{"filename": "YY.Build.Cross.Tasks/OSX/Ld.cs", "chunked_list": ["\ufeffusing Microsoft.Build.CPPTasks;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace YY.Build.Cross.Tasks.OSX\n{\n    public class Ld : YY.Build.Cross.Tasks.Cross.Ld\n    {\n        public Ld()\n            : base()\n        {\n            // \u82f9\u679c\u81ea\u5e26\u7684ld\u4e0d\u652f\u6301\u8fd9\u51e0\u4e2a\u9009\u9879\n            SwitchOrderList.Remove(\"Relocation\");\n            SwitchOrderList.Remove(\"FunctionBinding\");\n            SwitchOrderList.Remove(\"NoExecStackRequired\");\n            SwitchOrderList.Remove(\"ShowProgress\");\n            SwitchOrderList.Remove(\"LinkStatus\");\n\n            var Index = SwitchOrderList.IndexOf(\"AdditionalOptions\");\n            SwitchOrderList.Insert(Index++, \"FlatNamespace\");\n            SwitchOrderList.Insert(Index++, \"Frameworks\");\n        }\n", "    public class Ld : YY.Build.Cross.Tasks.Cross.Ld\n    {\n        public Ld()\n            : base()\n        {\n            // \u82f9\u679c\u81ea\u5e26\u7684ld\u4e0d\u652f\u6301\u8fd9\u51e0\u4e2a\u9009\u9879\n            SwitchOrderList.Remove(\"Relocation\");\n            SwitchOrderList.Remove(\"FunctionBinding\");\n            SwitchOrderList.Remove(\"NoExecStackRequired\");\n            SwitchOrderList.Remove(\"ShowProgress\");\n            SwitchOrderList.Remove(\"LinkStatus\");\n\n            var Index = SwitchOrderList.IndexOf(\"AdditionalOptions\");\n            SwitchOrderList.Insert(Index++, \"FlatNamespace\");\n            SwitchOrderList.Insert(Index++, \"Frameworks\");\n        }\n", "        public override bool UnresolvedSymbolReferences\n        {\n            get\n            {\n                if (IsPropertySet(\"UnresolvedSymbolReferences\"))\n                {\n                    return base.ActiveToolSwitches[\"UnresolvedSymbolReferences\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"UnresolvedSymbolReferences\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Report Unresolved Symbol References\";\n                toolSwitch.Description = \"This option when enabled will report unresolved symbol references.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                // toolSwitch.SwitchValue = \"-Wl,--no-undefined\";\n                toolSwitch.SwitchValue = \"-Wl,-undefined,error\";\n                toolSwitch.Name = \"UnresolvedSymbolReferences\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"UnresolvedSymbolReferences\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool FlatNamespace\n        {\n            get\n            {\n                if (IsPropertySet(\"FlatNamespace\"))\n                {\n                    return base.ActiveToolSwitches[\"FlatNamespace\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"FlatNamespace\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"\u542f\u7528\u4e00\u7ea7\u547d\u540d\";\n                toolSwitch.Description = \"\u5982\u679c\u5173\u95ed\u5219\u4fdd\u5b58\u9ed8\u8ba4\uff0c\u9ed8\u8ba4\u503c\u4e3a\u4e8c\u7ea7\u547d\u540d\uff08two_levelnamespace\uff09\u3002\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-Wl,-flat_namespace\";\n                toolSwitch.Name = \"FlatNamespace\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"FlatNamespace\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n\n        public string[] Frameworks\n        {\n            get\n            {", "                if (IsPropertySet(\"Frameworks\"))\n                {\n                    return base.ActiveToolSwitches[\"Frameworks\"].StringList;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"Frameworks\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);\n                toolSwitch.DisplayName = \"\u4f9d\u8d56\u7684Framework\";\n                toolSwitch.Description = \"Apple\u7279\u6709\u7684Framework\u5f15\u7528\uff08-framework\uff09\u3002\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-framework \";\n                toolSwitch.Name = \"Frameworks\";\n                toolSwitch.StringList = value;\n                base.ActiveToolSwitches.Add(\"Frameworks\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n    }\n}\n"]}
{"filename": "YY.Build.Cross.Tasks/OSX/Compile.cs", "chunked_list": ["\ufeffusing Microsoft.Build.Framework;\nusing Microsoft.Build.Utilities;\nusing System.Collections;\nusing Microsoft.Build.CPPTasks;\nusing Microsoft.Build.Framework;\n// using Microsoft.Build.Linux.Shared;\n// using Microsoft.Build.Linux.Tasks;\nusing Microsoft.Build.Utilities;\nusing System.Resources;\nusing Microsoft.Build.Shared;", "using System.Resources;\nusing Microsoft.Build.Shared;\nusing System.Text;\nusing System;\n\nnamespace YY.Build.Cross.Tasks.OSX\n{\n    public class Compile : YY.Build.Cross.Tasks.Cross.Compile\n    {\n        public Compile()\n            : base()\n        {\n            var Index = SwitchOrderList.IndexOf(\"AdditionalOptions\");\n            SwitchOrderList.Insert(Index++, \"ObjCAutomaticRefCounting\");\n            SwitchOrderList.Insert(Index++, \"ObjCAutomaticRefCountingExceptionHandlingSafe\");\n            SwitchOrderList.Insert(Index++, \"ObjCExceptionHandling\");\n        }\n\n        // OSX \u6dfb\u52a0ObjectC \u4ee5\u53caObjectC++\u652f\u6301", "        public virtual string CompileAs\n        {\n            get\n            {\n                if (IsPropertySet(\"CompileAs\"))\n                {\n                    return base.ActiveToolSwitches[\"CompileAs\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"CompileAs\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.DisplayName = \"Compile As\";\n                toolSwitch.Description = \"Select compile language option for .c and .cpp files.  'Default' will detect based on .c or .cpp extention. (-x c, -x c++)\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                string[][] switchMap = new string[][]\n                {\n                    new string[2] { \"Default\", \"\" },\n                    new string[2] { \"CompileAsC\", \"-x c\" },\n                    new string[2] { \"CompileAsCpp\", \"-x c++\" },\n                    new string[2] { \"CompileAsObjC\", \"-x objective-c\" },\n                    new string[2] { \"CompileAsObjCpp\", \"-x objective-c++\" }\n                };\n                toolSwitch.SwitchValue = ReadSwitchMap(\"CompileAs\", switchMap, value);\n                toolSwitch.Name = \"CompileAs\";\n                toolSwitch.Value = value;\n                toolSwitch.MultipleValues = true;\n                base.ActiveToolSwitches.Add(\"CompileAs\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool ObjCAutomaticRefCounting\n        {\n            get\n            {\n                if (IsPropertySet(\"ObjCAutomaticRefCounting\"))\n                {\n                    return base.ActiveToolSwitches[\"ObjCAutomaticRefCounting\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"ObjCAutomaticRefCounting\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Object-C Automatic Reference Counting\";\n                toolSwitch.Description = \"Synthesize retain and release calls for Objective-C pointers\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-fobjc-arc\";\n                toolSwitch.Name = \"ObjCAutomaticRefCounting\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"ObjCAutomaticRefCounting\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool ObjCAutomaticRefCountingExceptionHandlingSafe\n        {\n            get\n            {\n                if (IsPropertySet(\"ObjCAutomaticRefCountingExceptionHandlingSafe\"))\n                {\n                    return base.ActiveToolSwitches[\"ObjCAutomaticRefCountingExceptionHandlingSafe\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"ObjCAutomaticRefCountingExceptionHandlingSafe\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Object-C Automatic Reference Counting Except Handle Safe\";\n                toolSwitch.Description = \"Use EH-safe code when synthesizing retains and releases in -fobjc-arc.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-fobjc-arc-exceptions\";\n                toolSwitch.Name = \"ObjCAutomaticRefCountingExceptionHandlingSafe\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"ObjCAutomaticRefCountingExceptionHandlingSafe\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public string ObjCExceptionHandling\n        {\n            get\n            {\n                if (IsPropertySet(\"ObjCExceptionHandling\"))\n                {\n                    return base.ActiveToolSwitches[\"ObjCExceptionHandling\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"ObjCExceptionHandling\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.DisplayName = \"ObjC Exception Handling\";\n                toolSwitch.Description = \"Enable Objective-C exceptions.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                string[][] switchMap = new string[][]\n                {\n                    new string[2] { \"Disabled\", \"\" },\n                    new string[2] { \"Enabled\", \"-fobjc-exceptions\" }\n                };\n                toolSwitch.SwitchValue = ReadSwitchMap(\"ObjCExceptionHandling\", switchMap, value);\n                toolSwitch.Name = \"ObjCExceptionHandling\";\n                toolSwitch.Value = value;\n                toolSwitch.MultipleValues = true;\n                base.ActiveToolSwitches.Add(\"ObjCExceptionHandling\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        protected override void ValidateRelations()\n        {\n            if(!ObjCAutomaticRefCounting)\n            {\n                base.ActiveToolSwitches.Remove(\"ObjCAutomaticRefCountingExceptionHandlingSafe\");\n            }\n        }\n    }\n}"]}
{"filename": "YY.Build.Cross.Tasks/Cross/Ld.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.Build.Framework;\nusing Microsoft.Build.CPPTasks;\nusing Microsoft.Build.Framework;\n// using Microsoft.Build.Linux.Shared;", "using Microsoft.Build.Framework;\n// using Microsoft.Build.Linux.Shared;\n// using Microsoft.Build.Linux.Tasks;\nusing Microsoft.Build.Utilities;\nusing System.Text.RegularExpressions;\nusing Microsoft.Build.Shared;\nusing System.IO;\n\nnamespace YY.Build.Cross.Tasks.Cross\n{\n    public class Ld : TrackedVCToolTask\n    {\n        public Ld()\n            : base(Microsoft.Build.CppTasks.Common.Properties.Microsoft_Build_CPPTasks_Strings.ResourceManager)\n        {\n            switchOrderList = new ArrayList();\n            switchOrderList.Add(\"OutputFile\");\n            switchOrderList.Add(\"LinkStatus\");\n            switchOrderList.Add(\"Version\");\n            switchOrderList.Add(\"ShowProgress\");\n            switchOrderList.Add(\"Trace\");\n            switchOrderList.Add(\"TraceSymbols\");\n            switchOrderList.Add(\"GenerateMapFile\");\n            switchOrderList.Add(\"UnresolvedSymbolReferences\");\n            switchOrderList.Add(\"OptimizeforMemory\");\n            switchOrderList.Add(\"SharedLibrarySearchPath\");\n            switchOrderList.Add(\"AdditionalLibraryDirectories\");\n            switchOrderList.Add(\"IgnoreSpecificDefaultLibraries\");\n            switchOrderList.Add(\"IgnoreDefaultLibraries\");\n            switchOrderList.Add(\"ForceUndefineSymbolReferences\");\n            switchOrderList.Add(\"DebuggerSymbolInformation\");\n            switchOrderList.Add(\"MapFileName\");\n            switchOrderList.Add(\"Relocation\");\n            switchOrderList.Add(\"FunctionBinding\");\n            switchOrderList.Add(\"NoExecStackRequired\");\n            switchOrderList.Add(\"TargetArch\");\n            switchOrderList.Add(\"SysRoot\");\n            switchOrderList.Add(\"LinkDll\");\n            switchOrderList.Add(\"WholeArchiveBegin\");\n            switchOrderList.Add(\"AdditionalOptions\");\n            switchOrderList.Add(\"Sources\");\n            switchOrderList.Add(\"AdditionalDependencies\");\n            switchOrderList.Add(\"WholeArchiveEnd\");\n            switchOrderList.Add(\"LibraryDependencies\");\n            switchOrderList.Add(\"BuildingInIde\");\n            switchOrderList.Add(\"EnableASAN\");\n            switchOrderList.Add(\"UseOfStl\");\n            errorListRegexList.Add(_fileLineTextExpression);\n        }\n", "namespace YY.Build.Cross.Tasks.Cross\n{\n    public class Ld : TrackedVCToolTask\n    {\n        public Ld()\n            : base(Microsoft.Build.CppTasks.Common.Properties.Microsoft_Build_CPPTasks_Strings.ResourceManager)\n        {\n            switchOrderList = new ArrayList();\n            switchOrderList.Add(\"OutputFile\");\n            switchOrderList.Add(\"LinkStatus\");\n            switchOrderList.Add(\"Version\");\n            switchOrderList.Add(\"ShowProgress\");\n            switchOrderList.Add(\"Trace\");\n            switchOrderList.Add(\"TraceSymbols\");\n            switchOrderList.Add(\"GenerateMapFile\");\n            switchOrderList.Add(\"UnresolvedSymbolReferences\");\n            switchOrderList.Add(\"OptimizeforMemory\");\n            switchOrderList.Add(\"SharedLibrarySearchPath\");\n            switchOrderList.Add(\"AdditionalLibraryDirectories\");\n            switchOrderList.Add(\"IgnoreSpecificDefaultLibraries\");\n            switchOrderList.Add(\"IgnoreDefaultLibraries\");\n            switchOrderList.Add(\"ForceUndefineSymbolReferences\");\n            switchOrderList.Add(\"DebuggerSymbolInformation\");\n            switchOrderList.Add(\"MapFileName\");\n            switchOrderList.Add(\"Relocation\");\n            switchOrderList.Add(\"FunctionBinding\");\n            switchOrderList.Add(\"NoExecStackRequired\");\n            switchOrderList.Add(\"TargetArch\");\n            switchOrderList.Add(\"SysRoot\");\n            switchOrderList.Add(\"LinkDll\");\n            switchOrderList.Add(\"WholeArchiveBegin\");\n            switchOrderList.Add(\"AdditionalOptions\");\n            switchOrderList.Add(\"Sources\");\n            switchOrderList.Add(\"AdditionalDependencies\");\n            switchOrderList.Add(\"WholeArchiveEnd\");\n            switchOrderList.Add(\"LibraryDependencies\");\n            switchOrderList.Add(\"BuildingInIde\");\n            switchOrderList.Add(\"EnableASAN\");\n            switchOrderList.Add(\"UseOfStl\");\n            errorListRegexList.Add(_fileLineTextExpression);\n        }\n", "        private ArrayList switchOrderList;\n\n        protected override ArrayList SwitchOrderList => switchOrderList;\n\n        private static Regex _fileLineTextExpression = new Regex(\"^\\\\s*(?<FILENAME>[^:]*):(((?<LINE>\\\\d*):)?)(\\\\s*(?<CATEGORY>(fatal error|error|warning|note)):)?\\\\s*(?<TEXT>.*)$\", RegexOptions.IgnoreCase | RegexOptions.Compiled, TimeSpan.FromMilliseconds(100.0));\n\n        protected override string ToolName => \"ld\";\n\n        protected override ITaskItem[] TrackedInputFiles => Sources;\n\n        protected override bool MaintainCompositeRootingMarkers => true;\n", "        protected override ITaskItem[] TrackedInputFiles => Sources;\n\n        protected override bool MaintainCompositeRootingMarkers => true;\n\n        protected override string CommandTLogName\n        {\n            get\n            {\n                return \"ld.\" + base.CommandTLogName;\n            }\n        }\n", "        public string OutputFile\n        {\n            get\n            {\n                if (IsPropertySet(\"OutputFile\"))\n                {\n                    return base.ActiveToolSwitches[\"OutputFile\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"OutputFile\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);\n                toolSwitch.DisplayName = \"Output File\";\n                toolSwitch.Description = \"The option overrides the default name and location of the program that the linker creates. (-o)\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-o \";\n                toolSwitch.Name = \"OutputFile\";\n                toolSwitch.Value = value;\n                base.ActiveToolSwitches.Add(\"OutputFile\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool LinkStatus\n        {\n            get\n            {\n                if (IsPropertySet(\"LinkStatus\"))\n                {\n                    return base.ActiveToolSwitches[\"LinkStatus\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"LinkStatus\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"LinkStatus\";\n                toolSwitch.Description = \"Prints Linker Progress Messages.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-Wl,--stats\";\n                toolSwitch.Name = \"LinkStatus\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"LinkStatus\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool Version\n        {\n            get\n            {\n                if (IsPropertySet(\"Version\"))\n                {\n                    return base.ActiveToolSwitches[\"Version\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"Version\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Version\";\n                toolSwitch.Description = \"The -version option tells the linker to put a version number in the header of the executable.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-Wl,--version\";\n                toolSwitch.Name = \"Version\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"Version\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public string ShowProgress\n        {\n            get\n            {\n                if (IsPropertySet(\"ShowProgress\"))\n                {\n                    return base.ActiveToolSwitches[\"ShowProgress\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"ShowProgress\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.DisplayName = \"Show Progress\";\n                toolSwitch.Description = \"Prints Linker Progress Messages.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                // toolSwitch.SwitchValue = \"-Wl,--stats\";\n                string[][] switchMap = new string[][]\n                {\n                    new string[2] { \"NotSet\", \"\" },\n                    new string[2] { \"LinkVerbose\", \"-Wl,--verbose\" },\n                    new string[2] { \"LinkVerboseLib\", \"\" },\n                    new string[2] { \"LinkVerboseICF\", \"\" }, // \u4ec5\u517c\u5bb9MSVC\u9700\u8981\n                    new string[2] { \"LinkVerboseREF\", \"\" }, // \u4ec5\u517c\u5bb9MSVC\u9700\u8981\n                    new string[2] { \"LinkVerboseSAFESEH\", \"\" }, // \u4ec5\u517c\u5bb9MSVC\u9700\u8981\n                    new string[2] { \"LinkVerboseCLR\", \"\" }, // \u4ec5\u517c\u5bb9MSVC\u9700\u8981\n\n                    // Linux\u5de5\u5177\u96c6\u517c\u5bb9\n                    new string[2] { \"true\", \"-Wl,--stats\" },\n                    new string[2] { \"false\", \"\" },\n                };\n\n                toolSwitch.SwitchValue = ReadSwitchMap(\"ShowProgress\", switchMap, value);\n                toolSwitch.Name = \"ShowProgress\";\n                toolSwitch.Value = value;\n                toolSwitch.MultipleValues = true;\n                base.ActiveToolSwitches.Add(\"ShowProgress\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n\n        // \u4ec5\u517c\u5bb9Linux\u5de5\u5177\u96c6", "        public bool Trace\n        {\n            get\n            {\n                if (IsPropertySet(\"Trace\"))\n                {\n                    return base.ActiveToolSwitches[\"Trace\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"Trace\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Trace\";\n                toolSwitch.Description = \"The --trace option tells the linker to output the input files as are processed.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                // XCode\u7684ld\u4e0d\u652f\u6301 `--trace`\uff0c\u4f46\u662f\u652f\u6301 `-t`\n                // Linux\u4e0b\u7684ld\u80fd\u540c\u65f6\u652f\u6301 `--trace` \u4e0e `-t`\n                // \u6240\u4ee5\u6211\u4eec\u6700\u7ec8\u6539\u6210 -t\n                // toolSwitch.SwitchValue = \"-Wl,--trace\";\n                toolSwitch.SwitchValue = \"-Wl,-t\";\n                toolSwitch.Name = \"Trace\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"Trace\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n\n        public string[] TraceSymbols\n        {\n            get\n            {", "                if (IsPropertySet(\"TraceSymbols\"))\n                {\n                    return base.ActiveToolSwitches[\"TraceSymbols\"].StringList;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"TraceSymbols\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);\n                toolSwitch.DisplayName = \"Trace Symbols\";\n                toolSwitch.Description = \"Print the list of files in which a symbol appears. (--trace-symbol=symbol)\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-Wl,--trace-symbol=\";\n                toolSwitch.Name = \"TraceSymbols\";\n                toolSwitch.StringList = value;\n                base.ActiveToolSwitches.Add(\"TraceSymbols\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool GenerateMapFile\n        {\n            get\n            {\n                if (IsPropertySet(\"GenerateMapFile\"))\n                {\n                    return base.ActiveToolSwitches[\"GenerateMapFile\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"GenerateMapFile\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Print Map\";\n                toolSwitch.Description = \"The --print-map option tells the linker to output a link map.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-Wl,--print-map\";\n                toolSwitch.Name = \"GenerateMapFile\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"GenerateMapFile\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool UnresolvedSymbolReferences\n        {\n            get\n            {\n                if (IsPropertySet(\"UnresolvedSymbolReferences\"))\n                {\n                    return base.ActiveToolSwitches[\"UnresolvedSymbolReferences\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"UnresolvedSymbolReferences\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Report Unresolved Symbol References\";\n                toolSwitch.Description = \"This option when enabled will report unresolved symbol references.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-Wl,--no-undefined\";\n                toolSwitch.Name = \"UnresolvedSymbolReferences\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"UnresolvedSymbolReferences\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool OptimizeforMemory\n        {\n            get\n            {\n                if (IsPropertySet(\"OptimizeforMemory\"))\n                {\n                    return base.ActiveToolSwitches[\"OptimizeforMemory\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"OptimizeforMemory\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Optimize For Memory Usage\";\n                toolSwitch.Description = \"Optimize for memory usage, by rereading the symbol tables as necessary.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-Wl,--no-keep-memory\";\n                toolSwitch.Name = \"OptimizeforMemory\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"OptimizeforMemory\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual string[] SharedLibrarySearchPath\n        {\n            get\n            {\n                if (IsPropertySet(\"SharedLibrarySearchPath\"))\n                {\n                    return base.ActiveToolSwitches[\"SharedLibrarySearchPath\"].StringList;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"SharedLibrarySearchPath\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringPathArray);\n                toolSwitch.DisplayName = \"Shared Library Search Path\";\n                toolSwitch.Description = \"Allows the user to populate the shared library search path.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-Wl,-rpath-link=\";\n                toolSwitch.Name = \"SharedLibrarySearchPath\";\n                toolSwitch.StringList = value;\n                base.ActiveToolSwitches.Add(\"SharedLibrarySearchPath\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual string[] AdditionalLibraryDirectories\n        {\n            get\n            {\n                if (IsPropertySet(\"AdditionalLibraryDirectories\"))\n                {\n                    return base.ActiveToolSwitches[\"AdditionalLibraryDirectories\"].StringList;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"AdditionalLibraryDirectories\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringPathArray);\n                toolSwitch.DisplayName = \"Additional Library Directories\";\n                toolSwitch.Description = \"Allows the user to override the environmental library path. (-L folder).\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-Wl,-L\";\n                toolSwitch.Name = \"AdditionalLibraryDirectories\";\n                toolSwitch.StringList = value;\n                base.ActiveToolSwitches.Add(\"AdditionalLibraryDirectories\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual string[] IgnoreSpecificDefaultLibraries\n        {\n            get\n            {\n                if (IsPropertySet(\"IgnoreSpecificDefaultLibraries\"))\n                {\n                    return base.ActiveToolSwitches[\"IgnoreSpecificDefaultLibraries\"].StringList;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"IgnoreSpecificDefaultLibraries\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);\n                toolSwitch.DisplayName = \"Ignore Specific Default Libraries\";\n                toolSwitch.Description = \"Specifies one or more names of default libraries to ignore.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-Wl,--exclude-libs=\";\n                toolSwitch.Name = \"IgnoreSpecificDefaultLibraries\";\n                toolSwitch.StringList = value;\n                base.ActiveToolSwitches.Add(\"IgnoreSpecificDefaultLibraries\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool IgnoreDefaultLibraries\n        {\n            get\n            {\n                if (IsPropertySet(\"IgnoreDefaultLibraries\"))\n                {\n                    return base.ActiveToolSwitches[\"IgnoreDefaultLibraries\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"IgnoreDefaultLibraries\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Ignore Default Libraries\";\n                toolSwitch.Description = \"Ignore default libraries and only search libraries explicitely specified.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"--Wl,-nostdlib\";\n                toolSwitch.Name = \"IgnoreDefaultLibraries\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"IgnoreDefaultLibraries\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual string[] ForceUndefineSymbolReferences\n        {\n            get\n            {\n                if (IsPropertySet(\"ForceUndefineSymbolReferences\"))\n                {\n                    return base.ActiveToolSwitches[\"ForceUndefineSymbolReferences\"].StringList;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"ForceUndefineSymbolReferences\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);\n                toolSwitch.DisplayName = \"Force Symbol References\";\n                toolSwitch.Description = \"Force symbol to be entered in the output file as an undefined symbol.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-Wl,-u--undefined=\";\n                toolSwitch.Name = \"ForceUndefineSymbolReferences\";\n                toolSwitch.StringList = value;\n                base.ActiveToolSwitches.Add(\"ForceUndefineSymbolReferences\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual string DebuggerSymbolInformation\n        {\n            get\n            {\n                if (IsPropertySet(\"DebuggerSymbolInformation\"))\n                {\n                    return base.ActiveToolSwitches[\"DebuggerSymbolInformation\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"DebuggerSymbolInformation\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.DisplayName = \"Debugger Symbol Information\";\n                toolSwitch.Description = \"Debugger symbol information from the output file.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                string[][] switchMap = new string[5][]\n                {\n                    new string[2] { \"true\", \"\" },\n                    new string[2] { \"false\", \"\" },\n                    new string[2] { \"IncludeAll\", \"\" },\n                    new string[2] { \"OmitDebuggerSymbolInformation\", \"-Wl,--strip-debug\" },\n                    new string[2] { \"OmitAllSymbolInformation\", \"-Wl,--strip-all\" }\n                };\n                toolSwitch.SwitchValue = ReadSwitchMap(\"DebuggerSymbolInformation\", switchMap, value);\n                toolSwitch.Name = \"DebuggerSymbolInformation\";\n                toolSwitch.Value = value;\n                toolSwitch.MultipleValues = true;\n                base.ActiveToolSwitches.Add(\"DebuggerSymbolInformation\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual string MapFileName\n        {\n            get\n            {\n                if (IsPropertySet(\"MapFileName\"))\n                {\n                    return base.ActiveToolSwitches[\"MapFileName\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"MapFileName\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.DisplayName = \"Map File Name\";\n                toolSwitch.Description = \"The Map option tells the linker to create a map file with the user specified name.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.Name = \"MapFileName\";\n                toolSwitch.Value = value;\n                toolSwitch.SwitchValue = \"-Wl,-Map=\";\n                base.ActiveToolSwitches.Add(\"MapFileName\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool Relocation\n        {\n            get\n            {\n                if (IsPropertySet(\"Relocation\"))\n                {\n                    return base.ActiveToolSwitches[\"Relocation\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"Relocation\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Mark Variables ReadOnly After Relocation\";\n                toolSwitch.Description = \"This option marks variables read-only after relocation.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-Wl,-z,relro\";\n                toolSwitch.ReverseSwitchValue = \"-Wl,-z,norelro\";\n                toolSwitch.Name = \"Relocation\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"Relocation\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool FunctionBinding\n        {\n            get\n            {\n                if (IsPropertySet(\"FunctionBinding\"))\n                {\n                    return base.ActiveToolSwitches[\"FunctionBinding\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"FunctionBinding\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Enable Immediate Function Binding\";\n                toolSwitch.Description = \"This option marks object for immediate function binding.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-Wl,-z,now\";\n                toolSwitch.Name = \"FunctionBinding\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"FunctionBinding\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool NoExecStackRequired\n        {\n            get\n            {\n                if (IsPropertySet(\"NoExecStackRequired\"))\n                {\n                    return base.ActiveToolSwitches[\"NoExecStackRequired\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"NoExecStackRequired\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Executable Stack Not Required\";\n                toolSwitch.Description = \"This option marks output as not requiring executable stack.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-Wl,-z,noexecstack\";\n                toolSwitch.Name = \"NoExecStackRequired\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"NoExecStackRequired\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool LinkDll\n        {\n            get\n            {\n                if (IsPropertySet(\"LinkDll\"))\n                {\n                    return base.ActiveToolSwitches[\"LinkDll\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"LinkDll\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-shared\";\n                toolSwitch.Name = \"LinkDll\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"LinkDll\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool WholeArchiveBegin\n        {\n            get\n            {\n                if (IsPropertySet(\"WholeArchiveBegin\"))\n                {\n                    return base.ActiveToolSwitches[\"WholeArchiveBegin\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"WholeArchiveBegin\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Whole Archive\";\n                toolSwitch.Description = \"Whole Archive uses all code from Sources and Additional Dependencies.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-Wl,--whole-archive\";\n                toolSwitch.Name = \"WholeArchiveBegin\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"WholeArchiveBegin\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n\n        [Required]", "        public virtual ITaskItem[] Sources\n        {\n            get\n            {\n                if (IsPropertySet(\"Sources\"))\n                {\n                    return base.ActiveToolSwitches[\"Sources\"].TaskItemArray;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"Sources\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.ITaskItemArray);\n                toolSwitch.Separator = \" \";\n                toolSwitch.Required = true;\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.TaskItemArray = value;\n                base.ActiveToolSwitches.Add(\"Sources\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual string[] AdditionalDependencies\n        {\n            get\n            {\n                if (IsPropertySet(\"AdditionalDependencies\"))\n                {\n                    return base.ActiveToolSwitches[\"AdditionalDependencies\"].StringList;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"AdditionalDependencies\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);\n                toolSwitch.DisplayName = \"Additional Dependencies\";\n                toolSwitch.Description = \"Specifies additional items to add to the link command line.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.Name = \"AdditionalDependencies\";\n                toolSwitch.StringList = value;\n                base.ActiveToolSwitches.Add(\"AdditionalDependencies\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool WholeArchiveEnd\n        {\n            get\n            {\n                if (IsPropertySet(\"WholeArchiveEnd\"))\n                {\n                    return base.ActiveToolSwitches[\"WholeArchiveEnd\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"WholeArchiveEnd\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-Wl,--no-whole-archive\";\n                toolSwitch.Name = \"WholeArchiveEnd\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"WholeArchiveEnd\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual string[] LibraryDependencies\n        {\n            get\n            {\n                if (IsPropertySet(\"LibraryDependencies\"))\n                {\n                    return base.ActiveToolSwitches[\"LibraryDependencies\"].StringList;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"LibraryDependencies\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);\n                toolSwitch.DisplayName = \"Library Dependencies\";\n                toolSwitch.Description = \"This option allows specifying additional libraries to be  added to the linker command line. The additional library will be added to the end of the linker command line  prefixed with 'lib' and end with the '.a' extension.  (-lNAME)\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-l\";\n                toolSwitch.Name = \"LibraryDependencies\";\n                toolSwitch.StringList = value;\n                base.ActiveToolSwitches.Add(\"LibraryDependencies\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool BuildingInIde\n        {\n            get\n            {\n                if (IsPropertySet(\"BuildingInIde\"))\n                {\n                    return base.ActiveToolSwitches[\"BuildingInIde\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"BuildingInIde\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.Name = \"BuildingInIde\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"BuildingInIde\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool EnableASAN\n        {\n            get\n            {\n                if (IsPropertySet(\"EnableASAN\"))\n                {\n                    return base.ActiveToolSwitches[\"EnableASAN\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"EnableASAN\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Enable Address Sanitizer\";\n                toolSwitch.Description = \"Link program with AddressSanitizer. Must also compiler with AddressSanitizer enabled. Must run with debugger to view diagnostic results.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-fsanitize=address\";\n                toolSwitch.Name = \"EnableASAN\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"EnableASAN\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual string UseOfStl\n        {\n            get\n            {\n                if (IsPropertySet(\"UseOfStl\"))\n                {\n                    return base.ActiveToolSwitches[\"UseOfStl\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"UseOfStl\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                string[][] switchMap = new string[2][]\n                {\n                    new string[2] { \"libstdc++_shared\", \"\" },\n                    new string[2] { \"libstdc++_static\", \"-static-libstdc++\" }\n                };\n                toolSwitch.SwitchValue = ReadSwitchMap(\"UseOfStl\", switchMap, value);\n                toolSwitch.Name = \"UseOfStl\";\n                toolSwitch.Value = value;\n                toolSwitch.MultipleValues = true;\n                base.ActiveToolSwitches.Add(\"UseOfStl\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual string SysRoot\n        {\n            get\n            {\n                if (IsPropertySet(\"SysRoot\"))\n                {\n                    return base.ActiveToolSwitches[\"SysRoot\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"SysRoot\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.DisplayName = \"SysRoot\";\n                toolSwitch.Description = \"Folder path to the root directory for headers and libraries.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"--sysroot=\";\n                toolSwitch.Name = \"SysRoot\";\n                toolSwitch.Value = value;\n                base.ActiveToolSwitches.Add(\"SysRoot\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n\n        // \u4f8b\u5982 x86_64-linux-gnu\n        // \u6ce8\u610f\uff1a\u4ec5clang\u652f\u6301\uff0c\u5e76\u4e14\u6b64\u9009\u9879\u4f4d\u5185\u90e8\u8bbe\u7f6e\uff0c\u8ddf\u968fPlatformTriplet", "        public virtual string TargetArch\n        {\n            get\n            {\n                if (IsPropertySet(\"TargetArch\"))\n                {\n                    return base.ActiveToolSwitches[\"TargetArch\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"TargetArch\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.DisplayName = \"\u76ee\u6807\u4f53\u7cfb\u7ed3\u6784\";\n                toolSwitch.Description = \"\u76ee\u6807\u7684\u4f53\u7cfb\u7ed3\u6784\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.Name = \"TargetArch\";\n                toolSwitch.Value = value;\n                toolSwitch.SwitchValue = \"--target=\";\n                base.ActiveToolSwitches.Add(\"TargetArch\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        protected override string TrackerIntermediateDirectory\n        {\n            get\n            {\n                if (TrackerLogDirectory != null)\n                {\n                    return TrackerLogDirectory;\n                }\n                return string.Empty;\n            }\n        }\n", "        public virtual string TrackerLogDirectory\n        {\n            get\n            {\n                if (IsPropertySet(\"TrackerLogDirectory\"))\n                {\n                    return base.ActiveToolSwitches[\"TrackerLogDirectory\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"TrackerLogDirectory\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Directory);\n                toolSwitch.DisplayName = \"Tracker Log Directory\";\n                toolSwitch.Description = \"Tracker log directory.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.Value = VCToolTask.EnsureTrailingSlash(value);\n                base.ActiveToolSwitches.Add(\"TrackerLogDirectory\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n\n        private HashSet<string> ReadObjectFiles;\n        private bool? PrintTrace;\n", "        protected override void ValidateRelations()\n        {\n            if(PrintTrace == null)\n            {\n                PrintTrace = Trace;\n\n                if (GenerateMapFile)\n                    MinimalRebuildFromTracking = false;\n\n                if (MinimalRebuildFromTracking && IsPropertySet(\"ShowProgress\"))\n                {", "                if (MinimalRebuildFromTracking && IsPropertySet(\"ShowProgress\"))\n                {\n                    if(base.ActiveToolSwitches[\"ShowProgress\"].SwitchValue.Length !=0)\n                    {\n                        MinimalRebuildFromTracking = false;\n                    }\n                }\n\n                // \u56e0\u4e3a\u6700\u5c0f\u6784\u5efa\u5fc5\u987b\u8981\u6c42\u5f00\u542f Trace\uff0c\u5426\u5219\u65e0\u6cd5\u8ddf\u8e2a\u4f9d\u8d56\u7684\u4f7f\u7528\u60c5\u51b5\u3002\n                if (MinimalRebuildFromTracking && Trace == false)\n                    Trace = true;\n            }\n        }\n", "                if (MinimalRebuildFromTracking && Trace == false)\n                    Trace = true;\n            }\n        }\n\n        protected override int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands)\n        {\n            ReadObjectFiles = null;\n\n            if (MinimalRebuildFromTracking == true)\n            {\n                ReadObjectFiles = new HashSet<string>();\n            }\n\n            return base.ExecuteTool(pathToTool, responseFileCommands, commandLineCommands);\n        }\n", "            if (MinimalRebuildFromTracking == true)\n            {\n                ReadObjectFiles = new HashSet<string>();\n            }\n\n            return base.ExecuteTool(pathToTool, responseFileCommands, commandLineCommands);\n        }\n\n        protected override void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance)\n        {\n            do\n            {", "        protected override void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance)\n        {\n            do\n            {\n                if (StandardOutputImportanceToUse != messageImportance)\n                    break;\n\n                if (ReadObjectFiles == null)\n                    break;\n\n                if (singleLine.Length == 0)\n                    break;\n", "                if (singleLine.Length == 0)\n                    break;\n\n                if(singleLine[0] != '/' || singleLine.Contains(\": \"))\n                    break;\n\n                try\n                {\n                    var ObjPath = FileUtilities.NormalizePath(singleLine);\n                    ReadObjectFiles.Add(ObjPath);\n                    // Trace\u5982\u679c\u672c\u8eab\u6ca1\u6709\u5f00\u542f\uff0c\u90a3\u4e48\u4e0d\u5411\u5176\u8f93\u51fa\u641c\u7d22\u5185\u5bb9\uff0c\u907f\u514d\u5185\u5bb9\u592a\u591a\u5f62\u6210\u5e72\u6270\u3002", "                    if (PrintTrace != null && PrintTrace == false)\n                        return;\n                } catch\n                {\n                }\n                \n            } while (false);\n            \n            base.LogEventsFromTextOutput(singleLine, messageImportance);\n        }\n", "        protected override void SaveTracking()\n        {\n            string SourceKey = \"^\";\n\n            foreach (ITaskItem taskItem in Sources)\n            {\n                if (SourceKey.Length != 1)\n                    SourceKey += '|';\n\n                SourceKey += FileTracker.FormatRootingMarker(taskItem);\n            }\n\n            // \u4fdd\u5b58Write\u6587\u4ef6\n            {\n                string WriteFilePath = TLogWriteFiles[0].GetMetadata(\"FullPath\");\n                Directory.CreateDirectory(Path.GetDirectoryName(WriteFilePath));\n                using StreamWriter WriteFileWriter = FileUtilities.OpenWrite(WriteFilePath, append: true, Encoding.Unicode);\n\n                WriteFileWriter.WriteLine(SourceKey);\n                WriteFileWriter.WriteLine(OutputFile);\n            }\n\n            // \u4fdd\u5b58Read\u6587\u4ef6\n            {\n                string ReadFilePath = TLogReadFiles[0].GetMetadata(\"FullPath\");\n                Directory.CreateDirectory(Path.GetDirectoryName(ReadFilePath));\n                using StreamWriter ReadFileWriter = FileUtilities.OpenWrite(ReadFilePath, append: true, Encoding.Unicode);\n\n                ReadFileWriter.WriteLine(SourceKey);\n", "                foreach (var FilePath in ReadObjectFiles)\n                {\n                    ReadFileWriter.WriteLine(FilePath);\n                }\n            }\n        }\n    }\n}\n"]}
{"filename": "YY.Build.Cross.Tasks/Cross/Compile.cs", "chunked_list": ["\ufeffusing Microsoft.Build.Framework;\nusing Microsoft.Build.Utilities;\nusing System.Collections;\nusing Microsoft.Build.CPPTasks;\nusing Microsoft.Build.Framework;\n// using Microsoft.Build.Linux.Shared;\n// using Microsoft.Build.Linux.Tasks;\nusing Microsoft.Build.Utilities;\nusing System.Resources;\nusing Microsoft.Build.Shared;", "using System.Resources;\nusing Microsoft.Build.Shared;\nusing System.Text;\nusing System;\n\nnamespace YY.Build.Cross.Tasks.Cross\n{\n    public class Compile : TrackedVCToolTask\n    {\n        public Compile()\n            : base(Microsoft.Build.CppTasks.Common.Properties.Microsoft_Build_CPPTasks_Strings.ResourceManager)\n        {\n            UseCommandProcessor = false;\n\n            switchOrderList = new ArrayList();\n            switchOrderList.Add(\"AlwaysAppend\");\n            switchOrderList.Add(\"CompileAs\");\n            switchOrderList.Add(\"Sources\");\n            switchOrderList.Add(\"BuildingInIde\");\n            switchOrderList.Add(\"AdditionalIncludeDirectories\");\n            switchOrderList.Add(\"DebugInformationFormat\");\n            switchOrderList.Add(\"ObjectFileName\");\n            switchOrderList.Add(\"WarningLevel\");\n            switchOrderList.Add(\"TreatWarningAsError\");\n            switchOrderList.Add(\"AdditionalWarning\");\n            switchOrderList.Add(\"Verbose\");\n            switchOrderList.Add(\"Optimization\");\n            switchOrderList.Add(\"StrictAliasing\");\n            switchOrderList.Add(\"UnrollLoops\");\n            switchOrderList.Add(\"WholeProgramOptimization\");\n            switchOrderList.Add(\"OmitFramePointers\");\n            switchOrderList.Add(\"NoCommonBlocks\");\n            switchOrderList.Add(\"PreprocessorDefinitions\");\n            switchOrderList.Add(\"UndefinePreprocessorDefinitions\");\n            switchOrderList.Add(\"UndefineAllPreprocessorDefinitions\");\n            switchOrderList.Add(\"ShowIncludes\");\n            switchOrderList.Add(\"PositionIndependentCode\");\n            switchOrderList.Add(\"ThreadSafeStatics\");\n            switchOrderList.Add(\"FloatingPointModel\");\n            switchOrderList.Add(\"HideInlineMethods\");\n            switchOrderList.Add(\"SymbolsHiddenByDefault\");\n            switchOrderList.Add(\"ExceptionHandling\");\n            switchOrderList.Add(\"RuntimeTypeInfo\");\n            switchOrderList.Add(\"LanguageStandard_C\");\n            switchOrderList.Add(\"LanguageStandard\");\n            switchOrderList.Add(\"ForcedIncludeFiles\");\n            switchOrderList.Add(\"EnableASAN\");\n            switchOrderList.Add(\"AdditionalOptions\");\n            switchOrderList.Add(\"TargetArch\");\n            switchOrderList.Add(\"Sysroot\");\n            switchOrderList.Add(\"DependenceFile\");\n\n            base.IgnoreUnknownSwitchValues = true;\n        }\n", "        private bool PreprocessToFile = false;\n        private bool MinimalRebuild = false;\n\n        private ArrayList switchOrderList;\n\n        private Dictionary<string, ITaskItem> trackedInputFilesToRemove;\n\n        private Dictionary<string, ITaskItem> trackedOutputFilesToRemove;\n\n        protected override ArrayList SwitchOrderList => switchOrderList;\n", "        protected override ArrayList SwitchOrderList => switchOrderList;\n\n        protected override string ToolName => \"g++\";\n\n        protected override string AlwaysAppend => \"-c\";\n\n        protected override ITaskItem[] TrackedInputFiles => Sources;\n\n        protected override string TrackerIntermediateDirectory\n        {\n            get\n            {", "        protected override string TrackerIntermediateDirectory\n        {\n            get\n            {\n                if (TrackerLogDirectory != null)\n                {\n                    return TrackerLogDirectory;\n                }\n                return string.Empty;\n            }\n        }\n\n        private string[] objectFiles;\n\n        [Output]\n        public string[] ObjectFiles\n        {\n            get\n            {\n                return objectFiles;\n            }\n            set\n            {\n                objectFiles = value;\n            }\n        }\n\n        [Required]\n        public ITaskItem[] Sources\n        {\n            get\n            {", "                if (IsPropertySet(\"Sources\"))\n                {\n                    return base.ActiveToolSwitches[\"Sources\"].TaskItemArray;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"Sources\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.ITaskItemArray);\n                toolSwitch.Separator = \" \";\n                toolSwitch.Required = true;\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.TaskItemArray = value;\n                toolSwitch.TaskItemFullPath = true;\n                base.ActiveToolSwitches.Add(\"Sources\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n\n        public string[] AdditionalIncludeDirectories\n        {\n            get\n            {", "                if (IsPropertySet(\"AdditionalIncludeDirectories\"))\n                {\n                    return base.ActiveToolSwitches[\"AdditionalIncludeDirectories\"].StringList;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"AdditionalIncludeDirectories\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringPathArray);\n                toolSwitch.DisplayName = \"Additional Include Directories\";\n                toolSwitch.Description = \"Specifies one or more directories to add to the include path; separate with semi-colons if more than one. (-I[path]).\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-I \";\n                toolSwitch.Name = \"AdditionalIncludeDirectories\";\n                toolSwitch.StringList = value;\n                base.ActiveToolSwitches.Add(\"AdditionalIncludeDirectories\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual string DebugInformationFormat\n        {\n            get\n            {\n                if (IsPropertySet(\"DebugInformationFormat\"))\n                {\n                    return base.ActiveToolSwitches[\"DebugInformationFormat\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"DebugInformationFormat\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.DisplayName = \"Debug Information Format\";\n                toolSwitch.Description = \"Specifies the type of debugging information generated by the compiler.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                string[][] switchMap = new string[][]\n                {\n                    new string[2] { \"None\", \"-g0\" },\n                    new string[2] { \"OldStyle\", \"-g2 -gdwarf-2\" },\n                    new string[2] { \"ProgramDatabase\", \"-g2 -gdwarf-2\" },\n                    new string[2] { \"EditAndContinue\", \"-g2 -gdwarf-2\" },\n\n                    // Linux\u5de5\u5177\u96c6\u517c\u5bb9\n                    new string[2] { \"Minimal\", \"-g1\" },\n                    new string[2] { \"FullDebug\", \"-g2 -gdwarf-2\" }\n                };\n                toolSwitch.SwitchValue = ReadSwitchMap(\"DebugInformationFormat\", switchMap, value);\n                toolSwitch.Name = \"DebugInformationFormat\";\n                toolSwitch.Value = value;\n                toolSwitch.MultipleValues = true;\n                base.ActiveToolSwitches.Add(\"DebugInformationFormat\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public string ObjectFileName\n        {\n            get\n            {\n                if (IsPropertySet(\"ObjectFileName\"))\n                {\n                    return base.ActiveToolSwitches[\"ObjectFileName\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"ObjectFileName\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);\n                toolSwitch.DisplayName = \"Object File Name\";\n                toolSwitch.Description = \"Specifies a name to override the default object file name; can be file or directory name. (/Fo[name]).\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-o \";\n                toolSwitch.Name = \"ObjectFileName\";\n                toolSwitch.Value = value;\n                base.ActiveToolSwitches.Add(\"ObjectFileName\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public string WarningLevel\n        {\n            get\n            {\n                if (IsPropertySet(\"WarningLevel\"))\n                {\n                    return base.ActiveToolSwitches[\"WarningLevel\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"WarningLevel\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.DisplayName = \"Warning Level\";\n                toolSwitch.Description = \"Select how strict you want the compiler to be about code errors.  Other flags should be added directly to Additional Options. (/w, /Weverything).\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                string[][] switchMap = new string[][]\n                {\n                    new string[2] { \"TurnOffAllWarnings\", \"-w\" },\n                    new string[2] { \"Level1\", \"-Wall\" },\n                    new string[2] { \"Level2\", \"-Wall\" },\n                    new string[2] { \"Level3\", \"-Wall\" },\n                    new string[2] { \"Level4\", \"-Wall - Wextra\" },\n\n                    // \u5fae\u8f6fLinux\u5de5\u4f5c\u96c6\u9644\u5e26\uff0c\u987a\u9053\u517c\u5bb9\u4e00\u4e0b\u3002\n                    new string[2] { \"EnableAllWarnings\", \"-Wall\" },\n                };\n                toolSwitch.SwitchValue = ReadSwitchMap(\"WarningLevel\", switchMap, value);\n                toolSwitch.Name = \"WarningLevel\";\n                toolSwitch.Value = value;\n                toolSwitch.MultipleValues = true;\n                base.ActiveToolSwitches.Add(\"WarningLevel\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool TreatWarningAsError\n        {\n            get\n            {\n                if (IsPropertySet(\"TreatWarningAsError\"))\n                {\n                    return base.ActiveToolSwitches[\"TreatWarningAsError\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"TreatWarningAsError\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Treat Warnings As Errors\";\n                toolSwitch.Description = \"Treats all compiler warnings as errors. For a new project, it may be best to use /WX in all compilations; resolving all warnings will ensure the fewest possible hard-to-find code defects.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-Werror\";\n                toolSwitch.Name = \"TreatWarningAsError\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"TreatWarningAsError\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n\n        public string[] AdditionalWarning\n        {\n            get\n            {", "                if (IsPropertySet(\"AdditionalWarning\"))\n                {\n                    return base.ActiveToolSwitches[\"AdditionalWarning\"].StringList;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"AdditionalWarning\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);\n                toolSwitch.DisplayName = \"Additional Warnings\";\n                toolSwitch.Description = \"Defines a set of additional warning messages.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-W\";\n                toolSwitch.Name = \"AdditionalWarning\";\n                toolSwitch.StringList = value;\n                base.ActiveToolSwitches.Add(\"AdditionalWarning\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool Verbose\n        {\n            get\n            {\n                if (IsPropertySet(\"Verbose\"))\n                {\n                    return base.ActiveToolSwitches[\"Verbose\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"Verbose\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Enable Verbose mode\";\n                toolSwitch.Description = \"When Verbose mode is enabled, this tool would print out more information that for diagnosing the build.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-v\";\n                toolSwitch.Name = \"Verbose\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"Verbose\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public string Optimization\n        {\n            get\n            {\n                if (IsPropertySet(\"Optimization\"))\n                {\n                    return base.ActiveToolSwitches[\"Optimization\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"Optimization\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.DisplayName = \"Optimization\";\n                toolSwitch.Description = \"Specifies the optimization level for the application.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                string[][] switchMap = new string[5][]\n                {\n                    new string[2] { \"Custom\", \"\" },\n                    new string[2] { \"Disabled\", \"-O0\" },\n                    new string[2] { \"MinSize\", \"-Os\" },\n                    new string[2] { \"MaxSpeed\", \"-O2\" },\n                    new string[2] { \"Full\", \"-O3\" }\n                };\n                toolSwitch.SwitchValue = ReadSwitchMap(\"Optimization\", switchMap, value);\n                toolSwitch.Name = \"Optimization\";\n                toolSwitch.Value = value;\n                toolSwitch.MultipleValues = true;\n                base.ActiveToolSwitches.Add(\"Optimization\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool StrictAliasing\n        {\n            get\n            {\n                if (IsPropertySet(\"StrictAliasing\"))\n                {\n                    return base.ActiveToolSwitches[\"StrictAliasing\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"StrictAliasing\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Strict Aliasing\";\n                toolSwitch.Description = \"Assume the strictest aliasing rules.  An object of one type will never be assumed to reside at the same address as an object of a different type.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-fstrict-aliasing\";\n                toolSwitch.ReverseSwitchValue = \"-fno-strict-aliasing\";\n                toolSwitch.Name = \"StrictAliasing\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"StrictAliasing\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool UnrollLoops\n        {\n            get\n            {\n                if (IsPropertySet(\"UnrollLoops\"))\n                {\n                    return base.ActiveToolSwitches[\"UnrollLoops\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"UnrollLoops\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Unroll Loops\";\n                toolSwitch.Description = \"Unroll loops to make application faster by reducing number of branches executed at the cost of larger code size.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-funroll-all-loops\";\n                toolSwitch.Name = \"UnrollLoops\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"UnrollLoops\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool WholeProgramOptimization\n        {\n            get\n            {\n                if (IsPropertySet(\"WholeProgramOptimization\"))\n                {\n                    return base.ActiveToolSwitches[\"WholeProgramOptimization\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"WholeProgramOptimization\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Link Time Optimization\";\n                toolSwitch.Description = \"Enable Inter-Procedural optimizations by allowing the optimizer to look across object files in your application.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-flto\";\n                toolSwitch.Name = \"WholeProgramOptimization\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"WholeProgramOptimization\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool OmitFramePointers\n        {\n            get\n            {\n                if (IsPropertySet(\"OmitFramePointers\"))\n                {\n                    return base.ActiveToolSwitches[\"OmitFramePointers\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"OmitFramePointers\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Omit Frame Pointer\";\n                toolSwitch.Description = \"Suppresses creation of frame pointers on the call stack.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-fomit-frame-pointer\";\n                toolSwitch.ReverseSwitchValue = \"-fno-omit-frame-pointer\";\n                toolSwitch.Name = \"OmitFramePointers\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"OmitFramePointers\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool NoCommonBlocks\n        {\n            get\n            {\n                if (IsPropertySet(\"NoCommonBlocks\"))\n                {\n                    return base.ActiveToolSwitches[\"NoCommonBlocks\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"NoCommonBlocks\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"No Common Blocks\";\n                toolSwitch.Description = \"Allocate even unintialized global variables in the data section of the object file, rather then generating them as common blocks\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-fno-common\";\n                toolSwitch.Name = \"NoCommonBlocks\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"NoCommonBlocks\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n\n        public string[] PreprocessorDefinitions\n        {\n            get\n            {", "                if (IsPropertySet(\"PreprocessorDefinitions\"))\n                {\n                    return base.ActiveToolSwitches[\"PreprocessorDefinitions\"].StringList;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"PreprocessorDefinitions\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);\n                toolSwitch.DisplayName = \"Preprocessor Definitions\";\n                toolSwitch.Description = \"Defines a preprocessing symbols for your source file. (-D)\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-D\";\n                toolSwitch.Name = \"PreprocessorDefinitions\";\n                toolSwitch.StringList = value;\n                base.ActiveToolSwitches.Add(\"PreprocessorDefinitions\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n\n        public string[] UndefinePreprocessorDefinitions\n        {\n            get\n            {", "                if (IsPropertySet(\"UndefinePreprocessorDefinitions\"))\n                {\n                    return base.ActiveToolSwitches[\"UndefinePreprocessorDefinitions\"].StringList;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"UndefinePreprocessorDefinitions\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringArray);\n                toolSwitch.DisplayName = \"Undefine Preprocessor Definitions\";\n                toolSwitch.Description = \"Specifies one or more preprocessor undefines.  (-U [macro])\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-U\";\n                toolSwitch.Name = \"UndefinePreprocessorDefinitions\";\n                toolSwitch.StringList = value;\n                base.ActiveToolSwitches.Add(\"UndefinePreprocessorDefinitions\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool UndefineAllPreprocessorDefinitions\n        {\n            get\n            {\n                if (IsPropertySet(\"UndefineAllPreprocessorDefinitions\"))\n                {\n                    return base.ActiveToolSwitches[\"UndefineAllPreprocessorDefinitions\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"UndefineAllPreprocessorDefinitions\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Undefine All Preprocessor Definitions\";\n                toolSwitch.Description = \"Undefine all previously defined preprocessor values.  (-undef)\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-undef\";\n                toolSwitch.Name = \"UndefineAllPreprocessorDefinitions\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"UndefineAllPreprocessorDefinitions\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool ShowIncludes\n        {\n            get\n            {\n                if (IsPropertySet(\"ShowIncludes\"))\n                {\n                    return base.ActiveToolSwitches[\"ShowIncludes\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"ShowIncludes\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Show Includes\";\n                toolSwitch.Description = \"Generates a list of include files with compiler output.  (-H)\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-H\";\n                toolSwitch.Name = \"ShowIncludes\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"ShowIncludes\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool PositionIndependentCode\n        {\n            get\n            {\n                if (IsPropertySet(\"PositionIndependentCode\"))\n                {\n                    return base.ActiveToolSwitches[\"PositionIndependentCode\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"PositionIndependentCode\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Position Independent Code\";\n                toolSwitch.Description = \"Generate Position Independent Code (PIC) for use in a shared library.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-fpic\";\n                toolSwitch.Name = \"PositionIndependentCode\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"PositionIndependentCode\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool ThreadSafeStatics\n        {\n            get\n            {\n                if (IsPropertySet(\"ThreadSafeStatics\"))\n                {\n                    return base.ActiveToolSwitches[\"ThreadSafeStatics\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"ThreadSafeStatics\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Statics are thread safe\";\n                toolSwitch.Description = \"Emit Extra code to use routines specified in C++ ABI for thread safe initilization of local statics.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-fthreadsafe-statics\";\n                toolSwitch.ReverseSwitchValue = \"-fno-threadsafe-statics\";\n                toolSwitch.Name = \"ThreadSafeStatics\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"ThreadSafeStatics\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n\n        // \u7c7b\u4f3c\u4e8e\u5fae\u8f6fLinux\u5de5\u5177\u96c6\u7684RelaxIEEE\u3002", "        public string FloatingPointModel\n        {\n            get\n            {\n                if (IsPropertySet(\"FloatingPointModel\"))\n                {\n                    return base.ActiveToolSwitches[\"FloatingPointModel\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"FloatingPointModel\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"\u8bbe\u7f6e\u6d6e\u70b9\u6a21\u578b\";\n                toolSwitch.Description = \"\u8bbe\u7f6e\u6d6e\u70b9\u6a21\u578b\u3002\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                string[][] switchMap = new string[][]\n                {\n                    new string[2] { \"Precise\", \"\" },\n                    new string[2] { \"Strict\", \"\" },\n                    new string[2] { \"Fast\", \"-ffast-math\" },\n                };\n                toolSwitch.SwitchValue = ReadSwitchMap(\"FloatingPointModel\", switchMap, value);\n                toolSwitch.Name = \"FloatingPointModel\";\n                toolSwitch.Value = value;\n                toolSwitch.MultipleValues = true;\n                base.ActiveToolSwitches.Add(\"FloatingPointModel\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool HideInlineMethods\n        {\n            get\n            {\n                if (IsPropertySet(\"HideInlineMethods\"))\n                {\n                    return base.ActiveToolSwitches[\"HideInlineMethods\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"HideInlineMethods\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Inline Methods Hidden\";\n                toolSwitch.Description = \"When enabled, out-of-line copies of inline methods are declared 'private extern'.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-fvisibility-inlines-hidden\";\n                toolSwitch.Name = \"HideInlineMethods\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"HideInlineMethods\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool SymbolsHiddenByDefault\n        {\n            get\n            {\n                if (IsPropertySet(\"SymbolsHiddenByDefault\"))\n                {\n                    return base.ActiveToolSwitches[\"SymbolsHiddenByDefault\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"SymbolsHiddenByDefault\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Symbol Hiddens By Default\";\n                toolSwitch.Description = \"All symbols are declared 'private extern' unless explicitly marked to be exported using the '__attribute' macro.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-fvisibility=hidden\";\n                toolSwitch.Name = \"SymbolsHiddenByDefault\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"SymbolsHiddenByDefault\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public string ExceptionHandling\n        {\n            get\n            {\n                if (IsPropertySet(\"ExceptionHandling\"))\n                {\n                    return base.ActiveToolSwitches[\"ExceptionHandling\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"ExceptionHandling\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.DisplayName = \"Enable C++ Exceptions\";\n                toolSwitch.Description = \"Specifies the model of exception handling to be used by the compiler.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                string[][] switchMap = new string[][]\n                {\n                    // \u7279\u610f\u517c\u5bb9\u5fae\u8f6f\n                    new string[2] { \"false\", \"-fno-exceptions\" },\n                    new string[2] { \"Async\", \"-fexceptions\" },\n                    new string[2] { \"Sync\", \"-fexceptions\" },\n                    new string[2] { \"SyncCThrow\", \"-fexceptions\" },\n\n                    // \u5fae\u8f6fLinux\u5de5\u5177\u96c6\u9644\u5e26\uff0c\u987a\u9053\u4e5f\u517c\u5bb9\u4e00\u4e0b\u3002\n                    new string[2] { \"Disabled\", \"-fno-exceptions\" },\n                    new string[2] { \"Enabled\", \"-fexceptions\" }\n                };\n                toolSwitch.SwitchValue = ReadSwitchMap(\"ExceptionHandling\", switchMap, value);\n                toolSwitch.Name = \"ExceptionHandling\";\n                toolSwitch.Value = value;\n                toolSwitch.MultipleValues = true;\n                base.ActiveToolSwitches.Add(\"ExceptionHandling\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool RuntimeTypeInfo\n        {\n            get\n            {\n                if (IsPropertySet(\"RuntimeTypeInfo\"))\n                {\n                    return base.ActiveToolSwitches[\"RuntimeTypeInfo\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"RuntimeTypeInfo\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Enable Run-Time Type Information\";\n                toolSwitch.Description = \"Adds code for checking C++ object types at run time (runtime type information).     (frtti, fno-rtti)\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-frtti\";\n                toolSwitch.ReverseSwitchValue = \"-fno-rtti\";\n                toolSwitch.Name = \"RuntimeTypeInfo\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"RuntimeTypeInfo\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public string LanguageStandard_C\n        {\n            get\n            {\n                if (IsPropertySet(\"LanguageStandard_C\"))\n                {\n                    return base.ActiveToolSwitches[\"LanguageStandard_C\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"LanguageStandard_C\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.DisplayName = \"C Language Standard\";\n                toolSwitch.Description = \"Determines the C language standard.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                string[][] switchMap = new string[][]\n                {\n                    new string[2] { \"Default\", \"\" },\n                    new string[2] { \"stdc11\", \"-std=c11\" },\n                    new string[2] { \"stdc17\", \"-std=c17\" },\n\n                    // Linux\u5de5\u5177\u96c6\u517c\u5bb9\n                    new string[2] { \"c89\", \"-std=c89\" },\n                    new string[2] { \"gnu90\", \"-std=gnu90\" }, // \u9644\u52a0\n                    new string[2] { \"iso9899:199409\", \"-std=iso9899:199409\" },\n                    new string[2] { \"c99\", \"-std=c99\" },\n                    new string[2] { \"c11\", \"-std=c11\" },\n                    new string[2] { \"c2x\", \"-std=c2x\" }, // \u9644\u52a0\n                    new string[2] { \"gnu89\", \"-std=gnu89\" },\n                    new string[2] { \"gnu99\", \"-std=gnu99\" },\n                    new string[2] { \"gnu11\", \"-std=gnu11\" },\n                    new string[2] { \"gnu17\", \"-std=gnu17\" }, // \u9644\u52a0\n                };\n                toolSwitch.SwitchValue = ReadSwitchMap(\"LanguageStandard_C\", switchMap, value);\n                toolSwitch.Name = \"LanguageStandard_C\";\n                toolSwitch.Value = value;\n                toolSwitch.MultipleValues = true;\n                base.ActiveToolSwitches.Add(\"LanguageStandard_C\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public string LanguageStandard\n        {\n            get\n            {\n                if (IsPropertySet(\"LanguageStandard\"))\n                {\n                    return base.ActiveToolSwitches[\"LanguageStandard\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"LanguageStandard\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.DisplayName = \"C++ Language Standard\";\n                toolSwitch.Description = \"Determines the C++ language standard.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                string[][] switchMap = new string[][]\n                {\n                    new string[2] { \"Default\", \"\" },\n                    new string[2] { \"stdcpp14\", \"-std=c++14\" },\n                    new string[2] { \"stdcpp17\", \"-std=c++17\" },\n                    new string[2] { \"stdcpp20\", \"-std=c++20\" },\n                    new string[2] { \"stdcpplatest\", \"-std=c++2b\" },\n\n                    // Linux\u5de5\u5177\u96c6\u517c\u5bb9\n                    new string[2] { \"c++98\", \"-std=c++98\" },\n                    new string[2] { \"c++03\", \"-std=c++03\" },\n                    new string[2] { \"c++11\", \"-std=c++11\" },\n                    new string[2] { \"c++1y\", \"-std=c++14\" },\n                    new string[2] { \"c++14\", \"-std=c++14\" },\n                    new string[2] { \"c++17\", \"-std=c++17\" },\n                    new string[2] { \"c++2a\", \"-std=c++2a\" },\n                    new string[2] { \"c++20\", \"-std=c++20\" },\n                    new string[2] { \"c++2b\", \"-std=c++2b\" }, // \u9644\u52a0\n                    new string[2] { \"gnu++98\", \"-std=gnu++98\" },\n                    new string[2] { \"gnu++03\", \"-std=gnu++03\" },\n                    new string[2] { \"gnu++11\", \"-std=gnu++11\" },\n                    new string[2] { \"gnu++1y\", \"-std=gnu++1y\" },\n                    new string[2] { \"gnu++14\", \"-std=gnu++14\" },\n                    new string[2] { \"gnu++1z\", \"-std=gnu++1z\" },\n                    new string[2] { \"gnu++17\", \"-std=gnu++17\" },\n                    new string[2] { \"gnu++20\", \"-std=gnu++20\" },\n                    new string[2] { \"gnu++2b\", \"-std=gnu++2b\" }, // \u9644\u52a0\n                };\n                toolSwitch.SwitchValue = ReadSwitchMap(\"LanguageStandard\", switchMap, value);\n                toolSwitch.Name = \"LanguageStandard\";\n                toolSwitch.Value = value;\n                toolSwitch.MultipleValues = true;\n                base.ActiveToolSwitches.Add(\"LanguageStandard\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual string CompileAs\n        {\n            get\n            {\n                if (IsPropertySet(\"CompileAs\"))\n                {\n                    return base.ActiveToolSwitches[\"CompileAs\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"CompileAs\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.DisplayName = \"Compile As\";\n                toolSwitch.Description = \"Select compile language option for .c and .cpp files.  'Default' will detect based on .c or .cpp extention. (-x c, -x c++)\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                string[][] switchMap = new string[3][]\n                {\n                    new string[2] { \"Default\", \"\" },\n                    new string[2] { \"CompileAsC\", \"-x c\" },\n                    new string[2] { \"CompileAsCpp\", \"-x c++\" }\n                };\n                toolSwitch.SwitchValue = ReadSwitchMap(\"CompileAs\", switchMap, value);\n                toolSwitch.Name = \"CompileAs\";\n                toolSwitch.Value = value;\n                toolSwitch.MultipleValues = true;\n                base.ActiveToolSwitches.Add(\"CompileAs\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n\n        public string[] ForcedIncludeFiles\n        {\n            get\n            {", "                if (IsPropertySet(\"ForcedIncludeFiles\"))\n                {\n                    return base.ActiveToolSwitches[\"ForcedIncludeFiles\"].StringList;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"ForcedIncludeFiles\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.StringPathArray);\n                toolSwitch.DisplayName = \"Forced Include Files\";\n                toolSwitch.Description = \"one or more forced include files.     (-include [name])\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-include \";\n                toolSwitch.Name = \"ForcedIncludeFiles\";\n                toolSwitch.StringList = value;\n                base.ActiveToolSwitches.Add(\"ForcedIncludeFiles\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public bool EnableASAN\n        {\n            get\n            {\n                if (IsPropertySet(\"EnableASAN\"))\n                {\n                    return base.ActiveToolSwitches[\"EnableASAN\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"EnableASAN\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Enable Address Sanitizer\";\n                toolSwitch.Description = \"Compiles program with AddressSanitizer. Compile with -fno-omit-frame-pointer and compiler optimization level -Os or -O0 for best results. Must link with Address Sanitizer option too. Must run with debugger to view diagnostic results.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-fsanitize=address\";\n                toolSwitch.Name = \"EnableASAN\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"EnableASAN\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual string Sysroot\n        {\n            get\n            {\n                if (IsPropertySet(\"Sysroot\"))\n                {\n                    return base.ActiveToolSwitches[\"Sysroot\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"Sysroot\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.DisplayName = \"Sysroot\";\n                toolSwitch.Description = \"Folder path to the root directory for headers and libraries.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.Name = \"Sysroot\";\n                toolSwitch.Value = value;\n                toolSwitch.SwitchValue = \"--sysroot=\";\n                base.ActiveToolSwitches.Add(\"Sysroot\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n\n        // \u4f8b\u5982 x86_64-linux-gnu\n        // \u6ce8\u610f\uff1a\u4ec5clang\u652f\u6301\uff0c\u5e76\u4e14\u6b64\u9009\u9879\u4f4d\u5185\u90e8\u8bbe\u7f6e\uff0c\u8ddf\u968fPlatformTriplet", "        public virtual string TargetArch\n        {\n            get\n            {\n                if (IsPropertySet(\"TargetArch\"))\n                {\n                    return base.ActiveToolSwitches[\"TargetArch\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"TargetArch\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.DisplayName = \"\u76ee\u6807\u4f53\u7cfb\u7ed3\u6784\";\n                toolSwitch.Description = \"\u76ee\u6807\u7684\u4f53\u7cfb\u7ed3\u6784\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.Name = \"TargetArch\";\n                toolSwitch.Value = value;\n                toolSwitch.SwitchValue = \"--target=\";\n                base.ActiveToolSwitches.Add(\"TargetArch\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        protected override bool GenerateCostomCommandsAccordingToType(CommandLineBuilder builder, string switchName, bool dummyForBackwardCompatibility, CommandLineFormat format = CommandLineFormat.ForBuildLog, EscapeFormat escapeFormat = EscapeFormat.Default)\n        {\n            if (string.Equals(switchName, \"DependenceFile\", StringComparison.OrdinalIgnoreCase))\n            {\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);\n                toolSwitch.DisplayName = \"DependenceFile\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"-MD -MF \";\n                toolSwitch.Name = \"DependenceFile\";\n\n                if (IsPropertySet(\"ObjectFileName\"))\n                {\n                    toolSwitch.Value = base.ActiveToolSwitches[\"ObjectFileName\"].Value + \".d\";\n                }", "                if (IsPropertySet(\"ObjectFileName\"))\n                {\n                    toolSwitch.Value = base.ActiveToolSwitches[\"ObjectFileName\"].Value + \".d\";\n                }\n                else if(Sources.Length !=0)\n                {\n                    toolSwitch.Value = Environment.ExpandEnvironmentVariables(Sources[0].ItemSpec) + \".d\";\n                }\n                else\n                {\n                    return true;\n                }\n\n                GenerateCommandsAccordingToType(builder, toolSwitch, format, escapeFormat);\n                return true;\n            }\n            return false;\n        }\n", "        protected override int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands)\n        {\n            foreach (var Item in Sources)\n            {\n                Log.LogMessage(MessageImportance.High, Item.ItemSpec);\n            }\n\n            return base.ExecuteTool(pathToTool, responseFileCommands, commandLineCommands);\n        }\n\n        public virtual string TrackerLogDirectory\n        {\n            get\n            {", "        public virtual string TrackerLogDirectory\n        {\n            get\n            {\n                if (IsPropertySet(\"TrackerLogDirectory\"))\n                {\n                    return base.ActiveToolSwitches[\"TrackerLogDirectory\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"TrackerLogDirectory\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Directory);\n                toolSwitch.DisplayName = \"Tracker Log Directory\";\n                toolSwitch.Description = \"Tracker Log Directory.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.Value = VCToolTask.EnsureTrailingSlash(value);\n                base.ActiveToolSwitches.Add(\"TrackerLogDirectory\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        protected override string CommandTLogName\n        {\n            get\n            {\n                return \"compile.\" + base.CommandTLogName;\n            }\n        }\n\n        protected bool InputDependencyFilter(string fullInputPath)\n        {\n            if (fullInputPath.EndsWith(\".PDB\", StringComparison.OrdinalIgnoreCase) || fullInputPath.EndsWith(\".IDB\", StringComparison.OrdinalIgnoreCase))\n            {\n                return false;\n            }\n            return !trackedInputFilesToRemove.ContainsKey(fullInputPath);\n        }\n", "        protected bool InputDependencyFilter(string fullInputPath)\n        {\n            if (fullInputPath.EndsWith(\".PDB\", StringComparison.OrdinalIgnoreCase) || fullInputPath.EndsWith(\".IDB\", StringComparison.OrdinalIgnoreCase))\n            {\n                return false;\n            }\n            return !trackedInputFilesToRemove.ContainsKey(fullInputPath);\n        }\n\n        protected bool OutputDependencyFilter(string fullOutputPath)\n        {", "        protected bool OutputDependencyFilter(string fullOutputPath)\n        {\n            if (fullOutputPath.EndsWith(\".TLH\", StringComparison.OrdinalIgnoreCase) || fullOutputPath.EndsWith(\".TLI\", StringComparison.OrdinalIgnoreCase) || fullOutputPath.EndsWith(\".DLL\", StringComparison.OrdinalIgnoreCase))\n            {\n                return false;\n            }\n            return !trackedOutputFilesToRemove.ContainsKey(fullOutputPath);\n        }\n\n        protected override int PostExecuteTool(int exitCode)\n        {", "        protected override int PostExecuteTool(int exitCode)\n        {\n            if (base.MinimalRebuildFromTracking || base.TrackFileAccess)\n            {\n                base.SourceOutputs = new CanonicalTrackedOutputFiles(base.TLogWriteFiles);\n                base.SourceDependencies = new CanonicalTrackedInputFiles(base.TLogReadFiles, Sources, base.ExcludedInputPaths, base.SourceOutputs, UseMinimalRebuildOptimization, MaintainCompositeRootingMarkers);\n                DependencyFilter includeInTLog = OutputDependencyFilter;\n                DependencyFilter dependencyFilter = InputDependencyFilter;\n                trackedInputFilesToRemove = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);\n                if (base.TrackedInputFilesToIgnore != null)\n                {\n                    ITaskItem[] array = base.TrackedInputFilesToIgnore;", "                if (base.TrackedInputFilesToIgnore != null)\n                {\n                    ITaskItem[] array = base.TrackedInputFilesToIgnore;\n                    foreach (ITaskItem taskItem in array)\n                    {\n                        trackedInputFilesToRemove.Add(taskItem.GetMetadata(\"FullPath\"), taskItem);\n                    }\n                }\n                trackedOutputFilesToRemove = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);\n                if (base.TrackedOutputFilesToIgnore != null)\n                {\n                    ITaskItem[] array2 = base.TrackedOutputFilesToIgnore;", "                if (base.TrackedOutputFilesToIgnore != null)\n                {\n                    ITaskItem[] array2 = base.TrackedOutputFilesToIgnore;\n                    foreach (ITaskItem taskItem2 in array2)\n                    {\n                        trackedOutputFilesToRemove.Add(taskItem2.GetMetadata(\"FullPath\"), taskItem2);\n                    }\n                }\n                //if (PreprocessToFile)\n                //{\n                //    base.SourceOutputs.RemoveDependenciesFromEntryIfMissing(base.SourcesCompiled, preprocessOutput);\n                //    base.SourceDependencies.RemoveDependenciesFromEntryIfMissing(base.SourcesCompiled, preprocessOutput);\n                //}\n                //else\n                {\n                    base.SourceOutputs.RemoveDependenciesFromEntryIfMissing(base.SourcesCompiled);\n                    base.SourceDependencies.RemoveDependenciesFromEntryIfMissing(base.SourcesCompiled);\n                }", "                //if (PreprocessToFile)\n                //{\n                //    base.SourceOutputs.RemoveDependenciesFromEntryIfMissing(base.SourcesCompiled, preprocessOutput);\n                //    base.SourceDependencies.RemoveDependenciesFromEntryIfMissing(base.SourcesCompiled, preprocessOutput);\n                //}\n                //else\n                {\n                    base.SourceOutputs.RemoveDependenciesFromEntryIfMissing(base.SourcesCompiled);\n                    base.SourceDependencies.RemoveDependenciesFromEntryIfMissing(base.SourcesCompiled);\n                }\n                if (exitCode != 0 && !MinimalRebuild)\n                {\n                    ITaskItem[] array5;\n                    ITaskItem[] upToDateSources;", "                if (exitCode != 0 && !MinimalRebuild)\n                {\n                    ITaskItem[] array5;\n                    ITaskItem[] upToDateSources;\n                    if (!PreprocessToFile && base.SourcesCompiled.Length > 1)\n                    {\n                        KeyValuePair<string, bool>[] array3 = new KeyValuePair<string, bool>[]\n                        {\n                            new KeyValuePair<string, bool>(\"ObjectFile\", value: true)\n                        };\n                        ITaskItem[] sources = Sources;", "                        foreach (ITaskItem taskItem3 in sources)\n                        {\n                            string sourceKey = FileTracker.FormatRootingMarker(taskItem3);\n                            KeyValuePair<string, bool>[] array4 = array3;\n                            for (int l = 0; l < array4.Length; l++)\n                            {\n                                KeyValuePair<string, bool> keyValuePair = array4[l];\n                                string metadata = taskItem3.GetMetadata(keyValuePair.Key);\n                                if (keyValuePair.Value && !string.IsNullOrEmpty(metadata))\n                                {\n                                    base.SourceOutputs.AddComputedOutputForSourceRoot(sourceKey, metadata);\n                                }\n                            }\n                        }\n                        array5 = base.SourceDependencies.ComputeSourcesNeedingCompilation();\n                        List<ITaskItem> list = new List<ITaskItem>();\n                        int num = 0;\n                        ITaskItem[] array6 = base.SourcesCompiled;", "                                if (keyValuePair.Value && !string.IsNullOrEmpty(metadata))\n                                {\n                                    base.SourceOutputs.AddComputedOutputForSourceRoot(sourceKey, metadata);\n                                }\n                            }\n                        }\n                        array5 = base.SourceDependencies.ComputeSourcesNeedingCompilation();\n                        List<ITaskItem> list = new List<ITaskItem>();\n                        int num = 0;\n                        ITaskItem[] array6 = base.SourcesCompiled;\n                        foreach (ITaskItem taskItem4 in array6)\n                        {", "                        foreach (ITaskItem taskItem4 in array6)\n                        {\n                            if (num >= array5.Length)\n                            {\n                                list.Add(taskItem4);\n                            }\n                            else if (!array5[num].Equals(taskItem4))\n                            {\n                                list.Add(taskItem4);\n                            }\n                            else\n                            {\n                                num++;\n                            }\n                        }\n                        upToDateSources = list.ToArray();\n                        ITaskItem[] sources2 = Sources;", "                        foreach (ITaskItem taskItem5 in sources2)\n                        {\n                            string sourceRoot = FileTracker.FormatRootingMarker(taskItem5);\n                            KeyValuePair<string, bool>[] array7 = array3;\n                            for (int num2 = 0; num2 < array7.Length; num2++)\n                            {\n                                KeyValuePair<string, bool> keyValuePair2 = array7[num2];\n                                string metadata2 = taskItem5.GetMetadata(keyValuePair2.Key);\n                                if (keyValuePair2.Value && !string.IsNullOrEmpty(metadata2))\n                                {\n                                    base.SourceOutputs.RemoveOutputForSourceRoot(sourceRoot, metadata2);\n                                }\n                            }\n                        }\n                    }\n                    else\n                    {\n                        array5 = base.SourcesCompiled;\n                        upToDateSources = new ITaskItem[0];\n                    }\n                    // base.SourceOutputs.RemoveEntriesForSource(array5, preprocessOutput);\n                    base.SourceOutputs.SaveTlog(includeInTLog);\n                    base.SourceDependencies.RemoveEntriesForSource(array5);\n                    base.SourceDependencies.SaveTlog(dependencyFilter);\n                    ConstructCommandTLog(upToDateSources, dependencyFilter);\n                }", "                                if (keyValuePair2.Value && !string.IsNullOrEmpty(metadata2))\n                                {\n                                    base.SourceOutputs.RemoveOutputForSourceRoot(sourceRoot, metadata2);\n                                }\n                            }\n                        }\n                    }\n                    else\n                    {\n                        array5 = base.SourcesCompiled;\n                        upToDateSources = new ITaskItem[0];\n                    }\n                    // base.SourceOutputs.RemoveEntriesForSource(array5, preprocessOutput);\n                    base.SourceOutputs.SaveTlog(includeInTLog);\n                    base.SourceDependencies.RemoveEntriesForSource(array5);\n                    base.SourceDependencies.SaveTlog(dependencyFilter);\n                    ConstructCommandTLog(upToDateSources, dependencyFilter);\n                }", "                //else if (PreprocessToFile)\n                //{\n                //    bool flag = true;\n                //    if (string.IsNullOrEmpty(PreprocessOutputPath))\n                //    {\n                //        ITaskItem[] array8 = base.SourcesCompiled;\n                //        foreach (ITaskItem source in array8)\n                //        {\n                //            flag = flag && MovePreprocessedOutput(source, base.SourceDependencies, base.SourceOutputs);\n                //        }\n                //    }", "                //    if (flag)\n                //    {\n                //        AddPdbToCompactOutputs(base.SourcesCompiled, base.SourceOutputs);\n                //        base.SourceOutputs.SaveTlog(includeInTLog);\n                //        base.SourceDependencies.SaveTlog(dependencyFilter);\n                //        ConstructCommandTLog(base.SourcesCompiled, dependencyFilter);\n                //    }\n                //}\n                else\n                {\n                    AddPdbToCompactOutputs(base.SourcesCompiled, base.SourceOutputs);\n                    RemoveTaskSpecificInputs(base.SourceDependencies);\n                    base.SourceOutputs.SaveTlog(includeInTLog);\n                    base.SourceDependencies.SaveTlog(dependencyFilter);\n                    ConstructCommandTLog(base.SourcesCompiled, dependencyFilter);\n                }\n                TrackedVCToolTask.DeleteEmptyFile(base.TLogWriteFiles);\n                TrackedVCToolTask.DeleteEmptyFile(base.TLogReadFiles);\n                TrackedVCToolTask.DeleteFiles(base.TLogDeleteFiles);\n            }", "            //else if (PreprocessToFile)\n            //{\n            //    bool flag2 = true;\n            //    if (string.IsNullOrEmpty(PreprocessOutputPath))\n            //    {\n            //        ITaskItem[] array9 = base.SourcesCompiled;\n            //        foreach (ITaskItem source2 in array9)\n            //        {\n            //            flag2 = flag2 && MovePreprocessedOutput(source2, null, null);\n            //        }\n            //    }", "            //    if (!flag2)\n            //    {\n            //        exitCode = -1;\n            //    }\n            //}\n            return exitCode;\n        }\n\n        protected void ConstructCommandTLog(ITaskItem[] upToDateSources, DependencyFilter inputFilter)\n        {\n            IDictionary<string, string> dictionary = MapSourcesToCommandLines();\n            string text = GenerateCommandLineExceptSwitches(new string[1] { \"Sources\" }, CommandLineFormat.ForTracking);", "        protected void ConstructCommandTLog(ITaskItem[] upToDateSources, DependencyFilter inputFilter)\n        {\n            IDictionary<string, string> dictionary = MapSourcesToCommandLines();\n            string text = GenerateCommandLineExceptSwitches(new string[1] { \"Sources\" }, CommandLineFormat.ForTracking);\n            if (upToDateSources != null)\n            {\n                foreach (ITaskItem taskItem in upToDateSources)\n                {\n                    string metadata = taskItem.GetMetadata(\"FullPath\");\n                    if (inputFilter == null || inputFilter(metadata))\n                    {\n                        dictionary[FileTracker.FormatRootingMarker(taskItem)] = text + \" \" + metadata/*.ToUpperInvariant()*/;\n                    }\n                    else\n                    {\n                        dictionary.Remove(FileTracker.FormatRootingMarker(taskItem));\n                    }\n                }\n            }\n            WriteSourcesToCommandLinesTable(dictionary);\n        }\n\n", "                    if (inputFilter == null || inputFilter(metadata))\n                    {\n                        dictionary[FileTracker.FormatRootingMarker(taskItem)] = text + \" \" + metadata/*.ToUpperInvariant()*/;\n                    }\n                    else\n                    {\n                        dictionary.Remove(FileTracker.FormatRootingMarker(taskItem));\n                    }\n                }\n            }\n            WriteSourcesToCommandLinesTable(dictionary);\n        }\n\n", "        protected void AddPdbToCompactOutputs(ITaskItem[] sources, CanonicalTrackedOutputFiles compactOutputs)\n        {\n            // todo: gcc\u7684\u7b26\u53f7\uff1f\uff1f\n        }\n\n        protected void ComputeObjectFiles()\n        {\n            ObjectFiles = new string[Sources.Length];\n            int num = 0;\n            ITaskItem[] sources = Sources;\n            foreach (ITaskItem taskItem in sources)\n            {\n                ObjectFiles[num] = Helpers.GetOutputFileName(taskItem.ItemSpec, ObjectFileName, \"o\");\n                taskItem.SetMetadata(\"ObjectFile\", ObjectFiles[num]);\n                num++;\n            }\n        }\n", "            foreach (ITaskItem taskItem in sources)\n            {\n                ObjectFiles[num] = Helpers.GetOutputFileName(taskItem.ItemSpec, ObjectFileName, \"o\");\n                taskItem.SetMetadata(\"ObjectFile\", ObjectFiles[num]);\n                num++;\n            }\n        }\n\n        protected override void SaveTracking()\n        {\n            if(ObjectFiles == null)\n                ComputeObjectFiles();\n\n            // \u4fdd\u5b58Write\u6587\u4ef6\n            {\n                string WriteFilePath = TLogWriteFiles[0].GetMetadata(\"FullPath\");\n                Directory.CreateDirectory(Path.GetDirectoryName(WriteFilePath));\n                using StreamWriter WriteFileWriter = FileUtilities.OpenWrite(WriteFilePath, append: true, Encoding.Unicode);\n\n                KeyValuePair<string, bool>[] array = new KeyValuePair<string, bool>[]\n                {\n                    new KeyValuePair<string, bool>(\"ObjectFile\", value: true)\n                };\n", "        protected override void SaveTracking()\n        {\n            if(ObjectFiles == null)\n                ComputeObjectFiles();\n\n            // \u4fdd\u5b58Write\u6587\u4ef6\n            {\n                string WriteFilePath = TLogWriteFiles[0].GetMetadata(\"FullPath\");\n                Directory.CreateDirectory(Path.GetDirectoryName(WriteFilePath));\n                using StreamWriter WriteFileWriter = FileUtilities.OpenWrite(WriteFilePath, append: true, Encoding.Unicode);\n\n                KeyValuePair<string, bool>[] array = new KeyValuePair<string, bool>[]\n                {\n                    new KeyValuePair<string, bool>(\"ObjectFile\", value: true)\n                };\n", "                foreach (ITaskItem taskItem in Sources)\n                {\n                    string sourceKey = FileTracker.FormatRootingMarker(taskItem);\n                    WriteFileWriter.WriteLine(\"^\" + sourceKey);\n                    KeyValuePair<string, bool>[] array2 = array;\n                    for (int j = 0; j < array2.Length; j++)\n                    {\n                        KeyValuePair<string, bool> keyValuePair = array2[j];\n                        string metadata = taskItem.GetMetadata(keyValuePair.Key);\n                        if (keyValuePair.Value && !string.IsNullOrEmpty(metadata))\n                        {\n                            FileUtilities.UpdateFileExistenceCache(metadata);\n                            WriteFileWriter.WriteLine(metadata);\n                        }\n                    }\n                }\n            }\n\n            // \u4fdd\u5b58Read\u6587\u4ef6\n            {\n                string ReadFilePath = TLogReadFiles[0].GetMetadata(\"FullPath\");\n                Directory.CreateDirectory(Path.GetDirectoryName(ReadFilePath));\n                using StreamWriter WriteFileWriter = FileUtilities.OpenWrite(ReadFilePath, append: true, Encoding.Unicode);\n\n                GCCMapReader MapReader = new GCCMapReader();\n", "                        if (keyValuePair.Value && !string.IsNullOrEmpty(metadata))\n                        {\n                            FileUtilities.UpdateFileExistenceCache(metadata);\n                            WriteFileWriter.WriteLine(metadata);\n                        }\n                    }\n                }\n            }\n\n            // \u4fdd\u5b58Read\u6587\u4ef6\n            {\n                string ReadFilePath = TLogReadFiles[0].GetMetadata(\"FullPath\");\n                Directory.CreateDirectory(Path.GetDirectoryName(ReadFilePath));\n                using StreamWriter WriteFileWriter = FileUtilities.OpenWrite(ReadFilePath, append: true, Encoding.Unicode);\n\n                GCCMapReader MapReader = new GCCMapReader();\n", "                foreach (ITaskItem taskItem in Sources)\n                {\n                    var DependenceFile = ObjectFileName + \".d\";\n\n                    if (MapReader.Init(DependenceFile))\n                    {\n                        string sourceKey = FileTracker.FormatRootingMarker(taskItem);\n                        WriteFileWriter.WriteLine(\"^\" + sourceKey);\n\n                        for (; ; )\n                        {\n                            var Tmp = MapReader.ReadLine();", "                        for (; ; )\n                        {\n                            var Tmp = MapReader.ReadLine();\n                            if (Tmp == null)\n                                break;\n\n                            if (Tmp.Length == 0)\n                                continue;\n\n                            WriteFileWriter.WriteLine(FileUtilities.NormalizePath(Tmp));\n                        }\n                    }\n\n                    try\n                    {\n                        File.Delete(DependenceFile);\n                    }\n                    catch\n                    {\n\n                    }\n                }\n            }\n        }\n", "        protected internal override bool ComputeOutOfDateSources()\n        {\n            if (base.MinimalRebuildFromTracking || base.TrackFileAccess)\n            {\n                AssignDefaultTLogPaths();\n            }\n\n#if __REMOVE\n            if (PreprocessToFile)\n            {\n                ComputePreprocessedOutputFiles();\n            }\n#endif", "            if (PreprocessToFile)\n            {\n                ComputePreprocessedOutputFiles();\n            }\n#endif\n            if (base.MinimalRebuildFromTracking && !ForcedRebuildRequired())\n            {\n                base.SourceOutputs = new CanonicalTrackedOutputFiles(this, base.TLogWriteFiles, constructOutputsFromTLogs: false);\n                ComputeObjectFiles();\n#if __REMOVE\n                ComputeBrowseInformationFiles();\n                ComputeXmlDocumentationFiles();\n#endif\n                KeyValuePair<string, bool>[] array = new KeyValuePair<string, bool>[]\n                {\n                    new KeyValuePair<string, bool>(\"ObjectFile\", value: true)\n                    // new KeyValuePair<string, bool>(\"BrowseInformationFile\", BrowseInformation),\n                    // new KeyValuePair<string, bool>(\"XMLDocumentationFileName\", GenerateXMLDocumentationFiles)\n                };\n#if __REMOVE", "                if (PreprocessToFile)\n                {\n                    if (string.IsNullOrEmpty(PreprocessOutputPath))\n                    {\n                        base.RootSource = FileTracker.FormatRootingMarker(Sources, preprocessOutput);\n                        base.SourceOutputs.AddComputedOutputsForSourceRoot(base.RootSource, preprocessOutput);\n                    }\n                    array[0] = new KeyValuePair<string, bool>(\"PreprocessOutputFile\", value: true);\n                }\n#endif\n                ITaskItem[] sources = Sources;", "                foreach (ITaskItem taskItem in sources)\n                {\n                    string sourceKey = FileTracker.FormatRootingMarker(taskItem);\n                    KeyValuePair<string, bool>[] array2 = array;\n                    for (int j = 0; j < array2.Length; j++)\n                    {\n                        KeyValuePair<string, bool> keyValuePair = array2[j];\n                        string metadata = taskItem.GetMetadata(keyValuePair.Key);\n                        if (keyValuePair.Value && !string.IsNullOrEmpty(metadata))\n                        {\n                            base.SourceOutputs.AddComputedOutputForSourceRoot(sourceKey, metadata);", "                        if (keyValuePair.Value && !string.IsNullOrEmpty(metadata))\n                        {\n                            base.SourceOutputs.AddComputedOutputForSourceRoot(sourceKey, metadata);\n                            if (File.Exists(taskItem.GetMetadata(\"ObjectFile\")) && !File.Exists(metadata))\n                            {\n                                File.Delete(taskItem.GetMetadata(\"ObjectFile\"));\n                            }\n                        }\n                    }\n                }\n\n#if __REMOVE", "                if (IsPropertySet(\"PrecompiledHeader\") && PrecompiledHeader == \"Create\" && IsPropertySet(\"PrecompiledHeaderOutputFile\"))\n                {\n                    ITaskItem[] sources2 = Sources;\n                    foreach (ITaskItem source in sources2)\n                    {\n                        string sourceKey2 = FileTracker.FormatRootingMarker(source);\n                        base.SourceOutputs.AddComputedOutputForSourceRoot(sourceKey2, PrecompiledHeaderOutputFile);\n                    }\n                }\n#endif\n                base.SourceDependencies = new CanonicalTrackedInputFiles(this, base.TLogReadFiles, Sources, base.ExcludedInputPaths, base.SourceOutputs, useMinimalRebuildOptimization: true, MaintainCompositeRootingMarkers);\n                ITaskItem[] sourcesOutOfDateThroughTracking = base.SourceDependencies.ComputeSourcesNeedingCompilation();\n                List<ITaskItem> sourcesWithChangedCommandLines = GenerateSourcesOutOfDateDueToCommandLine();\n                base.SourcesCompiled = MergeOutOfDateSourceLists(sourcesOutOfDateThroughTracking, sourcesWithChangedCommandLines);", "                if (base.SourcesCompiled.Length == 0)\n                {\n                    base.SkippedExecution = true;\n                    return base.SkippedExecution;\n                }\n                if (!MinimalRebuild || PreprocessToFile)\n                {\n                    base.SourceDependencies.RemoveEntriesForSource(base.SourcesCompiled);\n                    base.SourceDependencies.SaveTlog();\n                    if (base.DeleteOutputOnExecute)\n                    {\n                        TrackedVCToolTask.DeleteFiles(base.SourceOutputs.OutputsForSource(base.SourcesCompiled, searchForSubRootsInCompositeRootingMarkers: false));\n                    }\n                    base.SourceOutputs = new CanonicalTrackedOutputFiles(this, base.TLogWriteFiles);\n                    base.SourceOutputs.RemoveEntriesForSource(base.SourcesCompiled /*, preprocessOutput*/);\n                    base.SourceOutputs.SaveTlog();\n                    IDictionary<string, string> dictionary = MapSourcesToCommandLines();\n                    ITaskItem[] array3 = base.SourcesCompiled;", "                    if (base.DeleteOutputOnExecute)\n                    {\n                        TrackedVCToolTask.DeleteFiles(base.SourceOutputs.OutputsForSource(base.SourcesCompiled, searchForSubRootsInCompositeRootingMarkers: false));\n                    }\n                    base.SourceOutputs = new CanonicalTrackedOutputFiles(this, base.TLogWriteFiles);\n                    base.SourceOutputs.RemoveEntriesForSource(base.SourcesCompiled /*, preprocessOutput*/);\n                    base.SourceOutputs.SaveTlog();\n                    IDictionary<string, string> dictionary = MapSourcesToCommandLines();\n                    ITaskItem[] array3 = base.SourcesCompiled;\n                    foreach (ITaskItem source2 in array3)\n                    {\n                        dictionary.Remove(FileTracker.FormatRootingMarker(source2));\n                    }\n                    WriteSourcesToCommandLinesTable(dictionary);\n                }\n                AssignOutOfDateSources(base.SourcesCompiled);\n            }\n            else\n            {\n                base.SourcesCompiled = Sources;\n            }", "                    foreach (ITaskItem source2 in array3)\n                    {\n                        dictionary.Remove(FileTracker.FormatRootingMarker(source2));\n                    }\n                    WriteSourcesToCommandLinesTable(dictionary);\n                }\n                AssignOutOfDateSources(base.SourcesCompiled);\n            }\n            else\n            {\n                base.SourcesCompiled = Sources;\n            }", "            if (string.IsNullOrEmpty(base.RootSource))\n            {\n#if __REMOVE\n                if (PreprocessToFile && string.IsNullOrEmpty(PreprocessOutputPath))\n                {\n                    if (!base.MinimalRebuildFromTracking)\n                    {\n                        base.RootSource = FileTracker.FormatRootingMarker(Sources, preprocessOutput);\n                    }\n                }else \n#endif", "                if (base.TrackFileAccess)\n                {\n                    base.RootSource = FileTracker.FormatRootingMarker(base.SourcesCompiled);\n                }\n            }\n\n#if __REMOVE\n            if (base.UseMsbuildResourceManager && !EnableCLServerMode && IsSetToTrue(\"MultiProcessorCompilation\"))\n            {\n                int num = base.BuildEngine9.RequestCores(base.SourcesCompiled.Length);\n                if (ProcessorNumber == 0 || ProcessorNumber > num)\n                {\n                    ProcessorNumber = num;\n                }\n            }\n#endif\n            base.SkippedExecution = false;\n            return base.SkippedExecution;\n        }\n    }\n}", "                if (ProcessorNumber == 0 || ProcessorNumber > num)\n                {\n                    ProcessorNumber = num;\n                }\n            }\n#endif\n            base.SkippedExecution = false;\n            return base.SkippedExecution;\n        }\n    }\n}"]}
{"filename": "YY.Build.Cross.Tasks/Cross/Ar.cs", "chunked_list": ["\ufeffusing Microsoft.Build.CPPTasks;\nusing Microsoft.Build.Framework;\nusing Microsoft.Build.Shared;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n", "using System.Threading.Tasks;\n\nnamespace YY.Build.Cross.Tasks.Cross\n{\n    public class Ar : TrackedVCToolTask\n    {\n        private ArrayList switchOrderList;\n\n        protected override ArrayList SwitchOrderList => switchOrderList;\n\n        protected override string ToolName => \"ar\";\n\n        public Ar()\n            : base(Microsoft.Build.CppTasks.Common.Properties.Microsoft_Build_CPPTasks_Strings.ResourceManager)\n        {\n            switchOrderList = new ArrayList();\n            switchOrderList.Add(\"Command\");\n            switchOrderList.Add(\"CreateIndex\");\n            switchOrderList.Add(\"CreateThinArchive\");\n            switchOrderList.Add(\"NoWarnOnCreate\");\n            switchOrderList.Add(\"TruncateTimestamp\");\n            switchOrderList.Add(\"SuppressStartupBanner\");\n            switchOrderList.Add(\"Verbose\");\n            switchOrderList.Add(\"AdditionalOptions\");\n            switchOrderList.Add(\"OutputFile\");\n            switchOrderList.Add(\"Sources\");\n        }\n", "        protected override ArrayList SwitchOrderList => switchOrderList;\n\n        protected override string ToolName => \"ar\";\n\n        public Ar()\n            : base(Microsoft.Build.CppTasks.Common.Properties.Microsoft_Build_CPPTasks_Strings.ResourceManager)\n        {\n            switchOrderList = new ArrayList();\n            switchOrderList.Add(\"Command\");\n            switchOrderList.Add(\"CreateIndex\");\n            switchOrderList.Add(\"CreateThinArchive\");\n            switchOrderList.Add(\"NoWarnOnCreate\");\n            switchOrderList.Add(\"TruncateTimestamp\");\n            switchOrderList.Add(\"SuppressStartupBanner\");\n            switchOrderList.Add(\"Verbose\");\n            switchOrderList.Add(\"AdditionalOptions\");\n            switchOrderList.Add(\"OutputFile\");\n            switchOrderList.Add(\"Sources\");\n        }\n", "        public virtual string Command\n        {\n            get\n            {\n                if (IsPropertySet(\"Command\"))\n                {\n                    return base.ActiveToolSwitches[\"Command\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"Command\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.String);\n                toolSwitch.DisplayName = \"Command\";\n                toolSwitch.Description = \"Command for AR.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.ArgumentRelationList.Add(new ArgumentRelation(\"CreateIndex\", \"\", required: false, \"\"));\n                toolSwitch.ArgumentRelationList.Add(new ArgumentRelation(\"CreateThinArchive\", \"\", required: false, \"\"));\n                toolSwitch.ArgumentRelationList.Add(new ArgumentRelation(\"NoWarnOnCreate\", \"\", required: false, \"\"));\n                toolSwitch.ArgumentRelationList.Add(new ArgumentRelation(\"TruncateTimestamp\", \"\", required: false, \"\"));\n                toolSwitch.ArgumentRelationList.Add(new ArgumentRelation(\"SuppressStartupBanner\", \"\", required: false, \"\"));\n                toolSwitch.ArgumentRelationList.Add(new ArgumentRelation(\"Verbose\", \"\", required: false, \"\"));\n                string[][] switchMap = new string[7][]\n                {\n                    new string[2] { \"Delete\", \"-d\" },\n                    new string[2] { \"Move\", \"-m\" },\n                    new string[2] { \"Print\", \"-p\" },\n                    new string[2] { \"Quick\", \"-q\" },\n                    new string[2] { \"Replacement\", \"-r\" },\n                    new string[2] { \"Table\", \"-t\" },\n                    new string[2] { \"Extract\", \"-x\" }\n                };\n                toolSwitch.SwitchValue = ReadSwitchMap(\"Command\", switchMap, value);\n                toolSwitch.Name = \"Command\";\n                toolSwitch.Value = value;\n                toolSwitch.MultipleValues = true;\n                base.ActiveToolSwitches.Add(\"Command\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n\n        [Required]", "        public virtual string OutputFile\n        {\n            get\n            {\n                if (IsPropertySet(\"OutputFile\"))\n                {\n                    return base.ActiveToolSwitches[\"OutputFile\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"OutputFile\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.File);\n                toolSwitch.Separator = \" \";\n                toolSwitch.DisplayName = \"Output File\";\n                toolSwitch.Description = \"The /OUT option overrides the default name and location of the program that the lib creates.\";\n                toolSwitch.Required = true;\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.Name = \"OutputFile\";\n                toolSwitch.Value = value;\n                base.ActiveToolSwitches.Add(\"OutputFile\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n\n        [Required]", "        public virtual ITaskItem[] Sources\n        {\n            get\n            {\n                if (IsPropertySet(\"Sources\"))\n                {\n                    return base.ActiveToolSwitches[\"Sources\"].TaskItemArray;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"Sources\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.ITaskItemArray);\n                toolSwitch.Required = true;\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.TaskItemArray = value;\n                base.ActiveToolSwitches.Add(\"Sources\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool CreateIndex\n        {\n            get\n            {\n                if (IsPropertySet(\"CreateIndex\"))\n                {\n                    return base.ActiveToolSwitches[\"CreateIndex\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"CreateIndex\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Create an archive index\";\n                toolSwitch.Description = \"Create an archive index (cf. ranlib).  This can speed up linking and reduce dependency within its own library.\";\n                toolSwitch.Parents.AddLast(\"Command\");\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"s\";\n                toolSwitch.Name = \"CreateIndex\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"CreateIndex\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool CreateThinArchive\n        {\n            get\n            {\n                if (IsPropertySet(\"CreateThinArchive\"))\n                {\n                    return base.ActiveToolSwitches[\"CreateThinArchive\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"CreateThinArchive\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Create Thin Archive\";\n                toolSwitch.Description = \"Create a thin archive.  A thin archive contains relativepaths to the objects instead of embedding the objects.  Switching between Thin and Normal requires deleting the existing library.\";\n                toolSwitch.Parents.AddLast(\"Command\");\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"T\";\n                toolSwitch.Name = \"CreateThinArchive\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"CreateThinArchive\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool NoWarnOnCreate\n        {\n            get\n            {\n                if (IsPropertySet(\"NoWarnOnCreate\"))\n                {\n                    return base.ActiveToolSwitches[\"NoWarnOnCreate\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"NoWarnOnCreate\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"No Warning on Create\";\n                toolSwitch.Description = \"Do not warn if when the library is created.\";\n                toolSwitch.Parents.AddLast(\"Command\");\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"c\";\n                toolSwitch.Name = \"NoWarnOnCreate\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"NoWarnOnCreate\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool TruncateTimestamp\n        {\n            get\n            {\n                if (IsPropertySet(\"TruncateTimestamp\"))\n                {\n                    return base.ActiveToolSwitches[\"TruncateTimestamp\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"TruncateTimestamp\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Truncate Timestamp\";\n                toolSwitch.Description = \"Use zero for timestamps and uids/gids.\";\n                toolSwitch.Parents.AddLast(\"Command\");\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"D\";\n                toolSwitch.Name = \"TruncateTimestamp\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"TruncateTimestamp\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool SuppressStartupBanner\n        {\n            get\n            {\n                if (IsPropertySet(\"SuppressStartupBanner\"))\n                {\n                    return base.ActiveToolSwitches[\"SuppressStartupBanner\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"SuppressStartupBanner\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Suppress Startup Banner\";\n                toolSwitch.Description = \"Dont show version number.\";\n                toolSwitch.Parents.AddLast(\"Command\");\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.ReverseSwitchValue = \"V\";\n                toolSwitch.Name = \"SuppressStartupBanner\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"SuppressStartupBanner\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        public virtual bool Verbose\n        {\n            get\n            {\n                if (IsPropertySet(\"Verbose\"))\n                {\n                    return base.ActiveToolSwitches[\"Verbose\"].BooleanValue;\n                }\n                return false;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"Verbose\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Boolean);\n                toolSwitch.DisplayName = \"Verbose\";\n                toolSwitch.Description = \"Verbose\";\n                toolSwitch.Parents.AddLast(\"Command\");\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.SwitchValue = \"v\";\n                toolSwitch.Name = \"Verbose\";\n                toolSwitch.BooleanValue = value;\n                base.ActiveToolSwitches.Add(\"Verbose\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        protected override ITaskItem[] TrackedInputFiles => Sources;\n\n        protected override bool MaintainCompositeRootingMarkers => true;\n\n        protected override string TrackerIntermediateDirectory\n        {\n            get\n            {\n                if (TrackerLogDirectory != null)\n                {\n                    return TrackerLogDirectory;\n                }\n                return string.Empty;\n            }\n        }\n", "                if (TrackerLogDirectory != null)\n                {\n                    return TrackerLogDirectory;\n                }\n                return string.Empty;\n            }\n        }\n\n        public virtual string TrackerLogDirectory\n        {\n            get\n            {", "        public virtual string TrackerLogDirectory\n        {\n            get\n            {\n                if (IsPropertySet(\"TrackerLogDirectory\"))\n                {\n                    return base.ActiveToolSwitches[\"TrackerLogDirectory\"].Value;\n                }\n                return null;\n            }\n            set\n            {\n                base.ActiveToolSwitches.Remove(\"TrackerLogDirectory\");\n                ToolSwitch toolSwitch = new ToolSwitch(ToolSwitchType.Directory);\n                toolSwitch.DisplayName = \"Tracker Log Directory\";\n                toolSwitch.Description = \"Tracker log directory.\";\n                toolSwitch.ArgumentRelationList = new ArrayList();\n                toolSwitch.Value = VCToolTask.EnsureTrailingSlash(value);\n                base.ActiveToolSwitches.Add(\"TrackerLogDirectory\", toolSwitch);\n                AddActiveSwitchToolValue(toolSwitch);\n            }\n        }\n", "        protected override void SaveTracking()\n        {\n            string SourceKey = \"^\";\n\n            foreach (ITaskItem taskItem in Sources)\n            {\n                if (SourceKey.Length > 1)\n                    SourceKey += '|';\n\n                SourceKey += FileTracker.FormatRootingMarker(taskItem);\n            }\n\n            // \u4fdd\u5b58Write\u6587\u4ef6\n            {\n                string WriteFilePath = TLogWriteFiles[0].GetMetadata(\"FullPath\");\n                Directory.CreateDirectory(Path.GetDirectoryName(WriteFilePath));\n                using StreamWriter WriteFileWriter = FileUtilities.OpenWrite(WriteFilePath, append: true, Encoding.Unicode);\n\n                WriteFileWriter.WriteLine(SourceKey);\n                WriteFileWriter.WriteLine(OutputFile);\n            }\n\n            // \u4fdd\u5b58Read\u6587\u4ef6\n            {\n                string ReadFilePath = TLogReadFiles[0].GetMetadata(\"FullPath\");\n                Directory.CreateDirectory(Path.GetDirectoryName(ReadFilePath));\n                using StreamWriter ReadFileWriter = FileUtilities.OpenWrite(ReadFilePath, append: true, Encoding.Unicode);\n\n                ReadFileWriter.WriteLine(SourceKey);\n", "                foreach (ITaskItem taskItem in Sources)\n                {\n                    ReadFileWriter.WriteLine(FileTracker.FormatRootingMarker(taskItem));\n                }\n            }\n        }\n    }\n}\n"]}
{"filename": "YY.Build.Cross.Tasks/Cross/GCCMapReader.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\n\nnamespace YY.Build.Cross.Tasks.Cross\n{\n    // \u7528\u4e8e\u8bfb\u53d6GCC -MD \u751f\u6210\u7684Map\u6587\u4ef6\u3002\n    internal class GCCMapReader\n    {\n        private StreamReader StreamReader;", "    internal class GCCMapReader\n    {\n        private StreamReader StreamReader;\n        private string TextBuffer;\n        private int CurrentTextBufferIndex = 0;\n        private bool FileEnd = true;\n\n        public bool Init(string MapFile)\n        {\n            TextBuffer = null;\n            CurrentTextBufferIndex = 0;\n            FileEnd = false;\n\n            try\n            {\n                StreamReader = File.OpenText(MapFile);\n\n                var ObjectName = ReadLine();\n                // \u6587\u4ef6\u5185\u5bb9\u4e0d\u5bf9\u3002", "                if (ObjectName == null || ObjectName.Length == 0 || ObjectName[ObjectName.Length - 1] != ':')\n                {\n                    return false;\n                }\n\n                ObjectName = ReadLine();\n                // \u5f00\u5934\u6307\u5411\u81ea\u5df1\uff0c\u6240\u4ee5\u8df3\u8fc7\u5373\u53ef\u3002\n                if(ObjectName == null || ObjectName.Length == 0)\n                {\n                    return false;\n                }\n\n                return true;\n            }", "            catch (Exception ex)\n            {\n                return false;\n            }\n        }\n\n        private char? GetChar()\n        {\n            if (FileEnd)\n                return null;\n          Read:", "            if (FileEnd)\n                return null;\n          Read:\n            if (TextBuffer == null || TextBuffer.Length == CurrentTextBufferIndex)\n            {\n                CurrentTextBufferIndex = 0;\n                TextBuffer = StreamReader.ReadLine();\n                if (TextBuffer == null)\n                {\n                    FileEnd = true;\n                    return null;\n                }\n            }\n\n            var ch = TextBuffer[CurrentTextBufferIndex];\n            ++CurrentTextBufferIndex;\n", "            if (ch == ' ')\n                return '\\0';\n\n            // \u8f6c\u4e49 ?\n            if (ch == '\\\\')\n            {\n                if (TextBuffer.Length == CurrentTextBufferIndex)\n                {\n                    // \u8fd9\u662f\u4e00\u4e2a\u8fde\u63a5\u7b26\uff0c\u91cd\u65b0\u518d\u8bfb\u4e00\u884c\n                    goto Read;\n                }\n\n                ch = TextBuffer[CurrentTextBufferIndex];\n                ++CurrentTextBufferIndex;\n            }\n\n            return ch;\n        }\n\n        public string? ReadLine()\n        {", "            if (FileEnd)\n                return null;\n\n            string Tmp = \"\";\n\n            char? ch;\n\n            // \u5220\u9664\u5f00\u5934\u591a\u4f59\u76840\u7ec8\u6b62\n            for(; ;)\n            {\n                ch = GetChar();", "            for(; ;)\n            {\n                ch = GetChar();\n                if (ch == null)\n                    return null;\n\n                if (ch != '\\0')\n                    break;\n            }\n\n            do\n            {\n                Tmp += ch;\n\n                ch = GetChar();", "            } while (ch != null && ch != '\\0');\n\n            return Tmp;\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.Shared/StringBuilderCache.cs", "chunked_list": ["\ufeffusing System;\nusing System.Text;\n\nnamespace Microsoft.Build.Shared\n{\n    internal static class StringBuilderCache\n    {\n        private const int MAX_BUILDER_SIZE = 360;\n\n        [ThreadStatic]\n        private static StringBuilder t_cachedInstance;\n", "        private static StringBuilder t_cachedInstance;\n\n        public static StringBuilder Acquire(int capacity = 16)\n        {\n            if (capacity <= 360)\n            {\n                StringBuilder stringBuilder = t_cachedInstance;\n                if (stringBuilder != null && capacity <= stringBuilder.Capacity)\n                {\n                    t_cachedInstance = null;\n                    stringBuilder.Length = 0;\n                    return stringBuilder;\n                }\n            }\n            return new StringBuilder(capacity);\n        }\n", "        public static void Release(StringBuilder sb)\n        {\n            if (sb.Capacity <= 360)\n            {\n                t_cachedInstance = sb;\n            }\n        }\n\n        public static string GetStringAndRelease(StringBuilder sb)\n        {\n            string result = sb.ToString();\n            Release(sb);\n            return result;\n        }\n    }\n}\n", "        public static string GetStringAndRelease(StringBuilder sb)\n        {\n            string result = sb.ToString();\n            Release(sb);\n            return result;\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.Shared/ExceptionHandling.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Runtime.ExceptionServices;\nusing System.Security;\nusing System.Text;\n\nnamespace Microsoft.Build.Shared\n{\n    internal static class ExceptionHandling\n    {\n        internal static bool IsCriticalException(Exception e)\n        {", "    internal static class ExceptionHandling\n    {\n        internal static bool IsCriticalException(Exception e)\n        {\n            if (e is OutOfMemoryException || e is StackOverflowException || e is ThreadAbortException || e is ThreadInterruptedException || e is AccessViolationException /*|| e is InternalErrorException*/)\n            {\n                return true;\n            }\n            if (e is AggregateException ex && ex.InnerExceptions.Any((Exception innerException) => IsCriticalException(innerException)))\n            {\n                return true;\n            }\n            return false;\n        }\n\n        internal static bool NotExpectedException(Exception e)\n        {\n            return !IsIoRelatedException(e);\n        }\n\n        internal static bool IsIoRelatedException(Exception e)\n        {", "            if (e is AggregateException ex && ex.InnerExceptions.Any((Exception innerException) => IsCriticalException(innerException)))\n            {\n                return true;\n            }\n            return false;\n        }\n\n        internal static bool NotExpectedException(Exception e)\n        {\n            return !IsIoRelatedException(e);\n        }\n\n        internal static bool IsIoRelatedException(Exception e)\n        {", "            if (!(e is UnauthorizedAccessException) && !(e is NotSupportedException) && (!(e is ArgumentException) || e is ArgumentNullException) && !(e is SecurityException))\n            {\n                return e is IOException;\n            }\n            return true;\n        }\n\n        internal static void Rethrow(this Exception e)\n        {\n            ExceptionDispatchInfo.Capture(e).Throw();\n        }\n\n        internal static void RethrowIfCritical(this Exception ex)\n        {", "            if (IsCriticalException(ex))\n            {\n                ex.Rethrow();\n            }\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.Shared/FileTracker.cs", "chunked_list": ["\ufeffusing Microsoft.Build.Framework;\nusing Microsoft.Build.Tasks;\nusing Microsoft.Build.Utilities;\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Microsoft.Build.Shared\n{\n    internal class FileTracker\n    {", "{\n    internal class FileTracker\n    {\n        public static bool FileIsExcludedFromDependencies(string fileName)\n        {\n#if __\n            if (!FileIsUnderPath(fileName, s_applicationDataPath) && !FileIsUnderPath(fileName, s_localApplicationDataPath) && !FileIsUnderPath(fileName, s_localLowApplicationDataPath) && !FileIsUnderPath(fileName, s_tempShortPath) && !FileIsUnderPath(fileName, s_tempLongPath))\n            {\n                return s_commonApplicationDataPaths.Any((string p) => FileIsUnderPath(fileName, p));\n            }\n            return true;\n#else\n            // Linux\u4e0b\u516c\u5171\u6587\u4ef6\u8ddf\u8fd9\u4e9b\u76ee\u5f55\u90fd\u6ca1\u4ec0\u4e48\u5173\u7cfb\u3002\n            return false;\n#endif\n        }\n", "        public static bool FileIsUnderPath(string fileName, string path)\n        {\n            path = FileUtilities.EnsureTrailingSlash(path);\n            return string.Compare(fileName, 0, path, 0, path.Length, StringComparison.OrdinalIgnoreCase) == 0;\n        }\n\n        public static string FormatRootingMarker(ITaskItem source)\n        {\n            return FormatRootingMarker(new ITaskItem[1] { source }, null);\n        }\n", "        public static string FormatRootingMarker(ITaskItem source, ITaskItem output)\n        {\n            return FormatRootingMarker(new ITaskItem[1] { source }, new ITaskItem[1] { output });\n        }\n\n        public static string FormatRootingMarker(ITaskItem[] sources)\n        {\n            return FormatRootingMarker(sources, null);\n        }\n\n        public static string FormatRootingMarker(ITaskItem[] sources, ITaskItem[] outputs)\n        {\n            ErrorUtilities.VerifyThrowArgumentNull(sources, \"sources\");", "        public static string FormatRootingMarker(ITaskItem[] sources, ITaskItem[] outputs)\n        {\n            ErrorUtilities.VerifyThrowArgumentNull(sources, \"sources\");\n            if (outputs == null)\n            {\n                outputs = Array.Empty<ITaskItem>();\n            }\n            List<string> list = new List<string>(sources.Length + outputs.Length);\n            ITaskItem[] array = sources;\n            foreach (ITaskItem taskItem in array)\n            {\n                list.Add(FileUtilities.NormalizePath(taskItem.ItemSpec)/*.ToUpperInvariant()*/);\n            }\n            array = outputs;", "            foreach (ITaskItem taskItem in array)\n            {\n                list.Add(FileUtilities.NormalizePath(taskItem.ItemSpec)/*.ToUpperInvariant()*/);\n            }\n            array = outputs;\n            foreach (ITaskItem taskItem2 in array)\n            {\n                list.Add(FileUtilities.NormalizePath(taskItem2.ItemSpec)/*.ToUpperInvariant()*/);\n            }\n            list.Sort(StringComparer.OrdinalIgnoreCase);\n            return string.Join(\"|\", list);\n        }\n\n        internal static void LogMessageFromResources(TaskLoggingHelper Log, MessageImportance importance, string messageResourceName, params object[] messageArgs)\n        {", "            if (Log != null)\n            {\n                ErrorUtilities.VerifyThrowArgumentNull(messageResourceName, \"messageResourceName\");\n                Log.LogMessage(importance, messageResourceName, messageArgs);\n            }\n        }\n\n        internal static void LogMessage(TaskLoggingHelper Log, MessageImportance importance, string message, params object[] messageArgs)\n        {\n            Log?.LogMessage(importance, message, messageArgs);\n        }\n\n        internal static void LogWarningWithCodeFromResources(TaskLoggingHelper Log, string messageResourceName, params object[] messageArgs)\n        {\n            Log?.LogWarning(messageResourceName, messageArgs);\n            // Log?.LogWarningWithCodeFromResources(messageResourceName, messageArgs);\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.Shared/ErrorUtilities.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.IO;\nusing System.Threading;\nusing Microsoft.Build.Shared;\n\nnamespace Microsoft.Build.Shared\n{\n    internal static class ErrorUtilities\n    {\n#if __", "namespace Microsoft.Build.Shared\n{\n    internal static class ErrorUtilities\n    {\n#if __\n        private static readonly bool s_throwExceptions = string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDDONOTTHROWINTERNAL\"));\n\n        private static readonly bool s_enableMSBuildDebugTracing = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable(\"MSBUILDENABLEDEBUGTRACING\"));\n#else\n        private static readonly bool s_throwExceptions = true;\n#endif", "        private static readonly bool s_throwExceptions = true;\n#endif\n        public static void DebugTraceMessage(string category, string formatstring, params object[] parameters)\n        {\n#if __\n            if (s_enableMSBuildDebugTracing)\n            {\n                if (parameters != null)\n                {\n                    Trace.WriteLine(string.Format(CultureInfo.CurrentCulture, formatstring, parameters), category);\n                }\n                else\n                {\n                    Trace.WriteLine(formatstring, category);\n                }\n            }\n#endif\n        }\n\n        internal static void VerifyThrowInternalError(bool condition, string message, params object[] args)\n        {", "            if (s_throwExceptions && !condition)\n            {\n                throw new Exception(message);\n            }\n        }\n\n        internal static void ThrowInternalError(string message, params object[] args)\n        {\n            if (s_throwExceptions)\n            {\n                throw new Exception(message);\n            }\n        }\n\n        internal static void ThrowInternalError(string message, Exception innerException, params object[] args)\n        {", "            if (s_throwExceptions)\n            {\n                throw new Exception(message);\n            }\n        }\n\n        internal static void ThrowInternalError(string message, Exception innerException, params object[] args)\n        {\n            if (s_throwExceptions)\n            {\n                throw new Exception(message, innerException);\n            }\n        }\n\n        internal static void ThrowInternalErrorUnreachable()\n        {", "            if (s_throwExceptions)\n            {\n                throw new Exception(message, innerException);\n            }\n        }\n\n        internal static void ThrowInternalErrorUnreachable()\n        {\n            if (s_throwExceptions)\n            {\n                throw new Exception(\"Unreachable?\");\n            }\n        }\n\n        internal static void VerifyThrowInternalErrorUnreachable(bool condition)\n        {", "            if (s_throwExceptions)\n            {\n                throw new Exception(\"Unreachable?\");\n            }\n        }\n\n        internal static void VerifyThrowInternalErrorUnreachable(bool condition)\n        {\n            if (s_throwExceptions && !condition)\n            {\n                throw new Exception(\"Unreachable?\");\n            }\n        }\n\n        internal static void ThrowIfTypeDoesNotImplementToString(object param)\n        {\n        }\n\n        internal static void VerifyThrowInternalNull(object parameter, string parameterName)\n        {", "            if (s_throwExceptions && !condition)\n            {\n                throw new Exception(\"Unreachable?\");\n            }\n        }\n\n        internal static void ThrowIfTypeDoesNotImplementToString(object param)\n        {\n        }\n\n        internal static void VerifyThrowInternalNull(object parameter, string parameterName)\n        {", "            if (parameter == null)\n            {\n                ThrowInternalError(\"{0} unexpectedly null\", parameterName);\n            }\n        }\n\n        internal static void VerifyThrowInternalLockHeld(object locker)\n        {\n            if (!Monitor.IsEntered(locker))\n            {\n                ThrowInternalError(\"Lock should already have been taken\");\n            }\n        }\n\n        internal static void VerifyThrowInternalLength(string parameterValue, string parameterName)\n        {\n            VerifyThrowInternalNull(parameterValue, parameterName);", "            if (!Monitor.IsEntered(locker))\n            {\n                ThrowInternalError(\"Lock should already have been taken\");\n            }\n        }\n\n        internal static void VerifyThrowInternalLength(string parameterValue, string parameterName)\n        {\n            VerifyThrowInternalNull(parameterValue, parameterName);\n            if (parameterValue.Length == 0)\n            {\n                ThrowInternalError(\"{0} unexpectedly empty\", parameterName);\n            }\n        }\n", "            if (parameterValue.Length == 0)\n            {\n                ThrowInternalError(\"{0} unexpectedly empty\", parameterName);\n            }\n        }\n\n        public static void VerifyThrowInternalLength<T>(T[] parameterValue, string parameterName)\n        {\n            VerifyThrowInternalNull(parameterValue, parameterName);\n            if (parameterValue.Length == 0)\n            {\n                ThrowInternalError(\"{0} unexpectedly empty\", parameterName);\n            }\n        }\n\n        internal static void VerifyThrowInternalRooted(string value)\n        {", "            if (parameterValue.Length == 0)\n            {\n                ThrowInternalError(\"{0} unexpectedly empty\", parameterName);\n            }\n        }\n\n        internal static void VerifyThrowInternalRooted(string value)\n        {\n            if (!Path.IsPathRooted(value))\n            {\n                ThrowInternalError(\"{0} unexpectedly not a rooted path\", value);\n            }\n        }\n\n        internal static void VerifyThrow(bool condition, string unformattedMessage)\n        {", "            if (!Path.IsPathRooted(value))\n            {\n                ThrowInternalError(\"{0} unexpectedly not a rooted path\", value);\n            }\n        }\n\n        internal static void VerifyThrow(bool condition, string unformattedMessage)\n        {\n            if (!condition)\n            {\n                ThrowInternalError(unformattedMessage, null, null);\n            }\n        }\n\n        internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0)\n        {", "            if (!condition)\n            {\n                ThrowInternalError(unformattedMessage, null, null);\n            }\n        }\n\n        internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0)\n        {\n            if (!condition)\n            {\n                ThrowInternalError(unformattedMessage, arg0);\n            }\n        }\n\n        internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1)\n        {", "            if (!condition)\n            {\n                ThrowInternalError(unformattedMessage, arg0);\n            }\n        }\n\n        internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1)\n        {\n            if (!condition)\n            {\n                ThrowInternalError(unformattedMessage, arg0, arg1);\n            }\n        }\n\n        internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2)\n        {", "            if (!condition)\n            {\n                ThrowInternalError(unformattedMessage, arg0, arg1);\n            }\n        }\n\n        internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2)\n        {\n            if (!condition)\n            {\n                ThrowInternalError(unformattedMessage, arg0, arg1, arg2);\n            }\n        }\n\n        internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2, object arg3)\n        {", "            if (!condition)\n            {\n                ThrowInternalError(unformattedMessage, arg0, arg1, arg2);\n            }\n        }\n\n        internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2, object arg3)\n        {\n            if (!condition)\n            {\n                ThrowInternalError(unformattedMessage, arg0, arg1, arg2, arg3);\n            }\n        }\n\n        internal static void ThrowInvalidOperation(string resourceName, params object[] args)\n        {", "            if (!condition)\n            {\n                ThrowInternalError(unformattedMessage, arg0, arg1, arg2, arg3);\n            }\n        }\n\n        internal static void ThrowInvalidOperation(string resourceName, params object[] args)\n        {\n            if (s_throwExceptions)\n            {\n                throw new InvalidOperationException(resourceName);\n            }\n        }\n\n        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName)\n        {", "            if (s_throwExceptions)\n            {\n                throw new InvalidOperationException(resourceName);\n            }\n        }\n\n        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName)\n        {\n            if (!condition)\n            {\n                ThrowInvalidOperation(resourceName, null);\n            }\n        }\n\n        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0)\n        {", "            if (!condition)\n            {\n                ThrowInvalidOperation(resourceName, null);\n            }\n        }\n\n        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0)\n        {\n            if (!condition)\n            {\n                ThrowInvalidOperation(resourceName, arg0);\n            }\n        }\n\n        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1)\n        {", "            if (!condition)\n            {\n                ThrowInvalidOperation(resourceName, arg0);\n            }\n        }\n\n        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1)\n        {\n            if (!condition)\n            {\n                ThrowInvalidOperation(resourceName, arg0, arg1);\n            }\n        }\n\n        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2)\n        {", "            if (!condition)\n            {\n                ThrowInvalidOperation(resourceName, arg0, arg1);\n            }\n        }\n\n        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2)\n        {\n            if (!condition)\n            {\n                ThrowInvalidOperation(resourceName, arg0, arg1, arg2);\n            }\n        }\n\n        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3)\n        {", "            if (!condition)\n            {\n                ThrowInvalidOperation(resourceName, arg0, arg1, arg2);\n            }\n        }\n\n        internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3)\n        {\n            if (!condition)\n            {\n                ThrowInvalidOperation(resourceName, arg0, arg1, arg2, arg3);\n            }\n        }\n\n        internal static void ThrowArgument(string resourceName, params object[] args)\n        {\n            ThrowArgument(null, resourceName, args);\n        }\n", "            if (!condition)\n            {\n                ThrowInvalidOperation(resourceName, arg0, arg1, arg2, arg3);\n            }\n        }\n\n        internal static void ThrowArgument(string resourceName, params object[] args)\n        {\n            ThrowArgument(null, resourceName, args);\n        }\n", "        private static void ThrowArgument(Exception innerException, string resourceName, params object[] args)\n        {\n            if (s_throwExceptions)\n            {\n                throw new ArgumentException(resourceName, innerException);\n            }\n        }\n\n        internal static void VerifyThrowArgument(bool condition, string resourceName)\n        {\n            VerifyThrowArgument(condition, null, resourceName);\n        }\n\n        internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0)\n        {\n            VerifyThrowArgument(condition, null, resourceName, arg0);\n        }\n\n        internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1)\n        {\n            VerifyThrowArgument(condition, null, resourceName, arg0, arg1);\n        }\n\n        internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2)\n        {\n            VerifyThrowArgument(condition, null, resourceName, arg0, arg1, arg2);\n        }\n\n        internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3)\n        {\n            VerifyThrowArgument(condition, null, resourceName, arg0, arg1, arg2, arg3);\n        }\n\n        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName)\n        {", "            if (!condition)\n            {\n                ThrowArgument(innerException, resourceName, null);\n            }\n        }\n\n        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0)\n        {\n            if (!condition)\n            {\n                ThrowArgument(innerException, resourceName, arg0);\n            }\n        }\n\n        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1)\n        {", "            if (!condition)\n            {\n                ThrowArgument(innerException, resourceName, arg0);\n            }\n        }\n\n        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1)\n        {\n            if (!condition)\n            {\n                ThrowArgument(innerException, resourceName, arg0, arg1);\n            }\n        }\n\n        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2)\n        {", "            if (!condition)\n            {\n                ThrowArgument(innerException, resourceName, arg0, arg1);\n            }\n        }\n\n        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2)\n        {\n            if (!condition)\n            {\n                ThrowArgument(innerException, resourceName, arg0, arg1, arg2);\n            }\n        }\n\n        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2, object arg3)\n        {", "            if (!condition)\n            {\n                ThrowArgument(innerException, resourceName, arg0, arg1, arg2);\n            }\n        }\n\n        internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2, object arg3)\n        {\n            if (!condition)\n            {\n                ThrowArgument(innerException, resourceName, arg0, arg1, arg2, arg3);\n            }\n        }\n\n        internal static void ThrowArgumentOutOfRange(string parameterName)\n        {", "            if (!condition)\n            {\n                ThrowArgument(innerException, resourceName, arg0, arg1, arg2, arg3);\n            }\n        }\n\n        internal static void ThrowArgumentOutOfRange(string parameterName)\n        {\n            if (s_throwExceptions)\n            {\n                throw new ArgumentOutOfRangeException(parameterName);\n            }\n        }\n\n        internal static void VerifyThrowArgumentOutOfRange(bool condition, string parameterName)\n        {", "            if (s_throwExceptions)\n            {\n                throw new ArgumentOutOfRangeException(parameterName);\n            }\n        }\n\n        internal static void VerifyThrowArgumentOutOfRange(bool condition, string parameterName)\n        {\n            if (!condition)\n            {\n                ThrowArgumentOutOfRange(parameterName);\n            }\n        }\n\n        internal static void VerifyThrowArgumentLength(string parameter, string parameterName)\n        {\n            VerifyThrowArgumentNull(parameter, parameterName);", "            if (!condition)\n            {\n                ThrowArgumentOutOfRange(parameterName);\n            }\n        }\n\n        internal static void VerifyThrowArgumentLength(string parameter, string parameterName)\n        {\n            VerifyThrowArgumentNull(parameter, parameterName);\n            if (parameter.Length == 0 && s_throwExceptions)\n            {\n                throw new ArgumentException(\"Shared.ParameterCannotHaveZeroLength\" + parameterName);\n            }\n        }\n\n        internal static void VerifyThrowArgumentLength<T>(IReadOnlyCollection<T> parameter, string parameterName)\n        {\n            VerifyThrowArgumentNull(parameter, parameterName);", "            if (parameter.Length == 0 && s_throwExceptions)\n            {\n                throw new ArgumentException(\"Shared.ParameterCannotHaveZeroLength\" + parameterName);\n            }\n        }\n\n        internal static void VerifyThrowArgumentLength<T>(IReadOnlyCollection<T> parameter, string parameterName)\n        {\n            VerifyThrowArgumentNull(parameter, parameterName);\n            if (parameter.Count == 0 && s_throwExceptions)\n            {\n                throw new ArgumentException(\"Shared.ParameterCannotHaveZeroLength\" + parameterName);\n            }\n        }\n\n        internal static void VerifyThrowArgumentLengthIfNotNull<T>(IReadOnlyCollection<T> parameter, string parameterName)\n        {", "            if (parameter.Count == 0 && s_throwExceptions)\n            {\n                throw new ArgumentException(\"Shared.ParameterCannotHaveZeroLength\" + parameterName);\n            }\n        }\n\n        internal static void VerifyThrowArgumentLengthIfNotNull<T>(IReadOnlyCollection<T> parameter, string parameterName)\n        {\n            if (parameter != null && parameter.Count == 0 && s_throwExceptions)\n            {\n                throw new ArgumentException( \"Shared.ParameterCannotHaveZeroLength\" + parameterName);\n            }\n        }\n\n        internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName)\n        {", "            if (parameter != null && parameter.Count == 0 && s_throwExceptions)\n            {\n                throw new ArgumentException( \"Shared.ParameterCannotHaveZeroLength\" + parameterName);\n            }\n        }\n\n        internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName)\n        {\n            if (parameter != null && parameter.Length == 0 && s_throwExceptions)\n            {\n                throw new ArgumentException(\"Shared.ParameterCannotHaveZeroLength\" + parameterName);\n            }\n        }\n\n        internal static void VerifyThrowArgumentNull(object parameter, string parameterName)\n        {\n            VerifyThrowArgumentNull(parameter, parameterName, \"Shared.ParameterCannotBeNull\");\n        }\n\n        internal static void VerifyThrowArgumentNull(object parameter, string parameterName, string resourceName)\n        {", "            if (parameter != null && parameter.Length == 0 && s_throwExceptions)\n            {\n                throw new ArgumentException(\"Shared.ParameterCannotHaveZeroLength\" + parameterName);\n            }\n        }\n\n        internal static void VerifyThrowArgumentNull(object parameter, string parameterName)\n        {\n            VerifyThrowArgumentNull(parameter, parameterName, \"Shared.ParameterCannotBeNull\");\n        }\n\n        internal static void VerifyThrowArgumentNull(object parameter, string parameterName, string resourceName)\n        {", "            if (parameter == null && s_throwExceptions)\n            {\n                throw new ArgumentNullException(resourceName + parameterName, (Exception?)null);\n            }\n        }\n\n        internal static void VerifyThrowArgumentArraysSameLength(Array parameter1, Array parameter2, string parameter1Name, string parameter2Name)\n        {\n            VerifyThrowArgumentNull(parameter1, parameter1Name);\n            VerifyThrowArgumentNull(parameter2, parameter2Name);\n            if (parameter1.Length != parameter2.Length && s_throwExceptions)\n            {\n                throw new ArgumentException(\"Shared.ParametersMustHaveTheSameLength\" + parameter1Name, parameter2Name);\n            }\n        }\n\n        internal static void VerifyThrowObjectDisposed(bool condition, string objectName)\n        {", "            if (parameter1.Length != parameter2.Length && s_throwExceptions)\n            {\n                throw new ArgumentException(\"Shared.ParametersMustHaveTheSameLength\" + parameter1Name, parameter2Name);\n            }\n        }\n\n        internal static void VerifyThrowObjectDisposed(bool condition, string objectName)\n        {\n            if (s_throwExceptions && !condition)\n            {\n                throw new ObjectDisposedException(objectName);\n            }\n        }\n    }\n}\n", "            if (s_throwExceptions && !condition)\n            {\n                throw new ObjectDisposedException(objectName);\n            }\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.Shared/FileUtilitiesRegex.cs", "chunked_list": ["\ufeffusing System.Runtime.CompilerServices;\n\nnamespace Microsoft.Build.Shared\n{\n    internal static class FileUtilitiesRegex\n    {\n        private static readonly char _backSlash = '\\\\';\n\n        private static readonly char _forwardSlash = '/';\n\n        internal static bool IsDrivePattern(string pattern)\n        {", "        private static readonly char _forwardSlash = '/';\n\n        internal static bool IsDrivePattern(string pattern)\n        {\n            if (pattern.Length == 2)\n            {\n                return StartsWithDrivePattern(pattern);\n            }\n            return false;\n        }\n\n        internal static bool IsDrivePatternWithSlash(string pattern)\n        {", "            if (pattern.Length == 3)\n            {\n                return StartsWithDrivePatternWithSlash(pattern);\n            }\n            return false;\n        }\n\n        internal static bool StartsWithDrivePattern(string pattern)\n        {\n            if (pattern.Length >= 2 && ((pattern[0] >= 'A' && pattern[0] <= 'Z') || (pattern[0] >= 'a' && pattern[0] <= 'z')))\n            {\n                return pattern[1] == ':';\n            }\n            return false;\n        }\n\n        internal static bool StartsWithDrivePatternWithSlash(string pattern)\n        {", "            if (pattern.Length >= 2 && ((pattern[0] >= 'A' && pattern[0] <= 'Z') || (pattern[0] >= 'a' && pattern[0] <= 'z')))\n            {\n                return pattern[1] == ':';\n            }\n            return false;\n        }\n\n        internal static bool StartsWithDrivePatternWithSlash(string pattern)\n        {\n            if (pattern.Length >= 3 && StartsWithDrivePattern(pattern))\n            {", "            if (pattern.Length >= 3 && StartsWithDrivePattern(pattern))\n            {\n                if (pattern[2] != _backSlash)\n                {\n                    return pattern[2] == _forwardSlash;\n                }\n                return true;\n            }\n            return false;\n        }\n\n        internal static bool IsUncPattern(string pattern)\n        {\n            return StartsWithUncPatternMatchLength(pattern) == pattern.Length;\n        }\n\n        internal static bool StartsWithUncPattern(string pattern)\n        {\n            return StartsWithUncPatternMatchLength(pattern) != -1;\n        }\n\n        internal static int StartsWithUncPatternMatchLength(string pattern)\n        {", "            if (!MeetsUncPatternMinimumRequirements(pattern))\n            {\n                return -1;\n            }\n            bool flag = true;\n            bool flag2 = false;\n            for (int i = 2; i < pattern.Length; i++)\n            {\n                if (pattern[i] == _backSlash || pattern[i] == _forwardSlash)\n                {\n                    if (flag)\n                    {\n                        return -1;\n                    }", "                if (pattern[i] == _backSlash || pattern[i] == _forwardSlash)\n                {\n                    if (flag)\n                    {\n                        return -1;\n                    }\n                    if (flag2)\n                    {\n                        return i;\n                    }\n                    flag2 = true;\n                    flag = true;\n                }\n                else\n                {\n                    flag = false;\n                }\n            }", "            if (!flag2)\n            {\n                return -1;\n            }\n            return pattern.Length;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        internal static bool MeetsUncPatternMinimumRequirements(string pattern)\n        {\n            if (pattern.Length >= 5 && (pattern[0] == _backSlash || pattern[0] == _forwardSlash))\n            {", "            if (pattern.Length >= 5 && (pattern[0] == _backSlash || pattern[0] == _forwardSlash))\n            {\n                if (pattern[1] != _backSlash)\n                {\n                    return pattern[1] == _forwardSlash;\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.Shared/MSBuildConstants.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Microsoft.Build.Shared\n{\n    internal class MSBuildConstants\n    {\n        internal static readonly char[] PipeChar = new char[1] { '|' };\n    }\n}\n"]}
{"filename": "Microsoft.Build.Shared/EscapingUtilities.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Text;\nusing Microsoft.Build.Shared;\nusing Microsoft.NET.StringTools;\n\nnamespace Microsoft.Build.Shared\n{\n    internal static class EscapingUtilities\n    {\n        private static Dictionary<string, string> s_unescapedToEscapedStrings = new Dictionary<string, string>(StringComparer.Ordinal);\n", "    internal static class EscapingUtilities\n    {\n        private static Dictionary<string, string> s_unescapedToEscapedStrings = new Dictionary<string, string>(StringComparer.Ordinal);\n\n        private static readonly char[] s_charsToEscape = new char[9] { '%', '*', '?', '@', '$', '(', ')', ';', '\\'' };\n\n        private static bool TryDecodeHexDigit(char character, out int value)\n        {\n            if (character >= '0' && character <= '9')\n            {\n                value = character - 48;\n                return true;\n            }", "            if (character >= '0' && character <= '9')\n            {\n                value = character - 48;\n                return true;\n            }\n            if (character >= 'A' && character <= 'F')\n            {\n                value = character - 65 + 10;\n                return true;\n            }\n            if (character >= 'a' && character <= 'f')\n            {\n                value = character - 97 + 10;\n                return true;\n            }\n            value = 0;\n            return false;\n        }\n\n        internal static string UnescapeAll(string escapedString, bool trim = false)\n        {", "            if (character >= 'a' && character <= 'f')\n            {\n                value = character - 97 + 10;\n                return true;\n            }\n            value = 0;\n            return false;\n        }\n\n        internal static string UnescapeAll(string escapedString, bool trim = false)\n        {", "            if (string.IsNullOrEmpty(escapedString))\n            {\n                return escapedString;\n            }\n            int num = escapedString.IndexOf('%');\n            if (num == -1)\n            {\n                if (!trim)\n                {\n                    return escapedString;\n                }\n                return escapedString.Trim();\n            }\n            StringBuilder stringBuilder = StringBuilderCache.Acquire(escapedString.Length);\n            int i = 0;\n            int num2 = escapedString.Length;", "            if (trim)\n            {\n                for (; i < escapedString.Length && char.IsWhiteSpace(escapedString[i]); i++)\n                {\n                }\n                if (i == escapedString.Length)\n                {\n                    return string.Empty;\n                }\n                while (char.IsWhiteSpace(escapedString[num2 - 1]))\n                {\n                    num2--;\n                }\n            }", "                while (char.IsWhiteSpace(escapedString[num2 - 1]))\n                {\n                    num2--;\n                }\n            }\n            while (num != -1)\n            {\n                if (num <= num2 - 3 && TryDecodeHexDigit(escapedString[num + 1], out var value) && TryDecodeHexDigit(escapedString[num + 2], out var value2))\n                {\n                    stringBuilder.Append(escapedString, i, num - i);\n                    char value3 = (char)((value << 4) + value2);\n                    stringBuilder.Append(value3);\n                    i = num + 3;\n                }\n                num = escapedString.IndexOf('%', num + 1);\n            }\n            stringBuilder.Append(escapedString, i, num2 - i);\n            return StringBuilderCache.GetStringAndRelease(stringBuilder);\n        }\n\n        internal static string EscapeWithCaching(string unescapedString)\n        {\n            return EscapeWithOptionalCaching(unescapedString, cache: true);\n        }\n\n        internal static string Escape(string unescapedString)\n        {\n            return EscapeWithOptionalCaching(unescapedString, cache: false);\n        }\n", "        private static string EscapeWithOptionalCaching(string unescapedString, bool cache)\n        {\n            if (string.IsNullOrEmpty(unescapedString) || !ContainsReservedCharacters(unescapedString))\n            {\n                return unescapedString;\n            }\n            if (cache)\n            {\n                lock (s_unescapedToEscapedStrings)\n                {\n                    if (s_unescapedToEscapedStrings.TryGetValue(unescapedString, out var value))\n                    {\n                        return value;\n                    }\n                }\n            }\n            StringBuilder stringBuilder = StringBuilderCache.Acquire(unescapedString.Length * 2);\n            AppendEscapedString(stringBuilder, unescapedString);", "                    if (s_unescapedToEscapedStrings.TryGetValue(unescapedString, out var value))\n                    {\n                        return value;\n                    }\n                }\n            }\n            StringBuilder stringBuilder = StringBuilderCache.Acquire(unescapedString.Length * 2);\n            AppendEscapedString(stringBuilder, unescapedString);\n            if (!cache)\n            {\n                return StringBuilderCache.GetStringAndRelease(stringBuilder);\n            }\n            string text = Strings.WeakIntern(stringBuilder.ToString());\n            StringBuilderCache.Release(stringBuilder);\n            lock (s_unescapedToEscapedStrings)\n            {\n                s_unescapedToEscapedStrings[unescapedString] = text;\n                return text;\n            }\n        }\n", "            if (!cache)\n            {\n                return StringBuilderCache.GetStringAndRelease(stringBuilder);\n            }\n            string text = Strings.WeakIntern(stringBuilder.ToString());\n            StringBuilderCache.Release(stringBuilder);\n            lock (s_unescapedToEscapedStrings)\n            {\n                s_unescapedToEscapedStrings[unescapedString] = text;\n                return text;\n            }\n        }\n", "        private static bool ContainsReservedCharacters(string unescapedString)\n        {\n            return -1 != unescapedString.IndexOfAny(s_charsToEscape);\n        }\n\n        internal static bool ContainsEscapedWildcards(string escapedString)\n        {\n            if (escapedString.Length < 3)\n            {\n                return false;\n            }", "            for (int num = escapedString.IndexOf('%', 0, escapedString.Length - 2); num != -1; num = escapedString.IndexOf('%', num + 1, escapedString.Length - (num + 1) - 2))\n            {\n                if (escapedString[num + 1] == '2' && (escapedString[num + 2] == 'a' || escapedString[num + 2] == 'A'))\n                {\n                    return true;\n                }\n                if (escapedString[num + 1] == '3' && (escapedString[num + 2] == 'f' || escapedString[num + 2] == 'F'))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n", "        private static char HexDigitChar(int x)\n        {\n            return (char)(x + ((x < 10) ? 48 : 87));\n        }\n\n        private static void AppendEscapedChar(StringBuilder sb, char ch)\n        {\n            sb.Append('%');\n            sb.Append(HexDigitChar((int)ch / 16));\n            sb.Append(HexDigitChar(ch & 0xF));\n        }\n", "        private static void AppendEscapedString(StringBuilder sb, string unescapedString)\n        {\n            int num = 0;\n            while (true)\n            {\n                int num2 = unescapedString.IndexOfAny(s_charsToEscape, num);\n                if (num2 == -1)\n                {\n                    break;\n                }\n                sb.Append(unescapedString, num, num2 - num);\n                AppendEscapedChar(sb, unescapedString[num2]);\n                num = num2 + 1;\n            }\n            sb.Append(unescapedString, num, unescapedString.Length - num);\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.Shared/FileMatcher.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.IO.Enumeration;\nusing System.Linq;\nusing System.Security;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;", "using System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Microsoft.Build.Shared;\nusing Microsoft.Build.Shared.FileSystem;\nusing Microsoft.Build.Utilities;\nusing Microsoft.VisualBasic.FileIO;\n\nnamespace Microsoft.Build.Shared\n{\n    internal class FileMatcher\n    {", "{\n    internal class FileMatcher\n    {\n        private class TaskOptions\n        {\n            public readonly int MaxTasks;\n\n            public int AvailableTasks;\n\n            public int MaxTasksPerIteration;\n\n            public TaskOptions(int maxTasks)\n            {\n                MaxTasks = maxTasks;\n            }\n        }\n\n", "            public int MaxTasksPerIteration;\n\n            public TaskOptions(int maxTasks)\n            {\n                MaxTasks = maxTasks;\n            }\n        }\n\n\n        private struct RecursiveStepResult\n        {", "        private struct RecursiveStepResult\n        {\n            public string RemainingWildcardDirectory;\n\n            public bool ConsiderFiles;\n\n            public bool NeedsToProcessEachFile;\n\n            public string DirectoryPattern;\n\n            public bool NeedsDirectoryRecursion;\n        }\n", "            public string DirectoryPattern;\n\n            public bool NeedsDirectoryRecursion;\n        }\n\n        private enum SearchAction\n        {\n            RunSearch,\n            ReturnFileSpec,\n            ReturnEmptyList\n        }\n\n", "        internal enum FileSystemEntity\n        {\n            Files,\n            Directories,\n            FilesAndDirectories\n        }\n\n        private class FilesSearchData\n        {\n            public string Filespec { get; }\n", "            public string Filespec { get; }\n\n            public string DirectoryPattern { get; }\n\n            public Regex RegexFileMatch { get; }\n\n            public bool NeedsRecursion { get; }\n\n            public FilesSearchData(string filespec, string directoryPattern, Regex regexFileMatch, bool needsRecursion)\n            {\n                Filespec = filespec;\n                DirectoryPattern = directoryPattern;\n                RegexFileMatch = regexFileMatch;\n                NeedsRecursion = needsRecursion;\n            }\n        }\n", "        internal sealed class Result\n        {\n            internal bool isLegalFileSpec;\n\n            internal bool isMatch;\n\n            internal bool isFileSpecRecursive;\n\n            internal string wildcardDirectoryPart = string.Empty;\n\n            internal Result()\n            {\n            }\n        }\n", "        private struct RecursionState\n        {\n            public string BaseDirectory;\n\n            public string RemainingWildcardDirectory;\n\n            public bool IsInsideMatchingDirectory;\n\n            public FilesSearchData SearchData;\n\n            public bool IsLookingForMatchingDirectory\n            {\n                get\n                {", "            public FilesSearchData SearchData;\n\n            public bool IsLookingForMatchingDirectory\n            {\n                get\n                {\n                    if (SearchData.DirectoryPattern != null)\n                    {\n                        return !IsInsideMatchingDirectory;\n                    }\n                    return false;\n                }\n            }\n        }\n", "        private static readonly string s_directorySeparator = new string(Path.DirectorySeparatorChar, 1);\n\n        private static readonly string s_thisDirectory = \".\" + s_directorySeparator;\n\n        public static FileMatcher Default = new FileMatcher(FileSystems.Default);\n\n        private static readonly char[] s_wildcardCharacters = new char[2] { '*', '?' };\n\n        internal delegate IReadOnlyList<string> GetFileSystemEntries(FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory);\n\n        private readonly ConcurrentDictionary<string, IReadOnlyList<string>> _cachedGlobExpansions;\n", "        internal delegate IReadOnlyList<string> GetFileSystemEntries(FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory);\n\n        private readonly ConcurrentDictionary<string, IReadOnlyList<string>> _cachedGlobExpansions;\n\n        private readonly Lazy<ConcurrentDictionary<string, object>> _cachedGlobExpansionsLock = new Lazy<ConcurrentDictionary<string, object>>(() => new ConcurrentDictionary<string, object>(StringComparer.OrdinalIgnoreCase));\n\n        private static readonly Lazy<ConcurrentDictionary<string, IReadOnlyList<string>>> s_cachedGlobExpansions = new Lazy<ConcurrentDictionary<string, IReadOnlyList<string>>>(() => new ConcurrentDictionary<string, IReadOnlyList<string>>(StringComparer.OrdinalIgnoreCase));\n\n        private static readonly Lazy<ConcurrentDictionary<string, object>> s_cachedGlobExpansionsLock = new Lazy<ConcurrentDictionary<string, object>>(() => new ConcurrentDictionary<string, object>(StringComparer.OrdinalIgnoreCase));\n        \n        private readonly IFileSystem _fileSystem;\n", "        private static readonly Lazy<ConcurrentDictionary<string, object>> s_cachedGlobExpansionsLock = new Lazy<ConcurrentDictionary<string, object>>(() => new ConcurrentDictionary<string, object>(StringComparer.OrdinalIgnoreCase));\n        \n        private readonly IFileSystem _fileSystem;\n\n        private readonly GetFileSystemEntries _getFileSystemEntries;\n\n        internal static readonly char[] directorySeparatorCharacters = FileUtilities.Slashes;\n\n        private static readonly char[] s_invalidPathChars = Path.GetInvalidPathChars();\n\n        public FileMatcher(IFileSystem fileSystem, ConcurrentDictionary<string, IReadOnlyList<string>> fileEntryExpansionCache = null)\n        : this(fileSystem, (FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory) => GetAccessibleFileSystemEntries(fileSystem, entityType, path, pattern, projectDirectory, stripProjectDirectory).ToArray(), fileEntryExpansionCache)\n        {\n        }\n\n        internal FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemEntries, ConcurrentDictionary<string, IReadOnlyList<string>> getFileSystemDirectoryEntriesCache = null)\n        {", "        private static readonly char[] s_invalidPathChars = Path.GetInvalidPathChars();\n\n        public FileMatcher(IFileSystem fileSystem, ConcurrentDictionary<string, IReadOnlyList<string>> fileEntryExpansionCache = null)\n        : this(fileSystem, (FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory) => GetAccessibleFileSystemEntries(fileSystem, entityType, path, pattern, projectDirectory, stripProjectDirectory).ToArray(), fileEntryExpansionCache)\n        {\n        }\n\n        internal FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemEntries, ConcurrentDictionary<string, IReadOnlyList<string>> getFileSystemDirectoryEntriesCache = null)\n        {\n            if (/*Traits.Instance.MSBuildCacheFileEnumerations*/false)\n            {\n                _cachedGlobExpansions = s_cachedGlobExpansions.Value;\n                _cachedGlobExpansionsLock = s_cachedGlobExpansionsLock;\n            }\n            else\n            {\n                _cachedGlobExpansions = getFileSystemDirectoryEntriesCache;\n            }\n            _fileSystem = fileSystem;\n            _getFileSystemEntries = ((getFileSystemDirectoryEntriesCache == null) ? getFileSystemEntries : ((GetFileSystemEntries)delegate (FileSystemEntity type, string path, string pattern, string directory, bool stripProjectDirectory)\n            {\n#if __", "            if (/*Traits.Instance.MSBuildCacheFileEnumerations*/false)\n            {\n                _cachedGlobExpansions = s_cachedGlobExpansions.Value;\n                _cachedGlobExpansionsLock = s_cachedGlobExpansionsLock;\n            }\n            else\n            {\n                _cachedGlobExpansions = getFileSystemDirectoryEntriesCache;\n            }\n            _fileSystem = fileSystem;\n            _getFileSystemEntries = ((getFileSystemDirectoryEntriesCache == null) ? getFileSystemEntries : ((GetFileSystemEntries)delegate (FileSystemEntity type, string path, string pattern, string directory, bool stripProjectDirectory)\n            {\n#if __", "                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))\n                {\n                    string key = type switch\n                    {\n                        FileSystemEntity.Files => \"F\",\n                        FileSystemEntity.Directories => \"D\",\n                        FileSystemEntity.FilesAndDirectories => \"A\",\n                        _ => throw new NotImplementedException(),\n                    } + \";\" + path;\n                    IReadOnlyList<string> orAdd = getFileSystemDirectoryEntriesCache.GetOrAdd(key, (string s) => getFileSystemEntries(type, path, \"*\", directory, stripProjectDirectory: false));\n                    IEnumerable<string> enumerable2;", "                    if (pattern == null || IsAllFilesWildcard(pattern))\n                    {\n                        IEnumerable<string> enumerable = orAdd;\n                        enumerable2 = enumerable;\n                    }\n                    else\n                    {\n                        enumerable2 = orAdd.Where((string o) => IsMatch(Path.GetFileName(o), pattern));\n                    }\n                    IEnumerable<string> enumerable3 = enumerable2;\n                    if (!stripProjectDirectory)\n                    {\n                        return enumerable3.ToArray();\n                    }\n                    return RemoveProjectDirectory(enumerable3, directory).ToArray();\n                }\n#endif\n                return (type == FileSystemEntity.Directories) ? getFileSystemDirectoryEntriesCache.GetOrAdd(\"D;\" + path + \";\" + (pattern ?? \"*\"), (string s) => getFileSystemEntries(type, path, pattern, directory, stripProjectDirectory).ToArray()) : getFileSystemEntries(type, path, pattern, directory, stripProjectDirectory);\n            }));\n        }\n\n        internal static bool HasWildcards(string filespec)\n        {\n            return -1 != filespec.LastIndexOfAny(s_wildcardCharacters);\n        }\n", "                    if (!stripProjectDirectory)\n                    {\n                        return enumerable3.ToArray();\n                    }\n                    return RemoveProjectDirectory(enumerable3, directory).ToArray();\n                }\n#endif\n                return (type == FileSystemEntity.Directories) ? getFileSystemDirectoryEntriesCache.GetOrAdd(\"D;\" + path + \";\" + (pattern ?? \"*\"), (string s) => getFileSystemEntries(type, path, pattern, directory, stripProjectDirectory).ToArray()) : getFileSystemEntries(type, path, pattern, directory, stripProjectDirectory);\n            }));\n        }\n\n        internal static bool HasWildcards(string filespec)\n        {\n            return -1 != filespec.LastIndexOfAny(s_wildcardCharacters);\n        }\n", "        private static IReadOnlyList<string> GetAccessibleFileSystemEntries(IFileSystem fileSystem, FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory)\n        {\n            path = FileUtilities.FixFilePath(path);\n            switch (entityType)\n            {\n                case FileSystemEntity.Files:\n                    return GetAccessibleFiles(fileSystem, path, pattern, projectDirectory, stripProjectDirectory);\n                case FileSystemEntity.Directories:\n                    return GetAccessibleDirectories(fileSystem, path, pattern);\n                case FileSystemEntity.FilesAndDirectories:\n                    return GetAccessibleFilesAndDirectories(fileSystem, path, pattern);\n                default:\n                    ErrorUtilities.VerifyThrow(condition: false, \"Unexpected filesystem entity type.\");\n                    return Array.Empty<string>();\n            }\n        }\n", "        private static IReadOnlyList<string> GetAccessibleFilesAndDirectories(IFileSystem fileSystem, string path, string pattern)\n        {\n            if (fileSystem.DirectoryExists(path))\n            {\n                try\n                {\n                    return (ShouldEnforceMatching(pattern) ? (from o in fileSystem.EnumerateFileSystemEntries(path, pattern)\n                                                              where IsMatch(Path.GetFileName(o), pattern)\n                                                              select o) : fileSystem.EnumerateFileSystemEntries(path, pattern)).ToArray();\n                }\n                catch (UnauthorizedAccessException)\n                {\n                }", "                catch (UnauthorizedAccessException)\n                {\n                }\n                catch (SecurityException)\n                {\n                }\n            }\n            return Array.Empty<string>();\n        }\n\n        private static bool ShouldEnforceMatching(string searchPattern)\n        {", "        private static bool ShouldEnforceMatching(string searchPattern)\n        {\n            if (searchPattern == null)\n            {\n                return false;\n            }\n            if (searchPattern.IndexOf(\"?.\", StringComparison.Ordinal) == -1 && (Path.GetExtension(searchPattern).Length != 4 || searchPattern.IndexOf('*') == -1))\n            {\n                return searchPattern.EndsWith(\"?\", StringComparison.Ordinal);\n            }\n            return true;\n        }\n", "        private static IReadOnlyList<string> GetAccessibleFiles(IFileSystem fileSystem, string path, string filespec, string projectDirectory, bool stripProjectDirectory)\n        {\n            try\n            {\n                string path2 = ((path.Length == 0) ? s_thisDirectory : path);\n                IEnumerable<string> enumerable;\n                if (filespec == null)\n                {\n                    enumerable = fileSystem.EnumerateFiles(path2);\n                }\n                else\n                {\n                    enumerable = fileSystem.EnumerateFiles(path2, filespec);", "                    if (ShouldEnforceMatching(filespec))\n                    {\n                        enumerable = enumerable.Where((string o) => IsMatch(Path.GetFileName(o), filespec));\n                    }\n                }\n                if (stripProjectDirectory)\n                {\n                    enumerable = RemoveProjectDirectory(enumerable, projectDirectory);\n                }\n                else if (!path.StartsWith(s_thisDirectory, StringComparison.Ordinal))\n                {\n                    enumerable = RemoveInitialDotSlash(enumerable);\n                }\n                return enumerable.ToArray();\n            }", "                else if (!path.StartsWith(s_thisDirectory, StringComparison.Ordinal))\n                {\n                    enumerable = RemoveInitialDotSlash(enumerable);\n                }\n                return enumerable.ToArray();\n            }\n            catch (SecurityException)\n            {\n                return Array.Empty<string>();\n            }\n            catch (UnauthorizedAccessException)\n            {\n                return Array.Empty<string>();\n            }\n        }\n", "            catch (UnauthorizedAccessException)\n            {\n                return Array.Empty<string>();\n            }\n        }\n\n        private static IReadOnlyList<string> GetAccessibleDirectories(IFileSystem fileSystem, string path, string pattern)\n        {\n            try\n            {\n                IEnumerable<string> enumerable = null;", "                if (pattern == null)\n                {\n                    enumerable = fileSystem.EnumerateDirectories((path.Length == 0) ? s_thisDirectory : path);\n                }\n                else\n                {\n                    enumerable = fileSystem.EnumerateDirectories((path.Length == 0) ? s_thisDirectory : path, pattern);\n                    if (ShouldEnforceMatching(pattern))\n                    {\n                        enumerable = enumerable.Where((string o) => IsMatch(Path.GetFileName(o), pattern));\n                    }\n                }", "                if (!path.StartsWith(s_thisDirectory, StringComparison.Ordinal))\n                {\n                    enumerable = RemoveInitialDotSlash(enumerable);\n                }\n                return enumerable.ToArray();\n            }\n            catch (SecurityException)\n            {\n                return Array.Empty<string>();\n            }\n            catch (UnauthorizedAccessException)\n            {\n                return Array.Empty<string>();\n            }\n        }\n", "            catch (UnauthorizedAccessException)\n            {\n                return Array.Empty<string>();\n            }\n        }\n\n        private static IEnumerable<string> RemoveInitialDotSlash(IEnumerable<string> paths)\n        {\n            foreach (string path in paths)\n            {\n                if (path.StartsWith(s_thisDirectory, StringComparison.Ordinal))\n                {\n                    yield return path.Substring(2);\n                }\n                else\n                {\n                    yield return path;\n                }\n            }\n        }\n\n        internal static bool IsDirectorySeparator(char c)\n        {", "            foreach (string path in paths)\n            {\n                if (path.StartsWith(s_thisDirectory, StringComparison.Ordinal))\n                {\n                    yield return path.Substring(2);\n                }\n                else\n                {\n                    yield return path;\n                }\n            }\n        }\n\n        internal static bool IsDirectorySeparator(char c)\n        {", "            if (c != Path.DirectorySeparatorChar)\n            {\n                return c == Path.AltDirectorySeparatorChar;\n            }\n            return true;\n        }\n\n        internal static IEnumerable<string> RemoveProjectDirectory(IEnumerable<string> paths, string projectDirectory)\n        {\n            bool directoryLastCharIsSeparator = IsDirectorySeparator(projectDirectory[projectDirectory.Length - 1]);\n            foreach (string path in paths)\n            {", "            foreach (string path in paths)\n            {\n                if (path.StartsWith(projectDirectory, StringComparison.Ordinal))\n                {\n                    if (!directoryLastCharIsSeparator)\n                    {\n                        if (path.Length <= projectDirectory.Length || !IsDirectorySeparator(path[projectDirectory.Length]))\n                        {\n                            yield return path;\n                        }\n                        else\n                        {\n                            yield return path.Substring(projectDirectory.Length + 1);\n                        }\n                    }\n                    else\n                    {\n                        yield return path.Substring(projectDirectory.Length);\n                    }\n                }\n                else\n                {\n                    yield return path;\n                }\n            }\n        }\n\n        internal static bool IsMatch(string input, string pattern)\n        {", "            if (input == null)\n            {\n                throw new ArgumentNullException(\"input\");\n            }\n            if (pattern == null)\n            {\n                throw new ArgumentNullException(\"pattern\");\n            }\n            int num = pattern.Length;\n            int num2 = input.Length;\n            int num3 = -1;\n            int num4 = -1;\n            int i = 0;\n            int num5 = 0;\n            bool flag = false;", "            while (num5 < num2)\n            {\n                if (i < num)\n                {\n                    if (pattern[i] == '*')\n                    {\n                        while (++i < num && pattern[i] == '*')\n                        {\n                        }\n                        if (i >= num)\n                        {\n                            return true;\n                        }", "                        if (i >= num)\n                        {\n                            return true;\n                        }\n                        if (!flag)\n                        {\n                            int num6 = num2;\n                            int num7 = num;\n                            while (i < num7 && num6 > num5)\n                            {\n                                num7--;\n                                num6--;", "                            while (i < num7 && num6 > num5)\n                            {\n                                num7--;\n                                num6--;\n                                if (pattern[num7] == '*')\n                                {\n                                    break;\n                                }\n                                if (!CompareIgnoreCase(input[num6], pattern[num7], num7, num6) && pattern[num7] != '?')\n                                {\n                                    return false;\n                                }", "                                if (!CompareIgnoreCase(input[num6], pattern[num7], num7, num6) && pattern[num7] != '?')\n                                {\n                                    return false;\n                                }\n                                if (i == num7)\n                                {\n                                    return true;\n                                }\n                            }\n                            num2 = num6 + 1;\n                            num = num7 + 1;\n                            flag = true;\n                        }", "                        if (pattern[i] != '?')\n                        {\n                            while (!CompareIgnoreCase(input[num5], pattern[i], num5, i))\n                            {\n                                if (++num5 >= num2)\n                                {\n                                    return false;\n                                }\n                            }\n                        }\n                        num3 = i;\n                        num4 = num5;\n                        continue;\n                    }", "                    if (CompareIgnoreCase(input[num5], pattern[i], num5, i) || pattern[i] == '?')\n                    {\n                        i++;\n                        num5++;\n                        continue;\n                    }\n                }\n                if (num3 < 0)\n                {\n                    return false;\n                }\n                i = num3;\n                num5 = num4++;\n            }", "            for (; i < num && pattern[i] == '*'; i++)\n            {\n            }\n            return i >= num;\n            bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)\n            {\n                char c = (char)(inputChar | 0x20u);\n                if (c >= 'a' && c <= 'z')\n                {\n                    return c == (patternChar | 0x20);\n                }", "                if (inputChar < '\\u0080' || patternChar < '\\u0080')\n                {\n                    return inputChar == patternChar;\n                }\n                return string.Compare(input, iIndex, pattern, pIndex, 1, StringComparison.OrdinalIgnoreCase) == 0;\n            }\n        }\n\n        private static string ComputeFileEnumerationCacheKey(string projectDirectoryUnescaped, string filespecUnescaped, List<string> excludes)\n        {\n            int num = 0;", "        private static string ComputeFileEnumerationCacheKey(string projectDirectoryUnescaped, string filespecUnescaped, List<string> excludes)\n        {\n            int num = 0;\n            if (excludes != null)\n            {\n                foreach (string exclude in excludes)\n                {\n                    num += exclude.Length;\n                }\n            }\n            using ReuseableStringBuilder reuseableStringBuilder = new ReuseableStringBuilder(projectDirectoryUnescaped.Length + filespecUnescaped.Length + num);\n            bool flag = false;\n            try\n            {\n                string text = Path.Combine(projectDirectoryUnescaped, filespecUnescaped);", "                if (text.Equals(filespecUnescaped, StringComparison.Ordinal))\n                {\n                    reuseableStringBuilder.Append(filespecUnescaped);\n                }\n                else\n                {\n                    reuseableStringBuilder.Append(\"p\");\n                    reuseableStringBuilder.Append(text);\n                }\n            }\n            catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n            {\n                flag = true;\n            }", "            catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n            {\n                flag = true;\n            }\n            if (flag)\n            {\n                reuseableStringBuilder.Append(\"e\");\n                reuseableStringBuilder.Append(\"p\");\n                reuseableStringBuilder.Append(projectDirectoryUnescaped);\n                reuseableStringBuilder.Append(filespecUnescaped);\n            }", "            if (excludes != null)\n            {\n                foreach (string exclude2 in excludes)\n                {\n                    reuseableStringBuilder.Append(exclude2);\n                }\n            }\n            return reuseableStringBuilder.ToString();\n        }\n\n        internal string[] GetFiles(string projectDirectoryUnescaped, string filespecUnescaped, List<string> excludeSpecsUnescaped = null)\n        {", "            if (!HasWildcards(filespecUnescaped))\n            {\n                return CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped);\n            }\n            if (_cachedGlobExpansions == null)\n            {\n                return GetFilesImplementation(projectDirectoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);\n            }\n            string key = ComputeFileEnumerationCacheKey(projectDirectoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);\n            if (!_cachedGlobExpansions.TryGetValue(key, out var value))\n            {\n                lock (_cachedGlobExpansionsLock.Value.GetOrAdd(key, (string _) => new object()))\n                {", "            if (!_cachedGlobExpansions.TryGetValue(key, out var value))\n            {\n                lock (_cachedGlobExpansionsLock.Value.GetOrAdd(key, (string _) => new object()))\n                {\n                    if (!_cachedGlobExpansions.TryGetValue(key, out value))\n                    {\n                        value = _cachedGlobExpansions.GetOrAdd(key, (string _) => GetFilesImplementation(projectDirectoryUnescaped, filespecUnescaped, excludeSpecsUnescaped));\n                    }\n                }\n            }\n            return value.ToArray();\n        }\n\n        internal static bool RawFileSpecIsValid(string filespec)\n        {", "            if (-1 != filespec.IndexOfAny(s_invalidPathChars))\n            {\n                return false;\n            }\n            if (-1 != filespec.IndexOf(\"...\", StringComparison.Ordinal))\n            {\n                return false;\n            }\n            int num = filespec.LastIndexOf(\":\", StringComparison.Ordinal);\n            if (-1 != num && 1 != num)\n            {\n                return false;\n            }\n            return true;\n        }\n", "            if (-1 != num && 1 != num)\n            {\n                return false;\n            }\n            return true;\n        }\n\n        private static void PreprocessFileSpecForSplitting(string filespec, out string fixedDirectoryPart, out string wildcardDirectoryPart, out string filenamePart)\n        {\n            filespec = FileUtilities.FixFilePath(filespec);\n            int num = filespec.LastIndexOfAny(directorySeparatorCharacters);", "            if (-1 == num)\n            {\n                fixedDirectoryPart = string.Empty;\n                wildcardDirectoryPart = string.Empty;\n                filenamePart = filespec;\n                return;\n            }\n            int num2 = filespec.IndexOfAny(s_wildcardCharacters);\n            if (-1 == num2 || num2 > num)\n            {\n                fixedDirectoryPart = filespec.Substring(0, num + 1);\n                wildcardDirectoryPart = string.Empty;\n                filenamePart = filespec.Substring(num + 1);\n                return;\n            }\n            int num3 = filespec.Substring(0, num2).LastIndexOfAny(directorySeparatorCharacters);", "            if (-1 == num2 || num2 > num)\n            {\n                fixedDirectoryPart = filespec.Substring(0, num + 1);\n                wildcardDirectoryPart = string.Empty;\n                filenamePart = filespec.Substring(num + 1);\n                return;\n            }\n            int num3 = filespec.Substring(0, num2).LastIndexOfAny(directorySeparatorCharacters);\n            if (-1 == num3)\n            {\n                fixedDirectoryPart = string.Empty;\n                wildcardDirectoryPart = filespec.Substring(0, num + 1);\n                filenamePart = filespec.Substring(num + 1);\n            }\n            else\n            {\n                fixedDirectoryPart = filespec.Substring(0, num3 + 1);\n                wildcardDirectoryPart = filespec.Substring(num3 + 1, num - num3);\n                filenamePart = filespec.Substring(num + 1);\n            }\n        }\n\n        internal string GetLongPathName(string path)\n        {\n            return GetLongPathName(path, _getFileSystemEntries);\n        }\n\n        internal static string GetLongPathName(string path, GetFileSystemEntries getFileSystemEntries)\n        {\n            return path;\n        }\n        \n        internal void SplitFileSpec(string filespec, out string fixedDirectoryPart, out string wildcardDirectoryPart, out string filenamePart)\n        {\n            PreprocessFileSpecForSplitting(filespec, out fixedDirectoryPart, out wildcardDirectoryPart, out filenamePart);", "            if (-1 == num3)\n            {\n                fixedDirectoryPart = string.Empty;\n                wildcardDirectoryPart = filespec.Substring(0, num + 1);\n                filenamePart = filespec.Substring(num + 1);\n            }\n            else\n            {\n                fixedDirectoryPart = filespec.Substring(0, num3 + 1);\n                wildcardDirectoryPart = filespec.Substring(num3 + 1, num - num3);\n                filenamePart = filespec.Substring(num + 1);\n            }\n        }\n\n        internal string GetLongPathName(string path)\n        {\n            return GetLongPathName(path, _getFileSystemEntries);\n        }\n\n        internal static string GetLongPathName(string path, GetFileSystemEntries getFileSystemEntries)\n        {\n            return path;\n        }\n        \n        internal void SplitFileSpec(string filespec, out string fixedDirectoryPart, out string wildcardDirectoryPart, out string filenamePart)\n        {\n            PreprocessFileSpecForSplitting(filespec, out fixedDirectoryPart, out wildcardDirectoryPart, out filenamePart);", "            if (\"**\" == filenamePart)\n            {\n                wildcardDirectoryPart += \"**\";\n                wildcardDirectoryPart += s_directorySeparator;\n                filenamePart = \"*.*\";\n            }\n            fixedDirectoryPart = GetLongPathName(fixedDirectoryPart, _getFileSystemEntries);\n        }\n\n        private static bool HasDotDot(string str)\n        {", "        private static bool HasDotDot(string str)\n        {\n            for (int i = 0; i < str.Length - 1; i++)\n            {\n                if (str[i] == '.' && str[i + 1] == '.')\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n", "        private static bool HasMisplacedRecursiveOperator(string str)\n        {\n            for (int i = 0; i < str.Length - 1; i++)\n            {\n                bool num = str[i] == '*' && str[i + 1] == '*';\n                bool flag = (i == 0 || FileUtilities.IsAnySlash(str[i - 1])) && i < str.Length - 2 && FileUtilities.IsAnySlash(str[i + 2]);\n                if (num && !flag)\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n", "        private static bool IsLegalFileSpec(string wildcardDirectoryPart, string filenamePart)\n        {\n            if (!HasDotDot(wildcardDirectoryPart) && !HasMisplacedRecursiveOperator(wildcardDirectoryPart))\n            {\n                return !HasMisplacedRecursiveOperator(filenamePart);\n            }\n            return false;\n        }\n\n        internal delegate (string fixedDirectoryPart, string recursiveDirectoryPart, string fileNamePart) FixupParts(string fixedDirectoryPart, string recursiveDirectoryPart, string filenamePart);\n\n        internal void GetFileSpecInfo(string filespec, out string fixedDirectoryPart, out string wildcardDirectoryPart, out string filenamePart, out bool needsRecursion, out bool isLegalFileSpec, FixupParts fixupParts = null)\n        {\n            needsRecursion = false;\n            fixedDirectoryPart = string.Empty;\n            wildcardDirectoryPart = string.Empty;\n            filenamePart = string.Empty;", "            if (!RawFileSpecIsValid(filespec))\n            {\n                isLegalFileSpec = false;\n                return;\n            }\n            SplitFileSpec(filespec, out fixedDirectoryPart, out wildcardDirectoryPart, out filenamePart);\n            if (fixupParts != null)\n            {\n                (fixedDirectoryPart, wildcardDirectoryPart, filenamePart) = fixupParts(fixedDirectoryPart, wildcardDirectoryPart, filenamePart);\n            }\n            isLegalFileSpec = IsLegalFileSpec(wildcardDirectoryPart, filenamePart);", "            if (isLegalFileSpec)\n            {\n                needsRecursion = wildcardDirectoryPart.Length != 0;\n            }\n        }\n\n\n        private SearchAction GetFileSearchData(string projectDirectoryUnescaped, string filespecUnescaped, out bool stripProjectDirectory, out RecursionState result)\n        {\n            stripProjectDirectory = false;\n            result = default(RecursionState);\n            GetFileSpecInfo(filespecUnescaped, out var fixedDirectoryPart, out var wildcardDirectoryPart, out var filenamePart, out var needsRecursion, out var isLegalFileSpec);", "            if (!isLegalFileSpec)\n            {\n                return SearchAction.ReturnFileSpec;\n            }\n            string text = fixedDirectoryPart;\n            if (projectDirectoryUnescaped != null)\n            {\n                if (fixedDirectoryPart != null)\n                {\n                    try\n                    {\n                        fixedDirectoryPart = Path.Combine(projectDirectoryUnescaped, fixedDirectoryPart);\n                    }", "                    catch (ArgumentException)\n                    {\n                        return SearchAction.ReturnEmptyList;\n                    }\n                    stripProjectDirectory = !string.Equals(fixedDirectoryPart, text, StringComparison.OrdinalIgnoreCase);\n                }\n                else\n                {\n                    fixedDirectoryPart = projectDirectoryUnescaped;\n                    stripProjectDirectory = true;\n                }\n            }", "            if (fixedDirectoryPart.Length > 0 && !_fileSystem.DirectoryExists(fixedDirectoryPart))\n            {\n                return SearchAction.ReturnEmptyList;\n            }\n            string text2 = null;\n            if (wildcardDirectoryPart.Length > 0)\n            {\n                string text3 = wildcardDirectoryPart.TrimTrailingSlashes();\n                int length = text3.Length;\n                if (length > 6 && text3[0] == '*' && text3[1] == '*' && FileUtilities.IsAnySlash(text3[2]) && FileUtilities.IsAnySlash(text3[length - 3]) && text3[length - 2] == '*' && text3[length - 1] == '*' && text3.IndexOfAny(FileUtilities.Slashes, 3, length - 6) == -1)\n                {\n                    text2 = text3.Substring(3, length - 6);\n                }\n            }\n            bool flag = wildcardDirectoryPart.Length > 0 && text2 == null && !IsRecursiveDirectoryMatch(wildcardDirectoryPart);\n            FilesSearchData searchData = new FilesSearchData(flag ? null : filenamePart, text2, flag ? new Regex(RegularExpressionFromFileSpec(text, wildcardDirectoryPart, filenamePart), RegexOptions.IgnoreCase) : null, needsRecursion);\n            result.SearchData = searchData;\n            result.BaseDirectory = Normalize(fixedDirectoryPart);\n            result.RemainingWildcardDirectory = Normalize(wildcardDirectoryPart);\n            return SearchAction.RunSearch;\n        }\n\n        internal static string RegularExpressionFromFileSpec(string fixedDirectoryPart, string wildcardDirectoryPart, string filenamePart)\n        {\n            using ReuseableStringBuilder reuseableStringBuilder = new ReuseableStringBuilder(291);\n            AppendRegularExpressionFromFixedDirectory(reuseableStringBuilder, fixedDirectoryPart);\n            AppendRegularExpressionFromWildcardDirectory(reuseableStringBuilder, wildcardDirectoryPart);\n            AppendRegularExpressionFromFilename(reuseableStringBuilder, filenamePart);\n            return reuseableStringBuilder.ToString();\n        }", "                if (length > 6 && text3[0] == '*' && text3[1] == '*' && FileUtilities.IsAnySlash(text3[2]) && FileUtilities.IsAnySlash(text3[length - 3]) && text3[length - 2] == '*' && text3[length - 1] == '*' && text3.IndexOfAny(FileUtilities.Slashes, 3, length - 6) == -1)\n                {\n                    text2 = text3.Substring(3, length - 6);\n                }\n            }\n            bool flag = wildcardDirectoryPart.Length > 0 && text2 == null && !IsRecursiveDirectoryMatch(wildcardDirectoryPart);\n            FilesSearchData searchData = new FilesSearchData(flag ? null : filenamePart, text2, flag ? new Regex(RegularExpressionFromFileSpec(text, wildcardDirectoryPart, filenamePart), RegexOptions.IgnoreCase) : null, needsRecursion);\n            result.SearchData = searchData;\n            result.BaseDirectory = Normalize(fixedDirectoryPart);\n            result.RemainingWildcardDirectory = Normalize(wildcardDirectoryPart);\n            return SearchAction.RunSearch;\n        }\n\n        internal static string RegularExpressionFromFileSpec(string fixedDirectoryPart, string wildcardDirectoryPart, string filenamePart)\n        {\n            using ReuseableStringBuilder reuseableStringBuilder = new ReuseableStringBuilder(291);\n            AppendRegularExpressionFromFixedDirectory(reuseableStringBuilder, fixedDirectoryPart);\n            AppendRegularExpressionFromWildcardDirectory(reuseableStringBuilder, wildcardDirectoryPart);\n            AppendRegularExpressionFromFilename(reuseableStringBuilder, filenamePart);\n            return reuseableStringBuilder.ToString();\n        }", "        private static int LastIndexOfDirectorySequence(string str, int startIndex)\n        {\n            if (startIndex >= str.Length || !FileUtilities.IsAnySlash(str[startIndex]))\n            {\n                return startIndex;\n            }\n            int num = startIndex;\n            bool flag = false;\n            while (!flag && num < str.Length)\n            {\n                bool num2 = num < str.Length - 1 && FileUtilities.IsAnySlash(str[num + 1]);\n                bool flag2 = num < str.Length - 2 && str[num + 1] == '.' && FileUtilities.IsAnySlash(str[num + 2]);", "            while (!flag && num < str.Length)\n            {\n                bool num2 = num < str.Length - 1 && FileUtilities.IsAnySlash(str[num + 1]);\n                bool flag2 = num < str.Length - 2 && str[num + 1] == '.' && FileUtilities.IsAnySlash(str[num + 2]);\n                if (num2)\n                {\n                    num++;\n                }\n                else if (flag2)\n                {\n                    num += 2;\n                }\n                else\n                {\n                    flag = true;\n                }\n            }\n            return num;\n        }\n", "                else if (flag2)\n                {\n                    num += 2;\n                }\n                else\n                {\n                    flag = true;\n                }\n            }\n            return num;\n        }\n", "        private static int LastIndexOfDirectoryOrRecursiveSequence(string str, int startIndex)\n        {\n            if (startIndex >= str.Length - 1 || str[startIndex] != '*' || str[startIndex + 1] != '*')\n            {\n                return LastIndexOfDirectorySequence(str, startIndex);\n            }\n            int num = startIndex + 2;\n            bool flag = false;\n            while (!flag && num < str.Length)\n            {\n                num = LastIndexOfDirectorySequence(str, num);", "            while (!flag && num < str.Length)\n            {\n                num = LastIndexOfDirectorySequence(str, num);\n                if (num < str.Length - 2 && str[num + 1] == '*' && str[num + 2] == '*')\n                {\n                    num += 3;\n                }\n                else\n                {\n                    flag = true;\n                }\n            }\n            return num + 1;\n        }\n", "        private static void AppendRegularExpressionFromFixedDirectory(ReuseableStringBuilder regex, string fixedDir)\n        {\n            regex.Append(\"^\");\n            int num;\n            //if (NativeMethodsShared.IsWindows && fixedDir.Length > 1 && fixedDir[0] == '\\\\')\n            //{\n            //    num = ((fixedDir[1] == '\\\\') ? 1 : 0);\n            //    if (num != 0)\n            //    {\n            //        regex.Append(\"\\\\\\\\\\\\\\\\\");\n            //    }\n            //}\n            //else\n            {\n                num = 0;\n            }", "            for (int num2 = ((num != 0) ? (LastIndexOfDirectorySequence(fixedDir, 0) + 1) : LastIndexOfDirectorySequence(fixedDir, 0)); num2 < fixedDir.Length; num2 = LastIndexOfDirectorySequence(fixedDir, num2 + 1))\n            {\n                AppendRegularExpressionFromChar(regex, fixedDir[num2]);\n            }\n        }\n\n        private static void AppendRegularExpressionFromWildcardDirectory(ReuseableStringBuilder regex, string wildcardDir)\n        {\n            regex.Append(\"(?<WILDCARDDIR>\");\n            if (wildcardDir.Length > 2 && wildcardDir[0] == '*' && wildcardDir[1] == '*')\n            {\n                regex.Append(\"((.*/)|(.*\\\\\\\\)|())\");\n            }", "            if (wildcardDir.Length > 2 && wildcardDir[0] == '*' && wildcardDir[1] == '*')\n            {\n                regex.Append(\"((.*/)|(.*\\\\\\\\)|())\");\n            }\n            for (int num = LastIndexOfDirectoryOrRecursiveSequence(wildcardDir, 0); num < wildcardDir.Length; num = LastIndexOfDirectoryOrRecursiveSequence(wildcardDir, num + 1))\n            {\n                char ch = wildcardDir[num];\n                if (num < wildcardDir.Length - 2 && wildcardDir[num + 1] == '*' && wildcardDir[num + 2] == '*')\n                {\n                    regex.Append(\"((/)|(\\\\\\\\)|(/.*/)|(/.*\\\\\\\\)|(\\\\\\\\.*\\\\\\\\)|(\\\\\\\\.*/))\");\n                }\n                else\n                {\n                    AppendRegularExpressionFromChar(regex, ch);\n                }\n            }\n            regex.Append(\")\");\n        }\n", "        private static void AppendRegularExpressionFromFilename(ReuseableStringBuilder regex, string filename)\n        {\n            regex.Append(\"(?<FILENAME>\");\n            bool flag = filename.Length > 0 && filename[filename.Length - 1] == '.';\n            int num = (flag ? (filename.Length - 1) : filename.Length);\n            for (int i = 0; i < num; i++)\n            {\n                char c = filename[i];\n                if (flag && c == '*')\n                {\n                    regex.Append(\"[^\\\\.]*\");\n                }", "                if (flag && c == '*')\n                {\n                    regex.Append(\"[^\\\\.]*\");\n                }\n                else if (flag && c == '?')\n                {\n                    regex.Append(\"[^\\\\.].\");\n                }\n                else\n                {\n                    AppendRegularExpressionFromChar(regex, c);\n                }", "                if (!flag && i < num - 2 && c == '*' && filename[i + 1] == '.' && filename[i + 2] == '*')\n                {\n                    i += 2;\n                }\n            }\n            regex.Append(\")\");\n            regex.Append(\"$\");\n        }\n\n        private static void AppendRegularExpressionFromChar(ReuseableStringBuilder regex, char ch)\n        {\n            switch (ch)\n            {\n                case '*':\n                    regex.Append(\"[^/\\\\\\\\]*\");\n                    return;\n                case '?':\n                    regex.Append(\".\");\n                    return;\n            }", "        private static void AppendRegularExpressionFromChar(ReuseableStringBuilder regex, char ch)\n        {\n            switch (ch)\n            {\n                case '*':\n                    regex.Append(\"[^/\\\\\\\\]*\");\n                    return;\n                case '?':\n                    regex.Append(\".\");\n                    return;\n            }", "            if (FileUtilities.IsAnySlash(ch))\n            {\n                regex.Append(\"[/\\\\\\\\]+\");\n            }\n            else if (IsSpecialRegexCharacter(ch))\n            {\n                regex.Append('\\\\');\n                regex.Append(ch);\n            }\n            else\n            {\n                regex.Append(ch);\n            }\n        }\n", "        private static bool IsSpecialRegexCharacter(char ch)\n        {\n            if (ch != '$' && ch != '(' && ch != ')' && ch != '+' && ch != '.' && ch != '[' && ch != '^' && ch != '{')\n            {\n                return ch == '|';\n            }\n            return true;\n        }\n\n        private static bool IsValidDriveChar(char value)\n        {", "        private static bool IsValidDriveChar(char value)\n        {\n            if (value < 'A' || value > 'Z')\n            {\n                if (value >= 'a')\n                {\n                    return value <= 'z';\n                }\n                return false;\n            }\n            return true;\n        }\n", "        private static int SkipSlashes(string aString, int startingIndex)\n        {\n            int i;\n            for (i = startingIndex; i < aString.Length && FileUtilities.IsAnySlash(aString[i]); i++)\n            {\n            }\n            return i;\n        }\n        internal static bool IsRecursiveDirectoryMatch(string path)\n        {\n            return path.TrimTrailingSlashes() == \"**\";\n        }\n\n        internal static string Normalize(string aString)\n        {", "            if (string.IsNullOrEmpty(aString))\n            {\n                return aString;\n            }\n            StringBuilder stringBuilder = new StringBuilder(aString.Length);\n            int num = 0;\n            if (aString.Length >= 2 && aString[1] == ':' && IsValidDriveChar(aString[0]))\n            {\n                stringBuilder.Append(aString[0]);\n                stringBuilder.Append(aString[1]);\n                int num2 = SkipSlashes(aString, 2);", "                if (num != num2)\n                {\n                    stringBuilder.Append('\\\\');\n                }\n                num = num2;\n            }\n            else if (aString.StartsWith(\"/\", StringComparison.Ordinal))\n            {\n                stringBuilder.Append('/');\n                num = SkipSlashes(aString, 1);\n            }", "            else if (aString.StartsWith(\"\\\\\\\\\", StringComparison.Ordinal))\n            {\n                stringBuilder.Append(\"\\\\\\\\\");\n                num = SkipSlashes(aString, 2);\n            }\n            else if (aString.StartsWith(\"\\\\\", StringComparison.Ordinal))\n            {\n                stringBuilder.Append(\"\\\\\");\n                num = SkipSlashes(aString, 1);\n            }\n            while (num < aString.Length)\n            {\n                int num3 = SkipSlashes(aString, num);", "            while (num < aString.Length)\n            {\n                int num3 = SkipSlashes(aString, num);\n                if (num3 >= aString.Length)\n                {\n                    break;\n                }\n                if (num3 > num)\n                {\n                    stringBuilder.Append(s_directorySeparator);\n                }\n                int num4 = aString.IndexOfAny(directorySeparatorCharacters, num3);\n                int num5 = ((num4 == -1) ? aString.Length : num4);\n                stringBuilder.Append(aString, num3, num5 - num3);\n                num = num5;\n            }\n            return stringBuilder.ToString();\n        }\n        private string[] GetFilesImplementation(string projectDirectoryUnescaped, string filespecUnescaped, List<string> excludeSpecsUnescaped)\n        {\n            bool stripProjectDirectory;\n            RecursionState result;\n            SearchAction fileSearchData = GetFileSearchData(projectDirectoryUnescaped, filespecUnescaped, out stripProjectDirectory, out result);\n            switch (fileSearchData)\n            {\n                case SearchAction.ReturnEmptyList:\n                    return Array.Empty<string>();\n                case SearchAction.ReturnFileSpec:\n                    return CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped);\n                default:\n                    throw new NotSupportedException(fileSearchData.ToString());\n                case SearchAction.RunSearch:\n                    {\n                        List<RecursionState> list2 = null;\n                        Dictionary<string, List<RecursionState>> dictionary = null;\n                        HashSet<string> resultsToExclude = null;", "                        if (excludeSpecsUnescaped != null)\n                        {\n                            list2 = new List<RecursionState>();\n                            foreach (string item in excludeSpecsUnescaped)\n                            {\n                                bool stripProjectDirectory2;\n                                RecursionState result2;\n                                SearchAction fileSearchData2 = GetFileSearchData(projectDirectoryUnescaped, item, out stripProjectDirectory2, out result2);\n                                switch (fileSearchData2)\n                                {\n                                    case SearchAction.ReturnFileSpec:", "                                        if (resultsToExclude == null)\n                                        {\n                                            resultsToExclude = new HashSet<string>();\n                                        }\n                                        resultsToExclude.Add(item);\n                                        break;\n                                    default:\n                                        throw new NotSupportedException(fileSearchData2.ToString());\n                                    case SearchAction.RunSearch:\n                                        {\n                                            string baseDirectory = result2.BaseDirectory;\n                                            string baseDirectory2 = result.BaseDirectory;", "                                            if (!string.Equals(baseDirectory, baseDirectory2, StringComparison.OrdinalIgnoreCase))\n                                            {\n                                                if (baseDirectory.Length == baseDirectory2.Length)\n                                                {\n                                                    break;\n                                                }\n                                                if (baseDirectory.Length > baseDirectory2.Length)\n                                                {\n                                                    if (IsSubdirectoryOf(baseDirectory, baseDirectory2))\n                                                    {\n                                                        if (dictionary == null)\n                                                        {\n                                                            dictionary = new Dictionary<string, List<RecursionState>>(StringComparer.OrdinalIgnoreCase);\n                                                        }", "                                                    if (IsSubdirectoryOf(baseDirectory, baseDirectory2))\n                                                    {\n                                                        if (dictionary == null)\n                                                        {\n                                                            dictionary = new Dictionary<string, List<RecursionState>>(StringComparer.OrdinalIgnoreCase);\n                                                        }\n                                                        if (!dictionary.TryGetValue(baseDirectory, out var value))\n                                                        {\n                                                            value = (dictionary[baseDirectory] = new List<RecursionState>());\n                                                        }\n                                                        value.Add(result2);\n                                                    }\n                                                }", "                                                else if (IsSubdirectoryOf(result.BaseDirectory, result2.BaseDirectory) && result2.RemainingWildcardDirectory.Length != 0)\n                                                {\n                                                    if (IsRecursiveDirectoryMatch(result2.RemainingWildcardDirectory))\n                                                    {\n                                                        result2.BaseDirectory = result.BaseDirectory;\n                                                        list2.Add(result2);\n                                                    }\n                                                    else\n                                                    {\n                                                        result2.BaseDirectory = result.BaseDirectory;\n                                                        result2.RemainingWildcardDirectory = \"**\" + s_directorySeparator;\n                                                        list2.Add(result2);\n                                                    }\n                                                }\n                                            }\n                                            else\n                                            {\n                                                string text = result.SearchData.Filespec ?? string.Empty;\n                                                string text2 = result2.SearchData.Filespec ?? string.Empty;\n                                                int num = Math.Min(text.Length - text.LastIndexOfAny(s_wildcardCharacters) - 1, text2.Length - text2.LastIndexOfAny(s_wildcardCharacters) - 1);", "                                                if (string.Compare(text, text.Length - num, text2, text2.Length - num, num, StringComparison.OrdinalIgnoreCase) == 0)\n                                                {\n                                                    list2.Add(result2);\n                                                }\n                                            }\n                                            break;\n                                        }\n                                    case SearchAction.ReturnEmptyList:\n                                        break;\n                                }\n                            }\n                        }", "                        if (list2 != null && list2.Count == 0)\n                        {\n                            list2 = null;\n                        }\n                        ConcurrentStack<List<string>> concurrentStack = new ConcurrentStack<List<string>>();\n                        try\n                        {\n                            int num2 = Math.Max(1, /*NativeMethodsShared.GetLogicalCoreCount()*/Environment.ProcessorCount / 2);\n                            TaskOptions taskOptions = new TaskOptions(num2)\n                            {\n                                AvailableTasks = num2,\n                                MaxTasksPerIteration = num2\n                            };\n                            GetFilesRecursive(concurrentStack, result, projectDirectoryUnescaped, stripProjectDirectory, list2, dictionary, taskOptions);\n                        }", "                        catch (AggregateException ex)\n                        {\n                            if (ex.Flatten().InnerExceptions.All(ExceptionHandling.IsIoRelatedException))\n                            {\n                                return CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped);\n                            }\n                            throw;\n                        }\n                        catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n                        {\n                            return CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped);\n                        }", "                        catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))\n                        {\n                            return CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped);\n                        }\n                        if (resultsToExclude == null)\n                        {\n                            return concurrentStack.SelectMany((List<string> list) => list).ToArray();\n                        }\n                        return (from f in concurrentStack.SelectMany((List<string> list) => list)\n                                where !resultsToExclude.Contains(f)\n                                select f).ToArray();\n                    }\n            }\n        }\n\n        private IEnumerable<string> GetFilesForStep(RecursiveStepResult stepResult, RecursionState recursionState, string projectDirectory, bool stripProjectDirectory)\n        {", "            if (!stepResult.ConsiderFiles)\n            {\n                return Enumerable.Empty<string>();\n            }\n            string pattern;\n            if (/*NativeMethodsShared.IsLinux*/true && recursionState.SearchData.DirectoryPattern != null)\n            {\n                pattern = \"*.*\";\n                stepResult.NeedsToProcessEachFile = true;\n            }\n            else\n            {\n                pattern = recursionState.SearchData.Filespec;\n            }\n            IEnumerable<string> enumerable = _getFileSystemEntries(FileSystemEntity.Files, recursionState.BaseDirectory, pattern, projectDirectory, stripProjectDirectory);", "            if (!stepResult.NeedsToProcessEachFile)\n            {\n                return enumerable;\n            }\n            return enumerable.Where((string o) => MatchFileRecursionStep(recursionState, o));\n        }\n\n        private static bool IsAllFilesWildcard(string pattern)\n        {\n            return pattern?.Length switch\n            {\n                1 => pattern[0] == '*',\n                3 => pattern[0] == '*' && pattern[1] == '.' && pattern[2] == '*',\n                _ => false,\n            };\n        }\n", "        private static bool MatchFileRecursionStep(RecursionState recursionState, string file)\n        {\n            if (IsAllFilesWildcard(recursionState.SearchData.Filespec))\n            {\n                return true;\n            }\n            if (recursionState.SearchData.Filespec != null)\n            {\n                return IsMatch(Path.GetFileName(file), recursionState.SearchData.Filespec);\n            }\n            return recursionState.SearchData.RegexFileMatch.IsMatch(file);\n        }\n", "        private static RecursiveStepResult GetFilesRecursiveStep(RecursionState recursionState)\n        {\n            RecursiveStepResult result = default(RecursiveStepResult);\n            bool flag = false;\n            if (recursionState.SearchData.DirectoryPattern != null)\n            {\n                flag = recursionState.IsInsideMatchingDirectory;\n            }\n            else if (recursionState.RemainingWildcardDirectory.Length == 0)\n            {\n                flag = true;\n            }", "            else if (recursionState.RemainingWildcardDirectory.Length == 0)\n            {\n                flag = true;\n            }\n            else if (recursionState.RemainingWildcardDirectory.IndexOf(\"**\", StringComparison.Ordinal) == 0)\n            {\n                flag = true;\n            }\n            result.ConsiderFiles = flag;\n            if (flag)\n            {\n                result.NeedsToProcessEachFile = recursionState.SearchData.Filespec == null;\n            }", "            if (flag)\n            {\n                result.NeedsToProcessEachFile = recursionState.SearchData.Filespec == null;\n            }\n            if (recursionState.SearchData.NeedsRecursion && recursionState.RemainingWildcardDirectory.Length > 0)\n            {\n                string text = null;\n                if (!IsRecursiveDirectoryMatch(recursionState.RemainingWildcardDirectory))\n                {\n                    int num = recursionState.RemainingWildcardDirectory.IndexOfAny(directorySeparatorCharacters);\n                    text = ((num != -1) ? recursionState.RemainingWildcardDirectory.Substring(0, num) : recursionState.RemainingWildcardDirectory);", "                    if (text == \"**\")\n                    {\n                        text = null;\n                        recursionState.RemainingWildcardDirectory = \"**\";\n                    }\n                    else\n                    {\n                        recursionState.RemainingWildcardDirectory = ((num != -1) ? recursionState.RemainingWildcardDirectory.Substring(num + 1) : string.Empty);\n                    }\n                }\n                result.NeedsDirectoryRecursion = true;\n                result.RemainingWildcardDirectory = recursionState.RemainingWildcardDirectory;\n                result.DirectoryPattern = text;\n            }\n            return result;\n        }\n", "        private void GetFilesRecursive(ConcurrentStack<List<string>> listOfFiles, RecursionState recursionState, string projectDirectory, bool stripProjectDirectory, IList<RecursionState> searchesToExclude, Dictionary<string, List<RecursionState>> searchesToExcludeInSubdirs, TaskOptions taskOptions)\n        {\n            ErrorUtilities.VerifyThrow(recursionState.SearchData.Filespec == null || recursionState.SearchData.RegexFileMatch == null, \"File-spec overrides the regular expression -- pass null for file-spec if you want to use the regular expression.\");\n            ErrorUtilities.VerifyThrow(recursionState.SearchData.Filespec != null || recursionState.SearchData.RegexFileMatch != null, \"Need either a file-spec or a regular expression to match files.\");\n            ErrorUtilities.VerifyThrow(recursionState.RemainingWildcardDirectory != null, \"Expected non-null remaning wildcard directory.\");\n            RecursiveStepResult[] excludeNextSteps = null;\n            if (searchesToExclude != null)\n            {\n                excludeNextSteps = new RecursiveStepResult[searchesToExclude.Count];\n                for (int i = 0; i < searchesToExclude.Count; i++)\n                {\n                    RecursionState recursionState2 = searchesToExclude[i];\n                    excludeNextSteps[i] = GetFilesRecursiveStep(searchesToExclude[i]);", "                for (int i = 0; i < searchesToExclude.Count; i++)\n                {\n                    RecursionState recursionState2 = searchesToExclude[i];\n                    excludeNextSteps[i] = GetFilesRecursiveStep(searchesToExclude[i]);\n                    if (!recursionState2.IsLookingForMatchingDirectory && recursionState2.SearchData.Filespec != null && recursionState2.RemainingWildcardDirectory == recursionState.RemainingWildcardDirectory && (IsAllFilesWildcard(recursionState2.SearchData.Filespec) || recursionState2.SearchData.Filespec == recursionState.SearchData.Filespec))\n                    {\n                        return;\n                    }\n                }\n            }\n            RecursiveStepResult nextStep = GetFilesRecursiveStep(recursionState);\n            List<string> list = null;", "            foreach (string item2 in GetFilesForStep(nextStep, recursionState, projectDirectory, stripProjectDirectory))\n            {\n                if (excludeNextSteps != null)\n                {\n                    bool flag = false;\n                    for (int j = 0; j < excludeNextSteps.Length; j++)\n                    {\n                        if (excludeNextSteps[j].ConsiderFiles && MatchFileRecursionStep(searchesToExclude[j], item2))\n                        {\n                            flag = true;\n                            break;\n                        }\n                    }", "                    if (flag)\n                    {\n                        continue;\n                    }\n                }\n                if (list == null)\n                {\n                    list = new List<string>();\n                }\n                list.Add(item2);\n            }", "            if (list != null && list.Count > 0)\n            {\n                listOfFiles.Push(list);\n            }\n            if (!nextStep.NeedsDirectoryRecursion)\n            {\n                return;\n            }\n            Action<string> action = delegate (string subdir)\n            {\n                RecursionState recursionState3 = recursionState;\n                recursionState3.BaseDirectory = subdir;\n                recursionState3.RemainingWildcardDirectory = nextStep.RemainingWildcardDirectory;", "                if (recursionState3.IsLookingForMatchingDirectory && DirectoryEndsWithPattern(subdir, recursionState.SearchData.DirectoryPattern))\n                {\n                    recursionState3.IsInsideMatchingDirectory = true;\n                }\n                List<RecursionState> list2 = null;\n                if (excludeNextSteps != null)\n                {\n                    list2 = new List<RecursionState>();\n                    for (int k = 0; k < excludeNextSteps.Length; k++)\n                    {\n                        if (excludeNextSteps[k].NeedsDirectoryRecursion && (excludeNextSteps[k].DirectoryPattern == null || IsMatch(Path.GetFileName(subdir), excludeNextSteps[k].DirectoryPattern)))\n                        {\n                            RecursionState item = searchesToExclude[k];\n                            item.BaseDirectory = subdir;\n                            item.RemainingWildcardDirectory = excludeNextSteps[k].RemainingWildcardDirectory;", "                    for (int k = 0; k < excludeNextSteps.Length; k++)\n                    {\n                        if (excludeNextSteps[k].NeedsDirectoryRecursion && (excludeNextSteps[k].DirectoryPattern == null || IsMatch(Path.GetFileName(subdir), excludeNextSteps[k].DirectoryPattern)))\n                        {\n                            RecursionState item = searchesToExclude[k];\n                            item.BaseDirectory = subdir;\n                            item.RemainingWildcardDirectory = excludeNextSteps[k].RemainingWildcardDirectory;\n                            if (item.IsLookingForMatchingDirectory && DirectoryEndsWithPattern(subdir, item.SearchData.DirectoryPattern))\n                            {\n                                item.IsInsideMatchingDirectory = true;\n                            }\n                            list2.Add(item);\n                        }\n                    }\n                }", "                if (searchesToExcludeInSubdirs != null && searchesToExcludeInSubdirs.TryGetValue(subdir, out var value))\n                {\n                    if (list2 == null)\n                    {\n                        list2 = new List<RecursionState>();\n                    }\n                    list2.AddRange(value);\n                }\n                GetFilesRecursive(listOfFiles, recursionState3, projectDirectory, stripProjectDirectory, list2, searchesToExcludeInSubdirs, taskOptions);\n            };\n            int num = 0;", "            if (taskOptions.MaxTasks > 1 && taskOptions.MaxTasksPerIteration > 1)\n            {\n                if (taskOptions.MaxTasks == taskOptions.MaxTasksPerIteration)\n                {\n                    num = taskOptions.AvailableTasks;\n                    taskOptions.AvailableTasks = 0;\n                }\n                else\n                {\n                    lock (taskOptions)\n                    {\n                        num = Math.Min(taskOptions.MaxTasksPerIteration, taskOptions.AvailableTasks);\n                        taskOptions.AvailableTasks -= num;\n                    }\n                }\n            }", "            if (num < 2)\n            {\n                foreach (string item3 in _getFileSystemEntries(FileSystemEntity.Directories, recursionState.BaseDirectory, nextStep.DirectoryPattern, null, stripProjectDirectory: false))\n                {\n                    action(item3);\n                }\n            }\n            else\n            {\n                Parallel.ForEach(_getFileSystemEntries(FileSystemEntity.Directories, recursionState.BaseDirectory, nextStep.DirectoryPattern, null, stripProjectDirectory: false), new ParallelOptions\n                {\n                    MaxDegreeOfParallelism = num\n                }, action);\n            }", "            if (num <= 0)\n            {\n                return;\n            }\n            if (taskOptions.MaxTasks == taskOptions.MaxTasksPerIteration)\n            {\n                taskOptions.AvailableTasks = taskOptions.MaxTasks;\n                return;\n            }\n            lock (taskOptions)\n            {\n                taskOptions.AvailableTasks += num;\n            }\n        }\n", "        private static bool IsSubdirectoryOf(string possibleChild, string possibleParent)\n        {\n            if (possibleParent == string.Empty)\n            {\n                return true;\n            }\n            if (!possibleChild.StartsWith(possibleParent, StringComparison.OrdinalIgnoreCase))\n            {\n                return false;\n            }\n            if (directorySeparatorCharacters.Contains(possibleParent[possibleParent.Length - 1]))\n            {\n                return true;\n            }\n            return directorySeparatorCharacters.Contains(possibleChild[possibleParent.Length]);\n        }\n", "            if (directorySeparatorCharacters.Contains(possibleParent[possibleParent.Length - 1]))\n            {\n                return true;\n            }\n            return directorySeparatorCharacters.Contains(possibleChild[possibleParent.Length]);\n        }\n\n        private static bool DirectoryEndsWithPattern(string directoryPath, string pattern)\n        {\n            int num = directoryPath.LastIndexOfAny(FileUtilities.Slashes);\n            if (num != -1)\n            {\n                return IsMatch(directoryPath.Substring(num + 1), pattern);\n            }\n            return false;\n        }\n\n        internal void GetFileSpecInfoWithRegexObject(string filespec, out Regex regexFileMatch, out bool needsRecursion, out bool isLegalFileSpec)\n        {\n            GetFileSpecInfo(filespec, out var fixedDirectoryPart, out var wildcardDirectoryPart, out var filenamePart, out needsRecursion, out isLegalFileSpec);", "            if (num != -1)\n            {\n                return IsMatch(directoryPath.Substring(num + 1), pattern);\n            }\n            return false;\n        }\n\n        internal void GetFileSpecInfoWithRegexObject(string filespec, out Regex regexFileMatch, out bool needsRecursion, out bool isLegalFileSpec)\n        {\n            GetFileSpecInfo(filespec, out var fixedDirectoryPart, out var wildcardDirectoryPart, out var filenamePart, out needsRecursion, out isLegalFileSpec);\n            if (isLegalFileSpec)\n            {\n                string pattern = RegularExpressionFromFileSpec(fixedDirectoryPart, wildcardDirectoryPart, filenamePart);\n                regexFileMatch = new Regex(pattern, RegexOptions.IgnoreCase);\n            }\n            else\n            {\n                regexFileMatch = null;\n            }\n        }\n\n        internal static void GetRegexMatchInfo(string fileToMatch, Regex fileSpecRegex, out bool isMatch, out string wildcardDirectoryPart, out string filenamePart)\n        {\n            Match match = fileSpecRegex.Match(fileToMatch);\n            isMatch = match.Success;\n            wildcardDirectoryPart = string.Empty;\n            filenamePart = string.Empty;", "            if (isLegalFileSpec)\n            {\n                string pattern = RegularExpressionFromFileSpec(fixedDirectoryPart, wildcardDirectoryPart, filenamePart);\n                regexFileMatch = new Regex(pattern, RegexOptions.IgnoreCase);\n            }\n            else\n            {\n                regexFileMatch = null;\n            }\n        }\n\n        internal static void GetRegexMatchInfo(string fileToMatch, Regex fileSpecRegex, out bool isMatch, out string wildcardDirectoryPart, out string filenamePart)\n        {\n            Match match = fileSpecRegex.Match(fileToMatch);\n            isMatch = match.Success;\n            wildcardDirectoryPart = string.Empty;\n            filenamePart = string.Empty;", "            if (isMatch)\n            {\n                wildcardDirectoryPart = match.Groups[\"WILDCARDDIR\"].Value;\n                filenamePart = match.Groups[\"FILENAME\"].Value;\n            }\n        }\n\n        internal Result FileMatch(string filespec, string fileToMatch)\n        {\n            Result result = new Result();\n            fileToMatch = GetLongPathName(fileToMatch, _getFileSystemEntries);\n            GetFileSpecInfoWithRegexObject(filespec, out var regexFileMatch, out result.isFileSpecRecursive, out result.isLegalFileSpec);", "            if (result.isLegalFileSpec)\n            {\n                GetRegexMatchInfo(fileToMatch, regexFileMatch, out result.isMatch, out result.wildcardDirectoryPart, out var _);\n            }\n            return result;\n        }\n\n        private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped, List<string> excludeSpecsUnescaped)\n        {\n            if (excludeSpecsUnescaped != null)\n            {", "            if (excludeSpecsUnescaped != null)\n            {\n                foreach (string item in excludeSpecsUnescaped)\n                {\n                    if (FileUtilities.PathsEqual(filespecUnescaped, item))\n                    {\n                        return Array.Empty<string>();\n                    }\n                    Result result = Default.FileMatch(item, filespecUnescaped);\n                    if (result.isLegalFileSpec && result.isMatch)\n                    {\n                        return Array.Empty<string>();\n                    }\n                }\n            }\n            return new string[1] { filespecUnescaped };\n        }\n\n    }\n}", "                    if (result.isLegalFileSpec && result.isMatch)\n                    {\n                        return Array.Empty<string>();\n                    }\n                }\n            }\n            return new string[1] { filespecUnescaped };\n        }\n\n    }\n}"]}
{"filename": "Microsoft.Build.Shared/FileUtilities.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Runtime.CompilerServices;\nusing System.Text;", "using System.Runtime.CompilerServices;\nusing System.Text;\nusing System.Threading;\nusing Microsoft.Build.Shared;\nusing Microsoft.Build.Shared.FileSystem;\nusing Microsoft.Build.Utilities;\n\nnamespace Microsoft.Build.Shared\n{\n\n    internal static class FileUtilities\n    {", "{\n\n    internal static class FileUtilities\n    {\n        private static readonly IFileSystem DefaultFileSystem = FileSystems.Default;\n\n        internal static readonly char[] Slashes = new char[2] { '/', '\\\\' };\n\n        // Linux\u5927\u5c0f\u5199\u654f\u611f\n        private static readonly ConcurrentDictionary<string, bool> FileExistenceCache = new ConcurrentDictionary<string, bool>(StringComparer.Ordinal);\n\n        internal static bool IsSlash(char c)\n        {", "        private static readonly ConcurrentDictionary<string, bool> FileExistenceCache = new ConcurrentDictionary<string, bool>(StringComparer.Ordinal);\n\n        internal static bool IsSlash(char c)\n        {\n            if (c != Path.DirectorySeparatorChar)\n            {\n                return c == Path.AltDirectorySeparatorChar;\n            }\n            return true;\n        }\n\n        internal static string TrimTrailingSlashes(this string s)\n        {\n            return s.TrimEnd(Slashes);\n        }\n\n        internal static string FixFilePath(string path)\n        {", "            if (!string.IsNullOrEmpty(path) && Path.DirectorySeparatorChar != '\\\\')\n            {\n                return path.Replace('\\\\', '/');\n            }\n            return path;\n        }\n\n        /// <summary>\n        /// If the given path doesn't have a trailing slash then add one.\n        /// If the path is an empty string, does not modify it.\n        /// </summary>\n        /// <param name=\"fileSpec\">The path to check.</param>\n        /// <returns>A path with a slash.</returns>\n        internal static string EnsureTrailingSlash(string fileSpec)\n        {\n            fileSpec = FixFilePath(fileSpec);", "            if (fileSpec.Length > 0 && !IsSlash(fileSpec[fileSpec.Length - 1]))\n            {\n                fileSpec += Path.DirectorySeparatorChar;\n            }\n\n            return fileSpec;\n        }\n\n        internal static string NormalizePath(string path)\n        {\n            ErrorUtilities.VerifyThrowArgumentLength(path, \"path\");\n            return FixFilePath(GetFullPath(path));\n        }\n", "        private static string GetFullPath(string path)\n        {\n#if __\n            if (NativeMethods.IsWindows)\n            {\n                string fullPath = NativeMethods.GetFullPath(path);\n                if (IsPathTooLong(fullPath))\n                {\n                    throw new PathTooLongException(ResourceUtilities.FormatString(AssemblyResources.GetString(\"Shared.PathTooLong\"), path, NativeMethods.MaxPath));\n                }\n                Path.HasExtension(fullPath);", "                if (!IsUNCPath(fullPath))\n                {\n                    return fullPath;\n                }\n                return Path.GetFullPath(fullPath);\n            }\n#endif\n            return Path.GetFullPath(path);\n        }\n\n        internal static string EnsureNoTrailingSlash(string path)\n        {\n            path = FixFilePath(path);", "            if (EndsWithSlash(path))\n            {\n                path = path.Substring(0, path.Length - 1);\n            }\n            return path;\n        }\n\n        internal static bool EndsWithSlash(string fileSpec)\n        {\n            if (fileSpec.Length <= 0)\n            {\n                return false;\n            }\n            return IsSlash(fileSpec[fileSpec.Length - 1]);\n        }\n\n        internal static string GetDirectoryNameOfFullPath(string fullPath)\n        {", "            if (fileSpec.Length <= 0)\n            {\n                return false;\n            }\n            return IsSlash(fileSpec[fileSpec.Length - 1]);\n        }\n\n        internal static string GetDirectoryNameOfFullPath(string fullPath)\n        {\n            if (fullPath != null)\n            {\n                int num = fullPath.Length;", "            if (fullPath != null)\n            {\n                int num = fullPath.Length;\n                while (num > 0 && fullPath[--num] != Path.DirectorySeparatorChar && fullPath[num] != Path.AltDirectorySeparatorChar)\n                {\n                }\n                return FixFilePath(fullPath.Substring(0, num));\n            }\n            return null;\n        }\n\n        internal static string AttemptToShortenPath(string path)\n        {\n#if __", "            if (IsPathTooLong(path) || IsPathTooLongIfRooted(path))\n            {\n                path = GetFullPathNoThrow(path);\n            }\n#endif\n            return FixFilePath(path);\n        }\n\n        internal static bool PathsEqual(string path1, string path2)\n        {\n            if (path1 == null && path2 == null)\n            {\n                return true;\n            }", "            if (path1 == null && path2 == null)\n            {\n                return true;\n            }\n            if (path1 == null || path2 == null)\n            {\n                return false;\n            }\n            int num = path1.Length - 1;\n            int num2 = path2.Length - 1;\n            for (int num3 = num; num3 >= 0; num3--)\n            {\n                char c = path1[num3];", "            for (int num3 = num; num3 >= 0; num3--)\n            {\n                char c = path1[num3];\n                if (c != '/' && c != '\\\\')\n                {\n                    break;\n                }\n                num--;\n            }\n            for (int num4 = num2; num4 >= 0; num4--)\n            {\n                char c2 = path2[num4];", "            for (int num4 = num2; num4 >= 0; num4--)\n            {\n                char c2 = path2[num4];\n                if (c2 != '/' && c2 != '\\\\')\n                {\n                    break;\n                }\n                num2--;\n            }\n            if (num != num2)\n            {\n                return false;\n            }", "            if (num != num2)\n            {\n                return false;\n            }\n            for (int i = 0; i <= num; i++)\n            {\n                uint num5 = path1[i];\n                uint num6 = path2[i];\n                if ((num5 | num6) > 127)\n                {\n                    return PathsEqualNonAscii(path1, path2, i, num - i + 1);\n                }", "                if ((num5 | num6) > 127)\n                {\n                    return PathsEqualNonAscii(path1, path2, i, num - i + 1);\n                }\n                if (num5 - 97 <= 25)\n                {\n                    num5 -= 32;\n                }\n                if (num6 - 97 <= 25)\n                {\n                    num6 -= 32;\n                }", "                if (num6 - 97 <= 25)\n                {\n                    num6 -= 32;\n                }\n                if (num5 == 92)\n                {\n                    num5 = 47u;\n                }\n                if (num6 == 92)\n                {\n                    num6 = 47u;\n                }", "                if (num6 == 92)\n                {\n                    num6 = 47u;\n                }\n                if (num5 != num6)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n", "        private static bool PathsEqualNonAscii(string strA, string strB, int i, int length)\n        {\n            if (string.Compare(strA, i, strB, i, length, StringComparison.OrdinalIgnoreCase) == 0)\n            {\n                return true;\n            }\n            string strA2 = strA.ToSlash();\n            string strB2 = strB.ToSlash();\n            if (string.Compare(strA2, i, strB2, i, length, StringComparison.OrdinalIgnoreCase) == 0)\n            {\n                return true;\n            }\n            return false;\n        }\n\n        internal static string ToSlash(this string s)\n        {\n            return s.Replace('\\\\', '/');\n        }\n\n        internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem = null)\n        {\n            fullPath = AttemptToShortenPath(fullPath);\n            try\n            {", "            if (string.Compare(strA2, i, strB2, i, length, StringComparison.OrdinalIgnoreCase) == 0)\n            {\n                return true;\n            }\n            return false;\n        }\n\n        internal static string ToSlash(this string s)\n        {\n            return s.Replace('\\\\', '/');\n        }\n\n        internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem = null)\n        {\n            fullPath = AttemptToShortenPath(fullPath);\n            try\n            {", "                if (fileSystem == null)\n                {\n                    fileSystem = DefaultFileSystem;\n                }\n                return /*Traits.Instance.CacheFileExistence*/true ? FileExistenceCache.GetOrAdd(fullPath, (string fullPath) => fileSystem.FileExists(fullPath)) : fileSystem.FileExists(fullPath);\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        internal static StreamWriter OpenWrite(string path, bool append, Encoding encoding = null)\n        {\n            FileMode mode = (append ? FileMode.Append : FileMode.Create);\n            Stream stream = new FileStream(path, mode, FileAccess.Write, FileShare.Read, 4096, FileOptions.SequentialScan);", "            if (stream != null)\n                FileExistenceCache[path] = true;\n\n            if (encoding == null)\n            {\n                return new StreamWriter(stream);\n            }\n            return new StreamWriter(stream, encoding);\n        }\n\n        internal static bool IsAnySlash(char c)\n        {", "            if (c != '/')\n            {\n                return c == '\\\\';\n            }\n            return true;\n        }\n\n        internal static void ClearFileExistenceCache()\n        {\n            FileExistenceCache.Clear();\n        }\n\n        internal static void UpdateFileExistenceCache(string path)\n        {\n            bool value;\n            FileExistenceCache.Remove(path, out value);\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.Shared/ReuseableStringBuilder.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Microsoft.Build.Shared\n{\n    internal sealed class ReuseableStringBuilder : IDisposable\n    {\n        private static class ReuseableStringBuilderFactory\n        {\n            private const int MaxBuilderSize = 1024;\n", "        private static class ReuseableStringBuilderFactory\n        {\n            private const int MaxBuilderSize = 1024;\n\n            private static StringBuilder s_sharedBuilder;\n\n            internal static StringBuilder Get(int capacity)\n            {\n                StringBuilder stringBuilder = Interlocked.Exchange(ref s_sharedBuilder, null);\n                if (stringBuilder == null)\n                {\n                    stringBuilder = new StringBuilder(capacity);\n                }", "                if (stringBuilder == null)\n                {\n                    stringBuilder = new StringBuilder(capacity);\n                }\n                else if (stringBuilder.Capacity < capacity)\n                {\n                    stringBuilder.Capacity = capacity;\n                }\n                return stringBuilder;\n            }\n\n            internal static void Release(StringBuilder returningBuilder)\n            {", "                if (returningBuilder.Capacity < 1024)\n                {\n                    returningBuilder.Clear();\n                    Interlocked.Exchange(ref s_sharedBuilder, returningBuilder);\n                }\n            }\n        }\n\n        private StringBuilder _borrowedBuilder;\n\n        private int _capacity;\n", "        private StringBuilder _borrowedBuilder;\n\n        private int _capacity;\n\n        public int Length\n        {\n            get\n            {\n                if (_borrowedBuilder != null)\n                {\n                    return _borrowedBuilder.Length;\n                }\n                return 0;\n            }\n            set\n            {\n                LazyPrepare();\n                _borrowedBuilder.Length = value;\n            }\n        }\n\n        internal ReuseableStringBuilder(int capacity = 16)\n        {\n            _capacity = capacity;\n        }\n", "                if (_borrowedBuilder != null)\n                {\n                    return _borrowedBuilder.Length;\n                }\n                return 0;\n            }\n            set\n            {\n                LazyPrepare();\n                _borrowedBuilder.Length = value;\n            }\n        }\n\n        internal ReuseableStringBuilder(int capacity = 16)\n        {\n            _capacity = capacity;\n        }\n", "        public override string ToString()\n        {\n            if (_borrowedBuilder == null)\n            {\n                return string.Empty;\n            }\n            return _borrowedBuilder.ToString();\n        }\n\n        void IDisposable.Dispose()\n        {", "            if (_borrowedBuilder != null)\n            {\n                ReuseableStringBuilderFactory.Release(_borrowedBuilder);\n                _borrowedBuilder = null;\n                _capacity = -1;\n            }\n        }\n\n        internal ReuseableStringBuilder Append(char value)\n        {\n            LazyPrepare();\n            _borrowedBuilder.Append(value);\n            return this;\n        }\n\n        internal ReuseableStringBuilder Append(string value)\n        {\n            LazyPrepare();\n            _borrowedBuilder.Append(value);\n            return this;\n        }\n\n        internal ReuseableStringBuilder Append(string value, int startIndex, int count)\n        {\n            LazyPrepare();\n            _borrowedBuilder.Append(value, startIndex, count);\n            return this;\n        }\n", "        public ReuseableStringBuilder AppendSeparated(char separator, ICollection<string> strings)\n        {\n            LazyPrepare();\n            int num = strings.Count - 1;\n            foreach (string @string in strings)\n            {\n                _borrowedBuilder.Append(@string);\n                if (num > 0)\n                {\n                    _borrowedBuilder.Append(separator);\n                }\n                num--;\n            }\n            return this;\n        }\n", "        public ReuseableStringBuilder Clear()\n        {\n            LazyPrepare();\n            _borrowedBuilder.Clear();\n            return this;\n        }\n\n        internal ReuseableStringBuilder Remove(int startIndex, int length)\n        {\n            LazyPrepare();\n            _borrowedBuilder.Remove(startIndex, length);\n            return this;\n        }\n", "        private void LazyPrepare()\n        {\n            if (_borrowedBuilder == null)\n            {\n                ErrorUtilities.VerifyThrow(_capacity != -1, \"Reusing after dispose\");\n                _borrowedBuilder = ReuseableStringBuilderFactory.Get(_capacity);\n            }\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.Shared/VCUtilities.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Security.Cryptography;\n\nnamespace Microsoft.Build.Shared\n{\n    internal static class VCUtilities\n    {\n        internal static string GetHashString(string content)\n        {\n            using SHA256 sHA = new SHA256CryptoServiceProvider();\n            byte[] array = sHA.ComputeHash(Encoding.UTF8.GetBytes(content)).Take(16).ToArray();\n            char[] array2 = new char[16];", "            for (int i = 0; i < array2.Length; i++)\n            {\n                array2[i] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[(int)array[i] % \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\".Length];\n            }\n            return new string(array2);\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.Shared/FileSystem/ManagedFileSystem.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing Microsoft.Build.Shared.FileSystem;\n\nnamespace Microsoft.Build.Shared.FileSystem\n{\n    internal class ManagedFileSystem : IFileSystem\n    {\n        private static readonly ManagedFileSystem Instance = new ManagedFileSystem();\n", "        private static readonly ManagedFileSystem Instance = new ManagedFileSystem();\n\n        public static ManagedFileSystem Singleton()\n        {\n            return Instance;\n        }\n\n        protected ManagedFileSystem()\n        {\n        }\n", "        public TextReader ReadFile(string path)\n        {\n            return new StreamReader(path);\n        }\n\n        public Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share)\n        {\n            return new FileStream(path, mode, access, share);\n        }\n\n        public string ReadFileAllText(string path)\n        {\n            return File.ReadAllText(path);\n        }\n\n        public byte[] ReadFileAllBytes(string path)\n        {\n            return File.ReadAllBytes(path);\n        }\n", "        public string ReadFileAllText(string path)\n        {\n            return File.ReadAllText(path);\n        }\n\n        public byte[] ReadFileAllBytes(string path)\n        {\n            return File.ReadAllBytes(path);\n        }\n\n        public virtual IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)\n        {\n            return Directory.EnumerateFiles(path, searchPattern, searchOption);\n        }\n", "        public virtual IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)\n        {\n            return Directory.EnumerateFiles(path, searchPattern, searchOption);\n        }\n\n        public virtual IEnumerable<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption)\n        {\n            return Directory.EnumerateDirectories(path, searchPattern, searchOption);\n        }\n\n        public virtual IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption)\n        {\n            return Directory.EnumerateFileSystemEntries(path, searchPattern, searchOption);\n        }\n", "        public virtual IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption)\n        {\n            return Directory.EnumerateFileSystemEntries(path, searchPattern, searchOption);\n        }\n\n        public FileAttributes GetAttributes(string path)\n        {\n            return File.GetAttributes(path);\n        }\n\n        public virtual DateTime GetLastWriteTimeUtc(string path)\n        {\n            return File.GetLastWriteTimeUtc(path);\n        }\n", "        public virtual DateTime GetLastWriteTimeUtc(string path)\n        {\n            return File.GetLastWriteTimeUtc(path);\n        }\n\n        public virtual bool DirectoryExists(string path)\n        {\n            return Directory.Exists(path);\n        }\n\n        public virtual bool FileExists(string path)\n        {\n            return File.Exists(path);\n        }\n", "        public virtual bool FileExists(string path)\n        {\n            return File.Exists(path);\n        }\n\n        public virtual bool FileOrDirectoryExists(string path)\n        {\n            if (!FileExists(path))\n            {\n                return DirectoryExists(path);\n            }\n            return true;\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.Shared/FileSystem/FileSystems.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Microsoft.Build.Shared.FileSystem\n{\n    internal interface IFileSystem\n    {\n        TextReader ReadFile(string path);\n\n        Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);\n\n        string ReadFileAllText(string path);\n\n        byte[] ReadFileAllBytes(string path);\n\n        IEnumerable<string> EnumerateFiles(string path, string searchPattern = \"*\", SearchOption searchOption = SearchOption.TopDirectoryOnly);\n\n        IEnumerable<string> EnumerateDirectories(string path, string searchPattern = \"*\", SearchOption searchOption = SearchOption.TopDirectoryOnly);\n\n        IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = \"*\", SearchOption searchOption = SearchOption.TopDirectoryOnly);\n\n        FileAttributes GetAttributes(string path);\n\n        DateTime GetLastWriteTimeUtc(string path);\n\n        bool DirectoryExists(string path);\n\n        bool FileExists(string path);\n\n        bool FileOrDirectoryExists(string path);\n    }\n\n", "    internal static class FileSystems\n    {\n        public static IFileSystem Default = GetFileSystem();\n\n        private static IFileSystem GetFileSystem()\n        {\n#if __\n            // \u4e0d\u652f\u6301Windows\uff0c\u6240\u4ee5\u4e0d\u8003\u8651\u8fd9\u4e2a\u8def\u5f84\n            if (NativeMethods.IsWindows)\n            {\n                return MSBuildOnWindowsFileSystem.Singleton();\n            }\n#endif\n            return ManagedFileSystem.Singleton();\n        }\n    }\n}\n", "            if (NativeMethods.IsWindows)\n            {\n                return MSBuildOnWindowsFileSystem.Singleton();\n            }\n#endif\n            return ManagedFileSystem.Singleton();\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.CPPTasks/ArgumentRelation.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Microsoft.Build.CPPTasks\n{\n    public class ArgumentRelation : PropertyRelation\n    {\n        public string Separator { get; set; }\n\n        public ArgumentRelation(string argument, string value, bool required, string separator)\n            : base(argument, value, required)\n        {\n            Separator = separator;\n        }\n    }\n}\n", "        public string Separator { get; set; }\n\n        public ArgumentRelation(string argument, string value, bool required, string separator)\n            : base(argument, value, required)\n        {\n            Separator = separator;\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.CPPTasks/MsbuildTaskUtilities.cs", "chunked_list": ["\ufeffusing Microsoft.Build.Framework;\nusing Microsoft.Build.Utilities;\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\nusing Microsoft.Build.Tasks;\nusing Microsoft.Build.Shared;\n\nnamespace Microsoft.Build.CPPTasks\n{\n    internal static class MsbuildTaskUtilities\n    {", "namespace Microsoft.Build.CPPTasks\n{\n    internal static class MsbuildTaskUtilities\n    {\n        public static char[] semicolonSeparator = new char[1] { ';' };\n\n        public static string[] GetWildcardExpandedFileListFromMetadata(IBuildEngine buildEngine, ITaskItem item, string metadataName, TaskLoggingHelper log = null, bool convertToUpperCase = true)\n        {\n            string metadata = item.GetMetadata(metadataName);\n            string warningResource = null;\n            if (metadataName == \"AdditionalInputs\")\n            {\n                warningResource = \"CustomBuild.InvalidDependency\";\n            }", "            if (metadataName == \"AdditionalInputs\")\n            {\n                warningResource = \"CustomBuild.InvalidDependency\";\n            }\n            else if (metadataName == \"Outputs\")\n            {\n                warningResource = \"CustomBuild.InvalidOutput\";\n            }\n            return GetWildcardExpandedFileList(buildEngine, metadata, log, warningResource, item.ItemSpec, convertToUpperCase);\n        }\n", "        public static string[] GetWildcardExpandedFileList(IBuildEngine buildEngine, string value, TaskLoggingHelper log = null, string warningResource = null, string itemName = null, bool convertToUpperCase = true)\n        {\n            List<string> list = new List<string>();\n            CreateItem createItem = new CreateItem();\n            createItem.BuildEngine = buildEngine;\n            if (!string.IsNullOrEmpty(value))\n            {\n                string[] array = value.Split(semicolonSeparator);\n                List<ITaskItem> list2 = new List<ITaskItem>();\n                string[] array2 = array;\n                foreach (string text in array2)\n                {\n                    string text2 = text.Trim();", "                foreach (string text in array2)\n                {\n                    string text2 = text.Trim();\n                    if (!string.IsNullOrEmpty(text2))\n                    {\n                        list2.Add(new TaskItem(text2));\n                    }\n                }\n                createItem.Include = list2.ToArray();\n                createItem.Execute();\n                ITaskItem[] include = createItem.Include;", "                foreach (ITaskItem taskItem in include)\n                {\n                    try\n                    {\n                        string text3 = taskItem.GetMetadata(\"FullPath\");\n                        //if (convertToUpperCase)\n                        //{\n                        //    text3 = text3.ToUpperInvariant();\n                        //}\n                        list.Add(text3);\n                    }", "                    catch (Exception ex)\n                    {\n                        if (log != null && warningResource != null && itemName != null)\n                        {\n                            log.LogWarningWithCodeFromResources(warningResource, itemName, taskItem.ItemSpec);\n                        }\n                        ex.RethrowIfCritical();\n                    }\n                }\n            }\n            return list.ToArray();\n        }\n", "        public static string FileNameFromHash(string content)\n        {\n            return VCUtilities.GetHashString(content);\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.CPPTasks/TrackedVCToolTask.cs", "chunked_list": ["\ufeffusing Microsoft.Build.Framework;\nusing Microsoft.Build.Shared;\nusing Microsoft.Build.Utilities;\nusing Microsoft.Win32.SafeHandles;\nusing System;\nusing System.Collections.Generic;\nusing System.Security;\nusing System.Text;\nusing System.Text.RegularExpressions;\n", "using System.Text.RegularExpressions;\n\nnamespace Microsoft.Build.CPPTasks\n{\n    public abstract class TrackedVCToolTask : VCToolTask\n    {\n        private bool skippedExecution;\n\n        private CanonicalTrackedInputFiles sourceDependencies;\n\n        private CanonicalTrackedOutputFiles sourceOutputs;\n", "        private CanonicalTrackedInputFiles sourceDependencies;\n\n        private CanonicalTrackedOutputFiles sourceOutputs;\n\n        private bool trackFileAccess;\n\n        private bool trackCommandLines = true;\n\n        private bool minimalRebuildFromTracking;\n\n        private bool deleteOutputBeforeExecute;\n", "        private bool minimalRebuildFromTracking;\n\n        private bool deleteOutputBeforeExecute;\n\n        private string rootSource;\n\n        private ITaskItem[] tlogReadFiles;\n\n        private ITaskItem[] tlogWriteFiles;\n\n        private ITaskItem tlogCommandFile;\n\n        private ITaskItem[] sourcesCompiled;\n\n        private ITaskItem[] trackedInputFilesToIgnore;\n\n        private ITaskItem[] trackedOutputFilesToIgnore;\n\n        private ITaskItem[] excludedInputPaths = new TaskItem[0];\n", "        private ITaskItem tlogCommandFile;\n\n        private ITaskItem[] sourcesCompiled;\n\n        private ITaskItem[] trackedInputFilesToIgnore;\n\n        private ITaskItem[] trackedOutputFilesToIgnore;\n\n        private ITaskItem[] excludedInputPaths = new TaskItem[0];\n\n        private string pathOverride;\n", "        private string pathOverride;\n\n        private static readonly char[] NewlineArray = Environment.NewLine.ToCharArray();\n\n        private static readonly Regex extraNewlineRegex = new Regex(\"(\\\\r?\\\\n)?(\\\\r?\\\\n)+\");\n\n        protected abstract string TrackerIntermediateDirectory { get; }\n\n        protected abstract ITaskItem[] TrackedInputFiles { get; }\n\n        protected CanonicalTrackedInputFiles SourceDependencies\n        {\n            get\n            {\n                return sourceDependencies;\n            }\n            set\n            {\n                sourceDependencies = value;\n            }\n        }\n", "        protected abstract ITaskItem[] TrackedInputFiles { get; }\n\n        protected CanonicalTrackedInputFiles SourceDependencies\n        {\n            get\n            {\n                return sourceDependencies;\n            }\n            set\n            {\n                sourceDependencies = value;\n            }\n        }\n", "        protected CanonicalTrackedOutputFiles SourceOutputs\n        {\n            get\n            {\n                return sourceOutputs;\n            }\n            set\n            {\n                sourceOutputs = value;\n            }\n        }\n\n        [Output]", "        public bool SkippedExecution\n        {\n            get\n            {\n                return skippedExecution;\n            }\n            set\n            {\n                skippedExecution = value;\n            }\n        }\n", "        public string RootSource\n        {\n            get\n            {\n                return rootSource;\n            }\n            set\n            {\n                rootSource = value;\n            }\n        }\n", "        protected virtual bool TrackReplaceFile => false;\n\n        protected virtual string[] ReadTLogNames\n        {\n            get\n            {\n                string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(ToolExe);\n                return new string[4]\n                {\n                fileNameWithoutExtension + \".read.*.tlog\",\n                fileNameWithoutExtension + \".*.read.*.tlog\",\n                fileNameWithoutExtension + \"-*.read.*.tlog\",\n                GetType().FullName + \".read.*.tlog\"\n                };\n            }\n        }\n", "        protected virtual string[] WriteTLogNames\n        {\n            get\n            {\n                string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(ToolExe);\n                return new string[4]\n                {\n                fileNameWithoutExtension + \".write.*.tlog\",\n                fileNameWithoutExtension + \".*.write.*.tlog\",\n                fileNameWithoutExtension + \"-*.write.*.tlog\",\n                GetType().FullName + \".write.*.tlog\"\n                };\n            }\n        }\n", "        protected virtual string[] DeleteTLogNames\n        {\n            get\n            {\n                string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(ToolExe);\n                return new string[4]\n                {\n                fileNameWithoutExtension + \".delete.*.tlog\",\n                fileNameWithoutExtension + \".*.delete.*.tlog\",\n                fileNameWithoutExtension + \"-*.delete.*.tlog\",\n                GetType().FullName + \".delete.*.tlog\"\n                };\n            }\n        }\n", "        protected virtual string CommandTLogName\n        {\n            get\n            {\n                string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(ToolExe);\n                return fileNameWithoutExtension + \".command.1.tlog\";\n            }\n        }\n\n        public ITaskItem[] TLogReadFiles\n        {\n            get\n            {\n                return tlogReadFiles;\n            }\n            set\n            {\n                tlogReadFiles = value;\n            }\n        }\n\n        public ITaskItem[] TLogWriteFiles\n        {\n            get\n            {\n                return tlogWriteFiles;\n            }\n            set\n            {\n                tlogWriteFiles = value;\n            }\n        }\n\n        public ITaskItem[] TLogDeleteFiles { get; set; }\n", "        public ITaskItem TLogCommandFile\n        {\n            get\n            {\n                return tlogCommandFile;\n            }\n            set\n            {\n                tlogCommandFile = value;\n            }\n        }\n", "        public bool TrackFileAccess\n        {\n            get\n            {\n                return trackFileAccess;\n            }\n            set\n            {\n                trackFileAccess = value;\n            }\n        }\n", "        public bool TrackCommandLines\n        {\n            get\n            {\n                return trackCommandLines;\n            }\n            set\n            {\n                trackCommandLines = value;\n            }\n        }\n", "        public bool PostBuildTrackingCleanup { get; set; }\n\n        public bool EnableExecuteTool { get; set; }\n\n        public bool MinimalRebuildFromTracking\n        {\n            get\n            {\n                return minimalRebuildFromTracking;\n            }\n            set\n            {\n                minimalRebuildFromTracking = value;\n            }\n        }\n", "        public virtual bool AttributeFileTracking => false;\n\n        [Output]\n        public ITaskItem[] SourcesCompiled\n        {\n            get\n            {\n                return sourcesCompiled;\n            }\n            set\n            {\n                sourcesCompiled = value;\n            }\n        }\n\n        public ITaskItem[] TrackedOutputFilesToIgnore\n        {\n            get\n            {\n                return trackedOutputFilesToIgnore;\n            }\n            set\n            {\n                trackedOutputFilesToIgnore = value;\n            }\n        }\n\n        public ITaskItem[] TrackedInputFilesToIgnore\n        {\n            get\n            {\n                return trackedInputFilesToIgnore;\n            }\n            set\n            {\n                trackedInputFilesToIgnore = value;\n            }\n        }\n", "        public bool DeleteOutputOnExecute\n        {\n            get\n            {\n                return deleteOutputBeforeExecute;\n            }\n            set\n            {\n                deleteOutputBeforeExecute = value;\n            }\n        }\n", "        public bool DeleteOutputBeforeExecute\n        {\n            get\n            {\n                return deleteOutputBeforeExecute;\n            }\n            set\n            {\n                deleteOutputBeforeExecute = value;\n            }\n        }\n", "        protected virtual bool MaintainCompositeRootingMarkers => false;\n\n        protected virtual bool UseMinimalRebuildOptimization => false;\n\n        public virtual string SourcesPropertyName => \"Sources\";\n\n        // protected virtual ExecutableType? ToolType => null;\n\n        public string ToolArchitecture { get; set; }\n\n        public string TrackerFrameworkPath { get; set; }\n", "        public string ToolArchitecture { get; set; }\n\n        public string TrackerFrameworkPath { get; set; }\n\n        public string TrackerSdkPath { get; set; }\n\n        public ITaskItem[] ExcludedInputPaths\n        {\n            get\n            {\n                return excludedInputPaths;\n            }\n            set\n            {\n                List<ITaskItem> list = new List<ITaskItem>(value);\n                excludedInputPaths = list.ToArray();\n            }\n        }\n", "        public string PathOverride\n        {\n            get\n            {\n                return pathOverride;\n            }\n            set\n            {\n                pathOverride = value;\n            }\n        }\n\n        protected TrackedVCToolTask(System.Resources.ResourceManager taskResources)\n            : base(taskResources)\n        {\n            PostBuildTrackingCleanup = true;\n            EnableExecuteTool = true;\n        }\n", "        protected virtual void AssignDefaultTLogPaths()\n        {\n            string trackerIntermediateDirectory = TrackerIntermediateDirectory;\n            if (TLogReadFiles == null)\n            {\n                string[] readTLogNames = ReadTLogNames;\n                TLogReadFiles = new ITaskItem[readTLogNames.Length];\n                for (int i = 0; i < readTLogNames.Length; i++)\n                {\n                    TLogReadFiles[i] = new TaskItem(Path.Combine(trackerIntermediateDirectory, readTLogNames[i]));\n                }\n            }", "            if (TLogWriteFiles == null)\n            {\n                string[] writeTLogNames = WriteTLogNames;\n                TLogWriteFiles = new ITaskItem[writeTLogNames.Length];\n                for (int j = 0; j < writeTLogNames.Length; j++)\n                {\n                    TLogWriteFiles[j] = new TaskItem(Path.Combine(trackerIntermediateDirectory, writeTLogNames[j]));\n                }\n            }\n            if (TLogDeleteFiles == null)\n            {\n                string[] deleteTLogNames = DeleteTLogNames;\n                TLogDeleteFiles = new ITaskItem[deleteTLogNames.Length];", "            if (TLogDeleteFiles == null)\n            {\n                string[] deleteTLogNames = DeleteTLogNames;\n                TLogDeleteFiles = new ITaskItem[deleteTLogNames.Length];\n                for (int k = 0; k < deleteTLogNames.Length; k++)\n                {\n                    TLogDeleteFiles[k] = new TaskItem(Path.Combine(trackerIntermediateDirectory, deleteTLogNames[k]));\n                }\n            }\n            if (TLogCommandFile == null)\n            {\n                TLogCommandFile = new TaskItem(Path.Combine(trackerIntermediateDirectory, CommandTLogName));\n            }\n        }\n", "            if (TLogCommandFile == null)\n            {\n                TLogCommandFile = new TaskItem(Path.Combine(trackerIntermediateDirectory, CommandTLogName));\n            }\n        }\n\n        protected override bool SkipTaskExecution()\n        {\n            return ComputeOutOfDateSources();\n        }\n", "        protected internal virtual bool ComputeOutOfDateSources()\n        {\n            if (MinimalRebuildFromTracking || TrackFileAccess)\n            {\n                AssignDefaultTLogPaths();\n            }\n            if (MinimalRebuildFromTracking && !ForcedRebuildRequired())\n            {\n                sourceOutputs = new CanonicalTrackedOutputFiles(this, TLogWriteFiles);\n                sourceDependencies = new CanonicalTrackedInputFiles(this, TLogReadFiles, TrackedInputFiles, ExcludedInputPaths, sourceOutputs, UseMinimalRebuildOptimization, MaintainCompositeRootingMarkers);\n                ITaskItem[] sourcesOutOfDateThroughTracking = SourceDependencies.ComputeSourcesNeedingCompilation(searchForSubRootsInCompositeRootingMarkers: false);\n                List<ITaskItem> sourcesWithChangedCommandLines = GenerateSourcesOutOfDateDueToCommandLine();\n                SourcesCompiled = MergeOutOfDateSourceLists(sourcesOutOfDateThroughTracking, sourcesWithChangedCommandLines);", "                if (SourcesCompiled.Length == 0)\n                {\n                    SkippedExecution = true;\n                    return SkippedExecution;\n                }\n                SourcesCompiled = AssignOutOfDateSources(SourcesCompiled);\n                SourceDependencies.RemoveEntriesForSource(SourcesCompiled);\n                SourceDependencies.SaveTlog();\n                if (DeleteOutputOnExecute)\n                {\n                    DeleteFiles(sourceOutputs.OutputsForSource(SourcesCompiled, searchForSubRootsInCompositeRootingMarkers: false));\n                }\n                sourceOutputs.RemoveEntriesForSource(SourcesCompiled);\n                sourceOutputs.SaveTlog();\n            }\n            else\n            {\n                SourcesCompiled = TrackedInputFiles;", "                if (DeleteOutputOnExecute)\n                {\n                    DeleteFiles(sourceOutputs.OutputsForSource(SourcesCompiled, searchForSubRootsInCompositeRootingMarkers: false));\n                }\n                sourceOutputs.RemoveEntriesForSource(SourcesCompiled);\n                sourceOutputs.SaveTlog();\n            }\n            else\n            {\n                SourcesCompiled = TrackedInputFiles;\n                if (SourcesCompiled == null || SourcesCompiled.Length == 0)\n                {\n                    SkippedExecution = true;\n                    return SkippedExecution;\n                }\n            }", "                if (SourcesCompiled == null || SourcesCompiled.Length == 0)\n                {\n                    SkippedExecution = true;\n                    return SkippedExecution;\n                }\n            }\n            if ((TrackFileAccess || TrackCommandLines) && string.IsNullOrEmpty(RootSource))\n            {\n                RootSource = FileTracker.FormatRootingMarker(SourcesCompiled);\n            }\n            SkippedExecution = false;\n            return SkippedExecution;\n        }\n", "        protected virtual ITaskItem[] AssignOutOfDateSources(ITaskItem[] sources)\n        {\n            return sources;\n        }\n\n        protected virtual bool ForcedRebuildRequired()\n        {\n            string text = null;\n            try\n            {\n                text = TLogCommandFile.GetMetadata(\"FullPath\");\n            }", "            catch (Exception ex)\n            {\n                if (!(ex is InvalidOperationException) && !(ex is NullReferenceException))\n                {\n                    throw;\n                }\n                base.Log.LogWarningWithCodeFromResources(\"TrackedVCToolTask.RebuildingDueToInvalidTLog\", ex.Message);\n                return true;\n            }\n            if (!File.Exists(text))\n            {\n                base.Log.LogMessageFromResources(MessageImportance.Low, \"TrackedVCToolTask.RebuildingNoCommandTLog\", TLogCommandFile.GetMetadata(\"FullPath\"));\n                return true;\n            }\n            return false;\n        }\n", "            if (!File.Exists(text))\n            {\n                base.Log.LogMessageFromResources(MessageImportance.Low, \"TrackedVCToolTask.RebuildingNoCommandTLog\", TLogCommandFile.GetMetadata(\"FullPath\"));\n                return true;\n            }\n            return false;\n        }\n\n        protected virtual List<ITaskItem> GenerateSourcesOutOfDateDueToCommandLine()\n        {\n            IDictionary<string, string> dictionary = MapSourcesToCommandLines();\n            List<ITaskItem> list = new List<ITaskItem>();", "        protected virtual List<ITaskItem> GenerateSourcesOutOfDateDueToCommandLine()\n        {\n            IDictionary<string, string> dictionary = MapSourcesToCommandLines();\n            List<ITaskItem> list = new List<ITaskItem>();\n            if (!TrackCommandLines)\n            {\n                return list;\n            }\n            if (dictionary.Count == 0)\n            {\n                ITaskItem[] trackedInputFiles = TrackedInputFiles;", "            if (dictionary.Count == 0)\n            {\n                ITaskItem[] trackedInputFiles = TrackedInputFiles;\n                foreach (ITaskItem item in trackedInputFiles)\n                {\n                    list.Add(item);\n                }\n            }\n            else if (MaintainCompositeRootingMarkers)\n            {\n                string text = ApplyPrecompareCommandFilter(GenerateCommandLine(CommandLineFormat.ForTracking));\n                string value = null;", "            else if (MaintainCompositeRootingMarkers)\n            {\n                string text = ApplyPrecompareCommandFilter(GenerateCommandLine(CommandLineFormat.ForTracking));\n                string value = null;\n                if (dictionary.TryGetValue(FileTracker.FormatRootingMarker(TrackedInputFiles), out value))\n                {\n                    value = ApplyPrecompareCommandFilter(value);\n                    if (value == null || !text.Equals(value, StringComparison.Ordinal))\n                    {\n                        ITaskItem[] trackedInputFiles2 = TrackedInputFiles;\n                        foreach (ITaskItem item2 in trackedInputFiles2)\n                        {\n                            list.Add(item2);\n                        }\n                    }\n                }\n                else\n                {\n                    ITaskItem[] trackedInputFiles3 = TrackedInputFiles;", "                        foreach (ITaskItem item2 in trackedInputFiles2)\n                        {\n                            list.Add(item2);\n                        }\n                    }\n                }\n                else\n                {\n                    ITaskItem[] trackedInputFiles3 = TrackedInputFiles;\n                    foreach (ITaskItem item3 in trackedInputFiles3)\n                    {\n                        list.Add(item3);\n                    }\n                }\n            }\n            else\n            {\n                string text2 = SourcesPropertyName ?? \"Sources\";\n                string text3 = GenerateCommandLineExceptSwitches(new string[1] { text2 }, CommandLineFormat.ForTracking);\n                ITaskItem[] trackedInputFiles4 = TrackedInputFiles;", "                    foreach (ITaskItem item3 in trackedInputFiles3)\n                    {\n                        list.Add(item3);\n                    }\n                }\n            }\n            else\n            {\n                string text2 = SourcesPropertyName ?? \"Sources\";\n                string text3 = GenerateCommandLineExceptSwitches(new string[1] { text2 }, CommandLineFormat.ForTracking);\n                ITaskItem[] trackedInputFiles4 = TrackedInputFiles;", "                foreach (ITaskItem taskItem in trackedInputFiles4)\n                {\n                    string text4 = ApplyPrecompareCommandFilter(text3 + \" \" + taskItem.GetMetadata(\"FullPath\")/*.ToUpperInvariant()*/);\n                    string value2 = null;\n                    if (dictionary.TryGetValue(FileTracker.FormatRootingMarker(taskItem), out value2))\n                    {\n                        value2 = ApplyPrecompareCommandFilter(value2);\n                        if (value2 == null || !text4.Equals(value2, StringComparison.Ordinal))\n                        {\n                            list.Add(taskItem);\n                        }\n                    }\n                    else\n                    {\n                        list.Add(taskItem);\n                    }\n                }\n            }\n            return list;\n        }\n\n        protected ITaskItem[] MergeOutOfDateSourceLists(ITaskItem[] sourcesOutOfDateThroughTracking, List<ITaskItem> sourcesWithChangedCommandLines)\n        {", "            if (sourcesWithChangedCommandLines.Count == 0)\n            {\n                return sourcesOutOfDateThroughTracking;\n            }\n            if (sourcesOutOfDateThroughTracking.Length == 0)\n            {\n                if (sourcesWithChangedCommandLines.Count == TrackedInputFiles.Length)\n                {\n                    base.Log.LogMessageFromResources(MessageImportance.Low, \"TrackedVCToolTask.RebuildingAllSourcesCommandLineChanged\");\n                }\n                else\n                {", "                    foreach (ITaskItem sourcesWithChangedCommandLine in sourcesWithChangedCommandLines)\n                    {\n                        base.Log.LogMessageFromResources(MessageImportance.Low, \"TrackedVCToolTask.RebuildingSourceCommandLineChanged\", sourcesWithChangedCommandLine.GetMetadata(\"FullPath\"));\n                    }\n                }\n                return sourcesWithChangedCommandLines.ToArray();\n            }\n            if (sourcesOutOfDateThroughTracking.Length == TrackedInputFiles.Length)\n            {\n                return TrackedInputFiles;\n            }", "            if (sourcesWithChangedCommandLines.Count == TrackedInputFiles.Length)\n            {\n                base.Log.LogMessageFromResources(MessageImportance.Low, \"TrackedVCToolTask.RebuildingAllSourcesCommandLineChanged\");\n                return TrackedInputFiles;\n            }\n            Dictionary<ITaskItem, bool> dictionary = new Dictionary<ITaskItem, bool>();\n            foreach (ITaskItem key in sourcesOutOfDateThroughTracking)\n            {\n                dictionary[key] = false;\n            }\n            foreach (ITaskItem sourcesWithChangedCommandLine2 in sourcesWithChangedCommandLines)\n            {", "            foreach (ITaskItem sourcesWithChangedCommandLine2 in sourcesWithChangedCommandLines)\n            {\n                if (!dictionary.ContainsKey(sourcesWithChangedCommandLine2))\n                {\n                    dictionary.Add(sourcesWithChangedCommandLine2, value: true);\n                }\n            }\n            List<ITaskItem> list = new List<ITaskItem>();\n            ITaskItem[] trackedInputFiles = TrackedInputFiles;\n            foreach (ITaskItem taskItem in trackedInputFiles)\n            {\n                bool value = false;", "            foreach (ITaskItem taskItem in trackedInputFiles)\n            {\n                bool value = false;\n                if (dictionary.TryGetValue(taskItem, out value))\n                {\n                    list.Add(taskItem);\n                    if (value)\n                    {\n                        base.Log.LogMessageFromResources(MessageImportance.Low, \"TrackedVCToolTask.RebuildingSourceCommandLineChanged\", taskItem.GetMetadata(\"FullPath\"));\n                    }\n                }\n            }\n            return list.ToArray();\n        }\n\n        protected IDictionary<string, string> MapSourcesToCommandLines()\n        {\n            IDictionary<string, string> dictionary = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            string metadata = TLogCommandFile.GetMetadata(\"FullPath\");", "            if (File.Exists(metadata))\n            {\n                using (StreamReader streamReader = File.OpenText(metadata))\n                {\n                    bool flag = false;\n                    string text = string.Empty;\n                    for (string text2 = streamReader.ReadLine(); text2 != null; text2 = streamReader.ReadLine())\n                    {\n                        if (text2.Length == 0)\n                        {\n                            flag = true;\n                            break;\n                        }", "                        if (text2.Length == 0)\n                        {\n                            flag = true;\n                            break;\n                        }\n                        if (text2[0] == '^')\n                        {\n                            if (text2.Length == 1)\n                            {\n                                flag = true;\n                                break;\n                            }\n                            text = text2.Substring(1);\n                        }\n                        else\n                        {\n                            string value = null;", "                            if (!dictionary.TryGetValue(text, out value))\n                            {\n                                dictionary[text] = text2;\n                            }\n                            else\n                            {\n                                IDictionary<string, string> dictionary2 = dictionary;\n                                string key = text;\n                                dictionary2[key] = dictionary2[key] + \"\\r\\n\" + text2;\n                            }\n                        }\n                    }", "                    if (flag)\n                    {\n                        base.Log.LogWarningWithCodeFromResources(\"TrackedVCToolTask.RebuildingDueToInvalidTLogContents\", metadata);\n                        return new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n                    }\n                    return dictionary;\n                }\n            }\n            return dictionary;\n        }\n", "        protected void WriteSourcesToCommandLinesTable(IDictionary<string, string> sourcesToCommandLines)\n        {\n            string metadata = TLogCommandFile.GetMetadata(\"FullPath\");\n            Directory.CreateDirectory(Path.GetDirectoryName(metadata));\n            using StreamWriter streamWriter = new StreamWriter(metadata, append: false, Encoding.Unicode);\n            foreach (KeyValuePair<string, string> sourcesToCommandLine in sourcesToCommandLines)\n            {\n                streamWriter.WriteLine(\"^\" + sourcesToCommandLine.Key);\n                streamWriter.WriteLine(ApplyPrecompareCommandFilter(sourcesToCommandLine.Value));\n            }\n        }\n", "        protected override int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands)\n        {\n            int num = 0;\n            if (EnableExecuteTool)\n            {\n                try\n                {\n                    num = TrackerExecuteTool(pathToTool, responseFileCommands, commandLineCommands);\n                }\n                finally\n                {\n                    PrintMessage(ParseLine(null), base.StandardOutputImportanceToUse);", "                    if (PostBuildTrackingCleanup)\n                    {\n                        num = PostExecuteTool(num);\n                    }\n                }\n            }\n            return num;\n        }\n\n        protected virtual int PostExecuteTool(int exitCode)\n        {", "        protected virtual int PostExecuteTool(int exitCode)\n        {\n            if (MinimalRebuildFromTracking || TrackFileAccess)\n            {\n                SourceOutputs = new CanonicalTrackedOutputFiles(TLogWriteFiles);\n                SourceDependencies = new CanonicalTrackedInputFiles(TLogReadFiles, TrackedInputFiles, ExcludedInputPaths, SourceOutputs, useMinimalRebuildOptimization: false, MaintainCompositeRootingMarkers);\n                string[] array = null;\n                IDictionary<string, string> dictionary = MapSourcesToCommandLines();\n                if (exitCode != 0)\n                {\n                    SourceOutputs.RemoveEntriesForSource(SourcesCompiled);\n                    SourceOutputs.SaveTlog();\n                    SourceDependencies.RemoveEntriesForSource(SourcesCompiled);\n                    SourceDependencies.SaveTlog();", "                if (exitCode != 0)\n                {\n                    SourceOutputs.RemoveEntriesForSource(SourcesCompiled);\n                    SourceOutputs.SaveTlog();\n                    SourceDependencies.RemoveEntriesForSource(SourcesCompiled);\n                    SourceDependencies.SaveTlog();\n                    if (TrackCommandLines)\n                    {\n                        if (MaintainCompositeRootingMarkers)\n                        {\n                            dictionary.Remove(RootSource);\n                        }\n                        else\n                        {\n                            ITaskItem[] array2 = SourcesCompiled;", "                        if (MaintainCompositeRootingMarkers)\n                        {\n                            dictionary.Remove(RootSource);\n                        }\n                        else\n                        {\n                            ITaskItem[] array2 = SourcesCompiled;\n                            foreach (ITaskItem source in array2)\n                            {\n                                dictionary.Remove(FileTracker.FormatRootingMarker(source));\n                            }\n                        }\n                        WriteSourcesToCommandLinesTable(dictionary);\n                    }\n                }\n                else\n                {\n                    AddTaskSpecificOutputs(SourcesCompiled, SourceOutputs);\n                    RemoveTaskSpecificOutputs(SourceOutputs);\n                    SourceOutputs.RemoveDependenciesFromEntryIfMissing(SourcesCompiled);", "                    if (MaintainCompositeRootingMarkers)\n                    {\n                        array = SourceOutputs.RemoveRootsWithSharedOutputs(SourcesCompiled);\n                        string[] array3 = array;\n                        foreach (string rootingMarker in array3)\n                        {\n                            SourceDependencies.RemoveEntryForSourceRoot(rootingMarker);\n                        }\n                    }\n                    if (TrackedOutputFilesToIgnore != null && TrackedOutputFilesToIgnore.Length != 0)\n                    {\n                        Dictionary<string, ITaskItem> trackedOutputFilesToRemove = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);\n                        ITaskItem[] array4 = TrackedOutputFilesToIgnore;", "                    if (TrackedOutputFilesToIgnore != null && TrackedOutputFilesToIgnore.Length != 0)\n                    {\n                        Dictionary<string, ITaskItem> trackedOutputFilesToRemove = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);\n                        ITaskItem[] array4 = TrackedOutputFilesToIgnore;\n                        foreach (ITaskItem taskItem in array4)\n                        {\n                            string key = taskItem.GetMetadata(\"FullPath\")/*.ToUpperInvariant()*/;\n                            if (!trackedOutputFilesToRemove.ContainsKey(key))\n                            {\n                                trackedOutputFilesToRemove.Add(key, taskItem);\n                            }\n                        }\n                        SourceOutputs.SaveTlog((string fullTrackedPath) => (!trackedOutputFilesToRemove.ContainsKey(fullTrackedPath/*.ToUpperInvariant()*/)) ? true : false);\n                    }\n                    else\n                    {\n                        SourceOutputs.SaveTlog();\n                    }\n                    DeleteEmptyFile(TLogWriteFiles);\n                    RemoveTaskSpecificInputs(SourceDependencies);\n                    SourceDependencies.RemoveDependenciesFromEntryIfMissing(SourcesCompiled);", "                    if (TrackedInputFilesToIgnore != null && TrackedInputFilesToIgnore.Length != 0)\n                    {\n                        Dictionary<string, ITaskItem> trackedInputFilesToRemove = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);\n                        ITaskItem[] array5 = TrackedInputFilesToIgnore;\n                        foreach (ITaskItem taskItem2 in array5)\n                        {\n                            string key2 = taskItem2.GetMetadata(\"FullPath\")/*.ToUpperInvariant()*/;\n                            if (!trackedInputFilesToRemove.ContainsKey(key2))\n                            {\n                                trackedInputFilesToRemove.Add(key2, taskItem2);\n                            }\n                        }\n                        SourceDependencies.SaveTlog((string fullTrackedPath) => (!trackedInputFilesToRemove.ContainsKey(fullTrackedPath)) ? true : false);\n                    }\n                    else\n                    {\n                        SourceDependencies.SaveTlog();\n                    }\n                    DeleteEmptyFile(TLogReadFiles);\n                    DeleteFiles(TLogDeleteFiles);", "                    if (TrackCommandLines)\n                    {\n                        if (MaintainCompositeRootingMarkers)\n                        {\n                            string value = GenerateCommandLine(CommandLineFormat.ForTracking);\n                            dictionary[RootSource] = value;\n                            if (array != null)\n                            {\n                                string[] array6 = array;\n                                foreach (string key3 in array6)\n                                {\n                                    dictionary.Remove(key3);\n                                }\n                            }\n                        }\n                        else\n                        {\n                            string text = SourcesPropertyName ?? \"Sources\";\n                            string text2 = GenerateCommandLineExceptSwitches(new string[1] { text }, CommandLineFormat.ForTracking);\n                            ITaskItem[] array7 = SourcesCompiled;", "                                foreach (string key3 in array6)\n                                {\n                                    dictionary.Remove(key3);\n                                }\n                            }\n                        }\n                        else\n                        {\n                            string text = SourcesPropertyName ?? \"Sources\";\n                            string text2 = GenerateCommandLineExceptSwitches(new string[1] { text }, CommandLineFormat.ForTracking);\n                            ITaskItem[] array7 = SourcesCompiled;", "                            foreach (ITaskItem taskItem3 in array7)\n                            {\n                                dictionary[FileTracker.FormatRootingMarker(taskItem3)] = text2 + \" \" + taskItem3.GetMetadata(\"FullPath\")/*.ToUpperInvariant()*/;\n                            }\n                        }\n                        WriteSourcesToCommandLinesTable(dictionary);\n                    }\n                }\n            }\n            return exitCode;\n        }\n", "        protected virtual void RemoveTaskSpecificOutputs(CanonicalTrackedOutputFiles compactOutputs)\n        {\n        }\n\n        protected virtual void RemoveTaskSpecificInputs(CanonicalTrackedInputFiles compactInputs)\n        {\n        }\n\n        protected virtual void AddTaskSpecificOutputs(ITaskItem[] sources, CanonicalTrackedOutputFiles compactOutputs)\n        {\n        }\n", "        protected virtual void AddTaskSpecificOutputs(ITaskItem[] sources, CanonicalTrackedOutputFiles compactOutputs)\n        {\n        }\n\n        protected override void LogPathToTool(string toolName, string pathToTool)\n        {\n            base.LogPathToTool(toolName, base.ResolvedPathToTool);\n        }\n\n        protected virtual void SaveTracking()\n        {\n            // \u5fae\u8f6f\u6ca1\u6709\u6b64\u51fd\u6570\uff0c\u81ea\u5df1\u91cd\u5199\u7684\u7248\u672c\uff0c\u4fdd\u5b58\u8ddf\u8e2a\u6587\u4ef6\uff0c\u589e\u91cf\u7f16\u8bd1\u4f7f\u7528\u3002\n        }\n", "        protected virtual void SaveTracking()\n        {\n            // \u5fae\u8f6f\u6ca1\u6709\u6b64\u51fd\u6570\uff0c\u81ea\u5df1\u91cd\u5199\u7684\u7248\u672c\uff0c\u4fdd\u5b58\u8ddf\u8e2a\u6587\u4ef6\uff0c\u589e\u91cf\u7f16\u8bd1\u4f7f\u7528\u3002\n        }\n\n        protected int TrackerExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands)\n        {\n            string dllName = null;\n            string text = null;\n            bool flag = TrackFileAccess;\n            string text2 = Environment.ExpandEnvironmentVariables(pathToTool);\n            string text3 = Environment.ExpandEnvironmentVariables(commandLineCommands);\n\n            // \u5fae\u8f6f\u7684\u65b9\u6848\u4e25\u91cd\u4e0d\u9002\u5408Linux\uff0c\u56e0\u4e3atracker\u4ec0\u4e48\u7684\u518dLinux\u7b49\u975eWindows \u5e73\u53f0\u90fd\u662f\u6ca1\u6709\u7684\u3002\n            // \u56e0\u6b64\u8fd9\u65b9\u9762\u91cd\u5199\u3002\n\n            var ErrorCode = base.ExecuteTool(text2, responseFileCommands, text3);\n", "            if(ErrorCode == 0 && (MinimalRebuildFromTracking || TrackFileAccess))\n            {\n                // \u5c06\u6570\u636e\u751f\u6210\u6570\u636e\u4f1a\u56de\u5199\u5230Write\u6587\u4ef6\u3002\n                SaveTracking();\n            }\n\n            return ErrorCode;\n#if __\n            try\n            {\n                string text4;", "                if (flag)\n                {\n                    ExecutableType result = ExecutableType.SameAsCurrentProcess;\n                    if (!string.IsNullOrEmpty(ToolArchitecture))\n                    {\n                        if (!Enum.TryParse<ExecutableType>(ToolArchitecture, out result))\n                        {\n                            base.Log.LogErrorWithCodeFromResources(\"General.InvalidValue\", \"ToolArchitecture\", GetType().Name);\n                            return -1;\n                        }\n                    }", "                    else if (ToolType.HasValue)\n                    {\n                        result = ToolType.Value;\n                    }\n                    if ((result == ExecutableType.Native32Bit || result == ExecutableType.Native64Bit) && Microsoft.Build.Shared.NativeMethodsShared.Is64bitApplication(text2, out var is64bit))\n                    {\n                        result = (is64bit ? ExecutableType.Native64Bit : ExecutableType.Native32Bit);\n                    }\n                    try\n                    {\n                        text4 = FileTracker.GetTrackerPath(result, TrackerSdkPath);", "                        if (text4 == null)\n                        {\n                            base.Log.LogErrorFromResources(\"Error.MissingFile\", \"tracker.exe\");\n                        }\n                    }\n                    catch (Exception e)\n                    {\n                        if (Microsoft.Build.Shared.ExceptionHandling.NotExpectedException(e))\n                        {\n                            throw;\n                        }\n                        base.Log.LogErrorWithCodeFromResources(\"General.InvalidValue\", \"TrackerSdkPath\", GetType().Name);\n                        return -1;\n                    }\n                    try\n                    {\n                        dllName = FileTracker.GetFileTrackerPath(result, TrackerFrameworkPath);\n                    }", "                    catch (Exception e2)\n                    {\n                        if (Microsoft.Build.Shared.ExceptionHandling.NotExpectedException(e2))\n                        {\n                            throw;\n                        }\n                        base.Log.LogErrorWithCodeFromResources(\"General.InvalidValue\", \"TrackerFrameworkPath\", GetType().Name);\n                        return -1;\n                    }\n                }\n                else\n                {\n                    text4 = text2;\n                }", "                if (!string.IsNullOrEmpty(text4))\n                {\n                    Microsoft.Build.Shared.ErrorUtilities.VerifyThrowInternalRooted(text4);\n                    string commandLineCommands2;\n                    if (flag)\n                    {\n                        string text5 = FileTracker.TrackerArguments(text2, text3, dllName, TrackerIntermediateDirectory, RootSource, base.CancelEventName);\n                        base.Log.LogMessageFromResources(MessageImportance.Low, \"Native_TrackingCommandMessage\");\n                        string message = text4 + (AttributeFileTracking ? \" /a \" : \" \") + (TrackReplaceFile ? \"/f \" : \"\") + text5 + \" \" + responseFileCommands;\n                        base.Log.LogMessage(MessageImportance.Low, message);\n                        text = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();", "                        using (StreamWriter streamWriter = new StreamWriter(text, append: false, Encoding.Unicode))\n                        {\n                            streamWriter.Write(FileTracker.TrackerResponseFileArguments(dllName, TrackerIntermediateDirectory, RootSource, base.CancelEventName));\n                        }\n                        commandLineCommands2 = (AttributeFileTracking ? \"/a @\\\"\" : \"@\\\"\") + text + \"\\\"\" + (TrackReplaceFile ? \" /f \" : \"\") + FileTracker.TrackerCommandArguments(text2, text3);\n                    }\n                    else\n                    {\n                        commandLineCommands2 = text3;\n                    }\n                    return base.ExecuteTool(text4, responseFileCommands, commandLineCommands2);\n                }\n                return -1;\n            }\n            finally\n            {", "                if (text != null)\n                {\n                    DeleteTempFile(text);\n                }\n            }\n#endif\n        }\n\n        protected override void ProcessStarted()\n        {\n        }\n", "        protected override void ProcessStarted()\n        {\n        }\n\n        public virtual string ApplyPrecompareCommandFilter(string value)\n        {\n            return extraNewlineRegex.Replace(value, \"$2\");\n        }\n\n        public static string RemoveSwitchFromCommandLine(string removalWord, string cmdString, bool removeMultiple = false)\n        {\n            int num = 0;", "        public static string RemoveSwitchFromCommandLine(string removalWord, string cmdString, bool removeMultiple = false)\n        {\n            int num = 0;\n            while ((num = cmdString.IndexOf(removalWord, num, StringComparison.Ordinal)) >= 0)\n            {\n                if (num == 0 || cmdString[num - 1] == ' ')\n                {\n                    int num2 = cmdString.IndexOf(' ', num);\n                    if (num2 >= 0)\n                    {\n                        num2++;\n                    }\n                    else\n                    {\n                        num2 = cmdString.Length;\n                        num--;\n                    }\n                    cmdString = cmdString.Remove(num, num2 - num);", "                    if (num2 >= 0)\n                    {\n                        num2++;\n                    }\n                    else\n                    {\n                        num2 = cmdString.Length;\n                        num--;\n                    }\n                    cmdString = cmdString.Remove(num, num2 - num);\n                    if (!removeMultiple)\n                    {\n                        break;\n                    }\n                }\n                num++;", "                    if (!removeMultiple)\n                    {\n                        break;\n                    }\n                }\n                num++;\n                if (num >= cmdString.Length)\n                {\n                    break;\n                }\n            }\n            return cmdString;\n        }\n", "        protected static int DeleteFiles(ITaskItem[] filesToDelete)\n        {\n            if (filesToDelete == null)\n            {\n                return 0;\n            }\n            ITaskItem[] array = TrackedDependencies.ExpandWildcards(filesToDelete);\n            if (array.Length == 0)\n            {\n                return 0;\n            }\n            int num = 0;\n            ITaskItem[] array2 = array;", "            foreach (ITaskItem taskItem in array2)\n            {\n                try\n                {\n                    FileInfo fileInfo = new FileInfo(taskItem.ItemSpec);\n                    if (fileInfo.Exists)\n                    {\n                        fileInfo.Delete();\n                        num++;\n                    }\n                }", "                catch (Exception ex)\n                {\n                    if (ex is SecurityException || ex is ArgumentException || ex is UnauthorizedAccessException || ex is PathTooLongException || ex is NotSupportedException)\n                    {\n                        continue;\n                    }\n                    throw;\n                }\n            }\n            return num;\n        }\n", "        protected static int DeleteEmptyFile(ITaskItem[] filesToDelete)\n        {\n            if (filesToDelete == null)\n            {\n                return 0;\n            }\n            ITaskItem[] array = TrackedDependencies.ExpandWildcards(filesToDelete);\n            if (array.Length == 0)\n            {\n                return 0;\n            }\n            int num = 0;\n            ITaskItem[] array2 = array;", "            foreach (ITaskItem taskItem in array2)\n            {\n                bool flag = false;\n                try\n                {\n                    FileInfo fileInfo = new FileInfo(taskItem.ItemSpec);\n                    if (fileInfo.Exists)\n                    {\n                        if (fileInfo.Length <= 4)\n                        {\n                            flag = true;\n                        }", "                        if (fileInfo.Length <= 4)\n                        {\n                            flag = true;\n                        }\n                        if (flag)\n                        {\n                            fileInfo.Delete();\n                            num++;\n                        }\n                    }\n                }", "                catch (Exception ex)\n                {\n                    if (ex is SecurityException || ex is ArgumentException || ex is UnauthorizedAccessException || ex is PathTooLongException || ex is NotSupportedException)\n                    {\n                        continue;\n                    }\n                    throw;\n                }\n            }\n            return num;\n        }\n    }\n\n}\n"]}
{"filename": "Microsoft.Build.CPPTasks/PropertyRelation.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Microsoft.Build.CPPTasks\n{\n    public class PropertyRelation\n    {\n        public string Argument { get; set; }\n\n        public string Value { get; set; }\n", "        public string Argument { get; set; }\n\n        public string Value { get; set; }\n\n        public bool Required { get; set; }\n\n        public PropertyRelation()\n        {\n        }\n\n        public PropertyRelation(string argument, string value, bool required)\n        {\n            Argument = argument;\n            Value = value;\n            Required = required;\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.CPPTasks/VCToolTask.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Resources;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing Microsoft.Build.CPPTasks;\nusing Microsoft.Build.Framework;", "using Microsoft.Build.CPPTasks;\nusing Microsoft.Build.Framework;\nusing Microsoft.Build.Shared;\nusing Microsoft.Build.Utilities;\n\nnamespace Microsoft.Build.CPPTasks\n{\n    public abstract class VCToolTask : ToolTask\n    {\n        public enum CommandLineFormat\n        {\n            ForBuildLog,\n            ForTracking\n        }\n\n        [Flags]", "        public enum CommandLineFormat\n        {\n            ForBuildLog,\n            ForTracking\n        }\n\n        [Flags]\n        public enum EscapeFormat\n        {\n            Default = 0,\n            EscapeTrailingSlash = 1\n        }\n", "        protected class MessageStruct\n        {\n            public string Category { get; set; } = \"\";\n\n\n            public string SubCategory { get; set; } = \"\";\n\n\n            public string Code { get; set; } = \"\";\n\n", "            public string Code { get; set; } = \"\";\n\n\n            public string Filename { get; set; } = \"\";\n\n\n            public int Line { get; set; }\n\n            public int Column { get; set; }\n\n            public string Text { get; set; } = \"\";\n\n", "            public int Column { get; set; }\n\n            public string Text { get; set; } = \"\";\n\n\n            public void Clear()\n            {\n                Category = \"\";\n                SubCategory = \"\";\n                Code = \"\";\n                Filename = \"\";\n                Line = 0;\n                Column = 0;\n                Text = \"\";\n            }\n", "            public static void Swap(ref MessageStruct lhs, ref MessageStruct rhs)\n            {\n                MessageStruct messageStruct = lhs;\n                lhs = rhs;\n                rhs = messageStruct;\n            }\n        }\n\n        private Dictionary<string, ToolSwitch> activeToolSwitchesValues = new Dictionary<string, ToolSwitch>();\n\n#if __REMOVE", "        private IntPtr cancelEvent;\n\n        private string cancelEventName;\n#endif\n\n        private bool fCancelled;\n\n        private Dictionary<string, ToolSwitch> activeToolSwitches = new Dictionary<string, ToolSwitch>(StringComparer.OrdinalIgnoreCase);\n\n        private Dictionary<string, Dictionary<string, string>> values = new Dictionary<string, Dictionary<string, string>>(StringComparer.OrdinalIgnoreCase);\n", "        private string additionalOptions = string.Empty;\n\n        private char prefix = '/';\n\n        private TaskLoggingHelper logPrivate;\n\n        protected List<Regex> errorListRegexList = new List<Regex>();\n\n        protected List<Regex> errorListRegexListExclusion = new List<Regex>();\n\n        protected MessageStruct lastMS = new MessageStruct();\n", "        protected MessageStruct lastMS = new MessageStruct();\n\n        protected MessageStruct currentMS = new MessageStruct();\n\n        protected Dictionary<string, ToolSwitch> ActiveToolSwitches => activeToolSwitches;\n\n        protected static Regex FindBackSlashInPath { get; } = new Regex(\"(?<=[^\\\\\\\\])\\\\\\\\(?=[^\\\\\\\\\\\\\\\"\\\\s])|(\\\\\\\\(?=[^\\\\\\\"]))|((?<=[^\\\\\\\\][\\\\\\\\])\\\\\\\\(?=[\\\\\\\"]))\", RegexOptions.Compiled);\n\n\n        public string AdditionalOptions\n        {\n            get\n            {\n                return additionalOptions;\n            }\n            set\n            {\n                additionalOptions = TranslateAdditionalOptions(value);\n            }\n        }\n", "        public string AdditionalOptions\n        {\n            get\n            {\n                return additionalOptions;\n            }\n            set\n            {\n                additionalOptions = TranslateAdditionalOptions(value);\n            }\n        }\n", "        public bool UseMsbuildResourceManager { get; set; }\n\n#if __REMOVE\n        protected override Encoding ResponseFileEncoding => Encoding.Unicode;\n#else\n        // Linux\u4e0b\u6587\u4ef6\u666e\u904d\u91c7\u7528\u6ca1\u6587\u4ef6\u5934\u7684UTF8\uff0c\u5426\u5219\u5bb9\u6613\u5f15\u5165\u517c\u5bb9\u6027\u95ee\u9898\u3002\n        private UTF8Encoding UTF8NoBom = new UTF8Encoding(false);\n        protected override Encoding ResponseFileEncoding => UTF8NoBom;\n#endif\n\n        protected virtual ArrayList SwitchOrderList => null;\n\n#if __REMOVE", "        protected virtual ArrayList SwitchOrderList => null;\n\n#if __REMOVE\n        protected string CancelEventName => cancelEventName;\n#endif\n\n        protected TaskLoggingHelper LogPrivate => logPrivate;\n\n        protected override MessageImportance StandardOutputLoggingImportance => MessageImportance.High;\n\n        protected override MessageImportance StandardErrorLoggingImportance => MessageImportance.High;\n", "        protected override MessageImportance StandardOutputLoggingImportance => MessageImportance.High;\n\n        protected override MessageImportance StandardErrorLoggingImportance => MessageImportance.High;\n\n        protected virtual string AlwaysAppend\n        {\n            get\n            {\n                return string.Empty;\n            }\n            set\n            {\n            }\n        }\n\n        public ITaskItem[] ErrorListRegex\n        {\n            set\n            {", "                foreach (ITaskItem taskItem in value)\n                {\n                    errorListRegexList.Add(new Regex(taskItem.ItemSpec, RegexOptions.IgnoreCase | RegexOptions.Compiled, TimeSpan.FromMilliseconds(100.0)));\n                }\n            }\n        }\n\n        public ITaskItem[] ErrorListListExclusion\n        {\n            set\n            {", "                foreach (ITaskItem taskItem in value)\n                {\n                    errorListRegexListExclusion.Add(new Regex(taskItem.ItemSpec, RegexOptions.IgnoreCase | RegexOptions.Compiled, TimeSpan.FromMilliseconds(100.0)));\n                }\n            }\n        }\n\n        public bool EnableErrorListRegex { get; set; } = true;\n\n\n        public bool ForceSinglelineErrorListRegex { get; set; }\n", "        public bool ForceSinglelineErrorListRegex { get; set; }\n\n        public virtual string[] AcceptableNonzeroExitCodes { get; set; }\n\n        public Dictionary<string, ToolSwitch> ActiveToolSwitchesValues\n        {\n            get\n            {\n                return activeToolSwitchesValues;\n            }\n            set\n            {\n                activeToolSwitchesValues = value;\n            }\n        }\n", "        public string EffectiveWorkingDirectory { get; set; }\n\n        [Output]\n        public string ResolvedPathToTool { get; protected set; }\n\n        protected bool IgnoreUnknownSwitchValues { get; set; }\n\n        protected VCToolTask(ResourceManager taskResources)\n            : base(taskResources)\n        {\n#if __REMOVE\n            cancelEventName = \"MSBuildConsole_CancelEvent\" + Guid.NewGuid().ToString(\"N\");\n            cancelEvent = VCTaskNativeMethods.CreateEventW(IntPtr.Zero, bManualReset: false, bInitialState: false, cancelEventName);\n#endif\n            fCancelled = false;\n            logPrivate = new TaskLoggingHelper(this);\n#if __REMOVE\n            logPrivate.TaskResources = Microsoft.Build.Shared.AssemblyResources.PrimaryResources;\n#endif\n            logPrivate.HelpKeywordPrefix = \"MSBuild.\";\n            IgnoreUnknownSwitchValues = false;\n        }\n", "        protected virtual string TranslateAdditionalOptions(string options)\n        {\n            return options;\n        }\n\n        protected override string GetWorkingDirectory()\n        {\n            return EffectiveWorkingDirectory;\n        }\n\n        protected override string GenerateFullPathToTool()\n        {\n            return ToolName;\n        }\n", "        protected override string GenerateFullPathToTool()\n        {\n            return ToolName;\n        }\n\n        protected override bool ValidateParameters()\n        {\n            if (!logPrivate.HasLoggedErrors)\n            {\n                return !base.Log.HasLoggedErrors;\n            }\n            return false;\n        }\n", "        public string GenerateCommandLine(CommandLineFormat format = CommandLineFormat.ForBuildLog, EscapeFormat escapeFormat = EscapeFormat.Default)\n        {\n            string text = GenerateCommandLineCommands(format, escapeFormat);\n            string text2 = GenerateResponseFileCommands(format, escapeFormat);\n            if (!string.IsNullOrEmpty(text))\n            {\n                return text + \" \" + text2;\n            }\n            return text2;\n        }\n", "        public string GenerateCommandLineExceptSwitches(string[] switchesToRemove, CommandLineFormat format = CommandLineFormat.ForBuildLog, EscapeFormat escapeFormat = EscapeFormat.Default)\n        {\n            string text = GenerateCommandLineCommandsExceptSwitches(switchesToRemove, format, escapeFormat);\n            string text2 = GenerateResponseFileCommandsExceptSwitches(switchesToRemove, format, escapeFormat);\n            if (!string.IsNullOrEmpty(text))\n            {\n                return text + \" \" + text2;\n            }\n            return text2;\n        }\n", "        protected virtual string GenerateCommandLineCommandsExceptSwitches(string[] switchesToRemove, CommandLineFormat format = CommandLineFormat.ForBuildLog, EscapeFormat escapeFormat = EscapeFormat.Default)\n        {\n            return string.Empty;\n        }\n\n        protected override string GenerateResponseFileCommands()\n        {\n            return GenerateResponseFileCommands(CommandLineFormat.ForBuildLog, EscapeFormat.Default);\n        }\n\n        protected virtual string GenerateResponseFileCommands(CommandLineFormat format, EscapeFormat escapeFormat)\n        {\n            return GenerateResponseFileCommandsExceptSwitches(new string[0], format, escapeFormat);\n        }\n", "        protected virtual string GenerateResponseFileCommands(CommandLineFormat format, EscapeFormat escapeFormat)\n        {\n            return GenerateResponseFileCommandsExceptSwitches(new string[0], format, escapeFormat);\n        }\n\n        protected override string GenerateCommandLineCommands()\n        {\n            return GenerateCommandLineCommands(CommandLineFormat.ForBuildLog, EscapeFormat.Default);\n        }\n\n        protected virtual string GenerateCommandLineCommands(CommandLineFormat format, EscapeFormat escapeFormat)\n        {\n            return GenerateCommandLineCommandsExceptSwitches(new string[0], format, escapeFormat);\n        }\n", "        protected virtual string GenerateCommandLineCommands(CommandLineFormat format, EscapeFormat escapeFormat)\n        {\n            return GenerateCommandLineCommandsExceptSwitches(new string[0], format, escapeFormat);\n        }\n\n        protected virtual bool GenerateCostomCommandsAccordingToType(CommandLineBuilder builder, string switchName, bool dummyForBackwardCompatibility, CommandLineFormat format = CommandLineFormat.ForBuildLog, EscapeFormat escapeFormat = EscapeFormat.Default)\n        {\n            return false;\n        }\n\n        protected virtual string GenerateResponseFileCommandsExceptSwitches(string[] switchesToRemove, CommandLineFormat format = CommandLineFormat.ForBuildLog, EscapeFormat escapeFormat = EscapeFormat.Default)\n        {\n            bool flag = false;\n            AddDefaultsToActiveSwitchList();\n            AddFallbacksToActiveSwitchList();\n            PostProcessSwitchList();\n            CommandLineBuilder commandLineBuilder = new CommandLineBuilder(quoteHyphensOnCommandLine: true);", "        protected virtual string GenerateResponseFileCommandsExceptSwitches(string[] switchesToRemove, CommandLineFormat format = CommandLineFormat.ForBuildLog, EscapeFormat escapeFormat = EscapeFormat.Default)\n        {\n            bool flag = false;\n            AddDefaultsToActiveSwitchList();\n            AddFallbacksToActiveSwitchList();\n            PostProcessSwitchList();\n            CommandLineBuilder commandLineBuilder = new CommandLineBuilder(quoteHyphensOnCommandLine: true);\n            foreach (string switchOrder in SwitchOrderList)\n            {\n                if (GenerateCostomCommandsAccordingToType(commandLineBuilder, switchOrder, dummyForBackwardCompatibility: false, format, escapeFormat))\n                {\n                    // \u5df2\u7ecf\u5904\u7406\n                }", "                if (GenerateCostomCommandsAccordingToType(commandLineBuilder, switchOrder, dummyForBackwardCompatibility: false, format, escapeFormat))\n                {\n                    // \u5df2\u7ecf\u5904\u7406\n                }\n                else if(IsPropertySet(switchOrder))\n                {\n                    ToolSwitch toolSwitch = activeToolSwitches[switchOrder];\n                    if (!VerifyDependenciesArePresent(toolSwitch) || !VerifyRequiredArgumentsArePresent(toolSwitch, throwOnError: false))\n                    {\n                        continue;\n                    }\n                    bool flag2 = true;", "                    if (switchesToRemove != null)\n                    {\n                        foreach (string value in switchesToRemove)\n                        {\n                            if (switchOrder.Equals(value, StringComparison.OrdinalIgnoreCase))\n                            {\n                                flag2 = false;\n                                break;\n                            }\n                        }\n                    }", "                    if (flag2 && !IsArgument(toolSwitch))\n                    {\n                        GenerateCommandsAccordingToType(commandLineBuilder, toolSwitch, dummyForBackwardCompatibility: false, format, escapeFormat);\n                    }\n                } \n                else if (string.Equals(switchOrder, \"additionaloptions\", StringComparison.OrdinalIgnoreCase))\n                {\n                    BuildAdditionalArgs(commandLineBuilder);\n                    flag = true;\n                }\n                else if (string.Equals(switchOrder, \"AlwaysAppend\", StringComparison.OrdinalIgnoreCase))\n                {\n                    commandLineBuilder.AppendSwitch(AlwaysAppend);\n                }\n            }", "                else if (string.Equals(switchOrder, \"AlwaysAppend\", StringComparison.OrdinalIgnoreCase))\n                {\n                    commandLineBuilder.AppendSwitch(AlwaysAppend);\n                }\n            }\n            if (!flag)\n            {\n                BuildAdditionalArgs(commandLineBuilder);\n            }\n            return commandLineBuilder.ToString();\n        }\n", "        protected override bool HandleTaskExecutionErrors()\n        {\n            if (IsAcceptableReturnValue())\n            {\n                return true;\n            }\n            return base.HandleTaskExecutionErrors();\n        }\n\n        public override bool Execute()\n        {", "        public override bool Execute()\n        {\n            if (fCancelled)\n            {\n                return false;\n            }\n            bool result = base.Execute();\n#if __REMOVE\n            VCTaskNativeMethods.CloseHandle(cancelEvent);\n#endif\n            PrintMessage(ParseLine(null), base.StandardOutputImportanceToUse);\n            return result;\n        }\n", "        protected override int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands)\n        {\n#if __REMOVE\n#else\n            // \u7531\u4e8e\u521b\u5efa\u54cd\u5e94\u6587\u4ef6\u901f\u5ea6\u9700\u8981\u989d\u5916IO\uff0c\u6240\u4ee5\u6211\u4eec\u7279\u522b\u5224\u65ad\uff0c\u5982\u679c\u547d\u4ee4\u884c\u603b\u957f\u5ea6\u5c0f\u4e8e2048(Linux\u652f\u63012048\u957f\u5ea6\u95ee\u9898\u4e0d\u5927)\u5219\u4e0d\u521b\u5efa\u54cd\u5e94\u6587\u4ef6\u4e86\u3002\n            if(responseFileCommands.Length != 0 && responseFileCommands.Length + commandLineCommands.Length + 1 < 2048)\n            {\n                if(commandLineCommands.Length != 0)\n                {\n                    commandLineCommands += ' ';\n                    commandLineCommands += responseFileCommands;\n                }\n                else\n                {\n                    commandLineCommands = responseFileCommands;\n                }\n\n                responseFileCommands = \"\";\n            }\n#endif\n\n            ResolvedPathToTool = Environment.ExpandEnvironmentVariables(pathToTool);\n            return base.ExecuteTool(pathToTool, responseFileCommands, commandLineCommands);\n        }\n", "        public override void Cancel()\n        {\n            fCancelled = true;\n#if __REMOVE\n            VCTaskNativeMethods.SetEvent(cancelEvent);\n#endif\n            base.Cancel();\n        }\n\n        protected bool VerifyRequiredArgumentsArePresent(ToolSwitch property, bool throwOnError)\n        {", "        protected bool VerifyRequiredArgumentsArePresent(ToolSwitch property, bool throwOnError)\n        {\n            if (property.ArgumentRelationList != null)\n            {\n                foreach (ArgumentRelation argumentRelation in property.ArgumentRelationList)\n                {\n                    if (argumentRelation.Required && (property.Value == argumentRelation.Value || argumentRelation.Value == string.Empty) && !HasSwitch(argumentRelation.Argument))\n                    {\n                        string text = \"\";\n                        text = ((!(string.Empty == argumentRelation.Value)) ? base.Log.FormatResourceString(\"MissingRequiredArgumentWithValue\", argumentRelation.Argument, property.Name, argumentRelation.Value) : base.Log.FormatResourceString(\"MissingRequiredArgument\", argumentRelation.Argument, property.Name));\n                        base.Log.LogError(text);", "                        if (throwOnError)\n                        {\n                            throw new LoggerException(text);\n                        }\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n", "        protected bool IsAcceptableReturnValue()\n        {\n            return IsAcceptableReturnValue(base.ExitCode);\n        }\n\n        protected bool IsAcceptableReturnValue(int code)\n        {\n            if (AcceptableNonzeroExitCodes != null)\n            {\n                string[] acceptableNonzeroExitCodes = AcceptableNonzeroExitCodes;\n                foreach (string value in acceptableNonzeroExitCodes)\n                {", "                foreach (string value in acceptableNonzeroExitCodes)\n                {\n                    if (code == Convert.ToInt32(value, CultureInfo.InvariantCulture))\n                    {\n                        return true;\n                    }\n                }\n            }\n            return code == 0;\n        }\n", "        protected void RemoveSwitchToolBasedOnValue(string switchValue)\n        {\n            if (ActiveToolSwitchesValues.Count > 0 && ActiveToolSwitchesValues.ContainsKey(\"/\" + switchValue))\n            {\n                ToolSwitch toolSwitch = ActiveToolSwitchesValues[\"/\" + switchValue];\n                if (toolSwitch != null)\n                {\n                    ActiveToolSwitches.Remove(toolSwitch.Name);\n                }\n            }\n        }\n", "        protected void AddActiveSwitchToolValue(ToolSwitch switchToAdd)\n        {\n            if (switchToAdd.Type != 0 || switchToAdd.BooleanValue)\n            {\n                if (switchToAdd.SwitchValue != string.Empty)\n                {\n                    ActiveToolSwitchesValues.Add(switchToAdd.SwitchValue, switchToAdd);\n                }\n            }\n            else if (switchToAdd.ReverseSwitchValue != string.Empty)\n            {\n                ActiveToolSwitchesValues.Add(switchToAdd.ReverseSwitchValue, switchToAdd);\n            }\n        }\n", "            else if (switchToAdd.ReverseSwitchValue != string.Empty)\n            {\n                ActiveToolSwitchesValues.Add(switchToAdd.ReverseSwitchValue, switchToAdd);\n            }\n        }\n\n        protected string GetEffectiveArgumentsValues(ToolSwitch property, CommandLineFormat format = CommandLineFormat.ForBuildLog)\n        {\n            StringBuilder stringBuilder = new StringBuilder();\n            bool flag = false;\n            string text = string.Empty;", "            if (property.ArgumentRelationList != null)\n            {\n                foreach (ArgumentRelation argumentRelation in property.ArgumentRelationList)\n                {\n                    if (text != string.Empty && text != argumentRelation.Argument)\n                    {\n                        flag = true;\n                    }\n                    text = argumentRelation.Argument;\n                    if ((property.Value == argumentRelation.Value || argumentRelation.Value == string.Empty || (property.Type == ToolSwitchType.Boolean && property.BooleanValue)) && HasSwitch(argumentRelation.Argument))\n                    {\n                        ToolSwitch toolSwitch = ActiveToolSwitches[argumentRelation.Argument];\n                        stringBuilder.Append(argumentRelation.Separator);\n                        CommandLineBuilder commandLineBuilder = new CommandLineBuilder();\n                        GenerateCommandsAccordingToType(commandLineBuilder, toolSwitch, dummyForBackwardCompatibility: true, format);\n                        stringBuilder.Append(commandLineBuilder.ToString());\n                    }\n                }\n            }\n            CommandLineBuilder commandLineBuilder2 = new CommandLineBuilder();", "                    if ((property.Value == argumentRelation.Value || argumentRelation.Value == string.Empty || (property.Type == ToolSwitchType.Boolean && property.BooleanValue)) && HasSwitch(argumentRelation.Argument))\n                    {\n                        ToolSwitch toolSwitch = ActiveToolSwitches[argumentRelation.Argument];\n                        stringBuilder.Append(argumentRelation.Separator);\n                        CommandLineBuilder commandLineBuilder = new CommandLineBuilder();\n                        GenerateCommandsAccordingToType(commandLineBuilder, toolSwitch, dummyForBackwardCompatibility: true, format);\n                        stringBuilder.Append(commandLineBuilder.ToString());\n                    }\n                }\n            }\n            CommandLineBuilder commandLineBuilder2 = new CommandLineBuilder();", "            if (flag)\n            {\n                commandLineBuilder2.AppendSwitchIfNotNull(\"\", stringBuilder.ToString());\n            }\n            else\n            {\n                commandLineBuilder2.AppendSwitchUnquotedIfNotNull(\"\", stringBuilder.ToString());\n            }\n            return commandLineBuilder2.ToString();\n        }\n", "        protected virtual void PostProcessSwitchList()\n        {\n            ValidateRelations();\n            ValidateOverrides();\n        }\n\n        protected virtual void ValidateRelations()\n        {\n        }\n\n        protected virtual void ValidateOverrides()\n        {\n            List<string> list = new List<string>();", "        protected virtual void ValidateOverrides()\n        {\n            List<string> list = new List<string>();\n            foreach (KeyValuePair<string, ToolSwitch> activeToolSwitch in ActiveToolSwitches)\n            {\n                foreach (KeyValuePair<string, string> @override in activeToolSwitch.Value.Overrides)\n                {\n                    if (!string.Equals(@override.Key, (activeToolSwitch.Value.Type == ToolSwitchType.Boolean && !activeToolSwitch.Value.BooleanValue) ? activeToolSwitch.Value.ReverseSwitchValue.TrimStart('/') : activeToolSwitch.Value.SwitchValue.TrimStart('/'), StringComparison.OrdinalIgnoreCase))\n                    {\n                        continue;\n                    }", "                    foreach (KeyValuePair<string, ToolSwitch> activeToolSwitch2 in ActiveToolSwitches)\n                    {\n                        if (!string.Equals(activeToolSwitch2.Key, activeToolSwitch.Key, StringComparison.OrdinalIgnoreCase))\n                        {\n                            if (string.Equals(activeToolSwitch2.Value.SwitchValue.TrimStart('/'), @override.Value, StringComparison.OrdinalIgnoreCase))\n                            {\n                                list.Add(activeToolSwitch2.Key);\n                                break;\n                            }\n                            if (activeToolSwitch2.Value.Type == ToolSwitchType.Boolean && !activeToolSwitch2.Value.BooleanValue && string.Equals(activeToolSwitch2.Value.ReverseSwitchValue.TrimStart('/'), @override.Value, StringComparison.OrdinalIgnoreCase))\n                            {\n                                list.Add(activeToolSwitch2.Key);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }", "                            if (activeToolSwitch2.Value.Type == ToolSwitchType.Boolean && !activeToolSwitch2.Value.BooleanValue && string.Equals(activeToolSwitch2.Value.ReverseSwitchValue.TrimStart('/'), @override.Value, StringComparison.OrdinalIgnoreCase))\n                            {\n                                list.Add(activeToolSwitch2.Key);\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            foreach (string item in list)\n            {\n                ActiveToolSwitches.Remove(item);\n            }\n        }\n", "            foreach (string item in list)\n            {\n                ActiveToolSwitches.Remove(item);\n            }\n        }\n\n        protected bool IsSwitchValueSet(string switchValue)\n        {\n            if (!string.IsNullOrEmpty(switchValue))\n            {\n                return ActiveToolSwitchesValues.ContainsKey(\"/\" + switchValue);\n            }\n            return false;\n        }\n", "            if (!string.IsNullOrEmpty(switchValue))\n            {\n                return ActiveToolSwitchesValues.ContainsKey(\"/\" + switchValue);\n            }\n            return false;\n        }\n\n        protected virtual bool VerifyDependenciesArePresent(ToolSwitch value)\n        {\n            if (value.Parents.Count > 0)\n            {\n                bool flag = false;\n                {", "            if (value.Parents.Count > 0)\n            {\n                bool flag = false;\n                {\n                    foreach (string parent in value.Parents)\n                    {\n                        flag = flag || HasDirectSwitch(parent);\n                    }\n                    return flag;\n                }\n            }\n            return true;\n        }\n", "        protected virtual void AddDefaultsToActiveSwitchList()\n        {\n        }\n\n        protected virtual void AddFallbacksToActiveSwitchList()\n        {\n        }\n\n        protected virtual void GenerateCommandsAccordingToType(CommandLineBuilder builder, ToolSwitch toolSwitch, bool dummyForBackwardCompatibility, CommandLineFormat format = CommandLineFormat.ForBuildLog, EscapeFormat escapeFormat = EscapeFormat.Default)\n        {\n            GenerateCommandsAccordingToType(builder, toolSwitch, format, escapeFormat);\n        }\n", "        protected virtual void GenerateCommandsAccordingToType(CommandLineBuilder builder, ToolSwitch toolSwitch, bool dummyForBackwardCompatibility, CommandLineFormat format = CommandLineFormat.ForBuildLog, EscapeFormat escapeFormat = EscapeFormat.Default)\n        {\n            GenerateCommandsAccordingToType(builder, toolSwitch, format, escapeFormat);\n        }\n\n        protected virtual void GenerateCommandsAccordingToType(CommandLineBuilder builder, ToolSwitch toolSwitch, CommandLineFormat format = CommandLineFormat.ForBuildLog, EscapeFormat escapeFormat = EscapeFormat.Default)\n        {\n            try\n            {\n                switch (toolSwitch.Type)\n                {\n                    case ToolSwitchType.Boolean:\n                        EmitBooleanSwitch(builder, toolSwitch, format);\n                        break;\n                    case ToolSwitchType.String:\n                        EmitStringSwitch(builder, toolSwitch);\n                        break;\n                    case ToolSwitchType.StringArray:\n                        EmitStringArraySwitch(builder, toolSwitch);\n                        break;\n                    case ToolSwitchType.StringPathArray:\n                        EmitStringArraySwitch(builder, toolSwitch, format, escapeFormat);\n                        break;\n                    case ToolSwitchType.Integer:\n                        EmitIntegerSwitch(builder, toolSwitch);\n                        break;\n                    case ToolSwitchType.File:\n                        EmitFileSwitch(builder, toolSwitch, format);\n                        break;\n                    case ToolSwitchType.Directory:\n                        EmitDirectorySwitch(builder, toolSwitch, format);\n                        break;\n                    case ToolSwitchType.ITaskItem:\n                        EmitTaskItemSwitch(builder, toolSwitch);\n                        break;\n                    case ToolSwitchType.ITaskItemArray:\n                        EmitTaskItemArraySwitch(builder, toolSwitch, format);\n                        break;\n                    case ToolSwitchType.AlwaysAppend:\n                        EmitAlwaysAppendSwitch(builder, toolSwitch);\n                        break;\n                    default:\n                        Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(condition: false, \"InternalError\");\n                        break;\n                }\n            }", "            catch (Exception ex)\n            {\n                base.Log.LogErrorFromResources(\"GenerateCommandLineError\", toolSwitch.Name, toolSwitch.ValueAsString, ex.Message);\n                ex.RethrowIfCritical();\n            }\n        }\n\n        protected void BuildAdditionalArgs(CommandLineBuilder cmdLine)\n        {\n            if (cmdLine != null && !string.IsNullOrEmpty(additionalOptions))\n            {\n                cmdLine.AppendSwitch(Environment.ExpandEnvironmentVariables(additionalOptions));\n            }\n        }\n", "            if (cmdLine != null && !string.IsNullOrEmpty(additionalOptions))\n            {\n                cmdLine.AppendSwitch(Environment.ExpandEnvironmentVariables(additionalOptions));\n            }\n        }\n\n        protected bool ValidateInteger(string switchName, int min, int max, int value)\n        {\n            if (value < min || value > max)\n            {\n                logPrivate.LogErrorFromResources(\"ArgumentOutOfRange\", switchName, value);\n                return false;\n            }\n            return true;\n        }\n", "            if (value < min || value > max)\n            {\n                logPrivate.LogErrorFromResources(\"ArgumentOutOfRange\", switchName, value);\n                return false;\n            }\n            return true;\n        }\n\n        protected string ReadSwitchMap(string propertyName, string[][] switchMap, string value)\n        {\n            if (switchMap != null)\n            {", "        protected string ReadSwitchMap(string propertyName, string[][] switchMap, string value)\n        {\n            if (switchMap != null)\n            {\n                for (int i = 0; i < switchMap.Length; i++)\n                {\n                    if (string.Equals(switchMap[i][0], value, StringComparison.CurrentCultureIgnoreCase))\n                    {\n                        return switchMap[i][1];\n                    }\n                }", "                if (!IgnoreUnknownSwitchValues)\n                {\n                    logPrivate.LogErrorFromResources(\"ArgumentOutOfRange\", propertyName, value);\n                }\n            }\n            return string.Empty;\n        }\n\n        protected bool IsPropertySet(string propertyName)\n        {\n            return activeToolSwitches.ContainsKey(propertyName);\n        }\n", "        protected bool IsPropertySet(string propertyName)\n        {\n            return activeToolSwitches.ContainsKey(propertyName);\n        }\n\n        protected bool IsSetToTrue(string propertyName)\n        {\n            if (activeToolSwitches.ContainsKey(propertyName))\n            {\n                return activeToolSwitches[propertyName].BooleanValue;\n            }\n            return false;\n        }\n", "        protected bool IsExplicitlySetToFalse(string propertyName)\n        {\n            if (activeToolSwitches.ContainsKey(propertyName))\n            {\n                return !activeToolSwitches[propertyName].BooleanValue;\n            }\n            return false;\n        }\n\n        protected bool IsArgument(ToolSwitch property)\n        {", "        protected bool IsArgument(ToolSwitch property)\n        {\n            if (property != null && property.Parents.Count > 0)\n            {\n                if (string.IsNullOrEmpty(property.SwitchValue))\n                {\n                    return true;\n                }\n                foreach (string parent in property.Parents)\n                {\n                    if (!activeToolSwitches.TryGetValue(parent, out var value))\n                    {\n                        continue;\n                    }", "                foreach (string parent in property.Parents)\n                {\n                    if (!activeToolSwitches.TryGetValue(parent, out var value))\n                    {\n                        continue;\n                    }\n                    foreach (ArgumentRelation argumentRelation in value.ArgumentRelationList)\n                    {\n                        if (argumentRelation.Argument.Equals(property.Name, StringComparison.Ordinal))\n                        {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n", "                        if (argumentRelation.Argument.Equals(property.Name, StringComparison.Ordinal))\n                        {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n\n        protected bool HasSwitch(string propertyName)\n        {", "        protected bool HasSwitch(string propertyName)\n        {\n            if (IsPropertySet(propertyName))\n            {\n                return !string.IsNullOrEmpty(activeToolSwitches[propertyName].Name);\n            }\n            return false;\n        }\n\n        protected bool HasDirectSwitch(string propertyName)\n        {", "        protected bool HasDirectSwitch(string propertyName)\n        {\n            if (activeToolSwitches.TryGetValue(propertyName, out var value) && !string.IsNullOrEmpty(value.Name))\n            {\n                if (value.Type == ToolSwitchType.Boolean)\n                {\n                    return value.BooleanValue;\n                }\n                return true;\n            }\n            return false;\n        }\n", "        protected static string EnsureTrailingSlash(string directoryName)\n        {\n            Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(directoryName != null, \"InternalError\");\n            if (directoryName != null && directoryName.Length > 0)\n            {\n                char c = directoryName[directoryName.Length - 1];\n                if (c != Path.DirectorySeparatorChar && c != Path.AltDirectorySeparatorChar)\n                {\n                    directoryName += Path.DirectorySeparatorChar;\n                }\n            }\n            return directoryName;\n        }\n", "        protected override void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance)\n        {\n            if (EnableErrorListRegex && errorListRegexList.Count > 0)\n            {\n                PrintMessage(ParseLine(singleLine), messageImportance);\n                if (ForceSinglelineErrorListRegex)\n                {\n                    PrintMessage(ParseLine(null), messageImportance);\n                }\n            }\n            else\n            {\n                base.LogEventsFromTextOutput(singleLine, messageImportance);\n            }\n        }\n", "        protected virtual void PrintMessage(MessageStruct message, MessageImportance messageImportance)\n        {\n            if (message != null && message.Text.Length > 0)\n            {\n                switch (message.Category)\n                {\n                    case \"fatal error\":\n                    case \"error\":\n                        base.Log.LogError(message.SubCategory, message.Code, null, message.Filename, message.Line, message.Column, 0, 0, message.Text.TrimEnd());\n                        break;\n                    case \"warning\":\n                        base.Log.LogWarning(message.SubCategory, message.Code, null, message.Filename, message.Line, message.Column, 0, 0, message.Text.TrimEnd());\n                        break;\n                    case \"note\":\n                        base.Log.LogCriticalMessage(message.SubCategory, message.Code, null, message.Filename, message.Line, message.Column, 0, 0, message.Text.TrimEnd());\n                        break;\n                    default:\n                        base.Log.LogMessage(messageImportance, message.Text.TrimEnd());\n                        break;\n                }\n                message.Clear();\n            }\n        }\n", "        protected virtual MessageStruct ParseLine(string inputLine)\n        {\n            if (inputLine == null)\n            {\n                MessageStruct.Swap(ref lastMS, ref currentMS);\n                currentMS.Clear();\n                return lastMS;\n            }\n            if (string.IsNullOrWhiteSpace(inputLine))\n            {\n                return null;\n            }\n            bool flag = false;", "            if (string.IsNullOrWhiteSpace(inputLine))\n            {\n                return null;\n            }\n            bool flag = false;\n            foreach (Regex item in errorListRegexListExclusion)\n            {\n                try\n                {\n                    Match match = item.Match(inputLine);\n                    if (match.Success)\n                    {\n                        flag = true;\n                        break;\n                    }\n                }", "                    if (match.Success)\n                    {\n                        flag = true;\n                        break;\n                    }\n                }\n                catch (RegexMatchTimeoutException)\n                {\n                }\n                catch (Exception e)\n                {\n                    ReportRegexException(inputLine, item, e);\n                }\n            }", "                catch (Exception e)\n                {\n                    ReportRegexException(inputLine, item, e);\n                }\n            }\n            if (!flag)\n            {\n                foreach (Regex errorListRegex in errorListRegexList)\n                {\n                    try\n                    {\n                        Match match2 = errorListRegex.Match(inputLine);", "                        if (match2.Success)\n                        {\n                            int result = 0;\n                            int result2 = 0;\n                            if (!int.TryParse(match2.Groups[\"LINE\"].Value, out result))\n                            {\n                                result = 0;\n                            }\n                            if (!int.TryParse(match2.Groups[\"COLUMN\"].Value, out result2))\n                            {\n                                result2 = 0;\n                            }\n                            MessageStruct.Swap(ref lastMS, ref currentMS);\n                            currentMS.Clear();\n                            currentMS.Category = match2.Groups[\"CATEGORY\"].Value.ToLowerInvariant();\n                            currentMS.SubCategory = match2.Groups[\"SUBCATEGORY\"].Value.ToLowerInvariant();\n                            currentMS.Filename = match2.Groups[\"FILENAME\"].Value;\n                            currentMS.Code = match2.Groups[\"CODE\"].Value;\n                            currentMS.Line = result;\n                            currentMS.Column = result2;\n                            MessageStruct messageStruct = currentMS;\n                            messageStruct.Text = messageStruct.Text + match2.Groups[\"TEXT\"].Value.TrimEnd() + Environment.NewLine;\n                            flag = true;\n                            return lastMS;\n                        }\n                    }", "                            if (!int.TryParse(match2.Groups[\"COLUMN\"].Value, out result2))\n                            {\n                                result2 = 0;\n                            }\n                            MessageStruct.Swap(ref lastMS, ref currentMS);\n                            currentMS.Clear();\n                            currentMS.Category = match2.Groups[\"CATEGORY\"].Value.ToLowerInvariant();\n                            currentMS.SubCategory = match2.Groups[\"SUBCATEGORY\"].Value.ToLowerInvariant();\n                            currentMS.Filename = match2.Groups[\"FILENAME\"].Value;\n                            currentMS.Code = match2.Groups[\"CODE\"].Value;\n                            currentMS.Line = result;\n                            currentMS.Column = result2;\n                            MessageStruct messageStruct = currentMS;\n                            messageStruct.Text = messageStruct.Text + match2.Groups[\"TEXT\"].Value.TrimEnd() + Environment.NewLine;\n                            flag = true;\n                            return lastMS;\n                        }\n                    }", "                    catch (RegexMatchTimeoutException)\n                    {\n                    }\n                    catch (Exception e2)\n                    {\n                        ReportRegexException(inputLine, errorListRegex, e2);\n                    }\n                }\n            }\n            if (!flag && !string.IsNullOrEmpty(currentMS.Filename))\n            {\n                MessageStruct messageStruct2 = currentMS;\n                messageStruct2.Text = messageStruct2.Text + inputLine.TrimEnd() + Environment.NewLine;\n                return null;\n            }\n            MessageStruct.Swap(ref lastMS, ref currentMS);\n            currentMS.Clear();\n            currentMS.Text = inputLine;\n            return lastMS;\n        }\n", "            if (!flag && !string.IsNullOrEmpty(currentMS.Filename))\n            {\n                MessageStruct messageStruct2 = currentMS;\n                messageStruct2.Text = messageStruct2.Text + inputLine.TrimEnd() + Environment.NewLine;\n                return null;\n            }\n            MessageStruct.Swap(ref lastMS, ref currentMS);\n            currentMS.Clear();\n            currentMS.Text = inputLine;\n            return lastMS;\n        }\n", "        protected void ReportRegexException(string inputLine, Regex regex, Exception e)\n        {\n#if __REMOVE\n            if (Microsoft.Build.Shared.ExceptionHandling.IsCriticalException(e))\n            {\n                if (e is OutOfMemoryException)\n                {\n                    int cacheSize = Regex.CacheSize;\n                    Regex.CacheSize = 0;\n                    Regex.CacheSize = cacheSize;\n                }\n                base.Log.LogErrorWithCodeFromResources(\"TrackedVCToolTask.CannotParseToolOutput\", inputLine, regex.ToString(), e.Message);\n                e.Rethrow();\n            }\n            else\n#endif\n            {\n                base.Log.LogWarningWithCodeFromResources(\"TrackedVCToolTask.CannotParseToolOutput\", inputLine, regex.ToString(), e.Message);\n            }\n        }\n", "        private static void EmitAlwaysAppendSwitch(CommandLineBuilder builder, ToolSwitch toolSwitch)\n        {\n            builder.AppendSwitch(toolSwitch.Name);\n        }\n\n        private static void EmitTaskItemArraySwitch(CommandLineBuilder builder, ToolSwitch toolSwitch, CommandLineFormat format = CommandLineFormat.ForBuildLog)\n        {\n            if (string.IsNullOrEmpty(toolSwitch.Separator))\n            {\n                ITaskItem[] taskItemArray = toolSwitch.TaskItemArray;\n                foreach (ITaskItem taskItem in taskItemArray)\n                {\n#if __REMOVE\n                    builder.AppendSwitchIfNotNull(toolSwitch.SwitchValue, Environment.ExpandEnvironmentVariables(taskItem.ItemSpec));\n#else\n                    var ExpandItemSpec =Environment.ExpandEnvironmentVariables(toolSwitch.TaskItem.ItemSpec);", "                foreach (ITaskItem taskItem in taskItemArray)\n                {\n#if __REMOVE\n                    builder.AppendSwitchIfNotNull(toolSwitch.SwitchValue, Environment.ExpandEnvironmentVariables(taskItem.ItemSpec));\n#else\n                    var ExpandItemSpec =Environment.ExpandEnvironmentVariables(toolSwitch.TaskItem.ItemSpec);\n                    if(toolSwitch.TaskItemFullPath)\n                    {\n                        ExpandItemSpec = FileUtilities.NormalizePath(ExpandItemSpec);\n                    }\n\n                    builder.AppendSwitchIfNotNull(toolSwitch.SwitchValue, ExpandItemSpec);\n#endif\n                }\n                return;\n            }\n            ITaskItem[] array = new ITaskItem[toolSwitch.TaskItemArray.Length];", "            for (int j = 0; j < toolSwitch.TaskItemArray.Length; j++)\n            {\n#if __REMOVE\n                array[j] = new TaskItem(Environment.ExpandEnvironmentVariables(toolSwitch.TaskItemArray[j].ItemSpec));\n                if (format == CommandLineFormat.ForTracking)\n                {\n                    array[j].ItemSpec = array[j].ItemSpec.ToUpperInvariant();\n                }\n#else\n                var ExpandItemSpec = Environment.ExpandEnvironmentVariables(toolSwitch.TaskItemArray[j].ItemSpec);\n                if (toolSwitch.TaskItemFullPath)\n                {\n                    ExpandItemSpec = FileUtilities.NormalizePath(ExpandItemSpec);\n                }\n                array[j] = new TaskItem(ExpandItemSpec);\n#endif\n            }\n            builder.AppendSwitchIfNotNull(toolSwitch.SwitchValue, array, toolSwitch.Separator);\n        }\n", "                if (toolSwitch.TaskItemFullPath)\n                {\n                    ExpandItemSpec = FileUtilities.NormalizePath(ExpandItemSpec);\n                }\n                array[j] = new TaskItem(ExpandItemSpec);\n#endif\n            }\n            builder.AppendSwitchIfNotNull(toolSwitch.SwitchValue, array, toolSwitch.Separator);\n        }\n\n        private static void EmitTaskItemSwitch(CommandLineBuilder builder, ToolSwitch toolSwitch)\n        {", "        private static void EmitTaskItemSwitch(CommandLineBuilder builder, ToolSwitch toolSwitch)\n        {\n            if (!string.IsNullOrEmpty(toolSwitch.TaskItem.ItemSpec))\n            {\n#if __REMOVE\n                builder.AppendFileNameIfNotNull(Environment.ExpandEnvironmentVariables(toolSwitch.TaskItem.ItemSpec + toolSwitch.Separator));\n#else\n                var ExpandItemSpec = Environment.ExpandEnvironmentVariables(toolSwitch.TaskItem.ItemSpec);\n                if(toolSwitch.TaskItemFullPath)\n                {\n                    ExpandItemSpec = FileUtilities.NormalizePath(ExpandItemSpec);\n                }\n                builder.AppendFileNameIfNotNull(ExpandItemSpec + toolSwitch.Separator);\n#endif\n            }\n        }\n", "                if(toolSwitch.TaskItemFullPath)\n                {\n                    ExpandItemSpec = FileUtilities.NormalizePath(ExpandItemSpec);\n                }\n                builder.AppendFileNameIfNotNull(ExpandItemSpec + toolSwitch.Separator);\n#endif\n            }\n        }\n\n        private static void EmitDirectorySwitch(CommandLineBuilder builder, ToolSwitch toolSwitch, CommandLineFormat format = CommandLineFormat.ForBuildLog)\n        {", "        private static void EmitDirectorySwitch(CommandLineBuilder builder, ToolSwitch toolSwitch, CommandLineFormat format = CommandLineFormat.ForBuildLog)\n        {\n            if (!string.IsNullOrEmpty(toolSwitch.SwitchValue))\n            {\n                if (format == CommandLineFormat.ForBuildLog)\n                {\n                    builder.AppendSwitch(toolSwitch.SwitchValue + toolSwitch.Separator);\n                }\n                else\n                {\n                    builder.AppendSwitch(toolSwitch.SwitchValue.ToUpperInvariant() + toolSwitch.Separator);\n                }\n            }\n        }\n", "        private static void EmitFileSwitch(CommandLineBuilder builder, ToolSwitch toolSwitch, CommandLineFormat format = CommandLineFormat.ForBuildLog)\n        {\n            if (!string.IsNullOrEmpty(toolSwitch.Value))\n            {\n                string text = Environment.ExpandEnvironmentVariables(toolSwitch.Value);\n                text = text.Trim();\n                //if (format == CommandLineFormat.ForTracking)\n                //{\n                //    text = text.ToUpperInvariant();\n                //}\n                if (!text.StartsWith(\"\\\"\", StringComparison.Ordinal))\n                {\n                    text = \"\\\"\" + text;\n                    text = ((!text.EndsWith(\"\\\\\", StringComparison.Ordinal) || text.EndsWith(\"\\\\\\\\\", StringComparison.Ordinal)) ? (text + \"\\\"\") : (text + \"\\\\\\\"\"));\n                }\n                builder.AppendSwitchUnquotedIfNotNull(toolSwitch.SwitchValue + toolSwitch.Separator, text);\n            }\n        }\n", "                if (!text.StartsWith(\"\\\"\", StringComparison.Ordinal))\n                {\n                    text = \"\\\"\" + text;\n                    text = ((!text.EndsWith(\"\\\\\", StringComparison.Ordinal) || text.EndsWith(\"\\\\\\\\\", StringComparison.Ordinal)) ? (text + \"\\\"\") : (text + \"\\\\\\\"\"));\n                }\n                builder.AppendSwitchUnquotedIfNotNull(toolSwitch.SwitchValue + toolSwitch.Separator, text);\n            }\n        }\n\n        private void EmitIntegerSwitch(CommandLineBuilder builder, ToolSwitch toolSwitch)\n        {", "        private void EmitIntegerSwitch(CommandLineBuilder builder, ToolSwitch toolSwitch)\n        {\n            if (toolSwitch.IsValid)\n            {\n                if (!string.IsNullOrEmpty(toolSwitch.Separator))\n                {\n                    builder.AppendSwitch(toolSwitch.SwitchValue + toolSwitch.Separator + toolSwitch.Number.ToString(CultureInfo.InvariantCulture) + GetEffectiveArgumentsValues(toolSwitch));\n                }\n                else\n                {\n                    builder.AppendSwitch(toolSwitch.SwitchValue + toolSwitch.Number.ToString(CultureInfo.InvariantCulture) + GetEffectiveArgumentsValues(toolSwitch));\n                }\n            }\n        }\n", "        private static void EmitStringArraySwitch(CommandLineBuilder builder, ToolSwitch toolSwitch, CommandLineFormat format = CommandLineFormat.ForBuildLog, EscapeFormat escapeFormat = EscapeFormat.Default)\n        {\n            string[] array = new string[toolSwitch.StringList.Length];\n            char[] anyOf = new char[11]\n            {\n            ' ', '|', '<', '>', ',', ';', '-', '\\r', '\\n', '\\t',\n            '\\f'\n            };\n            for (int i = 0; i < toolSwitch.StringList.Length; i++)\n            {\n                string text = ((!toolSwitch.StringList[i].StartsWith(\"\\\"\", StringComparison.Ordinal) || !toolSwitch.StringList[i].EndsWith(\"\\\"\", StringComparison.Ordinal)) ? Environment.ExpandEnvironmentVariables(toolSwitch.StringList[i]) : Environment.ExpandEnvironmentVariables(toolSwitch.StringList[i].Substring(1, toolSwitch.StringList[i].Length - 2)));", "            for (int i = 0; i < toolSwitch.StringList.Length; i++)\n            {\n                string text = ((!toolSwitch.StringList[i].StartsWith(\"\\\"\", StringComparison.Ordinal) || !toolSwitch.StringList[i].EndsWith(\"\\\"\", StringComparison.Ordinal)) ? Environment.ExpandEnvironmentVariables(toolSwitch.StringList[i]) : Environment.ExpandEnvironmentVariables(toolSwitch.StringList[i].Substring(1, toolSwitch.StringList[i].Length - 2)));\n                if (!string.IsNullOrEmpty(text))\n                {\n                    //if (format == CommandLineFormat.ForTracking)\n                    //{\n                    //    text = text.ToUpperInvariant();\n                    //}\n                    if (escapeFormat.HasFlag(EscapeFormat.EscapeTrailingSlash) && text.IndexOfAny(anyOf) == -1 && text.EndsWith(\"\\\\\", StringComparison.Ordinal) && !text.EndsWith(\"\\\\\\\\\", StringComparison.Ordinal))\n                    {\n                        text += \"\\\\\";\n                    }\n                    array[i] = text;\n                }\n            }", "                    if (escapeFormat.HasFlag(EscapeFormat.EscapeTrailingSlash) && text.IndexOfAny(anyOf) == -1 && text.EndsWith(\"\\\\\", StringComparison.Ordinal) && !text.EndsWith(\"\\\\\\\\\", StringComparison.Ordinal))\n                    {\n                        text += \"\\\\\";\n                    }\n                    array[i] = text;\n                }\n            }\n            if (string.IsNullOrEmpty(toolSwitch.Separator))\n            {\n                string[] array2 = array;\n                foreach (string parameter in array2)\n                {\n                    builder.AppendSwitchIfNotNull(toolSwitch.SwitchValue, parameter);\n                }\n            }\n            else\n            {\n                builder.AppendSwitchIfNotNull(toolSwitch.SwitchValue, array, toolSwitch.Separator);\n            }\n        }\n", "                foreach (string parameter in array2)\n                {\n                    builder.AppendSwitchIfNotNull(toolSwitch.SwitchValue, parameter);\n                }\n            }\n            else\n            {\n                builder.AppendSwitchIfNotNull(toolSwitch.SwitchValue, array, toolSwitch.Separator);\n            }\n        }\n", "        private void EmitStringSwitch(CommandLineBuilder builder, ToolSwitch toolSwitch)\n        {\n            string empty = string.Empty;\n            empty = empty + toolSwitch.SwitchValue + toolSwitch.Separator;\n            StringBuilder stringBuilder = new StringBuilder(GetEffectiveArgumentsValues(toolSwitch));\n            string value = toolSwitch.Value;\n            if (!toolSwitch.MultipleValues)\n            {\n                value = value.Trim();\n                if (!value.StartsWith(\"\\\"\", StringComparison.Ordinal))\n                {\n                    value = \"\\\"\" + value;\n                    value = ((!value.EndsWith(\"\\\\\", StringComparison.Ordinal) || value.EndsWith(\"\\\\\\\\\", StringComparison.Ordinal)) ? (value + \"\\\"\") : (value + \"\\\\\\\"\"));\n                }\n                stringBuilder.Insert(0, value);\n            }", "                if (!value.StartsWith(\"\\\"\", StringComparison.Ordinal))\n                {\n                    value = \"\\\"\" + value;\n                    value = ((!value.EndsWith(\"\\\\\", StringComparison.Ordinal) || value.EndsWith(\"\\\\\\\\\", StringComparison.Ordinal)) ? (value + \"\\\"\") : (value + \"\\\\\\\"\"));\n                }\n                stringBuilder.Insert(0, value);\n            }\n            if (empty.Length != 0 || stringBuilder.ToString().Length != 0)\n            {\n                builder.AppendSwitchUnquotedIfNotNull(empty, stringBuilder.ToString());\n            }\n        }\n", "        private void EmitBooleanSwitch(CommandLineBuilder builder, ToolSwitch toolSwitch, CommandLineFormat format = CommandLineFormat.ForBuildLog)\n        {\n            if (toolSwitch.BooleanValue)\n            {\n                if (!string.IsNullOrEmpty(toolSwitch.SwitchValue))\n                {\n                    StringBuilder stringBuilder = new StringBuilder(GetEffectiveArgumentsValues(toolSwitch, format));\n                    stringBuilder.Insert(0, toolSwitch.Separator);\n                    stringBuilder.Insert(0, toolSwitch.TrueSuffix);\n                    stringBuilder.Insert(0, toolSwitch.SwitchValue);\n                    builder.AppendSwitch(stringBuilder.ToString());\n                }\n            }\n            else\n            {\n                EmitReversibleBooleanSwitch(builder, toolSwitch);\n            }\n        }\n", "        private void EmitReversibleBooleanSwitch(CommandLineBuilder builder, ToolSwitch toolSwitch)\n        {\n            if (!string.IsNullOrEmpty(toolSwitch.ReverseSwitchValue))\n            {\n                string value = (toolSwitch.BooleanValue ? toolSwitch.TrueSuffix : toolSwitch.FalseSuffix);\n                StringBuilder stringBuilder = new StringBuilder(GetEffectiveArgumentsValues(toolSwitch));\n                stringBuilder.Insert(0, value);\n                stringBuilder.Insert(0, toolSwitch.Separator);\n                stringBuilder.Insert(0, toolSwitch.TrueSuffix);\n                stringBuilder.Insert(0, toolSwitch.ReverseSwitchValue);\n                builder.AppendSwitch(stringBuilder.ToString());\n            }\n        }\n", "        private string Prefix(string toolSwitch)\n        {\n            if (!string.IsNullOrEmpty(toolSwitch) && toolSwitch[0] != prefix)\n            {\n                return prefix + toolSwitch;\n            }\n            return toolSwitch;\n        }\n    }\n\n}\n"]}
{"filename": "Microsoft.Build.CPPTasks/Helpers.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Microsoft.Build.CPPTasks\n{\n    public sealed class Helpers\n    {\n        private Helpers()\n        {\n        }\n", "        public static string GetOutputFileName(string sourceFile, string outputFileOrDir, string outputExtension)\n        {\n            string text;\n            if (string.IsNullOrEmpty(outputFileOrDir))\n            {\n                text = sourceFile;\n                if (!string.IsNullOrEmpty(text) && !string.IsNullOrEmpty(outputExtension))\n                {\n                    text = Path.ChangeExtension(text, outputExtension);\n                }\n            }\n            else\n            {\n                text = outputFileOrDir;\n                char c = outputFileOrDir[outputFileOrDir.Length - 1];", "                if (c == Path.DirectorySeparatorChar || c == Path.AltDirectorySeparatorChar)\n                {\n                    text = Path.Combine(text, Path.GetFileName(sourceFile));\n                    text = Path.ChangeExtension(text, outputExtension);\n                }\n                else\n                {\n                    string extension = Path.GetExtension(text);\n                    if (string.IsNullOrEmpty(extension) && !string.IsNullOrEmpty(outputExtension))\n                    {\n                        text = Path.ChangeExtension(text, outputExtension);\n                    }\n                }\n            }", "                    if (string.IsNullOrEmpty(extension) && !string.IsNullOrEmpty(outputExtension))\n                    {\n                        text = Path.ChangeExtension(text, outputExtension);\n                    }\n                }\n            }\n            if (Path.IsPathRooted(text))\n            {\n                text = Path.GetFullPath(text);\n            }\n            return text;\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.CPPTasks/ToolSwitch.cs", "chunked_list": ["\ufeffusing System.Collections;\nusing System.Collections.Generic;\nusing Microsoft.Build.CPPTasks;\nusing Microsoft.Build.Framework;\nusing Microsoft.Build.Shared;\n\nnamespace Microsoft.Build.CPPTasks\n{\n    public enum ToolSwitchType\n    {\n        Boolean,\n        Integer,\n        String,\n        StringArray,\n        File,\n        Directory,\n        ITaskItem,\n        ITaskItemArray,\n        AlwaysAppend,\n        StringPathArray\n    }\n", "    public enum ToolSwitchType\n    {\n        Boolean,\n        Integer,\n        String,\n        StringArray,\n        File,\n        Directory,\n        ITaskItem,\n        ITaskItemArray,\n        AlwaysAppend,\n        StringPathArray\n    }\n", "    public class ToolSwitch\n    {\n        private string name = string.Empty;\n\n        private ToolSwitchType type;\n\n        private string falseSuffix = string.Empty;\n\n        private string trueSuffix = string.Empty;\n\n        private string separator = string.Empty;\n", "        private string trueSuffix = string.Empty;\n\n        private string separator = string.Empty;\n\n        private string argumentParameter = string.Empty;\n\n        private string fallback = string.Empty;\n\n        private bool argumentRequired;\n\n        private bool required;\n\n        private LinkedList<string> parents = new LinkedList<string>();\n\n        private LinkedList<KeyValuePair<string, string>> overrides = new LinkedList<KeyValuePair<string, string>>();\n", "        private bool argumentRequired;\n\n        private bool required;\n\n        private LinkedList<string> parents = new LinkedList<string>();\n\n        private LinkedList<KeyValuePair<string, string>> overrides = new LinkedList<KeyValuePair<string, string>>();\n\n        private ArrayList argumentRelationList;\n\n        private bool isValid;\n", "        private ArrayList argumentRelationList;\n\n        private bool isValid;\n\n        private bool reversible;\n\n        private bool booleanValue = true;\n\n        private int number;\n\n        private string[] stringList;\n", "        private int number;\n\n        private string[] stringList;\n\n        private ITaskItem taskItem;\n\n        private ITaskItem[] taskItemArray;\n\n#if __REMOVE\n#else\n        // GCC\u5de5\u5177\u94fe\u6ca1\u6709\u5b8c\u6574\u8def\u5f84\u9009\u62e9\uff0c\u4e3a\u4e86\u65b9\u4fbf\u51fa\u9519\u65f6\u67e5\u770b\u4ee3\u7801\u8def\u5f84\uff0c\u6240\u4ee5\u6dfb\u52a0\u4e86\u5b8c\u6574\u8def\u5f84\u8f93\u51fa\u80fd\u529b\u3002", "        public bool TaskItemFullPath = false;\n#endif\n        private string value = string.Empty;\n\n        private string switchValue = string.Empty;\n\n        private string reverseSwitchValue = string.Empty;\n\n        private string description = string.Empty;\n\n        private string displayName = string.Empty;\n", "        private string description = string.Empty;\n\n        private string displayName = string.Empty;\n\n        private const string typeBoolean = \"ToolSwitchType.Boolean\";\n\n        private const string typeInteger = \"ToolSwitchType.Integer\";\n\n        private const string typeITaskItem = \"ToolSwitchType.ITaskItem\";\n\n        private const string typeITaskItemArray = \"ToolSwitchType.ITaskItemArray\";\n", "        private const string typeITaskItem = \"ToolSwitchType.ITaskItem\";\n\n        private const string typeITaskItemArray = \"ToolSwitchType.ITaskItemArray\";\n\n        private const string typeStringArray = \"ToolSwitchType.StringArray or ToolSwitchType.StringPathArray\";\n\n        public string Name\n        {\n            get\n            {\n                return name;\n            }\n            set\n            {\n                name = value;\n            }\n        }\n", "        public string Value\n        {\n            get\n            {\n                return value;\n            }\n            set\n            {\n                this.value = value;\n            }\n        }\n", "        public bool IsValid\n        {\n            get\n            {\n                return isValid;\n            }\n            set\n            {\n                isValid = value;\n            }\n        }\n", "        public string SwitchValue\n        {\n            get\n            {\n                return switchValue;\n            }\n            set\n            {\n                switchValue = value;\n            }\n        }\n", "        public string ReverseSwitchValue\n        {\n            get\n            {\n                return reverseSwitchValue;\n            }\n            set\n            {\n                reverseSwitchValue = value;\n            }\n        }\n", "        public string DisplayName\n        {\n            get\n            {\n                return displayName;\n            }\n            set\n            {\n                displayName = value;\n            }\n        }\n", "        public string Description\n        {\n            get\n            {\n                return description;\n            }\n            set\n            {\n                description = value;\n            }\n        }\n", "        public ToolSwitchType Type\n        {\n            get\n            {\n                return type;\n            }\n            set\n            {\n                type = value;\n            }\n        }\n", "        public bool Reversible\n        {\n            get\n            {\n                return reversible;\n            }\n            set\n            {\n                reversible = value;\n            }\n        }\n", "        public bool MultipleValues { get; set; }\n\n        public string FalseSuffix\n        {\n            get\n            {\n                return falseSuffix;\n            }\n            set\n            {\n                falseSuffix = value;\n            }\n        }\n", "        public string TrueSuffix\n        {\n            get\n            {\n                return trueSuffix;\n            }\n            set\n            {\n                trueSuffix = value;\n            }\n        }\n", "        public string Separator\n        {\n            get\n            {\n                return separator;\n            }\n            set\n            {\n                separator = value;\n            }\n        }\n", "        public string FallbackArgumentParameter\n        {\n            get\n            {\n                return fallback;\n            }\n            set\n            {\n                fallback = value;\n            }\n        }\n", "        public bool ArgumentRequired\n        {\n            get\n            {\n                return argumentRequired;\n            }\n            set\n            {\n                argumentRequired = value;\n            }\n        }\n", "        public bool Required\n        {\n            get\n            {\n                return required;\n            }\n            set\n            {\n                required = value;\n            }\n        }\n\n        public LinkedList<string> Parents => parents;\n\n        public LinkedList<KeyValuePair<string, string>> Overrides => overrides;\n", "        public ArrayList ArgumentRelationList\n        {\n            get\n            {\n                return argumentRelationList;\n            }\n            set\n            {\n                argumentRelationList = value;\n            }\n        }\n", "        public bool BooleanValue\n        {\n            get\n            {\n                Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(type == ToolSwitchType.Boolean, \"InvalidType\", \"ToolSwitchType.Boolean\");\n                return booleanValue;\n            }\n            set\n            {\n                Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(type == ToolSwitchType.Boolean, \"InvalidType\", \"ToolSwitchType.Boolean\");\n                booleanValue = value;\n            }\n        }\n", "        public int Number\n        {\n            get\n            {\n                Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(type == ToolSwitchType.Integer, \"InvalidType\", \"ToolSwitchType.Integer\");\n                return number;\n            }\n            set\n            {\n                Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(type == ToolSwitchType.Integer, \"InvalidType\", \"ToolSwitchType.Integer\");\n                number = value;\n            }\n        }\n\n        public string[] StringList\n        {\n            get\n            {\n                Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(type == ToolSwitchType.StringArray || type == ToolSwitchType.StringPathArray, \"InvalidType\", \"ToolSwitchType.StringArray or ToolSwitchType.StringPathArray\");\n                return stringList;\n            }\n            set\n            {\n                Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(type == ToolSwitchType.StringArray || type == ToolSwitchType.StringPathArray, \"InvalidType\", \"ToolSwitchType.StringArray or ToolSwitchType.StringPathArray\");\n                stringList = value;\n            }\n        }\n", "        public ITaskItem TaskItem\n        {\n            get\n            {\n                Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(type == ToolSwitchType.ITaskItem, \"InvalidType\", \"ToolSwitchType.ITaskItem\");\n                return taskItem;\n            }\n            set\n            {\n                Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(type == ToolSwitchType.ITaskItem, \"InvalidType\", \"ToolSwitchType.ITaskItem\");\n                taskItem = value;\n            }\n        }\n\n        public ITaskItem[] TaskItemArray\n        {\n            get\n            {\n                Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(type == ToolSwitchType.ITaskItemArray, \"InvalidType\", \"ToolSwitchType.ITaskItemArray\");\n                return taskItemArray;\n            }\n            set\n            {\n                Microsoft.Build.Shared.ErrorUtilities.VerifyThrow(type == ToolSwitchType.ITaskItemArray, \"InvalidType\", \"ToolSwitchType.ITaskItemArray\");\n                taskItemArray = value;\n            }\n        }\n", "        public string ValueAsString\n        {\n            get\n            {\n                string result = string.Empty;\n                switch (Type)\n                {\n                    case ToolSwitchType.Boolean:\n                        result = booleanValue.ToString();\n                        break;\n                    case ToolSwitchType.String:\n                    case ToolSwitchType.File:\n                    case ToolSwitchType.Directory:\n                        result = value;\n                        break;\n                    case ToolSwitchType.StringArray:\n                    case ToolSwitchType.StringPathArray:\n                        result = string.Join(\";\", StringList);\n                        break;\n                    case ToolSwitchType.Integer:\n                        result = number.ToString();\n                        break;\n                }\n                return result;\n            }\n        }\n\n        public ToolSwitch()\n        {\n        }\n\n        public ToolSwitch(ToolSwitchType toolType)\n        {\n            type = toolType;\n        }\n    }\n\n}\n"]}
{"filename": "Microsoft.Build.CPPTasks/CPPClean.cs", "chunked_list": ["\ufeffusing Microsoft.Build.Framework;\nusing Microsoft.Build.Utilities;\nusing System;\nusing System.Collections.Generic;\nusing System.Reflection;\nusing System.Text;\nusing System.Resources;\n\nnamespace Microsoft.Build.CPPTasks\n{\n    public class CPPClean : Microsoft.Build.Utilities.Task\n    {\n        private ITaskItem[] _deletedFiles;\n", "namespace Microsoft.Build.CPPTasks\n{\n    public class CPPClean : Microsoft.Build.Utilities.Task\n    {\n        private ITaskItem[] _deletedFiles;\n\n        private string _foldersToClean;\n\n        private string _filePatternsToDeleteOnClean;\n\n        private string _filesExcludedFromClean;\n", "        private string _filePatternsToDeleteOnClean;\n\n        private string _filesExcludedFromClean;\n\n        private bool _doDelete = true;\n\n        private HashSet<string> _filesToDeleteSet = new HashSet<string>();\n\n        [Required]\n        public string FoldersToClean\n        {\n            get\n            {\n                return _foldersToClean;\n            }\n            set\n            {\n                _foldersToClean = value;\n            }\n        }\n", "        public string FoldersToClean\n        {\n            get\n            {\n                return _foldersToClean;\n            }\n            set\n            {\n                _foldersToClean = value;\n            }\n        }\n", "        public string FilesExcludedFromClean\n        {\n            get\n            {\n                return _filesExcludedFromClean;\n            }\n            set\n            {\n                _filesExcludedFromClean = value;\n            }\n        }\n", "        public bool DoDelete\n        {\n            get\n            {\n                return _doDelete;\n            }\n            set\n            {\n                _doDelete = value;\n            }\n        }\n\n        [Required]", "        public string FilePatternsToDeleteOnClean\n        {\n            get\n            {\n                return _filePatternsToDeleteOnClean;\n            }\n            set\n            {\n                _filePatternsToDeleteOnClean = value;\n            }\n        }\n\n        [Output]\n        public ITaskItem[] DeletedFiles\n        {\n            get\n            {\n                return _deletedFiles;\n            }\n            set\n            {\n                _deletedFiles = value;\n            }\n        }\n\n        public CPPClean()\n            : base(Microsoft.Build.CppTasks.Common.Properties.Microsoft_Build_CPPTasks_Strings.ResourceManager)\n        {\n        }\n", "        public override bool Execute()\n        {\n            try\n            {\n                if (!ComputeFilesToDelete())\n                {\n                    return true;\n                }\n                if (DoDelete)\n                {\n                    DeleteFiles();\n                }\n                return true;\n            }", "                if (DoDelete)\n                {\n                    DeleteFiles();\n                }\n                return true;\n            }\n            catch (Exception ex)\n            {\n                base.Log.LogErrorFromException(ex);\n                if (Microsoft.Build.Shared.ExceptionHandling.IsCriticalException(ex))\n                {\n                    throw;\n                }\n                return false;\n            }\n        }\n", "                if (Microsoft.Build.Shared.ExceptionHandling.IsCriticalException(ex))\n                {\n                    throw;\n                }\n                return false;\n            }\n        }\n\n        private bool ComputeFilesToDelete()\n        {\n            if (FoldersToClean == null || FilePatternsToDeleteOnClean == null)\n            {\n                return false;\n            }\n            string[] array = FilePatternsToDeleteOnClean.Split(';');\n            string[] array2 = FoldersToClean.Split(';');\n            string[] array3 = ((FilesExcludedFromClean != null) ? FilesExcludedFromClean.Split(';') : null);\n            List<string> list = new List<string>();\n            string[] array4 = array2;", "        private bool ComputeFilesToDelete()\n        {\n            if (FoldersToClean == null || FilePatternsToDeleteOnClean == null)\n            {\n                return false;\n            }\n            string[] array = FilePatternsToDeleteOnClean.Split(';');\n            string[] array2 = FoldersToClean.Split(';');\n            string[] array3 = ((FilesExcludedFromClean != null) ? FilesExcludedFromClean.Split(';') : null);\n            List<string> list = new List<string>();\n            string[] array4 = array2;", "            foreach (string text in array4)\n            {\n                if (!string.IsNullOrEmpty(text) && Directory.Exists(text))\n                {\n                    list.Add(text);\n                }\n            }\n            if (list.Count == 0)\n            {\n                return false;\n            }\n            List<string> filesFromFoldersByFilters = GetFilesFromFoldersByFilters(list, \"*.write.*.tlog\");\n            GetFilesFromTLogs(filesFromFoldersByFilters, _filesToDeleteSet);", "            foreach (string item in list)\n            {\n                DirectoryInfo dirInfo = new DirectoryInfo(item);\n                string[] array5 = array;\n                foreach (string filePattern in array5)\n                {\n                    List<string> matchingFilesInFolder = GetMatchingFilesInFolder(dirInfo, filePattern);\n                    foreach (string item2 in matchingFilesInFolder)\n                    {\n                        _filesToDeleteSet.Add(item2/*.ToLowerInvariant()*/);\n                    }\n                }", "                if (array3 == null)\n                {\n                    continue;\n                }\n                string[] array6 = array3;\n                foreach (string filePattern2 in array6)\n                {\n                    List<string> matchingFilesInFolder2 = GetMatchingFilesInFolder(dirInfo, filePattern2);\n                    foreach (string item3 in matchingFilesInFolder2)\n                    {\n                        _filesToDeleteSet.Remove(item3/*.ToLowerInvariant()*/);\n                    }\n                }\n            }", "                    foreach (string item3 in matchingFilesInFolder2)\n                    {\n                        _filesToDeleteSet.Remove(item3/*.ToLowerInvariant()*/);\n                    }\n                }\n            }\n            if (_filesToDeleteSet.Count == 0)\n            {\n                return false;\n            }\n            DeletedFiles = new ITaskItem[_filesToDeleteSet.Count];\n            int num = 0;", "            foreach (string item4 in _filesToDeleteSet)\n            {\n                DeletedFiles[num] = new TaskItem(item4);\n                num++;\n            }\n            return true;\n        }\n\n        private static List<string> GetFilesFromFoldersByFilters(List<string> foldersList, string filter)\n        {\n            if (foldersList == null)\n            {\n                return null;\n            }\n            List<string> list = new List<string>();", "        private static List<string> GetFilesFromFoldersByFilters(List<string> foldersList, string filter)\n        {\n            if (foldersList == null)\n            {\n                return null;\n            }\n            List<string> list = new List<string>();\n            foreach (string folders in foldersList)\n            {\n                list.AddRange(Directory.GetFiles(folders, filter));\n            }\n            return list;\n        }\n", "        private static List<string> GetMatchingFilesInFolder(DirectoryInfo dirInfo, string filePattern)\n        {\n            List<string> list = new List<string>();\n            if (!string.IsNullOrEmpty(filePattern))\n            {\n                if (filePattern.IndexOf(\"*\", StringComparison.OrdinalIgnoreCase) != -1)\n                {\n                    FileInfo[] files = dirInfo.GetFiles(filePattern);\n                    FileInfo[] array = files;\n                    foreach (FileInfo fileInfo in array)\n                    {\n                        list.Add(fileInfo.FullName);\n                    }\n                }\n                else\n                {\n                    string text = (Path.IsPathRooted(filePattern) ? filePattern : Path.Combine(dirInfo.FullName, filePattern));", "                    foreach (FileInfo fileInfo in array)\n                    {\n                        list.Add(fileInfo.FullName);\n                    }\n                }\n                else\n                {\n                    string text = (Path.IsPathRooted(filePattern) ? filePattern : Path.Combine(dirInfo.FullName, filePattern));\n                    if (File.Exists(text))\n                    {\n                        list.Add(text);\n                    }\n                }\n            }\n            return list;\n        }\n", "                    if (File.Exists(text))\n                    {\n                        list.Add(text);\n                    }\n                }\n            }\n            return list;\n        }\n\n        private static void GetFilesFromTLogs(List<string> TLogs, HashSet<string> filesToDelete)\n        {", "        private static void GetFilesFromTLogs(List<string> TLogs, HashSet<string> filesToDelete)\n        {\n            foreach (string TLog in TLogs)\n            {\n                if (TLog.Length <= 0)\n                {\n                    continue;\n                }\n                using TextReader textReader = File.OpenText(TLog);\n                while (textReader.Peek() > -1)\n                {\n                    string text = textReader.ReadLine();", "                while (textReader.Peek() > -1)\n                {\n                    string text = textReader.ReadLine();\n                    if (text.Length > 0 && text[0] != '^' && text[0] != '#')\n                    {\n                        filesToDelete.Add(text/*.ToLowerInvariant()*/);\n                    }\n                }\n            }\n        }\n", "        private bool DeleteFiles()\n        {\n            foreach (string item in _filesToDeleteSet)\n            {\n                if (!File.Exists(item))\n                {\n                    continue;\n                }\n                try\n                {\n                    File.Delete(item);\n                }", "                catch (Exception ex)\n                {\n                    if (Microsoft.Build.Shared.ExceptionHandling.IsCriticalException(ex))\n                    {\n                        throw;\n                    }\n                    base.Log.LogWarningFromException(ex);\n                }\n            }\n            return true;\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.CPPTasks/GetOutOfDateItems.cs", "chunked_list": ["\ufeffusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Resources;\nusing System.Text;\nusing Microsoft.Build.Framework;\nusing Microsoft.Build.Utilities;\n\nnamespace Microsoft.Build.CPPTasks", "\nnamespace Microsoft.Build.CPPTasks\n{\n    public class GetOutOfDateItems : Microsoft.Build.Utilities.Task\n    {\n        private const string DependsOnAnotherItemOutputsMetadataName = \"DependsOnAnotherItemOutput\";\n\n        private const string InitializingValue = \"Initializing\";\n\n        public ITaskItem[] Sources { get; set; }\n\n        [Required]", "        public string OutputsMetadataName { get; set; }\n\n        public string DependenciesMetadataName { get; set; }\n\n        public string CommandMetadataName { get; set; }\n\n        [Required]\n        public string TLogDirectory { get; set; }\n\n        [Required]\n        public string TLogNamePrefix { get; set; }\n", "        public string TLogNamePrefix { get; set; }\n\n        public bool CheckForInterdependencies { get; set; }\n\n        public bool TrackFileAccess { get; set; }\n\n        [Output]\n        public ITaskItem[] OutOfDateSources { get; set; }\n\n        [Output]\n        public bool HasInterdependencies { get; set; }\n\n        public GetOutOfDateItems()\n            : base(new ResourceManager(\"Microsoft.Build.CPPTasks.Strings\", Assembly.GetExecutingAssembly()))\n        {\n            CheckForInterdependencies = false;\n            HasInterdependencies = false;\n            DependenciesMetadataName = null;\n            CommandMetadataName = null;\n            TrackFileAccess = true;\n        }\n", "        public bool HasInterdependencies { get; set; }\n\n        public GetOutOfDateItems()\n            : base(new ResourceManager(\"Microsoft.Build.CPPTasks.Strings\", Assembly.GetExecutingAssembly()))\n        {\n            CheckForInterdependencies = false;\n            HasInterdependencies = false;\n            DependenciesMetadataName = null;\n            CommandMetadataName = null;\n            TrackFileAccess = true;\n        }\n", "        public override bool Execute()\n        {\n            //IL_00fd: Unknown result type (might be due to invalid IL or missing references)\n            //IL_0104: Expected O, but got Unknown\n            //IL_011f: Unknown result type (might be due to invalid IL or missing references)\n            //IL_0126: Expected O, but got Unknown\n            if (!TrackFileAccess)\n            {\n                if (Sources != null)\n                {\n                    List<ITaskItem> list = new List<ITaskItem>();\n                    ITaskItem[] sources = Sources;", "                if (Sources != null)\n                {\n                    List<ITaskItem> list = new List<ITaskItem>();\n                    ITaskItem[] sources = Sources;\n                    foreach (ITaskItem sourceItem in sources)\n                    {\n                        list.Add(new TaskItem(sourceItem));\n                    }\n                    OutOfDateSources = list.ToArray();\n                }\n                return true;\n            }\n            TaskItem taskItem = new TaskItem(Path.Combine(TLogDirectory, TLogNamePrefix + \".read.1.tlog\"));\n            TaskItem taskItem2 = new TaskItem(Path.Combine(TLogDirectory, TLogNamePrefix + \".write.1.tlog\"));\n            TaskItem taskItem3 = new TaskItem(Path.Combine(TLogDirectory, TLogNamePrefix + \".command.1.tlog\"));\n            string metadata = taskItem.GetMetadata(\"FullPath\");\n            string metadata2 = taskItem2.GetMetadata(\"FullPath\");\n            string metadata3 = taskItem3.GetMetadata(\"FullPath\");\n            List<ITaskItem> list2 = new List<ITaskItem>();", "            if (Sources != null)\n            {\n                CanonicalTrackedOutputFiles val = new CanonicalTrackedOutputFiles((ITask)this, new ITaskItem[1] { taskItem2 }, true);\n                CanonicalTrackedInputFiles val2 = new CanonicalTrackedInputFiles((ITask)this, new ITaskItem[1] { taskItem }, Sources, new ITaskItem[0], val, true, false);\n                ITaskItem[] collection = val2.ComputeSourcesNeedingCompilation(false);\n                HashSet<ITaskItem> hashSet = new HashSet<ITaskItem>(collection);\n                StringBuilder stringBuilder = new StringBuilder();\n                StringBuilder stringBuilder2 = new StringBuilder();\n                StringBuilder stringBuilder3 = new StringBuilder();\n                Dictionary<string, object> dictionary = ReadCommandLines(metadata3);\n                Dictionary<ITaskItem, HashSet<string>> dictionary2 = new Dictionary<ITaskItem, HashSet<string>>();\n                Dictionary<ITaskItem, HashSet<string>> dictionary3 = new Dictionary<ITaskItem, HashSet<string>>();\n                ITaskItem[] sources2 = Sources;", "                foreach (ITaskItem taskItem4 in sources2)\n                {\n                    string metadata4 = taskItem4.GetMetadata(\"FullPath\");\n                    string text = metadata4/*.ToUpperInvariant()*/;\n                    string text2 = (string.IsNullOrEmpty(CommandMetadataName) ? string.Empty : taskItem4.GetMetadata(CommandMetadataName).Trim());\n                    string[] collection2 = (string.IsNullOrEmpty(DependenciesMetadataName) ? new string[0] : MsbuildTaskUtilities.GetWildcardExpandedFileListFromMetadata(base.BuildEngine, taskItem4, DependenciesMetadataName, base.Log));\n                    HashSet<string> hashSet2 = new HashSet<string>(collection2, StringComparer.OrdinalIgnoreCase);\n                    hashSet2.Remove(metadata4);\n                    string[] wildcardExpandedFileListFromMetadata = MsbuildTaskUtilities.GetWildcardExpandedFileListFromMetadata(base.BuildEngine, taskItem4, OutputsMetadataName, base.Log);\n                    HashSet<string> hashSet3 = new HashSet<string>(wildcardExpandedFileListFromMetadata, StringComparer.OrdinalIgnoreCase);\n                    dictionary2[taskItem4] = hashSet2;\n                    dictionary3[taskItem4] = hashSet3;", "                    if (!hashSet.Contains(taskItem4))\n                    {\n                        bool flag = false;\n                        if (!string.IsNullOrEmpty(CommandMetadataName))\n                        {\n                            flag = true;\n                            if (dictionary.TryGetValue(metadata4, out var value))\n                            {\n                                if (value is List<string> list3)\n                                {\n                                    foreach (string item in list3)\n                                    {", "                                if (value is List<string> list3)\n                                {\n                                    foreach (string item in list3)\n                                    {\n                                        if (text2.Equals(item))\n                                        {\n                                            flag = false;\n                                            break;\n                                        }\n                                    }\n                                }\n                                else\n                                {\n                                    string value2 = (string)value;", "                                    if (text2.Equals(value2))\n                                    {\n                                        flag = false;\n                                    }\n                                }\n                                if (flag)\n                                {\n                                    hashSet.Add(taskItem4);\n                                    base.Log.LogMessageFromResources(MessageImportance.Low, \"TrackedVCToolTask.RebuildingSourceCommandLineChanged\", metadata4);\n                                }\n                            }\n                            else\n                            {\n                                hashSet.Add(taskItem4);\n                                base.Log.LogMessageFromResources(MessageImportance.Low, \"TrackedVCToolTask.RebuildingSourceCommandLineChanged\", metadata4);\n                            }\n                        }", "                        if (!flag && !string.IsNullOrEmpty(DependenciesMetadataName))\n                        {\n                            if (!IsTheSameFileSet(val2.DependencyTable, metadata4, hashSet2.ToArray(), dependencyTableIncludesSourceFile: true))\n                            {\n                                hashSet.Add(taskItem4);\n                                base.Log.LogMessageFromResources(MessageImportance.Low, \"GetOutOfDateItems.RebuildingSourceDependenciesChanged\", metadata4);\n                            }\n                            if (!IsTheSameFileSet(val.DependencyTable, metadata4, hashSet3.ToArray(), dependencyTableIncludesSourceFile: false))\n                            {\n                                hashSet.Add(taskItem4);\n                                base.Log.LogMessageFromResources(MessageImportance.Low, \"GetOutOfDateItems.RebuildingSourceOutputsChanged\", metadata4);\n                            }\n                        }\n                    }\n                    stringBuilder.Append(\"^\");\n                    stringBuilder.AppendLine(text);\n                    stringBuilder.AppendLine(text2);\n                    stringBuilder2.Append(\"^\");\n                    stringBuilder2.AppendLine(text);", "                    foreach (string item2 in hashSet2)\n                    {\n                        if (!string.Equals(item2, text, StringComparison.OrdinalIgnoreCase))\n                        {\n                            stringBuilder2.AppendLine(item2);\n                        }\n                    }\n                    stringBuilder3.Append(\"^\");\n                    stringBuilder3.AppendLine(text);\n                    foreach (string item3 in hashSet3)\n                    {\n                        stringBuilder3.AppendLine(item3);\n                    }\n                }", "                    foreach (string item3 in hashSet3)\n                    {\n                        stringBuilder3.AppendLine(item3);\n                    }\n                }\n                if (hashSet.Count > 0)\n                {\n                    Dictionary<string, ITaskItem> dictionary4 = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);\n                    if (CheckForInterdependencies)\n                    {\n                        ITaskItem[] sources3 = Sources;", "                    if (CheckForInterdependencies)\n                    {\n                        ITaskItem[] sources3 = Sources;\n                        foreach (ITaskItem taskItem5 in sources3)\n                        {\n                            foreach (string item4 in dictionary3[taskItem5])\n                            {\n                                dictionary4[item4] = taskItem5;\n                            }\n                        }\n                    }\n                    ITaskItem[] sources4 = Sources;", "                    foreach (ITaskItem taskItem6 in sources4)\n                    {\n                        CheckIfItemDependsOnOtherItemOutputs(taskItem6, dictionary2, dictionary4, hashSet);\n                        if (hashSet.Contains(taskItem6))\n                        {\n                            list2.Add(new TaskItem(taskItem6));\n                        }\n                    }\n                    Directory.CreateDirectory(Path.GetDirectoryName(metadata));\n                    File.WriteAllText(metadata3, stringBuilder.ToString());\n                    File.WriteAllText(metadata, stringBuilder2.ToString());\n                    File.WriteAllText(metadata2, stringBuilder3.ToString());\n                }\n            }\n            else\n            {\n                try\n                {", "                    if (File.Exists(metadata))\n                    {\n                        File.Delete(metadata);\n                    }\n                    if (File.Exists(metadata2))\n                    {\n                        File.Delete(metadata2);\n                    }\n                    if (File.Exists(metadata3))\n                    {\n                        File.Delete(metadata3);\n                    }\n                }", "                    if (File.Exists(metadata3))\n                    {\n                        File.Delete(metadata3);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    base.Log.LogWarningWithCodeFromResources(\"CannotDeleteTlogs\", TLogNamePrefix, ex.Message);\n                }\n            }\n            OutOfDateSources = list2.ToArray();\n            return true;\n        }\n", "        private bool CheckIfItemDependsOnOtherItemOutputs(ITaskItem item, Dictionary<ITaskItem, HashSet<string>> itemDependencies, Dictionary<string, ITaskItem> allOutputs, HashSet<ITaskItem> outOfDateItemHash)\n        {\n            if (allOutputs.Count > 0 && (!outOfDateItemHash.Contains(item) || string.IsNullOrEmpty(item.GetMetadata(\"DependsOnAnotherItemOutput\"))))\n            {\n                item.SetMetadata(\"DependsOnAnotherItemOutput\", \"Initializing\");\n                foreach (string item2 in itemDependencies[item])\n                {\n                    if (!allOutputs.TryGetValue(item2, out var value))\n                    {\n                        continue;\n                    }\n                    string metadata = value.GetMetadata(\"DependsOnAnotherItemOutput\");", "                    if (!string.Equals(metadata, \"Initializing\"))\n                    {\n                        if (outOfDateItemHash.Contains(value))\n                        {\n                            base.Log.LogMessageFromResources(MessageImportance.Normal, \"GetOutOfDateItems.ItemDependsOnAnotherItemOutput\", item.GetMetadata(\"FullPath\"), item2, value.GetMetadata(\"FullPath\"));\n                            item.SetMetadata(\"DependsOnAnotherItemOutput\", \"true\");\n                            outOfDateItemHash.Add(item);\n                            HasInterdependencies = true;\n                            return true;\n                        }\n                        if (CheckIfItemDependsOnOtherItemOutputs(value, itemDependencies, allOutputs, outOfDateItemHash))\n                        {\n                            return true;\n                        }\n                    }\n                }\n                item.SetMetadata(\"DependsOnAnotherItemOutput\", \"false\");\n            }\n            return false;\n        }\n\n        private Dictionary<string, object> ReadCommandLines(string tlogCommandFile)\n        {\n            Dictionary<string, object> dictionary = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);", "                        if (CheckIfItemDependsOnOtherItemOutputs(value, itemDependencies, allOutputs, outOfDateItemHash))\n                        {\n                            return true;\n                        }\n                    }\n                }\n                item.SetMetadata(\"DependsOnAnotherItemOutput\", \"false\");\n            }\n            return false;\n        }\n\n        private Dictionary<string, object> ReadCommandLines(string tlogCommandFile)\n        {\n            Dictionary<string, object> dictionary = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);", "            if (File.Exists(tlogCommandFile))\n            {\n                string[] array = File.ReadAllLines(tlogCommandFile);\n                string text = null;\n                StringBuilder stringBuilder = new StringBuilder();\n                string[] array2 = array;\n                foreach (string text2 in array2)\n                {\n                    if (string.IsNullOrEmpty(text2) || text2.StartsWith(\"#\"))\n                    {\n                        continue;\n                    }", "                    if (string.IsNullOrEmpty(text2) || text2.StartsWith(\"#\"))\n                    {\n                        continue;\n                    }\n                    if (text2.StartsWith(\"^\"))\n                    {\n                        AddCommandLine(dictionary, text, stringBuilder.ToString());\n                        stringBuilder.Clear();\n                        text = text2.Substring(1);\n                    }\n                    else if (!string.IsNullOrEmpty(text))\n                    {", "                    else if (!string.IsNullOrEmpty(text))\n                    {\n                        if (stringBuilder.Length != 0)\n                        {\n                            stringBuilder.Append(\"\\r\\n\");\n                        }\n                        stringBuilder.Append(text2);\n                    }\n                }\n                AddCommandLine(dictionary, text, stringBuilder.ToString());\n            }\n            return dictionary;\n        }\n", "        private void AddCommandLine(Dictionary<string, object> commandLines, string sourceFile, string command)\n        {\n            if (string.IsNullOrEmpty(sourceFile))\n            {\n                return;\n            }\n            if (commandLines.TryGetValue(sourceFile, out var value))\n            {\n                List<string> list = value as List<string>;\n                if (list == null)\n                {\n                    list = new List<string>();\n                    list.Add((string)value);\n                    commandLines[sourceFile] = list;\n                }\n                list.Add(command);\n            }\n            else\n            {\n                commandLines[sourceFile] = command;\n            }\n        }\n", "                if (list == null)\n                {\n                    list = new List<string>();\n                    list.Add((string)value);\n                    commandLines[sourceFile] = list;\n                }\n                list.Add(command);\n            }\n            else\n            {\n                commandLines[sourceFile] = command;\n            }\n        }\n", "        private bool IsTheSameFileSet<T>(Dictionary<string, Dictionary<string, T>> dependencyTable, string primaryFile, string[] newFileSet, bool dependencyTableIncludesSourceFile)\n        {\n            if (!dependencyTable.TryGetValue(primaryFile, out var value))\n            {\n                return false;\n            }\n            if (value.Count != newFileSet.GetLength(0) + (dependencyTableIncludesSourceFile ? 1 : 0))\n            {\n                return false;\n            }\n            foreach (string key in newFileSet)\n            {", "            foreach (string key in newFileSet)\n            {\n                if (!value.ContainsKey(key))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.Framework/NativeMethods.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Microsoft.Build.Framework\n{\n    internal class NativeMethods\n    {\n        static DateTime LastWriteFileUtcTime(string path)\n        {\n            DateTime result = DateTime.MinValue;\n#if __", "                if (IsWindows)\n                {\n                    if (Traits.Instance.EscapeHatches.AlwaysUseContentTimestamp)\n                    {\n                        return GetContentLastWriteFileUtcTime(path);\n                    }\n                    WIN32_FILE_ATTRIBUTE_DATA lpFileInformation = default(WIN32_FILE_ATTRIBUTE_DATA);\n                    if (GetFileAttributesEx(path, 0, ref lpFileInformation) && (lpFileInformation.fileAttributes & 0x10) == 0)\n                    {\n                        result = DateTime.FromFileTimeUtc((long)(((ulong)lpFileInformation.ftLastWriteTimeHigh << 32) | lpFileInformation.ftLastWriteTimeLow));\n                        if ((lpFileInformation.fileAttributes & 0x400) == 1024 && !Traits.Instance.EscapeHatches.UseSymlinkTimeInsteadOfTargetTime)\n                        {\n                            result = GetContentLastWriteFileUtcTime(path);\n                        }\n                    }\n                    return result;\n                }\n#endif", "                        if ((lpFileInformation.fileAttributes & 0x400) == 1024 && !Traits.Instance.EscapeHatches.UseSymlinkTimeInsteadOfTargetTime)\n                        {\n                            result = GetContentLastWriteFileUtcTime(path);\n                        }\n                    }\n                    return result;\n                }\n#endif\n            if (!File.Exists(path))\n            {\n                return DateTime.MinValue;\n            }\n            return File.GetLastWriteTimeUtc(path);\n        }\n\n        internal static DateTime GetLastWriteFileUtcTime(string fullPath)\n        {\n#if __", "            if (!File.Exists(path))\n            {\n                return DateTime.MinValue;\n            }\n            return File.GetLastWriteTimeUtc(path);\n        }\n\n        internal static DateTime GetLastWriteFileUtcTime(string fullPath)\n        {\n#if __\n            if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)\n            {\n                return LastWriteFileUtcTime(fullPath);\n            }\n            bool flag = FileClassifier.Shared.IsNonModifiable(fullPath);\n#else\n            bool flag = true;\n#endif\n", "            if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)\n            {\n                return LastWriteFileUtcTime(fullPath);\n            }\n            bool flag = FileClassifier.Shared.IsNonModifiable(fullPath);\n#else\n            bool flag = true;\n#endif\n\n            if (flag && ImmutableFilesTimestampCache.Shared.TryGetValue(fullPath, out var lastModified))\n            {\n                return lastModified;\n            }\n            DateTime dateTime = LastWriteFileUtcTime(fullPath);", "            if (flag && ImmutableFilesTimestampCache.Shared.TryGetValue(fullPath, out var lastModified))\n            {\n                return lastModified;\n            }\n            DateTime dateTime = LastWriteFileUtcTime(fullPath);\n            if (flag && dateTime != DateTime.MinValue)\n            {\n                ImmutableFilesTimestampCache.Shared.TryAdd(fullPath, dateTime);\n            }\n            return dateTime;\n\n        }\n\n    }\n}\n"]}
{"filename": "Microsoft.Build.Framework/ImmutableFilesTimestampCache.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Microsoft.Build.Framework\n{\n    internal class ImmutableFilesTimestampCache\n    {\n        private readonly ConcurrentDictionary<string, DateTime> _cache = new ConcurrentDictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);\n", "        private readonly ConcurrentDictionary<string, DateTime> _cache = new ConcurrentDictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);\n\n        public static ImmutableFilesTimestampCache Shared { get; } = new ImmutableFilesTimestampCache();\n\n\n        public bool TryGetValue(string fullPath, out DateTime lastModified)\n        {\n            return _cache.TryGetValue(fullPath, out lastModified);\n        }\n\n        public void TryAdd(string fullPath, DateTime lastModified)\n        {\n            _cache.TryAdd(fullPath, lastModified);\n        }\n    }\n}\n", "        public void TryAdd(string fullPath, DateTime lastModified)\n        {\n            _cache.TryAdd(fullPath, lastModified);\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.CppTasks.Common/VCMessage.cs", "chunked_list": ["\ufeffusing Microsoft.Build.Framework;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.Build.CppTasks.Common\n{\n    public class VCMessage : Microsoft.Build.Utilities.Task\n    {", "namespace Microsoft.Build.CppTasks.Common\n{\n    public class VCMessage : Microsoft.Build.Utilities.Task\n    {\n        private string code;\n\n        private string type;\n\n        private string _importance;\n\n        private string arguments;\n\n        [Required]", "        private string _importance;\n\n        private string arguments;\n\n        [Required]\n        public string Code\n        {\n            get\n            {\n                return code;\n            }\n            set\n            {\n                code = value;\n            }\n        }\n", "        public string Type\n        {\n            get\n            {\n                return type;\n            }\n            set\n            {\n                type = value;\n            }\n        }\n", "        public string Importance\n        {\n            get\n            {\n                return _importance;\n            }\n            set\n            {\n                _importance = value;\n            }\n        }\n", "        public string Arguments\n        {\n            get\n            {\n                return arguments;\n            }\n            set\n            {\n                arguments = value;\n            }\n        }\n", "        private static object[] ParseArguments(string arguments)\n        {\n            if (string.IsNullOrEmpty(arguments))\n            {\n                return null;\n            }\n            List<string> list = new List<string>();\n            bool flag = false;\n            int i = 0;\n            int num = 0;\n            for (; i < arguments.Length; i++)\n            {", "            for (; i < arguments.Length; i++)\n            {\n                if (arguments[i] == ';' && !flag)\n                {\n                    list.Add(arguments.Substring(num, i - num).Replace(\"\\\\;\", \";\"));\n                    num = i + 1;\n                }\n                else if (i == arguments.Length - 1)\n                {\n                    list.Add(arguments.Substring(num, i - num + 1).Replace(\"\\\\;\", \";\"));\n                }\n                flag = arguments[i] == '\\\\';\n            }\n            return list.ToArray();\n        }\n\n        public VCMessage()\n            : base(Microsoft.Build.CppTasks.Common.Properties.Microsoft_Build_CPPTasks_Strings.ResourceManager)\n        {\n            \n        }\n", "        public override bool Execute()\n        {\n            if (string.IsNullOrEmpty(Type))\n            {\n                Type = \"Warning\";\n            }\n            try\n            {\n                if (string.Equals(Type, \"Warning\", StringComparison.OrdinalIgnoreCase))\n                {\n                    Log.LogWarningWithCodeFromResources(\"VCMessage.\" + Code, ParseArguments(Arguments));\n                    return true;\n                }", "                if (string.Equals(Type, \"Warning\", StringComparison.OrdinalIgnoreCase))\n                {\n                    Log.LogWarningWithCodeFromResources(\"VCMessage.\" + Code, ParseArguments(Arguments));\n                    return true;\n                }\n                if (string.Equals(Type, \"Error\", StringComparison.OrdinalIgnoreCase))\n                {\n                    Log.LogErrorWithCodeFromResources(\"VCMessage.\" + Code, ParseArguments(Arguments));\n                    return false;\n                }\n                if (string.Equals(Type, \"Message\", StringComparison.OrdinalIgnoreCase))\n                {\n                    MessageImportance val = MessageImportance.Normal;\n                    try\n                    {\n                        val = (MessageImportance)Enum.Parse(typeof(MessageImportance), Importance, ignoreCase: true);\n                    }", "                if (string.Equals(Type, \"Message\", StringComparison.OrdinalIgnoreCase))\n                {\n                    MessageImportance val = MessageImportance.Normal;\n                    try\n                    {\n                        val = (MessageImportance)Enum.Parse(typeof(MessageImportance), Importance, ignoreCase: true);\n                    }\n                    catch (ArgumentException)\n                    {\n                        Log.LogErrorWithCodeFromResources(\"Message.InvalidImportance\", new object[1] { Importance });\n                        return false;\n                    }\n                    Log.LogMessageFromResources(val, \"VCMessage.\" + Code, ParseArguments(Arguments));\n                    return true;\n                }\n                Log.LogErrorWithCodeFromResources(\"VCMessage.InvalidType\", new object[1] { Type });\n                return false;\n            }", "            catch (ArgumentException)\n            {\n                Log.LogErrorWithCodeFromResources(\"VCMessage.InvalidCode\", new object[1] { Code });\n                return false;\n            }\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.CppTasks.Common/SetEnv.cs", "chunked_list": ["\ufeffusing Microsoft.Build.Framework;\nusing System.Runtime.InteropServices;\nusing System.Xml.Linq;\n\nnamespace Microsoft.Build.CPPTasks.Common\n{\n    // https://learn.microsoft.com/zh-cn/visualstudio/msbuild/setenv-task?view=vs-2022\n    public class SetEnv : Microsoft.Build.Utilities.Task\n    {\n        private string val = string.Empty;\n        private string? outputEnvironmentVariable;\n\n        [Required]", "        private string val = string.Empty;\n        private string? outputEnvironmentVariable;\n\n        [Required]\n        public string Name { get; set; }\n\n\n        public string Value \n        {\n            get\n            {\n                return val;\n            }\n            set\n            {\n                val = value;\n            }\n        }\n\n        [Required]", "        public bool Prefix { get; set; }\n\n        public string Target { get; set; }\n        public string? Verbosity { get; set; }\n\n        [Output]\n        public string? OutputEnvironmentVariable => outputEnvironmentVariable;\n\n        public SetEnv()\n        {\n            Target = \"Process\";\n        }\n", "        public override bool Execute()\n        {\n            EnvironmentVariableTarget environmentVariableTarget = EnvironmentVariableTarget.Process;\n            if (string.Compare(Target, \"User\", StringComparison.OrdinalIgnoreCase) == 0)\n            {\n                environmentVariableTarget = EnvironmentVariableTarget.User;\n            }\n            else if (string.Compare(Target, \"Machine\", StringComparison.OrdinalIgnoreCase) == 0)\n            {\n                environmentVariableTarget = EnvironmentVariableTarget.Machine;\n            }", "            if (Prefix)\n            {\n                string environmentVariable = Environment.GetEnvironmentVariable(Name, environmentVariableTarget);\n                outputEnvironmentVariable = Environment.ExpandEnvironmentVariables(Value + environmentVariable);\n            }\n            else\n            {\n                outputEnvironmentVariable = Environment.ExpandEnvironmentVariables(Value);\n            }\n            Environment.SetEnvironmentVariable(Name, outputEnvironmentVariable, environmentVariableTarget);\n\n            MessageImportance importance = MessageImportance.Low;", "            if (!string.IsNullOrEmpty(Verbosity))\n            {\n                try\n                {\n                    importance = (MessageImportance)Enum.Parse(typeof(MessageImportance), Verbosity, ignoreCase: true);\n                }\n                catch(ArgumentException)\n                {\n                    // \u4ec0\u4e48\u4e5f\u4e0d\u505a\uff0c\u53cd\u6b63\u53ea\u662f\u4e2a\u8f93\u51fa\n                }\n            }\n\n\n            Log.LogMessage(importance, Name + \"=\" + outputEnvironmentVariable);\n\n            return true;\n        }\n    }\n}"]}
{"filename": "Microsoft.Build.CppTasks.Common/Properties/Microsoft.Build.CPPTasks.Strings.Designer.cs", "chunked_list": ["\ufeff//------------------------------------------------------------------------------\n// <auto-generated>\n//     \u6b64\u4ee3\u7801\u7531\u5de5\u5177\u751f\u6210\u3002\n//     \u8fd0\u884c\u65f6\u7248\u672c:4.0.30319.42000\n//\n//     \u5bf9\u6b64\u6587\u4ef6\u7684\u66f4\u6539\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4e0d\u6b63\u786e\u7684\u884c\u4e3a\uff0c\u5e76\u4e14\u5982\u679c\n//     \u91cd\u65b0\u751f\u6210\u4ee3\u7801\uff0c\u8fd9\u4e9b\u66f4\u6539\u5c06\u4f1a\u4e22\u5931\u3002\n// </auto-generated>\n//------------------------------------------------------------------------------\n", "//------------------------------------------------------------------------------\n\nnamespace Microsoft.Build.CppTasks.Common.Properties {\n    using System;\n    \n    \n    /// <summary>\n    ///   \u4e00\u4e2a\u5f3a\u7c7b\u578b\u7684\u8d44\u6e90\u7c7b\uff0c\u7528\u4e8e\u67e5\u627e\u672c\u5730\u5316\u7684\u5b57\u7b26\u4e32\u7b49\u3002\n    /// </summary>\n    // \u6b64\u7c7b\u662f\u7531 StronglyTypedResourceBuilder", "    /// </summary>\n    // \u6b64\u7c7b\u662f\u7531 StronglyTypedResourceBuilder\n    // \u7c7b\u901a\u8fc7\u7c7b\u4f3c\u4e8e ResGen \u6216 Visual Studio \u7684\u5de5\u5177\u81ea\u52a8\u751f\u6210\u7684\u3002\n    // \u82e5\u8981\u6dfb\u52a0\u6216\u79fb\u9664\u6210\u5458\uff0c\u8bf7\u7f16\u8f91 .ResX \u6587\u4ef6\uff0c\u7136\u540e\u91cd\u65b0\u8fd0\u884c ResGen\n    // (\u4ee5 /str \u4f5c\u4e3a\u547d\u4ee4\u9009\u9879)\uff0c\u6216\u91cd\u65b0\u751f\u6210 VS \u9879\u76ee\u3002\n    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Resources.Tools.StronglyTypedResourceBuilder\", \"17.0.0.0\")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]\n    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]\n    internal class Microsoft_Build_CPPTasks_Strings {\n        \n        private static global::System.Resources.ResourceManager resourceMan;\n        ", "    internal class Microsoft_Build_CPPTasks_Strings {\n        \n        private static global::System.Resources.ResourceManager resourceMan;\n        \n        private static global::System.Globalization.CultureInfo resourceCulture;\n        \n        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(\"Microsoft.Performance\", \"CA1811:AvoidUncalledPrivateCode\")]\n        internal Microsoft_Build_CPPTasks_Strings() {\n        }\n        \n        /// <summary>\n        ///   \u8fd4\u56de\u6b64\u7c7b\u4f7f\u7528\u7684\u7f13\u5b58\u7684 ResourceManager \u5b9e\u4f8b\u3002\n        /// </summary>\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]\n        internal static global::System.Resources.ResourceManager ResourceManager {\n            get {", "                if (object.ReferenceEquals(resourceMan, null)) {\n                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager(\"Microsoft.Build.CppTasks.Common.Properties.Microsoft.Build.CPPTasks.Strings\", typeof(Microsoft_Build_CPPTasks_Strings).Assembly);\n                    resourceMan = temp;\n                }\n                return resourceMan;\n            }\n        }\n        \n        /// <summary>\n        ///   \u91cd\u5199\u5f53\u524d\u7ebf\u7a0b\u7684 CurrentUICulture \u5c5e\u6027\uff0c\u5bf9\n        ///   \u4f7f\u7528\u6b64\u5f3a\u7c7b\u578b\u8d44\u6e90\u7c7b\u7684\u6240\u6709\u8d44\u6e90\u67e5\u627e\u6267\u884c\u91cd\u5199\u3002\n        /// </summary>\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]\n        internal static global::System.Globalization.CultureInfo Culture {\n            get {\n                return resourceCulture;\n            }\n            set {\n                resourceCulture = value;\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Element &lt;{0}&gt; has an invalid value of &quot;{1}&quot;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string ArgumentOutOfRange {\n            get {\n                return ResourceManager.GetString(\"ArgumentOutOfRange\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Switch &lt;{0}&gt; requires an argument. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string ArgumentRequired {\n            get {\n                return ResourceManager.GetString(\"ArgumentRequired\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c {0}Reference &apos;{1}&apos;=&apos;{2}&apos;  is ignored as &apos;{1}&apos;=&apos;{3}&apos; already exists.  \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string BMIAlreadyReferenced {\n            get {\n                return ResourceManager.GetString(\"BMIAlreadyReferenced\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Building header unit {0} as {1} imports it. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string BuildingHeaderUnit {\n            get {\n                return ResourceManager.GetString(\"BuildingHeaderUnit\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8078: Cannot delete old &apos;{0}&apos; tlog files: {1} \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string CannotDeleteTlogs {\n            get {\n                return ResourceManager.GetString(\"CannotDeleteTlogs\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Forcing recompile of all source files due to missing PDB &quot;{0}&quot;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string CL_RebuildingNoPDB {\n            get {\n                return ResourceManager.GetString(\"CL.RebuildingNoPDB\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Expected &quot;{0}&quot; but got &quot;{1}&quot;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string CommandLineDiffer {\n            get {\n                return ResourceManager.GetString(\"CommandLineDiffer\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Compiling... \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string Compiling {\n            get {\n                return ResourceManager.GetString(\"Compiling\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8017: A circular dependency has been detected while executing custom build commands for item &quot;{0}&quot;. This may cause incremental build to work incorrectly. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string CustomBuild_CircularDepedencyDetected {\n            get {\n                return ResourceManager.GetString(\"CustomBuild.CircularDepedencyDetected\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8066: Custom build for &apos;{0}&apos; exited with code {1}. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string CustomBuild_ExitCodeError {\n            get {\n                return ResourceManager.GetString(\"CustomBuild.ExitCodeError\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8062: Custom build for item &quot;{0}&quot; specifies invalid path &quot;{1}&quot; as an additional dependency. This may cause incremental build to work incorrectly. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string CustomBuild_InvalidDependency {\n            get {\n                return ResourceManager.GetString(\"CustomBuild.InvalidDependency\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8063: Custom build for item &quot;{0}&quot; specifies invalid path &quot;{1}&quot; as an output. This may cause incremental build to work incorrectly. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string CustomBuild_InvalidOutput {\n            get {\n                return ResourceManager.GetString(\"CustomBuild.InvalidOutput\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8064: Custom build for item &quot;{0}&quot; succeeded, but specified dependency &quot;{1}&quot; does not exist. This may cause incremental build to work incorrectly. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string CustomBuild_MissingDependency {\n            get {\n                return ResourceManager.GetString(\"CustomBuild.MissingDependency\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8065: Custom build for item &quot;{0}&quot; succeeded, but specified output &quot;{1}&quot; has not been created. This may cause incremental build to work incorrectly. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string CustomBuild_MissingOutput {\n            get {\n                return ResourceManager.GetString(\"CustomBuild.MissingOutput\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8018: No outputs specified for item &quot;{0}&quot;. Its custom build command will be skipped. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string CustomBuild_NoOutputs {\n            get {\n                return ResourceManager.GetString(\"CustomBuild.NoOutputs\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Performing Custom Build Step \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string CustomBuildStepMessage {\n            get {\n                return ResourceManager.GetString(\"CustomBuildStepMessage\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Required file &quot;{0}&quot; is missing. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string Error_MissingFile {\n            get {\n                return ResourceManager.GetString(\"Error.MissingFile\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Unable to open file {0} because {1} \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string FileNotOpen {\n            get {\n                return ResourceManager.GetString(\"FileNotOpen\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB3098: &quot;{1}&quot; task received an invalid value for the &quot;{0}&quot; parameter. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string General_InvalidValue {\n            get {\n                return ResourceManager.GetString(\"General.InvalidValue\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Error generating command line switch for &apos;{0}&apos; with value &apos;{1}&apos;: {2} \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string GenerateCommandLineError {\n            get {\n                return ResourceManager.GetString(\"GenerateCommandLineError\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Remote deployment might be slow/inefficient. {0} \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string GenerateDesktopDeployRecipeFileException {\n            get {\n                return ResourceManager.GetString(\"GenerateDesktopDeployRecipeFileException\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c &quot;The build of &apos;{0}&apos; depends on &apos;{1}&apos; which is produced by the build of &apos;{2}&apos;. The items cannot be built in parallel.&quot; \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string GetOutOfDateItems_ItemDependsOnAnotherItemOutput {\n            get {\n                return ResourceManager.GetString(\"GetOutOfDateItems.ItemDependsOnAnotherItemOutput\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Source file &apos;{0}&apos; is not up-to-date: list of dependencies has changed since the last build. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string GetOutOfDateItems_RebuildingSourceDependenciesChanged {\n            get {\n                return ResourceManager.GetString(\"GetOutOfDateItems.RebuildingSourceDependenciesChanged\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Source file &apos;{0}&apos; is not up-to-date: list of outputs has changed since the last build. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string GetOutOfDateItems_RebuildingSourceOutputsChanged {\n            get {\n                return ResourceManager.GetString(\"GetOutOfDateItems.RebuildingSourceOutputsChanged\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Element &lt;{0}&gt; has invalid type of &quot;{1}&quot;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string ImproperType {\n            get {\n                return ResourceManager.GetString(\"ImproperType\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Internal Error has occurred. Most likely a bug. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string InternalError {\n            get {\n                return ResourceManager.GetString(\"InternalError\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Expecting &quot;{0}&quot;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string InvalidType {\n            get {\n                return ResourceManager.GetString(\"InvalidType\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB3511: &quot;{0}&quot; is an invalid value for the &quot;Importance&quot; parameter. Valid values are: High, Normal and Low. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string Message_InvalidImportance {\n            get {\n                return ResourceManager.GetString(\"Message.InvalidImportance\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c To improve incremental build performance for managed components, please make sure that the &apos;VC++ Directories-&gt;Reference Directories&apos; points to all the paths which contain the referenced managed assemblies. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string MetaGenInfoReferenceDirectories {\n            get {\n                return ResourceManager.GetString(\"MetaGenInfoReferenceDirectories\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Element &lt;{0}&gt; does not contain the required attribute &quot;{1}&quot;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string MissingAttribute {\n            get {\n                return ResourceManager.GetString(\"MissingAttribute\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Missing required argument &lt;{0}&gt; for property &lt;{1}&gt;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string MissingRequiredArgument {\n            get {\n                return ResourceManager.GetString(\"MissingRequiredArgument\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Missing required argument &lt;{0}&gt; for property &lt;{1}&gt; which is set to {2}. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string MissingRequiredArgumentWithValue {\n            get {\n                return ResourceManager.GetString(\"MissingRequiredArgumentWithValue\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Xml file must start with the root element &lt;{0}&gt;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string MissingRootElement {\n            get {\n                return ResourceManager.GetString(\"MissingRootElement\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8074: Cannot read Module Dependencies file {0}: {1} The build order might be incorrect. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string ModuleDependencies_JsonReadingError {\n            get {\n                return ResourceManager.GetString(\"ModuleDependencies.JsonReadingError\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8067: Unexpected number of sources &apos;{0}&apos; in Module Dependencies file &apos;{1}&apos;. Only one source data is currenty supported. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string ModuleDependencies_UnexpectedJsonData {\n            get {\n                return ResourceManager.GetString(\"ModuleDependencies.UnexpectedJsonData\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Unable to move file &quot;{0}&quot; to &quot;{1}&quot;. {2} \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string Move_Error {\n            get {\n                return ResourceManager.GetString(\"Move.Error\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Moving file from &quot;{0}&quot; to &quot;{1}&quot;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string Move_FileComment {\n            get {\n                return ResourceManager.GetString(\"Move.FileComment\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c {0} will run on {1} out of {2} file(s) in {4} batches.  Startup phase took {3}ms. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string MultiTool_AddDone {\n            get {\n                return ResourceManager.GetString(\"MultiTool.AddDone\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Adding source &quot;{0}&quot;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string MultiTool_AddSource {\n            get {\n                return ResourceManager.GetString(\"MultiTool.AddSource\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Adding source &quot;{0}&quot; with dependency on &quot;{1}&quot;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string MultiTool_AddSourceWithDep {\n            get {\n                return ResourceManager.GetString(\"MultiTool.AddSourceWithDep\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Building with &quot;{0}&quot;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string MultiTool_BuildingWith {\n            get {\n                return ResourceManager.GetString(\"MultiTool.BuildingWith\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Cannot build the following source files because there is a cyclic dependency between them: {0}. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string MultiTool_CyclicDependency {\n            get {\n                return ResourceManager.GetString(\"MultiTool.CyclicDependency\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MultiToolTask has encounted an issue scheduling task because one or more tasks still remains but none could be started.  Please check the inputs and their dependency to avoid cirular loops. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string MultiTool_DependencyIssue {\n            get {\n                return ResourceManager.GetString(\"MultiTool.DependencyIssue\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Cleanup phase took {0}ms. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string MultiTool_PostExecuteToolTiming {\n            get {\n                return ResourceManager.GetString(\"MultiTool.PostExecuteToolTiming\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c All Sources must have the same TrackerLogDirectory ({0},{1}). \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string MultiTool_SameTrackerLogDirectory {\n            get {\n                return ResourceManager.GetString(\"MultiTool.SameTrackerLogDirectory\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Source &quot;{0}&quot; doesn&apos;t match previous command line.\n        ///*** Previous command line: &apos;{1}&apos;\n        ///*** Current  command line: &apos;{2}&apos; \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string MultiTool_SourceNotMatchCommand {\n            get {\n                return ResourceManager.GetString(\"MultiTool.SourceNotMatchCommand\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Source &quot;{0}&quot; is out of date. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string MultiTool_SourceOutOfDate {\n            get {\n                return ResourceManager.GetString(\"MultiTool.SourceOutOfDate\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c {0} task found. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string MultiTool_TaskFound {\n            get {\n                return ResourceManager.GetString(\"MultiTool.TaskFound\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Task &apos;{0}&apos; took {1}ms. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string MultiTool_TaskStatus {\n            get {\n                return ResourceManager.GetString(\"MultiTool.TaskStatus\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Tracking command: \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string Native_TrackingCommandMessage {\n            get {\n                return ResourceManager.GetString(\"Native_TrackingCommandMessage\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c {0}Referencing &apos;{1}&apos;=&apos;{2}&apos;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string ReferencingBMI {\n            get {\n                return ResourceManager.GetString(\"ReferencingBMI\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Scanning sources for module dependencies... \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string Scanning {\n            get {\n                return ResourceManager.GetString(\"Scanning\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB5003: Failed to create a temporary file. Temporary files folder is full or its path is incorrect. {0} \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string Shared_FailedCreatingTempFile {\n            get {\n                return ResourceManager.GetString(\"Shared.FailedCreatingTempFile\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Parameter &quot;{0}&quot; cannot be null. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string Shared_ParameterCannotBeNull {\n            get {\n                return ResourceManager.GetString(\"Shared.ParameterCannotBeNull\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Parameter &quot;{0}&quot; cannot have zero length. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string Shared_ParameterCannotHaveZeroLength {\n            get {\n                return ResourceManager.GetString(\"Shared.ParameterCannotHaveZeroLength\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Parameters &quot;{0}&quot; and &quot;{1}&quot; must have the same number of elements. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string Shared_ParametersMustHaveTheSameLength {\n            get {\n                return ResourceManager.GetString(\"Shared.ParametersMustHaveTheSameLength\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c {0} depends on {1} \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string SourceDependsOnSource {\n            get {\n                return ResourceManager.GetString(\"SourceDependsOnSource\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8071: Cannot parse tool output &apos;{0}&apos; with regex &apos;{1}&apos;: {2} \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string TrackedVCToolTask_CannotParseToolOutput {\n            get {\n                return ResourceManager.GetString(\"TrackedVCToolTask.CannotParseToolOutput\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8016: Can not turn on Unicode output for &quot;{0}&quot;. Some Unicode characters will be improperly displayed. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string TrackedVCToolTask_CreateUnicodeOutputPipeFailed {\n            get {\n                return ResourceManager.GetString(\"TrackedVCToolTask.CreateUnicodeOutputPipeFailed\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c All source files are not up-to-date:  command line has changed since the last build. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string TrackedVCToolTask_RebuildingAllSourcesCommandLineChanged {\n            get {\n                return ResourceManager.GetString(\"TrackedVCToolTask.RebuildingAllSourcesCommandLineChanged\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8014: All source files are not up-to-date:  forcing a rebuild of all sources due to an error with the tracking logs. {0} \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string TrackedVCToolTask_RebuildingDueToInvalidTLog {\n            get {\n                return ResourceManager.GetString(\"TrackedVCToolTask.RebuildingDueToInvalidTLog\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8015: All source files are not up-to-date:  forcing a rebuild of all source files due to the contents of &apos;{0}&apos; being invalid. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string TrackedVCToolTask_RebuildingDueToInvalidTLogContents {\n            get {\n                return ResourceManager.GetString(\"TrackedVCToolTask.RebuildingDueToInvalidTLogContents\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c All source files are not up-to-date: missing command TLog &quot;{0}&quot;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string TrackedVCToolTask_RebuildingNoCommandTLog {\n            get {\n                return ResourceManager.GetString(\"TrackedVCToolTask.RebuildingNoCommandTLog\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Source file &quot;{0}&quot; is not up-to-date: command line has changed since the last build. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string TrackedVCToolTask_RebuildingSourceCommandLineChanged {\n            get {\n                return ResourceManager.GetString(\"TrackedVCToolTask.RebuildingSourceCommandLineChanged\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c &quot;The following files previously generated for unity build were deleted as they are no longer used: {0}.  \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string Unity_CleanupOldUnityFiles {\n            get {\n                return ResourceManager.GetString(\"Unity_CleanupOldUnityFiles\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c &quot;Minimum Number of Sources in a Unity File&quot; ({0}) cannot be more than &quot;Maximum Number of Sources in a Unity File&quot; ({1}).  \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string Unity_MinMoreThanMax {\n            get {\n                return ResourceManager.GetString(\"Unity_MinMoreThanMax\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8001: &quot;{0}&quot; is an invalid value for the &quot;Code&quot; parameter. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_InvalidCode {\n            get {\n                return ResourceManager.GetString(\"VCMessage.InvalidCode\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8000: &quot;{0}&quot; is an invalid value for the &quot;Type&quot; parameter. Valid values are: Warning and Error. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_InvalidType {\n            get {\n                return ResourceManager.GetString(\"VCMessage.InvalidType\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8002: Specified platform toolset ({0}) is not compatible with the targeted .NET Framework version ({1}). Please set TargetFrameworkVersion to one of the supported values (&apos;v2.0&apos;, &apos;v3.0&apos;, &apos;v3.5&apos;). \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8002 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8002\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8003: The {0} property is not defined. Some build tools may not be found. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8003 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8003\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8004: {0} Directory does not end with a trailing slash.  This build instance will add the slash as it is required to allow proper evaluation of the {1} Directory. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8004 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8004\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8005: The property &apos;{0}&apos; doesn&apos;t exist.  Skipping... \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8005 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8005\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8006: The Platform for project &apos;{0}&apos; is invalid.  Platform=&apos;{1}&apos;. This error may also appear if some other project is trying to follow a project-to-project reference to this project, this project has been unloaded or is not included in the solution, and the referencing project does not build using the same or an equivalent Platform. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8006 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8006\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8007: The Platform for project &apos;{0}&apos; is invalid.  Platform=&apos;{1}&apos;. You may be seeing this message because you are trying to build a project without a solution file, and have specified a non-default Platform that doesn&apos;t exist for this project. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8007 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8007\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8008: Specified platform toolset ({0}) is not installed or invalid. Please make sure that a supported PlatformToolset value is selected. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8008 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8008\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8009: .NET Framework 2.0/3.0/3.5 target the v90 platform toolset. Please make sure that Visual Studio 2008 is installed on the machine. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8009 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8009\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8010: Specified platform toolset (v90) requires Visual Studio 2008. Please make sure that Visual Studio 2008 is installed on the machine. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8010 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8010\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8011: Failed to register output. Please try enabling Per-user Redirection or register the component from a command prompt with elevated permissions. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8011 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8011\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8012: {0}({1}) does not match the {2}&apos;s OutputFile property value ({3}). This may cause your project to build incorrectly. To correct this, please make sure that $(OutDir), $(TargetName) and $(TargetExt) property values match the value specified in %({4}.OutputFile). \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8012 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8012\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8013: This project doesn&apos;t contain the Configuration and Platform combination of {0}. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8013 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8013\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8016: This project does not support the current Configuration Type ({0}). \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8016 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8016\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8019: This build is consuming a component &quot;{0}&quot; that is not packaged because the component is not coming from a Windows Store app project &quot;{1}&quot;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8019 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8019\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8020: The build tools for {0} (Platform Toolset = &apos;{1}&apos;) cannot be found. To build using the {1} build tools, please install {0} build tools.  Alternatively, you may upgrade to the current Visual Studio tools by selecting the Project menu or right-click the solution, and then selecting &quot;Retarget solution&quot;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8020 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8020\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8020: The build tools for &apos;{2}&apos; application Type {0} (Platform Toolset = &apos;{1}&apos;) cannot be found. Please install the workflow for this application type and include the build tools for the  \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8020_AppType {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8020_AppType\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8021: The value &apos;{0}&apos; of the variable &apos;{1}&apos; is incompatible with the value &apos;{2}&apos; of the variable &apos;{3}&apos;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8021 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8021\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8022: Building Desktop applications for the {0} platform is not supported. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8022 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8022\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8023: Execution path ({0}) could not be found. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8023 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8023\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8024: Using static version of the C++ runtime library is not supported. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8024 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8024\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8025: Using legacy manifest embedding because of {0} on Manifest Tool is set. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8025 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8025\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8026: Static analysis is not supported with the current platform toolset. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8026 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8026\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8027: Two or more files with the name of {0} will produce outputs to the same location. This can lead to an incorrect build result.  The files involved are {1}. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8027 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8027\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8028: The intermediate directory ({1}) contains files shared from another project ({0}).  This can lead to incorrect clean and rebuild behavior. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8028 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8028\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8029: The Intermediate directory or Output directory cannot reside under the Temporary directory as it could lead to issues with incremental build. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8029 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8029\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8030: The linker switch &quot;Minimum Required Version&quot; requires &quot;SubSystem&quot; to be set.  Without &quot;SubSystem&quot;, the &quot;Minimum Required Version&quot; would not be passed to linker and could prevent to the output binary from running on older Operating Systems. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8030 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8030\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8031: Building an MFC project for a non-Unicode character set is deprecated. You must change the project property to Unicode or download an additional library. See https://go.microsoft.com/fwlink/p/?LinkId=286820 for more information. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8031 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8031\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8032: The Platform or PlatformToolset is not available from a 64bit environment.  Consider building from 32bit environment instead. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8032 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8032\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c {0} -&gt; {1} (Partial PDB) \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8033 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8033\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8033: Cannot determine a remote location corresponding to {0} directory on local machine. Some files might not be found during remote build. Please change the properties to use relative paths or add a local-remote folders mapping in Tools - Options - Cross Platform \u2013 C++ - iOS - Mapping. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8033_RemoteBuild_MissingDirectoryMapping {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8033.RemoteBuild.MissingDirectoryMapping\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c {0} -&gt; {1} (Full PDB) \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8034 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8034\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c {0} -&gt; {1} (Partial -&gt; Full PDB) \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8035 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8035\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8035: Root folder for local relative paths is not defined, but relative path {0} is used. Please change it to a full path or define root folder. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8035_RemoteBuild_MissingRootFolderForLocalRelativePaths {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8035.RemoteBuild.MissingRootFolderForLocalRelativePaths\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8036: The Windows SDK version {0} was not found. Install the required version of Windows SDK or change the SDK version in the project property pages or by right-clicking the solution and selecting &quot;Retarget solution&quot;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8036 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8036\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8037: The Windows SDK version {0} for Desktop C++ {1} Apps was not found. Install the required version of Windows SDK or change the SDK version in the project property pages or by right-clicking the solution and selecting &quot;Retarget solution&quot;.  \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8037 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8037\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8038: Platform Toolset is not defined. Please select one of the available Platform Toolsets in the Project Properties UI. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8038 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8038\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Warning: Full debug symbol generation from partial PDBs is not supported for static libraries. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8039 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8039\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8040: Spectre-mitigated libraries are required for this project. Install them from the Visual Studio installer (Individual components tab) for any toolsets and architectures being used. Learn more: https://aka.ms/Ofhn4c \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8040 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8040\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8041: {0} libraries are required for this project. Install them from the Visual Studio installer (Individual Components tab) for any toolsets and architectures being used. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8041 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8041\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8042: {0} libraries with Spectre Mitigations are required for this project. Install them from the Visual Studio installer (Individual components tab) for any toolsets and architectures being used. Learn more: https://aka.ms/Ofhn4c \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8042 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8042\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8051: Support for targeting Windows XP is deprecated and will not be present in future releases of Visual Studio. Please see https://go.microsoft.com/fwlink/?linkid=2023588 for more information. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8051 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8051\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8053: /clr (common language runtime) not supported by clang-cl. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8053 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8053\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8054: /ZW (WinRT language extensions) not supported by clang-cl. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8054 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8054\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8055: /openmp (OpenMP language extensions) not supported not supported by clang-cl. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8055 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8055\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8056: /experimental:module not supported by clang-cl. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8056 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8056\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8057: &apos;C++ Clang tools for Windows (15.0.1 - x64/x86)&apos; component is not installed in Visual Studio.  Open the &apos;Visual Studio Installer&apos; and install &apos;C++ Clang tools for Windows (15.0.1 - x64/x86)&apos; under the &apos;Desktop development with C++&apos; workload.  Learn more: https://aka.ms/AA55s5p  \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8057 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8057\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8058: -fsanitize=address (Enable Address Sanitizer) not supported by platform &apos;{0}&apos;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8058 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8058\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8059: -fsanitize=address (Enable Address Sanitizer) is incompatible with option &apos;{0}&apos;. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8059 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8059\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8060: Microsoft Code Analysis is not supported by clang-cl. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8060 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8060\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8061: No tool enabled for Code Analysis. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8061 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8061\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8072: /std:c++latest (MSVC preview - features from the latest C++ working draft ) not supported by clang-cl. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8072 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8072\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8073: Cannot find LLVM toolset version &apos;{0}&apos;: the folder &apos;{1}&apos; does not exist. Please make sure LLVM toolset version &apos;{0}&apos; is installed or choose another toolset version. Learn more: https://aka.ms/AA55s5p \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8073 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8073\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8075: We do not support building UWP AppContainer applications for ARM64EC. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8075 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8075\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8076: Only ARM, ARM64 and ARM64EC platforms are supported. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8076 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8076\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8077: Some files are set to compile as C++/CLI, but &apos;Enable CLR Support for Individual Files&apos; property is not defined. See &apos;Advanced Property Page&apos; documentation for more details. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCMessage_MSB8077 {\n            get {\n                return ResourceManager.GetString(\"VCMessage.MSB8077\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Adding the project to the build agent... \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_AddingProject {\n            get {\n                return ResourceManager.GetString(\"VCRemote.AddingProject\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Adding the sources to the build agent... \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_AddingSources {\n            get {\n                return ResourceManager.GetString(\"VCRemote.AddingSources\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Remote build failed, a remote machine has not been configured for build or the connection was lost. If a machine was not paired, please pair it by using the instructions in this link: {0} \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_BuildFailed {\n            get {\n                return ResourceManager.GetString(\"VCRemote.BuildFailed\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Remote build failed, please see the Output Window - Build output for more details. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_BuildFailedSeeOutputWindow {\n            get {\n                return ResourceManager.GetString(\"VCRemote.BuildFailedSeeOutputWindow\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Building the project on the build agent... \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_BuildingProject {\n            get {\n                return ResourceManager.GetString(\"VCRemote.BuildingProject\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Building the source maps... \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_BuildingSourceMap {\n            get {\n                return ResourceManager.GetString(\"VCRemote.BuildingSourceMap\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c {0}.vcxproj -&gt; host: {1}  output: {2}/{3}{4} \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_BuildOutput {\n            get {\n                return ResourceManager.GetString(\"VCRemote.BuildOutput\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Build started on the build agent. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_BuildStarted {\n            get {\n                return ResourceManager.GetString(\"VCRemote.BuildStarted\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Copying remote build output to: {0}. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_CopyingBuildOutput {\n            get {\n                return ResourceManager.GetString(\"VCRemote.CopyingBuildOutput\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c The file &apos;{0}&apos; will not be added to the build agent because it is invalid. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_FileInvalid {\n            get {\n                return ResourceManager.GetString(\"VCRemote.FileInvalid\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c The file &apos;{0}&apos; will not be added to the build agent because it does not exist. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_FileNotExist {\n            get {\n                return ResourceManager.GetString(\"VCRemote.FileNotExist\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Finished adding the project to the build agent. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_FinishedAddingProject {\n            get {\n                return ResourceManager.GetString(\"VCRemote.FinishedAddingProject\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Finished adding the sources to the build agent. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_FinishedAddingSources {\n            get {\n                return ResourceManager.GetString(\"VCRemote.FinishedAddingSources\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Finished building the project on the build agent. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_FinishedBuildingProject {\n            get {\n                return ResourceManager.GetString(\"VCRemote.FinishedBuildingProject\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Finished copying remote build output. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_FinishedCopyingBuildOutput {\n            get {\n                return ResourceManager.GetString(\"VCRemote.FinishedCopyingBuildOutput\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Remote output directory: {0} \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_RemoteOutputDirectory {\n            get {\n                return ResourceManager.GetString(\"VCRemote.RemoteOutputDirectory\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Remote project: {0} \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_RemoteProject {\n            get {\n                return ResourceManager.GetString(\"VCRemote.RemoteProject\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Remote project directory: {0} \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_RemoteProjectDirectory {\n            get {\n                return ResourceManager.GetString(\"VCRemote.RemoteProjectDirectory\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Waiting for the build to finish on the build agent... \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCRemote_WaitingForBuildToFinish {\n            get {\n                return ResourceManager.GetString(\"VCRemote.WaitingForBuildToFinish\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8052: MSVC Toolset Version &apos;{0}&apos; is not compatible with &apos;{1}&apos; Platform Toolset. Please either change Platform Toolset to {2} or MSVC Toolset Version (VCToolsVersion property) to  the version with the format &apos;{3}*.*&apos;. To use default MSVC Toolset Version for a given Platform Toolset don&apos;t set VCToolsVersion property. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCToolsVersionDoesNotMatchPlatformToolset {\n            get {\n                return ResourceManager.GetString(\"VCToolsVersionDoesNotMatchPlatformToolset\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c MSB8070: Cannot find MSVC toolset version &apos;{0}&apos;: the folder &apos;{1}&apos; does not exist. Please make sure MSVC toolset version &apos;{0}&apos; is  installed or choose another toolset version. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string VCToolsVersionNotInstaled {\n            get {\n                return ResourceManager.GetString(\"VCToolsVersionNotInstaled\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Unable to create Xaml task.  Compilation failed.  {0} \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string XamlTaskCreationFailed {\n            get {\n                return ResourceManager.GetString(\"XamlTaskCreationFailed\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Unable to parse Xaml task.  {0} \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string XamlTaskParseFailed {\n            get {\n                return ResourceManager.GetString(\"XamlTaskParseFailed\", resourceCulture);\n            }\n        }\n        \n        /// <summary>\n        ///   \u67e5\u627e\u7c7b\u4f3c Xml Error: {0}. \u7684\u672c\u5730\u5316\u5b57\u7b26\u4e32\u3002\n        /// </summary>\n        internal static string XmlError {\n            get {\n                return ResourceManager.GetString(\"XmlError\", resourceCulture);\n            }\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.Utilities/CanonicalTrackedInputFiles.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.Build.Framework;\nusing Microsoft.Build.Shared;\nusing Microsoft.Build.Utilities;\n", "using Microsoft.Build.Utilities;\n\nnamespace Microsoft.Build.Utilities\n{\n    public class CanonicalTrackedInputFiles\n    {\n        private DateTime _outputNewestTime = DateTime.MinValue;\n\n        private ITaskItem[] _tlogFiles;\n\n        private ITaskItem[] _sourceFiles;\n", "        private TaskLoggingHelper _log;\n\n        private CanonicalTrackedOutputFiles _outputs;\n\n        private ITaskItem[] _outputFileGroup;\n\n        private ITaskItem[] _outputFiles;\n\n        private bool _useMinimalRebuildOptimization;\n\n        private bool _tlogAvailable;\n", "        private bool _useMinimalRebuildOptimization;\n\n        private bool _tlogAvailable;\n\n        private bool _maintainCompositeRootingMarkers;\n\n        private readonly HashSet<string> _excludedInputPaths = new HashSet<string>(StringComparer.Ordinal);\n\n        private readonly ConcurrentDictionary<string, DateTime> _lastWriteTimeCache = new ConcurrentDictionary<string, DateTime>(StringComparer.Ordinal);\n\n        internal ITaskItem[] SourcesNeedingCompilation { get; set; }\n\n        public Dictionary<string, Dictionary<string, string>> DependencyTable { get; private set; }\n\n        public CanonicalTrackedInputFiles(ITaskItem[] tlogFiles, ITaskItem[] sourceFiles, CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers)\n        {\n            InternalConstruct(null, tlogFiles, sourceFiles, null, null, outputs, useMinimalRebuildOptimization, maintainCompositeRootingMarkers);\n        }\n\n        public CanonicalTrackedInputFiles(ITaskItem[] tlogFiles, ITaskItem[] sourceFiles, ITaskItem[] excludedInputPaths, CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers)\n        {\n            InternalConstruct(null, tlogFiles, sourceFiles, null, excludedInputPaths, outputs, useMinimalRebuildOptimization, maintainCompositeRootingMarkers);\n        }\n\n        public CanonicalTrackedInputFiles(ITask ownerTask, ITaskItem[] tlogFiles, ITaskItem[] sourceFiles, ITaskItem[] excludedInputPaths, CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers)\n        {\n            InternalConstruct(ownerTask, tlogFiles, sourceFiles, null, excludedInputPaths, outputs, useMinimalRebuildOptimization, maintainCompositeRootingMarkers);\n        }\n\n        public CanonicalTrackedInputFiles(ITask ownerTask, ITaskItem[] tlogFiles, ITaskItem[] sourceFiles, ITaskItem[] excludedInputPaths, ITaskItem[] outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers)\n        {\n            InternalConstruct(ownerTask, tlogFiles, sourceFiles, outputs, excludedInputPaths, null, useMinimalRebuildOptimization, maintainCompositeRootingMarkers);\n        }\n\n        public CanonicalTrackedInputFiles(ITask ownerTask, ITaskItem[] tlogFiles, ITaskItem sourceFile, ITaskItem[] excludedInputPaths, CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers)\n        {\n            InternalConstruct(ownerTask, tlogFiles, new ITaskItem[1] { sourceFile }, null, excludedInputPaths, outputs, useMinimalRebuildOptimization, maintainCompositeRootingMarkers);\n        }\n", "        private readonly ConcurrentDictionary<string, DateTime> _lastWriteTimeCache = new ConcurrentDictionary<string, DateTime>(StringComparer.Ordinal);\n\n        internal ITaskItem[] SourcesNeedingCompilation { get; set; }\n\n        public Dictionary<string, Dictionary<string, string>> DependencyTable { get; private set; }\n\n        public CanonicalTrackedInputFiles(ITaskItem[] tlogFiles, ITaskItem[] sourceFiles, CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers)\n        {\n            InternalConstruct(null, tlogFiles, sourceFiles, null, null, outputs, useMinimalRebuildOptimization, maintainCompositeRootingMarkers);\n        }\n\n        public CanonicalTrackedInputFiles(ITaskItem[] tlogFiles, ITaskItem[] sourceFiles, ITaskItem[] excludedInputPaths, CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers)\n        {\n            InternalConstruct(null, tlogFiles, sourceFiles, null, excludedInputPaths, outputs, useMinimalRebuildOptimization, maintainCompositeRootingMarkers);\n        }\n\n        public CanonicalTrackedInputFiles(ITask ownerTask, ITaskItem[] tlogFiles, ITaskItem[] sourceFiles, ITaskItem[] excludedInputPaths, CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers)\n        {\n            InternalConstruct(ownerTask, tlogFiles, sourceFiles, null, excludedInputPaths, outputs, useMinimalRebuildOptimization, maintainCompositeRootingMarkers);\n        }\n\n        public CanonicalTrackedInputFiles(ITask ownerTask, ITaskItem[] tlogFiles, ITaskItem[] sourceFiles, ITaskItem[] excludedInputPaths, ITaskItem[] outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers)\n        {\n            InternalConstruct(ownerTask, tlogFiles, sourceFiles, outputs, excludedInputPaths, null, useMinimalRebuildOptimization, maintainCompositeRootingMarkers);\n        }\n\n        public CanonicalTrackedInputFiles(ITask ownerTask, ITaskItem[] tlogFiles, ITaskItem sourceFile, ITaskItem[] excludedInputPaths, CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers)\n        {\n            InternalConstruct(ownerTask, tlogFiles, new ITaskItem[1] { sourceFile }, null, excludedInputPaths, outputs, useMinimalRebuildOptimization, maintainCompositeRootingMarkers);\n        }\n", "        private void InternalConstruct(ITask ownerTask, ITaskItem[] tlogFiles, ITaskItem[] sourceFiles, ITaskItem[] outputFiles, ITaskItem[] excludedInputPaths, CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers)\n        {\n            if (ownerTask != null)\n            {\n                _log = new TaskLoggingHelper(ownerTask)\n                {\n                    TaskResources = Microsoft.Build.CppTasks.Common.Properties.Microsoft_Build_CPPTasks_Strings.ResourceManager,\n                    HelpKeywordPrefix = \"MSBuild.\"\n                };\n            }\n            _tlogFiles = TrackedDependencies.ExpandWildcards(tlogFiles);\n            _tlogAvailable = TrackedDependencies.ItemsExist(_tlogFiles);\n            _sourceFiles = sourceFiles;\n            _outputs = outputs;\n            _outputFiles = outputFiles;\n            _useMinimalRebuildOptimization = useMinimalRebuildOptimization;\n            _maintainCompositeRootingMarkers = maintainCompositeRootingMarkers;", "            if (excludedInputPaths != null)\n            {\n                for (int i = 0; i < excludedInputPaths.Length; i++)\n                {\n                    string item = FileUtilities.EnsureNoTrailingSlash(FileUtilities.NormalizePath(excludedInputPaths[i].ItemSpec))/*.ToUpperInvariant()*/;\n                    _excludedInputPaths.Add(item);\n                }\n            }\n            DependencyTable = new Dictionary<string, Dictionary<string, string>>(StringComparer.OrdinalIgnoreCase);\n            if (_tlogFiles != null)\n            {\n                ConstructDependencyTable();\n            }\n        }\n\n        public ITaskItem[] ComputeSourcesNeedingCompilation()\n        {\n            return ComputeSourcesNeedingCompilation(searchForSubRootsInCompositeRootingMarkers: true);\n        }\n\n        public ITaskItem[] ComputeSourcesNeedingCompilation(bool searchForSubRootsInCompositeRootingMarkers)\n        {", "            if (_tlogFiles != null)\n            {\n                ConstructDependencyTable();\n            }\n        }\n\n        public ITaskItem[] ComputeSourcesNeedingCompilation()\n        {\n            return ComputeSourcesNeedingCompilation(searchForSubRootsInCompositeRootingMarkers: true);\n        }\n\n        public ITaskItem[] ComputeSourcesNeedingCompilation(bool searchForSubRootsInCompositeRootingMarkers)\n        {", "            if (_outputFiles != null)\n            {\n                _outputFileGroup = _outputFiles;\n            }\n            else if (_sourceFiles != null && _outputs != null && _maintainCompositeRootingMarkers)\n            {\n                _outputFileGroup = _outputs.OutputsForSource(_sourceFiles, searchForSubRootsInCompositeRootingMarkers);\n            }\n            else if (_sourceFiles != null && _outputs != null)\n            {\n                _outputFileGroup = _outputs.OutputsForNonCompositeSource(_sourceFiles);\n            }", "            else if (_sourceFiles != null && _outputs != null)\n            {\n                _outputFileGroup = _outputs.OutputsForNonCompositeSource(_sourceFiles);\n            }\n            if (!_maintainCompositeRootingMarkers)\n            {\n                return ComputeSourcesNeedingCompilationFromPrimaryFiles();\n            }\n            return ComputeSourcesNeedingCompilationFromCompositeRootingMarker(searchForSubRootsInCompositeRootingMarkers);\n        }\n\n        private ITaskItem[] ComputeSourcesNeedingCompilationFromPrimaryFiles()\n        {", "            if (SourcesNeedingCompilation == null)\n            {\n                ConcurrentQueue<ITaskItem> sourcesNeedingCompilationList = new ConcurrentQueue<ITaskItem>();\n                bool allOutputFilesExist = false;\n                if (_tlogAvailable && !_useMinimalRebuildOptimization)\n                {\n                    allOutputFilesExist = FilesExistAndRecordNewestWriteTime(_outputFileGroup);\n                }\n                Parallel.For(0, _sourceFiles.Length, delegate (int index)\n                {\n                    CheckIfSourceNeedsCompilation(sourcesNeedingCompilationList, allOutputFilesExist, _sourceFiles[index]);\n                });\n                SourcesNeedingCompilation = sourcesNeedingCompilationList.ToArray();\n            }", "            if (SourcesNeedingCompilation.Length == 0)\n            {\n                FileTracker.LogMessageFromResources(_log, MessageImportance.Normal, \"Tracking_AllOutputsAreUpToDate\");\n                SourcesNeedingCompilation = Array.Empty<ITaskItem>();\n            }\n            else\n            {\n                Array.Sort(SourcesNeedingCompilation, CompareTaskItems);\n                ITaskItem[] sourcesNeedingCompilation = SourcesNeedingCompilation;\n                foreach (ITaskItem taskItem in sourcesNeedingCompilation)\n                {\n                    string metadata = taskItem.GetMetadata(\"_trackerModifiedPath\");\n                    string metadata2 = taskItem.GetMetadata(\"_trackerModifiedTime\");\n                    string metadata3 = taskItem.GetMetadata(\"_trackerOutputFile\");\n                    string metadata4 = taskItem.GetMetadata(\"_trackerCompileReason\");", "                foreach (ITaskItem taskItem in sourcesNeedingCompilation)\n                {\n                    string metadata = taskItem.GetMetadata(\"_trackerModifiedPath\");\n                    string metadata2 = taskItem.GetMetadata(\"_trackerModifiedTime\");\n                    string metadata3 = taskItem.GetMetadata(\"_trackerOutputFile\");\n                    string metadata4 = taskItem.GetMetadata(\"_trackerCompileReason\");\n                    if (string.Equals(metadata4, \"Tracking_SourceWillBeCompiledDependencyWasModifiedAt\", StringComparison.Ordinal))\n                    {\n                        FileTracker.LogMessageFromResources(_log, MessageImportance.Low, metadata4, taskItem.ItemSpec, metadata, metadata2);\n                    }\n                    else if (string.Equals(metadata4, \"Tracking_SourceWillBeCompiledMissingDependency\", StringComparison.Ordinal))\n                    {\n                        FileTracker.LogMessageFromResources(_log, MessageImportance.Low, metadata4, taskItem.ItemSpec, metadata);\n                    }", "                    else if (string.Equals(metadata4, \"Tracking_SourceWillBeCompiledMissingDependency\", StringComparison.Ordinal))\n                    {\n                        FileTracker.LogMessageFromResources(_log, MessageImportance.Low, metadata4, taskItem.ItemSpec, metadata);\n                    }\n                    else if (string.Equals(metadata4, \"Tracking_SourceWillBeCompiledOutputDoesNotExist\", StringComparison.Ordinal))\n                    {\n                        FileTracker.LogMessageFromResources(_log, MessageImportance.Low, metadata4, taskItem.ItemSpec, metadata3);\n                    }\n                    else\n                    {\n                        FileTracker.LogMessageFromResources(_log, MessageImportance.Low, metadata4, taskItem.ItemSpec);\n                    }\n                    taskItem.RemoveMetadata(\"_trackerModifiedPath\");\n                    taskItem.RemoveMetadata(\"_trackerModifiedTime\");\n                    taskItem.RemoveMetadata(\"_trackerOutputFile\");\n                    taskItem.RemoveMetadata(\"_trackerCompileReason\");\n                }\n            }\n            return SourcesNeedingCompilation;\n        }\n", "        private void CheckIfSourceNeedsCompilation(ConcurrentQueue<ITaskItem> sourcesNeedingCompilationList, bool allOutputFilesExist, ITaskItem source)\n        {\n            if (!_tlogAvailable || _outputFileGroup == null)\n            {\n                source.SetMetadata(\"_trackerCompileReason\", \"Tracking_SourceWillBeCompiledAsNoTrackingLog\");\n                sourcesNeedingCompilationList.Enqueue(source);\n            }\n            else if (!_useMinimalRebuildOptimization && !allOutputFilesExist)\n            {\n                source.SetMetadata(\"_trackerCompileReason\", \"Tracking_SourceOutputsNotAvailable\");\n                sourcesNeedingCompilationList.Enqueue(source);\n            }", "            else if (!IsUpToDate(source))\n            {\n                if (string.IsNullOrEmpty(source.GetMetadata(\"_trackerCompileReason\")))\n                {\n                    source.SetMetadata(\"_trackerCompileReason\", \"Tracking_SourceWillBeCompiled\");\n                }\n                sourcesNeedingCompilationList.Enqueue(source);\n            }\n            else if (!_useMinimalRebuildOptimization && _outputNewestTime == DateTime.MinValue)\n            {\n                source.SetMetadata(\"_trackerCompileReason\", \"Tracking_SourceNotInTrackingLog\");\n                sourcesNeedingCompilationList.Enqueue(source);\n            }\n        }\n", "            else if (!_useMinimalRebuildOptimization && _outputNewestTime == DateTime.MinValue)\n            {\n                source.SetMetadata(\"_trackerCompileReason\", \"Tracking_SourceNotInTrackingLog\");\n                sourcesNeedingCompilationList.Enqueue(source);\n            }\n        }\n\n        private static int CompareTaskItems(ITaskItem left, ITaskItem right)\n        {\n            return string.Compare(left.ItemSpec, right.ItemSpec, StringComparison.Ordinal);\n        }\n\n        private ITaskItem[] ComputeSourcesNeedingCompilationFromCompositeRootingMarker(bool searchForSubRootsInCompositeRootingMarkers)\n        {", "            if (!_tlogAvailable)\n            {\n                return _sourceFiles;\n            }\n            Dictionary<string, ITaskItem> dictionary = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);\n            string text = FileTracker.FormatRootingMarker(_sourceFiles);\n            List<ITaskItem> list = new List<ITaskItem>();\n            foreach (string key in DependencyTable.Keys)\n            {\n                string text2 = key/*.ToUpperInvariant()*/;\n                if (searchForSubRootsInCompositeRootingMarkers)\n                {", "                if (searchForSubRootsInCompositeRootingMarkers)\n                {\n                    if (text2.Contains(text) || CanonicalTrackedFilesHelper.RootContainsAllSubRootComponents(text, text2))\n                    {\n                        SourceDependenciesForOutputRoot(dictionary, text2, _outputFileGroup);\n                    }\n                }\n                else if (text2.Equals(text, StringComparison.Ordinal))\n                {\n                    SourceDependenciesForOutputRoot(dictionary, text2, _outputFileGroup);\n                }\n            }", "            if (dictionary.Count == 0)\n            {\n                FileTracker.LogMessageFromResources(_log, MessageImportance.Low, \"Tracking_DependenciesForRootNotFound\", text);\n                return _sourceFiles;\n            }\n            list.AddRange(dictionary.Values);\n            string outputOldestFilename = string.Empty;\n            if (CanonicalTrackedFilesHelper.FilesExistAndRecordNewestWriteTime(list, _log, out var outputNewestTime, out var outputNewestFilename) && CanonicalTrackedFilesHelper.FilesExistAndRecordOldestWriteTime(_outputFileGroup, _log, out var outputOldestTime, out outputOldestFilename) && outputNewestTime <= outputOldestTime)\n            {\n                FileTracker.LogMessageFromResources(_log, MessageImportance.Normal, \"Tracking_AllOutputsAreUpToDate\");\n                return Array.Empty<ITaskItem>();\n            }", "            if (dictionary.Count > 100)\n            {\n                FileTracker.LogMessageFromResources(_log, MessageImportance.Low, \"Tracking_InputsNotShown\", dictionary.Count);\n            }\n            else\n            {\n                FileTracker.LogMessageFromResources(_log, MessageImportance.Low, \"Tracking_InputsFor\", text);\n                foreach (ITaskItem item in list)\n                {\n                    FileTracker.LogMessage(_log, MessageImportance.Low, \"\\t\" + item);\n                }\n            }\n            FileTracker.LogMessageFromResources(_log, MessageImportance.Low, \"Tracking_InputNewerThanOutput\", outputNewestFilename, outputOldestFilename);\n            return _sourceFiles;\n        }\n", "        private void SourceDependenciesForOutputRoot(Dictionary<string, ITaskItem> sourceDependencies, string sourceKey, ITaskItem[] filesToIgnore)\n        {\n            bool flag = filesToIgnore != null && filesToIgnore.Length != 0;\n            if (!DependencyTable.TryGetValue(sourceKey, out var value))\n            {\n                return;\n            }\n            foreach (string key in value.Keys)\n            {\n                bool flag2 = false;\n                if (flag)\n                {", "                if (flag)\n                {\n                    foreach (ITaskItem taskItem in filesToIgnore)\n                    {\n                        if (string.Equals(key, taskItem.ItemSpec, StringComparison.OrdinalIgnoreCase))\n                        {\n                            flag2 = true;\n                            break;\n                        }\n                    }\n                }", "                if (!flag2 && !sourceDependencies.TryGetValue(key, out var _))\n                {\n                    sourceDependencies.Add(key, new TaskItem(key));\n                }\n            }\n        }\n\n        private bool IsUpToDate(ITaskItem sourceFile)\n        {\n            string text = FileUtilities.NormalizePath(sourceFile.ItemSpec);\n            Dictionary<string, string> value;\n            bool flag = DependencyTable.TryGetValue(text, out value);\n            DateTime dateTime = _outputNewestTime;", "            if (_useMinimalRebuildOptimization && _outputs != null && flag)\n            {\n                dateTime = DateTime.MinValue;\n                if (!_outputs.DependencyTable.TryGetValue(text, out var value2))\n                {\n                    sourceFile.SetMetadata(\"_trackerCompileReason\", \"Tracking_SourceOutputsNotAvailable\");\n                    return false;\n                }\n                DateTime lastWriteFileUtcTime = NativeMethods.GetLastWriteFileUtcTime(text);\n                foreach (string key in value2.Keys)\n                {\n                    DateTime lastWriteFileUtcTime2 = NativeMethods.GetLastWriteFileUtcTime(key);", "                foreach (string key in value2.Keys)\n                {\n                    DateTime lastWriteFileUtcTime2 = NativeMethods.GetLastWriteFileUtcTime(key);\n                    if (lastWriteFileUtcTime2 > DateTime.MinValue)\n                    {\n                        if (lastWriteFileUtcTime2 < lastWriteFileUtcTime)\n                        {\n                            sourceFile.SetMetadata(\"_trackerCompileReason\", \"Tracking_SourceWillBeCompiledDependencyWasModifiedAt\");\n                            sourceFile.SetMetadata(\"_trackerModifiedPath\", text);\n                            sourceFile.SetMetadata(\"_trackerModifiedTime\", lastWriteFileUtcTime.ToLocalTime().ToString());\n                            return false;\n                        }", "                        if (lastWriteFileUtcTime2 > dateTime)\n                        {\n                            dateTime = lastWriteFileUtcTime2;\n                        }\n                        continue;\n                    }\n                    sourceFile.SetMetadata(\"_trackerCompileReason\", \"Tracking_SourceWillBeCompiledOutputDoesNotExist\");\n                    sourceFile.SetMetadata(\"_trackerOutputFile\", key);\n                    return false;\n                }\n            }", "            if (flag)\n            {\n                foreach (string key2 in value.Keys)\n                {\n                    if (!FileIsExcludedFromDependencyCheck(key2))\n                    {\n                        if (!_lastWriteTimeCache.TryGetValue(key2, out var value3))\n                        {\n                            value3 = NativeMethods.GetLastWriteFileUtcTime(key2);\n                            _lastWriteTimeCache[key2] = value3;\n                        }", "                        if (!(value3 > DateTime.MinValue))\n                        {\n                            sourceFile.SetMetadata(\"_trackerCompileReason\", \"Tracking_SourceWillBeCompiledMissingDependency\");\n                            sourceFile.SetMetadata(\"_trackerModifiedPath\", key2);\n                            return false;\n                        }\n                        if (value3 > dateTime)\n                        {\n                            sourceFile.SetMetadata(\"_trackerCompileReason\", \"Tracking_SourceWillBeCompiledDependencyWasModifiedAt\");\n                            sourceFile.SetMetadata(\"_trackerModifiedPath\", key2);\n                            sourceFile.SetMetadata(\"_trackerModifiedTime\", value3.ToLocalTime().ToString());\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n            sourceFile.SetMetadata(\"_trackerCompileReason\", \"Tracking_SourceNotInTrackingLog\");\n            return false;\n        }\n", "        public bool FileIsExcludedFromDependencyCheck(string fileName)\n        {\n            string directoryNameOfFullPath = FileUtilities.GetDirectoryNameOfFullPath(fileName);\n            return _excludedInputPaths.Contains(directoryNameOfFullPath);\n        }\n\n        private bool FilesExistAndRecordNewestWriteTime(ITaskItem[] files)\n        {\n            string outputNewestFilename;\n            return CanonicalTrackedFilesHelper.FilesExistAndRecordNewestWriteTime(files, _log, out _outputNewestTime, out outputNewestFilename);\n        }\n", "        private void ConstructDependencyTable()\n        {\n            string text;\n            try\n            {\n                text = DependencyTableCache.FormatNormalizedTlogRootingMarker(_tlogFiles);\n            }\n            catch (ArgumentException ex)\n            {\n                FileTracker.LogWarningWithCodeFromResources(_log, \"Tracking_RebuildingDueToInvalidTLog\", ex.Message);\n                return;\n            }\n            string path = FileUtilities.EnsureTrailingSlash(Directory.GetCurrentDirectory());\n            ITaskItem[] tlogFiles;", "            if (!_tlogAvailable)\n            {\n                tlogFiles = _tlogFiles;\n                foreach (ITaskItem taskItem in tlogFiles)\n                {\n                    if (!FileUtilities.FileExistsNoThrow(taskItem.ItemSpec))\n                    {\n                        FileTracker.LogMessageFromResources(_log, MessageImportance.Low, \"Tracking_SingleLogFileNotAvailable\", taskItem.ItemSpec);\n                    }\n                }\n                lock (DependencyTableCache.DependencyTable)\n                {\n                    DependencyTableCache.DependencyTable.Remove(text);\n                    return;\n                }\n            }\n            DependencyTableCacheEntry cachedEntry;\n            lock (DependencyTableCache.DependencyTable)\n            {\n                cachedEntry = DependencyTableCache.GetCachedEntry(text);\n            }", "            if (cachedEntry != null)\n            {\n                DependencyTable = (Dictionary<string, Dictionary<string, string>>)cachedEntry.DependencyTable;\n                FileTracker.LogMessageFromResources(_log, MessageImportance.Low, \"Tracking_ReadTrackingCached\");\n                tlogFiles = cachedEntry.TlogFiles;\n                foreach (ITaskItem taskItem2 in tlogFiles)\n                {\n                    FileTracker.LogMessage(_log, MessageImportance.Low, \"\\t{0}\", taskItem2.ItemSpec);\n                }\n                return;\n            }\n            bool flag = false;\n            bool flag2 = false;\n            string text2 = null;\n            FileTracker.LogMessageFromResources(_log, MessageImportance.Low, \"Tracking_ReadTrackingLogs\");\n            tlogFiles = _tlogFiles;", "            foreach (ITaskItem taskItem3 in tlogFiles)\n            {\n                try\n                {\n                    FileTracker.LogMessage(_log, MessageImportance.Low, \"\\t{0}\", taskItem3.ItemSpec);\n                    using StreamReader streamReader = File.OpenText(taskItem3.ItemSpec);\n                    string text3 = streamReader.ReadLine();\n                    while (text3 != null)\n                    {\n                        if (text3.Length == 0)\n                        {\n                            flag = true;\n                            text2 = taskItem3.ItemSpec;\n                            break;\n                        }", "                        if (text3.Length == 0)\n                        {\n                            flag = true;\n                            text2 = taskItem3.ItemSpec;\n                            break;\n                        }\n                        if (text3[0] != '#')\n                        {\n                            bool flag3 = false;\n                            if (text3[0] == '^')\n                            {\n                                text3 = text3.Substring(1);", "                            if (text3[0] == '^')\n                            {\n                                text3 = text3.Substring(1);\n                                if (text3.Length == 0)\n                                {\n                                    flag = true;\n                                    text2 = taskItem3.ItemSpec;\n                                    break;\n                                }\n                                flag3 = true;\n                            }", "                            if (flag3)\n                            {\n                                Dictionary<string, string> dictionary;\n                                if (!_maintainCompositeRootingMarkers)\n                                {\n                                    dictionary = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n                                    if (text3.Contains(\"|\"))\n                                    {\n                                        ITaskItem[] sourceFiles = _sourceFiles;\n                                        foreach (ITaskItem taskItem4 in sourceFiles)\n                                        {", "                                        foreach (ITaskItem taskItem4 in sourceFiles)\n                                        {\n                                            if (!dictionary.ContainsKey(FileUtilities.NormalizePath(taskItem4.ItemSpec)))\n                                            {\n                                                dictionary.Add(FileUtilities.NormalizePath(taskItem4.ItemSpec), null);\n                                            }\n                                        }\n                                    }\n                                    else\n                                    {\n                                        dictionary.Add(text3, null);\n                                    }\n                                }\n                                else\n                                {\n                                    dictionary = null;\n                                }", "                                if (!DependencyTable.TryGetValue(text3, out var value))\n                                {\n                                    value = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n                                    if (!_maintainCompositeRootingMarkers)\n                                    {\n                                        value.Add(text3, null);\n                                    }\n                                    DependencyTable.Add(text3, value);\n                                }\n                                text3 = streamReader.ReadLine();\n                                if (_maintainCompositeRootingMarkers)\n                                {", "                                if (_maintainCompositeRootingMarkers)\n                                {\n                                    while (text3 != null)\n                                    {\n                                        if (text3.Length == 0)\n                                        {\n                                            flag = true;\n                                            text2 = taskItem3.ItemSpec;\n                                            break;\n                                        }\n                                        if (text3[0] == '#' || text3[0] == '^')\n                                        {\n                                            break;\n                                        }", "                                        if (text3[0] == '#' || text3[0] == '^')\n                                        {\n                                            break;\n                                        }\n                                        if (!value.ContainsKey(text3) && (FileTracker.FileIsUnderPath(text3, path) || !FileTracker.FileIsExcludedFromDependencies(text3)))\n                                        {\n                                            value.Add(text3, null);\n                                        }\n                                        text3 = streamReader.ReadLine();\n                                    }\n                                    continue;\n                                }", "                                while (text3 != null)\n                                {\n                                    if (text3.Length == 0)\n                                    {\n                                        flag = true;\n                                        text2 = taskItem3.ItemSpec;\n                                        break;\n                                    }\n                                    if (text3[0] == '#' || text3[0] == '^')\n                                    {\n                                        break;\n                                    }", "                                    if (text3[0] == '#' || text3[0] == '^')\n                                    {\n                                        break;\n                                    }\n                                    if (dictionary.ContainsKey(text3))\n                                    {\n                                        if (!DependencyTable.TryGetValue(text3, out value))\n                                        {\n                                            value = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase) { { text3, null } };\n                                            DependencyTable.Add(text3, value);\n                                        }\n                                    }", "                                    else if (!value.ContainsKey(text3) && (FileTracker.FileIsUnderPath(text3, path) || !FileTracker.FileIsExcludedFromDependencies(text3)))\n                                    {\n                                        value.Add(text3, null);\n                                    }\n                                    text3 = streamReader.ReadLine();\n                                }\n                            }\n                            else\n                            {\n                                text3 = streamReader.ReadLine();\n                            }\n                        }\n                        else\n                        {\n                            text3 = streamReader.ReadLine();\n                        }\n                    }\n                }", "                catch (Exception ex2) when (ExceptionHandling.IsIoRelatedException(ex2))\n                {\n                    FileTracker.LogWarningWithCodeFromResources(_log, \"Tracking_RebuildingDueToInvalidTLog\", ex2.Message);\n                    break;\n                }\n                if (flag)\n                {\n                    FileTracker.LogWarningWithCodeFromResources(_log, \"Tracking_RebuildingDueToInvalidTLogContents\", text2);\n                    break;\n                }\n            }\n            lock (DependencyTableCache.DependencyTable)\n            {", "                if (flag || flag2)\n                {\n                    DependencyTableCache.DependencyTable.Remove(text);\n                    DependencyTable = new Dictionary<string, Dictionary<string, string>>(StringComparer.OrdinalIgnoreCase);\n                }\n                else\n                {\n                    DependencyTableCache.DependencyTable[text] = new DependencyTableCacheEntry(_tlogFiles, DependencyTable);\n                }\n            }\n        }\n", "        public void SaveTlog()\n        {\n            SaveTlog(null);\n        }\n\n        public void SaveTlog(DependencyFilter includeInTLog)\n        {\n            ITaskItem[] tlogFiles = _tlogFiles;\n            if (tlogFiles == null || tlogFiles.Length == 0)\n            {\n                return;\n            }\n            string key = DependencyTableCache.FormatNormalizedTlogRootingMarker(_tlogFiles);\n            lock (DependencyTableCache.DependencyTable)\n            {\n                DependencyTableCache.DependencyTable.Remove(key);\n            }\n            string itemSpec = _tlogFiles[0].ItemSpec;\n            ITaskItem[] tlogFiles2 = _tlogFiles;", "            if (tlogFiles == null || tlogFiles.Length == 0)\n            {\n                return;\n            }\n            string key = DependencyTableCache.FormatNormalizedTlogRootingMarker(_tlogFiles);\n            lock (DependencyTableCache.DependencyTable)\n            {\n                DependencyTableCache.DependencyTable.Remove(key);\n            }\n            string itemSpec = _tlogFiles[0].ItemSpec;\n            ITaskItem[] tlogFiles2 = _tlogFiles;", "            for (int i = 0; i < tlogFiles2.Length; i++)\n            {\n                File.WriteAllText(tlogFiles2[i].ItemSpec, \"\", Encoding.Unicode);\n            }\n            using StreamWriter streamWriter = FileUtilities.OpenWrite(itemSpec, append: false, Encoding.Unicode);\n            if (!_maintainCompositeRootingMarkers)\n            {\n                foreach (string key2 in DependencyTable.Keys)\n                {\n                    if (!key2.Contains(\"|\"))\n                    {\n                        Dictionary<string, string> dictionary = DependencyTable[key2];\n                        streamWriter.WriteLine(\"^\" + key2);", "                    if (!key2.Contains(\"|\"))\n                    {\n                        Dictionary<string, string> dictionary = DependencyTable[key2];\n                        streamWriter.WriteLine(\"^\" + key2);\n                        foreach (string key3 in dictionary.Keys)\n                        {\n                            if (key3 != key2 && (includeInTLog == null || includeInTLog(key3)))\n                            {\n                                streamWriter.WriteLine(key3);\n                            }\n                        }\n                    }\n                }\n                return;\n            }", "            foreach (string key4 in DependencyTable.Keys)\n            {\n                Dictionary<string, string> dictionary2 = DependencyTable[key4];\n                streamWriter.WriteLine(\"^\" + key4);\n                foreach (string key5 in dictionary2.Keys)\n                {\n                    if (includeInTLog == null || includeInTLog(key5))\n                    {\n                        streamWriter.WriteLine(key5);\n                    }\n                }\n            }\n        }\n", "        public void RemoveEntriesForSource(ITaskItem source)\n        {\n            RemoveEntriesForSource(new ITaskItem[1] { source });\n        }\n\n        public void RemoveEntriesForSource(ITaskItem[] source)\n        {\n            string key = FileTracker.FormatRootingMarker(source);\n            DependencyTable.Remove(key);\n            foreach (ITaskItem taskItem in source)\n            {\n                DependencyTable.Remove(FileUtilities.NormalizePath(taskItem.ItemSpec));\n            }\n        }\n", "            foreach (ITaskItem taskItem in source)\n            {\n                DependencyTable.Remove(FileUtilities.NormalizePath(taskItem.ItemSpec));\n            }\n        }\n\n        public void RemoveEntryForSourceRoot(string rootingMarker)\n        {\n            DependencyTable.Remove(rootingMarker);\n        }\n", "        public void RemoveDependencyFromEntry(ITaskItem[] sources, ITaskItem dependencyToRemove)\n        {\n            string rootingMarker = FileTracker.FormatRootingMarker(sources);\n            RemoveDependencyFromEntry(rootingMarker, dependencyToRemove);\n        }\n\n        public void RemoveDependencyFromEntry(ITaskItem source, ITaskItem dependencyToRemove)\n        {\n            string rootingMarker = FileTracker.FormatRootingMarker(source);\n            RemoveDependencyFromEntry(rootingMarker, dependencyToRemove);\n        }\n", "        private void RemoveDependencyFromEntry(string rootingMarker, ITaskItem dependencyToRemove)\n        {\n            if (DependencyTable.TryGetValue(rootingMarker, out var value))\n            {\n                value.Remove(FileUtilities.NormalizePath(dependencyToRemove.ItemSpec));\n                return;\n            }\n            FileTracker.LogMessageFromResources(_log, MessageImportance.Normal, \"Tracking_ReadLogEntryNotFound\", rootingMarker);\n        }\n\n        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source)\n        {\n            RemoveDependenciesFromEntryIfMissing(new ITaskItem[1] { source }, null);\n        }\n", "        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source)\n        {\n            RemoveDependenciesFromEntryIfMissing(new ITaskItem[1] { source }, null);\n        }\n\n        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source, ITaskItem correspondingOutput)\n        {\n            RemoveDependenciesFromEntryIfMissing(new ITaskItem[1] { source }, new ITaskItem[1] { correspondingOutput });\n        }\n\n        public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source)\n        {\n            RemoveDependenciesFromEntryIfMissing(source, null);\n        }\n", "        public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source)\n        {\n            RemoveDependenciesFromEntryIfMissing(source, null);\n        }\n\n        public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source, ITaskItem[] correspondingOutputs)\n        {\n            Dictionary<string, bool> fileCache = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);\n            if (correspondingOutputs != null)\n            {\n                ErrorUtilities.VerifyThrowArgument(source.Length == correspondingOutputs.Length, \"Tracking_SourcesAndCorrespondingOutputMismatch\");\n            }\n            string rootingMarker = FileTracker.FormatRootingMarker(source, correspondingOutputs);\n            RemoveDependenciesFromEntryIfMissing(rootingMarker, fileCache);", "            if (correspondingOutputs != null)\n            {\n                ErrorUtilities.VerifyThrowArgument(source.Length == correspondingOutputs.Length, \"Tracking_SourcesAndCorrespondingOutputMismatch\");\n            }\n            string rootingMarker = FileTracker.FormatRootingMarker(source, correspondingOutputs);\n            RemoveDependenciesFromEntryIfMissing(rootingMarker, fileCache);\n            for (int i = 0; i < source.Length; i++)\n            {\n                rootingMarker = ((correspondingOutputs != null) ? FileTracker.FormatRootingMarker(source[i], correspondingOutputs[i]) : FileTracker.FormatRootingMarker(source[i]));\n                RemoveDependenciesFromEntryIfMissing(rootingMarker, fileCache);\n            }\n        }\n", "        private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictionary<string, bool> fileCache)\n        {\n            if (!DependencyTable.TryGetValue(rootingMarker, out var value))\n            {\n                return;\n            }\n            Dictionary<string, string> dictionary = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            int num = 0;\n            foreach (string key in value.Keys)\n            {\n                if (num++ > 0)\n                {", "            foreach (string key in value.Keys)\n            {\n                if (num++ > 0)\n                {\n                    if (!fileCache.TryGetValue(key, out var value2))\n                    {\n                        value2 = FileUtilities.FileExistsNoThrow(key);\n                        fileCache.Add(key, value2);\n                    }\n                    if (value2)\n                    {\n                        dictionary.Add(key, value[key]);\n                    }\n                }\n                else\n                {\n                    dictionary.Add(key, key);\n                }\n            }\n            DependencyTable[rootingMarker] = dictionary;\n        }\n    }\n}\n", "                    if (value2)\n                    {\n                        dictionary.Add(key, value[key]);\n                    }\n                }\n                else\n                {\n                    dictionary.Add(key, key);\n                }\n            }\n            DependencyTable[rootingMarker] = dictionary;\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.Utilities/TrackedDependencies.cs", "chunked_list": ["\ufeffusing System.Collections.Generic;\nusing System.IO;\nusing Microsoft.Build.Framework;\nusing Microsoft.Build.Shared;\nusing Microsoft.Build.Shared.FileSystem;\nusing Microsoft.Build.Utilities;\n\nnamespace Microsoft.Build.Utilities\n{\n    public static class TrackedDependencies\n    {", "{\n    public static class TrackedDependencies\n    {\n        public static ITaskItem[] ExpandWildcards(ITaskItem[] expand)\n        {\n            if (expand == null)\n            {\n                return null;\n            }\n            List<ITaskItem> list = new List<ITaskItem>(expand.Length);\n            foreach (ITaskItem taskItem in expand)\n            {", "            foreach (ITaskItem taskItem in expand)\n            {\n                if (FileMatcher.HasWildcards(taskItem.ItemSpec))\n                {\n                    string directoryName = Path.GetDirectoryName(taskItem.ItemSpec);\n                    string fileName = Path.GetFileName(taskItem.ItemSpec);\n                    string[] array = ((FileMatcher.HasWildcards(directoryName) || !FileSystems.Default.DirectoryExists(directoryName)) ? FileMatcher.Default.GetFiles(null, taskItem.ItemSpec) : Directory.GetFiles(directoryName, fileName));\n                    string[] array2 = array;\n                    foreach (string itemSpec in array2)\n                    {\n                        list.Add(new TaskItem(taskItem)\n                        {\n                            ItemSpec = itemSpec\n                        });\n                    }\n                }\n                else\n                {\n                    list.Add(taskItem);\n                }\n            }\n            return list.ToArray();\n        }\n\n        internal static bool ItemsExist(ITaskItem[] files)\n        {\n            bool result = true;", "                    foreach (string itemSpec in array2)\n                    {\n                        list.Add(new TaskItem(taskItem)\n                        {\n                            ItemSpec = itemSpec\n                        });\n                    }\n                }\n                else\n                {\n                    list.Add(taskItem);\n                }\n            }\n            return list.ToArray();\n        }\n\n        internal static bool ItemsExist(ITaskItem[] files)\n        {\n            bool result = true;", "            if (files != null && files.Length != 0)\n            {\n                for (int i = 0; i < files.Length; i++)\n                {\n                    if (!FileUtilities.FileExistsNoThrow(files[i].ItemSpec))\n                    {\n                        result = false;\n                        break;\n                    }\n                }\n            }\n            else\n            {\n                result = false;\n            }\n            return result;\n        }\n    }\n\n}\n"]}
{"filename": "Microsoft.Build.Utilities/DependencyTableCache.cs", "chunked_list": ["\ufeffusing Microsoft.Build.Framework;\nusing Microsoft.Build.Shared;\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Microsoft.Build.Utilities\n{\n    internal static class DependencyTableCache\n    {\n        private class TaskItemItemSpecIgnoreCaseComparer : IEqualityComparer<ITaskItem>\n        {", "    internal static class DependencyTableCache\n    {\n        private class TaskItemItemSpecIgnoreCaseComparer : IEqualityComparer<ITaskItem>\n        {\n            public bool Equals(ITaskItem x, ITaskItem y)\n            {\n                if (x == y)\n                {\n                    return true;\n                }\n                if (x == null || y == null)\n                {\n                    return false;\n                }\n                return string.Equals(x.ItemSpec, y.ItemSpec, StringComparison.OrdinalIgnoreCase);\n            }\n", "                if (x == null || y == null)\n                {\n                    return false;\n                }\n                return string.Equals(x.ItemSpec, y.ItemSpec, StringComparison.OrdinalIgnoreCase);\n            }\n\n            public int GetHashCode(ITaskItem obj)\n            {\n                if (obj != null)\n                {\n                    return StringComparer.OrdinalIgnoreCase.GetHashCode(obj.ItemSpec);\n                }\n                return 0;\n            }\n        }\n", "                if (obj != null)\n                {\n                    return StringComparer.OrdinalIgnoreCase.GetHashCode(obj.ItemSpec);\n                }\n                return 0;\n            }\n        }\n\n        private static readonly char[] s_numerals = new char[10] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };\n\n        private static readonly TaskItemItemSpecIgnoreCaseComparer s_taskItemComparer = new TaskItemItemSpecIgnoreCaseComparer();\n\n        internal static Dictionary<string, DependencyTableCacheEntry> DependencyTable { get; } = new Dictionary<string, DependencyTableCacheEntry>(StringComparer.OrdinalIgnoreCase);\n\n", "        private static readonly char[] s_numerals = new char[10] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };\n\n        private static readonly TaskItemItemSpecIgnoreCaseComparer s_taskItemComparer = new TaskItemItemSpecIgnoreCaseComparer();\n\n        internal static Dictionary<string, DependencyTableCacheEntry> DependencyTable { get; } = new Dictionary<string, DependencyTableCacheEntry>(StringComparer.OrdinalIgnoreCase);\n\n\n        private static bool DependencyTableIsUpToDate(DependencyTableCacheEntry dependencyTable)\n        {\n            DateTime tableTime = dependencyTable.TableTime;\n            ITaskItem[] tlogFiles = dependencyTable.TlogFiles;", "            for (int i = 0; i < tlogFiles.Length; i++)\n            {\n                if (NativeMethods.GetLastWriteFileUtcTime(FileUtilities.NormalizePath(tlogFiles[i].ItemSpec)) > tableTime)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        internal static DependencyTableCacheEntry GetCachedEntry(string tLogRootingMarker)\n        {", "            if (DependencyTable.TryGetValue(tLogRootingMarker, out var value))\n            {\n                if (DependencyTableIsUpToDate(value))\n                {\n                    return value;\n                }\n                DependencyTable.Remove(tLogRootingMarker);\n            }\n            return null;\n        }\n\n        internal static string FormatNormalizedTlogRootingMarker(ITaskItem[] tlogFiles)\n        {\n            HashSet<ITaskItem> hashSet = new HashSet<ITaskItem>(s_taskItemComparer);", "            for (int i = 0; i < tlogFiles.Length; i++)\n            {\n                ITaskItem taskItem = new TaskItem(tlogFiles[i]);\n                taskItem.ItemSpec = NormalizeTlogPath(tlogFiles[i].ItemSpec);\n                hashSet.Add(taskItem);\n            }\n            return FileTracker.FormatRootingMarker(hashSet.ToArray());\n        }\n\n        private static string NormalizeTlogPath(string tlogPath)\n        {", "        private static string NormalizeTlogPath(string tlogPath)\n        {\n            if (tlogPath.IndexOfAny(s_numerals) == -1)\n            {\n                return tlogPath;\n            }\n            StringBuilder stringBuilder = new StringBuilder();\n            int num = tlogPath.Length - 1;\n            while (num >= 0 && tlogPath[num] != '\\\\')\n            {\n                if (tlogPath[num] == '.' || tlogPath[num] == '-')\n                {\n                    stringBuilder.Append(tlogPath[num]);\n                    int num2 = num - 1;", "            while (num >= 0 && tlogPath[num] != '\\\\')\n            {\n                if (tlogPath[num] == '.' || tlogPath[num] == '-')\n                {\n                    stringBuilder.Append(tlogPath[num]);\n                    int num2 = num - 1;\n                    while (num2 >= 0 && tlogPath[num2] != '\\\\' && tlogPath[num2] >= '0' && tlogPath[num2] <= '9')\n                    {\n                        num2--;\n                    }\n                    if (num2 >= 0 && tlogPath[num2] == '.')\n                    {\n                        stringBuilder.Append(\"]DI[\");\n                        stringBuilder.Append(tlogPath[num2]);\n                        num = num2;\n                    }\n                }\n                else\n                {\n                    stringBuilder.Append(tlogPath[num]);\n                }\n                num--;\n            }\n            StringBuilder stringBuilder2 = new StringBuilder(num + stringBuilder.Length);", "                    if (num2 >= 0 && tlogPath[num2] == '.')\n                    {\n                        stringBuilder.Append(\"]DI[\");\n                        stringBuilder.Append(tlogPath[num2]);\n                        num = num2;\n                    }\n                }\n                else\n                {\n                    stringBuilder.Append(tlogPath[num]);\n                }\n                num--;\n            }\n            StringBuilder stringBuilder2 = new StringBuilder(num + stringBuilder.Length);", "            if (num >= 0)\n            {\n                stringBuilder2.Append(tlogPath, 0, num + 1);\n            }\n            for (int num3 = stringBuilder.Length - 1; num3 >= 0; num3--)\n            {\n                stringBuilder2.Append(stringBuilder[num3]);\n            }\n            return stringBuilder2.ToString();\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.Utilities/CanonicalTrackedFilesHelper.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing Microsoft.Build.Framework;\nusing Microsoft.Build.Shared;\nusing Microsoft.Build.Utilities;\n\nnamespace Microsoft.Build.Utilities\n{\n    internal static class CanonicalTrackedFilesHelper\n    {\n        internal const int MaxLogCount = 100;\n\n        internal static bool RootContainsAllSubRootComponents(string compositeRoot, string compositeSubRoot)\n        {", "    internal static class CanonicalTrackedFilesHelper\n    {\n        internal const int MaxLogCount = 100;\n\n        internal static bool RootContainsAllSubRootComponents(string compositeRoot, string compositeSubRoot)\n        {\n            if (string.Equals(compositeRoot, compositeSubRoot, StringComparison.OrdinalIgnoreCase))\n            {\n                return true;\n            }\n            string[] array = compositeSubRoot.Split(MSBuildConstants.PipeChar);", "            foreach (string value in array)\n            {\n                if (!compositeRoot.Contains(value))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        internal static bool FilesExistAndRecordNewestWriteTime(ICollection<ITaskItem> files, TaskLoggingHelper log, out DateTime outputNewestTime, out string outputNewestFilename)\n        {\n            return FilesExistAndRecordRequestedWriteTime(files, log, getNewest: true, out outputNewestTime, out outputNewestFilename);\n        }\n\n        internal static bool FilesExistAndRecordOldestWriteTime(ICollection<ITaskItem> files, TaskLoggingHelper log, out DateTime outputOldestTime, out string outputOldestFilename)\n        {\n            return FilesExistAndRecordRequestedWriteTime(files, log, getNewest: false, out outputOldestTime, out outputOldestFilename);\n        }\n", "        private static bool FilesExistAndRecordRequestedWriteTime(ICollection<ITaskItem> files, TaskLoggingHelper log, bool getNewest, out DateTime requestedTime, out string requestedFilename)\n        {\n            bool result = true;\n            requestedTime = (getNewest ? DateTime.MinValue : DateTime.MaxValue);\n            requestedFilename = string.Empty;\n            if (files == null || files.Count == 0)\n            {\n                return false;\n            }\n            foreach (ITaskItem file in files)\n            {\n                DateTime lastWriteFileUtcTime = NativeMethods.GetLastWriteFileUtcTime(file.ItemSpec);", "            foreach (ITaskItem file in files)\n            {\n                DateTime lastWriteFileUtcTime = NativeMethods.GetLastWriteFileUtcTime(file.ItemSpec);\n                if (lastWriteFileUtcTime == DateTime.MinValue)\n                {\n                    FileTracker.LogMessageFromResources(log, MessageImportance.Low, \"Tracking_OutputDoesNotExist\", file.ItemSpec);\n                    return false;\n                }\n                if ((getNewest && lastWriteFileUtcTime > requestedTime) || (!getNewest && lastWriteFileUtcTime < requestedTime))\n                {\n                    requestedTime = lastWriteFileUtcTime;\n                    requestedFilename = file.ItemSpec;\n                }\n            }\n            return result;\n        }\n    }\n}\n", "                if ((getNewest && lastWriteFileUtcTime > requestedTime) || (!getNewest && lastWriteFileUtcTime < requestedTime))\n                {\n                    requestedTime = lastWriteFileUtcTime;\n                    requestedFilename = file.ItemSpec;\n                }\n            }\n            return result;\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.Utilities/DependencyTableCacheEntry.cs", "chunked_list": ["\ufeffusing Microsoft.Build.Framework;\nusing Microsoft.Build.Shared;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Microsoft.Build.Utilities\n{\n    internal class DependencyTableCacheEntry\n    {\n        public ITaskItem[] TlogFiles { get; }\n", "{\n    internal class DependencyTableCacheEntry\n    {\n        public ITaskItem[] TlogFiles { get; }\n\n        public DateTime TableTime { get; }\n\n        public IDictionary DependencyTable { get; }\n\n        internal DependencyTableCacheEntry(ITaskItem[] tlogFiles, IDictionary dependencyTable)\n        {\n            TlogFiles = new ITaskItem[tlogFiles.Length];\n            TableTime = DateTime.MinValue;", "            for (int i = 0; i < tlogFiles.Length; i++)\n            {\n                string text = FileUtilities.NormalizePath(tlogFiles[i].ItemSpec);\n                TlogFiles[i] = new TaskItem(text);\n                DateTime lastWriteFileUtcTime = NativeMethods.GetLastWriteFileUtcTime(text);\n                if (lastWriteFileUtcTime > TableTime)\n                {\n                    TableTime = lastWriteFileUtcTime;\n                }\n            }\n            DependencyTable = dependencyTable;\n        }\n    }\n}\n"]}
{"filename": "Microsoft.Build.Utilities/DependencyFilter.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Microsoft.Build.Utilities\n{\n    public delegate bool DependencyFilter(string fullPath);\n}\n"]}
{"filename": "Microsoft.Build.Utilities/CanonicalTrackedOutputFiles.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\nusing Microsoft.Build.Framework;\nusing Microsoft.Build.Shared;\nusing Microsoft.Build.Utilities;\n\nnamespace Microsoft.Build.Utilities\n{\n    public class CanonicalTrackedOutputFiles\n    {\n        private ITaskItem[] _tlogFiles;\n", "namespace Microsoft.Build.Utilities\n{\n    public class CanonicalTrackedOutputFiles\n    {\n        private ITaskItem[] _tlogFiles;\n\n        private TaskLoggingHelper _log;\n\n        private bool _tlogAvailable;\n\n        public Dictionary<string, Dictionary<string, DateTime>> DependencyTable { get; private set; }\n\n        public CanonicalTrackedOutputFiles(ITaskItem[] tlogFiles)\n        {\n            InternalConstruct(null, tlogFiles, constructOutputsFromTLogs: true);\n        }\n\n        public CanonicalTrackedOutputFiles(ITask ownerTask, ITaskItem[] tlogFiles)\n        {\n            InternalConstruct(ownerTask, tlogFiles, constructOutputsFromTLogs: true);\n        }\n\n        public CanonicalTrackedOutputFiles(ITask ownerTask, ITaskItem[] tlogFiles, bool constructOutputsFromTLogs)\n        {\n            InternalConstruct(ownerTask, tlogFiles, constructOutputsFromTLogs);\n        }\n", "        private bool _tlogAvailable;\n\n        public Dictionary<string, Dictionary<string, DateTime>> DependencyTable { get; private set; }\n\n        public CanonicalTrackedOutputFiles(ITaskItem[] tlogFiles)\n        {\n            InternalConstruct(null, tlogFiles, constructOutputsFromTLogs: true);\n        }\n\n        public CanonicalTrackedOutputFiles(ITask ownerTask, ITaskItem[] tlogFiles)\n        {\n            InternalConstruct(ownerTask, tlogFiles, constructOutputsFromTLogs: true);\n        }\n\n        public CanonicalTrackedOutputFiles(ITask ownerTask, ITaskItem[] tlogFiles, bool constructOutputsFromTLogs)\n        {\n            InternalConstruct(ownerTask, tlogFiles, constructOutputsFromTLogs);\n        }\n", "        private void InternalConstruct(ITask ownerTask, ITaskItem[] tlogFiles, bool constructOutputsFromTLogs)\n        {\n            if (ownerTask != null)\n            {\n                _log = new TaskLoggingHelper(ownerTask)\n                {\n                    TaskResources = Microsoft.Build.CppTasks.Common.Properties.Microsoft_Build_CPPTasks_Strings.ResourceManager,\n                    HelpKeywordPrefix = \"MSBuild.\"\n                };\n            }\n            _tlogFiles = TrackedDependencies.ExpandWildcards(tlogFiles);\n            _tlogAvailable = TrackedDependencies.ItemsExist(_tlogFiles);\n            DependencyTable = new Dictionary<string, Dictionary<string, DateTime>>(StringComparer.OrdinalIgnoreCase);", "            if (_tlogFiles != null && constructOutputsFromTLogs)\n            {\n                ConstructOutputTable();\n            }\n        }\n\n        private void ConstructOutputTable()\n        {\n            string text;\n            try\n            {\n                text = DependencyTableCache.FormatNormalizedTlogRootingMarker(_tlogFiles);\n            }", "            catch (ArgumentException ex)\n            {\n                FileTracker.LogWarningWithCodeFromResources(_log, \"Tracking_RebuildingDueToInvalidTLog\", ex.Message);\n                return;\n            }\n            string path = FileUtilities.EnsureTrailingSlash(Directory.GetCurrentDirectory());\n            if (!_tlogAvailable)\n            {\n                FileTracker.LogMessageFromResources(_log, MessageImportance.Low, \"Tracking_TrackingLogNotAvailable\");\n                lock (DependencyTableCache.DependencyTable)\n                {\n                    DependencyTableCache.DependencyTable.Remove(text);\n                    return;\n                }\n            }\n            DependencyTableCacheEntry dependencyTableCacheEntry = null;\n            lock (DependencyTableCache.DependencyTable)\n            {\n                dependencyTableCacheEntry = DependencyTableCache.GetCachedEntry(text);\n            }\n            ITaskItem[] tlogFiles;", "            if (dependencyTableCacheEntry != null)\n            {\n                DependencyTable = (Dictionary<string, Dictionary<string, DateTime>>)dependencyTableCacheEntry.DependencyTable;\n                FileTracker.LogMessageFromResources(_log, MessageImportance.Low, \"Tracking_WriteTrackingCached\");\n                tlogFiles = dependencyTableCacheEntry.TlogFiles;\n                foreach (ITaskItem taskItem in tlogFiles)\n                {\n                    FileTracker.LogMessage(_log, MessageImportance.Low, \"\\t{0}\", taskItem.ItemSpec);\n                }\n                return;\n            }\n            FileTracker.LogMessageFromResources(_log, MessageImportance.Low, \"Tracking_WriteTrackingLogs\");\n            bool flag = false;\n            string text2 = null;\n            tlogFiles = _tlogFiles;", "            foreach (ITaskItem taskItem2 in tlogFiles)\n            {\n                FileTracker.LogMessage(_log, MessageImportance.Low, \"\\t{0}\", taskItem2.ItemSpec);\n                try\n                {\n                    using StreamReader streamReader = File.OpenText(taskItem2.ItemSpec);\n                    string text3 = streamReader.ReadLine();\n                    while (text3 != null)\n                    {\n                        if (text3.Length == 0)\n                        {\n                            flag = true;\n                            text2 = taskItem2.ItemSpec;\n                            break;\n                        }", "                        if (text3.Length == 0)\n                        {\n                            flag = true;\n                            text2 = taskItem2.ItemSpec;\n                            break;\n                        }\n                        if (text3[0] == '^')\n                        {\n                            text3 = text3.Substring(1);\n                            if (text3.Length == 0)\n                            {\n                                flag = true;\n                                text2 = taskItem2.ItemSpec;\n                                break;\n                            }", "                            if (text3.Length == 0)\n                            {\n                                flag = true;\n                                text2 = taskItem2.ItemSpec;\n                                break;\n                            }\n                            if (!DependencyTable.TryGetValue(text3, out var value))\n                            {\n                                value = new Dictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);\n                                DependencyTable.Add(text3, value);\n                            }\n                            do\n                            {\n                                text3 = streamReader.ReadLine();", "                                if (text3 != null)\n                                {\n                                    if (text3.Length == 0)\n                                    {\n                                        flag = true;\n                                        text2 = taskItem2.ItemSpec;\n                                        break;\n                                    }\n                                    if (text3[0] != '^' && text3[0] != '#' && !value.ContainsKey(text3) && (FileTracker.FileIsUnderPath(text3, path) || !FileTracker.FileIsExcludedFromDependencies(text3)))\n                                    {\n                                        DateTime lastWriteFileUtcTime = NativeMethods.GetLastWriteFileUtcTime(text3);\n                                        value.Add(text3, lastWriteFileUtcTime);\n                                    }\n                                }\n                            }", "                                    if (text3[0] != '^' && text3[0] != '#' && !value.ContainsKey(text3) && (FileTracker.FileIsUnderPath(text3, path) || !FileTracker.FileIsExcludedFromDependencies(text3)))\n                                    {\n                                        DateTime lastWriteFileUtcTime = NativeMethods.GetLastWriteFileUtcTime(text3);\n                                        value.Add(text3, lastWriteFileUtcTime);\n                                    }\n                                }\n                            }\n                            while (text3 != null && text3[0] != '^');\n                            if (flag)\n                            {\n                                break;\n                            }\n                        }\n                        else\n                        {\n                            text3 = streamReader.ReadLine();\n                        }\n                    }\n                }", "                            if (flag)\n                            {\n                                break;\n                            }\n                        }\n                        else\n                        {\n                            text3 = streamReader.ReadLine();\n                        }\n                    }\n                }", "                catch (Exception ex2) when (ExceptionHandling.IsIoRelatedException(ex2))\n                {\n                    FileTracker.LogWarningWithCodeFromResources(_log, \"Tracking_RebuildingDueToInvalidTLog\", ex2.Message);\n                    break;\n                }\n                if (flag)\n                {\n                    FileTracker.LogWarningWithCodeFromResources(_log, \"Tracking_RebuildingDueToInvalidTLogContents\", text2);\n                    break;\n                }\n            }\n            lock (DependencyTableCache.DependencyTable)\n            {", "                if (flag)\n                {\n                    DependencyTableCache.DependencyTable.Remove(text);\n                    DependencyTable = new Dictionary<string, Dictionary<string, DateTime>>(StringComparer.OrdinalIgnoreCase);\n                }\n                else\n                {\n                    DependencyTableCache.DependencyTable[text] = new DependencyTableCacheEntry(_tlogFiles, DependencyTable);\n                }\n            }\n        }\n\n        public string[] RemoveRootsWithSharedOutputs(ITaskItem[] sources)\n        {\n            ErrorUtilities.VerifyThrowArgumentNull(sources, \"sources\");\n            List<string> list = new List<string>();\n            string text = FileTracker.FormatRootingMarker(sources);", "            if (DependencyTable.TryGetValue(text, out var value))\n            {\n                foreach (KeyValuePair<string, Dictionary<string, DateTime>> item in DependencyTable)\n                {\n                    if (text.Equals(item.Key, StringComparison.Ordinal))\n                    {\n                        continue;\n                    }\n                    foreach (string key in value.Keys)\n                    {\n                        if (item.Value.ContainsKey(key))\n                        {\n                            list.Add(item.Key);\n                            break;\n                        }\n                    }\n                }", "                    foreach (string key in value.Keys)\n                    {\n                        if (item.Value.ContainsKey(key))\n                        {\n                            list.Add(item.Key);\n                            break;\n                        }\n                    }\n                }\n                foreach (string item2 in list)\n                {\n                    DependencyTable.Remove(item2);\n                }\n            }\n            return list.ToArray();\n        }\n", "                foreach (string item2 in list)\n                {\n                    DependencyTable.Remove(item2);\n                }\n            }\n            return list.ToArray();\n        }\n\n        public bool RemoveOutputForSourceRoot(string sourceRoot, string outputPathToRemove)\n        {\n            if (DependencyTable.TryGetValue(sourceRoot, out var value))\n            {\n                bool result = value.Remove(outputPathToRemove);", "        public bool RemoveOutputForSourceRoot(string sourceRoot, string outputPathToRemove)\n        {\n            if (DependencyTable.TryGetValue(sourceRoot, out var value))\n            {\n                bool result = value.Remove(outputPathToRemove);\n                if (DependencyTable[sourceRoot].Count == 0)\n                {\n                    DependencyTable.Remove(sourceRoot);\n                }\n                return result;\n            }\n            return true;\n        }\n\n        public ITaskItem[] OutputsForNonCompositeSource(params ITaskItem[] sources)\n        {\n            Dictionary<string, ITaskItem> dictionary = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);\n            List<ITaskItem> list = new List<ITaskItem>();\n            string text = FileTracker.FormatRootingMarker(sources);", "            for (int i = 0; i < sources.Length; i++)\n            {\n                string sourceKey = FileUtilities.NormalizePath(sources[i].ItemSpec);\n                OutputsForSourceRoot(dictionary, sourceKey);\n            }\n            if (dictionary.Count == 0)\n            {\n                FileTracker.LogMessageFromResources(_log, MessageImportance.Low, \"Tracking_OutputForRootNotFound\", text);\n            }\n            else\n            {\n                list.AddRange(dictionary.Values);", "                if (dictionary.Count > 100)\n                {\n                    FileTracker.LogMessageFromResources(_log, MessageImportance.Low, \"Tracking_OutputsNotShown\", dictionary.Count);\n                }\n                else\n                {\n                    FileTracker.LogMessageFromResources(_log, MessageImportance.Low, \"Tracking_OutputsFor\", text);\n                    foreach (ITaskItem item in list)\n                    {\n                        FileTracker.LogMessage(_log, MessageImportance.Low, \"\\t\" + item);\n                    }\n                }\n            }\n            return list.ToArray();\n        }\n\n        public ITaskItem[] OutputsForSource(params ITaskItem[] sources)\n        {\n            return OutputsForSource(sources, searchForSubRootsInCompositeRootingMarkers: true);\n        }\n\n        public ITaskItem[] OutputsForSource(ITaskItem[] sources, bool searchForSubRootsInCompositeRootingMarkers)\n        {", "            if (!_tlogAvailable)\n            {\n                return null;\n            }\n            Dictionary<string, ITaskItem> dictionary = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);\n            string text = FileTracker.FormatRootingMarker(sources);\n            List<ITaskItem> list = new List<ITaskItem>();\n            foreach (string key in DependencyTable.Keys)\n            {\n                string text2 = key/*.ToUpperInvariant()*/;\n                if (searchForSubRootsInCompositeRootingMarkers && (text.Contains(text2) || text2.Contains(text) || CanonicalTrackedFilesHelper.RootContainsAllSubRootComponents(text, text2)))\n                {\n                    OutputsForSourceRoot(dictionary, text2);\n                }", "                if (searchForSubRootsInCompositeRootingMarkers && (text.Contains(text2) || text2.Contains(text) || CanonicalTrackedFilesHelper.RootContainsAllSubRootComponents(text, text2)))\n                {\n                    OutputsForSourceRoot(dictionary, text2);\n                }\n                else if (!searchForSubRootsInCompositeRootingMarkers && text2.Equals(text, StringComparison.Ordinal))\n                {\n                    OutputsForSourceRoot(dictionary, text2);\n                }\n            }\n            if (dictionary.Count == 0)\n            {\n                FileTracker.LogMessageFromResources(_log, MessageImportance.Low, \"Tracking_OutputForRootNotFound\", text);\n            }\n            else\n            {\n                list.AddRange(dictionary.Values);", "            if (dictionary.Count == 0)\n            {\n                FileTracker.LogMessageFromResources(_log, MessageImportance.Low, \"Tracking_OutputForRootNotFound\", text);\n            }\n            else\n            {\n                list.AddRange(dictionary.Values);\n                if (dictionary.Count > 100)\n                {\n                    FileTracker.LogMessageFromResources(_log, MessageImportance.Low, \"Tracking_OutputsNotShown\", dictionary.Count);\n                }\n                else\n                {\n                    FileTracker.LogMessageFromResources(_log, MessageImportance.Low, \"Tracking_OutputsFor\", text);", "                    foreach (ITaskItem item in list)\n                    {\n                        FileTracker.LogMessage(_log, MessageImportance.Low, \"\\t\" + item);\n                    }\n                }\n            }\n            return list.ToArray();\n        }\n\n        private void OutputsForSourceRoot(Dictionary<string, ITaskItem> outputs, string sourceKey)\n        {", "        private void OutputsForSourceRoot(Dictionary<string, ITaskItem> outputs, string sourceKey)\n        {\n            if (!DependencyTable.TryGetValue(sourceKey, out var value))\n            {\n                return;\n            }\n            foreach (string key in value.Keys)\n            {\n                if (!outputs.ContainsKey(key))\n                {\n                    outputs.Add(key, new TaskItem(key));\n                }\n            }\n        }\n", "                if (!outputs.ContainsKey(key))\n                {\n                    outputs.Add(key, new TaskItem(key));\n                }\n            }\n        }\n\n        public void AddComputedOutputForSourceRoot(string sourceKey, string computedOutput)\n        {\n            AddOutput(GetSourceKeyOutputs(sourceKey), computedOutput);\n        }\n", "        public void AddComputedOutputsForSourceRoot(string sourceKey, string[] computedOutputs)\n        {\n            Dictionary<string, DateTime> sourceKeyOutputs = GetSourceKeyOutputs(sourceKey);\n            foreach (string computedOutput in computedOutputs)\n            {\n                AddOutput(sourceKeyOutputs, computedOutput);\n            }\n        }\n\n        public void AddComputedOutputsForSourceRoot(string sourceKey, ITaskItem[] computedOutputs)\n        {\n            Dictionary<string, DateTime> sourceKeyOutputs = GetSourceKeyOutputs(sourceKey);", "        public void AddComputedOutputsForSourceRoot(string sourceKey, ITaskItem[] computedOutputs)\n        {\n            Dictionary<string, DateTime> sourceKeyOutputs = GetSourceKeyOutputs(sourceKey);\n            foreach (ITaskItem taskItem in computedOutputs)\n            {\n                AddOutput(sourceKeyOutputs, FileUtilities.NormalizePath(taskItem.ItemSpec));\n            }\n        }\n\n        private Dictionary<string, DateTime> GetSourceKeyOutputs(string sourceKey)\n        {", "            if (!DependencyTable.TryGetValue(sourceKey, out var value))\n            {\n                value = new Dictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);\n                DependencyTable.Add(sourceKey, value);\n            }\n            return value;\n        }\n\n        private static void AddOutput(Dictionary<string, DateTime> dependencies, string computedOutput)\n        {\n            var Output = FileUtilities.NormalizePath(computedOutput);\n\n            string text = Output/*.ToUpperInvariant()*/;", "        private static void AddOutput(Dictionary<string, DateTime> dependencies, string computedOutput)\n        {\n            var Output = FileUtilities.NormalizePath(computedOutput);\n\n            string text = Output/*.ToUpperInvariant()*/;\n            if (!dependencies.ContainsKey(text))\n            {\n                DateTime value = (FileUtilities.FileExistsNoThrow(Output) ? NativeMethods.GetLastWriteFileUtcTime(Output) : DateTime.MinValue);\n                dependencies.Add(text, value);\n            }\n        }\n", "        public void SaveTlog()\n        {\n            SaveTlog(null);\n        }\n\n        public void SaveTlog(DependencyFilter includeInTLog)\n        {\n            ITaskItem[] tlogFiles = _tlogFiles;\n            if (tlogFiles == null || tlogFiles.Length == 0)\n            {\n                return;\n            }\n            string key = DependencyTableCache.FormatNormalizedTlogRootingMarker(_tlogFiles);\n            lock (DependencyTableCache.DependencyTable)\n            {\n                DependencyTableCache.DependencyTable.Remove(key);\n            }\n            string itemSpec = _tlogFiles[0].ItemSpec;\n            ITaskItem[] tlogFiles2 = _tlogFiles;", "            if (tlogFiles == null || tlogFiles.Length == 0)\n            {\n                return;\n            }\n            string key = DependencyTableCache.FormatNormalizedTlogRootingMarker(_tlogFiles);\n            lock (DependencyTableCache.DependencyTable)\n            {\n                DependencyTableCache.DependencyTable.Remove(key);\n            }\n            string itemSpec = _tlogFiles[0].ItemSpec;\n            ITaskItem[] tlogFiles2 = _tlogFiles;", "            for (int i = 0; i < tlogFiles2.Length; i++)\n            {\n                File.WriteAllText(tlogFiles2[i].ItemSpec, \"\", Encoding.Unicode);\n            }\n            using StreamWriter streamWriter = FileUtilities.OpenWrite(itemSpec, append: false, Encoding.Unicode);\n            foreach (string key2 in DependencyTable.Keys)\n            {\n                Dictionary<string, DateTime> dictionary = DependencyTable[key2];\n                streamWriter.WriteLine(\"^\" + key2);\n                foreach (string key3 in dictionary.Keys)\n                {", "                foreach (string key3 in dictionary.Keys)\n                {\n                    if (includeInTLog == null || includeInTLog(key3))\n                    {\n                        streamWriter.WriteLine(key3);\n                    }\n                }\n            }\n\n            _tlogAvailable = true;\n        }\n", "        public void RemoveEntriesForSource(ITaskItem source)\n        {\n            RemoveEntriesForSource(new ITaskItem[1] { source }, null);\n        }\n\n        public void RemoveEntriesForSource(ITaskItem source, ITaskItem correspondingOutput)\n        {\n            RemoveEntriesForSource(new ITaskItem[1] { source }, new ITaskItem[1] { correspondingOutput });\n        }\n\n        public void RemoveEntriesForSource(ITaskItem[] source)\n        {\n            RemoveEntriesForSource(source, null);\n        }\n", "        public void RemoveEntriesForSource(ITaskItem[] source)\n        {\n            RemoveEntriesForSource(source, null);\n        }\n\n        public void RemoveEntriesForSource(ITaskItem[] source, ITaskItem[] correspondingOutputs)\n        {\n            string key = FileTracker.FormatRootingMarker(source, correspondingOutputs);\n            DependencyTable.Remove(key);\n            foreach (ITaskItem taskItem in source)\n            {\n                DependencyTable.Remove(FileUtilities.NormalizePath(taskItem.ItemSpec));\n            }\n        }\n", "            foreach (ITaskItem taskItem in source)\n            {\n                DependencyTable.Remove(FileUtilities.NormalizePath(taskItem.ItemSpec));\n            }\n        }\n\n        public void RemoveDependencyFromEntry(ITaskItem[] sources, ITaskItem dependencyToRemove)\n        {\n            string rootingMarker = FileTracker.FormatRootingMarker(sources);\n            RemoveDependencyFromEntry(rootingMarker, dependencyToRemove);\n        }\n", "        public void RemoveDependencyFromEntry(ITaskItem source, ITaskItem dependencyToRemove)\n        {\n            string rootingMarker = FileTracker.FormatRootingMarker(source);\n            RemoveDependencyFromEntry(rootingMarker, dependencyToRemove);\n        }\n\n        private void RemoveDependencyFromEntry(string rootingMarker, ITaskItem dependencyToRemove)\n        {\n            if (DependencyTable.TryGetValue(rootingMarker, out var value))\n            {\n                value.Remove(FileUtilities.NormalizePath(dependencyToRemove.ItemSpec));\n                return;\n            }\n            FileTracker.LogMessageFromResources(_log, MessageImportance.Normal, \"Tracking_WriteLogEntryNotFound\", rootingMarker);\n        }\n", "            if (DependencyTable.TryGetValue(rootingMarker, out var value))\n            {\n                value.Remove(FileUtilities.NormalizePath(dependencyToRemove.ItemSpec));\n                return;\n            }\n            FileTracker.LogMessageFromResources(_log, MessageImportance.Normal, \"Tracking_WriteLogEntryNotFound\", rootingMarker);\n        }\n\n        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source)\n        {\n            RemoveDependenciesFromEntryIfMissing(new ITaskItem[1] { source }, null);\n        }\n", "        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source)\n        {\n            RemoveDependenciesFromEntryIfMissing(new ITaskItem[1] { source }, null);\n        }\n\n        public void RemoveDependenciesFromEntryIfMissing(ITaskItem source, ITaskItem correspondingOutput)\n        {\n            RemoveDependenciesFromEntryIfMissing(new ITaskItem[1] { source }, new ITaskItem[1] { correspondingOutput });\n        }\n\n        public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source)\n        {\n            RemoveDependenciesFromEntryIfMissing(source, null);\n        }\n", "        public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source)\n        {\n            RemoveDependenciesFromEntryIfMissing(source, null);\n        }\n\n        public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source, ITaskItem[] correspondingOutputs)\n        {\n            Dictionary<string, bool> fileCache = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);\n            if (correspondingOutputs != null)\n            {\n                ErrorUtilities.VerifyThrowArgument(source.Length == correspondingOutputs.Length, \"Tracking_SourcesAndCorrespondingOutputMismatch\");\n            }\n            string rootingMarker = FileTracker.FormatRootingMarker(source, correspondingOutputs);\n            RemoveDependenciesFromEntryIfMissing(rootingMarker, fileCache);", "            if (correspondingOutputs != null)\n            {\n                ErrorUtilities.VerifyThrowArgument(source.Length == correspondingOutputs.Length, \"Tracking_SourcesAndCorrespondingOutputMismatch\");\n            }\n            string rootingMarker = FileTracker.FormatRootingMarker(source, correspondingOutputs);\n            RemoveDependenciesFromEntryIfMissing(rootingMarker, fileCache);\n            for (int i = 0; i < source.Length; i++)\n            {\n                rootingMarker = ((correspondingOutputs != null) ? FileTracker.FormatRootingMarker(source[i], correspondingOutputs[i]) : FileTracker.FormatRootingMarker(source[i]));\n                RemoveDependenciesFromEntryIfMissing(rootingMarker, fileCache);\n            }\n        }\n", "        private void RemoveDependenciesFromEntryIfMissing(string rootingMarker, Dictionary<string, bool> fileCache)\n        {\n            if (!DependencyTable.TryGetValue(rootingMarker, out var value))\n            {\n                return;\n            }\n            Dictionary<string, DateTime> dictionary = new Dictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);\n            int num = 0;\n            foreach (string key in value.Keys)\n            {\n                if (num++ > 0)\n                {", "            foreach (string key in value.Keys)\n            {\n                if (num++ > 0)\n                {\n                    if (!fileCache.TryGetValue(key, out var value2))\n                    {\n                        value2 = FileUtilities.FileExistsNoThrow(key);\n                        fileCache.Add(key, value2);\n                    }\n                    if (value2)\n                    {\n                        dictionary.Add(key, value[key]);\n                    }\n                }\n                else\n                {\n                    dictionary.Add(key, DateTime.Now);\n                }\n            }\n            DependencyTable[rootingMarker] = dictionary;\n        }\n    }\n}\n", "                    if (value2)\n                    {\n                        dictionary.Add(key, value[key]);\n                    }\n                }\n                else\n                {\n                    dictionary.Add(key, DateTime.Now);\n                }\n            }\n            DependencyTable[rootingMarker] = dictionary;\n        }\n    }\n}\n"]}
