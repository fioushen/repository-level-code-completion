{"filename": "src/apphost-extract/apphost-extract/AppHostFile.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection.PortableExecutable;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace apphost_extract\n{\n    public class AppHostFile\n    {", "namespace apphost_extract\n{\n    public class AppHostFile\n    {\n        private FileStream FileStream;\n\n        public AppHostFileHeader Header { get; set; }\n        private ApphostVersion Version { get; set; }\n\n        private const int VERSION_OFFSET_NET3 = 0x1A3E8;\n", "        private const int VERSION_OFFSET_NET3 = 0x1A3E8;\n\n        private const int HEADER_OFFSET_PTR_NET5 = 0x8E508;\n        private const int HEADER_OFFSET_PTR_NET3 = 0x27600;\n\n       \n\n        public AppHostFile(FileStream fileStream) \n        {\n            FileStream = fileStream;\n\n            //RDATA = GetRDATASection(fileStream);\n            var ver = GetVersion(VERSION_OFFSET_NET3);\n            var headerVA = GetHeaderAddress(HEADER_OFFSET_PTR_NET3);\n            \n            Header = new AppHostFileHeader(FileStream, headerVA);\n        }\n", "        private int GetRDATASection(FileStream fileStream)\n        {\n            var pefile = new PEReader(fileStream);\n            var sectionHeaders = pefile.PEHeaders.SectionHeaders;\n            return sectionHeaders.Where(header => header.Name == \".rdata\").FirstOrDefault().VirtualAddress + 0x668;\n        }\n\n        public int GetHeaderAddress(int offset)\n        {\n            var buffer = new byte[16];\n            FileStream.Seek(offset, SeekOrigin.Begin);\n            FileStream.Read(buffer, 0, buffer.Length);\n            return BitConverter.ToInt32(buffer, 0);\n        }\n", "        public ApphostVersion GetVersion(int offset)\n        {\n            FileStream.Seek(offset, SeekOrigin.Begin);\n            var buffer = new byte[10];\n            FileStream.Read(buffer, 0, buffer.Length);\n            var versionStr = Encoding.Unicode.GetString(buffer);\n\n            if (versionStr.StartsWith(\"3.\"))\n            {\n                Log.Info(\"Detected .NET Core 3.\");\n                return ApphostVersion.NET3;\n            }\n            else\n            {\n                Log.Info(\"Could not detect .NET Core version, assumming .NET Core 5.\");\n                return ApphostVersion.NET5;\n            }\n        }\n\n", "        public static AppHostFile Open(string path)\n        {\n            try\n            {\n                FileStream fs = new FileStream(path, FileMode.Open, FileAccess.ReadWrite);\n                AppHostFile file = new AppHostFile(fs);\n                Log.Info(\"File opened successfully!\");\n                return file;\n            }\n            catch(Exception ex)\n            {\n                Log.Fatal($\"Exception when trying to open file: {ex.Message}\");\n                return null;\n            }\n        }\n", "            catch(Exception ex)\n            {\n                Log.Fatal($\"Exception when trying to open file: {ex.Message}\");\n                return null;\n            }\n        }\n\n        public void ExtractAll(string outputDir)\n        {\n            Directory.CreateDirectory(outputDir);\n            foreach (var fileEntry in Header.Manifest.FileEntries)\n            {\n                try\n                {\n                    var bytes = fileEntry.Read();\n                    var name = fileEntry.Name;\n                    var filePath = Path.Combine(outputDir, name);\n                    File.WriteAllBytes(filePath, bytes);\n\n                    Log.Critical($\"Extracted {name}\");\n\n                }", "            foreach (var fileEntry in Header.Manifest.FileEntries)\n            {\n                try\n                {\n                    var bytes = fileEntry.Read();\n                    var name = fileEntry.Name;\n                    var filePath = Path.Combine(outputDir, name);\n                    File.WriteAllBytes(filePath, bytes);\n\n                    Log.Critical($\"Extracted {name}\");\n\n                }", "                catch (Exception ex)\n                {\n                    Log.Error($\"Could not extract {fileEntry.Name}: {ex.Message}\");\n                }\n\n            }\n        }\n\n        public void Close()\n        {\n            FileStream.Close();\n        }\n    }\n", "        public void Close()\n        {\n            FileStream.Close();\n        }\n    }\n\n    public enum ApphostVersion\n    {\n        NET5,\n        NET3\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract/AppHostFileHeader.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace apphost_extract\n{\n    public class AppHostFileHeader\n    {", "{\n    public class AppHostFileHeader\n    {\n        private const int HEADER_SIZE = 0xD;\n\n        private byte[] Raw;\n\n        public string Path { get; set; }\n        \n        public AppHostManifest Manifest { get; set; }\n\n        public AppHostFileHeader(FileStream File, long HeaderOffset)\n        {\n            File.Seek(HeaderOffset, SeekOrigin.Begin);\n            byte[] headerBuffer = new byte[HEADER_SIZE];\n            File.Read(headerBuffer, 0, HEADER_SIZE);\n            Raw = headerBuffer;\n\n            byte[] stringBuffer = new byte[Raw[0xC]];\n            File.Read(stringBuffer, 0, stringBuffer.Length);\n            Path = Encoding.UTF8.GetString(stringBuffer);\n            Log.Info(\"Header parsed successfully!\");\n\n            Manifest = new AppHostManifest(File, BitConverter.ToInt32(Raw, 0x8));\n\n           \n        }\n\n        \n    }\n}\n", "        public AppHostManifest Manifest { get; set; }\n\n        public AppHostFileHeader(FileStream File, long HeaderOffset)\n        {\n            File.Seek(HeaderOffset, SeekOrigin.Begin);\n            byte[] headerBuffer = new byte[HEADER_SIZE];\n            File.Read(headerBuffer, 0, HEADER_SIZE);\n            Raw = headerBuffer;\n\n            byte[] stringBuffer = new byte[Raw[0xC]];\n            File.Read(stringBuffer, 0, stringBuffer.Length);\n            Path = Encoding.UTF8.GetString(stringBuffer);\n            Log.Info(\"Header parsed successfully!\");\n\n            Manifest = new AppHostManifest(File, BitConverter.ToInt32(Raw, 0x8));\n\n           \n        }\n\n        \n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract/Log.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\npublic static class Log\n{\n    public static void Critical(object value)\n    {\n        Color(ConsoleColor.Magenta);\n        Console.WriteLine(\"[!] \" + value.ToString());\n        Color();\n    }\n", "    public static void Critical(object value)\n    {\n        Color(ConsoleColor.Magenta);\n        Console.WriteLine(\"[!] \" + value.ToString());\n        Color();\n    }\n\n    public static void Info(object value)\n    {\n        Color(ConsoleColor.Cyan);\n        Console.WriteLine(\"[+] \" + value.ToString());\n    }\n", "    public static bool QueryYesNo(string question)\n    {\n        var input = QueryString(question);\n        if (input.ToLower().StartsWith(\"y\")) return true;\n        else return false;\n    }\n\n    public static string QueryString(string question)\n    {\n        Color(ConsoleColor.Yellow);\n        Console.Write(\"[?] \" + question);\n        Color();\n        return Console.ReadLine();\n    }\n", "    public static void Info(object value, ConsoleColor color)\n    {\n        Color(color);\n        Console.WriteLine(\"[+] \" + value.ToString());\n    }\n\n    public static void Error(object value)\n    {\n        Color(ConsoleColor.Red);\n        Console.WriteLine(\"[-] \" + value.ToString());\n        Color();\n    }\n", "    public static void Fatal(object value)\n    {\n        Error(value);\n        Console.ReadLine();\n        Environment.Exit(0);\n    }\n\n    private static void Color(ConsoleColor color = ConsoleColor.White)\n    {\n        Console.ForegroundColor = color;\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract/AppHostManifest.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace apphost_extract\n{\n    public class AppHostManifest\n    {\n        public IReadOnlyList<AppHostFileEntry> FileEntries { get; set; }\n\n        public AppHostManifest(FileStream File, int embeddedFileCount)\n        {\n            List<AppHostFileEntry> entries = new List<AppHostFileEntry>();\n            ", "{\n    public class AppHostManifest\n    {\n        public IReadOnlyList<AppHostFileEntry> FileEntries { get; set; }\n\n        public AppHostManifest(FileStream File, int embeddedFileCount)\n        {\n            List<AppHostFileEntry> entries = new List<AppHostFileEntry>();\n            \n            for(int i = 0; i < embeddedFileCount; i++)\n            {\n                AppHostFileEntry entry = new AppHostFileEntry(File);\n                entries.Add(entry);\n            }\n            FileEntries = entries.AsReadOnly();\n\n            Log.Info(\"Manifest parsed successfully!\");\n        }\n    }\n}\n", "            for(int i = 0; i < embeddedFileCount; i++)\n            {\n                AppHostFileEntry entry = new AppHostFileEntry(File);\n                entries.Add(entry);\n            }\n            FileEntries = entries.AsReadOnly();\n\n            Log.Info(\"Manifest parsed successfully!\");\n        }\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract/Program.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace apphost_extract\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Log.Info(\"apphost-extract by VollRagm\\n\", ConsoleColor.Yellow);\n            var path = GetPath(args);\n\n            var path2 = \"test.exe\";\n            //var path2 = \"AmongUsUnlocker.exe\";\n\n            var file = AppHostFile.Open(path2);//path.FullName);\n            Log.Info($\"{file.Header.Manifest.FileEntries.Count} embedded file(s) found.\");\n\n            var directory = Path.Combine(path.DirectoryName, path.Name.Remove(path.Name.Length - path.Extension.Length) +\"_extracted\");\n            Console.WriteLine();\n            Log.Info(\"Extracting...\");\n\n            file.ExtractAll(directory);\n\n            Console.WriteLine();\n            Log.Info(\"Done.\");\n            file.Close();\n            Console.ReadLine();\n        }\n\n        static FileInfo GetPath(string[] args)\n        {\n            try\n            {\n                var fileName = new FileInfo(Assembly.GetExecutingAssembly().Location).Name;\n", "namespace apphost_extract\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Log.Info(\"apphost-extract by VollRagm\\n\", ConsoleColor.Yellow);\n            var path = GetPath(args);\n\n            var path2 = \"test.exe\";\n            //var path2 = \"AmongUsUnlocker.exe\";\n\n            var file = AppHostFile.Open(path2);//path.FullName);\n            Log.Info($\"{file.Header.Manifest.FileEntries.Count} embedded file(s) found.\");\n\n            var directory = Path.Combine(path.DirectoryName, path.Name.Remove(path.Name.Length - path.Extension.Length) +\"_extracted\");\n            Console.WriteLine();\n            Log.Info(\"Extracting...\");\n\n            file.ExtractAll(directory);\n\n            Console.WriteLine();\n            Log.Info(\"Done.\");\n            file.Close();\n            Console.ReadLine();\n        }\n\n        static FileInfo GetPath(string[] args)\n        {\n            try\n            {\n                var fileName = new FileInfo(Assembly.GetExecutingAssembly().Location).Name;\n", "                if (args.Length > 0)\n                {\n                    if (File.Exists(args[0]))\n                    {\n                        return new FileInfo(args[0]);\n                    }\n                    else\n                    {\n                        Log.Fatal($\"{args[0]} could not be found. Usage: {fileName} <path>\");\n                    }\n                }\n                else\n                {\n                    Log.Fatal($\"No File provided. Usage: {fileName} <path>\");\n                }", "            }catch(Exception ex)\n            {\n                Log.Fatal($\"Could not get file: {ex.Message}\");\n            }\n            return null;\n        }\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract/AppHostFileEntry.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace apphost_extract\n{\n    public class AppHostFileEntry\n    {", "{\n    public class AppHostFileEntry\n    {\n        public long Offset { get; set; }\n        public int Size { get; set; }\n        public string Name { get; set; }\n\n        private byte[] Raw;\n        private FileStream FileStream;\n\n        private const int FILE_ENTRY_SIZE = 0x12;\n\n        public AppHostFileEntry(FileStream File)\n        {\n            FileStream = File;\n            byte[] entryBuffer = new byte[FILE_ENTRY_SIZE];\n            File.Read(entryBuffer, 0, entryBuffer.Length);\n            Raw = entryBuffer;\n\n            Offset = BitConverter.ToInt64(Raw, 0);\n\n            //hopefully nobody embeds a file larger than 2GB :D\n            Size = (int)BitConverter.ToInt64(Raw, 0x8); \n\n            byte[] stringBuffer = new byte[Raw[0x11]];\n            File.Read(stringBuffer, 0, stringBuffer.Length);\n            Name = Encoding.UTF8.GetString(stringBuffer);\n        }\n\n        public byte[] Read()\n        {\n            //jumps to the offsets and reads the bytes\n            byte[] buffer = new byte[Size];\n            FileStream.Seek(Offset, SeekOrigin.Begin);\n            FileStream.Read(buffer, 0, Size);\n            return buffer;\n        }\n    }\n}\n", "        private FileStream FileStream;\n\n        private const int FILE_ENTRY_SIZE = 0x12;\n\n        public AppHostFileEntry(FileStream File)\n        {\n            FileStream = File;\n            byte[] entryBuffer = new byte[FILE_ENTRY_SIZE];\n            File.Read(entryBuffer, 0, entryBuffer.Length);\n            Raw = entryBuffer;\n\n            Offset = BitConverter.ToInt64(Raw, 0);\n\n            //hopefully nobody embeds a file larger than 2GB :D\n            Size = (int)BitConverter.ToInt64(Raw, 0x8); \n\n            byte[] stringBuffer = new byte[Raw[0x11]];\n            File.Read(stringBuffer, 0, stringBuffer.Length);\n            Name = Encoding.UTF8.GetString(stringBuffer);\n        }\n\n        public byte[] Read()\n        {\n            //jumps to the offsets and reads the bytes\n            byte[] buffer = new byte[Size];\n            FileStream.Seek(Offset, SeekOrigin.Begin);\n            FileStream.Read(buffer, 0, Size);\n            return buffer;\n        }\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract/Properties/AssemblyInfo.cs", "chunked_list": ["\ufeffusing System.Reflection;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n\n// General Information about an assembly is controlled through the following\n// set of attributes. Change these attribute values to modify the information\n// associated with an assembly.\n[assembly: AssemblyTitle(\"apphost-extract\")]\n[assembly: AssemblyDescription(\"\")]\n[assembly: AssemblyConfiguration(\"\")]", "[assembly: AssemblyDescription(\"\")]\n[assembly: AssemblyConfiguration(\"\")]\n[assembly: AssemblyCompany(\"\")]\n[assembly: AssemblyProduct(\"apphost-extract\")]\n[assembly: AssemblyCopyright(\"Copyright \u00a9  2021\")]\n[assembly: AssemblyTrademark(\"\")]\n[assembly: AssemblyCulture(\"\")]\n\n// Setting ComVisible to false makes the types in this assembly not visible\n// to COM components.  If you need to access a type in this assembly from", "// Setting ComVisible to false makes the types in this assembly not visible\n// to COM components.  If you need to access a type in this assembly from\n// COM, set the ComVisible attribute to true on that type.\n[assembly: ComVisible(false)]\n\n// The following GUID is for the ID of the typelib if this project is exposed to COM\n[assembly: Guid(\"150e6d0d-598e-40e7-b7dd-3941f31e5c63\")]\n\n// Version information for an assembly consists of the following four values:\n//", "// Version information for an assembly consists of the following four values:\n//\n//      Major Version\n//      Minor Version\n//      Build Number\n//      Revision\n//\n// You can specify all the values or you can default the Build and Revision Numbers\n// by using the '*' as shown below:\n// [assembly: AssemblyVersion(\"1.0.*\")]", "// by using the '*' as shown below:\n// [assembly: AssemblyVersion(\"1.0.*\")]\n[assembly: AssemblyVersion(\"1.0.0.0\")]\n[assembly: AssemblyFileVersion(\"1.0.0.0\")]\n"]}
{"filename": "src/apphost-extract/TestProject/Program.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Security.Cryptography;\n\nnamespace TestProject\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // this originally was meant to test the extractor and now turned into the hash generator\n            Console.WriteLine(\"Generating hashes.txt...\");\n            var existing = File.ReadAllLines(\"hashes.txt\").ToList();\n            var files = Directory.GetFiles(\".\\\\files\");\n            SHA256Managed sha = new SHA256Managed();", "    class Program\n    {\n        static void Main(string[] args)\n        {\n            // this originally was meant to test the extractor and now turned into the hash generator\n            Console.WriteLine(\"Generating hashes.txt...\");\n            var existing = File.ReadAllLines(\"hashes.txt\").ToList();\n            var files = Directory.GetFiles(\".\\\\files\");\n            SHA256Managed sha = new SHA256Managed();\n            foreach (var file in files)\n            {\n                try\n                {\n                    var hash = BitConverter.ToString(sha.ComputeHash(File.ReadAllBytes(file))).Replace(\"-\", \"\");", "            foreach (var file in files)\n            {\n                try\n                {\n                    var hash = BitConverter.ToString(sha.ComputeHash(File.ReadAllBytes(file))).Replace(\"-\", \"\");\n                    if (existing.Contains(hash))\n                    {\n                        Console.WriteLine(file + \" is known\");\n                        continue;\n                    }\n                    File.AppendAllText(\"hashes.txt\", hash + \"\\n\");\n                    existing.Add(hash);\n                }\n                catch\n                {\n                    Console.WriteLine(\"exception lol\");\n                }\n            }\n\n        }\n\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract-v2/Util.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection.PortableExecutable;\nusing System.Text;\n\nnamespace apphost_extract_v2\n{\n    public static class Util\n    {", "{\n    public static class Util\n    {\n        public static int[] PatternScan(FileStream fs, int start, int length, byte[] pattern, string mask)\n        {\n            byte[] scanBuffer = fs.ReadBuffer(start, length);\n\n            List<int> scanResults = new List<int>();\n\n            for(int i = 0; i < scanBuffer.Length - pattern.Length; i++)\n            {", "            for(int i = 0; i < scanBuffer.Length - pattern.Length; i++)\n            {\n                if (!IsMatch(scanBuffer, i, pattern, mask))\n                    continue;\n\n                scanResults.Add(start + i);\n            }\n\n            return scanResults.ToArray();\n        }\n\n\n        //https://stackoverflow.com/a/283648/10724593", "        private static bool IsMatch(byte[] array, int position, byte[] candidate, string mask)\n        {\n            if (candidate.Length > (array.Length - position))\n                return false;\n\n            for (int i = 0; i < candidate.Length; i++)\n                if (mask[i] == 'x' && array[position + i] != candidate[i])\n                    return false;\n\n            return true;\n        }\n", "        public static byte[] ReadBuffer(this FileStream fs, long start, int length)\n        {\n            byte[] buff = new byte[length];\n            lock (fs)\n            {\n                fs.Seek(start, SeekOrigin.Begin);\n                fs.Read(buff, 0, length);\n            }\n            return buff;\n        }\n", "        public static int AddVirtualOffset(this PEHeaders header, int fileAddress, int offset)\n        {\n            return header.VirtualAddressToFileOffset(header.FileOffsetToVirtualAddress(fileAddress) + offset);\n        }\n\n        public static int FileOffsetToVirtualAddress(this PEHeaders header, int offset)\n        {\n            var section = header.FindSection(offset, true);\n            return offset + (section.VirtualAddress - section.PointerToRawData);\n        }\n", "        public static int VirtualAddressToFileOffset(this PEHeaders header, int address)\n        {\n            var section = header.FindSection(address, false);\n            return address - (section.VirtualAddress - section.PointerToRawData);\n        }\n\n        public static SectionHeader GetSegment(this PEHeaders header, string name)\n        {\n            var section = header.SectionHeaders.Where(x => x.Name == name).FirstOrDefault();\n            return section;\n        }\n", "        public static SectionHeader FindSection(this PEHeaders header, int address, bool fileOffset)\n        {\n            foreach (var section in header.SectionHeaders)\n            {\n                if (fileOffset)\n                {\n                    if (section.PointerToRawData < address && section.PointerToRawData + section.SizeOfRawData > address) return section;\n                }\n                else\n                    if (section.VirtualAddress < address && section.VirtualAddress + section.VirtualSize > address) return section;\n            }\n\n            return new SectionHeader();\n        }\n    }\n}\n", "                    if (section.VirtualAddress < address && section.VirtualAddress + section.VirtualSize > address) return section;\n            }\n\n            return new SectionHeader();\n        }\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract-v2/FileChecker.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Security.Cryptography;\nusing System.Security.Cryptography.X509Certificates;\nusing System.Text;\n\nnamespace apphost_extract_v2", "\nnamespace apphost_extract_v2\n{\n    public static class FileChecker\n    {\n        private const string HASHFILE = \"apphost-hashes.txt\"; \n        private static string[] Hashes;\n        private static SHA256Managed sha = new SHA256Managed();\n\n        public static void Load()\n        {\n            var path = Path.Combine(Path.GetDirectoryName(System.AppContext.BaseDirectory), HASHFILE);", "        public static void Load()\n        {\n            var path = Path.Combine(Path.GetDirectoryName(System.AppContext.BaseDirectory), HASHFILE);\n            if (File.Exists(path))\n                Hashes = File.ReadAllLines(path);\n            else\n            {\n                Log.Error(\"apphost-hashes.txt wasn't found, only running cert check.\");\n                Console.WriteLine();\n                Hashes = new string[0];\n            }\n        }\n", "        public static bool IsKnownFile(byte[] buffer)\n        {\n            string hash = \"\";\n            lock (sha)\n            {\n                hash = BitConverter.ToString(sha.ComputeHash(buffer)).Replace(\"-\", \"\");\n            }\n            return Hashes.Contains(hash) || SignedByMS(buffer);\n        }\n\n        public static bool SignedByMS(byte[] buffer)\n        {\n            try\n            {\n                X509Certificate cert = new X509Certificate(buffer);\n                return cert.GetCertHashString() == \"2485A7AFA98E178CB8F30C9838346B514AEA4769\";\n            }catch { return false; }\n        }\n\n\n\n\n\n\n\n\n\n\n\n    }\n}\n", "        public static bool SignedByMS(byte[] buffer)\n        {\n            try\n            {\n                X509Certificate cert = new X509Certificate(buffer);\n                return cert.GetCertHashString() == \"2485A7AFA98E178CB8F30C9838346B514AEA4769\";\n            }catch { return false; }\n        }\n\n\n\n\n\n\n\n\n\n\n\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract-v2/Log.cs", "chunked_list": ["\ufeffusing System;\n\npublic static class Log\n{\n    public static void Critical(object value)\n    {\n        Color(ConsoleColor.Magenta);\n        Console.WriteLine(\"[!] \" + value.ToString());\n        Color();\n    }\n", "    public static void Info(object value)\n    {\n        Color(ConsoleColor.Cyan);\n        Console.WriteLine(\"[+] \" + value.ToString());\n    }\n\n    public static bool QueryYesNo(string question)\n    {\n        var input = QueryString(question);\n        if (input.ToLower().StartsWith(\"y\")) return true;\n        else return false;\n    }\n", "        if (input.ToLower().StartsWith(\"y\")) return true;\n        else return false;\n    }\n\n    public static string QueryString(string question)\n    {\n        Color(ConsoleColor.Yellow);\n        Console.Write(\"[?] \" + question);\n        Color();\n        return Console.ReadLine();\n    }\n", "    public static void Info(object value, ConsoleColor color)\n    {\n        Color(color);\n        Console.WriteLine(\"[+] \" + value.ToString());\n    }\n\n    public static void Error(object value)\n    {\n        Color(ConsoleColor.Red);\n        Console.WriteLine(\"[-] \" + value.ToString());\n        Color();\n    }\n", "    public static void Fatal(object value)\n    {\n        Error(value);\n        Console.ReadLine();\n        Environment.Exit(0);\n    }\n\n    private static void Color(ConsoleColor color = ConsoleColor.White)\n    {\n        Console.ForegroundColor = color;\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract-v2/Analyzer.cs", "chunked_list": ["\ufeffusing apphost_extract_v2.General;\nusing apphost_extract_v2.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection.PortableExecutable;\nusing System.Text;\nusing static apphost_extract_v2.Util;", "using System.Text;\nusing static apphost_extract_v2.Util;\n\nnamespace apphost_extract_v2\n{\n    public class Analyzer\n    {\n        private FileStream File;\n        public PEHeaders PEHeader;\n\n        private readonly byte[] VERSION_SIGNATURE = new byte[] { 0x4C, 0x8D, 0x05, 0x0, 0x0, 0x0, 0x0, 0x48, 0x8D, 0x15, 0x0, 0x0, 0x0, 0x0, 0x48, 0x8D, 0x0D, 0x0, 0x0, 0x0, 0x0 };", "        public PEHeaders PEHeader;\n\n        private readonly byte[] VERSION_SIGNATURE = new byte[] { 0x4C, 0x8D, 0x05, 0x0, 0x0, 0x0, 0x0, 0x48, 0x8D, 0x15, 0x0, 0x0, 0x0, 0x0, 0x48, 0x8D, 0x0D, 0x0, 0x0, 0x0, 0x0 };\n        private const string VERSION_SIGNATURE_MASK = \"xxx???xxxx???xxxx???x\";\n\n        public Analyzer(FileInfo fi)\n        {\n            File = new FileStream(fi.FullName, FileMode.Open, FileAccess.Read);\n            PEHeader = new PEHeaders(File);\n        }\n", "        public IApphostFile Open()\n        {\n              var textSegment = PEHeader.GetSegment(\".text\");\n\n              var sw = Stopwatch.StartNew();\n              Log.Info(\"Scanning for version string pointer...\");\n\n              var sigscanResults = PatternScan(File, \n                                  textSegment.PointerToRawData, textSegment.SizeOfRawData,\n                                      VERSION_SIGNATURE, VERSION_SIGNATURE_MASK);\n              sw.Stop();\n", "              if (sigscanResults.Length == 0)\n                  return null;\n\n              var versionOffset = (int)BitConverter.ToUInt32(File.ReadBuffer(sigscanResults[0] + 3, 4));\n              var versionStringPtr = PEHeader.AddVirtualOffset(sigscanResults[0] + 7, versionOffset);\n              var versionString = Encoding.Unicode.GetString(\n                                                  File.ReadBuffer(\n                                                      versionStringPtr, 6));\n\n              Log.Info($\"Found version string at 0x{versionStringPtr:X8} in {sw.ElapsedMilliseconds}ms -> {versionString}\");\n              Console.WriteLine();\n\n\n            switch (versionString)\n            {\n                case \"3.0\":\n                    return new ApphostFile30(File, PEHeader);\n                case \"3.1\":\n                    return new ApphostFile31(File, PEHeader);\n                case \"5.0\":\n                    return new ApphostFile5(File, PEHeader);\n                case \"6.0\":\n                    return new ApphostFile6(File, PEHeader);\n                case \"7.0\":\n                    return new ApphostFile7(File, PEHeader);\n                default:\n                    return null;\n            }\n        }\n", "        public IApphostFile Open(string versionString, uint headerOffset)\n        {\n            switch (versionString)\n            {\n                case \"3.0\":\n                    return new ApphostFile30(File, PEHeader, headerOffset);\n                case \"3.1\":\n                    return new ApphostFile31(File, PEHeader, headerOffset);\n                case \"5.0\":\n                    return new ApphostFile5(File, PEHeader, headerOffset);\n                case \"6.0\":\n                    return new ApphostFile6(File, PEHeader, headerOffset);\n                case \"7.0\":\n                    return new ApphostFile7(File, PEHeader, headerOffset);\n                default:\n                    return null;\n            }\n        }\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract-v2/Program.cs", "chunked_list": ["\ufeffusing System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.MemoryMappedFiles;\nusing System.Reflection;\n\nnamespace apphost_extract_v2\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Log.Info(\"apphost-extract-v2 by VollRagm\\n\", ConsoleColor.Yellow);\n\n            FileChecker.Load();\n\n            var fileInfo = GetFileInfo(args);\n\n            var apphostAnalyzer = new Analyzer(fileInfo);\n            var apphost = apphostAnalyzer.Open();\n", "    class Program\n    {\n        static void Main(string[] args)\n        {\n            Log.Info(\"apphost-extract-v2 by VollRagm\\n\", ConsoleColor.Yellow);\n\n            FileChecker.Load();\n\n            var fileInfo = GetFileInfo(args);\n\n            var apphostAnalyzer = new Analyzer(fileInfo);\n            var apphost = apphostAnalyzer.Open();\n", "            if (apphost == null)\n            {\n                Log.Error(\"Unable to determine apphost version automatically.\");\n                var version = Log.QueryString(\"Please enter the apphost version, you can find it in the entry point of the app (3.0, 3.1, 5.0, 6.0, 7.0): \");\n                var headerOffset = uint.Parse(Log.QueryString(\"Please enter the Header offset \\n(parse pdb, search for header_offset in names or\\n use string reference 'Bundle Header Offset: [%lx]', find the .data ptr and enter its value): \").Replace(\"0x\", \"\"), System.Globalization.NumberStyles.HexNumber);\n                \n                apphostAnalyzer = new Analyzer(fileInfo);\n                apphost = apphostAnalyzer.Open(version, headerOffset);\n            }\n                \n\n            Log.Info(\"File parsed successfully, extracting contents...\");\n            Console.WriteLine();\n\n            var directory = Path.Combine(fileInfo.DirectoryName, fileInfo.Name.Remove(fileInfo.Name.Length - fileInfo.Extension.Length) + \"_extracted\");\n            apphost.ExtractAll(directory);\n\n            Log.Info(\"Extraction completed successfully and unknown files have been prefixed with _ .\");\n            Console.ReadLine();\n        }\n\n        static FileInfo GetFileInfo(string[] args)\n        {\n            try\n            {\n                var fileName = new FileInfo(System.AppContext.BaseDirectory).Name;\n", "                if (args.Length > 0)\n                {\n                    if (File.Exists(args[0]))\n                    {\n                        var fullPath = Path.GetFullPath(args[0]);\n                        return new FileInfo(fullPath);\n                    }\n                    else\n                    {\n                        Log.Fatal($\"{args[0]} could not be found. Usage: {fileName} <path>\");\n                    }\n                }\n                else\n                {\n                    Log.Fatal($\"No File provided. Usage: {fileName} <path>\");\n                }\n            }", "            catch (Exception ex)\n            {\n                Log.Fatal($\"Could not get file: {ex.Message}\");\n            }\n            return null;\n        }\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract-v2/Models/ApphostFile7.cs", "chunked_list": ["\ufeffusing apphost_extract_v2.General;\nusing System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Reflection.PortableExecutable;\nusing System.Text;\nusing static apphost_extract_v2.Util;\n\nnamespace apphost_extract_v2.Models\n{\n    public class ApphostFile7 : IApphostFile\n    {", "namespace apphost_extract_v2.Models\n{\n    public class ApphostFile7 : IApphostFile\n    {\n        private readonly byte[] HEADER_OFFSET_SIG = { 0xE8, 0x0, 0x0, 0x0, 0x0, 0x48, 0x8B, 0x05, 0x0, 0x0, 0x0, 0x0, 0x48, 0x85, 0xC0 };\n        private const string HEADER_OFFSET_MASK = \"x????xxx????xxx\";\n\n        private const int HEADER_SIZE = 0xD;\n        private const int FILE_ENTRY_SIZE = 0x1A;\n\n        public ApphostFile7(FileStream fs, PEHeaders peheader) : base(fs, peheader)\n        {\n            Header = new AppHostFileHeader();\n            var headerAddress = FindHeaderOffset();\n", "        private const int FILE_ENTRY_SIZE = 0x1A;\n\n        public ApphostFile7(FileStream fs, PEHeaders peheader) : base(fs, peheader)\n        {\n            Header = new AppHostFileHeader();\n            var headerAddress = FindHeaderOffset();\n\n            if (headerAddress == 0)\n            {\n                Log.Error(\"Unable to located bundle header :/\");\n                var headerOffset = uint.Parse(Log.QueryString(\"Please enter the Header offset \\n(parse pdb, search for header_offset in names or\\n use string reference 'Bundle Header Offset: [%lx]', find the .data ptr and enter its value): \").Replace(\"0x\", \"\"), System.Globalization.NumberStyles.HexNumber);\n                headerAddress = headerOffset;\n            }\n\n            var headerBuffer = fs.ReadBuffer(headerAddress, HEADER_SIZE);\n\n            Header.Raw = headerBuffer;\n            Header.Path = Encoding.UTF8.GetString(\n                                fs.ReadBuffer(headerAddress + HEADER_SIZE, 0xC));\n\n            Header.Manifest = ParseManifest();\n\n        }\n\n        public ApphostFile7(FileStream fs, PEHeaders peheader, uint headerOffset) : base(fs, peheader)\n        {\n            Header = new AppHostFileHeader();\n            var headerAddress = headerOffset;\n", "            if (headerAddress == 0)\n                Log.Fatal(\"Unable to located bundle header :/\");\n\n            var headerBuffer = fs.ReadBuffer(headerAddress, HEADER_SIZE);\n\n            Header.Raw = headerBuffer;\n            Header.Path = Encoding.UTF8.GetString(\n                                fs.ReadBuffer(headerAddress + HEADER_SIZE, 0xC));\n\n            Header.Manifest = ParseManifest();\n\n        }\n", "        private uint FindHeaderOffset()\n        {\n            var textSegment = PEHeader.GetSegment(\".text\");\n            Log.Info(\"Scanning for the .NET 7 Bundle header...\");\n            var sw = Stopwatch.StartNew();\n\n            var sigscanResults = PatternScan(FileStream,\n                                    textSegment.PointerToRawData, textSegment.SizeOfRawData,\n                                        HEADER_OFFSET_SIG, HEADER_OFFSET_MASK);\n\n            sw.Stop();\n", "            if (sigscanResults.Length == 0) return 0;\n\n            var headerOffset = (int)BitConverter.ToUInt32(\n                                    FileStream.ReadBuffer(sigscanResults[0] + 8, 4));\n\n            var headerPtr = PEHeader.AddVirtualOffset(sigscanResults[0] + 12, headerOffset);\n            var headerAddress = BitConverter.ToUInt32(FileStream.ReadBuffer(headerPtr, 4));\n\n            Log.Info($\"Found bundle header offset at 0x{headerPtr:X8} in {sw.ElapsedMilliseconds}ms -> {headerAddress:X8}\");\n            return headerAddress;\n        }\n", "        private AppHostManifest ParseManifest()\n        {\n            //Seek over random bullshit that got added in .NET 5\n            FileStream.Seek(0x3C, SeekOrigin.Current);\n\n            AppHostManifest manifest = new AppHostManifest();\n            var embeddedFileCount = BitConverter.ToInt32(Header.Raw, 0x8);\n            Log.Info($\"Found {embeddedFileCount} embedded files.\");\n            for (int i = 0; i < embeddedFileCount; i++)\n                manifest.FileEntries.Add(GetNextEntry());\n\n            return manifest;\n        }\n", "            for (int i = 0; i < embeddedFileCount; i++)\n                manifest.FileEntries.Add(GetNextEntry());\n\n            return manifest;\n        }\n\n        private AppHostFileEntry GetNextEntry()\n        {\n            AppHostFileEntry entry = new AppHostFileEntry();\n            byte[] entryBuffer = new byte[FILE_ENTRY_SIZE];\n            FileStream.Read(entryBuffer, 0, entryBuffer.Length);\n            entry.Raw = entryBuffer;\n\n            entry.Offset = BitConverter.ToInt64(entry.Raw, 0);\n\n            //hopefully nobody embeds a file larger than 2GB :D\n            entry.Size = (int)BitConverter.ToInt64(entry.Raw, 0x8);\n\n            byte[] stringBuffer = new byte[entry.Raw[0x19]];\n            FileStream.Read(stringBuffer, 0, stringBuffer.Length);\n            entry.Name = Encoding.UTF8.GetString(stringBuffer);\n\n            return entry;\n        }\n\n", "        public override void Close()\n        {\n            FileStream.Close();\n        }\n\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract-v2/Models/ApphostFile6.cs", "chunked_list": ["\ufeffusing apphost_extract_v2.General;\nusing System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Reflection.PortableExecutable;\nusing System.Text;\nusing static apphost_extract_v2.Util;\n\nnamespace apphost_extract_v2.Models\n{\n    public class ApphostFile6 : IApphostFile\n    {", "namespace apphost_extract_v2.Models\n{\n    public class ApphostFile6 : IApphostFile\n    {\n        private readonly byte[] HEADER_OFFSET_SIG = { 0xE8, 0x0, 0x0, 0x0, 0x0, 0x48, 0x8B, 0x05, 0x0, 0x0, 0x0, 0x0, 0x48, 0x85, 0xC0 };\n        private const string HEADER_OFFSET_MASK = \"x????xxx????xxx\";\n\n        private const int HEADER_SIZE = 0xD;\n        private const int FILE_ENTRY_SIZE = 0x1A;\n\n        public ApphostFile6(FileStream fs, PEHeaders peheader) : base(fs, peheader)\n        {\n            Header = new AppHostFileHeader();\n            var headerAddress = FindHeaderOffset();\n", "        private const int FILE_ENTRY_SIZE = 0x1A;\n\n        public ApphostFile6(FileStream fs, PEHeaders peheader) : base(fs, peheader)\n        {\n            Header = new AppHostFileHeader();\n            var headerAddress = FindHeaderOffset();\n\n            if(headerAddress == 0)\n                Log.Fatal(\"Unable to located bundle header :/\");\n\n            var headerBuffer = fs.ReadBuffer(headerAddress, HEADER_SIZE);\n\n            Header.Raw = headerBuffer;\n            Header.Path = Encoding.UTF8.GetString(\n                                fs.ReadBuffer(headerAddress + HEADER_SIZE, 0xC));\n\n            Header.Manifest = ParseManifest();\n\n        }\n\n        public ApphostFile6(FileStream fs, PEHeaders peheader, uint headerOffset) : base(fs, peheader)\n        {\n            Header = new AppHostFileHeader();\n            var headerAddress = headerOffset;\n", "            if (headerAddress == 0)\n                Log.Fatal(\"Unable to located bundle header :/\");\n\n            var headerBuffer = fs.ReadBuffer(headerAddress, HEADER_SIZE);\n\n            Header.Raw = headerBuffer;\n            Header.Path = Encoding.UTF8.GetString(\n                                fs.ReadBuffer(headerAddress + HEADER_SIZE, 0xC));\n\n            Header.Manifest = ParseManifest();\n\n        }\n", "        private uint FindHeaderOffset()\n        {\n            var textSegment = PEHeader.GetSegment(\".text\");\n            Log.Info(\"Scanning for the .NET 6 Bundle header...\");\n            var sw = Stopwatch.StartNew();\n\n            var sigscanResults = PatternScan(FileStream,\n                                    textSegment.PointerToRawData, textSegment.SizeOfRawData,\n                                        HEADER_OFFSET_SIG, HEADER_OFFSET_MASK);\n\n            sw.Stop();\n", "            if (sigscanResults.Length == 0) return 0;\n\n            var headerOffset = (int)BitConverter.ToUInt32(\n                                    FileStream.ReadBuffer(sigscanResults[0] + 8, 4));\n\n            var headerPtr = PEHeader.AddVirtualOffset(sigscanResults[0] + 12, headerOffset);\n            var headerAddress = BitConverter.ToUInt32(FileStream.ReadBuffer(headerPtr, 4));\n\n            Log.Info($\"Found bundle header offset at 0x{headerPtr:X8} in {sw.ElapsedMilliseconds}ms -> {headerAddress:X8}\");\n            return headerAddress;\n        }\n", "        private AppHostManifest ParseManifest()\n        {\n            //Seek over random bullshit that got added in .NET 5\n            FileStream.Seek(0x3C, SeekOrigin.Current);\n\n            AppHostManifest manifest = new AppHostManifest();\n            var embeddedFileCount = BitConverter.ToInt32(Header.Raw, 0x8);\n            Log.Info($\"Found {embeddedFileCount} embedded files.\");\n            for (int i = 0; i < embeddedFileCount; i++)\n                manifest.FileEntries.Add(GetNextEntry());\n\n            return manifest;\n        }\n", "            for (int i = 0; i < embeddedFileCount; i++)\n                manifest.FileEntries.Add(GetNextEntry());\n\n            return manifest;\n        }\n\n        private AppHostFileEntry GetNextEntry()\n        {\n            AppHostFileEntry entry = new AppHostFileEntry();\n            byte[] entryBuffer = new byte[FILE_ENTRY_SIZE];\n            FileStream.Read(entryBuffer, 0, entryBuffer.Length);\n            entry.Raw = entryBuffer;\n\n            entry.Offset = BitConverter.ToInt64(entry.Raw, 0);\n\n            //hopefully nobody embeds a file larger than 2GB :D\n            entry.Size = (int)BitConverter.ToInt64(entry.Raw, 0x8);\n\n            byte[] stringBuffer = new byte[entry.Raw[0x19]];\n            FileStream.Read(stringBuffer, 0, stringBuffer.Length);\n            entry.Name = Encoding.UTF8.GetString(stringBuffer);\n\n            return entry;\n        }\n\n", "        public override void Close()\n        {\n            FileStream.Close();\n        }\n\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract-v2/Models/ApphostFile31.cs", "chunked_list": ["\ufeffusing apphost_extract_v2.General;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Reflection.PortableExecutable;\nusing System.Text;\n\nnamespace apphost_extract_v2.Models\n{\n    public class ApphostFile31 : IApphostFile\n    {", "{\n    public class ApphostFile31 : IApphostFile\n    {\n        private const int HEADER_OFFSET_PTR = 0x27600;\n        private const int HEADER_SIZE = 0xD;\n        private const int FILE_ENTRY_SIZE = 0x12;\n\n        public ApphostFile31(FileStream fs, PEHeaders peheader) : base(fs, peheader)\n        {\n            Header = new AppHostFileHeader();\n            var headerAddress = BitConverter.ToInt32(fs.ReadBuffer(HEADER_OFFSET_PTR, 4));\n", "            if (headerAddress == 0)\n                Log.Fatal(\"The address of the Bundle header is 0 :/\");\n\n            var headerBuffer = fs.ReadBuffer(headerAddress, HEADER_SIZE);\n            Log.Info($\"Reading header at 0x{HEADER_OFFSET_PTR:X8}...\");\n            Header.Raw = headerBuffer;\n            Header.Path = Encoding.UTF8.GetString(fs.ReadBuffer(headerAddress + HEADER_SIZE, 0xC));\n            \n            Header.Manifest = ParseManifest();\n        }\n\n        public ApphostFile31(FileStream fs, PEHeaders peheader, uint headerOffset) : base(fs, peheader)\n        {\n            Header = new AppHostFileHeader();\n            var headerAddress = headerOffset;\n", "            if (headerAddress == 0)\n                Log.Fatal(\"The address of the Bundle header is 0 :/\");\n\n            var headerBuffer = fs.ReadBuffer(headerAddress, HEADER_SIZE);\n            Log.Info($\"Reading header at 0x{HEADER_OFFSET_PTR:X8}...\");\n            Header.Raw = headerBuffer;\n            Header.Path = Encoding.UTF8.GetString(fs.ReadBuffer(headerAddress + HEADER_SIZE, 0xC));\n\n            Header.Manifest = ParseManifest();\n        }\n", "        private AppHostManifest ParseManifest()\n        {\n            AppHostManifest manifest = new AppHostManifest();\n            var embeddedFileCount = BitConverter.ToInt32(Header.Raw, 0x8);\n            Log.Info($\"Found {embeddedFileCount} embedded files.\");\n            for (int i = 0; i< embeddedFileCount; i++)\n            {\n                manifest.FileEntries.Add(GetNextEntry());\n            }\n\n            return manifest;\n        }\n", "        private AppHostFileEntry GetNextEntry()\n        {\n            AppHostFileEntry entry = new AppHostFileEntry();\n            byte[] entryBuffer = new byte[FILE_ENTRY_SIZE];\n            FileStream.Read(entryBuffer, 0, entryBuffer.Length);\n            entry.Raw = entryBuffer;\n\n            entry.Offset = BitConverter.ToInt64(entry.Raw, 0);\n\n            //hopefully nobody embeds a file larger than 2GB :D\n            entry.Size = (int)BitConverter.ToInt64(entry.Raw, 0x8);\n\n            byte[] stringBuffer = new byte[entry.Raw[0x11]];\n            FileStream.Read(stringBuffer, 0, stringBuffer.Length);\n            entry.Name = Encoding.UTF8.GetString(stringBuffer);\n\n            return entry;\n        }\n\n\n", "        public override void Close()\n        {\n            FileStream.Close();\n        }\n\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract-v2/Models/ApphostFile30.cs", "chunked_list": ["\ufeffusing apphost_extract_v2.General;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Reflection.PortableExecutable;\nusing System.Text;\n\nnamespace apphost_extract_v2.Models\n{\n    public class ApphostFile30 : IApphostFile\n    {", "{\n    public class ApphostFile30 : IApphostFile\n    {\n        private const int HEADER_OFFSET_PTR = 0x23E00;\n        private const int HEADER_SIZE = 0xD;\n        private const int FILE_ENTRY_SIZE = 0x12;\n\n        public ApphostFile30(FileStream fs, PEHeaders peheader) : base(fs, peheader)\n        {\n            Header = new AppHostFileHeader();\n            Log.Info($\"Reading header at 0x{HEADER_OFFSET_PTR:X8}...\");\n            var headerAddress = BitConverter.ToInt32(fs.ReadBuffer(HEADER_OFFSET_PTR, 4));\n            ", "            if(headerAddress == 0)\n                Log.Fatal(\"The address of the Bundle header is 0 :/\");\n\n            var headerBuffer = fs.ReadBuffer(headerAddress, HEADER_SIZE);\n\n            Header.Raw = headerBuffer;\n            Header.Path = Encoding.UTF8.GetString(fs.ReadBuffer(headerAddress + HEADER_SIZE, 0xC));\n\n            Header.Manifest = ParseManifest();\n        }\n\n        public ApphostFile30(FileStream fs, PEHeaders peheader, uint headerOffset) : base(fs, peheader)\n        {\n            Header = new AppHostFileHeader();\n            Log.Info($\"Reading header at 0x{HEADER_OFFSET_PTR:X8}...\");\n            var headerAddress = headerOffset;\n", "            if (headerAddress == 0)\n                Log.Fatal(\"The address of the Bundle header is 0 :/\");\n\n            var headerBuffer = fs.ReadBuffer(headerAddress, HEADER_SIZE);\n\n            Header.Raw = headerBuffer;\n            Header.Path = Encoding.UTF8.GetString(fs.ReadBuffer(headerAddress + HEADER_SIZE, 0xC));\n\n            Header.Manifest = ParseManifest();\n        }\n", "        private AppHostManifest ParseManifest()\n        {\n            AppHostManifest manifest = new AppHostManifest();\n            var embeddedFileCount = BitConverter.ToInt32(Header.Raw, 0x8);\n            Log.Info($\"Found {embeddedFileCount} embedded files.\");\n\n            for (int i = 0; i < embeddedFileCount; i++)\n            {\n                manifest.FileEntries.Add(GetNextEntry());\n            }\n\n            return manifest;\n        }\n", "        private AppHostFileEntry GetNextEntry()\n        {\n            AppHostFileEntry entry = new AppHostFileEntry();\n            byte[] entryBuffer = new byte[FILE_ENTRY_SIZE];\n            FileStream.Read(entryBuffer, 0, entryBuffer.Length);\n            entry.Raw = entryBuffer;\n\n            entry.Offset = BitConverter.ToInt64(entry.Raw, 0);\n\n            //hopefully nobody embeds a file larger than 2GB :D\n            entry.Size = (int)BitConverter.ToInt64(entry.Raw, 0x8);\n\n            byte[] stringBuffer = new byte[entry.Raw[0x11]];\n            FileStream.Read(stringBuffer, 0, stringBuffer.Length);\n            entry.Name = Encoding.UTF8.GetString(stringBuffer);\n\n            return entry;\n        }\n\n\n", "        public override void Close()\n        {\n            FileStream.Close();\n        }\n\n\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract-v2/Models/ApphostFile5.cs", "chunked_list": ["\ufeffusing apphost_extract_v2.General;\nusing System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Reflection.PortableExecutable;\nusing System.Text;\nusing static apphost_extract_v2.Util;\n\nnamespace apphost_extract_v2.Models\n{\n    public class ApphostFile5 : IApphostFile\n    {", "namespace apphost_extract_v2.Models\n{\n    public class ApphostFile5 : IApphostFile\n    {\n        private readonly byte[] HEADER_OFFSET_SIG = { 0xE8, 0x0, 0x0, 0x0, 0x0, 0x48, 0x8B, 0x05, 0x0, 0x0, 0x0, 0x0, 0x48, 0x85, 0xC0 };\n        private const string HEADER_OFFSET_MASK = \"x????xxx????xxx\";\n\n        private const int HEADER_SIZE = 0xD;\n        private const int FILE_ENTRY_SIZE = 0x12;\n\n        public ApphostFile5(FileStream fs, PEHeaders peheader) : base(fs, peheader)\n        {\n            Header = new AppHostFileHeader();\n            var headerAddress = FindHeaderOffset();\n", "        private const int FILE_ENTRY_SIZE = 0x12;\n\n        public ApphostFile5(FileStream fs, PEHeaders peheader) : base(fs, peheader)\n        {\n            Header = new AppHostFileHeader();\n            var headerAddress = FindHeaderOffset();\n\n            if(headerAddress == 0)\n                Log.Fatal(\"Unable to located bundle header :/\");\n\n            var headerBuffer = fs.ReadBuffer(headerAddress, HEADER_SIZE);\n\n            Header.Raw = headerBuffer;\n            Header.Path = Encoding.UTF8.GetString(\n                                fs.ReadBuffer(headerAddress + HEADER_SIZE, 0xC));\n\n            Header.Manifest = ParseManifest();\n\n        }\n\n        public ApphostFile5(FileStream fs, PEHeaders peheader, uint headerOffset) : base(fs, peheader)\n        {\n            Header = new AppHostFileHeader();\n            var headerAddress = headerOffset;\n", "            if (headerAddress == 0)\n                Log.Fatal(\"Unable to located bundle header :/\");\n\n            var headerBuffer = fs.ReadBuffer(headerAddress, HEADER_SIZE);\n\n            Header.Raw = headerBuffer;\n            Header.Path = Encoding.UTF8.GetString(\n                                fs.ReadBuffer(headerAddress + HEADER_SIZE, 0xC));\n\n            Header.Manifest = ParseManifest();\n\n        }\n", "        private uint FindHeaderOffset()\n        {\n            var textSegment = PEHeader.GetSegment(\".text\");\n            Log.Info(\"Scanning for the .NET 5 Bundle header...\");\n            var sw = Stopwatch.StartNew();\n\n            var sigscanResults = PatternScan(FileStream,\n                                    textSegment.PointerToRawData, textSegment.SizeOfRawData,\n                                        HEADER_OFFSET_SIG, HEADER_OFFSET_MASK);\n\n            sw.Stop();\n", "            if (sigscanResults.Length == 0) return 0;\n\n            var headerOffset = (int)BitConverter.ToUInt32(\n                                    FileStream.ReadBuffer(sigscanResults[0] + 8, 4));\n\n            var headerPtr = PEHeader.AddVirtualOffset(sigscanResults[0] + 12, headerOffset);\n            var headerAddress = BitConverter.ToUInt32(FileStream.ReadBuffer(headerPtr, 4));\n\n            Log.Info($\"Found bundle header offset at 0x{headerPtr:X8} in {sw.ElapsedMilliseconds}ms -> {headerAddress:X8}\");\n            return headerAddress;\n        }\n", "        private AppHostManifest ParseManifest()\n        {\n            //Seek over random bullshit that got added in .NET 5\n            FileStream.Seek(0x28, SeekOrigin.Current);\n\n            AppHostManifest manifest = new AppHostManifest();\n            var embeddedFileCount = BitConverter.ToInt32(Header.Raw, 0x8);\n            Log.Info($\"Found {embeddedFileCount} embedded files.\");\n            for (int i = 0; i < embeddedFileCount; i++)\n                manifest.FileEntries.Add(GetNextEntry());\n\n            return manifest;\n        }\n", "            for (int i = 0; i < embeddedFileCount; i++)\n                manifest.FileEntries.Add(GetNextEntry());\n\n            return manifest;\n        }\n\n        private AppHostFileEntry GetNextEntry()\n        {\n            AppHostFileEntry entry = new AppHostFileEntry();\n            byte[] entryBuffer = new byte[FILE_ENTRY_SIZE];\n            FileStream.Read(entryBuffer, 0, entryBuffer.Length);\n            entry.Raw = entryBuffer;\n\n            entry.Offset = BitConverter.ToInt64(entry.Raw, 0);\n\n            //hopefully nobody embeds a file larger than 2GB :D\n            entry.Size = (int)BitConverter.ToInt64(entry.Raw, 0x8);\n\n            byte[] stringBuffer = new byte[entry.Raw[0x11]];\n            FileStream.Read(stringBuffer, 0, stringBuffer.Length);\n            entry.Name = Encoding.UTF8.GetString(stringBuffer);\n\n            return entry;\n        }\n\n", "        public override void Close()\n        {\n            FileStream.Close();\n        }\n\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract-v2/Models/General/IApphostFile.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Reflection.PortableExecutable;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace apphost_extract_v2.General\n{\n    public abstract class IApphostFile\n    {\n        internal FileStream FileStream;", "{\n    public abstract class IApphostFile\n    {\n        internal FileStream FileStream;\n        public PEHeaders PEHeader;\n        public AppHostFileHeader Header;\n\n        public IApphostFile(FileStream fs, PEHeaders peheader)\n        {\n            FileStream = fs;\n            PEHeader = peheader;\n        }\n", "        public void ExtractAll(string outputDir)\n        {\n            Directory.CreateDirectory(outputDir);\n          \n            //foreach(var fileEntry in Header.Manifest.FileEntries)\n            Parallel.ForEach(Header.Manifest.FileEntries, fileEntry =>\n            {\n                try\n                {\n                    var bytes = FileStream.ReadBuffer(fileEntry.Offset, fileEntry.Size);\n                    var name = Path.GetFileName(fileEntry.Name);\n                    var path = Path.GetDirectoryName(fileEntry.Name);", "                    if (path.Length > 0)\n                    {\n                        Directory.CreateDirectory(Path.Combine(outputDir, path));\n                    }\n\n                    if (FileChecker.IsKnownFile(bytes))\n                    {\n                        Log.Info($\"Extracting {name} --> Known file\", ConsoleColor.Green);\n                    }\n                    else\n                    {\n                        Log.Info($\"Extracting {name} --> Unknown file\", ConsoleColor.Yellow);\n                        name = name.Insert(0, \"_\");\n                    }\n\n                    var filePath = Path.Combine(outputDir, path, name);\n                    File.WriteAllBytes(filePath, bytes);\n                }", "                catch (Exception ex)\n                {\n                    Log.Error($\"Could not extract {fileEntry.Name}: {ex.Message}\");\n                }\n            });\n            Console.WriteLine();\n        }\n\n        public abstract void Close();\n    }\n}\n", "        public abstract void Close();\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract-v2/Models/General/AppHostFileHeader.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace apphost_extract_v2.General\n{\n    public class AppHostFileHeader\n    {\n        public byte[] Raw;\n", "{\n    public class AppHostFileHeader\n    {\n        public byte[] Raw;\n\n        public string Path { get; set; }\n        \n        public AppHostManifest Manifest { get; set; }\n\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract-v2/Models/General/AppHostManifest.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace apphost_extract_v2.General\n{\n    public class AppHostManifest\n    {\n        public List<AppHostFileEntry> FileEntries { get; set; }\n\n        public AppHostManifest()\n        {\n            FileEntries = new List<AppHostFileEntry>();\n        }\n    }\n}\n", "{\n    public class AppHostManifest\n    {\n        public List<AppHostFileEntry> FileEntries { get; set; }\n\n        public AppHostManifest()\n        {\n            FileEntries = new List<AppHostFileEntry>();\n        }\n    }\n}\n"]}
{"filename": "src/apphost-extract/apphost-extract-v2/Models/General/AppHostFileEntry.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace apphost_extract_v2.General\n{\n    public class AppHostFileEntry\n    {", "{\n    public class AppHostFileEntry\n    {\n        public long Offset { get; set; }\n        public int Size { get; set; }\n        public string Name { get; set; }\n\n        public byte[] Raw;\n    }\n}\n"]}
