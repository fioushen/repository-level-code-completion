{"filename": "DragonFruit.Kaplan/App.axaml.cs", "chunked_list": ["// Kaplan Copyright (c) DragonFruit Network <inbox@dragonfruit.network>\n// Licensed under Apache-2. Refer to the LICENSE file for more info\n\nusing Avalonia;\nusing Avalonia.Controls.ApplicationLifetimes;\nusing Avalonia.Markup.Xaml;\nusing DragonFruit.Kaplan.Views;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Logging.EventLog;\n", "using Microsoft.Extensions.Logging.EventLog;\n\nnamespace DragonFruit.Kaplan\n{\n    public partial class App : Application\n    {\n        public static App Instance => (App)Current;\n\n        private ILoggerFactory Logger { get; set; }\n\n        public bool BugReportingEnabled { get; set; } = true;\n", "        private ILoggerFactory Logger { get; set; }\n\n        public bool BugReportingEnabled { get; set; } = true;\n\n        public static ILogger GetLogger<T>()\n        {\n            return Instance.Logger.CreateLogger<T>();\n        }\n\n        public override void Initialize()\n        {\n            Logger = LoggerFactory.Create(o =>\n            {\n                o.ClearProviders();\n\n                o.AddEventLog(new EventLogSettings\n                {\n                    SourceName = Program.AppTitle,\n                    Filter = (_, level) => level is LogLevel.Warning or LogLevel.Error or LogLevel.Critical\n                });\n\n                o.AddSentry(s =>\n                {\n                    s.Release = Program.Version;\n                    s.Dsn = \"https://7818b48e8de14c9f8b1e32df36e7417b@o97031.ingest.sentry.io/4505465657294848\";\n\n                    s.MaxBreadcrumbs = 200;\n                    s.MinimumEventLevel = LogLevel.Warning;\n\n                    s.SetBeforeSend(e => BugReportingEnabled ? e : null);\n                });\n            });\n\n            AvaloniaXamlLoader.Load(this);\n        }\n", "        public override void Initialize()\n        {\n            Logger = LoggerFactory.Create(o =>\n            {\n                o.ClearProviders();\n\n                o.AddEventLog(new EventLogSettings\n                {\n                    SourceName = Program.AppTitle,\n                    Filter = (_, level) => level is LogLevel.Warning or LogLevel.Error or LogLevel.Critical\n                });\n\n                o.AddSentry(s =>\n                {\n                    s.Release = Program.Version;\n                    s.Dsn = \"https://7818b48e8de14c9f8b1e32df36e7417b@o97031.ingest.sentry.io/4505465657294848\";\n\n                    s.MaxBreadcrumbs = 200;\n                    s.MinimumEventLevel = LogLevel.Warning;\n\n                    s.SetBeforeSend(e => BugReportingEnabled ? e : null);\n                });\n            });\n\n            AvaloniaXamlLoader.Load(this);\n        }\n", "        public override void OnFrameworkInitializationCompleted()\n        {\n            if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)\n            {\n                desktop.MainWindow = new Welcome();\n            }\n\n            base.OnFrameworkInitializationCompleted();\n        }\n    }\n}"]}
{"filename": "DragonFruit.Kaplan/Program.cs", "chunked_list": ["\ufeff// Kaplan Copyright (c) DragonFruit Network <inbox@dragonfruit.network>\n// Licensed under Apache-2. Refer to the LICENSE file for more info\n\nusing System;\nusing Avalonia;\nusing Avalonia.Controls;\nusing Avalonia.ReactiveUI;\n\nnamespace DragonFruit.Kaplan\n{\n    internal class Program\n    {\n        internal static Version MinWindowsVersion = new(\"10.0.19041\");\n", "namespace DragonFruit.Kaplan\n{\n    internal class Program\n    {\n        internal static Version MinWindowsVersion = new(\"10.0.19041\");\n\n        public static string Version { get; } = typeof(Program).Assembly.GetName().Version!.ToString(3);\n        public static string AppTitle { get; } = $\"DragonFruit Kaplan v{Version}\";\n\n        internal static WindowTransparencyLevel[] TransparencyLevels =\n        {\n            WindowTransparencyLevel.Mica,\n            WindowTransparencyLevel.AcrylicBlur,\n            WindowTransparencyLevel.None\n        };\n\n        // Initialization code. Don't use any Avalonia, third-party APIs or any\n        // SynchronizationContext-reliant code before AppMain is called: things aren't initialized\n        // yet and stuff might break.\n        [STAThread]", "        public static void Main(string[] args) => BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);\n\n        // Avalonia configuration, don't remove; also used by visual designer.\n        private static AppBuilder BuildAvaloniaApp() =>\n            AppBuilder.Configure<App>()\n                .UsePlatformDetect()\n                .LogToTrace()\n                .UseReactiveUI();\n    }\n}"]}
{"filename": "DragonFruit.Kaplan/ViewModels/MainWindowViewModel.cs", "chunked_list": ["\ufeff// Kaplan Copyright (c) DragonFruit Network <inbox@dragonfruit.network>\n// Licensed under Apache-2. Refer to the LICENSE file for more info\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.Linq;\nusing System.Reactive.Linq;\nusing System.Security.Principal;\nusing System.Threading.Tasks;", "using System.Security.Principal;\nusing System.Threading.Tasks;\nusing System.Windows.Input;\nusing Windows.ApplicationModel;\nusing Windows.Management.Deployment;\nusing Avalonia.Threading;\nusing DragonFruit.Kaplan.ViewModels.Enums;\nusing DragonFruit.Kaplan.ViewModels.Messages;\nusing DynamicData;\nusing DynamicData.Binding;", "using DynamicData;\nusing DynamicData.Binding;\nusing Microsoft.Extensions.Logging;\nusing ReactiveUI;\n\nnamespace DragonFruit.Kaplan.ViewModels\n{\n    public class MainWindowViewModel : ReactiveObject, IDisposable\n    {\n        private readonly ILogger _logger;\n        private readonly WindowsIdentity _currentUser;", "        private readonly ILogger _logger;\n        private readonly WindowsIdentity _currentUser;\n        private readonly PackageManager _packageManager;\n        private readonly IDisposable _packageRefreshListener;\n\n        private readonly ObservableAsPropertyHelper<IEnumerable<PackageViewModel>> _displayedPackages;\n\n        private string _searchQuery = string.Empty;\n        private PackageInstallationMode _packageMode = PackageInstallationMode.User;\n        private IReadOnlyCollection<PackageViewModel> _discoveredPackages = Array.Empty<PackageViewModel>();\n\n        public MainWindowViewModel()\n        {\n            _packageManager = new PackageManager();\n            _currentUser = WindowsIdentity.GetCurrent();\n\n            _logger = App.GetLogger<MainWindowViewModel>();\n\n            AvailablePackageModes = _currentUser.User != null\n                ? Enum.GetValues<PackageInstallationMode>()\n                : new[] {PackageInstallationMode.Machine};\n\n            // create observables\n            var packagesSelected = SelectedPackages.ToObservableChangeSet()\n                .ToCollection()\n                .ObserveOn(RxApp.MainThreadScheduler)\n                .Select(x => x.Any());\n\n            _packageRefreshListener = MessageBus.Current.Listen<UninstallEventArgs>().ObserveOn(RxApp.TaskpoolScheduler).Subscribe(x => RefreshPackagesImpl());\n            _displayedPackages = this.WhenAnyValue(x => x.DiscoveredPackages, x => x.SearchQuery, x => x.SelectedPackages)\n                .ObserveOn(RxApp.TaskpoolScheduler)\n                .Select(q =>\n                {\n                    // because filters remove selected entries, the search will split the listing into two groups, with the matches showing above\n                    var matches = q.Item1.ToLookup(x => x.IsSearchMatch(q.Item2));\n                    return matches[true].Concat(matches[false]);\n                })\n                .ToProperty(this, x => x.DisplayedPackages);\n\n            // create commands\n            RefreshPackages = ReactiveCommand.CreateFromTask(RefreshPackagesImpl);\n            RemovePackages = ReactiveCommand.Create(RemovePackagesImpl, packagesSelected);\n            ClearSelection = ReactiveCommand.Create(() => SelectedPackages.Clear(), packagesSelected);\n            ShowAbout = ReactiveCommand.Create(() => MessageBus.Current.SendMessage(new ShowAboutWindowEventArgs()));\n\n            // auto refresh the package list if the user package filter switch is changed\n            this.WhenValueChanged(x => x.PackageMode).ObserveOn(RxApp.TaskpoolScheduler).Subscribe(_ => RefreshPackages.Execute(null));\n        }\n\n        public IEnumerable<PackageInstallationMode> AvailablePackageModes { get; }\n\n        public ObservableCollection<PackageViewModel> SelectedPackages { get; } = new();\n\n        public IEnumerable<PackageViewModel> DisplayedPackages => _displayedPackages.Value;\n\n        private IReadOnlyCollection<PackageViewModel> DiscoveredPackages\n        {\n            get => _discoveredPackages;\n            set => this.RaiseAndSetIfChanged(ref _discoveredPackages, value);\n        }\n\n        /// <summary>\n        /// Gets or sets whether the <see cref=\"DiscoveredPackages\"/> collection should show packages installed for the selected user\n        /// </summary>", "        private PackageInstallationMode _packageMode = PackageInstallationMode.User;\n        private IReadOnlyCollection<PackageViewModel> _discoveredPackages = Array.Empty<PackageViewModel>();\n\n        public MainWindowViewModel()\n        {\n            _packageManager = new PackageManager();\n            _currentUser = WindowsIdentity.GetCurrent();\n\n            _logger = App.GetLogger<MainWindowViewModel>();\n\n            AvailablePackageModes = _currentUser.User != null\n                ? Enum.GetValues<PackageInstallationMode>()\n                : new[] {PackageInstallationMode.Machine};\n\n            // create observables\n            var packagesSelected = SelectedPackages.ToObservableChangeSet()\n                .ToCollection()\n                .ObserveOn(RxApp.MainThreadScheduler)\n                .Select(x => x.Any());\n\n            _packageRefreshListener = MessageBus.Current.Listen<UninstallEventArgs>().ObserveOn(RxApp.TaskpoolScheduler).Subscribe(x => RefreshPackagesImpl());\n            _displayedPackages = this.WhenAnyValue(x => x.DiscoveredPackages, x => x.SearchQuery, x => x.SelectedPackages)\n                .ObserveOn(RxApp.TaskpoolScheduler)\n                .Select(q =>\n                {\n                    // because filters remove selected entries, the search will split the listing into two groups, with the matches showing above\n                    var matches = q.Item1.ToLookup(x => x.IsSearchMatch(q.Item2));\n                    return matches[true].Concat(matches[false]);\n                })\n                .ToProperty(this, x => x.DisplayedPackages);\n\n            // create commands\n            RefreshPackages = ReactiveCommand.CreateFromTask(RefreshPackagesImpl);\n            RemovePackages = ReactiveCommand.Create(RemovePackagesImpl, packagesSelected);\n            ClearSelection = ReactiveCommand.Create(() => SelectedPackages.Clear(), packagesSelected);\n            ShowAbout = ReactiveCommand.Create(() => MessageBus.Current.SendMessage(new ShowAboutWindowEventArgs()));\n\n            // auto refresh the package list if the user package filter switch is changed\n            this.WhenValueChanged(x => x.PackageMode).ObserveOn(RxApp.TaskpoolScheduler).Subscribe(_ => RefreshPackages.Execute(null));\n        }\n\n        public IEnumerable<PackageInstallationMode> AvailablePackageModes { get; }\n\n        public ObservableCollection<PackageViewModel> SelectedPackages { get; } = new();\n\n        public IEnumerable<PackageViewModel> DisplayedPackages => _displayedPackages.Value;\n\n        private IReadOnlyCollection<PackageViewModel> DiscoveredPackages\n        {\n            get => _discoveredPackages;\n            set => this.RaiseAndSetIfChanged(ref _discoveredPackages, value);\n        }\n\n        /// <summary>\n        /// Gets or sets whether the <see cref=\"DiscoveredPackages\"/> collection should show packages installed for the selected user\n        /// </summary>", "        public PackageInstallationMode PackageMode\n        {\n            get => _packageMode;\n            set => this.RaiseAndSetIfChanged(ref _packageMode, value);\n        }\n\n        /// <summary>\n        /// Gets or sets the search query used to filter <see cref=\"DisplayedPackages\"/>\n        /// </summary>\n        public string SearchQuery\n        {\n            get => _searchQuery;\n            set => this.RaiseAndSetIfChanged(ref _searchQuery, value);\n        }\n", "        public string SearchQuery\n        {\n            get => _searchQuery;\n            set => this.RaiseAndSetIfChanged(ref _searchQuery, value);\n        }\n\n        public ICommand ShowAbout { get; }\n        public ICommand ClearSelection { get; }\n        public ICommand RemovePackages { get; }\n        public ICommand RefreshPackages { get; }\n", "        public ICommand RemovePackages { get; }\n        public ICommand RefreshPackages { get; }\n\n        private async Task RefreshPackagesImpl()\n        {\n            IEnumerable<Package> packages;\n\n            switch (PackageMode)\n            {\n                case PackageInstallationMode.User when _currentUser.User != null:\n                    _logger.LogInformation(\"Loading Packages for user {userId}\", _currentUser.User.Value);\n                    packages = _packageManager.FindPackagesForUser(_currentUser.User.Value);\n                    break;\n\n                case PackageInstallationMode.Machine:\n                    _logger.LogInformation(\"Loading machine-wide packages\");\n                    packages = _packageManager.FindPackages();\n                    break;\n\n                default:\n                    throw new ArgumentOutOfRangeException();\n            }\n\n            var filteredPackageModels = packages.Where(x => x.SignatureKind != PackageSignatureKind.System)\n                .Select(x => new PackageViewModel(x))\n                .ToList();\n\n            _logger.LogDebug(\"Discovered {x} packages\", filteredPackageModels.Count);\n\n            // ensure the ui doesn't have non-existent packages nominated through an intersection\n            // ToList needed due to deferred nature of iterators used.\n            var reselectedPackages = filteredPackageModels.IntersectBy(SelectedPackages.Select(x => x.Package.Id.FullName), x => x.Package.Id.FullName).ToList();\n\n            await Dispatcher.UIThread.InvokeAsync(() =>\n            {\n                SelectedPackages.Clear();\n\n                SearchQuery = string.Empty;\n                DiscoveredPackages = filteredPackageModels;\n                SelectedPackages.AddRange(reselectedPackages);\n            });\n        }\n", "        private void RemovePackagesImpl()\n        {\n            var packages = SelectedPackages.Select(x => x.Package).ToList();\n            var args = new UninstallEventArgs(packages, PackageMode);\n\n            _logger.LogInformation(\"Starting removal of {x} packages\", packages.Count);\n\n            MessageBus.Current.SendMessage(args);\n        }\n\n        public void Dispose()\n        {\n            _displayedPackages?.Dispose();\n            _packageRefreshListener?.Dispose();\n        }\n    }\n}", "        public void Dispose()\n        {\n            _displayedPackages?.Dispose();\n            _packageRefreshListener?.Dispose();\n        }\n    }\n}"]}
{"filename": "DragonFruit.Kaplan/ViewModels/PackageViewModel.cs", "chunked_list": ["\ufeff// Kaplan Copyright (c) DragonFruit Network <inbox@dragonfruit.network>\n// Licensed under Apache-2. Refer to the LICENSE file for more info\n\nusing System;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Threading.Tasks;\nusing Windows.ApplicationModel;\nusing Windows.Foundation;\nusing Avalonia.Media;", "using Windows.Foundation;\nusing Avalonia.Media;\nusing Avalonia.Media.Imaging;\nusing Microsoft.Extensions.Logging;\nusing ReactiveUI;\n\nnamespace DragonFruit.Kaplan.ViewModels\n{\n    /// <summary>\n    /// A wrapper for a <see cref=\"Package\"/>, exposing the Logo as a usable property to the UI.", "    /// <summary>\n    /// A wrapper for a <see cref=\"Package\"/>, exposing the Logo as a usable property to the UI.\n    /// </summary>\n    public class PackageViewModel : ReactiveObject\n    {\n        private IImage _logo;\n        private Task _logoLoadTask;\n\n        public PackageViewModel(Package package)\n        {\n            Package = package;\n        }\n", "        public Package Package { get; }\n\n        public IImage Logo\n        {\n            get\n            {\n                // defer image loading until someone requests it.\n                _logoLoadTask ??= LoadIconStream();\n\n                return _logo;\n            }\n            private set => this.RaiseAndSetIfChanged(ref _logo, value);\n        }\n", "        public string Id => Package.Id.Name;\n        public string Name => Package.DisplayName;\n        public string Publisher => Package.PublisherDisplayName;\n\n        public bool IsSearchMatch(string query)\n        {\n            return Id.Contains(query, StringComparison.OrdinalIgnoreCase) ||\n                   Name.Contains(query, StringComparison.OrdinalIgnoreCase) ||\n                   Publisher.Contains(query, StringComparison.OrdinalIgnoreCase);\n        }\n", "        private async Task LoadIconStream()\n        {\n            try\n            {\n                var loader = Package.GetLogoAsRandomAccessStreamReference(new Size(64, 64));\n                using var proxy = await loader.OpenReadAsync();\n\n                Logo = new Bitmap(proxy.AsStreamForRead());\n            }\n            catch (COMException comEx) when ((uint)comEx.ErrorCode == 0x80070490)\n            {\n                // Element not found COM error - do nothing\n                App.GetLogger<PackageViewModel>().LogDebug(\"Loading package icon for {appId} failed: {msg}\", Id, comEx.Message);\n            }\n        }\n", "            catch (COMException comEx) when ((uint)comEx.ErrorCode == 0x80070490)\n            {\n                // Element not found COM error - do nothing\n                App.GetLogger<PackageViewModel>().LogDebug(\"Loading package icon for {appId} failed: {msg}\", Id, comEx.Message);\n            }\n        }\n\n        public override int GetHashCode() => Package.GetHashCode();\n    }\n}"]}
{"filename": "DragonFruit.Kaplan/ViewModels/ICanCloseWindow.cs", "chunked_list": ["\ufeff// Kaplan Copyright (c) DragonFruit Network <inbox@dragonfruit.network>\n// Licensed under Apache-2. Refer to the LICENSE file for more info\n\nusing System;\n\nnamespace DragonFruit.Kaplan.ViewModels\n{\n    public interface ICanCloseWindow\n    {\n        event Action CloseRequested;\n    }\n}"]}
{"filename": "DragonFruit.Kaplan/ViewModels/IHandlesClosingEvent.cs", "chunked_list": ["\ufeff// Kaplan Copyright (c) DragonFruit Network <inbox@dragonfruit.network>\n// Licensed under Apache-2. Refer to the LICENSE file for more info\n\nusing System.ComponentModel;\n\nnamespace DragonFruit.Kaplan.ViewModels\n{\n    /// <summary>\n    /// Exposes a method for handling window close requests\n    /// </summary>\n    public interface IHandlesClosingEvent\n    {\n        void OnClose(CancelEventArgs args);\n    }\n}", "    /// Exposes a method for handling window close requests\n    /// </summary>\n    public interface IHandlesClosingEvent\n    {\n        void OnClose(CancelEventArgs args);\n    }\n}"]}
{"filename": "DragonFruit.Kaplan/ViewModels/IExecutesTaskPostLoad.cs", "chunked_list": ["\ufeff// Kaplan Copyright (c) DragonFruit Network <inbox@dragonfruit.network>\n// Licensed under Apache-2. Refer to the LICENSE file for more info\n\nusing System.Threading.Tasks;\n\nnamespace DragonFruit.Kaplan.ViewModels\n{\n    /// <summary>\n    /// Exposes a method to run content after the window has been rendered.\n    /// </summary>\n    public interface IExecutesTaskPostLoad\n    {\n        Task Perform();\n    }\n}", "    /// Exposes a method to run content after the window has been rendered.\n    /// </summary>\n    public interface IExecutesTaskPostLoad\n    {\n        Task Perform();\n    }\n}"]}
{"filename": "DragonFruit.Kaplan/ViewModels/RemovalProgressViewModel.cs", "chunked_list": ["\ufeff// Kaplan Copyright (c) DragonFruit Network <inbox@dragonfruit.network>\n// Licensed under Apache-2. Refer to the LICENSE file for more info\n\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Linq;\nusing System.Reactive.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;", "using System.Threading;\nusing System.Threading.Tasks;\nusing System.Windows.Input;\nusing Windows.ApplicationModel;\nusing Windows.Management.Deployment;\nusing Avalonia.Media;\nusing DragonFruit.Kaplan.ViewModels.Enums;\nusing DragonFruit.Kaplan.ViewModels.Messages;\nusing DynamicData.Binding;\nusing Microsoft.Extensions.Logging;", "using DynamicData.Binding;\nusing Microsoft.Extensions.Logging;\nusing Nito.AsyncEx;\nusing ReactiveUI;\n\nnamespace DragonFruit.Kaplan.ViewModels\n{\n    public class RemovalProgressViewModel : ReactiveObject, IHandlesClosingEvent, IExecutesTaskPostLoad, ICanCloseWindow\n    {\n        private readonly ILogger _logger = App.GetLogger<RemovalProgressViewModel>();\n        private readonly AsyncLock _lock = new();", "        private readonly ILogger _logger = App.GetLogger<RemovalProgressViewModel>();\n        private readonly AsyncLock _lock = new();\n        private readonly PackageInstallationMode _mode;\n        private readonly CancellationTokenSource _cancellation = new();\n        private readonly ObservableAsPropertyHelper<ISolidColorBrush> _progressColor;\n\n        private OperationState _status;\n        private int _currentPackageNumber;\n        private PackageRemovalTask _current;\n\n        public RemovalProgressViewModel(IEnumerable<Package> packages, PackageInstallationMode mode)\n        {\n            _mode = mode;\n            _status = OperationState.Pending;\n            _progressColor = this.WhenValueChanged(x => x.Status).Select(x => x switch\n            {\n                OperationState.Pending => Brushes.Gray,\n                OperationState.Running => Brushes.DodgerBlue,\n                OperationState.Errored => Brushes.Red,\n                OperationState.Completed => Brushes.Green,\n                OperationState.Canceled => Brushes.DarkGray,\n\n                _ => throw new ArgumentOutOfRangeException(nameof(x), x, null)\n            }).ToProperty(this, x => x.ProgressColor);\n\n            var canCancelOperation = this.WhenAnyValue(x => x.CancellationRequested, x => x.Status)\n                .ObserveOn(RxApp.MainThreadScheduler)\n                .Select(x => !x.Item1 && x.Item2 == OperationState.Running);\n\n            Packages = packages.ToList();\n            RequestCancellation = ReactiveCommand.Create(CancelOperation, canCancelOperation);\n        }\n", "        private PackageRemovalTask _current;\n\n        public RemovalProgressViewModel(IEnumerable<Package> packages, PackageInstallationMode mode)\n        {\n            _mode = mode;\n            _status = OperationState.Pending;\n            _progressColor = this.WhenValueChanged(x => x.Status).Select(x => x switch\n            {\n                OperationState.Pending => Brushes.Gray,\n                OperationState.Running => Brushes.DodgerBlue,\n                OperationState.Errored => Brushes.Red,\n                OperationState.Completed => Brushes.Green,\n                OperationState.Canceled => Brushes.DarkGray,\n\n                _ => throw new ArgumentOutOfRangeException(nameof(x), x, null)\n            }).ToProperty(this, x => x.ProgressColor);\n\n            var canCancelOperation = this.WhenAnyValue(x => x.CancellationRequested, x => x.Status)\n                .ObserveOn(RxApp.MainThreadScheduler)\n                .Select(x => !x.Item1 && x.Item2 == OperationState.Running);\n\n            Packages = packages.ToList();\n            RequestCancellation = ReactiveCommand.Create(CancelOperation, canCancelOperation);\n        }\n", "        public event Action CloseRequested;\n\n        public PackageRemovalTask Current\n        {\n            get => _current;\n            private set => this.RaiseAndSetIfChanged(ref _current, value);\n        }\n\n        public int CurrentPackageNumber\n        {\n            get => _currentPackageNumber;\n            private set => this.RaiseAndSetIfChanged(ref _currentPackageNumber, value);\n        }\n", "        public int CurrentPackageNumber\n        {\n            get => _currentPackageNumber;\n            private set => this.RaiseAndSetIfChanged(ref _currentPackageNumber, value);\n        }\n\n        public OperationState Status\n        {\n            get => _status;\n            private set => this.RaiseAndSetIfChanged(ref _status, value);\n        }\n", "        public bool CancellationRequested => _cancellation.IsCancellationRequested;\n\n        public ISolidColorBrush ProgressColor => _progressColor.Value;\n\n        public IReadOnlyList<Package> Packages { get; }\n\n        public ICommand RequestCancellation { get; }\n\n        private void CancelOperation()\n        {\n            _cancellation.Cancel();\n            this.RaisePropertyChanged(nameof(CancellationRequested));\n        }\n\n        void IHandlesClosingEvent.OnClose(CancelEventArgs args)\n        {\n            args.Cancel = Status == OperationState.Running;\n        }\n\n        async Task IExecutesTaskPostLoad.Perform()\n        {\n            _logger.LogInformation(\"Removal process started\");\n            _logger.LogDebug(\"Waiting for lock access\");\n", "        private void CancelOperation()\n        {\n            _cancellation.Cancel();\n            this.RaisePropertyChanged(nameof(CancellationRequested));\n        }\n\n        void IHandlesClosingEvent.OnClose(CancelEventArgs args)\n        {\n            args.Cancel = Status == OperationState.Running;\n        }\n\n        async Task IExecutesTaskPostLoad.Perform()\n        {\n            _logger.LogInformation(\"Removal process started\");\n            _logger.LogDebug(\"Waiting for lock access\");\n", "            using (await _lock.LockAsync(_cancellation.Token).ConfigureAwait(false))\n            {\n                Status = OperationState.Running;\n\n                var manager = new PackageManager();\n\n                for (var i = 0; i < Packages.Count; i++)\n                {\n                    if (CancellationRequested)\n                    {\n                        break;\n                    }\n\n                    CurrentPackageNumber = i + 1;\n                    Current = new PackageRemovalTask(manager, Packages[i], _mode);\n\n                    try\n                    {\n                        _logger.LogInformation(\"Starting removal of {packageId}\", Current.Package.Id);\n\n#if DRY_RUN\n                        await Task.Delay(1000, _cancellation.Token).ConfigureAwait(false);\n#else\n                        await Current.RemoveAsync(_cancellation.Token).ConfigureAwait(false);\n#endif\n                    }", "                    if (CancellationRequested)\n                    {\n                        break;\n                    }\n\n                    CurrentPackageNumber = i + 1;\n                    Current = new PackageRemovalTask(manager, Packages[i], _mode);\n\n                    try\n                    {\n                        _logger.LogInformation(\"Starting removal of {packageId}\", Current.Package.Id);\n\n#if DRY_RUN\n                        await Task.Delay(1000, _cancellation.Token).ConfigureAwait(false);\n#else\n                        await Current.RemoveAsync(_cancellation.Token).ConfigureAwait(false);\n#endif\n                    }", "                    catch (OperationCanceledException)\n                    {\n                        _logger.LogInformation(\"Package removal cancelled by user (stopped at {packageId})\", Current.Package.Id);\n                    }\n                    catch (Exception ex)\n                    {\n                        Status = OperationState.Errored;\n                        _logger.LogError(ex, \"Package removal failed: {err}\", ex.Message);\n\n                        break;\n                    }\n                }\n            }\n\n            Status = CancellationRequested ? OperationState.Canceled : OperationState.Completed;\n            MessageBus.Current.SendMessage(new PackageRefreshEventArgs());\n\n            _logger.LogInformation(\"Package removal process ended: {state}\", Status);\n\n            await Task.Delay(1000).ConfigureAwait(false);\n            CloseRequested?.Invoke();\n        }\n    }\n", "    public enum OperationState\n    {\n        Pending,\n        Running,\n        Errored,\n        Completed,\n        Canceled\n    }\n}"]}
{"filename": "DragonFruit.Kaplan/ViewModels/PackageRemovalTask.cs", "chunked_list": ["\ufeff// Kaplan Copyright (c) DragonFruit Network <inbox@dragonfruit.network>\n// Licensed under Apache-2. Refer to the LICENSE file for more info\n\nusing System;\nusing System.Reactive.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Windows.ApplicationModel;\nusing Windows.Management.Deployment;\nusing DragonFruit.Kaplan.ViewModels.Enums;", "using Windows.Management.Deployment;\nusing DragonFruit.Kaplan.ViewModels.Enums;\nusing ReactiveUI;\n\nnamespace DragonFruit.Kaplan.ViewModels\n{\n    public class PackageRemovalTask : ReactiveObject\n    {\n        private readonly ObservableAsPropertyHelper<string> _statusString;\n        private readonly PackageInstallationMode _mode;\n        private readonly PackageManager _manager;\n\n        private DeploymentProgress? _progress;\n\n        public PackageRemovalTask(PackageManager manager, Package package, PackageInstallationMode mode)\n        {\n            Package = new PackageViewModel(package);\n\n            _mode = mode;\n            _manager = manager;\n            _statusString = this.WhenAnyValue(x => x.Progress)\n                .Select(x => x?.state switch\n                {\n                    DeploymentProgressState.Queued => $\"Removing {Package.Name}: Pending\",\n                    DeploymentProgressState.Processing when x.Value.percentage == 100 => $\"Removing {Package.Name} Complete\",\n                    DeploymentProgressState.Processing when x.Value.percentage > 0 => $\"Removing {Package.Name}: {x.Value.percentage}% Complete\",\n\n                    _ => $\"Removing {Package.Name}\"\n                })\n                .ToProperty(this, x => x.Status);\n        }\n\n        private DeploymentProgress? Progress\n        {\n            get => _progress;\n            set => this.RaiseAndSetIfChanged(ref _progress, value);\n        }\n", "        private readonly ObservableAsPropertyHelper<string> _statusString;\n        private readonly PackageInstallationMode _mode;\n        private readonly PackageManager _manager;\n\n        private DeploymentProgress? _progress;\n\n        public PackageRemovalTask(PackageManager manager, Package package, PackageInstallationMode mode)\n        {\n            Package = new PackageViewModel(package);\n\n            _mode = mode;\n            _manager = manager;\n            _statusString = this.WhenAnyValue(x => x.Progress)\n                .Select(x => x?.state switch\n                {\n                    DeploymentProgressState.Queued => $\"Removing {Package.Name}: Pending\",\n                    DeploymentProgressState.Processing when x.Value.percentage == 100 => $\"Removing {Package.Name} Complete\",\n                    DeploymentProgressState.Processing when x.Value.percentage > 0 => $\"Removing {Package.Name}: {x.Value.percentage}% Complete\",\n\n                    _ => $\"Removing {Package.Name}\"\n                })\n                .ToProperty(this, x => x.Status);\n        }\n\n        private DeploymentProgress? Progress\n        {\n            get => _progress;\n            set => this.RaiseAndSetIfChanged(ref _progress, value);\n        }\n", "        public PackageViewModel Package { get; }\n\n        public string Status => _statusString.Value;\n\n        public async Task RemoveAsync(CancellationToken cancellation = default)\n        {\n            var progressCallback = new Progress<DeploymentProgress>(p => Progress = p);\n            var options = _mode == PackageInstallationMode.Machine ? RemovalOptions.RemoveForAllUsers : RemovalOptions.None;\n\n            await _manager.RemovePackageAsync(Package.Package.Id.FullName, options).AsTask(cancellation, progressCallback).ConfigureAwait(false);\n        }\n    }\n}"]}
{"filename": "DragonFruit.Kaplan/ViewModels/Messages/ShowAboutWindowEventArgs.cs", "chunked_list": ["\ufeff// Kaplan Copyright (c) DragonFruit Network <inbox@dragonfruit.network>\n// Licensed under Apache-2. Refer to the LICENSE file for more info\n\nnamespace DragonFruit.Kaplan.ViewModels.Messages\n{\n    public class ShowAboutWindowEventArgs\n    {\n    }\n}"]}
{"filename": "DragonFruit.Kaplan/ViewModels/Messages/PackageRefreshEventArgs.cs", "chunked_list": ["\ufeff// Kaplan Copyright (c) DragonFruit Network <inbox@dragonfruit.network>\n// Licensed under Apache-2. Refer to the LICENSE file for more info\n\nnamespace DragonFruit.Kaplan.ViewModels.Messages\n{\n    public class PackageRefreshEventArgs\n    {\n    }\n}"]}
{"filename": "DragonFruit.Kaplan/ViewModels/Messages/UninstallEventArgs.cs", "chunked_list": ["\ufeff// Kaplan Copyright (c) DragonFruit Network <inbox@dragonfruit.network>\n// Licensed under Apache-2. Refer to the LICENSE file for more info\n\nusing System.Collections.Generic;\nusing Windows.ApplicationModel;\nusing DragonFruit.Kaplan.ViewModels.Enums;\n\nnamespace DragonFruit.Kaplan.ViewModels.Messages\n{\n    public class UninstallEventArgs\n    {\n        public UninstallEventArgs(IEnumerable<Package> packages, PackageInstallationMode mode)\n        {\n            Packages = packages;\n            Mode = mode;\n        }\n\n        public IEnumerable<Package> Packages { get; }", "{\n    public class UninstallEventArgs\n    {\n        public UninstallEventArgs(IEnumerable<Package> packages, PackageInstallationMode mode)\n        {\n            Packages = packages;\n            Mode = mode;\n        }\n\n        public IEnumerable<Package> Packages { get; }\n        public PackageInstallationMode Mode { get; }\n    }\n}", "        public PackageInstallationMode Mode { get; }\n    }\n}"]}
{"filename": "DragonFruit.Kaplan/ViewModels/Enums/PackageInstallationMode.cs", "chunked_list": ["\ufeff// Kaplan Copyright (c) DragonFruit Network <inbox@dragonfruit.network>\n// Licensed under Apache-2. Refer to the LICENSE file for more info\n\nnamespace DragonFruit.Kaplan.ViewModels.Enums\n{\n    public enum PackageInstallationMode\n    {\n        User,\n        Machine\n    }\n}"]}
{"filename": "DragonFruit.Kaplan/Views/Welcome.axaml.cs", "chunked_list": ["// Kaplan Copyright (c) DragonFruit Network <inbox@dragonfruit.network>\n// Licensed under Apache-2. Refer to the LICENSE file for more info\n\nusing System;\nusing Avalonia;\nusing Avalonia.Controls;\nusing Avalonia.Controls.ApplicationLifetimes;\nusing Avalonia.Interactivity;\nusing DragonFruit.Kaplan.ViewModels;\n", "using DragonFruit.Kaplan.ViewModels;\n\nnamespace DragonFruit.Kaplan.Views\n{\n    public partial class Welcome : Window\n    {\n        public Welcome()\n        {\n            InitializeComponent();\n            DataContext = this;\n        }\n", "        public bool ShowCompatabilityMessage => !WindowsVersionCompatible;\n        public bool WindowsVersionCompatible => Environment.OSVersion.Version >= Program.MinWindowsVersion;\n\n        public string CompatabilityErrorMessage => $\"Windows {Program.MinWindowsVersion.ToString()} is required to use this program. This machine is currently running version {Environment.OSVersion.Version.ToString()}\";\n\n        private async void OpenAboutDialog(object sender, RoutedEventArgs e)\n        {\n            await new About().ShowDialog(this).ConfigureAwait(false);\n        }\n\n        private void CloseDialog(object sender, RoutedEventArgs e)\n        {\n            var window = new MainWindow\n            {\n                DataContext = new MainWindowViewModel()\n            };\n\n            window.Show();\n", "        private void CloseDialog(object sender, RoutedEventArgs e)\n        {\n            var window = new MainWindow\n            {\n                DataContext = new MainWindowViewModel()\n            };\n\n            window.Show();\n\n            if (Application.Current?.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)\n            {\n                desktop.MainWindow = window;\n            }\n\n            Close();\n        }\n    }\n}", "            if (Application.Current?.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)\n            {\n                desktop.MainWindow = window;\n            }\n\n            Close();\n        }\n    }\n}"]}
{"filename": "DragonFruit.Kaplan/Views/MainWindow.axaml.cs", "chunked_list": ["// Kaplan Copyright (c) DragonFruit Network <inbox@dragonfruit.network>\n// Licensed under Apache-2. Refer to the LICENSE file for more info\n\nusing System;\nusing System.Collections.Generic;\nusing Avalonia;\nusing Avalonia.Controls;\nusing DragonFruit.Kaplan.ViewModels;\nusing DragonFruit.Kaplan.ViewModels.Messages;\nusing FluentAvalonia.UI.Windowing;", "using DragonFruit.Kaplan.ViewModels.Messages;\nusing FluentAvalonia.UI.Windowing;\nusing ReactiveUI;\n\nnamespace DragonFruit.Kaplan.Views\n{\n    public partial class MainWindow : AppWindow\n    {\n        private readonly IEnumerable<IDisposable> _messageListeners;\n\n        public MainWindow()\n        {\n            InitializeComponent();\n\n            TransparencyLevelHint = Program.TransparencyLevels;\n\n            TitleBar.ExtendsContentIntoTitleBar = true;\n            TitleBar.TitleBarHitTestType = TitleBarHitTestType.Complex;\n\n            _messageListeners = new[]\n            {\n                MessageBus.Current.Listen<UninstallEventArgs>().Subscribe(OpenProgressDialog),\n                MessageBus.Current.Listen<ShowAboutWindowEventArgs>().Subscribe(_ => new About().ShowDialog(this))\n            };\n        }\n", "        private readonly IEnumerable<IDisposable> _messageListeners;\n\n        public MainWindow()\n        {\n            InitializeComponent();\n\n            TransparencyLevelHint = Program.TransparencyLevels;\n\n            TitleBar.ExtendsContentIntoTitleBar = true;\n            TitleBar.TitleBarHitTestType = TitleBarHitTestType.Complex;\n\n            _messageListeners = new[]\n            {\n                MessageBus.Current.Listen<UninstallEventArgs>().Subscribe(OpenProgressDialog),\n                MessageBus.Current.Listen<ShowAboutWindowEventArgs>().Subscribe(_ => new About().ShowDialog(this))\n            };\n        }\n", "        private async void OpenProgressDialog(UninstallEventArgs args)\n        {\n            var window = new RemovalProgress\n            {\n                DataContext = new RemovalProgressViewModel(args.Packages, args.Mode)\n            };\n\n            await window.ShowDialog(this).ConfigureAwait(false);\n            MessageBus.Current.SendMessage(new PackageRefreshEventArgs());\n        }\n", "        private void PackageListPropertyChanged(object sender, AvaloniaPropertyChangedEventArgs e)\n        {\n            if (e.Property.Name != nameof(ListBox.ItemsSource))\n            {\n                return;\n            }\n\n            // when the item source changes, scroll to the top\n            if (sender is ListBox box && box.Scroll != null)\n            {\n                box.Scroll.Offset = Vector.Zero;\n            }\n        }\n", "            if (sender is ListBox box && box.Scroll != null)\n            {\n                box.Scroll.Offset = Vector.Zero;\n            }\n        }\n\n        protected override void OnClosed(EventArgs e)\n        {\n            base.OnClosed(e);\n\n            foreach (var messageListener in _messageListeners)\n            {\n                messageListener.Dispose();\n            }\n        }\n    }\n}", "            foreach (var messageListener in _messageListeners)\n            {\n                messageListener.Dispose();\n            }\n        }\n    }\n}"]}
{"filename": "DragonFruit.Kaplan/Views/RemovalProgress.axaml.cs", "chunked_list": ["// Kaplan Copyright (c) DragonFruit Network <inbox@dragonfruit.network>\n// Licensed under Apache-2. Refer to the LICENSE file for more info\n\nusing System;\nusing Avalonia.Controls;\nusing Avalonia.Threading;\nusing DragonFruit.Kaplan.ViewModels;\n\nnamespace DragonFruit.Kaplan.Views\n{\n    public partial class RemovalProgress : Window\n    {\n        public RemovalProgress()\n        {\n            InitializeComponent();\n        }\n", "namespace DragonFruit.Kaplan.Views\n{\n    public partial class RemovalProgress : Window\n    {\n        public RemovalProgress()\n        {\n            InitializeComponent();\n        }\n\n        protected override void OnOpened(EventArgs e)\n        {", "        protected override void OnOpened(EventArgs e)\n        {\n            if (DataContext is ICanCloseWindow windowCloser)\n            {\n                windowCloser.CloseRequested += () => Dispatcher.UIThread.InvokeAsync(Close);\n            }\n\n            (DataContext as IExecutesTaskPostLoad)?.Perform();\n        }\n\n        protected override void OnClosing(WindowClosingEventArgs e)\n        {\n            (DataContext as IHandlesClosingEvent)?.OnClose(e);\n        }\n    }\n}", "        protected override void OnClosing(WindowClosingEventArgs e)\n        {\n            (DataContext as IHandlesClosingEvent)?.OnClose(e);\n        }\n    }\n}"]}
{"filename": "DragonFruit.Kaplan/Views/About.axaml.cs", "chunked_list": ["// Kaplan Copyright (c) DragonFruit Network <inbox@dragonfruit.network>\n// Licensed under Apache-2. Refer to the LICENSE file for more info\n\nusing System;\nusing System.IO;\nusing Avalonia.Controls;\nusing Avalonia.Interactivity;\nusing Avalonia.Platform;\nusing Avalonia.Threading;\n", "using Avalonia.Threading;\n\nnamespace DragonFruit.Kaplan.Views\n{\n    public partial class About : Window\n    {\n        public About()\n        {\n            InitializeComponent();\n        }\n", "        private async void OnLoad(object sender, RoutedEventArgs e)\n        {\n            using var licenseFileStream = AssetLoader.Open(new Uri(\"avares://DragonFruit.Kaplan/Assets/licences.txt\"));\n            using var streamReader = new StreamReader(licenseFileStream);\n\n            var contents = await streamReader.ReadToEndAsync().ConfigureAwait(false);\n            Dispatcher.UIThread.InvokeAsync(() => LicenseContents.Text = contents);\n        }\n    }\n}"]}
