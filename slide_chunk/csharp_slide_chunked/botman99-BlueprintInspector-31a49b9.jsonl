{"filename": "VisualStudioExtension/NamedPipeThread.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Threading;\nusing System.IO;\nusing System.IO.Pipes;\nusing System.Runtime.InteropServices;\n\nnamespace BlueprintInspector\n{\n\tpublic class NamedPipeThread\n\t{\n\t\t[DllImport(\"user32.dll\")]\n\t\tstatic extern bool SetForegroundWindow(IntPtr hWnd);\n\n\t\tNamedPipeClientStream ClientPipe = null;\n\t\tNamedPipeServerStream ServerPipe = null;\n\n\t\tbool bIsPipeConnected = false;\n\t\tbool bShouldReadEditorWindowHandle = true;\n\n\t\tprivate List<string> BlueprintAssetPathToSend = new List<string>();\n\n\t\tpublic NamedPipeThread()\n\t\t{\n\t\t}\n", "namespace BlueprintInspector\n{\n\tpublic class NamedPipeThread\n\t{\n\t\t[DllImport(\"user32.dll\")]\n\t\tstatic extern bool SetForegroundWindow(IntPtr hWnd);\n\n\t\tNamedPipeClientStream ClientPipe = null;\n\t\tNamedPipeServerStream ServerPipe = null;\n\n\t\tbool bIsPipeConnected = false;\n\t\tbool bShouldReadEditorWindowHandle = true;\n\n\t\tprivate List<string> BlueprintAssetPathToSend = new List<string>();\n\n\t\tpublic NamedPipeThread()\n\t\t{\n\t\t}\n", "\t\tpublic void Run()\n\t\t{\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tif (!bIsPipeConnected)  // do we need to open the named pipe?\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\t// see if the named pipe already exists (opened by the other application)\n\t\t\t\t\t\tif (Directory.GetFiles(\"\\\\\\\\.\\\\pipe\\\\\", \"BlueprintInspector*\").Length > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tClientPipe = new NamedPipeClientStream(\".\", \"BlueprintInspector\");\n\t\t\t\t\t\t\tClientPipe.Connect();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse  // otherwise, open the pipe as a server in bi-directional mode\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tServerPipe = new NamedPipeServerStream(\"BlueprintInspector\", PipeDirection.InOut);\n\t\t\t\t\t\t\tServerPipe.WaitForConnection();\n\t\t\t\t\t\t}\n\t\t\t\t\t}", "\t\t\t\t\t\tif (Directory.GetFiles(\"\\\\\\\\.\\\\pipe\\\\\", \"BlueprintInspector*\").Length > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tClientPipe = new NamedPipeClientStream(\".\", \"BlueprintInspector\");\n\t\t\t\t\t\t\tClientPipe.Connect();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse  // otherwise, open the pipe as a server in bi-directional mode\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tServerPipe = new NamedPipeServerStream(\"BlueprintInspector\", PipeDirection.InOut);\n\t\t\t\t\t\t\tServerPipe.WaitForConnection();\n\t\t\t\t\t\t}\n\t\t\t\t\t}", "\t\t\t\t\tcatch(Exception ex)\n\t\t\t\t\t{\n\t\t\t\t\t\tConsole.WriteLine(\"Exception: {0}\", ex.Message);\n\t\t\t\t\t}\n\n\t\t\t\t\tbIsPipeConnected = true;\n\t\t\t\t}\n\n\t\t\t\tif (bShouldReadEditorWindowHandle && bIsPipeConnected)\n\t\t\t\t{\n\t\t\t\t\tbShouldReadEditorWindowHandle = false;\n", "\t\t\t\tif (bShouldReadEditorWindowHandle && bIsPipeConnected)\n\t\t\t\t{\n\t\t\t\t\tbShouldReadEditorWindowHandle = false;\n\n\t\t\t\t\tif (ClientPipe != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbyte[] handle = new byte[] { 0,0,0,0 };\n\t\t\t\t\t\tClientPipe.Read(handle, 0, 4);\n\t\t\t\t\t\tBlueprintInspectorGlobals.EditorTopLevelWindowHandle = BitConverter.ToInt32(handle, 0);\n\t\t\t\t\t}\n\t\t\t\t\telse if (ServerPipe != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbyte[] handle = new byte[] { 0,0,0,0 };\n\t\t\t\t\t\tServerPipe.Read(handle, 0, 4);\n\t\t\t\t\t\tBlueprintInspectorGlobals.EditorTopLevelWindowHandle = BitConverter.ToInt32(handle, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n", "\t\t\t\t\telse if (ServerPipe != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbyte[] handle = new byte[] { 0,0,0,0 };\n\t\t\t\t\t\tServerPipe.Read(handle, 0, 4);\n\t\t\t\t\t\tBlueprintInspectorGlobals.EditorTopLevelWindowHandle = BitConverter.ToInt32(handle, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (BlueprintInspectorGlobals.bHasBlueprintAssetPathToSend)\n\t\t\t\t{\n\t\t\t\t\tlock (BlueprintInspectorGlobals.BlueprintAssetPathLock)\n\t\t\t\t\t{\n\t\t\t\t\t\tBlueprintAssetPathToSend.AddRange(BlueprintInspectorGlobals.BlueprintAssetPathToSend);\n\t\t\t\t\t\tBlueprintInspectorGlobals.BlueprintAssetPathToSend.Clear();\n\n\t\t\t\t\t\tBlueprintInspectorGlobals.bHasBlueprintAssetPathToSend = false;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry\n\t\t\t\t\t{", "\t\t\t\tif (BlueprintInspectorGlobals.bHasBlueprintAssetPathToSend)\n\t\t\t\t{\n\t\t\t\t\tlock (BlueprintInspectorGlobals.BlueprintAssetPathLock)\n\t\t\t\t\t{\n\t\t\t\t\t\tBlueprintAssetPathToSend.AddRange(BlueprintInspectorGlobals.BlueprintAssetPathToSend);\n\t\t\t\t\t\tBlueprintInspectorGlobals.BlueprintAssetPathToSend.Clear();\n\n\t\t\t\t\t\tBlueprintInspectorGlobals.bHasBlueprintAssetPathToSend = false;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry\n\t\t\t\t\t{", "\t\t\t\t\t\twhile (BlueprintAssetPathToSend.Count > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring command = String.Format(\"AssetPath,{0}\", BlueprintAssetPathToSend[0]);\n\n\t\t\t\t\t\t\tbyte[] outBuffer = Encoding.ASCII.GetBytes(command);\n\t\t\t\t\t\t\tushort length = (ushort)outBuffer.Length;\n\t\t\t\t\t\t\tif (ClientPipe != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tClientPipe.WriteByte((byte)(length & 0xff));\n\t\t\t\t\t\t\t\tClientPipe.WriteByte((byte)(length / 256));\n\t\t\t\t\t\t\t\tClientPipe.Write(outBuffer, 0, length);\n\t\t\t\t\t\t\t}", "\t\t\t\t\t\t\telse if (ServerPipe != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tServerPipe.WriteByte((byte)(length & 0xff));\n\t\t\t\t\t\t\t\tServerPipe.WriteByte((byte)(length / 256));\n\t\t\t\t\t\t\t\tServerPipe.Write(outBuffer, 0, length);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tBlueprintAssetPathToSend.RemoveAt(0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tIntPtr TopLevelWindow = new IntPtr(BlueprintInspectorGlobals.EditorTopLevelWindowHandle);\n\t\t\t\t\t\tSetForegroundWindow(TopLevelWindow);\n\t\t\t\t\t}", "\t\t\t\t\tcatch(Exception)\n\t\t\t\t\t{\n\t\t\t\t\t\t// pipe connection was closed...\n\t\t\t\t\t\tbIsPipeConnected = false;\n\t\t\t\t\t\tbShouldReadEditorWindowHandle = true;\n\n\t\t\t\t\t\tif (ClientPipe != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tClientPipe.Close();\n\t\t\t\t\t\t}\n", "\t\t\t\t\t\tif (ServerPipe != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tServerPipe.Close();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tClientPipe = null;\n\t\t\t\t\t\tServerPipe = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tThread.Sleep(100);  // sleep for 1/10th of a second\n\t\t\t}\n\t\t}\n\t}\n}\n"]}
{"filename": "VisualStudioExtension/GuidAndCmdID.cs", "chunked_list": ["\ufeffusing System;\n\nnamespace BlueprintInspector\n{\n    class GuidAndCmdID\n    {\n        public const string PackageGuidString = \"9fe6d913-c6f4-4eee-99d5-23c22924ac10\";\n        public const string PackageCmdSetGuidString = \"faaf1a9b-f925-4bfb-b76c-7d6d9e9968d1\";\n\n        public static readonly Guid guidPackage = new Guid(PackageGuidString);\n        public static readonly Guid guidCmdSet = new Guid(PackageCmdSetGuidString);\n", "        public static readonly Guid guidPackage = new Guid(PackageGuidString);\n        public static readonly Guid guidCmdSet = new Guid(PackageCmdSetGuidString);\n\n        public const uint cmdidGenerateJsonFile = 0x0100;\n        public const uint cmdidCopyToClipboard = 0x0101;\n        public const uint cmdidOpenAssetPath = 0x0102;\n    }\n}\n"]}
{"filename": "VisualStudioExtension/MyService.cs", "chunked_list": ["\ufeff\nnamespace BlueprintInspector\n{\n\tpublic interface MyService\n\t{\n\t}\n}\n"]}
{"filename": "VisualStudioExtension/Common.cs", "chunked_list": ["\ufeffusing System;\nusing System.IO.MemoryMappedFiles;\nusing System.Text;\nusing System.Threading;\n\nnamespace BlueprintInspector\n{\n\tpublic class Common\n\t{\n\t\tpublic void WriteSharedMemoryData(MemoryMappedFile mmf, Mutex mutex)\n\t\t{", "\t\tpublic void WriteSharedMemoryData(MemoryMappedFile mmf, Mutex mutex)\n\t\t{\n\t\t\tif (mmf == null || mutex == null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmutex.WaitOne();\n\n\t\t\ttry\n\t\t\t{", "\t\t\t\tusing (MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor(0, 4096))\n\t\t\t\t{\n\t\t\t\t\taccessor.Write(0, (ushort)BlueprintInspectorGlobals.JsonFileUpdateCounter);\n\n\t\t\t\t\tbyte[] Buffer = ASCIIEncoding.ASCII.GetBytes(BlueprintInspectorGlobals.SolutionDirectory);\n\t\t\t\t\taccessor.Write(2, (ushort)Buffer.Length);\n\t\t\t\t\taccessor.WriteArray(4, Buffer, 0, Buffer.Length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\n\t\t\tmutex.ReleaseMutex();\n\t\t}\n\t}\n}\n", "\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\n\t\t\tmutex.ReleaseMutex();\n\t\t}\n\t}\n}\n"]}
{"filename": "VisualStudioExtension/SelectProjectForm.Designer.cs", "chunked_list": ["\ufeffnamespace BlueprintInspector\n{\n\tpartial class SelectProjectForm\n\t{\n\t\t/// <summary>\n\t\t/// Required designer variable.\n\t\t/// </summary>\n\t\tprivate System.ComponentModel.IContainer components = null;\n\n\t\t/// <summary>\n\t\t/// Clean up any resources being used.\n\t\t/// </summary>\n\t\t/// <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.</param>", "\t\tprotected override void Dispose(bool disposing)\n\t\t{\n\t\t\tif (disposing && (components != null))\n\t\t\t{\n\t\t\t\tcomponents.Dispose();\n\t\t\t}\n\t\t\tbase.Dispose(disposing);\n\t\t}\n\n\t\t#region Windows Form Designer generated code\n\n\t\t/// <summary>\n\t\t/// Required method for Designer support - do not modify\n\t\t/// the contents of this method with the code editor.\n\t\t/// </summary>", "\t\tprivate void InitializeComponent()\n\t\t{\n\t\t\tthis.label1 = new System.Windows.Forms.Label();\n\t\t\tthis.comboBox1 = new System.Windows.Forms.ComboBox();\n\t\t\tthis.OK_Button = new System.Windows.Forms.Button();\n\t\t\tthis.Cancel_Button = new System.Windows.Forms.Button();\n\t\t\tthis.EngineCheckbox = new System.Windows.Forms.CheckBox();\n\t\t\tthis.PluginsCheckbox = new System.Windows.Forms.CheckBox();\n\t\t\tthis.DevelopersCheckbox = new System.Windows.Forms.CheckBox();\n\t\t\tthis.SuspendLayout();\n\t\t\t// \n\t\t\t// label1\n\t\t\t// \n\t\t\tthis.label1.Location = new System.Drawing.Point(12, 43);\n\t\t\tthis.label1.Name = \"label1\";\n\t\t\tthis.label1.Size = new System.Drawing.Size(485, 20);\n\t\t\tthis.label1.TabIndex = 0;\n\t\t\tthis.label1.Text = \"xxx\";\n\t\t\tthis.label1.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;\n\t\t\t// \n\t\t\t// comboBox1\n\t\t\t// \n\t\t\tthis.comboBox1.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;\n\t\t\tthis.comboBox1.FormattingEnabled = true;\n\t\t\tthis.comboBox1.Location = new System.Drawing.Point(143, 74);\n\t\t\tthis.comboBox1.Margin = new System.Windows.Forms.Padding(3, 2, 3, 2);\n\t\t\tthis.comboBox1.Name = \"comboBox1\";\n\t\t\tthis.comboBox1.Size = new System.Drawing.Size(223, 24);\n\t\t\tthis.comboBox1.TabIndex = 1;\n\t\t\t// \n\t\t\t// OK_Button\n\t\t\t// \n\t\t\tthis.OK_Button.Location = new System.Drawing.Point(281, 251);\n\t\t\tthis.OK_Button.Margin = new System.Windows.Forms.Padding(3, 2, 3, 2);\n\t\t\tthis.OK_Button.Name = \"OK_Button\";\n\t\t\tthis.OK_Button.Size = new System.Drawing.Size(85, 31);\n\t\t\tthis.OK_Button.TabIndex = 2;\n\t\t\tthis.OK_Button.Text = \"OK\";\n\t\t\tthis.OK_Button.UseVisualStyleBackColor = true;\n\t\t\tthis.OK_Button.Click += new System.EventHandler(this.OK_Button_Click);\n\t\t\t// \n\t\t\t// Cancel_Button\n\t\t\t// \n\t\t\tthis.Cancel_Button.Location = new System.Drawing.Point(396, 251);\n\t\t\tthis.Cancel_Button.Margin = new System.Windows.Forms.Padding(3, 2, 3, 2);\n\t\t\tthis.Cancel_Button.Name = \"Cancel_Button\";\n\t\t\tthis.Cancel_Button.Size = new System.Drawing.Size(85, 31);\n\t\t\tthis.Cancel_Button.TabIndex = 3;\n\t\t\tthis.Cancel_Button.Text = \"Cancel\";\n\t\t\tthis.Cancel_Button.UseVisualStyleBackColor = true;\n\t\t\tthis.Cancel_Button.Click += new System.EventHandler(this.Cancel_Button_Click);\n\t\t\t// \n\t\t\t// EngineCheckbox\n\t\t\t// \n\t\t\tthis.EngineCheckbox.AutoSize = true;\n\t\t\tthis.EngineCheckbox.Location = new System.Drawing.Point(131, 117);\n\t\t\tthis.EngineCheckbox.Margin = new System.Windows.Forms.Padding(4);\n\t\t\tthis.EngineCheckbox.Name = \"EngineCheckbox\";\n\t\t\tthis.EngineCheckbox.Size = new System.Drawing.Size(227, 20);\n\t\t\tthis.EngineCheckbox.TabIndex = 4;\n\t\t\tthis.EngineCheckbox.Text = \"Include Engine Content Blueprints\";\n\t\t\tthis.EngineCheckbox.UseVisualStyleBackColor = true;\n\t\t\t// \n\t\t\t// PluginsCheckbox\n\t\t\t// \n\t\t\tthis.PluginsCheckbox.AutoSize = true;\n\t\t\tthis.PluginsCheckbox.Location = new System.Drawing.Point(131, 158);\n\t\t\tthis.PluginsCheckbox.Margin = new System.Windows.Forms.Padding(4);\n\t\t\tthis.PluginsCheckbox.Name = \"PluginsCheckbox\";\n\t\t\tthis.PluginsCheckbox.Size = new System.Drawing.Size(229, 20);\n\t\t\tthis.PluginsCheckbox.TabIndex = 5;\n\t\t\tthis.PluginsCheckbox.Text = \"Include Plugins Content Blueprints\";\n\t\t\tthis.PluginsCheckbox.UseVisualStyleBackColor = true;\n\t\t\t// \n\t\t\t// DevelopersCheckbox\n\t\t\t// \n\t\t\tthis.DevelopersCheckbox.AutoSize = true;\n\t\t\tthis.DevelopersCheckbox.Location = new System.Drawing.Point(131, 199);\n\t\t\tthis.DevelopersCheckbox.Margin = new System.Windows.Forms.Padding(4);\n\t\t\tthis.DevelopersCheckbox.Name = \"DevelopersCheckbox\";\n\t\t\tthis.DevelopersCheckbox.Size = new System.Drawing.Size(245, 20);\n\t\t\tthis.DevelopersCheckbox.TabIndex = 6;\n\t\t\tthis.DevelopersCheckbox.Text = \"Include Developers folder Blueprints\";\n\t\t\tthis.DevelopersCheckbox.UseVisualStyleBackColor = true;\n\t\t\t// \n\t\t\t// SelectProjectForm\n\t\t\t// \n\t\t\tthis.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);\n\t\t\tthis.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;\n\t\t\tthis.ClientSize = new System.Drawing.Size(509, 310);\n\t\t\tthis.Controls.Add(this.DevelopersCheckbox);\n\t\t\tthis.Controls.Add(this.PluginsCheckbox);\n\t\t\tthis.Controls.Add(this.EngineCheckbox);\n\t\t\tthis.Controls.Add(this.Cancel_Button);\n\t\t\tthis.Controls.Add(this.OK_Button);\n\t\t\tthis.Controls.Add(this.comboBox1);\n\t\t\tthis.Controls.Add(this.label1);\n\t\t\tthis.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n\t\t\tthis.Margin = new System.Windows.Forms.Padding(3, 2, 3, 2);\n\t\t\tthis.MaximizeBox = false;\n\t\t\tthis.MinimizeBox = false;\n\t\t\tthis.Name = \"SelectProjectForm\";\n\t\t\tthis.Text = \"Select Project\";\n\t\t\tthis.Load += new System.EventHandler(this.OnLoad);\n\t\t\tthis.ResumeLayout(false);\n\t\t\tthis.PerformLayout();\n\n\t\t}\n\n\t\t#endregion\n\n\t\tprivate System.Windows.Forms.Label label1;\n\t\tprivate System.Windows.Forms.ComboBox comboBox1;\n\t\tprivate System.Windows.Forms.Button OK_Button;\n\t\tprivate System.Windows.Forms.Button Cancel_Button;\n\t\tprivate System.Windows.Forms.CheckBox EngineCheckbox;\n\t\tprivate System.Windows.Forms.CheckBox PluginsCheckbox;\n\t\tprivate System.Windows.Forms.CheckBox DevelopersCheckbox;\n\t}\n}"]}
{"filename": "VisualStudioExtension/SelectProjectForm.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\nusing System.Threading.Tasks;", "using System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\n\nnamespace BlueprintInspector\n{\n\tpublic partial class SelectProjectForm : Form\n\t{\n\t\tpublic List<string> ProjectFiles;\n\t\tpublic int SelectedIndex = -1;\n\t\tpublic bool bIncludeEngine = false;", "\t\tpublic int SelectedIndex = -1;\n\t\tpublic bool bIncludeEngine = false;\n\t\tpublic bool bIncludePlugins = false;\n\t\tpublic bool bIncludeDevelopers = false;\n\n\t\tpublic SelectProjectForm()\n\t\t{\n\t\t\tInitializeComponent();\n\n\t\t\tStartPosition = FormStartPosition.CenterParent;\n\n\t\t\tEngineCheckbox.Checked = Properties.Settings.Default.IncludeEngine;\n\t\t\tPluginsCheckbox.Checked = Properties.Settings.Default.IncludePlugins;\n\t\t\tDevelopersCheckbox.Checked = Properties.Settings.Default.IncludeDevelopers;\n\t\t}\n", "\t\tprivate void OnLoad(object sender, EventArgs e)\n\t\t{\n\t\t\tif (ProjectFiles.Count == 1)\n\t\t\t{\n\t\t\t\tthis.Text = \"Project\";\n\n\t\t\t\tlabel1.Text = String.Format(\"Generating the JSON file for project {0}\", Path.GetFileNameWithoutExtension(ProjectFiles[0]));\n\n\t\t\t\tcomboBox1.Hide();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlabel1.Text = \"Select the project you wish to generate the JSON file for:\";\n\n\t\t\t}\n", "\t\t\tfor (int index = 0; index < ProjectFiles.Count; ++index)  // even though this is hidden for just a single project, add the only project to the (hidden) list\n\t\t\t{\n\t\t\t\tstring projectName = Path.GetFileNameWithoutExtension(ProjectFiles[index]);\n\t\t\t\tcomboBox1.Items.Add(projectName);\n\t\t\t}\n\n\t\t\tcomboBox1.SelectedIndex = 0;  // default to first project (this will be used to set 'SelectedIndex' for just a single project)\n\t\t}\n\n\t\tprivate void OK_Button_Click(object sender, EventArgs e)\n\t\t{\n\t\t\tSelectedIndex = comboBox1.SelectedIndex;\n\n\t\t\tProperties.Settings.Default.IncludeEngine = EngineCheckbox.Checked;\n\t\t\tProperties.Settings.Default.IncludePlugins = PluginsCheckbox.Checked;\n\t\t\tProperties.Settings.Default.IncludeDevelopers = DevelopersCheckbox.Checked;\n\n\t\t\tProperties.Settings.Default.Save();  // this will go into C:\\Users\\<user>\\AppData\\Local\\...\\user.config\n\n\t\t\tbIncludeEngine = EngineCheckbox.Checked;\n\t\t\tbIncludePlugins = PluginsCheckbox.Checked;\n\t\t\tbIncludeDevelopers = DevelopersCheckbox.Checked;\n\n\t\t\tthis.DialogResult = DialogResult.OK;\n\n\t\t\tClose();\n\t\t}\n", "\t\tprivate void OK_Button_Click(object sender, EventArgs e)\n\t\t{\n\t\t\tSelectedIndex = comboBox1.SelectedIndex;\n\n\t\t\tProperties.Settings.Default.IncludeEngine = EngineCheckbox.Checked;\n\t\t\tProperties.Settings.Default.IncludePlugins = PluginsCheckbox.Checked;\n\t\t\tProperties.Settings.Default.IncludeDevelopers = DevelopersCheckbox.Checked;\n\n\t\t\tProperties.Settings.Default.Save();  // this will go into C:\\Users\\<user>\\AppData\\Local\\...\\user.config\n\n\t\t\tbIncludeEngine = EngineCheckbox.Checked;\n\t\t\tbIncludePlugins = PluginsCheckbox.Checked;\n\t\t\tbIncludeDevelopers = DevelopersCheckbox.Checked;\n\n\t\t\tthis.DialogResult = DialogResult.OK;\n\n\t\t\tClose();\n\t\t}\n", "\t\tprivate void Cancel_Button_Click(object sender, EventArgs e)\n\t\t{\n\t\t\tthis.DialogResult = DialogResult.Cancel;\n\n\t\t\tClose();\n\t\t}\n\t}\n}\n"]}
{"filename": "VisualStudioExtension/RunExecutable.cs", "chunked_list": ["\ufeffusing System;\nusing System.IO;\nusing System.Diagnostics;\nusing System.Threading;\nusing Microsoft.VisualStudio.Shell;\nusing Microsoft.VisualStudio.Shell.Interop;\nusing System.IO.MemoryMappedFiles;\n\nnamespace BlueprintInspector\n{\n\tpublic class RunExecutable\n\t{", "namespace BlueprintInspector\n{\n\tpublic class RunExecutable\n\t{\n\t\tprivate bool StdOutDone;  // wait until OnOutputDataReceived receives e.Data == null to know that stdout has terminated\n\t\tprivate bool StdErrDone;  // wait until OnErrorDataReceived receives e.Data == null to know that stderr has terminated\n\n\t\tprivate bool bIsUE4Project;\n\t\tprivate bool bIncludeEngine;\n\t\tprivate bool bIncludePlugins;\n\t\tprivate bool bIncludeDevelopers;\n", "\t\tprivate bool bIncludeEngine;\n\t\tprivate bool bIncludePlugins;\n\t\tprivate bool bIncludeDevelopers;\n\n\t\tprivate MemoryMappedFile mmf = null;\n\t\tprivate Mutex mutex = null;\n\n\t\tprivate bool JsonFileUpdated = false;\n\t\tprivate bool bRestartVisualStudio = false;\n\t\tprivate SharedProject.BlueprintJson OldBlueprintJsonData = null;\n\t\tprivate SharedProject.BlueprintJson NewBlueprintJsonData = null;\n", "\t\tprivate bool bRestartVisualStudio = false;\n\t\tprivate SharedProject.BlueprintJson OldBlueprintJsonData = null;\n\t\tprivate SharedProject.BlueprintJson NewBlueprintJsonData = null;\n\n\t\tprivate bool bBlueprintInspectorCommandletStarted = false;\n\t\tprivate bool bBlueprintInspectorCommandletCompleted = false;\n\t\tprivate bool bCommandletProcessCompleted = false;\n\n\t\tpublic RunExecutable(bool bInIsUE4Project, bool bInIncludeEngine, bool bInIncludePlugins, bool bInIncludeDevelopers)\n\t\t{\n\t\t\tbIsUE4Project = bInIsUE4Project;\n\t\t\tbIncludeEngine = bInIncludeEngine;\n\t\t\tbIncludePlugins = bInIncludePlugins;\n\t\t\tbIncludeDevelopers = bInIncludeDevelopers;\n\t\t}\n", "\t\tpublic void Run()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstring json_filename = BlueprintInspectorGlobals.SolutionDirectory + \".vs\\\\BlueprintInspector.json\";\n\n\t\t\t\tif (File.Exists(json_filename))\n\t\t\t\t{\n\t\t\t\t\tOldBlueprintJsonData = new SharedProject.BlueprintJson();\n\t\t\t\t\tOldBlueprintJsonData.ReadBlueprintJson(json_filename);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// if the json file doesn't already exist before running the commandlet, we should ALWAYS restart Visual Studio after it's generated\n\t\t\t\t\tbRestartVisualStudio = true;\n\t\t\t\t}\n\n\t\t\t\t// use EngineDirectory, ProjectFilename and SolutionDirectory in BlueprintInspectorGlobals to run the commandlet...\n\t\t\t\tstring UnrealEditorCmd = \"\";\n", "\t\t\t\tif (bIsUE4Project)\n\t\t\t\t{\n\t\t\t\t\tUnrealEditorCmd = \"\\\"\" + BlueprintInspectorGlobals.EngineDirectory + \"\\\\Binaries\\\\Win64\\\\UE4Editor-Cmd.exe\\\"\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tUnrealEditorCmd = \"\\\"\" + BlueprintInspectorGlobals.EngineDirectory + \"\\\\Binaries\\\\Win64\\\\UnrealEditor-Cmd.exe\\\"\";\n\t\t\t\t}\n\n\t\t\t\tstring command = String.Format(\"\\\"{0}\\\" -Log -FullStdOutLogOutput -run=BlueprintInspectorCommandlet -outfile=\\\"{1}\\\"\", BlueprintInspectorGlobals.ProjectFilename, json_filename);\n", "\t\t\t\tif (!bIncludeEngine)\n\t\t\t\t{\n\t\t\t\t\tcommand += \" -skipengine\";\n\t\t\t\t}\n\n\t\t\t\tif (!bIncludePlugins)\n\t\t\t\t{\n\t\t\t\t\tcommand += \" -skipplugins\";\n\t\t\t\t}\n\n\t\t\t\tif (!bIncludeDevelopers)\n\t\t\t\t{\n\t\t\t\t\tcommand += \" -skipdevelopers\";\n\t\t\t\t}\n\n\t\t\t\tProcess proc = new Process();\n\n\t\t\t\tStdOutDone = false;\n\t\t\t\tStdErrDone = false;\n\n\t\t\t\tProcessStartInfo startInfo = new ProcessStartInfo(UnrealEditorCmd);\n\n\t\t\t\tstartInfo.UseShellExecute = false;\n\t\t\t\tstartInfo.CreateNoWindow = true;\n\n\t\t\t\tstartInfo.RedirectStandardInput = false;\n\t\t\t\tstartInfo.RedirectStandardOutput = true;\n\t\t\t\tstartInfo.RedirectStandardError = true;\n\n\t\t\t\tstartInfo.Arguments = command;\n\n\t\t\t\tproc.StartInfo = startInfo;\n\t\t\t\tproc.EnableRaisingEvents = true;\n//\t\t\t\tproc.Exited += OnProcessExited;\n\n\t\t\t\tproc.OutputDataReceived += OnOutputDataReceived;\n\t\t\t\tproc.ErrorDataReceived += OnErrorDataReceived;\n\n\t\t\t\tproc.Start();\n\t\t\t\tproc.BeginOutputReadLine();\n\t\t\t\tproc.BeginErrorReadLine();\n", "\t\t\t\tif (!bIncludeDevelopers)\n\t\t\t\t{\n\t\t\t\t\tcommand += \" -skipdevelopers\";\n\t\t\t\t}\n\n\t\t\t\tProcess proc = new Process();\n\n\t\t\t\tStdOutDone = false;\n\t\t\t\tStdErrDone = false;\n\n\t\t\t\tProcessStartInfo startInfo = new ProcessStartInfo(UnrealEditorCmd);\n\n\t\t\t\tstartInfo.UseShellExecute = false;\n\t\t\t\tstartInfo.CreateNoWindow = true;\n\n\t\t\t\tstartInfo.RedirectStandardInput = false;\n\t\t\t\tstartInfo.RedirectStandardOutput = true;\n\t\t\t\tstartInfo.RedirectStandardError = true;\n\n\t\t\t\tstartInfo.Arguments = command;\n\n\t\t\t\tproc.StartInfo = startInfo;\n\t\t\t\tproc.EnableRaisingEvents = true;\n//\t\t\t\tproc.Exited += OnProcessExited;\n\n\t\t\t\tproc.OutputDataReceived += OnOutputDataReceived;\n\t\t\t\tproc.ErrorDataReceived += OnErrorDataReceived;\n\n\t\t\t\tproc.Start();\n\t\t\t\tproc.BeginOutputReadLine();\n\t\t\t\tproc.BeginErrorReadLine();\n", "\t\t\t\tif (!proc.WaitForExit(-1))\n\t\t\t\t{\n\t\t\t\t\tproc.Kill();\n\t\t\t\t}\n\n\t\t\t\tint output_timeout = 10;\n\t\t\t\twhile (!StdOutDone || !StdErrDone)  // wait until the output and error streams have been flushed (or a 1 second (1000 ms) timeout is reached)\n\t\t\t\t{\n\t\t\t\t\tThread.Sleep(100);\n\n\t\t\t\t\tif (--output_timeout == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tproc.Close();\n", "\t\t\t\t\tif (--output_timeout == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tproc.Close();\n\n\t\t\t\tif (File.Exists(json_filename))\n\t\t\t\t{\n\t\t\t\t\t// check if the date of the json file changed and is very recent (to verify that the commandlet updated the file)\n\t\t\t\t\tDateTime filetime = File.GetLastWriteTime(json_filename);\n\t\t\t\t\tdouble deltatime = DateTime.Now.Subtract(filetime).TotalSeconds;", "\t\t\t\tif (File.Exists(json_filename))\n\t\t\t\t{\n\t\t\t\t\t// check if the date of the json file changed and is very recent (to verify that the commandlet updated the file)\n\t\t\t\t\tDateTime filetime = File.GetLastWriteTime(json_filename);\n\t\t\t\t\tdouble deltatime = DateTime.Now.Subtract(filetime).TotalSeconds;\n\t\t\t\t\tif (deltatime < 300)  // less than 5 minutes ago?\n\t\t\t\t\t{\n\t\t\t\t\t\tJsonFileUpdated = true;\n\n\t\t\t\t\t\tBlueprintInspectorGlobals.JsonFileUpdateCounter++;\n\n\t\t\t\t\t\tCommon common = new Common();\n\t\t\t\t\t\tcommon.WriteSharedMemoryData(mmf, mutex);\n\n\t\t\t\t\t\tNewBlueprintJsonData = new SharedProject.BlueprintJson();\n\t\t\t\t\t\tNewBlueprintJsonData.ReadBlueprintJson(json_filename);\n\n\t\t\t\t\t\t// compare the old json data to the new json data to see if they match or not (if not, restart of Visual Studio is required)", "\t\t\t\t\t\tif (OldBlueprintJsonData != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!OldBlueprintJsonData.Compare(NewBlueprintJsonData))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbRestartVisualStudio = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t_ = BlueprintInspectorGlobals.package.JoinableTaskFactory.RunAsync(() => DisplayCommandletCompleteMessageAsync());\n\n\t\t\t}", "\t\t\tcatch (Exception)\n\t\t\t{\n\t\t\t}\n\t\t}\n\n\t\tprivate async System.Threading.Tasks.Task AddOutputStringAsync(string msg)\n\t\t{\n\t\t\tif (bCommandletProcessCompleted)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait ThreadHelper.JoinableTaskFactory.SwitchToMainThreadAsync(BlueprintInspectorGlobals.package.DisposalToken);\n", "\t\t\tif (msg.Contains(\"LogBlueprintInspector: Running BlueprintInspector Commandlet\"))\n\t\t\t{\n\t\t\t\tbBlueprintInspectorCommandletStarted = true;\n\t\t\t}\n\n\t\t\tif (msg.Contains(\"LogBlueprintInspector: Successfully finished running BlueprintInspector Commandlet\"))\n\t\t\t{\n\t\t\t\tbBlueprintInspectorCommandletCompleted = true;\n\t\t\t}\n\n\t\t\tif (msg.Contains(\"Execution of commandlet took:\"))  // ignore any further output after this text is seen\n\t\t\t{\n\t\t\t\tbCommandletProcessCompleted = true;\n\t\t\t}\n\n\t\t\tBlueprintInspectorGlobals.OutputPane.OutputStringThreadSafe(msg);\n\t\t\tBlueprintInspectorGlobals.OutputPane.OutputStringThreadSafe(\"\\n\");\n\t\t}\n", "\t\t\tif (msg.Contains(\"Execution of commandlet took:\"))  // ignore any further output after this text is seen\n\t\t\t{\n\t\t\t\tbCommandletProcessCompleted = true;\n\t\t\t}\n\n\t\t\tBlueprintInspectorGlobals.OutputPane.OutputStringThreadSafe(msg);\n\t\t\tBlueprintInspectorGlobals.OutputPane.OutputStringThreadSafe(\"\\n\");\n\t\t}\n\n\t\tprivate void OnOutputDataReceived(object sender, DataReceivedEventArgs e)\n\t\t{", "\t\tprivate void OnOutputDataReceived(object sender, DataReceivedEventArgs e)\n\t\t{\n\t\t\tif (e.Data != null)\n\t\t\t{\n\t\t\t\t_ = BlueprintInspectorGlobals.package.JoinableTaskFactory.RunAsync(() => AddOutputStringAsync(e.Data));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStdOutDone = true;\n\t\t\t}\n\t\t}\n", "\t\tprivate void OnErrorDataReceived(object sender, DataReceivedEventArgs e)\n\t\t{\n\t\t\tif (e.Data != null)\n\t\t\t{\n\t\t\t\t_ = BlueprintInspectorGlobals.package.JoinableTaskFactory.RunAsync(() => AddOutputStringAsync(e.Data));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStdErrDone = true;\n\t\t\t}\n\t\t}\n", "//\t\tpublic void OnProcessExited(object sender, EventArgs e)\n//\t\t{\n//\t\t}\n\n\t\tprivate async System.Threading.Tasks.Task DisplayCommandletCompleteMessageAsync()\n\t\t{\n\t\t\tawait ThreadHelper.JoinableTaskFactory.SwitchToMainThreadAsync(BlueprintInspectorGlobals.package.DisposalToken);\n\n\t\t\tstring title = \"\";\n\t\t\tstring message = \"\";\n\n\t\t\tOLEMSGICON icon = OLEMSGICON.OLEMSGICON_INFO;\n", "\t\t\tif (!bBlueprintInspectorCommandletStarted)\n\t\t\t{\n\t\t\t\ttitle = \"Failed\";\n\t\t\t\tmessage = \"BlueprintInspector commandlet didn't start running.\\n\\nMake sure you have added the 'Blueprint Inspector' plugin to your project in the editor (Edit -> Plugins).\";\n\t\t\t\ticon = OLEMSGICON.OLEMSGICON_CRITICAL;\n\t\t\t}\n\t\t\telse if (!bBlueprintInspectorCommandletCompleted)\n\t\t\t{\n\t\t\t\ttitle = \"Failed\";\n\t\t\t\tmessage = \"BlueprintInspector commandlet didn't finish running.\\n\\nCheck your project's Saved\\\\Logs folder for the most recent .log file and open it in a text editor to see if the process crashed.\";\n\t\t\t\ticon = OLEMSGICON.OLEMSGICON_CRITICAL;\n\t\t\t}", "\t\t\telse if (!JsonFileUpdated)\n\t\t\t{\n\t\t\t\ttitle = \"Failed\";\n\t\t\t\tmessage = \"BlueprintInspector commandlet failed to generate JSON file (in the hidden .vs folder).\\n\\nCheck your project's Saved\\\\Logs folder for the most recent .log file and open it in a text editor to look for 'LogBlueprintInspector:' messages to investigate why there is no JSON file.\";\n\t\t\t\ticon = OLEMSGICON.OLEMSGICON_CRITICAL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttitle = \"Complete\";\n\t\t\t\tmessage = \"BlueprintInspector commandlet completed successfully.\";\n", "\t\t\t\tif (bRestartVisualStudio)\n\t\t\t\t{\n\t\t\t\t\tmessage = \"BlueprintInspector commandlet completed successfully.\\n\\nYou should RESTART Visual Studio!!!\";\n\t\t\t\t\ticon = OLEMSGICON.OLEMSGICON_CRITICAL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tVsShellUtilities.ShowMessageBox(BlueprintInspectorGlobals.package, message, title, icon, OLEMSGBUTTON.OLEMSGBUTTON_OK, OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST);\n\t\t}\n\t}\n}\n"]}
{"filename": "VisualStudioExtension/BlueprintInspectorGlobals.cs", "chunked_list": ["\ufeffusing Microsoft.VisualStudio.Shell;\nusing Microsoft.VisualStudio.Shell.Interop;\nusing System;\nusing System.Collections.Generic;\n\nnamespace BlueprintInspector\n{\n\tpublic static class BlueprintInspectorGlobals\n\t{\n\t\tpublic static string SolutionDirectory = \"\";  // ends with trailing \"\\\\\"\n\t\tpublic static string EngineDirectory = \"\";  // without the trailing \"\\\\\"", "\t\tpublic static string SolutionDirectory = \"\";  // ends with trailing \"\\\\\"\n\t\tpublic static string EngineDirectory = \"\";  // without the trailing \"\\\\\"\n\t\tpublic static string ProjectFilename = \"\";\n\n\t\tpublic static ushort JsonFileUpdateCounter = 0;  // increment this counter each time the JSON file is rebuilt (this will get sent to the provider via shared memory)\n\n\t\tpublic static Object BlueprintAssetPathLock = new object();\n\t\tpublic static volatile bool bHasBlueprintAssetPathToSend = false;\n\t\tpublic static volatile List<string> BlueprintAssetPathToSend = new List<string>();\n\n\t\tpublic static AsyncPackage package = null;\n", "\t\tpublic static volatile List<string> BlueprintAssetPathToSend = new List<string>();\n\n\t\tpublic static AsyncPackage package = null;\n\n\t\tpublic static IVsOutputWindowPane OutputPane;\n\n\t\tpublic static Int32 EditorTopLevelWindowHandle = -1;\n\t}\n}\n"]}
{"filename": "VisualStudioExtension/BlueprintInspectorPackage.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Threading;\nusing Task = System.Threading.Tasks.Task;\nusing IServiceProvider = System.IServiceProvider;\nusing System.Windows.Forms;\nusing Microsoft.VisualStudio;\nusing Microsoft.VisualStudio.OLE.Interop;\nusing Microsoft.VisualStudio.Shell;", "using Microsoft.VisualStudio.OLE.Interop;\nusing Microsoft.VisualStudio.Shell;\nusing Microsoft.VisualStudio.Shell.Interop;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.MemoryMappedFiles;\n\n#pragma warning disable VSSDK006\n\nnamespace BlueprintInspector", "\nnamespace BlueprintInspector\n{\n\t/// <summary>\n\t/// This is the class that implements the package exposed by this assembly.\n\t/// </summary>\n\t/// <remarks>\n\t/// <para>\n\t/// The minimum requirement for a class to be considered a valid package for Visual Studio\n\t/// is to implement the IVsPackage interface and register itself with the shell.\n\t/// This package uses the helper classes defined inside the Managed Package Framework (MPF)", "\t/// The minimum requirement for a class to be considered a valid package for Visual Studio\n\t/// is to implement the IVsPackage interface and register itself with the shell.\n\t/// This package uses the helper classes defined inside the Managed Package Framework (MPF)\n\t/// to do it: it derives from the Package class that provides the implementation of the\n\t/// IVsPackage interface and uses the registration attributes defined in the framework to\n\t/// register itself and its components with the shell. These attributes tell the pkgdef creation\n\t/// utility what data to put into .pkgdef file.\n\t/// </para>\n\t/// <para>\n\t/// To get loaded into VS, the package must be referred by &lt;Asset Type=\"Microsoft.VisualStudio.VsPackage\" ...&gt; in .vsixmanifest file.\n\t/// </para>\n\t/// </remarks>\n\t[PackageRegistration(UseManagedResourcesOnly = true, AllowsBackgroundLoading = true)]\n\t[ProvideService(typeof(MyService), IsAsyncQueryable = true)]\n\t[ProvideAutoLoad(VSConstants.UICONTEXT.NoSolution_string, PackageAutoLoadFlags.BackgroundLoad)]\n\t[ProvideAutoLoad(VSConstants.UICONTEXT.SolutionOpening_string, PackageAutoLoadFlags.BackgroundLoad)]\n\t[Guid(GuidAndCmdID.PackageGuidString)]\n\t[ProvideMenuResource(\"Menus.ctmenu\", 1)]\n\t[ProvideBindingPath]", "\tpublic sealed class BlueprintInspectorPackage : AsyncPackage, IVsSolutionEvents, IVsSolutionLoadEvents, IOleCommandTarget\n\t{\n\t\tprivate IOleCommandTarget pkgCommandTarget;\n\n\t\tprivate IVsSolution2 advise_solution = null;\n\t\tprivate uint solutionEventsCookie = 0;\n\n\t\tprivate static Int32 VisualStudioProcessId = 0;\n\n\t\tprivate\tstatic System.Threading.Thread NamedPipeWorkerThread = null;\n\t\tprivate static System.Threading.Thread RunExecutableThread = null;\n", "\t\tprivate\tstatic System.Threading.Thread NamedPipeWorkerThread = null;\n\t\tprivate static System.Threading.Thread RunExecutableThread = null;\n\n\t\tprivate static MemoryMappedFile mmf = null;\n\t\tprivate static Mutex mutex = null;\n\n\t\tprivate static char[] InvalidChars;\n\n\t\tprivate Guid OutputPaneGuid = Guid.Empty;\n\n\t\t#region Package Members\n\n\t\t/// <summary>\n\t\t/// Initialization of the package; this method is called right after the package is sited, so this is the place\n\t\t/// where you can put all the initialization code that rely on services provided by VisualStudio.\n\t\t/// </summary>\n\t\t/// <param name=\"cancellationToken\">A cancellation token to monitor for initialization cancellation, which can occur when VS is shutting down.</param>\n\t\t/// <param name=\"progress\">A provider for progress updates.</param>\n\t\t/// <returns>A task representing the async work of package initialization, or an already completed task if there is none. Do not return null from this method.</returns>", "\t\tprivate Guid OutputPaneGuid = Guid.Empty;\n\n\t\t#region Package Members\n\n\t\t/// <summary>\n\t\t/// Initialization of the package; this method is called right after the package is sited, so this is the place\n\t\t/// where you can put all the initialization code that rely on services provided by VisualStudio.\n\t\t/// </summary>\n\t\t/// <param name=\"cancellationToken\">A cancellation token to monitor for initialization cancellation, which can occur when VS is shutting down.</param>\n\t\t/// <param name=\"progress\">A provider for progress updates.</param>\n\t\t/// <returns>A task representing the async work of package initialization, or an already completed task if there is none. Do not return null from this method.</returns>", "\t\tprotected override async Task InitializeAsync(CancellationToken cancellationToken, IProgress<ServiceProgressData> progress)\n\t\t{\n\t\t\tawait base.InitializeAsync(cancellationToken, progress);\n\n\t\t\t// When initialized asynchronously, the current thread may be a background thread at this point.\n\t\t\t// Do any initialization that requires the UI thread after switching to the UI thread.\n\t\t\tawait this.JoinableTaskFactory.SwitchToMainThreadAsync(cancellationToken);\n\n\t\t\tBlueprintInspectorGlobals.package = this;\n\n\t\t\tthis.pkgCommandTarget = await this.GetServiceAsync(typeof(IOleCommandTarget)) as IOleCommandTarget;\n\n\t\t\t// we want to find the Visual Studio process and use that process id to create a unique Mutex and MemoryMappedFile to communicate with the out-of-band CodeLens process (CodeLensProvider)\n\t\t\tint count = 10;\n\t\t\tProcess proc = Process.GetCurrentProcess();\n", "\t\t\twhile ((proc != null) && (proc.ProcessName != \"devenv\") && (count != 0))\n\t\t\t{\n\t\t\t\tproc = SharedProject.SharedGlobals.ParentProcessUtilities.GetParentProcess(proc.Id);\n\t\t\t\tcount--;\n\t\t\t}\n\n\t\t\tif (proc.ProcessName == \"devenv\")\n\t\t\t{\n\t\t\t\tVisualStudioProcessId = proc.Id;\n\t\t\t}\n\n#if OutputDebugString\n\t\t\tSharedProject.SharedGlobals.debug_mutex = new Mutex(false, String.Format(\"BlueprintInspector_debugmutex{0}\", VisualStudioProcessId), out bool debug_mutexCreated);\n", "\t\t\tif (SharedProject.SharedGlobals.debug_mutex != null)\n\t\t\t{\n\t\t\t\tSharedProject.SharedGlobals.OutputDebugString(\"\", false);  // output a blank line each time Visual Studio is restarted\n\t\t\t\tSharedProject.SharedGlobals.OutputDebugString(\"InitializeAsync() - debug_mutex initialized\");\n\t\t\t\tSharedProject.SharedGlobals.OutputDebugString(String.Format(\"InitializeAsync() - process id = {0}\", VisualStudioProcessId));\n\t\t\t}\n#endif\n\n\t\t\tmutex = new Mutex(false, String.Format(\"BlueprintInspector_mutex{0}\", VisualStudioProcessId), out bool mutexCreated);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tmmf = MemoryMappedFile.CreateNew(String.Format(\"BlueprintInspector{0}\", VisualStudioProcessId), 4096);\n\t\t\t\t}", "\t\t\t\tcatch(Exception)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (mmf == null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tUnadviseSolutionEvents();\n\t\t\t\tAdviseSolutionEvents();\n\n\t\t\t\tNamedPipeWorkerThread = new System.Threading.Thread(new NamedPipeThread().Run);\n\t\t\t\tNamedPipeWorkerThread.Priority = ThreadPriority.BelowNormal;\n\t\t\t\tNamedPipeWorkerThread.Start();  // start the thread running\n\n\t\t\t\tInvalidChars = Path.GetInvalidPathChars();  // get characters not allowed in file paths\n\n\t\t\t\t// see if we have a solution loaded...\n\n\t\t\t\t// we need the solution directory to determine where the JSON file is (it will be inside the \".vs\" folder where the .sln file is)\n\t\t\t\tIVsSolution solution = (IVsSolution) Microsoft.VisualStudio.Shell.Package.GetGlobalService(typeof(IVsSolution));", "\t\t\t\tif (solution != null)\n\t\t\t\t{\n\t\t\t\t\tsolution.GetSolutionInfo(out string solutionDirectory, out string solutionName, out string solutionDirectory2);\n\t\t\t\t\tif (solutionDirectory != null && solutionDirectory != \"\")\n\t\t\t\t\t{\n\t\t\t\t\t\tBlueprintInspectorGlobals.SolutionDirectory = solutionDirectory;\n\n\t\t\t\t\t\tCommon common = new Common();\n\t\t\t\t\t\tcommon.WriteSharedMemoryData(mmf, mutex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}", "\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\t\t}\n\n\t\tprivate void AdviseSolutionEvents()\n\t\t{\n\t\t\tThreadHelper.ThrowIfNotOnUIThread();\n\n\t\t\t// Get the solution interface\n\t\t\tadvise_solution = ServiceProvider.GlobalProvider.GetService(typeof(SVsSolution)) as IVsSolution2;", "\t\t\tif (advise_solution != null)\n\t\t\t{\n\t\t\t\t// Register for solution events\n\t\t\t\tadvise_solution.AdviseSolutionEvents(this, out solutionEventsCookie);\n\t\t\t}\n\t\t}\n\n\t\tprivate void UnadviseSolutionEvents()\n\t\t{\n\t\t\tThreadHelper.ThrowIfNotOnUIThread();\n\n\t\t\t// Unadvise all events", "\t\t\tif (advise_solution != null && solutionEventsCookie != 0)\n\t\t\t{\n\t\t\t\tadvise_solution.UnadviseSolutionEvents(solutionEventsCookie);\n\t\t\t}\n\t\t}\n\n\t\t#endregion\n\n\t\t#region IVsSolutionEvents\n\n\t\t// IVsSolutionEvents interface begin", "\t\t// IVsSolutionEvents interface begin\n\t\tpublic int OnAfterOpenProject(IVsHierarchy pHierarchy, int fAdded)\n\t\t{\n\t\t\treturn VSConstants.S_OK;\n\t\t}\n\n\t\tpublic int OnQueryCloseProject(IVsHierarchy pHierarchy, int fRemoving, ref int pfCancel)\n\t\t{\n\t\t\treturn VSConstants.S_OK;\n\t\t}\n", "\t\tpublic int OnBeforeCloseProject(IVsHierarchy pHierarchy, int fRemoved)\n\t\t{\n\t\t\treturn VSConstants.S_OK;\n\t\t}\n\n\t\tpublic int OnAfterLoadProject(IVsHierarchy pStubHierarchy, IVsHierarchy pRealHierarchy)\n\t\t{\n\t\t\treturn VSConstants.S_OK;\n\t\t}\n\n\t\tpublic int OnQueryUnloadProject(IVsHierarchy pRealHierarchy, ref int pfCancel)\n\t\t{\n\t\t\treturn VSConstants.S_OK;\n\t\t}\n", "\t\tpublic int OnQueryUnloadProject(IVsHierarchy pRealHierarchy, ref int pfCancel)\n\t\t{\n\t\t\treturn VSConstants.S_OK;\n\t\t}\n\n\t\tpublic int OnBeforeUnloadProject(IVsHierarchy pRealHierarchy, IVsHierarchy pStubHierarchy)\n\t\t{\n\t\t\treturn VSConstants.S_OK;\n\t\t}\n\n\t\tpublic int OnAfterOpenSolution(object pUnkReserved, int fNewSolution)\n\t\t{\n\t\t\tThreadHelper.ThrowIfNotOnUIThread();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// we need the solution directory to determine where the JSON file is (it will be inside the \".vs\" folder where the .sln file is)\n\t\t\t\tIVsSolution solution = (IVsSolution) Microsoft.VisualStudio.Shell.Package.GetGlobalService(typeof(IVsSolution));", "\t\tpublic int OnAfterOpenSolution(object pUnkReserved, int fNewSolution)\n\t\t{\n\t\t\tThreadHelper.ThrowIfNotOnUIThread();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// we need the solution directory to determine where the JSON file is (it will be inside the \".vs\" folder where the .sln file is)\n\t\t\t\tIVsSolution solution = (IVsSolution) Microsoft.VisualStudio.Shell.Package.GetGlobalService(typeof(IVsSolution));\n\t\t\t\tif (solution != null)\n\t\t\t\t{\n\t\t\t\t\tsolution.GetSolutionInfo(out string solutionDirectory, out string solutionName, out string solutionDirectory2);", "\t\t\t\tif (solution != null)\n\t\t\t\t{\n\t\t\t\t\tsolution.GetSolutionInfo(out string solutionDirectory, out string solutionName, out string solutionDirectory2);\n\t\t\t\t\tif (solutionDirectory != null && solutionDirectory != \"\")\n\t\t\t\t\t{\n\t\t\t\t\t\tBlueprintInspectorGlobals.SolutionDirectory = solutionDirectory;\n\n\t\t\t\t\t\tCommon common = new Common();\n\t\t\t\t\t\tcommon.WriteSharedMemoryData(mmf, mutex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}", "\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\n\t\t\treturn VSConstants.S_OK;\n\t\t}\n\n\t\tpublic int OnQueryCloseSolution(object pUnkReserved, ref int pfCancel)\n\t\t{\n\t\t\treturn VSConstants.S_OK;\n\t\t}\n", "\t\tpublic int OnBeforeCloseSolution(object pUnkReserved)\n\t\t{\n\t\t\treturn VSConstants.S_OK;\n\t\t}\n\n\t\tpublic int OnAfterCloseSolution(object pUnkReserved)\n\t\t{\n\t\t\treturn VSConstants.S_OK;\n\t\t}\n\t\t// IVsSolutionEvents interface end\n\n\t\t#endregion\n\n\t\t#region IVsSolutionLoadEvents\n", "\t\t// IVsSolutionEvents interface end\n\n\t\t#endregion\n\n\t\t#region IVsSolutionLoadEvents\n\n\t\t// IVsSolutionLoadEvents interface begin\n\t\tpublic int OnBeforeOpenSolution(string pszSolutionFilename)\n\t\t{\n\t\t\treturn VSConstants.S_OK;\n\t\t}\n", "\t\tpublic int OnBeforeBackgroundSolutionLoadBegins()\n\t\t{\n\t\t\treturn VSConstants.S_OK;\n\t\t}\n\n\t\tpublic int OnQueryBackgroundLoadProjectBatch(out bool pfShouldDelayLoadToNextIdle)\n\t\t{\n\t\t\tpfShouldDelayLoadToNextIdle = false;\n\n\t\t\treturn VSConstants.S_OK;\n\t\t}\n", "\t\tpublic int OnBeforeLoadProjectBatch(bool fIsBackgroundIdleBatch)\n\t\t{\n\t\t\treturn VSConstants.S_OK;\n\t\t}\n\n\t\tpublic int OnAfterLoadProjectBatch(bool fIsBackgroundIdleBatch)\n\t\t{\n\t\t\treturn VSConstants.S_OK;\n\t\t}\n\n\t\tpublic int OnAfterBackgroundSolutionLoadComplete()\n\t\t{\n\t\t\treturn VSConstants.S_OK;\n\t\t}", "\t\tpublic int OnAfterBackgroundSolutionLoadComplete()\n\t\t{\n\t\t\treturn VSConstants.S_OK;\n\t\t}\n\t\t// IVsSolutionLoadEvents interface end\n\n\t\t#endregion\n\n\t\t#region IOleCommandTarget\n\n\t\tint IOleCommandTarget.QueryStatus(ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)\n\t\t{\n\t\t\tThreadHelper.ThrowIfNotOnUIThread();\n", "\t\t\tif (pguidCmdGroup == GuidAndCmdID.guidCmdSet)\n\t\t\t{\n\t\t\t\tswitch (prgCmds[0].cmdID)\n\t\t\t\t{\n\t\t\t\t\tcase GuidAndCmdID.cmdidGenerateJsonFile:\n\t\t\t\t\t\tprgCmds[0].cmdf |= (uint)(OLECMDF.OLECMDF_SUPPORTED | OLECMDF.OLECMDF_ENABLED | OLECMDF.OLECMDF_INVISIBLE);\n\t\t\t\t\t\treturn VSConstants.S_OK;\n\t\t\t\t\tcase GuidAndCmdID.cmdidCopyToClipboard:\n\t\t\t\t\t\tprgCmds[0].cmdf |= (uint)(OLECMDF.OLECMDF_SUPPORTED | OLECMDF.OLECMDF_ENABLED | OLECMDF.OLECMDF_INVISIBLE);\n\t\t\t\t\t\treturn VSConstants.S_OK;\n\t\t\t\t\tcase GuidAndCmdID.cmdidOpenAssetPath:\n\t\t\t\t\t\tprgCmds[0].cmdf |= (uint)(OLECMDF.OLECMDF_SUPPORTED | OLECMDF.OLECMDF_ENABLED | OLECMDF.OLECMDF_INVISIBLE);\n\t\t\t\t\t\treturn VSConstants.S_OK;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.pkgCommandTarget.QueryStatus(ref pguidCmdGroup, cCmds, prgCmds, pCmdText);\n\t\t}\n\n\t\tint IOleCommandTarget.Exec(ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)\n\t\t{\n\t\t\tThreadHelper.ThrowIfNotOnUIThread();\n", "\t\t\tif (pguidCmdGroup == GuidAndCmdID.guidCmdSet)\n\t\t\t{\n\t\t\t\tswitch (nCmdID)\n\t\t\t\t{\n\t\t\t\t\tcase GuidAndCmdID.cmdidGenerateJsonFile:\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring message = \"\";\n\t\t\t\t\t\t\tstring title = \"\";\n", "\t\t\t\t\t\t\tif (RunExecutableThread != null && RunExecutableThread.IsAlive)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmessage = \"BlueprintInspector commandlet is already running.\\nWait until it finishes.\";\n\t\t\t\t\t\t\t\ttitle = \"WARNING!\";\n\n\t\t\t\t\t\t\t\tVsShellUtilities.ShowMessageBox(this as IServiceProvider, message, title, OLEMSGICON.OLEMSGICON_WARNING, OLEMSGBUTTON.OLEMSGBUTTON_OK, OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST);\n\n\t\t\t\t\t\t\t\treturn VSConstants.S_OK;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// search the solution for a C++ project that contains a file with \".uproject\" extension of the same name as the project...\n\t\t\t\t\t\t\tIVsSolution2 solution = ServiceProvider.GlobalProvider.GetService(typeof(SVsSolution)) as IVsSolution2;\n", "\t\t\t\t\t\t\tif (solution == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmessage = \"You must load an Unreal Engine solution file.\";\n\t\t\t\t\t\t\t\ttitle = \"WARNING!\";\n\n\t\t\t\t\t\t\t\tVsShellUtilities.ShowMessageBox(this as IServiceProvider, message, title, OLEMSGICON.OLEMSGICON_WARNING, OLEMSGBUTTON.OLEMSGBUTTON_OK, OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST);\n\n\t\t\t\t\t\t\t\treturn VSConstants.S_OK;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (solution != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsolution.GetSolutionInfo(out string solutionDirectory, out string solutionName, out string solutionDirectory2);", "\t\t\t\t\t\t\tif (solution != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsolution.GetSolutionInfo(out string solutionDirectory, out string solutionName, out string solutionDirectory2);\n\t\t\t\t\t\t\t\tif (solutionDirectory == null || solutionDirectory == \"\")\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmessage = \"You must load an Unreal Engine solution file.\";\n\t\t\t\t\t\t\t\t\ttitle = \"WARNING!\";\n\n\t\t\t\t\t\t\t\t\tVsShellUtilities.ShowMessageBox(this as IServiceProvider, message, title, OLEMSGICON.OLEMSGICON_WARNING, OLEMSGBUTTON.OLEMSGBUTTON_OK, OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST);\n\n\t\t\t\t\t\t\t\t\treturn VSConstants.S_OK;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tBlueprintInspectorGlobals.SolutionDirectory = solutionDirectory;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tIVsHierarchy solutionHierarchy = (IVsHierarchy)solution;\n\t\t\t\t\t\t\tIVsProject solutionProject = null;\n\n\t\t\t\t\t\t\tstring UnrealEditorTargetFile = \"\";  // looking for \"UnrealEditor.Target.cs\" to find path where Engine is installed\n\t\t\t\t\t\t\tbool bIsUE4Project = false;\n\n\t\t\t\t\t\t\tGetHierarchyInSolution(solutionHierarchy, VSConstants.VSITEMID_ROOT, ref solutionProject, \"Engine\", \"\", \"\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tout IVsHierarchy EngineHierarchy, out IVsProject EngineProject, out uint EngineItemId, out string Unused1);", "\t\t\t\t\t\t\tif ((EngineHierarchy != null) && (EngineProject != null))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tGetHierarchyInSolution(EngineHierarchy, VSConstants.VSITEMID_ROOT, ref EngineProject, \"UE5\", \"\", \"\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout IVsHierarchy UE5Hierarchy, out IVsProject UE5Project, out uint UE5ItemId, out string Unused2);\n\t\t\t\t\t\t\t\tif ((UE5Hierarchy != null) && (UE5Project != null))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tGetHierarchyInSolution(UE5Hierarchy, VSConstants.VSITEMID_ROOT, ref UE5Project, \"\", \"Source\", \"\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout IVsHierarchy SourceHierarchy, out IVsProject SourceProject, out uint SourceItemId, out string Unused3);\n\t\t\t\t\t\t\t\t\tif ((SourceHierarchy != null) && (SourceProject != null))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tGetHierarchyInSolution(SourceHierarchy, SourceItemId, ref SourceProject, \"\", \"\", \"UnrealEditor.Target.cs\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout IVsHierarchy UnusedHierarchy, out IVsProject UnusedProject, out uint UnusedItemId, out UnrealEditorTargetFile);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse  // if UE5 not found, then check if UE4...\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tGetHierarchyInSolution(EngineHierarchy, VSConstants.VSITEMID_ROOT, ref EngineProject, \"UE4\", \"\", \"\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout IVsHierarchy UE4Hierarchy, out IVsProject UE4Project, out uint UE4ItemId, out string Unused4);", "\t\t\t\t\t\t\t\t\tif ((SourceHierarchy != null) && (SourceProject != null))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tGetHierarchyInSolution(SourceHierarchy, SourceItemId, ref SourceProject, \"\", \"\", \"UnrealEditor.Target.cs\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout IVsHierarchy UnusedHierarchy, out IVsProject UnusedProject, out uint UnusedItemId, out UnrealEditorTargetFile);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse  // if UE5 not found, then check if UE4...\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tGetHierarchyInSolution(EngineHierarchy, VSConstants.VSITEMID_ROOT, ref EngineProject, \"UE4\", \"\", \"\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout IVsHierarchy UE4Hierarchy, out IVsProject UE4Project, out uint UE4ItemId, out string Unused4);\n\t\t\t\t\t\t\t\t\tif ((UE4Hierarchy != null) && (UE4Project != null))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tGetHierarchyInSolution(UE4Hierarchy, VSConstants.VSITEMID_ROOT, ref UE4Project, \"\", \"Source\", \"\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout IVsHierarchy SourceHierarchy, out IVsProject SourceProject, out uint SourceItemId, out string Unused3);", "\t\t\t\t\t\t\t\t\tif ((UE4Hierarchy != null) && (UE4Project != null))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tGetHierarchyInSolution(UE4Hierarchy, VSConstants.VSITEMID_ROOT, ref UE4Project, \"\", \"Source\", \"\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout IVsHierarchy SourceHierarchy, out IVsProject SourceProject, out uint SourceItemId, out string Unused3);\n\t\t\t\t\t\t\t\t\t\tif ((SourceHierarchy != null) && (SourceProject != null))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tGetHierarchyInSolution(SourceHierarchy, SourceItemId, ref SourceProject, \"\", \"\", \"UE4Editor.Target.cs\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout IVsHierarchy UnusedHierarchy, out IVsProject UnusedProject, out uint UnusedItemId, out UnrealEditorTargetFile);\n\n\t\t\t\t\t\t\t\t\t\t\tbIsUE4Project = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n", "\t\t\t\t\t\t\tif (UnrealEditorTargetFile == \"\")\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmessage = \"Can't determine which Unreal Engine version is being used.\";\n\t\t\t\t\t\t\t\ttitle = \"WARNING!\";\n\n\t\t\t\t\t\t\t\tVsShellUtilities.ShowMessageBox(this as IServiceProvider, message, title, OLEMSGICON.OLEMSGICON_WARNING, OLEMSGBUTTON.OLEMSGBUTTON_OK, OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST);\n\n\t\t\t\t\t\t\t\treturn VSConstants.S_OK;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tstring UnrealEditorTargetDirectory = Path.GetDirectoryName(UnrealEditorTargetFile);\n\t\t\t\t\t\t\tDirectoryInfo EngineDirectoryInfo = System.IO.Directory.GetParent(UnrealEditorTargetDirectory);\n\t\t\t\t\t\t\tBlueprintInspectorGlobals.EngineDirectory = EngineDirectoryInfo.FullName;  // without the trailing \"\\\\\"\n\n\t\t\t\t\t\t\tList<string> projectFilenames = new List<string>();\n\n\t\t\t\t            IEnumHierarchies enumerator = null;\n\t\t\t\t            Guid guid = Guid.Empty;\n\t\t\t\t            solution.GetProjectEnum((uint)__VSENUMPROJFLAGS.EPF_LOADEDINSOLUTION, ref guid, out enumerator);\n\n\t\t\t\t            IVsHierarchy[] hierarchy = new IVsHierarchy[1] { null };\n\t\t\t\t            uint fetched = 0;", "\t\t\t\t            for (enumerator.Reset(); enumerator.Next(1, hierarchy, out fetched) == VSConstants.S_OK && fetched == 1; /*nothing*/)\n\t\t\t\t            {\n\t\t\t\t                IVsProject Project = (IVsProject)hierarchy[0];\n\n\t\t\t\t\t\t\t\tGetProjectFilesInProject(hierarchy[0], VSConstants.VSITEMID_ROOT, ref Project, ref projectFilenames);\n\t\t\t\t            }\n\n\t\t\t\t\t\t\tif (projectFilenames.Count == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmessage = \"Can't find .uproject file in solution.  You must run the commandlet manually.\";\n\t\t\t\t\t\t\t\ttitle = \"ERROR!\";\n\n\t\t\t\t\t\t\t\tVsShellUtilities.ShowMessageBox(this as IServiceProvider, message, title, OLEMSGICON.OLEMSGICON_CRITICAL, OLEMSGBUTTON.OLEMSGBUTTON_OK, OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST);\n\n\t\t\t\t\t\t\t\treturn VSConstants.S_OK;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tstring projectName = \"\";\n\n\t\t\t\t\t\t\tSelectProjectForm form = new SelectProjectForm();\n\t\t\t\t\t\t\tform.ProjectFiles = projectFilenames;\n\n\t\t\t\t\t\t\tSystem.Windows.Forms.DialogResult result = form.ShowDialog();\n", "\t\t\t\t\t\t\tif (result != DialogResult.OK)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn VSConstants.S_OK;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbool bIncludeEngine = form.bIncludeEngine;\n\t\t\t\t\t\t\tbool bIncludePlugins = form.bIncludePlugins;\n\t\t\t\t\t\t\tbool bIncludeDevelopers = form.bIncludeDevelopers;\n\n\t\t\t\t\t\t\tBlueprintInspectorGlobals.ProjectFilename = projectFilenames[form.SelectedIndex];\n\n\t\t\t\t\t\t\tprojectName = Path.GetFileNameWithoutExtension(projectFilenames[form.SelectedIndex]);\n\n\t\t\t\t\t\t\t// we now have the Engine directory (for Engine\\Binaries\\Win64\\UnrealEditor.exe) and the project file name (*.uproject) so we can run the commandlet to generate the JSON file...", "\t\t\t\t\t\t\tif (OutputPaneGuid == Guid.Empty)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Create a new output pane.\n\t\t\t\t\t\t\t\tIVsOutputWindow output = GetGlobalService(typeof(SVsOutputWindow)) as IVsOutputWindow;\n\n\t\t\t\t\t\t\t\tOutputPaneGuid = Guid.NewGuid();\n\n\t\t\t\t\t\t\t\tbool visible = true;\n\t\t\t\t\t\t\t\tbool clearWithSolution = false;\n\t\t\t\t\t\t\t\toutput.CreatePane(ref OutputPaneGuid, \"Blueprint Inspector\", Convert.ToInt32(visible), Convert.ToInt32(clearWithSolution));\n\t\t\t\t\t\t\t\toutput.GetPane(ref OutputPaneGuid, out BlueprintInspectorGlobals.OutputPane);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// clear the output pane", "\t\t\t\t\t\t\t\tif (BlueprintInspectorGlobals.OutputPane != null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tBlueprintInspectorGlobals.OutputPane.Clear();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (BlueprintInspectorGlobals.OutputPane != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tBlueprintInspectorGlobals.OutputPane.Activate();\n\t\t\t\t\t\t\t\tBlueprintInspectorGlobals.OutputPane.OutputStringThreadSafe(\"Running BlueprintInspector commandlet now...\");\n\t\t\t\t\t\t\t\tBlueprintInspectorGlobals.OutputPane.OutputStringThreadSafe(\"\\n\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tRunExecutableThread = new System.Threading.Thread(new RunExecutable(bIsUE4Project, bIncludeEngine, bIncludePlugins, bIncludeDevelopers).Run);\n\t\t\t\t\t\t\tRunExecutableThread.Priority = ThreadPriority.Normal;\n\t\t\t\t\t\t\tRunExecutableThread.Start();  // start the thread running\n\t\t\t\t\t\t}", "\t\t\t\t\t\tcatch(Exception)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn VSConstants.S_OK;\n\n\t\t\t\t\tcase GuidAndCmdID.cmdidCopyToClipboard:\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (IsQueryParameterList(pvaIn, pvaOut, nCmdexecopt))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn VSConstants.S_OK;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\tif (IsQueryParameterList(pvaIn, pvaOut, nCmdexecopt))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn VSConstants.S_OK;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (pvaIn == IntPtr.Zero)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\treturn VSConstants.S_FALSE;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tobject vaInObject = Marshal.GetObjectForNativeVariant(pvaIn);", "\t\t\t\t\t\t\t\tif (vaInObject == null || vaInObject.GetType() != typeof(string))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\treturn VSConstants.E_INVALIDARG;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tstring AssetPathsString = (string)vaInObject;\n\t\t\t\t\t\t\t\tstring[] AssetPaths = AssetPathsString.Split(',');\n\n\t\t\t\t\t\t\t\tstring OutputString = \"\";\n\t\t\t\t\t\t\t\tforeach (string AssetPath in AssetPaths)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tOutputString += AssetPath + \"\\n\";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tClipboard.SetText(OutputString);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}", "\t\t\t\t\t\t\t\tforeach (string AssetPath in AssetPaths)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tOutputString += AssetPath + \"\\n\";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tClipboard.SetText(OutputString);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(Exception)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn VSConstants.S_OK;\n\n\t\t\t\t\tcase GuidAndCmdID.cmdidOpenAssetPath:\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{", "\t\t\t\t\t\tcatch(Exception)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn VSConstants.S_OK;\n\n\t\t\t\t\tcase GuidAndCmdID.cmdidOpenAssetPath:\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (IsQueryParameterList(pvaIn, pvaOut, nCmdexecopt))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn VSConstants.S_OK;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{", "\t\t\t\t\t\t\tif (IsQueryParameterList(pvaIn, pvaOut, nCmdexecopt))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\treturn VSConstants.S_OK;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (pvaIn == IntPtr.Zero)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\treturn VSConstants.S_FALSE;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tobject vaInObject = Marshal.GetObjectForNativeVariant(pvaIn);", "\t\t\t\t\t\t\t\tif (vaInObject == null || vaInObject.GetType() != typeof(string))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\treturn VSConstants.E_INVALIDARG;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tstring AssetPathsString = (string)vaInObject;\n\n\t\t\t\t\t\t\t\tlock (BlueprintInspectorGlobals.BlueprintAssetPathLock)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tBlueprintInspectorGlobals.BlueprintAssetPathToSend.Add(AssetPathsString);\n\t\t\t\t\t\t\t\t\tBlueprintInspectorGlobals.bHasBlueprintAssetPathToSend = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}", "\t\t\t\t\t\tcatch(Exception)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn VSConstants.S_OK;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this.pkgCommandTarget.Exec(ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);\n\t\t}\n\n\t\t#endregion\n", "\t\tprivate static bool IsQueryParameterList(IntPtr pvaIn, IntPtr pvaOut, uint nCmdexecopt)\n\t\t{\n\t\t\tushort lo = (ushort)(nCmdexecopt & (uint)0xffff);\n\t\t\tushort hi = (ushort)(nCmdexecopt >> 16);\n\t\t\tif (lo == (ushort)OLECMDEXECOPT.OLECMDEXECOPT_SHOWHELP)\n\t\t\t{\n\t\t\t\tif (hi == VsMenus.VSCmdOptQueryParameterList)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n", "\t\tprivate void GetProjectFilesInProject(IVsHierarchy hierarchy, uint itemId, ref IVsProject Project, ref List<string> projectFilenames)\n\t\t{\n\t\t\tThreadHelper.ThrowIfNotOnUIThread();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// NOTE: If itemId == VSConstants.VSITEMID_ROOT then this hierarchy is a solution, project, or folder in the Solution Explorer\n\n\t\t\t\tif (hierarchy == null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tobject ChildObject = null;\n\n\t\t\t\t// Get the first visible child node", "\t\t\t\tif (hierarchy == null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tobject ChildObject = null;\n\n\t\t\t\t// Get the first visible child node\n\t\t\t\tif (hierarchy.GetProperty(itemId, (int)__VSHPROPID.VSHPROPID_FirstVisibleChild, out ChildObject) == VSConstants.S_OK)\n\t\t\t\t{\n\t\t\t\t\twhile (ChildObject != null)\n\t\t\t\t\t{", "\t\t\t\tif (hierarchy.GetProperty(itemId, (int)__VSHPROPID.VSHPROPID_FirstVisibleChild, out ChildObject) == VSConstants.S_OK)\n\t\t\t\t{\n\t\t\t\t\twhile (ChildObject != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((ChildObject is int) && ((uint)(int)ChildObject == VSConstants.VSITEMID_NIL))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuint visibleChildNodeId = Convert.ToUInt32(ChildObject);\n\n\t\t\t\t\t\tstring projectFilename = \"\";\n\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{", "\t\t\t\t\t\t\tif (Project.GetMkDocument(visibleChildNodeId, out projectFilename) == VSConstants.S_OK)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif ((projectFilename != null) && (projectFilename.Length > 0) &&\n\t\t\t\t\t\t\t\t\t(!projectFilename.EndsWith(\"\\\\\")) &&  // some invalid \"filenames\" will end with '\\\\'\n\t\t\t\t\t\t\t\t\t(projectFilename.IndexOfAny(InvalidChars) == -1) &&\n\t\t\t\t\t\t\t\t\t(projectFilename.IndexOf(\":\", StringComparison.OrdinalIgnoreCase) == 1))  // make sure filename is of the form: drive letter followed by colon\n\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\tif (projectFilename.EndsWith(\".uproject\"))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tprojectFilenames.Add(projectFilename);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}", "\t\t\t\t\t\t\t\t\tif (projectFilename.EndsWith(\".uproject\"))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tprojectFilenames.Add(projectFilename);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tChildObject = null;\n\n\t\t\t\t\t\t// Get the next visible sibling node", "\t\t\t\t\t\tif (hierarchy.GetProperty(visibleChildNodeId, (int)__VSHPROPID.VSHPROPID_NextVisibleSibling, out ChildObject) != VSConstants.S_OK)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\t\t}\n\n\t\t// searches the solution for a specific project name, folder name, or file name", "\t\tprivate void GetHierarchyInSolution(IVsHierarchy hierarchy, uint itemId, ref IVsProject Project, string SearchProject, string SearchFolder, string SearchFileName, out IVsHierarchy OutHierarchy, out IVsProject OutProject, out uint OutItemId, out string OutFilename)\n\t\t{\n\t\t\tThreadHelper.ThrowIfNotOnUIThread();\n\n\t\t\tOutHierarchy = null;\n\t\t\tOutProject = null;\n\t\t\tOutItemId = VSConstants.VSITEMID_ROOT;\n\t\t\tOutFilename = \"\";\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// NOTE: If itemId == VSConstants.VSITEMID_ROOT then this hierarchy is a solution, project, or folder in the Solution Explorer\n", "\t\t\t\tif (hierarchy == null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tobject ChildObject = null;\n\n\t\t\t\t// Get the first visible child node\n\t\t\t\tif (hierarchy.GetProperty(itemId, (int)__VSHPROPID.VSHPROPID_FirstVisibleChild, out ChildObject) == VSConstants.S_OK)\n\t\t\t\t{\n\t\t\t\t\twhile (ChildObject != null)\n\t\t\t\t\t{", "\t\t\t\tif (hierarchy.GetProperty(itemId, (int)__VSHPROPID.VSHPROPID_FirstVisibleChild, out ChildObject) == VSConstants.S_OK)\n\t\t\t\t{\n\t\t\t\t\twhile (ChildObject != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ((ChildObject is int) && ((uint)(int)ChildObject == VSConstants.VSITEMID_NIL))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuint visibleChildNodeId = Convert.ToUInt32(ChildObject);\n\n\t\t\t\t\t\tobject nameObject = null;\n", "\t\t\t\t\t\tif ((hierarchy.GetProperty(visibleChildNodeId, (int)__VSHPROPID.VSHPROPID_Name, out nameObject) == VSConstants.S_OK) && (nameObject != null))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ((string)nameObject == SearchProject)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tGuid nestedHierarchyGuid = typeof(IVsHierarchy).GUID;\n\t\t\t\t\t\t\t\tIntPtr nestedHiearchyValue = IntPtr.Zero;\n\t\t\t\t\t\t\t\tuint nestedItemIdValue = 0;\n\n\t\t\t\t\t\t\t\t// see if the child node has a nested hierarchy (i.e. is it a project?, is it a folder?, etc.)...\n\t\t\t\t\t\t\t\tif ((hierarchy.GetNestedHierarchy(visibleChildNodeId, ref nestedHierarchyGuid, out nestedHiearchyValue, out nestedItemIdValue) == VSConstants.S_OK) &&\n\t\t\t\t\t\t\t\t\t(nestedHiearchyValue != IntPtr.Zero && nestedItemIdValue == VSConstants.VSITEMID_ROOT))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Get the new hierarchy\n\t\t\t\t\t\t\t\t\tIVsHierarchy nestedHierarchy = System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(nestedHiearchyValue) as IVsHierarchy;\n\t\t\t\t\t\t\t\t\tSystem.Runtime.InteropServices.Marshal.Release(nestedHiearchyValue);\n", "\t\t\t\t\t\t\t\tif ((hierarchy.GetNestedHierarchy(visibleChildNodeId, ref nestedHierarchyGuid, out nestedHiearchyValue, out nestedItemIdValue) == VSConstants.S_OK) &&\n\t\t\t\t\t\t\t\t\t(nestedHiearchyValue != IntPtr.Zero && nestedItemIdValue == VSConstants.VSITEMID_ROOT))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Get the new hierarchy\n\t\t\t\t\t\t\t\t\tIVsHierarchy nestedHierarchy = System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(nestedHiearchyValue) as IVsHierarchy;\n\t\t\t\t\t\t\t\t\tSystem.Runtime.InteropServices.Marshal.Release(nestedHiearchyValue);\n\n\t\t\t\t\t\t\t\t\tif (nestedHierarchy != null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tOutHierarchy = nestedHierarchy;\n\t\t\t\t\t\t\t\t\t\tOutProject = (IVsProject)nestedHierarchy;\n\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tobject NodeChildObject = null;\n\n\t\t\t\t\t\t\t\t// see if this regular node has children...", "\t\t\t\t\t\t\t\tif ((string)nameObject == SearchFolder)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (hierarchy.GetProperty(visibleChildNodeId, (int)__VSHPROPID.VSHPROPID_FirstVisibleChild, out NodeChildObject) == VSConstants.S_OK)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (NodeChildObject != null)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif ((NodeChildObject is int) && ((uint)(int)NodeChildObject != VSConstants.VSITEMID_NIL))\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tOutHierarchy = hierarchy;\n\t\t\t\t\t\t\t\t\t\t\t\tOutProject = Project;\n\t\t\t\t\t\t\t\t\t\t\t\tOutItemId = visibleChildNodeId;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n", "\t\t\t\t\t\t\t\tif ((string)nameObject == SearchFileName)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tstring projectFilename = \"\";\n\n\t\t\t\t\t\t\t\t\t\tif (Project.GetMkDocument(visibleChildNodeId, out projectFilename) == VSConstants.S_OK)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif ((projectFilename != null) && (projectFilename.Length > 0) &&\n\t\t\t\t\t\t\t\t\t\t\t\t(!projectFilename.EndsWith(\"\\\\\")) &&  // some invalid \"filenames\" will end with '\\\\'\n\t\t\t\t\t\t\t\t\t\t\t\t(projectFilename.IndexOfAny(InvalidChars) == -1) &&\n\t\t\t\t\t\t\t\t\t\t\t\t(projectFilename.IndexOf(\":\", StringComparison.OrdinalIgnoreCase) == 1))  // make sure filename is of the form: drive letter followed by colon\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tOutFilename = projectFilename;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}", "\t\t\t\t\t\t\t\t\t\t\tif ((projectFilename != null) && (projectFilename.Length > 0) &&\n\t\t\t\t\t\t\t\t\t\t\t\t(!projectFilename.EndsWith(\"\\\\\")) &&  // some invalid \"filenames\" will end with '\\\\'\n\t\t\t\t\t\t\t\t\t\t\t\t(projectFilename.IndexOfAny(InvalidChars) == -1) &&\n\t\t\t\t\t\t\t\t\t\t\t\t(projectFilename.IndexOf(\":\", StringComparison.OrdinalIgnoreCase) == 1))  // make sure filename is of the form: drive letter followed by colon\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tOutFilename = projectFilename;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcatch (Exception)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tChildObject = null;\n\n\t\t\t\t\t\t// Get the next visible sibling node", "\t\t\t\t\t\t\t\t\tcatch (Exception)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tChildObject = null;\n\n\t\t\t\t\t\t// Get the next visible sibling node\n\t\t\t\t\t\tif (hierarchy.GetProperty(visibleChildNodeId, (int)__VSHPROPID.VSHPROPID_NextVisibleSibling, out ChildObject) != VSConstants.S_OK)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}", "\t\t\t\t\t\tif (hierarchy.GetProperty(visibleChildNodeId, (int)__VSHPROPID.VSHPROPID_NextVisibleSibling, out ChildObject) != VSConstants.S_OK)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception)\n\t\t\t{\n\t\t\t}\n\t\t}\n\t}\n}\n"]}
{"filename": "VisualStudioExtension/Properties/Settings.Designer.cs", "chunked_list": ["\ufeff//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a tool.\n//     Runtime Version:4.0.30319.42000\n//\n//     Changes to this file may cause incorrect behavior and will be lost if\n//     the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n", "//------------------------------------------------------------------------------\n\nnamespace BlueprintInspector.Properties {\n    \n    \n    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]\n    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator\", \"17.4.0.0\")]\n    public sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {\n        \n        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));\n        ", "        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));\n        \n        public static Settings Default {\n            get {\n                return defaultInstance;\n            }\n        }\n        \n        [global::System.Configuration.UserScopedSettingAttribute()]\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]\n        [global::System.Configuration.DefaultSettingValueAttribute(\"True\")]", "        public bool IncludeEngine {\n            get {\n                return ((bool)(this[\"IncludeEngine\"]));\n            }\n            set {\n                this[\"IncludeEngine\"] = value;\n            }\n        }\n        \n        [global::System.Configuration.UserScopedSettingAttribute()]\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]\n        [global::System.Configuration.DefaultSettingValueAttribute(\"True\")]", "        public bool IncludePlugins {\n            get {\n                return ((bool)(this[\"IncludePlugins\"]));\n            }\n            set {\n                this[\"IncludePlugins\"] = value;\n            }\n        }\n        \n        [global::System.Configuration.UserScopedSettingAttribute()]\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]\n        [global::System.Configuration.DefaultSettingValueAttribute(\"True\")]", "        public bool IncludeDevelopers {\n            get {\n                return ((bool)(this[\"IncludeDevelopers\"]));\n            }\n            set {\n                this[\"IncludeDevelopers\"] = value;\n            }\n        }\n    }\n}\n"]}
{"filename": "VisualStudioExtension/Properties/AssemblyInfo.cs", "chunked_list": ["\ufeffusing System.Reflection;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n\n// General Information about an assembly is controlled through the following \n// set of attributes. Change these attribute values to modify the information\n// associated with an assembly.\n[assembly: AssemblyTitle(\"BlueprintInspector\")]\n[assembly: AssemblyDescription(\"\")]\n[assembly: AssemblyConfiguration(\"\")]", "[assembly: AssemblyDescription(\"\")]\n[assembly: AssemblyConfiguration(\"\")]\n[assembly: AssemblyCompany(\"\")]\n[assembly: AssemblyProduct(\"BlueprintInspector\")]\n[assembly: AssemblyCopyright(\"\")]\n[assembly: AssemblyTrademark(\"\")]\n[assembly: AssemblyCulture(\"\")]\n\n// Setting ComVisible to false makes the types in this assembly not visible \n// to COM components.  If you need to access a type in this assembly from ", "// Setting ComVisible to false makes the types in this assembly not visible \n// to COM components.  If you need to access a type in this assembly from \n// COM, set the ComVisible attribute to true on that type.\n[assembly: ComVisible(false)]\n\n// Version information for an assembly consists of the following four values:\n//\n//      Major Version\n//      Minor Version \n//      Build Number", "//      Minor Version \n//      Build Number\n//      Revision\n//\n// You can specify all the values or you can default the Build and Revision Numbers \n// by using the '*' as shown below:\n// [assembly: AssemblyVersion(\"1.0.*\")]\n[assembly: AssemblyVersion(\"1.0.0.0\")]\n[assembly: AssemblyFileVersion(\"1.0.0.0\")]\n", "[assembly: AssemblyFileVersion(\"1.0.0.0\")]\n"]}
{"filename": "VisualStudioExtension/SharedProject/BlueprintJson.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nnamespace SharedProject\n{\n\tinternal class BlueprintAsset\n\t{\n\t\tpublic string blueprintasset { get; set; } = null;\n", "\t\tpublic string blueprintasset { get; set; } = null;\n\n\t\tpublic int Deserialize(ref MemoryStream memorystream)  // returns the last character read from the stream\n\t\t{\n\t\t\tint somechar = -1;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n", "\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (somechar == ']')  // end of an empty array?\n\t\t\t\t{\n\t\t\t\t\treturn somechar;\n\t\t\t\t}\n\n\t\t\t\tif (somechar != '{')\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tstring token = SharedGlobals.ReadToken(ref memorystream);\n", "\t\t\t\tif (somechar != '{')\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tstring token = SharedGlobals.ReadToken(ref memorystream);\n\n\t\t\t\tif (token != \"bpasset\")\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tstring Value = SharedGlobals.ReadValue(ref memorystream);\n", "\t\t\t\tif (Value == \"\")\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tblueprintasset = Value;\n\n\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n", "\t\t\t\tif (somechar != '}')\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\n\t\t\treturn somechar;  // should be '}'\n\t\t}\n\t}\n", "\tinternal class BlueprintAssetIndex\n\t{\n\t\tpublic int blueprintassetindex { get; set; } = -1;\n\t\tpublic int count { get; set; } = 0;\n\n\t\tpublic int Deserialize(ref MemoryStream memorystream)  // returns the last character read from the stream\n\t\t{\n\t\t\tint somechar = -1;\n\n\t\t\ttry\n\t\t\t{", "\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (somechar == ']')  // end of an empty array?\n\t\t\t\t{\n\t\t\t\t\treturn somechar;\n\t\t\t\t}\n\n\t\t\t\tif (somechar != '{')\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tstring token = SharedGlobals.ReadToken(ref memorystream);\n", "\t\t\t\tif (somechar != '{')\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tstring token = SharedGlobals.ReadToken(ref memorystream);\n\n\t\t\t\tif (token != \"bpasset\")\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tstring Value = SharedGlobals.ReadValue(ref memorystream);\n", "\t\t\t\tif (Value == \"\")\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tblueprintassetindex = int.Parse(Value);\n\n\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n", "\t\t\t\tif (somechar != ',')\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\ttoken = SharedGlobals.ReadToken(ref memorystream);\n\n\t\t\t\tif (token != \"count\")\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tValue = SharedGlobals.ReadValue(ref memorystream);\n", "\t\t\t\tif (Value == \"\")\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tcount = int.Parse(Value);\n\n\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n", "\t\t\t\tif (somechar != '}')\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\n\t\t\treturn somechar;  // should be '}'\n\t\t}\n\t}\n", "\tinternal class BlueprintFunction\n\t{\n\t\tpublic string functionname { get; set; } = null;\n\t\tpublic List<BlueprintAssetIndex> blueprintassetindexes { get; set; } = null;\n\n\t\tpublic int Deserialize(ref MemoryStream memorystream)  // returns the last character read from the stream\n\t\t{\n\t\t\tint somechar = -1;\n\n\t\t\ttry\n\t\t\t{", "\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (somechar == ']')  // end of an empty array?\n\t\t\t\t{\n\t\t\t\t\treturn somechar;\n\t\t\t\t}\n\n\t\t\t\tif (somechar != '{')\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tstring token = SharedGlobals.ReadToken(ref memorystream);\n", "\t\t\t\tif (somechar != '{')\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tstring token = SharedGlobals.ReadToken(ref memorystream);\n\n\t\t\t\tif (token != \"func\")\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tstring Value = SharedGlobals.ReadValue(ref memorystream);\n", "\t\t\t\tif (Value == \"\")\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfunctionname = Value;\n\n\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n", "\t\t\t\tif (somechar != ',')\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\ttoken = SharedGlobals.ReadToken(ref memorystream);\n\n\t\t\t\tif (token != \"bps\")\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n", "\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (somechar != '[')  // look for the start of the array\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tblueprintassetindexes = new List<BlueprintAssetIndex>();\n\n\t\t\t\t// loop through each function here and add it to the List\n\t\t\t\tBlueprintAssetIndex someblueprintassetindex = new BlueprintAssetIndex();\n\t\t\t\tsomechar = someblueprintassetindex.Deserialize(ref memorystream);\n", "\t\t\t\tif (somechar == -1)\n\t\t\t\t{\n\t\t\t\t}\n\n\t\t\t\twhile ((somechar != -1) && (somechar != ']'))  // loop until end of buffer or until end of array\n\t\t\t\t{\n\t\t\t\t\tblueprintassetindexes.Add(someblueprintassetindex);\n\n\t\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}", "\t\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (somechar != ',')\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tsomeblueprintassetindex = new BlueprintAssetIndex();\n\t\t\t\t\tsomechar = someblueprintassetindex.Deserialize(ref memorystream);\n\t\t\t\t}\n", "\t\t\t\tif (somechar != ']')  // look for the end of the array\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (somechar != '}')\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}", "\t\t\t\tif (somechar != '}')\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\n\t\t\treturn somechar;  // should be '}'\n\t\t}\n\t}\n", "\tinternal class UnrealClass\n\t{\n\t\tpublic string classname { get; set; }\n\t\tpublic List<BlueprintFunction> functions { get; set; }\n\t\tpublic Dictionary<string, int> FunctionNameToIndex = null;\n\n\t\tpublic int Deserialize(ref MemoryStream memorystream)  // returns the last character read from the stream\n\t\t{\n\t\t\tint somechar = -1;\n\n\t\t\ttry\n\t\t\t{", "\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (somechar != '{')\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tstring token = SharedGlobals.ReadToken(ref memorystream);\n", "\t\t\t\tif (token != \"class\")\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tstring Value = SharedGlobals.ReadValue(ref memorystream);\n\n\t\t\t\tif (Value == \"\")\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tclassname = Value;\n", "\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (somechar != ',')\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\ttoken = SharedGlobals.ReadToken(ref memorystream);\n", "\t\t\t\tif (token != \"functions\")\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (somechar != '[')  // look for the start of the array\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfunctions = new List<BlueprintFunction>();\n\n\t\t\t\t// loop through each function here and add it to the List\n\t\t\t\tBlueprintFunction somefunction = new BlueprintFunction();\n\t\t\t\tsomechar = somefunction.Deserialize(ref memorystream);\n", "\t\t\t\tif (somechar != '[')  // look for the start of the array\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tfunctions = new List<BlueprintFunction>();\n\n\t\t\t\t// loop through each function here and add it to the List\n\t\t\t\tBlueprintFunction somefunction = new BlueprintFunction();\n\t\t\t\tsomechar = somefunction.Deserialize(ref memorystream);\n", "\t\t\t\twhile ((somechar != -1) && (somechar != ']'))  // loop until end of buffer or until end of array\n\t\t\t\t{\n\t\t\t\t\tfunctions.Add(somefunction);\n\n\t\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (somechar != ',')\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tsomefunction = new BlueprintFunction();\n\t\t\t\t\tsomechar = somefunction.Deserialize(ref memorystream);\n\t\t\t\t}\n", "\t\t\t\t\tif (somechar != ',')\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tsomefunction = new BlueprintFunction();\n\t\t\t\t\tsomechar = somefunction.Deserialize(ref memorystream);\n\t\t\t\t}\n\n\t\t\t\tif (somechar != ']')  // look for the end of the array\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n", "\t\t\t\tif (somechar != ']')  // look for the end of the array\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (somechar != '}')\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}", "\t\t\t\tif (somechar != '}')\n\t\t\t\t{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\n\t\t\t// build the dictionary for quick lookup of function name\n\t\t\tFunctionNameToIndex = new Dictionary<string, int>();", "\t\t\tfor (int index = 0; index < functions.Count; ++index)\n\t\t\t{\n\t\t\t\tFunctionNameToIndex.Add(functions[index].functionname, index);\n\t\t\t}\n\n\t\t\treturn somechar;\n\t\t}\n\t}\n\n\tinternal class BlueprintJson\n\t{\n\t\tprivate List<BlueprintAsset> blueprintassets { get; set; } = null;\n", "\tinternal class BlueprintJson\n\t{\n\t\tprivate List<BlueprintAsset> blueprintassets { get; set; } = null;\n\n\t\tprivate Int32 Version;\n\n\t\tpublic List<UnrealClass> classes { get; set; } = null;\n\t\tprivate Dictionary<string, int> ClassNameToIndex = null;\n\n\t\tpublic BlueprintJson()\n\t\t{\n\t\t}\n", "\t\tpublic void ReadBlueprintJson(string filename)\n\t\t{\n\t\t\tif (File.Exists(filename))\n\t\t\t{\n\t\t\t\tbyte[] jsonfile = File.ReadAllBytes(filename);\n\n\t\t\t\tMemoryStream memorystream = new MemoryStream(jsonfile);\n\t\t\t\t{\n\t\t\t\t\tDeserialize(ref memorystream);\n\t\t\t\t}\n\t\t\t\tmemorystream.Dispose();\n\t\t\t}\n\t\t}\n", "\t\tpublic bool Deserialize(ref MemoryStream memorystream)  // returns bool indicating success status\n\t\t{\n\t\t\tint somechar = -1;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n", "\t\t\t\tif (somechar != '{')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// read the json version number...\n\t\t\t\tstring token = SharedGlobals.ReadToken(ref memorystream);\n\n\t\t\t\tif (token != \"version\")\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n", "\t\t\t\tif (token != \"version\")\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (somechar != '{')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\ttoken = SharedGlobals.ReadToken(ref memorystream);\n", "\t\t\t\tif (somechar != '{')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\ttoken = SharedGlobals.ReadToken(ref memorystream);\n\n\t\t\t\tif (token != \"version\")\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tstring Value = SharedGlobals.ReadValue(ref memorystream);\n", "\t\t\t\tif (Value == \"\")\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tVersion = int.Parse(Value);\n\n\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n", "\t\t\t\tif (somechar != '}')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (somechar != ',')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\ttoken = SharedGlobals.ReadToken(ref memorystream);\n", "\t\t\t\tif (somechar != ',')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\ttoken = SharedGlobals.ReadToken(ref memorystream);\n\n\t\t\t\tif (token != \"blueprints\")\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n", "\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (somechar != '[')  // look for the start of the array\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tblueprintassets = new List<BlueprintAsset>();\n\n\t\t\t\t// loop through each blueprintasset here and add it to the List\n\t\t\t\tBlueprintAsset someblueprintasset = new BlueprintAsset();\n\t\t\t\tsomechar = someblueprintasset.Deserialize(ref memorystream);\n", "\t\t\t\twhile ((somechar != -1) && (somechar != ']'))  // loop until end of buffer or until end of array\n\t\t\t\t{\n\t\t\t\t\tblueprintassets.Add(someblueprintasset);\n\n\t\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (somechar != ',')\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tsomeblueprintasset = new BlueprintAsset();\n\t\t\t\t\tsomechar = someblueprintasset.Deserialize(ref memorystream);\n\t\t\t\t}\n", "\t\t\t\t\tif (somechar != ',')\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tsomeblueprintasset = new BlueprintAsset();\n\t\t\t\t\tsomechar = someblueprintasset.Deserialize(ref memorystream);\n\t\t\t\t}\n\n\t\t\t\tif (somechar != ']')  // look for the end of the array\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n", "\t\t\t\tif (somechar != ']')  // look for the end of the array\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (somechar != ',')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\ttoken = SharedGlobals.ReadToken(ref memorystream);\n", "\t\t\t\tif (somechar != ',')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\ttoken = SharedGlobals.ReadToken(ref memorystream);\n\n\t\t\t\tif (token != \"classes\")\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n", "\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (somechar != '[')  // look for the start of the array\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tclasses = new List<UnrealClass>();\n", "\t\t\t\t// loop through each class here and add it to the List\n\t\t\t\tUnrealClass someclass = new UnrealClass();\n\t\t\t\tsomechar = someclass.Deserialize(ref memorystream);\n\n\t\t\t\twhile ((somechar != -1) && (somechar != ']'))  // loop until end of buffer or until end of array\n\t\t\t\t{\n\t\t\t\t\tclasses.Add(someclass);\n\n\t\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}", "\t\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (somechar != ',')\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tsomeclass = new UnrealClass();\n\t\t\t\t\tsomechar = someclass.Deserialize(ref memorystream);\n\t\t\t\t}\n", "\t\t\t\tif (somechar != ']')  // look for the end of the array\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif ((somechar = SharedGlobals.ReadCharSkipWhitespace(ref memorystream)) == -1)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (somechar != '}')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}", "\t\t\t\tif (somechar != '}')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\n\t\t\t// build the dictionary for quick lookup of class name\n\t\t\tClassNameToIndex = new Dictionary<string, int>();", "\t\t\t// build the dictionary for quick lookup of class name\n\t\t\tClassNameToIndex = new Dictionary<string, int>();\n\t\t\tfor (int index = 0; index < classes.Count; ++index)\n\t\t\t{\n\t\t\t\tClassNameToIndex.Add(classes[index].classname, index);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic int GetClassIndex(string class_name)\n\t\t{", "\t\tpublic int GetClassIndex(string class_name)\n\t\t{\n\t\t\tif (class_name == null)\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tstring class_name_lower = class_name.ToLower();\n\n\t\t\tint classname_index = -1;\n\t\t\tif (ClassNameToIndex != null && ClassNameToIndex.TryGetValue(class_name_lower, out classname_index))\n\t\t\t{\n\t\t\t\treturn classname_index;\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t}\n", "\t\t\tif (ClassNameToIndex != null && ClassNameToIndex.TryGetValue(class_name_lower, out classname_index))\n\t\t\t{\n\t\t\t\treturn classname_index;\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t}\n\n\t\tpublic int GetFunctionIndex(int class_index, string function_name)\n\t\t{\n\t\t\tif (function_name == null)\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tstring function_name_lower = function_name.ToLower();\n", "\t\tpublic int GetFunctionIndex(int class_index, string function_name)\n\t\t{\n\t\t\tif (function_name == null)\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tstring function_name_lower = function_name.ToLower();\n\n\t\t\tif (class_index < classes.Count && classes[class_index].FunctionNameToIndex != null)\n\t\t\t{\n\t\t\t\tint function_name_index = -1;", "\t\t\tif (class_index < classes.Count && classes[class_index].FunctionNameToIndex != null)\n\t\t\t{\n\t\t\t\tint function_name_index = -1;\n\t\t\t\tif (classes[class_index].FunctionNameToIndex.TryGetValue(function_name_lower, out function_name_index))\n\t\t\t\t{\n\t\t\t\t\treturn function_name_index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t}\n\n\t\tpublic List<string> GetBlueprintAssetPaths(int class_index, int function_index)\n\t\t{\n\t\t\tList<string> list = new List<string>();\n", "\t\t\tif (classes == null)\n\t\t\t{\n\t\t\t\treturn list;\n\t\t\t}\n\n\t\t\tif (class_index < classes.Count)\n\t\t\t{\n\t\t\t\tif (classes[class_index].functions == null)\n\t\t\t\t{\n\t\t\t\t\treturn list;\n\t\t\t\t}\n", "\t\t\t\tif (function_index < classes[class_index].functions.Count)\n\t\t\t\t{\n\t\t\t\t\tif (classes[class_index].functions[function_index].blueprintassetindexes == null)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn list;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int index = 0; index < classes[class_index].functions[function_index].blueprintassetindexes.Count; ++index)\n\t\t\t\t\t{\n\t\t\t\t\t\tint asset_index = classes[class_index].functions[function_index].blueprintassetindexes[index].blueprintassetindex;\n\t\t\t\t\t\tif (blueprintassets != null && asset_index < blueprintassets.Count())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring path = String.Format(\"{0} ({1})\", blueprintassets[asset_index].blueprintasset, classes[class_index].functions[function_index].blueprintassetindexes[index].count);\n\t\t\t\t\t\t\tlist.Add(path);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlist.Sort();\n\n\t\t\treturn list;\n\t\t}\n", "\t\t\t\t\t\tif (blueprintassets != null && asset_index < blueprintassets.Count())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring path = String.Format(\"{0} ({1})\", blueprintassets[asset_index].blueprintasset, classes[class_index].functions[function_index].blueprintassetindexes[index].count);\n\t\t\t\t\t\t\tlist.Add(path);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlist.Sort();\n\n\t\t\treturn list;\n\t\t}\n", "\t\tpublic bool Compare(BlueprintJson otherBlueprintJson)\n\t\t{\n\t\t\tif (classes.Count != otherBlueprintJson.classes.Count)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (int class_index = 0; class_index < classes.Count; ++class_index)\n\t\t\t{\n\t\t\t\t// classes are sorted so these should match if the code is unchanged\n\t\t\t\tif (classes[class_index].classname != otherBlueprintJson.classes[class_index].classname)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n", "\t\t\t\tif (classes[class_index].classname != otherBlueprintJson.classes[class_index].classname)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (classes[class_index].functions.Count != otherBlueprintJson.classes[class_index].functions.Count)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tfor (int function_index = 0; function_index < classes[class_index].functions.Count; ++function_index)\n\t\t\t\t{", "\t\t\t\tfor (int function_index = 0; function_index < classes[class_index].functions.Count; ++function_index)\n\t\t\t\t{\n\t\t\t\t\tif (classes[class_index].functions[function_index].functionname != otherBlueprintJson.classes[class_index].functions[function_index].functionname)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t}\n}\n"]}
{"filename": "VisualStudioExtension/SharedProject/SharedGlobals.cs", "chunked_list": ["\ufeffusing System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Threading;\n\nnamespace SharedProject\n{\n\tinternal class SharedGlobals\n\t{\n#if OutputDebugString", "\tinternal class SharedGlobals\n\t{\n#if OutputDebugString\n\t\tpublic static Mutex debug_mutex = null;  // for debugging output file\n\t\tprivate static bool BPCLFile_EnvChecked = false;\n\t\tprivate static string BPCLFile = \"\";\n#endif\n\n\t\tpublic static int ReadCharSkipWhitespace(ref MemoryStream memorystream)\n\t\t{\n\t\t\tint somechar = memorystream.ReadByte();\n", "\t\tpublic static int ReadCharSkipWhitespace(ref MemoryStream memorystream)\n\t\t{\n\t\t\tint somechar = memorystream.ReadByte();\n\n\t\t\twhile(Char.IsWhiteSpace((char)somechar))  // skip whitespace\n\t\t\t{\n\t\t\t\tsomechar = memorystream.ReadByte();\n\t\t\t}\n\n\t\t\treturn somechar;\n\t\t}\n", "\t\tpublic static string ReadValue(ref MemoryStream memorystream)  // note: this does NOT read any trailing ',' character\n\t\t{\n\t\t\tint somechar = memorystream.ReadByte();\n\n\t\t\tif (somechar == -1)\n\t\t\t{\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\twhile(Char.IsWhiteSpace((char)somechar))  // skip whitespace\n\t\t\t{\n\t\t\t\tsomechar = memorystream.ReadByte();\n\t\t\t}\n", "\t\t\twhile(Char.IsWhiteSpace((char)somechar))  // skip whitespace\n\t\t\t{\n\t\t\t\tsomechar = memorystream.ReadByte();\n\t\t\t}\n\n\t\t\tif (somechar != '\"')  // first character of value string should be \"\n\t\t\t{\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\tstring value = \"\";\n\n\t\t\tsomechar = memorystream.ReadByte();\n", "\t\t\twhile ((somechar != -1) && (somechar != '\"'))  // read until second double quote adding char to token\n\t\t\t{\n\t\t\t\tvalue += (char)somechar;\n\t\t\t\tsomechar = memorystream.ReadByte();\n\t\t\t}\n\n\t\t\tif (somechar == -1)\n\t\t\t{\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n", "\t\tpublic static string ReadToken(ref MemoryStream memorystream)\n\t\t{\n\t\t\tint somechar = memorystream.ReadByte();\n\n\t\t\tif (somechar == -1)\n\t\t\t{\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\twhile(Char.IsWhiteSpace((char)somechar))  // skip whitespace\n\t\t\t{\n\t\t\t\tsomechar = memorystream.ReadByte();\n\t\t\t}\n", "\t\t\twhile(Char.IsWhiteSpace((char)somechar))  // skip whitespace\n\t\t\t{\n\t\t\t\tsomechar = memorystream.ReadByte();\n\t\t\t}\n\n\t\t\tif (somechar != '\"')  // first character of token should be \"\n\t\t\t{\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\tstring token = \"\";\n\n\t\t\tsomechar = memorystream.ReadByte();\n", "\t\t\twhile ((somechar != -1) && (somechar != '\"'))  // read until second double quote adding char to token\n\t\t\t{\n\t\t\t\ttoken += (char)somechar;\n\t\t\t\tsomechar = memorystream.ReadByte();\n\t\t\t}\n\n\t\t\tif (somechar == -1)\n\t\t\t{\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\tsomechar = memorystream.ReadByte();\n", "\t\t\tif (somechar != ':')\n\t\t\t{\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\treturn token;\n\t\t}\n\n#if OutputDebugString\n\t\tpublic static void OutputDebugString(string msg, bool bTimestamp = true)\n\t\t{", "\t\tpublic static void OutputDebugString(string msg, bool bTimestamp = true)\n\t\t{\n\t\t\tif (debug_mutex == null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!BPCLFile_EnvChecked)\n\t\t\t{\n\t\t\t\tBPCLFile = Environment.GetEnvironmentVariable(\"BPCLFile\");\n\t\t\t\tBPCLFile_EnvChecked = true;\n\t\t\t}\n", "\t\t\tif (BPCLFile == \"\")\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdebug_mutex.WaitOne();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing (StreamWriter sw = File.AppendText(BPCLFile))\n\t\t\t\t{\n\t\t\t\t\tsw.WriteLine(String.Format(\"{0}{1}\", bTimestamp ? DateTime.Now.ToString(\"MM/dd/yyyy HH:mm:ss - \") : \"\", msg));\n\t\t\t\t}\n\t\t\t}", "\t\t\t\tusing (StreamWriter sw = File.AppendText(BPCLFile))\n\t\t\t\t{\n\t\t\t\t\tsw.WriteLine(String.Format(\"{0}{1}\", bTimestamp ? DateTime.Now.ToString(\"MM/dd/yyyy HH:mm:ss - \") : \"\", msg));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\n\t\t\tdebug_mutex.ReleaseMutex();\n\t\t}\n#endif\n\n\n\t\t// From: https://stackoverflow.com/questions/394816/how-to-get-parent-process-in-net-in-managed-way\n\t\t[StructLayout(LayoutKind.Sequential)]", "\t\tpublic struct ParentProcessUtilities\n\t\t{\n\t\t\t// These members must match PROCESS_BASIC_INFORMATION\n\t\t\tinternal IntPtr Reserved1;\n\t\t\tinternal IntPtr PebBaseAddress;\n\t\t\tinternal IntPtr Reserved2_0;\n\t\t\tinternal IntPtr Reserved2_1;\n\t\t\tinternal IntPtr UniqueProcessId;\n\t\t\tinternal IntPtr InheritedFromUniqueProcessId;\n\n\t\t\t[DllImport(\"ntdll.dll\")]", "\t\t\tprivate static extern int NtQueryInformationProcess(IntPtr processHandle, int processInformationClass, ref ParentProcessUtilities processInformation, int processInformationLength, out int returnLength);\n\n\t\t\t/// <summary>\n\t\t\t/// Gets the parent process of the current process.\n\t\t\t/// </summary>\n\t\t\t/// <returns>An instance of the Process class.</returns>\n\t\t\tpublic static Process GetParentProcess()\n\t\t\t{\n\t\t\t\treturn GetParentProcess(Process.GetCurrentProcess().Handle);\n\t\t\t}\n\n\t\t\t/// <summary>\n\t\t\t/// Gets the parent process of specified process.\n\t\t\t/// </summary>\n\t\t\t/// <param name=\"id\">The process id.</param>\n\t\t\t/// <returns>An instance of the Process class.</returns>", "\t\t\tpublic static Process GetParentProcess(int id)\n\t\t\t{\n\t\t\t\tProcess process = Process.GetProcessById(id);\n\t\t\t\treturn GetParentProcess(process.Handle);\n\t\t\t}\n\n\t\t\t/// <summary>\n\t\t\t/// Gets the parent process of a specified process.\n\t\t\t/// </summary>\n\t\t\t/// <param name=\"handle\">The process handle.</param>\n\t\t\t/// <returns>An instance of the Process class.</returns>", "\t\t\tpublic static Process GetParentProcess(IntPtr handle)\n\t\t\t{\n\t\t\t\tParentProcessUtilities pbi = new ParentProcessUtilities();\n\t\t\t\tint returnLength;\n\t\t\t\tint status = NtQueryInformationProcess(handle, 0, ref pbi, Marshal.SizeOf(pbi), out returnLength);\n\t\t\t\tif (status != 0)\n\t\t\t\t{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\treturn Process.GetProcessById(pbi.InheritedFromUniqueProcessId.ToInt32());\n\t\t\t\t}", "\t\t\t\tcatch (ArgumentException)\n\t\t\t\t{\n\t\t\t\t\t// not found\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n"]}
{"filename": "VisualStudioExtension/CodeLensProvider/CodeLensDataPoint.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.VisualStudio.Threading;\nusing Microsoft.VisualStudio.Language.CodeLens;\nusing Microsoft.VisualStudio.Language.CodeLens.Remoting;\nusing SharedProject;", "using Microsoft.VisualStudio.Language.CodeLens.Remoting;\nusing SharedProject;\n\n\n#pragma warning disable VSTHRD110\n\nnamespace CodeLensProvider\n{\n\tpublic class CodeLensDataPoint : IAsyncCodeLensDataPoint\n\t{\n\t\tprivate readonly CodeLensDescriptor descriptor;", "\tpublic class CodeLensDataPoint : IAsyncCodeLensDataPoint\n\t{\n\t\tprivate readonly CodeLensDescriptor descriptor;\n\t\tpublic CodeLensDescriptor Descriptor => this.descriptor;\n\t\tpublic event AsyncEventHandler InvalidatedAsync;\n\n\t\tprivate string FullyQualifiedName;\n\t\tprivate string class_name;\n\t\tprivate string function_name;\n\n\t\tpublic List<string> blueprint_asset_list = null;\n\n\t\tpublic CodeLensDataPoint(CodeLensDescriptor descriptor, string in_FullyQualifiedName, string in_class_name, string in_function_name)\n\t\t{\n\t\t\tthis.descriptor = descriptor ?? throw new ArgumentNullException(nameof(descriptor));\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tFullyQualifiedName = in_FullyQualifiedName;\n\t\t\t\tclass_name = in_class_name;\n\t\t\t\tfunction_name = in_function_name;\n\n\t\t\t\tInitializeBlueprintAssetList(class_name, function_name);\n\t\t\t}", "\t\tprivate string function_name;\n\n\t\tpublic List<string> blueprint_asset_list = null;\n\n\t\tpublic CodeLensDataPoint(CodeLensDescriptor descriptor, string in_FullyQualifiedName, string in_class_name, string in_function_name)\n\t\t{\n\t\t\tthis.descriptor = descriptor ?? throw new ArgumentNullException(nameof(descriptor));\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tFullyQualifiedName = in_FullyQualifiedName;\n\t\t\t\tclass_name = in_class_name;\n\t\t\t\tfunction_name = in_function_name;\n\n\t\t\t\tInitializeBlueprintAssetList(class_name, function_name);\n\t\t\t}", "\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\t\t}\n\n\t\t~CodeLensDataPoint()\n\t\t{\n\t\t\tif (CodeLensDataPointGlobals.CodeLensDataPoints.Contains(this))\n\t\t\t{\n\t\t\t\tCodeLensDataPointGlobals.CodeLensDataPoints.Remove(this);\n\t\t\t}\n\t\t}\n\n\t\tpublic Task<CodeLensDataPointDescriptor> GetDataAsync(CodeLensDescriptorContext descriptorContext, CancellationToken token)\n\t\t{\n\t\t\ttry\n\t\t\t{", "\t\t\t\tif (blueprint_asset_list == null)\n\t\t\t\t{\n\t\t\t\t\tInitializeBlueprintAssetList(class_name, function_name);\n\t\t\t\t}\n\n\t\t\t\treturn Task.FromResult(new CodeLensDataPointDescriptor {\n\t\t\t\t\tDescription = String.Format(\"{0} Blueprint asset{1}\", (blueprint_asset_list == null) ? 0 : blueprint_asset_list.Count, (blueprint_asset_list == null) ? \"s\" : (blueprint_asset_list.Count == 1) ? \"\" : \"s\"),\n\t\t\t\t\tIntValue = null,\n\t\t\t\t\tTooltipText = \"Blueprint assets\"\n\t\t\t\t});\n\t\t\t}", "\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\n\t\t\treturn Task.FromResult(new CodeLensDataPointDescriptor {\n\t\t\t\tDescription = String.Format(\"\"),\n\t\t\t\tIntValue = null,\n\t\t\t\tTooltipText = \"Error\"\n\t\t\t});\n\t\t}\n\n\t\tpublic Task<CodeLensDetailsDescriptor> GetDetailsAsync(CodeLensDescriptorContext descriptorContext, CancellationToken token)\n\t\t{\n\t\t\ttry\n\t\t\t{", "\t\t\t\tif (blueprint_asset_list.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tList<CodeLensDetailHeaderDescriptor> headers = new List<CodeLensDetailHeaderDescriptor>();\n\t\t\t\t\theaders.Add(new CodeLensDetailHeaderDescriptor() { DisplayName = \"Blueprint Assets\", Width = 1.0 });\n\t\t\t\n\t\t\t\t\tList<CodeLensDetailEntryDescriptor> entries = new List<CodeLensDetailEntryDescriptor>();\n\n\t\t\t\t\tfor (int index = 0; index < blueprint_asset_list.Count; ++index)\n\t\t\t\t\t{\n\t\t\t\t\t\tint trim_pos = blueprint_asset_list[index].LastIndexOf(\" (\");  // trim off the \"(x)\" substring at the end\n\t\t\t\t\t\tstring asset_path = String.Format(\"{0},{1},{2}\", blueprint_asset_list[index].Substring(0, trim_pos), class_name, function_name);\n\n\t\t\t\t\t\tentries.Add(new CodeLensDetailEntryDescriptor()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tFields = new List<CodeLensDetailEntryField>()\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tnew CodeLensDetailEntryField() { Text = blueprint_asset_list[index] },\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tNavigationCommand = new CodeLensDetailEntryCommand()\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tCommandSet = new Guid(\"faaf1a9b-f925-4bfb-b76c-7d6d9e9968d1\"),\n\t\t\t\t\t\t\t\t\tCommandId = 0x0102,\n\t\t\t\t\t\t\t\t\tCommandName = \"OpenAssetPath\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tTooltip = \"Blueprint AssetPath\",\n\t\t\t\t\t\t\t\tNavigationCommandArgs = new List<string>() { asset_path }\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tstring copy_args = String.Format(\"Blueprint assets for {0}\", FullyQualifiedName);", "\t\t\t\t\tfor (int index = 0; index < blueprint_asset_list.Count; ++index)\n\t\t\t\t\t{\n\t\t\t\t\t\tcopy_args += String.Format(\",{0}\", blueprint_asset_list[index]);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar result = new CodeLensDetailsDescriptor()\n\t\t\t\t\t{\n\t\t\t\t\t\tHeaders = headers,\n\t\t\t\t\t\tEntries = entries,\n\t\t\t\t\t\tPaneNavigationCommands = new List<CodeLensDetailPaneCommand>()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnew CodeLensDetailPaneCommand()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tCommandId = new CodeLensDetailEntryCommand()\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tCommandSet = new Guid(\"faaf1a9b-f925-4bfb-b76c-7d6d9e9968d1\"),\n\t\t\t\t\t\t\t\t\tCommandId = 0x0101,\n\t\t\t\t\t\t\t\t\tCommandName = \"CopyToClipboard\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tCommandDisplayName = \"Copy all to clipboard\",\n\t\t\t\t\t\t\t\tCommandArgs = new List<string>() { copy_args }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\n\t\t\t\t\treturn Task.FromResult(result);\n\t\t\t\t}\n\t\t\t}", "\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\n\t\t\treturn Task.FromResult<CodeLensDetailsDescriptor>(null);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Raises <see cref=\"IAsyncCodeLensDataPoint.Invalidated\"/> event.\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t///  This is not part of the IAsyncCodeLensDataPoint interface.\n\t\t///  The data point source can call this method to notify the client proxy that data for this data point has changed.\n\t\t/// </remarks>", "\t\tpublic void Invalidate()\n\t\t{\n\t\t\tthis.InvalidatedAsync?.InvokeAsync(this, EventArgs.Empty).ConfigureAwait(false);\n\t\t}\n\n\t\tprivate void InitializeBlueprintAssetList(string class_name, string function_name)\n\t\t{\n\t\t\tif (CodeLensDataPointGlobals.BlueprintJsonData != null)\n\t\t\t{\n\t\t\t\tint class_index = CodeLensDataPointGlobals.BlueprintJsonData.GetClassIndex(class_name);\n", "\t\t\t\tif (class_index != -1)\n\t\t\t\t{\n\t\t\t\t\tint function_index = CodeLensDataPointGlobals.BlueprintJsonData.GetFunctionIndex(class_index, function_name);\n\n\t\t\t\t\tif (function_index != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tblueprint_asset_list = CodeLensDataPointGlobals.BlueprintJsonData.GetBlueprintAssetPaths(class_index, function_index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"]}
{"filename": "VisualStudioExtension/CodeLensProvider/CodeLensDataPointProvider.cs", "chunked_list": ["\ufeffusing System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.ComponentModel.Composition;\nusing Microsoft.VisualStudio.Language.CodeLens.Remoting;\nusing Microsoft.VisualStudio.Utilities;\nusing CodeLensProvider.Properties;", "using Microsoft.VisualStudio.Utilities;\nusing CodeLensProvider.Properties;\nusing Microsoft.VisualStudio.Language.CodeLens;\nusing System.Diagnostics;\nusing System.Threading;\nusing System.IO.MemoryMappedFiles;\nusing System.Timers;\n\nnamespace CodeLensProvider\n{", "namespace CodeLensProvider\n{\n\t[Export(typeof(IAsyncCodeLensDataPointProvider))]\n\t[Name(Id)]\n//\t[ContentType(\"code\")]\n\t[ContentType(\"C/C++\")]\n//\t[ContentType(\"CppProperties\")]\n\t[LocalizedName(typeof(Resources), \"BlueprintInspector\")]\n\t[Priority(200)]\n    public class CodeLensDataPointProvider : IAsyncCodeLensDataPointProvider\n    {\n\t\tinternal const string Id = \"BlueprintInspector\";\n", "\t[Priority(200)]\n    public class CodeLensDataPointProvider : IAsyncCodeLensDataPointProvider\n    {\n\t\tinternal const string Id = \"BlueprintInspector\";\n\n\t\tprivate static Int32 VisualStudioProcessId = 0;\n\n\t\tprivate static MemoryMappedFile mmf = null;\n\t\tprivate static Mutex mutex = null;\n\t\tprivate static System.Timers.Timer timer;\n\n\n\t\tpublic CodeLensDataPointProvider()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tint count = 10;\n\t\t\t\tProcess proc = Process.GetCurrentProcess();\n", "\t\tprivate static Mutex mutex = null;\n\t\tprivate static System.Timers.Timer timer;\n\n\n\t\tpublic CodeLensDataPointProvider()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tint count = 10;\n\t\t\t\tProcess proc = Process.GetCurrentProcess();\n", "\t\t\t\twhile ((proc != null) && (proc.ProcessName != \"devenv\") && (count != 0))\n\t\t\t\t{\n\t\t\t\t\tproc = SharedProject.SharedGlobals.ParentProcessUtilities.GetParentProcess(proc.Id);\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\n\t\t\t\tif (proc.ProcessName == \"devenv\")\n\t\t\t\t{\n\t\t\t\t\tVisualStudioProcessId = proc.Id;\n\t\t\t\t}\n\n#if OutputDebugString", "\t\t\t\tif (SharedProject.SharedGlobals.debug_mutex == null)\n\t\t\t\t{\n\t\t\t\t\tSharedProject.SharedGlobals.debug_mutex = Mutex.OpenExisting(String.Format(\"BlueprintInspector_debugmutex{0}\", VisualStudioProcessId));\n\t\t\t\t}\n\n\t\t\t\tif (SharedProject.SharedGlobals.debug_mutex != null)\n\t\t\t\t{\n\t\t\t\t\tSharedProject.SharedGlobals.OutputDebugString(\"CodeLensDataPointProvider() - debug_mutex initialized\");\n\t\t\t\t\tSharedProject.SharedGlobals.OutputDebugString(String.Format(\"CodeLensDataPointProvider() - VisualStudioProcessId = {0}\", VisualStudioProcessId));\n\t\t\t\t}\n#endif\n", "\t\t\t\tif (mutex == null)\n\t\t\t\t{\n\t\t\t\t\tmutex = Mutex.OpenExisting(String.Format(\"BlueprintInspector_mutex{0}\", VisualStudioProcessId));\n\t\t\t\t}\n\n\t\t\t\tif (mmf == null)\n\t\t\t\t{\n\t\t\t\t\tmmf = MemoryMappedFile.OpenExisting(String.Format(\"BlueprintInspector{0}\", VisualStudioProcessId));\n\t\t\t\t}\n\n\t\t\t\tif (mmf != null && mutex != null)\n\t\t\t\t{\n\t\t\t\t\tmutex.WaitOne();\n", "\t\t\t\tif (mmf != null && mutex != null)\n\t\t\t\t{\n\t\t\t\t\tmutex.WaitOne();\n\n\t\t\t\t\tusing (MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor(0, 4096))\n\t\t\t\t\t{\n\t\t\t\t\t\tCodeLensDataPointGlobals.JsonFileUpdateCounter = accessor.ReadUInt16(0);\n\n\t\t\t\t\t\tushort Size = accessor.ReadUInt16(2);\n\t\t\t\t\t\tbyte[] Buffer = new byte[Size];\n\t\t\t\t\t\taccessor.ReadArray(4, Buffer, 0, Buffer.Length);\n\n\t\t\t\t\t\tCodeLensDataPointGlobals.SolutionDirectory = ASCIIEncoding.ASCII.GetString(Buffer);\n\n\t\t\t\t\t\tCodeLensDataPointGlobals.bNeedToInitializeSolutionDirectory = false;\n\t\t\t\t\t}\n\n\t\t\t\t\t// keep track of the value of the counter the last time we read it (so we can tell when it changes)\n\t\t\t\t\tCodeLensDataPointGlobals.JsonFileUpdatePreviousCounter = CodeLensDataPointGlobals.JsonFileUpdateCounter;\n\n\t\t\t\t\tmutex.ReleaseMutex();\n\t\t\t\t}\n", "\t\t\t\tif (CodeLensDataPointGlobals.bNeedsToReadJsonFile && CodeLensDataPointGlobals.SolutionDirectory != \"\")\n\t\t\t\t{\n\t\t\t\t\tstring filename = CodeLensDataPointGlobals.SolutionDirectory + \".vs\\\\BlueprintInspector.json\";\n\n\t\t\t\t\tif (File.Exists(filename))\n\t\t\t\t\t{\n\t\t\t\t\t\tCodeLensDataPointGlobals.BlueprintJsonData = new SharedProject.BlueprintJson();\n\t\t\t\t\t\tCodeLensDataPointGlobals.BlueprintJsonData.ReadBlueprintJson(filename);\n\t\t\t\t\t}\n\n#if OutputDebugString\n\t\t\t\t\tSharedProject.SharedGlobals.OutputDebugString(String.Format(\"CodeLensDataPointProvider() - BlueprintJsonData.classes.Count() = {0}\", CodeLensDataPointGlobals.BlueprintJsonData.classes.Count));\n#endif\n\n\t\t\t\t\tCodeLensDataPointGlobals.bNeedsToReadJsonFile = false;\n\t\t\t\t}\n\n\t\t\t\ttimer = new System.Timers.Timer();\n\t\t\t\ttimer.Elapsed += new ElapsedEventHandler(OnTimerEvent);\n\t\t\t\ttimer.AutoReset = true;\n\t\t\t\ttimer.Enabled = true;\n\t\t\t\ttimer.Interval = 500;\n\t\t\t}", "\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\t\t}\n\n\t\tpublic Task<bool> CanCreateDataPointAsync(CodeLensDescriptor descriptor, CodeLensDescriptorContext descriptorContext, CancellationToken token)\n\t\t{\n\t\t\tif (CodeLensDataPointGlobals.bNeedToInitializeSolutionDirectory)\n\t\t\t{\n\t\t\t\t// shouldn't be here\n\t\t\t\treturn Task.FromResult<bool>(false);\n\t\t\t}\n", "\t\t\tif (CodeLensDataPointGlobals.bNeedsToReadJsonFile && CodeLensDataPointGlobals.SolutionDirectory != \"\")\n\t\t\t{\n\t\t\t\tstring filename = CodeLensDataPointGlobals.SolutionDirectory + \".vs\\\\BlueprintInspector.json\";\n\n\t\t\t\tif (File.Exists(filename))\n\t\t\t\t{\n\t\t\t\t\tCodeLensDataPointGlobals.BlueprintJsonData = new SharedProject.BlueprintJson();\n\t\t\t\t\tCodeLensDataPointGlobals.BlueprintJsonData.ReadBlueprintJson(filename);\n\t\t\t\t}\n\n\t\t\t\tCodeLensDataPointGlobals.bNeedsToReadJsonFile = false;\n\t\t\t}\n\n\t\t\tbool bHasValidBlueprintFunctionName = false;\n", "\t\t\tif (CodeLensDataPointGlobals.BlueprintJsonData != null)\n\t\t\t{\n\t\t\t\tstring FullyQualifiedName = \"\";\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tforeach(object SomeObj in descriptorContext.Properties)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (SomeObj != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring SomeObjString = SomeObj.ToString();", "\t\t\t\t\t\tif (SomeObj != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring SomeObjString = SomeObj.ToString();\n\t\t\t\t\t\t\tif (SomeObjString.Contains(\"FullyQualifiedName\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tFullyQualifiedName = SomeObjString.Replace(\"[\", \"\").Replace(\"]\", \"\");\n\t\t\t\t\t\t\t\tFullyQualifiedName = FullyQualifiedName.Replace(\"FullyQualifiedName, \", \"\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n", "\t\t\t\t\tif (FullyQualifiedName != \"\" && FullyQualifiedName.Contains(\"::\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tstring class_name = \"\";\n\t\t\t\t\t\tstring function_name = \"\";\n\n\t\t\t\t\t\tint index = FullyQualifiedName.IndexOf(\"::\");\n\t\t\t\t\t\tif (index > 0 && (index < FullyQualifiedName.Length - 2))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tclass_name = FullyQualifiedName.Substring(0, index);\n\t\t\t\t\t\t\tfunction_name = FullyQualifiedName.Substring(index + 2);\n\t\t\t\t\t\t}\n", "\t\t\t\t\t\tif (CodeLensDataPointGlobals.BlueprintJsonData != null && class_name != \"\" && function_name != \"\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint class_index = CodeLensDataPointGlobals.BlueprintJsonData.GetClassIndex(class_name);\n\n\t\t\t\t\t\t\tif (class_index != -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint function_index = CodeLensDataPointGlobals.BlueprintJsonData.GetFunctionIndex(class_index, function_name);\n\n\t\t\t\t\t\t\t\tif (function_index != -1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbHasValidBlueprintFunctionName = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}", "\t\t\t\t\t\t\t\tif (function_index != -1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbHasValidBlueprintFunctionName = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch(Exception)\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Task.FromResult<bool>(bHasValidBlueprintFunctionName);\n\t\t}\n\n\t\tpublic Task<IAsyncCodeLensDataPoint> CreateDataPointAsync(CodeLensDescriptor descriptor, CodeLensDescriptorContext descriptorContext, CancellationToken token)\n\t\t{\n\t\t\tstring FullyQualifiedName = \"\";\n\t\t\tstring class_name = \"\";\n\t\t\tstring function_name = \"\";\n", "\t\t\t\tcatch(Exception)\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Task.FromResult<bool>(bHasValidBlueprintFunctionName);\n\t\t}\n\n\t\tpublic Task<IAsyncCodeLensDataPoint> CreateDataPointAsync(CodeLensDescriptor descriptor, CodeLensDescriptorContext descriptorContext, CancellationToken token)\n\t\t{\n\t\t\tstring FullyQualifiedName = \"\";\n\t\t\tstring class_name = \"\";\n\t\t\tstring function_name = \"\";\n", "\t\t\tif (CodeLensDataPointGlobals.BlueprintJsonData != null)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tforeach(object SomeObj in descriptorContext.Properties)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (SomeObj != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring SomeObjString = SomeObj.ToString();\n\t\t\t\t\t\t\tif (SomeObjString.Contains(\"FullyQualifiedName\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tFullyQualifiedName = SomeObjString.Replace(\"[\", \"\").Replace(\"]\", \"\");\n\t\t\t\t\t\t\t\tFullyQualifiedName = FullyQualifiedName.Replace(\"FullyQualifiedName, \", \"\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}", "\t\t\t\t\t\t\tif (SomeObjString.Contains(\"FullyQualifiedName\"))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tFullyQualifiedName = SomeObjString.Replace(\"[\", \"\").Replace(\"]\", \"\");\n\t\t\t\t\t\t\t\tFullyQualifiedName = FullyQualifiedName.Replace(\"FullyQualifiedName, \", \"\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch(Exception)\n\t\t\t\t{\n\t\t\t\t}\n", "\t\t\t\tcatch(Exception)\n\t\t\t\t{\n\t\t\t\t}\n\n\t\t\t\tif (FullyQualifiedName != \"\" && FullyQualifiedName.Contains(\"::\"))\n\t\t\t\t{\n\t\t\t\t\tint index = FullyQualifiedName.IndexOf(\"::\");\n\t\t\t\t\tif (index > 0 && (index < FullyQualifiedName.Length - 2))\n\t\t\t\t\t{\n\t\t\t\t\t\tclass_name = FullyQualifiedName.Substring(0, index);\n\t\t\t\t\t\tfunction_name = FullyQualifiedName.Substring(index + 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tCodeLensDataPoint NewCodeLensDataPoint = new CodeLensDataPoint(descriptor, FullyQualifiedName, class_name, function_name);\n\n\t\t\ttry\n\t\t\t{", "\t\t\t\tif (CodeLensDataPointGlobals.CodeLensDataPoints == null)\n\t\t\t\t{\n\t\t\t\t\tCodeLensDataPointGlobals.CodeLensDataPoints = new List<CodeLensDataPoint>();\n\t\t\t\t}\n\n\t\t\t\tCodeLensDataPointGlobals.CodeLensDataPoints.Add(NewCodeLensDataPoint);\n\t\t\t}\n\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\n\t\t\treturn Task.FromResult<IAsyncCodeLensDataPoint>(NewCodeLensDataPoint);\n\t\t}\n", "\t\tprivate static void OnTimerEvent(object source, ElapsedEventArgs e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// update the globals memory (in the event that things have changed)\n\t\t\t\tif (mmf != null && mutex != null)\n\t\t\t\t{\n\t\t\t\t\tmutex.WaitOne();\n\n\t\t\t\t\tusing (MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor(0, 4096))\n\t\t\t\t\t{\n\t\t\t\t\t\tCodeLensDataPointGlobals.JsonFileUpdateCounter = accessor.ReadUInt16(0);\n\n\t\t\t\t\t\tushort Size = accessor.ReadUInt16(2);\n\t\t\t\t\t\tbyte[] Buffer = new byte[Size];\n\t\t\t\t\t\taccessor.ReadArray(4, Buffer, 0, Buffer.Length);\n\n\t\t\t\t\t\tCodeLensDataPointGlobals.SolutionDirectory = ASCIIEncoding.ASCII.GetString(Buffer);\n\t\t\t\t\t}\n\n\t\t\t\t\tmutex.ReleaseMutex();\n\t\t\t\t}\n\n\t\t\t\t// has the json file been updated?", "\t\t\t\t\tusing (MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor(0, 4096))\n\t\t\t\t\t{\n\t\t\t\t\t\tCodeLensDataPointGlobals.JsonFileUpdateCounter = accessor.ReadUInt16(0);\n\n\t\t\t\t\t\tushort Size = accessor.ReadUInt16(2);\n\t\t\t\t\t\tbyte[] Buffer = new byte[Size];\n\t\t\t\t\t\taccessor.ReadArray(4, Buffer, 0, Buffer.Length);\n\n\t\t\t\t\t\tCodeLensDataPointGlobals.SolutionDirectory = ASCIIEncoding.ASCII.GetString(Buffer);\n\t\t\t\t\t}\n\n\t\t\t\t\tmutex.ReleaseMutex();\n\t\t\t\t}\n\n\t\t\t\t// has the json file been updated?", "\t\t\t\tif (CodeLensDataPointGlobals.JsonFileUpdatePreviousCounter != CodeLensDataPointGlobals.JsonFileUpdateCounter)\n\t\t\t\t{\n\t\t\t\t\t// keep track of the value of the counter the last time we read it (so we can tell when it changes)\n\t\t\t\t\tCodeLensDataPointGlobals.JsonFileUpdatePreviousCounter = CodeLensDataPointGlobals.JsonFileUpdateCounter;\n\n\t\t\t\t\tCodeLensDataPointGlobals.bNeedsToReadJsonFile = true;\n\n\t\t\t\t\t// We need to invalidate all CodeLensDataPoint objects here.  Call the Invalidate() method on them.\n\t\t\t\t\tfor (Int32 index = 0; index < CodeLensDataPointGlobals.CodeLensDataPoints.Count; ++index)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (CodeLensDataPointGlobals.CodeLensDataPoints[index] != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCodeLensDataPointGlobals.CodeLensDataPoints[index].blueprint_asset_list = null;\n\t\t\t\t\t\t\tCodeLensDataPointGlobals.CodeLensDataPoints[index].Invalidate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}", "\t\t\t\t\tfor (Int32 index = 0; index < CodeLensDataPointGlobals.CodeLensDataPoints.Count; ++index)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (CodeLensDataPointGlobals.CodeLensDataPoints[index] != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tCodeLensDataPointGlobals.CodeLensDataPoints[index].blueprint_asset_list = null;\n\t\t\t\t\t\t\tCodeLensDataPointGlobals.CodeLensDataPoints[index].Invalidate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\t\t}\n    }\n}\n", "\t\t\tcatch(Exception)\n\t\t\t{\n\t\t\t}\n\t\t}\n    }\n}\n"]}
{"filename": "VisualStudioExtension/CodeLensProvider/CodeLensDataPointGlobals.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nnamespace CodeLensProvider\n{\n\tpublic static class CodeLensDataPointGlobals\n\t{\n\t\tpublic static volatile bool bNeedToInitializeSolutionDirectory = true;\n\t\tpublic static string SolutionDirectory = \"\";  // ends with trailing \"\\\\\"\n", "\t\tpublic static volatile bool bNeedToInitializeSolutionDirectory = true;\n\t\tpublic static string SolutionDirectory = \"\";  // ends with trailing \"\\\\\"\n\n\t\tpublic static List<CodeLensDataPoint> CodeLensDataPoints = null;\n\n\t\tpublic static ushort JsonFileUpdateCounter = 0;\n\t\tpublic static ushort JsonFileUpdatePreviousCounter = 0;\n\t\tpublic static volatile bool bNeedsToReadJsonFile = true;\n\t\tinternal static volatile SharedProject.BlueprintJson BlueprintJsonData = null;\n\n\t\tpublic static Object BlueprintAssetPathLock = new object();", "\t\tpublic static Object BlueprintAssetPathLock = new object();\n\t\tpublic static volatile bool bHasBlueprintAssetPathToSend = false;\n\t\tpublic static volatile List<string> BlueprintAssetPathToSend;\n\n\t\tpublic static Int32 EditorTopLevelWindowHandle = -1;\n\t}\n}\n"]}
{"filename": "VisualStudioExtension/CodeLensProvider/Properties/Resources.Designer.cs", "chunked_list": ["\ufeff//------------------------------------------------------------------------------\n// <auto-generated>\n//     This code was generated by a tool.\n//     Runtime Version:4.0.30319.42000\n//\n//     Changes to this file may cause incorrect behavior and will be lost if\n//     the code is regenerated.\n// </auto-generated>\n//------------------------------------------------------------------------------\n", "//------------------------------------------------------------------------------\n\nnamespace CodeLensProvider.Properties {\n    using System;\n    \n    \n    /// <summary>\n    ///   A strongly-typed resource class, for looking up localized strings, etc.\n    /// </summary>\n    // This class was auto-generated by the StronglyTypedResourceBuilder\n    // class via a tool like ResGen or Visual Studio.\n    // To add or remove a member, edit your .ResX file then rerun ResGen\n    // with the /str option, or rebuild your VS project.\n    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Resources.Tools.StronglyTypedResourceBuilder\", \"17.0.0.0\")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]\n    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]", "    /// </summary>\n    // This class was auto-generated by the StronglyTypedResourceBuilder\n    // class via a tool like ResGen or Visual Studio.\n    // To add or remove a member, edit your .ResX file then rerun ResGen\n    // with the /str option, or rebuild your VS project.\n    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Resources.Tools.StronglyTypedResourceBuilder\", \"17.0.0.0\")]\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]\n    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]\n    public class Resources {\n        \n        private static global::System.Resources.ResourceManager resourceMan;\n        ", "    public class Resources {\n        \n        private static global::System.Resources.ResourceManager resourceMan;\n        \n        private static global::System.Globalization.CultureInfo resourceCulture;\n        \n        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(\"Microsoft.Performance\", \"CA1811:AvoidUncalledPrivateCode\")]\n        internal Resources() {\n        }\n        \n        /// <summary>\n        ///   Returns the cached ResourceManager instance used by this class.\n        /// </summary>\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]", "        public static global::System.Resources.ResourceManager ResourceManager {\n            get {\n                if (object.ReferenceEquals(resourceMan, null)) {\n                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager(\"CodeLensProvider.Properties.Resources\", typeof(Resources).Assembly);\n                    resourceMan = temp;\n                }\n                return resourceMan;\n            }\n        }\n        \n        /// <summary>\n        ///   Overrides the current thread's CurrentUICulture property for all\n        ///   resource lookups using this strongly typed resource class.\n        /// </summary>\n        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]", "        public static global::System.Globalization.CultureInfo Culture {\n            get {\n                return resourceCulture;\n            }\n            set {\n                resourceCulture = value;\n            }\n        }\n        \n        /// <summary>\n        ///   Looks up a localized string similar to Blueprint Inspector.\n        /// </summary>", "        public static string BlueprintInspector {\n            get {\n                return ResourceManager.GetString(\"BlueprintInspector\", resourceCulture);\n            }\n        }\n    }\n}\n"]}
{"filename": "VisualStudioExtension/CodeLensProvider/Properties/AssemblyInfo.cs", "chunked_list": ["\ufeffusing System.Reflection;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n\n// General Information about an assembly is controlled through the following\n// set of attributes. Change these attribute values to modify the information\n// associated with an assembly.\n[assembly: AssemblyTitle(\"CodeLensProvider\")]\n[assembly: AssemblyDescription(\"\")]\n[assembly: AssemblyConfiguration(\"\")]", "[assembly: AssemblyDescription(\"\")]\n[assembly: AssemblyConfiguration(\"\")]\n[assembly: AssemblyCompany(\"\")]\n[assembly: AssemblyProduct(\"CodeLensProvider\")]\n[assembly: AssemblyCopyright(\"Copyright \u00a9  2022\")]\n[assembly: AssemblyTrademark(\"\")]\n[assembly: AssemblyCulture(\"\")]\n\n// Setting ComVisible to false makes the types in this assembly not visible\n// to COM components.  If you need to access a type in this assembly from", "// Setting ComVisible to false makes the types in this assembly not visible\n// to COM components.  If you need to access a type in this assembly from\n// COM, set the ComVisible attribute to true on that type.\n[assembly: ComVisible(false)]\n\n// The following GUID is for the ID of the typelib if this project is exposed to COM\n[assembly: Guid(\"32e5847e-5986-49cc-8ed6-eadd09101161\")]\n\n// Version information for an assembly consists of the following four values:\n//", "// Version information for an assembly consists of the following four values:\n//\n//      Major Version\n//      Minor Version\n//      Build Number\n//      Revision\n//\n// You can specify all the values or you can default the Build and Revision Numbers\n// by using the '*' as shown below:\n// [assembly: AssemblyVersion(\"1.0.*\")]", "// by using the '*' as shown below:\n// [assembly: AssemblyVersion(\"1.0.*\")]\n[assembly: AssemblyVersion(\"1.0.0.0\")]\n[assembly: AssemblyFileVersion(\"1.0.0.0\")]\n"]}
{"filename": "UnrealPlugin/BlueprintInspector/Source/BlueprintInspector/BlueprintInspector.Build.cs", "chunked_list": ["// Copyright 2023 - Jeffrey \"botman\" Broome. All Rights Reserved\n\nusing UnrealBuildTool;\n\npublic class BlueprintInspector : ModuleRules\n{\n\tpublic BlueprintInspector(ReadOnlyTargetRules Target) : base(Target)\n\t{\n\t\tPCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;\n\n\t\tPublicDependencyModuleNames.AddRange(\n\t\t\tnew[]\n\t\t\t{\n\t\t\t\t\"Core\",\n\t\t\t}\n\t\t);\n\n\t\tPrivateDependencyModuleNames.AddRange(\n\t\t\tnew string[]\n\t\t\t{\n\t\t\t\t\"CoreUObject\",\n\t\t\t\t\"AssetRegistry\",\n\t\t\t\t\"Engine\",\n\t\t\t\t\"UnrealEd\",\n\t\t\t\t\"BlueprintGraph\",\n\t\t\t\t\"Kismet\",\n\t\t\t\t\"Projects\",\n\t\t\t\t\"Json\",\n\t\t\t}\n\t\t);\n\n\t\tPublicIncludePaths.Add(ModuleDirectory + \"/Public\");\n\n\t\tint EngineMajor = 0;\n\t\tint EngineMinor = 0;\n\n\t\tGetEngineVersion(ref EngineMajor, ref EngineMinor);\n\n\t\tPrivateDefinitions.Add(string.Format(\"ENGINE_MAJOR_VERSION={0}\", EngineMajor));\n\t\tPrivateDefinitions.Add(string.Format(\"ENGINE_MINOR_VERSION={0}\", EngineMinor));\n\t}\n", "\tprivate void GetEngineVersion(ref int EngineMajor, ref int EngineMinor)\n\t{\n\t\tEngineMajor = 0;\n\t\tEngineMinor = 0;\n\n\t\tstring input;\n\t\tusing(System.IO.StreamReader sr = new System.IO.StreamReader(\"Runtime/Launch/Resources/Version.h\"))\n\t\t{\n\t\t\twhile ((input = sr.ReadLine()) != null)\n\t\t\t{\n\t\t\t\tif (input.StartsWith(\"#define ENGINE_MAJOR_VERSION\"))\n\t\t\t\t{\n\t\t\t\t\tstring[] fields = input.Split();", "\t\t\twhile ((input = sr.ReadLine()) != null)\n\t\t\t{\n\t\t\t\tif (input.StartsWith(\"#define ENGINE_MAJOR_VERSION\"))\n\t\t\t\t{\n\t\t\t\t\tstring[] fields = input.Split();\n\t\t\t\t\tif (fields.Length > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tEngineMajor = int.Parse(fields[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (input.StartsWith(\"#define ENGINE_MINOR_VERSION\"))\n\t\t\t\t{\n\t\t\t\t\tstring[] fields = input.Split();", "\t\t\t\telse if (input.StartsWith(\"#define ENGINE_MINOR_VERSION\"))\n\t\t\t\t{\n\t\t\t\t\tstring[] fields = input.Split();\n\t\t\t\t\tif (fields.Length > 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tEngineMinor = int.Parse(fields[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"]}
