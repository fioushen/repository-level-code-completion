{"filename": "tests/Redis/KeyManager/RedisKeyManagerTests.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Threading.Tasks;\nusing AspectCore.DynamicProxy;\nusing AspectCore.DynamicProxy.Parameters;\nusing Moq;\nusing Nebula.Caching.Common.Constants;\nusing Nebula.Caching.Redis.KeyManager;", "using Nebula.Caching.Common.Constants;\nusing Nebula.Caching.Redis.KeyManager;\nusing Xunit;\n\nnamespace Nebula.Caching.tests.Redis.KeyManager\n{\n    public class RedisKeyManagerTests\n    {\n        [Fact]\n        public void Given_AMethodExecutedWithRedisCacheAttribute_When_NoArgumentsArePassed_Then_CacheKeyOnlyContainsFullPathMethod()\n        {\n            //Arrrange\n            var redisKeyManager = new RedisKeyManager();\n            var arguments = new string[] { };\n            var mockedMethodInfo = new Mock<MethodInfo>();\n            mockedMethodInfo.SetupGet(m => m.DeclaringType.FullName).Returns(\"my.full.name\");\n            mockedMethodInfo.SetupGet(m => m.Name).Returns(\"myMethod\");\n            var methodInfo = mockedMethodInfo.Object;\n            var expectedCacheKey = $\"{methodInfo.DeclaringType.FullName}{KeyConstants.MethodAndParametersSeparator}{methodInfo.Name}\";\n\n            //Act\n            var generatedCacheKey = redisKeyManager.GenerateKey(methodInfo, arguments);\n\n            //Assert\n            Assert.NotEmpty(generatedCacheKey);\n            Assert.Equal(expectedCacheKey, generatedCacheKey);\n        }\n\n        [Theory]\n        [MemberData(nameof(ExecutedMethodArguments))]", "        public void Given_AMethodExecutedWithRedisCacheAttribute_When_NoArgumentsArePassed_Then_CacheKeyOnlyContainsFullPathMethod()\n        {\n            //Arrrange\n            var redisKeyManager = new RedisKeyManager();\n            var arguments = new string[] { };\n            var mockedMethodInfo = new Mock<MethodInfo>();\n            mockedMethodInfo.SetupGet(m => m.DeclaringType.FullName).Returns(\"my.full.name\");\n            mockedMethodInfo.SetupGet(m => m.Name).Returns(\"myMethod\");\n            var methodInfo = mockedMethodInfo.Object;\n            var expectedCacheKey = $\"{methodInfo.DeclaringType.FullName}{KeyConstants.MethodAndParametersSeparator}{methodInfo.Name}\";\n\n            //Act\n            var generatedCacheKey = redisKeyManager.GenerateKey(methodInfo, arguments);\n\n            //Assert\n            Assert.NotEmpty(generatedCacheKey);\n            Assert.Equal(expectedCacheKey, generatedCacheKey);\n        }\n\n        [Theory]\n        [MemberData(nameof(ExecutedMethodArguments))]", "        public void Given_AMethodExecutedWithRedisCacheAttribute_When_ArgumentsArePassed_Then_CacheKeyShouldContainArguments(string[] methodArguments)\n        {\n            //Arrrange\n            var redisKeyManager = new RedisKeyManager();\n            var mockedMethodInfo = new Mock<MethodInfo>();\n            mockedMethodInfo.SetupGet(expression: m => m.DeclaringType.FullName).Returns(\"my.full.name\");\n            mockedMethodInfo.SetupGet(m => m.Name).Returns(\"myMethod\");\n            var methodInfo = mockedMethodInfo.Object;\n            string methodParamsAggregated = string.Join(KeyConstants.MethodAndParametersSeparator, methodArguments);\n            var expectedCacheKey = $\"{methodInfo.DeclaringType.FullName}{KeyConstants.MethodAndParametersSeparator}{methodInfo.Name}{KeyConstants.MethodAndParametersSeparator}{methodParamsAggregated}\";\n\n            //Act\n            var generatedCacheKey = redisKeyManager.GenerateKey(methodInfo, methodArguments);\n\n            //Assert\n            Assert.NotEmpty(generatedCacheKey);\n            Assert.Equal(expectedCacheKey, generatedCacheKey);\n        }\n\n        [Theory]\n        [MemberData(nameof(ValidCacheKeys))]", "        public void Given_ACacheKey_When_AConfigKeyTransformationIsNeeded_Then_PerformTransformationFromCacheKeyToConfigKey(string key, string expectedConfigKey)\n        {\n            //Arrange\n            var redisKeyManager = new RedisKeyManager();\n\n            //Act\n            var generatedConfigKey = redisKeyManager.ConvertCacheKeyToConfigKey(key);\n\n            //Assert\n            Assert.Equal(expectedConfigKey, generatedConfigKey);\n        }\n\n        //Unit test data", "        public static IEnumerable<object[]> ExecutedMethodArguments\n        {\n            get\n            {\n                var values1 = new string[] { \"1\", \"2\", \"Rafael\" };\n                var values2 = new string[] { \"10\", \"6\", \"3\" };\n                var values3 = new string[] { \"Rafael\", \"Camara\" };\n                var values4 = new string[] { \"a\", \"Rafael\", \"true\", \"123\" };\n                return new List<object[]>\n                        {\n                            new object[] { values1 },\n                            new object[] { values2 },\n                            new object[] { values3 },\n                            new object[] { values4 }\n                        };\n            }\n        }", "        public static IEnumerable<object[]> ValidCacheKeys\n        {\n            get\n            {\n                return new List<object[]>\n                        {\n                            new object[] {\"full.path.to.method:method:param1:param2:param3:param4\", \"full-path-to-method--method--param1--param2--param3--param4\"},\n                            new object[] {\"a.happy.path.to.method:method\", \"a-happy-path-to-method--method\"},\n                            new object[] {\"path.to.amazing.method:method:param1\", \"path-to-amazing-method--method--param1\"}\n                        };\n            }\n        }\n\n    }\n}"]}
{"filename": "tests/Redis/Interceptors/RedisCacheInterceptorTests.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace Nebula.Caching.tests.Redis.Interceptors\n{\n    public class RedisCacheInterceptorTests\n    {\n        \n    }\n}"]}
{"filename": "tests/Redis/CacheManager/RedisCacheManagerTests.cs", "chunked_list": ["using System.Collections.Concurrent;\nusing Moq;\nusing Nebula.Caching.Redis.CacheManager;\nusing StackExchange.Redis;\nusing Xunit;\n\nnamespace Nebula.Caching.tests.Redis.CacheManager\n{\n    public class RedisCacheManagerTests\n    {\n        [Fact]", "    public class RedisCacheManagerTests\n    {\n        [Fact]\n        public void Given_AMethodExecutedWithRedisCacheAttribute_When_CacheDoesExist_Then_ReturnTrueBecauseCacheExists()\n        {\n            //Arrange\n            var mockedIDatabase = new Mock<IDatabase>();\n            mockedIDatabase.Setup(m => m.StringGet(\"key\", It.IsAny<CommandFlags>())).Returns(\"value\");\n            var redisCacheManager = new RedisCacheManager(mockedIDatabase.Object);\n            var expectedCacheExistence = true;\n\n            //Act\n            var cacheExists = redisCacheManager.CacheExists(\"key\");\n\n            //Assert\n            Assert.Equal(expectedCacheExistence, cacheExists);\n            mockedIDatabase.Verify(m => m.StringGet(\"key\", It.IsAny<CommandFlags>()), Times.Once);\n        }\n\n        [Fact]", "        public void Given_AMethodExecutedWithRedisCacheAttribute_When_CacheDoesNotExist_Then_ReturnFalseBecauseCacheDoesNotExist()\n        {\n            //Arrange\n            var mockedIDatabase = new Mock<IDatabase>();\n            mockedIDatabase.Setup(m => m.StringGet(\"key\", It.IsAny<CommandFlags>())).Returns(RedisValue.Null);\n            var redisCacheManager = new RedisCacheManager(mockedIDatabase.Object);\n            var expectedCacheExistence = false;\n\n            //Act\n            var cacheExists = redisCacheManager.CacheExists(\"key\");\n\n            //Assert\n            Assert.Equal(expectedCacheExistence, cacheExists);\n            mockedIDatabase.Verify(m => m.StringGet(\"key\", It.IsAny<CommandFlags>()), Times.Once);\n        }\n\n        [Fact]", "        public void Given_AMethodExecutedWithRedisCacheAttribute_When_CacheExistsAndWillBeRetrieved_Then_CacheValueWillBeReturned()\n        {\n            //Arrange\n            var mockedIDatabase = new Mock<IDatabase>();\n            mockedIDatabase.Setup(m => m.StringGet(\"key\", It.IsAny<CommandFlags>())).Returns(\"value\");\n            var redisCacheManager = new RedisCacheManager(mockedIDatabase.Object);\n            var expectedCacheValue = \"value\";\n\n            //Act\n            var cacheValue = redisCacheManager.Get(\"key\");\n\n            //Assert\n            Assert.Equal(expectedCacheValue, cacheValue);\n            mockedIDatabase.Verify(m => m.StringGet(\"key\", It.IsAny<CommandFlags>()), Times.Once);\n        }\n\n        [Fact]", "        public void Given_AMethodExecutedWithRedisCacheAttribute_When_CacheDoesNotExist_Then_SetCache()\n        {\n            //Arrange\n            var mockedIDatabase = new Mock<IDatabase>();\n            var key = \"someKey\";\n            var value = \"someValue\";\n            var expiration = TimeSpan.FromSeconds(25);\n            mockedIDatabase.Setup(m => m.StringSet(key, value, It.IsAny<TimeSpan?>(), It.IsAny<bool>(), It.IsAny<When>(), It.IsAny<CommandFlags>())).Returns(It.IsAny<bool>());\n            mockedIDatabase.Setup(m => m.KeyExpire(key, expiration, It.IsAny<ExpireWhen>(), It.IsAny<CommandFlags>())).Returns(It.IsAny<bool>());\n            var redisCacheManager = new RedisCacheManager(mockedIDatabase.Object);\n\n\n            //Act\n            redisCacheManager.Set(key, value, expiration);\n\n            //Assert\n            mockedIDatabase.Verify(m => m.StringSet(key, value, It.IsAny<TimeSpan?>(), It.IsAny<bool>(), It.IsAny<When>(), It.IsAny<CommandFlags>()), Times.Once);\n            mockedIDatabase.Verify(m => m.KeyExpire(key, expiration, It.IsAny<ExpireWhen>(), It.IsAny<CommandFlags>()), Times.Once);\n        }\n\n        [Fact]", "        public async Task Given_AMethodExecutedWithRedisCacheAttribute_When_CacheDoesExist_Then_ReturnTrueBecauseCacheExistsAsync()\n        {\n            //Arrange\n            var mockedIDatabase = new Mock<IDatabase>();\n            mockedIDatabase.Setup(m => m.StringGetAsync(\"key\", It.IsAny<CommandFlags>())).ReturnsAsync(\"value\");\n            var redisCacheManager = new RedisCacheManager(mockedIDatabase.Object);\n            var expectedCacheExistence = true;\n\n            //Act\n            var cacheExists = await redisCacheManager.CacheExistsAsync(\"key\");\n\n            //Assert\n            Assert.Equal(expectedCacheExistence, cacheExists);\n            mockedIDatabase.Verify(m => m.StringGetAsync(\"key\", It.IsAny<CommandFlags>()), Times.Once);\n        }\n\n        [Fact]", "        public async Task Given_AMethodExecutedWithRedisCacheAttribute_When_CacheDoesNotExist_Then_ReturnFalseBecauseCacheDoesNotExistAsync()\n        {\n            //Arrange\n            var mockedIDatabase = new Mock<IDatabase>();\n            mockedIDatabase.Setup(m => m.StringGetAsync(\"key\", It.IsAny<CommandFlags>())).ReturnsAsync(RedisValue.Null);\n            var redisCacheManager = new RedisCacheManager(mockedIDatabase.Object);\n            var expectedCacheExistence = false;\n\n            //Act\n            var cacheExists = await redisCacheManager.CacheExistsAsync(\"key\");\n\n            //Assert\n            Assert.Equal(expectedCacheExistence, cacheExists);\n            mockedIDatabase.Verify(m => m.StringGetAsync(\"key\", It.IsAny<CommandFlags>()), Times.Once);\n        }\n\n        [Fact]", "        public async Task Given_AMethodExecutedWithRedisCacheAttribute_When_CacheExistsAndWillBeRetrieved_Then_CacheValueWillBeReturnedAsync()\n        {\n            //Arrange\n            var mockedIDatabase = new Mock<IDatabase>();\n            mockedIDatabase.Setup(m => m.StringGetAsync(\"key\", It.IsAny<CommandFlags>())).ReturnsAsync(\"value\");\n            var redisCacheManager = new RedisCacheManager(mockedIDatabase.Object);\n            var expectedCacheValue = \"value\";\n\n            //Act\n            var cacheValue = await redisCacheManager.GetAsync(\"key\");\n\n            //Assert\n            Assert.Equal(expectedCacheValue, cacheValue);\n            mockedIDatabase.Verify(m => m.StringGetAsync(\"key\", It.IsAny<CommandFlags>()), Times.Once);\n        }\n\n        [Fact]", "        public async Task Given_AMethodExecutedWithRedisCacheAttribute_When_CacheDoesNotExist_Then_SetCacheAsync()\n        {\n            //Arrange\n            var mockedIDatabase = new Mock<IDatabase>();\n            var key = \"someKey\";\n            var value = \"someValue\";\n            var expiration = TimeSpan.FromSeconds(25);\n            mockedIDatabase.Setup(m => m.StringSetAsync(key, value, It.IsAny<TimeSpan?>(), It.IsAny<bool>(), It.IsAny<When>(), It.IsAny<CommandFlags>())).ReturnsAsync(It.IsAny<bool>());\n            mockedIDatabase.Setup(m => m.KeyExpireAsync(key, expiration, It.IsAny<ExpireWhen>(), It.IsAny<CommandFlags>())).ReturnsAsync(It.IsAny<bool>());\n            var redisCacheManager = new RedisCacheManager(mockedIDatabase.Object);\n\n\n            //Act\n            redisCacheManager.SetAsync(key, value, expiration);\n\n            //Assert\n            mockedIDatabase.Verify(m => m.StringSetAsync(key, value, It.IsAny<TimeSpan?>(), It.IsAny<bool>(), It.IsAny<When>(), It.IsAny<CommandFlags>()), Times.Once);\n            mockedIDatabase.Verify(m => m.KeyExpireAsync(key, expiration, It.IsAny<ExpireWhen>(), It.IsAny<CommandFlags>()), Times.Once);\n        }\n    }\n}"]}
{"filename": "tests/Common/Utils/ContextUtilsTests.cs", "chunked_list": ["using System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing AspectCore.DynamicProxy;\nusing AspectCore.DynamicProxy.Parameters;\nusing Common.Settings;\nusing Microsoft.Extensions.Configuration;\nusing Moq;", "using Microsoft.Extensions.Configuration;\nusing Moq;\nusing Nebula.Caching.Common.KeyManager;\nusing Nebula.Caching.Common.Utils;\nusing Nebula.Caching.Redis.KeyManager;\nusing Redis.Settings;\nusing Xunit;\n\nnamespace Nebula.Caching.tests.Common.Utils\n{\n    public class ContextUtilsTests\n    {\n\n        [Theory]\n        [MemberData(nameof(ValidGenericParamNames))]", "namespace Nebula.Caching.tests.Common.Utils\n{\n    public class ContextUtilsTests\n    {\n\n        [Theory]\n        [MemberData(nameof(ValidGenericParamNames))]\n        public void Given_AParameterName_When_GenericParameterForConfigIsNeeded_Then_ReturnGenericParamAppropriateForConfig(string paramName, string expectedGenericConfigCacheParameter)\n        {\n            //Arrange\n            var contextUtils = new ContextUtils(It.IsAny<IKeyManager>(), It.IsAny<IConfiguration>(), It.IsAny<BaseOptions>());\n\n            //Act\n            var generatedGenericConfigCacheParameter = contextUtils.GenerateGeneriConfigCacheParameter(paramName);\n\n            //Assert\n            Assert.Equal(expectedGenericConfigCacheParameter, generatedGenericConfigCacheParameter);\n        }\n\n\n        [Fact]", "        public void Given_ACacheExpirationValue_When_CacheExpirationIsValid_Then_ReturnTrue()\n        {\n            //Arrange\n            var contextUtils = new ContextUtils(It.IsAny<IKeyManager>(), It.IsAny<IConfiguration>(), It.IsAny<BaseOptions>());\n            var validExpiration = TimeSpan.FromSeconds(30);\n\n            //Act\n            var isExpirationValid = contextUtils.IsCacheExpirationValid(validExpiration);\n\n            //Assert\n            Assert.True(isExpirationValid);\n        }\n\n        [Fact]", "        public void Given_ACacheExpirationValue_When_CacheExpirationIsNull_Then_ReturnFalse()\n        {\n            //Arrange\n            var contextUtils = new ContextUtils(It.IsAny<IKeyManager>(), It.IsAny<IConfiguration>(), It.IsAny<BaseOptions>());\n            TimeSpan? nullExpirationValue = null;\n\n            //Act\n            var isExpirationValid = contextUtils.IsCacheExpirationValid(nullExpirationValue);\n\n            //Assert\n            Assert.False(isExpirationValid);\n        }\n\n        [Fact]", "        public void Given_ACacheExpirationValue_When_CacheExpirationIsZero_Then_ReturnFalse()\n        {\n            //Arrange\n            var contextUtils = new ContextUtils(It.IsAny<IKeyManager>(), It.IsAny<IConfiguration>(), It.IsAny<BaseOptions>());\n            var validExpiration = TimeSpan.FromSeconds(0);\n\n            //Act\n            var isExpirationValid = contextUtils.IsCacheExpirationValid(validExpiration);\n\n            //Assert\n            Assert.False(isExpirationValid);\n        }\n\n        [Fact]", "        public void Given_ARequestToCheckforCacheConfigSection_When_CacheConfigSectionExists_Then_ReturnTrue()\n        {\n            //Arrange\n            var baseOptions = new RedisOptions();\n            baseOptions.CacheSettings = new ConcurrentDictionary<string, TimeSpan>();\n            var contextUtils = new ContextUtils(It.IsAny<IKeyManager>(), It.IsAny<IConfiguration>(), baseOptions);\n\n            //Act\n            var cacheConfigSectionExists = contextUtils.CacheConfigSectionExists();\n\n            //Assert\n            Assert.True(cacheConfigSectionExists);\n        }\n\n        [Fact]", "        public void Given_ARequestToCheckforCacheConfigSection_When_CacheConfigSectionDoesNotExist_Then_ReturnFalse()\n        {\n            //Arrange\n            var baseOptions = new RedisOptions();\n            var contextUtils = new ContextUtils(It.IsAny<IKeyManager>(), It.IsAny<IConfiguration>(), baseOptions);\n\n            //Act\n            var cacheConfigSectionExists = contextUtils.CacheConfigSectionExists();\n\n            //Assert\n            Assert.False(cacheConfigSectionExists);\n        }\n\n        // [Fact]", "        // public void Given1_A()\n        // {\n        //     //Arrange\n        //     var contextUtils = new ContextUtils(It.IsAny<IKeyManager>(), It.IsAny<IConfiguration>(), It.IsAny<BaseOptions>());\n        //     var mockedParamCollection = new Mock<ParameterCollection>();\n        //     var mockedParam = new Mock<Parameter>();\n        //     mockedParam.SetupGet(m => m.Name).Returns(\"param1\");\n        //     List<Parameter> parameters = new List<Parameter> { mockedParam.Object };\n        //     mockedParamCollection.Setup(m => m.Count).Returns(() => parameters.Count);\n        //     mockedParamCollection.Setup(m => m[It.IsAny<int>()]).Returns<int>(i => parameters.ElementAt(i));\n        //     mockedParamCollection.Setup(m => m.GetEnumerator()).Returns(() => parameters.GetEnumerator());\n\n        //     var expectedParamList = new string[] { \"param1\" };\n\n        //     //Act\n        //     var generatedGenericParamList = contextUtils.GenerateParamsFromParamCollection(mockedParamCollection.Object);\n\n        //     //Assert\n        //     Assert.Equal(expectedParamList, generatedGenericParamList);\n        // }\n\n        //Unit test data", "        public static IEnumerable<object[]> ValidGenericParamNames\n        {\n            get\n            {\n                return new List<object[]>\n                        {\n                            new object[] {\"paramName1\", \"{paramName1}\"},\n                            new object[] {\"paramName2\", \"{paramName2}\"},\n                            new object[] {\"aVeryLongParamNameWithNoMeaning\", \"{aVeryLongParamNameWithNoMeaning}\"}\n                        };\n            }\n        }\n\n    }\n}"]}
{"filename": "src/Nebula.Caching.InMemory/KeyManager/InMemoryKeyManager.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Threading.Tasks;\nusing Nebula.Caching.Common.Constants;\nusing Nebula.Caching.Common.KeyManager;\nusing Nebula.Caching.InMemory.Attributes;\n\nnamespace Nebula.Caching.InMemory.KeyManager", "\nnamespace Nebula.Caching.InMemory.KeyManager\n{\n    public class InMemoryKeyManager : IKeyManager\n    {\n        public string ConvertCacheKeyToConfigKey(string key)\n        {\n            ArgumentNullException.ThrowIfNull(key);\n\n            return (key.Replace(KeyConstants.MethodFullPathSeparator, KeyConstants.ConfigMethodFullPathSeparator))\n                    .Replace(KeyConstants.MethodAndParametersSeparator, KeyConstants.ConfigMethodAndParametersSeparator);\n        }\n", "        public string GenerateKey(MethodInfo executedMethodInfo, MethodInfo serviceMethodInfo, string[] parameters)\n        {\n            ArgumentNullException.ThrowIfNull(argument: parameters);\n            return HasCustomCacheNameDefined(serviceMethodInfo) ?\n                                                            GetCustomCacheName(serviceMethodInfo)\n                                                            :\n                                                            GetDefaultCacheName(executedMethodInfo, parameters);\n        }\n\n        public bool HasCustomCacheNameDefined(MethodInfo methodInfo)\n        {\n            return GetCustomCacheName(methodInfo) is not null;\n        }\n", "        public bool HasCustomCacheNameDefined(MethodInfo methodInfo)\n        {\n            return GetCustomCacheName(methodInfo) is not null;\n        }\n\n        public string GetCustomCacheName(MethodInfo methodInfo)\n        {\n            var executedMethodAttribute = methodInfo.GetCustomAttributes(true)\n                        .FirstOrDefault(\n                                            x => typeof(InMemoryCacheAttribute).IsAssignableFrom(x.GetType())\n                                        );\n\n            var castedExecutedMethodAttribute = executedMethodAttribute as InMemoryCacheAttribute;\n\n            return castedExecutedMethodAttribute.CustomCacheName;\n        }\n", "        public string GetDefaultCacheName(MethodInfo methodInfo, string[] parameters)\n        {\n            string methodParamsAggregated = string.Join(KeyConstants.MethodAndParametersSeparator, parameters);\n            return $\"{methodInfo.DeclaringType.FullName}{KeyConstants.MethodAndParametersSeparator}{methodInfo.Name}{(parameters.Length > 0 ? KeyConstants.MethodAndParametersSeparator : \"\")}{methodParamsAggregated}\";\n        }\n    }\n}"]}
{"filename": "src/Nebula.Caching.InMemory/Attributes/InMemoryCacheAttribute.cs", "chunked_list": ["using Nebula.Caching.Common.Attributes;\n\nnamespace Nebula.Caching.InMemory.Attributes\n{\n    public class InMemoryCacheAttribute : BaseAttribute\n    {\n\n    }\n}"]}
{"filename": "src/Nebula.Caching.InMemory/Extensions/Extensions.cs", "chunked_list": ["using Microsoft.Extensions.DependencyInjection;\nusing Nebula.Caching.InMemory.Extensions.InMemoryExtensions;\nusing Nebula.Caching.InMemory.Extensions.InterceptorExtensions;\nusing Nebula.Caching.InMemory.Extensions.ManagerExtensions;\nusing Nebula.Caching.InMemory.Settings;\nusing Nebula.Caching.InMemory.UtilsExtensions;\n\nnamespace Nebula.Caching.InMemory.Extensions\n{\n    public static class Extensions\n    {", "{\n    public static class Extensions\n    {\n        public static IServiceCollection AddInMemoryChache(this IServiceCollection services, InMemoryConfigurations configs = null)\n        {\n            return services\n                        .AddInMemoryInterceptor()\n                        .AddInMemoryExtensions(configs)\n                        .AddManagerExtensions()\n                        .AddUtilsExtensions();\n        }\n    }\n}"]}
{"filename": "src/Nebula.Caching.InMemory/Extensions/InterceptorExtensions/InterceptorExtensions.cs", "chunked_list": ["using AspectCore.Configuration;\nusing AspectCore.Extensions.DependencyInjection;\nusing Microsoft.Extensions.DependencyInjection;\nusing Nebula.Caching.InMemory.Interceptors;\n\nnamespace Nebula.Caching.InMemory.Extensions.InterceptorExtensions\n{\n    public static class InterceptorExtensions\n    {\n        public static IServiceCollection AddInMemoryInterceptor(this IServiceCollection services)\n        {\n            services.AddSingleton<InMemoryCacheInterceptor>();\n\n            services.ConfigureDynamicProxy(config =>\n            {\n                config\n                    .Interceptors\n                    .AddServiced<InMemoryCacheInterceptor>();\n            });\n            return services;\n        }\n    }\n}", "        public static IServiceCollection AddInMemoryInterceptor(this IServiceCollection services)\n        {\n            services.AddSingleton<InMemoryCacheInterceptor>();\n\n            services.ConfigureDynamicProxy(config =>\n            {\n                config\n                    .Interceptors\n                    .AddServiced<InMemoryCacheInterceptor>();\n            });\n            return services;\n        }\n    }\n}"]}
{"filename": "src/Nebula.Caching.InMemory/Extensions/InMemoryExtensions/InMemoryExtensions.cs", "chunked_list": ["using Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Nebula.Caching.Common.Constants;\nusing Nebula.Caching.InMemory.Settings;\n\nnamespace Nebula.Caching.InMemory.Extensions.InMemoryExtensions\n{\n    public static class InMemoryExtensions\n    {\n        public static IServiceCollection AddInMemoryExtensions(this IServiceCollection services, InMemoryConfigurations inMemoryConfigs)\n        {\n            // CreateDefaultInMemoryConfigurationsIfNull(inMemoryConfigs);\n            // SetDefaultValuesBasedOnInMemoryConfigurations(inMemoryConfigs);\n            // InjectInMemoryOptionsObject(services, inMemoryConfigs);\n", "        public static IServiceCollection AddInMemoryExtensions(this IServiceCollection services, InMemoryConfigurations inMemoryConfigs)\n        {\n            // CreateDefaultInMemoryConfigurationsIfNull(inMemoryConfigs);\n            // SetDefaultValuesBasedOnInMemoryConfigurations(inMemoryConfigs);\n            // InjectInMemoryOptionsObject(services, inMemoryConfigs);\n\n            if (inMemoryConfigs is null)\n            {\n                inMemoryConfigs = new InMemoryConfigurations\n                {\n                    ConfigurationSection = \"InMemory\"\n                };\n            }\n\n            CacheDurationConstants.DefaultCacheDurationInSeconds = inMemoryConfigs.DefaultCacheDurationInSeconds;\n\n            CacheConfigurationConstants.ConfigurationSection = inMemoryConfigs.ConfigurationSection;\n\n            services.AddSingleton<InMemoryOptions>(ctx =>\n            {\n                var configuration = ctx.GetService<IConfiguration>();\n                var inMemoryOptions = configuration.GetSection(inMemoryConfigs.ConfigurationSection).Get<InMemoryOptions>();\n                inMemoryOptions.ConfigurationRoot = inMemoryConfigs.ConfigurationSection;\n                return inMemoryOptions;\n            });\n\n            return services;\n        }\n", "        private static void CreateDefaultInMemoryConfigurationsIfNull(InMemoryConfigurations inMemoryConfigs)\n        {\n            if (inMemoryConfigs is null)\n            {\n                inMemoryConfigs = new InMemoryConfigurations\n                {\n                    ConfigurationSection = \"InMemory\"\n                };\n            }\n        }\n", "        private static void SetDefaultValuesBasedOnInMemoryConfigurations(InMemoryConfigurations inMemoryConfigs)\n        {\n            CacheDurationConstants.DefaultCacheDurationInSeconds = inMemoryConfigs.DefaultCacheDurationInSeconds;\n\n            CacheConfigurationConstants.ConfigurationSection = inMemoryConfigs.ConfigurationSection;\n        }\n\n        private static void InjectInMemoryOptionsObject(IServiceCollection services, InMemoryConfigurations inMemoryConfigs)\n        {\n            services.AddSingleton<InMemoryOptions>(ctx =>\n            {\n                var configuration = ctx.GetService<IConfiguration>();\n                var inMemoryOptions = configuration.GetSection(inMemoryConfigs.ConfigurationSection).Get<InMemoryOptions>();\n                inMemoryOptions.ConfigurationRoot = inMemoryConfigs.ConfigurationSection;\n                return inMemoryOptions;\n            });\n        }\n\n    }\n}"]}
{"filename": "src/Nebula.Caching.InMemory/Extensions/ManagerExtensions/ManagerExtensions.cs", "chunked_list": ["using Microsoft.Extensions.Caching.Memory;\nusing Microsoft.Extensions.DependencyInjection;\nusing Nebula.Caching.Common.CacheManager;\nusing Nebula.Caching.Common.Compression;\nusing Nebula.Caching.Common.KeyManager;\nusing Nebula.Caching.InMemory.CacheManager;\nusing Nebula.Caching.InMemory.KeyManager;\n\nnamespace Nebula.Caching.InMemory.Extensions.ManagerExtensions\n{\n    public static class ManagerExtensions\n    {", "namespace Nebula.Caching.InMemory.Extensions.ManagerExtensions\n{\n    public static class ManagerExtensions\n    {\n        public static IServiceCollection AddManagerExtensions(this IServiceCollection services)\n        {\n            services.AddMemoryCache();\n\n            services.AddScoped<ICacheManager>(serviceProvider =>\n            {\n                var memoryCache = serviceProvider.GetRequiredService<IMemoryCache>();\n                var compression = serviceProvider.GetRequiredService<GZipCompression>();\n\n                return new InMemoryCacheManager(memoryCache, compression);\n            });\n\n            services.AddScoped<IKeyManager>(serviceProvider =>\n            {\n                return new InMemoryKeyManager();\n            });\n\n            return services;\n        }\n    }\n}"]}
{"filename": "src/Nebula.Caching.InMemory/Settings/InMemoryOptions.cs", "chunked_list": ["using Common.Settings;\n\nnamespace Nebula.Caching.InMemory.Settings\n{\n    public class InMemoryOptions : BaseOptions\n    {\n        public override string ConfigurationRoot { get; set; } = \"InMemory\";\n    }\n}"]}
{"filename": "src/Nebula.Caching.InMemory/Settings/InMemoryConfigurations.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Nebula.Caching.Common.Settings;\n\nnamespace Nebula.Caching.InMemory.Settings\n{\n    public class InMemoryConfigurations : Configurations\n    {\n\n    }\n}", "    public class InMemoryConfigurations : Configurations\n    {\n\n    }\n}"]}
{"filename": "src/Nebula.Caching.InMemory/Interceptors/InMemoryCacheInterceptor.cs", "chunked_list": ["using AspectCore.DynamicProxy;\nusing Nebula.Caching.Common.CacheManager;\nusing Nebula.Caching.Common.KeyManager;\nusing Nebula.Caching.Common.Utils;\nusing Nebula.Caching.InMemory.Attributes;\nusing Newtonsoft.Json;\n\nnamespace Nebula.Caching.InMemory.Interceptors\n{\n    public class InMemoryCacheInterceptor : AbstractInterceptorAttribute\n    {", "{\n    public class InMemoryCacheInterceptor : AbstractInterceptorAttribute\n    {\n        private ICacheManager _cacheManager { get; set; }\n        private IKeyManager _keyManager { get; set; }\n        private IContextUtils _utils { get; set; }\n        private AspectContext context { get; set; }\n        private AspectDelegate next { get; set; }\n\n\n        public InMemoryCacheInterceptor(IContextUtils utils, ICacheManager cacheManager, IKeyManager keyManager)\n        {\n            _cacheManager = cacheManager;\n            _utils = utils;\n            _keyManager = keyManager;\n        }\n", "        public async override Task Invoke(AspectContext context, AspectDelegate next)\n        {\n            this.context = context;\n            this.next = next;\n            if (ExecutedMethodHasInMemoryCacheAttribute()) await ExecuteMethodThatHasInMemoryCacheAttribute().ConfigureAwait(false);\n            else await ContinueExecutionForNonCacheableMethod().ConfigureAwait(false);\n        }\n\n        private bool ExecutedMethodHasInMemoryCacheAttribute()\n        {\n            return _utils.IsAttributeOfType<InMemoryCacheAttribute>(context);\n        }\n", "        private bool ExecutedMethodHasInMemoryCacheAttribute()\n        {\n            return _utils.IsAttributeOfType<InMemoryCacheAttribute>(context);\n        }\n\n        private async Task ExecuteMethodThatHasInMemoryCacheAttribute()\n        {\n            if (await CacheExistsAsync().ConfigureAwait(false))\n            {\n                await ReturnCachedValueAsync().ConfigureAwait(false);\n            }\n            else\n            {\n                await next(context).ConfigureAwait(false);\n                await CacheValueAsync().ConfigureAwait(false);\n            }\n        }\n", "        private async Task ContinueExecutionForNonCacheableMethod()\n        {\n            await next(context).ConfigureAwait(false);\n        }\n\n        private async Task ReturnCachedValueAsync()\n        {\n            var value = await _cacheManager.GetAsync(GenerateKey()).ConfigureAwait(false);\n\n            if (context.IsAsync())\n            {\n                dynamic objectType = context.ServiceMethod.ReturnType.GetGenericArguments().First();\n                dynamic deserializedObject = JsonConvert.DeserializeObject(value, objectType);\n                context.ReturnValue = Task.FromResult(deserializedObject);\n            }\n            else\n            {\n                var objectType = context.ServiceMethod.ReturnType;\n                context.ReturnValue = JsonConvert.DeserializeObject(value, objectType);\n            }\n        }\n", "            if (context.IsAsync())\n            {\n                dynamic objectType = context.ServiceMethod.ReturnType.GetGenericArguments().First();\n                dynamic deserializedObject = JsonConvert.DeserializeObject(value, objectType);\n                context.ReturnValue = Task.FromResult(deserializedObject);\n            }\n            else\n            {\n                var objectType = context.ServiceMethod.ReturnType;\n                context.ReturnValue = JsonConvert.DeserializeObject(value, objectType);\n            }\n        }\n", "        private async Task CacheValueAsync()\n        {\n            string value = \"\";\n\n            if (context.IsAsync())\n            {\n                Type returnType = context.ReturnValue.GetType();\n                value = JsonConvert.SerializeObject(await context.UnwrapAsyncReturnValue().ConfigureAwait(false));\n            }\n            else\n            {\n                var returnValue = context.ReturnValue;\n                value = JsonConvert.SerializeObject(returnValue);\n            }\n\n            var key = GenerateKey();\n            var expiration = TimeSpan.FromSeconds(_utils.GetCacheDuration<InMemoryCacheAttribute>(key, context));\n\n            await _cacheManager.SetAsync(key, value, expiration).ConfigureAwait(false);\n        }\n", "        private async Task<bool> CacheExistsAsync()\n        {\n            return await _cacheManager.CacheExistsAsync(GenerateKey()).ConfigureAwait(false);\n        }\n\n        private string GenerateKey()\n        {\n            return _keyManager.GenerateKey(_utils.GetExecutedMethodInfo(context), _utils.GetServiceMethodInfo(context), _utils.GetMethodParameters(context));\n        }\n    }\n}"]}
{"filename": "src/Nebula.Caching.InMemory/CacheManager/InMemoryCacheManager.cs", "chunked_list": ["using System.Text;\nusing Microsoft.Extensions.Caching.Memory;\nusing Nebula.Caching.Common.CacheManager;\nusing Nebula.Caching.Common.Compression;\n\nnamespace Nebula.Caching.InMemory.CacheManager\n{\n    public class InMemoryCacheManager : ICacheManager\n    {\n        private readonly IMemoryCache _memoryCache;\n        private readonly GZipCompression _gzipCompression;\n\n        public InMemoryCacheManager(IMemoryCache memoryCache, GZipCompression gzipCompression)\n        {\n            _memoryCache = memoryCache;\n            _gzipCompression = gzipCompression;\n        }\n", "        private readonly IMemoryCache _memoryCache;\n        private readonly GZipCompression _gzipCompression;\n\n        public InMemoryCacheManager(IMemoryCache memoryCache, GZipCompression gzipCompression)\n        {\n            _memoryCache = memoryCache;\n            _gzipCompression = gzipCompression;\n        }\n\n        public bool CacheExists(string key)\n        {\n            return _memoryCache.TryGetValue(key, out _);\n        }\n", "        public bool CacheExists(string key)\n        {\n            return _memoryCache.TryGetValue(key, out _);\n        }\n\n        public async Task<bool> CacheExistsAsync(string key)\n        {\n            return await Task.Run(() => CacheExists(key)).ConfigureAwait(false);\n        }\n\n        public string Get(string key)\n        {\n            _memoryCache.TryGetValue(key, out byte[] value);\n            var data = _gzipCompression.Decompress(value);\n            return Encoding.UTF8.GetString(data);\n        }\n", "        public string Get(string key)\n        {\n            _memoryCache.TryGetValue(key, out byte[] value);\n            var data = _gzipCompression.Decompress(value);\n            return Encoding.UTF8.GetString(data);\n        }\n\n        public async Task<string> GetAsync(string key)\n        {\n            return await Task.Run(() => Get(key)).ConfigureAwait(false);\n        }\n", "        public void Set(string key, string value, TimeSpan expiration)\n        {\n            var cacheEntryOptions = new MemoryCacheEntryOptions\n            {\n                AbsoluteExpirationRelativeToNow = expiration\n            };\n\n            byte[] compressedData = _gzipCompression.Compress(Encoding.UTF8.GetBytes(value));\n\n            _memoryCache.Set(key, compressedData, cacheEntryOptions);\n        }\n", "        public async Task SetAsync(string key, string value, TimeSpan expiration)\n        {\n            await Task.Run(() => Set(key, value, expiration)).ConfigureAwait(false);\n        }\n    }\n}"]}
{"filename": "src/Nebula.Caching.InMemory/UtilsExtensions/UtilsExtensions.cs", "chunked_list": ["using Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Nebula.Caching.Common.Compression;\nusing Nebula.Caching.Common.Utils;\nusing Nebula.Caching.InMemory.KeyManager;\nusing Nebula.Caching.InMemory.Settings;\n\nnamespace Nebula.Caching.InMemory.UtilsExtensions\n{\n    public static class UtilsExtensions\n    {", "{\n    public static class UtilsExtensions\n    {\n        public static IServiceCollection AddUtilsExtensions(this IServiceCollection services)\n        {\n            services.AddScoped<IContextUtils>(serviceProvider =>\n            {\n                var configuration = serviceProvider.GetService<IConfiguration>();\n                var inMemoryOptions = serviceProvider.GetService<InMemoryOptions>();\n                return new ContextUtils(new InMemoryKeyManager(), configuration, inMemoryOptions);\n            });\n\n            services.AddScoped<GZipCompression>();\n\n            return services;\n        }\n    }\n}"]}
{"filename": "src/Nebula.Caching.Redis/KeyManager/RedisKeyManager.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Threading.Tasks;\nusing AspectCore.DynamicProxy;\nusing AspectCore.DynamicProxy.Parameters;\nusing Nebula.Caching.Common.Constants;\nusing Nebula.Caching.Common.KeyManager;\nusing Nebula.Caching.Redis.Attributes;", "using Nebula.Caching.Common.KeyManager;\nusing Nebula.Caching.Redis.Attributes;\n\nnamespace Nebula.Caching.Redis.KeyManager\n{\n    public class RedisKeyManager : IKeyManager\n    {\n\n        public RedisKeyManager()\n        {\n\n        }\n", "        public string GenerateKey(MethodInfo executedMethodInfo, MethodInfo serviceMethodInfo, string[] parameters)\n        {\n            ArgumentNullException.ThrowIfNull(argument: parameters);\n            return HasCustomCacheNameDefined(serviceMethodInfo) ?\n                                                            GetCustomCacheName(serviceMethodInfo)\n                                                            :\n                                                            GetDefaultCacheName(executedMethodInfo, parameters);\n        }\n\n        public bool HasCustomCacheNameDefined(MethodInfo methodInfo)\n        {\n            var executedMethodAttribute = methodInfo.GetCustomAttributes(true)\n                                    .FirstOrDefault(\n                                                        x => typeof(RedisCacheAttribute).IsAssignableFrom(x.GetType())\n                                                    );\n\n            var castedExecutedMethodAttribute = executedMethodAttribute as RedisCacheAttribute;\n            return castedExecutedMethodAttribute.CustomCacheName is not null;\n        }\n", "        public bool HasCustomCacheNameDefined(MethodInfo methodInfo)\n        {\n            var executedMethodAttribute = methodInfo.GetCustomAttributes(true)\n                                    .FirstOrDefault(\n                                                        x => typeof(RedisCacheAttribute).IsAssignableFrom(x.GetType())\n                                                    );\n\n            var castedExecutedMethodAttribute = executedMethodAttribute as RedisCacheAttribute;\n            return castedExecutedMethodAttribute.CustomCacheName is not null;\n        }\n", "        public string GetCustomCacheName(MethodInfo methodInfo)\n        {\n            var executedMethodAttribute = methodInfo.GetCustomAttributes(true)\n                        .FirstOrDefault(\n                                            x => typeof(RedisCacheAttribute).IsAssignableFrom(x.GetType())\n                                        );\n\n            var castedExecutedMethodAttribute = executedMethodAttribute as RedisCacheAttribute;\n\n            return castedExecutedMethodAttribute.CustomCacheName;\n        }\n", "        public string GetDefaultCacheName(MethodInfo methodInfo, string[] parameters)\n        {\n            string methodParamsAggregated = string.Join(KeyConstants.MethodAndParametersSeparator, parameters);\n            return $\"{methodInfo.DeclaringType.FullName}{KeyConstants.MethodAndParametersSeparator}{methodInfo.Name}{(parameters.Length > 0 ? KeyConstants.MethodAndParametersSeparator : \"\")}{methodParamsAggregated}\";\n        }\n\n        public string ConvertCacheKeyToConfigKey(string key)\n        {\n            ArgumentNullException.ThrowIfNull(key);\n\n            return (key.Replace(KeyConstants.MethodFullPathSeparator, KeyConstants.ConfigMethodFullPathSeparator))\n                    .Replace(KeyConstants.MethodAndParametersSeparator, KeyConstants.ConfigMethodAndParametersSeparator);\n        }\n    }\n}"]}
{"filename": "src/Nebula.Caching.Redis/Attributes/RedisCacheAttribute.cs", "chunked_list": ["using Nebula.Caching.Common.Attributes;\n\nnamespace Nebula.Caching.Redis.Attributes\n{\n    public class RedisCacheAttribute : BaseAttribute\n    {\n    }\n}"]}
{"filename": "src/Nebula.Caching.Redis/Extensions/Extensions.cs", "chunked_list": ["using System.Diagnostics.CodeAnalysis;\nusing Microsoft.Extensions.DependencyInjection;\nusing Nebula.Caching.Redis.Settings;\nusing Redis.Extensions.InterceptorExtensions;\nusing Redis.Extensions.ManagerExtensions;\nusing Redis.Extensions.RedisExtensions;\nusing Redis.Extensions.UtilsExtensions;\n\nnamespace Nebula.Caching.Redis.Extensions\n{", "namespace Nebula.Caching.Redis.Extensions\n{\n    [ExcludeFromCodeCoverage]\n    public static class Extensions\n    {\n        public static IServiceCollection AddRedisChache(this IServiceCollection services, RedisConfigurations configs)\n        {\n            return services\n                        .AddRedisInterceptor()\n                        .AddRedisExtensions(configs)\n                        .AddManagerExtensions()\n                        .AddUtilsExtensions();\n        }\n    }\n}"]}
{"filename": "src/Nebula.Caching.Redis/Extensions/InterceptorExtensions/InterceptorExtensions.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing AspectCore.Configuration;\nusing AspectCore.Extensions.DependencyInjection;\nusing Common.Settings;\nusing Microsoft.Extensions.DependencyInjection;\nusing Nebula.Caching.Redis.Interceptors;", "using Microsoft.Extensions.DependencyInjection;\nusing Nebula.Caching.Redis.Interceptors;\n\nnamespace Redis.Extensions.InterceptorExtensions\n{\n    [ExcludeFromCodeCoverage]\n    public static class InterceptorExtensions\n    {\n        public static IServiceCollection AddRedisInterceptor(this IServiceCollection services)\n        {\n            services.AddSingleton<RedisCacheInterceptor>();\n\n            services.ConfigureDynamicProxy(config =>\n            {\n                config\n                    .Interceptors\n                    .AddServiced<RedisCacheInterceptor>();\n            });\n            return services;\n        }\n    }\n}", "        public static IServiceCollection AddRedisInterceptor(this IServiceCollection services)\n        {\n            services.AddSingleton<RedisCacheInterceptor>();\n\n            services.ConfigureDynamicProxy(config =>\n            {\n                config\n                    .Interceptors\n                    .AddServiced<RedisCacheInterceptor>();\n            });\n            return services;\n        }\n    }\n}"]}
{"filename": "src/Nebula.Caching.Redis/Extensions/ManagerExtensions/ManagerExtensions.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.DependencyInjection;\nusing Nebula.Caching.Common.CacheManager;\nusing Nebula.Caching.Common.KeyManager;\nusing Nebula.Caching.Redis.CacheManager;\nusing Nebula.Caching.Redis.KeyManager;", "using Nebula.Caching.Redis.CacheManager;\nusing Nebula.Caching.Redis.KeyManager;\nusing StackExchange.Redis;\n\nnamespace Redis.Extensions.ManagerExtensions\n{\n    [ExcludeFromCodeCoverage]\n    public static class ManagerExtensions\n    {\n\n        public static IServiceCollection AddManagerExtensions(this IServiceCollection services)\n        {\n            services.AddScoped<ICacheManager>(serviceProvider =>\n            {\n                var database = serviceProvider.GetService<IDatabase>();\n                return new RedisCacheManager(database);\n            });\n\n            services.AddScoped<IKeyManager>(serviceProvider =>\n            {\n                return new RedisKeyManager();\n            });\n\n            return services;\n        }\n\n    }\n}", "        public static IServiceCollection AddManagerExtensions(this IServiceCollection services)\n        {\n            services.AddScoped<ICacheManager>(serviceProvider =>\n            {\n                var database = serviceProvider.GetService<IDatabase>();\n                return new RedisCacheManager(database);\n            });\n\n            services.AddScoped<IKeyManager>(serviceProvider =>\n            {\n                return new RedisKeyManager();\n            });\n\n            return services;\n        }\n\n    }\n}"]}
{"filename": "src/Nebula.Caching.Redis/Extensions/UtilsExtensions/UtilsExtensions.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Nebula.Caching.Common.Utils;\nusing Nebula.Caching.Redis.KeyManager;\nusing Redis.Settings;", "using Nebula.Caching.Redis.KeyManager;\nusing Redis.Settings;\n\nnamespace Redis.Extensions.UtilsExtensions\n{\n    [ExcludeFromCodeCoverage]\n    public static class UtilsExtensions\n    {\n        public static IServiceCollection AddUtilsExtensions(this IServiceCollection services)\n        {\n            services.AddScoped<IContextUtils>(serviceProvider =>\n            {\n                var configuration = serviceProvider.GetService<IConfiguration>();\n                var redisOptions = serviceProvider.GetService<RedisOptions>();\n                return new ContextUtils(new RedisKeyManager(), configuration, redisOptions);\n            });\n\n            return services;\n        }\n    }\n}", "        public static IServiceCollection AddUtilsExtensions(this IServiceCollection services)\n        {\n            services.AddScoped<IContextUtils>(serviceProvider =>\n            {\n                var configuration = serviceProvider.GetService<IConfiguration>();\n                var redisOptions = serviceProvider.GetService<RedisOptions>();\n                return new ContextUtils(new RedisKeyManager(), configuration, redisOptions);\n            });\n\n            return services;\n        }\n    }\n}"]}
{"filename": "src/Nebula.Caching.Redis/Extensions/RedisExtensions/RedisExtensions.cs", "chunked_list": ["using Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Nebula.Caching.Common.Constants;\nusing Nebula.Caching.Redis.Settings;\nusing Redis.Settings;\nusing StackExchange.Redis;\n\nnamespace Redis.Extensions.RedisExtensions\n{\n    public static class RedisExtensions\n    {", "{\n    public static class RedisExtensions\n    {\n        public static IServiceCollection AddRedisExtensions(this IServiceCollection services, RedisConfigurations configs)\n        {\n            CacheDurationConstants.DefaultCacheDurationInSeconds = configs.DefaultCacheDurationInSeconds;\n\n            CacheConfigurationConstants.ConfigurationSection = \"RedisConfig\";\n\n            services.AddSingleton<RedisOptions>(ctx =>\n            {\n                var configuration = ctx.GetService<IConfiguration>();\n                var redisOptions = configuration.GetSection(configs.ConfigurationSection).Get<RedisOptions>();\n                redisOptions.ConfigurationRoot = configs.ConfigurationSection;\n                return redisOptions;\n            });\n", "            if (configs.ConfigurationFlavour == RedisConfigurationFlavour.Vanilla)\n            {\n                services.AddSingleton<IConnectionMultiplexer>(ctx =>\n                {\n                    var options = ctx.GetService<RedisOptions>();\n                    return ConnectionMultiplexer.Connect(options.CacheServiceUrl, configs.Log);\n                });\n            }\n            else if (configs.ConfigurationFlavour == RedisConfigurationFlavour.Configured)\n            {\n                if (configs.Configuration != null)\n                {\n                    services.AddSingleton<IConnectionMultiplexer>(ctx =>\n                    {\n                        return ConnectionMultiplexer.Connect(configs.Configuration, configs.Log);\n                    });\n                }\n                else\n                {\n                    services.AddSingleton<IConnectionMultiplexer>(ctx =>\n                    {\n                        var options = ctx.GetService<RedisOptions>();\n                        return ConnectionMultiplexer.Connect(options.CacheServiceUrl, configs.Configure, configs.Log);\n                    });\n                }\n            }\n\n            services.AddSingleton<IDatabase>(serviceProvider =>\n            {\n                var redis = serviceProvider.GetService<IConnectionMultiplexer>();\n                return redis.GetDatabase();\n            });\n\n            return services;\n        }\n\n    }\n}", "            else if (configs.ConfigurationFlavour == RedisConfigurationFlavour.Configured)\n            {\n                if (configs.Configuration != null)\n                {\n                    services.AddSingleton<IConnectionMultiplexer>(ctx =>\n                    {\n                        return ConnectionMultiplexer.Connect(configs.Configuration, configs.Log);\n                    });\n                }\n                else\n                {\n                    services.AddSingleton<IConnectionMultiplexer>(ctx =>\n                    {\n                        var options = ctx.GetService<RedisOptions>();\n                        return ConnectionMultiplexer.Connect(options.CacheServiceUrl, configs.Configure, configs.Log);\n                    });\n                }\n            }\n\n            services.AddSingleton<IDatabase>(serviceProvider =>\n            {\n                var redis = serviceProvider.GetService<IConnectionMultiplexer>();\n                return redis.GetDatabase();\n            });\n\n            return services;\n        }\n\n    }\n}"]}
{"filename": "src/Nebula.Caching.Redis/Settings/RedisConfigurationFlavour.cs", "chunked_list": ["namespace Redis.Settings\n{\n    public enum RedisConfigurationFlavour\n    {\n        Vanilla,\n        Configured\n    }\n}"]}
{"filename": "src/Nebula.Caching.Redis/Settings/RedisOptions.cs", "chunked_list": ["using System.Collections.Concurrent;\nusing System.Diagnostics.CodeAnalysis;\nusing Common.Settings;\n\nnamespace Redis.Settings\n{\n    [ExcludeFromCodeCoverage]\n    public class RedisOptions : BaseOptions\n    {\n        public override string ConfigurationRoot { get; set; } = \"Redis\";\n    }\n}", "        public override string ConfigurationRoot { get; set; } = \"Redis\";\n    }\n}"]}
{"filename": "src/Nebula.Caching.Redis/Settings/RedisConfigurations.cs", "chunked_list": ["using Nebula.Caching.Common.Settings;\nusing Redis.Settings;\nusing StackExchange.Redis;\n\nnamespace Nebula.Caching.Redis.Settings\n{\n    public class RedisConfigurations : Configurations\n    {\n        public RedisConfigurationFlavour ConfigurationFlavour { get; set; }\n        public Action<ConfigurationOptions>? Configure { get; set; }\n        public ConfigurationOptions? Configuration { get; set; }\n        public TextWriter? Log { get; set; }\n    }\n}", "        public RedisConfigurationFlavour ConfigurationFlavour { get; set; }\n        public Action<ConfigurationOptions>? Configure { get; set; }\n        public ConfigurationOptions? Configuration { get; set; }\n        public TextWriter? Log { get; set; }\n    }\n}"]}
{"filename": "src/Nebula.Caching.Redis/Interceptors/RedisCacheInterceptor.cs", "chunked_list": ["using System.Reflection;\nusing System.Runtime.CompilerServices;\nusing System.Text;\nusing AspectCore.DynamicProxy;\nusing AspectCore.DynamicProxy.Parameters;\nusing AspectCore.Extensions.Reflection;\nusing Microsoft.Extensions.DependencyInjection;\nusing Nebula.Caching.Common.CacheManager;\nusing Nebula.Caching.Common.KeyManager;\nusing Nebula.Caching.Common.Utils;", "using Nebula.Caching.Common.KeyManager;\nusing Nebula.Caching.Common.Utils;\nusing Nebula.Caching.Redis.Attributes;\nusing Newtonsoft.Json;\nusing StackExchange.Redis;\n\nnamespace Nebula.Caching.Redis.Interceptors\n{\n    public class RedisCacheInterceptor : AbstractInterceptorAttribute\n    {\n        private ICacheManager _cacheManager { get; set; }", "    public class RedisCacheInterceptor : AbstractInterceptorAttribute\n    {\n        private ICacheManager _cacheManager { get; set; }\n        private IKeyManager _keyManager { get; set; }\n        private IContextUtils _utils { get; set; }\n        private AspectContext context { get; set; }\n        private AspectDelegate next { get; set; }\n\n\n        public RedisCacheInterceptor(ICacheManager cacheManager, IKeyManager keyManager, IContextUtils utils)\n        {\n            _cacheManager = cacheManager;\n            _keyManager = keyManager;\n            _utils = utils;\n        }\n", "        public async override Task Invoke(AspectContext context, AspectDelegate next)\n        {\n            this.context = context;\n            this.next = next;\n            if (ExecutedMethodHasRedisCacheAttribute()) await ExecuteMethodThatHasRedisCacheAttribute().ConfigureAwait(false);\n            else await ContinueExecutionForNonCacheableMethod().ConfigureAwait(false);\n        }\n\n        private bool ExecutedMethodHasRedisCacheAttribute()\n        {\n            return _utils.IsAttributeOfType<RedisCacheAttribute>(context);\n        }\n", "        private bool ExecutedMethodHasRedisCacheAttribute()\n        {\n            return _utils.IsAttributeOfType<RedisCacheAttribute>(context);\n        }\n\n        private async Task ExecuteMethodThatHasRedisCacheAttribute()\n        {\n            if (await CacheExistsAsync().ConfigureAwait(false))\n            {\n                await ReturnCachedValueAsync().ConfigureAwait(false);\n            }\n            else\n            {\n                await next(context).ConfigureAwait(false);\n                await CacheValueAsync().ConfigureAwait(false);\n            }\n        }\n", "        private async Task ContinueExecutionForNonCacheableMethod()\n        {\n            await next(context).ConfigureAwait(false);\n        }\n\n        private async Task ReturnCachedValueAsync()\n        {\n            var value = await _cacheManager.GetAsync(GenerateKey()).ConfigureAwait(false);\n\n            if (context.IsAsync())\n            {\n                dynamic objectType = context.ServiceMethod.ReturnType.GetGenericArguments().First();\n                dynamic deserializedObject = JsonConvert.DeserializeObject(value, objectType);\n                context.ReturnValue = Task.FromResult(deserializedObject);\n            }\n            else\n            {\n                var objectType = context.ServiceMethod.ReturnType;\n                context.ReturnValue = JsonConvert.DeserializeObject(value, objectType);\n            }\n        }\n", "            if (context.IsAsync())\n            {\n                dynamic objectType = context.ServiceMethod.ReturnType.GetGenericArguments().First();\n                dynamic deserializedObject = JsonConvert.DeserializeObject(value, objectType);\n                context.ReturnValue = Task.FromResult(deserializedObject);\n            }\n            else\n            {\n                var objectType = context.ServiceMethod.ReturnType;\n                context.ReturnValue = JsonConvert.DeserializeObject(value, objectType);\n            }\n        }\n", "        private async Task CacheValueAsync()\n        {\n            string value = \"\";\n\n            if (context.IsAsync())\n            {\n                Type returnType = context.ReturnValue.GetType();\n                value = JsonConvert.SerializeObject(await context.UnwrapAsyncReturnValue().ConfigureAwait(false));\n            }\n            else\n            {\n                var returnValue = context.ReturnValue;\n                value = JsonConvert.SerializeObject(returnValue);\n            }\n\n            var key = GenerateKey();\n            var expiration = TimeSpan.FromSeconds(_utils.GetCacheDuration<RedisCacheAttribute>(GenerateKey(), context));\n\n            await _cacheManager.SetAsync(key, value, expiration).ConfigureAwait(false);\n        }\n", "        private async Task<bool> CacheExistsAsync()\n        {\n            return await _cacheManager.CacheExistsAsync(GenerateKey()).ConfigureAwait(false);\n        }\n\n        private string GenerateKey()\n        {\n            return _keyManager.GenerateKey(_utils.GetExecutedMethodInfo(context), _utils.GetServiceMethodInfo(context), _utils.GetMethodParameters(context));\n        }\n    }\n}"]}
{"filename": "src/Nebula.Caching.Redis/CacheManager/RedisCacheManager.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Nebula.Caching.Common.CacheManager;\nusing StackExchange.Redis;\n\nnamespace Nebula.Caching.Redis.CacheManager\n{\n    public class RedisCacheManager : ICacheManager\n    {", "namespace Nebula.Caching.Redis.CacheManager\n{\n    public class RedisCacheManager : ICacheManager\n    {\n        private IDatabase _redis;\n\n        public RedisCacheManager(IDatabase redis)\n        {\n            _redis = redis;\n        }\n", "        public bool CacheExists(string key)\n        {\n            ArgumentNullException.ThrowIfNull(key);\n\n            return _redis.StringGet(key) != RedisValue.Null;\n        }\n\n        public string Get(string key)\n        {\n            ArgumentNullException.ThrowIfNull(key);\n\n            return _redis.StringGet(key).ToString();\n        }\n", "        public void Set(string key, string value, TimeSpan expiration)\n        {\n            ArgumentNullException.ThrowIfNull(key);\n            ArgumentNullException.ThrowIfNull(value);\n            ArgumentNullException.ThrowIfNull(expiration);\n\n            _redis.StringSet(key, value, expiration);\n        }\n\n        public async Task<bool> CacheExistsAsync(string key)\n        {\n            ArgumentNullException.ThrowIfNull(key);\n            return (await _redis.StringGetAsync(key).ConfigureAwait(false)) != RedisValue.Null;\n        }\n", "        public async Task<bool> CacheExistsAsync(string key)\n        {\n            ArgumentNullException.ThrowIfNull(key);\n            return (await _redis.StringGetAsync(key).ConfigureAwait(false)) != RedisValue.Null;\n        }\n\n        public async Task<string> GetAsync(string key)\n        {\n            ArgumentNullException.ThrowIfNull(key);\n            return (await _redis.StringGetAsync(key).ConfigureAwait(false)).ToString();\n        }\n", "        public async Task SetAsync(string key, string value, TimeSpan expiration)\n        {\n            ArgumentNullException.ThrowIfNull(key);\n            ArgumentNullException.ThrowIfNull(value);\n            ArgumentNullException.ThrowIfNull(expiration);\n\n            await _redis.StringSetAsync(key, value, expiration);\n        }\n    }\n}"]}
{"filename": "src/Nebula.Caching.Common/KeyManager/IKeyManager.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Threading.Tasks;\nusing AspectCore.DynamicProxy;\nusing AspectCore.DynamicProxy.Parameters;\n\nnamespace Nebula.Caching.Common.KeyManager\n{\n    public interface IKeyManager\n    {\n        string GenerateKey(MethodInfo executedMethodInfo, MethodInfo serviceMethodInfo, string[] parameters);\n        string ConvertCacheKeyToConfigKey(string key);\n    }\n}", "namespace Nebula.Caching.Common.KeyManager\n{\n    public interface IKeyManager\n    {\n        string GenerateKey(MethodInfo executedMethodInfo, MethodInfo serviceMethodInfo, string[] parameters);\n        string ConvertCacheKeyToConfigKey(string key);\n    }\n}"]}
{"filename": "src/Nebula.Caching.Common/Attributes/BaseAttribute.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Nebula.Caching.Common.Constants;\n\nnamespace Nebula.Caching.Common.Attributes\n{\n    [AttributeUsage(AttributeTargets.Method, Inherited = true)]", "{\n    [AttributeUsage(AttributeTargets.Method, Inherited = true)]\n    [ExcludeFromCodeCoverage]\n    public class BaseAttribute : Attribute\n    {\n        public int CacheDurationInSeconds { get; set; } = CacheDurationConstants.DefaultCacheDurationInSeconds;\n        public string? CacheGroup { get; set; }\n        public string? CustomCacheName { get; set; }\n    }\n}"]}
{"filename": "src/Nebula.Caching.Common/Utils/ContextUtils.cs", "chunked_list": ["using System.Collections.Generic;\nusing System.Reflection;\nusing AspectCore.DynamicProxy;\nusing AspectCore.DynamicProxy.Parameters;\nusing Common.Settings;\nusing Microsoft.Extensions.Configuration;\nusing Nebula.Caching.Common.Attributes;\nusing Nebula.Caching.Common.KeyManager;\n\nnamespace Nebula.Caching.Common.Utils", "\nnamespace Nebula.Caching.Common.Utils\n{\n    public class ContextUtils : IContextUtils\n    {\n\n        private IKeyManager _keyManager;\n        private IConfiguration _configuration;\n        private BaseOptions _baseOptions;\n\n        public ContextUtils(IKeyManager keyManager, IConfiguration configuration, BaseOptions baseOptions)\n        {\n            _keyManager = keyManager;\n            _configuration = configuration;\n            _baseOptions = baseOptions;\n        }\n", "        private BaseOptions _baseOptions;\n\n        public ContextUtils(IKeyManager keyManager, IConfiguration configuration, BaseOptions baseOptions)\n        {\n            _keyManager = keyManager;\n            _configuration = configuration;\n            _baseOptions = baseOptions;\n        }\n\n        public int GetCacheDuration<T>(string key, AspectContext context) where T : BaseAttribute\n        {\n            return CacheExistInConfiguration(key, context) ?\n                                                RetrieveCacheExpirationFromConfig(key, context)\n                                                :\n                                                RetrieveCacheExpirationFromAttribute<T>(context);\n        }\n", "        public int GetCacheDuration<T>(string key, AspectContext context) where T : BaseAttribute\n        {\n            return CacheExistInConfiguration(key, context) ?\n                                                RetrieveCacheExpirationFromConfig(key, context)\n                                                :\n                                                RetrieveCacheExpirationFromAttribute<T>(context);\n        }\n\n        public bool CacheExistInConfiguration(string key, AspectContext context)\n        {\n            if (_baseOptions.CacheSettings is null) return false;\n\n            var convertedKey = _keyManager.ConvertCacheKeyToConfigKey(_keyManager.GenerateKey(context.ImplementationMethod, context.ServiceMethod, GenerateParamsFromParamCollection(context.GetParameters())));\n            return _baseOptions.CacheSettings.ContainsKey(convertedKey);\n        }\n", "        public bool CacheExistInConfiguration(string key, AspectContext context)\n        {\n            if (_baseOptions.CacheSettings is null) return false;\n\n            var convertedKey = _keyManager.ConvertCacheKeyToConfigKey(_keyManager.GenerateKey(context.ImplementationMethod, context.ServiceMethod, GenerateParamsFromParamCollection(context.GetParameters())));\n            return _baseOptions.CacheSettings.ContainsKey(convertedKey);\n        }\n\n        public MethodInfo GetExecutedMethodInfo(AspectContext context)\n        {\n            return context.ImplementationMethod;\n        }\n", "        public MethodInfo GetExecutedMethodInfo(AspectContext context)\n        {\n            return context.ImplementationMethod;\n        }\n\n        public MethodInfo GetServiceMethodInfo(AspectContext context)\n        {\n            return context.ServiceMethod;\n        }\n\n        public string[] GetMethodParameters(AspectContext context)\n        {\n            var methodParams = context.Parameters.Select((object obj) =>\n            {\n                return obj.ToString();\n            }).ToArray();\n            return methodParams;\n        }\n", "        public bool IsAttributeOfType<T>(AspectContext context) where T : BaseAttribute\n        {\n            var executedMethodAttribute = context.ServiceMethod.GetCustomAttributes(true)\n                                                            .FirstOrDefault(\n                                                            x => typeof(T).IsAssignableFrom(x.GetType())\n                                                            );\n            return executedMethodAttribute is T;\n        }\n\n        public bool CacheConfigSectionExists()\n        {\n            return _baseOptions.CacheSettings != null;\n        }\n", "        public bool CacheConfigSectionExists()\n        {\n            return _baseOptions.CacheSettings != null;\n        }\n\n        public int RetrieveCacheExpirationFromConfig(string key, AspectContext context)\n        {\n            ArgumentNullException.ThrowIfNull(key);\n\n            var convertedKey = _keyManager.ConvertCacheKeyToConfigKey(_keyManager.GenerateKey(context.ImplementationMethod, context.ServiceMethod, GenerateParamsFromParamCollection(context.GetParameters())));\n            var cacheExpiration = _baseOptions.CacheSettings.GetValueOrDefault(convertedKey);\n", "            if (IsCacheExpirationValid(cacheExpiration))\n            {\n                return (int)cacheExpiration.TotalSeconds;\n            }\n\n            throw new InvalidOperationException($\"Cache key {key} either doesn't exist on the configuration or if exist has an invalid value for its duration. Cache duration should be greater than zero.\");\n        }\n\n        public int RetrieveCacheExpirationFromAttribute<T>(AspectContext context) where T : BaseAttribute\n        {\n            var executedMethodAttribute = context.ServiceMethod.GetCustomAttributes(true)\n                                                .FirstOrDefault(\n                                                                    x => typeof(T).IsAssignableFrom(x.GetType())\n                                                                );\n\n            var castedExecutedMethodAttribute = executedMethodAttribute as T;\n\n            return IsCacheGroupDefined(castedExecutedMethodAttribute) ?\n                                                                                    RetrieveCacheExpirationFromCacheGroup(castedExecutedMethodAttribute.CacheGroup)\n                                                                                    :\n                                                                                    castedExecutedMethodAttribute.CacheDurationInSeconds;\n        }\n", "        public int RetrieveCacheExpirationFromAttribute<T>(AspectContext context) where T : BaseAttribute\n        {\n            var executedMethodAttribute = context.ServiceMethod.GetCustomAttributes(true)\n                                                .FirstOrDefault(\n                                                                    x => typeof(T).IsAssignableFrom(x.GetType())\n                                                                );\n\n            var castedExecutedMethodAttribute = executedMethodAttribute as T;\n\n            return IsCacheGroupDefined(castedExecutedMethodAttribute) ?\n                                                                                    RetrieveCacheExpirationFromCacheGroup(castedExecutedMethodAttribute.CacheGroup)\n                                                                                    :\n                                                                                    castedExecutedMethodAttribute.CacheDurationInSeconds;\n        }\n", "        public bool IsCacheGroupDefined(BaseAttribute attribute)\n        {\n            return !String.IsNullOrEmpty(attribute.CacheGroup);\n        }\n\n        public int RetrieveCacheExpirationFromCacheGroup(string cacheGroup)\n        {\n            var cacheExpiration = _baseOptions.CacheGroupSettings.GetValueOrDefault(cacheGroup);\n\n            if (IsCacheExpirationValid(cacheExpiration))\n            {\n                return (int)cacheExpiration.TotalSeconds;\n            }\n\n            throw new InvalidOperationException($\"Cache group {cacheGroup} either doesn't exist on the configuration or if exist has an invalid value for its duration. Cache duration should be greater than zero.\");\n        }\n", "            if (IsCacheExpirationValid(cacheExpiration))\n            {\n                return (int)cacheExpiration.TotalSeconds;\n            }\n\n            throw new InvalidOperationException($\"Cache group {cacheGroup} either doesn't exist on the configuration or if exist has an invalid value for its duration. Cache duration should be greater than zero.\");\n        }\n\n        public bool IsCacheExpirationValid(TimeSpan? cacheExpiration)\n        {\n            return cacheExpiration != null && cacheExpiration > TimeSpan.Zero;\n        }\n\n        public string[] GenerateParamsFromParamCollection(ParameterCollection parameters)\n        {\n            List<string> genericParamsList = new List<string>();\n", "        public bool IsCacheExpirationValid(TimeSpan? cacheExpiration)\n        {\n            return cacheExpiration != null && cacheExpiration > TimeSpan.Zero;\n        }\n\n        public string[] GenerateParamsFromParamCollection(ParameterCollection parameters)\n        {\n            List<string> genericParamsList = new List<string>();\n\n            foreach (var param in parameters)\n            {\n                var genericParam = GenerateGeneriConfigCacheParameter(param.Name);\n                genericParamsList.Add(genericParam);\n            }\n\n            return genericParamsList.ToArray();\n        }\n", "            foreach (var param in parameters)\n            {\n                var genericParam = GenerateGeneriConfigCacheParameter(param.Name);\n                genericParamsList.Add(genericParam);\n            }\n\n            return genericParamsList.ToArray();\n        }\n\n        public string GenerateGeneriConfigCacheParameter(string parameter)\n        {\n            ArgumentNullException.ThrowIfNull(parameter);\n            return $\"{{{parameter}}}\";\n        }\n\n    }\n}", "        public string GenerateGeneriConfigCacheParameter(string parameter)\n        {\n            ArgumentNullException.ThrowIfNull(parameter);\n            return $\"{{{parameter}}}\";\n        }\n\n    }\n}"]}
{"filename": "src/Nebula.Caching.Common/Utils/IContextUtils.cs", "chunked_list": ["using System.Reflection;\nusing AspectCore.DynamicProxy;\nusing Nebula.Caching.Common.Attributes;\n\nnamespace Nebula.Caching.Common.Utils\n{\n    public interface IContextUtils\n    {\n        int GetCacheDuration<T>(string key, AspectContext context) where T : BaseAttribute;\n        string[] GetMethodParameters(AspectContext context);\n        MethodInfo GetExecutedMethodInfo(AspectContext context);\n        MethodInfo GetServiceMethodInfo(AspectContext context);\n        bool IsAttributeOfType<T>(AspectContext context) where T : BaseAttribute;\n    }\n}"]}
{"filename": "src/Nebula.Caching.Common/Extensions/Extensions.cs", "chunked_list": ["using System.Diagnostics.CodeAnalysis;\nusing AspectCore.Extensions.Hosting;\nusing Microsoft.Extensions.Hosting;\n\nnamespace Nebula.Caching.Common.Extensions\n{\n    [ExcludeFromCodeCoverage]\n    public static class Extensions\n    {\n        public static IHostBuilder UseNebulaCaching(this IHostBuilder builderHost)\n        {\n            return builderHost.UseDynamicProxy();\n        }\n    }\n}", "        public static IHostBuilder UseNebulaCaching(this IHostBuilder builderHost)\n        {\n            return builderHost.UseDynamicProxy();\n        }\n    }\n}"]}
{"filename": "src/Nebula.Caching.Common/Settings/BaseOptions.cs", "chunked_list": ["using System.Collections.Concurrent;\nusing System.Diagnostics.CodeAnalysis;\n\nnamespace Common.Settings\n{\n    [ExcludeFromCodeCoverage]\n    public abstract class BaseOptions\n    {\n        public virtual string ConfigurationRoot { get; set; } = \"\";\n        public virtual string CacheServiceUrl { get; set; } = \"\";\n        public virtual ConcurrentDictionary<string, TimeSpan> CacheSettings { get; set; } = new();", "        public virtual string ConfigurationRoot { get; set; } = \"\";\n        public virtual string CacheServiceUrl { get; set; } = \"\";\n        public virtual ConcurrentDictionary<string, TimeSpan> CacheSettings { get; set; } = new();\n        public virtual ConcurrentDictionary<string, TimeSpan> CacheGroupSettings { get; set; } = new();\n    }\n}"]}
{"filename": "src/Nebula.Caching.Common/Settings/Configurations.cs", "chunked_list": ["using System.Diagnostics.CodeAnalysis;\nusing Nebula.Caching.Common.Constants;\n\nnamespace Nebula.Caching.Common.Settings\n{\n    [ExcludeFromCodeCoverage]\n    public class Configurations\n    {\n        public string ConfigurationSection { get; set; } = CacheConfigurationConstants.ConfigurationSection;\n        public int DefaultCacheDurationInSeconds { get; set; } = CacheDurationConstants.DefaultCacheDurationInSeconds;\n    }\n}", "        public string ConfigurationSection { get; set; } = CacheConfigurationConstants.ConfigurationSection;\n        public int DefaultCacheDurationInSeconds { get; set; } = CacheDurationConstants.DefaultCacheDurationInSeconds;\n    }\n}"]}
{"filename": "src/Nebula.Caching.Common/Constants/CacheConfigurationConstants.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace Nebula.Caching.Common.Constants\n{\n    public static class CacheConfigurationConstants\n    {\n        public static string ConfigurationSection = \"\";\n    }\n}", "        public static string ConfigurationSection = \"\";\n    }\n}"]}
{"filename": "src/Nebula.Caching.Common/Constants/CacheDurationConstants.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace Nebula.Caching.Common.Constants\n{\n    [ExcludeFromCodeCoverage]\n    public static class CacheDurationConstants\n    {", "    [ExcludeFromCodeCoverage]\n    public static class CacheDurationConstants\n    {\n        public static int DefaultCacheDurationInSeconds = 600;\n    }\n}"]}
{"filename": "src/Nebula.Caching.Common/Constants/KeyConstants.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace Nebula.Caching.Common.Constants\n{\n    [ExcludeFromCodeCoverage]\n    public class KeyConstants\n    {", "    [ExcludeFromCodeCoverage]\n    public class KeyConstants\n    {\n        public const char MethodFullPathSeparator = '.';\n        public const string MethodAndParametersSeparator = \":\";\n        public const char ConfigMethodFullPathSeparator = '-';\n        public const string ConfigMethodAndParametersSeparator = \"--\";\n\n    }\n\n}"]}
{"filename": "src/Nebula.Caching.Common/CacheManager/ICacheManager.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing StackExchange.Redis;\n\nnamespace Nebula.Caching.Common.CacheManager\n{\n    public interface ICacheManager\n    {\n        void Set(string key, string value, TimeSpan expiration);\n        string Get(string key);\n        bool CacheExists(string key);\n        Task SetAsync(string key, string value, TimeSpan expiration);\n        Task<string> GetAsync(string key);\n        Task<bool> CacheExistsAsync(string key);\n    }\n}", "    public interface ICacheManager\n    {\n        void Set(string key, string value, TimeSpan expiration);\n        string Get(string key);\n        bool CacheExists(string key);\n        Task SetAsync(string key, string value, TimeSpan expiration);\n        Task<string> GetAsync(string key);\n        Task<bool> CacheExistsAsync(string key);\n    }\n}"]}
{"filename": "src/Nebula.Caching.Common/Compression/GZipCompression.cs", "chunked_list": ["using System.IO.Compression;\n\nnamespace Nebula.Caching.Common.Compression\n{\n    public class GZipCompression\n    {\n        public byte[] Compress(byte[] dataToCompress)\n        {\n            using (var memoryStream = new MemoryStream())\n            {\n                using (var gzipStream = new GZipStream(memoryStream, CompressionLevel.Optimal))\n                {\n                    gzipStream.Write(dataToCompress, 0, dataToCompress.Length);\n                }\n                return memoryStream.ToArray();\n            }\n        }\n\n        public byte[] Decompress(byte[] dataToDecompress)\n        {", "            using (var memoryStream = new MemoryStream())\n            {\n                using (var gzipStream = new GZipStream(memoryStream, CompressionLevel.Optimal))\n                {\n                    gzipStream.Write(dataToCompress, 0, dataToCompress.Length);\n                }\n                return memoryStream.ToArray();\n            }\n        }\n\n        public byte[] Decompress(byte[] dataToDecompress)\n        {", "            using (var memoryStream = new MemoryStream(dataToDecompress))\n            {\n\n                using (var outputStream = new MemoryStream())\n                {\n                    using (var decompressStream = new GZipStream(memoryStream, CompressionMode.Decompress))\n                    {\n                        decompressStream.CopyTo(outputStream);\n                    }\n                    return outputStream.ToArray();\n                }\n            }\n        }\n", "        public async static Task<byte[]> CompressAsync(byte[] bytes)\n        {\n            using (var memoryStream = new MemoryStream())\n            {\n                using (var gzipStream = new GZipStream(memoryStream, CompressionLevel.Optimal))\n                {\n                    await gzipStream.WriteAsync(bytes, 0, bytes.Length);\n                }\n                return memoryStream.ToArray();\n            }\n        }\n", "        public async static Task<byte[]> DecompressAsync(byte[] bytes)\n        {\n            using (var memoryStream = new MemoryStream(bytes))\n            {\n                using (var outputStream = new MemoryStream())\n                {\n                    using (var decompressStream = new GZipStream(memoryStream, CompressionMode.Decompress))\n                    {\n                        await decompressStream.CopyToAsync(outputStream);\n                    }\n                    return outputStream.ToArray();\n                }\n            }\n        }\n\n    }\n}"]}
