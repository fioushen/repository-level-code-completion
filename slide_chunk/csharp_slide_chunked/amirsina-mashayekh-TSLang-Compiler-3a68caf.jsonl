{"filename": "Tokenizer/TSLangTokenizer.cs", "chunked_list": ["\ufeffusing System.Collections.ObjectModel;\nusing System.Text;\n\nnamespace Tokenizer\n{\n    /// <summary>\n    /// Represents a TSLang source code tokenizer.\n    /// </summary>\n    public class TSLangTokenizer\n    {\n        /// <summary>\n        /// Current line of source code which <see cref=\"stream\"/> is pointing to.\n        /// </summary>", "    public class TSLangTokenizer\n    {\n        /// <summary>\n        /// Current line of source code which <see cref=\"stream\"/> is pointing to.\n        /// </summary>\n        private int line;\n\n        /// <summary>\n        /// Current column of source code which <see cref=\"stream\"/> is pointing to.\n        /// </summary>\n        private int column;\n\n        /// <summary>\n        /// A <see cref=\"StreamReader\"/> which provides source code content.\n        /// </summary>", "        private int column;\n\n        /// <summary>\n        /// A <see cref=\"StreamReader\"/> which provides source code content.\n        /// </summary>\n        private readonly StreamReader stream;\n\n        /// <summary>\n        /// Gets weather the tokenizer reached end of source code.\n        /// </summary>\n        public bool EndOfStream { get; private set; }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"TSLangTokenizer\"/> class\n        /// for the provided source code stream.\n        /// </summary>\n        /// <param name=\"stream\">A <see cref=\"StreamReader\"/> providing source code.</param>\n        /// <exception cref=\"ArgumentNullException\"></exception>\n        public TSLangTokenizer(StreamReader stream)\n        {\n            this.stream = stream ?? throw new ArgumentNullException(nameof(stream));\n            EndOfStream = false;\n            line = 1;\n            column = 1;\n        }\n\n        /// <summary>\n        /// Returns first available token in\n        /// the provided source code stream.\n        /// Closes source code <see cref=\"StreamReader\"/> when it\n        /// reaches to the end of it.\n        /// </summary>\n        /// <returns>Next token in the source code.</returns>", "        public bool EndOfStream { get; private set; }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"TSLangTokenizer\"/> class\n        /// for the provided source code stream.\n        /// </summary>\n        /// <param name=\"stream\">A <see cref=\"StreamReader\"/> providing source code.</param>\n        /// <exception cref=\"ArgumentNullException\"></exception>\n        public TSLangTokenizer(StreamReader stream)\n        {\n            this.stream = stream ?? throw new ArgumentNullException(nameof(stream));\n            EndOfStream = false;\n            line = 1;\n            column = 1;\n        }\n\n        /// <summary>\n        /// Returns first available token in\n        /// the provided source code stream.\n        /// Closes source code <see cref=\"StreamReader\"/> when it\n        /// reaches to the end of it.\n        /// </summary>\n        /// <returns>Next token in the source code.</returns>", "        public Token NextToken()\n        {\n            int tokenStartLine = line;\n            int tokenStartCol = column;\n\n            StringBuilder tmpToken = new();\n\n            TokenType prevType = TSLangTokenTypes.invalid;\n            bool endOfToken = false;\n\n            while (!stream.EndOfStream)\n            {\n                char ch = (char)stream.Peek();\n", "            while (!stream.EndOfStream)\n            {\n                char ch = (char)stream.Peek();\n\n                if (ch == '\\r')\n                {\n                    stream.Read();\n                    continue;\n                }\n                else if (ch == '\\n')\n                {\n                    stream.Read();\n                    line++;\n                    column = 1;\n", "                else if (ch == '\\n')\n                {\n                    stream.Read();\n                    line++;\n                    column = 1;\n\n                    if (tmpToken.Length > 0)\n                    {\n                        endOfToken = true;\n                    }\n                    else\n                    {\n                        tokenStartLine = line;\n                        tokenStartCol = column;\n                        continue;\n                    }\n                }", "                else if (ch is ' ' or '\\t')\n                {\n                    if (tmpToken.Length == 0)\n                    {\n                        column++;\n                        tokenStartCol = column;\n                        stream.Read();\n                        continue;\n                    }\n                    else if (tmpToken[0] is not '\"' and not '\\'' and not '#')\n                    {\n                        endOfToken = true;\n                    }\n                }\n\n                tmpToken.Append(ch);\n\n                TokenType currentType = TypeOfToken(tmpToken.ToString());\n\n                endOfToken |=\n                    stream.EndOfStream |\n                    ((prevType != TSLangTokenTypes.invalid) &&\n                    (currentType == TSLangTokenTypes.invalid));\n", "                    else if (tmpToken[0] is not '\"' and not '\\'' and not '#')\n                    {\n                        endOfToken = true;\n                    }\n                }\n\n                tmpToken.Append(ch);\n\n                TokenType currentType = TypeOfToken(tmpToken.ToString());\n\n                endOfToken |=\n                    stream.EndOfStream |\n                    ((prevType != TSLangTokenTypes.invalid) &&\n                    (currentType == TSLangTokenTypes.invalid));\n", "                if (endOfToken)\n                {\n                    tmpToken.Length--;\n                    break;\n                }\n\n                stream.Read();\n                column++;\n                prevType = currentType;\n            }\n\n            string tokenStr = tmpToken.ToString();\n", "            if (stream.EndOfStream)\n            {\n                stream.Close();\n                EndOfStream = true;\n                prevType = TypeOfToken(tokenStr);\n            }\n\n            return new Token(prevType, tokenStr, tokenStartLine, tokenStartCol);\n        }\n\n        /// <summary>\n        /// Detects type of a given token.\n        /// </summary>\n        /// <param name=\"tokenStr\">String Representation of the token.</param>\n        /// <returns>\n        /// Type of token if <paramref name=\"tokenStr\"/> matches a specific type.\n        /// <see cref=\"TSLangTokenTypes.invalid\"/> if <paramref name=\"tokenStr\"/> does not\n        /// match any type of token or matches more than one type (except keyword and identifier).\n        /// </returns>", "        private static TokenType TypeOfToken(string tokenStr)\n        {\n            TokenType tokenType = TSLangTokenTypes.invalid;\n            int matchCount = 0;\n\n            foreach (TokenType type in TokenTypes)\n            {\n                if (type.Pattern.IsMatch(tokenStr))\n                {\n                    matchCount++;\n                    if (matchCount == 1)\n                    {\n                        tokenType = type;\n                    }\n                    else\n                    {\n                        // More than one match. Invalid token.\n                        tokenType = TSLangTokenTypes.invalid;\n                        break;\n                    }\n                }\n            }\n\n            // Keywords also match identifier pattern.\n            // Check if token is actually identifier or keyword.", "                    if (matchCount == 1)\n                    {\n                        tokenType = type;\n                    }\n                    else\n                    {\n                        // More than one match. Invalid token.\n                        tokenType = TSLangTokenTypes.invalid;\n                        break;\n                    }\n                }\n            }\n\n            // Keywords also match identifier pattern.\n            // Check if token is actually identifier or keyword.", "            if (tokenType.Name == \"identifier\")\n            {\n                foreach (TokenType type in Keywords)\n                {\n                    if (type.Pattern.IsMatch(tokenStr))\n                    {\n                        tokenType = type;\n                        break;\n                    }\n                }\n            }\n\n            return tokenType;\n        }\n\n        /// <summary>\n        /// A collection of non-keyword <see cref=\"TokenType\"/>s for TSLang.\n        /// </summary>", "        public static readonly ReadOnlyCollection<TokenType> TokenTypes = new(new List<TokenType>\n        {\n            TSLangTokenTypes.identifier,\n            TSLangTokenTypes.literal_integer,\n            TSLangTokenTypes.literal_string_singleQuote,\n            TSLangTokenTypes.literal_string_doubleQuote,\n            TSLangTokenTypes.semicolon,\n            TSLangTokenTypes.leftParenthesis,\n            TSLangTokenTypes.rightParenthesis,\n            TSLangTokenTypes.leftBrace,\n            TSLangTokenTypes.rightBrace,\n            TSLangTokenTypes.leftBracket,\n            TSLangTokenTypes.rightBracket,\n            TSLangTokenTypes.lessThan,\n            TSLangTokenTypes.greaterThan,\n            TSLangTokenTypes.lessThanOrEqual,\n            TSLangTokenTypes.greaterThanOrEqual,\n            TSLangTokenTypes.equals,\n            TSLangTokenTypes.plus,\n            TSLangTokenTypes.minus,\n            TSLangTokenTypes.asterisk,\n            TSLangTokenTypes.slash,\n            TSLangTokenTypes.percent,\n            TSLangTokenTypes.doubleEquals,\n            TSLangTokenTypes.notEquals,\n            TSLangTokenTypes.logicalOr,\n            TSLangTokenTypes.logicalAnd,\n            TSLangTokenTypes.exclamationMark,\n            TSLangTokenTypes.questionMark,\n            TSLangTokenTypes.colon,\n            TSLangTokenTypes.comma,\n            TSLangTokenTypes.comment,\n        });\n\n        /// <summary>\n        /// A collection of keyword <see cref=\"TokenType\"/>s for TSLang.\n        /// </summary>", "        public static readonly ReadOnlyCollection<TokenType> Keywords = new(new List<TokenType>()\n        {\n            TSLangTokenTypes.kw_for,\n            TSLangTokenTypes.kw_while,\n            TSLangTokenTypes.kw_if,\n            TSLangTokenTypes.kw_else,\n            TSLangTokenTypes.kw_var,\n            TSLangTokenTypes.kw_def,\n            TSLangTokenTypes.kw_int,\n            TSLangTokenTypes.kw_vector,\n            TSLangTokenTypes.kw_str,\n            TSLangTokenTypes.kw_null,\n            TSLangTokenTypes.kw_return,\n            TSLangTokenTypes.kw_to,\n        });\n    }\n}\n"]}
{"filename": "Tokenizer/Token.cs", "chunked_list": ["\ufeffnamespace Tokenizer\n{\n    /// <summary>\n    /// Represents a token in code.\n    /// </summary>\n    public class Token\n    {\n        /// <summary>\n        /// Type of the current <see cref=\"Token\"/>.\n        /// </summary>\n        public TokenType Type { get; }\n\n        /// <summary>\n        /// String value of the current <see cref=\"Token\"/>.\n        /// </summary>", "        public TokenType Type { get; }\n\n        /// <summary>\n        /// String value of the current <see cref=\"Token\"/>.\n        /// </summary>\n        public string Value { get; }\n\n        /// <summary>\n        /// Line number of the current <see cref=\"Token\"/> in source file. Starts from 1.\n        /// </summary>\n        public int Line { get; }\n\n        /// <summary>\n        /// Column number of the current <see cref=\"Token\"/> in source file. Starts from 1.\n        /// </summary>", "        public int Line { get; }\n\n        /// <summary>\n        /// Column number of the current <see cref=\"Token\"/> in source file. Starts from 1.\n        /// </summary>\n        public int Column { get; }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"Token\"/> class\n        /// with the specified type, value, line number and column number.\n        /// </summary>\n        /// <param name=\"type\">Type of the current token.</param>\n        /// <param name=\"value\">String value of the current token.</param>\n        /// <param name=\"line\">Line number of the current token in source file.</param>\n        /// <param name=\"column\">Column number of the current token is source file.</param>\n        /// <exception cref=\"ArgumentNullException\"></exception>\n        public Token(TokenType type, string value, int line, int column)\n        {\n            Type = type ?? throw new ArgumentNullException(nameof(type));\n            Value = value;\n            Line = line;\n            Column = column;\n        }\n", "        public override string? ToString()\n        {\n            return\n                Value + \", \" +\n                Type + \", \" +\n                Line + \", \" +\n                Column;\n        }\n    }\n}\n"]}
{"filename": "Tokenizer/TokenType.cs", "chunked_list": ["\ufeffusing System.Text.RegularExpressions;\n\nnamespace Tokenizer\n{\n    /// <summary>\n    /// Represents type of tokens in tokenizer.\n    /// Includes a list of token types for TSLang.\n    /// </summary>\n    public class TokenType\n    {\n        /// <summary>\n        /// Gets the name of the current <see cref=\"TokenType\"/>.\n        /// </summary>", "    public class TokenType\n    {\n        /// <summary>\n        /// Gets the name of the current <see cref=\"TokenType\"/>.\n        /// </summary>\n        public string Name { get; }\n\n        /// <summary>\n        /// Gets the regex object to match tokens with the current <see cref=\"TokenType\"/>.\n        /// </summary>\n        public Regex Pattern { get; }\n\n        /// <summary>\n        /// Saves hash code of the current <see cref=\"TokenType\"/>. \n        /// </summary>", "        public Regex Pattern { get; }\n\n        /// <summary>\n        /// Saves hash code of the current <see cref=\"TokenType\"/>. \n        /// </summary>\n        private readonly int _hashCode;\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"TokenType\"/> class\n        /// with the specified name and regex pattern and defaul regex options (compiled and culture invariant).\n        /// </summary>\n        /// <param name=\"name\">The name of this token type.</param>\n        /// <param name=\"pattern\">The regular expression pattern to match tokens of this type.</param>\n        /// <exception cref=\"ArgumentNullException\"></exception>\n        public TokenType(string name, string pattern) : this(\n            name,\n            new Regex(\"^\" + pattern + @\"\\z\", RegexOptions.CultureInvariant))\n        { }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"TokenType\"/> class\n        /// with the specified name and regex object.\n        /// </summary>\n        /// <param name=\"name\">The name of this token type.</param>\n        /// <param name=\"pattern\">The <see cref=\"Regex\"/> object to match tokens of this type.</param>\n        /// <exception cref=\"ArgumentNullException\"></exception>\n        public TokenType(string name, Regex pattern)\n        {\n            Name = name ?? throw new ArgumentNullException(nameof(name));\n            Pattern = pattern ?? throw new ArgumentNullException(nameof(pattern));\n            _hashCode = HashCode.Combine(name, pattern);\n        }\n", "        public override bool Equals(object? obj)\n        {\n            return obj is TokenType && _hashCode == obj.GetHashCode();\n        }\n\n        public override int GetHashCode()\n        {\n            return _hashCode;\n        }\n\n        public override string? ToString()\n        {\n            return Name;\n        }\n    }\n}\n", "        public override string? ToString()\n        {\n            return Name;\n        }\n    }\n}\n"]}
{"filename": "Tokenizer/Program.cs", "chunked_list": ["\ufeffusing Tokenizer;\n\nstring path = args.Length == 0 ? Console.ReadLine()! : args[0];\n\nTSLangTokenizer tokenizer = new(new StreamReader(path));\n\nwhile (!tokenizer.EndOfStream)\n{\n    Console.WriteLine(tokenizer.NextToken());\n}"]}
{"filename": "Tokenizer/TSLangTokenTypes.cs", "chunked_list": ["\ufeffnamespace Tokenizer\n{\n    /// <summary>\n    /// Static class which includes token types of TSLang.\n    /// </summary>\n    public static class TSLangTokenTypes\n    {\n        public static readonly TokenType\n            invalid\n            = new(\"invalid\", \"\"),\n\n            identifier\n            = new(\"identifier\", @\"[A-Za-z_][A-Za-z1-9_]*\"),\n\n            literal_integer\n            = new(\"literal_integer\", @\"[0-9]+\"),\n\n            literal_string_singleQuote\n            = new(\"literal_string_singleQuote\", @\"'[^'\\r\\n]*'\"),\n\n            literal_string_doubleQuote\n            = new(\"literal_string_doubleQuote\", @\"\"\"[^\"\"\\r\\n]*\"\"\"),\n\n            semicolon\n            = new(\"semicolon\", @\";\"),\n\n            leftParenthesis\n            = new(\"leftParenthesis\", @\"\\(\"),\n\n            rightParenthesis\n            = new(\"rightParenthesis\", @\"\\)\"),\n\n            leftBrace\n            = new(\"leftBrace\", @\"\\{\"),\n\n            rightBrace\n            = new(\"rightBrace\", @\"\\}\"),\n\n            leftBracket\n            = new(\"leftBracket\", @\"\\[\"),\n\n            rightBracket\n            = new(\"rightBracket\", @\"\\]\"),\n\n            lessThan\n            = new(\"lessThan\", @\"<\"),\n\n            greaterThan\n            = new(\"greaterThan\", @\">\"),\n\n            lessThanOrEqual\n            = new(\"lessThanOrEqual\", @\"<=\"),\n\n            greaterThanOrEqual\n            = new(\"greaterThanOrEqual\", @\">=\"),\n\n            equals\n            = new(\"equals\", @\"=\"),\n\n            plus\n            = new(\"plus\", @\"\\+\"),\n\n            minus\n            = new(\"minus\", @\"\\-\"),\n\n            asterisk\n            = new(\"asterisk\", @\"\\*\"),\n\n            slash\n            = new(\"slash\", @\"\\/\"),\n\n            percent\n            = new(\"percent\", @\"\\%\"),\n\n            doubleEquals\n            = new(\"doubleEquals\", @\"==\"),\n\n            notEquals\n            = new(\"notEquals\", @\"!=\"),\n\n            logicalOr\n            = new(\"logicalOr\", @\"\\|\\|\"),\n\n            logicalAnd\n            = new(\"logicalAnd\", @\"&&\"),\n\n            exclamationMark\n            = new(\"exclamationMark\", @\"!\"),\n\n            questionMark\n            = new(\"questionMark\", @\"\\?\"),\n\n            colon\n            = new(\"colon\", @\":\"),\n\n            comma\n            = new(\"comma\", @\",\"),\n\n            comment\n            = new(\"comment\", @\"#.*\"),\n\n            kw_for\n            = new(\"kw_for\", @\"for\"),\n\n            kw_while\n            = new(\"kw_while\", @\"while\"),\n\n            kw_if\n            = new(\"kw_if\", @\"if\"),\n\n            kw_else\n            = new(\"kw_else\", @\"else\"),\n\n            kw_var\n            = new(\"kw_var\", @\"var\"),\n\n            kw_def\n            = new(\"kw_def\", @\"def\"),\n\n            kw_int\n            = new(\"kw_int\", @\"int\"),\n\n            kw_vector\n            = new(\"kw_vector\", @\"vector\"),\n\n            kw_str\n            = new(\"kw_str\", @\"str\"),\n\n            kw_null\n            = new(\"kw_null\", @\"null\"),\n\n            kw_return\n            = new(\"kw_return\", @\"return\"),\n\n            kw_to\n            = new(\"kw_to\", @\"to\");\n    }\n}\n"]}
{"filename": "Parser/TSLangParserGrammar.cs", "chunked_list": ["\ufeffusing Parser.SymbolTableUtil;\nusing Tokenizer;\n\nnamespace Parser\n{\n    public partial class TSLangParser\n    {\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// *EMPTY*\n        /// Func Prog\n        /// </code>\n        /// </summary>", "        private void Prog()\n        {\n            if (Done)\n                // *EMPTY*\n                return;\n\n            Func();\n            Prog();\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// def Type iden ( FList ) { Body }\n        /// def Type iden ( FList ) return Expr ;\n        /// </code>\n        /// </summary>", "        private void Func()\n        {\n            SymbolType type = TSLangSymbolTypes.invalid_type;\n            List<Variable>? parameters = null;\n            string? id = null;\n            var prevScope = currentSymTab;\n\n            if (CurrentToken.Type != TSLangTokenTypes.kw_def)\n            {\n                SyntaxError(\"Expected 'def'\");\n\n                TokenType[] recoveryPoint =\n                {\n                    TSLangTokenTypes.kw_def,\n                    TSLangTokenTypes.leftParenthesis,\n                    TSLangTokenTypes.rightParenthesis,\n                    TSLangTokenTypes.leftBrace,\n                    TSLangTokenTypes.kw_return,\n                };\n\n                do\n                {\n                    DropToken();", "                    if (Done)\n                        return;\n                } while (!recoveryPoint.Contains(CurrentToken.Type));\n\n                if (CurrentToken.Type == TSLangTokenTypes.kw_def)\n                    goto rp1;\n                else if (CurrentToken.Type == TSLangTokenTypes.leftParenthesis)\n                    goto rp2;\n                else if (CurrentToken.Type == TSLangTokenTypes.rightParenthesis)\n                    goto rp3;\n                else\n                    goto rp4;\n            }\n        rp1:\n            DropToken();\n\n            type = Type();\n", "                else if (CurrentToken.Type == TSLangTokenTypes.rightParenthesis)\n                    goto rp3;\n                else\n                    goto rp4;\n            }\n        rp1:\n            DropToken();\n\n            type = Type();\n\n            if (CurrentToken.Type != TSLangTokenTypes.identifier)\n            {\n                SyntaxError(\"Expected identifier\");\n\n                TokenType[] recoveryPoint =\n                {\n                    TSLangTokenTypes.leftParenthesis,\n                    TSLangTokenTypes.rightParenthesis,\n                    TSLangTokenTypes.leftBrace,\n                    TSLangTokenTypes.kw_return,\n                };\n\n                do\n                {\n                    DropToken();", "            if (CurrentToken.Type != TSLangTokenTypes.identifier)\n            {\n                SyntaxError(\"Expected identifier\");\n\n                TokenType[] recoveryPoint =\n                {\n                    TSLangTokenTypes.leftParenthesis,\n                    TSLangTokenTypes.rightParenthesis,\n                    TSLangTokenTypes.leftBrace,\n                    TSLangTokenTypes.kw_return,\n                };\n\n                do\n                {\n                    DropToken();", "                    if (Done)\n                        return;\n                } while (!recoveryPoint.Contains(CurrentToken.Type));\n\n                if (CurrentToken.Type == TSLangTokenTypes.leftParenthesis)\n                    goto rp2;\n                else if (CurrentToken.Type == TSLangTokenTypes.rightParenthesis)\n                    goto rp3;\n                else\n                    goto rp4;\n            }\n            else\n            {\n                id = CurrentToken.Value;\n            }\n            DropToken();\n", "            if (CurrentToken.Type != TSLangTokenTypes.leftParenthesis)\n            {\n                SyntaxError(\"Expected '('\");\n\n                TokenType[] recoveryPoint =\n                {\n                    TSLangTokenTypes.leftParenthesis,\n                    TSLangTokenTypes.rightParenthesis,\n                    TSLangTokenTypes.leftBrace,\n                    TSLangTokenTypes.kw_return,\n                };\n\n                do\n                {\n                    DropToken();", "                    if (Done)\n                        return;\n                } while (!recoveryPoint.Contains(CurrentToken.Type));\n\n                if (CurrentToken.Type == TSLangTokenTypes.leftParenthesis)\n                    goto rp2;\n                else if (CurrentToken.Type == TSLangTokenTypes.rightParenthesis)\n                    goto rp3;\n                else\n                    goto rp4;\n            }\n        rp2:\n            DropToken();\n\n            parameters = FList();\n", "            if (CurrentToken.Type != TSLangTokenTypes.rightParenthesis)\n            {\n                SyntaxError(\"Expected ')'\");\n\n                TokenType[] recoveryPoint =\n                {\n                    TSLangTokenTypes.rightParenthesis,\n                    TSLangTokenTypes.leftBrace,\n                    TSLangTokenTypes.kw_return,\n                };\n\n                do\n                {\n                    DropToken();", "                    if (Done)\n                        return;\n                } while (!recoveryPoint.Contains(CurrentToken.Type));\n\n                if (CurrentToken.Type == TSLangTokenTypes.rightParenthesis)\n                    goto rp3;\n                else\n                    goto rp4;\n            }\n        rp3:\n            DropToken();\n", "            if (type != TSLangSymbolTypes.invalid_type && parameters is not null && id is not null)\n            {\n                if (currentSymTab.Exists(id))\n                    SemanticError($\"Function with name '{id}' already exists in this in current scope\");\n                else\n                {\n                    currentSymTab.Add(new Function(id, type, parameters));\n                    currentSymTab = new(prevScope);\n                    foreach (ISymbol item in parameters)\n                    {\n                        currentSymTab.Add(item);\n                    }\n                }\n            }\n\n        rp4:", "                    foreach (ISymbol item in parameters)\n                    {\n                        currentSymTab.Add(item);\n                    }\n                }\n            }\n\n        rp4:\n            if (CurrentToken.Type == TSLangTokenTypes.leftBrace)\n            {\n                DropToken();\n\n                Body(type);", "            if (CurrentToken.Type == TSLangTokenTypes.leftBrace)\n            {\n                DropToken();\n\n                Body(type);\n                if (CurrentToken.Type != TSLangTokenTypes.rightBrace)\n                    SyntaxError(\"Expected '}'\");\n                else DropToken();\n            }\n            else if (CurrentToken.Type == TSLangTokenTypes.kw_return)\n            {\n                DropToken();\n", "            else if (CurrentToken.Type == TSLangTokenTypes.kw_return)\n            {\n                DropToken();\n\n                if (type != TSLangSymbolTypes.null_type)\n                {\n                    var t = Expr();\n                    if (t != type)\n                    {\n                        SemanticError($\"Expected '{type}' return expression\");\n                    }\n                }\n", "                if (CurrentToken.Type != TSLangTokenTypes.semicolon)\n                    SyntaxError(\"Expected ';'\");\n                else DropToken();\n            }\n            else\n            {\n                SyntaxError(\"Expected '{' or 'return'\");\n                while (CurrentToken.Type != TSLangTokenTypes.kw_def && !Done)\n                    DropToken();\n            }\n\n            currentSymTab = prevScope;\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// *EMPTY*\n        /// Stmt Body\n        /// </code>\n        /// </summary>\n        /// <param name=\"returnType\">Expected type of return expression for functions.</param>", "        private void Body(SymbolType returnType)\n        {\n            if (CurrentToken.Type == TSLangTokenTypes.rightBrace)\n                // *EMPTY*\n                return;\n\n            var tmp = currentSymTab;\n            currentSymTab = new(tmp);\n\n            Stmt(returnType);\n\n            Body(returnType);\n\n            currentSymTab = tmp;\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>", "        /// if ( Expr ) Stmt\n        /// if ( Expr ) Stmt else Stmt\n        /// while ( Expr ) Stmt\n        /// for ( iden = Expr to Expr ) Stmt\n        /// return Expr ;\n        /// { Body }\n        /// Func\n        /// Defvar ;\n        /// Expr ;\n        /// </code>\n        /// </summary>\n        /// <param name=\"returnType\">Expected type of return expression for functions.</param>", "        private void Stmt(SymbolType returnType)\n        {\n            if (CurrentToken.Type == TSLangTokenTypes.kw_if)\n            {\n                // if ( Expr ) Stmt\n                DropToken();\n\n                if (CurrentToken.Type != TSLangTokenTypes.leftParenthesis)\n                {\n                    SyntaxError(\"Expected '('\");\n\n                    TokenType[] recoveryPoint =\n                    {\n                        TSLangTokenTypes.leftParenthesis,\n                        TSLangTokenTypes.rightParenthesis,\n                    };\n", "                    while (!recoveryPoint.Contains(CurrentToken.Type))\n                    {\n                        DropToken();\n                        if (Done)\n                            return;\n                    }\n\n                    if (CurrentToken.Type == TSLangTokenTypes.rightParenthesis)\n                    {\n                        DropToken();\n                        goto rp1;\n                    }\n                }\n                DropToken();\n\n                var t = Expr();\n", "                if (t != TSLangSymbolTypes.integer_type)\n                {\n                    SemanticError(\"Condition expression type must be integer\");\n                }\n\n                if (CurrentToken.Type != TSLangTokenTypes.rightParenthesis)\n                    SyntaxError(\"Expected ')'\");\n                else DropToken();\n\n                rp1:\n                Stmt(returnType);\n", "                if (CurrentToken.Type == TSLangTokenTypes.kw_else)\n                {\n                    // if ( Expr ) Stmt else Stmt\n                    DropToken();\n\n                    Stmt(returnType);\n                }\n            }\n            else if (CurrentToken.Type == TSLangTokenTypes.kw_while)\n            {\n                // while ( Expr ) Stmt\n                DropToken();\n", "            else if (CurrentToken.Type == TSLangTokenTypes.kw_while)\n            {\n                // while ( Expr ) Stmt\n                DropToken();\n\n                if (CurrentToken.Type != TSLangTokenTypes.leftParenthesis)\n                {\n                    SyntaxError(\"Expected '('\");\n\n                    TokenType[] recoveryPoint =\n                    {\n                        TSLangTokenTypes.leftParenthesis,\n                        TSLangTokenTypes.rightParenthesis,\n                    };\n", "                    while (!recoveryPoint.Contains(CurrentToken.Type))\n                    {\n                        DropToken();\n                        if (Done)\n                            return;\n                    }\n\n                    if (CurrentToken.Type == TSLangTokenTypes.rightParenthesis)\n                    {\n                        DropToken();\n                        goto rp1;\n                    }\n                }\n                DropToken();\n\n                var t = Expr();\n", "                if (t != TSLangSymbolTypes.integer_type)\n                {\n                    SemanticError(\"Condition expression type must be integer\");\n                }\n\n                if (CurrentToken.Type != TSLangTokenTypes.rightParenthesis)\n                    SyntaxError(\"Expected ')'\");\n                else DropToken();\n                rp1:\n                Stmt(returnType);\n            }", "            else if (CurrentToken.Type == TSLangTokenTypes.kw_for)\n            {\n                // for ( iden = Expr to Expr ) Stmt\n                DropToken();\n\n                string? id = null;\n                SymbolType typeStart = TSLangSymbolTypes.invalid_type;\n                SymbolType typeEnd;\n                int l = CurrentToken.Line;\n                int c = CurrentToken.Column;\n                var prevScope = currentSymTab;\n", "                if (CurrentToken.Type != TSLangTokenTypes.leftParenthesis)\n                {\n                    SyntaxError(\"Expected '('\");\n\n                    TokenType[] recoveryPoint =\n                    {\n                        TSLangTokenTypes.leftParenthesis,\n                        TSLangTokenTypes.equals,\n                        TSLangTokenTypes.kw_to,\n                        TSLangTokenTypes.rightParenthesis,\n                    };\n", "                    while (!recoveryPoint.Contains(CurrentToken.Type))\n                    {\n                        DropToken();\n                        if (Done)\n                            return;\n                    }\n\n                    if (CurrentToken.Type == TSLangTokenTypes.equals)\n                        goto rp1;\n                    else if (CurrentToken.Type == TSLangTokenTypes.kw_to)\n                        goto rp2;", "                    else if (CurrentToken.Type == TSLangTokenTypes.kw_to)\n                        goto rp2;\n                    else if (CurrentToken.Type == TSLangTokenTypes.rightParenthesis)\n                    {\n                        DropToken();\n                        goto rp3;\n                    }\n                }\n                DropToken();\n\n                if (CurrentToken.Type != TSLangTokenTypes.identifier)\n                {\n                    SyntaxError(\"Expected identifier\");\n\n                    TokenType[] recoveryPoint =\n                    {\n                        TSLangTokenTypes.equals,\n                        TSLangTokenTypes.kw_to,\n                        TSLangTokenTypes.rightParenthesis,\n                    };\n", "                if (CurrentToken.Type != TSLangTokenTypes.identifier)\n                {\n                    SyntaxError(\"Expected identifier\");\n\n                    TokenType[] recoveryPoint =\n                    {\n                        TSLangTokenTypes.equals,\n                        TSLangTokenTypes.kw_to,\n                        TSLangTokenTypes.rightParenthesis,\n                    };\n", "                    while (!recoveryPoint.Contains(CurrentToken.Type))\n                    {\n                        DropToken();\n                        if (Done)\n                            return;\n                    }\n\n                    if (CurrentToken.Type == TSLangTokenTypes.equals)\n                        goto rp1;\n                    else if (CurrentToken.Type == TSLangTokenTypes.kw_to)\n                        goto rp2;", "                    else if (CurrentToken.Type == TSLangTokenTypes.kw_to)\n                        goto rp2;\n                    else if (CurrentToken.Type == TSLangTokenTypes.rightParenthesis)\n                    {\n                        DropToken();\n                        goto rp3;\n                    }\n                }\n                else\n                {\n                    id = CurrentToken.Value;\n                }\n                DropToken();\n", "                if (CurrentToken.Type != TSLangTokenTypes.equals)\n                {\n                    SyntaxError(\"Expected '='\");\n\n                    TokenType[] recoveryPoint =\n                    {\n                        TSLangTokenTypes.equals,\n                        TSLangTokenTypes.kw_to,\n                        TSLangTokenTypes.rightParenthesis,\n                    };\n", "                    while (!recoveryPoint.Contains(CurrentToken.Type))\n                    {\n                        DropToken();\n                        if (Done)\n                            return;\n                    }\n\n                    if (CurrentToken.Type == TSLangTokenTypes.equals)\n                        goto rp1;\n                    else if (CurrentToken.Type == TSLangTokenTypes.kw_to)\n                        goto rp2;", "                    else if (CurrentToken.Type == TSLangTokenTypes.kw_to)\n                        goto rp2;\n                    else if (CurrentToken.Type == TSLangTokenTypes.rightParenthesis)\n                    {\n                        DropToken();\n                        goto rp3;\n                    }\n                }\n            rp1:\n                DropToken();\n\n                typeStart = Expr();", "                if (typeStart != TSLangSymbolTypes.integer_type)\n                {\n                    SemanticError($\"Invalid type '{typeStart}' as start of loop range\", l, c);\n                    typeStart = TSLangSymbolTypes.invalid_type;\n                }\n\n                if (CurrentToken.Type != TSLangTokenTypes.kw_to)\n                {\n                    SyntaxError(\"Expected 'to'\");\n\n                    TokenType[] recoveryPoint =\n                    {\n                        TSLangTokenTypes.kw_to,\n                        TSLangTokenTypes.rightParenthesis,\n                    };\n", "                    while (!recoveryPoint.Contains(CurrentToken.Type))\n                    {\n                        DropToken();\n                        if (Done)\n                            return;\n                    }\n\n                    if (CurrentToken.Type == TSLangTokenTypes.rightParenthesis)\n                    {\n                        DropToken();\n                        goto rp3;\n                    }\n                }\n            rp2:\n                DropToken();\n\n                typeEnd = Expr();", "                if (typeEnd != TSLangSymbolTypes.integer_type)\n                {\n                    SemanticError($\"Invalid type '{typeEnd}' as end of loop range\", l, c);\n                    typeEnd = TSLangSymbolTypes.invalid_type;\n                }\n\n                if (CurrentToken.Type != TSLangTokenTypes.rightParenthesis)\n                    SyntaxError(\"Expected ')'\");\n                else DropToken();\n\n                if (id is not null && typeStart != TSLangSymbolTypes.invalid_type && typeEnd != TSLangSymbolTypes.invalid_type)\n                {\n                    currentSymTab = new(prevScope);", "                if (id is not null && typeStart != TSLangSymbolTypes.invalid_type && typeEnd != TSLangSymbolTypes.invalid_type)\n                {\n                    currentSymTab = new(prevScope);\n                    if (currentSymTab.Exists(id))\n                    {\n                        if (currentSymTab.Get(id).Type != typeStart)\n                            SemanticError(\"Invalid loop iterator type\", l, c);\n                    }\n                    else\n                    {\n                        currentSymTab.Add(new Variable(id, typeStart));\n                    }\n                }\n\n            rp3:\n                Stmt(returnType);\n\n                currentSymTab = prevScope;\n            }", "            else if (CurrentToken.Type == TSLangTokenTypes.kw_return)\n            {\n                // return Expr ;\n                DropToken();\n\n                if (returnType != TSLangSymbolTypes.null_type)\n                {\n                    var t = Expr();\n                    if (t != returnType)\n                    {\n                        SemanticError($\"Expected '{returnType}' return expression\");\n                    }\n                }\n", "                    if (t != returnType)\n                    {\n                        SemanticError($\"Expected '{returnType}' return expression\");\n                    }\n                }\n\n                if (CurrentToken.Type != TSLangTokenTypes.semicolon)\n                    SyntaxError(\"Expected ';'\");\n                else DropToken();\n            }\n            else if (CurrentToken.Type == TSLangTokenTypes.leftBrace)\n            {\n                // { Body }\n                DropToken();\n\n                Body(returnType);\n", "            else if (CurrentToken.Type == TSLangTokenTypes.leftBrace)\n            {\n                // { Body }\n                DropToken();\n\n                Body(returnType);\n\n                if (CurrentToken.Type != TSLangTokenTypes.rightBrace)\n                    SyntaxError(\"Expected '}'\");\n                else DropToken();\n            }", "            else if (CurrentToken.Type == TSLangTokenTypes.kw_def)\n            {\n                // Func\n                Func();\n            }\n            else if (CurrentToken.Type == TSLangTokenTypes.kw_var)\n            {\n                // DefVar ;\n                DefVar();\n\n                if (CurrentToken.Type != TSLangTokenTypes.semicolon)\n                    SyntaxError(\"Expected ';'\");\n                else DropToken();\n            }\n            else\n            {\n                // Expr ;\n                Expr();\n", "                if (CurrentToken.Type != TSLangTokenTypes.semicolon)\n                    SyntaxError(\"Expected ';'\");\n                else DropToken();\n            }\n            else\n            {\n                // Expr ;\n                Expr();\n\n                if (CurrentToken.Type != TSLangTokenTypes.semicolon)\n                    SyntaxError(\"Expected ';'\");\n                else DropToken();\n            }\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// var Type iden\n        /// var Type iden = Expr\n        /// </code>\n        /// </summary>", "                if (CurrentToken.Type != TSLangTokenTypes.semicolon)\n                    SyntaxError(\"Expected ';'\");\n                else DropToken();\n            }\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// var Type iden\n        /// var Type iden = Expr\n        /// </code>\n        /// </summary>", "        private void DefVar()\n        {\n            if (CurrentToken.Type != TSLangTokenTypes.kw_var)\n                SyntaxError(\"Expected 'var'\");\n            else DropToken();\n\n            var type = Type();\n\n            if (type == TSLangSymbolTypes.null_type)\n                SemanticError(\"Cannot define null type variable\");\n\n            string? id = null;", "            if (type == TSLangSymbolTypes.null_type)\n                SemanticError(\"Cannot define null type variable\");\n\n            string? id = null;\n            if (CurrentToken.Type != TSLangTokenTypes.identifier)\n                SyntaxError(\"Expected identifier\");\n            else\n            {\n                id = CurrentToken.Value;\n                DropToken();\n            }\n", "            if (type is not null && type != TSLangSymbolTypes.null_type && id is not null)\n            {\n                if (currentSymTab.Exists(id))\n                    SemanticError($\"Variable with name '{id}' already exists in current scope\");\n                else\n                    currentSymTab.Add(new Variable(id, type));\n            }\n\n            if (CurrentToken.Type == TSLangTokenTypes.equals)\n            {\n                // var Type iden = Expr\n                DropToken();\n\n                Expr();\n            }\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// *EMPTY*\n        /// Type iden\n        /// Type iden, FList\n        /// </code>\n        /// </summary>\n        private List<Variable> FList()\n        {\n            List<Variable> list = new();\n", "            if (CurrentToken.Type == TSLangTokenTypes.equals)\n            {\n                // var Type iden = Expr\n                DropToken();\n\n                Expr();\n            }\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// *EMPTY*\n        /// Type iden\n        /// Type iden, FList\n        /// </code>\n        /// </summary>\n        private List<Variable> FList()\n        {\n            List<Variable> list = new();\n", "            if (CurrentToken.Type == TSLangTokenTypes.rightParenthesis)\n                // *EMPTY*\n                return list;\n\n\n            var type = Type();\n\n            if (type == TSLangSymbolTypes.null_type)\n                SemanticError(\"Cannot define null type function parameter\");\n\n            string? id = null;", "            if (CurrentToken.Type != TSLangTokenTypes.identifier)\n                SyntaxError(\"Expected identifier\");\n            else\n            {\n                id = CurrentToken.Value;\n                DropToken();\n            }\n\n            if (type is not null && type != TSLangSymbolTypes.null_type && id is not null)\n            {\n                list.Add(new Variable(id, type));\n            }\n", "            if (type is not null && type != TSLangSymbolTypes.null_type && id is not null)\n            {\n                list.Add(new Variable(id, type));\n            }\n\n            if (CurrentToken.Type == TSLangTokenTypes.comma)\n            {\n                // Type iden, FList\n                DropToken();\n\n                var next = FList();", "                if (next is not null)\n                {\n                    foreach (Variable v in next)\n                    {\n                        if (list.Any(x => x.Identifier == v.Identifier))\n                            SemanticError($\"Parameter with name '{v.Identifier}' already exists\");\n                        list.Add(v);\n                    }\n                }\n            }\n\n            return list;\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// *EMPTY*\n        /// Expr\n        /// Expr, CList\n        /// </code>\n        /// </summary>\n        private List<SymbolType> CList()\n        {\n            List<SymbolType> list = new();\n", "            if (CurrentToken.Type == TSLangTokenTypes.rightBracket\n                || CurrentToken.Type == TSLangTokenTypes.rightParenthesis)\n            {\n                // *EMPTY*\n                return list;\n            }\n\n            var t = Expr();\n            list.Add(t);\n\n            if (CurrentToken.Type == TSLangTokenTypes.comma)\n            {\n                // Expr, CList\n                DropToken();\n\n                var lst = CList();\n                list.AddRange(lst);\n            }\n\n            return list;\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// int\n        /// vector\n        /// str\n        /// null\n        /// </code>\n        /// </summary>", "            if (CurrentToken.Type == TSLangTokenTypes.comma)\n            {\n                // Expr, CList\n                DropToken();\n\n                var lst = CList();\n                list.AddRange(lst);\n            }\n\n            return list;\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// int\n        /// vector\n        /// str\n        /// null\n        /// </code>\n        /// </summary>", "        private SymbolType Type()\n        {\n            if (CurrentToken.Type == TSLangTokenTypes.kw_int)\n            {\n                DropToken();\n                return TSLangSymbolTypes.integer_type;\n            }\n            else if (CurrentToken.Type == TSLangTokenTypes.kw_vector)\n            {\n                DropToken();\n                return TSLangSymbolTypes.vector_type;\n            }", "            else if (CurrentToken.Type == TSLangTokenTypes.kw_str)\n            {\n                DropToken();\n                return TSLangSymbolTypes.string_type;\n            }\n            else if (CurrentToken.Type == TSLangTokenTypes.kw_null)\n            {\n                DropToken();\n                return TSLangSymbolTypes.null_type;\n            }\n            else\n            {\n                SyntaxError(\"Expected type\");\n                return TSLangSymbolTypes.invalid_type;\n            }\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// Expr\n        /// Expr ? Expr : Expr\n        /// </code>\n        /// </summary>", "        private SymbolType Expr()\n        {\n            var type = LOrExpr();\n\n            while (CurrentToken.Type == TSLangTokenTypes.questionMark)\n            {\n                // Expr ? Expr : Expr\n                int l = CurrentToken.Line;\n                int c = CurrentToken.Column;\n                DropToken();\n", "                if (type != TSLangSymbolTypes.integer_type)\n                    SemanticError(\"Condition expression type must be integer\", l, c);\n\n                var typeL = Expr();\n\n                if (CurrentToken.Type != TSLangTokenTypes.colon)\n                    SyntaxError(\"Expected ':'\");\n                else DropToken();\n\n                var typeR = Expr();\n", "                if (typeL != typeR)\n                {\n                    SemanticError($\"Invalid operation: '{type}' ? '{typeL}' : '{typeR}' \");\n                    type = TSLangSymbolTypes.invalid_type;\n                }\n                else\n                {\n                    type = typeL;\n                }\n            }\n\n            return type;\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// Expr\n        /// Expr || Expr\n        /// </code>\n        /// </summary>", "        private SymbolType LOrExpr()\n        {\n            var typeL = LAndExpr();\n            var type = typeL;\n\n            while (CurrentToken.Type == TSLangTokenTypes.logicalOr)\n            {\n                // Expr || Expr\n                int l = CurrentToken.Line;\n                int c = CurrentToken.Column;\n                string op = CurrentToken.Value;\n                DropToken();\n\n                var typeR = LAndExpr();\n", "                if (typeL != TSLangSymbolTypes.integer_type || typeR != TSLangSymbolTypes.integer_type)\n                {\n                    SemanticError($\"Invalid operation: '{typeL}' {op} '{typeR}'\", l, c);\n                    type = TSLangSymbolTypes.invalid_type;\n                }\n                else if (type != TSLangSymbolTypes.invalid_type)\n                {\n                    type = typeL;\n                }\n\n                typeL = typeR;\n            }\n\n            return type;\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// Expr\n        /// Expr && Expr\n        /// </code>\n        /// </summary>", "        private SymbolType LAndExpr()\n        {\n            var typeL = EqNeqExpr();\n            var type = typeL;\n\n            while (CurrentToken.Type == TSLangTokenTypes.logicalAnd)\n            {\n                // Expr && Expr\n                int l = CurrentToken.Line;\n                int c = CurrentToken.Column;\n                string op = CurrentToken.Value;\n                DropToken();\n\n                var typeR = EqNeqExpr();\n", "                if (typeL != TSLangSymbolTypes.integer_type || typeR != TSLangSymbolTypes.integer_type)\n                {\n                    SemanticError($\"Invalid operation: '{typeL}' {op} '{typeR}'\", l, c);\n                    type = TSLangSymbolTypes.invalid_type;\n                }\n                else if (type != TSLangSymbolTypes.invalid_type)\n                {\n                    type = typeL;\n                }\n\n                typeL = typeR;\n            }\n\n            return type;\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// Expr\n        /// Expr == Expr\n        /// Expr != Expr\n        /// </code>\n        /// </summary>", "        private SymbolType EqNeqExpr()\n        {\n            var typeL = CompareExpr();\n            var type = typeL;\n\n            while (CurrentToken.Type == TSLangTokenTypes.doubleEquals\n                || CurrentToken.Type == TSLangTokenTypes.notEquals)\n            {\n                // Expr == Expr\n                // Expr != Expr\n                int l = CurrentToken.Line;\n                int c = CurrentToken.Column;\n                string op = CurrentToken.Value;\n                DropToken();\n\n                var typeR = CompareExpr();\n", "                if (typeL != TSLangSymbolTypes.integer_type || typeR != TSLangSymbolTypes.integer_type)\n                {\n                    SemanticError($\"Invalid operation: '{typeL}' {op} '{typeR}'\", l, c);\n                    type = TSLangSymbolTypes.invalid_type;\n                }\n                else if (type != TSLangSymbolTypes.invalid_type)\n                {\n                    type = typeL;\n                }\n\n                typeL = typeR;\n            }\n\n            return type;\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// Expr\n        /// Expr > Expr\n        /// Expr &lt; Expr\n        /// Expr >= Expr\n        /// Expr &lt;= Expr\n        /// </code>\n        /// </summary>", "        private SymbolType CompareExpr()\n        {\n            var typeL = AddSubExpr();\n            var type = typeL;\n\n            while (CurrentToken.Type == TSLangTokenTypes.lessThan\n                || CurrentToken.Type == TSLangTokenTypes.greaterThan\n                || CurrentToken.Type == TSLangTokenTypes.lessThanOrEqual\n                || CurrentToken.Type == TSLangTokenTypes.greaterThanOrEqual)\n            {\n                // Expr > Expr\n                // Expr < Expr\n                // Expr >= Expr\n                // Expr <= Expr\n                int l = CurrentToken.Line;\n                int c = CurrentToken.Column;\n                string op = CurrentToken.Value;\n                DropToken();\n\n                var typeR = AddSubExpr();\n", "                if (typeL != TSLangSymbolTypes.integer_type || typeR != TSLangSymbolTypes.integer_type)\n                {\n                    SemanticError($\"Invalid operation: '{typeL}' {op} '{typeR}'\", l, c);\n                    type = TSLangSymbolTypes.invalid_type;\n                }\n                else if (type != TSLangSymbolTypes.invalid_type)\n                {\n                    type = typeL;\n                }\n\n                typeL = typeR;\n            }\n\n            return type;\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// Expr\n        /// Expr + Expr\n        /// Expr - Expr\n        /// </code>\n        /// </summary>", "        private SymbolType AddSubExpr()\n        {\n            var typeL = MulDivModExpr();\n            var type = typeL;\n\n            while (CurrentToken.Type == TSLangTokenTypes.plus\n                || CurrentToken.Type == TSLangTokenTypes.minus)\n            {\n                // Expr + Expr\n                // Expr - Expr\n                int l = CurrentToken.Line;\n                int c = CurrentToken.Column;\n                string op = CurrentToken.Value;\n                DropToken();\n\n                var typeR = MulDivModExpr();\n", "                if (typeL != typeR)\n                {\n                    SemanticError($\"Invalid operation: '{typeL}' {op} '{typeR}'\", l, c);\n                    type = TSLangSymbolTypes.invalid_type;\n                }\n                else if (type != TSLangSymbolTypes.invalid_type)\n                {\n                    type = typeL;\n                }\n\n                typeL = typeR;\n            }\n\n            return type;\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// Expr\n        /// Expr * Expr\n        /// Expr / Expr\n        /// Expr % Expr\n        /// </code>\n        /// </summary>", "        private SymbolType MulDivModExpr()\n        {\n            var typeL = FinalExpr();\n            var type = typeL;\n\n            while (CurrentToken.Type == TSLangTokenTypes.asterisk\n                || CurrentToken.Type == TSLangTokenTypes.slash\n                || CurrentToken.Type == TSLangTokenTypes.percent)\n            {\n                // Expr * Expr\n                // Expr / Expr\n                // Expr % Expr\n                int l = CurrentToken.Line;\n                int c = CurrentToken.Column;\n                string op = CurrentToken.Value;\n                DropToken();\n\n                var typeR = FinalExpr();\n", "                if (typeL != TSLangSymbolTypes.integer_type || typeR != TSLangSymbolTypes.integer_type)\n                {\n                    SemanticError($\"Invalid operation: '{typeL}' {op} '{typeR}'\", l, c);\n                    type = TSLangSymbolTypes.invalid_type;\n                }\n                else if (type != TSLangSymbolTypes.invalid_type)\n                {\n                    type = typeL;\n                }\n\n                typeL = typeR;\n            }\n\n            return type;\n        }\n\n        /// <summary>\n        /// Parses the following grammars:\n        /// <code>\n        /// iden\n        /// iden [ Expr ]\n        /// iden [ Expr ] = Expr\n        /// iden = Expr\n        /// iden ( CList )\n        /// number\n        /// string\n        /// [ CList ]\n        /// ! Expr\n        /// + Expr\n        /// - Expr\n        /// ( Expr )\n        /// </code>\n        /// </summary>", "        private SymbolType FinalExpr()\n        {\n            SymbolType type;\n\n            if (CurrentToken.Type == TSLangTokenTypes.identifier)\n            {\n                // iden\n                var id = CurrentToken.Value;\n                bool found = currentSymTab.Exists(id);\n                ISymbol? symbol = null;\n", "                if (found)\n                {\n                    symbol = currentSymTab.Get(id);\n                    type = symbol.Type;\n                }\n                else\n                {\n                    SemanticError($\"Cannot find variable or function '{id}' in current scope\");\n                    type = TSLangSymbolTypes.invalid_type;\n                }\n                DropToken();\n", "                if (CurrentToken.Type == TSLangTokenTypes.leftBracket)\n                {\n                    // iden [ Expr ]\n                    type = TSLangSymbolTypes.integer_type;\n\n                    if (found && symbol!.Type != TSLangSymbolTypes.vector_type)\n                    {\n                        SemanticError($\"'{id}' is not vector\");\n                    }\n                    DropToken();\n\n                    var indexType = Expr();", "                    if (indexType != TSLangSymbolTypes.integer_type)\n                        SemanticError($\"Cannot use expression of type '{indexType}' as vector index\");\n\n                    if (CurrentToken.Type != TSLangTokenTypes.rightBracket)\n                        SyntaxError(\"Expected ']'\");\n                    DropToken();\n\n                    if (CurrentToken.Type == TSLangTokenTypes.equals)\n                    {\n                        // iden [ Expr ] = Expr\n                        int l = CurrentToken.Line;\n                        int c = CurrentToken.Column;\n                        DropToken();\n\n                        var assignedType = Expr();\n", "                        if (assignedType != TSLangSymbolTypes.integer_type)\n                            SemanticError($\"Cannot assign expression of type '{assignedType}' to a vector member\", l, c);\n                    }\n                }\n                else if (CurrentToken.Type == TSLangTokenTypes.equals)\n                {\n                    // iden = Expr\n                    int l = CurrentToken.Line;\n                    int c = CurrentToken.Column;\n                    DropToken();\n\n                    var assignedType = Expr();\n", "                    if (found)\n                    {\n                        var t = symbol!.Type;\n                        if (symbol is Function)\n                        {\n                            SemanticError(\"Cannot assign to a function\", l, c);\n                        }\n                        else if (assignedType != t)\n                        {\n                            SemanticError($\"Cannot assign expression of type '{assignedType}' to a variable of type '{t}'\", l, c);\n                        }\n                    }\n\n                    type = assignedType;\n                }", "                else if (CurrentToken.Type == TSLangTokenTypes.leftParenthesis)\n                {\n                    // iden ( CList )\n                    int l = CurrentToken.Line;\n                    int c = CurrentToken.Column;\n                    DropToken();\n\n                    if (found)\n                    {\n                        if (symbol is not Function)\n                        {\n                            SemanticError($\"'{id}' is not a function\", l, c);\n                        }\n                        else\n                        {\n                            type = symbol!.Type;\n                        }\n                    }\n                    else\n                    {\n                        type = TSLangSymbolTypes.invalid_type;\n                    }\n\n                    var args = CList();\n", "                        if (symbol is not Function)\n                        {\n                            SemanticError($\"'{id}' is not a function\", l, c);\n                        }\n                        else\n                        {\n                            type = symbol!.Type;\n                        }\n                    }\n                    else\n                    {\n                        type = TSLangSymbolTypes.invalid_type;\n                    }\n\n                    var args = CList();\n", "                    if (symbol is Function f)\n                    {\n                        int pc = f.ParametersCount;\n\n                        if (pc != args.Count)\n                        {\n                            SemanticError($\"Expected {pc} arguments, got {args.Count}\", l, c);\n                        }\n\n                        pc = Math.Min(pc, args.Count);\n", "                        for (int i = 0; i < pc; i++)\n                        {\n                            var et = f.Parameters[i].Type;\n                            if (et != args[i])\n                            {\n                                SemanticError($\"Arg{i + 1}: Expected argument of type '{et}', got '{args[i]}'\", l, c);\n                            }\n                        }\n                    }\n\n                    if (CurrentToken.Type != TSLangTokenTypes.rightParenthesis)\n                        SyntaxError(\"Expected ')'\");\n                    DropToken();\n                }\n            }", "                    if (CurrentToken.Type != TSLangTokenTypes.rightParenthesis)\n                        SyntaxError(\"Expected ')'\");\n                    DropToken();\n                }\n            }\n            else if (CurrentToken.Type == TSLangTokenTypes.literal_integer)\n            {\n                // number\n                type = TSLangSymbolTypes.integer_type;\n                DropToken();\n            }", "            else if (CurrentToken.Type == TSLangTokenTypes.literal_string_doubleQuote\n                || CurrentToken.Type == TSLangTokenTypes.literal_string_singleQuote)\n            {\n                // string\n                type = TSLangSymbolTypes.string_type;\n                DropToken();\n            }\n            else if (CurrentToken.Type == TSLangTokenTypes.leftBracket)\n            {\n                // [ CList ]\n                type = TSLangSymbolTypes.vector_type;\n                DropToken();\n\n                CList();\n", "                if (CurrentToken.Type != TSLangTokenTypes.rightBracket)\n                    SyntaxError(\"Expected ']'\");\n                DropToken();\n            }\n            else if (CurrentToken.Type == TSLangTokenTypes.exclamationMark\n                || CurrentToken.Type == TSLangTokenTypes.plus\n                || CurrentToken.Type == TSLangTokenTypes.minus)\n            {\n                // ! Expr\n                // + Expr\n                // - Expr\n                int l = CurrentToken.Line;\n                int c = CurrentToken.Column;\n                string op = CurrentToken.Value;\n                DropToken();\n\n                var t = Expr();\n", "                if (t != TSLangSymbolTypes.integer_type)\n                {\n                    SemanticError($\"Invalid operation '{op}' on type '{t}'\");\n                    type = TSLangSymbolTypes.invalid_type;\n                }\n                else\n                {\n                    type = t;\n                }\n            }\n            else if (CurrentToken.Type == TSLangTokenTypes.leftParenthesis)\n            {\n                // ( Expr )\n                DropToken();\n\n                type = Expr();\n", "            else if (CurrentToken.Type == TSLangTokenTypes.leftParenthesis)\n            {\n                // ( Expr )\n                DropToken();\n\n                type = Expr();\n\n                if (CurrentToken.Type != TSLangTokenTypes.rightParenthesis)\n                    SyntaxError(\"Expected ')'\");\n                DropToken();\n            }\n            else\n            {\n                type = TSLangSymbolTypes.invalid_type;\n\n                SyntaxError(\"Expected valid expression\");\n\n                TokenType[] recoveryTokens =\n                {\n                    TSLangTokenTypes.semicolon,\n                    TSLangTokenTypes.rightParenthesis,\n                    TSLangTokenTypes.rightBracket,\n                    TSLangTokenTypes.rightBrace,\n                    TSLangTokenTypes.kw_to,\n                    TSLangTokenTypes.comma,\n                };", "                while (!recoveryTokens.Contains(CurrentToken.Type) && !Done)\n                {\n                    DropToken();\n                }\n            }\n\n            return type;\n        }\n    }\n}\n"]}
{"filename": "Parser/TSLangParser.cs", "chunked_list": ["\ufeffusing Parser.SymbolTableUtil;\nusing Tokenizer;\n\nnamespace Parser\n{\n    /// <summary>\n    /// Represents a TSLang source code parser.\n    /// </summary>\n    public partial class TSLangParser\n    {\n        /// <summary>\n        /// A <see cref=\"TSLangTokenizer\"/> which provides tokens of code.\n        /// </summary>", "    public partial class TSLangParser\n    {\n        /// <summary>\n        /// A <see cref=\"TSLangTokenizer\"/> which provides tokens of code.\n        /// </summary>\n        private readonly TSLangTokenizer tokenizer;\n\n        /// <summary>\n        /// A <see cref=\"TextWriter\"/> to write errors on it.\n        /// </summary>\n        private readonly TextWriter errorStream;\n\n        /// <summary>\n        /// The last token provided by tokenizer\n        /// </summary>", "        private readonly TextWriter errorStream;\n\n        /// <summary>\n        /// The last token provided by tokenizer\n        /// </summary>\n        private Token lastToken;\n\n        /// <summary>\n        /// Gets current token.\n        /// </summary>\n        private Token CurrentToken => lastToken;\n\n        /// <summary>\n        /// Root symbol table of the code.\n        /// </summary>", "        private Token CurrentToken => lastToken;\n\n        /// <summary>\n        /// Root symbol table of the code.\n        /// </summary>\n        private readonly SymbolTable rootSymTab;\n\n        /// <summary>\n        /// Symbol table for current scope.\n        /// </summary>\n        private SymbolTable currentSymTab;\n\n        /// <summary>\n        /// Gets whether an error occured while parsing the code.\n        /// </summary>", "        private SymbolTable currentSymTab;\n\n        /// <summary>\n        /// Gets whether an error occured while parsing the code.\n        /// </summary>\n        public bool HasError { get; private set; }\n\n        /// <summary>\n        /// Last token which caused syntax error.\n        /// </summary>\n        private Token lastErrorToken;\n\n        /// <summary>\n        /// Gets whether parsing is done.\n        /// </summary>", "        private Token lastErrorToken;\n\n        /// <summary>\n        /// Gets whether parsing is done.\n        /// </summary>\n        public bool Done { get; private set; }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"TSLangParser\"/> class\n        /// for the provided source code stream.\n        /// </summary>\n        /// <param name=\"stream\">A <see cref=\"StreamReader\"/> providing source code.</param>\n        public TSLangParser(StreamReader stream, TextWriter errorStream)\n        {\n            tokenizer = new TSLangTokenizer(stream);\n            this.errorStream = errorStream;\n\n            HasError = false;\n            Done = false;\n            lastToken = new Token(TSLangTokenTypes.comment, \"\", 0, 0);\n            lastErrorToken = lastToken;\n            rootSymTab = new();\n            currentSymTab = rootSymTab;\n\n            DropToken();\n        }\n\n        /// <summary>\n        /// Starts parsing the provided souce code.\n        /// </summary>", "        public void Parse()\n        {\n            try\n            {\n                Prog();\n            }\n            catch { }\n        }\n\n        /// <summary>\n        /// Gets next token from <see cref=\"tokenizer\"/> (if available)\n        /// and puts it in <see cref=\"CurrentToken\"/>.\n        /// </summary>", "        private void DropToken()\n        {\n            if (tokenizer.EndOfStream)\n            {\n                Done = true;\n                lastToken = new Token(TSLangTokenTypes.invalid, \"\", lastToken.Column, lastToken.Line);\n                return;\n            }\n\n            do\n            {\n                lastToken = tokenizer.NextToken();", "                if (lastToken.Type == TSLangTokenTypes.invalid)\n                {\n                    SyntaxError(\"Invalid token: \" + lastToken.Value);\n                }\n            } while (lastToken.Type == TSLangTokenTypes.comment || lastToken.Type == TSLangTokenTypes.invalid);\n        }\n\n        /// <summary>\n        /// Prints syntax error message and its location\n        /// to the provided <see cref=\"errorStream\"/>.\n        /// </summary>\n        /// <param name=\"message\">Message of error.</param>", "        private void SyntaxError(string message)\n        {\n            HasError = true;\n\n            if (lastErrorToken == CurrentToken)\n            {\n                DropToken();\n                if (Done)\n                    throw new Exception(\"Reached end of file.\");\n                return;\n            }\n\n            lastErrorToken = CurrentToken;\n\n            errorStream.WriteLine(\n                CurrentToken.Line.ToString() + \":\" +\n                CurrentToken.Column.ToString() + \":\\t\" +\n                message);\n        }\n\n        /// <summary>\n        /// Prints semantic error message and its location\n        /// to the provided <see cref=\"errorStream\"/>.\n        /// </summary>\n        /// <param name=\"message\">Message of error.</param>", "        private void SemanticError(string message)\n        {\n            HasError = true;\n\n            errorStream.WriteLine(\n                CurrentToken.Line.ToString() + \":\" +\n                CurrentToken.Column.ToString() + \":\\t\" +\n                message);\n\n        }\n\n        /// <summary>\n        /// Prints semantic error message and its location\n        /// to the provided <see cref=\"errorStream\"/>.\n        /// </summary>\n        /// <param name=\"message\">Message of error.</param>\n        /// <param name=\"line\">Line of error.</param>\n        /// <param name=\"col\">Column of error.</param>", "        private void SemanticError(string message, int line, int col)\n        {\n            HasError = true;\n\n            errorStream.WriteLine(\n                line + \":\" +\n                col + \":\\t\" +\n                message);\n\n        }\n    }\n}\n"]}
{"filename": "Parser/Program.cs", "chunked_list": ["\ufeffusing Parser;\n\nstring path = args.Length == 0 ? Console.ReadLine()! : args[0];\n\nTSLangParser parser = new(new StreamReader(path), Console.Error);\n\nparser.Parse();\n\nif (!parser.HasError)\n{\n    Console.WriteLine(\"Parsing finished successfully.\");\n}", "if (!parser.HasError)\n{\n    Console.WriteLine(\"Parsing finished successfully.\");\n}"]}
{"filename": "Parser/SymbolTableUtil/SymbolTable.cs", "chunked_list": ["\ufeffnamespace Parser.SymbolTableUtil\n{\n    /// <summary>\n    /// Represents a symbol table for TSLang.\n    /// </summary>\n    internal class SymbolTable\n    {\n        /// <summary>\n        /// Gets the symbol table of the upper scope.\n        /// </summary>\n        public SymbolTable? UpperScope { get; }\n\n        /// <summary>\n        /// Includes symbols of the symbol table.\n        /// </summary>", "        private readonly Dictionary<string, ISymbol> symbols;\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"SymbolTable\"/> class.\n        /// </summary>\n        public SymbolTable()\n        {\n            symbols = new();\n        }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"SymbolTable\"/> class.\n        /// </summary>\n        /// <param name=\"upperScope\">The symbol table for the upper scope.</param>\n        public SymbolTable(SymbolTable? upperScope)\n        {\n            symbols = new();\n            UpperScope = upperScope;\n        }\n\n        /// <summary>\n        /// Checks whether a symbol with provided identifier (name) exists in the symbol table.\n        /// </summary>\n        /// <param name=\"identifier\">Identifier to check for.</param>\n        /// <returns>\n        /// True if a symbol with the specified identifier exists in the symbol table.\n        /// False otherwise.\n        /// </returns>", "        public bool Exists(string identifier)\n        {\n            bool e;\n            SymbolTable? st = this;\n\n            do\n            {\n                e = st.symbols.ContainsKey(identifier);\n                st = st.UpperScope;\n            } while (!e && st is not null);\n\n            return e;\n        }\n\n        /// <summary>\n        /// Adds new symbol to the symbol table.\n        /// </summary>\n        /// <param name=\"symbol\">The symbol to be added to the symbol table.</param>\n        /// <exception cref=\"ArgumentException\"></exception>", "            } while (!e && st is not null);\n\n            return e;\n        }\n\n        /// <summary>\n        /// Adds new symbol to the symbol table.\n        /// </summary>\n        /// <param name=\"symbol\">The symbol to be added to the symbol table.</param>\n        /// <exception cref=\"ArgumentException\"></exception>\n        public void Add(ISymbol symbol)\n        {", "        public void Add(ISymbol symbol)\n        {\n            if (Exists(symbol.Identifier))\n                throw new ArgumentException(\"A symbol with the same identifier already exists in the symbol table.\");\n            symbols.Add(symbol.Identifier, symbol);\n        }\n\n        /// <summary>\n        /// Gets the symbol with specified identifier (name) from the symbol table.\n        /// </summary>\n        /// <param name=\"identifier\">Identifier (name) of the symbol.</param>\n        /// <returns>The symbol with the specified identifier.</returns>\n        /// <exception cref=\"ArgumentException\"></exception>", "        public ISymbol Get(string identifier)\n        {\n            SymbolTable? st = this;\n\n            do\n            {\n                if (st.symbols.ContainsKey(identifier))\n                    return st.symbols[identifier];\n                st = st.UpperScope;\n            } while (st is not null);\n\n            throw new ArgumentException(\"Identifier does not exist in the symbol table.\");\n        }\n    }\n}\n", "            } while (st is not null);\n\n            throw new ArgumentException(\"Identifier does not exist in the symbol table.\");\n        }\n    }\n}\n"]}
{"filename": "Parser/SymbolTableUtil/SymbolType.cs", "chunked_list": ["\ufeffusing Tokenizer;\n\nnamespace Parser.SymbolTableUtil\n{\n    /// <summary>\n    /// Represents type of an <see cref=\"ISymbol\"/>.\n    /// </summary>\n    public class SymbolType\n    {\n        /// <summary>\n        /// Gets name of the type.\n        /// </summary>", "        public string Name { get; }\n\n        /// <summary>\n        /// Gets keyword associated with this type.\n        /// </summary>\n        public TokenType TokenType { get; }\n\n        /// <summary>\n        /// Initializes new instance of the <see cref=\"SymbolType\"/> class.\n        /// </summary>\n        /// <param name=\"name\">Name of the type.</param>\n        /// <param name=\"type\">A <see cref=\"Tokenizer.TokenType\"/> representing keyword associated with this type.</param>\n        public SymbolType(string name, TokenType type)\n        {\n            Name = name;\n            TokenType = type;\n        }\n", "        public override string ToString()\n        {\n            return Name;\n        }\n    }\n}\n"]}
{"filename": "Parser/SymbolTableUtil/TSLangSymbolTypes.cs", "chunked_list": ["\ufeffusing Tokenizer;\n\nnamespace Parser.SymbolTableUtil\n{\n    /// <summary>\n    /// Static class which includes Symbol types of TSLang.\n    /// </summary>\n    public static class TSLangSymbolTypes\n    {\n        public static readonly SymbolType\n            integer_type = new(\"integer\", TSLangTokenTypes.kw_int),\n\n            string_type = new(\"string\", TSLangTokenTypes.kw_str),\n\n            vector_type = new(\"vector\", TSLangTokenTypes.kw_vector),\n\n            null_type = new(\"null\", TSLangTokenTypes.kw_null),\n\n            invalid_type = new(\"invalid\", TSLangTokenTypes.invalid);\n    }\n}\n", "        public static readonly SymbolType\n            integer_type = new(\"integer\", TSLangTokenTypes.kw_int),\n\n            string_type = new(\"string\", TSLangTokenTypes.kw_str),\n\n            vector_type = new(\"vector\", TSLangTokenTypes.kw_vector),\n\n            null_type = new(\"null\", TSLangTokenTypes.kw_null),\n\n            invalid_type = new(\"invalid\", TSLangTokenTypes.invalid);\n    }\n}\n"]}
{"filename": "Parser/SymbolTableUtil/Variable.cs", "chunked_list": ["\ufeffnamespace Parser.SymbolTableUtil\n{\n    /// <summary>\n    /// Represents a variable in symbol table.\n    /// </summary>\n    internal class Variable : ISymbol\n    {\n        /// <summary>\n        /// Gets identifier (name) of the variable.\n        /// </summary>\n        public string Identifier { get; }\n\n        /// <summary>\n        /// Gets type of the variable.\n        /// </summary>", "        public string Identifier { get; }\n\n        /// <summary>\n        /// Gets type of the variable.\n        /// </summary>\n        public SymbolType Type { get; }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"Variable\"/> struct.\n        /// </summary>\n        /// <param name=\"identifier\">Identifier (name) of the variable.</param>\n        /// <param name=\"type\">Type of the variable. Cannot be <see cref=\"SymbolType.null_type\"/>.</param>\n        /// <exception cref=\"ArgumentException\"></exception>\n        public Variable(string identifier, SymbolType type)\n        {", "            if (type == TSLangSymbolTypes.null_type)\n            {\n                throw new ArgumentException(\"Variable type cannot be null.\");\n            }\n            Identifier = identifier;\n            Type = type;\n        }\n    }\n}\n"]}
{"filename": "Parser/SymbolTableUtil/Function.cs", "chunked_list": ["\ufeffusing System.Collections.ObjectModel;\n\nnamespace Parser.SymbolTableUtil\n{\n    /// <summary>\n    /// Represents a function in symbol table.\n    /// </summary>\n    internal class Function : ISymbol\n    {\n        /// <summary>\n        /// Gets identifier (name) of the function.\n        /// </summary>", "        public string Identifier { get; }\n\n        /// <summary>\n        /// Gets return type of the function.\n        /// </summary>\n        public SymbolType Type { get; }\n\n        /// <summary>\n        /// Gets list of the function parameters.\n        /// </summary>\n        public ReadOnlyCollection<Variable> Parameters { get; }\n\n        /// <summary>\n        /// Gets count of the function parameters.\n        /// </summary>", "        public int ParametersCount => Parameters.Count;\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"Function\"/> struct.\n        /// </summary>\n        /// <param name=\"identifier\">Identifier (name) of the function.</param>\n        /// <param name=\"type\">Return type of the function.</param>\n        /// <param name=\"parameters\">Array of the function parameters.</param>\n        public Function(string identifier, SymbolType type, Variable[] parameters)\n        {\n            Identifier = identifier;\n            Type = type;\n            Parameters = new ReadOnlyCollection<Variable>(parameters);\n        }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"Function\"/> struct.\n        /// </summary>\n        /// <param name=\"identifier\">Identifier (name) of the function.</param>\n        /// <param name=\"type\">Return type of the function.</param>\n        /// <param name=\"parameters\">List of the function parameters.</param>\n        public Function(string identifier, SymbolType type, List<Variable> parameters)\n        {\n            Identifier = identifier;\n            Type = type;\n            Parameters = new ReadOnlyCollection<Variable>(parameters);\n        }\n    }\n}\n"]}
{"filename": "Parser/SymbolTableUtil/ISymbol.cs", "chunked_list": ["\ufeffnamespace Parser.SymbolTableUtil\n{\n    /// <summary>\n    /// Represents a symbol which has a name and type.\n    /// </summary>\n    internal interface ISymbol\n    {\n        /// <summary>\n        /// Gets name of the symbol.\n        /// </summary>\n        public string Identifier { get; }\n\n        /// <summary>\n        /// Gets type of the symbol.\n        /// </summary>", "        public string Identifier { get; }\n\n        /// <summary>\n        /// Gets type of the symbol.\n        /// </summary>\n        public SymbolType Type { get; }\n    }\n}\n"]}
