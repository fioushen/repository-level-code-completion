{"filename": "src/Gum/Parser.cs", "chunked_list": ["\ufeffusing System;\nusing System.Data.Common;\nusing System.Reflection;\nusing System.Text.RegularExpressions;\nusing Gum.InnerThoughts;\nusing Gum.Utilities;\n\nnamespace Gum\n{\n    /// <summary>", "{\n    /// <summary>\n    /// These are the directives used to parse the current line instruction.\n    /// </summary>\n    internal enum TokenChar\n    {\n        None = 0,\n        Situation = '=',\n        BeginCondition = '(',\n        EndCondition = ')',\n        OnceBlock = '-',\n        MultipleBlock = '+',\n        BeginAction = '[',\n        EndAction = ']',\n        ChoiceBlock = '>',\n        Flow = '@',\n        Negative = '!',\n        Debug = '%'\n    }\n", "    internal static partial class Tokens\n    {\n        public const string Comments = \"//\";\n    }\n\n    public partial class Parser\n    {\n        private static readonly Regex _indentation = new Regex(@\"^(\\t|    |[-+]   )*\", RegexOptions.Compiled);\n        private const char _separatorChar = ' ';\n\n        private readonly string[] _lines;\n\n        /// <summary>\n        /// Each parser will consist into a single script.\n        /// The owner shall be assigned once this gets instantiated in the engine.\n        /// </summary>", "        private const char _separatorChar = ' ';\n\n        private readonly string[] _lines;\n\n        /// <summary>\n        /// Each parser will consist into a single script.\n        /// The owner shall be assigned once this gets instantiated in the engine.\n        /// </summary>\n        private readonly CharacterScript _script;\n\n        /// <summary>\n        /// The current block of dialog that currently belong to <see cref=\"CharacterScript.CurrentSituation\"/>.\n        /// </summary>", "        private readonly CharacterScript _script;\n\n        /// <summary>\n        /// The current block of dialog that currently belong to <see cref=\"CharacterScript.CurrentSituation\"/>.\n        /// </summary>\n        private int _currentBlock = 0;\n\n        private Block Block => _script.CurrentSituation.Blocks[_currentBlock];\n\n        /// <summary>\n        /// Current line without any comments, used for diagnostics.\n        /// </summary>", "        private string _currentLine = string.Empty;\n\n        /// <summary>\n        /// Keep tack of the latest index of each line.\n        /// </summary>\n        private int _lastIndentationIndex = 0;\n\n        /// <summary>\n        /// If applicable, tracks the first token of the last line.\n        /// This is used to tweak our own indentation rules.\n        /// </summary>\n        private TokenChar? _lastLineToken = null;\n", "        private int _indentationIndex = 0;\n\n        /// <summary>\n        /// The last directive '@random' to randomize the following choices.\n        /// </summary>\n        private bool _random = false;\n\n        /// <summary>\n        /// Whether the last line processed was an action.\n        /// </summary>\n        private bool _wasPreviousAction = false;\n", "        private bool _wasPreviousAction = false;\n\n        private bool ConsumeIsRandom()\n        {\n            bool random = _random;\n            _random = false;\n\n            return random;\n        }\n\n        /// <summary>\n        /// The last directive '@' to play an amount of times.\n        /// </summary>", "        private int _playUntil = -1;\n\n        private int ConsumePlayUntil()\n        {\n            int playUntil = _playUntil;\n            _playUntil = -1;\n\n            return playUntil;\n        }\n\n        //\n        // Post-analysis variables.\n        // \n\n        /// <summary>\n        /// This is for validating all the goto destination statements.\n        /// </summary>", "        private readonly List<(Block Block, string Location, int Line)> _gotoDestinations = new();\n\n        internal static CharacterScript? Parse(string file)\n        {\n            string[] lines = File.ReadAllLines(file);\n\n            Parser parser = new(name: Path.GetFileNameWithoutExtension(file), lines);\n            return parser.Start();\n        }\n\n        internal Parser(string name, string[] lines)\n        {\n            _script = new(name);\n            _lines = lines;\n        }\n\n        internal CharacterScript? Start()\n        {\n            int index = 0;\n", "            foreach (string rawLine in _lines)\n            {\n                index++;\n\n                ReadOnlySpan<char> lineNoComments = rawLine.AsSpan();\n\n                // First, start by ripping all the comments in this line.\n                int comment = lineNoComments.IndexOf(Tokens.Comments);\n                if (comment != -1)\n                {\n                    lineNoComments = lineNoComments.Slice(start: 0, length: comment);\n                    lineNoComments = lineNoComments.TrimEnd();\n                }\n\n                ReadOnlySpan<char> lineNoIndent = lineNoComments.TrimStart();", "                if (comment != -1)\n                {\n                    lineNoComments = lineNoComments.Slice(start: 0, length: comment);\n                    lineNoComments = lineNoComments.TrimEnd();\n                }\n\n                ReadOnlySpan<char> lineNoIndent = lineNoComments.TrimStart();\n                if (lineNoIndent.IsEmpty) continue;\n\n                _currentLine = lineNoComments.ToString();\n\n                // TODO: I think I can be fancy and use ReadOnlySpan here instead.\n                // However, I couldn't really find a smart way to list the group matches with a ValueMatch yet.\n                MatchCollection result = _indentation.Matches(_currentLine);\n\n                // Count the indentation based on the regex captures result.\n                _lastIndentationIndex = _indentationIndex;\n                _indentationIndex = result[0].Groups[1].Captures.Count;\n\n                // For science!\n                int column = lineNoComments.Length - lineNoIndent.Length;\n", "                if (lineNoIndent.IsEmpty) continue;\n\n                if (!ProcessLine(lineNoIndent, index, column))\n                {\n                    return null;\n                }\n\n                // Track whatever was the last token used.\n                if (Enum.IsDefined(typeof(TokenChar), (int)lineNoIndent[0]))\n                {\n                    _lastLineToken = (TokenChar)lineNoIndent[0];\n                }\n                else\n                {\n                    _lastLineToken = null;\n                }\n", "                if (Enum.IsDefined(typeof(TokenChar), (int)lineNoIndent[0]))\n                {\n                    _lastLineToken = (TokenChar)lineNoIndent[0];\n                }\n                else\n                {\n                    _lastLineToken = null;\n                }\n\n                if (_script.HasCurrentSituation is false)\n                {\n                    OutputHelpers.WriteError($\"Expected a situation (=) to be declared before line {index}.\");\n                    return null;\n                }\n            }\n", "                if (_script.HasCurrentSituation is false)\n                {\n                    OutputHelpers.WriteError($\"Expected a situation (=) to be declared before line {index}.\");\n                    return null;\n                }\n            }\n\n            if (!ResolveAllGoto())\n            {\n                return null;\n            }\n\n            _ = Trim();\n\n            return _script;\n        }\n\n        /// <summary>\n        /// Check whether the first character of a line has a token defined.\n        /// </summary>", "        private bool Defines(ReadOnlySpan<char> line, TokenChar token, string? stringAfterToken = null)\n        {\n            ReadOnlySpan<char> word = GetNextWord(line, out int end).TrimStart();\n            while (end != -1 && !word.IsEmpty)\n            {\n                if (word[0] == (char)token)\n                {\n                    if (stringAfterToken is null)\n                    {\n                        return true;\n                    }", "                    else if (word.Slice(1).StartsWith(stringAfterToken))\n                    {\n                        return true;\n                    }\n                }\n\n                if (!Enum.IsDefined(typeof(TokenChar), (int)word[0]))\n                {\n                    return false;\n                }\n", "                if (end == line.Length)\n                {\n                    return false;\n                }\n\n                line = line.Slice(end);\n                word = GetNextWord(line, out end).TrimStart();\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// Check whether the first character of a line has a token defined.\n        /// </summary>", "        private bool Defines(ReadOnlySpan<char> line, TokenChar[] tokens)\n        {\n            HashSet<char> tokensChar = tokens.Select(t => (char)t).ToHashSet();\n\n            ReadOnlySpan<char> word = GetNextWord(line, out int end).TrimStart();\n            while (end != -1 && !word.IsEmpty)\n            {\n                if (tokensChar.Contains(word[0]))\n                {\n                    return true;\n                }\n", "                if (Enum.IsDefined(typeof(TokenChar), (int)word[0]))\n                {\n                    return false;\n                }\n\n                if (end >= line.Length)\n                {\n                    return false;\n                }\n\n                line = line.Slice(end);\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// Read the next line, without any comments.\n        /// </summary>\n        /// <returns>Whether it was successful and no error occurred.</returns>", "        private bool ProcessLine(ReadOnlySpan<char> line, int index, int column, int depth = 0, int joinLevel = 0, bool hasCreatedBlock = false)\n        {\n            if (line.IsEmpty) return true;\n\n            bool isNestedBlock = false;\n\n            // If this is not a situation declaration ('=') but a situation has not been declared yet!\n            if (line[0] != (char)TokenChar.Situation && _script.HasCurrentSituation is false)\n            {\n                OutputHelpers.WriteError($\"Expected a situation (=) to be declared before line {index}.\");\n                return false;\n            }", "            else if (depth == 0 && _script.HasCurrentSituation)\n            {\n                // This fixes the lack of indentation of choice dialogs. This is so we can\n                // properly join scenarios such as:\n                //\n                //  >> Something...\n                //  > Or else!\n                //  > No?\n                //\n                //  Okay.\n                bool isChoice = Defines(line, TokenChar.ChoiceBlock);", "                if (_indentationIndex == _lastIndentationIndex &&\n                    _lastLineToken == TokenChar.ChoiceBlock && !isChoice)\n                {\n                    _lastIndentationIndex += 1;\n                }\n\n                // We are on a valid situation, check whether we need to join dialogs.\n                // Indentation changed:\n                //     < from here\n                // ^ to here\n                if (_indentationIndex < _lastIndentationIndex)\n                {\n                    joinLevel = _lastIndentationIndex - _indentationIndex;\n                    bool createJoinBlock = true;\n\n                    // If the last line was actually a flow (@) and this is a join,\n                    // we'll likely disregard the last join.\n                    //\n                    //  @1  Hi!\n                    //      Bye.\n                    //\n                    //  Join. <- this will apply a join.\n                    //\n                    //  @1  Hi!\n                    //  Bye. <- this will apply a join.\n                    //\n                    //  (something)\n                    //      @1  Hi!\n                    //\n                    //  Bye. <- this will apply a join on (something).", "                if (_indentationIndex < _lastIndentationIndex)\n                {\n                    joinLevel = _lastIndentationIndex - _indentationIndex;\n                    bool createJoinBlock = true;\n\n                    // If the last line was actually a flow (@) and this is a join,\n                    // we'll likely disregard the last join.\n                    //\n                    //  @1  Hi!\n                    //      Bye.\n                    //\n                    //  Join. <- this will apply a join.\n                    //\n                    //  @1  Hi!\n                    //  Bye. <- this will apply a join.\n                    //\n                    //  (something)\n                    //      @1  Hi!\n                    //\n                    //  Bye. <- this will apply a join on (something).", "                    if (_lastLineToken == TokenChar.Flow && \n                        _script.CurrentSituation.PeekLastBlockParent().Conditional)\n                    {\n                        joinLevel += 1;\n                    }\n\n                    if (Defines(line, TokenChar.BeginCondition))\n                    {\n                        createJoinBlock = false;\n\n                        Block lastBlock = _script.CurrentSituation.PeekLastBlock();\n                        Block parent = _script.CurrentSituation.PeekBlockAt(joinLevel);\n\n                        // This might backfire when it's actually deeper into the condition, but okay.", "                        if (lastBlock.Requirements.Count == 0 && parent.IsChoice)\n                        {\n                            // Consider this scenario:\n                            // (Condition)\n                            //     Block!\n                            //     >> Option A or B?\n                            //     > A\n                            //     > B                   <- parent was choice, so disregard one join...?\n                            //         Something from B. <- last block was here\n                            // (...)                     <- joinLevel is 2. \n                            //     Branch\n                            joinLevel -= 1;\n                        }\n                    }", "                    else if (Defines(line, new TokenChar[] {\n                        TokenChar.Situation,\n                        TokenChar.ChoiceBlock,\n                        TokenChar.MultipleBlock,\n                        TokenChar.OnceBlock }))\n                    {\n                        if (line.Length > 1 && line[1] == (char)TokenChar.ChoiceBlock)\n                        {\n                            // Actually a ->\n                        }\n                        else\n                        {\n                            // > Hell yeah!\n                            //     (LookForFire)\n                            //         Yes...?\n                            // > Why would I? <- this needs to pop", "                            if (_script.CurrentSituation.PeekLastBlock().Conditional)\n                            {\n                                joinLevel -= 1;\n\n                                // This is a bit awkward, but I added this in cases which:\n                                //  -   Option a\n                                //      (Something) < parent of this is non linear, so extra pop is needed\n                                //          Hello\n                                //  -   Option b\n                                if (_script.CurrentSituation.PeekLastBlockParent().NonLinearNode)\n                                {\n                                    _script.CurrentSituation.PopLastBlock();\n                                    createJoinBlock = false;\n                                }\n                            }\n", "                                if (_script.CurrentSituation.PeekLastBlockParent().NonLinearNode)\n                                {\n                                    _script.CurrentSituation.PopLastBlock();\n                                    createJoinBlock = false;\n                                }\n                            }\n\n                            if (line[0] != (char)TokenChar.MultipleBlock && \n                                line[0] != (char)TokenChar.OnceBlock)\n                            {\n                                _script.CurrentSituation.PopLastBlock();\n\n                                // We might need to do this check out of this switch case?", "                                if (_script.CurrentSituation.PeekLastBlock().IsChoice &&\n                                    _script.CurrentSituation.PeekLastEdgeKind() != EdgeKind.Choice)\n                                {\n                                    _script.CurrentSituation.PopLastBlock();\n                                    joinLevel -= 1;\n                                }\n\n                                createJoinBlock = false;\n                            }\n                        }\n                    }\n\n                    // Depending where we were, we may need to \"join\" different branches.", "                    if (createJoinBlock)\n                    {\n                        Block? result = _script.CurrentSituation.AddBlock(ConsumePlayUntil(), joinLevel, isNested: false);\n                        if (result is null)\n                        {\n                            OutputHelpers.WriteError($\"Unable to join line {index}. Was the indentation correct?\");\n                            return false;\n                        }\n\n                        _currentBlock = result.Id;\n                        hasCreatedBlock = true;\n                    }\n                }", "                else if (_indentationIndex > _lastIndentationIndex)\n                {\n                    // May be used if we end up creating a new block.\n                    // (first indent obviously won't count)\n                    isNestedBlock = _indentationIndex != 1;\n\n                    // Since the last block was a choice, we will need to create another block to continue it.\n                    // AS LONG AS the next block is not another choice!\n                    if (_script.CurrentSituation.PeekLastBlock().IsChoice && !(line.Length > 1 && line[1] == (char)TokenChar.ChoiceBlock))\n                    {\n                        Block? result = _script.CurrentSituation.AddBlock(ConsumePlayUntil(), joinLevel: 0, isNested: true);", "                    if (_script.CurrentSituation.PeekLastBlock().IsChoice && !(line.Length > 1 && line[1] == (char)TokenChar.ChoiceBlock))\n                    {\n                        Block? result = _script.CurrentSituation.AddBlock(ConsumePlayUntil(), joinLevel: 0, isNested: true);\n                        if (result is null)\n                        {\n                            OutputHelpers.WriteError($\"Unable to nest line {index}. Was the indentation correct?\");\n                            return false;\n                        }\n\n                        _currentBlock = result.Id;\n                        isNestedBlock = false;\n\n                        hasCreatedBlock = true;\n                    }\n                }\n\n                bool isChoiceTitle = isChoice && Defines(line, TokenChar.ChoiceBlock, $\"{(char)TokenChar.ChoiceBlock}\");", "                if (isChoiceTitle && !isNestedBlock)\n                {\n                    // If this declares another dialog, e.g.:\n                    // >> Option?\n                    // > Yes\n                    // > No!\n                    // >> Here comes another...\n                    // > Okay.\n                    // > Go away!\n                    // We need to make sure that the second title declares a new choice block. We do that by popping\n                    // the last option and the title.\n                    // The popping might have not come up before because they share the same indentation, so that's why we help them a little\n                    // bit here.", "                    if (_script.CurrentSituation.PeekLastBlock().IsChoice)\n                    {\n                        _script.CurrentSituation.PopLastBlock();\n                        _script.CurrentSituation.PopLastBlock();\n                    }\n                }\n            }\n\n            if (Enum.IsDefined(typeof(TokenChar), (int)line[0]))\n            {\n                TokenChar nextDirective = (TokenChar)line[0];\n\n                // Eat this next token!\n                line = line.Slice(1);\n                column += 1;\n\n                _wasPreviousAction = false;\n\n                switch (nextDirective)\n                {\n                    // =\n                    case TokenChar.Situation:", "            if (Enum.IsDefined(typeof(TokenChar), (int)line[0]))\n            {\n                TokenChar nextDirective = (TokenChar)line[0];\n\n                // Eat this next token!\n                line = line.Slice(1);\n                column += 1;\n\n                _wasPreviousAction = false;\n\n                switch (nextDirective)\n                {\n                    // =\n                    case TokenChar.Situation:", "                        if (_indentationIndex >= 1)\n                        {\n                            OutputHelpers.WriteError($\"We do not expect an indentation prior to a situation declaration on line {index}.\");\n                            OutputHelpers.ProposeFix(index, before: _currentLine, after: $\"{TokenChar.Situation}{line}\");\n\n                            return false;\n                        }\n\n                        if (!_script.AddNewSituation(line))\n                        {\n                            OutputHelpers.WriteError($\"Situation of name '{line}' has been declared twice on line {index}.\");\n                            OutputHelpers.ProposeFix(index, before: _currentLine, after: $\"{_currentLine} 2\");\n\n                            return false;\n                        }\n\n                        return true;\n\n                    // @\n                    case TokenChar.Flow:\n                        ReadOnlySpan<char> command = GetNextWord(line, out int end);", "                        if (!_script.AddNewSituation(line))\n                        {\n                            OutputHelpers.WriteError($\"Situation of name '{line}' has been declared twice on line {index}.\");\n                            OutputHelpers.ProposeFix(index, before: _currentLine, after: $\"{_currentLine} 2\");\n\n                            return false;\n                        }\n\n                        return true;\n\n                    // @\n                    case TokenChar.Flow:\n                        ReadOnlySpan<char> command = GetNextWord(line, out int end);", "                        if (command.Length == 0)\n                        {\n                            OutputHelpers.WriteError($\"Empty flow (@) found on line {index}.\");\n                            return false;\n                        }\n\n                        // List of supported directives ('@'):\n                        //  @random\n                        //  @order\n                        //  @{number}\n                        // ...that's all!", "                        if (command.StartsWith(\"random\"))\n                        {\n                            if (hasCreatedBlock)\n                            {\n                                _ = _script.CurrentSituation.SwitchRelationshipTo(EdgeKind.Random);\n                            }\n                            else\n                            {\n                                _random = true;\n                            }\n                        }", "                        else if (command.StartsWith(\"order\"))\n                        {\n                            // No-op? This is already the default?\n                        }\n                        else if (TryReadInteger(command) is int number)\n                        {\n                            if (hasCreatedBlock)\n                            {\n                                _ = Block.PlayUntil = number;\n                            }\n                            else\n                            {", "                                if (Defines(line.Slice(end), TokenChar.BeginCondition, Tokens.Else))\n                                {\n                                    OutputHelpers.WriteError($\"Flow directive '{(char)TokenChar.Flow}' is not supported on else blocks on line {index}.\");\n\n                                    ReadOnlySpan<char> newLine = _currentLine.AsSpan().Slice(0, _currentLine.IndexOf('('));\n                                    OutputHelpers.ProposeFixOnLineBelow(\n                                        index,\n                                        _currentLine,\n                                        newLine: Regex.Replace(_currentLine, \"  @[0-9]\", \"\"),\n                                        newLineBelow: string.Concat(\"    \", newLine));\n\n                                    return false;\n                                }\n\n                                Block? result = _script.CurrentSituation.AddBlock(number, joinLevel, isNestedBlock, EdgeKind.Next);", "                                if (result is null)\n                                {\n                                    OutputHelpers.WriteError($\"Unable to join line {index}. Was the indentation correct?\");\n                                    return false;\n                                }\n\n                                _currentBlock = result.Id;\n\n                                // Ignore any other join or nested operations, since the block has been dealed with.\n                                joinLevel = 0;\n                            }\n                        }\n                        else\n                        {\n                            // Failed reading the command :(\n                            TryGuessFlowDirectiveError(command, index);\n                            return false;\n                        }\n", "                        if (end == -1)\n                        {\n                            return true;\n                        }\n                        else\n                        {\n                            column += end;\n                            line = line.Slice(end).TrimStart();\n                        }\n\n                        break;\n\n                    // (\n                    case TokenChar.BeginCondition:", "                        if (!hasCreatedBlock)\n                        {\n                            int playUntil = ConsumePlayUntil();\n\n                            EdgeKind relationshipKind = EdgeKind.Next;\n                            if (line.StartsWith(Tokens.Else))\n                            {\n                                relationshipKind = EdgeKind.IfElse;\n                            }\n\n                            Block? result = _script.CurrentSituation.AddBlock(\n                                playUntil, joinLevel, isNestedBlock, relationshipKind);", "                            if (result is null)\n                            {\n                                OutputHelpers.WriteError($\"Unable to create condition on line {index}.\");\n                                return false;\n                            }\n\n                            _currentBlock = result.Id;\n                        }\n\n                        return ParseConditions(line, index, column);\n\n                    // [\n                    case TokenChar.BeginAction:\n                        // Check for the end of the condition block ']'\n                        int endAction = MemoryExtensions.IndexOf(line, (char)TokenChar.EndAction);", "                        if (endAction == -1)\n                        {\n                            OutputHelpers.WriteError($\"Missing matching '{(char)TokenChar.EndAction}' on line {index}.\");\n                            OutputHelpers.ProposeFix(\n                                index,\n                                before: _currentLine,\n                                after: _currentLine.TrimEnd() + (char)TokenChar.EndAction);\n\n                            return false;\n                        }\n\n                        _wasPreviousAction = true;\n\n                        line = line.Slice(0, endAction);\n                        return ParseAction(line, index, column);\n\n                    // -\n                    case TokenChar.OnceBlock:\n                        // Check whether this is actually a '->'", "                        if (!line.IsEmpty && line[0] == (char)TokenChar.ChoiceBlock)\n                        {\n                            line = line.Slice(1);\n                            column += 1;\n\n                            return ParseGoto(line, index, column, isNestedBlock);\n                        }\n\n                        _playUntil = 1;\n                        return ParseOption(line, index, column, joinLevel, isNestedBlock);\n\n                    // +\n                    case TokenChar.MultipleBlock:\n                        _playUntil = -1;\n                        return ParseOption(line, index, column, joinLevel, isNestedBlock);\n\n                    // >\n                    case TokenChar.ChoiceBlock:\n                        return ParseChoice(line, index, column, joinLevel, isNestedBlock);\n\n                    default:\n                        return true;\n                }\n            }\n            else\n            {\n                return ParseLine(line, index, column, isNestedBlock);\n            }\n", "            if (!line.IsEmpty)\n            {\n                return ProcessLine(line, index, column, depth + 1, joinLevel, hasCreatedBlock);\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// This parses choices of the dialog. It expects the following line format:\n        ///     > Choice is happening\n        ///      ^ begin of span    ^ end of span\n        ///     >> Choice is happening\n        ///      ^ begin of span    ^ end of span\n        ///     + > Choice is happening\n        ///        ^ begin of span    ^ end of span\n        /// </summary>", "        private bool ParseChoice(ReadOnlySpan<char> line, int lineIndex, int columnIndex, int joinLevel, bool nested)\n        {\n            line = line.TrimStart().TrimEnd();\n\n            if (line.IsEmpty)\n            {\n                OutputHelpers.WriteError($\"Invalid empty choice '{(char)TokenChar.ChoiceBlock}' on line {lineIndex}.\");\n                OutputHelpers.ProposeFixAtColumn(\n                    lineIndex,\n                    columnIndex,\n                    arrowLength: 1,\n                    content: _currentLine,\n                    issue: \"Expected any form of text.\");\n\n                return false;\n            }\n\n            Block parent = _script.CurrentSituation.PeekBlockAt(joinLevel);", "            if (!parent.IsChoice && line[0] != (char)TokenChar.ChoiceBlock)\n            {\n                ReadOnlySpan<char> newLine = _currentLine.AsSpan().Slice(0, columnIndex);\n\n                OutputHelpers.WriteError($\"Expected a title prior to a choice block '{(char)TokenChar.ChoiceBlock}' on line {lineIndex}.\");\n                OutputHelpers.ProposeFixOnLineAbove(\n                    lineIndex,\n                    currentLine: _currentLine,\n                    newLine: string.Concat(newLine, \"> Do your choice\"));\n\n                return false;\n            }\n", "            if (line[0] == (char)TokenChar.ChoiceBlock)\n            {\n                // This is actually the title! So trim the first character.\n                line = line.Slice(1).TrimStart();\n            }\n\n            if (Enum.IsDefined(typeof(TokenChar), (int)line[0]))\n            {\n                OutputHelpers.WriteWarning($\"Special tokens after a '>' will be ignored! Use a '\\\\' if this was what you meant. See line {lineIndex}.\");\n                OutputHelpers.ProposeFix(\n                    lineIndex,\n                    before: _currentLine,\n                    after: _currentLine.TrimEnd().Replace($\"{line[0]}\", $\"\\\\{line[0]}\"));\n            }\n\n            Block? result = _script.CurrentSituation.AddBlock(ConsumePlayUntil(), joinLevel, nested, EdgeKind.Choice);", "            if (result is null)\n            {\n                OutputHelpers.WriteError($\"Unable to create condition on line {lineIndex}. This may happen if you declare an else ('...') without a prior condition, for example.\");\n                return false;\n            }\n\n            _currentBlock = result.Id;\n\n            AddLineToBlock(line);\n            return true;\n        }\n", "        private bool ParseOption(ReadOnlySpan<char> line, int lineIndex, int columnIndex, int joinLevel, bool nested)\n        {\n            EdgeKind relationshipKind = EdgeKind.HighestScore;\n            if (ConsumeIsRandom() || _script.CurrentSituation.PeekLastEdgeKind() == EdgeKind.Random)\n            {\n                relationshipKind = EdgeKind.Random;\n            }\n\n            // TODO: Check for requirements!\n\n            Block? result = _script.CurrentSituation.AddBlock(ConsumePlayUntil(), joinLevel, nested, relationshipKind);", "            if (result is null)\n            {\n                OutputHelpers.WriteError($\"Unable to create option on line {lineIndex}.\");\n                return false;\n            }\n\n            _currentBlock = result.Id;\n\n            line = line.TrimStart();\n            if (line.IsEmpty)\n            {\n                // OutputHelpers.WriteWarning($\"Skipping first empty dialog option in line {lineIndex}.\");\n                return true;\n            }\n", "            if (line.IsEmpty)\n            {\n                // OutputHelpers.WriteWarning($\"Skipping first empty dialog option in line {lineIndex}.\");\n                return true;\n            }\n\n            if (line[0] == (char)TokenChar.BeginCondition)\n            {\n                // Do not create a new block for conditions. This is because an option is deeply tied\n                // to its rules (it's their score, after all!) so we can't just get away with that.\n                // We might do another syntax if we want to create a new block for some reason.\n                return ParseConditions(line.Slice(1), lineIndex, columnIndex + 1);\n            }", "            else if (line[0] == (char)TokenChar.ChoiceBlock)\n            {\n                return ParseChoice(line.Slice(1), lineIndex, columnIndex + 1, joinLevel: 0, nested: false);\n            }\n\n            AddLineToBlock(line);\n            return true;\n        }\n\n        private bool CheckAndCreateLinearBlock(int joinLevel, bool isNested)\n        {\n            // We only create a new block for a line when:\n            //  - this is actually the root (or first) node\n            //  - previous line was a choice (without a conditional).", "        private bool CheckAndCreateLinearBlock(int joinLevel, bool isNested)\n        {\n            // We only create a new block for a line when:\n            //  - this is actually the root (or first) node\n            //  - previous line was a choice (without a conditional).\n            if (_script.CurrentSituation.Blocks.Count == 1 ||\n                (isNested && Block.IsChoice && !Block.Conditional))\n            {\n                Block? result = _script.CurrentSituation.AddBlock(\n                    ConsumePlayUntil(), joinLevel, isNested: false, EdgeKind.Next);\n", "                if (result is null)\n                {\n                    return false;\n                }\n\n                _currentBlock = result.Id;\n            }\n\n            return true;\n        }\n", "        private bool ParseGoto(ReadOnlySpan<char> line, int lineIndex, int currentColumn, bool isNested)\n        {\n            CheckAndCreateLinearBlock(joinLevel: 0, isNested);\n\n            // Check if we started specifying the relationship from the previous requirement.\n            ReadOnlySpan<char> location = line.TrimStart().TrimEnd();\n            if (location.IsEmpty)\n            {\n                // We saw something like a (and) condition. This is not really valid for us.\n                OutputHelpers.WriteError($\"Expected a situation after '->'.\");\n                OutputHelpers.ProposeFixAtColumn(\n                    lineIndex,\n                    currentColumn,\n                    arrowLength: 1,\n                    content: _currentLine,\n                    issue: \"Did you forget a destination here?\");\n\n                return false;\n            }\n\n            bool isExit = false;", "            if (MemoryExtensions.Equals(location, \"exit!\", StringComparison.OrdinalIgnoreCase))\n            {\n                // If this is an 'exit!' keyword, finalize right away.\n                isExit = true;\n            }\n            else\n            {\n                // Otherwise, keep track of this and add at the end.\n                _gotoDestinations.Add((Block, location.ToString(), lineIndex));\n            }\n\n            _script.CurrentSituation.MarkGotoOnBlock(_currentBlock, isExit);\n\n            return true;\n        }\n\n        /// <summary>\n        /// This reads and parses a condition into <see cref=\"_currentBlock\"/>.\n        /// Expected format is:\n        ///     (HasSomething is true)\n        ///      ^ begin of span    ^ end of span\n        /// \n        /// </summary>\n        /// <returns>Whether it succeeded parsing the line.</returns>", "        private bool ParseConditions(ReadOnlySpan<char> line, int lineIndex, int currentColumn)\n        {\n            // Check for the end of the condition block ')'\n            int endColumn = MemoryExtensions.IndexOf(line, (char)TokenChar.EndCondition);\n            if (endColumn == -1)\n            {\n                OutputHelpers.WriteError($\"Missing matching '{(char)TokenChar.EndCondition}' on line {lineIndex}.\");\n                OutputHelpers.ProposeFix(\n                    lineIndex,\n                    before: _currentLine,\n                    after: _currentLine.TrimEnd() + (char)TokenChar.EndCondition);\n\n                return false;\n            }\n\n            Block.Conditional = true;\n            line = line.Slice(0, endColumn).TrimEnd();\n", "            while (true)\n            {\n                ReadOnlySpan<char> previousLine = line;\n                if (!ReadNextCriterion(ref line, lineIndex, currentColumn, out CriterionNode? node))\n                {\n                    return false;\n                }\n\n                currentColumn += previousLine.Length - line.Length;\n\n                if (node is null)\n                {\n                    return true;\n                }\n\n                Block.AddRequirement(node.Value);\n            }\n        }\n\n        /// <summary>\n        /// Fetches the immediate next word of a line.\n        /// This disregards any indentation or white space prior to the word.\n        /// </summary>\n        /// <param name=\"end\">The end of the parameter. If -1, this is an empty word.</param>", "                if (node is null)\n                {\n                    return true;\n                }\n\n                Block.AddRequirement(node.Value);\n            }\n        }\n\n        /// <summary>\n        /// Fetches the immediate next word of a line.\n        /// This disregards any indentation or white space prior to the word.\n        /// </summary>\n        /// <param name=\"end\">The end of the parameter. If -1, this is an empty word.</param>", "        private static ReadOnlySpan<char> GetNextWord(ReadOnlySpan<char> line, out int end)\n        {\n            ReadOnlySpan<char> trimmed = line.TrimStart();\n            int separatorIndex = trimmed.IndexOf(_separatorChar);\n\n            ReadOnlySpan<char> result = separatorIndex == -1 ?\n                trimmed : trimmed.Slice(0, separatorIndex);\n\n            end = trimmed.IsEmpty ? -1 : result.Length + (line.Length - trimmed.Length);\n\n            return result;\n        }\n\n        /// <summary>\n        /// Fetches and removes the next word of <paramref name=\"line\"/>.\n        /// This disregards any indentation or white space prior to the word.\n        /// </summary>\n        /// <param name=\"end\">The end of the parameter. If -1, this is an empty word.</param>", "        private static ReadOnlySpan<char> PopNextWord(ref ReadOnlySpan<char> line, out int end)\n        {\n            ReadOnlySpan<char> result = GetNextWord(line, out end);\n            if (end != -1)\n            {\n                line = line.Slice(end);\n            }\n\n            return result;\n        }\n\n        /// <summary>\n        /// Expects to read an integer of a line such as:\n        ///     \"28 (Something else)\"   -> valid\n        ///     \"28something\"           -> invalid\n        ///     \"28\"                    -> valid\n        /// </summary>\n        private int? TryReadInteger(ReadOnlySpan<char> maybeInteger)\n        {", "            if (int.TryParse(maybeInteger, out int result))\n            {\n                return result;\n            }\n\n            return null;\n        }\n\n        /// <summary>\n        /// Try to guess why we failed parsing a '@' directive.\n        /// </summary>", "        private void TryGuessFlowDirectiveError(ReadOnlySpan<char> directive, int index)\n        {\n            OutputHelpers.WriteError($\"Unable to recognize '@{directive}' directive on line {index}.\");\n\n            if (char.IsDigit(directive[0]))\n            {\n                char[] clean = Array.FindAll(directive.ToArray(), char.IsDigit);\n                OutputHelpers.ProposeFix(\n                    index, \n                    before: _currentLine, \n                    after: _currentLine.Replace(directive.ToString(), new string(clean)));\n\n                return;\n            }\n\n            int commonLength = directive.ToArray().Intersect(\"random\").Count();", "            if (commonLength > 3)\n            {\n                OutputHelpers.ProposeFix(\n                    index, \n                    before: _currentLine, \n                    after: _currentLine.Replace(directive.ToString(), \"random\"));\n\n                return;\n            }\n\n            OutputHelpers.Remark(\"We currently support '@{number}' and '@random' as valid directives. Please, reach out if this was not clear. \ud83d\ude4f\");\n        }\n    }\n}\n"]}
{"filename": "src/Gum/DiagnosticLevel.cs", "chunked_list": ["\ufeffnamespace Gum\n{\n    internal enum DiagnosticLevel\n    {\n        All = 0,\n        ErrorsOnly = 1\n    }\n}\n"]}
{"filename": "src/Gum/Reader.cs", "chunked_list": ["\ufeffusing Gum.InnerThoughts;\nusing Gum.Utilities;\nusing Murder.Serialization;\nusing Newtonsoft.Json;\nusing System.Reflection;\nusing System.Text;\n\nnamespace Gum\n{\n    /// <summary>", "{\n    /// <summary>\n    /// This is the parser entrypoint when converting .gum -> metadata.\n    /// </summary>\n    public class Reader\n    {\n        /// <param name=\"arguments\">\n        /// This expects the following arguments:\n        ///   `.\\Gum <input-path> <output-path>`\n        ///   <input-path> can be the path of a directory or a single file.\n        ///   <output-path> is where the output should be created.\n        /// </param>\n        internal static void Main(string[] arguments)\n        {\n            // If this got called from the msbuild command, for example,\n            // it might group different arguments into the same string.\n            // We manually split them if there's such a case.\n            //\n            // Regex stringParser = new Regex(@\"([^\"\"]+)\"\"|\\s*([^\\\"\"\\s]+)\");\n\n            Console.OutputEncoding = Encoding.UTF8;\n", "            if (arguments.Length != 2)\n            {\n                Console.ForegroundColor = ConsoleColor.Yellow;\n                Console.WriteLine(\"This expects the following arguments:\\n\" +\n                    \"\\t.\\\\Whispers <input-path> <output-path>\\n\\n\" +\n                    \"\\t  - <input-path> can be the path of a directory or a single file.\\n\" +\n                    \"\\t  - <output-path> is where the output should be created.\\n\");\n                Console.ResetColor();\n\n                throw new ArgumentException(nameof(arguments));\n            }\n\n            string outputPath = ToRootPath(arguments[1]);", "            if (!Directory.Exists(outputPath))\n            {\n                OutputHelpers.WriteError($\"Unable to find output path '{outputPath}'\");\n                return;\n            }\n\n            CharacterScript[] scripts = ParseImplementation(inputPath: arguments[0], lastModified: null, DiagnosticLevel.All);\n\n            foreach (CharacterScript script in scripts)\n            {\n                _ = Save(script, outputPath);\n            }\n", "            foreach (CharacterScript script in scripts)\n            {\n                _ = Save(script, outputPath);\n            }\n\n            if (scripts.Length > 0)\n            {\n                Console.ForegroundColor = ConsoleColor.Green;\n                Console.WriteLine($\"\ud83e\ude84 Success! Successfully saved output at {outputPath}.\");\n                Console.ResetColor();\n            }\n        }\n\n        internal static bool Save(CharacterScript script, string path)\n        {\n            string json = JsonConvert.SerializeObject(script, Settings);\n            File.WriteAllText(path: Path.Join(path, $\"{script.Name}.json\"), contents: json);\n\n            return true;\n        }\n\n        internal static CharacterScript? Retrieve(string filepath)\n        {", "            if (!File.Exists(filepath))\n            {\n                OutputHelpers.WriteError($\"Unable to find file at '{filepath}'\");\n                return null;\n            }\n\n            string json = File.ReadAllText(filepath);\n            return JsonConvert.DeserializeObject<CharacterScript>(json);\n        }\n\n        /// <summary>\n        /// This will parse all the documents in <paramref name=\"inputPath\"/>.\n        /// </summary>", "        public static CharacterScript[] Parse(string inputPath, DateTime? lastModified, out string errors)\n        {\n            StringWriter writer = new();\n\n            Console.SetOut(writer);\n\n            CharacterScript[] result = ParseImplementation(inputPath, lastModified, DiagnosticLevel.ErrorsOnly);\n            errors = writer.ToString();\n\n            return result;\n        }\n\n        /// <summary>\n        /// This will parse all the documents in <paramref name=\"inputPath\"/>.\n        /// </summary>", "        private static CharacterScript[] ParseImplementation(string inputPath, DateTime? lastModified, DiagnosticLevel level)\n        {\n            OutputHelpers.Level = level;\n\n            inputPath = ToRootPath(inputPath);\n\n            List<CharacterScript> scripts = new List<CharacterScript>();\n\n            IEnumerable<string> files = GetAllLibrariesInPath(inputPath, lastModified);\n            foreach (string file in files)\n            {\n                OutputHelpers.Log($\"\u2728 Compiling {Path.GetFileName(file)}...\");\n\n                CharacterScript? script = Parser.Parse(file);", "            foreach (string file in files)\n            {\n                OutputHelpers.Log($\"\u2728 Compiling {Path.GetFileName(file)}...\");\n\n                CharacterScript? script = Parser.Parse(file);\n                if (script is not null)\n                {\n                    scripts.Add(script);\n                }\n            }\n\n            return scripts.ToArray();\n        }\n\n        internal readonly static JsonSerializerSettings Settings = new()\n        {\n            TypeNameHandling = TypeNameHandling.None,\n            ContractResolver = new WritablePropertiesOnlyResolver(),\n            Formatting = Formatting.Indented,\n            NullValueHandling = NullValueHandling.Ignore\n        };\n\n        /// <summary>\n        /// Handles any relative path to the executable.\n        /// </summary>", "        private static string ToRootPath(string s) =>\n            Path.IsPathRooted(s) ? s : Path.GetFullPath(Path.Join(Path.GetDirectoryName(Assembly.GetEntryAssembly()!.Location), s));\n\n        /// <summary>\n        /// Look recursively for all the files in <paramref name=\"path\"/>.\n        /// </summary>\n        /// <param name=\"path\">Rooted path to the binaries folder. This must be a valid directory.</param>\n        private static IEnumerable<string> GetAllLibrariesInPath(in string path, DateTime? lastModified)\n        {\n            if (File.Exists(path))\n            {\n                return new string[] { path };\n            }\n", "            if (File.Exists(path))\n            {\n                return new string[] { path };\n            }\n\n            if (!Path.Exists(path))\n            {\n                OutputHelpers.WriteError($\"Unable to find input path '{path}'\");\n                return new string[0];\n            }\n\n            // 1. Filter all files that has a \"*.gum\" extension.\n            // 2. Distinguish the file names.\n            IEnumerable<string> paths = Directory.EnumerateFiles(path, \"*.gum\", SearchOption.AllDirectories)\n                .GroupBy(s => Path.GetFileName(s))\n                .Select(s => s.First());\n", "            if (lastModified is not null)\n            {\n                // Only select files that have been modifier prior to a specific date.\n                paths = paths.Where(s => File.GetLastWriteTime(s) > lastModified);\n            }\n\n            return paths;\n        }\n    }\n}"]}
{"filename": "src/Gum/Parser_Goto.cs", "chunked_list": ["\ufeffusing Gum.InnerThoughts;\nusing Gum.Utilities;\n\nnamespace Gum\n{\n    public partial class Parser\n    {\n        private bool ResolveAllGoto()\n        {\n            foreach ((Block block, string location, int line) in _gotoDestinations)\n            {", "            foreach ((Block block, string location, int line) in _gotoDestinations)\n            {\n                if (_script.FetchSituationId(location) is not int destinationId)\n                {\n                    OutputHelpers.WriteError($\"Unable to find a situation of name '{location}' reference in line {line}.\");\n                    if (TryFindABestGuess(location) is string guess)\n                    {\n                        OutputHelpers.ProposeFix(line, before: $\"-> {location}\", after: $\"-> {guess}\");\n                    }\n\n                    return false;\n                }\n", "                if (block.GoTo is not null)\n                {\n                    OutputHelpers.WriteWarning($\"Additional goto statement found '-> {location}' in {line}. It will be disregarded, was that intentional?\");\n                    continue;\n                }\n\n                block.GoTo = destinationId;\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Try to guess the best name of a location that the person may have meant.\n        /// This is only used for diagnostics.\n        /// </summary>\n        private string? TryFindABestGuess(string guess)\n        {\n            string[] locations = _script.FetchAllNames();\n\n            int minInsersect = (int)Math.Round(guess.Length * .55f);\n\n            int bestMatchCount = 0;\n            string? bestMatch = null;\n", "            foreach (string location in locations)\n            {\n                int intersectCount = guess.Intersect(location).Count();\n\n                // Did it succeed the bare minimum?\n                if (intersectCount > minInsersect)\n                {\n                    // Did it beat our best match yet?\n                    if (intersectCount > bestMatchCount)\n                    {\n                        bestMatchCount = intersectCount;\n                        bestMatch = location;\n                    }\n                }\n            }\n\n            return bestMatch;\n        }\n    }\n}\n", "                    if (intersectCount > bestMatchCount)\n                    {\n                        bestMatchCount = intersectCount;\n                        bestMatch = location;\n                    }\n                }\n            }\n\n            return bestMatch;\n        }\n    }\n}\n"]}
{"filename": "src/Gum/Parser_Requirements.cs", "chunked_list": ["\ufeffusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing Gum.InnerThoughts;\nusing Gum.Utilities;\n\nnamespace Gum\n{\n    internal static partial class Tokens\n    {\n        public const string And = \"and\";\n        public const string And2 = \"&&\";\n", "        public const string And = \"and\";\n        public const string And2 = \"&&\";\n\n        public const string Or = \"or\";\n        public const string Or2 = \"||\";\n\n        public const string Is = \"is\";\n\n        public const string Less = \"<\";\n        public const string LessEqual = \"<=\";\n        public const string Equal = \"==\";", "        public const string Less = \"<\";\n        public const string LessEqual = \"<=\";\n        public const string Equal = \"==\";\n        public const string Bigger = \">\";\n        public const string BiggerEqual = \">=\";\n\n        public const string Different = \"!=\";\n\n        public const string Else = \"...\";\n    }\n", "        public const string Else = \"...\";\n    }\n\n    public partial class Parser\n    {\n        /// <summary>\n        /// Read the next criterion.\n        /// </summary>\n        /// <param name=\"line\"></param>\n        /// <param name=\"node\">\n        /// The resulting node. Only valid if it was able to read a non-empty valid\n        /// requirement syntax.\n        /// </param>\n        /// <returns>Whether it read without any grammar errors.</returns>", "        private bool ReadNextCriterion(ref ReadOnlySpan<char> line, int lineIndex, int currentColumn, out CriterionNode? node)\n        {\n            node = null;\n\n            if (line.IsEmpty)\n            {\n                return true;\n            }\n\n            if (line.StartsWith(Tokens.Else))\n            {\n                // This is actually a \"else\" block!\n                line = line.Slice(Tokens.Else.Length);\n                currentColumn += Tokens.Else.Length;\n            }\n\n            // Check if we started specifying the relationship from the previous requirement.\n            ReadOnlySpan<char> token = PopNextWord(ref line, out int end);", "            if (line.StartsWith(Tokens.Else))\n            {\n                // This is actually a \"else\" block!\n                line = line.Slice(Tokens.Else.Length);\n                currentColumn += Tokens.Else.Length;\n            }\n\n            // Check if we started specifying the relationship from the previous requirement.\n            ReadOnlySpan<char> token = PopNextWord(ref line, out int end);\n            if (end == -1)\n            {\n                // No requirement specified.\n                return true;\n            }\n\n            // Diagnostics... \ud83d\ude4f\n            currentColumn += token.Length;\n\n            CriterionNodeKind? nodeKind = null;\n            switch (token)\n            {\n                case Tokens.Or:\n                case Tokens.Or2:\n                    nodeKind = CriterionNodeKind.Or;\n                    break;\n\n                case Tokens.And:\n                case Tokens.And2:\n                    nodeKind = CriterionNodeKind.And;\n                    break;\n\n                // TODO: Check for '...'\n            }\n\n            ReadOnlySpan<char> variableToken = token;", "            if (end == -1)\n            {\n                // No requirement specified.\n                return true;\n            }\n\n            // Diagnostics... \ud83d\ude4f\n            currentColumn += token.Length;\n\n            CriterionNodeKind? nodeKind = null;\n            switch (token)\n            {\n                case Tokens.Or:\n                case Tokens.Or2:\n                    nodeKind = CriterionNodeKind.Or;\n                    break;\n\n                case Tokens.And:\n                case Tokens.And2:\n                    nodeKind = CriterionNodeKind.And;\n                    break;\n\n                // TODO: Check for '...'\n            }\n\n            ReadOnlySpan<char> variableToken = token;", "            if (nodeKind is not null)\n            {\n                variableToken = PopNextWord(ref line, out end);\n                if (end == -1)\n                {\n                    // We saw something like a (and) condition. This is not really valid for us.\n                    OutputHelpers.WriteError($\"Unexpected condition end after '{token}' on line {lineIndex}.\");\n                    OutputHelpers.ProposeFixAtColumn(\n                        lineIndex,\n                        currentColumn,\n                        arrowLength: 1,\n                        content: _currentLine,\n                        issue: \"Unexpected end of condition.\");\n\n                    return false;\n                }\n\n                currentColumn += variableToken.Length;\n            }\n            else\n            {\n                // Assume 'AND' by default and move on.\n                nodeKind = CriterionNodeKind.And;\n            }\n\n            // Check if this is actually a\n            //      (!SomethingBad)\n            //       ^\n            // variable.\n            CriterionKind criterionKind = CriterionKind.Is;", "            if (variableToken[0] == (char)TokenChar.Negative)\n            {\n                criterionKind = CriterionKind.Different;\n                variableToken = variableToken.Slice(1);\n            }\n\n            // 'token' now corresponds to the variable name. Check if there is a blackboard specified.\n            (string? blackboard, string variable) = ReadBlackboardVariableName(variableToken);\n\n            // The following are *optional*, so let's not kick off any characters yet.\n            ReadOnlySpan<char> @operator = GetNextWord(line, out end);\n\n            bool readNextToken = !@operator.IsEmpty;\n", "            if (!@operator.IsEmpty)\n            {\n                switch (@operator)\n                {\n                    // is, ==\n                    case Tokens.Is:\n                    case Tokens.Equal:\n                        break;\n\n                    // !=\n                    case Tokens.Different:\n                        criterionKind = criterionKind == CriterionKind.Different ?\n                            CriterionKind.Is : CriterionKind.Different;\n                        break;\n\n                    // <\n                    case Tokens.Less:\n                        criterionKind = CriterionKind.Less;\n                        break;\n\n                    // <=\n                    case Tokens.LessEqual:\n                        criterionKind = CriterionKind.LessOrEqual;\n                        break;\n\n                    // >=\n                    case Tokens.BiggerEqual:\n                        criterionKind = CriterionKind.BiggerOrEqual;\n                        break;\n\n                    // >\n                    case Tokens.Bigger:\n                        criterionKind = CriterionKind.Bigger;\n                        break;\n\n                    default:\n                        // The next node will take care of this.\n                        readNextToken = false;\n                        break;\n                }\n            }\n\n            FactKind? expectedFact;\n            object? ruleValue;\n", "            if (readNextToken)\n            {\n                line = line.Slice(end);\n                currentColumn += end;\n\n                // Check if we started specifying the relationship from the previous requirement.\n                ReadOnlySpan<char> specifier = PopNextWord(ref line, out end);\n                if (end == -1)\n                {\n                    // We have something like a '==' or 'is' waiting for another condition.\n                    OutputHelpers.WriteError($\"Unexpected condition end after '{@operator}' on line {lineIndex}.\");\n                    OutputHelpers.ProposeFixAtColumn(\n                        lineIndex,\n                        currentColumn,\n                        arrowLength: 1,\n                        content: _currentLine,\n                        issue: \"The matching value is missing.\");\n\n                    return false;\n                }\n", "                if (!ReadFactValue(specifier, out expectedFact, out ruleValue))\n                {\n                    OutputInvalidRuleValueSpecifier(specifier, lineIndex, currentColumn);\n                    return false;\n                }\n\n                // currentColumn += end;\n            }\n            else\n            {\n                Debug.Assert(criterionKind == CriterionKind.Is || criterionKind == CriterionKind.Different,\n                    \"Unexpected criterion kind for a condition without an explicit token value!\");\n\n                // If there is no specifier, assume this is a boolean and the variable is enough.\n                ruleValue = true;\n                expectedFact = FactKind.Bool;\n            }\n\n            Fact fact = new(blackboard, variable, expectedFact.Value);\n            Criterion criterion = new(fact, criterionKind, ruleValue);\n\n            node = new(criterion, nodeKind.Value);\n\n            return true;\n        }\n\n        private (string? Blackboard, string Variable) ReadBlackboardVariableName(ReadOnlySpan<char> value)\n        {\n            // 'token' now corresponds to the variable name. Check if there is a blackboard specified.\n            string? blackboard;\n            string variable;\n\n            // First, check if there is a namespace specified.\n            int blackboardIndex = value.IndexOf('.');", "            if (blackboardIndex != -1)\n            {\n                blackboard = value.Slice(0, blackboardIndex).ToString();\n                variable = value.Slice(blackboardIndex + 1).ToString();\n            }\n            else\n            {\n                blackboard = null;\n                variable = value.ToString();\n            }\n\n            return (blackboard, variable);\n        }\n", "        private bool ReadFactValue(ReadOnlySpan<char> line, [NotNullWhen(true)] out FactKind? fact, [NotNullWhen(true)] out object? value)\n        {\n            fact = null;\n            value = null;\n\n            if (TryReadInteger(line) is int @int)\n            {\n                fact = FactKind.Int;\n                value = @int;\n            }\n            else if (MemoryExtensions.Equals(line.Trim(), \"true\", StringComparison.OrdinalIgnoreCase))\n            {\n                fact = FactKind.Bool;\n                value = true;\n            }", "            else if (MemoryExtensions.Equals(line.Trim(), \"true\", StringComparison.OrdinalIgnoreCase))\n            {\n                fact = FactKind.Bool;\n                value = true;\n            }\n            else if (MemoryExtensions.Equals(line.Trim(), \"false\", StringComparison.OrdinalIgnoreCase))\n            {\n                fact = FactKind.Bool;\n                value = false;\n            }\n            else if ((line[0] == '\\'' && line[line.Length - 1] == '\\'') ||\n                     (line[0] == '\\\"' && line[line.Length - 1] == '\\\"'))\n            {\n                fact = FactKind.String;\n                value = line.Slice(1, line.Length - 2).ToString();\n            }\n            else\n            {\n                return false;\n            }\n\n            return true;\n        }\n", "            else if ((line[0] == '\\'' && line[line.Length - 1] == '\\'') ||\n                     (line[0] == '\\\"' && line[line.Length - 1] == '\\\"'))\n            {\n                fact = FactKind.String;\n                value = line.Slice(1, line.Length - 2).ToString();\n            }\n            else\n            {\n                return false;\n            }\n\n            return true;\n        }\n", "        private void OutputInvalidRuleValueSpecifier(ReadOnlySpan<char> specifier, int lineIndex, int column)\n        {\n            // Unrecognized token?\n            OutputHelpers.WriteError($\"Unexpected rule value '{specifier}' on line {lineIndex}.\");\n\n            if (OutputTryGuessAssignmentValue(specifier, lineIndex, column))\n            {\n                return;\n            }\n\n            // We couldn't guess a fix. \ud83d\ude25 Sorry, just move on.\n            OutputHelpers.ProposeFixAtColumn(\n                lineIndex,\n                column,\n                arrowLength: specifier.Length,\n                content: _currentLine,\n                issue: \"This rule could not be recognized.\");\n        }\n", "        private bool OutputTryGuessAssignmentValue(ReadOnlySpan<char> specifier, int lineIndex, int column)\n        {\n            if (char.IsDigit(specifier[0]))\n            {\n                char[] clean = Array.FindAll(specifier.ToArray(), char.IsDigit);\n                OutputHelpers.ProposeFix(\n                    lineIndex,\n                    before: _currentLine,\n                    after: _currentLine.Replace(specifier.ToString(), new string(clean)));\n\n                return true;\n            }\n\n            string lowercaseSpecifier = specifier.ToString().ToLowerInvariant();\n\n            int commonLength = lowercaseSpecifier.Intersect(\"true\").Count();", "            if (commonLength > 3)\n            {\n                OutputHelpers.ProposeFix(\n                    lineIndex,\n                    before: _currentLine,\n                    after: _currentLine.Replace(specifier.ToString(), \"true\"));\n\n                return true;\n            }\n\n            commonLength = lowercaseSpecifier.Intersect(\"false\").Count();", "            if (commonLength > 3)\n            {\n                OutputHelpers.ProposeFix(\n                    lineIndex,\n                    before: _currentLine,\n                    after: _currentLine.Replace(specifier.ToString(), \"false\"));\n\n                return true;\n            }\n\n            return false;\n        }\n    }\n}\n"]}
{"filename": "src/Gum/Parser_Actions.cs", "chunked_list": ["\ufeffusing Gum.Blackboards;\nusing Gum.InnerThoughts;\nusing Gum.Utilities;\n\nnamespace Gum\n{\n    internal static partial class Tokens\n    {\n        public const char Assign = '=';\n        public const string Add = \"+=\";\n        public const string Minus = \"-=\";\n", "        public const char Assign = '=';\n        public const string Add = \"+=\";\n        public const string Minus = \"-=\";\n\n        public const string Component = \"c:\";\n    }\n\n    public partial class Parser\n    {\n        /// <summary>\n        /// This reads and parses an action into <see cref=\"_currentBlock\"/>.\n        /// Expected format is:\n        ///     [SomeVariable = true]\n        ///      ^ begin of span   ^ end of span\n        /// \n        /// </summary>\n        /// <returns>Whether it succeeded parsing the action.</returns>", "        private bool ParseAction(ReadOnlySpan<char> line, int lineIndex, int currentColumn)\n        {\n            if (line.IsEmpty)\n            {\n                // We saw something like a (and) condition. This is not really valid for us.\n                OutputHelpers.WriteWarning($\"Empty action ('[]') found at line {lineIndex}. \" +\n                    \"Was this on purpose? Because it will be ignored.\");\n                return true;\n            }\n\n            CheckAndCreateLinearBlock(joinLevel: 0, isNested: false);\n", "            if (line.StartsWith(Tokens.Component))\n            {\n                line = line.Slice(Tokens.Component.Length);\n\n                string component = line.ToString();\n\n                Block.AddAction(\n                    new DialogAction(\n                        new Fact(componentType: component), \n                        BlackboardActionKind.Component, component));\n                return true;\n            }\n\n            BlackboardActionKind? actionKind = null;\n\n            int index = line.IndexOf(Tokens.Minus);", "            if (index != -1)\n            {\n                actionKind = BlackboardActionKind.Minus;\n            }\n\n            if (actionKind is null &&\n                (index = line.IndexOf(Tokens.Add)) != -1)\n            {\n                actionKind = BlackboardActionKind.Add;\n            }\n", "            if (actionKind is null && \n                (index = line.IndexOf(Tokens.Assign)) != -1)\n            {\n                actionKind = BlackboardActionKind.Set;\n            }\n\n            if (actionKind is null)\n            {\n                OutputHelpers.WriteError($\"Unable to find an assignment for action '[{line}]' on line {lineIndex}.\");\n\n                if (line.ToString().Contains(\"Interaction\"))\n                {\n                    OutputHelpers.ProposeFix(\n                        lineIndex,\n                        before: _currentLine,\n                        after: _currentLine.Replace(line.ToString(), $\"c:{line}\"));\n\n                    return false;\n                }\n\n                OutputHelpers.ProposeFixAtColumn(\n                    lineIndex,\n                    currentColumn,\n                    arrowLength: line.Length,\n                    content: _currentLine,\n                    issue: $\"Expected a component ({Tokens.Component}) or an assignment \" +\n                        $\"({Tokens.Minus}, {Tokens.Add}, {Tokens.Assign}).\");\n\n                return false;\n            }\n\n            // Read the first half.\n\n            ReadOnlySpan<char> variableName = line.Slice(0, index).TrimEnd();\n            (string? blackboard, string variable) = ReadBlackboardVariableName(variableName);\n\n            line = line.Slice(index);\n            currentColumn += index;\n\n            FactKind? factKind = null;\n            object? value = null;\n", "                if (line.ToString().Contains(\"Interaction\"))\n                {\n                    OutputHelpers.ProposeFix(\n                        lineIndex,\n                        before: _currentLine,\n                        after: _currentLine.Replace(line.ToString(), $\"c:{line}\"));\n\n                    return false;\n                }\n\n                OutputHelpers.ProposeFixAtColumn(\n                    lineIndex,\n                    currentColumn,\n                    arrowLength: line.Length,\n                    content: _currentLine,\n                    issue: $\"Expected a component ({Tokens.Component}) or an assignment \" +\n                        $\"({Tokens.Minus}, {Tokens.Add}, {Tokens.Assign}).\");\n\n                return false;\n            }\n\n            // Read the first half.\n\n            ReadOnlySpan<char> variableName = line.Slice(0, index).TrimEnd();\n            (string? blackboard, string variable) = ReadBlackboardVariableName(variableName);\n\n            line = line.Slice(index);\n            currentColumn += index;\n\n            FactKind? factKind = null;\n            object? value = null;\n", "            if (actionKind == BlackboardActionKind.Minus || \n                actionKind == BlackboardActionKind.Add)\n            {\n                // += or -=\n                line = line.Slice(Tokens.Minus.Length); // minus and add has the same length, so i will keep this simple...\n                currentColumn += Tokens.Minus.Length;\n\n                factKind = FactKind.Int;\n                value = TryReadInteger(line);\n                if (value is not int)\n                {\n                    OutputHelpers.WriteError($\"Expected '{line}' to be an integer on line {lineIndex}.\");\n\n                    char[] clean = Array.FindAll(line.ToArray(), char.IsDigit);", "                if (value is not int)\n                {\n                    OutputHelpers.WriteError($\"Expected '{line}' to be an integer on line {lineIndex}.\");\n\n                    char[] clean = Array.FindAll(line.ToArray(), char.IsDigit);\n                    if (clean.Length != 0)\n                    {\n                        OutputHelpers.ProposeFix(\n                            lineIndex,\n                            before: _currentLine,\n                            after: _currentLine.Replace(line.ToString(), new string(clean)));\n\n                        return false;\n                    }\n\n                    // We couldn't guess a fix. \ud83d\ude25 Sorry, just move on.\n                    OutputHelpers.ProposeFixAtColumn(\n                        lineIndex,\n                        currentColumn,\n                        arrowLength: line.Length,\n                        content: _currentLine,\n                        issue: \"Expected an integer value.\");\n                    return false;\n                }\n            }\n            else\n            {\n                // =\n                line = line.Slice(1); // minus and add has the same length, so i will keep this simple...\n                currentColumn += 1;\n", "                if (line.IsEmpty)\n                {\n                    OutputHelpers.WriteError($\"Empty assignment for '[{variableName}=]' on line {lineIndex}.\");\n\n                    OutputHelpers.ProposeFixAtColumn(\n                        lineIndex,\n                        currentColumn,\n                        arrowLength: 1,\n                        content: _currentLine,\n                        issue: \"Expected a boolean, integer or string value.\");\n\n                    return false;\n                }\n", "                if (!ReadFactValue(line, out factKind, out value))\n                {\n                    OutputHelpers.WriteError($\"Expected '{line}' to be an integer, boolean or string on line {lineIndex}.\");\n\n                    if (OutputTryGuessAssignmentValue(line, lineIndex, currentColumn))\n                    {\n                        return false;\n                    }\n\n                    OutputHelpers.ProposeFixAtColumn(\n                        lineIndex,\n                        currentColumn,\n                        arrowLength: line.Length,\n                        content: _currentLine,\n                        issue: \"Expected a boolean, integer or string value.\");\n\n                    return false;\n                }\n            }\n\n            Fact fact = new(blackboard, variable, factKind.Value);\n            DialogAction action = new(fact, actionKind.Value, value);\n\n            Block.AddAction(action);\n\n            return true;\n        }\n    }\n}\n"]}
{"filename": "src/Gum/Parser_Line.cs", "chunked_list": ["\ufeffusing Gum.InnerThoughts;\nusing Gum.Utilities;\nusing System;\n\nnamespace Gum\n{\n    internal static partial class Tokens\n    {\n        public const char EscapeToken = '\\\\';\n        public const char SpeakerToken = ':';\n        public const char SpeakerPortraitToken = '.';\n    }\n", "        public const char EscapeToken = '\\\\';\n        public const char SpeakerToken = ':';\n        public const char SpeakerPortraitToken = '.';\n    }\n\n    public partial class Parser\n    {\n        private bool ParseLine(ReadOnlySpan<char> line, int index, int columnIndex, bool isNested)\n        {\n            if (_wasPreviousAction)\n            {\n                // If current line is not an action *but* the previous line was,\n                // create a block so this can be executed immediately after this line.\n\n                Block? result = _script.CurrentSituation.AddBlock(ConsumePlayUntil(), joinLevel: 0, isNested: false);", "            if (_wasPreviousAction)\n            {\n                // If current line is not an action *but* the previous line was,\n                // create a block so this can be executed immediately after this line.\n\n                Block? result = _script.CurrentSituation.AddBlock(ConsumePlayUntil(), joinLevel: 0, isNested: false);\n                if (result is null)\n                {\n                    OutputHelpers.WriteError($\"Unable to add condition on line {index}. Was the indentation correct?\");\n                    return false;\n                }\n\n                _currentBlock = result.Id;\n                _wasPreviousAction = false;\n            }\n\n            CheckAndCreateLinearBlock(joinLevel: 0, isNested);\n\n            // This is probably just a line! So let's just read as it is.\n            AddLineToBlock(line);\n            return true;\n        }\n", "        private void AddLineToBlock(ReadOnlySpan<char> line)\n        {\n            (string? speaker, string? portrait) = ReadSpeakerAndLine(line, out int end);\n            if (end != -1)\n            {\n                line = line.Slice(end + 1);\n            }\n\n            line = line.TrimStart().TrimEnd();\n\n            Block.AddLine(speaker, portrait, line.ToString().Replace(\"\\\\\", \"\"));\n        }\n\n        /// <summary>\n        /// Read an optional string for the speaker and portrait in a line.\n        /// Valid examples:\n        ///     {speaker}.{portrait}: {line}\n        ///     {speaker}: {line}\n        ///     {line}\n        /// </summary>\n        private (string? Speaker, string? Portrait) ReadSpeakerAndLine(ReadOnlySpan<char> line, out int end)\n        {\n            string? speaker = null;\n            string? portrait = null;\n\n            end = -1;\n", "            if (line.IsEmpty)\n            {\n                return (speaker, portrait);\n            }\n\n            ReadOnlySpan<char> speakerText = GetNextWord(line, out end);\n            if (end == -1)\n            {\n                return (speaker, portrait);\n            }\n\n            // First, check if there is a speaker specified and look for the escape token.\n            end = speakerText.IndexOf(Tokens.SpeakerToken);", "            if (end == -1 || speakerText[end-1] == Tokens.EscapeToken)\n            {\n                return (speaker, portrait);\n            }\n\n            speakerText = speakerText.Slice(0, end);\n\n            int portraitEndIndex = speakerText.IndexOf(Tokens.SpeakerPortraitToken);\n            if (portraitEndIndex == -1)\n            {\n                return (speakerText.ToString(), portrait);\n            }\n\n            speaker = speakerText.Slice(0, portraitEndIndex).ToString();\n            portrait = speakerText.Slice(portraitEndIndex + 1).ToString();\n\n            return (speaker, portrait);\n        }\n    }\n}\n", "            if (portraitEndIndex == -1)\n            {\n                return (speakerText.ToString(), portrait);\n            }\n\n            speaker = speakerText.Slice(0, portraitEndIndex).ToString();\n            portrait = speakerText.Slice(portraitEndIndex + 1).ToString();\n\n            return (speaker, portrait);\n        }\n    }\n}\n"]}
{"filename": "src/Gum/Parser_Trimmer.cs", "chunked_list": ["\ufeffusing Gum.InnerThoughts;\n\nnamespace Gum\n{\n    public partial class Parser\n    {\n        /// <summary>\n        /// This will trim the graph: clean up empty edges and such.\n        /// </summary>\n        private bool Trim()\n        {\n            IEnumerable<Situation> situations = _script.FetchAllSituations();\n", "        private bool Trim()\n        {\n            IEnumerable<Situation> situations = _script.FetchAllSituations();\n\n            foreach (Situation s in situations)\n            {\n                (int, Edge)[] edges = s.Edges.Select(t => (t.Key, t.Value)).ToArray();\n                foreach ((int owner, Edge edge) in edges)\n                {\n                    if (edge.Blocks.Count == 0)\n                    {\n                        s.Edges.Remove(owner);\n                    }\n                }\n            }\n\n            return true;\n        }\n    }\n}\n", "                    if (edge.Blocks.Count == 0)\n                    {\n                        s.Edges.Remove(owner);\n                    }\n                }\n            }\n\n            return true;\n        }\n    }\n}\n"]}
{"filename": "src/Gum/AssemblyInfo.cs", "chunked_list": ["\ufeffusing System.Runtime.CompilerServices;\n\n[assembly: InternalsVisibleTo(\"Gum.Tests\")]"]}
{"filename": "src/Gum/Attributes/TokenName.cs", "chunked_list": ["\ufeffnamespace Gum.Attributes\n{\n    internal class TokenNameAttribute : Attribute\n    {\n        public string Name;\n\n        public TokenNameAttribute(string name)\n        {\n            Name = name;\n        }\n    }\n}\n"]}
{"filename": "src/Gum/Utilities/OutputHelpers.cs", "chunked_list": ["\ufeffusing System;\nusing Gum.Attributes;\n\nnamespace Gum.Utilities\n{\n    internal static class OutputHelpers\n    {\n        internal static DiagnosticLevel Level = DiagnosticLevel.All;\n\n        public static void Log(string message)\n        {", "        public static void Log(string message)\n        {\n            if (Level == DiagnosticLevel.ErrorsOnly)\n            {\n                return;\n            }\n\n            Console.ForegroundColor = ConsoleColor.Magenta;\n            Console.WriteLine(message);\n            Console.ResetColor();\n        }\n", "        public static void WriteError(string message)\n        {\n            Console.ForegroundColor = ConsoleColor.Red;\n            Console.WriteLine($\"\ud83e\udd1a Error! {message}\");\n            Console.ResetColor();\n        }\n\n        public static void WriteWarning(string message)\n        {\n            Console.ForegroundColor = ConsoleColor.Yellow;\n            Console.WriteLine($\"\ud83d\udea7 Warning! {message}\");\n            Console.ResetColor();\n        }\n", "        public static void Suggestion(string message)\n        {\n            Console.WriteLine($\"\ud83d\udca1 Did you mean {message}\");\n        }\n\n        public static void Remark(string message)\n        {\n            Console.WriteLine(message);\n        }\n\n        public static void ProposeFix(int line, ReadOnlySpan<char> before, ReadOnlySpan<char> after)\n        {\n            Console.WriteLine(\"Suggestion:\");\n            Console.WriteLine($\"\\tLine {line} | {before}\");\n            Console.WriteLine($\"\\t   \u2b07\ufe0f\");\n            Console.WriteLine($\"\\tLine {line} | {after}\");\n        }\n", "        public static void ProposeFix(int line, ReadOnlySpan<char> before, ReadOnlySpan<char> after)\n        {\n            Console.WriteLine(\"Suggestion:\");\n            Console.WriteLine($\"\\tLine {line} | {before}\");\n            Console.WriteLine($\"\\t   \u2b07\ufe0f\");\n            Console.WriteLine($\"\\tLine {line} | {after}\");\n        }\n\n        public static void ProposeFixOnLineAbove(int line, ReadOnlySpan<char> currentLine, ReadOnlySpan<char> newLine)\n        {\n            Console.WriteLine(\"Suggestion:\");\n            Console.WriteLine($\"\\tLine {line} | {currentLine}\");\n            Console.WriteLine($\"\\t   \u2b07\ufe0f\");\n            Console.WriteLine($\"\\tLine {line} | {newLine}\");\n            Console.WriteLine($\"\\tLine {line+1} | {currentLine}\");\n        }\n", "        public static void ProposeFixOnLineAbove(int line, ReadOnlySpan<char> currentLine, ReadOnlySpan<char> newLine)\n        {\n            Console.WriteLine(\"Suggestion:\");\n            Console.WriteLine($\"\\tLine {line} | {currentLine}\");\n            Console.WriteLine($\"\\t   \u2b07\ufe0f\");\n            Console.WriteLine($\"\\tLine {line} | {newLine}\");\n            Console.WriteLine($\"\\tLine {line+1} | {currentLine}\");\n        }\n\n        public static void ProposeFixOnLineBelow(int line, ReadOnlySpan<char> currentLine, ReadOnlySpan<char> newLine, ReadOnlySpan<char> newLineBelow)\n        {\n            Console.WriteLine(\"Suggestion:\");\n            Console.WriteLine($\"\\tLine {line} | {currentLine}\");\n            Console.WriteLine($\"\\t   \u2b07\ufe0f\");\n            Console.WriteLine($\"\\tLine {line} | {newLine}\");\n            Console.WriteLine($\"\\tLine {line + 1} | {newLineBelow}\");\n        }\n", "        public static void ProposeFixOnLineBelow(int line, ReadOnlySpan<char> currentLine, ReadOnlySpan<char> newLine, ReadOnlySpan<char> newLineBelow)\n        {\n            Console.WriteLine(\"Suggestion:\");\n            Console.WriteLine($\"\\tLine {line} | {currentLine}\");\n            Console.WriteLine($\"\\t   \u2b07\ufe0f\");\n            Console.WriteLine($\"\\tLine {line} | {newLine}\");\n            Console.WriteLine($\"\\tLine {line + 1} | {newLineBelow}\");\n        }\n\n        public static void ProposeFixAtColumn(int line, int column, int arrowLength, ReadOnlySpan<char> content, ReadOnlySpan<char> issue)\n        {\n            Console.WriteLine($\"\\tLine {line} | {content}\");\n\n            Console.Write(\"\\t          \");\n", "        public static void ProposeFixAtColumn(int line, int column, int arrowLength, ReadOnlySpan<char> content, ReadOnlySpan<char> issue)\n        {\n            Console.WriteLine($\"\\tLine {line} | {content}\");\n\n            Console.Write(\"\\t          \");\n\n            while (column-- > 0)\n            {\n                Console.Write(' ');\n            }\n\n            // The emoji occupies sort of two characters?\n            arrowLength = Math.Max(1, arrowLength/2);\n", "            while (arrowLength-- > 0)\n            {\n                Console.Write($\"\u261d\ufe0f\");\n            }\n            Console.Write($\" {issue}\");\n        }\n\n        public static string ToCustomString<T>(this T value) where T : Enum\n        {\n            TokenNameAttribute[] attributes = (TokenNameAttribute[])typeof(T)\n                .GetField(value.ToString())!\n                .GetCustomAttributes(typeof(TokenNameAttribute), false);\n\n            return attributes.Length > 0 ? attributes[0].Name : value.ToString();\n        }\n    }\n}\n"]}
{"filename": "src/Gum/Utilities/InnerThoughtsHelpers.cs", "chunked_list": ["\ufeffusing Gum.InnerThoughts;\n\nnamespace Gum.Utilities\n{\n    internal static class InnerThoughtsHelpers\n    {\n        /// <summary>\n        /// Returns whether the order in which the blocks are available within an edge\n        /// is relevant or not when picking a new option.\n        /// </summary>\n        public static bool IsSequential(this EdgeKind kind)\n        {\n            switch (kind)\n            {\n                case EdgeKind.Next:\n                case EdgeKind.IfElse:\n                case EdgeKind.Choice:\n                    return true;\n\n                case EdgeKind.Random:\n                case EdgeKind.HighestScore:\n                    return false;\n            }\n\n            return false;\n        }\n    }\n}\n", "        public static bool IsSequential(this EdgeKind kind)\n        {\n            switch (kind)\n            {\n                case EdgeKind.Next:\n                case EdgeKind.IfElse:\n                case EdgeKind.Choice:\n                    return true;\n\n                case EdgeKind.Random:\n                case EdgeKind.HighestScore:\n                    return false;\n            }\n\n            return false;\n        }\n    }\n}\n"]}
{"filename": "src/Gum/Utilities/WritablePropertiesOnlyResolver.cs", "chunked_list": ["\ufeffusing Newtonsoft.Json;\nusing Newtonsoft.Json.Serialization;\nusing System.Reflection;\n\nnamespace Murder.Serialization\n{\n    /// <summary>\n    /// Custom contract resolver for serializing our game assets.\n    /// This currently filters out getters and filters in readonly fields.\n    /// </summary>\n    internal class WritablePropertiesOnlyResolver : DefaultContractResolver\n    {\n        /// <summary>\n        /// Only create properties that are able to be set.\n        /// See: https://stackoverflow.com/a/18548894.\n        /// </summary>", "    /// This currently filters out getters and filters in readonly fields.\n    /// </summary>\n    internal class WritablePropertiesOnlyResolver : DefaultContractResolver\n    {\n        /// <summary>\n        /// Only create properties that are able to be set.\n        /// See: https://stackoverflow.com/a/18548894.\n        /// </summary>\n        protected override IList<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization)\n        {\n            IList<JsonProperty> properties = base.CreateProperties(type, memberSerialization);\n            return properties.Where(p => p.Writable).ToList();\n        }\n        \n        /// <summary>\n        /// While we ignore getter properties, we do not want to ignore readonly fields.\n        /// </summary>", "        protected override IList<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization)\n        {\n            IList<JsonProperty> properties = base.CreateProperties(type, memberSerialization);\n            return properties.Where(p => p.Writable).ToList();\n        }\n        \n        /// <summary>\n        /// While we ignore getter properties, we do not want to ignore readonly fields.\n        /// </summary>\n        protected override JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization)\n        {\n            var property = base.CreateProperty(member, memberSerialization);\n            \n            switch (member.MemberType)\n            {\n                case MemberTypes.Field:\n                    property.Readable = true;\n                    property.Writable = true;\n                    break;\n            }\n\n            return property;\n        }\n    }\n}\n", "        protected override JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization)\n        {\n            var property = base.CreateProperty(member, memberSerialization);\n            \n            switch (member.MemberType)\n            {\n                case MemberTypes.Field:\n                    property.Readable = true;\n                    property.Writable = true;\n                    break;\n            }\n\n            return property;\n        }\n    }\n}\n"]}
{"filename": "src/Gum/Blackboards/BlackboardActionKind.cs", "chunked_list": ["\ufeffusing Gum.Attributes;\n\nnamespace Gum.Blackboards\n{\n    public enum BlackboardActionKind\n    {\n        [TokenName(\"=\")]\n        Set,      // All\n\n        [TokenName(\"+=\")]\n        Add,      // Integer\n\n        [TokenName(\"-=\")]\n        Minus,    // Integer\n\n        [TokenName(\"c:\")]\n        Component // Adding or modifying components.\n    }\n}\n"]}
{"filename": "src/Gum/InnerThoughts/Line.cs", "chunked_list": ["\ufeffusing System.Diagnostics;\n\nnamespace Gum.InnerThoughts\n{\n    [DebuggerDisplay(\"{Text}\")]\n    public readonly struct Line\n    {\n        /// <summary>\n        /// This may be the speaker name or \"Owner\" for whoever owns this script.\n        /// </summary>\n        public readonly string? Speaker;\n", "        public readonly string? Speaker;\n\n        public readonly string? Portrait = null;\n\n        /// <summary>\n        /// If the caption has a text, this will be the information.\n        /// </summary>\n        public readonly string? Text = null;\n\n        /// <summary>\n        /// Delay in seconds.\n        /// </summary>", "        public readonly float? Delay = null;\n\n        public Line() { }\n\n        public Line(string? speaker) => Speaker = speaker;\n\n        /// <summary>\n        /// Create a line with a text. That won't be used as a timer.\n        /// </summary>\n        public Line(string? speaker, string? portrait, string text) => (Speaker, Portrait, Text) = (speaker, portrait, text);\n", "        public static Line LineWithoutSpeaker(string text) => new(speaker: null, portrait: null, text);\n\n        public bool IsText => Text is not null;\n    }\n}\n"]}
{"filename": "src/Gum/InnerThoughts/CharacterScript.cs", "chunked_list": ["\ufeffusing Newtonsoft.Json;\n\nnamespace Gum.InnerThoughts\n{\n    public class CharacterScript\n    {\n        /// <summary>\n        /// List of tasks or events that the <see cref=\"Situations\"/> may do.\n        /// </summary>\n        [JsonProperty]\n        private readonly SortedList<int, Situation> _situations = new();\n", "        private readonly SortedList<int, Situation> _situations = new();\n\n        private readonly Dictionary<string, int> _situationNames = new();\n\n        [JsonProperty]\n        private int _nextId = 0;\n\n        public readonly string Name;\n\n        public CharacterScript(string name) { Name = name; }\n\n        private Situation? _currentSituation;\n", "        public Situation CurrentSituation => \n            _currentSituation ?? throw new InvalidOperationException(\"\u2620\ufe0f Unable to fetch an active situation.\");\n\n        public bool HasCurrentSituation => _currentSituation != null;\n        \n        public bool AddNewSituation(ReadOnlySpan<char> name)\n        {\n            int id = _nextId++;\n\n            string situationName = name.TrimStart().TrimEnd().ToString();\n            if (_situationNames.ContainsKey(situationName))\n            {\n                return false;\n            }\n\n            _currentSituation = new Situation(id, situationName);\n\n            _situations.Add(id, _currentSituation);\n            _situationNames.Add(situationName, id);\n            return true;\n        }\n\n        public Situation? FetchSituation(int id)\n        {", "            if (_situationNames.ContainsKey(situationName))\n            {\n                return false;\n            }\n\n            _currentSituation = new Situation(id, situationName);\n\n            _situations.Add(id, _currentSituation);\n            _situationNames.Add(situationName, id);\n            return true;\n        }\n\n        public Situation? FetchSituation(int id)\n        {", "            if (_situations.TryGetValue(id, out Situation? value))\n            {\n                return value;\n            }\n\n            return null;\n        }\n\n        public int? FetchSituationId(string name)\n        {\n            if (_situationNames.TryGetValue(name, out int id))\n            {\n                return id;\n            }\n\n            return null;\n        }\n\n        public string[] FetchAllNames() => _situationNames.Keys.ToArray();\n\n        public IEnumerable<Situation> FetchAllSituations() => _situations.Values;\n    }\n}\n", "            if (_situationNames.TryGetValue(name, out int id))\n            {\n                return id;\n            }\n\n            return null;\n        }\n\n        public string[] FetchAllNames() => _situationNames.Keys.ToArray();\n\n        public IEnumerable<Situation> FetchAllSituations() => _situations.Values;\n    }\n}\n"]}
{"filename": "src/Gum/InnerThoughts/Fact.cs", "chunked_list": ["\ufeffusing System.Diagnostics;\n\nnamespace Gum.InnerThoughts\n{\n    public enum FactKind\n    {\n        Invalid,\n        Int,\n        Bool,\n        String,\n\n        /// <summary>\n        /// Used when the fact is only a weight which will be applied when picking\n        /// the most suitable dialog.\n        /// </summary>\n        Weight,\n\n        /// <summary>\n        /// Used when checking for required components.\n        /// </summary>\n        Component\n    }\n\n    [DebuggerDisplay(\"{Name}\")]", "    public readonly struct Fact\n    {\n        /// <summary>\n        /// If null, the user did not especify any blackboard and can be assumed the default one.\n        /// </summary>\n        public readonly string? Blackboard = null;\n\n        public readonly string Name = string.Empty;\n\n        public readonly FactKind Kind = FactKind.Invalid;\n\n        /// <summary>\n        /// Set when the fact is of type <see cref=\"FactKind.Component\"/>\n        /// </summary>", "        public readonly FactKind Kind = FactKind.Invalid;\n\n        /// <summary>\n        /// Set when the fact is of type <see cref=\"FactKind.Component\"/>\n        /// </summary>\n        public readonly string? ComponentType = null;\n\n        public Fact() { }\n\n        private Fact(FactKind kind) => Kind = kind;\n\n        public Fact(string componentType) => (Kind, ComponentType) = (FactKind.Component, componentType);\n\n        public Fact(string? blackboard, string name, FactKind kind) =>\n            (Blackboard, Name, Kind) = (blackboard, name, kind);\n\n        /// <summary>\n        /// Creates a fact of type <see cref=\"FactKind.Weight\"/>.\n        /// </summary>\n        internal static Fact Weight => new(FactKind.Weight);\n\n        /// <summary>\n        /// Creates a fact of type <see cref=\"FactKind.Component\"/>.\n        /// </summary>\n        internal static Fact Component => new(FactKind.Component);\n    }\n}\n"]}
{"filename": "src/Gum/InnerThoughts/CriterionNodeKind.cs", "chunked_list": ["\ufeffusing Gum.Attributes;\n\nnamespace Gum.InnerThoughts\n{\n    public enum CriterionNodeKind\n    {\n        [TokenName(\"and\")]\n        And,\n\n        [TokenName(\"or\")]\n        Or\n    }\n}\n"]}
{"filename": "src/Gum/InnerThoughts/Situation.cs", "chunked_list": ["\ufeffusing Gum.Utilities;\nusing Newtonsoft.Json;\nusing System.Diagnostics;\n\nnamespace Gum.InnerThoughts\n{\n    [DebuggerDisplay(\"{Name}\")]\n    public class Situation\n    {\n        [JsonProperty]\n        public readonly int Id = 0;\n\n        [JsonProperty]", "        public readonly int Id = 0;\n\n        [JsonProperty]\n        public readonly string Name = string.Empty;\n\n        public int Root = 0;\n\n        public readonly List<Block> Blocks = new();\n\n        /// <summary>\n        /// This points\n        /// [ Node Id -> Edge ]\n        /// </summary>", "        public readonly Dictionary<int, Edge> Edges = new();\n\n        /// <summary>\n        /// This points\n        /// [ Node Id -> Parent ]\n        /// If parent is empty, this is at the top.\n        /// </summary>\n        public readonly Dictionary<int, HashSet<int>> ParentOf = new();\n\n        private readonly Stack<int> _lastBlocks = new();\n\n        public Situation() { }\n\n        public Situation(int id, string name)\n        {\n            Id = id;\n            Name = name;\n\n            // Add a root node.\n            Block block = CreateBlock(playUntil: -1, track: true);\n            Edge edge = CreateEdge(EdgeKind.Next);\n\n            AssignOwnerToEdge(block.Id, edge);\n\n            Root = block.Id;\n        }\n", "        private readonly Stack<int> _lastBlocks = new();\n\n        public Situation() { }\n\n        public Situation(int id, string name)\n        {\n            Id = id;\n            Name = name;\n\n            // Add a root node.\n            Block block = CreateBlock(playUntil: -1, track: true);\n            Edge edge = CreateEdge(EdgeKind.Next);\n\n            AssignOwnerToEdge(block.Id, edge);\n\n            Root = block.Id;\n        }\n", "        public bool SwitchRelationshipTo(EdgeKind kind)\n        {\n            Edge lastEdge = LastEdge;\n            \n            if (lastEdge.Kind == kind)\n            {\n                // No operation, relationship is already set.\n                return true;\n            }\n\n            int length = lastEdge.Blocks.Count;\n\n            switch (kind)\n            {\n                case EdgeKind.Next:\n                case EdgeKind.Random:\n                    lastEdge.Kind = kind;\n                    return true;\n\n                case EdgeKind.Choice:\n                case EdgeKind.HighestScore:", "                    if (length == 1)\n                    {\n                        lastEdge.Kind = kind;\n                    }\n                    else\n                    {\n                        Debug.Fail(\"I don't understand this scenario fully, please debug this.\");\n                        // Remove the last block and create a new one?\n                    }\n\n                    return true;\n\n                case EdgeKind.IfElse:\n                    return false;\n            }\n\n            return true;\n        }\n\n        internal EdgeKind PeekLastEdgeKind() => LastEdge.Kind;\n\n        internal Block PeekLastBlock() => Blocks[_lastBlocks.Peek()];\n\n        internal Block PeekLastBlockParent() => Blocks[_lastBlocks.ElementAt(1)];\n\n        internal Block PeekBlockAt(int level) => Blocks[_lastBlocks.ElementAt(level)];\n\n        /// <summary>\n        /// Creates a new block subjected to a <paramref name=\"kind\"/> relationship.\n        /// </summary>\n        public Block? AddBlock(int playUntil, int joinLevel, bool isNested, EdgeKind kind = EdgeKind.Next)\n        {\n            Block lastBlock = PeekLastBlock();", "            if (joinLevel == 0 && playUntil == 1 && lastBlock.PlayUntil == 1 && !lastBlock.NonLinearNode)\n            {\n                // Consider this:\n                //     @1  -> Go\n                //\n                //     @1  Some other dialog with the same indentation.\n                //         -> exit!\n                // We need to \"fake\" another join level here to make up for our lack of indentation.\n                joinLevel += 1;\n            }\n\n            // We need to know the \"parent\" node when nesting blocks (make the parent -> point to the new block).\n            (int parentId, int[] blocksToBeJoined) = FetchParentOfJoinedBlock(joinLevel, kind);\n\n            Edge lastEdge = Edges[parentId];\n\n            // Looks on whether we need to pop nodes on:\n            //  >> Dialog\n            //  > Choice\n            //  > Choice 2 <- pop here!\n            bool shouldPopChoiceBlock = kind == EdgeKind.Choice && Blocks[parentId].IsChoice && lastEdge.Kind != kind && !isNested;\n", "            if (shouldPopChoiceBlock || (!kind.IsSequential() && Blocks[parentId].NonLinearNode))\n            {\n                // This is the only \"HACKY\" thing I will allow here.\n                // Since I want to avoid a syntax such as:\n                //  (condition)\n                //      @score\n                //          - something\n                //          - something\n                // and instead have something like\n                //  (condition)\n                //      - something\n                //      - something\n                // I will do the following:\n                _lastBlocks.Pop();\n\n                parentId = _lastBlocks.Peek();\n                blocksToBeJoined = new int[] { parentId };\n            }\n            \n            // Do not make a join on the leaves if this is an (...) or another choice (-/+)", "            if (kind == EdgeKind.IfElse || \n                (!lastEdge.Kind.IsSequential() && !kind.IsSequential()) || \n                (kind == EdgeKind.Choice && lastEdge.Kind == EdgeKind.Choice))\n            {\n                blocksToBeJoined = new int[] { parentId };\n            }\n\n            Block block = CreateBlock(playUntil, track: true);\n\n            block.NonLinearNode = !kind.IsSequential();\n            block.IsChoice = kind == EdgeKind.Choice;\n\n            Edge? edge = CreateEdge(EdgeKind.Next);\n            AssignOwnerToEdge(block.Id, edge);\n\n            // If this was called right after a situation has been declared, it'll think that it is a nested block\n            // (when it's not really).\n", "            if (isNested)\n            {\n                Edge? parentEdge = Edges[parentId];\n\n                if (block.IsChoice)\n                {\n                    parentEdge.Kind = EdgeKind.Next;\n\n                    //  (Condition)\n                    //      >> Nested title\n                    //      > Option a\n                    //      > Option b\n                    edge.Kind = kind;\n                }\n                else\n                {\n                    parentEdge.Kind = kind;\n                }\n\n                AddNode(parentEdge, block.Id);\n\n                return block;\n            }\n", "            foreach (int parent in blocksToBeJoined)\n            {\n                JoinBlock(block, edge, parent, kind);\n            }\n\n            return block;\n        }\n\n        private bool JoinBlock(Block block, Edge nextEdge, int parentId, EdgeKind kind)\n        {\n            Edge lastEdge = Edges[parentId];\n            switch (kind)\n            {\n                case EdgeKind.Choice:", "        private bool JoinBlock(Block block, Edge nextEdge, int parentId, EdgeKind kind)\n        {\n            Edge lastEdge = Edges[parentId];\n            switch (kind)\n            {\n                case EdgeKind.Choice:\n                    if (lastEdge.Kind != EdgeKind.Choice)\n                    {\n                        // before:\n                        //     .\n                        //     |    D\n                        //     A \n                        //\n                        // after:\n                        //     .\n                        //     |\n                        //     A\n                        //     |\n                        //     D\n                        //  {choice}\n\n                        lastEdge = Edges[parentId];\n                        AddNode(lastEdge, block.Id);\n\n                        nextEdge.Kind = kind;\n\n                        return true;\n                    }\n\n                    AddNode(lastEdge, block.Id);\n                    return true;\n\n                case EdgeKind.HighestScore:\n                case EdgeKind.Random:\n                    // nextEdge.Kind = EdgeKind.HighestScore;\n                    break;\n\n                case EdgeKind.IfElse:", "                    if (lastEdge.Kind == EdgeKind.IfElse ||\n                        (lastEdge.Kind.IsSequential() && lastEdge.Blocks.Count == 1))\n                    {\n                        lastEdge.Kind = EdgeKind.IfElse;\n\n                        AddNode(lastEdge, block.Id);\n                        return true;\n                    }\n\n                    if (lastEdge.Blocks.Count > 1)\n                    {\n                        CreateDummyNodeAt(lastEdge.Blocks.Last(), block.Id, kind);\n                        return true;\n                    }\n\n                    Debug.Fail(\"Empty edge?\");\n                    return false;\n            }\n", "                    if (lastEdge.Blocks.Count > 1)\n                    {\n                        CreateDummyNodeAt(lastEdge.Blocks.Last(), block.Id, kind);\n                        return true;\n                    }\n\n                    Debug.Fail(\"Empty edge?\");\n                    return false;\n            }\n\n            if (kind == EdgeKind.IfElse && lastEdge.Kind != kind)\n            {", "            if (kind == EdgeKind.IfElse && lastEdge.Kind != kind)\n            {\n                if (lastEdge.Kind != EdgeKind.Next)\n                {\n                    CreateDummyNodeAt(parentId, block.Id, kind);\n                    return true;\n                }\n\n                // This has been a bit of a headache, but if this is an \"if else\" and the current connection\n                // is not the same, we'll convert this later.\n                kind = EdgeKind.Next;\n            }\n\n            // If this is \"intruding\" an existing nested if-else.\n            //  (hasA)\n            //      (hasB)\n            //      (...)\n            //  (...)", "            else if (kind == EdgeKind.IfElse && lastEdge.Kind == kind && parentId == lastEdge.Owner)\n            {\n                CreateDummyNodeAt(parentId, block.Id, kind);\n                return true;\n            }\n\n            if (kind == EdgeKind.HighestScore && lastEdge.Kind == EdgeKind.Random)\n            {\n                // A \"HighestScore\" kind when is matched with a \"random\" relationship, it is considered one of them\n                // automatically.\n                kind = EdgeKind.Random;\n            }\n", "            if (lastEdge.Kind != kind && lastEdge.Blocks.Count == 0)\n            {\n                lastEdge.Kind = kind;\n            }\n            else if (lastEdge.Kind != kind && kind == EdgeKind.HighestScore)\n            {\n                // No-op?\n            }\n            else if (lastEdge.Kind != kind)\n            {\n                CreateDummyNodeAt(parentId, block.Id, kind);\n                return true;\n            }\n\n            AddNode(lastEdge, block.Id);\n            return true;\n        }\n\n        /// <summary>\n        /// Given C and D:\n        /// Before:\n        ///    A\n        ///   / \\\n        ///  B   C <- parent  D <- block\n        ///     /\n        ///  ...\n        ///  \n        /// After:\n        ///    A\n        ///   / \\\n        ///  B   E <- dummy\n        ///     / \\\n        ///    C   D\n        ///   /    \n        ///...\n        ///\n        /// </summary>", "            else if (lastEdge.Kind != kind)\n            {\n                CreateDummyNodeAt(parentId, block.Id, kind);\n                return true;\n            }\n\n            AddNode(lastEdge, block.Id);\n            return true;\n        }\n\n        /// <summary>\n        /// Given C and D:\n        /// Before:\n        ///    A\n        ///   / \\\n        ///  B   C <- parent  D <- block\n        ///     /\n        ///  ...\n        ///  \n        /// After:\n        ///    A\n        ///   / \\\n        ///  B   E <- dummy\n        ///     / \\\n        ///    C   D\n        ///   /    \n        ///...\n        ///\n        /// </summary>", "        private void CreateDummyNodeAt(int parentId, int blockId, EdgeKind kind)\n        {\n            Block lastBlock = Blocks[parentId];\n\n            // Block the last block, this will be the block that we just added (blockId).\n            _ = _lastBlocks.TryPop(out _);\n\n            // If this block corresponds to the parent, remove it from the stack.\n            if (_lastBlocks.TryPeek(out int peek) && peek == parentId)\n            {\n                _ = _lastBlocks.Pop();\n            }\n\n            Block empty = CreateBlock(playUntil: lastBlock.PlayUntil, track: true);\n            ReplaceEdgesToNodeWith(parentId, empty.Id);\n\n            _lastBlocks.Push(blockId);\n\n            Edge lastEdge = CreateEdge(kind);\n            AddNode(lastEdge, parentId);\n            AddNode(lastEdge, blockId);\n            AssignOwnerToEdge(empty.Id, lastEdge);\n        }\n\n        /// <summary>\n        /// Find all leaf nodes eligible to be joined.\n        /// This will disregard nodes that are already dead (due to a goto!).\n        /// </summary>", "            if (_lastBlocks.TryPeek(out int peek) && peek == parentId)\n            {\n                _ = _lastBlocks.Pop();\n            }\n\n            Block empty = CreateBlock(playUntil: lastBlock.PlayUntil, track: true);\n            ReplaceEdgesToNodeWith(parentId, empty.Id);\n\n            _lastBlocks.Push(blockId);\n\n            Edge lastEdge = CreateEdge(kind);\n            AddNode(lastEdge, parentId);\n            AddNode(lastEdge, blockId);\n            AssignOwnerToEdge(empty.Id, lastEdge);\n        }\n\n        /// <summary>\n        /// Find all leaf nodes eligible to be joined.\n        /// This will disregard nodes that are already dead (due to a goto!).\n        /// </summary>", "        private void GetAllLeaves(int block, bool createBlockForElse, ref HashSet<int> result)\n        {\n            Edge edge = Edges[block];\n            if (edge.Blocks.Count != 0)\n            {\n                foreach (int otherBlock in edge.Blocks)\n                {\n                    GetAllLeaves(otherBlock, createBlockForElse, ref result);\n                }\n\n                if (createBlockForElse)\n                {\n                    //  @1  (Something)\n                    //          Hello!\n                    //\n                    //      (...Something2)\n                    //          Hello once?\n                    //  Bye.\n                    //\n                    // turns into:\n                    //  @1  (Something)\n                    //          Hello!\n                    //\n                    //      (...Something2)\n                    //          Hello once?\n                    //\n                    //      (...)\n                    //          // go down.\n                    //\n                    //  Bye.\n                    // If this an else if, but may not enter any of the blocks,\n                    // do a last else to the next block.", "                if (createBlockForElse)\n                {\n                    //  @1  (Something)\n                    //          Hello!\n                    //\n                    //      (...Something2)\n                    //          Hello once?\n                    //  Bye.\n                    //\n                    // turns into:\n                    //  @1  (Something)\n                    //          Hello!\n                    //\n                    //      (...Something2)\n                    //          Hello once?\n                    //\n                    //      (...)\n                    //          // go down.\n                    //\n                    //  Bye.\n                    // If this an else if, but may not enter any of the blocks,\n                    // do a last else to the next block.", "                    if (edge.Kind == EdgeKind.IfElse &&\n                        Blocks[edge.Blocks.Last()].Requirements.Count != 0)\n                    {\n                        // Create else block and its edge.\n                        int elseBlockId = CreateBlock(-1, track: false).Id;\n\n                        Edge? elseBlockEdge = CreateEdge(EdgeKind.Next);\n                        AssignOwnerToEdge(elseBlockId, elseBlockEdge);\n\n                        // Assign the block as part of the .IfElse edge.\n                        AddNode(edge, elseBlockId);\n\n                        // Track the block as a leaf.\n                        result.Add(elseBlockId);\n                    }\n                }\n            }\n            else\n            {", "                if (!_blocksWithGoto.Contains(block))\n                {\n                    // This doesn't point to any other blocks - so it's a leaf!\n                    result.Add(block);\n                }\n            }\n        }\n\n        private (int Parent, int[] blocksToBeJoined) FetchParentOfJoinedBlock(int joinLevel, EdgeKind edgeKind)\n        {\n            int topParent;\n", "            if (joinLevel == 0)\n            {\n                topParent = _lastBlocks.Peek();\n\n                return (topParent, new int[] { topParent });\n            }\n\n            while (_lastBlocks.Count > 1 && joinLevel-- > 0)\n            {\n                int blockId = _lastBlocks.Pop();\n                Block block = Blocks[blockId];\n\n                // When I said I would allow one (1) hacky code, I lied.\n                // This is another one.\n                // SO, the indentation gets really weird for conditionals, as we pretty\n                // much disregard one indent? I found that the best approach to handle this is \n                // manually cleaning up the stack when there is NOT a conditional block on join.\n                // This is also true for @[0-9] blocks, since those add an extra indentation.", "                if (block.NonLinearNode)\n                {\n                    if (block.Conditional)\n                    {\n                        // Nevermind the last pop: this is actually not an indent at all, as the last\n                        // block was actually a condition (and we have a minus one indent).\n                        _lastBlocks.Push(blockId);\n                    }\n                    else if (Edges[ParentOf[blockId].First()].Kind != EdgeKind.HighestScore)\n                    {\n                        // Skip indentation for non linear nodes with the default setting.\n                        // TODO: Check how that breaks join with @order? Does it actually break?\n                        // no-op.\n                    }\n                    else\n                    {\n                        joinLevel++;\n                    }\n                }", "                    else if (Edges[ParentOf[blockId].First()].Kind != EdgeKind.HighestScore)\n                    {\n                        // Skip indentation for non linear nodes with the default setting.\n                        // TODO: Check how that breaks join with @order? Does it actually break?\n                        // no-op.\n                    }\n                    else\n                    {\n                        joinLevel++;\n                    }\n                }", "                else if (!block.Conditional)\n                {\n                    // [parent]\n                    //  @1  Conditional\n                    //      Line\n                    //\n                    //  And the other block.\n                    //  but not here:\n                    //  >> something\n                    //  > a\n                    //      >> b\n                    //      > c\n                    //  > d <-", "                    if (block.PlayUntil == -1 && (!block.IsChoice || edgeKind != EdgeKind.Choice))\n                    {\n                        joinLevel++;\n                    }\n                }\n            }\n\n            topParent = _lastBlocks.Peek();\n\n            int[] blocksToLookForLeaves = Edges[topParent].Blocks.ToArray();\n            HashSet<int> leafBlocks = new();\n\n            // Now, for each of those blocks, we'll collect all of its leaves and add edges to it.", "            foreach (int blockToJoin in blocksToLookForLeaves)\n            {\n                GetAllLeaves(blockToJoin, createBlockForElse: edgeKind != EdgeKind.IfElse, ref leafBlocks);\n            }\n\n            leafBlocks.Add(topParent);\n\n            if (leafBlocks.Count != 0)\n            {\n                HashSet<int> prunnedLeafBlocks = leafBlocks.ToHashSet();\n                foreach (int b in prunnedLeafBlocks)\n                {", "                foreach (int b in prunnedLeafBlocks)\n                {\n                    if (b != topParent)\n                    {\n                        // Whether this block will always be played or is it tied to a condition.\n                        // If this is tied to the root directly, returns -1.\n                        int conditionalParent = GetConditionalBlock(b);\n                        if (conditionalParent == -1 || conditionalParent == topParent)\n                        {\n                            prunnedLeafBlocks.Remove(topParent);\n                        }\n                    }\n\n                    // If the last block doesn't have any condition *but* this is actually an \n                    // if else block.\n                    // I *think* this doesn't take into account child of child blocks, but it's not\n                    // the end of the world if we have an extra edge that will never be reached.\n                    switch (Edges[b].Kind)\n                    {\n                        case EdgeKind.IfElse:", "                            if (Edges[b].Blocks.LastOrDefault() is int lastBlockId)\n                            {\n                                if (Blocks[lastBlockId].Requirements.Count == 0 && \n                                    prunnedLeafBlocks.Contains(lastBlockId))\n                                {\n                                    prunnedLeafBlocks.Remove(b);\n                                }\n                            }\n\n                            break;\n\n                        case EdgeKind.HighestScore:\n                        case EdgeKind.Choice:\n                        case EdgeKind.Random:\n                            prunnedLeafBlocks.Remove(b);\n                            break;\n                    }\n                }\n\n                leafBlocks = prunnedLeafBlocks;\n            }\n\n            return (topParent, leafBlocks.ToArray());\n        }\n", "        private int GetConditionalBlock(int block)\n        {\n            if (Blocks[block].PlayUntil != -1)\n            {\n                return block;\n            }\n\n            if (Blocks[block].Requirements.Count != 0)\n            {\n                return block;\n            }\n", "            if (ParentOf[block].Contains(0))\n            {\n                // This is tied to the root and the block can play forever.\n                return -1;\n            }\n\n            int result = -1;\n            foreach (int parent in ParentOf[block])\n            {\n                result = GetConditionalBlock(parent);\n                if (result == -1)\n                {\n                    break;\n                }\n            }\n\n            return result;\n        }\n\n        /// <summary>\n        /// Creates a new block and assign an id to it.\n        /// </summary>", "                if (result == -1)\n                {\n                    break;\n                }\n            }\n\n            return result;\n        }\n\n        /// <summary>\n        /// Creates a new block and assign an id to it.\n        /// </summary>", "        private Block CreateBlock(int playUntil, bool track)\n        {\n            int id = Blocks.Count;\n            Block block = new(id, playUntil);\n\n            Blocks.Add(block);\n\n            if (track)\n            {\n                _lastBlocks.Push(id);\n            }\n\n            ParentOf[id] = new();\n\n            return block;\n        }\n", "        private Edge CreateEdge(EdgeKind kind)\n        {\n            Edge relationship = new(kind);\n\n            return relationship;\n        }\n\n        private void AssignOwnerToEdge(int id, Edge edge)\n        {\n            Edges.Add(id, edge);\n            edge.Owner = id;\n\n            // Track parents.", "            foreach (int block in edge.Blocks)\n            {\n                ParentOf[block].Add(id);\n            }\n        }\n\n        private void AddNode(Edge edge, int id)\n        {\n            edge.Blocks.Add(id);\n\n            if (edge.Owner != -1)\n            {\n                ParentOf[id].Add(edge.Owner);\n            }\n        }\n\n        /// <summary>\n        /// Given C and D:\n        /// Before:\n        ///    A      D\n        ///   / \\\n        ///  B   C \n        ///  \n        ///    D\n        /// After:\n        ///    A      C\n        ///   / \\\n        ///  B   D \n        /// This assumes that <paramref name=\"other\"/> is an orphan.\n        /// <paramref name=\"id\"/> will be orphan after this.\n        /// </summary>", "            if (edge.Owner != -1)\n            {\n                ParentOf[id].Add(edge.Owner);\n            }\n        }\n\n        /// <summary>\n        /// Given C and D:\n        /// Before:\n        ///    A      D\n        ///   / \\\n        ///  B   C \n        ///  \n        ///    D\n        /// After:\n        ///    A      C\n        ///   / \\\n        ///  B   D \n        /// This assumes that <paramref name=\"other\"/> is an orphan.\n        /// <paramref name=\"id\"/> will be orphan after this.\n        /// </summary>", "        private void ReplaceEdgesToNodeWith(int id, int other)\n        {\n            if (Root == id)\n            {\n                Root = other;\n            }\n\n            foreach (int parent in ParentOf[id])\n            {\n                // Manually tell each parent that the child has stopped existing.\n                int position = Edges[parent].Blocks.IndexOf(id);\n                Edges[parent].Blocks[position] = other;\n\n                ParentOf[other].Add(parent);\n            }\n\n            ParentOf[id].Clear();\n        }\n", "        private bool IsParentOf(int parentNode, int childNode)\n        {\n            if (ParentOf[childNode].Count == 0)\n            {\n                return false;\n            }\n\n            if (ParentOf[childNode].Contains(parentNode))\n            {\n                return true;\n            }\n", "            foreach (int otherParent in ParentOf[childNode])\n            {\n                if (IsParentOf(parentNode, otherParent))\n                {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n", "        public void PopLastBlock()\n        {\n            if (_lastBlocks.Count > 1)\n            {\n                _ = _lastBlocks.Pop();\n            }\n        }\n\n        private Edge LastEdge => Edges[_lastBlocks.Peek()];\n\n        private readonly HashSet<int> _blocksWithGoto = new();\n", "        private Edge LastEdge => Edges[_lastBlocks.Peek()];\n\n        private readonly HashSet<int> _blocksWithGoto = new();\n\n        public void MarkGotoOnBlock(int block, bool isExit)\n        {\n            if (isExit)\n            {\n                Blocks[block].Exit();\n            }\n\n            _ = _blocksWithGoto.Add(block);\n        }\n    }\n}\n"]}
{"filename": "src/Gum/InnerThoughts/Edge.cs", "chunked_list": ["\ufeffusing System;\nusing System.Diagnostics;\nusing System.Text;\n\nnamespace Gum.InnerThoughts\n{\n    /// <summary>\n    /// This class has a list of blocks and the respective directions this dialog can take from here.\n    /// The relationship kind is how it will pick the next candidate.\n    /// </summary>\n    [DebuggerDisplay(\"{DebuggerDisplay(),nq}\")]", "    public class Edge\n    {\n        public EdgeKind Kind = EdgeKind.Next;\n\n        /// <summary>\n        /// Node that owns this edge. This is a 1 <-> 1 relationship.\n        /// </summary>\n        public int Owner = -1;\n\n        /// <summary>\n        /// Blocks, in order, which will be subjected to a scan according to <see cref=\"Kind\"/>.\n        /// </summary>", "        public readonly List<int> Blocks = new();\n\n        public Edge() { }\n\n        public Edge(EdgeKind kind) => Kind = kind;\n\n        public string DebuggerDisplay()\n        {\n            StringBuilder result = new();\n\n            result = result.Append(\n                $\"[{Kind}, Blocks = {{\");\n\n            bool isFirst = true;", "            foreach (int i in Blocks)\n            {\n                if (!isFirst)\n                {\n                    result = result.Append(\", \");\n                }\n                else\n                {\n                    isFirst = false;\n                }\n\n                result = result.Append($\"{i}\");\n            }\n\n            result = result.Append($\"}}]\");\n\n            return result.ToString();\n        }\n    }\n}\n"]}
{"filename": "src/Gum/InnerThoughts/CriterionNode.cs", "chunked_list": ["\ufeffusing System.Diagnostics;\nusing Gum.Utilities;\n\nnamespace Gum.InnerThoughts\n{\n    [DebuggerDisplay(\"{DebuggerDisplay(),nq}\")]\n    public readonly struct CriterionNode\n    {\n        public readonly Criterion Criterion = new();\n        public readonly CriterionNodeKind Kind = CriterionNodeKind.And;\n\n        public CriterionNode() { }\n\n        public CriterionNode(Criterion criterion) =>\n            Criterion = criterion;\n\n        public CriterionNode(Criterion criterion, CriterionNodeKind kind) =>\n            (Criterion, Kind) = (criterion, kind);\n", "        public readonly Criterion Criterion = new();\n        public readonly CriterionNodeKind Kind = CriterionNodeKind.And;\n\n        public CriterionNode() { }\n\n        public CriterionNode(Criterion criterion) =>\n            Criterion = criterion;\n\n        public CriterionNode(Criterion criterion, CriterionNodeKind kind) =>\n            (Criterion, Kind) = (criterion, kind);\n", "        public CriterionNode WithCriterion(Criterion criterion) => new(criterion, Kind);\n\n        public CriterionNode WithKind(CriterionNodeKind kind) => new(Criterion, kind);\n\n        public string DebuggerDisplay()\n        {\n            return $\"{OutputHelpers.ToCustomString(Kind)} {Criterion.DebuggerDisplay()}\";\n        }\n    }\n}\n"]}
{"filename": "src/Gum/InnerThoughts/EdgeKind.cs", "chunked_list": ["\ufeffnamespace Gum.InnerThoughts\n{\n    public enum EdgeKind\n    {\n        /// <summary>\n        /// This will pick in consecutive order, whatever matches first.\n        /// </summary>\n        Next = 1,\n\n        /// <summary>\n        /// This will pick random dialogs.\n        /// </summary>\n        Random = 2,\n\n        /// <summary>\n        /// This will pick the dialog with the highest score.\n        /// This is when dialogs are listed with -/+.\n        /// </summary>\n        HighestScore = 3,\n\n        /// <summary>\n        /// All the blocks that are next are subjected to an \"else\" relationship.\n        /// </summary>\n        IfElse = 4,\n\n        /// <summary>\n        /// Choice dialogs (>) that the player can pick.\n        /// </summary>\n        Choice = 5\n    }\n}\n"]}
{"filename": "src/Gum/InnerThoughts/Portrait.cs", "chunked_list": ["\ufeffnamespace Gum.InnerThoughts\n{\n    internal readonly struct Portrait\n    {\n        public readonly string AnimationId;\n\n        public Portrait(string animationId) =>\n            AnimationId = animationId;\n    }\n}\n"]}
{"filename": "src/Gum/InnerThoughts/DialogAction.cs", "chunked_list": ["\ufeffusing System.Diagnostics;\nusing System.Text;\nusing Gum.Blackboards;\nusing Gum.Utilities;\n\nnamespace Gum.InnerThoughts\n{\n    [DebuggerDisplay(\"{DebuggerDisplay(),nq}\")]\n    public class DialogAction\n    {\n        public readonly Fact Fact = new();\n", "    public class DialogAction\n    {\n        public readonly Fact Fact = new();\n\n        public readonly BlackboardActionKind Kind = BlackboardActionKind.Set;\n\n        public readonly string? StrValue = null;\n\n        public readonly int? IntValue = null;\n\n        public readonly bool? BoolValue = null;\n", "        public readonly int? IntValue = null;\n\n        public readonly bool? BoolValue = null;\n\n        public readonly string? ComponentValue = null;\n\n        public DialogAction() { }\n\n        public DialogAction(Fact fact, BlackboardActionKind kind, object value)\n        {\n            bool? @bool = null;\n            int? @int = null;\n            string? @string = null;\n\n            string? component = null;\n\n            // Do not propagate previous values.\n            switch (fact.Kind)\n            {\n                case FactKind.Bool:\n                    @bool = (bool)value;\n                    break;\n\n                case FactKind.Int:\n                    @int = (int)value;\n                    break;\n\n                case FactKind.String:\n                    @string = (string)value;\n                    break;\n\n                case FactKind.Component:\n                    component = (string)value;\n                    break;\n            }\n\n            (Fact, Kind, StrValue, IntValue, BoolValue, ComponentValue) = (fact, kind, @string, @int, @bool, component);\n        }\n", "        public string DebuggerDisplay()\n        {\n            StringBuilder result = new();\n\n            if (Fact.Kind == FactKind.Component)\n            {\n                result = result.Append($\"[c:\");\n            }\n            else\n            {\n                result = result.Append($\"[{Fact.Name} {OutputHelpers.ToCustomString(Kind)} \");\n            }\n\n            switch (Fact.Kind)\n            {\n                case FactKind.Bool:\n                    result = result.Append(BoolValue);\n                    break;\n\n                case FactKind.Int:\n                    result = result.Append(IntValue);\n                    break;\n\n                case FactKind.String:\n                    result = result.Append(StrValue);\n                    break;\n\n                case FactKind.Component:\n                    result = result.Append(ComponentValue);\n                    break;\n            }\n\n            result = result.Append(']');\n\n            return result.ToString();\n        }\n    }\n}\n"]}
{"filename": "src/Gum/InnerThoughts/Criterion.cs", "chunked_list": ["\ufeffusing System.Text;\nusing System.Diagnostics;\nusing Gum.Utilities;\n\nnamespace Gum.InnerThoughts\n{\n    [DebuggerDisplay(\"{DebuggerDisplay(),nq}\")]\n    public readonly struct Criterion\n    {\n        public readonly Fact Fact = new();\n", "        public readonly Fact Fact = new();\n\n        public readonly CriterionKind Kind = CriterionKind.Is;\n\n        public readonly string? StrValue = null;\n\n        public readonly int? IntValue = null;\n\n        public readonly bool? BoolValue = null;\n\n        public Criterion() { }\n\n        /// <summary>\n        /// Creates a fact of type <see cref=\"FactKind.Weight\"/>.\n        /// </summary>", "        public readonly bool? BoolValue = null;\n\n        public Criterion() { }\n\n        /// <summary>\n        /// Creates a fact of type <see cref=\"FactKind.Weight\"/>.\n        /// </summary>\n        public static Criterion Weight => new(Fact.Weight, CriterionKind.Is, 1);\n\n        /// <summary>\n        /// Creates a fact of type <see cref=\"FactKind.Component\"/>.\n        /// </summary>", "        public static Criterion Component => new(Fact.Component, CriterionKind.Is, true);\n\n        public Criterion(Fact fact, CriterionKind kind, object @value)\n        {\n            bool? @bool = null;\n            int? @int = null;\n            string? @string = null;\n\n            // Do not propagate previous values.\n            switch (fact.Kind)\n            {\n                case FactKind.Bool:\n                    @bool = (bool)@value;\n                    break;\n\n                case FactKind.Int:\n                    @int = (int)@value;\n                    break;\n\n                case FactKind.String:\n                    @string = (string)@value;\n                    break;\n\n                case FactKind.Weight:\n                    @int = (int)@value;\n                    break;\n            }\n\n            (Fact, Kind, StrValue, IntValue, BoolValue) = (fact, kind, @string, @int, @bool);\n        }\n", "        public string DebuggerDisplay()\n        {\n            StringBuilder result = new();\n\n            if (Fact.Kind == FactKind.Component)\n            {\n                result = result.Append($\"[c:\");\n            }\n            else\n            {\n                result = result.Append($\"[{Fact.Name} {OutputHelpers.ToCustomString(Kind)} \");\n            }\n\n            switch (Fact.Kind)\n            {\n                case FactKind.Bool:\n                    result = result.Append(BoolValue);\n                    break;\n\n                case FactKind.Int:\n                    result = result.Append(IntValue);\n                    break;\n\n                case FactKind.String:\n                    result = result.Append(StrValue);\n                    break;\n\n                case FactKind.Weight:\n                    result = result.Append(IntValue);\n                    break;\n            }\n\n            _ = result.Append(']');\n\n            return result.ToString();\n        }\n    }\n}\n"]}
{"filename": "src/Gum/InnerThoughts/CriterionKind.cs", "chunked_list": ["\ufeffusing Gum.Attributes;\n\nnamespace Gum.InnerThoughts\n{\n    public enum CriterionKind\n    {\n        [TokenName(\"is\")]\n        Is,             // Boolean, integer or string comparison\n        [TokenName(\"<\")]\n        Less,           // Integer comparison\n        [TokenName(\"<=\")]\n        LessOrEqual,    // Integer comparison\n        [TokenName(\">\")]\n        Bigger,         // Integer comparison\n        [TokenName(\">=\")]\n        BiggerOrEqual,  // Integer comparison\n        [TokenName(\"!=\")]\n        Different       // Boolean, integer or string comparison\n    }\n}\n"]}
{"filename": "src/Gum/InnerThoughts/Block.cs", "chunked_list": ["\ufeffusing System;\nusing System.Diagnostics;\nusing System.Text;\n\nnamespace Gum.InnerThoughts\n{\n    [DebuggerDisplay(\"{DebuggerDisplay(),nq}\")]\n    public class Block\n    {\n        public readonly int Id = 0;\n\n        /// <summary>\n        /// Stop playing this dialog until this number.\n        /// If -1, this will play forever.\n        /// </summary>", "        public readonly int Id = 0;\n\n        /// <summary>\n        /// Stop playing this dialog until this number.\n        /// If -1, this will play forever.\n        /// </summary>\n        public int PlayUntil = -1;\n\n        public readonly List<CriterionNode> Requirements = new();\n\n        public readonly List<Line> Lines = new();\n\n        public List<DialogAction>? Actions = null;\n\n        /// <summary>\n        /// Go to another dialog with a specified id.\n        /// If this is -1, it will immediately exit the dialog interaction.\n        /// </summary>\n        public int? GoTo = null;\n", "        public readonly List<CriterionNode> Requirements = new();\n\n        public readonly List<Line> Lines = new();\n\n        public List<DialogAction>? Actions = null;\n\n        /// <summary>\n        /// Go to another dialog with a specified id.\n        /// If this is -1, it will immediately exit the dialog interaction.\n        /// </summary>\n        public int? GoTo = null;\n", "        public bool NonLinearNode = false;\n\n        public bool IsChoice = false;\n\n        public bool Conditional = false;\n\n        public Block() { }\n\n        public Block(int id) { Id = id; }\n\n        public Block(int id, int playUntil) { (Id, PlayUntil) = (id, playUntil); }\n", "        public void AddLine(string? speaker, string? portrait, string text)\n        {\n            Lines.Add(new(speaker, portrait, text));\n        }\n\n        public void AddRequirement(CriterionNode node)\n        {\n            Requirements.Add(node);\n        }\n\n        public void AddAction(DialogAction action)\n        {\n            Actions ??= new();\n            Actions.Add(action);\n        }\n", "        public void AddAction(DialogAction action)\n        {\n            Actions ??= new();\n            Actions.Add(action);\n        }\n\n        public void Exit()\n        {\n            GoTo = -1;\n        }\n", "        public string DebuggerDisplay()\n        {\n            StringBuilder result = new();\n            _ = result.Append(\n                $\"[{Id}, Requirements = {Requirements.Count}, Lines = {Lines.Count}, Actions = {Actions?.Count ?? 0}]\");\n\n            return result.ToString();\n        }\n    }\n}\n"]}
{"filename": "src/Gum.Tests/Bungee.cs", "chunked_list": ["using Gum.InnerThoughts;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing Newtonsoft.Json;\nusing System.Text.RegularExpressions;\n\nnamespace Gum.Tests\n{\n    [TestClass]\n    public class Bungee\n    {\n        private CharacterScript? Read(string input)\n        {\n            string[] lines = Regex.Split(input, @\"\\r?\\n|\\r\");\n            Parser parser = new(\"Test\", lines);\n\n            return parser.Start();\n        }\n\n        [TestMethod]", "    public class Bungee\n    {\n        private CharacterScript? Read(string input)\n        {\n            string[] lines = Regex.Split(input, @\"\\r?\\n|\\r\");\n            Parser parser = new(\"Test\", lines);\n\n            return parser.Start();\n        }\n\n        [TestMethod]", "        public void TestSerialization()\n        {\n            const string path = \"./resources\";\n\n            CharacterScript[] results = Reader.Parse(path, lastModified: null, out string errors);\n\n            Assert.IsTrue(string.IsNullOrEmpty(errors));\n            Assert.AreEqual(1, results.Length);\n\n            IEnumerable<Situation> situations = results[0].FetchAllSituations();\n            Assert.AreEqual(3, situations.Count());\n        }\n\n        [TestMethod]", "        public void TestDeserialization()\n        {\n            const string path = \"./resources\";\n\n            CharacterScript[] results = Reader.Parse(path, lastModified: null, out string errors);\n\n            Assert.IsTrue(string.IsNullOrEmpty(errors));\n            Assert.AreEqual(1, results.Length);\n\n            CharacterScript script = results[0];\n            string json = JsonConvert.SerializeObject(script, Reader.Settings);\n\n            CharacterScript? deserializedScript = JsonConvert.DeserializeObject<CharacterScript>(json);\n\n            Assert.IsNotNull(deserializedScript);\n\n            IEnumerable<Situation> situations = deserializedScript.FetchAllSituations();\n            Assert.AreEqual(3, situations.Count());\n        }\n\n        [TestMethod]", "        public void TestSingleSentence()\n        {\n            const string situationText = @\"\n=Encounter\n    I just have one sentence.\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(target.Owner, 0);\n            CollectionAssert.AreEqual(new int[] { 1 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestSingleCondition()\n        {\n            const string situationText = @\"\n=Encounter\n    (!HasSeenThis)\n        Wow! Have you seen this?\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Block block = situation.Blocks[1];\n\n            Assert.AreEqual(1, block.Requirements.Count);\n            Assert.AreEqual(CriterionNodeKind.And, block.Requirements[0].Kind);\n            Assert.AreEqual(CriterionKind.Different, block.Requirements[0].Criterion.Kind);\n            Assert.AreEqual(true, block.Requirements[0].Criterion.BoolValue);\n        }\n\n        [TestMethod]", "        public void TestSingleSentenceWithSpeaker()\n        {\n            const string situationText = @\"\n=Encounter\n    speaker.happy: I just have one sentence.\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(target.Owner, 0);\n            CollectionAssert.AreEqual(new int[] { 1 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestSimpleIf()\n        {\n            const string situationText = @\"\n=Encounter\n    (LikeFishes)\n        Wow, I love fishes!\n\n    (...)\n        Ugh, I hate fishes.\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 2 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestOrderChoice()\n        {\n            const string situationText = @\"\n=Encounter\n    @order\n        - Hello\n        + Bye!\n\n    -> exit!\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.HighestScore, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 2 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestChoicesWithRules()\n        {\n            const string situationText = @\"\n=Encounter\n    - (HasIceCream)\n        This seems a pretty good ice cream.\n    - (!HasIceCream)\n        What do you have there??\n    - (WithoutCoins and HasIceCream)\n        Maybe you want to sell that ice cream of yours?\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.HighestScore, target.Kind);\n            Assert.AreEqual(target.Owner, 0);\n            CollectionAssert.AreEqual(new int[] { 1, 2, 3 }, target.Blocks);\n\n            Block block = situation.Blocks[1];\n            Assert.AreEqual(1, block.Requirements.Count);\n            Assert.AreEqual(1, block.Lines.Count);\n\n            block = situation.Blocks[2];\n            Assert.AreEqual(1, block.Requirements.Count);\n            Assert.AreEqual(1, block.Lines.Count);\n\n            block = situation.Blocks[3];\n            Assert.AreEqual(2, block.Requirements.Count);\n            Assert.AreEqual(1, block.Lines.Count);\n        }\n\n        [TestMethod]", "        public void TestLineAfterChoice()\n        {\n            const string situationText = @\"\n=Dinner\n    (Socks >= 5)\n        Do you hate socks!\n\n        >> Hate socks?\n        > Hell yeah!\n            -> exit!\n        > Why would I?\n            -> exit!\n\n    Okay, bye!\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 7 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            // Uhhh this block 7 shouldn't really be here, but I am okay with\n            // this compromise.\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3, 5 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4 }, target.Blocks);\n\n            target = situation.Edges[5];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(5, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestOptionsWithChoices()\n        {\n            const string situationText = @\"\n=Choice\n    +   >> Settle down for a while?\n        > Rest my eyes...\n            [c:SaveCheckpointInteraction]\n        > Keep going.\n\n    +   >> Do you want it all to be all right?\n        > Just for a while.\n            [c:SaveCheckpointInteraction]\n        > Not now.\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.HighestScore, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 6 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3, 5 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4 }, target.Blocks);\n\n            target = situation.Edges[6];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(6, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 7 }, target.Blocks);\n\n            target = situation.Edges[7];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(7, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 8, 10 }, target.Blocks);\n\n            target = situation.Edges[8];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(8, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 9 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestLineAfterChoiceWithoutLeaves()\n        {\n            const string situationText = @\"\n=Dinner\n    (Socks >= 5)\n        Do you hate socks!\n\n        >> Hate socks?\n        > Hell yeah!\n            Okay.\n        > Why would I?\n            Yeah??\n\n    Okay, bye!\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 7 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3, 5 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4 }, target.Blocks);\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 7 }, target.Blocks);\n\n            target = situation.Edges[5];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(5, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6 }, target.Blocks);\n\n            target = situation.Edges[6];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(6, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 7 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestChoiceWithAction()\n        {\n            const string situationText = @\"\n=Dinner\n    >> Hate socks?\n    > Hell yeah!\n        [FireOnSocks=true]\n    > Why would I?\n        [c:GoAwayInteraction]\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2, 4 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3 }, target.Blocks);\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestChoiceWithNestedBlock()\n        {\n            const string situationText = @\"\n=Dinner\n    >> Hate socks?\n    > Hell yeah!\n        (LookForFire)\n            Yes...?\n    > Why would I?\n        No!\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2, 4 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3 }, target.Blocks);\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestElseAfterChoice()\n        {\n            const string situationText = @\"\n=Dinner\n    (Socks >= 5)\n        Do you hate socks!\n\n        >> Hate socks?\n        > Hell yeah!\n            -> DestroyAll\n        > Why would I?\n            -> Sorry\n\n    (...Socks > 1 and Socks < 5)\n        thief: What about socks that you hate?\n        Everything!!!!\n\n    (...)\n        -   thief: Actually, some shoes are okay.\n            Ew.\n\n        -   thief: Can you not look at me?\n            What if I do.\n\n        +   Happy birthday! I bought you socks.\n\n= DestroyAll\n\n= Sorry\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 7, 8 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3, 5 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4 }, target.Blocks);\n\n            target = situation.Edges[5];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(5, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6 }, target.Blocks);\n\n            target = situation.Edges[8];\n\n            Assert.AreEqual(EdgeKind.HighestScore, target.Kind);\n            Assert.AreEqual(8, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 9, 10, 11 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestChoices()\n        {\n            const string situationText = @\"\n=Chitchat\n    -   You are amazing.\n        FOR A COOKER.\n    -   I'm sorry. I was rude there.\n        I needed to come up with stuff.\n        I actually did enjoy your food.\n    +   ...\n    -   The dead fly was on purpose, right?\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.HighestScore, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 2, 3, 4 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestChoicesWithCondition()\n        {\n            const string situationText = @\"\n=Choices\n    -   (!Eaten)\n            I am FULL.\n    -   (!Eaten)\n            I am soooooo stuffed.\n    -   (Hungry)\n            DUDE I am hungry.\n            [Eat=true]\n\n=Bye\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.HighestScore, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 2, 3 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestNestedCondition1()\n        {\n            const string situationText = @\"\n=Encounter\n    @1  (!SawMe)\n            Do you see anything?\n            Of course not.\n\n            [Variable=true]\n\n            -> exit!\n\n        (...)\n            Okay you see me.\n            I'm sorry.\n            thief: For what?\n            thief: I am simply existing here.\n\n            -> Bye\n\n    @1  (LookedAtLeft)\n            -> Hey!?\n\n    (!GotSword)\n        (!Scared)\n            What do you want?\n    \n        (...)\n            @1  Please, stop.\n                thief: Or what?\n\n                -> Bye\n\n    (...)\n        -> Bye\n\n=Bye\n=Hey!?\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Assert.AreEqual(situation.Root, 0);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 4, 11 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2, 3 }, target.Blocks);\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5 }, target.Blocks);\n\n            target = situation.Edges[6];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(6, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 7, 8 }, target.Blocks);\n\n            target = situation.Edges[8];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(8, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 9 }, target.Blocks);\n\n            target = situation.Edges[11];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(11, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6, 10 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestNestedCondition2()\n        {\n            const string situationText = @\"\n=Welcome\n    @1  1!\n        2\n\n        (Three)\n            4\n            5\n\n            -> Bye\n\n        (...)\n            6\n            7\n        \n        [Condition=true]\n        [c:Interaction]\n\n        -> exit!\n\n    (!Eight)\n        9\n        10 {i:Variable}!\n\n        -> Bye\n    \n    (...!Eleven)\n        (Twelve)\n            @random\n                + 13\n                + 14\n\n        (...)\n            @random\n                + 15\n                ...\n                16\n                + 17\n\n        -> exit!\n\n    -> Bye\n\n=Bye\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Assert.AreEqual(situation.Name, \"Welcome\");\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 16 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2, 3 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4 }, target.Blocks);\n\n            target = situation.Edges[6];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(6, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 8, 11 }, target.Blocks);\n\n            target = situation.Edges[7];\n\n            Assert.AreEqual(target.Kind, EdgeKind.IfElse);\n            Assert.AreEqual(target.Owner, 7);\n            CollectionAssert.AreEqual(new int[] { 5, 6 }, target.Blocks);\n\n            target = situation.Edges[8];\n\n            Assert.AreEqual(EdgeKind.Random, target.Kind);\n            Assert.AreEqual(8, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 9, 10 }, target.Blocks);\n\n            target = situation.Edges[9];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(9, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 14 }, target.Blocks);\n\n            target = situation.Edges[10];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(10, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 14 }, target.Blocks);\n\n            target = situation.Edges[11];\n\n            Assert.AreEqual(EdgeKind.Random, target.Kind);\n            Assert.AreEqual(11, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 12, 13 }, target.Blocks);\n\n            target = situation.Edges[12];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(12, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 14 }, target.Blocks);\n\n            target = situation.Edges[13];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(13, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 14 }, target.Blocks);\n\n            target = situation.Edges[16];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(16, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 7, 15 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestNestedCondition3()\n        {\n            const string situationText = @\"\n=Encounter\n    @1  (!SawMe)\n            Do you see anything?\n            Of course not.\n\n            [Variable=true]\n        (...)\n            Okay you see me.\n            I'm sorry.\n            thief: For what?\n            thief: I am simply existing here.\n\n    Bye.\n\n=Bye\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 4 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2, 3 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestNestedCondition4()\n        {\n            const string situationText = @\"\n=Encounter\n    @1  (!SawMe)\n            Do you see anything?\n            Of course not.\n\n            [Variable=true]\n\n        (...)\n            Okay you see me.\n            I'm sorry.\n            thief: For what?\n            thief: I am simply existing here.\n\n        I guess?\n\n    Bye.\n\n=Bye\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 5 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2, 3 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4 }, target.Blocks);\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestNestedCondition5()\n        {\n            const string situationText = @\"\n=Encounter\n    @1  \n        Hello.\n        I do talk a lot.\n        \\(you might have noticed?\\)\n        SO. As I was saying-\n        thief: What?\n        Nevermind.\n\n    (Defeated)\n        WOW!! You did it!\n        -> exit!\n\n    // this will think that it's joining with the one above ^\n    @1  \n        Can you go now?\n\n        (!CanMove)\n            thief: I would. If I wasn't STUCK.\n            Wow wow wow! Hold on!\n            What do you mean STUCK?\n            thief: Stuck!\n            Okay.\n\n        (...)\n            thief.happy: Yes.\n            So go!\n            Maybe I will!\n            Okay.\n            Okay.\n\n            [Left=true]\n            -> exit!\n\n    @1  (Left and StillHere)\n            thief.happy: Uhhhhhhhhhhhh\n\n            -> exit!\n\n    -> Random\n\n=Random\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 2, 3, 6, 8 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4, 5 }, target.Blocks);\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestNestedCondition6()\n        {\n            const string situationText = @\"\n=Encounter\n    @1  (Defeated)\n            Okay. I am here now.\n            Right?\n\n            [c:DoSomething]\n        \n        (...)\n            Oh my. Congratulations.\n\n            (WonInThePast)\n                I don't care though.\n            (...)\n                I am super jealous.\n\n            I hope you like the taste of victory.\n    \n    -> Random\n\n=Random\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 7 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2, 3 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 7 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4, 5 }, target.Blocks);\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6 }, target.Blocks);\n\n            target = situation.Edges[5];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(5, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6 }, target.Blocks);\n\n            target = situation.Edges[6];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(6, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 7 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestNestedCondition7()\n        {\n            const string situationText = @\"\n=Encounter\n    (Meet and PreviouslySaidBye)\n        @1  Hi! But only once.\n\n            -> exit!\n\n        (DatesTogether >= 1)\n            I guess this is really like meeting again...?\n\n    (...!StillHasJob)\n        (ChocolateAmount == 0)\n            @1  Out of chocolates?\n                Again...?\n\n        (...ChocolateAmount >= 1)\n            - I mean, chocolates are great!\n\n            - Until they aren't.\n    (...)\n        @1  I am embarassed.\n            Bye.\n\n=Random\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 4, 10 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2, 3 }, target.Blocks);\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5, 7 }, target.Blocks);\n\n            target = situation.Edges[5];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(5, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6 }, target.Blocks);\n\n            target = situation.Edges[7];\n\n            Assert.AreEqual(EdgeKind.HighestScore, target.Kind);\n            Assert.AreEqual(7, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 8, 9 }, target.Blocks);\n\n            target = situation.Edges[10];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(10, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 11 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestNestedCondition8()\n        {\n            const string situationText = @\"\n=Encounter\n    (!Meet and !Greet) \n        @order\n            -   I will go now.\n            +   Hello!?\n\n        -> exit!\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            // This edge currently has an extra edge to 4.\n            // This technically doesn't make sense because 1 will always be chosen.\n            // I *think* we could do some fancy inference around leaves? But for now,\n            // I will leave it like this.\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 4 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.HighestScore, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2, 3 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestNestedCondition9()\n        {\n            const string situationText = @\"\n=MapThree\n    -   mushroom: ...\n        He says hi.\n\n    -   (!UnlockedBoatTravel)\n            You seem more lost than usual.\n\n        (TalkedWithBoatman)\n            You met the boatman, haven't you?\n            He must know a way to get where you want.\n\n        (...)\n            You can try searching for the boatman. He knows his way around here.\n            I was told he is somewhere in the glimmering forest.\n    \n    -   I used to be very upset about the farmlands.\n        I did not like it here. The smell. The endlessness.\n        The overbearing wall.\n        I came to accept it, eventually.\n        And it became easier.\n\n    -> Choice\n\n=Choice\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.HighestScore, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 2, 5 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3, 4 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6 }, target.Blocks);\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6 }, target.Blocks);\n\n            target = situation.Edges[5];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(5, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6 }, target.Blocks);\n        }\n\n\n        [TestMethod]", "        public void TestLinearOneBlocks()\n        {\n            const string situationText = @\"\n=CreateVillage\n    @1  -> ChooseName\n\n    @1  Seriously? You are not living in a place called {VillageName}.\n        Choose an actual name now:\n        -> exit!\n\n    @1  (HasChosenSameName)\n            Okay, I guess {VillageName} is what YOU really want.\n        \n    Move to {VilageName}?\n\n    >> Ready?\n    > Yes.\n        -> ChooseName\n    > No.\n        -> ChooseName\n\n=ChooseName\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 2, 3, 5 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4 }, target.Blocks);\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5 }, target.Blocks);\n\n            target = situation.Edges[5];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(5, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6 }, target.Blocks);\n\n            target = situation.Edges[6];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(6, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 7, 9 }, target.Blocks);\n\n            target = situation.Edges[7];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(7, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 8 }, target.Blocks);\n\n            target = situation.Edges[9];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(9, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 10 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestConditionWithOneJoin()\n        {\n            const string situationText = @\"\n=Encounter\n    (Something)\n        @1  Hello!\n\n    (...Something2)\n        @1  Hello once?\n\n    Bye!\n\n=ChooseName\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Assert.AreEqual(6, situation.Root);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 3 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2 }, target.Blocks);\n\n            Assert.AreEqual(1, situation.Blocks[2].PlayUntil); // @1\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4 }, target.Blocks);\n\n            Assert.AreEqual(1, situation.Blocks[4].PlayUntil); // @1\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5 }, target.Blocks);\n\n            target = situation.Edges[6];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(6, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 0, 5 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestConditionWithTwoLinesJoin()\n        {\n            const string situationText = @\"\n=Encounter\n    (Something)\n        @1  Hello!\n            ok...\n\n    (...Something2)\n        @1  Hello once?\n\n    Bye!\n\n=ChooseName\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Assert.AreEqual(6, situation.Root);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 3 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2 }, target.Blocks);\n\n            Assert.AreEqual(1, situation.Blocks[2].PlayUntil); // @1\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4 }, target.Blocks);\n\n            Assert.AreEqual(1, situation.Blocks[4].PlayUntil); // @1\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5 }, target.Blocks);\n\n            target = situation.Edges[6];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(6, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 0, 5 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestConditionWithOneIfElseJoin()\n        {\n            const string situationText = @\"\n=Encounter\n    @1  (Something)\n            Hello!\n\n        (...Something2)\n            Hello once?\n\n    Bye!\n\n=ChooseName\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Assert.AreEqual(0, situation.Root);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 5 }, target.Blocks);\n\n            Assert.AreEqual(1, situation.Blocks[1].PlayUntil); // @1\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2, 3, 4 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5 }, target.Blocks);\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestConditionWithQuestion()\n        {\n            const string situationText = @\"\n=Encounter\n    (TriedPickName > 3)\n        >> Do you really think a name will stop you from running away?\n        > Yes.\n            -> ChooseName\n        > No.\n            -> Encounter\n\n=ChooseName\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Assert.AreEqual(0, situation.Root);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3, 5 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4 }, target.Blocks);\n\n            target = situation.Edges[5];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(5, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestChoiceInsideIf()\n        {\n            const string situationText = @\"\n=Encounter\n    (SupposedlyHaveAJob)\n        Especially since you don't even have a job.\n\n        >> No job...\n        > All my paperwork is set, sir.\n        > I am very tired and I just want to go home.\n\n    Okay.\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Assert.AreEqual(0, situation.Root);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 5 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3, 4 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5 }, target.Blocks);\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestChoiceOutsideIf()\n        {\n            const string situationText = @\"\n=Encounter\n    (SupposedlyHaveAJob)\n        Especially since you don't even have a job.\n\n    >> No job...\n    > All my paperwork is set, sir.\n    > I am very tired and I just want to go home.\n\n    Okay.\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Assert.AreEqual(0, situation.Root);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1, 2 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4, 5 }, target.Blocks);\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6 }, target.Blocks);\n\n            target = situation.Edges[5];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(5, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestNestedChoice()\n        {\n            const string situationText = @\"\n=Encounter\n    >> No job...\n    > All my paperwork is set, sir.\n        >> Oh really?\n        > It was a lie!\n        > Yes...\n    > I am very tired and I just want to go home.\n\n    Okay.\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2, 6 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4, 5 }, target.Blocks);\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 7 }, target.Blocks);\n\n            target = situation.Edges[5];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(5, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 7 }, target.Blocks);\n\n            target = situation.Edges[6];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(6, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 7 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestNestedChoice2()\n        {\n            const string situationText = @\"\n=Encounter\n    >> No job...\n    > All my paperwork is set, sir.\n        >> Oh really?\n        > It was a lie!\n            Yeah?\n        > Yes...\n            No!\n    > I am very tired and I just want to go home.\n\n    Okay.\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2, 8 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4, 6 }, target.Blocks);\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5 }, target.Blocks);\n\n            target = situation.Edges[5];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(5, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 9 }, target.Blocks);\n\n            target = situation.Edges[6];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(6, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 7 }, target.Blocks);\n\n            target = situation.Edges[7];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(7, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 9 }, target.Blocks);\n\n            target = situation.Edges[8];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(8, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 9 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestOrderAfterIf()\n        {\n            const string situationText = @\"\n=Sold\n    (AmountSold > 0)\n        Here is a total of {AmountSold}C.\n        [AmountSold = 0]\n\n    + Have a wonderful day!\n    + Bye, bye!\n    + I hope you had fun!\n    + See you around!\n    + Thanks for passing by!\n\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.HighestScore, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3, 4, 5, 6, 7 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestImmediateEffects()\n        {\n            const string situationText = @\"\n=Encounter\n    Hi!\n    [c:SomeInteraction]\n    Now, I will say bye.\n    So bye!\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestChoicesWithIfElse()\n        {\n            const string situationText = @\"\n=Encounter\n    @1  (Day == 1)\n            Hi!\n        Hope you are okay.\n\n        (Cooked >= 1)\n            Anything new?\n            >> I guess.\n            > A\n                soma: You could say so.\n                Or...\n                Not!\n            > B\n                soma: You could say so.\n                But actually.\n                No, nevermind.\n                \\(At least that's what I keep telling myself\\)\n            > C\n                soma: You could say so.\n                Maybe? I guess?\n                I never thought too much about it.\n                [Happy += 5]\n                Or yes?\n        (...)\n            No.\n        \n        -> exit!\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2, 3 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4, 13 }, target.Blocks);\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5 }, target.Blocks);\n\n            target = situation.Edges[5];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(5, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6, 8, 10 }, target.Blocks);\n\n            target = situation.Edges[6];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(6, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 7 }, target.Blocks);\n\n            target = situation.Edges[7];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(7, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 14 }, target.Blocks);\n\n            target = situation.Edges[8];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(8, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 9 }, target.Blocks);\n\n            target = situation.Edges[9];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(9, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 14 }, target.Blocks);\n\n            target = situation.Edges[10];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(10, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 11 }, target.Blocks);\n\n            target = situation.Edges[11];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(11, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 12 }, target.Blocks);\n\n            target = situation.Edges[12];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(12, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 14 }, target.Blocks);\n\n            target = situation.Edges[13];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(13, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 14 }, target.Blocks);\n        }\n\n        [TestMethod]", "        public void TestChoicesWithIfElse2()\n        {\n            const string situationText = @\"\n=Encounter\n    @1  (Day == 1)\n            Hi!\n        Hope you are okay.\n\n        (Cooked >= 1)\n            Anything new?\n            >> I guess.\n            > A\n                soma: You could say so.\n                Or...\n                Not!\n            > B\n                soma: You could say so.\n                But actually.\n                No, nevermind.\n                \\(At least that's what I keep telling myself\\)\n            > C\n                soma: You could say so.\n                Maybe? I guess?\n                I never thought too much about it.\n                [Happy += 5]\n        (...)\n            No.\n        \n        -> exit!\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2, 3 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.IfElse, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4, 12 }, target.Blocks);\n\n            target = situation.Edges[4];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(4, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 5 }, target.Blocks);\n\n            target = situation.Edges[5];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(5, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6, 8, 10 }, target.Blocks);\n\n            target = situation.Edges[6];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(6, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 7 }, target.Blocks);\n\n            target = situation.Edges[7];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(7, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 13 }, target.Blocks);\n\n            target = situation.Edges[8];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(8, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 9 }, target.Blocks);\n\n            target = situation.Edges[9];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(9, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 13 }, target.Blocks);\n\n            target = situation.Edges[10];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(10, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 11 }, target.Blocks);\n\n            target = situation.Edges[11];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(11, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 13 }, target.Blocks);\n\n            target = situation.Edges[12];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(12, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 13 }, target.Blocks);\n        }\n\n\n        [TestMethod]", "        public void TestChoicesWithIfElse3()\n        {\n            const string situationText = @\"\n=Encounter\n    @1  A\n        B\n\n        >> Bla bla!\n        > He.\n            thief: No?\n            Okay.\n        > Ha!\n            thief: Yes.\n            Exactly!\n            [AccumulatedCharm += 2]\n            Do not do it.\n        > No.\n            thief: Stop!\n            Okay.\n\n            -> exit!\";\n\n            CharacterScript? script = Read(situationText);\n            Assert.IsTrue(script != null);\n\n            Situation? situation = script.FetchSituation(id: 0);\n            Assert.IsTrue(situation != null);\n\n            Edge target = situation.Edges[0];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(0, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 1 }, target.Blocks);\n\n            target = situation.Edges[1];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(1, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 2 }, target.Blocks);\n\n            target = situation.Edges[2];\n\n            Assert.AreEqual(EdgeKind.Choice, target.Kind);\n            Assert.AreEqual(2, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 3, 5, 8 }, target.Blocks);\n\n            target = situation.Edges[3];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(3, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 4 }, target.Blocks);\n\n            target = situation.Edges[5];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(5, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 6 }, target.Blocks);\n\n            target = situation.Edges[6];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(6, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 7 }, target.Blocks);\n\n            target = situation.Edges[8];\n\n            Assert.AreEqual(EdgeKind.Next, target.Kind);\n            Assert.AreEqual(8, target.Owner);\n            CollectionAssert.AreEqual(new int[] { 9 }, target.Blocks);\n        }\n    }\n}"]}
