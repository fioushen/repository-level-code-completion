{"filename": "src/OGXbdmDumper/MemoryRegion.cs", "chunked_list": ["\ufeffnamespace OGXbdmDumper\n{\n    public class MemoryRegion\n    {\n        public uint Address { get; }\n        public int Size { get; }\n\n        public MemoryRegion(uint address, int size)\n        { \n            Address = address;\n            Size = size;\n        }\n    }\n}\n"]}
{"filename": "src/OGXbdmDumper/SodmaSignature.cs", "chunked_list": ["\ufeffusing Serilog;\nusing System.Collections.Concurrent;\nusing System.Collections;\n\nnamespace OGXbdmDumper\n{\n    /// <summary>\n    /// Offset data mask pattern.\n    /// </summary>\n    public readonly struct OdmPattern\n    {\n        /// <summary>\n        /// The offset from the presumed function start upon match.\n        /// </summary>", "    /// </summary>\n    public readonly struct OdmPattern\n    {\n        /// <summary>\n        /// The offset from the presumed function start upon match.\n        /// </summary>\n        public readonly int Offset;\n\n        /// <summary>\n        ///The bitwise mask applied to the data when evaluating a match.\n        /// </summary>", "        public readonly ReadOnlyMemory<byte> Mask;\n\n        /// <summary>\n        /// The data to match.\n        /// </summary>\n        public readonly ReadOnlyMemory<byte> Data;\n\n        /// <summary>\n        /// Initializes a new offset data mask pattern.\n        /// </summary>\n        /// <param name=\"offset\">The offset from the presumed function start upon match. Negative offsets are allowed.</param>\n        /// <param name=\"data\">The data to match.</param>\n        /// <param name=\"mask\">The bitwise mask applied to the data when evaluating a match.</param>\n        public OdmPattern(int offset, ReadOnlyMemory<byte> data, ReadOnlyMemory<byte> mask)\n        {\n            Offset = offset;\n            Data = data;\n            Mask = mask;\n        }\n\n        /// <summary>\n        /// Initializes a new offset data mask pattern; assumes a mask of all 1's.\n        /// </summary>\n        /// <param name=\"offset\">The offset from the presumed function start upon match. Negative offsets are allowed.</param>\n        /// <param name=\"data\">The data to match.</param>\n        public OdmPattern(int offset, ReadOnlyMemory<byte> data) :\n            this(offset, data, Enumerable.Repeat(byte.MaxValue, data.Length).ToArray())\n        { }\n", "        public bool IsMatch(ReadOnlyMemory<byte> range, int offset)\n        {\n            // check if offset and data size are within range\n            if (offset - Offset < 0 || offset + Offset + Data.Length > range.Length)\n                return false;\n\n            // compare with the pattern data and return false upon encountering a non-match\n            ReadOnlySpan<byte> data = range.Span.Slice(offset + Offset, Data.Length);\n            for (int i = 0; i < data.Length; i++)\n            {\n                if ((data[i] & Mask.Span[i]) != Data.Span[i])\n                    return false;\n            }\n\n            return true;\n        }\n    }\n\n    /// <summary>\n    /// Simple offset data mask array signature containing a list of patterns.\n    /// </summary>", "            for (int i = 0; i < data.Length; i++)\n            {\n                if ((data[i] & Mask.Span[i]) != Data.Span[i])\n                    return false;\n            }\n\n            return true;\n        }\n    }\n\n    /// <summary>\n    /// Simple offset data mask array signature containing a list of patterns.\n    /// </summary>", "    public class SodmaSignature : IEnumerable<OdmPattern>\n    {\n        private readonly List<OdmPattern> _patterns;\n\n        /// <summary>\n        /// The name of the function the signature is attempting to identify.\n        /// </summary>\n        public string Name { get; private set; }\n\n        /// <summary>\n        /// The pattern data size.\n        /// </summary>", "        public int Size => _patterns.Sum(p => p.Data.Length);\n\n        /// <summary>\n        /// The pattern data range.\n        /// </summary>\n        public int Range => _patterns.Max(p => p.Offset + p.Data.Length) - _patterns.Min(p => p.Offset);\n\n        /// <summary>\n        /// Initializes a new simple offset mask data array signature.\n        /// </summary>\n        /// <param name=\"name\">The name of the function the signature is attempting to identify.</param>\n        public SodmaSignature(string name)\n        {\n            _patterns = new List<OdmPattern>();\n            Name = name;\n        }\n", "        public void Add(OdmPattern item)\n        {\n            // ensure mask and data are the same size\n            if (item.Data.Length != item.Mask.Length)\n                throw new NotSupportedException(\"Data and mask must be the same length\");\n\n            _patterns.Add(item);\n        }\n\n        public IEnumerator<OdmPattern> GetEnumerator()\n        {\n            return _patterns.GetEnumerator();\n        }\n\n        IEnumerator IEnumerable.GetEnumerator()\n        {\n            return GetEnumerator();\n        }\n", "        public bool IsMatch(ReadOnlyMemory<byte> range, int offset)\n        {\n            foreach (var pattern in _patterns)\n            {\n                if (!pattern.IsMatch(range, offset))\n                    return false;\n            }\n\n            return true;\n        }\n    }\n\n    // TODO: don't make it IEnumerable, just have a Register function instead?\n    /// <summary>\n    /// \n    /// </summary>", "    public class SignatureResolver : IEnumerable<SodmaSignature>\n    {\n        private readonly List<SodmaSignature> _signatures;\n\n        /// <summary>\n        /// Initializes a new simple offset mask data array signature resolver.\n        /// </summary>\n        public SignatureResolver()\n        {\n            _signatures = new List<SodmaSignature>();\n        }\n", "        public void Add(SodmaSignature item)\n        {\n            _signatures.Add(item);\n        }\n\n        public IEnumerator<SodmaSignature> GetEnumerator()\n        {\n            return _signatures.GetEnumerator();\n        }\n\n        IEnumerator IEnumerable.GetEnumerator()\n        {\n            return GetEnumerator();\n        }\n\n        /// <summary>\n        /// Resolves signature patterns against the specified memory range.\n        /// Returns a dictionary of signature names and their respective absolute addresses.\n        /// </summary>\n        /// <param name=\"range\"></param>\n        /// <param name=\"baseAddress\"></param>\n        /// <returns></returns>\n        public Dictionary<string, long> Resolve(ReadOnlyMemory<byte> range, long baseAddress = 0)\n        {\n            Log.Information(\"Resolving signatures in xbdm memory space.\");\n\n            // get matching signature addresses; signatures that match multiple addresses get assigned -1 to indicate failure\n            var matches = new ConcurrentDictionary<SodmaSignature, long>();\n            Parallel.ForEach(_signatures, sig =>\n            {\n                var r = range.Span;\n                int maxOffset = range.Length - (sig.Max(p => p.Offset) + sig.Max(p => p.Data.Length));\n", "                for (int i = sig.Min(p => p.Offset); i < maxOffset; i++)\n                {\n                    // account for negative offsets\n                    if (i < 0) continue;\n\n                    foreach (var pattern in sig)\n                    {\n                        for (int j = 0; j < pattern.Data.Length; j++)\n                        {\n                            if ((r[i + pattern.Offset + j] & pattern.Mask.Span[j]) != pattern.Data.Span[j])\n                                goto nomatch;   // shut up\n                        }\n                    }\n", "                            if ((r[i + pattern.Offset + j] & pattern.Mask.Span[j]) != pattern.Data.Span[j])\n                                goto nomatch;   // shut up\n                        }\n                    }\n\n                    if (!matches.TryAdd(sig, baseAddress + i))\n                    {\n                        matches[sig] = -1;\n                        Log.Error(\"Duplicate match for {0} signature at address {1}.\", sig.Name, (baseAddress + i).ToHexString(8));\n                    }\n                    else Log.Debug(\"Match for {0} signature at address {1}.\", sig.Name, (baseAddress + i).ToHexString(8));\n\n                    nomatch:;\n                }\n            });\n\n            // when possible, resolve conflicts based on signature pattern size followed by largest offset range\n            var resolved = new Dictionary<string, SodmaSignature>();", "            foreach (var match in matches)\n            {\n                // ignore patterns with multiple matches\n                if (match.Value == -1)\n                    continue;\n\n                // resolve different version signature conflicts\n                if (resolved.ContainsKey(match.Key.Name))\n                {\n                    // match against the largest pattern size followed by largest offset range, otherwise unresolved\n                    if (match.Key.Size > resolved[match.Key.Name].Size ||\n                        ((match.Key.Size == resolved[match.Key.Name].Size) &&\n                        match.Key.Range > resolved[match.Key.Name].Range))\n                    {\n                        resolved[match.Key.Name] = match.Key;\n                    }\n                    else\n                    {\n                        Log.Error(\"Unresolved conflict with {0} signature.\", match.Key.Name);\n                        resolved.Remove(match.Key.Name);\n                    }\n                }\n                else resolved.Add(match.Key.Name, match.Key);\n            }\n\n            // translate to final name/address dictionary\n            var result = new Dictionary<string, long>();", "                    if (match.Key.Size > resolved[match.Key.Name].Size ||\n                        ((match.Key.Size == resolved[match.Key.Name].Size) &&\n                        match.Key.Range > resolved[match.Key.Name].Range))\n                    {\n                        resolved[match.Key.Name] = match.Key;\n                    }\n                    else\n                    {\n                        Log.Error(\"Unresolved conflict with {0} signature.\", match.Key.Name);\n                        resolved.Remove(match.Key.Name);\n                    }\n                }\n                else resolved.Add(match.Key.Name, match.Key);\n            }\n\n            // translate to final name/address dictionary\n            var result = new Dictionary<string, long>();", "            foreach (var unique in resolved)\n            {\n                Log.Information(\"Resolved {0} to address {1}.\", unique.Value.Name, matches[unique.Value].ToHexString(8));\n                result.Add(unique.Key, matches[unique.Value]);\n            }\n\n            return result;\n        }\n    }\n}\n"]}
{"filename": "src/OGXbdmDumper/Xbox.cs", "chunked_list": ["\ufeffusing System.Text;\nusing System.Net;\nusing Microsoft.Extensions.Caching.Memory;\nusing Serilog;\nusing Serilog.Events;\nusing Iced.Intel;\nusing static Iced.Intel.AssemblerRegisters;\n\nnamespace OGXbdmDumper\n{\n    public class Xbox : IDisposable\n    {\n        #region Properties\n", "namespace OGXbdmDumper\n{\n    public class Xbox : IDisposable\n    {\n        #region Properties\n\n        private bool _disposed;\n\n        private const int _cacheDuration = 1;   // in minutes\n\n        private readonly MemoryCache _cache = new MemoryCache(new MemoryCacheOptions { ExpirationScanFrequency = TimeSpan.FromMinutes(_cacheDuration) });\n\n        private bool? _hasFastGetmem;\n", "        private const int _cacheDuration = 1;   // in minutes\n\n        private readonly MemoryCache _cache = new MemoryCache(new MemoryCacheOptions { ExpirationScanFrequency = TimeSpan.FromMinutes(_cacheDuration) });\n\n        private bool? _hasFastGetmem;\n\n        public ScratchBuffer StaticScratch;\n\n        public bool HasFastGetmem\n        {\n            get\n            {", "        public bool HasFastGetmem\n        {\n            get\n            {\n                if (_hasFastGetmem == null)\n                {\n                    try\n                    {\n                        long testAddress = 0x10000;\n                        if (IsValidAddress(testAddress))\n                        {\n                            Session.SendCommandStrict(\"getmem2 addr={0} length=1\", testAddress.ToHexString());\n                            Session.ClearReceiveBuffer();\n                            _hasFastGetmem = true;\n                            Log.Information(\"Fast getmem support detected.\");\n                        }                      \n                        else _hasFastGetmem = false;\n                    }\n                    catch\n                    {\n                        _hasFastGetmem = false;\n                    }\n                }\n                return _hasFastGetmem.Value;\n            }\n        }\n\n        /// <summary>\n        /// Determines whether precautions (usually at the expense of performance) should be taken to prevent crashing the xbox.\n        /// </summary>", "                        if (IsValidAddress(testAddress))\n                        {\n                            Session.SendCommandStrict(\"getmem2 addr={0} length=1\", testAddress.ToHexString());\n                            Session.ClearReceiveBuffer();\n                            _hasFastGetmem = true;\n                            Log.Information(\"Fast getmem support detected.\");\n                        }                      \n                        else _hasFastGetmem = false;\n                    }\n                    catch\n                    {\n                        _hasFastGetmem = false;\n                    }\n                }\n                return _hasFastGetmem.Value;\n            }\n        }\n\n        /// <summary>\n        /// Determines whether precautions (usually at the expense of performance) should be taken to prevent crashing the xbox.\n        /// </summary>", "        public bool SafeMode { get; set; } = true;\n\n        public bool IsConnected => Session.IsConnected;\n\n        public int SendTimeout { get => Session.SendTimeout; set => Session.SendTimeout = value; }\n\n        public int ReceiveTimeout { get => Session.ReceiveTimeout; set => Session.ReceiveTimeout = value; }\n\n        public Connection Session { get; private set; } = new Connection();\n\n        public ConnectionInfo? ConnectionInfo { get; protected set; }\n\n        /// <summary>\n        /// The Xbox memory stream.\n        /// </summary>", "        public Connection Session { get; private set; } = new Connection();\n\n        public ConnectionInfo? ConnectionInfo { get; protected set; }\n\n        /// <summary>\n        /// The Xbox memory stream.\n        /// </summary>\n        public XboxMemoryStream Memory { get; private set; }\n\n        public Kernel Kernel { get; private set; }\n\n        public List<Module> Modules => GetModules();\n\n        public List<Thread> Threads => GetThreads();\n", "        public Kernel Kernel { get; private set; }\n\n        public List<Module> Modules => GetModules();\n\n        public List<Thread> Threads => GetThreads();\n\n        public Version Version => GetVersion();\n\n        #endregion\n\n        #region Connection\n", "        public void Connect(string host, int port = 731)\n        {\n            _cache.Clear();\n            ConnectionInfo = Session.Connect(host, port);\n\n            // init subsystems\n            Memory = new XboxMemoryStream(this);\n            Kernel = new Kernel(this);\n            StaticScratch = new ScratchBuffer(this);\n\n            Log.Information(\"Loaded Modules:\");", "            foreach (var module in Modules)\n            {\n                Log.Information(\"\\t{0} ({1})\", module.Name, module.TimeStamp);\n            }\n\n            Log.Information(\"Xbdm Version {0}\", Version);\n            Log.Information(\"Kernel Version {0}\", Kernel.Version);\n\n            // enable remote code execution and use the remainder reloc section as scratch\n            PatchXbdm(this);\n        }\n", "        public void Disconnect()\n        {\n            Session.Disconnect();\n            ConnectionInfo = null;\n            _cache.Clear();\n        }\n\n        public List<ConnectionInfo> Discover(int timeout = 500)\n        {\n            return ConnectionInfo.DiscoverXbdm(731, timeout);\n        }\n", "        public void Connect(IPEndPoint endpoint)\n        {\n            Connect(endpoint.Address.ToString(), endpoint.Port);\n        }\n\n        public void Connect(int timeout = 500)\n        {\n            Connect(Discover(timeout).First().Endpoint);\n        }\n\n        #endregion\n\n        #region Memory\n", "        public bool IsValidAddress(long address)\n        {\n            try\n            {\n                Session.SendCommandStrict(\"getmem addr={0} length=1\", address.ToHexString());\n                return \"??\" != Session.ReceiveMultilineResponse()[0];\n            }\n            catch\n            {\n                return false;\n            }\n        }\n", "        public void ReadMemory(long address, Span<byte> buffer)\n        {\n            if (HasFastGetmem && !SafeMode)\n            {\n                Session.SendCommandStrict(\"getmem2 addr={0} length={1}\", address.ToHexString(), buffer.Length);\n                Session.Read(buffer);\n                if (Log.IsEnabled(LogEventLevel.Verbose))\n                {\n                    Log.Verbose(buffer.ToHexString());\n                }\n            }", "            else if (!SafeMode)\n            {\n                // custom getmem2\n                Session.SendCommandStrict(\"funccall type=1 addr={0} length={1}\", address, buffer.Length);\n                Session.ReadExactly(buffer);\n                if (Log.IsEnabled(LogEventLevel.Verbose))\n                {\n                    Log.Verbose(buffer.ToHexString());\n                }\n            }\n            else\n            {\n                Session.SendCommandStrict(\"getmem addr={0} length={1}\", address.ToHexString(), buffer.Length);\n\n                int bytesRead = 0;\n                string hexString;", "                while ((hexString = Session.ReceiveLine()) != \".\")\n                {\n                    Span<byte> slice = buffer.Slice(bytesRead, hexString.Length / 2);\n                    slice.FromHexString(hexString);\n                    bytesRead += slice.Length;\n                }\n            }\n        }\n\n        public void ReadMemory(long address, byte[] buffer, int offset, int count)\n        {\n            ReadMemory(address, buffer.AsSpan(offset, count));\n        }\n", "        public void ReadMemory(long address, byte[] buffer, int offset, int count)\n        {\n            ReadMemory(address, buffer.AsSpan(offset, count));\n        }\n\n        public void ReadMemory(long address, int count, Stream destination)\n        {\n            // argument checks\n            if (address < 0) throw new ArgumentOutOfRangeException(nameof(address));\n            if (count <= 0) throw new ArgumentOutOfRangeException(nameof(count));\n            if (destination == null) throw new ArgumentNullException(nameof(destination));\n\n            Span<byte> buffer = stackalloc byte[1024 * 80];\n", "            if (address < 0) throw new ArgumentOutOfRangeException(nameof(address));\n            if (count <= 0) throw new ArgumentOutOfRangeException(nameof(count));\n            if (destination == null) throw new ArgumentNullException(nameof(destination));\n\n            Span<byte> buffer = stackalloc byte[1024 * 80];\n\n            while (count > 0)\n            {\n                int bytesToRead = Math.Min(buffer.Length, count);\n\n                Span<byte> slice = buffer.Slice(0, bytesToRead);\n                ReadMemory(address, slice);\n                destination.Write(slice);\n\n                count -= bytesToRead;\n                address += (uint)bytesToRead;\n            }\n        }\n", "        public void WriteMemory(long address, ReadOnlySpan<byte> buffer)\n        {\n            const int maxBytesPerLine = 240;\n            int totalWritten = 0;\n\n            while (totalWritten < buffer.Length)\n            {\n                ReadOnlySpan<byte> slice = buffer.Slice(totalWritten, Math.Min(maxBytesPerLine, buffer.Length - totalWritten));\n                Session.SendCommandStrict(\"setmem addr={0} data={1}\", (address + totalWritten).ToHexString(), slice.ToHexString());\n                totalWritten += slice.Length;\n            }\n        }\n", "        public void WriteMemory(long address, byte[] buffer, int offset, int count)\n        {\n            WriteMemory(address, buffer.AsSpan(offset, count));\n        }\n\n        public void WriteMemory(long address, int count, Stream source)\n        {\n            // argument checks\n            if (address < 0) throw new ArgumentOutOfRangeException(nameof(address));\n            if (count <= 0) throw new ArgumentOutOfRangeException(nameof(count));\n            if (source == null) throw new ArgumentNullException(nameof(source));\n\n            Span<byte> buffer = stackalloc byte[1024 * 80];\n", "            if (address < 0) throw new ArgumentOutOfRangeException(nameof(address));\n            if (count <= 0) throw new ArgumentOutOfRangeException(nameof(count));\n            if (source == null) throw new ArgumentNullException(nameof(source));\n\n            Span<byte> buffer = stackalloc byte[1024 * 80];\n\n            while (count > 0)\n            {\n                int bytesRead = source.Read(buffer.Slice(0, Math.Min(buffer.Length, count)));\n                WriteMemory(address, buffer.Slice(0, bytesRead));\n\n                count -= bytesRead;\n                address += bytesRead;\n            }\n        }\n\n        #endregion\n\n        #region Process\n\n        public List<Thread> GetThreads()\n        {\n            List<Thread> threads = new List<Thread>();\n\n            Session.SendCommandStrict(\"threads\");", "            foreach (var threadId in Session.ReceiveMultilineResponse())\n            {\n                Session.SendCommandStrict(\"threadinfo thread={0}\", threadId);\n                var info = Connection.ParseKvpResponse(string.Join(Environment.NewLine, Session.ReceiveMultilineResponse()));\n\n                threads.Add(new Thread\n                {\n                    Id = Convert.ToInt32(threadId),\n                    Suspend = (int)(uint)info[\"suspend\"], // initially -1 in earlier xbdm versions, 0 in later ones\n                    Priority = (int)(uint)info[\"priority\"],\n                    TlsBase = (uint)info[\"tlsbase\"],\n\n                    // optional depending on xbdm version\n                    Start = info.ContainsKey(\"start\") ? (uint)info[\"start\"] : 0,\n                    Base = info.ContainsKey(\"base\") ? (uint)info[\"base\"] : 0,\n                    Limit = info.ContainsKey(\"limit\") ? (uint)info[\"limit\"] : 0,\n                    CreationTime = DateTime.FromFileTime(\n                        (info.ContainsKey(\"createhi\") ? (((long)(uint)info[\"createhi\"]) << 32) : 0) |\n                        (info.ContainsKey(\"createlo\") ? (uint)info[\"createlo\"] : 0))\n                });\n            }\n\n            return threads;\n        }\n\n        public List<Module> GetModules()\n        {\n            List<Module> modules = new List<Module>();\n\n            Session.SendCommandStrict(\"modules\");", "            foreach (var moduleResponse in Session.ReceiveMultilineResponse())\n            {\n                var moduleInfo = Connection.ParseKvpResponse(moduleResponse);\n                Module module = new Module\n                {\n                    Name = (string)moduleInfo[\"name\"],\n                    BaseAddress = (uint)moduleInfo[\"base\"],\n                    Size = (int)(uint)moduleInfo[\"size\"],\n                    Checksum = (uint)moduleInfo[\"check\"],\n                    TimeStamp = DateTimeOffset.FromUnixTimeSeconds((uint)moduleInfo[\"timestamp\"]).DateTime,\n                    Sections = new List<ModuleSection>(),\n                    HasTls = moduleInfo.ContainsKey(\"tls\"),\n                    IsXbe = moduleInfo.ContainsKey(\"xbe\")\n                };\n\n                Session.SendCommandStrict(\"modsections name=\\\"{0}\\\"\", module.Name);", "                foreach (var sectionResponse in Session.ReceiveMultilineResponse())\n                {\n                    var sectionInfo = Connection.ParseKvpResponse(sectionResponse);\n                    module.Sections.Add(new ModuleSection\n                    {\n                        Name = (string)sectionInfo[\"name\"],\n                        Base = (uint)sectionInfo[\"base\"],\n                        Size = (int)(uint)sectionInfo[\"size\"],\n                        Flags = (uint)sectionInfo[\"flags\"]\n                    });\n                }\n\n                modules.Add(module);\n            }\n\n            return modules;\n        }\n", "        public Version GetVersion()\n        {\n            var version = _cache.Get<Version>(nameof(GetVersion));\n            if (version == null)\n            {\n                try\n                {\n                    // peek inside VS_VERSIONINFO struct\n                    var versionAddress = GetModules().FirstOrDefault(m => m.Name.Equals(\"xbdm.dll\")).GetSection(\".rsrc\").Base + 0x98;\n\n                    // call getmem directly to avoid dependency loops with ReadMemory checking the version\n                    Span<byte> buffer = stackalloc byte[sizeof(ushort) * 4];\n                    Session.SendCommandStrict(\"getmem addr={0} length={1}\", versionAddress.ToHexString(), buffer.Length);\n                    buffer.FromHexString(Session.ReceiveMultilineResponse().First());\n\n                    version = new Version(\n                        BitConverter.ToUInt16(buffer.Slice(2, sizeof(ushort))),\n                        BitConverter.ToUInt16(buffer.Slice(0, sizeof(ushort))),\n                        BitConverter.ToUInt16(buffer.Slice(6, sizeof(ushort))),\n                        BitConverter.ToUInt16(buffer.Slice(4, sizeof(ushort)))\n                    );\n\n                    // cache the result\n                    _cache.Set(nameof(GetVersion), version);\n                }\n                catch\n                {\n                    version = new Version(\"0.0.0.0\");\n                }\n            }\n\n            return version;\n        }\n", "        public void Stop()\n        {\n            Log.Information(\"Suspending xbox execution.\");\n            Session.SendCommand(\"stop\");\n        }\n\n        public void Go()\n        {\n            Log.Information(\"Resuming xbox execution.\");\n            Session.SendCommand(\"go\");\n        }\n\n        /// <summary>\n        /// Calls an Xbox function.\n        /// </summary>\n        /// <param name=\"address\">The function address.</param>\n        /// <param name=\"args\">The function arguments.</param>\n        /// <returns>Returns an object that unboxes eax by default, but allows for reading st0 for floating-point return values.</returns>", "        public uint Call(long address, params object[] args)\n        {\n            // TODO: call context (~4039+ which requires qwordparam)\n\n            // injected script pushes arguments in reverse order for simplicity, this corrects that\n            var reversedArgs = args.Reverse().ToArray();\n\n            StringBuilder command = new StringBuilder();\n            command.AppendFormat(\"funccall type=0 addr={0} \", address);\n            for (int i = 0; i < reversedArgs.Length; i++)\n            {\n                command.AppendFormat(\"arg{0}={1} \", i, Convert.ToUInt32(reversedArgs[i]));\n            }\n\n            var returnValues = Connection.ParseKvpResponse(Session.SendCommandStrict(command.ToString()).Message);\n            return (uint)returnValues[\"eax\"];\n        }\n\n        /// <summary>\n        /// Original Xbox Debug Monitor runtime patches.\n        /// Prevents crashdumps from being written to the HDD and enables remote code execution.\n        /// </summary>\n        /// <param name=\"target\"></param>", "            for (int i = 0; i < reversedArgs.Length; i++)\n            {\n                command.AppendFormat(\"arg{0}={1} \", i, Convert.ToUInt32(reversedArgs[i]));\n            }\n\n            var returnValues = Connection.ParseKvpResponse(Session.SendCommandStrict(command.ToString()).Message);\n            return (uint)returnValues[\"eax\"];\n        }\n\n        /// <summary>\n        /// Original Xbox Debug Monitor runtime patches.\n        /// Prevents crashdumps from being written to the HDD and enables remote code execution.\n        /// </summary>\n        /// <param name=\"target\"></param>", "        private void PatchXbdm(Xbox target)\n        {\n            // the spin routine to be patched in after the signature patterns\n            // spin:\n            // jmp spin\n            // int 3\n            var spinBytes = new byte[] { 0xEB, 0xFE, 0xCC };\n\n            // prevent crashdumps from being written to the hard drive by making it spin instead (only for xbdm versions ~4831+)\n            if (target.Signatures.ContainsKey(\"ReadWriteOneSector\"))\n            {\n                Log.Information(\"Disabling crashdump functionality.\");\n                target.WriteMemory(target.Signatures[\"ReadWriteOneSector\"] + 9, spinBytes);\n            }", "            if (target.Signatures.ContainsKey(\"ReadWriteOneSector\"))\n            {\n                Log.Information(\"Disabling crashdump functionality.\");\n                target.WriteMemory(target.Signatures[\"ReadWriteOneSector\"] + 9, spinBytes);\n            }\n            else if (target.Signatures.ContainsKey(\"WriteSMBusByte\"))\n            {\n                // this will prevent the LED state from changing upon crash\n                Log.Information(\"Disabling crashdump functionality.\");\n                target.WriteMemory(target.Signatures[\"WriteSMBusByte\"] + 9, spinBytes);\n            }\n\n            Log.Information(\"Patching xbdm memory to enable remote code execution.\");\n\n            uint argThreadStringAddress = StaticScratch.Alloc(\"thread\\0\");\n            uint argTypeStringAddress = StaticScratch.Alloc(\"type\\0\");\n            uint argAddrStringAddress = StaticScratch.Alloc(\"addr\\0\");\n            uint argLengthStringAddress = StaticScratch.Alloc(\"length\\0\");\n            uint argFormatStringAddress = StaticScratch.Alloc(\"arg%01d\\0\");\n            uint returnFormatAddress = StaticScratch.Alloc(\"eax=0x%X\\0\");\n\n            var asm = new Assembler(32);\n\n            #region HrSendGetMemory2Data\n\n            uint getmem2CallbackAddress = 0;", "            if (!HasFastGetmem)\n            {\n                // labels\n                var label1 = asm.CreateLabel();\n                var label2 = asm.CreateLabel();\n                var label3 = asm.CreateLabel();\n\n                asm.push(ebx);\n                asm.mov(ebx, __dword_ptr[esp + 8]);     // pdmcc\n                asm.mov(eax, __dword_ptr[ebx + 0x14]);  // size\n                asm.test(eax, eax);\n                asm.mov(edx, __dword_ptr[ebx + 0x10]);\n                asm.ja(label1);\n                //asm.push(__dword_ptr[ebx + 8]);\n                //asm.call((uint)target.Signatures[\"DmFreePool\"]);\n                //asm.and(__dword_ptr[ebx + 8], 0);\n                asm.mov(eax, 0x82DB0104);\n                asm.jmp(label3);\n\n                asm.Label(ref label1);\n                asm.mov(ecx, __dword_ptr[ebx + 0xC]);   // buffer size\n                asm.cmp(eax, ecx);\n                asm.jb(label2);\n                asm.mov(eax, ecx);\n\n                asm.Label(ref label2);\n                asm.push(ebp);\n                asm.push(esi);\n                asm.mov(esi, __dword_ptr[edx + 0x14]);  // address\n                asm.push(edi);\n                asm.mov(edi, __dword_ptr[ebx + 8]);\n                asm.mov(ecx, eax);\n                asm.mov(ebp, ecx);\n                asm.shr(ecx, 2);\n                asm.rep.movsd();\n                asm.mov(ecx, ebp);\n                asm.and(ecx, 3);\n                asm.rep.movsb();\n                asm.sub(__dword_ptr[ebx + 0x14], eax);\n                asm.pop(edi);\n                asm.mov(__dword_ptr[ebx + 4], eax);\n                asm.add(__dword_ptr[edx + 0x14], eax);\n                asm.pop(esi);\n                asm.mov(eax, 0x2DB0000);\n                asm.pop(ebp);\n\n                asm.Label(ref label3);\n                asm.pop(ebx);\n                asm.ret(0xC);\n\n                getmem2CallbackAddress = StaticScratch.Alloc(asm.AssembleBytes(StaticScratch.Region.Address));\n            }\n\n            #endregion\n\n            #region HrFunctionCall\n\n            // 3424+ as it depends on sprintf within xbdm, earlier versions can possibly call against the kernel but their exports are different\n            asm = new Assembler(32);\n\n            // labels\n            var binaryResponseLabel = asm.CreateLabel();\n            var getmem2Label = asm.CreateLabel();\n            var errorLabel = asm.CreateLabel();\n            var successLabel = asm.CreateLabel();\n\n            // prolog\n            asm.push(ebp);\n            asm.mov(ebp, esp);\n            asm.sub(esp, 0x10); // carve out arbitrary space for local temp variables\n            asm.pushad();\n\n            // disable write protection globally, otherwise checked kernel calls may fail when writing to the default scratch space\n            asm.mov(eax, cr0);\n            asm.and(eax, 0xFFFEFFFF);\n            asm.mov(cr0, eax);\n\n            // arguments\n            var commandPtr = ebp + 0x8;\n            var responseAddress = ebp + 0xC;\n            var pdmcc = ebp + 0x14;\n\n            // local variables\n            var temp = ebp - 0x4;\n            var callAddress = ebp - 0x8;\n            var argName = ebp - 0x10;\n\n            // check for thread id\n            asm.lea(eax, temp);\n            asm.push(eax);\n            asm.push(argThreadStringAddress);    // 'thread', 0\n            asm.push(__dword_ptr[commandPtr]);\n            asm.call((uint)target.Signatures[\"FGetDwParam\"]);\n            asm.test(eax, eax);\n            var customCommandLabel = asm.CreateLabel();\n            asm.je(customCommandLabel);\n\n            // call original code if thread id exists\n            asm.push(__dword_ptr[temp]);\n            asm.call((uint)target.Signatures[\"DmSetupFunctionCall\"]);\n            var doneLabel = asm.CreateLabel();\n            asm.jmp(doneLabel);\n\n            // thread argument doesn't exist, must be a custom command\n            asm.Label(ref customCommandLabel);\n\n            // determine custom function type\n            asm.lea(eax, temp);\n            asm.push(eax);\n            asm.push(argTypeStringAddress);    // 'type', 0\n            asm.push(__dword_ptr[commandPtr]);\n            asm.call((uint)target.Signatures[\"FGetDwParam\"]);\n            asm.test(eax, eax);\n            asm.je(errorLabel);\n\n            #region Custom Call (type 0)\n\n            asm.cmp(__dword_ptr[temp], 0);\n            asm.jne(getmem2Label);\n\n            // get the call address\n            asm.lea(eax, __dword_ptr[callAddress]);\n            asm.push(eax);\n            asm.push(argAddrStringAddress);    // 'addr', 0\n            asm.push(__dword_ptr[commandPtr]);\n            asm.call((uint)target.Signatures[\"FGetDwParam\"]);\n            asm.test(eax, eax);\n\n            asm.je(errorLabel);\n\n            // push arguments (leave it up to caller to reverse argument order and supply the correct amount)\n            asm.xor(edi, edi);\n            var nextArgLabel = asm.CreateLabel();\n            var noMoreArgsLabel = asm.CreateLabel();\n            asm.Label(ref nextArgLabel);\n            {\n                // get argument name\n                asm.push(edi);                                  // argument index\n                asm.push(argFormatStringAddress);                // format string address\n                asm.lea(eax, __dword_ptr[argName]);          // argument name address\n                asm.push(eax);\n                asm.call((uint)target.Signatures[\"sprintf\"]);\n                asm.add(esp, 0xC);\n\n                // check if it's included in the command\n                asm.lea(eax, __[temp]);                    // argument value address\n                asm.push(eax);\n                asm.lea(eax, __[argName]);                   // argument name address\n                asm.push(eax);\n                asm.push(__dword_ptr[commandPtr]);               // command\n                asm.call((uint)target.Signatures[\"FGetDwParam\"]);\n                asm.test(eax, eax);\n                asm.je(noMoreArgsLabel);\n\n                // push it on the stack\n                asm.push(__dword_ptr[temp]);\n                asm.inc(edi);\n\n                // move on to the next argument\n                asm.jmp(nextArgLabel);\n            }\n            asm.Label(ref noMoreArgsLabel);\n\n            // perform the call\n            asm.call(__dword_ptr[callAddress]);\n\n            // print response message\n            asm.push(eax);                                  // integer return value\n            asm.push(returnFormatAddress);                  // format string address\n            asm.push(__dword_ptr[responseAddress]);         // response address\n            asm.call((uint)target.Signatures[\"sprintf\"]);\n            asm.add(esp, 0xC);\n            asm.jmp(successLabel);\n\n            #endregion\n\n            #region Fast Getmem (type 1)\n\n            asm.Label(ref getmem2Label);\n            asm.cmp(__dword_ptr[temp], 1);\n            asm.jne(errorLabel);\n ", "            if (!HasFastGetmem)\n            {\n                // TODO: figure out why DmAllocatePool crashes, for now, allocate static scratch space (prevents multi-session!)\n                StaticScratch.Align16();\n                uint getmem2BufferSize = 512;\n                uint getmem2buffer = StaticScratch.Alloc(new byte[getmem2BufferSize]);\n\n                // get length and size args\n                asm.mov(esi, __dword_ptr[pdmcc]);\n                asm.push(__dword_ptr[responseAddress]);\n                asm.mov(edi, __dword_ptr[esi + 0x10]);\n                asm.lea(eax, __dword_ptr[pdmcc]);\n                asm.push(eax);\n                asm.push(argAddrStringAddress);\n                asm.push(__dword_ptr[commandPtr]);\n                asm.call((uint)target.Signatures[\"FGetNamedDwParam\"]);\n                asm.test(eax, eax);\n                asm.jz(errorLabel);\n                asm.push(__dword_ptr[responseAddress]);\n                asm.lea(eax, __dword_ptr[responseAddress]);\n                asm.push(eax);\n                asm.push(argLengthStringAddress);\n                asm.push(__dword_ptr[commandPtr]);\n                asm.call((uint)target.Signatures[\"FGetNamedDwParam\"]);\n                asm.test(eax, eax);\n                asm.jz(errorLabel);\n\n                asm.mov(eax, __dword_ptr[pdmcc]);   // address\n                asm.and(__dword_ptr[edi + 0x10], 0);\n                asm.mov(__dword_ptr[edi + 0x14], eax);\n                //asm.mov(eax, 0x2000);   // TODO: increase pool size?\n                //asm.push(eax);\n                //asm.call((uint)target.Signatures[\"DmAllocatePool\"]);    // TODO: crashes in here, possible IRQ issues?\n                asm.mov(__dword_ptr[esi + 0xC], getmem2BufferSize);   // buffer size\n                asm.mov(__dword_ptr[esi + 8], getmem2buffer); // buffer address\n                asm.mov(eax, __dword_ptr[responseAddress]);\n                asm.mov(__dword_ptr[esi + 0x14], eax);\n                asm.mov(__dword_ptr[esi], getmem2CallbackAddress);\n                asm.jmp(binaryResponseLabel);\n            }\n\n            #endregion\n\n            #region Return Codes\n\n            // if we're here, must be an unknown custom type\n            asm.jmp(errorLabel);\n\n            // generic success epilog\n            asm.Label(ref successLabel);\n            asm.popad();\n            asm.leave();\n            asm.mov(eax, 0x2DB0000);\n            asm.ret(0x10);\n\n            // successful binary response follows epilog\n            asm.Label(ref binaryResponseLabel);\n            asm.popad();\n            asm.leave();\n            asm.mov(eax, 0x2DB0003);\n            asm.ret(0x10);\n\n            // generic failure epilog\n            asm.Label(ref errorLabel);\n            asm.popad();\n            asm.leave();\n            asm.mov(eax, 0x82DB0000);\n            asm.ret(0x10);\n\n            // original epilog\n            asm.Label(ref doneLabel);\n            asm.popad();\n            asm.leave();\n            asm.ret(0x10);\n\n            #endregion\n\n            // inject RPC handler and hook\n            uint caveAddress = StaticScratch.Alloc(asm.AssembleBytes(StaticScratch.Region.Address));\n            Log.Information(\"HrFuncCall address {0}\", caveAddress.ToHexString());\n            asm.Hook(target, target.Signatures[\"HrFunctionCall\"], caveAddress);\n            \n            #endregion\n        }\n", "        public string GetDisassembly(long address, int length, bool tabPrefix = true, bool showBytes = false)\n        {\n            // read code from xbox memory\n            byte[] code = Memory.ReadBytes(address, length);\n\n            // disassemble valid instructions\n            var decoder = Iced.Intel.Decoder.Create(32, code);\n            decoder.IP = (ulong)address;\n            var instructions = new List<Instruction>();\n            while (decoder.IP < decoder.IP + (uint)code.Length)\n            {\n                var insn = decoder.Decode();", "            while (decoder.IP < decoder.IP + (uint)code.Length)\n            {\n                var insn = decoder.Decode();\n                if (insn.IsInvalid)\n                    break;\n                instructions.Add(insn);\n            }\n\n            // formatting options\n            var formatter = new MasmFormatter();\n            formatter.Options.FirstOperandCharIndex = 8;\n            formatter.Options.SpaceAfterOperandSeparator = true;\n\n            // convert to string\n            var output = new StringOutput();\n            var disassembly = new StringBuilder();\n            bool firstInstruction = true;", "            foreach (var instr in instructions)\n            {\n                // skip newline for the first instruction\n                if (firstInstruction)\n                {\n                    firstInstruction = false;\n                } else disassembly.AppendLine();\n\n                // optionally indent\n                if (tabPrefix)\n                {\n                    disassembly.Append('\\t');\n                }\n\n                // output address\n                disassembly.Append(instr.IP.ToString(\"X8\"));\n                disassembly.Append(' ');\n\n                // optionally output instruction bytes", "                if (tabPrefix)\n                {\n                    disassembly.Append('\\t');\n                }\n\n                // output address\n                disassembly.Append(instr.IP.ToString(\"X8\"));\n                disassembly.Append(' ');\n\n                // optionally output instruction bytes\n                if (showBytes)\n                {", "                if (showBytes)\n                {\n                    for (int i = 0; i < instr.Length; i++)\n                        disassembly.Append(code[(int)(instr.IP - (ulong)address) + i].ToString(\"X2\"));\n                    int missingBytes = 10 - instr.Length;\n                    for (int i = 0; i < missingBytes; i++)\n                        disassembly.Append(\"  \");\n                    disassembly.Append(' ');\n                }\n\n                // output the decoded instruction\n                formatter.Format(instr, output);\n                disassembly.Append(output.ToStringAndReset());\n            }\n            \n            return disassembly.ToString();\n        }\n\n        public Dictionary<string, long> Signatures\n        {\n            get\n            {\n                var signatures = _cache.Get<Dictionary<string, long>>(nameof(Signatures));", "                if (signatures == null)\n                {\n                    var resolver = new SignatureResolver\n                    {\n                        // NOTE: ensure patterns don't overlap with any hooks! that way we don't have to cache any states; simplicity at the expense of slightly less perf on connect\n\n                        // universal pattern\n                        new SodmaSignature(\"ReadWriteOneSector\")\n                        { \n                            // mov     ebp, esp\n                            new OdmPattern(0x1, new byte[] { 0x8B, 0xEC }),\n\n                            // mov     dx, 1F6h\n                            new OdmPattern(0x3, new byte[] { 0x66, 0xBA, 0xF6, 0x01 }),\n\n                            // mov     al, 0A0h\n                            new OdmPattern(0x7, new byte[] { 0xB0, 0xA0 })\n                        },\n\n                        // universal pattern\n                        new SodmaSignature(\"WriteSMBusByte\")\n                        { \n                            // mov     al, 20h\n                            new OdmPattern(0x3, new byte[] { 0xB0, 0x20 }),\n\n                            // mov     dx, 0C004h\n                            new OdmPattern(0x5, new byte[] { 0x66, 0xBA, 0x04, 0xC0 }),\n                        },\n\n                        // universal pattern\n                        new SodmaSignature(\"FGetDwParam\")\n                        { \n                            // jz      short 0x2C\n                            new OdmPattern(0x15, new byte[] { 0x74, 0x2C }),\n\n                            // push     20h\n                            new OdmPattern(0x17, new byte[] { 0x6A, 0x20 }),\n\n                            // mov      [ecx], eax\n                            new OdmPattern(0x33, new byte[] { 0x89, 0x01 })\n                        },\n\n                        // universal pattern\n                        new SodmaSignature(\"FGetNamedDwParam\")\n                        {\n                            // mov     ebp, esp\n                            new OdmPattern(0x1, new byte[] { 0x8B, 0xEC }),\n\n                            // jnz     short 0x17\n                            new OdmPattern(0x13, new byte[] { 0x75, 0x17 }),\n\n                            // retn    10h\n                            new OdmPattern(0x30, new byte[] { 0xC2, 0x10, 0x00 })\n                        },\n\n                        // universal pattern\n                        new SodmaSignature(\"DmSetupFunctionCall\")\n                        {\n                            // test     ax, 280h\n                            new OdmPattern(0x45, new byte[] { 0x66, 0xA9, 0x80, 0x02 }),\n\n                            // push     63666D64h\n                            new OdmPattern(0x54, new byte[] { 0x68, 0x64, 0x6D, 0x66, 0x63 })\n                        },\n\n                        // early revisions\n                        new SodmaSignature(\"HrFunctionCall\")\n                        {\n                            // mov     eax, 80004005h\n                            new OdmPattern(0x1B, new byte[] { 0xB8, 0x05, 0x40, 0x00, 0x80 }),\n\n                            // mov     ebx, 10008h\n                            new OdmPattern(0x46, new byte[] { 0xBB, 0x08, 0x00, 0x01, 0x00 })\n                        },\n\n                        // later revisions\n                        new SodmaSignature(\"HrFunctionCall\")\n                        {\n                            // mov     eax, 80004005h\n                            new OdmPattern(0x1B, new byte[] { 0xB8, 0x05, 0x40, 0x00, 0x80 }),\n\n                            // mov     ebx, 10008h\n                            new OdmPattern(0x45, new byte[] { 0xBB, 0x08, 0x00, 0x01, 0x00 })\n                        },\n\n                        // xbdm 3424+ contains this (3223 does not, who knows what inbetween does) whereas some early kernel versions do not? or have different kernel export tables for alpha/dvt3/dvt4/dvt6 etc.\n                        new SodmaSignature(\"sprintf\")\n                        {\n                            // mov     esi, [ebp+arg_0]\n                            new OdmPattern(0x7, new byte[] { 0x8B, 0x75, 0x08 }),\n                    \n                            // mov      [ebp+var_1C], 7FFFFFFFh\n                            new OdmPattern(0x16, new byte[] { 0xC7, 0x45, 0xE4, 0xFF, 0xFF, 0xFF, 0x7F })\n                        },\n\n                        // early revisions\n                        new SodmaSignature(\"DmAllocatePool\")\n                        {\n                            // push    ebp\n                            new OdmPattern(0x0, new byte[] { 0x55 }),\n\n                            // mov     ebp, esp\n                            new OdmPattern(0x0, new byte[] { 0x8B, 0xEC }),\n\n                            // push    'enoN'\n                            new OdmPattern(0x3, new byte[] { 0x68, 0x4E, 0x6F, 0x6E, 0x65 })\n                        },\n\n                        // later revisions\n                        new SodmaSignature(\"DmAllocatePool\")\n                        {\n                            // push    'enoN'\n                            new OdmPattern(0x0, new byte[] { 0x68, 0x4E, 0x6F, 0x6E, 0x65 }),\n\n                            // retn    4\n                            new OdmPattern(0xE, new byte[] { 0xC2, 0x04, 0x00 })\n                        },\n\n                        // universal pattern\n                        new SodmaSignature(\"DmFreePool\")\n                        {\n                            // cmp     eax, 0B0000000h\n                            new OdmPattern(0xF, new byte[] { 0x3D, 0x00, 0x00, 0x00, 0xB0 })\n                        }\n                    };\n\n                    // read xbdm .text section\n                    var xbdmTextSegment = GetModules().FirstOrDefault(m => m.Name.Equals(\"xbdm.dll\")).GetSection(\".text\");\n                    byte[] data = new byte[xbdmTextSegment.Size];\n                    ReadMemory(xbdmTextSegment.Base, data);\n\n                    // scan for signatures\n                    signatures = resolver.Resolve(data, xbdmTextSegment.Base);\n\n                    // cache the result indefinitely\n                    _cache.Set(nameof(Signatures), signatures);\n                }\n\n                return signatures;\n            }\n        }\n\n        #endregion\n\n        #region File\n\n        public char[] GetDrives()\n        {\n            return Session.SendCommandStrict(\"drivelist\").Message.ToCharArray();\n        }\n\n        public List<XboxFileInformation> GetDirectoryList(string path)\n        {\n            var list = new List<XboxFileInformation>();\n            Session.SendCommandStrict(\"dirlist name=\\\"{0}\\\"\", path);", "            foreach (string file in Session.ReceiveMultilineResponse())\n            {\n                var fileInfo = file.ParseXboxResponseLine();\n                var info = new XboxFileInformation();\n                info.FullName = Path.Combine(path, (string)fileInfo[\"name\"]);\n                info.Size = ((long)fileInfo[\"sizehi\"] << 32) | (long)fileInfo[\"sizelo\"];\n                info.CreationTime = DateTime.FromFileTimeUtc(((long)fileInfo[\"createhi\"] << 32) | (long)fileInfo[\"createlo\"]);\n                info.ChangeTime = DateTime.FromFileTimeUtc(((long)fileInfo[\"changehi\"] << 32) | (long)fileInfo[\"changelo\"]);\n                info.Attributes |= file.Contains(\"directory\") ? FileAttributes.Directory : FileAttributes.Normal;\n                info.Attributes |= file.Contains(\"readonly\") ? FileAttributes.ReadOnly : 0;\n                info.Attributes |= file.Contains(\"hidden\") ? FileAttributes.Hidden : 0;\n                list.Add(info);\n            }\n\n            return list; \n        }\n", "        public void GetFile(string localPath, string remotePath)\n        {\n            Session.SendCommandStrict(\"getfile name=\\\"{0}\\\"\", remotePath);\n            using var lfs = File.Create(localPath);\n            Session.CopyToCount(lfs, Session.Reader.ReadInt32());\n        }\n\n        #endregion\n\n        #region IDisposable\n", "        protected virtual void Dispose(bool disposing)\n        {\n            if (!_disposed)\n            {\n                if (disposing)\n                {\n                    // TODO: dispose managed state (managed objects)\n                }\n\n                // TODO: free unmanaged resources (unmanaged objects) and override finalizer\n                Session?.Dispose();\n\n                // TODO: set large fields to null\n\n                _disposed = true;\n            }\n        }\n\n        ~Xbox()\n        {\n            Dispose(false);\n        }\n", "        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        #endregion\n    }\n}\n"]}
{"filename": "src/OGXbdmDumper/XboxMemoryStream.cs", "chunked_list": ["\ufeffusing System.Diagnostics;\nusing System.Text;\n\nnamespace OGXbdmDumper\n{\n    /// <summary>\n    /// Provides streaming access to Xbox memory.\n    /// </summary>\n    public class XboxMemoryStream : Stream\n    {\n        #region Properties\n\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]", "    public class XboxMemoryStream : Stream\n    {\n        #region Properties\n\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n        private readonly Xbox _xbox;\n\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n        private readonly BinaryReader _reader;\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n        private readonly BinaryWriter _writer;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>", "        private readonly BinaryReader _reader;\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n        private readonly BinaryWriter _writer;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public override long Position { get; set; }\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>", "        public override bool CanRead => true;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public override bool CanSeek => true;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public override bool CanWrite => true;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>", "        public override bool CanWrite => true;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public override bool CanTimeout => true;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public override int ReadTimeout => _xbox.ReceiveTimeout;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>", "        public override int ReadTimeout => _xbox.ReceiveTimeout;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public override int WriteTimeout => _xbox.SendTimeout;\n\n        #endregion\n\n        #region Constructor\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        /// <param name=\"xbox\"></param>\n        public XboxMemoryStream(Xbox xbox)\n        {\n            _xbox = xbox ?? throw new ArgumentNullException(nameof(xbox));\n            _reader = new BinaryReader(this);\n            _writer = new BinaryWriter(this);\n        }\n\n        #endregion\n\n        #region Methods\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        /// <param name=\"offset\"></param>\n        /// <param name=\"origin\"></param>\n        /// <returns></returns>", "        public override long Seek(long offset, SeekOrigin origin)\n        {\n            switch (origin)\n            {\n                case SeekOrigin.Begin: return Position = offset; // zero-based address\n                case SeekOrigin.Current: return Position += offset;\n                default: throw new InvalidOperationException(\"Invalid SeekOrigin.\");\n            }\n        }\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        /// <param name=\"buffer\"></param>\n        /// <param name=\"offset\"></param>\n        /// <param name=\"count\"></param>\n        /// <returns></returns>", "        public override int Read(byte[] buffer, int offset, int count)\n        {\n            _xbox.ReadMemory(Position, buffer, offset, count);\n            Position += count;  // have to manually increment count here since it's an external operation\n            return count;\n        }\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        /// <param name=\"buffer\"></param>\n        /// <param name=\"offset\"></param>\n        /// <param name=\"count\"></param>", "        public override void Write(byte[] buffer, int offset, int count)\n        {\n            _xbox.WriteMemory(Position, buffer, offset, count);\n            Position += count;  // have to manually increment count here since it's an external operation\n        }\n\n        #endregion\n\n        #region Reads\n\n        /// <summary>\n        /// Reads a byte from the stream and advances the position of the stream by one byte.\n        /// Throws an EndOfStreamException if the base stream returns -1 indicating the end of the stream.\n        /// </summary>\n        /// <returns></returns>", "        public new byte ReadByte()\n        {\n            int val = _reader.ReadByte();\n            if (val == -1) throw new EndOfStreamException();\n            return (byte)val;\n        }\n\n        public bool ReadBool() => Convert.ToBoolean(_reader.ReadByte());\n        public bool ReadBool(long position) { Position = position; return ReadBool(); }\n        public sbyte ReadSByte() => _reader.ReadSByte();\n        public sbyte ReadSByte(long position) { Position = position; return ReadSByte(); }", "        public bool ReadBool(long position) { Position = position; return ReadBool(); }\n        public sbyte ReadSByte() => _reader.ReadSByte();\n        public sbyte ReadSByte(long position) { Position = position; return ReadSByte(); }\n        public byte ReadByte(long position) { Position = position; return ReadByte(); }\n        public short ReadInt16() => _reader.ReadInt16();\n        public int ReadInt16(long position) { Position = position; return ReadInt16(); }\n        public ushort ReadUInt16() => _reader.ReadUInt16();\n        public ushort ReadUInt16(long position) { Position = position; return ReadUInt16(); }\n        public int ReadInt32() => _reader.ReadInt32();\n        public int ReadInt32(long position) { Position = position; return ReadInt32(); }\n        public uint ReadUInt32() => _reader.ReadUInt32();", "        public int ReadInt32() => _reader.ReadInt32();\n        public int ReadInt32(long position) { Position = position; return ReadInt32(); }\n        public uint ReadUInt32() => _reader.ReadUInt32();\n        public uint ReadUInt32(long position) { Position = position; return ReadUInt32(); }\n        public long ReadInt64() => _reader.ReadInt64();\n        public long ReadInt64(long position) { Position = position; return ReadInt64(); }\n        public ulong ReadUInt64() => _reader.ReadUInt64();\n        public ulong ReadUInt64(long position) { Position = position; return ReadUInt64(); }\n        public float ReadSingle() =>  _reader.ReadSingle();\n        public float ReadSingle(long position) { Position = position; return ReadSingle(); }\n        public double ReadDouble() => _reader.ReadDouble();", "        public float ReadSingle() =>  _reader.ReadSingle();\n        public float ReadSingle(long position) { Position = position; return ReadSingle(); }\n        public double ReadDouble() => _reader.ReadDouble();\n        public double ReadDouble(long position) { Position = position; return ReadDouble(); }\n        public string ReadAscii(int length) => Encoding.ASCII.GetString(_reader.ReadBytes(length));\n        public string ReadAscii(long position, int length) { Position = position; return ReadAscii(length); }\n        public string ReadUnicode(int length) => Encoding.Unicode.GetString(_reader.ReadBytes(length * sizeof(char)));\n        public string ReadUnicode(long position, int length) { Position = position; return ReadUnicode(length); }\n        public byte[] ReadBytes(int length) => _reader.ReadBytes(length);\n        public byte[] ReadBytes(long position, int length) { Position = position; return _reader.ReadBytes(length); }\n\n        /// <summary>\n        /// Read a value of specified type from the stream.\n        /// </summary>\n        /// <typeparam name=\"T\"></typeparam>\n        /// <param name=\"peek\"></param>\n        /// <returns></returns>", "        public T Read<T>(bool peek = false) where T : struct\n        {\n            if (peek && !CanSeek)\n                throw new NotSupportedException(\"Cannot peek a non-seekable stream.\");\n\n            long originalPosition = Position;\n\n            try\n            {\n                return (Type.GetTypeCode(typeof(T))) switch\n                {\n                    TypeCode.Boolean => (T)(object)ReadBool(),\n                    TypeCode.SByte => (T)(object)ReadSByte(),\n                    TypeCode.Byte => (T)(object)ReadByte(),\n                    TypeCode.Int16 => (T)(object)ReadInt16(),\n                    TypeCode.UInt16 => (T)(object)ReadUInt16(),\n                    TypeCode.Int32 => (T)(object)ReadInt32(),\n                    TypeCode.UInt32 => (T)(object)ReadUInt32(),\n                    TypeCode.Int64 => (T)(object)ReadInt64(),\n                    TypeCode.UInt64 => (T)(object)ReadUInt64(),\n                    TypeCode.Single => (T)(object)ReadSingle(),\n                    TypeCode.Double => (T)(object)ReadDouble(),\n                    _ => throw new NotSupportedException(),\n                };\n            }\n            finally\n            {", "                if (peek)\n                {\n                    Position = originalPosition;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Read a value of specified type from the stream.\n        /// </summary>\n        /// <typeparam name=\"T\"></typeparam>\n        /// <param name=\"position\"></param>\n        /// <param name=\"peek\"></param>\n        /// <returns></returns>", "        public T Read<T>(long position, bool peek = false) where T : struct\n        {\n            Position = position;\n            return Read<T>(peek);\n        }\n\n        public int Read(long position, Span<byte> buffer) { Position = position; return Read(buffer); }\n\n        #endregion\n\n        #region Writes\n", "        public void Write(bool value) { WriteByte(Convert.ToByte(value)); }\n        public void Write(long position, bool value) { Position = position; Write(value); }\n        public void Write(byte value) { WriteByte(value); }\n        public void Write(long position, byte value) { Position = position; Write(value); }\n        public void Write(sbyte value) => _writer.Write(value);\n        public void Write(long position, sbyte value) { Position = position; Write(value); }\n        public void Write(short value) => _writer.Write(value);\n        public void Write(long position, short value) { Position = position; Write(value); }\n        public void Write(ushort value) => _writer.Write(value);\n        public void Write(long position, ushort value) { Position = position; Write(value); }\n        public void Write(int value) => _writer.Write(value);", "        public void Write(ushort value) => _writer.Write(value);\n        public void Write(long position, ushort value) { Position = position; Write(value); }\n        public void Write(int value) => _writer.Write(value);\n        public void Write(long position, int value) { Position = position; Write(value); }\n        public void Write(uint value) => _writer.Write(value);\n        public void Write(long position, uint value) { Position = position; Write(value); }\n        public void Write(long value) => _writer.Write(value);\n        public void Write(long position, long value) { Position = position; Write(value); }\n        public void Write(ulong value) => _writer.Write(value);\n        public void Write(long position, ulong value) { Position = position; Write(value); }\n        public void Write(float value) => _writer.Write(value);", "        public void Write(ulong value) => _writer.Write(value);\n        public void Write(long position, ulong value) { Position = position; Write(value); }\n        public void Write(float value) => _writer.Write(value);\n        public void Write(long position, float value) { Position = position; Write(value); }\n        public void Write(double value) => _writer.Write(value);\n        public void Write(long position, double value) { Position = position; Write(value); }\n        public void WriteAscii(string value) => _writer.Write(Encoding.ASCII.GetBytes(value));\n        public void WriteAscii(long position, string value) { Position = position; WriteAscii(value); }\n        public void WriteUnicode(string value) => _writer.Write(Encoding.Unicode.GetBytes(value));\n        public void WriteUnicode(long position, string value) { Position = position; WriteUnicode(value); }\n\n        #endregion\n\n        #region Unsupported\n\n        /// <summary>\n        /// TODO: description. possibly remove exception and just do nothing\n        /// </summary>", "        public void WriteUnicode(string value) => _writer.Write(Encoding.Unicode.GetBytes(value));\n        public void WriteUnicode(long position, string value) { Position = position; WriteUnicode(value); }\n\n        #endregion\n\n        #region Unsupported\n\n        /// <summary>\n        /// TODO: description. possibly remove exception and just do nothing\n        /// </summary>\n        public override void Flush() { throw new NotSupportedException(); }\n\n        /// <summary>\n        /// TODO: description. possibly return total memory size\n        /// </summary>", "        public override void Flush() { throw new NotSupportedException(); }\n\n        /// <summary>\n        /// TODO: description. possibly return total memory size\n        /// </summary>\n        public override long Length { get { throw new NotSupportedException(); } }\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        /// <param name=\"value\"></param>", "        public override void SetLength(long value) { throw new NotSupportedException(); }\n\n        #endregion\n    }\n}\n"]}
{"filename": "src/OGXbdmDumper/CommandResponse.cs", "chunked_list": ["\ufeff\nnamespace OGXbdmDumper\n{\n    /// <summary>\n    /// Xbox command status response.\n    /// </summary>\n    public class CommandResponse\n    {\n        /// <summary>\n        /// The full command response.\n        /// </summary>", "        public string Full { get; }\n\n        /// <summary>\n        /// The command response code.\n        /// </summary>\n        public int Code { get; }\n\n        /// <summary>\n        /// The message portion of the command response.\n        /// </summary>\n        public string Message { get; }\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>", "        public string Message { get; }\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public bool Success => (Code & 200) == 200;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        /// <param name=\"full\"></param>\n        /// <param name=\"code\"></param>\n        /// <param name=\"message\"></param>\n        public CommandResponse(string full, int code, string message)\n        {\n            Full = full;\n            Code = code;\n            Message = message;\n        }\n    }\n}\n"]}
{"filename": "src/OGXbdmDumper/ModuleSection.cs", "chunked_list": ["\ufeffusing System.Diagnostics;\n\nnamespace OGXbdmDumper\n{\n    /// <summary>\n    /// TODO: description\n    /// </summary>\n    [DebuggerDisplay(\"{\" + nameof(Name) + \"}\")]\n    public class ModuleSection\n    {\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public string? Name;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>", "    public class ModuleSection\n    {\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public string? Name;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public uint Base;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>", "        public uint Base;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public int Size;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public uint Flags;\n    }\n}\n", "        public uint Flags;\n    }\n}\n"]}
{"filename": "src/OGXbdmDumper/ScratchBuffer.cs", "chunked_list": ["\ufeffusing Serilog;\n\nnamespace OGXbdmDumper\n{\n    public class ScratchBuffer\n    {\n        private bool _hasScratchReassigned;\n        private Xbox _xbox;\n        public MemoryRegion Region;\n\n        public ScratchBuffer(Xbox xbox) \n        {\n            _xbox = xbox ?? throw new ArgumentNullException(nameof(xbox));\n\n            // get the xbdm reloc section info to be used as a scratch buffer\n            var xbdm = xbox.Modules.Find(m => m.Name == \"xbdm.dll\") ?? throw new DllNotFoundException(\"xbdm.dll\");\n            var reloc = xbdm.GetSection(\".reloc\") ?? throw new NotSupportedException(\"Unable to allocate scratch space.\");\n            Region = new MemoryRegion(reloc.Base, reloc.Size);\n\n            Log.Information(\"Using {0} bytes of scratch space at address {1}.\",\n                Region.Size.ToHexString(), Region.Address.ToHexString());\n        }\n\n        /// <summary>\n        /// Allocates/writes data within the scratch buffer.\n        /// </summary>\n        /// <param name=\"data\"></param>\n        /// <returns>Returns the allocation address.</returns>", "        public MemoryRegion Region;\n\n        public ScratchBuffer(Xbox xbox) \n        {\n            _xbox = xbox ?? throw new ArgumentNullException(nameof(xbox));\n\n            // get the xbdm reloc section info to be used as a scratch buffer\n            var xbdm = xbox.Modules.Find(m => m.Name == \"xbdm.dll\") ?? throw new DllNotFoundException(\"xbdm.dll\");\n            var reloc = xbdm.GetSection(\".reloc\") ?? throw new NotSupportedException(\"Unable to allocate scratch space.\");\n            Region = new MemoryRegion(reloc.Base, reloc.Size);\n\n            Log.Information(\"Using {0} bytes of scratch space at address {1}.\",\n                Region.Size.ToHexString(), Region.Address.ToHexString());\n        }\n\n        /// <summary>\n        /// Allocates/writes data within the scratch buffer.\n        /// </summary>\n        /// <param name=\"data\"></param>\n        /// <returns>Returns the allocation address.</returns>", "        public uint Alloc<T>(T data)\n        {\n            // keep track of the allocation address\n            uint address = Region.Address;\n\n            // write the data\n            _xbox.Memory.Position = address;\n            int bytesWritten = _xbox.Memory.Write(data);\n\n            // calculate the new region size\n            uint newAddress = (uint)(Region.Address + bytesWritten);\n            int newSize = Region.Size - bytesWritten;", "            if (newSize < 0) throw new OverflowException(\"Overflowed scratch space!\");\n            Region = new MemoryRegion(newAddress, newSize);\n\n            // return the allocation address\n            return address;\n        }\n\n        public void Align16()\n        {\n            uint padding = ((Region.Address + 0xF) & 0xFFFFFFF0) - Region.Address;\n            Region = new MemoryRegion(Region.Address + padding, Region.Size - (int)padding);\n        }\n", "        public void Align4K()\n        {\n            uint padding = ((Region.Address + 0xFFF) & 0xFFFFF000) - Region.Address;\n            Region = new MemoryRegion(Region.Address + padding, Region.Size - (int)padding);\n        }\n    }\n}\n"]}
{"filename": "src/OGXbdmDumper/Thread.cs", "chunked_list": ["\ufeffnamespace OGXbdmDumper\n{\n    /// <summary>\n    /// TODO: description\n    /// </summary>\n    public class Thread\n    {\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public int Id;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>", "        public int Id;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public int Suspend;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public int Priority;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>", "        public int Priority;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public uint TlsBase;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public uint Start;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>", "        public uint Start;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public uint Base;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public uint Limit;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>", "        public uint Limit;\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        public DateTime CreationTime;\n    }\n}\n"]}
{"filename": "src/OGXbdmDumper/XboxFileInformation.cs", "chunked_list": ["\ufeffusing System.Diagnostics;\n\nnamespace OGXbdmDumper\n{\n    /// <summary>\n    /// Xbox file information.\n    /// </summary>\n    [DebuggerDisplay(\"{Name}\")]\n    public class XboxFileInformation\n    {\n        /// <summary>\n        /// The file name.\n        /// </summary>", "    public class XboxFileInformation\n    {\n        /// <summary>\n        /// The file name.\n        /// </summary>\n        public string Name => Path.GetFileName(FullName);\n\n        /// <summary>\n        /// The parent directory.\n        /// </summary>\n        public string Directory => Path.GetDirectoryName(FullName);\n\n        /// <summary>\n        /// The full file path and name.\n        /// </summary>", "        public string Directory => Path.GetDirectoryName(FullName);\n\n        /// <summary>\n        /// The full file path and name.\n        /// </summary>\n        public string FullName;\n\n        /// <summary>\n        /// The file size.\n        /// </summary>\n        public long Size;\n\n        /// <summary>\n        /// The file attributes.\n        /// </summary>", "        public long Size;\n\n        /// <summary>\n        /// The file attributes.\n        /// </summary>\n        public FileAttributes Attributes;\n\n        /// <summary>\n        /// The file creation time.\n        /// </summary>\n        public DateTime CreationTime;\n\n        /// <summary>\n        /// The file modification time.\n        /// </summary>", "        public DateTime CreationTime;\n\n        /// <summary>\n        /// The file modification time.\n        /// </summary>\n        public DateTime ChangeTime;\n    }\n}\n"]}
{"filename": "src/OGXbdmDumper/ConnectionInfo.cs", "chunked_list": ["\ufeffusing Serilog;\nusing System.Diagnostics;\nusing System.Net;\nusing System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing System.Text;\n\nnamespace OGXbdmDumper\n{\n    public class ConnectionInfo\n    {", "{\n    public class ConnectionInfo\n    {\n        public IPEndPoint Endpoint { get; set; }\n        public string? Name { get; set; }\n\n        public ConnectionInfo(IPEndPoint endpoint, string? name = null)\n        {\n            Endpoint = endpoint;\n            Name = name;\n        }\n", "        public static List<ConnectionInfo> DiscoverXbdm(int port, int timeout = 500)\n        {\n            Log.Information(\"Performing Xbox debug monitor network discovery broadcast on UDP port {Port}.\", port);\n\n            var connections = new List<ConnectionInfo>();\n            byte[] datagramBuffer = new byte[1024];\n\n            // iterate through each network interface\n            Parallel.ForEach(NetworkInterface.GetAllNetworkInterfaces(), nic =>\n            {\n                // only worry about active IPv4 interfaces", "                if (nic.OperationalStatus != OperationalStatus.Up || !nic.Supports(NetworkInterfaceComponent.IPv4))\n                    return;\n\n                // iterate through each ip address assigned to the interface\n                Parallel.ForEach(nic.GetIPProperties().UnicastAddresses, ip =>\n                {\n                    // don't bother broadcasting from IPv6 or loopback addresses\n                    if (ip.Address.AddressFamily == AddressFamily.InterNetworkV6 || IPAddress.IsLoopback(ip.Address))\n                        return;\n\n                    try\n                    {\n                        const short wildcardDiscoveryType = 3;\n\n                        Log.Verbose(\"Broadcasting wildcard discovery packet from {IP} on interface {Name}\",\n                            $\"{ip.Address}/{ip.PrefixLength}\", nic.Name);\n\n                        // broadcast wildcard discovery packet\n                        using var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);\n                        socket.EnableBroadcast = true;\n                        socket.Bind(new IPEndPoint(ip.Address, 0));\n                        socket.SendTo(BitConverter.GetBytes(wildcardDiscoveryType), new IPEndPoint(IPAddress.Broadcast, port));\n\n                        // listen for any responses\n                        var timer = Stopwatch.StartNew();", "                        while (timer.ElapsedMilliseconds < timeout)\n                        {\n                            if (socket.Available == 0)\n                            {\n                                System.Threading.Thread.Sleep(1);\n                                continue;\n                            }\n\n                            // receive the response\n                            EndPoint endpoint = new IPEndPoint(IPAddress.Any, 0);\n                            int bytesReceived = socket.ReceiveFrom(datagramBuffer, datagramBuffer.Length, SocketFlags.None, ref endpoint);\n\n                            // perform some simple sanity checks to be more certain it was an xbox device that has responded and not some freak chance of nature", "                            if (bytesReceived >= 2)\n                            {\n                                int nameLength = datagramBuffer[1];\n                                if (datagramBuffer[0] == 2 && nameLength + 2 == bytesReceived)\n                                {\n                                    string xboxName = Encoding.ASCII.GetString(datagramBuffer, 2, nameLength);\n                                    var foundXbox = new ConnectionInfo((IPEndPoint)endpoint, xboxName);\n\n                                    // skip duplicates in the case that multiple ip addresses sharing the same subnet are assigned to an interface\n                                    if (!connections.Contains(foundXbox))\n                                    {\n                                        Log.Information(\"Discovered an Xbox named {Name} at {Address}\", foundXbox.Name, foundXbox.Endpoint);\n                                        connections.Add(foundXbox);\n                                    }\n                                }\n                            }\n\n                            // reset the timer and keep listening for any additional responses\n                            timer = Stopwatch.StartNew();\n                        }\n                    }", "                                    if (!connections.Contains(foundXbox))\n                                    {\n                                        Log.Information(\"Discovered an Xbox named {Name} at {Address}\", foundXbox.Name, foundXbox.Endpoint);\n                                        connections.Add(foundXbox);\n                                    }\n                                }\n                            }\n\n                            // reset the timer and keep listening for any additional responses\n                            timer = Stopwatch.StartNew();\n                        }\n                    }", "                    catch (Exception ex)\n                    {\n                        Log.Warning(ex, \"An error has occurred during Xbox network discovery.\");\n                    }\n                });\n            });\n\n            return connections;\n        }\n    }\n}"]}
{"filename": "src/OGXbdmDumper/Module.cs", "chunked_list": ["\ufeffusing System.Diagnostics;\n\nnamespace OGXbdmDumper\n{\n    /// <summary>\n    /// TODO: description\n    /// </summary>\n    [DebuggerDisplay(\"{\" + nameof(Name) + \"}\")]\n    public class Module\n    {\n        /// <summary>\n        /// Name of the module that was loaded.\n        /// </summary>\n        public string? Name;\n\n        /// <summary>\n        /// Address that the module was loaded to.\n        /// </summary>", "    public class Module\n    {\n        /// <summary>\n        /// Name of the module that was loaded.\n        /// </summary>\n        public string? Name;\n\n        /// <summary>\n        /// Address that the module was loaded to.\n        /// </summary>\n        public uint BaseAddress;\n\n        /// <summary>\n        /// Size of the module.\n        /// </summary>", "        public uint BaseAddress;\n\n        /// <summary>\n        /// Size of the module.\n        /// </summary>\n        public int Size;\n\n        /// <summary>\n        /// Time stamp of the module.\n        /// </summary>\n        public DateTime TimeStamp;\n\n        /// <summary>\n        /// Checksum of the module.\n        /// </summary>", "        public DateTime TimeStamp;\n\n        /// <summary>\n        /// Checksum of the module.\n        /// </summary>\n        public uint Checksum;\n\n        /// <summary>\n        /// Sections contained within the module.\n        /// </summary>\n        public List<ModuleSection>? Sections;\n\n        /// <summary>\n        /// Indicates whether or not the module uses TLS.\n        /// </summary>", "        public bool HasTls;\n\n        /// <summary>\n        /// Indicates whether or not the module is an Xbox executable.\n        /// </summary>\n        public bool IsXbe;\n\n        /// <summary>\n        /// Gets an Xbox module section by name.\n        /// </summary>\n        /// <param name=\"name\"></param>\n        /// <returns></returns>\n        public ModuleSection? GetSection(string name)\n        {\n            return Sections?.FirstOrDefault(section => name.Equals(section?.Name));\n        }\n    }\n}\n"]}
{"filename": "src/OGXbdmDumper/KernelExports.cs", "chunked_list": ["\ufeffusing PeNet.Header.Pe;\n\nnamespace OGXbdmDumper\n{\n    /// <summary>\n    /// TODO: description\n    /// </summary>\n    public class KernelExports\n    {\n        private ExportFunction[] _functions;\n        private readonly long _kernelBase;\n\n        #region Exports\n\n        /// <summary>\n        /// \n        /// </summary>", "        private readonly long _kernelBase;\n\n        #region Exports\n\n        /// <summary>\n        /// \n        /// </summary>\n        public long HalReadSMBusValue { get; }\n\n        /// <summary>\n        /// \n        /// </summary>", "        public long NtClose { get; }\n\n        /// <summary>\n        /// \n        /// </summary>\n        public long NtDeviceIoControlFile { get; }\n\n        /// <summary>\n        /// \n        /// </summary>\n        public long NtOpenFile { get; }\n\n        /// <summary>\n        /// \n        /// </summary>", "        public long NtOpenFile { get; }\n\n        /// <summary>\n        /// \n        /// </summary>\n        public long NtReadFile { get; }\n\n        /// <summary>\n        /// \n        /// </summary>\n        public long RtlFreeAnsiString { get; }\n\n        /// <summary>\n        /// \n        /// </summary>", "        public long RtlFreeAnsiString { get; }\n\n        /// <summary>\n        /// \n        /// </summary>\n        public long RtlInitAnsiString { get; }\n\n        /// <summary>\n        /// \n        /// </summary>\n        public long XboxKrnlVersion { get; }\n\n        /// <summary>\n        /// \n        /// </summary>", "        public long XboxKrnlVersion { get; }\n\n        /// <summary>\n        /// \n        /// </summary>\n        public long MmAllocateContiguousMemory { get; }\n\n        /// <summary>\n        /// \n        /// </summary>\n        public long MmFreeContiguousMemory { get; }\n\n        #endregion\n\n        /// <summary>\n        /// Index signifies ordinal number.\n        /// </summary>\n        /// <param name=\"kernelBase\"></param>\n        /// <param name=\"functions\"></param>\n        public KernelExports(long kernelBase, ExportFunction[] functions)\n        {\n            _kernelBase = kernelBase;\n            _functions = functions;\n\n            // TODO: guestimate, dvt4/retail seemed to have at least 366 whereas dvt3/beta around 345\n            bool isBeta = functions.Length < 360;\n\n            HalReadSMBusValue = Resolve(isBeta ? 339 : 45);\n            NtClose = Resolve(isBeta ? 183 : 187);\n            NtDeviceIoControlFile = Resolve(isBeta ? 192 : 196);\n            NtOpenFile = Resolve(isBeta ? 199 : 202);\n            NtReadFile = Resolve(isBeta ? 216 : 219);\n            RtlFreeAnsiString = Resolve(isBeta ? 282 : 286);\n            RtlInitAnsiString = Resolve(isBeta ? 285 : 289);\n            XboxKrnlVersion = Resolve(isBeta ? 316 : 324);\n            MmAllocateContiguousMemory = Resolve(isBeta ? 161 : 165);\n            MmFreeContiguousMemory = Resolve(isBeta ? 166 : 171);\n        }\n", "        public long MmFreeContiguousMemory { get; }\n\n        #endregion\n\n        /// <summary>\n        /// Index signifies ordinal number.\n        /// </summary>\n        /// <param name=\"kernelBase\"></param>\n        /// <param name=\"functions\"></param>\n        public KernelExports(long kernelBase, ExportFunction[] functions)\n        {\n            _kernelBase = kernelBase;\n            _functions = functions;\n\n            // TODO: guestimate, dvt4/retail seemed to have at least 366 whereas dvt3/beta around 345\n            bool isBeta = functions.Length < 360;\n\n            HalReadSMBusValue = Resolve(isBeta ? 339 : 45);\n            NtClose = Resolve(isBeta ? 183 : 187);\n            NtDeviceIoControlFile = Resolve(isBeta ? 192 : 196);\n            NtOpenFile = Resolve(isBeta ? 199 : 202);\n            NtReadFile = Resolve(isBeta ? 216 : 219);\n            RtlFreeAnsiString = Resolve(isBeta ? 282 : 286);\n            RtlInitAnsiString = Resolve(isBeta ? 285 : 289);\n            XboxKrnlVersion = Resolve(isBeta ? 316 : 324);\n            MmAllocateContiguousMemory = Resolve(isBeta ? 161 : 165);\n            MmFreeContiguousMemory = Resolve(isBeta ? 166 : 171);\n        }\n", "        private long Resolve(int ordinal)\n        {\n            foreach (var function in _functions)\n            {\n                if (function.Ordinal == ordinal)\n                    return _kernelBase + function.Address;\n            }\n            return 0;\n        }\n    }\n}\n"]}
{"filename": "src/OGXbdmDumper/Kernel.cs", "chunked_list": ["\ufeffusing Serilog.Events;\nusing Serilog;\nusing System.ComponentModel;\nusing System.Diagnostics;\nusing System.Reflection;\nusing PeNet;\n\nnamespace OGXbdmDumper\n{\n    /// <summary>\n    /// An interface to the Xbox kernel.\n    /// </summary>", "{\n    /// <summary>\n    /// An interface to the Xbox kernel.\n    /// </summary>\n    public class Kernel\n    {\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n        private readonly Xbox _xbox;\n\n        /// <summary>\n        /// The file name.\n        /// </summary>", "        public const string Name = \"xboxkrnl.exe\";\n\n        /// <summary>\n        /// The kernel module information. Note: Internally caches result for future use.\n        /// </summary>\n        public readonly Module Module;\n\n        /// <summary>\n        /// The kernel image size. NOTE: May not be contiguous memory.\n        /// </summary>\n        public int Size => Module.Size;\n\n        /// <summary>\n        /// The kernel base address in memory.\n        /// </summary>", "        public int Size => Module.Size;\n\n        /// <summary>\n        /// The kernel base address in memory.\n        /// </summary>\n        public long Address => Module.BaseAddress;\n\n        /// <summary>\n        /// The kernel build time in UTC.\n        /// </summary>\n        public DateTime Date => Module.TimeStamp;\n\n        /// <summary>\n        /// The Xbox kernel build version.\n        /// </summary>", "        public DateTime Date => Module.TimeStamp;\n\n        /// <summary>\n        /// The Xbox kernel build version.\n        /// </summary>\n        public Version Version { get; private set; }\n\n        /// <summary>\n        /// The kernel exports.\n        /// </summary>\n        public KernelExports Exports { get; private set; }\n\n        /// <summary>\n        /// Initializes communication with the Xbox kernel.\n        /// </summary>\n        /// <param name=\"xbox\"></param>\n        public Kernel(Xbox xbox)\n        {\n            _xbox = xbox ??\n                throw new ArgumentNullException(nameof(xbox));\n\n            Module = xbox.Modules.Find(m => m.Name == Name) ??\n                throw new NullReferenceException(string.Format(\"Failed to load {0} module information!\", Name));\n\n            // TODO: remove 3rd-party dependency with proper PE parsing logic\n            // grab enough of the kernel in memory to allow parsing it (possibly only need through the data section)\n            var initSection = Module.Sections.Find(m => m.Name == \"INIT\");\n            int size = (int)(initSection.Base - Address);\n            var pe = new PeFile(_xbox.Memory.ReadBytes(Address, size));\n\n            // resolve exports\n            Exports = new KernelExports(Address, pe.ExportedFunctions);\n\n            // get the version\n            Version = xbox.Memory.ReadInt32(Exports.XboxKrnlVersion).ToVersion();\n\n            // log export disassembly for debugging purposes when verbose is enabled", "        public KernelExports Exports { get; private set; }\n\n        /// <summary>\n        /// Initializes communication with the Xbox kernel.\n        /// </summary>\n        /// <param name=\"xbox\"></param>\n        public Kernel(Xbox xbox)\n        {\n            _xbox = xbox ??\n                throw new ArgumentNullException(nameof(xbox));\n\n            Module = xbox.Modules.Find(m => m.Name == Name) ??\n                throw new NullReferenceException(string.Format(\"Failed to load {0} module information!\", Name));\n\n            // TODO: remove 3rd-party dependency with proper PE parsing logic\n            // grab enough of the kernel in memory to allow parsing it (possibly only need through the data section)\n            var initSection = Module.Sections.Find(m => m.Name == \"INIT\");\n            int size = (int)(initSection.Base - Address);\n            var pe = new PeFile(_xbox.Memory.ReadBytes(Address, size));\n\n            // resolve exports\n            Exports = new KernelExports(Address, pe.ExportedFunctions);\n\n            // get the version\n            Version = xbox.Memory.ReadInt32(Exports.XboxKrnlVersion).ToVersion();\n\n            // log export disassembly for debugging purposes when verbose is enabled", "            if (Log.Logger.IsEnabled(LogEventLevel.Verbose))\n            {\n                foreach (PropertyInfo prop in Exports.GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance))\n                {\n                    if (prop.Name.Equals(\"XboxKrnlVersion\"))\n                        continue;\n\n                    Log.Verbose(\"{0} disassembly snippet.\" + Environment.NewLine + \n                        xbox.GetDisassembly(prop.GetValue<long>(Exports), 64).ToString(), prop.Name);\n                }\n            }\n        }\n\n        #region Exports\n", "        public void HalReadSMBusValue(int address, int command, bool writeWord, uint valuePtr)\n        {\n            if (_xbox.Call(Exports.HalReadSMBusValue, address, command, writeWord, valuePtr) != 0)\n                throw new Exception();\n        }\n\n        public uint NtOpenFile(uint fileHandlePtr, uint desiredAccess, uint objectAttributesPtr, uint ioStatusBlockPtr, uint shareAccess, uint openOptions)\n        {\n            int status = (int)_xbox.Call(Exports.NtOpenFile, fileHandlePtr, desiredAccess, objectAttributesPtr, ioStatusBlockPtr, shareAccess, openOptions);\n            if (status != 0)\n                throw new Win32Exception(status);\n\n            return _xbox.Memory.ReadUInt32(fileHandlePtr);\n        }\n", "            if (status != 0)\n                throw new Win32Exception(status);\n\n            return _xbox.Memory.ReadUInt32(fileHandlePtr);\n        }\n\n        public void NtReadFile(uint fileHandlePtr, uint eventPtr, uint apcRoutinePtr, uint apcContextPtr, uint ioStatusBlockPtr, uint bufferPtr, uint length, uint byteOffsetPtr)\n        {\n            int status = (int)_xbox.Call(Exports.NtReadFile, fileHandlePtr, eventPtr, apcRoutinePtr, apcContextPtr, ioStatusBlockPtr, bufferPtr, length, byteOffsetPtr);\n            if (status != 0)\n                throw new Win32Exception(status);\n        }\n", "            if (status != 0)\n                throw new Win32Exception(status);\n        }\n\n        public void NtClose(uint fileHandlePtr)\n        {\n            int status = (int)_xbox.Call(Exports.NtClose, fileHandlePtr);\n            if (status != 0)\n                throw new Win32Exception(status);\n        }\n\n        /// <summary>\n        /// Allocates physical memory.\n        /// </summary>\n        /// <param name=\"size\">The allocation size.</param>\n        /// <returns>Returns the allocation address, or zero if unsuccessful.</returns>", "        public long MmAllocateContiguousMemory(int size)\n        {\n            return _xbox.Call(_xbox.Kernel.Exports.MmAllocateContiguousMemory, size);\n        }\n\n        /// <summary>\n        /// Frees physical memory on the xbox.\n        /// </summary>\n        /// <param name=\"address\">Memory address.</param>\n        /// <returns>Returns true if successful.</returns>\n        public bool MmFreeContiguousMemory(long address)\n        {\n            return _xbox.Call(_xbox.Kernel.Exports.MmFreeContiguousMemory, address) != 0;\n        }\n\n        #endregion\n    }\n}\n", "        public bool MmFreeContiguousMemory(long address)\n        {\n            return _xbox.Call(_xbox.Kernel.Exports.MmFreeContiguousMemory, address) != 0;\n        }\n\n        #endregion\n    }\n}\n"]}
{"filename": "src/OGXbdmDumper/Connection.cs", "chunked_list": ["\ufeffusing Serilog;\nusing System.Diagnostics;\nusing System.Net;\nusing System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\nnamespace OGXbdmDumper\n{\n    public class Connection : Stream\n    {\n        #region Properties\n", "namespace OGXbdmDumper\n{\n    public class Connection : Stream\n    {\n        #region Properties\n\n        private bool _disposed;\n\n        private TcpClient _client;\n\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]", "        private TcpClient _client;\n\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n        private static ReadOnlySpan<byte> NewLineBytes => new byte[] { (byte)'\\r', (byte)'\\n' };\n\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]\n        private const string NewLineString = \"\\r\\n\";\n\n        /// <summary>\n        /// The binary reader for the session stream.\n        /// </summary>", "        public BinaryReader Reader { get; private set; }\n\n        /// <summary>\n        /// The binary writer for the session stream.\n        /// </summary>\n        public BinaryWriter Writer { get; private set; }\n\n        /// <summary>\n        /// Returns true if the session thinks it's connected based on the most recent operation.\n        /// </summary>\n        public bool IsConnected => _client.Connected;\n\n        /// <summary>\n        /// The time in milliseconds to wait while sending data before throwing a TimeoutException.\n        /// </summary>", "        public bool IsConnected => _client.Connected;\n\n        /// <summary>\n        /// The time in milliseconds to wait while sending data before throwing a TimeoutException.\n        /// </summary>\n        public int SendTimeout { get => _client.SendTimeout; set => _client.SendTimeout = value; }\n\n        /// <summary>\n        /// The time in milliseconds to wait while receiving data before throwing a TimeoutException.\n        /// </summary>\n        public int ReceiveTimeout { get => _client.ReceiveTimeout; set => _client.ReceiveTimeout = value; }\n\n        #endregion\n\n        #region Construction\n\n        /// <summary>\n        /// Initializes the session.\n        /// </summary>\n        public Connection()\n        {\n            // initialize defaults\n            Reader = new BinaryReader(this);\n            Writer = new BinaryWriter(this);\n            ResetTcp();\n        }\n\n        #endregion\n\n        #region Methods\n\n        /// <summary>\n        /// Resets the internal TCP client state.\n        /// </summary>", "        public int ReceiveTimeout { get => _client.ReceiveTimeout; set => _client.ReceiveTimeout = value; }\n\n        #endregion\n\n        #region Construction\n\n        /// <summary>\n        /// Initializes the session.\n        /// </summary>\n        public Connection()\n        {\n            // initialize defaults\n            Reader = new BinaryReader(this);\n            Writer = new BinaryWriter(this);\n            ResetTcp();\n        }\n\n        #endregion\n\n        #region Methods\n\n        /// <summary>\n        /// Resets the internal TCP client state.\n        /// </summary>", "        private void ResetTcp()\n        {\n            // preserve previous settings or specify new defaults\n            int sendTimeout = _client?.SendTimeout ?? 10000;\n            int receiveTimeout = _client?.ReceiveTimeout ?? 10000;\n            int sendBufferSize = _client?.SendBufferSize ?? 1024 * 1024 * 2;\n            int receiveBufferSize = _client?.ReceiveBufferSize ?? 1024 * 1024 * 2;\n\n            try\n            {\n                // attempt to disconnect\n                _client?.Client?.Disconnect(false);\n                _client?.Close();\n                _client?.Dispose();\n            }\n            catch { /* do nothing */ }\n\n            // initialize defaults\n            _client = new TcpClient(AddressFamily.InterNetwork)\n            {\n                NoDelay = true,\n                SendTimeout = sendTimeout,\n                ReceiveTimeout = receiveTimeout,\n                SendBufferSize = sendBufferSize,\n                ReceiveBufferSize = receiveBufferSize\n            };\n        }\n\n        /// <summary>\n        /// Connects to the specified host and port.\n        /// </summary>\n        /// <param name=\"host\">The host to connect to.</param>\n        /// <param name=\"port\">The port the host is listening on for the connection.</param>\n        /// <param name=\"timeout\">The time to wait in milliseconds for a connection to complete.</param>\n        /// <returns></returns>\n        /// <exception cref=\"ArgumentNullException\"></exception>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>\n        /// <exception cref=\"TimeoutException\"></exception>\n        /// <exception cref=\"SocketException\"></exception>\n        /// <exception cref=\"ObjectDisposedException\"></exception>\n        /// <exception cref=\"InvalidDataException\"></exception>\n        /// <exception cref=\"Exception\"></exception>", "        public ConnectionInfo Connect(string host, int port, int timeout = 500)\n        {\n            // argument checks\n            if (host == null) throw new ArgumentNullException(nameof(host));\n            if (port <= 0 || port > ushort.MaxValue) throw new ArgumentOutOfRangeException(nameof(port));\n            if (timeout < 0) throw new ArgumentOutOfRangeException(nameof(timeout));\n            if (_disposed) throw new ObjectDisposedException(nameof(Connection));\n\n            Log.Information(\"Connecting to {0}.\", host + \":\" + port);\n            if (!_client.ConnectAsync(host, port).Wait(timeout))\n            {\n                throw new TimeoutException(\"Failed to connect within the specified timeout period.\");\n            }\n            Log.Information(\"Connected via {0}.\", _client.Client.LocalEndPoint);\n\n            // \"201- connected\\r\\n\"\n            var response = ReceiveStatusResponse();", "            if (!_client.ConnectAsync(host, port).Wait(timeout))\n            {\n                throw new TimeoutException(\"Failed to connect within the specified timeout period.\");\n            }\n            Log.Information(\"Connected via {0}.\", _client.Client.LocalEndPoint);\n\n            // \"201- connected\\r\\n\"\n            var response = ReceiveStatusResponse();\n            if (!response.Success)\n                throw new Exception(response.Full);\n\n            // check connection quality\n            var endpoint = _client.Client.RemoteEndPoint as IPEndPoint;\n            var ping = new Ping().Send(endpoint.Address);", "            if (!response.Success)\n                throw new Exception(response.Full);\n\n            // check connection quality\n            var endpoint = _client.Client.RemoteEndPoint as IPEndPoint;\n            var ping = new Ping().Send(endpoint.Address);\n            if (ping.RoundtripTime > 1)\n            {\n                Log.Warning(\"Elevated network latency of {0}ms detected. Please have wired connectivity to your Xbox for fastest results.\", ping.RoundtripTime);\n            }\n\n            return new ConnectionInfo(endpoint);\n        }\n\n        /// <summary>\n        /// Closes the connection.\n        /// </summary>", "        public void Disconnect()\n        {\n            if (_disposed) throw new ObjectDisposedException(nameof(Connection));\n\n            Log.Information(\"Disconnecting.\");\n\n            // avoid port exhaustion by attempting to gracefully inform the xbox we're leaving\n            TrySendCommandText(\"bye\");\n\n            ResetTcp();\n        }\n\n        /// <summary>\n        /// Waits for a single line of text to be available before receiving it.\n        /// </summary>\n        /// <param name=\"timeout\">The optional receive timeout in milliseconds, overriding the session timeout.</param>\n        /// <returns></returns>\n        /// <exception cref=\"TimeoutException\"></exception>\n        /// <exception cref=\"ObjectDisposedException\"></exception>\n        /// <exception cref=\"SocketException\"></exception>", "        public string ReceiveLine(int? timeout = null)\n        {\n            if (_disposed) throw new ObjectDisposedException(nameof(Connection));\n\n            Stopwatch timer = Stopwatch.StartNew();\n            Span<byte> buffer = stackalloc byte[1024];\n\n            while ((timeout ?? ReceiveTimeout) == 0 || timer.ElapsedMilliseconds < (timeout ?? ReceiveTimeout))\n            {\n                Wait();\n\n                // new line can't possibly exist", "                if (_client.Available < NewLineBytes.Length) continue;\n\n                // peek into the receive buffer for a new line\n                int bytesRead = _client.Client.Receive(buffer, SocketFlags.Peek);\n                int newLineIndex = buffer.Slice(0, bytesRead).IndexOf(NewLineBytes);\n\n                // new line doesn't exist yet\n                if (newLineIndex == -1) continue;\n\n                // receive the line\n                _client.Client.Receive(buffer.Slice(0, newLineIndex + NewLineBytes.Length));\n                string line = Encoding.ASCII.GetString(buffer.Slice(0, newLineIndex).ToArray());\n                Log.Verbose(\"Received line {0}.\", line);\n                return line;\n            }\n\n            throw new TimeoutException();\n        }\n\n        /// <summary>\n        /// Receives multiple lines of text discarding the '.' delimiter at the end.\n        /// </summary>\n        /// <param name=\"timeout\">The optional receive timeout in milliseconds, overriding the session timeout.</param>\n        /// <returns></returns>\n        /// <exception cref=\"TimeoutException\"></exception>\n        public List<string> ReceiveMultilineResponse(int? timeout = null)\n        {", "            if (_disposed) throw new ObjectDisposedException(nameof(Connection));\n\n            Log.Verbose(\"Receiving multiline response.\");\n\n            List<string> lines = new List<string>();\n\n            string line;\n            while ((line = ReceiveLine(timeout)) != \".\")\n            {\n                lines.Add(line);\n            }\n\n            return lines;\n        }\n\n        /// <summary>\n        /// Clears the specified amount of data from the receive buffer.\n        /// </summary>\n        /// <param name=\"size\"></param>\n        /// <exception cref=\"TimeoutException\"></exception>\n        /// <exception cref=\"ObjectDisposedException\"></exception>\n        /// <exception cref=\"SocketException\"></exception>", "        public void ClearReceiveBuffer(int size)\n        {\n            if (_disposed) throw new ObjectDisposedException(nameof(Connection));\n\n            if (size <= 0) return;\n\n            Log.Verbose(\"Clearing {0} bytes from the receive buffer.\", size);\n\n            Span<byte> buffer = stackalloc byte[1024 * 80];\n\n            while (size > 0)\n            {\n                size -= _client.Client.Receive(buffer.Slice(0, Math.Min(buffer.Length, size)));\n            }\n        }\n\n        /// <summary>\n        /// Clears all existing data from the receive buffer.\n        /// </summary>", "            while (size > 0)\n            {\n                size -= _client.Client.Receive(buffer.Slice(0, Math.Min(buffer.Length, size)));\n            }\n        }\n\n        /// <summary>\n        /// Clears all existing data from the receive buffer.\n        /// </summary>\n        public void ClearReceiveBuffer()\n        {\n            ClearReceiveBuffer(_client.Available);\n        }\n\n        /// <summary>\n        /// Sends a command to the xbox without waiting for a response.\n        /// </summary>\n        /// <param name=\"command\">Command to be sent</param>\n        /// <param name=\"args\">Arguments</param>\n        /// <exception cref=\"TimeoutException\"></exception>\n        /// <exception cref=\"IOException\"></exception>\n        /// <exception cref=\"ArgumentNullException\"></exception>\n        /// <exception cref=\"SocketException\"></exception>\n        /// <exception cref=\"ObjectDisposedException\"></exception>\n        /// <exception cref=\"FormatException\"></exception>", "        public void ClearReceiveBuffer()\n        {\n            ClearReceiveBuffer(_client.Available);\n        }\n\n        /// <summary>\n        /// Sends a command to the xbox without waiting for a response.\n        /// </summary>\n        /// <param name=\"command\">Command to be sent</param>\n        /// <param name=\"args\">Arguments</param>\n        /// <exception cref=\"TimeoutException\"></exception>\n        /// <exception cref=\"IOException\"></exception>\n        /// <exception cref=\"ArgumentNullException\"></exception>\n        /// <exception cref=\"SocketException\"></exception>\n        /// <exception cref=\"ObjectDisposedException\"></exception>\n        /// <exception cref=\"FormatException\"></exception>", "        public void SendCommandText(string command, params object[] args)\n        {\n            if (_disposed) throw new ObjectDisposedException(nameof(Connection));\n\n            // attempt to clean up the stream a bit; it's up to the caller to ensure this isn't ran while data is still being received\n            ClearReceiveBuffer(_client.Available);\n   \n            string commandText = string.Format(command, args);\n            Log.Verbose(\"Sending command {0}.\", commandText);\n\n            _client.Client.Send(Encoding.ASCII.GetBytes(commandText + NewLineString));\n        }\n\n        /// <summary>\n        /// Attempts to send a command to the Xbox without waiting for a response.\n        /// </summary>\n        /// <param name=\"command\">Command to be sent</param>\n        /// <param name=\"args\">Arguments</param>\n        /// <returns>Returns true if successful.</returns>", "        public bool TrySendCommandText(string command, params object[] args)\n        {\n            try\n            {\n                SendCommandText(command, args);\n                return true;\n            }\n            catch (Exception e)\n            {\n                Log.Warning(e, \"Command failure ignored.\");\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Sends a command to the xbox and returns the status response.\n        /// Leaves error-handling up to the caller.\n        /// </summary>\n        /// <param name=\"command\">Command to be sent</param>\n        /// <param name=\"args\">Arguments</param>\n        /// <returns>Status response</returns>\n        /// <exception cref=\"TimeoutException\"></exception>\n        /// <exception cref=\"InvalidDataException\"></exception>\n        /// <exception cref=\"SocketException\"></exception>\n        /// <exception cref=\"IOException\"></exception>\n        /// <exception cref=\"ArgumentNullException\"></exception>\n        /// <exception cref=\"ObjectDisposedException\"></exception>\n        /// <exception cref=\"FormatException\"></exception>", "        public CommandResponse SendCommand(string command, params object[] args)\n        {\n            if (_disposed) throw new ObjectDisposedException(nameof(Connection));\n\n            SendCommandText(command, args);\n            return ReceiveStatusResponse();\n        }\n\n        /// <summary>\n        /// Sends a command to the xbox and returns the status response.\n        /// An error response is rethrown as an exception.\n        /// </summary>\n        /// <param name=\"command\">The command to be sent.</param>\n        /// <param name=\"args\">The formatted command arguments.</param>\n        /// <returns>The status response.</returns>\n        /// <exception cref=\"ObjectDisposedException\"></exception>\n        /// <exception cref=\"TimeoutException\"></exception>\n        /// <exception cref=\"InvalidDataException\"></exception>\n        /// <exception cref=\"SocketException\"></exception>\n        /// <exception cref=\"ArgumentNullException\"></exception>\n        /// <exception cref=\"IOException\"></exception>\n        /// <exception cref=\"FormatException\"></exception>\n        /// <exception cref=\"Exception\">Throws varous other types when the command response indicates failure.</exception>", "        public CommandResponse SendCommandStrict(string command, params object[] args)\n        {\n            if (_disposed) throw new ObjectDisposedException(nameof(Connection));\n\n            CommandResponse response = SendCommand(command, args);\n            if (response.Success) return response;\n\n            throw response.Code switch\n            {\n                // TODO: other error codes\n                402 => new FileNotFoundException(response.Full),        // file not found\n                407 => new NotSupportedException(response.Full),        // command not found\n                410 => new IOException(response.Full),                  // file already exists\n                411 => new IOException(response.Full),                  // directory not empty\n                412 => new IOException(response.Full),                  // bad filename\n                413 => new IOException(response.Full),                  // file cannot be created\n                414 => new UnauthorizedAccessException(response.Full),  // access denied\n                423 => new ArgumentException(response.Full),            // argument invalid\n                _ => new Exception(response.Full),\n            };\n        }\n\n        /// <summary>\n        /// Receives a command for a status response to be received from the xbox.\n        /// </summary>\n        /// <param name=\"timeout\">The optional receive timeout in milliseconds, overriding the XbdmSession Timeout.</param>\n        /// <returns></returns>\n        /// <exception cref=\"TimeoutException\"></exception>\n        /// <exception cref=\"InvalidDataException\"></exception>\n        /// <exception cref=\"ObjectDisposedException\"></exception>\n        /// <exception cref=\"SocketException\"></exception>", "        public CommandResponse ReceiveStatusResponse(int? timeout = null)\n        {\n            if (_disposed) throw new ObjectDisposedException(nameof(Connection));\n\n            string response = ReceiveLine(timeout);\n\n            try\n            {\n                return new CommandResponse(response, Convert.ToInt32(response.Remove(3)), response.Remove(0, 5));\n            }\n            catch { throw new InvalidDataException(\"Invalid response.\"); }\n        }\n\n        /// <summary>\n        /// Sleeps for the specified number of milliseconds unless the NoSleep session option is enabled, in which case it does nothing.\n        /// </summary>", "        public void Wait(int milliseconds = 1)\n        {\n            if (_disposed) throw new ObjectDisposedException(nameof(Connection));\n\n            if (milliseconds < 0) return;\n        }\n\n        #endregion\n\n        #region Utilities\n\n        /// <summary>\n        /// Extracts key/value pairs from an Xbox response line.\n        /// Values returned are either strings or UInt32's.\n        /// Keys with a null value are considered flags.\n        /// </summary>\n        /// <param name=\"line\"></param>\n        /// <returns></returns>", "        public static Dictionary<string, object> ParseKvpResponse(string line)\n        {\n            Dictionary<string, object> values = new Dictionary<string, object>();\n\n            // remove any whitespace surrounding equals signs\n            line = Regex.Replace(line, @\"\\s*([=+])\\s*\", \"$1\");\n\n            // split by whitespace and commas, ignoring instances inside double quotes\n            // ([^\\s]+\".*?[^\\\\]\")|([^\\s,]+)\n            foreach (Match item in Regex.Matches(line, @\"([^\\s]+\"\".*?[^\\\\]\"\")|([^\\s,]+)\"))\n            {\n                // attempt to parse key value pair\n                Match kvp = Regex.Match(item.Value, @\"([^=]+)=(.+)\");", "            foreach (Match item in Regex.Matches(line, @\"([^\\s]+\"\".*?[^\\\\]\"\")|([^\\s,]+)\"))\n            {\n                // attempt to parse key value pair\n                Match kvp = Regex.Match(item.Value, @\"([^=]+)=(.+)\");\n                if (kvp.Success)\n                {\n                    string name = kvp.Groups[1].Value;\n                    string value = kvp.Groups[2].Value;\n\n                    if (value.StartsWith(\"\\\"\"))\n                    {\n                        // string\n                        values[name] = value.Trim('\"');\n                    }", "                    if (value.StartsWith(\"\\\"\"))\n                    {\n                        // string\n                        values[name] = value.Trim('\"');\n                    }\n                    else if (value.StartsWith(\"0x\"))\n                    {\n                        // hexidecimal integer\n                        values[name] = Convert.ToUInt32(value, 16);\n                    }\n                    else if (uint.TryParse(value, out uint uintValue))\n                    {\n                        // decimal integer\n                        values[name] = uintValue;\n                    }\n                    else\n                    {\n                        throw new InvalidCastException(line);\n                    }\n                }\n                else\n                {\n                    // otherwise it must be a flag\n                    values[item.Value] = null;\n                }\n            }\n\n            return values;\n        }\n\n        #endregion\n\n        #region Stream Implementation\n", "                    else if (uint.TryParse(value, out uint uintValue))\n                    {\n                        // decimal integer\n                        values[name] = uintValue;\n                    }\n                    else\n                    {\n                        throw new InvalidCastException(line);\n                    }\n                }\n                else\n                {\n                    // otherwise it must be a flag\n                    values[item.Value] = null;\n                }\n            }\n\n            return values;\n        }\n\n        #endregion\n\n        #region Stream Implementation\n", "        public override bool CanRead => true;\n\n        public override bool CanSeek => false;\n\n        public override bool CanWrite => true;\n\n        public override long Length => throw new NotSupportedException();\n\n        public override long Position { get => throw new NotSupportedException(); set => throw new NotSupportedException(); }\n\n        public override int Read(byte[] buffer, int offset, int count)\n        {\n            // argument checks", "        public override long Position { get => throw new NotSupportedException(); set => throw new NotSupportedException(); }\n\n        public override int Read(byte[] buffer, int offset, int count)\n        {\n            // argument checks\n            if (buffer == null) throw new ArgumentNullException(nameof(buffer));\n            if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));\n            if (count <= 0) throw new ArgumentOutOfRangeException(nameof(count));\n            if (_disposed) throw new ObjectDisposedException(nameof(Connection));\n\n            // ensure it blocks for the full amount requested\n            int bytesRead = 0;", "            if (_disposed) throw new ObjectDisposedException(nameof(Connection));\n\n            // ensure it blocks for the full amount requested\n            int bytesRead = 0;\n            while (bytesRead < count)\n            {\n                bytesRead += _client.Client.Receive(buffer, offset + bytesRead, count - bytesRead, SocketFlags.None);\n            }\n\n            return bytesRead;\n        }\n", "        public override void Write(byte[] buffer, int offset, int count)\n        {\n            // argument checks\n            if (buffer == null) throw new ArgumentNullException(nameof(buffer));\n            if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));\n            if (count <= 0) throw new ArgumentOutOfRangeException(nameof(count));\n            if (_disposed) throw new ObjectDisposedException(nameof(Connection));\n\n            int bytesWritten = _client.Client.Send(buffer, offset, count, SocketFlags.None);\n\n            // ensure all bytes are written", "            if (bytesWritten != count)\n                throw new Exception(string.Format(\"Partial write of {0} out of {1} bytes total.\", bytesWritten, count));\n        }\n\n        /// <summary>\n        /// Does nothing.\n        /// </summary>\n        public override void Flush()\n        {\n\n        }\n\n        /// <summary>\n        /// Not supported.\n        /// </summary>\n        /// <param name=\"offset\"></param>\n        /// <param name=\"origin\"></param>\n        /// <returns></returns>", "        public override long Seek(long offset, SeekOrigin origin)\n        {\n            throw new NotSupportedException();\n        }\n\n        /// <summary>\n        /// Not supported.\n        /// </summary>\n        /// <param name=\"value\"></param>\n        public override void SetLength(long value)\n        {\n            throw new NotSupportedException();\n        }\n\n        #endregion\n\n        #region IDisposable Implementation\n", "        public override void SetLength(long value)\n        {\n            throw new NotSupportedException();\n        }\n\n        #endregion\n\n        #region IDisposable Implementation\n\n        protected override void Dispose(bool disposing)\n        {", "        protected override void Dispose(bool disposing)\n        {\n            if (!_disposed)\n            {\n                // TODO: free unmanaged resources (unmanaged objects) and override finalizer\n                Disconnect();\n\n                if (disposing)\n                {\n                    // TODO: dispose managed state (managed objects)\n                }\n\n                // TODO: set large fields to null\n                _disposed = true;\n            }\n        }\n\n        // TODO: override finalizer only if 'Dispose(bool disposing)' has code to free unmanaged resources\n        ~Connection()\n        {\n            // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method\n            Dispose(disposing: false);\n        }\n", "        public new void Dispose()\n        {\n            // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method\n            Dispose(disposing: true);\n            GC.SuppressFinalize(this);\n        }\n\n        #endregion\n    }\n}"]}
{"filename": "src/OGXbdmDumper/Extensions.cs", "chunked_list": ["\ufeffusing Iced.Intel;\nusing System.Collections;\nusing System.Reflection;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\nnamespace OGXbdmDumper\n{\n    public static class Extensions\n    {\n        #region Misc\n\n        /// <summary>\n        /// Converts an Int32 into a Version.\n        /// </summary>\n        /// <param name=\"version\"></param>\n        /// <returns></returns>", "    public static class Extensions\n    {\n        #region Misc\n\n        /// <summary>\n        /// Converts an Int32 into a Version.\n        /// </summary>\n        /// <param name=\"version\"></param>\n        /// <returns></returns>\n        public static Version ToVersion(this int version)\n        {\n            return new Version(version & 0xFF, (version >> 8) & 0xFF,\n                (version >> 16) & 0xFF, version >> 24);\n        }\n\n        #endregion\n\n        #region String\n\n        /// <summary>\n        /// Extracts name/value pairs from an Xbox response line.\n        /// </summary>\n        /// <param name=\"line\"></param>\n        /// <returns></returns>", "        public static Version ToVersion(this int version)\n        {\n            return new Version(version & 0xFF, (version >> 8) & 0xFF,\n                (version >> 16) & 0xFF, version >> 24);\n        }\n\n        #endregion\n\n        #region String\n\n        /// <summary>\n        /// Extracts name/value pairs from an Xbox response line.\n        /// </summary>\n        /// <param name=\"line\"></param>\n        /// <returns></returns>", "        public static Dictionary<string, object> ParseXboxResponseLine(this string line)\n        {\n            Dictionary<string, object> values = new Dictionary<string, object>();\n            var items = Regex.Matches(line, @\"(\\S+)\\s*=\\s*(\"\"(?:[^\"\"]|\"\"\"\")*\"\"|\\S+)\");\n\n            foreach (Match item in items)\n            {\n                string name = item.Groups[1].Value;\n                string value = item.Groups[2].Value;\n\n                long longValue;", "                if (value.StartsWith(\"\\\"\"))\n                {\n                    // string\n                    values[name] = value.Trim('\"');\n                }\n                else if (value.StartsWith(\"0x\"))\n                {\n                    // hexidecimal integer\n                    values[name] = Convert.ToInt64(value, 16);\n                }\n                else if (long.TryParse(value, out longValue))\n                {\n                    // decimal integer\n                    values[name] = longValue;\n                }\n                else\n                {\n                    throw new InvalidCastException(\"Unknown data type\");\n                }\n            }\n\n            return values;\n        }\n\n        #endregion\n\n        #region Arrays\n\n        /// <summary>\n        /// Fills the specified byte array with random data.\n        /// </summary>\n        /// <param name=\"data\"></param>\n        /// <returns>Returns a reference of itself.</returns>", "                else if (long.TryParse(value, out longValue))\n                {\n                    // decimal integer\n                    values[name] = longValue;\n                }\n                else\n                {\n                    throw new InvalidCastException(\"Unknown data type\");\n                }\n            }\n\n            return values;\n        }\n\n        #endregion\n\n        #region Arrays\n\n        /// <summary>\n        /// Fills the specified byte array with random data.\n        /// </summary>\n        /// <param name=\"data\"></param>\n        /// <returns>Returns a reference of itself.</returns>", "        public static byte[] FillRandom(this byte[] data)\n        {\n            for (int i = 0; i < data.Length; i++)\n            {\n                data[i] = (byte)Utility.Random.Next(byte.MaxValue);\n            }\n            return data;\n        }\n\n        /// <summary>\n        /// Fills the specified byte array with random data.\n        /// </summary>\n        /// <param name=\"data\"></param>\n        /// <returns>Returns a reference of itself.</returns>", "        public static Span<byte> FillRandom(this Span<byte> data)\n        {\n            for (int i = 0; i < data.Length; i++)\n            {\n                data[i] = (byte)Utility.Random.Next(byte.MaxValue);\n            }\n            return data;\n        }\n\n        /// <summary>\n        /// Checks if the underlying data is equal.\n        /// </summary>\n        /// <param name=\"sourceData\"></param>\n        /// <param name=\"data\"></param>\n        /// <returns></returns>", "        public static bool IsEqual(this byte[] sourceData, byte[] data)\n        {\n            return StructuralComparisons.StructuralEqualityComparer.Equals(sourceData, data);\n        }\n\n        /// <summary>\n        /// Checks if the underlying data is equal.\n        /// </summary>\n        /// <param name=\"sourceData\"></param>\n        /// <param name=\"data\"></param>\n        /// <returns></returns>", "        public static bool IsEqual(this Span<byte> sourceData, Span<byte> data)\n        {\n            return MemoryExtensions.SequenceEqual(sourceData, data);\n        }\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        /// <param name=\"data\"></param>\n        /// <param name=\"pattern\"></param>\n        /// <param name=\"startIndex\"></param>\n        /// <returns></returns>", "        public static int IndexOfArray(this byte[] data, byte[] pattern, int startIndex = 0)\n        {\n            for (int i = startIndex; i < data.Length; i++)\n            {\n                for (int j = 0; j < pattern.Length; j++)\n                {\n                    if (data[i + j] != pattern[j])\n                        break;\n\n                    if (j == pattern.Length - 1)\n                        return i;\n                }\n            }\n\n            return -1;\n        }\n\n        #endregion\n\n        #region Assembler\n\n        /// <summary>\n        /// Assembles the instructions.\n        /// </summary>\n        /// <param name=\"asm\"></param>\n        /// <param name=\"baseAddress\"></param>\n        /// <returns>Returns the assembled bytes.</returns>", "                    if (j == pattern.Length - 1)\n                        return i;\n                }\n            }\n\n            return -1;\n        }\n\n        #endregion\n\n        #region Assembler\n\n        /// <summary>\n        /// Assembles the instructions.\n        /// </summary>\n        /// <param name=\"asm\"></param>\n        /// <param name=\"baseAddress\"></param>\n        /// <returns>Returns the assembled bytes.</returns>", "        public static byte[] AssembleBytes(this Assembler asm, uint baseAddress)\n        {\n            using var ms = new MemoryStream();\n            asm.Assemble(new StreamCodeWriter(ms), baseAddress);\n            return ms.ToArray();\n        }\n\n        /// <summary>\n        /// Hooks the specified Xbox target address redirecting to the specified cave address.\n        /// Caller must recreate any instructions clobbered by the hook in the cave.\n        /// The hook is 6 bytes long consisting of a push followed by a ret.\n        /// </summary>\n        /// <param name=\"asm\">The assembler.</param>\n        /// <param name=\"target\">The xbox target.</param>\n        /// <param name=\"hookAddress\">The hook address.</param>\n        /// <param name=\"caveAddress\">The cave address.</param>", "        public static void Hook(this Assembler asm, Xbox target, long hookAaddress, long caveAddress)\n        {\n            // store the pushret hook to the cave\n            // TODO: combine writes!\n            target.Memory.Position = hookAaddress;\n            target.Memory.Write((byte)0x68);    // push\n            target.Memory.Write(caveAddress);   // cave address\n            target.Memory.Write((byte)0xC3);    // ret\n        }\n\n        #endregion\n\n        #region Stream\n\n        /// <summary>\n        /// Copies the specified amount of data from the source to desination streams.\n        /// Useful when at least one stream doesn't support the Length property.\n        /// </summary>\n        /// <param name=\"source\">The source stream.</param>\n        /// <param name=\"destination\">The destination stream.</param>\n        /// <param name=\"count\">The amount of data to copy.</param>", "        public static void CopyToCount(this Stream source, Stream destination, long count)\n        {\n            Span<byte> buffer = stackalloc byte[1024 * 80];\n\n            while (count > 0)\n            {\n                var slice = buffer.Slice(0, (int)Math.Min(buffer.Length, count));\n\n                // TODO: optimize via async queuing of reads/writes\n                source.Read(slice);\n                destination.Write(slice);\n\n                count -= slice.Length;\n            }\n        }\n\n        /// <summary>\n        /// Writes a value to a stream.\n        /// </summary>\n        /// <typeparam name=\"T\"></typeparam>\n        /// <param name=\"stream\"></param>\n        /// <param name=\"value\"></param>\n        /// <returns>Returns the number of bytes written.</returns>", "        public static int Write<T>(this Stream stream, T value)\n        {\n            if (value == null) throw new ArgumentNullException(nameof(value));\n\n            long origStreamPosition = stream.Position;\n            using var writer = new BinaryWriter(stream);\n\n            switch (Type.GetTypeCode(typeof(T)))\n            {\n                case TypeCode.Boolean:\n                    writer.Write((bool)(object)value);\n                    break;\n                case TypeCode.Char:\n                    writer.Write((char)(object)value);\n                    break;\n                case TypeCode.SByte:\n                    writer.Write((sbyte)(object)value);\n                    break;\n                case TypeCode.Byte:\n                    writer.Write((byte)(object)value);\n                    break;\n                case TypeCode.Int16:\n                    writer.Write((short)(object)value);\n                    break;\n                case TypeCode.UInt16:\n                    writer.Write((ushort)(object)value);\n                    break;\n                case TypeCode.Int32:\n                    writer.Write((int)(object)value);\n                    break;\n                case TypeCode.UInt32:\n                    writer.Write((uint)(object)value);\n                    break;\n                case TypeCode.Int64:\n                    writer.Write((long)(object)value);\n                    break;\n                case TypeCode.UInt64:\n                    writer.Write((ulong)(object)value);\n                    break;\n                case TypeCode.Single:\n                    writer.Write((float)(object)value);\n                    break;\n                case TypeCode.Double:\n                    writer.Write((double)(object)value);\n                    break;\n                case TypeCode.String:\n                    writer.Write(Encoding.ASCII.GetBytes((string)(object)value));\n                    break;\n                default:\n", "                    if (value is byte[])\n                    {\n                        writer.Write(value as byte[]);\n                        break;\n                    }\n\n                    throw new InvalidCastException();\n            }\n\n            return (int)(stream.Position - origStreamPosition);\n        }\n\n        #endregion\n\n        #region Hex Conversion\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        /// <param name=\"value\"></param>\n        /// <param name=\"padWidth\"></param>\n        /// <returns></returns>", "        public static string ToHexString(this uint value, int padWidth = 0)\n        {\n            // TODO: cleanup\n            return \"0x\" + value.ToString(\"X\" + (padWidth > 0 ? padWidth.ToString() : string.Empty));\n        }\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        /// <param name=\"value\"></param>\n        /// <param name=\"padWidth\"></param>\n        /// <returns></returns>", "        public static string ToHexString(this int value, int padWidth = 0)\n        {\n            // TODO: cleanup\n            return \"0x\" + value.ToString(\"X\" + (padWidth > 0 ? padWidth.ToString() : string.Empty));\n        }\n\n        /// <summary>\n        /// TODO: description\n        /// </summary>\n        /// <param name=\"value\"></param>\n        /// <param name=\"padWidth\"></param>\n        /// <returns></returns>", "        public static string ToHexString(this long value, int padWidth = 0)\n        {\n            // TODO: cleanup\n            return \"0x\" + value.ToString(\"X\" + (padWidth > 0 ? padWidth.ToString() : string.Empty));\n        }\n\n        /// <summary>\n        /// Converts an span array of bytes to a hexidecimal string representation.\n        /// </summary>\n        /// <param name=\"data\"></param>\n        /// <returns></returns>", "        public static string ToHexString(this byte[] data)\n        {\n            StringBuilder hexString = new StringBuilder();\n            for (int i = 0; i < data.Length; i++)\n            {\n                hexString.Append(Convert.ToString(data[i], 16).ToUpperInvariant().PadLeft(2, '0'));\n            }\n            return hexString.ToString();\n        }\n\n        /// <summary>\n        /// Converts an span array of bytes to a hexidecimal string representation.\n        /// </summary>\n        /// <param name=\"data\"></param>\n        /// <returns></returns>", "        public static string ToHexString(this Span<byte> data)\n        {\n            StringBuilder hexString = new StringBuilder();\n            for (int i = 0; i < data.Length; i++)\n            {\n                hexString.Append(Convert.ToString(data[i], 16).ToUpperInvariant().PadLeft(2, '0'));\n            }\n            return hexString.ToString();\n        }\n\n        /// <summary>\n        /// Converts an span array of bytes to a hexidecimal string representation.\n        /// </summary>\n        /// <param name=\"data\"></param>\n        /// <returns></returns>", "        public static string ToHexString(this ReadOnlySpan<byte> data)\n        {\n            StringBuilder hexString = new StringBuilder();\n            for (int i = 0; i < data.Length; i++)\n            {\n                hexString.Append(Convert.ToString(data[i], 16).ToUpperInvariant().PadLeft(2, '0'));\n            }\n            return hexString.ToString();\n        }\n\n        /// <summary>\n        /// Converts a hexidecimal string into byte format in the destination.\n        /// </summary>\n        /// <param name=\"str\"></param>\n        /// <param name=\"destination\"></param>", "        public static void FromHexString(this Span<byte> destination, string str)\n        {\n            if (str.Length == 0 || str.Length % 2 != 0)\n                throw new ArgumentException(\"Invalid hexidecimal string length.\");\n\n            if (destination.Length != str.Length / 2)\n                throw new ArgumentException(\"Invalid size.\", nameof(destination));\n\n            for (int i = 0; i < str.Length / 2; i++)\n            {\n                destination[i] = Convert.ToByte(str.Substring(i * 2, 2), 16);\n            }\n        }\n\n        #endregion\n\n        #region Reflection\n\n        /// <summary>\n        /// Gets the value of the specified member field or property.\n        /// </summary>\n        /// <typeparam name=\"T\"></typeparam>\n        /// <param name=\"member\"></param>\n        /// <param name=\"obj\"></param>\n        /// <returns></returns>", "            for (int i = 0; i < str.Length / 2; i++)\n            {\n                destination[i] = Convert.ToByte(str.Substring(i * 2, 2), 16);\n            }\n        }\n\n        #endregion\n\n        #region Reflection\n\n        /// <summary>\n        /// Gets the value of the specified member field or property.\n        /// </summary>\n        /// <typeparam name=\"T\"></typeparam>\n        /// <param name=\"member\"></param>\n        /// <param name=\"obj\"></param>\n        /// <returns></returns>", "        public static T GetValue<T>(this MemberInfo member, object obj)\n        {\n            return member.MemberType switch\n            {\n                MemberTypes.Field => (T)((FieldInfo)member).GetValue(obj),\n                MemberTypes.Property => (T)((PropertyInfo)member).GetValue(obj),\n                _ => throw new NotImplementedException(),\n            };\n        }\n\n        /// <summary>\n        /// Sets the value of the specified member field or property.\n        /// </summary>\n        /// <typeparam name=\"T\"></typeparam>\n        /// <param name=\"member\"></param>\n        /// <param name=\"obj\"></param>\n        /// <param name=\"value\"></param>", "        public static void SetValue<T>(this MemberInfo member, object obj, T value)\n        {\n            switch (member.MemberType)\n            {\n                case MemberTypes.Field:\n                    ((FieldInfo)member).SetValue(obj, value);\n                    break;\n                case MemberTypes.Property:\n                    ((PropertyInfo)member).SetValue(obj, value);\n                    break;\n                default:\n                    throw new NotImplementedException();\n            }\n        }\n\n        #endregion\n    }\n}\n"]}
{"filename": "src/OGXbdmDumper/Program.cs", "chunked_list": ["\ufeffusing Serilog;\nusing Serilog.Core;\nusing Serilog.Events;\nusing ShellProgressBar;\nusing System.ComponentModel;\nusing System.Diagnostics;\nusing System.Net;\nusing System.Reflection;\nusing DustInTheWind.ConsoleTools.Controls.Menus;\nusing DustInTheWind.ConsoleTools.Controls.InputControls;", "using DustInTheWind.ConsoleTools.Controls.Menus;\nusing DustInTheWind.ConsoleTools.Controls.InputControls;\nusing System;\n\nnamespace OGXbdmDumper\n{\n    internal class Program\n    {\n        /// <summary>\n        /// Allows the switching of log event levels without creating a new logger.\n        /// </summary>\n        [DebuggerBrowsable(DebuggerBrowsableState.Never)]", "        private static readonly LoggingLevelSwitch _levelSwitch = new(LogEventLevel.Information);\n\n        /// <summary>\n        /// The minimum level used to filter message output.\n        /// </summary>\n        public static LogEventLevel LogLevel\n        {\n            get { return _levelSwitch.MinimumLevel; }\n            set\n            {\n                if (value == _levelSwitch.MinimumLevel) return;\n\n                _levelSwitch.MinimumLevel = value;\n                Log.Information(\"File logger level changed to {LogEventLevel}\", value);\n            }\n        }\n\n        static void Main(string[] args)\n        {\n            try\n            {\n                InitializeLogging();\n\n                // obtain a connection\n                using var xbox = GetXboxConnection();\n\n                // create dated folder underneath selection to help prevent accidental overwrites\n                var path = Path.Combine(GetOutputDirectory(), DateTime.Now.ToString(\"yyyyMMddHHmmss\"));\n                Directory.CreateDirectory(path);\n\n                // pause execution to prevent any interference\n                xbox.Stop();\n\n                // dump all the things\n                DumpXbdmMemory(xbox, Path.Combine(path, \"xbdm.dll.memory\"));\n                DumpKernelMemory(xbox, Path.Combine(path, \"xboxkrnl.exe.memory\"));\n                DumpBiosImage(xbox, Path.Combine(path, \"bios.bin\"));\n                ValidateRpc(xbox);\n                DumpEeprom(xbox, Path.Combine(path, \"eeprom.bin\"));\n                DumpHddImage(xbox, Path.Combine(path, \"hdd.img\"));\n                DumpHddFiles(xbox, Path.Combine(path, \"hdd\"));\n\n                // resume execution\n                xbox.Go();\n            }", "                if (value == _levelSwitch.MinimumLevel) return;\n\n                _levelSwitch.MinimumLevel = value;\n                Log.Information(\"File logger level changed to {LogEventLevel}\", value);\n            }\n        }\n\n        static void Main(string[] args)\n        {\n            try\n            {\n                InitializeLogging();\n\n                // obtain a connection\n                using var xbox = GetXboxConnection();\n\n                // create dated folder underneath selection to help prevent accidental overwrites\n                var path = Path.Combine(GetOutputDirectory(), DateTime.Now.ToString(\"yyyyMMddHHmmss\"));\n                Directory.CreateDirectory(path);\n\n                // pause execution to prevent any interference\n                xbox.Stop();\n\n                // dump all the things\n                DumpXbdmMemory(xbox, Path.Combine(path, \"xbdm.dll.memory\"));\n                DumpKernelMemory(xbox, Path.Combine(path, \"xboxkrnl.exe.memory\"));\n                DumpBiosImage(xbox, Path.Combine(path, \"bios.bin\"));\n                ValidateRpc(xbox);\n                DumpEeprom(xbox, Path.Combine(path, \"eeprom.bin\"));\n                DumpHddImage(xbox, Path.Combine(path, \"hdd.img\"));\n                DumpHddFiles(xbox, Path.Combine(path, \"hdd\"));\n\n                // resume execution\n                xbox.Go();\n            }", "            catch (Exception ex)\n            {\n                Log.Fatal(ex, \"Fatal error encountered!\");\n            }\n            finally\n            {\n                // cleanup\n                Log.CloseAndFlush();\n            }\n        }\n", "        public static void InitializeLogging()\n        {\n            // initialize logger\n            Log.Logger = new LoggerConfiguration()\n                .MinimumLevel.ControlledBy(_levelSwitch)\n                .WriteTo.Console(restrictedToMinimumLevel: LogEventLevel.Information)\n                .WriteTo.File(\"log.txt\", buffered: true, flushToDiskInterval: TimeSpan.FromSeconds(1))\n                .CreateLogger();\n\n            // log application information\n            Log.Information(\"https://github.com/Ernegien/OGXbdmDumper\");\n            Log.Information(\"Version {0}\", Assembly.GetExecutingAssembly().GetName().Version);\n\n            // provide the option for additional log capture\n            LogLevel = YesNo(\"Enable verbose file logging?\", false) ? LogEventLevel.Verbose : LogEventLevel.Information;\n        }\n", "        public static Xbox GetXboxConnection()\n        {\n            var xbox = new Xbox();\n\n            // attempt xbox auto-discovery\n            var xboxen = xbox.Discover();\n\n            if (xboxen.Count > 0)\n            {\n                var textMenu = new TextMenu\n                {\n                    TitleText = \"The following Xboxes were discovered on the local network:\",\n                    QuestionText = \"Connect to: \"\n                };", "                for (int i = 0; i < xboxen.Count; i++)\n                {\n                    textMenu.AddItem(new TextMenuItem()\n                    {\n                        Id = i.ToString(),\n                        Text = xboxen[i].Endpoint.Address.ToString() +\n                            (string.IsNullOrWhiteSpace(xboxen[i].Name) ? string.Empty : \" (\" + xboxen[i].Name + \")\")\n                    });\n                }\n                textMenu.AddItem(new TextMenuItem()\n                {\n                    Id = xboxen.Count.ToString(),\n                    Text = \"Other\"\n                });\n\n                textMenu.Display();\n", "                if (textMenu.SelectedIndex < xboxen.Count)\n                {\n                    xbox.Connect(xboxen[textMenu.SelectedIndex.Value].Endpoint);\n                    return xbox;\n                }\n            }\n            else Log.Warning(\"Auto-discovery failed! Manually enter connection information instead.\");\n\n            // manual address entry\n            // TODO: custom parser for ip address\n            string ip = ValueControl<string>.QuickRead(\"IP Address:\");\n            var port = new ValueControl<ushort>(\"Alternate Port [leave blank if no]:\")\n            {\n                AcceptDefaultValue = true,\n                DefaultValue = 731\n            }.Read();\n\n            xbox.Connect(new IPEndPoint(IPAddress.Parse(ip), port));\n            return xbox;\n        }\n", "        public static string GetOutputDirectory()\n        {\n            // TODO: custom parser for path validation\n            var path = ValueControl<string>.QuickRead(\"Enter output directory path:\");\n\n            if (!Directory.Exists(path))\n                throw new DirectoryNotFoundException(path);\n\n            Log.Information(\"Using {0} as the output directory path.\", path);\n            return path;\n        }\n", "        public static void DumpXbdmMemory(Xbox xbox, string path)\n        {\n            if (!YesNo(\"Dump xbdm.dll from memory?\"))\n                return;\n\n            Log.Information(\"Dumping xbdm.dll from memory.\");\n\n            var xbdm = xbox.Modules.Find(m => m.Name == \"xbdm.dll\");\n            if (xbdm != null)\n            {\n                File.WriteAllBytes(path, xbox.Memory.ReadBytes(xbdm.BaseAddress, xbdm.Size));\n            }\n        }\n", "            if (xbdm != null)\n            {\n                File.WriteAllBytes(path, xbox.Memory.ReadBytes(xbdm.BaseAddress, xbdm.Size));\n            }\n        }\n\n        public static void DumpKernelMemory(Xbox xbox, string path)\n        {\n            if (!YesNo(\"Dump xboxkrnl.exe from memory?\"))\n                return;\n\n            Log.Information(\"Dumping xboxkrnl.exe from memory.\");\n\n            var kernel = xbox.Modules.Find(m => m.Name == \"xboxkrnl.exe\");", "            if (!YesNo(\"Dump xboxkrnl.exe from memory?\"))\n                return;\n\n            Log.Information(\"Dumping xboxkrnl.exe from memory.\");\n\n            var kernel = xbox.Modules.Find(m => m.Name == \"xboxkrnl.exe\");\n            if (kernel != null)\n            {\n                byte[] page = new byte[0x1000];\n                using var fs = File.Create(path);\n                using var bw = new BinaryWriter(fs);\n\n                // loop through each page in the kernel address range skipping any invalid ones since the init section will be deallocated               ", "                for (long position = kernel.BaseAddress; position < kernel.BaseAddress + kernel.Size; position += page.Length)\n                {\n                    bw.Write(xbox.IsValidAddress(position) ? xbox.Memory.ReadBytes(position, page.Length) : page);\n                }                \n            }\n        }\n\n        public static void ValidateRpc(Xbox xbox)\n        {\n            Log.Information(\"Validating remote procedure call functionality.\");\n\n            // mov eax, 0DEADBEEFh\n            // ret\n            xbox.WriteMemory(xbox.StaticScratch.Region.Address, new byte[] { 0xB8, 0xEF, 0xBE, 0xAD, 0xDE, 0xC3 });", "            if (xbox.Call(xbox.StaticScratch.Region.Address) != 0xDEADBEEF)\n            {\n                Log.Warning(\"Remote procedure call failure!\");\n                throw new InvalidDataException();\n            }\n        }\n\n        public static void DumpEeprom(Xbox xbox, string path)\n        {\n            if (!YesNo(\"Dump EEPROM?\"))\n                return;\n\n            Log.Information(\"Dumping EEPROM.\");\n\n            // configure progress bar\n            const int eepromSize = 256;\n            using var progress = CreatePercentProgressBar();\n\n            // read a byte at a time\n            using var fs = File.Create(path);\n            using var bw = new BinaryWriter(fs);", "            if (!YesNo(\"Dump EEPROM?\"))\n                return;\n\n            Log.Information(\"Dumping EEPROM.\");\n\n            // configure progress bar\n            const int eepromSize = 256;\n            using var progress = CreatePercentProgressBar();\n\n            // read a byte at a time\n            using var fs = File.Create(path);\n            using var bw = new BinaryWriter(fs);", "            for (int i = 0; i < eepromSize; i++)\n            {\n                xbox.Kernel.HalReadSMBusValue(0xA8, i, false, xbox.StaticScratch.Region.Address);\n                bw.Write(xbox.Memory.ReadByte(xbox.StaticScratch.Region.Address));\n                progress.AsProgress<float>().Report((float)i / eepromSize);\n            }\n            progress.AsProgress<float>().Report(1.0f);\n        }\n\n        public static void DumpBiosImage(Xbox xbox, string path)\n        {", "        public static void DumpBiosImage(Xbox xbox, string path)\n        {\n            if (!YesNo(\"Dump BIOS?\"))\n                return;\n\n            Log.Information(\"Dumping BIOS image from flash.\");\n\n            // take the first 1MB which is enough for all legit development gear\n            byte[] bios = new byte[1024 * 1024];\n\n            // configure progress bar\n            var chunkSize = 0x1000;\n            var chunks = bios.Length / chunkSize;\n            using var progress = CreatePercentProgressBar();\n\n            // read 4kb at a time", "            for (int i = 0; i < chunks; i++)\n            {\n                xbox.ReadMemory(0xFF000000 + i * chunkSize, bios, i * chunkSize, chunkSize);\n                progress.AsProgress<float>().Report((float)i / chunks);\n            }\n            progress.AsProgress<float>().Report(1.0f);\n\n            // find smallest 256KB-aligned unique chunk since it gets mirrored throughout the upper 16MB range\n            byte[] testPattern = bios.Take(1024 * 256).ToArray();\n            int flashSize = bios.IndexOfArray(testPattern, (int)testPattern.Length);\n            if (flashSize == -1)\n                flashSize = bios.Length;\n\n            File.WriteAllBytes(path, bios.Take(flashSize).ToArray());\n        }\n", "            if (flashSize == -1)\n                flashSize = bios.Length;\n\n            File.WriteAllBytes(path, bios.Take(flashSize).ToArray());\n        }\n\n        public static void DumpHddImage(Xbox xbox, string path)\n        {\n            if (!YesNo(\"Dump HDD image?\"))\n                return;\n\n            // attempt to allocate a larger scratch buffer and switch to unsafe mode for increased performance\n            int scratchSize = 1024 * 1024;\n            uint scratch = (uint)xbox.Kernel.MmAllocateContiguousMemory(scratchSize);", "            if (!YesNo(\"Dump HDD image?\"))\n                return;\n\n            // attempt to allocate a larger scratch buffer and switch to unsafe mode for increased performance\n            int scratchSize = 1024 * 1024;\n            uint scratch = (uint)xbox.Kernel.MmAllocateContiguousMemory(scratchSize);\n            if (scratch == 0)\n            {\n                scratch = xbox.StaticScratch.Region.Address;\n                scratchSize = xbox.StaticScratch.Region.Size;\n            }\n\n            xbox.SafeMode = false;\n\n            Log.Information(\"Dumping HDD image.\");\n\n            // remote memory map\n            //FileHandle:\n            //    dd    0\n            //IoStatusBlock: +4\n            //    dd\t0\n            //    dd\t0\n            //ObjectAttributes:\t+12\t; (OBJECT ATTRIBUTES)\n            //    dd\t0\t\t    ; HANDLE RootDirectory\n            //    dd\tObjectName\t; PANSI_STRING ObjectName\n            //    dd\t00000040h\t; ULONG Attributes = FILE_ATTRIBUTE_DEVICE\n            //ObjectName:\t +24\t; (PANSI_STRING)\n            //    dw\t26;\t\t    ; USHORT Length\n            //    dw\t26;\t\t    ; USHORT MaximumLength\n            //    dd\tFileName\t; PCHAR Buffer\n            // FileName: + 32\n            // db\t\"\\Device\\Harddisk0\\Partition0\", 0\n            uint fileHandleAddr = scratch;\n            uint iOStatusBlockAddr = scratch + 4;\n            uint objectAttributesAddr = scratch + 12;\n            uint objectNameAddr = scratch + 24;\n            uint fileNameAddr = scratch + 32;\n\n            // initialize remote memory\n            string name = @\"\\Device\\Harddisk0\\Partition0\";      // physical disk path\n            xbox.Memory.Position = scratch;\n            xbox.Memory.Write((uint)0);\n            xbox.Memory.Write((uint)0);\n            xbox.Memory.Write((uint)0);\n            xbox.Memory.Write((uint)0);\n            xbox.Memory.Write(objectNameAddr);\n            xbox.Memory.Write((uint)0x40);\n            xbox.Memory.Write((ushort)name.Length);\n            xbox.Memory.Write((ushort)name.Length);\n            xbox.Memory.Write(fileNameAddr);\n            xbox.Memory.WriteAscii(name);\n            xbox.Memory.Write(0);\n\n            // obtain a handle to the raw physical hdd device\n            var status = xbox.Call(xbox.Kernel.Exports.NtOpenFile,\n                    fileHandleAddr,         // PHANDLE FileHandle\n                    0xC0000000,             // ACCESS_MASK DesiredAccess = GENERIC_WRITE | GENERIC_READ\n                    objectAttributesAddr,   // POBJECT_ATTRIBUTES ObjectAttributes\n                    iOStatusBlockAddr,      // PIO_STATUS_BLOCK IoStatusBlock\n                    (uint)3,                // ULONG ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE\n                    (uint)0x60              // ULONG OpenOptions = FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE\n                );", "            if (status != 0)\n                throw new Win32Exception((int)status);\n            uint handle = xbox.Memory.ReadUInt32(fileHandleAddr);\n\n            // memory map\n            var geometryInfoAddr = scratch + 100;\n            var geometryInfoSize = 24;\n\n            // get the disk geometry information\n            status = xbox.Call(xbox.Kernel.Exports.NtDeviceIoControlFile,\n                    handle,                                 // HANDLE FileHandle\n                    0,                                      // HANDLE Event\n                    0,                                      // PIO_APC_ROUTINE ApcRoutine\n                    0,                                      // PVOID ApcContext\n                    iOStatusBlockAddr,                      // PIO_STATUS_BLOCK IoStatusBlock\n                    (7 << 16) | (0 << 14) | (0 << 2) | 0,   // ULONG IoControlCode = IOCTL_DISK_BASE << 16 | FILE_ANY_ACCESS << 14 | Function << 2 | METHOD_BUFFERED\n                    0,                                      // PVOID InputBuffer\n                    0,                                      // ULONG InputBufferLength\n                    geometryInfoAddr,                       // PVOID OutputBuffer\n                    geometryInfoSize                        // ULONG OutputBufferLength\n                );", "            if (status != 0)\n                throw new Win32Exception((int)status);\n\n            // calculate the total raw disk size\n            long cylinders = xbox.Memory.ReadInt64(geometryInfoAddr);\n            int tracksPerCylinder = xbox.Memory.ReadInt32(geometryInfoAddr + 12);\n            int sectorsPerTrack = xbox.Memory.ReadInt32(geometryInfoAddr + 16);\n            long bytesPerSector = xbox.Memory.ReadInt32(geometryInfoAddr + 20);\n            long size = cylinders * tracksPerCylinder * sectorsPerTrack * bytesPerSector;\n            Log.Information(\"Detected {0} GB HDD ({1} bytes).\", (int)((float)size / (1024 * 1024 * 1024)), size.ToHexString());\n\n            // get the required 4KB-aligned/sized buffer within scratch space\n            uint bufferAddress = scratch + 16; // first 16 bytes of scratch is reserved for NtReadFile args\n            bufferAddress = (bufferAddress + 0xFFF) & 0xFFFFF000; // align up to the next 4KB\n            uint bufferSize = (uint)(scratch + scratchSize - bufferAddress);\n            bufferSize &= 0xFFFFF000; // align down to the next 4KB\n            byte[] buffer = new byte[bufferSize];\n\n            // make sure we haven't gone too far", "            if (bufferSize == 0)\n                throw new OutOfMemoryException(\"Not enough aligned scratch space!\");\n\n            using var progress = CreatePercentProgressBar();\n            using var fs = File.Create(path);\n            using var bw = new BinaryWriter(fs);\n\n            long diskOffset = 0;\n            while (diskOffset < size)\n            {\n                uint bytesToRead = (uint)Math.Min((ulong)bufferSize, (ulong)(size - diskOffset));\n\n                Log.Verbose(\"Reading {0} bytes from disk offset {1}\", bytesToRead, diskOffset);\n\n                try\n                {\n                    xbox.Memory.Write(scratch, diskOffset);\n                    xbox.Kernel.NtReadFile(\n                        handle,         // HANDLE FileHandle\n                        0,              // HANDLE Event\n                        0,              // PIO_APC_ROUTINE ApcRoutine\n                        0,              // PVOID ApcContext\n                        scratch + 8,    // PIO_STATUS_BLOCK IoStatusBlock\n                        bufferAddress,  // PVOID Buffer\n                        bytesToRead,    // ULONG Length\n                        scratch         // PLARGE_INTEGER ByteOffset\n                    );\n\n                    xbox.ReadMemory(bufferAddress, buffer, 0, (int)bytesToRead);\n                }", "            while (diskOffset < size)\n            {\n                uint bytesToRead = (uint)Math.Min((ulong)bufferSize, (ulong)(size - diskOffset));\n\n                Log.Verbose(\"Reading {0} bytes from disk offset {1}\", bytesToRead, diskOffset);\n\n                try\n                {\n                    xbox.Memory.Write(scratch, diskOffset);\n                    xbox.Kernel.NtReadFile(\n                        handle,         // HANDLE FileHandle\n                        0,              // HANDLE Event\n                        0,              // PIO_APC_ROUTINE ApcRoutine\n                        0,              // PVOID ApcContext\n                        scratch + 8,    // PIO_STATUS_BLOCK IoStatusBlock\n                        bufferAddress,  // PVOID Buffer\n                        bytesToRead,    // ULONG Length\n                        scratch         // PLARGE_INTEGER ByteOffset\n                    );\n\n                    xbox.ReadMemory(bufferAddress, buffer, 0, (int)bytesToRead);\n                }", "                catch (Exception ex)\n                {\n                    Log.Warning(ex, \"Read failure at {0}\", diskOffset.ToHexString());\n                    buffer = new byte[bytesToRead];\n                }\n                finally\n                {\n                    bw.Write(buffer);\n                    fs.Flush();\n                    diskOffset += bytesToRead;\n                }\n\n                progress.AsProgress<float>().Report((float)diskOffset / size);\n            }\n            progress.AsProgress<float>().Report(1.0f);\n\n            // cleanup\n            xbox.Kernel.NtClose(handle);\n            xbox.Kernel.MmFreeContiguousMemory(scratch);\n        }\n", "        private static void DumpDirectory(Xbox xbox, string remotePath, string localPath)\n        {\n            Log.Information(\"Downloading {0}\", remotePath);\n            Directory.CreateDirectory(localPath);\n\n            try\n            {\n                var list = xbox.GetDirectoryList(remotePath);\n\n                foreach (var item in list)\n                {", "                foreach (var item in list)\n                {\n                    if (item.Attributes.HasFlag(FileAttributes.Directory))\n                    {\n                        DumpDirectory(xbox, item.FullName, Path.Combine(localPath, item.Name));\n                    }\n                    else\n                    {\n                        try\n                        {\n                            Log.Information(\"Downloading file {0}\", item.Name);\n                            xbox.GetFile(Path.Combine(localPath, item.Name), item.FullName);\n                        }", "                        catch (Exception ex)\n                        {\n                            Log.Warning(ex, item.Name);\n                        }\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                Log.Warning(ex, remotePath);\n            }\n        }\n", "        public static void DumpHddFiles(Xbox xbox, string path)\n        {\n            if (!YesNo(\"Dump files from HDD?\"))\n                return;\n\n            Log.Information(\"Dumping files from hdd.\");\n\n            foreach (var drive in xbox.GetDrives())\n            {\n                DumpDirectory(xbox, drive.ToString() + \":\\\\\", Path.Combine(path, drive.ToString()));\n            }\n        }\n", "        private static ProgressBar CreatePercentProgressBar()\n        {\n            return new ProgressBar(10000, \"Completed\",\n                new ProgressBarOptions\n                {\n                    ForegroundColor = ConsoleColor.Yellow,\n                    ForegroundColorDone = ConsoleColor.DarkGreen,\n                    BackgroundColor = ConsoleColor.DarkGray,\n                    BackgroundCharacter = '\\u2593'\n                });\n        }\n", "        private static bool YesNo(string question, bool defaultYes = true)\n        {\n            var yesNoQuestion = new YesNoQuestion(question)\n            {\n                DefaultAnswer = defaultYes ? YesNoAnswer.Yes : YesNoAnswer.No\n            };\n\n            return yesNoQuestion.ReadAnswer() == YesNoAnswer.Yes;\n        }\n    }\n}"]}
{"filename": "src/OGXbdmDumper/Utility.cs", "chunked_list": ["\ufeffnamespace OGXbdmDumper\n{\n    public static class Utility\n    {\n        /// <summary>\n        /// Shared random number generator.\n        /// </summary>\n        public static Random Random = new Random();\n\n        public static long FromHiLo(uint hi, uint lo)\n        {\n            return ((long)hi << 32) | lo;\n        }\n    }\n}\n", "        public static long FromHiLo(uint hi, uint lo)\n        {\n            return ((long)hi << 32) | lo;\n        }\n    }\n}\n"]}
