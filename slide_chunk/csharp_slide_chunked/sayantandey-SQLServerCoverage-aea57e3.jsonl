{"filename": "src/SQLServerCoverage/Properties/AssemblyInfo.cs", "chunked_list": ["\ufeffusing System.Reflection;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n\n// General Information about an assembly is controlled through the following \n// set of attributes. Change these attribute values to modify the information\n// associated with an assembly.\n[assembly: AssemblyTitle(\"SQLServerCoverage\")]\n[assembly: AssemblyDescription(\"Code coverage tool SQL Server\")]\n[assembly: AssemblyConfiguration(\"\")]", "[assembly: AssemblyDescription(\"Code coverage tool SQL Server\")]\n[assembly: AssemblyConfiguration(\"\")]\n[assembly: AssemblyProduct(\"SQLServerCoverage\")] \n[assembly: AssemblyTrademark(\"\")]\n[assembly: AssemblyCulture(\"\")]\n\n// Setting ComVisible to false makes the types in this assembly not visible \n// to COM components.  If you need to access a type in this assembly from \n// COM, set the ComVisible attribute to true on that type.\n[assembly: ComVisible(false)]", "// COM, set the ComVisible attribute to true on that type.\n[assembly: ComVisible(false)]\n\n// The following GUID is for the ID of the typelib if this project is exposed to COM\n[assembly: Guid(\"b81b5731-2829-4666-bd75-9dc905560c6f\")]\n\n// Version information for an assembly consists of the following four values:\n//\n//      Major Version\n//      Minor Version ", "//      Major Version\n//      Minor Version \n//      Build Number\n//      Revision\n//\n// You can specify all the values or you can default the Build and Revision Numbers \n// by using the '*' as shown below:\n// [assembly: AssemblyVersion(\"1.0.*\")]\n\n[assembly: AssemblyVersion(\"2.0.0.0\")]", "\n[assembly: AssemblyVersion(\"2.0.0.0\")]\n[assembly: AssemblyFileVersion(\"2.0.0.0\")]\n"]}
{"filename": "src/SQLServerCoverage/Serializers/OpenCoverXmlSerializer.cs", "chunked_list": ["\ufeffusing SQLServerCoverage.Objects;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.IO;\nusing System.Linq;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Xml;\nusing System.Xml.Linq;\n", "using System.Xml.Linq;\n\nnamespace SQLServerCoverage.Serializers\n{\n    public class OpenCoverXmlSerializer\n    {\n        private long uniqueId = 1;\n\n        #region \" XNames \"\n\n        private static readonly XName BranchPointElementName = XName.Get(\"BranchPoint\");", "        private static readonly XName BranchPointElementName = XName.Get(\"BranchPoint\");\n        private static readonly XName BranchPointsElementName = XName.Get(\"BranchPoints\");\n        private static readonly XName ClassesElementName = XName.Get(\"Classes\");\n        private static readonly XName ClassElementName = XName.Get(\"Class\");\n        private static readonly XName CoverageSessionElementName = XName.Get(\"CoverageSession\");\n        private static readonly XName FileRefName = XName.Get(\"FileRef\");\n        private static readonly XName FileElementName = XName.Get(\"File\");\n        private static readonly XName FilesElementName = XName.Get(\"Files\");\n        private static readonly XName FullNameElementName = XName.Get(\"FullName\");\n        private static readonly XName MetadataTokenElementName = XName.Get(\"MetadataToken\");\n        private static readonly XName MethodNameElementName = XName.Get(\"Method\");", "        private static readonly XName FullNameElementName = XName.Get(\"FullName\");\n        private static readonly XName MetadataTokenElementName = XName.Get(\"MetadataToken\");\n        private static readonly XName MethodNameElementName = XName.Get(\"Method\");\n        private static readonly XName MethodsNameElementName = XName.Get(\"Methods\");\n        private static readonly XName ModuleElementName = XName.Get(\"Module\");\n        private static readonly XName ModuleNameElementName = XName.Get(\"ModuleName\");\n        private static readonly XName ModulesElementName = XName.Get(\"Modules\");\n        private static readonly XName NameElementName = XName.Get(\"Name\");\n        private static readonly XName SequencePointName = XName.Get(\"SequencePoint\");\n        private static readonly XName SequencePointsName = XName.Get(\"SequencePoints\");\n        private static readonly XName SummaryElementName = XName.Get(\"Summary\");\n", "        private static readonly XName SequencePointName = XName.Get(\"SequencePoint\");\n        private static readonly XName SequencePointsName = XName.Get(\"SequencePoints\");\n        private static readonly XName SummaryElementName = XName.Get(\"Summary\");\n\n        private static readonly XName XmlnsXsdAttributeName = XNamespace.Xmlns + \"xsd\";\n        private static readonly XName XmlnsXsiAttributeName = XNamespace.Xmlns + \"xsi\";\n\n        private static readonly XName branchCoverageAttributeName = XName.Get(\"branchCoverage\");\n        private static readonly XName cyclomaticComplexityAttributeName = XName.Get(\"cyclomaticComplexity\");\n        private static readonly XName ecAttributeName = XName.Get(\"ec\");\n        private static readonly XName elAttributeName = XName.Get(\"el\");", "        private static readonly XName cyclomaticComplexityAttributeName = XName.Get(\"cyclomaticComplexity\");\n        private static readonly XName ecAttributeName = XName.Get(\"ec\");\n        private static readonly XName elAttributeName = XName.Get(\"el\");\n        private static readonly XName fullPathAttributeName = XName.Get(\"fullPath\");\n        private static readonly XName isConstructorAttributeName = XName.Get(\"isConstructor\");\n        private static readonly XName isGetterAttributeName = XName.Get(\"isGetter\");\n        private static readonly XName isSetterAttributeName = XName.Get(\"isSetter\");\n        private static readonly XName isStaticAttributeName = XName.Get(\"isStatic\");\n        private static readonly XName maxCyclomaticComplexityAttributeName = XName.Get(\"maxCyclomaticComplexity\");\n        private static readonly XName minCyclomaticComplexityAttributeName = XName.Get(\"minCyclomaticComplexity\");\n        private static readonly XName numBranchPointsAttributeName = XName.Get(\"numBranchPoints\");", "        private static readonly XName maxCyclomaticComplexityAttributeName = XName.Get(\"maxCyclomaticComplexity\");\n        private static readonly XName minCyclomaticComplexityAttributeName = XName.Get(\"minCyclomaticComplexity\");\n        private static readonly XName numBranchPointsAttributeName = XName.Get(\"numBranchPoints\");\n        private static readonly XName numSequencePointsAttributeName = XName.Get(\"numSequencePoints\");\n        private static readonly XName offsetAttributeName = XName.Get(\"offset\");\n        private static readonly XName offsetchainAttributeName = XName.Get(\"offsetchain\");\n        private static readonly XName offsetendAttributeName = XName.Get(\"offsetend\");\n        private static readonly XName ordinalAttributeName = XName.Get(\"ordinal\");\n        private static readonly XName pathAttributeName = XName.Get(\"path\");\n        private static readonly XName sequenceCoverageAttributeName = XName.Get(\"sequenceCoverage\");\n        private static readonly XName scAttributeName = XName.Get(\"sc\");", "        private static readonly XName pathAttributeName = XName.Get(\"path\");\n        private static readonly XName sequenceCoverageAttributeName = XName.Get(\"sequenceCoverage\");\n        private static readonly XName scAttributeName = XName.Get(\"sc\");\n        private static readonly XName slAttributeName = XName.Get(\"sl\");\n        private static readonly XName uidAttributeName = XName.Get(\"uid\");\n        private static readonly XName uspidAttributeName = XName.Get(\"uspid\");\n        private static readonly XName vcAttributeName = XName.Get(\"vc\");\n        private static readonly XName visitedAttributeName = XName.Get(\"visited\");\n        private static readonly XName visitedBranchPointsAttributeName = XName.Get(\"visitedBranchPoints\");\n        private static readonly XName visitedSequencePointsAttributeName = XName.Get(\"visitedSequencePoints\");\n\n        #endregion\n", "        private static readonly XName visitedBranchPointsAttributeName = XName.Get(\"visitedBranchPoints\");\n        private static readonly XName visitedSequencePointsAttributeName = XName.Get(\"visitedSequencePoints\");\n\n        #endregion\n\n        public string Serialize(CoverageResult result)\n        {\n            var document = new XDocument(CreateCoverageSessionElement(result));\n\n            using (var ms = new MemoryStream())\n            {\n                var xmlSettings = new XmlWriterSettings()\n                {\n                    OmitXmlDeclaration = true,\n                    Encoding = new UTF8Encoding(false),\n                    Indent = true,\n                    IndentChars = \"  \"\n                };\n", "            using (var ms = new MemoryStream())\n            {\n                var xmlSettings = new XmlWriterSettings()\n                {\n                    OmitXmlDeclaration = true,\n                    Encoding = new UTF8Encoding(false),\n                    Indent = true,\n                    IndentChars = \"  \"\n                };\n\n                using (var writer = XmlWriter.Create(ms, xmlSettings))\n                {\n                    document.WriteTo(writer);\n\n                }\n                return Encoding.UTF8.GetString(ms.ToArray());\n            }\n        }\n", "                using (var writer = XmlWriter.Create(ms, xmlSettings))\n                {\n                    document.WriteTo(writer);\n\n                }\n                return Encoding.UTF8.GetString(ms.ToArray());\n            }\n        }\n\n        private XElement CreateCoverageSessionElement(CoverageResult result)\n            => new XElement(CoverageSessionElementName,\n                new XAttribute(XmlnsXsdAttributeName, \"http://www.w3.org/2001/XMLSchema\"),\n                new XAttribute(XmlnsXsiAttributeName, \"http://www.w3.org/2001/XMLSchema-instance\"),\n                CreateSummaryElement(result),\n                CreateModulesElement(result)\n            );\n", "        private XElement CreateCoverageSessionElement(CoverageResult result)\n            => new XElement(CoverageSessionElementName,\n                new XAttribute(XmlnsXsdAttributeName, \"http://www.w3.org/2001/XMLSchema\"),\n                new XAttribute(XmlnsXsiAttributeName, \"http://www.w3.org/2001/XMLSchema-instance\"),\n                CreateSummaryElement(result),\n                CreateModulesElement(result)\n            );\n\n        private XElement CreateSummaryElement(CoverageResult result)\n            => CreateSummaryElement(\n                numSequencePoints: result.Batches.Sum(p => p.StatementCount),\n                visitedSequencePoints: result.Batches.Sum(p => p.CoveredStatementCount),\n                numBranchPoints: result.Batches.Sum(p => p.BranchesCount),\n                visitedBranchPoints: result.Batches.Sum(p => p.CoveredBranchesCount)\n            );\n", "        private XElement CreateSummaryElement(CoverageResult result)\n            => CreateSummaryElement(\n                numSequencePoints: result.Batches.Sum(p => p.StatementCount),\n                visitedSequencePoints: result.Batches.Sum(p => p.CoveredStatementCount),\n                numBranchPoints: result.Batches.Sum(p => p.BranchesCount),\n                visitedBranchPoints: result.Batches.Sum(p => p.CoveredBranchesCount)\n            );\n\n        private XElement CreateSummaryElement(Batch batch)\n            => CreateSummaryElement(\n                numSequencePoints: batch.StatementCount,\n                visitedSequencePoints: batch.CoveredStatementCount,\n                numBranchPoints: batch.BranchesCount,\n                visitedBranchPoints: batch.CoveredBranchesCount\n            );\n", "        private XElement CreateSummaryElement(Batch batch)\n            => CreateSummaryElement(\n                numSequencePoints: batch.StatementCount,\n                visitedSequencePoints: batch.CoveredStatementCount,\n                numBranchPoints: batch.BranchesCount,\n                visitedBranchPoints: batch.CoveredBranchesCount\n            );\n\n        private XElement CreateSummaryElement(\n            long numSequencePoints,\n            long visitedSequencePoints,\n            long numBranchPoints,\n            long visitedBranchPoints)\n            => new XElement(\n                SummaryElementName,\n                new XAttribute(numSequencePointsAttributeName, numSequencePoints),\n                new XAttribute(visitedSequencePointsAttributeName, visitedSequencePoints),\n                new XAttribute(numBranchPointsAttributeName, numBranchPoints),\n                new XAttribute(visitedBranchPointsAttributeName, visitedBranchPoints),\n                new XAttribute(sequenceCoverageAttributeName, numSequencePoints == 0 ? 0 : visitedSequencePoints / (double)numSequencePoints * 100.0),\n                new XAttribute(branchCoverageAttributeName, numBranchPoints == 0 ? 0 : visitedBranchPoints / (double)numBranchPoints * 100.0),\n                new XAttribute(maxCyclomaticComplexityAttributeName, \"0\"),\n                new XAttribute(minCyclomaticComplexityAttributeName, \"0\")\n            );\n", "        private XElement CreateSummaryElement(\n            long numSequencePoints,\n            long visitedSequencePoints,\n            long numBranchPoints,\n            long visitedBranchPoints)\n            => new XElement(\n                SummaryElementName,\n                new XAttribute(numSequencePointsAttributeName, numSequencePoints),\n                new XAttribute(visitedSequencePointsAttributeName, visitedSequencePoints),\n                new XAttribute(numBranchPointsAttributeName, numBranchPoints),\n                new XAttribute(visitedBranchPointsAttributeName, visitedBranchPoints),\n                new XAttribute(sequenceCoverageAttributeName, numSequencePoints == 0 ? 0 : visitedSequencePoints / (double)numSequencePoints * 100.0),\n                new XAttribute(branchCoverageAttributeName, numBranchPoints == 0 ? 0 : visitedBranchPoints / (double)numBranchPoints * 100.0),\n                new XAttribute(maxCyclomaticComplexityAttributeName, \"0\"),\n                new XAttribute(minCyclomaticComplexityAttributeName, \"0\")\n            );\n", "        private XElement CreateModulesElement(CoverageResult result)\n        {\n            var databaseName = result.DatabaseName;\n\n            var hash = string.Join(\n                \"-\",\n                SHA1.Create().ComputeHash(\n                    Encoding.UTF8.GetBytes(databaseName)\n                ).Select(x => x.ToString(\"X2\")).ToArray()\n            );\n\n            return new XElement(\n                ModulesElementName,\n                new XElement(\n                    ModuleElementName,\n                    new XAttribute(\"hash\", hash),\n                    new XElement(FullNameElementName, databaseName),\n                    new XElement(ModuleNameElementName, databaseName),\n                    CreateFilesElement(result.Batches),\n                    CreateClassesElement(result.Batches)\n                )\n            );\n        }\n", "        private XElement CreateFilesElement(IEnumerable<Batch> batches)\n            => new XElement(\n                FilesElementName,\n                batches.Select((x, i) => CreateFileElement(x.ObjectId, x.ObjectName))\n            );\n\n        private XElement CreateFileElement(int uid, string fullPath)\n            => new XElement(\n                FileElementName,\n                new XAttribute(uidAttributeName, uid),\n                new XAttribute(fullPathAttributeName, fullPath)\n            );\n", "        private XElement CreateClassesElement(IEnumerable<Batch> batches)\n            => new XElement(\n                ClassesElementName,\n                batches.Select((x, i) => CreateClassElement(x))\n            );\n\n        private XElement CreateClassElement(Batch batch)\n        {\n            return new XElement(\n                ClassElementName,\n                CreateSummaryElement(batch),\n                new XElement(FullNameElementName, batch.ObjectName),\n                CreateMethodsElement(batch)\n            );\n        }\n", "        private XElement CreateMethodsElement(Batch batch)\n            => new XElement(\n                MethodsNameElementName,\n                new XElement(\n                    MethodNameElementName,\n                    new XAttribute(visitedAttributeName, batch.CoveredStatementCount > 0),\n                    new XAttribute(cyclomaticComplexityAttributeName, \"0\"),\n                    new XAttribute(sequenceCoverageAttributeName, batch.StatementCount == 0 ? 0 : batch.CoveredStatementCount / (double)batch.StatementCount * 100.0),\n                    new XAttribute(branchCoverageAttributeName, batch.BranchesCount == 0 ? 0 : batch.CoveredBranchesCount / (double)batch.BranchesCount * 100.0),\n                    new XAttribute(isConstructorAttributeName, \"false\"),\n                    new XAttribute(isStaticAttributeName, \"false\"),\n                    new XAttribute(isGetterAttributeName, \"true\"),\n                    new XAttribute(isSetterAttributeName, \"false\"),\n                    CreateSummaryElement(batch),\n                    new XElement(MetadataTokenElementName, \"01041980\"),\n                    new XElement(NameElementName, batch.ObjectName),\n                    new XElement(\n                        FileRefName,\n                        new XAttribute(uidAttributeName, batch.ObjectId)\n                    ),\n                    CreateSequencePointsElement(batch),\n                    CreateBranchPointsElement(batch)\n                )\n            );\n", "        private XElement CreateSequencePointsElement(Batch batch)\n            => new XElement(\n                SequencePointsName,\n                batch.Statements.Select((x, i) => CreateSequencePointElement(batch, x, i + 1))\n            );\n\n        private XElement CreateSequencePointElement(Batch batch, Statement statement, int ordinal)\n        {\n            var offsets = CoverageResult.GetOffsets(statement, batch.Text);\n\n            return new XElement(\n                SequencePointName,\n                new XAttribute(vcAttributeName, statement.HitCount),\n                new XAttribute(uspidAttributeName, uniqueId++),\n                new XAttribute(ordinalAttributeName, ordinal),\n                new XAttribute(offsetAttributeName, statement.Offset),\n                new XAttribute(slAttributeName, offsets.StartLine),\n                new XAttribute(scAttributeName, offsets.StartColumn),\n                new XAttribute(elAttributeName, offsets.EndLine),\n                new XAttribute(ecAttributeName, offsets.EndColumn)\n            );\n        }\n\n", "        private XElement CreateBranchPointsElement(Batch batch)\n        {\n            var ordinal = 1;\n\n            return new XElement(\n                BranchPointsElementName,\n                batch.Statements\n                    .Where(x => x.Branches.Any())\n                    .SelectMany((statement, i) =>\n                        statement.Branches.Select((branch, j) => CreateBranchPointElement(batch, statement, branch, ordinal++, j))\n                    )\n            );\n        }\n", "        private XElement CreateBranchPointElement(Batch batch, Statement statement, Branch branch, int ordinal, int path)\n        {\n            var offsets = CoverageResult.GetOffsets(statement, batch.Text);\n            var offsetEnd = branch.Offset + branch.Length;\n\n            return new XElement(\n                BranchPointElementName,\n                new XAttribute(vcAttributeName, branch.HitCount),\n                new XAttribute(uspidAttributeName, uniqueId++),\n                new XAttribute(ordinalAttributeName, ordinal),\n                new XAttribute(offsetAttributeName, branch.Offset),\n                new XAttribute(slAttributeName, offsets.StartLine),\n                new XAttribute(pathAttributeName, path),\n                new XAttribute(offsetchainAttributeName, \"\"),\n                new XAttribute(offsetendAttributeName, branch.Offset + branch.Length)\n            );\n        }\n    }\n}\n"]}
{"filename": "src/SQLServerCoverageCore/Program.cs", "chunked_list": ["\ufeffusing CommandLine;\nusing Newtonsoft.Json;\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel.Composition.Primitives;\nusing System.IO;\nusing System.Linq;\n\nnamespace SQLServerCoverage.Core\n{\n    class Program\n\n    {\n\n        // Default path of result storage", "namespace SQLServerCoverage.Core\n{\n    class Program\n\n    {\n\n        // Default path of result storage\n        public const string DefaultLocation = \"SQL Server Coverage Report\";\n        // Default path of result storage\n        public const string DefaultCoverageFileName = \"SQLServerCoverage\";\n", "        public const string DefaultCoverageFileName = \"SQLServerCoverage\";\n\n        public class Options\n        {\n            [Option('v', \"verbose\", Required = false, HelpText = \"Set output to verbose messages.\")]\n            public bool Verbose { get; set; }\n\n            [Option('c', \"command\", Required = true, HelpText = \"Choose command to run: Currently only Get-CoverTSql available\")]\n            public string Command { get; set; }\n\n            [Option('e', \"exportType\", Required = true, HelpText = \"Choose export options : Export-OpenXml, Export-Html, Export-Cobertura\")]", "            public string Command { get; set; }\n\n            [Option('e', \"exportType\", Required = true, HelpText = \"Choose export options : Export-OpenXml, Export-Html, Export-Cobertura\")]\n            public string ExportType { get; set; }\n\n            [Option('b', \"debug\", Required = false, HelpText = \"Prints out detailed output.\")]\n            public bool Debug { get; set; }\n\n            [Option('p', \"requiredParams\", Required = false, HelpText = \"Get required parameters for a command\")]\n            public bool GetRequiredParameters { get; set; }\n\n            [JsonIgnore]\n            [Option('k', \"connectionString\", Required = false, HelpText = \"Connection String to the SQL server\")]", "            public bool GetRequiredParameters { get; set; }\n\n            [JsonIgnore]\n            [Option('k', \"connectionString\", Required = false, HelpText = \"Connection String to the SQL server\")]\n            public string ConnectionString { get; set; }\n\n            [Option('d', \"databaseName\", Required = false, HelpText = \"Default Database\")]\n            public string databaseName { get; set; }\n\n            [Option('q', \"query\", Required = false, HelpText = \"Sql Query, Ex. tSQLt.runAll OR your custom test executor\")]\n            public string Query { get; set; }\n\n            [Option('o', \"outputPath\", Required = false, HelpText = \"Output Path of The Export Result\")]", "            public string Query { get; set; }\n\n            [Option('o', \"outputPath\", Required = false, HelpText = \"Output Path of The Export Result\")]\n            public string OutputPath { get; set; }\n\n            [Option('t', \"timeout\", Required = false, HelpText = \"Wait time in Seconds before terminating the attempt to execute test SQL command\")]\n            public int TimeOut { get; set; }\n\n            [Option('i', \"ignore\", Required = false, HelpText = \"Space separated list of database objects to ignore. Regex Accepted. Case sensitive depending on collation\" +\n                                                                 \"Ex.\\\"sp_dummy_proc* sp_test_proc\\\"\")]\n            public string IgnoreObjects { get; set; }\n\n        }", "            public string IgnoreObjects { get; set; }\n\n        }\n        private enum CommandType\n        {\n            GetCoverTSql,\n            Unknown\n        }\n\n        private enum ExportType\n        {\n            ExportOpenXml,\n            ExportHtml,\n            ExportCobertura,\n            Unknown\n        }\n        /// <summary>\n        /// \n        /// run by `dotnet run -- -c Get-CoverTSql -r`\n        /// `dotnet run -- -c Get-CoverTSql -e Export-OpenXml -k \"Data Source=localhost;Initial Catalog=master;User ID=sa;Password=yourStrong(!)Password\" -d DatabaseWithTests -q \"tSQLt.runAll\" -p TestCoverageOpenXml`\n        /// </summary>\n        /// <param name=\"args\">Arguments required for SQLServerCoverage to execute</param>\n        static void Main(string[] args)\n        {\n            Parser.Default.ParseArguments<Options>(args)\n                   .WithParsed<Options>(o =>\n                   {", "        private enum ExportType\n        {\n            ExportOpenXml,\n            ExportHtml,\n            ExportCobertura,\n            Unknown\n        }\n        /// <summary>\n        /// \n        /// run by `dotnet run -- -c Get-CoverTSql -r`\n        /// `dotnet run -- -c Get-CoverTSql -e Export-OpenXml -k \"Data Source=localhost;Initial Catalog=master;User ID=sa;Password=yourStrong(!)Password\" -d DatabaseWithTests -q \"tSQLt.runAll\" -p TestCoverageOpenXml`\n        /// </summary>\n        /// <param name=\"args\">Arguments required for SQLServerCoverage to execute</param>\n        static void Main(string[] args)\n        {\n            Parser.Default.ParseArguments<Options>(args)\n                   .WithParsed<Options>(o =>\n                   {", "                       if (o.Verbose)\n                       {\n                           Console.WriteLine($\"Verbose output enabled. Current Arguments: -v {o.Verbose}\");\n                           Console.WriteLine(\"Current Arguments Serialized::\" + JsonConvert.SerializeObject(o));\n                           Console.WriteLine(\"SQLServerCoverageCore App is in Verbose mode!\");\n                       }\n                       else\n                       {\n                           Console.WriteLine($\"Current Arguments: -v {o.Verbose} -c {o.Command}\");\n                           Console.WriteLine(\":::Running SQLServerCoverageCore:::\");\n                       }\n                       var cType = CommandType.Unknown;\n                       var eType = ExportType.Unknown;\n                       string[] requiredParameters = null;\n                       string[] requiredExportParameters = null;\n                       switch (o.Command)\n                       {\n                           case \"Get-CoverTSql\":\n                               cType = CommandType.GetCoverTSql;\n                               requiredParameters = new string[]{\n                                \"connectionString\",\n                                \"databaseName\",\n                                \"query\"};\n                               break;\n                           default:\n                               Console.Error.WriteLine(\"Command:\" + o.Command + \" is not supported\");\n                               break;\n                       }\n\n                       switch (o.ExportType)\n                       {\n                           case \"Export-OpenXml\":\n                               eType = ExportType.ExportOpenXml;\n                               requiredExportParameters = new string[]{\n                                \"outputPath\"};\n                               break;\n                           case \"Export-Html\":\n                               eType = ExportType.ExportHtml;\n                               requiredExportParameters = new string[]{\n                                \"outputPath\"};\n                               break;\n                           case \"Export-Cobertura\":\n                               eType = ExportType.ExportCobertura;\n                               requiredExportParameters = new string[]{\n                                \"outputPath\"};\n                               break;\n                           default:\n                               // coverage result will be serialized as json for future reference\n                               requiredExportParameters = new string[]{\n                                \"outputPath\"};\n                               break;\n                       }\n\n                       bool isValid = (cType != CommandType.Unknown)\n                                       && validateRequired(o, requiredParameters)\n                                       && validateRequired(o, requiredExportParameters, isExportParams: true);\n", "                       if (isValid)\n                       {\n                           if (o.GetRequiredParameters)\n                           {\n                               Console.WriteLine(o.Command + \" requiredParameters are:\" + string.Join(',', requiredParameters));\n                               Console.WriteLine(o.ExportType + \" requiredParameters are:\" + string.Join(',', requiredExportParameters));\n                           }\n                           else\n                           {\n                               Console.WriteLine(\":::Running command\" + cType.ToString() + \":::\");\n                               CodeCoverage coverage = null;\n                               CoverageResult results = null;\n                               // run command\n                               switch (cType)\n                               {\n                                   case CommandType.GetCoverTSql:\n                                       coverage = new CodeCoverage(o.ConnectionString, o.databaseName, o.IgnoreObjects?.Split(), true, o.Debug);\n                                       results = coverage.Cover(o.Query, Math.Max(o.TimeOut, 0));\n                                       break;\n\n                               }", "                               if (coverage != null && results != null)\n                               {\n                                   Console.WriteLine(\":::Exporting Result with \" + eType.ToString() + \":::\");\n                                   var resultString = \"\";\n                                   var outputPath = \"\";\n                                   string openCoverXml = null;\n\n                                   if (!string.IsNullOrWhiteSpace(o.OutputPath))\n                                   {\n                                       outputPath = o.OutputPath;\n                                       if (outputPath.Substring(outputPath.Length - 1, 1) != Path.DirectorySeparatorChar.ToString())\n                                       {\n                                           outputPath += Path.DirectorySeparatorChar;\n                                       }\n                                   }\n                                   else\n                                   {\n                                       outputPath = DefaultLocation + Path.DirectorySeparatorChar + DateTime.Now.ToString(\"yyyyMMdd_HHmmss\") + Path.DirectorySeparatorChar;", "                                       if (outputPath.Substring(outputPath.Length - 1, 1) != Path.DirectorySeparatorChar.ToString())\n                                       {\n                                           outputPath += Path.DirectorySeparatorChar;\n                                       }\n                                   }\n                                   else\n                                   {\n                                       outputPath = DefaultLocation + Path.DirectorySeparatorChar + DateTime.Now.ToString(\"yyyyMMdd_HHmmss\") + Path.DirectorySeparatorChar;\n                                       if (!Directory.Exists(outputPath))\n                                       {\n                                           Directory.CreateDirectory(outputPath);\n                                       }\n                                   }\n                                   var openCoverFile = $\"{outputPath}{DefaultCoverageFileName}.opencover.xml\";\n                                   switch (eType)\n                                   {\n                                       case ExportType.ExportOpenXml:\n                                           openCoverXml = results.ToOpenCoverXml();\n                                           results.SaveResult(openCoverFile, openCoverXml);\n                                           results.SaveSourceFiles(outputPath);\n                                           break;\n                                       case ExportType.ExportHtml:\n                                           openCoverXml = results.ToOpenCoverXml();\n                                           results.SaveResult(openCoverFile, openCoverXml);\n                                           results.SaveSourceFiles(outputPath);\n\n                                           results.ToHtml(outputPath, outputPath, openCoverFile);\n                                           break;\n                                       case ExportType.ExportCobertura:\n                                           openCoverXml = results.ToOpenCoverXml();\n                                           results.SaveResult(openCoverFile, openCoverXml);\n                                           results.SaveSourceFiles(outputPath);\n\n                                           results.ToCobertura(outputPath, outputPath, openCoverFile);\n                                           break;\n                                       default:\n                                           Console.Error.WriteLine(\"Invalid export option provided. Saving Result as Json\");\n                                           resultString = results.ToJson();\n                                           results.SaveResult(outputPath + $\"{DefaultCoverageFileName}.json\", resultString);\n                                           results.SaveSourceFiles(outputPath);\n                                           break;\n                                   }\n                               }\n                           }\n                       }\n                   });\n        }\n\n        /// <summary>\n        /// Validate all the required arguments and print error message \n        /// </summary>\n        /// <param name=\"o\"> input arguments</param>\n        /// <param name=\"requiredParameters\">list of required parameters</param>\n        /// <returns></returns>", "                                       if (!Directory.Exists(outputPath))\n                                       {\n                                           Directory.CreateDirectory(outputPath);\n                                       }\n                                   }\n                                   var openCoverFile = $\"{outputPath}{DefaultCoverageFileName}.opencover.xml\";\n                                   switch (eType)\n                                   {\n                                       case ExportType.ExportOpenXml:\n                                           openCoverXml = results.ToOpenCoverXml();\n                                           results.SaveResult(openCoverFile, openCoverXml);\n                                           results.SaveSourceFiles(outputPath);\n                                           break;\n                                       case ExportType.ExportHtml:\n                                           openCoverXml = results.ToOpenCoverXml();\n                                           results.SaveResult(openCoverFile, openCoverXml);\n                                           results.SaveSourceFiles(outputPath);\n\n                                           results.ToHtml(outputPath, outputPath, openCoverFile);\n                                           break;\n                                       case ExportType.ExportCobertura:\n                                           openCoverXml = results.ToOpenCoverXml();\n                                           results.SaveResult(openCoverFile, openCoverXml);\n                                           results.SaveSourceFiles(outputPath);\n\n                                           results.ToCobertura(outputPath, outputPath, openCoverFile);\n                                           break;\n                                       default:\n                                           Console.Error.WriteLine(\"Invalid export option provided. Saving Result as Json\");\n                                           resultString = results.ToJson();\n                                           results.SaveResult(outputPath + $\"{DefaultCoverageFileName}.json\", resultString);\n                                           results.SaveSourceFiles(outputPath);\n                                           break;\n                                   }\n                               }\n                           }\n                       }\n                   });\n        }\n\n        /// <summary>\n        /// Validate all the required arguments and print error message \n        /// </summary>\n        /// <param name=\"o\"> input arguments</param>\n        /// <param name=\"requiredParameters\">list of required parameters</param>\n        /// <returns></returns>", "        private static bool validateRequired(Options o, string[] requiredParameters, bool isExportParams = false)\n        {\n            var valid = true;\n            var requiredString = isExportParams ? \" is required for this exportCommand\" : \" is required for this command\";\n            foreach (var param in requiredParameters)\n            {\n                switch (param)\n                {\n                    case \"connectionString\":\n                        if (string.IsNullOrWhiteSpace(o.ConnectionString))\n                        {\n                            Console.Error.WriteLine(\"connectionString\" + requiredString);\n                            valid = false;\n                        }\n                        break;\n                    case \"databaseName\":", "                        if (string.IsNullOrWhiteSpace(o.ConnectionString))\n                        {\n                            Console.Error.WriteLine(\"connectionString\" + requiredString);\n                            valid = false;\n                        }\n                        break;\n                    case \"databaseName\":\n                        if (string.IsNullOrWhiteSpace(o.databaseName))\n                        {\n                            Console.Error.WriteLine(\"databaseName\" + requiredString);\n                            valid = false;\n                        }\n                        break;\n                    case \"query\":", "                        if (string.IsNullOrWhiteSpace(o.Query))\n                        {\n                            Console.Error.WriteLine(\"query\" + requiredString);\n                            valid = false;\n                        }\n                        break;\n                    case \"outputPath\":\n                        if (!string.IsNullOrWhiteSpace(o.OutputPath))\n                        {\n                            if (!Directory.Exists(o.OutputPath))\n                            {\n                                Console.Error.WriteLine(\"outputPath:\" + o.OutputPath + \" is not a valid directory.\");\n                                return false;\n                            }\n\n                        }\n                        else\n                        {\n                            o.OutputPath = string.Empty;\n                        }\n                        break;\n\n                    default:\n                        Console.WriteLine(\"Required check on:\" + param + \" ignored\");\n                        // will always be invalid for commands not validated on a required param\n                        valid = false;\n                        break;\n                }\n            }\n            return valid;\n        }\n    }\n}\n", "                            if (!Directory.Exists(o.OutputPath))\n                            {\n                                Console.Error.WriteLine(\"outputPath:\" + o.OutputPath + \" is not a valid directory.\");\n                                return false;\n                            }\n\n                        }\n                        else\n                        {\n                            o.OutputPath = string.Empty;\n                        }\n                        break;\n\n                    default:\n                        Console.WriteLine(\"Required check on:\" + param + \" ignored\");\n                        // will always be invalid for commands not validated on a required param\n                        valid = false;\n                        break;\n                }\n            }\n            return valid;\n        }\n    }\n}\n"]}
{"filename": "src/SQLServerCoverageLib/CodeCoverage.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\nusing SQLServerCoverage.Gateway;\nusing SQLServerCoverage.Source;\nusing SQLServerCoverage.Trace;\n", "using SQLServerCoverage.Trace;\n\nnamespace SQLServerCoverage\n{\n    public class CodeCoverage\n    {\n        private const int MAX_DISPATCH_LATENCY = 1000;\n        private readonly DatabaseGateway _database;\n        private readonly string _databaseName;\n        private readonly bool _debugger;\n        private readonly TraceControllerType _traceType;", "        private readonly string _databaseName;\n        private readonly bool _debugger;\n        private readonly TraceControllerType _traceType;\n        private readonly List<string> _excludeFilter;\n        private readonly bool _logging;\n        private readonly SourceGateway _source;\n        private CoverageResult _result;\n\n        public const short TIMEOUT_EXPIRED = -2; //From TdsEnums\n        public SQLServerCoverageException Exception { get; private set; } = null;\n        public bool IsStarted { get; private set; } = false;\n", "        public const short TIMEOUT_EXPIRED = -2; //From TdsEnums\n        public SQLServerCoverageException Exception { get; private set; } = null;\n        public bool IsStarted { get; private set; } = false;\n\n        private TraceController _trace;\n\n        //This is to better support powershell and optional parameters\n        public CodeCoverage(string connectionString, string databaseName) : this(connectionString, databaseName, null, false, false, TraceControllerType.Default)\n        {\n        }\n\n        public CodeCoverage(string connectionString, string databaseName, string[] excludeFilter) : this(connectionString, databaseName, excludeFilter, false, false, TraceControllerType.Default)\n        {\n        }\n\n        public CodeCoverage(string connectionString, string databaseName, string[] excludeFilter, bool logging) : this(connectionString, databaseName, excludeFilter, logging, false, TraceControllerType.Default)\n        {\n        }\n\n        public CodeCoverage(string connectionString, string databaseName, string[] excludeFilter, bool logging, bool debugger) : this(connectionString, databaseName, excludeFilter, logging, debugger, TraceControllerType.Default)\n        {\n        }\n\n        public CodeCoverage(string connectionString, string databaseName, string[] excludeFilter, bool logging, bool debugger, TraceControllerType traceType)\n        {", "            if (debugger)\n                Debugger.Launch();\n\n            _databaseName = databaseName;\n            if (excludeFilter == null)\n                excludeFilter = new string[0];\n\n            _excludeFilter = excludeFilter.ToList();\n            _logging = logging;\n            _debugger = debugger;\n            _traceType = traceType;\n            _database = new DatabaseGateway(connectionString, databaseName);\n            _source = new DatabaseSourceGateway(_database);\n        }\n", "        public bool Start(int timeOut = 30)\n        {\n            Exception = null;\n            try\n            {\n                _database.TimeOut = timeOut;\n                _trace = new TraceControllerBuilder().GetTraceController(_database, _databaseName, _traceType);\n                _trace.Start();\n                IsStarted = true;\n                return true;\n            }", "            catch (Exception ex)\n            {\n                Debug(\"Error starting trace: {0}\", ex);\n                Exception = new SQLServerCoverageException(\"SQL Cover failed to start.\", ex);\n                IsStarted = false;\n                return false;\n            }\n        }\n\n        private List<string> StopInternal()\n        {\n            var events = _trace.ReadTrace();\n            _trace.Stop();\n            _trace.Drop();\n\n            return events;\n        }\n", "        public CoverageResult Stop()\n        {\n            if (!IsStarted)\n                throw new SQLServerCoverageException(\"SQL Cover was not started, or did not start correctly.\");\n\n            IsStarted = false;\n\n            WaitForTraceMaxLatency();\n\n            var results = StopInternal();\n\n            GenerateResults(_excludeFilter, results, new List<string>(), \"SQLServerCoverage result of running external process\");\n\n            return _result;\n        }\n", "        private void Debug(string message, params object[] args)\n        {\n            if (_logging)\n                Console.WriteLine(message, args);\n        }\n\n        public CoverageResult Cover(string command, int timeOut = 30)\n        {\n\n            Debug(\"Starting Code Coverage\");\n\n            _database.TimeOut = timeOut;\n", "            if (!Start())\n            {\n                throw new SQLServerCoverageException(\"Unable to start the trace - errors are recorded in the debug output\");\n\n            }\n\n            Debug(\"Executing Command: {0}\", command);\n\n            var sqlExceptions = new List<string>();\n\n            try\n            {\n                _database.Execute(command, timeOut, true);\n            }", "            catch (System.Data.SqlClient.SqlException e)\n            {\n                if (e.Number == -2)\n                {\n                    throw;\n                }\n\n                sqlExceptions.Add(e.Message);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(\"Exception running command: {0} - error: {1}\", command, e.Message);\n            }\n\n            Debug(\"Executing Command: {0}...done\", command);\n            WaitForTraceMaxLatency();\n            Debug(\"Stopping Code Coverage\");\n            try\n            {\n                var rawEvents = StopInternal();\n\n                Debug(\"Getting Code Coverage Result\");\n                GenerateResults(_excludeFilter, rawEvents, sqlExceptions, $\"SQLServerCoverage result of running '{command}'\");\n                Debug(\"Result generated\");\n            }", "            catch (Exception e)\n            {\n                Console.WriteLine(\"Exception running command: {0} - error: {1}\", command, e.Message);\n            }\n\n            Debug(\"Executing Command: {0}...done\", command);\n            WaitForTraceMaxLatency();\n            Debug(\"Stopping Code Coverage\");\n            try\n            {\n                var rawEvents = StopInternal();\n\n                Debug(\"Getting Code Coverage Result\");\n                GenerateResults(_excludeFilter, rawEvents, sqlExceptions, $\"SQLServerCoverage result of running '{command}'\");\n                Debug(\"Result generated\");\n            }", "            catch (Exception e)\n            {\n                Console.Write(e.StackTrace);\n                throw new SQLServerCoverageException(\"Exception gathering the results\", e);\n            }\n\n            return _result;\n        }\n\n\n        private static void WaitForTraceMaxLatency()\n        {\n            Thread.Sleep(MAX_DISPATCH_LATENCY);\n        }\n", "        private static void WaitForTraceMaxLatency()\n        {\n            Thread.Sleep(MAX_DISPATCH_LATENCY);\n        }\n\n        private void GenerateResults(List<string> filter, List<string> xml, List<string> sqlExceptions, string commandDetail)\n        {\n            var batches = _source.GetBatches(filter);\n            _result = new CoverageResult(batches, xml, _databaseName, _database.DataSource, sqlExceptions, commandDetail);\n        }\n", "        public CoverageResult Results()\n        {\n            return _result;\n        }\n    }\n}"]}
{"filename": "src/SQLServerCoverageLib/StatementChecker.cs", "chunked_list": ["using SQLServerCoverage.Objects;\n\nnamespace SQLServerCoverage\n{\n    public class StatementChecker\n    {\n        public bool Overlaps(Statement statement, CoveredStatement coveredStatement)\n        {\n            var coveredOffsetStart = coveredStatement.Offset / 2;\n            var coveredOffsetEnd = coveredStatement.OffsetEnd;\n", "            if (coveredOffsetEnd == -1)\n            {\n                // Last statement in the batch, so only covered if the 'start' is equal to or less than the statement start\n                return (statement.Offset >= coveredOffsetStart);\n            }\n\n            var statementStart = statement.Offset;\n            var statementEnd = statementStart + statement.Length;\n            coveredOffsetEnd = coveredStatement.OffsetEnd / 2;\n\n            if (statementStart >= coveredOffsetStart && statementEnd <= coveredOffsetEnd)\n            {\n                return true;\n            }\n\n            //this is a little painful:\n            // https://connect.microsoft.com/SQLServer/feedback/details/3124768\n            /*\n                i don't think this is an actual problem because on the offsetEnd is wrong, the offsetStart is right so even if there was something like:\n                    exec a;b; \n                    which would execute proc a and b, we wouldn't mark b as executed when a was executed because the start would be before b\n             */\n            coveredOffsetEnd = coveredOffsetEnd +2;\n", "            if (statementStart >= coveredOffsetStart && statementEnd <= coveredOffsetEnd)\n            {\n                return true;\n            }\n\n            //this is a little painful:\n            // https://connect.microsoft.com/SQLServer/feedback/details/3124768\n            /*\n                i don't think this is an actual problem because on the offsetEnd is wrong, the offsetStart is right so even if there was something like:\n                    exec a;b; \n                    which would execute proc a and b, we wouldn't mark b as executed when a was executed because the start would be before b\n             */\n            coveredOffsetEnd = coveredOffsetEnd +2;\n", "            if (statementStart >= coveredOffsetStart && statementEnd <= coveredOffsetEnd)\n            {\n                return true;\n            }\n\n            return false;\n\n        }\n\n        \n        public bool Overlaps(Statement statement, int offsetStart, int offsetEnd)\n        {\n            var statementStart = statement.Offset;\n            var statementEnd = statementStart + statement.Length;\n", "        public bool Overlaps(Statement statement, int offsetStart, int offsetEnd)\n        {\n            var statementStart = statement.Offset;\n            var statementEnd = statementStart + statement.Length;\n\n            if (statementStart >= offsetStart && statementEnd <= offsetEnd)\n            {\n                return true;\n            }\n\n            return false;\n        }\n    }\n}"]}
{"filename": "src/SQLServerCoverageLib/CoverageResult.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Security;\nusing System.Text;\nusing SQLServerCoverage.Objects;\nusing SQLServerCoverage.Parsers;\nusing SQLServerCoverage.Serializers;\nusing Newtonsoft.Json;", "using SQLServerCoverage.Serializers;\nusing Newtonsoft.Json;\nusing Palmmedia.ReportGenerator.Core;\nusing ReportGenerator;\n\nnamespace SQLServerCoverage\n{\n    public class CoverageResult : CoverageSummary\n    {\n        private readonly IEnumerable<Batch> _batches;\n        private readonly List<string> _sqlExceptions;", "        private readonly IEnumerable<Batch> _batches;\n        private readonly List<string> _sqlExceptions;\n        private readonly string _commandDetail;\n\n        public string DatabaseName { get; }\n        public string DataSource { get; }\n\n        public List<string> SqlExceptions\n        {\n            get { return _sqlExceptions; }\n        }\n\n        public IEnumerable<Batch> Batches\n        {\n            get { return _batches; }\n        }", "        private readonly StatementChecker _statementChecker = new StatementChecker();\n\n        public CoverageResult(IEnumerable<Batch> batches, List<string> xml, string database, string dataSource, List<string> sqlExceptions, string commandDetail)\n        {\n            _batches = batches;\n            _sqlExceptions = sqlExceptions;\n            _commandDetail = $\"{commandDetail} at {DateTime.Now}\";\n            DatabaseName = database;\n            DataSource = dataSource;\n            var parser = new EventsParser(xml);\n\n            var statement = parser.GetNextStatement();\n", "            while (statement != null)\n            {\n                var batch = _batches.FirstOrDefault(p => p.ObjectId == statement.ObjectId);\n                if (batch != null)\n                {\n                    var item = batch.Statements.FirstOrDefault(p => _statementChecker.Overlaps(p, statement));\n                    if (item != null)\n                    {\n                        item.HitCount++;\n                    }\n                }\n\n                statement = parser.GetNextStatement();\n            }\n", "            foreach (var batch in _batches)\n            {\n                foreach (var item in batch.Statements)\n                {\n                    foreach (var branch in item.Branches)\n                    {\n                        var branchStatement = batch.Statements\n                            .Where(x => _statementChecker.Overlaps(x, branch.Offset, branch.Offset + branch.Length))\n                            .FirstOrDefault();\n\n                        branch.HitCount = branchStatement.HitCount;\n                    }\n                }\n\n                batch.CoveredStatementCount = batch.Statements.Count(p => p.HitCount > 0);\n                batch.CoveredBranchesCount = batch.Statements.SelectMany(p => p.Branches).Count(p => p.HitCount > 0);\n                batch.HitCount = batch.Statements.Sum(p => p.HitCount);\n            }\n\n            CoveredStatementCount = _batches.Sum(p => p.CoveredStatementCount);\n            CoveredBranchesCount = _batches.Sum(p => p.CoveredBranchesCount);\n            BranchesCount = _batches.Sum(p => p.BranchesCount);\n            StatementCount = _batches.Sum(p => p.StatementCount);\n            HitCount = _batches.Sum(p => p.HitCount);\n\n\n        }\n", "        public void SaveResult(string path, string resultString)\n        {\n            File.WriteAllText(path, resultString);\n        }\n\n        public void SaveSourceFiles(string path)\n        {\n            foreach (var batch in _batches)\n            {\n                File.WriteAllText(Path.Combine(path, batch.ObjectName), batch.Text);\n            }\n        }", "        private static string Unquote(string quotedStr) => quotedStr.Replace(\"'\", \"\\\"\");\n\n        public string ToOpenCoverXml()\n        {\n            return new OpenCoverXmlSerializer().Serialize(this);\n        }\n\n        public string ToJson()\n        {\n            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Formatting.Indented);\n        }\n\n        /// <summary>\n        /// Use ReportGenerator Tool to Convert Open XML To Inline HTML\n        /// </summary>\n        /// <param name=\"targetDirectory\">diretory where report will be generated</param>\n        /// <param name=\"sourceDirectory\">source directory</param>\n        /// <param name=\"openCoverFile\">source path of open cover report</param>\n        /// <returns></returns>", "        public void ToHtml(string targetDirectory, string sourceDirectory, string openCoverFile)\n        {\n            var reportType = \"HtmlInline\";\n            generateReport(targetDirectory, sourceDirectory, openCoverFile, reportType);\n        }\n\n        /// <summary>\n        /// Use ReportGenerator Tool to Convert Open XML To Cobertura\n        /// </summary>\n        /// <param name=\"targetDirectory\">diretory where report will be generated</param>\n        /// <param name=\"sourceDirectory\">source directory</param>\n        /// <param name=\"openCoverFile\">source path of open cover report</param>\n        /// <returns></returns>", "        public void ToCobertura(string targetDirectory, string sourceDirectory, string openCoverFile)\n        {\n            var reportType = \"Cobertura\";\n            generateReport(targetDirectory, sourceDirectory, openCoverFile, reportType);\n        }\n\n\n        /// <summary>\n        /// Use ReportGenerator Tool to Convert Open Cover XML To Required Report Type\n        /// </summary>\n        /// TODO : Use Enum for Report Type\n        /// <param name=\"targetDirectory\">diretory where report will be generated</param>\n        /// <param name=\"sourceDirectory\">source directory</param>\n        /// <param name=\"openCoverFile\">source path of open cover report</param>\n        /// <param name=\"reportType\">type of report to be generated</param>", "        public void generateReport(string targetDirectory, string sourceDirectory, string openCoverFile, string reportType)\n        {\n            var reportGenerator = new Generator();\n            var reportConfiguration = new ReportConfigurationBuilder().Create(new Dictionary<string, string>()\n                                            {\n                                                { \"REPORTS\", openCoverFile },\n                                                { \"TARGETDIR\", targetDirectory },\n                                                { \"SOURCEDIRS\", sourceDirectory },\n                                                { \"REPORTTYPES\", reportType},\n                                                { \"VERBOSITY\", \"Info\" },\n\n                                            });\n            Console.ForegroundColor = ConsoleColor.Cyan;\n            Console.WriteLine($\"Report from : '{Path.GetFullPath(openCoverFile)}' \\n will be used to generate {reportType} report in: {Path.GetFullPath(targetDirectory)} directory\");\n            Console.ResetColor();\n            var isGenerated = reportGenerator.GenerateReport(reportConfiguration);", "            if (!isGenerated)\n                Console.WriteLine($\"Error Generating {reportType} Report.Check logs for more details\");\n        }\n\n        public static OpenCoverOffsets GetOffsets(Statement statement, string text)\n            => GetOffsets(statement.Offset, statement.Length, text);\n\n        public static OpenCoverOffsets GetOffsets(int offset, int length, string text, int lineStart = 1)\n        {\n            var offsets = new OpenCoverOffsets();\n\n            var column = 1;\n            var line = lineStart;\n            var index = 0;\n", "            while (index < text.Length)\n            {\n                switch (text[index])\n                {\n                    case '\\n':\n                        line++;\n                        column = 0;\n                        break;\n                    default:\n\n                        if (index == offset)\n                        {\n                            offsets.StartLine = line;\n                            offsets.StartColumn = column;\n                        }\n", "                        if (index == offset)\n                        {\n                            offsets.StartLine = line;\n                            offsets.StartColumn = column;\n                        }\n\n                        if (index == offset + length)\n                        {\n                            offsets.EndLine = line;\n                            offsets.EndColumn = column;\n                            return offsets;\n                        }\n                        column++;\n                        break;\n                }\n\n                index++;\n            }\n\n            return offsets;\n        }\n\n", "        public string NCoverXml()\n        {\n            return \"\";\n        }\n    }\n\n    public struct OpenCoverOffsets\n    {\n        public int StartLine;\n        public int EndLine;\n        public int StartColumn;", "        public int StartLine;\n        public int EndLine;\n        public int StartColumn;\n        public int EndColumn;\n    }\n\n    public class CustomCoverageUpdateParameter\n    {\n        public Batch Batch { get; internal set; }\n        public int LineCorrection { get; set; } = 0;\n        public int OffsetCorrection { get; set; } = 0;\n    }\n}\n", "        public Batch Batch { get; internal set; }\n        public int LineCorrection { get; set; } = 0;\n        public int OffsetCorrection { get; set; } = 0;\n    }\n}\n"]}
{"filename": "src/SQLServerCoverageLib/SQLServerCoverageException.cs", "chunked_list": ["\ufeffusing System;\nusing System.Runtime.Serialization;\n\nnamespace SQLServerCoverage\n{\n    [Serializable]\n    public class SQLServerCoverageException : Exception\n    {\n        public SQLServerCoverageException()\n        {\n        }\n\n        public SQLServerCoverageException(string message) : base(message)\n        {\n        }\n\n        public SQLServerCoverageException(string message, Exception innerException) : base(message, innerException)\n        {\n        }\n\n        protected SQLServerCoverageException(SerializationInfo info, StreamingContext context) : base(info, context)\n        {\n        }\n    }\n}"]}
{"filename": "src/SQLServerCoverageLib/Gateway/DatabaseSourceGateway.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing SQLServerCoverage.Gateway;\nusing SQLServerCoverage.Objects;\nusing SQLServerCoverage.Parsers;\n", "using SQLServerCoverage.Parsers;\n\nnamespace SQLServerCoverage.Source\n{\n    public class DatabaseSourceGateway : SourceGateway\n    {\n        private readonly DatabaseGateway _databaseGateway;\n\n        public DatabaseSourceGateway(DatabaseGateway databaseGateway)\n        {\n            _databaseGateway = databaseGateway;\n        }\n", "        public SqlServerVersion GetVersion()\n        {\n            var compatibilityString = _databaseGateway.GetString(\"select compatibility_level from sys.databases where database_id = db_id();\");\n            SqlServerVersion res;\n            if (Enum.TryParse(string.Format(\"Sql{0}\", compatibilityString), out res))\n            {\n                return res;\n            }\n\n            return SqlServerVersion.Sql130;\n        }\n\n", "        public bool IsAzure()\n        {\n            var versionString = _databaseGateway.GetString(\"select @@version\");\n            return versionString.Contains(\"Azure\");\n        }\n\n\n        public IEnumerable<Batch> GetBatches(List<string> objectFilter)\n        {\n            var table =\n                _databaseGateway.GetRecords(\n                           \n                            \"SELECT sm.object_id, ISNULL('[' + OBJECT_SCHEMA_NAME(sm.object_id) + '].[' + OBJECT_NAME(sm.object_id) + ']', '[' + st.name + ']')  object_name, sm.definition, sm.uses_quoted_identifier FROM sys.sql_modules sm LEFT JOIN sys.triggers st ON st.object_id = sm.object_id WHERE sm.object_id NOT IN(SELECT object_id FROM sys.objects WHERE type = 'IF'); \");\n\n            var batches = new List<Batch>();\n            \n            var version = GetVersion();\n            var excludedObjects = GetExcludedObjects();", "            if(objectFilter == null)\n                objectFilter = new List<string>();\n\n            objectFilter.Add(\".*tSQLt.*\");\n\n            foreach (DataRow row in table.Rows)\n            {\n                var quoted = (bool) row[\"uses_quoted_identifier\"];\n                \n                var name = row[\"object_name\"] as string;\n                ", "                if (name != null && row[\"object_id\"] as int? != null && ShouldIncludeObject(name, objectFilter, excludedObjects))\n                {\n                    batches.Add(\n                        new Batch(new StatementParser(version), quoted, EndDefinitionWithNewLine(GetDefinition(row)), name, name, (int) row[\"object_id\"]));\n\n                }\n                \n            }\n\n            table.Dispose();\n", "            foreach (var batch in batches)\n            {\n                batch.StatementCount = batch.Statements.Count(p => p.IsCoverable);\n                batch.BranchesCount = batch.Statements.SelectMany(x => x.Branches).Count();\n            }\n\n            return batches.Where(p=>p.StatementCount > 0);\n        }\n\n        private static string GetDefinition(DataRow row)\n        {", "        private static string GetDefinition(DataRow row)\n        {\n            if (row[\"definition\"] != null && row[\"definition\"] is string)\n            {\n                var definition = row[\"definition\"] as string;\n\n                if (!String.IsNullOrEmpty(definition))\n                    return definition;\n            }\n\n            return String.Empty;\n            \n  }", "        public string GetWarnings()\n        {\n            var warnings = new StringBuilder();\n\n            var table =\n                _databaseGateway.GetRecords(\n                    \"select \\'[\\' + object_schema_name(object_id) + \\'].[\\' + object_name(object_id) + \\']\\' as object_name from sys.sql_modules where object_id not in (select object_id from sys.objects where type = 'IF') and definition is null\");\n\n\n            foreach (DataRow row in table.Rows)\n            {", "            foreach (DataRow row in table.Rows)\n            {\n                if(row[\"object_name\"] == null || row[\"object_name\"] as string == null)\n                {\n                    warnings.AppendFormat(\"An object_name was not found, unable to provide code coverage results, I don't even know the name to tell you what it was - check sys.sql_modules where definition is null and the object is not an inline function\");\n\n                }\n                else\n                {\n                    var name = (string)row[\"object_name\"];\n\n                    warnings.AppendFormat(\"The object definition for {0} was not found, unable to provide code coverage results\", name);\n\n                }\n\n            }\n\n            return warnings.ToString();\n\n        }\n", "        private static string EndDefinitionWithNewLine(string definition)\n        {\n            if (definition.EndsWith(\"\\r\\n\\r\\n\"))\n                return definition;\n\n            return definition + \"\\r\\n\\r\\n\";\n        }\n\n        private List<string> GetExcludedObjects()\n        {\n            var tSQLtObjects =\n                _databaseGateway.GetRecords(\n                    @\"select  '[' + object_schema_name(object_id) + '].[' + object_name(object_id) + ']' as object_name from sys.procedures\n\twhere schema_id in (\nselect major_id from sys.extended_properties ep\n\twhere class_desc = 'SCHEMA' and name = 'tSQLt.TestClass' )\");\n\n            var excludedObjects = new List<string>();\n", "            foreach (DataRow row in tSQLtObjects.Rows)\n            {\n                excludedObjects.Add(row[0].ToString().ToLowerInvariant());\n            }\n\n            return excludedObjects;\n\n        }\n\n        private bool ShouldIncludeObject(string name, List<string> customExcludedObjects, List<string> excludedObjects)\n        {\n            var lowerName = name.ToLowerInvariant();\n", "        private bool ShouldIncludeObject(string name, List<string> customExcludedObjects, List<string> excludedObjects)\n        {\n            var lowerName = name.ToLowerInvariant();\n\n            foreach (var filter in customExcludedObjects)\n            {\n                if (Regex.IsMatch(name, (string) (filter ?? \".*\")))\n                    return false;\n            }\n\n            foreach (var filter in excludedObjects)\n            {", "            foreach (var filter in excludedObjects)\n            {\n                if (filter == lowerName)\n                    return false;\n            }\n            \n            return true;\n        }\n    }\n}"]}
{"filename": "src/SQLServerCoverageLib/Gateway/SourceGateway.cs", "chunked_list": ["\ufeffusing System.Collections.Generic;\nusing SQLServerCoverage.Objects;\n\nnamespace SQLServerCoverage.Source\n{\n    public interface SourceGateway\n    {\n        SqlServerVersion GetVersion();\n        IEnumerable<Batch> GetBatches(List<string> objectFilter);\n        string GetWarnings();\n    }\n}"]}
{"filename": "src/SQLServerCoverageLib/Gateway/DatabaseGateway.cs", "chunked_list": ["\ufeffusing System;\nusing System.Data;\nusing System.Data.Common;\nusing System.Data.SqlClient;\nusing System.Xml;\n\nnamespace SQLServerCoverage.Gateway\n{\n    public class DatabaseGateway\n    {\n        private readonly string _connectionString;", "    public class DatabaseGateway\n    {\n        private readonly string _connectionString;\n        private readonly string _databaseName;\n        private readonly SqlConnectionStringBuilder _connectionStringBuilder;\n        public string DataSource { get { return _connectionStringBuilder.DataSource; } }\n\n        public int TimeOut { get; set; }\n\n        public DatabaseGateway()\n        {\n            //for mocking.\n        }\n        public DatabaseGateway(string connectionString, string databaseName)\n        {\n            TimeOut = 60;\n            _connectionString = connectionString;\n            _databaseName = databaseName;\n            _connectionStringBuilder = new SqlConnectionStringBuilder(connectionString);\n        }\n", "        public virtual string GetString(string query)\n        {\n            using (var conn = new SqlConnection(_connectionString))\n            {\n                conn.Open();\n                if (!string.IsNullOrEmpty(_databaseName))\n                    conn.ChangeDatabase(_databaseName);\n                using (var cmd = conn.CreateCommand())\n                {\n                    cmd.CommandText = query;\n                    cmd.CommandTimeout = TimeOut;\n\n                    var scalarResult = cmd.ExecuteScalar();\n", "                    if (scalarResult != null) return scalarResult.ToString();\n\n                    return null;\n                }\n            }\n        }\n\n        public virtual DataTable GetRecords(string query)\n        {\n            using (var conn = new SqlConnection(_connectionString))\n            {\n                conn.Open();\n                conn.ChangeDatabase(_databaseName);", "            using (var conn = new SqlConnection(_connectionString))\n            {\n                conn.Open();\n                conn.ChangeDatabase(_databaseName);\n                using (var cmd = conn.CreateCommand())\n                {\n                    cmd.CommandText = query;\n                    cmd.CommandTimeout = TimeOut;\n                    using (var reader = cmd.ExecuteReader())\n                    {\n                        var ds = new DataTable();\n                        ds.Load(reader);\n                        return ds;\n                    }\n                }\n            }\n        }\n", "                    using (var reader = cmd.ExecuteReader())\n                    {\n                        var ds = new DataTable();\n                        ds.Load(reader);\n                        return ds;\n                    }\n                }\n            }\n        }\n\n        public virtual DataTable GetTraceRecords(string query)\n        {", "        public virtual DataTable GetTraceRecords(string query)\n        {\n            using (var conn = new SqlConnection(_connectionString))\n            {\n                conn.Open();\n                conn.ChangeDatabase(_databaseName);\n                using (var cmd = conn.CreateCommand())\n                {\n                    cmd.CommandTimeout = TimeOut;\n                    cmd.CommandText = query;\n                    using (var reader = cmd.ExecuteReader())\n                    {\n                        var ds = new DataTable();\n                        ds.Columns.Add(new DataColumn(\"xml\"));", "                    using (var reader = cmd.ExecuteReader())\n                    {\n                        var ds = new DataTable();\n                        ds.Columns.Add(new DataColumn(\"xml\"));\n                        while (reader.Read())\n                        {\n                            XmlDocument xml = new XmlDocument();\n                            xml.LoadXml(reader[0].ToString());\n\n                            var root = xml.SelectNodes(\"/event\").Item(0);\n\n                            var objectId = xml.SelectNodes(\"/event/data[@name='object_id']\").Item(0);\n                            var offset = xml.SelectNodes(\"/event/data[@name='offset']\").Item(0);\n                            var offsetEnd = xml.SelectNodes(\"/event/data[@name='offset_end']\").Item(0);\n\n                            root.RemoveAll();\n\n                            root.AppendChild(objectId);\n                            root.AppendChild(offset);\n                            root.AppendChild(offsetEnd);\n\n                            var row = ds.NewRow();\n                            row[\"xml\"] = root.OuterXml;\n                            ds.Rows.Add(row);\n\n                        }\n\n                        return ds;\n                    }\n                }\n            }\n        }\n", "        public void Execute(string command, int timeOut, bool isQuery = false)\n        {\n            using (var conn = new SqlConnection(_connectionString))\n            {\n                conn.Open();\n                conn.ChangeDatabase(_databaseName);\n                if (isQuery)\n                    conn.InfoMessage += new SqlInfoMessageEventHandler(printSQLExecutionMessage);\n                using (var cmd = conn.CreateCommand())\n                {\n                    cmd.CommandText = command;\n                    cmd.CommandTimeout = timeOut;\n                    cmd.ExecuteNonQuery();\n                }\n                conn.Close();\n                conn.Dispose();\n            }\n        }\n\n        void printSQLExecutionMessage(object sender, SqlInfoMessageEventArgs e)\n        {\n            Console.ForegroundColor = ConsoleColor.Green;\n            Console.WriteLine(e.Message);\n            Console.ResetColor();\n        }\n    }\n}\n", "                using (var cmd = conn.CreateCommand())\n                {\n                    cmd.CommandText = command;\n                    cmd.CommandTimeout = timeOut;\n                    cmd.ExecuteNonQuery();\n                }\n                conn.Close();\n                conn.Dispose();\n            }\n        }\n\n        void printSQLExecutionMessage(object sender, SqlInfoMessageEventArgs e)\n        {\n            Console.ForegroundColor = ConsoleColor.Green;\n            Console.WriteLine(e.Message);\n            Console.ResetColor();\n        }\n    }\n}\n"]}
{"filename": "src/SQLServerCoverageLib/Trace/AzureTraceController.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Threading;\nusing SQLServerCoverage.Gateway;\n\nnamespace SQLServerCoverage.Trace\n{\n    internal class AzureTraceController : TraceController\n    {\n        private const string CreateTrace = @\"CREATE EVENT SESSION [{0}] ON DATABASE \nADD EVENT sqlserver.sp_statement_starting(action (sqlserver.plan_handle, sqlserver.tsql_stack) where ([sqlserver].[database_id]=({1})))\nadd target package0.ring_buffer(set max_memory = 500\n) /* not file {2}*/\nWITH (EVENT_RETENTION_MODE=ALLOW_MULTIPLE_EVENT_LOSS,MAX_DISPATCH_LATENCY=1 SECONDS,MAX_EVENT_SIZE=0 KB,MEMORY_PARTITION_MODE=NONE,TRACK_CAUSALITY=OFF,STARTUP_STATE=OFF) \n\";\n", "    internal class AzureTraceController : TraceController\n    {\n        private const string CreateTrace = @\"CREATE EVENT SESSION [{0}] ON DATABASE \nADD EVENT sqlserver.sp_statement_starting(action (sqlserver.plan_handle, sqlserver.tsql_stack) where ([sqlserver].[database_id]=({1})))\nadd target package0.ring_buffer(set max_memory = 500\n) /* not file {2}*/\nWITH (EVENT_RETENTION_MODE=ALLOW_MULTIPLE_EVENT_LOSS,MAX_DISPATCH_LATENCY=1 SECONDS,MAX_EVENT_SIZE=0 KB,MEMORY_PARTITION_MODE=NONE,TRACK_CAUSALITY=OFF,STARTUP_STATE=OFF) \n\";\n\n        private const string StartTraceFormat = @\"alter event session [{0}] on database state = start\n\";\n", "        private const string StartTraceFormat = @\"alter event session [{0}] on database state = start\n\";\n\n        private const string StopTraceFormat = @\"alter event session [{0}] on database state = stop\n\";\n\n        private const string DropTraceFormat = @\"drop EVENT SESSION [{0}] ON database \";\n\n        private const string ReadTraceFormat = @\"declare @x xml = (\n\n    select target_data from sys.dm_xe_database_session_targets AS xet\n\n    JOIN sys.dm_xe_database_sessions AS xe\n\n       ON(xe.address = xet.event_session_address)\n\n    WHERE xe.name = '{0}');\n            with a as (\n            select x.p.query('.') v from  @x.nodes('/RingBufferTarget/event') as x(p)\n\t)\n\nselect  v.value('(/event/@timestamp)[1]', 'datetime'), v from a\n\n    where v.value('(/event/@timestamp)[1]', 'datetime') > '{1}'\";\n", "        private const string ReadTraceFormat = @\"declare @x xml = (\n\n    select target_data from sys.dm_xe_database_session_targets AS xet\n\n    JOIN sys.dm_xe_database_sessions AS xe\n\n       ON(xe.address = xet.event_session_address)\n\n    WHERE xe.name = '{0}');\n            with a as (\n            select x.p.query('.') v from  @x.nodes('/RingBufferTarget/event') as x(p)\n\t)\n\nselect  v.value('(/event/@timestamp)[1]', 'datetime'), v from a\n\n    where v.value('(/event/@timestamp)[1]', 'datetime') > '{1}'\";\n", "        private readonly List<string> _events = new List<string>();\n\n        private bool _stop;\n        private bool _stopped;\n        private bool _stopping;\n\n\n        public AzureTraceController(DatabaseGateway gateway, string databaseName) : base(gateway, databaseName)\n        {\n        }\n\n", "        private void Create()\n        {\n            RunScript(CreateTrace, \"Error creating the extended events trace, error: {0}\");\n        }\n\n        public override void Start()\n        {\n            Create();\n            RunScript(StartTraceFormat, \"Error starting the extended events trace, error: {0}\");\n            ThreadPool.QueueUserWorkItem(PollAzureForEvents);\n        }\n", "        private void PollAzureForEvents(object state)\n        {\n            var maxDateReceived = new DateTime(1980, 04, 01);\n\n            while (true)\n            {\n                try\n                {\n                    var records = Gateway.GetRecords(string.Format(ReadTraceFormat, Name, maxDateReceived.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")));\n                    \n                    foreach (DataRow row in records.Rows)\n                    {\n                        _events.Add(row.ItemArray[1].ToString());\n                        var date = (DateTime)row.ItemArray[0];\n", "                    foreach (DataRow row in records.Rows)\n                    {\n                        _events.Add(row.ItemArray[1].ToString());\n                        var date = (DateTime)row.ItemArray[0];\n\n                        if (date > maxDateReceived)\n                            maxDateReceived = date;\n                    }\n                }\n                catch (Exception)\n                {\n                }\n", "                catch (Exception)\n                {\n                }\n\n                if (_stopping)\n                {\n                    //first time we set _stopped but this guarantees that we end up with a final call to get any pending events...\n                    _stopped = true;\n                    return;\n                }\n", "                if (_stop)\n                {\n                    _stopping = true;\n                }\n                else\n                {\n                    Thread.Sleep(5000);\n                }\n            }\n        }\n", "        public void StopInternal()\n        {\n            _stop = true;\n            while (!_stopped)\n                Thread.Sleep(1000);\n\n            RunScript(StopTraceFormat, \"Error stopping the extended events trace, error: {0}\");\n        }\n\n\n        public override void Stop()\n        {\n            //stop is called from readtrace so we can read the data before closing it when using a ring buffer\n        }\n", "        public override void Stop()\n        {\n            //stop is called from readtrace so we can read the data before closing it when using a ring buffer\n        }\n\n        public override List<string> ReadTrace()\n        {\n            StopInternal();\n            return _events;\n        }\n", "        public override void Drop()\n        {\n            RunScript(DropTraceFormat, \"Error dropping the extended events trace, error: {0}\");\n        }\n    }\n}"]}
{"filename": "src/SQLServerCoverageLib/Trace/TraceControllerBuilder.cs", "chunked_list": ["using System;\nusing SQLServerCoverage.Gateway;\nusing SQLServerCoverage.Objects;\nusing SQLServerCoverage.Source;\n\nnamespace SQLServerCoverage.Trace\n{\n    class TraceControllerBuilder\n    {\n        public TraceController GetTraceController(DatabaseGateway gateway, string databaseName, TraceControllerType type)\n        {\n\n         \n            switch(type)\n            {\n                case TraceControllerType.Azure:\n                    return new AzureTraceController(gateway, databaseName);\n                case TraceControllerType.Sql:\n                    return new SqlTraceController(gateway, databaseName);\n                case TraceControllerType.SqlLocalDb:\n                    return new SqlLocalDbTraceController(gateway, databaseName);\n            }\n\n            var source = new DatabaseSourceGateway(gateway);\n", "        public TraceController GetTraceController(DatabaseGateway gateway, string databaseName, TraceControllerType type)\n        {\n\n         \n            switch(type)\n            {\n                case TraceControllerType.Azure:\n                    return new AzureTraceController(gateway, databaseName);\n                case TraceControllerType.Sql:\n                    return new SqlTraceController(gateway, databaseName);\n                case TraceControllerType.SqlLocalDb:\n                    return new SqlLocalDbTraceController(gateway, databaseName);\n            }\n\n            var source = new DatabaseSourceGateway(gateway);\n", "            if (LooksLikeLocalDb(gateway.DataSource))\n            {\n                return new SqlLocalDbTraceController(gateway, databaseName);\n            }\n\n\n            var isAzure = source.IsAzure();\n\n            if(!isAzure)\n                return new SqlTraceController(gateway, databaseName);\n            \n            var version = source.GetVersion();", "            if(!isAzure)\n                return new SqlTraceController(gateway, databaseName);\n            \n            var version = source.GetVersion();\n            if(version < SqlServerVersion.Sql120)\n                throw  new Exception(\"SQL Azure is only supported from Version 12\");\n\n            return new AzureTraceController(gateway, databaseName);\n        }\n\n        private bool LooksLikeLocalDb(string dataSource)\n        {\n            dataSource = dataSource.ToLowerInvariant();\n            return dataSource.Contains(\"(localdb)\") || dataSource.StartsWith(\"np:\\\\\\\\.\\\\pipe\\\\localdb\");\n        }\n    }\n", "        private bool LooksLikeLocalDb(string dataSource)\n        {\n            dataSource = dataSource.ToLowerInvariant();\n            return dataSource.Contains(\"(localdb)\") || dataSource.StartsWith(\"np:\\\\\\\\.\\\\pipe\\\\localdb\");\n        }\n    }\n\n    public enum TraceControllerType\n    {\n        Default,\n        Sql,\n        Azure,\n        Exp,\n        SqlLocalDb\n    }\n}"]}
{"filename": "src/SQLServerCoverageLib/Trace/TraceController.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing SQLServerCoverage.Gateway;\n\nnamespace SQLServerCoverage.Trace\n{\n    abstract class TraceController\n    {\n        protected readonly string DatabaseId;\n        protected readonly DatabaseGateway Gateway;\n        protected string FileName;\n        ", "        protected readonly string DatabaseId;\n        protected readonly DatabaseGateway Gateway;\n        protected string FileName;\n        \n        protected readonly string Name;\n        \n        public TraceController(DatabaseGateway gateway, string databaseName)\n        {\n            Gateway = gateway;\n            DatabaseId = gateway.GetString(string.Format(\"select db_id('{0}')\", databaseName));\n            Name = string.Format($\"SQLServerCoverage-Trace-{Guid.NewGuid().ToString()}\");\n        }\n", "        public abstract void Start();\n        public abstract void Stop();\n        public abstract List<string> ReadTrace();\n        public abstract void Drop();\n\n\n        protected void RunScript(string query, string error, int timeout = 60)\n        {\n            var script = GetScript(query);\n            try\n            {\n                Gateway.Execute(script, timeout);\n            }", "            catch (Exception ex)\n            {\n                throw new InvalidOperationException(string.Format(error, ex.Message), ex);\n            }\n        }\n\n        protected string GetScript(string query)\n        {\n            if (query.Contains(\"{2}\"))\n            {\n                return string.Format(query, Name, DatabaseId, FileName + \".xel\");\n            }\n", "            if (query.Contains(\"{2}\"))\n            {\n                return string.Format(query, Name, DatabaseId, FileName + \".xel\");\n            }\n\n            if (query.Contains(\"{1}\"))\n            {\n                return string.Format(query, Name, DatabaseId);\n            }\n\n            return string.Format(query, Name);\n        }\n    }\n}"]}
{"filename": "src/SQLServerCoverageLib/Trace/SqlLocalDbTraceController.cs", "chunked_list": ["\ufeffusing SQLServerCoverage.Gateway;\nusing System.IO;\n\nnamespace SQLServerCoverage.Trace\n{\n    class SqlLocalDbTraceController : SqlTraceController\n    {\n        public SqlLocalDbTraceController(DatabaseGateway gateway, string databaseName) : base(gateway, databaseName)\n        {\n        }\n", "        protected override void Create()\n        {\n            var logDir = Path.Combine(Path.GetTempPath(), nameof(SqlLocalDbTraceController));\n            if (!Directory.Exists(logDir)) { Directory.CreateDirectory(logDir); }\n\n            this.FileName = Path.Combine(logDir, Name);\n\n            RunScript(CreateTrace, \"Error creating the extended events trace, error: {0}\");\n        }\n    }\n}"]}
{"filename": "src/SQLServerCoverageLib/Trace/SqlTraceController.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.IO;\nusing SQLServerCoverage.Gateway;\n\nnamespace SQLServerCoverage.Trace\n{\n    class SqlTraceController : TraceController\n    {\n        ", "    class SqlTraceController : TraceController\n    {\n        \n        protected const string CreateTrace = @\"CREATE EVENT SESSION [{0}] ON SERVER \nADD EVENT sqlserver.sp_statement_starting(action (sqlserver.plan_handle, sqlserver.tsql_stack) where ([sqlserver].[database_id]=({1})))\nADD TARGET package0.asynchronous_file_target(\n     SET filename='{2}')\nWITH (MAX_MEMORY=100 MB,EVENT_RETENTION_MODE=NO_EVENT_LOSS,MAX_DISPATCH_LATENCY=1 SECONDS,MAX_EVENT_SIZE=0 KB,MEMORY_PARTITION_MODE=NONE,TRACK_CAUSALITY=OFF,STARTUP_STATE=OFF) \n\";\n\n        private const string StartTraceFormat = @\"alter event session [{0}] on server state = start\n\";\n", "        private const string StartTraceFormat = @\"alter event session [{0}] on server state = start\n\";\n\n        private const string StopTraceFormat = @\"alter event session [{0}] on server state = stop\n\";\n\n        private const string DropTraceFormat = @\"drop EVENT SESSION [{0}] ON SERVER \";\n\n        private const string ReadTraceFormat = @\"select\n    event_data\nFROM sys.fn_xe_file_target_read_file(N'{0}*.xel', N'{0}*.xem', null, null);\";\n", "        private const string ReadTraceFormat = @\"select\n    event_data\nFROM sys.fn_xe_file_target_read_file(N'{0}*.xel', N'{0}*.xem', null, null);\";\n\n        private const string GetLogDir = @\"EXEC xp_readerrorlog 0, 1, N'Logging SQL Server messages in file'\";\n        \n        public SqlTraceController(DatabaseGateway gateway, string databaseName) : base(gateway, databaseName)\n        {\n            \n        }\n", "        protected virtual void Create()\n        {\n            var logDir = Gateway.GetRecords(GetLogDir).Rows[0].ItemArray[2].ToString();\n            if (string.IsNullOrEmpty(logDir))\n            {\n                throw new InvalidOperationException(\"Unable to use xp_readerrorlog to find log directory to write extended event file\");\n            }\n\n            logDir = logDir.ToUpper().Replace(\"Logging SQL Server messages in file '\".ToUpper(), \"\").Replace(\"'\", \"\").Replace(\"ERRORLOG.\", \"\").Replace(\"ERROR.LOG\", \"\");\n            FileName = Path.Combine(logDir, Name);\n\n            RunScript(CreateTrace, \"Error creating the extended events trace, error: {0}\");\n        }\n", "        public override void Start()\n        {\n            Create();\n            RunScript(StartTraceFormat, \"Error starting the extended events trace, error: {0}\");\n        }\n\n        public override void Stop()\n        {\n            RunScript(StopTraceFormat, \"Error stopping the extended events trace, error: {0}\");\n        }\n", "        public override List<string> ReadTrace()\n        {\n            var data = Gateway.GetTraceRecords(string.Format(ReadTraceFormat, FileName));\n            var events = new List<string>();\n            foreach (DataRow row in data.Rows)\n            {\n                events.Add(row.ItemArray[0].ToString());\n            }\n\n\n            return events;\n        }\n", "        public override void Drop()\n        {\n            RunScript(DropTraceFormat, \"Error dropping the extended events trace, error: {0}\");\n            try\n            {\n                foreach (var file in new DirectoryInfo(new FileInfo(FileName).DirectoryName).EnumerateFiles(new FileInfo(FileName).Name + \"*.*\"))\n                {\n                    File.Delete(file.FullName);\n                }\n            }\n            catch (Exception)\n            {\n            }\n        }\n\n        \n    }\n}", "            catch (Exception)\n            {\n            }\n        }\n\n        \n    }\n}"]}
{"filename": "src/SQLServerCoverageLib/Utils/XmlTextEncoder.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nnamespace SQLServerCoverage\n{\n    /// <summary>\n    ///  Taken from http://stackoverflow.com/questions/157646/best-way-to-encode-text-data-for-xml\n    /// </summary>\n    public class XmlTextEncoder : TextReader\n    {", "    ///  Taken from http://stackoverflow.com/questions/157646/best-way-to-encode-text-data-for-xml\n    /// </summary>\n    public class XmlTextEncoder : TextReader\n    {\n        private static readonly Dictionary<char, string> Entities =\n            new Dictionary<char, string>\n            {\n                {'\"', \"&quot;\"}, {'&', \"&amp;\"}, {'\\'', \"&apos;\"},\n                {'<', \"&lt;\"}, {'>', \"&gt;\"}\n            };\n", "        private readonly Queue<char> _buf = new Queue<char>();\n        private readonly bool _filterIllegalChars;\n        private readonly TextReader _source;\n\n        /// <param name=\"source\">The data to be encoded in UTF-16 format.</param>\n        /// <param name=\"filterIllegalChars\">\n        ///     It is illegal to encode certain\n        ///     characters in XML. If true, silently omit these characters from the\n        ///     output; if false, throw an error when encountered.\n        /// </param>\n        public XmlTextEncoder(TextReader source, bool filterIllegalChars = true)\n        {\n            _source = source;\n            _filterIllegalChars = filterIllegalChars;\n        }\n\n       ", "        public static string Encode(string s)\n        {\n            using (var stream = new StringReader(s))\n            using (var encoder = new XmlTextEncoder(stream))\n            {\n                return encoder.ReadToEnd();\n            }\n        }\n\n        public override int Peek()\n        {\n            PopulateBuffer();", "        public override int Peek()\n        {\n            PopulateBuffer();\n            if (_buf.Count == 0) return -1;\n            return _buf.Peek();\n        }\n\n        public override int Read()\n        {\n            PopulateBuffer();\n            if (_buf.Count == 0) return -1;\n            return _buf.Dequeue();\n        }\n", "            if (_buf.Count == 0) return -1;\n            return _buf.Dequeue();\n        }\n\n        private void PopulateBuffer()\n        {\n            const int endSentinel = -1;\n            while (_buf.Count == 0 && _source.Peek() != endSentinel)\n            {\n                // Strings in .NET are assumed to be UTF-16 encoded [1].\n                var c = (char) _source.Read();", "                if (Entities.ContainsKey(c))\n                {\n                    // Encode all entities defined in the XML spec [2].\n                    foreach (var i in Entities[c]) _buf.Enqueue(i);\n                }\n                else if (!(0x0 <= c && c <= 0x8) &&\n                         !new[] {0xB, 0xC}.Contains(c) &&\n                         !(0xE <= c && c <= 0x1F) &&\n                         !(0x7F <= c && c <= 0x84) &&\n                         !(0x86 <= c && c <= 0x9F) &&\n                         !(0xD800 <= c && c <= 0xDFFF) &&\n                         !new[] {0xFFFE, 0xFFFF}.Contains(c))\n                {\n                    // Allow if the Unicode codepoint is legal in XML [3].\n                    _buf.Enqueue(c);\n                }", "                else if (char.IsHighSurrogate(c) &&\n                         _source.Peek() != endSentinel &&\n                         char.IsLowSurrogate((char) _source.Peek()))\n                {\n                    // Allow well-formed surrogate pairs [1].\n                    _buf.Enqueue(c);\n                    _buf.Enqueue((char) _source.Read());\n                }\n                else if (!_filterIllegalChars)\n                {\n                    // Note that we cannot encode illegal characters as entity\n                    // references due to the \"Legal Character\" constraint of\n                    // XML [4]. Nor are they allowed in CDATA sections [5].\n                    throw new ArgumentException(\n                        string.Format(\"Illegal character: '{0:X}'\", (int) c));\n                }\n            }\n        }\n\n        // [5] http://www.w3.org/TR/xml11/#sec-cdata-sect\n        // [4] http://www.w3.org/TR/xml11/#sec-references\n        // [3] http://www.w3.org/TR/xml11/#charsets\n        // [2] http://www.w3.org/TR/xml11/#sec-predefined-ent\n        // [1] http://en.wikipedia.org/wiki/UTF-16/UCS-2\n\n        // References:\n    }\n}", "                else if (!_filterIllegalChars)\n                {\n                    // Note that we cannot encode illegal characters as entity\n                    // references due to the \"Legal Character\" constraint of\n                    // XML [4]. Nor are they allowed in CDATA sections [5].\n                    throw new ArgumentException(\n                        string.Format(\"Illegal character: '{0:X}'\", (int) c));\n                }\n            }\n        }\n\n        // [5] http://www.w3.org/TR/xml11/#sec-cdata-sect\n        // [4] http://www.w3.org/TR/xml11/#sec-references\n        // [3] http://www.w3.org/TR/xml11/#charsets\n        // [2] http://www.w3.org/TR/xml11/#sec-predefined-ent\n        // [1] http://en.wikipedia.org/wiki/UTF-16/UCS-2\n\n        // References:\n    }\n}"]}
{"filename": "src/SQLServerCoverageLib/Objects/SqlServerVersion.cs", "chunked_list": ["\ufeffnamespace SQLServerCoverage.Objects\n{\n    public enum SqlServerVersion\n    {\n        Sql90,\n        Sql100,\n        Sql110,\n        Sql120,\n        Sql130,\n        Sql140,\n        Sql150\n    }\n}\n"]}
{"filename": "src/SQLServerCoverageLib/Objects/Statement.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace SQLServerCoverage.Objects\n{\n\n    public class CoverageInformation\n    {\n        public long HitCount;\n\n    }\n", "        public long HitCount;\n\n    }\n\n    public class CoverageSummary : CoverageInformation\n    {\n        public long StatementCount;\n        public long CoveredStatementCount;  \n        public long BranchesCount;\n        public long CoveredBranchesCount;\n    }\n", "        public long BranchesCount;\n        public long CoveredBranchesCount;\n    }\n\n    public class Branch : CoverageInformation\n    {\n        public Branch(string text, int offset, int length)\n        {\n            Text = text;\n            Offset = offset;\n            Length = length;\n        }\n", "        public string Text;\n        public int Offset;\n        public int Length;\n    }\n   \n    public class Statement : CoverageInformation\n    {\n        public Statement(string text, int offset, int length, bool isCoverable)\n            : this(text, offset, length, isCoverable, Array.Empty<Branch>())\n        { }\n\n        public Statement(string text, int offset, int length, bool isCoverable, IEnumerable<Branch> branches)\n        {\n            Text = text;\n            Offset = offset;\n            Length = length;\n            IsCoverable = isCoverable;\n            Branches = branches;\n\n            NormalizeStatement();\n        }\n", "        private void NormalizeStatement()\n        {\n            int chopOff = 0;\n            var index = Length-1;\n            if (index <= 0)\n                return;\n            if (Text.Length == 0)\n                return;\n\n            var c = Text[index];\n", "            while (shouldChopOff(c))\n            {\n                chopOff++;\n\n                if (index <= 0)\n                    break;\n\n                c = Text[--index];\n            }\n\n            Length = Length - chopOff;\n        }\n", "        private bool shouldChopOff(char c)\n        {\n            if (Char.IsWhiteSpace(c))\n                return true;\n\n            if (Char.IsControl(c))\n                return true;\n\n            if (c == ';')\n                return true;\n\n            return false;\n        }\n", "            if (c == ';')\n                return true;\n\n            return false;\n        }\n\n        public string Text;\n        public int Offset;\n        public int Length;\n\n        public bool IsCoverable;\n        public IEnumerable<Branch> Branches;\n    }\n}\n", "        public int Length;\n\n        public bool IsCoverable;\n        public IEnumerable<Branch> Branches;\n    }\n}\n"]}
{"filename": "src/SQLServerCoverageLib/Objects/CoveredStatement.cs", "chunked_list": ["\ufeffnamespace SQLServerCoverage.Objects\n{\n    public class CoveredStatement\n    {\n        public int Offset;\n        public int OffsetEnd;\n        public int ObjectId;\n    }\n}"]}
{"filename": "src/SQLServerCoverageLib/Objects/Batch.cs", "chunked_list": ["\ufeffusing System.Collections.Generic;\nusing SQLServerCoverage.Parsers;\n\nnamespace SQLServerCoverage.Objects\n{\n    public class Batch : CoverageSummary\n    {\n        public Batch(StatementParser parser, bool quotedIdentifier, string text, string fileName, string objectName, int objectId)\n        {\n            QuotedIdentifier = quotedIdentifier;\n            Text = text;\n            FileName = fileName;\n            ObjectName = objectName;\n            ObjectId = objectId;\n            \n            Statements = parser.GetChildStatements(text, quotedIdentifier);\n        }\n            ", "        public bool QuotedIdentifier;\n        public string Text;\n        public string FileName;\n        public string ObjectName;\n        public int ObjectId;\n\n        public readonly  List<Statement> Statements;\n    }\n}"]}
{"filename": "src/SQLServerCoverageLib/Parsers/TSqlParserBuilder.cs", "chunked_list": ["\ufeffusing System;\nusing Microsoft.SqlServer.TransactSql.ScriptDom;\nusing SQLServerCoverage.Objects;\n\nnamespace SQLServerCoverage.Parsers\n{\n    internal static class TSqlParserBuilder\n    {\n        public static TSqlParser BuildNew(SqlServerVersion version, bool quoted)\n        {\n            switch (version)\n            {\n                case SqlServerVersion.Sql90:\n                    return new TSql90Parser(quoted);\n\n                case SqlServerVersion.Sql100:\n                    return new TSql100Parser(quoted);\n\n                case SqlServerVersion.Sql110:\n                    return new TSql110Parser(quoted);\n\n                case SqlServerVersion.Sql120:\n                    return new TSql120Parser(quoted);\n\n                case SqlServerVersion.Sql130:\n                    return new TSql130Parser(quoted);\n\n                case SqlServerVersion.Sql140:\n                    return new TSql130Parser(quoted);\n\n                case SqlServerVersion.Sql150:\n                    return new TSql130Parser(quoted);\n\n                default:\n                    throw new ArgumentOutOfRangeException(nameof(version), version, null);\n            }\n        }\n    }\n}", "        public static TSqlParser BuildNew(SqlServerVersion version, bool quoted)\n        {\n            switch (version)\n            {\n                case SqlServerVersion.Sql90:\n                    return new TSql90Parser(quoted);\n\n                case SqlServerVersion.Sql100:\n                    return new TSql100Parser(quoted);\n\n                case SqlServerVersion.Sql110:\n                    return new TSql110Parser(quoted);\n\n                case SqlServerVersion.Sql120:\n                    return new TSql120Parser(quoted);\n\n                case SqlServerVersion.Sql130:\n                    return new TSql130Parser(quoted);\n\n                case SqlServerVersion.Sql140:\n                    return new TSql130Parser(quoted);\n\n                case SqlServerVersion.Sql150:\n                    return new TSql130Parser(quoted);\n\n                default:\n                    throw new ArgumentOutOfRangeException(nameof(version), version, null);\n            }\n        }\n    }\n}"]}
{"filename": "src/SQLServerCoverageLib/Parsers/StatementParser.cs", "chunked_list": ["\ufeffusing System.Collections.Generic;\nusing System.IO;\nusing System; \nusing Microsoft.SqlServer.TransactSql.ScriptDom;\nusing SQLServerCoverage.Objects;\n\nnamespace SQLServerCoverage.Parsers\n{\n    public class StatementParser\n    {\n        private readonly SqlServerVersion _version;\n\n        public StatementParser(SqlServerVersion version)\n        {\n            _version = version;\n        }\n\n        public List<Statement> GetChildStatements(string script, bool quotedIdentifier)\n        {\n            try\n            {\n                var visitor = new StatementVisitor(script);\n                var parser = TSqlParserBuilder.BuildNew(_version, quotedIdentifier);\n\n\n                IList<ParseError> errors;\n                var fragment = parser.Parse(new StringReader(script), out errors);", "    public class StatementParser\n    {\n        private readonly SqlServerVersion _version;\n\n        public StatementParser(SqlServerVersion version)\n        {\n            _version = version;\n        }\n\n        public List<Statement> GetChildStatements(string script, bool quotedIdentifier)\n        {\n            try\n            {\n                var visitor = new StatementVisitor(script);\n                var parser = TSqlParserBuilder.BuildNew(_version, quotedIdentifier);\n\n\n                IList<ParseError> errors;\n                var fragment = parser.Parse(new StringReader(script), out errors);", "                if (fragment == null)\n                {\n                    return null;\n                }\n\n                fragment.Accept(visitor);\n\n\n                return visitor.Statements;\n            }\n             catch (Exception e)\n            {\n                Console.WriteLine(e.Message); \n                Console.WriteLine(e.StackTrace);\n                return null;\n            }\n        }\n    }\n", "             catch (Exception e)\n            {\n                Console.WriteLine(e.Message); \n                Console.WriteLine(e.StackTrace);\n                return null;\n            }\n        }\n    }\n\n    public class StatementVisitor : TSqlFragmentVisitor\n    {", "    public class StatementVisitor : TSqlFragmentVisitor\n    {\n        private readonly string _script;\n        public readonly List<Statement> Statements = new List<Statement>();\n        private bool _stopEnumerating = false;\n\n        public StatementVisitor(string script)\n        {\n            _script = script;\n        }\n", "        public override void Visit(TSqlStatement statement)\n        {\n            if (_stopEnumerating)\n                return;\n\n            if (ShouldNotEnumerateChildren(statement))\n            {\n                Statements.Add(new Statement (_script.Substring(statement.StartOffset, statement.FragmentLength),  statement.StartOffset, statement.FragmentLength, false));\n                _stopEnumerating = true;       //maybe ExplicitVisit would be simpler??\n                return;\n            }\n\n            base.Visit(statement);\n", "            if (!IsIgnoredType(statement))\n            {\n                Statements.Add(new Statement (_script.Substring(statement.StartOffset, statement.FragmentLength), statement.StartOffset, statement.FragmentLength, CanBeCovered(statement)));\n            }\n\n            if (statement is IfStatement)\n            {\n                var ifStatement = (IfStatement) statement;\n                \n                var branches = new List<Branch>(2) {\n                    new Branch(\n                        _script.Substring(ifStatement.ThenStatement.StartOffset, ifStatement.ThenStatement.FragmentLength),\n                        ifStatement.ThenStatement.StartOffset,\n                        ifStatement.ThenStatement.FragmentLength\n                    )\n                };\n", "                if (ifStatement.ElseStatement != null)\n                {\n                    branches.Add(\n                        new Branch(\n                            _script.Substring(ifStatement.ElseStatement.StartOffset, ifStatement.ElseStatement.FragmentLength),\n                            ifStatement.ElseStatement.StartOffset,\n                            ifStatement.ElseStatement.FragmentLength\n                        )\n                    );\n                }\n\n\n                var offset = statement.StartOffset;\n                var length = ifStatement.Predicate.StartOffset + ifStatement.Predicate.FragmentLength - statement.StartOffset;\n                Statements.Add(new Statement(_script.Substring(offset, length), offset, length, CanBeCovered(statement), branches));\n            }\n", "            if (statement is WhileStatement)\n            {\n                var whileStatement = (WhileStatement) statement;\n               var branches = new [] {\n                    new Branch(\n                        _script.Substring(whileStatement.Statement.StartOffset, whileStatement.Statement.FragmentLength),\n                        whileStatement.Statement.StartOffset,\n                        whileStatement.Statement.FragmentLength\n                    )\n                };\n\n\n                var offset = statement.StartOffset;\n                var length = whileStatement.Predicate.StartOffset + whileStatement.Predicate.FragmentLength - statement.StartOffset;\n                Statements.Add(new Statement(_script.Substring(offset, length), offset, length, CanBeCovered(statement), branches));\n            }\n        }\n", "        private bool IsIgnoredType(TSqlStatement statement)\n        {\n            if (statement is BeginEndBlockStatement)\n                return true;\n\n            if (statement is WhileStatement)\n                return true;\n\n            if (statement is IfStatement)\n                return true;\n\n            //next todo - in extended events i think if are handled differently - do we need to search for the predicate and have that a s asepararte thinggy???\n\n            return !CanBeCovered(statement); //TODO: This all needs tidying up, don't think i need two things to do the same thing???\n        }\n\n", "            if (statement is IfStatement)\n                return true;\n\n            //next todo - in extended events i think if are handled differently - do we need to search for the predicate and have that a s asepararte thinggy???\n\n            return !CanBeCovered(statement); //TODO: This all needs tidying up, don't think i need two things to do the same thing???\n        }\n\n\n        private bool ShouldNotEnumerateChildren(TSqlStatement statement)\n        {", "        private bool ShouldNotEnumerateChildren(TSqlStatement statement)\n        {\n            if (statement is CreateViewStatement)\n                return true;\n\n            return false;\n        }\n        private bool CanBeCovered(TSqlStatement statement)\n        {\n            if (statement is BeginEndBlockStatement)\n                return false;\n", "            if (statement is BeginEndBlockStatement)\n                return false;\n\n            if (statement is TryCatchStatement)\n                return false;\n                        \n            if (statement is CreateProcedureStatement)\n                return false;\n\n            if (statement is CreateFunctionStatement)\n                return false;\n", "            if (statement is CreateFunctionStatement)\n                return false;\n\n            if (statement is CreateTriggerStatement)\n                return false;\n\n            if (statement is DeclareVariableStatement)\n                return false;\n\n            if (statement is DeclareTableVariableStatement)\n                return false;\n", "            if (statement is DeclareTableVariableStatement)\n                return false;\n\n            if (statement is LabelStatement)\n                return false;\n\n            return true;\n        }\n    }\n}"]}
{"filename": "src/SQLServerCoverageLib/Parsers/EventsParser.cs", "chunked_list": ["using System.Collections.Generic;\nusing System.Xml.Linq;\nusing System.Xml.XPath;\nusing SQLServerCoverage.Objects;\n\nnamespace SQLServerCoverage.Parsers\n{\n    public class EventsParser\n    {\n        private readonly List<string> _xmlEvents;\n        private XDocument _doc;\n", "        private readonly List<string> _xmlEvents;\n        private XDocument _doc;\n\n        private int _stringNumber;\n\n        public EventsParser(List<string> xmlEvents)\n        {\n            _xmlEvents = xmlEvents;\n            if (_xmlEvents == null || _xmlEvents.Count == 0)\n            {\n                _xmlEvents = new List<string>();\n                return;\n            }\n            \n            _doc = XDocument.Parse(xmlEvents[_stringNumber++]);\n        }\n", "            if (_xmlEvents == null || _xmlEvents.Count == 0)\n            {\n                _xmlEvents = new List<string>();\n                return;\n            }\n            \n            _doc = XDocument.Parse(xmlEvents[_stringNumber++]);\n        }\n\n        public CoveredStatement GetNextStatement()\n        {", "        public CoveredStatement GetNextStatement()\n        {\n            if (_stringNumber > _xmlEvents.Count || _xmlEvents.Count == 0)\n                return null;\n\n\n            var statement = new CoveredStatement();\n\n            statement.Offset = GetOffset();\n            statement.OffsetEnd = GetOffsetEnd();\n            statement.ObjectId = GetIntValue(\"object_id\");\n", "            if (_stringNumber < _xmlEvents.Count)\n                _doc = XDocument.Parse(_xmlEvents[_stringNumber++]);\n            else\n                _stringNumber++;\n            \n            return statement;\n        }\n\n        private int GetOffset()\n        {\n            var value = GetStringValue(\"offset\");", "        private int GetOffset()\n        {\n            var value = GetStringValue(\"offset\");\n            if (value == null)\n            {\n                value = Get2008StyleString(\"offsetStart\");\n            }\n\n            return int.Parse(value);\n        }\n", "        private int GetOffsetEnd()\n        {\n            var value = GetStringValue(\"offset_end\");\n            if (value == null)\n            {\n                value = Get2008StyleString(\"offsetEnd\");\n            }\n\n            var offset = int.Parse(value);\n            return offset;\n        }\n", "        private string Get2008StyleString(string name)\n        {\n            var node = _doc.XPathSelectElement(\"//action[@name='tsql_stack']/value\");\n            var newDocument = XDocument.Parse(string.Format(\"<Root>{0}</Root>\", node.Value));\n\n            var frame = newDocument.Element(\"Root\").FirstNode;\n\n            if (frame == null)\n            {\n                return null;\n            }\n\n            var element = frame as XElement;\n            return element.Attribute(name).Value;\n        }\n", "        private int GetIntValue(string name)\n        {\n            var value = GetStringValue(name);\n            return int.Parse(value);\n        }\n\n\n        private string GetStringValue(string name)\n        {\n            var node = _doc.XPathSelectElement(string.Format(\"//data[@name='{0}']/value\", name));\n\n            return node?.Value;\n        }\n    }\n}"]}
{"filename": "src/SQLServerCoverageLib/Serializers/OpenCoverXmlSerializer.cs", "chunked_list": ["\ufeffusing SQLServerCoverage.Objects;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.IO;\nusing System.Linq;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Xml;\nusing System.Xml.Linq;\n", "using System.Xml.Linq;\n\nnamespace SQLServerCoverage.Serializers\n{\n    public class OpenCoverXmlSerializer\n    {\n        private long uniqueId = 1;\n\n        #region \" XNames \"\n\n        private static readonly XName BranchPointElementName = XName.Get(\"BranchPoint\");", "        private static readonly XName BranchPointElementName = XName.Get(\"BranchPoint\");\n        private static readonly XName BranchPointsElementName = XName.Get(\"BranchPoints\");\n        private static readonly XName ClassesElementName = XName.Get(\"Classes\");\n        private static readonly XName ClassElementName = XName.Get(\"Class\");\n        private static readonly XName CoverageSessionElementName = XName.Get(\"CoverageSession\");\n        private static readonly XName FileRefName = XName.Get(\"FileRef\");\n        private static readonly XName FileElementName = XName.Get(\"File\");\n        private static readonly XName FilesElementName = XName.Get(\"Files\");\n        private static readonly XName FullNameElementName = XName.Get(\"FullName\");\n        private static readonly XName MetadataTokenElementName = XName.Get(\"MetadataToken\");\n        private static readonly XName MethodNameElementName = XName.Get(\"Method\");", "        private static readonly XName FullNameElementName = XName.Get(\"FullName\");\n        private static readonly XName MetadataTokenElementName = XName.Get(\"MetadataToken\");\n        private static readonly XName MethodNameElementName = XName.Get(\"Method\");\n        private static readonly XName MethodsNameElementName = XName.Get(\"Methods\");\n        private static readonly XName ModuleElementName = XName.Get(\"Module\");\n        private static readonly XName ModuleNameElementName = XName.Get(\"ModuleName\");\n        private static readonly XName ModulesElementName = XName.Get(\"Modules\");\n        private static readonly XName NameElementName = XName.Get(\"Name\");\n        private static readonly XName SequencePointName = XName.Get(\"SequencePoint\");\n        private static readonly XName SequencePointsName = XName.Get(\"SequencePoints\");\n        private static readonly XName SummaryElementName = XName.Get(\"Summary\");\n", "        private static readonly XName SequencePointName = XName.Get(\"SequencePoint\");\n        private static readonly XName SequencePointsName = XName.Get(\"SequencePoints\");\n        private static readonly XName SummaryElementName = XName.Get(\"Summary\");\n\n        private static readonly XName XmlnsXsdAttributeName = XNamespace.Xmlns + \"xsd\";\n        private static readonly XName XmlnsXsiAttributeName = XNamespace.Xmlns + \"xsi\";\n\n        private static readonly XName branchCoverageAttributeName = XName.Get(\"branchCoverage\");\n        private static readonly XName cyclomaticComplexityAttributeName = XName.Get(\"cyclomaticComplexity\");\n        private static readonly XName ecAttributeName = XName.Get(\"ec\");\n        private static readonly XName elAttributeName = XName.Get(\"el\");", "        private static readonly XName cyclomaticComplexityAttributeName = XName.Get(\"cyclomaticComplexity\");\n        private static readonly XName ecAttributeName = XName.Get(\"ec\");\n        private static readonly XName elAttributeName = XName.Get(\"el\");\n        private static readonly XName fullPathAttributeName = XName.Get(\"fullPath\");\n        private static readonly XName isConstructorAttributeName = XName.Get(\"isConstructor\");\n        private static readonly XName isGetterAttributeName = XName.Get(\"isGetter\");\n        private static readonly XName isSetterAttributeName = XName.Get(\"isSetter\");\n        private static readonly XName isStaticAttributeName = XName.Get(\"isStatic\");\n        private static readonly XName maxCyclomaticComplexityAttributeName = XName.Get(\"maxCyclomaticComplexity\");\n        private static readonly XName minCyclomaticComplexityAttributeName = XName.Get(\"minCyclomaticComplexity\");\n        private static readonly XName numBranchPointsAttributeName = XName.Get(\"numBranchPoints\");", "        private static readonly XName maxCyclomaticComplexityAttributeName = XName.Get(\"maxCyclomaticComplexity\");\n        private static readonly XName minCyclomaticComplexityAttributeName = XName.Get(\"minCyclomaticComplexity\");\n        private static readonly XName numBranchPointsAttributeName = XName.Get(\"numBranchPoints\");\n        private static readonly XName numSequencePointsAttributeName = XName.Get(\"numSequencePoints\");\n        private static readonly XName offsetAttributeName = XName.Get(\"offset\");\n        private static readonly XName offsetchainAttributeName = XName.Get(\"offsetchain\");\n        private static readonly XName offsetendAttributeName = XName.Get(\"offsetend\");\n        private static readonly XName ordinalAttributeName = XName.Get(\"ordinal\");\n        private static readonly XName pathAttributeName = XName.Get(\"path\");\n        private static readonly XName sequenceCoverageAttributeName = XName.Get(\"sequenceCoverage\");\n        private static readonly XName scAttributeName = XName.Get(\"sc\");", "        private static readonly XName pathAttributeName = XName.Get(\"path\");\n        private static readonly XName sequenceCoverageAttributeName = XName.Get(\"sequenceCoverage\");\n        private static readonly XName scAttributeName = XName.Get(\"sc\");\n        private static readonly XName slAttributeName = XName.Get(\"sl\");\n        private static readonly XName uidAttributeName = XName.Get(\"uid\");\n        private static readonly XName uspidAttributeName = XName.Get(\"uspid\");\n        private static readonly XName vcAttributeName = XName.Get(\"vc\");\n        private static readonly XName visitedAttributeName = XName.Get(\"visited\");\n        private static readonly XName visitedBranchPointsAttributeName = XName.Get(\"visitedBranchPoints\");\n        private static readonly XName visitedSequencePointsAttributeName = XName.Get(\"visitedSequencePoints\");\n\n        #endregion\n", "        private static readonly XName visitedBranchPointsAttributeName = XName.Get(\"visitedBranchPoints\");\n        private static readonly XName visitedSequencePointsAttributeName = XName.Get(\"visitedSequencePoints\");\n\n        #endregion\n\n        public string Serialize(CoverageResult result)\n        {\n            var document = new XDocument(CreateCoverageSessionElement(result));\n\n            using (var ms = new MemoryStream())\n            {\n                var xmlSettings = new XmlWriterSettings()\n                {\n                    OmitXmlDeclaration = true,\n                    Encoding = new UTF8Encoding(false),\n                    Indent = true,\n                    IndentChars = \"  \"\n                };\n", "            using (var ms = new MemoryStream())\n            {\n                var xmlSettings = new XmlWriterSettings()\n                {\n                    OmitXmlDeclaration = true,\n                    Encoding = new UTF8Encoding(false),\n                    Indent = true,\n                    IndentChars = \"  \"\n                };\n\n                using (var writer = XmlWriter.Create(ms, xmlSettings))\n                {\n                    document.WriteTo(writer);\n\n                }\n                return Encoding.UTF8.GetString(ms.ToArray());\n            }\n        }\n", "                using (var writer = XmlWriter.Create(ms, xmlSettings))\n                {\n                    document.WriteTo(writer);\n\n                }\n                return Encoding.UTF8.GetString(ms.ToArray());\n            }\n        }\n\n        private XElement CreateCoverageSessionElement(CoverageResult result)\n            => new XElement(CoverageSessionElementName,\n                new XAttribute(XmlnsXsdAttributeName, \"http://www.w3.org/2001/XMLSchema\"),\n                new XAttribute(XmlnsXsiAttributeName, \"http://www.w3.org/2001/XMLSchema-instance\"),\n                CreateSummaryElement(result),\n                CreateModulesElement(result)\n            );\n", "        private XElement CreateCoverageSessionElement(CoverageResult result)\n            => new XElement(CoverageSessionElementName,\n                new XAttribute(XmlnsXsdAttributeName, \"http://www.w3.org/2001/XMLSchema\"),\n                new XAttribute(XmlnsXsiAttributeName, \"http://www.w3.org/2001/XMLSchema-instance\"),\n                CreateSummaryElement(result),\n                CreateModulesElement(result)\n            );\n\n        private XElement CreateSummaryElement(CoverageResult result)\n            => CreateSummaryElement(\n                numSequencePoints: result.Batches.Sum(p => p.StatementCount),\n                visitedSequencePoints: result.Batches.Sum(p => p.CoveredStatementCount),\n                numBranchPoints: result.Batches.Sum(p => p.BranchesCount),\n                visitedBranchPoints: result.Batches.Sum(p => p.CoveredBranchesCount)\n            );\n", "        private XElement CreateSummaryElement(CoverageResult result)\n            => CreateSummaryElement(\n                numSequencePoints: result.Batches.Sum(p => p.StatementCount),\n                visitedSequencePoints: result.Batches.Sum(p => p.CoveredStatementCount),\n                numBranchPoints: result.Batches.Sum(p => p.BranchesCount),\n                visitedBranchPoints: result.Batches.Sum(p => p.CoveredBranchesCount)\n            );\n\n        private XElement CreateSummaryElement(Batch batch)\n            => CreateSummaryElement(\n                numSequencePoints: batch.StatementCount,\n                visitedSequencePoints: batch.CoveredStatementCount,\n                numBranchPoints: batch.BranchesCount,\n                visitedBranchPoints: batch.CoveredBranchesCount\n            );\n", "        private XElement CreateSummaryElement(Batch batch)\n            => CreateSummaryElement(\n                numSequencePoints: batch.StatementCount,\n                visitedSequencePoints: batch.CoveredStatementCount,\n                numBranchPoints: batch.BranchesCount,\n                visitedBranchPoints: batch.CoveredBranchesCount\n            );\n\n        private XElement CreateSummaryElement(\n            long numSequencePoints,\n            long visitedSequencePoints,\n            long numBranchPoints,\n            long visitedBranchPoints)\n            => new XElement(\n                SummaryElementName,\n                new XAttribute(numSequencePointsAttributeName, numSequencePoints),\n                new XAttribute(visitedSequencePointsAttributeName, visitedSequencePoints),\n                new XAttribute(numBranchPointsAttributeName, numBranchPoints),\n                new XAttribute(visitedBranchPointsAttributeName, visitedBranchPoints),\n                new XAttribute(sequenceCoverageAttributeName, numSequencePoints == 0 ? 0 : visitedSequencePoints / (double)numSequencePoints * 100.0),\n                new XAttribute(branchCoverageAttributeName, numBranchPoints == 0 ? 0 : visitedBranchPoints / (double)numBranchPoints * 100.0),\n                new XAttribute(maxCyclomaticComplexityAttributeName, \"0\"),\n                new XAttribute(minCyclomaticComplexityAttributeName, \"0\")\n            );\n", "        private XElement CreateSummaryElement(\n            long numSequencePoints,\n            long visitedSequencePoints,\n            long numBranchPoints,\n            long visitedBranchPoints)\n            => new XElement(\n                SummaryElementName,\n                new XAttribute(numSequencePointsAttributeName, numSequencePoints),\n                new XAttribute(visitedSequencePointsAttributeName, visitedSequencePoints),\n                new XAttribute(numBranchPointsAttributeName, numBranchPoints),\n                new XAttribute(visitedBranchPointsAttributeName, visitedBranchPoints),\n                new XAttribute(sequenceCoverageAttributeName, numSequencePoints == 0 ? 0 : visitedSequencePoints / (double)numSequencePoints * 100.0),\n                new XAttribute(branchCoverageAttributeName, numBranchPoints == 0 ? 0 : visitedBranchPoints / (double)numBranchPoints * 100.0),\n                new XAttribute(maxCyclomaticComplexityAttributeName, \"0\"),\n                new XAttribute(minCyclomaticComplexityAttributeName, \"0\")\n            );\n", "        private XElement CreateModulesElement(CoverageResult result)\n        {\n            var databaseName = result.DatabaseName;\n\n            var hash = string.Join(\n                \"-\",\n                SHA1.Create().ComputeHash(\n                    Encoding.UTF8.GetBytes(databaseName)\n                ).Select(x => x.ToString(\"X2\")).ToArray()\n            );\n\n            return new XElement(\n                ModulesElementName,\n                new XElement(\n                    ModuleElementName,\n                    new XAttribute(\"hash\", hash),\n                    new XElement(FullNameElementName, databaseName),\n                    new XElement(ModuleNameElementName, databaseName),\n                    CreateFilesElement(result.Batches),\n                    CreateClassesElement(result.Batches)\n                )\n            );\n        }\n", "        private XElement CreateFilesElement(IEnumerable<Batch> batches)\n            => new XElement(\n                FilesElementName,\n                batches.Select((x, i) => CreateFileElement(x.ObjectId, x.ObjectName))\n            );\n\n        private XElement CreateFileElement(int uid, string fullPath)\n            => new XElement(\n                FileElementName,\n                new XAttribute(uidAttributeName, uid),\n                new XAttribute(fullPathAttributeName, fullPath)\n            );\n", "        private XElement CreateClassesElement(IEnumerable<Batch> batches)\n            => new XElement(\n                ClassesElementName,\n                batches.Select((x, i) => CreateClassElement(x))\n            );\n\n        private XElement CreateClassElement(Batch batch)\n        {\n            return new XElement(\n                ClassElementName,\n                CreateSummaryElement(batch),\n                new XElement(FullNameElementName, batch.ObjectName),\n                CreateMethodsElement(batch)\n            );\n        }\n", "        private XElement CreateMethodsElement(Batch batch)\n            => new XElement(\n                MethodsNameElementName,\n                new XElement(\n                    MethodNameElementName,\n                    new XAttribute(visitedAttributeName, batch.CoveredStatementCount > 0),\n                    new XAttribute(cyclomaticComplexityAttributeName, \"0\"),\n                    new XAttribute(sequenceCoverageAttributeName, batch.StatementCount == 0 ? 0 : batch.CoveredStatementCount / (double)batch.StatementCount * 100.0),\n                    new XAttribute(branchCoverageAttributeName, batch.BranchesCount == 0 ? 0 : batch.CoveredBranchesCount / (double)batch.BranchesCount * 100.0),\n                    new XAttribute(isConstructorAttributeName, \"false\"),\n                    new XAttribute(isStaticAttributeName, \"false\"),\n                    new XAttribute(isGetterAttributeName, \"true\"),\n                    new XAttribute(isSetterAttributeName, \"false\"),\n                    CreateSummaryElement(batch),\n                    new XElement(MetadataTokenElementName, \"01041980\"),\n                    new XElement(NameElementName, batch.ObjectName),\n                    new XElement(\n                        FileRefName,\n                        new XAttribute(uidAttributeName, batch.ObjectId)\n                    ),\n                    CreateSequencePointsElement(batch),\n                    CreateBranchPointsElement(batch)\n                )\n            );\n", "        private XElement CreateSequencePointsElement(Batch batch)\n            => new XElement(\n                SequencePointsName,\n                batch.Statements.Select((x, i) => CreateSequencePointElement(batch, x, i + 1))\n            );\n\n        private XElement CreateSequencePointElement(Batch batch, Statement statement, int ordinal)\n        {\n            var offsets = CoverageResult.GetOffsets(statement, batch.Text);\n\n            return new XElement(\n                SequencePointName,\n                new XAttribute(vcAttributeName, statement.HitCount),\n                new XAttribute(uspidAttributeName, uniqueId++),\n                new XAttribute(ordinalAttributeName, ordinal),\n                new XAttribute(offsetAttributeName, statement.Offset),\n                new XAttribute(slAttributeName, offsets.StartLine),\n                new XAttribute(scAttributeName, offsets.StartColumn),\n                new XAttribute(elAttributeName, offsets.EndLine),\n                new XAttribute(ecAttributeName, offsets.EndColumn)\n            );\n        }\n\n", "        private XElement CreateBranchPointsElement(Batch batch)\n        {\n            var ordinal = 1;\n\n            return new XElement(\n                BranchPointsElementName,\n                batch.Statements\n                    .Where(x => x.Branches.Any())\n                    .SelectMany((statement, i) =>\n                        statement.Branches.Select((branch, j) => CreateBranchPointElement(batch, statement, branch, ordinal++, j))\n                    )\n            );\n        }\n", "        private XElement CreateBranchPointElement(Batch batch, Statement statement, Branch branch, int ordinal, int path)\n        {\n            var offsets = CoverageResult.GetOffsets(statement, batch.Text);\n            var offsetEnd = branch.Offset + branch.Length;\n\n            return new XElement(\n                BranchPointElementName,\n                new XAttribute(vcAttributeName, branch.HitCount),\n                new XAttribute(uspidAttributeName, uniqueId++),\n                new XAttribute(ordinalAttributeName, ordinal),\n                new XAttribute(offsetAttributeName, branch.Offset),\n                new XAttribute(slAttributeName, offsets.StartLine),\n                new XAttribute(pathAttributeName, path),\n                new XAttribute(offsetchainAttributeName, \"\"),\n                new XAttribute(offsetendAttributeName, branch.Offset + branch.Length)\n            );\n        }\n    }\n}\n"]}
