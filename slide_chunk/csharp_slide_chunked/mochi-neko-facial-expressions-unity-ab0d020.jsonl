{"filename": "Assets/Mochineko/FacialExpressions/LipSync/LipAnimationFrame.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace Mochineko.FacialExpressions.LipSync\n{\n    /// <summary>\n    /// A frame of lip animation.\n    /// </summary>\n    [StructLayout(LayoutKind.Sequential)]\n    public readonly struct LipAnimationFrame : IEquatable<LipAnimationFrame>\n    {\n        /// <summary>\n        /// Sample of lip morphing.\n        /// </summary>", "    /// </summary>\n    [StructLayout(LayoutKind.Sequential)]\n    public readonly struct LipAnimationFrame : IEquatable<LipAnimationFrame>\n    {\n        /// <summary>\n        /// Sample of lip morphing.\n        /// </summary>\n        public readonly LipSample sample;\n\n        /// <summary>\n        /// Duration of this frame in seconds.\n        /// </summary>", "        public readonly float durationSeconds;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"LipAnimationFrame\"/>.\n        /// </summary>\n        /// <param name=\"sample\">Sample of lip morphing.</param>\n        /// <param name=\"durationSeconds\">Duration of this frame in seconds.</param>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>\n        public LipAnimationFrame(LipSample sample, float durationSeconds)\n        {\n            if (durationSeconds < 0f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(durationSeconds), durationSeconds,\n                    \"Duration must be greater than or equal to 0.\");\n            }\n\n            this.sample = sample;\n            this.durationSeconds = durationSeconds;\n        }\n", "            if (durationSeconds < 0f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(durationSeconds), durationSeconds,\n                    \"Duration must be greater than or equal to 0.\");\n            }\n\n            this.sample = sample;\n            this.durationSeconds = durationSeconds;\n        }\n", "        public bool Equals(LipAnimationFrame other)\n        {\n            return sample.Equals(other.sample)\n                   && durationSeconds.Equals(other.durationSeconds);\n        }\n\n        public override bool Equals(object? obj)\n        {\n            return obj is LipAnimationFrame other && Equals(other);\n        }\n", "        public override int GetHashCode()\n        {\n            return HashCode.Combine(sample, durationSeconds);\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/LipSync/VolumeBasedLipAnimator.cs", "chunked_list": ["#nullable enable\nusing UnityEngine;\n\nnamespace Mochineko.FacialExpressions.LipSync\n{\n    /// <summary>\n    /// An implementation of <see cref=\"IFramewiseLipAnimator\"/> to animate lip by audio volume.\n    /// </summary>\n    public sealed class VolumeBasedLipAnimator : IFramewiseLipAnimator\n    {\n        private readonly ILipMorpher morpher;", "    public sealed class VolumeBasedLipAnimator : IFramewiseLipAnimator\n    {\n        private readonly ILipMorpher morpher;\n        private readonly Viseme viseme;\n        private readonly AudioSource audioSource;\n        private readonly float smoothTime;\n        private readonly float volumeMultiplier;\n        private readonly float[] audioSamples;\n\n        private float currentVolume = 0f;\n        private float velocity = 0f;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"VolumeBasedLipAnimator\"/>.\n        /// </summary>\n        /// <param name=\"morpher\">Target morpher.</param>\n        /// <param name=\"viseme\">Target viseme to morph.</param>\n        /// <param name=\"audioSource\">Audio source to get volume.</param>\n        /// <param name=\"smoothTime\">Smooth time of volume.</param>\n        /// <param name=\"volumeMultiplier\">Multiplier of volume.</param>\n        /// <param name=\"samplesCount\">Count of samples to get volume at each frame.</param>\n        public VolumeBasedLipAnimator(\n            ILipMorpher morpher,\n            Viseme viseme,\n            AudioSource audioSource,\n            float smoothTime = 0.1f,\n            float volumeMultiplier = 1f,\n            int samplesCount = 1024)\n        {", "        private float currentVolume = 0f;\n        private float velocity = 0f;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"VolumeBasedLipAnimator\"/>.\n        /// </summary>\n        /// <param name=\"morpher\">Target morpher.</param>\n        /// <param name=\"viseme\">Target viseme to morph.</param>\n        /// <param name=\"audioSource\">Audio source to get volume.</param>\n        /// <param name=\"smoothTime\">Smooth time of volume.</param>\n        /// <param name=\"volumeMultiplier\">Multiplier of volume.</param>\n        /// <param name=\"samplesCount\">Count of samples to get volume at each frame.</param>\n        public VolumeBasedLipAnimator(\n            ILipMorpher morpher,\n            Viseme viseme,\n            AudioSource audioSource,\n            float smoothTime = 0.1f,\n            float volumeMultiplier = 1f,\n            int samplesCount = 1024)\n        {", "            if (smoothTime <= 0f)\n            {\n                throw new System.ArgumentOutOfRangeException(\n                    nameof(smoothTime), smoothTime,\n                    \"Smooth time must be greater than 0.\");\n            }\n\n            if (volumeMultiplier <= 0f)\n            {\n                throw new System.ArgumentOutOfRangeException(\n                    nameof(volumeMultiplier), volumeMultiplier,\n                    \"Volume multiplier must be greater than 0.\");\n            }\n", "            if (samplesCount <= 0)\n            {\n                throw new System.ArgumentOutOfRangeException(\n                    nameof(samplesCount), samplesCount,\n                    \"Samples count must be greater than 0.\");\n            }\n\n            this.morpher = morpher;\n            this.viseme = viseme;\n            this.audioSource = audioSource;\n            this.smoothTime = smoothTime;\n            this.volumeMultiplier = volumeMultiplier;\n            this.audioSamples = new float[samplesCount];\n        }\n", "        public void Update()\n        {\n            morpher.MorphInto(GetSample());\n        }\n\n        public void Reset()\n        {\n            morpher.Reset();\n        }\n\n        private LipSample GetSample()\n        {\n            audioSource.GetOutputData(audioSamples, channel: 0);\n\n            var volume = CalculateVolume(audioSamples);\n\n            currentVolume = Mathf.SmoothDamp(\n                current: currentVolume,\n                target: volume,\n                currentVelocity: ref velocity,\n                smoothTime: smoothTime\n            );\n\n            return new LipSample(\n                viseme,\n                Mathf.Clamp01(currentVolume * volumeMultiplier)\n            );\n        }\n", "        private LipSample GetSample()\n        {\n            audioSource.GetOutputData(audioSamples, channel: 0);\n\n            var volume = CalculateVolume(audioSamples);\n\n            currentVolume = Mathf.SmoothDamp(\n                current: currentVolume,\n                target: volume,\n                currentVelocity: ref velocity,\n                smoothTime: smoothTime\n            );\n\n            return new LipSample(\n                viseme,\n                Mathf.Clamp01(currentVolume * volumeMultiplier)\n            );\n        }\n", "        private static float CalculateVolume(float[] samples)\n        {\n            var sum = 0f;\n            foreach (var sample in samples)\n            {\n                sum += sample * sample;\n            }\n\n            return Mathf.Sqrt(sum / samples.Length); // Root mean square\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/LipSync/IFramewiseLipAnimator.cs", "chunked_list": ["#nullable enable\nnamespace Mochineko.FacialExpressions.LipSync\n{\n    /// <summary>\n    /// Defines an animator to update lip animation per game engine frame.\n    /// </summary>\n    public interface IFramewiseLipAnimator\n    {\n        /// <summary>\n        /// Updates animation.\n        /// </summary>\n        void Update();\n\n        /// <summary>\n        /// Resets animation to default.\n        /// </summary>\n        void Reset();\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/LipSync/LoopLipAnimator.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\nnamespace Mochineko.FacialExpressions.LipSync\n{\n    /// <summary>\n    /// Loops animation of lip for any <see cref=\"ISequentialLipAnimator\"/>.", "    /// <summary>\n    /// Loops animation of lip for any <see cref=\"ISequentialLipAnimator\"/>.\n    /// </summary>\n    public sealed class LoopLipAnimator : IDisposable\n    {\n        private readonly ISequentialLipAnimator animator;\n        private readonly IEnumerable<LipAnimationFrame> frames;\n        private readonly CancellationTokenSource cancellationTokenSource = new();\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"LoopLipAnimator\"/>.\n        /// </summary>\n        /// <param name=\"animator\">Target animator.</param>\n        /// <param name=\"frames\">Target frames.</param>\n        public LoopLipAnimator(\n            ISequentialLipAnimator animator,\n            IEnumerable<LipAnimationFrame> frames)\n        {\n            this.animator = animator;\n            this.frames = frames;\n\n            LoopAnimationAsync(cancellationTokenSource.Token)\n                .Forget();\n        }\n", "        private async UniTask LoopAnimationAsync(CancellationToken cancellationToken)\n        {\n            while (!cancellationToken.IsCancellationRequested)\n            {\n                await animator.AnimateAsync(frames, cancellationToken);\n\n                await UniTask\n                    .DelayFrame(delayFrameCount: 1, cancellationToken: cancellationToken)\n                    .SuppressCancellationThrow();\n            }\n        }\n", "        public void Dispose()\n        {\n            cancellationTokenSource.Cancel();\n            cancellationTokenSource.Dispose();\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/LipSync/SkinnedMeshLipMorpher.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\nusing UnityEngine;\n\nnamespace Mochineko.FacialExpressions.LipSync\n{\n    /// <summary>\n    /// An implementation of <see cref=\"ILipMorpher\"/> to morph lip by <see cref=\"SkinnedMeshRenderer\"/>.\n    /// </summary>\n    public sealed class SkinnedMeshLipMorpher : ILipMorpher\n    {", "    /// </summary>\n    public sealed class SkinnedMeshLipMorpher : ILipMorpher\n    {\n        private readonly SkinnedMeshRenderer skinnedMeshRenderer;\n        private readonly IReadOnlyDictionary<Viseme, int> indexMap;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"SkinnedMeshLipMorpher\"/>.\n        /// </summary>\n        /// <param name=\"skinnedMeshRenderer\">Target renderer.</param>\n        /// <param name=\"indexMap\">Map of viseme to blend shape index.</param>\n        public SkinnedMeshLipMorpher(\n            SkinnedMeshRenderer skinnedMeshRenderer,\n            IReadOnlyDictionary<Viseme, int> indexMap)\n        {\n            this.skinnedMeshRenderer = skinnedMeshRenderer;\n            this.indexMap = indexMap;\n        }\n", "        public void MorphInto(LipSample sample)\n        {\n            if (indexMap.TryGetValue(sample.viseme, out var index))\n            {\n                skinnedMeshRenderer.SetBlendShapeWeight(index, sample.weight * 100f);\n            }\n            else if (sample.viseme is Viseme.sil)\n            {\n                Reset();\n            }\n        }\n", "        public float GetWeightOf(Viseme viseme)\n        {\n            if (indexMap.TryGetValue(viseme, out var index))\n            {\n                return skinnedMeshRenderer.GetBlendShapeWeight(index) / 100f;\n            }\n            else\n            {\n                return 0f;\n            }\n        }\n", "        public void Reset()\n        {\n            foreach (var pair in indexMap)\n            {\n                skinnedMeshRenderer.SetBlendShapeWeight(pair.Value, 0f);\n            }\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/LipSync/FollowingLipAnimator.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Extensions.UniTask;\nusing UnityEngine;\n\nnamespace Mochineko.FacialExpressions.LipSync\n{", "namespace Mochineko.FacialExpressions.LipSync\n{\n    /// <summary>\n    /// A framewise lip animator that animates lip by following target weights.\n    /// </summary>\n    public sealed class FollowingLipAnimator : IFramewiseLipAnimator\n    {\n        private readonly ILipMorpher morpher;\n        private readonly float dt;\n        private readonly float initialFollowingVelocity;\n        private readonly float followingTime;", "        private readonly float dt;\n        private readonly float initialFollowingVelocity;\n        private readonly float followingTime;\n        private readonly Dictionary<Viseme, float> targetWeights = new ();\n        private readonly Dictionary<Viseme, float> followingVelocities = new();\n\n        private CancellationTokenSource? animationCanceller;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"FollowingLipAnimator\"/>.\n        /// </summary>\n        /// <param name=\"morpher\">Target morpher.</param>\n        /// <param name=\"initialFollowingVelocity\">Initial velocity of smooth damp.</param>\n        /// <param name=\"followingTime\">Time of smooth damp.</param>\n        public FollowingLipAnimator(\n            ILipMorpher morpher,\n            float initialFollowingVelocity = 0.1f,\n            float followingTime = 0.005f)\n        {", "            if (initialFollowingVelocity < 0f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(initialFollowingVelocity),\n                    initialFollowingVelocity,\n                    \"Initial velocity must be greater than or equal to 0.\");\n            }\n\n            if (followingTime < 0f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(followingTime),\n                    followingTime,\n                    \"Following time must be greater than or equal to 0.\");\n            }\n\n            this.morpher = morpher;\n            this.initialFollowingVelocity = initialFollowingVelocity;\n            this.followingTime = followingTime;\n        }\n", "            if (followingTime < 0f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(followingTime),\n                    followingTime,\n                    \"Following time must be greater than or equal to 0.\");\n            }\n\n            this.morpher = morpher;\n            this.initialFollowingVelocity = initialFollowingVelocity;\n            this.followingTime = followingTime;\n        }\n", "        public async UniTask SetTargetAsync(\n            IEnumerable<LipAnimationFrame> frames,\n            CancellationToken cancellationToken)\n        {\n            animationCanceller?.Cancel();\n            animationCanceller = CancellationTokenSource\n                .CreateLinkedTokenSource(cancellationToken);\n\n            foreach (var frame in frames)\n            {\n                if (animationCanceller.IsCancellationRequested)\n                {\n                    break;\n                }\n", "            foreach (var frame in frames)\n            {\n                if (animationCanceller.IsCancellationRequested)\n                {\n                    break;\n                }\n\n                if (targetWeights.ContainsKey(frame.sample.viseme))\n                {\n                    targetWeights[frame.sample.viseme] = frame.sample.weight;\n                }\n                else\n                {\n                    targetWeights.Add(frame.sample.viseme, frame.sample.weight);\n                    followingVelocities.Add(frame.sample.viseme, initialFollowingVelocity);\n                }\n\n                var result = await RelentUniTask.Delay(\n                    TimeSpan.FromSeconds(frame.durationSeconds),\n                    cancellationToken: animationCanceller.Token);\n\n                // Cancelled", "                if (result.Failure)\n                {\n                    break;\n                }\n            }\n\n            animationCanceller?.Cancel();\n            animationCanceller = null;\n        }\n\n        public void SetTarget(LipSample sample)\n        {", "        public void SetTarget(LipSample sample)\n        {\n            if (targetWeights.ContainsKey(sample.viseme))\n            {\n                targetWeights[sample.viseme] = sample.weight;\n            }\n            else\n            {\n                targetWeights.Add(sample.viseme, sample.weight);\n                followingVelocities.Add(sample.viseme, initialFollowingVelocity);\n            }\n        }\n", "        public void Update()\n        {\n            foreach (var target in targetWeights)\n            {\n                var velocity = followingVelocities[target.Key];\n                var smoothedWeight = Mathf.Clamp01(Mathf\n                    .SmoothDamp(\n                        current: morpher.GetWeightOf(target.Key),\n                        target: target.Value,\n                        ref velocity,\n                        followingTime));\n                followingVelocities[target.Key] = velocity;\n\n                morpher.MorphInto(new LipSample(target.Key, smoothedWeight));\n            }\n        }\n", "        public void Reset()\n        {\n            morpher.Reset();\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/LipSync/LipSample.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace Mochineko.FacialExpressions.LipSync\n{\n    /// <summary>\n    /// A sample of lip morphing.\n    /// </summary>\n    [StructLayout(LayoutKind.Sequential)]\n    public readonly struct LipSample : IEquatable<LipSample>\n    {\n        /// <summary>\n        /// Viseme to morph.\n        /// </summary>", "    /// </summary>\n    [StructLayout(LayoutKind.Sequential)]\n    public readonly struct LipSample : IEquatable<LipSample>\n    {\n        /// <summary>\n        /// Viseme to morph.\n        /// </summary>\n        public readonly Viseme viseme;\n\n        /// <summary>\n        /// Weight of morphing.\n        /// </summary>", "        public readonly float weight;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"LipSample\"/>.\n        /// </summary>\n        /// <param name=\"viseme\">Viseme to morph.</param>\n        /// <param name=\"weight\">Weight of morphing.</param>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>\n        public LipSample(Viseme viseme, float weight)\n        {\n            if (weight is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(weight), weight,\n                    \"Weight must be between 0 and 1.\");\n            }\n\n            this.viseme = viseme;\n            this.weight = weight;\n        }\n", "            if (weight is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(weight), weight,\n                    \"Weight must be between 0 and 1.\");\n            }\n\n            this.viseme = viseme;\n            this.weight = weight;\n        }\n", "        public bool Equals(LipSample other)\n        {\n            return viseme == other.viseme\n                   && weight.Equals(other.weight);\n        }\n\n        public override bool Equals(object? obj)\n        {\n            return obj is LipSample other\n                   && Equals(other);\n        }\n", "        public override int GetHashCode()\n        {\n            return HashCode.Combine(\n                (int)viseme,\n                weight);\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/LipSync/AnimatorLipMorpher.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\nusing UnityEngine;\n\nnamespace Mochineko.FacialExpressions.LipSync\n{\n    /// <summary>\n    /// An implementation of <see cref=\"ILipMorpher\"/> to morph lip by <see cref=\"Animator\"/>.\n    /// </summary>\n    public sealed class AnimatorLipMorpher : ILipMorpher\n    {", "    /// </summary>\n    public sealed class AnimatorLipMorpher : ILipMorpher\n    {\n        private readonly Animator animator;\n        private readonly IReadOnlyDictionary<Viseme, int> idMap;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"AnimatorLipMorpher\"/>.\n        /// </summary>\n        /// <param name=\"animator\">Target animator.</param>\n        /// <param name=\"idMap\">Map of viseme to animator float key.</param>\n        public AnimatorLipMorpher(\n            Animator animator,\n            IReadOnlyDictionary<Viseme, int> idMap)\n        {\n            this.animator = animator;\n            this.idMap = idMap;\n        }\n", "        public void MorphInto(LipSample sample)\n        {\n            if (idMap.TryGetValue(sample.viseme, out var id))\n            {\n                animator.SetFloat(id, sample.weight);\n            }\n            else if (sample.viseme is Viseme.sil or Viseme.nn)\n            {\n                Reset();\n            }\n        }\n", "        public float GetWeightOf(Viseme viseme)\n        {\n            if (idMap.TryGetValue(viseme, out var id))\n            {\n                return animator.GetFloat(id);\n            }\n            else\n            {\n                return 0f;\n            }\n        }\n", "        public void Reset()\n        {\n            foreach (var pair in idMap)\n            {\n                animator.SetFloat(pair.Value, 0f);\n            }\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/LipSync/CompositeLipMorpher.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\n\nnamespace Mochineko.FacialExpressions.LipSync\n{\n    /// <summary>\n    /// Composition of some <see cref=\"Mochineko.FacialExpressions.LipSync.ILipMorpher\"/>s.\n    /// </summary>\n    public sealed class CompositeLipMorpher : ILipMorpher\n    {\n        private readonly IReadOnlyList<ILipMorpher> morphers;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"Mochineko.FacialExpressions.LipSync.CompositeLipMorpher\"/>.\n        /// </summary>\n        /// <param name=\"morphers\">Composited morphers.</param>\n        public CompositeLipMorpher(IReadOnlyList<ILipMorpher> morphers)\n        {\n            this.morphers = morphers;\n        }\n\n        void ILipMorpher.MorphInto(LipSample sample)\n        {", "    public sealed class CompositeLipMorpher : ILipMorpher\n    {\n        private readonly IReadOnlyList<ILipMorpher> morphers;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"Mochineko.FacialExpressions.LipSync.CompositeLipMorpher\"/>.\n        /// </summary>\n        /// <param name=\"morphers\">Composited morphers.</param>\n        public CompositeLipMorpher(IReadOnlyList<ILipMorpher> morphers)\n        {\n            this.morphers = morphers;\n        }\n\n        void ILipMorpher.MorphInto(LipSample sample)\n        {", "            foreach (var morpher in morphers)\n            {\n                morpher.MorphInto(sample);\n            }\n        }\n\n        float ILipMorpher.GetWeightOf(Viseme viseme)\n        {\n            return morphers[0].GetWeightOf(viseme);\n        }\n\n        void ILipMorpher.Reset()\n        {", "            foreach (var morpher in morphers)\n            {\n                morpher.Reset();\n            }\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/LipSync/CompletionFunction.cs", "chunked_list": ["#nullable enable\nusing System;\n\nnamespace Mochineko.FacialExpressions.LipSync\n{\n    /// <summary>\n    /// Provides completion functions.\n    /// </summary>\n    public static class CompletionFunction\n    {\n        /// <summary>\n        /// Cubic function from 0 to 1 with easing.\n        /// </summary>\n        /// <param name=\"phase\"></param>\n        /// <returns></returns>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>", "    public static class CompletionFunction\n    {\n        /// <summary>\n        /// Cubic function from 0 to 1 with easing.\n        /// </summary>\n        /// <param name=\"phase\"></param>\n        /// <returns></returns>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>\n        public static float Cubic(float phase)\n        {\n            if (phase is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(phase), phase,\n                    \"Phase must be between 0 and 1.\");\n            }\n\n            return 3f * phase * phase - 2f * phase * phase * phase;\n        }\n    }\n}\n", "        public static float Cubic(float phase)\n        {\n            if (phase is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(phase), phase,\n                    \"Phase must be between 0 and 1.\");\n            }\n\n            return 3f * phase * phase - 2f * phase * phase * phase;\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/LipSync/Viseme.cs", "chunked_list": ["#nullable enable\n\nnamespace Mochineko.FacialExpressions.LipSync\n{\n    /// <summary>\n    /// Any of a group of speech sounds that look the same\n    ///  defined by https://visagetechnologies.com/uploads/2012/08/MPEG-4FBAOverview.pdf\n    /// </summary>\n    // ReSharper disable InconsistentNaming\n    public enum Viseme : byte\n    {\n        sil = 0,\n        PP = 1,\n        FF = 2,\n        TH = 3,\n        DD = 4,\n        kk = 5,\n        CH = 6,\n        SS = 7,\n        nn = 8,\n        RR = 9,\n        aa = 10,\n        E = 11,\n        ih = 12,\n        oh = 13,\n        ou = 14,\n    }\n}", "    // ReSharper disable InconsistentNaming\n    public enum Viseme : byte\n    {\n        sil = 0,\n        PP = 1,\n        FF = 2,\n        TH = 3,\n        DD = 4,\n        kk = 5,\n        CH = 6,\n        SS = 7,\n        nn = 8,\n        RR = 9,\n        aa = 10,\n        E = 11,\n        ih = 12,\n        oh = 13,\n        ou = 14,\n    }\n}"]}
{"filename": "Assets/Mochineko/FacialExpressions/LipSync/SequentialLipAnimator.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Extensions.UniTask;\n\nnamespace Mochineko.FacialExpressions.LipSync\n{\n    /// <summary>", "{\n    /// <summary>\n    /// A sequential lip animator.\n    /// </summary>\n    public sealed class SequentialLipAnimator : ISequentialLipAnimator\n    {\n        private readonly ILipMorpher morpher;\n\n        private CancellationTokenSource? animationCanceller;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"SequentialLipAnimator\"/>.\n        /// </summary>\n        /// <param name=\"morpher\">Target morpher.</param>\n        public SequentialLipAnimator(ILipMorpher morpher)\n        {\n            this.morpher = morpher;\n        }\n", "        public async UniTask AnimateAsync(\n            IEnumerable<LipAnimationFrame> frames,\n            CancellationToken cancellationToken)\n        {\n            animationCanceller?.Cancel();\n            animationCanceller = CancellationTokenSource\n                .CreateLinkedTokenSource(cancellationToken);\n\n            morpher.Reset();\n\n            foreach (var frame in frames)\n            {", "            foreach (var frame in frames)\n            {\n                if (animationCanceller.IsCancellationRequested)\n                {\n                    break;\n                }\n\n                morpher.MorphInto(frame.sample);\n\n                var result = await RelentUniTask.Delay(\n                    TimeSpan.FromSeconds(frame.durationSeconds),\n                    cancellationToken: animationCanceller.Token);\n\n                // Cancelled", "                if (result.Failure)\n                {\n                    break;\n                }\n            }\n\n            morpher.Reset();\n\n            animationCanceller = null;\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/LipSync/ISequentialLipAnimator.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\nnamespace Mochineko.FacialExpressions.LipSync\n{\n    /// <summary>\n    /// Defines an animator to animate lip sequentially by frame collection.\n    /// </summary>\n    public interface ISequentialLipAnimator\n    {\n        /// <summary>\n        /// Animates lip sequentially by a collection of <see cref=\"LipAnimationFrame\"/>.\n        /// </summary>\n        /// <param name=\"frames\">Target frames.</param>\n        /// <param name=\"cancellationToken\">Cancellation token.</param>\n        /// <returns></returns>\n        UniTask AnimateAsync(\n            IEnumerable<LipAnimationFrame> frames,\n            CancellationToken cancellationToken);\n    }\n}\n", "    /// Defines an animator to animate lip sequentially by frame collection.\n    /// </summary>\n    public interface ISequentialLipAnimator\n    {\n        /// <summary>\n        /// Animates lip sequentially by a collection of <see cref=\"LipAnimationFrame\"/>.\n        /// </summary>\n        /// <param name=\"frames\">Target frames.</param>\n        /// <param name=\"cancellationToken\">Cancellation token.</param>\n        /// <returns></returns>\n        UniTask AnimateAsync(\n            IEnumerable<LipAnimationFrame> frames,\n            CancellationToken cancellationToken);\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/LipSync/ILipMorpher.cs", "chunked_list": ["#nullable enable\n\nnamespace Mochineko.FacialExpressions.LipSync\n{\n    /// <summary>\n    /// Defines a morpher to change lip shape.\n    /// </summary>\n    public interface ILipMorpher\n    {\n        /// <summary>\n        /// Morphs lip by specified viseme into specified weight.\n        /// </summary>\n        /// <param name=\"sample\">Target lip sample.</param>\n        void MorphInto(LipSample sample);\n        \n        /// <summary>\n        /// Gets current weight of specified viseme.\n        /// </summary>\n        /// <param name=\"viseme\">Target viseme.</param>\n        /// <returns></returns>\n        float GetWeightOf(Viseme viseme);\n        \n        /// <summary>\n        /// Resets all morphing to default.\n        /// </summary>\n        void Reset();\n    }\n}"]}
{"filename": "Assets/Mochineko/FacialExpressions/Emotion/EmotionAnimationFrame.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace Mochineko.FacialExpressions.Emotion\n{\n    /// <summary>\n    /// Frame of emotion animation.\n    /// </summary>\n    [StructLayout(LayoutKind.Sequential)]\n    public readonly struct EmotionAnimationFrame<TEmotion>\n        : IEquatable<EmotionAnimationFrame<TEmotion>>\n        where TEmotion : Enum\n    {\n        /// <summary>\n        /// Sample of emotion morphing.\n        /// </summary>", "    /// </summary>\n    [StructLayout(LayoutKind.Sequential)]\n    public readonly struct EmotionAnimationFrame<TEmotion>\n        : IEquatable<EmotionAnimationFrame<TEmotion>>\n        where TEmotion : Enum\n    {\n        /// <summary>\n        /// Sample of emotion morphing.\n        /// </summary>\n        public readonly EmotionSample<TEmotion> sample;\n\n        /// <summary>\n        /// Duration of this frame in seconds.\n        /// </summary>", "        public readonly EmotionSample<TEmotion> sample;\n\n        /// <summary>\n        /// Duration of this frame in seconds.\n        /// </summary>\n        public readonly float durationSeconds;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"EmotionAnimationFrame{TEmotion}\"/>.\n        /// </summary>\n        /// <param name=\"sample\">Sample of emotion morphing.</param>\n        /// <param name=\"durationSeconds\">Duration of this frame in seconds.</param>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>\n        public EmotionAnimationFrame(EmotionSample<TEmotion> sample, float durationSeconds)\n        {", "            if (durationSeconds < 0f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(durationSeconds), durationSeconds,\n                    \"Duration must be greater than or equal to 0.\");\n            }\n\n            this.sample = sample;\n            this.durationSeconds = durationSeconds;\n        }\n", "        public bool Equals(EmotionAnimationFrame<TEmotion> other)\n        {\n            return sample.Equals(other.sample)\n                   && durationSeconds.Equals(other.durationSeconds);\n        }\n\n        public override bool Equals(object? obj)\n        {\n            return obj is EmotionAnimationFrame<TEmotion> other && Equals(other);\n        }\n", "        public override int GetHashCode()\n        {\n            return HashCode.Combine(sample, durationSeconds);\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Emotion/SkinnedMeshEmotionMorpher.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine;\n\nnamespace Mochineko.FacialExpressions.Emotion\n{\n    /// <summary>\n    /// A simple implementation of <see cref=\"IEmotionMorpher{TEmotion}\"/> for <see cref=\"SkinnedMeshRenderer\"/>.\n    /// </summary>", "    /// A simple implementation of <see cref=\"IEmotionMorpher{TEmotion}\"/> for <see cref=\"SkinnedMeshRenderer\"/>.\n    /// </summary>\n    /// <typeparam name=\"TEmotion\"></typeparam>\n    public sealed class SkinnedMeshEmotionMorpher<TEmotion>\n        : IEmotionMorpher<TEmotion>\n        where TEmotion : Enum\n    {\n        private readonly SkinnedMeshRenderer skinnedMeshRenderer;\n        private readonly IReadOnlyDictionary<TEmotion, int> indexMap;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"SkinnedMeshEmotionMorpher{TEmotion}\"/>.\n        /// </summary>\n        /// <param name=\"skinnedMeshRenderer\">Target renderer.</param>\n        /// <param name=\"indexMap\">Map of viseme to blend shape index.</param>\n        public SkinnedMeshEmotionMorpher(\n            SkinnedMeshRenderer skinnedMeshRenderer,\n            IReadOnlyDictionary<TEmotion, int> indexMap)\n        {\n            this.skinnedMeshRenderer = skinnedMeshRenderer;\n            this.indexMap = indexMap;\n        }\n", "        private readonly IReadOnlyDictionary<TEmotion, int> indexMap;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"SkinnedMeshEmotionMorpher{TEmotion}\"/>.\n        /// </summary>\n        /// <param name=\"skinnedMeshRenderer\">Target renderer.</param>\n        /// <param name=\"indexMap\">Map of viseme to blend shape index.</param>\n        public SkinnedMeshEmotionMorpher(\n            SkinnedMeshRenderer skinnedMeshRenderer,\n            IReadOnlyDictionary<TEmotion, int> indexMap)\n        {\n            this.skinnedMeshRenderer = skinnedMeshRenderer;\n            this.indexMap = indexMap;\n        }\n", "        public void MorphInto(EmotionSample<TEmotion> sample)\n        {\n            if (indexMap.TryGetValue(sample.emotion, out var index))\n            {\n                skinnedMeshRenderer.SetBlendShapeWeight(index, sample.weight * 100f);\n            }\n        }\n\n        public float GetWeightOf(TEmotion emotion)\n        {\n            if (indexMap.TryGetValue(emotion, out var index))\n            {\n                return skinnedMeshRenderer.GetBlendShapeWeight(index) / 100f;\n            }\n            else\n            {\n                return 0f;\n            }\n        }\n", "        public float GetWeightOf(TEmotion emotion)\n        {\n            if (indexMap.TryGetValue(emotion, out var index))\n            {\n                return skinnedMeshRenderer.GetBlendShapeWeight(index) / 100f;\n            }\n            else\n            {\n                return 0f;\n            }\n        }\n", "        public void Reset()\n        {\n            foreach (var index in indexMap.Values)\n            {\n                skinnedMeshRenderer.SetBlendShapeWeight(index, 0f);\n            }\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Emotion/EmotionSample.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\n\nnamespace Mochineko.FacialExpressions.Emotion\n{\n    /// <summary>\n    /// Sample of emotion morphing.\n    /// </summary>", "    /// Sample of emotion morphing.\n    /// </summary>\n    [StructLayout(LayoutKind.Sequential)]\n    public readonly struct EmotionSample<TEmotion>\n        : IEquatable<EmotionSample<TEmotion>>\n        where TEmotion : Enum\n    {\n        /// <summary>\n        /// Target emotion.\n        /// </summary>\n        public readonly TEmotion emotion;\n\n        /// <summary>\n        /// Weight of morphing.\n        /// </summary>", "        public readonly TEmotion emotion;\n\n        /// <summary>\n        /// Weight of morphing.\n        /// </summary>\n        public readonly float weight;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"EmotionSample{TEmotion}\"/>.\n        /// </summary>\n        /// <param name=\"emotion\">Target emotion.</param>\n        /// <param name=\"weight\">Weight of morphing.</param>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>\n        public EmotionSample(TEmotion emotion, float weight)\n        {", "            if (weight is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(weight), weight,\n                    \"Weight must be between 0 and 1.\");\n            }\n\n            this.emotion = emotion;\n            this.weight = weight;\n        }\n", "        public bool Equals(EmotionSample<TEmotion> other)\n        {\n            return EqualityComparer<TEmotion>.Default.Equals(emotion, other.emotion)\n                   && weight.Equals(other.weight);\n        }\n\n        public override bool Equals(object? obj)\n        {\n            return obj is EmotionSample<TEmotion> other && Equals(other);\n        }\n", "        public override int GetHashCode()\n        {\n            return HashCode.Combine(emotion, weight);\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Emotion/BasicEmotion.cs", "chunked_list": ["#nullable enable\nnamespace Mochineko.FacialExpressions.Emotion\n{\n    /// <summary>\n    /// Basic emotions defined by Paul Ekman.\n    /// </summary>\n    public enum BasicEmotion\n    {\n        /// <summary>\n        /// Neutral emotion.\n        /// </summary>\n        Neutral,\n        /// <summary>\n        /// Happy emotion.\n        /// </summary>\n        Happy,\n        /// <summary>\n        /// Sad emotion.\n        /// </summary>\n        Sad,\n        /// <summary>\n        /// Angry emotion.\n        /// </summary>\n        Angry,\n        /// <summary>\n        /// Fearful emotion.\n        /// </summary>\n        Fearful,\n        /// <summary>\n        /// Surprised emotion.\n        /// </summary>\n        Surprised,\n        /// <summary>\n        /// Disgusted emotion.\n        /// </summary>\n        Disgusted,\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Emotion/ISequentialEmotionAnimator.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\nnamespace Mochineko.FacialExpressions.Emotion\n{\n    /// <summary>\n    /// Defines an animator to animate emotion sequentially by frame collection.", "    /// <summary>\n    /// Defines an animator to animate emotion sequentially by frame collection.\n    /// </summary>\n    /// <typeparam name=\"TEmotion\"></typeparam>\n    public interface ISequentialEmotionAnimator<TEmotion>\n        where TEmotion : Enum\n    {\n        /// <summary>\n        /// Animates emotion sequentially by a collection of <see cref=\"EmotionAnimationFrame{TEmotion}\"/>.\n        /// </summary>\n        /// <param name=\"frames\">Target frames.</param>\n        /// <param name=\"cancellationToken\">Cancellation token.</param>\n        /// <returns></returns>\n        UniTask AnimateAsync(\n            IEnumerable<EmotionAnimationFrame<TEmotion>> frames,\n            CancellationToken cancellationToken);\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Emotion/IFramewiseEmotionAnimator.cs", "chunked_list": ["#nullable enable\nusing System;\n\nnamespace Mochineko.FacialExpressions.Emotion\n{\n    /// <summary>\n    /// Defines an animator of emotion per game engine frame.\n    /// </summary>\n    /// <typeparam name=\"TEmotion\"></typeparam>\n    public interface IFramewiseEmotionAnimator<TEmotion>\n        where TEmotion : Enum\n    {\n        /// <summary>\n        /// Updates animation.\n        /// </summary>\n        void Update();\n\n        /// <summary>\n        /// Resets all morphing to default.\n        /// </summary>\n        void Reset();\n    }\n}\n", "    /// <typeparam name=\"TEmotion\"></typeparam>\n    public interface IFramewiseEmotionAnimator<TEmotion>\n        where TEmotion : Enum\n    {\n        /// <summary>\n        /// Updates animation.\n        /// </summary>\n        void Update();\n\n        /// <summary>\n        /// Resets all morphing to default.\n        /// </summary>\n        void Reset();\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Emotion/LoopEmotionAnimator.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\nnamespace Mochineko.FacialExpressions.Emotion\n{\n    /// <summary>\n    /// Loops animation of eyelid for any <see cref=\"ISequentialEmotionAnimator{TEmotion}\"/>.", "    /// <summary>\n    /// Loops animation of eyelid for any <see cref=\"ISequentialEmotionAnimator{TEmotion}\"/>.\n    /// </summary>\n    public sealed class LoopEmotionAnimator<TEmotion>\n        : IDisposable\n        where TEmotion : Enum\n    {\n        private readonly ISequentialEmotionAnimator<TEmotion> animator;\n        private readonly IEnumerable<EmotionAnimationFrame<TEmotion>> frames;\n        private readonly CancellationTokenSource cancellationTokenSource = new();\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"LoopEmotionAnimator\"/>.\n        /// </summary>\n        /// <param name=\"animator\">Target animator.</param>\n        /// <param name=\"frames\">Target frames.</param>\n        public LoopEmotionAnimator(\n            ISequentialEmotionAnimator<TEmotion> animator,\n            IEnumerable<EmotionAnimationFrame<TEmotion>> frames)\n        {\n            this.animator = animator;\n            this.frames = frames;\n\n            LoopAnimationAsync(cancellationTokenSource.Token)\n                .Forget();\n        }\n", "        private readonly IEnumerable<EmotionAnimationFrame<TEmotion>> frames;\n        private readonly CancellationTokenSource cancellationTokenSource = new();\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"LoopEmotionAnimator\"/>.\n        /// </summary>\n        /// <param name=\"animator\">Target animator.</param>\n        /// <param name=\"frames\">Target frames.</param>\n        public LoopEmotionAnimator(\n            ISequentialEmotionAnimator<TEmotion> animator,\n            IEnumerable<EmotionAnimationFrame<TEmotion>> frames)\n        {\n            this.animator = animator;\n            this.frames = frames;\n\n            LoopAnimationAsync(cancellationTokenSource.Token)\n                .Forget();\n        }\n", "        private async UniTask LoopAnimationAsync(CancellationToken cancellationToken)\n        {\n            while (!cancellationToken.IsCancellationRequested)\n            {\n                await animator.AnimateAsync(frames, cancellationToken);\n\n                await UniTask\n                    .DelayFrame(delayFrameCount: 1, cancellationToken: cancellationToken)\n                    .SuppressCancellationThrow();\n            }\n        }\n", "        public void Dispose()\n        {\n            cancellationTokenSource.Cancel();\n            cancellationTokenSource.Dispose();\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Emotion/IEmotionMorpher.cs", "chunked_list": ["#nullable enable\nusing System;\n\nnamespace Mochineko.FacialExpressions.Emotion\n{\n    /// <summary>\n    /// Defines a morpher of emotion to change shapes for each emotion.\n    /// </summary>\n    public interface IEmotionMorpher<TEmotion>\n        where TEmotion : Enum\n    {\n        /// <summary>\n        /// Morphs specified emotion into specified weight.\n        /// </summary>\n        /// <param name=\"sample\">Target emotion sample.</param>\n        void MorphInto(EmotionSample<TEmotion> sample);\n\n        /// <summary>\n        /// Gets current weight of specified emotion.\n        /// </summary>\n        /// <param name=\"emotion\">Target emotion.</param>\n        /// <returns></returns>\n        float GetWeightOf(TEmotion emotion);\n\n        /// <summary>\n        /// Resets all morphing to default.\n        /// </summary>\n        void Reset();\n    }\n}\n", "    public interface IEmotionMorpher<TEmotion>\n        where TEmotion : Enum\n    {\n        /// <summary>\n        /// Morphs specified emotion into specified weight.\n        /// </summary>\n        /// <param name=\"sample\">Target emotion sample.</param>\n        void MorphInto(EmotionSample<TEmotion> sample);\n\n        /// <summary>\n        /// Gets current weight of specified emotion.\n        /// </summary>\n        /// <param name=\"emotion\">Target emotion.</param>\n        /// <returns></returns>\n        float GetWeightOf(TEmotion emotion);\n\n        /// <summary>\n        /// Resets all morphing to default.\n        /// </summary>\n        void Reset();\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Emotion/ExclusiveFollowingEmotionAnimator.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine;\n\nnamespace Mochineko.FacialExpressions.Emotion\n{\n    /// <summary>\n    /// An emotion animator that animates emotion by following target weights exclusively.\n    /// </summary>\n    public sealed class ExclusiveFollowingEmotionAnimator<TEmotion>\n        : IFramewiseEmotionAnimator<TEmotion>\n        where TEmotion : Enum\n    {", "    /// An emotion animator that animates emotion by following target weights exclusively.\n    /// </summary>\n    public sealed class ExclusiveFollowingEmotionAnimator<TEmotion>\n        : IFramewiseEmotionAnimator<TEmotion>\n        where TEmotion : Enum\n    {\n        private readonly IEmotionMorpher<TEmotion> morpher;\n        private readonly float followingTime;\n        private readonly Dictionary<TEmotion, EmotionSample<TEmotion>> targets = new();\n        private readonly Dictionary<TEmotion, float> velocities = new();\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"ExclusiveFollowingEmotionAnimator{TEmotion}\"/>.\n        /// </summary>\n        /// <param name=\"morpher\">Target morpher.</param>\n        /// <param name=\"followingTime\">Following time to smooth dump.</param>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>\n        public ExclusiveFollowingEmotionAnimator(\n            IEmotionMorpher<TEmotion> morpher,\n            float followingTime)\n        {", "        private readonly Dictionary<TEmotion, EmotionSample<TEmotion>> targets = new();\n        private readonly Dictionary<TEmotion, float> velocities = new();\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"ExclusiveFollowingEmotionAnimator{TEmotion}\"/>.\n        /// </summary>\n        /// <param name=\"morpher\">Target morpher.</param>\n        /// <param name=\"followingTime\">Following time to smooth dump.</param>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>\n        public ExclusiveFollowingEmotionAnimator(\n            IEmotionMorpher<TEmotion> morpher,\n            float followingTime)\n        {", "            if (followingTime <= 0f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(followingTime), followingTime,\n                    \"Following time must be greater than 0.\");\n            }\n\n            this.morpher = morpher;\n            this.followingTime = followingTime;\n            this.morpher.Reset();\n        }\n\n        /// <summary>\n        /// Emotes.\n        /// </summary>\n        /// <param name=\"sample\"></param>", "        public void Emote(EmotionSample<TEmotion> sample)\n        {\n            if (targets.ContainsKey(sample.emotion))\n            {\n                targets[sample.emotion] = sample;\n                velocities[sample.emotion] = 0f;\n            }\n            else\n            {\n                targets.Add(sample.emotion, sample);\n                velocities.Add(sample.emotion, 0f);\n            }\n\n            // Exclude other emotions\n            var otherEmotions = new List<TEmotion>();", "            foreach (var emotion in targets.Keys)\n            {\n                if (!emotion.Equals(sample.emotion))\n                {\n                    otherEmotions.Add(emotion);\n                }\n            }\n\n            foreach (var other in otherEmotions)\n            {\n                targets[other] = new EmotionSample<TEmotion>(other, weight: 0f);\n            }\n        }\n", "            foreach (var other in otherEmotions)\n            {\n                targets[other] = new EmotionSample<TEmotion>(other, weight: 0f);\n            }\n        }\n\n        public void Update()\n        {\n            foreach (var target in targets)\n            {\n                var velocity = velocities[target.Key];\n                var smoothedWeight = Mathf.Clamp(\n                    value: Mathf.SmoothDamp(\n                        current: morpher.GetWeightOf(target.Key),\n                        target: target.Value.weight,\n                        ref velocity,\n                        followingTime),\n                    min: 0f,\n                    max: target.Value.weight);\n                velocities[target.Key] = velocity;\n\n                morpher.MorphInto(new EmotionSample<TEmotion>(target.Key, smoothedWeight));\n            }\n        }\n", "            foreach (var target in targets)\n            {\n                var velocity = velocities[target.Key];\n                var smoothedWeight = Mathf.Clamp(\n                    value: Mathf.SmoothDamp(\n                        current: morpher.GetWeightOf(target.Key),\n                        target: target.Value.weight,\n                        ref velocity,\n                        followingTime),\n                    min: 0f,\n                    max: target.Value.weight);\n                velocities[target.Key] = velocity;\n\n                morpher.MorphInto(new EmotionSample<TEmotion>(target.Key, smoothedWeight));\n            }\n        }\n", "        public void Reset()\n        {\n            morpher.Reset();\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Emotion/CompositeEmotionMorpher.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\n\nnamespace Mochineko.FacialExpressions.Emotion\n{\n    /// <summary>\n    /// Composition of some <see cref=\"Mochineko.FacialExpressions.Emotion.IEmotionMorpher{TEmotion}\"/>s.\n    /// </summary>\n    /// <typeparam name=\"TEmotion\"></typeparam>\n    public sealed class CompositeEmotionMorpher<TEmotion>\n        : IEmotionMorpher<TEmotion>\n        where TEmotion : Enum\n    {", "    /// </summary>\n    /// <typeparam name=\"TEmotion\"></typeparam>\n    public sealed class CompositeEmotionMorpher<TEmotion>\n        : IEmotionMorpher<TEmotion>\n        where TEmotion : Enum\n    {\n        private readonly IReadOnlyList<IEmotionMorpher<TEmotion>> morphers;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"Mochineko.FacialExpressions.Emotion.CompositeEmotionMorpher{TEmotion}\"/>.\n        /// </summary>\n        /// <param name=\"morphers\">Composited morphers.</param>\n        public CompositeEmotionMorpher(IReadOnlyList<IEmotionMorpher<TEmotion>> morphers)\n        {\n            this.morphers = morphers;\n        }\n\n        void IEmotionMorpher<TEmotion>.MorphInto(EmotionSample<TEmotion> sample)\n        {", "            foreach (var morpher in morphers)\n            {\n                morpher.MorphInto(sample);\n            }\n        }\n\n        float IEmotionMorpher<TEmotion>.GetWeightOf(TEmotion emotion)\n        {\n            return morphers[0].GetWeightOf(emotion);\n        }\n\n        void IEmotionMorpher<TEmotion>.Reset()\n        {", "            foreach (var morpher in morphers)\n            {\n                morpher.Reset();\n            }\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Emotion/AnimatorEmotionMorpher.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine;\n\nnamespace Mochineko.FacialExpressions.Emotion\n{\n    /// <summary>\n    /// A simple implementation of <see cref=\"IEmotionMorpher{TEmotion}\"/> for <see cref=\"Animator\"/>.\n    /// </summary>\n    public sealed class AnimatorEmotionMorpher<TEmotion>\n        : IEmotionMorpher<TEmotion>\n        where TEmotion : Enum\n    {", "    /// A simple implementation of <see cref=\"IEmotionMorpher{TEmotion}\"/> for <see cref=\"Animator\"/>.\n    /// </summary>\n    public sealed class AnimatorEmotionMorpher<TEmotion>\n        : IEmotionMorpher<TEmotion>\n        where TEmotion : Enum\n    {\n        private readonly Animator animator;\n        private readonly IReadOnlyDictionary<TEmotion, int> idMap;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"AnimatorEmotionMorpher{TEmotion}\"/>.\n        /// </summary>\n        /// <param name=\"animator\">Target animator.</param>\n        /// <param name=\"idMap\">Map of eyelid to animator float key.</param>\n        public AnimatorEmotionMorpher(\n            Animator animator,\n            IReadOnlyDictionary<TEmotion, int> idMap)\n        {\n            this.animator = animator;\n            this.idMap = idMap;\n        }\n", "        public void MorphInto(EmotionSample<TEmotion> sample)\n        {\n            if (idMap.TryGetValue(sample.emotion, out var id))\n            {\n                animator.SetFloat(id, sample.weight);\n            }\n        }\n\n        public float GetWeightOf(TEmotion emotion)\n        {\n            if (idMap.TryGetValue(emotion, out var id))\n            {\n                return animator.GetFloat(id);\n            }\n            else\n            {\n                return 0f;\n            }\n        }\n", "        public float GetWeightOf(TEmotion emotion)\n        {\n            if (idMap.TryGetValue(emotion, out var id))\n            {\n                return animator.GetFloat(id);\n            }\n            else\n            {\n                return 0f;\n            }\n        }\n", "        public void Reset()\n        {\n            foreach (var id in idMap.Values)\n            {\n                animator.SetFloat(id, 0f);\n            }\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Blink/EyelidAnimationFrame.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace Mochineko.FacialExpressions.Blink\n{\n    /// <summary>\n    /// A frame of eyelid animation.\n    /// </summary>\n    [StructLayout(LayoutKind.Sequential)]\n    public readonly struct EyelidAnimationFrame : IEquatable<EyelidAnimationFrame>\n    {\n        /// <summary>\n        /// Sample of eyelid morphing at frame.\n        /// </summary>", "    /// </summary>\n    [StructLayout(LayoutKind.Sequential)]\n    public readonly struct EyelidAnimationFrame : IEquatable<EyelidAnimationFrame>\n    {\n        /// <summary>\n        /// Sample of eyelid morphing at frame.\n        /// </summary>\n        public readonly EyelidSample sample;\n        /// <summary>\n        /// Duration time of frame in seconds.\n        /// </summary>", "        public readonly float durationSeconds;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"EyelidAnimationFrame\"/>.\n        /// </summary>\n        /// <param name=\"sample\">Sample of eyelid morphing at frame.</param>\n        /// <param name=\"durationSeconds\">Duration time of frame in seconds.</param>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>\n        public EyelidAnimationFrame(EyelidSample sample, float durationSeconds)\n        {\n            if (durationSeconds < 0f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(durationSeconds), durationSeconds,\n                    \"Duration time must be greater than or equal to 0.\");\n            }\n\n            this.sample = sample;\n            this.durationSeconds = durationSeconds;\n        }\n", "            if (durationSeconds < 0f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(durationSeconds), durationSeconds,\n                    \"Duration time must be greater than or equal to 0.\");\n            }\n\n            this.sample = sample;\n            this.durationSeconds = durationSeconds;\n        }\n", "        public bool Equals(EyelidAnimationFrame other)\n        {\n            return sample.Equals(other.sample)\n                   && durationSeconds.Equals(other.durationSeconds);\n        }\n\n        public override bool Equals(object? obj)\n        {\n            return obj is EyelidAnimationFrame other && Equals(other);\n        }\n", "        public override int GetHashCode()\n        {\n            return HashCode.Combine(sample, durationSeconds);\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Blink/IFramewiseEyelidAnimator.cs", "chunked_list": ["#nullable enable\nnamespace Mochineko.FacialExpressions.Blink\n{\n    /// <summary>\n    /// Defines an animator to update eyelid animation per game engine frame.\n    /// </summary>\n    public interface IFramewiseEyelidAnimator\n    {\n        /// <summary>\n        /// Updates animation.\n        /// </summary>\n        void Update();\n\n        /// <summary>\n        /// Resets animation to default.\n        /// </summary>\n        void Reset();\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Blink/RandomFunction.cs", "chunked_list": ["#nullable enable\nusing System;\nusing UnityEngine;\nusing Random = UnityEngine.Random;\n\nnamespace Mochineko.FacialExpressions.Blink\n{\n    /// <summary>\n    /// Provides random functions.\n    /// </summary>\n    public static class RandomFunction\n    {", "    /// Provides random functions.\n    /// </summary>\n    public static class RandomFunction\n    {\n        public static float GaussianRandomInRange(float min, float max)\n        {\n            if (min > max)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(min), min,\n                    \"Min must be less than or equal to max.\");\n            }\n\n            return Mathf.Clamp(\n                GaussianRandom((min + max) / 2f, (max - min) / 6f),\n                min, max);\n        }\n", "        public static float GaussianRandom(float mu, float sigma)\n        {\n            var u1 = Random.value;\n            var u2 = Random.value;\n\n            var z = Mathf.Sqrt(-2f * Mathf.Log(u1)) * Mathf.Sin(2f * Mathf.PI * u2);\n\n            return mu + sigma * z;\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Blink/LoopEyelidAnimator.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\nnamespace Mochineko.FacialExpressions.Blink\n{\n    /// <summary>\n    /// Loops animation of eyelid for any <see cref=\"ISequentialEyelidAnimator\"/>.", "    /// <summary>\n    /// Loops animation of eyelid for any <see cref=\"ISequentialEyelidAnimator\"/>.\n    /// </summary>\n    public sealed class LoopEyelidAnimator : IDisposable\n    {\n        private readonly ISequentialEyelidAnimator animator;\n        private readonly IEnumerable<EyelidAnimationFrame> frames;\n        private readonly CancellationTokenSource cancellationTokenSource = new();\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"LoopEyelidAnimator\"/>.\n        /// </summary>\n        /// <param name=\"animator\">Target animator.</param>\n        /// <param name=\"frames\">Target frames.</param>\n        public LoopEyelidAnimator(\n            ISequentialEyelidAnimator animator,\n            IEnumerable<EyelidAnimationFrame> frames)\n        {\n            this.animator = animator;\n            this.frames = frames;\n\n            LoopAnimationAsync(cancellationTokenSource.Token)\n                .Forget();\n        }\n", "        private async UniTask LoopAnimationAsync(CancellationToken cancellationToken)\n        {\n            while (!cancellationToken.IsCancellationRequested)\n            {\n                await animator.AnimateAsync(frames, cancellationToken);\n\n                await UniTask\n                    .DelayFrame(delayFrameCount: 1, cancellationToken: cancellationToken)\n                    .SuppressCancellationThrow();\n            }\n        }\n", "        public void Dispose()\n        {\n            cancellationTokenSource.Cancel();\n            cancellationTokenSource.Dispose();\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Blink/AnimatorEyelidMorpher.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\nusing UnityEngine;\n\nnamespace Mochineko.FacialExpressions.Blink\n{\n    /// <summary>\n    /// A simple implementation of <see cref=\"IEyelidMorpher\"/> for <see cref=\"Animator\"/>.\n    /// </summary>\n    public sealed class AnimatorEyelidMorpher : IEyelidMorpher\n    {", "    /// </summary>\n    public sealed class AnimatorEyelidMorpher : IEyelidMorpher\n    {\n        private readonly Animator animator;\n        private readonly IReadOnlyDictionary<Eyelid, int> idMap;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"AnimatorEyelidMorpher\"/>.\n        /// </summary>\n        /// <param name=\"animator\">Target animator.</param>\n        /// <param name=\"idMap\">Map of eyelid to animator float key.</param>\n        public AnimatorEyelidMorpher(\n            Animator animator,\n            IReadOnlyDictionary<Eyelid, int> idMap)\n        {\n            this.animator = animator;\n            this.idMap = idMap;\n        }\n", "        public void MorphInto(EyelidSample sample)\n        {\n            if (idMap.TryGetValue(sample.eyelid, out var id))\n            {\n                animator.SetFloat(id, sample.weight);\n            }\n        }\n\n        public float GetWeightOf(Eyelid eyelid)\n        {\n            if (idMap.TryGetValue(eyelid, out var id))\n            {\n                return animator.GetFloat(id);\n            }\n            else\n            {\n                return 0f;\n            }\n        }\n", "        public float GetWeightOf(Eyelid eyelid)\n        {\n            if (idMap.TryGetValue(eyelid, out var id))\n            {\n                return animator.GetFloat(id);\n            }\n            else\n            {\n                return 0f;\n            }\n        }\n", "        public void Reset()\n        {\n            foreach (var id in idMap.Values)\n            {\n                animator.SetFloat(id, 0f);\n            }\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Blink/IEyelidMorpher.cs", "chunked_list": ["#nullable enable\nnamespace Mochineko.FacialExpressions.Blink\n{\n    /// <summary>\n    /// Defines a morpher of eyelid.\n    /// </summary>\n    public interface IEyelidMorpher\n    {\n        /// <summary>\n        /// Morphs specified eyelid into specified weight. \n        /// </summary>\n        /// <param name=\"sample\"></param>\n        void MorphInto(EyelidSample sample);\n\n        /// <summary>\n        /// Gets current weight of specified eyelid.\n        /// </summary>\n        /// <param name=\"eyelid\"></param>\n        /// <returns></returns>\n        float GetWeightOf(Eyelid eyelid);\n\n        /// <summary>\n        /// Resets all morphing to default.\n        /// </summary>\n        void Reset();\n    }\n}"]}
{"filename": "Assets/Mochineko/FacialExpressions/Blink/EyelidSample.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Runtime.InteropServices;\n\nnamespace Mochineko.FacialExpressions.Blink\n{\n    /// <summary>\n    /// A sample of eyelid morphing.\n    /// </summary>\n    [StructLayout(LayoutKind.Sequential)]\n    public readonly struct EyelidSample : IEquatable<EyelidSample>\n    {\n        /// <summary>\n        /// Target eyelid.\n        /// </summary>", "    /// </summary>\n    [StructLayout(LayoutKind.Sequential)]\n    public readonly struct EyelidSample : IEquatable<EyelidSample>\n    {\n        /// <summary>\n        /// Target eyelid.\n        /// </summary>\n        public readonly Eyelid eyelid;\n\n        /// <summary>\n        /// Weight of morphing.\n        /// </summary>", "        public readonly float weight;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"EyelidSample\"/>.\n        /// </summary>\n        /// <param name=\"eyelid\">Target eyelid.</param>\n        /// <param name=\"weight\">Weight of morphing.</param>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>\n        public EyelidSample(Eyelid eyelid, float weight)\n        {\n            if (weight is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(weight), weight,\n                    \"Weight must be between 0 and 1.\");\n            }\n\n            this.eyelid = eyelid;\n            this.weight = weight;\n        }\n", "            if (weight is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(weight), weight,\n                    \"Weight must be between 0 and 1.\");\n            }\n\n            this.eyelid = eyelid;\n            this.weight = weight;\n        }\n", "        public bool Equals(EyelidSample other)\n        {\n            return eyelid == other.eyelid\n                   && weight.Equals(other.weight);\n        }\n\n        public override bool Equals(object? obj)\n        {\n            return obj is EyelidSample other && Equals(other);\n        }\n", "        public override int GetHashCode()\n        {\n            return HashCode.Combine((int)eyelid, weight);\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Blink/Eyelid.cs", "chunked_list": ["#nullable enable\nnamespace Mochineko.FacialExpressions.Blink\n{\n    /// <summary>\n    /// Eyelid orientation.\n    /// </summary>\n    public enum Eyelid : byte\n    {\n        /// <summary>\n        /// Left eyelid.\n        /// </summary>\n        Left,\n        /// <summary>\n        /// Right eyelid.\n        /// </summary>\n        Right,\n        /// <summary>\n        /// Both eyelids.\n        /// </summary>\n        Both,\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Blink/CompositeEyelidMorpher.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\n\nnamespace Mochineko.FacialExpressions.Blink\n{\n    /// <summary>\n    /// Composition of some <see cref=\"IEyelidMorpher\"/>s.\n    /// </summary>\n    public sealed class CompositeEyelidMorpher : IEyelidMorpher\n    {\n        private readonly IReadOnlyList<IEyelidMorpher> morphers;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"CompositeEyelidMorpher\"/>.\n        /// </summary>\n        /// <param name=\"morphers\">Composited morphers.</param>\n        public CompositeEyelidMorpher(IReadOnlyList<IEyelidMorpher> morphers)\n        {\n            this.morphers = morphers;\n        }\n\n        void IEyelidMorpher.MorphInto(EyelidSample sample)\n        {", "    public sealed class CompositeEyelidMorpher : IEyelidMorpher\n    {\n        private readonly IReadOnlyList<IEyelidMorpher> morphers;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"CompositeEyelidMorpher\"/>.\n        /// </summary>\n        /// <param name=\"morphers\">Composited morphers.</param>\n        public CompositeEyelidMorpher(IReadOnlyList<IEyelidMorpher> morphers)\n        {\n            this.morphers = morphers;\n        }\n\n        void IEyelidMorpher.MorphInto(EyelidSample sample)\n        {", "            foreach (var morpher in morphers)\n            {\n                morpher.MorphInto(sample);\n            }\n        }\n\n        float IEyelidMorpher.GetWeightOf(Eyelid eyelid)\n        {\n            return morphers[0].GetWeightOf(eyelid);\n        }\n\n        void IEyelidMorpher.Reset()\n        {", "            foreach (var morpher in morphers)\n            {\n                morpher.Reset();\n            }\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Blink/BlinkFunction.cs", "chunked_list": ["#nullable enable\nusing System;\nusing UnityEngine;\n\nnamespace Mochineko.FacialExpressions.Blink\n{\n    /// <summary>\n    /// Provides blink functions.\n    /// </summary>\n    public static class BlinkFunction\n    {\n        /// <summary>\n        /// Weight of blink approximated by linear function.\n        /// </summary>\n        /// <param name=\"t\"></param>\n        /// <param name=\"tc\"></param>\n        /// <returns></returns>", "    /// </summary>\n    public static class BlinkFunction\n    {\n        /// <summary>\n        /// Weight of blink approximated by linear function.\n        /// </summary>\n        /// <param name=\"t\"></param>\n        /// <param name=\"tc\"></param>\n        /// <returns></returns>\n        public static float LinearWeight(float t, float tc)\n            => t <= tc\n                ? LinearClosingWeight(t, tc)\n                : LinearOpeningWeight(t, tc);\n\n        /// <summary>\n        /// Weight of closing blink approximated by linear function.\n        /// </summary>\n        /// <param name=\"t\"></param>\n        /// <param name=\"tc\"></param>\n        /// <returns></returns>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>", "        public static float LinearWeight(float t, float tc)\n            => t <= tc\n                ? LinearClosingWeight(t, tc)\n                : LinearOpeningWeight(t, tc);\n\n        /// <summary>\n        /// Weight of closing blink approximated by linear function.\n        /// </summary>\n        /// <param name=\"t\"></param>\n        /// <param name=\"tc\"></param>\n        /// <returns></returns>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>", "        public static float LinearClosingWeight(float t, float tc)\n        {\n            if (t is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(t), t,\n                    \"t must be between 0 and 1.\");\n            }\n\n            if (tc is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(tc), tc,\n                    \"tc must be between 0 and 1.\");\n            }\n", "            if (tc is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(tc), tc,\n                    \"tc must be between 0 and 1.\");\n            }\n\n            if (t > tc)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(t), t,\n                    \"t must be less than tc.\");\n            }\n\n            return t / tc;\n        }\n\n        /// <summary>\n        /// Weight of opening blink approximated by linear function.\n        /// </summary>\n        /// <param name=\"t\"></param>\n        /// <param name=\"tc\"></param>\n        /// <returns></returns>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>", "        public static float LinearOpeningWeight(float t, float tc)\n        {\n            if (t is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(t), t,\n                    \"t must be between 0 and 1.\");\n            }\n\n            if (tc is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(tc), tc,\n                    \"tc must be between 0 and 1.\");\n            }\n", "            if (tc is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(tc), tc,\n                    \"tc must be between 0 and 1.\");\n            }\n\n            if (t < tc)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(t), t,\n                    \"t must be greater than tc.\");\n            }\n\n            return (1f - t) / (1f - tc);\n        }\n\n        /// <summary>\n        /// Weight of blink approximated by exponential and quadratic functions.\n        /// </summary>\n        /// <param name=\"t\">Parameter</param>\n        /// <param name=\"tc\">Parameter at closing</param>\n        /// <param name=\"beta\">Strength of closing</param>\n        /// <param name=\"a\">Strength of opening</param>\n        /// <returns></returns>", "        public static float ApproximatedWeight(float t, float tc, float beta, float a)\n            => t <= tc\n                ? ApproximatedClosingWeight(t, tc, beta)\n                : ApproximatedOpeningWeight(t, tc, a);\n\n        /// <summary>\n        /// Weight of closing blink approximated by exponential and quadratic functions.\n        /// </summary>\n        /// <param name=\"t\"></param>\n        /// <param name=\"tc\"></param>\n        /// <param name=\"beta\"></param>\n        /// <returns></returns>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>", "        public static float ApproximatedClosingWeight(float t, float tc, float beta)\n        {\n            if (t is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(t), t,\n                    \"t must be between 0 and 1.\");\n            }\n\n            if (tc is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(tc), tc,\n                    \"tc must be between 0 and 1.\");\n            }\n", "            if (tc is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(tc), tc,\n                    \"tc must be between 0 and 1.\");\n            }\n\n            if (t > tc)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(t), t,\n                    \"t must be less than tc.\");\n            }\n", "            if (beta <= 0f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(beta), beta,\n                    \"beta must be greater than 0.\");\n            }\n\n            // f(t) = \\frac{e^{\\beta t} - 1}{e^{\\beta t_c} - 1} \\ & \\ (0 \\le t \\le t_c)\n            return (Mathf.Exp(beta * t) - 1f) / (Mathf.Exp(beta * tc) - 1f);\n        }\n\n        /// <summary>\n        /// Weight of opening blink approximated by exponential and quadratic functions.\n        /// </summary>\n        /// <param name=\"t\"></param>\n        /// <param name=\"tc\"></param>\n        /// <param name=\"a\"></param>\n        /// <returns></returns>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>", "        public static float ApproximatedOpeningWeight(float t, float tc, float a)\n        {\n            if (t is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(t), t,\n                    \"t must be between 0 and 1.\");\n            }\n\n            if (tc is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(tc), tc,\n                    \"tc must be between 0 and 1.\");\n            }\n", "            if (tc is < 0f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(tc), tc,\n                    \"tc must be between 0 and 1.\");\n            }\n\n            if (t < tc)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(t), t,\n                    \"t must be greater than tc.\");\n            }\n", "            if (a is < -1f or > 1f)\n            {\n                throw new ArgumentOutOfRangeException(\n                    nameof(a), a,\n                    \"a must be between -1 and 1.\");\n            }\n\n            // f(t) = - a (t - t_c)(1 - t) + \\frac{1 - t}{1 - t_c} \\ & \\ (t_c \\le t \\le 1)\n            return -a * (t - tc) * (1f - t) + (1f - t) / (1f - tc);\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Blink/ProbabilisticEyelidAnimationGenerator.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine;\n\nnamespace Mochineko.FacialExpressions.Blink\n{\n    /// <summary>\n    /// A generator of <see cref=\"EyelidAnimationFrame\"/> for approximated eyelid animation.\n    /// </summary>\n    public static class ProbabilisticEyelidAnimationGenerator\n    {\n        /// <summary>\n        /// Generates a collection of <see cref=\"EyelidAnimationFrame\"/>\n        ///  for approximated eyelid animation and harmonic interval.\n        /// </summary>\n        /// <param name=\"eyelid\"></param>\n        /// <param name=\"blinkCount\"></param>\n        /// <param name=\"framesPerSecond\"></param>\n        /// <param name=\"closingRate\"></param>\n        /// <param name=\"beta\"></param>\n        /// <param name=\"a\"></param>\n        /// <param name=\"minDurationSeconds\"></param>\n        /// <param name=\"maxDurationSeconds\"></param>\n        /// <param name=\"minIntervalSeconds\"></param>\n        /// <param name=\"maxIntervalSeconds\"></param>\n        /// <param name=\"harmonicScale\"></param>\n        /// <param name=\"period\"></param>\n        /// <returns></returns>", "    /// A generator of <see cref=\"EyelidAnimationFrame\"/> for approximated eyelid animation.\n    /// </summary>\n    public static class ProbabilisticEyelidAnimationGenerator\n    {\n        /// <summary>\n        /// Generates a collection of <see cref=\"EyelidAnimationFrame\"/>\n        ///  for approximated eyelid animation and harmonic interval.\n        /// </summary>\n        /// <param name=\"eyelid\"></param>\n        /// <param name=\"blinkCount\"></param>\n        /// <param name=\"framesPerSecond\"></param>\n        /// <param name=\"closingRate\"></param>\n        /// <param name=\"beta\"></param>\n        /// <param name=\"a\"></param>\n        /// <param name=\"minDurationSeconds\"></param>\n        /// <param name=\"maxDurationSeconds\"></param>\n        /// <param name=\"minIntervalSeconds\"></param>\n        /// <param name=\"maxIntervalSeconds\"></param>\n        /// <param name=\"harmonicScale\"></param>\n        /// <param name=\"period\"></param>\n        /// <returns></returns>", "        public static IEnumerable<EyelidAnimationFrame> Generate(\n            Eyelid eyelid,\n            int blinkCount,\n            int framesPerSecond = 60, float closingRate = 0.2f,\n            float beta = 10f, float a = 1f,\n            float minDurationSeconds = 0.05f, float maxDurationSeconds = 0.2f,\n            float minIntervalSeconds = 0.1f, float maxIntervalSeconds = 6f,\n            float harmonicScale = 0.03f, float period = 3f)\n        {\n            var frames = new List<EyelidAnimationFrame>();\n", "            for (var i = 0; i < blinkCount; i++)\n            {\n                var duration = RandomFunction.GaussianRandomInRange(\n                    minDurationSeconds,\n                    maxDurationSeconds);\n                frames.AddRange(GenerateBlinkAnimationFrames(\n                    eyelid,\n                    framesPerSecond,\n                    duration,\n                    closingRate,\n                    beta,\n                    a));\n\n                var interval = RandomFunction.GaussianRandomInRange(\n                    minIntervalSeconds,\n                    maxIntervalSeconds);\n                frames.AddRange(GenerateHarmonicIntervalAnimationFrames(\n                    eyelid,\n                    framesPerSecond, interval,\n                    harmonicScale, period));\n            }\n\n            return frames;\n        }\n\n        /// <summary>\n        /// Generates a collection of <see cref=\"EyelidAnimationFrame\"/>\n        ///  for one blinking by approximated function.\n        /// </summary>\n        /// <param name=\"eyelid\"></param>\n        /// <param name=\"framesPerSecond\"></param>\n        /// <param name=\"duration\"></param>\n        /// <param name=\"closingRate\"></param>\n        /// <param name=\"beta\"></param>\n        /// <param name=\"a\"></param>\n        /// <returns></returns>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>", "        public static IEnumerable<EyelidAnimationFrame> GenerateBlinkAnimationFrames(\n            Eyelid eyelid,\n            int framesPerSecond, float duration, float closingRate,\n            float beta, float a)\n        {\n            if (framesPerSecond <= 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(framesPerSecond));\n            }\n\n            if (duration <= 0f)\n            {\n                throw new ArgumentOutOfRangeException(nameof(duration));\n            }\n", "            if (duration <= 0f)\n            {\n                throw new ArgumentOutOfRangeException(nameof(duration));\n            }\n\n            if (closingRate is <= 0f or >= 1f)\n            {\n                throw new ArgumentOutOfRangeException(nameof(closingRate));\n            }\n\n            int frameCount = (int)(duration * framesPerSecond) + 1;\n            var frames = new EyelidAnimationFrame[frameCount];\n            var t = 0f;\n            var dt = duration / frameCount;\n", "            for (var i = 0; i < frameCount - 1; i++)\n            {\n                var weight = BlinkFunction\n                    .ApproximatedWeight(t / duration, closingRate, beta, a);\n\n                frames[i] = new EyelidAnimationFrame(\n                    new EyelidSample(eyelid, weight),\n                    dt);\n\n                t += dt;\n            }\n\n            frames[frameCount - 1] = new EyelidAnimationFrame(\n                new EyelidSample(eyelid, weight: 0f),\n                duration - (t - dt));\n\n            return frames;\n        }\n\n        /// <summary>\n        /// Generates a collection of <see cref=\"EyelidAnimationFrame\"/>\n        ///  for one interval by harmonic function.\n        /// </summary>\n        /// <param name=\"eyelid\"></param>\n        /// <param name=\"framesPerSecond\"></param>\n        /// <param name=\"duration\"></param>\n        /// <param name=\"harmonicScale\"></param>\n        /// <param name=\"period\"></param>\n        /// <returns></returns>", "        public static IEnumerable<EyelidAnimationFrame> GenerateHarmonicIntervalAnimationFrames(\n            Eyelid eyelid,\n            int framesPerSecond, float duration,\n            float harmonicScale, float period)\n        {\n            int frameCount = (int)(duration * framesPerSecond) + 1;\n            var frames = new EyelidAnimationFrame[frameCount];\n            var t = 0f;\n            var dt = duration / frameCount;\n\n            for (var i = 0; i < frameCount - 1; i++)\n            {\n                var weight = harmonicScale * (Mathf.Sin(2f * Mathf.PI * t / period) + 1f) / 2f;\n\n                frames[i] = new EyelidAnimationFrame(\n                    new EyelidSample(eyelid, weight),\n                    dt);\n\n                t += dt;\n            }\n\n            frames[frameCount - 1] = new EyelidAnimationFrame(\n                new EyelidSample(eyelid, weight: 0f),\n                duration - (t - dt));\n\n            return frames;\n        }\n    }\n}", "            for (var i = 0; i < frameCount - 1; i++)\n            {\n                var weight = harmonicScale * (Mathf.Sin(2f * Mathf.PI * t / period) + 1f) / 2f;\n\n                frames[i] = new EyelidAnimationFrame(\n                    new EyelidSample(eyelid, weight),\n                    dt);\n\n                t += dt;\n            }\n\n            frames[frameCount - 1] = new EyelidAnimationFrame(\n                new EyelidSample(eyelid, weight: 0f),\n                duration - (t - dt));\n\n            return frames;\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/FacialExpressions/Blink/ISequentialEyelidAnimator.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\nnamespace Mochineko.FacialExpressions.Blink\n{\n    /// <summary>\n    /// Defines an animator to animate eyelid sequentially by frame collection.\n    /// </summary>\n    public interface ISequentialEyelidAnimator\n    {\n        /// <summary>\n        /// Animates eyelid by a collection of <see cref=\"EyelidAnimationFrame\"/>.\n        /// </summary>\n        /// <param name=\"frames\">Target frames.</param>\n        /// <param name=\"cancellationToken\">Cancellation token.</param>\n        /// <returns></returns>\n        UniTask AnimateAsync(\n            IEnumerable<EyelidAnimationFrame> frames,\n            CancellationToken cancellationToken);\n    }\n}\n", "    /// Defines an animator to animate eyelid sequentially by frame collection.\n    /// </summary>\n    public interface ISequentialEyelidAnimator\n    {\n        /// <summary>\n        /// Animates eyelid by a collection of <see cref=\"EyelidAnimationFrame\"/>.\n        /// </summary>\n        /// <param name=\"frames\">Target frames.</param>\n        /// <param name=\"cancellationToken\">Cancellation token.</param>\n        /// <returns></returns>\n        UniTask AnimateAsync(\n            IEnumerable<EyelidAnimationFrame> frames,\n            CancellationToken cancellationToken);\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Blink/SequentialEyelidAnimator.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Extensions.UniTask;\n\nnamespace Mochineko.FacialExpressions.Blink\n{\n    /// <summary>", "{\n    /// <summary>\n    /// A sequential eyelid animator that animates eyelid sequentially by frame collection.\n    /// </summary>\n    public sealed class SequentialEyelidAnimator : ISequentialEyelidAnimator\n    {\n        private readonly IEyelidMorpher morpher;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"SequentialEyelidAnimator\"/>.\n        /// </summary>\n        /// <param name=\"morpher\">Target morpher.</param>\n        public SequentialEyelidAnimator(IEyelidMorpher morpher)\n        {\n            this.morpher = morpher;\n        }\n", "        public async UniTask AnimateAsync(\n            IEnumerable<EyelidAnimationFrame> frames,\n            CancellationToken cancellationToken)\n        {\n            morpher.Reset();\n\n            while (!cancellationToken.IsCancellationRequested)\n            {\n                foreach (var frame in frames)\n                {\n                    if (cancellationToken.IsCancellationRequested)\n                    {\n                        break;\n                    }\n\n                    morpher.MorphInto(frame.sample);\n\n                    var result = await RelentUniTask.Delay(\n                        TimeSpan.FromSeconds(frame.durationSeconds),\n                        delayTiming: PlayerLoopTiming.Update,\n                        cancellationToken: cancellationToken);\n\n                    // Cancelled", "                foreach (var frame in frames)\n                {\n                    if (cancellationToken.IsCancellationRequested)\n                    {\n                        break;\n                    }\n\n                    morpher.MorphInto(frame.sample);\n\n                    var result = await RelentUniTask.Delay(\n                        TimeSpan.FromSeconds(frame.durationSeconds),\n                        delayTiming: PlayerLoopTiming.Update,\n                        cancellationToken: cancellationToken);\n\n                    // Cancelled", "                    if (result.Failure)\n                    {\n                        break;\n                    }\n                }\n            }\n\n            morpher.Reset();\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Blink/SkinnedMeshEyelidMorpher.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\nusing UnityEngine;\n\nnamespace Mochineko.FacialExpressions.Blink\n{\n    /// <summary>\n    /// A simple implementation of <see cref=\"IEyelidMorpher\"/> for <see cref=\"skinnedMeshRenderer\"/>.\n    /// </summary>\n    public sealed class SkinnedMeshEyelidMorpher : IEyelidMorpher\n    {", "    /// </summary>\n    public sealed class SkinnedMeshEyelidMorpher : IEyelidMorpher\n    {\n        private readonly SkinnedMeshRenderer skinnedMeshRenderer;\n        private readonly IReadOnlyDictionary<Eyelid, int> indexMap;\n        private readonly bool separateBoth;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"SkinnedMeshEyelidMorpher\"/>.\n        /// </summary>\n        /// <param name=\"skinnedMeshRenderer\">Target renderer.</param>\n        /// <param name=\"indexMap\">Map of eyelid and blend shape index.</param>\n        /// <param name=\"separateBoth\">Whether separate both eyelids blend shape.</param>\n        public SkinnedMeshEyelidMorpher(\n            SkinnedMeshRenderer skinnedMeshRenderer,\n            IReadOnlyDictionary<Eyelid, int> indexMap,\n            bool separateBoth = false)\n        {\n            this.skinnedMeshRenderer = skinnedMeshRenderer;\n            this.indexMap = indexMap;\n            this.separateBoth = separateBoth;\n        }\n", "        public void MorphInto(EyelidSample sample)\n        {\n            if (separateBoth && sample.eyelid == Eyelid.Both)\n            {\n                if (indexMap.TryGetValue(Eyelid.Left, out var rightIndex))\n                {\n                    skinnedMeshRenderer.SetBlendShapeWeight(rightIndex, sample.weight * 100f);\n                }\n                if (indexMap.TryGetValue(Eyelid.Right, out var leftIndex))\n                {\n                    skinnedMeshRenderer.SetBlendShapeWeight(leftIndex, sample.weight * 100f);\n                }\n            }", "                if (indexMap.TryGetValue(Eyelid.Right, out var leftIndex))\n                {\n                    skinnedMeshRenderer.SetBlendShapeWeight(leftIndex, sample.weight * 100f);\n                }\n            }\n            else if (indexMap.TryGetValue(sample.eyelid, out var index))\n            {\n                skinnedMeshRenderer.SetBlendShapeWeight(index, sample.weight * 100f);\n            }\n        }\n", "        public float GetWeightOf(Eyelid eyelid)\n        {\n            if (indexMap.TryGetValue(eyelid, out var index))\n            {\n                return skinnedMeshRenderer.GetBlendShapeWeight(index) / 100f;\n            }\n            else\n            {\n                return 0f;\n            }\n        }\n", "        public void Reset()\n        {\n            foreach (var pair in indexMap)\n            {\n                skinnedMeshRenderer.SetBlendShapeWeight(pair.Value, 0f);\n            }\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions/Blink/LinearEyelidAnimationGenerator.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing Random = UnityEngine.Random;\n\nnamespace Mochineko.FacialExpressions.Blink\n{\n    /// <summary>\n    /// A generator of <see cref=\"EyelidAnimationFrame\"/> for linear eyelid animation.\n    /// </summary>\n    public static class LinearEyelidAnimationGenerator\n    {\n        /// <summary>\n        /// Generates a collection of <see cref=\"EyelidAnimationFrame\"/> for some blinking.\n        /// </summary>\n        /// <param name=\"eyelid\"></param>\n        /// <param name=\"blinkCount\"></param>\n        /// <param name=\"framesPerSecond\"></param>\n        /// <param name=\"closingRate\"></param>\n        /// <param name=\"minDurationSeconds\"></param>\n        /// <param name=\"maxDurationSeconds\"></param>\n        /// <param name=\"minIntervalSeconds\"></param>\n        /// <param name=\"maxIntervalSeconds\"></param>\n        /// <returns></returns>", "    /// A generator of <see cref=\"EyelidAnimationFrame\"/> for linear eyelid animation.\n    /// </summary>\n    public static class LinearEyelidAnimationGenerator\n    {\n        /// <summary>\n        /// Generates a collection of <see cref=\"EyelidAnimationFrame\"/> for some blinking.\n        /// </summary>\n        /// <param name=\"eyelid\"></param>\n        /// <param name=\"blinkCount\"></param>\n        /// <param name=\"framesPerSecond\"></param>\n        /// <param name=\"closingRate\"></param>\n        /// <param name=\"minDurationSeconds\"></param>\n        /// <param name=\"maxDurationSeconds\"></param>\n        /// <param name=\"minIntervalSeconds\"></param>\n        /// <param name=\"maxIntervalSeconds\"></param>\n        /// <returns></returns>", "        public static IEnumerable<EyelidAnimationFrame> Generate(\n            Eyelid eyelid,\n            int blinkCount,\n            int framesPerSecond = 60, float closingRate = 0.2f,\n            float minDurationSeconds = 0.05f, float maxDurationSeconds = 0.2f,\n            float minIntervalSeconds = 0.1f, float maxIntervalSeconds = 6f)\n        {\n            var frames = new List<EyelidAnimationFrame>();\n\n            for (var i = 0; i < blinkCount; i++)\n            {\n                var duration = Random.Range(minDurationSeconds, maxDurationSeconds);\n                frames.AddRange(GenerateBlinkAnimationFrames(\n                    eyelid,\n                    framesPerSecond,\n                    duration,\n                    closingRate));\n\n                var interval = Random.Range(minIntervalSeconds, maxIntervalSeconds);\n                frames.Add(new EyelidAnimationFrame(\n                    new EyelidSample(eyelid, weight: 0f),\n                    interval));\n            }\n\n            return frames;\n        }\n\n        /// <summary>\n        /// Generates a collection of <see cref=\"EyelidAnimationFrame\"/> for one blinking.\n        /// </summary>\n        /// <param name=\"eyelid\"></param>\n        /// <param name=\"framesPerSecond\"></param>\n        /// <param name=\"duration\"></param>\n        /// <param name=\"closingRate\"></param>\n        /// <returns></returns>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>", "            for (var i = 0; i < blinkCount; i++)\n            {\n                var duration = Random.Range(minDurationSeconds, maxDurationSeconds);\n                frames.AddRange(GenerateBlinkAnimationFrames(\n                    eyelid,\n                    framesPerSecond,\n                    duration,\n                    closingRate));\n\n                var interval = Random.Range(minIntervalSeconds, maxIntervalSeconds);\n                frames.Add(new EyelidAnimationFrame(\n                    new EyelidSample(eyelid, weight: 0f),\n                    interval));\n            }\n\n            return frames;\n        }\n\n        /// <summary>\n        /// Generates a collection of <see cref=\"EyelidAnimationFrame\"/> for one blinking.\n        /// </summary>\n        /// <param name=\"eyelid\"></param>\n        /// <param name=\"framesPerSecond\"></param>\n        /// <param name=\"duration\"></param>\n        /// <param name=\"closingRate\"></param>\n        /// <returns></returns>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>", "        public static IEnumerable<EyelidAnimationFrame> GenerateBlinkAnimationFrames(\n            Eyelid eyelid,\n            int framesPerSecond, float duration, float closingRate)\n        {\n            if (framesPerSecond <= 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(framesPerSecond));\n            }\n\n            if (duration <= 0f)\n            {\n                throw new ArgumentOutOfRangeException(nameof(duration));\n            }\n", "            if (duration <= 0f)\n            {\n                throw new ArgumentOutOfRangeException(nameof(duration));\n            }\n\n            if (closingRate is <= 0f or >= 1f)\n            {\n                throw new ArgumentOutOfRangeException(nameof(closingRate));\n            }\n\n            int frameCount = (int)(duration * framesPerSecond) + 1;\n            var frames = new EyelidAnimationFrame[frameCount];\n            var t = 0f;\n            var dt = duration / frameCount;\n", "            for (var i = 0; i < frameCount - 1; i++)\n            {\n                var weight = BlinkFunction\n                    .LinearWeight(t / duration, closingRate);\n\n                frames[i] = new EyelidAnimationFrame(\n                    new EyelidSample(eyelid, weight),\n                    dt);\n\n                t += dt;\n            }\n\n            frames[frameCount - 1] = new EyelidAnimationFrame(\n                new EyelidSample(eyelid, weight: 0f),\n                duration - (t - dt));\n\n            return frames;\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/FacialExpressions.Extensions/VOICEVOX/AudioQueryConverter.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\nusing Mochineko.FacialExpressions.LipSync;\nusing Mochineko.VOICEVOX_API.QueryCreation;\n\nnamespace Mochineko.FacialExpressions.Extensions.VOICEVOX\n{\n    /// <summary>\n    /// Provides converting from <see cref=\"AudioQuery\"/> to collection of <see cref=\"LipAnimationFrame\"/>.\n    /// </summary>\n    public static class AudioQueryConverter\n    {", "    /// Provides converting from <see cref=\"AudioQuery\"/> to collection of <see cref=\"LipAnimationFrame\"/>.\n    /// </summary>\n    public static class AudioQueryConverter\n    {\n        private static readonly IReadOnlyDictionary<string, Viseme> VisemeMap\n            = new Dictionary<string, Viseme>\n            {\n                // Vowels\n                [\"pau\"] = Viseme.sil, [\"cl\"] = Viseme.sil,\n                [\"a\"] = Viseme.aa, [\"A\"] = Viseme.aa,\n                [\"i\"] = Viseme.ih, [\"I\"] = Viseme.ih,\n                [\"u\"] = Viseme.ou, [\"U\"] = Viseme.ou,\n                [\"e\"] = Viseme.E, [\"E\"] = Viseme.E,\n                [\"o\"] = Viseme.oh, [\"O\"] = Viseme.oh,\n                [\"N\"] = Viseme.nn,\n                // Consonants\n                [\"y\"] = Viseme.sil,\n                [\"p\"] = Viseme.PP, [\"py\"] = Viseme.PP, [\"b\"] = Viseme.PP, [\"by\"] = Viseme.PP, [\"m\"] = Viseme.PP,\n                [\"my\"] = Viseme.PP,\n                [\"f\"] = Viseme.FF, [\"v\"] = Viseme.FF, [\"w\"] = Viseme.FF, [\"h\"] = Viseme.FF, [\"hy\"] = Viseme.FF,\n                [\"d\"] = Viseme.DD, [\"dy\"] = Viseme.DD, [\"t\"] = Viseme.DD, [\"ty\"] = Viseme.DD, [\"ts\"] = Viseme.DD,\n                [\"k\"] = Viseme.kk, [\"kw\"] = Viseme.kk, [\"ky\"] = Viseme.kk, [\"g\"] = Viseme.kk, [\"gy\"] = Viseme.kk,\n                [\"ch\"] = Viseme.CH, [\"sh\"] = Viseme.CH, [\"j\"] = Viseme.CH,\n                [\"z\"] = Viseme.SS, [\"s\"] = Viseme.SS,\n                [\"n\"] = Viseme.nn, [\"ny\"] = Viseme.nn,\n                [\"r\"] = Viseme.RR, [\"ry\"] = Viseme.RR,\n            };\n\n        /// <summary>\n        /// Converts <see cref=\"AudioQuery\"/> to collection of <see cref=\"LipAnimationFrame\"/>.\n        /// </summary>\n        /// <param name=\"audioQuery\"></param>\n        /// <returns></returns>", "        public static IEnumerable<LipAnimationFrame> ConvertToSequentialAnimationFrames(\n            AudioQuery audioQuery)\n        {\n            var frames = new List<LipAnimationFrame>();\n\n            frames.Add(new LipAnimationFrame(\n                new LipSample(Viseme.sil, weight: 0f),\n                audioQuery.PrePhonemeLength / audioQuery.SpeedScale));\n\n            foreach (var phase in audioQuery.AccentPhases)\n            {", "            foreach (var phase in audioQuery.AccentPhases)\n            {\n                foreach (var mora in phase.Moras)\n                {\n                    var duration = mora.VowelLength;\n                    if (mora.ConsonantLength is not null)\n                    {\n                        duration += mora.ConsonantLength.Value;\n                    }\n                    \n                    frames.Add(new LipAnimationFrame(\n                        new LipSample(VisemeMap[mora.Vowel], weight: 1f),\n                        duration / audioQuery.SpeedScale));\n\n                    frames.Add(new LipAnimationFrame(\n                        new LipSample(VisemeMap[mora.Vowel], weight: 0f),\n                        durationSeconds: 0f));\n                }\n", "                if (phase.PauseMora is not null)\n                {\n                    frames.Add(new LipAnimationFrame(\n                        new LipSample(Viseme.sil, weight: 0f),\n                        durationSeconds: phase.PauseMora.VowelLength / audioQuery.SpeedScale));\n                }\n            }\n\n            frames.Add(new LipAnimationFrame(\n                new LipSample(Viseme.sil, weight: 0f),\n                audioQuery.PostPhonemeLength / audioQuery.SpeedScale));\n\n            return frames;\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/FacialExpressions.Extensions/uLipSync/ULipSyncAnimator.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing Mochineko.FacialExpressions.LipSync;\nusing UniRx;\nusing UnityEngine;\n\nnamespace Mochineko.FacialExpressions.Extensions.uLipSync\n{\n    /// <summary>", "{\n    /// <summary>\n    /// An implementation of <see cref=\"IFramewiseLipAnimator\"/> for <see cref=\"global::uLipSync.uLipSync\"/>.\n    /// </summary>\n    public sealed class ULipSyncAnimator : IFramewiseLipAnimator, IDisposable\n    {\n        private readonly FollowingLipAnimator followingLipAnimator;\n        private readonly global::uLipSync.uLipSync uLipSync;\n        private readonly IReadOnlyDictionary<string, Viseme> phonomeMap;\n        private readonly IDisposable disposable;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"ULipSyncAnimator\"/>.\n        /// </summary>\n        /// <param name=\"followingLipAnimator\">Wrapped <see cref=\"FollowingLipAnimator\"/>.</param>\n        /// <param name=\"uLipSync\">Target <see cref=\"global::uLipSync.uLipSync\"/>.</param>\n        /// <param name=\"phonomeMap\">Map of phoneme to viseme.</param>\n        /// <param name=\"volumeThreshold\">Threshold of volume.</param>\n        /// <param name=\"verbose\">Whether to output log.</param>\n        public ULipSyncAnimator(\n            FollowingLipAnimator followingLipAnimator,\n            global::uLipSync.uLipSync uLipSync,\n            IReadOnlyDictionary<string, Viseme> phonomeMap,\n            float volumeThreshold = 0.01f,\n            bool verbose = false)\n        {\n            this.followingLipAnimator = followingLipAnimator;\n            this.phonomeMap = phonomeMap;\n            this.uLipSync = uLipSync;\n\n            this.disposable = this.uLipSync\n                .ObserveEveryValueChanged(lipSync => lipSync.result)\n                .Subscribe(info =>\n                {", "        private readonly IReadOnlyDictionary<string, Viseme> phonomeMap;\n        private readonly IDisposable disposable;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"ULipSyncAnimator\"/>.\n        /// </summary>\n        /// <param name=\"followingLipAnimator\">Wrapped <see cref=\"FollowingLipAnimator\"/>.</param>\n        /// <param name=\"uLipSync\">Target <see cref=\"global::uLipSync.uLipSync\"/>.</param>\n        /// <param name=\"phonomeMap\">Map of phoneme to viseme.</param>\n        /// <param name=\"volumeThreshold\">Threshold of volume.</param>\n        /// <param name=\"verbose\">Whether to output log.</param>\n        public ULipSyncAnimator(\n            FollowingLipAnimator followingLipAnimator,\n            global::uLipSync.uLipSync uLipSync,\n            IReadOnlyDictionary<string, Viseme> phonomeMap,\n            float volumeThreshold = 0.01f,\n            bool verbose = false)\n        {\n            this.followingLipAnimator = followingLipAnimator;\n            this.phonomeMap = phonomeMap;\n            this.uLipSync = uLipSync;\n\n            this.disposable = this.uLipSync\n                .ObserveEveryValueChanged(lipSync => lipSync.result)\n                .Subscribe(info =>\n                {", "                    if (verbose)\n                    {\n                        Debug.Log($\"[FacialExpressions.uLipSync] Update lip sync: {info.phoneme}, {info.volume}\");\n                    }\n\n                    if (phonomeMap.TryGetValue(info.phoneme, out var viseme) && info.volume > volumeThreshold)\n                    {\n                        SetTarget(new LipSample(viseme, weight: 1f));\n                    }\n                    else\n                    {\n                        SetDefault();\n                    }\n                });\n        }\n", "        public void Dispose()\n        {\n            Reset();\n            disposable.Dispose();\n        }\n\n        public void Update()\n        {\n            followingLipAnimator.Update();\n        }\n", "        public void Reset()\n        {\n            followingLipAnimator.Reset();\n        }\n\n        private void SetTarget(LipSample sample)\n        {\n            foreach (var viseme in phonomeMap.Values)\n            {\n                if (viseme == sample.viseme)\n                {\n                    followingLipAnimator.SetTarget(sample);\n                }\n                else\n                {\n                    followingLipAnimator.SetTarget(new LipSample(viseme, weight: 0f));\n                }\n            }\n        }\n", "                if (viseme == sample.viseme)\n                {\n                    followingLipAnimator.SetTarget(sample);\n                }\n                else\n                {\n                    followingLipAnimator.SetTarget(new LipSample(viseme, weight: 0f));\n                }\n            }\n        }\n", "        private void SetDefault()\n        {\n            foreach (var viseme in phonomeMap.Values)\n            {\n                followingLipAnimator.SetTarget(new LipSample(viseme, weight: 0f));\n            }\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions.Extensions/VRM/VRMEmotionMorpher.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing Mochineko.FacialExpressions.Emotion;\nusing UniVRM10;\n\nnamespace Mochineko.FacialExpressions.Samples\n{\n    /// <summary>\n    /// A sample of emotion morpher for VRM models.", "    /// <summary>\n    /// A sample of emotion morpher for VRM models.\n    /// </summary>\n    // ReSharper disable once InconsistentNaming\n    public sealed class VRMEmotionMorpher<TEmotion> :\n        IEmotionMorpher<TEmotion>\n        where TEmotion: Enum\n    {\n        private readonly Vrm10RuntimeExpression expression;\n        private readonly IReadOnlyDictionary<TEmotion, ExpressionKey> keyMap;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"VRMEmotionMorpher\"/>.\n        /// </summary>\n        /// <param name=\"expression\">Target expression of VRM instance.</param>\n        /// <param name=\"keyMap\">Map of emotion to expression key.</param>\n        public VRMEmotionMorpher(\n            Vrm10RuntimeExpression expression,\n            IReadOnlyDictionary<TEmotion, ExpressionKey> keyMap)\n        {\n            this.expression = expression;\n            this.keyMap = keyMap;\n        }\n", "        private readonly Vrm10RuntimeExpression expression;\n        private readonly IReadOnlyDictionary<TEmotion, ExpressionKey> keyMap;\n\n        /// <summary>\n        /// Creates a new instance of <see cref=\"VRMEmotionMorpher\"/>.\n        /// </summary>\n        /// <param name=\"expression\">Target expression of VRM instance.</param>\n        /// <param name=\"keyMap\">Map of emotion to expression key.</param>\n        public VRMEmotionMorpher(\n            Vrm10RuntimeExpression expression,\n            IReadOnlyDictionary<TEmotion, ExpressionKey> keyMap)\n        {\n            this.expression = expression;\n            this.keyMap = keyMap;\n        }\n", "        public void MorphInto(EmotionSample<TEmotion> sample)\n        {\n            if (keyMap.TryGetValue(sample.emotion, out var key))\n            {\n                expression.SetWeight(key, sample.weight);\n            }\n        }\n\n        public float GetWeightOf(TEmotion emotion)\n        {\n            if (keyMap.TryGetValue(emotion, out var key))\n            {\n                return expression.GetWeight(key);\n            }\n            else\n            {\n                return 0f;\n            }\n        }\n", "        public float GetWeightOf(TEmotion emotion)\n        {\n            if (keyMap.TryGetValue(emotion, out var key))\n            {\n                return expression.GetWeight(key);\n            }\n            else\n            {\n                return 0f;\n            }\n        }\n", "        public void Reset()\n        {\n            expression.SetWeight(ExpressionKey.Neutral, 0f);\n            expression.SetWeight(ExpressionKey.Happy, 0f);\n            expression.SetWeight(ExpressionKey.Angry, 0f);\n            expression.SetWeight(ExpressionKey.Sad, 0f);\n            expression.SetWeight(ExpressionKey.Relaxed, 0f);\n            expression.SetWeight(ExpressionKey.Surprised, 0f);\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions.Extensions/VRM/VRMEyelidMorpher.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\nusing Mochineko.FacialExpressions.Blink;\nusing UniVRM10;\n\nnamespace Mochineko.FacialExpressions.Extensions.VRM\n{\n    /// <summary>\n    /// An eyelid morpher for VRM models.\n    /// </summary>", "    /// An eyelid morpher for VRM models.\n    /// </summary>\n    // ReSharper disable once InconsistentNaming\n    public sealed class VRMEyelidMorpher : IEyelidMorpher\n    {\n        private readonly Vrm10RuntimeExpression expression;\n\n        private static readonly IReadOnlyDictionary<Eyelid, ExpressionKey> KeyMap\n            = new Dictionary<Eyelid, ExpressionKey>\n            {\n                [Eyelid.Both] = ExpressionKey.Blink,\n                [Eyelid.Left] = ExpressionKey.BlinkLeft,\n                [Eyelid.Right] = ExpressionKey.BlinkRight,\n            };\n\n        /// <summary>\n        /// Create an eyelid morpher for VRM models.\n        /// </summary>\n        /// <param name=\"expression\">Target expression of VRM instance.</param>\n        public VRMEyelidMorpher(Vrm10RuntimeExpression expression)\n        {\n            this.expression = expression;\n        }\n", "        public void MorphInto(EyelidSample sample)\n        {\n            if (KeyMap.TryGetValue(sample.eyelid, out var key))\n            {\n                expression.SetWeight(key, sample.weight);\n            }\n        }\n\n        public float GetWeightOf(Eyelid eyelid)\n        {\n            if (KeyMap.TryGetValue(eyelid, out var key))\n            {\n                return expression.GetWeight(key);\n            }\n            else\n            {\n                return 0f;\n            }\n        }\n", "        public float GetWeightOf(Eyelid eyelid)\n        {\n            if (KeyMap.TryGetValue(eyelid, out var key))\n            {\n                return expression.GetWeight(key);\n            }\n            else\n            {\n                return 0f;\n            }\n        }\n", "        public void Reset()\n        {\n            expression.SetWeight(ExpressionKey.BlinkLeft, 0f);\n            expression.SetWeight(ExpressionKey.BlinkRight, 0f);\n            expression.SetWeight(ExpressionKey.Blink, 0f);\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions.Extensions/VRM/VRMLipMorpher.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\nusing Mochineko.FacialExpressions.LipSync;\nusing UniVRM10;\n\nnamespace Mochineko.FacialExpressions.Extensions.VRM\n{\n    /// <summary>\n    /// A lip morpher for VRM models.\n    /// </summary>", "    /// A lip morpher for VRM models.\n    /// </summary>\n    // ReSharper disable once InconsistentNaming\n    public sealed class VRMLipMorpher : ILipMorpher\n    {\n        private readonly Vrm10RuntimeExpression expression;\n\n        private static readonly IReadOnlyDictionary<Viseme, ExpressionKey> KeyMap\n            = new Dictionary<Viseme, ExpressionKey>\n            {\n                [Viseme.aa] = ExpressionKey.Aa,\n                [Viseme.ih] = ExpressionKey.Ih,\n                [Viseme.ou] = ExpressionKey.Ou,\n                [Viseme.E] = ExpressionKey.Ee,\n                [Viseme.oh] = ExpressionKey.Ou,\n            };\n\n        /// <summary>\n        /// Create a lip morpher for VRM models.\n        /// </summary>\n        /// <param name=\"expression\">Target expression of VRM instance.</param>\n        public VRMLipMorpher(Vrm10RuntimeExpression expression)\n        {\n            this.expression = expression;\n        }\n", "        public void MorphInto(LipSample sample)\n        {\n            if (KeyMap.TryGetValue(sample.viseme, out var key))\n            {\n                expression.SetWeight(key, sample.weight);\n            }\n        }\n\n        public float GetWeightOf(Viseme viseme)\n        {\n            if (KeyMap.TryGetValue(viseme, out var key))\n            {\n                return expression.GetWeight(key);\n            }\n            else\n            {\n                return 0f;\n            }\n        }\n", "        public float GetWeightOf(Viseme viseme)\n        {\n            if (KeyMap.TryGetValue(viseme, out var key))\n            {\n                return expression.GetWeight(key);\n            }\n            else\n            {\n                return 0f;\n            }\n        }\n", "        public void Reset()\n        {\n            expression.SetWeight(ExpressionKey.Aa, 0f);\n            expression.SetWeight(ExpressionKey.Ih, 0f);\n            expression.SetWeight(ExpressionKey.Ou, 0f);\n            expression.SetWeight(ExpressionKey.Ee, 0f);\n            expression.SetWeight(ExpressionKey.Oh, 0f);\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions.Samples/SampleForULipSyncAndVRM.cs", "chunked_list": ["\ufeff#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.FacialExpressions.Blink;\nusing Mochineko.FacialExpressions.Emotion;\nusing Mochineko.FacialExpressions.Extensions.uLipSync;\nusing Mochineko.FacialExpressions.Extensions.VRM;", "using Mochineko.FacialExpressions.Extensions.uLipSync;\nusing Mochineko.FacialExpressions.Extensions.VRM;\nusing Mochineko.FacialExpressions.LipSync;\nusing Mochineko.VOICEVOX_API;\nusing UnityEngine;\nusing UniVRM10;\nusing VRMShaders;\n\nnamespace Mochineko.FacialExpressions.Samples\n{\n    internal sealed class SampleForULipSyncAndVRM : MonoBehaviour\n    {", "namespace Mochineko.FacialExpressions.Samples\n{\n    internal sealed class SampleForULipSyncAndVRM : MonoBehaviour\n    {\n        [SerializeField] private string path = string.Empty;\n        [SerializeField] private BasicEmotion basicEmotion = BasicEmotion.Neutral;\n        [SerializeField] private float emotionWeight = 1f;\n        [SerializeField] private float emotionFollowingTime = 1f;\n        [SerializeField] private uLipSync.uLipSync? uLipSync = null;\n\n        private ULipSyncAnimator? lipAnimator;\n        private IDisposable? eyelidAnimationLoop;\n        private ExclusiveFollowingEmotionAnimator<BasicEmotion>? emotionAnimator;\n", "        private async void Start()\n        {\n            if (uLipSync == null)\n            {\n                throw new NullReferenceException(nameof(uLipSync));\n            }\n\n            VoiceVoxBaseURL.BaseURL = \"http://127.0.0.1:50021\";\n\n            var binary = await File.ReadAllBytesAsync(\n                path,\n                this.GetCancellationTokenOnDestroy());\n\n            var instance = await LoadVRMAsync(\n                binary,\n                this.GetCancellationTokenOnDestroy());\n\n            var lipMorpher = new VRMLipMorpher(instance.Runtime.Expression);\n            var followingLipAnimator = new FollowingLipAnimator(lipMorpher, followingTime: 0.15f);\n            lipAnimator = new ULipSyncAnimator(\n                followingLipAnimator,\n                uLipSync,\n                phonomeMap: new Dictionary<string, Viseme>\n                {\n                    [\"A\"] = Viseme.aa,\n                    [\"I\"] = Viseme.ih,\n                    [\"U\"] = Viseme.ou,\n                    [\"E\"] = Viseme.E,\n                    [\"O\"] = Viseme.oh,\n                    [\"N\"] = Viseme.sil,\n                });\n\n            var eyelidFrames = ProbabilisticEyelidAnimationGenerator.Generate(\n                Eyelid.Both,\n                blinkCount: 20);\n\n            var eyelidMorpher = new VRMEyelidMorpher(instance.Runtime.Expression);\n            var eyelidAnimator = new SequentialEyelidAnimator(eyelidMorpher);\n            eyelidAnimationLoop = new LoopEyelidAnimator(eyelidAnimator, eyelidFrames);\n\n            var emotionMorpher = new VRMEmotionMorpher<BasicEmotion>(\n                instance.Runtime.Expression,\n                keyMap: new Dictionary<BasicEmotion, ExpressionKey>\n                {\n                    [BasicEmotion.Neutral] = ExpressionKey.Neutral,\n                    [BasicEmotion.Happy] = ExpressionKey.Happy,\n                    [BasicEmotion.Sad] = ExpressionKey.Sad,\n                    [BasicEmotion.Angry] = ExpressionKey.Angry,\n                    [BasicEmotion.Fearful] = ExpressionKey.Neutral,\n                    [BasicEmotion.Surprised] = ExpressionKey.Surprised,\n                    [BasicEmotion.Disgusted] = ExpressionKey.Neutral,\n                });\n            emotionAnimator = new ExclusiveFollowingEmotionAnimator<BasicEmotion>(\n                emotionMorpher,\n                followingTime: emotionFollowingTime);\n        }\n", "        private void Update()\n        {\n            lipAnimator?.Update();\n            emotionAnimator?.Update();\n        }\n\n        private void OnDestroy()\n        {\n            lipAnimator?.Dispose();\n            eyelidAnimationLoop?.Dispose();\n        }\n", "        private static async UniTask<Vrm10Instance> LoadVRMAsync(\n            byte[] binaryData,\n            CancellationToken cancellationToken)\n        {\n            cancellationToken.ThrowIfCancellationRequested();\n\n            return await Vrm10.LoadBytesAsync(\n                bytes: binaryData,\n                canLoadVrm0X: true,\n                controlRigGenerationOption: ControlRigGenerationOption.None,\n                showMeshes: true,\n                awaitCaller: new RuntimeOnlyAwaitCaller(),\n                materialGenerator: null,\n                vrmMetaInformationCallback: null,\n                ct: cancellationToken\n            );\n        }\n\n        [ContextMenu(nameof(Emote))]", "        public void Emote()\n        {\n            emotionAnimator?\n                .Emote(new EmotionSample<BasicEmotion>(\n                    basicEmotion,\n                    weight: emotionWeight));\n        }\n    }\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions.Samples/PolicyFactory.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.IO;\nusing Mochineko.Relent.Resilience;\nusing Mochineko.Relent.Resilience.Bulkhead;\nusing Mochineko.Relent.Resilience.Retry;\nusing Mochineko.Relent.Resilience.Timeout;\nusing Mochineko.Relent.Resilience.Wrap;\nusing Mochineko.VOICEVOX_API.QueryCreation;\n", "using Mochineko.VOICEVOX_API.QueryCreation;\n\nnamespace Mochineko.FacialExpressions.Samples\n{\n    internal static class PolicyFactory\n    {\n        private const float TotalTimeoutSeconds = 60f;\n        private const float EachTimeoutSeconds = 30f;\n        private const int MaxRetryCount = 5;\n        private const float RetryIntervalSeconds = 1f;\n        private const int MaxParallelization = 1;\n        ", "        private const int MaxRetryCount = 5;\n        private const float RetryIntervalSeconds = 1f;\n        private const int MaxParallelization = 1;\n        \n        public static IPolicy<Stream> BuildSynthesisPolicy()\n        {\n            var totalTimeoutPolicy = TimeoutFactory.Timeout<Stream>(\n                timeout: TimeSpan.FromSeconds(TotalTimeoutSeconds));\n            \n            var retryPolicy = RetryFactory.RetryWithInterval<Stream>(\n                MaxRetryCount,\n                interval: TimeSpan.FromSeconds(RetryIntervalSeconds));\n\n            var eachTimeoutPolicy = TimeoutFactory.Timeout<Stream>(\n                timeout: TimeSpan.FromSeconds(EachTimeoutSeconds));\n\n            var bulkheadPolicy = BulkheadFactory.Bulkhead<Stream>(\n                MaxParallelization);\n\n            return totalTimeoutPolicy\n                .Wrap(retryPolicy)\n                .Wrap(eachTimeoutPolicy)\n                .Wrap(bulkheadPolicy);\n        }\n        ", "        public static IPolicy<AudioQuery> BuildQueryCreationPolicy()\n        {\n            var totalTimeoutPolicy = TimeoutFactory.Timeout<AudioQuery>(\n                timeout: TimeSpan.FromSeconds(TotalTimeoutSeconds));\n            \n            var retryPolicy = RetryFactory.RetryWithInterval<AudioQuery>(\n                MaxRetryCount,\n                interval: TimeSpan.FromSeconds(RetryIntervalSeconds));\n\n            var eachTimeoutPolicy = TimeoutFactory.Timeout<AudioQuery>(\n                timeout: TimeSpan.FromSeconds(EachTimeoutSeconds));\n\n            var bulkheadPolicy = BulkheadFactory.Bulkhead<AudioQuery>(\n                MaxParallelization);\n\n            return totalTimeoutPolicy\n                .Wrap(retryPolicy)\n                .Wrap(eachTimeoutPolicy)\n                .Wrap(bulkheadPolicy);\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/FacialExpressions.Samples/SampleForVoiceVoxAndVRM.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.FacialExpressions.Blink;\nusing Mochineko.FacialExpressions.Emotion;\nusing Mochineko.FacialExpressions.Extensions.VOICEVOX;\nusing Mochineko.FacialExpressions.Extensions.VRM;", "using Mochineko.FacialExpressions.Extensions.VOICEVOX;\nusing Mochineko.FacialExpressions.Extensions.VRM;\nusing Mochineko.FacialExpressions.LipSync;\nusing Mochineko.Relent.Resilience;\nusing Mochineko.Relent.UncertainResult;\nusing Mochineko.SimpleAudioCodec;\nusing Mochineko.VOICEVOX_API;\nusing Mochineko.VOICEVOX_API.QueryCreation;\nusing Mochineko.VOICEVOX_API.Synthesis;\nusing Newtonsoft.Json;", "using Mochineko.VOICEVOX_API.Synthesis;\nusing Newtonsoft.Json;\nusing UnityEngine;\nusing UnityEngine.Assertions;\nusing UniVRM10;\nusing VRMShaders;\n\nnamespace Mochineko.FacialExpressions.Samples\n{\n    // ReSharper disable once InconsistentNaming\n    internal sealed class SampleForVoiceVoxAndVRM : MonoBehaviour\n    {\n        [SerializeField]", "{\n    // ReSharper disable once InconsistentNaming\n    internal sealed class SampleForVoiceVoxAndVRM : MonoBehaviour\n    {\n        [SerializeField]\n        private string path = string.Empty;\n\n        [SerializeField]\n        private string text = string.Empty;\n\n        [SerializeField]", "        private string text = string.Empty;\n\n        [SerializeField]\n        private int speakerID;\n\n        [SerializeField]\n        private AudioSource? audioSource = null;\n\n        [SerializeField]\n        private bool skipSpeechSynthesis = false;\n\n        [SerializeField]", "        private bool skipSpeechSynthesis = false;\n\n        [SerializeField]\n        private BasicEmotion basicEmotion = BasicEmotion.Neutral;\n\n        [SerializeField]\n        private float emotionWeight = 1f;\n\n        [SerializeField]\n        private float emotionFollowingTime = 1f;\n\n        private FollowingLipAnimator? lipAnimator;\n        private IDisposable? eyelidAnimationLoop;\n        private ExclusiveFollowingEmotionAnimator<BasicEmotion>? emotionAnimator;\n        private AudioClip? audioClip;\n", "        private float emotionFollowingTime = 1f;\n\n        private FollowingLipAnimator? lipAnimator;\n        private IDisposable? eyelidAnimationLoop;\n        private ExclusiveFollowingEmotionAnimator<BasicEmotion>? emotionAnimator;\n        private AudioClip? audioClip;\n\n        private readonly IPolicy<AudioQuery> queryCreationPolicy\n            = PolicyFactory.BuildQueryCreationPolicy();\n\n        private readonly IPolicy<Stream> synthesisPolicy\n            = PolicyFactory.BuildSynthesisPolicy();\n", "        private readonly IPolicy<Stream> synthesisPolicy\n            = PolicyFactory.BuildSynthesisPolicy();\n\n        private void Awake()\n        {\n            Assert.IsNotNull(audioSource);\n        }\n\n        private async void Start()\n        {\n            VoiceVoxBaseURL.BaseURL = \"http://127.0.0.1:50021\";\n\n            var binary = await File.ReadAllBytesAsync(\n                path,\n                this.GetCancellationTokenOnDestroy());\n\n            var instance = await LoadVRMAsync(\n                binary,\n                this.GetCancellationTokenOnDestroy());\n\n            var lipMorpher = new VRMLipMorpher(instance.Runtime.Expression);\n            lipAnimator = new FollowingLipAnimator(lipMorpher);\n\n            var eyelidFrames = ProbabilisticEyelidAnimationGenerator\n                .Generate(\n                    Eyelid.Both,\n                    blinkCount: 20\n                );\n\n            var eyelidMorpher = new VRMEyelidMorpher(instance.Runtime.Expression);\n            var eyelidAnimator = new SequentialEyelidAnimator(eyelidMorpher);\n            eyelidAnimationLoop = new LoopEyelidAnimator(eyelidAnimator, eyelidFrames);\n\n            var emotionMorpher = new VRMEmotionMorpher<BasicEmotion>(\n                instance.Runtime.Expression,\n                keyMap: new Dictionary<BasicEmotion, ExpressionKey>\n                {\n                    [BasicEmotion.Neutral] = ExpressionKey.Neutral,\n                    [BasicEmotion.Happy] = ExpressionKey.Happy,\n                    [BasicEmotion.Sad] = ExpressionKey.Sad,\n                    [BasicEmotion.Angry] = ExpressionKey.Angry,\n                    [BasicEmotion.Fearful] = ExpressionKey.Neutral,\n                    [BasicEmotion.Surprised] = ExpressionKey.Surprised,\n                    [BasicEmotion.Disgusted] = ExpressionKey.Neutral,\n                });\n            emotionAnimator = new ExclusiveFollowingEmotionAnimator<BasicEmotion>(\n                emotionMorpher,\n                followingTime: emotionFollowingTime);\n        }\n", "        private async void Start()\n        {\n            VoiceVoxBaseURL.BaseURL = \"http://127.0.0.1:50021\";\n\n            var binary = await File.ReadAllBytesAsync(\n                path,\n                this.GetCancellationTokenOnDestroy());\n\n            var instance = await LoadVRMAsync(\n                binary,\n                this.GetCancellationTokenOnDestroy());\n\n            var lipMorpher = new VRMLipMorpher(instance.Runtime.Expression);\n            lipAnimator = new FollowingLipAnimator(lipMorpher);\n\n            var eyelidFrames = ProbabilisticEyelidAnimationGenerator\n                .Generate(\n                    Eyelid.Both,\n                    blinkCount: 20\n                );\n\n            var eyelidMorpher = new VRMEyelidMorpher(instance.Runtime.Expression);\n            var eyelidAnimator = new SequentialEyelidAnimator(eyelidMorpher);\n            eyelidAnimationLoop = new LoopEyelidAnimator(eyelidAnimator, eyelidFrames);\n\n            var emotionMorpher = new VRMEmotionMorpher<BasicEmotion>(\n                instance.Runtime.Expression,\n                keyMap: new Dictionary<BasicEmotion, ExpressionKey>\n                {\n                    [BasicEmotion.Neutral] = ExpressionKey.Neutral,\n                    [BasicEmotion.Happy] = ExpressionKey.Happy,\n                    [BasicEmotion.Sad] = ExpressionKey.Sad,\n                    [BasicEmotion.Angry] = ExpressionKey.Angry,\n                    [BasicEmotion.Fearful] = ExpressionKey.Neutral,\n                    [BasicEmotion.Surprised] = ExpressionKey.Surprised,\n                    [BasicEmotion.Disgusted] = ExpressionKey.Neutral,\n                });\n            emotionAnimator = new ExclusiveFollowingEmotionAnimator<BasicEmotion>(\n                emotionMorpher,\n                followingTime: emotionFollowingTime);\n        }\n", "        private void Update()\n        {\n            lipAnimator?.Update();\n            emotionAnimator?.Update();\n        }\n\n        private void OnDestroy()\n        {\n            if (audioClip != null)\n            {\n                Destroy(audioClip);\n                audioClip = null;\n            }\n            eyelidAnimationLoop?.Dispose();\n        }\n", "            if (audioClip != null)\n            {\n                Destroy(audioClip);\n                audioClip = null;\n            }\n            eyelidAnimationLoop?.Dispose();\n        }\n\n        private static async UniTask<Vrm10Instance> LoadVRMAsync(\n            byte[] binaryData,\n            CancellationToken cancellationToken)\n        {\n            cancellationToken.ThrowIfCancellationRequested();\n\n            return await Vrm10.LoadBytesAsync(\n                bytes: binaryData,\n                canLoadVrm0X: true,\n                controlRigGenerationOption: ControlRigGenerationOption.None,\n                showMeshes: true,\n                awaitCaller: new RuntimeOnlyAwaitCaller(),\n                materialGenerator: null,\n                vrmMetaInformationCallback: null,\n                ct: cancellationToken\n            );\n        }\n\n        [ContextMenu(nameof(SynthesisSpeech))]", "        private static async UniTask<Vrm10Instance> LoadVRMAsync(\n            byte[] binaryData,\n            CancellationToken cancellationToken)\n        {\n            cancellationToken.ThrowIfCancellationRequested();\n\n            return await Vrm10.LoadBytesAsync(\n                bytes: binaryData,\n                canLoadVrm0X: true,\n                controlRigGenerationOption: ControlRigGenerationOption.None,\n                showMeshes: true,\n                awaitCaller: new RuntimeOnlyAwaitCaller(),\n                materialGenerator: null,\n                vrmMetaInformationCallback: null,\n                ct: cancellationToken\n            );\n        }\n\n        [ContextMenu(nameof(SynthesisSpeech))]", "        public void SynthesisSpeech()\n        {\n            SynthesisAsync(\n                    text,\n                    speakerID,\n                    this.GetCancellationTokenOnDestroy())\n                .Forget();\n        }\n\n        private async UniTask SynthesisAsync(\n            string text,\n            int speakerID,\n            CancellationToken cancellationToken)\n        {", "        private async UniTask SynthesisAsync(\n            string text,\n            int speakerID,\n            CancellationToken cancellationToken)\n        {\n            if (audioSource == null)\n            {\n                Debug.LogError(audioSource);\n                return;\n            }\n", "            if (lipAnimator == null)\n            {\n                return;\n            }\n\n            if (audioClip != null)\n            {\n                Destroy(audioClip);\n                audioClip = null;\n            }\n\n            audioSource.Stop();\n\n            await UniTask.SwitchToThreadPool();\n\n            var audioQuery = (await queryCreationPolicy.ExecuteAsync(\n                    async innerCancellationToken => await QueryCreationAPI.CreateQueryAsync(\n                        HttpClientPool.PooledClient,\n                        text: text,\n                        speaker: speakerID,\n                        coreVersion: null,\n                        cancellationToken: innerCancellationToken),\n                    cancellationToken)\n                ).Unwrap();\n\n            // Synthesize speech from AudioQuery by VOICEVOX synthesis API.\n            var stream = (await synthesisPolicy.ExecuteAsync(\n                    async innerCancellationToken => await SynthesisAPI.SynthesizeAsync(\n                        HttpClientPool.PooledClient,\n                        audioQuery: audioQuery,\n                        speaker: speakerID,\n                        enableInterrogativeUpspeak: null,\n                        coreVersion: null,\n                        cancellationToken: innerCancellationToken),\n                    cancellationToken)\n                ).Unwrap();\n", "            if (!skipSpeechSynthesis)\n            {\n                try\n                {\n                    // Decode WAV data to AudioClip by SimpleAudioCodec WAV decoder.\n                    audioClip = await WaveDecoder.DecodeBlockByBlockAsync(\n                        stream: stream,\n                        fileName: \"Synthesis.wav\",\n                        cancellationToken: cancellationToken);\n\n                    Debug.Log($\"[VOICEVOX_API.Samples] Succeeded to decode audio, \" +\n                              $\"samples:{audioClip.samples}, \" +\n                              $\"frequency:{audioClip.frequency}, \" +\n                              $\"channels:{audioClip.channels}, \" +\n                              $\"length:{audioClip.length}.\");\n                }", "                catch (Exception e)\n                {\n                    Debug.LogException(e);\n                    return;\n                }\n                finally\n                {\n                    await stream.DisposeAsync();\n                }\n\n                await UniTask.SwitchToMainThread(cancellationToken);\n\n                // Play AudioClip.\n                audioSource.clip = audioClip;\n                audioSource.PlayDelayed(0.1f);\n            }\n\n            var lipFrames = AudioQueryConverter\n                .ConvertToSequentialAnimationFrames(audioQuery);\n\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(0.1f),\n                cancellationToken: cancellationToken);\n\n            lipAnimator\n                .SetTargetAsync(lipFrames, cancellationToken)\n                .Forget();\n        }\n\n        [ContextMenu(nameof(Emote))]", "        public void Emote()\n        {\n            emotionAnimator?\n                .Emote(new EmotionSample<BasicEmotion>(\n                    basicEmotion,\n                    weight: emotionWeight));\n        }\n    }\n\n    // ReSharper disable once InconsistentNaming\n}\n"]}
{"filename": "Assets/Mochineko/FacialExpressions.Samples/VolumeBasedLipSyncSample.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.FacialExpressions.Blink;\nusing Mochineko.FacialExpressions.Emotion;\nusing Mochineko.FacialExpressions.Extensions.VRM;\nusing Mochineko.FacialExpressions.LipSync;", "using Mochineko.FacialExpressions.Extensions.VRM;\nusing Mochineko.FacialExpressions.LipSync;\nusing Mochineko.Relent.Resilience;\nusing Mochineko.Relent.UncertainResult;\nusing Mochineko.SimpleAudioCodec;\nusing Mochineko.VOICEVOX_API;\nusing Mochineko.VOICEVOX_API.QueryCreation;\nusing Mochineko.VOICEVOX_API.Synthesis;\nusing Newtonsoft.Json;\nusing UnityEngine;", "using Newtonsoft.Json;\nusing UnityEngine;\nusing UnityEngine.Assertions;\nusing UniVRM10;\nusing VRMShaders;\n\nnamespace Mochineko.FacialExpressions.Samples\n{\n    // ReSharper disable once InconsistentNaming\n    internal sealed class VolumeBasedLipSyncSample : MonoBehaviour\n    {\n        [SerializeField]", "    // ReSharper disable once InconsistentNaming\n    internal sealed class VolumeBasedLipSyncSample : MonoBehaviour\n    {\n        [SerializeField]\n        private string path = string.Empty;\n\n        [SerializeField]\n        private string text = string.Empty;\n\n        [SerializeField]\n        private int speakerID;\n\n        [SerializeField]\n        private AudioSource? audioSource = null;\n\n        [SerializeField]", "        private int speakerID;\n\n        [SerializeField]\n        private AudioSource? audioSource = null;\n\n        [SerializeField]\n        private bool skipSpeechSynthesis = false;\n\n        [SerializeField]\n        private BasicEmotion basicEmotion = BasicEmotion.Neutral;\n\n        [SerializeField]", "        private BasicEmotion basicEmotion = BasicEmotion.Neutral;\n\n        [SerializeField]\n        private float emotionWeight = 1f;\n\n        [SerializeField]\n        private float emotionFollowingTime = 1f;\n\n        [SerializeField]\n        private float volumeSmoothTime = 0.1f;\n\n        [SerializeField]", "        private float volumeSmoothTime = 0.1f;\n\n        [SerializeField]\n        private float volumeMultiplier = 1f;\n\n        private VolumeBasedLipAnimator? lipAnimator;\n        private IDisposable? eyelidAnimationLoop;\n        private ExclusiveFollowingEmotionAnimator<BasicEmotion>? emotionAnimator;\n        private AudioClip? audioClip;\n\n        private readonly IPolicy<AudioQuery> queryCreationPolicy\n            = PolicyFactory.BuildQueryCreationPolicy();\n", "        private readonly IPolicy<AudioQuery> queryCreationPolicy\n            = PolicyFactory.BuildQueryCreationPolicy();\n\n        private readonly IPolicy<Stream> synthesisPolicy\n            = PolicyFactory.BuildSynthesisPolicy();\n\n        private void Awake()\n        {\n            Assert.IsNotNull(audioSource);\n        }\n", "        private async void Start()\n        {\n            if (audioSource == null)\n            {\n                throw new NullReferenceException(nameof(audioSource));\n            }\n\n            VoiceVoxBaseURL.BaseURL = \"http://127.0.0.1:50021\";\n\n            var binary = await File.ReadAllBytesAsync(\n                path,\n                this.GetCancellationTokenOnDestroy());\n\n            var instance = await LoadVRMAsync(\n                binary,\n                this.GetCancellationTokenOnDestroy());\n\n            var lipMorpher = new VRMLipMorpher(instance.Runtime.Expression);\n            lipAnimator = new VolumeBasedLipAnimator(\n                lipMorpher,\n                Viseme.aa,\n                audioSource,\n                smoothTime: volumeSmoothTime,\n                volumeMultiplier: volumeMultiplier,\n                samplesCount: 1024);\n\n            var eyelidFrames = ProbabilisticEyelidAnimationGenerator.Generate(\n                Eyelid.Both,\n                blinkCount: 20);\n\n            var eyelidMorpher = new VRMEyelidMorpher(instance.Runtime.Expression);\n            var eyelidAnimator = new SequentialEyelidAnimator(eyelidMorpher);\n            eyelidAnimationLoop = new LoopEyelidAnimator(eyelidAnimator, eyelidFrames);\n\n            var emotionMorpher = new VRMEmotionMorpher<BasicEmotion>(\n                instance.Runtime.Expression,\n                keyMap: new Dictionary<BasicEmotion, ExpressionKey>\n                {\n                    [BasicEmotion.Neutral] = ExpressionKey.Neutral,\n                    [BasicEmotion.Happy] = ExpressionKey.Happy,\n                    [BasicEmotion.Sad] = ExpressionKey.Sad,\n                    [BasicEmotion.Angry] = ExpressionKey.Angry,\n                    [BasicEmotion.Fearful] = ExpressionKey.Neutral,\n                    [BasicEmotion.Surprised] = ExpressionKey.Surprised,\n                    [BasicEmotion.Disgusted] = ExpressionKey.Neutral,\n                });\n            emotionAnimator = new ExclusiveFollowingEmotionAnimator<BasicEmotion>(\n                emotionMorpher,\n                followingTime: emotionFollowingTime);\n        }\n", "        private void Update()\n        {\n            lipAnimator?.Update();\n            emotionAnimator?.Update();\n        }\n\n        private void OnDestroy()\n        {\n            if (audioClip != null)\n            {\n                Destroy(audioClip);\n                audioClip = null;\n            }\n            eyelidAnimationLoop?.Dispose();\n        }\n", "            if (audioClip != null)\n            {\n                Destroy(audioClip);\n                audioClip = null;\n            }\n            eyelidAnimationLoop?.Dispose();\n        }\n\n        private static async UniTask<Vrm10Instance> LoadVRMAsync(\n            byte[] binaryData,\n            CancellationToken cancellationToken)\n        {\n            cancellationToken.ThrowIfCancellationRequested();\n\n            return await Vrm10.LoadBytesAsync(\n                bytes: binaryData,\n                canLoadVrm0X: true,\n                controlRigGenerationOption: ControlRigGenerationOption.None,\n                showMeshes: true,\n                awaitCaller: new RuntimeOnlyAwaitCaller(),\n                materialGenerator: null,\n                vrmMetaInformationCallback: null,\n                ct: cancellationToken\n            );\n        }\n\n        [ContextMenu(nameof(SynthesisSpeech))]", "        private static async UniTask<Vrm10Instance> LoadVRMAsync(\n            byte[] binaryData,\n            CancellationToken cancellationToken)\n        {\n            cancellationToken.ThrowIfCancellationRequested();\n\n            return await Vrm10.LoadBytesAsync(\n                bytes: binaryData,\n                canLoadVrm0X: true,\n                controlRigGenerationOption: ControlRigGenerationOption.None,\n                showMeshes: true,\n                awaitCaller: new RuntimeOnlyAwaitCaller(),\n                materialGenerator: null,\n                vrmMetaInformationCallback: null,\n                ct: cancellationToken\n            );\n        }\n\n        [ContextMenu(nameof(SynthesisSpeech))]", "        public void SynthesisSpeech()\n        {\n            SynthesisAsync(\n                    text,\n                    speakerID,\n                    this.GetCancellationTokenOnDestroy())\n                .Forget();\n        }\n\n        private async UniTask SynthesisAsync(\n            string text,\n            int speakerID,\n            CancellationToken cancellationToken)\n        {", "        private async UniTask SynthesisAsync(\n            string text,\n            int speakerID,\n            CancellationToken cancellationToken)\n        {\n            if (audioSource == null)\n            {\n                Debug.LogError(audioSource);\n                return;\n            }\n", "            if (audioClip != null)\n            {\n                Destroy(audioClip);\n                audioClip = null;\n            }\n\n            audioSource.Stop();\n\n            await UniTask.SwitchToThreadPool();\n\n            AudioQuery audioQuery;\n            var createQueryResult = await queryCreationPolicy.ExecuteAsync(\n                async innerCancellationToken => await QueryCreationAPI.CreateQueryAsync(\n                    HttpClientPool.PooledClient,\n                    text: text,\n                    speaker: speakerID,\n                    coreVersion: null,\n                    cancellationToken: innerCancellationToken),\n                cancellationToken);", "            if (createQueryResult is IUncertainSuccessResult<AudioQuery> createQuerySuccess)\n            {\n                audioQuery = createQuerySuccess.Result;\n                Debug.Log(\n                    $\"[VOICEVOX_API.Samples] Succeeded to create query from text:{text} -> {JsonConvert.SerializeObject(audioQuery)}.\");\n            }\n            else if (createQueryResult is IUncertainRetryableResult<AudioQuery> createQueryRetryable)\n            {\n                Debug.LogError(\n                    $\"[VOICEVOX_API.Samples] Failed to create query because -> {createQueryRetryable.Message}.\");\n                return;\n            }", "            else if (createQueryResult is IUncertainFailureResult<AudioQuery> createQueryFailure)\n            {\n                Debug.LogError(\n                    $\"[VOICEVOX_API.Samples] Failed to create query because -> {createQueryFailure.Message}.\");\n                return;\n            }\n            else\n            {\n                throw new UncertainResultPatternMatchException(nameof(createQueryResult));\n            }\n\n            // Synthesize speech from AudioQuery by VOICEVOX synthesis API.\n            Stream stream;\n            var synthesisResult = await synthesisPolicy.ExecuteAsync(\n                async innerCancellationToken => await SynthesisAPI.SynthesizeAsync(\n                    HttpClientPool.PooledClient,\n                    audioQuery: audioQuery,\n                    speaker: speakerID,\n                    enableInterrogativeUpspeak: null,\n                    coreVersion: null,\n                    cancellationToken: innerCancellationToken),\n                cancellationToken);", "            if (synthesisResult is IUncertainSuccessResult<Stream> synthesisSuccess)\n            {\n                stream = synthesisSuccess.Result;\n                Debug.Log($\"[VOICEVOX_API.Samples] Succeeded to synthesis speech from text:{text}.\");\n            }\n            else if (synthesisResult is IUncertainRetryableResult<Stream> synthesisRetryable)\n            {\n                Debug.LogError(\n                    $\"[VOICEVOX_API.Samples] Failed to synthesis speech because -> {synthesisRetryable.Message}.\");\n                return;\n            }", "            else if (synthesisResult is IUncertainFailureResult<Stream> synthesisFailure)\n            {\n                Debug.LogError(\n                    $\"[VOICEVOX_API.Samples] Failed to synthesis speech because -> {synthesisFailure.Message}.\");\n                return;\n            }\n            else\n            {\n                throw new UncertainResultPatternMatchException(nameof(synthesisResult));\n            }\n", "            if (!skipSpeechSynthesis)\n            {\n                try\n                {\n                    // Decode WAV data to AudioClip by SimpleAudioCodec WAV decoder.\n                    audioClip = await WaveDecoder.DecodeBlockByBlockAsync(\n                        stream: stream,\n                        fileName: \"Synthesis.wav\",\n                        cancellationToken: cancellationToken);\n\n                    Debug.Log($\"[VOICEVOX_API.Samples] Succeeded to decode audio, \" +\n                              $\"samples:{audioClip.samples}, \" +\n                              $\"frequency:{audioClip.frequency}, \" +\n                              $\"channels:{audioClip.channels}, \" +\n                              $\"length:{audioClip.length}.\");\n                }", "                catch (Exception e)\n                {\n                    Debug.LogException(e);\n                    return;\n                }\n                finally\n                {\n                    await stream.DisposeAsync();\n                }\n\n                await UniTask.SwitchToMainThread(cancellationToken);\n\n                // Play AudioClip.\n                audioSource.clip = audioClip;\n                audioSource.PlayDelayed(0.1f);\n            }\n        }\n\n        [ContextMenu(nameof(Emote))]", "        public void Emote()\n        {\n            emotionAnimator?\n                .Emote(new EmotionSample<BasicEmotion>(\n                    basicEmotion,\n                    weight: emotionWeight));\n        }\n    }\n}\n"]}
