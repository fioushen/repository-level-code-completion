{"filename": "Assets/ZimGui/IMInput.cs", "chunked_list": ["\ufeffusing UnityEngine;\n\nnamespace ZimGui {\n    public enum FocusState {\n        NotFocus,\n        NewFocus,\n        Focus,\n    }\n\n    public static class IMInput {\n        public struct ModalWindowData {", "    public static class IMInput {\n        public struct ModalWindowData {\n            public bool IsActive;\n            public bool Activated;\n            public Vector2 BasePoint;\n            public int BaseID;\n        }\n\n        public static ModalWindowData ModalWindow;\n        static RayCaster _rayCaster = new RayCaster(16);\n        public static void Add(int id, Rect rect) => _rayCaster.Add(id, rect);", "        public static ModalWindowData ModalWindow;\n        static RayCaster _rayCaster = new RayCaster(16);\n        public static void Add(int id, Rect rect) => _rayCaster.Add(id, rect);\n        public static void Add(Rect rect) => _rayCaster.Add(CurrentID, rect);\n\n        public static void Init() {\n            ModalWindow = default;\n            _rayCaster.Clear();\n        }\n\n        public static string InputString {\n            get {", "        public static string InputString {\n            get {\n                if (_inputStringIsCalled) return _inputString;\n                _inputString = Input.inputString;\n                _inputStringIsCalled = false;\n                return _inputString;\n            }\n        }\n\n        static string _inputString;\n        static bool _inputStringIsCalled = false;", "        public static bool CanPush() => IsPointerDownActive | !IsPointerOn;\n        static bool _canPush;\n        public static void NewFrame(Vector2 pointerPos, bool pointerOn, bool pointerDown) {\n            CurrentID = 0;\n            FocusActivated = false;\n            _inputStringIsCalled = false;\n            IsPointerDownActive = IsPointerDown = pointerDown;\n            IsPointerActive = IsPointerOn = pointerOn;\n            _canPush = IsPointerDown | !IsPointerOn;\n            ModalWindow.Activated = false;\n            PointerPosition = pointerPos;", "            if (ModalWindow.IsActive) {\n                TargetID = -1;\n            }\n            else {\n                if (RetainFocus(pointerPos, pointerOn, pointerDown)) {\n                    TargetID = FocusID;\n                }\n                else {\n                    FocusID = -10;\n                    TargetID = _rayCaster.Raycast(pointerPos);\n                }\n\n                _rayCaster.Clear();\n            }\n        }\n", "        public static void EndFrame() {\n            ModalWindow.IsActive &= ModalWindow.Activated;\n            if (0 <= FocusID && !FocusActivated) FocusID = -1;\n        }\n\n        static bool RetainFocus(Vector2 pointerPos, bool pointerOn, bool pointerDown) {\n            if (FocusID < -1) return false;\n            if (FocusNeedMouse) {\n                if (!pointerOn) {\n                    FocusID = -10;\n                    return false;\n                }\n\n                return true;\n            }\n", "                if (!pointerOn) {\n                    FocusID = -10;\n                    return false;\n                }\n\n                return true;\n            }\n\n            if (pointerDown && !FocusRect.Contains(pointerPos)) {\n                FocusID = -10;\n                return false;\n            }\n\n            return true;\n        }\n", "            if (pointerDown && !FocusRect.Contains(pointerPos)) {\n                FocusID = -10;\n                return false;\n            }\n\n            return true;\n        }\n\n        public static FocusState GetModalWindowState(this Rect rect) {\n            if (ModalWindow.IsActive) {\n                if (ModalWindow.BaseID != CurrentID) return FocusState.NotFocus;", "        public static FocusState GetModalWindowState(this Rect rect) {\n            if (ModalWindow.IsActive) {\n                if (ModalWindow.BaseID != CurrentID) return FocusState.NotFocus;\n                if (!rect.Contains(ModalWindow.BasePoint)) {\n                    return FocusState.NotFocus;\n                }\n\n                ModalWindow.Activated = true;\n                return FocusState.Focus;\n            }\n            else {", "                if (!IsPointerDownActive || !ContainsActiveMouseDown(rect)) return FocusState.NotFocus;\n                IsPointerDownActive = false;\n                IsPointerActive = false;\n                ModalWindow.Activated = true;\n                ModalWindow.IsActive = true;\n                ModalWindow.BasePoint = rect.center;\n                ModalWindow.BaseID = CurrentID;\n                TargetID = -1;\n                return FocusState.NewFocus;\n            }\n        }\n", "        public static void CloseModalWindow() {\n            ModalWindow = default;\n            FocusID = -10;\n        }\n\n        public static bool IsFocusActive(this Rect rect, bool focusNeedMouse = true) {\n            if (TargetID != CurrentID || FocusActivated) return false;\n            if (focusNeedMouse && !(IsPointerDownActive || IsPointerActive)) return false;\n            if (FocusID == CurrentID) {\n                if (!rect.Contains(FocusPosition)) return false;\n                IsPointerDownActive = false;\n                IsPointerActive = false;\n                FocusPosition = rect.center;", "            if (FocusID == CurrentID) {\n                if (!rect.Contains(FocusPosition)) return false;\n                IsPointerDownActive = false;\n                IsPointerActive = false;\n                FocusPosition = rect.center;\n                if (!focusNeedMouse) FocusRect = rect;\n                FocusActivated = true;\n                return true;\n            }\n\n            if (-1 <= FocusID || !ContainsActiveMouseDown(rect)) return false;\n            IsPointerDownActive = false;\n            IsPointerActive = false;\n            FocusPosition = rect.center;", "            if (-1 <= FocusID || !ContainsActiveMouseDown(rect)) return false;\n            IsPointerDownActive = false;\n            IsPointerActive = false;\n            FocusPosition = rect.center;\n            if (!focusNeedMouse) FocusRect = rect;\n            FocusNeedMouse = focusNeedMouse;\n            FocusActivated = true;\n            FocusID = CurrentID;\n            return true;\n        }\n", "        public static FocusState GetFocusState(this Rect rect, bool focusNeedMouse = true) {\n            if (TargetID != CurrentID || FocusActivated) return FocusState.NotFocus;\n            if (focusNeedMouse && !(IsPointerDownActive || IsPointerActive)) return FocusState.NotFocus;\n            if (FocusID == CurrentID) {\n                if (!rect.Contains(FocusPosition)) return FocusState.NotFocus;\n                IsPointerDownActive = false;\n                IsPointerActive = false;\n                FocusPosition = rect.center;\n                FocusRect = rect;\n                FocusActivated = true;\n                return FocusState.Focus;\n            }\n", "            if (-1 <= FocusID || !ContainsActiveMouseDown(rect)) return FocusState.NotFocus;\n            IsPointerDownActive = false;\n            IsPointerActive = false;\n            FocusPosition = rect.center;\n            FocusRect = rect;\n            FocusNeedMouse = focusNeedMouse;\n            FocusActivated = true;\n            FocusID = CurrentID;\n            IsPointerActive = false;\n            return FocusState.NewFocus;\n        }\n", "        public static void LoseFocus() {\n            FocusID = -10;\n        }\n\n        public static bool IsFocusActive(Vector2 center, float radius, bool focusNeedMouse = true) {\n            if (TargetID != CurrentID || FocusActivated) return false;\n            if (focusNeedMouse && !(IsPointerDownActive || IsPointerActive)) return false;\n            if (FocusID == CurrentID) {\n                if (radius * radius < (FocusPosition - center).sqrMagnitude) return false;\n                IsPointerDownActive = false;\n                IsPointerActive = false;\n                FocusPosition = center;", "                if (radius * radius < (FocusPosition - center).sqrMagnitude) return false;\n                IsPointerDownActive = false;\n                IsPointerActive = false;\n                FocusPosition = center;\n                if (!focusNeedMouse) FocusRect = new Rect(center.x - radius, center.y - radius, 2 * radius, 2 * radius);\n                FocusActivated = true;\n                return true;\n            }\n\n            if (-1 <= FocusID || !CircleContainsActiveMouseDown(center, radius)) return false;\n            IsPointerDownActive = false;\n            IsPointerActive = false;\n            FocusPosition = center;", "            if (-1 <= FocusID || !CircleContainsActiveMouseDown(center, radius)) return false;\n            IsPointerDownActive = false;\n            IsPointerActive = false;\n            FocusPosition = center;\n            if (!focusNeedMouse) FocusRect = new Rect(center.x - radius, center.y - radius, 2 * radius, 2 * radius);\n            FocusNeedMouse = focusNeedMouse;\n            FocusActivated = true;\n            FocusID = CurrentID;\n            return true;\n        }\n", "        public static bool ContainsActiveMouse(this Rect rect) {\n            return TargetID == CurrentID && rect.Contains(PointerPosition);\n        }\n        \n        public static bool CanPush(this Rect rect) {\n            return _canPush&& TargetID == CurrentID && rect.Contains(PointerPosition);\n        }\n\n        public static bool ContainsActiveMouseDown(this Rect rect) {\n            return IsPointerDownActive && TargetID == CurrentID && rect.Contains(PointerPosition);\n        }\n", "        public static bool ContainsActiveMouseDown(this Rect rect) {\n            return IsPointerDownActive && TargetID == CurrentID && rect.Contains(PointerPosition);\n        }\n\n        public static bool ContainsMouse(this Rect rect) {\n            return rect.Contains(PointerPosition);\n        }\n\n        public static bool CircleContainsActiveMouse(Vector2 center, float radius) {\n            if (!IsPointerActive || TargetID != CurrentID) return false;\n            return ((PointerPosition - center).sqrMagnitude < radius * radius);\n        }\n", "        public static bool CircleContainsActiveMouse(Vector2 center, float radius) {\n            if (!IsPointerActive || TargetID != CurrentID) return false;\n            return ((PointerPosition - center).sqrMagnitude < radius * radius);\n        }\n\n        public static bool CircleContainsActiveMouseDown(Vector2 center, float radius) {\n            return IsPointerDownActive && TargetID == CurrentID &&\n                   ((PointerPosition - center).sqrMagnitude < radius * radius);\n        }\n\n        public static int TargetID;", "        public static int TargetID;\n        public static int CurrentID;\n        public static Vector2 FocusPosition;\n        public static Rect FocusRect;\n        public static Vector2 PointerPosition;\n        public static bool FocusNeedMouse;\n        public static int FocusID;\n        public static bool FocusActivated;\n        public static bool IsPointerDown;\n        public static bool IsPointerOn;\n        public static bool IsPointerActive;", "        public static bool IsPointerDown;\n        public static bool IsPointerOn;\n        public static bool IsPointerActive;\n        public static bool IsPointerDownActive;\n    }\n}"]}
{"filename": "Assets/ZimGui/RayCaster.cs", "chunked_list": ["\ufeffusing System;\nusing UnityEngine;\n\nnamespace ZimGui {\n    public struct RayCaster {\n        public Rect[] Rects;\n        public int[] TargetID;\n        public int Count;\n\n        public RayCaster(int capacity) {\n            Rects = new Rect[capacity];\n            TargetID = new int[capacity];\n            Count = 0;\n        }\n", "        public void Add(int id, Rect rect) {\n            if (Count == Rects.Length) {\n                Array.Resize(ref Rects ,Count*2);\n                Array.Resize(ref TargetID ,Count*2);\n            }\n            Rects[Count] = rect;\n            TargetID[Count] = id;\n            Count++;\n        } \n        public void Add(RayCaster child) {\n            for (int i = 0; i < child.Count; i++) {\n                Add(child.TargetID[i],child.Rects[i]);\n            }\n        }", "        public void Add(RayCaster child) {\n            for (int i = 0; i < child.Count; i++) {\n                Add(child.TargetID[i],child.Rects[i]);\n            }\n        }\n        public void Clear() {\n            Rects.AsSpan(0,Count).Clear();\n            TargetID.AsSpan(0,Count).Clear();\n            Count = 0;\n        }\n        public int Raycast(Vector2 v) {\n            var rects = Rects;", "        public int Raycast(Vector2 v) {\n            var rects = Rects;\n            for (int i = Count-1; 0<=i; --i) {\n                if (rects[i].Contains(v)) {\n                    return TargetID[i];\n                }\n            }\n            return -1;\n        }\n    }\n}"]}
{"filename": "Assets/ZimGui/Formatters.cs", "chunked_list": ["\ufeffusing System;\nusing ZimGui.Core;\nusing UnityEngine;\nusing UnityEngine.Profiling;\n\nnamespace ZimGui {\n   \n    public interface IFormatter<in T> {\n        public bool TryFormat(T value,Span<char> text, out int charsWritten);\n    }\n", "        public bool TryFormat(T value,Span<char> text, out int charsWritten);\n    }\n\n    public struct Vector2Formatter : IFormatter<Vector2> {\n        public bool TryFormat(Vector2 value, Span<char> text, out int charsWritten) {\n            try {\n                text[0] = '(';\n                var offset = 1;\n                value.x.Format(ref offset,text);\n                text[offset++] = ',';\n                value.y.Format(ref offset,text);\n                text[offset++] = ')';\n                charsWritten = offset;\n                return true;\n            }", "            catch (Exception) { \n                charsWritten = 0;\n                return false;\n            }\n        }\n    }\n    public struct Vector3Formatter : IFormatter<Vector3> {\n        public bool TryFormat(Vector3 value, Span<char> text, out int charsWritten) {\n            try {\n                text[0] = '(';\n                var offset = 1;\n                value.x.Format(ref offset,text);\n                text[offset++] = ',';\n                value.y.Format(ref offset,text);\n                text[offset++] = ',';\n                value.z.Format(ref offset,text);\n                text[offset++] = ')';\n                charsWritten = offset;\n                return true;\n            }", "            try {\n                text[0] = '(';\n                var offset = 1;\n                value.x.Format(ref offset,text);\n                text[offset++] = ',';\n                value.y.Format(ref offset,text);\n                text[offset++] = ',';\n                value.z.Format(ref offset,text);\n                text[offset++] = ')';\n                charsWritten = offset;\n                return true;\n            }", "            catch (Exception) { \n                charsWritten = 0;\n                return false;\n            }\n        }\n    }\n}"]}
{"filename": "Assets/ZimGui/InputFieldData.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing UnityEngine;\n\nnamespace ZimGui {\n    public struct InputFieldData {\n         public int Length;\n         public int CaretPosition;\n         public  float FocusTime;\n         //public bool IsDelayed;\n         // public InputFieldData(int length,bool isDelayed) {\n         //     Length = length;\n         //     CaretPosition = 0;\n         //     FocusTime = 0;\n         //     IsDelayed = isDelayed;\n         // }\n    }\n  \n}", "         public  float FocusTime;\n         //public bool IsDelayed;\n         // public InputFieldData(int length,bool isDelayed) {\n         //     Length = length;\n         //     CaretPosition = 0;\n         //     FocusTime = 0;\n         //     IsDelayed = isDelayed;\n         // }\n    }\n  \n}"]}
{"filename": "Assets/ZimGui/RotationHint.cs", "chunked_list": ["\ufeffusing System;\nusing System.Runtime.CompilerServices;\nusing UnityEngine;\n\nnamespace ZimGui {\n\n    public  struct EulerHint {\n        public Quaternion Rotation {\n            get=> _rotation;\n            set => GetEulerAngles(value);\n        }\n        Quaternion _rotation;", "        public Vector3 EulerAngles{\n            get=> _eulerAngles;\n            set { \n                _rotation=Quaternion.Euler(value);\n                _eulerAngles = value;\n            }\n        }\n        Vector3 _eulerAngles;\n        public EulerHint(Vector3 eulerAngles) {\n            _rotation=Quaternion.Euler(eulerAngles);\n            _eulerAngles = eulerAngles;\n        }\n        \n        \n        ", "        public  Vector3 GetLocalEulerAngles(Transform t) {\n            var q = t.localRotation;\n            if (Rotation == q) return _eulerAngles;\n            _rotation = q;\n            var newEuler =q.eulerAngles;\n            newEuler.x = RepeatWorking(newEuler.x - _eulerAngles.x + 180.0F, 360.0F) + _eulerAngles.x - 180.0F;\n            newEuler.y = RepeatWorking(newEuler.y - _eulerAngles.y + 180.0F, 360.0F) + _eulerAngles.y - 180.0F;\n            newEuler.z = RepeatWorking(newEuler.z - _eulerAngles.z + 180.0F, 360.0F) + _eulerAngles.z - 180.0F;\n            _eulerAngles = newEuler;\n            return  newEuler;\n        }", "        public  Vector3 GetEulerAngles(Quaternion q) {\n            if (Rotation == q) return _eulerAngles;\n            _rotation = q;\n            var newEuler =q.eulerAngles;\n            newEuler.x = RepeatWorking(newEuler.x - _eulerAngles.x + 180.0F, 360.0F) + _eulerAngles.x - 180.0F;\n            newEuler.y = RepeatWorking(newEuler.y - _eulerAngles.y + 180.0F, 360.0F) + _eulerAngles.y - 180.0F;\n            newEuler.z = RepeatWorking(newEuler.z - _eulerAngles.z + 180.0F, 360.0F) + _eulerAngles.z - 180.0F;\n            _eulerAngles = newEuler;\n            return  newEuler;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static float RepeatWorking (float t, float length)\n        {\n            return (t - (Mathf.Floor(t / length) * length));\n        }\n    }\n}"]}
{"filename": "Assets/ZimGui/DockWindow.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing Unity.Collections;\nusing UnityEngine;\n\nnamespace ZimGui {\n    public class DockWindow {\n        List<string> _names = new (16);\n        List<WObject> _activeWObjects = new (16);\n        public int Index;\n        public bool Opened = true;", "        public int Index;\n        public bool Opened = true;\n        public void Add(WObject wObject) {\n            _activeWObjects.Add(wObject);\n        }\n        public void Clear() {\n            Index = -1;\n            _activeWObjects.Clear();\n            _names.Clear();\n        }\n", "        public static KeyCode OpenKey=KeyCode.Escape;\n        public void Draw() {\n            var lockPosition = false;\n            if (Input.GetKeyDown(OpenKey)) {\n                Opened = true;\n                lockPosition = true;\n            }\n            foreach (var _ in IM.BeginWindow(\"Dock\",new Rect(0,0,100,100),ref Opened,!lockPosition,Coordinate.TopLeft)) {\n                for (var i = 0; i < _activeWObjects.Count; i++) {\n                    var o = _activeWObjects[i];\n                    var remove = false;", "                for (var i = 0; i < _activeWObjects.Count; i++) {\n                    var o = _activeWObjects[i];\n                    var remove = false;\n                    if (!IM.Current.TryGetNextRect(out var rect)) {\n                        return;\n                    };\n                    var foldWidth = rect.width - IMStyle.SpacedTextHeight;\n                    var  foldRect = new Rect(rect.xMin, rect.yMin,foldWidth, rect.height);\n                    var buttonRect = new Rect(rect.xMin + foldWidth, rect.yMin, IMStyle.SpacedTextHeight, rect.height);\n                    if (IM.Button(buttonRect, \"-\")) {\n                        _activeWObjects.RemoveAt(i);\n                        IM.WObjects.Add(o);\n                        o.Opened = false;\n                        break;\n                    }", "                    if (IM.Button(buttonRect, \"-\")) {\n                        _activeWObjects.RemoveAt(i);\n                        IM.WObjects.Add(o);\n                        o.Opened = false;\n                        break;\n                    }\n                    if (!IM.Foldout(foldRect, o.Name, o.Opened)) {\n                        o.Opened=false;\n                        continue;\n                    }\n                    using (IM.Indent()) {", "                    using (IM.Indent()) {\n                        if (! o.DrawAsElement()) {\n                                remove = true;\n                        }\n                    }\n                    if (remove) {\n                        _activeWObjects.RemoveAtSwapBack(Index);\n                        break;\n                    }\n                    o.Opened=true;\n                }\n                _names.Clear();", "                foreach (var w in IM.WObjects) {\n                    _names.Add(w.Name);\n                    \n                }\n                if (IM.InputDropdownButton(\"Add\", _names, ref Index)) {\n                    _activeWObjects.Add( IM.WObjects[Index]);\n                    IM.WObjects.RemoveAt(Index);\n                }\n                if (IM.InputDropdownButton(\"Open\", _names, ref Index)) {\n                    var w = IM.WObjects[Index];\n                   w.Opened = true;\n                   var mousePos = IMInput.PointerPosition;\n                   w.Rect = new Rect(mousePos.x-50, mousePos.y-100+IMStyle.SpacedTextHeight/2, 100, 100);\n                }\n                \n                \n            }\n        }\n    }\n}", "                if (IM.InputDropdownButton(\"Open\", _names, ref Index)) {\n                    var w = IM.WObjects[Index];\n                   w.Opened = true;\n                   var mousePos = IMInput.PointerPosition;\n                   w.Rect = new Rect(mousePos.x-50, mousePos.y-100+IMStyle.SpacedTextHeight/2, 100, 100);\n                }\n                \n                \n            }\n        }\n    }\n}"]}
{"filename": "Assets/ZimGui/TextureDrawer.cs", "chunked_list": ["\ufeffusing System;\nusing UnityEngine;\n\nnamespace ZimGui {\n    public class TextureDrawer : MonoBehaviour {\n        public Texture Texture1;\n        public Texture Texture2;\n        public Texture Texture3;\n        public Rect Rect1;\n        public Rect Rect2;\n        public Rect Rect3;\n\n       \n        void Update() {\n            IM.DrawTexture(Rect1,Texture1);\n            IM.DrawTexture(Rect2,Texture2);\n            IM.DrawTexture(Rect3,Texture3);\n        }\n        \n        \n        \n        //\n        // void OnDestroy() {\n        //     _textureMesh.Dispose();\n        // }\n    }\n}", "        public Rect Rect1;\n        public Rect Rect2;\n        public Rect Rect3;\n\n       \n        void Update() {\n            IM.DrawTexture(Rect1,Texture1);\n            IM.DrawTexture(Rect2,Texture2);\n            IM.DrawTexture(Rect3,Texture3);\n        }\n        \n        \n        \n        //\n        // void OnDestroy() {\n        //     _textureMesh.Dispose();\n        // }\n    }\n}"]}
{"filename": "Assets/ZimGui/WindowState.cs", "chunked_list": ["\ufeffusing System;\n\nnamespace ZimGui {\n   \n    public readonly struct WindowState:IDisposable {\n        public readonly bool IsActive;\n        public WindowState(bool isActive) {\n            IsActive = isActive;\n        }\n        \n        public void Dispose() {", "        public void Dispose() {\n           if(IsActive)IM.EndWindow();\n        }\n\n        public static bool operator true(WindowState state) => state.IsActive;\n\n        public static bool operator false(WindowState state) => !state.IsActive ;\n\n        public Enumerator GetEnumerator() { \n            return new Enumerator(this);\n        }\n      ", "        public Enumerator GetEnumerator() { \n            return new Enumerator(this);\n        }\n      \n        public struct Enumerator:IDisposable {\n            public bool DoOnce;\n            public bool  IsActive;\n\n            public Enumerator(WindowState state) {\n                DoOnce = state.IsActive;\n                IsActive = state.IsActive;\n            }", "            public bool Current => true;\n            public bool MoveNext() {\n                if (!DoOnce) return false;\n                DoOnce = false;\n                return true;\n            }\n            public void Dispose() {\n                if(IsActive)IM.EndWindow();\n            }\n        }\n    }\n    \n}"]}
{"filename": "Assets/ZimGui/TempStates.cs", "chunked_list": ["\ufeffusing System;\n\nnamespace ZimGui {\n    public struct DisposableIndent:IDisposable  {\n        public void Dispose() {\n            IMStyle.IndentLevel--;\n        }\n    }\n    \n    \n    public readonly struct DisposableDivision:IDisposable {", "    public readonly struct DisposableDivision:IDisposable {\n        public readonly int LastDivisions;\n        public DisposableDivision(int lastDivisions) {\n            LastDivisions = lastDivisions;\n        }\n        \n        public void Dispose() {\n            IMStyle.HorizontalDivisions=LastDivisions;\n            IMStyle.HorizontalDivisionsProgress=0;\n        }\n    }\n    \n    \n    \n}"]}
{"filename": "Assets/ZimGui/IM.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Reflection;\nusing ZimGui.Core;\nusing ZimGui.Text;\nusing Unity.Collections.LowLevel.Unsafe;\nusing UnityEngine;\nusing UnityEngine.PlayerLoop;\nusing UnityEngine.Profiling;\nusing Str = System.ReadOnlySpan<char>;", "using UnityEngine.Profiling;\nusing Str = System.ReadOnlySpan<char>;\n\nnamespace ZimGui {\n    public static class IMStyle {\n        public static UiColor BasicColor = UiColor.White;\n        public static UiColor WindowLabelLeftColor = UiColor.Black;\n        public static UiColor WindowLabelRightColor = UiColor.Cyan;\n        public static UiColor WindowBackGroundColor = new UiColor(56, 56, 56, 180);\n\n        public static UiColor WindowLabelColor {\n            set {\n                WindowLabelLeftColor = value;\n                WindowLabelRightColor = value;\n            }\n        }\n", "        public static UiColor WindowBackGroundColor = new UiColor(56, 56, 56, 180);\n\n        public static UiColor WindowLabelColor {\n            set {\n                WindowLabelLeftColor = value;\n                WindowLabelRightColor = value;\n            }\n        }\n\n        public static UiColor FontColor = UiColor.White;\n        public static UiColor ButtonColor = new UiColor(30, 30, 30, 150);", "        public static UiColor FontColor = UiColor.White;\n        public static UiColor ButtonColor = new UiColor(30, 30, 30, 150);\n        public static UiColor FieldColor = new UiColor(30, 30, 30, 255);\n        public static UiColor HoveredButtonColor = new UiColor(150, 150, 150, 150);\n        public static UiColor UnHoveredButtonColor = new UiColor(100, 100, 100, 150);\n        public static float FontSize = 20;\n        public static float LabelWidth => FontSize * 7.5f;\n        public static float LineSpaceRatio = 1.4f;\n\n        public static string FloatFormat = \"F2\";\n        public static float SpacedTextHeight => FontSize * LineSpaceRatio;\n", "        public static string FloatFormat = \"F2\";\n        public static float SpacedTextHeight => FontSize * LineSpaceRatio;\n\n        public static float DragNumberScale = 1f;\n        public static int IndentLevel = 0;\n\n\n        public static int HorizontalDivisions=1;\n        public static int HorizontalDivisionsProgress=0;\n    }\n", "        public static int HorizontalDivisionsProgress=0;\n    }\n\n    public struct NewFrame {\n    }\n\n    public struct EndFrame {\n    }\n\n    public static class IM {\n        static Window _screenWindow;", "    public static class IM {\n        static Window _screenWindow;\n        public static readonly Dictionary<string, Window> WindowDict = new Dictionary<string, Window>();\n        public static Window Current;\n        public static Rect ScreenRect;\n        public static Vector2 ScreenDeltaMousePos = new Vector2(0, 0);\n        public static Vector2 ScreenMousePos = new Vector2(0, 0);\n        public static bool GetLeftArrowKey => Input.GetKey(KeyCode.LeftArrow);\n        public static bool GetLeftArrowKeyDown => Input.GetKeyDown(KeyCode.LeftArrow);\n        public static bool GetRightArrowKey => Input.GetKey(KeyCode.RightArrow);\n        public static bool GetRightArrowKeyDown => Input.GetKeyDown(KeyCode.RightArrow);\n", "        public static bool GetLeftArrowKeyDown => Input.GetKeyDown(KeyCode.LeftArrow);\n        public static bool GetRightArrowKey => Input.GetKey(KeyCode.RightArrow);\n        public static bool GetRightArrowKeyDown => Input.GetKeyDown(KeyCode.RightArrow);\n\n        public static UiMesh Mesh;\n\n        public static Camera Camera;\n\n        static Range _popUpRange;\n\n        public static bool IsInModalWindow;\n\n", "        public static bool IsInModalWindow;\n\n\n        public readonly struct ModalWindowArea : IDisposable {\n            public readonly int StartIndex;\n            public readonly int WindowID;\n\n            ModalWindowArea(int startIndex) {\n                StartIndex = startIndex;\n                IsInModalWindow = true;\n                WindowID = IMInput.CurrentID;\n                IMInput.CurrentID = -1;\n            }\n", "            public static ModalWindowArea New() {\n                if (IsInModalWindow) throw new Exception();\n                return new ModalWindowArea(Mesh.Length);\n            }\n\n            void IDisposable.Dispose() {\n                IMInput.CurrentID = WindowID;\n                _popUpRange = StartIndex..Mesh.Length;\n                IsInModalWindow = false;\n            }\n        }\n", "        public static Rect GetPadded(ref this Rect rect, float padding) =>\n            new(rect.x - padding, rect.y - padding, rect.width + 2 * padding, rect.height + 2 * padding);\n\n        public static void Move(ref this Rect rect, Vector2 delta) {\n            ref var min = ref UnsafeUtility.As<Rect, Vector2>(ref rect);\n            min += delta;\n        }\n\n        public static void MoveX(ref this Rect rect, float delta) {\n            ref var min = ref UnsafeUtility.As<Rect, float>(ref rect);\n            min += delta;\n        }\n", "        public static void MoveX(ref this Rect rect, float delta) {\n            ref var min = ref UnsafeUtility.As<Rect, float>(ref rect);\n            min += delta;\n        }\n\n        public static void MoveY(ref this Rect rect, float delta) {\n            ref var min = ref UnsafeUtility.As<Rect, Vector2>(ref rect);\n            min.y += delta;\n        }\n\n        public static bool DivideToLabelAndValue(ref this Rect rect, out Rect labelRect, out Rect valueRect) {\n            var labelWidth = IMStyle.LabelWidth;", "        public static bool DivideToLabelAndValue(ref this Rect rect, out Rect labelRect, out Rect valueRect) {\n            var labelWidth = IMStyle.LabelWidth;\n            if (rect.width < labelWidth) {\n                labelRect = new Rect(rect.xMin, rect.yMin, rect.width, rect.height);\n                valueRect = default;\n                return false;\n            }\n\n            labelRect = new Rect(rect.xMin, rect.yMin, labelWidth, rect.height);\n            valueRect = new Rect(rect.xMin + labelWidth, rect.yMin, rect.width - labelWidth, rect.height);\n            return true;\n        }\n", "        public static bool TryDivide(ref this Rect rect, float labelWidth, out Rect labelRect,\n            out Rect valueRect) {\n            if (rect.width < labelWidth) {\n                labelRect = new Rect(rect.xMin, rect.yMin, rect.width, rect.height);\n                valueRect = default;\n                return false;\n            }\n\n            labelRect = new Rect(rect.xMin, rect.yMin, labelWidth, rect.height);\n            valueRect = new Rect(rect.xMin + labelWidth, rect.yMin, rect.width - labelWidth, rect.height);\n            return true;\n        }\n       \n", "        public static bool TryConsumeLeftMouseDown() {\n            if (IMInput.IsPointerDownActive) {\n                IMInput.IsPointerDownActive = false;\n                IMInput.IsPointerActive = false;\n                return true;\n            }\n\n            return false;\n        }\n\n", "        public static char[] ScratchBuffer = new char[1024];\n        static int frame;\n\n        public static void Init(UiMesh mesh,\n            Camera camera) {\n            Window.Init();\n            _screenWindow = new Window();\n            Mesh = mesh;\n            Camera = camera;\n            IMInput.Init();\n            _integratedWindow.Opened = true;\n        }\n\n", "        public static void Dispose() {\n            WindowDict.Clear();\n            WObjects.Clear();\n            _integratedWindow.Clear();\n            OnNewFrame = null;\n            OnEndFrame = null;\n            Mesh?.Dispose();\n            Mesh = null;\n            PlayerLoopInserter.RemoveRunner(typeof(NewFrame), typeof(EndFrame));\n        }\n", "        public static void InsertNewFrameToPostEarlyUpdate() {\n            PlayerLoopInserter.InsertSystem(typeof(NewFrame), typeof(EarlyUpdate),\n                InsertType.After, NewFrame);\n        }\n\n        public static void InsertEndFrameToPrePostLateUpdate() {\n            PlayerLoopInserter.InsertSystem(typeof(EndFrame), typeof(PostLateUpdate),\n                InsertType.Before, EndFrame);\n        }\n\n        public static bool TryGetPaste(out string text) {", "        public static bool TryGetPaste(out string text) {\n            if ((Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl)) &&\n                Input.GetKeyDown(KeyCode.V)) {\n                text = GUIUtility.systemCopyBuffer;\n                return true;\n            }\n\n            text = \"\";\n            return false;\n        }\n", "        public static event Action OnNewFrame;\n        public static event Action OnEndFrame;\n        public static void RequestResizeCursor() => _resizeCursorNeeded = true;\n\n        public static Texture2D ResizeCursor;\n        static bool _useResizeCursor;\n        static bool _resizeCursorNeeded;\n        public static Texture2D LRCursor;\n        static bool _useLRCursor;\n        static bool _LRCursorNeeded;\n\n        static DockWindow _integratedWindow = new DockWindow();", "        public static void Add(string name, Func<bool> func) => WObjects.Add(new WObject(name, func));\n\n        public static void NewFrame() {\n            if (Mesh == null) return;\n            var currentFrame = Time.frameCount;\n            if (frame != currentFrame) {\n                frame = currentFrame;\n                IMInput.NewFrame(Input.mousePosition, Input.GetMouseButton(0), Input.GetMouseButtonDown(0));\n                var pos = Input.mousePosition;\n                ScreenRect = new Rect(0, 0, Screen.width, Screen.height);\n                _screenWindow.Rect = ScreenRect;\n                _screenWindow.ResetNext();\n                Current = _screenWindow;\n                var newScreenMousePos = new Vector2(pos.x, pos.y);\n\n                ScreenDeltaMousePos = newScreenMousePos - ScreenMousePos;\n                ScreenMousePos = newScreenMousePos;\n                _popUpRange = default;\n                _resizeCursorNeeded = false;\n                _LRCursorNeeded = false;", "                try {\n                    OnNewFrame?.Invoke();\n                    _integratedWindow.Draw();\n                    _wObjectsCopy.Clear();\n                    foreach (var w in WObjects) {\n                        if(w.Opened)\n                            _wObjectsCopy.Add(w);\n                    }\n                    foreach (var w in _wObjectsCopy) {\n                        if (! w.DrawAsWindow()) {\n                            WObjects.Remove(w);\n                        }\n                    }\n                    \n                }", "                    foreach (var w in _wObjectsCopy) {\n                        if (! w.DrawAsWindow()) {\n                            WObjects.Remove(w);\n                        }\n                    }\n                    \n                }\n                catch (Exception e) {\n                    Debug.LogException(e);\n                }\n            }\n        }", "        public static List<WObject> WObjects = new (16);\n        static List<WObject> _wObjectsCopy = new (16);\n       \n        public static void EndFrame() {\n            try {\n                OnEndFrame?.Invoke();\n            }\n            catch (Exception e) {\n                Debug.LogException(e);\n            }\n\n            IMInput.EndFrame();", "            if (_resizeCursorNeeded && !_useResizeCursor) {\n                Cursor.SetCursor(ResizeCursor, new Vector2(8, 8), CursorMode.Auto);\n                _useResizeCursor = true;\n            }\n            else if (_LRCursorNeeded && !_useLRCursor) {\n                Cursor.SetCursor(LRCursor, new Vector2(8, 8), CursorMode.Auto);\n                _useLRCursor = true;\n            }\n            else if ((_useResizeCursor && !_resizeCursorNeeded) || _useLRCursor && !_LRCursorNeeded) {\n                _useResizeCursor = false;\n                _useLRCursor = false;\n                Cursor.SetCursor(null, new Vector2(8, 8), CursorMode.Auto);\n            }\n\n            var mesh = Mesh;", "            else if ((_useResizeCursor && !_resizeCursorNeeded) || _useLRCursor && !_LRCursorNeeded) {\n                _useResizeCursor = false;\n                _useLRCursor = false;\n                Cursor.SetCursor(null, new Vector2(8, 8), CursorMode.Auto);\n            }\n\n            var mesh = Mesh;\n            if (_popUpRange.End.Value != 0) {\n                mesh.SetDeferred(_popUpRange);\n            }\n", "            if (mesh != null) {\n                if (mesh.Build()) {\n                    mesh.Draw();\n                }\n\n                mesh.Clear();\n            }\n        }\n\n        public static Rect TopLeftToBottomLeftCoordinate(this Rect rect) {\n            var screenHeight = ScreenRect.height;\n            return new Rect(rect.xMin, screenHeight - rect.yMax, rect.width, rect.height);\n        }\n", "        public static Rect TopLeftToBottomLeftCoordinate(this Rect rect) {\n            var screenHeight = ScreenRect.height;\n            return new Rect(rect.xMin, screenHeight - rect.yMax, rect.width, rect.height);\n        }\n\n        public static WindowState BeginWindow(string name, Rect rect, bool firstTimeOnly = true,\n            Coordinate coordinate = Coordinate.BottomLeft) {\n            if (coordinate == Coordinate.TopLeft) {\n                rect = rect.TopLeftToBottomLeftCoordinate();\n            }\n            if (!WindowDict.TryGetValue(name, out Current)) {\n                Current = new Window(name, rect);\n                WindowDict.Add(name, Current);\n            }", "            if (!WindowDict.TryGetValue(name, out Current)) {\n                Current = new Window(name, rect);\n                WindowDict.Add(name, Current);\n            }\n            else if (!firstTimeOnly) {\n                Current.Rect = rect;\n            }\n            IMInput.CurrentID = Current.WindowID;\n            if (Current.Held) {\n                IMInput.TargetID = IMInput.CurrentID;\n            }\n            Current.Draw(Time.frameCount);\n            ", "            if (Current.Held) {\n                IMInput.TargetID = IMInput.CurrentID;\n            }\n            Current.Draw(Time.frameCount);\n            \n            if (firstTimeOnly) {\n                if (RectResize(ref Current.Rect, new Vector2(30, IMStyle.SpacedTextHeight + 20))) {\n                    Current.Held = false;\n                }\n            }\n            return new WindowState(true);\n        }\n", "        public static WindowState BeginWindow(string name, Rect rect, ref bool isOpen, bool firstTimeOnly = true,\n            Coordinate coordinate = Coordinate.BottomLeft) {\n            if (!isOpen) return default;\n            if (coordinate == Coordinate.TopLeft) {\n                rect = rect.TopLeftToBottomLeftCoordinate();\n            }\n\n            if (!WindowDict.TryGetValue(name, out Current)) {\n                Current = new Window(name, rect);\n                WindowDict.Add(name, Current);\n            }", "            else if (!firstTimeOnly) {\n                Current.Rect = rect;\n            }\n\n            IMInput.CurrentID = Current.WindowID;\n            if (Current.Held) {\n                IMInput.TargetID = IMInput.CurrentID;\n            }\n\n            Current.Draw(Time.frameCount, ref isOpen);\n            if (!isOpen) return default;", "            if (!isOpen) return default;\n            if (firstTimeOnly) {\n                if (RectResize(ref Current.Rect, new Vector2(30, IMStyle.SpacedTextHeight + 20))) {\n                    Current.Held = false;\n                }\n            }\n\n            return new WindowState(true);\n        }\n\n", "        public static void EndWindow() {\n           \n            Current.ApplyDrag();\n            \n\n            IMInput.Add(Current.Rect);\n            IMInput.CurrentID = 0;\n            Current = _screenWindow;\n        }\n        public static void EndWindowWithOutDrag(bool alive) {\n          if(alive)  IMInput.Add(Current.Rect);\n            IMInput.CurrentID = 0;\n            Current = _screenWindow;\n        }\n", "        public static void EndWindowWithOutDrag(bool alive) {\n          if(alive)  IMInput.Add(Current.Rect);\n            IMInput.CurrentID = 0;\n            Current = _screenWindow;\n        }\n\n        public static DisposableIndent Indent() {\n            IMStyle.IndentLevel++;\n            return default;\n        }\n        public static DisposableDivision HorizontalDivide(int numOfDivision) {\n            var lastDivision = IMStyle.HorizontalDivisions;\n            IMStyle.HorizontalDivisions=numOfDivision;\n            return new DisposableDivision(lastDivision);\n        }\n", "        public static DisposableDivision HorizontalDivide(int numOfDivision) {\n            var lastDivision = IMStyle.HorizontalDivisions;\n            IMStyle.HorizontalDivisions=numOfDivision;\n            return new DisposableDivision(lastDivision);\n        }\n\n        public static void DrawTexture(Rect rect, Texture texture) {\n            Mesh.AddTexture(rect, texture);\n        }\n\n        public static void DrawTexture(float height, Texture texture) {\n            var width = texture.width * height / texture.height;", "        public static void DrawTexture(float height, Texture texture) {\n            var width = texture.width * height / texture.height;\n            if (Current.TryGetNextRect(width, height, out var rect)) {\n                Mesh.AddTexture(rect, texture);\n            }\n        }\n\n        public static void Line(Vector2 start, Vector2 end, float width, UiColor color) {\n            Mesh.AddLine(start, end, width, color);\n        }\n", "        public static void Line(Vector2 start, Vector2 end, float width, UiColor startColor, UiColor endColor) {\n            Mesh.AddLine(start, end, width, startColor, endColor);\n        }\n\n        public static void Circle(Vector2 center, float radius, UiColor color) {\n            Mesh.AddCircle(center, radius, color);\n        }\n\n        public static void Circle(Vector2 center, float radius1, UiColor color1, float radius2, UiColor color2) {\n            Mesh.AddCircle(center, radius1, color1, radius2, color2);\n        }\n\n", "        public static void Circle(Vector2 center, float radius1, UiColor color1, float radius2, UiColor color2) {\n            Mesh.AddCircle(center, radius1, color1, radius2, color2);\n        }\n\n\n        public static bool DropDownField(IList<string> list, ref int selected) {\n            var lineHeight = IMStyle.SpacedTextHeight;\n            var fontSize = IMStyle.FontSize;\n            var mesh = Mesh;\n            if (!Current.TryGetNextRect(lineHeight, out var rect)) return false;\n            var focusState = DropDownFocusButton(rect, selected < 0 ? Str.Empty : list[selected]);", "            if (!Current.TryGetNextRect(lineHeight, out var rect)) return false;\n            var focusState = DropDownFocusButton(rect, selected < 0 ? Str.Empty : list[selected]);\n            if (focusState == FocusState.NotFocus) return false;\n            if (focusState == FocusState.NewFocus) {\n                return false;\n            }\n\n            using var p = ModalWindowArea.New();\n            rect.MoveY(-lineHeight);\n            var alreadySelected = false;\n            for (var index = 0; index < list.Count; index++) {", "            for (var index = 0; index < list.Count; index++) {\n                if (!alreadySelected && rect.ContainsMouse()) {\n                    mesh.AddRect(rect, new UiColor(40, 156, 200, 255));\n                    alreadySelected = true;\n                    if (TryConsumeLeftMouseDown()) {\n                        selected = index;\n                        IMInput.CloseModalWindow();\n                        return true;\n                    }\n                }\n                else {\n                    mesh.AddRect(rect, new UiColor(40, 40, 40, 255));\n                }\n\n                mesh.AddText(rect, fontSize, list[index], IMStyle.FontColor);\n                rect.MoveY(-lineHeight);", "                if (rect.yMax < 0) break;\n            }\n\n            if (IMInput.IsPointerDownActive) {\n                IMInput.CloseModalWindow();\n            }\n\n            return false;\n        }public static bool DropDownField(Str label,IList<string> list, ref int selected) {\n            var lineHeight = IMStyle.SpacedTextHeight;\n            var fontSize = IMStyle.FontSize;\n            var mesh = Mesh;", "        }public static bool DropDownField(Str label,IList<string> list, ref int selected) {\n            var lineHeight = IMStyle.SpacedTextHeight;\n            var fontSize = IMStyle.FontSize;\n            var mesh = Mesh;\n            if (!Current.TryGetNextRect(lineHeight, out var rect)) return false;\n            if (!DivideToLabelAndValue(ref rect, out var labelRect, out var valueRect)) {\n                Label(labelRect, label);\n            }\n            Label(labelRect, label);\n            var focusState = DropDownFocusButton(valueRect, selected < 0 ? Str.Empty : list[selected]);\n            if (focusState == FocusState.NotFocus) return false;", "            if (focusState == FocusState.NotFocus) return false;\n            if (focusState == FocusState.NewFocus) {\n                return false;\n            }\n            using var p = ModalWindowArea.New();\n            valueRect.MoveY(-lineHeight);\n            var alreadySelected = false;\n            for (var index = 0; index < list.Count; index++) {\n                if (!alreadySelected && valueRect.ContainsMouse()) {\n                    mesh.AddRect(valueRect, new UiColor(40, 156, 200, 255));\n                    alreadySelected = true;", "                if (!alreadySelected && valueRect.ContainsMouse()) {\n                    mesh.AddRect(valueRect, new UiColor(40, 156, 200, 255));\n                    alreadySelected = true;\n                    if (TryConsumeLeftMouseDown()) {\n                        selected = index;\n                        IMInput.CloseModalWindow();\n                        return true;\n                    }\n                }\n                else {\n                    mesh.AddRect(valueRect, new UiColor(40, 40, 40, 255));\n                }\n\n                mesh.AddText(valueRect, fontSize, list[index], IMStyle.FontColor);\n                valueRect.MoveY(-lineHeight);", "                if (valueRect.yMax < 0) break;\n            }\n\n            if (IMInput.IsPointerDownActive) {\n                IMInput.CloseModalWindow();\n            }\n\n            return false;\n        }\n\n        public static bool DropDownArea(Rect rect, IList<string> list, out int selected, bool enter = false) {\n            var lineHeight = IMStyle.SpacedTextHeight;\n            var fontSize = IMStyle.FontSize;\n            var mesh = Mesh;\n            rect.MoveY(-lineHeight);\n            selected = -1;\n            var alreadySelected = false;", "        public static bool DropDownArea(Rect rect, IList<string> list, out int selected, bool enter = false) {\n            var lineHeight = IMStyle.SpacedTextHeight;\n            var fontSize = IMStyle.FontSize;\n            var mesh = Mesh;\n            rect.MoveY(-lineHeight);\n            selected = -1;\n            var alreadySelected = false;\n            for (var index = 0; index < list.Count; index++) {\n                if (!alreadySelected && rect.ContainsMouse()) {\n                    mesh.AddRect(rect, new UiColor(40, 156, 200, 255));\n                    alreadySelected = true;\n                    _tempSelected = index;", "                if (!alreadySelected && rect.ContainsMouse()) {\n                    mesh.AddRect(rect, new UiColor(40, 156, 200, 255));\n                    alreadySelected = true;\n                    _tempSelected = index;\n                    if (enter || TryConsumeLeftMouseDown()) {\n                        selected = index;\n                        return true;\n                    }\n                }\n                else if (index == _tempSelected) {\n                    mesh.AddRect(rect, new UiColor(40, 156, 200, 255));", "                else if (index == _tempSelected) {\n                    mesh.AddRect(rect, new UiColor(40, 156, 200, 255));\n                    if (enter) {\n                        selected = index;\n                        return true;\n                    }\n                }\n                else {\n                    mesh.AddRect(rect, new UiColor(40, 40, 40, 255));\n                }\n\n                mesh.AddText(rect, fontSize, list[index], IMStyle.FontColor);\n                rect.MoveY(-lineHeight);", "                if (rect.yMax < 0) break;\n            }\n\n            return false;\n        }\n\n        public static bool DropDownArea(Rect rect, List<(int, string)> list, out int selected, bool enter = false) {\n            var lineHeight = IMStyle.SpacedTextHeight;\n            var fontSize = IMStyle.FontSize;\n            var mesh = Mesh;\n            rect.MoveY(-lineHeight);\n            var alreadySelected = false;\n            selected = -1;\n", "            for (var index = 0; index < list.Count; index++) {\n                if (!alreadySelected && rect.ContainsMouse()) {\n                    mesh.AddRect(rect, new UiColor(40, 156, 200, 255));\n                    alreadySelected = true;\n                    _tempSelected = index;\n                    if (enter || TryConsumeLeftMouseDown()) {\n                        selected = list[index].Item1;\n                        return true;\n                    }\n                }\n                else if (index == _tempSelected) {\n                    mesh.AddRect(rect, new UiColor(40, 156, 200, 255));", "                else if (index == _tempSelected) {\n                    mesh.AddRect(rect, new UiColor(40, 156, 200, 255));\n                    if (enter) {\n                        selected = list[index].Item1;\n                        return true;\n                    }\n                }\n                else {\n                    mesh.AddRect(rect, new UiColor(40, 40, 40, 255));\n                }\n\n                mesh.AddText(rect, fontSize, list[index].Item2, IMStyle.FontColor);\n                rect.MoveY(-lineHeight);", "                if (rect.yMax < 0) break;\n            }\n\n            return false;\n        }\n\n        static List<(int, string)> _queried = new();\n        static int _tempSelected;\n\n        public static bool InputDropdownField<TList>(TList list, ref int selected, bool forceUpdate = false)\n            where TList : IList<string> {", "        public static bool InputDropdownField<TList>(TList list, ref int selected, bool forceUpdate = false)\n            where TList : IList<string> {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) {\n                return false;\n            }\n            var focusState = DropDownFocusButton(rect, selected < 0 ? Str.Empty : list[selected]);\n            if (focusState == FocusState.NotFocus) return false;\n            if (focusState == FocusState.NewFocus) {\n                _inputFieldData = default;\n                _tempSelected = 0;\n                return false;\n            }\n\n            using var p = ModalWindowArea.New();\n            var lineHeight = IMStyle.SpacedTextHeight;\n            rect.MoveY(-lineHeight);\n\n            var inputState = DrawAndGetInputState(rect);\n            var input = _inputBuffer.AsSpan()[.._inputFieldData.Length];\n            var enter = false;", "            if ((forceUpdate && inputState == InputState.NoChange) || inputState == InputState.Change) {\n                _tempSelected = 0;\n                list.QueryContains(input, _queried, StringComparison.OrdinalIgnoreCase);\n            }\n            else if (inputState == InputState.Enter) {\n                enter = true;\n                if (!input.IsEmpty) list.QueryContains(input, _queried, StringComparison.OrdinalIgnoreCase);\n            }\n\n            if (!input.IsEmpty) {\n                if (DropDownArea(rect, _queried, out selected, enter)) {\n                    IMInput.CloseModalWindow();\n                    return true;\n                }\n", "            if (!input.IsEmpty) {\n                if (DropDownArea(rect, _queried, out selected, enter)) {\n                    IMInput.CloseModalWindow();\n                    return true;\n                }\n\n                if (IMInput.IsPointerDownActive) {\n                    IMInput.CloseModalWindow();\n                }\n\n                return false;\n            }\n", "            if (DropDownArea(rect, list, out selected, enter)) {\n                IMInput.CloseModalWindow();\n                return true;\n            }\n\n            if (IMInput.IsPointerDownActive) {\n                IMInput.CloseModalWindow();\n            }\n\n            return false;\n        } ", "        public static bool InputDropdownButton<TList>(Str label,TList list, ref int selected, bool forceUpdate = false)\n            where TList : IList<string> {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) {\n                return false;\n            }\n\n            selected = Mathf.Clamp(selected,0, list.Count);\n            var focusState = FocusButton(rect, label);\n            if (focusState == FocusState.NotFocus) return false;\n            if (focusState == FocusState.NewFocus) {\n                _inputFieldData = default;\n                _tempSelected = 0;\n                return false;\n            }\n\n            using var p = ModalWindowArea.New();\n            var lineHeight = IMStyle.SpacedTextHeight;\n            rect.MoveY(-lineHeight);\n\n            var inputState = DrawAndGetInputState(rect);\n            var input = _inputBuffer.AsSpan()[.._inputFieldData.Length];\n            var enter = false;", "            if (focusState == FocusState.NotFocus) return false;\n            if (focusState == FocusState.NewFocus) {\n                _inputFieldData = default;\n                _tempSelected = 0;\n                return false;\n            }\n\n            using var p = ModalWindowArea.New();\n            var lineHeight = IMStyle.SpacedTextHeight;\n            rect.MoveY(-lineHeight);\n\n            var inputState = DrawAndGetInputState(rect);\n            var input = _inputBuffer.AsSpan()[.._inputFieldData.Length];\n            var enter = false;", "            if ((forceUpdate && inputState == InputState.NoChange) || inputState == InputState.Change) {\n                _tempSelected = 0;\n                list.QueryContains(input, _queried, StringComparison.OrdinalIgnoreCase);\n            }\n            else if (inputState == InputState.Enter) {\n                enter = true;\n                if (!input.IsEmpty) list.QueryContains(input, _queried, StringComparison.OrdinalIgnoreCase);\n            }\n\n            if (!input.IsEmpty) {\n                if (DropDownArea(rect, _queried, out selected, enter)) {\n                    IMInput.CloseModalWindow();\n                    return true;\n                }\n", "            if (!input.IsEmpty) {\n                if (DropDownArea(rect, _queried, out selected, enter)) {\n                    IMInput.CloseModalWindow();\n                    return true;\n                }\n\n                if (IMInput.IsPointerDownActive) {\n                    IMInput.CloseModalWindow();\n                }\n\n                return false;\n            }\n", "            if (DropDownArea(rect, list, out selected, enter)) {\n                IMInput.CloseModalWindow();\n                return true;\n            }\n\n            if (IMInput.IsPointerDownActive) {\n                IMInput.CloseModalWindow();\n            }\n\n            return false;\n        }\n\n", "        public static bool VerticalTabs(IList<string> list, ref int selected) {\n            var lineHeight = IMStyle.SpacedTextHeight;\n            var fontSize = IMStyle.FontSize;\n            var mesh = Mesh;\n            var alreadySelected = false;\n            for (var index = 0; index < list.Count; index++) {\n                if (!Current.TryGetNextRect(lineHeight, out var rect)) break;\n                if (!alreadySelected && selected == index) {\n                    mesh.AddRect(rect, new UiColor(40, 156, 200, 255));\n                }\n                else if (!alreadySelected && rect.ContainsActiveMouse()) {\n                    mesh.AddRect(rect, new UiColor(20, 20, 20, 255));", "                else if (!alreadySelected && rect.ContainsActiveMouse()) {\n                    mesh.AddRect(rect, new UiColor(20, 20, 20, 255));\n                    if (TryConsumeLeftMouseDown()) {\n                        selected = index;\n                        alreadySelected = true;\n                    }\n                }\n                else {\n                    mesh.AddRect(rect, new UiColor(40, 40, 40, 255));\n                }\n\n                mesh.AddText(rect, fontSize, list[index], IMStyle.FontColor);\n            }\n\n            return alreadySelected;\n        }\n\n", "        public static void Label(Str label) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return;\n            Mesh.AddText(rect, IMStyle.FontSize, label, IMStyle.FontColor);\n        }\n\n        public static void Label(Str label1, Str label2) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return;\n            Span<char> label = stackalloc char[label1.Length + label2.Length];\n            label1.CopyTo(label[..label1.Length]);\n            label2.CopyTo(label[label1.Length..]);\n            Mesh.AddText(rect, IMStyle.FontSize, label, IMStyle.FontColor);\n        }\n", "        public static bool Label(Str label1, Str label2, UiColor color) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return false;\n            Mesh.AddText(rect, IMStyle.FontSize, label1, label2, color);\n            return true;\n        }\n\n        public static void Label(Rect rect, Str label1, Str label2, UiColor color) {\n            Mesh.AddText(rect, IMStyle.FontSize, label1, label2, color);\n        }\n\n        public static void Label(Rect rect, Str label) {\n            Mesh.AddText(rect, IMStyle.FontSize, label, IMStyle.FontColor);\n        }\n\n", "        public static void Label(Rect rect, Str label) {\n            Mesh.AddText(rect, IMStyle.FontSize, label, IMStyle.FontColor);\n        }\n\n\n        public static void Label(Str label, UiColor color) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return;\n            Mesh.AddText(rect, IMStyle.FontSize, label, color);\n        }\n\n        public static void Label(Str label, ReadOnlySpan<(int length, UiColor color)> colors) {", "        public static void Label(Str label, ReadOnlySpan<(int length, UiColor color)> colors) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return;\n            Mesh.AddText(rect, IMStyle.FontSize, label, colors);\n        }\n\n\n        public static void Label(Str label, int value) {\n            var span = ScratchBuffer.AsSpan();\n            label.CopyTo(span[..label.Length]);\n            var remain = span[label.Length..];\n            if (value.TryFormat(remain, out var count)) {\n                span = span[..(label.Length + count)];\n                Label(span);\n            }\n        }\n", "            if (value.TryFormat(remain, out var count)) {\n                span = span[..(label.Length + count)];\n                Label(span);\n            }\n        }\n\n        public static void Label(Str label, int value, UiColor labelColor, UiColor valueColor) {\n            var span = ScratchBuffer.AsSpan();\n            label.CopyTo(span[..label.Length]);\n            var remain = span[label.Length..];\n            if (value.TryFormat(remain, out var charsWritten)) {\n                ReadOnlySpan<(int, UiColor)> colors = stackalloc (int, UiColor)[2]\n                    {(label.Length, labelColor), (charsWritten, valueColor)};\n                span = span[..(label.Length + charsWritten)];\n                Label(span, colors);\n            }\n        }\n", "            if (value.TryFormat(remain, out var charsWritten)) {\n                ReadOnlySpan<(int, UiColor)> colors = stackalloc (int, UiColor)[2]\n                    {(label.Length, labelColor), (charsWritten, valueColor)};\n                span = span[..(label.Length + charsWritten)];\n                Label(span, colors);\n            }\n        }\n\n        public static void Label<T, TValue>(Str label, TValue value)\n            where T : struct, IFormatter<TValue> {\n            var span = ScratchBuffer.AsSpan();\n            label.CopyTo(span[..label.Length]);\n            var remain = span[label.Length..];", "        public static void Label<T, TValue>(Str label, TValue value)\n            where T : struct, IFormatter<TValue> {\n            var span = ScratchBuffer.AsSpan();\n            label.CopyTo(span[..label.Length]);\n            var remain = span[label.Length..];\n            if (default(T).TryFormat(value, remain, out var charsWritten)) {\n                span = span[..(label.Length + charsWritten)];\n                if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return;\n                Mesh.AddText(rect, IMStyle.FontSize, span, IMStyle.FontColor);\n            }\n        }\n", "        public static void Label<T, TValue>(Str label, TValue value, UiColor labelColor,\n            UiColor valueColor)\n            where T : struct, IFormatter<TValue> {\n            var span = ScratchBuffer.AsSpan();\n            label.CopyTo(span[..label.Length]);\n            var remain = span[label.Length..];\n            if (default(T).TryFormat(value, remain, out var charsWritten)) {\n                ReadOnlySpan<(int, UiColor)> colors = stackalloc (int, UiColor)[2]\n                    {(label.Length, labelColor), (charsWritten, valueColor)};\n                span = span[..(label.Length + charsWritten)];\n                Label(span, colors);\n            }\n        }\n", "        public static void Label<T, TValue>(TValue value) where T : struct, IFormatter<TValue> {\n            var span = ScratchBuffer.AsSpan();\n            if (default(T).TryFormat(value, span, out var charsWritten)) {\n                Label(span[..charsWritten]);\n            }\n        }\n\n        public static void Label(Str label, float value) {\n            var span = ScratchBuffer.AsSpan();\n            label.CopyTo(span.Slice(0, label.Length));\n            var remain = span.Slice(label.Length);", "            if (value.TryFormat(remain, out var count)) {\n                span = span.Slice(0, label.Length + count);\n                Label(span);\n            }\n        }\n\n        public static void Label(float value, Str format = default,\n            IFormatProvider formatProvider = default) {\n            var span = ScratchBuffer.AsSpan();\n            if (value.TryFormat(span, out var count, format, formatProvider)) {\n                span = span.Slice(0, count);\n                Label(span);\n                span.Clear();\n            }\n        }\n", "            if (value.TryFormat(span, out var count, format, formatProvider)) {\n                span = span.Slice(0, count);\n                Label(span);\n                span.Clear();\n            }\n        }\n\n        public static bool MethodButton(this object o, string name) {\n            if (Button(name)) {\n                var method = o.GetType().GetMethod(name,\n                    BindingFlags.InvokeMethod | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance |\n                    BindingFlags.Static);", "            if (Button(name)) {\n                var method = o.GetType().GetMethod(name,\n                    BindingFlags.InvokeMethod | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance |\n                    BindingFlags.Static);\n                if (method == null) {\n                    Debug.LogAssertion(name + \"is null\");\n                    return false;\n                }\n                method.Invoke(o, null);\n                return true;\n            }\n            return false;\n        }\n      \n", "        public static bool MethodButton(Type type, string name) {\n            if (Button(name)) {\n                var method = type.GetMethod(name,\n                    BindingFlags.InvokeMethod | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static);\n                if (method == null) {\n                    Debug.LogAssertion(name + \"is null\");\n                    return false;\n                }\n\n                method.Invoke(null, null);\n                return true;\n            }\n\n            return false;\n        }\n", "        public static bool Button(Str label) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return false;\n            return Button(rect, label);\n        }\n\n        public static bool RadioButton(ref bool on) => RadioButton(ref on, IMStyle.SpacedTextHeight / 2);\n\n        public static bool RadioButton(ref bool on, float radius) {\n            if (!Current.TryGetNextRect(2 * radius, out var rect)) return false;\n            rect.width = 2 * radius;\n            var contains = IMInput.CircleContainsActiveMouse(rect.center, radius);\n            var pushed = contains && TryConsumeLeftMouseDown();\n            on ^= pushed;\n            var instance = Mesh;\n            var center = rect.center;", "            if (!Current.TryGetNextRect(2 * radius, out var rect)) return false;\n            rect.width = 2 * radius;\n            var contains = IMInput.CircleContainsActiveMouse(rect.center, radius);\n            var pushed = contains && TryConsumeLeftMouseDown();\n            on ^= pushed;\n            var instance = Mesh;\n            var center = rect.center;\n            if (contains)\n                instance.AddCircle(center, radius + 1, new UiColor(255, 255, 255, 255), radius,\n                    IMStyle.FieldColor);\n            else instance.AddCircle(center, radius, IMStyle.FieldColor);", "            if (on) {\n                instance.AddCircle(center, radius / 2,\n                    new UiColor(200, 200, 200, 255));\n            }\n\n            return pushed;\n        }\n\n        public static bool CheckBox(bool on) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return on;\n            var size = IMStyle.FontSize;\n            rect = new Rect(rect.xMin + size / 10, rect.yMin, size, size);\n            var contains = rect.ContainsActiveMouse();\n            var pushed = contains && TryConsumeLeftMouseDown();\n            on ^= pushed;\n            var instance = Mesh;", "        public static bool CheckBox(bool on) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return on;\n            var size = IMStyle.FontSize;\n            rect = new Rect(rect.xMin + size / 10, rect.yMin, size, size);\n            var contains = rect.ContainsActiveMouse();\n            var pushed = contains && TryConsumeLeftMouseDown();\n            on ^= pushed;\n            var instance = Mesh;\n            if (contains)\n                instance.AddRect(rect, 1, new UiColor(255, 255, 255, 255), IMStyle.FieldColor);\n            else instance.AddRect(rect, IMStyle.FieldColor);", "            if (contains)\n                instance.AddRect(rect, 1, new UiColor(255, 255, 255, 255), IMStyle.FieldColor);\n            else instance.AddRect(rect, IMStyle.FieldColor);\n            if (on) {\n                var center = rect.center;\n                ReadOnlySpan<Vector2> lines = stackalloc[] {\n                    new Vector2(center.x - size / 3, center.y),\n                    new Vector2(center.x - size / 8, center.y - size * (5f / 24)),\n                    new Vector2(center.x + size / 3, center.y + size / 4)\n                };\n                instance.AddLines(lines, size / 10, IMStyle.FontColor);\n            }\n\n            return on;\n        }\n", "        public static bool BoolField(Str label, ref bool on) {\n            if (!Current.TryGetNextRect(out var rect)) return false;\n            return BoolField(rect, label, ref on);\n        }\n\n        public static bool BoolField(Rect rect, Str label, ref bool on) {\n            var success = rect.DivideToLabelAndValue(out var labelRect, out var valueRect);\n            Label(labelRect, label);\n            if (!success) {\n                return false;\n            }\n\n            var size = IMStyle.FontSize;\n            valueRect = new Rect(valueRect.xMin + size / 10, valueRect.yMin + size / 10, size, size);\n            var contains = valueRect.ContainsActiveMouse();\n            var pushed = contains && TryConsumeLeftMouseDown();\n            on ^= pushed;\n            var instance = Mesh;", "            if (!success) {\n                return false;\n            }\n\n            var size = IMStyle.FontSize;\n            valueRect = new Rect(valueRect.xMin + size / 10, valueRect.yMin + size / 10, size, size);\n            var contains = valueRect.ContainsActiveMouse();\n            var pushed = contains && TryConsumeLeftMouseDown();\n            on ^= pushed;\n            var instance = Mesh;\n            if (contains)\n                instance.AddRect(valueRect, 1, new UiColor(255, 255, 255, 255), IMStyle.FieldColor);\n            else instance.AddRect(valueRect, IMStyle.FieldColor);", "            if (contains)\n                instance.AddRect(valueRect, 1, new UiColor(255, 255, 255, 255), IMStyle.FieldColor);\n            else instance.AddRect(valueRect, IMStyle.FieldColor);\n            if (on) {\n                var center = valueRect.center;\n                ReadOnlySpan<Vector2> lines = stackalloc[] {\n                    new Vector2(center.x - size / 3, center.y),\n                    new Vector2(center.x - size / 8, center.y - size * (5f / 24)),\n                    new Vector2(center.x + size / 3, center.y + size / 4)\n                };\n                instance.AddLines(lines, size / 10, IMStyle.FontColor);\n            }\n\n            return pushed;\n        }\n", "        public static bool CheckBox(ref bool on) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return on;\n            var size = IMStyle.FontSize;\n            rect = new Rect(rect.xMin + size / 10, rect.yMin, size, size);\n            var contains = rect.ContainsActiveMouse();\n            var pushed = contains && TryConsumeLeftMouseDown();\n            on ^= pushed;\n            var instance = Mesh;\n            if (contains)\n                instance.AddRect(rect, 1, new UiColor(255, 255, 255, 255), IMStyle.FieldColor);\n            else instance.AddRect(rect, IMStyle.FieldColor);", "            if (contains)\n                instance.AddRect(rect, 1, new UiColor(255, 255, 255, 255), IMStyle.FieldColor);\n            else instance.AddRect(rect, IMStyle.FieldColor);\n            if (on) {\n                var center = rect.center;\n                ReadOnlySpan<Vector2> lines = stackalloc[] {\n                    new Vector2(center.x - size / 3, center.y),\n                    new Vector2(center.x - size / 8, center.y - size * (5f / 24)),\n                    new Vector2(center.x + size / 3, center.y + size / 4)\n                };\n                instance.AddLines(lines, size / 10, IMStyle.FontColor);\n            }\n\n            return pushed;\n        }\n", "        public static void HorizontalGradient(UiColor left, UiColor right) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return;\n            Mesh.AddHorizontalGradient(rect, left, right);\n        }\n\n        public static void HorizontalGradient(Rect rect, UiColor left, UiColor right) {\n            Mesh.AddHorizontalGradient(rect, left, right);\n        }\n\n        public static void Gradient(float height, UiColor topLeftColor, UiColor topRightColor, UiColor bottomLeftColor,\n            UiColor bottomRightColor) {", "        public static void Gradient(float height, UiColor topLeftColor, UiColor topRightColor, UiColor bottomLeftColor,\n            UiColor bottomRightColor) {\n            if (!Current.TryGetNextRect(height, out var rect)) return;\n            Mesh.AddGradient(rect, topLeftColor, topRightColor, bottomLeftColor, bottomRightColor);\n        }\n\n        public static void Gradient(Rect rect, UiColor topLeftColor, UiColor topRightColor, UiColor bottomLeftColor,\n            UiColor bottomRightColor) {\n            Mesh.AddGradient(rect, topLeftColor, topRightColor, bottomLeftColor, bottomRightColor);\n        }\n\n", "        public static bool Slider(ref float value, float min, float max) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return false;\n            return Slider(rect, ref value, min, max);\n        }\n\n        public static bool Slider(ref int value, int min, int max) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return false;\n            return Slider(ref value, min, max, rect);\n        }\n\n        public static void Quad(Rect rect) {\n            Mesh.AddRect(rect, IMStyle.BasicColor);\n        }\n", "        public static void Quad(Rect rect) {\n            Mesh.AddRect(rect, IMStyle.BasicColor);\n        }\n\n        public static void Quad(Rect rect, UiColor topLeftColor, UiColor topRightColor, UiColor bottomLeftColor,\n            UiColor bottomRightColor) {\n            Mesh.AddRect(rect, IMStyle.BasicColor);\n        }\n\n\n        public static bool Button(Rect rect, Str label) {\n            var canPush = rect.CanPush();\n            var pushed = canPush && TryConsumeLeftMouseDown();\n            var instance = Mesh;\n            var width = Mathf.Max(rect.height / 20, 1);\n            instance.AddRect(rect, width, IMStyle.ButtonColor, canPush ? IMStyle.HoveredButtonColor : IMStyle.UnHoveredButtonColor);\n            instance.AddCenterText(rect.center,rect.width-2*width, IMStyle.FontSize, label, IMStyle.FontColor);\n            return pushed;\n        }\n", "        public static bool Button(Rect rect, Str label) {\n            var canPush = rect.CanPush();\n            var pushed = canPush && TryConsumeLeftMouseDown();\n            var instance = Mesh;\n            var width = Mathf.Max(rect.height / 20, 1);\n            instance.AddRect(rect, width, IMStyle.ButtonColor, canPush ? IMStyle.HoveredButtonColor : IMStyle.UnHoveredButtonColor);\n            instance.AddCenterText(rect.center,rect.width-2*width, IMStyle.FontSize, label, IMStyle.FontColor);\n            return pushed;\n        }\n\n        public static bool Foldout(Str label, bool foldout) {", "        public static bool Foldout(Str label, bool foldout) {\n            if (!Current.TryGetNextRect(out var rect)) return false;\n            return Foldout(rect, label, foldout);\n        }\n        public static bool Foldout(Str label,ref  bool foldout) {\n            if (!Current.TryGetNextRect(out var rect)) return false;\n            return foldout=Foldout(rect, label, foldout);\n        }\n\n        public static bool Foldout(Rect rect, Str label, bool foldout) {\n            var canPush = rect.CanPush();\n            var pushed = canPush && TryConsumeLeftMouseDown();\n            var result = foldout ^ pushed;\n            var instance = Mesh;\n            var width = Mathf.Max(rect.height / 20, 1);\n            instance.AddRect(rect, width, IMStyle.ButtonColor, canPush ?IMStyle.HoveredButtonColor : IMStyle.UnHoveredButtonColor);\n\n            var fontSize = IMStyle.FontSize;\n            var fontColor = IMStyle.FontColor;", "        public static bool Foldout(Rect rect, Str label, bool foldout) {\n            var canPush = rect.CanPush();\n            var pushed = canPush && TryConsumeLeftMouseDown();\n            var result = foldout ^ pushed;\n            var instance = Mesh;\n            var width = Mathf.Max(rect.height / 20, 1);\n            instance.AddRect(rect, width, IMStyle.ButtonColor, canPush ?IMStyle.HoveredButtonColor : IMStyle.UnHoveredButtonColor);\n\n            var fontSize = IMStyle.FontSize;\n            var fontColor = IMStyle.FontColor;\n            if (!label.IsEmpty) {\n                var textRect = new Rect(rect.x + width + fontSize * 1.4f, rect.y + width,\n                    rect.width - 2 * width - fontSize * 1.4f,\n                    rect.height - 2 * width);\n                instance.AddText(textRect, fontSize, label, fontColor);\n            }\n", "            if (!label.IsEmpty) {\n                var textRect = new Rect(rect.x + width + fontSize * 1.4f, rect.y + width,\n                    rect.width - 2 * width - fontSize * 1.4f,\n                    rect.height - 2 * width);\n                instance.AddText(textRect, fontSize, label, fontColor);\n            }\n\n            if (result)\n                instance.AddInvertedTriangle(new Vector2(rect.xMin + fontSize * 0.7f, rect.yMin + rect.height / 2),\n                    fontSize * 0.5f, fontColor);\n            else\n                instance.AddRightPointingTriangle(new Vector2(rect.xMin + fontSize * 0.7f, rect.yMin + rect.height / 2),\n                    fontSize * 0.5f, fontColor);\n            return result;\n        }\n", "        public static FocusState DropDownFocusButton(Rect rect, Str label) {\n            var focusState = rect.GetModalWindowState();\n            var canPush = rect.CanPush();\n            var instance = Mesh;\n            var width = Mathf.Max(rect.height / 20, 1);\n            instance.AddRect(rect, width, IMStyle.ButtonColor, canPush ? IMStyle.HoveredButtonColor : IMStyle.UnHoveredButtonColor);\n\n            var fontSize = IMStyle.FontSize;\n            var fontColor = IMStyle.FontColor;\n            if (!label.IsEmpty) {\n                var textRect = new Rect(rect.x + width, rect.y + width, rect.width - 2 * width - fontSize,\n                    rect.height - 2 * width);\n                instance.AddText(textRect, fontSize, label, fontColor);\n            }\n\n            instance.AddInvertedTriangle(new Vector2(rect.xMax - fontSize * 0.7f, rect.yMin + rect.height / 2),\n                fontSize * 0.5f, fontColor);\n            return focusState;\n        }", "            if (!label.IsEmpty) {\n                var textRect = new Rect(rect.x + width, rect.y + width, rect.width - 2 * width - fontSize,\n                    rect.height - 2 * width);\n                instance.AddText(textRect, fontSize, label, fontColor);\n            }\n\n            instance.AddInvertedTriangle(new Vector2(rect.xMax - fontSize * 0.7f, rect.yMin + rect.height / 2),\n                fontSize * 0.5f, fontColor);\n            return focusState;\n        }\n        public static FocusState FocusButton(Rect rect, Str label) {\n            var focusState = rect.GetModalWindowState();\n            var canPush = rect.CanPush();\n            var instance = Mesh;\n            var width = Mathf.Max(rect.height / 20, 1);\n            instance.AddRect(rect, width, IMStyle.ButtonColor, canPush ? IMStyle.HoveredButtonColor : IMStyle.UnHoveredButtonColor);\n            var fontSize = IMStyle.FontSize;\n            var fontColor = IMStyle.FontColor;", "        public static FocusState FocusButton(Rect rect, Str label) {\n            var focusState = rect.GetModalWindowState();\n            var canPush = rect.CanPush();\n            var instance = Mesh;\n            var width = Mathf.Max(rect.height / 20, 1);\n            instance.AddRect(rect, width, IMStyle.ButtonColor, canPush ? IMStyle.HoveredButtonColor : IMStyle.UnHoveredButtonColor);\n            var fontSize = IMStyle.FontSize;\n            var fontColor = IMStyle.FontColor;\n            if (!label.IsEmpty) {\n               \n                instance.AddCenterText(rect.center,rect.width-2*width, fontSize, label, fontColor);\n            }\n\n            return focusState;\n        }\n\n", "            if (!label.IsEmpty) {\n               \n                instance.AddCenterText(rect.center,rect.width-2*width, fontSize, label, fontColor);\n            }\n\n            return focusState;\n        }\n\n\n        public enum InputState {\n            InputIsNull,\n            Change,\n            NoChange,\n            Enter,\n        }\n\n", "        public enum InputState {\n            InputIsNull,\n            Change,\n            NoChange,\n            Enter,\n        }\n\n\n        public static InputState DrawAndGetInputState(Rect rect) {\n            ref var data = ref _inputFieldData;\n            var buffer = _inputBuffer.AsSpan();\n            data.FocusTime += Time.unscaledDeltaTime;\n            var instance = Mesh;\n            instance.AddRect(rect, UiColor.Black);\n            var inputString = IMInput.InputString;", "        public static InputState DrawAndGetInputState(Rect rect) {\n            ref var data = ref _inputFieldData;\n            var buffer = _inputBuffer.AsSpan();\n            data.FocusTime += Time.unscaledDeltaTime;\n            var instance = Mesh;\n            instance.AddRect(rect, UiColor.Black);\n            var inputString = IMInput.InputString;\n            if (!string.IsNullOrEmpty(inputString) | TryGetPaste(out var pasteText)) {\n                var preCaretLength = data.CaretPosition;\n                var postCaretLength = data.Length - preCaretLength;\n                var postCaret = ScratchBuffer.AsSpan(0, postCaretLength);", "                if (postCaretLength != 0) buffer.Slice(data.CaretPosition, postCaretLength).CopyTo(postCaret);\n                var enter = false;\n                if (pasteText != null) {\n                    foreach (var c in pasteText) {\n                        if (c is '\\n' or '\\r') {\n                            IMInput.LoseFocus();\n                            enter = true;\n                            break;\n                        }\n\n                        if (preCaretLength < buffer.Length) {\n                            buffer[preCaretLength++] = c;\n                        }\n                    }\n                }\n", "                        if (preCaretLength < buffer.Length) {\n                            buffer[preCaretLength++] = c;\n                        }\n                    }\n                }\n\n                if (inputString != null)\n                    foreach (var c in inputString) {\n                        if (c == '\\b') {\n                            if (0 < preCaretLength) {\n                                --preCaretLength;\n                            }\n                        }", "                        if (c == '\\b') {\n                            if (0 < preCaretLength) {\n                                --preCaretLength;\n                            }\n                        }\n                        else if (c is '\\n' or '\\r') {\n                            IMInput.LoseFocus();\n                            enter = true;\n                            break;\n                        }\n                        else if (preCaretLength < buffer.Length) {\n                            buffer[preCaretLength++] = c;\n                        }\n                    }\n", "                        else if (preCaretLength < buffer.Length) {\n                            buffer[preCaretLength++] = c;\n                        }\n                    }\n\n                if (preCaretLength + postCaretLength == 0) {\n                    data.Length = 0;\n                    data.CaretPosition = 0;\n\n                    return enter ? InputState.Enter : InputState.InputIsNull;\n                }\n\n                float caretPos;", "                if (postCaretLength != 0) {\n                    caretPos = instance.CalculateLength(buffer[..preCaretLength], IMStyle.FontSize);\n                    postCaret.CopyTo(buffer.Slice(preCaretLength, postCaretLength));\n                    instance.AddText(rect,IMStyle.FontSize, buffer[..(preCaretLength + postCaretLength)], IMStyle.FontColor);\n                }\n                else {\n                    caretPos = instance.AddText(rect,IMStyle.FontSize, buffer[..preCaretLength], IMStyle.FontColor);\n                }\n\n                if (1.5f < (data.FocusTime * 3) % 3) {\n                    instance.AddRect(new Rect(rect.xMin + caretPos, rect.yMin, 2, IMStyle.SpacedTextHeight),\n                        IMStyle.FontColor);\n                }\n\n                data.Length = preCaretLength + postCaretLength;\n                data.CaretPosition = preCaretLength;\n                return enter ? InputState.Enter : InputState.Change;\n            }\n", "                if (1.5f < (data.FocusTime * 3) % 3) {\n                    instance.AddRect(new Rect(rect.xMin + caretPos, rect.yMin, 2, IMStyle.SpacedTextHeight),\n                        IMStyle.FontColor);\n                }\n\n                data.Length = preCaretLength + postCaretLength;\n                data.CaretPosition = preCaretLength;\n                return enter ? InputState.Enter : InputState.Change;\n            }\n\n            if (data.Length == 0) {", "            if (data.Length == 0) {\n                if (1.5f < (data.FocusTime * 3) % 3) {\n                    instance.AddRect(new Rect(rect.xMin, rect.yMin, 2, IMStyle.SpacedTextHeight),\n                        IMStyle.FontColor);\n                }\n\n                return InputState.InputIsNull;\n            }\n\n            if (GetLeftArrowKeyDown) {\n                data.FocusTime = 0.6f;\n                --data.CaretPosition;\n            }\n", "            if (GetLeftArrowKeyDown) {\n                data.FocusTime = 0.6f;\n                --data.CaretPosition;\n            }\n\n            if (GetRightArrowKeyDown) {\n                data.FocusTime = 0.6f;\n                ++data.CaretPosition;\n            }\n\n            data.CaretPosition = Mathf.Clamp(data.CaretPosition, 0, data.Length);\n            var drawCaret = 0.5f < (data.FocusTime) % 1;", "            if (drawCaret) {\n                float caretPos;\n                if (data.CaretPosition != data.Length) {\n                    caretPos = instance.AddTextNoMask(rect, IMStyle.FontSize, buffer[..data.CaretPosition],\n                        IMStyle.FontColor);\n                    instance.AddTextNoMask(new Rect(rect.xMin + caretPos, rect.yMin, 2, IMStyle.SpacedTextHeight),\n                        IMStyle.FontSize,\n                        buffer[data.CaretPosition..data.Length], IMStyle.FontColor);\n                }\n                else {\n                    caretPos = instance.AddTextNoMask(rect, IMStyle.FontSize, buffer[..data.Length],\n                        IMStyle.FontColor);\n                }\n\n                instance.AddRect(new Rect(rect.xMin + caretPos, rect.yMin, 2, IMStyle.SpacedTextHeight),\n                    IMStyle.FontColor);\n            }\n            else instance.AddTextNoMask(rect, IMStyle.FontSize, buffer[..data.Length], IMStyle.FontColor);\n\n            return InputState.NoChange;\n        }\n\n", "        public static double HoldingValue;\n        public static float ValueHoldingPosX;\n        public static float ValueHoldingPosY;\n        static InputFieldData _inputFieldData;\n        static char[] _inputBuffer = new char[1024];\n\n\n        public static bool IntField(Str label, ref int value, int min = int.MinValue,\n            int max = int.MaxValue) {\n            if (!Current.TryGetNextRect(out var rect)) return false;\n            return IntField(rect, label, ref value, min, max);\n        }\n", "            if (!Current.TryGetNextRect(out var rect)) return false;\n            return IntField(rect, label, ref value, min, max);\n        }\n\n        public static bool IntField(Rect rect, Str label, ref int value, int min = int.MinValue,\n            int max = int.MaxValue) {\n            var showValue = rect.DivideToLabelAndValue(out var labelRect, out var valueRect);\n            Label(labelRect, label);\n            var contains = labelRect.ContainsActiveMouse();\n            _LRCursorNeeded |= contains;\n            var focusState = labelRect.GetFocusState();", "            if (focusState == FocusState.NewFocus) {\n                HoldingValue = value;\n                ValueHoldingPosX = ScreenMousePos.x;\n                var mesh = Mesh;\n                mesh.AddRect(valueRect, UiColor.Black);\n                var buffer = ScratchBuffer.AsSpan();\n                value.TryFormat(buffer, out var charsWritten);\n                mesh.AddText(valueRect, IMStyle.FontSize, buffer[..charsWritten], IMStyle.FontColor);\n            }\n            else if (focusState == FocusState.Focus) {\n                _LRCursorNeeded = true;\n                var changed = false;\n                var deltaX = ScreenMousePos.x - ValueHoldingPosX;\n                var v = (int) (HoldingValue + deltaX / IMStyle.FontSize*IMStyle.DragNumberScale);\n                v = Mathf.Clamp(v, min, max);", "            else if (focusState == FocusState.Focus) {\n                _LRCursorNeeded = true;\n                var changed = false;\n                var deltaX = ScreenMousePos.x - ValueHoldingPosX;\n                var v = (int) (HoldingValue + deltaX / IMStyle.FontSize*IMStyle.DragNumberScale);\n                v = Mathf.Clamp(v, min, max);\n                if (v != value) {\n                    value = v;\n                    changed = true;\n                }\n", "                if (showValue) {\n                    var mesh = Mesh;\n                    mesh.AddRect(valueRect, UiColor.Black);\n                    var buffer = ScratchBuffer.AsSpan();\n                    value.TryFormat(buffer, out var charsWritten);\n                    mesh.AddText(valueRect, IMStyle.FontSize, buffer[..charsWritten], IMStyle.FontColor);\n                    return changed;\n                }\n            }\n\n            if (!showValue) return false;\n            return InputField<Int32ParserFormatter, int>(valueRect, ref value);\n        }\n", "            if (!showValue) return false;\n            return InputField<Int32ParserFormatter, int>(valueRect, ref value);\n        }\n\n        public static void IntField(Str label, int value) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return;\n            IntField(rect, label, value);\n        }\n\n        public static void IntField(Rect rect, Str label, int value) {\n            var showValue = rect.DivideToLabelAndValue(out var labelRect, out var valueRect);\n            var mesh = Mesh;\n            mesh.AddText(labelRect, IMStyle.FontSize, label, IMStyle.FontColor);", "        public static void IntField(Rect rect, Str label, int value) {\n            var showValue = rect.DivideToLabelAndValue(out var labelRect, out var valueRect);\n            var mesh = Mesh;\n            mesh.AddText(labelRect, IMStyle.FontSize, label, IMStyle.FontColor);\n            if (showValue) {\n                var buffer = ScratchBuffer.AsSpan();\n                value.TryFormat(buffer, out var charsWritten);\n                mesh.AddText(valueRect, IMStyle.FontSize, buffer[..charsWritten], IMStyle.FontColor);\n            }\n        }\n", "        public static void FloatField(Str label, float value) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return;\n            FloatField(rect, label, value);\n        }\n\n        public static void FloatField(Rect rect, Str label, float value) {\n            var showValue = rect.DivideToLabelAndValue(out var labelRect, out var valueRect);\n            var mesh = Mesh;\n            mesh.AddText(labelRect, IMStyle.FontSize, label, IMStyle.FontColor);\n            if (showValue) {\n                var buffer = ScratchBuffer.AsSpan();\n                value.TryFormat(buffer, out var charsWritten);\n                mesh.AddText(valueRect, IMStyle.FontSize, buffer[..charsWritten], IMStyle.FontColor);\n            }\n        }", "            if (showValue) {\n                var buffer = ScratchBuffer.AsSpan();\n                value.TryFormat(buffer, out var charsWritten);\n                mesh.AddText(valueRect, IMStyle.FontSize, buffer[..charsWritten], IMStyle.FontColor);\n            }\n        }\n        public static void FloatField(Rect rect,float labelWidth, Str label, float value) {\n            var showValue = rect.TryDivide(labelWidth,out var labelRect, out var valueRect);\n            var mesh = Mesh;\n            mesh.AddText(labelRect, IMStyle.FontSize, label, IMStyle.FontColor);\n            if (showValue) {\n                var buffer = ScratchBuffer.AsSpan();\n                value.TryFormat(buffer, out var charsWritten);\n                mesh.AddText(valueRect, IMStyle.FontSize, buffer[..charsWritten], IMStyle.FontColor);\n            }\n        }\n", "            if (showValue) {\n                var buffer = ScratchBuffer.AsSpan();\n                value.TryFormat(buffer, out var charsWritten);\n                mesh.AddText(valueRect, IMStyle.FontSize, buffer[..charsWritten], IMStyle.FontColor);\n            }\n        }\n\n        public static void StringField(Rect rect, Str label, string value) {\n            var showValue = rect.DivideToLabelAndValue(out var labelRect, out var valueRect);\n            var mesh = Mesh;\n            mesh.AddText(labelRect, IMStyle.FontSize, label, IMStyle.FontColor);", "            if (showValue) {\n                var buffer = ScratchBuffer.AsSpan(..value.Length);\n                value.AsSpan().CopyTo(buffer);\n                mesh.AddText(valueRect, IMStyle.FontSize, buffer, IMStyle.FontColor);\n            }\n        }\n\n        public static void StringField(Str label, string value) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return;\n            StringField(rect, label, value);\n        }\n", "            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return;\n            StringField(rect, label, value);\n        }\n\n        public static void ValueField<TFormatter, TValue>(Rect rect, Str label, TValue value)\n            where TFormatter : struct, IFormatter<TValue> {\n            var showValue = rect.DivideToLabelAndValue(out var labelRect, out var valueRect);\n            var mesh = Mesh;\n            mesh.AddText(labelRect, IMStyle.FontSize, label, IMStyle.FontColor);\n            if (!showValue) return;\n            var span = ScratchBuffer.AsSpan();", "            if (!showValue) return;\n            var span = ScratchBuffer.AsSpan();\n            if (default(TFormatter).TryFormat(value, span, out var charsWritten)) {\n                mesh.AddText(valueRect, IMStyle.FontSize, span[.. charsWritten], IMStyle.FontColor);\n            }\n        }\n\n        public static bool FloatField(Rect rect, Str label, ref float value, float min = float.MinValue,\n            float max = float.MaxValue) {\n            var showValue = rect.DivideToLabelAndValue(out var labelRect, out var valueRect);\n            Label(labelRect, label);\n            var contains = labelRect.ContainsActiveMouse();\n            _LRCursorNeeded |= contains;\n            var focusState = labelRect.GetFocusState();", "            if (focusState == FocusState.NewFocus) {\n                HoldingValue = value;\n                ValueHoldingPosX = ScreenMousePos.x;\n                if (showValue) {\n                    var mesh = Mesh;\n                    mesh.AddRect(valueRect, UiColor.Black);\n                    var buffer = ScratchBuffer.AsSpan();\n                    value.TryFormat(buffer, out var charsWritten);\n                    mesh.AddText(valueRect, IMStyle.FontSize, buffer[..charsWritten], IMStyle.FontColor);\n                }\n            }", "            else if (focusState == FocusState.Focus) {\n                _LRCursorNeeded = true;\n                var changed = false;\n                var deltaX = ScreenMousePos.x - ValueHoldingPosX;\n                var v = (float) (HoldingValue + deltaX / IMStyle.FontSize*IMStyle.DragNumberScale);\n                v = Mathf.Clamp(v, min, max);\n                if (v != value) {\n                    value = Mathf.Floor(v * 100) / 100;\n                    changed = true;\n                }\n", "                if (showValue) {\n                    var mesh = Mesh;\n                    mesh.AddRect(valueRect, UiColor.Black);\n                    var buffer = ScratchBuffer.AsSpan();\n                    value.TryFormat(buffer, out var charsWritten);\n                    mesh.AddText(valueRect, IMStyle.FontSize, buffer[..charsWritten], IMStyle.FontColor);\n                }\n\n                return changed;\n            }\n", "            if (!showValue) return false;\n            return InputField<SingleParserFormatter, float>(valueRect, ref value);\n        }\n\n        public static bool FloatField(Rect rect, float labelWidth, Str label, ref float value) {\n            var showValue = rect.TryDivide(labelWidth, out var labelRect, out var valueRect);\n            Label(labelRect, label);\n            var contains = labelRect.ContainsActiveMouse();\n            _LRCursorNeeded |= contains;\n            var focusState = labelRect.GetFocusState();\n            if (focusState == FocusState.NewFocus) {\n                HoldingValue = value;\n                ValueHoldingPosX = ScreenMousePos.x;", "            if (focusState == FocusState.NewFocus) {\n                HoldingValue = value;\n                ValueHoldingPosX = ScreenMousePos.x;\n                if (showValue) {\n                    var mesh = Mesh;\n                    mesh.AddRect(valueRect, UiColor.Black);\n                    var buffer = ScratchBuffer.AsSpan();\n                    value.TryFormat(buffer, out var charsWritten);\n                    mesh.AddText(valueRect, IMStyle.FontSize, buffer[..charsWritten], IMStyle.FontColor);\n                }\n            }", "            else if (focusState == FocusState.Focus) {\n                _LRCursorNeeded = true;\n                var changed = false;\n                var deltaX = ScreenMousePos.x - ValueHoldingPosX;\n                var v = (float) (HoldingValue + deltaX / IMStyle.FontSize*IMStyle.DragNumberScale);\n                v = Mathf.Floor(v * 100) / 100;\n                if (v != value) {\n                    value = v;\n                    changed = true;\n                }\n", "                if (showValue) {\n                    var mesh = Mesh;\n                    mesh.AddRect(valueRect, UiColor.Black);\n                    var buffer = ScratchBuffer.AsSpan();\n                    value.TryFormat(buffer, out var charsWritten);\n                    mesh.AddText(valueRect, IMStyle.FontSize, buffer[..charsWritten], IMStyle.FontColor);\n                }\n\n                return changed;\n            }\n", "            if (!showValue) return false;\n            return InputField<SingleParserFormatter, float>(valueRect, ref value);\n        }\n\n        public static bool FloatField(Str label, ref float value, float min = float.MinValue,\n            float max = float.MaxValue) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return false;\n\n            return FloatField(rect, label, ref value, min, max);\n        }\n", "        public static bool Vector2Field(Rect rect, Str label, ref Vector2 value) {\n            var showValue = rect.DivideToLabelAndValue(out var labelRect, out var valueRect);\n            Label(labelRect, label);\n            if (!showValue) return false;\n            var xRect = valueRect;\n            xRect.width = valueRect.width / 2;\n            var change = FloatField(xRect, IMStyle.FontSize*1.2f, \"X\", ref value.x);\n           \n            var yRect = new Rect(xRect.xMax, xRect.yMin, xRect.width , xRect.height);\n            if (0 < yRect.width) change |= FloatField(yRect, IMStyle.FontSize*1.2f, \"Y\", ref value.y);\n            return change;\n        }\n      ", "            if (0 < yRect.width) change |= FloatField(yRect, IMStyle.FontSize*1.2f, \"Y\", ref value.y);\n            return change;\n        }\n      \n        public static void Vector2Field(Rect rect, Str label,  Vector2 value) {\n            var showValue = rect.DivideToLabelAndValue(out var labelRect, out var valueRect);\n            Label(labelRect, label);\n            if (!showValue) return ;\n            var xRect = valueRect;\n            var padding = IMStyle.FontSize / 4f;\n            xRect.width = valueRect.width / 2-padding;\n            FloatField(xRect, IMStyle.FontSize, \"X\",  value.x);\n            var yRect = new Rect(xRect.xMax+ padding, xRect.yMin, xRect.width , xRect.height);", "            if (0 < yRect.width)  FloatField(yRect, IMStyle.FontSize, \"Y\",  value.y);\n        }\n\n        public static bool Vector2Field(Str label, ref Vector2 value) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return false;\n            return Vector2Field(rect, label, ref value);\n        }\n        public static bool Vector2Field(Str label,  Vector2 value,out Vector2 newValue) {\n            if (Vector2Field(label,ref value)) {\n                newValue = value;\n                return true;\n            }\n            newValue = value;\n            return false;\n        }", "            if (Vector2Field(label,ref value)) {\n                newValue = value;\n                return true;\n            }\n            newValue = value;\n            return false;\n        }\n        public static bool Vector3Field(Rect rect, Str label, ref Vector3 value) {\n            var showValue = rect.DivideToLabelAndValue(out var labelRect, out var valueRect);\n            Label(labelRect, label);\n            if (!showValue) return false;\n            var xRect = valueRect;\n            xRect.width = valueRect.width / 3;\n            var change = FloatField(xRect, IMStyle.FontSize*1.2f, \"X\", ref value.x);\n            var yRect = new Rect(xRect.xMax, xRect.yMin, xRect.width , xRect.height);\n            change |= FloatField(yRect, IMStyle.FontSize * 1.2f, \"Y\", ref value.y);\n            var zRect = new Rect(yRect.xMax, yRect.yMin, yRect.width , yRect.height);\n            change |= FloatField(zRect, IMStyle.FontSize * 1.2f, \"Z\", ref value.z);\n            return change;\n        }\n        ", "            if (!showValue) return false;\n            var xRect = valueRect;\n            xRect.width = valueRect.width / 3;\n            var change = FloatField(xRect, IMStyle.FontSize*1.2f, \"X\", ref value.x);\n            var yRect = new Rect(xRect.xMax, xRect.yMin, xRect.width , xRect.height);\n            change |= FloatField(yRect, IMStyle.FontSize * 1.2f, \"Y\", ref value.y);\n            var zRect = new Rect(yRect.xMax, yRect.yMin, yRect.width , yRect.height);\n            change |= FloatField(zRect, IMStyle.FontSize * 1.2f, \"Z\", ref value.z);\n            return change;\n        }\n        ", "        public static bool Vector3Field(Str label, ref Vector3 value) {\n            if (!Current.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) return false;\n            return Vector3Field(rect, label, ref value);\n        }\n        public static (FocusState state, bool containsMouse) GetFocusState(Rect rect, bool needMouse = true) {\n            var containsMouse = rect.ContainsActiveMouse();\n            return (rect.GetFocusState(), containsMouse);\n        }\n        public static bool Vector3Field(Str label,  Vector3 value,out Vector3 newValue) {\n            if (Vector3Field(label,ref value)) {\n                newValue = value;\n                return true;\n            }\n            newValue = value;\n            return false;\n        }", "        public static bool Vector3Field(Str label,  Vector3 value,out Vector3 newValue) {\n            if (Vector3Field(label,ref value)) {\n                newValue = value;\n                return true;\n            }\n            newValue = value;\n            return false;\n        }\n        public static bool InputField<T, TValue>(Rect rect, ref TValue value)\n            where T : struct, IParserFormatter<TValue> {\n            var focusState = rect.GetFocusState(false);", "        public static bool InputField<T, TValue>(Rect rect, ref TValue value)\n            where T : struct, IParserFormatter<TValue> {\n            var focusState = rect.GetFocusState(false);\n            if (focusState == FocusState.Focus) {\n                var state = DrawAndGetInputState(rect);\n                var buffer = _inputBuffer.AsSpan();\n                switch (state) {\n                    case InputState.InputIsNull: {\n                        value = default;\n                        return true;\n                    }\n                    case InputState.Change: {\n                        default(T).TryParse(buffer[.._inputFieldData.Length], out value);\n                        return true;\n                    }\n                    case InputState.NoChange: return false;\n                    case InputState.Enter: return false;\n                    default: throw new NotImplementedException();\n                }\n            }\n\n            var mesh = Mesh;\n            mesh.AddRect(rect, UiColor.Black);", "            if (focusState == FocusState.NewFocus) {\n                var buffer = _inputBuffer.AsSpan();\n                default(T).TryFormat(value, buffer, out var charsWritten);\n                _inputFieldData.Length = charsWritten;\n                _inputFieldData.CaretPosition = charsWritten;\n                mesh.AddText(rect,IMStyle.FontSize, buffer[..charsWritten], IMStyle.FontColor);\n            }\n            else {\n                var buffer = ScratchBuffer.AsSpan();\n                default(T).TryFormat(value, buffer, out var charsWritten);\n                Mesh.AddText(rect,IMStyle.FontSize, buffer[..charsWritten], IMStyle.FontColor);\n            }\n\n            return false;\n        }\n", "        public static bool StringField(Str label, ref string value) {\n            if (!Current.TryGetNextRect(out var rect)) return false;\n            return StringField(rect, label, ref value);\n        }\n\n        public static bool StringField(Rect rect, Str label, ref string value) {\n            var showValue = rect.DivideToLabelAndValue(out var labelRect, out var valueRect);\n            Label(labelRect, label);\n            if (!showValue) return false;\n            return InputField(valueRect, ref value);\n        }\n", "            if (!showValue) return false;\n            return InputField(valueRect, ref value);\n        }\n\n        public static bool InputField(Rect rect, ref string value) {\n            var focusState = rect.GetFocusState(false);\n            if (focusState == FocusState.Focus) {\n                var state = DrawAndGetInputState(rect);\n                var buffer = _inputBuffer.AsSpan();\n                switch (state) {\n                    case InputState.InputIsNull: {\n                        value = default;\n                        return true;\n                    }\n                    case InputState.Change: {\n                        value = buffer[.._inputFieldData.Length].ToString();\n                        return true;\n                    }\n                    case InputState.NoChange: return false;\n                    case InputState.Enter: return false;\n                    default: throw new NotImplementedException();\n                }\n            }\n\n            var mesh = Mesh;\n            mesh.AddRect(rect, UiColor.Black);", "            if (focusState == FocusState.NewFocus) {\n                if (string.IsNullOrEmpty(value)) {\n                    _inputFieldData.Length = 0;\n                    _inputFieldData.CaretPosition = 0;\n                    return false;\n                }\n\n                var buffer = _inputBuffer.AsSpan();\n                var length = value.Length;\n                value.AsSpan().CopyTo(buffer[..length]);\n                _inputFieldData.Length = length;\n                _inputFieldData.CaretPosition = length;\n                mesh.AddText(rect,IMStyle.FontSize, value, IMStyle.FontColor);\n            }\n            else {\n                Mesh.AddText(rect,IMStyle.FontSize, value, IMStyle.FontColor);\n            }\n\n            return false;\n        }\n\n", "        public static void VerticalScroll(Rect rect, ref float value, float size, out float top, out float bottom) {\n            var instance = Mesh;\n            var barHeight = rect.height * size;\n            var barWidth = rect.width * 0.95f;\n            var remainHeight = rect.height * (1 - size);\n            instance.AddRect(rect,  UiColor.Black);\n            var focusState = rect.GetFocusState();\n            if (focusState == FocusState.NewFocus) {\n                ValueHoldingPosY = ScreenMousePos.y;\n                var currentY = ValueHoldingPosY;\n                var barYMin = rect.yMin + (1 - value) * remainHeight;", "                if (currentY < barYMin) {\n                    value = 1 + (rect.yMin - currentY) / remainHeight;\n                }\n                else if (barYMin + barHeight < currentY) {\n                    value = (rect.yMax - currentY) / remainHeight;\n                }\n\n                HoldingValue = value;\n            }\n            else if (focusState == FocusState.Focus) {\n                value = (float) HoldingValue - (ScreenMousePos.y - ValueHoldingPosY) / remainHeight;\n            }\n\n            {\n                value = Mathf.Clamp(value, 0, 1);\n                var barRect = new Rect(rect.xMin + rect.width * 0.025f,\n                    rect.yMin + (1 - value) * rect.height * (1 - size),\n                    barWidth,\n                    barHeight);\n                instance.AddRect(barRect, IMStyle.BasicColor);\n                top = value * (1 - size);\n                bottom = 1 - (1 - value) * (1 - size);\n            }\n        }\n", "            else if (focusState == FocusState.Focus) {\n                value = (float) HoldingValue - (ScreenMousePos.y - ValueHoldingPosY) / remainHeight;\n            }\n\n            {\n                value = Mathf.Clamp(value, 0, 1);\n                var barRect = new Rect(rect.xMin + rect.width * 0.025f,\n                    rect.yMin + (1 - value) * rect.height * (1 - size),\n                    barWidth,\n                    barHeight);\n                instance.AddRect(barRect, IMStyle.BasicColor);\n                top = value * (1 - size);\n                bottom = 1 - (1 - value) * (1 - size);\n            }\n        }\n", "        public static bool Slider(Rect rect, ref float value, float min, float max) {\n            var instance = Mesh;\n            var currentValue = value = Mathf.Clamp(value, min, max);\n            var ratio = (currentValue - min) / (max - min);\n            var halfWidth = 3f;\n            var newRectXMin = rect.xMin + halfWidth;\n            var newRectXMax = rect.xMax - halfWidth;\n            instance.AddRect(newRectXMin, newRectXMax, rect.yMin + rect.height / 3f, rect.yMin + rect.height / 1.5f,\n                UiColor.Black);\n            var rectWidth = newRectXMax - newRectXMin;\n            var sliderCenterX = Mathf.Lerp(newRectXMin, newRectXMax, ratio);\n            var sliderRect = new Rect(sliderCenterX - halfWidth, rect.yMin, halfWidth * 2,\n                rect.height);\n            var focus = rect.IsFocusActive();", "            if (focus) {\n                var currentX = ScreenMousePos.x;\n                currentX = Mathf.Clamp(currentX, newRectXMin, newRectXMax);\n                sliderRect.MoveX(currentX - sliderCenterX);\n                if (currentX == newRectXMax) value = max;\n                else if (currentX == newRectXMin) value = min;\n                else value = min + (max - min) * ((currentX - newRectXMin) / rectWidth);\n                instance.AddRect(sliderRect, IMStyle.BasicColor);\n                return true;\n            }\n\n            instance.AddRect(sliderRect, IMStyle.BasicColor);\n            return false;\n        }\n", "        public static bool Slider(ref int value, int min, int max, Rect rect) {\n            var instance = Mesh;\n            var currentValue = value = Mathf.Clamp(value, min, max);\n            var ratio = (float) (currentValue - min) / (max - min);\n            var halfWidth = 3f;\n            var newRectXMin = rect.xMin + halfWidth;\n            var newRectXMax = rect.xMax - halfWidth;\n            instance.AddRect(newRectXMin, newRectXMax, rect.yMin + rect.height / 3f, rect.yMin + rect.height / 1.5f,\n                UiColor.Black);\n            var rectWidth = newRectXMax - newRectXMin;\n\n            var sliderCenterX = Mathf.Lerp(newRectXMin, newRectXMax, ratio);\n            var sliderRect = new Rect(sliderCenterX - halfWidth, rect.yMin, halfWidth * 2,\n                rect.height);\n            var focus = rect.IsFocusActive();", "            if (focus) {\n                var currentX = ScreenMousePos.x;\n                currentX = Mathf.Clamp(currentX, newRectXMin, newRectXMax);\n                var range = max - min;\n                value = min + Mathf.RoundToInt(range * ((currentX - newRectXMin) / rectWidth));\n                currentX = (value - min) * rectWidth / range + newRectXMin;\n                sliderRect.MoveX(currentX - sliderCenterX);\n                instance.AddRect(sliderRect, IMStyle.BasicColor);\n                return true;\n            }\n\n            instance.AddRect(sliderRect, IMStyle.BasicColor);\n            return false;\n        }\n", "        public static bool SlidePad(float radius, out Vector2 value) {\n            if (!Current.TryGetNextRect(radius * 2, out var rect)) {\n                value = default;\n                return false;\n            }\n\n            return SlidePad(rect, out value);\n        }\n\n        public static bool RectResize(ref Rect rect, Vector2 minimumSize) {\n            var instance = Mesh;\n            var bottomLeft = new Vector2(rect.xMax, rect.yMin);\n            var leftX = bottomLeft.x - 20;\n            var holdRect = new Rect(leftX, bottomLeft.y, 20, 20);\n            instance.AddBottomRightTriangle(holdRect, UiColor.Blue);\n            var contains = holdRect.ContainsActiveMouse();", "        public static bool RectResize(ref Rect rect, Vector2 minimumSize) {\n            var instance = Mesh;\n            var bottomLeft = new Vector2(rect.xMax, rect.yMin);\n            var leftX = bottomLeft.x - 20;\n            var holdRect = new Rect(leftX, bottomLeft.y, 20, 20);\n            instance.AddBottomRightTriangle(holdRect, UiColor.Blue);\n            var contains = holdRect.ContainsActiveMouse();\n            if (contains) {\n                RequestResizeCursor() ;\n            }\n            var focus = holdRect.GetFocusState();", "            if (focus == FocusState.Focus) {\n                RequestResizeCursor() ;\n                var delta = ScreenDeltaMousePos;\n                var newWidth = Mathf.Max(minimumSize.x, rect.width + delta.x);\n                var newHeight = Mathf.Max(minimumSize.y, rect.height - delta.y);\n                rect = new Rect(rect.xMin, rect.yMax - newHeight, newWidth, newHeight);\n                IMInput.FocusPosition = holdRect.center + delta;\n                IMInput.FocusRect = new Rect(holdRect.xMin + delta.x, holdRect.yMin + delta.y, 20, 20);\n                IMInput.IsPointerActive = false;\n                return true;\n            }\n\n            return false;\n        }\n", "        public static bool SlidePad(Rect rect, out Vector2 value) {\n            var slideRadius = Mathf.Min(rect.width, rect.height) / 2;\n            var slidePadRadius = slideRadius / 2;\n            var center = new Vector2(rect.xMin + slideRadius, rect.yMin + slideRadius);\n            var contains = IMInput.CircleContainsActiveMouse(center, slideRadius);\n            var hold = IMInput.IsFocusActive(center, slideRadius);\n            var instance = Mesh;\n            if (hold || contains)\n                instance.AddCircle(center, slideRadius + 2, UiColor.White, slideRadius, new UiColor(32, 32, 32, 255));\n            else instance.AddCircle(center, slideRadius, new UiColor(32, 32, 32, 255));\n            Vector2 delta;", "            if (hold) {\n                IMInput.FocusPosition = center;\n                var moveRadius = slideRadius - slidePadRadius;\n                var temp = (ScreenMousePos - center) / moveRadius;\n                var sqrMagnitude = temp.sqrMagnitude;\n                value = sqrMagnitude <= 1 ? temp : temp / Mathf.Sqrt(sqrMagnitude);\n                delta = value * moveRadius;\n            }\n            else {\n                value = delta = default;\n            }\n\n            instance.AddCircle(center + delta, slidePadRadius, IMStyle.UnHoveredButtonColor);\n            return hold;\n        }\n    }\n}"]}
{"filename": "Assets/ZimGui/ValueStopwatch.cs", "chunked_list": ["\ufeffusing System;\nusing System.Diagnostics;\nusing System.Globalization;\n\nnamespace ZimGui {\n    public readonly struct ValueStopwatch\n    {\n        static readonly double TimestampToTicks = TimeSpan.TicksPerSecond / (double)Stopwatch.Frequency;\n\n        readonly long _startTimestamp;\n", "        public bool IsActive => _startTimestamp != 0;\n\n        ValueStopwatch(long startTimestamp)\n        {\n            _startTimestamp = startTimestamp;\n        }\n\n        public static ValueStopwatch StartNew() => new ValueStopwatch(Stopwatch.GetTimestamp());\n\n        public TimeSpan GetElapsedTime()\n        {", "        public TimeSpan GetElapsedTime()\n        {\n            if (!IsActive)\n            {\n                throw new InvalidOperationException(\"An uninitialized, or 'default', ValueStopwatch cannot be used to get elapsed time.\");\n            }\n\n            var end = Stopwatch.GetTimestamp();\n            var timestampDelta = end - _startTimestamp;\n            var ticks = (long)(TimestampToTicks * timestampDelta);\n            return new TimeSpan(ticks);\n        }\n    }", "    public readonly struct ElapsedTimeLogger :IDisposable{\n        public static Action<string> Logger = UnityEngine.Debug.Log;\n        readonly ValueStopwatch _stopwatch;\n        public readonly string Label;\n        ElapsedTimeLogger(ValueStopwatch stopwatch) {\n            _stopwatch = stopwatch;\n            Label = null;\n        }\n        ElapsedTimeLogger(string label,ValueStopwatch stopwatch) {\n            _stopwatch = stopwatch;\n            Label = label;\n        }", "        public static ElapsedTimeLogger StartNew() =>new (ValueStopwatch.StartNew());\n        public static ElapsedTimeLogger StartNew(string label) =>new (label,ValueStopwatch.StartNew());\n\n        public void Dispose() {\n            Log();\n        }\n        public void Log() {\n            if (Label != null)\n                Logger(Label + \" : \" + _stopwatch.GetElapsedTime().TotalMilliseconds.ToString(CultureInfo.InvariantCulture) + \" ms\");\n            else  Logger(_stopwatch.GetElapsedTime().TotalMilliseconds.ToString(CultureInfo.InvariantCulture) + \" ms\");\n        }\n    }\n}"]}
{"filename": "Assets/ZimGui/ZimGuiManager.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing TMPro;\nusing UnityEngine;\n\nusing ZimGui.Core;\nusing UnityEngine.Profiling;\n\nnamespace ZimGui {\n    public class ZimGuiManager :MonoBehaviour{\n       public Camera TargetCamera;\n        [SerializeField] TMP_FontAsset _fontAsset;\n        [SerializeField] TextAsset _data;\n        [SerializeField] Texture2D _fontTexture;\n        [SerializeField] Material _material;\n        [SerializeField] Material _textureMaterial;\n\n        [SerializeField] Texture2D ResizeCursor;\n        [SerializeField] Texture2D LRCursor;\n        \n\n        void Awake() {\n            DontDestroyOnLoad(gameObject);", "namespace ZimGui {\n    public class ZimGuiManager :MonoBehaviour{\n       public Camera TargetCamera;\n        [SerializeField] TMP_FontAsset _fontAsset;\n        [SerializeField] TextAsset _data;\n        [SerializeField] Texture2D _fontTexture;\n        [SerializeField] Material _material;\n        [SerializeField] Material _textureMaterial;\n\n        [SerializeField] Texture2D ResizeCursor;\n        [SerializeField] Texture2D LRCursor;\n        \n\n        void Awake() {\n            DontDestroyOnLoad(gameObject);", "            if (TargetCamera == null) {\n                TargetCamera = Camera.main;\n            }\n\n            UiMesh uiMesh;\n            if (_fontAsset != null) {\n                uiMesh = new UiMesh(_fontAsset, _material);\n            }\n            else {\n                uiMesh = new UiMesh(_data.bytes.AsSpan(), _fontTexture, _material);\n            }\n\n            uiMesh.SetUpForTexture(_textureMaterial, 10);\n            IM.Init(uiMesh, TargetCamera);\n            IM.LRCursor = LRCursor;\n            IM.ResizeCursor = ResizeCursor;\n            IM.InsertNewFrameToPostEarlyUpdate();\n            IM.InsertEndFrameToPrePostLateUpdate();\n        }\n\n        void OnDestroy() {\n            IM.Dispose();\n        }\n\n      \n    }\n}"]}
{"filename": "Assets/ZimGui/Coordinate.cs", "chunked_list": ["\ufeffnamespace ZimGui {\n    public enum Coordinate {\n        TopLeft,\n        /// <summary>\n        /// Default\n        /// </summary>\n        BottomLeft,\n    }\n}"]}
{"filename": "Assets/ZimGui/PlayerLoopInserter.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing UnityEngine.LowLevel;\nusing UnityEngine.PlayerLoop;\n\nnamespace ZimGui {\n    \n\n    public enum InsertType {\n        Before,\n        After,\n        First,\n        Last,\n    }", "\n    public enum InsertType {\n        Before,\n        After,\n        First,\n        Last,\n    }\n    public static class PlayerLoopInserter {\n\n        public static void InsertSystem(Type thisLoop,Type parentLoopType,InsertType insertType,PlayerLoopSystem.UpdateFunction function) {\n            var mySystem = new PlayerLoopSystem\n            {\n                type = thisLoop,\n                updateDelegate = function,\n            };\n            var playerLoop = PlayerLoop.GetCurrentPlayerLoop();\n            switch (insertType) {\n                case InsertType.First :{ var subSystemList = playerLoop.subSystemList.AsSpan();", "        public static void InsertSystem(Type thisLoop,Type parentLoopType,InsertType insertType,PlayerLoopSystem.UpdateFunction function) {\n            var mySystem = new PlayerLoopSystem\n            {\n                type = thisLoop,\n                updateDelegate = function,\n            };\n            var playerLoop = PlayerLoop.GetCurrentPlayerLoop();\n            switch (insertType) {\n                case InsertType.First :{ var subSystemList = playerLoop.subSystemList.AsSpan();\n                    foreach (ref var subSystem in subSystemList) {\n                        if (subSystem.type == parentLoopType) {\n                            subSystem.subSystemList = subSystem.subSystemList.Prepend(mySystem).ToArray();\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case InsertType.Last :{ var subSystemList = playerLoop.subSystemList.AsSpan();", "                    foreach (ref var subSystem in subSystemList) {\n                        if (subSystem.type == parentLoopType) {\n                            subSystem.subSystemList = subSystem.subSystemList.Prepend(mySystem).ToArray();\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case InsertType.Last :{ var subSystemList = playerLoop.subSystemList.AsSpan();\n                    foreach (ref var subSystem in subSystemList) {\n                        if (subSystem.type == parentLoopType) {\n                            subSystem.subSystemList = subSystem.subSystemList.Append(mySystem).ToArray();\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case InsertType.Before :{ \n                    var subSystemList = RemoveRunner(playerLoop,thisLoop);", "                    foreach (ref var subSystem in subSystemList) {\n                        if (subSystem.type == parentLoopType) {\n                            subSystem.subSystemList = subSystem.subSystemList.Append(mySystem).ToArray();\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case InsertType.Before :{ \n                    var subSystemList = RemoveRunner(playerLoop,thisLoop);\n                    for (var index = 0; index < playerLoop.subSystemList.Length; index++) {", "                    for (var index = 0; index < playerLoop.subSystemList.Length; index++) {\n                        if (subSystemList[index].type == parentLoopType) {\n                            playerLoop.subSystemList = playerLoop.subSystemList.Insert(index, mySystem).ToArray();\n                            break;\n                        }\n                    }\n\n                    break;\n                } \n                case InsertType.After:{ \n                    var subSystemList = RemoveRunner(playerLoop,thisLoop);", "                    for (var index = 0; index < playerLoop.subSystemList.Length; index++) {\n                        if (subSystemList[index].type == parentLoopType) {\n                            playerLoop.subSystemList = playerLoop.subSystemList.Insert(index+1, mySystem).ToArray();\n                            break;\n                        }\n                    }\n\n                    break;\n                }\n            }\n           \n            \n            PlayerLoop.SetPlayerLoop(playerLoop);\n        }\n        static PlayerLoopSystem[] RemoveRunner(PlayerLoopSystem loopSystem,  Type loopRunnerType)\n        {\n            \n            return loopSystem.subSystemList\n                .Where(ls =>   ls.type != loopRunnerType)\n                .ToArray();\n        }static PlayerLoopSystem[] RemoveRunner(PlayerLoopSystem loopSystem,  Type loopRunnerType1,Type loopRunnerType2)\n        {\n            \n            return loopSystem.subSystemList\n                .Where(ls =>   ls.type != loopRunnerType1&&ls.type!=loopRunnerType2)\n                .ToArray();\n        }", "        public static void RemoveRunner( Type loopRunnerType)\n        {\n            var playerLoop = PlayerLoop.GetCurrentPlayerLoop();\n            playerLoop.subSystemList = RemoveRunner(playerLoop, loopRunnerType);\n            PlayerLoop.SetPlayerLoop(playerLoop);\n        }\n        public static void RemoveRunner(  Type loopRunnerType1,Type loopRunnerType2)\n        {\n            var playerLoop = PlayerLoop.GetCurrentPlayerLoop();\n            playerLoop.subSystemList = RemoveRunner(playerLoop, loopRunnerType1,loopRunnerType2);\n            PlayerLoop.SetPlayerLoop(playerLoop);\n        }\n", "        public static IEnumerable<T> Insert<T>(this IEnumerable<T> enumerable,int index,T element) {\n            var current = 0;\n            foreach (var e in enumerable) {\n                if (current++ == index) {\n                    yield return element;\n                }\n                yield return e;\n            }\n        }\n    }\n}"]}
{"filename": "Assets/ZimGui/Window.cs", "chunked_list": ["\ufeffusing System;\nusing UnityEngine;\n\nnamespace ZimGui {\n\n\n    public class Window  {\n        public string Name;\n        public readonly int WindowID;\n        static int _lastWindowID;\n        public Rect Rect;", "        public readonly int WindowID;\n        static int _lastWindowID;\n        public Rect Rect;\n        public Vector2 NextPosition;\n        public bool Opened;\n        public bool Held;\n        \n        public static void Init() {\n            _lastWindowID = 0;\n        }\n\n        public Window(string name, Rect rect) {\n            WindowID = _lastWindowID++;\n            Name = name;\n            Rect = rect;\n            NextPosition = default;\n        }\n        public Window() {\n            WindowID = _lastWindowID++;\n            NextPosition = default;\n        }\n", "        public void ResetNext() {\n            NextPosition = new Vector2(Rect.xMin, Rect.yMax);\n        }\n\n        public void Draw(int frame) {\n            var instance = IM.Mesh;\n            instance.AddRect(Rect, IMStyle.WindowBackGroundColor);\n            var fontSize = IMStyle.FontSize;\n            var topLeft = new Vector2(Rect.xMin, Rect.yMax);\n            var labelPos = new Vector2(Rect.xMin, Rect.yMax - IMStyle.SpacedTextHeight);\n            var gradientRect = new Rect(labelPos, new Vector2(Rect.width, IMStyle.SpacedTextHeight));\n            instance.AddHorizontalGradient(gradientRect, IMStyle.WindowLabelLeftColor, IMStyle.WindowLabelRightColor);\n            instance.AddText(gradientRect, fontSize, Name, Color.white);\n            NextPosition = new Vector2(topLeft.x+fontSize/5, topLeft.y - IMStyle.SpacedTextHeight);\n        }\n", "        public void Draw(int frame, ref bool isOpen) {\n            if (!isOpen) return;\n            var instance = IM.Mesh;\n            var fontSize = IMStyle.FontSize;\n            var spacedSize = IMStyle.SpacedTextHeight;\n            var topLeft = new Vector2(Rect.xMin, Rect.yMax);\n            var labelPos = new Vector2(Rect.xMin, Rect.yMax - spacedSize);\n            var closeRect = new Rect(Rect.xMax - spacedSize, labelPos.y, spacedSize, spacedSize);\n            var closeButtonContainsMouse = closeRect.ContainsActiveMouse();\n            if (closeButtonContainsMouse) {\n                if (IM.TryConsumeLeftMouseDown()) {\n                    isOpen = false;\n                    return;\n                }\n            }\n\n            instance.AddRect(Rect, IMStyle.WindowBackGroundColor);\n            var gradientRect = new Rect(labelPos, new Vector2(Rect.width, IMStyle.SpacedTextHeight));\n            instance.AddHorizontalGradient(gradientRect, IMStyle.WindowLabelLeftColor, IMStyle.WindowLabelRightColor);", "            if (closeButtonContainsMouse) {\n                if (IM.TryConsumeLeftMouseDown()) {\n                    isOpen = false;\n                    return;\n                }\n            }\n\n            instance.AddRect(Rect, IMStyle.WindowBackGroundColor);\n            var gradientRect = new Rect(labelPos, new Vector2(Rect.width, IMStyle.SpacedTextHeight));\n            instance.AddHorizontalGradient(gradientRect, IMStyle.WindowLabelLeftColor, IMStyle.WindowLabelRightColor);\n            if (closeButtonContainsMouse) {\n                instance.AddRect(closeRect, new UiColor(200,0,0,255));\n            }\n\n            instance.AddChar(new Vector2(Rect.xMax - spacedSize/2, Rect.yMax-spacedSize/2), fontSize, 'x',\n                Color.white);\n            gradientRect.width -= spacedSize;\n            instance.AddText(gradientRect, fontSize, Name, Color.white);\n            NextPosition = new Vector2(topLeft.x+fontSize/4, topLeft.y - spacedSize);\n        }\n", "            if (closeButtonContainsMouse) {\n                instance.AddRect(closeRect, new UiColor(200,0,0,255));\n            }\n\n            instance.AddChar(new Vector2(Rect.xMax - spacedSize/2, Rect.yMax-spacedSize/2), fontSize, 'x',\n                Color.white);\n            gradientRect.width -= spacedSize;\n            instance.AddText(gradientRect, fontSize, Name, Color.white);\n            NextPosition = new Vector2(topLeft.x+fontSize/4, topLeft.y - spacedSize);\n        }\n", "        public float InnerWidth => Rect.width - IMStyle.FontSize / 2;\n        public float InnerYMin => Rect.yMin + 20;\n\n        public void ApplyDrag() {\n            if (!IMInput.IsPointerActive) {\n                Held = false;\n                return;\n            }\n            if (IMInput.IsPointerDownActive) {\n                Held = Rect.ContainsActiveMouse();\n                if (Held) IMInput.IsPointerDownActive = false;\n            }", "            if (IMInput.IsPointerDownActive) {\n                Held = Rect.ContainsActiveMouse();\n                if (Held) IMInput.IsPointerDownActive = false;\n            }\n            else if (Held) {\n                Rect.Move(IM.ScreenDeltaMousePos);\n            }\n\n        }\n\n", "        public bool TryGetNextRect(float height, out Rect rect) {\n            var nextY = NextPosition.y - height;\n            if (nextY < Rect.yMin) {\n                rect = default;\n                NextPosition.y = nextY;\n                IMStyle.HorizontalDivisionsProgress = 0;\n                return false;\n            }\n            var space = IMStyle.FontSize * IMStyle.IndentLevel;\n            var division = IMStyle.HorizontalDivisions;\n            if(division==1) {\n                rect = new Rect(NextPosition.x + space, nextY, InnerWidth - space, height);\n                NextPosition.y -= height * 1.1f;\n                return true;\n            }\n            var ratio = (float) (IMStyle.HorizontalDivisionsProgress) / division;\n            var start = NextPosition.x + space;\n            var width= InnerWidth - space;\n            rect= new Rect(start+ratio*width, nextY,width/division, height);", "            if(division==1) {\n                rect = new Rect(NextPosition.x + space, nextY, InnerWidth - space, height);\n                NextPosition.y -= height * 1.1f;\n                return true;\n            }\n            var ratio = (float) (IMStyle.HorizontalDivisionsProgress) / division;\n            var start = NextPosition.x + space;\n            var width= InnerWidth - space;\n            rect= new Rect(start+ratio*width, nextY,width/division, height);\n            if (++IMStyle.HorizontalDivisionsProgress == division) {\n                NextPosition.y -= height * 1.1f;\n                NextPosition.x = Rect.xMin+IMStyle.FontSize/4;\n                IMStyle.HorizontalDivisionsProgress = 0;\n            }\n            return true;\n        }\n        ", "            if (++IMStyle.HorizontalDivisionsProgress == division) {\n                NextPosition.y -= height * 1.1f;\n                NextPosition.x = Rect.xMin+IMStyle.FontSize/4;\n                IMStyle.HorizontalDivisionsProgress = 0;\n            }\n            return true;\n        }\n        \n        public bool TryGetNextRect(out Rect rect) {\n            return TryGetNextRect(IMStyle.SpacedTextHeight, out rect);\n        }\n      \n        ", "        public bool TryGetNextRect(out Rect rect) {\n            return TryGetNextRect(IMStyle.SpacedTextHeight, out rect);\n        }\n      \n        \n       public bool TryGetRemainRect(out Rect rect) {\n           var innerYMin = InnerYMin;\n           if (NextPosition.y <= innerYMin) {\n               rect = default;\n               return false;\n           }\n           var height = NextPosition.y - innerYMin;\n           var space = IMStyle.FontSize*IMStyle.IndentLevel;\n           rect = new Rect(NextPosition.x+space, innerYMin, InnerWidth-space, height);\n           NextPosition.y = innerYMin-0.1f;\n           return true;\n        }\n      \n", "        public bool TryGetNextRect(float width, float height, out Rect rect) {\n            var nextY = NextPosition.y - height*1.1f;\n            if (nextY < Rect.yMin) {\n                rect = default;\n                return false;\n            }\n\n            rect = new Rect(NextPosition.x, NextPosition.y - height, width, height);\n            NextPosition.y = nextY;\n            return true;\n        }\n\n", "        public Rect GetNextRectHorizontal(float width, float height) {\n            var rect = new Rect(NextPosition.x, NextPosition.y, width, height);\n            NextPosition.x += width;\n            if (Rect.xMax < NextPosition.x) {\n                Rect.xMax = NextPosition.x;\n            }\n\n            return rect;\n        }\n\n\n    }\n}"]}
{"filename": "Assets/ZimGui/CollectionUtil.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\n\nnamespace ZimGui {\n    public static class CollectionUtil {\n        abstract class Dummy<T> {\n            public T[] Items;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static Span<T> AsSpan<T>(this List<T> list) {\n            return Unsafe.As<Dummy<T>>(list).Items.AsSpan(0, list.Count);\n        }\n    }\n\n    \n\n}", "        public static Span<T> AsSpan<T>(this List<T> list) {\n            return Unsafe.As<Dummy<T>>(list).Items.AsSpan(0, list.Count);\n        }\n    }\n\n    \n\n}"]}
{"filename": "Assets/ZimGui/WObject.cs", "chunked_list": ["\ufeffusing System;\nusing UnityEngine;\n\nnamespace ZimGui {\n    public class WObject:Window {\n        public Func<bool> DrawFunction;\n\n        public WObject(string name, Rect rect, Func<bool> func) : base(name, rect) {\n            DrawFunction = func;\n        }\n        public WObject(string name, Func<bool> func) : base(name, new Rect(0,0,200,300)) {\n            DrawFunction = func;\n        }", "        public bool DrawAsElement() {\n            if (!Opened) return true;\n          return  DrawFunction();\n        }\n        public bool DrawAsWindow() {\n            if (!Opened) return true;\n            IM.Current = this;\n            IMInput.CurrentID = WindowID;\n            if (Held) {\n                IMInput.TargetID = IMInput.CurrentID;\n            }\n            DrawBackGround();\n            bool movable = !IM.RectResize(ref Rect, new Vector2(30, IMStyle.SpacedTextHeight + 20));", "            if (Held) {\n                IMInput.TargetID = IMInput.CurrentID;\n            }\n            DrawBackGround();\n            bool movable = !IM.RectResize(ref Rect, new Vector2(30, IMStyle.SpacedTextHeight + 20));\n            if (!DrawFunction()) {\n                DrawFunction = null;\n                IM.EndWindowWithOutDrag(false);\n                return false;\n            }\n            if (movable) {", "            if (movable) {\n                if (!IMInput.IsPointerActive) {\n                    Held = false;\n                }\n                else if (IMInput.IsPointerDownActive) {\n                    Held = Rect.ContainsActiveMouse();\n                    if (Held) IMInput.IsPointerDownActive = false;\n                }\n                else if (Held) {\n                    Rect.Move(IM.ScreenDeltaMousePos);\n                }\n            }\n            IM.EndWindowWithOutDrag(true);\n            return true;\n        }\n\n        void DrawBackGround() {\n            var instance = IM.Mesh;\n            var fontSize = IMStyle.FontSize;\n            var spacedSize = IMStyle.SpacedTextHeight;\n            var topLeft = new Vector2(Rect.xMin, Rect.yMax);\n            var labelPos = new Vector2(Rect.xMin, Rect.yMax - spacedSize);\n            var closeRect = new Rect(Rect.xMax - spacedSize, labelPos.y, spacedSize, spacedSize);\n            var closeButtonContainsMouse = closeRect.ContainsActiveMouse();", "                else if (Held) {\n                    Rect.Move(IM.ScreenDeltaMousePos);\n                }\n            }\n            IM.EndWindowWithOutDrag(true);\n            return true;\n        }\n\n        void DrawBackGround() {\n            var instance = IM.Mesh;\n            var fontSize = IMStyle.FontSize;\n            var spacedSize = IMStyle.SpacedTextHeight;\n            var topLeft = new Vector2(Rect.xMin, Rect.yMax);\n            var labelPos = new Vector2(Rect.xMin, Rect.yMax - spacedSize);\n            var closeRect = new Rect(Rect.xMax - spacedSize, labelPos.y, spacedSize, spacedSize);\n            var closeButtonContainsMouse = closeRect.ContainsActiveMouse();", "            if (closeButtonContainsMouse) {\n                if (IM.TryConsumeLeftMouseDown()) {\n                    Opened = false;\n                    return;\n                }\n            }\n\n            instance.AddRect(Rect, IMStyle.WindowBackGroundColor);\n            var gradientRect = new Rect(labelPos, new Vector2(Rect.width, IMStyle.SpacedTextHeight));\n            instance.AddHorizontalGradient(gradientRect, IMStyle.WindowLabelLeftColor, IMStyle.WindowLabelRightColor);\n            if (closeButtonContainsMouse) {\n                instance.AddRect(closeRect, new UiColor(200,0,0,255));\n            }\n\n            instance.AddChar(new Vector2(Rect.xMax -spacedSize/2,  Rect.yMax-spacedSize/2), fontSize, 'x',\n                Color.white);\n            gradientRect.width -= spacedSize;\n            instance.AddText(gradientRect, fontSize, Name, Color.white);\n            NextPosition = new Vector2(topLeft.x+fontSize/4, topLeft.y - spacedSize);\n        }\n\n    }\n}", "            if (closeButtonContainsMouse) {\n                instance.AddRect(closeRect, new UiColor(200,0,0,255));\n            }\n\n            instance.AddChar(new Vector2(Rect.xMax -spacedSize/2,  Rect.yMax-spacedSize/2), fontSize, 'x',\n                Color.white);\n            gradientRect.width -= spacedSize;\n            instance.AddText(gradientRect, fontSize, Name, Color.white);\n            NextPosition = new Vector2(topLeft.x+fontSize/4, topLeft.y - spacedSize);\n        }\n\n    }\n}"]}
{"filename": "Assets/ZimGui/ParserFormatters.cs", "chunked_list": ["\ufeffusing System;\nusing ZimGui.Core;\nusing UnityEngine;\nnamespace ZimGui {\n    \n    public interface IParserFormatter<T>:IFormatter<T> {\n        public bool TryParse(ReadOnlySpan<char> text, out T value);\n        public T SetDefault(Span<char> text, out int charsWritten);\n    }\n    \n    public struct Int32ParserFormatter:IParserFormatter<int> {", "    public struct Int32ParserFormatter:IParserFormatter<int> {\n        public bool TryParse(ReadOnlySpan<char> text, out int value) => int.TryParse(text, out value);\n        public bool TryFormat(int value, Span<char> text, out int charsWritten) => value.TryFormat(text, out charsWritten);\n        public int SetDefault(Span<char> text, out int charsWritten) {\n            text[0] = '0';\n            charsWritten = 1;\n            return 0;\n        }\n    }\n    public struct SingleParserFormatter:IParserFormatter<float> {\n        public bool TryParse(ReadOnlySpan<char> text, out float value) => float.TryParse(text, out value);", "    public struct SingleParserFormatter:IParserFormatter<float> {\n        public bool TryParse(ReadOnlySpan<char> text, out float value) => float.TryParse(text, out value);\n        public bool TryFormat(float value, Span<char> text, out int charsWritten) => value.TryFormat(text, out charsWritten,IMStyle.FloatFormat);\n        public float SetDefault(Span<char> text, out int charsWritten) {\n            text[0] = '0';\n            charsWritten = 1;\n            return 0;\n        }\n    }\n    public interface IElementParserFormatter<T> {\n        public bool TryParse(ReadOnlySpan<char> text,char separator,out int charsRead, out T value);", "    public interface IElementParserFormatter<T> {\n        public bool TryParse(ReadOnlySpan<char> text,char separator,out int charsRead, out T value);\n        public bool TryFormat(T value,Span<char> text, out int charsWritten);\n        public T SetDefault(Span<char> text, out int charsWritten);\n    }\n   \n   \n    public interface IOverWritingParserFormatter<in T> {\n        public bool TryParse(ReadOnlySpan<char> text,  T target);\n        public bool TryFormat(T target,Span<char> text, out int charsWritten);\n        public void SetDefault(Span<char> text,T target, out int charsWritten);", "        public bool TryParse(ReadOnlySpan<char> text,  T target);\n        public bool TryFormat(T target,Span<char> text, out int charsWritten);\n        public void SetDefault(Span<char> text,T target, out int charsWritten);\n        public void SetDefault(T value);\n    }\n  \n}"]}
{"filename": "Assets/ZimGui/FieldViewer.cs", "chunked_list": ["\ufeffusing System.Collections.Generic;\nusing System;\nusing System.Reflection;\nusing System.Runtime.CompilerServices;\nusing Unity.Collections.LowLevel.Unsafe;\nusing UnityEngine;\nusing UnityEngine.Profiling;\nusing Str=System.ReadOnlySpan<char>;\nnamespace ZimGui {\n\n   public   delegate void ReferenceViewer(Rect rect,Str text, ref byte reference,bool isReadOnly);", "namespace ZimGui {\n\n   public   delegate void ReferenceViewer(Rect rect,Str text, ref byte reference,bool isReadOnly);\n    public static class FieldView {\n         static Dictionary<(Type, string), (short,short)> Fields=new (16);\n         public static readonly int BaseOffset = UnsafeUtility.GetFieldOffset(typeof(OffSetObject).GetField(\"ByteField\"));\n\n         static ReferenceViewer[] Actions = \n            {\n                (Rect rect,Str name, ref byte b, bool isReadOnly) => {\n                    if(isReadOnly)\n                        IM.IntField(rect,name,  Unsafe.As<byte, int>(ref b));\n                    else \n                        IM.IntField(rect,name, ref Unsafe.As<byte, int>(ref b));\n                },\n                (Rect rect,Str name, ref byte b, bool isReadOnly) => {", "                    if(isReadOnly)\n                        IM.IntField(rect,name,  Unsafe.As<byte, int>(ref b));\n                    else \n                        IM.IntField(rect,name, ref Unsafe.As<byte, int>(ref b));\n                },\n                (Rect rect,Str name, ref byte b, bool isReadOnly) => {\n                    if (isReadOnly)\n                        IM.FloatField(rect,name,  Unsafe.As<byte, float>(ref b));\n                    else \n                        IM.FloatField(rect,name, ref Unsafe.As<byte, float>(ref b));\n                    \n                },\n                (Rect rect,Str name, ref byte b, bool isReadOnly) => {", "                    if (isReadOnly)\n                        IM.StringField(rect,name,  Unsafe.As<byte, string>(ref b));\n                    else \n                        IM.StringField(rect,name, ref Unsafe.As<byte, string>(ref b));\n                },\n                (Rect rect,Str name, ref byte b, bool isReadOnly) => {\n                    IM.BoolField(rect,name, ref Unsafe.As<byte, bool>(ref b));\n                },\n                \n            };\n\n         static Dictionary<Type, short> TypeToAction = new Dictionary<Type, short>(16) {\n            {typeof(int), 0},\n            {typeof(float), 1},\n            {typeof(string), 2},\n            {typeof(bool), 3},\n        };\n         static bool TryGet(Type type, string name,out (short ActionIndex,short Offset) tuple) {", "            if (Fields.TryGetValue((type, name), out  tuple)) {\n                return true;\n            }\n            var field = type.GetField(name,BindingFlags.Instance|BindingFlags.Public|BindingFlags.NonPublic);\n            if (field == null) {\n                tuple = default;\n                return false;\n            }\n\n            var fieldType = field.FieldType;\n            if (!TypeToAction.TryGetValue(fieldType,out var actionIndex))return false;\n            var offset = (short)UnsafeUtility.GetFieldOffset(field);\n          \n            tuple = (actionIndex, offset);\n             Fields.Add((type, name),tuple);\n             return true;\n        }\n       static bool TryGetAutoProperty(Type type, string name,out (short ActionIndex,short Offset) tuple) {", "            if (!TypeToAction.TryGetValue(fieldType,out var actionIndex))return false;\n            var offset = (short)UnsafeUtility.GetFieldOffset(field);\n          \n            tuple = (actionIndex, offset);\n             Fields.Add((type, name),tuple);\n             return true;\n        }\n       static bool TryGetAutoProperty(Type type, string name,out (short ActionIndex,short Offset) tuple) {\n            if (Fields.TryGetValue((type, name), out  tuple)) {\n                return true;\n            }\n            var field = type.GetField(\"<\"+name+\">k__BackingField\",BindingFlags.Instance|BindingFlags.Public|BindingFlags.NonPublic);", "            if (Fields.TryGetValue((type, name), out  tuple)) {\n                return true;\n            }\n            var field = type.GetField(\"<\"+name+\">k__BackingField\",BindingFlags.Instance|BindingFlags.Public|BindingFlags.NonPublic);\n            if (field == null) {\n                tuple = default;\n                return false;\n            }\n\n            var fieldType = field.FieldType;\n            if (!TypeToAction.TryGetValue(fieldType,out var actionIndex))return false;\n            var offset = (short)UnsafeUtility.GetFieldOffset(field);\n          \n            tuple = (actionIndex, offset);\n             Fields.Add((type, name),tuple);\n             return true;\n        }\n       \n", "            if (!TypeToAction.TryGetValue(fieldType,out var actionIndex))return false;\n            var offset = (short)UnsafeUtility.GetFieldOffset(field);\n          \n            tuple = (actionIndex, offset);\n             Fields.Add((type, name),tuple);\n             return true;\n        }\n       \n\n        abstract class OffSetObject {\n            public byte ByteField;", "        abstract class OffSetObject {\n            public byte ByteField;\n            public ref byte GetPinnableReference() => ref ByteField;\n        }\n        public static  ref T GetReference<T>( object o, int offset) {\n            return  ref Unsafe.As<byte, T>(ref Unsafe.Add(ref Unsafe.As<OffSetObject>(o).ByteField, offset - BaseOffset));\n        }\n        public static  ref byte GetReference(this object o, int offset) {\n            return  ref Unsafe.Add(ref Unsafe.As<OffSetObject>(o).ByteField, offset - BaseOffset);\n        }\n      \n\n       ", "        public static  bool ViewField(this object o, string fieldName,bool isReadOnly=true,bool useRawName=false) {\n            if(TryGet(o.GetType(),fieldName,out var tuple)) {\n                if (!IM.Current.TryGetNextRect(out var rect)) return false;\n                Actions[tuple.Item1](rect,useRawName?fieldName: GetDisplayName(fieldName),ref GetReference(o,tuple.Item2),isReadOnly);\n                return true;\n            }\n            return false;\n        }\n        public static  bool ViewAutoProperty(this object o, string fieldName,bool isReadOnly=true) {\n            if(TryGetAutoProperty(o.GetType(),fieldName,out var tuple)) {\n                if (!IM.Current.TryGetNextRect(out var rect)) return false;\n                Actions[tuple.Item1](rect,fieldName,ref GetReference(o,tuple.Item2),isReadOnly);\n                return true;\n            }\n            return false;\n        }\n       ", "        public static  bool ViewAutoProperty(this object o, string fieldName,bool isReadOnly=true) {\n            if(TryGetAutoProperty(o.GetType(),fieldName,out var tuple)) {\n                if (!IM.Current.TryGetNextRect(out var rect)) return false;\n                Actions[tuple.Item1](rect,fieldName,ref GetReference(o,tuple.Item2),isReadOnly);\n                return true;\n            }\n            return false;\n        }\n       \n        public static  bool ViewField(this object o, string fieldName,Str displayName,bool isReadOnly=true) {\n            if(TryGet(o.GetType(),fieldName,out var tuple)) {", "        public static  bool ViewField(this object o, string fieldName,Str displayName,bool isReadOnly=true) {\n            if(TryGet(o.GetType(),fieldName,out var tuple)) {\n                if (!IM.Current.TryGetNextRect(out var rect)) return false;\n                Actions[tuple.Item1](rect,displayName, ref GetReference(o,tuple.Item2),isReadOnly);\n                return true;\n            }\n            return false;\n        }\n\n      \n", "        public static void ViewElements(this Span<float> span, Str name, bool isReadOnly = true) {\n            if (span.IsEmpty) return;\n            if (10 < span.Length) span = span[..10];\n            var currentWindow = IM.Current;\n            Span<char> label = stackalloc char[name.Length + 2];\n            name.CopyTo(label[..name.Length]);\n            label[name.Length] = ' ';\n            if (isReadOnly) {\n                for (var index = 0; index < span.Length; index++) {\n                    if (!currentWindow.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) break;\n                    label[name.Length + 1] = (char) ('0' + index);\n                    IM.FloatField(rect, label, span[index]);\n                }\n            }\n            else {", "                for (var index = 0; index < span.Length; index++) {\n                    if (!currentWindow.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) break;\n                    label[name.Length + 1] = (char) ('0' + index);\n                    IM.FloatField(rect, label, span[index]);\n                }\n            }\n            else {\n                for (var index = 0; index < span.Length; index++) {\n                    if (!currentWindow.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) break;\n                    label[name.Length + 1] = (char) ('0' + index);\n                    IM.FloatField(rect, label, ref span[index]);\n                }\n            }\n        }", "                    if (!currentWindow.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) break;\n                    label[name.Length + 1] = (char) ('0' + index);\n                    IM.FloatField(rect, label, ref span[index]);\n                }\n            }\n        }\n        public static void ViewElements(this Span<int> span, Str name, bool isReadOnly = true) {\n            if (span.IsEmpty) return;\n            if (10 < span.Length) span = span[..10];\n            var currentWindow = IM.Current;\n            Span<char> label = stackalloc char[name.Length + 2];\n            name.CopyTo(label[..name.Length]);\n            label[name.Length] = ' ';", "            if (10 < span.Length) span = span[..10];\n            var currentWindow = IM.Current;\n            Span<char> label = stackalloc char[name.Length + 2];\n            name.CopyTo(label[..name.Length]);\n            label[name.Length] = ' ';\n            if (isReadOnly) {\n                for (var index = 0; index < span.Length; index++) {\n                    if (!currentWindow.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) break;\n                    label[name.Length + 1] = (char) ('0' + index);\n                    IM.IntField(rect, label, span[index]);\n                }\n            }\n            else {", "                for (var index = 0; index < span.Length; index++) {\n                    if (!currentWindow.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) break;\n                    label[name.Length + 1] = (char) ('0' + index);\n                    IM.IntField(rect, label, ref span[index]);\n                }\n            }\n        }\n        public static void ViewElements(this Span<Vector2> span, Str name, bool isReadOnly = true) {\n            if (span.IsEmpty) return;\n            if (10 < span.Length) span = span[..10];\n            var currentWindow = IM.Current;\n            Span<char> label = stackalloc char[name.Length + 2];\n            name.CopyTo(label[..name.Length]);\n            label[name.Length] = ' ';", "            if (span.IsEmpty) return;\n            if (10 < span.Length) span = span[..10];\n            var currentWindow = IM.Current;\n            Span<char> label = stackalloc char[name.Length + 2];\n            name.CopyTo(label[..name.Length]);\n            label[name.Length] = ' ';\n            if (isReadOnly) {\n                for (var index = 0; index < span.Length; index++) {\n                    if (!currentWindow.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) break;\n                    label[name.Length + 1] = (char) ('0' + index);\n                    IM.Vector2Field(rect, label, span[index]);\n                }\n            }\n            else {", "                    if (!currentWindow.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) break;\n                    label[name.Length + 1] = (char) ('0' + index);\n                    IM.Vector2Field(rect, label, span[index]);\n                }\n            }\n            else {\n                for (var index = 0; index < span.Length; index++) {\n                    if (!currentWindow.TryGetNextRect(IMStyle.SpacedTextHeight, out var rect)) break;\n                    label[name.Length + 1] = (char) ('0' + index);\n                    IM.Vector2Field(rect, label, ref span[index]);\n                }\n            }\n        }", "        public static void ViewElements(this ReadOnlySpan<float> span, Str name) {\n            var currentWindow = IM.Current;\n            foreach (var element in span) {\n                if(!currentWindow.TryGetNextRect(IMStyle.SpacedTextHeight,out var rect))break;\n                IM.FloatField(rect,name, element);\n            }\n        }\n        public static void ViewElements(this ReadOnlySpan<int> span, Str name) {\n            var currentWindow = IM.Current;\n            foreach (var element in span) {\n                if(!currentWindow.TryGetNextRect(IMStyle.SpacedTextHeight,out var rect))break;\n                IM.IntField(rect,name, element);\n            }\n        }\n        \n        static Str GetDisplayName(string name) {\n            var length = name.Length;", "            foreach (var element in span) {\n                if(!currentWindow.TryGetNextRect(IMStyle.SpacedTextHeight,out var rect))break;\n                IM.IntField(rect,name, element);\n            }\n        }\n        \n        static Str GetDisplayName(string name) {\n            var length = name.Length;\n            if (length <= 1) return name.AsSpan();\n            if (name.StartsWith('_')) {\n                return name.AsSpan(1);\n            }", "            if (length <= 1) return name.AsSpan();\n            if (name.StartsWith('_')) {\n                return name.AsSpan(1);\n            }\n            if (name.StartsWith('m') && name[1] == '_') {\n                return name.AsSpan(2);\n            }\n            return name.AsSpan();\n        }\n\n    }\n}"]}
{"filename": "Assets/ZimGui/Demo/TimeOfDay.cs", "chunked_list": ["\ufeffusing System;\nusing UnityEngine;\n\nnamespace ZimGui.Demo {\n    public readonly struct TimeOfDay {\n        public readonly int Ticks;\n    \n        public TimeOfDay(DateTime dateTime) {\n            var timeOfDay = dateTime.TimeOfDay;\n            Ticks = (int)(timeOfDay.Ticks/10000);\n        }\n", "        public int Hours => Ticks / 3600000;\n        public int FormatHoursToMilliseconds(Span<char> span) {\n            var hours = Ticks / 3600000;\n            span[0] = (char)('0' + hours / 10);\n            span[1] =(char) ('0' + (hours - 10*(hours / 10)));\n            span[2] =':';\n            var minutesTicks = Ticks - hours * 3600000;\n            var minutes = minutesTicks/ 60000;\n            span[3] = (char)('0' + minutes / 10);\n            span[4] =(char) ('0' + (minutes - 10*(minutes / 10)));\n            span[5] =':';\n            var secondsTicks = minutesTicks - minutes * 60000;\n            var seconds=(secondsTicks) / 1000;\n            span[6] = (char)('0' + seconds / 10);\n            span[7] =(char) ('0' + (seconds - 10*(seconds / 10)));\n            span[8] =':';\n            var milliSecondsTicks = secondsTicks - seconds * 1000;\n            var mill100 = milliSecondsTicks / 100;\n            span[9] = (char)('0' + mill100);\n            var mill10 = (milliSecondsTicks - mill100 * 100)/10;\n            span[10] =(char) ('0' +mill10);\n            var mill1 = milliSecondsTicks-mill100*100-mill10*10;\n            span[11] =(char) ('0' + mill1);\n            return 12;\n        }", "        public int FormatHoursToSeconds(Span<char> span) {\n            var hours = Ticks / 3600000;\n            span[0] = (char)('0' + hours / 10);\n            span[1] =(char) ('0' + (hours - 10*(hours / 10)));\n            span[2] =':';\n            var minutesTicks = Ticks - hours * 3600000;\n            var minutes = minutesTicks/ 60000;\n            span[3] = (char)('0' + minutes / 10);\n            span[4] =(char) ('0' + (minutes - 10*(minutes / 10)));\n            span[5] =':';\n            var secondsTicks = minutesTicks - minutes * 60000;\n            var seconds=(secondsTicks) / 1000;\n            span[6] = (char)('0' + seconds / 10);\n            span[7] =(char) ('0' + (seconds - 10*(seconds / 10)));\n            return 8;\n        }\n    }\n}"]}
{"filename": "Assets/ZimGui/Demo/ZimGUITest.cs", "chunked_list": ["\ufeffusing System;\nusing System.Linq;\nusing UnityEngine;\nusing Random = UnityEngine.Random;\n\nnamespace ZimGui.Demo {\n    public class ZimGUITest : MonoBehaviour {\n        void Start() {\n            var meshRenderers = FindObjectsOfType<Renderer>();\n            _transforms = meshRenderers.Select(t => t.GetComponent<Transform>()).Prepend(null).ToArray();\n            _names = new string[_transforms.Length];\n            _names[0] = \"None\";", "            for (int i = 1; i < _transforms.Length; i++) {\n                _names[i] = _transforms[i].name;\n            }\n            selectedIndex = Array.IndexOf(_transforms, Target);\n            IMStyle.WindowLabelLeftColor = LeftColor;\n            IMStyle.WindowLabelRightColor = RightColor;\n            IMStyle.FontSize = FontSize;\n            SimpleConsole.Init(50);\n            IMStyle.FloatFormat = null;\n            IM.Add(\"Settings\", DrawSettings);\n            IM.Add(\"Demo\", DrawDemo);\n            IM.Add(\"SimpleLog\",SimpleConsole.Draw);\n        }\n        static int _keyIndex = 0;\n        static string[] _keyNames = {\"Escape\", \"Tab\", \"F4\"};\n        static KeyCode[] _keyCodes = {KeyCode.Escape, KeyCode.Tab, KeyCode.F4};", "        public int FontSize;\n        public Color LeftColor = Color.clear;\n        public Color RightColor = Color.red;\n\n        public float MoveSpeed = 10;\n        int selectedIndex;\n        string[] _names;\n        Transform[] _transforms;\n        public Transform Target;\n\n", "        public Transform Target;\n\n\n        public void Log() {\n            SimpleConsole.Log(LogText, Color.HSVToRGB(Random.Range(0f, 1), 0.6f, 1));\n        }\n        public void DebugLog() {\n          Debug.Log(LogText);\n        }\n\n        bool DrawSettings() {", "            if (this == null) return false;\n            IMStyle.FontColor = 0xFFFFFFFF;\n            IM.IntField(\"FontSize \", ref FontSize, 9, 100);\n            if (IM.Button(\"Apply FontSize\"))\n                IMStyle.FontSize = FontSize;\n            if (IM.DropDownField(\"ResetKey\",_keyNames, ref _keyIndex)) {\n                DockWindow.OpenKey = _keyCodes[_keyIndex];\n            }\n\n           \n\n            return true;\n        }\n\n        bool isMoveSpeedReadonly = false;\n        [SerializeField]Vector2[] _points;\n        \n         bool _logFoldout = false;\n         bool _pointsFoldout = false;\n         bool _moveFoldout = false;\n         bool _fillFoldOut = false;\n", "        public string LogText;\n        EulerHint _hint = default;\n        bool DrawDemo() {\n            if (this == null) return false;\n            if (IM.Foldout(\"Logger\", ref _logFoldout)) {\n                using (IM.Indent()) {\n                    IM.StringField(\"LogText\", ref LogText);\n                    using (IM.HorizontalDivide(2)) {\n                        this.MethodButton(nameof(DebugLog));\n                        this.MethodButton(nameof(Log)); \n                    }\n                }\n            }", "            if (IM.Foldout(\"Points\",ref  _pointsFoldout)) {\n                using (IM.Indent()) {\n                    IMStyle.DragNumberScale = 10;\n                    _points.AsSpan().ViewElements(ReadOnlySpan<char>.Empty, false);\n                    IMStyle.DragNumberScale = 1;\n                }\n                IM.Mesh.AddLinesLoop( _points.AsSpan(),10,UiColor.Cyan);\n            }\n            if (IM.Foldout(\"Move\", ref _moveFoldout)) {\n                using (IM.Indent()) {\n                    if (IM.InputDropdownField(_names, ref selectedIndex)) {\n                        Target = _transforms[selectedIndex];", "            if (IM.Foldout(\"Move\", ref _moveFoldout)) {\n                using (IM.Indent()) {\n                    if (IM.InputDropdownField(_names, ref selectedIndex)) {\n                        Target = _transforms[selectedIndex];\n                         if(Target) _hint.EulerAngles = Target.localEulerAngles;\n                    }\n                    if (Target != null) {\n                        IM.Slider(ref MoveSpeed, -30, 30);\n                        IM.BoolField(\"ReadOnly\", ref isMoveSpeedReadonly);\n                        this.ViewField(\"MoveSpeed\", isMoveSpeedReadonly);\n                        var pos = Target.localPosition;", "                        if (IM.Vector3Field(\"Position\", ref  pos)) {\n                            Target.localPosition = pos;\n                        }\n                        if (IM.Vector3Field(\"Rotation\",_hint.GetLocalEulerAngles(Target ),out var   euler)) {\n                            _hint.EulerAngles=euler;\n                            Target.localRotation = _hint.Rotation;\n                        }\n                        if (IM.Vector3Field(\"Scale\",Target.localScale, out var    scale)) {\n                            Target.localScale = scale;\n                        }\n                        Vector3 screenPoint;\n                        Vector2 targetScreenPos;", "                         if (IM.SlidePad(20, out var v2)) {\n                             Target.localPosition = pos += (Vector3) (v2 * (Time.deltaTime * MoveSpeed));\n                             screenPoint = IM.Camera.WorldToScreenPoint(pos);\n                             targetScreenPos = new Vector2(screenPoint.x, screenPoint.y + 50);\n                             IM.Circle(IM.ScreenMousePos, 12, UiColor.Yellow);\n                            IM.Line(targetScreenPos, IM.ScreenMousePos, 8, UiColor.Green, UiColor.Yellow);\n                        }else {\n                             screenPoint = IM.Camera.WorldToScreenPoint(pos);\n                             targetScreenPos = new Vector2(screenPoint.x, screenPoint.y + 50);\n                        }\n                        IM.Circle(targetScreenPos, 20, UiColor.Green);\n                      \n                    }\n                }\n            }", "            if (IM.Foldout(\"Circle\",ref  _fillFoldOut)) {\n                using (IM.Indent()) {\n                    var fillAmount = (Time.time / 3) % 1;\n                    IM.IntField(\"FillAmount\", (int) (100 * fillAmount));\n                    if (IM.Current.TryGetNextRect(80, out var rect)) {\n                        IM.Mesh.AddRadialFilledCircle(new Vector2(rect.xMin + 40, rect.yMin + 40), 40, UiColor.White,\n                            fillAmount);\n                    }\n                }\n            }\n            return true;\n        }\n\n        void OnDestroy() {\n            SimpleConsole.Clear();\n        }\n    }\n}"]}
{"filename": "Assets/ZimGui/Demo/RingBuffer.cs", "chunked_list": ["\ufeffusing System;\n\n\nnamespace ZimGui.Demo {\n    public class RingBuffer <T>{\n        T[] _array;\n        int _startIndex;\n\n        public int Count { get; private set; }\n        public T this[int index] => _array[( _startIndex + index ) % _array.Length];\n", "        public int Count { get; private set; }\n        public T this[int index] => _array[( _startIndex + index ) % _array.Length];\n\n        public int Capacity=> _array.Length;\n        \n        public RingBufferSlice Slice(int startIndex,int length) {\n            return new RingBufferSlice(this,startIndex, length);\n        }\n        \n\n        public RingBuffer( int capacity )\n        {\n            _array = new T[capacity];\n        }\n", "        public void Clear() {\n            _array.AsSpan(0,Count).Clear();\n            Count = 0;\n            _startIndex = 0;\n        }\n        \n        public void Add( T value )\n        {\n            if( Count < _array.Length )\n                _array[Count++] = value;\n            else\n            {\n                _array[_startIndex] = value;", "            if( Count < _array.Length )\n                _array[Count++] = value;\n            else\n            {\n                _array[_startIndex] = value;\n                if( ++_startIndex >= _array.Length )\n                    _startIndex = 0;\n            }\n        }\n         public Enumerator GetEnumerator() => new Enumerator(this);\n        ", "         public Enumerator GetEnumerator() => new Enumerator(this);\n        \n        public ref struct Enumerator {\n            public readonly ReadOnlySpan<T> Span;\n            public readonly int StartIndex;\n             int _count;\n             int _index;\n\n           \n            public Enumerator(RingBuffer <T> ringBuffer) {\n                Span = ringBuffer._array.AsSpan(0,ringBuffer.Count);\n                StartIndex = ringBuffer._startIndex;\n                _count = 0;\n                _index = 0;\n            }", "            public bool MoveNext() {\n                if ((uint)_count < (uint)Span.Length) {\n                    var i = (StartIndex + _count);\n                    _index=i<Span.Length?i:i-Span.Length;                    \n                    _count++;\n                    return true;\n                }\n                return false;     \n            }\n            public T Current => Span[_index];\n        }\n", "            public T Current => Span[_index];\n        }\n\n        public readonly ref struct RingBufferSlice {\n            public readonly ReadOnlySpan<T> Span;\n            public readonly int StartIndex;\n            public readonly int Length;\n\n            public RingBufferSlice(RingBuffer <T> ringBuffer, int  start,int length) {\n                Span = ringBuffer._array.AsSpan(0,ringBuffer.Count);\n                var  i= ringBuffer._startIndex + start;\n                StartIndex = i<Span.Length?i:i-Span.Length;   \n                Length = length;\n            }\n", "            public SliceEnumerator GetEnumerator() => new SliceEnumerator(this);\n            public ref struct SliceEnumerator {\n                public readonly ReadOnlySpan<T> Span;\n                public readonly int StartIndex;\n                public readonly int Length;\n                int _count;\n                int _index;\n\n                public SliceEnumerator(RingBufferSlice slice) {\n                    Span = slice.Span;\n                    StartIndex = slice.StartIndex;\n                    Length = slice.Length;\n                    _count = 0;\n                    _index = 0;\n                }", "                public bool MoveNext() {\n                    if (_count < Length) {\n                        var i = (StartIndex + _count);\n                        _index=i<Span.Length?i:i-Span.Length;        \n                        _count++;\n                        return true;\n                    }\n                    return false;     \n                }\n                public T Current => Span[_index];\n            }\n        }\n    }\n}", "                public T Current => Span[_index];\n            }\n        }\n    }\n}"]}
{"filename": "Assets/ZimGui/Demo/SimpleConsole.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Str=System.ReadOnlySpan<char>;\nnamespace ZimGui.Demo {\n    public enum LogTimeType {\n        None,\n        Seconds,\n        MilliSeconds\n    }\n    public static class SimpleConsole {\n        static object _lock = new object();\n        static RingBuffer<(TimeOfDay Time ,string Text ,UiColor Color)> _elements;\n\n", "    public static class SimpleConsole {\n        static object _lock = new object();\n        static RingBuffer<(TimeOfDay Time ,string Text ,UiColor Color)> _elements;\n\n\n        public static int Capacity {\n            get {\n                lock (_lock) {\n                    return _elements.Capacity;\n                }\n            }\n        }", "        public static void Init(int capacity=32,bool receiveLog=true) {\n            _elements=new (capacity);\n              if(receiveLog)    Application.logMessageReceivedThreaded += ReceivedLog;\n        }\n        static void ReceivedLog(string logString, string stackTrace, LogType logType) {\n            switch (logType) {\n                case LogType.Log:Log(logString);\n                    return;\n                case LogType.Warning:\n                case LogType.Assert:\n                    Log(logString,UiColor.Yellow);\n                    return;\n                case LogType.Error:\n                case LogType.Exception:\n                    Log(logString,UiColor.Red);\n                    return;\n                default: return;\n            }\n        }\n        ", "        public static void Clear() {\n            _elements.Clear();\n            Application.logMessageReceivedThreaded -= ReceivedLog;\n        }\n        public static void Log(string text) {\n            if (_inLock) return;\n            lock (_lock) {\n                _elements.Add((new TimeOfDay(DateTime.Now),text,IMStyle.FontColor));\n            }\n            \n        }", "         public static void Log(string text,UiColor color) {\n             if (_inLock) return;\n             lock (_lock) {\n                 _elements.Add((new TimeOfDay(DateTime.Now), text, color));\n             }\n         }\n         static float scrollValue=0;\n         static bool _inLock=false;\n         \n      \n        public static bool Draw() {\n            lock (_lock) {\n                _inLock = true;", "        public static bool Draw() {\n            lock (_lock) {\n                _inLock = true;\n                try {\n                    var count = _elements.Count;\n                    if (IM.Button(\"Clear\")) {\n                        _elements.Clear();\n                        return true;\n                    }\n\n                    if (count == 0) return true;", "                    if (count == 0) return true;\n                    if (!IM.Current.TryGetRemainRect(out var rect)) return true;\n                    var height = rect.height;\n                    var elementHeight = IMStyle.SpacedTextHeight * 1.1f;\n                    var elementsHeight = elementHeight * count;\n                    var elementRect = new Rect(rect.xMin, rect.yMax - elementHeight, rect.width,\n                        IMStyle.SpacedTextHeight);\n                    if (height < IMStyle.SpacedTextHeight) {\n                        return true;\n                    }\n", "                    if (elementsHeight < height) {\n                        scrollValue = 0;\n                        Span<char> timeLabel = stackalloc char[11];\n                        timeLabel[0] = '[';\n                        timeLabel[9] = ']';\n                        timeLabel[10] = ' ';\n                        var timeRange = timeLabel[1..9];\n                        foreach (var element in _elements) {\n                            element.Time.FormatHoursToSeconds(timeRange);\n                            IM.Label(elementRect, timeLabel, element.Text, element.Color);\n                            elementRect.MoveY(-elementHeight);\n                        }\n\n                        return true;\n                    }\n                    else {\n                        var barRect = rect;\n                        barRect.xMin += rect.width - 10f;\n                        IM.VerticalScroll(barRect, ref scrollValue, height / elementsHeight, out var top,\n                            out var bottom);\n                        elementRect.xMax -= 10f;\n                        var topIndex = (int) (Mathf.Ceil(count * top));\n                        topIndex = Mathf.Clamp(topIndex, 0, count - 1);\n                        elementRect.MoveY((count * top - topIndex) * elementHeight);\n                        Span<char> timeLabel = stackalloc char[11];\n                        timeLabel[0] = '[';\n                        timeLabel[9] = ']';\n                        timeLabel[10] = ' ';\n                        var timeRange = timeLabel[1..9];", "                        foreach (var element in _elements.Slice(topIndex, (int) (height / elementHeight))) {\n                            element.Time.FormatHoursToSeconds(timeRange);\n                            IM.Label(elementRect, timeLabel, element.Text, element.Color);\n                            elementRect.MoveY(-elementHeight);\n                        }\n\n\n                        return true;\n                    }\n                }\n                finally {\n                    _inLock = false;\n                }\n                \n               \n            }\n        }\n    }\n}", "                finally {\n                    _inLock = false;\n                }\n                \n               \n            }\n        }\n    }\n}"]}
{"filename": "Assets/ZimGui/Demo/FPSSetting.cs", "chunked_list": ["\ufeffusing System;\nusing  UnityEngine;\n\npublic class FPSSetting :MonoBehaviour\n{\n    public int FPS=60;\n    private void Start()\n    {\n        Application.targetFrameRate = FPS;\n    }\n}\n"]}
{"filename": "Assets/ZimGui/Demo/ReadOnlyRingSpan.cs", "chunked_list": ["\ufeff"]}
{"filename": "Assets/ZimGui/Reflection/PropertyViewer.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq.Expressions;\nusing System.Reflection;\n\nusing Str=System.ReadOnlySpan<char>;\nnamespace ZimGui.Reflection {\n  //  public   delegate void PropertyViewer(Str text, object instance,bool isReadOnly);\n    public static class PropertyView {\n        static Dictionary<(Type, string), (int,Func<object, object>)> GetterCache=new (16);\n        public static  bool ViewProperty(this object o, string fieldName) {\n            var type=o.GetType();\n            \n            var propertyInfo = type.GetProperty(fieldName);\n            var propertyType = propertyInfo.PropertyType;\n            return false;\n        }", "    public static class PropertyView {\n        static Dictionary<(Type, string), (int,Func<object, object>)> GetterCache=new (16);\n        public static  bool ViewProperty(this object o, string fieldName) {\n            var type=o.GetType();\n            \n            var propertyInfo = type.GetProperty(fieldName);\n            var propertyType = propertyInfo.PropertyType;\n            return false;\n        }\n        public static Func<object, object> CreateGetter(PropertyInfo propertyInfo)\n        {", "        public static Func<object, object> CreateGetter(PropertyInfo propertyInfo)\n        {\n            if (propertyInfo == null) return null;\n#if !UNITY_EDITOR&&ENABLE_IL2CPP\n                return propertyInfo.GetValue;\n#else \n            if (propertyInfo.GetGetMethod(true).IsStatic)  {\n                Expression body = Expression.Convert(Expression.MakeMemberAccess(null, propertyInfo), typeof(object));\n                var lambda = Expression.Lambda<Func<object>>(body).Compile();\n                return _ => lambda();\n      \n            }", "            if (propertyInfo.DeclaringType != null)\n            {\n                var objParam = Expression.Parameter(typeof(object), \"obj\");\n                var tParam = Expression.Convert(objParam, propertyInfo.DeclaringType);\n                Expression body = Expression.Convert(Expression.MakeMemberAccess(tParam, propertyInfo), typeof(object));\n                return Expression.Lambda<Func<object, object>>(body, objParam).Compile();\n            }\n            return null;\n#endif    \n        }\n    }\n}"]}
{"filename": "Assets/ZimGui/Reflection/MethodView.cs", "chunked_list": ["\ufeffusing System.Reflection;\n\nnamespace ZimGui.Reflection {\n    public static class MethodView {\n        \n    }\n}"]}
{"filename": "Assets/ZimGui/Editor/AssetWindow.cs", "chunked_list": ["\ufeffusing System.IO;\nusing ZimGui.Core;\nusing TMPro;\n#if UNITY_EDITOR\nusing UnityEditor;\nusing UnityEngine;\n\nnamespace ZimGui.Editor {\n    public class AssetWindow : EditorWindow\n    {\n        [MenuItem(\"Tools/ZimGUIAsset\")]\n         static void CreateWindow()\n        {\n            GetWindow<AssetWindow>();\n        }\n         static TMP_FontAsset _asset;\n        void OnGUI() {\n           \n            _asset=EditorGUILayout.ObjectField(_asset, typeof(TMP_FontAsset),true) as TMP_FontAsset;", "    public class AssetWindow : EditorWindow\n    {\n        [MenuItem(\"Tools/ZimGUIAsset\")]\n         static void CreateWindow()\n        {\n            GetWindow<AssetWindow>();\n        }\n         static TMP_FontAsset _asset;\n        void OnGUI() {\n           \n            _asset=EditorGUILayout.ObjectField(_asset, typeof(TMP_FontAsset),true) as TMP_FontAsset;", "            if (_asset!=null&&GUILayout.Button(\"Save new ZimGUIAsset\"))\n            {\n                var selectedPathName = EditorUtility.SaveFilePanel(title: \"Title\", directory: \"Assets\", defaultName: \"ZimGUI_\"+_asset.name+\".bytes\", extension: \"bytes\");\n               var bytes= UiMesh.CreateAsset(_asset);\n               File.WriteAllBytes(selectedPathName,bytes);\n               AssetDatabase.Refresh();\n            }\n        }\n    }\n}\n#endif"]}
{"filename": "Assets/ZimGui/Text/StringEx.cs", "chunked_list": ["\ufeffusing System;\n\nnamespace ZimGui.Text {\n    public static class StringEx {\n        public static unsafe bool Equals(this string text, ReadOnlySpan<char> span) {\n            if (text.Length != span.Length) return false;\n            int width = sizeof(nuint) / sizeof(char);\n            var count = text.Length / width;\n            var rem = text.Length % width;\n            fixed (char* ptr1 = text) {\n                fixed(char*ptr2=span)\n                {\n                    var lPtr1 = (nuint*)ptr1;\n                    var lPtr2 = (nuint*)ptr2;", "                    for (int i = 0; i < count; i++)\n                    {\n                        if (lPtr1[i] != lPtr2[i])\n                        {\n                            return false;\n                        }\n                    }\n                    for (int i = 0; i < rem; i++)\n                    {\n                        if ((ptr1)[count * width + i] != (ptr2)[count * width + i])\n                        {\n                            return false;\n                        }\n                    }\n                    \n                }\n            }\n\n            return true;\n        } ", "                        if ((ptr1)[count * width + i] != (ptr2)[count * width + i])\n                        {\n                            return false;\n                        }\n                    }\n                    \n                }\n            }\n\n            return true;\n        } ", "        public static  unsafe bool Equals(this ReadOnlySpan<char> left, ReadOnlySpan<char> right) {\n            if (left.Length != right.Length) return false;\n            int width = sizeof(nuint) / sizeof(char);\n            var count = left.Length / width;\n            var rem = left.Length % width;\n            fixed (char* ptr1 = left) {\n                fixed(char*ptr2=right) {\n                    var lPtr1 = (nuint*)ptr1;\n                    var lPtr2 = (nuint*)ptr2;\n                    for (int i = 0; i < count; i++) {\n                        if (lPtr1[i] != lPtr2[i]) return false;\n                    }", "                    for (int i = 0; i < count; i++) {\n                        if (lPtr1[i] != lPtr2[i]) return false;\n                    }\n                    if (rem == 0) return true;\n                    for (int i = 0; i < rem; i++)\n                    {\n                        if ((ptr1)[count * width + i] != (ptr2)[count * width + i])\n                        {\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        ", "       public static  unsafe int GetExHashCode(this string t) {\n            var length = t.Length;\n            switch (length) {\n                case 0: return 0;\n                case 1: return (((5381 << 5) + 5381) ^ t[0]) * 1566083941;\n                case 2:\n                    var hash = ((5381 << 5) + 5381) ^ t[0];\n                    return ((hash << 5) + hash) ^ t[1] * 1566083941;\n                case 3:\n                    hash = ((5381 << 5) + 5381) ^ t[0];\n                    hash = ((hash << 5) + hash) ^ t[1];\n                    return ((hash << 5) + hash) ^ t[2] * 1566083941;\n                default:\n                    fixed (char* ptr = t) {\n                        hash = 5381;\n                        var s = (int*) ptr;\n                        var end = s + (length + 1) / 2;\n                        do {\n                            hash = ((hash << 5) + hash) ^ s[0];", "                        } while (end > ++s);\n                        return (hash * 1566083941);\n                    }\n            }\n        }\n        public static  unsafe long GetExHashCode64(this string t) {\n            var length = t.Length;\n            switch (length) {\n                case 0: return 0;\n                case 1: return ((177573L) ^ t[0]) * 1566083941L;\n                case 2:\n                    var hash = (177573L) ^ t[0];\n                    return ((hash << 5) + hash) ^ t[1] * 1566083941L;\n                case 3:\n                    hash = (177573L) ^ t[0];\n                    hash = ((hash << 5) + hash) ^ t[1];\n                    return ((hash << 5) + hash) ^ t[2] * 1566083941L;\n                default:\n                    fixed (char* ptr = t) {\n                        hash = 5381L;\n                        var s = (int*) ptr;\n                        var end = s + (length + 1) / 2;\n                        do {\n                            hash = ((hash << 5) + hash) ^ s[0];", "                        } while (end > ++s);\n                        return (hash * 1566083941L);\n                    }\n            }\n        }\n\n       \n       public static  unsafe int GetExHashCode(this ReadOnlySpan<char> t) {\n            var length = t.Length;\n            switch (length) {\n                case 0: return 0;\n                case 1: return (177573 ^ t[0]) * 1566083941;\n                case 2:\n                    var hash = ( 177573) ^ t[0];\n                    return ((hash << 5) + hash) ^ t[1] * 1566083941;\n                case 3:\n                    hash =  177573^ t[0];\n                    hash = ((hash << 5) + hash) ^ t[1];\n                    return ((hash << 5) + hash) ^ t[2] * 1566083941;\n                default:\n                    fixed (char* ptr = t) {\n                        hash = 5381;\n                        var s = (int*) ptr;\n                        var end = s + length / 2;\n                        do {\n                            hash = ((hash << 5) + hash) ^ s[0];", "                        } while (end > ++s);\n                        if (length % 2 != 0) {\n                            hash = ((hash << 5) + hash) ^ (s[0] & 0xFFFF);\n                        }\n                        return (hash * 1566083941);\n                    }\n            }\n        }\n    }\n}"]}
{"filename": "Assets/ZimGui/Text/TextQuery.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing Unity.Collections;\nnamespace ZimGui.Text {\n   \n    public static class TextQuery {\n        public static void QueryStartsWith(this List<string> inputs,ReadOnlySpan<char> text,List<string> result) {\n            result.Clear();\n            \n            var textLength = text.Length;\n            foreach (var t in inputs) {", "            foreach (var t in inputs) {\n                if (textLength<t.Length&&t.AsSpan().StartsWith(text)) {\n                    result.Add(t);\n                }\n            }\n        }\n        public static void QueryStartsWith(this List<string> inputs,ReadOnlySpan<char> text,List<string> result,StringComparison comparison) {\n            result.Clear();\n            var textLength = text.Length;\n            foreach (var t in inputs) {\n                if (textLength<t.Length&&t.AsSpan().StartsWith(text,comparison)) {\n                    result.Add(t);\n                }\n            }\n        }", "            foreach (var t in inputs) {\n                if (textLength<t.Length&&t.AsSpan().StartsWith(text,comparison)) {\n                    result.Add(t);\n                }\n            }\n        }\n        public static void QueryContains(this List<string> inputs,ReadOnlySpan<char> text,List<string> result,StringComparison comparison) {\n            result.Clear();\n            var textLength = text.Length;\n            foreach (var t in inputs) {\n                if (textLength<t.Length&&t.AsSpan().Contains(text,comparison)) {\n                    result.Add(t);\n                }\n            }\n        }", "            foreach (var t in inputs) {\n                if (textLength<t.Length&&t.AsSpan().Contains(text,comparison)) {\n                    result.Add(t);\n                }\n            }\n        }\n        public static void QueryContains<T>(this T inputs,ReadOnlySpan<char> text,List<(int,string)> result,StringComparison comparison)where T:IList<string>{\n            result.Clear();\n            var textLength = text.Length;\n            for (var index = 0; index < inputs.Count; index++) {\n                var t = inputs[index];", "            for (var index = 0; index < inputs.Count; index++) {\n                var t = inputs[index];\n                if (textLength <= t.Length && t.AsSpan().Contains(text, comparison)) {\n                    result.Add((index,t));\n                }\n            }\n        }\n        \n        public static void QueryNextChar(this List<string> inputs,char c,int index,List<string> result) {\n            result.Clear();\n            foreach (var t in inputs) {", "        public static void QueryNextChar(this List<string> inputs,char c,int index,List<string> result) {\n            result.Clear();\n            foreach (var t in inputs) {\n                if (index<t.Length&&t[index]==c) {\n                    result.Add(t);\n                }\n            }\n        }\n    }\n}"]}
{"filename": "Assets/ZimGui/Text/RefDataMap.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\n\nnamespace ZimGui.Text {\n    public class RefDataMap<TValue> {\n        public struct Entry {\n            public int hashCode;\n            public int next;\n            public TValue value;\n        }\n        \n        int[] buckets;\n        Entry[] entries;\n        int count;\n", "            public TValue value;\n        }\n        \n        int[] buckets;\n        Entry[] entries;\n        int count;\n\n        public int Count => count ;\n\n        public TValue Default;\n\n        public ReadOnlySpan<Entry> ReadEntries() => entries.AsSpan()[..count];\n\n        public RefDataMap() {\n            \n        }\n        public RefDataMap(int capacity) {\n            Initialize(capacity);\n        }\n\n        void Initialize(int capacity) {\n            int size = 1;", "        public TValue Default;\n\n        public ReadOnlySpan<Entry> ReadEntries() => entries.AsSpan()[..count];\n\n        public RefDataMap() {\n            \n        }\n        public RefDataMap(int capacity) {\n            Initialize(capacity);\n        }\n\n        void Initialize(int capacity) {\n            int size = 1;", "            while (size < capacity) {\n                size <<= 1;\n            }\n\n            buckets = new int[size];\n            for (int i = 0; i < buckets.Length; i++) buckets[i] = -1;\n            entries = new Entry[size];\n        }\n\n        void Resize() {\n            var newSize = count * 2;\n            int[] newBuckets = new int[newSize];", "            for (int i = 0; i < newBuckets.Length; i++) newBuckets[i] = -1;\n            Entry[] newEntries = new Entry[newSize];\n            Array.Copy(entries, 0, newEntries, 0, count);\n            for (int i = 0; i < count; i++) {\n                int bucket = newEntries[i].hashCode & (newSize - 1);\n                newEntries[i].next = newBuckets[bucket];\n                newBuckets[bucket] = i;\n            }\n\n            buckets = newBuckets;\n            entries = newEntries;\n        }\n\n\n", "        public void Clear() {\n            if (count > 0) {\n                for (int i = 0; i < buckets.Length; i++) buckets[i] = -1;\n                Array.Clear(entries, 0, count);\n                count = 0;\n              \n            }\n        }\n\n        public ref TValue this[string key] {\n            get {", "        public ref TValue this[string key] {\n            get {\n                if (key == null) {\n                    throw new Exception();\n                }\n                if (buckets == null) Initialize(4);\n                int hashCode = key.GetExHashCode();\n                int targetBucket = hashCode & (buckets.Length - 1);\n                var es = entries;\n                for (int i = buckets[targetBucket]; i >= 0;) {\n                    ref var entry = ref es[i];", "                for (int i = buckets[targetBucket]; i >= 0;) {\n                    ref var entry = ref es[i];\n                    if (entry.hashCode == hashCode) {\n                        return ref entry.value;\n                    }\n                    i =entry.next;\n                }\n                if (count >= entries.Length*0.8f) {\n                    Resize();\n                    targetBucket = hashCode & (buckets.Length - 1);\n                }\n                var index = count;\n                count++;\n                \n                entries[index].hashCode = hashCode;\n                entries[index].next = buckets[targetBucket];\n                entries[index].value = Default;\n                buckets[targetBucket] = index;\n                return ref  entries[index].value;\n            }\n        }\n        \n    }\n}"]}
{"filename": "Assets/ZimGui/Core/NativeCollectionsExtensions.cs", "chunked_list": ["\ufeffusing System;\nusing Unity.Collections;\nusing Unity.Collections.LowLevel.Unsafe;\n\nnamespace ZimGui.Core {\n    public static unsafe class NativeCollectionsExtensions {\n        public static  NativeArray<T> AsArray<T>(ref this UnsafeList<T> list) where T:unmanaged {\n            var array= NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<T>(list.Ptr, list.Length, Allocator.None);\n#if ENABLE_UNITY_COLLECTIONS_CHECKS\n            \n            NativeArrayUnsafeUtility.SetAtomicSafetyHandle(ref array, AtomicSafetyHandle.GetTempUnsafePtrSliceHandle ());\n#endif\n            return array;\n        }", "        public static  NativeArray<T> AsArray<T>(ref this UnsafeList<T> list,int startIndex,int length) where T:unmanaged {\n            var array= NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<T>(startIndex+list.Ptr,length, Allocator.None);\n#if ENABLE_UNITY_COLLECTIONS_CHECKS\n            \n            NativeArrayUnsafeUtility.SetAtomicSafetyHandle(ref array, AtomicSafetyHandle.GetTempUnsafePtrSliceHandle ());\n#endif\n            return array;\n        }\n         public static  NativeArray<T> CreateNativeArray<T>(T* ptr,int length) where T:unmanaged {\n            var array= NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<T>(ptr, length, Allocator.None);\n#if ENABLE_UNITY_COLLECTIONS_CHECKS\n            \n            NativeArrayUnsafeUtility.SetAtomicSafetyHandle(ref array, AtomicSafetyHandle.GetTempUnsafePtrSliceHandle ());\n#endif\n            return array;\n        }", "         public static  NativeArray<T> CreateNativeArray<T>(T* ptr,int length) where T:unmanaged {\n            var array= NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<T>(ptr, length, Allocator.None);\n#if ENABLE_UNITY_COLLECTIONS_CHECKS\n            \n            NativeArrayUnsafeUtility.SetAtomicSafetyHandle(ref array, AtomicSafetyHandle.GetTempUnsafePtrSliceHandle ());\n#endif\n            return array;\n        }\npublic static  NativeArray<T> AsNativeArray<T>(this IntPtr ptr,int length) where T:unmanaged {\n            var array= NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<T>((void*)ptr, length, Allocator.None);\n#if ENABLE_UNITY_COLLECTIONS_CHECKS\n            \n            NativeArrayUnsafeUtility.SetAtomicSafetyHandle(ref array, AtomicSafetyHandle.GetTempUnsafePtrSliceHandle ());\n#endif\n            return array;\n        }\n\n", "public static  NativeArray<T> AsNativeArray<T>(this IntPtr ptr,int length) where T:unmanaged {\n            var array= NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<T>((void*)ptr, length, Allocator.None);\n#if ENABLE_UNITY_COLLECTIONS_CHECKS\n            \n            NativeArrayUnsafeUtility.SetAtomicSafetyHandle(ref array, AtomicSafetyHandle.GetTempUnsafePtrSliceHandle ());\n#endif\n            return array;\n        }\n\n\n        public static void Swap(void* ptr,int length1, int length2) {\n            var second = (byte*) ptr + length1;", "        public static void Swap(void* ptr,int length1, int length2) {\n            var second = (byte*) ptr + length1;\n            if (length1 == length2) {\n                var temp= UnsafeUtility.Malloc(length1, UnsafeUtility.AlignOf<byte>(), Allocator.Temp);\n                UnsafeUtility.MemCpy(temp,ptr,length1);\n                UnsafeUtility.MemCpy(ptr, second, length1);\n                UnsafeUtility.MemCpy(second,temp, length1);\n                UnsafeUtility.Free(temp,Allocator.Temp);\n            }\n            else if (length1 < length2) {\n               var temp= UnsafeUtility.Malloc(length1, UnsafeUtility.AlignOf<byte>(), Allocator.Temp);\n               UnsafeUtility.MemCpy(temp,ptr,length1);\n               UnsafeUtility.MemMove(ptr, second, length2);\n               UnsafeUtility.MemCpy(second,temp, length1);\n               UnsafeUtility.Free(temp,Allocator.Temp);\n            }\n            else {\n                var temp= UnsafeUtility.Malloc(length2, UnsafeUtility.AlignOf<byte>(), Allocator.Temp);\n                UnsafeUtility.MemCpy(temp,second,length2);\n                UnsafeUtility.MemMove((byte*) ptr + length2, ptr, length1);\n                UnsafeUtility.MemCpy(ptr,temp, length2);\n                UnsafeUtility.Free(temp,Allocator.Temp);\n            }", "            else if (length1 < length2) {\n               var temp= UnsafeUtility.Malloc(length1, UnsafeUtility.AlignOf<byte>(), Allocator.Temp);\n               UnsafeUtility.MemCpy(temp,ptr,length1);\n               UnsafeUtility.MemMove(ptr, second, length2);\n               UnsafeUtility.MemCpy(second,temp, length1);\n               UnsafeUtility.Free(temp,Allocator.Temp);\n            }\n            else {\n                var temp= UnsafeUtility.Malloc(length2, UnsafeUtility.AlignOf<byte>(), Allocator.Temp);\n                UnsafeUtility.MemCpy(temp,second,length2);\n                UnsafeUtility.MemMove((byte*) ptr + length2, ptr, length1);\n                UnsafeUtility.MemCpy(ptr,temp, length2);\n                UnsafeUtility.Free(temp,Allocator.Temp);\n            }", "        }public static void Swap<T>(T* ptr,int length1, int length2)where T:unmanaged  {\n            var second =  ptr + length1;\n            if (length1 == length2) {\n                var byteLength1 = sizeof(T) * length1;\n                var temp= (T*)UnsafeUtility.Malloc(byteLength1, UnsafeUtility.AlignOf<T>(), Allocator.Temp);\n                UnsafeUtility.MemCpy(temp,ptr,byteLength1);\n                UnsafeUtility.MemCpy(ptr, second, byteLength1);\n                UnsafeUtility.MemCpy(second,temp, byteLength1);\n                UnsafeUtility.Free(temp,Allocator.Temp);\n            }\n            else if (length1 < length2) {\n                var byteLength1 = sizeof(T) * length1;\n                var byteLength2 = sizeof(T) * length2;\n               var temp= (T*)UnsafeUtility.Malloc(byteLength1, UnsafeUtility.AlignOf<T>(), Allocator.Temp);\n               UnsafeUtility.MemCpy(temp,ptr,byteLength1);\n               UnsafeUtility.MemMove(ptr, second, byteLength2);\n               UnsafeUtility.MemCpy(ptr+length2,temp, byteLength1);\n               UnsafeUtility.Free(temp,Allocator.Temp);\n            }\n            else {\n                var byteLength1 = sizeof(T) * length1;\n                var byteLength2 = sizeof(T) * length2;\n                var temp= (T*)UnsafeUtility.Malloc(byteLength2, UnsafeUtility.AlignOf<T>(), Allocator.Temp);\n                UnsafeUtility.MemCpy(temp,second,byteLength2);\n                UnsafeUtility.MemMove( ptr + length2, ptr, byteLength1);\n                UnsafeUtility.MemCpy(ptr,temp, byteLength2);\n                UnsafeUtility.Free(temp,Allocator.Temp);\n            }\n        }", "            else if (length1 < length2) {\n                var byteLength1 = sizeof(T) * length1;\n                var byteLength2 = sizeof(T) * length2;\n               var temp= (T*)UnsafeUtility.Malloc(byteLength1, UnsafeUtility.AlignOf<T>(), Allocator.Temp);\n               UnsafeUtility.MemCpy(temp,ptr,byteLength1);\n               UnsafeUtility.MemMove(ptr, second, byteLength2);\n               UnsafeUtility.MemCpy(ptr+length2,temp, byteLength1);\n               UnsafeUtility.Free(temp,Allocator.Temp);\n            }\n            else {\n                var byteLength1 = sizeof(T) * length1;\n                var byteLength2 = sizeof(T) * length2;\n                var temp= (T*)UnsafeUtility.Malloc(byteLength2, UnsafeUtility.AlignOf<T>(), Allocator.Temp);\n                UnsafeUtility.MemCpy(temp,second,byteLength2);\n                UnsafeUtility.MemMove( ptr + length2, ptr, byteLength1);\n                UnsafeUtility.MemCpy(ptr,temp, byteLength2);\n                UnsafeUtility.Free(temp,Allocator.Temp);\n            }\n        }", "         public static void Insert<T>(ref this UnsafeList<T> list, int index, in T element) where T:unmanaged {\n             list.Length += 1;\n             var dest = list.Ptr + index;\n             UnsafeUtility.MemMove(dest+1,dest,sizeof(T)* (list.Length - index));\n             *dest = element;\n         }\n         public static ref T InsertRef<T>(ref this UnsafeList<T> list, int index) where T:unmanaged {\n             list.Length += 1;\n             var dest = list.Ptr + index;\n             UnsafeUtility.MemMove(dest+1,dest,sizeof(T)* (list.Length-1 - index));\n            return ref dest[0];\n         }", "        public static unsafe Span<T> AsSpan<T>(ref this UnsafeList<T> list) where T:unmanaged {\n            return new Span<T>(list.Ptr, list.Length);\n        }\n        public static unsafe Span<T> AsSpan<T>(ref this NativeArray<T> list) where T:unmanaged {\n            return new Span<T>(list.GetUnsafePtr(), list.Length);\n        }\n        public static ref T GetRef<T>(this NativeArray<T> array, int index)where T:unmanaged\n        {\n            // You might want to validate the index first, as the unsafe method won't do that.\n            if (index < 0 || index >= array.Length)\n                throw new ArgumentOutOfRangeException(nameof(index));\n            unsafe {\n                return ref ((T*) array.GetUnsafePtr())[index];\n            }\n        }\n    }\n}", "            if (index < 0 || index >= array.Length)\n                throw new ArgumentOutOfRangeException(nameof(index));\n            unsafe {\n                return ref ((T*) array.GetUnsafePtr())[index];\n            }\n        }\n    }\n}"]}
{"filename": "Assets/ZimGui/Core/MathHelper.cs", "chunked_list": ["\ufeffusing System;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\nusing UnityEngine;\n\nnamespace ZimGui.Core {\n    public static class MathHelper {\n        public static int CeilPow2(int x) {\n            var result = 1;\n            while (result < x) {\n                result <<= 1;\n            }\n\n            return result;\n        }\n     \n        [MethodImpl(MethodImplOptions.AggressiveInlining)]", "            while (result < x) {\n                result <<= 1;\n            }\n\n            return result;\n        }\n     \n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static  Vector2 Perpendicular(this Vector2 v) {\n            var x = v.x * v.x + v.y * v.y;\n            if(x==0) return default;\n            var y = 1f / Mathf.Sqrt(x);\n            return new Vector2(-v.y * y, v.x * y);\n        }\n        \n        [MethodImpl(MethodImplOptions.AggressiveInlining)]", "        public static  Vector2 Perpendicular(this Vector2 v) {\n            var x = v.x * v.x + v.y * v.y;\n            if(x==0) return default;\n            var y = 1f / Mathf.Sqrt(x);\n            return new Vector2(-v.y * y, v.x * y);\n        }\n        \n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static Vector2 NormIntersection(Vector2 a, Vector2 b) {\n            var c = a.x * b.x + a.y * b.y+1;\n            return new Vector2((a.x + b.x) / c, (a.y + b.y) / c);\n            \n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]", "        public static Vector2 NormIntersection(Vector2 a, Vector2 b) {\n            var c = a.x * b.x + a.y * b.y+1;\n            return new Vector2((a.x + b.x) / c, (a.y + b.y) / c);\n            \n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static float FastTan(float x) { \n             var xd=x*2d/Math.PI;\n             var y = 1 - xd * xd;\n             return (float) (xd * (-0.0187111 * y + 0.3158 + 1.2736575 / y));\n        }\n        \n        [MethodImpl(MethodImplOptions.AggressiveInlining)]", "        public static float FastTan2PI(float x) { \n             var xd=x*4d;\n             var y = 1 - xd * xd;\n             return (float) (xd * (-0.0187111 * y + 0.3158 + 1.2736575 / y));\n        }\n\n        public static Vector2 ConSin(float x) => new Vector2(Mathf.Cos(x), Mathf.Sin(x));\n\n\n\n    }\n}"]}
{"filename": "Assets/ZimGui/Core/FixedCharMap`1.cs", "chunked_list": ["\ufeffusing System;\nusing Unity.Collections;\nusing Unity.Collections.LowLevel.Unsafe;\nusing UnityEngine;\n\nnamespace ZimGui.Core {\n    public unsafe struct FixedCharMap<T>:IDisposable where T:unmanaged{\n       \n        [NativeDisableUnsafePtrRestriction]\n        T* _values;\n        public T* GetUnsafeValuesPtr => _values;\n        [NativeDisableUnsafePtrRestriction]\n        (ushort Key,short Next)* _entries;\n        public (ushort Key,short Next)* GetUnsafeEntriesPtr => _entries;\n        [NativeDisableUnsafePtrRestriction]\n        short* _buckets;\n        public short* GetUnsafeBucketsPtr => _buckets;", "        public readonly int Count;\n        public readonly int BucketsLength;\n        public short DefaultIndex;\n        short _count;\n        public T Default => _values[DefaultIndex];\n        public FixedCharMap(int count) {\n            Count = count;\n            BucketsLength = MathHelper.CeilPow2(count);\n            _values = (T* )UnsafeUtility.Malloc(sizeof(T) * Count, UnsafeUtility.AlignOf<T>(), Allocator.Persistent);\n            _entries = ((ushort ,short )* )UnsafeUtility.Malloc(sizeof((ushort ,short )) * Count, UnsafeUtility.AlignOf<(ushort ,short )>(), Allocator.Persistent);\n            (ushort ,short ) defaultEntry = (0, -1);\n            UnsafeUtility.MemCpyReplicate(_entries, &defaultEntry, sizeof((ushort ,short )), Count);\n            _buckets=(short* )UnsafeUtility.Malloc(sizeof(short) * BucketsLength, UnsafeUtility.AlignOf<short>(), Allocator.Persistent);\n            short defaultTarget = -1;\n            UnsafeUtility.MemCpyReplicate(_buckets, &defaultTarget, sizeof(short), BucketsLength);\n            _count = 0;\n            DefaultIndex = default;\n        }\n", "        public int ByteLength => 10 + Count * sizeof(T) + Count * 4 + 4 * BucketsLength;\n        public void Serialize(Span<byte> span) {\n            var offset = 0;\n            span = span[..ByteLength];\n            span.Write(ref offset,Count);\n            span.Write(ref offset,BucketsLength);\n            span.Write(ref offset,DefaultIndex);\n            span.Write(ref offset,_values,Count);\n            span.Write(ref offset,_entries,Count);\n            span.Write(ref offset,_buckets,BucketsLength);\n        }", "        public void Serialize(Span<byte> span,ref int offset) { \n            span.Write(ref offset,Count);\n            span.Write(ref offset,BucketsLength);\n            span.Write(ref offset,DefaultIndex);\n            span.Write(ref offset,_values,Count);\n            span.Write(ref offset,_entries,Count);\n            span.Write(ref offset,_buckets,BucketsLength);\n        }\n         public  FixedCharMap(ReadOnlySpan<byte> span) {\n             var offset = 0;\n             Count = span.ReadInt32(ref offset);\n             BucketsLength = span.ReadInt32(ref offset);\n             DefaultIndex = span.ReadInt16(ref offset);\n             _values = (T* )UnsafeUtility.Malloc(sizeof(T) * Count, UnsafeUtility.AlignOf<T>(), Allocator.Persistent);\n             span.WriteTo(ref offset,_values,Count);\n             _entries = ((ushort ,short )* )UnsafeUtility.Malloc(sizeof((ushort ,short )) * Count, UnsafeUtility.AlignOf<(ushort ,short )>(), Allocator.Persistent);\n             span.WriteTo(ref offset,_entries,Count);\n             _buckets=(short* )UnsafeUtility.Malloc(sizeof(short) * BucketsLength, UnsafeUtility.AlignOf<short>(), Allocator.Persistent);\n             span.WriteTo(ref offset,_buckets,BucketsLength);\n             _count = (short)Count;\n         }\n        \n        ", "        public bool IsCreated => _entries != null;\n        public void Dispose() {\n            UnsafeUtility.Free(_values,Allocator.Persistent);\n            _values = null;\n            UnsafeUtility.Free(_entries,Allocator.Persistent);\n            _entries = null;\n            UnsafeUtility.Free(_buckets,Allocator.Persistent);\n            _buckets = null;\n        }\n       \n        \n        void Insert(ushort key, T value) {\n            var targetBucket = key& (BucketsLength - 1);\n            var i = _buckets[targetBucket];", "            if(0<=i) {\n                var current = _entries[i];\n                if (current.Key == key) {\n                    return;\n                }\n                while (0<= current.Next) {\n                    current = _entries[current.Next];\n                    if (current.Key == key) {\n                        return;\n                    }\n                }\n            }\n            var index = _count;", "            if (Count <= index) throw new Exception();\n            _count++;\n            if(0<=i)\n                _entries[index].Next = i ;\n            _entries[index].Key = key;\n            _values[index] = value;\n            _buckets[targetBucket] = index;\n        }\n        public void Add(ushort key, T value) {\n            Insert(key, value);\n        }", "        public void Add(ushort key, T value) {\n            Insert(key, value);\n        }\n        public T this[ushort key] {\n            get {\n                var index = _buckets[key& (BucketsLength - 1)];\n                var entries = _entries;\n                if (index <0) return  _values[DefaultIndex];\n                var current =   entries[index];\n                if (current.Key == key) return _values[index];\n                index = current.Next;", "                if (current.Key == key) return _values[index];\n                index = current.Next;\n                while (0<= index) {\n                    current =  entries[index];\n                    if (current.Key == key) return  _values[index];\n                    index = current.Next;\n                }\n                return  _values[DefaultIndex];\n            }\n            set => Insert(key, value);\n        }\n", "        public ref readonly T GetRef(ushort key) {\n            var index = _buckets[key& (BucketsLength - 1)];\n            var entries = _entries;\n            if (index <0) return  ref _values[DefaultIndex];\n            var current =  entries[index];\n            if (current.Key == key) return ref _values[index];\n             index = current.Next;\n            while (0<= index) {\n                current =  entries[index];\n                if (current.Key == key) return ref _values[index];\n                index = current.Next;\n            }\n            return ref _values[DefaultIndex];\n        }", "                if (current.Key == key) return ref _values[index];\n                index = current.Next;\n            }\n            return ref _values[DefaultIndex];\n        }\n        public bool TryGetValue(ushort key, out T value) {\n            var index = _buckets[key& (BucketsLength - 1)];\n            if (index <0) {\n                value = default;\n                return false;\n            }\n            var entries = _entries;\n            var current = entries[index];", "            if (current.Key == key) {\n                value= _values[index];\n                return true;\n            }\n            index = current.Next;\n            while (0<= index) {\n                current =  entries[index];\n                if (current.Key == key) {\n                    value= _values[index];\n                    return true;\n                }\n                index = current.Next;\n            }\n            value = default;\n            return false;\n        }", "        public short GetEntryIndex(ushort key) {\n            var index = _buckets[key& (BucketsLength - 1)];\n            if (index <0) return DefaultIndex;\n            var entries = _entries;\n            var current = entries[index];\n            if (current.Key == key) return index;\n            index = current.Next;\n            while (0<= index) {\n                current = entries[index];\n                if (current.Key == key) return index;\n                index = current.Next;\n            }\n            return DefaultIndex;\n        }", "                if (current.Key == key) return index;\n                index = current.Next;\n            }\n            return DefaultIndex;\n        }\n        public ref readonly T GetFromEntryIndex(int index)=>ref _values[index];\n    }\n}"]}
{"filename": "Assets/ZimGui/Core/UiMesh.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing TMPro;\nusing Unity.Collections;\nusing Unity.Collections.LowLevel.Unsafe;\nusing UnityEngine;\nusing UnityEngine.Profiling;\nusing UnityEngine.Rendering;\nusing UnityEngine.TextCore;\nusing static ZimGui.Core.MathHelper;", "using UnityEngine.TextCore;\nusing static ZimGui.Core.MathHelper;\nnamespace ZimGui.Core {\n    public sealed unsafe class UiMesh : IDisposable {\n        public readonly Mesh Mesh;\n        readonly Material _material;\n\n        Material _textureMaterial;\n        MaterialPropertyBlock _materialPropertyBlock;\n        List<Texture> _textures;\n        int _textureLength => _textures?.Count ?? 0;\n        UnsafeList<Quad> _textureQuads;\n        static int _textureShaderPropertyId = Shader.PropertyToID(\"_MainTex\");\n", "        public void SetUpForTexture(Material material, int capacity) {\n            _textureMaterial = material;\n            _materialPropertyBlock = new MaterialPropertyBlock();\n            _textures = new List<Texture>(capacity);\n            _textureQuads = new UnsafeList<Quad>(capacity, Allocator.Persistent);\n        }\n\n        public void AddTexture(Rect rect, Texture texture) {\n            _textures.Add(texture);\n            EnsureNextTextureQuadCapacity();\n            var last = _textureQuads.Length;\n            _textureQuads.Length = last + 1;\n            Quad.WriteWithOutUV(ref _textureQuads.Ptr[last], new Vector2(rect.width, rect.height),\n                new Vector2(rect.xMin, rect.yMin), new UiColor(255, 255, 255, 255));\n        }\n", "        public void AddTexture(Rect rect, Texture texture, UiColor color) {\n            _textures.Add(texture);\n            EnsureNextTextureQuadCapacity();\n            var last = _textureQuads.Length;\n            _textureQuads.Length = last + 1;\n            Quad.WriteWithOutUV(ref _textureQuads.Ptr[last], new Vector2(rect.width, -rect.height),\n                new Vector2(rect.xMin, rect.yMax), color);\n        }\n\n        void EnsureTextureCapacity(int capacity) {\n            if (_textureQuads.Capacity >= capacity) return;\n            capacity = MathHelper.CeilPow2(capacity);\n            _textureQuads.SetCapacity(capacity);\n        }\n\n        void EnsureNextTextureQuadCapacity() {\n            var capacity = _textureQuads.Length + 1;", "            if (_textureQuads.Capacity >= capacity) return;\n            capacity = MathHelper.CeilPow2(capacity);\n            _textureQuads.SetCapacity(capacity);\n        }\n\n        void EnsureNextTextureQuadCapacity() {\n            var capacity = _textureQuads.Length + 1;\n            if (_textureQuads.Capacity >= capacity) return;\n            capacity = CeilPow2(capacity);\n            _textureQuads.SetCapacity(capacity);\n        }\n\n\n        UnsafeList<Quad> _quads;\n        UnsafeList<uint> _indices;", "        public readonly float PointSize;\n        public readonly float LineHeight;\n        // public readonly float BoldSpacing;\n        // public readonly float BoldStyle;\n        // public readonly float NormalStyle;\n        // public readonly float NormalSpacingOffset;\n\n        public int Length {\n            get => _quads.Length;\n            set {\n                EnsureCapacity(value);\n                _quads.Length = value;\n            }\n        }\n", "        public readonly Texture2D Texture;\n        public readonly Vector2 InvUvScale;\n        public FixedCharMap<CharInfo> Map;\n        public NativeArray<Quad> ReadQuads() => _quads.AsArray();\n        public Span<Quad> ReadQuadsSpan() => _quads.AsSpan();\n\n        public Span<Quad> ReadAdditionalQuadSpan(int length) {\n            var start = _quads.Length;\n            EnsureCapacity(_quads.Length + length);\n            _quads.Length += length;\n            return _quads.AsSpan()[start..];\n        }\n", "        public ref Quad ReadAdditionalQuad() {\n            var start = _quads.Length;\n            EnsureCapacity(_quads.Length + 1);\n            _quads.Length += 1;\n            return ref _quads.Ptr[start];\n        }\n\n        public void Swap(int start, int middle, int end) {\n            NativeCollectionsExtensions.Swap(_quads.Ptr + start, (middle - start) * sizeof(Quad),\n                (end - middle) * sizeof(Quad));\n        }\n\n\n        public NativeArray<Quad> ReadAdditionalQuadNativeArray(int length) {\n            var start = _quads.Length;\n            EnsureCapacity(_quads.Length + length);\n            _quads.Length += length;\n            return _quads.AsArray().GetSubArray(start, Length);\n        }\n", "        public void EnsureCapacity(int capacity) {\n            if (_quads.Capacity >= capacity) return;\n            capacity = MathHelper.CeilPow2(capacity);\n            _quads.SetCapacity(capacity);\n        }\n\n        public readonly Vector2 CircleCenter;\n        public readonly Vector4 CircleUV;\n        public readonly float SpaceXAdvance;\n        const char circle = '\\u25CF'; //\u25cf\n", "        public readonly float SpaceXAdvance;\n        const char circle = '\\u25CF'; //\u25cf\n\n        public static byte[] CreateAsset(TMP_FontAsset fontAsset) {\n            var texture = (Texture2D) fontAsset.material.mainTexture;\n            var textureWidth = texture.width;\n            var textureHeight = (float) texture.height;\n            var charList = fontAsset.characterTable;\n            var length = charList.Count;\n            var map = new FixedCharMap<CharInfo>(length + 3);\n            var faceInfo = fontAsset.faceInfo;\n            var scale = faceInfo.scale;\n            var pointSize = faceInfo.pointSize / scale;\n            var lineHeight = fontAsset.faceInfo.lineHeight / pointSize;\n            var padding = fontAsset.atlasPadding;", "            if (charList == null) {\n                throw new NullReferenceException(\"characterTable is null\");\n            }\n\n            foreach (var tmp_character in charList) {\n                var unicode = tmp_character.unicode;\n                var glyph = tmp_character.glyph;\n                var info = new CharInfo(glyph, textureWidth, textureHeight, pointSize, padding);\n                map[(ushort) unicode] = info;\n            }\n\n            var bytes = new byte[8 + map.ByteLength];\n            var span = bytes.AsSpan();\n            var offset = 0;\n            span.Write(ref offset,pointSize);\n            span.Write(ref offset, lineHeight);\n            map.Serialize(span, ref offset);\n            return bytes;\n        }\n\n        public UiMesh(ReadOnlySpan<byte> data, Texture2D texture, Material material, int capacity = 512) {\n            Texture = texture;\n            material.mainTexture = texture;\n            _material = material;\n            var offset = 0;\n            PointSize =data.ReadSingle(ref offset);\n            LineHeight = data.ReadSingle(ref offset);\n            InvUvScale = new Vector2(texture.width, texture.height) / PointSize;\n            Map = new FixedCharMap<CharInfo>(data[offset..]);", "            if (Map.TryGetValue(circle, out var info)) {\n                var uv = CircleUV = info.UV;\n                CircleCenter = new Vector2(uv.z + uv.x / 2, uv.w + uv.y / 2);\n            }\n            else {\n                throw new NotSupportedException(\"\u25cf \\\\u25CF is needed.\");\n            }\n\n            SpaceXAdvance = Map[' '].XAdvance;\n            Mesh = new Mesh() {\n                indexFormat = IndexFormat.UInt32\n            };\n            Mesh.MarkDynamic();\n            _quads = new UnsafeList<Quad>(capacity, Allocator.Persistent);\n            var indices = new UnsafeList<uint>(capacity * 4, Allocator.Persistent);", "            for (int i = 0; i < capacity * 4; i++) {\n                indices.AddNoResize((uint) i);\n            }\n\n            _indices = indices;\n        }\n\n        public UiMesh(TMP_FontAsset fontAsset, Material material, int capacity = 512) {\n            if (fontAsset == null) {\n                throw new NullReferenceException(\"fontAsset  is  null.\");\n            }\n", "            if (fontAsset == null) {\n                throw new NullReferenceException(\"fontAsset  is  null.\");\n            }\n\n            if (material == null) {\n                throw new NullReferenceException(\"material  is  null.\");\n            }\n\n            if (fontAsset.sourceFontFile != null) {\n                throw new NotSupportedException(\"Dynamic font is not supported.\");\n            }\n", "            if (fontAsset.sourceFontFile != null) {\n                throw new NotSupportedException(\"Dynamic font is not supported.\");\n            }\n\n            try {\n                Texture = (Texture2D) fontAsset.material.mainTexture;\n            }\n            catch (Exception) {\n                throw new NotSupportedException(\"mainTexture  is needed.\");\n            }\n\n            _material = material;\n            _material.mainTexture = Texture;\n            // BoldSpacing = fontAsset.boldSpacing;\n            // BoldStyle = fontAsset.boldStyle;\n            // NormalStyle = fontAsset.normalStyle;\n            // NormalSpacingOffset = fontAsset.normalSpacingOffset;\n            var textureWidth = Texture.width;\n            var textureHeight = (float) Texture.height;\n            var charList = fontAsset.characterTable;\n            var length = charList.Count;\n            Map = new FixedCharMap<CharInfo>(length + 3);\n            var faceInfo = fontAsset.faceInfo;\n            var scale = faceInfo.scale;\n            var tabWidth = faceInfo.tabWidth;\n            PointSize = faceInfo.pointSize / scale;\n            LineHeight = fontAsset.faceInfo.lineHeight / PointSize;\n            var padding = fontAsset.atlasPadding;\n            CharInfo info;", "            if (charList == null) {\n                throw new NullReferenceException(\"characterTable is null\");\n            }\n\n            foreach (var tmp_character in charList) {\n                var unicode = tmp_character.unicode;\n                var glyph = tmp_character.glyph;\n                info = new CharInfo(glyph, textureWidth, textureHeight, PointSize, padding);\n                Map[(ushort) unicode] = info;\n            }\n", "            if (Map.TryGetValue(' ', out info)) {\n                SpaceXAdvance = info.XAdvance;\n                Map[9] = new CharInfo(4 * SpaceXAdvance, 0, 0);\n            }\n            else {\n                SpaceXAdvance = tabWidth / PointSize;\n                Map[9] = new CharInfo(4 * SpaceXAdvance, 0, 0);\n            }\n\n            if (Map.TryGetValue(circle, out info)) {\n                var uv = CircleUV = info.UV;\n                CircleCenter = new Vector2(uv.z + uv.x / 2, uv.w + uv.y / 2);\n            }\n            else {\n                throw new NotSupportedException(\"\u25cf \\\\u25CF is needed.\");\n            }\n\n            Map.DefaultIndex = Map.GetEntryIndex(circle);\n            Mesh = new Mesh() {\n                indexFormat = IndexFormat.UInt32\n            };\n            Mesh.MarkDynamic();\n\n            _quads = new UnsafeList<Quad>(capacity, Allocator.Persistent);\n            var indices = new UnsafeList<uint>(capacity * 4, Allocator.Persistent);", "            if (Map.TryGetValue(circle, out info)) {\n                var uv = CircleUV = info.UV;\n                CircleCenter = new Vector2(uv.z + uv.x / 2, uv.w + uv.y / 2);\n            }\n            else {\n                throw new NotSupportedException(\"\u25cf \\\\u25CF is needed.\");\n            }\n\n            Map.DefaultIndex = Map.GetEntryIndex(circle);\n            Mesh = new Mesh() {\n                indexFormat = IndexFormat.UInt32\n            };\n            Mesh.MarkDynamic();\n\n            _quads = new UnsafeList<Quad>(capacity, Allocator.Persistent);\n            var indices = new UnsafeList<uint>(capacity * 4, Allocator.Persistent);", "            for (int i = 0; i < capacity * 4; i++) {\n                indices.AddNoResize((uint) i);\n            }\n\n            _indices = indices;\n            InvUvScale = new Vector2(textureWidth, textureHeight) / PointSize;\n        }\n\n\n        void CheckAddLength(int length) {\n            var nextQuadLength = (_quads.Length + length);", "            if (_quads.Capacity >= nextQuadLength) return;\n            nextQuadLength = MathHelper.CeilPow2(nextQuadLength);\n            _quads.SetCapacity(nextQuadLength);\n        }\n\n        public void AddDefault() {\n            CheckAddLength(1);\n            ;\n            var last = _quads.Length;\n            _quads.Resize(last + 1, NativeArrayOptions.ClearMemory);\n        }\n", "        public void Advance() {\n            CheckAddLength(1);\n            ;\n            _quads.Length += 1;\n        }\n\n        public void AdvanceUnsafe() {\n            _quads.Length += 1;\n        }\n\n        public void Add(ref Quad quad) {\n            CheckAddLength(1);\n            ;\n            var last = _quads.Length;\n            _quads.Resize(last + 1);\n            _quads[last] = quad;\n        }\n", "        public void Add(ref Quad quad) {\n            CheckAddLength(1);\n            ;\n            var last = _quads.Length;\n            _quads.Resize(last + 1);\n            _quads[last] = quad;\n        }\n\n        public void AddRange(ReadOnlySpan<Quad> quads) {\n            CheckAddLength(quads.Length);\n            var last = _quads.Length;\n            _quads.Length += quads.Length;\n            quads.CopyTo(_quads.AsSpan()[last..]);\n        }\n", "        public void AddRange(ReadOnlySpan<Quad> quads) {\n            CheckAddLength(quads.Length);\n            var last = _quads.Length;\n            _quads.Length += quads.Length;\n            quads.CopyTo(_quads.AsSpan()[last..]);\n        }\n\n        public void AddRange(Quad* ptr, int count) {\n            CheckAddLength(count);\n            _quads.AddRange(ptr, count);\n        }\n", "        public ref Quad Next() {\n            var last = _quads.Length;\n            if (_quads.Capacity <= last + 1) EnsureCapacity(last + 1);\n            _quads.Length = last + 1;\n            return ref _quads.Ptr[last];\n        }\n\n        public const float Sqrt3 =1.732050807f;\n        public void AddInvertedTriangle(Vector2 center,float height, UiColor color) {\n            ref var quad = ref Next();\n            quad.V3.Position.x = center.x; \n            quad.V0.Position.x = center.x-height/Sqrt3;\n            quad.V2.Position.y= quad.V0.Position.y = center.y+height/3;\n            quad.V2.Position.x = center.x+height/Sqrt3;\n            quad.V3.Position.y = center.y-height*2/3;\n            quad.V3.Color = quad.V2.Color =  quad.V0.Color = color;\n            quad.V3.Options.Size = quad.V2.Options.Size =  quad.V0.Options.Size = 255;\n            quad.V3.UV = quad.V2.UV = quad.V0.UV = CircleCenter;\n            quad.V1 = quad.V0;", "        public void AddInvertedTriangle(Vector2 center,float height, UiColor color) {\n            ref var quad = ref Next();\n            quad.V3.Position.x = center.x; \n            quad.V0.Position.x = center.x-height/Sqrt3;\n            quad.V2.Position.y= quad.V0.Position.y = center.y+height/3;\n            quad.V2.Position.x = center.x+height/Sqrt3;\n            quad.V3.Position.y = center.y-height*2/3;\n            quad.V3.Color = quad.V2.Color =  quad.V0.Color = color;\n            quad.V3.Options.Size = quad.V2.Options.Size =  quad.V0.Options.Size = 255;\n            quad.V3.UV = quad.V2.UV = quad.V0.UV = CircleCenter;\n            quad.V1 = quad.V0;", "        } public void AddRightPointingTriangle(Vector2 center,float height, UiColor color) {\n            ref var quad = ref Next();\n            quad.V3.Position.y = center.y; \n            quad.V0.Position.y = center.y-height/Sqrt3;\n            quad.V2.Position.x= quad.V0.Position.x = center.x-height/3;\n            quad.V2.Position.y = center.y+height/Sqrt3;\n            quad.V3.Position.x = center.x+height*2/3;\n            quad.V3.Color = quad.V2.Color =  quad.V0.Color = color;\n            quad.V3.Options.Size = quad.V2.Options.Size =  quad.V0.Options.Size = 255;\n            quad.V3.UV = quad.V2.UV = quad.V0.UV = CircleCenter;\n            quad.V1 = quad.V0;\n        }", "        public void AddTriangle(Vector2 a, Vector2 b, Vector2 c, UiColor color) {\n            ref var quad = ref Next();\n            quad.V0.Position =a;\n            quad.V2.Position= b;\n            quad.V3.Position = c;\n            quad.V3.Color = quad.V2.Color =  quad.V0.Color = color;\n            quad.V3.Options.Size = quad.V2.Options.Size =  quad.V0.Options.Size = 255;\n            quad.V3.UV = quad.V2.UV = quad.V0.UV = CircleCenter;\n            quad.V1 = quad.V0;\n        }\n", "        public void AddBottomRightTriangle(Rect rect, UiColor color) {\n            CheckAddLength(1);\n            var last = _quads.Length;\n            _quads.Length = last + 1;\n            ref var quad = ref _quads.Ptr[last];\n            ref var v0 = ref quad.V0;\n            v0.Position = rect.min;\n            v0.Color = color;\n            v0.UV = CircleCenter;\n            v0.Options.Size = 255;\n            quad.V1 = quad.V2 = quad.V3 = v0;\n            quad.V1.Position.y = rect.yMax;\n            quad.V2.Position.x = quad.V1.Position.x = rect.xMax;\n            quad.V2.Position.y = rect.yMin;\n        }\n", "        public void AddRect(Rect rect, UiColor color) {\n            var last = _quads.Length;\n            if (_quads.Capacity <= last + 1) EnsureCapacity(last + 1);\n            _quads.Length = last + 1;\n            ref var quad = ref _quads.Ptr[last];\n            quad.V3.Position.x = quad.V0.Position.x = rect.xMin;\n            quad.V1.Position.y = quad.V0.Position.y = rect.yMax;\n            quad.V2.Position.x = quad.V1.Position.x = rect.xMax;\n            quad.V3.Position.y = quad.V2.Position.y = rect.yMin;\n            quad.V3.Color = quad.V2.Color = quad.V1.Color = quad.V0.Color = color;\n            quad.V3.Options.Size = quad.V2.Options.Size = quad.V1.Options.Size = quad.V0.Options.Size = 255;\n            quad.V3.UV = quad.V2.UV = quad.V1.UV = quad.V0.UV = CircleCenter;\n        }\n        \n", "        public void AddRect(Rect rect, float width, UiColor backColor, UiColor frontColor) {\n            var last = _quads.Length;\n            if (_quads.Capacity <= last + 2) EnsureCapacity(last + 2);\n            _quads.Length = last + 2;\n            ref var quad1 = ref _quads.Ptr[last];\n            ref var quad2 = ref _quads.Ptr[last + 1];\n            quad1.V3.Position.x = quad1.V0.Position.x = rect.xMin;\n            quad2.V3.Position.x = quad2.V0.Position.x = rect.xMin + width;\n            quad1.V1.Position.y = quad1.V0.Position.y = rect.yMax;\n            quad2.V1.Position.y = quad2.V0.Position.y = rect.yMax - width;\n            quad1.V2.Position.x = quad1.V1.Position.x = rect.xMax;\n            quad2.V2.Position.x = quad2.V1.Position.x = rect.xMax - width;\n            quad1.V3.Position.y = quad1.V2.Position.y = rect.yMin;\n            quad2.V3.Position.y = quad2.V2.Position.y = rect.yMin + width;\n            quad1.V3.Color = quad1.V2.Color = quad1.V1.Color = quad1.V0.Color = backColor;\n            quad2.V3.Color = quad2.V2.Color = quad2.V1.Color = quad2.V0.Color = frontColor;\n            quad2.V3.Options.Size = quad2.V2.Options.Size = quad2.V1.Options.Size = quad2.V0.Options.Size =\n                quad1.V3.Options.Size = quad1.V2.Options.Size = quad1.V1.Options.Size = quad1.V0.Options.Size = 255;\n            quad2.V3.UV = quad2.V2.UV = quad2.V1.UV =\n                quad2.V0.UV = quad1.V3.UV = quad1.V2.UV = quad1.V1.UV = quad1.V0.UV = CircleCenter;\n        }\n", "        public void AddRect(BoundingBox box, UiColor color) {\n            var last = _quads.Length;\n            if (_quads.Capacity <= last + 1) EnsureCapacity(last + 1);\n            _quads.Length = last + 1;\n            ref var quad = ref _quads.Ptr[last];\n            quad.V3.Position.x = quad.V0.Position.x = box.XMin;\n            quad.V1.Position.y = quad.V0.Position.y = box.YMax;\n            quad.V2.Position.x = quad.V1.Position.x = box.XMax;\n            quad.V3.Position.y = quad.V2.Position.y = box.YMin;\n            quad.V3.Color = quad.V2.Color = quad.V1.Color = quad.V0.Color = color;\n            quad.V3.Options.Size = quad.V2.Options.Size = quad.V1.Options.Size = quad.V0.Options.Size = 255;\n            quad.V3.UV = quad.V2.UV = quad.V1.UV = quad.V0.UV = CircleCenter;\n        }", "        public void AddRect(float xMin,float xMax,float yMin,float yMax, UiColor color) {\n            var last = _quads.Length;\n            if (_quads.Capacity <= last + 1) EnsureCapacity(last + 1);\n            _quads.Length = last + 1;\n            ref var quad = ref _quads.Ptr[last];\n            quad.V3.Position.x = quad.V0.Position.x = xMin;\n            quad.V1.Position.y = quad.V0.Position.y = yMax;\n            quad.V2.Position.x = quad.V1.Position.x = xMax;\n            quad.V3.Position.y = quad.V2.Position.y = yMin;\n            quad.V3.Color = quad.V2.Color = quad.V1.Color = quad.V0.Color = color;\n            quad.V3.Options.Size = quad.V2.Options.Size = quad.V1.Options.Size = quad.V0.Options.Size = 255;\n            quad.V3.UV = quad.V2.UV = quad.V1.UV = quad.V0.UV = CircleCenter;\n        }\n", "        public void InsertQuad(int index, Rect rect, UiColor color) {\n            CheckAddLength(1);\n            ;\n            var scale = new Vector2(rect.width, -rect.height);\n            var position = new Vector2(rect.xMin, rect.yMax);\n            var uv = CircleCenter;\n            ref var quad = ref _quads.InsertRef(index);\n            quad.V0.Write(position + new Vector2(0, scale.y), 255, color, uv);\n            quad.V1.Write(position + scale, 255, color, uv);\n            quad.V2.Write(position + new Vector2(scale.x, 0), 255, color, uv);\n            quad.V3.Write(position, 255, color, uv);\n        }\n\n", "        public void AddHorizontalGradient(Rect rect, UiColor leftColor, UiColor rightColor) {\n            CheckAddLength(1);\n            var last = _quads.Length;\n            _quads.Length = last + 1;\n            var scale = new Vector2(rect.width, rect.height);\n            var position = rect.min;\n            var uv = CircleCenter;\n            ref var quad = ref _quads.Ptr[last];\n            quad.V0.Write(position + new Vector2(0, scale.y), 255, leftColor, uv);\n            quad.V1.Write(position + scale, 255, rightColor, uv);\n            quad.V2.Write(position + new Vector2(scale.x, 0), 255, rightColor, uv);\n            quad.V3.Write(position, 255, leftColor, uv);\n        }\n", "        public void AddGradient(Rect rect, UiColor topLeftColor, UiColor topRightColor, UiColor bottomLeftColor,\n            UiColor bottomRightColor) {\n            CheckAddLength(1);\n            var last = _quads.Length;\n            _quads.Length = last + 1;\n            ref var quad = ref _quads.Ptr[last];\n            var scale = new Vector2(rect.width, rect.height);\n            var position = new Vector2(rect.xMin, rect.yMax);\n            var uv = CircleCenter;\n            quad.V0.Write(position + new Vector2(0, scale.y), 255, topLeftColor, uv);\n            quad.V1.Write(position + scale, 255, topRightColor, uv);\n            quad.V2.Write(position + new Vector2(scale.x, 0), 255, bottomRightColor, uv);\n            quad.V3.Write(position, 255, bottomLeftColor, uv);\n        }\n\n", "        public void AddLine(Vector2 start, Vector2 end, float width, UiColor color) {\n            var last = _quads.Length;\n            if (last == _quads.Capacity) CheckAddLength(1);\n            _quads.Length = last + 1;\n            _quads.Ptr[last].WriteLine(start, end, width, color, CircleCenter);\n        }\n\n        public void AddLine(Vector2 start, Vector2 end, float width, UiColor startColor, UiColor endColor) {\n            var last = _quads.Length;\n            if (last == _quads.Capacity) CheckAddLength(1);\n            _quads.Length = last + 1;\n            _quads.Ptr[last].WriteLine(start, end, width, startColor, endColor, CircleCenter);\n        }\n", "            if (last == _quads.Capacity) CheckAddLength(1);\n            _quads.Length = last + 1;\n            _quads.Ptr[last].WriteLine(start, end, width, startColor, endColor, CircleCenter);\n        }\n\n        public void AddLines(ReadOnlySpan<Vector2> points, float width, UiColor color) {\n            if (points.Length <=1) return;\n            var p0 = points[0];\n            var p1 = points[1];\n            if (points.Length == 2) {\n                AddLine(p0, p1, width, color);\n                return;\n            }\n            var half = width / 2;\n            var span = ReadAdditionalQuadSpan(points.Length - 1);\n            Quad.SetUpQuadColorUV(span, color, CircleCenter);\n            var p2 = points[2];\n            var n0 = (p1 -p0).Perpendicular();\n            var n1 = (p2 -p1).Perpendicular();\n            {\n                ref var quad = ref span[0];\n                var verticalX = n0.x * half;\n                var verticalY = n0.y * half;\n                quad.V0.Position.x = p0.x +verticalX;\n                quad.V0.Position.y = p0.y +verticalY;\n                quad.V3.Position.x = p0.x -verticalX;\n                quad.V3.Position.y = p0.y -verticalY;\n                var interSection = NormIntersection(n0, n1);\n                var interSectionX = interSection.x * half;\n                var interSectionY = interSection.y * half;\n                quad.V1.Position.x = p1.x+ interSectionX;\n                quad.V1.Position.y = p1.y +interSectionY;\n                quad.V2.Position.x = p1.x -interSectionX;\n                quad.V2.Position.y = p1.y -interSectionY;\n            }\n            var end = p2;\n            var lastN = n1;\n            var lastV1 = span[0].V1.Position;\n            var lastV2 = span[0].V2.Position;", "            if (points.Length == 2) {\n                AddLine(p0, p1, width, color);\n                return;\n            }\n            var half = width / 2;\n            var span = ReadAdditionalQuadSpan(points.Length - 1);\n            Quad.SetUpQuadColorUV(span, color, CircleCenter);\n            var p2 = points[2];\n            var n0 = (p1 -p0).Perpendicular();\n            var n1 = (p2 -p1).Perpendicular();\n            {\n                ref var quad = ref span[0];\n                var verticalX = n0.x * half;\n                var verticalY = n0.y * half;\n                quad.V0.Position.x = p0.x +verticalX;\n                quad.V0.Position.y = p0.y +verticalY;\n                quad.V3.Position.x = p0.x -verticalX;\n                quad.V3.Position.y = p0.y -verticalY;\n                var interSection = NormIntersection(n0, n1);\n                var interSectionX = interSection.x * half;\n                var interSectionY = interSection.y * half;\n                quad.V1.Position.x = p1.x+ interSectionX;\n                quad.V1.Position.y = p1.y +interSectionY;\n                quad.V2.Position.x = p1.x -interSectionX;\n                quad.V2.Position.y = p1.y -interSectionY;\n            }\n            var end = p2;\n            var lastN = n1;\n            var lastV1 = span[0].V1.Position;\n            var lastV2 = span[0].V2.Position;", "            for (var index = 1; index < span.Length-1; index++) {\n                var nextP = points[index + 2];\n                var n=(nextP -end).Perpendicular();\n                var interSection = NormIntersection(lastN, n);\n                lastN = n;\n                var interSectionX = interSection.x * half;\n                var interSectionY = interSection.y * half;\n                ref var quad = ref span[index];\n                quad.V0.Position = lastV1;\n                quad.V3.Position= lastV2;\n                quad.V1.Position.x = end.x+ interSectionX;\n                quad.V1.Position.y = end.y +interSectionY;\n                lastV1 = quad.V1.Position;\n                quad.V2.Position.x = end.x -interSectionX;\n                quad.V2.Position.y = end.y -interSectionY;\n                lastV2 = quad.V2.Position;\n                end = nextP;\n            }\n            {\n                ref var quad = ref span[^1];\n                quad.V0.Position = lastV1;\n                quad.V3.Position= lastV2;\n                var interSectionX = lastN.x * half;\n                var interSectionY = lastN.y * half;\n                quad.V1.Position.x = end.x + interSectionX;\n                quad.V1.Position.y = end.y +interSectionY;\n                quad.V2.Position.x = end.x -interSectionX;\n                quad.V2.Position.y = end.y -interSectionY;\n            }\n        }", "        public void AddLinesLoop(ReadOnlySpan<Vector2> points, float width, UiColor color) {\n            if (points.Length <=1) return;\n            var p0 = points[0];\n            var p1 = points[1];\n            if (points.Length == 2) {\n                AddLine(p0, p1, width, color);\n                return;\n                ;\n            }\n            var half = width / 2;\n            var span = ReadAdditionalQuadSpan(points.Length );\n            Quad.SetUpQuadColorUV(span, color, CircleCenter);\n            var p2 = points[2];\n            var n0 = (p1 -p0).Perpendicular();\n            var n1 = (p2 -p1).Perpendicular();\n            {\n                ref var quad = ref span[0];\n                var interSection = NormIntersection(n0, n1)* half;\n                quad.V1.Position = p1+ interSection;\n                quad.V2.Position= p1 - interSection;\n            }\n            var end = p2;\n            var lastN = n1;\n            var lastV1 = span[0].V1.Position;\n            var lastV2 = span[0].V2.Position;", "            for (var index = 1; index < span.Length-1; index++) {\n                var nextP = points[index==span.Length-2?0:(index + 2)];\n                var n=(nextP -end).Perpendicular();\n                var interSection = NormIntersection(lastN, n)* half;\n                lastN = n;\n                ref var quad = ref span[index];\n                quad.V0.Position = lastV1;\n                quad.V3.Position= lastV2;\n                quad.V1.Position = lastV1=end+ interSection;\n                quad.V2.Position =lastV2= end -interSection;\n                end = nextP;\n            }\n            {\n                var interSection = MathHelper.NormIntersection(lastN, n0)* half;\n                ref var last = ref span[^1];\n                ref var first = ref span[0];\n                last.V0.Position = lastV1;\n                last.V3.Position= lastV2;\n                first.V0.Position = last.V1.Position= end + interSection;\n                first.V3.Position =  last.V2.Position = end -interSection;\n            }\n        }\n        ", "        public void AddUnScaledUV(Vector4 uv,Vector2 center, float size, UiColor color) {\n            var last = _quads.Length;\n            if (last == _quads.Capacity) CheckAddLength(1);\n            _quads.Length = last + 1;\n            _quads.Ptr[last].WriteCircle(center, size/2, color,uv);\n        }\n        public void AddCircle(Rect rect, UiColor color) {\n            CheckAddLength(1);\n            var last = _quads.Length;\n            _quads.Length = last + 1;\n            Quad.WriteWithOutUVScale(ref _quads.Ptr[last], new Vector2(rect.width, -rect.height),\n                new Vector2(rect.xMin, rect.yMax), color, CircleUV);\n        }\n", "        public void AddCircle(Vector2 center, float radius, UiColor color) {\n            var last = _quads.Length;\n            if (last == _quads.Capacity) CheckAddLength(1);\n            _quads.Length = last + 1;\n            _quads.Ptr[last].WriteCircle(center, radius, color, CircleUV);\n        }\n        public void AddCircle(Vector2 center, float backRadius, UiColor backColor, float frontRadius,\n            UiColor frontColor) {\n            var length = _quads.Length;\n            if (_quads.Capacity <= length + 2) EnsureCapacity(length + 2);\n            _quads.Length = length + 2;\n            ref var quad1 = ref _quads.Ptr[length];\n            ref var quad2 = ref _quads.Ptr[length + 1];\n            quad1.SetColorAndSize(backColor,backRadius < 85 ? (byte) (frontRadius * 3) : (byte) 255);\n            quad2.SetColorAndSize(frontColor,frontRadius < 85 ? (byte) (backRadius * 3) : (byte) 255);\n            quad1.V3.Position.x = quad1.V0.Position.x = center.x - backRadius;\n            quad1.V1.Position.y = quad1.V0.Position.y = center.y + backRadius;\n            quad1.V2.Position.x = quad1.V1.Position.x = center.x + backRadius;\n            quad1.V3.Position.y = quad1.V2.Position.y = center.y - backRadius;\n            quad2.V3.Position.x = quad2.V0.Position.x = center.x - frontRadius;\n            quad2.V1.Position.y = quad2.V0.Position.y = center.y + frontRadius;\n            quad2.V2.Position.x = quad2.V1.Position.x = center.x + frontRadius;\n            quad2.V3.Position.y = quad2.V2.Position.y = center.y - frontRadius;\n            quad2.V3.UV.x = quad2.V0.UV.x = quad1.V3.UV.x = quad1.V0.UV.x = CircleUV.z;\n            quad2.V1.UV.y = quad2.V0.UV.y = quad1.V1.UV.y = quad1.V0.UV.y = CircleUV.w + CircleUV.y;\n            quad2.V2.UV.x = quad2.V1.UV.x = quad1.V2.UV.x = quad1.V1.UV.x = CircleUV.x + CircleUV.z;\n            quad2.V3.UV.y = quad2.V2.UV.y = quad1.V3.UV.y = quad1.V2.UV.y = CircleUV.w;\n        }\n      ", "            if (_quads.Capacity <= length + 2) EnsureCapacity(length + 2);\n            _quads.Length = length + 2;\n            ref var quad1 = ref _quads.Ptr[length];\n            ref var quad2 = ref _quads.Ptr[length + 1];\n            quad1.SetColorAndSize(backColor,backRadius < 85 ? (byte) (frontRadius * 3) : (byte) 255);\n            quad2.SetColorAndSize(frontColor,frontRadius < 85 ? (byte) (backRadius * 3) : (byte) 255);\n            quad1.V3.Position.x = quad1.V0.Position.x = center.x - backRadius;\n            quad1.V1.Position.y = quad1.V0.Position.y = center.y + backRadius;\n            quad1.V2.Position.x = quad1.V1.Position.x = center.x + backRadius;\n            quad1.V3.Position.y = quad1.V2.Position.y = center.y - backRadius;\n            quad2.V3.Position.x = quad2.V0.Position.x = center.x - frontRadius;\n            quad2.V1.Position.y = quad2.V0.Position.y = center.y + frontRadius;\n            quad2.V2.Position.x = quad2.V1.Position.x = center.x + frontRadius;\n            quad2.V3.Position.y = quad2.V2.Position.y = center.y - frontRadius;\n            quad2.V3.UV.x = quad2.V0.UV.x = quad1.V3.UV.x = quad1.V0.UV.x = CircleUV.z;\n            quad2.V1.UV.y = quad2.V0.UV.y = quad1.V1.UV.y = quad1.V0.UV.y = CircleUV.w + CircleUV.y;\n            quad2.V2.UV.x = quad2.V1.UV.x = quad1.V2.UV.x = quad1.V1.UV.x = CircleUV.x + CircleUV.z;\n            quad2.V3.UV.y = quad2.V2.UV.y = quad1.V3.UV.y = quad1.V2.UV.y = CircleUV.w;\n        }\n      ", "        public void AddRadialFilledCircle(Vector2 center, float radius, UiColor color,float fillAmount) {\n            AddRadialFilledUnScaledUV(CircleUV, center, radius*2, color, fillAmount);\n        }  \n        public void AddRadialFilledSquare(Vector2 center, float size, UiColor color,float fillAmount) {\n            AddRadialFilledUnScaledUV(new Vector4(0,0,CircleCenter.x,CircleCenter.y), center, size, color, fillAmount);\n        }\n        public void AddRadialFilledUnScaledUV(Vector4 uv,Vector2 center, float size, UiColor color,float fillAmount) {\n            if (fillAmount <= 0) return;\n            fillAmount = Mathf.Clamp01(fillAmount);\n            if (fillAmount == 1) {\n                AddUnScaledUV(uv,center, size, color);\n                return;\n            }\n            var radius = size / 2;\n            var centerUV=  new Vector2(uv.z + uv.x / 2, uv.w + uv.y / 2);\n            var last = _quads.Length;", "            if (fillAmount == 1) {\n                AddUnScaledUV(uv,center, size, color);\n                return;\n            }\n            var radius = size / 2;\n            var centerUV=  new Vector2(uv.z + uv.x / 2, uv.w + uv.y / 2);\n            var last = _quads.Length;\n            if ( _quads.Capacity<last+3) EnsureCapacity(last+3);\n            _quads.Length = last + 1;\n            ref var quad = ref _quads.Ptr[last];\n            quad.SetColorAndSize(color,radius < 85 ? (byte) (radius * 3) : (byte) 255);\n            quad.V0.Position =center;\n            quad.V0.UV = centerUV;\n            quad.V1.Position =center+new Vector2(0,radius);\n            quad.V1.UV.x =  centerUV.x;\n            quad.V1.UV.y =   uv.w + uv.y;", "            if (fillAmount <= 0.125f) {\n                var t =  FastTan2PI(fillAmount);\n                quad.V3.Position = quad.V2.Position=center+new Vector2(t*radius,radius);\n                quad.V3.UV = quad.V2.UV = new Vector2(centerUV.x + t * uv.x / 2,  quad.V1.UV.y);\n                return;\n            }\n            quad.V2.Position =center+new Vector2(radius,radius);\n            quad.V2.UV.y =  quad.V1.UV.y;\n            quad.V2.UV.x =  uv.x + uv.z;\n            if (fillAmount <= 0.375f) {\n                var t= FastTan2PI(0.25f-fillAmount);\n                quad.V3.Position =center+new Vector2(radius,t*radius);\n                quad.V3.UV.y = centerUV.y + uv.y * t / 2;\n                quad.V3.UV.x =  uv.x + uv.z;\n                return;\n            }\n            {\n                quad.V3.Position =center+new Vector2(radius,-radius);\n                quad.V3.UV.y = uv.w;\n                quad.V3.UV.x =  uv.x + uv.z;\n            }\n            _quads.Length = last + 2;\n            ref var quad2 = ref _quads.Ptr[last+1];\n            quad2.SetColorAndSize(color,quad.V0.Options.Size);\n            quad2.V0 = quad.V0;\n            quad2.V1=  quad.V3;", "            if (fillAmount <= 0.375f) {\n                var t= FastTan2PI(0.25f-fillAmount);\n                quad.V3.Position =center+new Vector2(radius,t*radius);\n                quad.V3.UV.y = centerUV.y + uv.y * t / 2;\n                quad.V3.UV.x =  uv.x + uv.z;\n                return;\n            }\n            {\n                quad.V3.Position =center+new Vector2(radius,-radius);\n                quad.V3.UV.y = uv.w;\n                quad.V3.UV.x =  uv.x + uv.z;\n            }\n            _quads.Length = last + 2;\n            ref var quad2 = ref _quads.Ptr[last+1];\n            quad2.SetColorAndSize(color,quad.V0.Options.Size);\n            quad2.V0 = quad.V0;\n            quad2.V1=  quad.V3;", "            if (fillAmount <= 0.625f) {\n                var t =  FastTan2PI(0.5f-fillAmount);\n                quad2.V3.Position = quad2.V2.Position=center+new Vector2(t*radius,-radius);\n                quad2.V3.UV = quad2.V2.UV = new Vector2(centerUV.x + t * uv.x / 2, uv.w);\n                return;\n            }\n            quad2.V2.Position =center-new Vector2(radius,radius);\n            quad2.V2.UV.y =  uv.w;\n            quad2.V2.UV.x =  uv.z;\n            if (fillAmount <= 0.875f) {\n                var t = FastTan2PI(fillAmount-0.75f);\n                quad2.V3.Position =center+new Vector2(-radius,radius*t);\n                quad2.V3.UV.y = centerUV.y + uv.y *t / 2;\n                quad2.V3.UV.x =  uv.z;\n                return;\n            }\n            {\n                quad2.V3.Position =center+new Vector2(-radius,radius);\n                quad2.V3.UV.y =uv.y+uv.w;\n                quad2.V3.UV.x =  uv.z;\n            }\n            _quads.Length = last + 3;\n            ref var quad3 = ref _quads.Ptr[last+2];\n            {\n                quad3.V0 = quad2.V0;\n                quad3.V2 = quad3.V1 = quad2.V3;\n                quad3.V3.Options.Size = quad3.V0.Options.Size;\n                quad3.V3.Color = quad3.V0.Color;\n                quad3.V3.Position.y = center.y + radius;\n                quad3.V3.UV.y = quad3.V2.UV.y;\n                var t =  FastTan2PI((1-fillAmount));\n                quad3.V3.Position.x =center.x-radius*t;\n                quad3.V3.UV.x =  centerUV.x-uv.x *t / 2;\n            }\n        }\n", "            if (fillAmount <= 0.875f) {\n                var t = FastTan2PI(fillAmount-0.75f);\n                quad2.V3.Position =center+new Vector2(-radius,radius*t);\n                quad2.V3.UV.y = centerUV.y + uv.y *t / 2;\n                quad2.V3.UV.x =  uv.z;\n                return;\n            }\n            {\n                quad2.V3.Position =center+new Vector2(-radius,radius);\n                quad2.V3.UV.y =uv.y+uv.w;\n                quad2.V3.UV.x =  uv.z;\n            }\n            _quads.Length = last + 3;\n            ref var quad3 = ref _quads.Ptr[last+2];\n            {\n                quad3.V0 = quad2.V0;\n                quad3.V2 = quad3.V1 = quad2.V3;\n                quad3.V3.Options.Size = quad3.V0.Options.Size;\n                quad3.V3.Color = quad3.V0.Color;\n                quad3.V3.Position.y = center.y + radius;\n                quad3.V3.UV.y = quad3.V2.UV.y;\n                var t =  FastTan2PI((1-fillAmount));\n                quad3.V3.Position.x =center.x-radius*t;\n                quad3.V3.UV.x =  centerUV.x-uv.x *t / 2;\n            }\n        }\n", "        public float CalculateLength(ReadOnlySpan<char> text, float fontSize) {\n            var map = Map;\n            var deltaOffsetX = fontSize / 4;\n            var spaceXAdvance = SpaceXAdvance;\n            foreach (var c in text) {\n                deltaOffsetX += c == ' ' ? spaceXAdvance : map.GetRef(c).XAdvance;\n            }\n\n            return deltaOffsetX * fontSize;\n        }\n", "        public float CalculateLength(ReadOnlySpan<char> text, float fontSize, Span<int> infoIndices) {\n            var map = Map;\n            var deltaOffsetX = 0f;\n            var spaceXAdvance = SpaceXAdvance;\n            for (var i = 0; i < text.Length; i++) {\n                var c = text[i];\n                if (c == ' ') {\n                    deltaOffsetX += spaceXAdvance;\n                    infoIndices[i] = -1;\n                }\n                else {\n                    var index = map.GetEntryIndex(c);\n                    infoIndices[i] = index;\n                    deltaOffsetX += map.GetFromEntryIndex(index).XAdvance;\n                }\n            }\n\n            return deltaOffsetX * fontSize;\n        }\n", "        public void AddCenterText(Rect rect, float fontSize, ReadOnlySpan<char> span, UiColor textColor) {\n            if (span.Length == 0||rect.width<=0) return ;\n            var scale = new Vector2(fontSize, fontSize);\n            var position = new Vector2(rect.xMin, rect.yMin + rect.height / 2 - fontSize / 4);\n            scale *= InvUvScale;\n            var ptr = _quads.Ptr + _quads.Length;\n            var xMax = rect.xMax;\n            var normXMax = (rect.width) / fontSize;\n            var writeCount = 0;\n            var deltaOffsetX = 0f;\n            foreach (var c in span) {", "            foreach (var c in span) {\n                if (c == ' ') {\n                    deltaOffsetX += SpaceXAdvance;\n                    if (normXMax < deltaOffsetX) {\n                        deltaOffsetX = normXMax;\n                        break;\n                    }\n                }\n                else {\n                    ref var quad = ref ptr++[0];\n                    ref readonly var info = ref Map.GetRef(c);\n                    quad.Write(position.x+fontSize * deltaOffsetX,position.y,scale,fontSize,info);\n                    deltaOffsetX += info.XAdvance;\n                    ++writeCount;", "                    if (normXMax > deltaOffsetX) continue;\n                    quad.MaskTextMaxX(xMax);\n                    break;\n                }\n            }\n            var scaleX = (byte) Mathf.Clamp((int) fontSize, 0, 255);\n            if (normXMax < deltaOffsetX) {\n                for (int i = 0; i < writeCount; i++) {\n                    (--ptr)->SetColorAndSize(textColor, scaleX);\n                }\n            }\n            else {\n                var scaledDelta = (rect.width - fontSize * deltaOffsetX)/2 ;", "                for (int i = 0; i < writeCount; i++) {\n                    (--ptr)->SetColorAndSize(textColor, scaleX);\n                    ptr->MoveX(scaledDelta);\n                }\n            }\n\n            _quads.Length += writeCount;\n        }\n        public void AddCenterText(Vector2 center,float width, float fontSize, ReadOnlySpan<char> span, UiColor textColor) {\n            if (span.Length == 0||width<=0) return ;\n            var scale = new Vector2(fontSize, fontSize);\n            var position = new Vector2(center.x-width/2,center.y - fontSize / 4);\n            scale *= InvUvScale;\n            var ptr = _quads.Ptr + _quads.Length;\n            var xMax = center.x+width/2;\n            var normXMax = width / fontSize;\n            var writeCount = 0;\n            var deltaOffsetX = 0f;", "        public void AddCenterText(Vector2 center,float width, float fontSize, ReadOnlySpan<char> span, UiColor textColor) {\n            if (span.Length == 0||width<=0) return ;\n            var scale = new Vector2(fontSize, fontSize);\n            var position = new Vector2(center.x-width/2,center.y - fontSize / 4);\n            scale *= InvUvScale;\n            var ptr = _quads.Ptr + _quads.Length;\n            var xMax = center.x+width/2;\n            var normXMax = width / fontSize;\n            var writeCount = 0;\n            var deltaOffsetX = 0f;\n            foreach (var c in span) {", "            foreach (var c in span) {\n                if (c == ' ') {\n                    deltaOffsetX += SpaceXAdvance;\n                    if (normXMax < deltaOffsetX) {\n                        deltaOffsetX = normXMax;\n                        break;\n                    }\n                }\n                else {\n                    ref var quad = ref ptr++[0];\n                    ref readonly var info = ref Map.GetRef(c);\n                    quad.Write(position.x+fontSize * deltaOffsetX,position.y,scale,fontSize,info);\n                    deltaOffsetX += info.XAdvance;\n                    ++writeCount;", "                    if (normXMax > deltaOffsetX) continue;\n                    quad.MaskTextMaxX(xMax);\n                    break;\n                }\n            }\n            var scaleX = (byte) Mathf.Clamp((int) fontSize, 0, 255);\n            if (normXMax < deltaOffsetX) {\n                for (int i = 0; i < writeCount; i++) {\n                    (--ptr)->SetColorAndSize(textColor, scaleX);\n                }\n            }\n            else {\n                var scaledDelta = (width - fontSize * deltaOffsetX)/2 ;", "                for (int i = 0; i < writeCount; i++) {\n                    (--ptr)->SetColorAndSize(textColor, scaleX);\n                    ptr->MoveX(scaledDelta);\n                }\n            }\n\n            _quads.Length += writeCount;\n        }\n\n      \n", "        public float AddText(Rect rect, ReadOnlySpan<char> span, UiColor color) {\n            if (span.Length == 0||rect.width<=0) return 0;\n            CheckAddLength(span.Length);\n            var fontSize = rect.height;\n            var position = new Vector2(rect.xMin, rect.yMin + rect.height / 2 - fontSize / 3);\n            var xMax = rect.xMax;\n            var scale = new Vector2(fontSize, fontSize);\n            scale *= InvUvScale;\n            var normXMax = (xMax - position.x) / fontSize;\n            var ptr = _quads.Ptr + _quads.Length;\n            var writeCount = 0;\n            var deltaOffsetX = fontSize / 4;", "            foreach (var c in span) {\n                if (c == ' ') {\n                    deltaOffsetX += SpaceXAdvance;\n                    if (normXMax < deltaOffsetX) {\n                        deltaOffsetX = normXMax;\n                        break;\n                    }\n                }\n                else {\n                    ref var quad = ref ptr++[0];\n                    ref readonly var info = ref Map.GetRef(c);\n                    quad.Write(position.x+fontSize * deltaOffsetX,position.y,scale,fontSize,info);\n                    deltaOffsetX += info.XAdvance;\n                    ++writeCount;", "                    if (normXMax > deltaOffsetX) continue;\n                    quad.MaskTextMaxX(xMax);\n                    break;\n                }\n            }\n\n            var scaleX = (byte) Mathf.Clamp((int) fontSize, 0, 255);\n            for (int i = 0; i < writeCount; i++) {\n                (--ptr)->SetColorAndSize(color, scaleX);\n            }\n\n            _quads.Length += writeCount;\n            return fontSize * deltaOffsetX;\n        }", "        public float AddTextNoMask(Rect rect, float fontSize, ReadOnlySpan<char> span, UiColor color) {\n            if (span.Length == 0) return 0;\n            CheckAddLength(span.Length);\n            var position = new Vector2(rect.xMin, rect.yMin + rect.height / 2 - fontSize / 3);\n            var xMax = rect.xMax;\n            var scale = fontSize*InvUvScale;\n            var ptr = _quads.Ptr + _quads.Length;\n            var writeCount = 0;\n            var nextX = position.x+fontSize / 4;\n            foreach (var c in span) {\n                if (c == ' ') {\n                    nextX += SpaceXAdvance*fontSize;\n                }\n                ref var quad = ref ptr++[0];\n                ref readonly var info = ref Map.GetRef(c);\n                quad.Write(nextX,position.y,scale,fontSize,info);\n                nextX += info.XAdvance*fontSize;\n                ++writeCount;\n            }\n            var scaleX = (byte) Mathf.Clamp((int) fontSize, 0, 255);", "            foreach (var c in span) {\n                if (c == ' ') {\n                    nextX += SpaceXAdvance*fontSize;\n                }\n                ref var quad = ref ptr++[0];\n                ref readonly var info = ref Map.GetRef(c);\n                quad.Write(nextX,position.y,scale,fontSize,info);\n                nextX += info.XAdvance*fontSize;\n                ++writeCount;\n            }\n            var scaleX = (byte) Mathf.Clamp((int) fontSize, 0, 255);", "            for (int i = 0; i < writeCount; i++) {\n                (--ptr)->SetColorAndSize(color, scaleX);\n            }\n            _quads.Length += writeCount;\n            return nextX-position.x;\n        }\n        public float AddText(Rect rect, float fontSize, ReadOnlySpan<char> span, ReadOnlySpan<(int length,UiColor color)> colors) {\n            if (span.Length == 0||rect.width<=0) return 0;\n            CheckAddLength(span.Length);\n            var position = new Vector2(rect.xMin, rect.yMin + rect.height / 2 - fontSize / 3);\n            var xMax = rect.xMax;\n            var scale = fontSize*InvUvScale;\n            var ptr = _quads.Ptr + _quads.Length;\n            var writeCount = 0;\n            var nextX = position.x+fontSize / 4;\n            var colorRemainLength = colors[0].length;\n            var colorIndex =0;\n            var color = colors[0].color;", "            foreach (var c in span) {\n                while (--colorRemainLength < 0) {\n                    (colorRemainLength, color)= colors[++colorIndex];\n                }\n                if (c == ' ') {\n                    nextX += SpaceXAdvance*fontSize;\n                    if (nextX < xMax) continue;\n                    break;\n                }\n                ref var quad = ref ptr++[0];\n                ref readonly var info = ref Map.GetRef(c);\n                quad.Write(nextX,position.y,scale,fontSize,info);\n                quad.SetColor(color);\n                nextX += info.XAdvance*fontSize;\n                ++writeCount;", "                if (nextX <xMax) continue;\n                quad.MaskTextMaxX(xMax);\n                break;\n            }\n            var scaleX = (byte) Mathf.Clamp((int) fontSize, 0, 255);\n            for (int i = 0; i < writeCount; i++) {\n                (--ptr)->SetSize(scaleX);\n            }\n\n            _quads.Length += writeCount;\n            return nextX-position.x;\n        }\n", "        public float AddText(Rect rect, float fontSize, ReadOnlySpan<char> span, UiColor color) {\n            if (span.Length == 0) return 0;\n            CheckAddLength(span.Length);\n            var position = new Vector2(rect.xMin, rect.yMin + rect.height / 2 - fontSize / 3);\n            var xMax = rect.xMax;\n            var scale = fontSize*InvUvScale;\n            var ptr = _quads.Ptr + _quads.Length;\n            var writeCount = 0;\n            var nextX = position.x+fontSize / 4;\n            foreach (var c in span) {\n                if (c == ' ') {\n                    nextX += SpaceXAdvance*fontSize;", "            foreach (var c in span) {\n                if (c == ' ') {\n                    nextX += SpaceXAdvance*fontSize;\n                    if (nextX < xMax) continue;\n                    break;\n                }\n                ref var quad = ref ptr++[0];\n                ref readonly var info = ref Map.GetRef(c);\n                quad.Write(nextX,position.y,scale,fontSize,info);\n                nextX += info.XAdvance*fontSize;\n                ++writeCount;", "                if (nextX <xMax) continue;\n                quad.MaskTextMaxX(xMax);\n                break;\n            }\n            var scaleX = (byte) Mathf.Clamp((int) fontSize, 0, 255);\n            for (int i = 0; i < writeCount; i++) {\n                (--ptr)->SetColorAndSize(color, scaleX);\n            }\n            _quads.Length += writeCount;\n            return nextX-position.x;\n        }", "       public float AddText(Rect rect, float fontSize, ReadOnlySpan<char> span1,ReadOnlySpan<char> span2, UiColor color) {\n           var length = span1.Length + span2.Length;\n            if (length==0) return 0;\n            CheckAddLength(length);\n            var position = new Vector2(rect.xMin+fontSize / 4, rect.yMin + rect.height / 2 - fontSize / 3);\n            var xMax = rect.xMax;\n            var scale = fontSize*InvUvScale;\n            var ptr = _quads.Ptr + _quads.Length;\n            var writeCount = 0;\n            var nextX = position.x;\n            ", "            foreach (var c in span1) {\n                if (c == ' ') {\n                    nextX += SpaceXAdvance*fontSize;\n                    if (nextX < xMax) continue;\n                    goto EndWrite;\n                }\n                ref var quad = ref ptr++[0];\n                ref readonly var info = ref Map.GetRef(c);\n                quad.Write(nextX,position.y,scale,fontSize,info);\n                nextX += info.XAdvance*fontSize;\n                ++writeCount;", "                if (nextX <xMax) continue;\n                quad.MaskTextMaxX(xMax);\n                goto EndWrite;\n            }\n            foreach (var c in span2) {\n                if (c == ' ') {\n                    nextX += SpaceXAdvance*fontSize;\n                    if (nextX < xMax) continue;\n                    break;\n                }\n                if(c is '\\r'or '\\n' ) {\n                    break;\n                }\n                ref var quad = ref ptr++[0];\n                ref readonly var info = ref Map.GetRef(c);\n                quad.Write(nextX,position.y,scale,fontSize,info);\n                nextX += info.XAdvance*fontSize;\n                ++writeCount;", "                if(c is '\\r'or '\\n' ) {\n                    break;\n                }\n                ref var quad = ref ptr++[0];\n                ref readonly var info = ref Map.GetRef(c);\n                quad.Write(nextX,position.y,scale,fontSize,info);\n                nextX += info.XAdvance*fontSize;\n                ++writeCount;\n                if (nextX <xMax) continue;\n                quad.MaskTextMaxX(xMax);\n                break;\n            }\n            EndWrite:\n            var scaleX = (byte) Mathf.Clamp((int) fontSize, 0, 255);", "                if (nextX <xMax) continue;\n                quad.MaskTextMaxX(xMax);\n                break;\n            }\n            EndWrite:\n            var scaleX = (byte) Mathf.Clamp((int) fontSize, 0, 255);\n            for (int i = 0; i < writeCount; i++) {\n                (--ptr)->SetColorAndSize(color, scaleX);\n            }\n            _quads.Length += writeCount;\n            return nextX-position.x;\n        }\n       \n      ", "        public void AddTextMultiLine(Rect rect, float fontSize,float yMin,ReadOnlySpan<string> enumerable, UiColor color) {\n            var fullLength = 0;\n            foreach (var text in enumerable) {\n                fullLength += text.Length;\n            }\n            CheckAddLength(fullLength);\n            if (fullLength == 0) return;\n            var position = new Vector2(rect.xMin+fontSize / 4,LineHeight+ rect.yMin + rect.height / 2 - fontSize / 3);\n            var xMax = rect.xMax;\n            var scale = fontSize*InvUvScale;\n            var ptr = _quads.Ptr + _quads.Length;\n            var writeCount = 0;", "            foreach (var text in enumerable) {\n                position.y -= LineHeight*fontSize;\n                if (position.y < yMin) break;\n                var span =text.AsSpan();\n                var nextX = position.x;\n                foreach (var c in span) {\n                    if (c == ' ') {\n                        nextX += SpaceXAdvance*fontSize;\n                        if (nextX < xMax) continue;\n                        break;\n                    }\n                    ref var quad = ref ptr++[0];\n                    ref readonly var info = ref Map.GetRef(c);\n                    quad.Write(nextX,position.y,scale,fontSize,info);\n                    nextX += info.XAdvance*fontSize;\n                    ++writeCount;", "                        if (nextX < xMax) continue;\n                        break;\n                    }\n                    ref var quad = ref ptr++[0];\n                    ref readonly var info = ref Map.GetRef(c);\n                    quad.Write(nextX,position.y,scale,fontSize,info);\n                    nextX += info.XAdvance*fontSize;\n                    ++writeCount;\n                    if (nextX <xMax) continue;\n                    quad.MaskTextMaxX(xMax);\n                    break;\n                }\n            }\n            var scaleX = (byte) Mathf.Clamp((int) fontSize, 0, 255);", "                    if (nextX <xMax) continue;\n                    quad.MaskTextMaxX(xMax);\n                    break;\n                }\n            }\n            var scaleX = (byte) Mathf.Clamp((int) fontSize, 0, 255);\n            for (int i = 0; i < writeCount; i++) {\n                (--ptr)->SetColorAndSize(color, scaleX);\n            }\n            _quads.Length += writeCount;\n        }\n\n\n       \n\n\n       \n", "        public float AddCharMasked(Rect rect, float fontSize, char c, UiColor color) {\n            if (c == ' ') {\n                return SpaceXAdvance;\n            }\n            var position = new Vector2(rect.xMin+fontSize / 3, rect.yMin + rect.height / 2 - fontSize / 2);\n            var scale = new Vector2(fontSize, fontSize);\n            scale *= InvUvScale;\n            CheckAddLength(1);\n            var deltaOffsetX = 0f;\n            var data = Map[c];\n            var uv = data.UV;\n            var cPosX = position.x + fontSize * (deltaOffsetX + data.XOffset);\n            var cPosX2 = cPosX + uv.x * scale.x;\n            var cPosY = position.y + fontSize * data.YOffset;\n            var cPosY2 = cPosY + uv.y * scale.y;\n            ref var quad = ref (_quads.Ptr + _quads.Length)[0];\n            quad.V0.Write( cPosX, cPosY2, uv.z, uv.w + uv.y);\n            quad.V1.Write( cPosX2, cPosY2, uv.x + uv.z, uv.y + uv.w);\n            quad.V2.Write( cPosX2, cPosY, uv.x + uv.z, uv.w);\n            quad.V3.Write( cPosX, cPosY, uv.z, uv.w);\n            \n            var scaleX = (byte) Mathf.Clamp((int) fontSize, 0, 255);\n            quad.SetColorAndSize(color, scaleX);\n            _quads.Length += 1;\n            return fontSize * deltaOffsetX;\n        }", "        public  float AddChar(Vector2 center,float fontSize, char c, UiColor color) {\n            if (c == ' ') {\n                return SpaceXAdvance;\n            }\n            var scale = new Vector2(fontSize, fontSize);\n            scale *= InvUvScale;\n            CheckAddLength(1);\n            var deltaOffsetX = 0f;\n            var data = Map[c];\n            var position = new Vector2(center.x-data.XAdvance*fontSize/2,center.y - fontSize / 3);\n            var uv = data.UV;\n            var cPosX = position.x + fontSize * (deltaOffsetX + data.XOffset);\n            var cPosX2 = cPosX + uv.x * scale.x;\n            var cPosY = position.y + fontSize * data.YOffset;\n            var cPosY2 = cPosY + uv.y * scale.y;\n            ref var quad = ref (_quads.Ptr + _quads.Length)[0];\n            quad.V0.Write( cPosX, cPosY2, uv.z, uv.w + uv.y);\n            quad.V1.Write( cPosX2, cPosY2, uv.x + uv.z, uv.y + uv.w);\n            quad.V2.Write( cPosX2, cPosY, uv.x + uv.z, uv.w);\n            quad.V3.Write( cPosX, cPosY, uv.z, uv.w);\n            var scaleX = (byte) Mathf.Clamp((int) fontSize, 0, 255);\n            quad.SetColorAndSize(color, scaleX);\n            _quads.Length += 1;\n            return fontSize * deltaOffsetX;\n        }\n\n\n        static readonly VertexAttributeDescriptor[] _attributes = {\n            new(VertexAttribute.Position, VertexAttributeFormat.Float32, 2),\n            new(VertexAttribute.Color, VertexAttributeFormat.UNorm8, 4),\n            new(VertexAttribute.TexCoord0, VertexAttributeFormat.Float32, 2),\n            new(VertexAttribute.TexCoord1, VertexAttributeFormat.UNorm8, 4),\n        };\n\n        int lastVertexCount = -1;\n        int lastTexturesCount = -1;\n\n        const MeshUpdateFlags MESH_UPDATE_FLAGS = MeshUpdateFlags.DontRecalculateBounds |\n                                                  MeshUpdateFlags.DontValidateIndices |\n                                                  MeshUpdateFlags.DontNotifyMeshUsers;\n", "        public void SetDeferred(Range range) {\n            var start = range.Start.Value;\n            var end = range.End.Value;\n            var ptr = _quads.Ptr + start;\n            var length1 = end - start;\n            var length2 = _quads.Length - end;\n            NativeCollectionsExtensions.Swap(ptr, length1, length2);\n        }\n\n        public bool Build() {\n            var textOnlyVertLength = _quads.Length * 4;", "        public bool Build() {\n            var textOnlyVertLength = _quads.Length * 4;\n            if (_textureQuads.IsCreated && _textureQuads.Length != 0) {\n                CheckAddLength(_textureQuads.Length);\n                _quads.AddRange(_textureQuads);\n            }\n\n            if (_quads.Length == 0) {\n                Mesh.Clear();\n                return false;\n            }\n\n            var quadCount = _quads.Length;\n            var vertexCount = quadCount * 4;", "            if (_indices.Length < vertexCount) {\n                _indices.SetCapacity(vertexCount);\n                var currentLength = _indices.Length;\n                _indices.Length = vertexCount;\n                var span = _indices.AsSpan();\n                for (var i = currentLength; i < span.Length; i++) {\n                    span[i] = (uint) i;\n                }\n            }\n\n            var textureLength = _textureLength;", "            if (lastVertexCount != vertexCount || lastTexturesCount != textureLength) {\n                Mesh.Clear();\n\n                Mesh.subMeshCount = 1 + textureLength;\n                Mesh.SetVertexBufferParams(vertexCount, _attributes);\n                Mesh.SetIndexBufferParams(vertexCount, IndexFormat.UInt32);\n                var meshDesc = new SubMeshDescriptor(0, textOnlyVertLength, MeshTopology.Quads) {\n                    firstVertex = 0,\n                    vertexCount = textOnlyVertLength\n                };\n                ;\n                Mesh.SetSubMesh(0, meshDesc, MESH_UPDATE_FLAGS);", "                try {\n                    for (int i = 0; i < textureLength; i++) {\n                        var firstVertex = textOnlyVertLength + i * 4;\n                        meshDesc = new SubMeshDescriptor(firstVertex, 4, MeshTopology.Quads) {\n                            firstVertex = firstVertex,\n                            vertexCount = 4\n                        };\n                        Mesh.SetSubMesh(i + 1, meshDesc, MESH_UPDATE_FLAGS);\n                    }\n                }\n                catch (Exception e) {\n                    Debug.LogException(e);\n                    return false;\n                }\n            }\n\n            Mesh.SetVertexBufferData(_quads.AsArray(), 0, 0, quadCount);\n            Mesh.SetIndexBufferData(_indices.AsArray().GetSubArray(0, vertexCount), 0, 0, vertexCount);\n            lastVertexCount = vertexCount;\n            lastTexturesCount = textureLength;\n            return true;\n        }\n", "                catch (Exception e) {\n                    Debug.LogException(e);\n                    return false;\n                }\n            }\n\n            Mesh.SetVertexBufferData(_quads.AsArray(), 0, 0, quadCount);\n            Mesh.SetIndexBufferData(_indices.AsArray().GetSubArray(0, vertexCount), 0, 0, vertexCount);\n            lastVertexCount = vertexCount;\n            lastTexturesCount = textureLength;\n            return true;\n        }\n", "        public void Clear() {\n            _quads.Clear();\n            if (_textureLength != 0) {\n                _textureQuads.Clear();\n                _textures.Clear();\n            }\n        }\n\n        public int Layer=0;\n        public Camera Camera=null;\n        public void Draw() {\n            Mesh.bounds = new Bounds(default, new Vector3(float.MaxValue, float.MaxValue, float.MaxValue));\n            Graphics.DrawMesh(Mesh, default, _material, Layer, Camera, 0, null, ShadowCastingMode.Off, false);", "        public int Layer=0;\n        public Camera Camera=null;\n        public void Draw() {\n            Mesh.bounds = new Bounds(default, new Vector3(float.MaxValue, float.MaxValue, float.MaxValue));\n            Graphics.DrawMesh(Mesh, default, _material, Layer, Camera, 0, null, ShadowCastingMode.Off, false);\n            for (int i = 0; i < _textureLength; i++) {\n                DrawTextureMesh(i);\n            }\n        }\n\n        void DrawTextureMesh(int index) {\n            _materialPropertyBlock.SetTexture(_textureShaderPropertyId, _textures[index]);\n            Graphics.DrawMesh(Mesh, default, _textureMaterial, Layer, Camera, index + 1, _materialPropertyBlock,\n                ShadowCastingMode.Off, false);\n        }\n\n        bool _isDisposed;\n        ~UiMesh() => Dispose(false);\n", "        public void Dispose() {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        void Dispose(bool b) {\n            if (!_isDisposed) {\n                if (_quads.IsCreated) _quads.Dispose();\n                if (_indices.IsCreated) _indices.Dispose();\n                if (Map.IsCreated) Map.Dispose();\n                if (_textureQuads.IsCreated) _textureQuads.Dispose();\n                _isDisposed = true;\n            }\n        }\n", "                if (_indices.IsCreated) _indices.Dispose();\n                if (Map.IsCreated) Map.Dispose();\n                if (_textureQuads.IsCreated) _textureQuads.Dispose();\n                _isDisposed = true;\n            }\n        }\n\n        public readonly struct CharInfo {\n            public readonly float XAdvance;\n            public readonly float XOffset;\n            public readonly float YOffset;", "            public readonly float XAdvance;\n            public readonly float XOffset;\n            public readonly float YOffset;\n            public readonly Vector4 UV;\n\n            public CharInfo(Glyph glyph, float textureWidth, float textureHeight, float pointSize, float padding) {\n                var metrics = glyph.metrics;\n                var rect = glyph.glyphRect;\n                var width = (rect.width + 2 * padding);\n                var height = (rect.height + 2 * padding);\n                UV = new Vector4(width / textureWidth, height / textureHeight, (rect.x - padding) / textureWidth,\n                    (rect.y - padding) / textureHeight);\n                XAdvance = metrics.horizontalAdvance / pointSize;\n                XOffset = (metrics.horizontalBearingX + (metrics.width - width) / 2) / pointSize;\n                YOffset = (metrics.horizontalBearingY - (metrics.height + height) / 2) / pointSize;\n            }\n\n            public CharInfo(float xAdvance, float xOffset, float yOffset) {\n                UV = default;\n                XAdvance = xAdvance;\n                XOffset = xOffset;\n                YOffset = yOffset;\n            }\n        }\n    }\n}"]}
{"filename": "Assets/ZimGui/Core/BoundingBox.cs", "chunked_list": ["\ufeffnamespace ZimGui.Core {\n    public struct BoundingBox {\n        public float XMin;\n        public float XMax;\n        public float YMin;\n        public float YMax;\n\n       \n    }\n}"]}
{"filename": "Assets/ZimGui/Core/UiColor.cs", "chunked_list": ["\ufeffusing System;\nusing System.Runtime.CompilerServices;\nusing Unity.Collections.LowLevel.Unsafe;\nusing UnityEngine;\n\nnamespace ZimGui {\n    \n    public struct UiColor : IEquatable<UiColor> {\n        public byte R;\n        public byte G;\n        public byte B;", "        public byte R;\n        public byte G;\n        public byte B;\n        public byte A;\n        public UiColor(uint rgba) {\n            R = (byte)(rgba >> 24);\n            G = (byte)((rgba >> 16)&0xFF);\n            B = (byte)((rgba >> 8)&0xFF);\n            A = (byte)(rgba&0xFF);\n        }\n        public UiColor(uint rgb,byte a) {\n            R = (byte)((rgb >> 16)&0xFF);\n            G = (byte)((rgb >> 8)&0xFF);\n            B = (byte)(rgb&0xFF);\n            A = a;\n        }\n        \n\n        public UiColor(byte r, byte g, byte b, byte a) {\n            R = r;\n            G = g;\n            B = b;\n            A = a;\n        }\n\n        public UiColor(byte r, byte g, byte b) {\n            R = r;\n            G = g;\n            B = b;\n            A = 255;\n        }\n", "        public static implicit operator UiColor(Color color) => new UiColor((byte) (color.r * 255), (byte) (color.g * 255), (byte) (color.b * 255), (byte) (color.a * 255));\n\n        public static implicit operator Color(UiColor color) =>\n            new Color(color.R / 255f, color.G / 255f, color.B / 255f, color.A / 255f);\n\n        public static implicit operator UiColor(Color32 color) =>UnsafeUtility.As<Color32,UiColor>(ref color);\n        public static implicit operator Color32(UiColor color) => new Color32(color.R, color.G, color.B, color.A);\n        \n        public static implicit operator UiColor(uint a) =>UnsafeUtility.As<uint,UiColor>(ref a);\n\n        /// <summary>\n        /// #FFFFFFFF\n        /// </summary>", "        public static implicit operator UiColor(uint a) =>UnsafeUtility.As<uint,UiColor>(ref a);\n\n        /// <summary>\n        /// #FFFFFFFF\n        /// </summary>\n        public static UiColor White => new UiColor(255, 255, 255);\n\n        /// <summary>\n        /// #000000FF\n        /// </summary>\n        public static UiColor Black => new UiColor(0, 0, 0);\n\n        /// <summary>\n        /// #7F7F7FFF\n        /// </summary>", "        public static UiColor Black => new UiColor(0, 0, 0);\n\n        /// <summary>\n        /// #7F7F7FFF\n        /// </summary>\n        public static UiColor Gray => new UiColor(127, 127, 127);\n\n        /// <summary>\n        /// #7F7F7FFF\n        /// </summary>\n        public static UiColor Grey => new UiColor(127, 127, 127);\n\n        /// <summary>\n        /// #00000000\n        /// </summary>", "        public static UiColor Grey => new UiColor(127, 127, 127);\n\n        /// <summary>\n        /// #00000000\n        /// </summary>\n        public static UiColor Clear => default;\n\n        /// <summary>\n        /// #FF000000\n        /// </summary>\n        public static UiColor Red => new UiColor(255, 0, 0);\n\n        /// <summary>\n        /// #00FF00FF\n        /// </summary>", "        public static UiColor Red => new UiColor(255, 0, 0);\n\n        /// <summary>\n        /// #00FF00FF\n        /// </summary>\n        public static UiColor Green => new UiColor(0, 255, 0);\n\n        /// <summary>\n        /// #0000FFFF\n        /// </summary>\n        public static UiColor Blue => new UiColor(0, 0, 255);\n\n        /// <summary>\n        /// #EA0400FF\n        /// </summary>", "        public static UiColor Blue => new UiColor(0, 0, 255);\n\n        /// <summary>\n        /// #EA0400FF\n        /// </summary>\n        public static UiColor Yellow => new UiColor(255,234, 4);\n\n        /// <summary>\n        /// #00FFFFFF\n        /// </summary>\n        public static UiColor Cyan => new UiColor(0, 255, 255);\n\n        /// <summary>\n        /// #FF00FFFF\n        /// </summary>", "        public static UiColor Cyan => new UiColor(0, 255, 255);\n\n        /// <summary>\n        /// #FF00FFFF\n        /// </summary>\n        public static UiColor Magenta => new UiColor(255, 0, 255);\n\n        /// <summary>\n        /// #F97306FF\n        /// </summary>\n        public static UiColor Orange => new UiColor(0xf9, 0x73, 0x06);\n", "        public static UiColor Orange => new UiColor(0xf9, 0x73, 0x06);\n\n        public static UiColor AlphaFade(UiColor color, byte fadeAlpha) =>\n            new UiColor(color.R, color.G, color.B, (byte) (color.A - fadeAlpha));\n\n        public static UiColor AlphaDiv(UiColor color, byte fadeAlpha) =>\n            new UiColor(color.R, color.G, color.B, (byte) (color.A / fadeAlpha));\n        public static UiColor WithAlpha(UiColor color, byte alpha) =>\n            new UiColor(color.R, color.G, color.B, alpha);\n\n       public  UiColor WithAlpha( byte alpha) =>\n            new UiColor(R, G, B, alpha);\n", "       public  UiColor WithAlpha( byte alpha) =>\n            new UiColor(R, G, B, alpha);\n\n       public static UiColor Lerp(UiColor a, UiColor b, float t) {\n          return  new UiColor((byte)(a.R + (b.R - a.R) * t),(byte)(a.G + (b.G - a.G) * t), (byte)(a.B + (b.B - a.B) * t),(byte)(a.A + (b.A - a.A) * t));\n       }\n\n        [MethodImpl((MethodImplOptions) 256)]\n        public static UiColor operator *(UiColor a, float b) =>\n            new UiColor((byte) (a.R * b), (byte) (a.G * b), (byte) (a.B * b), (byte) (a.A * b));\n\n        [MethodImpl((MethodImplOptions) 256)]", "        public static UiColor operator *(UiColor a, float b) =>\n            new UiColor((byte) (a.R * b), (byte) (a.G * b), (byte) (a.B * b), (byte) (a.A * b));\n\n        [MethodImpl((MethodImplOptions) 256)]\n        public static UiColor operator *(float b, UiColor a) =>\n            new UiColor((byte) (a.R * b), (byte) (a.G * b), (byte) (a.B * b), (byte) (a.A * b));\n\n        [MethodImpl((MethodImplOptions) 256)]\n        public static UiColor operator /(UiColor a, float b) =>\n            new UiColor((byte) (a.R / b), (byte) (a.G / b), (byte) (a.B / b), (byte) (a.A / b));\n\n        [MethodImpl((MethodImplOptions) 256)]", "        public static UiColor operator /(UiColor a, float b) =>\n            new UiColor((byte) (a.R / b), (byte) (a.G / b), (byte) (a.B / b), (byte) (a.A / b));\n\n        [MethodImpl((MethodImplOptions) 256)]\n        public static UiColor operator /(UiColor a, int b) =>\n            new UiColor((byte) (a.R / b), (byte) (a.G / b), (byte) (a.B / b), (byte) (a.A / b));\n\n        [MethodImpl((MethodImplOptions) 256)]\n        public static bool operator ==(UiColor lhs, UiColor rhs) =>\n            UnsafeUtility.As<UiColor,int>(ref lhs)==UnsafeUtility.As<UiColor,int>(ref rhs);\n\n        [MethodImpl((MethodImplOptions) 256)]", "        public static bool operator ==(UiColor lhs, UiColor rhs) =>\n            UnsafeUtility.As<UiColor,int>(ref lhs)==UnsafeUtility.As<UiColor,int>(ref rhs);\n\n        [MethodImpl((MethodImplOptions) 256)]\n        public static bool operator !=(UiColor lhs, UiColor rhs) => !(lhs == rhs);\n\n        public bool Equals(UiColor other) {\n            return UnsafeUtility.As<UiColor,int>(ref this)==UnsafeUtility.As<UiColor,int>(ref other);\n        }\n\n        public override bool Equals(object obj) {\n            return obj is UiColor other && Equals(other);\n        }\n", "        public override bool Equals(object obj) {\n            return obj is UiColor other && Equals(other);\n        }\n\n        public override int GetHashCode() {\n            return UnsafeUtility.As<UiColor,int>(ref this);\n        }\n\n        public override string ToString() {\n            return \"(\"+R+\", \"+G+\", \"+B+\", \"+A+\")\";\n        }\n    }\n}", "        public override string ToString() {\n            return \"(\"+R+\", \"+G+\", \"+B+\", \"+A+\")\";\n        }\n    }\n}"]}
{"filename": "Assets/ZimGui/Core/FormatEx.cs", "chunked_list": ["\ufeffusing System;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\nusing Unity.Collections.LowLevel.Unsafe;\n\nnamespace ZimGui.Core {\n    public static class FormatEx {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static void Format(this float f,ref int offset, Span<char> span) {\n            f.TryFormat(span[offset..], out var charsWritten,IMStyle.FloatFormat);\n            offset += charsWritten;\n        }", "        public static void Format(this float f,ref int offset, Span<char> span) {\n            f.TryFormat(span[offset..], out var charsWritten,IMStyle.FloatFormat);\n            offset += charsWritten;\n        }\n        public static void Format(this int i,ref int offset, Span<char> span) {\n            i.TryFormat(span[offset..], out var charsWritten);\n            offset += charsWritten;\n        }\n        public static void Format(this byte i,ref int offset, Span<char> span) {\n            if (99 < i) {\n                var hundredsPlace = i / 100;\n                var tensPlace = (i - hundredsPlace * 100)/10;\n                var onesPlace = (i - hundredsPlace * 100 - tensPlace * 10);\n                span[offset++] = (char)('0' + hundredsPlace);\n                span[offset++] = (char)('0' + tensPlace);\n                span[offset++] = (char)('0' + onesPlace);\n            }", "        public static void Format(this byte i,ref int offset, Span<char> span) {\n            if (99 < i) {\n                var hundredsPlace = i / 100;\n                var tensPlace = (i - hundredsPlace * 100)/10;\n                var onesPlace = (i - hundredsPlace * 100 - tensPlace * 10);\n                span[offset++] = (char)('0' + hundredsPlace);\n                span[offset++] = (char)('0' + tensPlace);\n                span[offset++] = (char)('0' + onesPlace);\n            }\n            else if(9 < i) {\n                var tensPlace = i/10;\n                var onesPlace = i -  tensPlace * 10;\n                span[offset++] = (char)('0' + tensPlace);\n                span[offset++] = (char)('0' + onesPlace);\n            }\n            else span[offset++] = (char)('0' + i);", "            else if(9 < i) {\n                var tensPlace = i/10;\n                var onesPlace = i -  tensPlace * 10;\n                span[offset++] = (char)('0' + tensPlace);\n                span[offset++] = (char)('0' + onesPlace);\n            }\n            else span[offset++] = (char)('0' + i);\n        }public static int Format(this byte i, Span<char> span) {\n            if (99 < i) {\n                var hundredsPlace = i / 100;\n                var tensPlace = (i - hundredsPlace * 100)/10;\n                var onesPlace = (i - hundredsPlace * 100 - tensPlace * 10);\n                span[0] = (char)('0' + hundredsPlace);\n                span[1] = (char)('0' + tensPlace);\n                span[2] = (char)('0' + onesPlace);\n                return 3;\n            }", "            if (99 < i) {\n                var hundredsPlace = i / 100;\n                var tensPlace = (i - hundredsPlace * 100)/10;\n                var onesPlace = (i - hundredsPlace * 100 - tensPlace * 10);\n                span[0] = (char)('0' + hundredsPlace);\n                span[1] = (char)('0' + tensPlace);\n                span[2] = (char)('0' + onesPlace);\n                return 3;\n            }\n            if(9 < i) {\n                var tensPlace = i/10;\n                var onesPlace = i -  tensPlace * 10;\n                span[0] = (char)('0' + tensPlace);\n                span[1] = (char)('0' + onesPlace);\n                return 2;\n            }\n            span[0] = (char)('0' + i);\n            return 1;\n\n        }\n        ", "            if(9 < i) {\n                var tensPlace = i/10;\n                var onesPlace = i -  tensPlace * 10;\n                span[0] = (char)('0' + tensPlace);\n                span[1] = (char)('0' + onesPlace);\n                return 2;\n            }\n            span[0] = (char)('0' + i);\n            return 1;\n\n        }\n        ", "        public static void Write(this Span<byte> span,ref int offset, ushort value) {\n            UnsafeUtility.As<byte, ushort>(ref span[offset])=value;\n            offset += 2;\n        }\n        public static void Write(this Span<byte> span,ref int offset, short value) {\n            UnsafeUtility.As<byte, short>(ref span[offset])=value;\n            offset += 2;\n        }\n        public static  void Write(this Span<byte> span,ref int offset, int value) {\n            UnsafeUtility.As<byte, int>(ref span[offset])=value;\n            offset += 4;\n        }", "        public static  void Write(this Span<byte> span,ref int offset, int value) {\n            UnsafeUtility.As<byte, int>(ref span[offset])=value;\n            offset += 4;\n        }\n        public static void Write(this Span<byte> span,ref int offset, float value) {\n            UnsafeUtility.As<byte, float>(ref span[offset])=value;\n            offset += 4;\n        }\n        \n        public static void Write(this Span<byte> span,ref int offset, ReadOnlySpan<byte> value) {\n            value.CopyTo(span.Slice(offset,value.Length));\n            offset += value.Length;\n        }", "        public static void Write(this Span<byte> span,ref int offset, ReadOnlySpan<byte> value) {\n            value.CopyTo(span.Slice(offset,value.Length));\n            offset += value.Length;\n        }\n        public static  void Write<T>(this Span<byte> span,ref int offset, ReadOnlySpan<T> value) where T:unmanaged {\n            var valueAsBytes = MemoryMarshal.Cast<T, byte>(value);\n            valueAsBytes.CopyTo(span.Slice(offset,valueAsBytes.Length));\n            offset += valueAsBytes.Length;\n        }\n        public static unsafe void Write<T>(this Span<byte> span,ref int offset, T* ptr,int length) where T:unmanaged {\n            var valueAsBytes = new ReadOnlySpan<byte>((byte*)ptr,length*sizeof(T));\n            valueAsBytes.CopyTo(span.Slice(offset,valueAsBytes.Length));\n            offset += valueAsBytes.Length;\n        }", "        public static unsafe void Write<T>(this Span<byte> span,ref int offset, T* ptr,int length) where T:unmanaged {\n            var valueAsBytes = new ReadOnlySpan<byte>((byte*)ptr,length*sizeof(T));\n            valueAsBytes.CopyTo(span.Slice(offset,valueAsBytes.Length));\n            offset += valueAsBytes.Length;\n        }\n        public static ushort ReadUInt16(this ReadOnlySpan<byte> span,ref int offset) {\n            return MemoryMarshal.Cast<byte, ushort>(span[offset..(offset += 4)])[0];\n        }\n        public static short ReadInt16(this ReadOnlySpan<byte> span,ref int offset) {\n            return MemoryMarshal.Cast<byte, short>(span[offset..(offset += 2)])[0];\n        }", "        public static short ReadInt16(this ReadOnlySpan<byte> span,ref int offset) {\n            return MemoryMarshal.Cast<byte, short>(span[offset..(offset += 2)])[0];\n        }\n        public static float ReadSingle(this ReadOnlySpan<byte> span,ref int offset) {\n            return MemoryMarshal.Cast<byte, float>(span[offset..(offset += 4)])[0];\n        }\n        public static int ReadInt32(this ReadOnlySpan<byte> span,ref int offset) {\n            return MemoryMarshal.Cast<byte, int>(span[offset..(offset += 4)])[0];\n        }\n        public static unsafe void WriteTo<T>(this ReadOnlySpan<byte> span,ref int offset, T* ptr,int length) where T:unmanaged {\n            var valueAsBytes = new Span<byte>((byte*)ptr,length*sizeof(T));\n            span.Slice(offset,valueAsBytes.Length).CopyTo( valueAsBytes);\n            offset += valueAsBytes.Length;\n        }\n        \n    }\n}", "        public static unsafe void WriteTo<T>(this ReadOnlySpan<byte> span,ref int offset, T* ptr,int length) where T:unmanaged {\n            var valueAsBytes = new Span<byte>((byte*)ptr,length*sizeof(T));\n            span.Slice(offset,valueAsBytes.Length).CopyTo( valueAsBytes);\n            offset += valueAsBytes.Length;\n        }\n        \n    }\n}"]}
{"filename": "Assets/ZimGui/Core/IReadOnlySpanEnumerator.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\n\nnamespace ZimGui.Core {\n    public interface IReadOnlySpanEnumerator<T> {\n        public ReadOnlySpan<T> Current { get; }\n        public bool MoveNext();\n    }\n\n    public struct TextListEnumerator : IReadOnlySpanEnumerator<char> {\n        public List<string>.Enumerator Enumerator;\n        public ReadOnlySpan<char> Current => Enumerator.Current;", "    public struct TextListEnumerator : IReadOnlySpanEnumerator<char> {\n        public List<string>.Enumerator Enumerator;\n        public ReadOnlySpan<char> Current => Enumerator.Current;\n        public bool MoveNext() => Enumerator.MoveNext();\n    } \n}"]}
{"filename": "Assets/ZimGui/Core/Quad.cs", "chunked_list": ["\ufeffusing System;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\nusing Unity.Collections.LowLevel.Unsafe;\nusing UnityEngine;\n\nnamespace ZimGui.Core {\n    [StructLayout(LayoutKind.Sequential)]\n    public struct Options {\n        public byte Size;\n        public byte Padding0; //TODO use paddings for something like bold style.", "    public struct Options {\n        public byte Size;\n        public byte Padding0; //TODO use paddings for something like bold style.\n        public byte Padding1;\n        public byte Padding2;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct VertexData {\n        /// <summary>\n        /// Screen Position\n        /// </summary>", "    public struct VertexData {\n        /// <summary>\n        /// Screen Position\n        /// </summary>\n        public Vector2 Position;\n\n        public UiColor Color;\n        public Vector2 UV;\n        public Options Options;\n\n", "        public Options Options;\n\n\n        public void Write(Vector2 position, byte scale, UiColor color, Vector2 uv) {\n            Position = position;\n            Color = color;\n            UV = uv;\n            Options.Size = scale;\n        }\n\n        [MethodImpl((MethodImplOptions) 256)]", "        public void Write(Vector2 position, Vector2 uv) {\n            Position = position;\n            UV = uv;\n        }\n\n        [MethodImpl((MethodImplOptions) 256)]\n        public void Write(float positionX, float positionY, Vector2 uv) {\n            Position.x = positionX;\n            Position.y = positionY;\n            UV = uv;\n        }\n\n        [MethodImpl((MethodImplOptions) 256)]", "        public void Write(float positionX, float positionY, float u, float v) {\n            Position.x = positionX;\n            Position.y = positionY;\n            UV.x = u;\n            UV.y = v;\n        }\n\n\n        public void Write(Vector2 position, byte scale, UiColor color, float uvX, float uvY) {\n            Position = position;\n            Color = color;\n            UV = new Vector2(uvX, uvY);\n            Options.Size = scale;\n        }\n", "        public void Write(Vector2 position, byte scale, UiColor color, float uvX, float uvY) {\n            Position = position;\n            Color = color;\n            UV = new Vector2(uvX, uvY);\n            Options.Size = scale;\n        }\n\n        public void Write(float x, float y, byte scale, UiColor color, float uvX, float uvY) {\n            Position.x = x;\n            Position.y = y;\n            Color = color;\n            UV = new Vector2(uvX, uvY);\n            Options.Size = scale;\n        }\n", "        public void Write(Vector2 position, float uvX, float uvY) {\n            Position = position;\n            UV.x = uvX;\n            UV.y = uvY;\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct Quad {\n        /// <summary>\n        /// Top Left\n        /// </summary>", "    public struct Quad {\n        /// <summary>\n        /// Top Left\n        /// </summary>\n        public VertexData V0;\n\n        /// <summary>\n        /// Top Right\n        /// </summary>\n        public VertexData V1;\n\n        /// <summary>\n        /// Bottom Right\n        /// </summary>", "        public VertexData V1;\n\n        /// <summary>\n        /// Bottom Right\n        /// </summary>\n        public VertexData V2;\n\n        /// <summary>\n        /// Bottom Left\n        /// </summary>\n        public VertexData V3;\n\n", "        public VertexData V3;\n\n\n        public void WriteLine(Vector2 start, Vector2 end, float width, UiColor color, Vector2 quadUV) {\n            V3.Color = V2.Color = V1.Color = V0.Color = color;\n            V3.UV = V2.UV = V1.UV = V0.UV = quadUV;\n            V3.Options.Size = V2.Options.Size = V1.Options.Size = V0.Options.Size = 255;\n            var p = (end - start).Perpendicular();\n            var verticalX = p.x * width / 2;\n            var verticalY = p.y * width / 2;\n            V0.Position.x = start.x + verticalX;\n            V0.Position.y = start.y + verticalY;\n            V1.Position.x = end.x + verticalX;\n            V1.Position.y = end.y + verticalY;\n            V2.Position.x = end.x - verticalX;\n            V2.Position.y = end.y - verticalY;\n            V3.Position.x = start.x - verticalX;\n            V3.Position.y = start.y - verticalY;\n        }\n", "        public void WriteLine(Vector2 start, Vector2 end, float width, UiColor startColor, UiColor endColor,\n            Vector2 quadUV) {\n            V3.UV = V2.UV = V1.UV = V0.UV = quadUV;\n            V3.Options.Size = V2.Options.Size = V1.Options.Size = V0.Options.Size = 255;\n            V3.Color = V0.Color = startColor;\n            V2.Color = V1.Color = endColor;\n            var p = (end - start).Perpendicular();\n            var verticalX = p.x * width / 2;\n            var verticalY = p.y * width / 2;\n            V0.Position.x = start.x + verticalX;\n            V0.Position.y = start.y + verticalY;\n            V1.Position.x = end.x + verticalX;\n            V1.Position.y = end.y + verticalY;\n            V2.Position.x = end.x - verticalX;\n            V2.Position.y = end.y - verticalY;\n            V3.Position.x = start.x - verticalX;\n            V3.Position.y = start.y - verticalY;\n        }\n", "        public void WriteLinePosition(Vector2 start, Vector2 end, float width) {\n            var p = (end - start).Perpendicular();\n            var verticalX = p.x * width / 2;\n            var verticalY = p.y * width / 2;\n            V0.Position.x = start.x + verticalX;\n            V0.Position.y = start.y + verticalY;\n            V1.Position.x = end.x + verticalX;\n            V1.Position.y = end.y + verticalY;\n            V2.Position.x = end.x - verticalX;\n            V2.Position.y = end.y - verticalY;\n            V3.Position.x = start.x - verticalX;\n            V3.Position.y = start.y - verticalY;\n        }\n", "        public void WriteCircle(Vector2 center, float radius, UiColor color, in Vector4 circleUV) {\n            V3.Options.Size = V2.Options.Size = V1.Options.Size = V0.Options.Size = radius < 85 ? (byte) (radius * 3) : (byte) 255;\n            V3.Color = V2.Color = V1.Color = V0.Color = color;\n            V3.Position.x = V0.Position.x = center.x - radius;\n            V1.Position.y = V0.Position.y = center.y + radius;\n            V2.Position.x = V1.Position.x = center.x + radius;\n            V3.Position.y = V2.Position.y = center.y - radius;\n            V3.UV.x = V0.UV.x = circleUV.z;\n            V1.UV.y = V0.UV.y = circleUV.w + circleUV.y;\n            V2.UV.x = V1.UV.x = circleUV.x + circleUV.z;\n            V3.UV.y = V2.UV.y = circleUV.w;\n        }\n", "        public void Write(float x, float y, Vector2 scale, float fontSize, in UiMesh.CharInfo info) {\n            var uv = info.UV;\n            V3.UV.x = V0.UV.x = uv.z;\n            V1.UV.y = V0.UV.y = uv.w + uv.y;\n            V2.UV.x = V1.UV.x = uv.x + uv.z;\n            V3.UV.y = V2.UV.y = uv.w;\n            x += fontSize * info.XOffset;\n            V3.Position.x = V0.Position.x = x;\n            V2.Position.x = V1.Position.x = x + uv.x * scale.x;\n            y += fontSize * info.YOffset;\n            V3.Position.y = V2.Position.y = y;\n            V1.Position.y = V0.Position.y = y + uv.y * scale.y;\n        }\n        /* \n            var uv =  info.UV;\n            quad.V3.UV.x=quad.V0.UV.x = uv.z;\n            quad.V1.UV.y=quad.V0.UV.y = uv.w + uv.y;\n            quad.V2.UV.x=quad.V1.UV.x= uv.x + uv.z;\n            quad.V3.UV.y=quad.V2.UV.y= uv.w;\n            var x = nextX+= fontSize * info.XOffset;\n            var y = position.y+fontSize * info.YOffset;\n            quad.V3.Position.x=quad.V0.Position.x = x;\n            quad.V2.Position.x=quad.V1.Position.x=  x + uv.x * scale.x;\n            quad.V3.Position.y=quad.V2.Position.y= y;\n            quad.V1.Position.y=quad.V0.Position.y = y + uv.y * scale.y;\n         */\n\n", "        public void WriteCircle(float centerX, float centerY, float radius, UiColor color, in Vector4 circleUV) {\n            V0.Options.Size = radius < 85 ? (byte) (radius * 3) : (byte) 255;\n            V0.Position.x = centerX - radius;\n            V0.Position.y = centerY - radius;\n            V0.Color = color;\n            V0.UV.x = circleUV.z;\n            V0.UV.y = circleUV.w + circleUV.y;\n            V3 = V2 = V1 = V0;\n            V2.Position.x = V1.Position.x = centerX + radius;\n            V3.Position.y = V2.Position.y = centerY + radius;\n            V2.UV.x = V1.UV.x = circleUV.x + circleUV.z;\n            V3.UV.y = V2.UV.y = circleUV.w;\n        }\n", "        public void WriteCircle(float centerX, float centerY, float radius) {\n            V0.Position.x = centerX - radius;\n            V0.Position.y = centerY - radius;\n            V2.Position.x = V1.Position.x = centerX + radius;\n            V3.Position.y = V2.Position.y = centerY + radius;\n        }\n\n        public static void WriteWithOutUVScale(ref Quad quad, Vector2 scale, Vector2 position, UiColor color,\n            Vector4 uv) {\n            var size = (byte) Mathf.Clamp((int) (scale.x * 2), 0, 255);\n            quad.V0.Write(position + new Vector2(0, scale.y), size, color, uv.z, uv.w + uv.y);\n            quad.V1.Write(position + scale, size, color, new Vector2(uv.x + uv.z, uv.y + uv.w));\n            quad.V2.Write(position + new Vector2(scale.x, 0), size, color, uv.x + uv.z, uv.w);\n            quad.V3.Write(position, size, color, new Vector2(uv.z, uv.w));\n        }\n", "        public static void WriteWithOutUV(ref Quad quad, Vector2 scale, Vector2 position, UiColor color) {\n            quad.V0.Write(position + new Vector2(0, scale.y), 0, color, 0, 1);\n            quad.V1.Write(position + scale, 0, color, 1, 1);\n            quad.V2.Write(position + new Vector2(scale.x, 0), 0, color, 1, 0);\n            quad.V3.Write(position, 0, color, 0, 0);\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Write(float xMin, float xMax, float yMin, float yMax, ref Vector4 uv) {\n            V3.Position.x = V0.Position.x = xMin;\n            V3.UV.x = V0.UV.x = uv.z;\n            V1.Position.y = V0.Position.y = yMax;\n            V1.UV.y = V0.UV.y = uv.w + uv.y;\n            V2.Position.x = V1.Position.x = xMax;\n            V2.UV.x = V1.UV.x = uv.x + uv.z;\n            V3.Position.y = V2.Position.y = yMin;\n            V3.UV.y = V2.UV.y = uv.w;\n        }\n\n", "        public void Write(float xMin, float xMax, float yMin, float yMax, ref Vector4 uv) {\n            V3.Position.x = V0.Position.x = xMin;\n            V3.UV.x = V0.UV.x = uv.z;\n            V1.Position.y = V0.Position.y = yMax;\n            V1.UV.y = V0.UV.y = uv.w + uv.y;\n            V2.Position.x = V1.Position.x = xMax;\n            V2.UV.x = V1.UV.x = uv.x + uv.z;\n            V3.Position.y = V2.Position.y = yMin;\n            V3.UV.y = V2.UV.y = uv.w;\n        }\n\n", "        public static void WriteHorizontalGradient(ref Quad quad, Vector2 scale, Vector2 position, UiColor leftColor,\n            UiColor rightColor, Vector2 uv) {\n            var size = (byte) Mathf.Clamp((int) scale.x, 0, 255);\n            quad.V0.Write(position + new Vector2(0, scale.y), size, leftColor, uv);\n            quad.V1.Write(position + scale, size, rightColor, uv);\n            quad.V2.Write(position + new Vector2(scale.x, 0), size, rightColor, uv);\n            quad.V3.Write(position, size, leftColor, uv);\n        }\n\n\n        public void MaskTextMaxX(float x) {\n            var u = V0.UV.x;\n            var minX = V0.Position.x;\n            u += (V1.UV.x - u) * (x - minX) / (V1.Position.x - minX);\n            V1.Position.x = x;\n            V1.UV.x = u;\n            V2.Position.x = x;\n            V2.UV.x = u;\n        }\n", "        public void MaskTextMaxX(float x) {\n            var u = V0.UV.x;\n            var minX = V0.Position.x;\n            u += (V1.UV.x - u) * (x - minX) / (V1.Position.x - minX);\n            V1.Position.x = x;\n            V1.UV.x = u;\n            V2.Position.x = x;\n            V2.UV.x = u;\n        }\n\n        public void MaskTextMaxY(float y) {\n            var maxY = V1.Position.y;", "        public void MaskTextMaxY(float y) {\n            var maxY = V1.Position.y;\n            if (maxY < y) return;\n            var v = V0.UV.y;\n            var minY = V0.Position.x;\n            v += (V1.UV.y - v) * (y - minY) / (maxY - minY);\n            V1.Position.y = y;\n            V1.UV.y = v;\n            V2.Position.y = y;\n            V2.UV.y = v;\n        }\n\n        /// <summary>\n        /// /UseThisBefore WriteLinePositionOnly\n        /// </summary>\n        /// <param name=\"span\"></param>\n        /// <param name=\"color\"></param>\n        /// <param name=\"quadUV\"></param>", "        public static unsafe void SetUpQuadColorUV(Span<Quad> span, UiColor color, Vector2 quadUV) {\n            fixed (Quad* p = span) {\n                *p = default;\n                p->SetColor(color);\n                p->SetSize(255);\n                p->SetUV(quadUV);\n                UnsafeUtility.MemCpyReplicate(p + 1, p, sizeof(Quad), span.Length - 1);\n            }\n        }\n\n        /// <summary>\n        /// /UseThisBefore WriteLinePositionOnly\n        /// </summary>\n        /// <param name=\"span\"></param>\n        /// <param name=\"quadUV\"></param>", "        public static unsafe void SetUpQuadUV(Span<Quad> span, Vector2 quadUV) {\n            fixed (Quad* p = span) {\n                *p = default;\n                p->SetSize(255);\n                p->SetUV(quadUV);\n                UnsafeUtility.MemCpyReplicate(p + 1, p, sizeof(Quad), span.Length - 1);\n            }\n        }\n\n\n        /// <summary>\n        /// /UseThisBefore WriteLinePositionOnly\n        /// </summary>\n        /// <param name=\"span\"></param>\n        /// <param name=\"v\"></param>", "        public static unsafe void SetUpForQuad(Span<Quad> span, Vector2 v) {\n            fixed (Quad* p = span) {\n                *p = default;\n                p->SetSize(255);\n                p->SetUV(v);\n                UnsafeUtility.MemCpyReplicate(p + 1, p, sizeof(Quad), span.Length - 1);\n            }\n        }\n\n        public static unsafe void SetUpUVForCircle(Span<Quad> span, Vector4 circleUV) {\n            fixed (Quad* p = span) {\n                *p = default;\n                p->V3.UV.x = p->V0.UV.x = circleUV.z;\n                p->V1.UV.y = p->V0.UV.y = circleUV.w + circleUV.y;\n                p->V2.UV.x = p->V1.UV.x = circleUV.x + circleUV.z;\n                p->V3.UV.y = p->V2.UV.y = circleUV.w;\n                UnsafeUtility.MemCpyReplicate(p + 1, p, sizeof(Quad), span.Length - 1);\n            }\n        }\n", "        public static unsafe void SetUpUVForCircle(Span<Quad> span, Vector4 circleUV) {\n            fixed (Quad* p = span) {\n                *p = default;\n                p->V3.UV.x = p->V0.UV.x = circleUV.z;\n                p->V1.UV.y = p->V0.UV.y = circleUV.w + circleUV.y;\n                p->V2.UV.x = p->V1.UV.x = circleUV.x + circleUV.z;\n                p->V3.UV.y = p->V2.UV.y = circleUV.w;\n                UnsafeUtility.MemCpyReplicate(p + 1, p, sizeof(Quad), span.Length - 1);\n            }\n        }\n", "        public void SetColor(UiColor color) {\n            V0.Color = color;\n            V1.Color = color;\n            V2.Color = color;\n            V3.Color = color;\n        }\n\n        public void SetUV(Vector2 uv) {\n            V0.UV = uv;\n            V1.UV = uv;\n            V2.UV = uv;\n            V3.UV = uv;\n        }\n", "        public void SetSize(byte size) {\n            V3.Options.Size = V2.Options.Size = V1.Options.Size = V0.Options.Size = size;\n        }\n\n        public void SetColorAndSize(UiColor color, byte size) {\n            V3.Color = V2.Color = V1.Color = V0.Color = color;\n            V3.Options.Size = V2.Options.Size = V1.Options.Size = V0.Options.Size = size;\n        }\n\n        public void Rotate(float angle) {\n            Rotate(new Vector2(Mathf.Cos(angle), Mathf.Sin((angle))));\n        }\n", "        public void Rotate(float angle) {\n            Rotate(new Vector2(Mathf.Cos(angle), Mathf.Sin((angle))));\n        }\n\n        public void Rotate(Vector2 complex) {\n            var center = (V1.Position + V3.Position) / 2;\n            V0.Position = cross(complex, V0.Position - center) + center;\n            V1.Position = cross(complex, V1.Position - center) + center;\n            V2.Position = cross(complex, V2.Position - center) + center;\n            V3.Position = cross(complex, V3.Position - center) + center;\n        }\n", "        public void RotateFrom(Vector2 center, Vector2 complex) {\n            V0.Position = cross(complex, V0.Position - center) + center;\n            V1.Position = cross(complex, V1.Position - center) + center;\n            V2.Position = cross(complex, V2.Position - center) + center;\n            V3.Position = cross(complex, V3.Position - center) + center;\n        }\n\n        public void Scale(Vector2 scale) {\n            var center = (V1.Position + V3.Position) / 2;\n            V0.Position = scale * (V0.Position - center) + center;\n            V1.Position = scale * (V1.Position - center) + center;\n            V2.Position = scale * (V2.Position - center) + center;\n            V3.Position = scale * (V3.Position - center) + center;\n        }\n", "        public void ScaleFrom(Vector2 offset, Vector2 scale) {\n            V0.Position = scale * (V0.Position - offset);\n            V1.Position = scale * (V1.Position - offset);\n            V2.Position = scale * (V2.Position - offset);\n            V3.Position = scale * (V3.Position - offset);\n        }\n\n        public void Move(Vector2 delta) {\n            V0.Position += delta;\n            V1.Position += delta;\n            V2.Position += delta;\n            V3.Position += delta;\n        }\n", "        public void MoveX(float deltaX) {\n            V0.Position.x += deltaX;\n            V1.Position.x += deltaX;\n            V2.Position.x += deltaX;\n            V3.Position.x += deltaX;\n        }\n\n        public void MoveY(float deltaY) {\n            V0.Position.y += deltaY;\n            V1.Position.y += deltaY;\n            V2.Position.y += deltaY;\n            V3.Position.y += deltaY;\n        }\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        static Vector2 cross(Vector2 left, Vector2 right) {\n            return new Vector2(left.x * right.x - left.y * right.y, left.x * right.y + left.y * right.x);\n        }\n    }\n}"]}
