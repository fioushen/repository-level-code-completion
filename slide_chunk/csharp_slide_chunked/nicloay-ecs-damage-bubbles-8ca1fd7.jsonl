{"filename": "Assets/EcsDamageBubbles/Samples~/Demo/Scripts/TestSpawner/TestSpawnerSystem.cs", "chunked_list": ["\ufeffusing EcsDamageBubbles.Config;\nusing Unity.Collections;\nusing Unity.Entities;\nusing Unity.Transforms;\nusing UnityEngine;\nusing Random = Unity.Mathematics.Random;\n\nnamespace EcsDamageBubbles.Demo\n{\n    public partial class TestSpawnerSystem : SystemBase\n    {", "{\n    public partial class TestSpawnerSystem : SystemBase\n    {\n        private Random _rnd;\n        \n        protected override void OnCreate()\n        {\n            _rnd = new Random((uint)SystemAPI.Time.GetHashCode());\n            RequireForUpdate<DamageBubbleColorConfig>();\n        }\n", "        protected override void OnUpdate()\n        {\n            var colorConfig = SystemAPI.GetSingletonBuffer<DamageBubbleColorConfig>();\n            var ecb = new EntityCommandBuffer(Allocator.Temp);\n            foreach (var spawner in SystemAPI.Query<TestSpawner>())\n            {\n                var entities = spawner.EntitiesPerFrame;\n                while (entities-- > 0)\n                {\n                    var colorRND = _rnd.NextInt(0, 10);\n                    var colorId = 0;", "                    if (colorRND > 6 )\n                    {\n                        colorId = colorRND > 8 ? 1 : 2;\n                    }\n                    \n                    var entity = ecb.CreateEntity();\n                    ecb.AddComponent(entity, new DamageBubbleRequest\n                    {\n                        Value = _rnd.NextInt(1, 999999),\n                        ColorId = colorId\n                    });\n\n                    ecb.AddComponent(entity, new LocalTransform\n                    {\n                        Scale = 1, Position = _rnd.NextFloat3(spawner.MinPosition, spawner.MaxPosition), Rotation = Quaternion.identity\n                    });\n                }\n                \n            }\n\n            ecb.Playback(EntityManager);\n        }\n    }\n}"]}
{"filename": "Assets/EcsDamageBubbles/Samples~/Demo/Scripts/TestSpawner/TestSpawnerAuthoring.cs", "chunked_list": ["using Unity.Entities;\nusing UnityEngine;\n\nnamespace EcsDamageBubbles.Demo\n{\n    public class TestSpawnerAuthoring : MonoBehaviour\n    {\n        public Vector3 minPosition;\n        public Vector3 maxPosition;\n        public int entitiesPerFrame;\n        ", "        public Vector3 maxPosition;\n        public int entitiesPerFrame;\n        \n        public class TestSpawnerBaker : Baker<TestSpawnerAuthoring>\n        {\n            public override void Bake(TestSpawnerAuthoring authoring)\n            {\n                var entity = GetEntity(TransformUsageFlags.None);\n                AddComponent(entity, new TestSpawner()\n                {\n                    MaxPosition = authoring.maxPosition,\n                    MinPosition = authoring.minPosition,\n                    EntitiesPerFrame = authoring.entitiesPerFrame\n                });\n            }\n        }\n    }\n}"]}
{"filename": "Assets/EcsDamageBubbles/Samples~/Demo/Scripts/TestSpawner/TestSpawner.cs", "chunked_list": ["\ufeffusing Unity.Entities;\nusing Unity.Mathematics;\n\nnamespace EcsDamageBubbles.Demo\n{\n    public struct TestSpawner : IComponentData\n    {\n        public float3 MinPosition;\n        public float3 MaxPosition;\n        public int EntitiesPerFrame;\n    }\n}", "        public float3 MaxPosition;\n        public int EntitiesPerFrame;\n    }\n}"]}
{"filename": "Assets/EcsDamageBubbles/Editor/CreatePlane.cs", "chunked_list": ["// CreatePlane\n// Credit: http://wiki.unity3d.com/index.php?title=CreatePlane\n\n//  1. Using the inspector, create a new C# script.\n//  2. Name the script \"CreatePlane\" and place it in a folder titled \"Editor\".\n//  3. A new menu option titled \"Custom Plane\" will appear in \"GameObject > Create Other\". \n\nusing UnityEditor;\nusing UnityEngine;\n", "using UnityEngine;\n\nnamespace EcsDamageBubbles.Editor\n{\n    public class CreatePlane : ScriptableWizard\n    {\n        public enum AnchorPoint\n        {\n            TopLeft,\n            TopHalf,\n            TopRight,\n            RightHalf,\n            BottomRight,\n            BottomHalf,\n            BottomLeft,\n            LeftHalf,\n            Center\n        }\n", "        public enum Orientation\n        {\n            Horizontal,\n            Vertical\n        }\n\n        private static Camera _cam;\n        private static Camera _lastUsedCam;\n\n        public int widthSegments = 1;\n        public int lengthSegments = 1;", "        public int widthSegments = 1;\n        public int lengthSegments = 1;\n        public float width = 1.0f;\n        public float length = 1.0f;\n        public Orientation orientation = Orientation.Horizontal;\n        public AnchorPoint anchor = AnchorPoint.Center;\n        public bool addCollider;\n        public bool createAtOrigin = true;\n        public string optionalName;\n\n", "        public string optionalName;\n\n\n        private void OnWizardCreate()\n        {\n            var plane = new GameObject();\n\n            if (!string.IsNullOrEmpty(optionalName))\n                plane.name = optionalName;\n            else\n                plane.name = \"Plane\";\n", "            if (!createAtOrigin && _cam)\n                plane.transform.position = _cam.transform.position + _cam.transform.forward * 5.0f;\n            else\n                plane.transform.position = Vector3.zero;\n\n            Vector2 anchorOffset;\n            string anchorId;\n            switch (anchor)\n            {\n                case AnchorPoint.TopLeft:\n                    anchorOffset = new Vector2(-width / 2.0f, length / 2.0f);\n                    anchorId = \"TL\";\n                    break;\n                case AnchorPoint.TopHalf:\n                    anchorOffset = new Vector2(0.0f, length / 2.0f);\n                    anchorId = \"TH\";\n                    break;\n                case AnchorPoint.TopRight:\n                    anchorOffset = new Vector2(width / 2.0f, length / 2.0f);\n                    anchorId = \"TR\";\n                    break;\n                case AnchorPoint.RightHalf:\n                    anchorOffset = new Vector2(width / 2.0f, 0.0f);\n                    anchorId = \"RH\";\n                    break;\n                case AnchorPoint.BottomRight:\n                    anchorOffset = new Vector2(width / 2.0f, -length / 2.0f);\n                    anchorId = \"BR\";\n                    break;\n                case AnchorPoint.BottomHalf:\n                    anchorOffset = new Vector2(0.0f, -length / 2.0f);\n                    anchorId = \"BH\";\n                    break;\n                case AnchorPoint.BottomLeft:\n                    anchorOffset = new Vector2(-width / 2.0f, -length / 2.0f);\n                    anchorId = \"BL\";\n                    break;\n                case AnchorPoint.LeftHalf:\n                    anchorOffset = new Vector2(-width / 2.0f, 0.0f);\n                    anchorId = \"LH\";\n                    break;\n                case AnchorPoint.Center:\n                default:\n                    anchorOffset = Vector2.zero;\n                    anchorId = \"C\";\n                    break;\n            }\n\n            var meshFilter = (MeshFilter)plane.AddComponent(typeof(MeshFilter));\n            plane.AddComponent(typeof(MeshRenderer));\n\n            var planeAssetName = plane.name + widthSegments + \"x\" + lengthSegments + \"W\" + width + \"L\" + length +\n                                 (orientation == Orientation.Horizontal ? \"H\" : \"V\") + anchorId + \".asset\";\n            var m = (Mesh)AssetDatabase.LoadAssetAtPath(\"Assets/Editor/\" + planeAssetName, typeof(Mesh));\n", "            if (m == null)\n            {\n                m = new Mesh();\n                m.name = plane.name;\n\n                var hCount2 = widthSegments + 1;\n                var vCount2 = lengthSegments + 1;\n                var numTriangles = widthSegments * lengthSegments * 6;\n                var numVertices = hCount2 * vCount2;\n\n                var vertices = new Vector3[numVertices];\n                var uvs = new Vector2[numVertices];\n                var triangles = new int[numTriangles];\n\n                var index = 0;\n                var uvFactorX = 1.0f / widthSegments;\n                var uvFactorY = 1.0f / lengthSegments;\n                var scaleX = width / widthSegments;\n                var scaleY = length / lengthSegments;", "                for (var y = 0.0f; y < vCount2; y++)\n                for (var x = 0.0f; x < hCount2; x++)\n                {\n                    if (orientation == Orientation.Horizontal)\n                        vertices[index] = new Vector3(x * scaleX - width / 2f - anchorOffset.x, 0.0f,\n                            y * scaleY - length / 2f - anchorOffset.y);\n                    else\n                        vertices[index] = new Vector3(x * scaleX - width / 2f - anchorOffset.x,\n                            y * scaleY - length / 2f - anchorOffset.y, 0.0f);\n                    uvs[index++] = new Vector2(x * uvFactorX, y * uvFactorY);\n                }\n\n                index = 0;", "                for (var y = 0; y < lengthSegments; y++)\n                for (var x = 0; x < widthSegments; x++)\n                {\n                    triangles[index] = y * hCount2 + x;\n                    triangles[index + 1] = (y + 1) * hCount2 + x;\n                    triangles[index + 2] = y * hCount2 + x + 1;\n\n                    triangles[index + 3] = (y + 1) * hCount2 + x;\n                    triangles[index + 4] = (y + 1) * hCount2 + x + 1;\n                    triangles[index + 5] = y * hCount2 + x + 1;\n                    index += 6;\n                }\n\n                m.vertices = vertices;\n                m.uv = uvs;\n                m.triangles = triangles;\n                m.RecalculateNormals();\n\n                AssetDatabase.CreateAsset(m, \"Assets/Editor/\" + planeAssetName);\n                AssetDatabase.SaveAssets();\n            }\n\n            meshFilter.sharedMesh = m;\n            m.RecalculateBounds();\n", "            if (addCollider)\n                plane.AddComponent(typeof(BoxCollider));\n\n            Selection.activeObject = plane;\n        }\n\n\n        private void OnWizardUpdate()\n        {\n            widthSegments = Mathf.Clamp(widthSegments, 1, 254);\n            lengthSegments = Mathf.Clamp(lengthSegments, 1, 254);\n        }\n\n\n        [MenuItem(\"GameObject/Create Other/Custom Plane...\")]", "        private static void CreateWizard()\n        {\n            _cam = Camera.current;\n            // Hack because camera.current doesn't return editor camera if scene view doesn't have focus\n            if (!_cam)\n                _cam = _lastUsedCam;\n            else\n                _lastUsedCam = _cam;\n            DisplayWizard(\"Create Plane\", typeof(CreatePlane));\n        }\n    }\n}"]}
{"filename": "Assets/EcsDamageBubbles/Runtime/Scripts/DamageBubbleSpawnSystem.cs", "chunked_list": ["\ufeffusing EcsDamageBubbles.Config;\nusing Unity.Burst;\nusing Unity.Collections;\nusing Unity.Entities;\nusing Unity.Mathematics;\nusing Unity.Transforms;\n\nnamespace EcsDamageBubbles\n{\n    /// <summary>", "{\n    /// <summary>\n    ///     Replace DamageRequest tag with DamageBubble text\n    /// </summary>\n    public partial struct DamageBubbleSpawnSystem : ISystem\n    {\n        private NativeArray<float4> _colorConfig;\n\n        [BurstCompile]\n        public void OnCreate(ref SystemState state)\n        {\n            state.RequireForUpdate<BeginSimulationEntityCommandBufferSystem.Singleton>();\n            state.RequireForUpdate<DamageBubblesConfig>();\n            state.RequireForUpdate<DamageBubbleColorConfig>();\n        }\n", "        public void OnCreate(ref SystemState state)\n        {\n            state.RequireForUpdate<BeginSimulationEntityCommandBufferSystem.Singleton>();\n            state.RequireForUpdate<DamageBubblesConfig>();\n            state.RequireForUpdate<DamageBubbleColorConfig>();\n        }\n\n        public void OnDestroy(ref SystemState state)\n        {\n            _colorConfig.Dispose();\n        }\n\n        [BurstCompile]", "        public void OnUpdate(ref SystemState state)\n        {\n            if (_colorConfig == default)\n            {\n                var damageColorConfig = SystemAPI.GetSingletonBuffer<DamageBubbleColorConfig>(true);\n                _colorConfig = new NativeArray<float4>(damageColorConfig.Length, Allocator.Persistent);\n                for (var i = 0; i < _colorConfig.Length; i++) _colorConfig[i] = damageColorConfig[i].Color;\n            }\n\n            var config = SystemAPI.GetSingleton<DamageBubblesConfig>();\n\n            var elapsedTime = (float)SystemAPI.Time.ElapsedTime;\n            var ecbSingleton = SystemAPI.GetSingleton<BeginSimulationEntityCommandBufferSystem.Singleton>();\n\n            new ApplyGlyphsJob\n            {\n                Ecb = ecbSingleton.CreateCommandBuffer(state.WorldUnmanaged).AsParallelWriter(),\n                ElapsedTime = elapsedTime,\n                ColorConfig = _colorConfig,\n                GlyphEntity = config.GlyphPrefab,\n                GlyphZOffset = config.GlyphZOffset,\n                GlyphWidth = config.GlyphWidth\n            }.ScheduleParallel();\n        }\n\n\n        [BurstCompile]\n        [WithNone(typeof(DamageBubble.DamageBubble))]", "        public partial struct ApplyGlyphsJob : IJobEntity\n        {\n            public EntityCommandBuffer.ParallelWriter Ecb;\n            [ReadOnly] public Entity GlyphEntity;\n            [ReadOnly] public float ElapsedTime;\n            [ReadOnly] public float GlyphZOffset;\n            [ReadOnly] public float GlyphWidth;\n            [ReadOnly] public NativeArray<float4> ColorConfig;\n\n            public void Execute([ChunkIndexInQuery] int chunkIndex, Entity entity, in LocalTransform transform,\n                in DamageBubbleRequest damageBubbleRequest)\n            {\n                var number = damageBubbleRequest.Value;\n                var color = ColorConfig[damageBubbleRequest.ColorId];\n                var glyphTransform = transform;\n                var offset = math.log10(number) / 2f * GlyphWidth;\n                glyphTransform.Position.x += offset;\n\n                // split to numbers\n                // we iterate from  rightmost digit to leftmost", "            public void Execute([ChunkIndexInQuery] int chunkIndex, Entity entity, in LocalTransform transform,\n                in DamageBubbleRequest damageBubbleRequest)\n            {\n                var number = damageBubbleRequest.Value;\n                var color = ColorConfig[damageBubbleRequest.ColorId];\n                var glyphTransform = transform;\n                var offset = math.log10(number) / 2f * GlyphWidth;\n                glyphTransform.Position.x += offset;\n\n                // split to numbers\n                // we iterate from  rightmost digit to leftmost", "                while (number > 0)\n                {\n                    var digit = number % 10;\n                    number /= 10;\n                    var glyph = Ecb.Instantiate(chunkIndex, GlyphEntity);\n                    Ecb.SetComponent(chunkIndex, glyph, glyphTransform);\n                    glyphTransform.Position.x -= GlyphWidth;\n                    glyphTransform.Position.z -= GlyphZOffset;\n                    Ecb.AddComponent(chunkIndex, glyph,\n                        new DamageBubble.DamageBubble\n                            { SpawnTime = ElapsedTime, OriginalY = glyphTransform.Position.y });\n\n                    Ecb.AddComponent(chunkIndex, glyph, new GlyphIdFloatOverride { Value = digit });\n                    Ecb.SetComponent(chunkIndex, glyph, new GlyphColorOverride { Color = color });\n                }\n\n                Ecb.DestroyEntity(chunkIndex, entity);\n            }\n        }\n    }\n}"]}
{"filename": "Assets/EcsDamageBubbles/Runtime/Scripts/DamageBubbleRequest.cs", "chunked_list": ["\ufeffusing Unity.Entities;\n\nnamespace EcsDamageBubbles\n{\n    public struct DamageBubbleRequest : IComponentData\n    {\n        public int Value;\n        public int ColorId;\n    }\n}"]}
{"filename": "Assets/EcsDamageBubbles/Runtime/Scripts/DamageBubble/DamageBubble.cs", "chunked_list": ["\ufeffusing Unity.Entities;\n\nnamespace EcsDamageBubbles.DamageBubble\n{\n    public struct DamageBubble : IComponentData\n    {\n        public float SpawnTime;\n        public float OriginalY;\n    }\n}"]}
{"filename": "Assets/EcsDamageBubbles/Runtime/Scripts/DamageBubble/DamageBubbleMovementSystem.cs", "chunked_list": ["\ufeffusing System.Runtime.CompilerServices;\nusing EcsDamageBubbles.Config;\nusing Unity.Burst;\nusing Unity.Entities;\nusing Unity.Transforms;\n\nnamespace EcsDamageBubbles.DamageBubble\n{\n    [UpdateAfter(typeof(DamageBubbleSpawnSystem))]\n    public partial struct DamageBubbleMovementSystem : ISystem\n    {", "    [UpdateAfter(typeof(DamageBubbleSpawnSystem))]\n    public partial struct DamageBubbleMovementSystem : ISystem\n    {\n        public void OnCreate(ref SystemState state)\n        {\n            state.RequireForUpdate<EndSimulationEntityCommandBufferSystem.Singleton>();\n            state.RequireForUpdate<DamageBubblesConfig>();\n        }\n\n        [BurstCompile]\n        public void OnUpdate(ref SystemState state)\n        {\n            var ecbSingleton = SystemAPI.GetSingleton<EndSimulationEntityCommandBufferSystem.Singleton>();\n            var config = SystemAPI.GetSingleton<DamageBubblesConfig>();\n            new MoveJob\n            {\n                ElapsedTime = (float)SystemAPI.Time.ElapsedTime,\n                DeltaTime = SystemAPI.Time.DeltaTime,\n                ECBWriter = ecbSingleton.CreateCommandBuffer(state.WorldUnmanaged).AsParallelWriter(),\n                lifeTime = config.MovementTime,\n                VerticalOffset = config.VerticalOffset,\n                ScaleOffset = config.ScaleOffset\n            }.ScheduleParallel();\n        }\n\n        [BurstCompile]", "        public void OnUpdate(ref SystemState state)\n        {\n            var ecbSingleton = SystemAPI.GetSingleton<EndSimulationEntityCommandBufferSystem.Singleton>();\n            var config = SystemAPI.GetSingleton<DamageBubblesConfig>();\n            new MoveJob\n            {\n                ElapsedTime = (float)SystemAPI.Time.ElapsedTime,\n                DeltaTime = SystemAPI.Time.DeltaTime,\n                ECBWriter = ecbSingleton.CreateCommandBuffer(state.WorldUnmanaged).AsParallelWriter(),\n                lifeTime = config.MovementTime,\n                VerticalOffset = config.VerticalOffset,\n                ScaleOffset = config.ScaleOffset\n            }.ScheduleParallel();\n        }\n\n        [BurstCompile]", "        public partial struct MoveJob : IJobEntity\n        {\n            public float ElapsedTime;\n            public float DeltaTime;\n            public EntityCommandBuffer.ParallelWriter ECBWriter;\n            public float lifeTime;\n            public float VerticalOffset;\n            public float ScaleOffset;\n\n            private void Execute(Entity entity, [ChunkIndexInQuery] int chunkIndex, ref LocalTransform transform,\n                in DamageBubble bubble)\n            {\n                var timeAlive = ElapsedTime - bubble.SpawnTime;", "            private void Execute(Entity entity, [ChunkIndexInQuery] int chunkIndex, ref LocalTransform transform,\n                in DamageBubble bubble)\n            {\n                var timeAlive = ElapsedTime - bubble.SpawnTime;\n                if (timeAlive > lifeTime) ECBWriter.DestroyEntity(chunkIndex, entity);\n\n                var easing = EaseOutQuad(timeAlive / lifeTime);\n                transform.Position.y = bubble.OriginalY + VerticalOffset * easing;\n                transform.Position.z += DeltaTime / 100;\n                transform.Scale = 1 + ScaleOffset * easing;\n            }\n\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]", "            private static float EaseOutQuad(float number)\n            {\n                return 1 - (1 - number) * (1 - number);\n            }\n        }\n    }\n}"]}
{"filename": "Assets/EcsDamageBubbles/Runtime/Scripts/Config/DamageBubblesConfig.cs", "chunked_list": ["\ufeffusing Unity.Entities;\n\nnamespace EcsDamageBubbles.Config\n{\n    public struct DamageBubblesConfig : IComponentData\n    {\n        public Entity GlyphPrefab;\n        public float VerticalOffset;\n        public float MovementTime;\n        public float ScaleOffset;\n        public float GlyphZOffset;", "        public float MovementTime;\n        public float ScaleOffset;\n        public float GlyphZOffset;\n        public float GlyphWidth;\n    }\n}"]}
{"filename": "Assets/EcsDamageBubbles/Runtime/Scripts/Config/DamageBubblesConfigAuthoring.cs", "chunked_list": ["using Unity.Entities;\nusing Unity.Mathematics;\nusing UnityEngine;\n\nnamespace EcsDamageBubbles.Config\n{\n    public class DamageBubblesConfigAuthoring : MonoBehaviour\n    {\n        public GameObject glyphPrefab;\n        public float verticalOffset = 2f;\n        public float movementTime = 2f;", "        public GameObject glyphPrefab;\n        public float verticalOffset = 2f;\n        public float movementTime = 2f;\n        public float scaleOffset = 1f;\n        public float glyphZOffset = 0.001f;\n        public float glyphWidth = 0.07f;\n        public Color[] damageColors;\n\n        public class ConfigDataBaker : Baker<DamageBubblesConfigAuthoring>\n        {\n            public override void Bake(DamageBubblesConfigAuthoring authoring)\n            {\n                var entity = GetEntity(TransformUsageFlags.None);\n                AddComponent(entity, new DamageBubblesConfig\n                {\n                    GlyphPrefab = GetEntity(authoring.glyphPrefab, TransformUsageFlags.None),\n                    ScaleOffset = authoring.scaleOffset,\n                    VerticalOffset = authoring.verticalOffset,\n                    MovementTime = authoring.movementTime,\n                    GlyphZOffset = authoring.glyphZOffset,\n                    GlyphWidth = authoring.glyphWidth\n                });\n\n                var buffer = AddBuffer<DamageBubbleColorConfig>(entity);", "        public class ConfigDataBaker : Baker<DamageBubblesConfigAuthoring>\n        {\n            public override void Bake(DamageBubblesConfigAuthoring authoring)\n            {\n                var entity = GetEntity(TransformUsageFlags.None);\n                AddComponent(entity, new DamageBubblesConfig\n                {\n                    GlyphPrefab = GetEntity(authoring.glyphPrefab, TransformUsageFlags.None),\n                    ScaleOffset = authoring.scaleOffset,\n                    VerticalOffset = authoring.verticalOffset,\n                    MovementTime = authoring.movementTime,\n                    GlyphZOffset = authoring.glyphZOffset,\n                    GlyphWidth = authoring.glyphWidth\n                });\n\n                var buffer = AddBuffer<DamageBubbleColorConfig>(entity);", "                foreach (var managedColor in authoring.damageColors)\n                {\n                    var color = new float4(managedColor.r, managedColor.g, managedColor.b, managedColor.a);\n                    buffer.Add(new DamageBubbleColorConfig { Color = color });\n                }\n            }\n        }\n    }\n}"]}
{"filename": "Assets/EcsDamageBubbles/Runtime/Scripts/Config/GlyphColorOverride.cs", "chunked_list": ["\ufeffusing Unity.Entities;\nusing Unity.Mathematics;\nusing Unity.Rendering;\n\nnamespace EcsDamageBubbles.Config\n{\n    [MaterialProperty(\"_GlyphColor\")]\n    internal struct GlyphColorOverride : IComponentData\n    {\n        public float4 Color;\n    }\n}", "        public float4 Color;\n    }\n}"]}
{"filename": "Assets/EcsDamageBubbles/Runtime/Scripts/Config/GlyphIdFloatOverride.cs", "chunked_list": ["using Unity.Entities;\nusing Unity.Rendering;\n\nnamespace EcsDamageBubbles.Config\n{\n    [MaterialProperty(\"_GlyphId\")]\n    internal struct GlyphIdFloatOverride : IComponentData\n    {\n        public float Value;\n    }\n}", "        public float Value;\n    }\n}"]}
{"filename": "Assets/EcsDamageBubbles/Runtime/Scripts/Config/DamageBubbleColorConfig.cs", "chunked_list": ["\ufeffusing Unity.Entities;\nusing Unity.Mathematics;\n\nnamespace EcsDamageBubbles.Config\n{\n    public struct DamageBubbleColorConfig : IBufferElementData\n    {\n        public float4 Color;\n    }\n}"]}
{"filename": "Assets/Demo/Scripts/TestSpawner/TestSpawnerSystem.cs", "chunked_list": ["\ufeffusing EcsDamageBubbles.Config;\nusing Unity.Collections;\nusing Unity.Entities;\nusing Unity.Transforms;\nusing UnityEngine;\nusing Random = Unity.Mathematics.Random;\n\nnamespace EcsDamageBubbles.Demo\n{\n    public partial class TestSpawnerSystem : SystemBase\n    {", "{\n    public partial class TestSpawnerSystem : SystemBase\n    {\n        private Random _rnd;\n        \n        protected override void OnCreate()\n        {\n            _rnd = new Random((uint)SystemAPI.Time.GetHashCode());\n            RequireForUpdate<DamageBubbleColorConfig>();\n        }\n", "        protected override void OnUpdate()\n        {\n            var colorConfig = SystemAPI.GetSingletonBuffer<DamageBubbleColorConfig>();\n            var ecb = new EntityCommandBuffer(Allocator.Temp);\n            foreach (var spawner in SystemAPI.Query<TestSpawner>())\n            {\n                var entities = spawner.EntitiesPerFrame;\n                while (entities-- > 0)\n                {\n                    var colorRND = _rnd.NextInt(0, 10);\n                    var colorId = 0;", "                    if (colorRND > 6 )\n                    {\n                        colorId = colorRND > 8 ? 1 : 2;\n                    }\n                    \n                    var entity = ecb.CreateEntity();\n                    ecb.AddComponent(entity, new DamageBubbleRequest\n                    {\n                        Value = _rnd.NextInt(1, 999999),\n                        ColorId = colorId\n                    });\n\n                    ecb.AddComponent(entity, new LocalTransform\n                    {\n                        Scale = 1, Position = _rnd.NextFloat3(spawner.MinPosition, spawner.MaxPosition), Rotation = Quaternion.identity\n                    });\n                }\n                \n            }\n\n            ecb.Playback(EntityManager);\n        }\n    }\n}"]}
{"filename": "Assets/Demo/Scripts/TestSpawner/TestSpawnerAuthoring.cs", "chunked_list": ["using Unity.Entities;\nusing UnityEngine;\n\nnamespace EcsDamageBubbles.Demo\n{\n    public class TestSpawnerAuthoring : MonoBehaviour\n    {\n        public Vector3 minPosition;\n        public Vector3 maxPosition;\n        public int entitiesPerFrame;\n        ", "        public Vector3 maxPosition;\n        public int entitiesPerFrame;\n        \n        public class TestSpawnerBaker : Baker<TestSpawnerAuthoring>\n        {\n            public override void Bake(TestSpawnerAuthoring authoring)\n            {\n                var entity = GetEntity(TransformUsageFlags.None);\n                AddComponent(entity, new TestSpawner()\n                {\n                    MaxPosition = authoring.maxPosition,\n                    MinPosition = authoring.minPosition,\n                    EntitiesPerFrame = authoring.entitiesPerFrame\n                });\n            }\n        }\n    }\n}"]}
{"filename": "Assets/Demo/Scripts/TestSpawner/TestSpawner.cs", "chunked_list": ["\ufeffusing Unity.Entities;\nusing Unity.Mathematics;\n\nnamespace EcsDamageBubbles.Demo\n{\n    public struct TestSpawner : IComponentData\n    {\n        public float3 MinPosition;\n        public float3 MaxPosition;\n        public int EntitiesPerFrame;\n    }\n}", "        public float3 MaxPosition;\n        public int EntitiesPerFrame;\n    }\n}"]}
{"filename": "Assets/Editor/SyncDemoFolder.cs", "chunked_list": ["using System.IO;\nusing UnityEditor;\n\npublic class SyncDemoFolder\n{\n    const string SRC_FOLDER = @\"Assets/Demo\";\n    const string TARGET_FOLDER = @\"Assets/EcsDamageBubbles/Samples~/Demo\";\n    \n    [MenuItem(\"Window/SyncDemoFolder\")]\n    public static void SyncDemoFolderRecursively()\n    {\n", "    public static void SyncDemoFolderRecursively()\n    {\n\n        if (Directory.Exists(TARGET_FOLDER + \"/Demo\")) Directory.Delete(TARGET_FOLDER, true);\n\n        var srcInfo = new DirectoryInfo(SRC_FOLDER);\n        var dstInfo = new DirectoryInfo(TARGET_FOLDER);\n        CopyAll(srcInfo, dstInfo);\n    }\n\n    private static void CopyAll(DirectoryInfo source, DirectoryInfo target)\n    {", "    private static void CopyAll(DirectoryInfo source, DirectoryInfo target)\n    {\n        if (Directory.Exists(target.FullName) == false) Directory.CreateDirectory(target.FullName);\n\n        foreach (var fi in source.GetFiles()) fi.CopyTo(Path.Combine(target.ToString(), fi.Name), true);\n        foreach (var diSourceDir in source.GetDirectories())\n        {\n            var nextTargetDir = target.CreateSubdirectory(diSourceDir.Name);\n            CopyAll(diSourceDir, nextTargetDir);\n        }\n    }\n}"]}
