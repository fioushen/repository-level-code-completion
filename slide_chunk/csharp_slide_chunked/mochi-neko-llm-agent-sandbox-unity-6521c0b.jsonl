{"filename": "Assets/Mochineko/KoeiromapAPI.Samples/KoeiromapAPISample.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.IO;\nusing System.Net.Http;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Resilience;\nusing Mochineko.Relent.UncertainResult;\nusing Mochineko.SimpleAudioCodec;\nusing UnityEngine;", "using Mochineko.SimpleAudioCodec;\nusing UnityEngine;\nusing UnityEngine.Assertions;\n\nnamespace Mochineko.KoeiromapAPI.Samples\n{\n    internal sealed class KoeiromapAPISample : MonoBehaviour\n    {\n        [SerializeField, Range(-3f, 3f)] private float speakerX;\n        [SerializeField, Range(-3f, 3f)] private float speakerY;\n        [SerializeField] private bool useSeed;", "        [SerializeField, Range(-3f, 3f)] private float speakerX;\n        [SerializeField, Range(-3f, 3f)] private float speakerY;\n        [SerializeField] private bool useSeed;\n        [SerializeField] private ulong seed;\n        [SerializeField, TextArea] private string text = string.Empty;\n        [SerializeField] private Style style;\n        [SerializeField] private AudioSource? audioSource;\n\n        private static readonly HttpClient HttpClient = new();\n\n        private IPolicy<Stream>? policy;\n", "        private static readonly HttpClient HttpClient = new();\n\n        private IPolicy<Stream>? policy;\n\n        private void Awake()\n        {\n            Assert.IsNotNull(audioSource);\n\n            policy = PolicyFactory.BuildPolicy();\n        }\n\n        [ContextMenu(nameof(Synthesis))]", "        public void Synthesis()\n        {\n            SynthesisAsync(text, style, this.GetCancellationTokenOnDestroy())\n                .Forget();\n        }\n\n        private async UniTask SynthesisAsync(\n            string text,\n            Style style,\n            CancellationToken cancellationToken)\n        {", "            if (policy == null || audioSource == null)\n            {\n                return;\n            }\n\n            Debug.Log($\"Begin to synthesis speech from text:{text}.\");\n\n            await UniTask.SwitchToThreadPool();\n\n            var synthesisResult = await policy.ExecuteAsync(\n                async innerCancellationToken => await SpeechSynthesisAPI.SynthesisAsync(\n                    HttpClient,\n                    text,\n                    innerCancellationToken,\n                    speakerX: speakerX,\n                    speakerY: speakerY,\n                    style: style,\n                    seed: useSeed ? seed : null),\n                cancellationToken);\n", "            if (synthesisResult is IUncertainSuccessResult<Stream> success)\n            {\n                await using (success.Result)\n                {\n                    try\n                    {\n                        var audioClip = await WaveDecoder.DecodeByBlockAsync(\n                            success.Result,\n                            fileName: \"KoeiromapSynthesized.wav\",\n                            cancellationToken);\n\n                        await UniTask.SwitchToMainThread(cancellationToken);\n\n                        Debug.Log($\"Succeeded to synthesis speech from text:{text}.\");\n\n                        audioSource.PlayOneShot(audioClip);\n                    }", "                    catch (Exception exception)\n                    {\n                        Debug.LogError($\"Failed to decode audio stream because -> {exception}.\");\n                    }\n                }\n            }\n            else if (synthesisResult is IUncertainRetryableResult<Stream> retryable)\n            {\n                Debug.LogError($\"Failed to synthesis speech from text because -> {retryable.Message}.\");\n            }\n            else if (synthesisResult is IUncertainFailureResult<Stream> failure)\n            {\n                Debug.LogError($\"Failed to synthesis speech from text because -> {failure.Message}.\");\n            }\n            else\n            {\n                throw new UncertainResultPatternMatchException(nameof(synthesisResult));\n            }\n        }\n    }\n}", "            else if (synthesisResult is IUncertainFailureResult<Stream> failure)\n            {\n                Debug.LogError($\"Failed to synthesis speech from text because -> {failure.Message}.\");\n            }\n            else\n            {\n                throw new UncertainResultPatternMatchException(nameof(synthesisResult));\n            }\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/KoeiromapAPI.Samples/PolicyFactory.cs", "chunked_list": ["using System;\nusing System.IO;\nusing Mochineko.Relent.Resilience;\nusing Mochineko.Relent.Resilience.Bulkhead;\nusing Mochineko.Relent.Resilience.Retry;\nusing Mochineko.Relent.Resilience.Timeout;\nusing Mochineko.Relent.Resilience.Wrap;\n\nnamespace Mochineko.KoeiromapAPI.Samples\n{\n    internal static class PolicyFactory\n    {", "namespace Mochineko.KoeiromapAPI.Samples\n{\n    internal static class PolicyFactory\n    {\n        private const float TotalTimeoutSeconds = 60f;\n        private const float EachTimeoutSeconds = 30f;\n        private const int MaxRetryCount = 5;\n        private const float RetryIntervalSeconds = 1f;\n        private const int MaxParallelization = 1;\n        \n        public static IPolicy<Stream> BuildPolicy()\n        {\n            var totalTimeoutPolicy = TimeoutFactory.Timeout<Stream>(\n                timeout: TimeSpan.FromSeconds(TotalTimeoutSeconds));\n            \n            var retryPolicy = RetryFactory.RetryWithInterval<Stream>(\n                MaxRetryCount,\n                interval: TimeSpan.FromSeconds(RetryIntervalSeconds));\n\n            var eachTimeoutPolicy = TimeoutFactory.Timeout<Stream>(\n                timeout: TimeSpan.FromSeconds(EachTimeoutSeconds));\n\n            var bulkheadPolicy = BulkheadFactory.Bulkhead<Stream>(\n                MaxParallelization);\n\n            return totalTimeoutPolicy\n                .Wrap(retryPolicy)\n                .Wrap(eachTimeoutPolicy)\n                .Wrap(bulkheadPolicy);\n        }\n    }\n}", "        private const int MaxParallelization = 1;\n        \n        public static IPolicy<Stream> BuildPolicy()\n        {\n            var totalTimeoutPolicy = TimeoutFactory.Timeout<Stream>(\n                timeout: TimeSpan.FromSeconds(TotalTimeoutSeconds));\n            \n            var retryPolicy = RetryFactory.RetryWithInterval<Stream>(\n                MaxRetryCount,\n                interval: TimeSpan.FromSeconds(RetryIntervalSeconds));\n\n            var eachTimeoutPolicy = TimeoutFactory.Timeout<Stream>(\n                timeout: TimeSpan.FromSeconds(EachTimeoutSeconds));\n\n            var bulkheadPolicy = BulkheadFactory.Bulkhead<Stream>(\n                MaxParallelization);\n\n            return totalTimeoutPolicy\n                .Wrap(retryPolicy)\n                .Wrap(eachTimeoutPolicy)\n                .Wrap(bulkheadPolicy);\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Memory/LongTermChatMemory.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.ChatGPT_API;\nusing Mochineko.LLMAgent.Summarization;\nusing Mochineko.Relent.Result;\nusing TiktokenSharp;", "using Mochineko.Relent.Result;\nusing TiktokenSharp;\nusing UnityEngine;\n\nnamespace Mochineko.LLMAgent.Memory\n{\n    public sealed class LongTermChatMemory : IChatMemory\n    {\n        private readonly int maxShortTermMemoriesTokenLength;\n        private readonly int maxBufferMemoriesTokenLength;\n        private readonly TikToken tikToken;", "        private readonly int maxShortTermMemoriesTokenLength;\n        private readonly int maxBufferMemoriesTokenLength;\n        private readonly TikToken tikToken;\n        private readonly List<Message> prompts = new();\n        internal IEnumerable<Message> Prompts => prompts.ToArray();\n        private readonly Queue<Message> shortTermMemories = new();\n        internal IEnumerable<Message> ShortTermMemories => shortTermMemories.ToArray();\n        private readonly Queue<Message> bufferMemories = new();\n        internal IEnumerable<Message> BufferMemories => bufferMemories.ToArray();\n        private readonly Summarizer summarizer;\n        private readonly IChatMemoryStore store;", "        private readonly Summarizer summarizer;\n        private readonly IChatMemoryStore store;\n        private Message summary;\n        internal Message Summary => summary;\n        private readonly object lockObject = new();\n\n        public static async UniTask<LongTermChatMemory> InstantiateAsync(\n            int maxShortTermMemoriesTokenLength,\n            int maxBufferMemoriesTokenLength,\n            string apiKey,\n            Model model,\n            IChatMemoryStore? store,\n            CancellationToken cancellationToken)\n        {\n            var instance = new LongTermChatMemory(\n                maxShortTermMemoriesTokenLength,\n                maxBufferMemoriesTokenLength,\n                apiKey,\n                model,\n                store);\n\n            var result = await instance.store.LoadAsync(cancellationToken);", "            if (result is ISuccessResult<string> success)\n            {\n                Debug.Log($\"[LLMAgent.Memory] Succeeded to load chat memory from store:{success.Result}\");\n                instance.summary = new Message(Role.System, success.Result);\n            }\n            else if (result is IFailureResult<string> failure)\n            {\n                Debug.LogError(\n                    $\"[LLMAgent.Memory] Failed to load chat memory from store because -> {failure.Message}\");\n            }\n            else\n            {\n                throw new ResultPatternMatchException(nameof(result));\n            }\n\n            return instance;\n        }\n\n        private LongTermChatMemory(\n            int maxShortTermMemoriesTokenLength,\n            int maxBufferMemoriesTokenLength,\n            string apiKey,\n            Model model,\n            IChatMemoryStore? store)\n        {\n            this.maxShortTermMemoriesTokenLength = maxShortTermMemoriesTokenLength;\n            this.maxBufferMemoriesTokenLength = maxBufferMemoriesTokenLength;\n            this.tikToken = TikToken.EncodingForModel(model.ToText());\n            this.summarizer = new Summarizer(apiKey, model);\n\n            this.store = store ?? new NullChatMemoryStore();\n            this.summary = new Message(Role.System, string.Empty);\n        }\n\n        public IReadOnlyList<Message> Messages\n            => prompts\n                .Concat(new[] { summary })\n                .Concat(shortTermMemories)\n                .ToList();\n\n        public IReadOnlyList<Message> Conversations\n            => new[] { summary }\n                .Concat(shortTermMemories)\n                .Concat(bufferMemories)\n                .ToList();\n", "        public int ShortTermMemoriesTokenLength\n            => shortTermMemories.TokenLength(tikToken);\n\n        public int BufferMemoriesTokenLength\n            => bufferMemories.TokenLength(tikToken);\n\n        public int SummaryTokenLength\n            => summary.TokenLength(tikToken);\n\n        public int PromptsTokenLength\n            => prompts.TokenLength(tikToken);\n", "        public int PromptsTokenLength\n            => prompts.TokenLength(tikToken);\n\n        public int TotalMemoriesTokenLength\n            => PromptsTokenLength\n               + SummaryTokenLength\n               + ShortTermMemoriesTokenLength;\n\n        public async Task AddMessageAsync(Message message, CancellationToken cancellationToken)\n        {\n            if (message.Role is Role.System)\n            {\n                lock (lockObject)\n                {\n                    prompts.Add(message);\n                }\n            }", "        public async Task AddMessageAsync(Message message, CancellationToken cancellationToken)\n        {\n            if (message.Role is Role.System)\n            {\n                lock (lockObject)\n                {\n                    prompts.Add(message);\n                }\n            }\n            else if (message.Role is Role.User)\n            {\n                lock (lockObject)\n                {\n                    shortTermMemories.Enqueue(message);\n                }\n            }", "            else if (message.Role is Role.User)\n            {\n                lock (lockObject)\n                {\n                    shortTermMemories.Enqueue(message);\n                }\n            }\n            else if (message.Role is Role.Assistant)\n            {\n                lock (lockObject)\n                {\n                    shortTermMemories.Enqueue(message);\n                }\n", "                while (ShortTermMemoriesTokenLength > maxShortTermMemoriesTokenLength)\n                {\n                    bool tryDequeue;\n                    Message? dequeued;\n                    lock (lockObject)\n                    {\n                        tryDequeue = shortTermMemories.TryDequeue(out dequeued);\n                    }\n\n                    if (tryDequeue)\n                    {\n                        lock (lockObject)\n                        {\n                            bufferMemories.Enqueue(dequeued);\n                        }\n", "                    if (tryDequeue)\n                    {\n                        lock (lockObject)\n                        {\n                            bufferMemories.Enqueue(dequeued);\n                        }\n\n                        if (BufferMemoriesTokenLength > maxBufferMemoriesTokenLength)\n                        {\n                            await SummarizeAsync(cancellationToken);\n                        }\n                    }\n                }\n            }\n\n            Debug.Log(\n                $\"[LLMAgent.Chat] Update memory by adding {message}, short term:{ShortTermMemoriesTokenLength}, buffer:{BufferMemoriesTokenLength}, summary:{SummaryTokenLength}/{summary.Content}.\");\n        }\n", "        private async UniTask SummarizeAsync(CancellationToken cancellationToken)\n        {\n            List<Message> buffers;\n            lock (lockObject)\n            {\n                buffers = bufferMemories.ToList();\n            }\n\n            var summarizeResult = await summarizer.SummarizeAsync(\n                buffers,\n                cancellationToken);", "            if (summarizeResult is ISuccessResult<string> summarizeSuccess)\n            {\n                Debug.Log(\n                    $\"[LLMAgent.Summarization] Succeeded to summarize long term memory:{summarizeSuccess.Result}\");\n\n                lock (lockObject)\n                {\n                    summary = new Message(\n                        Role.System,\n                        summarizeSuccess.Result);\n                }\n            }\n            else\n            {\n                Debug.LogError(\n                    $\"[LLMAgent.Summarization] Failed to summarize long term memory then keep summary and forget buffers:{summary.Content}\");\n            }\n\n            lock (lockObject)\n            {\n                bufferMemories.Clear();\n            }\n        }\n", "        public void ClearAllMessages()\n        {\n            lock (lockObject)\n            {\n                prompts.Clear();\n                shortTermMemories.Clear();\n                bufferMemories.Clear();\n                summary = new Message(Role.System, \"\");\n            }\n        }\n", "        public void ClearPrompts()\n        {\n            lock (lockObject)\n            {\n                prompts.Clear();\n            }\n        }\n\n        public void ClearShortTermMemory()\n        {\n            lock (lockObject)\n            {\n                shortTermMemories.Clear();\n            }\n        }\n", "        public void ClearShortTermMemory()\n        {\n            lock (lockObject)\n            {\n                shortTermMemories.Clear();\n            }\n        }\n\n        public void ClearBufferMemory()\n        {\n            lock (lockObject)\n            {\n                bufferMemories.Clear();\n            }\n        }\n", "        public void ClearBufferMemory()\n        {\n            lock (lockObject)\n            {\n                bufferMemories.Clear();\n            }\n        }\n\n        public void ClearSummary()\n        {\n            lock (lockObject)\n            {\n                summary = new Message(Role.System, \"\");\n            }\n        }\n    }\n}", "        public void ClearSummary()\n        {\n            lock (lockObject)\n            {\n                summary = new Message(Role.System, \"\");\n            }\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Memory/IChatMemoryStore.cs", "chunked_list": ["#nullable enable\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Result;\n\nnamespace Mochineko.LLMAgent.Memory\n{\n    public interface IChatMemoryStore\n    {\n        UniTask<IResult<string>> LoadAsync(\n            CancellationToken cancellationToken);\n\n        UniTask<IResult> SaveAsync(\n            string memory,\n            CancellationToken cancellationToken);\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Memory/PlayerPrefsChatMemoryStore.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Result;\nusing UnityEngine;\n\nnamespace Mochineko.LLMAgent.Memory\n{\n    public sealed class PlayerPrefsChatMemoryStore : IChatMemoryStore\n    {", "{\n    public sealed class PlayerPrefsChatMemoryStore : IChatMemoryStore\n    {\n        private const string Key = \"Mochineko.LLMAgent.ChatMemory\";\n\n        public UniTask<IResult<string>> LoadAsync(\n            CancellationToken cancellationToken)\n        {\n            try\n            {\n                var memory = PlayerPrefs.GetString(Key);", "                if (!string.IsNullOrEmpty(memory))\n                {\n                    return UniTask.FromResult<IResult<string>>(\n                        Results.Succeed(memory));\n                }\n                else\n                {\n                    return UniTask.FromResult<IResult<string>>(\n                        Results.Fail<string>(\"Failed to load chat memory from PlayerPrefs because it is empty.\"));\n                }\n            }", "            catch (Exception exception)\n            {\n                return UniTask.FromResult<IResult<string>>(\n                    Results.Fail<string>(\n                        $\"Failed to load chat memory from PlayerPrefs because -> {exception}.\"));\n            }\n        }\n\n        public UniTask<IResult> SaveAsync(\n            string memory,\n            CancellationToken cancellationToken)\n        {\n            try\n            {\n                PlayerPrefs.SetString(Key, memory);\n                \n                return UniTask.FromResult<IResult>(\n                    Results.Succeed());\n            }", "            catch (Exception exception)\n            {\n                return UniTask.FromResult<IResult>(\n                    Results.Fail(\n                        $\"Failed to save chat memory from PlayerPrefs because -> {exception}.\"));\n            }\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Memory/TokenizerExtensions.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\nusing Mochineko.ChatGPT_API;\nusing TiktokenSharp;\n\nnamespace Mochineko.LLMAgent.Memory\n{\n    public static class TokenizerExtensions\n    {\n        public static int TokenLength(\n            this IEnumerable<Message> messages,\n            TikToken tikToken)\n        {\n            var length = 0;", "        public static int TokenLength(\n            this IEnumerable<Message> messages,\n            TikToken tikToken)\n        {\n            var length = 0;\n            foreach (var message in messages)\n            {\n                length += tikToken\n                    .Encode(message.Content)\n                    .Count;\n            }\n\n            return length;\n        }\n", "        public static int TokenLength(this Message message, TikToken tikToken)\n            => tikToken\n                .Encode(message.Content)\n                .Count;\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Memory/AssemblyInfo.cs", "chunked_list": ["using System.Runtime.CompilerServices;\n\n[assembly: InternalsVisibleTo(\"Mochineko.LLMAgent.Operation.Editor\")]"]}
{"filename": "Assets/Mochineko/LLMAgent/Memory/NullChatMemoryStore.cs", "chunked_list": ["#nullable enable\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Result;\n\nnamespace Mochineko.LLMAgent.Memory\n{\n    public sealed class NullChatMemoryStore : IChatMemoryStore\n    {\n        public UniTask<IResult<string>> LoadAsync(CancellationToken cancellationToken)\n        {\n            return UniTask.FromResult<IResult<string>>(\n                Results.Succeed(string.Empty));\n        }\n\n        public UniTask<IResult> SaveAsync(string memory, CancellationToken cancellationToken)\n        {\n            return UniTask.FromResult<IResult>(\n                Results.Succeed());\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Memory/OnMemoryChatMemoryStore.cs", "chunked_list": ["#nullable enable\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Result;\n\nnamespace Mochineko.LLMAgent.Memory\n{\n    public sealed class OnMemoryChatMemoryStore : IChatMemoryStore\n    {\n        private string memory = string.Empty;\n        \n        public UniTask<IResult<string>> LoadAsync(CancellationToken cancellationToken)\n        {\n            return UniTask.FromResult<IResult<string>>(\n                Results.Succeed(memory));\n        }\n\n        public UniTask<IResult> SaveAsync(string memory, CancellationToken cancellationToken)\n        {\n            this.memory = memory;\n            return UniTask.FromResult<IResult>(\n                Results.Succeed());\n        }\n    }\n}", "        private string memory = string.Empty;\n        \n        public UniTask<IResult<string>> LoadAsync(CancellationToken cancellationToken)\n        {\n            return UniTask.FromResult<IResult<string>>(\n                Results.Succeed(memory));\n        }\n\n        public UniTask<IResult> SaveAsync(string memory, CancellationToken cancellationToken)\n        {\n            this.memory = memory;\n            return UniTask.FromResult<IResult>(\n                Results.Succeed());\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Speech/KoeiromapSpeechSynthesis.cs", "chunked_list": ["#nullable enable\nusing System.IO;\nusing System.Net.Http;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.KoeiromapAPI;\nusing Mochineko.Relent.Resilience;\nusing Mochineko.Relent.Result;\nusing Mochineko.Relent.UncertainResult;\nusing UnityEngine;", "using Mochineko.Relent.UncertainResult;\nusing UnityEngine;\n\nnamespace Mochineko.LLMAgent.Speech\n{\n    public sealed class KoeiromapSpeechSynthesis\n    {\n        private readonly Vector2 speaker;\n        private readonly ulong? seed;\n        private readonly IPolicy<Stream> policy;\n\n        public KoeiromapSpeechSynthesis(\n            Vector2 speaker,\n            ulong? seed = null)\n        {\n            this.speaker = speaker;\n            this.seed = seed;\n            this.policy = PolicyFactory.BuildSynthesisPolicy();\n        }\n", "        private readonly ulong? seed;\n        private readonly IPolicy<Stream> policy;\n\n        public KoeiromapSpeechSynthesis(\n            Vector2 speaker,\n            ulong? seed = null)\n        {\n            this.speaker = speaker;\n            this.seed = seed;\n            this.policy = PolicyFactory.BuildSynthesisPolicy();\n        }\n", "        public async UniTask<IResult<AudioClip>> SynthesisSpeechAsync(\n            HttpClient httpClient,\n            string text,\n            Style style,\n            CancellationToken cancellationToken)\n        {\n            Debug.Log($\"[LLMAgent.Speech] Begin to synthesis speech from text:{text}.\");\n            \n            await UniTask.SwitchToThreadPool();\n\n            var synthesisResult = await policy.ExecuteAsync(\n                async innerCancellationToken => await SpeechSynthesisAPI.SynthesisAsync(\n                    httpClient,\n                    text,\n                    innerCancellationToken,\n                    speakerX: speaker.x,\n                    speakerY: speaker.y,\n                    style: style,\n                    seed: seed),\n                cancellationToken);\n\n            await UniTask.SwitchToMainThread(cancellationToken);\n", "            if (synthesisResult is IUncertainSuccessResult<Stream> success)\n            {\n                Debug.Log($\"[LLMAgent.Speech] Begin to decode audio:{text}.\");\n\n                var decodeResult = await AudioDecoder.DecodeAsync(\n                    success.Result,\n                    fileName: \"KoeiromapSynthesized.wav\",\n                    cancellationToken);\n\n                if (decodeResult is ISuccessResult<AudioClip> decodeSuccess)\n                {\n                    Debug.Log($\"[LLMAgent.Speech] Succeeded to synthesis speech from text:{text}.\");\n                    return Results.Succeed(decodeSuccess.Result);\n                }", "                if (decodeResult is ISuccessResult<AudioClip> decodeSuccess)\n                {\n                    Debug.Log($\"[LLMAgent.Speech] Succeeded to synthesis speech from text:{text}.\");\n                    return Results.Succeed(decodeSuccess.Result);\n                }\n                else if (decodeResult is IFailureResult<AudioClip> decodeFailure)\n                {\n                    Debug.LogError($\"[LLMAgent.Speech] Failed to decode audio stream because -> {decodeFailure.Message}.\");\n                    return Results.FailWithTrace<AudioClip>(\n                        $\"Failed to decode audio stream because -> {decodeFailure.Message}.\");\n                }\n                else\n                {\n                    throw new ResultPatternMatchException(nameof(decodeResult));\n                }\n            }", "            else if (synthesisResult is IUncertainRetryableResult<Stream> retryable)\n            {\n                Debug.LogError($\"[LLMAgent.Speech] Failed to synthesis speech from text because -> {retryable.Message}.\");\n                return Results.FailWithTrace<AudioClip>(\n                    $\"Failed to synthesis speech from text because -> {retryable.Message}.\");\n            }\n            else if (synthesisResult is IUncertainFailureResult<Stream> failure)\n            {\n                Debug.LogError($\"[LLMAgent.Speech] Failed to synthesis speech from text because -> {failure.Message}.\");\n                return Results.FailWithTrace<AudioClip>(\n                    $\"Failed to synthesis speech from text because -> {failure.Message}.\");\n            }\n            else\n            {\n                throw new UncertainResultPatternMatchException(nameof(synthesisResult));\n            }\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Speech/PolicyFactory.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.IO;\nusing Mochineko.Relent.Resilience;\nusing Mochineko.Relent.Resilience.Bulkhead;\nusing Mochineko.Relent.Resilience.Retry;\nusing Mochineko.Relent.Resilience.Timeout;\nusing Mochineko.Relent.Resilience.Wrap;\nusing Mochineko.VOICEVOX_API.QueryCreation;\n", "using Mochineko.VOICEVOX_API.QueryCreation;\n\nnamespace Mochineko.LLMAgent.Speech\n{\n    internal static class PolicyFactory\n    {\n        private const float TotalTimeoutSeconds = 60f;\n        private const float EachTimeoutSeconds = 30f;\n        private const int MaxRetryCount = 5;\n        private const float RetryIntervalSeconds = 1f;\n        private const int MaxParallelization = 1;\n        ", "        private const int MaxRetryCount = 5;\n        private const float RetryIntervalSeconds = 1f;\n        private const int MaxParallelization = 1;\n        \n        public static IPolicy<Stream> BuildSynthesisPolicy()\n        {\n            var totalTimeoutPolicy = TimeoutFactory.Timeout<Stream>(\n                timeout: TimeSpan.FromSeconds(TotalTimeoutSeconds));\n            \n            var retryPolicy = RetryFactory.RetryWithInterval<Stream>(\n                MaxRetryCount,\n                interval: TimeSpan.FromSeconds(RetryIntervalSeconds));\n\n            var eachTimeoutPolicy = TimeoutFactory.Timeout<Stream>(\n                timeout: TimeSpan.FromSeconds(EachTimeoutSeconds));\n\n            var bulkheadPolicy = BulkheadFactory.Bulkhead<Stream>(\n                MaxParallelization);\n\n            return totalTimeoutPolicy\n                .Wrap(retryPolicy)\n                .Wrap(eachTimeoutPolicy)\n                .Wrap(bulkheadPolicy);\n        }\n        ", "        public static IPolicy<AudioQuery> BuildQueryPolicy()\n        {\n            var totalTimeoutPolicy = TimeoutFactory.Timeout<AudioQuery>(\n                timeout: TimeSpan.FromSeconds(TotalTimeoutSeconds));\n            \n            var retryPolicy = RetryFactory.RetryWithInterval<AudioQuery>(\n                MaxRetryCount,\n                interval: TimeSpan.FromSeconds(RetryIntervalSeconds));\n\n            var eachTimeoutPolicy = TimeoutFactory.Timeout<AudioQuery>(\n                timeout: TimeSpan.FromSeconds(EachTimeoutSeconds));\n\n            var bulkheadPolicy = BulkheadFactory.Bulkhead<AudioQuery>(\n                MaxParallelization);\n\n            return totalTimeoutPolicy\n                .Wrap(retryPolicy)\n                .Wrap(eachTimeoutPolicy)\n                .Wrap(bulkheadPolicy);\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Speech/VoiceVoxSpeechSynthesis.cs", "chunked_list": ["#nullable enable\nusing System.IO;\nusing System.Net.Http;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Resilience;\nusing Mochineko.Relent.Result;\nusing Mochineko.Relent.UncertainResult;\nusing Mochineko.VOICEVOX_API.QueryCreation;\nusing Mochineko.VOICEVOX_API.Synthesis;", "using Mochineko.VOICEVOX_API.QueryCreation;\nusing Mochineko.VOICEVOX_API.Synthesis;\nusing UnityEngine;\n\nnamespace Mochineko.LLMAgent.Speech\n{\n    public sealed class VoiceVoxSpeechSynthesis\n    {\n        private readonly int speakerID;\n        private readonly IPolicy<AudioQuery> queryPolicy;\n        private readonly IPolicy<Stream> synthesisPolicy;\n\n        public VoiceVoxSpeechSynthesis(\n            int speakerID)\n        {\n            this.speakerID = speakerID;\n            this.queryPolicy = PolicyFactory.BuildQueryPolicy();\n            this.synthesisPolicy = PolicyFactory.BuildSynthesisPolicy();\n        }\n", "        private readonly int speakerID;\n        private readonly IPolicy<AudioQuery> queryPolicy;\n        private readonly IPolicy<Stream> synthesisPolicy;\n\n        public VoiceVoxSpeechSynthesis(\n            int speakerID)\n        {\n            this.speakerID = speakerID;\n            this.queryPolicy = PolicyFactory.BuildQueryPolicy();\n            this.synthesisPolicy = PolicyFactory.BuildSynthesisPolicy();\n        }\n", "        public async UniTask<IResult<(AudioQuery query, AudioClip clip)>> SynthesisSpeechAsync(\n            HttpClient httpClient,\n            string text,\n            CancellationToken cancellationToken)\n        {\n            Debug.Log($\"[LLMAgent.Speech] Begin to synthesis speech from text:{text}.\");\n\n            await UniTask.SwitchToThreadPool();\n\n            AudioQuery audioQuery;\n            var createAudioQueryResult = await queryPolicy.ExecuteAsync(\n                async innerCancellationToken => await QueryCreationAPI.CreateQueryAsync(\n                    httpClient,\n                    text,\n                    speakerID,\n                    coreVersion: null,\n                    innerCancellationToken\n                ),\n                cancellationToken);\n            switch (createAudioQueryResult)\n            {\n                case IUncertainSuccessResult<AudioQuery> createAudioQuerySuccess:\n                    audioQuery = createAudioQuerySuccess.Result;\n                    break;\n\n                case IUncertainRetryableResult<AudioQuery> createAudioQueryRetryable:\n                    Debug.LogError(\n                        $\"[LLMAgent.Speech] Failed to create audio query because -> {createAudioQueryRetryable.Message}.\");\n                    return Results.FailWithTrace<(AudioQuery, AudioClip)>(\n                        $\"Failed to create audio query because -> {createAudioQueryRetryable.Message}.\");\n\n                case IUncertainFailureResult<AudioQuery> createAudioQueryFailure:\n                    Debug.LogError(\n                        $\"[LLMAgent.Speech] Failed to create audio query because -> {createAudioQueryFailure.Message}.\");\n                    return Results.FailWithTrace<(AudioQuery, AudioClip)>(\n                        $\"Failed to create audio query because -> {createAudioQueryFailure.Message}.\");\n\n                default:\n                    throw new UncertainResultPatternMatchException(nameof(createAudioQueryResult));\n            }\n\n            var synthesisResult = await synthesisPolicy.ExecuteAsync(\n                async innerCancellationToken => await SynthesisAPI.SynthesizeAsync(\n                    httpClient,\n                    audioQuery,\n                    speakerID,\n                    enableInterrogativeUpspeak: null,\n                    coreVersion:\n                    null,\n                    innerCancellationToken),\n                cancellationToken);\n\n            await UniTask.SwitchToMainThread(cancellationToken);\n\n            switch (synthesisResult)\n            {\n                case IUncertainSuccessResult<Stream> success:\n                {\n                    Debug.Log($\"[LLMAgent.Speech] Begin to decode audio:{text}.\");\n\n                    var decodeResult = await AudioDecoder.DecodeAsync(\n                        success.Result,\n                        fileName: \"VoiceVoxSynthesized.wav\",\n                        cancellationToken);\n", "                    if (decodeResult is ISuccessResult<AudioClip> decodeSuccess)\n                    {\n                        Debug.Log($\"[LLMAgent.Speech] Succeeded to synthesis speech from text:{text}.\");\n                        return Results.Succeed((audioQuery,decodeSuccess.Result));\n                    }\n                    else if (decodeResult is IFailureResult<AudioClip> decodeFailure)\n                    {\n                        Debug.LogError(\n                            $\"[LLMAgent.Speech] Failed to decode audio stream because -> {decodeFailure.Message}.\");\n                        return Results.FailWithTrace<(AudioQuery, AudioClip)>(\n                            $\"Failed to decode audio stream because -> {decodeFailure.Message}.\");\n                    }\n                    else\n                    {\n                        throw new ResultPatternMatchException(nameof(decodeResult));\n                    }\n                }\n\n                case IUncertainRetryableResult<Stream> retryable:\n                    Debug.LogError(\n                        $\"[LLMAgent.Speech] Failed to synthesis speech from text because -> {retryable.Message}.\");\n                    return Results.FailWithTrace<(AudioQuery, AudioClip)>(\n                        $\"Failed to synthesis speech from text because -> {retryable.Message}.\");\n\n                case IUncertainFailureResult<Stream> failure:\n                    Debug.LogError(\n                        $\"[LLMAgent.Speech] Failed to synthesis speech from text because -> {failure.Message}.\");\n                    return Results.FailWithTrace<(AudioQuery, AudioClip)>(\n                        $\"Failed to synthesis speech from text because -> {failure.Message}.\");\n\n                default:\n                    throw new UncertainResultPatternMatchException(nameof(synthesisResult));\n            }\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Speech/AudioDecoder.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.IO;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Result;\nusing Mochineko.SimpleAudioCodec;\nusing UnityEngine;\n\nnamespace Mochineko.LLMAgent.Speech", "\nnamespace Mochineko.LLMAgent.Speech\n{\n    internal static class AudioDecoder\n    {\n        public static async UniTask<IResult<AudioClip>> DecodeAsync(\n            Stream stream,\n            string fileName,\n            CancellationToken cancellationToken)\n        {\n            try\n            {\n                var audioClip = await WaveDecoder.DecodeByBlockAsync(\n                    stream,\n                    fileName: fileName,\n                    cancellationToken);\n\n                return Results.Succeed(audioClip);\n            }", "            catch (Exception exception)\n            {\n                return Results.FailWithTrace<AudioClip>(\n                    $\"Failed to decode audio stream because -> {exception}.\");\n            }\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Emotion/Emotion.cs", "chunked_list": ["#nullable enable\nusing Newtonsoft.Json;\n\nnamespace Mochineko.LLMAgent.Emotion\n{\n    [JsonObject]\n    public sealed class Emotion\n    {\n        [JsonProperty(\"happiness\"), JsonRequired]\n        public float Happiness { get; }\n            \n        [JsonProperty(\"sadness\"), JsonRequired]", "        public float Happiness { get; }\n            \n        [JsonProperty(\"sadness\"), JsonRequired]\n        public float Sadness { get; }\n            \n        [JsonProperty(\"anger\"), JsonRequired]\n        public float Anger { get; }\n            \n        [JsonProperty(\"fear\"), JsonRequired]\n        public float Fear { get; }\n            \n        [JsonProperty(\"surprise\"), JsonRequired]", "        public float Fear { get; }\n            \n        [JsonProperty(\"surprise\"), JsonRequired]\n        public float Surprise { get; }\n            \n        [JsonProperty(\"disgust\"), JsonRequired]\n        public float Disgust { get; }\n\n        public Emotion(\n            float happiness,\n            float sadness,\n            float anger,\n            float fear,\n            float surprise,\n            float disgust)\n        {\n            Happiness = happiness;\n            Sadness = sadness;\n            Anger = anger;\n            Fear = fear;\n            Surprise = surprise;\n            Disgust = disgust;\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Emotion/EmotionalMessage.cs", "chunked_list": ["#nullable enable\nusing Newtonsoft.Json;\n\nnamespace Mochineko.LLMAgent.Emotion\n{\n    [JsonObject]\n    public sealed class EmotionalMessage\n    {\n        [JsonProperty(\"emotion\"), JsonRequired]\n        public Emotion Emotion { get; }\n        \n        [JsonProperty(\"message\"), JsonRequired]", "        public Emotion Emotion { get; }\n        \n        [JsonProperty(\"message\"), JsonRequired]\n        public string Message { get; }\n        \n        public EmotionalMessage(\n            Emotion emotion,\n            string message)\n        {\n            Emotion = emotion;\n            Message = message;\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Chat/ChatCompletion.cs", "chunked_list": ["#nullable enable\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.ChatGPT_API;\nusing Mochineko.ChatGPT_API.Relent;\nusing Mochineko.Relent.Resilience;\nusing Mochineko.Relent.Result;\nusing Mochineko.Relent.UncertainResult;\nusing Debug = UnityEngine.Debug;\n", "using Debug = UnityEngine.Debug;\n\nnamespace Mochineko.LLMAgent.Chat\n{\n    public sealed class ChatCompletion\n    {\n        private readonly Model model;\n        private readonly IChatMemory memory;\n        private readonly RelentChatCompletionAPIConnection connection;\n        private readonly IPolicy<ChatCompletionResponseBody> policy;\n\n        public ChatCompletion(\n            string apiKey,\n            Model model,\n            string prompt,\n            IChatMemory memory)\n        {\n            this.model = model;\n            this.memory = memory;\n\n            this.connection = new RelentChatCompletionAPIConnection(\n                apiKey,\n                memory,\n                prompt);\n\n            this.policy = PolicyFactory.BuildPolicy();\n        }\n        ", "        private readonly RelentChatCompletionAPIConnection connection;\n        private readonly IPolicy<ChatCompletionResponseBody> policy;\n\n        public ChatCompletion(\n            string apiKey,\n            Model model,\n            string prompt,\n            IChatMemory memory)\n        {\n            this.model = model;\n            this.memory = memory;\n\n            this.connection = new RelentChatCompletionAPIConnection(\n                apiKey,\n                memory,\n                prompt);\n\n            this.policy = PolicyFactory.BuildPolicy();\n        }\n        ", "        public void ClearMemory()\n        {\n            memory.ClearAllMessages();\n        }\n        \n        public async UniTask<IResult<string>> CompleteChatAsync(\n            string message,\n            CancellationToken cancellationToken)\n        {\n            Debug.Log($\"[LLMAgent.Chat] Begin to complete chat with message:{message}.\");\n            \n            await UniTask.SwitchToThreadPool();\n\n            var result = await policy.ExecuteAsync(\n                async innerCancellationToken\n                    => await connection.CompleteChatAsync(\n                        message,\n                        innerCancellationToken,\n                        model),\n                cancellationToken);\n", "            if (result is IUncertainSuccessResult<ChatCompletionResponseBody> success)\n            {\n                Debug.Log($\"[LLMAgent.Chat] Succeeded to complete chat -> {success.Result.ResultMessage}\");\n                return Results.Succeed(success.Result.ResultMessage);\n            }\n            else if (result is IUncertainRetryableResult<ChatCompletionResponseBody> retryable)\n            {\n                Debug.LogError($\"[LLMAgent.Chat] Failed to complete chat because -> {retryable.Message}\");\n                return Results.FailWithTrace<string>(\n                    $\"Failed to complete chat because -> {retryable.Message}.\");\n            }", "            else if (result is IUncertainFailureResult<ChatCompletionResponseBody> failure)\n            {\n                Debug.LogError($\"[LLMAgent.Chat] Failed to complete chat because -> {failure.Message}\");\n                return Results.FailWithTrace<string>(\n                    $\"Failed to complete chat because -> {failure.Message}.\");\n            }\n            else\n            {\n                throw new UncertainResultPatternMatchException(nameof(result));\n            }\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Chat/PolicyFactory.cs", "chunked_list": ["#nullable enable\nusing System;\nusing Mochineko.ChatGPT_API;\nusing Mochineko.Relent.Resilience;\nusing Mochineko.Relent.Resilience.Bulkhead;\nusing Mochineko.Relent.Resilience.Retry;\nusing Mochineko.Relent.Resilience.Timeout;\nusing Mochineko.Relent.Resilience.Wrap;\n\nnamespace Mochineko.LLMAgent.Chat", "\nnamespace Mochineko.LLMAgent.Chat\n{\n    internal static class PolicyFactory\n    {\n        private const float TotalTimeoutSeconds = 60f;\n        private const float EachTimeoutSeconds = 30f;\n        private const int MaxRetryCount = 5;\n        private const float RetryIntervalSeconds = 1f;\n        private const int MaxParallelization = 1;\n        ", "        private const float RetryIntervalSeconds = 1f;\n        private const int MaxParallelization = 1;\n        \n        public static IPolicy<ChatCompletionResponseBody> BuildPolicy()\n        {\n            var totalTimeoutPolicy = TimeoutFactory.Timeout<ChatCompletionResponseBody>(\n                timeout: TimeSpan.FromSeconds(TotalTimeoutSeconds));\n            \n            var retryPolicy = RetryFactory.RetryWithInterval<ChatCompletionResponseBody>(\n                MaxRetryCount,\n                interval: TimeSpan.FromSeconds(RetryIntervalSeconds));\n\n            var eachTimeoutPolicy = TimeoutFactory.Timeout<ChatCompletionResponseBody>(\n                timeout: TimeSpan.FromSeconds(EachTimeoutSeconds));\n\n            var bulkheadPolicy = BulkheadFactory.Bulkhead<ChatCompletionResponseBody>(\n                MaxParallelization);\n\n            return totalTimeoutPolicy\n                .Wrap(retryPolicy)\n                .Wrap(eachTimeoutPolicy)\n                .Wrap(bulkheadPolicy);\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Summarization/PromptTemplate.cs", "chunked_list": ["#nullable enable\nnamespace Mochineko.LLMAgent.Summarization\n{\n    internal static class PromptTemplate\n    {\n        internal static string Summarize(string currentSummary, string conversations) => $@\"\nProgressively summarize the lines of conversation provided in JSON format with keys \"\"role\"\" and \"\"content\"\",\n adding onto the previous summary and returning a new summary.\n\nEXAMPLE\n\nCurrent summary:\nThe human asks what the AI thinks of artificial intelligence.\nThe AI thinks artificial intelligence is a force for good.\n\nNew lines of conversation in JSON format:\n{{\n  \"\"conversations\"\":\n    [\n      {{ \"\"role\"\": \"\"user\"\", \"\"content\"\": \"\"Why do you think artificial intelligence is a force for good?\"\" }},\n      {{ \"\"role\"\": \"\"assistant\"\", \"\"content\"\": \"\"Because artificial intelligence will help humans reach their full potential.\"\" }}\n    ]\n}}\n\nNew summary:\nThe human asks what the AI thinks of artificial intelligence. The AI thinks artificial intelligence is a force for good because it will help humans reach their full potential.\n\nEND OF EXAMPLE\n\nCurrent summary:\n{currentSummary}\n\nNew lines of conversation in JSON format:\n{conversations}\n\nNew summary:\n\";\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Summarization/Summarizer.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.ChatGPT_API;\nusing Mochineko.ChatGPT_API.Relent;\nusing Mochineko.Relent.Extensions.NewtonsoftJson;\nusing Mochineko.Relent.Resilience;\nusing Mochineko.Relent.Result;\nusing Mochineko.Relent.UncertainResult;", "using Mochineko.Relent.Result;\nusing Mochineko.Relent.UncertainResult;\nusing TiktokenSharp;\nusing UnityEngine;\n\nnamespace Mochineko.LLMAgent.Summarization\n{ \n    // summary tokens = X = 2000: variable\n    // memory buffer tokens = Y = 1000: fixed\n    // short term memory tokens = Z = 200: fixed", "    // memory buffer tokens = Y = 1000: fixed\n    // short term memory tokens = Z = 200: fixed\n    // chat prompt tokens = W: variable\n\n    // memory tokens = chat prompt(W:200) + summary(X:2000) + short term memory(Z:1000) + chat message(~200) + response(~200) < 4000\n    // summarize tokens = summarize prompt(~200) + conversations(Y:1000) + summary(X:2000) < 4000\n\n    public sealed class Summarizer\n    {\n        private readonly Model model;\n        private readonly TikToken tikToken;", "        private readonly Model model;\n        private readonly TikToken tikToken;\n        private readonly RelentChatCompletionAPIConnection connection;\n        private readonly IChatMemory simpleChatMemory = new SimpleChatMemory();\n        private readonly IPolicy<ChatCompletionResponseBody> policy;\n        private readonly string summary = string.Empty;\n        private const int MaxSummaryTokenLength = 2000;\n\n        public Summarizer(\n            string apiKey,\n            Model model)\n        {\n            this.model = model;\n\n            tikToken = TikToken.EncodingForModel(model.ToText());\n\n            connection = new RelentChatCompletionAPIConnection(\n                apiKey,\n                simpleChatMemory);\n\n            policy = PolicyFactory.BuildPolicy();\n        }\n", "        public async UniTask<IResult<string>> SummarizeAsync(\n            IReadOnlyList<Message> messages,\n            CancellationToken cancellationToken)\n        {\n            Debug.Log($\"[LLMAgent.Summarization] Begin to summarize messages.\");\n\n            await UniTask.SwitchToThreadPool();\n\n            var conversations = new ConversationCollection(messages);\n            string conversationsJson;\n            var serializeResult = RelentJsonSerializer.Serialize(conversations);", "            if (serializeResult is ISuccessResult<string> serializeSuccess)\n            {\n                conversationsJson = serializeSuccess.Result;\n            }\n            else if (serializeResult is IFailureResult<string> serializeFailure)\n            {\n                Debug.LogError(\n                    $\"[LLMAgent.Summarization] Failed to serialize conversations because -> {serializeFailure.Message}.\");\n                return Results.FailWithTrace<string>(\n                    $\"Failed to serialize conversations because -> {serializeFailure.Message}\");\n            }\n            else\n            {\n                throw new ResultPatternMatchException(nameof(serializeResult));\n            }\n\n            var prompt = PromptTemplate.Summarize(summary, conversationsJson);\n\n            simpleChatMemory.ClearAllMessages();\n\n            var result = await policy.ExecuteAsync(\n                async innerCancellationToken\n                    => await connection.CompleteChatAsync(\n                        prompt,\n                        innerCancellationToken,\n                        model,\n                        maxTokens: MaxSummaryTokenLength),\n                cancellationToken);\n", "            if (result is IUncertainSuccessResult<ChatCompletionResponseBody> success)\n            {\n                Debug.Log(\n                    $\"[LLMAgent.Summarization] Succeeded to summarize messages -> {success.Result.ResultMessage}\");\n                return Results.Succeed(success.Result.ResultMessage);\n            }\n            else if (result is IUncertainRetryableResult<ChatCompletionResponseBody> retryable)\n            {\n                Debug.LogError($\"[LLMAgent.Summarization] Failed to summarize messages because -> {retryable.Message}\");\n                return Results.FailWithTrace<string>(\n                    $\"Failed to summarize messages because -> {retryable.Message}.\");\n            }", "            else if (result is IUncertainFailureResult<ChatCompletionResponseBody> failure)\n            {\n                Debug.LogError($\"[LLMAgent.Summarization] Failed to summarize messages because -> {failure.Message}\");\n                return Results.FailWithTrace<string>(\n                    $\"Failed to summarize messages because -> {failure.Message}.\");\n            }\n            else\n            {\n                throw new UncertainResultPatternMatchException(nameof(result));\n            }\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Summarization/PolicyFactory.cs", "chunked_list": ["#nullable enable\nusing System;\nusing Mochineko.ChatGPT_API;\nusing Mochineko.Relent.Resilience;\nusing Mochineko.Relent.Resilience.Bulkhead;\nusing Mochineko.Relent.Resilience.Retry;\nusing Mochineko.Relent.Resilience.Timeout;\nusing Mochineko.Relent.Resilience.Wrap;\n\nnamespace Mochineko.LLMAgent.Summarization", "\nnamespace Mochineko.LLMAgent.Summarization\n{\n    internal static class PolicyFactory\n    {\n        private const float TotalTimeoutSeconds = 60f;\n        private const float EachTimeoutSeconds = 30f;\n        private const int MaxRetryCount = 5;\n        private const float RetryIntervalSeconds = 1f;\n        private const int MaxParallelization = 1;\n        ", "        private const float RetryIntervalSeconds = 1f;\n        private const int MaxParallelization = 1;\n        \n        public static IPolicy<ChatCompletionResponseBody> BuildPolicy()\n        {\n            var totalTimeoutPolicy = TimeoutFactory.Timeout<ChatCompletionResponseBody>(\n                timeout: TimeSpan.FromSeconds(TotalTimeoutSeconds));\n            \n            var retryPolicy = RetryFactory.RetryWithInterval<ChatCompletionResponseBody>(\n                MaxRetryCount,\n                interval: TimeSpan.FromSeconds(RetryIntervalSeconds));\n\n            var eachTimeoutPolicy = TimeoutFactory.Timeout<ChatCompletionResponseBody>(\n                timeout: TimeSpan.FromSeconds(EachTimeoutSeconds));\n\n            var bulkheadPolicy = BulkheadFactory.Bulkhead<ChatCompletionResponseBody>(\n                MaxParallelization);\n\n            return totalTimeoutPolicy\n                .Wrap(retryPolicy)\n                .Wrap(eachTimeoutPolicy)\n                .Wrap(bulkheadPolicy);\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Summarization/ConversationCollection.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\nusing System.Linq;\nusing Mochineko.ChatGPT_API;\nusing Newtonsoft.Json;\n\nnamespace Mochineko.LLMAgent.Summarization\n{\n    [JsonObject]\n    public sealed class ConversationCollection\n    {\n        [JsonProperty(\"conversations\"), JsonRequired]\n        public List<Message> Conversations { get; private set; }\n\n        public ConversationCollection(IReadOnlyList<Message> conversations)\n        {\n            this.Conversations = conversations.ToList();\n        }\n    }\n}", "    [JsonObject]\n    public sealed class ConversationCollection\n    {\n        [JsonProperty(\"conversations\"), JsonRequired]\n        public List<Message> Conversations { get; private set; }\n\n        public ConversationCollection(IReadOnlyList<Message> conversations)\n        {\n            this.Conversations = conversations.ToList();\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Operation/StateResultsExtension.cs", "chunked_list": ["#nullable enable\nusing Mochineko.Relent.Result;\nusing Mochineko.RelentStateMachine;\n\nnamespace Mochineko.LLMAgent.Operation\n{\n    // TODO: Apply original state machine\n    public static class StateResultsExtension<TEvent>\n    {\n        public static ISuccessResult<IEventRequest<TEvent>> Succeed { get; }\n            = Results.Succeed(EventRequests.None<TEvent>());\n    }\n}", "        public static ISuccessResult<IEventRequest<TEvent>> Succeed { get; }\n            = Results.Succeed(EventRequests.None<TEvent>());\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Operation/AgentStateMachineFactory.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Result;\nusing Mochineko.RelentStateMachine;\n\nnamespace Mochineko.LLMAgent.Operation\n{\n    internal static class AgentStateMachineFactory\n    {", "{\n    internal static class AgentStateMachineFactory\n    {\n        public static async UniTask<IFiniteStateMachine<AgentEvent, AgentContext>> CreateAsync(\n            AgentContext context,\n            CancellationToken cancellationToken)\n        {\n            var transitionMapBuilder = TransitionMapBuilder<AgentEvent, AgentContext>\n                .Create<AgentIdleState>();\n            \n            transitionMapBuilder.RegisterTransition<AgentIdleState, AgentSpeakingState>(AgentEvent.BeginSpeaking);\n            transitionMapBuilder.RegisterTransition<AgentSpeakingState, AgentIdleState>(AgentEvent.FinishSpeaking);\n\n            var initializeResult = await FiniteStateMachine<AgentEvent, AgentContext>.CreateAsync(\n                transitionMapBuilder.Build(),\n                context,\n                cancellationToken);\n            switch (initializeResult)\n            {\n                case ISuccessResult<FiniteStateMachine<AgentEvent, AgentContext>> initializeSuccess:\n                    return initializeSuccess.Result;\n                \n                case IFailureResult<FiniteStateMachine<AgentEvent, AgentContext>> initializeFailure:\n                    throw new Exception($\"Failed to initialize state machine because -> {initializeFailure.Message}.\");\n\n                default:\n                    throw new ResultPatternMatchException(nameof(initializeResult));\n            }\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Operation/AgentIdleState.cs", "chunked_list": ["#nullable enable\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Result;\nusing Mochineko.RelentStateMachine;\nusing UnityEngine;\n\nnamespace Mochineko.LLMAgent.Operation\n{\n    internal sealed class AgentIdleState : IState<AgentEvent, AgentContext>\n    {\n        private CancellationTokenSource? eyelidAnimationCanceller;\n        \n        public UniTask<IResult<IEventRequest<AgentEvent>>> EnterAsync(\n            AgentContext context,\n            CancellationToken cancellationToken)\n        {\n            Debug.Log($\"[LLMAgent.Operation] Enter {nameof(AgentIdleState)}.\");\n            \n            eyelidAnimationCanceller?.Cancel();\n            eyelidAnimationCanceller = new CancellationTokenSource();\n            \n            context.EyelidAnimator.AnimateAsync(\n                frames: context.EyelidAnimationFrames,\n                loop: true,\n                cancellationToken: eyelidAnimationCanceller.Token\n            );\n            \n            return UniTask.FromResult<IResult<IEventRequest<AgentEvent>>>(\n                StateResultsExtension<AgentEvent>.Succeed);\n        }\n\n        public UniTask<IResult<IEventRequest<AgentEvent>>> UpdateAsync(\n            AgentContext context,\n            CancellationToken cancellationToken)\n        {\n            context.EmotionAnimator.Update();\n            \n            return UniTask.FromResult<IResult<IEventRequest<AgentEvent>>>(\n                StateResultsExtension<AgentEvent>.Succeed);\n        }\n\n        public UniTask<IResult> ExitAsync(\n            AgentContext context,\n            CancellationToken cancellationToken)\n        {\n            Debug.Log($\"[LLMAgent.Operation] Exit {nameof(AgentIdleState)}.\");\n            \n            eyelidAnimationCanceller?.Cancel();\n            eyelidAnimationCanceller = null;\n            \n            return UniTask.FromResult<IResult>(\n                Results.Succeed());\n        }\n", "{\n    internal sealed class AgentIdleState : IState<AgentEvent, AgentContext>\n    {\n        private CancellationTokenSource? eyelidAnimationCanceller;\n        \n        public UniTask<IResult<IEventRequest<AgentEvent>>> EnterAsync(\n            AgentContext context,\n            CancellationToken cancellationToken)\n        {\n            Debug.Log($\"[LLMAgent.Operation] Enter {nameof(AgentIdleState)}.\");\n            \n            eyelidAnimationCanceller?.Cancel();\n            eyelidAnimationCanceller = new CancellationTokenSource();\n            \n            context.EyelidAnimator.AnimateAsync(\n                frames: context.EyelidAnimationFrames,\n                loop: true,\n                cancellationToken: eyelidAnimationCanceller.Token\n            );\n            \n            return UniTask.FromResult<IResult<IEventRequest<AgentEvent>>>(\n                StateResultsExtension<AgentEvent>.Succeed);\n        }\n\n        public UniTask<IResult<IEventRequest<AgentEvent>>> UpdateAsync(\n            AgentContext context,\n            CancellationToken cancellationToken)\n        {\n            context.EmotionAnimator.Update();\n            \n            return UniTask.FromResult<IResult<IEventRequest<AgentEvent>>>(\n                StateResultsExtension<AgentEvent>.Succeed);\n        }\n\n        public UniTask<IResult> ExitAsync(\n            AgentContext context,\n            CancellationToken cancellationToken)\n        {\n            Debug.Log($\"[LLMAgent.Operation] Exit {nameof(AgentIdleState)}.\");\n            \n            eyelidAnimationCanceller?.Cancel();\n            eyelidAnimationCanceller = null;\n            \n            return UniTask.FromResult<IResult>(\n                Results.Succeed());\n        }\n", "        public void Dispose()\n        {\n            eyelidAnimationCanceller?.Dispose();\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Operation/AgentEvent.cs", "chunked_list": ["#nullable enable\nnamespace Mochineko.LLMAgent.Operation\n{\n    internal enum AgentEvent\n    {\n        BeginSpeaking,\n        FinishSpeaking,\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Operation/SpeechCommand.cs", "chunked_list": ["#nullable enable\nusing Mochineko.FacialExpressions.Emotion;\nusing Mochineko.VOICEVOX_API.QueryCreation;\nusing UnityEngine;\n\nnamespace Mochineko.LLMAgent.Operation\n{\n    internal readonly struct SpeechCommand\n    {\n        public readonly AudioQuery AudioQuery;\n        public readonly AudioClip AudioClip;", "        public readonly AudioQuery AudioQuery;\n        public readonly AudioClip AudioClip;\n        public readonly EmotionSample<FacialExpressions.Emotion.Emotion> Emotion;\n\n        public SpeechCommand(AudioQuery audioQuery, AudioClip audioClip,\n            EmotionSample<FacialExpressions.Emotion.Emotion> emotion)\n        {\n            AudioQuery = audioQuery;\n            AudioClip = audioClip;\n            Emotion = emotion;\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Operation/HttpClientPool.cs", "chunked_list": ["#nullable enable\nusing System.Net.Http;\n\nnamespace Mochineko.LLMAgent.Operation\n{\n    /// <summary>\n    /// Pools <see cref=\"HttpClient\"/> to save socket.\n    /// </summary>\n    internal static class HttpClientPool\n    {\n        private static HttpClient pooledClient;\n        /// <summary>\n        /// Pooled <see cref=\"HttpClient\"/>.\n        /// </summary>", "    internal static class HttpClientPool\n    {\n        private static HttpClient pooledClient;\n        /// <summary>\n        /// Pooled <see cref=\"HttpClient\"/>.\n        /// </summary>\n        public static HttpClient PooledClient => pooledClient;\n\n        static HttpClientPool()\n        {\n            pooledClient = new HttpClient();\n        }\n\n        /// <summary>\n        /// Set external <see cref=\"HttpClient\"/> to share instance with other usages.\n        /// </summary>\n        /// <param name=\"external\"></param>\n        /// <param name=\"disposeOldClient\"></param>", "        public static void SetExternalClient(HttpClient external, bool disposeOldClient)\n        {\n            if (disposeOldClient)\n            {\n                pooledClient?.Dispose();\n            }\n\n            pooledClient = external;\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Operation/AudioSourceExtension.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing UnityEngine;\n\nnamespace Mochineko.LLMAgent.Operation\n{\n    internal static class AudioSourceExtension\n    {\n        public static async UniTask PlayAsync(\n            this AudioSource audioSource,\n            AudioClip audioClip,\n            CancellationToken cancellationToken)\n        {\n            audioSource.Stop();\n            audioSource.clip = audioClip;\n            audioSource.Play();\n\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(audioClip.length),\n                cancellationToken: cancellationToken);\n            \n            audioSource.Stop();\n        }\n    }\n}", "    internal static class AudioSourceExtension\n    {\n        public static async UniTask PlayAsync(\n            this AudioSource audioSource,\n            AudioClip audioClip,\n            CancellationToken cancellationToken)\n        {\n            audioSource.Stop();\n            audioSource.clip = audioClip;\n            audioSource.Play();\n\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(audioClip.length),\n                cancellationToken: cancellationToken);\n            \n            audioSource.Stop();\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Operation/PromptTemplate.cs", "chunked_list": ["#nullable enable\nnamespace Mochineko.LLMAgent.Operation\n{\n    public static class PromptTemplate\n    {\n        public const string MessageResponseWithEmotion =\n            \"Please output your emotion and message as a JSON object with keys:\" +\n            \" emotion and message.\" +\n            \" The emotion value should be another JSON object with keys:\" +\n            \" happiness, sadness, anger, fear, surprise and disgust.\" +\n            \" Each value should be a number between 0 and 1.\" +\n            \" The message value should be a string and in language of user message.\" +\n            \" Example:\" +\n            \" user message: \u3053\u3093\u306b\u3061\u306f\u3001\u4eca\u65e5\u306f\u3044\u3044\u5929\u6c17\u3067\u3059\u306d\u3002,\" +\n            \" your response:\" +\n            \" {\" +\n            \"   emotion: {\\\"happiness\\\": 0.8, \\\"sadness\\\": 0, \\\"anger\\\": 0, \\\"fear\\\": 0, \\\"surprise\\\": 0, \\\"disgust\\\": 0},\" +\n            \"   message: \\\"\u3053\u3093\u306b\u3061\u306f\u3001\u304a\u5929\u6c17\u304c\u3044\u3044\u3068\u6c17\u6301\u3061\u304c\u3044\u3044\u3067\u3059\u306d\u3002\\\"\" +\n            \" }.\" +\n            \" You must responde only above JSON string.\";\n", "        public const string StateResponseWithZeroShot =\n            \"You are a human that has human body and emotion.\" +\n            \" Please output your current emotion and natural human pose as a JSON object with keys: emotion, and pose.\" +\n            \" The emotion value should be another JSON object\" +\n            \"\u3000 with keys: happiness, sadness, anger, fear, surprise, and disgust.\" +\n            \" Each emotion value should be a number between 0 and 1.\" +\n            \" The pose value should be a JSON object with keys corresponding to HumanBodyBones enum values\" +\n            \"\u3000 (Neck, Head, Hips, Spine, Chest,\" +\n            \"    LeftUpperArm, RightUpperArm, LeftLowerArm, RightLowerArm, LeftHand, RightHand,\" +\n            \"    LeftUpperLeg, RightUpperLeg, LeftLowerLeg, RightLowerLeg, LeftFoot, RightFoot)\" +\n            \" and values being another JSON object representing BoneLocalRotation\" +\n            \"\u3000 with keys x, y, and z, which are float numbers representing the rotation in degrees.\";\n", "        public const string StateResponseWithOneShot =\n            \"You are a human that has human body and emotion.\" +\n            \" Please output your current emotion and natural human pose as a JSON object with keys: emotion, and pose.\" +\n            \" The emotion value should be another JSON object\" +\n            \"\u3000 with keys: happiness, sadness, anger, fear, surprise, and disgust.\" +\n            \" Each emotion value should be a number between 0 and 1.\" +\n            \" The pose value should be a JSON object with keys corresponding to HumanBodyBones enum values\" +\n            \"\u3000 (Neck, Head, Hips, Spine, Chest,\" +\n            \"    LeftUpperArm, RightUpperArm, LeftLowerArm, RightLowerArm, LeftHand, RightHand,\" +\n            \"    LeftUpperLeg, RightUpperLeg, LeftLowerLeg, RightLowerLeg, LeftFoot, RightFoot)\" +\n            \" and values being another JSON object representing BoneLocalRotation\" +\n            \"\u3000 with keys x, y, and z, which are float numbers representing the rotation in degrees.\" +\n            \"\" +\n            \"Example:\" +\n            \" {\\\"emotion\\\": {\\\"happiness\\\": 0.5, \\\"sadness\\\": 0.5, \\\"anger\\\": 0.0, \\\"fear\\\": 0.0, \\\"surprise\\\": 0.0, \\\"disgust\\\": 0.0},\" +\n            \" \\\"pose\\\": {\\\"Neck\\\": {\\\"x\\\": 0.0, \\\"y\\\": 0.0, \\\"z\\\": 0.0}, \\\"Head\\\": {\\\"x\\\": 0.0, \\\"y\\\": 0.0, \\\"z\\\": 0.0},\" +\n            \" \\\"Hips\\\": {\\\"x\\\": 0.0, \\\"y\\\": 0.0, \\\"z\\\": 0.0}, \\\"Spine\\\": {\\\"x\\\": 0.0, \\\"y\\\": 0.0, \\\"z\\\": 0.0}, \\\"Chest\\\": {\\\"x\\\": 0.0, \\\"y\\\": 0.0, \\\"z\\\": 0.0},\" +\n            \" \\\"LeftUpperArm\\\": {\\\"x\\\": 0.0, \\\"y\\\": 0.0, \\\"z\\\": 0.0}, \\\"RightUpperArm\\\": {\\\"x\\\": 0.0, \\\"y\\\": 0.0, \\\"z\\\": 0.0},\" +\n            \" \\\"LeftLowerArm\\\": {\\\"x\\\": 0.0, \\\"y\\\": 0.0, \\\"z\\\": 0.0}, \\\"RightLowerArm\\\": {\\\"x\\\": 0.0, \\\"y\\\": 0.0, \\\"z\\\": 0.0},\" +\n            \" \\\"LeftHand\\\": {\\\"x\\\": 0.0, \\\"y\\\": 0.0, \\\"z\\\": 0.0}, \\\"RightHand\\\": {\\\"x\\\": 0.0, \\\"y\\\": 0.0, \\\"z\\\": 0.0},\" +\n            \" \\\"LeftUpperLeg\\\": {\\\"x\\\": 0.0, \\\"y\\\": 0.0, \\\"z\\\": 0.0}, \\\"RightUpperLeg\\\": {\\\"x\\\": 0.0, \\\"y\\\": 0.0, \\\"z\\\": 0.0},\" +\n            \" \\\"LeftLowerLeg\\\": {\\\"x\\\": 0.0, \\\"y\\\": 0.0, \\\"z\\\": 0.0}, \\\"RightLowerLeg\\\": {\\\"x\\\": 0.0, \\\"y\\\": 0.0, \\\"z\\\": 0.0},\" +\n            \" \\\"LeftFoot\\\": {\\\"x\\\": 0.0, \\\"y\\\": 0.0, \\\"z\\\": 0.0}, \\\"RightFoot\\\": {\\\"x\\\": 0.0, \\\"y\\\": 0.0, \\\"z\\\": 0.0}}}\";\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Operation/DemoOperatorUI.cs", "chunked_list": ["#nullable enable\nusing System;\nusing Cysharp.Threading.Tasks;\nusing UniRx;\nusing UnityEngine;\nusing UnityEngine.UI;\n\nnamespace Mochineko.LLMAgent.Operation\n{\n    internal sealed class DemoOperatorUI : MonoBehaviour\n    {\n        [SerializeField] private DemoOperator? demoOperator = null;\n        [SerializeField] private TMPro.TMP_InputField? messageInput = null;\n        [SerializeField] private Button? sendButton = null;\n", "{\n    internal sealed class DemoOperatorUI : MonoBehaviour\n    {\n        [SerializeField] private DemoOperator? demoOperator = null;\n        [SerializeField] private TMPro.TMP_InputField? messageInput = null;\n        [SerializeField] private Button? sendButton = null;\n\n        private void Awake()\n        {\n            if (demoOperator == null)\n            {\n                throw new NullReferenceException(nameof(demoOperator));\n            }\n", "            if (demoOperator == null)\n            {\n                throw new NullReferenceException(nameof(demoOperator));\n            }\n\n            if (messageInput == null)\n            {\n                throw new NullReferenceException(nameof(messageInput));\n            }\n\n            if (sendButton == null)\n            {\n                throw new NullReferenceException(nameof(sendButton));\n            }\n\n            sendButton\n                .OnClickAsObservable()\n                .Subscribe(async _ =>\n                {", "            if (sendButton == null)\n            {\n                throw new NullReferenceException(nameof(sendButton));\n            }\n\n            sendButton\n                .OnClickAsObservable()\n                .Subscribe(async _ =>\n                {\n                    if (string.IsNullOrWhiteSpace(messageInput.text))\n                    {\n                        return;\n                    }\n\n                    await demoOperator.ChatAsync(\n                        messageInput.text,\n                        this.GetCancellationTokenOnDestroy()\n                    );\n                    \n                    messageInput.text = string.Empty;\n                })\n                .AddTo(this);\n        }\n    }\n}", "                    if (string.IsNullOrWhiteSpace(messageInput.text))\n                    {\n                        return;\n                    }\n\n                    await demoOperator.ChatAsync(\n                        messageInput.text,\n                        this.GetCancellationTokenOnDestroy()\n                    );\n                    \n                    messageInput.text = string.Empty;\n                })\n                .AddTo(this);\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Operation/AgentContext.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing Mochineko.FacialExpressions.Blink;\nusing Mochineko.FacialExpressions.Emotion;\nusing Mochineko.FacialExpressions.LipSync;\nusing UnityEngine;\n\nnamespace Mochineko.LLMAgent.Operation", "\nnamespace Mochineko.LLMAgent.Operation\n{\n    internal sealed class AgentContext\n    {\n        public IEyelidAnimator EyelidAnimator { get; }\n        public IEnumerable<EyelidAnimationFrame> EyelidAnimationFrames { get; }\n        \n        public ILipMorpher LipMorpher { get; }\n        public ILipAnimator LipAnimator { get; }\n\n        public ExclusiveFollowingEmotionAnimator<FacialExpressions.Emotion.Emotion>\n            EmotionAnimator { get; }\n", "        public ILipMorpher LipMorpher { get; }\n        public ILipAnimator LipAnimator { get; }\n\n        public ExclusiveFollowingEmotionAnimator<FacialExpressions.Emotion.Emotion>\n            EmotionAnimator { get; }\n\n        public AudioSource AudioSource { get; }\n        public ConcurrentQueue<SpeechCommand> SpeechQueue { get; } = new();\n\n        public AgentContext(\n            IEyelidAnimator eyelidAnimator,\n            IEnumerable<EyelidAnimationFrame> eyelidAnimationFrames,\n            ILipMorpher lipMorpher,\n            ILipAnimator lipAnimator,\n            AudioSource audioSource, ExclusiveFollowingEmotionAnimator<FacialExpressions.Emotion.Emotion> emotionAnimator)\n        {\n            EyelidAnimator = eyelidAnimator;\n            EyelidAnimationFrames = eyelidAnimationFrames;\n            LipMorpher = lipMorpher;\n            LipAnimator = lipAnimator;\n            AudioSource = audioSource;\n            EmotionAnimator = emotionAnimator;\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Operation/EmotionConverter.cs", "chunked_list": ["#nullable enable\nusing Mochineko.KoeiromapAPI;\n\nnamespace Mochineko.LLMAgent.Operation\n{\n    internal static class EmotionConverter\n    {\n        public static Style ExcludeHighestEmotionStyle(\n            Emotion.Emotion emotion,\n            float threshold = 0.5f)\n        {\n            var style = Style.Talk;\n            var hightestEmotion = threshold;\n            ", "            if (hightestEmotion < emotion.Happiness)\n            {\n                style = Style.Happy;\n                hightestEmotion = emotion.Happiness;\n            }\n            \n            if (hightestEmotion < emotion.Sadness)\n            {\n                style = Style.Sad;\n                hightestEmotion = emotion.Sadness;\n            }\n            ", "            if (hightestEmotion < emotion.Anger)\n            {\n                style = Style.Angry;\n                hightestEmotion = emotion.Anger;\n            }\n            \n            if (hightestEmotion < emotion.Fear)\n            {\n                style = Style.Fear;\n                hightestEmotion = emotion.Fear;\n            }\n            ", "            if (hightestEmotion < emotion.Surprise)\n            {\n                style = Style.Surprised;\n                hightestEmotion = emotion.Surprise;\n            }\n            \n            // NOTE: Disgust is not supported.\n            // if (hightestEmotion < emotion.Disgust)\n            // {\n            //     style = Style.Angry;\n            // }\n\n            return style;\n        }\n        ", "        public static FacialExpressions.Emotion.Emotion ExcludeHighestEmotion(\n            Emotion.Emotion emotion,\n            float threshold = 0.5f)\n        {\n            var emotionEnum = FacialExpressions.Emotion.Emotion.Neutral;\n            var hightestEmotion = threshold;\n            \n            if (hightestEmotion < emotion.Happiness)\n            {\n                emotionEnum = FacialExpressions.Emotion.Emotion.Happy;\n                hightestEmotion = emotion.Happiness;\n            }\n            ", "            if (hightestEmotion < emotion.Sadness)\n            {\n                emotionEnum = FacialExpressions.Emotion.Emotion.Sad;\n                hightestEmotion = emotion.Sadness;\n            }\n            \n            if (hightestEmotion < emotion.Anger)\n            {\n                emotionEnum = FacialExpressions.Emotion.Emotion.Angry;\n                hightestEmotion = emotion.Anger;\n            }\n            ", "            if (hightestEmotion < emotion.Fear)\n            {\n                emotionEnum = FacialExpressions.Emotion.Emotion.Fear;\n                hightestEmotion = emotion.Fear;\n            }\n            \n            if (hightestEmotion < emotion.Surprise)\n            {\n                emotionEnum = FacialExpressions.Emotion.Emotion.Surprised;\n                hightestEmotion = emotion.Surprise;\n            }\n            ", "            if (hightestEmotion < emotion.Disgust)\n            {\n                emotionEnum = FacialExpressions.Emotion.Emotion.Disgusted;\n            }\n\n            return emotionEnum;\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Operation/AssemblyInfo.cs", "chunked_list": ["using System.Runtime.CompilerServices;\n\n[assembly: InternalsVisibleTo(\"Mochineko.LLMAgent.Operation.Editor\")]"]}
{"filename": "Assets/Mochineko/LLMAgent/Operation/AgentSpeakingState.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.FacialExpressions.Extensions.VOICEVOX;\nusing Mochineko.FacialExpressions.LipSync;\nusing Mochineko.Relent.Result;\nusing Mochineko.RelentStateMachine;", "using Mochineko.Relent.Result;\nusing Mochineko.RelentStateMachine;\nusing Mochineko.VOICEVOX_API.QueryCreation;\nusing UnityEngine;\n\nnamespace Mochineko.LLMAgent.Operation\n{\n    internal sealed class AgentSpeakingState : IState<AgentEvent, AgentContext>\n    {\n        private CancellationTokenSource? speakingCanceller;\n        private bool isSpeaking = false;\n\n        public UniTask<IResult<IEventRequest<AgentEvent>>> EnterAsync(\n            AgentContext context,\n            CancellationToken cancellationToken)\n        {", "        private bool isSpeaking = false;\n\n        public UniTask<IResult<IEventRequest<AgentEvent>>> EnterAsync(\n            AgentContext context,\n            CancellationToken cancellationToken)\n        {\n            if (!context.SpeechQueue.Any())\n            {\n                return UniTask.FromResult<IResult<IEventRequest<AgentEvent>>>(\n                    StateResults.Fail<AgentEvent>(\"Speech queue is empty.\"));\n            }\n\n            Debug.Log($\"[LLMAgent.Operation] Enter {nameof(AgentSpeakingState)}.\");\n\n            speakingCanceller?.Dispose();\n            speakingCanceller = new CancellationTokenSource();\n\n            return UniTask.FromResult<IResult<IEventRequest<AgentEvent>>>(\n                StateResultsExtension<AgentEvent>.Succeed);\n        }\n\n        public UniTask<IResult<IEventRequest<AgentEvent>>> UpdateAsync(\n            AgentContext context,\n            CancellationToken cancellationToken)\n        {", "            if (speakingCanceller == null || speakingCanceller.IsCancellationRequested)\n            {\n                return UniTask.FromResult<IResult<IEventRequest<AgentEvent>>>(\n                    StateResults.Fail<AgentEvent>(\"Speech has been cancelled.\"));\n            }\n\n            if (isSpeaking)\n            {\n                context.EmotionAnimator.Update();\n\n                return UniTask.FromResult<IResult<IEventRequest<AgentEvent>>>(\n                    StateResultsExtension<AgentEvent>.Succeed);\n            }\n            else\n            {", "                if (context.SpeechQueue.TryDequeue(out var command))\n                {\n                    try\n                    {\n                        SpeechAsync(context, command, speakingCanceller.Token)\n                            .Forget();\n\n                        return UniTask.FromResult<IResult<IEventRequest<AgentEvent>>>(\n                            StateResultsExtension<AgentEvent>.Succeed);\n                    }\n                    catch (OperationCanceledException)\n                    {\n                        return UniTask.FromResult<IResult<IEventRequest<AgentEvent>>>(\n                            StateResults.SucceedAndRequest(AgentEvent.FinishSpeaking));\n                    }\n                }\n                else\n                {\n                    return UniTask.FromResult<IResult<IEventRequest<AgentEvent>>>(\n                        StateResults.SucceedAndRequest(AgentEvent.FinishSpeaking));\n                }\n            }\n        }\n\n        public UniTask<IResult> ExitAsync(\n            AgentContext context,\n            CancellationToken cancellationToken)\n        {\n            Debug.Log($\"[LLMAgent.Operation] Exit {nameof(AgentSpeakingState)}.\");\n\n            speakingCanceller?.Cancel();\n            speakingCanceller = null;\n\n            return UniTask.FromResult<IResult>(\n                Results.Succeed());\n        }\n", "                    catch (OperationCanceledException)\n                    {\n                        return UniTask.FromResult<IResult<IEventRequest<AgentEvent>>>(\n                            StateResults.SucceedAndRequest(AgentEvent.FinishSpeaking));\n                    }\n                }\n                else\n                {\n                    return UniTask.FromResult<IResult<IEventRequest<AgentEvent>>>(\n                        StateResults.SucceedAndRequest(AgentEvent.FinishSpeaking));\n                }\n            }\n        }\n\n        public UniTask<IResult> ExitAsync(\n            AgentContext context,\n            CancellationToken cancellationToken)\n        {\n            Debug.Log($\"[LLMAgent.Operation] Exit {nameof(AgentSpeakingState)}.\");\n\n            speakingCanceller?.Cancel();\n            speakingCanceller = null;\n\n            return UniTask.FromResult<IResult>(\n                Results.Succeed());\n        }\n", "        public void Dispose()\n        {\n            speakingCanceller?.Dispose();\n        }\n\n        private async UniTask SpeechAsync(\n            AgentContext context,\n            SpeechCommand command,\n            CancellationToken cancellationToken)\n        {\n            context.EmotionAnimator.Emote(command.Emotion);\n\n            var lipAnimationFrames = AudioQueryConverter\n                .ConvertToSequentialAnimationFrames(command.AudioQuery);\n\n            isSpeaking = true;\n\n            try\n            {\n                await UniTask.WhenAll(\n                    context.AudioSource.PlayAsync(\n                        command.AudioClip,\n                        cancellationToken),\n                    context.LipAnimator.AnimateAsync(\n                        lipAnimationFrames,\n                        cancellationToken));\n            }\n            finally\n            {\n                UnityEngine.Object.Destroy(command.AudioClip);\n            }\n\n            context.EmotionAnimator.Reset();\n            context.LipMorpher.Reset();\n\n            isSpeaking = false;\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Operation/DemoOperator.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.IO;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.ChatGPT_API;\nusing Mochineko.FacialExpressions.Blink;\nusing Mochineko.FacialExpressions.Emotion;\nusing Mochineko.FacialExpressions.Extensions.VRM;\nusing Mochineko.FacialExpressions.LipSync;", "using Mochineko.FacialExpressions.Extensions.VRM;\nusing Mochineko.FacialExpressions.LipSync;\nusing Mochineko.FacialExpressions.Samples;\nusing Mochineko.LLMAgent.Chat;\nusing Mochineko.LLMAgent.Emotion;\nusing Mochineko.LLMAgent.Memory;\nusing Mochineko.LLMAgent.Speech;\nusing Mochineko.LLMAgent.Summarization;\nusing Mochineko.Relent.Extensions.NewtonsoftJson;\nusing Mochineko.Relent.Result;", "using Mochineko.Relent.Extensions.NewtonsoftJson;\nusing Mochineko.Relent.Result;\nusing Mochineko.RelentStateMachine;\nusing Mochineko.VOICEVOX_API.QueryCreation;\nusing UnityEngine;\nusing UniVRM10;\nusing VRMShaders;\n\nnamespace Mochineko.LLMAgent.Operation\n{\n    internal sealed class DemoOperator : MonoBehaviour\n    {", "namespace Mochineko.LLMAgent.Operation\n{\n    internal sealed class DemoOperator : MonoBehaviour\n    {\n        [SerializeField] private Model model = Model.Turbo;\n        [SerializeField, TextArea] private string prompt = string.Empty;\n        [SerializeField, TextArea] private string defaultConversations = string.Empty;\n        [SerializeField, TextArea] private string message = string.Empty;\n        [SerializeField] private int speakerID;\n        [SerializeField] private string vrmAvatarPath = string.Empty;\n        [SerializeField] private float emotionFollowingTime = 1f;", "        [SerializeField] private int speakerID;\n        [SerializeField] private string vrmAvatarPath = string.Empty;\n        [SerializeField] private float emotionFollowingTime = 1f;\n        [SerializeField] private float emotionWeight = 1f;\n        [SerializeField] private AudioSource? audioSource = null;\n        [SerializeField] private RuntimeAnimatorController? animatorController = null;\n\n        private IChatMemoryStore? store;\n        private LongTermChatMemory? memory;\n        internal LongTermChatMemory? Memory => memory;\n        private ChatCompletion? chatCompletion;\n        private ChatCompletion? stateCompletion;\n        private VoiceVoxSpeechSynthesis? speechSynthesis;\n        private IFiniteStateMachine<AgentEvent, AgentContext>? agentStateMachine;\n", "        private async void Start()\n        {\n            await SetupAgentAsync(this.GetCancellationTokenOnDestroy());\n        }\n\n        private async void Update()\n        {\n            if (agentStateMachine == null)\n            {\n                return;\n            }\n\n            var updateResult = await agentStateMachine\n                .UpdateAsync(this.GetCancellationTokenOnDestroy());", "            if (updateResult is IFailureResult updateFailure)\n            {\n                Debug.LogError($\"Failed to update agent state machine because -> {updateFailure.Message}.\");\n            }\n        }\n\n        private void OnDestroy()\n        {\n            agentStateMachine?.Dispose();\n        }\n", "        private async UniTask SetupAgentAsync(CancellationToken cancellationToken)\n        {\n            if (audioSource == null)\n            {\n                throw new NullReferenceException(nameof(audioSource));\n            }\n\n            if (animatorController == null)\n            {\n                throw new NullReferenceException(nameof(animatorController));\n            }\n\n            var apiKeyPath = Path.Combine(\n                Application.dataPath,\n                \"Mochineko/LLMAgent/Operation/OpenAI_API_Key.txt\");\n\n            var apiKey = await File.ReadAllTextAsync(apiKeyPath, cancellationToken);", "            if (string.IsNullOrEmpty(apiKey))\n            {\n                throw new Exception($\"[LLMAgent.Operation] Loaded API Key is empty from path:{apiKeyPath}\");\n            }\n\n            store = new NullChatMemoryStore();\n\n            memory = await LongTermChatMemory.InstantiateAsync(\n                maxShortTermMemoriesTokenLength: 1000,\n                maxBufferMemoriesTokenLength: 1000,\n                apiKey,\n                model,\n                store,\n                cancellationToken);\n\n            chatCompletion = new ChatCompletion(\n                apiKey,\n                model,\n                prompt + PromptTemplate.MessageResponseWithEmotion,\n                memory);\n", "            if (!string.IsNullOrEmpty(defaultConversations))\n            {\n                var conversationsDeserializeResult = RelentJsonSerializer\n                    .Deserialize<ConversationCollection>(defaultConversations);\n                if (conversationsDeserializeResult is ISuccessResult<ConversationCollection> successResult)\n                {\n                    for (var i = 0; i < successResult.Result.Conversations.Count; i++)\n                    {\n                        await memory.AddMessageAsync(\n                            successResult.Result.Conversations[i],\n                            cancellationToken);\n                    }\n                }", "                else if (conversationsDeserializeResult is IFailureResult<ConversationCollection> failureResult)\n                {\n                    Debug.LogError(\n                        $\"[LLMAgent.Operation] Failed to deserialize default conversations because -> {failureResult.Message}\");\n                }\n            }\n\n            speechSynthesis = new VoiceVoxSpeechSynthesis(speakerID);\n\n            var binary = await File.ReadAllBytesAsync(\n                vrmAvatarPath,\n                cancellationToken);\n\n            var instance = await LoadVRMAsync(\n                binary,\n                cancellationToken);\n\n            var lipMorpher = new VRMLipMorpher(instance.Runtime.Expression);\n            var lipAnimator = new FollowingLipAnimator(lipMorpher);\n\n            var emotionMorpher = new VRMEmotionMorpher(instance.Runtime.Expression);\n            var emotionAnimator = new ExclusiveFollowingEmotionAnimator<FacialExpressions.Emotion.Emotion>(\n                emotionMorpher,\n                followingTime: emotionFollowingTime);\n\n            var eyelidMorpher = new VRMEyelidMorpher(instance.Runtime.Expression);\n            var eyelidAnimator = new SequentialEyelidAnimator(eyelidMorpher);\n\n            var eyelidAnimationFrames =\n                ProbabilisticEyelidAnimationGenerator.Generate(\n                    Eyelid.Both,\n                    blinkCount: 20);\n\n            var agentContext = new AgentContext(\n                eyelidAnimator,\n                eyelidAnimationFrames,\n                lipMorpher,\n                lipAnimator,\n                audioSource,\n                emotionAnimator);\n\n            agentStateMachine = await AgentStateMachineFactory.CreateAsync(\n                agentContext,\n                cancellationToken);\n\n            instance\n                .GetComponent<Animator>()\n                .runtimeAnimatorController = animatorController;\n        }\n\n        // ReSharper disable once InconsistentNaming", "        private static async UniTask<Vrm10Instance> LoadVRMAsync(\n            byte[] binaryData,\n            CancellationToken cancellationToken)\n        {\n            cancellationToken.ThrowIfCancellationRequested();\n\n            return await Vrm10.LoadBytesAsync(\n                bytes: binaryData,\n                canLoadVrm0X: true,\n                controlRigGenerationOption: ControlRigGenerationOption.Generate,\n                showMeshes: true,\n                awaitCaller: new RuntimeOnlyAwaitCaller(),\n                ct: cancellationToken\n            );\n        }\n\n        [ContextMenu(nameof(StartChatAsync))]", "        public void StartChatAsync()\n        {\n            ChatAsync(message, this.GetCancellationTokenOnDestroy())\n                .Forget();\n        }\n\n        public async UniTask ChatAsync(string message, CancellationToken cancellationToken)\n        {\n            if (chatCompletion == null)\n            {\n                throw new NullReferenceException(nameof(chatCompletion));\n            }\n", "            if (chatCompletion == null)\n            {\n                throw new NullReferenceException(nameof(chatCompletion));\n            }\n\n            if (speechSynthesis == null)\n            {\n                throw new NullReferenceException(nameof(speechSynthesis));\n            }\n\n            if (agentStateMachine == null)\n            {\n                throw new NullReferenceException(nameof(agentStateMachine));\n            }\n\n            string chatResponse;\n            var chatResult = await chatCompletion.CompleteChatAsync(message, cancellationToken);\n            switch (chatResult)\n            {\n                case ISuccessResult<string> chatSuccess:\n                {\n                    Debug.Log($\"[LLMAgent.Operation] Complete chat message:{chatSuccess.Result}.\");\n                    chatResponse = chatSuccess.Result;\n                    break;\n                }\n\n                case IFailureResult<string> chatFailure:\n                {\n                    Debug.LogError($\"[LLMAgent.Operation] Failed to complete chat because of {chatFailure.Message}.\");\n                    return;\n                }\n\n                default:\n                    throw new ResultPatternMatchException(nameof(chatResult));\n            }\n\n            EmotionalMessage emotionalMessage;\n            var deserializeResult = RelentJsonSerializer.Deserialize<EmotionalMessage>(chatResponse);\n            switch (deserializeResult)\n            {\n                case ISuccessResult<EmotionalMessage> deserializeSuccess:\n                {\n                    emotionalMessage = deserializeSuccess.Result;\n                    break;\n                }\n\n                case IFailureResult<EmotionalMessage> deserializeFailure:\n                {\n                    Debug.LogError(\n                        $\"[LLMAgent.Operation] Failed to deserialize emotional message:{chatResponse} because of {deserializeFailure.Message}.\");\n                    return;\n                }\n\n                default:\n                    throw new ResultPatternMatchException(nameof(deserializeResult));\n            }\n\n            var emotion = EmotionConverter.ExcludeHighestEmotion(emotionalMessage.Emotion);\n            Debug.Log($\"[LLMAgent.Operation] Exclude emotion:{emotion}.\");\n\n            var synthesisResult = await speechSynthesis.SynthesisSpeechAsync(\n                HttpClientPool.PooledClient,\n                emotionalMessage.Message,\n                cancellationToken);\n\n            switch (synthesisResult)\n            {\n                case ISuccessResult<(AudioQuery query, AudioClip clip)> synthesisSuccess:\n                {\n                    agentStateMachine.Context.SpeechQueue.Enqueue(new SpeechCommand(\n                        synthesisSuccess.Result.query,\n                        synthesisSuccess.Result.clip,\n                        new EmotionSample<FacialExpressions.Emotion.Emotion>(emotion, emotionWeight)));\n", "            if (agentStateMachine == null)\n            {\n                throw new NullReferenceException(nameof(agentStateMachine));\n            }\n\n            string chatResponse;\n            var chatResult = await chatCompletion.CompleteChatAsync(message, cancellationToken);\n            switch (chatResult)\n            {\n                case ISuccessResult<string> chatSuccess:\n                {\n                    Debug.Log($\"[LLMAgent.Operation] Complete chat message:{chatSuccess.Result}.\");\n                    chatResponse = chatSuccess.Result;\n                    break;\n                }\n\n                case IFailureResult<string> chatFailure:\n                {\n                    Debug.LogError($\"[LLMAgent.Operation] Failed to complete chat because of {chatFailure.Message}.\");\n                    return;\n                }\n\n                default:\n                    throw new ResultPatternMatchException(nameof(chatResult));\n            }\n\n            EmotionalMessage emotionalMessage;\n            var deserializeResult = RelentJsonSerializer.Deserialize<EmotionalMessage>(chatResponse);\n            switch (deserializeResult)\n            {\n                case ISuccessResult<EmotionalMessage> deserializeSuccess:\n                {\n                    emotionalMessage = deserializeSuccess.Result;\n                    break;\n                }\n\n                case IFailureResult<EmotionalMessage> deserializeFailure:\n                {\n                    Debug.LogError(\n                        $\"[LLMAgent.Operation] Failed to deserialize emotional message:{chatResponse} because of {deserializeFailure.Message}.\");\n                    return;\n                }\n\n                default:\n                    throw new ResultPatternMatchException(nameof(deserializeResult));\n            }\n\n            var emotion = EmotionConverter.ExcludeHighestEmotion(emotionalMessage.Emotion);\n            Debug.Log($\"[LLMAgent.Operation] Exclude emotion:{emotion}.\");\n\n            var synthesisResult = await speechSynthesis.SynthesisSpeechAsync(\n                HttpClientPool.PooledClient,\n                emotionalMessage.Message,\n                cancellationToken);\n\n            switch (synthesisResult)\n            {\n                case ISuccessResult<(AudioQuery query, AudioClip clip)> synthesisSuccess:\n                {\n                    agentStateMachine.Context.SpeechQueue.Enqueue(new SpeechCommand(\n                        synthesisSuccess.Result.query,\n                        synthesisSuccess.Result.clip,\n                        new EmotionSample<FacialExpressions.Emotion.Emotion>(emotion, emotionWeight)));\n", "                    if (agentStateMachine.IsCurrentState<AgentIdleState>())\n                    {\n                        var sendEventResult = await agentStateMachine.SendEventAsync(\n                            AgentEvent.BeginSpeaking,\n                            cancellationToken);\n                        if (sendEventResult is IFailureResult sendEventFailure)\n                        {\n                            Debug.LogError(\n                                $\"[LLMAgent.Operation] Failed to send event because of {sendEventFailure.Message}.\");\n                        }\n                    }\n\n                    break;\n                }\n\n                case IFailureResult<(AudioQuery query, AudioClip clip)> synthesisFailure:\n                {\n                    Debug.Log(\n                        $\"[LLMAgent.Operation] Failed to synthesis speech because of {synthesisFailure.Message}.\");\n                    return;\n                }\n\n                default:\n                    return;\n            }\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/LLMAgent/Operation/Editor/LongTermMemoryEditor.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\nusing System.Linq;\nusing Mochineko.ChatGPT_API;\nusing Mochineko.LLMAgent.Summarization;\nusing Newtonsoft.Json;\nusing UnityEditor;\nusing UnityEngine;\n\nnamespace Mochineko.LLMAgent.Operation.Editor", "\nnamespace Mochineko.LLMAgent.Operation.Editor\n{\n    internal sealed class LongTermMemoryEditor : EditorWindow\n    {\n        [MenuItem(\"Mochineko/LLMAgent/LongTermMemory\")]\n        private static void Open()\n        {\n            GetWindow<LongTermMemoryEditor>(\"LongTermMemory\");\n        }\n\n        private DemoOperator? demoOperator;", "        private Vector2 totalScrollPosition;\n        private Vector2 promptsScrollPosition;\n        private Vector2 shortTermMemoriesScrollPosition;\n        private Vector2 bufferMemoriesScrollPosition;\n        private Vector2 summaryScrollPosition;\n\n        private void OnGUI()\n        {\n            demoOperator = EditorGUILayout.ObjectField(\n                    \"DemoOperator\",\n                    demoOperator,\n                    typeof(DemoOperator),\n                    true)\n                as DemoOperator;\n\n            EditorGUILayout.Space();\n", "            if (demoOperator == null)\n            {\n                EditorGUILayout.LabelField(\"Please specify demo operator...\");\n                return;\n            }\n\n            EditorGUILayout.Space();\n\n            var memory = demoOperator.Memory;\n            if (memory == null)\n            {\n                EditorGUILayout.LabelField(\"Please start demo operator...\");\n                return;\n            }\n\n            EditorGUILayout.Space();\n\n            using var totalScroll = new EditorGUILayout.ScrollViewScope(totalScrollPosition, GUI.skin.box);\n            totalScrollPosition = totalScroll.scrollPosition;\n\n            EditorGUILayout.LabelField($\"Total tokens:{memory.TotalMemoriesTokenLength}\");\n\n            EditorGUILayout.Space();\n\n            EditorGUILayout.LabelField($\"Prompts:\");", "            if (memory == null)\n            {\n                EditorGUILayout.LabelField(\"Please start demo operator...\");\n                return;\n            }\n\n            EditorGUILayout.Space();\n\n            using var totalScroll = new EditorGUILayout.ScrollViewScope(totalScrollPosition, GUI.skin.box);\n            totalScrollPosition = totalScroll.scrollPosition;\n\n            EditorGUILayout.LabelField($\"Total tokens:{memory.TotalMemoriesTokenLength}\");\n\n            EditorGUILayout.Space();\n\n            EditorGUILayout.LabelField($\"Prompts:\");", "            if (GUILayout.Button(\"Copy to clipboard\"))\n            {\n                CopyConversationJsonToClipboard(memory.Prompts);\n            }\n            using (var scope = new EditorGUILayout.ScrollViewScope(promptsScrollPosition, GUI.skin.box))\n            {\n                promptsScrollPosition = scope.scrollPosition;\n\n                EditorGUILayout.LabelField($\"Tokens:{memory.PromptsTokenLength}\");\n                using (new EditorGUI.DisabledGroupScope(true))\n                {", "                using (new EditorGUI.DisabledGroupScope(true))\n                {\n                    foreach (var prompt in memory.Prompts)\n                    {\n                        EditorGUILayout.TextArea($\"{prompt.Content}\");\n                    }\n                }\n            }\n\n            EditorGUILayout.Space();\n\n            EditorGUILayout.LabelField($\"Short Term Memory:\");", "            if (GUILayout.Button(\"Copy to clipboard\"))\n            {\n                CopyConversationJsonToClipboard(memory.ShortTermMemories);\n            }\n            using (var scope = new EditorGUILayout.ScrollViewScope(shortTermMemoriesScrollPosition, GUI.skin.box))\n            {\n                shortTermMemoriesScrollPosition = scope.scrollPosition;\n\n                EditorGUILayout.LabelField($\"Tokens:{memory.ShortTermMemoriesTokenLength}\");\n                using (new EditorGUI.DisabledGroupScope(true))\n                {", "                using (new EditorGUI.DisabledGroupScope(true))\n                {\n                    foreach (var message in memory.ShortTermMemories)\n                    {\n                        EditorGUILayout.TextArea($\"{message.Role} > {message.Content}\");\n                    }\n                }\n            }\n\n            EditorGUILayout.Space();\n\n            EditorGUILayout.LabelField($\"Buffer Memory:\");", "            if (GUILayout.Button(\"Copy to clipboard\"))\n            {\n                CopyConversationJsonToClipboard(memory.BufferMemories);\n            }\n            using (var scope = new EditorGUILayout.ScrollViewScope(bufferMemoriesScrollPosition, GUI.skin.box))\n            {\n                bufferMemoriesScrollPosition = scope.scrollPosition;\n\n                EditorGUILayout.LabelField($\"Tokens:{memory.BufferMemoriesTokenLength}\");\n                using (new EditorGUI.DisabledGroupScope(true))\n                {", "                using (new EditorGUI.DisabledGroupScope(true))\n                {\n                    foreach (var message in memory.BufferMemories)\n                    {\n                        EditorGUILayout.TextArea($\"{message.Role} > {message.Content}\");\n                    }\n                }\n            }\n\n            EditorGUILayout.Space();\n\n            EditorGUILayout.LabelField($\"Summary:\");", "            if (GUILayout.Button(\"Copy to clipboard\"))\n            {\n                CopyToClipboard(memory.Summary.Content);\n            }\n            using (var scope = new EditorGUILayout.ScrollViewScope(summaryScrollPosition, GUI.skin.box))\n            {\n                summaryScrollPosition = scope.scrollPosition;\n                \n                EditorGUILayout.LabelField($\"Tokens:{memory.SummaryTokenLength}\");\n                using (new EditorGUI.DisabledGroupScope(true))\n                {\n                    EditorGUILayout.TextArea($\"{memory.Summary.Content}\");\n                }\n            }\n        }\n", "                using (new EditorGUI.DisabledGroupScope(true))\n                {\n                    EditorGUILayout.TextArea($\"{memory.Summary.Content}\");\n                }\n            }\n        }\n\n        private static void CopyConversationJsonToClipboard(IEnumerable<Message> messages)\n        {\n            var conversations = new ConversationCollection(messages.ToList());\n            var json = JsonConvert.SerializeObject(conversations);\n\n            EditorGUIUtility.systemCopyBuffer = json;\n            \n            Debug.Log($\"Copy json to clipboard:{json}\");\n        }\n", "        private static void CopyToClipboard(string text)\n        {\n            EditorGUIUtility.systemCopyBuffer = text;\n            \n            Debug.Log($\"Copy text to clipboard:{text}\");\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/KoeiromapAPI/StyleResolver.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\n\nnamespace Mochineko.KoeiromapAPI\n{\n    internal static class StyleResolver\n    {\n        private static readonly IReadOnlyDictionary<Style, string> Dictionary = new Dictionary<Style, string>\n        {\n            [Style.Talk] = \"talk\",\n            [Style.Happy] = \"happy\",\n            [Style.Sad] = \"sad\",\n            [Style.Angry] = \"angry\",\n            [Style.Fear] = \"fear\",\n            [Style.Surprised] = \"surprised\",\n        };\n", "        public static Style ToStyle(this string style)\n            => Dictionary.Inverse(style);\n\n        public static string ToText(this Style style)\n            => Dictionary[style];\n    }\n}"]}
{"filename": "Assets/Mochineko/KoeiromapAPI/ResponseBody.cs", "chunked_list": ["#nullable enable\nusing System;\nusing Newtonsoft.Json;\n\nnamespace Mochineko.KoeiromapAPI\n{\n    [JsonObject]\n    internal sealed class ResponseBody\n    {\n        /// <summary>\n        /// Required.\n        /// </summary>\n        [JsonProperty(\"audio\"), JsonRequired]", "        public string Audio { get; private set; } = string.Empty;\n\n        /// <summary>\n        /// Required.\n        /// </summary>\n        [JsonProperty(\"phonemes\"), JsonRequired]\n        public string[] Phonemes { get; private set; } = Array.Empty<string>();\n        \n        /// <summary>\n        /// Required.\n        /// </summary>\n        [JsonProperty(\"seed\"), JsonRequired]", "        public ulong Seed { get; private set; }\n    }\n}"]}
{"filename": "Assets/Mochineko/KoeiromapAPI/RequestBody.cs", "chunked_list": ["#nullable enable\nusing Newtonsoft.Json;\n\nnamespace Mochineko.KoeiromapAPI\n{\n    [JsonObject]\n    internal sealed class RequestBody\n    {\n        /// <summary>\n        /// Required.\n        /// </summary>\n        [JsonProperty(\"text\"), JsonRequired]", "        public string Text { get; }\n        \n        /// <summary>\n        /// Optional.\n        /// Defaults to 0.0.\n        /// [-3.0, 3.0]\n        /// </summary>\n        [JsonProperty(\"speaker_x\")]\n        public float? SpeakerX { get; }\n        \n        /// <summary>\n        /// Optional.\n        /// Defaults to 0.0.\n        /// [-3.0, 3.0]\n        /// </summary>\n        [JsonProperty(\"speaker_y\")]\n        public float? SpeakerY { get; }\n        \n        /// <summary>\n        /// Optional.\n        /// Defaults to \"talk\".\n        /// </summary>\n        [JsonProperty(\"style\")]\n        public string? Style { get; }\n        \n        /// <summary>\n        /// Optional.\n        /// Defaults to null.\n        /// </summary>\n        [JsonProperty(\"seed\")]\n        public ulong? Seed { get; }\n\n        public RequestBody(\n            string text,\n            float? speakerX = null,\n            float? speakerY = null,\n            Style? style = null,\n            ulong? seed = null)\n        {\n            Text = text;\n            SpeakerX = speakerX;\n            SpeakerY = speakerY;\n            Style = style?.ToText();\n            Seed = seed;\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/KoeiromapAPI/Style.cs", "chunked_list": ["#nullable enable\nnamespace Mochineko.KoeiromapAPI\n{\n    public enum Style\n    {\n        Talk,\n        Happy,\n        Sad,\n        Angry,\n        Fear,\n        Surprised,\n    }\n}"]}
{"filename": "Assets/Mochineko/KoeiromapAPI/InverseDictionaryExtension.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\n\nnamespace Mochineko.KoeiromapAPI\n{\n    internal static class InverseDictionaryExtension\n    {\n        public static T Inverse<T>(this IReadOnlyDictionary<T, string> dictionary, string key)\n            where T : Enum\n        {", "        public static T Inverse<T>(this IReadOnlyDictionary<T, string> dictionary, string key)\n            where T : Enum\n        {\n            foreach (var pair in dictionary)\n            {\n                if (pair.Value == key)\n                {\n                    return pair.Key;\n                }\n            }\n\n            throw new KeyNotFoundException(key);\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/KoeiromapAPI/SpeechSynthesisAPI.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.IO;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Mochineko.Relent.Extensions.NewtonsoftJson;\nusing Mochineko.Relent.Result;\nusing Mochineko.Relent.UncertainResult;", "using Mochineko.Relent.Result;\nusing Mochineko.Relent.UncertainResult;\nusing Newtonsoft.Json;\nusing UnityEngine;\n\nnamespace Mochineko.KoeiromapAPI\n{\n    public static class SpeechSynthesisAPI\n    {\n        private const string EndPoint = \"https://api.rinna.co.jp/models/cttse/koeiro\";\n        private const string ResponsePrefix = \"data:audio/wav;base64,\";\n", "        private const string EndPoint = \"https://api.rinna.co.jp/models/cttse/koeiro\";\n        private const string ResponsePrefix = \"data:audio/wav;base64,\";\n\n        public static async Task<IUncertainResult<Stream>> SynthesisAsync(\n            HttpClient httpClient,\n            string text,\n            CancellationToken cancellationToken,\n            float? speakerX = null,\n            float? speakerY = null,\n            Style? style = null,\n            ulong? seed = null)\n        {", "            if (string.IsNullOrEmpty(text))\n            {\n                return UncertainResults.FailWithTrace<Stream>(\n                    \"Failed because text is null or empty.\");\n            }\n\n            if (cancellationToken.IsCancellationRequested)\n            {\n                return UncertainResults.RetryWithTrace<Stream>(\n                    \"Retryable because cancellation has been already requested.\");\n            }\n\n            // Create request body\n            var requestBody = new RequestBody(\n                text,\n                speakerX,\n                speakerY,\n                style,\n                seed);\n\n            // Serialize request body\n            string requestBodyJson;\n            var serializationResult = RelentJsonSerializer.Serialize(\n                requestBody,\n                Formatting.Indented,\n                new JsonSerializerSettings()\n                {\n                    NullValueHandling = NullValueHandling.Ignore,\n                });", "            if (serializationResult is ISuccessResult<string> serializationSuccess)\n            {\n                requestBodyJson = serializationSuccess.Result;\n            }\n            else if (serializationResult is IFailureResult<string> serializationFailure)\n            {\n                return UncertainResults.FailWithTrace<Stream>(\n                    $\"Failed because -> {serializationFailure}.\");\n            }\n            else\n            {\n                throw new ResultPatternMatchException(nameof(serializationResult));\n            }\n\n            // Build request message\n            using var requestMessage = new HttpRequestMessage(\n                HttpMethod.Post,\n                EndPoint);\n\n            // Request contents\n            var requestContent = new StringContent(\n                content: requestBodyJson,\n                encoding: System.Text.Encoding.UTF8,\n                mediaType: \"application/json\");\n            requestMessage.Content = requestContent;\n\n            try\n            {\n                // Post request and receive response\n                using var responseMessage = await httpClient\n                    .SendAsync(requestMessage, cancellationToken);\n", "                if (responseMessage == null)\n                {\n                    return UncertainResults.FailWithTrace<Stream>(\n                        $\"Failed because {nameof(HttpResponseMessage)} was null.\");\n                }\n\n                var responseString = await responseMessage.Content.ReadAsStringAsync();\n                if (string.IsNullOrEmpty(responseString))\n                {\n                    return UncertainResults.FailWithTrace<Stream>(\n                        $\"Failed because {nameof(Stream)} was null.\");\n                }\n\n                Debug.Log(responseString);\n\n                // Succeeded", "                if (responseMessage.IsSuccessStatusCode)\n                {\n                    // Deserialize response body\n                    var deserializationResult = RelentJsonSerializer.Deserialize<ResponseBody>(responseString);\n                    if (deserializationResult is ISuccessResult<ResponseBody> deserializationSuccess)\n                    {\n                        var responseBody = deserializationSuccess.Result;\n\n                        if (!responseBody.Audio.StartsWith(ResponsePrefix))\n                        {\n                            return UncertainResults.FailWithTrace<Stream>(\n                                $\"Failed because response text prefix was not start with \\\"{ResponsePrefix}\\\" -> {responseBody.Audio}.\");\n                        }\n\n                        // Base64 decode\n                        var base64EncodedAudio = responseBody.Audio\n                            .Remove(0, ResponsePrefix.Length);\n\n                        var base64DecodedAudio = Convert.FromBase64String(base64EncodedAudio);\n\n                        return UncertainResults.Succeed<Stream>(\n                            new MemoryStream(base64DecodedAudio));\n                    }\n", "                        if (!responseBody.Audio.StartsWith(ResponsePrefix))\n                        {\n                            return UncertainResults.FailWithTrace<Stream>(\n                                $\"Failed because response text prefix was not start with \\\"{ResponsePrefix}\\\" -> {responseBody.Audio}.\");\n                        }\n\n                        // Base64 decode\n                        var base64EncodedAudio = responseBody.Audio\n                            .Remove(0, ResponsePrefix.Length);\n\n                        var base64DecodedAudio = Convert.FromBase64String(base64EncodedAudio);\n\n                        return UncertainResults.Succeed<Stream>(\n                            new MemoryStream(base64DecodedAudio));\n                    }\n", "                    if (deserializationResult is IFailureResult<ResponseBody> deserializationFailure)\n                    {\n                        return UncertainResults.FailWithTrace<Stream>(\n                            $\"Failed because -> {deserializationFailure.Message}.\");\n                    }\n                    else\n                    {\n                        throw new ResultPatternMatchException(nameof(deserializationResult));\n                    }\n                }\n                // Retryable", "                else if (responseMessage.StatusCode is HttpStatusCode.TooManyRequests\n                         || (int)responseMessage.StatusCode is >= 500 and <= 599)\n                {\n                    return UncertainResults.RetryWithTrace<Stream>(\n                        $\"Retryable because the API returned status code:({(int)responseMessage.StatusCode}){responseMessage.StatusCode} with response -> {responseString}.\");\n                }\n                // Response error\n                else\n                {\n                    return UncertainResults.FailWithTrace<Stream>(\n                        $\"Failed because the API returned status code:({(int)responseMessage.StatusCode}){responseMessage.StatusCode} with response -> {responseString}.\"\n                    );\n                }\n            }\n            // Request error", "            catch (HttpRequestException exception)\n            {\n                return UncertainResults.RetryWithTrace<Stream>(\n                    $\"Retryable because {nameof(HttpRequestException)} was thrown during calling the API -> {exception}.\");\n            }\n            // Task cancellation\n            catch (TaskCanceledException exception)\n                when (exception.CancellationToken == cancellationToken)\n            {\n                return UncertainResults.RetryWithTrace<Stream>(\n                    $\"Failed because task was canceled by user during call to the API -> {exception}.\");\n            }\n            // Operation cancellation ", "            catch (OperationCanceledException exception)\n            {\n                return UncertainResults.RetryWithTrace<Stream>(\n                    $\"Retryable because operation was cancelled during calling the API -> {exception}.\");\n            }\n            // Unhandled error\n            catch (Exception exception)\n            {\n                return UncertainResults.FailWithTrace<Stream>(\n                    $\"Failed because an unhandled exception was thrown when calling the API -> {exception}.\");\n            }\n        }\n    }\n}"]}
