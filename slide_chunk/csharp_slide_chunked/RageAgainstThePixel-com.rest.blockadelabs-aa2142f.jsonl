{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Tests/TestFixture_00_Skyboxes.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing BlockadeLabs.Skyboxes;\nusing NUnit.Framework;\nusing System;\nusing System.Threading;\nusing UnityEngine;\nusing Task = System.Threading.Tasks.Task;\n\nnamespace BlockadeLabs.Tests", "\nnamespace BlockadeLabs.Tests\n{\n    public class TestFixture_01_Skyboxes\n    {\n        [Test]\n        public async Task Test_01_GetSkyboxStyles()\n        {\n            var api = new BlockadeLabsClient(BlockadeLabsAuthentication.Default.LoadFromEnvironment());\n            Assert.IsNotNull(api.SkyboxEndpoint);\n            var skyboxStyles = await api.SkyboxEndpoint.GetSkyboxStylesAsync();\n            Assert.IsNotNull(skyboxStyles);\n", "            foreach (var skyboxStyle in skyboxStyles)\n            {\n                Debug.Log($\"{skyboxStyle.Name}\");\n            }\n        }\n\n        [Test]\n        public async Task Test_02_GenerateSkybox()\n        {\n            var api = new BlockadeLabsClient(BlockadeLabsAuthentication.Default.LoadFromEnvironment());\n            Assert.IsNotNull(api.SkyboxEndpoint);\n\n            var request = new SkyboxRequest(\"mars\", depth: true);\n            var skyboxInfo = await api.SkyboxEndpoint.GenerateSkyboxAsync(request);\n            Assert.IsNotNull(skyboxInfo);\n            Debug.Log($\"Successfully created skybox: {skyboxInfo.Id}\");\n            Debug.Log(skyboxInfo.MainTextureUrl);\n            Assert.IsNotNull(skyboxInfo.MainTexture);\n            Debug.Log(skyboxInfo.DepthTextureUrl);\n            Assert.IsNotNull(skyboxInfo.DepthTexture);\n            Debug.Log(skyboxInfo.ToString());\n        }\n\n        [Test]", "        public async Task Test_03_GetSkyboxInfo()\n        {\n            var api = new BlockadeLabsClient(BlockadeLabsAuthentication.Default.LoadFromEnvironment());\n            Assert.IsNotNull(api.SkyboxEndpoint);\n            var skyboxId = 6602899;\n            var skyboxInfo = await api.SkyboxEndpoint.GetSkyboxInfoAsync(skyboxId);\n            Assert.IsNotNull(skyboxInfo);\n            await skyboxInfo.LoadTexturesAsync();\n            Assert.IsNotNull(skyboxInfo.MainTexture);\n            Assert.IsNotNull(skyboxInfo.DepthTexture);\n        }\n\n        [Test]", "        public async Task Test_04_GetHistory()\n        {\n            var api = new BlockadeLabsClient(BlockadeLabsAuthentication.Default.LoadFromEnvironment());\n            Assert.IsNotNull(api.SkyboxEndpoint);\n            var history = await api.SkyboxEndpoint.GetSkyboxHistoryAsync();\n            Assert.IsNotNull(history);\n            Assert.IsNotEmpty(history.Skyboxes);\n            Debug.Log($\"Found {history.TotalCount} skyboxes\");\n\n            foreach (var skybox in history.Skyboxes)\n            {\n                Debug.Log($\"{skybox.Id} {skybox.Title} status: {skybox.Status}\");\n            }\n        }\n\n        [Test]", "            foreach (var skybox in history.Skyboxes)\n            {\n                Debug.Log($\"{skybox.Id} {skybox.Title} status: {skybox.Status}\");\n            }\n        }\n\n        [Test]\n        public async Task Test_05_CancelPendingGeneration()\n        {\n            var api = new BlockadeLabsClient(BlockadeLabsAuthentication.Default.LoadFromEnvironment());\n            Assert.IsNotNull(api.SkyboxEndpoint);\n            var request = new SkyboxRequest(\"mars\", depth: true);\n            var cts = new CancellationTokenSource(TimeSpan.FromSeconds(1.5));\n\n            try\n            {\n                await api.SkyboxEndpoint.GenerateSkyboxAsync(request, 1, cts.Token);\n            }", "            catch (OperationCanceledException)\n            {\n                Debug.Log(\"Operation successfully cancelled\");\n            }\n            catch (Exception e)\n            {\n                Debug.LogError(e);\n            }\n        }\n\n        [Test]", "        public async Task Test_06_CancelAllPendingGenerations()\n        {\n            var api = new BlockadeLabsClient(BlockadeLabsAuthentication.Default.LoadFromEnvironment());\n            Assert.IsNotNull(api.SkyboxEndpoint);\n            var result = await api.SkyboxEndpoint.CancelAllPendingSkyboxGenerationsAsync();\n            Debug.Log(result ? \"All pending generations successfully cancelled\" : \"No pending generations\");\n        }\n\n        [Test]\n        public async Task Test_07_DeleteSkybox()\n        {\n            var api = new BlockadeLabsClient(BlockadeLabsAuthentication.Default.LoadFromEnvironment());\n            Assert.IsNotNull(api.SkyboxEndpoint);\n            var history = await api.SkyboxEndpoint.GetSkyboxHistoryAsync(new SkyboxHistoryParameters { StatusFilter = Status.Abort });\n            Assert.IsNotNull(history);\n", "        public async Task Test_07_DeleteSkybox()\n        {\n            var api = new BlockadeLabsClient(BlockadeLabsAuthentication.Default.LoadFromEnvironment());\n            Assert.IsNotNull(api.SkyboxEndpoint);\n            var history = await api.SkyboxEndpoint.GetSkyboxHistoryAsync(new SkyboxHistoryParameters { StatusFilter = Status.Abort });\n            Assert.IsNotNull(history);\n\n            foreach (var skybox in history.Skyboxes)\n            {\n                Debug.Log($\"Deleting {skybox.Id} {skybox.Title}\");\n                var result = await api.SkyboxEndpoint.DeleteSkyboxAsync(skybox);\n                Assert.IsTrue(result);\n            }\n        }\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Tests/TestFixture_00_Authentication.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing NUnit.Framework;\nusing System;\nusing System.IO;\nusing System.Security.Authentication;\nusing UnityEditor;\nusing UnityEngine;\n\nnamespace BlockadeLabs.Tests", "\nnamespace BlockadeLabs.Tests\n{\n    internal class TestFixture_00_Authentication\n    {\n        [SetUp]\n        public void Setup()\n        {\n            var authJson = new BlockadeLabsAuthInfo(\"key-test12\");\n            var authText = JsonUtility.ToJson(authJson, true);\n            File.WriteAllText(BlockadeLabsAuthentication.CONFIG_FILE, authText);\n        }\n\n        [Test]", "        public void Test_01_GetAuthFromEnv()\n        {\n            var auth = BlockadeLabsAuthentication.Default.LoadFromEnvironment();\n            Assert.IsNotNull(auth);\n            Assert.IsNotNull(auth.Info.ApiKey);\n            Assert.IsNotEmpty(auth.Info.ApiKey);\n        }\n\n        [Test]\n        public void Test_02_GetAuthFromFile()\n        {\n            var auth = BlockadeLabsAuthentication.Default.LoadFromPath(Path.GetFullPath(BlockadeLabsAuthentication.CONFIG_FILE));\n            Assert.IsNotNull(auth);\n            Assert.IsNotNull(auth.Info.ApiKey);\n            Assert.AreEqual(\"key-test12\", auth.Info.ApiKey);\n        }\n\n        [Test]", "        public void Test_02_GetAuthFromFile()\n        {\n            var auth = BlockadeLabsAuthentication.Default.LoadFromPath(Path.GetFullPath(BlockadeLabsAuthentication.CONFIG_FILE));\n            Assert.IsNotNull(auth);\n            Assert.IsNotNull(auth.Info.ApiKey);\n            Assert.AreEqual(\"key-test12\", auth.Info.ApiKey);\n        }\n\n        [Test]\n        public void Test_03_GetAuthFromNonExistentFile()\n        {\n            var auth = BlockadeLabsAuthentication.Default.LoadFromDirectory(filename: \"bad.config\");\n            Assert.IsNull(auth);\n        }\n\n        [Test]", "        public void Test_03_GetAuthFromNonExistentFile()\n        {\n            var auth = BlockadeLabsAuthentication.Default.LoadFromDirectory(filename: \"bad.config\");\n            Assert.IsNull(auth);\n        }\n\n        [Test]\n        public void Test_04_GetAuthFromConfiguration()\n        {\n            var configPath = $\"Assets/Resources/{nameof(BlockadeLabsConfiguration)}.asset\";\n            var cleanup = false;\n", "            if (!File.Exists(Path.GetFullPath(configPath)))\n            {\n                if (!Directory.Exists($\"{Application.dataPath}/Resources\"))\n                {\n                    Directory.CreateDirectory($\"{Application.dataPath}/Resources\");\n                }\n\n                var instance = ScriptableObject.CreateInstance<BlockadeLabsConfiguration>();\n                instance.ApiKey = \"key-test12\";\n                AssetDatabase.CreateAsset(instance, configPath);\n                cleanup = true;\n            }\n\n            var config = AssetDatabase.LoadAssetAtPath<BlockadeLabsConfiguration>(configPath);\n            var auth = BlockadeLabsAuthentication.Default.LoadFromAsset<BlockadeLabsConfiguration>();\n\n            Assert.IsNotNull(auth);\n            Assert.IsNotNull(auth.Info.ApiKey);\n            Assert.IsNotEmpty(auth.Info.ApiKey);\n            Assert.AreEqual(auth.Info.ApiKey, config.ApiKey);\n", "            if (cleanup)\n            {\n                AssetDatabase.DeleteAsset(configPath);\n                AssetDatabase.DeleteAsset(\"Assets/Resources\");\n            }\n        }\n\n        [Test]\n        public void Test_05_Authentication()\n        {\n            var defaultAuth = BlockadeLabsAuthentication.Default;\n            var manualAuth = new BlockadeLabsAuthentication(\"key-testAA\");\n\n            Assert.IsNotNull(defaultAuth);\n            Assert.IsNotNull(defaultAuth.Info.ApiKey);\n            Assert.AreEqual(defaultAuth.Info.ApiKey, BlockadeLabsAuthentication.Default.Info.ApiKey);\n\n            BlockadeLabsAuthentication.Default = new BlockadeLabsAuthentication(\"key-testAA\");\n            Assert.IsNotNull(manualAuth);\n            Assert.IsNotNull(manualAuth.Info.ApiKey);\n            Assert.AreEqual(manualAuth.Info.ApiKey, BlockadeLabsAuthentication.Default.Info.ApiKey);\n\n            BlockadeLabsAuthentication.Default = defaultAuth;\n        }\n\n        [Test]", "        public void Test_05_Authentication()\n        {\n            var defaultAuth = BlockadeLabsAuthentication.Default;\n            var manualAuth = new BlockadeLabsAuthentication(\"key-testAA\");\n\n            Assert.IsNotNull(defaultAuth);\n            Assert.IsNotNull(defaultAuth.Info.ApiKey);\n            Assert.AreEqual(defaultAuth.Info.ApiKey, BlockadeLabsAuthentication.Default.Info.ApiKey);\n\n            BlockadeLabsAuthentication.Default = new BlockadeLabsAuthentication(\"key-testAA\");\n            Assert.IsNotNull(manualAuth);\n            Assert.IsNotNull(manualAuth.Info.ApiKey);\n            Assert.AreEqual(manualAuth.Info.ApiKey, BlockadeLabsAuthentication.Default.Info.ApiKey);\n\n            BlockadeLabsAuthentication.Default = defaultAuth;\n        }\n\n        [Test]", "        public void Test_06_GetKey()\n        {\n            var auth = new BlockadeLabsAuthentication(\"key-testAA\");\n            Assert.IsNotNull(auth.Info.ApiKey);\n            Assert.AreEqual(\"key-testAA\", auth.Info.ApiKey);\n        }\n\n        [Test]\n        public void Test_07_GetKeyFailed()\n        {\n            BlockadeLabsAuthentication auth = null;\n\n            try\n            {\n                auth = new BlockadeLabsAuthentication(\"fail-key\");\n            }", "        public void Test_07_GetKeyFailed()\n        {\n            BlockadeLabsAuthentication auth = null;\n\n            try\n            {\n                auth = new BlockadeLabsAuthentication(\"fail-key\");\n            }\n            catch (InvalidCredentialException)\n            {\n                Assert.IsNull(auth);\n            }", "            catch (InvalidCredentialException)\n            {\n                Assert.IsNull(auth);\n            }\n            catch (Exception e)\n            {\n                Assert.IsTrue(false, $\"Expected exception {nameof(InvalidCredentialException)} but got {e.GetType().Name}\");\n            }\n        }\n\n        [Test]", "        public void Test_08_ParseKey()\n        {\n            var auth = new BlockadeLabsAuthentication(\"key-testAA\");\n            Assert.IsNotNull(auth.Info.ApiKey);\n            Assert.AreEqual(\"key-testAA\", auth.Info.ApiKey);\n            auth = \"key-testCC\";\n            Assert.IsNotNull(auth.Info.ApiKey);\n            Assert.AreEqual(\"key-testCC\", auth.Info.ApiKey);\n\n            auth = new BlockadeLabsAuthentication(\"key-testBB\");\n            Assert.IsNotNull(auth.Info.ApiKey);\n            Assert.AreEqual(\"key-testBB\", auth.Info.ApiKey);\n        }\n\n        [Test]", "        public void Test_12_CustomDomainConfigurationSettings()\n        {\n            var auth = new BlockadeLabsAuthentication(\"customIssuedToken\");\n            var settings = new BlockadeLabsSettings(domain: \"api.your-custom-domain.com\");\n            var api = new BlockadeLabsClient(auth, settings);\n            Debug.Log(api.Settings.Info.BaseRequestUrlFormat);\n        }\n\n        [TearDown]\n        public void TearDown()\n        {", "        public void TearDown()\n        {\n            if (File.Exists(BlockadeLabsAuthentication.CONFIG_FILE))\n            {\n                File.Delete(BlockadeLabsAuthentication.CONFIG_FILE);\n            }\n        }\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Samples~/Skybox/SkyboxBehaviour.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing BlockadeLabs.Skyboxes;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing TMPro;\nusing UnityEngine;\nusing UnityEngine.UI;", "using UnityEngine;\nusing UnityEngine.UI;\nusing Utilities.Extensions;\n\nnamespace BlockadeLabs.Samples.Skybox\n{\n    public class SkyboxBehaviour : MonoBehaviour\n    {\n        [SerializeField]\n        private TMP_InputField promptInputField;\n\n        [SerializeField]", "        private TMP_InputField promptInputField;\n\n        [SerializeField]\n        private TMP_Dropdown skyboxStyleDropdown;\n\n        [SerializeField]\n        private Button generateButton;\n\n        [SerializeField]\n        private Material skyboxMaterial;\n", "        private Material skyboxMaterial;\n\n        private BlockadeLabsClient api;\n\n        private CancellationTokenSource lifetimeCancellationTokenSource;\n\n        private IReadOnlyList<SkyboxStyle> skyboxOptions;\n\n        private void OnValidate()\n        {\n            promptInputField.Validate();\n            skyboxStyleDropdown.Validate();\n            generateButton.Validate();\n        }\n", "        private void OnValidate()\n        {\n            promptInputField.Validate();\n            skyboxStyleDropdown.Validate();\n            generateButton.Validate();\n        }\n\n        private void Awake()\n        {\n            OnValidate();\n            lifetimeCancellationTokenSource = new CancellationTokenSource();\n\n            try\n            {\n                api = new BlockadeLabsClient();\n            }", "            catch (Exception e)\n            {\n                Debug.LogError($\"Failed to create {nameof(BlockadeLabsClient)}!\\n{e}\");\n                enabled = false;\n                return;\n            }\n\n            GetSkyboxStyles();\n            generateButton.onClick.AddListener(GenerateSkybox);\n            promptInputField.onSubmit.AddListener(GenerateSkybox);\n            promptInputField.onValueChanged.AddListener(ValidateInput);\n        }\n", "        private void ValidateInput(string input)\n        {\n            generateButton.interactable = !string.IsNullOrWhiteSpace(input);\n        }\n\n        private void GenerateSkybox() => GenerateSkybox(promptInputField.text);\n\n        private async void GenerateSkybox(string prompt)\n        {\n            if (string.IsNullOrWhiteSpace(prompt))\n            {\n                Debug.LogWarning(\"No prompt given!\");\n                return;\n            }\n\n            try\n            {\n                generateButton.interactable = false;\n                promptInputField.interactable = false;\n                var request = new SkyboxRequest(prompt, skyboxStyleId: skyboxOptions[skyboxStyleDropdown.value].Id);\n                var skyboxInfo = await api.SkyboxEndpoint.GenerateSkyboxAsync(request, cancellationToken: lifetimeCancellationTokenSource.Token).ConfigureAwait(true);\n                skyboxMaterial.mainTexture = skyboxInfo.MainTexture;\n                Debug.Log($\"Successfully created skybox: {skyboxInfo.Id}\");\n            }", "            if (string.IsNullOrWhiteSpace(prompt))\n            {\n                Debug.LogWarning(\"No prompt given!\");\n                return;\n            }\n\n            try\n            {\n                generateButton.interactable = false;\n                promptInputField.interactable = false;\n                var request = new SkyboxRequest(prompt, skyboxStyleId: skyboxOptions[skyboxStyleDropdown.value].Id);\n                var skyboxInfo = await api.SkyboxEndpoint.GenerateSkyboxAsync(request, cancellationToken: lifetimeCancellationTokenSource.Token).ConfigureAwait(true);\n                skyboxMaterial.mainTexture = skyboxInfo.MainTexture;\n                Debug.Log($\"Successfully created skybox: {skyboxInfo.Id}\");\n            }", "            catch (Exception e)\n            {\n                Debug.LogError(e);\n            }\n            finally\n            {\n                generateButton.interactable = true;\n                promptInputField.interactable = true;\n            }\n        }\n", "        private void OnDestroy()\n        {\n            lifetimeCancellationTokenSource.Cancel();\n        }\n\n        private async void GetSkyboxStyles()\n        {\n            try\n            {\n                skyboxOptions = await api.SkyboxEndpoint.GetSkyboxStylesAsync(lifetimeCancellationTokenSource.Token).ConfigureAwait(true);\n                var dropdownOptions = new List<TMP_Dropdown.OptionData>(skyboxOptions.Count);\n                dropdownOptions.AddRange(skyboxOptions.Select(skyboxStyle => new TMP_Dropdown.OptionData(skyboxStyle.Name)));\n                skyboxStyleDropdown.options = dropdownOptions;\n            }", "            catch (Exception e)\n            {\n                Debug.LogError(e);\n            }\n        }\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Editor/SkyboxStylePropertyDrawer.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing BlockadeLabs.Skyboxes;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Authentication;\nusing UnityEditor;\nusing UnityEngine;\n", "using UnityEngine;\n\nnamespace BlockadeLabs.Editor\n{\n    [CustomPropertyDrawer(typeof(SkyboxStyle))]\n    public class SkyboxStylePropertyDrawer : PropertyDrawer\n    {\n        private static BlockadeLabsClient blockadeLabsClient;\n\n        private static BlockadeLabsClient BlockadeLabsClient => blockadeLabsClient ??= new BlockadeLabsClient();\n", "        private static BlockadeLabsClient BlockadeLabsClient => blockadeLabsClient ??= new BlockadeLabsClient();\n\n        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)\n        {\n            try\n            {\n                if (!BlockadeLabsClient.HasValidAuthentication)\n                {\n                    EditorGUI.LabelField(position, \"Cannot fetch skybox styles\");\n                    return;\n                }\n            }", "            catch (AuthenticationException)\n            {\n                EditorGUI.HelpBox(position, \"Check blockade labs api key\", MessageType.Error);\n\n                return;\n            }\n            catch (Exception e)\n            {\n                Debug.LogError(e);\n\n                return;\n            }\n\n            var id = property.FindPropertyRelative(\"id\");\n            var name = property.FindPropertyRelative(\"name\");\n", "            if (options.Length < 1)\n            {\n                FetchStyles();\n\n                if (string.IsNullOrWhiteSpace(name.stringValue))\n                {\n                    EditorGUI.HelpBox(position, \"Fetching skybox styles...\", MessageType.Info);\n                    return;\n                }\n\n                EditorGUI.LabelField(position, label, new GUIContent(name.stringValue, id.intValue.ToString()));\n                return;\n            }\n\n            // dropdown\n            var index = -1;\n            dynamic currentOption = null;\n", "            if (id.intValue > 0)\n            {\n                currentOption = styles?.FirstOrDefault(style => style.Id.ToString() == id.intValue.ToString());\n            }\n\n            if (currentOption != null)\n            {\n                for (var i = 0; i < options.Length; i++)\n                {\n                    if (options[i].tooltip.Contains(currentOption.Id.ToString()))\n                    {\n                        index = i;\n                        break;\n                    }\n                }\n            }\n\n            EditorGUI.BeginChangeCheck();\n            index = EditorGUI.Popup(position, label, index, options);\n", "                    if (options[i].tooltip.Contains(currentOption.Id.ToString()))\n                    {\n                        index = i;\n                        break;\n                    }\n                }\n            }\n\n            EditorGUI.BeginChangeCheck();\n            index = EditorGUI.Popup(position, label, index, options);\n", "            if (EditorGUI.EndChangeCheck())\n            {\n                currentOption = styles?.FirstOrDefault(style => options[index].text.Contains(style.Name));\n                id.intValue = currentOption!.Id;\n                name.stringValue = currentOption!.Name;\n            }\n        }\n\n        private static bool isFetchingStyles;\n\n        public static bool IsFetchingStyles => isFetchingStyles;\n", "        private static bool isFetchingStyles;\n\n        public static bool IsFetchingStyles => isFetchingStyles;\n\n        private static IReadOnlyList<SkyboxStyle> styles = new List<SkyboxStyle>();\n\n        public static IReadOnlyList<SkyboxStyle> Styles => styles;\n\n        private static GUIContent[] options = Array.Empty<GUIContent>();\n\n        public static IReadOnlyList<GUIContent> Options => options;\n", "        private static GUIContent[] options = Array.Empty<GUIContent>();\n\n        public static IReadOnlyList<GUIContent> Options => options;\n\n        public static async void FetchStyles()\n        {\n            if (isFetchingStyles) { return; }\n            isFetchingStyles = true;\n\n            try\n            {\n                styles = await BlockadeLabsClient.SkyboxEndpoint.GetSkyboxStylesAsync();\n                options = styles.OrderBy(style => style.Id).Select(style => new GUIContent(style.Name, style.Id.ToString())).ToArray();\n            }", "            catch (Exception e)\n            {\n                Debug.LogError(e);\n            }\n            finally\n            {\n                isFetchingStyles = false;\n            }\n        }\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Editor/BlockadeLabsConfigurationInspector.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing System;\nusing UnityEditor;\nusing Utilities.Rest.Editor;\n\nnamespace BlockadeLabs.Editor\n{\n    [CustomEditor(typeof(BlockadeLabsConfiguration))]\n    public class BlockadeLabsConfigurationInspector : BaseConfigurationInspector<BlockadeLabsConfiguration>\n    {", "    [CustomEditor(typeof(BlockadeLabsConfiguration))]\n    public class BlockadeLabsConfigurationInspector : BaseConfigurationInspector<BlockadeLabsConfiguration>\n    {\n        private static bool triggerReload;\n\n        private SerializedProperty apiKey;\n        private SerializedProperty proxyDomain;\n\n        #region Project Settings Window\n\n        [SettingsProvider]", "        private static SettingsProvider Preferences()\n            => GetSettingsProvider(nameof(BlockadeLabs), CheckReload);\n\n        #endregion Project Settings Window\n\n        #region Inspector Window\n\n        private void OnEnable()\n        {\n            GetOrCreateInstance(target);\n\n            try\n            {\n                apiKey = serializedObject.FindProperty(nameof(apiKey));\n                proxyDomain = serializedObject.FindProperty(nameof(proxyDomain));\n            }", "            catch (Exception)\n            {\n                // Ignored\n            }\n        }\n\n        private void OnDisable() => CheckReload();\n\n        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n            EditorGUILayout.Space();\n            EditorGUI.indentLevel++;\n            EditorGUI.BeginChangeCheck();\n\n            EditorGUILayout.PropertyField(apiKey);\n            EditorGUILayout.PropertyField(proxyDomain);\n", "        public override void OnInspectorGUI()\n        {\n            serializedObject.Update();\n            EditorGUILayout.Space();\n            EditorGUI.indentLevel++;\n            EditorGUI.BeginChangeCheck();\n\n            EditorGUILayout.PropertyField(apiKey);\n            EditorGUILayout.PropertyField(proxyDomain);\n\n            if (EditorGUI.EndChangeCheck())\n            {\n                triggerReload = true;\n            }\n\n            EditorGUI.indentLevel--;\n            serializedObject.ApplyModifiedProperties();\n        }\n\n        #endregion Inspector Window\n", "            if (EditorGUI.EndChangeCheck())\n            {\n                triggerReload = true;\n            }\n\n            EditorGUI.indentLevel--;\n            serializedObject.ApplyModifiedProperties();\n        }\n\n        #endregion Inspector Window\n", "        private static void CheckReload()\n        {\n            if (triggerReload)\n            {\n                triggerReload = false;\n                EditorUtility.RequestScriptReload();\n            }\n        }\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Editor/BlockadeLabsEditorWindow.cs", "chunked_list": ["using BlockadeLabs.Skyboxes;\nusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing UnityEditor;\nusing UnityEngine;\nusing Utilities.Async;\nusing Utilities.WebRequestRest;", "using Utilities.Async;\nusing Utilities.WebRequestRest;\nusing Task = System.Threading.Tasks.Task;\n\nnamespace BlockadeLabs.Editor\n{\n    public sealed class BlockadeLabsEditorWindow : EditorWindow\n    {\n        private const int TabWidth = 18;\n        private const int EndWidth = 10;\n        private const int InnerLabelIndentLevel = 13;", "        private const int TabWidth = 18;\n        private const int EndWidth = 10;\n        private const int InnerLabelIndentLevel = 13;\n        private const int MaxCharacterLength = 5000;\n\n        private const float InnerLabelWidth = 1.9f;\n        private const float DefaultColumnWidth = 96f;\n        private const float WideColumnWidth = 128f;\n        private const float SettingsLabelWidth = 1.56f;\n\n        private static readonly GUIContent guiTitleContent = new GUIContent(\"BlockadeLabs Dashboard\");", "        private const float SettingsLabelWidth = 1.56f;\n\n        private static readonly GUIContent guiTitleContent = new GUIContent(\"BlockadeLabs Dashboard\");\n        private static readonly GUIContent saveDirectoryContent = new GUIContent(\"Save Directory\");\n        private static readonly GUIContent downloadContent = new GUIContent(\"Download\");\n        private static readonly GUIContent deleteContent = new GUIContent(\"Delete\");\n        private static readonly GUIContent refreshContent = new GUIContent(\"Refresh\");\n\n        private static readonly string[] tabTitles = { \"Skybox Generation\", \"History\" };\n\n        private static GUIStyle boldCenteredHeaderStyle;\n", "        private static readonly string[] tabTitles = { \"Skybox Generation\", \"History\" };\n\n        private static GUIStyle boldCenteredHeaderStyle;\n\n        private static GUIStyle BoldCenteredHeaderStyle\n        {\n            get\n            {\n                if (boldCenteredHeaderStyle == null)\n                {\n                    var editorStyle = EditorGUIUtility.isProSkin ? EditorStyles.whiteLargeLabel : EditorStyles.largeLabel;\n", "                if (boldCenteredHeaderStyle == null)\n                {\n                    var editorStyle = EditorGUIUtility.isProSkin ? EditorStyles.whiteLargeLabel : EditorStyles.largeLabel;\n\n                    if (editorStyle != null)\n                    {\n                        boldCenteredHeaderStyle = new GUIStyle(editorStyle)\n                        {\n                            alignment = TextAnchor.MiddleCenter,\n                            fontSize = 18,\n                            padding = new RectOffset(0, 0, -8, -8)\n                        };\n                    }\n                }\n\n                return boldCenteredHeaderStyle;\n            }\n        }\n", "        private static string DefaultSaveDirectoryKey => $\"{Application.productName}_BlockadeLabs_EditorDownloadDirectory\";\n\n        private static string DefaultSaveDirectory => Application.dataPath;\n\n        private static readonly GUILayoutOption[] defaultColumnWidthOption =\n        {\n            GUILayout.Width(DefaultColumnWidth)\n        };\n\n        private static readonly GUILayoutOption[] wideColumnWidthOption =\n        {\n            GUILayout.Width(WideColumnWidth)\n        };\n", "        private static readonly GUILayoutOption[] wideColumnWidthOption =\n        {\n            GUILayout.Width(WideColumnWidth)\n        };\n\n        private static readonly GUILayoutOption[] expandWidthOption =\n        {\n            GUILayout.ExpandWidth(true)\n        };\n\n        #region static content\n", "        private static BlockadeLabsClient api;\n\n        private static string editorDownloadDirectory = string.Empty;\n\n        private static bool isGeneratingSkybox;\n\n        private static IReadOnlyList<SkyboxStyle> skyboxStyles = new List<SkyboxStyle>();\n\n        private static GUIContent[] skyboxOptions = Array.Empty<GUIContent>();\n\n        private static SkyboxStyle currentSkyboxStyleSelection;\n", "        private static GUIContent[] skyboxOptions = Array.Empty<GUIContent>();\n\n        private static SkyboxStyle currentSkyboxStyleSelection;\n\n        private static bool isFetchingSkyboxStyles;\n        private static bool hasFetchedSkyboxStyles;\n\n        private static bool hasFetchedHistory;\n        private static bool isFetchingSkyboxHistory;\n\n        private static SkyboxHistory history;\n", "        private static bool isFetchingSkyboxHistory;\n\n        private static SkyboxHistory history;\n\n        private static int page;\n\n        private static int limit = 100;\n\n        #endregion static content\n\n        [SerializeField]", "        private int tab;\n\n        [SerializeField]\n        private int currentSkyboxStyleId;\n\n        private Vector2 scrollPosition = Vector2.zero;\n\n        private string promptText;\n\n        private string negativeText;\n", "        private string negativeText;\n\n        private int seed;\n\n        private bool depth;\n\n        private Texture2D controlImage;\n\n        [MenuItem(\"BlockadeLabs/Dashboard\")]\n        private static void OpenWindow()\n        {\n            // Dock it next to the Scene View.\n            var instance = GetWindow<BlockadeLabsEditorWindow>(typeof(SceneView));\n            instance.Show();\n            instance.titleContent = guiTitleContent;\n        }\n", "        private static void OpenWindow()\n        {\n            // Dock it next to the Scene View.\n            var instance = GetWindow<BlockadeLabsEditorWindow>(typeof(SceneView));\n            instance.Show();\n            instance.titleContent = guiTitleContent;\n        }\n\n        private void OnEnable()\n        {\n            titleContent = guiTitleContent;\n            minSize = new Vector2(WideColumnWidth * 5, WideColumnWidth * 4);\n        }\n", "        private void OnEnable()\n        {\n            titleContent = guiTitleContent;\n            minSize = new Vector2(WideColumnWidth * 5, WideColumnWidth * 4);\n        }\n\n        private void OnFocus()\n        {\n            api ??= new BlockadeLabsClient();\n\n            if (!hasFetchedSkyboxStyles)\n            {\n                hasFetchedSkyboxStyles = true;\n                FetchSkyboxStyles();\n            }\n", "            if (!hasFetchedSkyboxStyles)\n            {\n                hasFetchedSkyboxStyles = true;\n                FetchSkyboxStyles();\n            }\n\n            if (!hasFetchedHistory)\n            {\n                hasFetchedHistory = true;\n                FetchSkyboxHistory();\n            }\n        }\n", "        private void OnGUI()\n        {\n            EditorGUILayout.BeginVertical();\n            scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition, expandWidthOption);\n            EditorGUILayout.BeginHorizontal();\n            GUILayout.Space(TabWidth);\n            EditorGUILayout.BeginVertical();\n            { // Begin Header\n                EditorGUILayout.Space();\n                EditorGUILayout.LabelField(\"BlockadeLabs Dashboard\", BoldCenteredHeaderStyle);\n                EditorGUILayout.Space();\n", "                if (api is not { HasValidAuthentication: true })\n                {\n                    EditorGUILayout.HelpBox($\"No valid {nameof(BlockadeLabsConfiguration)} was found. This tool requires that you set your API key.\", MessageType.Error);\n                    return;\n                }\n\n                EditorGUILayout.Space();\n                EditorGUI.BeginChangeCheck();\n                tab = GUILayout.Toolbar(tab, tabTitles, expandWidthOption);\n\n                if (EditorGUI.EndChangeCheck())\n                {\n                    GUI.FocusControl(null);\n                }\n\n                EditorGUILayout.LabelField(saveDirectoryContent);\n", "                if (EditorGUI.EndChangeCheck())\n                {\n                    GUI.FocusControl(null);\n                }\n\n                EditorGUILayout.LabelField(saveDirectoryContent);\n\n                if (string.IsNullOrWhiteSpace(editorDownloadDirectory))\n                {\n                    editorDownloadDirectory = EditorPrefs.GetString(DefaultSaveDirectoryKey, DefaultSaveDirectory);\n                }\n\n                EditorGUILayout.BeginHorizontal();\n                {\n                    EditorGUILayout.TextField(editorDownloadDirectory, expandWidthOption);\n", "                    if (GUILayout.Button(\"Reset\", wideColumnWidthOption))\n                    {\n                        editorDownloadDirectory = DefaultSaveDirectory;\n                        EditorPrefs.SetString(DefaultSaveDirectoryKey, editorDownloadDirectory);\n                    }\n                }\n                EditorGUILayout.EndHorizontal();\n                EditorGUILayout.BeginHorizontal();\n                {\n                    if (GUILayout.Button(\"Change Save Directory\", expandWidthOption))\n                    {\n                        EditorApplication.delayCall += () =>\n                        {\n                            var result = EditorUtility.OpenFolderPanel(\"Save Directory\", editorDownloadDirectory, string.Empty);\n", "                    if (GUILayout.Button(\"Change Save Directory\", expandWidthOption))\n                    {\n                        EditorApplication.delayCall += () =>\n                        {\n                            var result = EditorUtility.OpenFolderPanel(\"Save Directory\", editorDownloadDirectory, string.Empty);\n\n                            if (!string.IsNullOrWhiteSpace(result))\n                            {\n                                editorDownloadDirectory = result;\n                                EditorPrefs.SetString(DefaultSaveDirectoryKey, editorDownloadDirectory);\n                            }\n                        };\n                    }\n                }\n                EditorGUILayout.EndHorizontal();\n            } // End Header\n            EditorGUILayout.EndVertical();\n            GUILayout.Space(EndWidth);\n            EditorGUILayout.EndHorizontal();\n            EditorGUILayout.Space();\n\n            switch (tab)\n            {\n                case 0:\n                    SkyboxGeneration();\n                    break;\n                case 1:\n                    RenderHistory();\n                    break;\n            }\n\n            EditorGUILayout.EndScrollView();\n            EditorGUILayout.EndVertical();\n        }\n", "        private void SkyboxGeneration()\n        {\n            EditorGUILayout.BeginHorizontal();\n            GUILayout.Space(TabWidth);\n            EditorGUILayout.BeginVertical();\n            EditorGUILayout.LabelField(\"Describe your world\");\n            promptText = EditorGUILayout.TextArea(promptText);\n            EditorGUILayout.LabelField(\"Negative text\");\n            negativeText = EditorGUILayout.TextArea(negativeText);\n            EditorGUILayout.Space();\n            seed = EditorGUILayout.IntField(\"Seed\", seed);\n            depth = EditorGUILayout.Toggle(\"Depth\", depth);\n            controlImage = EditorGUILayout.ObjectField(new GUIContent(\"Control Image\"), controlImage, typeof(Texture2D), false) as Texture2D;\n\n            EditorGUILayout.BeginHorizontal();\n            { // skybox style dropdown\n                var skyboxIndex = -1;\n\n                currentSkyboxStyleSelection ??= skyboxStyles?.FirstOrDefault(skyboxStyle => skyboxStyle.Id == currentSkyboxStyleId);\n", "                if (currentSkyboxStyleSelection != null)\n                {\n                    for (var i = 0; i < skyboxOptions.Length; i++)\n                    {\n                        if (skyboxOptions[i].text.Contains(currentSkyboxStyleSelection.Name))\n                        {\n                            skyboxIndex = i;\n                            break;\n                        }\n                    }\n                }\n\n                EditorGUI.BeginChangeCheck();\n                skyboxIndex = EditorGUILayout.Popup(new GUIContent(\"Style\"), skyboxIndex, skyboxOptions);\n", "                if (EditorGUI.EndChangeCheck())\n                {\n                    currentSkyboxStyleSelection = skyboxStyles?.FirstOrDefault(voice => skyboxOptions[skyboxIndex].text.Contains(voice.Name));\n                    currentSkyboxStyleId = currentSkyboxStyleSelection!.Id;\n                }\n            }\n            EditorGUILayout.EndHorizontal();\n            EditorGUILayout.Space();\n\n            GUI.enabled = !isGeneratingSkybox;\n", "            if (GUILayout.Button(\"Generate\"))\n            {\n                GenerateSkybox();\n            }\n\n            GUI.enabled = true;\n            EditorGUILayout.EndVertical();\n            GUILayout.Space(EndWidth);\n            EditorGUILayout.EndHorizontal();\n        }\n", "        private static async void FetchSkyboxStyles()\n        {\n            if (isFetchingSkyboxStyles) { return; }\n            isFetchingSkyboxStyles = true;\n\n            try\n            {\n                skyboxStyles = await api.SkyboxEndpoint.GetSkyboxStylesAsync();\n                skyboxOptions = skyboxStyles.Select(skyboxStyle => new GUIContent(skyboxStyle.Name)).ToArray();\n            }\n            catch (Exception e)\n            {\n                Debug.LogError(e);\n            }\n            finally\n            {\n                isFetchingSkyboxStyles = false;\n            }\n        }\n", "            catch (Exception e)\n            {\n                Debug.LogError(e);\n            }\n            finally\n            {\n                isFetchingSkyboxStyles = false;\n            }\n        }\n\n        private async void GenerateSkybox()\n        {", "        private async void GenerateSkybox()\n        {\n            if (isGeneratingSkybox) { return; }\n            isGeneratingSkybox = true;\n\n            try\n            {\n                if (AssetImporter.GetAtPath(AssetDatabase.GetAssetPath(controlImage)) is TextureImporter textureImporter)\n                {\n                    if (!textureImporter.isReadable)\n                    {\n                        throw new Exception($\"Enable Read/Write in Texture asset import settings for {controlImage.name}\");\n                    }\n", "                    if (!textureImporter.isReadable)\n                    {\n                        throw new Exception($\"Enable Read/Write in Texture asset import settings for {controlImage.name}\");\n                    }\n\n                    if (textureImporter.textureCompression != TextureImporterCompression.Uncompressed)\n                    {\n                        throw new Exception($\"Disable compression in Texture asset import settings for {controlImage.name}\");\n                    }\n                }\n\n                using var skyboxRequest = controlImage == null\n                    ? new SkyboxRequest(\n                        prompt: promptText,\n                        negativeText: negativeText,\n                        skyboxStyleId: currentSkyboxStyleSelection?.Id,\n                        seed: seed,\n                    depth: depth)\n                    : new SkyboxRequest(\n                        prompt: promptText,\n                        negativeText: negativeText,\n                        controlImage: controlImage,\n                        skyboxStyleId: currentSkyboxStyleSelection?.Id,\n                        seed: seed,\n                        depth: depth);\n                promptText = string.Empty;\n                negativeText = string.Empty;\n                controlImage = null;\n                var skyboxInfo = await api.SkyboxEndpoint.GenerateSkyboxAsync(skyboxRequest);\n                await SaveSkyboxAssetAsync(skyboxInfo);\n            }", "            catch (Exception e)\n            {\n                Debug.LogError(e);\n            }\n            finally\n            {\n                isGeneratingSkybox = false;\n            }\n        }\n\n        private static readonly ConcurrentDictionary<int, SkyboxInfo> loadingSkyboxes = new ConcurrentDictionary<int, SkyboxInfo>();\n", "        private static readonly ConcurrentDictionary<int, SkyboxInfo> loadingSkyboxes = new ConcurrentDictionary<int, SkyboxInfo>();\n\n        private static async void SaveSkyboxAsset(SkyboxInfo skyboxInfo)\n        {\n            loadingSkyboxes.TryAdd(skyboxInfo.Id, skyboxInfo);\n            await skyboxInfo.LoadTexturesAsync();\n            await SaveSkyboxAssetAsync(skyboxInfo);\n            loadingSkyboxes.TryRemove(skyboxInfo.Id, out _);\n        }\n\n        private static async Task SaveSkyboxAssetAsync(SkyboxInfo skyboxInfo)\n        {", "        private static async Task SaveSkyboxAssetAsync(SkyboxInfo skyboxInfo)\n        {\n            if (skyboxInfo.MainTexture == null)\n            {\n                Debug.LogError(\"No main texture found!\");\n                return;\n            }\n\n            await Awaiters.UnityMainThread;\n            var directory = editorDownloadDirectory.Replace(Application.dataPath, \"Assets\");\n\n            var mainTexturePath = string.Empty;\n            var depthTexturePath = string.Empty;\n            var mainTextureBytes = skyboxInfo.MainTexture != null ? skyboxInfo.MainTexture.EncodeToPNG() : Array.Empty<byte>();\n", "            if (mainTextureBytes.Length > 0)\n            {\n                mainTexturePath = $\"{directory}/{skyboxInfo.MainTexture!.name}.png\";\n                Debug.Log(mainTexturePath);\n            }\n\n            var depthTextureBytes = skyboxInfo.DepthTexture != null ? skyboxInfo.DepthTexture.EncodeToPNG() : Array.Empty<byte>();\n\n            if (depthTextureBytes.Length > 0)\n            {\n                depthTexturePath = $\"{directory}/{skyboxInfo.DepthTexture!.name}.depth.png\";\n                Debug.Log(depthTexturePath);\n            }\n\n            var importTasks = new List<Task>(2)\n            {\n                Task.Run(async () =>\n                {", "            if (depthTextureBytes.Length > 0)\n            {\n                depthTexturePath = $\"{directory}/{skyboxInfo.DepthTexture!.name}.depth.png\";\n                Debug.Log(depthTexturePath);\n            }\n\n            var importTasks = new List<Task>(2)\n            {\n                Task.Run(async () =>\n                {\n                    if (mainTextureBytes.Length > 0)\n                    {\n                        await SaveTextureAsync(mainTexturePath, mainTextureBytes);\n                    }\n                }),\n                Task.Run(async () =>\n                {", "                    if (mainTextureBytes.Length > 0)\n                    {\n                        await SaveTextureAsync(mainTexturePath, mainTextureBytes);\n                    }\n                }),\n                Task.Run(async () =>\n                {\n                    if (depthTextureBytes.Length > 0)\n                    {\n                        await SaveTextureAsync(depthTexturePath, depthTextureBytes);\n                    }\n                })\n            };\n\n            await Task.WhenAll(importTasks);\n            await Awaiters.UnityMainThread;\n", "            if (AssetImporter.GetAtPath(mainTexturePath) is TextureImporter mainTextureImporter)\n            {\n                mainTextureImporter.alphaIsTransparency = false;\n                mainTextureImporter.alphaSource = TextureImporterAlphaSource.None;\n            }\n\n            if (AssetImporter.GetAtPath(depthTexturePath) is TextureImporter depthTextureImporter)\n            {\n                depthTextureImporter.alphaIsTransparency = false;\n                depthTextureImporter.alphaSource = TextureImporterAlphaSource.None;\n            }\n\n            EditorApplication.delayCall += () =>\n            {\n                AssetDatabase.Refresh();\n                var mainTexture = AssetDatabase.LoadAssetAtPath<Texture2D>(mainTexturePath);\n                EditorGUIUtility.PingObject(mainTexture);\n            };\n        }\n", "        private static async Task SaveTextureAsync(string path, byte[] pngBytes)\n        {\n            var fileStream = File.OpenWrite(path);\n\n            try\n            {\n                await fileStream.WriteAsync(pngBytes, 0, pngBytes.Length);\n            }\n            catch (Exception e)\n            {\n                Debug.LogError($\"Failed to write texture to disk!\\n{e}\");\n            }\n            finally\n            {\n                await fileStream.DisposeAsync();\n            }\n        }\n", "            catch (Exception e)\n            {\n                Debug.LogError($\"Failed to write texture to disk!\\n{e}\");\n            }\n            finally\n            {\n                await fileStream.DisposeAsync();\n            }\n        }\n\n        private void RenderHistory()\n        {\n            EditorGUILayout.BeginHorizontal();\n            GUILayout.Space(TabWidth);\n            { //Header\n                EditorGUILayout.LabelField(\"History\", EditorStyles.boldLabel, wideColumnWidthOption);\n\n                GUI.enabled = !isFetchingSkyboxHistory;", "        private void RenderHistory()\n        {\n            EditorGUILayout.BeginHorizontal();\n            GUILayout.Space(TabWidth);\n            { //Header\n                EditorGUILayout.LabelField(\"History\", EditorStyles.boldLabel, wideColumnWidthOption);\n\n                GUI.enabled = !isFetchingSkyboxHistory;\n                if (history != null && page > 0 && GUILayout.Button(\"Prev Page\"))\n                {\n                    page--;\n                    EditorApplication.delayCall += FetchSkyboxHistory;\n                }\n", "                if (history != null && page > 0 && GUILayout.Button(\"Prev Page\"))\n                {\n                    page--;\n                    EditorApplication.delayCall += FetchSkyboxHistory;\n                }\n\n                if (history is { HasMore: true } && GUILayout.Button(\"Next Page\"))\n                {\n                    page++;\n                    EditorApplication.delayCall += FetchSkyboxHistory;\n                }\n\n                EditorGUI.BeginChangeCheck();\n                limit = EditorGUILayout.IntField(\"page items\", limit);\n", "                if (EditorGUI.EndChangeCheck())\n                {\n                    if (limit > 100)\n                    {\n                        limit = 100;\n                    }\n\n                    if (limit < 1)\n                    {\n                        limit = 1;\n                    }\n                }\n\n                GUILayout.FlexibleSpace();\n", "                if (GUILayout.Button(refreshContent, defaultColumnWidthOption))\n                {\n                    EditorApplication.delayCall += FetchSkyboxHistory;\n                }\n\n                GUI.enabled = true;\n            }\n            GUILayout.Space(EndWidth);\n            EditorGUILayout.EndHorizontal();\n            EditorGUILayout.Space();\n", "            if (history == null) { return; }\n\n            EditorGUILayout.BeginHorizontal();\n            GUILayout.Space(TabWidth);\n            EditorGUILayout.BeginVertical();\n\n            foreach (var skybox in history.Skyboxes)\n            {\n                if (Rest.TryGetFileNameFromUrl(skybox.MainTextureUrl, out var mainTextureFilePath))\n                {\n                    mainTextureFilePath = Path.Combine(editorDownloadDirectory, mainTextureFilePath).Replace(\"\\\\\", \"/\").Replace(\".jpg\", \".png\");\n                }\n", "                if (Rest.TryGetFileNameFromUrl(skybox.MainTextureUrl, out var mainTextureFilePath))\n                {\n                    mainTextureFilePath = Path.Combine(editorDownloadDirectory, mainTextureFilePath).Replace(\"\\\\\", \"/\").Replace(\".jpg\", \".png\");\n                }\n\n                if (Rest.TryGetFileNameFromUrl(skybox.DepthTextureUrl, out var depthTextureFilePath))\n                {\n                    depthTextureFilePath = Path.Combine(editorDownloadDirectory, $\"{depthTextureFilePath}\").Replace(\"\\\\\", \"/\").Replace(\".jpg\", \".depth.png\");\n                }\n\n                EditorGUILayout.BeginVertical();\n                EditorGUILayout.LabelField($\"{skybox.Title} {skybox.Status} {skybox.CreatedAt}\");\n", "                if (!File.Exists(mainTextureFilePath))\n                {\n                    GUI.enabled = !loadingSkyboxes.TryGetValue(skybox.Id, out _);\n\n                    if (GUILayout.Button(\"Download\", defaultColumnWidthOption))\n                    {\n                        EditorApplication.delayCall += () =>\n                        {\n                            SaveSkyboxAsset(skybox);\n                        };\n                    }\n\n                    GUI.enabled = true;\n                }\n                else\n                {\n                    var mainLocalPath = mainTextureFilePath.Replace(Application.dataPath, \"Assets\");\n                    var mainImageAsset = AssetDatabase.LoadAssetAtPath<Texture2D>(mainLocalPath);\n", "                    if (mainImageAsset != null)\n                    {\n                        EditorGUILayout.ObjectField(mainImageAsset, typeof(Texture2D), false);\n                    }\n\n                    if (File.Exists(depthTextureFilePath))\n                    {\n                        var depthLocalPath = depthTextureFilePath.Replace(Application.dataPath, \"Assets\");\n                        var depthImageAsset = AssetDatabase.LoadAssetAtPath<Texture2D>(depthLocalPath);\n\n                        if (depthImageAsset != null)\n                        {\n                            EditorGUILayout.ObjectField(depthImageAsset, typeof(Texture2D), false);\n                        }\n                    }\n                }\n\n                EditorGUILayout.EndVertical();\n            }\n\n            EditorGUILayout.EndVertical();\n            GUILayout.Space(EndWidth);\n            EditorGUILayout.EndHorizontal();\n            EditorGUILayout.Space();\n        }\n", "                        if (depthImageAsset != null)\n                        {\n                            EditorGUILayout.ObjectField(depthImageAsset, typeof(Texture2D), false);\n                        }\n                    }\n                }\n\n                EditorGUILayout.EndVertical();\n            }\n\n            EditorGUILayout.EndVertical();\n            GUILayout.Space(EndWidth);\n            EditorGUILayout.EndHorizontal();\n            EditorGUILayout.Space();\n        }\n", "        private static async void FetchSkyboxHistory()\n        {\n            if (isFetchingSkyboxHistory) { return; }\n            isFetchingSkyboxHistory = true;\n\n            try\n            {\n                history = await api.SkyboxEndpoint.GetSkyboxHistoryAsync(new SkyboxHistoryParameters { Limit = limit, Offset = page });\n                //Debug.Log($\"history item count: {history.TotalCount} | hasMore? {history.HasMore}\");\n            }\n            catch (Exception e)\n            {\n                Debug.LogError(e);\n            }\n            finally\n            {\n                isFetchingSkyboxHistory = false;\n            }\n        }\n    }\n}\n", "            catch (Exception e)\n            {\n                Debug.LogError(e);\n            }\n            finally\n            {\n                isFetchingSkyboxHistory = false;\n            }\n        }\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Editor/AssemblyInfo.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Runtime/BlockadeLabsBaseEndpoint.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing Utilities.WebRequestRest;\n\nnamespace BlockadeLabs\n{\n    public abstract class BlockadeLabsBaseEndpoint : BaseEndPoint<BlockadeLabsClient, BlockadeLabsAuthentication, BlockadeLabsSettings>\n    {\n        protected BlockadeLabsBaseEndpoint(BlockadeLabsClient client) : base(client) { }\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Runtime/BlockadeLabsConfiguration.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing UnityEngine;\nusing Utilities.WebRequestRest.Interfaces;\n\nnamespace BlockadeLabs\n{\n    [CreateAssetMenu(fileName = nameof(BlockadeLabsConfiguration), menuName = nameof(BlockadeLabs) + \"/\" + nameof(BlockadeLabsConfiguration), order = 0)]\n    public sealed class BlockadeLabsConfiguration : ScriptableObject, IConfiguration\n    {\n        [SerializeField]\n        [Tooltip(\"The api key.\")]", "    public sealed class BlockadeLabsConfiguration : ScriptableObject, IConfiguration\n    {\n        [SerializeField]\n        [Tooltip(\"The api key.\")]\n        private string apiKey;\n\n        public string ApiKey\n        {\n            get => apiKey;\n            internal set => apiKey = value;\n        }\n\n        [SerializeField]\n        [Tooltip(\"Optional proxy domain to make requests though.\")]", "        private string proxyDomain;\n\n        public string ProxyDomain => proxyDomain;\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Runtime/BlockadeLabsAuthInfo.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing System;\nusing System.Security.Authentication;\nusing UnityEngine;\nusing Utilities.WebRequestRest.Interfaces;\n\nnamespace BlockadeLabs\n{\n    [Serializable]\n    public sealed class BlockadeLabsAuthInfo : IAuthInfo\n    {\n        public BlockadeLabsAuthInfo(string apiKey)\n        {", "{\n    [Serializable]\n    public sealed class BlockadeLabsAuthInfo : IAuthInfo\n    {\n        public BlockadeLabsAuthInfo(string apiKey)\n        {\n            if (string.IsNullOrWhiteSpace(apiKey))\n            {\n                throw new InvalidCredentialException(nameof(apiKey));\n            }\n\n            this.apiKey = apiKey;\n        }\n\n        [SerializeField]", "        private string apiKey;\n\n        /// <summary>\n        /// The API key, required to access the service.\n        /// </summary>\n        public string ApiKey => apiKey;\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Runtime/BlockadeLabsAuthentication.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing System;\nusing System.IO;\nusing System.Linq;\nusing UnityEngine;\nusing Utilities.WebRequestRest.Interfaces;\n\nnamespace BlockadeLabs\n{\n    public sealed class BlockadeLabsAuthentication : AbstractAuthentication<BlockadeLabsAuthentication, BlockadeLabsAuthInfo>\n    {\n        internal const string CONFIG_FILE = \".blockadelabs\";", "namespace BlockadeLabs\n{\n    public sealed class BlockadeLabsAuthentication : AbstractAuthentication<BlockadeLabsAuthentication, BlockadeLabsAuthInfo>\n    {\n        internal const string CONFIG_FILE = \".blockadelabs\";\n        private const string BLOCKADE_LABS_API_KEY = nameof(BLOCKADE_LABS_API_KEY);\n\n        public static implicit operator BlockadeLabsAuthentication(string apiKey) => new BlockadeLabsAuthentication(apiKey);\n\n        /// <summary>\n        /// Instantiates a new Authentication object that will load the default config.\n        /// </summary>\n        public BlockadeLabsAuthentication()\n        {", "            if (cachedDefault != null)\n            {\n                return;\n            }\n\n            cachedDefault = (LoadFromAsset<BlockadeLabsConfiguration>() ??\n                             LoadFromDirectory()) ??\n                             LoadFromDirectory(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile)) ??\n                             LoadFromEnvironment();\n            Info = cachedDefault?.Info;\n        }\n\n        /// <summary>\n        /// Instantiates a new Authentication object with the given <paramref name=\"apiKey\"/>, which may be <see langword=\"null\"/>.\n        /// </summary>\n        /// <param name=\"apiKey\">The API key, required to access the API endpoint.</param>\n        public BlockadeLabsAuthentication(string apiKey) => Info = new BlockadeLabsAuthInfo(apiKey);\n\n        /// <summary>\n        /// Instantiates a new Authentication object with the given <paramref name=\"authInfo\"/>, which may be <see langword=\"null\"/>.\n        /// </summary>\n        /// <param name=\"authInfo\"></param>\n        public BlockadeLabsAuthentication(BlockadeLabsAuthInfo authInfo) => Info = authInfo;\n\n        /// <inheritdoc />", "        public override BlockadeLabsAuthInfo Info { get; }\n\n        private static BlockadeLabsAuthentication cachedDefault;\n\n        /// <summary>\n        /// The default authentication to use when no other auth is specified.\n        /// This can be set manually, or automatically loaded via environment variables or a config file.\n        /// <seealso cref=\"LoadFromEnvironment\"/><seealso cref=\"LoadFromDirectory\"/>\n        /// </summary>\n        public static BlockadeLabsAuthentication Default\n        {\n            get => cachedDefault ??= new BlockadeLabsAuthentication();\n            internal set => cachedDefault = value;\n        }\n\n        /// <inheritdoc />", "        public static BlockadeLabsAuthentication Default\n        {\n            get => cachedDefault ??= new BlockadeLabsAuthentication();\n            internal set => cachedDefault = value;\n        }\n\n        /// <inheritdoc />\n        public override BlockadeLabsAuthentication LoadFromAsset<T>()\n            => Resources.LoadAll<T>(string.Empty)\n                .Where(asset => asset != null)\n                .Where(asset => asset is BlockadeLabsConfiguration config &&\n                                !string.IsNullOrWhiteSpace(config.ApiKey))\n                .Select(asset => asset is BlockadeLabsConfiguration config\n                    ? new BlockadeLabsAuthentication(config.ApiKey)\n                    : null)\n                .FirstOrDefault();\n\n        /// <inheritdoc />", "        public override BlockadeLabsAuthentication LoadFromEnvironment()\n        {\n            var apiKey = Environment.GetEnvironmentVariable(BLOCKADE_LABS_API_KEY);\n            return string.IsNullOrEmpty(apiKey) ? null : new BlockadeLabsAuthentication(apiKey);\n        }\n\n        /// <inheritdoc />\n        /// ReSharper disable once OptionalParameterHierarchyMismatch\n        public override BlockadeLabsAuthentication LoadFromDirectory(string directory = null, string filename = CONFIG_FILE, bool searchUp = true)\n        {\n            if (string.IsNullOrWhiteSpace(directory))\n            {\n                directory = Environment.CurrentDirectory;\n            }\n\n            BlockadeLabsAuthInfo tempAuthInfo = null;\n\n            var currentDirectory = new DirectoryInfo(directory);\n", "        public override BlockadeLabsAuthentication LoadFromDirectory(string directory = null, string filename = CONFIG_FILE, bool searchUp = true)\n        {\n            if (string.IsNullOrWhiteSpace(directory))\n            {\n                directory = Environment.CurrentDirectory;\n            }\n\n            BlockadeLabsAuthInfo tempAuthInfo = null;\n\n            var currentDirectory = new DirectoryInfo(directory);\n", "            while (tempAuthInfo == null && currentDirectory.Parent != null)\n            {\n                var filePath = Path.Combine(currentDirectory.FullName, filename);\n\n                if (File.Exists(filePath))\n                {\n                    try\n                    {\n                        tempAuthInfo = JsonUtility.FromJson<BlockadeLabsAuthInfo>(File.ReadAllText(filePath));\n                        break;\n                    }", "                    catch (Exception)\n                    {\n                        // try to parse the old way for backwards support.\n                    }\n\n                    var lines = File.ReadAllLines(filePath);\n                    string apiKey = null;\n\n                    foreach (var line in lines)\n                    {\n                        var parts = line.Split('=', ':');\n", "                    foreach (var line in lines)\n                    {\n                        var parts = line.Split('=', ':');\n\n                        for (var i = 0; i < parts.Length - 1; i++)\n                        {\n                            var part = parts[i];\n                            var nextPart = parts[i + 1];\n\n                            switch (part)\n                            {\n                                case BLOCKADE_LABS_API_KEY:\n                                    apiKey = nextPart.Trim();\n                                    break;\n                            }\n                        }\n                    }\n\n                    tempAuthInfo = new BlockadeLabsAuthInfo(apiKey);\n                }\n", "                if (searchUp)\n                {\n                    currentDirectory = currentDirectory.Parent;\n                }\n                else\n                {\n                    break;\n                }\n            }\n\n            if (tempAuthInfo == null ||\n                string.IsNullOrEmpty(tempAuthInfo.ApiKey))\n            {\n                return null;\n            }\n\n            return new BlockadeLabsAuthentication(tempAuthInfo);\n        }\n    }\n}\n", "            if (tempAuthInfo == null ||\n                string.IsNullOrEmpty(tempAuthInfo.ApiKey))\n            {\n                return null;\n            }\n\n            return new BlockadeLabsAuthentication(tempAuthInfo);\n        }\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Runtime/BlockadeLabsClient.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing BlockadeLabs.Skyboxes;\nusing Newtonsoft.Json;\nusing System.Collections.Generic;\nusing System.Security.Authentication;\nusing Utilities.WebRequestRest;\n\nnamespace BlockadeLabs\n{\n    public sealed class BlockadeLabsClient : BaseClient<BlockadeLabsAuthentication, BlockadeLabsSettings>\n    {\n        public BlockadeLabsClient(BlockadeLabsAuthentication authentication = null, BlockadeLabsSettings settings = null)\n            : base(authentication ?? BlockadeLabsAuthentication.Default, settings ?? BlockadeLabsSettings.Default)\n        {\n            JsonSerializationOptions = new JsonSerializerSettings\n            {\n                DefaultValueHandling = DefaultValueHandling.Ignore\n            };\n\n            SkyboxEndpoint = new SkyboxEndpoint(this);\n        }\n", "namespace BlockadeLabs\n{\n    public sealed class BlockadeLabsClient : BaseClient<BlockadeLabsAuthentication, BlockadeLabsSettings>\n    {\n        public BlockadeLabsClient(BlockadeLabsAuthentication authentication = null, BlockadeLabsSettings settings = null)\n            : base(authentication ?? BlockadeLabsAuthentication.Default, settings ?? BlockadeLabsSettings.Default)\n        {\n            JsonSerializationOptions = new JsonSerializerSettings\n            {\n                DefaultValueHandling = DefaultValueHandling.Ignore\n            };\n\n            SkyboxEndpoint = new SkyboxEndpoint(this);\n        }\n", "        protected override void ValidateAuthentication()\n        {\n            if (!HasValidAuthentication)\n            {\n                throw new AuthenticationException(\"You must provide API authentication.  Please refer to https://github.com/RageAgainstThePixel/com.rest.blockadelabs#authentication for details.\");\n            }\n        }\n\n        protected override void SetupDefaultRequestHeaders()\n        {\n            DefaultRequestHeaders = new Dictionary<string, string>\n            {\n#if !UNITY_WEBGL\n                {\"User-Agent\", \"com.rest.blockadelabs\" },\n#endif\n                {\"x-api-key\", Authentication.Info.ApiKey }\n            };\n        }\n", "        protected override void SetupDefaultRequestHeaders()\n        {\n            DefaultRequestHeaders = new Dictionary<string, string>\n            {\n#if !UNITY_WEBGL\n                {\"User-Agent\", \"com.rest.blockadelabs\" },\n#endif\n                {\"x-api-key\", Authentication.Info.ApiKey }\n            };\n        }\n", "        public override bool HasValidAuthentication => !string.IsNullOrWhiteSpace(Authentication?.Info?.ApiKey);\n\n        internal JsonSerializerSettings JsonSerializationOptions { get; }\n\n        public SkyboxEndpoint SkyboxEndpoint { get; }\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Runtime/BlockadeLabsSettings.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing System.Linq;\nusing UnityEngine;\nusing Utilities.WebRequestRest.Interfaces;\n\nnamespace BlockadeLabs\n{\n    public sealed class BlockadeLabsSettings : ISettings\n    {\n        public BlockadeLabsSettings()\n        {", "    public sealed class BlockadeLabsSettings : ISettings\n    {\n        public BlockadeLabsSettings()\n        {\n            if (cachedDefault != null) { return; }\n\n            var config = Resources.LoadAll<BlockadeLabsConfiguration>(string.Empty)\n                .FirstOrDefault(asset => asset != null);\n\n            if (config != null)\n            {\n                Info = new BlockadeLabsSettingsInfo(config.ProxyDomain);\n                Default = new BlockadeLabsSettings(Info);\n            }\n            else\n            {\n                Info = new BlockadeLabsSettingsInfo();\n                Default = new BlockadeLabsSettings(Info);\n            }\n        }\n\n        public BlockadeLabsSettings(BlockadeLabsSettingsInfo settingsInfo)\n            => Info = settingsInfo;\n\n        public BlockadeLabsSettings(string domain)\n            => Info = new BlockadeLabsSettingsInfo(domain);\n", "            if (config != null)\n            {\n                Info = new BlockadeLabsSettingsInfo(config.ProxyDomain);\n                Default = new BlockadeLabsSettings(Info);\n            }\n            else\n            {\n                Info = new BlockadeLabsSettingsInfo();\n                Default = new BlockadeLabsSettings(Info);\n            }\n        }\n\n        public BlockadeLabsSettings(BlockadeLabsSettingsInfo settingsInfo)\n            => Info = settingsInfo;\n\n        public BlockadeLabsSettings(string domain)\n            => Info = new BlockadeLabsSettingsInfo(domain);\n", "        private static BlockadeLabsSettings cachedDefault;\n\n        public static BlockadeLabsSettings Default\n        {\n            get => cachedDefault ??= new BlockadeLabsSettings();\n            internal set => cachedDefault = value;\n        }\n\n        public BlockadeLabsSettingsInfo Info { get; }\n\n        public string BaseRequestUrlFormat => Info.BaseRequestUrlFormat;\n    }\n}\n", "        public BlockadeLabsSettingsInfo Info { get; }\n\n        public string BaseRequestUrlFormat => Info.BaseRequestUrlFormat;\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Runtime/AssemblyInfo.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing System.Runtime.CompilerServices;\n\n[assembly: InternalsVisibleTo(\"BlockadeLabs.Tests\")]\n[assembly: InternalsVisibleTo(\"BlockadeLabs.Editor\")]\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Runtime/BlockadeLabsSettingsInfo.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing System;\nusing Utilities.WebRequestRest.Interfaces;\n\nnamespace BlockadeLabs\n{\n    public sealed class BlockadeLabsSettingsInfo : ISettingsInfo\n    {\n        internal const string DefaultDomain = \"backend.blockadelabs.com\";\n        internal const string DefaultVersion = \"v1\";\n\n        public BlockadeLabsSettingsInfo()\n        {\n            Domain = DefaultDomain;\n            BaseRequestUrlFormat = $\"https://{Domain}/api/{DefaultVersion}/{{0}}\";\n        }\n\n        public BlockadeLabsSettingsInfo(string domain)\n        {", "            if (string.IsNullOrWhiteSpace(domain))\n            {\n                domain = DefaultDomain;\n            }\n\n            if (!domain.Contains('.') &&\n                !domain.Contains(':'))\n            {\n                throw new ArgumentException($\"Invalid parameter \\\"{nameof(domain)}\\\"\");\n            }\n\n            Domain = domain;\n            BaseRequestUrlFormat = $\"https://{Domain}/api/{DefaultVersion}/{{0}}\";\n        }\n", "        public string Domain { get; }\n\n        public string BaseRequestUrlFormat { get; }\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Runtime/Skyboxes/SkyboxStyle.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing Newtonsoft.Json;\nusing System;\nusing UnityEngine;\n\nnamespace BlockadeLabs.Skyboxes\n{\n    [Serializable]\n    public sealed class SkyboxStyle\n    {\n        [JsonConstructor]\n        public SkyboxStyle(\n            [JsonProperty(\"id\")] int id,\n            [JsonProperty(\"name\")] string name,\n            [JsonProperty(\"max-char\")] string maxChar,\n            [JsonProperty(\"negative-text-max-char\")] int negativeTextMaxChar,\n            [JsonProperty(\"image\")] string image,\n            [JsonProperty(\"sort_order\")] int sortOrder)\n        {\n            this.id = id;\n            this.name = name;\n            MaxChar = maxChar;\n            NegativeTextMaxChar = negativeTextMaxChar;\n            Image = image;\n            SortOrder = sortOrder;\n        }\n\n        [SerializeField]", "    [Serializable]\n    public sealed class SkyboxStyle\n    {\n        [JsonConstructor]\n        public SkyboxStyle(\n            [JsonProperty(\"id\")] int id,\n            [JsonProperty(\"name\")] string name,\n            [JsonProperty(\"max-char\")] string maxChar,\n            [JsonProperty(\"negative-text-max-char\")] int negativeTextMaxChar,\n            [JsonProperty(\"image\")] string image,\n            [JsonProperty(\"sort_order\")] int sortOrder)\n        {\n            this.id = id;\n            this.name = name;\n            MaxChar = maxChar;\n            NegativeTextMaxChar = negativeTextMaxChar;\n            Image = image;\n            SortOrder = sortOrder;\n        }\n\n        [SerializeField]", "        private string name;\n\n        [JsonProperty(\"name\")]\n        public string Name => name;\n\n        [SerializeField]\n        private int id;\n\n        [JsonProperty(\"id\")]\n        public int Id => id;\n\n        [JsonProperty(\"max-char\")]", "        public int Id => id;\n\n        [JsonProperty(\"max-char\")]\n        public string MaxChar { get; }\n\n        [JsonProperty(\"negative-text-max-char\")]\n        public int NegativeTextMaxChar { get; }\n\n        [JsonProperty(\"image\")]\n        public string Image { get; }\n\n        [JsonProperty(\"sort_order\")]", "        public string Image { get; }\n\n        [JsonProperty(\"sort_order\")]\n        public int SortOrder { get; }\n\n        public static implicit operator int(SkyboxStyle style) => style.Id;\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Runtime/Skyboxes/SkyboxHistory.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing System.Collections.Generic;\nusing Newtonsoft.Json;\n\nnamespace BlockadeLabs.Skyboxes\n{\n    public sealed class SkyboxHistory\n    {\n        [JsonConstructor]\n        public SkyboxHistory(\n            [JsonProperty(\"data\")] List<SkyboxInfo> skyboxes,\n            [JsonProperty(\"totalCount\")] int totalCount,\n            [JsonProperty(\"has_more\")] bool hasMore)\n        {\n            Skyboxes = skyboxes;\n            TotalCount = totalCount;\n            HasMore = hasMore;\n        }\n\n        [JsonProperty(\"data\")]\n        public IReadOnlyList<SkyboxInfo> Skyboxes { get; }\n\n        [JsonProperty(\"totalCount\")]", "        public int TotalCount { get; }\n\n        [JsonProperty(\"has_more\")]\n        public bool HasMore { get; }\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Runtime/Skyboxes/SkyboxInfo.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Converters;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing UnityEngine;\nusing Utilities.WebRequestRest;", "using UnityEngine;\nusing Utilities.WebRequestRest;\n\nnamespace BlockadeLabs.Skyboxes\n{\n    public sealed class SkyboxInfo\n    {\n        [JsonConstructor]\n        public SkyboxInfo(\n            [JsonProperty(\"id\")] int id,\n            [JsonProperty(\"skybox_style_id\")] int skyboxStyleId,\n            [JsonProperty(\"skybox_style_name\")] string skyboxStyleName,\n            [JsonProperty(\"status\")] Status status,\n            [JsonProperty(\"queue_position\")] int queuePosition,\n            [JsonProperty(\"type\")] string type,\n            [JsonProperty(\"file_url\")] string mainTextureUrl,\n            [JsonProperty(\"thumb_url\")] string thumbUrl,\n            [JsonProperty(\"depth_map_url\")] string depthTextureUrl,\n            [JsonProperty(\"title\")] string title,\n            [JsonProperty(\"obfuscated_id\")] string obfuscatedId,\n            [JsonProperty(\"created_at\")] DateTime createdAt,\n            [JsonProperty(\"updated_at\")] DateTime updatedAt,\n            [JsonProperty(\"dispatched_at\")] DateTime dispatchedAt,\n            [JsonProperty(\"processing_at\")] DateTime processingAt,\n            [JsonProperty(\"completed_at\")] DateTime completedAt,\n            [JsonProperty(\"error_message\")] string errorMessage = null)\n        {\n            Id = id;\n            SkyboxStyleId = skyboxStyleId;\n            SkyboxStyleName = skyboxStyleName;\n            Status = status;\n            QueuePosition = queuePosition;\n            Type = type;\n            MainTextureUrl = mainTextureUrl;\n            ThumbUrl = thumbUrl;\n            DepthTextureUrl = depthTextureUrl;\n            Title = title;\n            ObfuscatedId = obfuscatedId;\n            CreatedAt = createdAt;\n            UpdatedAt = updatedAt;\n            DispatchedAt = dispatchedAt;\n            ProcessingAt = processingAt;\n            CompletedAt = completedAt;\n            ErrorMessage = errorMessage;\n        }\n\n        [JsonProperty(\"id\")]", "        public int Id { get; }\n\n        [JsonProperty(\"skybox_style_id\")]\n        public int SkyboxStyleId { get; }\n\n        [JsonProperty(\"skybox_style_name\")]\n        public string SkyboxStyleName { get; }\n\n        [JsonProperty(\"status\")]\n        [JsonConverter(typeof(StringEnumConverter))]\n        public Status Status { get; }\n\n        [JsonProperty(\"queue_position\")]", "        public Status Status { get; }\n\n        [JsonProperty(\"queue_position\")]\n        public int QueuePosition { get; }\n\n        [JsonProperty(\"type\")]\n        public string Type { get; }\n\n        [JsonProperty(\"file_url\")]\n        public string MainTextureUrl { get; }\n\n        [JsonIgnore]", "        public string MainTextureUrl { get; }\n\n        [JsonIgnore]\n        public Texture2D MainTexture { get; internal set; }\n\n        [JsonProperty(\"thumb_url\")]\n        public string ThumbUrl { get; }\n\n        [JsonIgnore]\n        public Texture2D Thumbnail { get; internal set; }\n\n        [JsonProperty(\"depth_map_url\")]", "        public Texture2D Thumbnail { get; internal set; }\n\n        [JsonProperty(\"depth_map_url\")]\n        public string DepthTextureUrl { get; }\n\n        [JsonIgnore]\n        public Texture2D DepthTexture { get; internal set; }\n\n        [JsonProperty(\"title\")]\n        public string Title { get; }\n\n        [JsonProperty(\"obfuscated_id\")]", "        public string Title { get; }\n\n        [JsonProperty(\"obfuscated_id\")]\n        public string ObfuscatedId { get; }\n\n        [JsonProperty(\"created_at\")]\n        public DateTime CreatedAt { get; }\n\n        [JsonProperty(\"updated_at\")]\n        public DateTime UpdatedAt { get; }\n\n        [JsonProperty(\"dispatched_at\")]", "        public DateTime UpdatedAt { get; }\n\n        [JsonProperty(\"dispatched_at\")]\n        public DateTime DispatchedAt { get; }\n\n        [JsonProperty(\"processing_at\")]\n        public DateTime ProcessingAt { get; }\n\n        [JsonProperty(\"completed_at\")]\n        public DateTime CompletedAt { get; }\n\n        [JsonProperty(\"error_message\")]", "        public DateTime CompletedAt { get; }\n\n        [JsonProperty(\"error_message\")]\n        public string ErrorMessage { get; set; }\n\n        public override string ToString() => JsonConvert.SerializeObject(this, Formatting.Indented);\n\n        public static implicit operator int(SkyboxInfo skyboxInfo) => skyboxInfo.Id;\n\n        /// <summary>\n        /// Loads the textures for this skybox.\n        /// </summary>\n        /// <param name=\"cancellationToken\">Optional, <see cref=\"CancellationToken\"/>.</param>", "        public async Task LoadTexturesAsync(CancellationToken cancellationToken = default)\n        {\n            var downloadTasks = new List<Task>(2)\n            {\n                Task.Run(async () =>\n                {\n                    if (!string.IsNullOrWhiteSpace(ThumbUrl))\n                    {\n                        Thumbnail = await Rest.DownloadTextureAsync(ThumbUrl, parameters:null, cancellationToken: cancellationToken);\n                    }\n                }, cancellationToken),\n                Task.Run(async () =>\n                {", "                    if (!string.IsNullOrWhiteSpace(MainTextureUrl))\n                    {\n                        MainTexture = await Rest.DownloadTextureAsync(MainTextureUrl, parameters: null, cancellationToken: cancellationToken);\n                    }\n                }, cancellationToken),\n                Task.Run(async () =>\n                {\n                    if (!string.IsNullOrWhiteSpace(DepthTextureUrl))\n                    {\n                        DepthTexture = await Rest.DownloadTextureAsync(DepthTextureUrl, parameters: null, cancellationToken: cancellationToken);\n                    }\n                }, cancellationToken)\n            };\n\n            await Task.WhenAll(downloadTasks).ConfigureAwait(true);\n        }\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Runtime/Skyboxes/Status.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nnamespace BlockadeLabs.Skyboxes\n{\n    public enum Status\n    {\n        All,\n        Pending,\n        Dispatched,\n        Processing,\n        Complete,\n        Abort,\n        Error\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Runtime/Skyboxes/SortOrder.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nnamespace BlockadeLabs.Skyboxes\n{\n    public enum SortOrder\n    {\n        Desc,\n        Asc\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Runtime/Skyboxes/SkyboxEndpoint.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing Newtonsoft.Json;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing UnityEngine;\nusing UnityEngine.Scripting;", "using UnityEngine;\nusing UnityEngine.Scripting;\nusing Utilities.WebRequestRest;\n\nnamespace BlockadeLabs.Skyboxes\n{\n    public sealed class SkyboxEndpoint : BlockadeLabsBaseEndpoint\n    {\n        [Preserve]\n        private class SkyboxInfoRequest\n        {\n            [Preserve]\n            [JsonConstructor]\n            public SkyboxInfoRequest([JsonProperty(\"request\")] SkyboxInfo skyboxInfo)\n            {\n                SkyboxInfo = skyboxInfo;\n            }\n\n            [Preserve]\n            [JsonProperty(\"request\")]", "        private class SkyboxInfoRequest\n        {\n            [Preserve]\n            [JsonConstructor]\n            public SkyboxInfoRequest([JsonProperty(\"request\")] SkyboxInfo skyboxInfo)\n            {\n                SkyboxInfo = skyboxInfo;\n            }\n\n            [Preserve]\n            [JsonProperty(\"request\")]", "            public SkyboxInfo SkyboxInfo { get; }\n        }\n\n        [Preserve]\n        private class SkyboxOperation\n        {\n            [Preserve]\n            [JsonConstructor]\n            public SkyboxOperation(\n                [JsonProperty(\"success\")] string success,\n                [JsonProperty(\"error\")] string error)\n            {\n                Success = success;\n                Error = error;\n            }\n\n            [Preserve]\n            [JsonProperty(\"success\")]", "            public string Success { get; }\n\n            [Preserve]\n            [JsonProperty(\"Error\")]\n            public string Error { get; }\n        }\n\n        public SkyboxEndpoint(BlockadeLabsClient client) : base(client) { }\n\n        protected override string Root => string.Empty;\n\n        /// <summary>\n        /// Returns the list of predefined styles that can influence the overall aesthetic of your skybox generation.\n        /// </summary>\n        /// <param name=\"cancellationToken\">Optional, <see cref=\"CancellationToken\"/>.</param>\n        /// <returns>A list of <see cref=\"SkyboxStyle\"/>s.</returns>", "        protected override string Root => string.Empty;\n\n        /// <summary>\n        /// Returns the list of predefined styles that can influence the overall aesthetic of your skybox generation.\n        /// </summary>\n        /// <param name=\"cancellationToken\">Optional, <see cref=\"CancellationToken\"/>.</param>\n        /// <returns>A list of <see cref=\"SkyboxStyle\"/>s.</returns>\n        public async Task<IReadOnlyList<SkyboxStyle>> GetSkyboxStylesAsync(CancellationToken cancellationToken = default)\n        {\n            var response = await Rest.GetAsync(GetUrl(\"skybox/styles\"), parameters: new RestParameters(client.DefaultRequestHeaders), cancellationToken);\n            response.Validate();\n            return JsonConvert.DeserializeObject<IReadOnlyList<SkyboxStyle>>(response.Body, client.JsonSerializationOptions);\n        }\n\n        /// <summary>\n        /// Generate a skybox image.\n        /// </summary>\n        /// <param name=\"skyboxRequest\"><see cref=\"SkyboxRequest\"/>.</param>\n        /// <param name=\"pollingInterval\">Optional, polling interval in seconds.</param>\n        /// <param name=\"cancellationToken\">Optional, <see cref=\"CancellationToken\"/>.</param>\n        /// <returns><see cref=\"SkyboxInfo\"/>.</returns>", "        public async Task<SkyboxInfo> GenerateSkyboxAsync(SkyboxRequest skyboxRequest, int? pollingInterval = null, CancellationToken cancellationToken = default)\n        {\n            var formData = new WWWForm();\n            formData.AddField(\"prompt\", skyboxRequest.Prompt);\n\n            if (!string.IsNullOrWhiteSpace(skyboxRequest.NegativeText))\n            {\n                formData.AddField(\"negative_text\", skyboxRequest.NegativeText);\n            }\n\n            if (skyboxRequest.Seed.HasValue)\n            {\n                formData.AddField(\"seed\", skyboxRequest.Seed.Value);\n            }\n", "            if (skyboxRequest.Seed.HasValue)\n            {\n                formData.AddField(\"seed\", skyboxRequest.Seed.Value);\n            }\n\n            if (skyboxRequest.SkyboxStyleId.HasValue)\n            {\n                formData.AddField(\"skybox_style_id\", skyboxRequest.SkyboxStyleId.Value);\n            }\n\n            if (skyboxRequest.RemixImagineId.HasValue)\n            {\n                formData.AddField(\"remix_imagine_id\", skyboxRequest.RemixImagineId.Value);\n            }\n", "            if (skyboxRequest.RemixImagineId.HasValue)\n            {\n                formData.AddField(\"remix_imagine_id\", skyboxRequest.RemixImagineId.Value);\n            }\n\n            if (skyboxRequest.Depth)\n            {\n                formData.AddField(\"return_depth\", skyboxRequest.Depth.ToString());\n            }\n\n            if (skyboxRequest.ControlImage != null)\n            {", "            if (skyboxRequest.ControlImage != null)\n            {\n                if (!string.IsNullOrWhiteSpace(skyboxRequest.ControlModel))\n                {\n                    formData.AddField(\"control_model\", skyboxRequest.ControlModel);\n                }\n\n                using var imageData = new MemoryStream();\n                await skyboxRequest.ControlImage.CopyToAsync(imageData, cancellationToken);\n                formData.AddBinaryData(\"control_image\", imageData.ToArray(), skyboxRequest.ControlImageFileName);\n                skyboxRequest.Dispose();\n            }\n\n            var response = await Rest.PostAsync(GetUrl(\"skybox\"), formData, parameters: new RestParameters(client.DefaultRequestHeaders), cancellationToken);\n            response.Validate();\n            var skyboxInfo = JsonConvert.DeserializeObject<SkyboxInfo>(response.Body, client.JsonSerializationOptions);\n", "            while (!cancellationToken.IsCancellationRequested)\n            {\n                await Task.Delay(pollingInterval ?? 3 * 1000, CancellationToken.None)\n                    .ConfigureAwait(true); // Configure await to make sure we're still in Unity context\n                skyboxInfo = await GetSkyboxInfoAsync(skyboxInfo, CancellationToken.None);\n\n                if (skyboxInfo.Status is Status.Pending or Status.Processing or Status.Dispatched)\n                {\n                    continue;\n                }\n\n                break;\n            }\n", "            if (cancellationToken.IsCancellationRequested)\n            {\n                var cancelResult = await CancelSkyboxGenerationAsync(skyboxInfo, CancellationToken.None);\n\n                if (!cancelResult)\n                {\n                    throw new Exception($\"Failed to cancel generation for {skyboxInfo.Id}\");\n                }\n            }\n\n            cancellationToken.ThrowIfCancellationRequested();\n", "            if (skyboxInfo.Status != Status.Complete)\n            {\n                throw new Exception($\"Failed to generate skybox! {skyboxInfo.Id} -> {skyboxInfo.Status}\\nError: {skyboxInfo.ErrorMessage}\\n{skyboxInfo}\");\n            }\n\n            await skyboxInfo.LoadTexturesAsync(cancellationToken);\n            return skyboxInfo;\n        }\n\n        /// <summary>\n        /// Returns the skybox metadata for the given skybox id.\n        /// </summary>\n        /// <param name=\"id\">Skybox Id.</param>\n        /// <param name=\"cancellationToken\">Optional, <see cref=\"CancellationToken\"/>.</param>\n        /// <returns><see cref=\"SkyboxInfo\"/>.</returns>", "        public async Task<SkyboxInfo> GetSkyboxInfoAsync(int id, CancellationToken cancellationToken = default)\n        {\n            var response = await Rest.GetAsync(GetUrl($\"imagine/requests/{id}\"), parameters: new RestParameters(client.DefaultRequestHeaders), cancellationToken);\n            response.Validate();\n            return JsonConvert.DeserializeObject<SkyboxInfoRequest>(response.Body, client.JsonSerializationOptions).SkyboxInfo;\n        }\n\n        /// <summary>\n        /// Deletes a skybox by id.\n        /// </summary>\n        /// <param name=\"id\">The id of the skybox.</param>\n        /// <param name=\"cancellationToken\">Optional, <see cref=\"CancellationToken\"/>.</param>\n        /// <returns>True, if skybox was successfully deleted.</returns>", "        public async Task<bool> DeleteSkyboxAsync(int id, CancellationToken cancellationToken = default)\n        {\n            var response = await Rest.DeleteAsync(GetUrl($\"imagine/deleteImagine/{id}\"), new RestParameters(client.DefaultRequestHeaders), cancellationToken);\n            response.Validate();\n            var skyboxOp = JsonConvert.DeserializeObject<SkyboxOperation>(response.Body, client.JsonSerializationOptions);\n\n            const string successStatus = \"Item deleted successfully\";\n\n            if (skyboxOp is not { Success: successStatus })\n            {\n                throw new Exception($\"Failed to cancel generation for skybox {id}!\\n{skyboxOp?.Error}\");\n            }\n\n            return skyboxOp.Success.Equals(successStatus);\n        }\n\n        /// <summary>\n        /// Gets the previously generated skyboxes.\n        /// </summary>\n        /// <param name=\"parameters\">Optional, <see cref=\"SkyboxHistoryParameters\"/>.</param>\n        /// <param name=\"cancellationToken\">Optional, <see cref=\"CancellationToken\"/>.</param>\n        /// <returns><see cref=\"SkyboxHistory\"/>.</returns>", "            if (skyboxOp is not { Success: successStatus })\n            {\n                throw new Exception($\"Failed to cancel generation for skybox {id}!\\n{skyboxOp?.Error}\");\n            }\n\n            return skyboxOp.Success.Equals(successStatus);\n        }\n\n        /// <summary>\n        /// Gets the previously generated skyboxes.\n        /// </summary>\n        /// <param name=\"parameters\">Optional, <see cref=\"SkyboxHistoryParameters\"/>.</param>\n        /// <param name=\"cancellationToken\">Optional, <see cref=\"CancellationToken\"/>.</param>\n        /// <returns><see cref=\"SkyboxHistory\"/>.</returns>", "        public async Task<SkyboxHistory> GetSkyboxHistoryAsync(SkyboxHistoryParameters parameters = null, CancellationToken cancellationToken = default)\n        {\n            var historyRequest = parameters ?? new SkyboxHistoryParameters();\n            var response = await Rest.GetAsync(GetUrl($\"imagine/myRequests{historyRequest}\"), parameters: new RestParameters(client.DefaultRequestHeaders), cancellationToken);\n            response.Validate();\n            return JsonConvert.DeserializeObject<SkyboxHistory>(response.Body, client.JsonSerializationOptions);\n        }\n\n        /// <summary>\n        /// Cancels a pending skybox generation request by id.\n        /// </summary>\n        /// <param name=\"id\">The id of the skybox.</param>\n        /// <param name=\"cancellationToken\">Optional, <see cref=\"CancellationToken\"/>.</param>\n        /// <returns>True, if generation was cancelled.</returns>", "        public async Task<bool> CancelSkyboxGenerationAsync(int id, CancellationToken cancellationToken = default)\n        {\n            var response = await Rest.DeleteAsync(GetUrl($\"imagine/requests/{id}\"), new RestParameters(client.DefaultRequestHeaders), cancellationToken);\n            response.Validate();\n            var skyboxOp = JsonConvert.DeserializeObject<SkyboxOperation>(response.Body, client.JsonSerializationOptions);\n\n            if (skyboxOp is not { Success: \"true\" })\n            {\n                throw new Exception($\"Failed to cancel generation for skybox {id}!\\n{skyboxOp?.Error}\");\n            }\n\n            return skyboxOp.Success.Equals(\"true\");\n        }\n\n        /// <summary>\n        /// Cancels ALL pending skybox generation requests.\n        /// </summary>\n        /// <param name=\"cancellationToken\">Optional, <see cref=\"CancellationToken\"/>.</param>", "        public async Task<bool> CancelAllPendingSkyboxGenerationsAsync(CancellationToken cancellationToken = default)\n        {\n            var response = await Rest.DeleteAsync(GetUrl(\"imagine/requests/pending\"), new RestParameters(client.DefaultRequestHeaders), cancellationToken);\n            response.Validate();\n            var skyboxOp = JsonConvert.DeserializeObject<SkyboxOperation>(response.Body, client.JsonSerializationOptions);\n\n            if (skyboxOp is not { Success: \"true\" })\n            {\n                if (skyboxOp != null &&\n                    skyboxOp.Error.Contains(\"You don't have any pending\"))\n                {\n                    return false;\n                }\n\n                throw new Exception($\"Failed to cancel all pending skybox generations!\\n{skyboxOp?.Error}\");\n            }\n\n            return skyboxOp.Success.Equals(\"true\");\n        }\n    }\n}\n", "                if (skyboxOp != null &&\n                    skyboxOp.Error.Contains(\"You don't have any pending\"))\n                {\n                    return false;\n                }\n\n                throw new Exception($\"Failed to cancel all pending skybox generations!\\n{skyboxOp?.Error}\");\n            }\n\n            return skyboxOp.Success.Equals(\"true\");\n        }\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Runtime/Skyboxes/SkyboxHistoryParameters.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing System.Collections.Generic;\nusing UnityEngine.Networking;\n\nnamespace BlockadeLabs.Skyboxes\n{\n    public sealed class SkyboxHistoryParameters\n    {\n        /// <summary>\n        /// Filter by status.<br/>\n        /// Options: all, pending, dispatched, processing, complete, abort, error (default: all)\n        /// </summary>\n        public Status? StatusFilter { get; set; }\n\n        /// <summary>\n        /// Number of items to be returned per page (default: 18)\n        /// </summary>\n        public int? Limit { get; set; }\n\n        /// <summary>\n        /// Page number (default: 0)\n        /// </summary>\n        public int? Offset { get; set; }\n\n        /// <summary>\n        /// Sort order. Options: ASC, DESC (default: DESC)\n        /// </summary>\n        public SortOrder? Order { get; set; }\n\n        /// <summary>\n        /// Filter by id\n        /// </summary>\n        public int? ImagineId { get; set; }\n\n        /// <summary>\n        /// Filter by title or prompt\n        /// </summary>", "        public string QueryFilter { get; set; }\n\n        /// <summary>\n        /// Filter by generator\n        /// </summary>\n        public string GeneratorFilter { get; set; }\n\n        public override string ToString()\n        {\n            var @params = new List<string>();\n", "            if (StatusFilter.HasValue)\n            {\n                @params.Add($\"status={StatusFilter.ToString().ToLower()}\");\n            }\n\n            if (Limit.HasValue)\n            {\n                @params.Add($\"limit={Limit}\");\n            }\n\n            if (Offset.HasValue)\n            {\n                @params.Add($\"offset={Offset}\");\n            }\n", "            if (Offset.HasValue)\n            {\n                @params.Add($\"offset={Offset}\");\n            }\n\n            if (Order.HasValue)\n            {\n                @params.Add($\"order={Order.ToString().ToUpper()}\");\n            }\n\n            if (ImagineId.HasValue)\n            {\n                @params.Add($\"imagine_id={ImagineId}\");\n            }\n", "            if (ImagineId.HasValue)\n            {\n                @params.Add($\"imagine_id={ImagineId}\");\n            }\n\n            if (!string.IsNullOrWhiteSpace(QueryFilter))\n            {\n                @params.Add($\"query={UnityWebRequest.EscapeURL(QueryFilter)}\");\n            }\n\n            if (!string.IsNullOrWhiteSpace(GeneratorFilter))\n            {\n                @params.Add($\"generator={UnityWebRequest.EscapeURL(GeneratorFilter)}\");\n            }\n\n            return @params.Count == 0 ? string.Empty : $\"?{string.Join('&', @params)}\";\n        }\n    }\n}\n", "            if (!string.IsNullOrWhiteSpace(GeneratorFilter))\n            {\n                @params.Add($\"generator={UnityWebRequest.EscapeURL(GeneratorFilter)}\");\n            }\n\n            return @params.Count == 0 ? string.Empty : $\"?{string.Join('&', @params)}\";\n        }\n    }\n}\n"]}
{"filename": "BlockadeLabs/Packages/com.rest.blockadelabs/Runtime/Skyboxes/SkyboxRequest.cs", "chunked_list": ["// Licensed under the MIT License. See LICENSE in the project root for license information.\n\nusing System;\nusing System.IO;\nusing UnityEngine;\n\nnamespace BlockadeLabs.Skyboxes\n{\n    public sealed class SkyboxRequest : IDisposable\n    {\n        /// <summary>\n        /// Creates a new Skybox Request.\n        /// </summary>\n        /// <param name=\"prompt\">\n        /// Text prompt describing the skybox world you wish to create.\n        /// Maximum number of characters: 550.\n        /// If you are using <see cref=\"SkyboxStyleId\"/> then the maximum number of characters is defined\n        /// in the max-char response parameter defined for each style.\n        /// </param>\n        /// <param name=\"negativeText\">\n        /// Describe things to avoid in the skybox world you wish to create.\n        /// Maximum number of characters: 200.\n        /// If you are using <see cref=\"SkyboxStyleId\"/> then the maximum number of characters is defined\n        /// in the negative-text-max-char response parameter defined for each style.\n        /// </param>\n        /// <param name=\"seed\">\n        /// Send 0 for a random seed generation.\n        /// Any other number (1-2147483647) set will be used to \"freeze\" the image generator generator and\n        /// create similar images when run again with the same seed and settings.\n        /// </param>\n        /// <param name=\"skyboxStyleId\">\n        /// Id of predefined style that influences the overall aesthetic of your skybox generation.\n        /// </param>\n        /// <param name=\"remixImagineId\">\n        /// ID of a previously generated skybox.\n        /// </param>\n        /// <param name=\"depth\">\n        /// Return depth map image.\n        /// </param>\n        public SkyboxRequest(\n            string prompt,\n            string negativeText = null,\n            int? seed = null,\n            int? skyboxStyleId = null,\n            int? remixImagineId = null,\n            bool depth = false)\n        {\n            Prompt = prompt;\n            NegativeText = negativeText;\n            Seed = seed;\n            SkyboxStyleId = skyboxStyleId;\n            RemixImagineId = remixImagineId;\n            Depth = depth;\n        }\n\n        /// <summary>\n        /// Creates a new Skybox Request.\n        /// </summary>\n        /// <param name=\"prompt\">\n        /// Text prompt describing the skybox world you wish to create.\n        /// Maximum number of characters: 550.\n        /// If you are using <see cref=\"SkyboxStyleId\"/> then the maximum number of characters is defined\n        /// in the max-char response parameter defined for each style.\n        /// </param>\n        /// <param name=\"controlImagePath\">\n        /// File path to the control image for the request.\n        /// </param>\n        /// <param name=\"controlModel\">\n        /// Model used for the <see cref=\"ControlImage\"/>.\n        /// Currently the only option is: \"scribble\".\n        /// </param>\n        /// <param name=\"negativeText\">\n        /// Describe things to avoid in the skybox world you wish to create.\n        /// Maximum number of characters: 200.\n        /// If you are using <see cref=\"SkyboxStyleId\"/> then the maximum number of characters is defined\n        /// in the negative-text-max-char response parameter defined for each style.\n        /// </param>\n        /// <param name=\"seed\">\n        /// Send 0 for a random seed generation.\n        /// Any other number (1-2147483647) set will be used to \"freeze\" the image generator generator and\n        /// create similar images when run again with the same seed and settings.\n        /// </param>\n        /// <param name=\"skyboxStyleId\">\n        /// Id of predefined style that influences the overall aesthetic of your skybox generation.\n        /// </param>\n        /// <param name=\"remixImagineId\">\n        /// ID of a previously generated skybox.\n        /// </param>\n        /// <param name=\"depth\">\n        /// Return depth map image.\n        /// </param>\n        public SkyboxRequest(\n            string prompt,\n            string controlImagePath,\n            string controlModel = null,\n            string negativeText = null,\n            int? seed = null,\n            int? skyboxStyleId = null,\n            int? remixImagineId = null,\n            bool depth = false)\n            : this(\n                prompt,\n                File.OpenRead(controlImagePath),\n                Path.GetFileName(controlImagePath),\n                controlModel,\n                negativeText,\n                seed,\n                skyboxStyleId,\n                remixImagineId,\n                depth)\n        {\n        }\n\n        /// <summary>\n        /// Creates a new Skybox Request.\n        /// </summary>\n        /// <param name=\"prompt\">\n        /// Text prompt describing the skybox world you wish to create.\n        /// Maximum number of characters: 550.\n        /// If you are using <see cref=\"SkyboxStyleId\"/> then the maximum number of characters is defined\n        /// in the max-char response parameter defined for each style.\n        /// </param>\n        /// <param name=\"controlImage\">\n        /// <see cref=\"Texture2D\"/> Control image used to influence the generation.\n        /// The image needs to be exactly 1024 pixels wide and 512 pixels tall PNG equirectangular projection image\n        /// of a scribble with black background and white brush strokes.\n        /// </param>\n        /// <param name=\"controlModel\">\n        /// Model used for the <see cref=\"ControlImage\"/>.\n        /// Currently the only option is: \"scribble\".\n        /// </param>\n        /// <param name=\"negativeText\">\n        /// Describe things to avoid in the skybox world you wish to create.\n        /// Maximum number of characters: 200.\n        /// If you are using <see cref=\"SkyboxStyleId\"/> then the maximum number of characters is defined\n        /// in the negative-text-max-char response parameter defined for each style.\n        /// </param>\n        /// <param name=\"seed\">\n        /// Send 0 for a random seed generation.\n        /// Any other number (1-2147483647) set will be used to \"freeze\" the image generator generator and\n        /// create similar images when run again with the same seed and settings.\n        /// </param>\n        /// <param name=\"skyboxStyleId\">\n        /// Id of predefined style that influences the overall aesthetic of your skybox generation.\n        /// </param>\n        /// <param name=\"remixImagineId\">\n        /// ID of a previously generated skybox.\n        /// </param>\n        /// <param name=\"depth\">\n        /// Return depth map image.\n        /// </param>\n        public SkyboxRequest(\n            string prompt,\n            Texture2D controlImage,\n            string controlModel = null,\n            string negativeText = null,\n            int? seed = null,\n            int? skyboxStyleId = null,\n            int? remixImagineId = null,\n            bool depth = false)\n            : this(\n                prompt,\n                new MemoryStream(controlImage.EncodeToPNG()),\n                !string.IsNullOrWhiteSpace(controlImage.name) ? $\"{controlImage.name}.png\" : null,\n                controlModel,\n                negativeText,\n                seed,\n                skyboxStyleId,\n                remixImagineId,\n                depth)\n        {", "    public sealed class SkyboxRequest : IDisposable\n    {\n        /// <summary>\n        /// Creates a new Skybox Request.\n        /// </summary>\n        /// <param name=\"prompt\">\n        /// Text prompt describing the skybox world you wish to create.\n        /// Maximum number of characters: 550.\n        /// If you are using <see cref=\"SkyboxStyleId\"/> then the maximum number of characters is defined\n        /// in the max-char response parameter defined for each style.\n        /// </param>\n        /// <param name=\"negativeText\">\n        /// Describe things to avoid in the skybox world you wish to create.\n        /// Maximum number of characters: 200.\n        /// If you are using <see cref=\"SkyboxStyleId\"/> then the maximum number of characters is defined\n        /// in the negative-text-max-char response parameter defined for each style.\n        /// </param>\n        /// <param name=\"seed\">\n        /// Send 0 for a random seed generation.\n        /// Any other number (1-2147483647) set will be used to \"freeze\" the image generator generator and\n        /// create similar images when run again with the same seed and settings.\n        /// </param>\n        /// <param name=\"skyboxStyleId\">\n        /// Id of predefined style that influences the overall aesthetic of your skybox generation.\n        /// </param>\n        /// <param name=\"remixImagineId\">\n        /// ID of a previously generated skybox.\n        /// </param>\n        /// <param name=\"depth\">\n        /// Return depth map image.\n        /// </param>\n        public SkyboxRequest(\n            string prompt,\n            string negativeText = null,\n            int? seed = null,\n            int? skyboxStyleId = null,\n            int? remixImagineId = null,\n            bool depth = false)\n        {\n            Prompt = prompt;\n            NegativeText = negativeText;\n            Seed = seed;\n            SkyboxStyleId = skyboxStyleId;\n            RemixImagineId = remixImagineId;\n            Depth = depth;\n        }\n\n        /// <summary>\n        /// Creates a new Skybox Request.\n        /// </summary>\n        /// <param name=\"prompt\">\n        /// Text prompt describing the skybox world you wish to create.\n        /// Maximum number of characters: 550.\n        /// If you are using <see cref=\"SkyboxStyleId\"/> then the maximum number of characters is defined\n        /// in the max-char response parameter defined for each style.\n        /// </param>\n        /// <param name=\"controlImagePath\">\n        /// File path to the control image for the request.\n        /// </param>\n        /// <param name=\"controlModel\">\n        /// Model used for the <see cref=\"ControlImage\"/>.\n        /// Currently the only option is: \"scribble\".\n        /// </param>\n        /// <param name=\"negativeText\">\n        /// Describe things to avoid in the skybox world you wish to create.\n        /// Maximum number of characters: 200.\n        /// If you are using <see cref=\"SkyboxStyleId\"/> then the maximum number of characters is defined\n        /// in the negative-text-max-char response parameter defined for each style.\n        /// </param>\n        /// <param name=\"seed\">\n        /// Send 0 for a random seed generation.\n        /// Any other number (1-2147483647) set will be used to \"freeze\" the image generator generator and\n        /// create similar images when run again with the same seed and settings.\n        /// </param>\n        /// <param name=\"skyboxStyleId\">\n        /// Id of predefined style that influences the overall aesthetic of your skybox generation.\n        /// </param>\n        /// <param name=\"remixImagineId\">\n        /// ID of a previously generated skybox.\n        /// </param>\n        /// <param name=\"depth\">\n        /// Return depth map image.\n        /// </param>\n        public SkyboxRequest(\n            string prompt,\n            string controlImagePath,\n            string controlModel = null,\n            string negativeText = null,\n            int? seed = null,\n            int? skyboxStyleId = null,\n            int? remixImagineId = null,\n            bool depth = false)\n            : this(\n                prompt,\n                File.OpenRead(controlImagePath),\n                Path.GetFileName(controlImagePath),\n                controlModel,\n                negativeText,\n                seed,\n                skyboxStyleId,\n                remixImagineId,\n                depth)\n        {\n        }\n\n        /// <summary>\n        /// Creates a new Skybox Request.\n        /// </summary>\n        /// <param name=\"prompt\">\n        /// Text prompt describing the skybox world you wish to create.\n        /// Maximum number of characters: 550.\n        /// If you are using <see cref=\"SkyboxStyleId\"/> then the maximum number of characters is defined\n        /// in the max-char response parameter defined for each style.\n        /// </param>\n        /// <param name=\"controlImage\">\n        /// <see cref=\"Texture2D\"/> Control image used to influence the generation.\n        /// The image needs to be exactly 1024 pixels wide and 512 pixels tall PNG equirectangular projection image\n        /// of a scribble with black background and white brush strokes.\n        /// </param>\n        /// <param name=\"controlModel\">\n        /// Model used for the <see cref=\"ControlImage\"/>.\n        /// Currently the only option is: \"scribble\".\n        /// </param>\n        /// <param name=\"negativeText\">\n        /// Describe things to avoid in the skybox world you wish to create.\n        /// Maximum number of characters: 200.\n        /// If you are using <see cref=\"SkyboxStyleId\"/> then the maximum number of characters is defined\n        /// in the negative-text-max-char response parameter defined for each style.\n        /// </param>\n        /// <param name=\"seed\">\n        /// Send 0 for a random seed generation.\n        /// Any other number (1-2147483647) set will be used to \"freeze\" the image generator generator and\n        /// create similar images when run again with the same seed and settings.\n        /// </param>\n        /// <param name=\"skyboxStyleId\">\n        /// Id of predefined style that influences the overall aesthetic of your skybox generation.\n        /// </param>\n        /// <param name=\"remixImagineId\">\n        /// ID of a previously generated skybox.\n        /// </param>\n        /// <param name=\"depth\">\n        /// Return depth map image.\n        /// </param>\n        public SkyboxRequest(\n            string prompt,\n            Texture2D controlImage,\n            string controlModel = null,\n            string negativeText = null,\n            int? seed = null,\n            int? skyboxStyleId = null,\n            int? remixImagineId = null,\n            bool depth = false)\n            : this(\n                prompt,\n                new MemoryStream(controlImage.EncodeToPNG()),\n                !string.IsNullOrWhiteSpace(controlImage.name) ? $\"{controlImage.name}.png\" : null,\n                controlModel,\n                negativeText,\n                seed,\n                skyboxStyleId,\n                remixImagineId,\n                depth)\n        {", "            if (controlImage.height != 512 || controlImage.width != 1024)\n            {\n                throw new ArgumentException($\"{nameof(ControlImage)} dimensions should be 512x1024\");\n            }\n        }\n\n        /// <summary>\n        /// Creates a new Skybox Request.\n        /// </summary>\n        /// <param name=\"prompt\">\n        /// Text prompt describing the skybox world you wish to create.\n        /// Maximum number of characters: 550.\n        /// If you are using <see cref=\"SkyboxStyleId\"/> then the maximum number of characters is defined\n        /// in the max-char response parameter defined for each style.\n        /// </param>\n        /// <param name=\"controlImage\">\n        /// <see cref=\"Stream\"/> data of control image for request.\n        /// </param>\n        /// <param name=\"controlImageFileName\">\n        /// File name of <see cref=\"controlImage\"/>.\n        /// </param>\n        /// <param name=\"controlModel\">\n        /// Model used for the <see cref=\"ControlImage\"/>.\n        /// Currently the only option is: \"scribble\".\n        /// </param>\n        /// <param name=\"negativeText\">\n        /// Describe things to avoid in the skybox world you wish to create.\n        /// Maximum number of characters: 200.\n        /// If you are using <see cref=\"SkyboxStyleId\"/> then the maximum number of characters is defined\n        /// in the negative-text-max-char response parameter defined for each style.\n        /// </param>\n        /// <param name=\"seed\">\n        /// Send 0 for a random seed generation.\n        /// Any other number (1-2147483647) set will be used to \"freeze\" the image generator generator and\n        /// create similar images when run again with the same seed and settings.\n        /// </param>\n        /// <param name=\"skyboxStyleId\">\n        /// Id of predefined style that influences the overall aesthetic of your skybox generation.\n        /// </param>\n        /// <param name=\"remixImagineId\">\n        /// ID of a previously generated skybox.\n        /// </param>\n        /// <param name=\"depth\">\n        /// Return depth map image.\n        /// </param>\n        public SkyboxRequest(\n            string prompt,\n            Stream controlImage,\n            string controlImageFileName,\n            string controlModel = null,\n            string negativeText = null,\n            int? seed = null,\n            int? skyboxStyleId = null,\n            int? remixImagineId = null,\n            bool depth = false)\n            : this(prompt, negativeText, seed, skyboxStyleId, remixImagineId, depth)\n        {\n            ControlImage = controlImage;\n", "            if (string.IsNullOrWhiteSpace(controlImageFileName))\n            {\n                const string defaultImageName = \"control_image.png\";\n                controlImageFileName = defaultImageName;\n            }\n\n            ControlImageFileName = controlImageFileName;\n            ControlModel = controlModel;\n        }\n\n        ~SkyboxRequest() => Dispose(false);\n\n        /// <summary>\n        /// Text prompt describing the skybox world you wish to create.\n        /// Maximum number of characters: 550.\n        /// If you are using <see cref=\"SkyboxStyleId\"/> then the maximum number of characters is defined\n        /// in the max-char response parameter defined for each style.\n        /// </summary>", "        public string Prompt { get; }\n\n        /// <summary>\n        /// Describe things to avoid in the skybox world you wish to create.\n        /// Maximum number of characters: 200.\n        /// If you are using <see cref=\"SkyboxStyleId\"/> then the maximum number of characters is defined\n        /// in the negative-text-max-char response parameter defined for each style.\n        /// </summary>\n        public string NegativeText { get; }\n\n        /// <summary>\n        /// Send 0 for a random seed generation.\n        /// Any other number (1-2147483647) set will be used to \"freeze\" the image generator generator and\n        /// create similar images when run again with the same seed and settings.\n        /// </summary>\n        public int? Seed { get; }\n\n        /// <summary>\n        /// Id of predefined style that influences the overall aesthetic of your skybox generation.\n        /// </summary>\n        public int? SkyboxStyleId { get; }\n\n        /// <summary>\n        /// ID of a previously generated skybox.\n        /// </summary>\n        public int? RemixImagineId { get; }\n\n        /// <summary>\n        /// Return depth map image.\n        /// </summary>", "        public string NegativeText { get; }\n\n        /// <summary>\n        /// Send 0 for a random seed generation.\n        /// Any other number (1-2147483647) set will be used to \"freeze\" the image generator generator and\n        /// create similar images when run again with the same seed and settings.\n        /// </summary>\n        public int? Seed { get; }\n\n        /// <summary>\n        /// Id of predefined style that influences the overall aesthetic of your skybox generation.\n        /// </summary>\n        public int? SkyboxStyleId { get; }\n\n        /// <summary>\n        /// ID of a previously generated skybox.\n        /// </summary>\n        public int? RemixImagineId { get; }\n\n        /// <summary>\n        /// Return depth map image.\n        /// </summary>", "        public bool Depth { get; }\n\n        /// <summary>\n        /// Control image used to influence the generation.\n        /// The image needs to be exactly 1024 pixels wide and 512 pixels tall PNG equirectangular projection image\n        /// of a scribble with black background and white brush strokes.\n        /// </summary>\n        public Stream ControlImage { get; }\n\n        /// <summary>\n        /// File name of <see cref=\"ControlImage\"/>.\n        /// </summary>", "        public string ControlImageFileName { get; }\n\n        /// <summary>\n        /// Model used for the <see cref=\"ControlImage\"/>.\n        /// Currently the only option is: \"scribble\".\n        /// </summary>\n        public string ControlModel { get; }\n\n        private void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                ControlImage?.Close();\n                ControlImage?.Dispose();\n            }\n        }\n", "        private void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                ControlImage?.Close();\n                ControlImage?.Dispose();\n            }\n        }\n\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n    }\n}\n", "        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n    }\n}\n"]}
