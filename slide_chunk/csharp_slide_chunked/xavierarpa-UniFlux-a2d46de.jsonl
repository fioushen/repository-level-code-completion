{"filename": "Tests/EditMode/EditMode_Test_1.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing NUnit.Framework;\nusing UnityEngine;", "using NUnit.Framework;\nusing UnityEngine;\nusing UnityEngine.TestTools;\nusing Kingdox.UniFlux;\nusing Kingdox.UniFlux.Core;\n\nnamespace Kingdox.UniFlux.Tests\n{\n    public class EditMode_Test_1\n    {\n        [Test] public void _0_EntireWorkFlow()\n        {\n            //Subscribe\n            SubscribeAction();\n            SubscribeActionParam();\n            SubscribeFunc();\n            SubscribeFuncParam();\n            //Dispatch\n            DispatchAction();\n            DispatchActionParam();\n            DispatchFunc();\n            DispatchFuncParam();\n            //Unsubscribe\n            UnsubscribeAction();\n            UnsubscribeActionParam();\n            UnsubscribeFunc();\n            UnsubscribeFuncParam();\n        }", "    public class EditMode_Test_1\n    {\n        [Test] public void _0_EntireWorkFlow()\n        {\n            //Subscribe\n            SubscribeAction();\n            SubscribeActionParam();\n            SubscribeFunc();\n            SubscribeFuncParam();\n            //Dispatch\n            DispatchAction();\n            DispatchActionParam();\n            DispatchFunc();\n            DispatchFuncParam();\n            //Unsubscribe\n            UnsubscribeAction();\n            UnsubscribeActionParam();\n            UnsubscribeFunc();\n            UnsubscribeFuncParam();\n        }", "        [Test] public void SubscribeAction()\n        {\n            Flux.Store(\"OnTest\", OnTest_Action, true);\n        }\n        [Test] public void SubscribeActionParam()\n        {\n            Flux.Store<string,bool>(\"OnTest\", OnTest_ActionParam, true);\n        }\n        [Test] public void SubscribeFunc()\n        {\n            Flux.Store<string, int>(\"OnTest\", OnTest_Func, true);\n        }", "        [Test] public void SubscribeFunc()\n        {\n            Flux.Store<string, int>(\"OnTest\", OnTest_Func, true);\n        }\n        [Test] public void SubscribeFuncParam()\n        {\n            Flux.Store<string,float,float>(\"OnTest\", OnTest_FuncPatam, true);\n        }\n        [Test] public void DispatchAction()\n        {\n            Flux.Dispatch(\"OnTest\");\n        }", "        [Test] public void DispatchAction()\n        {\n            Flux.Dispatch(\"OnTest\");\n        }\n        [Test] public void DispatchActionParam()\n        {\n            Flux.Dispatch(\"OnTest\", true);\n        }\n        [Test] public void DispatchFunc()\n        {\n            var val = Flux.Dispatch<string,int>(\"OnTest\");\n        }", "        [Test] public void DispatchFunc()\n        {\n            var val = Flux.Dispatch<string,int>(\"OnTest\");\n        }\n        [Test] public void DispatchFuncParam()\n        {\n            var val_2 = Flux.Dispatch<string, float, float>(\"OnTest\", 3f);\n        }\n        [Test] public void UnsubscribeAction()\n        {\n            Flux.Store(\"OnTest\", OnTest_Action, false);\n        }", "        [Test] public void UnsubscribeAction()\n        {\n            Flux.Store(\"OnTest\", OnTest_Action, false);\n        }\n        [Test] public void UnsubscribeActionParam()\n        {\n            Flux.Store<string, bool>(\"OnTest\", OnTest_ActionParam, false);\n        }\n        [Test] public void UnsubscribeFunc()\n        {\n            Flux.Store<string, int>(\"OnTest\", OnTest_Func, false);\n        }", "        [Test] public void UnsubscribeFunc()\n        {\n            Flux.Store<string, int>(\"OnTest\", OnTest_Func, false);\n        }\n        [Test] public void UnsubscribeFuncParam()\n        {\n            Flux.Store<string, float, float>(\"OnTest\", OnTest_FuncPatam, false);\n        }\n        public void OnTest_Action() {}\n        public void OnTest_ActionParam(bool condition) {}\n        public int OnTest_Func() => 1;", "        public void OnTest_Action() {}\n        public void OnTest_ActionParam(bool condition) {}\n        public int OnTest_Func() => 1;\n        public float OnTest_FuncPatam(float value) => value;\n    }\n}\n//Assert.AreNotEqual(0, val);"]}
{"filename": "Samples/UniFlux.Sample.5/Sample_5.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing UnityEngine;\nusing System.Collections.Generic;\nnamespace Kingdox.UniFlux.Sample\n{\n    public sealed class Sample_5 : MonoFlux\n    {", "{\n    public sealed class Sample_5 : MonoFlux\n    {\n        public const string K_Primary = \"primary\";\n        [SerializeField] private Color color_1;\n        [SerializeField] private Color color_2;\n        [Space]\n        [SerializeField] private Color color_current;\n        [Space]\n        [SerializeField] private List<Color> history_colors;\n        private void Awake() \n        {\n            history_colors.Clear();\n        }", "        private void Awake() \n        {\n            history_colors.Clear();\n        }\n        protected override void OnFlux(in bool condition) => K_Primary.StoreState<Color>(OnPrimaryChange, condition); // 1 - Subscribe OnPrimaryChange and invokes automatically\n        private void Start() => K_Primary.DispatchState(color_2); // 2 - Change to secondary color state\n        private void OnPrimaryChange(Color color) \n        {\n            color_current = color;\n            history_colors.Add(color);\n        }", "        [Flux(nameof(Sample_5) + \".ChangePrimary_Color1\")] private void _ChangePrimary_Color1() => K_Primary.DispatchState(color_1);\n        [Flux(nameof(Sample_5) + \".ChangePrimary_Color2\")] private void _ChangePrimary_Color2() => K_Primary.DispatchState(color_2);\n    }\n}"]}
{"filename": "Samples/UniFlux.Sample.1/Sample_1.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing UnityEngine;\nnamespace Kingdox.UniFlux.Sample\n{\n    public sealed class Sample_1 : MonoFlux\n    {\n        private void Start() \n        {\n            \"Sample_1\".Dispatch();\n        }", "    public sealed class Sample_1 : MonoFlux\n    {\n        private void Start() \n        {\n            \"Sample_1\".Dispatch();\n        }\n        [Flux(\"Sample_1\")] private void Method() \n        {\n            Debug.Log(\"Sample_1 !\");\n        }\n    }\n}"]}
{"filename": "Samples/UniFlux.Sample.Experimental/UniFlux_Exp_S_1_C.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing UnityEngine;\nnamespace Kingdox.UniFlux.Experimental\n{\n    public class UniFlux_Exp_S_1_C : MonoFlux\n    {\n        [SerializeField] KeyFlux k_onSample;", "    public class UniFlux_Exp_S_1_C : MonoFlux\n    {\n        [SerializeField] KeyFlux k_onSample;\n        protected override void OnFlux(in bool condition) => k_onSample.Store(OnSample, condition);\n        private void OnSample() => Debug.Log(\"On Sample!\");   \n    }\n}"]}
{"filename": "Samples/UniFlux.Sample.Experimental/UniFlux_Exp_S_1_B.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing UnityEngine;\nnamespace Kingdox.UniFlux.Experimental\n{\n    public class UniFlux_Exp_S_1_B : MonoFlux\n    {\n        [SerializeField] KeyFluxBase k_doSample;\n        [SerializeField] KeyFlux k_onSample;", "    public class UniFlux_Exp_S_1_B : MonoFlux\n    {\n        [SerializeField] KeyFluxBase k_doSample;\n        [SerializeField] KeyFlux k_onSample;\n        protected override void OnFlux(in bool condition) => k_doSample.Store(DoSample, condition);\n        private void DoSample() => k_onSample.Dispatch();\n    }\n}"]}
{"filename": "Samples/UniFlux.Sample.Experimental/UniFlux_Exp_S_1_A.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing UnityEngine;\nnamespace Kingdox.UniFlux.Experimental\n{\n    public class UniFlux_Exp_S_1_A : MonoFlux\n    {\n        [SerializeField] KeyFluxBase k_doSample;", "    public class UniFlux_Exp_S_1_A : MonoFlux\n    {\n        [SerializeField] KeyFluxBase k_doSample;\n        private void Start() => k_doSample.Dispatch();\n    }\n}"]}
{"filename": "Samples/UniFlux.Sample.3/Sample_3.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing UnityEngine;\nnamespace Kingdox.UniFlux.Sample\n{\n    public sealed class Sample_3 : MonoFlux\n    {\n        [SerializeField] private int _life;", "    public sealed class Sample_3 : MonoFlux\n    {\n        [SerializeField] private int _life;\n        public int Life\n        {\n            [Flux(\"Get_Life\")] get => _life;\n            [Flux(\"Set_Life\")] set \n            {\n                _life = value;\n                \"OnChange_Life\".Dispatch(value);\n            }\n        }", "        private void Start() \n        {\n            \"Set_Life\".Dispatch(10);\n        }\n        private void Update()\n        {\n            (Time.frameCount % 60).Dispatch();\n        }\n        [Flux(0)] private void OnUpdate() \n        {\n            if(\"Get_Life\".Dispatch<int>() > 0)\n            {\n                \"Set_Life\".Dispatch(\"Get_Life\".Dispatch<int>()-1);\n            }\n        }", "        [Flux(0)] private void OnUpdate() \n        {\n            if(\"Get_Life\".Dispatch<int>() > 0)\n            {\n                \"Set_Life\".Dispatch(\"Get_Life\".Dispatch<int>()-1);\n            }\n        }\n        [Flux(\"OnChange_Life\")] private void OnChange_Life(int life) \n        {\n            if(life == 0)\n            {\n                \"OnDeath\".Dispatch();\n            }   \n        }", "            if(life == 0)\n            {\n                \"OnDeath\".Dispatch();\n            }   \n        }\n        [Flux(\"OnDeath\")] private void OnDeath()\n        {\n            Debug.Log(\"You're Dead !\");\n        }\n    }\n}"]}
{"filename": "Samples/UniFlux.Sample.2/Sample_2.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing UnityEngine;\nnamespace Kingdox.UniFlux.Sample\n{\n    public sealed class Sample_2 : MonoFlux\n    {\n        protected override void OnFlux(in bool condition)\n        {\n            \"Sample_2\".Store(Method, condition);\n        }", "    public sealed class Sample_2 : MonoFlux\n    {\n        protected override void OnFlux(in bool condition)\n        {\n            \"Sample_2\".Store(Method, condition);\n        }\n        private void Start() \n        {\n            \"Sample_2\".Dispatch();\n        }\n        private void Method() \n        {\n            Debug.Log(\"Sample_2 !\");\n        }\n    }\n}", "        private void Method() \n        {\n            Debug.Log(\"Sample_2 !\");\n        }\n    }\n}"]}
{"filename": "Samples/UniFlux.Sample.4/Sample_4.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing UnityEngine;\nnamespace Kingdox.UniFlux.Sample\n{\n    public sealed class Sample_4 : MonoFlux\n    {\n        [SerializeField] private int _shots;", "    public sealed class Sample_4 : MonoFlux\n    {\n        [SerializeField] private int _shots;\n        private void Update()\n        {\n            Kingdox.UniFlux.Core.Flux.Dispatch(_shots < 10);\n        }\n        [Flux(true)]private void CanShot()\n        {\n            if(Time.frameCount % 60 == 0)\n            {\n                \"Shot\".Dispatch(Time.frameCount);\n            }\n        }", "            if(Time.frameCount % 60 == 0)\n            {\n                \"Shot\".Dispatch(Time.frameCount);\n            }\n        }\n        [Flux(\"Shot\")] private void Shot(int frameCount)\n        {\n            _shots++;\n            \"LogShot\".Dispatch((frameCount, _shots));\n        }\n        [Flux(\"LogShot\")] private void LogShot((int frameCount, int shots) data)\n        {\n            Debug.Log(data);\n        }\n    }\n}", "        [Flux(\"LogShot\")] private void LogShot((int frameCount, int shots) data)\n        {\n            Debug.Log(data);\n        }\n    }\n}"]}
{"filename": "Editor/MonoFluxEditor.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing UnityEngine;\nusing UnityEditor;\nusing System.Reflection;\nusing System;\nusing System.Linq;", "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nnamespace Kingdox.UniFlux.Editor\n{\n    [CustomEditor(typeof(MonoFlux), true)]\n    public partial class MonoFluxEditor : UnityEditor.Editor\n    {\n        private MethodInfo[] methods_subscribeAttrb;\n        private Dictionary<MethodInfo, object[]> dic_method_parameters;\n        private static bool showBox = true;", "        private static bool showBox = true;\n        private void OnEnable()\n        {\n            Type type = target.GetType();\n            var methods = type.GetMethods((BindingFlags)(-1));\n            methods_subscribeAttrb = methods.Where(m => m.GetCustomAttributes(typeof(FluxAttribute), true).Length > 0).ToArray();\n            dic_method_parameters = methods_subscribeAttrb.Select(m => new { Method = m, Parameters = new object[m.GetParameters().Length] }).ToDictionary(mp => mp.Method, mp => mp.Parameters);\n        }\n        public override void OnInspectorGUI()\n        {\n            DrawDefaultInspector();\n", "        public override void OnInspectorGUI()\n        {\n            DrawDefaultInspector();\n\n            if(methods_subscribeAttrb.Length.Equals(0))\n            {\n                showBox = false;\n            }\n            else\n            {\n                if(GUILayout.Button( showBox ? \"Close\" : $\"Open ({methods_subscribeAttrb.Length})\", GUI.skin.box))\n                {\n                    showBox = !showBox;\n                }\n            }", "                if(GUILayout.Button( showBox ? \"Close\" : $\"Open ({methods_subscribeAttrb.Length})\", GUI.skin.box))\n                {\n                    showBox = !showBox;\n                }\n            }\n            if(showBox)\n            {\n                _Draw();\n            }\n        }\n        private void _Draw()\n        {\n            GUILayout.Space(20);\n            \n            GUIStyle buttonStyle = new GUIStyle(GUI.skin.button)\n            {\n                alignment = TextAnchor.MiddleLeft,\n                richText = true,\n                fontSize = 12\n            };\n            GUIStyle style_title = new GUIStyle(EditorStyles.boldLabel)\n            {\n                richText = true\n            };", "        private void _Draw()\n        {\n            GUILayout.Space(20);\n            \n            GUIStyle buttonStyle = new GUIStyle(GUI.skin.button)\n            {\n                alignment = TextAnchor.MiddleLeft,\n                richText = true,\n                fontSize = 12\n            };\n            GUIStyle style_title = new GUIStyle(EditorStyles.boldLabel)\n            {\n                richText = true\n            };", "            foreach (var item in methods_subscribeAttrb)\n            {\n                var atribute = item.GetCustomAttribute<FluxAttribute>();\n                var parameters = item.GetParameters();\n                var isParameters = parameters.Length > 0;\n                var isErr_return = item.ReturnType != typeof(void);\n                var isErr_static = item.IsStatic;\n                var isError = isParameters || isErr_return || isErr_static;\n                string key_color =  isError ? \"yellow\" : \"white\";\n                EditorGUILayout.BeginVertical(EditorStyles.helpBox);\n                GUILayout.Label( $\"<color={key_color}>{atribute.key}</color>\", style_title);\n                GUILayout.Label(item.ToString(), EditorStyles.whiteMiniLabel);\n                GenerateButton(buttonStyle,item);\n                EditorGUILayout.BeginVertical();\n                GenerateParameters(item, parameters);\n                EditorGUILayout.EndVertical();\n                EditorGUILayout.EndVertical();\n                GUILayout.Space(5);\n            }\n        }", "        // private void GenerateParameters(MethodInfo item, ParameterInfo[] parameters)\n        // {\n        //     // var args = dic_method_parameters[item];\n        //     // for (int i = 0; i < parameters.Length; i++)\n        //     // {\n        //     //     EditorGUILayout.BeginHorizontal(EditorStyles.helpBox);\n        //     //     GUILayout.Label(parameters[i].ToString());\n        //     //     EditorGUILayout.EndHorizontal();\n        //     // }\n        //     // dic_method_parameters[item] = args;\n        // }", "        private void GenerateParameters(MethodInfo item, ParameterInfo[] parameters)\n        {\n            // var args = dic_method_parameters[item];\n\n            // for (int i = 0; i < parameters.Length; i++)\n            // {\n            //     var parameter = parameters[i];\n\n            //     if (parameter.ParameterType.IsValueType)\n            //     {\n            //         // El par\u00e1metro es primitivo\n            //         object defaultValue = Activator.CreateInstance(parameter.ParameterType);\n            //         object value = args[i] ?? defaultValue;\n\n            //         EditorGUILayout.BeginHorizontal(EditorStyles.helpBox);\n            //         GUILayout.Label(parameter.Name, GUILayout.Width(150));\n", "            //     if (parameter.ParameterType.IsValueType)\n            //     {\n            //         // El par\u00e1metro es primitivo\n            //         object defaultValue = Activator.CreateInstance(parameter.ParameterType);\n            //         object value = args[i] ?? defaultValue;\n\n            //         EditorGUILayout.BeginHorizontal(EditorStyles.helpBox);\n            //         GUILayout.Label(parameter.Name, GUILayout.Width(150));\n\n            //         if (parameter.ParameterType == typeof(int))\n            //         {\n            //             value = EditorGUILayout.IntField((int)value);\n            //         }", "            //         if (parameter.ParameterType == typeof(int))\n            //         {\n            //             value = EditorGUILayout.IntField((int)value);\n            //         }\n            //         else if (parameter.ParameterType == typeof(float))\n            //         {\n            //             value = EditorGUILayout.FloatField((float)value);\n            //         }\n            //         else if (parameter.ParameterType == typeof(bool))\n            //         {\n            //             value = EditorGUILayout.Toggle((bool)value);\n            //         }", "            //         else if (parameter.ParameterType == typeof(bool))\n            //         {\n            //             value = EditorGUILayout.Toggle((bool)value);\n            //         }\n            //         else if (parameter.ParameterType == typeof(string))\n            //         {\n            //             value = EditorGUILayout.TextField((string)value);\n            //         }\n            //         else if (parameter.ParameterType == typeof(Vector2))\n            //         {\n            //             value = EditorGUILayout.Vector2Field(\"\", (Vector2)value);\n            //         }", "            //         else if (parameter.ParameterType == typeof(Vector2))\n            //         {\n            //             value = EditorGUILayout.Vector2Field(\"\", (Vector2)value);\n            //         }\n            //         else if (parameter.ParameterType == typeof(Vector3))\n            //         {\n            //             value = EditorGUILayout.Vector3Field(\"\", (Vector3)value);\n            //         }\n            //         else if (parameter.ParameterType == typeof(Vector4))\n            //         {\n            //             value = EditorGUILayout.Vector4Field(\"\", (Vector4)value);\n            //         }\n\n            //         args[i] = Convert.ChangeType(value, parameter.ParameterType);\n            //         EditorGUILayout.EndHorizontal();\n            //     }\n            //     else\n            //     {\n            //         // El par\u00e1metro no es primitivo\n            //         GUILayout.Label(parameter.Name + \" (no primitivo)\", EditorStyles.whiteMiniLabel);\n            //     }\n            // }\n\n            // dic_method_parameters[item] = args;\n        }\n", "            //         else if (parameter.ParameterType == typeof(Vector4))\n            //         {\n            //             value = EditorGUILayout.Vector4Field(\"\", (Vector4)value);\n            //         }\n\n            //         args[i] = Convert.ChangeType(value, parameter.ParameterType);\n            //         EditorGUILayout.EndHorizontal();\n            //     }\n            //     else\n            //     {\n            //         // El par\u00e1metro no es primitivo\n            //         GUILayout.Label(parameter.Name + \" (no primitivo)\", EditorStyles.whiteMiniLabel);\n            //     }\n            // }\n\n            // dic_method_parameters[item] = args;\n        }\n", "        private void GenerateButton(GUIStyle buttonStyle, MethodInfo item)\n        {\n            GUI.enabled = Application.isPlaying;\n            if (dic_method_parameters[item].Length.Equals(0) && GUILayout.Button($\"Invoke!\", buttonStyle)) \n            {\n                if(item.ReturnType != typeof(void))\n                {\n                    var resp = item.Invoke(target, dic_method_parameters[item]);\n                    Debug.Log(resp);\n                }\n                else\n                {\n                    item.Invoke(target, dic_method_parameters[item]);\n                }\n            }\n            GUI.enabled = true;\n        }\n    }\n}"]}
{"filename": "Benchmark/Tool/Mark.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nusing System.Diagnostics;\nusing UnityEngine;\nusing UnityEngine.Profiling;\nnamespace Kingdox.UniFlux.Benchmark", "using UnityEngine.Profiling;\nnamespace Kingdox.UniFlux.Benchmark\n{\n    [Serializable]\n    public class Marker\n    {\n        [SerializeField] public bool Execute=true;\n        [HideInInspector] public int iteration = 1;\n\t\t[HideInInspector] public readonly Stopwatch sw = new Stopwatch();\n        [HideInInspector] public string K = \"?\";\n        public string Visual => $\"{K} --- {iteration} iteration --- {sw.ElapsedMilliseconds} ms\";", "\t\t[HideInInspector] public readonly Stopwatch sw = new Stopwatch();\n        [HideInInspector] public string K = \"?\";\n        public string Visual => $\"{K} --- {iteration} iteration --- {sw.ElapsedMilliseconds} ms\";\n        public void Begin()\n        {\n            sw.Restart();\n            Profiler.BeginSample(K);\n        }\n        public void End()\n        {\n            Profiler.EndSample();\n            sw.Stop();\n        }\n    }\n}", "        public void End()\n        {\n            Profiler.EndSample();\n            sw.Stop();\n        }\n    }\n}"]}
{"filename": "Benchmark/Nest/Benchmark_Nest_UniFlux.cs", "chunked_list": ["using System;\nusing UnityEngine;\nnamespace Kingdox.UniFlux.Benchmark\n{\n    public sealed class Benchmark_Nest_UniFlux : MonoFlux\n    {\n        [SerializeField] private Marker _mark_fluxAttribute = new Marker()\n        {\n            K = \"NestedModel Flux Attribute\"\n        };\n        [SerializeField] private Marker _mark_store = new Marker()\n        {\n            K = \"NestedModel Store\"\n        };", "        [SerializeField] private Marker _mark_store = new Marker()\n        {\n            K = \"NestedModel Store\"\n        };\n        private readonly Lazy<GUIStyle> _style = new Lazy<GUIStyle>(() => new GUIStyle(\"label\")\n\t\t{\n\t\t\tfontSize = 28,\n\t\t\talignment = TextAnchor.MiddleLeft,\n            padding = new RectOffset(10, 0, 0, 0)\n\t\t});\n\t\tprivate Rect rect_area;", "\t\tprivate Rect rect_area;\n        public int iteration;\n        protected override void OnFlux(in bool condition)\n        {\n            \"1\".Store(Store_1, condition);\n            \"2\".Store(Store_2, condition);\n            \"3\".Store(Store_3, condition);\n            \"4\".Store(Store_4, condition);\n            \"5\".Store(Store_5, condition);\n        }\n        private void Update() \n        {\n            Sample();\n            Sample_2();\n        }", "        private void Update() \n        {\n            Sample();\n            Sample_2();\n        }\n        [Flux(\"A\")] private void A() => \"B\".Dispatch();\n        [Flux(\"B\")] private void B() => \"C\".Dispatch();\n        [Flux(\"C\")] private void C() => \"D\".Dispatch();\n        [Flux(\"D\")] private void D() => \"E\".Dispatch();\n        [Flux(\"E\")] private void E() {}\n        private void Store_1() => \"2\".Dispatch();", "        [Flux(\"D\")] private void D() => \"E\".Dispatch();\n        [Flux(\"E\")] private void E() {}\n        private void Store_1() => \"2\".Dispatch();\n        private void Store_2() => \"3\".Dispatch();\n        private void Store_3() => \"4\".Dispatch();\n        private void Store_4() => \"5\".Dispatch();\n        private void Store_5() {}\n        private void Sample()\n        {\n            if (_mark_fluxAttribute.Execute)\n            {\n                _mark_fluxAttribute.iteration = iteration;\n                _mark_fluxAttribute.Begin();", "            if (_mark_fluxAttribute.Execute)\n            {\n                _mark_fluxAttribute.iteration = iteration;\n                _mark_fluxAttribute.Begin();\n                for (int i = 0; i < iteration; i++) \"A\".Dispatch();\n                _mark_fluxAttribute.End();\n            }\n        }\n        private void Sample_2()\n        {\n            if (_mark_store.Execute)\n            {\n                _mark_store.iteration = iteration;\n                _mark_store.Begin();", "        private void Sample_2()\n        {\n            if (_mark_store.Execute)\n            {\n                _mark_store.iteration = iteration;\n                _mark_store.Begin();\n                for (int i = 0; i < iteration; i++) \"1\".Dispatch();\n                _mark_store.End();\n            }\n        }\n        private void OnGUI()\n        {", "        private void OnGUI()\n        {\n            if (_mark_fluxAttribute.Execute)\n            {\n                // Flux\n                rect_area = new Rect(0, _style.Value.lineHeight, Screen.width, Screen.height / 2);\n                GUI.Label(rect_area, _mark_fluxAttribute.Visual, _style.Value);\n            }\n            if (_mark_store.Execute)\n            {\n                // Store\n                rect_area = new Rect(0, _style.Value.lineHeight * 2, Screen.width, Screen.height / 2);\n                GUI.Label(rect_area, _mark_store.Visual, _style.Value);\n            }\n        }\n    }\n}", "            if (_mark_store.Execute)\n            {\n                // Store\n                rect_area = new Rect(0, _style.Value.lineHeight * 2, Screen.width, Screen.height / 2);\n                GUI.Label(rect_area, _mark_store.Visual, _style.Value);\n            }\n        }\n    }\n}"]}
{"filename": "Benchmark/General/Benchmark_UniFlux.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Kingdox.UniFlux.Core;\nnamespace Kingdox.UniFlux.Benchmark", "using Kingdox.UniFlux.Core;\nnamespace Kingdox.UniFlux.Benchmark\n{\n    public class Benchmark_UniFlux : MonoFlux\n    {\n        [SerializeField] private Marker _m_store_string_add = new Marker()\n        {\n            K = \"store<string,Action> ADD\"\n        };\n        [SerializeField] private Marker _m_store_int_add = new Marker()\n        {\n            K = \"store<int,Action> ADD\"\n        };", "        [SerializeField] private Marker _m_store_int_add = new Marker()\n        {\n            K = \"store<int,Action> ADD\"\n        };\n        [SerializeField] private Marker _m_store_byte_add = new Marker()\n        {\n            K = \"store<byte,Action> ADD\"\n        };\n        [SerializeField] private Marker _m_store_bool_add = new Marker()\n        {\n            K = \"store<bool,Action> ADD\"\n        };", "        [SerializeField] private Marker _m_store_bool_add = new Marker()\n        {\n            K = \"store<bool,Action> ADD\"\n        };\n        [SerializeField] private Marker _m_store_string_remove = new Marker()\n        {\n            K = \"store<string,Action> REMOVE\"\n        };\n        [SerializeField] private Marker _m_store_int_remove = new Marker()\n        {\n            K = \"store<int,Action> REMOVE\"\n        };", "        [SerializeField] private Marker _m_store_int_remove = new Marker()\n        {\n            K = \"store<int,Action> REMOVE\"\n        };\n        [SerializeField] private Marker _m_store_byte_remove = new Marker()\n        {\n            K = \"store<byte,Action> REMOVE\"\n        };\n        [SerializeField] private Marker _m_store_bool_remove = new Marker()\n        {\n            K = \"store<bool,Action> REMOVE\"\n        };", "        [SerializeField] private Marker _m_store_bool_remove = new Marker()\n        {\n            K = \"store<bool,Action> REMOVE\"\n        };\n        [SerializeField] private Marker _m_dispatch_string = new Marker()\n        {\n            K = $\"dispatch<string>\"\n        };\n        [SerializeField] private Marker _m_dispatch_int = new Marker()\n        {\n            K = $\"dispatch<int>\"\n        };", "        [SerializeField] private Marker _m_dispatch_int = new Marker()\n        {\n            K = $\"dispatch<int>\"\n        };\n        [SerializeField] private Marker _m_dispatch_byte = new Marker()\n        {\n            K = $\"dispatch<byte>\"\n        };\n        [SerializeField] private Marker _m_dispatch_bool = new Marker()\n        {\n            K = $\"dispatch<bool>\"\n        };", "        [SerializeField] private Marker _m_dispatch_bool = new Marker()\n        {\n            K = $\"dispatch<bool>\"\n        };\n        private const byte __m_store = 52;\n        private const byte __m_dispatch = 250;\n\t\tprivate Rect rect_area;\n        private readonly Lazy<GUIStyle> _style = new Lazy<GUIStyle>(() => new GUIStyle(\"label\")\n\t\t{\n\t\t\tfontSize = 28,\n\t\t\talignment = TextAnchor.MiddleLeft,\n            padding = new RectOffset(10, 0, 0, 0)\n\t\t});", "        [SerializeField] private int _iterations = default;\n        [SerializeField] private List<string> _Results = default;\n        public bool draw=true;\n        public bool isUpdated = false;\n        public bool isUpdated_store = false;\n        public bool isUpdated_dispatch = false;\n        protected override void OnFlux(in bool condition)\n        {\n            StoreTest_Add();\n            StoreTest_Remove();\n        }", "        public void Start()\n        {\n            DispatchTest();\n        }\n        private void Update()\n        {\n            if(!isUpdated) return;\n            if(isUpdated_store) StoreTest_Add();\n            if(isUpdated_store) StoreTest_Remove();\n            if(isUpdated_dispatch) DispatchTest();\n        }", "            if(isUpdated_store) StoreTest_Remove();\n            if(isUpdated_dispatch) DispatchTest();\n        }\n        private void StoreTest_Add()\n        {\n            // Store String\n            if(_m_store_string_add.Execute)\n            {\n                _m_store_string_add.iteration=_iterations;\n                _m_store_string_add.Begin();\n                for (int i = 0; i < _iterations; i++) \n                {\n                    \"Store\".Store(Example_OnFlux, true);\n                }\n                _m_store_string_add.End();\n            }\n            // Store Int", "                for (int i = 0; i < _iterations; i++) \n                {\n                    \"Store\".Store(Example_OnFlux, true);\n                }\n                _m_store_string_add.End();\n            }\n            // Store Int\n            if(_m_store_int_add.Execute)\n            {\n                _m_store_int_add.iteration=_iterations;\n                _m_store_int_add.Begin();", "                for (int i = 0; i < _iterations; i++) \n                {\n                    42.Store(Example_OnFlux, true);\n                }\n                _m_store_int_add.End();\n            }\n            // Store Byte\n            if(_m_store_byte_add.Execute)\n            {\n                _m_store_byte_add.iteration=_iterations;\n                _m_store_byte_add.Begin();", "                for (int i = 0; i < _iterations; i++) \n                {\n                    Flux.Store(__m_store, Example_OnFlux, true);\n                }\n                _m_store_byte_add.End();\n            }\n            // Store Bool\n            if(_m_store_bool_add.Execute)\n            {\n                _m_store_bool_add.iteration=_iterations;\n                _m_store_bool_add.Begin();", "                for (int i = 0; i < _iterations; i++) \n                {\n                    Flux.Store(true, Example_OnFlux, true);\n                }\n                _m_store_bool_add.End();\n            }\n        }\n        private void StoreTest_Remove()\n        {\n            // Store String\n            if(_m_store_string_remove.Execute)\n            {\n                _m_store_string_remove.iteration=_iterations;\n                _m_store_string_remove.Begin();", "            if(_m_store_string_remove.Execute)\n            {\n                _m_store_string_remove.iteration=_iterations;\n                _m_store_string_remove.Begin();\n                for (int i = 0; i < _iterations; i++) \n                {\n                    \"Store\".Store(Example_OnFlux, false);\n                }\n                _m_store_string_remove.End();\n            }\n            // Store Int", "            if(_m_store_int_remove.Execute)\n            {\n                _m_store_int_remove.iteration=_iterations;\n                _m_store_int_remove.Begin();\n                for (int i = 0; i < _iterations; i++) \n                {\n                    42.Store(Example_OnFlux, false);\n                }\n                _m_store_int_remove.End();\n            }\n            // Store Byte", "            if(_m_store_byte_remove.Execute)\n            {\n                _m_store_byte_remove.iteration=_iterations;\n                _m_store_byte_remove.Begin();\n                for (int i = 0; i < _iterations; i++) \n                {\n                    Flux.Store(__m_store, Example_OnFlux, false);\n                }\n                _m_store_byte_remove.End();\n            }\n            // Store Bool", "            if(_m_store_bool_remove.Execute)\n            {\n                _m_store_bool_remove.iteration=_iterations;\n                _m_store_bool_remove.Begin();\n                for (int i = 0; i < _iterations; i++) \n                {\n                    Flux.Store(true, Example_OnFlux, false);\n                }\n                _m_store_bool_remove.End();\n            }\n        }", "        private void DispatchTest()\n        {\n            // Dispatch String\n            if(_m_dispatch_string.Execute)\n            {\n                _m_dispatch_string.iteration=_iterations;\n                _m_dispatch_string.Begin();\n                for (int i = 0; i < _iterations; i++) \"UniFlux.Dispatch\".Dispatch();\n                _m_dispatch_string.End();\n            }\n            // Dispatch Int", "            if(_m_dispatch_int.Execute)\n            {\n                _m_dispatch_int.iteration=_iterations;\n                _m_dispatch_int.Begin();\n                for (int i = 0; i < _iterations; i++) 0.Dispatch();\n                _m_dispatch_int.End();\n            }\n            // Dispatch Byte\n            if(_m_dispatch_byte.Execute)\n            {\n                _m_dispatch_byte.iteration=_iterations;\n                _m_dispatch_byte.Begin();", "            if(_m_dispatch_byte.Execute)\n            {\n                _m_dispatch_byte.iteration=_iterations;\n                _m_dispatch_byte.Begin();\n                for (int i = 0; i < _iterations; i++) Flux.Dispatch(__m_dispatch);\n                _m_dispatch_byte.End();\n            }\n            // Dispatch Boolean\n            if(_m_dispatch_bool.Execute)\n            {\n                _m_dispatch_bool.iteration=_iterations;\n                _m_dispatch_bool.Begin();", "            if(_m_dispatch_bool.Execute)\n            {\n                _m_dispatch_bool.iteration=_iterations;\n                _m_dispatch_bool.Begin();\n                for (int i = 0; i < _iterations; i++) Flux.Dispatch(true);\n                _m_dispatch_bool.End();\n            }\n        }\n        [Flux(\"UniFlux.Dispatch\")] private void Example_Dispatch_String(){}\n        [Flux(\"UniFlux.Dispatch\")] private void Example_Dispatch_String2(){}\n        [Flux(0)] private void Example_Dispatch_Int(){}", "        [Flux(\"UniFlux.Dispatch\")] private void Example_Dispatch_String(){}\n        [Flux(\"UniFlux.Dispatch\")] private void Example_Dispatch_String2(){}\n        [Flux(0)] private void Example_Dispatch_Int(){}\n        [Flux(__m_dispatch)] private void Example_Dispatch_Byte(){}\n        [Flux(false)] private void Example_Dispatch_Boolean_2(){}\n        [Flux(false)] private void Example_Dispatch_Boolean_3(){}\n        [Flux(false)] private void Example_Dispatch_Boolean_4(){}\n        [Flux(false)] private void Example_Dispatch_Boolean_5(){}\n        [Flux(false)] private void Example_Dispatch_Boolean_6(){}\n        [Flux(true)] private void Example_Dispatch_Boolean(){}\n        private void Example_OnFlux(){}", "        [Flux(false)] private void Example_Dispatch_Boolean_6(){}\n        [Flux(true)] private void Example_Dispatch_Boolean(){}\n        private void Example_OnFlux(){}\n        private void OnGUI()\n\t\t{\n            if(!draw)return;\n            _Results.Clear();\n            _Results.Add(_m_store_string_add.Visual);\n            _Results.Add(_m_store_int_add.Visual);\n            _Results.Add(_m_store_byte_add.Visual);\n            _Results.Add(_m_store_bool_add.Visual);\n            _Results.Add(_m_store_string_remove.Visual);\n            _Results.Add(_m_store_int_remove.Visual);\n            _Results.Add(_m_store_byte_remove.Visual);\n            _Results.Add(_m_store_bool_remove.Visual);\n            _Results.Add(_m_dispatch_string.Visual);\n            _Results.Add(_m_dispatch_int.Visual);\n            _Results.Add(_m_dispatch_byte.Visual);\n            _Results.Add(_m_dispatch_bool.Visual);\n            var height = (float) Screen.height / 2;", "            for (int i = 0; i < _Results.Count; i++)\n            {\n                rect_area = new Rect(0, _style.Value.lineHeight * i, Screen.width, height);\n\t\t\t    GUI.Label(rect_area, _Results[i], _style.Value);\n            }\n\t\t}\n    }\n}"]}
{"filename": "Runtime/UniFlux.Int.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Kingdox.UniFlux.Core;", "using System.Threading.Tasks;\nusing Kingdox.UniFlux.Core;\n// asmdef Version Defines, enabled when com.cysharp.unitask is imported.\n#if UNIFLUX_UNITASK_SUPPORT\n    using Cysharp.Threading.Tasks;\n    namespace Kingdox.UniFlux\n    {\n        public static partial class FluxExtension //Action<UniTask>\n        {\n            public static void Store(this int key, Action<UniTask> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store(this int key, Func<UniTask> action, bool condition) => Flux.Store(key, action, condition);", "            public static void Store(this int key, Action<UniTask> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store(this int key, Func<UniTask> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store<T>(this int key, Func<UniTask<T>> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store<T>(this int key, Func<T, UniTask> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store<T,T2>(this int key, Func<T, UniTask<T2>> action, bool condition) => Flux.Store(key, action, condition);\n\n            public static UniTask @UniTask(this int key) => Flux.Dispatch<int, UniTask>(key);\n            public static UniTask<T> @UniTask<T>(this int key) => Flux.Dispatch<int, UniTask<T>>(key);\n            public static UniTask @UniTask<T>(this int key, T @param) => Flux.Dispatch<int, T, UniTask>(key, @param);\n            public static UniTask<T2> @UniTask<T, T2>(this int key, T @param) => Flux.Dispatch<int, T, UniTask<T2>>(key, @param);\n        }\n    }\n#endif\n#if UNIFLUX_UNIRX_SUPPORT\n    namespace Kingdox.UniFlux\n    {\n        #if !(NETFX_CORE || NET_4_6 || NET_STANDARD_2_0 || UNITY_WSA_10_0)", "            public static UniTask @UniTask<T>(this int key, T @param) => Flux.Dispatch<int, T, UniTask>(key, @param);\n            public static UniTask<T2> @UniTask<T, T2>(this int key, T @param) => Flux.Dispatch<int, T, UniTask<T2>>(key, @param);\n        }\n    }\n#endif\n#if UNIFLUX_UNIRX_SUPPORT\n    namespace Kingdox.UniFlux\n    {\n        #if !(NETFX_CORE || NET_4_6 || NET_STANDARD_2_0 || UNITY_WSA_10_0)\n        public static partial class FluxExtension //Action<UniRx.IObservable<T>>\n        {", "        public static partial class FluxExtension //Action<UniRx.IObservable<T>>\n        {\n            public static void Store<T>(this int key, Action<UniRx.IObservable<T>> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store<T>(this int key, Func<UniRx.IObservable<T>> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store<T,T2>(this int key, Func<T, UniRx.IObservable<T2>> action, bool condition) => Flux.Store(key, action, condition);\n            public static void @IObservable<T>(this int key, UniRx.IObservable<T> @param) => Flux.Dispatch(key, @param);\n            public static UniRx.IObservable<T> @IObservable<T>(this int key) => Flux.Dispatch<int,UniRx.IObservable<T>>(key);\n            public static UniRx.IObservable<T2> @IObservable<T,T2>(this int key, T @param) => Flux.Dispatch<int, T, UniRx.IObservable<T2>>(key, @param);\n        }        \n        public static partial class FluxExtension //Action<UniRx.IObserver<T>>\n        {", "        public static partial class FluxExtension //Action<UniRx.IObserver<T>>\n        {\n            public static void Store<T>(this int key, Action<UniRx.IObserver<T>> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store<T>(this int key, Func<UniRx.IObserver<T>> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store<T,T2>(this int key, Func<T, UniRx.IObserver<T2>> action, bool condition) => Flux.Store(key, action, condition);\n            public static void @IObserver<T>(this int key, UniRx.IObserver<T> @param) => Flux.Dispatch(key, @param);\n            public static UniRx.IObserver<T> @IObserver<T>(this int key) => Flux.Dispatch<int,UniRx.IObserver<T>>(key);\n            public static UniRx.IObserver<T2> @IObserver<T,T2>(this int key, T @param) => Flux.Dispatch<int, T, UniRx.IObserver<T2>>(key, @param);\n        }\n        #endif\n    }\n#endif\nnamespace Kingdox.UniFlux\n{\n#region Common", "    public static partial class FluxExtension //Action\n    {\n        public static void Store(this int key, in Action action, in bool condition) => Flux.Store(in key, in action,in condition);\n        public static void Dispatch(this int key) => Flux.Dispatch(key);\n    }\n    public static partial class FluxExtension //Action<T>\n    {\n        public static void Store<T>(this int key, in Action<T> action,in bool condition) => Flux.Store(in key, in action, in condition);\n        public static void Dispatch<T>(this int key, in T @param) => Flux.Dispatch(in key, in @param);\n    }\n    public static partial class FluxExtension //Func<out T>\n    {", "        public static void Dispatch<T>(this int key, in T @param) => Flux.Dispatch(in key, in @param);\n    }\n    public static partial class FluxExtension //Func<out T>\n    {\n        public static void Store<T>(this int key, in Func<T> action, in bool condition) => Flux.Store(in key, in action, in condition);\n        public static T Dispatch<T>(this int key) => Flux.Dispatch<int, T>(in key);\n    }\n    public static partial class FluxExtension //Func<T, out T2>\n    {\n        public static void Store<T,T2>(this int key, in Func<T, T2> action, in bool condition) => Flux.Store(in key, in action, in condition);\n        public static T2 Dispatch<T, T2>(this int key, in T @param) => Flux.Dispatch<int, T, T2>(in key, in @param);\n    }", "        public static void Store<T,T2>(this int key, in Func<T, T2> action, in bool condition) => Flux.Store(in key, in action, in condition);\n        public static T2 Dispatch<T, T2>(this int key, in T @param) => Flux.Dispatch<int, T, T2>(in key, in @param);\n    }\n    public static partial class FluxExtension //State Action<T>\n    {\n        public static void StoreState<T>(this int key, in Action<T> action,in bool condition) => Flux.StoreState(in key, in action, in condition);\n        public static void DispatchState<T>(this int key, in T state) => Flux.DispatchState(in key, in state);\n        public static bool GetState<T>(this int key, out T state) => Flux.GetState(in key, out state);\n\n    }\n#endregion\n#region IEnumerator", "    public static partial class FluxExtension //Action<IEnumerator>\n    {\n        public static void Store(this int key, in Action<IEnumerator> action, in bool condition) => Flux.Store(in key, in action, in condition);\n        public static void Store(this int key, in Func<IEnumerator> action, in bool condition) => Flux.Store(in key, in action, in condition);\n        public static void Store<T>(this int key, in Func<IEnumerator<T>> action, in bool condition) => Flux.Store(in key, in action, in condition);\n        public static void Store<T>(this int key, in Func<T, IEnumerator> action, in bool condition) => Flux.Store(in key, in action, in condition);\n        public static void Store<T,T2>(this int key, in Func<T, IEnumerator<T2>> action, in bool condition) => Flux.Store(in key, in action, in condition);\n\n        public static IEnumerator @IEnumerator(this int key) => Flux.Dispatch<int, IEnumerator>(in key);\n        public static IEnumerator<T> @IEnumerator<T>(this int key) => Flux.Dispatch<int, IEnumerator<T>>(in key);\n        public static IEnumerator @IEnumerator<T>(this int key, in T @param) => Flux.Dispatch<int, T, IEnumerator>(in key, in @param);", "        public static IEnumerator @IEnumerator(this int key) => Flux.Dispatch<int, IEnumerator>(in key);\n        public static IEnumerator<T> @IEnumerator<T>(this int key) => Flux.Dispatch<int, IEnumerator<T>>(in key);\n        public static IEnumerator @IEnumerator<T>(this int key, in T @param) => Flux.Dispatch<int, T, IEnumerator>(in key, in @param);\n        public static IEnumerator<T2> @IEnumerator<T, T2>(this int key, in T @param) => Flux.Dispatch<int, T, IEnumerator<T2>>(in key, in @param);\n    }\n#endregion\n#region Task\n    public static partial class FluxExtension //Action<Task>\n    {\n        public static void Store(this int key, in Action<Task> action, in bool condition) => Flux.Store(in key,in action,in condition);\n        public static void Store(this int key, in Func<Task> action, in bool condition) => Flux.Store(in key,in action,in condition);", "        public static void Store(this int key, in Action<Task> action, in bool condition) => Flux.Store(in key,in action,in condition);\n        public static void Store(this int key, in Func<Task> action, in bool condition) => Flux.Store(in key,in action,in condition);\n        public static void Store<T>(this int key, in Func<Task<T>> action, in bool condition) => Flux.Store(in key,in action,in condition);\n        public static void Store<T>(this int key, in Func<T, Task> action, in bool condition) => Flux.Store(in key,in action,in condition);\n        public static void Store<T,T2>(this int key, in Func<T, Task<T2>> action, in bool condition) => Flux.Store(in key,in action,in condition);\n\n        public static Task @Task(this int key) => Flux.Dispatch<int, Task>(key);\n        public static Task<T> @Task<T>(this int key) => Flux.Dispatch<int, Task<T>>(key);\n        public static Task @Task<T>(this int key, in T @param) => Flux.Dispatch<int, T, Task>(key, in @param);\n        public static Task<T2> @Task<T, T2>(this int key, in T @param) => Flux.Dispatch<int, T, Task<T2>>(key, in @param);\n    }\n#endregion\n#region IObservable<T>", "        public static Task @Task<T>(this int key, in T @param) => Flux.Dispatch<int, T, Task>(key, in @param);\n        public static Task<T2> @Task<T, T2>(this int key, in T @param) => Flux.Dispatch<int, T, Task<T2>>(key, in @param);\n    }\n#endregion\n#region IObservable<T>\n    public static partial class FluxExtension //Action<IObservable<T>>\n    {\n        public static void Store<T>(this int key, Action<IObservable<T>> action, bool condition) => Flux.Store(key, action, condition);\n        public static void Store<T>(this int key, Func<IObservable<T>> action, bool condition) => Flux.Store(key, action, condition);\n        public static void Store<T,T2>(this int key, Func<T, IObservable<T2>> action, bool condition) => Flux.Store(key, action, condition);\n        public static void @IObservable<T>(this int key, IObservable<T> @param) => Flux.Dispatch(key, @param);", "        public static void Store<T>(this int key, Func<IObservable<T>> action, bool condition) => Flux.Store(key, action, condition);\n        public static void Store<T,T2>(this int key, Func<T, IObservable<T2>> action, bool condition) => Flux.Store(key, action, condition);\n        public static void @IObservable<T>(this int key, IObservable<T> @param) => Flux.Dispatch(key, @param);\n        public static IObservable<T> @IObservable<T>(this int key) => Flux.Dispatch<int,IObservable<T>>(key);\n        public static IObservable<T2> @IObservable<T,T2>(this int key, T @param) => Flux.Dispatch<int, T, IObservable<T2>>(key, @param);\n    }\n#endregion\n#region IObserver<T>\n    public static partial class FluxExtension //Action<IObserver<T>>\n    {\n        public static void Store<T>(this int key, Action<IObserver<T>> action, bool condition) => Flux.Store(key, action, condition);", "    public static partial class FluxExtension //Action<IObserver<T>>\n    {\n        public static void Store<T>(this int key, Action<IObserver<T>> action, bool condition) => Flux.Store(key, action, condition);\n        public static void Store<T>(this int key, Func<IObserver<T>> action, bool condition) => Flux.Store(key, action, condition);\n        public static void Store<T,T2>(this int key, Func<T, IObserver<T2>> action, bool condition) => Flux.Store(key, action, condition);\n        public static void @IObserver<T>(this int key, IObserver<T> @param) => Flux.Dispatch(key, @param);\n        public static IObserver<T> @IObserver<T>(this int key) => Flux.Dispatch<int, IObserver<T>>(key);\n        public static IObserver<T2> @IObserver<T,T2>(this int key, T @param) => Flux.Dispatch<int, T, IObserver<T2>>(key, @param);\n    }\n#endregion\n}\n"]}
{"filename": "Runtime/FluxAttribute.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nnamespace Kingdox.UniFlux\n{\n    ///<summary>\n    /// Class FluxAttribute, a custom attribute that mark a method to be subscribed in a flux.", "    ///<summary>\n    /// Class FluxAttribute, a custom attribute that mark a method to be subscribed in a flux.\n    /// AllowMultiple is false to keep legibility\n    ///</summary>\n    [AttributeUsageAttribute(AttributeTargets.Method, AllowMultiple = false)]\n    public class FluxAttribute : System.Attribute\n    {\n        ///<summary>\n        /// Key provided to the attribute's constructor.\n        ///</summary>\n        public readonly object key;\n        ///<summary>", "        public readonly object key;\n        ///<summary>\n        /// Constructor of the FluxAttribute class that takes a key as a parameter.\n        ///</summary>\n        public FluxAttribute(object key)\n        {\n            this.key = key;\n        }\n    }\n}\n//TODO: C# 11 allow Attribute<T>, instead of object key"]}
{"filename": "Runtime/MonoFlux.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing UnityEngine;\nnamespace Kingdox.UniFlux\n{\n    /// <summary>\n    /// The `MonoFlux` class is a base class that should be used for all Unity scripts that need to respond to changes in a flux state. \n    /// It provides a helper method for subscribing and unsubscribing to flux state updates, and a virtual method that can be overriden to handle changes in subscription state. \n    /// </summary>", "    /// <summary>\n    /// The `MonoFlux` class is a base class that should be used for all Unity scripts that need to respond to changes in a flux state. \n    /// It provides a helper method for subscribing and unsubscribing to flux state updates, and a virtual method that can be overriden to handle changes in subscription state. \n    /// </summary>\n    public abstract partial class MonoFlux : MonoBehaviour\n    {\n        /// <summary>\n        /// Called when the script instance is being enabled.\n        /// </summary>\n        private void OnEnable()  => OnSubscription(true);\n        /// <summary>\n        /// Called when the script instance is being disabled.\n        /// </summary>", "        private void OnEnable()  => OnSubscription(true);\n        /// <summary>\n        /// Called when the script instance is being disabled.\n        /// </summary>\n        private void OnDisable()  => OnSubscription(false);\n        /// <summary>\n        /// Helper method to subscribe or unsubscribe from the flux state updates.\n        /// </summary>\n        /// <param name=\"condition\">Whether to subscribe or unsubscribe.</param>\n        private void OnSubscription(bool condition)\n        {\n            // Subscribe or unsubscribe from flux state updates\n            this.Subscribe(in condition);\n            // Call OnFlux method with the new subscription state\n            OnFlux(in condition);\n        }\n        /// <summary>\n        /// Override this method to react to changes in subscription state.\n        /// </summary>\n        /// <param name=\"condition\">Whether the object is being subscribed or unsubscribed.</param>", "        private void OnSubscription(bool condition)\n        {\n            // Subscribe or unsubscribe from flux state updates\n            this.Subscribe(in condition);\n            // Call OnFlux method with the new subscription state\n            OnFlux(in condition);\n        }\n        /// <summary>\n        /// Override this method to react to changes in subscription state.\n        /// </summary>\n        /// <param name=\"condition\">Whether the object is being subscribed or unsubscribed.</param>", "        protected virtual void OnFlux(in bool condition) { }\n    }\n}"]}
{"filename": "Runtime/MonoFluxExtension.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nnamespace Kingdox.UniFlux", "using System.Reflection;\nnamespace Kingdox.UniFlux\n{\n    ///<summary>\n    /// static class that ensure to handle the FluxAttribute\n    ///</summary>\n    internal static class MonoFluxExtension\n    {\n        internal static readonly BindingFlags m_bindingflag_all = (BindingFlags)(-1);\n        //\n        internal static readonly Type m_type_monoflux = typeof(MonoFlux);\n        //\n        internal static readonly Type m_type_flux = typeof(Core.Internal.Flux<>);\n        internal static readonly Type m_type_flux_delegate = typeof(Action);\n        internal static readonly string m_type_flux_method = nameof(Core.Internal.Flux<object>.Store);\n        //\n        internal static readonly Type m_type_fluxparam = typeof(Core.Internal.FluxParam<,>);\n        internal static readonly Type m_type_fluxparam_delegate = typeof(Action<>);\n        internal static readonly string m_type_fluxparam_method = nameof(Core.Internal.FluxParam<object,object>.Store);\n        //\n        internal static readonly Type m_type_fluxreturn = typeof(Core.Internal.FluxReturn<,>);\n        internal static readonly Type m_type_fluxreturn_delegate = typeof(Func<>);\n        internal static readonly string m_type_fluxreturn_method = nameof(Core.Internal.FluxReturn<object,object>.Store);\n        //\n        internal static readonly Type m_type_fluxparamreturn = typeof(Core.Internal.FluxParamReturn<,,>);\n        internal static readonly Type m_type_fluxparamreturn_delegate = typeof(Func<,>);\n        internal static readonly string m_type_fluxparamreturn_method = nameof(Core.Internal.FluxParamReturn<object,object,object>.Store);\n        //\n        ///<summary>\n        /// typeof(void)\n        ///</summary>\n        internal static readonly Type m_type_void = typeof(void);\n        ///<summary>\n        /// Dictionary to cache each MonoFlux instance's methods\n        ///</summary>\n        internal static readonly Dictionary<MonoFlux, List<MethodInfo>> m_monofluxes = new Dictionary<MonoFlux, List<MethodInfo>>();\n        ///<summary>\n        /// Dictionary to cache the FluxAttribute of each MethodInfo\n        ///</summary>\n        internal static readonly Dictionary<MethodInfo, FluxAttribute> m_methods = new Dictionary<MethodInfo, FluxAttribute>();\n        ///<summary>\n        /// Allows subscribe methods using `FluxAttribute` by reflection\n        /// ~ where magic happens ~\n        ///</summary>\n        internal static void Subscribe(this MonoFlux monoflux, in bool condition)\n        {", "            if (!m_monofluxes.ContainsKey(monoflux))\n            {\n                m_monofluxes.Add(\n                    monoflux, \n                    monoflux.gameObject.GetComponent(m_type_monoflux).GetType().GetMethods(m_bindingflag_all).Where(method => \n                    {\n                        if(System.Attribute.GetCustomAttributes(method).FirstOrDefault((_att) => _att is FluxAttribute) is FluxAttribute _attribute)\n                        {\n                            if(!m_methods.ContainsKey(method)) m_methods.Add(method, _attribute); // ADD <Method, Attribute>!\n                            return true;\n                        } \n                        else return false;\n                    }).ToList()\n                );\n            }\n            //\n            List<MethodInfo> methods = m_monofluxes[monoflux];\n            //", "                            if(!m_methods.ContainsKey(method)) m_methods.Add(method, _attribute); // ADD <Method, Attribute>!\n                            return true;\n                        } \n                        else return false;\n                    }).ToList()\n                );\n            }\n            //\n            List<MethodInfo> methods = m_monofluxes[monoflux];\n            //\n            for (int i = 0; i < methods.Count; i++) \n            {\n                var _Parameters = methods[i].GetParameters();\n                #if UNITY_EDITOR", "            for (int i = 0; i < methods.Count; i++) \n            {\n                var _Parameters = methods[i].GetParameters();\n                #if UNITY_EDITOR\n                    if(_Parameters.Length > 1) // Auth Params is 0 or 1\n                    {\n                        throw new System.Exception($\"Error '{methods[i].Name}' : Theres more than one parameter, please set 1 or 0 parameter. (if you need to add more than 1 argument use Tuples or create a struct, record o class...)\");\n                    }\n                #endif\n                switch ((_Parameters.Length.Equals(1), !methods[i].ReturnType.Equals(m_type_void)))\n                {\n                    case (false, false): // Flux\n                        m_type_flux\n                            .MakeGenericType(m_methods[methods[i]].key.GetType())\n                            .GetMethod(m_type_flux_method, m_bindingflag_all)\n                            .Invoke( null, new object[]{ m_methods[methods[i]].key, methods[i].CreateDelegate(m_type_flux_delegate, monoflux), condition})\n                        ;\n                    break;\n                    case (true, false): // FluxParam\n                        m_type_fluxparam\n                            .MakeGenericType(m_methods[methods[i]].key.GetType(), _Parameters[0].ParameterType)\n                            .GetMethod(m_type_fluxparam_method, m_bindingflag_all)\n                            .Invoke( null, new object[]{ m_methods[methods[i]].key, methods[i].CreateDelegate(m_type_fluxparam_delegate.MakeGenericType(_Parameters[0].ParameterType), monoflux), condition})\n                        ;\n                    break;\n                    case (false, true): //FluxReturn\n                        m_type_fluxreturn\n                            .MakeGenericType(m_methods[methods[i]].key.GetType(), methods[i].ReturnType)\n                            .GetMethod(m_type_fluxreturn_method, m_bindingflag_all)\n                            .Invoke( null, new object[]{ m_methods[methods[i]].key, methods[i].CreateDelegate(m_type_fluxreturn_delegate.MakeGenericType(methods[i].ReturnType), monoflux), condition})\n                        ;\n                    break;\n                    case (true, true): //FluxParamReturn\n                        m_type_fluxparamreturn\n                            .MakeGenericType(m_methods[methods[i]].key.GetType(), _Parameters[0].ParameterType, methods[i].ReturnType)\n                            .GetMethod(m_type_fluxparamreturn_method, m_bindingflag_all)\n                            .Invoke( null, new object[]{ m_methods[methods[i]].key, methods[i].CreateDelegate(m_type_fluxparamreturn_delegate.MakeGenericType(_Parameters[0].ParameterType, methods[i].ReturnType), monoflux), condition})\n                        ;\n                    break;\n                }\n            }\n        }\n        // internal static void Subscribe_v2(this MonoFlux monoflux, in bool condition)\n        // {\n        //     var methods = new List<(MethodInfo Method, FluxAttribute Attribute)>();\n        //     var methods_raw  = monoflux.GetType().GetMethods(m_bindingflag_all);", "        //     foreach (var method in methods_raw)\n        //     {\n        //         var attribute = method.GetCustomAttribute<FluxAttribute>();\n        //         if (attribute != null)\n        //         {\n        //             #if UNITY_EDITOR\n        //             if (method.GetParameters().Length > 1)\n        //             {\n        //                 throw new System.Exception($\"Error '{method.Name}' : Theres more than one parameter, please set 1 or 0 parameter. (if you need to add more than 1 argument use Tuples or create a struct, record o class...)\");\n        //             }\n        //             #endif\n        //             methods.Add((method, attribute));\n        //         }\n        //     }\n", "        //     foreach (var (method, attribute) in methods)\n        //     {\n        //         var parameters = method.GetParameters();\n        //         var returnType = method.ReturnType;\n\n        //         switch ((parameters.Length == 1, returnType != m_type_void))\n        //         {\n        //             case (false, false):\n        //                 m_type_flux.MakeGenericType(attribute.key.GetType())\n        //                     .GetMethod(m_type_flux_method, m_bindingflag_all)\n        //                     .Invoke(null, new object[] { attribute.key, Delegate.CreateDelegate(m_type_flux_delegate, monoflux, method), condition });\n        //                 break;\n        //             case (true, false):\n        //                 m_type_fluxparam.MakeGenericType(attribute.key.GetType(), parameters[0].ParameterType)\n        //                     .GetMethod(m_type_fluxparam_method, m_bindingflag_all)\n        //                     .Invoke(null, new object[] { attribute.key, Delegate.CreateDelegate(m_type_fluxparam_delegate.MakeGenericType(parameters[0].ParameterType), monoflux, method), condition });\n        //                 break;\n        //             case (false, true):\n        //                 m_type_fluxreturn.MakeGenericType(attribute.key.GetType(), returnType)\n        //                     .GetMethod(m_type_fluxreturn_method, m_bindingflag_all)\n        //                     .Invoke(null, new object[] { attribute.key, Delegate.CreateDelegate(m_type_fluxreturn_delegate.MakeGenericType(returnType), monoflux, method), condition });\n        //                 break;\n        //             case (true, true):\n        //                 m_type_fluxparamreturn.MakeGenericType(attribute.key.GetType(), parameters[0].ParameterType, returnType)\n        //                     .GetMethod(m_type_fluxparamreturn_method, m_bindingflag_all)\n        //                     .Invoke(null, new object[] { attribute.key, Delegate.CreateDelegate(m_type_fluxparamreturn_delegate.MakeGenericType(parameters[0].ParameterType, returnType), monoflux, method), condition });\n        //                 break;\n        //         }\n        //     }\n        // }\n        // internal static void Subscribe_v3(this MonoFlux monoflux, in bool condition)\n        // {\n        //     var methods_raw = monoflux.GetType().GetMethods(m_bindingflag_all);\n        //     var methods = new (MethodInfo Method, FluxAttribute Attribute)[methods_raw.Length];\n        //     var method_count = 0;\n", "        //     for (int i = 0; i < methods_raw.Length; i++)\n        //     {\n        //         var attribute = methods_raw[i].GetCustomAttribute<FluxAttribute>();\n        //         if (attribute != null)\n        //         {\n        //             #if UNITY_EDITOR\n        //             if (methods_raw[i].GetParameters().Length > 1) throw new System.Exception($\"Error '{methods_raw[i].Name}' : Theres more than one parameter, please set 1 or 0 parameter. (if you need to add more than 1 argument use Tuples or create a struct, record o class...)\");\n        //             #endif\n        //             methods[method_count++] = (methods_raw[i], attribute);\n        //         }\n        //     }\n", "        //     for (int i = 0; i < method_count; i++)\n        //     {\n        //         var method = methods[i].Method;\n        //         var attribute = methods[i].Attribute;\n        //         var parameters = method.GetParameters();\n        //         var returnType = method.ReturnType;\n\n        //         switch ((parameters.Length == 1, returnType != m_type_void))\n        //         {\n        //             case (false, false):\n        //                 m_type_flux.MakeGenericType(attribute.key.GetType())\n        //                     .GetMethod(m_type_flux_method, m_bindingflag_all)\n        //                     .Invoke(null, new object[] { attribute.key, Delegate.CreateDelegate(m_type_flux_delegate, monoflux, method), condition }.ToArray());\n        //                 break;\n        //             case (true, false):\n        //                 m_type_fluxparam.MakeGenericType(attribute.key.GetType(), parameters[0].ParameterType)\n        //                     .GetMethod(m_type_fluxparam_method, m_bindingflag_all)\n        //                     .Invoke(null, new object[] { attribute.key, Delegate.CreateDelegate(m_type_fluxparam_delegate.MakeGenericType(parameters[0].ParameterType), monoflux, method), condition }.ToArray());\n        //                 break;\n        //             case (false, true):\n        //                 m_type_fluxreturn.MakeGenericType(attribute.key.GetType(), returnType)\n        //                     .GetMethod(m_type_fluxreturn_method, m_bindingflag_all)\n        //                     .Invoke(null, new object[] { attribute.key, Delegate.CreateDelegate(m_type_fluxreturn_delegate.MakeGenericType(returnType), monoflux, method), condition }.ToArray());\n        //                 break;\n        //             case (true, true):\n        //                 m_type_fluxparamreturn.MakeGenericType(attribute.key.GetType(), parameters[0].ParameterType, returnType)\n        //                     .GetMethod(m_type_fluxparamreturn_method, m_bindingflag_all)\n        //                     .Invoke(null, new object[] { attribute.key, Delegate.CreateDelegate(m_type_fluxparamreturn_delegate.MakeGenericType(parameters[0].ParameterType, returnType), monoflux, method), condition }.ToArray());\n        //                 break;\n        //         }\n        //     }\n        // }\n        // internal static void Subscribe_v4(this MonoFlux monoflux, in bool condition)\n        // {\n        //     var methods_raw = monoflux.GetType().GetMethods(m_bindingflag_all);\n        //     var methods = new (MethodInfo Method, FluxAttribute Attribute)[methods_raw.Length];\n        //     var method_count = 0;", "        //     for (int i = 0; i < methods_raw.Length; i++)\n        //     {\n        //         var attribute = methods_raw[i].GetCustomAttribute<FluxAttribute>();\n        //         if (attribute != null)\n        //         {\n        //             methods[method_count++] = (methods_raw[i], attribute);\n        //         }\n        //     }\n        //     for (int i = 0; i < method_count; i++)\n        //     {\n        //         var method = methods[i].Method;\n        //         var attribute = methods[i].Attribute;\n        //         var parameters = method.GetParameters();\n        //         var returnType = method.ReturnType;\n\n        //         switch ((parameters.Length == 1, returnType != m_type_void))\n        //         {\n        //             case (false, false):\n        //                 var genericType = m_type_flux.MakeGenericType(attribute.key.GetType());\n        //                 var methodInfo = genericType.GetMethod(m_type_flux_method, m_bindingflag_all);\n        //                 var delegateType = m_type_flux_delegate;\n        //                 var delegateMethod = Delegate.CreateDelegate(delegateType, monoflux, method);\n        //                 var arguments = new object[] { attribute.key, delegateMethod, condition };\n        //                 methodInfo.Invoke(null, arguments);\n        //                 break;\n        //             case (true, false):\n        //                 genericType = m_type_fluxparam.MakeGenericType(attribute.key.GetType(), parameters[0].ParameterType);\n        //                 methodInfo = genericType.GetMethod(m_type_fluxparam_method, m_bindingflag_all);\n        //                 delegateType = m_type_fluxparam_delegate.MakeGenericType(parameters[0].ParameterType);\n        //                 delegateMethod = Delegate.CreateDelegate(delegateType, monoflux, method);\n        //                 arguments = new object[] { attribute.key, delegateMethod, condition };\n        //                 methodInfo.Invoke(null, arguments);\n        //                 break;\n        //             case (false, true):\n        //                 genericType = m_type_fluxreturn.MakeGenericType(attribute.key.GetType(), returnType);\n        //                 methodInfo = genericType.GetMethod(m_type_fluxreturn_method, m_bindingflag_all);\n        //                 delegateType = m_type_fluxreturn_delegate.MakeGenericType(returnType);\n        //                 delegateMethod = Delegate.CreateDelegate(delegateType, monoflux, method);\n        //                 arguments = new object[] { attribute.key, delegateMethod, condition };\n        //                 methodInfo.Invoke(null, arguments);\n        //                 break;\n        //             case (true, true):\n        //                 genericType = m_type_fluxparamreturn.MakeGenericType(attribute.key.GetType(), parameters[0].ParameterType, returnType);\n        //                 methodInfo = genericType.GetMethod(m_type_fluxparamreturn_method, m_bindingflag_all);\n        //                 delegateType = m_type_fluxparamreturn_delegate.MakeGenericType(parameters[0].ParameterType, returnType);\n        //                 delegateMethod = Delegate.CreateDelegate(delegateType, monoflux, method);\n        //                 arguments = new object[] { attribute.key, delegateMethod, condition };\n        //                 methodInfo.Invoke(null, arguments);\n        //                 break;\n        //         }\n        //     }\n        // }\n    }\n}", "        //     for (int i = 0; i < method_count; i++)\n        //     {\n        //         var method = methods[i].Method;\n        //         var attribute = methods[i].Attribute;\n        //         var parameters = method.GetParameters();\n        //         var returnType = method.ReturnType;\n\n        //         switch ((parameters.Length == 1, returnType != m_type_void))\n        //         {\n        //             case (false, false):\n        //                 var genericType = m_type_flux.MakeGenericType(attribute.key.GetType());\n        //                 var methodInfo = genericType.GetMethod(m_type_flux_method, m_bindingflag_all);\n        //                 var delegateType = m_type_flux_delegate;\n        //                 var delegateMethod = Delegate.CreateDelegate(delegateType, monoflux, method);\n        //                 var arguments = new object[] { attribute.key, delegateMethod, condition };\n        //                 methodInfo.Invoke(null, arguments);\n        //                 break;\n        //             case (true, false):\n        //                 genericType = m_type_fluxparam.MakeGenericType(attribute.key.GetType(), parameters[0].ParameterType);\n        //                 methodInfo = genericType.GetMethod(m_type_fluxparam_method, m_bindingflag_all);\n        //                 delegateType = m_type_fluxparam_delegate.MakeGenericType(parameters[0].ParameterType);\n        //                 delegateMethod = Delegate.CreateDelegate(delegateType, monoflux, method);\n        //                 arguments = new object[] { attribute.key, delegateMethod, condition };\n        //                 methodInfo.Invoke(null, arguments);\n        //                 break;\n        //             case (false, true):\n        //                 genericType = m_type_fluxreturn.MakeGenericType(attribute.key.GetType(), returnType);\n        //                 methodInfo = genericType.GetMethod(m_type_fluxreturn_method, m_bindingflag_all);\n        //                 delegateType = m_type_fluxreturn_delegate.MakeGenericType(returnType);\n        //                 delegateMethod = Delegate.CreateDelegate(delegateType, monoflux, method);\n        //                 arguments = new object[] { attribute.key, delegateMethod, condition };\n        //                 methodInfo.Invoke(null, arguments);\n        //                 break;\n        //             case (true, true):\n        //                 genericType = m_type_fluxparamreturn.MakeGenericType(attribute.key.GetType(), parameters[0].ParameterType, returnType);\n        //                 methodInfo = genericType.GetMethod(m_type_fluxparamreturn_method, m_bindingflag_all);\n        //                 delegateType = m_type_fluxparamreturn_delegate.MakeGenericType(parameters[0].ParameterType, returnType);\n        //                 delegateMethod = Delegate.CreateDelegate(delegateType, monoflux, method);\n        //                 arguments = new object[] { attribute.key, delegateMethod, condition };\n        //                 methodInfo.Invoke(null, arguments);\n        //                 break;\n        //         }\n        //     }\n        // }\n    }\n}"]}
{"filename": "Runtime/UniFlux.String.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Kingdox.UniFlux.Core;", "using System.Threading.Tasks;\nusing Kingdox.UniFlux.Core;\n// asmdef Version Defines, enabled when com.cysharp.unitask is imported.\n#if UNIFLUX_UNITASK_SUPPORT\n    using Cysharp.Threading.Tasks;\n    namespace Kingdox.UniFlux\n    {\n        public static partial class FluxExtension //Action<UniTask>\n        {\n            public static void Store(this string key, Action<UniTask> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store(this string key, Func<UniTask> action, bool condition) => Flux.Store(key, action, condition);", "            public static void Store(this string key, Action<UniTask> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store(this string key, Func<UniTask> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store<T>(this string key, Func<UniTask<T>> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store<T>(this string key, Func<T, UniTask> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store<T,T2>(this string key, Func<T, UniTask<T2>> action, bool condition) => Flux.Store(key, action, condition);\n\n            public static UniTask @UniTask(this string key) => Flux.Dispatch<string, UniTask>(key);\n            public static UniTask<T> @UniTask<T>(this string key) => Flux.Dispatch<string, UniTask<T>>(key);\n            public static UniTask @UniTask<T>(this string key, T @param) => Flux.Dispatch<string, T, UniTask>(key, @param);\n            public static UniTask<T2> @UniTask<T, T2>(this string key, T @param) => Flux.Dispatch<string, T, UniTask<T2>>(key, @param);\n        }\n    }\n#endif\n#if UNIFLUX_UNIRX_SUPPORT\n    namespace Kingdox.UniFlux\n    {\n        #if !(NETFX_CORE || NET_4_6 || NET_STANDARD_2_0 || UNITY_WSA_10_0)", "            public static UniTask @UniTask<T>(this string key, T @param) => Flux.Dispatch<string, T, UniTask>(key, @param);\n            public static UniTask<T2> @UniTask<T, T2>(this string key, T @param) => Flux.Dispatch<string, T, UniTask<T2>>(key, @param);\n        }\n    }\n#endif\n#if UNIFLUX_UNIRX_SUPPORT\n    namespace Kingdox.UniFlux\n    {\n        #if !(NETFX_CORE || NET_4_6 || NET_STANDARD_2_0 || UNITY_WSA_10_0)\n        public static partial class FluxExtension //Action<UniRx.IObservable<T>>\n        {", "        public static partial class FluxExtension //Action<UniRx.IObservable<T>>\n        {\n            public static void Store<T>(this string key, Action<UniRx.IObservable<T>> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store<T>(this string key, Func<UniRx.IObservable<T>> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store<T,T2>(this string key, Func<T, UniRx.IObservable<T2>> action, bool condition) => Flux.Store(key, action, condition);\n            public static void @IObservable<T>(this string key, UniRx.IObservable<T> @param) => Flux.Dispatch(key, @param);\n            public static UniRx.IObservable<T> @IObservable<T>(this string key) => Flux.Dispatch<int,UniRx.IObservable<T>>(key);\n            public static UniRx.IObservable<T2> @IObservable<T,T2>(this string key, T @param) => Flux.Dispatch<int, T, UniRx.IObservable<T2>>(key, @param);\n        }\n        public static partial class FluxExtension //Action<UniRx.IObserver<T>>\n        {", "        public static partial class FluxExtension //Action<UniRx.IObserver<T>>\n        {\n            public static void Store<T>(this string key, Action<UniRx.IObserver<T>> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store<T>(this string key, Func<UniRx.IObserver<T>> action, bool condition) => Flux.Store(key, action, condition);\n            public static void Store<T,T2>(this string key, Func<T, UniRx.IObserver<T2>> action, bool condition) => Flux.Store(key, action, condition);\n            public static void @IObserver<T>(this string key, UniRx.IObserver<T> @param) => Flux.Dispatch(key, @param);\n            public static UniRx.IObserver<T> @IObserver<T>(this string key) => Flux.Dispatch<int,UniRx.IObserver<T>>(key);\n            public static UniRx.IObserver<T2> @IObserver<T,T2>(this string key, T @param) => Flux.Dispatch<int, T, UniRx.IObserver<T2>>(key, @param);\n        }\n        #endif\n    }\n#endif\nnamespace Kingdox.UniFlux\n{\n#region Common", "    public static partial class FluxExtension //Action\n    {\n        public static void Store(this string key, in Action action, in bool condition) => Flux.Store(in key, in action,in condition);\n        public static void Dispatch(this string key) => Flux.Dispatch(key);\n    }\n    public static partial class FluxExtension //Action<T>\n    {\n        public static void Store<T>(this string key, in Action<T> action,in bool condition) => Flux.Store(in key, in action, in condition);\n        public static void Dispatch<T>(this string key, in T @param) => Flux.Dispatch(in key, in @param);\n    }\n    public static partial class FluxExtension //Func<out T>\n    {", "        public static void Dispatch<T>(this string key, in T @param) => Flux.Dispatch(in key, in @param);\n    }\n    public static partial class FluxExtension //Func<out T>\n    {\n        public static void Store<T>(this string key, in Func<T> action, in bool condition) => Flux.Store(in key, in action, in condition);\n        public static T Dispatch<T>(this string key) => Flux.Dispatch<string, T>(in key);\n    }\n    public static partial class FluxExtension //Func<T, out T2>\n    {\n        public static void Store<T,T2>(this string key, in Func<T, T2> action, in bool condition) => Flux.Store(in key, in action, in condition);\n        public static T2 Dispatch<T, T2>(this string key, in T @param) => Flux.Dispatch<string, T, T2>(in key, in @param);\n    }", "        public static void Store<T,T2>(this string key, in Func<T, T2> action, in bool condition) => Flux.Store(in key, in action, in condition);\n        public static T2 Dispatch<T, T2>(this string key, in T @param) => Flux.Dispatch<string, T, T2>(in key, in @param);\n    }\n    public static partial class FluxExtension //State Action<T>\n    {\n        public static void StoreState<T>(this string key, in Action<T> action,in bool condition) => Flux.StoreState(in key, in action, in condition);\n        public static void DispatchState<T>(this string key, in T state) => Flux.DispatchState(in key, in state);\n        public static bool GetState<T>(this string key, out T state) => Flux.GetState(in key, out state);\n    }\n#endregion\n#region IEnumerator", "    public static partial class FluxExtension //Action<IEnumerator>\n    {\n        public static void Store(this string key, in Action<IEnumerator> action, in bool condition) => Flux.Store(in key, in action, in condition);\n        public static void Store(this string key, in Func<IEnumerator> action, in bool condition) => Flux.Store(in key, in action, in condition);\n        public static void Store<T>(this string key, in Func<IEnumerator<T>> action, in bool condition) => Flux.Store(in key, in action, in condition);\n        public static void Store<T>(this string key, in Func<T, IEnumerator> action, in bool condition) => Flux.Store(in key, in action, in condition);\n        public static void Store<T,T2>(this string key, in Func<T, IEnumerator<T2>> action, in bool condition) => Flux.Store(in key, in action, in condition);\n\n        public static IEnumerator @IEnumerator(this string key) => Flux.Dispatch<string, IEnumerator>(in key);\n        public static IEnumerator<T> @IEnumerator<T>(this string key) => Flux.Dispatch<string, IEnumerator<T>>(in key);\n        public static IEnumerator @IEnumerator<T>(this string key, in T @param) => Flux.Dispatch<string, T, IEnumerator>(in key, in @param);", "        public static IEnumerator @IEnumerator(this string key) => Flux.Dispatch<string, IEnumerator>(in key);\n        public static IEnumerator<T> @IEnumerator<T>(this string key) => Flux.Dispatch<string, IEnumerator<T>>(in key);\n        public static IEnumerator @IEnumerator<T>(this string key, in T @param) => Flux.Dispatch<string, T, IEnumerator>(in key, in @param);\n        public static IEnumerator<T2> @IEnumerator<T, T2>(this string key, in T @param) => Flux.Dispatch<string, T, IEnumerator<T2>>(in key, in @param);\n    }\n#endregion\n#region Task\n    public static partial class FluxExtension //Action<Task>\n    {\n        public static void Store(this string key, in Action<Task> action, in bool condition) => Flux.Store(in key,in action,in condition);\n        public static void Store(this string key, in Func<Task> action, in bool condition) => Flux.Store(in key,in action,in condition);", "        public static void Store(this string key, in Action<Task> action, in bool condition) => Flux.Store(in key,in action,in condition);\n        public static void Store(this string key, in Func<Task> action, in bool condition) => Flux.Store(in key,in action,in condition);\n        public static void Store<T>(this string key, in Func<Task<T>> action, in bool condition) => Flux.Store(in key,in action,in condition);\n        public static void Store<T>(this string key, in Func<T, Task> action, in bool condition) => Flux.Store(in key,in action,in condition);\n        public static void Store<T,T2>(this string key, in Func<T, Task<T2>> action, in bool condition) => Flux.Store(in key,in action,in condition);\n\n        public static Task @Task(this string key) => Flux.Dispatch<string, Task>(key);\n        public static Task<T> @Task<T>(this string key) => Flux.Dispatch<string, Task<T>>(key);\n        public static Task @Task<T>(this string key, in T @param) => Flux.Dispatch<string, T, Task>(key, in @param);\n        public static Task<T2> @Task<T, T2>(this string key, in T @param) => Flux.Dispatch<string, T, Task<T2>>(key, in @param);\n    }\n#endregion\n#region IObservable<T>", "        public static Task @Task<T>(this string key, in T @param) => Flux.Dispatch<string, T, Task>(key, in @param);\n        public static Task<T2> @Task<T, T2>(this string key, in T @param) => Flux.Dispatch<string, T, Task<T2>>(key, in @param);\n    }\n#endregion\n#region IObservable<T>\n    public static partial class FluxExtension //Action<IObservable<T>>\n    {\n        public static void Store<T>(this string key, Action<IObservable<T>> action, bool condition) => Flux.Store(key, action, condition);\n        public static void Store<T>(this string key, Func<IObservable<T>> action, bool condition) => Flux.Store(key, action, condition);\n        public static void Store<T,T2>(this string key, Func<T, IObservable<T2>> action, bool condition) => Flux.Store(key, action, condition);\n        public static void @IObservable<T>(this string key, IObservable<T> @param) => Flux.Dispatch(key, @param);", "        public static void Store<T>(this string key, Func<IObservable<T>> action, bool condition) => Flux.Store(key, action, condition);\n        public static void Store<T,T2>(this string key, Func<T, IObservable<T2>> action, bool condition) => Flux.Store(key, action, condition);\n        public static void @IObservable<T>(this string key, IObservable<T> @param) => Flux.Dispatch(key, @param);\n        public static IObservable<T> @IObservable<T>(this string key) => Flux.Dispatch<string,IObservable<T>>(key);\n        public static IObservable<T2> @IObservable<T,T2>(this string key, T @param) => Flux.Dispatch<string, T, IObservable<T2>>(key, @param);\n    }\n#endregion\n#region IObserver<T>\n    public static partial class FluxExtension //Action<IObserver<T>>\n    {\n        public static void Store<T>(this string key, Action<IObserver<T>> action, bool condition) => Flux.Store(key, action, condition);", "    public static partial class FluxExtension //Action<IObserver<T>>\n    {\n        public static void Store<T>(this string key, Action<IObserver<T>> action, bool condition) => Flux.Store(key, action, condition);\n        public static void Store<T>(this string key, Func<IObserver<T>> action, bool condition) => Flux.Store(key, action, condition);\n        public static void Store<T,T2>(this string key, Func<T, IObserver<T2>> action, bool condition) => Flux.Store(key, action, condition);\n        public static void @IObserver<T>(this string key, IObserver<T> @param) => Flux.Dispatch(key, @param);\n        public static IObserver<T> @IObserver<T>(this string key) => Flux.Dispatch<string, IObserver<T>>(key);\n        public static IObserver<T2> @IObserver<T,T2>(this string key, T @param) => Flux.Dispatch<string, T, IObserver<T2>>(key, @param);\n    }\n#endregion\n}\n"]}
{"filename": "Runtime/UniFlux.Utils.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nnamespace Kingdox.UniFlux\n{\n    public static class Utils \n    {\n        public static void Subscribe<T>(in this bool condition, ref T action,in T callback) where T : System.Delegate\n        {", "        public static void Subscribe<T>(in this bool condition, ref T action,in T callback) where T : System.Delegate\n        {\n            if(condition) action = (T)System.Delegate.Combine(action, callback);\n            else action = (T)System.Delegate.Remove(action, callback);\n        }\n    }\n}"]}
{"filename": "Runtime/Experimental/IKeyFlux.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nnamespace Kingdox.UniFlux.Experimental\n{\n    public interface IKeyFlux\n    {\n        object Key { get; }\n    }\n}"]}
{"filename": "Runtime/Experimental/IKeyFluxT.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nnamespace Kingdox.UniFlux.Experimental\n{\n    public interface IKeyFlux<T> : IKeyFlux\n    {\n        T KeyT { get; }\n    }\n}"]}
{"filename": "Runtime/Experimental/KeyFluxT.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nnamespace Kingdox.UniFlux.Experimental\n{\n    [Serializable] public abstract class KeyFlux<T> : KeyFluxBase, IKeyFlux<T>\n    {\n        protected override object Key => KeyT;", "    [Serializable] public abstract class KeyFlux<T> : KeyFluxBase, IKeyFlux<T>\n    {\n        protected override object Key => KeyT;\n        protected abstract T KeyT {get; }\n        T IKeyFlux<T>.KeyT => KeyT;\n        public sealed override void Store(in Action callback, in bool condition) => Core.Flux.Store(KeyT, callback, condition);\n        public sealed override void Dispatch() => Core.Flux.Dispatch(KeyT);\n        public sealed override void Store<T2>(in Action<T2> callback, in bool condition) => Core.Flux.Store<T,T2>(KeyT, in callback, in condition);\n        public sealed override void Dispatch<T2>(in T2 @param) => Core.Flux.Dispatch(KeyT, in @param);\n        public sealed override void Store<T2>(in Func<T2> callback, in bool condition) => Core.Flux.Store<T,T2>(KeyT, in callback, in condition);\n        public sealed override T2 Dispatch<T2>() => Core.Flux.Dispatch<T, T2>(KeyT);", "        public sealed override void Dispatch<T2>(in T2 @param) => Core.Flux.Dispatch(KeyT, in @param);\n        public sealed override void Store<T2>(in Func<T2> callback, in bool condition) => Core.Flux.Store<T,T2>(KeyT, in callback, in condition);\n        public sealed override T2 Dispatch<T2>() => Core.Flux.Dispatch<T, T2>(KeyT);\n        public sealed override void Store<T2, T3>(in Func<T2, T3> callback, in bool condition) => Core.Flux.Store<T,T2,T3>(KeyT, in callback, in condition);\n        public sealed override T3 Dispatch<T2, T3>(in T2 @param) => Core.Flux.Dispatch<T,T2,T3>(KeyT, in @param);\n        public sealed override void StoreState<T2>(in Action<T2> callback, in bool condition) => Core.Flux.StoreState<T,T2>(KeyT, in callback, in condition);\n        public sealed override void DispatchState<T2>(in T2 @param) => Core.Flux.DispatchState(KeyT, in @param);\n    }\n}"]}
{"filename": "Runtime/Experimental/KeyFlux.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nusing UnityEngine;\nnamespace Kingdox.UniFlux.Experimental\n{\n    /// <summary>", "{\n    /// <summary>\n    /// Key to Store or Dispatch with UniFlux System\n    /// </summary>\n    [CreateAssetMenu(menuName = \"Kingdox/UniFlux/KeyFlux/KeyFlux\", fileName = \"KeyFlux.\")]\n    [Serializable]\n    public sealed class KeyFlux : KeyFlux<KeyFlux>\n    {\n        protected override KeyFlux KeyT => this;\n    }\n}", "        protected override KeyFlux KeyT => this;\n    }\n}"]}
{"filename": "Runtime/Experimental/KeyFluxBase.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nusing UnityEngine;\nnamespace Kingdox.UniFlux.Experimental\n{\n    [Serializable]\n    public abstract class KeyFluxBase : ScriptableObject, IKeyFlux\n    {", "{\n    [Serializable]\n    public abstract class KeyFluxBase : ScriptableObject, IKeyFlux\n    {\n        protected abstract object Key { get; }\n        object IKeyFlux.Key => Key;\n        public virtual void Store(in Action callback, in bool condition) => Core.Flux.Store(Key, callback, condition);\n        public virtual void Dispatch() => Core.Flux.Dispatch(Key);\n        public virtual void Store<T2>(in Action<T2> callback, in bool condition) => Core.Flux.Store<object,T2>(Key, in callback, in condition);\n        public virtual void Dispatch<T2>(in T2 @param) => Core.Flux.Dispatch(Key, in @param);\n        public virtual void Store<T2>(in Func<T2> callback, in bool condition) => Core.Flux.Store<object,T2>(Key, in callback, in condition);", "        public virtual void Store<T2>(in Action<T2> callback, in bool condition) => Core.Flux.Store<object,T2>(Key, in callback, in condition);\n        public virtual void Dispatch<T2>(in T2 @param) => Core.Flux.Dispatch(Key, in @param);\n        public virtual void Store<T2>(in Func<T2> callback, in bool condition) => Core.Flux.Store<object,T2>(Key, in callback, in condition);\n        public virtual T2 Dispatch<T2>() => Core.Flux.Dispatch<object, T2>(Key);\n        public virtual void Store<T2, T3>(in Func<T2, T3> callback, in bool condition) => Core.Flux.Store<object,T2,T3>(Key, in callback, in condition);\n        public virtual T3 Dispatch<T2, T3>(in T2 @param) => Core.Flux.Dispatch<object,T2,T3>(Key, in @param);\n        public virtual void StoreState<T2>(in Action<T2> callback, in bool condition) => Core.Flux.StoreState<object,T2>(Key, in callback, in condition);\n        public virtual void DispatchState<T2>(in T2 @param) => Core.Flux.DispatchState(Key, in @param);\n    }\n}"]}
{"filename": "Runtime/Core/Flux.cs", "chunked_list": ["using System;\nnamespace Kingdox.UniFlux.Core\n{\n    public static class Flux \n    {\n#region // Flux\n        public static void Store<T>(in T key, in Action callback, in bool condition) => Internal.Flux<T>.Store(in key, in callback, in condition);\n        public static void Dispatch<T>(in T key) => Internal.Flux<T>.Dispatch(in key);\n#endregion\n#region // FluxParam\n        public static void Store<T,T2>(in T key, in Action<T2> callback, in bool condition) => Internal.FluxParam<T,T2>.Store(in key, in callback, in condition);", "        public static void Store<T,T2>(in T key, in Action<T2> callback, in bool condition) => Internal.FluxParam<T,T2>.Store(in key, in callback, in condition);\n        public static void Dispatch<T, T2>(in T key, in T2 @param) => Internal.FluxParam<T,T2>.Dispatch(in key, in @param);\n#endregion\n#region // FluxReturn\n        public static void Store<T,T2>(in T key, in Func<T2> callback, in bool condition) => Internal.FluxReturn<T,T2>.Store(in key, in callback, in condition);\n        public static T2 Dispatch<T, T2>(in T key) => Internal.FluxReturn<T,T2>.Dispatch(in key);\n#endregion\n#region // FluxParamReturn\n        public static void Store<T, T2, T3>(in T key, in Func<T2, T3> callback, in bool condition) => Internal.FluxParamReturn<T,T2,T3>.Store(in key, in callback, in condition);\n        public static T3 Dispatch<T, T2, T3>(in T key, in T2 @param) => Internal.FluxParamReturn<T,T2,T3>.Dispatch(in key, in @param);\n#endregion\n#region // FluxState", "        public static void Store<T, T2, T3>(in T key, in Func<T2, T3> callback, in bool condition) => Internal.FluxParamReturn<T,T2,T3>.Store(in key, in callback, in condition);\n        public static T3 Dispatch<T, T2, T3>(in T key, in T2 @param) => Internal.FluxParamReturn<T,T2,T3>.Dispatch(in key, in @param);\n#endregion\n#region // FluxState\n        public static void StoreState<T,T2>(in T key, in Action<T2> callback, in bool condition) => Internal.FluxState<T,T2>.Store(in key, in callback, in condition);\n        public static void DispatchState<T, T2>(in T key, in T2 @param) => Internal.FluxState<T,T2>.Dispatch(in key, in @param);\n        public static bool GetState<T, T2>(in T key, out T2 @state) => Internal.FluxState<T,T2>.Get(in key, out @state);\n#endregion\n    }\n}"]}
{"filename": "Runtime/Core/Internal/StateFlux.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nusing System.Collections.Generic;\nnamespace Kingdox.UniFlux.Core.Internal\n{\n    internal sealed class StateFlux<TKey, TValue> : IFluxParam<TKey, TValue, Action<TValue>>\n    {\n        internal readonly Dictionary<TKey, State<TValue>> dictionary = new Dictionary<TKey, State<TValue>>();\n        void IStore<TKey, Action<TValue>>.Store(in bool condition, TKey key, Action<TValue> action)\n        {", "{\n    internal sealed class StateFlux<TKey, TValue> : IFluxParam<TKey, TValue, Action<TValue>>\n    {\n        internal readonly Dictionary<TKey, State<TValue>> dictionary = new Dictionary<TKey, State<TValue>>();\n        void IStore<TKey, Action<TValue>>.Store(in bool condition, TKey key, Action<TValue> action)\n        {\n            if(dictionary.TryGetValue(key, out var state)) \n            {\n                state.Store(condition,action);\n            }\n            else if (condition)\n            {\n                dictionary.Add(key, new State<TValue>(action));\n            }\n        }\n        void IFluxParam<TKey, TValue, Action<TValue>>.Dispatch(TKey key, TValue param)\n        {", "            else if (condition)\n            {\n                dictionary.Add(key, new State<TValue>(action));\n            }\n        }\n        void IFluxParam<TKey, TValue, Action<TValue>>.Dispatch(TKey key, TValue param)\n        {\n            if(dictionary.TryGetValue(key, out var state)) \n            {\n                state.Dispatch(param);\n            }\n            else\n            {\n                dictionary.Add(key, new State<TValue>(param));\n            }\n        }\n    }\n}"]}
{"filename": "Runtime/Core/Internal/IFlux.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nnamespace Kingdox.UniFlux.Core.Internal\n{\n    /// <summary>\n    ///  TKey\n    /// </summary>\n    internal interface IFlux<in TKey, in TStorage>:  IStore<TKey, TStorage>\n    {\n        /// <summary>\n        ///  Dispatch the TKey\n        /// </summary>\n        void Dispatch(TKey key);\n    }\n    /// <summary>\n    ///  TKey TParam\n    /// </summary>", "    ///  TKey\n    /// </summary>\n    internal interface IFlux<in TKey, in TStorage>:  IStore<TKey, TStorage>\n    {\n        /// <summary>\n        ///  Dispatch the TKey\n        /// </summary>\n        void Dispatch(TKey key);\n    }\n    /// <summary>\n    ///  TKey TParam\n    /// </summary>", "    internal interface IFluxParam<in TKey, in TParam, in TStorage> : IStore<TKey, TStorage>\n    {\n        /// <summary>\n        ///  Dispatch the TKey with TParam\n        /// </summary>\n        void Dispatch(TKey key, TParam param);\n    }\n    /// <summary>\n    ///  TKey TReturn\n    /// </summary>\n    internal interface IFluxReturn<in TKey, out TReturn, in TStorage> : IStore<TKey, TStorage>\n    {\n        /// <summary>\n        ///  Dispatch the TKey and return TReturn\n        /// </summary>\n        TReturn Dispatch(TKey key);   \n    }\n    /// <summary>\n    ///  TKey TParam TReturn\n    /// </summary>", "    internal interface IFluxReturn<in TKey, out TReturn, in TStorage> : IStore<TKey, TStorage>\n    {\n        /// <summary>\n        ///  Dispatch the TKey and return TReturn\n        /// </summary>\n        TReturn Dispatch(TKey key);   \n    }\n    /// <summary>\n    ///  TKey TParam TReturn\n    /// </summary>\n    internal interface IFluxParamReturn<in TKey, in TParam, out TReturn, in TStorage> : IStore<TKey, TStorage>\n    {\n        /// <summary>\n        ///  Dispatch the TKey with TParam and return TReturn\n        /// </summary>\n        TReturn Dispatch(TKey key, TParam param);\n    }\n}", "    internal interface IFluxParamReturn<in TKey, in TParam, out TReturn, in TStorage> : IStore<TKey, TStorage>\n    {\n        /// <summary>\n        ///  Dispatch the TKey with TParam and return TReturn\n        /// </summary>\n        TReturn Dispatch(TKey key, TParam param);\n    }\n}"]}
{"filename": "Runtime/Core/Internal/FluxParam_T_T2.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nnamespace Kingdox.UniFlux.Core.Internal\n{\n    ///<summary>\n    /// Flux<T> Action<T2>", "    ///<summary>\n    /// Flux<T> Action<T2>\n    ///</summary>\n    internal static class FluxParam<T,T2> // (T, Action<T2>)\n    {\n        ///<summary>\n        /// Defines a static instance of ActionFluxParam<T, T2>\n        ///</summary>\n        internal static readonly IFluxParam<T, T2, Action<T2>> flux_action_param = new ActionFluxParam<T,T2>();\n        ///<summary>\n        /// Defines a static method that subscribes an action with a parameter to a key with a condition\n        ///</summary>\n        internal static void Store(in T key, in  Action<T2> action, in  bool condition) => flux_action_param.Store(in condition, key, action);\n        ///<summary>\n        /// Defines a static method that triggers an action with a parameter with a key\n        ///</summary>\n        internal static void Dispatch(in T key,in  T2 @param) => flux_action_param.Dispatch(key, @param);\n    }\n}"]}
{"filename": "Runtime/Core/Internal/FuncFlux.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nusing System.Collections.Generic;\nnamespace Kingdox.UniFlux.Core.Internal\n{\n    /// <summary>\n    /// The `FuncFlux` class represents a flux that stores functions with no parameters and a return value of type `TReturn`.\n    /// It provides a dictionary to store the functions and methods to subscribe and trigger the stored functions.\n    /// </summary>\n    /// <typeparam name=\"TKey\">The type of the keys used to store the functions in the dictionary.</typeparam>\n    /// <typeparam name=\"TReturn\">The return type of the functions stored in the dictionary.</typeparam>", "{\n    /// <summary>\n    /// The `FuncFlux` class represents a flux that stores functions with no parameters and a return value of type `TReturn`.\n    /// It provides a dictionary to store the functions and methods to subscribe and trigger the stored functions.\n    /// </summary>\n    /// <typeparam name=\"TKey\">The type of the keys used to store the functions in the dictionary.</typeparam>\n    /// <typeparam name=\"TReturn\">The return type of the functions stored in the dictionary.</typeparam>\n    internal sealed class FuncFlux<TKey, TReturn> : IFluxReturn<TKey, TReturn, Func<TReturn>>\n    {\n        /// <summary>\n        /// A dictionary that stores functions with no parameters and a return value of type `TReturn`.\n        /// </summary>\n        internal readonly Dictionary<TKey, Func<TReturn>> dictionary = new Dictionary<TKey, Func<TReturn>>();\n        /// <summary>\n        /// Subscribes the provided function to the dictionary with the specified key when `condition` is true. \n        /// If `condition` is false and the dictionary contains the specified key, the function is removed from the dictionary.\n        /// </summary>\n        void IStore<TKey, Func<TReturn>>.Store(in bool condition, TKey key, Func<TReturn> func) \n        {", "            if(dictionary.TryGetValue(key, out var values))\n            {\n                if (condition) dictionary[key] += func;\n                else\n                {\n                    values -= func;\n                    if (values is null) dictionary.Remove(key);\n                    else dictionary[key] = values;\n                }\n            }\n            else if (condition) dictionary.Add(key, func);\n        }\n        // <summary>\n        /// Triggers the function stored in the dictionary with the specified key and returns its return value. \n        /// If the dictionary does not contain the specified key, returns the default value of type `TReturn`.\n        /// </summary>\n        TReturn IFluxReturn<TKey, TReturn, Func<TReturn>>.Dispatch(TKey key)\n        {", "            else if (condition) dictionary.Add(key, func);\n        }\n        // <summary>\n        /// Triggers the function stored in the dictionary with the specified key and returns its return value. \n        /// If the dictionary does not contain the specified key, returns the default value of type `TReturn`.\n        /// </summary>\n        TReturn IFluxReturn<TKey, TReturn, Func<TReturn>>.Dispatch(TKey key)\n        {\n            if(dictionary.TryGetValue(key, out var _actions)) \n            {\n                return _actions.Invoke();\n            }\n            return default;\n        }\n    }\n}", "            if(dictionary.TryGetValue(key, out var _actions)) \n            {\n                return _actions.Invoke();\n            }\n            return default;\n        }\n    }\n}"]}
{"filename": "Runtime/Core/Internal/State.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nusing System.Collections.Generic;\nnamespace Kingdox.UniFlux.Core.Internal\n{\n    internal sealed class State<TValue>\n    {", "{\n    internal sealed class State<TValue>\n    {\n        private bool inited = false;\n        private TValue state = default;\n        private readonly HashSet<Action<TValue>> actions = new HashSet<Action<TValue>>();\n        public State(Action<TValue> action)\n        {\n            Store(true, action);\n        }\n        public State(TValue value)\n        {\n            Dispatch(value);\n        }", "        public void Store(in bool condition, in Action<TValue> action)\n        {\n            if (condition)\n            {\n                actions.Add(action);\n                if(inited)\n                {\n                    action.Invoke(state);\n                }\n            }\n            else actions.Remove(action);\n        }", "        private bool IsDifferentState(in TValue value) => !Object.Equals(value, state);\n        public void Dispatch(in TValue value)\n        {\n            if (IsDifferentState(value))\n            {\n                state = value;\n                foreach (var item in actions) item.Invoke(value);\n            }\n            inited=true;\n        }\n        public bool Get(out TValue _value) \n        {\n            _value = state;\n            return inited;\n        }\n    }\n}", "        public bool Get(out TValue _value) \n        {\n            _value = state;\n            return inited;\n        }\n    }\n}"]}
{"filename": "Runtime/Core/Internal/ActionFluxParam.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nusing System.Collections.Generic;\nnamespace Kingdox.UniFlux.Core.Internal\n{\n    ///<summary>\n    /// This class represents an implementation of an IFlux interface with a TKey key and an action without parameters.\n    ///</summary>", "{\n    ///<summary>\n    /// This class represents an implementation of an IFlux interface with a TKey key and an action without parameters.\n    ///</summary>\n    internal sealed class ActionFluxParam<TKey, TValue> : IFluxParam<TKey, TValue, Action<TValue>>\n    {\n        /// <summary>\n        /// A dictionary that stores functions with parameters\n        /// </summary>\n        internal readonly Dictionary<TKey, HashSet<Action<TValue>>> dictionary = new Dictionary<TKey, HashSet<Action<TValue>>>();\n        ///<summary>\n        /// Subscribes an event to the action dictionary if the given condition is met\n        ///</summary>\n        ///<param name=\"condition\">Condition that must be true to subscribe the event</param>\n        ///<param name=\"key\">Key of the event to subscribe</param>\n        ///<param name=\"action\">Action to execute when the event is triggered</param>\n        void IStore<TKey, Action<TValue>>.Store(in bool condition, TKey key, Action<TValue> action)\n        {", "            if(dictionary.TryGetValue(key, out var values))\n            {\n                if (condition) values.Add(action);\n                else values.Remove(action);\n            }\n            else if (condition) dictionary.Add(key, new HashSet<Action<TValue>>(){action});\n        }\n        ///<summary>\n        /// Triggers the function stored in the dictionary with the specified key and set the parameter as argument \n        ///</summary>\n        void IFluxParam<TKey, TValue, Action<TValue>>.Dispatch(TKey key, TValue param)\n        {", "            if(dictionary.TryGetValue(key, out var _actions)) \n            {\n                foreach (var item in _actions) item.Invoke(param);\n            }\n        }\n    }\n}"]}
{"filename": "Runtime/Core/Internal/FuncFluxParam.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nusing System.Collections.Generic;\nnamespace Kingdox.UniFlux.Core.Internal\n{\n    /// <summary>\n    /// The `FuncFluxParam` class represents a flux that stores functions with one parameter of type `TParam` and a return value of type `TReturn`.\n    /// It provides a dictionary to store the functions and methods to subscribe and trigger the stored functions.\n    /// </summary>\n    /// <typeparam name=\"TKey\">The type of the keys used to store the functions in the dictionary.</typeparam>\n    /// <typeparam name=\"TParam\">The type of the parameter passed to the functions stored in the dictionary.</typeparam>\n    /// <typeparam name=\"TReturn\">The return type of the functions stored in the dictionary.</typeparam>", "{\n    /// <summary>\n    /// The `FuncFluxParam` class represents a flux that stores functions with one parameter of type `TParam` and a return value of type `TReturn`.\n    /// It provides a dictionary to store the functions and methods to subscribe and trigger the stored functions.\n    /// </summary>\n    /// <typeparam name=\"TKey\">The type of the keys used to store the functions in the dictionary.</typeparam>\n    /// <typeparam name=\"TParam\">The type of the parameter passed to the functions stored in the dictionary.</typeparam>\n    /// <typeparam name=\"TReturn\">The return type of the functions stored in the dictionary.</typeparam>\n    internal sealed class FuncFluxParam<TKey, TParam, TReturn> : IFluxParamReturn<TKey, TParam, TReturn, Func<TParam, TReturn>>\n    {\n        /// <summary>\n        /// A dictionary that stores functions with one parameter of type `TParam` and a return value of type `TReturn`.\n        /// </summary>\n        internal readonly Dictionary<TKey, Func<TParam, TReturn>> dictionary = new Dictionary<TKey, Func<TParam, TReturn>>();\n        /// <summary>\n        /// Subscribes the provided function to the dictionary with the specified key when `condition` is true. \n        /// If `condition` is false and the dictionary contains the specified key, the function is removed from the dictionary.\n        /// </summary>\n        void IStore<TKey, Func<TParam, TReturn>>.Store(in bool condition, TKey key, Func<TParam, TReturn> func)\n        {", "    internal sealed class FuncFluxParam<TKey, TParam, TReturn> : IFluxParamReturn<TKey, TParam, TReturn, Func<TParam, TReturn>>\n    {\n        /// <summary>\n        /// A dictionary that stores functions with one parameter of type `TParam` and a return value of type `TReturn`.\n        /// </summary>\n        internal readonly Dictionary<TKey, Func<TParam, TReturn>> dictionary = new Dictionary<TKey, Func<TParam, TReturn>>();\n        /// <summary>\n        /// Subscribes the provided function to the dictionary with the specified key when `condition` is true. \n        /// If `condition` is false and the dictionary contains the specified key, the function is removed from the dictionary.\n        /// </summary>\n        void IStore<TKey, Func<TParam, TReturn>>.Store(in bool condition, TKey key, Func<TParam, TReturn> func)\n        {", "            if(dictionary.TryGetValue(key, out var values))\n            {\n                if (condition) dictionary[key] += func;\n                else\n                {\n                    values -= func;\n                    if (values is null) dictionary.Remove(key);\n                    else dictionary[key] = values;\n                }\n            }\n            else if (condition) dictionary.Add(key, func);\n        }\n        /// <summary>\n        /// Triggers the function stored in the dictionary with the specified key and parameter, and returns its return value. \n        /// If the dictionary does not contain the specified key, returns the default value of type `TReturn`.\n        /// </summary>\n        TReturn IFluxParamReturn<TKey, TParam, TReturn, Func<TParam, TReturn>>.Dispatch(TKey key, TParam param)\n        {", "            else if (condition) dictionary.Add(key, func);\n        }\n        /// <summary>\n        /// Triggers the function stored in the dictionary with the specified key and parameter, and returns its return value. \n        /// If the dictionary does not contain the specified key, returns the default value of type `TReturn`.\n        /// </summary>\n        TReturn IFluxParamReturn<TKey, TParam, TReturn, Func<TParam, TReturn>>.Dispatch(TKey key, TParam param)\n        {\n            if(dictionary.TryGetValue(key, out var _actions))\n            {\n                return _actions.Invoke(param);\n            }\n            return default;\n        }\n    }\n}", "            if(dictionary.TryGetValue(key, out var _actions))\n            {\n                return _actions.Invoke(param);\n            }\n            return default;\n        }\n    }\n}"]}
{"filename": "Runtime/Core/Internal/ActionFlux.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nusing System.Collections.Generic;\nnamespace Kingdox.UniFlux.Core.Internal\n{\n    ///<summary>\n    /// This class represents an implementation of an IFlux interface with a TKey key and an action without parameters.\n    ///</summary>", "{\n    ///<summary>\n    /// This class represents an implementation of an IFlux interface with a TKey key and an action without parameters.\n    ///</summary>\n    internal sealed class ActionFlux<TKey> :  IFlux<TKey, Action>\n    {\n        /// <summary>\n        /// A dictionary that stores functions with no parameters\n        /// </summary>\n        internal Dictionary<TKey, HashSet<Action>> dictionary = new Dictionary<TKey, HashSet<Action>>();\n        ///<summary>\n        /// Subscribes an event to the action dictionary if the given condition is met\n        ///</summary>\n        ///<param name=\"condition\">Condition that must be true to subscribe the event</param>\n        ///<param name=\"key\">Key of the event to subscribe</param>\n        ///<param name=\"action\">Action to execute when the event is triggered</param>\n        void IStore<TKey, Action>.Store(in bool condition, TKey key, Action action)\n        {", "            if(dictionary.TryGetValue(key, out var values))\n            {\n                if (condition) values.Add(action);\n                else values.Remove(action);\n            }\n            else if (condition) dictionary.Add(key, new HashSet<Action>(){action});\n        }\n        ///<summary>\n        /// Triggers the function stored in the dictionary with the specified key. \n        ///</summary>\n        void IFlux<TKey, Action>.Dispatch(TKey key)\n        {", "            if(dictionary.TryGetValue(key, out var _actions)) \n            {\n                foreach (var item in _actions) item.Invoke();\n            }\n        }\n    }\n}\n//Hashtable<TAction>"]}
{"filename": "Runtime/Core/Internal/FluxParamReturn_T_T2_T3.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nnamespace Kingdox.UniFlux.Core.Internal\n{\n    ///<summary>\n    /// Flux<T> Func<T2, out T3>", "    ///<summary>\n    /// Flux<T> Func<T2, out T3>\n    ///</summary>\n    internal static class FluxParamReturn<T,T2,T3> // (T, Func<T2, out T3>)\n    {\n        ///<summary>\n        /// Defines a static instance of FuncFluxParam<T, T2, T3>\n        ///</summary>\n        internal static readonly IFluxParamReturn<T, T2, T3, Func<T2,T3>> flux_func_param = new FuncFluxParam<T, T2, T3>();\n        ///<summary>\n        /// Defines a static method that subscribes a function with a parameter that returns a value to a key with a condition\n        ///</summary>\n        internal static void Store(in T key, in Func<T2, T3> action, in bool condition) => flux_func_param.Store(in condition, key, action);\n        ///<summary>\n        /// Defines a static method that triggers a function with a parameter with a key and returns the result\n        ///</summary>\n        internal static T3 Dispatch(in T key, in T2 @param) => flux_func_param.Dispatch(key, @param);\n    }\n}"]}
{"filename": "Runtime/Core/Internal/Flux_T.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nnamespace Kingdox.UniFlux.Core.Internal\n{\n    ///<summary>\n    /// Flux Action", "    ///<summary>\n    /// Flux Action\n    ///</summary>\n    internal static class Flux<T> //(T, Action)\n    {\n        ///<summary>\n        /// Defines a static instance of ActionFlux<T>\n        ///</summary>\n        internal static readonly IFlux<T, Action> flux_action = new ActionFlux<T>();\n        ///<summary>\n        /// Defines a static method that subscribes an action to a key with a condition\n        ///</summary>\n        internal static void Store(in T key, in Action action, in bool condition) => flux_action.Store(in condition, key, action);\n        ///<summary>\n        /// Defines a static method that triggers an action with a key\n        ///</summary>\n        internal static void Dispatch(in T key) => flux_action.Dispatch(key);\n    }\n}"]}
{"filename": "Runtime/Core/Internal/FluxState.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nnamespace Kingdox.UniFlux.Core.Internal\n{\n    internal static class FluxState<T,T2>\n    {\n        internal static readonly IFluxParam<T, T2, Action<T2>> flux_action_param = new StateFlux<T,T2>();\n        internal static void Store(in T key, in  Action<T2> action, in  bool condition) => flux_action_param.Store(in condition, key, action);\n        internal static void Dispatch(in T key,in  T2 @param) => flux_action_param.Dispatch(key, @param);\n        internal static bool Get(in T key, out T2 _state)\n        {\n            //TODO TEMP", "    internal static class FluxState<T,T2>\n    {\n        internal static readonly IFluxParam<T, T2, Action<T2>> flux_action_param = new StateFlux<T,T2>();\n        internal static void Store(in T key, in  Action<T2> action, in  bool condition) => flux_action_param.Store(in condition, key, action);\n        internal static void Dispatch(in T key,in  T2 @param) => flux_action_param.Dispatch(key, @param);\n        internal static bool Get(in T key, out T2 _state)\n        {\n            //TODO TEMP\n            if((flux_action_param as StateFlux<T,T2>).dictionary.TryGetValue(key, out var state)) \n            {\n                return state.Get(out _state);\n            }\n            else\n            {\n                _state = default;\n                return false;\n            }\n        } \n    }\n}", "            if((flux_action_param as StateFlux<T,T2>).dictionary.TryGetValue(key, out var state)) \n            {\n                return state.Get(out _state);\n            }\n            else\n            {\n                _state = default;\n                return false;\n            }\n        } \n    }\n}"]}
{"filename": "Runtime/Core/Internal/FluxReturn_T_T2.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nusing System;\nnamespace Kingdox.UniFlux.Core.Internal\n{\n    ///<summary>\n    /// Flux<T> Func<out T2>", "    ///<summary>\n    /// Flux<T> Func<out T2>\n    ///</summary>\n    internal static class FluxReturn<T,T2> //  (T, Func<out T2>)\n    {\n        ///<summary>\n        /// Defines a static instance of FuncFlux<T,T2>\n        ///</summary>\n        internal static readonly IFluxReturn<T, T2, Func<T2>> flux_func = new FuncFlux<T,T2>();\n        ///<summary>\n        /// Defines a static method that subscribes a function that returns a value to a key with a condition\n        ///</summary>\n        internal static void Store(in T key, in Func<T2> action, in bool condition) => flux_func.Store(in condition, key, action);\n        ///<summary>\n        /// Defines a static method that triggers a function with a key and returns the result\n        ///</summary>\n        internal static T2 Dispatch(in T key) => flux_func.Dispatch(key);\n    }\n}"]}
{"filename": "Runtime/Core/Internal/IStore.cs", "chunked_list": ["/*\nCopyright (c) 2023 Xavier Arpa L\u00f3pez Thomas Peter ('Kingdox')\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n", "furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,", "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\nnamespace Kingdox.UniFlux.Core.Internal\n{\n    ///<summary>\n    /// Flux Storage Interface\n    ///</summary>\n    internal interface IStore<in TKey, in TStorage>\n    {\n        ///<summary>\n        /// Store TStorage with TKey\n        ///</summary>\n        void Store(in bool condition, TKey key, TStorage storage);\n    }\n}", "    /// Flux Storage Interface\n    ///</summary>\n    internal interface IStore<in TKey, in TStorage>\n    {\n        ///<summary>\n        /// Store TStorage with TKey\n        ///</summary>\n        void Store(in bool condition, TKey key, TStorage storage);\n    }\n}"]}
