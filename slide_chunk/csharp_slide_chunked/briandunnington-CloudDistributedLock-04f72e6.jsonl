{"filename": "CloudDistributedLock/ServiceCollectionExtensions.cs", "chunked_list": ["\ufeffusing Microsoft.Azure.Cosmos;\nusing Microsoft.Extensions.DependencyInjection;\n\nnamespace CloudDistributedLock\n{\n    public static class ServiceCollectionExtensions\n    {\n        public static IServiceCollection AddCloudDistributedLock(this IServiceCollection services, string cosmosEndpoint, string cosmosKey, string databaseName, int ttl, Action<CloudDistributedLockProviderOptions>? configureOptions = null)\n        {\n            var cosmosClient = new CosmosClient(cosmosEndpoint, cosmosKey);\n            return services.AddCloudDistributedLock(CloudDistributedLockProviderFactory.DefaultName, cosmosClient, databaseName, ttl, configureOptions);\n        }\n", "        public static IServiceCollection AddCloudDistributedLock(this IServiceCollection services, CosmosClient cosmosClient, string databaseName, int ttl, Action<CloudDistributedLockProviderOptions>? configureOptions = null)\n        {\n            return services.AddCloudDistributedLock(CloudDistributedLockProviderFactory.DefaultName, cosmosClient, databaseName, ttl, configureOptions);\n        }\n\n        public static IServiceCollection AddCloudDistributedLock(this IServiceCollection services, string name, string cosmosEndpoint, string cosmosKey, string databaseName, int ttl, Action<CloudDistributedLockProviderOptions>? configureOptions = null)\n        {\n            var cosmosClient = new CosmosClient(cosmosEndpoint, cosmosKey);\n            return services.AddCloudDistributedLock(name, cosmosClient, databaseName, ttl, configureOptions);\n        }\n", "        public static IServiceCollection AddCloudDistributedLock(this IServiceCollection services, string name, CosmosClient cosmosClient, string databaseName, int ttl, Action<CloudDistributedLockProviderOptions>? configureOptions = null)\n        {\n            services.AddOptions();\n            services.AddSingleton<ICloudDistributedLockProviderFactory, CloudDistributedLockProviderFactory>();\n            services.Configure<CloudDistributedLockProviderOptions>(name, o =>\n            {\n                o.ProviderName = name;\n                o.CosmosClient = cosmosClient;\n                o.DatabaseName = databaseName;\n                o.TTL = ttl;\n                configureOptions?.Invoke(o);\n            });\n            return services;\n        }\n    }\n}\n"]}
{"filename": "CloudDistributedLock/CloudDistributedLock.cs", "chunked_list": ["\ufeffusing Microsoft.Azure.Cosmos;\n\nnamespace CloudDistributedLock\n{\n    public class CloudDistributedLock : IDisposable\n    {\n        private readonly TimeSpan keepAliveBuffer = TimeSpan.FromSeconds(1); // 1 second is the smallest Cosmos TTL increment\n        private readonly CosmosLockClient? cosmosLockClient;\n        private ItemResponse<LockRecord>? currentItem;\n        private readonly string? lockId;\n        private readonly long fencingToken;\n        private Timer? timer;", "        private readonly string? lockId;\n        private readonly long fencingToken;\n        private Timer? timer;\n        private bool isDisposed;\n\n\n        public static CloudDistributedLock CreateUnacquiredLock()\n        {\n            return new CloudDistributedLock();\n        }\n", "        public static CloudDistributedLock CreateAcquiredLock(CosmosLockClient cosmosLockClient, ItemResponse<LockRecord> item)\n        {\n            return new CloudDistributedLock(cosmosLockClient, item);\n        }\n\n        private CloudDistributedLock()\n        {\n        }\n\n        private CloudDistributedLock(CosmosLockClient cosmosLockClient, ItemResponse<LockRecord> item)\n        {\n            this.cosmosLockClient = cosmosLockClient;\n            this.fencingToken = SessionTokenParser.Parse(item.Headers.Session);\n            this.lockId = $\"{item.Resource.providerName}:{item.Resource.id}:{fencingToken}:{item.Resource.lockObtainedAt.Ticks}\";\n            InitializeKeepAlive(item);\n        }\n", "        public bool IsAcquired => currentItem != null;\n\n        public string? LockId => lockId;\n\n        public long FencingToken => fencingToken;\n\n        public string? ETag => currentItem?.ETag;\n\n        async void KeepAlive(object? state)\n        {\n            if (!IsAcquired || isDisposed || cosmosLockClient == null || currentItem == null) return;\n\n            var updatedItem = await cosmosLockClient.RenewLockAsync(currentItem);", "            if (!IsAcquired || isDisposed || cosmosLockClient == null || currentItem == null) return;\n\n            var updatedItem = await cosmosLockClient.RenewLockAsync(currentItem);\n            if (updatedItem != null)\n            {\n                InitializeKeepAlive(updatedItem);\n            }\n            else\n            {\n                // someone else already acquired a new lock, which means our lock was already released\n            }\n        }\n\n        void InitializeKeepAlive(ItemResponse<LockRecord> item)\n        {\n            this.currentItem = item;\n", "            if (!IsAcquired || isDisposed || item == null) return;\n\n            var lockRecord = currentItem.Resource;\n            var lockExpiresAt = lockRecord!.lockLastRenewedAt + TimeSpan.FromSeconds(lockRecord._ttl);\n            var dueIn = lockExpiresAt - DateTimeOffset.UtcNow - keepAliveBuffer;  // renew the lock right before it expires if the reference is still held\n            if (dueIn < TimeSpan.Zero) return;\n            this.timer = new Timer(KeepAlive, null, dueIn, Timeout.InfiniteTimeSpan);\n        }\n\n        private async Task ReleaseLock()\n        {", "        private async Task ReleaseLock()\n        {\n            if (cosmosLockClient == null || currentItem == null) return;\n\n            await cosmosLockClient.ReleaseLockAsync(currentItem);\n        }\n\n        public void Dispose()\n        {\n            Dispose(disposing: true);\n            GC.SuppressFinalize(this);\n        }\n", "        protected virtual void Dispose(bool disposing)\n        {\n            if (!isDisposed)\n            {\n                // the lock in the DB is essentially an unmanaged resource\n                timer?.Dispose();\n                _ = ReleaseLock();\n\n                isDisposed = true;\n            }\n        }\n\n        ~CloudDistributedLock()\n        {\n            Dispose(disposing: false);\n        }\n    }\n}\n"]}
{"filename": "CloudDistributedLock/LockRecord.cs", "chunked_list": ["\ufeffnamespace CloudDistributedLock\n{\n    public class LockRecord\n    {\n        public string? id { get; set; }\n        public string? name { get; set; }\n        public string? providerName { get; set; }\n        public DateTimeOffset lockObtainedAt { get; set; } = DateTimeOffset.UtcNow;\n        public DateTimeOffset lockLastRenewedAt { get; set; } = DateTimeOffset.UtcNow;\n        public int _ttl { get; set; }\n    }\n}\n", "        public DateTimeOffset lockLastRenewedAt { get; set; } = DateTimeOffset.UtcNow;\n        public int _ttl { get; set; }\n    }\n}\n"]}
{"filename": "CloudDistributedLock/CosmosLockClient.cs", "chunked_list": ["\ufeffusing Microsoft.Azure.Cosmos;\nusing System.Net;\n\nnamespace CloudDistributedLock\n{\n    public class CosmosLockClient\n    {\n        private readonly CloudDistributedLockProviderOptions options;\n        private readonly Container container;\n\n        public CosmosLockClient(CloudDistributedLockProviderOptions options)\n        {\n            this.options = options;\n            this.container = options.CosmosClient!.GetContainer(options.DatabaseName, options.ContainerName);\n        }\n", "        private readonly Container container;\n\n        public CosmosLockClient(CloudDistributedLockProviderOptions options)\n        {\n            this.options = options;\n            this.container = options.CosmosClient!.GetContainer(options.DatabaseName, options.ContainerName);\n        }\n\n        public async Task<ItemResponse<LockRecord>?> TryAquireLockAsync(string name)\n        {\n            try\n            {\n                /* This will successfully insert the document if no other process is currently holding a lock.\n                 * The collection is set with a TTL so that the record will be deleted automatically, \n                 * releasing the lock in the event that it is not released by the holder.\n                 * */\n                var safeLockName = GenerateSafeLockName(name);\n                var now = DateTimeOffset.UtcNow;\n                var lockRecord = new LockRecord { id = safeLockName, name = name, providerName = options.ProviderName, lockObtainedAt = now, lockLastRenewedAt = now, _ttl = options.TTL };\n                return await container.CreateItemAsync(lockRecord, new PartitionKey(lockRecord.id));\n            }", "        public async Task<ItemResponse<LockRecord>?> TryAquireLockAsync(string name)\n        {\n            try\n            {\n                /* This will successfully insert the document if no other process is currently holding a lock.\n                 * The collection is set with a TTL so that the record will be deleted automatically, \n                 * releasing the lock in the event that it is not released by the holder.\n                 * */\n                var safeLockName = GenerateSafeLockName(name);\n                var now = DateTimeOffset.UtcNow;\n                var lockRecord = new LockRecord { id = safeLockName, name = name, providerName = options.ProviderName, lockObtainedAt = now, lockLastRenewedAt = now, _ttl = options.TTL };\n                return await container.CreateItemAsync(lockRecord, new PartitionKey(lockRecord.id));\n            }", "            catch (CosmosException ex)\n            {\n                if (ex.StatusCode == HttpStatusCode.Conflict)\n                {\n                    // lock already held by someone else\n                    return null;\n                }\n                throw;\n            }\n        }\n", "        public async Task<ItemResponse<LockRecord>?> RenewLockAsync(ItemResponse<LockRecord> item)\n        {\n            try\n            {\n                var lockRecord = item.Resource;\n                lockRecord.lockLastRenewedAt = DateTimeOffset.UtcNow;\n                return await container.UpsertItemAsync(lockRecord, new PartitionKey(lockRecord.id), new ItemRequestOptions { IfMatchEtag = item.ETag });\n            }\n            catch (CosmosException ex)\n            {\n                if (ex.StatusCode == HttpStatusCode.PreconditionFailed)\n                {\n                    // someone else already acquired a new lock, which means our lock was already released\n                    return null;\n                }\n                throw;\n            }\n        }\n", "            catch (CosmosException ex)\n            {\n                if (ex.StatusCode == HttpStatusCode.PreconditionFailed)\n                {\n                    // someone else already acquired a new lock, which means our lock was already released\n                    return null;\n                }\n                throw;\n            }\n        }\n", "        public async Task ReleaseLockAsync(ItemResponse<LockRecord> item)\n        {\n            try\n            {\n                var lockRecord = item.Resource;\n                _ = await container.DeleteItemAsync<LockRecord>(lockRecord.id, new PartitionKey(lockRecord.id), new ItemRequestOptions { IfMatchEtag = item.ETag });\n            }\n            catch (CosmosException ex)\n            {\n                if (ex.StatusCode == HttpStatusCode.PreconditionFailed)\n                {\n                    // someone else already acquired a new lock, which means our lock was already released\n                }\n            }\n        }\n\n", "                if (ex.StatusCode == HttpStatusCode.PreconditionFailed)\n                {\n                    // someone else already acquired a new lock, which means our lock was already released\n                }\n            }\n        }\n\n\n        private static string GenerateSafeLockName(string lockName)\n        {\n            //'/', '\\\\', '?', '#' are invalid \n            return lockName.Replace('/', '_').Replace('\\\\', '_').Replace('?', '_').Replace('#', '_');\n        }\n    }\n}\n", "        private static string GenerateSafeLockName(string lockName)\n        {\n            //'/', '\\\\', '?', '#' are invalid \n            return lockName.Replace('/', '_').Replace('\\\\', '_').Replace('?', '_').Replace('#', '_');\n        }\n    }\n}\n"]}
{"filename": "CloudDistributedLock/CloudDistributedLockProviderOptions.cs", "chunked_list": ["\ufeffusing Microsoft.Azure.Cosmos;\n\nnamespace CloudDistributedLock\n{\n    public class CloudDistributedLockProviderOptions\n    {\n        internal string? ProviderName { get; set; }\n\n        internal CosmosClient? CosmosClient { get; set; }\n\n        public int TTL { get; set; } = 5;   // Should match the value set in Cosmos\n\n        public string? DatabaseName { get; set; }\n", "        public int TTL { get; set; } = 5;   // Should match the value set in Cosmos\n\n        public string? DatabaseName { get; set; }\n\n        public string ContainerName { get; set; } = \"distributedlocks\";\n\n        public TimeSpan RetryInterval { get; set; } = TimeSpan.FromMilliseconds(500);\n    }\n}\n"]}
{"filename": "CloudDistributedLock/CloudDistributedLockProvider.cs", "chunked_list": ["\ufeffnamespace CloudDistributedLock\n{\n    public interface ICloudDistributedLockProvider\n    {\n        Task<CloudDistributedLock> TryAquireLockAsync(string name);\n\n        Task<CloudDistributedLock> AcquireLockAsync(string name, TimeSpan? timeout = default);\n    }\n\n    public class CloudDistributedLockProvider : ICloudDistributedLockProvider\n    {", "    public class CloudDistributedLockProvider : ICloudDistributedLockProvider\n    {\n        private readonly CloudDistributedLockProviderOptions options;\n        private readonly CosmosLockClient cosmosLockClient;\n\n        public CloudDistributedLockProvider(CloudDistributedLockProviderOptions options)\n        {\n            this.options = options;\n            this.cosmosLockClient = new CosmosLockClient(options);\n        }\n", "        public async Task<CloudDistributedLock> AcquireLockAsync(string name, TimeSpan? timeout = null)\n        {\n            using var cancellationTokenSource = timeout.HasValue ? new CancellationTokenSource(timeout.Value) : new CancellationTokenSource();\n            return await ContinuallyTryAquireLockAsync(name, cancellationTokenSource.Token);\n        }\n\n        public async Task<CloudDistributedLock> TryAquireLockAsync(string name)\n        {\n            var item = await cosmosLockClient.TryAquireLockAsync(name);\n            if (item != null)\n            {\n                return CloudDistributedLock.CreateAcquiredLock(cosmosLockClient, item);\n            }\n            else\n            {\n                return CloudDistributedLock.CreateUnacquiredLock();\n            }\n        }\n", "            if (item != null)\n            {\n                return CloudDistributedLock.CreateAcquiredLock(cosmosLockClient, item);\n            }\n            else\n            {\n                return CloudDistributedLock.CreateUnacquiredLock();\n            }\n        }\n\n        private async Task<CloudDistributedLock> ContinuallyTryAquireLockAsync(string name, CancellationToken cancellationToken)\n        {\n            CloudDistributedLock? @lock;\n            do\n            {\n                @lock = await TryAquireLockAsync(name);", "        private async Task<CloudDistributedLock> ContinuallyTryAquireLockAsync(string name, CancellationToken cancellationToken)\n        {\n            CloudDistributedLock? @lock;\n            do\n            {\n                @lock = await TryAquireLockAsync(name);\n                if (!@lock.IsAcquired && !cancellationToken.IsCancellationRequested)\n                {\n                    await Task.Delay(options.RetryInterval);\n                }\n            }", "            while (!@lock.IsAcquired && !cancellationToken.IsCancellationRequested);\n            return @lock;\n        }\n    }\n}"]}
{"filename": "CloudDistributedLock/CloudDistributedLockProviderFactory.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.Options;\nusing System.Collections.Concurrent;\n\nnamespace CloudDistributedLock\n{\n    public interface ICloudDistributedLockProviderFactory\n    {\n        ICloudDistributedLockProvider GetLockProvider();\n        ICloudDistributedLockProvider GetLockProvider(string name);\n    }\n", "    public class CloudDistributedLockProviderFactory : ICloudDistributedLockProviderFactory\n    {\n        internal const string DefaultName = \"__DEFAULT\";\n\n        private readonly ConcurrentDictionary<string, ICloudDistributedLockProvider> clients = new();\n\n\n        public CloudDistributedLockProviderFactory(IOptionsMonitor<CloudDistributedLockProviderOptions> optionsMonitor)\n        {\n            this.OptionsMonitor = optionsMonitor;\n        }\n\n        protected IOptionsMonitor<CloudDistributedLockProviderOptions> OptionsMonitor { get; }\n", "        public ICloudDistributedLockProvider GetLockProvider(string name)\n        {\n            return clients.GetOrAdd(name, n => CreateClient(n));\n        }\n\n        public ICloudDistributedLockProvider GetLockProvider()\n        {\n            return GetLockProvider(DefaultName);\n        }\n\n        protected ICloudDistributedLockProvider CreateClient(string name)\n        {\n            var options = OptionsMonitor.Get(name);\n\n            ArgumentNullException.ThrowIfNull(options.ProviderName);\n            ArgumentNullException.ThrowIfNull(options.CosmosClient);\n            ArgumentNullException.ThrowIfNull(options.DatabaseName);\n            ArgumentNullException.ThrowIfNull(options.ContainerName);\n\n            return new CloudDistributedLockProvider(options);\n        }\n    }\n}\n", "        protected ICloudDistributedLockProvider CreateClient(string name)\n        {\n            var options = OptionsMonitor.Get(name);\n\n            ArgumentNullException.ThrowIfNull(options.ProviderName);\n            ArgumentNullException.ThrowIfNull(options.CosmosClient);\n            ArgumentNullException.ThrowIfNull(options.DatabaseName);\n            ArgumentNullException.ThrowIfNull(options.ContainerName);\n\n            return new CloudDistributedLockProvider(options);\n        }\n    }\n}\n"]}
{"filename": "CloudDistributedLock/SessionTokenParser.cs", "chunked_list": ["\ufeffnamespace CloudDistributedLock\n{\n    internal class SessionTokenParser\n    {\n        private static readonly char[] segmentSeparator = (new[] { '#' });\n        private static readonly char[] pkRangeSeparator = (new[] { ':' });\n\n        public static long Parse(string sessionToken)\n        {\n            // Simple session token: {pkrangeid}:{globalLSN}\n            // Vector session token: {pkrangeid}:{Version}#{GlobalLSN}#{RegionId1}={LocalLsn1}#{RegionId2}={LocalLsn2}....#{RegionIdN}={LocalLsnN}\n\n            var items = sessionToken.Split(pkRangeSeparator, StringSplitOptions.RemoveEmptyEntries);\n            var sessionTokenSegments = items[1].Split(segmentSeparator, StringSplitOptions.RemoveEmptyEntries);\n            var globalLsnSegmentIndex = sessionTokenSegments.Length == 1 ? 0 : 1;\n            return long.Parse(sessionTokenSegments[globalLsnSegmentIndex]);\n        }\n    }\n}\n"]}
{"filename": "ExampleApp/Functions.cs", "chunked_list": ["using CloudDistributedLock;\nusing Microsoft.Azure.Functions.Worker;\nusing Microsoft.Azure.Functions.Worker.Http;\nusing System.Net;\n\nnamespace ExampleApp\n{\n    public class Functions\n    {\n        public const string LockName = \"MyLock\";\n        public const string OtherLockName = \"OtherLockName\";\n", "        public const string LockName = \"MyLock\";\n        public const string OtherLockName = \"OtherLockName\";\n\n        private readonly ICloudDistributedLockProviderFactory lockProviderFactory;\n\n        public Functions(ICloudDistributedLockProviderFactory lockProviderFactory)\n        {\n            this.lockProviderFactory = lockProviderFactory;\n        }\n\n        [Function(\"TryLock\")]", "        public async Task<HttpResponseData> TryLock([HttpTrigger(AuthorizationLevel.Anonymous, \"get\")] HttpRequestData req)\n        {\n            var response = req.CreateResponse();\n            var lockProvider = lockProviderFactory.GetLockProvider();\n            using var @lock = await lockProvider.TryAquireLockAsync(LockName);\n            if (@lock.IsAcquired)\n            {\n                response.StatusCode = HttpStatusCode.OK;\n                await response.WriteAsJsonAsync(new\n                {\n                    message = \"TryLock obtained the lock\",\n                    lockId = @lock.LockId,\n                    etag = @lock.ETag,\n                    fencingToken = @lock.FencingToken\n                });\n\n                // hold the lock for 10 seconds to demonstrate\n                await Task.Delay(TimeSpan.FromSeconds(10));\n            }\n            else\n            {\n                response.StatusCode = HttpStatusCode.Conflict;\n                response.WriteString(\"TryLock failed to obtain the lock immediately\");\n            }\n            return response;\n        }\n\n        [Function(\"OtherLock\")]", "        public async Task<HttpResponseData> OtherLock([HttpTrigger(AuthorizationLevel.Anonymous, \"get\")] HttpRequestData req)\n        {\n            var response = req.CreateResponse();\n            var lockProvider = lockProviderFactory.GetLockProvider();\n            using var @lock = await lockProvider.TryAquireLockAsync(OtherLockName);\n            if (@lock.IsAcquired)\n            {\n                response.StatusCode = HttpStatusCode.OK;\n                await response.WriteAsJsonAsync(new\n                {\n                    message = \"OtherLock obtained the lock\",\n                    lockId = @lock.LockId,\n                    etag = @lock.ETag,\n                    fencingToken = @lock.FencingToken\n                });\n            }\n            else\n            {\n                response.StatusCode = HttpStatusCode.Conflict;\n                response.WriteString(\"OtherLock failed to obtain the lock immediately\");\n            }\n            return response;\n        }\n\n        [Function(\"WaitLock\")]", "        public async Task<HttpResponseData> WaitLock([HttpTrigger(AuthorizationLevel.Anonymous, \"get\")] HttpRequestData req)\n        {\n            var response = req.CreateResponse(HttpStatusCode.OK);\n            var lockProvider = lockProviderFactory.GetLockProvider();\n            using var @lock = await lockProvider.AcquireLockAsync(LockName);\n            if (@lock.IsAcquired)\n            {\n                response.StatusCode = HttpStatusCode.OK;\n                await response.WriteAsJsonAsync(new\n                {\n                    message = \"WaitLock obtained the lock\",\n                    lockId = @lock.LockId,\n                    etag = @lock.ETag,\n                    fencingToken = @lock.FencingToken\n                });\n            }\n            else\n            {\n                // since no timeout was specified in the AcquireAsync(), this should not get hit\n                response.StatusCode = HttpStatusCode.Conflict;\n                response.WriteString(\"WaitLock failed to obtain the lock - should not happen\");\n            }\n            return response;\n        }\n\n        [Function(\"WaitTimeoutLock\")]", "        public async Task<HttpResponseData> WaitTimeoutLock([HttpTrigger(AuthorizationLevel.Anonymous, \"get\")] HttpRequestData req)\n        {\n            var response = req.CreateResponse(HttpStatusCode.OK);\n            var lockProvider = lockProviderFactory.GetLockProvider();\n            using var @lock = await lockProvider.AcquireLockAsync(LockName, TimeSpan.FromSeconds(2));\n            if (@lock.IsAcquired)\n            {\n                response.StatusCode = HttpStatusCode.OK;\n                await response.WriteAsJsonAsync(new\n                {\n                    message = \"WaitTimeoutLock obtained the lock\",\n                    lockId = @lock.LockId,\n                    etag = @lock.ETag,\n                    fencingToken = @lock.FencingToken\n                });\n            }\n            else\n            {\n                // this will get hit if the lock can not be acquired in 2 seconds\n                response.StatusCode = HttpStatusCode.Conflict;\n                response.WriteString(\"WaitTimeoutLock failed to obtain a lock within 2 seconds\");\n            }\n            return response;\n        }\n    }\n}\n"]}
{"filename": "ExampleApp/Program.cs", "chunked_list": ["using CloudDistributedLock;\nusing Microsoft.Extensions.Hosting;\n\nvar host = new HostBuilder()\n    .ConfigureFunctionsWorkerDefaults()\n    .ConfigureServices((hbc, services) =>\n    {\n        var config = hbc.Configuration;\n        services.AddCloudDistributedLock(config[\"CosmosEndpoint\"], config[\"CosmosKey\"], config[\"DatabaseName\"], 5);\n    })", "        services.AddCloudDistributedLock(config[\"CosmosEndpoint\"], config[\"CosmosKey\"], config[\"DatabaseName\"], 5);\n    })\n    .Build();\n\nhost.Run();\n"]}
