{"filename": "Assets/Mochineko/RelentStateMachine/IStackState.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Result;\n\nnamespace Mochineko.RelentStateMachine\n{\n    public interface IStackState<in TContext> : IDisposable\n    {\n        UniTask EnterAsync(TContext context, CancellationToken cancellationToken);\n        UniTask UpdateAsync(TContext context, CancellationToken cancellationToken);\n        UniTask ExitAsync(TContext context, CancellationToken cancellationToken);\n    }\n}", "    public interface IStackState<in TContext> : IDisposable\n    {\n        UniTask EnterAsync(TContext context, CancellationToken cancellationToken);\n        UniTask UpdateAsync(TContext context, CancellationToken cancellationToken);\n        UniTask ExitAsync(TContext context, CancellationToken cancellationToken);\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/IFiniteStateMachine.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Result;\n\nnamespace Mochineko.RelentStateMachine\n{\n    public interface IFiniteStateMachine<TEvent, out TContext> : IDisposable\n    {\n        TContext Context { get; }\n        bool IsCurrentState<TState>() where TState : IState<TEvent, TContext>;\n        UniTask<IResult> SendEventAsync(TEvent @event, CancellationToken cancellationToken);\n        UniTask UpdateAsync(CancellationToken cancellationToken);\n    }\n}", "    public interface IFiniteStateMachine<TEvent, out TContext> : IDisposable\n    {\n        TContext Context { get; }\n        bool IsCurrentState<TState>() where TState : IState<TEvent, TContext>;\n        UniTask<IResult> SendEventAsync(TEvent @event, CancellationToken cancellationToken);\n        UniTask UpdateAsync(CancellationToken cancellationToken);\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/IStackStateMachine.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Result;\n\nnamespace Mochineko.RelentStateMachine\n{\n    public interface IStackStateMachine<out TContext> : IDisposable\n    {\n        TContext Context { get; }\n        bool IsCurrentState<TState>() where TState : IStackState<TContext>;\n\n        UniTask<IResult<IPopToken>> PushAsync<TState>(CancellationToken cancellationToken)\n            where TState : IStackState<TContext>;\n\n        UniTask UpdateAsync(CancellationToken cancellationToken);\n    }\n}", "    public interface IStackStateMachine<out TContext> : IDisposable\n    {\n        TContext Context { get; }\n        bool IsCurrentState<TState>() where TState : IStackState<TContext>;\n\n        UniTask<IResult<IPopToken>> PushAsync<TState>(CancellationToken cancellationToken)\n            where TState : IStackState<TContext>;\n\n        UniTask UpdateAsync(CancellationToken cancellationToken);\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/TransitionMapBuilder.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\n\nnamespace Mochineko.RelentStateMachine\n{\n    public sealed class TransitionMapBuilder<TEvent, TContext>\n        : ITransitionMapBuilder<TEvent, TContext>\n    {\n        private readonly IState<TEvent, TContext> initialState;\n        private readonly List<IState<TEvent, TContext>> states = new();\n", "        private readonly IState<TEvent, TContext> initialState;\n        private readonly List<IState<TEvent, TContext>> states = new();\n\n        private readonly Dictionary<IState<TEvent, TContext>, Dictionary<TEvent, IState<TEvent, TContext>>>\n            transitionMap = new();\n\n        private readonly Dictionary<TEvent, IState<TEvent, TContext>>\n            anyTransitionMap = new();\n\n        private bool disposed = false;\n", "        private bool disposed = false;\n\n        public static TransitionMapBuilder<TEvent, TContext> Create<TInitialState>()\n            where TInitialState : IState<TEvent, TContext>, new()\n        {\n            var initialState = new TInitialState();\n            return new TransitionMapBuilder<TEvent, TContext>(initialState);\n        }\n\n        private TransitionMapBuilder(IState<TEvent, TContext> initialState)\n        {\n            this.initialState = initialState;\n            states.Add(this.initialState);\n        }\n", "        public void Dispose()\n        {\n            if (disposed)\n            {\n                throw new ObjectDisposedException(nameof(TransitionMapBuilder<TEvent, TContext>));\n            }\n\n            disposed = true;\n        }\n\n        public void RegisterTransition<TFromState, TToState>(TEvent @event)\n            where TFromState : IState<TEvent, TContext>, new()\n            where TToState : IState<TEvent, TContext>, new()\n        {", "        public void RegisterTransition<TFromState, TToState>(TEvent @event)\n            where TFromState : IState<TEvent, TContext>, new()\n            where TToState : IState<TEvent, TContext>, new()\n        {\n            if (disposed)\n            {\n                throw new ObjectDisposedException(nameof(TransitionMapBuilder<TEvent, TContext>));\n            }\n\n            var fromState = GetOrCreateState<TFromState>();\n            var toState = GetOrCreateState<TToState>();\n", "            if (transitionMap.TryGetValue(fromState, out var transitions))\n            {\n                if (transitions.TryGetValue(@event, out var nextState))\n                {\n                    throw new InvalidOperationException(\n                        $\"Already exists transition from {fromState.GetType()} to {nextState.GetType()} with event {@event}.\");\n                }\n                else\n                {\n                    transitions.Add(@event, toState);\n                }\n            }\n            else\n            {\n                var newTransitions = new Dictionary<TEvent, IState<TEvent, TContext>>();\n                newTransitions.Add(@event, toState);\n                transitionMap.Add(fromState, newTransitions);\n            }\n        }\n", "        public void RegisterAnyTransition<TToState>(TEvent @event)\n            where TToState : IState<TEvent, TContext>, new()\n        {\n            if (disposed)\n            {\n                throw new ObjectDisposedException(nameof(TransitionMapBuilder<TEvent, TContext>));\n            }\n\n            var toState = GetOrCreateState<TToState>();\n\n            if (anyTransitionMap.TryGetValue(@event, out var nextState))\n            {\n                throw new InvalidOperationException(\n                    $\"Already exists transition from any state to {nextState.GetType()} with event {@event}.\");\n            }\n            else\n            {\n                anyTransitionMap.Add(@event, toState);\n            }\n        }\n\n        public ITransitionMap<TEvent, TContext> Build()\n        {", "            if (anyTransitionMap.TryGetValue(@event, out var nextState))\n            {\n                throw new InvalidOperationException(\n                    $\"Already exists transition from any state to {nextState.GetType()} with event {@event}.\");\n            }\n            else\n            {\n                anyTransitionMap.Add(@event, toState);\n            }\n        }\n\n        public ITransitionMap<TEvent, TContext> Build()\n        {", "            if (disposed)\n            {\n                throw new ObjectDisposedException(nameof(TransitionMapBuilder<TEvent, TContext>));\n            }\n\n            var result = new TransitionMap<TEvent, TContext>(\n                initialState,\n                states,\n                BuildReadonlyTransitionMap(),\n                anyTransitionMap);\n\n            // Cannot reuse builder after build.\n            this.Dispose();\n\n            return result;\n        }\n\n        private IReadOnlyDictionary<\n                IState<TEvent, TContext>,\n                IReadOnlyDictionary<TEvent, IState<TEvent, TContext>>>\n            BuildReadonlyTransitionMap()\n        {\n            var result = new Dictionary<\n                IState<TEvent, TContext>,\n                IReadOnlyDictionary<TEvent, IState<TEvent, TContext>>>();", "            foreach (var (key, value) in transitionMap)\n            {\n                result.Add(key, value);\n            }\n\n            return result;\n        }\n\n        private TState GetOrCreateState<TState>()\n            where TState : IState<TEvent, TContext>, new()\n        {", "        private TState GetOrCreateState<TState>()\n            where TState : IState<TEvent, TContext>, new()\n        {\n            foreach (var state in states)\n            {\n                if (state is TState target)\n                {\n                    return target;\n                }\n            }\n\n            var newState = new TState();\n            states.Add(newState);\n            return newState;\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/SomeEventRequest.cs", "chunked_list": ["#nullable enable\nnamespace Mochineko.RelentStateMachine\n{\n    internal sealed class SomeEventRequest<TEvent> : IEventRequest<TEvent>\n    {\n        public bool Request => true;\n        public TEvent Event { get; }\n\n        public SomeEventRequest(TEvent @event)\n        {\n            Event = @event;\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/StateResults.cs", "chunked_list": ["#nullable enable\nusing Mochineko.Relent.Result;\n\nnamespace Mochineko.RelentStateMachine\n{\n    internal static class StateResults\n    {\n        public static ISuccessResult<IEventRequest<TEvent>> Succeed<TEvent>()\n            => Results.Succeed(EventRequests<TEvent>.None());\n     \n        public static ISuccessResult<IEventRequest<TEvent>> SucceedAndRequest<TEvent>(TEvent @event)\n            => Results.Succeed(EventRequests<TEvent>.Request(@event));\n        ", "        public static ISuccessResult<IEventRequest<TEvent>> SucceedAndRequest<TEvent>(TEvent @event)\n            => Results.Succeed(EventRequests<TEvent>.Request(@event));\n        \n        public static IFailureResult<IEventRequest<TEvent>> Fail<TEvent>(string message)\n            => Results.FailWithTrace<IEventRequest<TEvent>>(message);\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/StateStoreBuilder.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\n\nnamespace Mochineko.RelentStateMachine\n{\n    public sealed class StateStoreBuilder<TContext>\n        : IStateStoreBuilder<TContext>\n    {\n        private readonly IStackState<TContext> initialState;\n        private readonly List<IStackState<TContext>> states = new();\n", "        private readonly IStackState<TContext> initialState;\n        private readonly List<IStackState<TContext>> states = new();\n\n        private bool disposed = false;\n\n        public static StateStoreBuilder<TContext> Create<TInitialState>()\n            where TInitialState : IStackState<TContext>, new()\n        {\n            var initialState = new TInitialState();\n            return new StateStoreBuilder<TContext>(initialState);\n        }\n\n        private StateStoreBuilder(IStackState<TContext> initialState)\n        {\n            this.initialState = initialState;\n            states.Add(this.initialState);\n        }\n", "        public void Dispose()\n        {\n            if (disposed)\n            {\n                throw new ObjectDisposedException(nameof(StateStoreBuilder<TContext>));\n            }\n\n            disposed = true;\n        }\n\n        public void Register<TState>()\n            where TState : IStackState<TContext>, new()\n        {", "        public void Register<TState>()\n            where TState : IStackState<TContext>, new()\n        {\n            if (disposed)\n            {\n                throw new ObjectDisposedException(nameof(StateStoreBuilder<TContext>));\n            }\n\n            foreach (var state in states)\n            {\n                if (state is TState)\n                {\n                    throw new InvalidOperationException($\"Already registered state: {typeof(TState)}\");\n                }\n            }\n\n            states.Add(new TState());\n        }\n\n        public IStateStore<TContext> Build()\n        {", "            foreach (var state in states)\n            {\n                if (state is TState)\n                {\n                    throw new InvalidOperationException($\"Already registered state: {typeof(TState)}\");\n                }\n            }\n\n            states.Add(new TState());\n        }\n\n        public IStateStore<TContext> Build()\n        {", "            if (disposed)\n            {\n                throw new ObjectDisposedException(nameof(StateStoreBuilder<TContext>));\n            }\n\n            var result = new StateStore<TContext>(\n                initialState,\n                states);\n\n            // Cannot reuse builder after build.\n            this.Dispose();\n\n            return result;\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/IEventRequest.cs", "chunked_list": ["#nullable enable\nnamespace Mochineko.RelentStateMachine\n{\n    public interface IEventRequest<TEvent>\n    {\n        bool Request { get; }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/EventRequests.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\n\nnamespace Mochineko.RelentStateMachine\n{\n    public static class EventRequests<TEvent>\n    {\n        public static IEventRequest<TEvent> Request(TEvent @event)\n        {\n            if (requestsCache.TryGetValue(@event, out var request))\n            {\n                return request;\n            }\n            else\n            {\n                var newInstance = new SomeEventRequest<TEvent>(@event);\n                requestsCache.Add(@event, newInstance);\n                return newInstance;\n            }\n        }\n", "            if (requestsCache.TryGetValue(@event, out var request))\n            {\n                return request;\n            }\n            else\n            {\n                var newInstance = new SomeEventRequest<TEvent>(@event);\n                requestsCache.Add(@event, newInstance);\n                return newInstance;\n            }\n        }\n", "        public static IEventRequest<TEvent> None()\n            => NoEventRequest<TEvent>.Instance;\n\n        private static readonly Dictionary<TEvent, SomeEventRequest<TEvent>> requestsCache = new();\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/ITransitionMapBuilder.cs", "chunked_list": ["#nullable enable\nusing System;\n\nnamespace Mochineko.RelentStateMachine\n{\n    public interface ITransitionMapBuilder<TEvent, TContext> : IDisposable\n    {\n        void RegisterTransition<TFromState, TToState>(TEvent @event)\n            where TFromState : IState<TEvent, TContext>, new()\n            where TToState : IState<TEvent, TContext>, new();\n\n        void RegisterAnyTransition<TToState>(TEvent @event)\n            where TToState : IState<TEvent, TContext>, new();\n\n        ITransitionMap<TEvent, TContext> Build();\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/NoEventRequest.cs", "chunked_list": ["#nullable enable\nnamespace Mochineko.RelentStateMachine\n{\n    internal sealed class NoEventRequest<TEvent> : IEventRequest<TEvent>\n    {\n        public bool Request => false;\n        \n        public static NoEventRequest<TEvent> Instance { get; } = new();\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/IStateStore.cs", "chunked_list": ["#nullable enable\nusing System;\n\nnamespace Mochineko.RelentStateMachine\n{\n    public interface IStateStore<TContext> : IDisposable\n    {\n        internal IStackState<TContext> InitialState { get; }\n        internal IStackState<TContext> Get<TState>() where TState : IStackState<TContext>;\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/StateStore.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\n\nnamespace Mochineko.RelentStateMachine\n{\n    public sealed class StateStore<TContext> : IStateStore<TContext>\n    {\n        private readonly IStackState<TContext> initialState;\n        private readonly IReadOnlyList<IStackState<TContext>> states;\n\n        public StateStore(\n            IStackState<TContext> initialState,\n            IReadOnlyList<IStackState<TContext>> states)\n        {\n            this.initialState = initialState;\n            this.states = states;\n        }\n\n        IStackState<TContext> IStateStore<TContext>.InitialState\n            => initialState;\n\n        IStackState<TContext> IStateStore<TContext>.Get<TState>()\n        {", "        private readonly IStackState<TContext> initialState;\n        private readonly IReadOnlyList<IStackState<TContext>> states;\n\n        public StateStore(\n            IStackState<TContext> initialState,\n            IReadOnlyList<IStackState<TContext>> states)\n        {\n            this.initialState = initialState;\n            this.states = states;\n        }\n\n        IStackState<TContext> IStateStore<TContext>.InitialState\n            => initialState;\n\n        IStackState<TContext> IStateStore<TContext>.Get<TState>()\n        {", "            foreach (var state in states)\n            {\n                if (state is TState target)\n                {\n                    return target;\n                }\n            }\n\n            throw new ArgumentException($\"Not found state: {typeof(TState)}\");\n        }\n", "        public void Dispose()\n        {\n            foreach (var state in states)\n            {\n                state.Dispose();\n            }\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/IStateStoreBuilder.cs", "chunked_list": ["#nullable enable\nusing System;\n\nnamespace Mochineko.RelentStateMachine\n{\n    public interface IStateStoreBuilder<TContext> : IDisposable\n    {\n        void Register<TState>()\n            where TState : IStackState<TContext>, new();\n\n        IStateStore<TContext> Build();\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/ITransitionMap.cs", "chunked_list": ["#nullable enable\nusing System;\nusing Mochineko.Relent.Result;\n\nnamespace Mochineko.RelentStateMachine\n{\n    public interface ITransitionMap<TEvent, TContext> : IDisposable\n    {\n        internal IState<TEvent, TContext> InitialState { get; }\n        internal IResult<IState<TEvent, TContext>> AllowedToTransit(IState<TEvent, TContext> currentState, TEvent @event);\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/IState.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\nnamespace Mochineko.RelentStateMachine\n{\n    public interface IState<TEvent, in TContext> : IDisposable\n    {\n        UniTask<IEventRequest<TEvent>> EnterAsync(TContext context, CancellationToken cancellationToken);\n        UniTask<IEventRequest<TEvent>> UpdateAsync(TContext context, CancellationToken cancellationToken);\n        UniTask ExitAsync(TContext context, CancellationToken cancellationToken);\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/StackStateMachine.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Result;\n\nnamespace Mochineko.RelentStateMachine\n{\n    public sealed class StackStateMachine<TContext>\n        : IStackStateMachine<TContext>\n    {", "{\n    public sealed class StackStateMachine<TContext>\n        : IStackStateMachine<TContext>\n    {\n        private readonly IStateStore<TContext> stateStore;\n        public TContext Context { get; }\n        private readonly Stack<IStackState<TContext>> stack = new();\n\n        public bool IsCurrentState<TState>()\n            where TState : IStackState<TContext>\n            => stack.Peek() is TState;\n", "        public bool IsCurrentState<TState>()\n            where TState : IStackState<TContext>\n            => stack.Peek() is TState;\n\n        private readonly SemaphoreSlim semaphore = new(\n            initialCount: 1,\n            maxCount: 1);\n\n        private readonly TimeSpan semaphoreTimeout;\n        private const float DefaultSemaphoreTimeoutSeconds = 30f;\n", "        private readonly TimeSpan semaphoreTimeout;\n        private const float DefaultSemaphoreTimeoutSeconds = 30f;\n\n        public static async UniTask<StackStateMachine<TContext>> CreateAsync(\n            IStateStore<TContext> stateStore,\n            TContext context,\n            CancellationToken cancellationToken,\n            TimeSpan? semaphoreTimeout = null)\n        {\n            var instance = new StackStateMachine<TContext>(\n                stateStore,\n                context,\n                semaphoreTimeout);\n\n            await instance.stack.Peek()\n                .EnterAsync(context, cancellationToken);\n\n            return instance;\n        }\n\n        private StackStateMachine(\n            IStateStore<TContext> stateStore,\n            TContext context,\n            TimeSpan? semaphoreTimeout = null)\n        {\n            this.stateStore = stateStore;\n            this.Context = context;\n            this.stack.Push(this.stateStore.InitialState);\n\n            this.semaphoreTimeout =\n                semaphoreTimeout\n                ?? TimeSpan.FromSeconds(DefaultSemaphoreTimeoutSeconds);\n        }\n", "        public void Dispose()\n        {\n            semaphore.Dispose();\n            stack.Clear();\n            stateStore.Dispose();\n        }\n\n        public async UniTask<IResult<IPopToken>> PushAsync<TState>(\n            CancellationToken cancellationToken)\n            where TState : IStackState<TContext>\n        {\n            // Make stack thread-safe.\n            try\n            {\n                await semaphore.WaitAsync(semaphoreTimeout, cancellationToken);\n            }", "            catch (OperationCanceledException exception)\n            {\n                semaphore.Release();\n                return Results.Fail<IPopToken>(\n                    $\"Cancelled to wait semaphore because of {exception}.\");\n            }\n\n            var nextState = stateStore.Get<TState>();\n            try\n            {\n                await nextState.EnterAsync(Context, cancellationToken);\n\n                stack.Push(nextState);\n                return Results.Succeed(PopToken.Publish(this));\n            }\n            finally\n            {\n                semaphore.Release();\n            }\n        }\n", "        public async UniTask UpdateAsync(CancellationToken cancellationToken)\n        {\n            var currentState = stack.Peek();\n            await currentState.UpdateAsync(Context, cancellationToken);\n        }\n\n        private sealed class PopToken : IPopToken\n        {\n            private readonly StackStateMachine<TContext> publisher;\n            private bool popped = false;\n", "            private readonly StackStateMachine<TContext> publisher;\n            private bool popped = false;\n\n            public static IPopToken Publish(StackStateMachine<TContext> publisher)\n                => new PopToken(publisher);\n\n            private PopToken(StackStateMachine<TContext> publisher)\n            {\n                this.publisher = publisher;\n            }\n", "            public async UniTask<IResult> PopAsync(CancellationToken cancellationToken)\n            {\n                if (popped)\n                {\n                    throw new InvalidOperationException(\n                        $\"Failed to pop because of already popped.\");\n                }\n\n                if (publisher.stack.Count is 0)\n                {\n                    throw new InvalidOperationException(\n                        $\"Failed to pop because of stack is empty.\");\n                }\n\n                // Make stack thread-safe.\n                try\n                {\n                    await publisher.semaphore\n                        .WaitAsync(publisher.semaphoreTimeout, cancellationToken);\n                }", "                if (publisher.stack.Count is 0)\n                {\n                    throw new InvalidOperationException(\n                        $\"Failed to pop because of stack is empty.\");\n                }\n\n                // Make stack thread-safe.\n                try\n                {\n                    await publisher.semaphore\n                        .WaitAsync(publisher.semaphoreTimeout, cancellationToken);\n                }", "                catch (OperationCanceledException exception)\n                {\n                    publisher.semaphore.Release();\n                    return Results.Fail(\n                        $\"Cancelled to wait semaphore because of {exception}.\");\n                }\n\n                popped = true;\n\n                var currentState = publisher.stack.Peek();\n                try\n                {\n                    await currentState\n                        .ExitAsync(publisher.Context, cancellationToken);\n\n                    publisher.stack.Pop();\n                    return Results.Succeed();\n                }\n                finally\n                {\n                    publisher.semaphore.Release();\n                }\n            }\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/TransitionMap.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\nusing Mochineko.Relent.Result;\n\nnamespace Mochineko.RelentStateMachine\n{\n    internal sealed class TransitionMap<TEvent, TContext>\n        : ITransitionMap<TEvent, TContext>\n    {\n        private readonly IState<TEvent, TContext> initialState;\n        private readonly IReadOnlyList<IState<TEvent, TContext>> states;\n", "        private readonly IState<TEvent, TContext> initialState;\n        private readonly IReadOnlyList<IState<TEvent, TContext>> states;\n\n        private readonly IReadOnlyDictionary<\n                IState<TEvent, TContext>,\n                IReadOnlyDictionary<TEvent, IState<TEvent, TContext>>>\n            transitionMap;\n\n        private readonly IReadOnlyDictionary<TEvent, IState<TEvent, TContext>>\n            anyTransitionMap;\n\n        public TransitionMap(\n            IState<TEvent, TContext> initialState,\n            IReadOnlyList<IState<TEvent, TContext>> states,\n            IReadOnlyDictionary<\n                    IState<TEvent, TContext>,\n                    IReadOnlyDictionary<TEvent, IState<TEvent, TContext>>>\n                transitionMap,\n            IReadOnlyDictionary<TEvent, IState<TEvent, TContext>> anyTransitionMap)\n        {\n            this.initialState = initialState;\n            this.states = states;\n            this.transitionMap = transitionMap;\n            this.anyTransitionMap = anyTransitionMap;\n        }\n\n        IState<TEvent, TContext> ITransitionMap<TEvent, TContext>.InitialState\n            => initialState;\n\n        IResult<IState<TEvent, TContext>> ITransitionMap<TEvent, TContext>.AllowedToTransit(\n            IState<TEvent, TContext> currentState,\n            TEvent @event)\n        {", "        private readonly IReadOnlyDictionary<TEvent, IState<TEvent, TContext>>\n            anyTransitionMap;\n\n        public TransitionMap(\n            IState<TEvent, TContext> initialState,\n            IReadOnlyList<IState<TEvent, TContext>> states,\n            IReadOnlyDictionary<\n                    IState<TEvent, TContext>,\n                    IReadOnlyDictionary<TEvent, IState<TEvent, TContext>>>\n                transitionMap,\n            IReadOnlyDictionary<TEvent, IState<TEvent, TContext>> anyTransitionMap)\n        {\n            this.initialState = initialState;\n            this.states = states;\n            this.transitionMap = transitionMap;\n            this.anyTransitionMap = anyTransitionMap;\n        }\n\n        IState<TEvent, TContext> ITransitionMap<TEvent, TContext>.InitialState\n            => initialState;\n\n        IResult<IState<TEvent, TContext>> ITransitionMap<TEvent, TContext>.AllowedToTransit(\n            IState<TEvent, TContext> currentState,\n            TEvent @event)\n        {", "            if (transitionMap.TryGetValue(currentState, out var candidates))\n            {\n                if (candidates.TryGetValue(@event, out var nextState))\n                {\n                    return Results.Succeed(nextState);\n                }\n            }\n\n            if (anyTransitionMap.TryGetValue(@event, out var nextStateFromAny))\n            {\n                return Results.Succeed(nextStateFromAny);\n            }\n\n            return Results.Fail<IState<TEvent, TContext>>(\n                $\"Not found transition from {currentState.GetType()} with event {@event}.\");\n        }\n", "            if (anyTransitionMap.TryGetValue(@event, out var nextStateFromAny))\n            {\n                return Results.Succeed(nextStateFromAny);\n            }\n\n            return Results.Fail<IState<TEvent, TContext>>(\n                $\"Not found transition from {currentState.GetType()} with event {@event}.\");\n        }\n\n        public void Dispose()\n        {", "        public void Dispose()\n        {\n            foreach (var state in states)\n            {\n                state.Dispose();\n            }\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/IPopToken.cs", "chunked_list": ["#nullable enable\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Result;\n\nnamespace Mochineko.RelentStateMachine\n{\n    public interface IPopToken\n    {\n        UniTask<IResult> PopAsync(CancellationToken cancellationToken);\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine/FiniteStateMachine.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Result;\n\nnamespace Mochineko.RelentStateMachine\n{\n    public sealed class FiniteStateMachine<TEvent, TContext>\n        : IFiniteStateMachine<TEvent, TContext>\n    {", "    public sealed class FiniteStateMachine<TEvent, TContext>\n        : IFiniteStateMachine<TEvent, TContext>\n    {\n        private readonly ITransitionMap<TEvent, TContext> transitionMap;\n        public TContext Context { get; }\n        private IState<TEvent, TContext> currentState;\n\n        public bool IsCurrentState<TState>()\n            where TState : IState<TEvent, TContext>\n            => currentState is TState;\n", "        private readonly SemaphoreSlim semaphore = new(\n            initialCount: 1,\n            maxCount: 1);\n\n        private readonly TimeSpan semaphoreTimeout;\n        private const float DefaultSemaphoreTimeoutSeconds = 30f;\n\n        public static async UniTask<FiniteStateMachine<TEvent, TContext>> CreateAsync(\n            ITransitionMap<TEvent, TContext> transitionMap,\n            TContext context,\n            CancellationToken cancellationToken,\n            TimeSpan? semaphoreTimeout = null)\n        {\n            var instance = new FiniteStateMachine<TEvent, TContext>(\n                transitionMap,\n                context,\n                semaphoreTimeout);\n\n            var enterResult = await instance.currentState\n                .EnterAsync(context, cancellationToken);\n            switch (enterResult)\n            {\n                case NoEventRequest<TEvent>:\n                    return instance;;\n\n                case SomeEventRequest<TEvent> eventRequest:\n                    var sendEventResult = await instance\n                        .SendEventAsync(eventRequest.Event, cancellationToken);\n                    return instance;;\n                \n                default:\n                    throw new ArgumentOutOfRangeException(nameof(enterResult));\n            }\n        }\n\n        private FiniteStateMachine(\n            ITransitionMap<TEvent, TContext> transitionMap,\n            TContext context,\n            TimeSpan? semaphoreTimeout = null)\n        {\n            this.transitionMap = transitionMap;\n            this.Context = context;\n            this.currentState = this.transitionMap.InitialState;\n\n            this.semaphoreTimeout =\n                semaphoreTimeout\n                ?? TimeSpan.FromSeconds(DefaultSemaphoreTimeoutSeconds);\n        }\n        ", "        public void Dispose()\n        {\n            transitionMap.Dispose();\n            semaphore.Dispose();\n        }\n\n        public async UniTask<IResult> SendEventAsync(\n            TEvent @event,\n            CancellationToken cancellationToken)\n        {\n            // Check transition.\n            IState<TEvent, TContext> nextState;\n            var transitionCheckResult = transitionMap.AllowedToTransit(currentState, @event);\n            switch (transitionCheckResult)\n            {\n                case ISuccessResult<IState<TEvent, TContext>> transitionSuccess:\n                    nextState = transitionSuccess.Result;\n                    break;\n\n                case IFailureResult<IState<TEvent, TContext>> transitionFailure:\n                    return Results.Fail(\n                        $\"Failed to transit state because of {transitionFailure.Message}.\");\n\n                default:\n                    throw new ResultPatternMatchException(nameof(transitionCheckResult));\n            }\n\n            var transitResult = await TransitAsync(nextState, cancellationToken);\n            switch (transitResult)\n            {\n                case ISuccessResult<IEventRequest<TEvent>> successResult\n                    when successResult.Result is SomeEventRequest<TEvent> eventRequest:\n                    // NOTE: Recursive calling.\n                    return await SendEventAsync(eventRequest.Event, cancellationToken);\n\n                case ISuccessResult<IEventRequest<TEvent>> successResult:\n                    return Results.Succeed();\n\n                case IFailureResult<IEventRequest<TEvent>> failureResult:\n                    return Results.Fail(\n                        $\"Failed to transit state from {currentState.GetType()} to {nextState.GetType()} because of {failureResult.Message}.\");\n\n                default:\n                    throw new ResultPatternMatchException(nameof(transitResult));\n            }\n        }\n", "        private async UniTask<IResult<IEventRequest<TEvent>>> TransitAsync(\n            IState<TEvent, TContext> nextState,\n            CancellationToken cancellationToken)\n        {\n            // Make state thread-safe.\n            try\n            {\n                await semaphore.WaitAsync(semaphoreTimeout, cancellationToken);\n            }\n            catch (OperationCanceledException exception)\n            {\n                semaphore.Release();\n                return StateResults.Fail<TEvent>(\n                    $\"Cancelled to wait semaphore because of {exception}.\");\n            }\n\n            try\n            {\n                // Exit current state.\n                await currentState.ExitAsync(Context, cancellationToken);\n                \n                // Enter next state.\n                var enterResult = await nextState.EnterAsync(Context, cancellationToken);\n                currentState = nextState;\n                return Results.Succeed(enterResult);\n            }", "            catch (OperationCanceledException exception)\n            {\n                semaphore.Release();\n                return StateResults.Fail<TEvent>(\n                    $\"Cancelled to wait semaphore because of {exception}.\");\n            }\n\n            try\n            {\n                // Exit current state.\n                await currentState.ExitAsync(Context, cancellationToken);\n                \n                // Enter next state.\n                var enterResult = await nextState.EnterAsync(Context, cancellationToken);\n                currentState = nextState;\n                return Results.Succeed(enterResult);\n            }", "            catch (OperationCanceledException exception)\n            {\n                return StateResults.Fail<TEvent>(\n                    $\"Cancelled to transit state because of {exception}.\");\n            }\n            finally\n            {\n                semaphore.Release();\n            }\n        }\n", "        public async UniTask UpdateAsync(CancellationToken cancellationToken)\n        {\n            var updateResult = await currentState.UpdateAsync(Context, cancellationToken);\n            switch (updateResult)\n            {\n                case NoEventRequest<TEvent>:\n                    break;\n                \n                case SomeEventRequest<TEvent> eventRequest:\n                    await SendEventAsync(eventRequest.Event, cancellationToken);\n                    return;\n                \n                default:\n                    throw new ArgumentOutOfRangeException(nameof(updateResult));\n            }\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/MockContinueEvent.cs", "chunked_list": ["#nullable enable\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal enum MockContinueEvent\n    {\n        Continue,\n        Stop,\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/Phase3State.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal sealed class Phase3State : IState<MockContinueEvent, MockContinueContext>\n    {\n        public async UniTask<IEventRequest<MockContinueEvent>> EnterAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(0.01f),\n                cancellationToken: cancellationToken);\n\n            context.PhaseCount++;\n\n            return EventRequests<MockContinueEvent>.Request(MockContinueEvent.Continue);\n        }\n", "        public async UniTask<IEventRequest<MockContinueEvent>> EnterAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(0.01f),\n                cancellationToken: cancellationToken);\n\n            context.PhaseCount++;\n\n            return EventRequests<MockContinueEvent>.Request(MockContinueEvent.Continue);\n        }\n", "        public async UniTask<IEventRequest<MockContinueEvent>> UpdateAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                    TimeSpan.FromSeconds(0.01f),\n                    cancellationToken: cancellationToken);\n\n            return EventRequests<MockContinueEvent>.None();\n        }\n", "        public async UniTask ExitAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                    TimeSpan.FromSeconds(0.01f),\n                    cancellationToken: cancellationToken);\n        }\n\n        public void Dispose()\n        {\n        }\n    }\n}", "        public void Dispose()\n        {\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/InactiveState.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal sealed class InactiveState : IState<MockEvent, MockContext>\n    {\n        async UniTask<IEventRequest<MockEvent>> IState<MockEvent, MockContext>.EnterAsync(\n            MockContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(0.01f),\n                cancellationToken: cancellationToken);\n\n            context.Active = false;\n\n            return EventRequests<MockEvent>.None();\n        }\n", "        public async UniTask<IEventRequest<MockEvent>> UpdateAsync(MockContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(0.01f),\n                cancellationToken: cancellationToken);\n\n            return EventRequests<MockEvent>.None();\n        }\n\n        public async UniTask ExitAsync(MockContext context, CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(0.01f),\n                cancellationToken: cancellationToken);\n        }\n", "        public async UniTask ExitAsync(MockContext context, CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(0.01f),\n                cancellationToken: cancellationToken);\n        }\n\n        public void Dispose()\n        {\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/ErrorState.cs", "chunked_list": ["#nullable enable\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal sealed class ErrorState : IState<MockEvent, MockContext>\n    {\n        public async UniTask<IEventRequest<MockEvent>> EnterAsync(MockContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.DelayFrame(1, cancellationToken: cancellationToken);\n\n            context.ErrorMessage = \"Manual Error\";\n\n            return EventRequests<MockEvent>.None();\n        }\n", "        public async UniTask<IEventRequest<MockEvent>> EnterAsync(MockContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.DelayFrame(1, cancellationToken: cancellationToken);\n\n            context.ErrorMessage = \"Manual Error\";\n\n            return EventRequests<MockEvent>.None();\n        }\n\n        public async UniTask<IEventRequest<MockEvent>> UpdateAsync(MockContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.DelayFrame(1, cancellationToken: cancellationToken);\n\n            return EventRequests<MockEvent>.None();\n        }\n", "        public async UniTask<IEventRequest<MockEvent>> UpdateAsync(MockContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.DelayFrame(1, cancellationToken: cancellationToken);\n\n            return EventRequests<MockEvent>.None();\n        }\n\n        public async UniTask ExitAsync(MockContext context, CancellationToken cancellationToken)\n        {\n            await UniTask.DelayFrame(1, cancellationToken: cancellationToken);\n        }\n", "        public async UniTask ExitAsync(MockContext context, CancellationToken cancellationToken)\n        {\n            await UniTask.DelayFrame(1, cancellationToken: cancellationToken);\n        }\n\n        public void Dispose()\n        {\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/MockStackContext.cs", "chunked_list": ["#nullable enable\nusing System.Collections.Generic;\n\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal sealed class MockStackContext\n    {\n        public Stack<IPopToken> PopTokenStack = new();\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/FirstStackState.cs", "chunked_list": ["#nullable enable\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\n#pragma warning disable CS1998\n\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal sealed class FirstStackState : IStackState<MockStackContext>\n    {\n        public async UniTask EnterAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n        }\n", "    internal sealed class FirstStackState : IStackState<MockStackContext>\n    {\n        public async UniTask EnterAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n        }\n\n        public async UniTask UpdateAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n        }\n\n        public async UniTask ExitAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n        }\n", "        public async UniTask ExitAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n        }\n\n        public void Dispose()\n        {\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/FinishState.cs", "chunked_list": ["#nullable enable\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\n#pragma warning disable CS1998\n\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal sealed class FinishState : IState<MockContinueEvent, MockContinueContext>\n    {\n        public async UniTask<IEventRequest<MockContinueEvent>> EnterAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            context.Finished = true;\n            \n            return EventRequests<MockContinueEvent>.None();\n        }\n", "    internal sealed class FinishState : IState<MockContinueEvent, MockContinueContext>\n    {\n        public async UniTask<IEventRequest<MockContinueEvent>> EnterAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            context.Finished = true;\n            \n            return EventRequests<MockContinueEvent>.None();\n        }\n", "        public async UniTask<IEventRequest<MockContinueEvent>> UpdateAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            return EventRequests<MockContinueEvent>.None();\n        }\n\n        public UniTask ExitAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            return UniTask.CompletedTask;\n        }\n", "        public void Dispose()\n        {\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/MockEvent.cs", "chunked_list": ["#nullable enable\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal enum MockEvent\n    {\n        Activate,\n        Deactivate,\n        Fail,\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/BaseStackState.cs", "chunked_list": ["#nullable enable\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\n#pragma warning disable CS1998\n\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal sealed class BaseStackState : IStackState<MockStackContext>\n    {\n        public async UniTask EnterAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n        }\n", "    internal sealed class BaseStackState : IStackState<MockStackContext>\n    {\n        public async UniTask EnterAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n        }\n\n        public async UniTask UpdateAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n            \n        }\n", "        public async UniTask ExitAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n            \n        }\n        \n        public void Dispose()\n        {\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/FiniteStateMachineTest.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing FluentAssertions;\nusing NUnit.Framework;\nusing UnityEngine.TestTools;\n\nnamespace Mochineko.RelentStateMachine.Tests\n{", "namespace Mochineko.RelentStateMachine.Tests\n{\n    [TestFixture]\n    internal sealed class FiniteStateMachineTest\n    {\n        [Test]\n        [RequiresPlayMode(false)]\n        public async Task StateMachineShouldTransitByEvent()\n        {\n            // NOTE: Initial state is specified at constructor.\n            var transitionMapBuilder = TransitionMapBuilder<MockEvent, MockContext>\n                .Create<InactiveState>();\n\n            // NOTE: Register transitions to builder.\n            transitionMapBuilder.RegisterTransition<InactiveState, ActiveState>(MockEvent.Activate);\n            transitionMapBuilder.RegisterTransition<ActiveState, InactiveState>(MockEvent.Deactivate);\n            transitionMapBuilder.RegisterAnyTransition<ErrorState>(MockEvent.Fail);\n\n            // NOTE: Built transition map is immutable.\n            using var stateMachine =\n                await FiniteStateMachine<MockEvent, MockContext>.CreateAsync(\n                    transitionMapBuilder.Build(),\n                    new MockContext(),\n                    CancellationToken.None);\n\n            // Inactive state ------------------------------------------------------\n\n            // NOTE: Asynchronously created state machine has been already in initial state.\n            stateMachine.IsCurrentState<InactiveState>()\n                .Should().BeTrue(\n                    because: $\"Initial state should be {nameof(InactiveState)}.\");\n\n            stateMachine.Context.Active\n                .Should().BeFalse();\n\n            await stateMachine.UpdateAsync(CancellationToken.None);\n\n            stateMachine.IsCurrentState<InactiveState>()\n                .Should().BeTrue(\n                    because: $\"State should not change on update.\");\n\n            (await stateMachine\n                    .SendEventAsync(MockEvent.Deactivate, CancellationToken.None))\n                .Failure.Should().BeTrue(\n                    because: $\"Already in {nameof(InactiveState)}.\");\n\n            // Active state ------------------------------------------------------\n\n            (await stateMachine\n                    .SendEventAsync(MockEvent.Activate, CancellationToken.None))\n                .Success.Should().BeTrue(\n                    because:\n                    $\"Can change state from {nameof(InactiveState)} to {nameof(ActiveState)} by {MockEvent.Activate}.\");\n\n            stateMachine.IsCurrentState<ActiveState>()\n                .Should().BeTrue();\n\n            stateMachine.Context.Active\n                .Should().BeTrue();\n\n            await stateMachine.UpdateAsync(CancellationToken.None);\n\n            (await stateMachine\n                    .SendEventAsync(MockEvent.Activate, CancellationToken.None))\n                .Failure.Should().BeTrue(\n                    because: $\"Already in {nameof(ActiveState)}.\");\n\n            stateMachine.IsCurrentState<ActiveState>()\n                .Should().BeTrue(\n                    because: \"State should not change by sending event failure.\");\n\n            stateMachine.Context.Active\n                .Should().BeTrue();\n\n            // Inactive state ------------------------------------------------------\n\n            (await stateMachine\n                    .SendEventAsync(MockEvent.Deactivate, CancellationToken.None))\n                .Success.Should().BeTrue(\n                    because:\n                    $\"Can change state from {nameof(ActiveState)} to {nameof(ActiveState)} by {MockEvent.Deactivate}.\");\n\n            stateMachine.IsCurrentState<InactiveState>()\n                .Should().BeTrue();\n\n            stateMachine.Context.Active\n                .Should().BeFalse();\n\n            await stateMachine.UpdateAsync(CancellationToken.None);\n\n            // Error state ------------------------------------------------------\n\n            (await stateMachine\n                    .SendEventAsync(MockEvent.Fail, CancellationToken.None))\n                .Success.Should().BeTrue(\n                    because: $\"Error state can be transited from any state by {MockEvent.Fail}.\");\n\n            stateMachine.IsCurrentState<ErrorState>()\n                .Should().BeTrue();\n\n            stateMachine.Context.ErrorMessage\n                .Should().Be(\"Manual Error\");\n        }\n\n        [Test]\n        [RequiresPlayMode(false)]", "        public void BuilderShouldNotBeReused()\n        {\n            var transitionMapBuilder = TransitionMapBuilder<MockEvent, MockContext>\n                .Create<InactiveState>();\n\n            transitionMapBuilder.RegisterTransition<InactiveState, ActiveState>(MockEvent.Activate);\n            transitionMapBuilder.RegisterTransition<ActiveState, InactiveState>(MockEvent.Deactivate);\n\n            _ = transitionMapBuilder.Build();\n\n            Action operateBuilder = () => transitionMapBuilder\n                .RegisterAnyTransition<ErrorState>(MockEvent.Fail);\n\n            operateBuilder.Should().Throw<ObjectDisposedException>();\n        }\n\n        [Test]\n        [RequiresPlayMode(false)]", "        public async Task SendEventShouldBeThreadSafe()\n        {\n            var transitionMapBuilder = TransitionMapBuilder<MockEvent, MockContext>\n                .Create<InactiveState>();\n\n            transitionMapBuilder.RegisterTransition<InactiveState, ActiveState>(MockEvent.Activate);\n            transitionMapBuilder.RegisterTransition<ActiveState, InactiveState>(MockEvent.Deactivate);\n            transitionMapBuilder.RegisterAnyTransition<ErrorState>(MockEvent.Fail);\n\n            using var stateMachine =\n                await FiniteStateMachine<MockEvent, MockContext>.CreateAsync(\n                    transitionMapBuilder.Build(),\n                    new MockContext(),\n                    CancellationToken.None);\n\n#pragma warning disable CS4014\n            var firstTask = Task.Run(async () =>\n            {\n                _ = await stateMachine\n                    .SendEventAsync(MockEvent.Activate, CancellationToken.None);\n            });\n            var secondTask = Task.Run(async () =>\n            {\n                _ = await stateMachine\n                    .SendEventAsync(MockEvent.Fail, CancellationToken.None);\n            });\n#pragma warning restore CS4014\n\n            firstTask.Status.Should().Be(TaskStatus.WaitingForActivation);\n            secondTask.Status.Should().Be(TaskStatus.WaitingForActivation);\n\n            await Task.WhenAll(firstTask, secondTask);\n\n            firstTask.Status.Should().Be(TaskStatus.RanToCompletion);\n            secondTask.Status.Should().Be(TaskStatus.RanToCompletion);\n\n            stateMachine.IsCurrentState<ErrorState>()\n                .Should().BeTrue();\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/StackStateMachineTest.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing FluentAssertions;\nusing Mochineko.Relent.Result;\nusing NUnit.Framework;\nusing UnityEngine.TestTools;\n\nnamespace Mochineko.RelentStateMachine.Tests", "\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    [TestFixture]\n    internal sealed class StackStateMachineTest\n    {\n        [Test]\n        [RequiresPlayMode(false)]\n        public async Task StateMachineShouldTransitByEvent()\n        {\n            // NOTE: Initial state is specified at constructor.\n            var stateStore = StateStoreBuilder<MockStackContext>\n                .Create<BaseStackState>();\n\n            // NOTE: Register states to builder.\n            stateStore.Register<PopupStackState>();\n            stateStore.Register<OverlayStackState>();\n            stateStore.Register<FirstStackState>();\n\n            // NOTE: Built store is immutable.\n            using var stateMachine =\n                await StackStateMachine<MockStackContext>.CreateAsync(\n                    stateStore.Build(),\n                    new MockStackContext(),\n                    CancellationToken.None);\n\n            // [Base state] ------------------------------------------------------\n\n            // NOTE: Asynchronously created state machine has been already in initial state.\n            stateMachine.IsCurrentState<BaseStackState>()\n                .Should().BeTrue(\n                    because: $\"Initial state should be {nameof(BaseStackState)}.\");\n\n            stateMachine.Context.PopTokenStack.Count\n                .Should().Be(0);\n\n            await stateMachine.UpdateAsync(CancellationToken.None);\n\n            // [Popup] ------------------------------------------------------\n            // [Base] ------------------------------------------------------\n\n            var pushResult = await stateMachine\n                .PushAsync<PopupStackState>(CancellationToken.None);\n            pushResult.Success\n                .Should().BeTrue();", "        public async Task StateMachineShouldTransitByEvent()\n        {\n            // NOTE: Initial state is specified at constructor.\n            var stateStore = StateStoreBuilder<MockStackContext>\n                .Create<BaseStackState>();\n\n            // NOTE: Register states to builder.\n            stateStore.Register<PopupStackState>();\n            stateStore.Register<OverlayStackState>();\n            stateStore.Register<FirstStackState>();\n\n            // NOTE: Built store is immutable.\n            using var stateMachine =\n                await StackStateMachine<MockStackContext>.CreateAsync(\n                    stateStore.Build(),\n                    new MockStackContext(),\n                    CancellationToken.None);\n\n            // [Base state] ------------------------------------------------------\n\n            // NOTE: Asynchronously created state machine has been already in initial state.\n            stateMachine.IsCurrentState<BaseStackState>()\n                .Should().BeTrue(\n                    because: $\"Initial state should be {nameof(BaseStackState)}.\");\n\n            stateMachine.Context.PopTokenStack.Count\n                .Should().Be(0);\n\n            await stateMachine.UpdateAsync(CancellationToken.None);\n\n            // [Popup] ------------------------------------------------------\n            // [Base] ------------------------------------------------------\n\n            var pushResult = await stateMachine\n                .PushAsync<PopupStackState>(CancellationToken.None);\n            pushResult.Success\n                .Should().BeTrue();", "            if (pushResult is ISuccessResult<IPopToken> pushSuccess)\n            {\n                stateMachine.Context.PopTokenStack\n                    .Push(pushSuccess.Result);\n            }\n            else\n            {\n                Assert.Fail();\n            }\n\n            stateMachine.IsCurrentState<PopupStackState>()\n                .Should().BeTrue();\n\n            stateMachine.Context.PopTokenStack.Count\n                .Should().Be(1);\n\n            await stateMachine.UpdateAsync(CancellationToken.None);\n\n            // [Overlay] ------------------------------------------------------\n            // [Popup] ------------------------------------------------------\n            // [Base] ------------------------------------------------------\n\n            pushResult = await stateMachine\n                .PushAsync<OverlayStackState>(CancellationToken.None);\n            pushResult.Success\n                .Should().BeTrue();", "            if (pushResult is ISuccessResult<IPopToken> pushSuccess2)\n            {\n                stateMachine.Context.PopTokenStack\n                    .Push(pushSuccess2.Result);\n            }\n            else\n            {\n                Assert.Fail();\n            }\n\n            stateMachine.IsCurrentState<OverlayStackState>()\n                .Should().BeTrue();\n\n            stateMachine.Context.PopTokenStack.Count\n                .Should().Be(2);\n\n            await stateMachine.UpdateAsync(CancellationToken.None);\n\n            // [Popup] ------------------------------------------------------\n            // [Overlay] ------------------------------------------------------\n            // [Popup] ------------------------------------------------------\n            // [Base] ------------------------------------------------------\n\n            pushResult = await stateMachine\n                .PushAsync<FirstStackState>(CancellationToken.None);\n            pushResult.Success\n                .Should().BeTrue();", "            if (pushResult is ISuccessResult<IPopToken> pushSuccess3)\n            {\n                stateMachine.Context.PopTokenStack\n                    .Push(pushSuccess3.Result);\n            }\n            else\n            {\n                Assert.Fail();\n            }\n\n            stateMachine.IsCurrentState<FirstStackState>()\n                .Should().BeTrue();\n\n            stateMachine.Context.PopTokenStack.Count\n                .Should().Be(3);\n\n            await stateMachine.UpdateAsync(CancellationToken.None);\n\n            // [Overlay] ------------------------------------------------------\n            // [Popup] ------------------------------------------------------\n            // [Base] ------------------------------------------------------\n\n            var firstPopToken = stateMachine.Context.PopTokenStack.Pop();\n            await firstPopToken.PopAsync(CancellationToken.None);\n\n            stateMachine.IsCurrentState<OverlayStackState>()\n                .Should().BeTrue();\n\n            stateMachine.Context.PopTokenStack.Count\n                .Should().Be(2);\n\n            await stateMachine.UpdateAsync(CancellationToken.None);\n\n            // [Popup] ------------------------------------------------------\n            // [Base] ------------------------------------------------------\n\n            var overlayPopToken = stateMachine.Context.PopTokenStack.Pop();\n            await overlayPopToken.PopAsync(CancellationToken.None);\n\n            stateMachine.IsCurrentState<PopupStackState>()\n                .Should().BeTrue();\n\n            stateMachine.Context.PopTokenStack.Count\n                .Should().Be(1);\n\n            // [First] ------------------------------------------------------\n            // [Popup] ------------------------------------------------------\n            // [Base] ------------------------------------------------------\n\n            pushResult = await stateMachine\n                .PushAsync<FirstStackState>(CancellationToken.None);\n            pushResult.Success\n                .Should().BeTrue();", "            if (pushResult is ISuccessResult<IPopToken> pushSuccess4)\n            {\n                stateMachine.Context.PopTokenStack\n                    .Push(pushSuccess4.Result);\n            }\n            else\n            {\n                Assert.Fail();\n            }\n\n            stateMachine.IsCurrentState<FirstStackState>()\n                .Should().BeTrue();\n\n            stateMachine.Context.PopTokenStack.Count\n                .Should().Be(2);\n\n            // [Base] ------------------------------------------------------\n", "            while (stateMachine.Context.PopTokenStack.TryPop(out var popToken))\n            {\n                await popToken.PopAsync(CancellationToken.None);\n            }\n\n            stateMachine.IsCurrentState<BaseStackState>()\n                .Should().BeTrue();\n\n            stateMachine.Context.PopTokenStack.Count\n                .Should().Be(0);\n        }\n\n        [Test]\n        [RequiresPlayMode(false)]", "        public void BuilderShouldNotBeReused()\n        {\n            var stateStoreBuilder = StateStoreBuilder<MockStackContext>\n                .Create<BaseStackState>();\n\n            stateStoreBuilder.Register<PopupStackState>();\n            stateStoreBuilder.Register<OverlayStackState>();\n            stateStoreBuilder.Register<FirstStackState>();\n\n            _ = stateStoreBuilder.Build();\n\n            Action operateBuilder = () => stateStoreBuilder\n                .Register<BaseStackState>();\n\n            operateBuilder.Should().Throw<ObjectDisposedException>();\n        }\n\n        [Test]\n        [RequiresPlayMode(false)]", "        public void InitialStateShouldHaveBeenRegistered()\n        {\n            var stateStoreBuilder = StateStoreBuilder<MockStackContext>\n                .Create<BaseStackState>();\n\n            Action registerInitial = () => stateStoreBuilder\n                .Register<BaseStackState>();\n\n            registerInitial\n                .Should().Throw<InvalidOperationException>();\n        }\n\n        [Test]\n        [RequiresPlayMode(false)]", "        public void CannotRegisterSameStateTwice()\n        {\n            var stateStoreBuilder = StateStoreBuilder<MockStackContext>\n                .Create<BaseStackState>();\n\n            stateStoreBuilder.Register<PopupStackState>();\n\n            Action registerTwice = () => stateStoreBuilder\n                .Register<PopupStackState>();\n\n            registerTwice\n                .Should().Throw<InvalidOperationException>();\n        }\n\n        [Test]\n        [RequiresPlayMode(false)]", "        public async Task StackOperationsShouldBeThreadSafe()\n        {\n            var stateStore = StateStoreBuilder<MockStackContext>\n                .Create<BaseStackState>();\n\n            stateStore.Register<PopupStackState>();\n            stateStore.Register<OverlayStackState>();\n            stateStore.Register<FirstStackState>();\n\n            using var stateMachine =\n                await StackStateMachine<MockStackContext>.CreateAsync(\n                    stateStore.Build(),\n                    new MockStackContext(),\n                    CancellationToken.None);\n\n#pragma warning disable CS4014\n            var firstTask = Task.Run(async () =>\n            {\n                await stateMachine\n                    .PushAsync<PopupStackState>(CancellationToken.None);\n            });\n            var secondTask = Task.Run(async () =>\n            {\n                await stateMachine\n                    .PushAsync<OverlayStackState>(CancellationToken.None);\n            });\n#pragma warning restore CS4014\n\n            firstTask.Status.Should().Be(TaskStatus.WaitingForActivation);\n            secondTask.Status.Should().Be(TaskStatus.WaitingForActivation);\n\n            await Task.WhenAll(firstTask, secondTask);\n\n            firstTask.Status.Should().Be(TaskStatus.RanToCompletion);\n            secondTask.Status.Should().Be(TaskStatus.RanToCompletion);\n\n            stateMachine.IsCurrentState<OverlayStackState>()\n                .Should().BeTrue();\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/Phase4State.cs", "chunked_list": ["#nullable enable\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Result;\n\n#pragma warning disable CS1998\n\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal sealed class Phase4State : IState<MockContinueEvent, MockContinueContext>\n    {", "{\n    internal sealed class Phase4State : IState<MockContinueEvent, MockContinueContext>\n    {\n        public async UniTask<IEventRequest<MockContinueEvent>> EnterAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            context.PhaseCount++;\n            \n            return EventRequests<MockContinueEvent>.None();\n        }\n", "        public async UniTask<IEventRequest<MockContinueEvent>> UpdateAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            return EventRequests<MockContinueEvent>.Request(MockContinueEvent.Stop);\n        }\n\n        public async UniTask ExitAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            \n        }\n", "        public void Dispose()\n        {\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/OverlayStackState.cs", "chunked_list": ["#nullable enable\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\n#pragma warning disable CS1998\n\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal sealed class OverlayStackState : IStackState<MockStackContext>\n    {\n        public async UniTask EnterAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n        }\n", "    internal sealed class OverlayStackState : IStackState<MockStackContext>\n    {\n        public async UniTask EnterAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n        }\n\n        public async UniTask UpdateAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n        }\n\n        public async UniTask ExitAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n        }\n        ", "        public async UniTask ExitAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n        }\n        \n        public void Dispose()\n        {\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/Phase2State.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal sealed class Phase2State : IState<MockContinueEvent, MockContinueContext>\n    {\n        public async UniTask<IEventRequest<MockContinueEvent>> EnterAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(0.01f),\n                cancellationToken: cancellationToken);\n\n            context.PhaseCount++;\n\n            return EventRequests<MockContinueEvent>.Request(MockContinueEvent.Continue);\n        }\n", "        public async UniTask<IEventRequest<MockContinueEvent>> EnterAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(0.01f),\n                cancellationToken: cancellationToken);\n\n            context.PhaseCount++;\n\n            return EventRequests<MockContinueEvent>.Request(MockContinueEvent.Continue);\n        }\n", "        public async UniTask<IEventRequest<MockContinueEvent>> UpdateAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(0.01f),\n                cancellationToken: cancellationToken);\n\n            return EventRequests<MockContinueEvent>.None();\n        }\n", "        public async UniTask ExitAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(0.01f),\n                cancellationToken: cancellationToken);\n        }\n\n        public void Dispose()\n        {\n        }\n    }\n}", "        public void Dispose()\n        {\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/MockStateMachineController.cs", "chunked_list": ["#nullable enable\nusing Cysharp.Threading.Tasks;\nusing Mochineko.Relent.Result;\nusing UnityEngine;\nusing Assert = UnityEngine.Assertions.Assert;\n\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal sealed class MockStateMachineController : MonoBehaviour\n    {\n        private FiniteStateMachine<MockEvent, MockContext>? stateMachine;\n", "    internal sealed class MockStateMachineController : MonoBehaviour\n    {\n        private FiniteStateMachine<MockEvent, MockContext>? stateMachine;\n\n        private async void Awake()\n        {\n            var transitionMapBuilder = TransitionMapBuilder<MockEvent, MockContext>\n                .Create<InactiveState>();\n\n            transitionMapBuilder.RegisterTransition<InactiveState, ActiveState>(MockEvent.Activate);\n            transitionMapBuilder.RegisterTransition<ActiveState, InactiveState>(MockEvent.Deactivate);\n            transitionMapBuilder.RegisterTransition<InactiveState, ErrorState>(MockEvent.Fail);\n            transitionMapBuilder.RegisterTransition<ActiveState, ErrorState>(MockEvent.Fail);\n\n            stateMachine = await FiniteStateMachine<MockEvent, MockContext>\n                .CreateAsync(\n                    transitionMapBuilder.Build(),\n                    new MockContext(),\n                    this.GetCancellationTokenOnDestroy());\n        }\n", "        private void OnDestroy()\n        {\n            if (stateMachine is null)\n            {\n                throw new System.NullReferenceException(nameof(stateMachine));\n            }\n\n            stateMachine.Dispose();\n        }\n\n        private async void Update()\n        {", "        private async void Update()\n        {\n            if (stateMachine is null)\n            {\n                throw new System.NullReferenceException(nameof(stateMachine));\n            }\n\n            await stateMachine.UpdateAsync(this.GetCancellationTokenOnDestroy());\n        }\n\n        public async UniTask Activate()\n        {", "        public async UniTask Activate()\n        {\n            if (stateMachine is null)\n            {\n                throw new System.NullReferenceException(nameof(stateMachine));\n            }\n\n            var result = await stateMachine.SendEventAsync(\n                MockEvent.Activate,\n                this.GetCancellationTokenOnDestroy());\n            if (result.Success)\n            {\n                Debug.Log(\"Succeeded to activated.\");\n                Assert.IsTrue(stateMachine.Context.Active);\n            }\n            else\n            {\n                Debug.Log(\"Failed to activate.\");\n                Assert.IsFalse(stateMachine.Context.Active);\n            }\n        }\n", "            if (result.Success)\n            {\n                Debug.Log(\"Succeeded to activated.\");\n                Assert.IsTrue(stateMachine.Context.Active);\n            }\n            else\n            {\n                Debug.Log(\"Failed to activate.\");\n                Assert.IsFalse(stateMachine.Context.Active);\n            }\n        }\n", "        public async UniTask Deactivate()\n        {\n            if (stateMachine is null)\n            {\n                throw new System.NullReferenceException(nameof(stateMachine));\n            }\n\n            var result = await stateMachine.SendEventAsync(\n                MockEvent.Deactivate,\n                this.GetCancellationTokenOnDestroy());\n            if (result.Success)\n            {\n                Debug.Log(\"Succeeded to deactivated.\");\n                Assert.IsFalse(stateMachine.Context.Active);\n            }\n            else\n            {\n                Debug.Log(\"Failed to deactivate.\");\n                Assert.IsTrue(stateMachine.Context.Active);\n            }\n        }\n", "            if (result.Success)\n            {\n                Debug.Log(\"Succeeded to deactivated.\");\n                Assert.IsFalse(stateMachine.Context.Active);\n            }\n            else\n            {\n                Debug.Log(\"Failed to deactivate.\");\n                Assert.IsTrue(stateMachine.Context.Active);\n            }\n        }\n", "        public async UniTask Fail()\n        {\n            if (stateMachine is null)\n            {\n                throw new System.NullReferenceException(nameof(stateMachine));\n            }\n\n            var result = await stateMachine.SendEventAsync(\n                MockEvent.Fail,\n                this.GetCancellationTokenOnDestroy());\n            if (result.Success)\n            {\n                Debug.Log(\"Succeeded to deactivated.\");\n                Assert.IsFalse(stateMachine.Context.Active);\n            }\n            else\n            {\n                Debug.Log(\"Failed to deactivate.\");\n                Assert.IsTrue(stateMachine.Context.Active);\n            }\n        }\n    }\n}", "            if (result.Success)\n            {\n                Debug.Log(\"Succeeded to deactivated.\");\n                Assert.IsFalse(stateMachine.Context.Active);\n            }\n            else\n            {\n                Debug.Log(\"Failed to deactivate.\");\n                Assert.IsTrue(stateMachine.Context.Active);\n            }\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/MockContinueContext.cs", "chunked_list": ["#nullable enable\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal sealed class MockContinueContext\n    {\n        public int PhaseCount { get; set; }\n        public bool Finished { get; set; }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/MockContext.cs", "chunked_list": ["#nullable enable\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal sealed class MockContext\n    {\n        public bool Active { get; set; }\n        public string ErrorMessage { get; set; } = string.Empty;\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/ContinuousStateMachineTest.cs", "chunked_list": ["#nullable enable\nusing System.Threading;\nusing System.Threading.Tasks;\nusing FluentAssertions;\nusing Mochineko.Relent.Result;\nusing NUnit.Framework;\nusing UnityEngine.TestTools;\n\nnamespace Mochineko.RelentStateMachine.Tests\n{", "namespace Mochineko.RelentStateMachine.Tests\n{\n    [TestFixture]\n    internal sealed class ContinuousStateMachineTest\n    {\n        [Test]\n        [RequiresPlayMode(false)]\n        public async Task StateMachineShouldTransitByEvent()\n        {\n            // NOTE: Initial state is specified at constructor.\n            var transitionMapBuilder = TransitionMapBuilder<MockContinueEvent, MockContinueContext>\n                .Create<Phase1State>();\n\n            // NOTE: Register sequential transitions to builder.\n            transitionMapBuilder.RegisterTransition<Phase1State, Phase2State>(MockContinueEvent.Continue);\n            transitionMapBuilder.RegisterTransition<Phase2State, Phase3State>(MockContinueEvent.Continue);\n            transitionMapBuilder.RegisterTransition<Phase3State, Phase4State>(MockContinueEvent.Continue);\n            transitionMapBuilder.RegisterTransition<Phase4State, FinishState>(MockContinueEvent.Stop);\n            \n            using var stateMachine = await FiniteStateMachine<MockContinueEvent, MockContinueContext>.CreateAsync(\n                transitionMapBuilder.Build(),\n                new MockContinueContext(),\n                CancellationToken.None);\n\n            stateMachine.IsCurrentState<Phase4State>()\n                .Should().BeTrue(\n                    because: \"Initial state should be run to phase 1 ~ 4 state by sending event on enter state.\");\n\n            stateMachine.Context.PhaseCount\n                .Should().Be(4);\n\n            await stateMachine.UpdateAsync(CancellationToken.None);\n            \n            stateMachine.IsCurrentState<FinishState>()\n                .Should().BeTrue(\n                    because: \"Phase 4 state should be run to finish state by sending event on update state.\");\n\n            stateMachine.Context.Finished\n                .Should().BeTrue();\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/PopupStackState.cs", "chunked_list": ["#nullable enable\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\n#pragma warning disable CS1998\n\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal sealed class PopupStackState : IStackState<MockStackContext>\n    {\n        public async UniTask EnterAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n        }\n", "    internal sealed class PopupStackState : IStackState<MockStackContext>\n    {\n        public async UniTask EnterAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n        }\n\n        public async UniTask UpdateAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n        }\n\n        public async UniTask ExitAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n        }\n        ", "        public async UniTask ExitAsync(MockStackContext context, CancellationToken cancellationToken)\n        {\n        }\n        \n        public void Dispose()\n        {\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/ActiveState.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal sealed class ActiveState : IState<MockEvent, MockContext>\n    {\n        async UniTask<IEventRequest<MockEvent>> IState<MockEvent, MockContext>.EnterAsync(\n            MockContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(0.01f),\n                cancellationToken: cancellationToken);\n\n            context.Active = true;\n\n            return EventRequests<MockEvent>.None();\n        }\n", "        public async UniTask<IEventRequest<MockEvent>> UpdateAsync(MockContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(0.01f),\n                cancellationToken: cancellationToken);\n\n            return EventRequests<MockEvent>.None();\n        }\n\n        public async UniTask ExitAsync(MockContext context, CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(0.01f),\n                cancellationToken: cancellationToken);\n        }\n", "        public async UniTask ExitAsync(MockContext context, CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(0.01f),\n                cancellationToken: cancellationToken);\n        }\n\n        public void Dispose()\n        {\n        }\n    }\n}"]}
{"filename": "Assets/Mochineko/RelentStateMachine.Tests/Phase1State.cs", "chunked_list": ["#nullable enable\nusing System;\nusing System.Threading;\nusing Cysharp.Threading.Tasks;\n\nnamespace Mochineko.RelentStateMachine.Tests\n{\n    internal sealed class Phase1State : IState<MockContinueEvent, MockContinueContext>\n    {\n        public async UniTask<IEventRequest<MockContinueEvent>> EnterAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(0.01f),\n                cancellationToken: cancellationToken);\n\n            context.PhaseCount++;\n\n            return EventRequests<MockContinueEvent>.Request(MockContinueEvent.Continue);\n        }\n", "        public async UniTask<IEventRequest<MockContinueEvent>> EnterAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                TimeSpan.FromSeconds(0.01f),\n                cancellationToken: cancellationToken);\n\n            context.PhaseCount++;\n\n            return EventRequests<MockContinueEvent>.Request(MockContinueEvent.Continue);\n        }\n", "        public async UniTask<IEventRequest<MockContinueEvent>> UpdateAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                    TimeSpan.FromSeconds(0.01f),\n                    cancellationToken: cancellationToken);\n            \n            return EventRequests<MockContinueEvent>.None();\n        }\n", "        public async UniTask ExitAsync(\n            MockContinueContext context,\n            CancellationToken cancellationToken)\n        {\n            await UniTask.Delay(\n                    TimeSpan.FromSeconds(0.01f),\n                    cancellationToken: cancellationToken);\n        }\n\n        public void Dispose()\n        {\n        }\n    }\n}", "        public void Dispose()\n        {\n        }\n    }\n}"]}
