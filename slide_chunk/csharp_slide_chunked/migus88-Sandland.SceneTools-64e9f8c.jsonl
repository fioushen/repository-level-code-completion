{"filename": "Assets/SceneTools/Editor/Services/ThemesService.cs", "chunked_list": ["using System;\nusing System.Linq;\nusing Sandland.SceneTool.Editor.Common.Utils;\nusing UnityEditor;\nusing UnityEngine.UIElements;\n\nnamespace Sandland.SceneTool.Editor.Services\n{\n    internal static class ThemesService\n    {\n        public const string DefaultThemeStyleSheetName = \"sandland-new-dark\";\n        ", "    internal static class ThemesService\n    {\n        public const string DefaultThemeStyleSheetName = \"sandland-new-dark\";\n        \n        private const string SelectedThemePathKey = \"sandland-selected-theme-guid\";\n\n        public static event Action<StyleSheet> ThemeChanged;\n        \n        public static string SelectedThemePath\n        {\n            get => EditorPrefs.GetString(SelectedThemePathKey, DefaultThemePath);\n            set\n            {\n                EditorPrefs.SetString(SelectedThemePathKey, value);\n                ThemeChanged?.Invoke(GetSelectedTheme());\n            }\n        }\n\n        // This will throw an exception if not found", "        public static string SelectedThemePath\n        {\n            get => EditorPrefs.GetString(SelectedThemePathKey, DefaultThemePath);\n            set\n            {\n                EditorPrefs.SetString(SelectedThemePathKey, value);\n                ThemeChanged?.Invoke(GetSelectedTheme());\n            }\n        }\n\n        // This will throw an exception if not found", "        public static string DefaultThemePath =>\n            AssetDatabaseUtils.FindAssets<StyleSheet>(DefaultThemeStyleSheetName).First().Path;\n\n        public static StyleSheet GetSelectedTheme()\n        {\n            var selectedTheme = AssetDatabase.LoadAssetAtPath<StyleSheet>(SelectedThemePath);\n            if (selectedTheme != null)\n            {\n                return selectedTheme;\n            }\n\n            SelectedThemePath = DefaultThemePath;\n            return GetSelectedTheme();\n        }\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Services/FavoritesService.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Sandland.SceneTool.Editor.Common.Data;\nusing Sandland.SceneTool.Editor.Common.Utils;\nusing UnityEditor;\n\nnamespace Sandland.SceneTool.Editor.Services\n{\n    internal static class FavoritesService\n    {", "{\n    internal static class FavoritesService\n    {\n        private const string FavoriteSceneLabel = \"sandland-favorite-scene\";\n\n        public static event Action FavoritesChanged;\n\n        public static bool IsFavorite(this AssetFileInfo info) => info.Labels?.Contains(FavoriteSceneLabel) ?? false;\n\n        public static void AddToFavorites(this AssetFileInfo info)\n        {", "        public static void AddToFavorites(this AssetFileInfo info)\n        {\n            if (info.IsFavorite())\n            {\n                return;\n            }\n\n            info.Labels ??= new List<string>();\n            info.Labels.Add(FavoriteSceneLabel);\n            info.SetLabels<SceneAsset>();\n            FavoritesChanged?.Invoke();\n        }\n", "        public static void RemoveFromFavorites(this AssetFileInfo info)\n        {\n            if (!info.IsFavorite())\n            {\n                return;\n            }\n\n            info.Labels.Remove(FavoriteSceneLabel);\n            info.SetLabels<SceneAsset>();\n            FavoritesChanged?.Invoke();\n        }\n", "        public static IOrderedEnumerable<SceneInfo> OrderByFavorites(this IEnumerable<SceneInfo> infos) =>\n            infos.OrderByDescending(i => i.IsFavorite());\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Services/SceneTools/SceneToolsService.cs", "chunked_list": ["namespace Sandland.SceneTool.Editor.Services\n{\n    internal static partial class SceneToolsService\n    {\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Services/SceneTools/SceneToolsClassGenerationService.cs", "chunked_list": ["using System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Sandland.SceneTool.Editor.Common.Data;\nusing Sandland.SceneTool.Editor.Common.Utils;\nusing UnityEditor;\n\nnamespace Sandland.SceneTool.Editor.Services\n{\n    internal static partial class SceneToolsService\n    {", "{\n    internal static partial class SceneToolsService\n    {\n        public static class ClassGeneration\n        {\n            private const string MainToggleKey = \"sandland-scene-class-generation-toggle\";\n            private const string LocationKey = \"sandland-scene-class-generation-location\";\n            private const string ClassNameKey = \"sandland-scene-class-generation-class-name\";\n            private const string NamespaceKey = \"sandland-scene-class-generation-namespace\";\n            private const string AddressablesSupportKey = \"sandland-scene-class-generation-addressables-support\";\n            private const string AutogenerateOnChangeToggleKey = \"sandland-scene-class-generation-autogenerate-toggle\";\n            ", "            private const string NamespaceKey = \"sandland-scene-class-generation-namespace\";\n            private const string AddressablesSupportKey = \"sandland-scene-class-generation-addressables-support\";\n            private const string AutogenerateOnChangeToggleKey = \"sandland-scene-class-generation-autogenerate-toggle\";\n            \n            private const string DefaultLocation = \"Assets/Sandland/Runtime/\";\n            private const string DefaultClassName = \"SceneList\";\n            private const string DefaultNamespace = \"Sandland\";\n            private const string Label = \"sandland-scene-class\";\n\n            public static bool IsEnabled\n            {\n                get => EditorPrefs.GetBool(MainToggleKey, false);\n                set => EditorPrefs.SetBool(MainToggleKey, value);\n            }\n            ", "            public static bool IsEnabled\n            {\n                get => EditorPrefs.GetBool(MainToggleKey, false);\n                set => EditorPrefs.SetBool(MainToggleKey, value);\n            }\n            \n            public static bool IsAutoGenerateEnabled\n            {\n                get => EditorPrefs.GetBool(AutogenerateOnChangeToggleKey, true);\n                set => EditorPrefs.SetBool(AutogenerateOnChangeToggleKey, value);\n            }\n            ", "            public static bool IsAddressablesSupportEnabled\n            {\n                get => EditorPrefs.GetBool(AddressablesSupportKey, false);\n                set => EditorPrefs.SetBool(AddressablesSupportKey, value);\n            }\n\n            public static string Directory\n            {\n                get => GetDirectory();\n                set => EditorPrefs.SetString(LocationKey, value);\n            }\n", "            public static string ClassName\n            {\n                get => EditorPrefs.GetString(ClassNameKey, DefaultClassName);\n                set => EditorPrefs.SetString(ClassNameKey, value);\n            }\n\n            public static string Namespace\n            {\n                get => EditorPrefs.GetString(NamespaceKey, DefaultNamespace);\n                set => EditorPrefs.SetString(NamespaceKey, value);\n            }\n", "            public static string FullPath => GetClassLocation();\n\n            public static void CreateFile(List<SceneInfo> scenes)\n            {\n                var builtInScenes = scenes.Where(s => string.IsNullOrEmpty(s.Address));\n                var addressablesScene = scenes.Where(s => !string.IsNullOrWhiteSpace(s.Address));\n                \n                var builtInIndexes = builtInScenes\n                    .Select(s => $\"\\t\\t\\tpublic const int {s.Name.ToPascalCase()} = {s.BuildIndex.ToString()};\");\n                var builtInNames = builtInScenes\n                    .Select(s => $\"\\t\\t\\tpublic const string {s.Name.ToPascalCase()} = \\\"{s.Name}\\\";\");\n                var addresses = addressablesScene\n                    .Select(s => $\"\\t\\t\\tpublic const string {GetAddressablesConstName(s.Address)} = \\\"{s.Address}\\\";\");\n\n                var content = $\"namespace {Namespace}\\n\" +\n                              $\"{{\\n\" +\n                              $\"\\tpublic class {ClassName}\\n\" +\n                              $\"\\t{{\\n\" +", "                              $\"\\t\\tpublic class Names\\n\" +\n                              $\"\\t\\t{{\\n\" +\n                              string.Join(\"\\n\", builtInNames) +\n                              $\"\\n\\t\\t}}\\n\" +\n                              $\"\\n\\t\\tpublic class Indexes\\n\" +\n                              $\"\\t\\t{{\\n\" +\n                              string.Join(\"\\n\", builtInIndexes) +\n                              $\"\\n\\t\\t}}\\n\\n\" +\n                              \"\\t\\tpublic class Addressables\\n\" +\n                              $\"\\t\\t{{\\n\" +\n                              string.Join(\"\\n\", addresses) +\n                              $\"\\n\\t\\t}}\\n\" +\n                              $\"\\t}}\\n\" +\n                              $\"}}\\n\";\n\n                var finalPath = FullPath ?? Path.Combine(Directory, $\"{ClassName}.cs\");\n", "                              \"\\t\\tpublic class Addressables\\n\" +\n                              $\"\\t\\t{{\\n\" +\n                              string.Join(\"\\n\", addresses) +\n                              $\"\\n\\t\\t}}\\n\" +\n                              $\"\\t}}\\n\" +\n                              $\"}}\\n\";\n\n                var finalPath = FullPath ?? Path.Combine(Directory, $\"{ClassName}.cs\");\n\n                if (!AssetDatabase.IsValidFolder(Directory))\n                {\n                    System.IO.Directory.CreateDirectory(Directory);\n                }\n\n                File.WriteAllText(finalPath, content);\n                AssetDatabase.Refresh();\n\n                AssetDatabaseUtils.SetLabel<MonoScript>(finalPath, Label);\n            }\n", "                if (!AssetDatabase.IsValidFolder(Directory))\n                {\n                    System.IO.Directory.CreateDirectory(Directory);\n                }\n\n                File.WriteAllText(finalPath, content);\n                AssetDatabase.Refresh();\n\n                AssetDatabaseUtils.SetLabel<MonoScript>(finalPath, Label);\n            }\n", "            private static string GetAddressablesConstName(string address) =>\n                Path.GetFileNameWithoutExtension(address).ToPascalCase();\n\n            private static string GetDirectory()\n            {\n                var classLocation = GetClassLocation();\n\n                return classLocation == null\n                    ? EditorPrefs.GetString(LocationKey, DefaultLocation)\n                    : Path.GetDirectoryName(classLocation);\n            }\n", "            private static string GetClassLocation()\n            {\n                var info = AssetDatabase.FindAssets($\"l:{Label}\");\n                return info.Length == 0 ? null : AssetDatabase.GUIDToAssetPath(info[0]);\n            }\n        }\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Common/Utils/AssetDatabaseUtils.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Sandland.SceneTool.Editor.Common.Data;\nusing UnityEditor;\nusing UnityEngine;\nusing UnityEngine.SceneManagement;\nusing UnityEngine.UIElements;\nusing Object = UnityEngine.Object;", "using UnityEngine.UIElements;\nusing Object = UnityEngine.Object;\n\nnamespace Sandland.SceneTool.Editor.Common.Utils\n{\n    internal static class AssetDatabaseUtils\n    {\n        public static VisualTreeAsset FindAndLoadVisualTreeAsset(string name = null) =>\n            FindAndLoadAsset<VisualTreeAsset>(name);\n\n        public static StyleSheet FindAndLoadStyleSheet(string name = null) => FindAndLoadAsset<StyleSheet>(name);\n", "        public static StyleSheet FindAndLoadStyleSheet(string name = null) => FindAndLoadAsset<StyleSheet>(name);\n\n        public static bool TryFindAndLoadAsset<T>(out T result, string name = null) where T : Object\n        {\n            try\n            {\n                result = FindAndLoadAsset<T>(name);\n                return true;\n            }\n            catch\n            {\n                result = null;\n                return false;\n            }\n        }\n", "        public static T FindAndLoadAsset<T>(string name = null) where T : Object\n        {\n            // TODO: Reuse code from FindAssets\n            var typeName = typeof(T).Name;\n            var query = string.IsNullOrEmpty(name) ? $\"t:{typeName}\" : $\"{name} t:{typeName}\";\n            var guids = AssetDatabase.FindAssets(query);\n\n            switch (guids.Length)\n            {\n                case 0:\n                    throw new FileNotFoundException($\"Cant locate {typeName} file with the name: {name}\");\n                case > 1:\n                    Debug.LogWarning(\n                        $\"Found more than one {typeName} file with the name: {name}; Loading only the first\");\n                    break;\n            }\n\n            var path = AssetDatabase.GUIDToAssetPath(guids.First());\n\n            var asset = AssetDatabase.LoadAssetAtPath<T>(path);\n", "            if (asset == null)\n            {\n                throw new FileNotFoundException($\"Unable to load the {typeName} with the name {name}\");\n            }\n\n            return asset;\n        }\n\n        public static bool TryFindAssets<T>(out AssetFileInfo[] result, string name = null)\n        {\n            try\n            {\n                result = FindAssets<T>(name);\n                return result.Length > 0;\n            }\n            catch\n            {\n                result = null;\n                return false;\n            }\n        }\n", "        public static bool TryFindAssets<T>(out AssetFileInfo[] result, string name = null)\n        {\n            try\n            {\n                result = FindAssets<T>(name);\n                return result.Length > 0;\n            }\n            catch\n            {\n                result = null;\n                return false;\n            }\n        }\n", "        public static SceneInfo[] FindScenes(string name = null)\n        {\n            var assets = FindAssets<Scene>(name);\n\n            var result = new List<SceneInfo>(assets.Length);\n            var sceneBuildIndexes = Utils.GetSceneBuildIndexes();\n            var assetsInBundles = Utils.GetAssetsInBundles();\n\n            const string packagesPrefix = \"Packages/\";\n\n            foreach (var asset in assets)\n            {", "            foreach (var asset in assets)\n            {\n                if (asset.Path.StartsWith(packagesPrefix))\n                {\n                    continue;\n                }\n                \n                SceneInfo info;\n                \n                if (Utils.IsAssetAddressable(asset.Guid, out var address))\n                {\n                    info = SceneInfo.Create.Addressable(address, asset.Name, asset.Path, asset.Guid, asset.Labels);\n                }", "                if (Utils.IsAssetAddressable(asset.Guid, out var address))\n                {\n                    info = SceneInfo.Create.Addressable(address, asset.Name, asset.Path, asset.Guid, asset.Labels);\n                }\n                else if (Utils.IsAssetInBundle(assetsInBundles, asset.Path, out var bundleName))\n                {\n                    info = SceneInfo.Create.AssetBundle(asset.Name, asset.Path, asset.Guid, bundleName, asset.Labels);\n                }\n                else if (sceneBuildIndexes.ContainsSceneGuid(asset.Guid, out var buildIndex))\n                {\n                    info = SceneInfo.Create.BuiltIn(asset.Name, buildIndex, asset.Path, asset.Guid, asset.Labels);\n                }\n                else\n                {\n                    info = SceneInfo.Create.Default(asset.Name, asset.Path, asset.Guid, asset.Labels);\n                }\n                \n                result.Add(info);\n            }\n\n            return result.ToArray();\n        }\n", "                else if (sceneBuildIndexes.ContainsSceneGuid(asset.Guid, out var buildIndex))\n                {\n                    info = SceneInfo.Create.BuiltIn(asset.Name, buildIndex, asset.Path, asset.Guid, asset.Labels);\n                }\n                else\n                {\n                    info = SceneInfo.Create.Default(asset.Name, asset.Path, asset.Guid, asset.Labels);\n                }\n                \n                result.Add(info);\n            }\n\n            return result.ToArray();\n        }\n", "        public static AssetFileInfo[] FindAssets<T>(string name = null)\n        {\n            var typeName = typeof(T).Name;\n            var query = string.IsNullOrEmpty(name) ? $\"t:{typeName}\" : $\"{name} t:{typeName}\";\n            var guids = AssetDatabase.FindAssets(query);\n\n            if (guids.Length == 0)\n            {\n                return Array.Empty<AssetFileInfo>();\n            }\n\n            var result = new AssetFileInfo[guids.Length];\n", "            for (var i = 0; i < guids.Length; i++)\n            {\n                var guid = guids[i];\n                var path = AssetDatabase.GUIDToAssetPath(guid);\n                var assetName = Path.GetFileNameWithoutExtension(path);\n                var labels = AssetDatabase.GetLabels(new GUID(guid)).ToList();\n                result[i] = new AssetFileInfo(assetName, path, guid, string.Empty, labels);\n            }\n\n            return result;\n        }\n", "        public static void SetLabels<T>(this AssetFileInfo info) where T : Object\n        {\n            var asset = AssetDatabase.LoadAssetAtPath<T>(info.Path);\n            AssetDatabase.SetLabels(asset, info.Labels.ToArray());\n        }\n\n        public static void SetLabel<T>(string path, string label) where T : Object\n        {\n            var asset = AssetDatabase.LoadAssetAtPath<T>(path);\n            var labels = AssetDatabase.GetLabels(asset).ToList();\n", "            if (labels.Contains(label))\n            {\n                return;\n            }\n\n            labels.Add(label);\n            AssetDatabase.SetLabels(asset, labels.ToArray());\n        }\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Common/Utils/Icons.cs", "chunked_list": ["using System;\nusing Sandland.SceneTool.Editor.Common.Data;\nusing UnityEditor;\nusing UnityEngine;\n\nnamespace Sandland.SceneTool.Editor.Common.Utils\n{\n    internal static class Icons\n    {\n        private const string IconsRoot = \"Sandland/Images/\";\n        ", "        private const string IconsRoot = \"Sandland/Images/\";\n        \n        public static Texture2D BrightSceneToolIcon => _brightSceneToolIcon ??=\n            Resources.Load<Texture2D>($\"{IconsRoot}tool_icon_bright\"); \n        public static Texture2D DarkSceneToolIcon => _darkSceneToolIcon ??=\n            Resources.Load<Texture2D>($\"{IconsRoot}tool_icon_dark\");\n        public static Texture2D BrightSceneIcon => _brightSceneIcon ??=\n            Resources.Load<Texture2D>($\"{IconsRoot}scene_icon_bright\"); \n        public static Texture2D DarkSceneIcon => _darkSceneIcon ??=\n            Resources.Load<Texture2D>($\"{IconsRoot}scene_icon_dark\"); \n        ", "        public static Texture2D DarkSceneIcon => _darkSceneIcon ??=\n            Resources.Load<Texture2D>($\"{IconsRoot}scene_icon_dark\"); \n        \n        private static Texture2D _brightSceneToolIcon;\n        private static Texture2D _darkSceneToolIcon;\n        private static Texture2D _brightSceneIcon;\n        private static Texture2D _darkSceneIcon;\n\n        public static Texture2D GetSceneIcon(bool isDarkTheme) => isDarkTheme ? BrightSceneIcon : DarkSceneIcon;\n        public static Texture2D GetSceneToolIcon(bool isDarkTheme) => isDarkTheme ? BrightSceneToolIcon : DarkSceneToolIcon;\n\n    }\n}", "        public static Texture2D GetSceneIcon(bool isDarkTheme) => isDarkTheme ? BrightSceneIcon : DarkSceneIcon;\n        public static Texture2D GetSceneToolIcon(bool isDarkTheme) => isDarkTheme ? BrightSceneToolIcon : DarkSceneToolIcon;\n\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Common/Utils/Utils.cs", "chunked_list": ["using System.Collections.Generic;\nusing System.Linq;\nusing UnityEditor;\nusing UnityEngine;\nusing PackageInfo = UnityEditor.PackageManager.PackageInfo;\n\n#if SANDLAND_ADDRESSABLES\nusing UnityEditor.AddressableAssets;\nusing UnityEditor.AddressableAssets.Settings;\n#endif", "using UnityEditor.AddressableAssets.Settings;\n#endif\n\nnamespace Sandland.SceneTool.Editor.Common.Utils\n{\n    public static class Utils\n    {\n        public static bool IsAddressablesInstalled =>\n            PackageInfo.FindForAssetPath(\"Packages/com.unity.addressables/AddressableAssets\")?.name ==\n            \"com.unity.addressables\";\n", "        public static bool IsAssetAddressable(string guid, out string address)\n        {\n            address = string.Empty;\n\n#if SANDLAND_ADDRESSABLES\n            var settings = AddressableAssetSettingsDefaultObject.Settings;\n\n            if (settings == null)\n            {\n                Debug.LogError(\"Addressable Asset Settings not found.\");\n                return false;\n            }\n", "            if (!string.IsNullOrEmpty(guid))\n            {\n                var entry = settings.FindAssetEntry(guid);\n                address = entry != null ? entry.address : address;\n                return entry != null;\n            }\n\n            Debug.LogError($\"No valid asset path found: {guid}\");\n            return false;\n#else\n            return false;\n#endif\n        }\n", "        public static bool IsAssetInBundle(Dictionary<string, string> assetsInBundles, string assetPath, out string bundleName) \n            => assetsInBundles.TryGetValue(assetPath, out bundleName);\n\n        public static Dictionary<string, string> GetAssetsInBundles() =>\n            AssetDatabase\n                .GetAllAssetBundleNames()\n                .SelectMany(AssetDatabase.GetAssetPathsFromAssetBundle, (bundleName, path) => new { bundleName, path })\n                .ToDictionary(x => x.path, x => x.bundleName);\n\n        public static Dictionary<GUID, int> GetSceneBuildIndexes()\n        {\n            var collection = new Dictionary<GUID, int>();\n            var scenesAmount = EditorBuildSettings.scenes.Length;\n", "        public static Dictionary<GUID, int> GetSceneBuildIndexes()\n        {\n            var collection = new Dictionary<GUID, int>();\n            var scenesAmount = EditorBuildSettings.scenes.Length;\n\n            for (var i = 0; i < scenesAmount; i++)\n            {\n                var scene = EditorBuildSettings.scenes[i];\n                collection.Add(scene.guid, i);\n            }\n\n            return collection;\n        }\n", "        public static bool ContainsSceneGuid(this Dictionary<GUID, int> sceneBuildIndexes, string sceneGuid,\n            out int buildIndex)\n        {\n            buildIndex = -1;\n            var sceneGuidObj = new GUID(sceneGuid);\n\n            var hasScene = sceneBuildIndexes.TryGetValue(sceneGuidObj, out var sceneIndex);\n\n            if (hasScene)\n            {\n                buildIndex = sceneIndex;\n            }\n\n            return hasScene;\n        }\n    }\n}", "            if (hasScene)\n            {\n                buildIndex = sceneIndex;\n            }\n\n            return hasScene;\n        }\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Common/Utils/Extensions.cs", "chunked_list": ["using System;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text.RegularExpressions;\nusing UnityEngine;\n\nnamespace Sandland.SceneTool.Editor.Common.Utils\n{\n    internal static class Extensions\n    {\n        public static string GetRelativePath(this string fullPath) => fullPath.StartsWith(Application.dataPath)\n            ? $\"Assets{fullPath.Substring(Application.dataPath.Length)}\"\n            : string.Empty;\n", "    internal static class Extensions\n    {\n        public static string GetRelativePath(this string fullPath) => fullPath.StartsWith(Application.dataPath)\n            ? $\"Assets{fullPath.Substring(Application.dataPath.Length)}\"\n            : string.Empty;\n\n        public static string ToPascalCase(this string original)\n        {\n            // TODO: optimize this method\n            // Taken from here: https://stackoverflow.com/a/46095771\n\n            var invalidCharsRgx = new Regex(\"[^_a-zA-Z0-9]\");\n            var whiteSpace = new Regex(@\"(?<=\\s)\");\n            var startsWithLowerCaseChar = new Regex(\"^[a-z]\");\n            var firstCharFollowedByUpperCasesOnly = new Regex(\"(?<=[A-Z])[A-Z0-9]+$\");\n            var lowerCaseNextToNumber = new Regex(\"(?<=[0-9])[a-z]\");\n            var upperCaseInside = new Regex(\"(?<=[A-Z])[A-Z]+?((?=[A-Z][a-z])|(?=[0-9]))\");\n\n            // replace white spaces with undescore, then replace all invalid chars with empty string\n            var pascalCase = invalidCharsRgx.Replace(whiteSpace.Replace(original, \"_\"), string.Empty)\n                // split by underscores\n                .Split(new char[] { '_' }, StringSplitOptions.RemoveEmptyEntries)\n                // set first letter to uppercase\n                .Select(w => startsWithLowerCaseChar.Replace(w, m => m.Value.ToUpper()))\n                // replace second and all following upper case letters to lower if there is no next lower (ABC -> Abc)\n                .Select(w => firstCharFollowedByUpperCasesOnly.Replace(w, m => m.Value.ToLower()))\n                // set upper case the first lower case following a number (Ab9cd -> Ab9Cd)\n                .Select(w => lowerCaseNextToNumber.Replace(w, m => m.Value.ToUpper()))\n                // lower second and next upper case letters except the last if it follows by any lower (ABcDEf -> AbcDef)\n                .Select(w => upperCaseInside.Replace(w, m => m.Value.ToLower()));\n\n            return string.Concat(pascalCase);\n        }\n        ", "        public static string ToDescription(this Enum genericEnum)\n        {\n            var genericEnumType = genericEnum.GetType();\n            var memberInfo = genericEnumType.GetMember(genericEnum.ToString());\n            \n            if (memberInfo.Length <= 0)\n            {\n                return genericEnum.ToString();\n            }\n            \n            var attributes = memberInfo[0].GetCustomAttributes(typeof(System.ComponentModel.DescriptionAttribute), false);\n            \n            return attributes.Any() ? ((System.ComponentModel.DescriptionAttribute)attributes.ElementAt(0)).Description : genericEnum.ToString();\n        }\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Common/Utils/DefineUtils.cs", "chunked_list": ["using UnityEditor;\n\nnamespace Sandland.SceneTool.Editor.Common.Utils\n{\n    internal class DefineUtils\n    {\n        public static void AddDefine(string define)\n        {\n            var targetGroup = EditorUserBuildSettings.selectedBuildTargetGroup;\n            var defines = PlayerSettings.GetScriptingDefineSymbolsForGroup(targetGroup);\n", "            if (defines.Contains(define))\n            {\n                return;\n            }\n\n            defines += $\";{define}\";\n            PlayerSettings.SetScriptingDefineSymbolsForGroup(targetGroup, defines);\n        }\n\n        public static void RemoveDefine(string define)\n        {\n            var targetGroup = EditorUserBuildSettings.selectedBuildTargetGroup;\n            var defines = PlayerSettings.GetScriptingDefineSymbolsForGroup(targetGroup);\n", "        public static void RemoveDefine(string define)\n        {\n            var targetGroup = EditorUserBuildSettings.selectedBuildTargetGroup;\n            var defines = PlayerSettings.GetScriptingDefineSymbolsForGroup(targetGroup);\n\n            if (!defines.Contains(define))\n            {\n                return;\n            }\n\n            defines = defines.Replace(define + \";\", string.Empty).Replace(define, string.Empty);\n            PlayerSettings.SetScriptingDefineSymbolsForGroup(targetGroup, defines);\n        }\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Common/Utils/MenuItems.cs", "chunked_list": ["namespace Sandland.SceneTool.Editor.Common.Utils\n{\n    internal static class MenuItems\n    {\n        public static class Tools\n        {\n            public const string Root = \"Tools/Sandland Games/\";\n            public const string Actions = Root + \"Actions/\";\n        }\n\n        public static class Creation\n        {", "        public static class Creation\n        {\n            public const string Root = \"Sandland Games/\";\n        }\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Common/Data/SceneInfo.cs", "chunked_list": ["using System.Collections.Generic;\n\nnamespace Sandland.SceneTool.Editor.Common.Data\n{\n    internal class SceneInfo : AssetFileInfo\n    {\n        public int BuildIndex { get; set; }\n        public string Address { get; set; }\n        public SceneImportType ImportType { get; set; }\n\n        private SceneInfo(string name, string path, string guid, string bundleName, List<string> labels) : base(name, path, guid, bundleName, labels)\n        {\n        }\n", "        public SceneImportType ImportType { get; set; }\n\n        private SceneInfo(string name, string path, string guid, string bundleName, List<string> labels) : base(name, path, guid, bundleName, labels)\n        {\n        }\n\n        public static class Create\n        {\n            public static SceneInfo Addressable(string address, string name = null, string path = null, string guid = null, List<string> labels = null)\n            {\n                return new SceneInfo(name, path, guid, string.Empty, labels)\n                {\n                    ImportType = SceneImportType.Addressables,\n                    Address = address\n                };\n            }\n            ", "            public static SceneInfo Addressable(string address, string name = null, string path = null, string guid = null, List<string> labels = null)\n            {\n                return new SceneInfo(name, path, guid, string.Empty, labels)\n                {\n                    ImportType = SceneImportType.Addressables,\n                    Address = address\n                };\n            }\n            \n            public static SceneInfo AssetBundle(string name, string path, string guid, string bundleName, List<string> labels = null)\n            {\n                return new SceneInfo(name, path, guid, bundleName, labels)\n                {\n                    ImportType = SceneImportType.AssetBundle\n                };\n            }\n            ", "            public static SceneInfo AssetBundle(string name, string path, string guid, string bundleName, List<string> labels = null)\n            {\n                return new SceneInfo(name, path, guid, bundleName, labels)\n                {\n                    ImportType = SceneImportType.AssetBundle\n                };\n            }\n            \n            public static SceneInfo Default(string name, string path, string guid, List<string> labels = null)\n            {\n                return new SceneInfo(name, path, guid, string.Empty, labels)\n                {\n                    ImportType = SceneImportType.None\n                };\n            }\n            ", "            public static SceneInfo Default(string name, string path, string guid, List<string> labels = null)\n            {\n                return new SceneInfo(name, path, guid, string.Empty, labels)\n                {\n                    ImportType = SceneImportType.None\n                };\n            }\n            \n            public static SceneInfo BuiltIn(string name, int buildIndex, string path, string guid, List<string> labels = null)\n            {\n                return new SceneInfo(name, path, guid, string.Empty, labels)\n                {\n                    ImportType = SceneImportType.BuildSettings,\n                    BuildIndex = buildIndex\n                };\n            }\n        }\n    }\n}", "            public static SceneInfo BuiltIn(string name, int buildIndex, string path, string guid, List<string> labels = null)\n            {\n                return new SceneInfo(name, path, guid, string.Empty, labels)\n                {\n                    ImportType = SceneImportType.BuildSettings,\n                    BuildIndex = buildIndex\n                };\n            }\n        }\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Common/Data/AssetFileInfo.cs", "chunked_list": ["using System.Collections.Generic;\n\nnamespace Sandland.SceneTool.Editor.Common.Data\n{\n    internal class AssetFileInfo\n    {\n        public string Name { get; set; }\n        public string Path { get; set; }\n        public string Guid { get; set; }\n        public string BundleName { get; set; }\n        public List<string> Labels { get; set; }\n\n        public AssetFileInfo(string name, string path, string guid, string bundleName, List<string> labels)\n        {\n            Name = name;\n            Path = path;\n            Guid = guid;\n            BundleName = bundleName;\n            Labels = labels;\n        }\n    }\n}", "        public string Guid { get; set; }\n        public string BundleName { get; set; }\n        public List<string> Labels { get; set; }\n\n        public AssetFileInfo(string name, string path, string guid, string bundleName, List<string> labels)\n        {\n            Name = name;\n            Path = path;\n            Guid = guid;\n            BundleName = bundleName;\n            Labels = labels;\n        }\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Common/Data/SceneImportType.cs", "chunked_list": ["using System.ComponentModel;\n\nnamespace Sandland.SceneTool.Editor.Common.Data\n{\n    public enum SceneImportType\n    {\n        [Description(\"Not Used\")]\n        None = 0,\n        [Description(\"In Build Settings\")]\n        BuildSettings = 1,\n        [Description(\"In Addressable Group\")]\n        Addressables = 2,\n        [Description(\"In AssetBundle\")]\n        AssetBundle = 3\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Views/SceneToolsSetupWindow/SceneToolsSetupWindow.cs", "chunked_list": ["using System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Sandland.SceneTool.Editor.Common.Utils;\nusing Sandland.SceneTool.Editor.Views.Base;\nusing Sandland.SceneTool.Editor.Views.Handlers;\nusing UnityEditor;\nusing UnityEngine;\nusing UnityEngine.UIElements;\n\nnamespace Sandland.SceneTool.Editor.Views", "\nnamespace Sandland.SceneTool.Editor.Views\n{\n    internal class SceneToolsSetupWindow : SceneToolsWindowBase\n    {\n        private const string WindowMenuItem = MenuItems.Tools.Root + \"Setup Scene Tools\";\n\n        public override float MinWidth => 600;\n        public override float MinHeight => 600;\n        public override string WindowName => \"Scene Tools Setup\";\n        public override string VisualTreeName => nameof(SceneToolsSetupWindow);", "        public override float MinHeight => 600;\n        public override string WindowName => \"Scene Tools Setup\";\n        public override string VisualTreeName => nameof(SceneToolsSetupWindow);\n        public override string StyleSheetName => nameof(SceneToolsSetupWindow);\n\n        private readonly List<ISceneToolsSetupUiHandler> _uiHandlers = new();\n\n        private Button _saveAllButton;\n\n        [MenuItem(WindowMenuItem, priority = 0)]\n        public static void ShowWindow()\n        {\n            var window = GetWindow<SceneToolsSetupWindow>();\n            window.InitWindow();\n            window.minSize = new Vector2(window.MinWidth, window.MinHeight);\n        }\n", "        public static void ShowWindow()\n        {\n            var window = GetWindow<SceneToolsSetupWindow>();\n            window.InitWindow();\n            window.minSize = new Vector2(window.MinWidth, window.MinHeight);\n        }\n\n        protected override void InitGui()\n        {\n            _uiHandlers.Add(new SceneClassGenerationUiHandler(rootVisualElement));\n            _uiHandlers.Add(new ThemesSelectionUiHandler(rootVisualElement));\n\n            _saveAllButton = rootVisualElement.Q<Button>(\"save-button\");\n\n            _saveAllButton.clicked += OnSaveAllButtonClicked;\n            _uiHandlers.ForEach(handler => handler.SubscribeToEvents());\n        }\n", "        private void OnDestroy()\n        {\n            _saveAllButton.clicked -= OnSaveAllButtonClicked;\n            _uiHandlers.ForEach(handler => handler.UnsubscribeFromEvents());\n        }\n\n        private async void OnSaveAllButtonClicked()\n        {\n            rootVisualElement.SetEnabled(false);\n            _uiHandlers.ForEach(handler => handler.Apply());\n", "            while (EditorApplication.isCompiling)\n            {\n                await Task.Delay(100); // Checking every 100ms\n            }\n\n            rootVisualElement.SetEnabled(true);\n        }\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Views/SceneToolsSetupWindow/Handlers/ThemesSelectionUiHandler.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing Sandland.SceneTool.Editor.Common.Data;\nusing Sandland.SceneTool.Editor.Common.Utils;\nusing Sandland.SceneTool.Editor.Services;\nusing UnityEditor;\nusing UnityEngine;\nusing UnityEngine.UIElements;\n\nnamespace Sandland.SceneTool.Editor.Views.Handlers", "\nnamespace Sandland.SceneTool.Editor.Views.Handlers\n{\n    public class ThemesSelectionUiHandler : ISceneToolsSetupUiHandler\n    {\n        private readonly RadioButtonGroup _root;\n        private readonly ThemeDisplay[] _themeDisplays;\n\n        private string _selectedThemePath;\n        \n        public ThemesSelectionUiHandler(VisualElement root)\n        {\n            _root = root.Q<RadioButtonGroup>(\"theme-selection-group\");\n            var styleSheets = AssetDatabaseUtils.FindAssets<StyleSheet>(\"l:Sandland-theme\");\n            _themeDisplays = new ThemeDisplay[styleSheets.Length];\n            _selectedThemePath = ThemesService.SelectedThemePath;\n", "        private string _selectedThemePath;\n        \n        public ThemesSelectionUiHandler(VisualElement root)\n        {\n            _root = root.Q<RadioButtonGroup>(\"theme-selection-group\");\n            var styleSheets = AssetDatabaseUtils.FindAssets<StyleSheet>(\"l:Sandland-theme\");\n            _themeDisplays = new ThemeDisplay[styleSheets.Length];\n            _selectedThemePath = ThemesService.SelectedThemePath;\n\n            for (var i = 0; i < styleSheets.Length; i++)\n            {\n                var styleSheetInfo = styleSheets[i];\n                \n                var themeDisplay = new ThemeDisplay(styleSheetInfo);\n                _themeDisplays[i] = themeDisplay;\n", "            for (var i = 0; i < styleSheets.Length; i++)\n            {\n                var styleSheetInfo = styleSheets[i];\n                \n                var themeDisplay = new ThemeDisplay(styleSheetInfo);\n                _themeDisplays[i] = themeDisplay;\n\n                if (styleSheetInfo.Path == _selectedThemePath)\n                {\n                    themeDisplay.SetValueWithoutNotify(true);\n                }\n                \n                _root.Add(themeDisplay);\n            }\n        }\n", "        private void OnThemeSelected(AssetFileInfo info)\n        {\n            _selectedThemePath = info.Path;\n        }\n\n        public void SubscribeToEvents()\n        {\n            foreach (var themeDisplay in _themeDisplays)\n            {\n                themeDisplay.Selected += OnThemeSelected;\n            }\n        }\n", "        public void UnsubscribeFromEvents()\n        {\n            foreach (var themeDisplay in _themeDisplays)\n            {\n                themeDisplay.Selected -= OnThemeSelected;\n            }\n        }\n\n        public void Apply()\n        {\n            ThemesService.SelectedThemePath = _selectedThemePath;\n        }\n    }\n}", "        public void Apply()\n        {\n            ThemesService.SelectedThemePath = _selectedThemePath;\n        }\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Views/SceneToolsSetupWindow/Handlers/ISceneToolsSetupUiHandler.cs", "chunked_list": ["using System;\n\nnamespace Sandland.SceneTool.Editor.Views.Handlers\n{\n    internal interface ISceneToolsSetupUiHandler\n    {\n        void SubscribeToEvents();\n        void UnsubscribeFromEvents();\n        void Apply();\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Views/SceneToolsSetupWindow/Handlers/SceneClassGenerationUiHandler.cs", "chunked_list": ["using System.IO;\nusing Sandland.SceneTool.Editor.Common.Utils;\nusing Sandland.SceneTool.Editor.Services;\nusing UnityEditor;\nusing UnityEngine.UIElements;\n\nnamespace Sandland.SceneTool.Editor.Views.Handlers\n{\n    internal class SceneClassGenerationUiHandler : ISceneToolsSetupUiHandler\n    {\n        private const string HiddenContentClass = \"hidden\";", "    internal class SceneClassGenerationUiHandler : ISceneToolsSetupUiHandler\n    {\n        private const string HiddenContentClass = \"hidden\";\n        private const string ScriptDefine = \"SANDLAND_SCENE_CLASS_GEN\";\n        private const string AddressablesSupportDefine = \"SANDLAND_ADDRESSABLES\";\n\n        private readonly Toggle _mainToggle;\n        private readonly Toggle _autogenerateOnChangeToggle;\n        private readonly Toggle _addressableScenesSupportToggle;\n        private readonly VisualElement _section;\n        private readonly TextField _locationText;", "        private readonly Toggle _addressableScenesSupportToggle;\n        private readonly VisualElement _section;\n        private readonly TextField _locationText;\n        private readonly TextField _namespaceText;\n        private readonly TextField _classNameText;\n        private readonly Button _locationButton;\n\n        public SceneClassGenerationUiHandler(VisualElement root)\n        {\n            _mainToggle = root.Q<Toggle>(\"scene-class-generation-toggle\");\n            _autogenerateOnChangeToggle = root.Q<Toggle>(\"scene-class-changes-detection-toggle\");\n            _addressableScenesSupportToggle = root.Q<Toggle>(\"scene-class-addressables-support-toggle\");\n            _section = root.Q<VisualElement>(\"scene-class-generation-block\");\n            _locationText = root.Q<TextField>(\"scene-class-location-text\");\n            _namespaceText = root.Q<TextField>(\"scene-namespace-text\");\n            _classNameText = root.Q<TextField>(\"scene-class-name-text\");\n            _locationButton = root.Q<Button>(\"scene-class-location-button\");\n\n            Init();\n        }\n", "        private void Init()\n        {\n            _locationText.SetEnabled(false);\n            _mainToggle.SetValueWithoutNotify(SceneToolsService.ClassGeneration.IsEnabled);\n            _autogenerateOnChangeToggle.SetValueWithoutNotify(SceneToolsService.ClassGeneration.IsAutoGenerateEnabled);\n            _locationText.SetValueWithoutNotify(SceneToolsService.ClassGeneration.Directory);\n            _namespaceText.SetValueWithoutNotify(SceneToolsService.ClassGeneration.Namespace);\n            _classNameText.SetValueWithoutNotify(SceneToolsService.ClassGeneration.ClassName);\n\n            if (!Utils.IsAddressablesInstalled)\n            {\n                _addressableScenesSupportToggle.SetValueWithoutNotify(false);\n                _addressableScenesSupportToggle.SetEnabled(false);\n            }\n            else\n            {\n                _addressableScenesSupportToggle.SetValueWithoutNotify(SceneToolsService.ClassGeneration.IsAddressablesSupportEnabled);\n            }\n            \n            SetSectionVisibility(_mainToggle.value);\n        }\n", "            if (!Utils.IsAddressablesInstalled)\n            {\n                _addressableScenesSupportToggle.SetValueWithoutNotify(false);\n                _addressableScenesSupportToggle.SetEnabled(false);\n            }\n            else\n            {\n                _addressableScenesSupportToggle.SetValueWithoutNotify(SceneToolsService.ClassGeneration.IsAddressablesSupportEnabled);\n            }\n            \n            SetSectionVisibility(_mainToggle.value);\n        }\n", "        public void SubscribeToEvents()\n        {\n            _locationButton.RegisterCallback<ClickEvent>(OnLocationClicked);\n            _mainToggle.RegisterValueChangedCallback(OnMainToggleChanged);\n        }\n\n        public void UnsubscribeFromEvents()\n        {\n            _locationButton.UnregisterCallback<ClickEvent>(OnLocationClicked);\n            _mainToggle.UnregisterValueChangedCallback(OnMainToggleChanged);\n        }\n", "        public void Apply()\n        {\n            SceneToolsService.ClassGeneration.IsEnabled = _mainToggle.value;\n\n            if (!SceneToolsService.ClassGeneration.IsEnabled)\n            {\n                DefineUtils.RemoveDefine(ScriptDefine);\n                return;\n            }\n\n            DefineUtils.AddDefine(ScriptDefine);\n\n            SceneToolsService.ClassGeneration.IsAddressablesSupportEnabled = _addressableScenesSupportToggle.value;", "            if (SceneToolsService.ClassGeneration.IsAddressablesSupportEnabled)\n            {\n                DefineUtils.AddDefine(AddressablesSupportDefine);\n            }\n            else\n            {\n                DefineUtils.RemoveDefine(AddressablesSupportDefine);\n            }\n\n            SceneToolsService.ClassGeneration.Directory = _locationText.text;\n            SceneToolsService.ClassGeneration.Namespace = _namespaceText.text;\n            SceneToolsService.ClassGeneration.ClassName = _classNameText.text;\n            SceneToolsService.ClassGeneration.IsAutoGenerateEnabled = _autogenerateOnChangeToggle.value;\n", "            if (!AssetDatabase.IsValidFolder(_locationText.text))\n            {\n                Directory.CreateDirectory(_locationText.text);\n            }\n        }\n\n        private void OnMainToggleChanged(ChangeEvent<bool> args)\n        {\n            SetSectionVisibility(args.newValue);\n        }\n", "        private void SetSectionVisibility(bool isVisible)\n        {\n            if (isVisible)\n            {\n                _section.RemoveFromClassList(HiddenContentClass);\n            }\n            else\n            {\n                _section.AddToClassList(HiddenContentClass);\n            }\n        }\n", "        private void OnLocationClicked(ClickEvent args)\n        {\n            var path = EditorUtility.OpenFolderPanel(\"Select Folder\", \"Assets/\", string.Empty);\n            _locationText.SetValueWithoutNotify(path.GetRelativePath());\n        }\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Views/SceneToolsSetupWindow/ThemeDisplay/ThemeDisplay.cs", "chunked_list": ["using System;\nusing Sandland.SceneTool.Editor.Common.Data;\nusing Sandland.SceneTool.Editor.Common.Utils;\nusing UnityEditor;\nusing UnityEngine.UIElements;\n\nnamespace Sandland.SceneTool.Editor.Views\n{\n    internal class ThemeDisplay : RadioButton, IDisposable\n    {\n        public event Action<AssetFileInfo> Selected;\n        ", "    internal class ThemeDisplay : RadioButton, IDisposable\n    {\n        public event Action<AssetFileInfo> Selected;\n        \n        private readonly AssetFileInfo _themeInfo;\n        \n        public ThemeDisplay(AssetFileInfo themeInfo) : base()\n        {\n            _themeInfo = themeInfo;\n            \n            var visualTree = AssetDatabaseUtils.FindAndLoadVisualTreeAsset(nameof(ThemeDisplay));\n            visualTree.CloneTree(this);\n            \n            AddToClassList(\"sandland-theme-button\");\n\n            var mainStyleSheet = AssetDatabaseUtils.FindAndLoadStyleSheet(nameof(ThemeDisplay));\n            var styleSheet = AssetDatabase.LoadAssetAtPath<StyleSheet>(themeInfo.Path);\n            \n            styleSheets.Add(mainStyleSheet);\n            styleSheets.Add(styleSheet);\n            \n            label = themeInfo.Name;\n\n            this.RegisterValueChangedCallback(OnValueChanged);\n        }\n", "        private void OnValueChanged(ChangeEvent<bool> evt)\n        {\n            if (!evt.newValue)\n            {\n                return;\n            }\n\n            Selected?.Invoke(_themeInfo);\n        }\n\n        public void Dispose()\n        {\n            this.UnregisterValueChangedCallback(OnValueChanged);\n        }\n    }\n}", "        public void Dispose()\n        {\n            this.UnregisterValueChangedCallback(OnValueChanged);\n        }\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Views/Base/SceneToolsWindowBase.cs", "chunked_list": ["using Sandland.SceneTool.Editor.Common.Utils;\nusing Sandland.SceneTool.Editor.Services;\nusing UnityEditor;\nusing UnityEngine;\nusing UnityEngine.UIElements;\n\nnamespace Sandland.SceneTool.Editor.Views.Base\n{\n    internal abstract class SceneToolsWindowBase : EditorWindow\n    {\n        private const string GlobalStyleSheetName = \"SceneToolsMain\";\n", "    internal abstract class SceneToolsWindowBase : EditorWindow\n    {\n        private const string GlobalStyleSheetName = \"SceneToolsMain\";\n\n        public abstract float MinWidth { get; }\n        public abstract float MinHeight { get; }\n        public abstract string WindowName { get; }\n        public abstract string VisualTreeName { get; }\n        public abstract string StyleSheetName { get; }\n\n        private StyleSheet _theme;\n\n", "        public abstract string StyleSheetName { get; }\n\n        private StyleSheet _theme;\n\n\n        protected void InitWindow(Texture2D overrideIcon = null)\n        {\n            minSize = new Vector2(MinWidth, MinHeight);\n            // TODO: support dynamic theme\n            titleContent = new GUIContent(WindowName, overrideIcon ? overrideIcon : Icons.GetSceneToolIcon(true));\n", "            if (docked)\n            {\n                return;\n            }\n\n            var editorPos = EditorGUIUtility.GetMainWindowPosition();\n            var x = editorPos.x + editorPos.width * 0.5f - MinWidth * 0.5f;\n            var y = editorPos.y + editorPos.height * 0.5f - MinHeight * 0.5f;\n\n            position = new Rect(x, y, MinWidth, MinHeight);\n        }\n\n", "        public virtual void CreateGUI()\n        {\n            var visualTree = AssetDatabaseUtils.FindAndLoadVisualTreeAsset(VisualTreeName);\n            visualTree.CloneTree(rootVisualElement);\n\n            _theme = ThemesService.GetSelectedTheme();\n            \n            var globalStyleSheet = AssetDatabaseUtils.FindAndLoadStyleSheet(GlobalStyleSheetName);\n            var styleSheet = AssetDatabaseUtils.FindAndLoadStyleSheet(StyleSheetName);\n            \n            rootVisualElement.styleSheets.Add(_theme);\n            rootVisualElement.styleSheets.Add(globalStyleSheet);\n            rootVisualElement.styleSheets.Add(styleSheet);\n            InitGui();\n        }\n", "        protected virtual void OnEnable()\n        {\n            ThemesService.ThemeChanged += RefreshTheme;\n        }\n\n        protected virtual void OnDisable()\n        {\n            ThemesService.ThemeChanged -= RefreshTheme;\n        }\n\n        protected abstract void InitGui();\n", "        protected abstract void InitGui();\n\n        protected void RefreshTheme(StyleSheet theme)\n        {\n            if (_theme == theme)\n            {\n                return;\n            }\n            \n            if(_theme != null)\n            {\n                rootVisualElement.styleSheets.Remove(_theme);\n            }\n\n            _theme = theme;\n            rootVisualElement.styleSheets.Add(_theme);\n        }\n    }\n}", "            if(_theme != null)\n            {\n                rootVisualElement.styleSheets.Remove(_theme);\n            }\n\n            _theme = theme;\n            rootVisualElement.styleSheets.Add(_theme);\n        }\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Views/SceneSelectorWindow/SceneSelectorWindow.cs", "chunked_list": ["using System.Linq;\nusing Sandland.SceneTool.Editor.Common.Data;\nusing Sandland.SceneTool.Editor.Common.Utils;\nusing Sandland.SceneTool.Editor.Services;\nusing Sandland.SceneTool.Editor.Views.Base;\nusing UnityEditor;\nusing UnityEngine;\nusing UnityEngine.UIElements;\n\nnamespace Sandland.SceneTool.Editor.Views", "\nnamespace Sandland.SceneTool.Editor.Views\n{\n    internal class SceneSelectorWindow : SceneToolsWindowBase\n    {\n        private const string WindowNameInternal = \"Scene Selector\";\n        private const string KeyboardShortcut = \" %g\";\n        private const string WindowMenuItem = MenuItems.Tools.Root + WindowNameInternal + KeyboardShortcut;\n\n        public override float MinWidth => 460;\n        public override float MinHeight => 600;", "        public override float MinWidth => 460;\n        public override float MinHeight => 600;\n        public override string WindowName => WindowNameInternal;\n        public override string VisualTreeName => nameof(SceneSelectorWindow);\n        public override string StyleSheetName => nameof(SceneSelectorWindow);\n\n\n        private SceneInfo[] _sceneInfos;\n        private SceneInfo[] _filteredSceneInfos;\n\n        private ListView _sceneList;", "        private ListView _sceneList;\n        private TextField _searchField;\n\n        [MenuItem(WindowMenuItem)]\n        public static void ShowWindow()\n        {\n            var window = GetWindow<SceneSelectorWindow>();\n            window.InitWindow();\n            window._searchField?.Focus();\n        }\n", "        protected override void OnEnable()\n        {\n            base.OnEnable();\n            FavoritesService.FavoritesChanged += OnFavoritesChanged;\n        }\n\n        protected override void OnDisable()\n        {\n            base.OnDisable();\n            FavoritesService.FavoritesChanged -= OnFavoritesChanged;\n        }\n", "        protected override void InitGui()\n        {\n            _sceneInfos = AssetDatabaseUtils.FindScenes();\n            _filteredSceneInfos = GetFilteredSceneInfos();\n\n            _sceneList = rootVisualElement.Q<ListView>(\"scenes-list\");\n            _sceneList.makeItem = () => new SceneItemView();\n            _sceneList.bindItem = InitListItem;\n            _sceneList.fixedItemHeight = SceneItemView.FixedHeight;\n            _sceneList.itemsSource = _filteredSceneInfos;\n\n            _searchField = rootVisualElement.Q<TextField>(\"scenes-search\");\n            _searchField.RegisterValueChangedCallback(OnSearchValueChanged);\n            _searchField.Focus();\n            _searchField.SelectAll();\n        }\n", "        private void OnSearchValueChanged(ChangeEvent<string> @event) => RebuildItems(@event.newValue);\n\n        private void OnFavoritesChanged() => RebuildItems();\n\n        private void RebuildItems(string filter = null)\n        {\n            _filteredSceneInfos = GetFilteredSceneInfos(filter);\n            _sceneList.itemsSource = _filteredSceneInfos;\n            _sceneList.Rebuild();\n        }\n\n        private SceneInfo[] GetFilteredSceneInfos(string filter = null)\n        {\n            var isFilterEmpty = string.IsNullOrWhiteSpace(filter);\n            \n            return _sceneInfos\n                .Where(s => isFilterEmpty || s.Name.ToUpper().Contains(filter.ToUpper()))\n                .OrderByFavorites()\n                .ThenByDescending(s => s.ImportType == SceneImportType.BuildSettings)\n                .ThenByDescending(s => s.ImportType == SceneImportType.Addressables)\n                .ThenByDescending(s => s.ImportType == SceneImportType.AssetBundle)\n                .ToArray();\n        }\n", "        private void InitListItem(VisualElement element, int dataIndex)\n        {\n            var sceneView = (SceneItemView)element;\n            sceneView.Init(_filteredSceneInfos[dataIndex]);\n        }\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Views/SceneSelectorWindow/SceneListItem/SceneItemView.cs", "chunked_list": ["using System;\nusing Sandland.SceneTool.Editor.Common.Data;\nusing Sandland.SceneTool.Editor.Common.Utils;\nusing UnityEditor;\nusing UnityEditor.SceneManagement;\nusing UnityEngine;\nusing UnityEngine.UIElements;\n\nnamespace Sandland.SceneTool.Editor.Views\n{\n    internal class SceneItemView : VisualElement, IDisposable\n    {", "namespace Sandland.SceneTool.Editor.Views\n{\n    internal class SceneItemView : VisualElement, IDisposable\n    {\n        public const float FixedHeight = 100;\n        \n        private readonly Image _iconImage;\n        private readonly FavoritesButton _favoritesButton;\n        private readonly Label _button;\n        private readonly Label _typeLabel;\n        private readonly VisualElement _textWrapper;", "        private readonly Label _button;\n        private readonly Label _typeLabel;\n        private readonly VisualElement _textWrapper;\n        private readonly Clickable _clickManipulator;\n\n        private AssetFileInfo _sceneInfo;\n\n        public SceneItemView()\n        {\n            var visualTree = AssetDatabaseUtils.FindAndLoadVisualTreeAsset(\"SceneItemView\");\n            visualTree.CloneTree(this);\n\n            _iconImage = this.Q<Image>(\"scene-icon\");\n            _button = this.Q<Label>(\"scene-button\");\n            _favoritesButton = this.Q<FavoritesButton>(\"favorites-button\");\n            _typeLabel = this.Q<Label>(\"scene-type-label\");\n            _textWrapper = this.Q<VisualElement>(\"scene-text-wrapper\");\n\n            _clickManipulator = new Clickable(OnOpenSceneButtonClicked);\n            _textWrapper.AddManipulator(_clickManipulator);\n            \n            RegisterCallback<DetachFromPanelEvent>(OnDetachFromPanel);\n\n            _iconImage.AddManipulator(new Clickable(OnIconClick));\n        }\n", "        private void OnIconClick()\n        {\n            Selection.activeObject = AssetDatabase.LoadAssetAtPath<SceneAsset>(_sceneInfo.Path);\n        }\n\n        public void Init(SceneInfo info)\n        {\n            _sceneInfo = info;\n            _button.text = _sceneInfo.Name;\n            _favoritesButton.Init(_sceneInfo);\n            _typeLabel.text = info.ImportType.ToDescription();\n\n            // TODO: Support dynamic themes\n            _iconImage.image = Icons.GetSceneIcon(true);\n\n            ResetInlineStyles();\n        }\n", "        private void ResetInlineStyles()\n        {\n            // ListView sets inline attributes that we want to control from UCSS\n            style.height = StyleKeyword.Null;\n            style.flexGrow = StyleKeyword.Null;\n            style.flexShrink = StyleKeyword.Null;\n            style.marginBottom = StyleKeyword.Null;\n            style.marginTop = StyleKeyword.Null;\n            style.paddingBottom = StyleKeyword.Null;\n        }\n", "        private void OnOpenSceneButtonClicked()\n        {\n            EditorSceneManager.OpenScene(_sceneInfo.Path);\n        }\n\n        private void OnDetachFromPanel(DetachFromPanelEvent evt)\n        {\n            Dispose();\n        }\n\n        public void Dispose()\n        {\n            UnregisterCallback<DetachFromPanelEvent>(OnDetachFromPanel);\n        }\n    }\n}", "        public void Dispose()\n        {\n            UnregisterCallback<DetachFromPanelEvent>(OnDetachFromPanel);\n        }\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Views/SceneSelectorWindow/FavoritesButton/FavoritesButton.cs", "chunked_list": ["using Sandland.SceneTool.Editor.Common.Data;\nusing Sandland.SceneTool.Editor.Common.Utils;\nusing Sandland.SceneTool.Editor.Services;\nusing UnityEditor;\nusing UnityEngine;\nusing UnityEngine.UIElements;\n\nnamespace Sandland.SceneTool.Editor.Views\n{\n    internal class FavoritesButton : VisualElement\n    {", "{\n    internal class FavoritesButton : VisualElement\n    {\n        private const string FavoriteClassName = \"favorite\";\n        \n        public bool IsFavorite { get; private set; }\n\n        //private Image _starImage;\n        private AssetFileInfo _fileInfo;\n\n        public FavoritesButton()\n        {\n            this.AddManipulator(new Clickable(OnClick));\n        }\n", "        private AssetFileInfo _fileInfo;\n\n        public FavoritesButton()\n        {\n            this.AddManipulator(new Clickable(OnClick));\n        }\n\n        public void Init(AssetFileInfo info)\n        {\n            _fileInfo = info;\n            var isFavorite = _fileInfo.IsFavorite();\n            SetState(isFavorite);\n        }\n\n", "        private void OnClick()\n        {\n            SetState(!IsFavorite);\n\n            if (IsFavorite)\n            {\n                _fileInfo.AddToFavorites();\n            }\n            else\n            {\n                _fileInfo.RemoveFromFavorites();\n            }\n        }\n", "        public void SetState(bool isFavorite)\n        {\n            IsFavorite = isFavorite;\n            \n            if (IsFavorite)\n            {\n                AddToClassList(FavoriteClassName);\n            }\n            else\n            {\n                RemoveFromClassList(FavoriteClassName);\n            }\n        }\n", "        public new class UxmlFactory : UxmlFactory<FavoritesButton, UxmlTraits>\n        {\n        }\n    }\n}"]}
{"filename": "Assets/SceneTools/Editor/Listeners/SceneClassGenerationListener.cs", "chunked_list": ["#if SANDLAND_SCENE_CLASS_GEN\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Sandland.SceneTool.Editor.Common.Data;\nusing Sandland.SceneTool.Editor.Common.Utils;\nusing Sandland.SceneTool.Editor.Services;\nusing UnityEditor;\n\n#if SANDLAND_ADDRESSABLES", "\n#if SANDLAND_ADDRESSABLES\nusing UnityEditor.AddressableAssets;\nusing UnityEditor.AddressableAssets.Settings;\n#endif\n\nnamespace Sandland.SceneTool.Editor.Listeners\n{\n    internal static class SceneClassGenerationListener\n    {\n        [InitializeOnLoadMethod]", "    internal static class SceneClassGenerationListener\n    {\n        [InitializeOnLoadMethod]\n        private static void Initialize()\n        {\n            EditorBuildSettings.sceneListChanged += GenerateScenesClass;\n\n#if SANDLAND_ADDRESSABLES\n            AddressableAssetSettings.OnModificationGlobal += OnAddressablesModification;\n#endif\n        }\n\n\n#if SANDLAND_ADDRESSABLES", "        private static void OnAddressablesModification(AddressableAssetSettings settings,\n            AddressableAssetSettings.ModificationEvent args, object obj)\n        {\n            switch (obj)\n            {\n                case AddressableAssetEntry entry:\n                {\n                    var shouldGenerate = IsShouldGenerateClass(args, entry);\n                    if (shouldGenerate)\n                    {\n                        GenerateScenesClass();\n                    }\n\n                    break;\n                }\n                case IList<AddressableAssetEntry> entries:\n                {", "                    if (shouldGenerate)\n                    {\n                        GenerateScenesClass();\n                    }\n\n                    break;\n                }\n                case IList<AddressableAssetEntry> entries:\n                {\n                    foreach (var e in entries)\n                    {\n                        var shouldGenerate = IsShouldGenerateClass(args, e);", "                    foreach (var e in entries)\n                    {\n                        var shouldGenerate = IsShouldGenerateClass(args, e);\n                        if (shouldGenerate)\n                        {\n                            GenerateScenesClass();\n                        }\n                    }\n\n                    break;\n                }\n            }\n        }\n", "        private static bool IsShouldGenerateClass(AddressableAssetSettings.ModificationEvent evt,\n            AddressableAssetEntry entry)\n        {\n            var assetPath = entry.AssetPath;\n            var assetType = AssetDatabase.GetMainAssetTypeAtPath(assetPath);\n\n            if (assetType != typeof(SceneAsset))\n            {\n                return false;\n            }\n\n            return evt is AddressableAssetSettings.ModificationEvent.BatchModification\n                       or AddressableAssetSettings.ModificationEvent.EntryModified ||\n                   EditorBuildSettings.scenes.All(s => s.path != assetPath);\n        }\n#endif\n\n        [MenuItem(MenuItems.Tools.Actions + \"Generate Scenes Class\")]", "        private static void GenerateScenesClass()\n        {\n            if (!SceneToolsService.ClassGeneration.IsAutoGenerateEnabled)\n            {\n                return;\n            }\n\n            var scenes = new List<SceneInfo>();\n\n            for (var i = 0; i < EditorBuildSettings.scenes.Length; i++)\n            {\n                var sceneAsset = EditorBuildSettings.scenes[i];\n                var name = Path.GetFileNameWithoutExtension(sceneAsset.path);\n                var info = SceneInfo.Create.BuiltIn(name, i, null, null);\n                scenes.Add(info);\n            }\n\n#if SANDLAND_ADDRESSABLES\n\n            var addressableScenes = AddressableAssetSettingsDefaultObject.Settings.groups.SelectMany(g => g.entries)\n                .Where(e => EditorUtility.IsPersistent(e.MainAsset) && e.MainAsset is SceneAsset)\n                .Select(e => SceneInfo.Create.Addressable(e.address, e.address))\n                .ToList();\n\n            scenes.AddRange(addressableScenes);\n#endif\n\n            SceneToolsService.ClassGeneration.CreateFile(scenes);\n        }\n    }\n}\n\n#endif", "            for (var i = 0; i < EditorBuildSettings.scenes.Length; i++)\n            {\n                var sceneAsset = EditorBuildSettings.scenes[i];\n                var name = Path.GetFileNameWithoutExtension(sceneAsset.path);\n                var info = SceneInfo.Create.BuiltIn(name, i, null, null);\n                scenes.Add(info);\n            }\n\n#if SANDLAND_ADDRESSABLES\n\n            var addressableScenes = AddressableAssetSettingsDefaultObject.Settings.groups.SelectMany(g => g.entries)\n                .Where(e => EditorUtility.IsPersistent(e.MainAsset) && e.MainAsset is SceneAsset)\n                .Select(e => SceneInfo.Create.Addressable(e.address, e.address))\n                .ToList();\n\n            scenes.AddRange(addressableScenes);\n#endif\n\n            SceneToolsService.ClassGeneration.CreateFile(scenes);\n        }\n    }\n}\n\n#endif"]}
{"filename": "Assets/Sandland/Runtime/SceneList.cs", "chunked_list": ["namespace WordsDuel.Core.Logic.Utils\n{\n\tpublic class Scenes\n\t{\n\t\tpublic class Names\n\t\t{\n\t\t\tpublic const string SampleScene = \"SampleScene\";\n\t\t\tpublic const string YetAnotherScene = \"YetAnother Scene\";\n\t\t}\n\n\t\tpublic class Indexes\n\t\t{", "\t\tpublic class Indexes\n\t\t{\n\t\t\tpublic const int SampleScene = 0;\n\t\t\tpublic const int YetAnotherScene = 1;\n\t\t}\n\n\t\tpublic class Addressables\n\t\t{\n\t\t\tpublic const string SampleScene = \"Assets/Scenes/SampleScene.d\";\n\t\t}\n\t}\n}\n", "\t\t\tpublic const string SampleScene = \"Assets/Scenes/SampleScene.d\";\n\t\t}\n\t}\n}\n"]}
