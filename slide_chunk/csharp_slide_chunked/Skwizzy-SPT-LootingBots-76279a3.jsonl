{"filename": "LootingBots/LootingLayer.cs", "chunked_list": ["using System;\nusing System.Text;\n\nusing DrakiaXYZ.BigBrain.Brains;\n\nusing EFT;\n\nusing LootingBots.Brain.Logics;\nusing LootingBots.Patch.Components;\n", "using LootingBots.Patch.Components;\n\nusing UnityEngine;\n\nnamespace LootingBots.Brain\n{\n    internal class LootingLayer : CustomLayer\n    {\n        private readonly LootingBrain _lootingBrain;\n        private float _scanTimer;\n", "        private readonly LootingBrain _lootingBrain;\n        private float _scanTimer;\n\n        private bool IsScheduledScan\n        {\n            get { return _scanTimer < Time.time && _lootingBrain.WaitAfterLootTimer < Time.time; }\n        }\n\n        public LootingLayer(BotOwner botOwner, int priority)\n            : base(botOwner, priority)\n        {\n            LootingBrain lootingBrain = botOwner.GetPlayer.gameObject.AddComponent<LootingBrain>();\n            lootingBrain.Init(botOwner);\n            _lootingBrain = lootingBrain;\n        }\n", "        public override string GetName()\n        {\n            return \"Looting\";\n        }\n\n        public override bool IsActive()\n        {\n            bool isBotActive = BotOwner.BotState == EBotState.Active;\n            bool hasAvailableSlots = _lootingBrain.Stats.AvailableGridSpaces > 0;\n            return isBotActive\n                && hasAvailableSlots\n                && (IsScheduledScan || _lootingBrain.IsBotLooting);\n        }\n", "        public override void Start()\n        {\n            _lootingBrain.EnableTransactions();\n            base.Start();\n        }\n\n        public override void Stop()\n        {\n            _lootingBrain.DisableTransactions();\n            base.Stop();\n        }\n", "        public override Action GetNextAction()\n        {\n            if (_lootingBrain.IsBotLooting)\n            {\n                return new Action(typeof(LootingLogic), \"Looting\");\n            }\n\n            if (IsScheduledScan)\n            {\n                _scanTimer = Time.time + 6f;\n                return new Action(typeof(FindLootLogic), \"Loot Scan\");\n            }\n\n            return new Action(typeof(PeacefulLogic), \"Peaceful\");\n        }\n", "        public override bool IsCurrentActionEnding()\n        {\n            Type currentActionType = CurrentAction?.Type;\n\n            if (currentActionType == typeof(FindLootLogic))\n            {\n                return _lootingBrain.HasActiveLootable();\n            }\n\n            return !_lootingBrain.IsBotLooting;\n        }\n", "        public override void BuildDebugText(StringBuilder debugPanel)\n        {\n            string itemName = _lootingBrain.ActiveItem?.Name?.Localized();\n            string containerName = _lootingBrain.ActiveContainer?.name?.Localized();\n            string corpseName = _lootingBrain.ActiveCorpse?.name?.Localized();\n            string lootableName = itemName ?? containerName ?? corpseName ?? \"-\";\n\n            string category = \"\";\n            if (itemName != null)\n            {\n                category = \"Item\";\n            }", "            if (itemName != null)\n            {\n                category = \"Item\";\n            }\n            else if (containerName != null)\n            {\n                category = \"Container\";\n            }\n            else if (corpseName != null)\n            {\n                category = \"Corpse\";\n            }\n\n            debugPanel.AppendLine(\n                _lootingBrain.LootTaskRunning ? \"Looting in progress...\" : \"\",\n                Color.green\n            );\n            debugPanel.AppendLabeledValue(\n                $\"Target Loot\",\n                $\" {lootableName} ({category})\",\n                Color.yellow,\n                Color.yellow\n            );\n\n            debugPanel.AppendLabeledValue(\n                $\"Distance to Loot\",\n                $\" {(category == \"\" ? \"-\" : Math.Sqrt(_lootingBrain.DistanceToLoot).ToString(\"0.##\"))}m\",\n                Color.grey,\n                Color.grey\n            );\n\n            _lootingBrain.Stats.StatsDebugPanel(debugPanel);\n        }\n", "            else if (corpseName != null)\n            {\n                category = \"Corpse\";\n            }\n\n            debugPanel.AppendLine(\n                _lootingBrain.LootTaskRunning ? \"Looting in progress...\" : \"\",\n                Color.green\n            );\n            debugPanel.AppendLabeledValue(\n                $\"Target Loot\",\n                $\" {lootableName} ({category})\",\n                Color.yellow,\n                Color.yellow\n            );\n\n            debugPanel.AppendLabeledValue(\n                $\"Distance to Loot\",\n                $\" {(category == \"\" ? \"-\" : Math.Sqrt(_lootingBrain.DistanceToLoot).ToString(\"0.##\"))}m\",\n                Color.grey,\n                Color.grey\n            );\n\n            _lootingBrain.Stats.StatsDebugPanel(debugPanel);\n        }\n", "        public bool EndLooting()\n        {\n            return _lootingBrain.ActiveContainer == null\n                && _lootingBrain.ActiveCorpse == null\n                && _lootingBrain.ActiveItem == null;\n        }\n    }\n}\n"]}
{"filename": "LootingBots/LootingBots.cs", "chunked_list": ["using BepInEx;\nusing BepInEx.Configuration;\n\nusing Comfort.Common;\n\nusing EFT;\n\nusing LootingBots.Patch.Components;\nusing LootingBots.Patch.Util;\nusing LootingBots.Patch;", "using LootingBots.Patch.Util;\nusing LootingBots.Patch;\nusing LootingBots.Brain;\n\nusing DrakiaXYZ.BigBrain.Brains;\nusing System.Collections.Generic;\n\nusing HandbookClass = GClass2775;\n\nnamespace LootingBots", "\nnamespace LootingBots\n{\n    [BepInPlugin(MOD_GUID, MOD_NAME, MOD_VERSION)]\n    [BepInDependency(\"xyz.drakia.bigbrain\", \"0.1.4\")]\n    [BepInProcess(\"EscapeFromTarkov.exe\")]\n    public class LootingBots : BaseUnityPlugin\n    {\n        private const string MOD_GUID = \"me.skwizzy.lootingbots\";\n        private const string MOD_NAME = \"LootingBots\";\n        private const string MOD_VERSION = \"1.1.2\";\n", "        private const string MOD_GUID = \"me.skwizzy.lootingbots\";\n        private const string MOD_NAME = \"LootingBots\";\n        private const string MOD_VERSION = \"1.1.2\";\n\n        public const BotType SettingsDefaults = BotType.Scav | BotType.Pmc | BotType.Raider;\n\n        // Loot Finder Settings\n        public static ConfigEntry<BotType> CorpseLootingEnabled;\n        public static ConfigEntry<BotType> ContainerLootingEnabled;\n        public static ConfigEntry<BotType> LooseItemLootingEnabled;\n", "        public static ConfigEntry<BotType> ContainerLootingEnabled;\n        public static ConfigEntry<BotType> LooseItemLootingEnabled;\n\n        public static ConfigEntry<float> TimeToWaitBetweenLoot;\n        public static ConfigEntry<float> DetectItemDistance;\n        public static ConfigEntry<float> DetectContainerDistance;\n        public static ConfigEntry<float> DetectCorpseDistance;\n\n        public static ConfigEntry<bool> DebugLootNavigation;\n        public static ConfigEntry<LogLevel> LootingLogLevels;\n        public static Log LootLog;\n\n        // Loot Settings", "        public static ConfigEntry<bool> DebugLootNavigation;\n        public static ConfigEntry<LogLevel> LootingLogLevels;\n        public static Log LootLog;\n\n        // Loot Settings\n        public static ConfigEntry<bool> UseMarketPrices;\n        public static ConfigEntry<bool> ValueFromMods;\n        public static ConfigEntry<bool> CanStripAttachments;\n        public static ConfigEntry<float> PMCLootThreshold;\n        public static ConfigEntry<float> ScavLootThreshold;\n        public static ConfigEntry<EquipmentType> PMCGearToEquip;", "        public static ConfigEntry<float> PMCLootThreshold;\n        public static ConfigEntry<float> ScavLootThreshold;\n        public static ConfigEntry<EquipmentType> PMCGearToEquip;\n        public static ConfigEntry<EquipmentType> PMCGearToPickup;\n        public static ConfigEntry<EquipmentType> ScavGearToEquip;\n        public static ConfigEntry<EquipmentType> ScavGearToPickup;\n\n        public static ConfigEntry<LogLevel> ItemAppraiserLogLevels;\n        public static Log ItemAppraiserLog;\n        public static ItemAppraiser ItemAppraiser = new ItemAppraiser();\n", "        public static Log ItemAppraiserLog;\n        public static ItemAppraiser ItemAppraiser = new ItemAppraiser();\n\n        public void LootFinderSettings()\n        {\n            CorpseLootingEnabled = Config.Bind(\n                \"Loot Finder\",\n                \"Enable corpse looting\",\n                SettingsDefaults,\n                new ConfigDescription(\n                    \"Enables corpse looting for the selected bot types\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 10 }\n                )\n            );\n            DetectCorpseDistance = Config.Bind(\n                \"Loot Finder\",\n                \"Detect corpse distance\",\n                75f,\n                new ConfigDescription(\n                    \"Distance (in meters) a bot is able to detect a corpse\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 9 }\n                )\n            );\n            ContainerLootingEnabled = Config.Bind(\n                \"Loot Finder\",\n                \"Enable container looting\",\n                SettingsDefaults,\n                new ConfigDescription(\n                    \"Enables container looting for the selected bot types\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 8 }\n                )\n            );\n            DetectContainerDistance = Config.Bind(\n                \"Loot Finder\",\n                \"Detect container distance\",\n                75f,\n                new ConfigDescription(\n                    \"Distance (in meters) a bot is able to detect a container\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 7 }\n                )\n            );\n            LooseItemLootingEnabled = Config.Bind(\n                \"Loot Finder\",\n                \"Enable loose item looting\",\n                SettingsDefaults,\n                new ConfigDescription(\n                    \"Enables loose item looting for the selected bot types\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 6 }\n                )\n            );\n            DetectItemDistance = Config.Bind(\n                \"Loot Finder\",\n                \"Detect item distance\",\n                75f,\n                new ConfigDescription(\n                    \"Distance (in meters) a bot is able to detect an item\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 5 }\n                )\n            );\n            TimeToWaitBetweenLoot = Config.Bind(\n                \"Loot Finder\",\n                \"Delay between looting\",\n                15f,\n                new ConfigDescription(\n                    \"The amount of time the bot will wait after looting an container/item/corpse before trying to find the next nearest item/container/corpse\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 2 }\n                )\n            );\n            LootingLogLevels = Config.Bind(\n                \"Loot Finder\",\n                \"Log Levels\",\n                LogLevel.Error | LogLevel.Info,\n                new ConfigDescription(\n                    \"Enable different levels of log messages to show in the logs\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 1 }\n                )\n            );\n            DebugLootNavigation = Config.Bind(\n                \"Loot Finder\",\n                \"Debug: Show navigation points\",\n                false,\n                new ConfigDescription(\n                    \"Renders shperes where bots are trying to navigate when container looting. (Red): Container position. (Black): 'Optimized' container position. (Green): Calculated bot destination. (Blue): NavMesh corrected destination (where the bot will move).\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 0 }\n                )\n            );\n        }\n", "        public void LootSettings()\n        {\n            UseMarketPrices = Config.Bind(\n                \"Loot Settings\",\n                \"Use flea market prices\",\n                false,\n                new ConfigDescription(\n                    \"Bots will query more accurate ragfair prices to do item value checks. Will make a query to get ragfair prices when the client is first started\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 10 }\n                )\n            );\n            ValueFromMods = Config.Bind(\n                \"Loot Settings\",\n                \"Calculate weapon value from attachments\",\n                true,\n                new ConfigDescription(\n                    \"Calculate weapon value by looking up each attachement. More accurate than just looking at the base weapon template but a slightly more expensive check\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 9 }\n                )\n            );\n            CanStripAttachments = Config.Bind(\n                \"Loot Settings\",\n                \"Allow weapon attachment stripping\",\n                true,\n                new ConfigDescription(\n                    \"Allows bots to take the attachments off of a weapon if they are not able to pick the weapon up into their inventory\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 8 }\n                )\n            );\n            PMCLootThreshold = Config.Bind(\n                \"Loot Settings\",\n                \"PMC: Loot value threshold\",\n                12000f,\n                new ConfigDescription(\n                    \"PMC bots will only loot items that exceed the specified value in roubles\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 6 }\n                )\n            );\n            PMCGearToEquip = Config.Bind(\n                \"Loot Settings\",\n                \"PMC: Allowed gear to equip\",\n                EquipmentType.All,\n                new ConfigDescription(\n                    \"The equipment a PMC bot is able to equip during raid\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 5 }\n                )\n            );\n            PMCGearToPickup = Config.Bind(\n                \"Loot Settings\",\n                \"PMC: Allowed gear in bags\",\n                EquipmentType.All,\n                new ConfigDescription(\n                    \"The equipment a PMC bot is able to place in their backpack/rig\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 4 }\n                )\n            );\n            ScavLootThreshold = Config.Bind(\n                \"Loot Settings\",\n                \"Scav: Loot value threshold\",\n                5000f,\n                new ConfigDescription(\n                    \"All non-PMC bots will only loot items that exceed the specified value in roubles.\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 3 }\n                )\n            );\n            ScavGearToEquip = Config.Bind(\n                \"Loot Settings\",\n                \"Scav: Allowed gear to equip\",\n                EquipmentType.All,\n                new ConfigDescription(\n                    \"The equipment a non-PMC bot is able to equip during raid\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 2 }\n                )\n            );\n            ScavGearToPickup = Config.Bind(\n                \"Loot Settings\",\n                \"Scav: Allowed gear in bags\",\n                EquipmentType.All,\n                new ConfigDescription(\n                    \"The equipment a non-PMC bot is able to place in their backpack/rig\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 1 }\n                )\n            );\n\n            ItemAppraiserLogLevels = Config.Bind(\n                \"Loot Settings\",\n                \"Log Levels\",\n                LogLevel.Error,\n                new ConfigDescription(\n                    \"Enables logs for the item apprasier that calcualtes the weapon values\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 0 }\n                )\n            );\n        }\n", "        public void Awake()\n        {\n            LootFinderSettings();\n            LootSettings();\n\n            LootLog = new Log(Logger, LootingLogLevels);\n            ItemAppraiserLog = new Log(Logger, ItemAppraiserLogLevels);\n\n            new SettingsAndCachePatch().Enable();\n            new RemoveComponent().Enable();\n\n            BrainManager.RemoveLayer(\n                \"Utility peace\",\n                new List<string>()\n                {\n                    \"Assault\",\n                    \"ExUsec\",\n                    \"BossSanitar\",\n                    \"CursAssault\",\n                    \"PMC\",\n                    \"SectantWarrior\"\n                }\n            );\n            BrainManager.AddCustomLayer(\n                typeof(LootingLayer),\n                new List<string>()\n                {\n                    \"Assault\",\n                    \"BossSanitar\",\n                    \"CursAssault\",\n                    \"BossKojaniy\",\n                    \"SectantPriest\",\n                    \"FollowerGluharScout\",\n                    \"FollowerGluharProtect\",\n                    \"FollowerGluharAssault\",\n                    \"BossGluhar\",\n                    \"Fl_Zraychiy\",\n                    \"TagillaFollower\",\n                    \"FollowerSanitar\",\n                    \"FollowerBully\",\n                    \"BirdEye\",\n                    \"BigPipe\",\n                    \"Knight\",\n                    \"BossZryachiy\",\n                    \"Tagilla\",\n                    \"Killa\",\n                    \"BossSanitar\",\n                    \"BossBully\"\n                },\n                2\n            );\n            BrainManager.AddCustomLayer(\n                typeof(LootingLayer),\n                new List<string>() { \"PMC\", \"ExUsec\" },\n                3\n            );\n            BrainManager.AddCustomLayer(\n                typeof(LootingLayer),\n                new List<string>() { \"SectantWarrior\" },\n                13\n            );\n        }\n", "        public void Update()\n        {\n            bool shoultInitAppraiser =\n                (!UseMarketPrices.Value && ItemAppraiser.HandbookData == null)\n                || (UseMarketPrices.Value && !ItemAppraiser.MarketInitialized);\n\n            // Initialize the itemAppraiser when the BE instance comes online\n            if (\n                Singleton<ClientApplication<ISession>>.Instance != null\n                && Singleton<HandbookClass>.Instance != null\n                && shoultInitAppraiser\n            )\n            {\n                LootLog.LogInfo($\"Initializing item appraiser\");\n                ItemAppraiser.Init();\n            }\n        }\n    }\n}\n"]}
{"filename": "LootingBots/ConfigurationManagerAttributes.cs", "chunked_list": ["\ufeff/// <summary>\n/// Class that specifies how a setting should be displayed inside the ConfigurationManager settings window.\n/// \n/// Usage:\n/// This class template has to be copied inside the plugin's project and referenced by its code directly.\n/// make a new instance, assign any fields that you want to override, and pass it as a tag for your setting.\n/// \n/// If a field is null (default), it will be ignored and won't change how the setting is displayed.\n/// If a field is non-null (you assigned a value to it), it will override default behavior.\n/// </summary>\n/// \n/// <example> \n/// Here's an example of overriding order of settings and marking one of the settings as advanced:\n/// <code>\n/// // Override IsAdvanced and Order\n/// Config.AddSetting(\"X\", \"1\", 1, new ConfigDescription(\"\", null, new ConfigurationManagerAttributes { IsAdvanced = true, Order = 3 }));\n/// // Override only Order, IsAdvanced stays as the default value assigned by ConfigManager\n/// Config.AddSetting(\"X\", \"2\", 2, new ConfigDescription(\"\", null, new ConfigurationManagerAttributes { Order = 1 }));\n/// Config.AddSetting(\"X\", \"3\", 3, new ConfigDescription(\"\", null, new ConfigurationManagerAttributes { Order = 2 }));\n/// </code>\n/// </example>\n/// \n/// <remarks> \n/// You can read more and see examples in the readme at https://github.com/BepInEx/BepInEx.ConfigurationManager\n/// You can optionally remove fields that you won't use from this class, it's the same as leaving them null.\n/// </remarks>\n#pragma warning disable 0169, 0414, 0649", "internal sealed class ConfigurationManagerAttributes\n{\n    /// <summary>\n    /// Should the setting be shown as a percentage (only use with value range settings).\n    /// </summary>\n    public bool? ShowRangeAsPercent;\n\n    /// <summary>\n    /// Custom setting editor (OnGUI code that replaces the default editor provided by ConfigurationManager).\n    /// See below for a deeper explanation. Using a custom drawer will cause many of the other fields to do nothing.\n    /// </summary>\n    public System.Action<BepInEx.Configuration.ConfigEntryBase> CustomDrawer;\n\n    /// <summary>\n    /// Show this setting in the settings screen at all? If false, don't show.\n    /// </summary>\n    public bool? Browsable;\n\n    /// <summary>\n    /// Category the setting is under. Null to be directly under the plugin.\n    /// </summary>", "    public string Category;\n\n    /// <summary>\n    /// If set, a \"Default\" button will be shown next to the setting to allow resetting to default.\n    /// </summary>\n    public object DefaultValue;\n\n    /// <summary>\n    /// Force the \"Reset\" button to not be displayed, even if a valid DefaultValue is available. \n    /// </summary>\n    public bool? HideDefaultButton;\n\n    /// <summary>\n    /// Force the setting name to not be displayed. Should only be used with a <see cref=\"CustomDrawer\"/> to get more space.\n    /// Can be used together with <see cref=\"HideDefaultButton\"/> to gain even more space.\n    /// </summary>\n    public bool? HideSettingName;\n\n    /// <summary>\n    /// Optional description shown when hovering over the setting.\n    /// Not recommended, provide the description when creating the setting instead.\n    /// </summary>", "    public string Description;\n\n    /// <summary>\n    /// Name of the setting.\n    /// </summary>\n    public string DispName;\n\n    /// <summary>\n    /// Order of the setting on the settings list relative to other settings in a category.\n    /// 0 by default, higher number is higher on the list.\n    /// </summary>\n    public int? Order;\n\n    /// <summary>\n    /// Only show the value, don't allow editing it.\n    /// </summary>\n    public bool? ReadOnly;\n\n    /// <summary>\n    /// If true, don't show the setting by default. User has to turn on showing advanced settings or search for it.\n    /// </summary>\n    public bool? IsAdvanced;\n\n    /// <summary>\n    /// Custom converter from setting type to string for the built-in editor textboxes.\n    /// </summary>\n    public System.Func<object, string> ObjToStr;\n\n    /// <summary>\n    /// Custom converter from string to setting type for the built-in editor textboxes.\n    /// </summary>\n    public System.Func<string, object> StrToObj;\n}"]}
{"filename": "LootingBots/components/ItemAppraiser.cs", "chunked_list": ["using System.Collections.Generic;\nusing System.Linq;\n\nusing Comfort.Common;\n\nusing EFT;\nusing EFT.HandBook;\nusing EFT.InventoryLogic;\n\nusing LootingBots.Patch.Util;", "\nusing LootingBots.Patch.Util;\n\nusing HandbookClass = GClass2775;\n\nnamespace LootingBots.Patch.Components\n{\n    public class ItemAppraiser\n    {\n        public Log Log;\n        public Dictionary<string, EFT.HandBook.HandbookData> HandbookData;\n        public Dictionary<string, float> MarketData;\n", "        public Log Log;\n        public Dictionary<string, EFT.HandBook.HandbookData> HandbookData;\n        public Dictionary<string, float> MarketData;\n\n        public bool MarketInitialized = false;\n\n        public void Init()\n        {\n            Log = LootingBots.ItemAppraiserLog;\n\n            if (LootingBots.UseMarketPrices.Value)\n            {\n                // Initialize ragfair prices from the BE session\n                Singleton<ClientApplication<ISession>>.Instance\n                    .GetClientBackEndSession()\n                    .RagfairGetPrices(\n                        new Callback<Dictionary<string, float>>(\n                            (Result<Dictionary<string, float>> result) => MarketData = result.Value\n                        )\n                    );\n                MarketInitialized = true;\n            }\n            else\n            {\n                // This is the handbook instance which is initialized when the client first starts.\n                HandbookData = Singleton<HandbookClass>.Instance.Items.ToDictionary((item) => item.Id);\n            }\n        }\n\n        /** Will either get the lootItem's price using the ragfair service or the handbook depending on the option selected in the mod menu. If the item is a weapon, will calculate its value based off its attachments if the mod setting is enabled */", "            if (LootingBots.UseMarketPrices.Value)\n            {\n                // Initialize ragfair prices from the BE session\n                Singleton<ClientApplication<ISession>>.Instance\n                    .GetClientBackEndSession()\n                    .RagfairGetPrices(\n                        new Callback<Dictionary<string, float>>(\n                            (Result<Dictionary<string, float>> result) => MarketData = result.Value\n                        )\n                    );\n                MarketInitialized = true;\n            }\n            else\n            {\n                // This is the handbook instance which is initialized when the client first starts.\n                HandbookData = Singleton<HandbookClass>.Instance.Items.ToDictionary((item) => item.Id);\n            }\n        }\n\n        /** Will either get the lootItem's price using the ragfair service or the handbook depending on the option selected in the mod menu. If the item is a weapon, will calculate its value based off its attachments if the mod setting is enabled */", "        public float GetItemPrice(Item lootItem)\n        {\n            bool valueFromMods = LootingBots.ValueFromMods.Value;\n            if (LootingBots.UseMarketPrices.Value && MarketData != null)\n            {\n                return lootItem is Weapon && valueFromMods\n                    ? GetWeaponMarketPrice(lootItem as Weapon)\n                    : GetItemMarketPrice(lootItem);\n            }\n\n            if (HandbookData != null)\n            {\n                return lootItem is Weapon && valueFromMods\n                    ? GetWeaponHandbookPrice(lootItem as Weapon)\n                    : GetItemHandbookPrice(lootItem);\n            }\n\n            Log.LogDebug($\"ItemAppraiser data is null\");\n\n            return 0;\n        }\n        \n        /**\n        * Get the price of a weapon from the sum of its attachments mods, using the default handbook prices to appraise each mod.\n        */", "            if (HandbookData != null)\n            {\n                return lootItem is Weapon && valueFromMods\n                    ? GetWeaponHandbookPrice(lootItem as Weapon)\n                    : GetItemHandbookPrice(lootItem);\n            }\n\n            Log.LogDebug($\"ItemAppraiser data is null\");\n\n            return 0;\n        }\n        \n        /**\n        * Get the price of a weapon from the sum of its attachments mods, using the default handbook prices to appraise each mod.\n        */", "        public float GetWeaponHandbookPrice(Weapon lootWeapon)\n        {\n            Log.LogDebug($\"Getting value of attachments for {lootWeapon.Name.Localized()}\");\n            float finalPrice = lootWeapon.Mods.Aggregate(\n                0f,\n                (price, mod) => price += GetItemHandbookPrice(mod)\n            );\n            Log.LogDebug(\n                $\"Final price of attachments: {finalPrice} compared to full item {GetItemHandbookPrice(lootWeapon)}\"\n            );\n\n            return finalPrice;\n        }\n\n        /** Gets the price of the item as stated from the beSession handbook values */", "        public float GetItemHandbookPrice(Item lootItem)\n        {\n            HandbookData.TryGetValue(lootItem.TemplateId, out HandbookData value);\n            float price = value?.Price ?? 0;\n            Log.LogDebug($\"Price of {lootItem.Name.Localized()} is {price}\");\n            return price;\n        }\n\n        /**\n        * Get the price of a weapon from the sum of its attachments mods, using the ragfair prices to appraise each mod.\n        */", "        public float GetWeaponMarketPrice(Weapon lootWeapon)\n        {\n            Log.LogDebug($\"Getting value of attachments for {lootWeapon.Name.Localized()}\");\n            float finalPrice = lootWeapon.Mods.Aggregate(\n                0f,\n                (price, mod) => price += GetItemMarketPrice(mod)\n            );\n            Log.LogDebug(\n                $\"Final price of attachments: {finalPrice} compared to item template {GetItemMarketPrice(lootWeapon)}\"\n            );\n\n            return finalPrice;\n        }\n\n        /** Gets the price of the item as stated from the ragfair values */", "        public float GetItemMarketPrice(Item lootItem)\n        {\n            float price = MarketData[lootItem.TemplateId];\n            Log.LogDebug($\"Price of {lootItem.Name.Localized()} is {price}\");\n\n            return price;\n        }\n    }\n}\n"]}
{"filename": "LootingBots/components/InventoryController.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\nusing System.Threading.Tasks;\n\nusing Comfort.Common;\n\nusing EFT;", "\nusing EFT;\nusing EFT.InventoryLogic;\n\nusing LootingBots.Patch.Util;\n\nusing UnityEngine;\n\nnamespace LootingBots.Patch.Components\n{\n    public class GearValue\n    {", "namespace LootingBots.Patch.Components\n{\n    public class GearValue\n    {\n        public ValuePair Primary = new ValuePair(\"\", 0);\n        public ValuePair Secondary = new ValuePair(\"\", 0);\n        public ValuePair Holster = new ValuePair(\"\", 0);\n    }\n\n    public class ValuePair\n    {", "    public class ValuePair\n    {\n        public string Id;\n        public float Value = 0;\n\n        public ValuePair(string id, float value)\n        {\n            Id = id;\n            Value = value;\n        }\n    }\n", "    public class BotStats\n    {\n        public float NetLootValue;\n        public int AvailableGridSpaces;\n        public int TotalGridSpaces;\n\n        public GearValue WeaponValues = new GearValue();\n\n        public void AddNetValue(float itemPrice)\n        {\n            NetLootValue += itemPrice;\n        }\n", "        public void AddNetValue(float itemPrice)\n        {\n            NetLootValue += itemPrice;\n        }\n\n        public void SubtractNetValue(float itemPrice)\n        {\n            NetLootValue += itemPrice;\n        }\n\n        public void StatsDebugPanel(StringBuilder debugPanel)\n        {\n            Color freeSpaceColor =\n                AvailableGridSpaces == 0\n                    ? Color.red\n                    : AvailableGridSpaces < TotalGridSpaces / 2\n                        ? Color.yellow\n                        : Color.green;\n\n            debugPanel.AppendLabeledValue(\n                $\"Total looted value\",\n                $\" {NetLootValue:n0}\u20bd\",\n                Color.white,\n                Color.white\n            );\n            debugPanel.AppendLabeledValue(\n                $\"Available space\",\n                $\" {AvailableGridSpaces} slots\",\n                Color.white,\n                freeSpaceColor\n            );\n        }\n    }\n", "        public void StatsDebugPanel(StringBuilder debugPanel)\n        {\n            Color freeSpaceColor =\n                AvailableGridSpaces == 0\n                    ? Color.red\n                    : AvailableGridSpaces < TotalGridSpaces / 2\n                        ? Color.yellow\n                        : Color.green;\n\n            debugPanel.AppendLabeledValue(\n                $\"Total looted value\",\n                $\" {NetLootValue:n0}\u20bd\",\n                Color.white,\n                Color.white\n            );\n            debugPanel.AppendLabeledValue(\n                $\"Available space\",\n                $\" {AvailableGridSpaces} slots\",\n                Color.white,\n                freeSpaceColor\n            );\n        }\n    }\n", "    public class InventoryController\n    {\n        private readonly BotLog _log;\n        private readonly TransactionController _transactionController;\n        private readonly BotOwner _botOwner;\n        private readonly InventoryControllerClass _botInventoryController;\n        private readonly LootingBrain _lootingBrain;\n        private readonly ItemAppraiser _itemAppraiser;\n        private readonly bool _isBoss;\n\n        public BotStats Stats = new BotStats();\n", "        private readonly bool _isBoss;\n\n        public BotStats Stats = new BotStats();\n\n        private static readonly GearValue GearValue = new GearValue();\n\n        // Represents the highest equipped armor class of the bot either from the armor vest or tac vest\n        public int CurrentBodyArmorClass = 0;\n\n        // Represents the value in roubles of the current item\n        public float CurrentItemPrice = 0f;\n", "        public float CurrentItemPrice = 0f;\n\n        public bool ShouldSort = true;\n\n        public InventoryController(BotOwner botOwner, LootingBrain lootingBrain)\n        {\n            try\n            {\n                _log = new BotLog(LootingBots.LootLog, botOwner);\n                _lootingBrain = lootingBrain;\n                _isBoss = LootUtils.IsBoss(botOwner);\n                _itemAppraiser = LootingBots.ItemAppraiser;\n\n                // Initialize bot inventory controller\n                Type botOwnerType = botOwner.GetPlayer.GetType();\n                FieldInfo botInventory = botOwnerType.BaseType.GetField(\n                    \"_inventoryController\",\n                    BindingFlags.NonPublic\n                        | BindingFlags.Static\n                        | BindingFlags.Public\n                        | BindingFlags.Instance\n                );\n\n                _botOwner = botOwner;\n                _botInventoryController = (InventoryControllerClass)\n                    botInventory.GetValue(botOwner.GetPlayer);\n                _transactionController = new TransactionController(\n                    _botOwner,\n                    _botInventoryController,\n                    _log\n                );\n\n                // Initialize current armor classs\n                Item chest = _botInventoryController.Inventory.Equipment\n                    .GetSlot(EquipmentSlot.ArmorVest)\n                    .ContainedItem;\n                SearchableItemClass tacVest = (SearchableItemClass)\n                    _botInventoryController.Inventory.Equipment\n                        .GetSlot(EquipmentSlot.TacticalVest)\n                        .ContainedItem;\n                ArmorComponent currentArmor = chest?.GetItemComponent<ArmorComponent>();\n                ArmorComponent currentVest = tacVest?.GetItemComponent<ArmorComponent>();\n                CurrentBodyArmorClass = currentArmor?.ArmorClass ?? currentVest?.ArmorClass ?? 0;\n\n                CalculateGearValue();\n                UpdateGridStats();\n            }", "            catch (Exception e)\n            {\n                _log.LogError(e);\n            }\n        }\n\n        /**\n        * Disable the tranaction controller to ensure transactions do not occur when the looting layer is interrupted\n        */\n        public void DisableTransactions()\n        {\n            _transactionController.Enabled = false;\n        }\n\n        /**\n        * Used to enable the transaction controller when the looting layer is active\n        */", "        public void DisableTransactions()\n        {\n            _transactionController.Enabled = false;\n        }\n\n        /**\n        * Used to enable the transaction controller when the looting layer is active\n        */\n        public void EnableTransactions()\n        {\n            _transactionController.Enabled = true;\n        }\n\n        /**\n        * Calculates the value of the bot's current weapons to use in weapon swap comparison checks\n        */", "        public void EnableTransactions()\n        {\n            _transactionController.Enabled = true;\n        }\n\n        /**\n        * Calculates the value of the bot's current weapons to use in weapon swap comparison checks\n        */\n        public void CalculateGearValue()\n        {\n            _log.LogDebug(\"Calculating gear value...\");\n            Item primary = _botInventoryController.Inventory.Equipment\n                .GetSlot(EquipmentSlot.FirstPrimaryWeapon)\n                .ContainedItem;\n            Item secondary = _botInventoryController.Inventory.Equipment\n                .GetSlot(EquipmentSlot.SecondPrimaryWeapon)\n                .ContainedItem;\n            Item holster = _botInventoryController.Inventory.Equipment\n                .GetSlot(EquipmentSlot.Holster)\n                .ContainedItem;\n", "        public void CalculateGearValue()\n        {\n            _log.LogDebug(\"Calculating gear value...\");\n            Item primary = _botInventoryController.Inventory.Equipment\n                .GetSlot(EquipmentSlot.FirstPrimaryWeapon)\n                .ContainedItem;\n            Item secondary = _botInventoryController.Inventory.Equipment\n                .GetSlot(EquipmentSlot.SecondPrimaryWeapon)\n                .ContainedItem;\n            Item holster = _botInventoryController.Inventory.Equipment\n                .GetSlot(EquipmentSlot.Holster)\n                .ContainedItem;\n", "            if (primary != null && GearValue.Primary.Id != primary.Id)\n            {\n                float value = _itemAppraiser.GetItemPrice(primary);\n                GearValue.Primary = new ValuePair(primary.Id, value);\n            }\n            if (secondary != null && GearValue.Secondary.Id != secondary.Id)\n            {\n                float value = _itemAppraiser.GetItemPrice(secondary);\n                GearValue.Secondary = new ValuePair(secondary.Id, value);\n            }\n            if (holster != null && GearValue.Holster.Id != holster.Id)\n            {\n                float value = _itemAppraiser.GetItemPrice(holster);\n                GearValue.Holster = new ValuePair(holster.Id, value);\n            }\n        }\n\n        /**\n        * Updates stats for AvailableGridSpaces and TotalGridSpaces based off the bots current gear\n        */", "            if (holster != null && GearValue.Holster.Id != holster.Id)\n            {\n                float value = _itemAppraiser.GetItemPrice(holster);\n                GearValue.Holster = new ValuePair(holster.Id, value);\n            }\n        }\n\n        /**\n        * Updates stats for AvailableGridSpaces and TotalGridSpaces based off the bots current gear\n        */\n        public void UpdateGridStats()\n        {\n            SearchableItemClass tacVest = (SearchableItemClass)\n                _botInventoryController.Inventory.Equipment\n                    .GetSlot(EquipmentSlot.TacticalVest)\n                    .ContainedItem;\n            SearchableItemClass backpack = (SearchableItemClass)\n                _botInventoryController.Inventory.Equipment\n                    .GetSlot(EquipmentSlot.Backpack)\n                    .ContainedItem;\n            SearchableItemClass pockets = (SearchableItemClass)\n                _botInventoryController.Inventory.Equipment\n                    .GetSlot(EquipmentSlot.Pockets)\n                    .ContainedItem;\n\n            int freePockets = LootUtils.GetAvailableGridSlots(pockets?.Grids);\n            int freeTacVest = LootUtils.GetAvailableGridSlots(tacVest?.Grids);\n            int freeBackpack = LootUtils.GetAvailableGridSlots(backpack?.Grids);\n\n            Stats.AvailableGridSpaces = freeBackpack + freePockets + freeTacVest;\n            Stats.TotalGridSpaces =\n                (tacVest?.Grids?.Length ?? 0)\n                + (backpack?.Grids?.Length ?? 0)\n                + (pockets?.Grids?.Length ?? 0);\n        }\n\n        /**\n        * Sorts the items in the tactical vest so that items prefer to be in slots that match their size. I.E a 1x1 item will be placed in a 1x1 slot instead of a 1x2 slot\n        */", "        public void UpdateGridStats()\n        {\n            SearchableItemClass tacVest = (SearchableItemClass)\n                _botInventoryController.Inventory.Equipment\n                    .GetSlot(EquipmentSlot.TacticalVest)\n                    .ContainedItem;\n            SearchableItemClass backpack = (SearchableItemClass)\n                _botInventoryController.Inventory.Equipment\n                    .GetSlot(EquipmentSlot.Backpack)\n                    .ContainedItem;\n            SearchableItemClass pockets = (SearchableItemClass)\n                _botInventoryController.Inventory.Equipment\n                    .GetSlot(EquipmentSlot.Pockets)\n                    .ContainedItem;\n\n            int freePockets = LootUtils.GetAvailableGridSlots(pockets?.Grids);\n            int freeTacVest = LootUtils.GetAvailableGridSlots(tacVest?.Grids);\n            int freeBackpack = LootUtils.GetAvailableGridSlots(backpack?.Grids);\n\n            Stats.AvailableGridSpaces = freeBackpack + freePockets + freeTacVest;\n            Stats.TotalGridSpaces =\n                (tacVest?.Grids?.Length ?? 0)\n                + (backpack?.Grids?.Length ?? 0)\n                + (pockets?.Grids?.Length ?? 0);\n        }\n\n        /**\n        * Sorts the items in the tactical vest so that items prefer to be in slots that match their size. I.E a 1x1 item will be placed in a 1x1 slot instead of a 1x2 slot\n        */", "        public async Task<IResult> SortTacVest()\n        {\n            SearchableItemClass tacVest = (SearchableItemClass)\n                _botInventoryController.Inventory.Equipment\n                    .GetSlot(EquipmentSlot.TacticalVest)\n                    .ContainedItem;\n\n            ShouldSort = false;\n\n            if (tacVest != null)\n            {\n                var result = LootUtils.SortContainer(tacVest, _botInventoryController);\n", "            if (tacVest != null)\n            {\n                var result = LootUtils.SortContainer(tacVest, _botInventoryController);\n\n                if (result.Succeeded)\n                {\n                    return await _transactionController.TryRunNetworkTransaction(result);\n                }\n            }\n\n            return null;\n        }\n\n        /**\n        * Main driving method which kicks off the logic for what a bot will do with the loot found.\n        * If bots are looting something that is equippable and they have nothing equipped in that slot, they will always equip it.\n        * If the bot decides not to equip the item then it will attempt to put in an available container slot\n        */", "        public async Task<bool> TryAddItemsToBot(Item[] items)\n        {\n            foreach (Item item in items)\n            {\n                if (_transactionController.IsLootingInterrupted())\n                {\n                    UpdateKnownItems();\n                    return false;\n                }\n\n                if (item != null && item.Name != null)\n                {\n                    CurrentItemPrice = _itemAppraiser.GetItemPrice(item);\n                    _log.LogInfo($\"Loot found: {item.Name.Localized()} ({CurrentItemPrice}\u20bd)\");", "                if (item != null && item.Name != null)\n                {\n                    CurrentItemPrice = _itemAppraiser.GetItemPrice(item);\n                    _log.LogInfo($\"Loot found: {item.Name.Localized()} ({CurrentItemPrice}\u20bd)\");\n                    if (item is MagazineClass mag && !CanUseMag(mag))\n                    {\n                        _log.LogDebug($\"Cannot use mag: {item.Name.Localized()}. Skipping\");\n                        continue;\n                    }\n\n                    // Check to see if we need to swap gear\n                    TransactionController.EquipAction action = GetEquipAction(item);", "                    if (action.Swap != null)\n                    {\n                        await _transactionController.ThrowAndEquip(action.Swap);\n                        continue;\n                    }\n                    else if (action.Move != null)\n                    {\n                        _log.LogDebug(\"Moving due to GetEquipAction\");\n                        if (await _transactionController.MoveItem(action.Move))\n                        {\n                            Stats.AddNetValue(CurrentItemPrice);\n                        }\n                        continue;\n                    }\n\n                    // Check to see if we can equip the item\n                    bool ableToEquip =\n                        AllowedToEquip(item) && await _transactionController.TryEquipItem(item);\n", "                        if (await _transactionController.MoveItem(action.Move))\n                        {\n                            Stats.AddNetValue(CurrentItemPrice);\n                        }\n                        continue;\n                    }\n\n                    // Check to see if we can equip the item\n                    bool ableToEquip =\n                        AllowedToEquip(item) && await _transactionController.TryEquipItem(item);\n", "                    if (ableToEquip)\n                    {\n                        Stats.AddNetValue(CurrentItemPrice);\n                        continue;\n                    }\n\n                    // If the item we are trying to pickup is a weapon, we need to perform the \"pickup\" action before trying to strip the weapon of its mods. This is to\n                    // prevent stripping the mods from a weapon and then picking up the weapon afterwards.\n                    if (item is Weapon weapon)\n                    {\n                        bool ableToPickUp =\n                            AllowedToPickup(weapon)\n                            && await _transactionController.TryPickupItem(weapon);\n", "                    if (item is Weapon weapon)\n                    {\n                        bool ableToPickUp =\n                            AllowedToPickup(weapon)\n                            && await _transactionController.TryPickupItem(weapon);\n\n                        if (ableToPickUp)\n                        {\n                            Stats.AddNetValue(CurrentItemPrice);\n                            continue;\n                        }\n", "                        if (LootingBots.CanStripAttachments.Value)\n                        {\n                            // Strip the weapon of its mods if we cannot pickup the weapon\n                            bool success = await TryAddItemsToBot(\n                                weapon.Mods.Where(mod => !mod.IsUnremovable).ToArray()\n                            );\n\n                            if (!success)\n                            {\n                                UpdateKnownItems();\n                                return success;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        // Try to pick up any nested items before trying to pick up the item. This helps when looting rigs to transfer ammo to the bots active rig\n                        bool success = await LootNestedItems(item);\n", "                        if (!success)\n                        {\n                            UpdateKnownItems();\n                            return success;\n                        }\n\n                        // Check to see if we can pick up the item\n                        bool ableToPickUp =\n                            AllowedToPickup(item)\n                            && await _transactionController.TryPickupItem(item);\n", "                        if (ableToPickUp)\n                        {\n                            Stats.AddNetValue(CurrentItemPrice);\n                            continue;\n                        }\n                    }\n                }\n                else\n                {\n                    _log.LogDebug(\"Item was null\");\n                }\n            }\n\n            // Refresh bot's known items dictionary\n            UpdateKnownItems();\n\n            return true;\n        }\n\n        /**\n        * Method to make the bot change to its primary weapon. Useful for making sure bots have their weapon out after they have swapped weapons.\n        */", "        public void ChangeToPrimary()\n        {\n            if (_botOwner != null && _botOwner.WeaponManager?.Selector != null)\n            {\n                _log.LogWarning($\"Changing to primary\");\n                _botOwner.WeaponManager.UpdateWeaponsList();\n                _botOwner.WeaponManager.Selector.ChangeToMain();\n                RefillAndReload();\n            }\n        }\n\n        /**\n        * Updates the bot's known weapon list and tells the bot to switch to its main weapon\n        */", "        public void UpdateActiveWeapon()\n        {\n            if (_botOwner != null && _botOwner.WeaponManager?.Selector != null)\n            {\n                _log.LogWarning($\"Updating weapons\");\n                _botOwner.WeaponManager.UpdateWeaponsList();\n                _botOwner.WeaponManager.Selector.TakeMainWeapon();\n                RefillAndReload();\n            }\n        }\n\n        /**\n        * Method to refill magazines with ammo and also reload the current weapon with a new magazine\n        */", "        private void RefillAndReload()\n        {\n            if (_botOwner != null && _botOwner.WeaponManager?.Selector != null)\n            {\n                _botOwner.WeaponManager.Reload.TryFillMagazines();\n                _botOwner.WeaponManager.Reload.TryReload();\n            }\n        }\n\n        /** Marks all items placed in rig/pockets/backpack as known items that they are able to use */\n        public void UpdateKnownItems()\n        {\n            // Protection against bot death interruption", "        public void UpdateKnownItems()\n        {\n            // Protection against bot death interruption\n            if (_botOwner != null && _botInventoryController != null)\n            {\n                SearchableItemClass tacVest = (SearchableItemClass)\n                    _botInventoryController.Inventory.Equipment\n                        .GetSlot(EquipmentSlot.TacticalVest)\n                        .ContainedItem;\n                SearchableItemClass backpack = (SearchableItemClass)\n                    _botInventoryController.Inventory.Equipment\n                        .GetSlot(EquipmentSlot.Backpack)\n                        .ContainedItem;\n                SearchableItemClass pockets = (SearchableItemClass)\n                    _botInventoryController.Inventory.Equipment\n                        .GetSlot(EquipmentSlot.Pockets)\n                        .ContainedItem;\n                SearchableItemClass secureContainer = (SearchableItemClass)\n                    _botInventoryController.Inventory.Equipment\n                        .GetSlot(EquipmentSlot.SecuredContainer)\n                        .ContainedItem;\n\n                tacVest?.UncoverAll(_botOwner.ProfileId);\n                backpack?.UncoverAll(_botOwner.ProfileId);\n                pockets?.UncoverAll(_botOwner.ProfileId);\n                secureContainer?.UncoverAll(_botOwner.ProfileId);\n            }\n        }\n\n        /**\n        * Checks certain slots to see if the item we are looting is \"better\" than what is currently equipped. View shouldSwapGear for criteria.\n        * Gear is checked in a specific order so that bots will try to swap gear that is a \"container\" first like backpacks and tacVests to make sure\n        * they arent putting loot in an item they will ultimately decide to drop\n        */\n        public TransactionController.EquipAction GetEquipAction(Item lootItem)\n        {\n            Item helmet = _botInventoryController.Inventory.Equipment\n                .GetSlot(EquipmentSlot.Headwear)\n                .ContainedItem;\n            Item chest = _botInventoryController.Inventory.Equipment\n                .GetSlot(EquipmentSlot.ArmorVest)\n                .ContainedItem;\n            Item tacVest = _botInventoryController.Inventory.Equipment\n                .GetSlot(EquipmentSlot.TacticalVest)\n                .ContainedItem;\n            Item backpack = _botInventoryController.Inventory.Equipment\n                .GetSlot(EquipmentSlot.Backpack)\n                .ContainedItem;\n\n            string lootID = lootItem?.Parent?.Container?.ID;\n            TransactionController.EquipAction action = new TransactionController.EquipAction();\n            TransactionController.SwapAction swapAction = null;\n", "            if (!AllowedToEquip(lootItem))\n            {\n                return action;\n            }\n\n            if (lootItem.Template is WeaponTemplate && !_isBoss)\n            {\n                return GetWeaponEquipAction(lootItem as Weapon);\n            }\n\n            if (backpack?.Parent?.Container.ID == lootID && ShouldSwapGear(backpack, lootItem))\n            {\n                swapAction = GetSwapAction(backpack, lootItem, null, true);\n            }", "            if (backpack?.Parent?.Container.ID == lootID && ShouldSwapGear(backpack, lootItem))\n            {\n                swapAction = GetSwapAction(backpack, lootItem, null, true);\n            }\n            else if (helmet?.Parent?.Container?.ID == lootID && ShouldSwapGear(helmet, lootItem))\n            {\n                swapAction = GetSwapAction(helmet, lootItem);\n            }\n            else if (chest?.Parent?.Container?.ID == lootID && ShouldSwapGear(chest, lootItem))\n            {\n                swapAction = GetSwapAction(chest, lootItem);\n            }", "            else if (chest?.Parent?.Container?.ID == lootID && ShouldSwapGear(chest, lootItem))\n            {\n                swapAction = GetSwapAction(chest, lootItem);\n            }\n            else if (tacVest?.Parent?.Container?.ID == lootID && ShouldSwapGear(tacVest, lootItem))\n            {\n                // If the tac vest we are looting is higher armor class and we have a chest equipped, make sure to drop the chest and pick up the armored rig\n                if (IsLootingBetterArmor(tacVest, lootItem) && chest != null)\n                {\n                    _log.LogDebug(\"Looting armored rig and dropping chest\");\n                    swapAction = GetSwapAction(\n                        chest,\n                        null,\n                        async () =>\n                            await _transactionController.ThrowAndEquip(\n                                GetSwapAction(tacVest, lootItem, null, true)\n                            )\n                    );\n                }\n                else\n                {\n                    swapAction = GetSwapAction(tacVest, lootItem, null, true);\n                }\n            }\n\n            action.Swap = swapAction;\n            return action;\n        }\n", "        public bool CanUseMag(MagazineClass mag)\n        {\n            return _botInventoryController.Inventory.Equipment\n                    .GetSlotsByName(\n                        new EquipmentSlot[]\n                        {\n                            EquipmentSlot.FirstPrimaryWeapon,\n                            EquipmentSlot.SecondPrimaryWeapon,\n                            EquipmentSlot.Holster\n                        }\n                    )\n                    .Where(\n                        slot =>\n                            slot.ContainedItem != null\n                            && ((Weapon)slot.ContainedItem).GetMagazineSlot() != null\n                            && ((Weapon)slot.ContainedItem).GetMagazineSlot().CanAccept(mag)\n                    )\n                    .ToArray()\n                    .Length > 0;\n        }\n\n        /**\n        * Throws all magazines from the rig that are not able to be used by any of the weapons that the bot currently has equipped\n        */", "        public async Task ThrowUselessMags(Weapon thrownWeapon)\n        {\n            Weapon primary = (Weapon)\n                _botInventoryController.Inventory.Equipment\n                    .GetSlot(EquipmentSlot.FirstPrimaryWeapon)\n                    .ContainedItem;\n            Weapon secondary = (Weapon)\n                _botInventoryController.Inventory.Equipment\n                    .GetSlot(EquipmentSlot.SecondPrimaryWeapon)\n                    .ContainedItem;\n            Weapon holster = (Weapon)\n                _botInventoryController.Inventory.Equipment\n                    .GetSlot(EquipmentSlot.Holster)\n                    .ContainedItem;\n            List<MagazineClass> mags = new List<MagazineClass>();\n            _botInventoryController.GetReachableItemsOfTypeNonAlloc(mags);\n\n            _log.LogDebug($\"Cleaning up old mags...\");\n            int reservedCount = 0;", "            foreach (MagazineClass mag in mags)\n            {\n                bool fitsInThrown =\n                    thrownWeapon.GetMagazineSlot() != null\n                    && thrownWeapon.GetMagazineSlot().CanAccept(mag);\n                bool fitsInPrimary =\n                    primary != null\n                    && primary.GetMagazineSlot() != null\n                    && primary.GetMagazineSlot().CanAccept(mag);\n                bool fitsInSecondary =\n                    secondary != null\n                    && secondary.GetMagazineSlot() != null\n                    && secondary.GetMagazineSlot().CanAccept(mag);\n                bool fitsInHolster =\n                    holster != null\n                    && holster.GetMagazineSlot() != null\n                    && holster.GetMagazineSlot().CanAccept(mag);\n\n                bool fitsInEquipped = fitsInPrimary || fitsInSecondary || fitsInHolster;\n                bool isSharedMag = fitsInThrown && fitsInEquipped;", "                if (reservedCount < 2 && fitsInThrown && fitsInEquipped)\n                {\n                    _log.LogDebug($\"Reserving shared mag {mag.Name.Localized()}\");\n                    reservedCount++;\n                }\n                else if ((reservedCount >= 2 && fitsInEquipped) || !fitsInEquipped)\n                {\n                    _log.LogDebug($\"Removing useless mag {mag.Name.Localized()}\");\n                    await _transactionController.ThrowAndEquip(\n                        new TransactionController.SwapAction(mag)\n                    );\n                }\n            }\n        }\n\n        /**\n        * Determines the kind of equip action the bot should take when encountering a weapon. Bots will always prefer to replace weapons that have lower value when encountering a higher value weapon.\n        */\n        public TransactionController.EquipAction GetWeaponEquipAction(Weapon lootWeapon)\n        {\n            Weapon primary = (Weapon)\n                _botInventoryController.Inventory.Equipment\n                    .GetSlot(EquipmentSlot.FirstPrimaryWeapon)\n                    .ContainedItem;\n            Weapon secondary = (Weapon)\n                _botInventoryController.Inventory.Equipment\n                    .GetSlot(EquipmentSlot.SecondPrimaryWeapon)\n                    .ContainedItem;\n            Weapon holster = (Weapon)\n                _botInventoryController.Inventory.Equipment\n                    .GetSlot(EquipmentSlot.Holster)\n                    .ContainedItem;\n\n            TransactionController.EquipAction action = new TransactionController.EquipAction();\n            bool isPistol = lootWeapon.WeapClass.Equals(\"pistol\");\n            float lootValue = CurrentItemPrice;\n", "            if (isPistol)\n            {\n                if (holster == null)\n                {\n                    var place = _botInventoryController.FindSlotToPickUp(lootWeapon);\n                    if (place != null)\n                    {\n                        action.Move = new TransactionController.MoveAction(lootWeapon, place);\n                        GearValue.Holster = new ValuePair(lootWeapon.Id, lootValue);\n                    }\n                }", "                else if (holster != null && GearValue.Holster.Value < lootValue)\n                {\n                    _log.LogDebug(\n                        $\"Trying to swap {holster.Name.Localized()} (\u20bd{GearValue.Holster.Value}) with {lootWeapon.Name.Localized()} (\u20bd{lootValue})\"\n                    );\n                    action.Swap = GetSwapAction(holster, lootWeapon);\n                    GearValue.Holster = new ValuePair(lootWeapon.Id, lootValue);\n                }\n            }\n            else\n            {\n                // If we have no primary, just equip the weapon to primary", "                if (primary == null)\n                {\n                    var place = _botInventoryController.FindSlotToPickUp(lootWeapon);\n                    if (place != null)\n                    {\n                        action.Move = new TransactionController.MoveAction(\n                            lootWeapon,\n                            place,\n                            null,\n                            async () =>\n                            {\n                                ChangeToPrimary();\n                                Stats.AddNetValue(lootValue);\n                                await TransactionController.SimulatePlayerDelay(1000);\n                            }\n                        );\n                        GearValue.Primary = new ValuePair(lootWeapon.Id, lootValue);\n                    }\n                }", "                else if (GearValue.Primary.Value < lootValue)\n                {\n                    // If the loot weapon is worth more than the primary, by nature its also worth more than the secondary. Try to move the primary weapon to the secondary slot and equip the new weapon as the primary\n                    if (secondary == null)\n                    {\n                        ItemAddress place = _botInventoryController.FindSlotToPickUp(primary);\n                        if (place != null)\n                        {\n                            _log.LogDebug(\n                                $\"Moving {primary.Name.Localized()} (\u20bd{GearValue.Primary.Value}) to secondary and equipping {lootWeapon.Name.Localized()} (\u20bd{lootValue})\"\n                            );\n                            action.Move = new TransactionController.MoveAction(\n                                primary,\n                                place,\n                                null,\n                                async () =>\n                                {\n                                    await _transactionController.TryEquipItem(lootWeapon);\n                                    await TransactionController.SimulatePlayerDelay(1500);\n                                    ChangeToPrimary();\n                                }\n                            );\n\n                            GearValue.Secondary = GearValue.Primary;\n                            GearValue.Primary = new ValuePair(lootWeapon.Id, lootValue);\n                        }\n                    }\n                    // In the case where we have a secondary, throw it, move the primary to secondary, and equip the loot weapon as primary\n                    else\n                    {\n                        _log.LogDebug(\n                            $\"Trying to swap {secondary.Name.Localized()} (\u20bd{GearValue.Secondary.Value}) with {primary.Name.Localized()} (\u20bd{GearValue.Primary.Value}) and equip {lootWeapon.Name.Localized()} (\u20bd{lootValue})\"\n                        );\n                        action.Swap = GetSwapAction(\n                            secondary,\n                            primary,\n                            null,\n                            false,\n                            async () =>\n                            {\n                                await ThrowUselessMags(secondary);\n                                await _transactionController.TryEquipItem(lootWeapon);\n                                Stats.AddNetValue(lootValue);\n                                await TransactionController.SimulatePlayerDelay(1500);\n                                ChangeToPrimary();\n                            }\n                        );\n                        GearValue.Secondary = GearValue.Primary;\n                        GearValue.Primary = new ValuePair(lootWeapon.Id, lootValue);\n                    }\n                }\n                // If there is no secondary weapon, equip to secondary", "                else if (secondary == null)\n                {\n                    var place = _botInventoryController.FindSlotToPickUp(lootWeapon);\n                    if (place != null)\n                    {\n                        action.Move = new TransactionController.MoveAction(\n                            lootWeapon,\n                            _botInventoryController.FindSlotToPickUp(lootWeapon)\n                        );\n                        GearValue.Secondary = new ValuePair(lootWeapon.Id, lootValue);\n                    }\n                }\n                // If the loot weapon is worth more than the secondary, swap it", "                else if (GearValue.Secondary.Value < lootValue)\n                {\n                    _log.LogDebug(\n                        $\"Trying to swap {secondary.Name.Localized()} (\u20bd{GearValue.Secondary.Value}) with {lootWeapon.Name.Localized()} (\u20bd{lootValue})\"\n                    );\n                    action.Swap = GetSwapAction(secondary, lootWeapon);\n                    GearValue.Secondary = new ValuePair(secondary.Id, lootValue);\n                }\n            }\n\n            return action;\n        }\n\n        /**\n        * Checks to see if the bot should swap its currently equipped gear with the item to loot. Bot will swap under the following criteria:\n        * 1. The item is a container and its larger than what is equipped.", "        *   - Tactical rigs have an additional check, will not switch out if the rig we are looting is lower armor class than what is equipped\n        * 2. The item has an armor rating, and its higher than what is currently equipped.\n        */\n        public bool ShouldSwapGear(Item equipped, Item itemToLoot)\n        {\n            // Bosses cannot swap gear as many bosses have custom logic tailored to their loadouts\n            if (_isBoss)\n            {\n                return false;\n            }\n\n            bool foundBiggerContainer = false;\n            // If the item is a container, calculate the size and see if its bigger than what is equipped", "            if (equipped.IsContainer)\n            {\n                int equippedSize = LootUtils.GetContainerSize(equipped as SearchableItemClass);\n                int itemToLootSize = LootUtils.GetContainerSize(itemToLoot as SearchableItemClass);\n\n                foundBiggerContainer = equippedSize < itemToLootSize;\n            }\n\n            bool foundBetterArmor = IsLootingBetterArmor(equipped, itemToLoot);\n            ArmorComponent lootArmor = itemToLoot.GetItemComponent<ArmorComponent>();\n            ArmorComponent equippedArmor = equipped.GetItemComponent<ArmorComponent>();\n\n            // Equip if we found item with a better armor class.\n            // Equip if we found an item with more slots only if what we have equipped is the same or worse armor class\n            return foundBetterArmor\n                || (\n                    foundBiggerContainer\n                    && (equippedArmor == null || equippedArmor.ArmorClass <= lootArmor?.ArmorClass)\n                );\n        }\n\n        /**\n        * Checks to see if the item we are looting has higher armor value than what is currently equipped. For chests/vests, make sure we compare against the", "        * currentBodyArmorClass and update the value if a higher armor class is found.\n        */\n        public bool IsLootingBetterArmor(Item equipped, Item itemToLoot)\n        {\n            ArmorComponent lootArmor = itemToLoot.GetItemComponent<ArmorComponent>();\n            HelmetComponent lootHelmet = itemToLoot.GetItemComponent<HelmetComponent>();\n            ArmorComponent equippedArmor = equipped.GetItemComponent<ArmorComponent>();\n\n            bool foundBetterArmor = false;\n\n            // If we are looting a helmet, check to see if it has a better armor class than what is equipped", "            // If we are looting a helmet, check to see if it has a better armor class than what is equipped\n            if (lootArmor != null && lootHelmet != null)\n            {\n                // If the equipped item is not an ArmorComponent then assume the lootArmor item is higher class\n                if (equippedArmor == null)\n                {\n                    return lootArmor != null;\n                }\n\n                foundBetterArmor = equippedArmor.ArmorClass <= lootArmor.ArmorClass;\n            }", "            else if (lootArmor != null)\n            {\n                // If we are looting chest/rig with armor, check to see if it has a better armor class than what is equipped\n                foundBetterArmor = CurrentBodyArmorClass <= lootArmor.ArmorClass;\n\n                if (foundBetterArmor)\n                {\n                    CurrentBodyArmorClass = lootArmor.ArmorClass;\n                }\n            }\n\n            return foundBetterArmor;\n        }\n\n        /** Searches throught the child items of a container and attempts to loot them */", "        public async Task<bool> LootNestedItems(Item parentItem)\n        {\n            if (_transactionController.IsLootingInterrupted())\n            {\n                return false;\n            }\n\n            Item[] nestedItems = parentItem.GetAllItems().ToArray();\n            if (nestedItems.Length > 1)\n            {\n                // Filter out the parent item from the list, filter out any items that are children of another container like a magazine, backpack, rig\n                Item[] containerItems = nestedItems\n                    .Where(\n                        nestedItem =>\n                            nestedItem.Id != parentItem.Id\n                            && nestedItem.Id == nestedItem.GetRootItem().Id\n                            && !nestedItem.QuestItem\n                            && !LootUtils.IsSingleUseKey(nestedItem)\n                    )\n                    .ToArray();\n", "            if (nestedItems.Length > 1)\n            {\n                // Filter out the parent item from the list, filter out any items that are children of another container like a magazine, backpack, rig\n                Item[] containerItems = nestedItems\n                    .Where(\n                        nestedItem =>\n                            nestedItem.Id != parentItem.Id\n                            && nestedItem.Id == nestedItem.GetRootItem().Id\n                            && !nestedItem.QuestItem\n                            && !LootUtils.IsSingleUseKey(nestedItem)\n                    )\n                    .ToArray();\n", "                if (containerItems.Length > 0)\n                {\n                    _log.LogDebug(\n                        $\"Looting {containerItems.Length} items from {parentItem.Name.Localized()}\"\n                    );\n                    await TransactionController.SimulatePlayerDelay(1000);\n                    return await TryAddItemsToBot(containerItems);\n                }\n            }\n            else\n            {\n                _log.LogDebug($\"No nested items found in {parentItem.Name}\");\n            }\n\n            return true;\n        }\n\n        /**\n            Check if the item being looted meets the loot value threshold specified in the mod settings and saves its value in CurrentItemPrice.\n            PMC bots use the PMC loot threshold, all other bots such as scavs, bosses, and raiders will use the scav threshold\n        */", "        public bool IsValuableEnough(float itemPrice)\n        {\n            WildSpawnType botType = _botOwner.Profile.Info.Settings.Role;\n            bool isPMC = BotTypeUtils.IsPMC(botType);\n\n            // If the bot is a PMC, compare the price against the PMC loot threshold. For all other bot types use the scav threshold\n            return isPMC && itemPrice >= LootingBots.PMCLootThreshold.Value\n                || !isPMC && itemPrice >= LootingBots.ScavLootThreshold.Value;\n        }\n\n        public bool AllowedToEquip(Item lootItem)\n        {\n            WildSpawnType botType = _botOwner.Profile.Info.Settings.Role;\n            bool isPMC = BotTypeUtils.IsPMC(botType);\n            bool allowedToEquip = isPMC\n                ? LootingBots.PMCGearToEquip.Value.IsItemEligible(lootItem)\n                : LootingBots.ScavGearToEquip.Value.IsItemEligible(lootItem);\n\n            return allowedToEquip && IsValuableEnough(CurrentItemPrice);\n        }\n", "        public bool AllowedToEquip(Item lootItem)\n        {\n            WildSpawnType botType = _botOwner.Profile.Info.Settings.Role;\n            bool isPMC = BotTypeUtils.IsPMC(botType);\n            bool allowedToEquip = isPMC\n                ? LootingBots.PMCGearToEquip.Value.IsItemEligible(lootItem)\n                : LootingBots.ScavGearToEquip.Value.IsItemEligible(lootItem);\n\n            return allowedToEquip && IsValuableEnough(CurrentItemPrice);\n        }\n", "        public bool AllowedToPickup(Item lootItem)\n        {\n            WildSpawnType botType = _botOwner.Profile.Info.Settings.Role;\n            bool isPMC = BotTypeUtils.IsPMC(botType);\n            bool allowedToPickup = isPMC\n                ? LootingBots.PMCGearToPickup.Value.IsItemEligible(lootItem)\n                : LootingBots.ScavGearToPickup.Value.IsItemEligible(lootItem);\n\n            return allowedToPickup && IsValuableEnough(CurrentItemPrice);\n        }\n\n        /**\n        *   Returns the list of slots to loot from a corpse in priority order. When a bot already has a backpack/rig, they will attempt to loot the weapons off the bot first. Otherwise they will loot the equipement first and loot the weapons afterwards.\n        */\n        public EquipmentSlot[] GetPrioritySlots()\n        {\n            InventoryControllerClass botInventoryController = _botInventoryController;\n            bool hasBackpack =\n                botInventoryController.Inventory.Equipment\n                    .GetSlot(EquipmentSlot.Backpack)\n                    .ContainedItem != null;\n            bool hasTacVest =\n                botInventoryController.Inventory.Equipment\n                    .GetSlot(EquipmentSlot.TacticalVest)\n                    .ContainedItem != null;\n\n            EquipmentSlot[] prioritySlots = new EquipmentSlot[0];\n            EquipmentSlot[] weaponSlots = new EquipmentSlot[]\n            {\n                EquipmentSlot.Holster,\n                EquipmentSlot.FirstPrimaryWeapon,\n                EquipmentSlot.SecondPrimaryWeapon\n            };\n            EquipmentSlot[] storageSlots = new EquipmentSlot[]\n            {\n                EquipmentSlot.Backpack,\n                EquipmentSlot.ArmorVest,\n                EquipmentSlot.TacticalVest,\n                EquipmentSlot.Pockets\n            };\n", "            if (hasBackpack || hasTacVest)\n            {\n                _log.LogDebug($\"Has backpack/rig and is looting weapons first!\");\n                prioritySlots = prioritySlots.Concat(weaponSlots).Concat(storageSlots).ToArray();\n            }\n            else\n            {\n                prioritySlots = prioritySlots.Concat(storageSlots).Concat(weaponSlots).ToArray();\n            }\n\n            return prioritySlots\n                .Concat(\n                    new EquipmentSlot[]\n                    {\n                        EquipmentSlot.Headwear,\n                        EquipmentSlot.Earpiece,\n                        EquipmentSlot.Dogtag,\n                        EquipmentSlot.Scabbard,\n                        EquipmentSlot.FaceCover\n                    }\n                )\n                .ToArray();\n        }\n\n        /** Generates a SwapAction to send to the transaction controller*/\n        public TransactionController.SwapAction GetSwapAction(\n            Item toThrow,\n            Item toEquip,\n            TransactionController.ActionCallback callback = null,\n            bool tranferItems = false,\n            TransactionController.ActionCallback onComplete = null\n        )\n        {\n            TransactionController.ActionCallback onSwapComplete = null;\n            // If we want to transfer items after the throw and equip fully completes, call the lootNestedItems method\n            // on the item that was just thrown", "            if (tranferItems)\n            {\n                onSwapComplete = async () =>\n                {\n                    await TransactionController.SimulatePlayerDelay();\n                    await LootNestedItems(toThrow);\n                };\n            }\n\n            return new TransactionController.SwapAction(\n                toThrow,\n                toEquip,\n                callback\n                    ?? (\n                        async () =>\n                        {\n                            Stats.SubtractNetValue(_itemAppraiser.GetItemPrice(toThrow));\n                            _lootingBrain.IgnoreLoot(toThrow.Id);\n                            await TransactionController.SimulatePlayerDelay(1000);\n", "                            if (toThrow is Weapon weapon)\n                            {\n                                await ThrowUselessMags(weapon);\n                            }\n\n                            bool isMovingOwnedItem = _botInventoryController.IsItemEquipped(\n                                toEquip\n                            );\n                            // Try to equip the item after throwing\n                            if (\n                                await _transactionController.TryEquipItem(toEquip)\n                                && !isMovingOwnedItem\n                            )\n                            {\n                                Stats.AddNetValue(CurrentItemPrice);\n                            }\n                        }\n                    ),\n                onComplete ?? onSwapComplete\n            );\n        }\n    }\n}\n", "                            if (\n                                await _transactionController.TryEquipItem(toEquip)\n                                && !isMovingOwnedItem\n                            )\n                            {\n                                Stats.AddNetValue(CurrentItemPrice);\n                            }\n                        }\n                    ),\n                onComplete ?? onSwapComplete\n            );\n        }\n    }\n}\n"]}
{"filename": "LootingBots/components/LootingBrain.cs", "chunked_list": ["using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Threading.Tasks;\n\nusing EFT;\nusing EFT.Interactive;\nusing EFT.InventoryLogic;", "using EFT.Interactive;\nusing EFT.InventoryLogic;\n\nusing LootingBots.Patch.Util;\n\nusing UnityEngine;\n\nnamespace LootingBots.Patch.Components\n{\n    // Degug spheres from DrakiaXYZ Waypoints https://github.com/DrakiaXYZ/SPT-Waypoints/blob/master/Helpers/GameObjectHelper.cs\n    public class GameObjectHelper\n    {", "{\n    // Degug spheres from DrakiaXYZ Waypoints https://github.com/DrakiaXYZ/SPT-Waypoints/blob/master/Helpers/GameObjectHelper.cs\n    public class GameObjectHelper\n    {\n        public static GameObject DrawSphere(Vector3 position, float size, Color color)\n        {\n            var sphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n            sphere.GetComponent<Renderer>().material.color = color;\n            sphere.GetComponent<Collider>().enabled = false;\n            sphere.transform.position = new Vector3(position.x, position.y, position.z);\n            sphere.transform.localScale = new Vector3(size, size, size);\n\n            return sphere;\n        }\n    }\n", "    public class LootingBrain : MonoBehaviour\n    {\n        public BotOwner BotOwner;\n\n        // Component responsible for adding items to the bot inventory\n        public InventoryController InventoryController;\n\n        // Current container that the bot will try to loot\n        public LootableContainer ActiveContainer;\n\n        // Current loose item that the bot will try to loot", "        public LootableContainer ActiveContainer;\n\n        // Current loose item that the bot will try to loot\n        public LootItem ActiveItem;\n\n        // Current corpse that the bot will try to loot\n        public BotOwner ActiveCorpse;\n\n        // Center of the loot object's collider used to help in navigation\n        public Vector3 LootObjectCenter;\n\n        // Collider.transform.position for the active lootable. Used in LOS checks to make sure bots dont loot through walls", "        public Vector3 LootObjectCenter;\n\n        // Collider.transform.position for the active lootable. Used in LOS checks to make sure bots dont loot through walls\n        public Vector3 LootObjectPosition;\n\n        // Object ids that the bot has looted\n        public List<string> IgnoredLootIds;\n\n        // Object ids that were not able to be reached even though a valid path exists. Is cleared every 2 mins by default\n        public List<string> NonNavigableLootIds;\n", "        public BotStats Stats\n        {\n            get { return InventoryController.Stats; }\n        }\n\n        public bool IsBotLooting {\n            get {\n                return LootTaskRunning || HasActiveLootable();\n            }\n        }\n\n        // Boolean showing when the looting coroutine is running", "        public bool LootTaskRunning = false;\n\n        public float DistanceToLoot = 0f;\n\n        // Amount of time in seconds to wait after looting successfully\n        public float WaitAfterLootTimer;\n        private BotLog _log;\n\n        public void Init(BotOwner botOwner)\n        {\n            _log = new BotLog(LootingBots.LootLog, botOwner);\n            BotOwner = botOwner;\n            InventoryController = new InventoryController(BotOwner, this);\n            IgnoredLootIds = new List<string> { };\n            NonNavigableLootIds = new List<string> { };\n        }\n\n        /*\n        * LootFinder update should only be running if one of the looting settings is enabled and the bot is in an active state\n        */", "        public void Init(BotOwner botOwner)\n        {\n            _log = new BotLog(LootingBots.LootLog, botOwner);\n            BotOwner = botOwner;\n            InventoryController = new InventoryController(BotOwner, this);\n            IgnoredLootIds = new List<string> { };\n            NonNavigableLootIds = new List<string> { };\n        }\n\n        /*\n        * LootFinder update should only be running if one of the looting settings is enabled and the bot is in an active state\n        */", "        public async Task Update()\n        {\n            try\n            {\n                WildSpawnType botType = BotOwner.Profile.Info.Settings.Role;\n                bool isLootFinderEnabled =\n                    LootingBots.ContainerLootingEnabled.Value.IsBotEnabled(botType)\n                    || LootingBots.LooseItemLootingEnabled.Value.IsBotEnabled(botType)\n                    || LootingBots.CorpseLootingEnabled.Value.IsBotEnabled(botType);\n\n                if (isLootFinderEnabled && BotOwner.BotState == EBotState.Active)\n                {", "                if (isLootFinderEnabled && BotOwner.BotState == EBotState.Active)\n                {\n                    if (InventoryController.ShouldSort)\n                    {\n                        // Sort items in tacVest for better space management\n                        await InventoryController.SortTacVest();\n                    }\n\n                    // Open any nearby door\n                    BotOwner.DoorOpener.Update();\n                }\n            }", "            catch (Exception e)\n            {\n                _log.LogError(e);\n            }\n        }\n\n        /**\n        * Determines the looting action to take depending on the current Active object in the LootFinder. There can only be one Active object at a time\n        */\n        public void StartLooting()\n        {", "        public void StartLooting()\n        {\n            if (ActiveContainer)\n            {\n                StartCoroutine(LootContainer());\n            }\n            else if (ActiveItem)\n            {\n                StartCoroutine(LootItem());\n            }\n            else if (ActiveCorpse)\n            {\n                StartCoroutine(LootCorpse());\n            }\n        }\n\n        /**\n        * Handles looting a corpse found on the map.\n        */", "            else if (ActiveCorpse)\n            {\n                StartCoroutine(LootCorpse());\n            }\n        }\n\n        /**\n        * Handles looting a corpse found on the map.\n        */\n        public IEnumerator LootCorpse()\n        {\n            var watch = new System.Diagnostics.Stopwatch();\n            watch.Start();\n\n            LootTaskRunning = true;\n            // Initialize corpse inventory controller\n            Player corpsePlayer = ActiveCorpse.GetPlayer;\n            Type corpseType = corpsePlayer.GetType();\n            FieldInfo corpseInventory = corpseType.BaseType.GetField(\n                \"_inventoryController\",\n                BindingFlags.NonPublic\n                    | BindingFlags.Static\n                    | BindingFlags.Public\n                    | BindingFlags.Instance\n            );\n            InventoryControllerClass corpseInventoryController = (InventoryControllerClass)\n                corpseInventory.GetValue(corpsePlayer);\n\n            // Get items to loot from the corpse in a priority order based off the slots\n            EquipmentSlot[] prioritySlots = InventoryController.GetPrioritySlots();\n            _log.LogWarning($\"Trying to loot corpse\");\n\n            Item[] priorityItems = corpseInventoryController.Inventory.Equipment\n                .GetSlotsByName(prioritySlots)\n                .Select(slot => slot.ContainedItem)\n                .Where(item => item != null && !item.IsUnremovable)\n                .ToArray();\n\n            Task<bool> lootTask = InventoryController.TryAddItemsToBot(priorityItems);\n            yield return new WaitUntil(() => lootTask.IsCompleted);\n\n            InventoryController.UpdateActiveWeapon();\n\n            // Only ignore the corpse if looting was not interrupted\n            CleanupCorpse(lootTask.Result);\n            OnLootTaskEnd(lootTask.Result);\n\n            watch.Stop();\n            _log.LogDebug(\n                $\"Corpse loot time: {watch.ElapsedMilliseconds / 1000f}s. Net Worth: {Stats.NetLootValue}\"\n            );\n        }\n\n        /**\n        * Handles looting a container found on the map.\n        */", "        public IEnumerator LootCorpse()\n        {\n            var watch = new System.Diagnostics.Stopwatch();\n            watch.Start();\n\n            LootTaskRunning = true;\n            // Initialize corpse inventory controller\n            Player corpsePlayer = ActiveCorpse.GetPlayer;\n            Type corpseType = corpsePlayer.GetType();\n            FieldInfo corpseInventory = corpseType.BaseType.GetField(\n                \"_inventoryController\",\n                BindingFlags.NonPublic\n                    | BindingFlags.Static\n                    | BindingFlags.Public\n                    | BindingFlags.Instance\n            );\n            InventoryControllerClass corpseInventoryController = (InventoryControllerClass)\n                corpseInventory.GetValue(corpsePlayer);\n\n            // Get items to loot from the corpse in a priority order based off the slots\n            EquipmentSlot[] prioritySlots = InventoryController.GetPrioritySlots();\n            _log.LogWarning($\"Trying to loot corpse\");\n\n            Item[] priorityItems = corpseInventoryController.Inventory.Equipment\n                .GetSlotsByName(prioritySlots)\n                .Select(slot => slot.ContainedItem)\n                .Where(item => item != null && !item.IsUnremovable)\n                .ToArray();\n\n            Task<bool> lootTask = InventoryController.TryAddItemsToBot(priorityItems);\n            yield return new WaitUntil(() => lootTask.IsCompleted);\n\n            InventoryController.UpdateActiveWeapon();\n\n            // Only ignore the corpse if looting was not interrupted\n            CleanupCorpse(lootTask.Result);\n            OnLootTaskEnd(lootTask.Result);\n\n            watch.Stop();\n            _log.LogDebug(\n                $\"Corpse loot time: {watch.ElapsedMilliseconds / 1000f}s. Net Worth: {Stats.NetLootValue}\"\n            );\n        }\n\n        /**\n        * Handles looting a container found on the map.\n        */", "        public IEnumerator LootContainer()\n        {\n            var watch = new System.Diagnostics.Stopwatch();\n            watch.Start();\n            LootTaskRunning = true;\n\n            Item item = ActiveContainer.ItemOwner.Items.ToArray()[0];\n            _log.LogDebug($\"Trying to add items from: {item.Name.Localized()}\");\n\n            bool didOpen = false;\n            // If a container was closed, open it before looting", "            if (ActiveContainer.DoorState == EDoorState.Shut)\n            {\n                LootUtils.InteractContainer(ActiveContainer, EInteractionType.Open);\n                didOpen = true;\n            }\n\n            Task delayTask = TransactionController.SimulatePlayerDelay(2000);\n            yield return new WaitUntil(() => delayTask.IsCompleted);\n\n            Task<bool> lootTask = InventoryController.LootNestedItems(item);\n            yield return new WaitUntil(() => lootTask.IsCompleted);\n\n            // Close the container after looting if a container was open, and the bot didnt open it", "            if (ActiveContainer.DoorState == EDoorState.Open && !didOpen)\n            {\n                LootUtils.InteractContainer(ActiveContainer, EInteractionType.Close);\n            }\n\n            InventoryController.UpdateActiveWeapon();\n\n            // Only ignore the container if looting was not interrupted\n            CleanupContainer(lootTask.Result);\n            OnLootTaskEnd(lootTask.Result);\n\n            watch.Stop();\n            _log.LogDebug(\n                $\"Container loot time: {watch.ElapsedMilliseconds / 1000f}s. Net Worth: {Stats.NetLootValue}\"\n            );\n        }\n\n        /**\n        * Handles looting a loose item found on the map.\n        */", "        public IEnumerator LootItem()\n        {\n            LootTaskRunning = true;\n\n            Item item = ActiveItem.ItemOwner.RootItem;\n\n            _log.LogDebug($\"Trying to pick up loose item: {item.Name.Localized()}\");\n            BotOwner.GetPlayer.UpdateInteractionCast();\n            Task<bool> lootTask = InventoryController.TryAddItemsToBot(new Item[] { item });\n\n            yield return new WaitUntil(() => lootTask.IsCompleted);\n\n            BotOwner.GetPlayer.CurrentManagedState.Pickup(false, null);\n            InventoryController.UpdateActiveWeapon();\n\n            // Need to manually cleanup item because the ItemOwner on the original object changes. Only ignore if looting was not interrupted\n            CleanupItem(lootTask.Result, item);\n            OnLootTaskEnd(lootTask.Result);\n            _log.LogDebug($\"Net Worth: {Stats.NetLootValue}\");\n        }\n", "        public void OnLootTaskEnd(bool lootingSuccessful)\n        {\n            UpdateGridStats();\n            BotOwner.AIData.CalcPower();\n            LootTaskRunning = false;\n            if (lootingSuccessful)\n            {\n                IncrementLootTimer();\n            }\n        }\n", "        public void UpdateGridStats()\n        {\n            InventoryController.UpdateGridStats();\n        }\n\n        /**\n        *  Check to see if the object being looted has been ignored due to bad navigation, being looted already, or if its in use by another bot\n        */\n        public bool IsLootIgnored(string lootId)\n        {\n            bool alreadyTried =\n                NonNavigableLootIds.Contains(lootId) || IgnoredLootIds.Contains(lootId);\n\n            return alreadyTried || ActiveLootCache.IsLootInUse(lootId);\n        }\n\n        /** Check if the item being looted meets the loot value threshold specified in the mod settings. PMC bots use the PMC loot threshold, all other bots such as scavs, bosses, and raiders will use the scav threshold */", "        public bool IsLootIgnored(string lootId)\n        {\n            bool alreadyTried =\n                NonNavigableLootIds.Contains(lootId) || IgnoredLootIds.Contains(lootId);\n\n            return alreadyTried || ActiveLootCache.IsLootInUse(lootId);\n        }\n\n        /** Check if the item being looted meets the loot value threshold specified in the mod settings. PMC bots use the PMC loot threshold, all other bots such as scavs, bosses, and raiders will use the scav threshold */\n        public bool IsValuableEnough(Item lootItem)\n        {\n            float itemValue = LootingBots.ItemAppraiser.GetItemPrice(lootItem);\n            return InventoryController.IsValuableEnough(itemValue);\n        }\n\n        /**\n        *  Handles adding non navigable loot to the list of non-navigable ids for use in the ignore logic. Additionaly removes the object from the active loot cache\n        */", "        public bool IsValuableEnough(Item lootItem)\n        {\n            float itemValue = LootingBots.ItemAppraiser.GetItemPrice(lootItem);\n            return InventoryController.IsValuableEnough(itemValue);\n        }\n\n        /**\n        *  Handles adding non navigable loot to the list of non-navigable ids for use in the ignore logic. Additionaly removes the object from the active loot cache\n        */\n        public void HandleNonNavigableLoot()\n        {\n            string lootId =\n                ActiveContainer?.Id ?? ActiveItem?.ItemOwner.RootItem.Id ?? ActiveCorpse.name;\n            NonNavigableLootIds.Add(lootId);\n            Cleanup();\n        }\n\n        /**\n        * Increment the delay timer used to delay the next loot scan after an object has been looted\n        */", "        public void HandleNonNavigableLoot()\n        {\n            string lootId =\n                ActiveContainer?.Id ?? ActiveItem?.ItemOwner.RootItem.Id ?? ActiveCorpse.name;\n            NonNavigableLootIds.Add(lootId);\n            Cleanup();\n        }\n\n        /**\n        * Increment the delay timer used to delay the next loot scan after an object has been looted\n        */", "        public void IncrementLootTimer(float time = -1f)\n        {\n            // Increment loot wait timer\n            float timer = time != -1f ? time : LootingBots.TimeToWaitBetweenLoot.Value;\n            WaitAfterLootTimer = Time.time + timer;\n        }\n\n        /**\n        * Returns true if the LootFinder has an ActiveContainer, ActiveItem, or ActiveCorpse defined\n        */\n        public bool HasActiveLootable()\n        {\n            return ActiveContainer != null || ActiveItem != null || ActiveCorpse != null;\n        }\n\n        /**\n        * Adds a loot id to the list of loot items to ignore for a specific bot\n        */", "        public bool HasActiveLootable()\n        {\n            return ActiveContainer != null || ActiveItem != null || ActiveCorpse != null;\n        }\n\n        /**\n        * Adds a loot id to the list of loot items to ignore for a specific bot\n        */\n        public void IgnoreLoot(string id)\n        {\n            IgnoredLootIds.Add(id);\n        }\n\n        /**\n        * Wrapper function to enable transactions to be executed by the InventoryController.\n        */", "        public void IgnoreLoot(string id)\n        {\n            IgnoredLootIds.Add(id);\n        }\n\n        /**\n        * Wrapper function to enable transactions to be executed by the InventoryController.\n        */\n        public void EnableTransactions()\n        {\n            InventoryController.EnableTransactions();\n        }\n\n        /**\n        * Wrapper function to disable the execution of transactions by the InventoryController.\n        */", "        public void EnableTransactions()\n        {\n            InventoryController.EnableTransactions();\n        }\n\n        /**\n        * Wrapper function to disable the execution of transactions by the InventoryController.\n        */\n        public void DisableTransactions()\n        {\n            InventoryController.DisableTransactions();\n        }\n\n        /**\n        * Removes all active lootables from LootFinder and cleans them from the active loot cache\n        */", "        public void DisableTransactions()\n        {\n            InventoryController.DisableTransactions();\n        }\n\n        /**\n        * Removes all active lootables from LootFinder and cleans them from the active loot cache\n        */\n        public void Cleanup(bool ignore = true)\n        {\n            if (ActiveContainer != null)\n            {\n                CleanupContainer(ignore);\n            }\n", "        public void Cleanup(bool ignore = true)\n        {\n            if (ActiveContainer != null)\n            {\n                CleanupContainer(ignore);\n            }\n\n            if (ActiveItem != null)\n            {\n                CleanupItem(ignore);\n            }\n", "            if (ActiveCorpse != null)\n            {\n                CleanupCorpse(ignore);\n            }\n        }\n\n        /**\n        * Removes the ActiveContainer from the LootFinder and ActiveLootCache. Can optionally add the container to the ignore list after cleaning\n        */\n        public void CleanupContainer(bool ignore = true)\n        {\n            LootableContainer container = ActiveContainer;\n            ActiveLootCache.Cleanup(container.Id);\n", "        public void CleanupContainer(bool ignore = true)\n        {\n            LootableContainer container = ActiveContainer;\n            ActiveLootCache.Cleanup(container.Id);\n\n            if (ignore)\n            {\n                IgnoreLoot(container.Id);\n            }\n\n            ActiveContainer = null;\n        }\n\n        /**\n        * Removes the ActiveItem from the LootFinder and ActiveLootCache. Can optionally add the item to the ignore list after cleaning\n        */", "        public void CleanupItem(bool ignore = true, Item movedItem = null)\n        {\n            Item item = movedItem ?? ActiveItem.ItemOwner?.RootItem;\n            ActiveLootCache.Cleanup(item.Id);\n\n            if (ignore)\n            {\n                IgnoreLoot(item.Id);\n            }\n\n            ActiveItem = null;\n        }\n\n        /**\n        * Removes the ActiveCorpse from the LootFinder and ActiveLootCache. Can optionally add the corpse to the ignore list after cleaning\n        */", "        public void CleanupCorpse(bool ignore = true)\n        {\n            BotOwner corpse = ActiveCorpse;\n            string name = corpse.name;\n            ActiveLootCache.Cleanup(name);\n\n            if (ignore)\n            {\n                IgnoreLoot(name);\n            }\n\n            ActiveCorpse = null;\n        }\n    }\n}\n"]}
{"filename": "LootingBots/components/TransactionController.cs", "chunked_list": ["using System;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nusing Comfort.Common;\n\nusing EFT;\nusing EFT.InventoryLogic;\n\nusing LootingBots.Patch.Util;", "\nusing LootingBots.Patch.Util;\n\nusing InventoryOperationResultStruct = GStruct370;\nusing InventoryHelperClass = GClass2672;\nusing GridClassEx = GClass2411;\nusing GridCacheClass = GClass1384;\n\nnamespace LootingBots.Patch.Components\n{\n    public class TransactionController\n    {\n        readonly BotLog _log;\n        readonly InventoryControllerClass _inventoryController;\n        readonly BotOwner _botOwner;", "namespace LootingBots.Patch.Components\n{\n    public class TransactionController\n    {\n        readonly BotLog _log;\n        readonly InventoryControllerClass _inventoryController;\n        readonly BotOwner _botOwner;\n        public bool Enabled;\n\n        public TransactionController(\n            BotOwner botOwner,\n            InventoryControllerClass inventoryController,\n            BotLog log\n        )\n        {\n            _botOwner = botOwner;\n            _inventoryController = inventoryController;\n            _log = log;\n        }\n", "        public class EquipAction\n        {\n            public SwapAction Swap;\n            public MoveAction Move;\n        }\n\n        public class SwapAction\n        {\n            public Item ToThrow;\n            public Item ToEquip;\n            public ActionCallback Callback;", "            public Item ToThrow;\n            public Item ToEquip;\n            public ActionCallback Callback;\n            public ActionCallback OnComplete;\n\n            public SwapAction(\n                Item toThrow = null,\n                Item toEquip = null,\n                ActionCallback callback = null,\n                ActionCallback onComplete = null\n            )\n            {\n                ToThrow = toThrow;\n                ToEquip = toEquip;\n                Callback = callback;\n                OnComplete = onComplete;\n            }\n        }\n", "        public class MoveAction\n        {\n            public Item ToMove;\n            public ItemAddress Place;\n            public ActionCallback Callback;\n            public ActionCallback OnComplete;\n\n            public MoveAction(\n                Item toMove = null,\n                ItemAddress place = null,\n                ActionCallback callback = null,\n                ActionCallback onComplete = null\n            )\n            {\n                ToMove = toMove;\n                Place = place;\n                Callback = callback;\n                OnComplete = onComplete;\n            }\n        }\n", "        public delegate Task ActionCallback();\n\n        /** Tries to add extra spare ammo for the weapon being looted into the bot's secure container so that the bots are able to refill their mags properly in their reload logic */\n        public bool AddExtraAmmo(Weapon weapon)\n        {\n            try\n            {\n                SearchableItemClass secureContainer = (SearchableItemClass)\n                    _inventoryController.Inventory.Equipment\n                        .GetSlot(EquipmentSlot.SecuredContainer)\n                        .ContainedItem;\n\n                // Try to get the current ammo used by the weapon by checking the contents of the magazine. If its empty, try to create an instance of the ammo using the Weapon's CurrentAmmoTemplate\n                Item ammoToAdd =\n                    weapon.GetCurrentMagazine()?.FirstRealAmmo()\n                    ?? Singleton<ItemFactory>.Instance.CreateItem(\n                        new MongoID(false),\n                        weapon.CurrentAmmoTemplate._id,\n                        null\n                    );\n\n                // Check to see if there already is ammo that meets the weapon's caliber in the secure container\n                bool alreadyHasAmmo =\n                    secureContainer\n                        .GetAllItems()\n                        .Where(\n                            item =>\n                                item is BulletClass bullet\n                                && bullet.Caliber.Equals(((BulletClass)ammoToAdd).Caliber)\n                        )\n                        .ToArray()\n                        .Length > 0;\n\n                // If we dont have any ammo, attempt to add 10 max ammo stacks into the bot's secure container for use in the bot's internal reloading code", "                if (!alreadyHasAmmo)\n                {\n                    _log.LogDebug($\"Trying to add ammo\");\n                    int ammoAdded = 0;\n\n                    for (int i = 0; i < 10; i++)\n                    {\n                        Item ammo = ammoToAdd.CloneItem();\n                        ammo.StackObjectsCount = ammo.StackMaxSize;\n\n                        string[] visitorIds = new string[] { _inventoryController.ID };\n\n                        var location = _inventoryController.FindGridToPickUp(\n                            ammo,\n                            secureContainer.Grids\n                        );\n", "                        if (location != null)\n                        {\n                            var result = location.AddWithoutRestrictions(ammo, visitorIds);\n                            if (result.Failed)\n                            {\n                                _log.LogError(\n                                    $\"Failed to add {ammo.Name.Localized()} to secure container\"\n                                );\n                            }\n                            else\n                            {\n                                ammoAdded += ammo.StackObjectsCount;\n                                Singleton<GridCacheClass>.Instance.Add(location.GetOwner().ID, location.Grid as GridClassEx, ammo);\n                            }\n                        }\n                        else\n                        {\n                            _log.LogError(\n                                $\"Cannot find location in secure container for {ammo.Name.Localized()}\"\n                            );\n                        }\n                    }\n", "                    if (ammoAdded > 0)\n                    {\n                        _log.LogDebug(\n                            $\"Successfully added {ammoAdded} round of {ammoToAdd.Name.Localized()}\"\n                        );\n                    }\n                }\n                else\n                {\n                    _log.LogDebug($\"Already has ammo for {weapon.Name.Localized()}\");\n                }\n\n                return true;\n            }", "            catch (Exception e)\n            {\n                _log.LogError(e);\n            }\n\n            return false;\n        }\n\n        /** Tries to find an open Slot to equip the current item to. If a slot is found, issue a move action to equip the item */\n        public async Task<bool> TryEquipItem(Item item)\n        {\n            try\n            {\n\n                // Check to see if we can equip the item\n                var ableToEquip = _inventoryController.FindSlotToPickUp(item);", "        public async Task<bool> TryEquipItem(Item item)\n        {\n            try\n            {\n\n                // Check to see if we can equip the item\n                var ableToEquip = _inventoryController.FindSlotToPickUp(item);\n                if (ableToEquip != null)\n                {\n                    _log.LogWarning(\n                        $\"Equipping: {item.Name.Localized()} [place: {ableToEquip.Container.ID.Localized()}]\"\n                    );\n                    bool success = await MoveItem(new MoveAction(item, ableToEquip));\n                    return success;\n                }\n\n                _log.LogDebug($\"Cannot equip: {item.Name.Localized()}\");\n            }", "            catch (Exception e)\n            {\n                _log.LogError(e);\n            }\n\n            return false;\n        }\n\n        /** Tries to find a valid grid for the item being looted. Checks all containers currently equipped to the bot. If there is a valid grid to place the item inside of, issue a move action to pick up the item */\n        public async Task<bool> TryPickupItem(Item item)\n        {\n            try\n            {\n                var ableToPickUp = _inventoryController.FindGridToPickUp(item);\n", "        public async Task<bool> TryPickupItem(Item item)\n        {\n            try\n            {\n                var ableToPickUp = _inventoryController.FindGridToPickUp(item);\n\n                if (\n                    ableToPickUp != null\n                    && !ableToPickUp\n                        .GetRootItem()\n                        .Parent.Container.ID.ToLower()\n                        .Equals(\"securedcontainer\")\n                )\n                {\n                    _log.LogWarning(\n                        $\"Picking up: {item.Name.Localized()} [place: {ableToPickUp.GetRootItem().Name.Localized()}]\"\n                    );\n                    return await MoveItem(new MoveAction(item, ableToPickUp));\n                }\n\n                _log.LogDebug($\"No valid slot found for: {item.Name.Localized()}\");\n            }", "            catch (Exception e)\n            {\n                _log.LogError(e);\n            }\n            return false;\n        }\n\n        /** Moves an item to a specified item address. Supports executing a callback */\n        public async Task<bool> MoveItem(MoveAction moveAction)\n        {\n            try\n            {", "        public async Task<bool> MoveItem(MoveAction moveAction)\n        {\n            try\n            {\n                if (IsLootingInterrupted())\n                {\n                    return false;\n                }\n\n                if (moveAction.ToMove is Weapon weapon && !(moveAction.ToMove is BulletClass))\n                {\n                    AddExtraAmmo(weapon);\n                }\n\n                _log.LogDebug($\"Moving item to: {moveAction?.Place?.Container?.ID?.Localized()}\");\n                var value = InventoryHelperClass.Move(\n                    moveAction.ToMove,\n                    moveAction.Place,\n                    _inventoryController,\n                    true\n                );\n", "                if (moveAction.ToMove is Weapon weapon && !(moveAction.ToMove is BulletClass))\n                {\n                    AddExtraAmmo(weapon);\n                }\n\n                _log.LogDebug($\"Moving item to: {moveAction?.Place?.Container?.ID?.Localized()}\");\n                var value = InventoryHelperClass.Move(\n                    moveAction.ToMove,\n                    moveAction.Place,\n                    _inventoryController,\n                    true\n                );\n", "                if (value.Failed)\n                {\n                    _log.LogError(\n                        $\"Failed to move {moveAction.ToMove.Name.Localized()} to {moveAction.Place.Container.ID.Localized()}\"\n                    );\n                    return false;\n                }\n\n                if (moveAction.Callback == null)\n                {\n                    await SimulatePlayerDelay();\n                    await _inventoryController.TryRunNetworkTransaction(value, null);\n                }\n                else\n                {\n                    TaskCompletionSource<IResult> promise = new TaskCompletionSource<IResult>();\n\n                    await _inventoryController.TryRunNetworkTransaction(\n                        value,\n                        new Callback(\n                            async (IResult result) =>\n                            {", "                if (moveAction.Callback == null)\n                {\n                    await SimulatePlayerDelay();\n                    await _inventoryController.TryRunNetworkTransaction(value, null);\n                }\n                else\n                {\n                    TaskCompletionSource<IResult> promise = new TaskCompletionSource<IResult>();\n\n                    await _inventoryController.TryRunNetworkTransaction(\n                        value,\n                        new Callback(\n                            async (IResult result) =>\n                            {", "                                if (result.Succeed)\n                                {\n                                    await SimulatePlayerDelay();\n                                    await moveAction.Callback();\n                                }\n                                promise.TrySetResult(result);\n                            }\n                        )\n                    );\n\n                    await promise.Task;\n                }", "                if (moveAction.OnComplete != null)\n                {\n                    await SimulatePlayerDelay();\n                    await moveAction.OnComplete();\n                }\n            }\n            catch (Exception e)\n            {\n                _log.LogError(e);\n            }\n\n            return true;\n        }\n\n        /** Method used when we want the bot the throw an item and then equip an item immidiately afterwards */", "        public async Task<bool> ThrowAndEquip(SwapAction swapAction)\n        {\n            if (IsLootingInterrupted())\n            {\n                return false;\n            }\n\n            try\n            {\n                TaskCompletionSource<IResult> promise = new TaskCompletionSource<IResult>();\n                Item toThrow = swapAction.ToThrow;\n\n                _log.LogWarning($\"Throwing item: {toThrow.Name.Localized()}\");\n                _inventoryController.ThrowItem(\n                    toThrow,\n                    null,\n                    new Callback(\n                        async (IResult result) =>\n                        {", "                            if (result.Succeed)\n                            {\n                                if (swapAction.Callback != null)\n                                {\n                                    await SimulatePlayerDelay();\n                                    await swapAction.Callback();\n                                }\n                            }\n\n                            promise.TrySetResult(result);\n                        }\n                    ),\n                    false\n                );\n                await SimulatePlayerDelay();\n                IResult taskResult = await promise.Task;", "                if (taskResult.Failed)\n                {\n                    return false;\n                }\n\n                if (swapAction.OnComplete != null)\n                {\n                    await swapAction.OnComplete();\n                }\n\n                return true;\n            }", "            catch (Exception e)\n            {\n                _log.LogError(e);\n            }\n\n            return false;\n        }\n\n        public Task<IResult> TryRunNetworkTransaction(\n            InventoryOperationResultStruct operationResult,\n            Callback callback = null\n        )\n        {\n            return _inventoryController.TryRunNetworkTransaction(operationResult, callback);\n        }\n", "        public bool IsLootingInterrupted()\n        {\n           return !Enabled;\n        }\n\n        public static Task SimulatePlayerDelay(int delay = 500)\n        {\n            return Task.Delay(delay);\n        }\n\n\n    }\n}\n"]}
{"filename": "LootingBots/patches/SettingsAndCache.cs", "chunked_list": ["using System.Reflection;\n\nusing Aki.Reflection.Patching;\n\nusing EFT;\n\nusing LootingBots.Patch.Util;\n\nnamespace LootingBots.Patch\n{\n    public class SettingsAndCachePatch\n    {", "namespace LootingBots.Patch\n{\n    public class SettingsAndCachePatch\n    {\n        public void Enable()\n        {\n            new CleanCacheOnRaidEnd().Enable();\n            new EnableWeaponSwitching().Enable();\n        }\n    }\n", "    public class CleanCacheOnRaidEnd : ModulePatch\n    {\n        protected override MethodBase GetTargetMethod()\n        {\n            return typeof(GameWorld).GetMethod(\n                \"Dispose\",\n                BindingFlags.Public | BindingFlags.Instance\n            );\n        }\n\n        [PatchPrefix]", "        private static void PatchPrefix()\n        {\n            LootingBots.LootLog.LogDebug($\"Resetting Loot Cache\");\n            ActiveLootCache.Reset();\n        }\n    }\n\n    /* Patch that enables all bots to be able to switch weapons. Values based on Usec/Bear bot values */\n    public class EnableWeaponSwitching : ModulePatch\n    {\n        protected override MethodBase GetTargetMethod()\n        {\n            return typeof(BotDifficultySettingsClass).GetMethod(\"ApplyPresetLocation\");\n        }\n\n        [PatchPostfix]", "    public class EnableWeaponSwitching : ModulePatch\n    {\n        protected override MethodBase GetTargetMethod()\n        {\n            return typeof(BotDifficultySettingsClass).GetMethod(\"ApplyPresetLocation\");\n        }\n\n        [PatchPostfix]\n        private static void PatchPostfix(\n            BotLocationModifier modifier,\n            ref BotDifficultySettingsClass __instance,\n            ref WildSpawnType ___wildSpawnType_0\n        )\n        {\n            bool corpseLootEnabled = LootingBots.CorpseLootingEnabled.Value.IsBotEnabled(\n                ___wildSpawnType_0\n            );\n            bool containerLootEnabled = LootingBots.ContainerLootingEnabled.Value.IsBotEnabled(\n                ___wildSpawnType_0\n            );\n            bool itemLootEnabled = LootingBots.LooseItemLootingEnabled.Value.IsBotEnabled(\n                ___wildSpawnType_0\n            );\n", "        private static void PatchPostfix(\n            BotLocationModifier modifier,\n            ref BotDifficultySettingsClass __instance,\n            ref WildSpawnType ___wildSpawnType_0\n        )\n        {\n            bool corpseLootEnabled = LootingBots.CorpseLootingEnabled.Value.IsBotEnabled(\n                ___wildSpawnType_0\n            );\n            bool containerLootEnabled = LootingBots.ContainerLootingEnabled.Value.IsBotEnabled(\n                ___wildSpawnType_0\n            );\n            bool itemLootEnabled = LootingBots.LooseItemLootingEnabled.Value.IsBotEnabled(\n                ___wildSpawnType_0\n            );\n", "            if (corpseLootEnabled || containerLootEnabled || itemLootEnabled)\n            {\n                __instance.FileSettings.Shoot.CHANCE_TO_CHANGE_WEAPON = 80;\n                __instance.FileSettings.Shoot.CHANCE_TO_CHANGE_WEAPON_WITH_HELMET = 40;\n            }\n        }\n    }\n}\n"]}
{"filename": "LootingBots/patches/RemoveComponent.cs", "chunked_list": ["\ufeffusing Aki.Reflection.Patching;\nusing EFT;\nusing LootingBots.Patch.Components;\nusing System.Reflection;\nusing UnityEngine;\n\nnamespace LootingBots.Patch\n{\n    internal class RemoveComponent : ModulePatch\n    {\n        protected override MethodBase GetTargetMethod()\n        {\n            return typeof(BotControllerClass).GetMethod(\n                \"Init\",\n                BindingFlags.Public | BindingFlags.Instance\n            );\n        }\n\n        [PatchPostfix]", "    internal class RemoveComponent : ModulePatch\n    {\n        protected override MethodBase GetTargetMethod()\n        {\n            return typeof(BotControllerClass).GetMethod(\n                \"Init\",\n                BindingFlags.Public | BindingFlags.Instance\n            );\n        }\n\n        [PatchPostfix]", "        private static void PatchPostfix(BotControllerClass __instance)\n        {\n            __instance.BotSpawner.OnBotRemoved += botOwner =>\n            {\n                if (botOwner.GetPlayer.TryGetComponent<LootingBrain>(out var component))\n                {\n                    Object.Destroy(component);\n                }\n            };\n        }\n    }\n}\n"]}
{"filename": "LootingBots/utils/LootUtils.cs", "chunked_list": ["using System.Collections.Generic;\nusing System.Linq;\n\nusing Comfort.Common;\n\nusing EFT;\nusing EFT.Interactive;\nusing EFT.InventoryLogic;\n\nusing UnityEngine;", "\nusing UnityEngine;\n\nusing GridClass = GClass2408;\nusing GridClassEx = GClass2411;\nusing InteractResultClass = GClass2846;\nusing GridManagerClass = GClass2706;\nusing SortResultStruct = GStruct371<GClass2706>;\nusing GridItemClass = GClass2416;\nusing ItemAddressExClass = GClass2667;", "using GridItemClass = GClass2416;\nusing ItemAddressExClass = GClass2667;\nusing SortErrorClass = GClass3103;\nusing GridCacheClass = GClass1384;\n\nnamespace LootingBots.Patch.Util\n{\n    public static class LootUtils\n    {\n        public static LayerMask LowPolyMask = LayerMask.GetMask(new string[] { \"LowPolyCollider\" });\n        public static LayerMask LootMask = LayerMask.GetMask(\n            new string[] { \"Interactive\", \"Loot\", \"Deadbody\" }\n        );\n\n        /* Simple check to see if the current bot is a Boss type */", "        public static LayerMask LowPolyMask = LayerMask.GetMask(new string[] { \"LowPolyCollider\" });\n        public static LayerMask LootMask = LayerMask.GetMask(\n            new string[] { \"Interactive\", \"Loot\", \"Deadbody\" }\n        );\n\n        /* Simple check to see if the current bot is a Boss type */\n        public static bool IsBoss(BotOwner botOwner)\n        {\n            return botOwner.Boss != null;\n        }\n\n        /** Calculate the size of a container */", "        public static int GetContainerSize(SearchableItemClass container)\n        {\n            GridClass[] grids = container.Grids;\n            int gridSize = 0;\n\n            foreach (GridClass grid in grids)\n            {\n                gridSize += grid.GridHeight.Value * grid.GridWidth.Value;\n            }\n\n            return gridSize;\n        }\n\n        // Prevents bots from looting single use quest keys like \"Unknown Key\"", "        public static bool IsSingleUseKey(Item item)\n        {\n            KeyComponent key = item.GetItemComponent<KeyComponent>();\n            return key != null && key.Template.MaximumNumberOfUsage == 1;\n        }\n\n        /** Triggers a container to open/close */\n        public static void InteractContainer(LootableContainer container, EInteractionType action)\n        {\n            InteractResultClass result = new InteractResultClass(action);\n            container.Interact(result);\n        }\n\n        /**\n        * Sorts the items in a container and places them in grid spaces that match their exact size before moving on to a bigger slot size. This helps make more room in the container for items to be placed in\n        */", "        public static SortResultStruct SortContainer(\n            SearchableItemClass container,\n            InventoryControllerClass controller\n        )\n        {\n            if (container != null)\n            {\n                List<object> newLocations = new List<object>();\n                GridManagerClass gridManager = new GridManagerClass(container, controller);\n                List<Item> itemsInContainer = new List<Item>();\n\n                // Remove positions of all loot", "                foreach (var grid in container.Grids)\n                {\n                    gridManager.SetOldPositions(grid, grid.ItemCollection.ToListOfLocations());\n                    itemsInContainer.AddRange(grid.Items);\n                    grid.RemoveAll();\n                    Singleton<GridCacheClass>.Instance.Set(container.Owner.ID, grid as GridClassEx, new string[] { });\n                    controller.RaiseEvent(new GEventArgs23(grid));\n                }\n\n                // Sort items in container from largest to smallest\n                itemsInContainer.Sort(\n                    (item1, item2) => item2.GetItemSize().CompareTo(item1.GetItemSize())\n                );\n\n                // Sort grids in the container from smallest to largest\n                var sortedGrids = SortGrids(container.Grids);\n\n                // Go through each item and try to find a spot in the container for it. Since items are sorted largest to smallest and grids sorted from smallest to largest,\n                // this should ensure that items prefer to be in slots that match their size, instead of being placed in a larger grid spots", "                foreach (Item item in itemsInContainer)\n                {\n                    bool foundPlace = false;\n\n                    // Go through each grid slot and try to add the item\n                    foreach (var grid in sortedGrids)\n                    {\n                        if (!grid.Add(item).Failed)\n                        {\n                            foundPlace = true;\n                            gridManager.AddItemToGrid(\n                                grid,\n                                new GridItemClass(\n                                    item,\n                                    ((ItemAddressExClass)item.CurrentAddress).LocationInGrid\n                                )\n                            );\n                            Singleton<GridCacheClass>.Instance.Add(container.Owner.ID, grid as GridClassEx, item);\n                            break;\n                        }\n                    }\n", "                    if (!foundPlace)\n                    {\n                        // Sorting has failed! Rollback state of rig\n                        gridManager.RollBack();\n                        LootingBots.LootLog.LogError(\"Sort Failed\");\n                        return new SortErrorClass(item);\n                    }\n                }\n                return gridManager;\n            }\n\n            LootingBots.LootLog.LogError(\"No container!\");\n            return new SortErrorClass(null);\n        }\n\n        // Sort grids in the container from smallest to largest", "        public static GridClass[] SortGrids(GridClass[] grids)\n        {\n            // Sort grids in the container from smallest to largest\n            var containerGrids = grids.ToList();\n            containerGrids.Sort(\n                (grid1, grid2) =>\n                {\n                    var grid1Size = grid1.GridHeight.Value * grid1.GridWidth.Value;\n                    var grid2Size = grid2.GridHeight.Value * grid2.GridWidth.Value;\n                    return grid1Size.CompareTo(grid2Size);\n                }\n            );\n            return containerGrids.ToArray();\n        }\n\n        /**\n        * Calculates the amount of empty grid slots in the container\n        */", "        public static int GetAvailableGridSlots(GridClass[] grids)\n        {\n            if (grids == null) {\n                grids = new GridClass[] {};\n            }\n\n            List<GridClass> gridList = grids.ToList();\n            return gridList.Aggregate(\n                0,\n                (freeSpaces, grid) =>\n                {\n                    int gridSize = grid.GridHeight.Value * grid.GridWidth.Value;\n                    int containedItemSize = grid.GetSizeOfContainedItems();\n                    freeSpaces += gridSize - containedItemSize;\n                    return freeSpaces;\n                }\n            );\n        }\n\n        /**\n        * Returns an array of available grid slots, omitting 1 free 1x2 slot. This is to ensure no loot is placed in this slot and the grid space is only used for reloaded mags\n        */", "        public static GridClass[] Reserve2x1Slot(GridClass[] grids)\n        {\n            const int RESERVE_SLOT_COUNT = 2;\n            List<GridClass> gridList = grids.ToList();\n            foreach (var grid in gridList)\n            {\n                int gridSize = grid.GridHeight.Value * grid.GridWidth.Value;\n                bool isLargeEnough = gridSize >= RESERVE_SLOT_COUNT;\n\n                // If the grid is larger than 2 spaces, and the amount of free space in the grid is greater or equal to 2\n                // reserve the grid as a place where the bot can place reloaded mags", "                if (isLargeEnough && gridSize - grid.GetSizeOfContainedItems() >= 2)\n                {\n                    gridList.Remove(grid);\n                    return gridList.ToArray();\n                }\n            }\n\n            return gridList.ToArray();\n        }\n\n        /** Return the amount of spaces taken up by all the items in a given grid slot */", "        public static int GetSizeOfContainedItems(this GridClass grid)\n        {\n            return grid.Items.Aggregate(0, (sum, item2) => sum + item2.GetItemSize());\n        }\n\n        /** Gets the size of an item in a grid */\n        public static int GetItemSize(this Item item)\n        {\n            var dimensions = item.CalculateCellSize();\n            return dimensions.X * dimensions.Y;\n        }\n\n        // Custom extension for EFT InventoryControllerClass.FindGridToPickUp that uses a custom method for choosing the grid slot to place a loot item", "        public static ItemAddressExClass FindGridToPickUp(\n            this InventoryControllerClass controller,\n            Item item,\n            IEnumerable<GridClass> grids = null\n        )\n        {\n            var prioritzedGrids =\n                grids ?? controller.Inventory.Equipment.GetPrioritizedGridsForLoot(item);\n            foreach (var grid in prioritzedGrids)\n            {\n                var address = grid.FindFreeSpace(item);", "            foreach (var grid in prioritzedGrids)\n            {\n                var address = grid.FindFreeSpace(item);\n                if (address != null)\n                {\n                    return new ItemAddressExClass(grid, address);\n                }\n            }\n\n            return null;\n        }\n\n        // Custom extension for EFT EquipmentClass.GetPrioritizedGridsForLoot which sorts the tacVest/backpack and reserves a 1x2 grid slot in the tacvest before finding an available grid space for loot", "        public static IEnumerable<GridClass> GetPrioritizedGridsForLoot(\n            this EquipmentClass equipment,\n            Item item\n        )\n        {\n            SearchableItemClass tacVest = (SearchableItemClass)\n                equipment.GetSlot(EquipmentSlot.TacticalVest).ContainedItem;\n            SearchableItemClass backpack = (SearchableItemClass)\n                equipment.GetSlot(EquipmentSlot.Backpack).ContainedItem;\n            SearchableItemClass pockets = (SearchableItemClass)\n                equipment.GetSlot(EquipmentSlot.Pockets).ContainedItem;\n            SearchableItemClass secureContainer = (SearchableItemClass)\n                equipment.GetSlot(EquipmentSlot.SecuredContainer).ContainedItem;\n\n            GridClass[] tacVestGrids = new GridClass[0];", "            if (tacVest != null)\n            {\n                var sortedGrids = SortGrids(tacVest.Grids);\n                tacVestGrids = Reserve2x1Slot(sortedGrids);\n            }\n\n            GridClass[] backpackGrids =\n                (backpack != null) ? SortGrids(backpack.Grids) : new GridClass[0];\n            GridClass[] pocketGrids = (pockets != null) ? pockets.Grids : new GridClass[0];\n            GridClass[] secureContainerGrids =\n                (secureContainer != null) ? secureContainer.Grids : new GridClass[0];\n", "            if (item is BulletClass || item is MagazineClass)\n            {\n                return tacVestGrids\n                    .Concat(pocketGrids)\n                    .Concat(backpackGrids)\n                    .Concat(secureContainerGrids);\n            }\n            else if (item is GrenadeClass)\n            {\n                return pocketGrids\n                    .Concat(tacVestGrids)\n                    .Concat(backpackGrids)\n                    .Concat(secureContainerGrids);\n            }\n            else\n            {\n                return backpackGrids\n                    .Concat(tacVestGrids)\n                    .Concat(pocketGrids)\n                    .Concat(secureContainerGrids);\n            }\n        }\n    }\n}\n"]}
{"filename": "LootingBots/utils/Log.cs", "chunked_list": ["using System;\n\nusing EFT;\n\nnamespace LootingBots.Patch.Util\n{\n    [Flags]\n    public enum LogLevel\n    {\n        /// <summary>\n        ///     No level selected.\n        /// </summary>\n        None = 0,\n\n        /// <summary>\n        ///     An error has occured, but can be recovered from.\n        /// </summary>\n        Error = 2,\n\n        /// <summary>\n        ///     A warning has been produced, but does not necessarily mean that something wrong has happened.\n        /// </summary>\n        Warning = 4,\n\n        /// <summary>\n        ///     A message of low importance.\n        /// </summary>\n        Info = 16,\n\n        /// <summary>\n        ///     A message that would likely only interest a developer.\n        /// </summary>\n        Debug = 32,\n\n        /// <summary>\n        ///     All log levels.\n        /// </summary>\n        All = Error | Warning | Debug\n    }\n", "    public class BotLog\n    {\n        private readonly Log _log;\n        private readonly BotOwner _botOwner;\n        private readonly string _botString;\n\n        public BotLog(Log log, BotOwner botOwner)\n        {\n            _log = log;\n            _botOwner = botOwner;\n            _botString = $\"([{_botOwner.Profile.Info.Settings.Role}] {_botOwner.name})\";\n        }\n", "        public void LogDebug(object msg)\n        {\n            _log.LogDebug(FormatMessage(msg));\n        }\n\n        public void LogInfo(object msg)\n        {\n            _log.LogInfo(FormatMessage(msg));\n        }\n\n        public void LogWarning(object msg)\n        {\n            _log.LogWarning(FormatMessage(msg));\n        }\n", "        public void LogWarning(object msg)\n        {\n            _log.LogWarning(FormatMessage(msg));\n        }\n\n        public void LogError(object msg)\n        {\n            _log.LogError(FormatMessage(msg));\n        }\n\n        private string FormatMessage(object data)\n        {\n            return $\"{_botString} {data}\";\n        }\n    }\n", "        private string FormatMessage(object data)\n        {\n            return $\"{_botString} {data}\";\n        }\n    }\n\n    public class Log\n    {\n        public BepInEx.Logging.ManualLogSource Logger;\n        public BepInEx.Configuration.ConfigEntry<LogLevel> LogLevels;\n\n        public Log(\n            BepInEx.Logging.ManualLogSource logger,\n            BepInEx.Configuration.ConfigEntry<LogLevel> logLevels\n        )\n        {\n            Logger = logger;\n            LogLevels = logLevels;\n        }\n", "        public bool IsDebug()\n        {\n            return LogLevels.Value.HasDebug();\n        }\n\n        public void LogDebug(object data)\n        {\n            if (LogLevels.Value.HasDebug())\n            {\n                Logger.LogDebug(data);\n            }\n        }\n", "        public void LogInfo(object data)\n        {\n            if (LogLevels.Value.HasInfo())\n            {\n                Logger.LogInfo(data);\n            }\n        }\n\n        public void LogWarning(object data)\n        {\n            if (LogLevels.Value.HasWarning())\n            {\n                Logger.LogWarning(data);\n            }\n        }\n", "        public void LogWarning(object data)\n        {\n            if (LogLevels.Value.HasWarning())\n            {\n                Logger.LogWarning(data);\n            }\n        }\n\n        public void LogError(object data)\n        {\n            if (LogLevels.Value.HasError())\n            {\n                Logger.LogError(data);\n            }\n        }\n    }\n", "        public void LogError(object data)\n        {\n            if (LogLevels.Value.HasError())\n            {\n                Logger.LogError(data);\n            }\n        }\n    }\n\n    public static class LogUtils\n    {", "    public static class LogUtils\n    {\n        public static bool HasError(this LogLevel logLevel)\n        {\n            return logLevel.HasFlag(LogLevel.Error);\n        }\n\n        public static bool HasWarning(this LogLevel logLevel)\n        {\n            return logLevel.HasFlag(LogLevel.Warning);\n        }\n", "        public static bool HasInfo(this LogLevel logLevel)\n        {\n            return logLevel.HasFlag(LogLevel.Info);\n        }\n\n        public static bool HasDebug(this LogLevel logLevel)\n        {\n            return logLevel.HasFlag(LogLevel.Debug);\n        }\n    }\n}\n"]}
{"filename": "LootingBots/utils/BotTypes.cs", "chunked_list": ["using System;\n\nusing EFT;\n\nnamespace LootingBots.Patch.Util\n{\n    [Flags]\n    public enum BotType\n    {\n        Scav = 1,\n        Pmc = 2,\n        Raider = 4,\n        Cultist = 8,\n        Boss = 16,\n        Follower = 32,\n        Bloodhound = 64,\n\n        All = Scav | Pmc | Raider | Cultist | Boss | Follower | Bloodhound\n    }\n", "    public static class BotTypeUtils\n    {\n        public static bool HasScav(this BotType botType)\n        {\n            return botType.HasFlag(BotType.Scav);\n        }\n\n        public static bool HasPmc(this BotType botType)\n        {\n            return botType.HasFlag(BotType.Pmc);\n        }\n", "        public static bool HasRaider(this BotType botType)\n        {\n            return botType.HasFlag(BotType.Raider);\n        }\n\n        public static bool HasCultist(this BotType botType)\n        {\n            return botType.HasFlag(BotType.Cultist);\n        }\n\n        public static bool HasBoss(this BotType botType)\n        {\n            return botType.HasFlag(BotType.Boss);\n        }\n", "        public static bool HasBoss(this BotType botType)\n        {\n            return botType.HasFlag(BotType.Boss);\n        }\n\n        public static bool HasFollower(this BotType botType)\n        {\n            return botType.HasFlag(BotType.Follower);\n        }\n\n        public static bool HasBloodhound(this BotType botType)\n        {\n            return botType.HasFlag(BotType.Bloodhound);\n        }\n", "        public static bool HasBloodhound(this BotType botType)\n        {\n            return botType.HasFlag(BotType.Bloodhound);\n        }\n\n        public static bool IsBotEnabled(this BotType enabledTypes, WildSpawnType botType)\n        {\n            // Unchecked to get around cast of usec/bear WildSpawnType added in AkiBotsPrePatcher\n            unchecked\n            {\n                WildSpawnType bear = (WildSpawnType)Aki.PrePatch.AkiBotsPrePatcher.sptBearValue;\n                WildSpawnType usec = (WildSpawnType)Aki.PrePatch.AkiBotsPrePatcher.sptUsecValue;\n\n                bool isPMC = botType == bear || botType == usec;", "                if (isPMC)\n                {\n                    return enabledTypes.HasPmc();\n                }\n\n                switch (botType)\n                {\n                    case WildSpawnType.assault:\n                    case WildSpawnType.assaultGroup:\n                    {\n                        return enabledTypes.HasScav();\n                    }\n                    case WildSpawnType.bossBully:\n                    case WildSpawnType.bossGluhar:\n                    case WildSpawnType.bossKilla:\n                    case WildSpawnType.bossKnight:\n                    case WildSpawnType.bossKojaniy:\n                    case WildSpawnType.bossSanitar:\n                    case WildSpawnType.bossTagilla:\n                    case WildSpawnType.bossTest:\n                    case WildSpawnType.bossZryachiy:\n                    {\n                        return enabledTypes.HasBoss();\n                    }\n                    case WildSpawnType.followerBigPipe:\n                    case WildSpawnType.followerBirdEye:\n                    case WildSpawnType.followerBully:\n                    case WildSpawnType.followerGluharAssault:\n                    case WildSpawnType.followerGluharScout:\n                    case WildSpawnType.followerGluharSecurity:\n                    case WildSpawnType.followerGluharSnipe:\n                    case WildSpawnType.followerKojaniy:\n                    case WildSpawnType.followerSanitar:\n                    case WildSpawnType.followerTagilla:\n                    case WildSpawnType.followerTest:\n                    case WildSpawnType.followerZryachiy:\n                    {\n                        return enabledTypes.HasFollower();\n                    }\n                    case WildSpawnType.exUsec:\n                    case WildSpawnType.pmcBot:\n                    {\n                        return enabledTypes.HasRaider();\n                    }\n                    case WildSpawnType.sectantPriest:\n                    case WildSpawnType.sectantWarrior:\n                    case WildSpawnType.cursedAssault:\n                    {\n                        return enabledTypes.HasCultist();\n                    }\n                    case WildSpawnType.arenaFighterEvent:\n                    {\n                        return enabledTypes.HasBloodhound();\n                    }\n                    default:\n                        return false;\n                }\n            }\n        }\n", "        public static bool IsPMC(WildSpawnType wildSpawnType)\n        {\n            unchecked\n            {\n                WildSpawnType bear = (WildSpawnType)Aki.PrePatch.AkiBotsPrePatcher.sptBearValue;\n                WildSpawnType usec = (WildSpawnType)Aki.PrePatch.AkiBotsPrePatcher.sptUsecValue;\n\n                return wildSpawnType == bear || wildSpawnType == usec;\n            }\n        }\n", "        public static bool IsScav(WildSpawnType wildSpawnType)\n        {\n            return wildSpawnType == WildSpawnType.assault\n                || wildSpawnType == WildSpawnType.assaultGroup;\n        }\n    }\n}\n"]}
{"filename": "LootingBots/utils/EquipmentTypes.cs", "chunked_list": ["using System;\n\nusing EFT.InventoryLogic;\n\nusing BodyArmorClass = GClass2538;\nusing HeadArmorClass = GClass2537;\nusing BackpackItemClass = GClass2584;\nusing TacticalRigItemClass = GClass2585;\n\nnamespace LootingBots.Patch.Util", "\nnamespace LootingBots.Patch.Util\n{\n    [Flags]\n    public enum EquipmentType\n    {\n        Backpack = 1,\n        TacticalRig = 2,\n        ArmoredRig = 4,\n        ArmorVest = 8,\n        Weapon = 16,\n        Grenade = 32,\n        Helmet = 64,\n\n        All = Backpack | TacticalRig | ArmoredRig | ArmorVest | Weapon | Helmet | Grenade\n    }\n", "    public static class EquipmentTypeUtils\n    {\n        public static bool HasBackpack(this EquipmentType equipmentType)\n        {\n            return equipmentType.HasFlag(EquipmentType.Backpack);\n        }\n\n        public static bool HasTacticalRig(this EquipmentType equipmentType)\n        {\n            return equipmentType.HasFlag(EquipmentType.TacticalRig);\n        }\n", "        public static bool HasArmoredRig(this EquipmentType equipmentType)\n        {\n            return equipmentType.HasFlag(EquipmentType.ArmoredRig);\n        }\n\n        public static bool HasArmorVest(this EquipmentType equipmentType)\n        {\n            return equipmentType.HasFlag(EquipmentType.ArmorVest);\n        }\n\n        public static bool HasGrenade(this EquipmentType equipmentType)\n        {\n            return equipmentType.HasFlag(EquipmentType.Grenade);\n        }\n", "        public static bool HasGrenade(this EquipmentType equipmentType)\n        {\n            return equipmentType.HasFlag(EquipmentType.Grenade);\n        }\n\n        public static bool HasWeapon(this EquipmentType equipmentType)\n        {\n            return equipmentType.HasFlag(EquipmentType.Weapon);\n        }\n\n        public static bool HasHelmet(this EquipmentType equipmentType)\n        {\n            return equipmentType.HasFlag(EquipmentType.Helmet);\n        }\n\n        // GClasses based off GClass2645.FindSlotToPickUp", "        public static bool HasHelmet(this EquipmentType equipmentType)\n        {\n            return equipmentType.HasFlag(EquipmentType.Helmet);\n        }\n\n        // GClasses based off GClass2645.FindSlotToPickUp\n        public static bool IsItemEligible(this EquipmentType allowedGear, Item item)\n        {\n            if (item is BodyArmorClass)\n            {\n                return allowedGear.HasArmorVest();\n            }\n        ", "            if (item is BodyArmorClass)\n            {\n                return allowedGear.HasArmorVest();\n            }\n        \n            if (item is HeadArmorClass headwear && headwear.IsArmorMod())\n            {\n                return allowedGear.HasHelmet();\n            }\n\n            if (item is BackpackItemClass)\n            {\n                return allowedGear.HasBackpack();\n            }", "            if (item is BackpackItemClass)\n            {\n                return allowedGear.HasBackpack();\n            }\n            if (item is TacticalRigItemClass tacRig)\n            {\n                return tacRig.IsArmorMod()\n                    ? allowedGear.HasArmoredRig()\n                    : allowedGear.HasTacticalRig();\n            }\n", "            if (item is KnifeClass) { }\n\n            if (item is GrenadeClass) {\n                return allowedGear.HasGrenade();\n            }\n\n            if (item is Weapon)\n            {\n                return allowedGear.HasWeapon();\n            }\n\n            return true;\n        }\n\n    }\n}\n"]}
{"filename": "LootingBots/utils/LootCache.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\n\nnamespace LootingBots.Patch.Util\n{\n    // Cached used to keep track of what lootable are currently being targeted by a bot so that multiple bots\n    // dont try and path to the same lootable\n    public static class ActiveLootCache\n    {\n        public static Dictionary<string, string> ActiveLoot = new Dictionary<string, string>();\n", "        public static Dictionary<string, string> ActiveLoot = new Dictionary<string, string>();\n\n        public static void Reset()\n        {\n            ActiveLoot = new Dictionary<string, string>();\n        }\n\n        public static void CacheActiveLootId(string containerId, string botId)\n        {\n            ActiveLoot.Add(containerId, botId);\n        }\n", "        public static bool IsLootInUse(string containerId)\n        {\n            return ActiveLoot.TryGetValue(containerId, out string _);\n        }\n\n        public static void Cleanup(string lootId)\n        {\n            try\n            {\n                ActiveLoot.Remove(lootId);\n            }", "            catch (Exception e)\n            {\n                LootingBots.LootLog.LogError(e);\n            }\n        }\n    }\n}\n"]}
{"filename": "LootingBots/logics/PeacefulLogic.cs", "chunked_list": ["\ufeffusing DrakiaXYZ.BigBrain.Brains;\nusing EFT;\n\nusing PeacefulNodeClass = GClass177;\n\nnamespace LootingBots.Brain.Logics\n{\n    internal class PeacefulLogic : CustomLogic\n    {\n        private readonly PeacefulNodeClass _baseLogic;\n\n        // PatrolAssault peaceful logic\n        public PeacefulLogic(BotOwner botOwner) : base(botOwner)\n        {\n            _baseLogic = new PeacefulNodeClass(botOwner);\n        }\n", "        private readonly PeacefulNodeClass _baseLogic;\n\n        // PatrolAssault peaceful logic\n        public PeacefulLogic(BotOwner botOwner) : base(botOwner)\n        {\n            _baseLogic = new PeacefulNodeClass(botOwner);\n        }\n\n        public override void Update()\n        {\n            _baseLogic.Update();\n        }\n    }\n}", "        public override void Update()\n        {\n            _baseLogic.Update();\n        }\n    }\n}"]}
{"filename": "LootingBots/logics/FindLootLogic.cs", "chunked_list": ["using System.Text;\n\nusing DrakiaXYZ.BigBrain.Brains;\n\nusing EFT;\nusing EFT.Interactive;\n\nusing LootingBots.Patch.Components;\nusing LootingBots.Patch.Util;\n", "using LootingBots.Patch.Util;\n\nusing UnityEngine;\n\nnamespace LootingBots.Brain.Logics\n{\n    internal class FindLootLogic : CustomLogic\n    {\n        private readonly LootingBrain _lootingBrain;\n        private readonly BotLog _log;\n", "        private readonly LootingBrain _lootingBrain;\n        private readonly BotLog _log;\n\n        private float DetectCorpseDistance\n        {\n            get { return Mathf.Pow(LootingBots.DetectCorpseDistance.Value, 2); }\n        }\n        private float DetectContainerDistance\n        {\n            get { return Mathf.Pow(LootingBots.DetectContainerDistance.Value, 2); }\n        }", "        private float DetectItemDistance\n        {\n            get { return Mathf.Pow(LootingBots.DetectItemDistance.Value, 2); }\n        }\n\n        public FindLootLogic(BotOwner botOwner)\n            : base(botOwner)\n        {\n            _log = new BotLog(LootingBots.LootLog, botOwner);\n            _lootingBrain = botOwner.GetPlayer.gameObject.GetComponent<LootingBrain>();\n        }\n", "        public override void Update()\n        {\n                FindLootable();\n        }\n\n        public void FindLootable()\n        {\n            LootableContainer closestContainer = null;\n            LootItem closestItem = null;\n            BotOwner closestCorpse = null;\n            float shortestDist = -1f;\n\n            // Use the largest detection radius specified in the settings as the main Sphere radius\n            float detectionRadius = Mathf.Max(\n                LootingBots.DetectItemDistance.Value,\n                LootingBots.DetectContainerDistance.Value,\n                LootingBots.DetectCorpseDistance.Value\n            );\n\n            // Cast a sphere on the bot, detecting any Interacive world objects that collide with the sphere\n            Collider[] array = Physics.OverlapSphere(\n                BotOwner.Position,\n                detectionRadius,\n                LootUtils.LootMask,\n                QueryTriggerInteraction.Collide\n            );\n\n            // For each object detected, check to see if it is a lootable container and then calculate its distance from the player", "            foreach (Collider collider in array)\n            {\n                LootableContainer container =\n                    collider.gameObject.GetComponentInParent<LootableContainer>();\n                LootItem lootItem = collider.gameObject.GetComponentInParent<LootItem>();\n                BotOwner corpse = collider.gameObject.GetComponentInParent<BotOwner>();\n\n                bool canLootContainer =\n                    LootingBots.ContainerLootingEnabled.Value.IsBotEnabled(\n                        BotOwner.Profile.Info.Settings.Role\n                    )\n                    && container != null\n                    && !_lootingBrain.IsLootIgnored(container.Id)\n                    && container.isActiveAndEnabled\n                    && container.DoorState != EDoorState.Locked;\n\n                bool canLootItem =\n                    LootingBots.LooseItemLootingEnabled.Value.IsBotEnabled(\n                        BotOwner.Profile.Info.Settings.Role\n                    )\n                    && lootItem != null\n                    && !(lootItem is Corpse)\n                    && lootItem?.ItemOwner?.RootItem != null\n                    && !lootItem.ItemOwner.RootItem.QuestItem\n                    && _lootingBrain.IsValuableEnough(lootItem.ItemOwner.RootItem)\n                    && !_lootingBrain.IsLootIgnored(lootItem.ItemOwner.RootItem.Id);\n\n                bool canLootCorpse =\n                    LootingBots.CorpseLootingEnabled.Value.IsBotEnabled(\n                        BotOwner.Profile.Info.Settings.Role\n                    )\n                    && corpse != null\n                    && corpse.GetPlayer != null\n                    && !_lootingBrain.IsLootIgnored(corpse.name);\n", "                if (canLootContainer || canLootItem || canLootCorpse)\n                {\n                    // If we havent already visted the lootable, calculate its distance and save the lootable with the shortest distance\n                    bool isInRange = IsLootInRange(container, lootItem, corpse, out float dist);\n\n                    // If we are considering a lootable to be the new closest lootable, make sure the loot is in the detection range specified for the type of loot\n                    if (isInRange && (shortestDist == -1f || dist < shortestDist))\n                    {\n                        if (canLootContainer)\n                        {\n                            closestItem = null;\n                            closestCorpse = null;\n                            closestContainer = container;\n                        }", "                        if (canLootContainer)\n                        {\n                            closestItem = null;\n                            closestCorpse = null;\n                            closestContainer = container;\n                        }\n                        else if (canLootCorpse)\n                        {\n                            closestItem = null;\n                            closestContainer = null;\n                            closestCorpse = corpse;\n                        }\n                        else\n                        {\n                            closestCorpse = null;\n                            closestContainer = null;\n                            closestItem = lootItem;\n                        }\n\n                        _lootingBrain.LootObjectCenter = collider.bounds.center;\n                        // Push the center point to the lowest y point in the collider. Extend it further down by .3f to help container positions of jackets snap to a valid NavMesh\n                        _lootingBrain.LootObjectCenter.y =\n                            collider.bounds.center.y - collider.bounds.extents.y - 0.4f;\n                        _lootingBrain.DistanceToLoot = shortestDist;\n                    }\n                }\n            }\n", "            if (closestContainer != null)\n            {\n                _lootingBrain.ActiveContainer = closestContainer;\n                _lootingBrain.LootObjectPosition = closestContainer.transform.position;\n                ActiveLootCache.CacheActiveLootId(closestContainer.Id, BotOwner.name);\n            }\n            else if (closestItem != null)\n            {\n                _lootingBrain.ActiveItem = closestItem;\n                _lootingBrain.LootObjectPosition = closestItem.transform.position;\n                ActiveLootCache.CacheActiveLootId(closestItem.ItemOwner.RootItem.Id, BotOwner.name);\n            }", "            else if (closestCorpse != null)\n            {\n                _lootingBrain.ActiveCorpse = closestCorpse;\n                _lootingBrain.LootObjectPosition = closestCorpse.Transform.position;\n                ActiveLootCache.CacheActiveLootId(closestCorpse.name, BotOwner.name);\n            }\n        }\n\n        /**\n        * Checks to see if any of the found lootable items are within their detection range specified in the mod settings.\n        */", "        public bool IsLootInRange(\n            LootableContainer container,\n            LootItem lootItem,\n            BotOwner corpse,\n            out float dist\n        )\n        {\n            Vector3 vector =\n                BotOwner.Position\n                - (\n                    container?.transform.position\n                    ?? lootItem?.transform.position\n                    ?? corpse.GetPlayer.Transform.position\n                );\n            dist = vector.sqrMagnitude;\n\n            return (container != null && DetectContainerDistance >= dist)\n                || (lootItem != null && DetectItemDistance >= dist)\n                || (corpse != null && DetectCorpseDistance >= dist);\n        }\n    }\n}\n"]}
{"filename": "LootingBots/logics/LootingLogic.cs", "chunked_list": ["using System;\nusing System.Linq;\n\nusing DrakiaXYZ.BigBrain.Brains;\n\nusing EFT;\n\nusing LootingBots.Patch.Components;\nusing LootingBots.Patch.Util;\n", "using LootingBots.Patch.Util;\n\nusing UnityEngine;\nusing UnityEngine.AI;\n\nnamespace LootingBots.Brain.Logics\n{\n    internal class LootingLogic : CustomLogic\n    {\n        private readonly LootingBrain _lootingBrain;\n        private readonly BotLog _log;", "        private readonly LootingBrain _lootingBrain;\n        private readonly BotLog _log;\n        private float _closeEnoughTimer = 0f;\n        private float _moveTimer = 0f;\n        private int _stuckCount = 0;\n        private int _navigationAttempts = 0;\n        private Vector3 _destination;\n\n        public LootingLogic(BotOwner botOwner)\n            : base(botOwner)\n        {\n            _log = new BotLog(LootingBots.LootLog, botOwner);\n            _lootingBrain = botOwner.GetPlayer.gameObject.GetComponent<LootingBrain>();\n        }\n", "        public override void Update()\n        {\n            // Kick off looting logic\n            if (ShouldUpdate())\n            {\n                TryLoot();\n            }\n        }\n\n        public override void Start()\n        {\n            _lootingBrain.DistanceToLoot = 0;\n            _stuckCount = 0;\n            _navigationAttempts = 0;\n            base.Start();\n        }\n\n        // Run looting logic only when the bot is not looting and when the bot has an active item to loot", "        public override void Start()\n        {\n            _lootingBrain.DistanceToLoot = 0;\n            _stuckCount = 0;\n            _navigationAttempts = 0;\n            base.Start();\n        }\n\n        // Run looting logic only when the bot is not looting and when the bot has an active item to loot\n        public bool ShouldUpdate()\n        {\n            return !_lootingBrain.LootTaskRunning\n                && _lootingBrain.HasActiveLootable()\n                && BotOwner.BotState == EBotState.Active;\n        }\n", "        public bool ShouldUpdate()\n        {\n            return !_lootingBrain.LootTaskRunning\n                && _lootingBrain.HasActiveLootable()\n                && BotOwner.BotState == EBotState.Active;\n        }\n\n        private void TryLoot()\n        {\n            try\n            {\n                // Check if the bot is close enough to the destination to commence looting", "                if (_closeEnoughTimer < Time.time)\n                {\n                    _closeEnoughTimer = Time.time + 2f;\n                    bool isCloseEnough = IsCloseEnough();\n\n                    // If the bot has not just looted something, loot the current item since we are now close enough\n                    if (!_lootingBrain.LootTaskRunning && isCloseEnough)\n                    {\n                        // Crouch and look to item\n                        BotOwner.SetPose(0f);\n                        BotOwner.Steering.LookToPoint(_lootingBrain.LootObjectPosition);\n                        _lootingBrain.StartLooting();\n                        return;\n                    }\n                }\n\n                // Try to move the bot to the destination", "                if (_moveTimer < Time.time && !_lootingBrain.LootTaskRunning)\n                {\n                    _moveTimer = Time.time + 4f;\n\n                    // Initiate move to loot. Will return false if the bot is not able to navigate using a NavMesh\n                    bool canMove = TryMoveToLoot();\n\n                    // If there is not a valid path to the loot, ignore the loot forever\n                    if (!canMove)\n                    {\n                        _lootingBrain.HandleNonNavigableLoot();\n                        _stuckCount = 0;\n                    }\n                }\n            }", "                    if (!canMove)\n                    {\n                        _lootingBrain.HandleNonNavigableLoot();\n                        _stuckCount = 0;\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                _log.LogError(e);\n            }\n        }\n\n        /*\n            Check to see if the destination point and the loot object do not have a wall between them by casting a Ray between the two points.\n            Walls should be on the LowPolyCollider LayerMask, so we can assume if we see one of these then we cannot properly loot\n        */", "        public bool HasLOS()\n        {\n            Vector3 rayDirection = _lootingBrain.LootObjectPosition - _destination;\n\n            if (Physics.Raycast(_destination, rayDirection, out RaycastHit hit))\n            {\n                if (hit.collider.gameObject.layer == LootUtils.LowPolyMask)\n                {\n                    _log.LogError(\n                        $\"NO LOS: LowPolyCollider hit {hit.collider.gameObject.layer} {hit.collider.gameObject.name}\"\n                    );\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        /**\n        * Makes the bot look towards the target destination and begin moving towards it. Navigation will be cancelled if the bot has not moved in more than 2 navigation calls, if the destination cannot be snapped to a mesh,\n        * or if the NavPathStatus is anything other than Completed\n        */", "        public bool TryMoveToLoot()\n        {\n            bool canMove = true;\n            try\n            {\n                // Stand and move to lootable\n                BotOwner.SetPose(1f);\n                BotOwner.SetTargetMoveSpeed(1f);\n                BotOwner.Steering.LookToMovingDirection();\n\n                //Increment navigation attempt counter\n                _navigationAttempts++;\n\n                string lootableName =\n                    _lootingBrain.ActiveContainer?.ItemOwner.Items.ToArray()[0].Name.Localized()\n                    ?? _lootingBrain.ActiveItem?.Name.Localized()\n                    ?? _lootingBrain.ActiveCorpse.GetPlayer?.name.Localized();\n\n                // If the bot has not been stuck for more than 2 navigation checks, attempt to navigate to the lootable otherwise ignore the container forever\n                bool isBotStuck = _stuckCount > 1;\n                bool isNavigationLimit = _navigationAttempts > 30;", "                if (!isBotStuck && !isNavigationLimit)\n                {\n                    Vector3 center = _lootingBrain.LootObjectCenter;\n\n                    // Try to snap the desired destination point to the nearest NavMesh to ensure the bot can draw a navigable path to the point\n                    Vector3 pointNearbyContainer = NavMesh.SamplePosition(\n                        center,\n                        out NavMeshHit navMeshAlignedPoint,\n                        1f,\n                        NavMesh.AllAreas\n                    )\n                        ? navMeshAlignedPoint.position\n                        : Vector3.zero;\n\n                    // Since SamplePosition always snaps to the closest point on the NavMesh, sometimes this point is a little too close to the loot and causes the bot to shake violently while looting.\n                    // Add a small amount of padding by pushing the point away from the nearbyPoint\n                    Vector3 padding = center - pointNearbyContainer;\n                    padding.y = 0;\n                    padding.Normalize();\n\n                    // Make sure the point is still snapped to the NavMesh after its been pushed\n                    _destination = pointNearbyContainer = NavMesh.SamplePosition(\n                        center - padding,\n                        out navMeshAlignedPoint,\n                        1f,\n                        navMeshAlignedPoint.mask\n                    )\n                        ? navMeshAlignedPoint.position\n                        : pointNearbyContainer;\n\n                    // Debug for bot loot navigation", "                    if (LootingBots.DebugLootNavigation.Value)\n                    {\n                        GameObjectHelper.DrawSphere(center, 0.5f, Color.red);\n                        GameObjectHelper.DrawSphere(center - padding, 0.5f, Color.green);\n                        if (pointNearbyContainer != Vector3.zero)\n                        {\n                            GameObjectHelper.DrawSphere(pointNearbyContainer, 0.5f, Color.blue);\n                        }\n                    }\n\n                    // If we were able to snap the loot position to a NavMesh, attempt to navigate", "                    if (pointNearbyContainer != Vector3.zero && HasLOS())\n                    {\n                        NavMeshPathStatus pathStatus = BotOwner.GoToPoint(\n                            pointNearbyContainer,\n                            true,\n                            1f,\n                            false,\n                            false,\n                            true\n                        );\n\n                        // Log every 5 movement attempts to reduce noise", "                        if (_navigationAttempts % 5 == 1)\n                        {\n                            _log.LogDebug(\n                                $\"[Attempt: {_navigationAttempts}] Moving to {lootableName} status: {pathStatus}\"\n                            );\n                        }\n\n                        if (pathStatus != NavMeshPathStatus.PathComplete)\n                        {\n                            _log.LogWarning($\"No valid path to: {lootableName}. Ignoring\");\n                            canMove = false;\n                        }\n                    }\n                    else\n                    {\n                        _log.LogWarning(\n                            $\"Unable to snap loot position to NavMesh. Ignoring {lootableName}\"\n                        );\n                        canMove = false;\n                    }\n                }\n                else\n                {", "                    if (isBotStuck)\n                    {\n                        _log.LogError($\"Has been stuck trying to reach: {lootableName}. Ignoring\");\n                    }\n                    else\n                    {\n                        _log.LogError(\n                            $\"Has exceeded the navigation limit (30) trying to reach: {lootableName}. Ignoring\"\n                        );\n                    }\n                    canMove = false;\n                }\n            }", "            catch (Exception e)\n            {\n                _log.LogError(e);\n            }\n\n            return canMove;\n        }\n\n        /**\n        * Check to see if the bot is close enough to the destination so that they can stop moving and start looting\n        */", "        private bool IsCloseEnough()\n        {\n            // Calculate distance from bot to destination\n            float dist;\n            Vector3 vector = BotOwner.Position - _destination;\n            float y = vector.y;\n            vector.y = 0f;\n            dist = vector.sqrMagnitude;\n\n            bool isCloseEnough = dist < 0.85f && Math.Abs(y) < 0.5f;\n\n            // If the bot is not looting anything, check to see if the bot is stuck", "            if (!_lootingBrain.LootTaskRunning && !IsBotStuck(dist))\n            {\n                // Bot has moved, reset stuckCount and update cached distance to container\n                _lootingBrain.DistanceToLoot = dist;\n            }\n\n            return isCloseEnough;\n        }\n\n        // Checks if the bot is stuck moving and increments the stuck counter.\n        public bool IsBotStuck(float dist)\n        {\n            // Calculate change in distance and assume any change less than .25f means the bot hasnt moved.\n            float changeInDist = Math.Abs(_lootingBrain.DistanceToLoot - dist);\n            bool isStuck = changeInDist < 0.25f;\n", "        public bool IsBotStuck(float dist)\n        {\n            // Calculate change in distance and assume any change less than .25f means the bot hasnt moved.\n            float changeInDist = Math.Abs(_lootingBrain.DistanceToLoot - dist);\n            bool isStuck = changeInDist < 0.25f;\n\n            if (isStuck)\n            {\n                _log.LogDebug(\n                    $\"[Stuck: {_stuckCount}] Disance moved since check: {changeInDist}. Dist from loot: {dist}\"\n                );\n\n                // Bot is stuck, update stuck count\n                _stuckCount++;\n            }\n\n            return isStuck;\n        }\n    }\n}\n"]}
