{"filename": "App.xaml.cs", "chunked_list": ["using CommunityToolkit.Mvvm.DependencyInjection;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.UI.Xaml;\nusing System;\nusing System.Diagnostics;\nusing System.Linq;\nusing wingman.Interfaces;\nusing wingman.Services;\nusing wingman.Updates;", "using wingman.Services;\nusing wingman.Updates;\nusing wingman.ViewModels;\nusing wingman.Views;\n\nnamespace wingman\n{\n    public partial class App : Application, IDisposable\n    {\n        private readonly IHost _host;\n        private readonly AppUpdater _appUpdater;\n\n        public App()\n        {\n            InitializeComponent();\n            UnhandledException += App_UnhandledException;\n            _host = BuildHost();\n            Ioc.Default.ConfigureServices(_host.Services);\n\n            _appUpdater = new AppUpdater();\n        }\n", "        private readonly IHost _host;\n        private readonly AppUpdater _appUpdater;\n\n        public App()\n        {\n            InitializeComponent();\n            UnhandledException += App_UnhandledException;\n            _host = BuildHost();\n            Ioc.Default.ConfigureServices(_host.Services);\n\n            _appUpdater = new AppUpdater();\n        }\n", "        public void Dispose()\n        {\n            var serviceTypes = _host.Services.GetType().Assembly.GetTypes()\n                .Where(t => t.GetInterfaces().Contains(typeof(IDisposable)) && !t.IsInterface);\n\n            foreach (var serviceType in serviceTypes)\n            {\n                var serviceInstance = _host.Services.GetService(serviceType);\n                if (serviceInstance is IDisposable disposableService)\n                {\n                    disposableService.Dispose();\n                }\n            }\n            Debug.WriteLine(\"Services disposed.\");\n            _host.Dispose();\n            Debug.WriteLine(\"Host disposed.\");\n        }\n\n", "                if (serviceInstance is IDisposable disposableService)\n                {\n                    disposableService.Dispose();\n                }\n            }\n            Debug.WriteLine(\"Services disposed.\");\n            _host.Dispose();\n            Debug.WriteLine(\"Host disposed.\");\n        }\n\n", "        private void App_UnhandledException(object sender, Microsoft.UI.Xaml.UnhandledExceptionEventArgs e)\n        {\n            var Logger = Ioc.Default.GetRequiredService<ILoggingService>();\n            Logger.LogException(e.Exception.ToString());\n        }\n\n        protected override void OnLaunched(LaunchActivatedEventArgs args)\n        {\n            base.OnLaunched(args);\n\n            Ioc.Default.GetRequiredService<StatusWindow>(); // make sure events are initialized\n            Ioc.Default.GetRequiredService<IEventHandlerService>(); // make sure events are initialized\n\n            IAppActivationService appWindowService = Ioc.Default.GetRequiredService<IAppActivationService>();\n            appWindowService.Activate(args);\n            MainWindow mw = Ioc.Default.GetRequiredService<MainWindow>();\n            mw.SetApp(this);\n\n            _ = _appUpdater.CheckForUpdatesAsync(mw.Dispatcher);\n        }\n", "        private static IHost BuildHost() => Host.CreateDefaultBuilder()\n                .ConfigureServices((context, services) =>\n                {\n                    _ = services\n                        // Services\n                        .AddSingleton<IGlobalHotkeyService, GlobalHotkeyService>()\n                        .AddSingleton<ILoggingService, LoggingService>()\n                        .AddSingleton<IEventHandlerService, EventHandlerService>()\n                        .AddSingleton<IWindowingService, WindowingService>()\n                        .AddSingleton<IMicrophoneDeviceService, MicrophoneDeviceService>()\n                        .AddSingleton<IEditorService, EditorService>()\n                        .AddSingleton<IStdInService, StdInService>()\n                        .AddSingleton<ISettingsService, SettingsService>()\n                        .AddSingleton<IAppActivationService, AppActivationService>()\n                        .AddScoped<IOpenAIAPIService, OpenAIAPIService>()\n                        // ViewModels   \n                        .AddSingleton<AudioInputControlViewModel>()\n                        .AddSingleton<OpenAIControlViewModel>()\n                        .AddSingleton<MainWindowViewModel>()\n                        .AddTransient<ModalControlViewModel>()\n                        .AddSingleton<MainPageViewModel>()\n                        .AddSingleton<FooterViewModel>()\n                        // Views\n                        .AddSingleton<StatusWindow>()\n                        .AddSingleton<MainWindow>();\n\n                })\n                .Build();\n    }\n}"]}
{"filename": "ViewModels/ModalControlViewModel.cs", "chunked_list": ["using CommunityToolkit.Mvvm.ComponentModel;\n\nnamespace wingman.ViewModels\n{\n    public class ModalControlViewModel : ObservableObject\n    {\n        private string _textcontent;\n\n        public string TextContent\n        {\n            get => _textcontent;\n            set => SetProperty(ref _textcontent, value);\n        }\n\n        public ModalControlViewModel()\n        {\n        }\n    }\n\n\n}", "        public string TextContent\n        {\n            get => _textcontent;\n            set => SetProperty(ref _textcontent, value);\n        }\n\n        public ModalControlViewModel()\n        {\n        }\n    }\n\n\n}"]}
{"filename": "ViewModels/MainWindowViewModel.cs", "chunked_list": ["using CommunityToolkit.Mvvm.ComponentModel;\n\nnamespace wingman.ViewModels\n{\n    public partial class MainWindowViewModel : ObservableObject\n    {\n        public MainWindowViewModel()\n        {\n        }\n\n    }\n}"]}
{"filename": "ViewModels/AudioInputControlViewModel.cs", "chunked_list": ["using CommunityToolkit.Mvvm.ComponentModel;\nusing CommunityToolkit.Mvvm.Input;\nusing CommunityToolkit.WinUI;\nusing Microsoft.UI.Dispatching;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Windows.Input;", "using System.Threading.Tasks;\nusing System.Windows.Input;\nusing Windows.Media.Devices;\nusing wingman.Interfaces;\n\nnamespace wingman.ViewModels\n{\n    public class AudioInputControlViewModel : ObservableObject, IDisposable\n    {\n        private readonly IMicrophoneDeviceService _microphoneDeviceService;\n        private readonly ISettingsService _settingsService;\n\n        private List<MicrophoneDevice> _micDevices;", "        private readonly IMicrophoneDeviceService _microphoneDeviceService;\n        private readonly ISettingsService _settingsService;\n\n        private List<MicrophoneDevice> _micDevices;\n        private readonly DispatcherQueue _dispatcherQueue;\n        private readonly TimeSpan _updateInterval = TimeSpan.FromMilliseconds(100);\n        private readonly Stopwatch _stopwatch;\n        private double _lastVolume;\n\n        private List<string> _microphoneDeviceOptions = new List<string>();\n        private readonly EventHandler<double> _microphoneServiceVolumeChanged;", "        private readonly EventHandler<double> _microphoneServiceVolumeChanged;\n        private double _progressBarValue;\n\n        public ICommand RefreshDevices { get; }\n\n        private string _selectedMicrophoneDevice;\n        private bool _disposed = false;\n        private bool _disposing = false;\n\n        public AudioInputControlViewModel(IMicrophoneDeviceService microphoneDeviceService, ISettingsService settingsService)\n        {\n            _microphoneDeviceService = microphoneDeviceService ?? throw new ArgumentNullException(nameof(microphoneDeviceService));\n            _settingsService = settingsService ?? throw new ArgumentNullException(nameof(settingsService));\n\n            _microphoneServiceVolumeChanged = async (sender, volume) =>\n            {", "                if (!_disposing && !_disposed)\n                    await VolumeHandler(volume);\n            };\n\n            _microphoneDeviceService.VolumeChanged += _microphoneServiceVolumeChanged;\n\n            _dispatcherQueue = DispatcherQueue.GetForCurrentThread();\n            _stopwatch = Stopwatch.StartNew();\n\n            RefreshDevices = new RelayCommand(PopulateMicrophoneDeviceOptions);\n            PopulateMicrophoneDeviceOptions();\n\n            var chooseForMe = MediaDevice.GetDefaultAudioCaptureId(AudioDeviceRole.Communications);", "            if (!string.IsNullOrEmpty(chooseForMe))\n            {\n                var chooser = _micDevices.FirstOrDefault(x => x.Info.Id.Equals(chooseForMe));\n                if (chooser != null)\n                    SelectedMicrophoneDevice = chooser.Name;\n            }\n        }\n\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n", "        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        protected virtual void Dispose(bool disposing)\n        {\n            _disposing = disposing;\n\n            if (_disposed)\n                return;\n", "            if (_disposed)\n                return;\n\n            if (disposing)\n            {\n                // Unsubscribe from event handlers\n                if (_microphoneDeviceService != null)\n                {\n                    _microphoneDeviceService.VolumeChanged -= _microphoneServiceVolumeChanged;\n                }\n\n                // Dispose of any disposable objects\n            }\n\n            _disposed = true;\n        }\n", "        private async Task VolumeHandler(double volume)\n        {\n            if (_disposing || _disposed) return;\n\n            _lastVolume = volume;\n            if (_stopwatch.Elapsed >= _updateInterval)\n            {\n                _stopwatch.Restart();\n                await _dispatcherQueue.EnqueueAsync(() =>\n                {\n                    ProgressBarValue = _lastVolume;\n                });\n            }\n        }\n", "        private async void PopulateMicrophoneDeviceOptions()\n        {\n            _micDevices = new List<MicrophoneDevice>();\n            var devices = await _microphoneDeviceService.GetMicrophoneDevicesAsync();\n\n            if (devices == null || devices.Count == 0)\n                return;\n\n            foreach (MicrophoneDevice dev in devices)\n                _micDevices.Add(dev);\n\n            MicrophoneDeviceOptions = devices.Select(d => d.Name).ToList();\n        }\n", "            foreach (MicrophoneDevice dev in devices)\n                _micDevices.Add(dev);\n\n            MicrophoneDeviceOptions = devices.Select(d => d.Name).ToList();\n        }\n\n        public double ProgressBarValue\n        {\n            get => _progressBarValue;\n            set => SetProperty(ref _progressBarValue, value);\n        }\n\n        public List<string> MicrophoneDeviceOptions\n        {\n            get => _microphoneDeviceOptions;\n            set => SetProperty(ref _microphoneDeviceOptions, value);\n        }", "        public string SelectedMicrophoneDevice\n        {\n            get => _selectedMicrophoneDevice;\n            set\n            {\n                if (value != _selectedMicrophoneDevice)\n                {\n                    var newMic = _micDevices.Find(x => x.Name.Equals(value));\n                    _microphoneDeviceService.SetMicrophoneDeviceAsync(newMic);\n                    SetProperty(ref _selectedMicrophoneDevice, value);\n                }\n            }\n        }\n    }\n}"]}
{"filename": "ViewModels/OpenAIControlViewModel.cs", "chunked_list": ["using CommunityToolkit.Mvvm.ComponentModel;\nusing Microsoft.UI.Xaml;\nusing Microsoft.UI.Xaml.Controls.Primitives;\nusing System;\nusing wingman.Interfaces;\nusing wingman.Services;\n\nnamespace wingman.ViewModels\n{\n    public class OpenAIControlViewModel : ObservableObject\n    {", "{\n    public class OpenAIControlViewModel : ObservableObject\n    {\n        private readonly ISettingsService _settingsService;\n        private readonly IGlobalHotkeyService _globalHotkeyService;\n        private readonly ILoggingService _logger;\n        private string _apikey;\n        private bool _keypressed;\n\n        private string _mainhotkey;\n        private string _modalhotkey;", "        private string _mainhotkey;\n        private string _modalhotkey;\n        private string _purgatoryhotkey;\n\n        private bool _trimwhitespaces;\n        private bool _trimnewlines;\n        private bool _appendclipboard;\n        private bool _appendclipboardmodal;\n\n        public OpenAIControlViewModel(ISettingsService settingsService, IOpenAIAPIService openAIService, IGlobalHotkeyService globalHotkeyService, ILoggingService logger)\n        {\n            _settingsService = settingsService;\n            _globalHotkeyService = globalHotkeyService;\n            _logger = logger;\n\n            Main_Hotkey_Toggled = false;\n            Api_Key = _settingsService.Load<string>(WingmanSettings.ApiKey);\n            Main_Hotkey = _settingsService.Load<string>(WingmanSettings.Main_Hotkey);\n            Modal_Hotkey = _settingsService.Load<string>(WingmanSettings.Modal_Hotkey);\n            Trim_Newlines = _settingsService.Load<bool>(WingmanSettings.Trim_Newlines);\n            Trim_Whitespaces = _settingsService.Load<bool>(WingmanSettings.Trim_Whitespaces);\n            Append_Clipboard = _settingsService.Load<bool>(WingmanSettings.Append_Clipboard);\n            Append_Clipboard_Modal = _settingsService.Load<bool>(WingmanSettings.Append_Clipboard_Modal);\n        }\n", "        public bool Append_Clipboard_Modal\n        {\n            get => _appendclipboardmodal;\n            set\n            {\n                _settingsService.Save<bool>(WingmanSettings.Append_Clipboard_Modal, value);\n                SetProperty(ref _appendclipboardmodal, value);\n            }\n        }\n\n        public bool Append_Clipboard\n        {\n            get => _appendclipboard;\n            set\n            {\n                _settingsService.Save<bool>(WingmanSettings.Append_Clipboard, value);\n                SetProperty(ref _appendclipboard, value);\n            }\n        }\n", "        public bool Append_Clipboard\n        {\n            get => _appendclipboard;\n            set\n            {\n                _settingsService.Save<bool>(WingmanSettings.Append_Clipboard, value);\n                SetProperty(ref _appendclipboard, value);\n            }\n        }\n\n        public bool Trim_Whitespaces\n        {\n            get => _trimwhitespaces;\n            set\n            {\n                _settingsService.Save<bool>(WingmanSettings.Trim_Whitespaces, value);\n                SetProperty(ref _trimwhitespaces, value);\n            }\n        }\n", "        public bool Trim_Whitespaces\n        {\n            get => _trimwhitespaces;\n            set\n            {\n                _settingsService.Save<bool>(WingmanSettings.Trim_Whitespaces, value);\n                SetProperty(ref _trimwhitespaces, value);\n            }\n        }\n\n        public bool Trim_Newlines\n        {\n            get => _trimnewlines;\n            set\n            {\n                _settingsService.Save<bool>(WingmanSettings.Trim_Newlines, value);\n                SetProperty(ref _trimnewlines, value);\n            }\n        }\n", "        public bool Trim_Newlines\n        {\n            get => _trimnewlines;\n            set\n            {\n                _settingsService.Save<bool>(WingmanSettings.Trim_Newlines, value);\n                SetProperty(ref _trimnewlines, value);\n            }\n        }\n\n        public string Main_Hotkey\n        {\n            get => _mainhotkey;\n            set\n            {\n                _settingsService.Save(WingmanSettings.Main_Hotkey, value);  // TODO; actually manage hotkey key,value pair relationships\n                SetProperty(ref _mainhotkey, value);\n            }\n        }\n", "        public string Main_Hotkey\n        {\n            get => _mainhotkey;\n            set\n            {\n                _settingsService.Save(WingmanSettings.Main_Hotkey, value);  // TODO; actually manage hotkey key,value pair relationships\n                SetProperty(ref _mainhotkey, value);\n            }\n        }\n\n        public string Modal_Hotkey\n        {\n            get => _modalhotkey;\n            set\n            {\n                _settingsService.Save(WingmanSettings.Modal_Hotkey, value);\n                SetProperty(ref _modalhotkey, value);\n            }\n        }\n", "        public string Modal_Hotkey\n        {\n            get => _modalhotkey;\n            set\n            {\n                _settingsService.Save(WingmanSettings.Modal_Hotkey, value);\n                SetProperty(ref _modalhotkey, value);\n            }\n        }\n\n        public bool Main_Hotkey_Toggled\n        {\n            get => _keypressed;\n            set => SetProperty(ref _keypressed, value);\n        }\n", "        public bool Main_Hotkey_Toggled\n        {\n            get => _keypressed;\n            set => SetProperty(ref _keypressed, value);\n        }\n\n        public async void ConfigureHotkeyCommand(object sender, RoutedEventArgs e)\n        {\n            Main_Hotkey_Toggled = true;\n\n            await _globalHotkeyService.ConfigureHotkeyAsync(NativeKeyboard_OnKeyDown);\n\n            Main_Hotkey_Toggled = false;\n", "            if (!String.IsNullOrEmpty(_purgatoryhotkey))\n            {\n                // try to clear sticky keys\n\n                if ((sender as ToggleButton).Name == \"ConfigMainHotkeyButton\")\n                {\n                    if (_purgatoryhotkey != Modal_Hotkey)\n                        Main_Hotkey = _purgatoryhotkey;\n                    else\n                        _logger.LogError(\"Main hotkey cannot be the same as the modal hotkey.\");\n                }", "                else if ((sender as ToggleButton).Name == \"ConfigModalHotkeyButton\")\n                {\n                    if (_purgatoryhotkey != Main_Hotkey)\n                        Modal_Hotkey = _purgatoryhotkey;\n                    else\n                        _logger.LogError(\"Modal hotkey cannot be the same as the main hotkey.\");\n                }\n\n            }\n        }\n", "        private bool NativeKeyboard_OnKeyDown(string input)\n        {\n            if (input == \"Escape\" || String.IsNullOrEmpty(input))\n            {\n                _purgatoryhotkey = \"\";\n                return true;\n            }\n\n            Main_Hotkey_Toggled = false;\n            _purgatoryhotkey = input;\n            return true;\n        }\n\n", "        public bool IsValidKey()\n        {\n            return _isvalidkey;\n        }\n\n        bool _isvalidkey;\n        public bool IsEnabled\n        {\n            get => _isvalidkey;\n            set\n            {\n                SetProperty(ref _isvalidkey, value);\n            }\n        }\n", "        private bool IsApiKeyValid()\n        {\n            if (String.IsNullOrEmpty(_apikey) || !_apikey.StartsWith(\"sk-\") || _apikey.Length != 51)\n                return false;\n            return true;\n        }\n\n        private readonly string _apikeymessage;\n        public string ApiKeymessage\n        {\n            get\n            {", "        public string ApiKeymessage\n        {\n            get\n            {\n                if (IsApiKeyValid())\n                    return \"Key format valid.\";\n                else\n                    return \"Invalid key format.\";\n            }\n        }\n", "        public string Api_Key\n        {\n            get => _apikey;\n            set\n            {\n                SetProperty(ref _apikey, value);\n                if (!IsApiKeyValid())\n                {\n                    _apikey = \"You must enter a valid OpenAI API Key.\";\n                    IsEnabled = IsApiKeyValid();\n                    OnPropertyChanged(nameof(Api_Key));\n                }\n                else\n                {\n                    _settingsService.TrySave(WingmanSettings.ApiKey, value);\n                    IsEnabled = IsApiKeyValid();\n                    _logger.LogInfo(\"New OpenAI key has a valid format.\");\n                }\n                OnPropertyChanged(nameof(ApiKeymessage));\n            }\n        }\n    }\n\n\n}"]}
{"filename": "ViewModels/FooterViewModel.cs", "chunked_list": ["using CommunityToolkit.Mvvm.ComponentModel;\nusing CommunityToolkit.WinUI;\nusing Microsoft.UI.Dispatching;\nusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing wingman.Interfaces;\n\nnamespace wingman.ViewModels\n{\n    public class FooterViewModel : ObservableObject, IDisposable\n    {", "namespace wingman.ViewModels\n{\n    public class FooterViewModel : ObservableObject, IDisposable\n    {\n        private readonly ISettingsService _settingsService;\n        private readonly ILoggingService _loggingService;\n\n        private readonly DispatcherQueue _dispatcherQueue;\n\n        private readonly EventHandler<string> LoggingService_OnLogEntry;\n        private string _logText = \"\";", "        private readonly EventHandler<string> LoggingService_OnLogEntry;\n        private string _logText = \"\";\n        private bool _disposed = false;\n        private bool _disposing = false;\n\n        public FooterViewModel(ISettingsService settingsService, ILoggingService loggingService)\n        {\n            _settingsService = settingsService;\n            _loggingService = loggingService;\n\n            try\n            {\n                _dispatcherQueue = DispatcherQueue.GetForCurrentThread();\n            }", "            catch (Exception ex)\n            {\n                throw new Exception($\"Couldn't get dispatcherQueue: {ex.Message}\");\n            }\n\n            LoggingService_OnLogEntry = async (sender, logEntry) =>\n            {\n                await LogHandler(logEntry);\n            };\n\n            _loggingService.UIOutputHandler += LoggingService_OnLogEntry;\n        }\n", "        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n            Debug.WriteLine(\"Footerview Disposed\");\n        }\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (_disposed)\n                return;\n\n            _disposing = true;\n            _loggingService.UIOutputHandler -= LoggingService_OnLogEntry;\n            _disposing = false;\n            _disposed=true;\n        }\n\n\n", "            if (_disposed)\n                return;\n\n            _disposing = true;\n            _loggingService.UIOutputHandler -= LoggingService_OnLogEntry;\n            _disposing = false;\n            _disposed=true;\n        }\n\n\n", "        public string LogText\n        {\n            get => _logText;\n            set\n            {\n                SetProperty(ref _logText, value);\n            }\n        }\n\n        private async Task LogHandler(string logBook)\n        {\n            await _dispatcherQueue.EnqueueAsync(async () =>\n            {\n                LogText = logBook;\n            });\n        }\n\n    }\n}", "        private async Task LogHandler(string logBook)\n        {\n            await _dispatcherQueue.EnqueueAsync(async () =>\n            {\n                LogText = logBook;\n            });\n        }\n\n    }\n}"]}
{"filename": "ViewModels/MainPageViewModel.cs", "chunked_list": ["using CommunityToolkit.Mvvm.ComponentModel;\nusing CommunityToolkit.Mvvm.Input;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Windows.Input;\nusing wingman.Interfaces;\nusing wingman.Services;\n", "using wingman.Services;\n\nnamespace wingman.ViewModels\n{\n    public class MainPageViewModel : ObservableObject\n    {\n        private readonly IEditorService _editorService;\n        private readonly IStdInService _stdinService;\n        private readonly ISettingsService _settingsService;\n        private readonly ILoggingService _loggingService;\n\n        private List<string> _stdInTargetOptions = new List<string>();\n        private List<Process> _runningProcesses;\n\n        // Selected values", "        private readonly ISettingsService _settingsService;\n        private readonly ILoggingService _loggingService;\n\n        private List<string> _stdInTargetOptions = new List<string>();\n        private List<Process> _runningProcesses;\n\n        // Selected values\n        private string _selectedStdInTarget;\n        private string _preprompt;\n\n        public MainPageViewModel(IEditorService editorService, IStdInService stdinService, ISettingsService settingsService, ILoggingService loggingService)\n        {\n            _editorService = editorService;\n            _stdinService = stdinService;\n            _loggingService = loggingService;\n\n            InitializeStdInTargetOptions();\n            _settingsService = settingsService;\n            PrePrompt = _settingsService.Load<string>(WingmanSettings.System_Preprompt);\n        }\n", "        private string _preprompt;\n\n        public MainPageViewModel(IEditorService editorService, IStdInService stdinService, ISettingsService settingsService, ILoggingService loggingService)\n        {\n            _editorService = editorService;\n            _stdinService = stdinService;\n            _loggingService = loggingService;\n\n            InitializeStdInTargetOptions();\n            _settingsService = settingsService;\n            PrePrompt = _settingsService.Load<string>(WingmanSettings.System_Preprompt);\n        }\n", "        public string PrePrompt\n        {\n            get => _preprompt;\n            set\n            {\n                SetProperty(ref _preprompt, value);\n                _settingsService.Save<string>(WingmanSettings.System_Preprompt, value);\n            }\n        }\n\n        public List<string> StdInTargetOptions\n        {\n            get => _stdInTargetOptions;\n            set => SetProperty(ref _stdInTargetOptions, value);\n        }\n", "        private string _chatGPTOutput;\n        public string ChatGptOutput\n        {\n            get => _chatGPTOutput;\n            set => SetProperty(ref _chatGPTOutput, value);\n        }\n\n        public string SelectedStdInTarget\n        {\n            get => _selectedStdInTarget;\n            set\n            {", "                if (SetProperty(ref _selectedStdInTarget, value))\n                {\n                    // Find the process with the selected process name and ID\n                    var selectedProcessName = _selectedStdInTarget.Substring(_selectedStdInTarget.IndexOf(']') + 2); // Extract the process name from the selected option\n                    var selectedProcessId = int.Parse(_selectedStdInTarget.Substring(1, _selectedStdInTarget.IndexOf(']') - 1)); // Extract the process ID from the selected option\n                    var selectedProcess = _runningProcesses.FirstOrDefault(p => p.ProcessName == selectedProcessName && p.Id == selectedProcessId);\n                    if (selectedProcess != null)\n                    {\n                        // Set the process in the StdInService\n                        //_stdinService.SetProcess(selectedProcess);\n                    }\n                }\n            }\n        }\n", "        private async void InitializeStdInTargetOptions()\n        {\n\n            _runningProcesses = (await _editorService.GetRunningEditorsAsync()).ToList();\n            var distinctProcesses = _runningProcesses.GroupBy(p => new { p.ProcessName, p.Id }).Select(g => g.First());\n            var targetOptions = distinctProcesses.Select(p => $\"[{p.Id}] {p.ProcessName}\");\n\n            StdInTargetOptions = targetOptions.ToList();\n\n        }\n", "        public ICommand StartCommand => new RelayCommand(Start);\n\n        private void Start()\n        {\n            // Logic to execute when Start button is clicked\n        }\n\n        public ICommand ActivateChatGPT => new AsyncRelayCommand(TestAsync);\n\n        private async Task TestAsync()\n        {\n\n        }\n\n    }\n}", "        private async Task TestAsync()\n        {\n\n        }\n\n    }\n}"]}
{"filename": "Helpers/JsonHelper.cs", "chunked_list": ["using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace wingman.Helpers\n{\n    public static class JsonHelper\n    {\n        public static async Task<T?> DeserializeAsync<T>(string value) => await Task.Run(() => JsonSerializer.Deserialize<T>(value));\n\n        public static async Task<string> SerializeAsync(object value) => await Task.Run(() => JsonSerializer.Serialize(value));\n    }\n}", "        public static async Task<string> SerializeAsync(object value) => await Task.Run(() => JsonSerializer.Serialize(value));\n    }\n}"]}
{"filename": "Helpers/AudioTimer.cs", "chunked_list": ["\ufeffnamespace wingman.Helpers\n{\n    using Microsoft.UI.Xaml;\n    using System;\n\n    public class AudioTimer\n    {\n        private DispatcherTimer _timer;\n        private TimeSpan _elapsedTime;\n\n        public AudioTimer()\n        {\n            _timer = new DispatcherTimer();\n            _timer.Interval = TimeSpan.FromSeconds(1);\n            _timer.Tick += Timer_Tick;\n            _elapsedTime = TimeSpan.Zero;\n        }\n", "        private TimeSpan _elapsedTime;\n\n        public AudioTimer()\n        {\n            _timer = new DispatcherTimer();\n            _timer.Interval = TimeSpan.FromSeconds(1);\n            _timer.Tick += Timer_Tick;\n            _elapsedTime = TimeSpan.Zero;\n        }\n\n        public void Start()\n        {\n            _elapsedTime = TimeSpan.Zero;\n            _timer.Start();\n        }\n", "        public void Start()\n        {\n            _elapsedTime = TimeSpan.Zero;\n            _timer.Start();\n        }\n\n        public void Stop()\n        {\n            _timer.Stop();\n        }\n", "        public TimeSpan ElapsedTime\n        {\n            get { return _elapsedTime; }\n        }\n\n        public int ElapsedTimeInSeconds\n        {\n            get { return _elapsedTime.Seconds; }\n        }\n\n        private void Timer_Tick(object sender, object e)\n        {\n            _elapsedTime += _timer.Interval;\n            // Raise an event to notify subscribers of the elapsed time\n            TickEvent?.Invoke(this, EventArgs.Empty);\n        }\n", "        private void Timer_Tick(object sender, object e)\n        {\n            _elapsedTime += _timer.Interval;\n            // Raise an event to notify subscribers of the elapsed time\n            TickEvent?.Invoke(this, EventArgs.Empty);\n        }\n\n        public event EventHandler TickEvent;\n    }\n\n}\n"]}
{"filename": "Helpers/Converters.cs", "chunked_list": ["\ufeffusing Microsoft.UI;\nusing Microsoft.UI.Xaml;\nusing Microsoft.UI.Xaml.Controls;\nusing Microsoft.UI.Xaml.Data;\nusing Microsoft.UI.Xaml.Media;\nusing System;\nusing Windows.UI;\n\nnamespace wingman.Helpers\n{\n    public class ProgressBarValueToColorConverter : IValueConverter\n    {", "namespace wingman.Helpers\n{\n    public class ProgressBarValueToColorConverter : IValueConverter\n    {\n        public object Convert(object value, Type targetType, object parameter, string\n            uage)\n        {\n            if (value is double progress)\n            {\n                var gradientStops = (GradientStopCollection)Application.Current.Resources[\"ProgressRingGradientStops\"];\n                var gradientStopCount = gradientStops.Count;\n                var position = progress / 100.0 * (gradientStopCount - 1);\n                var index = (int)Math.Floor(position);\n                var color1 = gradientStops[index].Color;\n                var color2 = gradientStops[index + 1].Color;\n                var offset1 = gradientStops[index].Offset;\n                var offset2 = gradientStops[index + 1].Offset;\n                var weight = (position - index) / (offset2 - offset1);\n                var color = Color.FromArgb(\n                    (byte)(color1.A + (color2.A - color1.A) * weight),\n                    (byte)(color1.R + (color2.R - color1.R) * weight),\n                    (byte)(color1.G + (color2.G - color1.G) * weight),\n                    (byte)(color1.B + (color2.B - color1.B) * weight));\n                return new SolidColorBrush(color);\n            }\n            return 0;\n        }\n", "        public object ConvertBack(object value, Type targetType, object parameter, string language)\n        {\n            throw new NotImplementedException();\n        }\n    }\n\n    public class NullToRedBrushConverter : IValueConverter\n    {\n        public object Convert(object value, Type targetType, object parameter, string language)\n        {\n            // If the value is null, return a red brush", "        public object Convert(object value, Type targetType, object parameter, string language)\n        {\n            // If the value is null, return a red brush\n            if (value == null)\n            {\n                return new SolidColorBrush(Colors.Red);\n            }\n            // Otherwise return a transparent brush\n            else\n            {\n                return new SolidColorBrush(Colors.Transparent);\n            }\n        }\n", "        public object ConvertBack(object value, Type targetType, object parameter, string language)\n        {\n            throw new NotImplementedException();\n        }\n    }\n\n\n    public class BoolToApiKeyValidConverter : IValueConverter\n    {\n        public object Convert(object value, Type targetType, object parameter, string language)\n        {", "        public object Convert(object value, Type targetType, object parameter, string language)\n        {\n            if (value is bool isEnabled && isEnabled)\n            {\n                return new FontIcon\n                {\n                    FontFamily = new FontFamily(\"Segoe MDL2 Assets\"),\n                    FontSize = 15,\n                    Foreground = new SolidColorBrush(Colors.Green),\n                    Glyph = \"\\uF78C\"\n                };\n            }\n            else\n            {\n                return new FontIcon\n                {\n                    FontFamily = new FontFamily(\"Segoe MDL2 Assets\"),\n                    FontSize = 15,\n                    Foreground = new SolidColorBrush(Colors.Red),\n                    Glyph = \"\\uF78A\"\n                };\n            }\n        }\n\n", "        public object ConvertBack(object value, Type targetType, object parameter, string language)\n        {\n            throw new NotImplementedException();\n        }\n    }\n\n}\n"]}
{"filename": "Helpers/PromptCleaners.cs", "chunked_list": ["using System;\nusing System.Text.RegularExpressions;\n\nnamespace wingman.Helpers\n{\n    public static class PromptCleaners\n    {\n        public static string CleanBlockIdentifiers(string input)\n        {\n            string pattern = @\"(\\n)?(```(csharp|cpp|c\\+\\+|c|python|ruby|perl|php|html|css|javascript|java|typescript|swift|objectivec|go|kotlin|rust|scala|sql|sh|bash|json|yaml|xml|markdown))(\\n)?|(\\n)?(```)(\\n)?\";\n\n            input = Regex.Replace(input, pattern, \"\");\n\n            return input;\n        }\n\n", "        public static string TrimWhitespaces(string input)\n        {\n            // Split the input string into lines using all line-ending characters\n            string[] lines = input.Split(new[] { \"\\r\\n\", \"\\r\", \"\\n\" }, StringSplitOptions.None);\n\n            // Trim whitespace characters at the beginning and end of each line\n            for (int i = 0; i < lines.Length; i++)\n            {\n                lines[i] = lines[i].Trim();\n            }\n\n            // Join the lines back into a single string using the original line-ending character(s)\n            return string.Join(input.Contains(\"\\r\\n\") ? \"\\r\\n\" : input.Contains(\"\\r\") ? \"\\r\" : \"\\n\", lines);\n        }\n\n", "        public static string TrimNewlines(string input)\n        {\n            return Regex.Replace(input, @\"(\\r\\n|\\r|\\n)+\", \" \");\n        }\n\n\n    }\n}"]}
{"filename": "Helpers/KeyConverter.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing Windows.System;\nusing Windows.UI.Input.Preview.Injection;\n\nnamespace wingman.Helpers\n{\n    public static class KeyConverter\n    {\n        [Flags]\n        public enum ModifierKeys\n        {\n            None = 0,\n            Alt = 1,\n            Control = 2,\n            Shift = 4,\n            Windows = 8,\n        }\n", "        public enum ModifierKeys\n        {\n            None = 0,\n            Alt = 1,\n            Control = 2,\n            Shift = 4,\n            Windows = 8,\n        }\n\n        public static List<InjectedInputKeyboardInfo> NormalizeKeystroke(string keystroke)\n        {\n            // Split the keystroke string into modifier keys and the main key\n            string[] parts = keystroke.Split('+');\n            ModifierKeys modifiers = ModifierKeys.None;\n            string keyString = parts[parts.Length - 1];\n", "        public static List<InjectedInputKeyboardInfo> NormalizeKeystroke(string keystroke)\n        {\n            // Split the keystroke string into modifier keys and the main key\n            string[] parts = keystroke.Split('+');\n            ModifierKeys modifiers = ModifierKeys.None;\n            string keyString = parts[parts.Length - 1];\n\n            // Convert the modifier keys to a ModifierKeys enum value\n            for (int i = 0; i < parts.Length - 1; i++)\n            {\n                switch (parts[i].ToLower())\n                {\n                    case \"ctrl\":\n                    case \"control\":\n                        modifiers |= ModifierKeys.Control;\n                        break;\n                    case \"alt\":\n                        modifiers |= ModifierKeys.Alt;\n                        break;\n                    case \"shift\":\n                        modifiers |= ModifierKeys.Shift;\n                        break;\n                    case \"win\":\n                    case \"windows\":\n                        modifiers |= ModifierKeys.Windows;\n                        break;\n                    default:\n                        throw new ArgumentException(\"Invalid modifier key: \" + parts[i]);\n                }\n            }\n", "            for (int i = 0; i < parts.Length - 1; i++)\n            {\n                switch (parts[i].ToLower())\n                {\n                    case \"ctrl\":\n                    case \"control\":\n                        modifiers |= ModifierKeys.Control;\n                        break;\n                    case \"alt\":\n                        modifiers |= ModifierKeys.Alt;\n                        break;\n                    case \"shift\":\n                        modifiers |= ModifierKeys.Shift;\n                        break;\n                    case \"win\":\n                    case \"windows\":\n                        modifiers |= ModifierKeys.Windows;\n                        break;\n                    default:\n                        throw new ArgumentException(\"Invalid modifier key: \" + parts[i]);\n                }\n            }\n", "            // Convert the main key to a VirtualKey enum value\n            VirtualKey key;\n            switch (keyString.ToLower())\n            {\n                case \"up\":\n                    key = VirtualKey.Up;\n                    break;\n                case \"down\":\n                    key = VirtualKey.Down;\n                    break;\n                case \"right\":\n                    key = VirtualKey.Right;\n                    break;\n                case \"left\":\n                    key = VirtualKey.Left;\n                    break;\n                case \"backspace\":\n                    key = VirtualKey.Back;\n                    break;\n                case \"break\":\n                    key = VirtualKey.Cancel;\n                    break;\n                case \"capslock\":\n                    key = VirtualKey.CapitalLock;\n                    break;\n                case \"delete\":\n                    key = VirtualKey.Delete;\n                    break;\n                case \"end\":\n                    key = VirtualKey.End;\n                    break;\n                case \"enter\":\n                    key = VirtualKey.Enter;\n                    break;\n                case \"esc\":\n                    key = VirtualKey.Escape;\n                    break;\n                case \"help\":\n                    key = VirtualKey.Help;\n                    break;\n                case \"home\":\n                    key = VirtualKey.Home;\n                    break;\n                case \"insert\":\n                    key = VirtualKey.Insert;\n                    break;\n                case \"numlock\":\n                    key = VirtualKey.NumberKeyLock;\n                    break;\n                case \"pagedown\":\n                    key = VirtualKey.PageDown;\n                    break;\n                case \"pageup\":\n                    key = VirtualKey.PageUp;\n                    break;\n                case \"printscreen\":\n                    key = VirtualKey.Print;\n                    break;\n                case \"scrolllock\":\n                    key = VirtualKey.Scroll;\n                    break;\n                case \"space\":\n                    key = VirtualKey.Space;\n                    break;\n                case \"tab\":\n                    key = VirtualKey.Tab;\n                    break;\n                case \"f1\":\n                    key = VirtualKey.F1;\n                    break;\n                case \"f2\":\n                    key = VirtualKey.F2;\n                    break;\n                case \"f3\":\n                    key = VirtualKey.F3;\n                    break;\n                case \"f4\":\n                    key = VirtualKey.F4;\n                    break;\n                case \"f5\":\n                    key = VirtualKey.F5;\n                    break;\n                case \"f6\":\n                    key = VirtualKey.F6;\n                    break;\n                case \"f7\":\n                    key = VirtualKey.F7;\n                    break;\n                case \"f8\":\n                    key = VirtualKey.F8;\n                    break;\n                case \"f9\":\n                    key = VirtualKey.F9;\n                    break;\n                case \"f10\":\n                    key = VirtualKey.F10;\n                    break;\n                case \"f11\":\n                    key = VirtualKey.F11;\n                    break;\n                case \"f12\":\n                    key = VirtualKey.F12;\n                    break;\n                case \"f13\":\n                    key = VirtualKey.F13;\n                    break;\n                case \"f14\":\n                    key = VirtualKey.F14;\n                    break;\n                case \"f15\":\n                    key = VirtualKey.F15;\n                    break;\n                case \"f16\":\n                    key = VirtualKey.F16;\n                    break;\n                default:", "                    if (keyString.Length == 1)\n                    {\n                        key = (VirtualKey)keyString.ToUpper()[0];\n                    }\n                    else\n                    {\n                        throw new ArgumentException(\"Invalid key: \" + keyString);\n                    }\n                    break;\n            }\n\n            // Convert the modifier keys and main key to an input buffer\n            List<InjectedInputKeyboardInfo> inputBuffer = new List<InjectedInputKeyboardInfo>();", "            if (modifiers.HasFlag(ModifierKeys.Control))\n            {\n                inputBuffer.Add(new InjectedInputKeyboardInfo { VirtualKey = (ushort)VirtualKey.Control, KeyOptions = InjectedInputKeyOptions.None });\n            }\n            if (modifiers.HasFlag(ModifierKeys.Alt))\n            {\n                inputBuffer.Add(new InjectedInputKeyboardInfo { VirtualKey = (ushort)VirtualKey.Menu, KeyOptions = InjectedInputKeyOptions.None });\n            }\n            if (modifiers.HasFlag(ModifierKeys.Shift))\n            {\n                inputBuffer.Add(new InjectedInputKeyboardInfo { VirtualKey = (ushort)VirtualKey.Shift, KeyOptions = InjectedInputKeyOptions.None });\n            }", "            if (modifiers.HasFlag(ModifierKeys.Shift))\n            {\n                inputBuffer.Add(new InjectedInputKeyboardInfo { VirtualKey = (ushort)VirtualKey.Shift, KeyOptions = InjectedInputKeyOptions.None });\n            }\n            if (modifiers.HasFlag(ModifierKeys.Windows))\n            {\n                inputBuffer.Add(new InjectedInputKeyboardInfo { VirtualKey = (ushort)VirtualKey.LeftWindows, KeyOptions = InjectedInputKeyOptions.None });\n            }\n\n            inputBuffer.Add(new InjectedInputKeyboardInfo { VirtualKey = (ushort)key, KeyOptions = InjectedInputKeyOptions.None });\n", "            if (modifiers.HasFlag(ModifierKeys.Windows))\n            {\n                inputBuffer.Add(new InjectedInputKeyboardInfo { VirtualKey = (ushort)VirtualKey.LeftWindows, KeyOptions = InjectedInputKeyOptions.KeyUp });\n            }\n            if (modifiers.HasFlag(ModifierKeys.Shift))\n            {\n                inputBuffer.Add(new InjectedInputKeyboardInfo { VirtualKey = (ushort)VirtualKey.Shift, KeyOptions = InjectedInputKeyOptions.KeyUp });\n            }\n            if (modifiers.HasFlag(ModifierKeys.Alt))\n            {\n                inputBuffer.Add(new InjectedInputKeyboardInfo { VirtualKey = (ushort)VirtualKey.Menu, KeyOptions = InjectedInputKeyOptions.KeyUp });\n            }", "            if (modifiers.HasFlag(ModifierKeys.Alt))\n            {\n                inputBuffer.Add(new InjectedInputKeyboardInfo { VirtualKey = (ushort)VirtualKey.Menu, KeyOptions = InjectedInputKeyOptions.KeyUp });\n            }\n            if (modifiers.HasFlag(ModifierKeys.Control))\n            {\n                inputBuffer.Add(new InjectedInputKeyboardInfo { VirtualKey = (ushort)VirtualKey.Control, KeyOptions = InjectedInputKeyOptions.KeyUp });\n            }\n\n            return inputBuffer;\n        }\n    }\n}\n"]}
{"filename": "Helpers/ClipboardHelper.cs", "chunked_list": ["\ufeffusing CommunityToolkit.WinUI;\nusing Microsoft.UI.Dispatching;\nusing System;\nusing System.Threading.Tasks;\nusing Windows.ApplicationModel.DataTransfer;\n\n\nnamespace wingman.Helpers\n{\n    public static class ClipboardHelper\n    {", "{\n    public static class ClipboardHelper\n    {\n        public static async Task SetTextAsync(string? value)\n        {\n            if (!string.IsNullOrWhiteSpace(value))\n            {\n                await DispatcherQueue.GetForCurrentThread().EnqueueAsync(async () =>\n                {\n                    var data = new DataPackage\n                    {\n                        RequestedOperation = DataPackageOperation.Copy\n                    };\n                    data.SetText(value);\n                    Clipboard.SetContent(data);\n                    Clipboard.Flush();\n                });\n            }\n        }\n", "        public static async Task<string?> GetTextAsync()\n        {\n            string? result = null;\n\n            await DispatcherQueue.GetForCurrentThread().EnqueueAsync(async () =>\n            {\n                var data = Clipboard.GetContent();\n                if (data.Contains(StandardDataFormats.Text))\n                {\n                    result = await data.GetTextAsync();\n                }\n            });\n\n            return result;\n        }\n\n    }\n}\n"]}
{"filename": "Helpers/Extensions.cs", "chunked_list": ["using Microsoft.UI;\nusing Microsoft.UI.Input;\nusing Microsoft.UI.Windowing;\nusing Microsoft.UI.Xaml;\nusing System;\nusing System.Reflection;\nusing System.Threading.Tasks;\nusing Windows.Graphics;\nusing WinRT.Interop;\n", "using WinRT.Interop;\n\nnamespace wingman.Helpers\n{\n    public static class TaskExtensions\n    {\n        public static async Task<TResult> TimeoutAfter<TResult>(this Task<TResult> task, TimeSpan timeout)\n        {\n            if (task == await Task.WhenAny(task, Task.Delay(timeout)))\n                return await task;\n            else\n                throw new TimeoutException(\"The operation has timed out.\");\n        }\n    }\n\n", "            if (task == await Task.WhenAny(task, Task.Delay(timeout)))\n                return await task;\n            else\n                throw new TimeoutException(\"The operation has timed out.\");\n        }\n    }\n\n\n    public static class UIElementExtensions\n    {\n        public static void ChangeCursor(this UIElement uiElement, InputCursor cursor)\n        {\n            Type type = typeof(UIElement);\n            type.InvokeMember(\"ProtectedCursor\", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance, null, uiElement, new object[] { cursor });\n        }\n\n\n    }\n", "    public static class UIElementExtensions\n    {\n        public static void ChangeCursor(this UIElement uiElement, InputCursor cursor)\n        {\n            Type type = typeof(UIElement);\n            type.InvokeMember(\"ProtectedCursor\", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.SetProperty | BindingFlags.Instance, null, uiElement, new object[] { cursor });\n        }\n\n\n    }\n", "    public static class Extensions\n    {\n        public static void SetIcon(this Window window, string iconpath)\n        {\n            AppWindow appWindow = window.GetAppWindow();\n            appWindow.SetIcon(iconpath);\n\n            if (appWindow.Presenter is OverlappedPresenter overlappedPresenter)\n            {\n\n\n            }\n        }\n\n\n", "        public static void HideTitleBar(this Window window)\n        {\n            AppWindow appWindow = window.GetAppWindow();\n            appWindow.TitleBar.ExtendsContentIntoTitleBar = true;\n            appWindow.TitleBar.ButtonForegroundColor = Microsoft.UI.Colors.Transparent;\n            appWindow.TitleBar.ButtonBackgroundColor = Microsoft.UI.Colors.Transparent;\n            appWindow.TitleBar.ButtonInactiveBackgroundColor = Microsoft.UI.Colors.Transparent;\n            appWindow.TitleBar.ButtonHoverBackgroundColor = Microsoft.UI.Colors.Transparent;\n            appWindow.TitleBar.ButtonPressedBackgroundColor = Microsoft.UI.Colors.Transparent;\n            appWindow.TitleBar.ButtonInactiveForegroundColor = Microsoft.UI.Colors.Transparent;\n            appWindow.TitleBar.ButtonHoverForegroundColor = Microsoft.UI.Colors.Transparent;\n            appWindow.TitleBar.ButtonPressedForegroundColor = Microsoft.UI.Colors.Transparent;\n            appWindow.TitleBar.ForegroundColor = Microsoft.UI.Colors.Transparent;\n            appWindow.TitleBar.IconShowOptions = IconShowOptions.HideIconAndSystemMenu;\n            appWindow.TitleBar.PreferredHeightOption = 0;\n", "            if (appWindow.Presenter is OverlappedPresenter overlappedPresenter)\n            {\n                overlappedPresenter.IsMinimizable = false;\n                overlappedPresenter.IsMaximizable = false;\n                overlappedPresenter.SetBorderAndTitleBar(false, false);\n            }\n        }\n\n        public static AppWindow GetAppWindow(this Window window)\n        {\n            IntPtr windowHandle = WindowNative.GetWindowHandle(window);\n            WindowId windowId = Win32Interop.GetWindowIdFromWindow(windowHandle);\n            return AppWindow.GetFromWindowId(windowId);\n        }\n\n        public static (int Width, int Height) GetCurrentWindowSize(this Window window)\n        {\n            SizeInt32 size = window.GetAppWindow().Size;\n            return (size.Width, size.Height);\n        }\n", "        public static AppWindow GetAppWindow(this Window window)\n        {\n            IntPtr windowHandle = WindowNative.GetWindowHandle(window);\n            WindowId windowId = Win32Interop.GetWindowIdFromWindow(windowHandle);\n            return AppWindow.GetFromWindowId(windowId);\n        }\n\n        public static (int Width, int Height) GetCurrentWindowSize(this Window window)\n        {\n            SizeInt32 size = window.GetAppWindow().Size;\n            return (size.Width, size.Height);\n        }\n", "        public static void Hide(this Window window)\n        {\n            AppWindow appWindow = window.GetAppWindow();\n            appWindow.Hide();\n        }\n\n        public static void SetWindowPosition(this Window window, int x, int y)\n        {\n            AppWindow appWindow = window.GetAppWindow();\n            PointInt32 position = new(x, y);\n            appWindow.Move(position);\n        }\n", "        public static void SetWindowSize(this Window window, int width, int height)\n        {\n            AppWindow appWindow = window.GetAppWindow();\n            SizeInt32 size = new(width, height);\n            appWindow.Resize(size);\n        }\n\n        public static void SetIsResizable(this Window window, bool value)\n        {\n            AppWindow appWindow = window.GetAppWindow();\n", "            if (appWindow.Presenter is OverlappedPresenter overlappedPresenter)\n            {\n                overlappedPresenter.IsResizable = value;\n                overlappedPresenter.IsMaximizable = value;\n\n                return;\n            }\n\n            throw new NotSupportedException($\"Always on top is not supported with {appWindow.Presenter.Kind}.\");\n        }\n", "        public static void SetNeverFocused(this Window window, bool value)\n        {\n            AppWindow appWindow = window.GetAppWindow();\n\n            if (appWindow == null)\n                return;\n\n            if (appWindow.Presenter is OverlappedPresenter overlappedPresenter)\n            {\n\n                return;\n            }\n\n            throw new NotSupportedException($\"Cna't support never focused window {appWindow.Presenter.Kind}.\");\n        }\n", "        public static void SetIsAlwaysOnTop(this Window window, bool value)\n        {\n            AppWindow appWindow = window.GetAppWindow();\n\n            if (appWindow == null)\n                return;\n\n            if (appWindow.Presenter is OverlappedPresenter overlappedPresenter)\n            {\n                overlappedPresenter.IsAlwaysOnTop = value;\n                return;\n            }\n\n            throw new NotSupportedException($\"Always on top is not supported with {appWindow.Presenter.Kind}.\");\n        }\n", "        public static bool GetIsAlwaysOnTop(this Window window)\n        {\n            AppWindow appWindow = window.GetAppWindow();\n\n            if (appWindow.Presenter is OverlappedPresenter overlappedPresenter)\n            {\n                return overlappedPresenter.IsAlwaysOnTop;\n            }\n\n            throw new NotSupportedException($\"Always on top is not supported with {appWindow.Presenter.Kind}.\");\n        }\n    }\n}"]}
{"filename": "Services/LoggingService.cs", "chunked_list": ["\ufeffusing System;\nusing System.IO;\nusing System.Runtime.CompilerServices;\nusing wingman.Interfaces;\nusing wingman.Services;\n\nnamespace wingman.Interfaces\n{\n    public interface ILoggingService\n    {\n        event EventHandler<string> UIOutputHandler;\n\n        void LogInfo(string message, bool includeReflectionInfo = false, [CallerMemberName] string memberName = \"\", [CallerFilePath] string filePath = \"\", [CallerLineNumber] int lineNumber = 0);\n        void LogDebug(string message, bool includeReflectionInfo = true, [CallerMemberName] string memberName = \"\", [CallerFilePath] string filePath = \"\", [CallerLineNumber] int lineNumber = 0);\n        void LogWarning(string message, bool includeReflectionInfo = true, [CallerMemberName] string memberName = \"\", [CallerFilePath] string filePath = \"\", [CallerLineNumber] int lineNumber = 0);\n        void LogError(string message, bool includeReflectionInfo = true, [CallerMemberName] string memberName = \"\", [CallerFilePath] string filePath = \"\", [CallerLineNumber] int lineNumber = 0);\n        void LogException(string message, bool includeReflectionInfo = true, [CallerMemberName] string memberName = \"\", [CallerFilePath] string filePath = \"\", [CallerLineNumber] int lineNumber = 0);\n        void LogApiQuery(string prompt, string response);\n\n        void SetVerboseLevel(VerboseLevel level);\n    }\n}\n\nnamespace wingman.Services\n{", "    public interface ILoggingService\n    {\n        event EventHandler<string> UIOutputHandler;\n\n        void LogInfo(string message, bool includeReflectionInfo = false, [CallerMemberName] string memberName = \"\", [CallerFilePath] string filePath = \"\", [CallerLineNumber] int lineNumber = 0);\n        void LogDebug(string message, bool includeReflectionInfo = true, [CallerMemberName] string memberName = \"\", [CallerFilePath] string filePath = \"\", [CallerLineNumber] int lineNumber = 0);\n        void LogWarning(string message, bool includeReflectionInfo = true, [CallerMemberName] string memberName = \"\", [CallerFilePath] string filePath = \"\", [CallerLineNumber] int lineNumber = 0);\n        void LogError(string message, bool includeReflectionInfo = true, [CallerMemberName] string memberName = \"\", [CallerFilePath] string filePath = \"\", [CallerLineNumber] int lineNumber = 0);\n        void LogException(string message, bool includeReflectionInfo = true, [CallerMemberName] string memberName = \"\", [CallerFilePath] string filePath = \"\", [CallerLineNumber] int lineNumber = 0);\n        void LogApiQuery(string prompt, string response);\n\n        void SetVerboseLevel(VerboseLevel level);\n    }\n}\n\nnamespace wingman.Services\n{", "    public class LogEntry\n    {\n        public DateTime Timestamp { get; set; }\n        public string Level { get; set; }\n        public string Message { get; set; }\n        public string MemberName { get; set; }\n        public string FilePath { get; set; }\n        public int LineNumber { get; set; }\n        public string Prompt { get; set; }\n        public string Response { get; set; }\n    }\n", "        public string Prompt { get; set; }\n        public string Response { get; set; }\n    }\n\n    public enum VerboseLevel\n    {\n        Verbose,\n        Normal\n    }\n\n    public class LoggingService : ILoggingService\n    {", "    public class LoggingService : ILoggingService\n    {\n        private readonly object _lock = new object();\n        private readonly string _logFile;\n        private string _logBook = $\"Welcome to Wingman!\\r\\n\\r\\n\";\n#if DEBUG\n        private VerboseLevel _verboseLevel = VerboseLevel.Verbose;\n#else\n        private VerboseLevel _verboseLevel = VerboseLevel.Normal;\n#endif\n", "        private VerboseLevel _verboseLevel = VerboseLevel.Normal;\n#endif\n\n        public event EventHandler<string> UIOutputHandler;\n\n        public LoggingService()\n        {\n            _logBook += $\"\\r\\n\";\n            _logBook += $\"1. Make sure you enter a valid OpenAI key.  I can only validate format, not validity.\\r\\n\";\n            _logBook += $\"2. Press and hold your hotkey to record, let go when you're done speaking.\\r\\n\";\n            _logBook += $\"3. Main+Clipboard and Modal+Clipboard means whatever is on your clipboard will be appended to the voice prompt you are sending\\r\\n\";\n            _logBook += $\"4. To configure a hotkey, click the button + hit a hotkey\\r\\n\";\n            _logBook += $\"GIT: https://github.com/dannyr-git/wingman\\r\\n\";\n            _logBook += $\"\\r\\nPlease remember, we're still in Pre-Release!\\r\\n\";\n            _logBook += $\"\\r\\n>>> Log Start: {DateTime.Now:yyyy-MM-dd HH:mm:ss}\\r\\n\";\n\n            string logDirectory = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), \"Wingman\");\n            Directory.CreateDirectory(logDirectory);\n            _logFile = Path.Combine(logDirectory, $\"Wingman{DateTime.Now:yyyyMMdd_HHmmss}.log\");\n        }\n", "        public void LogDebug(string message, bool includeReflectionInfo = true, [CallerMemberName] string memberName = \"\", [CallerFilePath] string filePath = \"\", [CallerLineNumber] int lineNumber = 0)\n        {\n            Log(\"DEBUG\", message, includeReflectionInfo, memberName, filePath, lineNumber);\n        }\n\n        public void LogInfo(string message, bool includeReflectionInfo = false, [CallerMemberName] string memberName = \"\", [CallerFilePath] string filePath = \"\", [CallerLineNumber] int lineNumber = 0)\n        {\n            Log(\"INFO\", message, includeReflectionInfo, memberName, filePath, lineNumber);\n        }\n\n        public void LogWarning(string message, bool includeReflectionInfo = true, [CallerMemberName] string memberName = \"\", [CallerFilePath] string filePath = \"\", [CallerLineNumber] int lineNumber = 0)\n        {\n            Log(\"WARNING\", message, includeReflectionInfo, memberName, filePath, lineNumber);\n        }\n", "        public void LogWarning(string message, bool includeReflectionInfo = true, [CallerMemberName] string memberName = \"\", [CallerFilePath] string filePath = \"\", [CallerLineNumber] int lineNumber = 0)\n        {\n            Log(\"WARNING\", message, includeReflectionInfo, memberName, filePath, lineNumber);\n        }\n\n        public void LogError(string message, bool includeReflectionInfo = true, [CallerMemberName] string memberName = \"\", [CallerFilePath] string filePath = \"\", [CallerLineNumber] int lineNumber = 0)\n        {\n            Log(\"ERROR\", message, includeReflectionInfo, memberName, filePath, lineNumber);\n        }\n\n        public void LogException(string message, bool includeReflectionInfo = true, [CallerMemberName] string memberName = \"\", [CallerFilePath] string filePath = \"\", [CallerLineNumber] int lineNumber = 0)\n        {\n            Log(\"EXCEPTION\", message, includeReflectionInfo, memberName, filePath, lineNumber);\n        }\n", "        public void LogException(string message, bool includeReflectionInfo = true, [CallerMemberName] string memberName = \"\", [CallerFilePath] string filePath = \"\", [CallerLineNumber] int lineNumber = 0)\n        {\n            Log(\"EXCEPTION\", message, includeReflectionInfo, memberName, filePath, lineNumber);\n        }\n\n        public void LogApiQuery(string prompt, string response)\n        {\n            var logEntry = new LogEntry\n            {\n                Timestamp = DateTime.Now,\n                Level = \"API\",\n                Prompt = prompt,\n                Response = response\n            };\n\n            WriteLogEntry(logEntry);\n            UIOutputHandler?.Invoke(this, _logBook);\n        }\n", "        public void SetVerboseLevel(VerboseLevel level)\n        {\n            _verboseLevel = level;\n        }\n\n        private void Log(string level, string message, bool includeReflectionInfo, string memberName, string filePath, int lineNumber)\n        {\n            var logEntry = new LogEntry\n            {\n                Timestamp = DateTime.Now,\n                Level = level,\n                Message = message\n            };\n", "            if (includeReflectionInfo)\n            {\n                logEntry.MemberName = memberName;\n                logEntry.FilePath = filePath;\n                logEntry.LineNumber = lineNumber;\n            }\n\n            WriteLogEntry(logEntry);\n\n            UIOutputHandler?.Invoke(this, _logBook);\n        }\n", "        private void WriteLogEntry(LogEntry logEntry)\n        {\n            string formattedMessage = FormatLogEntry(logEntry);\n\n            lock (_lock)\n            {\n                File.AppendAllText(_logFile, formattedMessage + Environment.NewLine);\n\n                if (_verboseLevel == VerboseLevel.Verbose)\n                    _logBook += formattedMessage + Environment.NewLine;\n                else if (logEntry.Level != \"DEBUG\" && logEntry.Level != \"EXCEPTION\")\n                    _logBook += $\"{logEntry.Timestamp:HH:mm:ss} [{logEntry.Level}] {logEntry.Message}\" + Environment.NewLine;\n            }\n        }\n", "                if (_verboseLevel == VerboseLevel.Verbose)\n                    _logBook += formattedMessage + Environment.NewLine;\n                else if (logEntry.Level != \"DEBUG\" && logEntry.Level != \"EXCEPTION\")\n                    _logBook += $\"{logEntry.Timestamp:HH:mm:ss} [{logEntry.Level}] {logEntry.Message}\" + Environment.NewLine;\n            }\n        }\n\n        private string FormatLogEntry(LogEntry logEntry)\n        {\n            if (logEntry.Level == \"API\")\n            {\n                return $\"{logEntry.Timestamp:yyyy-MM-dd HH:mm:ss.fff} [{logEntry.Level}] Prompt: {logEntry.Prompt} | Response: {logEntry.Response}\";\n            }\n\n            string reflectionInfo = string.Empty;\n", "            if (logEntry.Level == \"API\")\n            {\n                return $\"{logEntry.Timestamp:yyyy-MM-dd HH:mm:ss.fff} [{logEntry.Level}] Prompt: {logEntry.Prompt} | Response: {logEntry.Response}\";\n            }\n\n            string reflectionInfo = string.Empty;\n\n            if (!string.IsNullOrEmpty(logEntry.MemberName) && !string.IsNullOrEmpty(logEntry.FilePath))\n            {\n                reflectionInfo = $\" {Path.GetFileName(logEntry.FilePath)}:{logEntry.LineNumber} {logEntry.MemberName} -\";\n            }\n\n            return $\"{logEntry.Timestamp:yyyy-MM-dd HH:mm:ss.fff} [{logEntry.Level}]{reflectionInfo} {logEntry.Message}\";\n        }\n    }\n}"]}
{"filename": "Services/AppActivationService.cs", "chunked_list": ["using System;\nusing System.Diagnostics;\nusing wingman.Interfaces;\nusing wingman.Views;\n\nnamespace wingman.Services\n{\n    public class AppActivationService : IAppActivationService, IDisposable\n    {\n        private readonly MainWindow _mainWindow;\n        private readonly ISettingsService _settingsService;\n\n        public AppActivationService(\n            MainWindow mainWindow,\n            ISettingsService settingsService)\n        {\n            _mainWindow = mainWindow;\n            _settingsService = settingsService;\n        }\n", "        private readonly MainWindow _mainWindow;\n        private readonly ISettingsService _settingsService;\n\n        public AppActivationService(\n            MainWindow mainWindow,\n            ISettingsService settingsService)\n        {\n            _mainWindow = mainWindow;\n            _settingsService = settingsService;\n        }\n", "        public void Activate(object activationArgs)\n        {\n            InitializeServices();\n            _mainWindow.Activate();\n        }\n\n        public void Dispose()\n        {\n            Debug.WriteLine(\"Appactivate Disposed\");\n            //    _app.Dispose();\n        }\n", "        private void InitializeServices()\n        {\n        }\n    }\n}"]}
{"filename": "Services/OpenAIAPIService.cs", "chunked_list": ["\ufeffusing OpenAI.GPT3;\nusing OpenAI.GPT3.Interfaces;\nusing OpenAI.GPT3.Managers;\nusing OpenAI.GPT3.ObjectModels;\nusing OpenAI.GPT3.ObjectModels.RequestModels;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices.WindowsRuntime;\nusing System.Threading.Tasks;", "using System.Runtime.InteropServices.WindowsRuntime;\nusing System.Threading.Tasks;\nusing Windows.Storage;\nusing Windows.Storage.FileProperties;\nusing Windows.Storage.Streams;\nusing wingman.Helpers;\nusing wingman.Interfaces;\n\nnamespace wingman.Services\n{\n    public class OpenAIAPIService : IOpenAIAPIService\n    {", "namespace wingman.Services\n{\n    public class OpenAIAPIService : IOpenAIAPIService\n    {\n        private readonly IOpenAIService? _openAIService;\n        private readonly ISettingsService settingsService;\n        private readonly ILoggingService Logger;\n        private readonly string _apikey;\n        private readonly bool _disposed;\n\n        public OpenAIAPIService(ISettingsService settingsService, ILoggingService logger)\n        {\n            this.settingsService = settingsService;\n            this.Logger = logger;\n            _apikey = settingsService.Load<string>(WingmanSettings.ApiKey);\n", "        private readonly bool _disposed;\n\n        public OpenAIAPIService(ISettingsService settingsService, ILoggingService logger)\n        {\n            this.settingsService = settingsService;\n            this.Logger = logger;\n            _apikey = settingsService.Load<string>(WingmanSettings.ApiKey);\n\n            if (String.IsNullOrEmpty(_apikey))\n            {\n                _apikey = \"Api Key Is Null or Empty\";\n                Logger.LogError(\"_apikey\");\n            }\n\n            _openAIService = new OpenAIService(new OpenAiOptions()\n            {\n                ApiKey =  _apikey\n            });\n        }\n", "            if (String.IsNullOrEmpty(_apikey))\n            {\n                _apikey = \"Api Key Is Null or Empty\";\n                Logger.LogError(\"_apikey\");\n            }\n\n            _openAIService = new OpenAIService(new OpenAiOptions()\n            {\n                ApiKey =  _apikey\n            });\n        }\n", "        public async Task<bool> IsApiKeyValid()\n        {\n            if (String.IsNullOrEmpty(_apikey) || !_apikey.StartsWith(\"sk-\") || _apikey.Length != 51)\n                return false;\n            return true;\n        }\n\n        public async Task<string> GetResponse(string prompt)\n        {\n            if (!await IsApiKeyValid())\n            {\n                Logger.LogError(\"OpenAI API Key is Invalid.\");\n                return \"Invalid API Key.  Please check your settings.\";\n            }\n\n            Logger.LogDebug(\"Sending prompt to OpenAI API\");\n            var completionResult = await _openAIService.ChatCompletion.CreateCompletion(new ChatCompletionCreateRequest\n            {\n                Messages = new List<ChatMessage>\n                {\n                    ChatMessage.FromSystem(settingsService.Load<string>(WingmanSettings.System_Preprompt)),\n                    ChatMessage.FromUser(prompt),\n                },\n                Model = Models.ChatGpt3_5Turbo,\n                MaxTokens = 2048,\n                //Model = Models.CodeDavinciV2,\n                //MaxTokens = 8001\n            });\n", "            if (!await IsApiKeyValid())\n            {\n                Logger.LogError(\"OpenAI API Key is Invalid.\");\n                return \"Invalid API Key.  Please check your settings.\";\n            }\n\n            Logger.LogDebug(\"Sending prompt to OpenAI API\");\n            var completionResult = await _openAIService.ChatCompletion.CreateCompletion(new ChatCompletionCreateRequest\n            {\n                Messages = new List<ChatMessage>\n                {\n                    ChatMessage.FromSystem(settingsService.Load<string>(WingmanSettings.System_Preprompt)),\n                    ChatMessage.FromUser(prompt),\n                },\n                Model = Models.ChatGpt3_5Turbo,\n                MaxTokens = 2048,\n                //Model = Models.CodeDavinciV2,\n                //MaxTokens = 8001\n            });\n", "            if (completionResult.Successful)\n            {\n                Logger.LogDebug(\"OpenAI API Response Received\");\n\n\n                var maid = completionResult.Choices.First().Message.Content;\n                var lines = maid.Split(new[] { Environment.NewLine }, StringSplitOptions.None);\n                var dbgstr = \"Raw Prompt :\\r\\n\";\n                foreach (var line in lines)\n                    dbgstr += \">>> \" + line;\n                Logger.LogDebug(dbgstr);\n\n                maid = PromptCleaners.CleanBlockIdentifiers(maid);", "                foreach (var line in lines)\n                    dbgstr += \">>> \" + line;\n                Logger.LogDebug(dbgstr);\n\n                maid = PromptCleaners.CleanBlockIdentifiers(maid);\n                if (settingsService.Load<bool>(WingmanSettings.Trim_Whitespaces))\n                    maid = PromptCleaners.TrimWhitespaces(maid);\n                if (settingsService.Load<bool>(WingmanSettings.Trim_Newlines))\n                    maid = PromptCleaners.TrimNewlines(maid);\n                return maid;\n            }\n            else\n            {\n                var result = completionResult.Error?.Message;\n", "                if (result != null && result.Contains(\"Incorrect API key provided\"))\n                {\n                    Logger.LogError(\"You aren't using a valid OpenAI API Key.\");\n                }\n                else\n                {\n                    Logger.LogError(\"OpenAI API Failed, Reason :\");\n                    if (result == null)\n                        Logger.LogError(\"Result was null.\");\n                    else\n                        Logger.LogError(result);\n                }\n\n                return String.Empty;\n            }\n        }\n", "        public async Task<byte[]> ReadFileBytes(StorageFile file)\n        {\n            if (file == null)\n            {\n                Logger.LogException(\"File is null\");\n                throw new ArgumentNullException(nameof(file));\n            }\n\n            BasicProperties fileProperties;\n\n            try\n            {\n                fileProperties = await file.GetBasicPropertiesAsync();\n            }", "            catch (TaskCanceledException e)\n            {\n                Logger.LogException($\"Task cancelled exception: {e.Message}\");\n                throw;\n            }\n            catch (Exception e)\n            {\n                Logger.LogException($\"Failed to get basic properties: {e.Message}\");\n                throw;\n            }\n\n            var fileSize = fileProperties.Size;\n            byte[] fileBytes = new byte[fileSize];\n\n            Logger.LogDebug(\"Reading audio file to byte array\");\n            try\n            {", "                using (var fileStream = await file.OpenAsync(FileAccessMode.Read))\n                {\n                    await fileStream.ReadAsync(fileBytes.AsBuffer(), (uint)fileSize, InputStreamOptions.None);\n                }\n            }\n            catch (Exception e)\n            {\n                Logger.LogException($\"Failed to read file bytes: {e.Message}\");\n                throw;\n            }\n\n            return fileBytes;\n        }\n\n", "        public async Task<string> GetWhisperResponse(StorageFile inmp3)\n        {\n\n            var fileBytes = await ReadFileBytes(inmp3);\n\n            Logger.LogDebug(\"Sending audio to Whisper API\");\n            //sult.Prompt\n            var completionResult = await _openAIService.Audio.CreateTranscription(new AudioCreateTranscriptionRequest\n            {\n                Prompt = \"The following transcription will be contextually based around programming, coding, or scripting.  It might include technical language and programming terminology.\",\n                Model = Models.WhisperV1,\n                ResponseFormat = StaticValues.AudioStatics.ResponseFormat.Text,\n                File = fileBytes,\n                FileName = inmp3.Name,\n            });\n", "            if (completionResult.Successful && !completionResult.Text.Contains(\"\\\"type\\\": \\\"invalid_request_error\\\",\"))\n            {\n                //Logger.LogInfo($\"Whisper API Response: \" + completionResult.Text);  // sent elsewhere for now\n                return completionResult.Text;\n            }\n            else\n            {\n                var result = completionResult.Error?.Message;\n\n                if (result != null && result.Contains(\"Incorrect API key provided\"))\n                {\n                    Logger.LogError(\"You aren't using a valid OpenAI API Key.\");\n                }\n                else\n                {\n                    Logger.LogError(\"Whisper API Failed, Reason :\");", "                if (result != null && result.Contains(\"Incorrect API key provided\"))\n                {\n                    Logger.LogError(\"You aren't using a valid OpenAI API Key.\");\n                }\n                else\n                {\n                    Logger.LogError(\"Whisper API Failed, Reason :\");\n                    if (result == null)\n                        Logger.LogError(\"Result was null.\");\n                    else\n                        Logger.LogError(result);\n                }\n\n                return String.Empty;\n            }\n        }\n\n    }\n}"]}
{"filename": "Services/SettingsService.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text.Json;\nusing Windows.ApplicationModel;\nusing wingman.Interfaces;\n\nnamespace wingman.Services\n{\n    public enum WingmanSettings\n    {\n        Version,\n        ApiKey,\n        Main_Hotkey,\n        Modal_Hotkey,\n        Trim_Whitespaces,\n        Trim_Newlines,\n        Append_Clipboard,\n        Append_Clipboard_Modal,\n        System_Preprompt\n    }\n", "{\n    public enum WingmanSettings\n    {\n        Version,\n        ApiKey,\n        Main_Hotkey,\n        Modal_Hotkey,\n        Trim_Whitespaces,\n        Trim_Newlines,\n        Append_Clipboard,\n        Append_Clipboard_Modal,\n        System_Preprompt\n    }\n", "    public static class WingmanSettingsDefaults\n    {\n        public const string ApiKey = \"sk-INSERTYOUROPENAIKEY\";\n        public const string Main_Hotkey = \"Alt+`\";\n        public const string Modal_Hotkey = \"`\";\n        public const string Trim_Whitespaces = \"false\";\n        public const string Trim_Newlines = \"false\";\n        public const string Append_Clipboard = \"false\";\n        public const string Append_Clipboard_Modal = \"false\";\n        public const string System_Preprompt = \"You are a programming assistant. You are only allowed to respond with the raw code. Do not generate explanations. Do not preface. Do not follow-up after the code.\";\n    }\n\n", "        public const string Append_Clipboard_Modal = \"false\";\n        public const string System_Preprompt = \"You are a programming assistant. You are only allowed to respond with the raw code. Do not generate explanations. Do not preface. Do not follow-up after the code.\";\n    }\n\n\n    public class SettingsService : ISettingsService\n    {\n        public readonly string SettingsFolderName = \"Wingman\";\n        public readonly string SettingsFileName = \"Wingman.settings\";\n\n        private readonly Dictionary<WingmanSettings, string> _settings; private readonly string _settingsFilePath;", "        public readonly string SettingsFileName = \"Wingman.settings\";\n\n        private readonly Dictionary<WingmanSettings, string> _settings; private readonly string _settingsFilePath;\n        private readonly ILoggingService _loggingService;\n        public SettingsService(ILoggingService loggingService)\n        {\n            _loggingService = loggingService; _settings = new Dictionary<WingmanSettings, string>();\n            _settingsFilePath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), SettingsFolderName, SettingsFileName);\n\n            if (!Directory.Exists(Path.GetDirectoryName(_settingsFilePath)))\n            {\n                Directory.CreateDirectory(Path.GetDirectoryName(_settingsFilePath));\n            }\n", "            if (!Directory.Exists(Path.GetDirectoryName(_settingsFilePath)))\n            {\n                Directory.CreateDirectory(Path.GetDirectoryName(_settingsFilePath));\n            }\n\n            if (!File.Exists(_settingsFilePath))\n            {\n                InitializeDefaultSettings();\n                SaveSettings();\n            }\n            else\n            {\n                var json = File.ReadAllText(_settingsFilePath);", "                if (json != null)\n                {\n                    try\n                    {\n                        _settings = JsonSerializer.Deserialize<Dictionary<WingmanSettings, string>>(json);\n                    }\n                    catch (JsonException)\n                    {\n                        _loggingService.LogWarning(\"Settings JSON is invalid, testing for old format...\");\n                        try\n                        {\n                            Dictionary<string, Dictionary<string, string>> oldSettings = JsonSerializer.Deserialize<Dictionary<string, Dictionary<string, string>>>(json);\n\n                            _settings = new Dictionary<WingmanSettings, string>();\n", "                            foreach (var pair in oldSettings[\"User\"])\n                            {\n                                if (Enum.TryParse(pair.Key, out WingmanSettings key))\n                                {\n                                    _settings[key] = pair.Value;\n                                }\n                            }\n                        }\n                        catch (JsonException)\n                        {\n                            _loggingService.LogWarning(\"Settings not salvagable, reverting...\");\n                            _settings = null;\n                        }\n                    }\n", "                        catch (JsonException)\n                        {\n                            _loggingService.LogWarning(\"Settings not salvagable, reverting...\");\n                            _settings = null;\n                        }\n                    }\n\n                    if (_settings != null && NeedsUpdate())\n                    {\n                        _loggingService.LogWarning(\"Old settings file detected, removing...\");\n                        File.Delete(_settingsFilePath);\n                        _loggingService.LogWarning(\"Importing old values if possible...\");\n                        ImportExistingSettings(_settings);\n                        EnsureAllSettingsPresent();\n                        //InitializeDefaultSettings();\n                        SaveSettings();\n                    }\n                    else\n                    {\n                        _loggingService.LogInfo(\"Sanitizing settings...\");\n                        EnsureAllSettingsPresent();\n                    }\n                }\n                else\n                {\n                    _loggingService.LogError(\"Settings JSON is empty, reverting to defaults...\"); InitializeDefaultSettings(); SaveSettings();\n                }\n            }\n        }\n", "        private void ImportExistingSettings(Dictionary<WingmanSettings, string> existingSettings)\n        {\n            foreach (var setting in existingSettings)\n            {\n                if (Enum.IsDefined(typeof(WingmanSettings), setting.Key))\n                {\n                    _settings[setting.Key] = setting.Value;\n                }\n            }\n        }\n", "        private bool NeedsUpdate()\n        {\n            var currentVersion = GetVersionFromAppxManifest();\n            var savedVersion = Load<string>(WingmanSettings.Version);\n\n            return savedVersion != currentVersion;\n        }\n\n        private string GetVersionFromAppxManifest()\n        {\n            var packageVersion = Package.Current.Id.Version;\n            return $\"{packageVersion.Major}.{packageVersion.Minor}.{packageVersion.Build}.{packageVersion.Revision}\";\n        }\n", "        private string GetVersionFromAppxManifest()\n        {\n            var packageVersion = Package.Current.Id.Version;\n            return $\"{packageVersion.Major}.{packageVersion.Minor}.{packageVersion.Build}.{packageVersion.Revision}\";\n        }\n\n        private void InitializeDefaultSettings()\n        {\n            foreach (WingmanSettings setting in Enum.GetValues(typeof(WingmanSettings)))\n            {\n                _settings[setting] = GetDefault(setting);\n            }\n        }\n", "            foreach (WingmanSettings setting in Enum.GetValues(typeof(WingmanSettings)))\n            {\n                _settings[setting] = GetDefault(setting);\n            }\n        }\n\n        private void EnsureAllSettingsPresent()\n        {\n            bool shouldSave = false;\n\n            foreach (WingmanSettings setting in Enum.GetValues(typeof(WingmanSettings)))\n            {", "            foreach (WingmanSettings setting in Enum.GetValues(typeof(WingmanSettings)))\n            {\n                if (setting == WingmanSettings.Version)\n                {\n                    _settings[setting] = GetDefault(setting);\n                }\n                else if (!_settings.ContainsKey(setting))\n                {\n                    _loggingService.LogWarning(String.Format(\"Setting \\\"{0}\\\" missing from settings\", Enum.GetName(setting)));\n                    shouldSave = true;\n                    _settings[setting] = GetDefault(setting);\n                    _loggingService.LogWarning(String.Format(\"\\\"{0}\\\" set to \\\"{1}\\\"\", Enum.GetName(setting), _settings[setting]));\n                }\n            }\n", "            if (shouldSave)\n            {\n                SaveSettings();\n            }\n        }\n\n        private string GetDefault(WingmanSettings setting)\n        {\n            return setting switch\n            {\n                WingmanSettings.Version => GetVersionFromAppxManifest(),\n                WingmanSettings.ApiKey => WingmanSettingsDefaults.ApiKey,\n                WingmanSettings.Main_Hotkey => WingmanSettingsDefaults.Main_Hotkey,\n                WingmanSettings.Modal_Hotkey => WingmanSettingsDefaults.Modal_Hotkey,\n                WingmanSettings.Trim_Whitespaces => WingmanSettingsDefaults.Trim_Whitespaces,\n                WingmanSettings.Trim_Newlines => WingmanSettingsDefaults.Trim_Newlines,\n                WingmanSettings.Append_Clipboard => WingmanSettingsDefaults.Append_Clipboard,\n                WingmanSettings.Append_Clipboard_Modal => WingmanSettingsDefaults.Append_Clipboard_Modal,\n                WingmanSettings.System_Preprompt => WingmanSettingsDefaults.System_Preprompt,\n                _ => throw new ArgumentOutOfRangeException(nameof(setting), setting, null)\n            };\n        }\n\n", "        private void SaveSettings()\n        {\n            var options = new JsonSerializerOptions\n            {\n                WriteIndented = true\n            };\n\n            var json = JsonSerializer.Serialize(_settings, options);\n            File.WriteAllText(_settingsFilePath, json);\n        }\n\n        public T? Load<T>(WingmanSettings key)\n        {\n            string keyString = Enum.GetName(typeof(WingmanSettings), key);", "            if (_settings.TryGetValue(key, out var value))\n            {\n                return (T)Convert.ChangeType(value, typeof(T));\n            }\n            return default;\n        }\n\n        public bool TryLoad<T>(WingmanSettings key, out T? value)\n        {\n            value = Load<T>(key);\n\n            return value != null;\n        }\n", "        public void Save<T>(WingmanSettings key, T value)\n        {\n            var stringValue = value?.ToString() ?? \"\";\n            _settings[key] = stringValue;\n\n            SaveSettings();\n        }\n\n        public bool TrySave<T>(WingmanSettings key, T value)\n        {\n            try\n            {\n                Save(key, value);\n                return true;\n            }", "        public bool TrySave<T>(WingmanSettings key, T value)\n        {\n            try\n            {\n                Save(key, value);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _loggingService.LogException($\"Failed to save setting {Enum.GetName(typeof(WingmanSettings), key)}.\" + ex.ToString()); return false;\n            }\n        }\n    }\n}"]}
{"filename": "Services/WindowingService.cs", "chunked_list": ["\ufeffusing Microsoft.UI.Xaml;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing wingman.Views;\n\nnamespace wingman.Interfaces\n{\n    public class WindowingService : IWindowingService, IDisposable\n    {", "{\n    public class WindowingService : IWindowingService, IDisposable\n    {\n        private readonly List<ModalWindow> openWindows = new List<ModalWindow>();\n        ILoggingService Logger;\n        private bool _disposed = false;\n        private bool _disposing = false;\n\n        public WindowingService(\n            ILoggingService logger)\n        {\n            Logger = logger;\n        }\n", "        protected virtual void Dispose(bool disposing)\n        {\n            if (!_disposed)\n            {\n                if (disposing)\n                {\n                    foreach (var window in openWindows)\n                    {\n                        window.Closed -= Dialog_Closed;\n                        window.Close();\n                    }\n                    _disposed = true;\n                }\n            }\n        }\n", "        public void Dispose()\n        {\n            _disposing = true;\n            Dispose(_disposing);\n            GC.SuppressFinalize(this);\n            Debug.WriteLine(\"WindowingService disposed\");\n        }\n\n        public async Task CreateCodeModal(string content)\n        {\n            ModalWindow dialog = new ModalWindow(content, 640, 480);\n            dialog.Closed += Dialog_Closed;\n            dialog.Title = \"Wingman Codeblock\";\n            dialog.Activate();\n\n            openWindows.Add(dialog);\n            Logger.LogDebug(\"Modal activated.\");\n        }\n", "        public async Task CreateCodeModal(string content)\n        {\n            ModalWindow dialog = new ModalWindow(content, 640, 480);\n            dialog.Closed += Dialog_Closed;\n            dialog.Title = \"Wingman Codeblock\";\n            dialog.Activate();\n\n            openWindows.Add(dialog);\n            Logger.LogDebug(\"Modal activated.\");\n        }\n", "        public async Task CreateModal(string content, string title = \"Modal\", int width = 640, int height = 480, bool isresizable = true, bool activated = true)\n        {\n            ModalWindow dialog = new ModalWindow(content, width, height, isresizable);\n\n            dialog.Closed += Dialog_Closed;\n            dialog.Title = title;\n\n            if (activated)\n                dialog.Activate();\n\n            openWindows.Add(dialog);\n            Logger.LogDebug(\"Modal activated.\");\n        }\n", "        private void Dialog_Closed(object sender, WindowEventArgs e)\n        {\n            if (sender is ModalWindow window && openWindows.Contains(window))\n            {\n                openWindows.Remove(window);\n            }\n            Logger.LogDebug(\"Modal closed.\");\n        }\n\n        public event EventHandler<string>? EventStatusChanged;\n        public event EventHandler? EventForceStatusHide;\n", "        public event EventHandler<string>? EventStatusChanged;\n        public event EventHandler? EventForceStatusHide;\n\n        public void ForceStatusHide()\n        {\n            if (EventForceStatusHide != null && !_disposed && !_disposing)\n            {\n                EventForceStatusHide(this, EventArgs.Empty);\n            }\n        }\n", "        public void UpdateStatus(string currentStatus)\n        {\n            if (EventStatusChanged != null && !_disposed && !_disposing)\n                EventStatusChanged?.Invoke(this, currentStatus);\n        }\n\n\n    }\n}\n"]}
{"filename": "Services/GlobalHotkeyService.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing WindowsHook;\nusing wingman.Interfaces;\nusing static wingman.Helpers.KeyConverter;\n\nnamespace wingman.Services", "\nnamespace wingman.Services\n{\n    public class KeyCombination\n    {\n        public Keys KeyCode { get; }\n        public ModifierKeys Modifiers { get; }\n        public KeyCombination OriginalRecord { get; }\n\n        public KeyCombination(Keys keyCode, ModifierKeys modifiers)\n        {\n            KeyCode = keyCode;\n            Modifiers = modifiers;\n            OriginalRecord = null;\n        }\n\n        public KeyCombination(Keys keyCode, ModifierKeys modifiers, KeyCombination originalRecord)\n        {\n            KeyCode = keyCode;\n            Modifiers = modifiers;\n            OriginalRecord = originalRecord;\n        }\n", "        public override bool Equals(object obj)\n        {\n            return obj is KeyCombination other && KeyCode == other.KeyCode && Modifiers == other.Modifiers;\n        }\n\n        public static bool operator ==(KeyCombination left, KeyCombination right)\n        {\n            if (left is null) return right is null;\n            return left.Equals(right);\n        }\n", "        public static bool operator !=(KeyCombination left, KeyCombination right)\n        {\n            return !(left == right);\n        }\n\n        public override int GetHashCode()\n        {\n            return HashCode.Combine(KeyCode, Modifiers);\n        }\n    }\n", "    public enum HotkeyType\n    {\n        KeyDown,\n        KeyUp\n    }\n\n    public class GlobalHotkeyService : IGlobalHotkeyService\n    {\n        private readonly IKeyboardMouseEvents _hook;\n        private readonly Dictionary<WingmanSettings, EventHandler> _hotkeyUpHandlers;\n        private readonly Dictionary<WingmanSettings, EventHandler> _hotkeyDownHandlers;", "        private readonly IKeyboardMouseEvents _hook;\n        private readonly Dictionary<WingmanSettings, EventHandler> _hotkeyUpHandlers;\n        private readonly Dictionary<WingmanSettings, EventHandler> _hotkeyDownHandlers;\n        private readonly ISettingsService _settingsService;\n        private readonly Dictionary<HotkeyType, KeyCombination> _cachedValidHotkeys;\n        private readonly HashSet<KeyCombination> _currentlyPressedCombinations;\n\n        public GlobalHotkeyService(ISettingsService settingsService)\n        {\n            _hook = Hook.GlobalEvents();\n            _hotkeyUpHandlers = new Dictionary<WingmanSettings, EventHandler>();\n            _hotkeyDownHandlers = new Dictionary<WingmanSettings, EventHandler>();\n            _settingsService = settingsService;\n\n            _currentlyPressedKeys = new HashSet<Keys>();\n            _cachedValidHotkeys = new Dictionary<HotkeyType, KeyCombination>();\n            _currentlyPressedCombinations = new HashSet<KeyCombination>();\n\n            _hook.KeyDown += Hook_KeyDown;\n            _hook.KeyUp += Hook_KeyUp;\n        }\n", "        public void UpdateHotkeyCache() // could potentially speed up keyup/down events; not sure if it's worth it\n        {\n            foreach (var handlerEntry in _hotkeyUpHandlers)\n            {\n                WingmanSettings settingsKey = handlerEntry.Key;\n                var hotkeyStr = _settingsService.Load<string>(settingsKey);\n                var hotkeyCombination = ParseHotkeyCombination(hotkeyStr);\n\n                _cachedValidHotkeys[HotkeyType.KeyUp] = hotkeyCombination;\n            }\n            foreach (var handlerEntry in _hotkeyDownHandlers)\n            {\n                WingmanSettings settingsKey = handlerEntry.Key;\n                var hotkeyStr = _settingsService.Load<string>(settingsKey);\n                var hotkeyCombination = ParseHotkeyCombination(hotkeyStr);\n\n                _cachedValidHotkeys[HotkeyType.KeyDown] = hotkeyCombination;\n            }\n\n        }\n", "            foreach (var handlerEntry in _hotkeyDownHandlers)\n            {\n                WingmanSettings settingsKey = handlerEntry.Key;\n                var hotkeyStr = _settingsService.Load<string>(settingsKey);\n                var hotkeyCombination = ParseHotkeyCombination(hotkeyStr);\n\n                _cachedValidHotkeys[HotkeyType.KeyDown] = hotkeyCombination;\n            }\n\n        }\n", "        public void RegisterHotkeyUp(WingmanSettings settingsKey, EventHandler handler)\n        {\n            if (!_hotkeyUpHandlers.ContainsKey(settingsKey))\n            {\n                _hotkeyUpHandlers[settingsKey] = null;\n            }\n            _hotkeyUpHandlers[settingsKey] += handler;\n        }\n\n        public void RegisterHotkeyDown(WingmanSettings settingsKey, EventHandler handler)\n        {", "        public void RegisterHotkeyDown(WingmanSettings settingsKey, EventHandler handler)\n        {\n            if (!_hotkeyDownHandlers.ContainsKey(settingsKey))\n            {\n                _hotkeyDownHandlers[settingsKey] = null;\n            }\n            _hotkeyDownHandlers[settingsKey] += handler;\n        }\n\n        public void UnregisterHotkeyUp(WingmanSettings settingsKey, EventHandler handler)\n        {", "        public void UnregisterHotkeyUp(WingmanSettings settingsKey, EventHandler handler)\n        {\n            if (_hotkeyUpHandlers.ContainsKey(settingsKey))\n            {\n                _hotkeyUpHandlers[settingsKey] -= handler;\n            }\n        }\n\n        public void UnregisterHotkeyDown(WingmanSettings settingsKey, EventHandler handler)\n        {\n            if (_hotkeyDownHandlers.ContainsKey(settingsKey))\n            {\n                _hotkeyDownHandlers[settingsKey] -= handler;\n            }\n        }\n", "        public void UnregisterHotkeyDown(WingmanSettings settingsKey, EventHandler handler)\n        {\n            if (_hotkeyDownHandlers.ContainsKey(settingsKey))\n            {\n                _hotkeyDownHandlers[settingsKey] -= handler;\n            }\n        }\n\n        private void Hook_KeyDown(object sender, KeyEventArgs e)\n        {\n            if (!IsModifierKey(e.KeyCode))\n            {\n                var currentModifiers = GetCurrentModifiers(e);\n                var keyCombination = new KeyCombination(e.KeyCode, currentModifiers, new KeyCombination(e.KeyCode, currentModifiers));\n                _currentlyPressedCombinations.Add(keyCombination);", "        private void Hook_KeyDown(object sender, KeyEventArgs e)\n        {\n            if (!IsModifierKey(e.KeyCode))\n            {\n                var currentModifiers = GetCurrentModifiers(e);\n                var keyCombination = new KeyCombination(e.KeyCode, currentModifiers, new KeyCombination(e.KeyCode, currentModifiers));\n                _currentlyPressedCombinations.Add(keyCombination);\n                if (HandleKeyEvent(keyCombination, _hotkeyDownHandlers))\n                {\n                    Console.WriteLine(String.Format(\"D: {0} has been handled with mods: {1}\", e.KeyCode.ToString(), e.Modifiers.ToString()));\n                    e.Handled = true;\n                }\n                else\n                {\n                    _currentlyPressedCombinations.Remove(keyCombination);\n                }\n            }\n            else\n            {\n                // Ignore modifier keys by themselves\n            }\n        }\n", "        private void Hook_KeyUp(object sender, KeyEventArgs e)\n        {\n            if (!IsModifierKey(e.KeyCode))\n            {\n                var findPressed = _currentlyPressedCombinations.FirstOrDefault(x => x.KeyCode == e.KeyCode);\n\n                if (findPressed == null)\n                    return;\n\n                _currentlyPressedCombinations.Remove(findPressed);\n", "                if (HandleKeyEvent(findPressed.OriginalRecord, _hotkeyUpHandlers))\n                {\n                    e.Handled = true;\n                    Debug.WriteLine(String.Format(\"UpX. {0} is handled.\", e.KeyCode.ToString()));\n                }\n            }\n        }\n\n        // takes KeyCombination\n        private bool HandleKeyEvent(KeyCombination pressed, Dictionary<WingmanSettings, EventHandler> handlers)\n        {\n            bool isHandled = false;\n", "        private bool HandleKeyEvent(KeyCombination pressed, Dictionary<WingmanSettings, EventHandler> handlers)\n        {\n            bool isHandled = false;\n\n            foreach (var handlerEntry in handlers)\n            {\n                var settingsKey = handlerEntry.Key;\n                var handler = handlerEntry.Value;\n                var hotkeySettingString = _settingsService.Load<string>(settingsKey);\n                var hotkeyCombo = ParseHotkeyCombination(hotkeySettingString);\n\n", "                if (hotkeyCombo == pressed)\n                {\n                    handler?.Invoke(this, EventArgs.Empty);\n                    isHandled = true;\n                }\n            }\n            return isHandled;\n        }\n\n\n        private readonly Dictionary<string, Keys> specialKeysMap = new Dictionary<string, Keys>\n        {\n            { \"`\", Keys.Oem3 },\n            { \";\", Keys.Oem1 },\n            { \"=\", Keys.Oemplus },\n            { \",\", Keys.Oemcomma },\n            { \"-\", Keys.OemMinus },\n            { \".\", Keys.OemPeriod },\n            { \"/\", Keys.Oem2 },\n            { \"[\", Keys.Oem4 },\n            { \"\\\\\", Keys.Oem5 },\n            { \"]\", Keys.Oem6 },\n            { \"'\", Keys.Oem7 }\n        };\n", "        private readonly Dictionary<string, Keys> specialKeysMap = new Dictionary<string, Keys>\n        {\n            { \"`\", Keys.Oem3 },\n            { \";\", Keys.Oem1 },\n            { \"=\", Keys.Oemplus },\n            { \",\", Keys.Oemcomma },\n            { \"-\", Keys.OemMinus },\n            { \".\", Keys.OemPeriod },\n            { \"/\", Keys.Oem2 },\n            { \"[\", Keys.Oem4 },\n            { \"\\\\\", Keys.Oem5 },\n            { \"]\", Keys.Oem6 },\n            { \"'\", Keys.Oem7 }\n        };\n", "        private KeyCombination ParseHotkeyCombination(string hotkeyCombination)\n        {\n            Keys newkey = Keys.None;\n            ModifierKeys modifiers = ModifierKeys.None;\n\n            if (hotkeyCombination.Length > 1 && hotkeyCombination.Contains('+'))\n            {\n                var keysAndModifiers = hotkeyCombination.Split(\"+\");\n                var keystr = keysAndModifiers.TakeLast(1).Single().Trim();\n                Array.Resize(ref keysAndModifiers, keysAndModifiers.Length - 1);\n\n                newkey = specialKeysMap.ContainsKey(keystr) ? specialKeysMap[keystr] : (Keys)Enum.Parse(typeof(Keys), keystr, ignoreCase: true);\n\n", "                foreach (var modifier in keysAndModifiers)\n                {\n                    // Check if the key is a modifier key\n                    if (modifier == \"Alt\")\n                    {\n                        modifiers |= ModifierKeys.Alt;\n                    }\n                    else if (modifier == \"Ctrl\")\n                    {\n                        modifiers |= ModifierKeys.Control;\n                    }", "                    else if (modifier == \"Shift\")\n                    {\n                        modifiers |= ModifierKeys.Shift;\n                    }\n                    else if (modifier == \"Win\")\n                    {\n                        modifiers |= ModifierKeys.Windows;\n                    }\n                }\n\n            }\n            else\n            {\n                modifiers = ModifierKeys.None;\n                newkey = specialKeysMap.ContainsKey(hotkeyCombination) ? specialKeysMap[hotkeyCombination] : (Keys)Enum.Parse(typeof(Keys), hotkeyCombination, ignoreCase: true);\n            }\n\n            // Create the key combination\n            return new KeyCombination(newkey, modifiers);\n        }\n\n\n\n", "        private ModifierKeys GetCurrentModifiers(KeyEventArgs e)\n        {\n            ModifierKeys currentModifiers = ModifierKeys.None;\n            if (e.Control) currentModifiers |= ModifierKeys.Control;\n            if (e.Shift) currentModifiers |= ModifierKeys.Shift;\n            if (e.Alt) currentModifiers |= ModifierKeys.Alt;\n\n            return currentModifiers;\n        }\n\n        // Start of Hotkey Configuration Routines\n\n        private Func<string, bool> _keyConfigurationCallback;", "        private readonly HashSet<Keys> _currentlyPressedKeys;\n\n        public async Task ConfigureHotkeyAsync(Func<string, bool> keyConfigurationCallback)\n        {\n            _currentlyPressedKeys.Clear();\n            _keyConfigurationCallback = keyConfigurationCallback;\n\n            // Unregister the original KeyDown and KeyUp listeners.\n            _hook.KeyDown -= Hook_KeyDown;\n            _hook.KeyUp -= Hook_KeyUp;\n\n            // Register the configuration KeyDown and KeyUp listeners.\n            _hook.KeyDown += Hook_KeyDown_Configuration;\n            _hook.KeyUp += Hook_KeyUp_Configuration;\n", "            while (_keyConfigurationCallback != null)\n            {\n                await Task.Delay(500);\n            }\n\n            // Unregister the configuration KeyDown and KeyUp listeners.\n            _hook.KeyDown -= Hook_KeyDown_Configuration;\n            _hook.KeyUp -= Hook_KeyUp_Configuration;\n\n            // Re-register the original KeyDown and KeyUp listeners.\n            _hook.KeyDown += Hook_KeyDown;\n            _hook.KeyUp += Hook_KeyUp;\n        }\n", "        private void Hook_KeyDown_Configuration(object sender, KeyEventArgs e)\n        {\n            if (!IsModifierKey(e.KeyCode))\n            {\n                _currentlyPressedKeys.Add(e.KeyCode);\n            }\n\n            ModifierKeys currentModifiers = ModifierKeys.None;\n            if (e.Control) currentModifiers |= ModifierKeys.Control;\n            if (e.Shift) currentModifiers |= ModifierKeys.Shift;\n            if (e.Alt) currentModifiers |= ModifierKeys.Alt;\n\n            var otherModifiers = GetCurrentModifiers(e);", "            if (e.Control) currentModifiers |= ModifierKeys.Control;\n            if (e.Shift) currentModifiers |= ModifierKeys.Shift;\n            if (e.Alt) currentModifiers |= ModifierKeys.Alt;\n\n            var otherModifiers = GetCurrentModifiers(e);\n            if ((otherModifiers & ModifierKeys.Windows) != 0)\n                currentModifiers |= ModifierKeys.Windows;\n\n\n            if (!IsModifierKey(e.KeyCode))\n            {\n                var hkstr = BuildHotkeyString(e);\n                _keyConfigurationCallback?.Invoke(hkstr);\n                _keyConfigurationCallback = null;\n                e.Handled = true;\n            }\n        }\n\n", "            if (!IsModifierKey(e.KeyCode))\n            {\n                var hkstr = BuildHotkeyString(e);\n                _keyConfigurationCallback?.Invoke(hkstr);\n                _keyConfigurationCallback = null;\n                e.Handled = true;\n            }\n        }\n\n\n        private void Hook_KeyUp_Configuration(object sender, KeyEventArgs e)\n        {\n            _currentlyPressedKeys.Remove(e.KeyCode);\n        }\n", "        private void Hook_KeyUp_Configuration(object sender, KeyEventArgs e)\n        {\n            _currentlyPressedKeys.Remove(e.KeyCode);\n        }\n\n        private bool IsModifierKey(Keys keyCode)\n        {\n            return keyCode == Keys.ControlKey || keyCode == Keys.ShiftKey || keyCode == Keys.Menu || keyCode == Keys.LMenu || keyCode == Keys.RMenu\n                || keyCode == Keys.LShiftKey || keyCode == Keys.RShiftKey || keyCode == Keys.LControlKey || keyCode == Keys.RControlKey || keyCode == Keys.LWin || keyCode == Keys.RWin;\n        }\n", "        private string BuildHotkeyString(KeyEventArgs e)\n        {\n            List<string> keyParts = new List<string>();\n\n            if (e.Control) keyParts.Add(\"Ctrl\");\n            if (e.Shift) keyParts.Add(\"Shift\");\n            if (e.Alt) keyParts.Add(\"Alt\");\n            var otherModifiers = GetCurrentModifiers(e);\n            if ((otherModifiers & ModifierKeys.Windows) != 0)\n                keyParts.Add(\"Win\");\n\n            string mainKey = specialKeysMap.FirstOrDefault(x => x.Value == e.KeyCode).Key;", "            if ((otherModifiers & ModifierKeys.Windows) != 0)\n                keyParts.Add(\"Win\");\n\n            string mainKey = specialKeysMap.FirstOrDefault(x => x.Value == e.KeyCode).Key;\n            if (string.IsNullOrEmpty(mainKey))\n            {\n                mainKey = e.KeyCode.ToString();\n            }\n\n            keyParts.Add(mainKey);\n\n            return string.Join(\"+\", keyParts);\n        }\n    }\n}\n"]}
{"filename": "Services/StdInService.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\nusing System.Threading.Tasks;\nusing Windows.System;\nusing Windows.UI.Input.Preview.Injection;\nusing wingman.Helpers;\nusing wingman.Interfaces;\n", "using wingman.Interfaces;\n\nnamespace wingman.Services\n{\n    public class StdInService : IStdInService\n    {\n        [DllImport(\"user32.dll\")]\n        static extern IntPtr FindWindow(string lpClassName, string lpWindowName);\n\n        [DllImport(\"user32.dll\")]\n        static extern IntPtr SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);\n\n        [DllImport(\"user32.dll\")]\n        static extern bool SetForegroundWindow(IntPtr hWnd);\n\n        // import VkKeyScanA function from user32.dll\n        [DllImport(\"user32.dll\")]\n        static extern short VkKeyScanA(char ch);\n\n        const uint WM_CHAR = 0x0102;\n\n        private Process? _process;\n        readonly ILoggingService Logger;\n", "        public void SetProcess(Process process)\n        {\n            _process = process ?? throw new ArgumentNullException(nameof(process));\n        }\n\n        public StdInService(ILoggingService logger)\n        {\n            Logger = logger;\n        }\n\n        public async Task SendWithClipboardAsync(string str)\n        {\n            InputInjector inputInjector = InputInjector.TryCreate();\n            // Save whatever is on the clipboard\n            //var savedClipboard = await ClipboardHelper.GetTextAsync();\n            //await Task.Delay(100);\n\n            Logger.LogDebug(\"Leveraging Clipboard to send string: \" + str);\n            await ClipboardHelper.SetTextAsync(str);\n            await Task.Delay(100);\n\n            // Paste the clipboard out\n\n            inputInjector.InjectKeyboardInput(new[] {\n                new InjectedInputKeyboardInfo\n                {\n                    VirtualKey = (ushort) VirtualKey.Control,\n                    KeyOptions = InjectedInputKeyOptions.None\n                },\n                new InjectedInputKeyboardInfo\n                {\n                    VirtualKey = (ushort) VirtualKey.V,\n                    KeyOptions = InjectedInputKeyOptions.None\n                },\n                new InjectedInputKeyboardInfo\n                {\n                    VirtualKey = (ushort) VirtualKey.Control,\n                    KeyOptions = InjectedInputKeyOptions.KeyUp\n                }\n            });\n\n            //\n            //await Task.Delay(100);\n            //await ClipboardHelper.SetTextAsync(savedClipboard);\n        }\n", "        public async Task SendWithClipboardAsync(string str)\n        {\n            InputInjector inputInjector = InputInjector.TryCreate();\n            // Save whatever is on the clipboard\n            //var savedClipboard = await ClipboardHelper.GetTextAsync();\n            //await Task.Delay(100);\n\n            Logger.LogDebug(\"Leveraging Clipboard to send string: \" + str);\n            await ClipboardHelper.SetTextAsync(str);\n            await Task.Delay(100);\n\n            // Paste the clipboard out\n\n            inputInjector.InjectKeyboardInput(new[] {\n                new InjectedInputKeyboardInfo\n                {\n                    VirtualKey = (ushort) VirtualKey.Control,\n                    KeyOptions = InjectedInputKeyOptions.None\n                },\n                new InjectedInputKeyboardInfo\n                {\n                    VirtualKey = (ushort) VirtualKey.V,\n                    KeyOptions = InjectedInputKeyOptions.None\n                },\n                new InjectedInputKeyboardInfo\n                {\n                    VirtualKey = (ushort) VirtualKey.Control,\n                    KeyOptions = InjectedInputKeyOptions.KeyUp\n                }\n            });\n\n            //\n            //await Task.Delay(100);\n            //await ClipboardHelper.SetTextAsync(savedClipboard);\n        }\n", "        // The new InputInjector class works 500x better than SendKeys; so we abandon NativeKeyboard here \n\n        public async Task SendStringAsync(string str)\n        {\n            InputInjector inputInjector = InputInjector.TryCreate();\n            if (inputInjector == null)\n            {\n                Logger.LogException(\"Failed to create input injector.\");\n                throw new InvalidOperationException(\"Failed to create input injector.\");\n            }\n\n            List<InjectedInputKeyboardInfo> inputBuffer = new List<InjectedInputKeyboardInfo>();\n", "            foreach (char c in str)\n            {\n                var loworderbyte = new InjectedInputKeyboardInfo();\n\n                short vk = VkKeyScanA(c);\n                byte vkCode = (byte)(vk & 0xFF);\n                loworderbyte.VirtualKey = (ushort)vkCode;\n\n                if ((vk & 0x100) != 0)\n                {\n                    var highorderbyteup = new InjectedInputKeyboardInfo();\n                    highorderbyteup.VirtualKey = (ushort)VirtualKey.Shift;\n                    highorderbyteup.KeyOptions = InjectedInputKeyOptions.KeyUp;\n\n                    var highorderbytedown = new InjectedInputKeyboardInfo();\n                    highorderbytedown.VirtualKey = (ushort)VirtualKey.Shift;\n                    highorderbytedown.KeyOptions = InjectedInputKeyOptions.None;\n\n                    inputBuffer.Add(highorderbytedown);\n                    inputBuffer.Add(loworderbyte);\n                    inputBuffer.Add(highorderbyteup);\n                    //inputInjector.InjectKeyboardInput(new[] { highorderbytedown, loworderbyte, highorderbyteup });\n                }\n                else\n                {\n                    loworderbyte.VirtualKey = (ushort)vkCode;\n                    inputBuffer.Add(loworderbyte);\n                    //inputInjector.InjectKeyboardInput(new[] { loworderbyte });\n                }\n\n            }\n\n\n            // To speed up streaming the output, we'll batch keys sent with InjectKeyboardInput", "                if ((vk & 0x100) != 0)\n                {\n                    var highorderbyteup = new InjectedInputKeyboardInfo();\n                    highorderbyteup.VirtualKey = (ushort)VirtualKey.Shift;\n                    highorderbyteup.KeyOptions = InjectedInputKeyOptions.KeyUp;\n\n                    var highorderbytedown = new InjectedInputKeyboardInfo();\n                    highorderbytedown.VirtualKey = (ushort)VirtualKey.Shift;\n                    highorderbytedown.KeyOptions = InjectedInputKeyOptions.None;\n\n                    inputBuffer.Add(highorderbytedown);\n                    inputBuffer.Add(loworderbyte);\n                    inputBuffer.Add(highorderbyteup);\n                    //inputInjector.InjectKeyboardInput(new[] { highorderbytedown, loworderbyte, highorderbyteup });\n                }\n                else\n                {\n                    loworderbyte.VirtualKey = (ushort)vkCode;\n                    inputBuffer.Add(loworderbyte);\n                    //inputInjector.InjectKeyboardInput(new[] { loworderbyte });\n                }\n\n            }\n\n\n            // To speed up streaming the output, we'll batch keys sent with InjectKeyboardInput", "            if (inputBuffer.Count > 0)\n            {\n                for (int i = 0; i < inputBuffer.Count;)\n                {\n                    var count = Math.Min(4, inputBuffer.Count - i); // This is randomly unstable again; 8 was the magic number but now I'm trying 4 to be safe\n                    var plus1 = i + count + 1;\n                    var plus2 = i + count + 2;\n                    // We need to make sure Shift-Down and Shift-Up are sent together in the same batch or things get wonky\n                    if (plus1 < inputBuffer.Count && inputBuffer[plus1].KeyOptions == InjectedInputKeyOptions.KeyUp)\n                    {\n                        count -= 2;\n                    }", "                    if (plus1 < inputBuffer.Count && inputBuffer[plus1].KeyOptions == InjectedInputKeyOptions.KeyUp)\n                    {\n                        count -= 2;\n                    }\n                    else if (plus2 < inputBuffer.Count && inputBuffer[plus2].KeyOptions == InjectedInputKeyOptions.KeyUp)\n                    {\n                        count--;\n                    }\n                    inputInjector.InjectKeyboardInput(inputBuffer.GetRange(i, count));\n                    await Task.Delay(10); // Small delay required, either for injection method or for STDIN to register on the other end\n                    i += count;\n                }\n            }\n\n\n        }\n\n\n\n\n\n\n    }\n\n}\n\n\n\n"]}
{"filename": "Services/EditorService.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing wingman.Interfaces;\n\nnamespace wingman.Services\n{\n    public class EditorService : IEditorService\n    {", "namespace wingman.Services\n{\n    public class EditorService : IEditorService\n    {\n        public async Task<IReadOnlyList<Process>> GetRunningEditorsAsync()\n        {\n            var processes = await Task.Run(() => Process.GetProcesses());\n            var editorProcesses = processes.Where(p => IsKnownEditorProcess(p)).ToList();\n            return editorProcesses;\n        }\n", "        private bool IsKnownEditorProcess(Process process)\n        {\n            // Add known editor executable names here\n            var knownEditorExes = new[] { \"devenv\", \"code\", \"notepad++\", \"notepad\", \"sublime_text\", \"eclipse\", \"atom\", \"idea64\", \"pycharm64\", \"netbeans64\", \"brackets\" };\n            return knownEditorExes.Contains(Path.GetFileNameWithoutExtension(process.ProcessName));\n        }\n    }\n}\n"]}
{"filename": "Services/MicrophoneDeviceService.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Threading.Tasks;\nusing Windows.Devices.Enumeration;\nusing Windows.Foundation;\nusing Windows.Media;\nusing Windows.Media.Audio;", "using Windows.Media;\nusing Windows.Media.Audio;\nusing Windows.Media.Capture;\nusing Windows.Media.MediaProperties;\nusing Windows.Media.Render;\nusing Windows.Storage;\nusing wingman.Interfaces;\nusing WinRT;\n\nnamespace wingman.Services", "\nnamespace wingman.Services\n{\n\n    public class MicrophoneDeviceService : IMicrophoneDeviceService, IDisposable\n    {\n        MicrophoneDevice? _currentMicrophoneDevice;\n        public event EventHandler<double>? VolumeChanged;\n        private AudioGraph? graph;\n        private AudioFrameInputNode? _frameInputNode;\n        private AudioFrameOutputNode? _frameOutputNode;\n        private AudioDeviceInputNode? _deviceInputNode;\n", "        private bool _isRecording = false;\n        private AudioBuffer? _recBuffer;\n        private AudioFileOutputNode? _audioFileOutputNode;\n        private bool _disposed = false;\n        private bool _disposing = false;\n        private ulong _sampleRate;\n\n        ILoggingService Logger;\n\n        public MicrophoneDeviceService(ILoggingService logger)\n        {\n            Logger = logger;\n        }\n", "        public async Task<IReadOnlyList<MicrophoneDevice>> GetMicrophoneDevicesAsync()\n        {\n            List<MicrophoneDevice> result = new();\n\n            var devices = await DeviceInformation.FindAllAsync(DeviceClass.AudioCapture);\n\n            if (devices == null || devices.Count == 0)\n                return result;\n\n            foreach (var device in devices)\n            {\n                result.Add(new MicrophoneDevice\n                {\n                    Id = device.Id,\n                    Name = device.Name,\n                    Info = device\n                });\n            }\n\n            return result;\n        }\n", "            foreach (var device in devices)\n            {\n                result.Add(new MicrophoneDevice\n                {\n                    Id = device.Id,\n                    Name = device.Name,\n                    Info = device\n                });\n            }\n\n            return result;\n        }\n", "        protected virtual void Dispose(bool disposing)\n        {\n            if (!_disposed)\n            {\n                if (disposing)\n                {\n                    _isRecording = false;\n\n                    if (_audioFileOutputNode != null) // this wont ever be true\n                    {\n                        _audioFileOutputNode.Stop();\n                        _audioFileOutputNode.Dispose();\n                        _audioFileOutputNode = null;\n                    }\n", "                    if (_audioFileOutputNode != null) // this wont ever be true\n                    {\n                        _audioFileOutputNode.Stop();\n                        _audioFileOutputNode.Dispose();\n                        _audioFileOutputNode = null;\n                    }\n\n                    if (graph != null)\n                    {\n                        if (_frameOutputNode != null)\n                        {\n                            _frameOutputNode.Stop();\n                            graph.QuantumStarted -= FrameOutputNode_QuantumStarted;\n                            _frameOutputNode.Dispose();\n                            _frameOutputNode = null;\n                        }", "                        if (_frameOutputNode != null)\n                        {\n                            _frameOutputNode.Stop();\n                            graph.QuantumStarted -= FrameOutputNode_QuantumStarted;\n                            _frameOutputNode.Dispose();\n                            _frameOutputNode = null;\n                        }\n                        if (_frameInputNode != null)\n                        {\n                            _frameInputNode.Stop();\n                            _frameInputNode.Dispose();\n                            _frameInputNode = null;\n                        }", "                        if (_deviceInputNode != null)\n                        {\n                            _deviceInputNode.Stop();\n                            _deviceInputNode.Dispose();\n                            _deviceInputNode = null;\n                        }\n                        graph.UnrecoverableErrorOccurred -= AudioGraph_UnrecoverableErrorOccurred;\n                        graph.Stop();\n                        graph.Dispose();\n                        graph = null;\n                    }", "                    if (_recBuffer != null)\n                    {\n                        _recBuffer.Dispose();\n                        _recBuffer = null;\n                    }\n                    _disposed = true;\n                    Debug.WriteLine(\"Microphone Devices disposed\");\n                }\n            }\n        }\n\n", "        public void Dispose()\n        {\n            _disposing = true;\n            Dispose(_disposing);\n            GC.SuppressFinalize(this);\n            Debug.WriteLine(\"MicrophoneDeviceService disposed\");\n        }\n\n\n        private void AudioGraph_UnrecoverableErrorOccurred(AudioGraph sender, AudioGraphUnrecoverableErrorOccurredEventArgs args)\n        {", "        private void AudioGraph_UnrecoverableErrorOccurred(AudioGraph sender, AudioGraphUnrecoverableErrorOccurredEventArgs args)\n        {\n            if (sender == graph && args.Error != AudioGraphUnrecoverableError.None)\n            {\n                Logger.LogDebug(\"The audio graph encountered and unrecoverable error.\");\n                graph.Stop();\n                graph.Dispose();\n            }\n        }\n\n        public async Task SetMicrophoneDeviceAsync(MicrophoneDevice device)\n        {\n            Dispose(true);\n            _disposed = false;\n", "        public async Task SetMicrophoneDeviceAsync(MicrophoneDevice device)\n        {\n            Dispose(true);\n            _disposed = false;\n\n            if (device != null)\n            {\n                _currentMicrophoneDevice = device;\n\n                var settings = new AudioGraphSettings(AudioRenderCategory.Speech)\n                {\n                    EncodingProperties = AudioEncodingProperties.CreatePcm(16000, 1, 16),\n                    QuantumSizeSelectionMode = QuantumSizeSelectionMode.LowestLatency,\n                    //DesiredRenderDeviceAudioProcessing = Windows.Media.AudioProcessing.Raw\n                };\n\n                CreateAudioGraphResult? result = default(CreateAudioGraphResult);\n\n                try\n                {\n                    result = await AudioGraph.CreateAsync(settings);\n                }", "                catch (Exception ex)\n                {\n                    Debug.WriteLine($\"An error occurred: {ex.Message}\");\n                }\n\n\n                if (result == null || result.Status != AudioGraphCreationStatus.Success)\n                {\n                    throw new Exception(\"AudioGraph creation error\");\n                }\n\n\n                graph = result.Graph;\n                graph.UnrecoverableErrorOccurred += AudioGraph_UnrecoverableErrorOccurred;\n\n                var inputResult = await graph.CreateDeviceInputNodeAsync(MediaCategory.Speech, settings.EncodingProperties, device.Info);\n", "                if (inputResult.Status != AudioDeviceNodeCreationStatus.Success)\n                {\n                    throw new Exception(\"AudioGraph input node creation error\");\n                }\n\n                _deviceInputNode = inputResult.DeviceInputNode;\n                //_deviceInputNode.OutgoingGain = 5;\n\n                try\n                {\n                    _frameOutputNode = graph.CreateFrameOutputNode(settings.EncodingProperties);\n                }", "                catch (Exception)\n                {\n                }\n\n                _deviceInputNode.AddOutgoingConnection(_frameOutputNode);\n\n                _throttlecount = 0;\n                graph.QuantumStarted += FrameOutputNode_QuantumStarted;\n\n                graph.Start();\n                Logger.LogDebug(\"Graph started.\");\n            }\n        }\n\n        [ComImport]\n        [Guid(\"5B0D3235-4DBA-4D44-865E-8F1D0E4FD04D\")]\n        [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]", "        unsafe interface IMemoryBufferByteAccess\n        {\n            void GetBuffer(out byte* buffer, out uint capacity);\n        }\n\n        private long _throttlecount;\n        private void FrameOutputNode_QuantumStarted(AudioGraph sender, object args)\n        {\n            if (_disposing)\n                return;\n\n            _throttlecount++;", "            if (_disposing)\n                return;\n\n            _throttlecount++;\n            if (_throttlecount < 10)\n                return;\n            _throttlecount = 0;\n\n            var frame = _frameOutputNode?.GetFrame() ?? default;\n            if (frame == null) { return; }\n\n            unsafe\n            {", "            if (frame == null) { return; }\n\n            unsafe\n            {\n                using (AudioBuffer buffer = frame.LockBuffer(AudioBufferAccessMode.Read))\n                using (IMemoryBufferReference reference = buffer.CreateReference())\n                {\n                    double decibels = double.NegativeInfinity;\n                    try\n                    {\n\n                        byte* dataInBytes;\n                        uint capacityInBytes;\n                        var memoryBuffer = reference.As<IMemoryBufferByteAccess>();\n                        memoryBuffer.GetBuffer(out dataInBytes, out capacityInBytes);\n                        int dataInFloatsLength = (int)capacityInBytes / sizeof(float);\n                        float* dataInFloat = (float*)dataInBytes;\n\n                        double sumOfSquares = 0.0;", "                        for (int i = 0; i < capacityInBytes / sizeof(float); i++)\n                        {\n                            sumOfSquares += dataInFloat[i] * dataInFloat[i];\n                        }\n\n                        double rms = Math.Sqrt(sumOfSquares / (capacityInBytes / sizeof(float)));\n\n                        decibels = 20 * Math.Log10(rms);\n\n                    }\n                    catch (Exception)\n                    {\n\n                    }\n\n                    // Update UI with decibels value\n", "                    catch (Exception)\n                    {\n\n                    }\n\n                    // Update UI with decibels value\n\n                    if (Double.IsNaN(decibels))\n                    {\n                        decibels = 0;\n                    }\n\n                    double minDecibels = -150;\n                    double maxDecibels = 100;\n                    double normalizedVolume = (decibels - minDecibels) / (maxDecibels - minDecibels);\n\n                    var volumePercentage = Math.Min(Math.Max(normalizedVolume * 100, 0), 100);\n", "                    if (!_disposing)\n                        VolumeChanged?.Invoke(this, volumePercentage);\n                }\n            }\n        }\n\n        private async Task<StorageFile> CreateTempFileOutputNode()\n        {\n            string uniqueId = DateTime.UtcNow.ToString(\"yyyyMMddHHmmssfff\");\n            string uniqueFileName = $\"chatsample_{uniqueId}.mp3\";\n\n            //Windows.Storage.StorageFolder temporaryFolder = ApplicationData.Current.TemporaryFolder;            \n            // ^-- another innocent bystandard that doesn't work on unpackaged WinUI\n\n            var path = Path.GetTempPath();\n            await Task.Delay(100);\n            StorageFolder temporaryFolder = await StorageFolder.GetFolderFromPathAsync(path);\n\n            StorageFile sampleFile = await temporaryFolder.CreateFileAsync(uniqueFileName, CreationCollisionOption.ReplaceExisting);\n\n            var outProfile = MediaEncodingProfile.CreateMp3(AudioEncodingQuality.High);\n\n            var outResult = await graph?.CreateFileOutputNodeAsync(sampleFile, outProfile);", "            if (outResult?.Status != AudioFileNodeCreationStatus.Success)\n            {\n                throw new Exception(\"Couldn't create file output node.\");\n            }\n\n            if (outResult?.Status != AudioFileNodeCreationStatus.Success)\n            {\n                throw new Exception(\"Couldn't create file output node.\");\n            }\n\n            _audioFileOutputNode = outResult.FileOutputNode;\n", "            if (_deviceInputNode == null)\n            {\n                throw new Exception(\"_deviceInputNode is null\");\n            }\n\n            _deviceInputNode.AddOutgoingConnection(_audioFileOutputNode);\n\n\n            Logger.LogDebug(\"Temporary Audio File created\");\n            return sampleFile;\n        }\n\n        StorageFile? tmpFile { get; set; } = null;\n", "        public async Task StartRecording()\n        {\n            try\n            {\n                if (_isRecording || _currentMicrophoneDevice == null || graph == null)\n                {\n                    return;\n                }\n                _isRecording = true;\n                graph.Stop();\n                tmpFile = await CreateTempFileOutputNode();\n                graph.Start();\n", "                if (_audioFileOutputNode == null)\n                {\n                    throw new Exception(\"_audioFileOutputNode is null.\");\n                }\n                _audioFileOutputNode.Start();\n                Logger.LogDebug(\"Audio recording to file started: \" + tmpFile.Name);\n            }\n            catch (Exception)\n            {\n                Logger.LogException(\"Error starting audio recording to file.\");\n                // Log or handle exceptions that occur during StartRecording\n                _isRecording = false;\n                throw; // Re-throw the exception if needed or handle it accordingly\n            }\n        }\n", "        public async Task<StorageFile?> StopRecording()\n        {\n            if (!_isRecording)\n            {\n                return default(StorageFile);\n            }\n            try\n            {\n                if (_audioFileOutputNode == null)\n                {\n                    Logger.LogException(\"_audioFileOutputNode is null.\");\n                    throw new Exception(\"_audioFileOutputNode is null.\");\n                }\n                _audioFileOutputNode.Stop();\n                await _audioFileOutputNode.FinalizeAsync();\n                _audioFileOutputNode = null;\n                Logger.LogDebug(\"Audio output node finalized.\");\n\n                _isRecording = false;\n                return tmpFile;\n            }", "                if (_audioFileOutputNode == null)\n                {\n                    Logger.LogException(\"_audioFileOutputNode is null.\");\n                    throw new Exception(\"_audioFileOutputNode is null.\");\n                }\n                _audioFileOutputNode.Stop();\n                await _audioFileOutputNode.FinalizeAsync();\n                _audioFileOutputNode = null;\n                Logger.LogDebug(\"Audio output node finalized.\");\n\n                _isRecording = false;\n                return tmpFile;\n            }", "            catch (Exception)\n            {\n                Logger.LogException(\"Error stopping audio recording to file.\");\n                // Log or handle exceptions that occur during StopRecording\n                _isRecording = false;\n                throw; // Re-throw the exception if needed or handle it accordingly\n            }\n        }\n\n    }\n}\n\n"]}
{"filename": "Services/NamedPipesService.cs", "chunked_list": ["\ufeffusing System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Pipes;\nusing System.Security.AccessControl;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing wingman.Interfaces;\n", "using wingman.Interfaces;\n\nnamespace wingman.Services\n{\n    public class NamedPipesService : INamedPipesService, IDisposable\n    {\n        private bool disposed = false;\n        private CancellationTokenSource cts;\n        private Task mouseServer;\n\n        public NamedPipesService()\n        {\n            cts = new CancellationTokenSource();\n            mouseServer = Task.Run(MouseServer, cts.Token);\n        }\n", "        private Task mouseServer;\n\n        public NamedPipesService()\n        {\n            cts = new CancellationTokenSource();\n            mouseServer = Task.Run(MouseServer, cts.Token);\n        }\n\n        public void Dispose()\n        {\n            if (!disposed)\n            {\n                disposed = true;\n                cts.Cancel();\n                mouseServer.Wait();\n            }\n            Debug.WriteLine(\"Namedpipes disposed\");\n        }\n", "        public void Dispose()\n        {\n            if (!disposed)\n            {\n                disposed = true;\n                cts.Cancel();\n                mouseServer.Wait();\n            }\n            Debug.WriteLine(\"Namedpipes disposed\");\n        }\n", "        private async Task MouseServer()\n        {\n            while (!cts.Token.IsCancellationRequested)\n            {\n                try\n                {\n                    var cmd = await Listen(\"MousePipe\");\n                    switch (cmd)\n                    {\n                        case \"MouseArrow\":\n                            ToggleMouseArrow();\n                            break;\n                        case \"MouseWait\":\n                            ToggleMouseWait();\n                            break;\n                        default:\n                            break;\n                    }\n                }", "                catch (Exception ex)\n                {\n                    // Log the exception or do something else with it\n                    Debug.WriteLine(ex.ToString());\n                }\n                await Task.Delay(1000);\n            }\n        }\n\n        public async Task SendMessageAsync(string message)\n        {", "        public async Task SendMessageAsync(string message)\n        {\n            using (NamedPipeClientStream pipeClient = new NamedPipeClientStream(\".\", \"MousePipe\", PipeDirection.Out, PipeOptions.Asynchronous))\n            {\n                var connectTask = pipeClient.ConnectAsync();\n                var timeoutTask = Task.Delay(TimeSpan.FromSeconds(5));\n\n                // Wait for either the connection to succeed or the timeout to elapse\n                await Task.WhenAny(connectTask, timeoutTask);\n\n                if (!pipeClient.IsConnected)\n                {\n                    throw new TimeoutException(\"Timed out while waiting for named pipe connection.\");\n                }\n\n                byte[] buffer = Encoding.UTF8.GetBytes(message);\n                await pipeClient.WriteAsync(buffer, 0, buffer.Length);\n                await pipeClient.FlushAsync();\n\n            }\n        }\n\n", "                if (!pipeClient.IsConnected)\n                {\n                    throw new TimeoutException(\"Timed out while waiting for named pipe connection.\");\n                }\n\n                byte[] buffer = Encoding.UTF8.GetBytes(message);\n                await pipeClient.WriteAsync(buffer, 0, buffer.Length);\n                await pipeClient.FlushAsync();\n\n            }\n        }\n\n", "        private async Task<string> Listen(string PipeName)\n        {\n            PipeSecurity pipeSecurity = new PipeSecurity();\n            pipeSecurity.AddAccessRule(new PipeAccessRule(\"Users\", PipeAccessRights.ReadWrite, AccessControlType.Allow));\n            // Create NamedPipeServerStream\n            using (NamedPipeServerStream pipeServer = new NamedPipeServerStream(PipeName, PipeDirection.In, 1, PipeTransmissionMode.Byte, PipeOptions.Asynchronous))\n            {\n                //pipeServer.SetAccessControl(pipeSecurity);\n                // Wait for a Connection from a client\n                await Task.Factory.FromAsync(pipeServer.BeginWaitForConnection, pipeServer.EndWaitForConnection, null);\n\n                string msg = string.Empty;", "                using (StreamReader reader = new StreamReader(pipeServer))\n                {\n                    // Wait for object to be placed on stream by client then read it   \n                    msg = await reader.ReadToEndAsync();\n                }\n\n                return msg;\n            }\n        }\n\n", "        private async void ToggleMouseArrow()\n        {\n            /*\n             * Many bugs in Win UI right now prevent any workarounds i tried (including this namedpipes solution) from working.\n             * You can read more about similar issues here :\n             * \n             * https://github.com/microsoft/microsoft-ui-xaml/issues/7947\n             *\n             * https://github.com/microsoft/microsoft-ui-xaml/issues/7062\n             *\n             * \n             */\n\n        }\n", "        private async void ToggleMouseWait()\n        {\n\n        }\n\n\n    }\n\n}"]}
{"filename": "Services/EventHandlerService.cs", "chunked_list": ["\ufeffusing CommunityToolkit.Mvvm.DependencyInjection;\nusing Microsoft.Extensions.DependencyInjection;\nusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Windows.Media.Core;\nusing Windows.Media.Playback;\nusing wingman.Helpers;\nusing wingman.Interfaces;\nusing wingman.ViewModels;", "using wingman.Interfaces;\nusing wingman.ViewModels;\n\nnamespace wingman.Services\n{\n    public class EventHandlerService : IEventHandlerService, IDisposable\n    {\n        private readonly IGlobalHotkeyService globalHotkeyService;\n        private readonly IMicrophoneDeviceService micService;\n        private readonly IStdInService stdInService;\n        private readonly ISettingsService settingsService;", "        private readonly IMicrophoneDeviceService micService;\n        private readonly IStdInService stdInService;\n        private readonly ISettingsService settingsService;\n        private readonly ILoggingService Logger;\n        private readonly IWindowingService windowingService;\n        private readonly OpenAIControlViewModel openAIControlViewModel;\n        private readonly MediaPlayer mediaPlayer;\n        private readonly Stopwatch micQueueDebouncer = new Stopwatch();\n        private bool isDisposed;\n        private bool isRecording;\n        private bool isProcessing;\n\n        public EventHandler<bool> InferenceCallback { get; set; }\n\n        public EventHandlerService(OpenAIControlViewModel openAIControlViewModel,\n            IGlobalHotkeyService globalHotkeyService,\n            IMicrophoneDeviceService micService,\n            IStdInService stdInService,\n            ISettingsService settingsService,\n            ILoggingService loggingService,\n            IWindowingService windowingService\n            )\n        {\n            this.globalHotkeyService = globalHotkeyService;\n            this.micService = micService;\n            this.stdInService = stdInService;\n            this.settingsService = settingsService;\n            Logger = loggingService;\n            this.windowingService = windowingService;\n            mediaPlayer = new MediaPlayer();\n            this.openAIControlViewModel = openAIControlViewModel;\n\n            Initialize();\n        }\n", "        private bool isDisposed;\n        private bool isRecording;\n        private bool isProcessing;\n\n        public EventHandler<bool> InferenceCallback { get; set; }\n\n        public EventHandlerService(OpenAIControlViewModel openAIControlViewModel,\n            IGlobalHotkeyService globalHotkeyService,\n            IMicrophoneDeviceService micService,\n            IStdInService stdInService,\n            ISettingsService settingsService,\n            ILoggingService loggingService,\n            IWindowingService windowingService\n            )\n        {\n            this.globalHotkeyService = globalHotkeyService;\n            this.micService = micService;\n            this.stdInService = stdInService;\n            this.settingsService = settingsService;\n            Logger = loggingService;\n            this.windowingService = windowingService;\n            mediaPlayer = new MediaPlayer();\n            this.openAIControlViewModel = openAIControlViewModel;\n\n            Initialize();\n        }\n", "        private void Initialize()\n        {\n            globalHotkeyService.RegisterHotkeyDown(WingmanSettings.Main_Hotkey, Events_OnMainHotkey);\n            globalHotkeyService.RegisterHotkeyUp(WingmanSettings.Main_Hotkey, Events_OnMainHotkeyRelease);\n\n            globalHotkeyService.RegisterHotkeyDown(WingmanSettings.Modal_Hotkey, Events_OnModalHotkey);\n            globalHotkeyService.RegisterHotkeyUp(WingmanSettings.Modal_Hotkey, Events_OnModalHotkeyRelease);\n\n            isDisposed = false;\n            isRecording = false;\n            isProcessing = false;\n\n            Logger.LogDebug(\"EventHandler initialized.\");\n        }\n", "        public void Dispose()\n        {\n            if (!isDisposed)\n            {\n                globalHotkeyService.UnregisterHotkeyDown(WingmanSettings.Main_Hotkey, Events_OnMainHotkey);\n                globalHotkeyService.UnregisterHotkeyUp(WingmanSettings.Main_Hotkey, Events_OnMainHotkeyRelease);\n\n                globalHotkeyService.UnregisterHotkeyDown(WingmanSettings.Modal_Hotkey, Events_OnModalHotkey);\n                globalHotkeyService.UnregisterHotkeyUp(WingmanSettings.Modal_Hotkey, Events_OnModalHotkeyRelease);\n\n\n\n\n                mediaPlayer.Dispose();\n                Debug.WriteLine(\"EventHandler disposed.\");\n\n                isDisposed = true;\n            }\n        }\n", "        private async Task PlayChime(string chime)\n        {\n            var uri = new Uri(AppDomain.CurrentDomain.BaseDirectory + $\"Assets\\\\{chime}.aac\");\n            mediaPlayer.Source = MediaSource.CreateFromUri(uri);\n            mediaPlayer.Play();\n            Logger.LogDebug(\"Chime played.\");\n        }\n\n        private async Task MouseWait(bool wait)\n        {\n            InferenceCallback?.Invoke(this, wait);\n        }\n", "        private async Task MouseWait(bool wait)\n        {\n            InferenceCallback?.Invoke(this, wait);\n        }\n\n        private async Task<bool> HandleHotkey(Func<Task<bool>> action)\n        {\n            if (isDisposed || !openAIControlViewModel.IsValidKey())\n            {\n                return await Task.FromResult(false);\n            }\n", "            if (isRecording || isProcessing || micQueueDebouncer.IsRunning && micQueueDebouncer.Elapsed.TotalSeconds < 1)\n            {\n                return await Task.FromResult(true);\n            }\n#if DEBUG\n            Logger.LogDebug(\"Hotkey Down Caught\");\n#else\n            Logger.LogInfo(\"Recording has started ...\");\n#endif\n            micQueueDebouncer.Restart();\n            await PlayChime(\"normalchime\");\n            await micService.StartRecording();\n            isRecording = true;\n            return await action();\n        }\n", "        private async Task<bool> HandleHotkeyRelease(Func<string, Task<bool>> action, string callername)\n        {\n            if (!isRecording || isProcessing)\n            {\n                return await Task.FromResult(true);\n            }\n\n            try\n            {\n                Logger.LogDebug(\"Hotkey Up Caught\");\n                isProcessing = true;\n                await MouseWait(true);\n                await PlayChime(\"lowchime\");\n                micQueueDebouncer.Stop();\n                var elapsed = micQueueDebouncer.Elapsed;\n\n#if DEBUG\n                Logger.LogDebug(\"Stop recording\");\n#else\n                Logger.LogInfo(\"Stopping recording...\");\n#endif", "                if (elapsed.TotalSeconds < 1)\n                    await Task.Delay(1000);\n\n                var file = await micService.StopRecording();\n                await Task.Delay(100);\n                isRecording = false;\n\n                if (elapsed.TotalMilliseconds < 1500)\n                {\n                    Logger.LogError(\"Recording was too short.\");\n                    return await Task.FromResult(true);\n                }\n", "                if (file == null)\n                {\n                    throw new Exception(\"File is null\");\n                }\n#if DEBUG\n                Logger.LogDebug(\"Send recording to Whisper API\");\n#else\n                Logger.LogInfo(\"Initiating Whisper API request...\");\n#endif\n                windowingService.UpdateStatus(\"Waiting for Whisper API Response... (This can lag)\");\n\n                string prompt = string.Empty;\n                var taskwatch = new Stopwatch();\n                taskwatch.Start();", "                using (var scope = Ioc.Default.CreateScope())\n                {\n                    var openAIAPIService = scope.ServiceProvider.GetRequiredService<IOpenAIAPIService>();\n                    var whisperResponseTask = openAIAPIService.GetWhisperResponse(file);\n\n\n                    while (!whisperResponseTask.IsCompleted)\n                    {\n                        await Task.Delay(50);\n                        if (taskwatch.Elapsed.TotalSeconds >= 3)\n                        {\n                            taskwatch.Restart();\n                            Logger.LogInfo(\"   Still waiting...\");\n                        }\n                    }\n                    prompt = await whisperResponseTask;\n                }\n                taskwatch.Stop();\n\n                windowingService.UpdateStatus(\"Whisper API Responded...\");\n#if DEBUG\n                Logger.LogDebug(\"WhisperAPI Prompt Received: \" + prompt);\n#else\n#endif", "                        if (taskwatch.Elapsed.TotalSeconds >= 3)\n                        {\n                            taskwatch.Restart();\n                            Logger.LogInfo(\"   Still waiting...\");\n                        }\n                    }\n                    prompt = await whisperResponseTask;\n                }\n                taskwatch.Stop();\n\n                windowingService.UpdateStatus(\"Whisper API Responded...\");\n#if DEBUG\n                Logger.LogDebug(\"WhisperAPI Prompt Received: \" + prompt);\n#else\n#endif", "                if (string.IsNullOrEmpty(prompt))\n                {\n                    Logger.LogError(\"WhisperAPI Prompt was Empty\");\n                    return await Task.FromResult(true);\n                }\n                Logger.LogInfo(\"Whisper API responded: \" + prompt);\n\n                string? cbstr = \"\";\n\n                if ((settingsService.Load<bool>(WingmanSettings.Append_Clipboard) && callername==\"MAIN_HOTKEY\") || (settingsService.Load<bool>(WingmanSettings.Append_Clipboard_Modal) && callername==\"MODAL_HOTKEY\"))\n                {\n#if DEBUG\n                    Logger.LogDebug(\"WingmanSettings.Append_Clipboard is true.\");\n#else\n                    Logger.LogInfo(\"Appending clipboard to prompt...\");\n#endif\n                    cbstr = await ClipboardHelper.GetTextAsync();", "                if ((settingsService.Load<bool>(WingmanSettings.Append_Clipboard) && callername==\"MAIN_HOTKEY\") || (settingsService.Load<bool>(WingmanSettings.Append_Clipboard_Modal) && callername==\"MODAL_HOTKEY\"))\n                {\n#if DEBUG\n                    Logger.LogDebug(\"WingmanSettings.Append_Clipboard is true.\");\n#else\n                    Logger.LogInfo(\"Appending clipboard to prompt...\");\n#endif\n                    cbstr = await ClipboardHelper.GetTextAsync();\n                    if (!string.IsNullOrEmpty(cbstr))\n                    {\n                        cbstr = PromptCleaners.TrimWhitespaces(cbstr);\n                        cbstr = PromptCleaners.TrimNewlines(cbstr);\n                        prompt += \" \" + cbstr;\n                    }\n                }\n\n                try\n                {\n                    Logger.LogDebug(\"Deleting temporary voice file: \" + file.Path);\n                    await file.DeleteAsync();\n                }", "                    if (!string.IsNullOrEmpty(cbstr))\n                    {\n                        cbstr = PromptCleaners.TrimWhitespaces(cbstr);\n                        cbstr = PromptCleaners.TrimNewlines(cbstr);\n                        prompt += \" \" + cbstr;\n                    }\n                }\n\n                try\n                {\n                    Logger.LogDebug(\"Deleting temporary voice file: \" + file.Path);\n                    await file.DeleteAsync();\n                }", "                catch (Exception e)\n                {\n                    Logger.LogException(\"Error deleting temporary voice file: \" + e.Message);\n                    throw e;\n                }\n\n                string response = String.Empty;\n                using (var scope = Ioc.Default.CreateScope())\n                {\n                    var openAIAPIService = scope.ServiceProvider.GetRequiredService<IOpenAIAPIService>();\n\n                    try\n                    {\n                        windowingService.UpdateStatus(\"Waiting for GPT response...\");\n#if DEBUG\n                        Logger.LogDebug(\"Sending prompt to OpenAI API: \" + prompt);\n#else\n                        Logger.LogInfo(\"Waiting for GPT Response... (This can lag)\");\n#endif\n\n                        var responseTask = openAIAPIService.GetResponse(prompt);\n                        taskwatch = Stopwatch.StartNew();", "                        while (!responseTask.IsCompleted)\n                        {\n                            await Task.Delay(50);\n                            if (taskwatch.Elapsed.TotalSeconds >= 3)\n                            {\n                                taskwatch.Restart();\n                                Logger.LogInfo(\"   Still waiting...\");\n                            }\n                        }\n                        response = await responseTask;\n                        taskwatch.Stop();\n\n                        windowingService.UpdateStatus(\"Response Received ...\");\n                        Logger.LogInfo(\"Received response from GPT...\");\n                    }", "                    catch (Exception e)\n                    {\n                        Logger.LogException(\"Error sending prompt to OpenAI API: \" + e.Message);\n                        throw e;\n                    }\n                }\n\n                await action(response);\n            }\n            catch (Exception e)\n            {\n                Logger.LogException(\"Error handling hotkey release: \" + e.Message);\n                throw e;\n            }\n\n            return await Task.FromResult(true);\n        }\n\n", "            catch (Exception e)\n            {\n                Logger.LogException(\"Error handling hotkey release: \" + e.Message);\n                throw e;\n            }\n\n            return await Task.FromResult(true);\n        }\n\n\n        //private async Task<bool> Events_OnMainHotkey()", "        //private async Task<bool> Events_OnMainHotkey()\n        private async void Events_OnMainHotkey(object sender, EventArgs e)\n        {\n            // return\n            await HandleHotkey(async () =>\n            {\n                // In case hotkeys end up being snowflakes\n                return await Task.FromResult(true);\n            });\n        }\n", "        //private async Task<bool> Events_OnMainHotkeyRelease()\n        private async void Events_OnMainHotkeyRelease(object sender, EventArgs e)\n        {\n            // return\n            await HandleHotkeyRelease(async (response) =>\n            {\n#if DEBUG\n                Logger.LogDebug(\"Returning\");\n#else\n                Logger.LogInfo(\"Sending response to STDOUT...\");\n#endif\n                windowingService.ForceStatusHide();\n                await stdInService.SendWithClipboardAsync(response);\n                return await Task.FromResult(true);\n            }, \"MAIN_HOTKEY\");\n\n            await MouseWait(false);\n            micQueueDebouncer.Restart();\n            isProcessing = false;\n        }\n", "        private async void Events_OnModalHotkey(object sender, EventArgs e)\n        {\n            await HandleHotkey(async () =>\n            {\n                // In case hotkeys end up being snowflakes\n                return await Task.FromResult(true);\n            });\n        }\n\n        //private async Task<bool> Events_OnModalHotkeyRelease()\n        private async void Events_OnModalHotkeyRelease(object sender, EventArgs e)\n        {\n            //return\n            await HandleHotkeyRelease(async (response) =>\n            {\n                Logger.LogInfo(\"Adding response to Clipboard...\");\n                await ClipboardHelper.SetTextAsync(response);\n#if DEBUG\n                Logger.LogDebug(\"Returning\");\n#else\n                Logger.LogInfo(\"Sending response via Modal...\");\n#endif\n                windowingService.ForceStatusHide();\n                await Task.Delay(100); // make sure focus changes are done\n                await windowingService.CreateModal(response);\n                return await Task.FromResult(true);\n            }, \"MODAL_HOTKEY\");\n\n            await MouseWait(false);\n            micQueueDebouncer.Restart();\n            isProcessing = false;\n        }\n    }\n}\n", "        //private async Task<bool> Events_OnModalHotkeyRelease()\n        private async void Events_OnModalHotkeyRelease(object sender, EventArgs e)\n        {\n            //return\n            await HandleHotkeyRelease(async (response) =>\n            {\n                Logger.LogInfo(\"Adding response to Clipboard...\");\n                await ClipboardHelper.SetTextAsync(response);\n#if DEBUG\n                Logger.LogDebug(\"Returning\");\n#else\n                Logger.LogInfo(\"Sending response via Modal...\");\n#endif\n                windowingService.ForceStatusHide();\n                await Task.Delay(100); // make sure focus changes are done\n                await windowingService.CreateModal(response);\n                return await Task.FromResult(true);\n            }, \"MODAL_HOTKEY\");\n\n            await MouseWait(false);\n            micQueueDebouncer.Restart();\n            isProcessing = false;\n        }\n    }\n}\n"]}
{"filename": "Interfaces/IMicrophoneDeviceService.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Windows.Devices.Enumeration;\nusing Windows.Storage;\n\nnamespace wingman.Interfaces\n{\n    public interface IMicrophoneDeviceService\n    {\n        event EventHandler<double> VolumeChanged;\n        Task<IReadOnlyList<MicrophoneDevice>> GetMicrophoneDevicesAsync();\n        Task SetMicrophoneDeviceAsync(MicrophoneDevice device);\n        Task StartRecording();\n        Task<StorageFile?> StopRecording();\n    }\n", "    public interface IMicrophoneDeviceService\n    {\n        event EventHandler<double> VolumeChanged;\n        Task<IReadOnlyList<MicrophoneDevice>> GetMicrophoneDevicesAsync();\n        Task SetMicrophoneDeviceAsync(MicrophoneDevice device);\n        Task StartRecording();\n        Task<StorageFile?> StopRecording();\n    }\n\n    public class MicrophoneDevice\n    {\n        public string? Id { get; set; }\n        public string? Name { get; set; }\n        public DeviceInformation? Info { get; set; }\n    }\n}\n", "    public class MicrophoneDevice\n    {\n        public string? Id { get; set; }\n        public string? Name { get; set; }\n        public DeviceInformation? Info { get; set; }\n    }\n}\n"]}
{"filename": "Interfaces/IOpenAIAPIService.cs", "chunked_list": ["\ufeffusing System.Threading.Tasks;\nusing Windows.Storage;\n\nnamespace wingman.Interfaces\n{\n    public interface IOpenAIAPIService\n    {\n        Task<string?> GetResponse(string prompt);\n        Task<string?> GetWhisperResponse(StorageFile inmp3);\n        Task<bool> IsApiKeyValid();\n    }\n}\n"]}
{"filename": "Interfaces/IWindowingService.cs", "chunked_list": ["\ufeffusing System;\nusing System.Threading.Tasks;\n\nnamespace wingman.Interfaces\n{\n    public interface IWindowingService\n    {\n        Task CreateModal(string content, string title = \"Modal\", int width = 640, int height = 480, bool isresizable = true, bool activated = true);\n        Task CreateCodeModal(string content);\n        void UpdateStatus(string currentStatus);\n        void ForceStatusHide();\n        event EventHandler<string> EventStatusChanged;\n        event EventHandler EventForceStatusHide;\n    }\n}\n"]}
{"filename": "Interfaces/IGlobalHotkeyService.cs", "chunked_list": ["\ufeffusing System;\nusing System.Threading.Tasks;\nusing wingman.Services;\n\nnamespace wingman.Interfaces\n{\n    public interface IGlobalHotkeyService\n    {\n        Task ConfigureHotkeyAsync(Func<string, bool> keyConfigurationCallback);\n\n        void RegisterHotkeyUp(WingmanSettings settingsKey, EventHandler handler);\n        void RegisterHotkeyDown(WingmanSettings settingsKey, EventHandler handler);\n        void UnregisterHotkeyUp(WingmanSettings settingsKey, EventHandler handler);\n        void UnregisterHotkeyDown(WingmanSettings settingsKey, EventHandler handler);\n    }\n}\n"]}
{"filename": "Interfaces/IAppActivationService.cs", "chunked_list": ["namespace wingman.Interfaces\n{\n    public interface IAppActivationService\n    {\n        void Activate(object activationArgs);\n    }\n}"]}
{"filename": "Interfaces/IStdInService.cs", "chunked_list": ["\ufeffusing System.Threading.Tasks;\n\nnamespace wingman.Interfaces\n{\n    public interface IStdInService\n    {\n        Task SendWithClipboardAsync(string str);\n    }\n}\n"]}
{"filename": "Interfaces/ISettingsService.cs", "chunked_list": ["using wingman.Services;\n\nnamespace wingman.Interfaces\n{\n    public interface ISettingsService\n    {\n        T? Load<T>(WingmanSettings key);\n        bool TryLoad<T>(WingmanSettings key, out T? value);\n        void Save<T>(WingmanSettings key, T value);\n        bool TrySave<T>(WingmanSettings key, T value);\n    }\n}"]}
{"filename": "Interfaces/IEventhandlerService.cs", "chunked_list": ["\ufeffusing System;\n\nnamespace wingman.Interfaces\n{\n    public interface IEventHandlerService\n    {\n        EventHandler<bool> InferenceCallback { get; set; }\n    }\n}\n"]}
{"filename": "Interfaces/INamedPipesService.cs", "chunked_list": ["\ufeffusing System.Threading.Tasks;\n\nnamespace wingman.Interfaces\n{\n    public interface INamedPipesService\n    {\n        Task SendMessageAsync(string message);\n    }\n}\n"]}
{"filename": "Interfaces/IEditorService.cs", "chunked_list": ["\ufeffusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nnamespace wingman.Interfaces\n{\n    public interface IEditorService\n    {\n        Task<IReadOnlyList<Process>> GetRunningEditorsAsync();\n    }\n}\n"]}
{"filename": "Updates/AppUpdater.cs", "chunked_list": ["\ufeffusing CommunityToolkit.Mvvm.DependencyInjection;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Windows.Services.Store;\nusing Windows.UI.Core;\nusing wingman.Interfaces;\n\nnamespace wingman.Updates\n{\n    public class AppUpdater\n    {", "namespace wingman.Updates\n{\n    public class AppUpdater\n    {\n        private StoreContext context;\n        private ILoggingService Logger;\n\n        public AppUpdater()\n        {\n            context = StoreContext.GetDefault();\n\n            Logger = Ioc.Default.GetRequiredService<ILoggingService>();\n        }\n", "        public async Task CheckForUpdatesAsync(CoreDispatcher dispatcher)\n        {\n            Logger.LogInfo(\"Checking for updates...\");\n            IReadOnlyList<StorePackageUpdate> storePackageUpdates = await context.GetAppAndOptionalStorePackageUpdatesAsync();\n\n            if (storePackageUpdates.Count > 0)\n            {\n                Logger.LogInfo(\"Updates available.\");\n                if (!context.CanSilentlyDownloadStorePackageUpdates)\n                {\n                    Logger.LogError(\"Unable to silently download store packages\");\n                    return;\n                }\n\n                Logger.LogInfo(\"Downloading updates.\");\n                StorePackageUpdateResult downloadResult = await context.TrySilentDownloadStorePackageUpdatesAsync(storePackageUpdates);\n\n                switch (downloadResult.OverallState)\n                {\n                    case StorePackageUpdateState.Completed:\n                        Logger.LogInfo(\"Updates downloaded.\");", "                if (!context.CanSilentlyDownloadStorePackageUpdates)\n                {\n                    Logger.LogError(\"Unable to silently download store packages\");\n                    return;\n                }\n\n                Logger.LogInfo(\"Downloading updates.\");\n                StorePackageUpdateResult downloadResult = await context.TrySilentDownloadStorePackageUpdatesAsync(storePackageUpdates);\n\n                switch (downloadResult.OverallState)\n                {\n                    case StorePackageUpdateState.Completed:\n                        Logger.LogInfo(\"Updates downloaded.\");", "                        if (IsNowAGoodTimeToRestartApp())\n                        {\n                            Logger.LogInfo(\"Installing updates.\");\n                            await InstallUpdate(storePackageUpdates);\n                        }\n                        else\n                        {\n                            // Retry/reschedule the installation later.\n                            Logger.LogInfo(\"Retrying later.\");\n                            RetryInstallLater(dispatcher);\n                        }\n                        break;\n\n                    case StorePackageUpdateState.Canceled:\n                    case StorePackageUpdateState.ErrorLowBattery:\n                    case StorePackageUpdateState.ErrorWiFiRecommended:\n                    case StorePackageUpdateState.ErrorWiFiRequired:\n                    case StorePackageUpdateState.OtherError:\n                        RetryDownloadAndInstallLater(dispatcher);\n                        break;\n\n                    default:\n                        break;\n                }\n            }\n            else\n            {\n                Logger.LogInfo(\"No Updates available.\");\n            }\n        }\n", "        private async Task InstallUpdate(IReadOnlyList<StorePackageUpdate> storePackageUpdates)\n        {\n            StorePackageUpdateResult installResult = await context.TrySilentDownloadAndInstallStorePackageUpdatesAsync(storePackageUpdates);\n\n            switch (installResult.OverallState)\n            {\n                case StorePackageUpdateState.Canceled:\n                case StorePackageUpdateState.ErrorLowBattery:\n                case StorePackageUpdateState.OtherError:\n                    Logger.LogError(\"Installation Failed: \" + installResult.OverallState.ToString());\n                    Logger.LogError(\"This could be broken.  Try uninstalling/reinstalling from store\");\n                    //RetryInstallLater();\n                    break;\n\n                default:\n                    break;\n            }\n        }\n", "        private bool IsNowAGoodTimeToRestartApp()\n        {\n            // Implement logic to determine if now is a good time to restart the app.\n            // For example, you can check if the app has been idle for a certain period of time.\n            return true;\n        }\n\n        private async void RetryDownloadAndInstallLater(CoreDispatcher dispatcher)\n        {\n            // Implement logic for retrying the download and installation later.\n            // You can use a timer or another scheduling mechanism to retry after a certain period of time.\n        }\n", "        private async void RetryInstallLater(CoreDispatcher dispatcher)\n        {\n            // Implement logic for retrying the installation later.\n            // You can use a timer or another scheduling mechanism to retry after a certain period of time.\n        }\n    }\n}"]}
{"filename": "Views/MainWindow.xaml.cs", "chunked_list": ["using CommunityToolkit.Mvvm.DependencyInjection;\nusing Microsoft.UI.Dispatching;\nusing Microsoft.UI.Input;\nusing Microsoft.UI.Xaml;\nusing Microsoft.UI.Xaml.Controls;\nusing Windows.UI.Core;\nusing wingman.Helpers;\nusing wingman.Interfaces;\nusing wingman.ViewModels;\n", "using wingman.ViewModels;\n\nnamespace wingman.Views\n{\n    public class GridExposeCursor : Grid\n    {\n        public InputCursor Cursor\n        {\n            get => ProtectedCursor;\n\n            set => ProtectedCursor = value;\n        }\n    }\n", "    public sealed partial class MainWindow : Window\n    {\n        public IEventHandlerService eventsHandler;\n        private readonly DispatcherQueue _dispatcherQueue;\n        private App _app;\n\n        public MainWindow(IEventHandlerService eventsHandler)\n        {\n            InitializeComponent();\n\n            _dispatcherQueue = DispatcherQueue.GetForCurrentThread();\n\n            this.eventsHandler = eventsHandler;\n            eventsHandler.InferenceCallback += HandleInferenceAsync;\n\n            ExtendsContentIntoTitleBar = true;\n            SetTitleBar(MainTitleBar);\n            ViewModel = Ioc.Default.GetRequiredService<MainWindowViewModel>();\n\n            this.SetWindowSize(800, 600);\n            this.SetIsResizable(true);\n\n            this.Closed += OnClosed;\n\n            _app = null;\n\n\n            this.SetIcon(\"Assets/wingman.ico\");\n\n        }\n", "        public void SetApp(App app)\n        {\n            this._app = app;\n        }\n\n        public MainWindowViewModel ViewModel { get; }\n\n        private void OnClosed(object sender, WindowEventArgs e)\n        {\n            // Unsubscribe the event handler\n            eventsHandler.InferenceCallback -= HandleInferenceAsync;\n\n            // Remove the event handler for the Closed event\n            ((Window)sender).Closed -= OnClosed;\n", "            if (_app != null)\n                _app.Dispose();\n        }\n\n        private async void HandleInferenceAsync(object sender, bool result)\n        {\n            // Your asynchronous code here\n            if (result)\n            {\n                await CommunityToolkit.WinUI.DispatcherQueueExtensions.EnqueueAsync(_dispatcherQueue, () =>\n                {\n                    // Change the mouse cursor to waiting cursor\n\n                    var cursor = InputCursor.CreateFromCoreCursor(new CoreCursor(CoreCursorType.Wait, 0));\n                    this.MainGrid.Cursor = cursor;\n                    //(ThisIsStupid as UIElement).ChangeCursor(InputSystemCursor.Create(InputSystemCursorShape.Wait));\n\n                });\n            }\n            else\n            {\n                await CommunityToolkit.WinUI.DispatcherQueueExtensions.EnqueueAsync(_dispatcherQueue, () =>\n                {\n                    var cursor = InputCursor.CreateFromCoreCursor(new CoreCursor(CoreCursorType.Arrow, 0));\n                    this.MainGrid.Cursor = cursor;\n\n                    // Change the mouse cursor to arrow cursor\n                    //(ThisIsStupid as UIElement).ChangeCursor(InputSystemCursor.Create(InputSystemCursorShape.Arrow));\n\n\n                });\n            }\n        }\n\n\n\n    }\n}"]}
{"filename": "Views/StatusWindow.xaml.cs", "chunked_list": ["using CommunityToolkit.WinUI;\nusing Microsoft.UI.Dispatching;\nusing Microsoft.UI.Xaml;\nusing Microsoft.UI.Xaml.Input;\nusing System;\nusing System.ComponentModel;\nusing System.Diagnostics;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing wingman.Helpers;", "using System.Threading.Tasks;\nusing wingman.Helpers;\nusing wingman.Interfaces;\n\nnamespace wingman.Views\n{\n    public sealed partial class StatusWindow : Window, INotifyPropertyChanged, IDisposable\n    {\n        private readonly IWindowingService _windowingService;\n        public event PropertyChangedEventHandler PropertyChanged;\n        private readonly EventHandler<string> WindowingService_StatusChanged;", "        private readonly IWindowingService _windowingService;\n        public event PropertyChangedEventHandler PropertyChanged;\n        private readonly EventHandler<string> WindowingService_StatusChanged;\n        private readonly EventHandler WindowingService_ForceStatusHide;\n        private CancellationTokenSource _timerCancellationTokenSource;\n        private readonly DispatcherQueue _dispatcher;\n        private Window _previousActiveWindow;\n        private const int StatusDisplayDurationMilliseconds = 20000;\n        private bool _disposed = false;\n        private bool _disposing = false;\n        private bool _isVisible = false;\n\n        public StatusWindow(IWindowingService windowingService)\n        {\n            _dispatcher = DispatcherQueue.GetForCurrentThread();\n            _windowingService = windowingService;\n\n            WindowingService_StatusChanged = async (sender, status) =>\n            {\n                await StatusChanged(status);\n            };\n\n            _windowingService.EventStatusChanged += WindowingService_StatusChanged;\n\n            WindowingService_ForceStatusHide = async (sender, e) =>\n            {\n                _isVisible = false;\n                await ForceStatusHide();\n            };\n\n            _windowingService.EventForceStatusHide += WindowingService_ForceStatusHide;\n\n\n            _timerCancellationTokenSource = new CancellationTokenSource();\n\n            InitializeComponent();\n\n            this.Activated += StatusWindow_Loaded;\n\n            this.SetTitleBar(null);\n            this.HideTitleBar();\n            this.SetIsResizable(false);\n\n        }\n", "        private bool _disposed = false;\n        private bool _disposing = false;\n        private bool _isVisible = false;\n\n        public StatusWindow(IWindowingService windowingService)\n        {\n            _dispatcher = DispatcherQueue.GetForCurrentThread();\n            _windowingService = windowingService;\n\n            WindowingService_StatusChanged = async (sender, status) =>\n            {\n                await StatusChanged(status);\n            };\n\n            _windowingService.EventStatusChanged += WindowingService_StatusChanged;\n\n            WindowingService_ForceStatusHide = async (sender, e) =>\n            {\n                _isVisible = false;\n                await ForceStatusHide();\n            };\n\n            _windowingService.EventForceStatusHide += WindowingService_ForceStatusHide;\n\n\n            _timerCancellationTokenSource = new CancellationTokenSource();\n\n            InitializeComponent();\n\n            this.Activated += StatusWindow_Loaded;\n\n            this.SetTitleBar(null);\n            this.HideTitleBar();\n            this.SetIsResizable(false);\n\n        }\n", "        private string _currentStatus = string.Empty;\n\n        public string CurrentStatus\n        {\n            get => _currentStatus;\n            set\n            {\n                _currentStatus = value;\n                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(CurrentStatus)));\n            }\n        }\n", "        private void ResizeWindowToContent()\n        {\n            StatusTextBlock.Measure(new Windows.Foundation.Size(double.PositiveInfinity, double.PositiveInfinity));\n            Windows.Foundation.Size desiredSize = StatusTextBlock.DesiredSize;\n\n            int width = (int)Math.Ceiling(desiredSize.Width);\n            int height = (int)Math.Ceiling(desiredSize.Height);\n            this.SetWindowSize(width, height);\n        }\n\n        private void StatusWindow_Loaded(object sender, WindowActivatedEventArgs e)\n        {\n            _previousActiveWindow = Window.Current; // Store the previously active window\n            _isVisible = true;\n            this.SetIsAlwaysOnTop(true);\n            UpdateWindowPosition();\n            RootGrid.PointerPressed += StatusWindow_PointerPressed;\n\n\n            // Immediately return focus to the previously active window", "        private void StatusWindow_Loaded(object sender, WindowActivatedEventArgs e)\n        {\n            _previousActiveWindow = Window.Current; // Store the previously active window\n            _isVisible = true;\n            this.SetIsAlwaysOnTop(true);\n            UpdateWindowPosition();\n            RootGrid.PointerPressed += StatusWindow_PointerPressed;\n\n\n            // Immediately return focus to the previously active window\n            if (_previousActiveWindow != null)\n            {\n                _previousActiveWindow.Activate();\n            }\n        }\n", "            if (_previousActiveWindow != null)\n            {\n                _previousActiveWindow.Activate();\n            }\n        }\n\n        private void StatusWindow_PointerPressed(object sender, PointerRoutedEventArgs e)\n        {\n            _isVisible = false;\n            this.Hide();\n        }\n", "        private async void UpdateWindowPosition()\n        {\n            this.SetWindowPosition(0, 0);\n        }\n\n        private async Task ForceStatusHide()\n        {\n            _isVisible = false;\n            await _dispatcher.EnqueueAsync(() => this.Hide());\n        }\n", "        private async Task StatusChanged(string status)\n        {\n            await _dispatcher.EnqueueAsync(async () =>\n            {\n                if (_previousActiveWindow == null && this != Window.Current)\n                    _previousActiveWindow = Window.Current;\n\n                if (this == Window.Current && _previousActiveWindow != this)\n                    _previousActiveWindow.Activate();\n\n                _timerCancellationTokenSource.Cancel();\n                _timerCancellationTokenSource = new CancellationTokenSource();\n                CancellationToken token = _timerCancellationTokenSource.Token;\n\n                CurrentStatus = status;\n", "                if (!_isVisible)\n                    this.Activate();\n\n\n\n                ResizeWindowToContent();\n                UpdateWindowPosition();\n\n                await ManageTimerAsync(token);\n            });\n        }\n\n", "        private async Task ManageTimerAsync(CancellationToken token)\n        {\n            try\n            {\n                await Task.Delay(StatusDisplayDurationMilliseconds, token);\n                await _dispatcher.EnqueueAsync(() => { _isVisible=false; this.Hide(); });\n            }\n            catch (TaskCanceledException)\n            {\n                // Do nothing, timer was reset\n            }", "            catch (Exception ex)\n            {\n                // Handle other unexpected exceptions here\n                Debug.WriteLine($\"ManageTimerAsync Exception: {ex.Message}\");\n            }\n        }\n\n        protected void Dispose(bool disposing)\n        {\n            if (!_disposed)\n            {", "            if (!_disposed)\n            {\n                if (disposing)\n                {\n                    RootGrid.PointerPressed -= StatusWindow_PointerPressed;\n                    _windowingService.EventStatusChanged -= WindowingService_StatusChanged;\n                    _windowingService.EventForceStatusHide -= WindowingService_ForceStatusHide;\n                    _timerCancellationTokenSource?.Cancel();\n                    _timerCancellationTokenSource?.Dispose();\n                    this.Close();\n                    _disposed = true;\n                    Debug.WriteLine(\"StatusWindow Disposed\");\n\n                }\n            }\n        }\n", "        public void Dispose()\n        {\n            _disposing = true;\n            Dispose(_disposing);\n            GC.SuppressFinalize(this);\n            Debug.WriteLine(\"StatusWindow Disposed\");\n        }\n\n        private void RootGrid_Loaded(object sender, RoutedEventArgs e)\n        {\n            // Set the DataContext of the RootGrid to the current instance\n            RootGrid.DataContext = this;\n        }\n\n\n    }\n}\n\n", "        private void RootGrid_Loaded(object sender, RoutedEventArgs e)\n        {\n            // Set the DataContext of the RootGrid to the current instance\n            RootGrid.DataContext = this;\n        }\n\n\n    }\n}\n\n"]}
{"filename": "Views/AppTitleBar.xaml.cs", "chunked_list": ["using Microsoft.UI.Xaml;\nusing Microsoft.UI.Xaml.Controls;\nusing Microsoft.UI.Xaml.Media;\n\nnamespace wingman.Views\n{\n    public sealed partial class AppTitleBar : UserControl\n    {\n        public static readonly DependencyProperty IconProperty = DependencyProperty.Register(\n            nameof(Icon),\n            typeof(ImageSource),\n            typeof(AppTitleBar),\n            new PropertyMetadata(default));\n", "        public static readonly DependencyProperty IconProperty = DependencyProperty.Register(\n            nameof(Icon),\n            typeof(ImageSource),\n            typeof(AppTitleBar),\n            new PropertyMetadata(default));\n\n        public static readonly DependencyProperty TextProperty = DependencyProperty.Register(\n            nameof(Text),\n            typeof(string),\n            typeof(AppTitleBar),\n            new PropertyMetadata(default));\n", "        public static readonly DependencyProperty IconWidthProperty = DependencyProperty.Register(\n            nameof(IconWidth),\n            typeof(double),\n            typeof(AppTitleBar),\n            new PropertyMetadata(16.0));\n\n        public static readonly DependencyProperty IconHeightProperty = DependencyProperty.Register(\n            nameof(IconHeight),\n            typeof(double),\n            typeof(AppTitleBar),\n            new PropertyMetadata(16.0));\n", "        public static readonly DependencyProperty IconMarginProperty = DependencyProperty.Register(\n            nameof(IconMargin),\n            typeof(Thickness),\n            typeof(AppTitleBar),\n            new PropertyMetadata(default));\n\n        public static readonly DependencyProperty TextMarginProperty = DependencyProperty.Register(\n            nameof(TextMargin),\n            typeof(Thickness),\n            typeof(AppTitleBar),\n            new PropertyMetadata(default));\n", "        public static readonly DependencyProperty TextWrappingProperty = DependencyProperty.Register(\n            nameof(TextWrapping),\n            typeof(TextWrapping),\n            typeof(AppTitleBar),\n            new PropertyMetadata(default));\n\n        public static readonly DependencyProperty TextFontSizeProperty = DependencyProperty.Register(\n            nameof(TextFontSize),\n            typeof(double),\n            typeof(AppTitleBar),\n            new PropertyMetadata(10.0));\n\n        public AppTitleBar()\n        {\n            InitializeComponent();\n        }\n", "        public ImageSource Icon\n        {\n            get => (ImageSource)GetValue(IconProperty);\n            set => SetValue(IconProperty, value);\n        }\n\n        public string Text\n        {\n            get => (string)GetValue(TextProperty);\n            set => SetValue(TextProperty, value);\n        }\n", "        public double IconWidth\n        {\n            get => (double)GetValue(IconWidthProperty);\n            set => SetValue(IconWidthProperty, value);\n        }\n\n        public double IconHeight\n        {\n            get => (double)GetValue(IconHeightProperty);\n            set => SetValue(IconHeightProperty, value);\n        }\n", "        public Thickness IconMargin\n        {\n            get => (Thickness)GetValue(IconMarginProperty);\n            set => SetValue(IconMarginProperty, value);\n        }\n\n        public Thickness TextMargin\n        {\n            get => (Thickness)GetValue(TextMarginProperty);\n            set => SetValue(TextMarginProperty, value);\n        }\n", "        public TextWrapping TextWrapping\n        {\n            get => (TextWrapping)GetValue(TextWrappingProperty);\n            set => SetValue(TextWrappingProperty, value);\n        }\n\n        public double TextFontSize\n        {\n            get => (double)GetValue(TextFontSizeProperty);\n            set => SetValue(TextFontSizeProperty, value);\n        }\n    }\n}"]}
{"filename": "Views/MainPage.xaml.cs", "chunked_list": ["using CommunityToolkit.Mvvm.DependencyInjection;\nusing Microsoft.UI.Xaml.Controls;\nusing wingman.ViewModels;\n\nnamespace wingman.Views\n{\n    public sealed partial class MainPage : Page\n    {\n        public MainPage()\n        {\n            InitializeComponent();\n            ViewModel = Ioc.Default.GetRequiredService<MainPageViewModel>();\n            DataContext = ViewModel;\n        }\n", "        public MainPageViewModel ViewModel { get; }\n\n    }\n}"]}
{"filename": "Views/ModalWindow.xaml.cs", "chunked_list": ["using Microsoft.UI.Xaml;\nusing wingman.Helpers;\n\nnamespace wingman.Views\n{\n    public sealed partial class ModalWindow : Window\n    {\n        readonly bool isClosing = false;\n        public ModalWindow(string input, int width = 800, int height = 600, bool isResizable = true)\n        {\n            InitializeComponent();\n            this.SetIsAlwaysOnTop(true);\n            ExtendsContentIntoTitleBar = true;\n            SetTitleBar(ModalTitleBar);\n            this.SetWindowSize(width, height);\n            this.SetIsResizable(isResizable);\n            myView.ViewModel.TextContent = input;\n            AppTitleTextBlock.Text = this.Title;\n\n            this.Activated += ModalWindow_Activated;\n            this.Closed += ModalWindow_Closed;\n        }\n", "        private void ModalWindow_Closed(object sender, WindowEventArgs args)\n        {\n            this.Activated -= ModalWindow_Activated;\n            this.Closed -= ModalWindow_Closed;\n        }\n\n        private void ModalWindow_Activated(object sender, WindowActivatedEventArgs args)\n        {\n            if (!isClosing)\n                this.SetIsAlwaysOnTop(false);\n        }\n    }\n}", "            if (!isClosing)\n                this.SetIsAlwaysOnTop(false);\n        }\n    }\n}"]}
{"filename": "Views/Footer.xaml.cs", "chunked_list": ["using CommunityToolkit.Mvvm.DependencyInjection;\nusing Microsoft.UI.Xaml;\nusing Microsoft.UI.Xaml.Controls;\nusing Microsoft.UI.Xaml.Media;\nusing wingman.ViewModels;\n\nnamespace wingman.Views\n{\n    public sealed partial class Footer : Page\n    {\n\n\n        public Footer()\n        {\n            InitializeComponent();\n            ViewModel = Ioc.Default.GetRequiredService<FooterViewModel>();\n            DataContext = ViewModel;\n        }\n", "    public sealed partial class Footer : Page\n    {\n\n\n        public Footer()\n        {\n            InitializeComponent();\n            ViewModel = Ioc.Default.GetRequiredService<FooterViewModel>();\n            DataContext = ViewModel;\n        }\n", "        public FooterViewModel ViewModel { get; }\n\n\n    }\n\n    public static class TextBoxBehavior\n    {\n        public static readonly DependencyProperty AutoScrollProperty =\n            DependencyProperty.RegisterAttached(\"AutoScroll\", typeof(bool), typeof(TextBoxBehavior), new PropertyMetadata(false, OnAutoScrollChanged));\n\n        public static bool GetAutoScroll(DependencyObject obj)\n        {\n            return (bool)obj.GetValue(AutoScrollProperty);\n        }\n", "        public static bool GetAutoScroll(DependencyObject obj)\n        {\n            return (bool)obj.GetValue(AutoScrollProperty);\n        }\n\n        public static void SetAutoScroll(DependencyObject obj, bool value)\n        {\n            obj.SetValue(AutoScrollProperty, value);\n        }\n\n        private static void OnAutoScrollChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)\n        {", "        private static void OnAutoScrollChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)\n        {\n            if (d is TextBox textBox && e.NewValue is bool autoScroll)\n            {\n                if (autoScroll)\n                {\n                    textBox.TextChanged += OnTextChanged;\n                    ScrollToBottom(textBox);\n                }\n                else\n                {\n                    textBox.TextChanged -= OnTextChanged;\n                }\n            }\n        }\n", "        private static void OnTextChanged(object sender, TextChangedEventArgs e)\n        {\n            if (sender is TextBox textBox)\n            {\n                ScrollToBottom(textBox);\n            }\n        }\n\n        private static void ScrollToBottom(TextBox textBox)\n        {\n            var grid = (Grid)VisualTreeHelper.GetChild(textBox, 0);", "        private static void ScrollToBottom(TextBox textBox)\n        {\n            var grid = (Grid)VisualTreeHelper.GetChild(textBox, 0);\n            if (grid != null)\n            {\n                for (var i = 0; i <= VisualTreeHelper.GetChildrenCount(grid) - 1; i++)\n                {\n                    object obj = VisualTreeHelper.GetChild(grid, i);\n                    if (!(obj is ScrollViewer)) continue;\n                    ((ScrollViewer)obj).ChangeView(0.0f, ((ScrollViewer)obj).ExtentHeight, 1.0f);\n                    break;\n                }\n            }\n        }\n    }\n", "                    if (!(obj is ScrollViewer)) continue;\n                    ((ScrollViewer)obj).ChangeView(0.0f, ((ScrollViewer)obj).ExtentHeight, 1.0f);\n                    break;\n                }\n            }\n        }\n    }\n\n    public static class ScrollViewerBehavior\n    {\n        public static readonly DependencyProperty AutoScrollProperty =\n            DependencyProperty.RegisterAttached(\"AutoScroll\", typeof(bool), typeof(ScrollViewerBehavior), new PropertyMetadata(false, OnAutoScrollChanged));\n", "    public static class ScrollViewerBehavior\n    {\n        public static readonly DependencyProperty AutoScrollProperty =\n            DependencyProperty.RegisterAttached(\"AutoScroll\", typeof(bool), typeof(ScrollViewerBehavior), new PropertyMetadata(false, OnAutoScrollChanged));\n\n        public static bool GetAutoScroll(DependencyObject obj)\n        {\n            return (bool)obj.GetValue(AutoScrollProperty);\n        }\n\n        public static void SetAutoScroll(DependencyObject obj, bool value)\n        {\n            obj.SetValue(AutoScrollProperty, value);\n        }\n", "        public static void SetAutoScroll(DependencyObject obj, bool value)\n        {\n            obj.SetValue(AutoScrollProperty, value);\n        }\n\n        private static void OnAutoScrollChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)\n        {\n            if (d is ScrollViewer scrollViewer && e.NewValue is bool autoScroll)\n            {\n                if (autoScroll)\n                {\n                    scrollViewer.ViewChanged += OnViewChanged;\n                    ScrollToBottom(scrollViewer);\n                }\n                else\n                {\n                    scrollViewer.ViewChanged -= OnViewChanged;\n                }\n            }\n        }\n", "                if (autoScroll)\n                {\n                    scrollViewer.ViewChanged += OnViewChanged;\n                    ScrollToBottom(scrollViewer);\n                }\n                else\n                {\n                    scrollViewer.ViewChanged -= OnViewChanged;\n                }\n            }\n        }\n", "        private static void OnViewChanged(object sender, ScrollViewerViewChangedEventArgs e)\n        {\n            if (sender is ScrollViewer scrollViewer && !e.IsIntermediate)\n            {\n                ScrollToBottom(scrollViewer);\n            }\n        }\n\n        private static void ScrollToBottom(ScrollViewer scrollViewer)\n        {\n            scrollViewer.ChangeView(null, scrollViewer.ScrollableHeight, null);\n        }\n    }\n}\n\n", "        private static void ScrollToBottom(ScrollViewer scrollViewer)\n        {\n            scrollViewer.ChangeView(null, scrollViewer.ScrollableHeight, null);\n        }\n    }\n}\n\n"]}
{"filename": "Views/Controls/ModalControl.xaml.cs", "chunked_list": ["using CommunityToolkit.Mvvm.DependencyInjection;\nusing Microsoft.UI.Xaml.Controls;\nusing wingman.ViewModels;\n\nnamespace wingman.Views\n{\n    public sealed partial class ModalControl : UserControl\n    {\n        public ModalControl()\n        {\n            InitializeComponent();\n            ViewModel = Ioc.Default.GetRequiredService<ModalControlViewModel>();\n            DataContext = ViewModel;\n        }\n", "        public ModalControlViewModel ViewModel { get; }\n\n    }\n}"]}
{"filename": "Views/Controls/AudioInputControl.xaml.cs", "chunked_list": ["using CommunityToolkit.Mvvm.DependencyInjection;\nusing Microsoft.UI.Xaml.Controls;\nusing wingman.ViewModels;\n\nnamespace wingman.Views\n{\n    public sealed partial class AudioInputControl : UserControl\n    {\n        public AudioInputControl()\n        {\n            InitializeComponent();\n            ViewModel = Ioc.Default.GetRequiredService<AudioInputControlViewModel>();\n            DataContext=ViewModel;\n        }\n", "        public AudioInputControlViewModel ViewModel { get; }\n    }\n}"]}
{"filename": "Views/Controls/OpenAIControl.xaml.cs", "chunked_list": ["using CommunityToolkit.Mvvm.DependencyInjection;\nusing wingman.ViewModels;\n\nnamespace wingman.Views\n{\n    public sealed partial class OpenAIControl : Microsoft.UI.Xaml.Controls.UserControl\n    {\n        public OpenAIControl()\n        {\n            InitializeComponent();\n            ViewModel = Ioc.Default.GetRequiredService<OpenAIControlViewModel>();\n            DataContext = ViewModel;\n        }\n", "        public OpenAIControlViewModel ViewModel { get; }\n    }\n}\n\n"]}
