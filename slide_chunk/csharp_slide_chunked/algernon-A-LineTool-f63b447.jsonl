{"filename": "Code/Loading.cs", "chunked_list": ["\ufeff// <copyright file=\"Loading.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod\n{\n    using System.Collections.Generic;\n    using AlgernonCommons.Patching;\n    using ICities;", "    using AlgernonCommons.Patching;\n    using ICities;\n\n    /// <summary>\n    /// Main loading class: the mod runs from here.\n    /// </summary>\n    public sealed class Loading : PatcherLoadingBase<OptionsPanel, Patcher>\n    {\n        /// <summary>\n        /// Gets a list of permitted loading modes.\n        /// </summary>", "        protected override List<AppMode> PermittedModes => new List<AppMode> { AppMode.Game, AppMode.MapEditor, AppMode.AssetEditor, AppMode.ScenarioEditor };\n\n        /// <summary>\n        /// Performs any actions upon successful creation of the mod.\n        /// E.g. Can be used to patch any other mods.\n        /// </summary>\n        /// <param name=\"loading\">Loading mode (e.g. game or editor).</param>\n        protected override void CreatedActions(ILoading loading)\n        {\n            base.CreatedActions(loading);\n\n            // Patch Find it.\n            PatcherManager<Patcher>.Instance.PatchFindIt();\n        }\n\n        /// <summary>\n        /// Performs any actions upon successful level loading completion.\n        /// </summary>\n        /// <param name=\"mode\">Loading mode (e.g. game, editor, scenario, etc.).</param>", "        protected override void LoadedActions(LoadMode mode)\n        {\n            base.LoadedActions(mode);\n\n            // Set up line tool.\n            ToolsModifierControl.toolController.gameObject.AddComponent<LineTool>();\n        }\n    }\n}\n"]}
{"filename": "Code/ConflictDetection.cs", "chunked_list": ["\ufeff// <copyright file=\"ConflictDetection.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod\n{\n    using System.Collections.Generic;\n    using System.Reflection;\n    using AlgernonCommons;", "    using System.Reflection;\n    using AlgernonCommons;\n    using AlgernonCommons.Notifications;\n    using AlgernonCommons.Translation;\n    using ColossalFramework.Plugins;\n    using ColossalFramework.UI;\n\n    /// <summary>\n    /// Mod conflict detection.\n    /// </summary>\n    internal sealed class ConflictDetection\n    {\n        // List of conflicting mods.\n        private List<string> _conflictingModNames;\n\n        /// <summary>\n        /// Checks for mod conflicts and displays a notification when a conflict is detected.\n        /// </summary>\n        /// <returns>True if a mod conflict was detected, false otherwise.</returns>\n        internal bool CheckModConflicts()\n        {\n            _conflictingModNames = CheckConflictingMods();\n\n            bool conflictDetected = _conflictingModNames != null && _conflictingModNames.Count > 0;", "    /// Mod conflict detection.\n    /// </summary>\n    internal sealed class ConflictDetection\n    {\n        // List of conflicting mods.\n        private List<string> _conflictingModNames;\n\n        /// <summary>\n        /// Checks for mod conflicts and displays a notification when a conflict is detected.\n        /// </summary>\n        /// <returns>True if a mod conflict was detected, false otherwise.</returns>\n        internal bool CheckModConflicts()\n        {\n            _conflictingModNames = CheckConflictingMods();\n\n            bool conflictDetected = _conflictingModNames != null && _conflictingModNames.Count > 0;", "            if (conflictDetected)\n            {\n                // First, check to see if UIView is ready.\n                if (UIView.GetAView() != null)\n                {\n                    // It's ready - display the notification now.\n                    DisplayNotification();\n                }\n                else\n                {\n                    // Otherwise, queue the notification for when the intro's finished loading.\n                    LoadingManager.instance.m_introLoaded += DisplayNotification;\n\n                    // Also queue the notification for level loading.\n                    LoadingManager.instance.m_levelLoaded += (updateMode) => DisplayNotification();\n                }\n            }\n\n            return conflictDetected;\n        }\n\n        /// <summary>\n        /// Displays the mod conflict notification.\n        /// </summary>", "        private void DisplayNotification()\n        {\n            // Mod conflict detected - display warning notification.\n            ListNotification modConflictNotification = NotificationBase.ShowNotification<ListNotification>();\n            if (modConflictNotification != null)\n            {\n                // Key text items.\n                modConflictNotification.AddParas(Translations.Translate(\"CONFLICT_DETECTED\"), Translations.Translate(\"UNABLE_TO_OPERATE\"), Translations.Translate(\"CONFLICTING_MODS\"));\n\n                // Add conflicting mod name(s).\n                modConflictNotification.AddList(_conflictingModNames.ToArray());\n            }\n        }\n\n        /// <summary>\n        /// Checks for any known fatal mod conflicts.\n        /// </summary>\n        /// <returns>A list of conflicting mod names if a mod conflict was detected, false otherwise.</returns>\n        private List<string> CheckConflictingMods()\n        {\n            // Initialise flag and list of conflicting mods.\n            bool conflictDetected = false;\n            List<string> conflictingModNames = new List<string>();\n\n            // Iterate through the full list of plugins.", "            foreach (PluginManager.PluginInfo plugin in PluginManager.instance.GetPluginsInfo())\n            {\n                foreach (Assembly assembly in plugin.GetAssemblies())\n                {\n                    switch (assembly.GetName().Name)\n                    {\n                        case \"EManagersLib\":\n                            // EML. Okay to just be disabled.\n                            if (plugin.isEnabled)\n                            {\n                                conflictDetected = true;\n                                conflictingModNames.Add(\"Extended Managers Library\");\n                            }\n\n                            break;\n\n                        case \"VanillaGarbageBinBlocker\":\n                            // Garbage Bin Controller.\n                            conflictDetected = true;\n                            conflictingModNames.Add(\"Garbage Bin Controller\");\n                            break;\n\n                        case \"Painter\":\n                            // Painter - this one is trickier because both Painter and Repaint use Painter.dll (thanks to CO savegame serialization...).", "                            if (plugin.isEnabled)\n                            {\n                                conflictDetected = true;\n                                conflictingModNames.Add(\"Extended Managers Library\");\n                            }\n\n                            break;\n\n                        case \"VanillaGarbageBinBlocker\":\n                            // Garbage Bin Controller.\n                            conflictDetected = true;\n                            conflictingModNames.Add(\"Garbage Bin Controller\");\n                            break;\n\n                        case \"Painter\":\n                            // Painter - this one is trickier because both Painter and Repaint use Painter.dll (thanks to CO savegame serialization...).", "                            if (plugin.userModInstance.GetType().ToString().Equals(\"Painter.UserMod\"))\n                            {\n                                conflictDetected = true;\n                                conflictingModNames.Add(\"Painter\");\n                            }\n\n                            break;\n                    }\n                }\n            }\n\n            // Was a conflict detected?", "            if (conflictDetected)\n            {\n                // Yes - log each conflict.\n                foreach (string conflictingMod in conflictingModNames)\n                {\n                    Logging.Error(\"Conflicting mod found: \", conflictingMod);\n                }\n\n                return conflictingModNames;\n            }\n\n            // If we got here, no conflict was detected; return null.\n            return null;\n        }\n    }\n}\n"]}
{"filename": "Code/Mod.cs", "chunked_list": ["\ufeff// <copyright file=\"Mod.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod\n{\n    using AlgernonCommons;\n    using AlgernonCommons.Patching;\n    using AlgernonCommons.Translation;", "    using AlgernonCommons.Patching;\n    using AlgernonCommons.Translation;\n    using ColossalFramework.Plugins;\n    using ICities;\n\n    /// <summary>\n    /// The base mod class for instantiation by the game.\n    /// </summary>\n    public sealed class Mod : PatcherMod<OptionsPanel, Patcher>, IUserMod\n    {\n        /// <summary>\n        /// Gets the mod's base display name (name only).\n        /// </summary>", "    public sealed class Mod : PatcherMod<OptionsPanel, Patcher>, IUserMod\n    {\n        /// <summary>\n        /// Gets the mod's base display name (name only).\n        /// </summary>\n        public override string BaseName => \"Line Tool\";\n\n        /// <summary>\n        /// Gets the mod's unique Harmony identfier.\n        /// </summary>\n        public override string HarmonyID => \"com.github.algernon-A.csl.linetool\";\n\n        /// <summary>\n        /// Gets the mod's description for display in the content manager.\n        /// </summary>", "        public override string HarmonyID => \"com.github.algernon-A.csl.linetool\";\n\n        /// <summary>\n        /// Gets the mod's description for display in the content manager.\n        /// </summary>\n        public string Description => Translations.Translate(\"MOD_DESCRIPTION\");\n\n        /// <summary>\n        /// Called by the game when the mod is enabled.\n        /// </summary>\n        public override void OnEnabled()\n        {\n            // Perform conflict detection.\n            ConflictDetection conflictDetection = new ConflictDetection();", "        public override void OnEnabled()\n        {\n            // Perform conflict detection.\n            ConflictDetection conflictDetection = new ConflictDetection();\n            if (conflictDetection.CheckModConflicts())\n            {\n                Logging.Error(\"aborting activation due to conflicting mods\");\n\n                // Load mod settings to ensure that correct language is selected for notification display.\n                LoadSettings();\n\n                // Disable mod.", "                if (AssemblyUtils.ThisPlugin is PluginManager.PluginInfo plugin)\n                {\n                    Logging.KeyMessage(\"disabling mod\");\n                    plugin.isEnabled = false;\n                }\n\n                // Don't do anything further.\n                return;\n            }\n\n            base.OnEnabled();\n        }\n\n        /// <summary>\n        /// Saves settings file.\n        /// </summary>", "        public override void SaveSettings() => ModSettings.Save();\n\n        /// <summary>\n        /// Loads settings file.\n        /// </summary>\n        public override void LoadSettings()\n        {\n            ModSettings.Load();\n        }\n    }\n}\n"]}
{"filename": "Code/UI/ToolModePanel.cs", "chunked_list": ["\ufeff// <copyright file=\"ToolModePanel.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod\n{\n    using AlgernonCommons.Translation;\n    using AlgernonCommons.UI;\n    using ColossalFramework.UI;", "    using AlgernonCommons.UI;\n    using ColossalFramework.UI;\n    using LineToolMod.Modes;\n    using UnityEngine;\n\n    /// <summary>\n    /// Mode selection buttons panel for the line tool.\n    /// </summary>\n    internal class ToolModePanel : StandalonePanelBase\n    {\n        // Mode button size.", "    internal class ToolModePanel : StandalonePanelBase\n    {\n        // Mode button size.\n        private const float ButtonSize = 36f;\n\n        // Panel components.\n        private UIMultiStateButton _optionsPanelToggle;\n\n        // Tool selection indicies.\n        private enum ModeIndexes : int\n        {\n            None = -1,\n            Single,\n            Line,\n            Curve,\n            Freeform,\n            Circle,\n            NumModes,\n        }\n\n        /// <summary>\n        /// Gets the panel width.\n        /// </summary>", "        private enum ModeIndexes : int\n        {\n            None = -1,\n            Single,\n            Line,\n            Curve,\n            Freeform,\n            Circle,\n            NumModes,\n        }\n\n        /// <summary>\n        /// Gets the panel width.\n        /// </summary>", "        public override float PanelWidth => ButtonSize * ((int)ModeIndexes.NumModes + 2);\n\n        /// <summary>\n        /// Gets the panel height.\n        /// </summary>\n        public override float PanelHeight => ButtonSize;\n\n        /// <summary>\n        /// Gets a value indicating whether the panel's previous position should be remembered after closing.\n        /// </summary>\n        public override bool RememberPosition => false;\n\n        /// <summary>\n        /// Called by Unity before the first frame.\n        /// Used to perform setup.\n        /// </summary>", "        public override bool RememberPosition => false;\n\n        /// <summary>\n        /// Called by Unity before the first frame.\n        /// Used to perform setup.\n        /// </summary>\n        public override void Start()\n        {\n            base.Start();\n\n            // Add mode tabstrip.\n            float tabStripWidth = ButtonSize * (int)ModeIndexes.NumModes;\n            UITabstrip controlTabStrip = AddUIComponent<UITabstrip>();\n            controlTabStrip.relativePosition = new Vector2(-Margin, 0f);\n            controlTabStrip.width = tabStripWidth;\n            controlTabStrip.height = ButtonSize;\n            controlTabStrip.padding.right = 0;\n\n            // Get button template.\n            UIButton buttonTemplate = GameObject.Find(\"ToolMode\").GetComponent<UITabstrip>().GetComponentInChildren<UIButton>();\n\n            // Add buttons.\n            AddTabTextButton(controlTabStrip, buttonTemplate, \"Single\", \"POINT\", \"\u2022\", 1.5f, 0, 1, 4, 0);\n            AddTabSpriteButton(controlTabStrip, buttonTemplate, \"Straight\", \"STRAIGHT_LINE\");\n            AddTabSpriteButton(controlTabStrip, buttonTemplate, \"Curved\", \"CURVE\");\n            AddTabSpriteButton(controlTabStrip, buttonTemplate, \"Freeform\", \"FREEFORM\");\n            AddTabTextButton(controlTabStrip, buttonTemplate, \"Circle\", \"CIRCLE\", \"\u25cb\", 3.0f, -2, 1, -13, 0);\n\n            // Fence mode toggle.\n            UITextureAtlas toggleAtlas = UITextures.CreateSpriteAtlas(\"LineToolToggles\", 1024, \"PLT\");\n            UIMultiStateButton fenceModeToggle = AddToggleButton(this, \"FenceMode\", toggleAtlas, \"PLT_MultiState\", \"PLT_FenceMode\");\n            fenceModeToggle.relativePosition = controlTabStrip.relativePosition + new Vector3(tabStripWidth, 0f);\n            fenceModeToggle.tooltip = Translations.Translate(\"FENCEMODE\");\n            fenceModeToggle.activeStateIndex = LineTool.Instance.FenceMode ? 1 : 0;\n            fenceModeToggle.eventActiveStateIndexChanged += (c, state) =>\n            {\n                LineTool.Instance.FenceMode = state != 0;\n            };\n\n            // Options panel toggle.\n            _optionsPanelToggle = AddToggleButton(this, \"Options\", toggleAtlas, \"PLT_MultiState\", \"PLT_ToggleCP\");\n            _optionsPanelToggle.relativePosition = fenceModeToggle.relativePosition + new Vector3(ButtonSize, 0f);\n            _optionsPanelToggle.tooltip = Translations.Translate(\"LINE_OPTIONS\");\n            _optionsPanelToggle.eventActiveStateIndexChanged += (c, state) =>\n            {", "                if (state == 0)\n                {\n                    StandalonePanelManager<ToolOptionsPanel>.Panel?.Close();\n                }\n                else\n                {\n                    StandalonePanelManager<ToolOptionsPanel>.Create();\n                    StandalonePanelManager<ToolOptionsPanel>.Panel.EventClose += OptionsPanelClosed;\n                }\n            };\n\n            // Event handler.\n            controlTabStrip.eventSelectedIndexChanged += TabIndexChanged;\n\n            // Make sure tool options panel is closed when this is closed.\n            EventClose += () => StandalonePanelManager<ToolOptionsPanel>.Panel?.Close();\n        }\n\n        /// <summary>\n        /// Gets the panel's default position.\n        /// </summary>", "        public override void ApplyDefaultPosition()\n        {\n            // Set position.\n            UIComponent optionsBar = GameObject.Find(\"OptionsBar\").GetComponent<UIComponent>();\n            absolutePosition = optionsBar.absolutePosition;\n        }\n\n        /// <summary>\n        /// Updates the options panel button state when the options panel is closed.\n        /// </summary>\n        private void OptionsPanelClosed() => _optionsPanelToggle.activeStateIndex = 0;\n\n        /// <summary>\n        /// Appends a tab button with text to a tabstrip.\n        /// </summary>\n        /// <param name=\"tabstrip\">Tabstrip to append to.</param>\n        /// <param name=\"template\">Button template.</param>\n        /// <param name=\"name\">Button name.</param>\n        /// <param name=\"tooltipKey\">Tooltop key.</param>\n        /// <param name=\"displayText\">Text to display.</param>\n        /// <param name=\"textScale\">Text scale.</param>\n        /// <param name=\"leftPadding\">Text padding (left).</param>\n        /// <param name=\"rightPadding\">Text padding (right).</param>\n        /// <param name=\"topPadding\">Text padding (top).</param>\n        /// <param name=\"bottomPadding\">Text padding (button).</param>", "        private void OptionsPanelClosed() => _optionsPanelToggle.activeStateIndex = 0;\n\n        /// <summary>\n        /// Appends a tab button with text to a tabstrip.\n        /// </summary>\n        /// <param name=\"tabstrip\">Tabstrip to append to.</param>\n        /// <param name=\"template\">Button template.</param>\n        /// <param name=\"name\">Button name.</param>\n        /// <param name=\"tooltipKey\">Tooltop key.</param>\n        /// <param name=\"displayText\">Text to display.</param>\n        /// <param name=\"textScale\">Text scale.</param>\n        /// <param name=\"leftPadding\">Text padding (left).</param>\n        /// <param name=\"rightPadding\">Text padding (right).</param>\n        /// <param name=\"topPadding\">Text padding (top).</param>\n        /// <param name=\"bottomPadding\">Text padding (button).</param>", "        private void AddTabTextButton(UITabstrip tabstrip, UIButton template, string name, string tooltipKey, string displayText, float textScale, int leftPadding, int rightPadding, int topPadding, int bottomPadding)\n        {\n            // Add basic button.\n            UIButton newButton = AddTabButton(tabstrip, template, name, tooltipKey);\n\n            // Clear sprites.\n            newButton.normalFgSprite = string.Empty;\n            newButton.focusedFgSprite = string.Empty;\n            newButton.hoveredFgSprite = string.Empty;\n            newButton.pressedFgSprite = string.Empty;\n            newButton.disabledFgSprite = string.Empty;\n\n            // Set text.\n            newButton.text = displayText;\n            newButton.textScale = textScale;\n\n            // Set text padding.\n            newButton.textPadding.left = leftPadding;\n            newButton.textPadding.right = rightPadding;\n            newButton.textPadding.top = topPadding;\n            newButton.textPadding.bottom = bottomPadding;\n\n            // Set text colour.\n            newButton.textColor = new Color32(119, 124, 126, 255);\n            newButton.hoveredTextColor = new Color32(110, 113, 114, 255);\n            newButton.pressedTextColor = new Color32(172, 175, 176, 255);\n            newButton.focusedTextColor = new Color32(187, 224, 235, 255);\n            newButton.disabledTextColor = new Color32(66, 69, 70, 255);\n        }\n\n        /// <summary>\n        /// Appends a tab button with sprite to a tabstrip.\n        /// </summary>\n        /// <param name=\"tabstrip\">Tabstrip to append to.</param>\n        /// <param name=\"template\">Button template.</param>\n        /// <param name=\"name\">Button name.</param>\n        /// <param name=\"tooltipKey\">Tooltop key.</param>", "        private void AddTabSpriteButton(UITabstrip tabstrip, UIButton template, string name, string tooltipKey)\n        {\n            // Add basic button.\n            UIButton newButton = AddTabButton(tabstrip, template, name, tooltipKey);\n\n            // Set sprites.\n            string spriteBaseName = \"RoadOption\" + name;\n            newButton.normalFgSprite = spriteBaseName;\n            newButton.focusedFgSprite = spriteBaseName + \"Focused\";\n            newButton.hoveredFgSprite = spriteBaseName + \"Hovered\";\n            newButton.pressedFgSprite = spriteBaseName + \"Pressed\";\n            newButton.disabledFgSprite = spriteBaseName + \"Disabled\";\n        }\n\n        /// <summary>\n        /// Appends a tab button to a tabstrip.\n        /// </summary>\n        /// <param name=\"tabstrip\">Tabstrip to append to.</param>\n        /// <param name=\"template\">Button template.</param>\n        /// <param name=\"name\">Button name.</param>\n        /// <param name=\"tooltipKey\">Tooltop key.</param>\n        /// <returns>New UIButton.</returns>", "        private UIButton AddTabButton(UITabstrip tabstrip, UIButton template, string name, string tooltipKey)\n        {\n            // Basic setup.\n            UIButton newButton = tabstrip.AddTab(name, template, false);\n            newButton.name = name;\n            newButton.autoSize = false;\n            newButton.height = ButtonSize;\n            newButton.width = ButtonSize;\n            newButton.tooltip = Translations.Translate(tooltipKey);\n\n            return newButton;\n        }\n\n        /// <summary>\n        /// Control tab index changed event handler.\n        /// </summary>\n        /// <param name=\"c\">Calling component.</param>\n        /// <param name=\"index\">Selected index.</param>", "        private void TabIndexChanged(UIComponent c, int index)\n        {\n            // Set current tool and/or mode based on new index.\n            switch ((ModeIndexes)index)\n            {\n                case ModeIndexes.Single:\n                    ToolsModifierControl.toolController.CurrentTool = LineTool.Instance.BaseTool;\n                    StandalonePanelManager<ToolOptionsPanel>.Panel?.Close();\n                    _optionsPanelToggle.Hide();\n                    break;\n\n                case ModeIndexes.Line:\n                    ToolsModifierControl.toolController.CurrentTool = LineTool.Instance;\n                    LineTool.Instance.CurrentMode = new LineMode();\n                    OpenOptionsPanel();\n                    break;\n\n                case ModeIndexes.Curve:\n                    ToolsModifierControl.toolController.CurrentTool = LineTool.Instance;\n                    LineTool.Instance.CurrentMode = new CurveMode();\n                    OpenOptionsPanel();\n                    break;\n\n                case ModeIndexes.Freeform:\n                    ToolsModifierControl.toolController.CurrentTool = LineTool.Instance;\n                    LineTool.Instance.CurrentMode = new FreeformMode();\n                    OpenOptionsPanel();\n                    break;\n\n                case ModeIndexes.Circle:\n                    ToolsModifierControl.toolController.CurrentTool = LineTool.Instance;\n                    LineTool.Instance.CurrentMode = new CircleMode();\n                    OpenOptionsPanel();\n                    break;\n            }\n        }\n\n        /// <summary>\n        /// Opens the options panel.\n        /// </summary>", "        private void OpenOptionsPanel()\n        {\n            _optionsPanelToggle.Show();\n            _optionsPanelToggle.activeStateIndex = 1;\n            StandalonePanelManager<ToolOptionsPanel>.Create();\n        }\n\n        /// <summary>\n        /// Adds a multi-state toggle button to the specified UIComponent.\n        /// </summary>\n        /// <param name=\"parent\">Parent UIComponent.</param>\n        /// <param name=\"name\">Button name.</param>\n        /// <param name=\"atlas\">Button atlas.</param>\n        /// <param name=\"backgroundPrefix\">Background sprite common prefix (will be appended with \"Zero\" and \"One\" for the two states).</param>\n        /// <param name=\"foregroundPrefix\">Foreground sprite common prefix (will be appended with \"Zero\" and \"One\" for the two states).</param>\n        /// <returns>New UIMultiStateButton.</returns>", "        private UIMultiStateButton AddToggleButton(UIComponent parent, string name, UITextureAtlas atlas, string backgroundPrefix, string foregroundPrefix)\n        {\n            // Create button.\n            UIMultiStateButton newButton = parent.AddUIComponent<UIMultiStateButton>();\n            newButton.name = name;\n            newButton.atlas = atlas;\n\n            // Get sprite sets.\n            UIMultiStateButton.SpriteSetState fgSpriteSetState = newButton.foregroundSprites;\n            UIMultiStateButton.SpriteSetState bgSpriteSetState = newButton.backgroundSprites;\n\n            // Calculate set names.\n            string bgPrefixZero = backgroundPrefix + \"Zero\";\n            string fgPrefixZero = foregroundPrefix + \"Zero\";\n            string bgPrefixOne = backgroundPrefix + \"One\";\n            string fgPrefixOne = foregroundPrefix + \"One\";\n\n            // State 0 background.\n            UIMultiStateButton.SpriteSet bgSpriteSetZero = bgSpriteSetState[0];\n            bgSpriteSetZero.normal = bgPrefixZero;\n            bgSpriteSetZero.focused = bgPrefixZero + \"Focused\";\n            bgSpriteSetZero.hovered = bgPrefixZero + \"Hovered\";\n            bgSpriteSetZero.pressed = bgPrefixZero + \"Pressed\";\n            bgSpriteSetZero.disabled = bgPrefixZero + \"Disabled\";\n\n            // State 0 foreground.\n            UIMultiStateButton.SpriteSet fgSpriteSetZero = fgSpriteSetState[0];\n            fgSpriteSetZero.normal = fgPrefixZero;\n            fgSpriteSetZero.focused = fgPrefixZero + \"Focused\";\n            fgSpriteSetZero.hovered = fgPrefixZero + \"Hovered\";\n            fgSpriteSetZero.pressed = fgPrefixZero + \"Pressed\";\n            fgSpriteSetZero.disabled = fgPrefixZero + \"Disabled\";\n\n            // Add state 1.\n            fgSpriteSetState.AddState();\n            bgSpriteSetState.AddState();\n\n            // State 1 background.\n            UIMultiStateButton.SpriteSet bgSpriteSetOne = bgSpriteSetState[1];\n            bgSpriteSetOne.normal = bgPrefixOne;\n            bgSpriteSetOne.focused = bgPrefixOne + \"Focused\";\n            bgSpriteSetOne.hovered = bgPrefixOne + \"Hovered\";\n            bgSpriteSetOne.pressed = bgPrefixOne + \"Pressed\";\n            bgSpriteSetOne.disabled = bgPrefixOne + \"Disabled\";\n\n            // State 1 foreground.\n            UIMultiStateButton.SpriteSet fgSpriteSetOne = fgSpriteSetState[1];\n            fgSpriteSetOne.normal = fgPrefixOne;\n            fgSpriteSetOne.focused = fgPrefixOne + \"Focused\";\n            fgSpriteSetOne.hovered = fgPrefixOne + \"Hovered\";\n            fgSpriteSetOne.pressed = fgPrefixOne + \"Pressed\";\n            fgSpriteSetOne.disabled = fgPrefixOne + \"Disabled\";\n\n            // Set initial state.\n            newButton.state = UIMultiStateButton.ButtonState.Normal;\n            newButton.activeStateIndex = 0;\n\n            // Size and appearance.\n            newButton.autoSize = false;\n            newButton.width = ButtonSize;\n            newButton.height = ButtonSize;\n            newButton.foregroundSpriteMode = UIForegroundSpriteMode.Scale;\n            newButton.spritePadding = new RectOffset(0, 0, 0, 0);\n            newButton.playAudioEvents = true;\n\n            // Enforce defaults.\n            newButton.canFocus = false;\n            newButton.enabled = true;\n            newButton.isInteractive = true;\n            newButton.isVisible = true;\n\n            return newButton;\n        }\n    }\n}\n"]}
{"filename": "Code/UI/BOBSlider.cs", "chunked_list": ["\ufeff// <copyright file=\"BOBSlider.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod\n{\n    using ColossalFramework.UI;\n    using UnityEngine;\n", "    using UnityEngine;\n\n    /// <summary>\n    /// Slider with integrated components.\n    /// </summary>\n    public class BOBSlider : UISlider\n    {\n        // State flag (to avoid infinite recursive update loops).\n        private bool suppressEvents = false;\n\n        // True (not displayed) value.", "        private bool suppressEvents = false;\n\n        // True (not displayed) value.\n        private float trueValue;\n\n        // Linked slider value textfield.\n        private UITextField _valueTextField;\n\n        /// <summary>\n        /// Value changed event (includes true value, i.e. value changes beyond the visibile range that won't trigger the default slider OnValueChanged event).\n        /// </summary>", "        public event PropertyChangedEventHandler<float> EventTrueValueChanged;\n\n        /// <summary>\n        /// Gets or sets a value indicating whether this is an integer slider (true) or floating-point slider (false).\n        /// </summary>\n        public bool IsInt { get; set; } = false;\n\n        /// <summary>\n        /// Gets or sets a value indicating whether the slider range should be limited to the visisble slider range (default false).\n        /// </summary>\n        public bool LimitToVisible { get; set; } = false;\n\n        /// <summary>\n        /// Gets or sets the linked value display textfield instance.\n        /// </summary>", "        public bool LimitToVisible { get; set; } = false;\n\n        /// <summary>\n        /// Gets or sets the linked value display textfield instance.\n        /// </summary>\n        public UITextField ValueField\n        {\n            get => _valueTextField;\n\n            set\n            {\n                // Don't do anything if no change.", "                if (value != _valueTextField)\n                {\n                    // Remove any attached event handler before changing the linked field.\n                    if (_valueTextField != null)\n                    {\n                        _valueTextField.eventTextSubmitted -= OnTextSubmitted;\n                    }\n\n                    // Update value.\n                    _valueTextField = value;\n\n                    // Add event handler if there's an active new instance.", "                    if (_valueTextField != null)\n                    {\n                        _valueTextField.eventTextSubmitted += OnTextSubmitted;\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets the 'true' (not just displayed) slider value; use this instead of value to ensure proper operation.\n        /// </summary>", "        public float TrueValue\n        {\n            get => trueValue;\n\n            set\n            {\n                // Clamp value to visible slider range.\n                float visibleValue = Mathf.Clamp(value, minValue, maxValue);\n\n                // Set value according to 'limit to visible' setting\n                trueValue = LimitToVisible ? visibleValue : value;\n\n                // Set slider and textfield values (visble and true values accordingly), suppressing events if they aren't already suppressed.\n                bool oldSuppressEvents = suppressEvents;\n                suppressEvents = true;\n                this.value = visibleValue;\n                SetText();\n\n                // Trigger value changed events, if any.\n                EventTrueValueChanged?.Invoke(this, trueValue);\n\n                // Restore previous event state.\n                suppressEvents = oldSuppressEvents;\n            }\n        }\n\n        /// <summary>\n        /// Sets the minimum slider step size.  Setting to 1 will make this an integer slider.\n        /// </summary>", "        public float StepSize\n        {\n            set\n            {\n                if (value == 1)\n                {\n                    // Set as integer.\n                    IsInt = true;\n                    stepSize = value;\n                }\n                else\n                {\n                    // For non-integers, underlying step size is 1/10th of value, to ensure small changes aren't quantized out.\n                    stepSize = value / 10f;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets the current step multiplier based on modifier key states.\n        /// For float 0.1/0.01 for none/Ctrl, for Int just 1.\n        /// </summary>", "        private float Multiplier\n        {\n            get\n            {\n                // Integer or float?\n                if (!IsInt)\n                {\n                    if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))\n                    {\n                        // Control modifier.\n                        return 0.01f;\n                    }\n\n                    // Default float multiplier.\n                    return 0.1f;\n                }\n\n                // Default multiplier.\n                return 1;\n            }\n        }\n\n        /// <summary>\n        /// Called by game when slider value is changed.\n        /// </summary>", "        protected override void OnValueChanged()\n        {\n            // Don't do anything special if events are suppressed.\n            if (!suppressEvents)\n            {\n                // Apply current multiplier and update TrueValue.\n                TrueValue = value.RoundToNearest(Multiplier);\n            }\n\n            // Complete normal slider value change processing (update thumb position, invoke events, etc.).\n            base.OnValueChanged();\n        }\n\n        /// <summary>\n        /// Called by game when slider visibility is changed.\n        /// </summary>", "        protected override void OnVisibilityChanged()\n        {\n            // Ensure value field visibility matches this.\n            if (_valueTextField != null)\n            {\n                _valueTextField.isVisible = isVisible;\n            }\n        }\n\n        /// <summary>\n        /// Called by game when mousewheel is scrolled.\n        /// </summary>\n        /// <param name=\"p\">Mouse event parameter.</param>", "        protected override void OnMouseWheel(UIMouseEventParameter p)\n        {\n            // Get current multiplier.\n            float multiplier = Multiplier;\n\n            // Set current value according to multiplier state.\n            TrueValue = trueValue.RoundToNearest(multiplier) + (p.wheelDelta * multiplier);\n\n            // Use event and invoke any handlers.\n            p.Use();\n            Invoke(\"OnMouseWheel\", p);\n        }\n\n        /// <summary>\n        /// Updates the displayed textfield values.\n        /// </summary>", "        private void SetText()\n        {\n            if (_valueTextField != null)\n            {\n                _valueTextField.text = TrueValue.RoundToNearest(Multiplier).ToString();\n            }\n        }\n\n        /// <summary>\n        /// Linked textfield value change event handler.\n        /// </summary>\n        /// <param name=\"c\">Calling component.</param>\n        /// <param name=\"text\">New text.</param>", "        private void OnTextSubmitted(UIComponent c, string text)\n        {\n            // Don't do anything is events are suppressed.\n            if (!suppressEvents)\n            {\n                // Suppress events while we change things, to avoid infinite recursive update loops.\n                suppressEvents = true;\n\n                // Attempt to parse textfield value.\n                if (float.TryParse(text, out float result))\n                {\n                    // Successful parse - set slider value.\n                    TrueValue = result.RoundToNearest(Multiplier);\n                }\n\n                // Restore event handling.\n                suppressEvents = false;\n            }\n        }\n    }\n}", "                if (float.TryParse(text, out float result))\n                {\n                    // Successful parse - set slider value.\n                    TrueValue = result.RoundToNearest(Multiplier);\n                }\n\n                // Restore event handling.\n                suppressEvents = false;\n            }\n        }\n    }\n}"]}
{"filename": "Code/UI/ToolOptionsPanel.cs", "chunked_list": ["\ufeff// <copyright file=\"ToolOptionsPanel.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod\n{\n    using AlgernonCommons.Translation;\n    using AlgernonCommons.UI;\n    using ColossalFramework.UI;", "    using AlgernonCommons.UI;\n    using ColossalFramework.UI;\n    using UnityEngine;\n\n    /// <summary>\n    /// Control panel for the line tool.\n    /// TODO: quick-and-dirty hack only for development, not production design.\n    /// </summary>\n    internal class ToolOptionsPanel : StandalonePanel\n    {\n        // Panel components.", "    internal class ToolOptionsPanel : StandalonePanel\n    {\n        // Panel components.\n        private BOBSlider _spacingSlider;\n        private UIButton _stepButton;\n        private UIButton _skipButton;\n        private UIMultiStateButton _relativeAngleButton;\n        private UIMultiStateButton _absoluteAngleButton;\n\n        /// <summary>\n        /// Gets the panel width.\n        /// </summary>", "        public override float PanelWidth => 36f * 7f;\n\n        /// <summary>\n        /// Gets the panel height.\n        /// </summary>\n        public override float PanelHeight => 250f;\n\n        /// <summary>\n        /// Gets the panel's default position.\n        /// </summary>\n        public override Vector3 DefaultPosition\n        {\n            get\n            {\n                UIComponent optionsBar = GameObject.Find(\"OptionsBar\").GetComponent<UIComponent>();\n                return optionsBar.absolutePosition - new Vector3(0f, PanelHeight + Margin);\n            }\n        }\n\n        /// <summary>\n        /// Gets the panel's title.\n        /// </summary>", "        public override Vector3 DefaultPosition\n        {\n            get\n            {\n                UIComponent optionsBar = GameObject.Find(\"OptionsBar\").GetComponent<UIComponent>();\n                return optionsBar.absolutePosition - new Vector3(0f, PanelHeight + Margin);\n            }\n        }\n\n        /// <summary>\n        /// Gets the panel's title.\n        /// </summary>", "        protected override string PanelTitle => Translations.Translate(\"MOD_NAME\");\n\n        /// <summary>\n        /// Called by Unity before the first frame.\n        /// Used to perform setup.\n        /// </summary>\n        public override void Start()\n        {\n            base.Start();\n\n            const float DoubleMargin = Margin * 2f;\n            const float ToggleSize = 45f;\n\n            float currentY = 50f;\n\n            // Spacing slider.\n            _spacingSlider = AddBOBSlider(this, DoubleMargin, currentY, PanelWidth - DoubleMargin - DoubleMargin, \"SPACING\", 1f, 100f, 0.1f, \"Spacing\");\n            _spacingSlider.value = LineTool.Instance.Spacing;\n            _spacingSlider.eventValueChanged += (c, value) => LineTool.Instance.Spacing = value;\n            currentY += 40f;\n\n            // Rotation slider.\n            BOBSlider rotationSlider = AddBOBSlider(this, DoubleMargin, currentY, PanelWidth - DoubleMargin - DoubleMargin, \"ROTATION\", 0f, 360f, 0.1f, \"Rotation\");\n            rotationSlider.value = LineTool.Instance.Rotation * Mathf.Rad2Deg;\n            rotationSlider.eventValueChanged += (c, value) => LineTool.Instance.Rotation = value * Mathf.Deg2Rad;\n            currentY += 40f;\n\n            // Angle mode buttons.\n            UITextureAtlas toggleAtlas = UITextures.CreateSpriteAtlas(\"LineToolToggles\", 1024, \"LineOptions\");\n            _relativeAngleButton = AddToggleButton(this, \"AngleRelative\", toggleAtlas, ToggleSize);\n            _relativeAngleButton.relativePosition = new Vector2(Margin, currentY);\n            _relativeAngleButton.tooltip = Translations.Translate(\"ROTATION_RELATIVE\");\n            _absoluteAngleButton = AddToggleButton(this, \"AngleAbsolute\", toggleAtlas, ToggleSize);\n            _absoluteAngleButton.relativePosition = new Vector2(ToggleSize + DoubleMargin, currentY);\n            _absoluteAngleButton.tooltip = Translations.Translate(\"ROTATION_ABSOLUTE\");\n\n            // Set to length button.\n            UIButton lengthButton = AddIconButton(this, \"Length\", toggleAtlas, ToggleSize);\n            lengthButton.relativePosition = new Vector2((ToggleSize + DoubleMargin) * 2f, currentY);\n            lengthButton.eventClicked += (c, p) => LineTool.Instance?.SetToLength();\n            lengthButton.tooltip = Translations.Translate(\"SET_LENGTH\");\n\n            // Set to width button.\n            UIButton widthButton = AddIconButton(this, \"Width\", toggleAtlas, ToggleSize);\n            widthButton.relativePosition = new Vector2((ToggleSize + DoubleMargin) * 3f, currentY);\n            widthButton.eventClicked += (c, p) => LineTool.Instance?.SetToWidth();\n            widthButton.tooltip = Translations.Translate(\"SET_WIDTH\");\n\n            currentY += ToggleSize + Margin + Margin;\n\n            // Spacer panel.\n            UISpacers.AddOptionsSpacer(this, Margin, currentY, PanelWidth - DoubleMargin);\n            currentY += 10f;\n\n            // Step check.\n            UICheckBox stepCheck = UICheckBoxes.AddLabelledCheckBox(this, Margin, currentY, Translations.Translate(\"STEP_ENABLED\"));\n            stepCheck.isChecked = LineTool.Instance.StepMode;\n            stepCheck.eventCheckChanged += (c, isChecked) => LineTool.Instance.StepMode = isChecked;\n            currentY += 25f;\n\n            // Step button.\n            float buttonWidth = (PanelWidth / 2f) - (Margin * 2f);\n            _stepButton = UIButtons.AddEvenSmallerButton(this, Margin, currentY, Translations.Translate(\"STEP\"), buttonWidth);\n            _stepButton.eventClicked += (c, p) =>\n            {\n                LineTool.Instance.Step();\n            };\n\n            // Skip button.\n            _skipButton = UIButtons.AddEvenSmallerButton(this, (Margin * 3f) + buttonWidth, currentY, Translations.Translate(\"SKIP\"), buttonWidth);\n            _skipButton.eventClicked += (c, p) =>\n            {\n                LineTool.Instance.Skip();\n            };\n\n            // Set initial angle toggle mode.", "            if (LineTool.Instance.RelativeRotation)\n            {\n                _relativeAngleButton.activeStateIndex = 1;\n            }\n            else\n            {\n                _absoluteAngleButton.activeStateIndex = 1;\n            }\n\n            // Absolute angle toggle event handler.\n            _absoluteAngleButton.eventActiveStateIndexChanged += (c, state) =>\n            {", "                if (state == 1)\n                {\n                    // Deselect relative angle toggle if this is selected.\n                    _relativeAngleButton.activeStateIndex = 0;\n                    LineTool.Instance.RelativeRotation = false;\n                }\n                else if (_relativeAngleButton.activeStateIndex == 0)\n                {\n                    // If relative angle button is not selected, force this one active.\n                    _absoluteAngleButton.activeStateIndex = 1;\n                }\n            };\n\n            // Relative angle toggle event handler.\n            _relativeAngleButton.eventActiveStateIndexChanged += (c, state) =>\n            {", "                if (state == 1)\n                {\n                    // Deselect absolute angle toggle if this is selected.\n                    _absoluteAngleButton.activeStateIndex = 0;\n                    LineTool.Instance.RelativeRotation = true;\n                }\n                else if (_absoluteAngleButton.activeStateIndex == 0)\n                {\n                    // If absolute angle button is not selected, force this one active.\n                    _relativeAngleButton.activeStateIndex = 1;\n                }\n            };\n\n            // Set initial state.\n            UpdateButtonStates();\n        }\n\n        /// <summary>\n        /// Applies the panel's default position.\n        /// </summary>", "        public override void ApplyDefaultPosition()\n        {\n            absolutePosition = DefaultPosition;\n        }\n\n        /// <summary>\n        /// Refreshes the spacing slider's value.\n        /// </summary>\n        internal void RefreshSpacing() => _spacingSlider.TrueValue = LineTool.Instance.Spacing;\n\n        /// <summary>\n        /// Updates button states to reflect the current tool state.\n        /// </summary>\n        internal void UpdateButtonStates()\n        {\n            // Set according to current stepping state.", "            if (LineTool.Instance != null && LineTool.Instance.Stepping)\n            {\n                _spacingSlider.Hide();\n                _skipButton.Enable();\n                _stepButton.Enable();\n            }\n            else\n            {\n                _spacingSlider.Show();\n                _skipButton.Disable();\n                _stepButton.Disable();\n            }\n        }\n\n        /// <summary>\n        /// Performs any actions required before closing the panel and checks that it's safe to do so.\n        /// </summary>\n        /// <returns>Always true (panel can always close).</returns>", "        protected override bool PreClose()\n        {\n            // Save panel position if it's not at the default.\n            if (absolutePosition != DefaultPosition)\n            {\n                ModSettings.Save();\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Adds a BOB slider to the specified component.\n        /// </summary>\n        /// <param name=\"parent\">Parent component.</param>\n        /// <param name=\"xPos\">Relative X position.</param>\n        /// <param name=\"yPos\">Relative Y position.</param>\n        /// <param name=\"width\">Slider width.</param>\n        /// <param name=\"labelKey\">Text label translation key.</param>\n        /// <param name=\"minValue\">Minimum displayed value.</param>\n        /// <param name=\"maxValue\">Maximum displayed value.</param>\n        /// <param name=\"stepSize\">Minimum slider step size.</param>\n        /// <param name=\"name\">Slider name.</param>\n        /// <returns>New BOBSlider.</returns>", "        private BOBSlider AddBOBSlider(UIComponent parent, float xPos, float yPos, float width, string labelKey, float minValue, float maxValue, float stepSize, string name)\n        {\n            const float SliderY = 18f;\n            const float ValueY = 3f;\n            const float LabelY = -13f;\n            const float SliderHeight = 18f;\n            const float FloatTextFieldWidth = 45f;\n            const float IntTextFieldWidth = 38f;\n\n            // Slider control.\n            BOBSlider newSlider = parent.AddUIComponent<BOBSlider>();\n            newSlider.size = new Vector2(width, SliderHeight);\n            newSlider.relativePosition = new Vector2(xPos, yPos + SliderY);\n            newSlider.name = name;\n\n            // Value field - added to parent, not to slider, otherwise slider catches all input attempts.  Integer textfields (stepsize == 1) have shorter widths.\n            float textFieldWidth = stepSize == 1 ? IntTextFieldWidth : FloatTextFieldWidth;\n            UITextField valueField = UITextFields.AddTinyTextField(parent, xPos + Margin + newSlider.width - textFieldWidth, yPos + ValueY, textFieldWidth);\n\n            // Title label.\n            UILabel titleLabel = UILabels.AddLabel(newSlider, 0f, LabelY, Translations.Translate(labelKey), textScale: 0.7f);\n\n            // Autoscale tile label text, with minimum size 0.35.", "            while (titleLabel.width > newSlider.width - textFieldWidth && titleLabel.textScale > 0.35f)\n            {\n                titleLabel.textScale -= 0.05f;\n            }\n\n            // Slider track.\n            UISlicedSprite sliderSprite = newSlider.AddUIComponent<UISlicedSprite>();\n            sliderSprite.atlas = UITextures.InGameAtlas;\n            sliderSprite.spriteName = \"BudgetSlider\";\n            sliderSprite.size = new Vector2(newSlider.width, 9f);\n            sliderSprite.relativePosition = new Vector2(0f, 4f);\n\n            // Slider thumb.\n            UISlicedSprite sliderThumb = newSlider.AddUIComponent<UISlicedSprite>();\n            sliderThumb.atlas = UITextures.InGameAtlas;\n            sliderThumb.spriteName = \"SliderBudget\";\n            newSlider.thumbObject = sliderThumb;\n\n            // Set references.\n            newSlider.ValueField = valueField;\n\n            // Set initial values.\n            newSlider.StepSize = stepSize;\n            newSlider.maxValue = maxValue;\n            newSlider.minValue = minValue;\n            newSlider.TrueValue = 0f;\n\n            // Ensure value textfield is in front.\n            valueField.BringToFront();\n\n            return newSlider;\n        }\n\n        /// <summary>\n        /// Adds a multi-state toggle button to the specified UIComponent.\n        /// </summary>\n        /// <param name=\"parent\">Parent UIComponent.</param>\n        /// <param name=\"spriteName\">Sprite name.</param>\n        /// <param name=\"atlas\">Button atlas.</param>\n        /// <param name=\"size\">Button size.</param>\n        /// <returns>New UIMultiStateButton.</returns>", "        private UIMultiStateButton AddToggleButton(UIComponent parent, string spriteName, UITextureAtlas atlas, float size)\n        {\n            // Create button.\n            UIMultiStateButton newButton = parent.AddUIComponent<UIMultiStateButton>();\n            newButton.name = spriteName;\n            newButton.atlas = atlas;\n\n            // Get sprite sets.\n            UIMultiStateButton.SpriteSetState fgSpriteSetState = newButton.foregroundSprites;\n            UIMultiStateButton.SpriteSetState bgSpriteSetState = newButton.backgroundSprites;\n\n            // State 0 background.\n            UIMultiStateButton.SpriteSet bgSpriteSetZero = bgSpriteSetState[0];\n            bgSpriteSetZero.normal = spriteName;\n            bgSpriteSetZero.focused = spriteName + \"Pressed\";\n            bgSpriteSetZero.hovered = spriteName + \"Hovered\";\n            bgSpriteSetZero.pressed = spriteName + \"Pressed\";\n            bgSpriteSetZero.disabled = spriteName;\n\n            // Add state 1.\n            fgSpriteSetState.AddState();\n            bgSpriteSetState.AddState();\n\n            // State 1 background.\n            UIMultiStateButton.SpriteSet bgSpriteSetOne = bgSpriteSetState[1];\n            bgSpriteSetOne.normal = spriteName + \"Pressed\";\n            bgSpriteSetOne.focused = spriteName + \"Pressed\";\n            bgSpriteSetOne.hovered = spriteName + \"Pressed\";\n            bgSpriteSetOne.pressed = spriteName + \"Pressed\";\n            bgSpriteSetOne.disabled = spriteName + \"Pressed\";\n\n            // Set initial state.\n            newButton.state = UIMultiStateButton.ButtonState.Normal;\n            newButton.activeStateIndex = 0;\n\n            // Size and appearance.\n            newButton.autoSize = false;\n            newButton.width = size;\n            newButton.height = size;\n            newButton.foregroundSpriteMode = UIForegroundSpriteMode.Fill;\n            newButton.spritePadding = new RectOffset(0, 0, 0, 0);\n            newButton.playAudioEvents = true;\n\n            // Enforce defaults.\n            newButton.canFocus = false;\n            newButton.enabled = true;\n            newButton.isInteractive = true;\n            newButton.isVisible = true;\n\n            return newButton;\n        }\n\n        /// <summary>\n        /// Adds an icon button to the specified component.\n        /// </summary>\n        /// <param name=\"parent\">Parent UIComponent.</param>\n        /// <param name=\"spriteName\">Sprite name.</param>\n        /// <param name=\"atlas\">Button atlas.</param>\n        /// <param name=\"size\">Button size.</param>\n        /// <returns>New UIButton.</returns>", "        private UIButton AddIconButton(UIComponent parent, string spriteName, UITextureAtlas atlas, float size)\n        {\n            UIButton newButton = parent.AddUIComponent<UIButton>();\n\n            // Size and position.\n            newButton.height = size;\n            newButton.width = size;\n\n            // Appearance.\n            newButton.atlas = atlas;\n            newButton.normalFgSprite = spriteName;\n            newButton.focusedFgSprite = spriteName;\n            newButton.hoveredFgSprite = spriteName + \"Hovered\";\n            newButton.disabledFgSprite = spriteName;\n            newButton.pressedFgSprite = spriteName + \"Pressed\";\n            newButton.playAudioEvents = true;\n\n            return newButton;\n        }\n    }\n}\n"]}
{"filename": "Code/Settings/ModSettings.cs", "chunked_list": ["\ufeff// <copyright file=\"ModSettings.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod\n{\n    using System.IO;\n    using System.Xml.Serialization;\n    using AlgernonCommons.UI;", "    using System.Xml.Serialization;\n    using AlgernonCommons.UI;\n    using AlgernonCommons.XML;\n\n    /// <summary>\n    /// Global mod settings.\n    /// </summary>\n    [XmlRoot(\"LineTool\")]\n    public class ModSettings : SettingsXMLBase\n    {\n        /// <summary>\n        /// Settings file name.\n        /// </summary>\n        [XmlIgnore]", "    public class ModSettings : SettingsXMLBase\n    {\n        /// <summary>\n        /// Settings file name.\n        /// </summary>\n        [XmlIgnore]\n        private static readonly string SettingsFileName = Path.Combine(ColossalFramework.IO.DataLocation.localApplicationData, \"LineTool.xml\");\n\n        /// <summary>\n        /// Gets or sets the tool options panel's last saved X position.\n        /// </summary>", "        public float PanelXPosition { get => StandalonePanelManager<ToolOptionsPanel>.LastSavedXPosition; set => StandalonePanelManager<ToolOptionsPanel>.LastSavedXPosition = value; }\n\n        /// <summary>\n        /// Gets or sets the tool options panel's last saved Y position.\n        /// </summary>\n        public float PanelYPosition { get => StandalonePanelManager<ToolOptionsPanel>.LastSavedYPosition; set => StandalonePanelManager<ToolOptionsPanel>.LastSavedYPosition = value; }\n\n        /// <summary>\n        /// Loads settings from file.\n        /// </summary>\n        internal static void Load() => XMLFileUtils.Load<ModSettings>(SettingsFileName);\n\n        /// <summary>\n        /// Saves settings to file.\n        /// </summary>\n        internal static void Save() => XMLFileUtils.Save<ModSettings>(SettingsFileName);\n    }\n}"]}
{"filename": "Code/Settings/OptionsPanel.cs", "chunked_list": ["\ufeff// <copyright file=\"OptionsPanel.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod\n{\n    using AlgernonCommons;\n    using AlgernonCommons.Translation;\n    using AlgernonCommons.UI;", "    using AlgernonCommons.Translation;\n    using AlgernonCommons.UI;\n    using ColossalFramework.UI;\n    using UnityEngine;\n\n    /// <summary>\n    /// The mod's settings options panel.\n    /// </summary>\n    public class OptionsPanel : OptionsPanelBase\n    {\n        // Layout constants.", "    public class OptionsPanel : OptionsPanelBase\n    {\n        // Layout constants.\n        private const float Margin = 5f;\n        private const float LeftMargin = 24f;\n\n        /// <summary>\n        /// Performs on-demand panel setup.\n        /// </summary>\n        protected override void Setup()\n        {\n            // Add controls.\n            // Y position indicator.\n            float currentY = Margin;\n\n            // Language choice.\n            UIDropDown languageDropDown = UIDropDowns.AddPlainDropDown(this, LeftMargin, currentY, Translations.Translate(\"LANGUAGE_CHOICE\"), Translations.LanguageList, Translations.Index);\n            languageDropDown.eventSelectedIndexChanged += (control, index) =>\n            {\n                Translations.Index = index;\n                OptionsPanelManager<OptionsPanel>.LocaleChanged();\n            };\n            languageDropDown.parent.relativePosition = new Vector2(LeftMargin, currentY);\n            currentY += languageDropDown.parent.height + Margin;\n\n            // Logging checkbox.\n            UICheckBox loggingCheck = UICheckBoxes.AddPlainCheckBox(this, LeftMargin, currentY, Translations.Translate(\"DETAIL_LOGGING\"));\n            loggingCheck.isChecked = Logging.DetailLogging;\n            loggingCheck.eventCheckChanged += (c, isChecked) => { Logging.DetailLogging = isChecked; };\n            currentY += loggingCheck.height + Margin;\n\n            UIButton resetPositionButton = UIButtons.AddButton(this, LeftMargin, currentY, Translations.Translate(\"RESET_POSITION\"), 300f);\n            resetPositionButton.eventClicked += (c, p) => StandalonePanelManager<ToolOptionsPanel>.ResetPosition();\n        }\n    }\n}", "        protected override void Setup()\n        {\n            // Add controls.\n            // Y position indicator.\n            float currentY = Margin;\n\n            // Language choice.\n            UIDropDown languageDropDown = UIDropDowns.AddPlainDropDown(this, LeftMargin, currentY, Translations.Translate(\"LANGUAGE_CHOICE\"), Translations.LanguageList, Translations.Index);\n            languageDropDown.eventSelectedIndexChanged += (control, index) =>\n            {\n                Translations.Index = index;\n                OptionsPanelManager<OptionsPanel>.LocaleChanged();\n            };\n            languageDropDown.parent.relativePosition = new Vector2(LeftMargin, currentY);\n            currentY += languageDropDown.parent.height + Margin;\n\n            // Logging checkbox.\n            UICheckBox loggingCheck = UICheckBoxes.AddPlainCheckBox(this, LeftMargin, currentY, Translations.Translate(\"DETAIL_LOGGING\"));\n            loggingCheck.isChecked = Logging.DetailLogging;\n            loggingCheck.eventCheckChanged += (c, isChecked) => { Logging.DetailLogging = isChecked; };\n            currentY += loggingCheck.height + Margin;\n\n            UIButton resetPositionButton = UIButtons.AddButton(this, LeftMargin, currentY, Translations.Translate(\"RESET_POSITION\"), 300f);\n            resetPositionButton.eventClicked += (c, p) => StandalonePanelManager<ToolOptionsPanel>.ResetPosition();\n        }\n    }\n}"]}
{"filename": "Code/Patches/PanelPatches.cs", "chunked_list": ["\ufeff// <copyright file=\"PanelPatches.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Reflection;", "    using System.Collections.Generic;\n    using System.Reflection;\n    using AlgernonCommons;\n    using HarmonyLib;\n\n    /// <summary>\n    /// Harmony patches for prefab selection panels to implement seamless prefab selection when line tool is active.\n    /// </summary>\n    [HarmonyPatch]\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\"StyleCop.CSharp.NamingRules\", \"SA1313:Parameter names should begin with lower-case letter\", Justification = \"Harmony\")]\n    internal static class PanelPatches\n    {\n        /// <summary>\n        /// Determines list of target methods to patch.\n        /// </summary>\n        /// <returns>List of target methods to patch.</returns>\n        internal static IEnumerable<MethodBase> TargetMethods()\n        {\n            // Vanilla game panels.\n            yield return AccessTools.Method(typeof(BeautificationPanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(LandscapingPanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(MonumentsPanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(WondersPanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(EducationPanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(HealthcarePanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(FireDepartmentPanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(ElectricityPanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(WaterAndSewagePanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(GarbagePanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(PublicTransportPanel), \"OnButtonClicked\");\n\n            // Natural resources brush (detours BeautificationGroupPanel).\n            Type nrbType = Type.GetType(\"NaturalResourcesBrush.Detours.BeautificationPanelDetour,NaturalResourcesBrush\");", "    [HarmonyPatch]\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\"StyleCop.CSharp.NamingRules\", \"SA1313:Parameter names should begin with lower-case letter\", Justification = \"Harmony\")]\n    internal static class PanelPatches\n    {\n        /// <summary>\n        /// Determines list of target methods to patch.\n        /// </summary>\n        /// <returns>List of target methods to patch.</returns>\n        internal static IEnumerable<MethodBase> TargetMethods()\n        {\n            // Vanilla game panels.\n            yield return AccessTools.Method(typeof(BeautificationPanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(LandscapingPanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(MonumentsPanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(WondersPanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(EducationPanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(HealthcarePanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(FireDepartmentPanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(ElectricityPanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(WaterAndSewagePanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(GarbagePanel), \"OnButtonClicked\");\n            yield return AccessTools.Method(typeof(PublicTransportPanel), \"OnButtonClicked\");\n\n            // Natural resources brush (detours BeautificationGroupPanel).\n            Type nrbType = Type.GetType(\"NaturalResourcesBrush.Detours.BeautificationPanelDetour,NaturalResourcesBrush\");", "            if (nrbType != null)\n            {\n                Logging.Message(\"Extra Landscaping Tools found; patching\");\n                yield return AccessTools.Method(nrbType, \"OnButtonClicked\");\n            }\n        }\n\n        /// <summary>\n        /// Harmony prefix patch to record if the LineTool is active before the base method is executed.\n        /// </summary>\n        /// <param name=\"__state\">Passthrough to postifx; set to true if the LineTool is active when the target method is called.</param>\n        internal static void Prefix(out bool __state)\n        {\n            __state = LineTool.IsActiveTool;\n        }\n\n        /// <summary>\n        /// Harmony postifx patch to check to see if LineTool should be restored after the base method is executed.\n        /// </summary>\n        /// <param name=\"__state\">Passthrough from prefix; set to true if the LineTool is active when the target method is called.</param>\n        internal static void Postfix(bool __state)\n        {", "            if (__state)\n            {\n                // LineTool was active; check current tool.\n                ToolBase newTool = ToolsModifierControl.toolController.CurrentTool;\n\n                // Only restore LineTool if a supported base tool type was selected.\n                if (newTool is PropTool || newTool is TreeTool || newTool is BuildingTool)\n                {\n                    ToolsModifierControl.toolController.CurrentTool = LineTool.Instance;\n                }\n            }\n        }\n    }\n}\n"]}
{"filename": "Code/Patches/BuildingToolPatches.cs", "chunked_list": ["\ufeff// <copyright file=\"BuildingToolPatches.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod\n{\n    using AlgernonCommons.UI;\n    using HarmonyLib;\n", "    using HarmonyLib;\n\n    /// <summary>\n    /// Harmony patches for BuildingTool to toggle line tool UI depending upon selected prefab.\n    /// </summary>\n    [HarmonyPatch(typeof(BuildingTool))]\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\"StyleCop.CSharp.NamingRules\", \"SA1313:Parameter names should begin with lower-case letter\", Justification = \"Harmony\")]\n    internal static class BuildingToolPatches\n    {\n        /// <summary>\n        /// Harmony prefix patch to BuildingTool.OnToolUpdate to hide the line tool UI if an intersection building is selected.\n        /// </summary>\n        /// <param name=\"__instance\">BuildingTool instance.</param>\n        [HarmonyPatch(\"OnToolUpdate\")]\n        [HarmonyPrefix]\n        internal static void OnToolUpdatePrefix(BuildingTool __instance)\n        {\n            // Toogle line tool UI visibility - hide if an intersection (or null) is selected, otherwise show.", "            if (!__instance.m_prefab || __instance.m_prefab.m_buildingAI is IntersectionAI)\n            {\n                StandalonePanelManager<ToolModePanel>.Panel?.Hide();\n            }\n            else\n            {\n                StandalonePanelManager<ToolModePanel>.Create();\n            }\n        }\n    }\n}\n"]}
{"filename": "Code/Patches/ToolControllerPatches.cs", "chunked_list": ["\ufeff// <copyright file=\"ToolControllerPatches.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod\n{\n    using AlgernonCommons.UI;\n    using HarmonyLib;\n", "    using HarmonyLib;\n\n    /// <summary>\n    /// Harmony patches for the tool controller to track tool changes.\n    /// </summary>\n    [HarmonyPatch(typeof(ToolController))]\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\"StyleCop.CSharp.NamingRules\", \"SA1313:Parameter names should begin with lower-case letter\", Justification = \"Harmony\")]\n    internal static class ToolControllerPatches\n    {\n        /// <summary>\n        /// Harmony prefix patch to ToolController.SetTool to record selected prefab from previous tool when switching to LineTool.\n        /// </summary>\n        /// <param name=\"__instance\">ToolController instance (from original instance call).</param>\n        /// <param name=\"tool\">Tool being assinged.</param>\n        [HarmonyPatch(\"SetTool\")]\n        [HarmonyPrefix]\n        internal static void SetToolPrefix(ToolController __instance, ToolBase tool)\n        {\n            // Look for activation of linetool.", "            if (tool is LineTool lineTool)\n            {\n                ToolBase currentTool = __instance.CurrentTool;\n\n                if (currentTool is BuildingTool buildingTool)\n                {\n                    lineTool.SelectedPrefab = buildingTool.m_prefab;\n                }\n                else if (currentTool is PropTool propTool)\n                {\n                    lineTool.SelectedPrefab = propTool.m_prefab;\n                }", "                else if (currentTool is PropTool propTool)\n                {\n                    lineTool.SelectedPrefab = propTool.m_prefab;\n                }\n                else if (currentTool is TreeTool treeTool)\n                {\n                    lineTool.SelectedPrefab = treeTool.m_prefab;\n                }\n                else\n                {\n                    lineTool.SelectedPrefab = null;\n                }\n            }\n            else\n            {\n                // Line tool isn't activated; is the new tool one of the other supported tools?", "                if (tool is PropTool propTool)\n                {\n                    LineTool.Instance.BaseTool = propTool;\n                    StandalonePanelManager<ToolModePanel>.Create();\n                }\n                else if (tool is TreeTool treeTool)\n                {\n                    LineTool.Instance.BaseTool = treeTool;\n                    StandalonePanelManager<ToolModePanel>.Create();\n                }\n                else if (tool is BuildingTool buildingTool)\n                {\n                    LineTool.Instance.BaseTool = buildingTool;\n                    StandalonePanelManager<ToolModePanel>.Create();\n                }\n                else\n                {\n                    StandalonePanelManager<ToolModePanel>.Panel?.Close();\n                }\n            }\n        }\n    }\n}\n", "                else if (tool is BuildingTool buildingTool)\n                {\n                    LineTool.Instance.BaseTool = buildingTool;\n                    StandalonePanelManager<ToolModePanel>.Create();\n                }\n                else\n                {\n                    StandalonePanelManager<ToolModePanel>.Panel?.Close();\n                }\n            }\n        }\n    }\n}\n"]}
{"filename": "Code/Patches/Patcher.cs", "chunked_list": ["\ufeff// <copyright file=\"Patcher.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod\n{\n    using System;\n    using System.Reflection;\n    using AlgernonCommons;", "    using System.Reflection;\n    using AlgernonCommons;\n    using AlgernonCommons.Patching;\n    using HarmonyLib;\n\n    /// <summary>\n    /// Class to manage the mod's Harmony patches.\n    /// </summary>\n    public sealed class Patcher : PatcherBase\n    {\n        /// <summary>\n        /// Applies patches to Find It for prefab selection management.\n        /// </summary>\n        internal void PatchFindIt()\n        {\n            try\n            {\n                // Check for enabled Find It assembly (don't try to patch disabled assembly, because that just breaks).", "    public sealed class Patcher : PatcherBase\n    {\n        /// <summary>\n        /// Applies patches to Find It for prefab selection management.\n        /// </summary>\n        internal void PatchFindIt()\n        {\n            try\n            {\n                // Check for enabled Find It assembly (don't try to patch disabled assembly, because that just breaks).\n                if (AssemblyUtils.GetEnabledAssembly(\"FindIt\") is Assembly findItAsm)\n                {\n                    Type findItType = findItAsm.GetType(\"FindIt.FindIt\");", "                if (AssemblyUtils.GetEnabledAssembly(\"FindIt\") is Assembly findItAsm)\n                {\n                    Type findItType = findItAsm.GetType(\"FindIt.FindIt\");\n                    if (findItType != null)\n                    {\n                        Logging.Message(\"Find It found; patching\");\n                        Harmony harmonyInstance = new Harmony(HarmonyID);\n                        MethodInfo targetMethod = AccessTools.Method(findItType, \"SelectPrefab\");\n                        MethodInfo prefix = AccessTools.Method(typeof(PanelPatches), nameof(PanelPatches.Prefix));\n                        MethodInfo postfix = AccessTools.Method(typeof(PanelPatches), nameof(PanelPatches.Postfix));\n\n                        harmonyInstance.Patch(targetMethod, prefix: new HarmonyMethod(prefix), postfix: new HarmonyMethod(postfix));\n                    }\n                }\n            }", "            catch (Exception e)\n            {\n                Logging.LogException(e, \"exception patching Find It\");\n            }\n        }\n    }\n}"]}
{"filename": "Code/Tool/ToolMode.cs", "chunked_list": ["\ufeff// <copyright file=\"ToolMode.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod.Modes\n{\n    using System.Collections.Generic;\n    using UnityEngine;\n    using static LineTool;", "    using UnityEngine;\n    using static LineTool;\n\n    /// <summary>\n    /// Tool placement mode.\n    /// </summary>\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\"StyleCop.CSharp.MaintainabilityRules\", \"SA1401:Fields should be private\", Justification = \"Protected fields\")]\n    public abstract class ToolMode\n    {\n        /// <summary>\n        /// Overlay dashed line dash length.\n        /// </summary>", "        protected const float DashLength = 8f;\n\n        /// <summary>\n        /// Indicates whether a valid starting position has been recorded.\n        /// </summary>\n        protected bool m_validStart = false;\n\n        /// <summary>\n        /// Records the current selection start position.\n        /// </summary>\n        protected Vector3 m_startPos;\n\n        /// <summary>\n        /// Clears the current selection.\n        /// </summary>", "        protected Vector3 m_startPos;\n\n        /// <summary>\n        /// Clears the current selection.\n        /// </summary>\n        public virtual void Reset()\n        {\n            m_validStart = false;\n        }\n\n        /// <summary>\n        /// Handles a mouse click.\n        /// </summary>\n        /// <param name=\"location\">Click world location.</param>\n        /// <returns>True if items are to be placed as a result of this click, false otherwise.</returns>", "        public virtual bool HandleClick(Vector3 location)\n        {\n            // If no valid start position is set, record it.\n            if (!m_validStart)\n            {\n                m_validStart = true;\n                m_startPos = location;\n\n                // No placement at this stage (only the first click has been made).\n                return false;\n            }\n\n            // Second click; we're placing items.\n            return true;\n        }\n\n        /// <summary>\n        /// Performs actions after items are placed on the current line, setting up for the next line to be set.\n        /// </summary>\n        /// <param name=\"location\">Click world location.</param>", "        public virtual void ItemsPlaced(Vector3 location)\n        {\n            // Update new starting location to the previous end point.\n            m_startPos = location;\n        }\n\n        /// <summary>\n        /// Renders the overlay for this tool mode, using the calculated point list.\n        /// </summary>\n        /// <param name=\"cameraInfo\">Current camera instance.</param>\n        /// <param name=\"toolManager\">ToolManager instance.</param>\n        /// <param name=\"overlay\">Overlay effect instance.</param>\n        /// <param name=\"pointList\">Current mouse position.</param>", "        public virtual void RenderOverlay(RenderManager.CameraInfo cameraInfo, ToolManager toolManager, OverlayEffect overlay, List<PointData> pointList)\n        {\n        }\n\n        /// <summary>\n        /// Renders the overlay for this tool mode.\n        /// </summary>\n        /// <param name=\"cameraInfo\">Current camera instance.</param>\n        /// <param name=\"toolManager\">ToolManager instance.</param>\n        /// <param name=\"overlay\">Overlay effect instance.</param>\n        /// <param name=\"color\">Color to use.</param>\n        /// <param name=\"position\">Current end position.</param>\n        /// <param name=\"drawGuides\">Indicates whether to draw guide lines.</param>", "        public abstract void RenderOverlay(RenderManager.CameraInfo cameraInfo, ToolManager toolManager, OverlayEffect overlay, Color color, Vector3 position, bool drawGuides);\n\n        /// <summary>\n        /// Calculates the points to use based on this mode.\n        /// </summary>\n        /// <param name=\"toolController\">Tool controller refernce.</param>\n        /// <param name=\"prefab\">Currently selected prefab.</param>\n        /// <param name=\"currentPos\">Selection current position.</param>\n        /// <param name=\"spacing\">Spacing setting.</param>\n        /// <param name=\"rotation\">Rotation setting.</param>\n        /// <param name=\"pointList\">List of points to populate.</param>\n        /// <param name=\"rotationMode\">Rotation calculation mode.</param>", "        public abstract void CalculatePoints(ToolController toolController, PrefabInfo prefab, Vector3 currentPos, float spacing, float rotation, List<PointData> pointList, RotationMode rotationMode);\n\n        /// <summary>\n        /// Checks for any collision at the specified point.\n        /// </summary>\n        /// <param name=\"prefab\">Selected prefab.</param>\n        /// <param name=\"position\">Position to check.</param>\n        /// <param name=\"collidingSegments\">Colliding segments array.</param>\n        /// <param name=\"collidingBuildings\">Colliding buildings array.</param>\n        /// <returns>True if the position has a collision for the selected prefab, false othewise.</returns>\n        protected bool CheckCollision(PrefabInfo prefab, Vector3 position, ulong[] collidingSegments, ulong[] collidingBuildings)\n        {", "        protected bool CheckCollision(PrefabInfo prefab, Vector3 position, ulong[] collidingSegments, ulong[] collidingBuildings)\n        {\n            if (prefab is PropInfo prop)\n            {\n                return PropTool.CheckPlacementErrors(prop, position, false, 0, collidingSegments, collidingBuildings) != ToolBase.ToolErrors.None;\n            }\n            else if (prefab is TreeInfo tree)\n            {\n                return TreeTool.CheckPlacementErrors(tree, position, false, 0, collidingSegments, collidingBuildings) != ToolBase.ToolErrors.None;\n            }\n\n            // If we got here, no collision by default.\n            return false;\n        }\n    }\n}\n"]}
{"filename": "Code/Tool/LineTool.cs", "chunked_list": ["\ufeff// <copyright file=\"LineTool.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod\n{\n    using System.Collections;\n    using System.Collections.Generic;\n    using AlgernonCommons;", "    using System.Collections.Generic;\n    using AlgernonCommons;\n    using AlgernonCommons.UI;\n    using ColossalFramework;\n    using ColossalFramework.Math;\n    using ColossalFramework.UI;\n    using HarmonyLib;\n    using LineToolMod.Modes;\n    using UnityEngine;\n    using TreeInstance = global::TreeInstance;", "    using UnityEngine;\n    using TreeInstance = global::TreeInstance;\n\n    /// <summary>\n    /// The line tool itslef.\n    /// </summary>\n    public class LineTool : DefaultTool\n    {\n        private readonly List<PointData> _propPoints = new List<PointData>();\n        private PrefabInfo _selectedPrefab;\n        private Randomizer _randomizer = default;", "        private readonly List<PointData> _propPoints = new List<PointData>();\n        private PrefabInfo _selectedPrefab;\n        private Randomizer _randomizer = default;\n        private ToolMode _currentMode = new LineMode();\n        private bool _fenceMode = false;\n        private float _spacing = 10f;\n\n        // Locking.\n        private bool _locked = false;\n        private Vector3 _lockedPosition;\n\n        // Stepping data.", "        private bool _locked = false;\n        private Vector3 _lockedPosition;\n\n        // Stepping data.\n        private Vector3 _endPos;\n        private float _originalRotation;\n        private bool _validEndPos = false;\n        private bool _stepMode = false;\n        private int _stepIndex = 0;\n\n        // Building height offset modifer.", "        private int _stepIndex = 0;\n\n        // Building height offset modifer.\n        private float _heightOffset = 0.001f;\n\n        // Building completed delegate.\n        private BuildingCompletedDelegate _buildingCompleted;\n\n        /// <summary>\n        /// Delegate to CommonBuildingAI.BuildingCompleted (open delegate).\n        /// </summary>", "        private delegate void BuildingCompletedDelegate(CommonBuildingAI instance, ushort buildingID, ref Building buildingData);\n\n        /// <summary>\n        /// Rotation calculation mode enum.\n        /// </summary>\n        public enum RotationMode\n        {\n            /// <summary>\n            /// Fixed rotation.\n            /// </summary>\n            Fixed,\n\n            /// <summary>\n            /// Relative rotation.\n            /// </summary>\n            Relative,\n\n            /// <summary>\n            /// Random rotation.\n            /// </summary>\n            Random,\n\n            /// <summary>\n            /// Fence mode, aligned to X-axis.\n            /// </summary>\n            FenceAlignedX,\n\n            /// <summary>\n            /// Fence mode, aligned to Z-axis.\n            /// </summary>\n            FenceAlignedZ,\n        }\n\n        /// <summary>\n        /// Gets or sets the line spacing.\n        /// </summary>", "        public float Spacing\n        {\n            get => _spacing;\n\n            set\n            {\n                _spacing = value;\n\n                // Update options panel.\n                StandalonePanelManager<ToolOptionsPanel>.Panel?.RefreshSpacing();\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets the rotation setting.\n        /// </summary>", "        public float Rotation { get; set; } = 0f;\n\n        /// <summary>\n        /// Gets or sets the current tool mode.\n        /// </summary>\n        public ToolMode CurrentMode\n        {\n            get => _currentMode;\n\n            set\n            {\n                _currentMode = value;\n\n                // Reset status on mode change.\n                _locked = false;\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets a value indicating whether fence mode is active.\n        /// </summary>", "        public bool FenceMode\n        {\n            get => _fenceMode;\n\n            set\n            {\n                // Don't do anything if no change.\n                if (value != _fenceMode)\n                {\n                    _fenceMode = value;\n\n                    // Set initial spacing if fence mode has just been activated.", "                    if (value)\n                    {\n                        SetFenceSpacing();\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets a value indicating whether step mode is active.\n        /// </summary>", "        public bool StepMode\n        {\n            get => _stepMode;\n\n            set\n            {\n                _stepMode = value;\n\n                // Clear flags if mode is being disabled.\n                if (!value)\n                {\n                    Stepping = false;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets the base tool for this activation of the line tool.\n        /// </summary>", "                if (!value)\n                {\n                    Stepping = false;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets the base tool for this activation of the line tool.\n        /// </summary>\n        public ToolBase BaseTool { get; set; }\n\n        /// <summary>\n        /// Gets or sets a value indicating whether rotation is relative or absolute.\n        /// </summary>", "        public ToolBase BaseTool { get; set; }\n\n        /// <summary>\n        /// Gets or sets a value indicating whether rotation is relative or absolute.\n        /// </summary>\n        public bool RelativeRotation { get; set; } = true;\n\n        /// <summary>\n        /// Gets or sets the selected prefab to place.\n        /// </summary>\n        public PrefabInfo SelectedPrefab\n        {\n            get => _selectedPrefab;\n\n            set\n            {\n                _selectedPrefab = value;\n\n                // Reset calculated spacing if we're in fence mode.", "        public PrefabInfo SelectedPrefab\n        {\n            get => _selectedPrefab;\n\n            set\n            {\n                _selectedPrefab = value;\n\n                // Reset calculated spacing if we're in fence mode.\n                if (FenceMode)\n                {\n                    SetFenceSpacing();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets the active instance reference.\n        /// </summary>\n        internal static LineTool Instance => ToolsModifierControl.toolController?.gameObject?.GetComponent<LineTool>();\n\n        /// <summary>\n        /// Gets a value indicating whether the RON tool is currently active (true) or inactive (false).\n        /// </summary>\n        internal static bool IsActiveTool => Instance != null && ToolsModifierControl.toolController.CurrentTool == Instance;\n\n        /// <summary>\n        /// Gets a value indicating whether stepping is active.\n        /// </summary>\n        internal bool Stepping\n        {\n            get => _validEndPos;\n\n            private set\n            {\n                // Don't do anything if no change.", "                if (FenceMode)\n                {\n                    SetFenceSpacing();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets the active instance reference.\n        /// </summary>\n        internal static LineTool Instance => ToolsModifierControl.toolController?.gameObject?.GetComponent<LineTool>();\n\n        /// <summary>\n        /// Gets a value indicating whether the RON tool is currently active (true) or inactive (false).\n        /// </summary>\n        internal static bool IsActiveTool => Instance != null && ToolsModifierControl.toolController.CurrentTool == Instance;\n\n        /// <summary>\n        /// Gets a value indicating whether stepping is active.\n        /// </summary>\n        internal bool Stepping\n        {\n            get => _validEndPos;\n\n            private set\n            {\n                // Don't do anything if no change.", "                if (_validEndPos != value)\n                {\n                    _validEndPos = value;\n\n                    // Update panel button states.\n                    StandalonePanelManager<ToolOptionsPanel>.Panel?.UpdateButtonStates();\n\n                    // Reset step index.\n                    _stepIndex = 0;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Sets vehicle ingore flags to ignore all vehicles.\n        /// </summary>\n        /// <returns>Vehicle flags ignoring all vehicles.</returns>", "        public override Vehicle.Flags GetVehicleIgnoreFlags() =>\n            Vehicle.Flags.LeftHandDrive\n            | Vehicle.Flags.Created\n            | Vehicle.Flags.Deleted\n            | Vehicle.Flags.Spawned\n            | Vehicle.Flags.Inverted\n            | Vehicle.Flags.TransferToTarget\n            | Vehicle.Flags.TransferToSource\n            | Vehicle.Flags.Emergency1\n            | Vehicle.Flags.Emergency2\n            | Vehicle.Flags.WaitingPath\n            | Vehicle.Flags.Stopped\n            | Vehicle.Flags.Leaving\n            | Vehicle.Flags.Arriving\n            | Vehicle.Flags.Reversed\n            | Vehicle.Flags.TakingOff\n            | Vehicle.Flags.Flying\n            | Vehicle.Flags.Landing\n            | Vehicle.Flags.WaitingSpace\n            | Vehicle.Flags.WaitingCargo\n            | Vehicle.Flags.GoingBack\n            | Vehicle.Flags.WaitingTarget\n            | Vehicle.Flags.Importing\n            | Vehicle.Flags.Exporting\n            | Vehicle.Flags.Parking\n            | Vehicle.Flags.CustomName\n            | Vehicle.Flags.OnGravel\n            | Vehicle.Flags.WaitingLoading\n            | Vehicle.Flags.Congestion\n            | Vehicle.Flags.DummyTraffic\n            | Vehicle.Flags.Underground\n            | Vehicle.Flags.Transition\n            | Vehicle.Flags.InsideBuilding;\n\n        /// <summary>\n        /// Called by the game every simulation step.\n        /// Performs raycasting to select hovered instance.\n        /// </summary>", "        public override void SimulationStep()\n        {\n            // Don't do anything if the end position is locked.\n            if (_validEndPos)\n            {\n                return;\n            }\n\n            // Get base mouse ray.\n            Ray mouseRay = m_mouseRay;\n\n            // Get raycast input.\n            RaycastInput input = new RaycastInput(mouseRay, m_mouseRayLength)\n            {\n                m_rayRight = m_rayRight,\n                m_netService = GetService(),\n                m_buildingService = GetService(),\n                m_propService = GetService(),\n                m_treeService = GetService(),\n                m_districtNameOnly = true,\n                m_ignoreTerrain = false,\n                m_ignoreNodeFlags = NetNode.Flags.All,\n                m_ignoreSegmentFlags = GetSegmentIgnoreFlags(out input.m_segmentNameOnly),\n                m_ignoreBuildingFlags = Building.Flags.None,\n                m_ignoreTreeFlags = TreeInstance.Flags.All,\n                m_ignorePropFlags = PropInstance.Flags.All,\n                m_ignoreVehicleFlags = GetVehicleIgnoreFlags(),\n                m_ignoreParkedVehicleFlags = VehicleParked.Flags.All,\n                m_ignoreCitizenFlags = CitizenInstance.Flags.All,\n                m_ignoreTransportFlags = TransportLine.Flags.All,\n                m_ignoreDistrictFlags = District.Flags.All,\n                m_ignoreParkFlags = DistrictPark.Flags.All,\n                m_ignoreDisasterFlags = DisasterData.Flags.All,\n                m_transportTypes = 0,\n            };\n\n            ToolErrors errors = ToolErrors.None;\n            RaycastOutput output;\n\n            // Is the base mouse ray valid?", "            if (m_mouseRayValid)\n            {\n                // Yes - raycast.\n                if (RayCast(input, out output))\n                {\n                    // Set base tool accurate position.\n                    m_accuratePosition = output.m_hitPos;\n                }\n                else\n                {\n                    // Raycast failed.\n                    errors = ToolErrors.RaycastFailed;\n                }\n            }\n            else\n            {\n                // No valid mouse ray.\n                output = default;\n                errors = ToolErrors.RaycastFailed;\n            }\n\n            // Set mouse position and record errors.\n            m_mousePosition = output.m_hitPos;\n            m_selectErrors = errors;\n\n            // Calculate points if not locked, or no errors and no valid end position.", "            if (_locked || (errors == ToolErrors.None && !_validEndPos))\n            {\n                // Make threadsafe.\n                lock (_propPoints)\n                {\n                    // Clear list.\n                    _propPoints.Clear();\n\n                    // Set default rotation.\n                    RotationMode rotationMode = RelativeRotation ? RotationMode.Relative : RotationMode.Fixed;\n\n                    // Fence mode calculations (overrides spacing and rotation mode).", "                    if (FenceMode)\n                    {\n                        if (SelectedPrefab is PropInfo prop)\n                        {\n                            // Prop fence mode.\n                            float xSize = prop.m_mesh.bounds.extents.x * 2f;\n                            float zSize = prop.m_mesh.bounds.extents.z * 2f;\n\n                            if (xSize > zSize)\n                            {\n                                rotationMode = RotationMode.FenceAlignedX;\n                            }\n                            else\n                            {\n                                rotationMode = RotationMode.FenceAlignedZ;\n                            }\n                        }", "                            if (xSize > zSize)\n                            {\n                                rotationMode = RotationMode.FenceAlignedX;\n                            }\n                            else\n                            {\n                                rotationMode = RotationMode.FenceAlignedZ;\n                            }\n                        }\n                        else if (SelectedPrefab is BuildingInfo building)\n                        {\n                            // Building fence mode.", "                        else if (SelectedPrefab is BuildingInfo building)\n                        {\n                            // Building fence mode.\n                            if (building.GetWidth() > building.GetLength())\n                            {\n                                rotationMode = RotationMode.FenceAlignedX;\n                            }\n                            else\n                            {\n                                rotationMode = RotationMode.FenceAlignedZ;\n                            }\n                        }\n                    }\n\n                    // Calculate points.\n                    CurrentMode?.CalculatePoints(m_toolController, _selectedPrefab, _locked ? _lockedPosition : m_accuratePosition, Spacing, Rotation, _propPoints, rotationMode);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Called by the game when tool geometry is to be rendered.\n        /// </summary>\n        /// <param name=\"cameraInfo\">Current camera instance.</param>", "        public override void RenderGeometry(RenderManager.CameraInfo cameraInfo)\n        {\n            // Don't preview prefabs when in step mode.\n            if (!_stepMode)\n            {\n                if (SelectedPrefab is PropInfo propInfo)\n                {\n                    Randomizer randomizer = default;\n\n                    // Preview props.\n                    lock (_propPoints)\n                    {", "                        foreach (PointData point in _propPoints)\n                        {\n                            // Skip blocked points.\n                            if (point.Colliding)\n                            {\n                                continue;\n                            }\n\n                            // Based on game code from PropTool.\n                            ushort seed = Singleton<PropManager>.instance.m_props.NextFreeItem(ref randomizer);\n                            Randomizer propRandomizer = new Randomizer(seed);\n                            float scale = propInfo.m_minScale + (propRandomizer.Int32(10000u) * (propInfo.m_maxScale - propInfo.m_minScale) * 0.0001f);\n                            Color color = propInfo.GetColor(ref propRandomizer);\n                            InstanceID id = default;", "                            if (propInfo.m_requireWaterMap)\n                            {\n                                Singleton<TerrainManager>.instance.GetHeightMapping(point.Position, out Texture heightMap, out Vector4 heightMapping, out Vector4 surfaceMapping);\n                                Singleton<TerrainManager>.instance.GetWaterMapping(point.Position, out Texture waterMap, out Vector4 waterHeightMapping, out Vector4 waterSurfaceMapping);\n                                PropInstance.RenderInstance(cameraInfo, propInfo, id, point.Position, scale, point.Rotation, color, RenderManager.DefaultColorLocation, active: true, heightMap, heightMapping, surfaceMapping, waterMap, waterHeightMapping, waterSurfaceMapping);\n                            }\n                            else if (propInfo.m_requireHeightMap)\n                            {\n                                Singleton<TerrainManager>.instance.GetHeightMapping(point.Position, out Texture heightMap, out Vector4 heightMapping, out Vector4 surfaceMapping);\n                                PropInstance.RenderInstance(cameraInfo, propInfo, id, point.Position, scale, point.Rotation, color, RenderManager.DefaultColorLocation, active: true, heightMap, heightMapping, surfaceMapping);\n                            }\n                            else\n                            {\n                                PropInstance.RenderInstance(cameraInfo, propInfo, id, point.Position, scale, point.Rotation, color, RenderManager.DefaultColorLocation, active: true);\n                            }\n                        }\n                    }\n                }", "                else if (SelectedPrefab is TreeInfo treeInfo)\n                {\n                    Randomizer randomizer = default;\n\n                    // Preview trees.\n                    lock (_propPoints)\n                    {\n                        foreach (PointData point in _propPoints)\n                        {\n                            // Skip blocked points.\n                            if (point.Colliding)\n                            {\n                                continue;\n                            }\n\n                            // Based on game code from TreeTool\n                            uint seed = Singleton<TreeManager>.instance.m_trees.NextFreeItem(ref randomizer);\n                            Randomizer treeRandomizer = new Randomizer(seed);\n                            float scale = treeInfo.m_minScale + (treeRandomizer.Int32(10000u) * (treeInfo.m_maxScale - treeInfo.m_minScale) * 0.0001f);\n                            float brightness = treeInfo.m_minBrightness + (treeRandomizer.Int32(10000u) * (treeInfo.m_maxBrightness - treeInfo.m_minBrightness) * 0.0001f);\n                            TreeInstance.RenderInstance(null, treeInfo, point.Position, scale, brightness, RenderManager.DefaultColorLocation, disableRuined: false);\n                        }\n                    }\n                }", "                            if (point.Colliding)\n                            {\n                                continue;\n                            }\n\n                            // Based on game code from TreeTool\n                            uint seed = Singleton<TreeManager>.instance.m_trees.NextFreeItem(ref randomizer);\n                            Randomizer treeRandomizer = new Randomizer(seed);\n                            float scale = treeInfo.m_minScale + (treeRandomizer.Int32(10000u) * (treeInfo.m_maxScale - treeInfo.m_minScale) * 0.0001f);\n                            float brightness = treeInfo.m_minBrightness + (treeRandomizer.Int32(10000u) * (treeInfo.m_maxBrightness - treeInfo.m_minBrightness) * 0.0001f);\n                            TreeInstance.RenderInstance(null, treeInfo, point.Position, scale, brightness, RenderManager.DefaultColorLocation, disableRuined: false);\n                        }\n                    }\n                }", "                else if (SelectedPrefab is BuildingInfo buildingInfo)\n                {\n                    // Preview buildings.\n                    lock (_propPoints)\n                    {\n                        foreach (PointData point in _propPoints)\n                        {\n                            // Skip blocked points.\n                            if (point.Colliding)\n                            {\n                                continue;\n                            }\n\n                            // Based on game code from BuildingTool.\n                            Building data = default;\n                            data.m_position = point.Position;\n                            data.m_angle = point.Rotation;\n                            m_toolController.RenderCollidingNotifications(cameraInfo, 0, 0);\n                            float elevation = point.Position.y;\n                            Color color = buildingInfo.m_buildingAI.GetColor(0, ref data, Singleton<InfoManager>.instance.CurrentMode, Singleton<InfoManager>.instance.CurrentSubMode);\n                            buildingInfo.m_buildingAI.RenderBuildGeometry(cameraInfo, point.Position, point.Rotation, elevation);\n                            BuildingTool.RenderGeometry(cameraInfo, buildingInfo, 0, point.Position, point.Rotation, radius: true, color);", "                            if (point.Colliding)\n                            {\n                                continue;\n                            }\n\n                            // Based on game code from BuildingTool.\n                            Building data = default;\n                            data.m_position = point.Position;\n                            data.m_angle = point.Rotation;\n                            m_toolController.RenderCollidingNotifications(cameraInfo, 0, 0);\n                            float elevation = point.Position.y;\n                            Color color = buildingInfo.m_buildingAI.GetColor(0, ref data, Singleton<InfoManager>.instance.CurrentMode, Singleton<InfoManager>.instance.CurrentSubMode);\n                            buildingInfo.m_buildingAI.RenderBuildGeometry(cameraInfo, point.Position, point.Rotation, elevation);\n                            BuildingTool.RenderGeometry(cameraInfo, buildingInfo, 0, point.Position, point.Rotation, radius: true, color);", "                            if (buildingInfo.m_subBuildings != null && buildingInfo.m_subBuildings.Length != 0)\n                            {\n                                Matrix4x4 matrix4x = default;\n                                matrix4x.SetTRS(point.Position, Quaternion.AngleAxis(point.Rotation * 57.29578f, Vector3.down), Vector3.one);\n                                for (int i = 0; i < buildingInfo.m_subBuildings.Length; i++)\n                                {\n                                    BuildingInfo renderInfo = buildingInfo.m_subBuildings[i].m_buildingInfo;\n                                    Vector3 position = matrix4x.MultiplyPoint(buildingInfo.m_subBuildings[i].m_position);\n                                    float angle = (buildingInfo.m_subBuildings[i].m_angle * (Mathf.PI / 180f)) + point.Rotation;\n                                    Segment3 connectionSegment = default;\n                                    renderInfo.m_buildingAI.CheckBuildPositionMainThread(0, ref position, ref angle, 0f, elevation, ref connectionSegment, out var _, out var _);\n                                    renderInfo.m_buildingAI.RenderBuildGeometry(cameraInfo, position, angle, elevation);\n                                    BuildingTool.RenderGeometry(cameraInfo, renderInfo, 0, position, angle, radius: true, color);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            base.RenderGeometry(cameraInfo);\n        }\n\n        /// <summary>\n        /// Called by game when overlay is to be rendered.\n        /// </summary>\n        /// <param name=\"cameraInfo\">Current camera instance.</param>", "        public override void RenderOverlay(RenderManager.CameraInfo cameraInfo)\n        {\n            base.RenderOverlay(cameraInfo);\n\n            // Local references.\n            ToolManager toolManager = Singleton<ToolManager>.instance;\n            OverlayEffect overlay = Singleton<RenderManager>.instance.OverlayEffect;\n\n            // Render the overlay based on locking status.\n            if (_locked)\n            {\n                CurrentMode.RenderOverlay(cameraInfo, toolManager, overlay, Color.green, _lockedPosition, false);\n            }\n            else\n            {\n                // Not locked - render either the saved track if applicable, or a new track based on the current position.\n                CurrentMode.RenderOverlay(cameraInfo, toolManager, overlay, Color.magenta, _validEndPos ? _endPos : m_accuratePosition, true);\n            }\n\n            // Point overlays.\n            lock (_propPoints)\n            {\n                // Active point if stepping.", "            if (_locked)\n            {\n                CurrentMode.RenderOverlay(cameraInfo, toolManager, overlay, Color.green, _lockedPosition, false);\n            }\n            else\n            {\n                // Not locked - render either the saved track if applicable, or a new track based on the current position.\n                CurrentMode.RenderOverlay(cameraInfo, toolManager, overlay, Color.magenta, _validEndPos ? _endPos : m_accuratePosition, true);\n            }\n\n            // Point overlays.\n            lock (_propPoints)\n            {\n                // Active point if stepping.", "                if (_validEndPos)\n                {\n                    overlay.DrawCircle(cameraInfo, Color.green, _propPoints[_stepIndex].Position, 7f, -1024f, 1024f, false, false);\n                    ++toolManager.m_drawCallData.m_overlayCalls;\n                }\n\n                // Remaining points.\n                foreach (PointData point in _propPoints)\n                {\n                    // Only render where we're not previewing prefabs.\n                    if (_stepMode | point.Colliding)\n                    {\n                        overlay.DrawCircle(cameraInfo, point.Colliding ? Color.red : Color.magenta, point.Position, 5f, -1024f, 1024f, false, false);\n                        ++toolManager.m_drawCallData.m_overlayCalls;\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Sets  spacing to the selected prefab's length.\n        /// </summary>", "                    if (_stepMode | point.Colliding)\n                    {\n                        overlay.DrawCircle(cameraInfo, point.Colliding ? Color.red : Color.magenta, point.Position, 5f, -1024f, 1024f, false, false);\n                        ++toolManager.m_drawCallData.m_overlayCalls;\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Sets  spacing to the selected prefab's length.\n        /// </summary>", "        public void SetToLength()\n        {\n            if (SelectedPrefab is PropInfo prop)\n            {\n                Spacing = prop.m_mesh.bounds.extents.z * 2f;\n            }\n            else if (SelectedPrefab is TreeInfo tree)\n            {\n                Spacing = tree.m_mesh.bounds.extents.z * 2f;\n            }\n            else if (SelectedPrefab is BuildingInfo building)\n            {\n                Spacing = building.GetLength() * 8f;\n            }\n        }\n\n        /// <summary>\n        /// Sets spacing to the selected prefab's width.\n        /// </summary>", "            else if (SelectedPrefab is BuildingInfo building)\n            {\n                Spacing = building.GetLength() * 8f;\n            }\n        }\n\n        /// <summary>\n        /// Sets spacing to the selected prefab's width.\n        /// </summary>\n        public void SetToWidth()\n        {", "        public void SetToWidth()\n        {\n            if (SelectedPrefab is PropInfo prop)\n            {\n                Spacing = prop.m_mesh.bounds.extents.x * 2f;\n            }\n            else if (SelectedPrefab is TreeInfo tree)\n            {\n                Spacing = tree.m_mesh.bounds.extents.x * 2f;\n            }\n            else if (SelectedPrefab is BuildingInfo building)\n            {\n                Spacing = building.GetWidth() * 8f;\n            }\n        }\n\n        /// <summary>\n        /// Adds the next item in sequence.\n        /// </summary>", "            else if (SelectedPrefab is BuildingInfo building)\n            {\n                Spacing = building.GetWidth() * 8f;\n            }\n        }\n\n        /// <summary>\n        /// Adds the next item in sequence.\n        /// </summary>\n        public void Step()\n        {\n            // Only step if data is valid.", "        public void Step()\n        {\n            // Only step if data is valid.\n            if (!_validEndPos || !StepMode)\n            {\n                return;\n            }\n\n            // Place item at this point.\n            int pointIndex = _stepIndex;\n\n            Singleton<SimulationManager>.instance.AddAction(CreateItem(pointIndex));\n\n            // Skip this point and move to next.\n            Skip();\n        }\n\n        /// <summary>\n        /// Skips the next pint in sequence.\n        /// </summary>", "        public void Skip()\n        {\n            // Only step if data is valid.\n            if (!_validEndPos || !StepMode)\n            {\n                return;\n            }\n\n            // Increment index.\n            ++_stepIndex;\n\n            // Check for completion of stepping.\n            lock (_propPoints)\n            {", "                if (_stepIndex == _propPoints.Count)\n                {\n                    // Reached the end of this line; stop stepping.\n                    Stepping = false;\n\n                    // Mode placement post-processing.\n                    CurrentMode.ItemsPlaced(_endPos);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Toggles the current tool to/from the line tool.\n        /// </summary>\n        internal static void ToggleTool()\n        {\n            // Activate tool if it isn't already; if already active, deactivate it by selecting the default tool instead.", "            if (!IsActiveTool)\n            {\n                // Activate tool.\n                ToolsModifierControl.toolController.CurrentTool = Instance;\n            }\n            else\n            {\n                // Activate default tool.\n                ToolsModifierControl.SetTool<DefaultTool>();\n            }\n        }\n\n        /// <summary>\n        /// Initialise the tool.\n        /// Called by unity when the tool is created.\n        /// </summary>", "        protected override void Awake()\n        {\n            base.Awake();\n\n            // Load cursor.\n            m_cursor = UITextures.LoadCursor(\"LT-Cursor.png\");\n\n            // Set the BuildingCompleted delegate if we haven't already.\n            if (_buildingCompleted == null)\n            {\n                _buildingCompleted = AccessTools.MethodDelegate<BuildingCompletedDelegate>(AccessTools.Method(typeof(CommonBuildingAI), \"BuildingCompleted\"));", "            if (_buildingCompleted == null)\n            {\n                _buildingCompleted = AccessTools.MethodDelegate<BuildingCompletedDelegate>(AccessTools.Method(typeof(CommonBuildingAI), \"BuildingCompleted\"));\n                if (_buildingCompleted == null)\n                {\n                    Logging.Error(\"unable to get delegate for CommonBuildingAI.BuildingCompleted\");\n                }\n            }\n        }\n\n        /// <summary>\n        /// Called by game when tool is enabled.\n        /// </summary>", "        protected override void OnEnable()\n        {\n            // Call base even before loaded checks to properly initialize tool.\n            base.OnEnable();\n\n            // Make sure that game is loaded before activating tool.\n            if (!Loading.IsLoaded)\n            {\n                // Loading not complete - deactivate tool by seting default tool.\n                ToolsModifierControl.SetTool<DefaultTool>();\n                return;\n            }\n        }\n\n        /// <summary>\n        /// Unity late update handling.\n        /// Called by game every late update.\n        /// </summary>", "        protected override void OnToolLateUpdate()\n        {\n            base.OnToolLateUpdate();\n\n            // Force the info mode to none.\n            ForceInfoMode(InfoManager.InfoMode.None, InfoManager.SubInfoMode.None);\n        }\n\n        /// <summary>\n        /// Tool GUI event processing.\n        /// Called by game every GUI update.\n        /// </summary>\n        /// <param name=\"e\">Event.</param>", "        protected override void OnToolGUI(Event e)\n        {\n            base.OnToolGUI(e);\n\n            // Prcessed 'enter' key to exit locking..\n            bool placing = false;\n            if (_locked && e.type == EventType.KeyUp)\n            {\n                if (e.keyCode == KeyCode.Return || e.keyCode == KeyCode.KeypadEnter)\n                {\n                    e.Use();\n                    _locked = false;\n\n                    // Initiate placement.\n                    InitiatePlacement();\n\n                    return;\n                }\n            }\n\n            // Don't do anything if inside UI.", "                if (e.keyCode == KeyCode.Return || e.keyCode == KeyCode.KeypadEnter)\n                {\n                    e.Use();\n                    _locked = false;\n\n                    // Initiate placement.\n                    InitiatePlacement();\n\n                    return;\n                }\n            }\n\n            // Don't do anything if inside UI.", "            if (m_toolController.IsInsideUI)\n            {\n                return;\n            }\n\n            // Check for escape key.\n            if (e.type == EventType.keyDown && e.keyCode == KeyCode.Escape)\n            {\n                // Escape key pressed - disable tool.\n                e.Use();\n                ToolsModifierControl.SetTool<DefaultTool>();\n            }\n\n            // Check for mousedown events with button zero.", "            if (placing || e.type == EventType.MouseDown)\n            {\n                // Got one; use the event.\n                UIInput.MouseUsed();\n\n                if (e.button == 1)\n                {\n                    // Right-click; clear selection.\n                    CurrentMode.Reset();\n                    Stepping = false;\n                    return;\n                }\n\n                // Don't do anything if there are any errors other than failed raycast.", "                if (m_selectErrors != ToolErrors.None && m_selectErrors != ToolErrors.RaycastFailed)\n                {\n                    return;\n                }\n\n                if (e.button == 0)\n                {\n                    if (_locked)\n                    {\n                        _locked = false;\n                    }\n\n                    // Only perform actions when not locked and there's a valid selected prefab.", "                    if (!_locked && _selectedPrefab != null)\n                    {\n                        // Handle click via current mode.\n                        if (CurrentMode.HandleClick(m_accuratePosition))\n                        {\n                            if (Input.GetKey(KeyCode.LeftControl) || Input.GetKey(KeyCode.RightControl))\n                            {\n                                _locked = true;\n                                _lockedPosition = m_accuratePosition;\n                                return;\n                            }\n\n                            // Initiate placement.\n                            InitiatePlacement();\n                        }\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Intitiates item placement.\n        /// </summary>", "        private void InitiatePlacement()\n        {\n            // Stepping?\n            if (StepMode)\n            {\n                // Step mode - save end point.\n                Stepping = true;\n                _endPos = m_accuratePosition;\n                _originalRotation = Rotation;\n            }\n            else\n            {\n                // Not step mode - place all items.\n                lock (_propPoints)\n                {\n                    PointData[] points = new PointData[_propPoints.Count];\n                    _propPoints.CopyTo(points);\n                    PrefabInfo selectedPrefab = _selectedPrefab;\n                    Singleton<SimulationManager>.instance.AddAction(CreateItems(points, selectedPrefab));\n                }\n\n                // Mode placement post-processing.\n                CurrentMode.ItemsPlaced(m_accuratePosition);\n            }\n        }\n\n        /// <summary>\n        /// Action method to create new items on the map.\n        /// </summary>\n        /// <param name=\"points\">Target point array.</param>\n        /// <param name=\"prefab\">Prefab to place.</param>\n        /// <returns>Action IEnumerator yield.</returns>", "        private IEnumerator CreateItems(PointData[] points, PrefabInfo prefab)\n        {\n            if (prefab is PropInfo prop)\n            {\n                // Props - create one at each point.\n                foreach (PointData point in points)\n                {\n                    if (!point.Colliding)\n                    {\n                        CreateProp(prop, point.Position, point.Rotation);\n                    }\n                }\n            }", "            else if (prefab is TreeInfo tree)\n            {\n                // Trees - create one at each point.\n                foreach (PointData point in points)\n                {\n                    if (!point.Colliding)\n                    {\n                        CreateTree(tree, point.Position);\n                    }\n                }\n            }", "            else if (prefab is BuildingInfo building)\n            {\n                // Buildings - create one at each point.\n                foreach (PointData point in points)\n                {\n                    if (!point.Colliding)\n                    {\n                        CreateBuilding(building, point.Position, point.Rotation);\n                    }\n                }\n            }\n\n            yield return 0;\n        }\n\n        /// <summary>\n        /// Action method to create a new single item on the map.\n        /// </summary>\n        /// <param name=\"pointIndex\">Index number of this point.</param>\n        /// <returns>Action IEnumerator yield.</returns>", "        private IEnumerator CreateItem(int pointIndex)\n        {\n            // Make threadsafe.\n            lock (_propPoints)\n            {\n                if (pointIndex < _propPoints.Count)\n                {\n                    PointData point = _propPoints[pointIndex];\n\n                    // Skip any colliding items.\n                    if (!point.Colliding)\n                    {\n                        // Check any rotation delta.\n                        float rotationDelta = Rotation - _originalRotation;\n", "                    if (!point.Colliding)\n                    {\n                        // Check any rotation delta.\n                        float rotationDelta = Rotation - _originalRotation;\n\n                        if (_selectedPrefab is PropInfo prop)\n                        {\n                            // Prop.\n                            CreateProp(prop, point.Position, point.Rotation + rotationDelta);\n                        }\n                        else if (_selectedPrefab is TreeInfo tree)\n                        {\n                            // Tree.\n                            CreateTree(tree, point.Position);\n                        }", "                        else if (_selectedPrefab is TreeInfo tree)\n                        {\n                            // Tree.\n                            CreateTree(tree, point.Position);\n                        }\n                        else if (_selectedPrefab is BuildingInfo building)\n                        {\n                            // Building.\n                            CreateBuilding(building, point.Position, point.Rotation + rotationDelta);\n                        }\n                    }\n                }\n            }\n\n            yield return 0;\n        }\n\n        /// <summary>\n        /// Creates a prop instance.\n        /// Based on game code.\n        /// </summary>\n        /// <param name=\"prop\">Prop prefab.</param>\n        /// <param name=\"position\">Postion.</param>\n        /// <param name=\"rotation\">Prop rotation (in degrees).</param>", "        private void CreateProp(PropInfo prop, Vector3 position, float rotation)\n        {\n            // Check construction cost.\n            bool isAffordable = true;\n            if ((Singleton<ToolManager>.instance.m_properties.m_mode & ItemClass.Availability.Game) != 0)\n            {\n                int constructionCost = prop.GetConstructionCost();\n                isAffordable = constructionCost == 0 || constructionCost == Singleton<EconomyManager>.instance.FetchResource(EconomyManager.Resource.Construction, constructionCost, prop.m_class);\n            }\n\n            // Create the prop.", "            if (isAffordable && Singleton<PropManager>.instance.CreateProp(out ushort _, ref _randomizer, prop, position, rotation, true))\n            {\n                PropTool.DispatchPlacementEffect(position, false);\n            }\n        }\n\n        /// <summary>\n        /// Creates a tree instance.\n        /// Based on game code.\n        /// </summary>\n        /// <param name=\"tree\">Tree prefab.</param>\n        /// <param name=\"position\">Postion.</param>", "        private void CreateTree(TreeInfo tree, Vector3 position)\n        {\n            // Check construction cost.\n            bool isAffordable = true;\n            if ((Singleton<ToolManager>.instance.m_properties.m_mode & ItemClass.Availability.Game) != 0)\n            {\n                int constructionCost = tree.GetConstructionCost();\n                isAffordable = constructionCost == 0 || constructionCost == Singleton<EconomyManager>.instance.FetchResource(EconomyManager.Resource.Construction, constructionCost, tree.m_class);\n            }\n\n            // Create the tree.", "            if (isAffordable && Singleton<TreeManager>.instance.CreateTree(out uint _, ref _randomizer, tree, position, true))\n            {\n                TreeTool.DispatchPlacementEffect(position, false);\n            }\n        }\n\n        /// <summary>\n        /// Creates a building instance.\n        /// Based on game code.\n        /// </summary>\n        /// <param name=\"building\">Building prefab.</param>\n        /// <param name=\"position\">Building position.</param>\n        /// <param name=\"angle\">Bulding angle.</param>", "        private void CreateBuilding(BuildingInfo building, Vector3 position, float angle)\n        {\n            // Effective prefab (may be overwritten).\n            BuildingInfo buildingPrefab = building;\n            ushort buildingID = 0;\n\n            // Check construction cost.\n            bool isAffordable = true;\n            if ((Singleton<ToolManager>.instance.m_properties.m_mode & ItemClass.Availability.Game) != 0)\n            {\n                int constructionCost = buildingPrefab.GetConstructionCost();\n                isAffordable = constructionCost == 0 || constructionCost == Singleton<EconomyManager>.instance.FetchResource(EconomyManager.Resource.Construction, constructionCost, buildingPrefab.m_class);\n            }\n\n            // Apply height adjustment.\n            Vector3 adjustedPosition = position;\n            adjustedPosition.y += _heightOffset;\n            _heightOffset *= -1f;\n", "            if ((Singleton<ToolManager>.instance.m_properties.m_mode & ItemClass.Availability.Game) != 0)\n            {\n                int constructionCost = buildingPrefab.GetConstructionCost();\n                isAffordable = constructionCost == 0 || constructionCost == Singleton<EconomyManager>.instance.FetchResource(EconomyManager.Resource.Construction, constructionCost, buildingPrefab.m_class);\n            }\n\n            // Apply height adjustment.\n            Vector3 adjustedPosition = position;\n            adjustedPosition.y += _heightOffset;\n            _heightOffset *= -1f;\n", "            if (isAffordable)\n            {\n                bool buildingPlaced = false;\n\n                if (buildingPrefab.m_buildingAI.WorksAsNet())\n                {\n                    Building data = default;\n                    data.m_buildIndex = Singleton<SimulationManager>.instance.m_currentBuildIndex;\n                    data.m_position = adjustedPosition;\n                    data.m_angle = angle;\n                    data.Width = buildingPrefab.m_cellWidth;\n                    data.Length = buildingPrefab.m_cellLength;\n                    BuildingDecoration.LoadPaths(buildingPrefab, 0, ref data, adjustedPosition.y);", "                    if (Mathf.Abs(adjustedPosition.y) < 1f)\n                    {\n                        BuildingDecoration.LoadProps(buildingPrefab, 0, ref data);\n                    }\n\n                    Singleton<SimulationManager>.instance.m_currentBuildIndex++;\n                    buildingPlaced = true;\n                }\n                else if (Singleton<BuildingManager>.instance.CreateBuilding(out buildingID, ref Singleton<SimulationManager>.instance.m_randomizer, buildingPrefab, adjustedPosition, angle, 0, Singleton<SimulationManager>.instance.m_currentBuildIndex))\n                {\n                    BuildingInfo placedInfo = Singleton<BuildingManager>.instance.m_buildings.m_buffer[buildingID].Info;", "                else if (Singleton<BuildingManager>.instance.CreateBuilding(out buildingID, ref Singleton<SimulationManager>.instance.m_randomizer, buildingPrefab, adjustedPosition, angle, 0, Singleton<SimulationManager>.instance.m_currentBuildIndex))\n                {\n                    BuildingInfo placedInfo = Singleton<BuildingManager>.instance.m_buildings.m_buffer[buildingID].Info;\n                    if (placedInfo != null)\n                    {\n                        buildingPrefab = placedInfo;\n                    }\n\n                    Singleton<BuildingManager>.instance.m_buildings.m_buffer[buildingID].m_flags |= Building.Flags.FixedHeight;\n\n                    Singleton<SimulationManager>.instance.m_currentBuildIndex++;\n                    buildingPlaced = true;\n                }\n\n                // Handle building placement.", "                if (buildingPlaced)\n                {\n                    buildingPrefab.m_notUsedGuide?.Disable();\n\n                    buildingPrefab.m_buildingAI.PlacementSucceeded();\n                    Singleton<GuideManager>.instance.m_notEnoughMoney.Deactivate();\n                    int publicServiceIndex = ItemClass.GetPublicServiceIndex(buildingPrefab.m_class.m_service);\n                    if (publicServiceIndex != -1)\n                    {\n                        Singleton<GuideManager>.instance.m_serviceNotUsed[publicServiceIndex].Disable();\n                        Singleton<GuideManager>.instance.m_serviceNeeded[publicServiceIndex].Deactivate();\n                        Singleton<CoverageManager>.instance.CoverageUpdated(buildingPrefab.m_class.m_service, buildingPrefab.m_class.m_subService, buildingPrefab.m_class.m_level);\n                    }\n\n                    BuildingTool.DispatchPlacementEffect(buildingPrefab, 0, adjustedPosition, angle, buildingPrefab.m_cellWidth, buildingPrefab.m_cellLength, bulldozing: false, collapsed: false);\n\n                    // Instant construction.\n                    // Check that we have a valid building ID.", "                    if (buildingID != 0)\n                    {\n                        // Get building AI.\n                        PrivateBuildingAI buildingAI = buildingPrefab.m_buildingAI as PrivateBuildingAI;\n\n                        // Only interested in private building AI.\n                        if (buildingAI != null)\n                        {\n                            // Check to see if construction time is greater than zero.\n                            if (buildingAI.m_constructionTime > 0)\n                            {\n                                // Complete construction.\n                                Singleton<BuildingManager>.instance.m_buildings.m_buffer[buildingID].m_frame0.m_constructState = byte.MaxValue;\n                                _buildingCompleted.Invoke(buildingAI, buildingID, ref Singleton<BuildingManager>.instance.m_buildings.m_buffer[buildingID]);\n\n                                // Have to do this manually as CommonBuildingAI.BuildingCompleted won't if construction time isn't zero.\n                                Singleton<BuildingManager>.instance.UpdateBuildingRenderer(buildingID, updateGroup: true);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Sets fence mode spacing to the relevant dimension size.\n        /// </summary>", "                            if (buildingAI.m_constructionTime > 0)\n                            {\n                                // Complete construction.\n                                Singleton<BuildingManager>.instance.m_buildings.m_buffer[buildingID].m_frame0.m_constructState = byte.MaxValue;\n                                _buildingCompleted.Invoke(buildingAI, buildingID, ref Singleton<BuildingManager>.instance.m_buildings.m_buffer[buildingID]);\n\n                                // Have to do this manually as CommonBuildingAI.BuildingCompleted won't if construction time isn't zero.\n                                Singleton<BuildingManager>.instance.UpdateBuildingRenderer(buildingID, updateGroup: true);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Sets fence mode spacing to the relevant dimension size.\n        /// </summary>", "        private void SetFenceSpacing()\n        {\n            if (SelectedPrefab is PropInfo prop)\n            {\n                // Prop fence mode.\n                float xSize = prop.m_mesh.bounds.extents.x * 2f;\n                float zSize = prop.m_mesh.bounds.extents.z * 2f;\n\n                if (xSize > zSize)\n                {\n                    SetToWidth();\n                }\n                else\n                {\n                    SetToLength();\n                }\n            }", "                if (xSize > zSize)\n                {\n                    SetToWidth();\n                }\n                else\n                {\n                    SetToLength();\n                }\n            }\n            else if (SelectedPrefab is BuildingInfo building)\n            {\n                // Building fence mode.", "            else if (SelectedPrefab is BuildingInfo building)\n            {\n                // Building fence mode.\n                if (building.GetWidth() > building.GetLength())\n                {\n                    SetToWidth();\n                }\n                else\n                {\n                    SetToLength();\n                }\n            }\n        }\n\n        /// <summary>", "        /// Data struct for calculated point.\n        /// </summary>\n        public struct PointData\n        {\n            /// <summary>\n            /// Point location.\n            /// </summary>\n            public Vector3 Position;\n\n            /// <summary>\n            /// Point rotation.\n            /// </summary>", "            public float Rotation;\n\n            /// <summary>\n            /// Collision state.\n            /// </summary>\n            public bool Colliding;\n        }\n    }\n}\n"]}
{"filename": "Code/Tool/Modes/LineMode.cs", "chunked_list": ["\ufeff// <copyright file=\"LineMode.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod.Modes\n{\n    using System.Collections.Generic;\n    using ColossalFramework;\n    using ColossalFramework.Math;", "    using ColossalFramework;\n    using ColossalFramework.Math;\n    using UnityEngine;\n    using static LineTool;\n\n    /// <summary>\n    /// Straight-line placement mode.\n    /// </summary>\n    public class LineMode : ToolMode\n    {\n        // Calculated bezier.", "    public class LineMode : ToolMode\n    {\n        // Calculated bezier.\n        private Bezier3 _thisBezier;\n\n        /// <summary>\n        /// Renders the overlay for this tool mode.\n        /// </summary>\n        /// <param name=\"cameraInfo\">Current camera instance.</param>\n        /// <param name=\"toolManager\">ToolManager instance.</param>\n        /// <param name=\"overlay\">Overlay effect instance.</param>\n        /// <param name=\"color\">Color to use.</param>\n        /// <param name=\"position\">Current end position.</param>\n        /// <param name=\"drawGuides\">Indicates whether to draw guide lines.</param>", "        public override void RenderOverlay(RenderManager.CameraInfo cameraInfo, ToolManager toolManager, OverlayEffect overlay, Color color, Vector3 position, bool drawGuides)\n        {\n            // Don't render anything if no valid initial point.\n            if (m_validStart)\n            {\n                // Calulate bezier data.\n                Vector3 startDirection = position - m_startPos;\n                startDirection = VectorUtils.NormalizeXZ(startDirection, out float distance);\n                Vector3 endDirection = -startDirection;\n                distance *= 0.15f;\n                Vector3 middlePos1 = m_startPos + (startDirection * distance);\n                Vector3 middlePos2 = position + (endDirection * distance);\n\n                // Draw bezier.\n                _thisBezier = new Bezier3(m_startPos, middlePos1, middlePos2, position);\n                overlay.DrawBezier(cameraInfo, color, _thisBezier, 2f, 0f, 0f, -1024f, 1024f, false, false);\n                ++toolManager.m_drawCallData.m_overlayCalls;\n            }\n        }\n\n        /// <summary>\n        /// Calculates the points to use based on this mode.\n        /// </summary>\n        /// <param name=\"toolController\">Tool controller refernce.</param>\n        /// <param name=\"prefab\">Currently selected prefab.</param>\n        /// <param name=\"currentPos\">Selection current position.</param>\n        /// <param name=\"spacing\">Spacing setting.</param>\n        /// <param name=\"rotation\">Rotation setting.</param>\n        /// <param name=\"pointList\">List of points to populate.</param>\n        /// <param name=\"rotationMode\">Rotation calculation mode.</param>", "        public override void CalculatePoints(ToolController toolController, PrefabInfo prefab, Vector3 currentPos, float spacing, float rotation, List<PointData> pointList, RotationMode rotationMode)\n        {\n            // Don't do anything if we don't have a valid start point.\n            if (!m_validStart)\n            {\n                return;\n            }\n\n            // Local reference.\n            TerrainManager terrainManager = Singleton<TerrainManager>.instance;\n\n            // Calculate line vector.\n            Vector3 difference = currentPos - m_startPos;\n            float magnitude = difference.magnitude;\n\n            // Handle rotation mode.\n            float finalRotation = rotation;\n            switch (rotationMode)\n            {\n                // Align prefab X-axis to line direction.\n                case RotationMode.Relative:\n                    finalRotation += Mathf.Atan2(difference.z, difference.x);\n                    break;\n\n                case RotationMode.FenceAlignedX:\n                    finalRotation = Mathf.Atan2(difference.z, difference.x);\n                    break;\n\n                // Align prefab Y-axis to line direction.\n                case RotationMode.FenceAlignedZ:\n                    // Offset 90 degrees.\n                    finalRotation = Mathf.Atan2(difference.z, difference.x) - (Mathf.PI / 2f);\n                    break;\n            }\n\n            // Determine start position.\n            float currentDistance = 0f;\n\n            // Offset start position for fence mode.", "            if (rotationMode == RotationMode.FenceAlignedX || rotationMode == RotationMode.FenceAlignedZ)\n            {\n                currentDistance = spacing / 2f;\n            }\n\n            // Create points.\n            toolController.BeginColliding(out ulong[] collidingSegments, out ulong[] collidingBuildings);\n            while (currentDistance < magnitude)\n            {\n                // Interpolate position.\n                float lerpFactor = currentDistance / magnitude;\n                Vector3 thisPoint = Vector3.Lerp(m_startPos, currentPos, lerpFactor);\n\n                // Get terrain height.\n                thisPoint.y = terrainManager.SampleDetailHeight(thisPoint, out float _, out float _);\n\n                // Add point to list.\n                pointList.Add(new PointData { Position = thisPoint, Rotation = finalRotation, Colliding = CheckCollision(prefab, thisPoint, collidingSegments, collidingBuildings) });\n                currentDistance += spacing;\n            }\n\n            toolController.EndColliding();\n        }\n    }\n}\n"]}
{"filename": "Code/Tool/Modes/CircleMode.cs", "chunked_list": ["\ufeff// <copyright file=\"CircleMode.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod.Modes\n{\n    using System.Collections.Generic;\n    using ColossalFramework;\n    using ColossalFramework.Math;", "    using ColossalFramework;\n    using ColossalFramework.Math;\n    using UnityEngine;\n    using static LineTool;\n\n    /// <summary>\n    /// Circle placement mode.\n    /// </summary>\n    public class CircleMode : ToolMode\n    {\n        /// <summary>\n        /// Renders the overlay for this tool mode.\n        /// </summary>\n        /// <param name=\"cameraInfo\">Current camera instance.</param>\n        /// <param name=\"toolManager\">ToolManager instance.</param>\n        /// <param name=\"overlay\">Overlay effect instance.</param>\n        /// <param name=\"color\">Color to use.</param>\n        /// <param name=\"position\">Current end position.</param>\n        /// <param name=\"drawGuides\">Indicates whether to draw guide lines.</param>", "    public class CircleMode : ToolMode\n    {\n        /// <summary>\n        /// Renders the overlay for this tool mode.\n        /// </summary>\n        /// <param name=\"cameraInfo\">Current camera instance.</param>\n        /// <param name=\"toolManager\">ToolManager instance.</param>\n        /// <param name=\"overlay\">Overlay effect instance.</param>\n        /// <param name=\"color\">Color to use.</param>\n        /// <param name=\"position\">Current end position.</param>\n        /// <param name=\"drawGuides\">Indicates whether to draw guide lines.</param>", "        public override void RenderOverlay(RenderManager.CameraInfo cameraInfo, ToolManager toolManager, OverlayEffect overlay, Color color, Vector3 position, bool drawGuides)\n        {\n            // Don't render anything if no valid initial point.\n            if (m_validStart && drawGuides)\n            {\n                // Simple straight line overlay to show centre and current radius/angle of circle.\n                Segment3 segment = new Segment3(m_startPos, position);\n                overlay.DrawSegment(cameraInfo, color, segment, 2f, DashLength, -1024f, 1024f, false, false);\n                ++toolManager.m_drawCallData.m_overlayCalls;\n            }\n        }\n\n        /// <summary>\n        /// Calculates the points to use based on this mode.\n        /// </summary>\n        /// <param name=\"toolController\">Tool controller refernce.</param>\n        /// <param name=\"prefab\">Currently selected prefab.</param>\n        /// <param name=\"currentPos\">Selection current position.</param>\n        /// <param name=\"spacing\">Spacing setting.</param>\n        /// <param name=\"rotation\">Rotation setting.</param>\n        /// <param name=\"pointList\">List of points to populate.</param>\n        /// <param name=\"rotationMode\">Rotation calculation mode.</param>", "        public override void CalculatePoints(ToolController toolController, PrefabInfo prefab, Vector3 currentPos, float spacing, float rotation, List<PointData> pointList, RotationMode rotationMode)\n        {\n            // Don't do anything if we don't have a valid start point.\n            if (!m_validStart)\n            {\n                return;\n            }\n\n            // Local reference.\n            TerrainManager terrainManager = Singleton<TerrainManager>.instance;\n\n            // Calculate line vector.\n            Vector3 difference = currentPos - m_startPos;\n            float magnitude = difference.magnitude;\n\n            // Calculate spacing.\n            float circumference = magnitude * Mathf.PI * 2f;\n            float numPoints = Mathf.Floor(circumference / spacing);\n            float increment = (Mathf.PI * 2f) / numPoints;\n            float startAngle = Mathf.Atan2(difference.z, difference.x);\n            float finalRotation = rotation;\n\n            // Create points.\n            toolController.BeginColliding(out ulong[] collidingSegments, out ulong[] collidingBuildings);", "            for (float i = startAngle; i < startAngle + (Mathf.PI * 2f); i += increment)\n            {\n                float xPos = magnitude * Mathf.Cos(i);\n                float yPos = magnitude * Mathf.Sin(i);\n                Vector3 thisPoint = new Vector3(m_startPos.x + xPos, m_startPos.y, m_startPos.z + yPos);\n\n                // Calculate non-absolute rotation, if applicable.\n                switch (rotationMode)\n                {\n                    case RotationMode.Relative:\n                        finalRotation = Mathf.Atan2(yPos, xPos) - (Mathf.PI / 2f) + rotation;\n                        break;\n\n                    case RotationMode.FenceAlignedZ:\n                        finalRotation = Mathf.Atan2(yPos, xPos);\n                        break;\n\n                    case RotationMode.FenceAlignedX:\n                        finalRotation = Mathf.Atan2(yPos, xPos) - (Mathf.PI / 2f);\n                        break;\n                }\n\n                // Get terrain height.\n                thisPoint.y = terrainManager.SampleDetailHeight(thisPoint, out float _, out float _);\n\n                // Add point to list.\n                pointList.Add(new PointData { Position = thisPoint, Rotation = finalRotation, Colliding = CheckCollision(prefab, thisPoint, collidingSegments, collidingBuildings) });\n            }\n\n            toolController.EndColliding();\n        }\n\n        /// <summary>\n        /// Performs actions after items are placed on the current line, setting up for the next line to be set.\n        /// </summary>\n        /// <param name=\"location\">Click world location.</param>", "        public override void ItemsPlaced(Vector3 location)\n        {\n            // Empty, to retain original start position (centre of circle).\n        }\n    }\n}\n"]}
{"filename": "Code/Tool/Modes/FreeformMode.cs", "chunked_list": ["\ufeff// <copyright file=\"FreeformMode.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod.Modes\n{\n    using UnityEngine;\n\n    /// <summary>", "\n    /// <summary>\n    /// Curved line placement mode.\n    /// </summary>\n    public class FreeformMode : CurveMode\n    {\n        /// <summary>\n        /// Handles a mouse click.\n        /// </summary>\n        /// <param name=\"location\">Click world location.</param>\n        /// <returns>True if items are to be placed as a result of this click, false otherwise.</returns>", "        public override bool HandleClick(Vector3 location)\n        {\n            // If no valid initial point, record this as the first point.\n            if (!m_validStart)\n            {\n                m_startPos = location;\n                m_validStart = true;\n                return false;\n            }\n\n            // Othwerwise, if no valid elbow point, record this as the elbow point.", "            if (!m_validElbow)\n            {\n                m_elbowPoint = location;\n                m_validElbow = true;\n                return false;\n            }\n\n            // If we got here, then we're placing.\n\n            // Place the items on the curve.\n            return true;\n        }\n\n        /// <summary>\n        /// Performs actions after items are placed on the current line, setting up for the next line to be set.\n        /// </summary>\n        /// <param name=\"location\">Click world location.</param>", "        public override void ItemsPlaced(Vector3 location)\n        {\n            // Calculate new start and elbow points based on second leg.\n            Vector3 difference = location - m_elbowPoint;\n            m_startPos = location;\n            m_elbowPoint = location + difference;\n        }\n    }\n}\n"]}
{"filename": "Code/Tool/Modes/CurveMode.cs", "chunked_list": ["\ufeff// <copyright file=\"CurveMode.cs\" company=\"algernon (K. Algernon A. Sheppard)\">\n// Copyright (c) algernon (K. Algernon A. Sheppard). All rights reserved.\n// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.\n// </copyright>\n\nnamespace LineToolMod.Modes\n{\n    using System.Collections.Generic;\n    using ColossalFramework;\n    using ColossalFramework.Math;", "    using ColossalFramework;\n    using ColossalFramework.Math;\n    using UnityEngine;\n    using static LineTool;\n\n    /// <summary>\n    /// Curved line placement mode.\n    /// </summary>\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\"StyleCop.CSharp.NamingRules\", \"SA1307:Accessible fields should begin with upper-case letter\", Justification = \"Protected internal fields\")]\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\"StyleCop.CSharp.MaintainabilityRules\", \"SA1401:Fields should be private\", Justification = \"Protected internal fields\")]\n    public class CurveMode : ToolMode\n    {\n        /// <summary>\n        /// Indicates whether the elbow point is currently valid.\n        /// </summary>", "    [System.Diagnostics.CodeAnalysis.SuppressMessage(\"StyleCop.CSharp.NamingRules\", \"SA1307:Accessible fields should begin with upper-case letter\", Justification = \"Protected internal fields\")]\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\"StyleCop.CSharp.MaintainabilityRules\", \"SA1401:Fields should be private\", Justification = \"Protected internal fields\")]\n    public class CurveMode : ToolMode\n    {\n        /// <summary>\n        /// Indicates whether the elbow point is currently valid.\n        /// </summary>\n        protected internal bool m_validElbow = false;\n\n        /// <summary>\n        /// Indicates whether the elbow point is currently valid.\n        /// </summary>", "        protected internal bool m_validBezier = false;\n\n        /// <summary>\n        /// Current elbow point.\n        /// </summary>\n        protected internal Vector3 m_elbowPoint;\n\n        // Calculated bezier.\n        private Bezier3 _thisBezier;\n\n        /// <summary>\n        /// Clears the current selection.\n        /// </summary>", "        private Bezier3 _thisBezier;\n\n        /// <summary>\n        /// Clears the current selection.\n        /// </summary>\n        public override void Reset()\n        {\n            // Only clear elbow if we have one.\n            if (m_validElbow)\n            {\n                m_validElbow = false;\n            }\n            else\n            {\n                base.Reset();\n            }\n\n            m_validBezier = false;\n        }\n\n        /// <summary>\n        /// Handles a mouse click.\n        /// </summary>\n        /// <param name=\"location\">Click world location.</param>\n        /// <returns>True if items are to be placed as a result of this click, false otherwise.</returns>", "            if (m_validElbow)\n            {\n                m_validElbow = false;\n            }\n            else\n            {\n                base.Reset();\n            }\n\n            m_validBezier = false;\n        }\n\n        /// <summary>\n        /// Handles a mouse click.\n        /// </summary>\n        /// <param name=\"location\">Click world location.</param>\n        /// <returns>True if items are to be placed as a result of this click, false otherwise.</returns>", "        public override bool HandleClick(Vector3 location)\n        {\n            // If no valid initial point, record this as the first point.\n            if (!m_validStart)\n            {\n                m_startPos = location;\n                m_validStart = true;\n                return false;\n            }\n\n            // Othwerwise, if no valid elbow point, record this as the elbow point.", "            if (!m_validElbow)\n            {\n                m_elbowPoint = location;\n                m_validElbow = true;\n                return false;\n            }\n\n            // Place the items on the curve.\n            return true;\n        }\n\n        /// <summary>\n        /// Performs actions after items are placed on the current line, setting up for the next line to be set.\n        /// </summary>\n        /// <param name=\"location\">Click world location.</param>", "        public override void ItemsPlaced(Vector3 location)\n        {\n            // Update new starting location to the previous end point and clear elbow.\n            m_startPos = location;\n            m_validElbow = false;\n            m_validBezier = false;\n        }\n\n        /// <summary>\n        /// Calculates the points to use based on this mode.\n        /// </summary>\n        /// <param name=\"toolController\">Tool controller refernce.</param>\n        /// <param name=\"prefab\">Currently selected prefab.</param>\n        /// <param name=\"currentPos\">Selection current position.</param>\n        /// <param name=\"spacing\">Spacing setting.</param>\n        /// <param name=\"rotation\">Rotation setting.</param>\n        /// <param name=\"pointList\">List of points to populate.</param>\n        /// <param name=\"rotationMode\">Rotation calculation mode.</param>", "        public override void CalculatePoints(ToolController toolController, PrefabInfo prefab, Vector3 currentPos, float spacing, float rotation, List<PointData> pointList, RotationMode rotationMode)\n        {\n            // Don't do anything if we don't have valid start and elbow points.\n            if (!(m_validStart & m_validElbow))\n            {\n                return;\n            }\n\n            // Calulate angles.\n            Vector3 direction1 = m_elbowPoint - m_startPos;\n            direction1.Normalize();\n            Vector3 direction2 = m_elbowPoint - currentPos;\n            direction2.Normalize();\n\n            // Create bezier.\n            NetSegment.CalculateMiddlePoints(m_startPos, direction1, currentPos, direction2, false, false, out Vector3 middlePos1, out Vector3 middlePos2);\n            _thisBezier = new Bezier3(m_startPos, middlePos1, middlePos2, currentPos);\n            m_validBezier = true;\n\n            // Local reference.\n            TerrainManager terrainManager = Singleton<TerrainManager>.instance;\n\n            // Calculate points along bezier.\n            float tFactor = 0f;\n            toolController.BeginColliding(out ulong[] collidingSegments, out ulong[] collidingBuildings);", "            if (rotationMode == RotationMode.FenceAlignedX || rotationMode == RotationMode.FenceAlignedZ)\n            {\n                // Fence mode.\n                while (tFactor <= 1.0f)\n                {\n                    // Get start and endpoints of this fence segment.\n                    Vector3 startPoint = _thisBezier.Position(tFactor);\n                    tFactor = BezierStep(tFactor, spacing);\n                    Vector3 endPoint = _thisBezier.Position(tFactor);\n\n                    // Calculate rotation angle.\n                    Vector3 difference = endPoint - startPoint;\n                    float finalRotation = Mathf.Atan2(difference.z, difference.x);\n\n                    // Calculate midpoint (prop placement point) and get terrain height.\n                    Vector3 midPoint = new Vector3(endPoint.x - (difference.x / 2f), 0f, endPoint.z - (difference.z / 2f));\n                    midPoint.y = terrainManager.SampleDetailHeight(midPoint, out float _, out float _);\n\n                    // Add point to list.\n                    pointList.Add(new PointData { Position = midPoint, Rotation = finalRotation, Colliding = CheckCollision(prefab, midPoint, collidingSegments, collidingBuildings) });\n                }\n            }\n            else\n            {\n                // Non-fence mode.", "                while (tFactor <= 1.0f)\n                {\n                    Vector3 thisPoint = _thisBezier.Position(tFactor);\n\n                    // Get terrain height.\n                    thisPoint.y = terrainManager.SampleDetailHeight(thisPoint, out float _, out float _);\n\n                    // Calculate rotation.\n                    float finalRotation = rotation;\n                    if (rotationMode == RotationMode.Relative)\n                    {\n                        // Get the points either side of this gap.\n                        Vector3 prevPoint = _thisBezier.Position(BezierStep(tFactor, -spacing));\n                        Vector3 nextPoint = _thisBezier.Position(BezierStep(tFactor, spacing));\n\n                        // Calculate rotation angle.\n                        Vector3 difference = nextPoint - prevPoint;\n                        finalRotation += Mathf.Atan2(difference.z, difference.x);\n                    }\n\n                    // Add point to list.\n                    pointList.Add(new PointData { Position = thisPoint, Rotation = finalRotation, Colliding = CheckCollision(prefab, thisPoint, collidingSegments, collidingBuildings) });\n\n                    // Get next point.\n                    tFactor = BezierStep(tFactor, spacing);\n                }\n            }\n\n            toolController.EndColliding();\n        }\n\n        /// <summary>\n        /// Renders the overlay for this tool mode.\n        /// </summary>\n        /// <param name=\"cameraInfo\">Current camera instance.</param>\n        /// <param name=\"toolManager\">ToolManager instance.</param>\n        /// <param name=\"overlay\">Overlay effect instance.</param>\n        /// <param name=\"color\">Color to use.</param>\n        /// <param name=\"position\">Current end position.</param>\n        /// <param name=\"drawGuides\">Indicates whether to draw guide lines.</param>", "                    if (rotationMode == RotationMode.Relative)\n                    {\n                        // Get the points either side of this gap.\n                        Vector3 prevPoint = _thisBezier.Position(BezierStep(tFactor, -spacing));\n                        Vector3 nextPoint = _thisBezier.Position(BezierStep(tFactor, spacing));\n\n                        // Calculate rotation angle.\n                        Vector3 difference = nextPoint - prevPoint;\n                        finalRotation += Mathf.Atan2(difference.z, difference.x);\n                    }\n\n                    // Add point to list.\n                    pointList.Add(new PointData { Position = thisPoint, Rotation = finalRotation, Colliding = CheckCollision(prefab, thisPoint, collidingSegments, collidingBuildings) });\n\n                    // Get next point.\n                    tFactor = BezierStep(tFactor, spacing);\n                }\n            }\n\n            toolController.EndColliding();\n        }\n\n        /// <summary>\n        /// Renders the overlay for this tool mode.\n        /// </summary>\n        /// <param name=\"cameraInfo\">Current camera instance.</param>\n        /// <param name=\"toolManager\">ToolManager instance.</param>\n        /// <param name=\"overlay\">Overlay effect instance.</param>\n        /// <param name=\"color\">Color to use.</param>\n        /// <param name=\"position\">Current end position.</param>\n        /// <param name=\"drawGuides\">Indicates whether to draw guide lines.</param>", "        public override void RenderOverlay(RenderManager.CameraInfo cameraInfo, ToolManager toolManager, OverlayEffect overlay, Color color, Vector3 position, bool drawGuides)\n        {\n            // No overlay to render if there isn't a valid starting point.\n            if (!m_validStart)\n            {\n                return;\n            }\n\n            // Draw line guides.\n            if (drawGuides)\n            {", "            if (drawGuides)\n            {\n                if (!m_validElbow)\n                {\n                    // No elbow point yet - just draw initial line.\n                    Segment3 segment = new Segment3(m_startPos, position);\n                    overlay.DrawSegment(cameraInfo, color, segment, 2f, DashLength, -1024f, 1024f, false, false);\n                    ++toolManager.m_drawCallData.m_overlayCalls;\n                }\n                else\n                {\n                    // Valid elbow - draw both lines.\n                    Segment3 segment = new Segment3(m_startPos, m_elbowPoint);\n                    Segment3 segment2 = new Segment3(m_elbowPoint, position);\n                    overlay.DrawSegment(cameraInfo, color, segment, segment2, 2f, DashLength, -1024f, 1024f, false, false);\n                    ++toolManager.m_drawCallData.m_overlayCalls;\n                }\n            }\n\n            // Draw bezier overlay if we have a valid bezier to draw.", "            if (m_validBezier)\n            {\n                overlay.DrawBezier(cameraInfo, color, _thisBezier, 2f, 0f, 0f, -1024f, 1024f, false, false);\n                ++toolManager.m_drawCallData.m_overlayCalls;\n            }\n        }\n\n        /// <summary>\n        /// Steps along a bezier calculating the target t factor for the given starting t factor and the current spacing setting.\n        /// Code based on Alterran's PropLineTool (StepDistanceCurve, Utilities/PLTMath.cs).\n        /// </summary>\n        /// <param name=\"tStart\">Starting t factor.</param>\n        /// <param name=\"spacing\">Spacing setting.</param>\n        /// <returns>Target t factor.</returns>", "        private float BezierStep(float tStart, float spacing)\n        {\n            const float Tolerance = 0.001f;\n            const float ToleranceSquared = Tolerance * Tolerance;\n\n            float tEnd = _thisBezier.Travel(tStart, spacing);\n            float usedDistance = CubicBezierArcLengthXZGauss04(tStart, tEnd);\n\n            // Twelve iteration maximum for performance and to prevent infinite loops.\n            for (int i = 0; i < 12; ++i)\n            {\n                // Stop looping if the remaining distance is less than tolerance.\n                float remainingDistance = spacing - usedDistance;", "            for (int i = 0; i < 12; ++i)\n            {\n                // Stop looping if the remaining distance is less than tolerance.\n                float remainingDistance = spacing - usedDistance;\n                if (remainingDistance * remainingDistance < ToleranceSquared)\n                {\n                    break;\n                }\n\n                usedDistance = CubicBezierArcLengthXZGauss04(tStart, tEnd);\n                tEnd += (spacing - usedDistance) / CubicSpeedXZ(tEnd);\n            }\n\n            return tEnd;\n        }\n\n        /// <summary>\n        /// From Alterann's PropLineTool (CubicSpeedXZ, Utilities/PLTMath.cs).\n        /// Returns the integrand of the arc length function for a cubic bezier curve, constrained to the XZ-plane at a specific t.\n        /// </summary>\n        /// <param name=\"t\"> t factor.</param>\n        /// <returns>Integrand of arc length.</returns>", "        private float CubicSpeedXZ(float t)\n        {\n            // Pythagorean theorem.\n            Vector3 tangent = _thisBezier.Tangent(t);\n            float derivXsqr = tangent.x * tangent.x;\n            float derivZsqr = tangent.z * tangent.z;\n\n            return Mathf.Sqrt(derivXsqr + derivZsqr);\n        }\n\n        /// <summary>\n        /// From Alterann's PropLineTool (CubicBezierArcLengthXZGauss04, Utilities/PLTMath.cs).\n        /// Returns the XZ arclength of a cubic bezier curve between two t factors.\n        /// Uses Gauss\u2013Legendre Quadrature with n = 4.\n        /// </summary>\n        /// <param name=\"t1\">Starting t factor.</param>\n        /// <param name=\"t2\">Ending t factor.</param>\n        /// <returns>XZ arc length.</returns>", "        private float CubicBezierArcLengthXZGauss04(float t1, float t2)\n        {\n            float linearAdj = (t2 - t1) / 2f;\n\n            // Constants are from Gauss-Lengendre quadrature rules for n = 4.\n            float p1 = CubicSpeedXZGaussPoint(0.3399810435848563f, 0.6521451548625461f, t1, t2);\n            float p2 = CubicSpeedXZGaussPoint(-0.3399810435848563f, 0.6521451548625461f, t1, t2);\n            float p3 = CubicSpeedXZGaussPoint(0.8611363115940526f, 0.3478548451374538f, t1, t2);\n            float p4 = CubicSpeedXZGaussPoint(-0.8611363115940526f, 0.3478548451374538f, t1, t2);\n\n            return linearAdj * (p1 + p2 + p3 + p4);\n        }\n\n        /// <summary>\n        /// From Alterann's PropLineTool (CubicSpeedXZGaussPoint, Utilities/PLTMath.cs).\n        /// </summary>\n        /// <param name=\"x_i\">X i.</param>\n        /// <param name=\"w_i\">W i.</param>\n        /// <param name=\"a\">a.</param>\n        /// <param name=\"b\">b.</param>\n        /// <returns>Cubic speed.</returns>", "        private float CubicSpeedXZGaussPoint(float x_i, float w_i, float a, float b)\n        {\n            float linearAdj = (b - a) / 2f;\n            float constantAdj = (a + b) / 2f;\n            return w_i * CubicSpeedXZ((linearAdj * x_i) + constantAdj);\n        }\n    }\n}\n"]}
