{"filename": "src/LegendaryLibrary.cs", "chunked_list": ["\ufeffusing CliWrap;\nusing CliWrap.EventStream;\nusing LegendaryLibraryNS.Enums;\nusing LegendaryLibraryNS.Models;\nusing LegendaryLibraryNS.Services;\nusing Playnite.Common;\nusing Playnite.SDK;\nusing Playnite.SDK.Data;\nusing Playnite.SDK.Events;\nusing Playnite.SDK.Models;", "using Playnite.SDK.Events;\nusing Playnite.SDK.Models;\nusing Playnite.SDK.Plugins;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\nusing System.Threading;", "using System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Controls;\n\nnamespace LegendaryLibraryNS\n{\n    [LoadPlugin]\n    public class LegendaryLibrary : LibraryPluginBase<LegendaryLibrarySettingsViewModel>\n    {", "    [LoadPlugin]\n    public class LegendaryLibrary : LibraryPluginBase<LegendaryLibrarySettingsViewModel>\n    {\n        private static readonly ILogger logger = LogManager.GetLogger();\n        public static LegendaryLibrary Instance { get; set; }\n        public static bool LegendaryGameInstaller { get; internal set; }\n        public LegendaryDownloadManager LegendaryDownloadManager { get; set; }\n\n        public LegendaryLibrary(IPlayniteAPI api) : base(\n            \"Legendary (Epic)\",\n            Guid.Parse(\"EAD65C3B-2F8F-4E37-B4E6-B3DE6BE540C6\"),\n            new LibraryPluginProperties { CanShutdownClient = true, HasSettings = true },\n            new LegendaryClient(),\n            LegendaryLauncher.Icon,\n            (_) => new LegendaryLibrarySettingsView(),\n            api)\n        {\n            Instance = this;\n            SettingsViewModel = new LegendaryLibrarySettingsViewModel(this, api);\n            LoadEpicLocalization();\n        }\n", "        public static LegendaryLibrarySettings GetSettings()\n        {\n            return Instance.SettingsViewModel?.Settings ?? null;\n        }\n\n        public static LegendaryDownloadManager GetLegendaryDownloadManager()\n        {\n            if (Instance.LegendaryDownloadManager == null)\n            {\n                Instance.LegendaryDownloadManager = new LegendaryDownloadManager();\n            }\n            return Instance.LegendaryDownloadManager;\n        }\n\n        internal Dictionary<string, GameMetadata> GetInstalledGames()\n        {\n            var games = new Dictionary<string, GameMetadata>();\n            var appList = LegendaryLauncher.GetInstalledAppList();\n", "            foreach (KeyValuePair<string, Installed> d in appList)\n            {\n                var app = d.Value;\n\n                if (app.App_name.StartsWith(\"UE_\"))\n                {\n                    continue;\n                }\n\n                // DLC\n                if (app.Is_dlc)\n                {\n                    continue;\n                }\n\n                var installLocation = app.Install_path;\n                var gameName = app?.Title ?? Path.GetFileName(installLocation);", "                if (app.Is_dlc)\n                {\n                    continue;\n                }\n\n                var installLocation = app.Install_path;\n                var gameName = app?.Title ?? Path.GetFileName(installLocation);\n                if (installLocation.IsNullOrEmpty())\n                {\n                    continue;\n                }\n\n                installLocation = Paths.FixSeparators(installLocation);", "                if (!Directory.Exists(installLocation))\n                {\n                    logger.Error($\"Epic game {gameName} installation directory {installLocation} not detected.\");\n                    continue;\n                }\n\n                var game = new GameMetadata()\n                {\n                    Source = new MetadataNameProperty(\"Epic\"),\n                    GameId = app.App_name,\n                    Name = gameName,\n                    Version = app.Version,\n                    InstallDirectory = installLocation,\n                    IsInstalled = true,\n                    Platforms = new HashSet<MetadataProperty> { new MetadataSpecProperty(\"pc_windows\") }\n                };\n\n                game.Name = game.Name.RemoveTrademarks();\n                games.Add(game.GameId, game);\n            }\n\n            return games;\n        }\n\n        internal List<GameMetadata> GetLibraryGames(CancellationToken cancelToken)\n        {\n            var cacheDir = GetCachePath(\"catalogcache\");\n            var games = new List<GameMetadata>();\n            var accountApi = new EpicAccountClient(PlayniteApi, LegendaryLauncher.TokensPath);\n            var assets = accountApi.GetAssets();", "            if (!assets?.Any() == true)\n            {\n                Logger.Warn(\"Found no assets on Epic accounts.\");\n            }\n\n            var playtimeItems = accountApi.GetPlaytimeItems();\n            foreach (var gameAsset in assets.Where(a => a.@namespace != \"ue\"))\n            {\n                if (cancelToken.IsCancellationRequested)\n                {\n                    break;\n                }\n\n                var cacheFile = Paths.GetSafePathName($\"{gameAsset.@namespace}_{gameAsset.catalogItemId}_{gameAsset.buildVersion}.json\");\n                cacheFile = Path.Combine(cacheDir, cacheFile);\n                var catalogItem = accountApi.GetCatalogItem(gameAsset.@namespace, gameAsset.catalogItemId, cacheFile);", "                if (cancelToken.IsCancellationRequested)\n                {\n                    break;\n                }\n\n                var cacheFile = Paths.GetSafePathName($\"{gameAsset.@namespace}_{gameAsset.catalogItemId}_{gameAsset.buildVersion}.json\");\n                cacheFile = Path.Combine(cacheDir, cacheFile);\n                var catalogItem = accountApi.GetCatalogItem(gameAsset.@namespace, gameAsset.catalogItemId, cacheFile);\n                if (catalogItem?.categories?.Any(a => a.path == \"applications\") != true)\n                {\n                    continue;\n                }\n", "                if (catalogItem?.categories?.Any(a => a.path == \"applications\") != true)\n                {\n                    continue;\n                }\n\n                if (catalogItem?.categories?.Any(a => a.path == \"dlc\") == true)\n                {\n                    continue;\n                }\n\n                var newGame = new GameMetadata\n                {\n                    Source = new MetadataNameProperty(\"Epic\"),\n                    GameId = gameAsset.appName,\n                    Name = catalogItem.title.RemoveTrademarks(),\n                    Platforms = new HashSet<MetadataProperty> { new MetadataSpecProperty(\"pc_windows\") }\n                };\n\n                var playtimeItem = playtimeItems?.FirstOrDefault(x => x.artifactId == gameAsset.appName);", "                if (playtimeItem != null)\n                {\n                    newGame.Playtime = playtimeItem.totalTime;\n                }\n\n                games.Add(newGame);\n            }\n\n            return games;\n        }\n", "        public override IEnumerable<GameMetadata> GetGames(LibraryGetGamesArgs args)\n        {\n            var allGames = new List<GameMetadata>();\n            var installedGames = new Dictionary<string, GameMetadata>();\n            Exception importError = null;\n\n            if (SettingsViewModel.Settings.ImportInstalledGames)\n            {\n                try\n                {\n                    installedGames = GetInstalledGames();\n                    Logger.Debug($\"Found {installedGames.Count} installed Epic games.\");\n                    allGames.AddRange(installedGames.Values.ToList());\n                }", "                catch (Exception e)\n                {\n                    Logger.Error(e, \"Failed to import installed Epic games.\");\n                    importError = e;\n                }\n            }\n\n            if (SettingsViewModel.Settings.ConnectAccount)\n            {\n                try\n                {\n                    var libraryGames = GetLibraryGames(args.CancelToken);\n                    Logger.Debug($\"Found {libraryGames.Count} library Epic games.\");\n", "                    if (!SettingsViewModel.Settings.ImportUninstalledGames)\n                    {\n                        libraryGames = libraryGames.Where(lg => installedGames.ContainsKey(lg.GameId)).ToList();\n                    }\n\n                    foreach (var game in libraryGames)\n                    {\n                        if (installedGames.TryGetValue(game.GameId, out var installed))\n                        {\n                            installed.Playtime = game.Playtime;\n                            installed.LastActivity = game.LastActivity;\n                            installed.Name = game.Name;\n                        }\n                        else\n                        {\n                            allGames.Add(game);\n                        }\n                    }\n                }", "                catch (Exception e)\n                {\n                    Logger.Error(e, \"Failed to import linked account Epic games details.\");\n                    importError = e;\n                }\n            }\n\n            if (importError != null)\n            {\n                PlayniteApi.Notifications.Add(new NotificationMessage(\n                    ImportErrorMessageId,\n                    string.Format(PlayniteApi.Resources.GetString(\"LOCLibraryImportError\"), Name) +\n                    Environment.NewLine + importError.Message,\n                    NotificationType.Error,\n                    () => OpenSettingsView()));\n            }\n            else\n            {\n                PlayniteApi.Notifications.Remove(ImportErrorMessageId);\n            }\n\n            return allGames;\n        }\n", "        public string GetCachePath(string dirName)\n        {\n            return Path.Combine(GetPluginUserDataPath(), dirName);\n        }\n\n        public override IEnumerable<InstallController> GetInstallActions(GetInstallActionsArgs args)\n        {\n            if (args.Game.PluginId != Id)\n            {\n                yield break;\n            }\n\n            yield return new LegendaryInstallController(args.Game);\n        }\n", "        public override IEnumerable<UninstallController> GetUninstallActions(GetUninstallActionsArgs args)\n        {\n            if (args.Game.PluginId != Id)\n            {\n                yield break;\n            }\n\n            yield return new LegendaryUninstallController(args.Game);\n        }\n\n        public override IEnumerable<PlayController> GetPlayActions(GetPlayActionsArgs args)\n        {", "        public override IEnumerable<PlayController> GetPlayActions(GetPlayActionsArgs args)\n        {\n            if (args.Game.PluginId != Id)\n            {\n                yield break;\n            }\n            yield return new LegendaryPlayController(args.Game);\n        }\n\n        public override LibraryMetadataProvider GetMetadataDownloader()\n        {\n            return new EpicMetadataProvider(PlayniteApi);\n        }\n", "        public override LibraryMetadataProvider GetMetadataDownloader()\n        {\n            return new EpicMetadataProvider(PlayniteApi);\n        }\n\n        public void LoadEpicLocalization()\n        {\n            var currentLanguage = PlayniteApi.ApplicationSettings.Language;\n            var dictionaries = Application.Current.Resources.MergedDictionaries;\n\n            void loadString(string xamlPath)\n            {\n                ResourceDictionary res = null;\n                try\n                {\n                    res = Xaml.FromFile<ResourceDictionary>(xamlPath);\n                    res.Source = new Uri(xamlPath, UriKind.Absolute);", "                    foreach (var key in res.Keys)\n                    {\n                        if (res[key] is string locString)\n                        {\n                            if (locString.IsNullOrEmpty())\n                            {\n                                res.Remove(key);\n                            }\n                        }\n                        else\n                        {\n                            res.Remove(key);\n                        }\n                    }\n                }", "                catch (Exception e)\n                {\n                    logger.Error(e, $\"Failed to parse localization file {xamlPath}\");\n                    return;\n                }\n                dictionaries.Add(res);\n            }\n\n            var extraLocDir = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), @\"Localization\\Epic\");\n            if (!Directory.Exists(extraLocDir))\n            {\n                return;\n            }\n\n            var enXaml = Path.Combine(extraLocDir, \"en_US.xaml\");", "            if (!Directory.Exists(extraLocDir))\n            {\n                return;\n            }\n\n            var enXaml = Path.Combine(extraLocDir, \"en_US.xaml\");\n            if (!File.Exists(enXaml))\n            {\n                return;\n            }\n\n            loadString(enXaml);", "            if (currentLanguage != \"en_US\")\n            {\n                var langXaml = Path.Combine(extraLocDir, $\"{currentLanguage}.xaml\");\n                if (File.Exists(langXaml))\n                {\n                    loadString(langXaml);\n                }\n            }\n        }\n\n        public void SyncGameSaves(string gameName, string gameID, string gameInstallDir, bool download)\n        {", "        public void SyncGameSaves(string gameName, string gameID, string gameInstallDir, bool download)\n        {\n            if (GetSettings().SyncGameSaves)\n            {\n                var metadataFile = Path.Combine(LegendaryLauncher.ConfigPath, \"metadata\", gameID + \".json\");\n                if (File.Exists(metadataFile))\n                {\n                    bool correctJson = false;\n                    LegendaryMetadata.Rootobject metadata = null;\n                    if (Serialization.TryFromJson(FileSystem.ReadFileAsStringSafe(Path.Combine(LegendaryLauncher.ConfigPath, \"metadata\", gameID + \".json\")), out metadata))\n                    {", "                    if (Serialization.TryFromJson(FileSystem.ReadFileAsStringSafe(Path.Combine(LegendaryLauncher.ConfigPath, \"metadata\", gameID + \".json\")), out metadata))\n                    {\n                        if (metadata != null && metadata.metadata != null)\n                        {\n                            correctJson = true;\n                        }\n                    }\n                    if (!correctJson)\n                    {\n                        GlobalProgressOptions metadataProgressOptions = new GlobalProgressOptions(ResourceProvider.GetString(\"LOCProgressMetadata\"), false);\n                        PlayniteApi.Dialogs.ActivateGlobalProgress(async (a) =>\n                        {\n                            a.ProgressMaxValue = 100;\n                            a.CurrentProgressValue = 0;\n                            var cmd = Cli.Wrap(LegendaryLauncher.ClientExecPath).WithArguments(new[] { \"info\", gameID });", "                            await foreach (var cmdEvent in cmd.ListenAsync())\n                            {\n                                switch (cmdEvent)\n                                {\n                                    case StartedCommandEvent started:\n                                        a.CurrentProgressValue = 1;\n                                        break;\n                                    case StandardErrorCommandEvent stdErr:\n                                        logger.Debug(\"[Legendary] \" + stdErr.ToString());\n                                        break;\n                                    case ExitedCommandEvent exited:", "                                        if (exited.ExitCode != 0)\n                                        {\n                                            logger.Error(\"[Legendary] exit code: \" + exited.ExitCode);\n                                            PlayniteApi.Dialogs.ShowErrorMessage(PlayniteApi.Resources.GetString(\"LOCMetadataDownloadError\").Format(gameName));\n                                            return;\n                                        }\n                                        else\n                                        {\n                                            metadata = Serialization.FromJson<LegendaryMetadata.Rootobject>(FileSystem.ReadFileAsStringSafe(Path.Combine(LegendaryLauncher.ConfigPath, \"metadata\", gameID + \".json\")));\n                                        }\n                                        a.CurrentProgressValue = 100;\n                                        break;\n                                    default:\n                                        break;\n                                }\n                            }\n                        }, metadataProgressOptions);\n                    }\n                    var cloudSaveFolder = metadata.metadata.customAttributes.CloudSaveFolder.value;", "                    if (cloudSaveFolder != null)\n                    {\n                        var userData = Serialization.FromJson<OauthResponse>(FileSystem.ReadFileAsStringSafe(LegendaryLauncher.TokensPath));\n                        var pathVariables = new Dictionary<string, string>\n                        {\n                            { \"{installdir}\", gameInstallDir },\n                            { \"{epicid}\",  userData.account_id },\n                            { \"{appdata}\",  Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) },\n                            { \"{userdir}\", Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments) },\n                            { \"{userprofile}\", Environment.GetFolderPath(Environment.SpecialFolder.UserProfile) },\n                            { \"{usersavedgames}\", Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \"Saved Games\") }\n                        };", "                        foreach (var pathVar in pathVariables)\n                        {\n                            if (cloudSaveFolder.Contains(pathVar.Key, StringComparison.OrdinalIgnoreCase))\n                            {\n                                cloudSaveFolder = cloudSaveFolder.Replace(pathVar.Key, pathVar.Value, StringComparison.OrdinalIgnoreCase);\n                            }\n                        }\n                        cloudSaveFolder = Path.GetFullPath(cloudSaveFolder);\n                        if (Directory.Exists(cloudSaveFolder))\n                        {\n                            GlobalProgressOptions globalProgressOptions = new GlobalProgressOptions(ResourceProvider.GetString(LOC.LegendarySyncing).Format(gameName), false);\n                            PlayniteApi.Dialogs.ActivateGlobalProgress(async (a) =>\n                            {\n                                a.ProgressMaxValue = 100;\n                                a.CurrentProgressValue = 0;\n                                var skippedActivity = \"--skip-upload\";", "                        if (Directory.Exists(cloudSaveFolder))\n                        {\n                            GlobalProgressOptions globalProgressOptions = new GlobalProgressOptions(ResourceProvider.GetString(LOC.LegendarySyncing).Format(gameName), false);\n                            PlayniteApi.Dialogs.ActivateGlobalProgress(async (a) =>\n                            {\n                                a.ProgressMaxValue = 100;\n                                a.CurrentProgressValue = 0;\n                                var skippedActivity = \"--skip-upload\";\n                                if (download == false)\n                                {\n                                    skippedActivity = \"--skip-download\";\n                                }\n                                var cmd = Cli.Wrap(LegendaryLauncher.ClientExecPath)\n                                             .WithArguments(new[] { \"-y\", \"sync-saves\", gameID, skippedActivity, \"--save-path\", cloudSaveFolder });", "                                if (download == false)\n                                {\n                                    skippedActivity = \"--skip-download\";\n                                }\n                                var cmd = Cli.Wrap(LegendaryLauncher.ClientExecPath)\n                                             .WithArguments(new[] { \"-y\", \"sync-saves\", gameID, skippedActivity, \"--save-path\", cloudSaveFolder });\n                                await foreach (var cmdEvent in cmd.ListenAsync())\n                                {\n                                    switch (cmdEvent)\n                                    {\n                                        case StartedCommandEvent started:\n                                            a.CurrentProgressValue = 1;\n                                            break;\n                                        case StandardErrorCommandEvent stdErr:\n                                            logger.Debug(\"[Legendary] \" + stdErr.ToString());\n                                            break;\n                                        case ExitedCommandEvent exited:\n                                            a.CurrentProgressValue = 100;", "                                            if (exited.ExitCode != 0)\n                                            {\n                                                logger.Error(\"[Legendary] exit code: \" + exited.ExitCode);\n                                                PlayniteApi.Dialogs.ShowErrorMessage(PlayniteApi.Resources.GetString(LOC.LegendarySyncError).Format(gameName));\n                                            }\n                                            break;\n                                        default:\n                                            break;\n                                    }\n                                }\n                            }, globalProgressOptions);\n                        }\n                    }\n                }\n            }\n        }\n", "        public override void OnGameStarting(OnGameStartingEventArgs args)\n        {\n            SyncGameSaves(args.Game.Name, args.Game.GameId, args.Game.InstallDirectory, true);\n        }\n\n        public override void OnGameStopped(OnGameStoppedEventArgs args)\n        {\n            SyncGameSaves(args.Game.Name, args.Game.GameId, args.Game.InstallDirectory, false);\n        }\n\n        public override IEnumerable<SidebarItem> GetSidebarItems()\n        {\n            yield return new SidebarItem\n            {\n                Title = ResourceProvider.GetString(LOC.LegendaryPanel),\n                Icon = LegendaryLauncher.Icon,\n                Type = SiderbarItemType.View,\n                Opened = () => GetLegendaryDownloadManager()\n            };\n        }\n", "        public override IEnumerable<SidebarItem> GetSidebarItems()\n        {\n            yield return new SidebarItem\n            {\n                Title = ResourceProvider.GetString(LOC.LegendaryPanel),\n                Icon = LegendaryLauncher.Icon,\n                Type = SiderbarItemType.View,\n                Opened = () => GetLegendaryDownloadManager()\n            };\n        }\n", "        public override void OnApplicationStopped(OnApplicationStoppedEventArgs args)\n        {\n            LegendaryDownloadManager downloadManager = GetLegendaryDownloadManager();\n            var runningAndQueuedDownloads = downloadManager.downloadManagerData.downloads.Where(i => i.status == (int)DownloadStatus.Running\n                                                                                                     || i.status == (int)DownloadStatus.Queued).ToList();\n            if (runningAndQueuedDownloads.Count > 0)\n            {\n                foreach (var download in runningAndQueuedDownloads)\n                {\n                    if (download.status == (int)DownloadStatus.Running)\n                    {\n                        downloadManager.gracefulInstallerCTS?.Cancel();\n                        downloadManager.gracefulInstallerCTS?.Dispose();\n                        downloadManager.forcefulInstallerCTS?.Dispose();\n                    }\n                    download.status = (int)DownloadStatus.Paused;\n                }\n                downloadManager.SaveData();\n            }\n", "                    if (download.status == (int)DownloadStatus.Running)\n                    {\n                        downloadManager.gracefulInstallerCTS?.Cancel();\n                        downloadManager.gracefulInstallerCTS?.Dispose();\n                        downloadManager.forcefulInstallerCTS?.Dispose();\n                    }\n                    download.status = (int)DownloadStatus.Paused;\n                }\n                downloadManager.SaveData();\n            }\n", "            if (GetSettings().AutoClearCache != (int)ClearCacheTime.Never)\n            {\n                var clearingTime = DateTime.Now;\n                switch (GetSettings().AutoClearCache)\n                {\n                    case (int)ClearCacheTime.Day:\n                        clearingTime = DateTime.Now.AddDays(-1);\n                        break;\n                    case (int)ClearCacheTime.Week:\n                        clearingTime = DateTime.Now.AddDays(-7);\n                        break;\n                    case (int)ClearCacheTime.Month:\n                        clearingTime = DateTime.Now.AddMonths(-1);\n                        break;\n                    case (int)ClearCacheTime.ThreeMonths:\n                        clearingTime = DateTime.Now.AddMonths(-3);\n                        break;\n                    case (int)ClearCacheTime.SixMonths:\n                        clearingTime = DateTime.Now.AddMonths(-6);\n                        break;\n                    default:\n                        break;\n                }\n                var cacheDirs = new List<string>()\n                {\n                    GetCachePath(\"catalogcache\"),\n                    GetCachePath(\"infocache\"),\n                    GetCachePath(\"sdlcache\")\n                };\n", "                foreach (var cacheDir in cacheDirs)\n                {\n                    if (Directory.Exists(cacheDir))\n                    {\n                        if (Directory.GetCreationTime(cacheDir) < clearingTime)\n                        {\n                            Directory.Delete(cacheDir, true);\n                        }\n                    }\n                }\n            }\n        }\n", "        public override IEnumerable<GameMenuItem> GetGameMenuItems(GetGameMenuItemsArgs args)\n        {\n            foreach (var game in args.Games)\n            {\n                if (game.PluginId == Id && game.IsInstalled)\n                {\n                    yield return new GameMenuItem\n                    {\n                        Description = ResourceProvider.GetString(LOC.LegendaryRepair),\n                        Action = (args) =>\n                        {\n                            Window window = null;", "                            if (PlayniteApi.ApplicationInfo.Mode == ApplicationMode.Desktop)\n                            {\n                                window = PlayniteApi.Dialogs.CreateWindow(new WindowCreationOptions\n                                {\n                                    ShowMaximizeButton = false,\n                                });\n                            }\n                            else\n                            {\n                                window = new Window\n                                {\n                                    Background = System.Windows.Media.Brushes.DodgerBlue\n                                };\n                            }\n                            window.Title = game.Name;\n                            var installProperties = new DownloadProperties { downloadAction = (int)DownloadAction.Repair };\n                            var installData = new DownloadManagerData.Download { gameID = game.GameId, downloadProperties = installProperties };\n                            window.DataContext = installData;\n                            window.Content = new LegendaryGameInstaller();\n                            window.Owner = PlayniteApi.Dialogs.GetCurrentAppWindow();\n                            window.SizeToContent = SizeToContent.WidthAndHeight;\n                            window.MinWidth = 600;\n                            window.WindowStartupLocation = WindowStartupLocation.CenterOwner;\n                            window.ShowDialog();\n                        }\n                    };\n                }\n            }\n        }\n\n    }\n}\n"]}
{"filename": "src/LegendaryLauncher.cs", "chunked_list": ["\ufeffusing IniParser;\nusing IniParser.Model;\nusing LegendaryLibraryNS.Models;\nusing Microsoft.Win32;\nusing Playnite.Common;\nusing Playnite.SDK;\nusing Playnite.SDK.Data;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;", "using System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS\n{\n    public class LegendaryLauncher\n    {", "{\n    public class LegendaryLauncher\n    {\n        public static string ConfigPath => Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \".config\", \"legendary\");\n\n        public static string ClientExecPath\n        {\n            get\n            {\n                var path = LauncherPath;\n                return string.IsNullOrEmpty(path) ? string.Empty : GetExecutablePath(path);\n            }\n        }\n", "        public static string LauncherPath\n        {\n            get\n            {\n                var launcherPath = \"\";\n                var envPath = Environment.GetEnvironmentVariable(\"PATH\")\n                                         .Split(';')\n                                         .Select(x => Path.Combine(x))\n                                         .FirstOrDefault(x => File.Exists(Path.Combine(x, \"legendary.exe\")));\n                if (string.IsNullOrWhiteSpace(envPath) == false)\n                {\n                    launcherPath = envPath;\n                }", "                if (string.IsNullOrWhiteSpace(envPath) == false)\n                {\n                    launcherPath = envPath;\n                }\n                else if (File.Exists(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),\n                                                  @\"Programs\\heroic\\resources\\app.asar.unpacked\\build\\bin\\win32\\legendary.exe\")))\n                {\n                    launcherPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),\n                                                @\"Programs\\heroic\\resources\\app.asar.unpacked\\build\\bin\\win32\\\");\n                }\n                else\n                {\n                    var pf64 = Environment.GetEnvironmentVariable(\"ProgramW6432\");", "                    if (string.IsNullOrEmpty(pf64))\n                    {\n                        pf64 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);\n                    }\n                    launcherPath = Path.Combine(pf64, \"Legendary\");\n                }\n                var savedSettings = LegendaryLibrary.GetSettings();\n                if (savedSettings != null)\n                {\n                    var savedLauncherPath = LegendaryLibrary.GetSettings().SelectedLauncherPath;\n                    if (savedLauncherPath != \"\" && Directory.Exists(savedLauncherPath) && LegendaryLibrary.GetSettings().UseCustomLauncherPath)\n                    {\n                        launcherPath = savedLauncherPath;\n                    }\n                }\n                return launcherPath;\n            }\n        }\n", "                    if (savedLauncherPath != \"\" && Directory.Exists(savedLauncherPath) && LegendaryLibrary.GetSettings().UseCustomLauncherPath)\n                    {\n                        launcherPath = savedLauncherPath;\n                    }\n                }\n                return launcherPath;\n            }\n        }\n\n        public static bool IsInstalled\n        {\n            get\n            {\n                var path = LauncherPath;\n                return !string.IsNullOrEmpty(path) && Directory.Exists(path);\n            }\n        }\n", "        public static bool IsInstalled\n        {\n            get\n            {\n                var path = LauncherPath;\n                return !string.IsNullOrEmpty(path) && Directory.Exists(path);\n            }\n        }\n\n        public static string DefaultGamesInstallationPath\n        {\n            get\n            {\n                var installPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \"Games\");", "        public static string DefaultGamesInstallationPath\n        {\n            get\n            {\n                var installPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), \"Games\");\n                if (IniConfig != null && !IniConfig[\"Legendary\"][\"install_dir\"].IsNullOrEmpty())\n                {\n                    var newInstallPath = \"\";\n                    bool installPathIsValid = true;\n                    try\n                    {\n                        newInstallPath = Path.GetFullPath(IniConfig[\"Legendary\"][\"install_dir\"]);\n                    }\n                    catch\n                    {\n                        installPathIsValid = false;\n                    }", "                    if (installPathIsValid)\n                    {\n                        installPath = newInstallPath;\n                    }\n                }\n                return installPath;\n            }\n        }\n\n        public static bool IsEOSOverlayInstalled\n        {\n            get\n            {\n                var installed = false;\n                var overlayInfoFile = Path.Combine(ConfigPath, \"overlay_install.json\");", "        public static bool IsEOSOverlayInstalled\n        {\n            get\n            {\n                var installed = false;\n                var overlayInfoFile = Path.Combine(ConfigPath, \"overlay_install.json\");\n                if (File.Exists(overlayInfoFile))\n                {\n                    installed = true;\n                }\n                return installed;\n            }\n        }\n", "        public static bool IsEOSOverlayEnabled\n        {\n            get\n            {\n                bool enabled = false;\n                RegistryKey key = Registry.CurrentUser.OpenSubKey(@\"SOFTWARE\\Epic Games\\EOS\");\n                if (key?.GetValueNames().Contains(\"OverlayPath\") == true)\n                {\n                    enabled = true;\n                }\n                return enabled;\n            }\n        }\n", "        public static string Icon => Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), @\"Resources\\legendary_icon.ico\");\n\n        public static void StartClient()\n        {\n            ProcessStarter.StartProcess(ClientExecPath);\n        }\n\n        internal static string GetExecutablePath(string rootPath)\n        {\n            return Path.Combine(rootPath, \"legendary.exe\");\n        }\n", "        public static Dictionary<string, Installed> GetInstalledAppList()\n        {\n            var installListPath = Path.Combine(ConfigPath, \"installed.json\");\n            if (!File.Exists(installListPath))\n            {\n                return new Dictionary<string, Installed>();\n            }\n\n            var list = Serialization.FromJson<Dictionary<string, Installed>>(FileSystem.ReadFileAsStringSafe(installListPath));\n            return list;\n        }\n", "        public static string TokensPath\n        {\n            get\n            {\n                return Path.Combine(ConfigPath, \"user.json\");\n            }\n        }\n\n        public static IniData IniConfig\n        {\n            get\n            {\n                var configIniPath = Path.Combine(ConfigPath, \"config.ini\");\n                IniData data = null;", "        public static IniData IniConfig\n        {\n            get\n            {\n                var configIniPath = Path.Combine(ConfigPath, \"config.ini\");\n                IniData data = null;\n                if (File.Exists(configIniPath))\n                {\n                    var parser = new FileIniDataParser();\n                    data = parser.ReadFile(Path.Combine(ConfigPath, \"config.ini\"));\n                }\n                return data;\n            }\n        }\n", "        public static string DefaultPreferredCDN\n        {\n            get\n            {\n                var cdn = \"\";\n                if (IniConfig != null && !IniConfig[\"Legendary\"][\"preferred_cdn\"].IsNullOrEmpty())\n                {\n                    cdn = IniConfig[\"Legendary\"][\"preferred_cdn\"];\n                }\n                return cdn;\n            }\n        }\n", "        public static bool DefaultNoHttps\n        {\n            get\n            {\n                bool noHttps = false;\n                if (IniConfig != null && !IniConfig[\"Legendary\"][\"disable_https\"].IsNullOrEmpty())\n                {\n                    noHttps = Convert.ToBoolean(IniConfig[\"Legendary\"][\"disable_https\"]);\n                }\n                return noHttps;\n            }\n        }\n", "        public static int DefaultMaxWorkers\n        {\n            get\n            {\n                int maxWorkers = 0;\n                if (IniConfig != null && !IniConfig[\"Legendary\"][\"max_workers\"].IsNullOrEmpty())\n                {\n                    maxWorkers = Convert.ToInt32(IniConfig[\"Legendary\"][\"max_workers\"]);\n                }\n                return maxWorkers;\n            }\n        }\n", "        public static int DefaultMaxSharedMemory\n        {\n            get\n            {\n                int maxSharedMemory = 0;\n                if (IniConfig != null && !IniConfig[\"Legendary\"][\"max_memory\"].IsNullOrEmpty())\n                {\n                    maxSharedMemory = Convert.ToInt32(IniConfig[\"Legendary\"][\"max_memory\"]);\n                }\n                return maxSharedMemory;\n            }\n        }\n    }\n}\n"]}
{"filename": "src/LocalizationKeys.cs", "chunked_list": ["///\n/// DO NOT MODIFY! Automatically generated via update_localization_keys.py script.\n///\nnamespace System\n{\n    public static class LOC\n    {\n        /// <summary>\n        /// Import installed games\n        /// </summary>\n        public const string EpicSettingsImportInstalledLabel = \"LOCEpicSettingsImportInstalledLabel\";\n        /// <summary>\n        /// Import not installed games\n        /// </summary>", "        public const string EpicSettingsImportInstalledLabel = \"LOCEpicSettingsImportInstalledLabel\";\n        /// <summary>\n        /// Import not installed games\n        /// </summary>\n        public const string EpicSettingsImportUninstalledLabel = \"LOCEpicSettingsImportUninstalledLabel\";\n        /// <summary>\n        /// Connect account\n        /// </summary>\n        public const string EpicSettingsConnectAccount = \"LOCEpicSettingsConnectAccount\";\n        /// <summary>\n        /// Checking authentication status\u2026\n        /// </summary>", "        public const string EpicSettingsConnectAccount = \"LOCEpicSettingsConnectAccount\";\n        /// <summary>\n        /// Checking authentication status\u2026\n        /// </summary>\n        public const string EpicLoginChecking = \"LOCEpicLoginChecking\";\n        /// <summary>\n        /// User is authenticated\n        /// </summary>\n        public const string EpicLoggedIn = \"LOCEpicLoggedIn\";\n        /// <summary>\n        /// Requires authentication\n        /// </summary>", "        public const string EpicLoggedIn = \"LOCEpicLoggedIn\";\n        /// <summary>\n        /// Requires authentication\n        /// </summary>\n        public const string EpicNotLoggedIn = \"LOCEpicNotLoggedIn\";\n        /// <summary>\n        /// Failed to authenticate user.\n        /// </summary>\n        public const string EpicNotLoggedInError = \"LOCEpicNotLoggedInError\";\n        /// <summary>\n        /// Authenticate\n        /// </summary>", "        public const string EpicNotLoggedInError = \"LOCEpicNotLoggedInError\";\n        /// <summary>\n        /// Authenticate\n        /// </summary>\n        public const string EpicAuthenticateLabel = \"LOCEpicAuthenticateLabel\";\n        /// <summary>\n        /// Start games directly without running official client\n        /// </summary>\n        public const string EpicSettingsStartGameDirectly = \"LOCEpicSettingsStartGameDirectly\";\n        /// <summary>\n        /// Troubleshooting account sync issues\n        /// </summary>", "        public const string EpicSettingsStartGameDirectly = \"LOCEpicSettingsStartGameDirectly\";\n        /// <summary>\n        /// Troubleshooting account sync issues\n        /// </summary>\n        public const string EpicTroubleShootingAccountLink = \"LOCEpicTroubleShootingAccountLink\";\n        /// <summary>\n        /// Troubleshooting issues\n        /// </summary>\n        public const string EpicTroubleShootingIssues = \"LOCEpicTroubleShootingIssues\";\n        /// <summary>\n        /// Import all games\n        /// </summary>", "        public const string EpicTroubleShootingIssues = \"LOCEpicTroubleShootingIssues\";\n        /// <summary>\n        /// Import all games\n        /// </summary>\n        public const string EpicSettingsImportLibraryLabel = \"LOCEpicSettingsImportLibraryLabel\";\n        /// <summary>\n        /// Private Account\n        /// </summary>\n        public const string EpicPrivateAccount = \"LOCEpicPrivateAccount\";\n        /// <summary>\n        /// Public Account\n        /// </summary>", "        public const string EpicPrivateAccount = \"LOCEpicPrivateAccount\";\n        /// <summary>\n        /// Public Account\n        /// </summary>\n        public const string EpicPublicAccount = \"LOCEpicPublicAccount\";\n        /// <summary>\n        /// API Key\n        /// </summary>\n        public const string EpicAPIKey = \"LOCEpicAPIKey\";\n        /// <summary>\n        /// Start using {0} client\n        /// </summary>", "        public const string EpicAPIKey = \"LOCEpicAPIKey\";\n        /// <summary>\n        /// Start using {0} client\n        /// </summary>\n        public const string EpicStartUsingClient = \"LOCEpicStartUsingClient\";\n        /// <summary>\n        /// Import play time\n        /// </summary>\n        public const string EpicImportPlaytime = \"LOCEpicImportPlaytime\";\n        /// <summary>\n        /// Account ID\n        /// </summary>", "        public const string EpicImportPlaytime = \"LOCEpicImportPlaytime\";\n        /// <summary>\n        /// Account ID\n        /// </summary>\n        public const string EpicAccountID = \"LOCEpicAccountID\";\n        /// <summary>\n        /// Metadata language:\n        /// </summary>\n        public const string EpicMetadataLanguageLabel = \"LOCEpicMetadataLanguageLabel\";\n        /// <summary>\n        /// Use custom launcher path\n        /// </summary>", "        public const string EpicMetadataLanguageLabel = \"LOCEpicMetadataLanguageLabel\";\n        /// <summary>\n        /// Use custom launcher path\n        /// </summary>\n        public const string LegendaryLauncherCustomPath = \"LOCLegendaryLauncherCustomPath\";\n        /// <summary>\n        /// Games Installation Path\n        /// </summary>\n        public const string LegendaryGamesInstallationPath = \"LOCLegendaryGamesInstallationPath\";\n        /// <summary>\n        /// Download Size:\n        /// </summary>", "        public const string LegendaryGamesInstallationPath = \"LOCLegendaryGamesInstallationPath\";\n        /// <summary>\n        /// Download Size:\n        /// </summary>\n        public const string LegendaryDownloadSize = \"LOCLegendaryDownloadSize\";\n        /// <summary>\n        /// Install Size:\n        /// </summary>\n        public const string LegendaryInstallSize = \"LOCLegendaryInstallSize\";\n        /// <summary>\n        /// Are you sure you want to uninstall {0}?\n        /// </summary>", "        public const string LegendaryInstallSize = \"LOCLegendaryInstallSize\";\n        /// <summary>\n        /// Are you sure you want to uninstall {0}?\n        /// </summary>\n        public const string LegendaryUninstallGameConfirm = \"LOCLegendaryUninstallGameConfirm\";\n        /// <summary>\n        /// Launch games in offline mode if possible\n        /// </summary>\n        public const string LegendaryLaunchOffline = \"LOCLegendaryLaunchOffline\";\n        /// <summary>\n        /// Exclude games\n        /// </summary>", "        public const string LegendaryLaunchOffline = \"LOCLegendaryLaunchOffline\";\n        /// <summary>\n        /// Exclude games\n        /// </summary>\n        public const string LegendaryExcludeGames = \"LOCLegendaryExcludeGames\";\n        /// <summary>\n        /// Offline games\n        /// </summary>\n        public const string LegendaryOfflineGames = \"LOCLegendaryOfflineGames\";\n        /// <summary>\n        /// Online games\n        /// </summary>", "        public const string LegendaryOfflineGames = \"LOCLegendaryOfflineGames\";\n        /// <summary>\n        /// Online games\n        /// </summary>\n        public const string LegendaryOnlineGames = \"LOCLegendaryOnlineGames\";\n        /// <summary>\n        /// Download Settings\n        /// </summary>\n        public const string LegendaryDownloadSettings = \"LOCLegendaryDownloadSettings\";\n        /// <summary>\n        /// Preferred CDN\n        /// </summary>", "        public const string LegendaryDownloadSettings = \"LOCLegendaryDownloadSettings\";\n        /// <summary>\n        /// Preferred CDN\n        /// </summary>\n        public const string LegendaryPreferredCDN = \"LOCLegendaryPreferredCDN\";\n        /// <summary>\n        /// Disable HTTPS (useful for CDNs e.g. LanCache)\n        /// </summary>\n        public const string LegendaryHttpOnlyDownload = \"LOCLegendaryHttpOnlyDownload\";\n        /// <summary>\n        /// EOS Overlay\n        /// </summary>", "        public const string LegendaryHttpOnlyDownload = \"LOCLegendaryHttpOnlyDownload\";\n        /// <summary>\n        /// EOS Overlay\n        /// </summary>\n        public const string LegendaryEOSOverlay = \"LOCLegendaryEOSOverlay\";\n        /// <summary>\n        /// Disable\n        /// </summary>\n        public const string LegendaryDisable = \"LOCLegendaryDisable\";\n        /// <summary>\n        /// Enable\n        /// </summary>", "        public const string LegendaryDisable = \"LOCLegendaryDisable\";\n        /// <summary>\n        /// Enable\n        /// </summary>\n        public const string LegendaryEnable = \"LOCLegendaryEnable\";\n        /// <summary>\n        /// Import game\n        /// </summary>\n        public const string LegendaryImportEGL = \"LOCLegendaryImportEGL\";\n        /// <summary>\n        /// Space Available:\n        /// </summary>", "        public const string LegendaryImportEGL = \"LOCLegendaryImportEGL\";\n        /// <summary>\n        /// Space Available:\n        /// </summary>\n        public const string LegendarySpaceAvailable = \"LOCLegendarySpaceAvailable\";\n        /// <summary>\n        /// Downloaded:\n        /// </summary>\n        public const string LegendaryDownloaded = \"LOCLegendaryDownloaded\";\n        /// <summary>\n        /// ETA:\n        /// </summary>", "        public const string LegendaryDownloaded = \"LOCLegendaryDownloaded\";\n        /// <summary>\n        /// ETA:\n        /// </summary>\n        public const string LegendaryETA = \"LOCLegendaryETA\";\n        /// <summary>\n        /// Download Speed:\n        /// </summary>\n        public const string LegendaryDownloadSpeed = \"LOCLegendaryDownloadSpeed\";\n        /// <summary>\n        /// Elapsed:\n        /// </summary>", "        public const string LegendaryDownloadSpeed = \"LOCLegendaryDownloadSpeed\";\n        /// <summary>\n        /// Elapsed:\n        /// </summary>\n        public const string LegendaryElapsed = \"LOCLegendaryElapsed\";\n        /// <summary>\n        /// Pause\n        /// </summary>\n        public const string LegendaryPauseDownload = \"LOCLegendaryPauseDownload\";\n        /// <summary>\n        /// Resume\n        /// </summary>", "        public const string LegendaryPauseDownload = \"LOCLegendaryPauseDownload\";\n        /// <summary>\n        /// Resume\n        /// </summary>\n        public const string LegendaryResumeDownload = \"LOCLegendaryResumeDownload\";\n        /// <summary>\n        /// Paused\n        /// </summary>\n        public const string LegendaryDownloadPaused = \"LOCLegendaryDownloadPaused\";\n        /// <summary>\n        /// Installation finished. Have fun.\n        /// </summary>", "        public const string LegendaryDownloadPaused = \"LOCLegendaryDownloadPaused\";\n        /// <summary>\n        /// Installation finished. Have fun.\n        /// </summary>\n        public const string LegendaryInstallationFinished = \"LOCLegendaryInstallationFinished\";\n        /// <summary>\n        /// After download is complete:\n        /// </summary>\n        public const string LegendaryAfterDownloadComplete = \"LOCLegendaryAfterDownloadComplete\";\n        /// <summary>\n        /// Sync game saves to the cloud\n        /// </summary>", "        public const string LegendaryAfterDownloadComplete = \"LOCLegendaryAfterDownloadComplete\";\n        /// <summary>\n        /// Sync game saves to the cloud\n        /// </summary>\n        public const string LegendarySyncGameSaves = \"LOCLegendarySyncGameSaves\";\n        /// <summary>\n        /// Syncing {0} game saves to the cloud...\n        /// </summary>\n        public const string LegendarySyncing = \"LOCLegendarySyncing\";\n        /// <summary>\n        /// An error occurred while syncing {0} game saves to the cloud.\n        /// </summary>", "        public const string LegendarySyncing = \"LOCLegendarySyncing\";\n        /// <summary>\n        /// An error occurred while syncing {0} game saves to the cloud.\n        /// </summary>\n        public const string LegendarySyncError = \"LOCLegendarySyncError\";\n        /// <summary>\n        /// Importing {0}...\n        /// </summary>\n        public const string LegendaryImportingGame = \"LOCLegendaryImportingGame\";\n        /// <summary>\n        /// Import finished. Have fun.\n        /// </summary>", "        public const string LegendaryImportingGame = \"LOCLegendaryImportingGame\";\n        /// <summary>\n        /// Import finished. Have fun.\n        /// </summary>\n        public const string LegendaryImportFinished = \"LOCLegendaryImportFinished\";\n        /// <summary>\n        /// Maximum number of worker processes\n        /// </summary>\n        public const string LegendaryMaxWorkers = \"LOCLegendaryMaxWorkers\";\n        /// <summary>\n        /// Maximum amount of shared memory (MB)\n        /// </summary>", "        public const string LegendaryMaxWorkers = \"LOCLegendaryMaxWorkers\";\n        /// <summary>\n        /// Maximum amount of shared memory (MB)\n        /// </summary>\n        public const string LegendaryMaxSharedMemory = \"LOCLegendaryMaxSharedMemory\";\n        /// <summary>\n        /// Download Manager\n        /// </summary>\n        public const string LegendaryDownloadManager = \"LOCLegendaryDownloadManager\";\n        /// <summary>\n        /// Status\n        /// </summary>", "        public const string LegendaryDownloadManager = \"LOCLegendaryDownloadManager\";\n        /// <summary>\n        /// Status\n        /// </summary>\n        public const string LegendaryDownloadStatus = \"LOCLegendaryDownloadStatus\";\n        /// <summary>\n        /// Completed\n        /// </summary>\n        public const string LegendaryDownloadCompletedColumn = \"LOCLegendaryDownloadCompletedColumn\";\n        /// <summary>\n        /// Queued\n        /// </summary>", "        public const string LegendaryDownloadCompletedColumn = \"LOCLegendaryDownloadCompletedColumn\";\n        /// <summary>\n        /// Queued\n        /// </summary>\n        public const string LegendaryDownloadQueued = \"LOCLegendaryDownloadQueued\";\n        /// <summary>\n        /// Running\n        /// </summary>\n        public const string LegendaryDownloadRunning = \"LOCLegendaryDownloadRunning\";\n        /// <summary>\n        /// Canceled\n        /// </summary>", "        public const string LegendaryDownloadRunning = \"LOCLegendaryDownloadRunning\";\n        /// <summary>\n        /// Canceled\n        /// </summary>\n        public const string LegendaryDownloadCanceled = \"LOCLegendaryDownloadCanceled\";\n        /// <summary>\n        /// Completed\n        /// </summary>\n        public const string LegendaryDownloadCompleted = \"LOCLegendaryDownloadCompleted\";\n        /// <summary>\n        /// Summary of the current download\n        /// </summary>", "        public const string LegendaryDownloadCompleted = \"LOCLegendaryDownloadCompleted\";\n        /// <summary>\n        /// Summary of the current download\n        /// </summary>\n        public const string LegendaryCurrentDownloadSummary = \"LOCLegendaryCurrentDownloadSummary\";\n        /// <summary>\n        /// Remove entry\n        /// </summary>\n        public const string LegendaryRemoveEntry = \"LOCLegendaryRemoveEntry\";\n        /// <summary>\n        /// Are you sure you want to remove {0} from list?\n        /// </summary>", "        public const string LegendaryRemoveEntry = \"LOCLegendaryRemoveEntry\";\n        /// <summary>\n        /// Are you sure you want to remove {0} from list?\n        /// </summary>\n        public const string LegendaryRemoveEntryConfirm = \"LOCLegendaryRemoveEntryConfirm\";\n        /// <summary>\n        /// Download Size\n        /// </summary>\n        public const string LegendaryDownloadSizeColumn = \"LOCLegendaryDownloadSizeColumn\";\n        /// <summary>\n        /// The download will start soon. You can see its status by accessing Legendary Panel via Menu => View or sidebar.\n        /// </summary>", "        public const string LegendaryDownloadSizeColumn = \"LOCLegendaryDownloadSizeColumn\";\n        /// <summary>\n        /// The download will start soon. You can see its status by accessing Legendary Panel via Menu => View or sidebar.\n        /// </summary>\n        public const string LegendaryDownloadManagerWhatsUp = \"LOCLegendaryDownloadManagerWhatsUp\";\n        /// <summary>\n        /// Legendary Panel\n        /// </summary>\n        public const string LegendaryPanel = \"LOCLegendaryPanel\";\n        /// <summary>\n        /// {0} is already in the download list. You can see status of the download by accessing Legendary Panel via Menu => View or sidebar.\n        /// </summary>", "        public const string LegendaryPanel = \"LOCLegendaryPanel\";\n        /// <summary>\n        /// {0} is already in the download list. You can see status of the download by accessing Legendary Panel via Menu => View or sidebar.\n        /// </summary>\n        public const string LegendaryDownloadAlreadyExists = \"LOCLegendaryDownloadAlreadyExists\";\n        /// <summary>\n        /// Repair\n        /// </summary>\n        public const string LegendaryRepair = \"LOCLegendaryRepair\";\n        /// <summary>\n        /// Advanced Options\n        /// </summary>", "        public const string LegendaryRepair = \"LOCLegendaryRepair\";\n        /// <summary>\n        /// Advanced Options\n        /// </summary>\n        public const string LegendaryAdvancedOptions = \"LOCLegendaryAdvancedOptions\";\n        /// <summary>\n        /// Enable reordering optimization\n        /// </summary>\n        public const string LegendaryEnableReordering = \"LOCLegendaryEnableReordering\";\n        /// <summary>\n        /// Extra Content\n        /// </summary>", "        public const string LegendaryEnableReordering = \"LOCLegendaryEnableReordering\";\n        /// <summary>\n        /// Extra Content\n        /// </summary>\n        public const string LegendaryExtraContent = \"LOCLegendaryExtraContent\";\n        /// <summary>\n        /// Cache\n        /// </summary>\n        public const string LegendaryCache = \"LOCLegendaryCache\";\n        /// <summary>\n        /// Clear cache\n        /// </summary>", "        public const string LegendaryCache = \"LOCLegendaryCache\";\n        /// <summary>\n        /// Clear cache\n        /// </summary>\n        public const string LegendaryClearCache = \"LOCLegendaryClearCache\";\n        /// <summary>\n        /// Automatically clear cache\n        /// </summary>\n        public const string LegendaryAutoClearCache = \"LOCLegendaryAutoClearCache\";\n        /// <summary>\n        /// Once a month\n        /// </summary>", "        public const string LegendaryAutoClearCache = \"LOCLegendaryAutoClearCache\";\n        /// <summary>\n        /// Once a month\n        /// </summary>\n        public const string LegendaryOnceAMonth = \"LOCLegendaryOnceAMonth\";\n        /// <summary>\n        /// Once every 3 months\n        /// </summary>\n        public const string LegendaryOnceEvery3Months = \"LOCLegendaryOnceEvery3Months\";\n        /// <summary>\n        /// Once every 6 months\n        /// </summary>", "        public const string LegendaryOnceEvery3Months = \"LOCLegendaryOnceEvery3Months\";\n        /// <summary>\n        /// Once every 6 months\n        /// </summary>\n        public const string LegendaryOnceEvery6Months = \"LOCLegendaryOnceEvery6Months\";\n        /// <summary>\n        /// Are you sure you want to clear cache?\n        /// </summary>\n        public const string LegendaryClearCacheConfirm = \"LOCLegendaryClearCacheConfirm\";\n        /// <summary>\n        /// Check the log files for more information.\n        /// </summary>", "        public const string LegendaryClearCacheConfirm = \"LOCLegendaryClearCacheConfirm\";\n        /// <summary>\n        /// Check the log files for more information.\n        /// </summary>\n        public const string LegendaryCheckLog = \"LOCLegendaryCheckLog\";\n        /// <summary>\n        /// Cloud saves feature is experimental. It's recommended to backup game saves in case something goes wrong.\n        /// </summary>\n        public const string LegendarySyncGameSavesWarn = \"LOCLegendarySyncGameSavesWarn\";\n        /// <summary>\n        /// Current shared memory cache is smaller than required: {0} < {1}. Try to enable reordering optimization to reduce memory usage or increase maximum amount of shared memory.\n        /// </summary>", "        public const string LegendarySyncGameSavesWarn = \"LOCLegendarySyncGameSavesWarn\";\n        /// <summary>\n        /// Current shared memory cache is smaller than required: {0} < {1}. Try to enable reordering optimization to reduce memory usage or increase maximum amount of shared memory.\n        /// </summary>\n        public const string LegendaryMemoryError = \"LOCLegendaryMemoryError\";\n        /// <summary>\n        /// Edit entry properties\n        /// </summary>\n        public const string LegendaryEditSelectedDownloadProperties = \"LOCLegendaryEditSelectedDownloadProperties\";\n        /// <summary>\n        /// Task\n        /// </summary>", "        public const string LegendaryEditSelectedDownloadProperties = \"LOCLegendaryEditSelectedDownloadProperties\";\n        /// <summary>\n        /// Task\n        /// </summary>\n        public const string LegendaryTask = \"LOCLegendaryTask\";\n        /// <summary>\n        /// Download Properties\n        /// </summary>\n        public const string LegendaryDownloadProperties = \"LOCLegendaryDownloadProperties\";\n        /// <summary>\n        /// Migrate all games from Epic plugin\n        /// </summary>", "        public const string LegendaryDownloadProperties = \"LOCLegendaryDownloadProperties\";\n        /// <summary>\n        /// Migrate all games from Epic plugin\n        /// </summary>\n        public const string LegendaryMigrateGamesEpic = \"LOCLegendaryMigrateGamesEpic\";\n        /// <summary>\n        /// Migrating all games from Epic plugin...\n        /// </summary>\n        public const string LegendaryMigratingGamesEpic = \"LOCLegendaryMigratingGamesEpic\";\n        /// <summary>\n        /// Migration completed successfully.\n        /// </summary>", "        public const string LegendaryMigratingGamesEpic = \"LOCLegendaryMigratingGamesEpic\";\n        /// <summary>\n        /// Migration completed successfully.\n        /// </summary>\n        public const string LegendaryMigrationCompleted = \"LOCLegendaryMigrationCompleted\";\n        /// <summary>\n        /// No games found for migration.\n        /// </summary>\n        public const string LegendaryMigrationNoGames = \"LOCLegendaryMigrationNoGames\";\n        /// <summary>\n        /// All games will be removed from Epic plugin and moved to Legendary. Are you sure you want to do this?\n        /// </summary>", "        public const string LegendaryMigrationNoGames = \"LOCLegendaryMigrationNoGames\";\n        /// <summary>\n        /// All games will be removed from Epic plugin and moved to Legendary. Are you sure you want to do this?\n        /// </summary>\n        public const string LegendaryMigrationConfirm = \"LOCLegendaryMigrationConfirm\";\n    }\n}\n"]}
{"filename": "src/LegendaryGameController.cs", "chunked_list": ["\ufeffusing CliWrap;\nusing CliWrap.Buffered;\nusing LegendaryLibraryNS.Models;\nusing Playnite;\nusing Playnite.Common;\nusing Playnite.SDK;\nusing Playnite.SDK.Models;\nusing Playnite.SDK.Plugins;\nusing System;\nusing System.Collections.Generic;", "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Windows;\n", "using System.Windows;\n\nnamespace LegendaryLibraryNS\n{\n    public class LegendaryInstallController : InstallController\n    {\n        private IPlayniteAPI playniteAPI = API.Instance;\n\n        public LegendaryInstallController(Game game) : base(game)\n        {\n            Name = \"Install using Legendary client\";\n        }\n", "        public override void Install(InstallActionArgs args)\n        {\n            if (!LegendaryLauncher.IsInstalled)\n            {\n                throw new Exception(\"Legendary Launcher is not installed.\");\n            }\n\n            Window window = null;\n            if (playniteAPI.ApplicationInfo.Mode == ApplicationMode.Desktop)\n            {\n                window = playniteAPI.Dialogs.CreateWindow(new WindowCreationOptions\n                {\n                    ShowMaximizeButton = false,\n                });\n            }\n            else\n            {\n                window = new Window\n                {\n                    Background = System.Windows.Media.Brushes.DodgerBlue\n                };\n            }\n            window.Title = Game.Name;\n            var installProperties = new DownloadProperties { downloadAction = (int)Enums.DownloadAction.Install };\n            var installData = new DownloadManagerData.Download { gameID = Game.GameId, downloadProperties = installProperties };\n            window.DataContext = installData;\n            window.Content = new LegendaryGameInstaller();\n            window.Owner = playniteAPI.Dialogs.GetCurrentAppWindow();\n            window.SizeToContent = SizeToContent.WidthAndHeight;\n            window.MinWidth = 600;\n            window.WindowStartupLocation = WindowStartupLocation.CenterOwner;\n            var result = window.ShowDialog();", "            if (playniteAPI.ApplicationInfo.Mode == ApplicationMode.Desktop)\n            {\n                window = playniteAPI.Dialogs.CreateWindow(new WindowCreationOptions\n                {\n                    ShowMaximizeButton = false,\n                });\n            }\n            else\n            {\n                window = new Window\n                {\n                    Background = System.Windows.Media.Brushes.DodgerBlue\n                };\n            }\n            window.Title = Game.Name;\n            var installProperties = new DownloadProperties { downloadAction = (int)Enums.DownloadAction.Install };\n            var installData = new DownloadManagerData.Download { gameID = Game.GameId, downloadProperties = installProperties };\n            window.DataContext = installData;\n            window.Content = new LegendaryGameInstaller();\n            window.Owner = playniteAPI.Dialogs.GetCurrentAppWindow();\n            window.SizeToContent = SizeToContent.WidthAndHeight;\n            window.MinWidth = 600;\n            window.WindowStartupLocation = WindowStartupLocation.CenterOwner;\n            var result = window.ShowDialog();", "            if (result == false)\n            {\n                Game.IsInstalling = false;\n            }\n            else\n            {\n                _ = (Application.Current.Dispatcher?.BeginInvoke((Action)delegate\n                {\n                    var installed = LegendaryLauncher.GetInstalledAppList();\n                    if (installed != null)\n                    {", "                    if (installed != null)\n                    {\n                        foreach (KeyValuePair<string, Installed> app in installed)\n                        {\n                            if (app.Value.App_name == Game.GameId)\n                            {\n                                var installInfo = new GameInstallationData\n                                {\n                                    InstallDirectory = app.Value.Install_path\n                                };\n\n                                InvokeOnInstalled(new GameInstalledEventArgs(installInfo));\n                                return;\n                            }\n                        }\n                    }\n                }));\n            }\n\n        }\n    }\n", "    public class LegendaryUninstallController : UninstallController\n    {\n        private IPlayniteAPI playniteAPI = API.Instance;\n        private static readonly ILogger logger = LogManager.GetLogger();\n\n        public LegendaryUninstallController(Game game) : base(game)\n        {\n            Name = \"Uninstall\";\n        }\n\n        public override async void Uninstall(UninstallActionArgs args)\n        {", "        public override async void Uninstall(UninstallActionArgs args)\n        {\n            if (!LegendaryLauncher.IsInstalled)\n            {\n                throw new Exception(\"Legendary Launcher is not installed.\");\n            }\n\n            Dispose();\n            var result = playniteAPI.Dialogs.ShowMessage(\n                string.Format(ResourceProvider.GetString(LOC.LegendaryUninstallGameConfirm), Game.Name),\n                ResourceProvider.GetString(\"LOCUninstallGame\"),\n                MessageBoxButton.YesNo, MessageBoxImage.Question);", "            if (result == MessageBoxResult.No)\n            {\n                Game.IsUninstalling = false;\n            }\n            else\n            {\n                var cmd = await Cli.Wrap(LegendaryLauncher.ClientExecPath)\n                                   .WithArguments(new[] { \"-y\", \"uninstall\", Game.GameId })\n                                   .WithValidation(CommandResultValidation.None)\n                                   .ExecuteBufferedAsync();\n                if (cmd.StandardError.Contains(\"has been uninstalled\"))\n                {\n                    InvokeOnUninstalled(new GameUninstalledEventArgs());\n                }\n                else\n                {\n                    logger.Debug(\"[Legendary] \" + cmd.StandardError);\n                    logger.Error(\"[Legendary] exit code: \" + cmd.ExitCode);\n                    Game.IsUninstalling = false;\n                }\n            }\n        }\n", "                if (cmd.StandardError.Contains(\"has been uninstalled\"))\n                {\n                    InvokeOnUninstalled(new GameUninstalledEventArgs());\n                }\n                else\n                {\n                    logger.Debug(\"[Legendary] \" + cmd.StandardError);\n                    logger.Error(\"[Legendary] exit code: \" + cmd.ExitCode);\n                    Game.IsUninstalling = false;\n                }\n            }\n        }\n", "        public Game GetGame()\n        {\n            return Game;\n        }\n    }\n\n    public class LegendaryPlayController : PlayController\n    {\n        private IPlayniteAPI playniteAPI = API.Instance;\n        private static ILogger logger = LogManager.GetLogger();\n        private ProcessMonitor procMon;", "        private IPlayniteAPI playniteAPI = API.Instance;\n        private static ILogger logger = LogManager.GetLogger();\n        private ProcessMonitor procMon;\n        private Stopwatch stopWatch;\n\n        public LegendaryPlayController(Game game) : base(game)\n        {\n            Name = string.Format(ResourceProvider.GetString(LOC.EpicStartUsingClient), \"Legendary\");\n        }\n\n        public override void Dispose()\n        {\n            procMon?.Dispose();\n        }\n", "        public override void Dispose()\n        {\n            procMon?.Dispose();\n        }\n\n        public override async void Play(PlayActionArgs args)\n        {\n            Dispose();\n            if (Directory.Exists(Game.InstallDirectory))\n            {\n                var playArgs = new List<string>();\n                playArgs.AddRange(new[] { \"launch\", Game.GameId });", "            if (Directory.Exists(Game.InstallDirectory))\n            {\n                var playArgs = new List<string>();\n                playArgs.AddRange(new[] { \"launch\", Game.GameId });\n                if (LegendaryLibrary.GetSettings().LaunchOffline)\n                {\n                    bool canRunOffline = false;\n                    var appList = LegendaryLauncher.GetInstalledAppList();\n                    foreach (KeyValuePair<string, Installed> d in appList)\n                    {\n                        var app = d.Value;", "                    foreach (KeyValuePair<string, Installed> d in appList)\n                    {\n                        var app = d.Value;\n                        if (app.App_name == Game.GameId)\n                        {\n                            if (app.Can_run_offline && !LegendaryLibrary.GetSettings().OnlineList.Contains(app.App_name))\n                            {\n                                canRunOffline = true;\n                            }\n                            break;\n                        }\n                    }", "                    if (LegendaryLibrary.GetSettings().LaunchOffline && canRunOffline)\n                    {\n                        playArgs.Add(\"--offline\");\n                    }\n                }\n                var cmd = await Cli.Wrap(LegendaryLauncher.ClientExecPath)\n                                   .WithArguments(playArgs)\n                                   .WithValidation(CommandResultValidation.None)\n                                   .ExecuteBufferedAsync();\n                if (cmd.ExitCode != 0)\n                {\n                    InvokeOnStopped(new GameStoppedEventArgs());\n                    logger.Error(\"[Legendary] \" + cmd.StandardError);", "                if (cmd.ExitCode != 0)\n                {\n                    InvokeOnStopped(new GameStoppedEventArgs());\n                    logger.Error(\"[Legendary] \" + cmd.StandardError);\n                    if (cmd.StandardError.Contains(\"login failed\"))\n                    {\n                        playniteAPI.Dialogs.ShowErrorMessage(string.Format(ResourceProvider.GetString(\"LOCGameStartError\"), ResourceProvider.GetString(\"LOCLoginRequired\")));\n                    }\n                    else\n                    {\n                        playniteAPI.Dialogs.ShowErrorMessage(string.Format(ResourceProvider.GetString(\"LOCGameStartError\"), ResourceProvider.GetString(cmd.StandardError)));\n                    }\n                    return;\n                }\n                procMon = new ProcessMonitor();\n                procMon.TreeStarted += (_, treeArgs) =>\n                {\n                    stopWatch = Stopwatch.StartNew();\n                    InvokeOnStarted(new GameStartedEventArgs { StartedProcessId = treeArgs.StartedId });\n                };\n                procMon.TreeDestroyed += (_, __) =>\n                {\n                    stopWatch.Stop();\n                    InvokeOnStopped(new GameStoppedEventArgs { SessionLength = Convert.ToUInt64(stopWatch.Elapsed.TotalSeconds) });\n                };\n                procMon.WatchDirectoryProcesses(Game.InstallDirectory, false);\n            }\n            else\n            {\n                InvokeOnStopped(new GameStoppedEventArgs());\n            }\n        }\n    }\n}\n"]}
{"filename": "src/LegendaryGameInstaller.xaml.cs", "chunked_list": ["\ufeffusing CliWrap;\nusing CliWrap.Buffered;\nusing CliWrap.EventStream;\nusing LegendaryLibraryNS.Enums;\nusing LegendaryLibraryNS.Models;\nusing Playnite.Common;\nusing Playnite.SDK;\nusing Playnite.SDK.Data;\nusing Playnite.SDK.Plugins;\nusing System;", "using Playnite.SDK.Plugins;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Media;\nusing System.Net.Http;\nusing System.Runtime.InteropServices;", "using System.Net.Http;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Documents;", "using System.Windows.Data;\nusing System.Windows.Documents;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Imaging;\nusing System.Windows.Navigation;\n\nnamespace LegendaryLibraryNS\n{\n    /// <summary>", "{\n    /// <summary>\n    /// Interaction logic for LegendaryGameInstaller.xaml\n    /// </summary>\n    public partial class LegendaryGameInstaller : UserControl\n    {\n        private ILogger logger = LogManager.GetLogger();\n        private IPlayniteAPI playniteAPI = API.Instance;\n        public string installCommand;\n        public string downloadSize;\n        public string installSize;\n        public List<string> requiredThings;", "        public string installCommand;\n        public string downloadSize;\n        public string installSize;\n        public List<string> requiredThings;\n        public double downloadSizeNumber;\n        public double installSizeNumber;\n        private LegendaryGameInfo.Rootobject manifest;\n\n        public LegendaryGameInstaller()\n        {\n            InitializeComponent();\n            SetControlStyles();\n        }\n", "        public Window InstallerWindow => Window.GetWindow(this);\n\n        public DownloadManagerData.Download InstallData => (DownloadManagerData.Download)DataContext;\n        public string GameID => InstallData.gameID;\n\n        private void ChooseGamePathBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var path = playniteAPI.Dialogs.SelectFolder();\n            if (path != \"\")\n            {\n                SelectedGamePathTxt.Text = path;\n                UpdateSpaceInfo(path);\n            }\n        }\n", "            if (path != \"\")\n            {\n                SelectedGamePathTxt.Text = path;\n                UpdateSpaceInfo(path);\n            }\n        }\n\n        private void CancelBtn_Click(object sender, RoutedEventArgs e)\n        {\n            Window.GetWindow(this).Close();\n        }\n", "        private async void InstallBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var settings = LegendaryLibrary.GetSettings();\n            var installPath = settings.GamesInstallationPath;\n            if (SelectedGamePathTxt.Text != \"\")\n            {\n                installPath = SelectedGamePathTxt.Text;\n            }\n            if (GameID == \"eos-overlay\")\n            {\n                installPath = Path.Combine(SelectedGamePathTxt.Text, \".overlay\");\n            }\n            int maxWorkers = settings.MaxWorkers;", "            if (GameID == \"eos-overlay\")\n            {\n                installPath = Path.Combine(SelectedGamePathTxt.Text, \".overlay\");\n            }\n            int maxWorkers = settings.MaxWorkers;\n            if (MaxWorkersNI.Value != \"\")\n            {\n                maxWorkers = int.Parse(MaxWorkersNI.Value);\n            }\n            int maxSharedMemory = settings.MaxSharedMemory;\n            if (MaxSharedMemoryNI.Value != \"\")\n            {\n                maxSharedMemory = int.Parse(MaxSharedMemoryNI.Value);\n            }\n            bool enableReordering = Convert.ToBoolean(ReorderingChk.IsChecked);\n            var selectedExtraContent = new List<string>();", "            if (MaxSharedMemoryNI.Value != \"\")\n            {\n                maxSharedMemory = int.Parse(MaxSharedMemoryNI.Value);\n            }\n            bool enableReordering = Convert.ToBoolean(ReorderingChk.IsChecked);\n            var selectedExtraContent = new List<string>();\n            if (requiredThings.Count > 0)\n            {\n                selectedExtraContent.Add(\"\");\n                foreach (var requiredThing in requiredThings)\n                {\n                    selectedExtraContent.Add(requiredThing);\n                }\n            }", "                foreach (var requiredThing in requiredThings)\n                {\n                    selectedExtraContent.Add(requiredThing);\n                }\n            }\n            if (ExtraContentLB.Items.Count > 0)\n            {\n                selectedExtraContent.AddMissing(\"\");\n                foreach (var selectedOption in ExtraContentLB.SelectedItems.Cast<KeyValuePair<string, LegendarySDLInfo>>().ToList())\n                {\n                    foreach (var tag in selectedOption.Value.Tags)\n                    {\n                        selectedExtraContent.AddMissing(tag);\n                    }\n                }\n            }\n            InstallerWindow.Close();\n            LegendaryDownloadManager downloadManager = LegendaryLibrary.GetLegendaryDownloadManager();\n            var wantedItem = downloadManager.downloadManagerData.downloads.FirstOrDefault(item => item.gameID == GameID);", "                foreach (var selectedOption in ExtraContentLB.SelectedItems.Cast<KeyValuePair<string, LegendarySDLInfo>>().ToList())\n                {\n                    foreach (var tag in selectedOption.Value.Tags)\n                    {\n                        selectedExtraContent.AddMissing(tag);\n                    }\n                }\n            }\n            InstallerWindow.Close();\n            LegendaryDownloadManager downloadManager = LegendaryLibrary.GetLegendaryDownloadManager();\n            var wantedItem = downloadManager.downloadManagerData.downloads.FirstOrDefault(item => item.gameID == GameID);", "            if (wantedItem != null)\n            {\n                playniteAPI.Dialogs.ShowMessage(string.Format(ResourceProvider.GetString(LOC.LegendaryDownloadAlreadyExists), wantedItem.name), \"\", MessageBoxButton.OK, MessageBoxImage.Error);\n            }\n            else\n            {\n                var messagesSettings = LegendaryMessagesSettings.LoadSettings();\n                if (!messagesSettings.DontShowDownloadManagerWhatsUpMsg)\n                {\n                    var okResponse = new MessageBoxOption(\"LOCOKLabel\", true, true);\n                    var dontShowResponse = new MessageBoxOption(\"LOCDontShowAgainTitle\");\n                    var response = playniteAPI.Dialogs.ShowMessage(LOC.LegendaryDownloadManagerWhatsUp, \"\", MessageBoxImage.Information, new List<MessageBoxOption> { okResponse, dontShowResponse });", "                    if (response == dontShowResponse)\n                    {\n                        messagesSettings.DontShowDownloadManagerWhatsUpMsg = true;\n                        LegendaryMessagesSettings.SaveSettings(messagesSettings);\n                    }\n                }\n\n                DownloadProperties downloadProperties = new DownloadProperties()\n                {\n                    installPath = installPath,\n                    downloadAction = (int)DownloadAction.Install,\n                    enableReordering = enableReordering,\n                    maxWorkers = maxWorkers,\n                    maxSharedMemory = maxSharedMemory,\n                    extraContent = selectedExtraContent\n                };\n                await downloadManager.EnqueueJob(GameID, InstallerWindow.Title, downloadSize, installSize, downloadProperties);\n            }\n        }\n", "        private async void ImportBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var path = playniteAPI.Dialogs.SelectFolder();\n            if (path != \"\")\n            {\n                var importCmd = await Cli.Wrap(LegendaryLauncher.ClientExecPath)\n                                         .WithArguments(new[] { \"-y\", \"import\", GameID, path })\n                                         .WithValidation(CommandResultValidation.None)\n                                         .ExecuteBufferedAsync();\n                if (importCmd.StandardError.Contains(\"has been imported\"))\n                {\n                    InstallerWindow.DialogResult = true;\n                }\n                else\n                {\n                    logger.Debug(\"[Legendary] \" + importCmd.StandardError);\n                    logger.Error(\"[Legendary] exit code: \" + importCmd.ExitCode);\n                }\n                InstallerWindow.Close();\n            }\n        }\n", "                if (importCmd.StandardError.Contains(\"has been imported\"))\n                {\n                    InstallerWindow.DialogResult = true;\n                }\n                else\n                {\n                    logger.Debug(\"[Legendary] \" + importCmd.StandardError);\n                    logger.Error(\"[Legendary] exit code: \" + importCmd.ExitCode);\n                }\n                InstallerWindow.Close();\n            }\n        }\n", "        private async void LegendaryGameInstallerUC_Loaded(object sender, RoutedEventArgs e)\n        {\n            if (InstallData.downloadProperties.downloadAction == (int)DownloadAction.Repair)\n            {\n                FolderDP.Visibility = Visibility.Collapsed;\n                ImportBtn.Visibility = Visibility.Collapsed;\n                InstallBtn.Visibility = Visibility.Collapsed;\n                RepairBtn.Visibility = Visibility.Visible;\n            }\n            var settings = LegendaryLibrary.GetSettings();\n            SelectedGamePathTxt.Text = settings.GamesInstallationPath;\n            ReorderingChk.IsChecked = settings.EnableReordering;\n            MaxWorkersNI.Value = settings.MaxWorkers.ToString();\n            MaxSharedMemoryNI.Value = settings.MaxSharedMemory.ToString();", "            if (!SelectedGamePathTxt.Text.IsNullOrEmpty())\n            {\n                UpdateSpaceInfo(SelectedGamePathTxt.Text);\n            }\n            else\n            {\n                UpdateSpaceInfo(settings.GamesInstallationPath);\n            }\n            requiredThings = new List<string>();\n            var cacheInfoPath = LegendaryLibrary.Instance.GetCachePath(\"infocache\");\n            var cacheInfoFile = Path.Combine(cacheInfoPath, GameID + \".json\");", "            if (!Directory.Exists(cacheInfoPath))\n            {\n                Directory.CreateDirectory(cacheInfoPath);\n            }\n            if (GameID != \"eos-overlay\")\n            {\n                bool correctJson = false;\n                if (File.Exists(cacheInfoFile))\n                {\n                    if (File.GetLastWriteTime(cacheInfoFile) < DateTime.Now.AddDays(-7))\n                    {\n                        File.Delete(cacheInfoFile);\n                    }", "                    if (File.GetLastWriteTime(cacheInfoFile) < DateTime.Now.AddDays(-7))\n                    {\n                        File.Delete(cacheInfoFile);\n                    }\n                    if (Serialization.TryFromJson(FileSystem.ReadFileAsStringSafe(cacheInfoFile), out manifest))\n                    {\n                        if (manifest != null && manifest.Manifest != null)\n                        {\n                            correctJson = true;\n                        }\n                    }\n                }", "                if (!correctJson)\n                {\n                    var result = await Cli.Wrap(LegendaryLauncher.ClientExecPath)\n                                      .WithArguments(new[] { \"info\", GameID, \"--json\" })\n                                      .WithValidation(CommandResultValidation.None)\n                                      .ExecuteBufferedAsync();\n                    if (result.ExitCode != 0)\n                    {\n                        logger.Error(\"[Legendary]\" + result.StandardError);\n                        if (result.StandardError.Contains(\"Log in failed\"))\n                        {\n                            playniteAPI.Dialogs.ShowErrorMessage(string.Format(ResourceProvider.GetString(\"LOCGameInstallError\"), ResourceProvider.GetString(\"LOCLoginRequired\")));\n                        }\n                        else\n                        {\n                            playniteAPI.Dialogs.ShowErrorMessage(string.Format(ResourceProvider.GetString(\"LOCGameInstallError\"), ResourceProvider.GetString(LOC.LegendaryCheckLog)));\n                        }\n                        Window.GetWindow(this).Close();\n                        return;\n                    }\n                    else\n                    {\n                        File.WriteAllText(cacheInfoFile, result.StandardOutput);\n                        manifest = Serialization.FromJson<LegendaryGameInfo.Rootobject>(result.StandardOutput);\n                    }\n                }", "                        if (result.StandardError.Contains(\"Log in failed\"))\n                        {\n                            playniteAPI.Dialogs.ShowErrorMessage(string.Format(ResourceProvider.GetString(\"LOCGameInstallError\"), ResourceProvider.GetString(\"LOCLoginRequired\")));\n                        }\n                        else\n                        {\n                            playniteAPI.Dialogs.ShowErrorMessage(string.Format(ResourceProvider.GetString(\"LOCGameInstallError\"), ResourceProvider.GetString(LOC.LegendaryCheckLog)));\n                        }\n                        Window.GetWindow(this).Close();\n                        return;\n                    }\n                    else\n                    {\n                        File.WriteAllText(cacheInfoFile, result.StandardOutput);\n                        manifest = Serialization.FromJson<LegendaryGameInfo.Rootobject>(result.StandardOutput);\n                    }\n                }", "                if (manifest.Manifest.Install_tags.Length > 1)\n                {\n                    downloadSizeNumber = 0;\n                    installSizeNumber = 0;\n                    var cacheSDLPath = LegendaryLibrary.Instance.GetCachePath(\"sdlcache\");\n                    var cacheSDLFile = Path.Combine(cacheSDLPath, GameID + \".json\");\n                    string content = null;\n                    if (File.Exists(cacheSDLFile))\n                    {\n                        if (File.GetLastWriteTime(cacheSDLFile) < DateTime.Now.AddDays(-7))\n                        {\n                            File.Delete(cacheSDLFile);\n                        }\n                    }", "                        if (File.GetLastWriteTime(cacheSDLFile) < DateTime.Now.AddDays(-7))\n                        {\n                            File.Delete(cacheSDLFile);\n                        }\n                    }\n                    if (!File.Exists(cacheSDLFile))\n                    {\n                        var httpClient = new HttpClient();\n                        var response = await httpClient.GetAsync(\"https://api.legendary.gl/v1/sdl/\" + GameID + \".json\");\n                        if (response.IsSuccessStatusCode)\n                        {\n                            content = await response.Content.ReadAsStringAsync();", "                        if (response.IsSuccessStatusCode)\n                        {\n                            content = await response.Content.ReadAsStringAsync();\n                            if (!Directory.Exists(cacheSDLPath))\n                            {\n                                Directory.CreateDirectory(cacheSDLPath);\n                            }\n                            File.WriteAllText(cacheSDLFile, content);\n                        }\n                        httpClient.Dispose();\n                    }\n                    else\n                    {\n                        content = FileSystem.ReadFileAsStringSafe(cacheSDLFile);\n                    }", "                    if (content.IsNullOrEmpty())\n                    {\n                        logger.Error(\"An error occurred while downloading SDL data.\");\n                    }\n                    if (Serialization.TryFromJson<Dictionary<string, LegendarySDLInfo>>(content, out var sdlInfo))\n                    {\n                        if (sdlInfo.ContainsKey(\"__required\"))\n                        {\n                            foreach (var tag in sdlInfo[\"__required\"].Tags)\n                            {\n                                foreach (var tagDo in manifest.Manifest.Tag_download_size)\n                                {", "                            foreach (var tag in sdlInfo[\"__required\"].Tags)\n                            {\n                                foreach (var tagDo in manifest.Manifest.Tag_download_size)\n                                {\n                                    if (tagDo.Tag == tag)\n                                    {\n                                        downloadSizeNumber += tagDo.Size;\n                                        break;\n                                    }\n                                }\n                                foreach (var tagDi in manifest.Manifest.Tag_disk_size)\n                                {", "                                foreach (var tagDi in manifest.Manifest.Tag_disk_size)\n                                {\n                                    if (tagDi.Tag == tag)\n                                    {\n                                        installSizeNumber += tagDi.Size;\n                                        break;\n                                    }\n                                }\n                                requiredThings.Add(tag);\n                            }\n                            sdlInfo.Remove(\"__required\");\n                        }", "                        foreach (var tagDo in manifest.Manifest.Tag_download_size)\n                        {\n                            if (tagDo.Tag == \"\")\n                            {\n                                downloadSizeNumber += tagDo.Size;\n                                break;\n                            }\n                        }\n                        foreach (var tagDi in manifest.Manifest.Tag_disk_size)\n                        {\n                            if (tagDi.Tag == \"\")\n                            {\n                                installSizeNumber += tagDi.Size;\n                                break;\n                            }\n                        }\n                        ExtraContentLB.ItemsSource = sdlInfo;\n                        ExtraContentBrd.Visibility = Visibility.Visible;\n                        downloadSize = Helpers.FormatSize(downloadSizeNumber);\n                        installSize = Helpers.FormatSize(installSizeNumber);\n                    }\n                }", "                        foreach (var tagDi in manifest.Manifest.Tag_disk_size)\n                        {\n                            if (tagDi.Tag == \"\")\n                            {\n                                installSizeNumber += tagDi.Size;\n                                break;\n                            }\n                        }\n                        ExtraContentLB.ItemsSource = sdlInfo;\n                        ExtraContentBrd.Visibility = Visibility.Visible;\n                        downloadSize = Helpers.FormatSize(downloadSizeNumber);\n                        installSize = Helpers.FormatSize(installSizeNumber);\n                    }\n                }", "                if (downloadSize.IsNullOrEmpty() || installSize.IsNullOrEmpty())\n                {\n                    downloadSize = Helpers.FormatSize(manifest.Manifest.Download_size);\n                    installSize = Helpers.FormatSize(manifest.Manifest.Disk_size);\n                }\n                DownloadSizeTB.Text = downloadSize;\n                InstallSizeTB.Text = installSize;\n            }\n            else\n            {\n                ImportBtn.IsEnabled = false;\n                ImportBtn.Visibility = Visibility.Collapsed;\n\n                var result = await Cli.Wrap(LegendaryLauncher.ClientExecPath)\n                                      .WithArguments(new[] { GameID, \"install\" })\n                                      .WithStandardInputPipe(PipeSource.FromString(\"n\"))\n                                      .WithValidation(CommandResultValidation.None)\n                                      .ExecuteBufferedAsync();", "                if (result.ExitCode != 0)\n                {\n                    logger.Error(\"[Legendary]\" + result.StandardError);\n                    if (result.StandardError.Contains(\"Failed to establish a new connection\"))\n                    {\n                        playniteAPI.Dialogs.ShowErrorMessage(string.Format(ResourceProvider.GetString(\"LOCGameInstallError\"), ResourceProvider.GetString(\"LOCLoginRequired\")));\n                    }\n                    else\n                    {\n                        playniteAPI.Dialogs.ShowErrorMessage(string.Format(ResourceProvider.GetString(\"LOCGameInstallError\"), ResourceProvider.GetString(LOC.LegendaryCheckLog)));\n                    }\n                    Window.GetWindow(this).Close();\n                }\n                else\n                {\n                    string[] lines = result.StandardError.Split(new[] { Environment.NewLine }, StringSplitOptions.None);", "                    foreach (var line in lines)\n                    {\n                        if (line.Contains(\"Download size:\"))\n                        {\n                            var downloadSizeValue = double.Parse(line.Substring(line.IndexOf(\"Download size:\") + 15).Replace(\" MiB\", \"\"), CultureInfo.InvariantCulture) * 1024 * 1024;\n                            downloadSize = Helpers.FormatSize(downloadSizeValue);\n                            DownloadSizeTB.Text = downloadSize;\n                        }\n                        if (line.Contains(\"Install size:\"))\n                        {\n                            var installSizeValue = double.Parse(line.Substring(line.IndexOf(\"Install size:\") + 14).Replace(\" MiB\", \"\"), CultureInfo.InvariantCulture) * 1024 * 1024;\n                            installSize = Helpers.FormatSize(installSizeValue);\n                            InstallSizeTB.Text = installSize;\n                        }\n                    }\n                }\n\n            }\n            InstallBtn.IsEnabled = true;\n            RepairBtn.IsEnabled = true;\n        }\n", "                        if (line.Contains(\"Install size:\"))\n                        {\n                            var installSizeValue = double.Parse(line.Substring(line.IndexOf(\"Install size:\") + 14).Replace(\" MiB\", \"\"), CultureInfo.InvariantCulture) * 1024 * 1024;\n                            installSize = Helpers.FormatSize(installSizeValue);\n                            InstallSizeTB.Text = installSize;\n                        }\n                    }\n                }\n\n            }\n            InstallBtn.IsEnabled = true;\n            RepairBtn.IsEnabled = true;\n        }\n", "        private void UpdateSpaceInfo(string path)\n        {\n            DriveInfo dDrive = new DriveInfo(path);\n            if (dDrive.IsReady)\n            {\n                SpaceTB.Text = Helpers.FormatSize(dDrive.AvailableFreeSpace);\n            }\n        }\n\n        private void ExtraContentLB_SelectionChanged(object sender, SelectionChangedEventArgs e)\n        {\n            var initialDownloadSizeNumber = downloadSizeNumber;\n            var initialInstallSizeNumber = installSizeNumber;", "        private void ExtraContentLB_SelectionChanged(object sender, SelectionChangedEventArgs e)\n        {\n            var initialDownloadSizeNumber = downloadSizeNumber;\n            var initialInstallSizeNumber = installSizeNumber;\n            foreach (var selectedOption in ExtraContentLB.SelectedItems.Cast<KeyValuePair<string, LegendarySDLInfo>>().ToList())\n            {\n                foreach (var tag in selectedOption.Value.Tags)\n                {\n                    foreach (var tagDo in manifest.Manifest.Tag_download_size)\n                    {\n                        if (tagDo.Tag == tag)\n                        {\n                            initialDownloadSizeNumber += tagDo.Size;\n                            break;\n                        }\n                    }", "                    foreach (var tagDo in manifest.Manifest.Tag_download_size)\n                    {\n                        if (tagDo.Tag == tag)\n                        {\n                            initialDownloadSizeNumber += tagDo.Size;\n                            break;\n                        }\n                    }\n                    foreach (var tagDi in manifest.Manifest.Tag_disk_size)\n                    {\n                        if (tagDi.Tag == tag)\n                        {\n                            initialInstallSizeNumber += tagDi.Size;\n                            break;\n                        }\n                    }\n                }\n            }\n            downloadSize = Helpers.FormatSize(initialDownloadSizeNumber);\n            DownloadSizeTB.Text = downloadSize;\n            installSize = Helpers.FormatSize(initialInstallSizeNumber);\n            InstallSizeTB.Text = installSize;\n        }\n", "                    foreach (var tagDi in manifest.Manifest.Tag_disk_size)\n                    {\n                        if (tagDi.Tag == tag)\n                        {\n                            initialInstallSizeNumber += tagDi.Size;\n                            break;\n                        }\n                    }\n                }\n            }\n            downloadSize = Helpers.FormatSize(initialDownloadSizeNumber);\n            DownloadSizeTB.Text = downloadSize;\n            installSize = Helpers.FormatSize(initialInstallSizeNumber);\n            InstallSizeTB.Text = installSize;\n        }\n", "        private void SetControlStyles()\n        {\n            var baseStyleName = \"BaseTextBlockStyle\";\n            if (playniteAPI.ApplicationInfo.Mode == ApplicationMode.Fullscreen)\n            {\n                baseStyleName = \"TextBlockBaseStyle\";\n                Resources.Add(typeof(Button), new Style(typeof(Button), null));\n            }\n\n            if (ResourceProvider.GetResource(baseStyleName) is Style baseStyle && baseStyle.TargetType == typeof(TextBlock))\n            {\n                var implicitStyle = new Style(typeof(TextBlock), baseStyle);\n                Resources.Add(typeof(TextBlock), implicitStyle);\n            }\n        }\n", "            if (ResourceProvider.GetResource(baseStyleName) is Style baseStyle && baseStyle.TargetType == typeof(TextBlock))\n            {\n                var implicitStyle = new Style(typeof(TextBlock), baseStyle);\n                Resources.Add(typeof(TextBlock), implicitStyle);\n            }\n        }\n\n        private async void RepairBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var settings = LegendaryLibrary.GetSettings();\n            int maxWorkers = settings.MaxWorkers;", "            if (MaxWorkersNI.Value != \"\")\n            {\n                maxWorkers = int.Parse(MaxWorkersNI.Value);\n            }\n            int maxSharedMemory = settings.MaxSharedMemory;\n            if (MaxSharedMemoryNI.Value != \"\")\n            {\n                maxSharedMemory = int.Parse(MaxSharedMemoryNI.Value);\n            }\n            bool enableReordering = Convert.ToBoolean(ReorderingChk.IsChecked);\n            var selectedExtraContent = new List<string>();", "            if (requiredThings.Count > 0)\n            {\n                selectedExtraContent.Add(\"\");\n                foreach (var requiredThing in requiredThings)\n                {\n                    selectedExtraContent.Add(requiredThing);\n                }\n            }\n            if (ExtraContentLB.Items.Count > 0)\n            {\n                selectedExtraContent.AddMissing(\"\");", "            if (ExtraContentLB.Items.Count > 0)\n            {\n                selectedExtraContent.AddMissing(\"\");\n                foreach (var selectedOption in ExtraContentLB.SelectedItems.Cast<KeyValuePair<string, LegendarySDLInfo>>().ToList())\n                {\n                    foreach (var tag in selectedOption.Value.Tags)\n                    {\n                        selectedExtraContent.AddMissing(tag);\n                    }\n                }\n            }\n            InstallerWindow.Close();\n            LegendaryDownloadManager downloadManager = LegendaryLibrary.GetLegendaryDownloadManager();\n            var wantedItem = downloadManager.downloadManagerData.downloads.FirstOrDefault(item => item.gameID == GameID);", "            if (wantedItem != null)\n            {\n                playniteAPI.Dialogs.ShowMessage(string.Format(ResourceProvider.GetString(LOC.LegendaryDownloadAlreadyExists), wantedItem.name), \"\", MessageBoxButton.OK, MessageBoxImage.Error);\n            }\n            else\n            {\n                var messagesSettings = LegendaryMessagesSettings.LoadSettings();\n                if (!messagesSettings.DontShowDownloadManagerWhatsUpMsg)\n                {\n                    var okResponse = new MessageBoxOption(\"LOCOKLabel\", true, true);\n                    var dontShowResponse = new MessageBoxOption(\"LOCDontShowAgainTitle\");\n                    var response = playniteAPI.Dialogs.ShowMessage(LOC.LegendaryDownloadManagerWhatsUp, \"\", MessageBoxImage.Information, new List<MessageBoxOption> { okResponse, dontShowResponse });", "                    if (response == dontShowResponse)\n                    {\n                        messagesSettings.DontShowDownloadManagerWhatsUpMsg = true;\n                        LegendaryMessagesSettings.SaveSettings(messagesSettings);\n                    }\n                }\n\n                DownloadProperties downloadProperties = new DownloadProperties()\n                {\n                    installPath = \"\",\n                    downloadAction = (int)DownloadAction.Repair,\n                    enableReordering = enableReordering,\n                    maxWorkers = maxWorkers,\n                    maxSharedMemory = maxSharedMemory,\n                    extraContent = selectedExtraContent\n                };\n                await downloadManager.EnqueueJob(GameID, InstallerWindow.Title, downloadSize, installSize, downloadProperties);\n            }\n        }\n    }\n}\n"]}
{"filename": "src/Helpers.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Management;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS\n{\n    public class Helpers\n    {\n        static readonly string[] suffixes = { \"B\", \"KB\", \"MB\", \"GB\", \"TB\" };", "{\n    public class Helpers\n    {\n        static readonly string[] suffixes = { \"B\", \"KB\", \"MB\", \"GB\", \"TB\" };\n        public static string FormatSize(double size)\n        {\n            int i = 0;\n            decimal number = (decimal)size;\n            while (Math.Round(number / 1024) >= 1)\n            {\n                number /= 1024;\n                i++;\n            }\n            return string.Format(\"{0:n2} {1}\", number, suffixes[i]);\n        }\n", "            while (Math.Round(number / 1024) >= 1)\n            {\n                number /= 1024;\n                i++;\n            }\n            return string.Format(\"{0:n2} {1}\", number, suffixes[i]);\n        }\n\n        public static int TotalRAM\n        {\n            get\n            {\n                ObjectQuery wql = new ObjectQuery(\"SELECT * FROM Win32_OperatingSystem\");\n                ManagementObjectSearcher searcher = new ManagementObjectSearcher(wql);\n                ManagementObjectCollection results = searcher.Get();\n                double ram = 0.0;", "        public static int TotalRAM\n        {\n            get\n            {\n                ObjectQuery wql = new ObjectQuery(\"SELECT * FROM Win32_OperatingSystem\");\n                ManagementObjectSearcher searcher = new ManagementObjectSearcher(wql);\n                ManagementObjectCollection results = searcher.Get();\n                double ram = 0.0;\n                foreach (ManagementObject result in results)\n                {\n                    ram = Convert.ToDouble(result[\"TotalVisibleMemorySize\"].ToString().Replace(\"KB\", \"\"));\n                }\n                ram = Math.Round(ram / 1024);\n                return Convert.ToInt32(ram);\n            }\n        }\n    }\n}\n", "                foreach (ManagementObject result in results)\n                {\n                    ram = Convert.ToDouble(result[\"TotalVisibleMemorySize\"].ToString().Replace(\"KB\", \"\"));\n                }\n                ram = Math.Round(ram / 1024);\n                return Convert.ToInt32(ram);\n            }\n        }\n    }\n}\n"]}
{"filename": "src/LegendaryLibrarySettingsView.xaml.cs", "chunked_list": ["\ufeffusing CliWrap;\nusing CliWrap.Buffered;\nusing LegendaryLibraryNS.Enums;\nusing LegendaryLibraryNS.Models;\nusing Playnite;\nusing Playnite.Common;\nusing Playnite.SDK;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;", "using System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Documents;\nusing System.Windows.Input;", "using System.Windows.Documents;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Imaging;\nusing System.Windows.Navigation;\nusing System.Windows.Shapes;\n\nnamespace LegendaryLibraryNS\n{\n    /// <summary>", "{\n    /// <summary>\n    /// Interaction logic for LegendaryLibrarySettingsView.xaml\n    /// </summary>\n    public partial class LegendaryLibrarySettingsView : UserControl\n    {\n        private ILogger logger = LogManager.GetLogger();\n        private IPlayniteAPI playniteAPI = API.Instance;\n        public LegendaryLibrarySettingsView()\n        {\n            InitializeComponent();\n        }\n", "        private void ChooseLauncherBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var path = playniteAPI.Dialogs.SelectFolder();\n            if (path != \"\")\n            {\n                SelectedLauncherPathTxt.Text = path;\n            }\n        }\n\n        private void ChooseGamePathBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var path = playniteAPI.Dialogs.SelectFolder();", "        private void ChooseGamePathBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var path = playniteAPI.Dialogs.SelectFolder();\n            if (path != \"\")\n            {\n                SelectedGamePathTxt.Text = path;\n            }\n        }\n\n        private void ExcludeOnlineGamesBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var window = playniteAPI.Dialogs.CreateWindow(new WindowCreationOptions\n            {\n                ShowMinimizeButton = false,\n            });\n            window.Content = new LegendaryExcludeOnlineGames();\n            window.Owner = playniteAPI.Dialogs.GetCurrentAppWindow();\n            window.Height = 450;\n            window.Width = 800;\n            window.Title = ResourceProvider.GetString(LOC.LegendaryExcludeGames);\n            window.WindowStartupLocation = WindowStartupLocation.CenterOwner;\n            window.ShowDialog();\n        }\n", "        private void ExcludeOnlineGamesBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var window = playniteAPI.Dialogs.CreateWindow(new WindowCreationOptions\n            {\n                ShowMinimizeButton = false,\n            });\n            window.Content = new LegendaryExcludeOnlineGames();\n            window.Owner = playniteAPI.Dialogs.GetCurrentAppWindow();\n            window.Height = 450;\n            window.Width = 800;\n            window.Title = ResourceProvider.GetString(LOC.LegendaryExcludeGames);\n            window.WindowStartupLocation = WindowStartupLocation.CenterOwner;\n            window.ShowDialog();\n        }\n", "        private async void EOSOUninstallBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var result = playniteAPI.Dialogs.ShowMessage(\n                string.Format(ResourceProvider.GetString(LOC.LegendaryUninstallGameConfirm), ResourceProvider.GetString(LOC.LegendaryEOSOverlay)), ResourceProvider.GetString(\"LOCUninstallGame\"), MessageBoxButton.YesNo, MessageBoxImage.Question);\n            if (result == MessageBoxResult.Yes)\n            {\n                var cmd = await Cli.Wrap(LegendaryLauncher.ClientExecPath)\n                                   .WithValidation(CommandResultValidation.None)\n                                   .WithArguments(new[] { \"-y\", \"eos-overlay\", \"remove\" })\n                                   .ExecuteBufferedAsync();\n                if (cmd.StandardError.Contains(\"Done\"))\n                {\n                    EOSOInstallBtn.Visibility = Visibility.Visible;\n                    EOSOUninstallBtn.Visibility = Visibility.Collapsed;\n                    EOSOToggleBtn.Visibility = Visibility.Collapsed;\n                }\n            }\n        }\n", "                if (cmd.StandardError.Contains(\"Done\"))\n                {\n                    EOSOInstallBtn.Visibility = Visibility.Visible;\n                    EOSOUninstallBtn.Visibility = Visibility.Collapsed;\n                    EOSOToggleBtn.Visibility = Visibility.Collapsed;\n                }\n            }\n        }\n\n        private void EOSOInstallBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var window = playniteAPI.Dialogs.CreateWindow(new WindowCreationOptions\n            {\n                ShowMaximizeButton = false\n            });\n            window.Title = ResourceProvider.GetString(LOC.LegendaryEOSOverlay);\n            var installProperties = new DownloadProperties { downloadAction = (int)DownloadAction.Install };\n            var installData = new DownloadManagerData.Download { gameID = \"eos-overlay\", downloadProperties = installProperties };\n            window.DataContext = installData;\n            window.Content = new LegendaryGameInstaller();\n            window.Owner = playniteAPI.Dialogs.GetCurrentAppWindow();\n            window.SizeToContent = SizeToContent.Height;\n            window.Width = 600;\n            window.WindowStartupLocation = WindowStartupLocation.CenterOwner;\n            var result = window.ShowDialog();", "        private void EOSOInstallBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var window = playniteAPI.Dialogs.CreateWindow(new WindowCreationOptions\n            {\n                ShowMaximizeButton = false\n            });\n            window.Title = ResourceProvider.GetString(LOC.LegendaryEOSOverlay);\n            var installProperties = new DownloadProperties { downloadAction = (int)DownloadAction.Install };\n            var installData = new DownloadManagerData.Download { gameID = \"eos-overlay\", downloadProperties = installProperties };\n            window.DataContext = installData;\n            window.Content = new LegendaryGameInstaller();\n            window.Owner = playniteAPI.Dialogs.GetCurrentAppWindow();\n            window.SizeToContent = SizeToContent.Height;\n            window.Width = 600;\n            window.WindowStartupLocation = WindowStartupLocation.CenterOwner;\n            var result = window.ShowDialog();", "            if (result == true)\n            {\n                if (LegendaryLauncher.IsEOSOverlayInstalled)\n                {\n                    EOSOInstallBtn.Visibility = Visibility.Collapsed;\n                    EOSOUninstallBtn.Visibility = Visibility.Visible;\n                    EOSOToggleBtn.Content = ResourceProvider.GetString(LOC.LegendaryDisable);\n                    EOSOToggleBtn.Visibility = Visibility.Visible;\n                }\n            }\n        }\n", "        private async void EOSOToggleBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var toggleCommand = \"disable\";\n            if (!LegendaryLauncher.IsEOSOverlayEnabled)\n            {\n                toggleCommand = \"enable\";\n            }\n            await Cli.Wrap(LegendaryLauncher.ClientExecPath)\n                     .WithArguments(new[] { \"-y\", \"eos-overlay\", toggleCommand })\n                     .WithValidation(CommandResultValidation.None)\n                     .ExecuteAsync();\n            var toggleTxt = LOC.LegendaryEnable;", "            if (LegendaryLauncher.IsEOSOverlayEnabled)\n            {\n                toggleTxt = LOC.LegendaryDisable;\n            }\n            EOSOToggleBtn.Content = ResourceProvider.GetString(toggleTxt);\n        }\n\n        private void LegendarySettingsUC_Loaded(object sender, RoutedEventArgs e)\n        {\n            var installedAddons = playniteAPI.Addons.Addons;\n            if (installedAddons.Contains(\"EpicGamesLibrary_Builtin\"))\n            {\n                MigrateEpicBtn.IsEnabled = true;\n            }\n", "            if (installedAddons.Contains(\"EpicGamesLibrary_Builtin\"))\n            {\n                MigrateEpicBtn.IsEnabled = true;\n            }\n\n            if (!LegendaryLauncher.IsEOSOverlayInstalled)\n            {\n                EOSOInstallBtn.Visibility = Visibility.Visible;\n                EOSOToggleBtn.Visibility = Visibility.Collapsed;\n                EOSOUninstallBtn.Visibility = Visibility.Collapsed;\n            }\n            else\n            {", "                if (!LegendaryLauncher.IsEOSOverlayEnabled)\n                {\n                    EOSOToggleBtn.Content = ResourceProvider.GetString(LOC.LegendaryEnable);\n                }\n            }\n\n            var downloadCompleteActions = new Dictionary<int, string>\n            {\n                { (int)DownloadCompleteAction.Nothing, ResourceProvider.GetString(\"LOCDoNothing\") },\n                { (int)DownloadCompleteAction.ShutDown, ResourceProvider.GetString(\"LOCMenuShutdownSystem\") },\n                { (int)DownloadCompleteAction.Reboot, ResourceProvider.GetString(\"LOCMenuRestartSystem\") },\n                { (int)DownloadCompleteAction.Hibernate, ResourceProvider.GetString(\"LOCMenuHibernateSystem\") },\n                { (int)DownloadCompleteAction.Sleep, ResourceProvider.GetString(\"LOCMenuSuspendSystem\") },\n            };\n            AfterDownloadCompleteCBo.ItemsSource = downloadCompleteActions;\n\n            var autoClearOptions = new Dictionary<int, string>\n            {\n                { (int)ClearCacheTime.Day, ResourceProvider.GetString(\"LOCOptionOnceADay\") },\n                { (int)ClearCacheTime.Week, ResourceProvider.GetString(\"LOCOptionOnceAWeek\") },\n                { (int)ClearCacheTime.Month, ResourceProvider.GetString(LOC.LegendaryOnceAMonth) },\n                { (int)ClearCacheTime.ThreeMonths, ResourceProvider.GetString(LOC.LegendaryOnceEvery3Months) },\n                { (int)ClearCacheTime.SixMonths, ResourceProvider.GetString(LOC.LegendaryOnceEvery6Months) },\n                { (int)ClearCacheTime.Never, ResourceProvider.GetString(\"LOCNever\") }\n            };\n            AutoClearCacheCBo.ItemsSource = autoClearOptions;\n        }\n", "        private void ClearCacheBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var result = playniteAPI.Dialogs.ShowMessage(ResourceProvider.GetString(LOC.LegendaryClearCacheConfirm), ResourceProvider.GetString(\"LOCSettingsClearCacheTitle\"), MessageBoxButton.YesNo, MessageBoxImage.Question);\n            if (result == MessageBoxResult.Yes)\n            {\n                var cacheDirs = new List<string>()\n                {\n                    LegendaryLibrary.Instance.GetCachePath(\"catalogcache\"),\n                    LegendaryLibrary.Instance.GetCachePath(\"infocache\"),\n                    LegendaryLibrary.Instance.GetCachePath(\"sdlcache\")\n                };", "                foreach (var cacheDir in cacheDirs)\n                {\n                    if (Directory.Exists(cacheDir))\n                    {\n                        Directory.Delete(cacheDir, true);\n                    }\n                }\n            }\n        }\n\n        private void SyncGameSavesChk_Click(object sender, RoutedEventArgs e)\n        {", "        private void SyncGameSavesChk_Click(object sender, RoutedEventArgs e)\n        {\n            if (SyncGameSavesChk.IsChecked == true)\n            {\n                playniteAPI.Dialogs.ShowMessage(ResourceProvider.GetString(LOC.LegendarySyncGameSavesWarn), \"\", MessageBoxButton.OK, MessageBoxImage.Warning);\n            }\n        }\n\n        private void MigrateEpicBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var result = playniteAPI.Dialogs.ShowMessage(ResourceProvider.GetString(LOC.LegendaryMigrationConfirm), ResourceProvider.GetString(LOC.LegendaryMigrateGamesEpic), MessageBoxButton.YesNo, MessageBoxImage.Question);", "        private void MigrateEpicBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var result = playniteAPI.Dialogs.ShowMessage(ResourceProvider.GetString(LOC.LegendaryMigrationConfirm), ResourceProvider.GetString(LOC.LegendaryMigrateGamesEpic), MessageBoxButton.YesNo, MessageBoxImage.Question);\n            if (result == MessageBoxResult.No)\n            {\n                return;\n            }\n            GlobalProgressOptions globalProgressOptions = new GlobalProgressOptions(ResourceProvider.GetString(LOC.LegendaryMigratingGamesEpic), false) { IsIndeterminate = false };\n            playniteAPI.Dialogs.ActivateGlobalProgress(async (a) =>\n            {\n                using (playniteAPI.Database.BufferedUpdate())\n                {\n                    var gamesToMigrate = playniteAPI.Database.Games.Where(i => i.PluginId == Guid.Parse(\"00000002-DBD1-46C6-B5D0-B1BA559D10E4\")).ToList();\n                    var migratedGames = new List<string>();\n                    var notImportedGames = new List<string>();", "                using (playniteAPI.Database.BufferedUpdate())\n                {\n                    var gamesToMigrate = playniteAPI.Database.Games.Where(i => i.PluginId == Guid.Parse(\"00000002-DBD1-46C6-B5D0-B1BA559D10E4\")).ToList();\n                    var migratedGames = new List<string>();\n                    var notImportedGames = new List<string>();\n                    if (gamesToMigrate.Count > 0)\n                    {\n                        var iterator = 0;\n                        a.ProgressMaxValue = gamesToMigrate.Count() + 1;\n                        a.CurrentProgressValue = 0;\n                        foreach (var game in gamesToMigrate.ToList())\n                        {\n                            iterator++;\n                            var alreadyExists = playniteAPI.Database.Games.FirstOrDefault(i => i.GameId == game.GameId && i.PluginId == LegendaryLibrary.Instance.Id);", "                        foreach (var game in gamesToMigrate.ToList())\n                        {\n                            iterator++;\n                            var alreadyExists = playniteAPI.Database.Games.FirstOrDefault(i => i.GameId == game.GameId && i.PluginId == LegendaryLibrary.Instance.Id);\n                            if (alreadyExists == null)\n                            {\n                                game.PluginId = LegendaryLibrary.Instance.Id;\n                                if (game.IsInstalled)\n                                {\n                                    var importCmd = await Cli.Wrap(LegendaryLauncher.ClientExecPath)\n                                                             .WithArguments(new[] { \"-y\", \"import\", game.GameId, game.InstallDirectory })\n                                                             .WithValidation(CommandResultValidation.None)\n                                                             .ExecuteBufferedAsync();", "                                    if (!importCmd.StandardError.Contains(\"has been imported\"))\n                                    {\n                                        notImportedGames.Add(game.GameId);\n                                        game.IsInstalled = false;\n                                        logger.Debug(\"[Legendary] \" + importCmd.StandardError);\n                                        logger.Error(\"[Legendary] exit code: \" + importCmd.ExitCode);\n                                    }\n                                }\n                                playniteAPI.Database.Games.Update(game);\n                                migratedGames.Add(game.GameId);\n                                a.CurrentProgressValue = iterator;\n                            }\n                        }\n                        a.CurrentProgressValue = gamesToMigrate.Count() + 1;", "                        if (migratedGames.Count > 0)\n                        {\n                            playniteAPI.Dialogs.ShowMessage(LOC.LegendaryMigrationCompleted, LOC.LegendaryMigrateGamesEpic, MessageBoxButton.OK, MessageBoxImage.Information);\n                            logger.Info(\"Successfully migrated \" + migratedGames.Count + \" game(s) from Epic to Legendary.\");\n                        }\n                        if (notImportedGames.Count > 0)\n                        {\n                            logger.Info(notImportedGames.Count + \" game(s) probably needs to be imported or installed again.\");\n                        }\n                    }\n                    else\n                    {\n                        a.ProgressMaxValue = 1;\n                        a.CurrentProgressValue = 1;\n                        playniteAPI.Dialogs.ShowErrorMessage(LOC.LegendaryMigrationNoGames);\n                    }\n                }\n            }, globalProgressOptions);\n        }\n    }\n}\n"]}
{"filename": "src/LegendaryDownloadManager.xaml.cs", "chunked_list": ["\ufeffusing CliWrap;\nusing CliWrap.EventStream;\nusing Playnite.SDK;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;", "using System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Documents;\nusing System.Windows.Input;\nusing System.Windows.Media;", "using System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Imaging;\nusing System.Windows.Navigation;\nusing System.IO;\nusing LegendaryLibraryNS.Models;\nusing Playnite.SDK.Plugins;\nusing LegendaryLibraryNS.Enums;\nusing Playnite.SDK.Data;\nusing Playnite.Common;", "using Playnite.SDK.Data;\nusing Playnite.Common;\nusing System.Collections.ObjectModel;\nusing System.ComponentModel;\n\nnamespace LegendaryLibraryNS\n{\n    /// <summary>\n    /// Interaction logic for LegendaryDownloadManager.xaml\n    /// </summary>\n    public partial class LegendaryDownloadManager : UserControl\n    {", "    /// Interaction logic for LegendaryDownloadManager.xaml\n    /// </summary>\n    public partial class LegendaryDownloadManager : UserControl\n    {\n        public CancellationTokenSource forcefulInstallerCTS;\n        public CancellationTokenSource gracefulInstallerCTS;\n        private ILogger logger = LogManager.GetLogger();\n        private IPlayniteAPI playniteAPI = API.Instance;\n        public DownloadManagerData.Rootobject downloadManagerData;\n\n        public LegendaryDownloadManager()\n        {\n            InitializeComponent();\n            SetControlTextBlockStyle();\n            LoadSavedData();\n            var runningAndQueuedDownloads = downloadManagerData.downloads.Where(i => i.status == (int)DownloadStatus.Running\n                                                                                     || i.status == (int)DownloadStatus.Queued).ToList();", "            if (runningAndQueuedDownloads.Count > 0)\n            {\n                foreach (var download in runningAndQueuedDownloads)\n                {\n                    download.status = (int)DownloadStatus.Paused;\n                }\n                SaveData();\n            }\n        }\n\n        public RelayCommand<object> NavigateBackCommand\n        {\n            get => new RelayCommand<object>((a) =>\n            {\n                playniteAPI.MainView.SwitchToLibraryView();\n            });\n        }\n\n        public DownloadManagerData.Rootobject LoadSavedData()\n        {\n            var dataDir = LegendaryLibrary.Instance.GetPluginUserDataPath();\n            var dataFile = Path.Combine(dataDir, \"downloadManager.json\");\n            bool correctJson = false;", "            if (File.Exists(dataFile))\n            {\n                if (Serialization.TryFromJson(FileSystem.ReadFileAsStringSafe(dataFile), out downloadManagerData))\n                {\n                    if (downloadManagerData != null && downloadManagerData.downloads != null)\n                    {\n                        correctJson = true;\n                    }\n                }\n            }\n            if (!correctJson)\n            {\n                downloadManagerData = new DownloadManagerData.Rootobject\n                {\n                    downloads = new ObservableCollection<DownloadManagerData.Download>()\n                };\n            }\n            DownloadsDG.ItemsSource = downloadManagerData.downloads;\n            return downloadManagerData;\n        }\n", "            if (!correctJson)\n            {\n                downloadManagerData = new DownloadManagerData.Rootobject\n                {\n                    downloads = new ObservableCollection<DownloadManagerData.Download>()\n                };\n            }\n            DownloadsDG.ItemsSource = downloadManagerData.downloads;\n            return downloadManagerData;\n        }\n", "        public void SaveData()\n        {\n            var dataDir = LegendaryLibrary.Instance.GetPluginUserDataPath();\n            var dataFile = Path.Combine(dataDir, \"downloadManager.json\");\n            if (!Directory.Exists(dataDir))\n            {\n                Directory.CreateDirectory(dataDir);\n            }\n            var strConf = Serialization.ToJson(downloadManagerData, true);\n            if (!strConf.IsNullOrEmpty())\n            {\n                File.WriteAllText(dataFile, strConf);\n            }\n        }\n", "            if (!strConf.IsNullOrEmpty())\n            {\n                File.WriteAllText(dataFile, strConf);\n            }\n        }\n\n        public async void DoNextJobInQueue(object _, PropertyChangedEventArgs arg)\n        {\n            var running = downloadManagerData.downloads.Any(item => item.status == (int)DownloadStatus.Running);\n            var queuedList = downloadManagerData.downloads.Where(i => i.status == (int)DownloadStatus.Queued).ToList();\n            if (!running && queuedList.Count > 0)\n            {\n                await Install(queuedList[0].gameID, queuedList[0].name, queuedList[0].downloadSize, queuedList[0].downloadProperties);\n            }", "            if (!running && queuedList.Count > 0)\n            {\n                await Install(queuedList[0].gameID, queuedList[0].name, queuedList[0].downloadSize, queuedList[0].downloadProperties);\n            }\n            else if (!running)\n            {\n                DownloadPB.Value = 0;\n                var downloadCompleteSettings = LegendaryLibrary.GetSettings().DoActionAfterDownloadComplete;\n                switch (downloadCompleteSettings)\n                {\n                    case (int)DownloadCompleteAction.ShutDown:\n                        Process.Start(\"shutdown\", \"/s /t 0\");\n                        break;\n                    case (int)DownloadCompleteAction.Reboot:\n                        Process.Start(\"shutdown\", \"/r /t 0\");\n                        break;\n                    case (int)DownloadCompleteAction.Hibernate:\n                        Playnite.Native.Powrprof.SetSuspendState(true, true, false);\n                        break;\n                    case (int)DownloadCompleteAction.Sleep:\n                        Playnite.Native.Powrprof.SetSuspendState(false, true, false);\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n", "        public async Task EnqueueJob(string gameID, string gameTitle, string downloadSize, string installSize, DownloadProperties downloadProperties)\n        {\n            var wantedItem = downloadManagerData.downloads.FirstOrDefault(item => item.gameID == gameID);\n            if (wantedItem == null)\n            {\n                DateTimeOffset now = DateTime.UtcNow;\n                downloadManagerData.downloads.Add(new DownloadManagerData.Download\n                { gameID = gameID, downloadSize = downloadSize, installSize = installSize, name = gameTitle, status = (int)DownloadStatus.Queued, addedTime = now.ToUnixTimeSeconds(), downloadProperties = downloadProperties });\n                SaveData();\n            }\n            else\n            {\n                wantedItem.status = (int)DownloadStatus.Queued;\n                SaveData();\n            }\n            var running = downloadManagerData.downloads.Any(item => item.status == (int)DownloadStatus.Running);", "            if (!running)\n            {\n                await Install(gameID, gameTitle, downloadSize, downloadProperties);\n            }\n            foreach (DownloadManagerData.Download download in downloadManagerData.downloads)\n            {\n                download.PropertyChanged -= DoNextJobInQueue;\n                download.PropertyChanged += DoNextJobInQueue;\n            }\n        }\n", "        public async Task Install(string gameID, string gameTitle, string downloadSize, DownloadProperties downloadProperties)\n        {\n            var installCommand = new List<string>() { \"-y\", \"install\", gameID };\n            if (downloadProperties.installPath != \"\")\n            {\n                installCommand.AddRange(new[] { \"--base-path\", downloadProperties.installPath });\n            }\n            var settings = LegendaryLibrary.GetSettings();\n            if (settings.PreferredCDN != \"\")\n            {\n                installCommand.AddRange(new[] { \"--preferred-cdn\", settings.PreferredCDN });\n            }", "            if (settings.PreferredCDN != \"\")\n            {\n                installCommand.AddRange(new[] { \"--preferred-cdn\", settings.PreferredCDN });\n            }\n            if (settings.NoHttps)\n            {\n                installCommand.Add(\"--no-https\");\n            }\n            if (downloadProperties.maxWorkers != 0)\n            {\n                installCommand.AddRange(new[] { \"--max-workers\", downloadProperties.maxWorkers.ToString() });\n            }", "            if (downloadProperties.maxWorkers != 0)\n            {\n                installCommand.AddRange(new[] { \"--max-workers\", downloadProperties.maxWorkers.ToString() });\n            }\n            if (downloadProperties.maxSharedMemory != 0)\n            {\n                installCommand.AddRange(new[] { \"--max-shared-memory\", downloadProperties.maxSharedMemory.ToString() });\n            }\n            if (downloadProperties.enableReordering)\n            {\n                installCommand.Add(\"--enable-reordering\");\n            }", "            if (downloadProperties.enableReordering)\n            {\n                installCommand.Add(\"--enable-reordering\");\n            }\n            if (downloadProperties.downloadAction == (int)DownloadAction.Repair)\n            {\n                installCommand.Add(\"--repair\");\n            }\n            if (downloadProperties.extraContent != null)\n            {\n                if (downloadProperties.extraContent.Count > 0)\n                {", "            if (downloadProperties.extraContent != null)\n            {\n                if (downloadProperties.extraContent.Count > 0)\n                {\n                    foreach (var singleSelectedContent in downloadProperties.extraContent)\n                    {\n                        installCommand.Add(\"--install-tag=\" + singleSelectedContent);\n                    }\n                }\n            }\n            if (gameID == \"eos-overlay\")\n            {\n                installCommand = new List<string>() { \"-y\", \"eos-overlay\", \"install\", \"--path\", downloadProperties.installPath };\n            }\n            forcefulInstallerCTS = new CancellationTokenSource();\n            gracefulInstallerCTS = new CancellationTokenSource();\n            try\n            {\n                var stdOutBuffer = new StringBuilder();\n                var cmd = Cli.Wrap(LegendaryLauncher.ClientExecPath).WithArguments(installCommand).WithValidation(CommandResultValidation.None);\n                var wantedItem = downloadManagerData.downloads.FirstOrDefault(item => item.gameID == gameID);", "            if (gameID == \"eos-overlay\")\n            {\n                installCommand = new List<string>() { \"-y\", \"eos-overlay\", \"install\", \"--path\", downloadProperties.installPath };\n            }\n            forcefulInstallerCTS = new CancellationTokenSource();\n            gracefulInstallerCTS = new CancellationTokenSource();\n            try\n            {\n                var stdOutBuffer = new StringBuilder();\n                var cmd = Cli.Wrap(LegendaryLauncher.ClientExecPath).WithArguments(installCommand).WithValidation(CommandResultValidation.None);\n                var wantedItem = downloadManagerData.downloads.FirstOrDefault(item => item.gameID == gameID);", "                await foreach (CommandEvent cmdEvent in cmd.ListenAsync(Console.OutputEncoding, Console.OutputEncoding, forcefulInstallerCTS.Token, gracefulInstallerCTS.Token))\n                {\n                    switch (cmdEvent)\n                    {\n                        case StartedCommandEvent started:\n                            wantedItem.status = (int)DownloadStatus.Running;\n                            DownloadPB.Value = 0;\n                            EtaTB.Text = \"\";\n                            ElapsedTB.Text = \"\";\n                            DownloadedTB.Text = \"\";\n                            DownloadSpeedTB.Text = \"\";\n                            break;\n                        case StandardErrorCommandEvent stdErr:\n                            var downloadSizeMatch = Regex.Match(stdErr.Text, @\"Download size: (\\S+.) MiB\");", "                            if (downloadSizeMatch.Length >= 2)\n                            {\n                                downloadSize = Helpers.FormatSize(double.Parse(downloadSizeMatch.Groups[1].Value, CultureInfo.InvariantCulture) * 1024 * 1024);\n                                wantedItem.downloadSize = downloadSize;\n                            }\n                            var installSizeMatch = Regex.Match(stdErr.Text, @\"Install size: (\\S+.) MiB\");\n                            if (installSizeMatch.Length >= 2)\n                            {\n                                string installSize = Helpers.FormatSize(double.Parse(installSizeMatch.Groups[1].Value, CultureInfo.InvariantCulture) * 1024 * 1024);\n                                wantedItem.installSize = installSize;\n                            }\n                            var fullInstallPathMatch = Regex.Match(stdErr.Text, @\"Install path: (\\S+)\");", "                            if (fullInstallPathMatch.Length >= 2)\n                            {\n                                wantedItem.fullInstallPath = fullInstallPathMatch.Groups[1].Value;\n                            }\n                            SaveData();\n                            var verificationProgressMatch = Regex.Match(stdErr.Text, @\"Verification progress:.*\\((\\d.*%)\");\n                            var progressMatch = Regex.Match(stdErr.Text, @\"Progress: (\\d.*%)\");\n                            if (verificationProgressMatch.Length >= 2)\n                            {\n                                double progress = double.Parse(verificationProgressMatch.Groups[1].Value.Replace(\"%\", \"\"), CultureInfo.InvariantCulture);\n                                DownloadPB.Value = progress;\n                            }", "                            else if (progressMatch.Length >= 2)\n                            {\n                                double progress = double.Parse(progressMatch.Groups[1].Value.Replace(\"%\", \"\"), CultureInfo.InvariantCulture);\n                                DownloadPB.Value = progress;\n                            }\n                            var ETAMatch = Regex.Match(stdErr.Text, @\"ETA: (\\d\\d:\\d\\d:\\d\\d)\");\n                            if (ETAMatch.Length >= 2)\n                            {\n                                EtaTB.Text = ETAMatch.Groups[1].Value;\n                            }\n                            var elapsedMatch = Regex.Match(stdErr.Text, @\"Running for (\\d\\d:\\d\\d:\\d\\d)\");", "                            var elapsedMatch = Regex.Match(stdErr.Text, @\"Running for (\\d\\d:\\d\\d:\\d\\d)\");\n                            if (elapsedMatch.Length >= 2)\n                            {\n                                ElapsedTB.Text = elapsedMatch.Groups[1].Value;\n                            }\n                            var downloadedMatch = Regex.Match(stdErr.Text, @\"Downloaded: (\\S+.) MiB\");\n                            if (downloadedMatch.Length >= 2)\n                            {\n                                string downloaded = Helpers.FormatSize(double.Parse(downloadedMatch.Groups[1].Value, CultureInfo.InvariantCulture) * 1024 * 1024);\n                                DownloadedTB.Text = downloaded + \" / \" + downloadSize;\n                            }\n                            var downloadSpeedMatch = Regex.Match(stdErr.Text, @\"Download\\t- (\\S+.) MiB\");", "                            if (downloadSpeedMatch.Length >= 2)\n                            {\n                                string downloadSpeed = Helpers.FormatSize(double.Parse(downloadSpeedMatch.Groups[1].Value, CultureInfo.InvariantCulture) * 1024 * 1024);\n                                DownloadSpeedTB.Text = downloadSpeed + \"/s\";\n                            }\n                            stdOutBuffer.AppendLine(stdErr.Text);\n                            break;\n                        case ExitedCommandEvent exited:\n                            if (exited.ExitCode == 0)\n                            {\n                                wantedItem.status = (int)DownloadStatus.Completed;\n                                DateTimeOffset now = DateTime.UtcNow;\n                                wantedItem.completedTime = now.ToUnixTimeSeconds();\n                                SaveData();\n                                _ = (Application.Current.Dispatcher?.BeginInvoke((Action)delegate\n                                {\n                                    var installed = LegendaryLauncher.GetInstalledAppList();", "                            if (exited.ExitCode == 0)\n                            {\n                                wantedItem.status = (int)DownloadStatus.Completed;\n                                DateTimeOffset now = DateTime.UtcNow;\n                                wantedItem.completedTime = now.ToUnixTimeSeconds();\n                                SaveData();\n                                _ = (Application.Current.Dispatcher?.BeginInvoke((Action)delegate\n                                {\n                                    var installed = LegendaryLauncher.GetInstalledAppList();\n                                    if (installed != null)\n                                    {", "                                    if (installed != null)\n                                    {\n                                        foreach (KeyValuePair<string, Installed> app in installed)\n                                        {\n                                            if (app.Value.App_name == gameID)\n                                            {\n                                                var installInfo = new GameInstallationData\n                                                {\n                                                    InstallDirectory = app.Value.Install_path\n                                                };\n\n                                                var game = playniteAPI.Database.Games.FirstOrDefault(\n                                                    item => item.PluginId == LegendaryLibrary.Instance.Id && item.GameId == gameID);\n                                                game.InstallDirectory = app.Value.Install_path;\n                                                game.Version = app.Value.Version;\n                                                game.IsInstalled = true;\n                                                playniteAPI.Database.Games.Update(game);\n                                                break;\n                                            }\n                                        }\n                                    }\n                                }));\n                                Playnite.WindowsNotifyIconManager.Notify(new System.Drawing.Icon(LegendaryLauncher.Icon), gameTitle, ResourceProvider.GetString(LOC.LegendaryInstallationFinished), null);\n                            }", "                            else if (exited.ExitCode != 0)\n                            {\n                                wantedItem.status = (int)DownloadStatus.Paused;\n                                SaveData();\n                                var memoryErrorMatch = Regex.Match(stdOutBuffer.ToString(), @\"MemoryError: Current shared memory cache is smaller than required: (\\S+.) MiB < (\\S+.) MiB\");\n                                if (memoryErrorMatch.Length >= 2)\n                                {\n                                    playniteAPI.Dialogs.ShowErrorMessage(string.Format(ResourceProvider.GetString(\"LOCGameInstallError\"), string.Format(ResourceProvider.GetString(LOC.LegendaryMemoryError), memoryErrorMatch.Groups[1] + \" MB\", memoryErrorMatch.Groups[2] + \" MB\")));\n                                }\n                                else\n                                {\n                                    playniteAPI.Dialogs.ShowErrorMessage(string.Format(ResourceProvider.GetString(\"LOCGameInstallError\"), ResourceProvider.GetString(LOC.LegendaryCheckLog)));\n                                }\n                                logger.Error(\"[Legendary]: \" + stdOutBuffer.ToString());\n                                logger.Error(\"[Legendary] exit code: \" + exited.ExitCode);\n                            }\n                            gracefulInstallerCTS?.Dispose();\n                            forcefulInstallerCTS?.Dispose();\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }", "            catch (OperationCanceledException)\n            {\n                // Command was canceled\n            }\n        }\n\n        private void PauseBtn_Click(object sender, RoutedEventArgs e)\n        {\n            if (DownloadsDG.SelectedIndex != -1)\n            {\n                foreach (var selectedRow in DownloadsDG.SelectedItems.Cast<DownloadManagerData.Download>().ToList())\n                {", "            if (DownloadsDG.SelectedIndex != -1)\n            {\n                foreach (var selectedRow in DownloadsDG.SelectedItems.Cast<DownloadManagerData.Download>().ToList())\n                {\n                    if (selectedRow.status == (int)DownloadStatus.Running ||\n                        selectedRow.status == (int)DownloadStatus.Queued)\n                    {\n                        if (selectedRow.status == (int)DownloadStatus.Running)\n                        {\n                            gracefulInstallerCTS?.Cancel();\n                            gracefulInstallerCTS?.Dispose();\n                            forcefulInstallerCTS?.Dispose();\n                            EtaTB.Text = \"\";\n                        }\n                        selectedRow.status = (int)DownloadStatus.Paused;\n                        SaveData();\n                    }\n                }\n            }\n        }\n", "        private async void ResumeDownloadBtn_Click(object sender, RoutedEventArgs e)\n        {\n            if (DownloadsDG.SelectedIndex != -1)\n            {\n                foreach (var selectedRow in DownloadsDG.SelectedItems.Cast<DownloadManagerData.Download>().ToList())\n                {\n                    if (selectedRow.status == (int)DownloadStatus.Canceled ||\n                        selectedRow.status == (int)DownloadStatus.Paused)\n                    {\n                        await EnqueueJob(selectedRow.gameID, selectedRow.name, selectedRow.downloadSize, selectedRow.installSize, selectedRow.downloadProperties);\n                    }\n                }\n            }\n        }\n", "        private void CancelDownloadBtn_Click(object sender, RoutedEventArgs e)\n        {\n            if (DownloadsDG.SelectedIndex != -1)\n            {\n                foreach (var selectedRow in DownloadsDG.SelectedItems.Cast<DownloadManagerData.Download>().ToList())\n                {\n                    if (selectedRow.status == (int)DownloadStatus.Running ||\n                        selectedRow.status == (int)DownloadStatus.Queued ||\n                        selectedRow.status == (int)DownloadStatus.Paused)\n                    {\n                        if (selectedRow.status == (int)DownloadStatus.Running)\n                        {\n                            gracefulInstallerCTS?.Cancel();\n                            gracefulInstallerCTS?.Dispose();\n                            forcefulInstallerCTS?.Dispose();\n                        }\n                        var resumeFile = Path.Combine(LegendaryLauncher.ConfigPath, \"tmp\", selectedRow.gameID + \".resume\");", "                        if (selectedRow.status == (int)DownloadStatus.Running)\n                        {\n                            gracefulInstallerCTS?.Cancel();\n                            gracefulInstallerCTS?.Dispose();\n                            forcefulInstallerCTS?.Dispose();\n                        }\n                        var resumeFile = Path.Combine(LegendaryLauncher.ConfigPath, \"tmp\", selectedRow.gameID + \".resume\");\n                        if (File.Exists(resumeFile))\n                        {\n                            File.Delete(resumeFile);\n                        }\n                        var repairFile = Path.Combine(LegendaryLauncher.ConfigPath, \"tmp\", selectedRow.gameID + \".repair\");", "                        if (File.Exists(repairFile))\n                        {\n                            File.Delete(repairFile);\n                        }\n                        if (selectedRow.fullInstallPath != null && selectedRow.downloadProperties.downloadAction == (int)DownloadAction.Install)\n                        {\n                            if (Directory.Exists(selectedRow.fullInstallPath))\n                            {\n                                Directory.Delete(selectedRow.fullInstallPath, true);\n                            }\n                        }\n                        selectedRow.status = (int)DownloadStatus.Canceled;\n                        DownloadSpeedTB.Text = \"\";\n                        DownloadedTB.Text = \"\";\n                        ElapsedTB.Text = \"\";\n                        EtaTB.Text = \"\";\n                        DownloadPB.Value = 0;\n                        SaveData();\n                    }\n                }\n            }\n        }\n", "        private void RemoveDownloadBtn_Click(object sender, RoutedEventArgs e)\n        {\n            if (DownloadsDG.SelectedIndex != -1)\n            {\n                foreach (var selectedRow in DownloadsDG.SelectedItems.Cast<DownloadManagerData.Download>().ToList())\n                {\n                    var result = playniteAPI.Dialogs.ShowMessage(string.Format(ResourceProvider.GetString(LOC.LegendaryRemoveEntryConfirm), selectedRow.name), ResourceProvider.GetString(LOC.LegendaryRemoveEntry), MessageBoxButton.YesNo, MessageBoxImage.Question);\n                    if (result == MessageBoxResult.Yes)\n                    {\n                        var wantedItem = downloadManagerData.downloads.FirstOrDefault(item => item.gameID == selectedRow.gameID);\n                        wantedItem.PropertyChanged -= DoNextJobInQueue;", "                        if (wantedItem.status != (int)DownloadStatus.Completed &&\n                            wantedItem.status != (int)DownloadStatus.Canceled)\n                        {\n                            if (wantedItem.status == (int)DownloadStatus.Running)\n                            {\n                                gracefulInstallerCTS?.Cancel();\n                                gracefulInstallerCTS?.Dispose();\n                                forcefulInstallerCTS?.Dispose();\n                            }\n                            selectedRow.status = (int)DownloadStatus.Canceled;\n                        }\n                        var resumeFile = Path.Combine(LegendaryLauncher.ConfigPath, \"tmp\", selectedRow.gameID + \".resume\");", "                        if (File.Exists(resumeFile))\n                        {\n                            File.Delete(resumeFile);\n                        }\n                        var repairFile = Path.Combine(LegendaryLauncher.ConfigPath, \"tmp\", selectedRow.gameID + \".repair\");\n                        if (File.Exists(repairFile))\n                        {\n                            File.Delete(repairFile);\n                        }\n                        if (selectedRow.fullInstallPath != null && wantedItem.status != (int)DownloadStatus.Completed\n                            && selectedRow.downloadProperties.downloadAction == (int)DownloadAction.Install)\n                        {", "                        if (selectedRow.fullInstallPath != null && wantedItem.status != (int)DownloadStatus.Completed\n                            && selectedRow.downloadProperties.downloadAction == (int)DownloadAction.Install)\n                        {\n                            if (Directory.Exists(selectedRow.fullInstallPath))\n                            {\n                                Directory.Delete(selectedRow.fullInstallPath, true);\n                            }\n                        }\n                        downloadManagerData.downloads.Remove(selectedRow);\n                        SaveData();\n                    }\n                }\n            }\n        }\n", "        private void FilterDownloadBtn_Checked(object sender, RoutedEventArgs e)\n        {\n            FilterPop.IsOpen = true;\n        }\n\n        private void FilterDownloadBtn_Unchecked(object sender, RoutedEventArgs e)\n        {\n            FilterPop.IsOpen = false;\n        }\n\n        private void DownloadFiltersChk_IsCheckedChanged(object sender, RoutedEventArgs e)\n        {\n            ICollectionView downloadsView = CollectionViewSource.GetDefaultView(downloadManagerData.downloads);\n            var checkedStatus = new List<int>();", "        private void DownloadFiltersChk_IsCheckedChanged(object sender, RoutedEventArgs e)\n        {\n            ICollectionView downloadsView = CollectionViewSource.GetDefaultView(downloadManagerData.downloads);\n            var checkedStatus = new List<int>();\n            foreach (CheckBox checkBox in FilterStatusSP.Children)\n            {\n                var downloadStatus = (int)Enum.Parse(typeof(DownloadStatus), checkBox.Name.Replace(\"Chk\", \"\"));\n                if (checkBox.IsChecked == true)\n                {\n                    checkedStatus.Add(downloadStatus);\n                }\n                else\n                {\n                    checkedStatus.Remove(downloadStatus);\n                }\n            }", "            if (checkedStatus.Count > 0)\n            {\n                downloadsView.Filter = item => checkedStatus.Contains((item as DownloadManagerData.Download).status);\n                FilterDownloadBtn.Content = \"\\uef29 \" + ResourceProvider.GetString(\"LOCFilterActiveLabel\");\n            }\n            else\n            {\n                downloadsView.Filter = null;\n                FilterDownloadBtn.Content = \"\\uef29\";\n            }\n        }\n", "        private void SetControlTextBlockStyle()\n        {\n            var baseStyleName = \"BaseTextBlockStyle\";\n            if (playniteAPI.ApplicationInfo.Mode == ApplicationMode.Fullscreen)\n            {\n                baseStyleName = \"TextBlockBaseStyle\";\n            }\n\n            if (ResourceProvider.GetResource(baseStyleName) is Style baseStyle && baseStyle.TargetType == typeof(TextBlock))\n            {\n                var implicitStyle = new Style(typeof(TextBlock), baseStyle);\n                Resources.Add(typeof(TextBlock), implicitStyle);\n            }\n        }\n", "            if (ResourceProvider.GetResource(baseStyleName) is Style baseStyle && baseStyle.TargetType == typeof(TextBlock))\n            {\n                var implicitStyle = new Style(typeof(TextBlock), baseStyle);\n                Resources.Add(typeof(TextBlock), implicitStyle);\n            }\n        }\n\n        private void DownloadPropertiesBtn_Click(object sender, RoutedEventArgs e)\n        {\n            if (DownloadsDG.SelectedIndex != -1)\n            {\n                var window = playniteAPI.Dialogs.CreateWindow(new WindowCreationOptions\n                {\n                    ShowMaximizeButton = false,\n                });\n                var selectedItem = DownloadsDG.SelectedItems[0] as DownloadManagerData.Download;\n                window.Title = selectedItem.name + \" \u2014 \" + ResourceProvider.GetString(LOC.LegendaryDownloadProperties);\n                window.DataContext = selectedItem;\n                window.Content = new LegendaryDownloadProperties();\n                window.Owner = playniteAPI.Dialogs.GetCurrentAppWindow();\n                window.SizeToContent = SizeToContent.WidthAndHeight;\n                window.WindowStartupLocation = WindowStartupLocation.CenterOwner;\n                window.ShowDialog();\n            }\n        }\n", "            if (DownloadsDG.SelectedIndex != -1)\n            {\n                var window = playniteAPI.Dialogs.CreateWindow(new WindowCreationOptions\n                {\n                    ShowMaximizeButton = false,\n                });\n                var selectedItem = DownloadsDG.SelectedItems[0] as DownloadManagerData.Download;\n                window.Title = selectedItem.name + \" \u2014 \" + ResourceProvider.GetString(LOC.LegendaryDownloadProperties);\n                window.DataContext = selectedItem;\n                window.Content = new LegendaryDownloadProperties();\n                window.Owner = playniteAPI.Dialogs.GetCurrentAppWindow();\n                window.SizeToContent = SizeToContent.WidthAndHeight;\n                window.WindowStartupLocation = WindowStartupLocation.CenterOwner;\n                window.ShowDialog();\n            }\n        }\n", "        private void DownloadsDG_SelectionChanged(object sender, SelectionChangedEventArgs e)\n        {\n            if (DownloadsDG.SelectedIndex != -1)\n            {\n                ResumeDownloadBtn.IsEnabled = true;\n                PauseBtn.IsEnabled = true;\n                CancelDownloadBtn.IsEnabled = true;\n                RemoveDownloadBtn.IsEnabled = true;\n                if (DownloadsDG.SelectedItems.Count == 1)\n                {\n                    DownloadPropertiesBtn.IsEnabled = true;\n                }\n                else\n                {\n                    DownloadPropertiesBtn.IsEnabled = false;\n                }\n            }\n            else\n            {\n                ResumeDownloadBtn.IsEnabled = false;\n                PauseBtn.IsEnabled = false;\n                CancelDownloadBtn.IsEnabled = false;\n                RemoveDownloadBtn.IsEnabled = false;\n                DownloadPropertiesBtn.IsEnabled = false;\n            }\n        }\n\n    }\n}\n", "                if (DownloadsDG.SelectedItems.Count == 1)\n                {\n                    DownloadPropertiesBtn.IsEnabled = true;\n                }\n                else\n                {\n                    DownloadPropertiesBtn.IsEnabled = false;\n                }\n            }\n            else\n            {\n                ResumeDownloadBtn.IsEnabled = false;\n                PauseBtn.IsEnabled = false;\n                CancelDownloadBtn.IsEnabled = false;\n                RemoveDownloadBtn.IsEnabled = false;\n                DownloadPropertiesBtn.IsEnabled = false;\n            }\n        }\n\n    }\n}\n"]}
{"filename": "src/NumericInput.xaml.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;", "using System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Documents;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Imaging;\nusing System.Windows.Navigation;\nusing System.Windows.Shapes;\n\nnamespace LegendaryLibraryNS", "\nnamespace LegendaryLibraryNS\n{\n    /// <summary>\n    /// Interaction logic for NumericInput.xaml\n    /// </summary>\n    public partial class NumericInput : UserControl\n    {\n        public NumericInput()\n        {\n            InitializeComponent();\n        }\n", "        public static readonly DependencyProperty MinValueProperty = DependencyProperty.Register(nameof(MinValue), typeof(int), typeof(NumericInput));\n        public static readonly DependencyProperty MaxValueProperty = DependencyProperty.Register(nameof(MaxValue), typeof(int), typeof(NumericInput));\n        public static readonly DependencyProperty StepSizeProperty = DependencyProperty.Register(nameof(StepSize), typeof(int), typeof(NumericInput), new FrameworkPropertyMetadata(\n        1));\n        public static readonly DependencyProperty ValueProperty = DependencyProperty.Register(\"Value\", typeof(string), typeof(NumericInput), new FrameworkPropertyMetadata(\n        \"\", FrameworkPropertyMetadataOptions.BindsTwoWayByDefault));\n\n        public int MinValue\n        {\n            get => (int)GetValue(MinValueProperty);\n            set => SetValue(MinValueProperty, value);\n        }", "        public int MaxValue\n        {\n            get => (int)GetValue(MaxValueProperty);\n            set => SetValue(MaxValueProperty, value);\n        }\n        public int StepSize\n        {\n            get => (int)GetValue(StepSizeProperty);\n            set => SetValue(StepSizeProperty, value);\n        }\n        private string lastGoodValue;", "        private string lastGoodValue;\n        public string Value\n        {\n            get => (string)GetValue(ValueProperty);\n            set => SetValue(ValueProperty, value);\n        }\n\n        private void NumericTxt_TextChanged(object sender, TextChangedEventArgs e)\n        {\n            if (NumericTxt.Text != \"\")\n            {", "            if (NumericTxt.Text != \"\")\n            {\n                if (int.TryParse(NumericTxt.Text, out int number))\n                {\n                    lastGoodValue = NumericTxt.Text;\n                    if (number > MaxValue)\n                    {\n                        NumericTxt.Text = MaxValue.ToString();\n                    }\n                    if (number < MinValue)\n                    {\n                        NumericTxt.Text = MinValue.ToString();\n                    }\n                }\n                else\n                {\n                    NumericTxt.Text = lastGoodValue;\n                }\n                NumericTxt.SelectionStart = NumericTxt.Text.Length;\n            }\n        }\n", "                    if (number < MinValue)\n                    {\n                        NumericTxt.Text = MinValue.ToString();\n                    }\n                }\n                else\n                {\n                    NumericTxt.Text = lastGoodValue;\n                }\n                NumericTxt.SelectionStart = NumericTxt.Text.Length;\n            }\n        }\n", "        private void UserControl_Loaded(object sender, RoutedEventArgs e)\n        {\n            lastGoodValue = !NumericTxt.Text.IsNullOrEmpty() ? NumericTxt.Text : MinValue.ToString();\n        }\n\n        public void Increment()\n        {\n            int number = !NumericTxt.Text.IsNullOrEmpty() ? Convert.ToInt32(NumericTxt.Text) : Convert.ToInt32(lastGoodValue);\n            if (number < MaxValue)\n            {\n                NumericTxt.Text = Convert.ToString(number + StepSize);\n            }\n            NumericTxt.Focus();\n        }\n", "            if (number < MaxValue)\n            {\n                NumericTxt.Text = Convert.ToString(number + StepSize);\n            }\n            NumericTxt.Focus();\n        }\n\n        private void IncrementBtn_Click(object sender, RoutedEventArgs e)\n        {\n            Increment();\n        }\n", "        public void Decrement()\n        {\n            int number = !NumericTxt.Text.IsNullOrEmpty() ? Convert.ToInt32(NumericTxt.Text) : Convert.ToInt32(lastGoodValue);\n            if (number > MinValue)\n            {\n                NumericTxt.Text = Convert.ToString(number - StepSize);\n            }\n            NumericTxt.Focus();\n        }\n\n        private void DecrementBtn_Click(object sender, RoutedEventArgs e)\n        {\n            Decrement();\n        }\n", "        private void DecrementBtn_Click(object sender, RoutedEventArgs e)\n        {\n            Decrement();\n        }\n\n        private void NumericTxt_PreviewKeyDown(object sender, KeyEventArgs e)\n        {\n            if (e.Key == Key.Up)\n            {\n                Increment();\n            }\n", "            if (e.Key == Key.Down)\n            {\n                Decrement();\n            }\n        }\n    }\n}\n"]}
{"filename": "src/EpicMetadataProvider.cs", "chunked_list": ["\ufeffusing LegendaryLibraryNS.Models;\nusing LegendaryLibraryNS.Services;\nusing Playnite.SDK;\nusing Playnite.SDK.Data;\nusing Playnite.SDK.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;", "using System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS\n{\n    public class EpicMetadataProvider : LibraryMetadataProvider\n    {\n        private readonly IPlayniteAPI api;\n\n        public EpicMetadataProvider(IPlayniteAPI api)\n        {\n            this.api = api;\n        }\n", "        private readonly IPlayniteAPI api;\n\n        public EpicMetadataProvider(IPlayniteAPI api)\n        {\n            this.api = api;\n        }\n\n        public override GameMetadata GetMetadata(Game game)\n        {\n            var gameInfo = new GameMetadata() { Links = new List<Link>() };\n\n            // The old search api for metadata we use is completely broken and returns terrible results.\n            // The new API actually checks if a browser makes requests so we would need to switch to a web view.\n            // So this is TODO to update this in future. It's temporarily disabled to make sure we don't apply messed up results.\n", "            //using (var client = new WebStoreClient())\n            //{\n            //    var catalogs = client.QuerySearch(game.Name).GetAwaiter().GetResult();\n            //    if (catalogs.HasItems())\n            //    {\n            //        var catalog = catalogs.FirstOrDefault(a => a.title.Equals(game.Name, StringComparison.InvariantCultureIgnoreCase));\n            //        if (catalog == null)\n            //        {\n            //            return null;\n            //        }\n\n            //        // Some games use completely different way in which the store gets game related data.\n            //        // I don't understand why Epic doesn't have this unified, but the other way totally sucks,\n            //        // so we are not going to support those games right now.", "            //        if (catalog.productSlug.IsNullOrEmpty())\n            //        {\n            //            return null;\n            //        }\n\n            //        var product = client.GetProductInfo(catalog.productSlug).GetAwaiter().GetResult();\n            //        if (product.pages.HasItems())\n            //        {\n            //            var page = product.pages.FirstOrDefault(a => a.type is string type && type == \"productHome\");\n            //            if (page == null)\n            //            {\n            //                page = product.pages[0];\n            //            }\n\n            //            gameInfo.Developers = page.data.about.developerAttribution?.\n            //                Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries).\n            //                Select(a => new MetadataNameProperty(a.Trim())).Cast<MetadataProperty>().ToHashSet();\n            //            gameInfo.Publishers = page.data.about.publisherAttribution?.\n            //                Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries).\n            //                Select(a => new MetadataNameProperty(a.Trim())).Cast<MetadataProperty>().ToHashSet();\n            //            gameInfo.BackgroundImage = new MetadataFile(page.data.hero.backgroundImageUrl);\n            //            gameInfo.Links.Add(new Link(\n            //                api.Resources.GetString(\"LOCCommonLinksStorePage\"),\n            //                \"https://www.epicgames.com/store/en-US/product/\" + catalogs[0].productSlug));\n", "            //            if (page == null)\n            //            {\n            //                page = product.pages[0];\n            //            }\n\n            //            gameInfo.Developers = page.data.about.developerAttribution?.\n            //                Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries).\n            //                Select(a => new MetadataNameProperty(a.Trim())).Cast<MetadataProperty>().ToHashSet();\n            //            gameInfo.Publishers = page.data.about.publisherAttribution?.\n            //                Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries).\n            //                Select(a => new MetadataNameProperty(a.Trim())).Cast<MetadataProperty>().ToHashSet();\n            //            gameInfo.BackgroundImage = new MetadataFile(page.data.hero.backgroundImageUrl);\n            //            gameInfo.Links.Add(new Link(\n            //                api.Resources.GetString(\"LOCCommonLinksStorePage\"),\n            //                \"https://www.epicgames.com/store/en-US/product/\" + catalogs[0].productSlug));\n", "            //            if (page.data.socialLinks.HasItems())\n            //            {\n            //                var links = page.data.socialLinks.\n            //                    Where(a => a.Key.StartsWith(\"link\") && !a.Value.IsNullOrEmpty()).\n            //                    Select(a => new Link(a.Key.Replace(\"link\", \"\"), a.Value)).ToList();\n            //                if (links.HasItems())\n            //                {\n            //                    gameInfo.Links.AddRange(links);\n            //                }\n            //            }\n", "            //            if (!page.data.about.description.IsNullOrEmpty())\n            //            {\n            //                gameInfo.Description = Markup.MarkdownToHtml(page.data.about.description);\n            //            }\n            //        }\n            //    }\n            //}\n\n            //gameInfo.Links.Add(new Link(\"PCGamingWiki\", @\"http://pcgamingwiki.com/w/index.php?search=\" + game.Name));\n\n            // There's not icon available on Epic servers so we will load one from EXE", "            if (game.IsInstalled && string.IsNullOrEmpty(game.Icon))\n            {\n                var installed = LegendaryLauncher.GetInstalledAppList();\n                foreach (KeyValuePair<string, Installed> d in installed)\n                {\n                    if (d.Value.App_name == game.GameId)\n                    {\n                        var exePath = Path.Combine(d.Value.Install_path, d.Value.Executable);\n                        if (File.Exists(exePath))\n                        {\n                            gameInfo.Icon = new MetadataFile(exePath);\n                        }\n                    }\n                }\n            }\n\n            return gameInfo;\n        }\n    }\n}\n", "                        if (File.Exists(exePath))\n                        {\n                            gameInfo.Icon = new MetadataFile(exePath);\n                        }\n                    }\n                }\n            }\n\n            return gameInfo;\n        }\n    }\n}\n"]}
{"filename": "src/LegendaryExcludeOnlineGames.xaml.cs", "chunked_list": ["\ufeffusing Playnite.SDK;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Documents;", "using System.Windows.Data;\nusing System.Windows.Documents;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Imaging;\nusing System.Windows.Navigation;\nusing System.Windows.Shapes;\n\nnamespace LegendaryLibraryNS\n{", "namespace LegendaryLibraryNS\n{\n    /// <summary>\n    /// Interaction logic for LegendaryExcludeOnlineGames.xaml\n    /// </summary>\n    public partial class LegendaryExcludeOnlineGames : UserControl\n    {\n        public LegendaryExcludeOnlineGames()\n        {\n            InitializeComponent();\n            Dispatcher.BeginInvoke((Action)(() =>\n            {\n                var offList = new List<KeyValuePair<string, string>>();\n                var onList = new List<KeyValuePair<string, string>>();\n                var appList = LegendaryLauncher.GetInstalledAppList();", "                foreach (KeyValuePair<string, Models.Installed> d in appList)\n                {\n                    var app = d.Value;\n                    if (LegendaryLibrary.GetSettings().OnlineList.Contains(app.App_name))\n                    {\n                        onList.Add(new KeyValuePair<string, string>(app.App_name, app.Title));\n                    }\n                    else if (!LegendaryLibrary.GetSettings().OnlineList.Contains(app.App_name) && app.Can_run_offline)\n                    {\n                        offList.Add(new KeyValuePair<string, string>(app.App_name, app.Title));\n                    }\n                }\n                OfflineLB.ItemsSource = offList;\n                OnlineLB.ItemsSource = onList;\n            }));\n        }\n", "        private void OnlineBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var selectedKeyValuePairs = OfflineLB.SelectedItems.Cast<KeyValuePair<string, string>>().ToList();\n            var offListItems = OfflineLB.Items.Cast<KeyValuePair<string, string>>().ToList();\n            var onListItems = OnlineLB.Items.Cast<KeyValuePair<string, string>>().ToList();\n            foreach (var sel in selectedKeyValuePairs)\n            {\n                onListItems.Add(new KeyValuePair<string, string>(sel.Key, sel.Value));\n                offListItems.Remove(new KeyValuePair<string, string>(sel.Key, sel.Value));\n            }\n            OfflineLB.ItemsSource = offListItems;\n            OnlineLB.ItemsSource = onListItems;\n        }\n", "        private void OfflineBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var selectedKeyValuePairs = OnlineLB.SelectedItems.Cast<KeyValuePair<string, string>>().ToList();\n            var offListItems = OfflineLB.Items.Cast<KeyValuePair<string, string>>().ToList();\n            var onListItems = OnlineLB.Items.Cast<KeyValuePair<string, string>>().ToList();\n            foreach (var sel in selectedKeyValuePairs)\n            {\n                onListItems.Remove(new KeyValuePair<string, string>(sel.Key, sel.Value));\n                offListItems.Add(new KeyValuePair<string, string>(sel.Key, sel.Value));\n            }\n            OfflineLB.ItemsSource = offListItems;\n            OnlineLB.ItemsSource = onListItems;\n        }\n", "        private void SaveBtn_Click(object sender, RoutedEventArgs e)\n        {\n            LegendaryLibrary.GetSettings().OnlineList = OnlineLB.Items.Cast<KeyValuePair<string, string>>().ToList().Select(a => a.Key).ToList();\n            Window.GetWindow(this).Close();\n        }\n\n        private void CancelBtn_Click(object sender, RoutedEventArgs e)\n        {\n            Window.GetWindow(this).Close();\n        }\n    }\n}\n"]}
{"filename": "src/LegendaryMessagesSettings.cs", "chunked_list": ["\ufeffusing Playnite.Common;\nusing Playnite.SDK.Data;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS", "\nnamespace LegendaryLibraryNS\n{\n    public class LegendaryMessagesSettingsModel\n    {\n        public bool DontShowDownloadManagerWhatsUpMsg { get; set; } = false;\n    }\n\n    public class LegendaryMessagesSettings\n    {\n        public static LegendaryMessagesSettingsModel LoadSettings()\n        {\n            LegendaryMessagesSettingsModel messagesSettings = null;\n            var dataDir = LegendaryLibrary.Instance.GetPluginUserDataPath();\n            var dataFile = Path.Combine(dataDir, \"messages.json\");\n            bool correctJson = false;", "    public class LegendaryMessagesSettings\n    {\n        public static LegendaryMessagesSettingsModel LoadSettings()\n        {\n            LegendaryMessagesSettingsModel messagesSettings = null;\n            var dataDir = LegendaryLibrary.Instance.GetPluginUserDataPath();\n            var dataFile = Path.Combine(dataDir, \"messages.json\");\n            bool correctJson = false;\n            if (File.Exists(dataFile))\n            {\n                if (Serialization.TryFromJson(FileSystem.ReadFileAsStringSafe(dataFile), out messagesSettings))\n                {\n                    correctJson = true;\n                }\n            }", "            if (File.Exists(dataFile))\n            {\n                if (Serialization.TryFromJson(FileSystem.ReadFileAsStringSafe(dataFile), out messagesSettings))\n                {\n                    correctJson = true;\n                }\n            }\n            if (!correctJson)\n            {\n                messagesSettings = new LegendaryMessagesSettingsModel { };\n            }\n            return messagesSettings;\n        }\n", "        public static void SaveSettings(LegendaryMessagesSettingsModel messagesSettings)\n        {\n            var dataDir = LegendaryLibrary.Instance.GetPluginUserDataPath();\n            var dataFile = Path.Combine(dataDir, \"messages.json\");\n            if (!Directory.Exists(dataDir))\n            {\n                Directory.CreateDirectory(dataDir);\n            }\n            var strConf = Serialization.ToJson(messagesSettings, true);\n            if (!strConf.IsNullOrEmpty())\n            {\n                File.WriteAllText(dataFile, strConf);\n            }\n        }\n    }\n}\n", "            if (!strConf.IsNullOrEmpty())\n            {\n                File.WriteAllText(dataFile, strConf);\n            }\n        }\n    }\n}\n"]}
{"filename": "src/LegendaryDownloadProperties.xaml.cs", "chunked_list": ["\ufeffusing LegendaryLibraryNS.Enums;\nusing LegendaryLibraryNS.Models;\nusing Playnite.Common;\nusing Playnite.SDK;\nusing Playnite.SDK.Data;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;", "using System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Documents;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Imaging;", "using System.Windows.Media;\nusing System.Windows.Media.Imaging;\nusing System.Windows.Navigation;\n\nnamespace LegendaryLibraryNS\n{\n    /// <summary>\n    /// Interaction logic for LegendaryDownloadProperties.xaml\n    /// </summary>\n    public partial class LegendaryDownloadProperties : UserControl\n    {\n        private DownloadManagerData.Download SelectedDownload => (DownloadManagerData.Download)DataContext;\n        public DownloadManagerData.Rootobject downloadManagerData;", "    /// </summary>\n    public partial class LegendaryDownloadProperties : UserControl\n    {\n        private DownloadManagerData.Download SelectedDownload => (DownloadManagerData.Download)DataContext;\n        public DownloadManagerData.Rootobject downloadManagerData;\n        private IPlayniteAPI playniteAPI = API.Instance;\n        public List<string> requiredThings;\n\n        public LegendaryDownloadProperties()\n        {\n            InitializeComponent();\n            LoadSavedData();\n        }\n\n        private DownloadManagerData.Rootobject LoadSavedData()\n        {\n            var downloadManager = LegendaryLibrary.GetLegendaryDownloadManager();\n            downloadManagerData = downloadManager.downloadManagerData;\n            return downloadManagerData;\n        }\n", "        private void LegendaryDownloadPropertiesUC_Loaded(object sender, RoutedEventArgs e)\n        {\n            var wantedItem = SelectedDownload;\n            if (wantedItem.downloadProperties != null)\n            {\n                SelectedGamePathTxt.Text = wantedItem.downloadProperties.installPath;\n                ReorderingChk.IsChecked = wantedItem.downloadProperties.enableReordering;\n                MaxWorkersNI.Value = wantedItem.downloadProperties.maxWorkers.ToString();\n                MaxSharedMemoryNI.Value = wantedItem.downloadProperties.maxSharedMemory.ToString();\n                TaskCBo.SelectedValue = wantedItem.downloadProperties.downloadAction;\n            }\n            var downloadActionOptions = new Dictionary<int, string>\n            {\n                { (int)DownloadAction.Install, ResourceProvider.GetString(\"LOCInstallGame\") },\n                { (int)DownloadAction.Repair, ResourceProvider.GetString(LOC.LegendaryRepair) }\n            };\n            TaskCBo.ItemsSource = downloadActionOptions;\n\n            var cacheSDLPath = LegendaryLibrary.Instance.GetCachePath(\"sdlcache\");\n            var cacheSDLFile = Path.Combine(cacheSDLPath, SelectedDownload.gameID + \".json\");\n            requiredThings = new List<string>();", "            if (File.Exists(cacheSDLFile))\n            {\n                var content = FileSystem.ReadFileAsStringSafe(cacheSDLFile);\n                if (Serialization.TryFromJson<Dictionary<string, LegendarySDLInfo>>(content, out var sdlInfo))\n                {\n                    if (sdlInfo.ContainsKey(\"__required\"))\n                    {\n                        foreach (var tag in sdlInfo[\"__required\"].Tags)\n                        {\n                            requiredThings.Add(tag);\n                        }\n                        sdlInfo.Remove(\"__required\");\n                    }", "                    if (wantedItem.downloadProperties != null)\n                    {\n                        foreach (var selectedExtraContent in wantedItem.downloadProperties.extraContent)\n                        {\n                            var wantedExtraItem = sdlInfo.SingleOrDefault(i => i.Value.Tags.Contains(selectedExtraContent));\n                            if (wantedExtraItem.Key != null)\n                            {\n                                ExtraContentLB.SelectedItems.Add(wantedExtraItem);\n                            }\n                        }\n                    }\n                    ExtraContentLB.ItemsSource = sdlInfo;\n                    ExtraContentTbI.Visibility = Visibility.Visible;\n                }\n            }\n        }\n", "        private void ChooseGamePathBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var path = playniteAPI.Dialogs.SelectFolder();\n            if (path != \"\")\n            {\n                SelectedGamePathTxt.Text = path;\n            }\n        }\n\n        private void SaveBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var dataDir = LegendaryLibrary.Instance.GetPluginUserDataPath();\n            var dataFile = Path.Combine(dataDir, \"downloadManager.json\");\n            var wantedItem = downloadManagerData.downloads.FirstOrDefault(item => item.gameID == SelectedDownload.gameID);\n            wantedItem.downloadProperties.installPath = SelectedGamePathTxt.Text;\n            wantedItem.downloadProperties.downloadAction = (int)TaskCBo.SelectedValue;\n            wantedItem.downloadProperties.enableReordering = (bool)ReorderingChk.IsChecked;\n            wantedItem.downloadProperties.maxWorkers = int.Parse(MaxWorkersNI.Value);\n            wantedItem.downloadProperties.maxSharedMemory = int.Parse(MaxSharedMemoryNI.Value);\n            var selectedExtraContent = new List<string>();", "        private void SaveBtn_Click(object sender, RoutedEventArgs e)\n        {\n            var dataDir = LegendaryLibrary.Instance.GetPluginUserDataPath();\n            var dataFile = Path.Combine(dataDir, \"downloadManager.json\");\n            var wantedItem = downloadManagerData.downloads.FirstOrDefault(item => item.gameID == SelectedDownload.gameID);\n            wantedItem.downloadProperties.installPath = SelectedGamePathTxt.Text;\n            wantedItem.downloadProperties.downloadAction = (int)TaskCBo.SelectedValue;\n            wantedItem.downloadProperties.enableReordering = (bool)ReorderingChk.IsChecked;\n            wantedItem.downloadProperties.maxWorkers = int.Parse(MaxWorkersNI.Value);\n            wantedItem.downloadProperties.maxSharedMemory = int.Parse(MaxSharedMemoryNI.Value);\n            var selectedExtraContent = new List<string>();", "            if (requiredThings.Count > 0)\n            {\n                selectedExtraContent.Add(\"\");\n                foreach (var requiredThing in requiredThings)\n                {\n                    selectedExtraContent.Add(requiredThing);\n                }\n            }\n            if (ExtraContentLB.Items.Count > 0)\n            {\n                selectedExtraContent.AddMissing(\"\");", "            if (ExtraContentLB.Items.Count > 0)\n            {\n                selectedExtraContent.AddMissing(\"\");\n                foreach (var selectedOption in ExtraContentLB.SelectedItems.Cast<KeyValuePair<string, LegendarySDLInfo>>().ToList())\n                {\n                    foreach (var tag in selectedOption.Value.Tags)\n                    {\n                        if (!selectedExtraContent.Contains(tag))\n                        {\n                            selectedExtraContent.Add(tag);\n                        }\n                    }\n                }\n            }\n            wantedItem.downloadProperties.extraContent = selectedExtraContent;\n            var strConf = Serialization.ToJson(downloadManagerData, true);\n            File.WriteAllText(dataFile, strConf);\n            var downloadManager = LegendaryLibrary.GetLegendaryDownloadManager();\n            var previouslySelected = downloadManager.DownloadsDG.SelectedIndex;", "            for (int i = 0; i < downloadManager.downloadManagerData.downloads.Count; i++)\n            {\n                if (downloadManager.downloadManagerData.downloads[i].gameID == SelectedDownload.gameID)\n                {\n                    downloadManager.downloadManagerData.downloads[i] = wantedItem;\n                    break;\n                }\n            }\n            downloadManager.DownloadsDG.SelectedIndex = previouslySelected;\n            Window.GetWindow(this).Close();\n        }\n    }\n}\n"]}
{"filename": "src/LegendaryLibrarySettingsViewModel.cs", "chunked_list": ["\ufeffusing LegendaryLibraryNS.Enums;\nusing LegendaryLibraryNS.Services;\nusing Playnite;\nusing Playnite.Commands;\nusing Playnite.SDK;\nusing Playnite.SDK.Data;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;", "using System.Diagnostics;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Media;\n", "using System.Windows.Media;\n\nnamespace LegendaryLibraryNS\n{\n    public class LegendaryLibrarySettings\n    {\n        public bool ImportInstalledGames { get; set; } = LegendaryLauncher.IsInstalled;\n        public bool ConnectAccount { get; set; } = false;\n        public bool ImportUninstalledGames { get; set; } = false;\n        public string SelectedLauncherPath { get; set; } = \"\";\n        public bool UseCustomLauncherPath { get; set; } = false;", "        public bool ImportUninstalledGames { get; set; } = false;\n        public string SelectedLauncherPath { get; set; } = \"\";\n        public bool UseCustomLauncherPath { get; set; } = false;\n        public string GamesInstallationPath { get; set; } = LegendaryLauncher.DefaultGamesInstallationPath;\n        public bool LaunchOffline { get; set; } = false;\n        public List<string> OnlineList { get; set; } = new List<string>();\n        public string PreferredCDN { get; set; } = LegendaryLauncher.DefaultPreferredCDN;\n        public bool NoHttps { get; set; } = LegendaryLauncher.DefaultNoHttps;\n        public int DoActionAfterDownloadComplete { get; set; } = (int)DownloadCompleteAction.Nothing;\n        public bool SyncGameSaves { get; set; } = false;\n        public int MaxWorkers { get; set; } = LegendaryLauncher.DefaultMaxWorkers;", "        public int DoActionAfterDownloadComplete { get; set; } = (int)DownloadCompleteAction.Nothing;\n        public bool SyncGameSaves { get; set; } = false;\n        public int MaxWorkers { get; set; } = LegendaryLauncher.DefaultMaxWorkers;\n        public int MaxSharedMemory { get; set; } = LegendaryLauncher.DefaultMaxSharedMemory;\n        public bool EnableReordering { get; set; } = false;\n        public int AutoClearCache { get; set; } = (int)ClearCacheTime.Never;\n    }\n\n    public class LegendaryLibrarySettingsViewModel : PluginSettingsViewModel<LegendaryLibrarySettings, LegendaryLibrary>\n    {\n        public bool IsUserLoggedIn\n        {\n            get\n            {\n                return new EpicAccountClient(PlayniteApi, LegendaryLauncher.TokensPath).GetIsUserLoggedIn();\n            }\n        }\n\n        public RelayCommand<object> LoginCommand\n        {\n            get => new RelayCommand<object>(async (a) =>\n            {\n                await Login();\n            });\n        }\n\n        public LegendaryLibrarySettingsViewModel(LegendaryLibrary library, IPlayniteAPI api) : base(library, api)\n        {\n            Settings = LoadSavedSettings() ?? new LegendaryLibrarySettings();\n        }\n", "    public class LegendaryLibrarySettingsViewModel : PluginSettingsViewModel<LegendaryLibrarySettings, LegendaryLibrary>\n    {\n        public bool IsUserLoggedIn\n        {\n            get\n            {\n                return new EpicAccountClient(PlayniteApi, LegendaryLauncher.TokensPath).GetIsUserLoggedIn();\n            }\n        }\n\n        public RelayCommand<object> LoginCommand\n        {\n            get => new RelayCommand<object>(async (a) =>\n            {\n                await Login();\n            });\n        }\n\n        public LegendaryLibrarySettingsViewModel(LegendaryLibrary library, IPlayniteAPI api) : base(library, api)\n        {\n            Settings = LoadSavedSettings() ?? new LegendaryLibrarySettings();\n        }\n", "        private async Task Login()\n        {\n            try\n            {\n                var clientApi = new EpicAccountClient(PlayniteApi, LegendaryLauncher.TokensPath);\n                await clientApi.Login();\n                OnPropertyChanged(nameof(IsUserLoggedIn));\n            }\n            catch (Exception e) when (!Debugger.IsAttached)\n            {\n                PlayniteApi.Dialogs.ShowErrorMessage(PlayniteApi.Resources.GetString(LOC.EpicNotLoggedInError), \"\");\n                Logger.Error(e, \"Failed to authenticate user.\");\n            }\n        }\n    }\n}\n", "            catch (Exception e) when (!Debugger.IsAttached)\n            {\n                PlayniteApi.Dialogs.ShowErrorMessage(PlayniteApi.Resources.GetString(LOC.EpicNotLoggedInError), \"\");\n                Logger.Error(e, \"Failed to authenticate user.\");\n            }\n        }\n    }\n}\n"]}
{"filename": "src/LegendaryClient.cs", "chunked_list": ["\ufeffusing Playnite.Common;\nusing Playnite.SDK;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS", "\nnamespace LegendaryLibraryNS\n{\n    public class LegendaryClient : LibraryClient\n    {\n        private static readonly ILogger logger = LogManager.GetLogger();\n\n        public override string Icon => LegendaryLauncher.Icon;\n\n        public override bool IsInstalled => LegendaryLauncher.IsInstalled;\n", "        public override bool IsInstalled => LegendaryLauncher.IsInstalled;\n\n        public override void Open()\n        {\n            LegendaryLauncher.StartClient();\n        }\n\n        public override void Shutdown()\n        {\n            var mainProc = Process.GetProcessesByName(\"Legendary\").FirstOrDefault();\n            if (mainProc == null)\n            {\n                logger.Info(\"Legendary is no longer running, no need to shut it down.\");\n                return;\n            }\n\n            var procRes = ProcessStarter.StartProcessWait(CmdLineTools.TaskKill, $\"/f /pid {mainProc.Id}\", null, out var stdOut, out var stdErr);", "            if (mainProc == null)\n            {\n                logger.Info(\"Legendary is no longer running, no need to shut it down.\");\n                return;\n            }\n\n            var procRes = ProcessStarter.StartProcessWait(CmdLineTools.TaskKill, $\"/f /pid {mainProc.Id}\", null, out var stdOut, out var stdErr);\n            if (procRes != 0)\n            {\n                logger.Error($\"Failed to close Legendary: {procRes}, {stdErr}\");\n            }\n        }\n    }\n}\n"]}
{"filename": "src/Properties/AssemblyInfo.cs", "chunked_list": ["\ufeffusing System.Reflection;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n\n// General Information about an assembly is controlled through the following\n// set of attributes. Change these attribute values to modify the information\n// associated with an assembly.\n[assembly: AssemblyTitle(\"LegendaryLibrary\")]\n[assembly: AssemblyDescription(\"Epic Games Store library integration with Legendary Launcher for Playnite\")]\n[assembly: AssemblyConfiguration(\"\")]", "[assembly: AssemblyDescription(\"Epic Games Store library integration with Legendary Launcher for Playnite\")]\n[assembly: AssemblyConfiguration(\"\")]\n[assembly: AssemblyCompany(\"\")]\n[assembly: AssemblyProduct(\"LegendaryLibrary\")]\n[assembly: AssemblyCopyright(\"Copyright \u00a9 2023 hawkeye116477\\n Copyright \u00a9 2018 Josef Nemec\")]\n[assembly: AssemblyTrademark(\"\")]\n[assembly: AssemblyCulture(\"\")]\n\n// Setting ComVisible to false makes the types in this assembly not visible\n// to COM components.  If you need to access a type in this assembly from", "// Setting ComVisible to false makes the types in this assembly not visible\n// to COM components.  If you need to access a type in this assembly from\n// COM, set the ComVisible attribute to true on that type.\n[assembly: ComVisible(false)]\n\n// The following GUID is for the ID of the typelib if this project is exposed to COM\n[assembly: Guid(\"EAD65C3B-2F8F-4E37-B4E6-B3DE6BE540C6\")]\n\n// Version information for an assembly consists of the following four values:\n//", "// Version information for an assembly consists of the following four values:\n//\n//      Major Version\n//      Minor Version\n//      Build Number\n//      Revision\n//\n// You can specify all the values or you can default the Build and Revision Numbers\n// by using the '*' as shown below:\n// [assembly: AssemblyVersion(\"1.0.*\")]", "// by using the '*' as shown below:\n// [assembly: AssemblyVersion(\"1.0.*\")]\n[assembly: AssemblyVersion(\"1.1.2.*\")]"]}
{"filename": "src/Services/WebStoreClient.cs", "chunked_list": ["\ufeffusing LegendaryLibraryNS.Models;\nusing Playnite.SDK.Data;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Web;\n", "using System.Web;\n\nnamespace LegendaryLibraryNS.Services\n{\n    public class WebStoreClient : IDisposable\n    {\n        private HttpClient httpClient = new HttpClient();\n\n        public const string GraphQLEndpoint = @\"https://graphql.epicgames.com/graphql\";\n        public const string ProductUrlBase = @\"https://store-content.ak.epicgames.com/api/en-US/content/products/{0}\";\n\n        public WebStoreClient()\n        {\n        }\n", "        public const string GraphQLEndpoint = @\"https://graphql.epicgames.com/graphql\";\n        public const string ProductUrlBase = @\"https://store-content.ak.epicgames.com/api/en-US/content/products/{0}\";\n\n        public WebStoreClient()\n        {\n        }\n\n        public void Dispose()\n        {\n            httpClient.Dispose();\n        }\n", "        public async Task<List<WebStoreModels.QuerySearchResponse.SearchStoreElement>> QuerySearch(string searchTerm)\n        {\n            var query = new WebStoreModels.QuerySearch();\n            query.variables.keywords = HttpUtility.UrlPathEncode(searchTerm);\n            var content = new StringContent(Serialization.ToJson(query), Encoding.UTF8, \"application/json\");\n            var response = await httpClient.PostAsync(GraphQLEndpoint, content);\n            var str = await response.Content.ReadAsStringAsync();\n            var data = Serialization.FromJson<WebStoreModels.QuerySearchResponse>(str);\n            return data.data.Catalog.searchStore.elements;\n        }\n", "        public async Task<WebStoreModels.ProductResponse> GetProductInfo(string productSlug)\n        {\n            var slugUri = productSlug.Split('/').First();\n            var productUrl = string.Format(ProductUrlBase, slugUri);\n            var str = await httpClient.GetStringAsync(productUrl);\n            return Serialization.FromJson<WebStoreModels.ProductResponse>(str);\n        }\n    }\n}\n"]}
{"filename": "src/Services/EpicAccountClient.cs", "chunked_list": ["\ufeffusing CliWrap;\nusing CliWrap.Buffered;\nusing CliWrap.EventStream;\nusing LegendaryLibraryNS.Models;\nusing Playnite.Common;\nusing Playnite.SDK;\nusing Playnite.SDK.Data;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;", "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Security.Principal;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading;", "using System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Windows.Media;\n\nnamespace LegendaryLibraryNS.Services\n{\n    public class TokenException : Exception\n    {\n        public TokenException(string message) : base(message)\n        {\n        }\n    }\n", "    public class ApiRedirectResponse\n    {\n        public string redirectUrl { get; set; }\n        public string sid { get; set; }\n        public string authorizationCode { get; set; }\n    }\n\n    public class EpicAccountClient\n    {\n        private ILogger logger = LogManager.GetLogger();\n        private IPlayniteAPI api;", "        private ILogger logger = LogManager.GetLogger();\n        private IPlayniteAPI api;\n        private string tokensPath;\n        private readonly string loginUrl = \"https://www.epicgames.com/id/login?redirectUrl=https%3A//www.epicgames.com/id/api/redirect%3FclientId%3D34a02cf8f4414e29b15921876da36f9a%26responseType%3Dcode\";\n        private readonly string oauthUrl = @\"\";\n        private readonly string accountUrl = @\"\";\n        private readonly string assetsUrl = @\"\";\n        private readonly string catalogUrl = @\"\";\n        private readonly string playtimeUrl = @\"\";\n        private const string authEncodedString = \"MzRhMDJjZjhmNDQxNGUyOWIxNTkyMTg3NmRhMzZmOWE6ZGFhZmJjY2M3Mzc3NDUwMzlkZmZlNTNkOTRmYzc2Y2Y=\";\n        private const string userAgent = @\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Vivaldi/5.5.2805.50\";\n\n        public EpicAccountClient(IPlayniteAPI api, string tokensPath)\n        {\n            this.api = api;\n            this.tokensPath = tokensPath;\n            var oauthUrlMask = @\"https://{0}/account/api/oauth/token\";\n            var accountUrlMask = @\"https://{0}/account/api/public/account/\";\n            var assetsUrlMask = @\"https://{0}/launcher/api/public/assets/Windows?label=Live\";\n            var catalogUrlMask = @\"https://{0}/catalog/api/shared/namespace/\";\n            var playtimeUrlMask = @\"https://{0}/library/api/public/playtime/account/{1}/all\";\n\n            var loadedFromConfig = false;\n", "        private readonly string playtimeUrl = @\"\";\n        private const string authEncodedString = \"MzRhMDJjZjhmNDQxNGUyOWIxNTkyMTg3NmRhMzZmOWE6ZGFhZmJjY2M3Mzc3NDUwMzlkZmZlNTNkOTRmYzc2Y2Y=\";\n        private const string userAgent = @\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Vivaldi/5.5.2805.50\";\n\n        public EpicAccountClient(IPlayniteAPI api, string tokensPath)\n        {\n            this.api = api;\n            this.tokensPath = tokensPath;\n            var oauthUrlMask = @\"https://{0}/account/api/oauth/token\";\n            var accountUrlMask = @\"https://{0}/account/api/public/account/\";\n            var assetsUrlMask = @\"https://{0}/launcher/api/public/assets/Windows?label=Live\";\n            var catalogUrlMask = @\"https://{0}/catalog/api/shared/namespace/\";\n            var playtimeUrlMask = @\"https://{0}/library/api/public/playtime/account/{1}/all\";\n\n            var loadedFromConfig = false;\n", "            if (!loadedFromConfig)\n            {\n                oauthUrl = string.Format(oauthUrlMask, \"account-public-service-prod03.ol.epicgames.com\");\n                accountUrl = string.Format(accountUrlMask, \"account-public-service-prod03.ol.epicgames.com\");\n                assetsUrl = string.Format(assetsUrlMask, \"launcher-public-service-prod06.ol.epicgames.com\");\n                catalogUrl = string.Format(catalogUrlMask, \"catalog-public-service-prod06.ol.epicgames.com\");\n                playtimeUrl = string.Format(playtimeUrlMask, \"library-service.live.use1a.on.epicgames.com\", \"{0}\");\n            }\n        }\n\n        public async Task Login()\n        {\n            var loggedIn = false;\n            var apiRedirectContent = string.Empty;\n", "        public async Task Login()\n        {\n            var loggedIn = false;\n            var apiRedirectContent = string.Empty;\n\n            using (var view = api.WebViews.CreateView(new WebViewSettings\n            {\n                WindowWidth = 580,\n                WindowHeight = 700,\n                // This is needed otherwise captcha won't pass\n                UserAgent = userAgent\n            }))\n            {\n                view.LoadingChanged += async (s, e) =>\n                {\n                    var address = view.GetCurrentAddress();", "                    if (address.StartsWith(@\"https://www.epicgames.com/id/api/redirect\"))\n                    {\n                        apiRedirectContent = await view.GetPageTextAsync();\n                        loggedIn = true;\n                        view.Close();\n                    }\n                };\n\n                view.DeleteDomainCookies(\".epicgames.com\");\n                view.Navigate(loginUrl);\n                view.OpenDialog();\n            }\n", "            if (!loggedIn)\n            {\n                return;\n            }\n\n            if (apiRedirectContent.IsNullOrEmpty())\n            {\n                return;\n            }\n\n            var authorizationCode = Serialization.FromJson<ApiRedirectResponse>(apiRedirectContent).authorizationCode;\n            FileSystem.DeleteFile(tokensPath);", "            if (string.IsNullOrEmpty(authorizationCode))\n            {\n                logger.Error(\"Failed to get login exchange key for Epic account.\");\n                return;\n            }\n\n            var result = await Cli.Wrap(LegendaryLauncher.ClientExecPath)\n                                  .WithArguments(new[] { \"auth\", \"--code\", authorizationCode })\n                                  .WithValidation(CommandResultValidation.None)\n                                  .ExecuteBufferedAsync();\n            if (result.ExitCode != 0 && !result.StandardError.Contains(\"Successfully\"))\n            {\n                logger.Error($\"[Legendary] Failed to authenticate with the Epic Games Store. Error: {result.StandardError}\");\n                return;\n            }\n        }\n", "            if (result.ExitCode != 0 && !result.StandardError.Contains(\"Successfully\"))\n            {\n                logger.Error($\"[Legendary] Failed to authenticate with the Epic Games Store. Error: {result.StandardError}\");\n                return;\n            }\n        }\n\n        public bool GetIsUserLoggedIn()\n        {\n            var tokens = loadTokens();\n            if (tokens == null)\n            {\n                return false;\n            }\n\n            try\n            {\n                var account = InvokeRequest<AccountResponse>(accountUrl + tokens.account_id, tokens).GetAwaiter().GetResult().Item2;\n                return account.id == tokens.account_id;\n            }", "            if (tokens == null)\n            {\n                return false;\n            }\n\n            try\n            {\n                var account = InvokeRequest<AccountResponse>(accountUrl + tokens.account_id, tokens).GetAwaiter().GetResult().Item2;\n                return account.id == tokens.account_id;\n            }\n            catch (Exception e)\n            {", "            catch (Exception e)\n            {\n                if (e is TokenException)\n                {\n                    renewTokens().GetAwaiter().GetResult();\n                    tokens = loadTokens();\n                    if (tokens is null)\n                    {\n                        return false;\n                    }\n                    var account = InvokeRequest<AccountResponse>(accountUrl + tokens.account_id, tokens).GetAwaiter().GetResult().Item2;\n                    return account.id == tokens.account_id;\n                }\n                else\n                {\n                    logger.Error(e, \"Failed to validation Epic authentication.\");\n                    return false;\n                }\n            }\n        }\n\n        public List<Asset> GetAssets()\n        {", "            if (!GetIsUserLoggedIn())\n            {\n                throw new Exception(\"User is not authenticated.\");\n            }\n\n            return InvokeRequest<List<Asset>>(assetsUrl, loadTokens()).GetAwaiter().GetResult().Item2;\n        }\n\n        public List<PlaytimeItem> GetPlaytimeItems()\n        {\n            if (!GetIsUserLoggedIn())\n            {\n                throw new Exception(\"User is not authenticated.\");\n            }\n\n            var tokens = loadTokens();\n            var formattedPlaytimeUrl = string.Format(playtimeUrl, tokens.account_id);\n            return InvokeRequest<List<PlaytimeItem>>(formattedPlaytimeUrl, tokens).GetAwaiter().GetResult().Item2;\n        }\n", "            if (!GetIsUserLoggedIn())\n            {\n                throw new Exception(\"User is not authenticated.\");\n            }\n\n            var tokens = loadTokens();\n            var formattedPlaytimeUrl = string.Format(playtimeUrl, tokens.account_id);\n            return InvokeRequest<List<PlaytimeItem>>(formattedPlaytimeUrl, tokens).GetAwaiter().GetResult().Item2;\n        }\n\n        public CatalogItem GetCatalogItem(string nameSpace, string id, string cachePath)\n        {\n            Dictionary<string, CatalogItem> result = null;", "        public CatalogItem GetCatalogItem(string nameSpace, string id, string cachePath)\n        {\n            Dictionary<string, CatalogItem> result = null;\n            if (!cachePath.IsNullOrEmpty() && FileSystem.FileExists(cachePath))\n            {\n                try\n                {\n                    result = Serialization.FromJson<Dictionary<string, CatalogItem>>(FileSystem.ReadStringFromFile(cachePath));\n                }\n                catch (Exception e)\n                {\n                    logger.Error(e, \"Failed to load Epic catalog cache.\");\n                }\n            }\n", "                catch (Exception e)\n                {\n                    logger.Error(e, \"Failed to load Epic catalog cache.\");\n                }\n            }\n\n            if (result == null)\n            {\n                var url = string.Format(\"{0}/bulk/items?id={1}&country=US&locale=en-US\", nameSpace, id);\n                var catalogResponse = InvokeRequest<Dictionary<string, CatalogItem>>(catalogUrl + url, loadTokens()).GetAwaiter().GetResult();\n                result = catalogResponse.Item2;\n                FileSystem.WriteStringToFile(cachePath, catalogResponse.Item1);\n            }\n", "            if (result.TryGetValue(id, out var catalogItem))\n            {\n                return catalogItem;\n            }\n            else\n            {\n                throw new Exception($\"Epic catalog item for {id} {nameSpace} not found.\");\n            }\n        }\n\n        private async Task renewTokens()\n        {\n            var cmd = Cli.Wrap(LegendaryLauncher.ClientExecPath)\n                         .WithArguments(\"auth\");\n            using var forcefulCTS = new CancellationTokenSource();\n            using var gracefulCTS = new CancellationTokenSource();\n            try\n            {", "        private async Task renewTokens()\n        {\n            var cmd = Cli.Wrap(LegendaryLauncher.ClientExecPath)\n                         .WithArguments(\"auth\");\n            using var forcefulCTS = new CancellationTokenSource();\n            using var gracefulCTS = new CancellationTokenSource();\n            try\n            {\n                await foreach (CommandEvent cmdEvent in cmd.ListenAsync(Console.OutputEncoding, Console.OutputEncoding, forcefulCTS.Token, gracefulCTS.Token))\n                {\n                    switch (cmdEvent)\n                    {\n                        case StandardErrorCommandEvent stdErr:\n                            // If tokens can't be renewed, Legendary will try to open web browser\n                            // and demand an answer from user,\n                            // so we need to prevent that.", "                await foreach (CommandEvent cmdEvent in cmd.ListenAsync(Console.OutputEncoding, Console.OutputEncoding, forcefulCTS.Token, gracefulCTS.Token))\n                {\n                    switch (cmdEvent)\n                    {\n                        case StandardErrorCommandEvent stdErr:\n                            // If tokens can't be renewed, Legendary will try to open web browser\n                            // and demand an answer from user,\n                            // so we need to prevent that.\n                            if (stdErr.Text.Contains(\"no longer valid\"))\n                            {\n                                gracefulCTS.Cancel();\n                                gracefulCTS?.Dispose();\n                                forcefulCTS?.Dispose();\n                            }\n                            break;\n                        case ExitedCommandEvent exited:\n                            gracefulCTS?.Dispose();\n                            forcefulCTS?.Dispose();\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }", "                            if (stdErr.Text.Contains(\"no longer valid\"))\n                            {\n                                gracefulCTS.Cancel();\n                                gracefulCTS?.Dispose();\n                                forcefulCTS?.Dispose();\n                            }\n                            break;\n                        case ExitedCommandEvent exited:\n                            gracefulCTS?.Dispose();\n                            forcefulCTS?.Dispose();\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }", "            catch (OperationCanceledException)\n            {\n                // Command was canceled\n            }\n        }\n\n        private async Task<Tuple<string, T>> InvokeRequest<T>(string url, OauthResponse tokens) where T : class\n        {\n            using (var httpClient = new HttpClient())\n            {\n                httpClient.DefaultRequestHeaders.Clear();\n                httpClient.DefaultRequestHeaders.Add(\"Authorization\", tokens.token_type + \" \" + tokens.access_token);\n                var response = await httpClient.GetAsync(url);\n                var str = await response.Content.ReadAsStringAsync();\n", "            using (var httpClient = new HttpClient())\n            {\n                httpClient.DefaultRequestHeaders.Clear();\n                httpClient.DefaultRequestHeaders.Add(\"Authorization\", tokens.token_type + \" \" + tokens.access_token);\n                var response = await httpClient.GetAsync(url);\n                var str = await response.Content.ReadAsStringAsync();\n\n                if (Serialization.TryFromJson<ErrorResponse>(str, out var error) && !string.IsNullOrEmpty(error.errorCode))\n                {\n                    throw new TokenException(error.errorCode);\n                }\n                else\n                {\n                    try\n                    {\n                        return new Tuple<string, T>(str, Serialization.FromJson<T>(str));\n                    }\n                    catch\n                    {\n                        // For cases like #134, where the entire service is down and doesn't even return valid error messages.\n                        logger.Error(str);\n                        throw new Exception(\"Failed to get data from Epic service.\");\n                    }\n                }\n            }\n        }\n", "        private OauthResponse loadTokens()\n        {\n            if (File.Exists(tokensPath))\n            {\n                try\n                {\n                    return Serialization.FromJson<OauthResponse>(FileSystem.ReadFileAsStringSafe(tokensPath));\n                }\n                catch (Exception e)\n                {\n                    logger.Error(e, \"Failed to load saved tokens.\");\n                }\n            }\n\n            return null;\n        }\n", "                catch (Exception e)\n                {\n                    logger.Error(e, \"Failed to load saved tokens.\");\n                }\n            }\n\n            return null;\n        }\n\n        private string getExchangeToken(string sid)\n        {\n            var cookieContainer = new CookieContainer();", "        private string getExchangeToken(string sid)\n        {\n            var cookieContainer = new CookieContainer();\n            using (var handler = new HttpClientHandler() { CookieContainer = cookieContainer })\n            using (var httpClient = new HttpClient(handler))\n            {\n                httpClient.DefaultRequestHeaders.Clear();\n                httpClient.DefaultRequestHeaders.Add(\"X-Epic-Event-Action\", \"login\");\n                httpClient.DefaultRequestHeaders.Add(\"X-Epic-Event-Category\", \"login\");\n                httpClient.DefaultRequestHeaders.Add(\"X-Epic-Strategy-Flags\", \"\");\n                httpClient.DefaultRequestHeaders.Add(\"X-Requested-With\", \"XMLHttpRequest\");\n                httpClient.DefaultRequestHeaders.Add(\"User-Agent\", userAgent);\n\n                httpClient.GetAsync(@\"https://www.epicgames.com/id/api/set-sid?sid=\" + sid).GetAwaiter().GetResult();\n                var resp = httpClient.GetAsync(@\"https://www.epicgames.com/id/api/csrf\").GetAwaiter().GetResult();\n                var cookies = resp.Headers.Single(header => header.Key == \"Set-Cookie\").Value;", "                if (cookies != null)\n                {\n                    var match = Regex.Match(cookies.First(), @\"=(.+);\");\n                    var xsrf = match.Groups[1].Value;\n                    httpClient.DefaultRequestHeaders.Add(\"X-XSRF-TOKEN\", xsrf);\n                    var country = \"US\";\n                    try\n                    {\n                        country = System.Globalization.CultureInfo.CurrentCulture.Name.Split(new char[] { '-' }).Last();\n                    }\n                    catch (Exception e)\n                    {\n                        logger.Error(e, $\"Failed to get country for auth request.\");\n                    }\n\n                    cookieContainer.Add(new Uri(\"https://www.epicgames.com\"), new Cookie(\"EPIC_COUNTRY\", country));\n                    resp = httpClient.PostAsync(\"https://www.epicgames.com/id/api/exchange/generate\", null).GetAwaiter().GetResult();\n                    var respContent = resp.Content.ReadAsStringAsync().GetAwaiter().GetResult();\n                    return Serialization.FromJson<Dictionary<string, string>>(respContent)[\"code\"];\n                }\n                else\n                {\n                    return null;\n                }\n            }\n        }\n    }\n}\n", "                    catch (Exception e)\n                    {\n                        logger.Error(e, $\"Failed to get country for auth request.\");\n                    }\n\n                    cookieContainer.Add(new Uri(\"https://www.epicgames.com\"), new Cookie(\"EPIC_COUNTRY\", country));\n                    resp = httpClient.PostAsync(\"https://www.epicgames.com/id/api/exchange/generate\", null).GetAwaiter().GetResult();\n                    var respContent = resp.Content.ReadAsStringAsync().GetAwaiter().GetResult();\n                    return Serialization.FromJson<Dictionary<string, string>>(respContent)[\"code\"];\n                }\n                else\n                {\n                    return null;\n                }\n            }\n        }\n    }\n}\n"]}
{"filename": "src/Models/LegendaryMetadata.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS.Models\n{\n    class LegendaryMetadata\n    {\n        public class Rootobject\n        {", "    class LegendaryMetadata\n    {\n        public class Rootobject\n        {\n            public string app_name { get; set; }\n            public string app_title { get; set; }\n            public Asset_Infos asset_infos { get; set; }\n            public string[] base_urls { get; set; }\n            public Metadata1 metadata { get; set; }\n        }\n", "            public Metadata1 metadata { get; set; }\n        }\n\n        public class Asset_Infos\n        {\n            public Windows Windows { get; set; }\n        }\n\n        public class Windows\n        {\n            public string app_name { get; set; }", "        public class Windows\n        {\n            public string app_name { get; set; }\n            public string asset_id { get; set; }\n            public string build_version { get; set; }\n            public string catalog_item_id { get; set; }\n            public string label_name { get; set; }\n            public Metadata metadata { get; set; }\n            public string _namespace { get; set; }\n        }\n", "            public string _namespace { get; set; }\n        }\n\n        public class Metadata\n        {\n        }\n\n        public class Metadata1\n        {\n            public Agegatings ageGatings { get; set; }\n            public Category[] categories { get; set; }", "            public Agegatings ageGatings { get; set; }\n            public Category[] categories { get; set; }\n            public DateTime creationDate { get; set; }\n            public Customattributes customAttributes { get; set; }\n            public string description { get; set; }\n            public string developer { get; set; }\n            public string developerId { get; set; }\n            public bool endOfSupport { get; set; }\n            public string entitlementName { get; set; }\n            public string entitlementType { get; set; }\n            public string[] eulaIds { get; set; }", "            public string entitlementName { get; set; }\n            public string entitlementType { get; set; }\n            public string[] eulaIds { get; set; }\n            public string id { get; set; }\n            public string itemType { get; set; }\n            public Keyimage[] keyImages { get; set; }\n            public DateTime lastModifiedDate { get; set; }\n            public string _namespace { get; set; }\n            public Releaseinfo[] releaseInfo { get; set; }\n            public string status { get; set; }\n            public string title { get; set; }", "            public string status { get; set; }\n            public string title { get; set; }\n            public bool unsearchable { get; set; }\n        }\n\n        public class Agegatings\n        {\n        }\n\n        public class Customattributes\n        {", "        public class Customattributes\n        {\n            public Canrunoffline CanRunOffline { get; set; }\n            public Canskipkoreanidverification CanSkipKoreanIdVerification { get; set; }\n            public Cloudincludelist CloudIncludeList { get; set; }\n            public Cloudsavefolder CloudSaveFolder { get; set; }\n            public Foldername FolderName { get; set; }\n            public Monitorpresence MonitorPresence { get; set; }\n            public Presenceid PresenceId { get; set; }\n            public Requirementsjson RequirementsJson { get; set; }\n            public Useaccesscontrol UseAccessControl { get; set; }\n        }\n", "            public Presenceid PresenceId { get; set; }\n            public Requirementsjson RequirementsJson { get; set; }\n            public Useaccesscontrol UseAccessControl { get; set; }\n        }\n\n        public class Canrunoffline\n        {\n            public string type { get; set; }\n            public string value { get; set; }\n        }\n", "            public string value { get; set; }\n        }\n\n        public class Canskipkoreanidverification\n        {\n            public string type { get; set; }\n            public string value { get; set; }\n        }\n\n        public class Cloudincludelist\n        {", "        public class Cloudincludelist\n        {\n            public string type { get; set; }\n            public string value { get; set; }\n        }\n\n        public class Cloudsavefolder\n        {\n            public string type { get; set; }\n            public string value { get; set; }\n        }\n", "            public string type { get; set; }\n            public string value { get; set; }\n        }\n\n        public class Foldername\n        {\n            public string type { get; set; }\n            public string value { get; set; }\n        }\n\n        public class Monitorpresence\n        {", "        public class Monitorpresence\n        {\n            public string type { get; set; }\n            public string value { get; set; }\n        }\n\n        public class Presenceid\n        {\n            public string type { get; set; }\n            public string value { get; set; }\n        }\n", "            public string type { get; set; }\n            public string value { get; set; }\n        }\n\n        public class Requirementsjson\n        {\n            public string type { get; set; }\n            public string value { get; set; }\n        }\n\n        public class Useaccesscontrol\n        {", "        public class Useaccesscontrol\n        {\n            public string type { get; set; }\n            public string value { get; set; }\n        }\n\n        public class Category\n        {\n            public string path { get; set; }\n        }\n", "            public string path { get; set; }\n        }\n\n        public class Keyimage\n        {\n            public int height { get; set; }\n            public string md5 { get; set; }\n            public int size { get; set; }\n            public string type { get; set; }\n            public DateTime uploadedDate { get; set; }\n            public string url { get; set; }", "            public string type { get; set; }\n            public DateTime uploadedDate { get; set; }\n            public string url { get; set; }\n            public int width { get; set; }\n        }\n\n        public class Releaseinfo\n        {\n            public string appId { get; set; }\n            public DateTime dateAdded { get; set; }\n            public string id { get; set; }\n            public string[] platform { get; set; }\n        }\n\n    }\n}\n", "            public string appId { get; set; }\n            public DateTime dateAdded { get; set; }\n            public string id { get; set; }\n            public string[] platform { get; set; }\n        }\n\n    }\n}\n"]}
{"filename": "src/Models/AssetsResponse.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS.Models\n{\n    public class Asset\n    {\n        public string appName;", "    public class Asset\n    {\n        public string appName;\n        public string labelName;\n        public string buildVersion;\n        public string catalogItemId;\n        public string @namespace;\n        public string assetId;\n    }\n}\n"]}
{"filename": "src/Models/ErrorResponse.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS.Models\n{\n    public class ErrorResponse\n    {\n        public string errorCode;", "    public class ErrorResponse\n    {\n        public string errorCode;\n        public string errorMessage;\n        public int numericErrorCode;\n        public string originatingService;\n        public string intent;\n    }\n}\n"]}
{"filename": "src/Models/Installed.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS.Models\n{\n    public class Installed\n    {\n        public string Key_name { get; set; }", "    public class Installed\n    {\n        public string Key_name { get; set; }\n        public string App_name { get; set; }\n        public bool Can_run_offline { get; set; }\n        public string Executable { get; set; }\n        public string Install_path { get; set; }\n        public long Install_size { get; set; }\n        public bool Is_dlc { get; set; }\n        public string Title { get; set; }\n        public string Version { get; set; }\n    }\n}\n", "        public bool Is_dlc { get; set; }\n        public string Title { get; set; }\n        public string Version { get; set; }\n    }\n}\n"]}
{"filename": "src/Models/CatalogResponse.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS.Models\n{\n    public class CatalogItem\n    {\n        public class CustomAttribute\n        {", "    public class CatalogItem\n    {\n        public class CustomAttribute\n        {\n            public string type;\n            public string value;\n        }\n\n        public class Image\n        {\n            public string url;", "        public class Image\n        {\n            public string url;\n            public string type;\n        }\n\n        public class Category\n        {\n            public string path;\n        }\n", "            public string path;\n        }\n\n        public class ReleaseInfo\n        {\n            public string appId;\n            public List<string> platform;\n            public DateTime? dateAdded;\n        }\n\n        public string id;", "        public string id;\n        public string title;\n        public string description;\n        public List<Image> keyImages;\n        public List<Category> categories;\n        public string @namespace;\n        public string status;\n        public DateTime? creationDate;\n        public DateTime? lastModifiedDate;\n        public Dictionary<string, CustomAttribute> customAttributes;\n        public string entitlementName;", "        public string entitlementName;\n        public string entitlementType;\n        public string itemType;\n        public List<ReleaseInfo> releaseInfo;\n        public string developer;\n        public string developerId;\n        public bool endOfSupport;\n    }\n\n\n}\n"]}
{"filename": "src/Models/AccountResponse.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS.Models\n{\n    public class AccountResponse\n    {\n        public string id;", "    public class AccountResponse\n    {\n        public string id;\n        public string displayName;\n    }\n}\n"]}
{"filename": "src/Models/DownloadManagerData.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\nusing System.ComponentModel;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS.Models\n{\n    public class DownloadManagerData\n    {", "namespace LegendaryLibraryNS.Models\n{\n    public class DownloadManagerData\n    {\n        public class Rootobject\n        {\n            public ObservableCollection<Download> downloads { get; set; }\n        }\n\n        public class Download : ObservableObject\n        {", "        public class Download : ObservableObject\n        {\n            public string gameID { get; set; }\n            public string name { get; set; }\n            public string fullInstallPath { get; set; }\n\n            private string _downloadSize;\n            public string downloadSize\n            {\n                get => _downloadSize;\n                set => SetValue(ref _downloadSize, value);\n            }", "            private string _installSize;\n            public string installSize\n            {\n                get => _installSize;\n                set => SetValue(ref _installSize, value);\n            }\n\n            public long addedTime { get; set; }\n\n            private long _completedTime;\n            public long completedTime\n            {\n                get => _completedTime;\n                set => SetValue(ref _completedTime, value);\n            }\n", "            private long _completedTime;\n            public long completedTime\n            {\n                get => _completedTime;\n                set => SetValue(ref _completedTime, value);\n            }\n\n            private int _status;\n            public int status\n            {\n                get => _status;\n                set => SetValue(ref _status, value);\n            }\n", "            public int status\n            {\n                get => _status;\n                set => SetValue(ref _status, value);\n            }\n\n            public DownloadProperties downloadProperties { get; set; }\n        }\n    }\n\n    public class DownloadProperties : ObservableObject\n    {", "    public class DownloadProperties : ObservableObject\n    {\n        public string installPath { get; set; } = \"\";\n        public int downloadAction { get; set; }\n        public bool enableReordering { get; set; }\n        public int maxWorkers { get; set; }\n        public int maxSharedMemory { get; set; }\n        public List<string> extraContent { get; set; } = default;\n    }\n}\n"]}
{"filename": "src/Models/OauthResponse.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS.Models\n{\n    public class OauthResponse\n    {\n        public string access_token;", "    public class OauthResponse\n    {\n        public string access_token;\n        public long expires_in;\n        public DateTime expires_at;\n        public string token_type;\n        public string refresh_token;\n        public long refresh_expires;\n        public DateTime refresh_expires_at;\n        public string account_id;\n        public string client_id;", "        public DateTime refresh_expires_at;\n        public string account_id;\n        public string client_id;\n        public bool internal_client;\n        public string client_service;\n        public string app;\n        public string in_app_id;\n        public string device_id;\n    }\n}\n"]}
{"filename": "src/Models/PlaytimesResponse.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS.Models\n{\n    public class PlaytimeItem\n    {\n        public string accountId;", "    public class PlaytimeItem\n    {\n        public string accountId;\n        public string artifactId;\n        public ulong totalTime;\n    }\n}"]}
{"filename": "src/Models/LegendarySDLInfo.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS.Models\n{\n    public class LegendarySDLInfo\n    {\n        public string Key_name { get; set; }", "    public class LegendarySDLInfo\n    {\n        public string Key_name { get; set; }\n        public string Description { get; set; }\n        public string Name { get; set; }\n        public List<string> Tags { get; set; }\n    }\n}\n"]}
{"filename": "src/Models/WebStoreModels.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS.Models\n{\n    public class WebStoreModels\n    {\n        public class QuerySearch\n        {", "    public class WebStoreModels\n    {\n        public class QuerySearch\n        {\n            public class Variables\n            {\n                public string locale = \"en-US\";\n                public string country = \"US\";\n                public string allowCountries = \"US\";\n                public string sortDir = \"DESC\";\n                public string category = \"games/edition/base|bundles/games|editors\";", "                public string allowCountries = \"US\";\n                public string sortDir = \"DESC\";\n                public string category = \"games/edition/base|bundles/games|editors\";\n                public string keywords;\n            }\n\n            public Variables variables = new Variables();\n            public string query = @\"query searchStoreQuery($allowCountries: String, $category: String, $count: Int, $country: String!, $keywords: String, $locale: String, $namespace: String, $itemNs: String, $sortBy: String, $sortDir: String, $start: Int, $tag: String, $releaseDate: String, $withPrice: Boolean = false, $withPromotions: Boolean = false) {  Catalog {    searchStore(allowCountries: $allowCountries, category: $category, count: $count, country: $country, keywords: $keywords, locale: $locale, namespace: $namespace, itemNs: $itemNs, sortBy: $sortBy, sortDir: $sortDir, releaseDate: $releaseDate, start: $start, tag: $tag) {      elements {        title        id        namespace        description        effectiveDate        keyImages {          type          url        }        seller {          id          name        }        productSlug        urlSlug        url        tags {          id        }        items {          id          namespace        }        customAttributes {          key          value        }        categories {          path        }        price(country: $country) @include(if: $withPrice) {          totalPrice {            discountPrice            originalPrice            voucherDiscount            discount            currencyCode            currencyInfo {              decimals            }            fmtPrice(locale: $locale) {              originalPrice              discountPrice              intermediatePrice            }          }          lineOffers {            appliedRules {              id              endDate              discountSetting {                discountType              }            }          }        }        promotions(category: $category) @include(if: $withPromotions) {          promotionalOffers {            promotionalOffers {              startDate              endDate              discountSetting {                discountType                discountPercentage              }            }          }          upcomingPromotionalOffers {            promotionalOffers {              startDate              endDate              discountSetting {                discountType                discountPercentage              }            }          }        }      }      paging {        count        total      }    }  }}\";\n        }\n\n        public class QuerySearchResponse\n        {", "        public class QuerySearchResponse\n        {\n            public class SearchStoreElement\n            {\n                public string url;\n                public string title;\n                public string id;\n                public string productSlug;\n            }\n\n            public class Data\n            {", "            public class Data\n            {\n                public class CatalogItem\n                {\n                    public class SearchStore\n                    {\n                        public List<SearchStoreElement> elements;\n                    }\n\n                    public SearchStore searchStore;\n                }\n", "                    public SearchStore searchStore;\n                }\n\n                public CatalogItem Catalog;\n            }\n\n            public Data data;\n        }\n\n        public class ProductResponse\n        {", "        public class ProductResponse\n        {\n            public class PageData\n            {\n                public class About\n                {\n                    public string developerAttribution;\n                    public string publisherAttribution;\n                    public string description;\n                    public string title;\n                }\n", "                    public string description;\n                    public string title;\n                }\n\n                public class Hero\n                {\n                    public string portraitBackgroundImageUrl;\n                    public string backgroundImageUrl;\n                }\n\n                public Dictionary<string, string> socialLinks;", "                public About about;\n                public Hero hero;\n            }\n\n            public class Page\n            {\n                public string @namespace;\n                public string _title;\n                public string regionBlock;\n                public string productName;\n                public string _urlPattern;", "                public string regionBlock;\n                public string productName;\n                public string _urlPattern;\n                public string _slug;\n                public DateTime? _activeDate;\n                public DateTime? lastModified;\n                public string _locale;\n                public string _id;\n                public PageData data;\n                public string tag;\n                public object type;\n            }\n\n            public string @namespace;", "                public PageData data;\n                public string tag;\n                public object type;\n            }\n\n            public string @namespace;\n            public string _title;\n            public string regionBlock;\n            public string productName;\n            public string _urlPattern;\n            public string _slug;\n            public DateTime? _activeDate;\n            public DateTime? lastModified;", "            public string productName;\n            public string _urlPattern;\n            public string _slug;\n            public DateTime? _activeDate;\n            public DateTime? lastModified;\n            public string _locale;\n            public string _id;\n            public List<Page> pages;\n        }\n    }\n}\n"]}
{"filename": "src/Models/LegendaryGameInfo.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS.Models\n{\n    public class LegendaryGameInfo\n    {\n        public class Rootobject\n        {", "    public class LegendaryGameInfo\n    {\n        public class Rootobject\n        {\n            public Game Game { get; set; }\n            public Manifest Manifest { get; set; }\n        }\n\n        public class Game\n        {\n            public string App_name { get; set; }", "        public class Game\n        {\n            public string App_name { get; set; }\n            public string Title { get; set; }\n            public string Version { get; set; }\n            public bool Cloud_saves_supported { get; set; }\n            public bool Is_dlc { get; set; }\n        }\n\n        public class Manifest\n        {", "        public class Manifest\n        {\n            public double Disk_size { get; set; }\n            public double Download_size { get; set; }\n            public string Launch_exe { get; set; }\n            public string[] Install_tags { get; set; }\n            public Tag_Disk_Size[] Tag_disk_size { get; set; }\n            public Tag_Download_Size[] Tag_download_size { get; set; }\n        }\n\n        public class Tag_Disk_Size\n        {", "        public class Tag_Disk_Size\n        {\n            public string Tag { get; set; }\n            public double Size { get; set; }\n            public int Count { get; set; }\n        }\n\n        public class Tag_Download_Size\n        {\n            public string Tag { get; set; }\n            public double Size { get; set; }", "            public string Tag { get; set; }\n            public double Size { get; set; }\n            public int Count { get; set; }\n        }\n    }\n}\n"]}
{"filename": "src/Enums/ClearCacheTime.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS.Enums\n{\n    public enum ClearCacheTime\n    {\n        Never,\n        Day,\n        Week,\n        Month,\n        ThreeMonths,\n        SixMonths,\n    }\n}\n", "    public enum ClearCacheTime\n    {\n        Never,\n        Day,\n        Week,\n        Month,\n        ThreeMonths,\n        SixMonths,\n    }\n}\n"]}
{"filename": "src/Enums/DownloadCompleteAction.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS.Enums\n{\n    public enum DownloadCompleteAction\n    {\n        Nothing,\n        ShutDown,\n        Reboot,\n        Hibernate,\n        Sleep\n    };\n}\n", "    public enum DownloadCompleteAction\n    {\n        Nothing,\n        ShutDown,\n        Reboot,\n        Hibernate,\n        Sleep\n    };\n}\n"]}
{"filename": "src/Enums/DownloadStatus.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS.Enums\n{\n    public enum DownloadStatus\n    {\n        Queued,\n        Running,\n        Paused,\n        Canceled,\n        Completed\n    }\n}\n", "    public enum DownloadStatus\n    {\n        Queued,\n        Running,\n        Paused,\n        Canceled,\n        Completed\n    }\n}\n"]}
{"filename": "src/Enums/DownloadAction.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace LegendaryLibraryNS.Enums\n{\n    public enum DownloadAction\n    {\n        Install,\n        Repair\n    }\n}\n", "    public enum DownloadAction\n    {\n        Install,\n        Repair\n    }\n}\n"]}
{"filename": "src/Converters/LongToDateConverter.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Data;\n\nnamespace LegendaryLibraryNS.Converters\n{\n    public class LongToDateConverter : IValueConverter\n    {", "namespace LegendaryLibraryNS.Converters\n{\n    public class LongToDateConverter : IValueConverter\n    {\n        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n        {\n            if (!(value is long seconds))\n                return value;\n            DateTime dateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);\n            if (seconds == 0)\n            {\n                return \"\";\n            }\n            return dateTime.AddSeconds(seconds).ToLocalTime();\n        }\n", "            if (seconds == 0)\n            {\n                return \"\";\n            }\n            return dateTime.AddSeconds(seconds).ToLocalTime();\n        }\n\n        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n        {\n            return new NotImplementedException();\n        }\n    }\n}\n"]}
{"filename": "src/Converters/DownloadStatusEnumToStringConverter.cs", "chunked_list": ["\ufeffusing LegendaryLibraryNS.Enums;\nusing Playnite.SDK;\nusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Net;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Data;", "using System.Threading.Tasks;\nusing System.Windows.Data;\n\nnamespace LegendaryLibraryNS.Converters\n{\n    public class DownloadStatusEnumToStringConverter : IValueConverter\n    {\n        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)\n        {\n            switch((int)value)\n            {\n                case (int)DownloadStatus.Queued:\n                    value = ResourceProvider.GetString(LOC.LegendaryDownloadQueued);\n                    break;\n                case (int)DownloadStatus.Running:\n                    value = ResourceProvider.GetString(LOC.LegendaryDownloadRunning);\n                    break;\n                case (int)DownloadStatus.Canceled:\n                    value = ResourceProvider.GetString(LOC.LegendaryDownloadCanceled);\n                    break;\n                case (int)DownloadStatus.Paused:\n                    value = ResourceProvider.GetString(LOC.LegendaryDownloadPaused);\n                    break;\n                case (int)DownloadStatus.Completed:\n                    value = ResourceProvider.GetString(LOC.LegendaryDownloadCompleted);\n                    break;\n            }\n            return value;\n        }\n", "        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)\n        {\n            throw new NotImplementedException();\n        }\n    }\n}\n"]}
