{"filename": "WaypointsPlugin.cs", "chunked_list": ["\ufeffusing BepInEx;\nusing DrakiaXYZ.BigBrain.Brains;\nusing DrakiaXYZ.Waypoints.BrainLogic;\nusing DrakiaXYZ.Waypoints.Helpers;\nusing DrakiaXYZ.Waypoints.Patches;\nusing DrakiaXYZ.Waypoints.VersionChecker;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;", "using System.Diagnostics;\nusing System.IO;\nusing System.Reflection;\n\nnamespace DrakiaXYZ.Waypoints\n{\n    [BepInPlugin(\"xyz.drakia.waypoints\", \"DrakiaXYZ-Waypoints\", \"1.2.0\")]\n    public class WaypointsPlugin : BaseUnityPlugin\n    {\n        public static string PluginFolder = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);\n        public static string CustomFolder = Path.Combine(PluginFolder, \"custom\");", "        public static string PluginFolder = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);\n        public static string CustomFolder = Path.Combine(PluginFolder, \"custom\");\n        public static string MeshFolder = Path.Combine(PluginFolder, \"mesh\");\n        public static string PointsFolder = Path.Combine(PluginFolder, \"points\");\n        public static string NavMeshFolder = Path.Combine(PluginFolder, \"navmesh\");\n\n        private void Awake()\n        {\n            if (!TarkovVersion.CheckEftVersion(Logger, Info, Config))\n            {\n                throw new Exception($\"Invalid EFT Version\");\n            }\n\n            Settings.Init(Config);\n\n            // Make sure plugin folders exist\n            Directory.CreateDirectory(CustomFolder);\n\n            try\n            {\n                CustomWaypointLoader.Instance.loadData();\n\n                new DebugPatch().Enable();\n                new WaypointPatch().Enable();\n                new BotOwnerRunPatch().Enable();\n\n                new EditorPatch().Enable();\n\n                new DoorBlockerPatch().Enable();\n            }", "            if (!TarkovVersion.CheckEftVersion(Logger, Info, Config))\n            {\n                throw new Exception($\"Invalid EFT Version\");\n            }\n\n            Settings.Init(Config);\n\n            // Make sure plugin folders exist\n            Directory.CreateDirectory(CustomFolder);\n\n            try\n            {\n                CustomWaypointLoader.Instance.loadData();\n\n                new DebugPatch().Enable();\n                new WaypointPatch().Enable();\n                new BotOwnerRunPatch().Enable();\n\n                new EditorPatch().Enable();\n\n                new DoorBlockerPatch().Enable();\n            }", "            catch (Exception ex)\n            {\n                Logger.LogError($\"{GetType().Name}: {ex}\");\n                throw;\n            }\n\n// Note: We only include this in debug builds for now, because we're not shipping BigBrain\n#if DEBUG\n            BrainManager.AddCustomLayer(typeof(RoamingLayer), new List<string>() { \"Assault\", \"PMC\" }, 1);\n#endif\n        }\n    }\n}\n"]}
{"filename": "CustomWaypointLoader.cs", "chunked_list": ["\ufeffusing Newtonsoft.Json;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace DrakiaXYZ.Waypoints\n{\n    public class CustomWaypointLoader\n    {\n        // Singleton because I'm lazy\n        private static CustomWaypointLoader instance = new CustomWaypointLoader();", "        private static CustomWaypointLoader instance = new CustomWaypointLoader();\n        public static CustomWaypointLoader Instance { get { return instance; } }\n\n        // The dictionary is [map][zone][patrol]\n        public Dictionary<string, Dictionary<string, Dictionary<string, CustomPatrol>>> mapZoneWaypoints = new Dictionary<string, Dictionary<string, Dictionary<string, CustomPatrol>>>();\n\n        public void loadData()\n        {\n            // If the \"custom\" folder doesn't exist, don't try to load from it\n            if (!Directory.Exists(WaypointsPlugin.CustomFolder))\n            {\n                return;\n            }\n\n            // Loop through all subfolders, and load data, assuming the filename is the map name", "            if (!Directory.Exists(WaypointsPlugin.CustomFolder))\n            {\n                return;\n            }\n\n            // Loop through all subfolders, and load data, assuming the filename is the map name\n            foreach (string directory in Directory.GetDirectories(WaypointsPlugin.CustomFolder))\n            {\n                foreach (string file in Directory.GetFiles(directory, \"*.json\"))\n                {\n                    string mapName = getMapFromFilename(file);\n                    //Console.WriteLine($\"Loading waypoints for {mapName}\");\n                    loadMapData(mapName, file);\n                }\n            }\n\n            // This is meant for creation purposes only, we'll loop through all files in the \"custom\" folder, and \n            // strip anything after an underscore. This allows us to create \"[mapname]_[date].json\" files automatically", "                foreach (string file in Directory.GetFiles(directory, \"*.json\"))\n                {\n                    string mapName = getMapFromFilename(file);\n                    //Console.WriteLine($\"Loading waypoints for {mapName}\");\n                    loadMapData(mapName, file);\n                }\n            }\n\n            // This is meant for creation purposes only, we'll loop through all files in the \"custom\" folder, and \n            // strip anything after an underscore. This allows us to create \"[mapname]_[date].json\" files automatically\n            foreach (string file in Directory.GetFiles(WaypointsPlugin.CustomFolder, \"*.json\"))\n            {\n                string mapName = getMapFromFilename(file);\n                //Console.WriteLine($\"Loading development waypoints for {mapName}\");\n                loadMapData(mapName, file);\n            }\n        }\n", "            foreach (string file in Directory.GetFiles(WaypointsPlugin.CustomFolder, \"*.json\"))\n            {\n                string mapName = getMapFromFilename(file);\n                //Console.WriteLine($\"Loading development waypoints for {mapName}\");\n                loadMapData(mapName, file);\n            }\n        }\n\n        private void loadMapData(string mapName, string file)\n        {\n            if (!mapZoneWaypoints.ContainsKey(mapName))\n            {\n                mapZoneWaypoints[mapName] = new Dictionary<string, Dictionary<string, CustomPatrol>>();\n            }\n\n            // We have to manually merge in our data, so multiple people can add waypoints to the same patrols\n            Dictionary<string, Dictionary<string, CustomPatrol>> zoneWaypoints = JsonConvert.DeserializeObject<Dictionary<string, Dictionary<string, CustomPatrol>>>(File.ReadAllText(file));", "        private void loadMapData(string mapName, string file)\n        {\n            if (!mapZoneWaypoints.ContainsKey(mapName))\n            {\n                mapZoneWaypoints[mapName] = new Dictionary<string, Dictionary<string, CustomPatrol>>();\n            }\n\n            // We have to manually merge in our data, so multiple people can add waypoints to the same patrols\n            Dictionary<string, Dictionary<string, CustomPatrol>> zoneWaypoints = JsonConvert.DeserializeObject<Dictionary<string, Dictionary<string, CustomPatrol>>>(File.ReadAllText(file));\n            foreach (string zoneName in zoneWaypoints.Keys)\n            {\n                // If the map already has this zone, merge in the patrols", "            foreach (string zoneName in zoneWaypoints.Keys)\n            {\n                // If the map already has this zone, merge in the patrols\n                if (mapZoneWaypoints[mapName].ContainsKey(zoneName))\n                {\n                    foreach (string patrolName in zoneWaypoints[zoneName].Keys)\n                    {\n                        // If the patrol already exists, merge in the waypoints\n                        if (mapZoneWaypoints[mapName][zoneName].ContainsKey(patrolName))\n                        {\n                            CustomPatrol existingPatrol = mapZoneWaypoints[mapName][zoneName][patrolName];\n                            CustomPatrol newPatrol = zoneWaypoints[zoneName][patrolName];\n                            // TODO: What do we do about mis-matched patrol data? Should we allow overrriding it? Who wins in the event of a conflict?\n                            //       For now, we'll go with \"Last to load wins\"\n                            existingPatrol.waypoints.AddRange(newPatrol.waypoints);\n                            existingPatrol.blockRoles = newPatrol.blockRoles ?? existingPatrol.blockRoles;\n                            existingPatrol.maxPersons = newPatrol.maxPersons ?? existingPatrol.maxPersons;\n                            existingPatrol.patrolType = newPatrol.patrolType ?? existingPatrol.patrolType;\n                        }\n                        // If the patrol doesn't exist, copy the whole thing over\n                        else\n                        {\n                            mapZoneWaypoints[mapName][zoneName][patrolName] = zoneWaypoints[zoneName][patrolName];\n                        }\n                    }\n                }\n                // If the zoneName key doesn't exist yet, we can just throw the whole thing in\n                else\n                {\n                    mapZoneWaypoints[mapName][zoneName] = zoneWaypoints[zoneName];\n                }\n            }\n        }\n\n        public Dictionary<string, CustomPatrol> getMapZonePatrols(string map, string zone)\n        {", "                        if (mapZoneWaypoints[mapName][zoneName].ContainsKey(patrolName))\n                        {\n                            CustomPatrol existingPatrol = mapZoneWaypoints[mapName][zoneName][patrolName];\n                            CustomPatrol newPatrol = zoneWaypoints[zoneName][patrolName];\n                            // TODO: What do we do about mis-matched patrol data? Should we allow overrriding it? Who wins in the event of a conflict?\n                            //       For now, we'll go with \"Last to load wins\"\n                            existingPatrol.waypoints.AddRange(newPatrol.waypoints);\n                            existingPatrol.blockRoles = newPatrol.blockRoles ?? existingPatrol.blockRoles;\n                            existingPatrol.maxPersons = newPatrol.maxPersons ?? existingPatrol.maxPersons;\n                            existingPatrol.patrolType = newPatrol.patrolType ?? existingPatrol.patrolType;\n                        }\n                        // If the patrol doesn't exist, copy the whole thing over\n                        else\n                        {\n                            mapZoneWaypoints[mapName][zoneName][patrolName] = zoneWaypoints[zoneName][patrolName];\n                        }\n                    }\n                }\n                // If the zoneName key doesn't exist yet, we can just throw the whole thing in\n                else\n                {\n                    mapZoneWaypoints[mapName][zoneName] = zoneWaypoints[zoneName];\n                }\n            }\n        }\n\n        public Dictionary<string, CustomPatrol> getMapZonePatrols(string map, string zone)\n        {", "            if (!mapZoneWaypoints.ContainsKey(map))\n            {\n                return null;\n            }\n\n            if (!mapZoneWaypoints[map].ContainsKey(zone))\n            {\n                return null;\n            }\n\n            return mapZoneWaypoints[map][zone];\n        }\n", "        private string getMapFromFilename(string file)\n        {\n            string fileWithoutExt = file.Substring(0, file.LastIndexOf('.'));\n            string mapName = fileWithoutExt.Substring(fileWithoutExt.LastIndexOf('\\\\') + 1);\n            int nUnderscoreOffset = mapName.IndexOf('_');\n            if (nUnderscoreOffset > -1)\n            {\n                // If this is factory, we have to check for the SECOND underscore, stupid factory\n                if (mapName.StartsWith(\"factory4\"))\n                {\n                    nUnderscoreOffset = mapName.IndexOf('_', nUnderscoreOffset + 1);\n                }\n", "                if (mapName.StartsWith(\"factory4\"))\n                {\n                    nUnderscoreOffset = mapName.IndexOf('_', nUnderscoreOffset + 1);\n                }\n\n                if (nUnderscoreOffset > -1)\n                {\n                    mapName = mapName.Substring(0, nUnderscoreOffset);\n                }\n            }\n\n            return mapName;\n        }\n    }\n}\n"]}
{"filename": "ConfigurationManagerAttributes.cs", "chunked_list": ["\ufeff/// <summary>\n/// Class that specifies how a setting should be displayed inside the ConfigurationManager settings window.\n/// \n/// Usage:\n/// This class template has to be copied inside the plugin's project and referenced by its code directly.\n/// make a new instance, assign any fields that you want to override, and pass it as a tag for your setting.\n/// \n/// If a field is null (default), it will be ignored and won't change how the setting is displayed.\n/// If a field is non-null (you assigned a value to it), it will override default behavior.\n/// </summary>\n/// \n/// <example> \n/// Here's an example of overriding order of settings and marking one of the settings as advanced:\n/// <code>\n/// // Override IsAdvanced and Order\n/// Config.Bind(\"X\", \"1\", 1, new ConfigDescription(\"\", null, new ConfigurationManagerAttributes { IsAdvanced = true, Order = 3 }));\n/// // Override only Order, IsAdvanced stays as the default value assigned by ConfigManager\n/// Config.Bind(\"X\", \"2\", 2, new ConfigDescription(\"\", null, new ConfigurationManagerAttributes { Order = 1 }));\n/// Config.Bind(\"X\", \"3\", 3, new ConfigDescription(\"\", null, new ConfigurationManagerAttributes { Order = 2 }));\n/// </code>\n/// </example>\n/// \n/// <remarks> \n/// You can read more and see examples in the readme at https://github.com/BepInEx/BepInEx.ConfigurationManager\n/// You can optionally remove fields that you won't use from this class, it's the same as leaving them null.\n/// </remarks>\n#pragma warning disable 0169, 0414, 0649", "internal sealed class ConfigurationManagerAttributes\n{\n    /// <summary>\n    /// Should the setting be shown as a percentage (only use with value range settings).\n    /// </summary>\n    public bool? ShowRangeAsPercent;\n\n    /// <summary>\n    /// Custom setting editor (OnGUI code that replaces the default editor provided by ConfigurationManager).\n    /// See below for a deeper explanation. Using a custom drawer will cause many of the other fields to do nothing.\n    /// </summary>\n    public System.Action<BepInEx.Configuration.ConfigEntryBase> CustomDrawer;\n\n    /// <summary>\n    /// Custom setting editor that allows polling keyboard input with the Input (or UnityInput) class.\n    /// Use either CustomDrawer or CustomHotkeyDrawer, using both at the same time leads to undefined behaviour.\n    /// </summary>", "    public CustomHotkeyDrawerFunc CustomHotkeyDrawer;\n\n    /// <summary>\n    /// Custom setting draw action that allows polling keyboard input with the Input class.\n    /// Note: Make sure to focus on your UI control when you are accepting input so user doesn't type in the search box or in another setting (best to do this on every frame).\n    /// If you don't draw any selectable UI controls You can use `GUIUtility.keyboardControl = -1;` on every frame to make sure that nothing is selected.\n    /// </summary>\n    /// <example>\n    /// CustomHotkeyDrawer = (ConfigEntryBase setting, ref bool isEditing) =>\n    /// {\n    ///     if (isEditing)\n    ///     {\n    ///         // Make sure nothing else is selected since we aren't focusing on a text box with GUI.FocusControl.\n    ///         GUIUtility.keyboardControl = -1;\n    ///                     \n    ///         // Use Input.GetKeyDown and others here, remember to set isEditing to false after you're done!\n    ///         // It's best to check Input.anyKeyDown and set isEditing to false immediately if it's true,\n    ///         // so that the input doesn't have a chance to propagate to the game itself.\n    /// ", "    ///     if (isEditing)\n    ///     {\n    ///         // Make sure nothing else is selected since we aren't focusing on a text box with GUI.FocusControl.\n    ///         GUIUtility.keyboardControl = -1;\n    ///                     \n    ///         // Use Input.GetKeyDown and others here, remember to set isEditing to false after you're done!\n    ///         // It's best to check Input.anyKeyDown and set isEditing to false immediately if it's true,\n    ///         // so that the input doesn't have a chance to propagate to the game itself.\n    /// \n    ///         if (GUILayout.Button(\"Stop\"))\n    ///             isEditing = false;\n    ///     }\n    ///     else\n    ///     {", "    ///         if (GUILayout.Button(\"Stop\"))\n    ///             isEditing = false;\n    ///     }\n    ///     else\n    ///     {\n    ///         if (GUILayout.Button(\"Start\"))\n    ///             isEditing = true;\n    ///     }\n    /// \n    ///     // This will only be true when isEditing is true and you hold any key\n    ///     GUILayout.Label(\"Any key pressed: \" + Input.anyKey);\n    /// }\n    /// </example>\n    /// <param name=\"setting\">\n    /// Setting currently being set (if available).\n    /// </param>\n    /// <param name=\"isCurrentlyAcceptingInput\">\n    /// Set this ref parameter to true when you want the current setting drawer to receive Input events.\n    /// The value will persist after being set, use it to see if the current instance is being edited.\n    /// Remember to set it to false after you are done!\n    /// </param>", "    public delegate void CustomHotkeyDrawerFunc(BepInEx.Configuration.ConfigEntryBase setting, ref bool isCurrentlyAcceptingInput);\n\n    /// <summary>\n    /// Show this setting in the settings screen at all? If false, don't show.\n    /// </summary>\n    public bool? Browsable;\n\n    /// <summary>\n    /// Category the setting is under. Null to be directly under the plugin.\n    /// </summary>\n    public string Category;\n\n    /// <summary>\n    /// If set, a \"Default\" button will be shown next to the setting to allow resetting to default.\n    /// </summary>", "    public string Category;\n\n    /// <summary>\n    /// If set, a \"Default\" button will be shown next to the setting to allow resetting to default.\n    /// </summary>\n    public object DefaultValue;\n\n    /// <summary>\n    /// Force the \"Reset\" button to not be displayed, even if a valid DefaultValue is available. \n    /// </summary>\n    public bool? HideDefaultButton;\n\n    /// <summary>\n    /// Force the setting name to not be displayed. Should only be used with a <see cref=\"CustomDrawer\"/> to get more space.\n    /// Can be used together with <see cref=\"HideDefaultButton\"/> to gain even more space.\n    /// </summary>\n    public bool? HideSettingName;\n\n    /// <summary>\n    /// Optional description shown when hovering over the setting.\n    /// Not recommended, provide the description when creating the setting instead.\n    /// </summary>", "    public string Description;\n\n    /// <summary>\n    /// Name of the setting.\n    /// </summary>\n    public string DispName;\n\n    /// <summary>\n    /// Order of the setting on the settings list relative to other settings in a category.\n    /// 0 by default, higher number is higher on the list.\n    /// </summary>\n    public int? Order;\n\n    /// <summary>\n    /// Only show the value, don't allow editing it.\n    /// </summary>\n    public bool? ReadOnly;\n\n    /// <summary>\n    /// If true, don't show the setting by default. User has to turn on showing advanced settings or search for it.\n    /// </summary>\n    public bool? IsAdvanced;\n\n    /// <summary>\n    /// Custom converter from setting type to string for the built-in editor textboxes.\n    /// </summary>\n    public System.Func<object, string> ObjToStr;\n\n    /// <summary>\n    /// Custom converter from string to setting type for the built-in editor textboxes.\n    /// </summary>\n    public System.Func<string, object> StrToObj;\n}"]}
{"filename": "CustomWaypoint.cs", "chunked_list": ["\ufeffusing System.Collections.Generic;\nusing UnityEngine;\n\nnamespace DrakiaXYZ.Waypoints\n{\n    public class CustomPatrol\n    {\n        public string name;\n        public List<CustomWaypoint> waypoints;\n\n        public PatrolType? patrolType;\n        public int? maxPersons;\n        public int? blockRoles;\n    }\n", "    public class CustomWaypoint\n    {\n        public Vector3 position;\n        public bool canUseByBoss;\n        public PatrolPointType patrolPointType;\n        public bool shallSit;\n        public List<CustomWaypoint> waypoints;\n    }\n}\n"]}
{"filename": "Helpers/PatrolWayCustom.cs", "chunked_list": ["\ufeffusing EFT;\n\nnamespace DrakiaXYZ.Waypoints.Helpers\n{\n    public class PatrolWayCustom : PatrolWay\n    {\n        // Custom patrol ways will always be suitable\n        public override bool Suitable(BotOwner bot, IBotData data)\n        {\n            return true;\n        }\n    }\n}\n"]}
{"filename": "Helpers/Settings.cs", "chunked_list": ["\ufeffusing BepInEx.Configuration;\nusing Comfort.Common;\nusing DrakiaXYZ.Waypoints.Components;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\nusing System.Threading.Tasks;", "using System.Text;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace DrakiaXYZ.Waypoints.Helpers\n{\n    internal class Settings\n    {\n        private const string GeneralSectionTitle = \"General\";\n        private const string DebugSectionTitle = \"Debug\";\n        private const string ExportSectionTitle = \"Export (Requires Debug)\";", "        private const string GeneralSectionTitle = \"General\";\n        private const string DebugSectionTitle = \"Debug\";\n        private const string ExportSectionTitle = \"Export (Requires Debug)\";\n        private const string EditorSectionTitle = \"Editor\";\n\n        public static ConfigEntry<bool> EnableCustomNavmesh;\n\n        public static ConfigEntry<bool> DebugEnabled;\n        public static ConfigEntry<bool> ShowNavMesh;\n        public static ConfigEntry<float> NavMeshOffset;\n", "        public static ConfigEntry<bool> ShowNavMesh;\n        public static ConfigEntry<float> NavMeshOffset;\n\n        public static ConfigEntry<bool> ExportNavMesh;\n        public static ConfigEntry<bool> ExportMapPoints;\n\n        public static ConfigEntry<bool> EditorEnabled;\n        public static ConfigEntry<KeyboardShortcut> AddWaypointKey;\n        public static ConfigEntry<KeyboardShortcut> RemoveWaypointKey;\n        public static ConfigEntry<KeyboardShortcut> NextBotZoneKey;\n        public static ConfigEntry<KeyboardShortcut> PrevBotZoneKey;", "        public static ConfigEntry<KeyboardShortcut> RemoveWaypointKey;\n        public static ConfigEntry<KeyboardShortcut> NextBotZoneKey;\n        public static ConfigEntry<KeyboardShortcut> PrevBotZoneKey;\n        public static ConfigEntry<KeyboardShortcut> NextPatrolKey;\n        public static ConfigEntry<KeyboardShortcut> PrevPatrolKey;\n        public static ConfigEntry<string> CustomPatrolName;\n\n        public static void Init(ConfigFile Config)\n        {\n            EnableCustomNavmesh = Config.Bind(\n                GeneralSectionTitle,\n                \"EnableCustomNavmesh\",\n                true,\n                \"Whether to use custom nav meshes when available\"\n                );\n\n            DebugEnabled = Config.Bind(\n                DebugSectionTitle,\n                \"Debug\",\n                false,\n                \"Whether to draw debug objects in-world\");\n            DebugEnabled.SettingChanged += DebugEnabled_SettingChanged;\n\n            ShowNavMesh = Config.Bind(\n                DebugSectionTitle,\n                \"ShowNavMesh\",\n                false,\n                \"Whether to show the navigation mesh\");\n            ShowNavMesh.SettingChanged += ShowNavMesh_SettingChanged;\n\n            NavMeshOffset = Config.Bind(\n                DebugSectionTitle,\n                \"NavMeshOffset\",\n                0.02f,\n                new ConfigDescription(\n                    \"The amount to offset the nav mesh so it's more visible over the terrain\",\n                    new AcceptableValueRange<float>(0f, 2f)\n                ));\n            NavMeshOffset.SettingChanged += NavMeshOffset_SettingChanged;\n\n            ExportNavMesh = Config.Bind(\n                ExportSectionTitle,\n                \"ExportNavMesh\",\n                false,\n                \"Whether to export the nav mesh on map load\");\n\n            ExportMapPoints = Config.Bind(\n                ExportSectionTitle,\n                \"ExportMapPoints\",\n                false,\n                \"Whether to export map points on map load (Waypoints)\");\n\n            EditorEnabled = Config.Bind(\n                EditorSectionTitle,\n                \"EditorEnabled\",\n                false,\n                new ConfigDescription(\n                    \"Whether to enable editing mode\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 1 }));\n            EditorEnabled.SettingChanged += EditorEnabled_SettingChanged;\n\n            AddWaypointKey = Config.Bind(\n                EditorSectionTitle,\n                \"AddWaypoint\",\n                new KeyboardShortcut(KeyCode.KeypadPlus),\n                new ConfigDescription(\n                    \"Add a Waypoint at the current position\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 2 }));\n\n            RemoveWaypointKey = Config.Bind(\n                EditorSectionTitle,\n                \"RemoveWaypoint\",\n                new KeyboardShortcut(KeyCode.KeypadMinus),\n                new ConfigDescription(\n                    \"Remove the nearest Waypoint added this session\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 3 }));\n\n            NextBotZoneKey = Config.Bind(\n                EditorSectionTitle,\n                \"NextBotzone\",\n                new KeyboardShortcut(KeyCode.Keypad9),\n                new ConfigDescription(\n                    \"Switch to the next BotZone for waypoint addition\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 4 }));\n\n            PrevBotZoneKey = Config.Bind(\n                EditorSectionTitle,\n                \"PrevBotzone\",\n                new KeyboardShortcut(KeyCode.Keypad3),\n                new ConfigDescription(\n                    \"Switch to the previous BotZone for waypoint addition\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 5 }));\n\n            NextPatrolKey = Config.Bind(\n                EditorSectionTitle,\n                \"NextPatrol\",\n                new KeyboardShortcut(KeyCode.Keypad8),\n                new ConfigDescription(\n                    \"Switch to the next Patrol for waypoint addition\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 6 }));\n\n            PrevPatrolKey = Config.Bind(\n                EditorSectionTitle,\n                \"PrevPatrol\",\n                new KeyboardShortcut(KeyCode.Keypad2),\n                new ConfigDescription(\n                    \"Switch to the previous Patrol for waypoint addition\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 7 }));\n\n            CustomPatrolName = Config.Bind(\n                EditorSectionTitle,\n                \"CustomPatrol\",\n                \"Custom\",\n                new ConfigDescription(\n                    \"Name to use for newly created custom patrols\",\n                    null,\n                    new ConfigurationManagerAttributes { Order = 8 }));\n        }\n", "        private static void DebugEnabled_SettingChanged(object sender, EventArgs e)\n        {\n            // If no game, do nothing\n            if (!Singleton<IBotGame>.Instantiated)\n            {\n                return;\n            }\n\n            if (DebugEnabled.Value)\n            {\n                BotZoneDebugComponent.Enable();\n            }\n            else\n            {\n                BotZoneDebugComponent.Disable();\n            }\n        }\n", "            if (DebugEnabled.Value)\n            {\n                BotZoneDebugComponent.Enable();\n            }\n            else\n            {\n                BotZoneDebugComponent.Disable();\n            }\n        }\n\n        private static void ShowNavMesh_SettingChanged(object sender, EventArgs e)\n        {\n            // If no game, do nothing", "        private static void ShowNavMesh_SettingChanged(object sender, EventArgs e)\n        {\n            // If no game, do nothing\n            if (!Singleton<IBotGame>.Instantiated)\n            {\n                return;\n            }\n\n            if (ShowNavMesh.Value)\n            {\n                NavMeshDebugComponent.Enable();\n            }\n            else\n            {\n                NavMeshDebugComponent.Disable();\n            }\n        }\n", "            if (ShowNavMesh.Value)\n            {\n                NavMeshDebugComponent.Enable();\n            }\n            else\n            {\n                NavMeshDebugComponent.Disable();\n            }\n        }\n\n        private static void NavMeshOffset_SettingChanged(object sender, EventArgs e)\n        {", "        private static void NavMeshOffset_SettingChanged(object sender, EventArgs e)\n        {\n            if (ShowNavMesh.Value)\n            {\n                NavMeshDebugComponent.Disable();\n                NavMeshDebugComponent.Enable();\n            }\n        }\n\n        private static void EditorEnabled_SettingChanged(object sender, EventArgs e)\n        {", "        private static void EditorEnabled_SettingChanged(object sender, EventArgs e)\n        {\n            if (EditorEnabled.Value)\n            {\n                EditorComponent.Enable();\n            }\n            else\n            {\n                EditorComponent.Disable();\n            }\n        }\n    }\n}\n"]}
{"filename": "Helpers/GameObjectHelper.cs", "chunked_list": ["\ufeffusing UnityEngine;\n\nnamespace DrakiaXYZ.Waypoints.Helpers\n{\n    public class GameObjectHelper\n    {\n        public static GameObject drawSphere(Vector3 position, float size, Color color)\n        {\n            var sphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);\n            sphere.GetComponent<Renderer>().material.color = color;\n            sphere.GetComponent<Collider>().enabled = false;\n            sphere.transform.position = new Vector3(position.x, position.y, position.z); ;\n            sphere.transform.localScale = new Vector3(size, size, size);\n\n            return sphere;\n        }\n    }\n}\n"]}
{"filename": "Helpers/ExportModel.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\nnamespace DrakiaXYZ.Waypoints.Helpers\n{\n    internal class ExportModel\n    {\n        public Dictionary<string, ExportZoneModel> zones = new Dictionary<string, ExportZoneModel>();\n    }\n", "{\n    internal class ExportModel\n    {\n        public Dictionary<string, ExportZoneModel> zones = new Dictionary<string, ExportZoneModel>();\n    }\n\n    internal class ExportZoneModel\n    {\n        public List<CustomPatrol> patrols = new List<CustomPatrol>();\n        public List<ExportNavigationPoint> coverPoints = new List<ExportNavigationPoint>();\n        public List<ExportNavigationPoint> ambushPoints = new List<ExportNavigationPoint>();\n    }\n", "    internal class ExportNavigationPoint\n    {\n        public Vector3 AltPosition;\n        public bool HaveAltPosition;\n        public Vector3 BasePosition;\n        public Vector3 ToWallVector;\n        public Vector3 FirePosition;\n        public int TiltType;\n        public int CoverLevel;\n        public bool AlwaysGood;\n        public bool BordersLightHave;", "        public int CoverLevel;\n        public bool AlwaysGood;\n        public bool BordersLightHave;\n        public Vector3 LeftBorderLight;\n        public Vector3 RightBorderLight;\n        public bool CanLookLeft;\n        public bool CanLookRight;\n        public int HideLevel;\n    }\n}\n"]}
{"filename": "Properties/AssemblyInfo.cs", "chunked_list": ["using DrakiaXYZ.Waypoints.VersionChecker;\nusing System.Reflection;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n\n// General Information about an assembly is controlled through the following\n// set of attributes. Change these attribute values to modify the information\n// associated with an assembly.\n[assembly: AssemblyTitle(\"DrakiaXYZ-Waypoints\")]\n[assembly: AssemblyDescription(\"\")]", "[assembly: AssemblyTitle(\"DrakiaXYZ-Waypoints\")]\n[assembly: AssemblyDescription(\"\")]\n[assembly: AssemblyConfiguration(\"\")]\n[assembly: AssemblyCompany(\"\")]\n[assembly: AssemblyProduct(\"DrakiaXYZ-Waypoints\")]\n[assembly: AssemblyCopyright(\"Copyright   2023 DrakiaXYZ\")]\n[assembly: AssemblyTrademark(\"\")]\n[assembly: AssemblyCulture(\"\")]\n\n// Setting ComVisible to false makes the types in this assembly not visible", "\n// Setting ComVisible to false makes the types in this assembly not visible\n// to COM components.  If you need to access a type in this assembly from\n// COM, set the ComVisible attribute to true on that type.\n[assembly: ComVisible(false)]\n\n// The following GUID is for the ID of the typelib if this project is exposed to COM\n[assembly: Guid(\"db6c9aca-dec4-4d61-af7b-5f5dab6cce70\")]\n\n// Version information for an assembly consists of the following four values:", "\n// Version information for an assembly consists of the following four values:\n//\n//      Major Version\n//      Minor Version\n//      Build Number\n//      Revision\n//\n// You can specify all the values or you can default the Build and Revision Numbers\n// by using the '*' as shown below:", "// You can specify all the values or you can default the Build and Revision Numbers\n// by using the '*' as shown below:\n// [assembly: AssemblyVersion(\"1.0.*\")]\n[assembly: AssemblyVersion(\"1.2.0.0\")]\n[assembly: AssemblyFileVersion(\"1.2.0.0\")]\n[assembly: TarkovVersion(24964)]\n"]}
{"filename": "VersionChecker/TarkovVersion.cs", "chunked_list": ["\ufeffusing BepInEx;\nusing BepInEx.Configuration;\nusing BepInEx.Logging;\nusing System;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Reflection;\nusing UnityEngine;\n\nnamespace DrakiaXYZ.Waypoints.VersionChecker", "\nnamespace DrakiaXYZ.Waypoints.VersionChecker\n{\n    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false)]\n    public class TarkovVersion : Attribute\n    {\n        private int version;\n        public TarkovVersion() : this(0) { }\n        public TarkovVersion(int version)\n        {\n            this.version = version;\n        }\n", "        public static int BuildVersion\n        {\n            get\n            {\n                return Assembly.GetExecutingAssembly()\n                    .GetCustomAttributes(typeof(TarkovVersion), false)\n                    ?.Cast<TarkovVersion>()?.FirstOrDefault()?.version ?? 0;\n            }\n        }\n\n        // Make sure the version of EFT being run is the correct version, throw an exception and output log message if it isn't\n        /// <summary>\n        /// Check the currently running program's version against the plugin assembly TarkovVersion attribute, and\n        /// return false if they do not match. \n        /// Optionally add a fake setting to the F12 menu if Config is passed in\n        /// </summary>\n        /// <param name=\"Logger\">The ManualLogSource to output an error to</param>\n        /// <param name=\"Info\">The PluginInfo object for the plugin, used to get the plugin name and version</param>\n        /// <param name=\"Config\">A BepinEx ConfigFile object, if provided, a custom message will be added to the F12 menu</param>\n        /// <returns></returns>", "        public static bool CheckEftVersion(ManualLogSource Logger, PluginInfo Info, ConfigFile Config = null)\n        {\n            int currentVersion = FileVersionInfo.GetVersionInfo(BepInEx.Paths.ExecutablePath).FilePrivatePart;\n            int buildVersion = BuildVersion;\n            if (currentVersion != buildVersion)\n            {\n                string errorMessage = $\"ERROR: This version of {Info.Metadata.Name} v{Info.Metadata.Version} was built for Tarkov {buildVersion}, but you are running {currentVersion}. Please download the correct plugin version.\";\n                Logger.LogError(errorMessage);\n\n                if (Config != null)\n                {\n                    // This results in a bogus config entry in the BepInEx config file for the plugin, but it shouldn't hurt anything\n                    // We leave the \"section\" parameter empty so there's no section header drawn\n                    Config.Bind(\"\", \"TarkovVersion\", \"\", new ConfigDescription(\n                        errorMessage, null, new ConfigurationManagerAttributes\n                        {\n                            CustomDrawer = ErrorLabelDrawer,\n                            ReadOnly = true,\n                            HideDefaultButton = true,\n                            HideSettingName = true,\n                            Category = null\n                        }\n                    ));\n                }\n\n                return false;\n            }\n\n            return true;\n        }\n\n        static void ErrorLabelDrawer(ConfigEntryBase entry)\n        {\n            GUIStyle styleNormal = new GUIStyle(GUI.skin.label);\n            styleNormal.wordWrap = true;\n            styleNormal.stretchWidth = true;\n\n            GUIStyle styleError = new GUIStyle(GUI.skin.label);\n            styleError.stretchWidth = true;\n            styleError.alignment = TextAnchor.MiddleCenter;\n            styleError.normal.textColor = Color.red;\n            styleError.fontStyle = FontStyle.Bold;\n\n            // General notice that we're the wrong version\n            GUILayout.BeginVertical();\n            GUILayout.Label(entry.Description.Description, styleNormal, new GUILayoutOption[] { GUILayout.ExpandWidth(true) });\n\n            // Centered red disabled text\n            GUILayout.Label(\"Plugin has been disabled!\", styleError, new GUILayoutOption[] { GUILayout.ExpandWidth(true) });\n            GUILayout.EndVertical();\n        }\n\n#pragma warning disable 0169, 0414, 0649", "                if (Config != null)\n                {\n                    // This results in a bogus config entry in the BepInEx config file for the plugin, but it shouldn't hurt anything\n                    // We leave the \"section\" parameter empty so there's no section header drawn\n                    Config.Bind(\"\", \"TarkovVersion\", \"\", new ConfigDescription(\n                        errorMessage, null, new ConfigurationManagerAttributes\n                        {\n                            CustomDrawer = ErrorLabelDrawer,\n                            ReadOnly = true,\n                            HideDefaultButton = true,\n                            HideSettingName = true,\n                            Category = null\n                        }\n                    ));\n                }\n\n                return false;\n            }\n\n            return true;\n        }\n\n        static void ErrorLabelDrawer(ConfigEntryBase entry)\n        {\n            GUIStyle styleNormal = new GUIStyle(GUI.skin.label);\n            styleNormal.wordWrap = true;\n            styleNormal.stretchWidth = true;\n\n            GUIStyle styleError = new GUIStyle(GUI.skin.label);\n            styleError.stretchWidth = true;\n            styleError.alignment = TextAnchor.MiddleCenter;\n            styleError.normal.textColor = Color.red;\n            styleError.fontStyle = FontStyle.Bold;\n\n            // General notice that we're the wrong version\n            GUILayout.BeginVertical();\n            GUILayout.Label(entry.Description.Description, styleNormal, new GUILayoutOption[] { GUILayout.ExpandWidth(true) });\n\n            // Centered red disabled text\n            GUILayout.Label(\"Plugin has been disabled!\", styleError, new GUILayoutOption[] { GUILayout.ExpandWidth(true) });\n            GUILayout.EndVertical();\n        }\n\n#pragma warning disable 0169, 0414, 0649", "        internal sealed class ConfigurationManagerAttributes\n        {\n            public bool? ShowRangeAsPercent;\n            public System.Action<BepInEx.Configuration.ConfigEntryBase> CustomDrawer;\n            public CustomHotkeyDrawerFunc CustomHotkeyDrawer;\n            public delegate void CustomHotkeyDrawerFunc(BepInEx.Configuration.ConfigEntryBase setting, ref bool isCurrentlyAcceptingInput);\n            public bool? Browsable;\n            public string Category;\n            public object DefaultValue;\n            public bool? HideDefaultButton;\n            public bool? HideSettingName;", "            public object DefaultValue;\n            public bool? HideDefaultButton;\n            public bool? HideSettingName;\n            public string Description;\n            public string DispName;\n            public int? Order;\n            public bool? ReadOnly;\n            public bool? IsAdvanced;\n            public System.Func<object, string> ObjToStr;\n            public System.Func<string, object> StrToObj;\n        }\n    }\n}\n"]}
{"filename": "Patches/DebugPatch.cs", "chunked_list": ["\ufeffusing Aki.Reflection.Patching;\nusing Comfort.Common;\nusing DrakiaXYZ.Waypoints.Components;\nusing DrakiaXYZ.Waypoints.Helpers;\nusing EFT;\nusing EFT.Game.Spawning;\nusing System.Collections.Generic;\nusing System.Reflection;\nusing UnityEngine;\nusing UnityEngine.AI;", "using UnityEngine;\nusing UnityEngine.AI;\n\nnamespace DrakiaXYZ.Waypoints.Patches\n{\n    public class DebugPatch : ModulePatch\n    {\n        protected override MethodBase GetTargetMethod()\n        {\n            return typeof(GameWorld).GetMethod(nameof(GameWorld.OnGameStarted));\n        }\n\n        [PatchPrefix]", "        public static void PatchPrefix()\n        {\n            BotZoneDebugComponent.Enable();\n            NavMeshDebugComponent.Enable();\n        }\n    }\n}\n"]}
{"filename": "Patches/DoorBlockerPatch.cs", "chunked_list": ["\ufeffusing Aki.Reflection.Patching;\nusing DrakiaXYZ.Waypoints.Components;\nusing EFT;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\nusing System.Threading.Tasks;\n", "using System.Threading.Tasks;\n\nnamespace DrakiaXYZ.Waypoints.Patches\n{\n    internal class DoorBlockerPatch : ModulePatch\n    {\n        protected override MethodBase GetTargetMethod()\n        {\n            return typeof(GameWorld).GetMethod(nameof(GameWorld.OnGameStarted));\n        }\n\n        [PatchPrefix]", "        public static void PatchPrefix()\n        {\n            DoorBlockAdderComponent.Enable();\n        }\n    }\n}\n"]}
{"filename": "Patches/EditorPatch.cs", "chunked_list": ["\ufeffusing Aki.Reflection.Patching;\nusing DrakiaXYZ.Waypoints.Components;\nusing EFT;\nusing System.Reflection;\n\nnamespace DrakiaXYZ.Waypoints.Patches\n{\n    public class EditorPatch : ModulePatch\n    {\n        protected override MethodBase GetTargetMethod()\n        {\n            return typeof(GameWorld).GetMethod(nameof(GameWorld.OnGameStarted));\n        }\n\n        [PatchPrefix]", "        protected override MethodBase GetTargetMethod()\n        {\n            return typeof(GameWorld).GetMethod(nameof(GameWorld.OnGameStarted));\n        }\n\n        [PatchPrefix]\n        public static void PatchPrefix()\n        {\n            EditorComponent.Enable();\n        }\n    }\n}\n"]}
{"filename": "Patches/WaypointPatch.cs", "chunked_list": ["\ufeffusing Aki.Reflection.Patching;\nusing Aki.Reflection.Utils;\nusing Comfort.Common;\nusing DrakiaXYZ.Waypoints.Helpers;\nusing EFT;\nusing HarmonyLib;\nusing Newtonsoft.Json;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;", "using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing UnityEngine;\nusing UnityEngine.AI;\nusing Random = UnityEngine.Random;\n\nnamespace DrakiaXYZ.Waypoints.Patches", "\nnamespace DrakiaXYZ.Waypoints.Patches\n{\n    public class WaypointPatch : ModulePatch\n    {\n        private static int customWaypointCount = 0;\n        private static FieldInfo _doorLinkListField;\n\n        protected override MethodBase GetTargetMethod()\n        {\n            _doorLinkListField = AccessTools.Field(typeof(BotCellController), \"navMeshDoorLink_0\");\n\n            return typeof(BotControllerClass).GetMethod(nameof(BotControllerClass.Init));\n        }\n\n        /// <summary>\n        /// \n        /// </summary>\n        [PatchPrefix]", "        protected override MethodBase GetTargetMethod()\n        {\n            _doorLinkListField = AccessTools.Field(typeof(BotCellController), \"navMeshDoorLink_0\");\n\n            return typeof(BotControllerClass).GetMethod(nameof(BotControllerClass.Init));\n        }\n\n        /// <summary>\n        /// \n        /// </summary>\n        [PatchPrefix]", "        private static void PatchPrefix(BotZone[] botZones)\n        {\n            var gameWorld = Singleton<GameWorld>.Instance;\n            if (gameWorld == null)\n            {\n                Logger.LogError(\"BotController::Init called, but GameWorld doesn't exist\");\n                return;\n            }\n\n            if (botZones != null)\n            {\n                InjectWaypoints(gameWorld, botZones);\n            }\n", "            if (botZones != null)\n            {\n                InjectWaypoints(gameWorld, botZones);\n            }\n\n            if (Settings.EnableCustomNavmesh.Value)\n            {\n                InjectNavmesh(gameWorld);\n            }\n        }\n\n        /// <summary>\n        /// Re-calculate the doorlink navmesh carvers, since these are baked into the map, but we've\n        /// changed the navmesh\n        /// </summary>\n        [PatchPostfix]", "        private static void PatchPostfix(BotCellController ___botCellController_0)\n        {\n            NavMeshDoorLink[] doorLinkList = _doorLinkListField.GetValue(___botCellController_0) as NavMeshDoorLink[];\n            if (doorLinkList != null)\n            {\n                foreach (NavMeshDoorLink doorLink in doorLinkList)\n                {\n                    doorLink.CheckAfterCreatedCarver();\n                }\n            }\n            else\n            {\n                Logger.LogError($\"Error finding doorLinkList\");\n            }\n        }\n", "        private static void InjectWaypoints(GameWorld gameWorld, BotZone[] botZones)\n        {\n            string mapName = gameWorld.MainPlayer.Location.ToLower();\n            customWaypointCount = 0;\n\n            var stopwatch = new Stopwatch();\n            stopwatch.Start();\n\n            // Inject our loaded patrols\n            foreach (BotZone botZone in botZones)\n            {\n                Dictionary<string, CustomPatrol> customPatrols = CustomWaypointLoader.Instance.getMapZonePatrols(mapName, botZone.NameZone);", "            foreach (BotZone botZone in botZones)\n            {\n                Dictionary<string, CustomPatrol> customPatrols = CustomWaypointLoader.Instance.getMapZonePatrols(mapName, botZone.NameZone);\n                if (customPatrols != null)\n                {\n                    Logger.LogDebug($\"Found custom patrols for {mapName} / {botZone.NameZone}\");\n                    foreach (string patrolName in customPatrols.Keys)\n                    {\n                        AddOrUpdatePatrol(botZone, customPatrols[patrolName]);\n                    }\n                }\n            }\n\n            stopwatch.Stop();\n            Logger.LogDebug($\"Loaded {customWaypointCount} custom waypoints in {stopwatch.ElapsedMilliseconds}ms!\");\n\n            // If enabled, dump the waypoint data", "            if (Settings.ExportMapPoints.Value)\n            {\n                // If we haven't written out the Waypoints for this map yet, write them out now\n                Directory.CreateDirectory(WaypointsPlugin.PointsFolder);\n                string exportFile = $\"{WaypointsPlugin.PointsFolder}\\\\{mapName}.json\";\n                if (!File.Exists(exportFile))\n                {\n                    ExportWaypoints(exportFile, botZones);\n                }\n            }\n        }\n", "        private static void InjectNavmesh(GameWorld gameWorld)\n        {\n            // First we load the asset from the bundle\n            string mapName = gameWorld.MainPlayer.Location.ToLower();\n\n            // Standardize Factory\n            if (mapName.StartsWith(\"factory4\"))\n            {\n                mapName = \"factory4\";\n            }\n\n            string navMeshFilename = mapName + \"-navmesh.bundle\";\n            string navMeshPath = Path.Combine(new string[] { WaypointsPlugin.NavMeshFolder, navMeshFilename });", "            if (!File.Exists(navMeshPath))\n            {\n                return;\n            }\n\n            var bundle = AssetBundle.LoadFromFile(navMeshPath);\n            if (bundle == null)\n            {\n                Logger.LogError($\"Error loading navMeshBundle: {navMeshPath}\");\n                return;\n            }\n\n            var assets = bundle.LoadAllAssets(typeof(NavMeshData));", "            if (assets == null || assets.Length == 0)\n            {\n                Logger.LogError($\"Bundle did not contain a NavMeshData asset: {navMeshPath}\");\n                return;\n            }\n\n            // Then inject the new navMeshData, while blowing away the old data\n            var navMeshData = assets[0] as NavMeshData;\n            NavMesh.RemoveAllNavMeshData();\n            NavMesh.AddNavMeshData(navMeshData);\n\n            // Unload the bundle, leaving behind currently in use assets, so we can reload it next map\n            bundle.Unload(false);\n\n            Logger.LogDebug($\"Injected custom navmesh: {navMeshPath}\");\n\n            // For Streets, we want to inject a mesh into Chek15, so bots can get inside", "            if (mapName == \"tarkovstreets\")\n            {\n                Logger.LogDebug(\"Injecting custom box colliders to expand Streets bot access\");\n\n                GameObject chek15LobbyAddonRamp = new GameObject(\"chek15LobbyAddonRamp\");\n                chek15LobbyAddonRamp.layer = LayerMaskClass.LowPolyColliderLayer;\n                chek15LobbyAddonRamp.transform.position = new Vector3(126.88f, 2.96f, 229.91f);\n                chek15LobbyAddonRamp.transform.localScale = new Vector3(1.0f, 0.1f, 1.0f);\n                chek15LobbyAddonRamp.transform.Rotate(new Vector3(0f, 23.65f, 25.36f));\n                chek15LobbyAddonRamp.transform.SetParent(gameWorld.transform);\n                chek15LobbyAddonRamp.AddComponent<BoxCollider>();\n\n                GameObject chek15BackAddonRamp = new GameObject(\"Chek15BackAddonRamp\");\n                chek15BackAddonRamp.layer = LayerMaskClass.LowPolyColliderLayer;\n                chek15BackAddonRamp.transform.position = new Vector3(108.31f, 3.32f, 222f);\n                chek15BackAddonRamp.transform.localScale = new Vector3(1.0f, 0.1f, 1.0f);\n                chek15BackAddonRamp.transform.Rotate(new Vector3(-40f, 0f, 0f));\n                chek15BackAddonRamp.transform.SetParent(gameWorld.transform);\n                chek15BackAddonRamp.AddComponent<BoxCollider>();\n            }\n        }\n", "        public static void AddOrUpdatePatrol(BotZone botZone, CustomPatrol customPatrol)\n        {\n            // If the map already has this patrol, update its values\n            PatrolWay mapPatrol = botZone.PatrolWays.FirstOrDefault(p => p.name == customPatrol.name);\n            if (mapPatrol != null)\n            {\n                Console.WriteLine($\"PatrolWay {customPatrol.name} exists, updating\");\n                UpdatePatrol(mapPatrol, customPatrol);\n            }\n            // Otherwise, add a full new patrol\n            else\n            {\n                Console.WriteLine($\"PatrolWay {customPatrol.name} doesn't exist, creating\");\n                AddPatrol(botZone, customPatrol);\n            }\n        }\n", "        private static void UpdatePatrol(PatrolWay mapPatrol, CustomPatrol customPatrol)\n        {\n            //mapPatrol.BlockRoles = (WildSpawnType?)customPatrol.blockRoles ?? mapPatrol.BlockRoles;\n            mapPatrol.MaxPersons = customPatrol.maxPersons ?? mapPatrol.MaxPersons;\n            mapPatrol.PatrolType = customPatrol.patrolType ?? mapPatrol.PatrolType;\n\n            // Exclude any points that already exist in the map PatrolWay\n            var customWaypoints = customPatrol.waypoints.Where(\n                p => (mapPatrol.Points.Where(w => w.position == p.position).ToList().Count == 0)\n            ).ToList();\n", "            if (customWaypoints.Count > 0)\n            {\n                mapPatrol.Points.AddRange(processWaypointsToPatrolPoints(mapPatrol, customWaypoints));\n            }\n        }\n\n        private static List<PatrolPoint> processWaypointsToPatrolPoints(PatrolWay mapPatrol, List<CustomWaypoint> waypoints)\n        {\n            List<PatrolPoint> patrolPoints = new List<PatrolPoint>();\n            if (waypoints == null)\n            {\n                return patrolPoints;\n            }\n", "            if (waypoints == null)\n            {\n                return patrolPoints;\n            }\n\n            foreach (CustomWaypoint waypoint in waypoints)\n            {\n                var newPatrolPointObject = new GameObject(\"CustomWaypoint_\" + (customWaypointCount++));\n                //Logger.LogDebug($\"Injecting custom PatrolPoint({newPatrolPointObject.name}) at {waypoint.position.x}, {waypoint.position.y}, {waypoint.position.z}\");\n                newPatrolPointObject.AddComponent<PatrolPoint>();\n                var newPatrolPoint = newPatrolPointObject.GetComponent<PatrolPoint>();\n\n                newPatrolPoint.Id = (new System.Random()).Next();\n                newPatrolPoint.transform.position = new Vector3(waypoint.position.x, waypoint.position.y, waypoint.position.z);\n                newPatrolPoint.CanUseByBoss = waypoint.canUseByBoss;\n                newPatrolPoint.PatrolPointType = waypoint.patrolPointType;\n                newPatrolPoint.ShallSit = waypoint.shallSit;\n                newPatrolPoint.PointWithLookSides = null;\n                newPatrolPoint.SubManual = false;", "                if (mapPatrol != null && waypoint.waypoints == null)\n                {\n                    // CreateSubPoints has a very annoying debug log message, so disable debug logging to avoid it\n                    bool previousLogEnabled = UnityEngine.Debug.unityLogger.logEnabled;\n                    UnityEngine.Debug.unityLogger.logEnabled = false;\n\n                    newPatrolPoint.CreateSubPoints(mapPatrol);\n\n                    UnityEngine.Debug.unityLogger.logEnabled = previousLogEnabled;\n                }\n                else\n                {\n                    newPatrolPoint.subPoints = processWaypointsToPatrolPoints(null, waypoint.waypoints);\n                }\n                patrolPoints.Add(newPatrolPoint);\n            }\n\n            return patrolPoints;\n        }\n", "        private static void AddPatrol(BotZone botZone, CustomPatrol customPatrol)\n        {\n            //Logger.LogDebug($\"Creating custom patrol {customPatrol.name} in {botZone.NameZone}\");\n            // Validate some data\n            //if (customPatrol.blockRoles == null)\n            //{\n            //    Logger.LogError(\"Invalid custom Patrol, blockRoles is null\");\n            //    return;\n            //}\n            if (customPatrol.maxPersons == null)\n            {\n                Logger.LogError(\"Invalid custom Patrol, maxPersons is null\");\n                return;\n            }", "            if (customPatrol.maxPersons == null)\n            {\n                Logger.LogError(\"Invalid custom Patrol, maxPersons is null\");\n                return;\n            }\n            if (customPatrol.patrolType == null)\n            {\n                Logger.LogError(\"Invalid custom Patrol, patrolTypes is null\");\n                return;\n            }\n\n            // Create the Patrol game object\n            var mapPatrolObject = new GameObject(customPatrol.name);\n            mapPatrolObject.AddComponent<PatrolWayCustom>();\n            var mapPatrol = mapPatrolObject.GetComponent<PatrolWayCustom>();\n\n            // Add the waypoints to the Patrol object\n            UpdatePatrol(mapPatrol, customPatrol);\n\n            // Add the patrol to our botZone\n            botZone.PatrolWays = botZone.PatrolWays.Append(mapPatrol).ToArray();\n        }\n\n        static void ExportWaypoints(string exportFile, BotZone[] botZones)\n        {\n            ExportModel exportModel = new ExportModel();\n", "            foreach (BotZone botZone in botZones)\n            {\n                exportModel.zones.Add(botZone.name, new ExportZoneModel());\n\n                List<CustomPatrol> customPatrolWays = new List<CustomPatrol>();\n                foreach (PatrolWay patrolWay in botZone.PatrolWays)\n                {\n                    CustomPatrol customPatrolWay = new CustomPatrol();\n                    //customPatrolWay.blockRoles = patrolWay.BlockRoles.GetInt();\n                    customPatrolWay.maxPersons = patrolWay.MaxPersons;\n                    customPatrolWay.patrolType = patrolWay.PatrolType;\n                    customPatrolWay.name = patrolWay.name;\n                    customPatrolWay.waypoints = CreateCustomWaypoints(patrolWay.Points);\n\n                    customPatrolWays.Add(customPatrolWay);\n                }\n\n                exportModel.zones[botZone.name].patrols = customPatrolWays;\n\n                exportModel.zones[botZone.name].coverPoints = botZone.CoverPoints.Select(p => customNavPointToExportNavPoint(p)).ToList();\n                exportModel.zones[botZone.name].ambushPoints = botZone.AmbushPoints.Select(p => customNavPointToExportNavPoint(p)).ToList();\n            }\n\n            string jsonString = JsonConvert.SerializeObject(exportModel, Formatting.Indented);", "            if (File.Exists(exportFile))\n            {\n                File.Delete(exportFile);\n            }\n            File.Create(exportFile).Dispose();\n            StreamWriter streamWriter = new StreamWriter(exportFile);\n            streamWriter.Write(jsonString);\n            streamWriter.Flush();\n            streamWriter.Close();\n        }\n\n        static ExportNavigationPoint customNavPointToExportNavPoint(CustomNavigationPoint customNavPoint)\n        {\n            ExportNavigationPoint exportNavPoint = new ExportNavigationPoint();\n            exportNavPoint.AltPosition = customNavPoint.AltPosition;\n            exportNavPoint.HaveAltPosition = customNavPoint.HaveAltPosition;\n            exportNavPoint.BasePosition = customNavPoint.BasePosition;\n            exportNavPoint.ToWallVector = customNavPoint.ToWallVector;\n            exportNavPoint.FirePosition = customNavPoint.FirePosition;\n            exportNavPoint.TiltType = customNavPoint.TiltType.GetInt();\n            exportNavPoint.CoverLevel = customNavPoint.CoverLevel.GetInt();\n            exportNavPoint.AlwaysGood = customNavPoint.AlwaysGood;\n            exportNavPoint.BordersLightHave = customNavPoint.BordersLightHave;\n            exportNavPoint.LeftBorderLight = customNavPoint.LeftBorderLight;\n            exportNavPoint.RightBorderLight = customNavPoint.RightBorderLight;\n            exportNavPoint.CanLookLeft = customNavPoint.CanLookLeft;\n            exportNavPoint.CanLookRight = customNavPoint.CanLookRight;\n            exportNavPoint.HideLevel = customNavPoint.HideLevel;\n\n            return exportNavPoint;\n        }\n\n        static List<CustomWaypoint> CreateCustomWaypoints(List<PatrolPoint> patrolPoints)\n        {\n            List<CustomWaypoint> customWaypoints = new List<CustomWaypoint>();", "            if (patrolPoints == null)\n            {\n                //Logger.LogDebug(\"patrolPoints is null, skipping\");\n                return customWaypoints;\n            }\n\n            foreach (PatrolPoint patrolPoint in patrolPoints)\n            {\n                CustomWaypoint customWaypoint = new CustomWaypoint();\n                customWaypoint.canUseByBoss = patrolPoint.CanUseByBoss;\n                customWaypoint.patrolPointType = patrolPoint.PatrolPointType;\n                customWaypoint.position = patrolPoint.Position;\n                customWaypoint.shallSit = patrolPoint.ShallSit;\n\n                customWaypoints.Add(customWaypoint);\n            }\n\n            return customWaypoints;\n        }\n    }\n", "    public class BotOwnerRunPatch : ModulePatch\n    {\n        protected override MethodBase GetTargetMethod()\n        {\n            return AccessTools.Method(typeof(BotOwner), \"CalcGoal\");\n        }\n\n        [PatchPostfix]\n        public static void PatchPostfix(BotOwner __instance)\n        {\n            // Wrap the whole thing in a try/catch, so we don't accidentally kill bot interactions\n            try\n            {\n                // If the bot doesn't have patrolling data, don't do anything", "        public static void PatchPostfix(BotOwner __instance)\n        {\n            // Wrap the whole thing in a try/catch, so we don't accidentally kill bot interactions\n            try\n            {\n                // If the bot doesn't have patrolling data, don't do anything\n                if (__instance.PatrollingData == null)\n                {\n                    return;\n                }\n\n                // If we're not patrolling, don't do anything", "                if (!__instance.Memory.IsPeace || __instance.PatrollingData.Status != PatrolStatus.go)\n                {\n                    //Logger.LogInfo($\"({Time.time})BotOwner::RunPatch[{__instance.name}] - Bot not in peace, or not patrolling\");\n                    return;\n                }\n\n                // If we're already running, check if our stamina is too low (< 30%), or we're close to our end point and stop running\n                if (__instance.Mover.Sprinting)\n                {\n                    if (__instance.GetPlayer.Physical.Stamina.NormalValue < 0.3f)\n                    {\n                        //Logger.LogInfo($\"({Time.time})BotOwner::RunPatch[{__instance.name}] - Bot was sprinting but stamina hit {Math.Floor(__instance.GetPlayer.Physical.Stamina.NormalValue * 100)}%. Stopping sprint\");\n                        __instance.Sprint(false);\n                    }\n\n                    // TODO: Get BotOwner.PatrollingData.PatrolPathControl.\n                }\n\n                // If we aren't running, and our stamina is near capacity (> 80%), allow us to run", "                    if (__instance.GetPlayer.Physical.Stamina.NormalValue < 0.3f)\n                    {\n                        //Logger.LogInfo($\"({Time.time})BotOwner::RunPatch[{__instance.name}] - Bot was sprinting but stamina hit {Math.Floor(__instance.GetPlayer.Physical.Stamina.NormalValue * 100)}%. Stopping sprint\");\n                        __instance.Sprint(false);\n                    }\n\n                    // TODO: Get BotOwner.PatrollingData.PatrolPathControl.\n                }\n\n                // If we aren't running, and our stamina is near capacity (> 80%), allow us to run\n                if (!__instance.Mover.Sprinting && __instance.GetPlayer.Physical.Stamina.NormalValue > 0.8f)\n                {\n                    //Logger.LogInfo($\"({Time.time})BotOwner::RunPatch[{__instance.name}] - Bot wasn't sprinting but stamina hit {Math.Floor(__instance.GetPlayer.Physical.Stamina.NormalValue * 100)}%. Giving bot chance to run\");", "                if (!__instance.Mover.Sprinting && __instance.GetPlayer.Physical.Stamina.NormalValue > 0.8f)\n                {\n                    //Logger.LogInfo($\"({Time.time})BotOwner::RunPatch[{__instance.name}] - Bot wasn't sprinting but stamina hit {Math.Floor(__instance.GetPlayer.Physical.Stamina.NormalValue * 100)}%. Giving bot chance to run\");\n                    if (Random.Range(0, 1000) < __instance.Settings.FileSettings.Patrol.SPRINT_BETWEEN_CACHED_POINTS)\n                    {\n                        //Logger.LogInfo($\"({Time.time})BotOwner::RunPatch[{__instance.name}] - Bot decided to run\");\n                        __instance.Sprint(true);\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                Logger.LogDebug($\"Something broke in the patch. We caught it so everything should be fine: {e.ToString()}\");\n            }\n        }\n    }\n}\n", "            catch (Exception e)\n            {\n                Logger.LogDebug($\"Something broke in the patch. We caught it so everything should be fine: {e.ToString()}\");\n            }\n        }\n    }\n}\n"]}
{"filename": "Components/EditorComponent.cs", "chunked_list": ["\ufeffusing Comfort.Common;\nusing DrakiaXYZ.Waypoints.Helpers;\nusing DrakiaXYZ.Waypoints.Patches;\nusing EFT;\nusing Newtonsoft.Json;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing UnityEngine;", "using System.Linq;\nusing UnityEngine;\nusing UnityEngine.AI;\n\nnamespace DrakiaXYZ.Waypoints.Components\n{\n    public class EditorComponent : MonoBehaviour, IDisposable\n    {\n        private static List<UnityEngine.Object> gameObjects = new List<UnityEngine.Object>();\n        private GameWorld gameWorld;\n        private Player player;", "        private static List<UnityEngine.Object> gameObjects = new List<UnityEngine.Object>();\n        private GameWorld gameWorld;\n        private Player player;\n        private IBotGame botGame;\n        private List<BotZone> botZones = new List<BotZone>();\n\n        private GUIContent guiContent;\n        private GUIStyle guiStyle;\n\n        // Used to only update the nearest zone periodically to avoid performance issues\n        private float lastLocationUpdate;", "        private float lastLocationUpdate;\n        private float locationUpdateFrequency = 0.5f;\n\n        private int currentZoneIndex = -1;\n        private BotZone nearestBotZone = null;\n\n        private float distanceToZone;\n        private NavMeshHit navMeshHit;\n\n        // Dictionary is [zone][patrol]\n        private Dictionary<string, Dictionary<string, CustomPatrol>> zoneWaypoints = new Dictionary<string, Dictionary<string, CustomPatrol>>();", "        private string filename;\n\n\n        private EditorComponent()\n        {\n            // Empty\n        }\n\n        public void Dispose()\n        {\n            gameObjects.ForEach(Destroy);\n            gameObjects.Clear();\n        }\n", "        public void Dispose()\n        {\n            gameObjects.ForEach(Destroy);\n            gameObjects.Clear();\n        }\n\n        public void Awake()\n        {\n            Console.WriteLine(\"Editor::OnEnable\");\n\n            // Setup access to game objects\n            gameWorld = Singleton<GameWorld>.Instance;\n            botGame = Singleton<IBotGame>.Instance;\n            player = gameWorld.MainPlayer;\n\n            // Cache list of botZones\n            botZones = LocationScene.GetAll<BotZone>().ToList();\n            UpdateLocation();\n\n            // Generate the filename to use for output\n            string datetime = DateTime.Now.ToString(\"MM-dd-yyyy.HH-mm\");\n            filename = $\"{WaypointsPlugin.CustomFolder }\\\\{gameWorld.MainPlayer.Location.ToLower()}_{datetime}.json\";\n        }\n", "        public void OnGUI()\n        {\n            if (Time.time > (lastLocationUpdate + locationUpdateFrequency))\n            {\n                UpdateLocation();\n                lastLocationUpdate = Time.time;\n            }\n\n            // Setup GUI objects if they're not setup yet\n            if (guiStyle == null)\n            {\n                guiStyle = new GUIStyle(GUI.skin.box);\n                guiStyle.alignment = TextAnchor.MiddleRight;\n                guiStyle.fontSize = 36;\n                guiStyle.margin = new RectOffset(3, 3, 3, 3);\n            }\n", "            if (guiStyle == null)\n            {\n                guiStyle = new GUIStyle(GUI.skin.box);\n                guiStyle.alignment = TextAnchor.MiddleRight;\n                guiStyle.fontSize = 36;\n                guiStyle.margin = new RectOffset(3, 3, 3, 3);\n            }\n\n            if (guiContent == null)\n            {\n                guiContent = new GUIContent();\n            }\n\n            string zoneName = getCurrentZoneName();\n            string patrolName = getCurrentPatrolName();\n\n            // Build the data to show in the GUI\n            string guiText = \"Waypoint Editor\\n\";\n            guiText += \"-----------------------\\n\";\n\n            guiText += $\"Current Zone: {zoneName}\\n\";\n            guiText += $\"Current Patrol: {patrolName}\\n\";\n            //guiText += $\"Distance To Nearest Waypoint: {distanceToZone}\\n\";\n            guiText += $\"{(navMeshHit.hit ? \"Inside\" : \"Outside\")} of Navmesh\\n\";\n            guiText += $\"Loc: {player.Position.x}, {player.Position.y}, {player.Position.z}\\n\";\n\n            // Draw the GUI\n            guiContent.text = guiText;\n            Vector2 guiSize = guiStyle.CalcSize(guiContent);\n            Rect guiRect = new Rect(\n                Screen.width - guiSize.x - 5f,\n                Screen.height - guiSize.y - 30f,\n                guiSize.x,\n                guiSize.y);\n\n            GUI.Box(guiRect, guiContent, guiStyle);\n        }\n", "            if (guiContent == null)\n            {\n                guiContent = new GUIContent();\n            }\n\n            string zoneName = getCurrentZoneName();\n            string patrolName = getCurrentPatrolName();\n\n            // Build the data to show in the GUI\n            string guiText = \"Waypoint Editor\\n\";\n            guiText += \"-----------------------\\n\";\n\n            guiText += $\"Current Zone: {zoneName}\\n\";\n            guiText += $\"Current Patrol: {patrolName}\\n\";\n            //guiText += $\"Distance To Nearest Waypoint: {distanceToZone}\\n\";\n            guiText += $\"{(navMeshHit.hit ? \"Inside\" : \"Outside\")} of Navmesh\\n\";\n            guiText += $\"Loc: {player.Position.x}, {player.Position.y}, {player.Position.z}\\n\";\n\n            // Draw the GUI\n            guiContent.text = guiText;\n            Vector2 guiSize = guiStyle.CalcSize(guiContent);\n            Rect guiRect = new Rect(\n                Screen.width - guiSize.x - 5f,\n                Screen.height - guiSize.y - 30f,\n                guiSize.x,\n                guiSize.y);\n\n            GUI.Box(guiRect, guiContent, guiStyle);\n        }\n", "        public void Update()\n        {\n            if (Settings.AddWaypointKey.Value.IsDown())\n            {\n                string zoneName = getCurrentZone().NameZone;\n                string patrolName = getCurrentPatrolName();\n\n                // Verify that our dictionary has our zone/patrol in it\n                if (!zoneWaypoints.ContainsKey(zoneName))\n                {\n                    zoneWaypoints.Add(zoneName, new Dictionary<string, CustomPatrol>());\n                }\n", "                if (!zoneWaypoints.ContainsKey(zoneName))\n                {\n                    zoneWaypoints.Add(zoneName, new Dictionary<string, CustomPatrol>());\n                }\n\n                if (!zoneWaypoints[zoneName].ContainsKey(patrolName))\n                {\n                    CustomPatrol patrolWay = new CustomPatrol();\n                    patrolWay.name = patrolName;\n                    patrolWay.patrolType = PatrolType.patrolling;\n                    patrolWay.maxPersons = 10;\n                    patrolWay.blockRoles = 0;\n                    patrolWay.waypoints = new List<CustomWaypoint>();\n                    zoneWaypoints[zoneName].Add(patrolName, patrolWay);\n                }\n\n                // Create and add a waypoint\n                CustomWaypoint waypoint = new CustomWaypoint();\n                waypoint.position = player.Position;\n                waypoint.canUseByBoss = true;\n                waypoint.patrolPointType = PatrolPointType.checkPoint;\n                waypoint.shallSit = false;\n                zoneWaypoints[zoneName][patrolName].waypoints.Add(waypoint);\n\n                // Add the waypoint to the map\n                WaypointPatch.AddOrUpdatePatrol(getCurrentZone(), zoneWaypoints[zoneName][patrolName]);\n                gameObjects.Add(GameObjectHelper.drawSphere(player.Position, 0.5f, new Color(1.0f, 0.41f, 0.09f)));\n\n                // Write output to file\n                Save();\n            }\n            ", "            if (Settings.RemoveWaypointKey.Value.IsDown())\n            {\n                if (DeleteNearestAddedWaypoint(player.Position))\n                {\n                    Save();\n                }\n            }\n\n            if (Settings.NextBotZoneKey.Value.IsDown())\n            {\n                currentZoneIndex++;\n\n                // Loop from the end of the zone list to -1", "            if (Settings.NextBotZoneKey.Value.IsDown())\n            {\n                currentZoneIndex++;\n\n                // Loop from the end of the zone list to -1\n                if (currentZoneIndex >= botZones.Count)\n                {\n                    currentZoneIndex = -1;\n                }\n            }\n", "            if (Settings.PrevBotZoneKey.Value.IsDown())\n            {\n                currentZoneIndex--;\n\n                // Loop from -1 to the end of the zone list\n                if (currentZoneIndex < -1)\n                {\n                    currentZoneIndex = botZones.Count - 1;\n                }\n            }\n        }\n", "        private bool DeleteNearestAddedWaypoint(Vector3 position)\n        {\n            string zoneName = getCurrentZone().NameZone;\n            string patrolName = getCurrentPatrolName();\n\n            // If there are no custom waypoints, just return false\n            if (!zoneWaypoints[zoneName].ContainsKey(patrolName) || zoneWaypoints[zoneName][patrolName].waypoints.Count == 0)\n            {\n                return false;\n            }\n\n            // Find the nearest waypoint we've created this session, and make sure we're near it\n            FindNearestAddedWaypointSphere(position, out GameObject sphere, out float dist);", "            if (dist > 10)\n            {\n                Console.WriteLine($\"Nearest added waypoint is too far away {dist}\");\n                return false;\n            }\n\n            // Remove the visible sphere\n            Vector3 waypointPosition = sphere.transform.position;\n            gameObjects.Remove(sphere);\n            Destroy(sphere);\n\n            // Remove the waypoint from our local data\n            CustomWaypoint waypoint = zoneWaypoints[zoneName][patrolName].waypoints.FirstOrDefault(w => w.position == waypointPosition);", "            if (waypoint != null)\n            {\n                zoneWaypoints[zoneName][patrolName].waypoints.Remove(waypoint);\n            }\n\n            // Remove the waypoint from the map data\n            PatrolWay patrolWay = getCurrentZone().PatrolWays.FirstOrDefault(p => p.name == patrolName);\n            if (patrolWay != null)\n            {\n                PatrolPoint patrolPoint = patrolWay.Points.FirstOrDefault(p => p.position == waypointPosition);\n                if (patrolPoint != null)\n                {\n                    patrolWay.Points.Remove(patrolPoint);\n                    Destroy(patrolPoint.gameObject);\n                }\n            }\n\n            return true;\n        }\n", "                if (patrolPoint != null)\n                {\n                    patrolWay.Points.Remove(patrolPoint);\n                    Destroy(patrolPoint.gameObject);\n                }\n            }\n\n            return true;\n        }\n\n        private void FindNearestAddedWaypointSphere(Vector3 position, out GameObject sphere, out float dist)\n        {\n            sphere = null;\n            dist = float.MaxValue;\n", "        private void FindNearestAddedWaypointSphere(Vector3 position, out GameObject sphere, out float dist)\n        {\n            sphere = null;\n            dist = float.MaxValue;\n\n            foreach (UnityEngine.Object obj in gameObjects)\n            {\n                if (!(obj is GameObject))\n                {\n                    continue;\n                }\n                GameObject gameObject = (GameObject)obj;\n                float sqrMagnitude = (gameObject.transform.position - position).sqrMagnitude;", "                if (sqrMagnitude < dist)\n                {\n                    dist = sqrMagnitude;\n                    sphere = gameObject;\n                }\n            }\n        }\n\n        private void UpdateLocation()\n        {\n            Vector3 currentPosition = player.Position;\n            nearestBotZone = botGame.BotsController.GetClosestZone(currentPosition, out distanceToZone);\n\n            NavMesh.SamplePosition(currentPosition, out navMeshHit, 1f, NavMesh.AllAreas);\n        }\n", "        private void UpdateLocation()\n        {\n            Vector3 currentPosition = player.Position;\n            nearestBotZone = botGame.BotsController.GetClosestZone(currentPosition, out distanceToZone);\n\n            NavMesh.SamplePosition(currentPosition, out navMeshHit, 1f, NavMesh.AllAreas);\n        }\n\n        private void Save()\n        {\n            // Dump the data to file\n            string jsonString = JsonConvert.SerializeObject(zoneWaypoints, Formatting.Indented);\n            File.Create(filename).Dispose();\n            StreamWriter streamWriter = new StreamWriter(filename);\n            streamWriter.Write(jsonString);\n            streamWriter.Flush();\n            streamWriter.Close();\n        }\n", "        private void Save()\n        {\n            // Dump the data to file\n            string jsonString = JsonConvert.SerializeObject(zoneWaypoints, Formatting.Indented);\n            File.Create(filename).Dispose();\n            StreamWriter streamWriter = new StreamWriter(filename);\n            streamWriter.Write(jsonString);\n            streamWriter.Flush();\n            streamWriter.Close();\n        }\n", "        public static void Enable()\n        {\n            if (Singleton<IBotGame>.Instantiated && Settings.EditorEnabled.Value)\n            {\n                var gameWorld = Singleton<GameWorld>.Instance;\n                gameObjects.Add(gameWorld.GetOrAddComponent<EditorComponent>());\n            }\n        }\n\n        public static void Disable()\n        {", "        public static void Disable()\n        {\n            if (Singleton<IBotGame>.Instantiated)\n            {\n                var gameWorld = Singleton<GameWorld>.Instance;\n                gameWorld.GetComponent<EditorComponent>()?.Dispose();\n            }\n        }\n\n        public BotZone getCurrentZone()\n        {\n            return (currentZoneIndex >= 0) ? botZones[currentZoneIndex] : nearestBotZone;\n        }\n", "        public BotZone getCurrentZone()\n        {\n            return (currentZoneIndex >= 0) ? botZones[currentZoneIndex] : nearestBotZone;\n        }\n\n        public string getCurrentZoneName()\n        {\n            BotZone currentZone = getCurrentZone();\n            if (currentZoneIndex < 0)\n            {\n                return $\"Nearest ({currentZone.NameZone})\";\n            }\n\n            return currentZone.NameZone;\n        }\n", "            if (currentZoneIndex < 0)\n            {\n                return $\"Nearest ({currentZone.NameZone})\";\n            }\n\n            return currentZone.NameZone;\n        }\n\n        public string getCurrentPatrolName()\n        {\n            return Settings.CustomPatrolName.Value;\n        }\n    }\n}\n", "        public string getCurrentPatrolName()\n        {\n            return Settings.CustomPatrolName.Value;\n        }\n    }\n}\n"]}
{"filename": "Components/DoorBlockAdderComponent.cs", "chunked_list": ["\ufeffusing BepInEx.Logging;\nusing Comfort.Common;\nusing DrakiaXYZ.Waypoints.Helpers;\nusing EFT;\nusing EFT.Interactive;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.AI;\n\nnamespace DrakiaXYZ.Waypoints.Components", "\nnamespace DrakiaXYZ.Waypoints.Components\n{\n    internal class DoorBlockAdderComponent : MonoBehaviour\n    {\n        List<DoorContainer> doorList = new List<DoorContainer>();\n        float nextUpdate = 0f;\n        protected ManualLogSource Logger = null;\n\n        public void Awake()\n        {\n            Logger = BepInEx.Logging.Logger.CreateLogSource(GetType().Name);\n\n            var gameWorld = Singleton<GameWorld>.Instance;\n            string mapName = gameWorld.MainPlayer.Location.ToLower();\n\n            FindObjectsOfType<Collider>().ExecuteForEach(collider =>\n            {\n                // We don't support doors that aren't on the \"Door\" layer", "        public void Awake()\n        {\n            Logger = BepInEx.Logging.Logger.CreateLogSource(GetType().Name);\n\n            var gameWorld = Singleton<GameWorld>.Instance;\n            string mapName = gameWorld.MainPlayer.Location.ToLower();\n\n            FindObjectsOfType<Collider>().ExecuteForEach(collider =>\n            {\n                // We don't support doors that aren't on the \"Door\" layer\n                if (collider.gameObject.layer != LayerMaskClass.DoorLayer)\n                {\n                    return;\n                }\n\n                // We don't support doors that don't have an \"Interactive\" parent\n                GameObject doorObject = collider.transform.parent.gameObject;\n                WorldInteractiveObject door = doorObject.GetComponent<WorldInteractiveObject>();\n\n                // If we don't have a door object, and the layer isn't interactive, skip\n                // Note: We have to do a door null check here because Factory has some non-interactive doors that bots can use...", "                if (collider.gameObject.layer != LayerMaskClass.DoorLayer)\n                {\n                    return;\n                }\n\n                // We don't support doors that don't have an \"Interactive\" parent\n                GameObject doorObject = collider.transform.parent.gameObject;\n                WorldInteractiveObject door = doorObject.GetComponent<WorldInteractiveObject>();\n\n                // If we don't have a door object, and the layer isn't interactive, skip\n                // Note: We have to do a door null check here because Factory has some non-interactive doors that bots can use...", "                if (door == null)\n                {\n                    // Note: Labs is a special case where fake doors don't always have an interactive parent...\n                    if (mapName.StartsWith(\"laboratory\"))\n                    {\n                        if (doorObject.layer != 0 && doorObject.layer != LayerMaskClass.InteractiveLayer)\n                        {\n                            //Logger.LogDebug($\"Skipping labs door ({doorObject.name}) due to layer {doorObject.layer} != 0 && != {LayerMaskClass.InteractiveLayer.value}\");\n                            return;\n                        }\n                    }", "                    else if (doorObject.layer != LayerMaskClass.InteractiveLayer)\n                    {\n                        //Logger.LogDebug($\"Skipping door ({doorObject.name}) due to layer {doorObject.layer} != {LayerMaskClass.InteractiveLayer.value}\");\n                        return;\n                    }\n                }\n\n                // If the door is an interactive object, and it's open or shut, we don't need to worry about it\n                if (door != null && door.enabled && (door.DoorState == EDoorState.Open || door.DoorState == EDoorState.Shut))\n                {\n                    drawDebugSphere(collider.bounds.center, 0.5f, Color.blue);\n                    //Logger.LogDebug($\"Found an open/closed door, skipping\");\n                    return;\n                }\n\n                // Make sure the door is tall, otherwise it's probably not a real door", "                if (door != null && door.enabled && (door.DoorState == EDoorState.Open || door.DoorState == EDoorState.Shut))\n                {\n                    drawDebugSphere(collider.bounds.center, 0.5f, Color.blue);\n                    //Logger.LogDebug($\"Found an open/closed door, skipping\");\n                    return;\n                }\n\n                // Make sure the door is tall, otherwise it's probably not a real door\n                if (collider.bounds.size.y < 1.5f)\n                {\n                    drawDebugSphere(collider.bounds.center, 0.5f, Color.yellow);\n                    //Logger.LogDebug($\"Skipping door ({meshCollider.name}) that's not tall enough ({meshCollider.bounds.center}) ({meshCollider.bounds.size})\");\n                    return;\n                }\n\n                GameObject obstacleObject = new GameObject(\"ObstacleObject\");\n                NavMeshObstacle navMeshObstacle = obstacleObject.AddComponent<NavMeshObstacle>();\n\n                // We use a small cube, to avoid cutting into the hallway mesh\n                navMeshObstacle.size = collider.bounds.size;\n                navMeshObstacle.carving = true;\n                navMeshObstacle.carveOnlyStationary = false;\n\n                // Position the new gameObject\n                obstacleObject.transform.SetParent(collider.transform);\n                obstacleObject.transform.position = collider.bounds.center;\n\n                // If the door was locked, we want to keep track of it to remove the blocker when it's unlocked", "                if (collider.bounds.size.y < 1.5f)\n                {\n                    drawDebugSphere(collider.bounds.center, 0.5f, Color.yellow);\n                    //Logger.LogDebug($\"Skipping door ({meshCollider.name}) that's not tall enough ({meshCollider.bounds.center}) ({meshCollider.bounds.size})\");\n                    return;\n                }\n\n                GameObject obstacleObject = new GameObject(\"ObstacleObject\");\n                NavMeshObstacle navMeshObstacle = obstacleObject.AddComponent<NavMeshObstacle>();\n\n                // We use a small cube, to avoid cutting into the hallway mesh\n                navMeshObstacle.size = collider.bounds.size;\n                navMeshObstacle.carving = true;\n                navMeshObstacle.carveOnlyStationary = false;\n\n                // Position the new gameObject\n                obstacleObject.transform.SetParent(collider.transform);\n                obstacleObject.transform.position = collider.bounds.center;\n\n                // If the door was locked, we want to keep track of it to remove the blocker when it's unlocked", "                if (door != null && door.DoorState == EDoorState.Locked)\n                {\n                    DoorContainer doorContainer = new DoorContainer();\n                    doorContainer.door = door;\n                    doorContainer.collider = collider;\n                    doorContainer.navMeshObstacle = navMeshObstacle;\n                    doorContainer.sphere = drawDebugSphere(obstacleObject.transform.position, 0.5f, Color.red);\n                    doorList.Add(doorContainer);\n                }\n                else\n                {\n                    drawDebugSphere(obstacleObject.transform.position, 0.5f, Color.magenta);\n                }\n            });\n        }\n", "        public void Update()\n        {\n            if (Time.time > nextUpdate)\n            {\n                for (int i = doorList.Count - 1; i >= 0; i--)\n                {\n                    DoorContainer doorContainer = doorList[i];\n\n                    // If the door has been unlocked, delete the blocker\n                    if (doorContainer.door.DoorState != EDoorState.Locked && doorContainer.door.DoorState != EDoorState.Interacting)\n                    {\n                        //Logger.LogDebug($\"DoorState is now {doorContainer.door.DoorState}, removing blocker\");", "                    if (doorContainer.door.DoorState != EDoorState.Locked && doorContainer.door.DoorState != EDoorState.Interacting)\n                    {\n                        //Logger.LogDebug($\"DoorState is now {doorContainer.door.DoorState}, removing blocker\");\n                        if (doorContainer.sphere != null)\n                        {\n                            Destroy(doorContainer.sphere);\n                        }\n\n                        Destroy(doorContainer.navMeshObstacle);\n                        doorList.RemoveAt(i);\n                    }\n                }\n\n                nextUpdate = Time.time + 0.5f;\n            }\n        }\n", "        private GameObject drawDebugSphere(Vector3 position, float size, Color color)\n        {\n#if DEBUG\n            return GameObjectHelper.drawSphere(position, size, color);\n#else\n            return null;\n#endif\n        }\n\n        public static void Enable()\n        {", "        public static void Enable()\n        {\n            if (Singleton<IBotGame>.Instantiated)\n            {\n                var gameWorld = Singleton<GameWorld>.Instance;\n                gameWorld.GetOrAddComponent<DoorBlockAdderComponent>();\n            }\n        }\n    }\n\n    internal struct DoorContainer\n    {", "    internal struct DoorContainer\n    {\n        public WorldInteractiveObject door;\n        public Collider collider;\n        public NavMeshObstacle navMeshObstacle;\n        public GameObject sphere;\n    }\n}\n"]}
{"filename": "Components/BotZoneDebugComponent.cs", "chunked_list": ["\ufeffusing Comfort.Common;\nusing DrakiaXYZ.Waypoints.Helpers;\nusing EFT;\nusing EFT.Game.Spawning;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing UnityEngine;\n\nnamespace DrakiaXYZ.Waypoints.Components", "\nnamespace DrakiaXYZ.Waypoints.Components\n{\n    internal class BotZoneDebugComponent : MonoBehaviour, IDisposable\n    {\n        private static List<UnityEngine.Object> gameObjects = new List<UnityEngine.Object>();\n\n        private List<SpawnPointMarker> spawnPoints = new List<SpawnPointMarker>();\n        private List<BotZone> botZones = new List<BotZone>();\n\n        public void Awake()\n        {\n            Console.WriteLine(\"BotZoneDebug::Awake\");\n\n            // Cache spawn points so we don't constantly need to re-fetch them\n            CachePoints(true);\n\n            // Create static game objects\n            createSpawnPointObjects();\n            createBotZoneObjects();\n        }\n", "        public void Awake()\n        {\n            Console.WriteLine(\"BotZoneDebug::Awake\");\n\n            // Cache spawn points so we don't constantly need to re-fetch them\n            CachePoints(true);\n\n            // Create static game objects\n            createSpawnPointObjects();\n            createBotZoneObjects();\n        }\n", "        public void Dispose()\n        {\n            Console.WriteLine(\"BotZoneDebugComponent::Dispose\");\n            gameObjects.ForEach(Destroy);\n            gameObjects.Clear();\n            spawnPoints.Clear();\n            botZones.Clear();\n        }\n\n        private void createSpawnPointObjects()\n        {\n            // Draw spawn point markers", "        private void createSpawnPointObjects()\n        {\n            // Draw spawn point markers\n            if (spawnPoints.Count > 0)\n            {\n                Console.WriteLine($\"Found {spawnPoints.Count} SpawnPointMarkers\");\n                foreach (SpawnPointMarker spawnPointMarker in spawnPoints)\n                {\n                    var spawnPoint = GameObject.CreatePrimitive(PrimitiveType.Cylinder);\n                    spawnPoint.GetComponent<Renderer>().material.color = Color.blue;\n                    spawnPoint.GetComponent<Collider>().enabled = false;\n                    spawnPoint.transform.localScale = new Vector3(0.1f, 1.0f, 0.1f);\n                    spawnPoint.transform.position = new Vector3(spawnPointMarker.Position.x, spawnPointMarker.Position.y + 1.0f, spawnPointMarker.Position.z);\n\n                    gameObjects.Add(spawnPoint);\n                }\n            }\n        }\n", "        private void createBotZoneObjects()\n        {\n            foreach (BotZone botZone in botZones)\n            {\n                Console.WriteLine($\"Drawing BotZone {botZone.NameZone}\");\n                Console.WriteLine($\"BushPoints (Green): {botZone.BushPoints.Length}\");\n                Console.WriteLine($\"CoverPoints (Blue): {botZone.CoverPoints.Length}\");\n                Console.WriteLine($\"AmbushPoints (Red): {botZone.AmbushPoints.Length}\");\n                Console.WriteLine($\"PatrolWays: {botZone.PatrolWays.Length}\");\n                foreach (PatrolWay patrol in botZone.PatrolWays)\n                {\n                    Console.WriteLine($\"    {patrol.name}\");\n                }\n\n                // Bushpoints are green", "                foreach (PatrolWay patrol in botZone.PatrolWays)\n                {\n                    Console.WriteLine($\"    {patrol.name}\");\n                }\n\n                // Bushpoints are green\n                foreach (CustomNavigationPoint bushPoint in botZone.BushPoints)\n                {\n                    gameObjects.Add(GameObjectHelper.drawSphere(bushPoint.Position, 0.5f, Color.green));\n                }\n\n                // Coverpoints are blue\n                var coverPoints = botZone.CoverPoints;", "                foreach (CustomNavigationPoint coverPoint in coverPoints)\n                {\n                    gameObjects.Add(GameObjectHelper.drawSphere(coverPoint.Position, 0.5f, Color.blue));\n                }\n\n                // Ambushpoints are red\n                var ambushPoints = botZone.AmbushPoints;\n                foreach (CustomNavigationPoint ambushPoint in ambushPoints)\n                {\n                    gameObjects.Add(GameObjectHelper.drawSphere(ambushPoint.Position, 0.5f, Color.red));\n                }\n\n                // Patrol points are yellow\n                var patrolWays = botZone.PatrolWays;", "                foreach (PatrolWay patrolWay in patrolWays)\n                {\n                    foreach (PatrolPoint patrolPoint in patrolWay.Points)\n                    {\n                        gameObjects.Add(GameObjectHelper.drawSphere(patrolPoint.Position, 0.5f, Color.yellow));\n\n                        //// Sub-points are purple\n                        //foreach (PatrolPoint subPoint in patrolPoint.subPoints)\n                        //{\n                        //    gameObjects.Add(GameObjectHelper.drawSphere(subPoint.Position, 0.25f, Color.magenta));\n                        //}\n                    }\n                }\n            }\n        }\n", "        private void CachePoints(bool forced)\n        {\n            if (forced || spawnPoints.Count == 0)\n            {\n                spawnPoints = FindObjectsOfType<SpawnPointMarker>().ToList();\n            }\n\n            if (forced || botZones.Count == 0)\n            {\n                botZones = LocationScene.GetAll<BotZone>().ToList();\n            }\n        }\n", "        public static void Enable()\n        {\n            if (Singleton<IBotGame>.Instantiated && Settings.DebugEnabled.Value)\n            {\n                var gameWorld = Singleton<GameWorld>.Instance;\n                gameObjects.Add(gameWorld.GetOrAddComponent<BotZoneDebugComponent>());\n            }\n        }\n\n        public static void Disable()\n        {", "        public static void Disable()\n        {\n            if (Singleton<IBotGame>.Instantiated)\n            {\n                var gameWorld = Singleton<GameWorld>.Instance;\n                gameWorld.GetComponent<BotZoneDebugComponent>()?.Dispose();\n            }\n        }\n    }\n}\n"]}
{"filename": "Components/NavMeshDebugComponent.cs", "chunked_list": ["\ufeffusing Comfort.Common;\nusing DrakiaXYZ.Waypoints.Helpers;\nusing EFT;\nusing Newtonsoft.Json;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing UnityEngine;\nusing UnityEngine.AI;", "using UnityEngine;\nusing UnityEngine.AI;\n\nnamespace DrakiaXYZ.Waypoints.Components\n{\n    internal class NavMeshDebugComponent : MonoBehaviour, IDisposable\n    {\n        private NavMeshTriangulation meshData;\n        private static List<UnityEngine.Object> gameObjects = new List<UnityEngine.Object>();\n\n        public void Dispose()\n        {\n            Console.WriteLine(\"NavMeshDebug::Dispose\");\n            gameObjects.ForEach(Destroy);\n            gameObjects.Clear();\n        }\n", "        private static List<UnityEngine.Object> gameObjects = new List<UnityEngine.Object>();\n\n        public void Dispose()\n        {\n            Console.WriteLine(\"NavMeshDebug::Dispose\");\n            gameObjects.ForEach(Destroy);\n            gameObjects.Clear();\n        }\n\n        public void Awake()\n        {\n            Console.WriteLine(\"NavMeshDebug::Awake\");\n", "        public void Awake()\n        {\n            Console.WriteLine(\"NavMeshDebug::Awake\");\n\n            if (!Singleton<IBotGame>.Instantiated)\n            {\n                Console.WriteLine(\"Can't create NavMeshDebug with no BotGame\");\n                return;\n            }\n\n            // Setup our gameObject\n            gameObjects.Add(gameObject.AddComponent<MeshFilter>());\n            gameObjects.Add(gameObject.AddComponent<MeshRenderer>());\n\n            // Build a dictionary of sub areas\n            meshData = NavMesh.CalculateTriangulation();\n            Console.WriteLine($\"NavMeshTriangulation Found. Vertices: {meshData.vertices.Length}\");\n\n            gameObject.GetComponent<MeshRenderer>().material.color = new Color(1.0f, 0.0f, 1.0f, 0.5f);\n\n            // Adjust each vertices up by a margin so we can see the navmesh better\n            Vector3[] adjustedVertices = meshData.vertices.Select(v => new Vector3(v.x, v.y + Settings.NavMeshOffset.Value, v.z)).ToArray();\n\n            // Create our new mesh and add all the vertices\n            Mesh mesh = new Mesh();\n            mesh.indexFormat = UnityEngine.Rendering.IndexFormat.UInt32;\n            mesh.vertices = adjustedVertices;\n            mesh.triangles = meshData.indices;\n            Vector2[] uvs = new Vector2[mesh.vertices.Length];", "            for (int i = 0; i < uvs.Length; i++)\n            {\n                uvs[i] = new Vector2(0f, 0f);\n            }\n            mesh.uv = uvs;\n            mesh.RecalculateNormals();\n            mesh.RecalculateBounds();\n            \n\n            // Set mesh of our gameObject\n            GetComponent<MeshFilter>().mesh = mesh;\n\n            // If dumping is enabled, dump to a JSON file", "            if (Settings.ExportNavMesh.Value)\n            {\n                Directory.CreateDirectory(WaypointsPlugin.MeshFolder);\n\n                var gameWorld = Singleton<GameWorld>.Instance;\n                string mapName = gameWorld.MainPlayer.Location.ToLower();\n                string meshFilename = $\"{WaypointsPlugin.MeshFolder}\\\\{mapName}.json\";\n                if (!File.Exists(meshFilename))\n                {\n                    string jsonString = JsonConvert.SerializeObject(meshData, Formatting.Indented);\n                    File.Create(meshFilename).Dispose();\n                    StreamWriter streamWriter = new StreamWriter(meshFilename);\n                    streamWriter.Write(jsonString);\n                    streamWriter.Flush();\n                    streamWriter.Close();\n                }\n            }\n        }\n", "        public static void Enable()\n        {\n            if (Singleton<IBotGame>.Instantiated && Settings.ShowNavMesh.Value)\n            {\n                var gameWorld = Singleton<GameWorld>.Instance;\n                gameObjects.Add(gameWorld.GetOrAddComponent<NavMeshDebugComponent>());\n            }\n        }\n\n        public static void Disable()\n        {", "        public static void Disable()\n        {\n            if (Singleton<IBotGame>.Instantiated)\n            {\n                var gameWorld = Singleton<GameWorld>.Instance;\n                gameWorld.GetComponent<NavMeshDebugComponent>()?.Dispose();\n            }\n        }\n    }\n}\n"]}
{"filename": "BrainLogic/RoamingLogic.cs", "chunked_list": ["\ufeffusing BepInEx.Logging;\nusing DrakiaXYZ.BigBrain.Brains;\nusing EFT;\nusing System;\nusing UnityEngine;\nusing UnityEngine.AI;\n\nnamespace DrakiaXYZ.Waypoints.BrainLogic\n{\n// Note: We only include this in debug builds for now, because we're not shipping BigBrain", "{\n// Note: We only include this in debug builds for now, because we're not shipping BigBrain\n#if DEBUG\n    internal class RoamingLogic : CustomLogic\n    {\n        protected ManualLogSource Logger;\n        Vector3? targetPos = null;\n        float sprintCheckTime;\n        NavMeshPath navMeshPath;\n\n        public RoamingLogic(BotOwner bot) : base(bot)\n        {\n            Logger = BepInEx.Logging.Logger.CreateLogSource(GetType().Name);\n            navMeshPath = new NavMeshPath();\n        }\n", "        public override void Start()\n        {\n            // When we start roaming, disable the bot patroller, since we're in control now\n            BotOwner.PatrollingData.Pause();\n        }\n\n        public override void Stop()\n        {\n            // When we're done this layer, re-enable the patroller\n            BotOwner.PatrollingData.Unpause();\n\n            // Clear targetPos, so we pick a new one next time we are active\n            targetPos = null;\n        }\n", "        public override void Update()\n        {\n            // Look where you're going\n            BotOwner.SetPose(1f);\n            BotOwner.Steering.LookToMovingDirection();\n            BotOwner.SetTargetMoveSpeed(1f);\n\n            // Alternate between running and walking\n            if (BotOwner.Mover.Sprinting && BotOwner.GetPlayer.Physical.Stamina.NormalValue < 0.3f)\n            {\n                //Logger.LogDebug($\"{BotOwner.name} Ending Sprint\");\n                BotOwner.GetPlayer.EnableSprint(false);\n            }\n\n            // Enough stamina to check? See if we're within our time window", "            if (BotOwner.Mover.Sprinting && BotOwner.GetPlayer.Physical.Stamina.NormalValue < 0.3f)\n            {\n                //Logger.LogDebug($\"{BotOwner.name} Ending Sprint\");\n                BotOwner.GetPlayer.EnableSprint(false);\n            }\n\n            // Enough stamina to check? See if we're within our time window\n            if (!BotOwner.Mover.Sprinting && BotOwner.GetPlayer.Physical.Stamina.NormalValue > 0.8f)\n            {\n                if (sprintCheckTime < Time.time)\n                {\n                    sprintCheckTime = Time.time + 5f;\n\n                    // Random chance to sprint\n                    int randomChance = UnityEngine.Random.Range(0, 1000);\n                    //Logger.LogDebug($\"{BotOwner.name} Stamina: {BotOwner.GetPlayer.Physical.Stamina.NormalValue}  Random: {randomChance}  Chance: {BotOwner.Settings.FileSettings.Patrol.SPRINT_BETWEEN_CACHED_POINTS}\");", "                if (sprintCheckTime < Time.time)\n                {\n                    sprintCheckTime = Time.time + 5f;\n\n                    // Random chance to sprint\n                    int randomChance = UnityEngine.Random.Range(0, 1000);\n                    //Logger.LogDebug($\"{BotOwner.name} Stamina: {BotOwner.GetPlayer.Physical.Stamina.NormalValue}  Random: {randomChance}  Chance: {BotOwner.Settings.FileSettings.Patrol.SPRINT_BETWEEN_CACHED_POINTS}\");\n                    if (randomChance < BotOwner.Settings.FileSettings.Patrol.SPRINT_BETWEEN_CACHED_POINTS)\n                    {\n                        //Logger.LogDebug($\"{BotOwner.name} Starting Sprint\");\n                        BotOwner.GetPlayer.EnableSprint(true);\n                    }\n                }\n            }\n\n            // If we have a target position, and we're already there, clear it", "            if (targetPos != null && (targetPos.Value - BotOwner.Position).sqrMagnitude < 4f)\n            {\n                Logger.LogDebug($\"{BotOwner.name} reach destination\");\n                targetPos = null;\n            }\n\n            // If we don't have a target position yet, pick one\n            int i = 0;\n            while (targetPos == null && i < 10)\n            {\n                Vector3 randomPos = UnityEngine.Random.insideUnitSphere * 100f;\n                randomPos += BotOwner.Position;", "            while (targetPos == null && i < 10)\n            {\n                Vector3 randomPos = UnityEngine.Random.insideUnitSphere * 100f;\n                randomPos += BotOwner.Position;\n                if (NavMesh.SamplePosition(randomPos, out var navHit, 100f, NavMesh.AllAreas))\n                {\n                    if (NavMesh.CalculatePath(BotOwner.Position, navHit.position, NavMesh.AllAreas, navMeshPath) && navMeshPath.status == NavMeshPathStatus.PathComplete)\n                    {\n                        targetPos = navHit.position;\n                        BotOwner.GoToPoint(targetPos.Value, true, -1f, false, true, true);\n                        Logger.LogDebug($\"{BotOwner.name} going to {targetPos.Value}\");\n                    }\n                }\n\n                i++;\n            }\n", "            if (targetPos == null)\n            {\n                Logger.LogError($\"Unable to find a location for {BotOwner.name}\");\n            }\n\n            BotOwner.DoorOpener.Update();\n\n            gclass272_0.Update(BotOwner);\n        }\n\n        private GClass272 gclass272_0 = new GClass272();\n    }\n#endif\n}\n", "        private GClass272 gclass272_0 = new GClass272();\n    }\n#endif\n}\n"]}
{"filename": "BrainLogic/RoamingLayer.cs", "chunked_list": ["\ufeffusing BepInEx.Logging;\nusing DrakiaXYZ.BigBrain.Brains;\nusing EFT;\nusing UnityEngine;\n\nnamespace DrakiaXYZ.Waypoints.BrainLogic\n{\n// Note: We only include this in debug builds for now, because we're not shipping BigBrain\n#if DEBUG\n    internal class RoamingLayer : CustomLayer\n    {", "#if DEBUG\n    internal class RoamingLayer : CustomLayer\n    {\n        protected ManualLogSource Logger;\n        protected float nextRoamCheckTime = 0f;\n        protected bool isActive = false;\n\n        public RoamingLayer(BotOwner botOwner, int priority) : base(botOwner, priority)\n        {\n            Logger = BepInEx.Logging.Logger.CreateLogSource(this.GetType().Name);\n            Logger.LogInfo($\"Added roaming to {botOwner.name}\");\n        }\n", "        public override string GetName()\n        {\n            return \"Roaming\";\n        }\n\n        public override bool IsActive()\n        {\n            // If we're not in peace, we can't be roaming, otherwise we die\n            if (!BotOwner.Memory.IsPeace)\n            {\n                return false;\n            }\n\n            // If we're active already, then stay active", "            if (!BotOwner.Memory.IsPeace)\n            {\n                return false;\n            }\n\n            // If we're active already, then stay active\n            if (isActive)\n            {\n                return true;\n            }\n\n            // If it's been long enough, check if we should roam", "            if (Time.time > nextRoamCheckTime)\n            {\n                Logger.LogDebug($\"Checking if {BotOwner.name} should roam\");\n                nextRoamCheckTime = Time.time + 10f;\n\n                if (Random.Range(0, 100) > 50)\n                {\n                    Logger.LogDebug(\"  Roaming\");\n                    isActive = true;\n                    return true;\n                }\n                else\n                {\n                    Logger.LogDebug(\"  Not Roaming\");\n                }\n            }\n\n            return false;\n        }\n", "        public override Action GetNextAction()\n        {\n            return new Action(typeof(RoamingLogic), \"Roaming\");\n        }\n\n        public override bool IsCurrentActionEnding()\n        {\n            // We only have one action, so it's never ending\n            return false;\n        }\n    }\n#endif\n}\n"]}
