{"filename": "WAGIapp/Program.cs", "chunked_list": ["using Microsoft.AspNetCore.Components.Web;\nusing Microsoft.AspNetCore.Components.WebAssembly.Hosting;\nusing Microsoft.AspNetCore.Cors.Infrastructure;\n\nusing WAGIapp;\n\nusing MudBlazor.Services;\nusing WAGIapp.AI;\n\nusing System;", "\nusing System;\nusing System.Threading;\nusing System.Runtime.Versioning;\nusing System.Runtime.InteropServices.JavaScript;\nusing System.Net.Http;\n\n[assembly: SupportedOSPlatform(\"browser\")]\n\nvar builder = WebAssemblyHostBuilder.CreateDefault(args);", "\nvar builder = WebAssemblyHostBuilder.CreateDefault(args);\nbuilder.RootComponents.Add<App>(\"#app\");\nbuilder.RootComponents.Add<HeadOutlet>(\"head::after\");\n\nbuilder.Services.AddScoped(sp => new HttpClient { BaseAddress = new Uri(builder.HostEnvironment.BaseAddress) });\n\nbuilder.Services.AddMudServices();\n/*\nbuilder.Services.AddCors(options =>", "/*\nbuilder.Services.AddCors(options =>\n{\n    options.AddDefaultPolicy(\n        policy =>\n        {\n            policy.AllowAnyHeader();  //set the allowed origin  \n            policy.AllowAnyMethod();\n            policy.AllowAnyOrigin();\n        });", "            policy.AllowAnyOrigin();\n        });\n});*/\n\n/*\nMaster.Singleton.Actions.AddAction(\"Thinking\", LogAction.ThinkIcon);\nMaster.Singleton.Actions.AddAction(\"Creating a memory\", LogAction.MemoryIcon);\nMaster.Singleton.Actions.AddAction(\"Hello there\");\n*/\n", "*/\n\n\nTask.Run(async () =>\n{\n    while (true)\n    {\n        await Task.Delay(10000);\n        await Master.Singleton.Tick();\n        /*switch (Random.Shared.Next(0,6))\n        {\n            case 0:\n                var a = Master.Singleton.Actions.AddAction(\"Thinking\", LogAction.ThinkIcon);\n                await Task.Delay(4000);\n                a.Text = \"testing text is cool and all but does the transition finally work of what? im quite tired of waiting for it to start working .. i would love to get to other things and stop obsesing about this.\";\n                break;\n            case 1:\n                Master.Singleton.Actions.AddAction(\"Creating a memory\", LogAction.MemoryIcon);\n                break;\n            case 2:\n                Master.Singleton.Actions.AddAction(\"Hello there\");\n                break;\n            case 3:\n                Master.Singleton.Notes.Add(\"Notes are cool and its cool i can show them!\");\n                break;\n            case 4:\n                Master.Singleton.Notes.Add(\"Notes are cool and its\\ncool i can show them!\");\n                break;\n            case 5:\n                Master.Singleton.Notes.Add(\"Notes are cool and its cool i can show them! but what if they are looooong as fuck .. will the ui manage or will it breaky?\");\n                break;\n\n        }*/\n\n\n\n    }\n}).ConfigureAwait(true);\n\n\n\nawait builder.Build().RunAsync();\n"]}
{"filename": "WAGIapp/AI/LongTermMemory.cs", "chunked_list": ["\ufeffusing System;\nusing WAGIapp.AI;\n\nnamespace WAGIapp.AI\n{\n    internal class LongTermMemory\n    {\n        public List<Memory> memories;\n        public HashSet<int> lastUsedMemories;\n        public HashSet<string> tags;\n", "        public bool MemoryChanged = false;\n\n        private int maxMemorySize;\n\n        public LongTermMemory(int maxMem = 256)\n        {\n            memories = new List<Memory>();\n            lastUsedMemories = new HashSet<int>();\n            tags = new HashSet<string>();\n            maxMemorySize = maxMem;\n        }\n", "        public async Task MakeMemory(string state)\n        {\n            string tagString = \"Tags:\\n\";\n\n            foreach (var tag in tags)\n                tagString += tag + \" ,\";\n            tagString.TrimEnd(',');\n            tagString += \"\\n\";\n\n            ChatMessage tagsListMessage = new ChatMessage(ChatRole.System, tagString);\n            ChatMessage stateMessage = new ChatMessage(ChatRole.User, state);\n\n            string mem = await OpenAI.GetChatCompletion(ChatModel.ChatGPT, new List<ChatMessage>() { tagsListMessage, Texts.ShortTermMemoryAddPrompt, stateMessage, Texts.ShortTermMemoryAddFormat });\n            mem = Utils.ExtractJson(mem);\n\n            try\n            {\n                Memory memory = new Memory(Utils.GetObjectFromJson<OutputMemoryAI>(mem));\n                memories.Add(memory);\n", "                foreach (var tag in memory.Tags)\n                {\n                    tags.Add(tag);\n                }\n\n                Console.WriteLine(\"New short term memory:\" + mem);\n            }\n            catch (Exception)\n            {\n                Console.WriteLine(\"Add memory failed\");\n            }\n\n            MemoryChanged = true;\n        }\n", "        public async Task<string> GetMemories(string input)\n        {\n            string memoryInput = \"\";\n\n            memoryInput += \"Available tags:\\n\";\n\n            foreach (string tag in tags)\n                memoryInput += tag + \", \";\n\n            memoryInput += \"\\nInput:\\n\";\n            memoryInput += input;\n\n            ChatMessage memoryState = new ChatMessage(ChatRole.User, memoryInput);\n\n\n            string mem;\n            OutputMemoryTagsJson memoryTags;", "            while (true)\n            {\n                try\n                {\n                    mem = await OpenAI.GetChatCompletion(ChatModel.ChatGPT, new List<ChatMessage>() { Texts.ShortTermMemoryGetPrompt, memoryState, Texts.ShortTermMemoryGetFormat });\n                    memoryTags = Utils.GetObjectFromJson<OutputMemoryTagsJson>(mem);\n                    break;\n                }\n                catch (Exception)\n                {\n                    Console.WriteLine(\"Get memory failed - trying again\");\n                }\n\n            }\n\n            HashSet<string> splitTags = Utils.CleanInput(memoryTags.tags.Split(\",\")).ToHashSet();\n\n            memories.Sort((memory1, memory2) => MathF.Sign(memory2.GetScore(splitTags) - memory1.GetScore(splitTags)));\n            lastUsedMemories.Clear();\n\n            string output = \"\";\n", "                catch (Exception)\n                {\n                    Console.WriteLine(\"Get memory failed - trying again\");\n                }\n\n            }\n\n            HashSet<string> splitTags = Utils.CleanInput(memoryTags.tags.Split(\",\")).ToHashSet();\n\n            memories.Sort((memory1, memory2) => MathF.Sign(memory2.GetScore(splitTags) - memory1.GetScore(splitTags)));\n            lastUsedMemories.Clear();\n\n            string output = \"\";\n", "            for (int i = 0; i < memories.Count && output.Split(\" \").Length < maxMemorySize; i++)\n            {\n                output += (i + 1) + \". \\n\";\n                foreach (var tag in memories[i].Tags)\n                {\n                    output += tag + \",\";\n                }\n                output += \"\\nScore: \" + memories[i].GetScore(splitTags) + \"\\n\";\n                memories[i].Remembered += memories[i].GetScore(splitTags);\n                output += memories[i].Content + \"\\n\";\n                lastUsedMemories.Add(i);\n            }\n\n            MemoryChanged = true;\n            return output;\n        }\n\n", "        public object GetGraphData()\n        {\n            MemoryChanged = false;\n\n            GraphMemoryData data = new();\n\n            data.nodes = new List<GraphMemoryNode>();\n\n            for (int i = 0; i < memories.Count; i++)\n            {\n                data.nodes.Add(new GraphMemoryNode() { id = i, name = memories[i].Tags.First(), text = memories[i].Content, color = lastUsedMemories.Contains(i)? \"#0bba83\" : \"#dddddd\" });\n            }\n\n", "            for (int i = 0; i < memories.Count; i++)\n            {\n                data.nodes.Add(new GraphMemoryNode() { id = i, name = memories[i].Tags.First(), text = memories[i].Content, color = lastUsedMemories.Contains(i)? \"#0bba83\" : \"#dddddd\" });\n            }\n\n\n            for (int i = 0; i < memories.Count; i++)\n            {\n                for (int j = 0; j < memories.Count; j++)\n                {\n                    if (i == j)\n                        continue;\n", "                for (int j = 0; j < memories.Count; j++)\n                {\n                    if (i == j)\n                        continue;\n\n                    if (memories[i].GetScore(memories[j].Tags) > 0)\n                        data.links.Add(new GraphMemoryLink() { target = i, source = j, label = memories[i].GetCommonTag(memories[j].Tags), width = memories[i].GetScore(memories[j].Tags) });\n\n                }\n            }\n\n            return data;\n        }\n    }\n}\n"]}
{"filename": "WAGIapp/AI/Settings.cs", "chunked_list": ["\ufeffnamespace WAGIapp.AI\n{\n    internal static class Settings\n    {\n        public static string OpenAIApiKey = \"\";\n        public static string Rules = \"\" +\n            \"The basic info\\n\" +\n            \"1. You are now an autonomous AI\\n\" +\n            \"3. You can use the commands given above, but only one command at a time\\n\" +\n            \"4. You have memory and can remember things you already thought about\\n\" +\n            \"5. You have a script file you can write to using commands given above\\n\" +\n            \"6. You have a notepad you can write things you want to using given commands\\n\" +\n\n            \"\\n\" +\n            \"Here are the rules you must follow\\n\" +\n            \"1. You can only respond in the specified output format\\n\" +\n            \"2. Only call one command at the time\\n\" +\n            \"3. Call the goal-reached command as soon as you finish the main goal\\n\";\n", "        public static string Goal = \"1. Write me a javascript script into your script file that will compute the digits of pi and write them out one by one into the console\\n2. Comment and edit the script file to make it more readable\\n3. recheck the code before you call goal-reached\";\n\n    }\n}\n"]}
{"filename": "WAGIapp/AI/Commands.cs", "chunked_list": ["\ufeffusing WAGIapp.AI.AICommands;\n\nnamespace WAGIapp.AI\n{\n    internal class Commands\n    {\n        private static Dictionary<string, Command> commands;\n        static Commands()\n        {\n            commands = new Dictionary<string, Command>();\n\n            Command c;\n\n            c = new NoActionCommand();\n            commands.Add(c.Name, c);\n            c = new GoalReachedCommand();\n            commands.Add(c.Name, c);\n            c = new AddNoteCommand();\n            commands.Add(c.Name, c);\n            c = new RemoveNoteCommand();\n            commands.Add(c.Name, c);\n            c = new SearchWebCommand();\n            commands.Add(c.Name, c);\n            c = new RemoveLineCommand();\n            commands.Add(c.Name, c);\n            c = new WriteLineCommand();\n            commands.Add(c.Name, c);\n\n        }\n\n", "        public static string GetCommands()\n        {\n            string output = \"\";\n\n            foreach (Command c in commands.Values)\n            {\n                output += c.Name + \"\\n\";\n                output += \"\\t\" + c.Description + \"\\n\";\n                output += \"\\t\" + \"Call format: \" + c.Format + \"\\n\";\n            }\n\n            return output;\n        }\n", "        public static async Task<string> TryToRun(Master caller, string commandText)\n        {\n            string[] args = commandText.Split(\"|\");\n\n            for (int i = 0; i < args.Length; i++)\n            {\n                args[i] = args[i].Trim();\n            }\n\n            args[0] = args[0].ToLower();\n\n            caller.Actions.AddAction(\"Running cmd: \" + args[0], LogAction.CommandIcon);\n", "            if (!commands.ContainsKey(args[0]))\n                return \"error! command not found\";\n\n            return await commands[args[0]].Execute(caller, args);\n        }\n\n    }\n}\n"]}
{"filename": "WAGIapp/AI/Master.cs", "chunked_list": ["\ufeffusing System.Text.Json;\n\nnamespace WAGIapp.AI\n{\n    internal class Master\n    {\n        private static Master singleton;\n        public static Master Singleton \n        {\n            get \n            {", "                if (singleton == null)\n                {\n                    Console.WriteLine(\"Create master\");\n                    singleton = new Master();\n                    Console.WriteLine(\"Master created\");\n                }\n\n                return singleton;\n            }\n        }\n\n", "        public LongTermMemory Memory;\n        public ActionList Actions;\n        public ScriptFile scriptFile;\n\n        public bool Done = true;\n\n        private string nextMemoryPrompt = \"\";\n        private string lastCommandOuput = \"\";\n\n\n        public List<string> Notes;\n\n        private List<ChatMessage> LastMessages = new List<ChatMessage>();\n        private List<ChatMessage> LastCommand = new List<ChatMessage>();\n", "        public string FormatedNotes\n        {\n            get\n            {\n                string output = \"\";\n                for (int i = 0; i < Notes.Count; i++)\n                {\n                    output += (i + 1) + \". \" + Notes[i] + \"\\n\";\n                }\n\n                return output;\n            }\n        }\n\n        public Master()\n        {\n            Notes = new List<string>();\n\n            Memory = new LongTermMemory(1024);\n            Actions = new ActionList(10);\n            scriptFile = new ScriptFile();\n\n            singleton = this;\n        }\n", "        public async Task Tick()\n        {\n\n            Console.WriteLine(\"master tick -master\");\n\n            if (Done)\n                return;\n\n            if (Memory.memories.Count == 0)\n            {\n                await Memory.MakeMemory(Settings.Goal);\n                Console.WriteLine(\"master start memory done\");\n            }\n\n            var masterInput = await GetMasterInput();\n\n            string responseString;\n            MasterResponse response;\n\n            var action = Actions.AddAction(\"Thinking\", LogAction.ThinkIcon);\n", "            if (Memory.memories.Count == 0)\n            {\n                await Memory.MakeMemory(Settings.Goal);\n                Console.WriteLine(\"master start memory done\");\n            }\n\n            var masterInput = await GetMasterInput();\n\n            string responseString;\n            MasterResponse response;\n\n            var action = Actions.AddAction(\"Thinking\", LogAction.ThinkIcon);\n", "            while (true)\n            {\n                try\n                {\n                    responseString = await OpenAI.GetChatCompletion(ChatModel.ChatGPT, masterInput);\n\n                    response = Utils.GetObjectFromJson<MasterResponse>(responseString) ?? new();\n                    break;\n                }\n                catch (Exception)\n                {\n                    Console.WriteLine(\"Master failed - trying again\");\n                }\n            }\n\n            nextMemoryPrompt = response.thoughts;\n\n            lastCommandOuput = await Commands.TryToRun(this, response.command);\n\n            LastMessages.Add(new ChatMessage(ChatRole.Assistant, responseString));\n            LastCommand.Add(new ChatMessage(ChatRole.System, \"Command output:\\n\" + lastCommandOuput));\n", "                catch (Exception)\n                {\n                    Console.WriteLine(\"Master failed - trying again\");\n                }\n            }\n\n            nextMemoryPrompt = response.thoughts;\n\n            lastCommandOuput = await Commands.TryToRun(this, response.command);\n\n            LastMessages.Add(new ChatMessage(ChatRole.Assistant, responseString));\n            LastCommand.Add(new ChatMessage(ChatRole.System, \"Command output:\\n\" + lastCommandOuput));\n", "            if (LastMessages.Count >= 10)\n                LastMessages.RemoveAt(0);\n\n            if (LastCommand.Count >= 10)\n                LastCommand.RemoveAt(0);\n\n            action.Text = response.thoughts;\n\n            masterInput.Add(LastMessages.Last());\n            masterInput.Add(LastCommand.Last());\n\n            Console.WriteLine(JsonSerializer.Serialize(masterInput, new JsonSerializerOptions() { WriteIndented = true }));\n            Console.WriteLine(scriptFile.GetText());\n            Console.WriteLine(\"------------------------------------------------------------------------\");\n\n\n            Actions.AddAction(\"Memory\", LogAction.MemoryIcon);\n\n            await Memory.MakeMemory(responseString);\n\n        }\n", "        public async Task<List<ChatMessage>> GetMasterInput()\n        {\n            List<ChatMessage> messages = new List<ChatMessage>();\n\n            messages.Add(Texts.MasterStartText);\n            messages.Add(new ChatMessage(ChatRole.System, \"Memories:\\n\" + await Memory.GetMemories(nextMemoryPrompt)));\n            messages.Add(new ChatMessage(ChatRole.System, \"Notes:\\n\" + FormatedNotes));\n            messages.Add(new ChatMessage(ChatRole.System, \"Commands:\\n\" + Commands.GetCommands()));\n            messages.Add(new ChatMessage(ChatRole.System, \"Main Goal:\\n\" + Settings.Goal));\n            messages.Add(new ChatMessage(ChatRole.System, \"Script file:\\n\" + scriptFile.GetText() + \"\\nEnd of script file\"));\n            messages.Add(Texts.MasterStartText);\n            messages.Add(Texts.MasterOutputFormat);\n            \n", "            for (int i = 0; i < LastMessages.Count; i++)\n            {\n                messages.Add(LastMessages[i]);\n                messages.Add(LastCommand[i]);\n            }\n\n            return messages;\n        }\n    }\n\n", "    class MasterResponse\n    {\n        public string thoughts { get; set; } = \"\";\n        public string command { get; set; } = \"\";\n    }\n}\n"]}
{"filename": "WAGIapp/AI/OpenAI.cs", "chunked_list": ["\ufeff/*using OpenAI.Chat;\nusing OpenAI.Models;\nusing OpenAI;*/\n\nusing System.Net.Http.Headers;\nusing System.Text.Json;\n\nnamespace WAGIapp.AI\n{\n    internal class OpenAI\n    {", "{\n    internal class OpenAI\n    {\n        public static async Task<string> GetChatCompletion(string model, List<ChatMessage> messages, int maxTokens = 8192)\n        {\n\n            ChatRequest req = new ChatRequest() { messages = messages, model = model };\n            ChatResponse res;\n\n\n            var client = new HttpClient();\n            var request = new HttpRequestMessage\n            {\n                Method = HttpMethod.Post,\n                RequestUri = new Uri(\"https://api.openai.com/v1/chat/completions\"),\n                Headers =\n                {\n                    { \"User-Agent\", \"WAGIapp\" },\n                    { \"Authorization\", \"Bearer \" + Settings.OpenAIApiKey },\n                },\n\n                Content = new StringContent(JsonSerializer.Serialize(req))\n                {\n                    Headers =\n                    {\n                        ContentType = new MediaTypeHeaderValue(\"application/json\")\n                    }\n                }\n            };", "            using (var response = await client.SendAsync(request))\n            {\n                response.EnsureSuccessStatusCode();\n                var body = await response.Content.ReadAsStringAsync();\n                res = JsonSerializer.Deserialize<ChatResponse>(body);\n            }\n\n\n\n            return res.choices.First().message.content;\n        }\n    }\n", "    public struct ChatRequest\n    {\n        public string model { get; set; }\n        public List<ChatMessage> messages { get; set; }\n    }\n\n    public struct ChatResponse\n    {\n        public string id { get; set; }\n        public List<ChatChoice> choices { get; set; }\n    }\n", "        public string id { get; set; }\n        public List<ChatChoice> choices { get; set; }\n    }\n\n    public struct ChatChoice\n    {\n        public ChatMessage message { get; set; }\n        public string finish_reason { get; set; }\n        public int index { get; set; }\n    }\n", "        public int index { get; set; }\n    }\n\n    public struct ChatMessage\n    {\n        public string role { get; set; }\n        public string content { get; set; }\n\n        public ChatMessage(string _role, string _content)\n        {\n            role = _role;\n            content = _content;\n        }\n    }\n", "    public static class ChatRole\n    {\n        public static string System => \"system\";\n        public static string User => \"user\";\n        public static string Assistant => \"assistant\";\n    }\n\n    public static class ChatModel\n    {\n        public static string ChatGPT => \"gpt-3.5-turbo\";\n    }\n}", "        public static string ChatGPT => \"gpt-3.5-turbo\";\n    }\n}"]}
{"filename": "WAGIapp/AI/LogAction.cs", "chunked_list": ["\ufeffusing MudBlazor;\n\nnamespace WAGIapp.AI\n{\n    public class LogAction\n    {\n        public string Title { get; set; } = \"\";\n        public string Icon { get; set; } = \"\";\n        public string Text { get; set; } = \"\";\n        public bool Last { get; set; } = false;\n", "        public string Text { get; set; } = \"\";\n        public bool Last { get; set; } = false;\n\n        public const string InfoIcon = Icons.Material.Filled.Info;\n        public const string MemoryIcon = Icons.Material.Filled.Memory;\n        public const string ThinkIcon = Icons.Material.Filled.Psychology;\n        public const string CommandIcon = Icons.Material.Filled.Terminal;\n    }\n}\n"]}
{"filename": "WAGIapp/AI/Memory.cs", "chunked_list": ["\ufeffnamespace WAGIapp.AI\n{\n    internal class Memory\n    {\n        public string Content { get; private set; }\n        public HashSet<string> Tags { get; private set; }\n        public int Remembered { get; set; }\n\n        public Memory(string content, HashSet<string> tags)\n        {\n            Content = content;\n            Tags = tags;\n            Remembered = 0;\n        }\n\n        public Memory(OutputMemoryAI m)\n        {\n            Content = m.content;\n            Tags = Utils.CleanInput(m.tags.Split(\",\")).ToHashSet();\n        }\n", "        public int GetScore(HashSet<string> tags)\n        {\n            int output = 0;\n            foreach (string tag in tags)\n            {\n                if (Tags.Contains(tag))\n                    output++;\n            }\n\n            return output;\n        }\n", "        public string GetCommonTag(HashSet<string> tags)\n        {\n            foreach (string tag in tags)\n            {\n                if (Tags.Contains(tag))\n                    return tag;\n            }\n\n            return \"\";\n        }\n", "        public override string ToString()\n        {\n            return Content;\n        }\n\n    }\n\n    internal struct OutputMemoryAI\n    {\n        public string tags { get; set; }\n        public string content { get; set; }\n    }\n", "        public string tags { get; set; }\n        public string content { get; set; }\n    }\n\n    internal struct OutputMemoryTagsJson\n    {\n        public string tags { get; set; }\n    }\n\n    internal struct GraphMemoryData\n    {\n        public List<GraphMemoryNode> nodes { get; set; }\n        public List<GraphMemoryLink> links { get; set; }\n\n        public GraphMemoryData()\n        {\n            nodes = new List<GraphMemoryNode>();\n            links = new List<GraphMemoryLink>();\n        }\n    }\n", "    internal struct GraphMemoryData\n    {\n        public List<GraphMemoryNode> nodes { get; set; }\n        public List<GraphMemoryLink> links { get; set; }\n\n        public GraphMemoryData()\n        {\n            nodes = new List<GraphMemoryNode>();\n            links = new List<GraphMemoryLink>();\n        }\n    }\n", "    internal struct GraphMemoryNode\n    {\n        public int id { get; set; }\n        public string name { get; set; }\n        public string text { get; set; }\n        public string color { get; set; }\n    }\n\n    internal struct GraphMemoryLink\n    {\n        public string label { get; set; }", "    internal struct GraphMemoryLink\n    {\n        public string label { get; set; }\n        public int width { get; set; }\n        public int source { get; set; }\n        public int target { get; set; }\n    }\n}"]}
{"filename": "WAGIapp/AI/ScriptFile.cs", "chunked_list": ["\ufeffnamespace WAGIapp.AI\n{\n    public class ScriptFile\n    {\n        public List<string> Lines { get; set; }\n\n        public ScriptFile() \n        {\n            Lines = new List<string>();\n\n            for (int i = 0; i < 21; i++)\n                Lines.Add(string.Empty);\n        }\n", "            for (int i = 0; i < 21; i++)\n                Lines.Add(string.Empty);\n        }\n\n        public string GetText()\n        {\n            string output = \"\";\n\n            for (int i = 0; i < Lines.Count; i++)\n            {\n                output += i.ToString(\"D2\") + \" | \" + Lines[i] + \"\\n\";\n            }\n\n            return output;\n        }\n\n", "            for (int i = 0; i < Lines.Count; i++)\n            {\n                output += i.ToString(\"D2\") + \" | \" + Lines[i] + \"\\n\";\n            }\n\n            return output;\n        }\n\n\n        public string WriteLine(int line, string text)\n        {", "        public string WriteLine(int line, string text)\n        {\n            for (int i = 0; i < 100; i++)\n            {\n                if (line <= Lines.Count)\n                    break;\n\n                Lines.Add(\"\");\n            }\n\n\n            string[] lines = text.Split('\\n');\n", "            if (line == Lines.Count)\n                Lines.Add(lines[0]);\n            else\n                Lines[line] = lines[0];\n\n            if (lines.Length != 1)\n            {\n                for (int i = 1; i < lines.Length; i++)\n                {\n                    if (line + i == Lines.Count)\n                        Lines.Add(lines[i]);\n                    else\n                        Lines.Insert(line + i, lines[i]);\n                }\n            }\n\n            return \"Line written\";\n        }\n", "                    if (line + i == Lines.Count)\n                        Lines.Add(lines[i]);\n                    else\n                        Lines.Insert(line + i, lines[i]);\n                }\n            }\n\n            return \"Line written\";\n        }\n\n        public string RemoveLine(int line) \n        {", "        public string RemoveLine(int line) \n        {\n            if (line >= Lines.Count)\n                return \"error! line outside of bounds\";\n\n            Lines.RemoveAt(line);\n\n            return \"Line removed\";\n        }\n    }\n}\n"]}
{"filename": "WAGIapp/AI/Utils.cs", "chunked_list": ["\ufeffusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Web;\nusing System;\nusing Microsoft.Extensions.Options;\nusing Microsoft.AspNetCore.Components.WebAssembly.Http;\n\nnamespace WAGIapp.AI\n{\n    internal class Utils\n    {", "{\n    internal class Utils\n    {\n        public static string ExtractJson(string input)\n        {\n            input = input.Replace(\"\\\"\\n\", \"\\\",\\n\");\n\n            int firstBracket = input.IndexOf(\"{\");\n            int lastBracket = input.LastIndexOf(\"}\");\n\n            if (firstBracket < 0)\n            {\n                Console.WriteLine(\"Json extraction failed: missing '{'\");\n                return \"\";\n            }\n", "            if (firstBracket < 0)\n            {\n                Console.WriteLine(\"Json extraction failed: missing '{'\");\n                return \"\";\n            }\n\n            if (lastBracket < 0)\n            {\n                Console.WriteLine(\"Json extraction failed: missing '}'\");\n                return \"\";\n            }\n\n            return input.Substring(firstBracket, lastBracket - firstBracket + 1);\n        }\n", "        public static T? GetObjectFromJson<T>(string json)\n        {\n            return JsonSerializer.Deserialize<T>(ExtractJson(json), new JsonSerializerOptions()\n            {\n                AllowTrailingCommas = true,\n            });\n        }\n\n        public static IEnumerable<string> CleanInput(IEnumerable<string> input)\n        {\n            var list = input.ToArray();\n", "        public static IEnumerable<string> CleanInput(IEnumerable<string> input)\n        {\n            var list = input.ToArray();\n\n            for (int i = 0; i < list.Length; i++)\n            {\n                list[i] = list[i].Trim();\n                list[i] = list[i].ToLower();\n            }\n\n            return list;\n        }\n", "        public static async Task<string> WebResult(string url, bool corsProxy = false)\n        {\n            try\n            {\n                var client = new HttpClient();\n\n                var request = new HttpRequestMessage\n                {\n                    Method = HttpMethod.Get,\n                    RequestUri = new Uri((corsProxy ? \"https://wapi.woltvint.net/cors-proxy?url=\" : \"\") + url),\n                };\n", "                using (var response = await client.SendAsync(request))\n                {\n                    response.EnsureSuccessStatusCode();\n                    var body = await response.Content.ReadAsStringAsync();\n                    return body;\n                }\n            }\n            catch (Exception)\n            {\n                return \"Web request failed\";\n            }\n        }\n\n", "        public static string CleanHtmlInput(string input)\n        {\n            string output = input;\n\n            output = HttpUtility.HtmlDecode(output);\n            output = Regex.Replace(output, \"<[^>]*>\", \" \", RegexOptions.ExplicitCapture);\n            output = output.Trim();\n\n            return output;\n        }\n\n    }\n}\n"]}
{"filename": "WAGIapp/AI/ActionList.cs", "chunked_list": ["\ufeffnamespace WAGIapp.AI\n{\n    public class ActionList\n    {\n        private readonly object dataLock = new object(); \n\n        private List<LogAction> Actions;\n        private int MaxActions;\n\n        public ActionList(int maxActions) \n        {\n            Actions = new List<LogAction>();\n            MaxActions = maxActions;\n        }\n", "        public LogAction AddAction(string action, string icon = LogAction.InfoIcon)\n        {\n            LogAction a = new LogAction() { Title = action, Icon = icon };\n\n            lock (dataLock)\n            {\n                Actions.Add(a);\n\n                if (Actions.Count >= MaxActions)\n                    Actions.RemoveAt(0);\n            }\n\n            return a;\n        }\n\n        public List<LogAction> GetActions()\n        {", "                if (Actions.Count >= MaxActions)\n                    Actions.RemoveAt(0);\n            }\n\n            return a;\n        }\n\n        public List<LogAction> GetActions()\n        {\n            foreach (var action in Actions)\n            {\n                action.Last = false;\n            }\n", "            foreach (var action in Actions)\n            {\n                action.Last = false;\n            }\n\n            if (Actions.Count > 0)\n                Actions.Last().Last = true;\n\n            return Actions.ToList();\n        }\n    }\n}\n"]}
{"filename": "WAGIapp/AI/Texts.cs", "chunked_list": ["\ufeffnamespace WAGIapp.AI\n{\n    public static class Texts\n    {\n\n        public static ChatMessage MasterStartText => new(ChatRole.System, Settings.Rules);\n\n        public static ChatMessage MasterOutputFormat = new ChatMessage(\n            ChatRole.System,\n            \"only reply in this json format\" +\n            \"Output format:\" +\n            \"{\" +\n            \"\\\"thoughts\\\": \\\"your thoughts\\\"\" +\n            \"\\\"command\\\": \\\"command you want to execute in the format specified for that command\\\"\" +\n            \"}\" +\n            \"\");\n", "        public static ChatMessage ShortTermMemoryAddPrompt = new ChatMessage(\n            ChatRole.System,\n            \"You are the memory of an AI.\\n\" +\n            \"Your job is to look at a piece of text and create a memory from it\\n\" +\n            \"The memory should be helpful for the AI that will remember it in the future\\n\" +\n            \"The memory should be up to 100 words long, but can be shorter\\n\" +\n            \"The memory should be in a form of a fact that the AI can understand without any additional context\\n\" +\n            \"With the memory you also need to provide between 10 to 40 tags that will help search for it later\\n\" +\n            \"There is a list of tags you can use, but you can also create new ones if none of them are aplicable\\n\" +\n            \"The tags should be relevant to the memory so the AI can later remember it by them\\n\" +\n            \"\");\n", "        public static ChatMessage ShortTermMemoryAddFormat = new ChatMessage(\n            ChatRole.System,\n            \"You must only output the memory in this json format\\n\" +\n            \"{\\n\" +\n            \"\\\"tags\\\": \\\"a list of 5-40 single word tags separated by a comma\\\"\\n\" +\n            \"\\\"content\\\": \\\"the text of the memory\\\"\\n\" +\n            \"}\\n\" +\n            \"\");\n\n        public static ChatMessage ShortTermMemoryGetPrompt = new ChatMessage(\n            ChatRole.System,\n            \"You are the memory of an AI.\\n\" +\n            \"Your job is to look at the input the AI will receive and select tags that it should use to search the memory from the list\\n\" +\n            \"You should always try to select the most relevant tags\\n\" +\n            \"You should only choose tags that you are given in the Available tags:\\n\" +\n            \"You should always output 5 to 20 tags\\n\" +\n            \"\");\n", "        public static ChatMessage ShortTermMemoryGetPrompt = new ChatMessage(\n            ChatRole.System,\n            \"You are the memory of an AI.\\n\" +\n            \"Your job is to look at the input the AI will receive and select tags that it should use to search the memory from the list\\n\" +\n            \"You should always try to select the most relevant tags\\n\" +\n            \"You should only choose tags that you are given in the Available tags:\\n\" +\n            \"You should always output 5 to 20 tags\\n\" +\n            \"\");\n\n        public static ChatMessage ShortTermMemoryGetFormat = new ChatMessage(\n            ChatRole.System,\n            \"You must only output the memory in this json format\\n\" +\n            \"{\\n\" +\n            \"\\\"tags\\\": \\\"a list of 5-20 single word tags separated by a comma\\\"\\n\" +\n            \"}\\n\" +\n            \"\");\n\n    }\n}", "        public static ChatMessage ShortTermMemoryGetFormat = new ChatMessage(\n            ChatRole.System,\n            \"You must only output the memory in this json format\\n\" +\n            \"{\\n\" +\n            \"\\\"tags\\\": \\\"a list of 5-20 single word tags separated by a comma\\\"\\n\" +\n            \"}\\n\" +\n            \"\");\n\n    }\n}"]}
{"filename": "WAGIapp/AI/AICommands/RemoveNoteCommand.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace WAGIapp.AI.AICommands\n{\n    internal class RemoveNoteCommand : Command\n    {\n        public override string Name => \"remove-note\";\n", "    internal class RemoveNoteCommand : Command\n    {\n        public override string Name => \"remove-note\";\n\n        public override string Description => \"Removes a note from the list\";\n\n        public override string Format => \"remove-note | number of the note to remove\";\n\n        public override async Task<string> Execute(Master caller, string[] args)\n        {\n            if (args.Length < 2)\n                return \"error! not enough parameters\";\n", "        public override async Task<string> Execute(Master caller, string[] args)\n        {\n            if (args.Length < 2)\n                return \"error! not enough parameters\";\n\n            if (!int.TryParse(args[1], out int number))\n                return \"error! number could not be parsed\";\n\n            if (number - 1 >= caller.Notes.Count)\n                return \"error! number out of range\";\n\n            caller.Notes.RemoveAt(number - 1);\n\n            return $\"Note {number} removed\";\n\n        }\n    }\n}\n", "            if (number - 1 >= caller.Notes.Count)\n                return \"error! number out of range\";\n\n            caller.Notes.RemoveAt(number - 1);\n\n            return $\"Note {number} removed\";\n\n        }\n    }\n}\n"]}
{"filename": "WAGIapp/AI/AICommands/RemoveLineCommand.cs", "chunked_list": ["\ufeffnamespace WAGIapp.AI.AICommands\n{\n    internal class RemoveLineCommand : Command\n    {\n        public override string Name => \"remove-line\";\n\n        public override string Description => \"deletes a line from the script\";\n\n        public override string Format => \"remove-line | line number\";\n\n        public override async Task<string> Execute(Master caller, string[] args)\n        {", "        public override string Format => \"remove-line | line number\";\n\n        public override async Task<string> Execute(Master caller, string[] args)\n        {\n            if (args.Length < 2)\n                return \"error! not enough parameters\";\n\n            int line;\n\n            try\n            {\n                line = Convert.ToInt32(args[1]);\n            }", "            catch (Exception)\n            {\n                return \"error! given line number is not a number\";\n            }\n\n            return caller.scriptFile.RemoveLine(line);\n        }\n    }\n}\n"]}
{"filename": "WAGIapp/AI/AICommands/WriteLineCommand.cs", "chunked_list": ["\ufeffnamespace WAGIapp.AI.AICommands\n{\n    internal class WriteLineCommand : Command\n    {\n        public override string Name => \"write-line\";\n\n        public override string Description => \"writes the given text to the line number\";\n\n        public override string Format => \"write-line | line number | text\";\n\n        public override async Task<string> Execute(Master caller, string[] args)\n        {", "        public override string Format => \"write-line | line number | text\";\n\n        public override async Task<string> Execute(Master caller, string[] args)\n        {\n            if (args.Length < 3)\n                return \"error! not enough parameters\";\n\n            int line;\n\n            try\n            {\n                line = Convert.ToInt32(args[1]);\n            }", "            catch (Exception)\n            {\n                return \"error! given line number is not a number\";\n            }\n\n            return caller.scriptFile.WriteLine(line, args[2]);\n        }\n    }\n}\n"]}
{"filename": "WAGIapp/AI/AICommands/AddNoteCommand.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace WAGIapp.AI.AICommands\n{\n    internal class AddNoteCommand : Command\n    {\n        public override string Name => \"add-note\"; \n", "    internal class AddNoteCommand : Command\n    {\n        public override string Name => \"add-note\"; \n\n        public override string Description => \"Adds a note to the list\"; \n\n        public override string Format => \"add-note | text to add to the list\";\n\n        public override async Task<string> Execute(Master caller, string[] args)\n        {\n            if (args.Length < 2)\n                return \"error! not enough parameters\";\n\n            caller.Notes.Add(args[1]);\n\n            return \"Note added\";\n        }\n    }\n}\n", "        public override async Task<string> Execute(Master caller, string[] args)\n        {\n            if (args.Length < 2)\n                return \"error! not enough parameters\";\n\n            caller.Notes.Add(args[1]);\n\n            return \"Note added\";\n        }\n    }\n}\n"]}
{"filename": "WAGIapp/AI/AICommands/GoalReachedCommand.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace WAGIapp.AI.AICommands\n{\n    internal class GoalReachedCommand : Command\n    {\n        public override string Name => \"goal-reached\";\n", "    internal class GoalReachedCommand : Command\n    {\n        public override string Name => \"goal-reached\";\n\n        public override string Description => \"Command that you must call when you reach the main goal\";\n\n        public override string Format => \"goal-reached\";\n\n        public override async Task<string> Execute(Master caller, string[] args)\n        {\n            caller.Done = true;\n            return \"done.\";\n        }\n    }\n}\n", "        public override async Task<string> Execute(Master caller, string[] args)\n        {\n            caller.Done = true;\n            return \"done.\";\n        }\n    }\n}\n"]}
{"filename": "WAGIapp/AI/AICommands/Command.cs", "chunked_list": ["\ufeffnamespace WAGIapp.AI.AICommands\n{\n    internal abstract class Command\n    {\n        public abstract string Name { get; }\n        public abstract string Description { get; }\n\n        public abstract string Format { get; }\n\n        public abstract Task<string> Execute(Master caller, string[] args);\n\n\n    }\n}\n", "        public abstract Task<string> Execute(Master caller, string[] args);\n\n\n    }\n}\n"]}
{"filename": "WAGIapp/AI/AICommands/SearchWebCommand.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace WAGIapp.AI.AICommands\n{\n    internal class SearchWebCommand : Command\n    {\n        public override string Name => \"search-web\";\n", "    internal class SearchWebCommand : Command\n    {\n        public override string Name => \"search-web\";\n\n        public override string Description => \"Searches the web and returns a list of links and descriptions\";\n\n        public override string Format => \"search-web | querry\";\n\n        public override async Task<string> Execute(Master caller, string[] args)\n        {\n            if (args.Length < 2)\n                return \"error! not enough parameters\";\n\n            string web = await Utils.WebResult(\"https://html.duckduckgo.com/html/?q=\" + args[1],true);\n\n            List<string> headers = new List<string>();\n            List<string> urls = new List<string>();\n            List<string> descritpions = new List<string>();\n\n            int i = 0;", "        public override async Task<string> Execute(Master caller, string[] args)\n        {\n            if (args.Length < 2)\n                return \"error! not enough parameters\";\n\n            string web = await Utils.WebResult(\"https://html.duckduckgo.com/html/?q=\" + args[1],true);\n\n            List<string> headers = new List<string>();\n            List<string> urls = new List<string>();\n            List<string> descritpions = new List<string>();\n\n            int i = 0;", "            while (true)\n            {\n                int tagStart = web.IndexOf(\"<a rel=\\\"nofollow\\\" class=\\\"result__a\\\"\", i);\n\n                if (tagStart == -1)\n                    break;\n\n                int tagEnd = web.IndexOf(\">\", tagStart);\n\n                int blockEnd = web.IndexOf(\"</a>\", tagEnd);\n\n                headers.Add(web.Substring(tagEnd + 1, blockEnd - tagEnd - 1));\n\n                i = blockEnd;\n            }\n\n\n            i = 0;", "            while (true)\n            {\n                int tagStart = web.IndexOf(\"<a class=\\\"result__url\\\"\", i);\n\n                if (tagStart == -1)\n                    break;\n\n                int tagEnd = web.IndexOf(\">\", tagStart);\n\n                int blockEnd = web.IndexOf(\"</a>\", tagEnd);\n\n                urls.Add(web.Substring(tagEnd + 1, blockEnd - tagEnd - 1));\n\n                i = blockEnd;\n            }\n\n\n            i = 0;", "            while (true)\n            {\n                int tagStart = web.IndexOf(\"<a class=\\\"result__snip\", i);\n\n                if (tagStart == -1)\n                    break;\n\n                int tagEnd = web.IndexOf(\">\", tagStart);\n\n                int blockEnd = web.IndexOf(\"</a>\", tagEnd);\n\n                descritpions.Add(web.Substring(tagEnd + 1, blockEnd - tagEnd - 1));\n\n                i = blockEnd;\n            }\n\n            string output = \"\";\n", "            for (int j = 0; j < headers.Count; j++)\n            {\n                headers[j] = Utils.CleanHtmlInput(headers[j]);\n                urls[j] = Utils.CleanHtmlInput(urls[j]);\n                descritpions[j] = Utils.CleanHtmlInput(descritpions[j]);\n            }\n\n            i = 0;\n            while (output.Split(\" \").Length < 800 && i < headers.Count)\n            {\n                output += (i + 1) + \". \" + headers[i] + \"\\n\";\n                output += \"[\" + urls[i] + \"]\\n\";\n                output += descritpions[i] + \"\\n\\n\";\n                i++;\n            }\n\n            return output;\n        }\n    }\n}\n", "            while (output.Split(\" \").Length < 800 && i < headers.Count)\n            {\n                output += (i + 1) + \". \" + headers[i] + \"\\n\";\n                output += \"[\" + urls[i] + \"]\\n\";\n                output += descritpions[i] + \"\\n\\n\";\n                i++;\n            }\n\n            return output;\n        }\n    }\n}\n"]}
{"filename": "WAGIapp/AI/AICommands/NoActionCommand.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Cryptography.X509Certificates;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace WAGIapp.AI.AICommands\n{\n    internal class NoActionCommand : Command\n    {", "{\n    internal class NoActionCommand : Command\n    {\n        public override string Name => \"no-action\";\n\n        public override string Description => \"does nothing\";\n\n        public override string Format => \"no-action\";\n\n        public override async Task<string> Execute(Master caller, string[] args)\n        {\n            return \"command did nothing\";\n        }\n    }\n}\n", "        public override async Task<string> Execute(Master caller, string[] args)\n        {\n            return \"command did nothing\";\n        }\n    }\n}\n"]}
