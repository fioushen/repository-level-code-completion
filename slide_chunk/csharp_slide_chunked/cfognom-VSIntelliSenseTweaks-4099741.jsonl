{"filename": "VSIntelliSenseTweaks/GeneralSettings.cs", "chunked_list": ["\ufeffusing Microsoft.VisualStudio.Shell;\nusing System.ComponentModel;\n\nnamespace VSIntelliSenseTweaks\n{\n    public class GeneralSettings : DialogPage\n    {\n        public const string PageName = \"General\";\n\n        private bool includeDebugSuffix = false;\n        private bool disableSoftSelection = false;", "        private bool includeDebugSuffix = false;\n        private bool disableSoftSelection = false;\n        private bool boostEnumMemberScore = true;\n\n        [Category(VSIntelliSenseTweaksPackage.PackageDisplayName)]\n        [DisplayName(nameof(IncludeDebugSuffix))]\n        [Description(\"Adds a suffix with debug information to the entries in the completion list.\")]\n        public bool IncludeDebugSuffix\n        {\n            get { return includeDebugSuffix; }\n            set { includeDebugSuffix = value; }\n        }\n\n        [Category(VSIntelliSenseTweaksPackage.PackageDisplayName)]\n        [DisplayName(nameof(DisableSoftSelection))]\n        [Description(\"Disables initial soft-selection in the completion-list when completion was triggered manually (usually by ctrl + space).\")]", "        public bool DisableSoftSelection\n        {\n            get { return disableSoftSelection; }\n            set { disableSoftSelection = value; }\n        }\n\n        [Category(VSIntelliSenseTweaksPackage.PackageDisplayName)]\n        [DisplayName(nameof(BoostEnumMemberScore))]\n        [Description(\"Boosts the score of enum members when the enum type was preselected by roslyn.\")]\n        public bool BoostEnumMemberScore\n        {\n            get { return boostEnumMemberScore; }\n            set { boostEnumMemberScore = value; }\n        }\n    }\n}\n", "        [Description(\"Boosts the score of enum members when the enum type was preselected by roslyn.\")]\n        public bool BoostEnumMemberScore\n        {\n            get { return boostEnumMemberScore; }\n            set { boostEnumMemberScore = value; }\n        }\n    }\n}\n"]}
{"filename": "VSIntelliSenseTweaks/CompletionItemManager.cs", "chunked_list": ["\ufeff/*\n    Copyright 2023 Carl Foghammar N\u00f6mtak\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software", "\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\nusing Microsoft;\nusing Microsoft.CodeAnalysis.Completion;", "using Microsoft;\nusing Microsoft.CodeAnalysis.Completion;\nusing Microsoft.VisualStudio.Language.Intellisense.AsyncCompletion;\nusing Microsoft.VisualStudio.Language.Intellisense.AsyncCompletion.Data;\nusing Microsoft.VisualStudio.Text.Editor;\nusing Microsoft.VisualStudio.Utilities;\nusing Microsoft.VisualStudio.Text;\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;", "using System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.ComponentModel.Composition;\nusing System.Diagnostics;\nusing System.Linq.Expressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing VSIntelliSenseTweaks.Utilities;\n\nusing RoslynCompletionItem = Microsoft.CodeAnalysis.Completion.CompletionItem;", "\nusing RoslynCompletionItem = Microsoft.CodeAnalysis.Completion.CompletionItem;\nusing VSCompletionItem = Microsoft.VisualStudio.Language.Intellisense.AsyncCompletion.Data.CompletionItem;\n\nnamespace VSIntelliSenseTweaks\n{\n    // TODO: How to make a user setting that stops the MEF export of this?\n    [Export(typeof(IAsyncCompletionItemManagerProvider))]\n    [Name(nameof(VSIntelliSenseTweaksCompletionItemManagerProvider))]\n    [ContentType(\"CSharp\")]", "    [Name(nameof(VSIntelliSenseTweaksCompletionItemManagerProvider))]\n    [ContentType(\"CSharp\")]\n    [ContentType(\"CSS\")]\n    [ContentType(\"XAML\")]\n    [ContentType(\"XML\")]\n    [TextViewRole(PredefinedTextViewRoles.PrimaryDocument)]\n    internal class VSIntelliSenseTweaksCompletionItemManagerProvider : IAsyncCompletionItemManagerProvider\n    {\n        public IAsyncCompletionItemManager GetOrCreate(ITextView textView)\n        {\n            VSIntelliSenseTweaksPackage.EnsurePackageLoaded();\n            var settings = VSIntelliSenseTweaksPackage.Settings;\n            return new CompletionItemManager(settings);\n        }\n    }\n", "        public IAsyncCompletionItemManager GetOrCreate(ITextView textView)\n        {\n            VSIntelliSenseTweaksPackage.EnsurePackageLoaded();\n            var settings = VSIntelliSenseTweaksPackage.Settings;\n            return new CompletionItemManager(settings);\n        }\n    }\n\n    internal class CompletionItemManager : IAsyncCompletionItemManager2\n    {\n        static readonly ImmutableArray<Span> noSpans = ImmutableArray<Span>.Empty;\n        \n        const int textFilterMaxLength = 256;\n\n        IAsyncCompletionSession session;\n        AsyncCompletionSessionInitialDataSnapshot initialData;\n        AsyncCompletionSessionDataSnapshot currentData;\n        CancellationToken cancellationToken;\n\n        VSCompletionItem[] completions;\n        CompletionItemKey[] keys;\n        int n_completions;\n\n        WordScorer scorer = new WordScorer(256);\n\n        CompletionFilterManager filterManager;\n        bool hasFilterManager;\n\n        bool includeDebugSuffix;\n        bool disableSoftSelection;\n        bool boostEnumMemberScore;\n\n        public CompletionItemManager(GeneralSettings settings)\n        {\n            this.includeDebugSuffix = settings.IncludeDebugSuffix;\n            this.disableSoftSelection = settings.DisableSoftSelection;\n            this.boostEnumMemberScore = settings.BoostEnumMemberScore;\n        }\n\n        public Task<ImmutableArray<VSCompletionItem>> SortCompletionListAsync(IAsyncCompletionSession session, AsyncCompletionSessionInitialDataSnapshot data, CancellationToken token)\n        {\n            // I think this method is not used, but required for the interface.\n            throw new NotImplementedException();\n        }\n\n        public Task<CompletionList<VSCompletionItem>> SortCompletionItemListAsync(IAsyncCompletionSession session, AsyncCompletionSessionInitialDataSnapshot data, CancellationToken token)\n        {\n            // Microsoft.VisualStudio.Language.Intellisense.AsyncCompletion.Implementation.AsyncCompletionSession\n            this.session = session;\n            this.initialData = data;\n            this.cancellationToken = token;\n\n            var sortTask = Task.Factory.StartNew(SortCompletionList, token, TaskCreationOptions.None, TaskScheduler.Current);\n\n            return sortTask;\n        }\n\n        public Task<FilteredCompletionModel> UpdateCompletionListAsync(IAsyncCompletionSession session, AsyncCompletionSessionDataSnapshot data, CancellationToken token)\n        {\n            Debug.Assert(this.session == session);\n            Debug.Assert(this.cancellationToken == token);\n            this.currentData = data;\n\n            var updateTask = Task.Factory.StartNew(UpdateCompletionList, token, TaskCreationOptions.None, TaskScheduler.Current);\n\n            return updateTask;\n        }\n\n        public CompletionList<VSCompletionItem> SortCompletionList()\n        {", "    internal class CompletionItemManager : IAsyncCompletionItemManager2\n    {\n        static readonly ImmutableArray<Span> noSpans = ImmutableArray<Span>.Empty;\n        \n        const int textFilterMaxLength = 256;\n\n        IAsyncCompletionSession session;\n        AsyncCompletionSessionInitialDataSnapshot initialData;\n        AsyncCompletionSessionDataSnapshot currentData;\n        CancellationToken cancellationToken;\n\n        VSCompletionItem[] completions;\n        CompletionItemKey[] keys;\n        int n_completions;\n\n        WordScorer scorer = new WordScorer(256);\n\n        CompletionFilterManager filterManager;\n        bool hasFilterManager;\n\n        bool includeDebugSuffix;\n        bool disableSoftSelection;\n        bool boostEnumMemberScore;\n\n        public CompletionItemManager(GeneralSettings settings)\n        {\n            this.includeDebugSuffix = settings.IncludeDebugSuffix;\n            this.disableSoftSelection = settings.DisableSoftSelection;\n            this.boostEnumMemberScore = settings.BoostEnumMemberScore;\n        }\n\n        public Task<ImmutableArray<VSCompletionItem>> SortCompletionListAsync(IAsyncCompletionSession session, AsyncCompletionSessionInitialDataSnapshot data, CancellationToken token)\n        {\n            // I think this method is not used, but required for the interface.\n            throw new NotImplementedException();\n        }\n\n        public Task<CompletionList<VSCompletionItem>> SortCompletionItemListAsync(IAsyncCompletionSession session, AsyncCompletionSessionInitialDataSnapshot data, CancellationToken token)\n        {\n            // Microsoft.VisualStudio.Language.Intellisense.AsyncCompletion.Implementation.AsyncCompletionSession\n            this.session = session;\n            this.initialData = data;\n            this.cancellationToken = token;\n\n            var sortTask = Task.Factory.StartNew(SortCompletionList, token, TaskCreationOptions.None, TaskScheduler.Current);\n\n            return sortTask;\n        }\n\n        public Task<FilteredCompletionModel> UpdateCompletionListAsync(IAsyncCompletionSession session, AsyncCompletionSessionDataSnapshot data, CancellationToken token)\n        {\n            Debug.Assert(this.session == session);\n            Debug.Assert(this.cancellationToken == token);\n            this.currentData = data;\n\n            var updateTask = Task.Factory.StartNew(UpdateCompletionList, token, TaskCreationOptions.None, TaskScheduler.Current);\n\n            return updateTask;\n        }\n\n        public CompletionList<VSCompletionItem> SortCompletionList()\n        {", "            using (new Measurement(nameof(SortCompletionList)))\n            {\n                var initialCompletions = initialData.InitialItemList;\n                this.n_completions = initialCompletions.Count;\n\n                Debug.WriteLine($\"Allocating for {n_completions} completions\");\n\n                this.completions = new VSCompletionItem[n_completions];\n                this.keys = new CompletionItemKey[n_completions];\n                this.hasFilterManager = false;\n", "                for (int i = 0; i < n_completions; i++)\n                {\n                    completions[i] = initialCompletions[i];\n                }\n\n                using (new Measurement(\"Sort\"))\n                Array.Sort(completions, new InitialComparer());\n\n                using (new Measurement(nameof(session.CreateCompletionList)))\n                {\n                    var completionList = session.CreateCompletionList(completions);\n\n                    return completionList;\n                }\n            }\n        }\n", "                using (new Measurement(nameof(session.CreateCompletionList)))\n                {\n                    var completionList = session.CreateCompletionList(completions);\n\n                    return completionList;\n                }\n            }\n        }\n\n        public FilteredCompletionModel UpdateCompletionList()\n        {", "        public FilteredCompletionModel UpdateCompletionList()\n        {\n            using (new Measurement(nameof(UpdateCompletionList)))\n            {\n                var textFilter = session.ApplicableToSpan.GetText(currentData.Snapshot);\n                bool hasTextFilter = textFilter.Length > 0;\n\n                if (ShouldDismiss()) return null;\n\n                var filterStates = currentData.SelectedFilters; // The types of filters displayed in the IntelliSense widget.\n                if (!hasFilterManager)\n                {\n                    this.filterManager = new CompletionFilterManager(filterStates);\n                    this.hasFilterManager = true;\n                }\n                filterManager.UpdateActiveFilters(filterStates);\n\n                int n_eligibleCompletions = 0;", "                if (!hasFilterManager)\n                {\n                    this.filterManager = new CompletionFilterManager(filterStates);\n                    this.hasFilterManager = true;\n                }\n                filterManager.UpdateActiveFilters(filterStates);\n\n                int n_eligibleCompletions = 0;\n                using (new Measurement(nameof(DetermineEligibleCompletions)))\n                DetermineEligibleCompletions();\n\n                var highlighted = CreateHighlightedCompletions(n_eligibleCompletions);\n                var selectionKind = GetSelectionKind(n_eligibleCompletions, hasTextFilter);\n\n                var result = new FilteredCompletionModel\n                (\n                    items: highlighted,\n                    selectedItemIndex: 0,\n                    filters: filterStates,\n                    selectionHint: selectionKind,\n                    centerSelection: false,\n                    uniqueItem: null\n                );\n\n                Debug.Assert(!cancellationToken.IsCancellationRequested);\n\n                return result;\n\n                bool ShouldDismiss()\n                {\n                    // Dismisses if first char in pattern is a number and not after a '.'.\n                    int position = session.ApplicableToSpan.GetStartPoint(currentData.Snapshot).Position;\n                    return hasTextFilter\n                        && char.IsNumber(currentData.Snapshot[position])\n                        && position > 0 && currentData.Snapshot[position - 1] != '.';\n                }\n\n                void DetermineEligibleCompletions()\n                {\n                    var initialCompletions = currentData.InitialSortedItemList;\n                    var defaults = currentData.Defaults;\n                    Debug.Assert(n_completions == initialCompletions.Count);\n\n                    int patternLength = Math.Min(textFilter.Length, textFilterMaxLength);\n                    var pattern = textFilter.AsSpan(0, patternLength);\n\n                    ReadOnlySpan<char> roslynPreselectedItemFilterText = null;\n                    BitField64 availableFilters = default;", "                using (new Measurement(nameof(DetermineEligibleCompletions)))\n                DetermineEligibleCompletions();\n\n                var highlighted = CreateHighlightedCompletions(n_eligibleCompletions);\n                var selectionKind = GetSelectionKind(n_eligibleCompletions, hasTextFilter);\n\n                var result = new FilteredCompletionModel\n                (\n                    items: highlighted,\n                    selectedItemIndex: 0,\n                    filters: filterStates,\n                    selectionHint: selectionKind,\n                    centerSelection: false,\n                    uniqueItem: null\n                );\n\n                Debug.Assert(!cancellationToken.IsCancellationRequested);\n\n                return result;\n\n                bool ShouldDismiss()\n                {\n                    // Dismisses if first char in pattern is a number and not after a '.'.\n                    int position = session.ApplicableToSpan.GetStartPoint(currentData.Snapshot).Position;\n                    return hasTextFilter\n                        && char.IsNumber(currentData.Snapshot[position])\n                        && position > 0 && currentData.Snapshot[position - 1] != '.';\n                }\n\n                void DetermineEligibleCompletions()\n                {\n                    var initialCompletions = currentData.InitialSortedItemList;\n                    var defaults = currentData.Defaults;\n                    Debug.Assert(n_completions == initialCompletions.Count);\n\n                    int patternLength = Math.Min(textFilter.Length, textFilterMaxLength);\n                    var pattern = textFilter.AsSpan(0, patternLength);\n\n                    ReadOnlySpan<char> roslynPreselectedItemFilterText = null;\n                    BitField64 availableFilters = default;", "                    for (int i = 0; i < n_completions; i++)\n                    {\n                        var completion = initialCompletions[i];\n\n                        int patternScore;\n                        ImmutableArray<Span> matchedSpans;\n                        if (hasTextFilter)\n                        {\n                            var word = completion.FilterText.AsSpan();\n                            int displayTextOffset = Math.Max(0, completion.DisplayText.AsSpan().IndexOf(word));\n                            patternScore = scorer.ScoreWord(word, pattern, displayTextOffset, out matchedSpans);", "                            if (patternScore == int.MinValue) continue;\n                        }\n                        else\n                        {\n                            patternScore = int.MinValue;\n                            matchedSpans = noSpans;\n                        }\n\n                        var filterMask = filterManager.CreateFilterMask(completion.Filters);\n                        var blacklistFilters = filterManager.blacklist & filterMask;\n                        availableFilters |= blacklistFilters; // Announce available blacklist filters.", "                        if (filterManager.HasActiveBlacklistFilter(filterMask)) continue;\n\n                        var whitelistFilters = filterManager.whitelist & filterMask;\n                        availableFilters |= whitelistFilters; // Announce available whitelist filters.\n                        if (filterManager.HasActiveWhitelist && !filterManager.HasActiveWhitelistFilter(filterMask)) continue;\n\n                        int defaultIndex = defaults.IndexOf(completion.FilterText) & int.MaxValue; // AND operation turns any negative value to int.MaxValue so we can sort properly\n\n                        if (blacklistFilters != default)\n                        {\n                            // We penalize items that have any inactive blacklist filters.\n                            // The current filter settings allow these items to be shown but they should be of lesser value than items without any blacklist filters.\n                            // Currently the only type of blacklist filter that exist in VS is 'add items from unimported namespaces'.\n                            patternScore -= 64 * pattern.Length;\n                        }\n\n                        int roslynScore = boostEnumMemberScore ?\n                            GetBoostedRoslynScore(completion, ref roslynPreselectedItemFilterText) :\n                            GetRoslynScore(completion);\n\n                        patternScore += CalculateRoslynScoreBonus(roslynScore, pattern.Length);\n\n                        var key = new CompletionItemKey\n                        {\n                            patternScore = patternScore,\n                            defaultIndex = defaultIndex,\n                            roslynScore = roslynScore,\n                            initialIndex = i,\n                            matchedSpans = matchedSpans,\n                        };\n", "                        if (blacklistFilters != default)\n                        {\n                            // We penalize items that have any inactive blacklist filters.\n                            // The current filter settings allow these items to be shown but they should be of lesser value than items without any blacklist filters.\n                            // Currently the only type of blacklist filter that exist in VS is 'add items from unimported namespaces'.\n                            patternScore -= 64 * pattern.Length;\n                        }\n\n                        int roslynScore = boostEnumMemberScore ?\n                            GetBoostedRoslynScore(completion, ref roslynPreselectedItemFilterText) :\n                            GetRoslynScore(completion);\n\n                        patternScore += CalculateRoslynScoreBonus(roslynScore, pattern.Length);\n\n                        var key = new CompletionItemKey\n                        {\n                            patternScore = patternScore,\n                            defaultIndex = defaultIndex,\n                            roslynScore = roslynScore,\n                            initialIndex = i,\n                            matchedSpans = matchedSpans,\n                        };\n", "                        if (this.includeDebugSuffix)\n                        {\n                            AddDebugSuffix(ref completion, in key);\n                        }\n\n                        this.completions[n_eligibleCompletions] = completion;\n                        this.keys[n_eligibleCompletions] = key;\n                        n_eligibleCompletions++;\n                    }\n\n                    using (new Measurement(\"Sort\"))\n                    Array.Sort(keys, completions, 0, n_eligibleCompletions);\n\n                    filterStates = UpdateFilterStates(filterStates, availableFilters);\n                }\n            }\n        }\n\n        UpdateSelectionHint GetSelectionKind(int n_eligibleCompletions, bool hasTextFilter)\n        {", "                    using (new Measurement(\"Sort\"))\n                    Array.Sort(keys, completions, 0, n_eligibleCompletions);\n\n                    filterStates = UpdateFilterStates(filterStates, availableFilters);\n                }\n            }\n        }\n\n        UpdateSelectionHint GetSelectionKind(int n_eligibleCompletions, bool hasTextFilter)\n        {\n            if (n_eligibleCompletions == 0)\n                return UpdateSelectionHint.NoChange;\n", "            if (n_eligibleCompletions == 0)\n                return UpdateSelectionHint.NoChange;\n\n            if (IsSoftSelectionDisabled())\n                return UpdateSelectionHint.Selected;\n\n            if (hasTextFilter && !currentData.DisplaySuggestionItem)\n                return UpdateSelectionHint.Selected;\n\n            var bestKey = keys[0];\n", "            if (bestKey.roslynScore >= MatchPriority.Preselect)\n                return UpdateSelectionHint.Selected;\n\n            //if (bestKey.defaultIndex < int.MaxValue)\n            //    return UpdateSelectionHint.Selected;\n\n            return UpdateSelectionHint.SoftSelected;\n\n            bool IsSoftSelectionDisabled()\n            {\n                // User setting to disable soft-selection.", "                if (disableSoftSelection)\n                {\n                    // If the user prefers hard-selection, we can disable soft-selection under the following circumstances.\n                    return currentData.InitialTrigger.Reason == CompletionTriggerReason.InvokeAndCommitIfUnique\n                        || currentData.InitialTrigger.Character.Equals('.');\n                }\n                return false;\n            }\n        }\n\n        ImmutableArray<CompletionItemWithHighlight> CreateHighlightedCompletions(int n_eligibleCompletions)\n        {\n            var builder = ImmutableArray.CreateBuilder<CompletionItemWithHighlight>(n_eligibleCompletions);\n            builder.Count = n_eligibleCompletions;", "            for (int i = 0; i < n_eligibleCompletions; i++)\n            {\n                builder[i] = new CompletionItemWithHighlight(completions[i], keys[i].matchedSpans);\n            }\n            return builder.MoveToImmutable();\n        }\n\n        private int CalculateRoslynScoreBonus(int roslynScore, int patternLength)\n        {\n            const int roslynScoreClamper = 1 << 22;\n            int clampedRoslynScore = Math.Max(Math.Min(roslynScore, roslynScoreClamper), -roslynScoreClamper);\n            return clampedRoslynScore * patternLength / 64;\n        }\n\n        /// <summary>", "        /// Returns the normal roslyn score but gives additional score to enum members if the enum type was preselected by roslyn.\n        /// </summary>\n        private int GetBoostedRoslynScore(VSCompletionItem completion, ref ReadOnlySpan<char> roslynPreselectedItemFilterText)\n        {\n            int roslynScore = GetRoslynScore(completion);\n\n            if (roslynScore >= MatchPriority.Preselect)\n            {\n                roslynPreselectedItemFilterText = completion.DisplayText.AsSpan();\n            }\n            else if (roslynPreselectedItemFilterText != null)\n            {\n                var word = completion.DisplayText.AsSpan();\n                int preselectedLength = roslynPreselectedItemFilterText.Length;\n", "            else if (roslynPreselectedItemFilterText != null)\n            {\n                var word = completion.DisplayText.AsSpan();\n                int preselectedLength = roslynPreselectedItemFilterText.Length;\n\n                if (word.Length > preselectedLength\n                &&  word.Slice(0, preselectedLength).SequenceEqual(roslynPreselectedItemFilterText))\n                {\n                    if (word[preselectedLength] == '.')\n                    {\n                        roslynScore = MatchPriority.Preselect / 2;\n                    }\n                }\n                else\n                {\n                    roslynPreselectedItemFilterText = null;\n                }\n            }\n\n            return roslynScore;\n        }\n", "                    if (word[preselectedLength] == '.')\n                    {\n                        roslynScore = MatchPriority.Preselect / 2;\n                    }\n                }\n                else\n                {\n                    roslynPreselectedItemFilterText = null;\n                }\n            }\n\n            return roslynScore;\n        }\n", "        private int GetRoslynScore(VSCompletionItem completion)\n        {\n            if (completion.Properties.TryGetProperty(\"RoslynCompletionItemData\", out object roslynObject))\n            {\n                var roslynCompletion = GetRoslynItemProperty(roslynObject);\n                int roslynScore = roslynCompletion.Rules.MatchPriority;\n                return roslynScore;\n            }\n\n            return 0;\n        }\n", "        // Since we do not have compile time access the class type;\n        // \"Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.AsyncCompletion.CompletionItemData\",\n        // we have to use reflection or expressions to access it.\n        private static Func<object, RoslynCompletionItem> RoslynCompletionItemGetter = null;\n\n        private RoslynCompletionItem GetRoslynItemProperty(object roslynObject)\n        {\n            if (RoslynCompletionItemGetter == null)\n            {\n                // Microsoft.CodeAnalysis.Editor.Implementation.IntelliSense.AsyncCompletion.CompletionItemData\n                var roslynType = roslynObject.GetType();\n                var input    = Expression.Parameter(typeof(object));\n                var casted   = Expression.Convert(input, roslynType);\n                var property = Expression.PropertyOrField(casted, \"RoslynItem\");\n                var lambda   = Expression.Lambda(property, input);\n                RoslynCompletionItemGetter = (Func<object, RoslynCompletionItem>)lambda.Compile();\n            }\n\n            return RoslynCompletionItemGetter.Invoke(roslynObject);\n        }\n\n        private ImmutableArray<CompletionFilterWithState> UpdateFilterStates(ImmutableArray<CompletionFilterWithState> filterStates, BitField64 availableFilters)\n        {\n            int n_filterStates = filterStates.Length;\n            var builder = ImmutableArray.CreateBuilder<CompletionFilterWithState>(n_filterStates);\n            builder.Count = n_filterStates;", "            for (int i = 0; i < n_filterStates; i++)\n            {\n                var filterState = filterStates[i];\n                builder[i] = new CompletionFilterWithState(filterState.Filter, availableFilters.GetBit(i), filterState.IsSelected);\n            }\n            return builder.MoveToImmutable();\n        }\n\n        struct InitialComparer : IComparer<VSCompletionItem>\n        {\n            public int Compare(VSCompletionItem x, VSCompletionItem y)\n            {\n                var a = x.SortText.AsSpan();\n                var b = y.SortText.AsSpan();\n\n                int comp = 0;", "        struct InitialComparer : IComparer<VSCompletionItem>\n        {\n            public int Compare(VSCompletionItem x, VSCompletionItem y)\n            {\n                var a = x.SortText.AsSpan();\n                var b = y.SortText.AsSpan();\n\n                int comp = 0;\n                if (a.Length > 0 && b.Length > 0)\n                {\n                    comp = GetUnderscoreCount(a) - GetUnderscoreCount(b);\n                }", "                if (a.Length > 0 && b.Length > 0)\n                {\n                    comp = GetUnderscoreCount(a) - GetUnderscoreCount(b);\n                }\n                if (comp == 0)\n                {\n                    comp = a.SequenceCompareTo(b);\n                }\n                return comp;\n            }\n", "            private int GetUnderscoreCount(ReadOnlySpan<char> str)\n            {\n                int i = 0;\n                while (i < str.Length && str[i] == '_')\n                {\n                    i++;\n                }\n                return i;\n            }\n        }\n", "        struct CompletionItemKey : IComparable<CompletionItemKey>\n        {\n            public int patternScore;\n            public int defaultIndex;\n            public int roslynScore;\n            public int initialIndex;\n            public ImmutableArray<Span> matchedSpans;\n\n            public int CompareTo(CompletionItemKey other)\n            {\n                int comp = other.patternScore - patternScore;", "            public int CompareTo(CompletionItemKey other)\n            {\n                int comp = other.patternScore - patternScore;\n                if (comp == 0)\n                {\n                    comp = defaultIndex - other.defaultIndex;\n                }\n                if (comp == 0)\n                {\n                    comp = other.roslynScore - roslynScore;\n                }", "                if (comp == 0) // If score is same, preserve initial ordering.\n                {\n                    comp = initialIndex - other.initialIndex;\n                }\n                return comp;\n            }\n        }\n\n        struct CompletionFilterManager\n        {\n            CompletionFilter[] filters;", "        struct CompletionFilterManager\n        {\n            CompletionFilter[] filters;\n            public readonly BitField64 blacklist;\n            public readonly BitField64 whitelist;\n            BitField64 activeBlacklist;\n            BitField64 activeWhitelist;\n\n            /// <summary>\n            /// True when there is an active whitelist to perform checks against.\n            /// </summary>", "            public bool HasActiveWhitelist => activeWhitelist != default;\n\n            enum CompletionFilterKind\n            {\n                Null, Blacklist, Whitelist\n            }\n\n            public CompletionFilterManager(ImmutableArray<CompletionFilterWithState> filterStates)\n            {\n                Assumes.True(filterStates.Length < 64);\n\n                filters = new CompletionFilter[filterStates.Length];\n                blacklist = default;\n                whitelist = default;\n                activeBlacklist = default;\n                activeWhitelist = default;\n                \n", "                for (int i = 0; i < filterStates.Length; i++)\n                {\n                    var filterState = filterStates[i];\n                    var filter = filterState.Filter;\n                    this.filters[i] = filter;\n                    var filterKind = GetFilterKind(i, filter);\n                    switch (filterKind)\n                    {\n                        case CompletionFilterKind.Blacklist:\n                            blacklist.SetBit(i);\n                            break;\n\n                        case CompletionFilterKind.Whitelist:\n                            whitelist.SetBit(i);\n                            break;\n\n                        default: throw new Exception();\n                    }\n                }\n\n                CompletionFilterKind GetFilterKind(int index, CompletionFilter filter)\n                {\n                    // Is there a safer rule to determine what kind of filter it is?\n                    return index == 0 ? CompletionFilterKind.Blacklist : CompletionFilterKind.Whitelist;\n                }\n            }\n", "            public void UpdateActiveFilters(ImmutableArray<CompletionFilterWithState> filterStates)\n            {\n                Debug.Assert(filterStates.Length == filters.Length);\n\n                BitField64 selection = default;\n                for (int i = 0; i < filterStates.Length; i++)\n                {\n                    if (filterStates[i].IsSelected)\n                    {\n                        selection.SetBit(i);\n                    }\n                }\n\n                activeBlacklist = ~selection & blacklist;\n                activeWhitelist =  selection & whitelist;\n            }\n", "            public BitField64 CreateFilterMask(ImmutableArray<CompletionFilter> completionFilters)\n            {\n                BitField64 mask = default;\n                for (int i = 0; i < completionFilters.Length; i++)\n                {\n                    int index = Array.IndexOf(filters, completionFilters[i]);\n                    Debug.Assert(index >= 0);\n                    mask.SetBit(index);\n                }\n                return mask;\n            }\n", "            public bool HasActiveBlacklistFilter(BitField64 completionFilters)\n            {\n                bool isOnBlacklist = (activeBlacklist & completionFilters) != default;\n                return isOnBlacklist;\n            }\n\n            public bool HasActiveWhitelistFilter(BitField64 completionFilters)\n            {\n                Debug.Assert(HasActiveWhitelist);\n                bool isOnWhitelist = (activeWhitelist & completionFilters) != default;\n                return isOnWhitelist;\n            }\n", "            public bool PassesActiveFilters(BitField64 completionFilters)\n            {\n                return !HasActiveBlacklistFilter(completionFilters) && HasActiveWhitelistFilter(completionFilters);\n            }\n        }\n\n        private void AddDebugSuffix(ref VSCompletionItem completion, in CompletionItemKey key)\n        {\n            var patternScoreString = key.patternScore == int.MinValue ? \"-\" : key.patternScore.ToString();\n            var defaultIndexString = key.defaultIndex == int.MaxValue ? \"-\" : key.defaultIndex.ToString();\n            var roslynScoreString = key.roslynScore == 0 ? \"-\" : key.roslynScore.ToString();\n\n            var debugSuffix = $\" (pattScr: {patternScoreString}, dfltIdx: {defaultIndexString}, roslScr: {roslynScoreString}, initIdx: {key.initialIndex})\";\n            \n            var modifiedCompletion = new VSCompletionItem\n            (\n                completion.DisplayText,\n                completion.Source,\n                completion.Icon,\n                completion.Filters,\n                completion.Suffix + debugSuffix,\n                completion.InsertText,\n                completion.SortText,\n                completion.FilterText,\n                completion.AutomationText,\n                completion.AttributeIcons,\n                completion.CommitCharacters,\n                completion.ApplicableToSpan,\n                completion.IsCommittedAsSnippet,\n                completion.IsPreselected\n            );\n", "            foreach (var property in completion.Properties.PropertyList)\n            {\n                modifiedCompletion.Properties.AddProperty(property.Key, property.Value);\n            }\n\n            completion = modifiedCompletion;\n        }\n    }\n}"]}
{"filename": "VSIntelliSenseTweaks/VSIntelliSenseTweaksPackage.cs", "chunked_list": ["\ufeffusing Microsoft.VisualStudio.Shell;\nusing System;\nusing System.Runtime.InteropServices;\nusing System.Threading;\nusing Microsoft.VisualStudio.Shell.Interop;\nusing System.Diagnostics;\nusing Task = System.Threading.Tasks.Task;\nusing Microsoft;\n\nnamespace VSIntelliSenseTweaks", "\nnamespace VSIntelliSenseTweaks\n{\n    /// <summary>\n    /// This is the class that implements the package exposed by this assembly.\n    /// </summary>\n    /// <remarks>\n    /// <para>\n    /// The minimum requirement for a class to be considered a valid package for Visual Studio\n    /// is to implement the IVsPackage interface and register itself with the shell.\n    /// This package uses the helper classes defined inside the Managed Package Framework (MPF)", "    /// The minimum requirement for a class to be considered a valid package for Visual Studio\n    /// is to implement the IVsPackage interface and register itself with the shell.\n    /// This package uses the helper classes defined inside the Managed Package Framework (MPF)\n    /// to do it: it derives from the Package class that provides the implementation of the\n    /// IVsPackage interface and uses the registration attributes defined in the framework to\n    /// register itself and its components with the shell. These attributes tell the pkgdef creation\n    /// utility what data to put into .pkgdef file.\n    /// </para>\n    /// <para>\n    /// To get loaded into VS, the package must be referred by &lt;Asset Type=\"Microsoft.VisualStudio.VsPackage\" ...&gt; in .vsixmanifest file.\n    /// </para>\n    /// </remarks>\n    [PackageRegistration(UseManagedResourcesOnly = true, AllowsBackgroundLoading = true)]\n    [Guid(VSIntelliSenseTweaksPackage.PackageGuidString)]\n    [ProvideOptionPage(pageType: typeof(GeneralSettings), categoryName: PackageDisplayName, pageName: GeneralSettings.PageName, 0, 0, true)]", "    public sealed class VSIntelliSenseTweaksPackage : AsyncPackage\n    {\n        /// <summary>\n        /// VSIntelliSenseTweaksPackage GUID string.\n        /// </summary>\n        public const string PackageGuidString = \"8e0ec3d8-0561-477a-ade4-77d8826fc290\";\n\n        public const string PackageDisplayName = \"IntelliSense Tweaks\";\n\n        #region Package Members\n\n        /// <summary>\n        /// Initialization of the package; this method is called right after the package is sited, so this is the place\n        /// where you can put all the initialization code that rely on services provided by VisualStudio.\n        /// </summary>\n        /// <param name=\"cancellationToken\">A cancellation token to monitor for initialization cancellation, which can occur when VS is shutting down.</param>\n        /// <param name=\"progress\">A provider for progress updates.</param>\n        /// <returns>A task representing the async work of package initialization, or an already completed task if there is none. Do not return null from this method.</returns>", "        protected override async Task InitializeAsync(CancellationToken cancellationToken, IProgress<ServiceProgressData> progress)\n        {\n            Instance = this;\n            // When initialized asynchronously, the current thread may be a background thread at this point.\n            // Do any initialization that requires the UI thread after switching to the UI thread.\n            await this.JoinableTaskFactory.SwitchToMainThreadAsync(cancellationToken);\n        }\n\n        public static VSIntelliSenseTweaksPackage Instance;\n\n        public static GeneralSettings Settings\n        {\n            get\n            {\n                Debug.Assert(Instance != null);\n                return (GeneralSettings)Instance.GetDialogPage(typeof(GeneralSettings));\n            }\n        }\n", "        public static VSIntelliSenseTweaksPackage Instance;\n\n        public static GeneralSettings Settings\n        {\n            get\n            {\n                Debug.Assert(Instance != null);\n                return (GeneralSettings)Instance.GetDialogPage(typeof(GeneralSettings));\n            }\n        }\n", "        public static void EnsurePackageLoaded()\n        {\n            ThreadHelper.ThrowIfNotOnUIThread();\n            if (Instance == null)\n            {\n                var vsShell = (IVsShell)ServiceProvider.GlobalProvider.GetService(typeof(IVsShell));\n                Assumes.Present(vsShell);\n                var guid = new Guid(VSIntelliSenseTweaksPackage.PackageGuidString);\n                vsShell.LoadPackage(ref guid, out var package);\n                Debug.Assert(Instance != null);\n            }\n        }\n\n        #endregion\n    }\n}\n"]}
{"filename": "VSIntelliSenseTweaks/MultiSelectionCompletionHandler.cs", "chunked_list": ["\ufeff/*\n    Copyright 2023 Carl Foghammar N\u00f6mtak\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software", "\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\nusing Microsoft.VisualStudio.Commanding;\nusing Microsoft.VisualStudio.Language.Intellisense.AsyncCompletion;", "using Microsoft.VisualStudio.Commanding;\nusing Microsoft.VisualStudio.Language.Intellisense.AsyncCompletion;\nusing Microsoft.VisualStudio.Text.Editor;\nusing Microsoft.VisualStudio.Text.Editor.Commanding.Commands;\nusing Microsoft.VisualStudio.Utilities;\nusing Microsoft.VisualStudio.Language.Intellisense.AsyncCompletion.Data;\nusing Microsoft.VisualStudio.Text.Operations;\nusing Microsoft.VisualStudio.Text;\nusing System.ComponentModel.Composition;\nusing System.Diagnostics;", "using System.ComponentModel.Composition;\nusing System.Diagnostics;\nusing System;\nusing System.Windows.Input;\nusing System.Threading;\nusing System.Linq;\nusing System.Collections.Generic;\n\nnamespace VSIntelliSenseTweaks\n{", "namespace VSIntelliSenseTweaks\n{\n    [Export(typeof(ICommandHandler))]\n    [Name(nameof(MultiSelectionCompletionHandler))]\n    [ContentType(\"text\")]\n    [TextViewRole(PredefinedTextViewRoles.Interactive)]\n    public class MultiSelectionCompletionHandler : ICommandHandler<TypeCharCommandArgs>\n    {\n        [Import]\n        IAsyncCompletionBroker completionBroker;\n\n        [Import]\n        ITextBufferUndoManagerProvider undoManagerProvider;\n\n        SessionController sessionController = new SessionController();\n\n        [ImportingConstructor]\n        public MultiSelectionCompletionHandler()\n        {\n            \n        }\n", "        public string DisplayName => nameof(MultiSelectionCompletionHandler);\n\n        public CommandState GetCommandState(TypeCharCommandArgs args)\n        {\n            var textView = args.TextView;\n            var textBuffer = textView.TextBuffer;\n\n            if (!completionBroker.IsCompletionSupported(textBuffer.ContentType, textView.Roles))\n                return CommandState.Unavailable;\n\n            return CommandState.Available;\n        }\n", "        public bool ExecuteCommand(TypeCharCommandArgs args, CommandExecutionContext executionContext)\n        {\n            // TODO: Use binding of edit.completeWord instead of hardcoded keybinding.\n            bool didAttemptCompleteWord = args.TypedChar == ' ' && (Keyboard.Modifiers & ModifierKeys.Control) != 0;\n\n            if (!didAttemptCompleteWord)\n                return false;\n\n            var textView = args.TextView;\n            var textBuffer = textView.TextBuffer;\n\n            var selectionBroker = textView.GetMultiSelectionBroker();", "            if (!selectionBroker.HasMultipleSelections)\n                return false;\n\n            if (sessionController.HasSession) // We already have an active session, do not start a new one.\n                return true;\n\n            var selections = selectionBroker.AllSelections;\n            var primarySelection = selectionBroker.PrimarySelection;\n            int n_selections = selections.Count;\n            var textVersion = textBuffer.CurrentSnapshot.Version;\n\n            var trigger = new CompletionTrigger(CompletionTriggerReason.InvokeAndCommitIfUnique, textBuffer.CurrentSnapshot);\n", "            for (int i = 0; i < n_selections; i++)\n            {\n                var selection = selections[i];\n\n                // Triggering a completion session only works when there is one selection.\n                // So we have to make a hack where try each selection one at a time and then\n                // patch up all other selections once an item was committed.\n                selectionBroker.SetSelection(selection);\n                var triggerPoint = selection.InsertionPoint.Position;\n                var potentialSession = completionBroker.TriggerCompletion(textView, trigger, triggerPoint, CancellationToken.None);\n", "                if (potentialSession == null)\n                    continue;\n\n                potentialSession.OpenOrUpdate(trigger, triggerPoint, CancellationToken.None);\n\n                var completionItems = potentialSession.GetComputedItems(CancellationToken.None); // This call dismisses the session if it is started in a bad location (in a string for example).\n\n                if (textBuffer.CurrentSnapshot.Version != textVersion)\n                {\n                    // For some reason the text version changed due to starting a session.\n                    // We have to get the updated selections.\n                    selections = selectionBroker.AllSelections;\n                    selection = selections[i];\n                }\n", "                if (potentialSession.IsDismissed)\n                    continue;\n\n                int n_completionItems = completionItems.Items.Count();\n\n                Debug.Assert(n_completionItems > 0);\n\n                if (n_completionItems == 1\n                && completionItems.Items.First().InsertText == potentialSession.ApplicableToSpan.GetText(textBuffer.CurrentSnapshot))\n                {\n                    potentialSession.Dismiss();\n                    continue;\n                }\n\n                // We have a good session.\n\n                // Restore original selections, but use current selection as primary, otherwise session will terminate;\n                selectionBroker.SetSelectionRange(selections, selection);\n\n                this.sessionController.Initialize(textBuffer, undoManagerProvider, potentialSession, selectionBroker, primarySelection);\n\n                return true;\n            }\n\n            // Restore original selections if we couldn't begin a session;\n            selectionBroker.SetSelectionRange(selections, primarySelection);\n            return true;\n        }\n", "        private void SelectionBroker_MultiSelectionSessionChanged(object sender, EventArgs e)\n        {\n            \n            throw new NotImplementedException();\n        }\n\n        private class SessionController\n        {\n            ITextBuffer textBuffer;\n            ITextBufferUndoManagerProvider undoManagerProvider;\n            IAsyncCompletionSession session;\n            IMultiSelectionBroker selectionBroker;\n\n            IReadOnlyList<Selection> currentSelections;\n            Selection currentPrimarySelection;\n            Selection originalPrimarySelection;\n\n            bool lastEditChangedTextBuffer;\n", "            public void Initialize(\n                ITextBuffer textBuffer,\n                ITextBufferUndoManagerProvider undoManagerProvider,\n                IAsyncCompletionSession session,\n                IMultiSelectionBroker selectionBroker,\n                Selection originalPrimarySelection)\n            {\n                Debug.Assert(!HasSession);\n\n                this.textBuffer = textBuffer;\n                this.undoManagerProvider = undoManagerProvider;\n                this.session = session;\n                this.selectionBroker = selectionBroker;\n                this.currentSelections = selectionBroker.AllSelections;\n                this.currentPrimarySelection = selectionBroker.PrimarySelection;\n                this.originalPrimarySelection = originalPrimarySelection;\n                this.lastEditChangedTextBuffer = false;\n\n                session.ItemCommitted += AfterItemCommitted;\n                session.Dismissed += SessionDismissed;\n                textBuffer.Changed += AfterTextBufferChanged;\n\n                selectionBroker.MultiSelectionSessionChanged += GetCurrentSelections;\n            }\n", "            public bool HasSession => session != null;\n            int n_selections => currentSelections.Count;\n\n            void GetCurrentSelections(object sender, EventArgs e)\n            {\n                Debug.Assert(sender == selectionBroker);\n                if (!selectionBroker.HasMultipleSelections)\n                {\n                    // If we dont have multiSelections anymore it is likely the user committed an item and a bug set the selections to one.\n                    return;\n                }\n                currentSelections = selectionBroker.AllSelections;\n                currentPrimarySelection = selectionBroker.PrimarySelection;\n            }\n", "            private void AfterTextBufferChanged(object sender, TextContentChangedEventArgs e)\n            {\n                Debug.Assert(sender == textBuffer);\n                this.lastEditChangedTextBuffer = e.BeforeVersion.ReiteratedVersionNumber != e.AfterVersion.ReiteratedVersionNumber;\n            }\n\n            void AfterItemCommitted(object sender, CompletionItemEventArgs e)\n            {\n                Debug.Assert(sender == session);\n\n                var selectionCharacteristics = new SelectionCharacteristics(selectionBroker.PrimarySelection);\n\n                var undoHistory = undoManagerProvider.GetTextBufferUndoManager(textBuffer).TextBufferUndoHistory;\n", "                if (lastEditChangedTextBuffer) // Last edit should be the commit action.\n                {\n                    // If text buffer was changed due to committing an item we need to revert that change.\n                    undoHistory.Undo(1); // Undo insertion of committed item, we will redo it for all selections under same transaction instead.\n                }\n\n                var undoTransaction = undoHistory.CreateTransaction(nameof(MultiSelectionCompletionHandler));\n\n                ITextSnapshot beforeEditSnapshot = textBuffer.CurrentSnapshot;\n                ITextSnapshot afterEditSnapshot;\n", "                using (var edit = textBuffer.CreateEdit())\n                {\n                    for (int j = 0; j < n_selections; j++)\n                    {\n                        var selection = currentSelections[j];\n\n                        var insertPoint = selection.InsertionPoint.TranslateTo(beforeEditSnapshot).Position;\n                        var replaceSpan = GetWordSpan(insertPoint.Position, beforeEditSnapshot);\n                        edit.Replace(replaceSpan, e.Item.InsertText);\n                    }\n                    afterEditSnapshot = edit.Apply();\n                }\n\n                var newSelections = currentSelections.Select(MakeNewSelection);\n                var newPrimarySelection = MakeNewSelection(originalPrimarySelection);\n\n                selectionBroker.SetSelectionRange(newSelections, newPrimarySelection);\n\n                undoTransaction.Complete();\n\n                Selection MakeNewSelection(Selection selection)\n                {\n                    var insertPoint = selection.InsertionPoint.TranslateTo(afterEditSnapshot).Position;\n                    return selectionCharacteristics.CreateSelection(insertPoint);\n                }\n            }\n\n            void SessionDismissed(object sender, EventArgs e)\n            {\n                Debug.Assert(sender == session);\n\n                session = null;\n                textBuffer.Changed -= AfterTextBufferChanged;\n                selectionBroker.MultiSelectionSessionChanged -= GetCurrentSelections;\n                selectionBroker.TrySetAsPrimarySelection(TranslateTo(originalPrimarySelection, selectionBroker.CurrentSnapshot,\n                    PointTrackingMode.Positive, PointTrackingMode.Negative, PointTrackingMode.Positive));\n            }\n        }\n", "        private static Span GetWordSpan(int position, ITextSnapshot snapshot)\n        {\n            int start = position;\n            int length = 0;\n            while (start > 0 && IsWordChar(snapshot[start - 1]))\n            {\n                start--;\n                length++;\n            }\n            if (length > 0)\n            {", "            if (length > 0)\n            {\n                while (start + length < snapshot.Length && IsWordChar(snapshot[start + length]))\n                {\n                    length++;\n                }\n            }\n            return new Span(start, length);\n\n            bool IsWordChar(char c)\n            {\n                return char.IsLetterOrDigit(c) || c == '_';\n            }\n        }\n", "        public static Selection TranslateTo(Selection selection, ITextSnapshot targetSnapshot, PointTrackingMode insertionPointTracking, PointTrackingMode anchorPointTracking, PointTrackingMode activePointTracking)\n        {\n            return new Selection\n            (\n                selection.InsertionPoint.TranslateTo(targetSnapshot, insertionPointTracking),\n                selection.AnchorPoint.TranslateTo(targetSnapshot, anchorPointTracking),\n                selection.ActivePoint.TranslateTo(targetSnapshot, activePointTracking),\n                selection.InsertionPointAffinity\n            );\n        }\n", "        struct SelectionCharacteristics\n        {\n            int anchorOffset;\n            int activeOffset;\n            PositionAffinity insertionPointAffinity;\n\n            public SelectionCharacteristics(Selection selection)\n            {\n                anchorOffset = selection.InsertionPoint.Position.Position\n                    - selection.AnchorPoint.Position.Position;\n\n                activeOffset = selection.InsertionPoint.Position.Position\n                    - selection.ActivePoint.Position.Position;\n\n                insertionPointAffinity = selection.InsertionPointAffinity;\n            }\n", "            public Selection CreateSelection(SnapshotPoint insertionPoint)\n            {\n                var snapshot = insertionPoint.Snapshot;\n                var anchorPoint = new SnapshotPoint(snapshot, insertionPoint.Position - anchorOffset);\n                var activePoint = new SnapshotPoint(snapshot, insertionPoint.Position - activeOffset);\n\n                return new Selection(insertionPoint, anchorPoint, activePoint, insertionPointAffinity);\n            }\n        }\n    }\n}\n"]}
{"filename": "VSIntelliSenseTweaks/Properties/AssemblyInfo.cs", "chunked_list": ["\ufeffusing System.Reflection;\nusing System.Runtime.InteropServices;\n\n// General Information about an assembly is controlled through the following \n// set of attributes. Change these attribute values to modify the information\n// associated with an assembly.\n[assembly: AssemblyTitle(\"VSIntelliSenseTweaks\")]\n[assembly: AssemblyDescription(\"\")]\n[assembly: AssemblyConfiguration(\"\")]\n[assembly: AssemblyCompany(\"\")]", "[assembly: AssemblyConfiguration(\"\")]\n[assembly: AssemblyCompany(\"\")]\n[assembly: AssemblyProduct(\"VSIntelliSenseTweaks\")]\n[assembly: AssemblyCopyright(\"\")]\n[assembly: AssemblyTrademark(\"\")]\n[assembly: AssemblyCulture(\"\")]\n\n// Setting ComVisible to false makes the types in this assembly not visible \n// to COM components.  If you need to access a type in this assembly from \n// COM, set the ComVisible attribute to true on that type.", "// to COM components.  If you need to access a type in this assembly from \n// COM, set the ComVisible attribute to true on that type.\n[assembly: ComVisible(false)]\n\n// Version information for an assembly consists of the following four values:\n//\n//      Major Version\n//      Minor Version \n//      Build Number\n//      Revision", "//      Build Number\n//      Revision\n//\n// You can specify all the values or you can default the Build and Revision Numbers \n// by using the '*' as shown below:\n// [assembly: AssemblyVersion(\"1.0.*\")]\n[assembly: AssemblyVersion(\"1.0.0.0\")]\n[assembly: AssemblyFileVersion(\"1.0.0.0\")]\n", ""]}
{"filename": "VSIntelliSenseTweaks/Utilities/BitSpan.cs", "chunked_list": ["\ufeffusing System;\nusing System.Diagnostics;\n\nnamespace VSIntelliSenseTweaks.Utilities\n{\n    public ref struct BitSpan\n    {\n        private Span<int> data;\n\n        public static int GetRequiredIntCount(int n_bits)\n        {\n            Debug.Assert(n_bits > 0);\n            return (n_bits - 1) / 32 + 1;\n        }\n\n        public BitSpan(Span<int> data)\n        {\n            this.data = data;\n        }\n", "        public static int GetRequiredIntCount(int n_bits)\n        {\n            Debug.Assert(n_bits > 0);\n            return (n_bits - 1) / 32 + 1;\n        }\n\n        public BitSpan(Span<int> data)\n        {\n            this.data = data;\n        }\n", "        public bool this[int index]\n        {\n            get => GetBit(index);\n            set\n            {\n                if (value)\n                {\n                    SetBit(index);\n                }\n                else\n                {\n                    ClearBit(index);\n                }\n            }\n        }\n", "        public bool GetBit(int index)\n        {\n            var intIndex = Math.DivRem(index, 32, out var bitIndex);\n            var mask = 1 << bitIndex;\n            return (data[intIndex] & mask) == mask;\n        }\n\n        public void SetBit(int index)\n        {\n            var intIndex = Math.DivRem(index, 32, out var bitIndex);\n            var mask = 1 << bitIndex;\n            data[intIndex] |= mask;\n        }\n", "        public void ClearBit(int index)\n        {\n            var intIndex = Math.DivRem(index, 32, out var bitIndex);\n            var mask = 1 << bitIndex;\n            data[intIndex] &= ~mask;\n        }\n\n        public bool[] ToBoolArray()\n        {\n            int l = data.Length * 32;\n            var a = new bool[l];", "            for (int i = 0; i < l; i++)\n            {\n                a[i] = this[i];\n            }\n            return a;\n        }\n    }\n}\n"]}
{"filename": "VSIntelliSenseTweaks/Utilities/Measurement.cs", "chunked_list": ["\ufeff#if DEBUG\n#define MEASURE_TIME\n#endif\n\nusing System;\nusing System.Text;\nusing System.Diagnostics;\n\nnamespace VSIntelliSenseTweaks.Utilities\n{\n    struct Measurement : IDisposable\n    {\n#if MEASURE_TIME\n        static int depth = 0;\n        static StringBuilder builder = new StringBuilder();\n        static int backupLength = -1;\n\n        Stopwatch watch;\n        int insertPos;\n#endif\n        public Measurement(string name) : this()\n        {\n#if MEASURE_TIME\n            builder.AppendLine();", "namespace VSIntelliSenseTweaks.Utilities\n{\n    struct Measurement : IDisposable\n    {\n#if MEASURE_TIME\n        static int depth = 0;\n        static StringBuilder builder = new StringBuilder();\n        static int backupLength = -1;\n\n        Stopwatch watch;\n        int insertPos;\n#endif\n        public Measurement(string name) : this()\n        {\n#if MEASURE_TIME\n            builder.AppendLine();", "            for (int i = 0; i < depth; i++)\n            {\n                builder.Append(\"|   \");\n            }\n            builder.Append(\"'\");\n            builder.Append(name);\n            builder.Append(\"' ms: \");\n            insertPos = builder.Length;\n            backupLength = builder.Length;\n            builder.AppendLine();\n            for (int i = 0; i < depth; i++)\n            {\n                builder.Append(\"|   \");\n            }\n            builder.Append(\"{\");\n            depth++;\n            watch = Stopwatch.StartNew();\n#endif\n        }\n", "            for (int i = 0; i < depth; i++)\n            {\n                builder.Append(\"|   \");\n            }\n            builder.Append(\"{\");\n            depth++;\n            watch = Stopwatch.StartNew();\n#endif\n        }\n\n        public void Dispose()\n        {\n#if MEASURE_TIME\n            var ms = watch.ElapsedMilliseconds;\n            depth--;", "        public void Dispose()\n        {\n#if MEASURE_TIME\n            var ms = watch.ElapsedMilliseconds;\n            depth--;\n            if (backupLength >= 0)\n            {\n                builder.Length = backupLength;\n                backupLength = -1;\n            }\n            else\n            {\n                builder.AppendLine();", "                for (int i = 0; i < depth; i++)\n                {\n                    builder.Append(\"|   \");\n                }\n                builder.Append(\"}\");\n            }\n            builder.Insert(insertPos, ms.ToString());\n\n            if (depth == 0)\n            {\n                Debug.WriteLine(builder.ToString());\n                builder.Clear();\n            }\n#endif\n        }\n    }\n}", "            if (depth == 0)\n            {\n                Debug.WriteLine(builder.ToString());\n                builder.Clear();\n            }\n#endif\n        }\n    }\n}"]}
{"filename": "VSIntelliSenseTweaks/Utilities/BitField64.cs", "chunked_list": ["\ufeffusing Microsoft.CodeAnalysis.CSharp;\nusing System;\n\nnamespace VSIntelliSenseTweaks.Utilities\n{\n    internal struct BitField64\n    {\n        public ulong data;\n\n        public bool GetBit(int index)\n        {\n            var mask = 1ul << index;\n            return (data & mask) == mask;\n        }\n", "        public bool GetBit(int index)\n        {\n            var mask = 1ul << index;\n            return (data & mask) == mask;\n        }\n\n        public void SetBit(int index)\n        {\n            var mask = 1ul << index;\n            data |= mask;\n        }\n", "        public void ClearBit(int index)\n        {\n            var mask = 1ul << index;\n            data &= ~mask;\n        }\n\n        public override bool Equals(object obj)\n        {\n            return obj is BitField64 field &&\n                   data == field.data;\n        }\n", "        public override int GetHashCode()\n        {\n            return data.GetHashCode();\n        }\n\n        public static bool operator ==(BitField64 x, BitField64 y) => x.data == y.data;\n        public static bool operator !=(BitField64 x, BitField64 y) => x.data != y.data;\n        public static BitField64 operator &(BitField64 x, BitField64 y) => new BitField64 { data = x.data & y.data };\n        public static BitField64 operator |(BitField64 x, BitField64 y) => new BitField64 { data = x.data | y.data };\n        public static BitField64 operator ^(BitField64 x, BitField64 y) => new BitField64 { data = x.data ^ y.data };\n        public static BitField64 operator ~(BitField64 x) => new BitField64 { data = ~x.data };\n", "        public static BitField64 operator |(BitField64 x, BitField64 y) => new BitField64 { data = x.data | y.data };\n        public static BitField64 operator ^(BitField64 x, BitField64 y) => new BitField64 { data = x.data ^ y.data };\n        public static BitField64 operator ~(BitField64 x) => new BitField64 { data = ~x.data };\n\n        public override string ToString()\n        {\n            return Convert.ToString((long)data, 2);\n        }\n    }\n}\n"]}
{"filename": "VSIntelliSenseTweaks/Utilities/Helpers.cs", "chunked_list": ["\ufeffusing Microsoft.VisualStudio.Text;\nusing Microsoft.VisualStudio.TextManager.Interop;\nusing System;\n\nnamespace VSIntelliSenseTweaks.Utilities\n{\n    static class Helpers\n    {\n        public static TextSpan GetTextSpan(ref this SnapshotSpan span)\n        {\n            TextSpan textSpan = new TextSpan();\n\n            var startPoint = span.Start;\n            var startLine = startPoint.GetContainingLine();\n            textSpan.iStartIndex = startPoint.Position - startLine.Start.Position;\n            textSpan.iStartLine = startLine.LineNumber;\n\n            var endPoint = span.End;\n            var endLine = endPoint.GetContainingLine();\n            textSpan.iEndIndex = endPoint.Position - endLine.Start.Position;\n            textSpan.iEndLine = endLine.LineNumber;\n\n            return textSpan;\n        }\n", "        public static TextSpan GetTextSpan(ref this SnapshotSpan span)\n        {\n            TextSpan textSpan = new TextSpan();\n\n            var startPoint = span.Start;\n            var startLine = startPoint.GetContainingLine();\n            textSpan.iStartIndex = startPoint.Position - startLine.Start.Position;\n            textSpan.iStartLine = startLine.LineNumber;\n\n            var endPoint = span.End;\n            var endLine = endPoint.GetContainingLine();\n            textSpan.iEndIndex = endPoint.Position - endLine.Start.Position;\n            textSpan.iEndLine = endLine.LineNumber;\n\n            return textSpan;\n        }\n", "        public static ReadOnlySpan<char> Slice(this ReadOnlySpan<char> word, Span span)\n        {\n            return word.Slice(span.Start, span.Length);\n        }\n    }\n}\n"]}
{"filename": "VSIntelliSenseTweaks/Utilities/UnmanagedStack.cs", "chunked_list": ["\ufeffusing System;\nusing System.Diagnostics;\n\nnamespace VSIntelliSenseTweaks.Utilities\n{\n    internal class UnmanagedStack<T> where T : unmanaged\n    {\n        public T[] array;\n        public int count;\n\n        public UnmanagedStack(int initialCapacity)\n        {\n            this.array = new T[initialCapacity];\n            this.count = 0;\n        }\n", "        public int count;\n\n        public UnmanagedStack(int initialCapacity)\n        {\n            this.array = new T[initialCapacity];\n            this.count = 0;\n        }\n\n        public void GrowCapacity(int newCapacity)\n        {\n            Debug.Assert(newCapacity > count);\n\n            var newArray = new T[newCapacity];\n            Array.Copy(array, newArray, count);\n            this.array = newArray;\n        }\n", "        public void GrowCapacity(int newCapacity)\n        {\n            Debug.Assert(newCapacity > count);\n\n            var newArray = new T[newCapacity];\n            Array.Copy(array, newArray, count);\n            this.array = newArray;\n        }\n\n        public void Push(T value)\n        {", "        public void Push(T value)\n        {\n            if (count == array.Length)\n            {\n                GrowCapacity(this.array.Length * 2);\n            }\n            array[count++] = value;\n        }\n\n        public ref T Peek()\n        {\n            Debug.Assert(count > 0);\n\n            return ref array[count - 1];\n        }\n", "        public ref T Peek()\n        {\n            Debug.Assert(count > 0);\n\n            return ref array[count - 1];\n        }\n\n        public T Pop()\n        {\n            Debug.Assert(count > 0);\n\n            count--;\n            return array[count];\n        }\n    }\n}\n"]}
{"filename": "VSIntelliSenseTweaks/Utilities/WordScorer.cs", "chunked_list": ["\ufeff/*\n    Copyright 2023 Carl Foghammar N\u00f6mtak\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software", "\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\nusing Microsoft.VisualStudio.Text;\nusing System;", "using Microsoft.VisualStudio.Text;\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Diagnostics;\n\nnamespace VSIntelliSenseTweaks.Utilities\n{\n    public struct WordScorer\n    {\n        UnmanagedStack<MatchedSpan> matchedSpans;\n\n        public WordScorer(int stackInitialCapacity)\n        {\n            this.matchedSpans = new UnmanagedStack<MatchedSpan>(stackInitialCapacity);\n        }\n", "    public struct WordScorer\n    {\n        UnmanagedStack<MatchedSpan> matchedSpans;\n\n        public WordScorer(int stackInitialCapacity)\n        {\n            this.matchedSpans = new UnmanagedStack<MatchedSpan>(stackInitialCapacity);\n        }\n\n        public int ScoreWord(ReadOnlySpan<char> word, ReadOnlySpan<char> pattern, int displayTextOffset, out ImmutableArray<Span> matchedSpans)\n        {\n            int wordLength = word.Length;\n            int patternLength = pattern.Length;\n            Debug.Assert(patternLength > 0);\n            Debug.Assert(patternLength <= 256);\n", "        public int ScoreWord(ReadOnlySpan<char> word, ReadOnlySpan<char> pattern, int displayTextOffset, out ImmutableArray<Span> matchedSpans)\n        {\n            int wordLength = word.Length;\n            int patternLength = pattern.Length;\n            Debug.Assert(patternLength > 0);\n            Debug.Assert(patternLength <= 256);\n\n            if (wordLength < patternLength)\n            {\n                matchedSpans = default;\n                return int.MinValue;\n            }\n\n            Span<CharRange> charRanges = stackalloc CharRange[patternLength];\n", "            if (!Prospect(word, pattern, charRanges))\n            {\n                matchedSpans = default;\n                return int.MinValue;\n            }\n\n            int n_ints = BitSpan.GetRequiredIntCount(wordLength + 1);\n            Span<int> ints = n_ints <= 256 ? stackalloc int[n_ints] : new int[n_ints];\n            var isSubwordStart = new BitSpan(ints);\n            int n_subwords = DetermineSubwords(word, isSubwordStart);\n\n            Span<MatchedSpan> spans = stackalloc MatchedSpan[patternLength];\n            Span<byte> charToSpan = stackalloc byte[patternLength];\n\n            var data = new PatternMatchingData\n            {\n                word = word,\n                pattern = pattern,\n                charRanges = charRanges,\n                charToSpan = charToSpan,\n                spans = spans,\n                isSubwordStart = isSubwordStart,\n                n_subwords = n_subwords,\n                n_spans = 0,\n            };\n\n            FindMatchingSpans(ref data);\n            CombineMatchedSpans(ref data);\n\n            int score = CompileSpans(ref data, displayTextOffset, out matchedSpans);\n            return score;\n        }\n\n        static int DetermineSubwords(ReadOnlySpan<char> word, BitSpan isSubwordStart)\n        {\n            Span<CharKind> charKinds = word.Length <= 1024 ? stackalloc CharKind[word.Length] : new CharKind[word.Length];\n            int n_chars = word.Length;\n", "            for (int i = 0; i < n_chars; i++)\n            {\n                charKinds[i] = new CharKind(word[i]);\n            }\n\n            int n_subwords = 0;\n            for (int i = 0; i < n_chars; i++)\n            {\n                bool isSubwordBeginning = i == 0\n                  || ((!charKinds[i - 1].IsUpper || (i == 1 && word[i - 1] == 'I')) && charKinds[i].IsUpper)\n                  || (!charKinds[i - 1].IsLetter && charKinds[i].IsLetter)\n                  || (i + 1 < n_chars && charKinds[i].IsUpper && !charKinds[i + 1].IsUpper);\n\n                // TODO: Set each bit to ensure initialized.", "                if (isSubwordBeginning)\n                {\n                    isSubwordStart.SetBit(i);\n                    n_subwords++;\n                }\n            }\n            return n_subwords;\n        }\n\n        static void PopulateSubwords(int wordLength, BitSpan isSubwordStart, Span<Span> subwordSpans)\n        {\n            int j = 0;", "            for (int i = 0; i < subwordSpans.Length; i++)\n            {\n                int start = j;\n                do\n                {\n                    j++;\n                } while (j != wordLength && !isSubwordStart[j]);\n                int length = j - start;\n                subwordSpans[i] = new Span(start, length);\n            }\n        }\n", "        private ref struct PatternMatchingData\n        {\n            public ReadOnlySpan<char> word;\n            public ReadOnlySpan<char> pattern;\n            public Span<CharRange> charRanges;\n            public Span<byte> charToSpan;\n            public Span<MatchedSpan> spans;\n            public BitSpan isSubwordStart;\n            public int n_subwords;\n            public int n_spans;\n", "            public int n_subwords;\n            public int n_spans;\n\n            public int GetSpanIndex(int charIndex) => charToSpan[charIndex];\n\n            public void AddSpan(MatchedSpan span)\n            {\n                var index = n_spans++;\n                spans[index] = span;\n                int i_end = span.EndInPattern;\n                for (int i = span.StartInPattern; i < i_end; i++)\n                {\n                    charToSpan[i] = (byte)index;\n                }\n            }\n", "                for (int i = span.StartInPattern; i < i_end; i++)\n                {\n                    charToSpan[i] = (byte)index;\n                }\n            }\n\n            public bool IsInRange(int indexInWord, int indexInPattern)\n            {\n                return charRanges[indexInPattern].IsInRange(indexInWord);\n            }\n        }\n", "        private struct CharRange\n        {\n            public short minPos;\n            public short maxPos;\n\n            public bool IsInRange(int index)\n            {\n                return minPos <= index && index <= maxPos;\n            }\n        }\n\n        static bool Prospect(ReadOnlySpan<char> word, ReadOnlySpan<char> pattern, Span<CharRange> ranges)\n        {\n            int wordLength = word.Length;\n            int patternLength = pattern.Length;\n            Debug.Assert(patternLength == ranges.Length);\n            int i = 0;\n            int j = 0;", "            while (j < patternLength)\n            {\n                if (patternLength - j > wordLength - i)\n                {\n                    return false;\n                }\n\n                if (FuzzyCharEquals(word[i], pattern[j]))\n                {\n                    ranges[j].minPos = (short)i;\n                    j++;\n                }\n                i++;\n            }\n\n            i = wordLength - 1;\n            j--;\n", "            while (j > -1)\n            {\n                if (FuzzyCharEquals(word[i], pattern[j]))\n                {\n                    ranges[j].maxPos = (short)i;\n                    j--;\n                }\n                i--;\n            }\n            Debug.Assert(j == -1);\n            return true;\n        }\n\n        void FindMatchingSpans(ref PatternMatchingData data)\n        {\n            this.matchedSpans.count = 0;\n\n            int i_final = data.word.Length - data.pattern.Length;\n", "            for (int k = 0; k <= i_final; k++)\n            {\n                DetermineApplicablePatternSpan(k, data.charRanges, out int j, out int j_final);\n                int i = k + j;\n                int length = 0;\n                bool isEnd = j > j_final;\n                while (!isEnd)\n                {\n                    if (FuzzyCharEquals(data.word[i], data.pattern[j]))\n                    {\n                        length++;\n                    }", "                    if (FuzzyCharEquals(data.word[i], data.pattern[j]))\n                    {\n                        length++;\n                    }\n                    else if (length > 0)\n                    {\n                        MakeSpan(ref data, this.matchedSpans);\n                    }\n\n                    i++;\n                    j++;\n\n                    isEnd = j > j_final;\n", "                    if (length > 0 && (isEnd || data.isSubwordStart[i]))\n                    {\n                        MakeSpan(ref data, this.matchedSpans);\n                    }\n\n                    void MakeSpan(ref PatternMatchingData _data, UnmanagedStack<MatchedSpan> matchedSpans)\n                    {\n                        int startInWord = i - length;\n                        int startInPattern = j - length;\n                        var newSpan = new MatchedSpan(startInWord, startInPattern, length, _data.isSubwordStart[startInWord]);\n                        matchedSpans.Push(newSpan);\n                        length = 0;\n                    }\n                }\n            }\n        }\n\n        static void DetermineApplicablePatternSpan(int k, Span<CharRange> ranges, out int start, out int final)\n        {\n            start = 0;\n            final = ranges.Length - 1;", "            while (start <  final && k + start > ranges[start].maxPos) start++;\n            while (final >= start && k + final < ranges[final].minPos) final--;\n        }\n\n        void CombineMatchedSpans(ref PatternMatchingData data)\n        {\n            Debug.Assert(matchedSpans.count > 0);\n\n            int n_matchedInPattern = 0;\n            for (int i = 0; i < matchedSpans.count; i++)\n            {\n                var newSpan = matchedSpans.array[i];\n\n                ConsiderSpan(ref data, ref n_matchedInPattern, newSpan);\n            }\n\n            Debug.Assert(n_matchedInPattern == data.pattern.Length);\n        }\n", "            for (int i = 0; i < matchedSpans.count; i++)\n            {\n                var newSpan = matchedSpans.array[i];\n\n                ConsiderSpan(ref data, ref n_matchedInPattern, newSpan);\n            }\n\n            Debug.Assert(n_matchedInPattern == data.pattern.Length);\n        }\n\n        private static void ConsiderSpan(ref PatternMatchingData data, ref int n_matchedInPattern, MatchedSpan newSpan)\n        {", "        private static void ConsiderSpan(ref PatternMatchingData data, ref int n_matchedInPattern, MatchedSpan newSpan)\n        {\n            if (newSpan.StartInPattern > n_matchedInPattern)\n            {\n                return;\n            }\n\n            if (newSpan.StartInPattern == n_matchedInPattern)\n            {\n                data.AddSpan(newSpan);\n                n_matchedInPattern = newSpan.EndInPattern;\n                return;\n            }\n\n            // newSpan.StartInPattern < n_matchedInPattern\n\n            int existingSpanIndex = data.charToSpan[newSpan.StartInPattern];\n            MatchedSpan existingSpan = data.spans[existingSpanIndex];\n", "            if (ShouldMerge(ref data, ref n_matchedInPattern))\n            {\n                data.n_spans = existingSpanIndex;\n                int overlap = existingSpan.EndInPattern - newSpan.StartInPattern;\n                Debug.Assert(overlap > 0);\n                if (overlap < existingSpan.Length)\n                {\n                    data.AddSpan(existingSpan.TrimBack(overlap));\n                }\n                data.AddSpan(newSpan);\n                n_matchedInPattern = newSpan.EndInPattern;\n            }", "            else if (newSpan.EndInPattern > n_matchedInPattern)\n            {\n                int trimCount = n_matchedInPattern - newSpan.StartInPattern;\n                Debug.Assert(trimCount > 0);\n                newSpan = newSpan.TrimFront(trimCount);\n                Debug.Assert(!data.isSubwordStart[newSpan.Start]);\n                data.AddSpan(newSpan);\n                n_matchedInPattern = newSpan.EndInPattern;\n            }\n\n            bool ShouldMerge(ref PatternMatchingData data_, ref int n_matchedInPattern_)\n            {", "                if (newSpan.StartInPattern == existingSpan.StartInPattern)\n                {\n                    if (newSpan.IsSubwordStart_AsInt > existingSpan.IsSubwordStart_AsInt)\n                        return true;\n\n                    if (newSpan.IsSubwordStart_AsInt < existingSpan.IsSubwordStart_AsInt)\n                        return false;\n\n                    if (newSpan.Length > existingSpan.Length)\n                        return true;\n\n                    return false;\n                }\n", "                    if (newSpan.Length > existingSpan.Length)\n                        return true;\n\n                    return false;\n                }\n\n                if (newSpan.IsSubwordStart)\n                {\n                    if (newSpan.EndInPattern > existingSpan.EndInPattern)\n                        return true;\n", "                    if (newSpan.EndInPattern > existingSpan.EndInPattern)\n                        return true;\n\n                    if (newSpan.EndInPattern == existingSpan.EndInPattern\n                        && data_.word[newSpan.Start] == data_.pattern[newSpan.StartInPattern])\n                    {\n                        return true;\n                    }\n                }\n\n                return false;\n            }\n        }\n\n        static int CompileSpans(ref PatternMatchingData data, int displayTextOffset, out ImmutableArray<Span> matchedSpans)\n        {\n            int n_spans = data.n_spans;\n            Debug.Assert(n_spans > 0);\n            var builder = ImmutableArray.CreateBuilder<Span>(n_spans);\n            builder.Count = n_spans;\n            int score = 0;\n            int n_subwordHits = 0;\n            int n_upperMatchedAsLower = 0;\n            int n_lowerMatchedAsUpper = 0;", "            for (int i = 0; i < n_spans; i++)\n            {\n                var span = data.spans[i];\n                builder[i] = new Span(span.Start + displayTextOffset, span.Length);\n                if (span.IsSubwordStart) n_subwordHits++;\n                for (int j = 0; j < span.Length; j++)\n                {\n                    int comp = data.word[span.Start + j] - data.pattern[span.StartInPattern + j];\n                    if (comp < 0)\n                    {\n                        n_lowerMatchedAsUpper++;\n                    }", "                    if (comp < 0)\n                    {\n                        n_lowerMatchedAsUpper++;\n                    }\n                    else if (comp > 0)\n                    {\n                        n_upperMatchedAsLower++;\n                    }\n                }\n                score += ScoreSpan(span); \n            }\n\n            int n_unmatchedChars = data.word.Length - data.pattern.Length;\n            int n_unmatchedTrailingChars = data.word.Length - data.spans[n_spans - 1].End;\n            int n_unmatchedPassedChars = n_unmatchedChars - n_unmatchedTrailingChars;\n            int n_unmatchedSubwords = data.n_subwords - n_subwordHits;\n\n            score -= 4 * n_unmatchedPassedChars;\n            score -= 1 * n_unmatchedTrailingChars;\n            score -= 64 * n_unmatchedSubwords;\n            score -= 16 * n_spans;\n            score -= 32 * n_upperMatchedAsLower;\n            score -= 16 * n_lowerMatchedAsUpper;\n", "            if (n_unmatchedChars == 0 && n_upperMatchedAsLower == 0 && n_lowerMatchedAsUpper == 0)\n            {\n                // Perfect match gets a bonus.\n                score *= 2;\n            }\n\n            matchedSpans = builder.MoveToImmutable();\n\n            return score;\n        }\n\n        static int ScoreSpan(MatchedSpan span)\n        {\n            int effectiveLength = span.Length;\n            int score = 32 * effectiveLength;\n            score *= span.IsSubwordStart ? 4 : 1;\n            //score -= span.Start;\n            return score;\n        }\n\n        static bool FuzzyCharEquals(char a, char b)\n        {\n            // May need to be improved if non-ascii chars are used.\n            int comp = a - b;\n            bool result = comp == 0;\n            result |= comp ==  32 && a >= 'a' && b <= 'Z';\n            result |= comp == -32 && a <= 'Z' && b >= 'a';\n            return result;\n        }\n", "        private struct FirstSpanFirst : IComparer<MatchedSpan>\n        {\n            public int Compare(MatchedSpan x, MatchedSpan y)\n            {\n                int comp = x.Start - y.Start;\n                return comp;\n            }\n        }\n\n        private struct MatchedSpan\n        {\n            // Kept small to decrease allocation size.\n            ushort isSubwordStart_start;\n            byte startInPattern;\n            byte length;\n", "        private struct MatchedSpan\n        {\n            // Kept small to decrease allocation size.\n            ushort isSubwordStart_start;\n            byte startInPattern;\n            byte length;\n\n            public bool IsValid => length != 0;\n            public int Start => isSubwordStart_start & ((1 << 15) - 1);\n            public int StartInPattern => startInPattern;\n            public int End => Start + length;", "            public int Start => isSubwordStart_start & ((1 << 15) - 1);\n            public int StartInPattern => startInPattern;\n            public int End => Start + length;\n            public int EndInPattern => startInPattern + length;\n            public int Length => length;\n            public bool IsSubwordStart => IsSubwordStart_AsInt == 1;\n            public int IsSubwordStart_AsInt => isSubwordStart_start >> 15;\n\n            public MatchedSpan(int start, int startInPattern, int length, bool isSubwordStart)\n            {\n                Debug.Assert(start >= 0);\n                Debug.Assert(start < 1 << 15);\n                Debug.Assert(startInPattern >= 0);\n                Debug.Assert(startInPattern <= byte.MaxValue);\n                Debug.Assert(length >= 0);\n                Debug.Assert(length <= byte.MaxValue);\n                this.isSubwordStart_start = (ushort)start;\n                this.startInPattern = (byte)startInPattern;\n                this.length = (byte)length;", "                if (isSubwordStart)\n                {\n                    this.isSubwordStart_start |= 1 << 15;\n                }\n            }\n\n            public Span ToSpan()\n            {\n                return new Span(Start, Length);\n            }\n", "            public MatchedSpan TrimFront(int count)\n            {\n                Debug.Assert(count < length);\n                return new MatchedSpan(Start + count, StartInPattern + count, Length - count, false);\n            }\n\n            public MatchedSpan TrimBack(int count)\n            {\n                Debug.Assert(count < length);\n                return new MatchedSpan(Start, StartInPattern, Length - count, IsSubwordStart);\n            }\n        }\n    }\n}"]}
{"filename": "VSIntelliSenseTweaks/Utilities/CharKind.cs", "chunked_list": ["\ufeffnamespace VSIntelliSenseTweaks.Utilities\n{\n    public struct CharKind\n    {\n        private const byte isLetter = 1;\n        private const byte isUpper = 2;\n\n        private byte flags;\n\n        public CharKind(char c)\n        {\n            this.flags = default;\n            flags |= char.IsLetter(c) ? isLetter : default;\n            flags |= char.IsUpper(c) ? isUpper : default;\n        }\n", "        public bool IsLetter => (flags & isLetter) != 0;\n        public bool IsUpper => (flags & isUpper) != 0;\n    }\n}\n"]}
