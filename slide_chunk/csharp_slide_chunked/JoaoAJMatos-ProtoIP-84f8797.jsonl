{"filename": "examples/netpods.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System;\nusing System.Threading;\n\nusing ProtoIP;\n\nclass Program \n{\n      static void Main() \n      {\n            Ethernet ethernet = new Ethernet();\n            IP ip = new IP(sourceIP: \"192.168.1.211\", destinationIP: \"192.168.1.211\");\n            TCP tcp = new TCP(sourcePort: 80, destinationPort: 80);\n\n            // Create a new NetPod and\n            // add the network layers using\n            // the composition operator (\"/\")\n            NetPod pod = new NetPod(ethernet / ip / tcp);\n\n            // Show the NetPod structure\n            NetPod.ShowStructure(pod);\n\n            Action<NetPod> action = (NetPod receivedPod) => {\n                  Console.WriteLine(\"Received packet: \" + receivedPod);\n            };\n\n            // Start sniffing packets on the \"lo0\" interface\n            // in a separate thread\n            Thread receiveThread = new Thread(() => {\n                  NetPod.Sniff(\"lo0\", action);\n            });\n            receiveThread.Start();\n\n            NetPod.Send(pod);\n      }\n}\n\n\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n", "class Program \n{\n      static void Main() \n      {\n            Ethernet ethernet = new Ethernet();\n            IP ip = new IP(sourceIP: \"192.168.1.211\", destinationIP: \"192.168.1.211\");\n            TCP tcp = new TCP(sourcePort: 80, destinationPort: 80);\n\n            // Create a new NetPod and\n            // add the network layers using\n            // the composition operator (\"/\")\n            NetPod pod = new NetPod(ethernet / ip / tcp);\n\n            // Show the NetPod structure\n            NetPod.ShowStructure(pod);\n\n            Action<NetPod> action = (NetPod receivedPod) => {\n                  Console.WriteLine(\"Received packet: \" + receivedPod);\n            };\n\n            // Start sniffing packets on the \"lo0\" interface\n            // in a separate thread\n            Thread receiveThread = new Thread(() => {\n                  NetPod.Sniff(\"lo0\", action);\n            });\n            receiveThread.Start();\n\n            NetPod.Send(pod);\n      }\n}\n\n\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
{"filename": "examples/packets.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System;\nusing System.Net.Sockets;\nusing System.Text;\n\n// Include the ProtoIP namespace\nusing ProtoIP;\n\nclass Program {\n      static void Main(string[] args) {\n            // Create a new packet\n            Packet packet = new Packet(Packet.Type.BYTES);\n            packet.SetData(\"Hello World!\");\n\n            // Serialize the packet\n            byte[] serializedPacket = packet.Serialize();\n\n            // Connect to the server\n            TcpClient client = new TcpClient(\"1.1.1.1\", 1234);\n            NetworkStream stream = client.GetStream();\n\n            // Send the packet over the network\n            stream.Write(serializedPacket, 0, serializedPacket.Length);            \n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n", "using ProtoIP;\n\nclass Program {\n      static void Main(string[] args) {\n            // Create a new packet\n            Packet packet = new Packet(Packet.Type.BYTES);\n            packet.SetData(\"Hello World!\");\n\n            // Serialize the packet\n            byte[] serializedPacket = packet.Serialize();\n\n            // Connect to the server\n            TcpClient client = new TcpClient(\"1.1.1.1\", 1234);\n            NetworkStream stream = client.GetStream();\n\n            // Send the packet over the network\n            stream.Write(serializedPacket, 0, serializedPacket.Length);            \n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
{"filename": "examples/transmission.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System;\nusing System.Net.Sockets;\nusing System.Text;\n\n// Include the ProtoIP namespace\nusing ProtoIP;\n\nclass Program {\n      static void Main(string[] args) {\n            // Connect to the server\n            TcpClient client = new TcpClient(\"1.1.1.1\", 1234);\n            NetworkStream stream = client.GetStream();\n\n            // Create a new Stream object\n            ProtoStream _protoStream = new ProtoStream(stream);\n\n            // Transmit a string over the network\n            _protoStream.Transmit(\"Hello World!\");\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.", "using ProtoIP;\n\nclass Program {\n      static void Main(string[] args) {\n            // Connect to the server\n            TcpClient client = new TcpClient(\"1.1.1.1\", 1234);\n            NetworkStream stream = client.GetStream();\n\n            // Create a new Stream object\n            ProtoStream _protoStream = new ProtoStream(stream);\n\n            // Transmit a string over the network\n            _protoStream.Transmit(\"Hello World!\");\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE."]}
{"filename": "examples/complexserver.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System;\nusing System.Net.Sockets;\nusing System.Text;\n\n// Include the ProtoIP namespace\nusing ProtoIP;\n\nclass ComplexServer : ProtoServer\n{\n      // Once the user makes a request, we can build the packet from the protoStream\n      // and respond accordingly", "using ProtoIP;\n\nclass ComplexServer : ProtoServer\n{\n      // Once the user makes a request, we can build the packet from the protoStream\n      // and respond accordingly\n      public override void OnRequest(int userID)\n      {\n            // Get the data from the ProtoStream and deserialize the packet\n            byte[] data = _protoStreamArrayClients[userID].GetDataAs<byte[]>();\n            Packet receivedPacket = Packet.Deserialize(data);\n\n            // Respond to PING packets", "            if (receivedPacket._GetType() == Packet.Type.PING)\n            {\n                  Packet packet = new Packet(Packet.Type.PONG);\n                  Send(packet.Serialize(), userID);\n            }\n      }\n}\n\nclass Program \n{\n      const int PORT = 1234;\n\n      static void Main()\n      {\n            // Create the server and start it\n            ComplexServer server = new ComplexServer(PORT);\n            server.Start();\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.", "class Program \n{\n      const int PORT = 1234;\n\n      static void Main()\n      {\n            // Create the server and start it\n            ComplexServer server = new ComplexServer(PORT);\n            server.Start();\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE."]}
{"filename": "examples/complexclient.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System;\nusing System.Net.Sockets;\nusing System.Text;\n\n// Include the ProtoIP namespace\nusing ProtoIP;\n\nclass ComplexClient : ProtoClient \n{\n      // We can override the OnConnect() method to describe our Client logic\n      // In this example, we are printing out the message we get back from the\n      // remote host.", "using ProtoIP;\n\nclass ComplexClient : ProtoClient \n{\n      // We can override the OnConnect() method to describe our Client logic\n      // In this example, we are printing out the message we get back from the\n      // remote host.\n      public override void OnReceive() \n      {\n            string data = _protoStream.GetDataAs<string>();\n            Console.WriteLine(data);\n      }\n}\n", "class Program \n{\n      static void Main() \n      {\n            // Create a new ComplexClient object and connect to the server\n            ComplexClient client = new ComplexClient();\n            client.Connect(\"1.1.1.1\", 1234);\n\n            // Send data to the server\n            client.Send(\"Hello World!\");\n\n            // Receive the response\n            // The OnReceive() method will be called\n            client.Receive();\n\n            // Disconnect from the server\n            client.Disconnect();\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE."]}
{"filename": "examples/client-server.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading;\n\nusing ProtoIP;\n\nclass ComplexClient : ProtoClient\n{\n      // We can override the OnSend() method to describe our Client logic\n      // In this example, we are printing out a message when the server responds", "using ProtoIP;\n\nclass ComplexClient : ProtoClient\n{\n      // We can override the OnSend() method to describe our Client logic\n      // In this example, we are printing out a message when the server responds\n      public override void OnReceive() \n      {\n            Packet receivedPacket = AssembleReceivedDataIntoPacket();\n\n            // We can check the type of the packet and act accordingly", "            if (receivedPacket._GetType() == (int)Packet.Type.PONG)\n            {\n                  Console.WriteLine(\"CLIENT: Received PONG packet!\");\n            }\n      }\n}\n\nclass ComplexServer : ProtoServer\n{\n      // We can override the OnRequest() method to describe our Server logic\n      // Once the server receives a request, it will call this method", "      public override void OnRequest(int userID)\n      {\n            Packet receivedPacket = AssembleReceivedDataIntoPacket(userID);\n\n            // We can check the type of the packet and act accordingly\n            if (receivedPacket._GetType() == (int)Packet.Type.PING)\n            {\n                  Console.WriteLine(\"SERVER: Received PING packet, sending PONG!\");\n                  Packet packet = new Packet(Packet.Type.PONG);\n                  Send(Packet.Serialize(packet), userID);\n            }\n      }\n}\n", "class Program\n{\n      static void Main()\n      {\n            int PORT = ProtoIP.Common.Network.GetRandomUnusedPort();\n\n            // Create the server and start it\n            ComplexServer server = new ComplexServer();\n            Thread serverThread = new Thread(() => server.Start(PORT));\n            serverThread.Start();\n\n            // Create a new ComplexClient object and connect to the server\n            ComplexClient client = new ComplexClient();\n            client.Connect(\"127.0.0.1\", PORT);\n\n            // Serialize the packet and send it\n            Packet packet = new Packet(Packet.Type.PING);\n            client.Send(Packet.Serialize(packet));\n\n            // Receive the response from the server\n            client.Receive();\n\n            // Disconnect from the server\n            client.Disconnect();\n\n            // Stop the server\n            server.Stop();\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
{"filename": "src/util.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System;\nusing System.IO;\nusing System.IO.Compression;\n\nnamespace ProtoIP\n{\n      namespace Util", "{\n      namespace Util\n      {\n            // Interface for interacting with the file system\n            public class FileSystem\n            {\n                  // File system basic utilities\n                  public static bool Exists(string path) { return File.Exists(path) || Directory.Exists(path); }\n                  public static bool IsFile(string path) { return File.Exists(path); }\n                  public static bool IsDirectory(string path) { return Directory.Exists(path); }\n                  public static void CreateFile(string path) { File.Create(path); }", "                  public static bool IsFile(string path) { return File.Exists(path); }\n                  public static bool IsDirectory(string path) { return Directory.Exists(path); }\n                  public static void CreateFile(string path) { File.Create(path); }\n                  public static void CreateDirectory(string path) { Directory.CreateDirectory(path); }\n\n                  // Delete a file or directory\n                  public static void Delete(string path)\n                  {\n                        if (IsFile(path))\n                        {\n                              File.Delete(path);\n                        }", "                        if (IsFile(path))\n                        {\n                              File.Delete(path);\n                        }\n                        else if (IsDirectory(path))\n                        {\n                              Directory.Delete(path);\n                        }\n                  }\n\n                  // Copy a file or directory", "                  public static void Copy(string source, string destination)\n                  {\n                        if (IsFile(source))\n                        {\n                              File.Copy(source, destination);\n                        }\n                        else if (IsDirectory(source))\n                        {\n                              //Directory.Copy(source, destination);\n                        }\n                  }\n\n                  // Move a file or directory", "                  public static void Move(string source, string destination)\n                  {\n                        if (IsFile(source))\n                        {\n                              File.Move(source, destination);\n                        }\n                        else if (IsDirectory(source))\n                        {\n                              Directory.Move(source, destination);\n                        }\n                  }\n\n                  // Rename a file or directory", "                  public static void Rename(string path, string name)\n                  {\n                        if (IsFile(path))\n                        {\n                              File.Move(path, Path.Combine(Path.GetDirectoryName(path), name));\n                        }\n                        else if (IsDirectory(path))\n                        {\n                              Directory.Move(path, Path.Combine(Path.GetDirectoryName(path), name));\n                        }\n                  }\n            }\n\n            // Interface for compressing and decompressing data", "            public class Compression\n            {\n                  // Compress a byte array using GZip and return the compressed data\n                  public static byte[] Compress(byte[] data)\n                  {\n                        using (var compressedStream = new MemoryStream())\n                        {\n                              using (var zipStream = new GZipStream(compressedStream, CompressionMode.Compress))\n                              {\n                                    zipStream.Write(data, 0, data.Length);\n                              }\n\n                              return compressedStream.ToArray();\n                        }\n                  }\n\n                  // Decompress a byte array using GZip and return the decompressed data", "                  public static byte[] Decompress(byte[] data)\n                  {\n                        using (var compressedStream = new MemoryStream(data))\n                        {\n                              using (var zipStream = new GZipStream(compressedStream, CompressionMode.Decompress))\n                              {\n                                    using (var resultStream = new MemoryStream())\n                                    {\n                                          zipStream.CopyTo(resultStream);\n                                          return resultStream.ToArray();\n                                    }\n                              }\n                        }\n                  }\n\n                  // Compress a file using GZip and save it to a destination", "                  public static void CompressFile(string filePath, string destination)\n                  {\n                        File.WriteAllBytes(destination, Compress(File.ReadAllBytes(filePath)));\n                  }\n\n                  // Decompress a file using GZip and save it to a destination\n                  public static void DecompressFile(string compressedFilePath, string destination)\n                  {\n                        File.WriteAllBytes(destination, Decompress(File.ReadAllBytes(compressedFilePath)));\n                  }\n            }\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
{"filename": "src/client.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System.Text;\nusing System;\n\nusing ProtoIP;\nusing ProtoIP.Common;\n\nnamespace ProtoIP", "\nnamespace ProtoIP\n{\n      public class ProtoClient\n      {\n            protected Common.Network.Connection _serverConnection;\n            protected ProtoStream _protoStream;\n\n            public ProtoClient() {}\n\n            // Connect to the remote host and create a new ProtoStream object.\n            //\n            // Call the OnConnect() method if the connection was successful, \n            // otherwise call OnConnectFailed().", "            public void Connect(string serverIP, int serverPort)\n            {\n                  _serverConnection = Common.Network.Connect(serverIP, serverPort);\n                  _protoStream = new ProtoStream(_serverConnection.stream);\n\n                  OnConnect();\n            }\n\n            // Disconnect from the remote host and destroy the ProtoStream object.\n            //\n            // Call the OnDisconnect() method.", "            public void Disconnect()\n            {\n                  Common.Network.Disconnect(_serverConnection);\n\n                  OnDisconnect();\n            }\n\n            // Send data to a remote host using a ProtoStream.\n            //\n            // Call the OnSend() method.\n            public void Send(byte[] data)\n            {\n                  _protoStream.Transmit(data);\n                  OnSend();\n            }\n\n            // Send overload for sending string data", "            public void Send(byte[] data)\n            {\n                  _protoStream.Transmit(data);\n                  OnSend();\n            }\n\n            // Send overload for sending string data\n            public void Send(string data)\n            {\n                  _protoStream.Transmit(data);\n                  OnSend();\n            }\n\n            // Receive data from a remote host using a ProtoStream.\n            //\n            // Call the OnReceive() method.", "            public void Receive(bool shouldCallOnReceive)\n            {\n                  _protoStream.Receive();\n                  if (shouldCallOnReceive)\n                        OnReceive();\n            }\n\n            // Assembles a packet from the recived data and returns the packet.\n            public Packet AssembleReceivedDataIntoPacket()\n            {\n                  byte[] data = _protoStream.GetDataAs<byte[]>();\n                  Packet assembledPacket = Packet.Deserialize(data);\n                  return assembledPacket;\n            }\n\n            // Virtual functions", "            public Packet AssembleReceivedDataIntoPacket()\n            {\n                  byte[] data = _protoStream.GetDataAs<byte[]>();\n                  Packet assembledPacket = Packet.Deserialize(data);\n                  return assembledPacket;\n            }\n\n            // Virtual functions\n            public virtual void OnConnect() { }\n            public virtual void OnDisconnect() { }\n            public virtual void OnSend() { }", "            public virtual void OnConnect() { }\n            public virtual void OnDisconnect() { }\n            public virtual void OnSend() { }\n            public virtual void OnReceive() { }\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
{"filename": "src/server.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System.Text;\nusing System.Threading;\nusing System.Net.Sockets;\nusing System.Collections.Generic;\nusing System;\n\nusing ProtoIP;", "\nusing ProtoIP;\nusing ProtoIP.Common;\n\nnamespace ProtoIP\n{\n      public class ProtoServer\n      {\n            public List<ProtoStream> _clients { get; private set; }\n            public TcpListener _listener { get; private set; }\n            public bool _isRunning { get; private set; }", "            public TcpListener _listener { get; private set; }\n            public bool _isRunning { get; private set; }\n            public string _LastError { get; private set; }\n\n            public ProtoServer() \n            { \n                  _clients = new List<ProtoStream>(); \n                  _isRunning = false;\n                  _LastError = \"\";\n            }\n\n            // Send data to the client and call the OnResponse() method", "            public void Send(byte[] data, int userID)\n            {\n                  _clients[userID].Transmit(data);\n                  OnResponse(userID);\n            }\n\n            // Send data to all the connected clients\n            public void SendBroadcast(byte[] data)\n            {\n                  foreach (ProtoStream client in _clients)\n                  {\n                        client.Transmit(data);\n                        OnResponse(_clients.IndexOf(client));\n                  }\n            }\n\n            // Receive data from the client and call the OnRequest() method", "                  foreach (ProtoStream client in _clients)\n                  {\n                        client.Transmit(data);\n                        OnResponse(_clients.IndexOf(client));\n                  }\n            }\n\n            // Receive data from the client and call the OnRequest() method\n            public void Receive(int userID)\n            {\n                  _clients[userID].Receive();\n                  OnRequest(userID);\n            }\n\n            // Starts the main server loop", "            public void Receive(int userID)\n            {\n                  _clients[userID].Receive();\n                  OnRequest(userID);\n            }\n\n            // Starts the main server loop\n            public void Start(int port)\n            {\n                  StartListening(port);\n                  _isRunning = true;\n", "                  while (_isRunning)\n                  {\n                        AcceptConnections();\n                  }\n            }\n\n            // Stops the main server loop\n            public void Stop()\n            {\n                  _listener.Stop();\n                  _isRunning = false;\n            }\n\n            // Assembles a packet from the received data and returns it.", "            public Packet AssembleReceivedDataIntoPacket(int userID)\n            {\n                  byte[] data = _clients[userID].GetDataAs<byte[]>();\n                  Packet receivedPacket = Packet.Deserialize(data);\n                  return receivedPacket; \n            }\n\n            private void HandleConnect(int userID)\n            {\n                  OnUserConnect(userID);\n                  while (_clients[userID].IsConnected())\n                  {\n                        Receive(userID);\n                  }\n                  OnUserDisconnect(userID);\n            }\n\n            // Virtual functions", "                  while (_clients[userID].IsConnected())\n                  {\n                        Receive(userID);\n                  }\n                  OnUserDisconnect(userID);\n            }\n\n            // Virtual functions\n            public virtual void OnUserConnect(int userID) {}\n            public virtual void OnUserDisconnect(int userID) { }\n            public virtual void OnResponse(int userID) { }", "            public virtual void OnUserConnect(int userID) {}\n            public virtual void OnUserDisconnect(int userID) { }\n            public virtual void OnResponse(int userID) { }\n            public virtual void OnRequest(int userID) { }\n\n            // Creates a TCP listener and starts listening for connections\n            private void StartListening(int port)\n            {\n                  _listener = new TcpListener(port);\n                  _listener.Start();\n            }\n\n            // Accepts new connections and adds them to the clients List\n            // Calls the OnUserConnect() method in a separate thread on every connect event", "            private void AcceptConnections()\n            {\n                  try\n                  {\n                        TcpClient client = _listener.AcceptTcpClient();\n                        NetworkStream stream = client.GetStream();\n                        ProtoStream protoStream = new ProtoStream(stream);\n\n                        _clients.Add(protoStream);\n\n                        Thread thread = new Thread(() => HandleConnect(_clients.Count - 1));\n                        thread.Start();\n                  }", "                  catch (Exception e)\n                  {\n                        _LastError = e.Message;\n                  }\n            }\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
{"filename": "src/udp.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System;\nusing System.Net;\n\nnamespace ProtoIP\n{\n      // Provides an interface for creating and manipulating UDP packets\n      // to be used with the NetPods.\n      public class UDP \n      {", "      // Provides an interface for creating and manipulating UDP packets\n      // to be used with the NetPods.\n      public class UDP \n      {\n            public const int UDP_HEADER_LENGTH = 8;\n\n            // HEADER\n            public ushort _sourcePort      { get; set; }\n            public ushort _destinationPort { get; set; }\n            public ushort _length          { get; set; }\n            public ushort _checksum        { get; set; }\n\n            // PAYLOAD\n            public byte[] _payload   { get; set; }\n\n            // Serializes the UDP packet into a byte array.\n            public byte[] Serialize()\n            {\n                  byte[] serialized = new byte[_length];\n                  Array.Copy(BitConverter.GetBytes(_sourcePort), 0, serialized, 0, 2);\n                  Array.Copy(BitConverter.GetBytes(_destinationPort), 0, serialized, 2, 2);\n                  Array.Copy(BitConverter.GetBytes(_length), 0, serialized, 4, 2);\n                  Array.Copy(BitConverter.GetBytes(_checksum), 0, serialized, 6, 2);\n                  Array.Copy(_payload, 0, serialized, 8, _payload.Length);\n                  return serialized;\n            }\n\n            // Deserializes a byte array into a UDP packet.", "            public ushort _destinationPort { get; set; }\n            public ushort _length          { get; set; }\n            public ushort _checksum        { get; set; }\n\n            // PAYLOAD\n            public byte[] _payload   { get; set; }\n\n            // Serializes the UDP packet into a byte array.\n            public byte[] Serialize()\n            {\n                  byte[] serialized = new byte[_length];\n                  Array.Copy(BitConverter.GetBytes(_sourcePort), 0, serialized, 0, 2);\n                  Array.Copy(BitConverter.GetBytes(_destinationPort), 0, serialized, 2, 2);\n                  Array.Copy(BitConverter.GetBytes(_length), 0, serialized, 4, 2);\n                  Array.Copy(BitConverter.GetBytes(_checksum), 0, serialized, 6, 2);\n                  Array.Copy(_payload, 0, serialized, 8, _payload.Length);\n                  return serialized;\n            }\n\n            // Deserializes a byte array into a UDP packet.", "            public static UDP Deserialize(byte[] serialized)\n            {\n                  if (serialized.Length < UDP_HEADER_LENGTH) { return null; }\n\n                  UDP udp = new UDP();\n                  udp._sourcePort = BitConverter.ToUInt16(serialized, 0);\n                  udp._destinationPort = BitConverter.ToUInt16(serialized, 2);\n                  udp._length = BitConverter.ToUInt16(serialized, 4);\n                  udp._checksum = BitConverter.ToUInt16(serialized, 6);\n                  udp._payload = new byte[udp._length - 8];\n                  Array.Copy(serialized, 8, udp._payload, 0, udp._length - 8);\n                  return udp;\n            }\n             ", "            public override string ToString()\n            {\n                  return $\"### [UDP] ###\\n\" +\n                         $\"Source Port: {_sourcePort}\\n\" +\n                         $\"Destination Port: {_destinationPort}\\n\" +\n                         $\"Length: {_length}\\n\" +\n                         $\"Checksum: {_checksum}\\n\" +\n                         $\"Payload: {_payload}\\n\";\n            } \n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
{"filename": "src/common.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System.Net.Sockets;\nusing System.Net;\n\nnamespace ProtoIP\n{\n      namespace Common \n      {", "      namespace Common \n      {\n            // Error definitions\n            public class Error {\n                  public const string INVALID_PACKET = \"Invalid packet\";\n                  public const string INVALID_PACKET_TYPE = \"Invalid packet type\";\n                  public const string INVALID_PACKET_ID = \"Invalid packet id\";\n                  public const string INVALID_PACKET_DATA_SIZE = \"Invalid packet data size\";\n                  public const string INVALID_PACKET_DATA = \"Invalid packet data\";\n                  public const string INVALID_PACKET_HEADER = \"Invalid packet header\";\n                  public const string INVALID_PACKET_HEADER_SIZE = \"Invalid packet header size\";", "                  public const string INVALID_PACKET_DATA = \"Invalid packet data\";\n                  public const string INVALID_PACKET_HEADER = \"Invalid packet header\";\n                  public const string INVALID_PACKET_HEADER_SIZE = \"Invalid packet header size\";\n                  public const string INVALID_PACKET_BUFFER = \"Invalid packet buffer\";\n                  public const string INVALID_PACKET_BUFFER_SIZE = \"Invalid packet buffer size\";\n\n                  public enum Code {\n                        OK,\n                        ERROR\n                  }\n            }\n", "            public class Network {\n                  public const int DEFAULT_BUFFER_SIZE = 1024;\n                  public const int MAX_TRIES = 3;\n                  public const int MAX_PACKETS = 1024;\n\n                  // Network connection object\n                  public struct Connection {\n                        public TcpClient client;\n                        public NetworkStream stream;\n                  }\n\n                  // Connect to a host and return a connection object", "                        public NetworkStream stream;\n                  }\n\n                  // Connect to a host and return a connection object\n                  public static Connection Connect(string host, int port) {\n                        Connection connection = new Connection();\n\n                        connection.client = new TcpClient(host, port);\n                        connection.stream = connection.client.GetStream();\n\n                        return connection;\n                  }\n\n                  // Disconnect from a host", "                  public static void Disconnect(Connection connection) {\n                        connection.stream.Close();\n                        connection.client.Close();\n                  }\n\n                  // Returns a random unused TCP port\n                  public static int GetRandomUnusedPort()\n                  {\n                        var listener = new TcpListener(IPAddress.Loopback, 0);\n                        listener.Start();\n\n                        var port = ((IPEndPoint)listener.LocalEndpoint).Port;\n                        listener.Stop();\n\n                        return port;\n                  }\n            }\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
{"filename": "src/p2p.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System;\n\nnamespace ProtoIP\n{\n    class Node\n    {\n        protected ProtoServer _server;\n        protected ProtoClient _client;\n\n        // Constructors\n        public Node()\n        {\n            \n        }\n    }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n", "        protected ProtoServer _server;\n        protected ProtoClient _client;\n\n        // Constructors\n        public Node()\n        {\n            \n        }\n    }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
{"filename": "src/packet.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System.Text;\nusing System;\n\nusing ProtoIP.Common;\n\nnamespace ProtoIP\n{\n      public class Packet\n      {\n            // Default packet types for the ProtoIP library", "namespace ProtoIP\n{\n      public class Packet\n      {\n            // Default packet types for the ProtoIP library\n            public enum Type\n            {\n                  ACK = 1,\n                  HANDSHAKE_REQ,\n                  HANDSHAKE_RES,\n                  PUBLIC_KEY,\n                  AES_KEY,\n                  BYTES,\n                  REPEAT,\n                  EOT,\n                  SOT,\n                  FTS,\n                  FTE,\n                  FILE_NAME,\n                  FILE_SIZE,\n                  PING,\n                  PONG,\n                  CHECKSUM,\n                  RELAY,\n                  BROADCAST\n            }\n", "            public const int HEADER_SIZE = 12;\n            const int BUFFER_SIZE = Common.Network.DEFAULT_BUFFER_SIZE;\n\n            /* MEMBER VARIABLES */\n            private int _type;\n            private int _id;\n            private int _dataSize;\n            \n            private byte[] _data;\n\n            /* CONSTRUCTORS */\n            public Packet() { }\n\n            public Packet(int type, int id, int dataSize, byte[] data)\n            {\n                  this._type = type;\n                  this._id = id;\n                  this._dataSize = dataSize;\n                  this._data = data;\n            }\n\n            public Packet(int type, int id, int dataSize, string data)\n            {\n                  this._type = type;\n                  this._id = id;\n                  this._dataSize = dataSize;\n                  this._data = Encoding.ASCII.GetBytes(data);\n            }\n\n            public Packet(Type type, int id, int dataSize, byte[] data)\n            {\n                  this._type = (int)type;\n                  this._id = id;\n                  this._dataSize = dataSize;\n                  this._data = data;\n            }\n\n            public Packet(int type)\n            {\n                  this._type = type;\n                  this._id = 0;\n                  this._dataSize = 0;\n                  this._data = new byte[0];\n            }\n\n            public Packet(Type type)\n            {\n                  this._type = (int)type;\n                  this._id = 0;\n                  this._dataSize = 0;\n                  this._data = new byte[0];\n            }\n\n            public Packet(string stringData)\n            {\n                  this._type = (int)Type.BYTES;\n                  this._id = 0;\n                  this._dataSize = stringData.Length;\n                  this._data = Encoding.ASCII.GetBytes(stringData);\n            }\n\n            static public byte[] Serialize(Packet packet)\n            {\n                  byte[] buffer = new byte[BUFFER_SIZE];\n\n                  // Packet Header\n                  byte[] type = BitConverter.GetBytes(packet._type);\n                  byte[] id = BitConverter.GetBytes(packet._id);\n                  byte[] dataSize = BitConverter.GetBytes(packet._dataSize);\n\n                  // Packet Payload\n                  byte[] data = packet._data;\n\n                  // Copy to buffer\n                  Buffer.BlockCopy(type, 0, buffer, 0, type.Length);\n                  Buffer.BlockCopy(id, 0, buffer, type.Length, id.Length);\n                  Buffer.BlockCopy(dataSize, 0, buffer, type.Length + id.Length, dataSize.Length);\n                  Buffer.BlockCopy(data, 0, buffer, type.Length + id.Length + dataSize.Length, data.Length);\n\n                  // Add padding if needed", "                  if (buffer.Length < BUFFER_SIZE)\n                  {\n                        byte[] padding = new byte[BUFFER_SIZE - buffer.Length];\n                        Buffer.BlockCopy(padding, 0, buffer, buffer.Length, padding.Length);\n                  }\n\n                  return buffer;\n            }\n\n            static public Packet Deserialize(byte[] buffer)\n            {\n                  Packet packet = new Packet();\n\n                  // Packet Header\n                  byte[] type = new byte[4];\n                  byte[] id = new byte[4];\n                  byte[] dataSize = new byte[4];\n\n                  // Packet Payload\n                  byte[] data = new byte[BUFFER_SIZE - 12];\n\n                  // Copy from buffer\n                  Buffer.BlockCopy(buffer, 0, type, 0, type.Length);\n                  Buffer.BlockCopy(buffer, type.Length, id, 0, id.Length);\n                  Buffer.BlockCopy(buffer, type.Length + id.Length, dataSize, 0, dataSize.Length);\n                  Buffer.BlockCopy(buffer, type.Length + id.Length + dataSize.Length, data, 0, data.Length);\n\n                  // Set packet\n                  packet._type = BitConverter.ToInt32(type, 0);\n                  packet._id = BitConverter.ToInt32(id, 0);\n                  packet._dataSize = BitConverter.ToInt32(dataSize, 0);\n                  packet._data = data;\n\n                  return packet;\n            }\n\n            // Shows the packet in the console", "            static public Packet Deserialize(byte[] buffer)\n            {\n                  Packet packet = new Packet();\n\n                  // Packet Header\n                  byte[] type = new byte[4];\n                  byte[] id = new byte[4];\n                  byte[] dataSize = new byte[4];\n\n                  // Packet Payload\n                  byte[] data = new byte[BUFFER_SIZE - 12];\n\n                  // Copy from buffer\n                  Buffer.BlockCopy(buffer, 0, type, 0, type.Length);\n                  Buffer.BlockCopy(buffer, type.Length, id, 0, id.Length);\n                  Buffer.BlockCopy(buffer, type.Length + id.Length, dataSize, 0, dataSize.Length);\n                  Buffer.BlockCopy(buffer, type.Length + id.Length + dataSize.Length, data, 0, data.Length);\n\n                  // Set packet\n                  packet._type = BitConverter.ToInt32(type, 0);\n                  packet._id = BitConverter.ToInt32(id, 0);\n                  packet._dataSize = BitConverter.ToInt32(dataSize, 0);\n                  packet._data = data;\n\n                  return packet;\n            }\n\n            // Shows the packet in the console", "            static public void ByteDump(Packet packet)\n            {\n                  byte[] buffer = Serialize(packet);\n                  int type = BitConverter.ToInt32(buffer, 0);\n                  int id = BitConverter.ToInt32(buffer, 4);\n                  int dataSize = BitConverter.ToInt32(buffer, 8);\n\n                  // Show the header of the packet\n                  Console.WriteLine(\"\u250cHEADERS\");\n\n                  // Show the type\n                  Console.Write(\"\u251cType: \");", "                  for (int i = 0; i < 4; i++) { Console.Write(buffer[i].ToString(\"X2\") + \" \"); }\n                  Console.Write(\"(\" + type + \" - ProtoIP Packet Mapping - \" + (Type)type + \")\");\n                  Console.WriteLine();\n\n                  // Show the ID\n                  Console.Write(\"\u251cID: \");\n                  for (int i = 4; i < 8; i++) { Console.Write(buffer[i].ToString(\"X2\") + \" \"); }\n                  Console.Write(\"(\" + id + \")\");\n                  Console.WriteLine();\n\n                  // Show the data size\n                  Console.Write(\"\u251cData Size: \");", "                  for (int i = 8; i < 12; i++) { Console.Write(buffer[i].ToString(\"X2\") + \" \"); }\n                  Console.WriteLine(\"(\" + dataSize + \")\");\n                  Console.WriteLine(\"\u2502\");\n\n\n                  // Show the body of the packet\n                  Console.WriteLine(\"\u251cPAYLOAD: \");\n                  Console.Write(\"\u2514Data: \");\n\n                  if (dataSize == 0) \n                  { \n                        Console.WriteLine(\"No payload\"); \n                  }\n                  else\n                  {", "                  if (dataSize == 0) \n                  { \n                        Console.WriteLine(\"No payload\"); \n                  }\n                  else\n                  {\n                        for (int i = 0; i < dataSize; i++)\n                        {\n                              if (i % 16 == 0 && i != 0) { Console.WriteLine(); Console.Write(\"   \"); }\n                              Console.Write(buffer[i + 12].ToString(\"X2\") + \" \");\n                        }\n\n\n                        // Show in string format\n                        Console.Write(\"('\");", "                              if (i % 16 == 0 && i != 0) { Console.WriteLine(); Console.Write(\"   \"); }\n                              Console.Write(buffer[i + 12].ToString(\"X2\") + \" \");\n                        }\n\n\n                        // Show in string format\n                        Console.Write(\"('\");\n                        for (int i = 0; i < dataSize; i++)\n                        {\n                              Console.Write((char)buffer[i + 12]);\n                        }\n                        Console.Write(\"') \");\n                        Console.Write(\"( + \" + (BUFFER_SIZE - dataSize) + \" bytes of padding)\");\n                        Console.WriteLine();\n                  }\n            }\n\n            /* GETTERS & SETTERS */", "            public int _GetType() { return this._type; }\n            public int _GetId() { return this._id; }\n            public int _GetDataSize() { return this._dataSize; }\n\n            // Returns the payload of the packet as the given data type\n            public T GetDataAs<T>()\n            {\n                  byte[] data;\n\n                  switch (typeof(T).Name)\n                  {\n                        case \"String\":\n                              data = new byte[this._dataSize];\n                              Buffer.BlockCopy(this._data, 0, data, 0, this._dataSize);\n                              return (T)Convert.ChangeType(Encoding.ASCII.GetString(data), typeof(T));\n                        case \"Int32\":\n                              data = new byte[4];\n                              Buffer.BlockCopy(this._data, 0, data, 0, 4);\n                              return (T)Convert.ChangeType(BitConverter.ToInt32(data, 0), typeof(T));\n                        case \"Int64\":\n                              data = new byte[8];\n                              Buffer.BlockCopy(this._data, 0, data, 0, 8);\n                              return (T)Convert.ChangeType(BitConverter.ToInt64(data, 0), typeof(T));\n                        case \"UInt32\":\n                              data = new byte[4];\n                              Buffer.BlockCopy(this._data, 0, data, 0, 4);\n                              return (T)Convert.ChangeType(BitConverter.ToUInt32(data, 0), typeof(T));\n                        case \"UInt64\":\n                              data = new byte[8];\n                              Buffer.BlockCopy(this._data, 0, data, 0, 8);\n                              return (T)Convert.ChangeType(BitConverter.ToUInt64(data, 0), typeof(T));\n                        case \"Byte[]\":\n                              data = new byte[this._dataSize];\n                              Buffer.BlockCopy(this._data, 0, data, 0, this._dataSize);\n                              return (T)Convert.ChangeType(data, typeof(T));\n                        default:\n                              return (T)Convert.ChangeType(this._data, typeof(T));\n                  }\n            }\n", "            public void _SetType(Type type) { this._type = (int)type; }\n            public void _SetId(int id) { this._id = id; }\n            public void _SetDataSize(int dataSize) { this._dataSize = dataSize; }\n            public void SetPayload(byte[] data) { this._data = data; this._dataSize = data.Length; }\n            public void SetPayload(string data) { this._data = Encoding.ASCII.GetBytes(data); this._dataSize = data.Length; }\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
{"filename": "src/pubsub.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace ProtoIP\n{\n      // Interface that defines the methods for Publishing, Subscribing and \n      // Unsubscribing to a channel.\n      public interface IMessageBroker\n      {\n            void Publish(string channel, object message);\n            void Subscribe(string channel, Action<object> callback);\n            void Unsubscribe(string channel, Action<object> callback);\n      }\n", "      // Interface that defines the methods for Publishing, Subscribing and \n      // Unsubscribing to a channel.\n      public interface IMessageBroker\n      {\n            void Publish(string channel, object message);\n            void Subscribe(string channel, Action<object> callback);\n            void Unsubscribe(string channel, Action<object> callback);\n      }\n\n      // Publisher class that implements the Publish method.\n      public class Publisher\n      {", "      // Publisher class that implements the Publish method.\n      public class Publisher\n      {\n            private readonly IMessageBroker _messageBroker;\n\n            public Publisher(IMessageBroker messageBroker)\n            {\n                  _messageBroker = messageBroker;\n            }\n\n            public void Publish(string channel, object message)\n            {\n                  _messageBroker.Publish(channel, message);\n            }\n      }\n", "            public void Publish(string channel, object message)\n            {\n                  _messageBroker.Publish(channel, message);\n            }\n      }\n\n      // Subscriber class that implements the Subscribe and Unsubscribe methods.\n      public class Subscriber\n      {\n            private readonly IMessageBroker _messageBroker;\n\n            public Subscriber(IMessageBroker messageBroker)\n            {\n                  _messageBroker = messageBroker;\n            }\n", "            private readonly IMessageBroker _messageBroker;\n\n            public Subscriber(IMessageBroker messageBroker)\n            {\n                  _messageBroker = messageBroker;\n            }\n\n            public void Subscribe(string channel, Action<object> callback)\n            {\n                  _messageBroker.Subscribe(channel, callback);\n            }\n", "            public void Unsubscribe(string channel, Action<object> callback)\n            {\n                  _messageBroker.Unsubscribe(channel, callback);\n            }\n      }\n\n      // Implementation of the IMessageBroker interface that manages\n      // the subscriptions and publishes messages to the subscribers.\n      public class PubSub : IMessageBroker\n      {\n            private readonly Dictionary<string, List<Action<object>>> _subscriptions = new Dictionary<string, List<Action<object>>>();\n\n            // Publish a message to a channel", "      public class PubSub : IMessageBroker\n      {\n            private readonly Dictionary<string, List<Action<object>>> _subscriptions = new Dictionary<string, List<Action<object>>>();\n\n            // Publish a message to a channel\n            public void Publish(string channel, object message)\n            {\n                  if (_subscriptions.ContainsKey(channel))\n                  {\n                        foreach (var callback in _subscriptions[channel])\n                        {\n                              callback(message);\n                        }\n                  }\n            }\n\n            // Subscribe to a channel", "                        foreach (var callback in _subscriptions[channel])\n                        {\n                              callback(message);\n                        }\n                  }\n            }\n\n            // Subscribe to a channel\n            public void Subscribe(string channel, Action<object> callback)\n            {\n                  if (!_subscriptions.ContainsKey(channel))\n                  {\n                        _subscriptions[channel] = new List<Action<object>>();\n                  }\n\n                  _subscriptions[channel].Add(callback);\n            }\n\n            // Unsubscribe from a channel", "            public void Subscribe(string channel, Action<object> callback)\n            {\n                  if (!_subscriptions.ContainsKey(channel))\n                  {\n                        _subscriptions[channel] = new List<Action<object>>();\n                  }\n\n                  _subscriptions[channel].Add(callback);\n            }\n\n            // Unsubscribe from a channel", "            public void Unsubscribe(string channel, Action<object> callback)\n            {\n                  if (_subscriptions.ContainsKey(channel))\n                  {\n                        _subscriptions[channel].Remove(callback);\n                  }\n            }\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE."]}
{"filename": "src/arp.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System;\n\nnamespace ProtoIP\n{\n      // Provides an interface for creating and manipulating ARP packets\n      // to be used with the NetPods.\n      public class ARP\n      {\n            // Hardware types for the transmission medium", "      public class ARP\n      {\n            // Hardware types for the transmission medium\n            public enum HardwareType : ushort\n            {\n                  Ethernet = 1,\n                  IEEE802Networks = 6,\n                  ARCNET = 7,\n                  FrameRelay = 15,\n                  ATM = 16,\n                  HDLC = 17,\n                  FibreChannel = 18,\n                  ATM2 = 19,\n                  SerialLine = 20\n            }\n\n            // Op codes for the ARP protocol", "            public enum Operation : ushort\n            {\n                  ARPRequest = 1,\n                  ARPReply = 2,\n                  RARPRequest = 3,\n                  RARPReply = 4,\n                  DRARPRequest = 5,\n                  DRARPReply = 6,\n                  DRARPError = 7,\n                  InARPRequest = 8,\n                  InARPReply = 9\n            }\n", "            public ushort _hardwareType { get; set; }\n            public ushort _protocolType { get; set; }\n            public byte _hardwareLength { get; set; }\n            public byte _protocolLength { get; set; }\n            public ushort _operation { get; set; }\n            public byte[] _senderHardwareAddress { get; set; }\n            public byte[] _senderProtocolAddress { get; set; }\n            public byte[] _targetHardwareAddress { get; set; }\n            public byte[] _targetProtocolAddress { get; set; }\n\n            /* CONSTRUCTORS */\n            public ARP() { }\n\n            public byte[] Serialize()\n            {\n                  byte[] serialized = new byte[28];\n                  Array.Copy(BitConverter.GetBytes(_hardwareType), 0, serialized, 0, 2);\n                  Array.Copy(BitConverter.GetBytes(_protocolType), 0, serialized, 2, 2);\n                  serialized[4] = _hardwareLength;\n                  serialized[5] = _protocolLength;\n                  Array.Copy(BitConverter.GetBytes(_operation), 0, serialized, 6, 2);\n                  Array.Copy(_senderHardwareAddress, 0, serialized, 8, 6);\n                  Array.Copy(_senderProtocolAddress, 0, serialized, 14, 4);\n                  Array.Copy(_targetHardwareAddress, 0, serialized, 18, 6);\n                  Array.Copy(_targetProtocolAddress, 0, serialized, 24, 4);\n                  return serialized;\n            }\n", "            public static ARP Deserialize(byte[] data)\n            {\n                  ARP arp = new ARP();\n                  arp._hardwareType = BitConverter.ToUInt16(data, 0);\n                  arp._protocolType = BitConverter.ToUInt16(data, 2);\n                  arp._hardwareLength = data[4];\n                  arp._protocolLength = data[5];\n                  arp._operation = BitConverter.ToUInt16(data, 6);\n                  arp._senderHardwareAddress = new byte[6];\n                  Array.Copy(data, 8, arp._senderHardwareAddress, 0, 6);\n                  arp._senderProtocolAddress = new byte[4];\n                  Array.Copy(data, 14, arp._senderProtocolAddress, 0, 4);\n                  arp._targetHardwareAddress = new byte[6];\n                  Array.Copy(data, 18, arp._targetHardwareAddress, 0, 6);\n                  arp._targetProtocolAddress = new byte[4];\n                  Array.Copy(data, 24, arp._targetProtocolAddress, 0, 4);\n                  return arp;\n            }\n", "            public override string ToString()\n            {\n                  return $\"### [ARP] ###\\n\" +\n                         $\"\\tHardware Type: {_hardwareType}\\n\" +\n                         $\"\\tProtocol Type: {_protocolType}\\n\" +\n                         $\"\\tHardware Length: {_hardwareLength}\\n\" +\n                         $\"\\tProtocol Length: {_protocolLength}\\n\" +\n                         $\"\\tOperation: {_operation}\\n\" +\n                         $\"\\tSender Hardware Address: {BitConverter.ToString(_senderHardwareAddress)}\\n\" +\n                         $\"\\tSender Protocol Address: {BitConverter.ToString(_senderProtocolAddress)}\\n\" +\n                         $\"\\tTarget Hardware Address: {BitConverter.ToString(_targetHardwareAddress)}\\n\" +\n                         $\"\\tTarget Protocol Address: {BitConverter.ToString(_targetProtocolAddress)}\\n\";\n            }\n\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
{"filename": "src/ip.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System;\nusing System.Net;\n\nnamespace ProtoIP\n{  \n      // Provides an interface for creating and manipulating IP packets\n      // to be used with the NetPods.\n      public class IP\n      {\n            // IP protocol packet types.", "      // Provides an interface for creating and manipulating IP packets\n      // to be used with the NetPods.\n      public class IP\n      {\n            // IP protocol packet types.\n            public enum IPProtocolPacketType\n            {\n                  ICMP = 1,\n                  TCP = 6,\n                  UDP = 17\n            }\n", "            public const int IP_HEADER_LENGTH = 20;\n            public const int IPV4 = 4;\n            public const int IPV6 = 6;\n\n            // Headers\n            public byte _version { get; set; }\n            public byte _headerLength { get; set; }\n            public byte _typeOfService { get; set; }\n            public ushort _totalLength { get; set; }\n            public ushort _identification { get; set; }\n            public ushort _flags { get; set; }", "            public ushort _totalLength { get; set; }\n            public ushort _identification { get; set; }\n            public ushort _flags { get; set; }\n            public ushort _fragmentOffset { get; set; }\n            public byte _timeToLive { get; set; }\n            public byte _protocol { get; set; }\n            public ushort _headerChecksum { get; set; }\n            public IPAddress _sourceAddress { get; set; }\n            public IPAddress _destinationAddress { get; set; }\n\n            // Payload\n            public byte[] _payload { get; set; }\n\n            /* CONSTRUCTORS */\n            public IP() { }\n\n            public IP(string sourceIP, string destinationIP)\n            {\n                  _version = IPV4;\n                  _headerLength = 5;\n                  _typeOfService = 0;\n                  _totalLength = IP_HEADER_LENGTH;\n                  _identification = 0;\n                  _flags = 0;\n                  _fragmentOffset = 0;\n                  _timeToLive = 64;\n                  _protocol = 0;\n                  _headerChecksum = 0;\n                  _sourceAddress = IPAddress.Parse(sourceIP);\n                  _destinationAddress = IPAddress.Parse(destinationIP);\n            }\n\n            // Serializes the packet and returns it as a byte Array\n            public byte[] Serialize()\n            {\n                  byte[] packet = new byte[IP_HEADER_LENGTH + _payload.Length];\n\n                  // Header\n                  packet[0] = (byte)((_version << 4) | _headerLength);\n                  packet[1] = _typeOfService;\n                  packet[2] = (byte)(_totalLength >> 8);\n                  packet[3] = (byte)(_totalLength & 0xFF);\n                  packet[4] = (byte)(_identification >> 8);\n                  packet[5] = (byte)(_identification & 0xFF);\n                  packet[6] = (byte)((_flags << 5) | (_fragmentOffset >> 8));\n                  packet[7] = (byte)(_fragmentOffset & 0xFF);\n                  packet[8] = _timeToLive;\n                  packet[9] = _protocol;\n                  packet[10] = (byte)(_headerChecksum >> 8);\n                  packet[11] = (byte)(_headerChecksum & 0xFF);\n\n                  byte[] sourceAddressBytes = _sourceAddress.GetAddressBytes();\n                  packet[12] = sourceAddressBytes[0];\n                  packet[13] = sourceAddressBytes[1];\n                  packet[14] = sourceAddressBytes[2];\n                  packet[15] = sourceAddressBytes[3];\n\n                  byte[] destinationAddressBytes = _destinationAddress.GetAddressBytes();\n                  packet[16] = destinationAddressBytes[0];\n                  packet[17] = destinationAddressBytes[1];\n                  packet[18] = destinationAddressBytes[2];\n                  packet[19] = destinationAddressBytes[3];\n\n                  Array.Copy(_payload, 0, packet, IP_HEADER_LENGTH, _payload.Length);\n\n                  return packet;\n            }\n\n            // Deserializes a byte Array and returns an IP object", "            public IPAddress _destinationAddress { get; set; }\n\n            // Payload\n            public byte[] _payload { get; set; }\n\n            /* CONSTRUCTORS */\n            public IP() { }\n\n            public IP(string sourceIP, string destinationIP)\n            {\n                  _version = IPV4;\n                  _headerLength = 5;\n                  _typeOfService = 0;\n                  _totalLength = IP_HEADER_LENGTH;\n                  _identification = 0;\n                  _flags = 0;\n                  _fragmentOffset = 0;\n                  _timeToLive = 64;\n                  _protocol = 0;\n                  _headerChecksum = 0;\n                  _sourceAddress = IPAddress.Parse(sourceIP);\n                  _destinationAddress = IPAddress.Parse(destinationIP);\n            }\n\n            // Serializes the packet and returns it as a byte Array\n            public byte[] Serialize()\n            {\n                  byte[] packet = new byte[IP_HEADER_LENGTH + _payload.Length];\n\n                  // Header\n                  packet[0] = (byte)((_version << 4) | _headerLength);\n                  packet[1] = _typeOfService;\n                  packet[2] = (byte)(_totalLength >> 8);\n                  packet[3] = (byte)(_totalLength & 0xFF);\n                  packet[4] = (byte)(_identification >> 8);\n                  packet[5] = (byte)(_identification & 0xFF);\n                  packet[6] = (byte)((_flags << 5) | (_fragmentOffset >> 8));\n                  packet[7] = (byte)(_fragmentOffset & 0xFF);\n                  packet[8] = _timeToLive;\n                  packet[9] = _protocol;\n                  packet[10] = (byte)(_headerChecksum >> 8);\n                  packet[11] = (byte)(_headerChecksum & 0xFF);\n\n                  byte[] sourceAddressBytes = _sourceAddress.GetAddressBytes();\n                  packet[12] = sourceAddressBytes[0];\n                  packet[13] = sourceAddressBytes[1];\n                  packet[14] = sourceAddressBytes[2];\n                  packet[15] = sourceAddressBytes[3];\n\n                  byte[] destinationAddressBytes = _destinationAddress.GetAddressBytes();\n                  packet[16] = destinationAddressBytes[0];\n                  packet[17] = destinationAddressBytes[1];\n                  packet[18] = destinationAddressBytes[2];\n                  packet[19] = destinationAddressBytes[3];\n\n                  Array.Copy(_payload, 0, packet, IP_HEADER_LENGTH, _payload.Length);\n\n                  return packet;\n            }\n\n            // Deserializes a byte Array and returns an IP object", "            public static IP Deserialize(byte[] packet)\n            {\n                  if (packet.Length < IP_HEADER_LENGTH) { return null; }\n\n                  IP ip = new IP();\n\n                  // Header\n                  ip._version = (byte)(packet[0] >> 4);\n                  ip._headerLength = (byte)(packet[0] & 0x0F);\n                  ip._typeOfService = packet[1];\n                  ip._totalLength = (ushort)((packet[2] << 8) | packet[3]);\n                  ip._identification = (ushort)((packet[4] << 8) | packet[5]);\n                  ip._flags = (ushort)(packet[6] >> 5);\n                  ip._fragmentOffset = (ushort)(((packet[6] & 0x1F) << 8) | packet[7]);\n                  ip._timeToLive = packet[8];\n                  ip._protocol = packet[9];\n                  ip._headerChecksum = (ushort)((packet[10] << 8) | packet[11]);\n                  ip._sourceAddress = new IPAddress(new byte[] { packet[12], packet[13], packet[14], packet[15] });\n                  ip._destinationAddress = new IPAddress(new byte[] { packet[16], packet[17], packet[18], packet[19] });\n\n                  // Payload\n                  ip._payload = new byte[ip._totalLength - IP_HEADER_LENGTH];\n                  Array.Copy(packet, IP_HEADER_LENGTH, ip._payload, 0, ip._payload.Length);\n\n                  return ip;\n            }             \n\n            // Returns a string representation of the IP packet.", "            public override string ToString()\n            {\n                  return $\"  ### [IP] ###\\n\" +\n                         $\"  Version: {_version}\\n\" +\n                         $\"  Header Length: {_headerLength}\\n\" +\n                         $\"  Type of Service: {_typeOfService}\\n\" +\n                         $\"  Total Length: {_totalLength}\\n\" +\n                         $\"  Identification: {_identification}\\n\" +\n                         $\"  Flags: {_flags}\\n\" +\n                         $\"  Fragment Offset: {_fragmentOffset}\\n\" +\n                         $\"  Time to Live: {_timeToLive}\\n\" +\n                         $\"  Protocol: {_protocol}\\n\" +\n                         $\"  Header Checksum: {_headerChecksum}\\n\" +\n                         $\"  Source Address: {_sourceAddress}\\n\" +\n                         $\"  Destination Address: {_destinationAddress}\";\n            }\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
{"filename": "src/crypto.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System.Security.Cryptography;\nusing System.Text;\nusing System;\n\nnamespace ProtoIP\n{\n      namespace Crypto", "{\n      namespace Crypto\n      {\n            public class HASH\n            {\n                  public byte[] _digest { get; set; }\n\n                  // Get the digest as a hexadecimal string\n                  public string GetDigestString()\n                  {\n                        StringBuilder sb = new StringBuilder();", "                  public string GetDigestString()\n                  {\n                        StringBuilder sb = new StringBuilder();\n                        foreach (byte b in _digest)\n                        {\n                              sb.Append(b.ToString(\"x2\"));\n                        }\n                        return sb.ToString();\n                  }\n\n                  public static byte[] GenerateRandomBytes(int length)\n                  {\n                        byte[] bytes = new byte[length];", "                  public static byte[] GenerateRandomBytes(int length)\n                  {\n                        byte[] bytes = new byte[length];\n                        using (var rng = new RNGCryptoServiceProvider())\n                        {\n                              rng.GetBytes(bytes);\n                        }\n                        return bytes;\n                  }\n            }\n\n            // Secure Hash Algorithm 256 (SHA256)", "            // Provides an interface for hashing data using the SHA256 algorithm\n            public class SHA256 : HASH\n            {\n                  // Hash a given byte array and set the digest\n                  public SHA256(byte[] data) { _digest = Hash(data); }\n\n                  public static byte[] Hash(byte[] data)\n                  {\n                        using (var sha256 = SHA256Managed.Create())\n                        {\n                              return sha256.ComputeHash(data);\n                        }\n                  }\n\n                  // Hash a given byte array and salt and set the digest", "                        using (var sha256 = SHA256Managed.Create())\n                        {\n                              return sha256.ComputeHash(data);\n                        }\n                  }\n\n                  // Hash a given byte array and salt and set the digest\n                  public static byte[] Hash(byte[] data, byte[] salt)\n                  {\n                        byte[] dataWithSalt = new byte[data.Length + salt.Length];\n                        Buffer.BlockCopy(data, 0, dataWithSalt, 0, data.Length);\n                        Buffer.BlockCopy(salt, 0, dataWithSalt, data.Length, salt.Length);\n                        return Hash(dataWithSalt);\n                  }\n            }\n\n            // Message-Digest Algorithm 5 (MD5)", "            // Provides an interface for hashing and verifying data using the MD5 algorithm\n            public class MD5 : HASH\n            {\n                  // Hash a given byte array and set the digest\n                  public MD5(byte[] data) { _digest = Hash(data); }\n\n                  public static byte[] Hash(byte[] data)\n                  {\n                        using (var md5 = MD5CryptoServiceProvider.Create())\n                        {\n                              return md5.ComputeHash(data);\n                        }\n                  }\n", "                        using (var md5 = MD5CryptoServiceProvider.Create())\n                        {\n                              return md5.ComputeHash(data);\n                        }\n                  }\n\n                  public static byte[] Hash(byte[] data, byte[] salt)\n                  {\n                        byte[] dataWithSalt = new byte[data.Length + salt.Length];\n                        Buffer.BlockCopy(data, 0, dataWithSalt, 0, data.Length);\n                        Buffer.BlockCopy(salt, 0, dataWithSalt, data.Length, salt.Length);\n                        return Hash(dataWithSalt);\n                  }\n            }\n\n            // Advanced Encryption Standard (AES)\n            // Provides methods for encrypting and decrypting data using AES", "            public class AES\n            {\n                  private const int KEY_SIZE = 256;\n\n                  public byte[] _key { get; private set; }\n\n                  // Constructors\n                  public AES() { }\n                  public AES(byte[] key) { this._key = key; }\n\n                  // Generate a random AES key", "                  public void GenerateKey()\n                  {\n                        using (var aes = Aes.Create())\n                        {\n                              aes.KeySize = KEY_SIZE;\n                              aes.GenerateKey();\n                              _key = aes.Key;\n                        }\n                  }\n\n                  public static byte[] DeriveKeyFromPassword(string password, byte[] salt)\n                  {", "                  public static byte[] DeriveKeyFromPassword(string password, byte[] salt)\n                  {\n                        using (var aes = Aes.Create())\n                        {\n                              aes.KeySize = KEY_SIZE;\n                              return new Rfc2898DeriveBytes(password, salt).GetBytes(aes.KeySize / 8);\n                        }\n                  }\n\n                  // Encrypt a byte array using the generated key\n                  // Returns a byte array containing the IV and the encrypted data\n                  public byte[] Encrypt(byte[] data)\n                  {", "                        if (_key == null) throw new Exception(\"Key not set\");\n                        using (var aes = Aes.Create())\n                        {\n                              aes.KeySize = KEY_SIZE;\n                              aes.Key = _key;\n                              aes.GenerateIV();\n                              byte[] iv = aes.IV;\n                              byte[] encrypted = aes.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);\n                              byte[] result = new byte[iv.Length + encrypted.Length];\n                              Buffer.BlockCopy(iv, 0, result, 0, iv.Length);\n                              Buffer.BlockCopy(encrypted, 0, result, iv.Length, encrypted.Length);\n                              return result;\n                        }\n                  }\n\n                  // Decrypt a byte array using the generated key\n                  // Returns a byte array containing the decrypted data\n                  public byte[] Decrypt(byte[] data)\n                  {", "                        if (_key == null) throw new Exception(\"Key not set\");\n                        using (var aes = Aes.Create())\n                        {\n                              aes.KeySize = KEY_SIZE;\n                              aes.Key = _key;\n                              byte[] iv = new byte[aes.IV.Length];\n                              byte[] encrypted = new byte[data.Length - iv.Length];\n                              Buffer.BlockCopy(data, 0, iv, 0, iv.Length);\n                              Buffer.BlockCopy(data, iv.Length, encrypted, 0, encrypted.Length);\n                              aes.IV = iv;\n                              return aes.CreateDecryptor().TransformFinalBlock(encrypted, 0, encrypted.Length);\n                        }\n                  }\n \n                  // Show the generated key as a string", "                  public string GetKeyString() { return Convert.ToBase64String(_key); }\n                  public byte[] GetKeyBytes() { return _key; }\n                  public void ShowKey() { Console.WriteLine(GetKeyString()); }\n            }\n\n            // Rivest\u2013Shamir\u2013Adleman (RSA)\n            // Provides methods for asymetric encryption and digital signatures using RSA\n            public class RSA\n            {\n                  private RSAParameters _privateKey;\n                  private RSAParameters _publicKey;\n\n                  // Constructors\n                  public RSA() { }\n\n                  public RSA(RSAParameters privateKey, RSAParameters publicKey)\n                  {\n                        _privateKey = privateKey;\n                        _publicKey = publicKey;\n                  }\n\n                  // Generate a random RSA key pair", "                  private RSAParameters _privateKey;\n                  private RSAParameters _publicKey;\n\n                  // Constructors\n                  public RSA() { }\n\n                  public RSA(RSAParameters privateKey, RSAParameters publicKey)\n                  {\n                        _privateKey = privateKey;\n                        _publicKey = publicKey;\n                  }\n\n                  // Generate a random RSA key pair", "                  public void GenerateKeyPair()\n                  {\n                        using (var rsa = new RSACryptoServiceProvider())\n                        {\n                              _privateKey = rsa.ExportParameters(true);\n                              _publicKey = rsa.ExportParameters(false);\n                        }\n                  }\n\n                  // Encrypt a byte array using the public key\n                  public static byte[] Encrypt(byte[] data, byte[] publicKey)\n                  {\n                        byte[] modulus = new byte[128];\n                        byte[] exponent = new byte[3];\n                        Buffer.BlockCopy(publicKey, 0, modulus, 0, 128);\n                        Buffer.BlockCopy(publicKey, 128, exponent, 0, 3);\n", "                  public static byte[] Encrypt(byte[] data, byte[] publicKey)\n                  {\n                        byte[] modulus = new byte[128];\n                        byte[] exponent = new byte[3];\n                        Buffer.BlockCopy(publicKey, 0, modulus, 0, 128);\n                        Buffer.BlockCopy(publicKey, 128, exponent, 0, 3);\n\n                        using (var rsa = new RSACryptoServiceProvider())\n                        {\n                              var rsaParams = new RSAParameters\n                              {\n                                    Modulus = modulus,\n                                    Exponent = exponent\n                              };\n                              rsa.ImportParameters(rsaParams);\n                              return rsa.Encrypt(data, false);\n                        }     \n                  }\n\n                  // Decrypt a byte array using the private key\n                  public byte[] Decrypt(byte[] data)\n                  {", "                        using (var rsa = new RSACryptoServiceProvider())\n                        {\n                              rsa.ImportParameters(_privateKey);\n                              return rsa.Decrypt(data, false);\n                        }\n                  }\n\n                  // Sign a byte array using the private key\n                  public byte[] Sign(byte[] data)\n                  {\n                        using (var rsa = new RSACryptoServiceProvider())\n                        {\n                              rsa.ImportParameters(_privateKey);\n                              return rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);\n                        }\n                  }\n\n                  // Verify a signature using a public key\n                  // ", "                        using (var rsa = new RSACryptoServiceProvider())\n                        {\n                              rsa.ImportParameters(_privateKey);\n                              return rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);\n                        }\n                  }\n\n                  // Verify a signature using a public key\n                  // \n                  // The public key is exported in a format specified in the comments\n                  // for the ExportPublicKey method. To use it we must extract the information\n                  // from the byte array and construct a new RSAParameters object", "                  // The public key is exported in a format specified in the comments\n                  // for the ExportPublicKey method. To use it we must extract the information\n                  // from the byte array and construct a new RSAParameters object\n                  public bool Verify(byte[] data, byte[] signature, byte[] exportedPublicKey)\n                  {\n                        byte[] modulus = new byte[128];\n                        byte[] exponent = new byte[3];\n                        Buffer.BlockCopy(exportedPublicKey, 0, modulus, 0, 128);\n                        Buffer.BlockCopy(exportedPublicKey, 128, exponent, 0, 3);\n\n                        using (var rsa = new RSACryptoServiceProvider())\n                        {\n                              rsa.ImportParameters(new RSAParameters { Modulus = modulus, Exponent = exponent });\n                              return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);\n                        }\n                  }\n\n                  // Exports the modulus and exponent of the public key\n                  // Returns a byte array containing the modulus and the exponent\n                  //\n                  // I had to implement this method because none of the export methods\n                  // provided by the .NET Framework seemed to work on my platform\n                  public byte[] ExportPublicKey()\n                  {\n                        byte[] modulus = _publicKey.Modulus;\n                        byte[] exponent = _publicKey.Exponent;\n\n                        byte[] publicKey = new byte[modulus.Length + exponent.Length];\n                        Buffer.BlockCopy(modulus, 0, publicKey, 0, modulus.Length);\n                        Buffer.BlockCopy(exponent, 0, publicKey, modulus.Length, exponent.Length);\n\n                        return publicKey;\n                  }\n            }\n\n            // Universal Unique Identifier (UUID) version 4\n            // Provides methods for generating UUIDs", "                        using (var rsa = new RSACryptoServiceProvider())\n                        {\n                              rsa.ImportParameters(new RSAParameters { Modulus = modulus, Exponent = exponent });\n                              return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);\n                        }\n                  }\n\n                  // Exports the modulus and exponent of the public key\n                  // Returns a byte array containing the modulus and the exponent\n                  //\n                  // I had to implement this method because none of the export methods\n                  // provided by the .NET Framework seemed to work on my platform\n                  public byte[] ExportPublicKey()\n                  {\n                        byte[] modulus = _publicKey.Modulus;\n                        byte[] exponent = _publicKey.Exponent;\n\n                        byte[] publicKey = new byte[modulus.Length + exponent.Length];\n                        Buffer.BlockCopy(modulus, 0, publicKey, 0, modulus.Length);\n                        Buffer.BlockCopy(exponent, 0, publicKey, modulus.Length, exponent.Length);\n\n                        return publicKey;\n                  }\n            }\n\n            // Universal Unique Identifier (UUID) version 4\n            // Provides methods for generating UUIDs", "            public class UUIDv4\n            {\n                  // Generate a random UUID\n                  // Returns a byte array containing the UUID\n                  private static byte[] GenerateRandomBytes()\n                  {\n                        byte[] uuid = new byte[16];\n                        using (var rng = new RNGCryptoServiceProvider())\n                        {\n                              rng.GetBytes(uuid);\n                        }\n                        uuid[6] = (byte)((uuid[6] & 0x0F) | 0x40);\n                        uuid[8] = (byte)((uuid[8] & 0x3F) | 0x80);\n                        return uuid;\n                  }\n\n                  // Generate a new UUID of type T", "                  public static T newID<T>()\n                  {\n                        if (typeof(T) == typeof(byte[]))\n                        {\n                              return (T)(object)GenerateRandomBytes();\n                        }\n                        else if (typeof(T) == typeof(string))\n                        {\n                              return (T)(object)ToString(GenerateRandomBytes());\n                        }\n                        else\n                        {\n                              throw new Exception(\"Invalid type\");\n                        }\n                  }\n\n                  // Show a UUID as a string", "                  public static string ToString(byte[] uuid)\n                  {\n                        return BitConverter.ToString(uuid).Replace(\"-\", \"\");\n                  }\n            }\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
{"filename": "src/netPod.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System;\nusing System.Net;\nusing System.Net.Sockets;\n\nnamespace ProtoIP\n{\n      // NetPods implement an abstraction for sending and receiving data over a raw socket.", "{\n      // NetPods implement an abstraction for sending and receiving data over a raw socket.\n      // This allows you to create and manipulate raw packets from all kinds of network layers.\n      public class NetPod\n      {\n            private Ethernet _ethernet;\n            private ARP _arp;\n            private IP _ip;\n            private UDP _udp;\n            private TCP _tcp;\n            private ICMP _icmp;\n\n            // Creates a new NetPod instance.\n            public NetPod()\n            {\n                  _ethernet = new Ethernet();\n                  _arp = new ARP();\n                  _ip = new IP();\n                  _udp = new UDP();\n                  _tcp = new TCP();\n                  _icmp = new ICMP();\n            }\n      \n            // Creates a new netpod object with an Ethernet layer and\n            // all the subsequent layers encapsulated inside it.\n            public NetPod(Ethernet ethernet)\n            {", "            private UDP _udp;\n            private TCP _tcp;\n            private ICMP _icmp;\n\n            // Creates a new NetPod instance.\n            public NetPod()\n            {\n                  _ethernet = new Ethernet();\n                  _arp = new ARP();\n                  _ip = new IP();\n                  _udp = new UDP();\n                  _tcp = new TCP();\n                  _icmp = new ICMP();\n            }\n      \n            // Creates a new netpod object with an Ethernet layer and\n            // all the subsequent layers encapsulated inside it.\n            public NetPod(Ethernet ethernet)\n            {", "                  if (ethernet._type == Ethernet.ETH_TYPE_IP) { ipDeserialization(ethernet, this); }\n                  else if (ethernet._type == Ethernet.ETH_TYPE_ARP) { arpDeserialization(ethernet, this); }\n                  else { throw new Exception(\"Unknown ethernet type.\"); } \n            }\n\n            // Sends a NetPod over a raw socket.\n            public static void Send(NetPod pod)\n            {\n                  byte[] data = Assemble(pod);\n                  Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Raw, ProtocolType.IP);\n                  IPEndPoint ipEndPoint = new IPEndPoint(pod._ip._destinationAddress, 0); \n                  socket.SendTo(data, ipEndPoint);\n            }\n\n            // Listens for every incomming packet on a Network Interface\n            // and calls the callback function with the NetPod as a parameter.", "            public static void Sniff(string networkInterface, Action<NetPod> callback)\n            {\n                  Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Raw, ProtocolType.IP);\n                  socket.Bind(new IPEndPoint(IPAddress.Any, 0));\n                  socket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.HeaderIncluded, true);\n                  byte[] data = new byte[4096];\n                  EndPoint ipEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                  while (true)\n                  {\n                        socket.ReceiveFrom(data, ref ipEndPoint);\n                        NetPod pod = NetPod.Disassemble(data);\n                        NetPod.ShowStructure(pod);\n                        callback(pod);\n                  }\n            }\n\n            // Deserializes an Ethernet frame and it's subsequent layers and assigns\n            // them to a netpod instance.", "            private static void ipDeserialization(Ethernet ethernet, NetPod pod)\n            {\n                  var deserializedIPPacket = IP.Deserialize(ethernet._payload);\n                  byte[] ipPayload = deserializedIPPacket._payload;\n\n                  if (deserializedIPPacket == null) { return; }\n\n                  pod._ethernet = ethernet;\n                  pod._ip = deserializedIPPacket;\n\n                  switch (deserializedIPPacket._protocol)\n                  {\n                        case (byte)IP.IPProtocolPacketType.TCP:\n                              var deserializedTCPPacket = TCP.Deserialize(ipPayload);", "                              if (deserializedTCPPacket != null) { pod._tcp = deserializedTCPPacket; }\n                              break;\n                        case (byte)IP.IPProtocolPacketType.UDP:\n                              var deserializedUDPPacket = UDP.Deserialize(ipPayload);\n                              if (deserializedUDPPacket != null) { pod._udp = deserializedUDPPacket; }\n                              break;\n                        case (byte)IP.IPProtocolPacketType.ICMP:\n                              var deserializedICMPPacket = ICMP.Deserialize(ipPayload);\n                              if (deserializedICMPPacket != null) { pod._icmp = deserializedICMPPacket; }\n                              break;\n                  }\n            }\n\n            // Deserializes an Ethernet frame and the ARP packet inside it\n            // and assigns the objects to a netpod instance.", "                              if (deserializedICMPPacket != null) { pod._icmp = deserializedICMPPacket; }\n                              break;\n                  }\n            }\n\n            // Deserializes an Ethernet frame and the ARP packet inside it\n            // and assigns the objects to a netpod instance.\n            private static void arpDeserialization(Ethernet ethernet, NetPod pod)\n            {\n                  var deserializedARPPacket = ARP.Deserialize(ethernet._payload);\n                  if (deserializedARPPacket != null) { return; }\n\n                  pod._ethernet = ethernet;\n                  pod._arp = deserializedARPPacket;\n            }\n\n            // Assembles the NetPod into a byte array.\n            // This byte array can be sent over a raw socket.", "                  if (deserializedARPPacket != null) { return; }\n\n                  pod._ethernet = ethernet;\n                  pod._arp = deserializedARPPacket;\n            }\n\n            // Assembles the NetPod into a byte array.\n            // This byte array can be sent over a raw socket.\n            private static byte[] Assemble(NetPod pod)\n            {\n                  byte[] data = pod._ethernet.Serialize();\n                  return data;\n            }\n\n            // Disassembles the NetPod from a byte array.\n            // This byte array can be received from a raw socket.", "            private static byte[] Assemble(NetPod pod)\n            {\n                  byte[] data = pod._ethernet.Serialize();\n                  return data;\n            }\n\n            // Disassembles the NetPod from a byte array.\n            // This byte array can be received from a raw socket.\n            private static NetPod Disassemble(byte[] data)\n            {\n                  Ethernet ethernet = Ethernet.Deserialize(data);\n                  return new NetPod(ethernet);\n            }\n \n            // Shows the netpod structure in a human readable format.", "            private static NetPod Disassemble(byte[] data)\n            {\n                  Ethernet ethernet = Ethernet.Deserialize(data);\n                  return new NetPod(ethernet);\n            }\n \n            // Shows the netpod structure in a human readable format.\n            public static void ShowStructure(NetPod pod)\n            {\n                  string header = \"### [NetPod Structure] ###\\n\";\n                  string etherLayer = pod._ethernet.ToString();\n                  string ipLayer = pod._ip.ToString();\n                  string lastLayer = \"\";\n\n                  switch (pod._ip._protocol)\n                  {\n                        case (byte)IP.IPProtocolPacketType.TCP:\n                              lastLayer = pod._tcp.ToString();\n                              break;\n                        case (byte)IP.IPProtocolPacketType.UDP:\n                              lastLayer = pod._udp.ToString();\n                              break;\n                        case (byte)IP.IPProtocolPacketType.ICMP:\n                              lastLayer = pod._icmp.ToString();\n                              break;\n                  }\n\n                  Console.WriteLine(header + etherLayer + \"\\n\" + ipLayer + \"\\n\" + lastLayer);\n            }\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
{"filename": "src/protoStream.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System.Net.Sockets;\nusing System.Text;\nusing System.IO;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System;\n", "using System;\n\nusing ProtoIP.Common;\nusing static ProtoIP.Packet;\n\nnamespace ProtoIP\n{\n      public class ProtoStream\n      {\n            const int BUFFER_SIZE = Common.Network.DEFAULT_BUFFER_SIZE;\n", "            private NetworkStream _stream;\n            private List<Packet> _packets = new List<Packet>();\n            private byte[] _buffer;\n            private string _LastError;\n            \n            /* CONSTRUCTORS */\n            public ProtoStream() { }\n            public ProtoStream(NetworkStream stream) { this._stream = stream; }\n            public ProtoStream(List<Packet> packets) { this._packets = packets; }\n            public ProtoStream(List<Packet> packets, NetworkStream stream) { this._packets = packets; this._stream = stream; }\n\n            /* PRIVATE METHODS & HELPER FUNCTIONS */\n\n            /*\n             * Tries to read from the stream to construct a packet\n             * Returns the deserialized packet\n             */", "            private Packet receivePacket()\n            {\n                  this._buffer = new byte[BUFFER_SIZE];\n                  if (this.TryRead(this._buffer) < BUFFER_SIZE)\n                  {\n                        this._LastError = \"Failed to receive the packet\";\n                        return null;\n                  }\n\n                  return Packet.Deserialize(this._buffer);\n            }\n\n            /*\n             * Receives an ACK packet from the peer\n             * Returns true if the packet was received successfully, false otherwise\n             */", "            private bool peerReceiveAck()\n            {\n                  Packet packet = this.receivePacket();\n                  if (packet._GetType() != (int)Packet.Type.ACK)\n                  {\n                        this._LastError = \"Invalid packet type\";\n                        return false;\n                  }\n\n                  return true;\n            }\n\n            /*\n            * Sends the ACK packet to the peer\n            * Returns true if the packet was sent successfully, false otherwise\n            */", "            private bool peerSendAck()\n            {\n                  Packet packet = new Packet(Packet.Type.ACK);\n\n                  this._buffer = Packet.Serialize(packet);\n                  if (this.TryWrite(this._buffer) < BUFFER_SIZE)\n                  {\n                        this._LastError = \"Failed to send the ACK packet\";\n                        return false;\n                  }\n\n                  return true;\n            }\n\n            /*\n            * Sends the SOT packet to the peer\n            * Returns true if the packet was sent successfully, false otherwise\n            */", "            private bool peerSendSot()\n            {\n                  this._buffer = Packet.Serialize(new Packet(Packet.Type.SOT));\n                  if (this.TryWrite(this._buffer) < BUFFER_SIZE)\n                  {\n                        this._LastError = \"Failed to send the START_OF_TRANSMISSION packet\";\n                        return false;\n                  }\n\n                  return true;\n            }\n\n            /*\n            * Receives the SOT packet from the peer\n            * Returns true if the packet was received successfully, false otherwise\n            */", "            private bool peerReceiveSot()\n            {\n                  Packet packet = this.receivePacket();\n                  if (packet != null && packet._GetType() != (int)Packet.Type.SOT)\n                  {\n                        this._LastError = \"Invalid packet type\";\n                        return false;\n                  }\n\n                  return true;\n            }\n\n            /*\n            * Sends the EOT packet to the peer\n            * Returns true if the packet was sent successfully, false otherwise\n            */", "            private bool peerSendEot()\n            {\n                  this._buffer = Packet.Serialize(new Packet(Packet.Type.EOT));\n                  if (this.TryWrite(this._buffer) < BUFFER_SIZE)\n                  {\n                        this._LastError = \"Failed to send the END_OF_TRANSMISSION packet\";\n                        return false;\n                  }\n\n                  return true;\n            }\n\n            /*\n            * Receives the EOT packet from the peer\n            * Returns true if the packet was received successfully, false otherwise\n            */", "            private bool peerReceiveEot()\n            {\n                  Packet packet = this.receivePacket();\n                  if (packet._GetType() != (int)Packet.Type.EOT)\n                  {\n                        this._LastError = \"Invalid packet type\";\n                        return false;\n                  }\n\n                  return true;\n            }\n\n            /*\n            * Sends a REPEAT packet with the missing packet IDs to the peer\n            */", "            private bool peerSendRepeat(List<int> missingPackets)\n            {\n                  Packet packet = new Packet(Packet.Type.REPEAT);\n\n                  byte[] payload = new byte[missingPackets.Count * sizeof(int)];\n                  Buffer.BlockCopy(missingPackets.ToArray(), 0, payload, 0, payload.Length);\n\n                  packet.SetPayload(payload);\n                  this._buffer = Packet.Serialize(packet);\n\n                  if (this.TryWrite(this._buffer) < BUFFER_SIZE)\n                  {\n                        this._LastError = \"Failed to send the REPEAT packet\";\n                        return false;\n                  }\n\n                  return true;\n            }\n\n            /*\n            * Receives the REPEAT packet from the requesting peer\n            * Returns the missing packet IDs\n            */\n            private List<int> peerReceiveRepeat()\n            {\n                  Packet packet = this.receivePacket();", "                  if (this.TryWrite(this._buffer) < BUFFER_SIZE)\n                  {\n                        this._LastError = \"Failed to send the REPEAT packet\";\n                        return false;\n                  }\n\n                  return true;\n            }\n\n            /*\n            * Receives the REPEAT packet from the requesting peer\n            * Returns the missing packet IDs\n            */\n            private List<int> peerReceiveRepeat()\n            {\n                  Packet packet = this.receivePacket();", "                  if (packet._GetType() != (int)Packet.Type.REPEAT)\n                  {\n                        this._LastError = \"Invalid packet type\";\n                        return null;\n                  }\n\n                  byte[] payload = packet.GetDataAs<byte[]>();\n                  int[] missingPackets = new int[payload.Length / sizeof(int)];\n                  Buffer.BlockCopy(payload, 0, missingPackets, 0, payload.Length);\n\n                  return new List<int>(missingPackets);\n            }\n\n            /*\n            * Resends the missing packets to the peer\n            */", "            private bool peerResendMissingPackets(List<int> packetIDs)\n            {\n                  for (int i = 0; i < packetIDs.Count; i++)\n                  {\n                        this._buffer = Packet.Serialize(this._packets[packetIDs[i]]);\n                        if (this.TryWrite(this._buffer) < BUFFER_SIZE)\n                        {\n                              this._LastError = \"Failed to send the packet \" + packetIDs[i];\n                              return false;\n                        }\n                  }\n\n                  return true;\n            }\n \n            /*\n            * Receives the missing packets from the peer and adds them to the packet List\n            */", "            private bool peerReceiveMissingPackets(int packetCount)\n            {\n                  for (int i = 0; i < packetCount; i++)\n                  {\n                        this._buffer = new byte[BUFFER_SIZE];\n                        if (this.TryRead(this._buffer) < BUFFER_SIZE)\n                        {\n                              this._LastError = \"Failed to receive the packet \" + i;\n                              return false;\n                        }\n\n                        Packet packet = Packet.Deserialize(this._buffer);\n                        this._packets.Add(packet);\n                  }\n\n                  return true;\n            }\n\n            /*\n             * Validate the packet List\n             *\n             * Check if there are any null packets or if there are any ID jumps\n             */", "            private bool ValidatePackets()\n            {\n                  for (int i = 0; i < this._packets.Count; i++)\n                  {\n                        if (this._packets[i] == null)\n                        {\n                              this._LastError = \"Packet \" + i + \" is null\";\n                              return false;\n                        }\n\n                        if (this._packets[i]._GetId() != i)\n                        {\n                              this._LastError = \"Packet \" + i + \" has an invalid id (Expected: \" + i + \", Actual: \" + this._packets[i]._GetId() + \")\";\n                              return false;\n                        }\n                  }\n\n                  return true;\n            }\n\n            /*\n             * Returns a list with the missing packet IDs\n             *\n             * Check for any ID jumps, if there is an ID jump, add the missing IDs to the list\n             */\n            private List<int> GetMissingPacketIDs()\n            {\n                  List<int> missingPackets = new List<int>();\n                  int lastId = 0;\n", "                        if (this._packets[i]._GetId() != i)\n                        {\n                              this._LastError = \"Packet \" + i + \" has an invalid id (Expected: \" + i + \", Actual: \" + this._packets[i]._GetId() + \")\";\n                              return false;\n                        }\n                  }\n\n                  return true;\n            }\n\n            /*\n             * Returns a list with the missing packet IDs\n             *\n             * Check for any ID jumps, if there is an ID jump, add the missing IDs to the list\n             */\n            private List<int> GetMissingPacketIDs()\n            {\n                  List<int> missingPackets = new List<int>();\n                  int lastId = 0;\n", "                  foreach (Packet packet in this._packets)\n                  {\n                        if (packet._GetId() - lastId > 1)\n                        {\n                              for (int i = lastId + 1; i < packet._GetId(); i++)\n                              {\n                                    missingPackets.Add(i);\n                              }\n                        }\n\n                        lastId = packet._GetId();\n                  }\n\n                  return missingPackets;\n            }\n\n            /*\n             * Orders the packets by id and assembles the data buffer\n             *\n             * Allocates a buffer with the total length of the data and copies the data from the packets to the buffer\n             */", "            private int Assemble()\n            {\n                  ProtoStream.OrderPackets(this._packets);\n\n                  if (!this.ValidatePackets())\n                  {\n                        return -1;\n                  }\n\n                  int dataLength = 0;\n                  for (int i = 0; i < this._packets.Count; i++) { dataLength += this._packets[i].GetDataAs<byte[]>().Length; }\n                  byte[] data = new byte[dataLength];\n\n                  int dataOffset = 0;", "                  for (int i = 0; i < this._packets.Count; i++) { dataLength += this._packets[i].GetDataAs<byte[]>().Length; }\n                  byte[] data = new byte[dataLength];\n\n                  int dataOffset = 0;\n                  for (int i = 0; i < this._packets.Count; i++)\n                  {\n                        byte[] packetData = this._packets[i].GetDataAs<byte[]>();\n                        Array.Copy(packetData, 0, data, dataOffset, packetData.Length);\n                        dataOffset += packetData.Length;\n                  }\n\n                  this._buffer = data;\n                  return 0;\n            }\n\n            /*\n             * Attemps to write the data to the stream until it succeeds or the number of tries is reached\n             */", "            private int TryWrite(byte[] data, int tries = Network.MAX_TRIES)\n            {\n                  int bytesWritten = 0;\n\n                  while (bytesWritten < data.Length && tries > 0)\n                  {\n                        try\n                        {\n                              if (this._stream.CanWrite)\n                              {\n                                    this._stream.Write(data, bytesWritten, data.Length - bytesWritten);\n                                    bytesWritten += data.Length - bytesWritten;\n                              }\n                        }", "                              if (this._stream.CanWrite)\n                              {\n                                    this._stream.Write(data, bytesWritten, data.Length - bytesWritten);\n                                    bytesWritten += data.Length - bytesWritten;\n                              }\n                        }\n                        catch (Exception e)\n                        {\n                              tries--;\n                        }\n                  }\n\n                  return bytesWritten;\n            }\n\n            /*\n             * Attemps to read the data from the stream until it succeeds or the number of tries is reached\n             */", "            private int TryRead(byte[] data, int tries = Network.MAX_TRIES)\n            {\n                  int bytesRead = 0;\n\n                  while (bytesRead < data.Length && tries > 0)\n                  {\n                        try\n                        {\n                              if (this._stream.DataAvailable || this._stream.CanRead)\n                                    bytesRead += this._stream.Read(data, bytesRead, data.Length - bytesRead);\n                        }", "                              if (this._stream.DataAvailable || this._stream.CanRead)\n                                    bytesRead += this._stream.Read(data, bytesRead, data.Length - bytesRead);\n                        }\n                        catch (Exception e)\n                        {\n                              tries--;\n                        }\n                  }\n\n                  return bytesRead;\n            }\n\n            /*\n             * Partitions the data into packets and adds them to the Packet list\n             */", "            private void Partition(byte[] data)\n            {\n                  if (data.Length > (BUFFER_SIZE) - Packet.HEADER_SIZE)\n                  {\n                        int numPackets = (int)Math.Ceiling((double)data.Length / ((BUFFER_SIZE) - Packet.HEADER_SIZE));\n                        int packetSize = (int)Math.Ceiling((double)data.Length / numPackets);\n\n                        this._packets = new List<Packet>();\n                        for (int i = 0; i < numPackets; i++)\n                        {\n                              int packetDataSize = (i == numPackets - 1) ? data.Length - (i * packetSize) : packetSize;\n                              byte[] packetData = new byte[packetDataSize];\n                              Array.Copy(data, i * packetSize, packetData, 0, packetDataSize);\n\n                              this._packets.Add(new Packet(Packet.Type.BYTES, i, packetDataSize, packetData));\n                        }\n                  }\n                  else\n                  {\n                        this._packets = new List<Packet>();\n                        this._packets.Add(new Packet(Packet.Type.BYTES, 0, data.Length, data));\n                  }\n            }\n\n            /* PUBLIC METHODS */\n            /*\n             * Checks if a peer is connected to the stream\n             */", "                        for (int i = 0; i < numPackets; i++)\n                        {\n                              int packetDataSize = (i == numPackets - 1) ? data.Length - (i * packetSize) : packetSize;\n                              byte[] packetData = new byte[packetDataSize];\n                              Array.Copy(data, i * packetSize, packetData, 0, packetDataSize);\n\n                              this._packets.Add(new Packet(Packet.Type.BYTES, i, packetDataSize, packetData));\n                        }\n                  }\n                  else\n                  {\n                        this._packets = new List<Packet>();\n                        this._packets.Add(new Packet(Packet.Type.BYTES, 0, data.Length, data));\n                  }\n            }\n\n            /* PUBLIC METHODS */\n            /*\n             * Checks if a peer is connected to the stream\n             */", "            public bool IsConnected()\n            {\n                  return this._stream != null && this._stream.CanRead && this._stream.CanWrite;\n            }\n\n            /*\n             * Transmits the data to the peer\n             *\n             * Ensures that the peer is ready to receive the data.\n             * Partitions the data into packets and sends them to the peer.\n             * Waits for the peer to acknowledge the data.\n             * Allows the peer to request missing packets until all the data\n             * has been received or the maximum number of tries has been reached.\n             */", "            public int Transmit(byte[] data)\n            {\n                  this.Partition(data);\n\n                  this.peerSendSot();\n                  if (this.peerReceiveAck() == false) { return -1; }\n                  ProtoStream.SendPackets(this._stream, this._packets);\n                  this.peerSendEot();\n\n                  int tries = 0;\n", "                  while (tries < Network.MAX_TRIES)\n                  {\n                        Packet response = this.receivePacket();\n                        if (response == null) { return -1; }\n                        if (response._GetType() == (int)Packet.Type.ACK) { break; }\n                        \n                        else if (response._GetType() == (int)Packet.Type.REPEAT)\n                        {\n                              List<int> missingPacketIDs = this.peerReceiveRepeat();\n                              if (missingPacketIDs.Any()) { this.peerResendMissingPackets(missingPacketIDs); }\n                              else { return -1; }\n                        }\n\n                        tries++;\n                  }\n\n                  this._packets = new List<Packet>();\n                  return 0;\n            }\n\n            /*\n             * Sends a string to the peer\n             */", "                              if (missingPacketIDs.Any()) { this.peerResendMissingPackets(missingPacketIDs); }\n                              else { return -1; }\n                        }\n\n                        tries++;\n                  }\n\n                  this._packets = new List<Packet>();\n                  return 0;\n            }\n\n            /*\n             * Sends a string to the peer\n             */", "            public int Transmit(string data)\n            {\n                  return this.Transmit(Encoding.ASCII.GetBytes(data));\n            }\n\n            /*\n             * Receives data from the peer until the EOT packet is received\n             */\n            public int Receive()\n            {\n                  bool dataFullyReceived = false;\n                  int tries = Network.MAX_TRIES;\n", "            public int Receive()\n            {\n                  bool dataFullyReceived = false;\n                  int tries = Network.MAX_TRIES;\n\n                  if (this.peerReceiveSot() == false) { return -1; }\n                  if (this.peerSendAck() == false) { return -1; }\n\n                  while (true)\n                  {\n                        if (this.TryRead(this._buffer) < BUFFER_SIZE) { return -1; }\n\n                        Packet packet = Packet.Deserialize(this._buffer);\n", "                  while (true)\n                  {\n                        if (this.TryRead(this._buffer) < BUFFER_SIZE) { return -1; }\n\n                        Packet packet = Packet.Deserialize(this._buffer);\n\n                        if (packet._GetType() == (int)Packet.Type.EOT) { break; }\n\n                        this._packets.Add(packet);\n                  }\n", "                  while (!dataFullyReceived && tries > 0)\n                  {\n                        List<int> missingPacketIDs = GetMissingPacketIDs();\n                        if (missingPacketIDs.Count > 0)\n                        {\n                              this.peerSendRepeat(missingPacketIDs);\n                              this.peerReceiveMissingPackets(missingPacketIDs.Count);\n                        }\n                        else\n                        {\n                              if (this.peerSendAck() == false) { return -1; }\n                              dataFullyReceived = true;\n                        }\n\n                        tries--;\n                  }\n\n                  return 0;\n            }\n\n            // Return the assembled data as a primitive type T", "                              if (this.peerSendAck() == false) { return -1; }\n                              dataFullyReceived = true;\n                        }\n\n                        tries--;\n                  }\n\n                  return 0;\n            }\n\n            // Return the assembled data as a primitive type T", "            public T GetDataAs<T>()\n            {\n                  this.Assemble();\n\n                  byte[] data = this._buffer;\n\n                  // Convert the data to the specified type\n                  switch (typeof(T).Name)\n                  {\n                        case \"String\":\n                              return (T)(object)Encoding.ASCII.GetString(data);\n                        case \"Int32\":\n                              return (T)(object)BitConverter.ToInt32(data, 0);\n                        case \"Int64\":\n                              return (T)(object)BitConverter.ToInt64(data, 0);\n                        case \"Byte[]\":\n                              return (T)(object)data;\n                        default:\n                              this._LastError = \"Invalid type\";\n                              return default(T);\n                  }\n            }\n\n            /* STATIC METHODS */\n            /*\n            * OrderPackets\n            * Orders the packets by id\n            */\n            static void OrderPackets(List<Packet> packets)\n            {\n                  packets.Sort((x, y) => x._GetId().CompareTo(y._GetId()));\n            }\n\n            /*\n            * SendPackets\n            * Sends the packets to the peer\n            */\n            static void SendPackets(NetworkStream stream, List<Packet> packets)\n            {", "                  for (int i = 0; i < packets.Count; i++)\n                  {\n                        SendPacket(stream, packets[i]);\n                  }\n            }\n\n            public static void SendPacket(NetworkStream stream, Packet packet)\n            {\n                  stream.Write(Packet.Serialize(packet), 0, BUFFER_SIZE);\n            }\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
{"filename": "src/icmp.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System;\n\nnamespace ProtoIP\n{\n      // Provides an interface for creating and manipulating ICMP packets\n      // to be used with the NetPods.\n      public class ICMP\n      {\n            // ICMP Packet types", "      public class ICMP\n      {\n            // ICMP Packet types\n            public enum ICMPType\n            {\n                  EchoReply = 0,\n                  DestinationUnreachable = 3,\n                  SourceQuench = 4,\n                  Redirect = 5,\n                  EchoRequest = 8,\n                  TimeExceeded = 11,\n                  ParameterProblem = 12,\n                  TimestampRequest = 13,\n                  TimestampReply = 14,\n                  InformationRequest = 15,\n                  InformationReply = 16,\n                  AddressMaskRequest = 17,\n                  AddressMaskReply = 18\n            }\n", "            public const int ICMP_HEADER_LENGTH = 20;\n\n            // ICMP headers\n            public byte _type { get; set; }\n            public byte _code { get; set; }\n            public ushort _checksum { get; set; }\n\n            // ICMP payload\n            public byte[] _payload { get; set; }\n\n            // Serializes the packet and returns it as a byte Array\n            public byte[] Serialize()\n            {\n                  byte[] packet = new byte[4 + _payload.Length];\n                  packet[0] = _type;\n                  packet[1] = _code;\n                  packet[2] = (byte)(_checksum >> 8);\n                  packet[3] = (byte)(_checksum & 0xFF);\n                  Array.Copy(_payload, 0, packet, 4, _payload.Length);\n                  return packet;\n            }\n\n            // Deserializes a byte Array into an ICMP packet", "            public static ICMP Deserialize(byte[] packet)\n            {\n                  if (packet.Length < ICMP_HEADER_LENGTH) { return null; }\n\n                  ICMP icmp = new ICMP();\n                  icmp._type = packet[0];\n                  icmp._code = packet[1];\n                  icmp._checksum = (ushort)((packet[2] << 8) + packet[3]);\n                  icmp._payload = new byte[packet.Length - 4];\n                  Array.Copy(packet, 4, icmp._payload, 0, packet.Length - 4);\n                  return icmp;\n            }\n ", "            public override string ToString()\n            {\n                  return $\"### [ICMP] ###\\n\" +\n                         $\"\\n\\nType: {_type}\\n\" +\n                         $\"\\n\\nCode: {_code}\\n\" +\n                         $\"\\n\\nChecksum: {_checksum}\\n\";\n            }\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
{"filename": "src/ethernet.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System;\nusing System.Net;\nusing System.Net.NetworkInformation;\n\nnamespace ProtoIP\n{\n      // Provides an interface for creating and manipulating Ethernet frames\n      // to be used with the NetPods.", "{\n      // Provides an interface for creating and manipulating Ethernet frames\n      // to be used with the NetPods.\n      public class Ethernet\n      {\n            public const int MAC_ADDRESS_LENGTH = 6;\n            public const int ETH_HEADER_LENGTH = 14;\n            public const int ETH_TYPE_IP = 0x0800;\n            public const int ETH_TYPE_ARP = 0x0806;\n            public static readonly byte[] BROADCAST_MAC = Ethernet.GetMACAddressBytesFromString(\"FF:FF:FF:FF:FF:FF\");\n\n            public byte[] _destinationMAC { get; private set; }\n            public byte[] _sourceMAC { get; private set; }", "            public const int ETH_TYPE_ARP = 0x0806;\n            public static readonly byte[] BROADCAST_MAC = Ethernet.GetMACAddressBytesFromString(\"FF:FF:FF:FF:FF:FF\");\n\n            public byte[] _destinationMAC { get; private set; }\n            public byte[] _sourceMAC { get; private set; }\n            public ushort _type { get; private set; }\n            public byte[] _payload { get; private set; }\n\n            /* CONSTRUCTORS */\n            public Ethernet() \n            {\n                  _type = ETH_TYPE_IP;\n            }\n\n            public Ethernet(string destinationMAC, string sourceMAC, ushort type = ETH_TYPE_IP, byte[] payload = null)\n            {\n                  _destinationMAC = GetMACAddressBytesFromString(destinationMAC);\n                  _sourceMAC = GetMACAddressBytesFromString(sourceMAC);\n                  _type = type;\n                  _payload = payload;\n            }\n\n            public Ethernet(byte[] destinationMAC, byte[] sourceMAC, ushort type = ETH_TYPE_IP, byte[] payload = null)\n            {\n                  _destinationMAC = destinationMAC;\n                  _sourceMAC = sourceMAC;\n                  _type = type;\n                  _payload = payload;\n            }\n\n            // Serializes the packet and returns it as a byte Array\n            public byte[] Serialize()\n            {\n                  byte[] packet = new byte[ETH_HEADER_LENGTH + _payload.Length];\n                  Array.Copy(_destinationMAC, 0, packet, 0, MAC_ADDRESS_LENGTH);\n                  Array.Copy(_sourceMAC, 0, packet, MAC_ADDRESS_LENGTH, MAC_ADDRESS_LENGTH);\n                  packet[12] = (byte)(_type >> 8);\n                  packet[13] = (byte)(_type & 0xFF);\n                  Array.Copy(_payload, 0, packet, ETH_HEADER_LENGTH, _payload.Length);\n                  return packet;\n            }\n\n            // Deserializes the incoming byte array and returns an Ethernet object", "            public static Ethernet Deserialize(byte[] packet)\n            {\n                  Ethernet ethernet = new Ethernet();\n                  ethernet._destinationMAC = new byte[MAC_ADDRESS_LENGTH];\n                  ethernet._sourceMAC = new byte[MAC_ADDRESS_LENGTH];\n                  ethernet._payload = new byte[packet.Length - ETH_HEADER_LENGTH];\n\n                  Array.Copy(packet, 0, ethernet._destinationMAC, 0, MAC_ADDRESS_LENGTH);\n                  Array.Copy(packet, MAC_ADDRESS_LENGTH, ethernet._sourceMAC, 0, MAC_ADDRESS_LENGTH);\n                  ethernet._type = (ushort)((packet[12] << 8) + packet[13]);\n                  Array.Copy(packet, ETH_HEADER_LENGTH, ethernet._payload, 0, packet.Length - ETH_HEADER_LENGTH);\n\n                  Console.WriteLine(ethernet.ToString());\n\n                  return ethernet;\n            }\n\n            // Returns the MAC address bytes of the specified MAC address", "            public static byte[] GetMACAddressBytesFromString(string macAddress)\n            {\n                  string[] macAddressBytes = macAddress.Split(':');\n                  byte[] bytes = new byte[MAC_ADDRESS_LENGTH];\n\n                  for (int i = 0; i < MAC_ADDRESS_LENGTH; i++)\n                  {\n                        bytes[i] = Convert.ToByte(macAddressBytes[i], 16);\n                  }\n\n                  return bytes;\n            }\n\n            // Returns the MAC address bytes of the specified IP address.\n            // Attempts to fetch the MAC address from an IP address using an ARP request.\n            // If the ARP request fails, it iterates through all network interfaces\n            // to find the one with the specified IP address.", "            public static byte[] GetMACAddressBytesFromIP(string ipAddressString)\n            {\n                  byte[] macAddressBytes = null;\n \n                  if (!ArpRequestWithWebClient(ipAddressString, macAddressBytes))\n                  {\n                        Console.WriteLine(\"ARP request failed. Attempting to fetch MAC address from network interfaces.\");\n                        FetchNetworkInterfacesForIPAddress(ipAddressString, macAddressBytes);\n                  }\n\n                  if (macAddressBytes == null)\n                  {\n                        throw new Exception(\"Could not find MAC address for the specified IP address: \" + ipAddressString + \".\");\n                  }\n\n                  return macAddressBytes;\n            }\n\n            // Iterates through all network interfaces to find the one with the specified IP address.\n            // Populates the outputBuffer with the MAC address bytes of the specified IP address.\n            //\n            // Returns true if the MAC address was found, false otherwise.", "                  if (macAddressBytes == null)\n                  {\n                        throw new Exception(\"Could not find MAC address for the specified IP address: \" + ipAddressString + \".\");\n                  }\n\n                  return macAddressBytes;\n            }\n\n            // Iterates through all network interfaces to find the one with the specified IP address.\n            // Populates the outputBuffer with the MAC address bytes of the specified IP address.\n            //\n            // Returns true if the MAC address was found, false otherwise.", "            public static void FetchNetworkInterfacesForIPAddress(string ipAddressString, byte[] macAddressBytes)\n            {\n                  IPAddress ipAddress = IPAddress.Parse(ipAddressString);\n                  foreach (NetworkInterface networkInterface in NetworkInterface.GetAllNetworkInterfaces())\n                  {\n                        foreach (UnicastIPAddressInformation ipAddressInfo in networkInterface.GetIPProperties().UnicastAddresses)\n                        {\n                              if (ipAddressInfo.Address.Equals(ipAddress))\n                              {\n                                    macAddressBytes = networkInterface.GetPhysicalAddress().GetAddressBytes();\n                              }\n                        }\n                  }\n            }\n\n            // Attempts to send an ARP request to a specified IP address using a WebClient.\n            // Populates the outputBuffer with the MAC address bytes of the specified IP address\n            // returned by the ARP request.\n            //\n            // Returns true if the ARP request was successful, false otherwise.", "            public static bool ArpRequestWithWebClient(string ipAddress, byte[] outputBuffer)\n            {\n                   using (var client = new WebClient())\n                  {\n                        client.Headers.Add(\"User-Agent\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.2; .NET CLR 1.0.3705;)\");\n                        try\n                        {\n                              byte[] response = client.DownloadData($\"http://{ipAddress}\");\n                              if (response.Length >= MAC_ADDRESS_LENGTH)\n                              {\n                                    outputBuffer = new byte[MAC_ADDRESS_LENGTH];\n                                    Array.Copy(response, 0, outputBuffer, 0, MAC_ADDRESS_LENGTH);\n                              }\n                        }", "                              if (response.Length >= MAC_ADDRESS_LENGTH)\n                              {\n                                    outputBuffer = new byte[MAC_ADDRESS_LENGTH];\n                                    Array.Copy(response, 0, outputBuffer, 0, MAC_ADDRESS_LENGTH);\n                              }\n                        }\n                        catch (WebException)\n                        {\n                              return false;\n                        }\n                  }\n\n                  return outputBuffer != null;\n            }\n\n            // Returns the MAC address string of the specified MAC address bytes", "            public static string MacAddressBytesToString(byte[] macAddressBytes)\n            {\n                  string macAddress = string.Empty;\n                  for (int i = 0; i < macAddressBytes.Length; i++)\n                  {\n                        macAddress += macAddressBytes[i].ToString(\"X2\");\n                        if (i != macAddressBytes.Length - 1)\n                        {\n                              macAddress += \":\";\n                        }\n                  }\n                  return macAddress;\n            }\n \n            /* OPERATOR OVERLOADS */\n            //\n            // Operator overload for the / operator.\n            // Similar to scapy's Ether() / IP() / TCP() syntax.\n            // You can use it as a composition packet builder.\n            //\n            // Add raw data to the payload of the last layer encapsulated\n            // in the ethernet frame.", "            public static Ethernet operator / (Ethernet ethernet, byte[] data)\n            {\n                  if (ethernet._payload == null)\n                  {\n                        ethernet._payload = data;\n                        return ethernet;\n                  }\n\n                  if (ethernet._type == Ethernet.ETH_TYPE_IP)\n                  {\n                        IP ipPacket = IP.Deserialize(ethernet._payload);", "                  if (ethernet._type == Ethernet.ETH_TYPE_IP)\n                  {\n                        IP ipPacket = IP.Deserialize(ethernet._payload);\n                        if (ipPacket._payload == null)\n                        {\n                              ipPacket._payload = data;\n                              ethernet._payload = ipPacket.Serialize();\n                              return ethernet;\n                        }\n\n                        switch (ipPacket._protocol)\n                        {\n                              case (byte)IP.IPProtocolPacketType.TCP:\n                                    TCP tcpPacket = TCP.Deserialize(ipPacket._payload);\n                                    tcpPacket._payload = data;\n                                    ipPacket._payload = tcpPacket.Serialize();\n                                    ethernet._payload = ipPacket.Serialize();\n                                    break;\n                              case (byte)IP.IPProtocolPacketType.UDP:\n                                    UDP udpPacket = UDP.Deserialize(ipPacket._payload);\n                                    udpPacket._payload = data;\n                                    ipPacket._payload = udpPacket.Serialize();\n                                    ethernet._payload = ipPacket.Serialize();\n                                    break;\n                              case (byte)IP.IPProtocolPacketType.ICMP:\n                                    ICMP icmpPacket = ICMP.Deserialize(ipPacket._payload);\n                                    icmpPacket._payload = data;\n                                    ipPacket._payload = icmpPacket.Serialize();\n                                    ethernet._payload = ipPacket.Serialize();\n                                    break;\n                        }\n                  }", "                  else if (ethernet._type == Ethernet.ETH_TYPE_ARP)\n                  {\n                        throw new Exception(\"Cannot add raw data to an ARP packet as it does not contain a payload buffer.\");\n                  }\n\n                  return ethernet;\n            }\n\n            // Encapsulate an IP packet inside an Ethernet frame.\n            //\n            // If the ethernet layer doesn't have a source & destination MAC address,\n            // fetch the MAC address from the given source & destination IP\n            // and assign it to the ethernet layer.\n            //\n            // ETH / IP", "            public static Ethernet operator / (Ethernet ethernet, IP ipPacket)\n            {\n                  if (ethernet._destinationMAC == null)\n                  {\n                        byte[] ipBytes = ipPacket._destinationAddress.GetAddressBytes();\n                        string ip = $\"{ipBytes[0]}.{ipBytes[1]}.{ipBytes[2]}.{ipBytes[3]}\";\n                        ethernet._destinationMAC = GetMACAddressBytesFromIP(ip);\n                  }\n\n                  if (ethernet._sourceMAC == null)\n                  {\n                        byte[] ipBytes = ipPacket._sourceAddress.GetAddressBytes();\n                        string ip = $\"{ipBytes[0]}.{ipBytes[1]}.{ipBytes[2]}.{ipBytes[3]}\";\n                        ethernet._sourceMAC = GetMACAddressBytesFromIP(ip);\n                  }\n\n                  ethernet._type = Ethernet.ETH_TYPE_IP;\n                  ethernet._payload = ipPacket.Serialize();\n                  return ethernet;\n            }\n\n            // Encapsulate an ARP packet inside an Ethernet frame.\n            //\n            // If the ethernet layer doesn't have a source & destination MAC address,\n            // the destination MAC address is set to the broadcast MAC address, and the\n            // source MAC address is fetched from the given source IP address.\n            //\n            // ETH / ARP", "                  if (ethernet._sourceMAC == null)\n                  {\n                        byte[] ipBytes = ipPacket._sourceAddress.GetAddressBytes();\n                        string ip = $\"{ipBytes[0]}.{ipBytes[1]}.{ipBytes[2]}.{ipBytes[3]}\";\n                        ethernet._sourceMAC = GetMACAddressBytesFromIP(ip);\n                  }\n\n                  ethernet._type = Ethernet.ETH_TYPE_IP;\n                  ethernet._payload = ipPacket.Serialize();\n                  return ethernet;\n            }\n\n            // Encapsulate an ARP packet inside an Ethernet frame.\n            //\n            // If the ethernet layer doesn't have a source & destination MAC address,\n            // the destination MAC address is set to the broadcast MAC address, and the\n            // source MAC address is fetched from the given source IP address.\n            //\n            // ETH / ARP", "            public static Ethernet operator / (Ethernet ethernet, ARP arpPacket)\n            {\n                  if (ethernet._destinationMAC == null || ethernet._destinationMAC != BROADCAST_MAC) \n                  { \n                        ethernet._destinationMAC = BROADCAST_MAC; \n                  }\n\n                  if (ethernet._sourceMAC == null)\n                  {\n                        byte[] ipBytes = arpPacket._senderProtocolAddress;\n                        string ip = $\"{ipBytes[0]}.{ipBytes[1]}.{ipBytes[2]}.{ipBytes[3]}\";\n                        ethernet._sourceMAC = GetMACAddressBytesFromIP(ip);\n                  }\n\n                  ethernet._type = Ethernet.ETH_TYPE_ARP;\n                  ethernet._payload = arpPacket.Serialize();\n                  return ethernet;\n            }\n\n            // Encapsulate a TCP packet inside an IP packet inside an Ethernet frame.\n            // ETH / IP / TCP", "            public static Ethernet operator / (Ethernet ethernet, TCP tcpPacket)\n            {\n                  if (ethernet._payload == null || ethernet._payload.Length < IP.IP_HEADER_LENGTH)\n                  {\n                        throw new Exception(\"Unable to add TCP layer because the ethernet layer doesn't have a valid IP packet\");\n                  }\n\n                  IP ipPacket = IP.Deserialize(ethernet._payload);\n                  ipPacket._protocol = (byte)IP.IPProtocolPacketType.TCP;\n                  ipPacket._payload = tcpPacket.Serialize();\n                  ethernet._payload = ipPacket.Serialize();\n                  return ethernet;\n            }\n\n            // Encapsulate a UDP packet inside an IP packet inside an Ethernet frame.\n            // ETH / IP / UDP", "            public static Ethernet operator / (Ethernet ethernet, UDP udpPacket)\n            {\n                  if (ethernet._payload == null || ethernet._payload.Length < IP.IP_HEADER_LENGTH)\n                  {\n                        throw new Exception(\"Unable to add UDP layer because the ethernet layer doesn't have a valid IP packet\");\n                  }\n\n                  IP ipPacket = IP.Deserialize(ethernet._payload);\n                  ipPacket._protocol = (byte)IP.IPProtocolPacketType.UDP;\n                  ipPacket._payload = udpPacket.Serialize();\n                  ethernet._payload = ipPacket.Serialize();\n                  return ethernet;\n            }\n\n            // Encapsulate an ICMP packet inside an IP packet inside an Ethernet frame.\n            // ETH / IP / ICMP", "            public static Ethernet operator / (Ethernet ethernet, ICMP icmpPacket)\n            {\n                  if (ethernet._payload == null || ethernet._payload.Length < IP.IP_HEADER_LENGTH)\n                  {\n                        throw new Exception(\"Unable to add ICMP layer because the ethernet layer doesn't have a valid IP packet\");\n                  }\n\n                  IP ipPacket = IP.Deserialize(ethernet._payload);\n                  ipPacket._protocol = (byte)IP.IPProtocolPacketType.ICMP;\n                  ipPacket._payload = icmpPacket.Serialize();\n                  ethernet._payload = ipPacket.Serialize();\n                  return ethernet;\n            }\n", "            public override string ToString()\n            {\n                  return $\"### [Ethernet] ###\\n\" +\n                        $\"Destination MAC: {MacAddressBytesToString(_destinationMAC)}\\n\" +\n                        $\"Source MAC: {MacAddressBytesToString(_sourceMAC)}\\n\" +\n                        $\"Type: {(_type == ETH_TYPE_IP ? \"IP\" : \"ARP\")}\";\n            }\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
{"filename": "src/tcp.cs", "chunked_list": ["// Copyright (c) 2023, Jo\u00e3o Matos\n// Check the end of the file for extended copyright notice.\n\nusing System;\nusing System.Net;\nusing System.Net.Sockets;\n\nnamespace ProtoIP\n{\n      // Provides an interface for creating and manipulating TCP segments\n      // to be used with the NetPods.", "{\n      // Provides an interface for creating and manipulating TCP segments\n      // to be used with the NetPods.\n      public class TCP\n      {\n            public const int TCP_HEADER_LENGTH = 20;\n\n            // Header\n            public ushort _sourcePort         { get; set; }\n            public ushort _destinationPort    { get; set; }\n            public int _sequenceNumber        { get; set; }", "            public ushort _sourcePort         { get; set; }\n            public ushort _destinationPort    { get; set; }\n            public int _sequenceNumber        { get; set; }\n            public int _acknowledgementNumber { get; set; }\n            public ushort _dataOffset         { get; set; }\n            public ushort _reserved           { get; set; }\n            public ushort _flags              { get; set; }\n            public ushort _windowSize         { get; set; }\n            public ushort _checksum           { get; set; }\n            public ushort _urgentPointer      { get; set; }\n            public byte[] _options            { get; set; }\n\n            // Payload\n            public byte[] _payload { get; set; }\n\n            /* CONSTRUCTORS */\n            public TCP() { }\n\n            public TCP(ushort sourcePort, ushort destinationPort)\n            {\n                  _sourcePort = sourcePort;\n                  _destinationPort = destinationPort;\n                  _sequenceNumber = 0;\n                  _acknowledgementNumber = 0;\n                  _dataOffset = 5;\n                  _reserved = 0;\n                  _flags = 0;\n                  _windowSize = 0;\n                  _checksum = 0;\n                  _urgentPointer = 0;\n                  _options = new byte[0];\n                  _payload = new byte[0];\n            }\n\n            // Serializes the packet and returns it as a byte Array\n            public byte[] Serialize()\n            {\n                  byte[] packet = new byte[TCP_HEADER_LENGTH + _payload.Length];\n                  packet[0] = (byte)(_sourcePort >> 8);\n                  packet[1] = (byte)(_sourcePort & 0xFF);\n                  packet[2] = (byte)(_destinationPort >> 8);\n                  packet[3] = (byte)(_destinationPort & 0xFF);\n                  packet[4] = (byte)(_sequenceNumber >> 24);\n                  packet[5] = (byte)(_sequenceNumber >> 16);\n                  packet[6] = (byte)(_sequenceNumber >> 8);\n                  packet[7] = (byte)(_sequenceNumber & 0xFF);\n                  packet[8] = (byte)(_acknowledgementNumber >> 24);\n                  packet[9] = (byte)(_acknowledgementNumber >> 16);\n                  packet[10] = (byte)(_acknowledgementNumber >> 8);\n                  packet[11] = (byte)(_acknowledgementNumber & 0xFF);\n                  packet[12] = (byte)((_dataOffset << 4) + _reserved);\n                  packet[13] = (byte)_flags;\n                  packet[14] = (byte)(_windowSize >> 8);\n                  packet[15] = (byte)(_windowSize & 0xFF);\n                  packet[16] = (byte)(_checksum >> 8);\n                  packet[17] = (byte)(_checksum & 0xFF);\n                  packet[18] = (byte)(_urgentPointer >> 8);\n                  packet[19] = (byte)(_urgentPointer & 0xFF);\n                  Array.Copy(_options, 0, packet, 20, _options.Length);\n                  Array.Copy(_payload, 0, packet, TCP_HEADER_LENGTH, _payload.Length);\n                  return packet;\n            }\n\n            // Deserializes a byte Array into a TCP packet", "            public ushort _checksum           { get; set; }\n            public ushort _urgentPointer      { get; set; }\n            public byte[] _options            { get; set; }\n\n            // Payload\n            public byte[] _payload { get; set; }\n\n            /* CONSTRUCTORS */\n            public TCP() { }\n\n            public TCP(ushort sourcePort, ushort destinationPort)\n            {\n                  _sourcePort = sourcePort;\n                  _destinationPort = destinationPort;\n                  _sequenceNumber = 0;\n                  _acknowledgementNumber = 0;\n                  _dataOffset = 5;\n                  _reserved = 0;\n                  _flags = 0;\n                  _windowSize = 0;\n                  _checksum = 0;\n                  _urgentPointer = 0;\n                  _options = new byte[0];\n                  _payload = new byte[0];\n            }\n\n            // Serializes the packet and returns it as a byte Array\n            public byte[] Serialize()\n            {\n                  byte[] packet = new byte[TCP_HEADER_LENGTH + _payload.Length];\n                  packet[0] = (byte)(_sourcePort >> 8);\n                  packet[1] = (byte)(_sourcePort & 0xFF);\n                  packet[2] = (byte)(_destinationPort >> 8);\n                  packet[3] = (byte)(_destinationPort & 0xFF);\n                  packet[4] = (byte)(_sequenceNumber >> 24);\n                  packet[5] = (byte)(_sequenceNumber >> 16);\n                  packet[6] = (byte)(_sequenceNumber >> 8);\n                  packet[7] = (byte)(_sequenceNumber & 0xFF);\n                  packet[8] = (byte)(_acknowledgementNumber >> 24);\n                  packet[9] = (byte)(_acknowledgementNumber >> 16);\n                  packet[10] = (byte)(_acknowledgementNumber >> 8);\n                  packet[11] = (byte)(_acknowledgementNumber & 0xFF);\n                  packet[12] = (byte)((_dataOffset << 4) + _reserved);\n                  packet[13] = (byte)_flags;\n                  packet[14] = (byte)(_windowSize >> 8);\n                  packet[15] = (byte)(_windowSize & 0xFF);\n                  packet[16] = (byte)(_checksum >> 8);\n                  packet[17] = (byte)(_checksum & 0xFF);\n                  packet[18] = (byte)(_urgentPointer >> 8);\n                  packet[19] = (byte)(_urgentPointer & 0xFF);\n                  Array.Copy(_options, 0, packet, 20, _options.Length);\n                  Array.Copy(_payload, 0, packet, TCP_HEADER_LENGTH, _payload.Length);\n                  return packet;\n            }\n\n            // Deserializes a byte Array into a TCP packet", "            public static TCP Deserialize(byte[] packet)\n            {\n                  if (packet.Length < TCP_HEADER_LENGTH) { return null; }\n                  \n                  TCP tcp = new TCP();\n                  tcp._sourcePort = (ushort)((packet[0] << 8) + packet[1]);\n                  tcp._destinationPort = (ushort)((packet[2] << 8) + packet[3]);\n                  tcp._sequenceNumber = (packet[4] << 24) + (packet[5] << 16) + (packet[6] << 8) + packet[7];\n                  tcp._acknowledgementNumber = (packet[8] << 24) + (packet[9] << 16) + (packet[10] << 8) + packet[11];\n                  tcp._dataOffset = (ushort)((packet[12] & 0xF0) >> 4);\n                  tcp._reserved = (ushort)(packet[12] & 0x0F);\n                  tcp._flags = packet[13];\n                  tcp._windowSize = (ushort)((packet[14] << 8) + packet[15]);\n                  tcp._checksum = (ushort)((packet[16] << 8) + packet[17]);\n                  tcp._urgentPointer = (ushort)((packet[18] << 8) + packet[19]);\n                  tcp._options = new byte[tcp._dataOffset * 4 - TCP_HEADER_LENGTH];\n                  Array.Copy(packet, 20, tcp._options, 0, tcp._options.Length);\n                  tcp._payload = new byte[packet.Length - tcp._dataOffset * 4];\n                  Array.Copy(packet, tcp._dataOffset * 4, tcp._payload, 0, tcp._payload.Length);\n                  return tcp;\n            }\n ", "            public override string ToString()\n            {\n                  return $\"    ### [TCP] ###\\n\" +\n                         $\"    Source Port: {_sourcePort}\\n\" +\n                         $\"    Destination Port: {_destinationPort}\\n\" +\n                         $\"    Sequence Number: {_sequenceNumber}\\n\" +\n                         $\"    Acknowledgement Number: {_acknowledgementNumber}\\n\" +\n                         $\"    Data Offset: {_dataOffset}\\n\" +\n                         $\"    Reserved: {_reserved}\\n\" +\n                         $\"    Flags: {_flags}\\n\" +\n                         $\"    Window Size: {_windowSize}\\n\" +\n                         $\"    Checksum: {_checksum}\\n\" +\n                         $\"    Urgent Pointer: {_urgentPointer}\\n\" +\n                         $\"    Options: {_options}\";\n            }\n      }\n}\n\n// MIT License\n// \n// Copyright (c) 2023 Jo\u00e3o Matos\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n"]}
