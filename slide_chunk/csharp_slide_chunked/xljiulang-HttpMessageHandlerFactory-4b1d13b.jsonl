{"filename": "HttpMessageHandlerFactory/CookieHttpHandler.cs", "chunked_list": ["\ufeffusing System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace HttpMessageHandlerFactory\n{\n    /// <summary>\n    /// cookie\u5904\u7406\u8005", "    /// <summary>\n    /// cookie\u5904\u7406\u8005\n    /// </summary>\n    sealed class CookieHttpHandler : DelegatingHandler\n    {\n        private const string COOKIE_HEADER = \"Cookie\";\n        private const string SET_COOKIE_HEADER = \"Set-Cookie\";\n        private readonly CookieContainer cookieContainer;\n\n        public CookieHttpHandler(HttpMessageHandler innerHandler, CookieContainer cookieContainer)\n        {\n            this.InnerHandler = innerHandler;\n            this.cookieContainer = cookieContainer;\n        }\n", "        protected override HttpResponseMessage Send(HttpRequestMessage request, CancellationToken cancellationToken)\n        {\n            UseCookie(request, this.cookieContainer);\n            var response = base.Send(request, cancellationToken);\n            SetCookie(request.RequestUri, response, this.cookieContainer);\n            return response;\n        }\n\n        protected async override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n        {\n            UseCookie(request, this.cookieContainer);\n            var response = await base.SendAsync(request, cancellationToken);\n            SetCookie(request.RequestUri, response, this.cookieContainer);\n            return response;\n        }\n\n        /// <summary>\n        /// \u4f7f\u7528Cookie\u5230\u8bf7\u6c42\n        /// </summary>\n        /// <param name=\"reqeust\"></param>\n        /// <param name=\"cookieContainer\"></param>", "        protected async override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n        {\n            UseCookie(request, this.cookieContainer);\n            var response = await base.SendAsync(request, cancellationToken);\n            SetCookie(request.RequestUri, response, this.cookieContainer);\n            return response;\n        }\n\n        /// <summary>\n        /// \u4f7f\u7528Cookie\u5230\u8bf7\u6c42\n        /// </summary>\n        /// <param name=\"reqeust\"></param>\n        /// <param name=\"cookieContainer\"></param>", "        private static void UseCookie(\n            HttpRequestMessage reqeust,\n            CookieContainer cookieContainer)\n        {\n            var requestUri = reqeust.RequestUri;\n            if (requestUri == null || requestUri.IsAbsoluteUri == false)\n            {\n                return;\n            }\n\n            var cookieHeader = cookieContainer.GetCookieHeader(requestUri);\n            reqeust.Headers.TryAddWithoutValidation(COOKIE_HEADER, cookieHeader);\n        }\n\n\n        /// <summary>\n        /// \u8bbe\u7f6eCookie\u5230CookieContainer\n        /// </summary>\n        /// <param name=\"requestUri\"></param>\n        /// <param name=\"response\"></param>\n        /// <param name=\"cookieContainer\"></param>", "        private static void SetCookie(\n            Uri? requestUri,\n            HttpResponseMessage response,\n            CookieContainer cookieContainer)\n        {\n            if (requestUri == null ||\n                response.Headers.TryGetValues(SET_COOKIE_HEADER, out var cookies) == false)\n            {\n                return;\n            }\n", "            foreach (var cookieHeader in cookies)\n            {\n                try\n                {\n                    cookieContainer.SetCookies(requestUri, cookieHeader);\n                }\n                catch (CookieException)\n                {\n                }\n            }\n        }\n\n    }\n}\n\n"]}
{"filename": "HttpMessageHandlerFactory/HttpMessageHandlerFactoryExtensions.cs", "chunked_list": ["\ufeffusing System;\nusing System.Net;\nusing System.Net.Http;\n\nnamespace HttpMessageHandlerFactory\n{\n    /// <summary>\n    /// HttpMessageHandlerFactory\u6269\u5c55\n    /// </summary>\n    public static class HttpMessageHandlerFactoryExtensions\n    {\n        /// <summary>\n        /// \u521b\u5efaHttp\u5ba2\u6237\u7aef\n        /// </summary>\n        /// <param name=\"factory\"></param>\n        /// <param name=\"name\">\u522b\u540d</param>\n        /// <param name=\"proxyUri\">\u652f\u6301\u643a\u5e26UserInfo\u7684\u4ee3\u7406\u5730\u5740</param>\n        /// <param name=\"cookieContainer\">cookie\u5bb9\u5668</param>\n        /// <returns></returns>", "    /// </summary>\n    public static class HttpMessageHandlerFactoryExtensions\n    {\n        /// <summary>\n        /// \u521b\u5efaHttp\u5ba2\u6237\u7aef\n        /// </summary>\n        /// <param name=\"factory\"></param>\n        /// <param name=\"name\">\u522b\u540d</param>\n        /// <param name=\"proxyUri\">\u652f\u6301\u643a\u5e26UserInfo\u7684\u4ee3\u7406\u5730\u5740</param>\n        /// <param name=\"cookieContainer\">cookie\u5bb9\u5668</param>\n        /// <returns></returns>", "        public static HttpClient CreateClient(this IHttpMessageHandlerFactory factory, string name, Uri? proxyUri = null, CookieContainer? cookieContainer = null)\n        {\n            var httpHandler = factory.CreateHandler(name, proxyUri, cookieContainer);\n            return new HttpClient(httpHandler, disposeHandler: false);\n        }\n\n        /// <summary>\n        /// \u521b\u5efaHttp\u6267\u884c\u5668\n        /// </summary>\n        /// <param name=\"factory\"></param>\n        /// <param name=\"name\">\u522b\u540d</param>\n        /// <param name=\"proxyUri\">\u652f\u6301\u643a\u5e26UserInfo\u7684\u4ee3\u7406\u5730\u5740</param>\n        /// <param name=\"cookieContainer\">cookie\u5bb9\u5668</param>\n        /// <returns></returns>", "        public static HttpMessageInvoker CreateInvoker(this IHttpMessageHandlerFactory factory, string name, Uri? proxyUri = null, CookieContainer? cookieContainer = null)\n        {\n            var httpHandler = factory.CreateHandler(name, proxyUri, cookieContainer);\n            return new HttpMessageInvoker(httpHandler, disposeHandler: false);\n        }\n\n        private static HttpMessageHandler CreateHandler(this IHttpMessageHandlerFactory factory, string name, Uri? proxyUri, CookieContainer? cookieContainer)\n        {\n            var httpHandler = factory.CreateHandler(name, proxyUri);\n            if (cookieContainer != null)\n            {\n                httpHandler = new CookieHttpHandler(httpHandler, cookieContainer);\n            }\n            return httpHandler;\n        }\n    }\n}\n", "            if (cookieContainer != null)\n            {\n                httpHandler = new CookieHttpHandler(httpHandler, cookieContainer);\n            }\n            return httpHandler;\n        }\n    }\n}\n"]}
{"filename": "HttpMessageHandlerFactory/IHttpMessageHandlerFactory.cs", "chunked_list": ["\ufeffusing System;\nusing System.Net.Http;\n\nnamespace HttpMessageHandlerFactory\n{\n    /// <summary>\n    /// Http\u6d88\u606f\u5904\u7406\u8005\u5de5\u5382\n    /// </summary>\n    public interface IHttpMessageHandlerFactory\n    {\n        /// <summary>\n        /// \u521b\u5efa\u7528\u4e8e\u8bf7\u6c42\u7684HttpMessageHandler\n        /// </summary>\n        /// <param name=\"name\">\u522b\u540d</param>\n        /// <param name=\"proxyUri\">\u652f\u6301\u643a\u5e26UserInfo\u7684\u4ee3\u7406\u5730\u5740</param> \n        /// <returns></returns>\n        HttpMessageHandler CreateHandler(string name, Uri? proxyUri);\n    }\n}\n", "    public interface IHttpMessageHandlerFactory\n    {\n        /// <summary>\n        /// \u521b\u5efa\u7528\u4e8e\u8bf7\u6c42\u7684HttpMessageHandler\n        /// </summary>\n        /// <param name=\"name\">\u522b\u540d</param>\n        /// <param name=\"proxyUri\">\u652f\u6301\u643a\u5e26UserInfo\u7684\u4ee3\u7406\u5730\u5740</param> \n        /// <returns></returns>\n        HttpMessageHandler CreateHandler(string name, Uri? proxyUri);\n    }\n}\n"]}
{"filename": "HttpMessageHandlerFactory/HttpMessageHandlerOptions.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Net.Http;\n\nnamespace HttpMessageHandlerFactory\n{\n    /// <summary>\n    /// HttpMessageHandler\u9009\u9879\n    /// </summary>\n    public class HttpMessageHandlerOptions\n    {\n        /// <summary>\n        /// \u83b7\u53d6\u6216\u8bbe\u7f6e\u751f\u547d\u5468\u671f\n        /// \u9ed8\u8ba4\u4e24\u5206\u949f\n        /// </summary>", "    /// </summary>\n    public class HttpMessageHandlerOptions\n    {\n        /// <summary>\n        /// \u83b7\u53d6\u6216\u8bbe\u7f6e\u751f\u547d\u5468\u671f\n        /// \u9ed8\u8ba4\u4e24\u5206\u949f\n        /// </summary>\n        public TimeSpan Lifetime { get; set; } = TimeSpan.FromMinutes(2d);\n\n        /// <summary>\n        /// \u83b7\u53d6\u5c5e\u6027\u8bb0\u5f55\u5b57\u5178\n        /// </summary>\n        public Dictionary<object, object> Properties { get; set; } = new();\n\n        /// <summary>\n        /// \u83b7\u53d6\u989d\u5916\u7684<see cref=\"DelegatingHandler\"/>\u521b\u5efa\u59d4\u6258\n        /// </summary>\n        public List<Func<IServiceProvider, DelegatingHandler>> AdditionalHandlers { get; } = new();\n\n        /// <summary>\n        /// \u83b7\u53d6\u57fa\u7840<see cref=\"SocketsHttpHandler\"/>\u7684\u914d\u7f6e\u59d4\u6258\n        /// </summary>\n        public List<Action<IServiceProvider, SocketsHttpHandler>> PrimaryHandlerConfigures { get; } = new();\n    }\n}\n"]}
{"filename": "HttpMessageHandlerFactory/Implementations/NonCapturingTimer.cs", "chunked_list": ["\ufeffusing System;\nusing System.Threading;\n\nnamespace HttpMessageHandlerFactory.Implementations\n{\n    static class NonCapturingTimer\n    {\n        public static Timer Create(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period)\n        {\n            if (callback is null)\n            {\n                throw new ArgumentNullException(nameof(callback));\n            }\n\n            // Don't capture the current ExecutionContext and its AsyncLocals onto the timer\n            bool restoreFlow = false;\n            try\n            {", "            if (callback is null)\n            {\n                throw new ArgumentNullException(nameof(callback));\n            }\n\n            // Don't capture the current ExecutionContext and its AsyncLocals onto the timer\n            bool restoreFlow = false;\n            try\n            {\n                if (!ExecutionContext.IsFlowSuppressed())\n                {\n                    ExecutionContext.SuppressFlow();\n                    restoreFlow = true;\n                }\n\n                return new Timer(callback, state, dueTime, period);\n            }\n            finally\n            {\n                // Restore the current ExecutionContext", "                if (!ExecutionContext.IsFlowSuppressed())\n                {\n                    ExecutionContext.SuppressFlow();\n                    restoreFlow = true;\n                }\n\n                return new Timer(callback, state, dueTime, period);\n            }\n            finally\n            {\n                // Restore the current ExecutionContext", "                if (restoreFlow)\n                {\n                    ExecutionContext.RestoreFlow();\n                }\n            }\n        }\n    }\n}\n"]}
{"filename": "HttpMessageHandlerFactory/Implementations/NameProxy.cs", "chunked_list": ["\ufeffusing System;\n\nnamespace HttpMessageHandlerFactory.Implementations\n{\n    /// <summary>\n    /// \u522b\u540d\u548c\u4ee3\u7406\n    /// </summary>\n    /// <param name=\"Name\">\u522b\u540d</param>\n    /// <param name=\"ProxyUri\">\u652f\u6301\u643a\u5e26UserInfo\u7684\u4ee3\u7406\u5730\u5740</param>\n    sealed record NameProxy(string Name, Uri? ProxyUri);", "    /// <param name=\"ProxyUri\">\u652f\u6301\u643a\u5e26UserInfo\u7684\u4ee3\u7406\u5730\u5740</param>\n    sealed record NameProxy(string Name, Uri? ProxyUri);\n}\n"]}
{"filename": "HttpMessageHandlerFactory/Implementations/LifetimeHttpHandler.cs", "chunked_list": ["\ufeffusing System.Net.Http;\n\nnamespace HttpMessageHandlerFactory.Implementations\n{\n    /// <summary>\n    /// \u8868\u793a\u81ea\u4e3b\u7ba1\u7406\u751f\u547d\u5468\u671f\u7684\u7684HttpMessageHandler\n    /// </summary>\n    sealed class LifetimeHttpHandler : DelegatingHandler\n    {\n        /// <summary>\n        /// \u5177\u6709\u751f\u547d\u5468\u671f\u7684HttpHandler\n        /// </summary> \n        /// <param name=\"httpHandler\"></param> \n        public LifetimeHttpHandler(HttpMessageHandler httpHandler)\n        {\n            this.InnerHandler = httpHandler;\n        }\n\n        /// <summary>\n        /// \u8fd9\u91cc\u4e0d\u91ca\u653e\u8d44\u6e90\n        /// </summary>\n        /// <param name=\"disposing\"></param>", "        protected override void Dispose(bool disposing)\n        {\n        }\n    }\n}\n"]}
{"filename": "HttpMessageHandlerFactory/Implementations/ActiveHandlerEntry.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.DependencyInjection;\nusing System;\nusing System.Diagnostics;\nusing System.Threading;\n\nnamespace HttpMessageHandlerFactory.Implementations\n{\n    /// <summary>\n    /// \u6d3b\u8dc3\u7684\u6761\u76ee\n    /// https://github.com/dotnet/runtime/blob/v7.0.0/src/libraries/Microsoft.Extensions.Http/src/ActiveHandlerTrackingEntry.cs", "    /// \u6d3b\u8dc3\u7684\u6761\u76ee\n    /// https://github.com/dotnet/runtime/blob/v7.0.0/src/libraries/Microsoft.Extensions.Http/src/ActiveHandlerTrackingEntry.cs\n    /// </summary>\n    sealed class ActiveHandlerEntry\n    {\n        private static readonly TimerCallback timerCallback = (s) => ((ActiveHandlerEntry)s!).Timer_Tick();\n\n        private readonly object root = new();\n        private bool timerInitialized = false;\n\n        private Timer? timer;\n        private TimerCallback? callback;\n", "        private bool timerInitialized = false;\n\n        private Timer? timer;\n        private TimerCallback? callback;\n\n        public TimeSpan Lifetime { get; }\n\n        public NameProxy NameProxy { get; }\n\n        public IServiceScope ServiceScope { get; }\n", "        public IServiceScope ServiceScope { get; }\n\n        public LifetimeHttpHandler LifetimeHttpHandler { get; }\n\n\n        public ActiveHandlerEntry(\n            TimeSpan lifetime,\n            NameProxy nameProxy,\n            IServiceScope serviceScope,\n            LifetimeHttpHandler lifetimeHttpHandler)\n        {\n            this.Lifetime = lifetime;\n            this.NameProxy = nameProxy;\n            this.ServiceScope = serviceScope;\n            this.LifetimeHttpHandler = lifetimeHttpHandler;\n        }\n\n", "        public void StartExpiryTimer(TimerCallback callback)\n        {\n            if (this.Lifetime == Timeout.InfiniteTimeSpan)\n            {\n                return;\n            }\n\n            if (Volatile.Read(ref this.timerInitialized))\n            {\n                return;\n            }\n\n            this.StartExpiryTimerSlow(callback);\n        }\n", "        private void StartExpiryTimerSlow(TimerCallback callback)\n        {\n            Debug.Assert(Lifetime != Timeout.InfiniteTimeSpan);\n\n            lock (this.root)\n            {\n                if (Volatile.Read(ref this.timerInitialized))\n                {\n                    return;\n                }\n\n                this.callback = callback;\n                this.timer = NonCapturingTimer.Create(timerCallback, this, Lifetime, Timeout.InfiniteTimeSpan);\n                this.timerInitialized = true;\n            }\n        }\n", "        private void Timer_Tick()\n        {\n            Debug.Assert(this.callback != null);\n            Debug.Assert(this.timer != null);\n\n            lock (this.root)\n            {\n                if (this.timer != null)\n                {\n                    this.timer.Dispose();\n                    this.timer = null;\n\n                    this.callback(this);\n                }\n            }\n        }\n    }\n}\n"]}
{"filename": "HttpMessageHandlerFactory/Implementations/NameRegistration.cs", "chunked_list": ["\ufeffusing System.Collections.Generic;\n\nnamespace HttpMessageHandlerFactory.Implementations\n{\n    /// <summary>\n    /// \u522b\u767b\u8bb0\n    /// </summary>\n    sealed class NameRegistration : HashSet<string>\n    {\n    }\n}\n"]}
{"filename": "HttpMessageHandlerFactory/Implementations/ExpiredHandlerEntryCleaner.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Logging.Abstractions;\nusing System;\nusing System.Collections.Concurrent;\nusing System.Diagnostics;\nusing System.Threading;\n\nnamespace HttpMessageHandlerFactory.Implementations\n{\n    /// <summary>", "{\n    /// <summary>\n    /// \u5df2\u8fc7\u671f\u7684\u6761\u76ee\u6e05\u9664\u5668\n    /// https://github.com/dotnet/runtime/blob/v7.0.0/src/libraries/Microsoft.Extensions.Http/src/DefaultHttpClientFactory.cs\n    /// </summary>\n    sealed partial class ExpiredHandlerEntryCleaner\n    {\n        private static readonly TimeSpan cleanupInterval = TimeSpan.FromSeconds(10d);\n        private static readonly TimerCallback cleanupCallback = s => ((ExpiredHandlerEntryCleaner)s!).CleanupTimer_Tick();\n\n        private Timer? cleanupTimer;", "        private static readonly TimerCallback cleanupCallback = s => ((ExpiredHandlerEntryCleaner)s!).CleanupTimer_Tick();\n\n        private Timer? cleanupTimer;\n        private readonly object cleanupTimerLock = new();\n        private readonly object cleanupActiveLock = new();\n        private readonly ConcurrentQueue<ExpiredHandlerEntry> expiredHandlerEntries = new();\n        private readonly ILogger<ExpiredHandlerEntryCleaner> logger;\n\n        /// <summary>\n        /// \u5df2\u8fc7\u671f\u7684\u6761\u76ee\u6e05\u9664\u5668\n        /// </summary>\n        public ExpiredHandlerEntryCleaner()\n            : this(NullLogger<ExpiredHandlerEntryCleaner>.Instance)\n        {\n        }\n\n        /// <summary>\n        /// \u5df2\u8fc7\u671f\u7684\u6761\u76ee\u6e05\u9664\u5668\n        /// </summary>\n        /// <param name=\"logger\"></param>\n        public ExpiredHandlerEntryCleaner(ILogger<ExpiredHandlerEntryCleaner> logger)\n        {\n            this.logger = logger;\n        }\n\n        /// <summary>\n        /// \u6dfb\u52a0\u8fc7\u671f\u6761\u76ee\n        /// </summary>\n        /// <param name=\"expiredEntry\"></param>", "        public void Add(ExpiredHandlerEntry expiredEntry)\n        {\n            Log.HandlerExpired(this.logger, expiredEntry.NameProxy.Name);\n\n            this.expiredHandlerEntries.Enqueue(expiredEntry);\n            this.StartCleanupTimer();\n        }\n\n        /// <summary>\n        /// \u542f\u52a8\u6e05\u6d01\n        /// </summary>", "        private void StartCleanupTimer()\n        {\n            lock (this.cleanupTimerLock)\n            {\n                this.cleanupTimer ??= NonCapturingTimer.Create(cleanupCallback, this, cleanupInterval, Timeout.InfiniteTimeSpan);\n            }\n        }\n\n        /// <summary>\n        /// \u505c\u6b62\u6e05\u6d01\n        /// </summary>", "        private void StopCleanupTimer()\n        {\n            lock (this.cleanupTimerLock)\n            {\n                this.cleanupTimer!.Dispose();\n                this.cleanupTimer = null;\n            }\n        }\n\n\n        private void CleanupTimer_Tick()\n        {\n            // Stop any pending timers, we'll restart the timer if there's anything left to process after cleanup.\n            //\n            // With the scheme we're using it's possible we could end up with some redundant cleanup operations.\n            // This is expected and fine.\n            //\n            // An alternative would be to take a lock during the whole cleanup process. This isn't ideal because it\n            // would result in threads executing ExpiryTimer_Tick as they would need to block on cleanup to figure out\n            // whether we need to start the timer.\n            this.StopCleanupTimer();\n", "        private void CleanupTimer_Tick()\n        {\n            // Stop any pending timers, we'll restart the timer if there's anything left to process after cleanup.\n            //\n            // With the scheme we're using it's possible we could end up with some redundant cleanup operations.\n            // This is expected and fine.\n            //\n            // An alternative would be to take a lock during the whole cleanup process. This isn't ideal because it\n            // would result in threads executing ExpiryTimer_Tick as they would need to block on cleanup to figure out\n            // whether we need to start the timer.\n            this.StopCleanupTimer();\n", "            if (!Monitor.TryEnter(this.cleanupActiveLock))\n            {\n                // We don't want to run a concurrent cleanup cycle. This can happen if the cleanup cycle takes\n                // a long time for some reason. Since we're running user code inside Dispose, it's definitely\n                // possible.\n                //\n                // If we end up in that position, just make sure the timer gets started again. It should be cheap\n                // to run a 'no-op' cleanup.\n                this.StartCleanupTimer();\n                return;\n            }\n\n            try\n            {\n\n                var initialCount = expiredHandlerEntries.Count;\n                Log.CleanupCycleStart(this.logger, initialCount);\n\n                var disposedCount = 0;", "                for (var i = 0; i < initialCount; i++)\n                {\n                    // Since we're the only one removing from _expired, TryDequeue must always succeed.\n                    this.expiredHandlerEntries.TryDequeue(out ExpiredHandlerEntry? entry);\n                    Debug.Assert(entry != null, \"Entry was null, we should always get an entry back from TryDequeue\");\n\n                    if (entry.CanDispose)\n                    {\n                        try\n                        {\n                            entry.InnerHandler.Dispose();\n                            entry.ServiceScope.Dispose();\n                            disposedCount++;\n                        }", "                        catch (Exception ex)\n                        {\n                            Log.CleanupItemFailed(this.logger, entry.NameProxy.Name, ex);\n                        }\n                    }\n                    else\n                    {\n                        // If the entry is still live, put it back in the queue so we can process it\n                        // during the next cleanup cycle.\n                        this.expiredHandlerEntries.Enqueue(entry);\n                    }\n                }\n                Log.CleanupCycleEnd(this.logger, disposedCount, this.expiredHandlerEntries.Count);\n            }\n            finally\n            {\n                Monitor.Exit(this.cleanupActiveLock);\n            }\n\n            // We didn't totally empty the cleanup queue, try again later.", "            if (!expiredHandlerEntries.IsEmpty)\n            {\n                this.StartCleanupTimer();\n            }\n        }\n\n        static partial class Log\n        {\n            [LoggerMessage(0, LogLevel.Debug, \"Starting HttpMessageHandler cleanup cycle with {initialCount} items\")]\n            public static partial void CleanupCycleStart(ILogger logger, int initialCount);\n\n            [LoggerMessage(1, LogLevel.Debug, \"Ending HttpMessageHandler cleanup, processed {disposedCount} items, remaining {remaining} items\")]", "            public static partial void CleanupCycleStart(ILogger logger, int initialCount);\n\n            [LoggerMessage(1, LogLevel.Debug, \"Ending HttpMessageHandler cleanup, processed {disposedCount} items, remaining {remaining} items\")]\n            public static partial void CleanupCycleEnd(ILogger logger, int disposedCount, int remaining);\n\n            [LoggerMessage(2, LogLevel.Debug, \"HttpMessageHandler.Dispose() threw an unhandled exception for '{name}'\")]\n            public static partial void CleanupItemFailed(ILogger logger, string name, Exception exception);\n\n            [LoggerMessage(3, LogLevel.Debug, \"HttpMessageHandler expired for '{name}'\")]\n            public static partial void HandlerExpired(ILogger logger, string name);\n        }\n    }\n}\n", "            public static partial void HandlerExpired(ILogger logger, string name);\n        }\n    }\n}\n"]}
{"filename": "HttpMessageHandlerFactory/Implementations/HttpMessageHandlerBuilder.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.Options;\nusing System;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Net;\nusing System.Net.Http;\n\nnamespace HttpMessageHandlerFactory.Implementations\n{\n    /// <summary>\n    /// HttpMessageHandler\u521b\u5efa\u5668", "    /// <summary>\n    /// HttpMessageHandler\u521b\u5efa\u5668\n    /// </summary>\n    sealed class HttpMessageHandlerBuilder\n    {\n        private readonly IServiceProvider serviceProvider;\n        private readonly IOptionsMonitor<HttpMessageHandlerOptions> options;\n\n        /// <summary>\n        /// \u83b7\u53d6\u6216\u8bbe\u7f6e\u522b\u540d\u548c\u4ee3\u7406\n        /// </summary>\n        [NotNull]\n        public NameProxy? NameProxy { get; set; }\n\n        /// <summary>\n        /// \u83b7\u53d6\u751f\u547d\u5468\u671f\n        /// </summary>\n        /// <returns></returns>", "        public TimeSpan GetLifetime()\n        {\n            return this.options.Get(this.NameProxy.Name).Lifetime;\n        }\n\n        /// <summary>\n        /// HttpMessageHandler\u521b\u5efa\u5668\n        /// </summary>\n        /// <param name=\"serviceProvider\"></param>\n        /// <param name=\"options\"></param>\n        public HttpMessageHandlerBuilder(\n            IServiceProvider serviceProvider,\n            IOptionsMonitor<HttpMessageHandlerOptions> options)\n        {\n            this.serviceProvider = serviceProvider;\n            this.options = options;\n        }\n\n        /// <summary>\n        /// \u521b\u5efa\u94fe\u5f0f\u8c03\u7528\u7684<see cref=\"HttpMessageHandler\"/>\n        /// </summary>\n        /// <returns></returns>", "        public HttpMessageHandler Build()\n        {\n            var next = this.BuildPrimary();\n            var additionalHandlers = this.options.Get(this.NameProxy.Name).AdditionalHandlers;\n\n            for (var i = additionalHandlers.Count - 1; i >= 0; i--)\n            {\n                var handler = additionalHandlers[i](serviceProvider);\n                handler.InnerHandler = next;\n                next = handler;\n            }\n\n            return next;\n        }\n\n        /// <summary>\n        /// \u521b\u5efa\u57fa\u7840\u6d88\u606f\u5904\u7406\u8005\n        /// </summary> \n        /// <returns></returns>", "        private HttpMessageHandler BuildPrimary()\n        {\n            var primaryHandler = new SocketsHttpHandler\n            {\n                UseCookies = false\n            };\n\n            var proxyUri = this.NameProxy.ProxyUri;\n            if (proxyUri == null)\n            {\n                primaryHandler.UseProxy = false;\n            }\n            else\n            {\n                primaryHandler.UseProxy = true;\n                primaryHandler.Proxy = new WebProxy(proxyUri) { Credentials = GetCredential(proxyUri) };\n            }\n\n            var configures = this.options.Get(this.NameProxy.Name).PrimaryHandlerConfigures;", "            if (proxyUri == null)\n            {\n                primaryHandler.UseProxy = false;\n            }\n            else\n            {\n                primaryHandler.UseProxy = true;\n                primaryHandler.Proxy = new WebProxy(proxyUri) { Credentials = GetCredential(proxyUri) };\n            }\n\n            var configures = this.options.Get(this.NameProxy.Name).PrimaryHandlerConfigures;", "            foreach (var configure in configures)\n            {\n                configure(serviceProvider, primaryHandler);\n            }\n\n            return primaryHandler;\n        }\n\n        /// <summary>\n        /// \u83b7\u53d6\u8eab\u4efd\n        /// </summary>\n        /// <param name=\"uri\"></param>\n        /// <returns></returns>", "        private static NetworkCredential? GetCredential(Uri uri)\n        {\n            var userInfo = uri.UserInfo;\n            if (string.IsNullOrEmpty(userInfo))\n            {\n                return null;\n            }\n\n            var index = userInfo.IndexOf(':');\n            if (index < 0)\n            {\n                return new NetworkCredential(userInfo, default(string));\n            }\n\n            var username = userInfo[..index];\n            var password = userInfo[(index + 1)..];\n            return new NetworkCredential(username, password);\n        }\n    }\n}\n", "            if (index < 0)\n            {\n                return new NetworkCredential(userInfo, default(string));\n            }\n\n            var username = userInfo[..index];\n            var password = userInfo[(index + 1)..];\n            return new NetworkCredential(username, password);\n        }\n    }\n}\n"]}
{"filename": "HttpMessageHandlerFactory/Implementations/DefaultHttpMessageHandlerFactory.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.DependencyInjection;\nusing System;\nusing System.Collections.Concurrent;\nusing System.Diagnostics;\nusing System.Net.Http;\nusing System.Threading;\n\nnamespace HttpMessageHandlerFactory.Implementations\n{\n    /// <summary>", "{\n    /// <summary>\n    /// \u9ed8\u8ba4\u7684Http\u6d88\u606f\u5904\u7406\u8005\u5de5\u5382\n    /// </summary>\n    sealed class DefaultHttpMessageHandlerFactory : IHttpMessageHandlerFactory\n    {\n        private readonly NameRegistration nameRegistration;\n        private readonly IServiceScopeFactory serviceScopeFactory;\n        private readonly ExpiredHandlerEntryCleaner expiredHandlerEntryCleaner;\n\n        /// <summary>\n        /// \u8fc7\u671f\u56de\u8c03\n        /// </summary>", "        private readonly ExpiredHandlerEntryCleaner expiredHandlerEntryCleaner;\n\n        /// <summary>\n        /// \u8fc7\u671f\u56de\u8c03\n        /// </summary>\n        private readonly TimerCallback expiryCallback;\n\n        /// <summary>\n        /// LazyOf(ActiveHandlerEntry)\u7f13\u5b58\n        /// </summary>\n        private readonly ConcurrentDictionary<NameProxy, Lazy<ActiveHandlerEntry>> activeHandlerEntries = new();\n\n        /// <summary>\n        /// Http\u6d88\u606f\u5904\u7406\u8005\u5de5\u5382\n        /// </summary>\n        /// <param name=\"nameRegistration\"></param>\n        /// <param name=\"serviceScopeFactory\"></param>\n        /// <param name=\"expiredHandlerEntryCleaner\"></param>\n        public DefaultHttpMessageHandlerFactory(\n            NameRegistration nameRegistration,\n            IServiceScopeFactory serviceScopeFactory,\n            ExpiredHandlerEntryCleaner expiredHandlerEntryCleaner)\n        {\n            this.nameRegistration = nameRegistration;\n            this.serviceScopeFactory = serviceScopeFactory;\n            this.expiredHandlerEntryCleaner = expiredHandlerEntryCleaner;\n\n            this.expiryCallback = this.ExpiryTimer_Tick;\n        }\n\n        /// <summary>\n        /// \u521b\u5efa\u7528\u4e8e\u8bf7\u6c42\u7684HttpMessageHandler\n        /// </summary>\n        /// <param name=\"name\">\u522b\u540d</param>\n        /// <param name=\"proxyUri\">\u652f\u6301\u643a\u5e26UserInfo\u7684\u4ee3\u7406\u5730\u5740</param> \n        /// <returns></returns>", "        private readonly ConcurrentDictionary<NameProxy, Lazy<ActiveHandlerEntry>> activeHandlerEntries = new();\n\n        /// <summary>\n        /// Http\u6d88\u606f\u5904\u7406\u8005\u5de5\u5382\n        /// </summary>\n        /// <param name=\"nameRegistration\"></param>\n        /// <param name=\"serviceScopeFactory\"></param>\n        /// <param name=\"expiredHandlerEntryCleaner\"></param>\n        public DefaultHttpMessageHandlerFactory(\n            NameRegistration nameRegistration,\n            IServiceScopeFactory serviceScopeFactory,\n            ExpiredHandlerEntryCleaner expiredHandlerEntryCleaner)\n        {\n            this.nameRegistration = nameRegistration;\n            this.serviceScopeFactory = serviceScopeFactory;\n            this.expiredHandlerEntryCleaner = expiredHandlerEntryCleaner;\n\n            this.expiryCallback = this.ExpiryTimer_Tick;\n        }\n\n        /// <summary>\n        /// \u521b\u5efa\u7528\u4e8e\u8bf7\u6c42\u7684HttpMessageHandler\n        /// </summary>\n        /// <param name=\"name\">\u522b\u540d</param>\n        /// <param name=\"proxyUri\">\u652f\u6301\u643a\u5e26UserInfo\u7684\u4ee3\u7406\u5730\u5740</param> \n        /// <returns></returns>", "        public HttpMessageHandler CreateHandler(string name, Uri? proxyUri)\n        {\n            if (this.nameRegistration.Contains(name) == false)\n            {\n                throw new InvalidOperationException($\"\u5c1a\u672a\u767b\u8bb0\u522b\u540d\u4e3a {name} \u7684HttpMessageHandler\");\n            }\n\n            var nameProxy = new NameProxy(name, proxyUri);\n            var ativeEntry = this.activeHandlerEntries.GetOrAdd(nameProxy, this.CreateActiveHandlerEntryLazy).Value;\n            ativeEntry.StartExpiryTimer(this.expiryCallback);\n            return ativeEntry.LifetimeHttpHandler;\n        }\n\n        /// <summary>\n        /// \u521b\u5efaLazyOf(ActiveHandlerEntry)\n        /// </summary>\n        /// <param name=\"nameProxy\"></param>\n        /// <returns></returns>\n        private Lazy<ActiveHandlerEntry> CreateActiveHandlerEntryLazy(NameProxy nameProxy)\n        {\n            return new Lazy<ActiveHandlerEntry>(() => this.CreateActiveHandlerEntry(nameProxy), LazyThreadSafetyMode.ExecutionAndPublication);\n        }\n\n        /// <summary>\n        /// \u521b\u5efaActiveHandlerEntry\n        /// </summary>\n        /// <param name=\"nameProxy\"></param> \n        /// <returns></returns>", "        private ActiveHandlerEntry CreateActiveHandlerEntry(NameProxy nameProxy)\n        {\n            var serviceScope = this.serviceScopeFactory.CreateScope();\n            var serviceProvider = serviceScope.ServiceProvider;\n\n            var builder = serviceProvider.GetRequiredService<HttpMessageHandlerBuilder>();\n            builder.NameProxy = nameProxy;\n            var httpHandler = builder.Build();\n            var lifetime = builder.GetLifetime();\n\n            var lifeTimeHandler = new LifetimeHttpHandler(httpHandler);\n            return new ActiveHandlerEntry(lifetime, nameProxy, serviceScope, lifeTimeHandler);\n        }\n\n\n        /// <summary>\n        /// \u8fc7\u671ftimer\u56de\u8c03\n        /// </summary>\n        /// <param name=\"state\"></param>", "        private void ExpiryTimer_Tick(object? state)\n        {\n            var ativeEntry = (ActiveHandlerEntry)state!;\n\n            // The timer callback should be the only one removing from the active collection. If we can't find\n            // our entry in the collection, then this is a bug.\n            var removed = this.activeHandlerEntries.TryRemove(ativeEntry.NameProxy, out Lazy<ActiveHandlerEntry>? found);\n            Debug.Assert(removed, \"Entry not found. We should always be able to remove the entry\");\n            Debug.Assert(object.ReferenceEquals(ativeEntry, found!.Value), \"Different entry found. The entry should not have been replaced\");\n\n            // At this point the handler is no longer 'active' and will not be handed out to any new clients.\n            // However we haven't dropped our strong reference to the handler, so we can't yet determine if\n            // there are still any other outstanding references (we know there is at least one).\n\n            // We use a different state object to track expired handlers. This allows any other thread that acquired\n            // the 'active' entry to use it without safety problems.\n            var expiredEntry = new ExpiredHandlerEntry(ativeEntry);\n            this.expiredHandlerEntryCleaner.Add(expiredEntry);\n        }\n    }\n}\n"]}
{"filename": "HttpMessageHandlerFactory/Implementations/ExpiredHandlerEntry.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.DependencyInjection;\nusing System;\nusing System.Net.Http;\n\nnamespace HttpMessageHandlerFactory.Implementations\n{\n    /// <summary>\n    /// \u5df2\u8fc7\u671f\u7684\u6761\u76ee\n    /// https://github.com/dotnet/runtime/blob/v7.0.0/src/libraries/Microsoft.Extensions.Http/src/ExpiredHandlerTrackingEntry.cs\n    /// </summary>\n    sealed class ExpiredHandlerEntry\n    {", "    /// https://github.com/dotnet/runtime/blob/v7.0.0/src/libraries/Microsoft.Extensions.Http/src/ExpiredHandlerTrackingEntry.cs\n    /// </summary>\n    sealed class ExpiredHandlerEntry\n    {\n        private readonly WeakReference livenessTracker;\n\n        public bool CanDispose => !livenessTracker.IsAlive;\n\n        public NameProxy NameProxy { get; }\n\n        public IServiceScope ServiceScope { get; }\n\n        /// <summary>\n        /// LifetimeHttpHandler\u7684InnerHandler\n        /// </summary>", "        public NameProxy NameProxy { get; }\n\n        public IServiceScope ServiceScope { get; }\n\n        /// <summary>\n        /// LifetimeHttpHandler\u7684InnerHandler\n        /// </summary>\n        public HttpMessageHandler InnerHandler { get; }\n\n        /// <summary>\n        /// \u5df2\u8fc7\u671f\u7684\u6761\u76ee\n        /// \u8fd9\u91cc\u4e0d\u8981\u5f15\u7528entry.LifetimeHttpHandler \n        /// </summary>\n        /// <param name=\"entry\"></param>   \n        public ExpiredHandlerEntry(ActiveHandlerEntry entry)\n        {\n            this.NameProxy = entry.NameProxy;\n            this.ServiceScope = entry.ServiceScope;\n\n            this.livenessTracker = new WeakReference(entry.LifetimeHttpHandler);\n            this.InnerHandler = entry.LifetimeHttpHandler.InnerHandler!;\n        }\n    }\n}\n"]}
{"filename": "HttpMessageHandlerFactory/DependencyInjection/ServiceCollectionExtensions.cs", "chunked_list": ["\ufeffusing HttpMessageHandlerFactory;\nusing HttpMessageHandlerFactory.Implementations;\nusing Microsoft.Extensions.DependencyInjection.Extensions;\nusing System.Linq;\n\nnamespace Microsoft.Extensions.DependencyInjection\n{\n    /// <summary>\n    /// ServiceCollection\u6269\u5c55\n    /// </summary>\n    public static class ServiceCollectionExtensions\n    {\n        /// <summary>\n        /// \u521b\u5efa\u522b\u540d\u7684HttpMessageHandler\u7684builder\n        /// </summary>\n        /// <param name=\"services\"></param>\n        /// <param name=\"name\">\u522b\u540d</param>\n        /// <returns></returns>", "    /// ServiceCollection\u6269\u5c55\n    /// </summary>\n    public static class ServiceCollectionExtensions\n    {\n        /// <summary>\n        /// \u521b\u5efa\u522b\u540d\u7684HttpMessageHandler\u7684builder\n        /// </summary>\n        /// <param name=\"services\"></param>\n        /// <param name=\"name\">\u522b\u540d</param>\n        /// <returns></returns>\n        public static IHttpMessageHandlerBuilder AddHttpMessageHandlerFactory(this IServiceCollection services, string name)\n        {\n            services.AddHttpMessageHandlerFactory();\n\n            var descriptor = services.FirstOrDefault(item => item.ServiceType == typeof(NameRegistration));\n            var registration = descriptor?.ImplementationInstance as NameRegistration;\n            registration?.Add(name);\n\n            return new DefaultProxyHttpClientBuilder(name, services);\n        }\n\n        /// <summary>\n        /// \u6ce8\u518cIHttpMessageHandlerFactory\u670d\u52a1\n        /// </summary>\n        /// <param name=\"services\"></param>  \n        /// <returns></returns>", "        public static IHttpMessageHandlerBuilder AddHttpMessageHandlerFactory(this IServiceCollection services, string name)\n        {\n            services.AddHttpMessageHandlerFactory();\n\n            var descriptor = services.FirstOrDefault(item => item.ServiceType == typeof(NameRegistration));\n            var registration = descriptor?.ImplementationInstance as NameRegistration;\n            registration?.Add(name);\n\n            return new DefaultProxyHttpClientBuilder(name, services);\n        }\n\n        /// <summary>\n        /// \u6ce8\u518cIHttpMessageHandlerFactory\u670d\u52a1\n        /// </summary>\n        /// <param name=\"services\"></param>  \n        /// <returns></returns>", "        public static IServiceCollection AddHttpMessageHandlerFactory(this IServiceCollection services)\n        {\n            services.AddOptions();\n            services.TryAddSingleton(new NameRegistration());\n            services.TryAddTransient<HttpMessageHandlerBuilder>();\n            services.TryAddSingleton<ExpiredHandlerEntryCleaner>();\n            services.TryAddSingleton<IHttpMessageHandlerFactory, DefaultHttpMessageHandlerFactory>();\n            return services;\n        }\n\n", "        private class DefaultProxyHttpClientBuilder : IHttpMessageHandlerBuilder\n        {\n            public string Name { get; }\n\n            public IServiceCollection Services { get; }\n\n            public DefaultProxyHttpClientBuilder(string name, IServiceCollection services)\n            {\n                this.Name = name;\n                this.Services = services;\n            }\n        }\n    }\n}\n"]}
{"filename": "HttpMessageHandlerFactory/DependencyInjection/HttpMessageHandlerBuilderExtensions.cs", "chunked_list": ["\ufeffusing HttpMessageHandlerFactory;\nusing Microsoft.Extensions.DependencyInjection.Extensions;\nusing Microsoft.Extensions.Options;\nusing System;\nusing System.Net;\nusing System.Net.Http;\n\nnamespace Microsoft.Extensions.DependencyInjection\n{\n    /// <summary>", "{\n    /// <summary>\n    /// IHttpMessageHandlerBuilder\u6269\u5c55\n    /// </summary>\n    public static class HttpMessageHandlerBuilderExtensions\n    {\n        /// <summary> \n        /// \u914d\u7f6e\u4e3a\u53cd\u5411\u4ee3\u7406\u6a21\u5f0f\u4ee5\u652f\u6301YARP\u7b49\u6846\u67b6\n        /// <para>.UseCookies = false</para>\n        /// <para>.AllowAutoRedirect = false</para>\n        /// <para>.ActivityHeadersPropagator = null</para>\n        /// <para>.AutomaticDecompression = DecompressionMethods.None</para>\n        /// </summary>\n        /// <param name=\"builder\"></param>\n        /// <returns></returns>", "        public static IHttpMessageHandlerBuilder ConfigureAsReverseProxy(this IHttpMessageHandlerBuilder builder)\n        {\n            return builder.ConfigurePrimaryHttpMessageHandler(handler =>\n            {\n                handler.UseCookies = false;\n                handler.AllowAutoRedirect = false;\n                handler.ActivityHeadersPropagator = null;\n                handler.AutomaticDecompression = DecompressionMethods.None;\n            });\n        }\n\n        /// <summary>\n        /// \u8bbe\u7f6e\u751f\u547d\u5468\u671f\n        /// </summary>\n        /// <param name=\"builder\"></param>\n        /// <param name=\"handlerLifetime\"></param>\n        /// <returns></returns>\n        /// <exception cref=\"ArgumentOutOfRangeException\"></exception>", "        public static IHttpMessageHandlerBuilder SetHandlerLifetime(this IHttpMessageHandlerBuilder builder, TimeSpan handlerLifetime)\n        {\n            if (handlerLifetime <= TimeSpan.Zero)\n            {\n                throw new ArgumentOutOfRangeException(nameof(handlerLifetime));\n            }\n\n            builder.AddOptions().Configure(options => options.Lifetime = handlerLifetime);\n            return builder;\n        }\n\n\n        /// <summary>\n        /// \u6dfb\u52a0\u7ba1\u9053HttpMessageHandler\n        /// </summary>\n        /// <typeparam name=\"THandler\"></typeparam>\n        /// <param name=\"builder\"></param>\n        /// <returns></returns>", "        public static IHttpMessageHandlerBuilder AddHttpMessageHandler<THandler>(this IHttpMessageHandlerBuilder builder)\n            where THandler : DelegatingHandler\n        {\n            builder.Services.TryAddTransient<THandler>();\n            return builder.AddHttpMessageHandler(serviceProvider => serviceProvider.GetRequiredService<THandler>());\n        }\n\n        /// <summary>\n        /// \u6dfb\u52a0\u7ba1\u9053HttpMessageHandler\n        /// </summary>\n        /// <param name=\"builder\"></param>\n        /// <param name=\"configureHandler\"></param>\n        /// <returns></returns>", "        public static IHttpMessageHandlerBuilder AddHttpMessageHandler(this IHttpMessageHandlerBuilder builder, Func<DelegatingHandler> configureHandler)\n        {\n            return builder.AddHttpMessageHandler(serviceProvider => configureHandler());\n        }\n\n        /// <summary>\n        /// \u6dfb\u52a0\u7ba1\u9053HttpMessageHandler\n        /// </summary>\n        /// <param name=\"builder\"></param>\n        /// <param name=\"configureHandler\"></param>\n        /// <returns></returns>", "        public static IHttpMessageHandlerBuilder AddHttpMessageHandler(this IHttpMessageHandlerBuilder builder, Func<IServiceProvider, DelegatingHandler> configureHandler)\n        {\n            builder.AddOptions().Configure(options => options.AdditionalHandlers.Add(configureHandler));\n            return builder;\n        }\n\n        /// <summary>\n        /// \u914d\u7f6e\u4e3b\u8981\u7684HttpMessageHandler\n        /// </summary>\n        /// <param name=\"builder\"></param>\n        /// <param name=\"configureHandler\"></param>\n        /// <returns></returns>", "        public static IHttpMessageHandlerBuilder ConfigurePrimaryHttpMessageHandler(this IHttpMessageHandlerBuilder builder, Action<SocketsHttpHandler> configureHandler)\n        {\n            return builder.ConfigurePrimaryHttpMessageHandler((serviceProvider, httpHandler) => configureHandler(httpHandler));\n        }\n\n        /// <summary>\n        /// \u914d\u7f6e\u4e3b\u8981\u7684HttpMessageHandler\n        /// </summary>\n        /// <param name=\"builder\"></param>\n        /// <param name=\"configureHandler\"></param>\n        /// <returns></returns>", "        public static IHttpMessageHandlerBuilder ConfigurePrimaryHttpMessageHandler(this IHttpMessageHandlerBuilder builder, Action<IServiceProvider, SocketsHttpHandler> configureHandler)\n        {\n            builder.AddOptions().Configure(options => options.PrimaryHandlerConfigures.Add(configureHandler));\n            return builder;\n        }\n\n\n        /// <summary>\n        /// \u6dfb\u52a0\u9009\u9879\n        /// </summary>\n        /// <param name=\"builder\"></param>\n        /// <returns></returns>", "        private static OptionsBuilder<HttpMessageHandlerOptions> AddOptions(this IHttpMessageHandlerBuilder builder)\n        {\n            return builder.Services.AddOptions<HttpMessageHandlerOptions>(builder.Name);\n        }\n    }\n}\n"]}
{"filename": "HttpMessageHandlerFactory/DependencyInjection/IHttpMessageHandlerBuilder.cs", "chunked_list": ["\ufeffnamespace Microsoft.Extensions.DependencyInjection\n{\n    /// <summary>\n    /// Http\u6d88\u606f\u5904\u7406\u8005\u521b\u5efa\u8005\n    /// </summary>\n    public interface IHttpMessageHandlerBuilder\n    {\n        /// <summary>\n        /// \u9009\u9879\u540d\n        /// </summary>\n        string Name { get; }\n\n        /// <summary>\n        /// \u670d\u52a1\u96c6\u5408\n        /// </summary>\n        IServiceCollection Services { get; }\n    }\n}\n"]}
{"filename": "ConsoleApp/AppHttpHandler.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.Logging;\nusing Microsoft.Extensions.Logging.Abstractions;\nusing System.Net.Http;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace ConsoleApp\n{\n    sealed class AppHttpHandler : DelegatingHandler\n    {\n        private readonly ILogger<AppHttpHandler> logger;\n\n        public AppHttpHandler()\n            : this(NullLogger<AppHttpHandler>.Instance)\n        {\n        }\n\n        public AppHttpHandler(ILogger<AppHttpHandler> logger)\n        {\n            this.logger = logger;\n        }\n", "    sealed class AppHttpHandler : DelegatingHandler\n    {\n        private readonly ILogger<AppHttpHandler> logger;\n\n        public AppHttpHandler()\n            : this(NullLogger<AppHttpHandler>.Instance)\n        {\n        }\n\n        public AppHttpHandler(ILogger<AppHttpHandler> logger)\n        {\n            this.logger = logger;\n        }\n", "        protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n        {\n            this.logger.LogInformation($\"App\u5f00\u59cb\u8bf7\u6c42{request.RequestUri}\");\n            var response = await base.SendAsync(request, cancellationToken);\n\n            this.logger.LogInformation($\"App\u8bf7\u6c42{request.RequestUri}\u5b8c\u6210\");\n            return response;\n        }\n    }\n}\n"]}
{"filename": "ConsoleApp/Program.cs", "chunked_list": ["\ufeffusing HttpMessageHandlerFactory;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading.Tasks;\n\nnamespace ConsoleApp\n{\n    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var services = new ServiceCollection();\n            services.AddLogging(x => x.AddConsole());\n            services.AddHttpMessageHandlerFactory(\"App\")\n                .AddHttpMessageHandler<AppHttpHandler>()\n                .SetHandlerLifetime(TimeSpan.FromMinutes(1d));\n\n            var serviceProvider = services.BuildServiceProvider();\n            var factory = serviceProvider.GetRequiredService<IHttpMessageHandlerFactory>();\n\n            var proxyUri = default(Uri);\n            var httpClient = factory.CreateClient(\"App\", proxyUri);\n            var html = await httpClient.GetStringAsync(\"https://github.com/xljiulang/HttpMessageHandlerFactory/blob/master/README.md\");\n            Console.WriteLine(html);\n        }\n    }\n}", "    class Program\n    {\n        static async Task Main(string[] args)\n        {\n            var services = new ServiceCollection();\n            services.AddLogging(x => x.AddConsole());\n            services.AddHttpMessageHandlerFactory(\"App\")\n                .AddHttpMessageHandler<AppHttpHandler>()\n                .SetHandlerLifetime(TimeSpan.FromMinutes(1d));\n\n            var serviceProvider = services.BuildServiceProvider();\n            var factory = serviceProvider.GetRequiredService<IHttpMessageHandlerFactory>();\n\n            var proxyUri = default(Uri);\n            var httpClient = factory.CreateClient(\"App\", proxyUri);\n            var html = await httpClient.GetStringAsync(\"https://github.com/xljiulang/HttpMessageHandlerFactory/blob/master/README.md\");\n            Console.WriteLine(html);\n        }\n    }\n}"]}
{"filename": "HttpMessageHandlerFactory.Polly/PollyHttpMessageHandlerBuilderExtensions.cs", "chunked_list": ["using Microsoft.Extensions.Http;\nusing Polly;\nusing Polly.Extensions.Http;\nusing Polly.Registry;\nusing System;\nusing System.Net.Http;\n\nnamespace Microsoft.Extensions.DependencyInjection\n{\n    /// <summary>", "{\n    /// <summary>\n    /// <see cref=\"IHttpMessageHandlerBuilder\"/>Polly\u0579\n    /// https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/http-requests?view=aspnetcore-6.0#use-polly-based-handlers\n    /// </summary>\n    public static class PollyHttpMessageHandlerBuilderExtensions\n    {\n        /// <summary>\n        /// <see cref=\"PolicyHttpMessageHandler\"/>\u0735 \n        /// </summary>\n        /// <param name=\"builder\"></param>\n        /// <param name=\"policy\"></param>\n        /// <returns></returns>", "        public static IHttpMessageHandlerBuilder AddPolicyHandler(\n            this IHttpMessageHandlerBuilder builder,\n            IAsyncPolicy<HttpResponseMessage> policy)\n        {\n            return builder.AddHttpMessageHandler(() => new PolicyHttpMessageHandler(policy));\n        }\n\n        /// <summary>\n        /// <see cref=\"PolicyHttpMessageHandler\"/>\u0735 \n        /// </summary>\n        /// <param name=\"builder\"></param>\n        /// <param name=\"policySelector\">\u0461</param>\n        /// <returns></returns>", "        public static IHttpMessageHandlerBuilder AddPolicyHandler(\n            this IHttpMessageHandlerBuilder builder,\n            Func<HttpRequestMessage, IAsyncPolicy<HttpResponseMessage>> policySelector)\n        {\n            return builder.AddHttpMessageHandler(() => new PolicyHttpMessageHandler(policySelector));\n        }\n\n        /// <summary>\n        /// <see cref=\"PolicyHttpMessageHandler\"/>\u0735 \n        /// </summary>\n        /// <param name=\"builder\"></param>\n        /// <param name=\"policySelector\">\u0461</param>\n        /// <returns></returns> ", "        public static IHttpMessageHandlerBuilder AddPolicyHandler(\n            this IHttpMessageHandlerBuilder builder,\n            Func<IServiceProvider, HttpRequestMessage, IAsyncPolicy<HttpResponseMessage>> policySelector)\n        {\n            return builder.AddHttpMessageHandler((services) =>\n            {\n                return new PolicyHttpMessageHandler((request) => policySelector(services, request));\n            });\n        }\n\n        /// <summary>\n        /// <see cref=\"PolicyHttpMessageHandler\"/>\u0735 \n        /// </summary>\n        /// <param name=\"builder\"></param>\n        /// <param name=\"policyFactory\">\u0539</param>\n        /// <param name=\"keySelector\">\u0461</param>\n        /// <returns></returns>", "        public static IHttpMessageHandlerBuilder AddPolicyHandler(\n            this IHttpMessageHandlerBuilder builder,\n            Func<IServiceProvider, HttpRequestMessage, string, IAsyncPolicy<HttpResponseMessage>> policyFactory,\n            Func<HttpRequestMessage, string> keySelector)\n        {\n            return builder.AddHttpMessageHandler((services) =>\n            {\n                var registry = services.GetRequiredService<IPolicyRegistry<string>>();\n                return new PolicyHttpMessageHandler((request) =>\n                {\n                    var key = keySelector(request);\n", "                    if (registry.TryGet<IAsyncPolicy<HttpResponseMessage>>(key, out var policy))\n                    {\n                        return policy;\n                    }\n\n                    var newPolicy = policyFactory(services, request, key);\n                    registry[key] = newPolicy;\n                    return newPolicy;\n                });\n            });\n        }\n\n        /// <summary>\n        /// <see cref=\"PolicyHttpMessageHandler\"/>\u0735 \n        /// </summary>\n        /// <param name=\"builder\"></param>\n        /// <param name=\"policyKey\">\u0368AddPolicyRegistrypolicyRegistry\u00bc\u0132</param>\n        /// <returns></returns>", "        public static IHttpMessageHandlerBuilder AddPolicyHandlerFromRegistry(\n            this IHttpMessageHandlerBuilder builder,\n            string policyKey)\n        {\n            return builder.AddHttpMessageHandler((services) =>\n            {\n                var registry = services.GetRequiredService<IReadOnlyPolicyRegistry<string>>();\n                var policy = registry.Get<IAsyncPolicy<HttpResponseMessage>>(policyKey);\n                return new PolicyHttpMessageHandler(policy);\n            });\n        }\n\n        /// <summary>\n        /// <see cref=\"PolicyHttpMessageHandler\"/>\u0735 \n        /// </summary>\n        /// <param name=\"builder\"></param>\n        /// <param name=\"policySelector\">\u0461</param>\n        /// <returns></returns>", "        public static IHttpMessageHandlerBuilder AddPolicyHandlerFromRegistry(\n            this IHttpMessageHandlerBuilder builder,\n            Func<IReadOnlyPolicyRegistry<string>, HttpRequestMessage, IAsyncPolicy<HttpResponseMessage>> policySelector)\n        {\n            return builder.AddHttpMessageHandler((services) =>\n            {\n                var registry = services.GetRequiredService<IReadOnlyPolicyRegistry<string>>();\n                return new PolicyHttpMessageHandler((request) => policySelector(registry, request));\n            });\n        }\n\n        /// <summary>\n        /// <see cref=\"PolicyHttpMessageHandler\"/>\u0735\n        /// \u0368\u05b4\u1e69\u03af\u0434\u0539\u0524\u03aa\u04e6\u00f3\u0534\u05b8\u02be\u02b1\u03f5\u02a7\n        /// </summary>\n        /// <param name=\"builder\"><see cref=\"IHttpMessageHandlerBuilder\"/></param>\n        /// <param name=\"configurePolicy\">\u06b4<see cref=\"IAsyncPolicy{HttpResponseMessage}\"/>\u03af</param>\n        /// <returns></returns>\n        /// <remarks>\n        /// <para>\n        /// \u00f2\u02b1\u03bf<see cref=\"PolicyHttpMessageHandler\"/>\u0131\u05e2\n        /// </para>\n        /// <para>\n        /// <paramref name=\"configurePolicy\"/><see cref=\"PolicyBuilder{HttpResponseMessage}\"/>\u047e\u0524\u02f4\udb4e\udf3f\u0534\u00bc:\n        /// <list type=\"bullet\">\n        /// <item><description><see cref=\"HttpRequestException\"/></description></item>\n        /// <item><description>\u04e65XX\u05f4\u032c</description></item>\n        /// <item><description>408\u05f4\u032c(request timeout)</description></item>\n        /// </list>\n        /// </para>\n        /// <para>\n        /// <paramref name=\"configurePolicy\"/>\u0132\u053d\u06b5\u063b\u6d7d\u00ff\u05b8\u013f\u037b\u02e1\n        /// \u0368\u03aa\u04bf\u02b5\u02b1\n        /// \u04aa\u05b8\u037b\u02f9\u0523\u0234\u0523\u023b\u04aa\u4d2b\u0778\n        /// <see cref=\"AddPolicyHandler(IHttpMessageHandlerBuilder, IAsyncPolicy{HttpResponseMessage})\"/>\n        /// \u0136\u00e1\n        /// </para>\n        /// </remarks>", "        public static IHttpMessageHandlerBuilder AddTransientHttpErrorPolicy(\n            this IHttpMessageHandlerBuilder builder,\n            Func<PolicyBuilder<HttpResponseMessage>, IAsyncPolicy<HttpResponseMessage>> configurePolicy)\n        {             \n            var policyBuilder = HttpPolicyExtensions.HandleTransientHttpError();\n\n            // Important - cache policy instances so that they are singletons per handler.\n            var policy = configurePolicy(policyBuilder);\n\n            builder.AddHttpMessageHandler(() => new PolicyHttpMessageHandler(policy));\n            return builder;\n        }\n    }\n}\n"]}
