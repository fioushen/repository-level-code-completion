{"filename": "ServiceSelf/Service.cs", "chunked_list": ["\ufeffusing System;\nusing System.Runtime.InteropServices;\n\nnamespace ServiceSelf\n{\n    /// <summary>\n    /// \u670d\u52a1\n    /// </summary>\n    public abstract partial class Service\n    {\n        /// <summary>\n        /// \u83b7\u53d6\u670d\u52a1\u540d\n        /// </summary>", "    public abstract partial class Service\n    {\n        /// <summary>\n        /// \u83b7\u53d6\u670d\u52a1\u540d\n        /// </summary>\n        public string Name { get; }\n\n        /// <summary>\n        /// \u670d\u52a1\n        /// </summary>\n        /// <param name=\"name\">\u670d\u52a1\u540d</param> \n        public Service(string name)\n        {\n            this.Name = name;\n        }\n\n        /// <summary>\n        /// \u521b\u5efa\u5e76\u542f\u52a8\u670d\u52a1\n        /// </summary>\n        /// <param name=\"filePath\">\u6587\u4ef6\u5b8c\u6574\u8def\u5f84</param>\n        /// <param name=\"options\">\u670d\u52a1\u9009\u9879</param> ", "        public abstract void CreateStart(string filePath, ServiceOptions options);\n\n        /// <summary>\n        /// \u505c\u6b62\u5e76\u5220\u9664\u670d\u52a1\n        /// </summary>\n        public abstract void StopDelete();\n\n        /// <summary>\n        /// \u76d1\u542c\u670d\u52a1\u8fdb\u7a0b\u7684LoggingEventSource\u7684\u65e5\u5fd7\n        /// </summary>\n        /// <param name=\"filter\">\u8fc7\u6ee4\u5668</param>\n        /// <param name=\"callback\">\u65e5\u5fd7\u56de\u8c03</param>\n        /// <returns></returns>", "        public bool ListenLogs(string? filter, Action<LogItem> callback)\n        {\n            if (this.TryGetProcessId(out var processId))\n            {\n                NamedPipeLoggerServer.ListenLogs(processId, filter, callback);\n                return true;\n            }\n            return false;\n        }\n\n        /// <summary>\n        /// \u5c1d\u8bd5\u83b7\u53d6\u670d\u52a1\u7684\u8fdb\u7a0bid\n        /// </summary>\n        /// <param name=\"processId\"></param>\n        /// <returns></returns>", "        protected abstract bool TryGetProcessId(out int processId);\n\n\n        /// <summary>\n        /// \u521b\u5efa\u670d\u52a1\u5bf9\u8c61\n        /// </summary>\n        /// <param name=\"name\">\u670d\u52a1\u540d\u79f0</param>\n        /// <returns></returns>\n        /// <exception cref=\"PlatformNotSupportedException\"></exception>\n        public static Service Create(string name)\n        {", "        public static Service Create(string name)\n        {\n            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\n            {\n                return new WindowsService(name);\n            }\n\n            if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))\n            {\n                return new LinuxService(name);\n            }\n\n            throw new PlatformNotSupportedException();\n        }\n    }\n}\n"]}
{"filename": "ServiceSelf/NamedPipeLoggerServer.cs", "chunked_list": ["\ufeffusing Google.Protobuf;\nusing System;\nusing System.IO;\nusing System.IO.Pipes;\n\nnamespace ServiceSelf\n{\n    /// <summary>\n    /// \u547d\u540d\u7ba1\u9053\u65e5\u5fd7\u670d\u52a1\u7aef\n    /// </summary>\n    static class NamedPipeLoggerServer\n    {\n        /// <summary>\n        /// \u76d1\u542c\u6307\u5b9a\u8fdb\u7a0b\u547d\u540d\u7ba1\u9053\u65e5\u5fd7\n        /// </summary>\n        /// <param name=\"processId\"></param>\n        /// <param name=\"filter\"></param>\n        /// <param name=\"callback\"></param> ", "    /// \u547d\u540d\u7ba1\u9053\u65e5\u5fd7\u670d\u52a1\u7aef\n    /// </summary>\n    static class NamedPipeLoggerServer\n    {\n        /// <summary>\n        /// \u76d1\u542c\u6307\u5b9a\u8fdb\u7a0b\u547d\u540d\u7ba1\u9053\u65e5\u5fd7\n        /// </summary>\n        /// <param name=\"processId\"></param>\n        /// <param name=\"filter\"></param>\n        /// <param name=\"callback\"></param> \n        public static void ListenLogs(int processId, string? filter, Action<LogItem> callback)\n        {\n            using var inputStream = CreateInputStream(processId);", "        public static void ListenLogs(int processId, string? filter, Action<LogItem> callback)\n        {\n            using var inputStream = CreateInputStream(processId);\n            while (inputStream.IsAtEnd == false)\n            {\n                var logItem = ReadLogItem(inputStream);\n                if (logItem == null)\n                {\n                    break;\n                }\n", "                if (logItem.IsMatch(filter))\n                {\n                    callback.Invoke(logItem);\n                }\n            }\n        }\n\n\n        private static CodedInputStream CreateInputStream(int processId)\n        {\n            var pipeName = $\"{nameof(ServiceSelf)}_{processId}\";\n            var pipeStream = new NamedPipeServerStream(pipeName);\n\n            pipeStream.WaitForConnection();\n            return new CodedInputStream(pipeStream, leaveOpen: false);\n        }\n\n", "        private static CodedInputStream CreateInputStream(int processId)\n        {\n            var pipeName = $\"{nameof(ServiceSelf)}_{processId}\";\n            var pipeStream = new NamedPipeServerStream(pipeName);\n\n            pipeStream.WaitForConnection();\n            return new CodedInputStream(pipeStream, leaveOpen: false);\n        }\n\n\n        private static LogItem? ReadLogItem(CodedInputStream inputStream)\n        {\n            try\n            {\n                var logItem = new LogItem();\n                inputStream.ReadMessage(logItem);\n                return logItem;\n            }", "        private static LogItem? ReadLogItem(CodedInputStream inputStream)\n        {\n            try\n            {\n                var logItem = new LogItem();\n                inputStream.ReadMessage(logItem);\n                return logItem;\n            }\n            catch (IOException)\n            {\n                return null;\n            }\n        }\n    }\n}\n", "            catch (IOException)\n            {\n                return null;\n            }\n        }\n    }\n}\n"]}
{"filename": "ServiceSelf/NamedPipeClient.cs", "chunked_list": ["\ufeffusing Google.Protobuf;\nusing System;\nusing System.Buffers;\nusing System.IO.Pipes;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace ServiceSelf\n{\n    /// <summary>", "{\n    /// <summary>\n    /// \u547d\u540d\u7ba1\u9053\u5ba2\u6237\u7aef\n    /// </summary>\n    sealed class NamedPipeClient : IDisposable\n    {\n        /// <summary>\n        /// \u5f53\u524d\u5b9e\u4f8b\n        /// </summary>\n        private Instance instance;\n\n        /// <summary>\n        /// \u5173\u95edtokenSource\n        /// </summary>", "        private Instance instance;\n\n        /// <summary>\n        /// \u5173\u95edtokenSource\n        /// </summary>\n        private readonly CancellationTokenSource disposeTokenSource = new();\n\n        /// <summary>\n        /// \u5f53\u524d\u662f\u5426\u652f\u6301\u5199\u5165\n        /// </summary>\n        public bool CanWrite => this.instance.CanWrite;\n\n        /// <summary>\n        /// \u547d\u540d\u7ba1\u9053\u5ba2\u6237\u7aef\n        /// </summary>\n        /// <param name=\"pipeName\"></param>\n        public NamedPipeClient(string pipeName)\n        {\n            this.instance = new Instance(pipeName);\n            this.RunRefreshInstanceAsync(pipeName);\n        }\n\n        /// <summary>\n        /// \u81ea\u52a8\u5237\u65b0\u5b9e\u4f8b\n        /// </summary>\n        /// <param name=\"pipeName\"></param>", "        public bool CanWrite => this.instance.CanWrite;\n\n        /// <summary>\n        /// \u547d\u540d\u7ba1\u9053\u5ba2\u6237\u7aef\n        /// </summary>\n        /// <param name=\"pipeName\"></param>\n        public NamedPipeClient(string pipeName)\n        {\n            this.instance = new Instance(pipeName);\n            this.RunRefreshInstanceAsync(pipeName);\n        }\n\n        /// <summary>\n        /// \u81ea\u52a8\u5237\u65b0\u5b9e\u4f8b\n        /// </summary>\n        /// <param name=\"pipeName\"></param>", "        private async void RunRefreshInstanceAsync(string pipeName)\n        {\n            try\n            {\n                while (true)\n                {\n                    await this.RefreshInstanceAsync(pipeName);\n                }\n            }\n            catch (OperationCanceledException)\n            {\n            }", "            catch (OperationCanceledException)\n            {\n            }\n            catch (Exception)\n            {\n            }\n        }\n\n        /// <summary>\n        /// \u5237\u65b0\u5b9e\u4f8b\n        /// </summary>\n        /// <param name=\"pipeName\"></param>\n        /// <returns></returns>", "        private async Task RefreshInstanceAsync(string pipeName)\n        {\n            using (this.instance)\n            {\n                var cancellationToken = this.disposeTokenSource.Token;\n                await this.instance.ConnectAsync(cancellationToken);\n                await this.instance.WaitForClosedAsync(cancellationToken);\n            }\n            this.instance = new Instance(pipeName);\n        }\n\n        /// <summary>\n        /// \u5e26\u8fb9\u754c\u5199\u5165\u6d88\u606f\n        /// </summary>\n        /// <param name=\"message\"></param>\n        /// <returns></returns>", "        public bool Write(IMessage message)\n        {\n            using var serializer = new Serializer(message);\n            var data = serializer.Serialize();\n            return this.instance.Write(data);\n        }\n\n        /// <summary>\n        /// \u91ca\u653e\u8d44\u6e90\n        /// </summary>\n        public void Dispose()\n        {\n            this.disposeTokenSource.Cancel();\n            this.disposeTokenSource.Dispose();\n        }\n\n        /// <summary>\n        /// NamedPipeClient\u5b9e\u4f8b\n        /// </summary>", "        public void Dispose()\n        {\n            this.disposeTokenSource.Cancel();\n            this.disposeTokenSource.Dispose();\n        }\n\n        /// <summary>\n        /// NamedPipeClient\u5b9e\u4f8b\n        /// </summary>\n        private class Instance : IDisposable\n        {", "        private class Instance : IDisposable\n        {\n            private readonly NamedPipeClientStream clientStream;\n            private readonly TaskCompletionSource<object?> closeTaskSource = new();\n\n            /// <summary>\n            /// \u5f53\u524d\u662f\u5426\u80fd\u5199\u5165\n            /// </summary>\n            public bool CanWrite { get; private set; }\n\n\n            public Instance(string pipeName)\n            {\n                this.clientStream = new(pipeName);\n            }\n\n            /// <summary>\n            /// \u8fde\u63a5\u7ba1\u9053\n            /// </summary>\n            /// <param name=\"cancellationToken\"></param>\n            /// <returns></returns>", "            public bool CanWrite { get; private set; }\n\n\n            public Instance(string pipeName)\n            {\n                this.clientStream = new(pipeName);\n            }\n\n            /// <summary>\n            /// \u8fde\u63a5\u7ba1\u9053\n            /// </summary>\n            /// <param name=\"cancellationToken\"></param>\n            /// <returns></returns>", "            public async Task ConnectAsync(CancellationToken cancellationToken = default)\n            {\n                await this.clientStream.ConnectAsync(cancellationToken);\n                this.CanWrite = true;\n            }\n\n            /// <summary>\n            /// \u7b49\u5f85\u5173\u95ed\n            /// </summary>\n            /// <param name=\"cancellationToken\"></param>\n            /// <returns></returns>", "            public Task WaitForClosedAsync(CancellationToken cancellationToken = default)\n            {\n                cancellationToken.Register(OperationCanceled);\n                return this.closeTaskSource.Task;\n\n                void OperationCanceled()\n                {\n                    var exception = new OperationCanceledException(cancellationToken);\n                    this.closeTaskSource.TrySetException(exception);\n                }\n            }\n\n            /// <summary>\n            /// \u5199\u5165\u6570\u636e\n            /// </summary>\n            /// <param name=\"data\"></param>\n            /// <returns></returns>", "            public bool Write(ReadOnlySpan<byte> data)\n            {\n                if (this.CanWrite == false)\n                {\n                    return false;\n                }\n\n                try\n                {\n                    this.clientStream.Write(data);\n                    return true;\n                }", "                catch (Exception)\n                {\n                    this.CanWrite = false;\n                    this.closeTaskSource.TrySetResult(null);\n                    return false;\n                }\n            }\n\n            public void Dispose()\n            {\n                this.CanWrite = false;\n                this.clientStream.Dispose();\n            }\n        }\n\n        /// <summary>\n        /// \u5305\u542b\u6d88\u606f\u957f\u5ea6\u7684\u5e8f\u5217\u5316\n        /// </summary>", "            public void Dispose()\n            {\n                this.CanWrite = false;\n                this.clientStream.Dispose();\n            }\n        }\n\n        /// <summary>\n        /// \u5305\u542b\u6d88\u606f\u957f\u5ea6\u7684\u5e8f\u5217\u5316\n        /// </summary>\n        private readonly struct Serializer : IDisposable\n        {", "        private readonly struct Serializer : IDisposable\n        {\n            private readonly IMessage message;\n            private readonly byte[] buffer;\n\n            public Serializer(IMessage message)\n            {\n                this.message = message;\n                this.buffer = ArrayPool<byte>.Shared.Rent(sizeof(int) + message.CalculateSize());\n            }\n\n            public ReadOnlySpan<byte> Serialize()\n            {\n                var outputStream = new CodedOutputStream(this.buffer);\n                outputStream.WriteMessage(this.message);\n                return this.buffer.AsSpan(0, (int)outputStream.Position);\n            }\n", "            public void Dispose()\n            {\n                ArrayPool<byte>.Shared.Return(this.buffer);\n            }\n        }\n    }\n}\n"]}
{"filename": "ServiceSelf/SystemdSection.cs", "chunked_list": ["\ufeffusing System.Collections.Generic;\nusing System.IO;\n\nnamespace ServiceSelf\n{\n    /// <summary>\n    /// \u9009\u9879\u7ae0\u8282\n    /// </summary>\n    public class SystemdSection\n    {\n        private readonly string name;", "    public class SystemdSection\n    {\n        private readonly string name;\n        private readonly Dictionary<string, string?> nodes = new Dictionary<string, string?>();\n\n        /// <summary>\n        /// \u83b7\u53d6\u6216\u8bbe\u7f6e\u503c\n        /// </summary>\n        /// <param name=\"key\">\u952e</param>\n        /// <returns></returns>\n        public string? this[string key]\n        {\n            get => this.Get(key);\n            set => this.Set(key, value);\n        }\n\n        /// <summary>\n        /// \u9009\u9879\u7ae0\u8282\n        /// </summary>\n        /// <param name=\"name\">\u7ae0\u8282\u540d\u79f0</param>\n        public SystemdSection(string name)\n        {\n            this.name = name;\n        }\n\n        /// <summary>\n        /// \u83b7\u53d6\u503c\n        /// </summary>\n        /// <param name=\"key\"></param>\n        /// <returns></returns>\n        protected string? Get(string key)\n        {\n            return this.nodes.GetValueOrDefault(key);\n        }\n\n        /// <summary>\n        /// \u8bbe\u7f6e\u503c\n        /// </summary>\n        /// <param name=\"key\"></param>\n        /// <param name=\"value\"></param>", "        protected void Set(string key, string? value)\n        {\n            if (string.IsNullOrEmpty(value))\n            {\n                this.nodes.Remove(key);\n            }\n            else\n            {\n                this.nodes[key] = value;\n            }\n        }\n\n        /// <summary>\n        /// \u8f6c\u6362\u4e3a\u6587\u672c\n        /// </summary>\n        /// <returns></returns>", "        public override string ToString()\n        {\n            var writer = new StringWriter();\n            this.WriteTo(writer);\n            return writer.ToString();\n        }\n\n        /// <summary>\n        /// \u5199\u5165writer\n        /// </summary>\n        /// <param name=\"writer\"></param>", "        public void WriteTo(TextWriter writer)\n        {\n            writer.WriteLine(this.name);\n            foreach (var kv in this.nodes)\n            {\n                writer.WriteLine($\"{kv.Key}={kv.Value}\");\n            }\n            writer.WriteLine();\n        }\n\n        /// <summary>\n        /// \u83b7\u53d6\u8fed\u4ee3\u5668\n        /// </summary>\n        /// <returns></returns>\n        public IEnumerator<KeyValuePair<string, string?>> GetEnumerator()\n        {\n            return this.nodes.GetEnumerator();\n        }\n    }\n}\n"]}
{"filename": "ServiceSelf/SystemdUnitSection.cs", "chunked_list": ["\ufeffnamespace ServiceSelf\n{\n    /// <summary>\n    /// Unit\u7ae0\u8282\n    /// </summary>\n    public sealed class SystemdUnitSection : SystemdSection\n    {\n        /// <summary>\n        /// Unit\u7ae0\u8282\n        /// </summary>\n        public SystemdUnitSection()\n            : base(\"[Unit]\")\n        {\n        }\n\n        /// <summary>\n        /// Unit\u7ae0\u8282\n        /// </summary>\n        /// <param name=\"section\"></param>\n        public SystemdUnitSection(SystemdUnitSection section)\n            : this()\n        {", "            foreach (var item in section)\n            {\n                this[item.Key] = item.Value;\n            }\n        }\n\n        /// <summary>\n        /// \u5355\u5143\u542f\u52a8\u540e\u5fc5\u987b\u542f\u52a8\u7684\u5176\u4ed6\u5355\u5143\u5217\u8868\n        /// </summary>\n        public string? After\n        {\n            get => Get(nameof(After));\n            set => Set(nameof(After), value);\n        }\n\n        /// <summary>\n        /// \u5355\u5143\u6240\u9700\u7684\u5176\u4ed6\u5355\u5143\u5217\u8868\n        /// </summary>\n        public string? Requires\n        {\n            get => Get(nameof(Requires));\n            set => Set(nameof(Requires), value);\n        }\n\n        /// <summary>\n        /// \u5355\u5143\u542f\u52a8\u524d\u5fc5\u987b\u542f\u52a8\u7684\u5176\u4ed6\u5355\u5143\u5217\u8868\n        /// </summary>\n        public string? Before\n        {\n            get => Get(nameof(Before));\n            set => Set(nameof(Before), value);\n        }\n        /// <summary>\n        /// \u5355\u5143\u5e0c\u671b\u542f\u52a8\u4f46\u4e0d\u662f\u5fc5\u9700\u7684\u5176\u4ed6\u5355\u5143\u5217\u8868\n        /// </summary>\n        public string? Wants\n        {\n            get => Get(nameof(Wants));\n            set => Set(nameof(Wants), value);\n        }\n    }\n}\n"]}
{"filename": "ServiceSelf/HostBuilderExtensions.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.DependencyInjection.Extensions;\nusing Microsoft.Extensions.Logging;\nusing ServiceSelf;\n\nnamespace Microsoft.Extensions.Hosting\n{\n    /// <summary>\n    /// IHostBuilder\u6269\u5c55\n    /// </summary>\n    public static class HostBuilderExtensions\n    {\n        /// <summary>\n        /// \u4e3a\u4e3b\u673a\u4f7f\u7528WindowsService\u548cSystemd\u7684\u751f\u547d\u5468\u671f\n        /// \u540c\u65f6\u9009\u62e9\u662f\u5426\u542f\u7528\u65e5\u5fd7\u8bb0\u5f55\u548c\u76d1\u542c\u529f\u80fd\n        /// </summary>\n        /// <param name=\"hostBuilder\"></param>\n        /// <param name=\"enableLogs\">\u662f\u5426\u542f\u7528\u65e5\u5fd7\u529f\u80fd\uff0c\u8bbe\u7f6e\u4e3atrue\u540e\u8c03\u7528logs\u5b50\u547d\u4ee4\u65f6\u624d\u6709\u65e5\u5fd7\u8f93\u51fa</param>\n        /// <returns></returns>", "    /// IHostBuilder\u6269\u5c55\n    /// </summary>\n    public static class HostBuilderExtensions\n    {\n        /// <summary>\n        /// \u4e3a\u4e3b\u673a\u4f7f\u7528WindowsService\u548cSystemd\u7684\u751f\u547d\u5468\u671f\n        /// \u540c\u65f6\u9009\u62e9\u662f\u5426\u542f\u7528\u65e5\u5fd7\u8bb0\u5f55\u548c\u76d1\u542c\u529f\u80fd\n        /// </summary>\n        /// <param name=\"hostBuilder\"></param>\n        /// <param name=\"enableLogs\">\u662f\u5426\u542f\u7528\u65e5\u5fd7\u529f\u80fd\uff0c\u8bbe\u7f6e\u4e3atrue\u540e\u8c03\u7528logs\u5b50\u547d\u4ee4\u65f6\u624d\u6709\u65e5\u5fd7\u8f93\u51fa</param>\n        /// <returns></returns>", "        public static IHostBuilder UseServiceSelf(this IHostBuilder hostBuilder, bool enableLogs = true)\n        {\n            if (enableLogs == true)\n            {\n                hostBuilder.ConfigureLogging(builder =>\n                {\n                    var descriptor = ServiceDescriptor.Singleton<ILoggerProvider, NamedPipeLoggerProvider>();\n                    builder.Services.TryAddEnumerable(descriptor);\n                });\n            }\n            return hostBuilder.UseWindowsService().UseSystemd();\n        }\n    }\n}\n"]}
{"filename": "ServiceSelf/WindowsServiceOptions.cs", "chunked_list": ["\ufeffnamespace ServiceSelf\n{\n    /// <summary>\n    /// windows\u72ec\u6709\u7684\u670d\u52a1\u9009\u9879\n    /// </summary>\n    public sealed class WindowsServiceOptions\n    {\n        /// <summary>\n        /// \u5728\u670d\u52a1\u63a7\u5236\u7ba1\u7406\u5668\u4e2d\u663e\u793a\u7684\u670d\u52a1\u540d\u79f0\n        /// </summary>\n        public string? DisplayName { get; set; }\n\n        /// <summary>\n        /// \u4e00\u4e2a\u7a7a\u683c\u5206\u9694\u7684\u4f9d\u8d56\u9879\u5217\u8868\n        /// \u5982\u679c\u670d\u52a1\u4f9d\u8d56\u4e8e\u5176\u4ed6\u670d\u52a1\uff0c\u5219\u5e94\u5728\u6b64\u5904\u5217\u51fa\u8fd9\u4e9b\u670d\u52a1\u7684\u540d\u79f0\n        /// </summary>\n        public string? Dependencies { get; set; }\n\n        /// <summary>\n        /// \u670d\u52a1\u8fd0\u884c\u7684\u5e10\u6237\u540d\u79f0\u3002\u5982\u679c\u4e0d\u6307\u5b9a\uff0c\u5219\u9ed8\u8ba4\u4e3aLocalSystem\u8d26\u6237\n        /// </summary>\n        public string? ServiceStartName { get; set; }\n\n        /// <summary>\n        /// \u4e0eServiceStartName\u5e10\u6237\u76f8\u5173\u8054\u7684\u5bc6\u7801\u3002\u5982\u679cServiceStartName\u4e3aNULL\uff0c\u5219\u6b64\u53c2\u6570\u88ab\u5ffd\u7565\n        /// </summary>\n        public string? Password { get; set; }\n\n        /// <summary>\n        /// \u670d\u52a1\u6545\u969c\u540e\u7684\u64cd\u4f5c\u7c7b\u578b\n        /// </summary>", "        public WindowsServiceActionType FailureActionType { get; set; }\n    }\n}\n"]}
{"filename": "ServiceSelf/AdvApi32.cs", "chunked_list": ["\ufeffusing System;\nusing System.Runtime.InteropServices;\n\nnamespace ServiceSelf\n{\n    /// <summary>\n    /// advApi32\n    /// </summary>\n    static unsafe class AdvApi32\n    {\n        private const string AdvApi32Lib = \"advapi32.dll\";", "    static unsafe class AdvApi32\n    {\n        private const string AdvApi32Lib = \"advapi32.dll\";\n        private const uint STANDARD_RIGHTS_REQUIRED = 0xF0000;\n\n        [Flags]\n        public enum ServiceManagerAccess : uint\n        {\n            SC_MANAGER_CONNECT = 0x0001,\n            SC_MANAGER_CREATE_SERVICE = 0x0002,\n            SC_MANAGER_ENUMERATE_SERVICE = 0x0004,\n            SC_MANAGER_LOCK = 0x0008,\n            SC_MANAGER_QUERY_LOCK_STATUS = 0x0010,\n            SC_MANAGER_MODIFY_BOOT_CONFIG = 0x0020,\n            SC_MANAGER_ALL_ACCESS = 0xF003F\n        }\n\n        [Flags]", "        public enum ServiceAccess : uint\n        {\n            SERVICE_QUERY_CONFIG = 0x0001,\n            SERVICE_CHANGE_CONFIG = 0x0002,\n            SERVICE_QUERY_STATUS = 0x0004,\n            SERVICE_ENUMERATE_DEPENDENTS = 0x0008,\n            SERVICE_START = 0x0010,\n            SERVICE_STOP = 0x0020,\n            SERVICE_PAUSE_CONTINUE = 0x0040,\n            SERVICE_INTERROGATE = 0x0080,\n            SERVICE_USER_DEFINED_CONTROL = 0x0100,\n            SERVICE_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED | SERVICE_QUERY_CONFIG | SERVICE_CHANGE_CONFIG | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_START | SERVICE_STOP | SERVICE_PAUSE_CONTINUE | SERVICE_INTERROGATE | SERVICE_USER_DEFINED_CONTROL),\n        }\n", "        public enum SC_STATUS_TYPE : uint\n        {\n            SC_STATUS_PROCESS_INFO = 0,\n        }\n\n        public enum ServiceState : uint\n        {\n            SERVICE_STOPPED = 0x00000001,\n            SERVICE_START_PENDING = 0x00000002,\n            SERVICE_STOP_PENDING = 0x00000003,\n            SERVICE_RUNNING = 0x00000004,\n            SERVICE_CONTINUE_PENDING = 0x00000005,\n            SERVICE_PAUSE_PENDING = 0x00000006,\n            SERVICE_PAUSED = 0x00000007,\n        }\n\n        [Flags]", "        public enum ServiceType : uint\n        {\n            SERVICE_KERNEL_DRIVER = 0x00000001,\n            SERVICE_FILE_SYSTEM_DRIVER = 0x00000002,\n            SERVICE_DRIVER = SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER,\n            SERVICE_ADAPTER = 0x00000004,\n            SERVICE_RECOGNIZER_DRIVER = 0x00000008,\n            SERVICE_WIN32_OWN_PROCESS = 0x00000010,\n            SERVICE_WIN32_SHARE_PROCESS = 0x00000020,\n            SERVICE_WIN32 = SERVICE_WIN32_OWN_PROCESS | SERVICE_WIN32_SHARE_PROCESS,\n            SERVICE_INTERACTIVE_PROCESS = 0x00000100,\n            SERVICE_NO_CHANGE = 0xFFFFFFFF,\n        }\n", "        public enum ServiceStartType : uint\n        {\n            SERVICE_BOOT_START = 0x00000000,\n            SERVICE_SYSTEM_START = 0x00000001,\n            SERVICE_AUTO_START = 0x00000002,\n            SERVICE_DEMAND_START = 0x00000003,\n            SERVICE_DISABLED = 0x00000004,\n            SERVICE_NO_CHANGE = 0xFFFFFFFF,\n        }\n\n        public enum ServiceErrorControl : uint\n        {\n            SERVICE_ERROR_IGNORE = 0x00000000,\n            SERVICE_ERROR_NORMAL = 0x00000001,\n            SERVICE_ERROR_SEVERE = 0x00000002,\n            SERVICE_ERROR_CRITICAL = 0x00000003,\n            SERVICE_NO_CHANGE = 0xFFFFFFFF,\n        }\n", "        public enum ServiceErrorControl : uint\n        {\n            SERVICE_ERROR_IGNORE = 0x00000000,\n            SERVICE_ERROR_NORMAL = 0x00000001,\n            SERVICE_ERROR_SEVERE = 0x00000002,\n            SERVICE_ERROR_CRITICAL = 0x00000003,\n            SERVICE_NO_CHANGE = 0xFFFFFFFF,\n        }\n\n        public enum ServiceInfoLevel : uint\n        {\n            SERVICE_CONFIG_DESCRIPTION = 1,\n            SERVICE_CONFIG_FAILURE_ACTIONS = 2,\n            SERVICE_CONFIG_DELAYED_AUTO_START_INFO = 3,\n            SERVICE_CONFIG_FAILURE_ACTIONS_FLAG = 4,\n            SERVICE_CONFIG_SERVICE_SID_INFO = 5,\n            SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO = 6,\n            SERVICE_CONFIG_PRESHUTDOWN_INFO = 7,\n            SERVICE_CONFIG_TRIGGER_INFO = 8,\n            SERVICE_CONFIG_PREFERRED_NODE = 9,\n            SERVICE_CONFIG_LAUNCH_PROTECTED = 12,\n        }\n", "        public enum ServiceInfoLevel : uint\n        {\n            SERVICE_CONFIG_DESCRIPTION = 1,\n            SERVICE_CONFIG_FAILURE_ACTIONS = 2,\n            SERVICE_CONFIG_DELAYED_AUTO_START_INFO = 3,\n            SERVICE_CONFIG_FAILURE_ACTIONS_FLAG = 4,\n            SERVICE_CONFIG_SERVICE_SID_INFO = 5,\n            SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO = 6,\n            SERVICE_CONFIG_PRESHUTDOWN_INFO = 7,\n            SERVICE_CONFIG_TRIGGER_INFO = 8,\n            SERVICE_CONFIG_PREFERRED_NODE = 9,\n            SERVICE_CONFIG_LAUNCH_PROTECTED = 12,\n        }\n", "        public enum ServiceControl : uint\n        {\n            SERVICE_CONTROL_STOP = 0x00000001,\n            SERVICE_CONTROL_PAUSE = 0x00000002,\n            SERVICE_CONTROL_CONTINUE = 0x00000003,\n            SERVICE_CONTROL_INTERROGATE = 0x00000004,\n            SERVICE_CONTROL_SHUTDOWN = 0x00000005,\n            SERVICE_CONTROL_PARAMCHANGE = 0x00000006,\n            SERVICE_CONTROL_DEVICEEVENT = 0x0000000B,\n            SERVICE_CONTROL_HARDWAREPROFILECHANGE = 0x0000000C,\n            SERVICE_CONTROL_POWEREVENT = 0x0000000D,\n            SERVICE_CONTROL_SESSIONCHANGE = 0x0000000E,\n            SERVICE_CONTROL_PRESHUTDOWN = 0x0000000F,\n            SERVICE_CONTROL_TIMECHANGE = 0x00000010,\n            SERVICE_CONTROL_TRIGGEREVENT = 0x00000020,\n            SERVICE_CONTROL_USERMODEREBOOT = 0x00000040,\n        }\n", "        public enum SC_ACTION_TYPE : uint\n        {\n            SC_ACTION_NONE,\n            SC_ACTION_RESTART,\n            SC_ACTION_REBOOT,\n            SC_ACTION_RUN_COMMAND,\n            SC_ACTION_OWN_RESTART\n        }\n\n\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]", "        public struct QUERY_SERVICE_CONFIG\n        {\n            public int dwServiceType;\n            public int dwStartType;\n            public int dwErrorControl;\n            public string lpBinaryPathName;\n            public string lpLoadOrderGroup;\n            public int dwTagId;\n            public string lpDependencies;\n            public string lpServiceStartName;\n            public string lpDisplayName;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]", "            public string lpDependencies;\n            public string lpServiceStartName;\n            public string lpDisplayName;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct SERVICE_STATUS_PROCESS\n        {\n            public ServiceType dwServiceType;\n            public ServiceState dwCurrentState;\n            public uint dwControlsAccepted;", "            public ServiceType dwServiceType;\n            public ServiceState dwCurrentState;\n            public uint dwControlsAccepted;\n            public uint dwWin32ExitCode;\n            public uint dwServiceSpecificExitCode;\n            public uint dwCheckPoint;\n            public uint dwWaitHint;\n            public uint dwProcessId;\n            public uint dwServiceFlags;\n        }\n\n\n        [StructLayout(LayoutKind.Sequential)]", "            public uint dwServiceFlags;\n        }\n\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct SERVICE_STATUS\n        {\n            public ServiceType dwServiceType;\n            public ServiceState dwCurrentState;\n            public int dwControlsAccepted;\n            public int dwWin32ExitCode;", "            public ServiceState dwCurrentState;\n            public int dwControlsAccepted;\n            public int dwWin32ExitCode;\n            public int dwServiceSpecificExitCode;\n            public int dwCheckPoint;\n            public int dwWaitHint;\n        }\n\n\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n        public struct ServiceDescription\n        {\n            [MarshalAs(UnmanagedType.LPWStr)]\n            public string? lpDescription;\n        }\n\n\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]", "        public struct ServiceDescription\n        {\n            [MarshalAs(UnmanagedType.LPWStr)]\n            public string? lpDescription;\n        }\n\n\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n        public struct SC_ACTION\n        {\n            public SC_ACTION_TYPE Type;", "        public struct SC_ACTION\n        {\n            public SC_ACTION_TYPE Type;\n            public uint Delay;\n        }\n\n\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n        public struct SERVICE_FAILURE_ACTIONS\n        {\n            public int dwResetPeriod;", "        public struct SERVICE_FAILURE_ACTIONS\n        {\n            public int dwResetPeriod;\n            public unsafe char* lpRebootMsg;\n            public unsafe char* lpCommand;\n            public int cActions;\n            public unsafe SC_ACTION* lpsaActions;\n        }\n\n\n\n        [DllImport(AdvApi32Lib, SetLastError = true, CharSet = CharSet.Unicode)]", "        public static extern SafeServiceHandle OpenSCManager(\n            string? lpMachineName,\n            string? lpDatabaseName,\n            ServiceManagerAccess dwDesiredAccess);\n\n        [DllImport(AdvApi32Lib, SetLastError = true, CharSet = CharSet.Unicode)]\n        public static extern SafeServiceHandle OpenService(\n            SafeServiceHandle hSCManager,\n            string lpServiceName,\n            ServiceAccess dwDesiredAccess);\n\n        [DllImport(AdvApi32Lib, SetLastError = true, CharSet = CharSet.Unicode)]", "        public static extern SafeServiceHandle CreateService(\n            SafeServiceHandle hSCManager,\n            string lpServiceName,\n            string? lpDisplayName,\n            ServiceAccess dwDesiredAccess,\n            ServiceType dwServiceType,\n            ServiceStartType dwStartType,\n            ServiceErrorControl dwErrorControl,\n            string lpBinaryPathName,\n            string? lpLoadOrderGroup,\n            int lpdwTagId,\n            string? lpDependencies,\n            string? lpServiceStartName,\n            string? lpPassword);\n\n        [DllImport(AdvApi32Lib, SetLastError = true, CharSet = CharSet.Unicode)]", "        public static extern bool StartService(\n            SafeServiceHandle hService,\n            int dwNumServiceArgs,\n            string? lpServiceArgVectors);\n\n        [DllImport(AdvApi32Lib, SetLastError = true)]\n        public static extern bool DeleteService(\n            SafeServiceHandle hService);\n\n        [DllImport(AdvApi32Lib, SetLastError = true)]\n        public static unsafe extern bool QueryServiceStatusEx(\n            SafeServiceHandle hService,\n            SC_STATUS_TYPE InfoLevel,\n            void* lpBuffer,\n            int cbBufSize,\n            out int pcbBytesNeeded);\n\n        [DllImport(AdvApi32Lib, CharSet = CharSet.Auto, SetLastError = true)]", "        public static unsafe extern bool QueryServiceStatusEx(\n            SafeServiceHandle hService,\n            SC_STATUS_TYPE InfoLevel,\n            void* lpBuffer,\n            int cbBufSize,\n            out int pcbBytesNeeded);\n\n        [DllImport(AdvApi32Lib, CharSet = CharSet.Auto, SetLastError = true)]\n        public static extern bool QueryServiceConfig(\n            SafeServiceHandle serviceHandle,\n            IntPtr buffer,\n            int bufferSize,\n            out int bytesNeeded);\n\n        [DllImport(AdvApi32Lib, SetLastError = true)]", "        public static extern bool QueryServiceConfig(\n            SafeServiceHandle serviceHandle,\n            IntPtr buffer,\n            int bufferSize,\n            out int bytesNeeded);\n\n        [DllImport(AdvApi32Lib, SetLastError = true)]\n        public static extern bool QueryServiceStatus(\n            SafeServiceHandle hService,\n            ref SERVICE_STATUS dwServiceStatus);\n\n\n        [DllImport(AdvApi32Lib, SetLastError = true, CharSet = CharSet.Unicode)]", "        public static unsafe extern bool ChangeServiceConfig2(\n            SafeServiceHandle hService,\n            ServiceInfoLevel dwInfoLevel,\n            void* lpInfo);\n\n        [DllImport(AdvApi32Lib, SetLastError = true)]\n        public static extern bool ControlService(\n            SafeServiceHandle hService,\n            ServiceControl dwControl,\n            ref SERVICE_STATUS lpServiceStatus);\n\n        /// <summary>\n        /// \u8868\u793a\u5b89\u5168\u670d\u52a1\u53e5\u67c4\n        /// </summary>", "        public class SafeServiceHandle : SafeHandle\n        {\n            [DllImport(AdvApi32Lib, SetLastError = true)]\n            private static extern bool CloseServiceHandle(IntPtr hSCObject);\n\n            public SafeServiceHandle()\n                : base(IntPtr.Zero, ownsHandle: true)\n            {\n            }\n\n            /// <inheritdoc />", "            public override bool IsInvalid => this.handle == IntPtr.Zero;\n\n            /// <inheritdoc />\n            protected override bool ReleaseHandle()\n            {\n                return CloseServiceHandle(this.handle);\n            }\n        }\n    }\n}\n"]}
{"filename": "ServiceSelf/Service.Self.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.Hosting.Systemd;\nusing Microsoft.Extensions.Hosting.WindowsServices;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Runtime.Versioning;\n\nnamespace ServiceSelf", "\nnamespace ServiceSelf\n{\n    partial class Service\n    {\n        [DllImport(\"kernel32\")]\n        [SupportedOSPlatform(\"windows\")]\n        private static extern bool AllocConsole();\n\n        [DllImport(\"libc\")]\n        [SupportedOSPlatform(\"linux\")]", "        private static extern int openpty(out int master, out int slave, IntPtr name, IntPtr termios, IntPtr winsize);\n\n        /// <summary>\n        /// \u4e3a\u7a0b\u5e8f\u5e94\u7528ServiceSelf\n        /// \u8fd4\u56detrue\u8868\u793a\u53ef\u4ee5\u6b63\u5e38\u8fdb\u5165\u7a0b\u5e8f\u903b\u8f91\n        /// </summary> \n        /// <param name=\"args\">\u542f\u52a8\u53c2\u6570</param>\n        /// <param name=\"serviceName\">\u670d\u52a1\u540d</param>\n        /// <param name=\"serviceArguments\">\u670d\u52a1\u542f\u52a8\u53c2\u6570</param>\n        /// <returns></returns>\n        /// <exception cref=\"FileNotFoundException\"></exception>\n        /// <exception cref=\"PlatformNotSupportedException\"></exception>", "        public static bool UseServiceSelf(string[] args, string? serviceName = null, IEnumerable<Argument>? serviceArguments = null)\n        {\n            var serviceOptions = new ServiceOptions { Arguments = serviceArguments };\n            return UseServiceSelf(args, serviceName, serviceOptions);\n        }\n\n        /// <summary>\n        /// \u4e3a\u7a0b\u5e8f\u5e94\u7528ServiceSelf\n        /// \u8fd4\u56detrue\u8868\u793a\u53ef\u4ee5\u6b63\u5e38\u8fdb\u5165\u7a0b\u5e8f\u903b\u8f91\n        /// <para>start  \u5b89\u88c5\u5e76\u542f\u52a8\u670d\u52a1</para>\n        /// <para>stop \u505c\u6b62\u5e76\u5220\u9664\u670d\u52a1</para>\n        /// <para>logs \u63a7\u5236\u53f0\u8f93\u51fa\u670d\u52a1\u7684\u65e5\u5fd7</para>\n        /// <para>logs filter=\"key words\" \u63a7\u5236\u53f0\u8f93\u51fa\u8fc7\u6ee4\u7684\u670d\u52a1\u65e5\u5fd7</para>\n        /// </summary> \n        /// <param name=\"args\">\u542f\u52a8\u53c2\u6570</param>\n        /// <param name=\"serviceName\">\u670d\u52a1\u540d</param>\n        /// <param name=\"serviceOptions\">\u670d\u52a1\u9009\u9879</param>\n        /// <returns></returns>\n        /// <exception cref=\"FileNotFoundException\"></exception>\n        /// <exception cref=\"PlatformNotSupportedException\"></exception>", "        public static bool UseServiceSelf(string[] args, string? serviceName, ServiceOptions? serviceOptions)\n        {\n            // windows\u670d\u52a1\u6a21\u5f0f\u65f6\u9700\u8981\u5c06\u5de5\u4f5c\u76ee\u5f55\u53c2\u6570\u8bbe\u7f6e\u5230\u73af\u5883\u53d8\u91cf\n            if (WindowsServiceHelpers.IsWindowsService())\n            {\n                return WindowsService.UseWorkingDirectory(args);\n            }\n\n            // systemd\u670d\u52a1\u6a21\u5f0f\u65f6\u4e0d\u518d\u68c0\u67e5\u4efb\u4f55\u53c2\u6570\n            if (SystemdHelpers.IsSystemdService())\n            {\n                return true;\n            }\n\n            // \u5177\u6709\u53ef\u4ea4\u4e92\u7684\u6a21\u5f0f\u65f6\uff0c\u6bd4\u5982\u684c\u9762\u7a0b\u5e8f\u3001\u63a7\u5236\u53f0\u7b49", "            if (SystemdHelpers.IsSystemdService())\n            {\n                return true;\n            }\n\n            // \u5177\u6709\u53ef\u4ea4\u4e92\u7684\u6a21\u5f0f\u65f6\uff0c\u6bd4\u5982\u684c\u9762\u7a0b\u5e8f\u3001\u63a7\u5236\u53f0\u7b49\n            if (Enum.TryParse<Command>(args.FirstOrDefault(), true, out var command) &&\n                Enum.IsDefined(typeof(Command), command))\n            {\n                var arguments = args.Skip(1);\n                UseCommand(command, arguments, serviceName, serviceOptions);\n                return false;\n            }\n\n            // \u6ca1\u6709command\u5b50\u547d\u4ee4\u65f6\n            return true;\n        }\n\n\n        /// <summary>\n        /// \u5e94\u7528\u670d\u52a1\u547d\u4ee4\n        /// </summary>\n        /// <param name=\"command\"></param> \n        /// <param name=\"arguments\">\u5269\u4f59\u53c2\u6570</param>\n        /// <param name=\"name\">\u670d\u52a1\u540d</param>\n        /// <param name=\"options\">\u670d\u52a1\u9009\u9879</param> \n        /// <returns></returns>\n        /// <exception cref=\"FileNotFoundException\"></exception>\n        /// <exception cref=\"PlatformNotSupportedException\"></exception>", "        private static void UseCommand(Command command, IEnumerable<string> arguments, string? name, ServiceOptions? options)\n        {\n#if NET6_0_OR_GREATER\n            var filePath = Environment.ProcessPath;\n#else\n            var filePath = System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName;\n#endif\n            if (string.IsNullOrEmpty(filePath))\n            {\n                throw new FileNotFoundException(\"\u65e0\u6cd5\u83b7\u53d6\u5f53\u524d\u8fdb\u7a0b\u7684\u542f\u52a8\u6587\u4ef6\u8def\u5f84\");\n            }\n", "            if (string.IsNullOrEmpty(name))\n            {\n                name = RuntimeInformation.IsOSPlatform(OSPlatform.Windows)\n                    ? Path.GetFileNameWithoutExtension(filePath)\n                    : Path.GetFileName(filePath);\n            }\n\n            var service = Create(name);\n            if (command == Command.Start)\n            {\n                service.CreateStart(filePath, options ?? new ServiceOptions());\n            }", "            if (command == Command.Start)\n            {\n                service.CreateStart(filePath, options ?? new ServiceOptions());\n            }\n            else if (command == Command.Stop)\n            {\n                service.StopDelete();\n            }\n            else if (command == Command.Logs)\n            {\n                var writer = GetConsoleWriter();\n                var filter = Argument.GetValueOrDefault(arguments, \"filter\");\n                service.ListenLogs(filter, log => log.WriteTo(writer));\n            }\n        }\n\n        /// <summary>\n        /// \u83b7\u53d6\u63a7\u5236\u53f0\u8f93\u51fa\n        /// </summary>\n        /// <returns></returns>", "            else if (command == Command.Logs)\n            {\n                var writer = GetConsoleWriter();\n                var filter = Argument.GetValueOrDefault(arguments, \"filter\");\n                service.ListenLogs(filter, log => log.WriteTo(writer));\n            }\n        }\n\n        /// <summary>\n        /// \u83b7\u53d6\u63a7\u5236\u53f0\u8f93\u51fa\n        /// </summary>\n        /// <returns></returns>", "        private static TextWriter GetConsoleWriter()\n        {\n            using (var stream = Console.OpenStandardOutput())\n            {\n                if (stream != Stream.Null)\n                {\n                    return Console.Out;\n                }\n            }\n\n            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\n            {\n                AllocConsole();\n            }", "            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\n            {\n                AllocConsole();\n            }\n            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))\n            {\n                openpty(out var _, out var _, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero);\n            }\n\n            var outputStream = Console.OpenStandardOutput();\n            var streamWriter = new StreamWriter(outputStream, Console.OutputEncoding, 256, leaveOpen: true)\n            {\n                AutoFlush = true\n            };\n\n            // Synchronized\u786e\u4fdd\u7ebf\u7a0b\u5b89\u5168\n            return TextWriter.Synchronized(streamWriter);\n        }\n    }\n}\n"]}
{"filename": "ServiceSelf/SupportedOSPlatformAttribute.cs", "chunked_list": ["\ufeff#if NETCOREAPP3_1\n\nnamespace System.Runtime.Versioning\n{\n    sealed class SupportedOSPlatformAttribute : Attribute\n    {\n        public string PlatformName { get; }\n\n        public SupportedOSPlatformAttribute(string platformName)\n        {\n            this.PlatformName = platformName;\n        }\n    }\n}\n#endif"]}
{"filename": "ServiceSelf/Command.cs", "chunked_list": ["\ufeffnamespace ServiceSelf\n{\n    /// <summary>\n    /// \u670d\u52a1\u547d\u4ee4\n    /// </summary>\n    enum Command\n    {\n        /// <summary>\n        /// \u505c\u6b62\u5e76\u5220\u9664\n        /// </summary>\n        Stop = 0,\n\n        /// <summary>\n        /// \u5b89\u88c5\u5e76\u542f\u52a8\n        /// </summary>\n        Start = 1,\n\n        /// <summary>\n        /// \u67e5\u770b\u65e5\u5fd7\n        /// </summary>\n        Logs = 2\n    }\n}\n"]}
{"filename": "ServiceSelf/SystemdServiceSection.cs", "chunked_list": ["\ufeffnamespace ServiceSelf\n{\n    /// <summary>\n    /// Service\u7ae0\u8282\n    /// </summary>\n    public sealed class SystemdServiceSection : SystemdSection\n    {\n        /// <summary>\n        /// Service\u7ae0\u8282\n        /// </summary>\n        public SystemdServiceSection()\n            : base(\"[Service]\")\n        {\n        }\n\n        /// <summary>\n        /// Service\u7ae0\u8282\n        /// </summary>\n        /// <param name=\"section\"></param>\n        public SystemdServiceSection(SystemdServiceSection section)\n            : this()\n        {", "            foreach (var item in section)\n            {\n                this[item.Key] = item.Value;\n            }\n        }\n\n        /// <summary>\n        /// \u670d\u52a1\u7c7b\u578b\n        /// <para>simple\u5728\u6b64\u6a21\u5f0f\u4e0b\uff0csystemd\u8ba4\u4e3a\u670d\u52a1\u8fdb\u7a0b\u5c06\u59cb\u7ec8\u4fdd\u6301\u5728\u524d\u53f0\u8fd0\u884c\uff0c\u800c\u4e14\u4e0d\u4f1a\u9000\u51fa\u76f4\u5230\u88ab\u663e\u5f0f\u505c\u6b62</para>\n        /// <para>forking \u5728\u6b64\u6a21\u5f0f\u4e0b\uff0csystemd\u5047\u5b9a\u670d\u52a1\u8fdb\u7a0b\u4f1a\u5728\u540e\u53f0\u8fd0\u884c\uff0c\u5e76\u4f1a\u6d3e\u751f\u51fa\u4e00\u4e2a\u5b50\u8fdb\u7a0b\u6765\u5b8c\u6210\u5b9e\u9645\u5de5\u4f5c\u3002</para>\n        /// <para>oneshot \u5728\u6b64\u6a21\u5f0f\u4e0b\uff0csystemd\u5047\u5b9a\u670d\u52a1\u8fdb\u7a0b\u53ea\u9700\u8981\u5728\u7cfb\u7edf\u542f\u52a8\u65f6\u8fd0\u884c\u4e00\u6b21\uff0c\u7136\u540e\u7acb\u5373\u9000\u51fa</para>\n        /// <para>dbus \u5728\u6b64\u6a21\u5f0f\u4e0b\uff0csystemd\u5c06\u901a\u8fc7DBus\u63a5\u53e3\u4e0e\u670d\u52a1\u8fdb\u7a0b\u901a\u4fe1\u3002</para>\n        /// <para>notify \u670d\u52a1\u8fdb\u7a0b\u53ef\u4ee5\u901a\u8fc7\u53d1\u9001\u901a\u77e5\u6d88\u606f\u6765\u8868\u660e\u5b83\u5df2\u7ecf\u542f\u52a8</para>\n        /// <para>idle \u670d\u52a1\u8fdb\u7a0b\u5e94\u8be5\u5c3d\u53ef\u80fd\u63a8\u8fdf\u542f\u52a8</para> \n        /// </summary>\n        public string? Type\n        {\n            get => Get(nameof(Type));\n            set => Set(nameof(Type), value);\n        }\n\n        /// <summary>\n        /// \u4e3a\u670d\u52a1\u5b9a\u4e49\u73af\u5883\u53d8\u91cf\n        /// </summary>\n        public string? Environment\n        {\n            get => Get(nameof(Environment));\n            set => Set(nameof(Environment), value);\n        }\n\n        /// <summary>\n        /// \u670d\u52a1\u8fdb\u7a0b\u8fd0\u884c\u7684\u7528\u6237\n        /// </summary>\n        public string? User\n        {\n            get => Get(nameof(User));\n            set => Set(nameof(User), value);\n        }\n\n        /// <summary>\n        /// \u670d\u52a1\u8fdb\u7a0b\u8fd0\u884c\u7684\u7528\u6237\u7ec4\n        /// </summary>\n        public string? Group\n        {\n            get => Get(nameof(Group));\n            set => Set(nameof(Group), value);\n        }\n\n        /// <summary>\n        /// \u91cd\u542f\u9009\u9879\n        /// <para>no \u4e0d\u81ea\u52a8\u91cd\u542f\u670d\u52a1\uff0c\u5982\u679c\u670d\u52a1\u5d29\u6e83\u6216\u9000\u51fa\uff0c\u5219\u4e0d\u4f1a\u81ea\u52a8\u91cd\u542f</para>\n        /// <para>on-success \u53ea\u6709\u5728\u670d\u52a1\u4ee5\u9000\u51fa\u72b6\u60010\u6210\u529f\u5b8c\u6210\u65f6\u624d\u81ea\u52a8\u91cd\u542f</para>\n        /// <para>on-failure \u53ea\u6709\u5728\u670d\u52a1\u4ee5\u9000\u51fa\u72b6\u6001\u975e\u96f6\u5931\u8d25\u65f6\u624d\u81ea\u52a8\u91cd\u542f</para>\n        /// <para>on-abnormal \u53ea\u6709\u5728\u670d\u52a1\u5f02\u5e38\u9000\u51fa\u65f6\u624d\u81ea\u52a8\u91cd\u542f\uff0c\u4f8b\u5982\u4fe1\u53f79\u7ec8\u6b62\u8fdb\u7a0b</para>\n        /// <para>on-abort \u53ea\u6709\u5728\u670d\u52a1\u88ab\u663e\u5f0f\u505c\u6b62\u65f6\u624d\u81ea\u52a8\u91cd\u542f</para>\n        /// <para>on-watchdog \u53ea\u6709\u5f53WatchdogSec\uff08\u770b\u95e8\u72d7\uff09\u6307\u5b9a\u7684\u65f6\u95f4\u5185\u672a\u6536\u5230\u670d\u52a1\u53d1\u9001\u7684\u201c\u5582\u72d7\u201d\u4fe1\u53f7\u65f6\uff0c\u624d\u4f1a\u81ea\u52a8\u91cd\u542f\u670d</para>\n        /// <para>always \u65e0\u8bba\u9000\u51fa\u72b6\u6001\u5982\u4f55\uff0c\u90fd\u81ea\u52a8\u91cd\u542f\u670d\u52a1</para>\n        /// </summary>\n        public string? Restart\n        {\n            get => Get(nameof(Restart));\n            set => Set(nameof(Restart), value);\n        }\n\n        /// <summary>\n        /// \u5c1d\u8bd5\u91cd\u65b0\u542f\u52a8\u670d\u52a1\u4e4b\u524d\u9700\u8981\u7b49\u5f85\u591a\u957f\u65f6\u95f4\n        /// </summary>\n        public string? RestartSec\n        {\n            get => Get(nameof(RestartSec));\n            set => Set(nameof(RestartSec), value);\n        }\n\n        /// <summary>\n        /// \u542f\u52a8\u670d\u52a1\u8fdb\u7a0b\u7684\u6700\u957f\u65f6\u95f4\n        /// </summary>\n        public string? TimeoutStartSec\n        {\n            get => Get(nameof(TimeoutStartSec));\n            set => Set(nameof(TimeoutStartSec), value);\n        }\n\n        /// <summary>\n        /// \u505c\u6b62\u670d\u52a1\u8fdb\u7a0b\u7684\u6700\u957f\u65f6\u95f4\n        /// </summary>\n        public string? TimeoutStopSec\n        {\n            get => Get(nameof(TimeoutStopSec));\n            set => Set(nameof(TimeoutStopSec), value);\n        }\n    }\n}\n"]}
{"filename": "ServiceSelf/SystemdInstallSection.cs", "chunked_list": ["\ufeffnamespace ServiceSelf\n{\n    /// <summary>\n    /// Install\u7ae0\u8282\n    /// </summary>\n    public sealed class SystemdInstallSection : SystemdSection\n    {\n        /// <summary>\n        /// Install\u7ae0\u8282\n        /// </summary>\n        public SystemdInstallSection()\n            : base(\"[Install]\")\n        {\n        }\n\n        /// <summary>\n        /// Install\u7ae0\u8282\n        /// </summary>\n        /// <param name=\"section\"></param>\n        public SystemdInstallSection(SystemdInstallSection section)\n            : this()\n        {", "            foreach (var item in section)\n            {\n                this[item.Key] = item.Value;\n            }\n        }\n\n        /// <summary>\n        /// \u5c06\u5355\u5143\u94fe\u63a5\u5230\u63d0\u4f9b\u7279\u5b9a\u529f\u80fd\u7684.target\u5355\u5143\n        /// </summary>\n        public string? WantedBy\n        {\n            get => Get(nameof(WantedBy));\n            set => Set(nameof(WantedBy), value);\n        }\n\n        /// <summary>\n        /// \u5728\u542f\u52a8\u65f6\u5f3a\u5236\u4f9d\u8d56\u4e8e\u5355\u4e2a\u6216\u591a\u4e2a\u5176\u4ed6\u5355\u5143\n        /// </summary>\n        public string? RequiredBy\n        {\n            get => Get(nameof(RequiredBy));\n            set => Set(nameof(RequiredBy), value);\n        }\n    }\n}\n"]}
{"filename": "ServiceSelf/Argument.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics.CodeAnalysis;\n\nnamespace ServiceSelf\n{\n    /// <summary>\n    /// \u542f\u52a8\u53c2\u6570\n    /// </summary>\n    public class Argument\n    {", "    /// </summary>\n    public class Argument\n    {\n        private readonly string argument;\n\n        /// <summary>\n        /// \u542f\u52a8\u53c2\u6570\n        /// </summary>\n        /// <param name=\"argument\">\u53c2\u6570</param>\n        public Argument(string argument)\n        {\n            this.argument = argument;\n        }\n\n        /// <summary>\n        /// \u542f\u52a8\u53c2\u6570\n        /// </summary>\n        /// <param name=\"name\">\u53c2\u6570\u540d</param>\n        /// <param name=\"value\">\u53c2\u6570\u503c</param>\n        public Argument(string name, object? value)\n        {\n            this.argument = @$\"{name}=\"\"{value}\"\"\";\n        }\n\n        /// <summary>\n        /// \u8f6c\u6362\u4e3a\u6587\u672c\n        /// </summary>\n        /// <returns></returns>", "        public override string ToString()\n        {\n            return this.argument;\n        }\n\n        /// <summary>\n        /// \u83b7\u53d6\u503c\n        /// </summary>\n        /// <param name=\"arguments\"></param>\n        /// <param name=\"name\"></param>\n        /// <returns></returns>", "        public static string? GetValueOrDefault(IEnumerable<string> arguments, string name)\n        {\n            return TryGetValue(arguments, name, out var value) ? value : default;\n        }\n\n        /// <summary>\n        /// \u5c1d\u8bd5\u89e3\u6790\u503c\n        /// </summary>\n        /// <param name=\"arguments\"></param>\n        /// <param name=\"name\"></param>\n        /// <param name=\"value\"></param>\n        /// <returns></returns>", "        public static bool TryGetValue(IEnumerable<string> arguments, string name, [MaybeNullWhen(false)] out string value)\n        {\n            var prefix = $\"{name}=\".AsSpan();\n            foreach (var argument in arguments)\n            {\n                if (TryGetValue(argument, prefix, out value))\n                {\n                    return true;\n                }\n            }\n\n            value = null;\n            return false;\n        }\n\n        /// <summary>\n        /// \u5c1d\u8bd5\u89e3\u6790\u503c\n        /// </summary>\n        /// <param name=\"argument\"></param>\n        /// <param name=\"prefix\"></param>\n        /// <param name=\"value\"></param>\n        /// <returns></returns>", "        private static bool TryGetValue(ReadOnlySpan<char> argument, ReadOnlySpan<char> prefix, [MaybeNullWhen(false)] out string value)\n        {\n            if (argument.StartsWith(prefix, StringComparison.OrdinalIgnoreCase) == false)\n            {\n                value = null;\n                return false;\n            }\n\n            var valueSpan = argument[prefix.Length..];\n            if (valueSpan.Length > 1 && valueSpan[0] == '\"' && valueSpan[^1] == '\"')\n            {\n                valueSpan = valueSpan[1..^1];\n            }\n\n            value = valueSpan.ToString();\n            return true;\n        }\n    }\n}\n", "            if (valueSpan.Length > 1 && valueSpan[0] == '\"' && valueSpan[^1] == '\"')\n            {\n                valueSpan = valueSpan[1..^1];\n            }\n\n            value = valueSpan.ToString();\n            return true;\n        }\n    }\n}\n"]}
{"filename": "ServiceSelf/LinuxService.cs", "chunked_list": ["\ufeffusing System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Runtime.Versioning;\nusing System.Text.RegularExpressions;\n\nnamespace ServiceSelf\n{", "namespace ServiceSelf\n{\n    [SupportedOSPlatform(\"linux\")]\n    sealed class LinuxService : Service\n    {\n        [DllImport(\"libc\", SetLastError = true)]\n        private static extern uint geteuid();\n\n        [DllImport(\"libc\")]\n        private static extern int kill(int pid, int sig);\n\n        public LinuxService(string name)\n            : base(name)\n        {\n        }\n", "        private static extern int kill(int pid, int sig);\n\n        public LinuxService(string name)\n            : base(name)\n        {\n        }\n\n        public override void CreateStart(string filePath, ServiceOptions options)\n        {\n            CheckRoot();\n\n            filePath = Path.GetFullPath(filePath);\n\n            var unitName = $\"{this.Name}.service\";\n            var unitFilePath = $\"/etc/systemd/system/{unitName}\";\n            var oldFilePath = QueryServiceFilePath(unitFilePath);\n", "            if (oldFilePath.Length > 0 && oldFilePath.Equals(filePath, StringComparison.OrdinalIgnoreCase) == false)\n            {\n                throw new InvalidOperationException(\"\u7cfb\u7edf\u5df2\u5b58\u5728\u540c\u540d\u4f46\u4e0d\u540c\u8def\u5f84\u7684\u670d\u52a1\");\n            }\n\n            var linuxOptions = CreateLinuxOptions(filePath, options);\n            using (var fileStream = File.OpenWrite(unitFilePath))\n            {\n                using var wirter = new StreamWriter(fileStream);\n                linuxOptions.WriteTo(wirter);\n            }\n\n            // SELinux\n            Shell(\"chcon\", $\"--type=bin_t {filePath}\", showError: false);\n\n            SystemControl(\"daemon-reload\", showError: true);\n            SystemControl($\"start {unitName}\", showError: true);\n            SystemControl($\"enable {unitName}\", showError: false);\n        }\n", "        private static ReadOnlySpan<char> QueryServiceFilePath(string unitFilePath)\n        {\n            if (File.Exists(unitFilePath) == false)\n            {\n                return ReadOnlySpan<char>.Empty;\n            }\n\n            var execStartPrefix = \"ExecStart=\".AsSpan();\n            var wantedByPrefix = \"WantedBy=\".AsSpan();\n\n            using var stream = File.OpenRead(unitFilePath);\n            var reader = new StreamReader(stream);\n\n            var filePath = ReadOnlySpan<char>.Empty;\n            var wantedBy = ReadOnlySpan<char>.Empty;", "            while (reader.EndOfStream == false)\n            {\n                var line = reader.ReadLine().AsSpan();\n                if (line.StartsWith(execStartPrefix, StringComparison.OrdinalIgnoreCase))\n                {\n                    line = line[execStartPrefix.Length..];\n                    var index = line.IndexOf(' ');\n                    filePath = index < 0 ? line : line[..index];\n                }\n                else if (line.StartsWith(wantedByPrefix, StringComparison.OrdinalIgnoreCase))\n                {\n                    wantedBy = line[wantedByPrefix.Length..].Trim();\n                }\n", "                else if (line.StartsWith(wantedByPrefix, StringComparison.OrdinalIgnoreCase))\n                {\n                    wantedBy = line[wantedByPrefix.Length..].Trim();\n                }\n\n                if (filePath.Length > 0 && wantedBy.Length > 0)\n                {\n                    break;\n                }\n            }\n", "            if (filePath.IsEmpty || wantedBy.IsEmpty)\n            {\n                return ReadOnlySpan<char>.Empty;\n            }\n\n            var wants = $\"{wantedBy.ToString()}.wants\";\n            var unitFileName = Path.GetFileName(unitFilePath);\n            var unitFileDir = Path.GetDirectoryName(unitFilePath);\n            var unitLink = Path.Combine(unitFileDir!, wants, unitFileName);\n            return File.Exists(unitLink) ? filePath : ReadOnlySpan<char>.Empty;\n        }\n\n", "        private static LinuxServiceOptions CreateLinuxOptions(string filePath, ServiceOptions options)\n        {\n            var execStart = filePath;\n            if (options.Arguments != null)\n            {\n                var args = options.Arguments.ToArray(); // \u9632\u6b62\u591a\u6b21\u8fed\u4ee3\n                if (args.Length > 0)\n                {\n                    execStart = $\"{filePath} {string.Join<Argument>(' ', args)}\";\n                }\n            }\n\n            var workingDirectory = string.IsNullOrEmpty(options.WorkingDirectory)\n                ? Path.GetDirectoryName(filePath)\n                : Path.GetFullPath(options.WorkingDirectory);\n\n            var linuxOptions = options.Linux.Clone();\n            linuxOptions.Unit[\"Description\"] = options.Description;\n            linuxOptions.Service[\"ExecStart\"] = execStart;\n            linuxOptions.Service[\"WorkingDirectory\"] = workingDirectory;\n", "            if (string.IsNullOrEmpty(linuxOptions.Service.Type))\n            {\n                linuxOptions.Service.Type = \"notify\";\n            }\n\n            if (string.IsNullOrEmpty(linuxOptions.Install.WantedBy))\n            {\n                linuxOptions.Install.WantedBy = \"multi-user.target\";\n            }\n\n            return linuxOptions;\n        }\n\n", "        public override void StopDelete()\n        {\n            CheckRoot();\n\n            var unitName = $\"{this.Name}.service\";\n            var unitFilePath = $\"/etc/systemd/system/{unitName}\";\n            if (File.Exists(unitFilePath) == false)\n            {\n                return;\n            }\n\n            SystemControl($\"stop {unitName}\", showError: true);\n            SystemControl($\"disable {unitName}\", showError: false);\n            SystemControl(\"daemon-reload\", showError: true);\n\n            File.Delete(unitFilePath);\n        }\n\n\n        /// <summary>\n        /// \u5c1d\u8bd5\u67e5\u8be2\u670d\u52a1\u7684\u8fdb\u7a0bid\n        /// </summary> \n        /// <param name=\"processId\"></param>\n        /// <returns></returns>", "        protected override bool TryGetProcessId(out int processId)\n        {\n            CheckRoot();\n\n            processId = 0;\n            var output = SystemControl($\"show -p MainPID {this.Name}.service\", false);\n            if (output == null)\n            {\n                return false;\n            }\n\n            var match = Regex.Match(output, @\"\\d+\");\n            return match.Success &&\n                int.TryParse(match.Value, out processId) &&\n                processId > 0 &&\n                kill(processId, 0) == 0;\n        }\n", "        private static string? SystemControl(string arguments, bool showError)\n        {\n            return Shell(\"systemctl\", arguments, showError);\n        }\n\n        private static string? Shell(string fileName, string arguments, bool showError)\n        {\n            var startInfo = new ProcessStartInfo\n            {\n                FileName = fileName,\n                Arguments = arguments,\n                UseShellExecute = false,\n                RedirectStandardOutput = true,\n                RedirectStandardError = !showError\n            };\n            var process = Process.Start(startInfo);", "            if (process == null)\n            {\n                return null;\n            }\n\n            var output = process.StandardOutput.ReadToEnd();\n            process.WaitForExit();\n            return output;\n        }\n\n        private static void CheckRoot()\n        {", "        private static void CheckRoot()\n        {\n            if (geteuid() != 0)\n            {\n                throw new UnauthorizedAccessException(\"\u65e0\u6cd5\u64cd\u4f5c\u670d\u52a1\uff1a\u6ca1\u6709root\u6743\u9650\");\n            }\n        }\n    }\n}\n"]}
{"filename": "ServiceSelf/WindowsServiceActionType.cs", "chunked_list": ["\ufeffnamespace ServiceSelf\n{\n    /// <summary>\n    /// windows\u670d\u52a1\u64cd\u4f5c\u7c7b\u578b\n    /// </summary>\n    public enum WindowsServiceActionType\n    {\n        /// <summary>\n        /// \u8868\u793a\u4e0d\u6267\u884c\u4efb\u4f55\u64cd\u4f5c\n        /// </summary>\n        None = 0,\n\n        /// <summary>\n        /// \u8868\u793a\u91cd\u65b0\u542f\u52a8\u670d\u52a1\n        /// </summary>\n        Restart = 1,\n\n        /// <summary>\n        /// \u8868\u793a\u91cd\u65b0\u542f\u52a8\u8ba1\u7b97\u673a\n        /// </summary>\n        Reboot = 2,\n    }\n}\n"]}
{"filename": "ServiceSelf/LinuxServiceOptions.cs", "chunked_list": ["\ufeffusing System.IO;\n\nnamespace ServiceSelf\n{\n    /// <summary>\n    /// linux\u72ec\u6709\u7684\u670d\u52a1\u9009\u9879\n    /// </summary>\n    public sealed class LinuxServiceOptions\n    {\n        /// <summary>\n        /// \u83b7\u53d6Unit\u7ae0\u8282\n        /// </summary>", "        public SystemdUnitSection Unit { get; private set; } = new SystemdUnitSection();\n\n        /// <summary>\n        /// \u83b7\u53d6Service\u7ae0\u8282\n        /// </summary>\n        public SystemdServiceSection Service { get; private set; } = new SystemdServiceSection();\n\n        /// <summary>\n        /// \u83b7\u53d6Install\u7ae0\u8282\n        /// </summary>\n        public SystemdInstallSection Install { get; private set; } = new SystemdInstallSection();\n\n        /// <summary>\n        /// \u514b\u9686\n        /// </summary>\n        /// <returns></returns>", "        public SystemdInstallSection Install { get; private set; } = new SystemdInstallSection();\n\n        /// <summary>\n        /// \u514b\u9686\n        /// </summary>\n        /// <returns></returns>\n        public LinuxServiceOptions Clone()\n        {\n            return new LinuxServiceOptions\n            {\n                Unit = new SystemdUnitSection(this.Unit),\n                Service = new SystemdServiceSection(this.Service),\n                Install = new SystemdInstallSection(this.Install),\n            };\n        }\n\n        /// <summary>\n        /// \u8f6c\u6362\u4e3a\u6587\u672c\n        /// </summary>\n        /// <returns></returns>", "        public override string ToString()\n        {\n            var writer = new StringWriter();\n            this.WriteTo(writer);\n            return writer.ToString();\n        }\n\n        /// <summary>\n        /// \u5199\u5165writer\n        /// </summary>\n        /// <param name=\"writer\"></param>", "        public void WriteTo(TextWriter writer)\n        {\n            this.Unit.WriteTo(writer);\n            this.Service.WriteTo(writer);\n            this.Install.WriteTo(writer);\n        }\n    }\n}\n"]}
{"filename": "ServiceSelf/LogItem.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO;\n\nnamespace ServiceSelf\n{\n    partial class LogItem\n    {\n        /// <summary>\n        /// \u65e5\u5fd7\u7ea7\u522b\n        /// </summary>", "        public LogLevel LogLevel => (LogLevel)this.Level;\n\n        /// <summary>\n        /// \u662f\u5426\u5339\u914d\u8fc7\u6ee4\u5668\n        /// </summary>\n        /// <param name=\"filter\">\u8fc7\u6ee4\u5668</param>\n        /// <returns></returns>\n        public bool IsMatch(ReadOnlySpan<char> filter)\n        {\n            return filter.IsEmpty ||\n                this.LogLevel.ToString().AsSpan().Equals(filter, StringComparison.InvariantCulture) ||\n                this.LoggerName.AsSpan().Contains(filter, StringComparison.InvariantCulture) ||\n                this.Message.AsSpan().Contains(filter, StringComparison.InvariantCulture);\n        }\n\n        /// <summary>\n        /// \u5199\u5165\u6307\u5b9a\u7684TextWriter\n        /// </summary>\n        /// <param name=\"writer\"></param>", "        public void WriteTo(TextWriter writer)\n        {\n            writer.WriteLine($\"{DateTimeOffset.Now:yyyy-MM-ddTHH:mm:ss.fffK} [{this.LogLevel}]\");\n            writer.WriteLine(this.LoggerName);\n            writer.WriteLine(this.Message);\n            writer.WriteLine();\n        }\n    }\n}\n"]}
{"filename": "ServiceSelf/NamedPipeLogger.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.Logging;\nusing System;\n\nnamespace ServiceSelf\n{\n    /// <summary>\n    /// \u547d\u540d\u7ba1\u9053\u65e5\u5fd7\n    /// </summary>\n    sealed class NamedPipeLogger : ILogger\n    {\n        private readonly string categoryName;", "    sealed class NamedPipeLogger : ILogger\n    {\n        private readonly string categoryName;\n        private readonly NamedPipeClient pipeClient;\n\n        public NamedPipeLogger(string categoryName, NamedPipeClient pipeClient)\n        {\n            this.categoryName = categoryName;\n            this.pipeClient = pipeClient;\n        }\n", "        public IDisposable BeginScope<TState>(TState state)\n        {\n            return NullScope.Instance;\n        }\n\n        public bool IsEnabled(LogLevel logLevel)\n        {\n            return logLevel != LogLevel.None && this.pipeClient.CanWrite;\n        }\n\n        public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, string> formatter)\n        {", "        public void Log<TState>(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func<TState, Exception, string> formatter)\n        {\n            if (this.IsEnabled(logLevel))\n            {\n                var logItem = new LogItem\n                {                     \n                    LoggerName = this.categoryName,\n                    Level = (int)logLevel,\n                    Message = formatter(state, exception)\n                };\n                \n                this.pipeClient.Write(logItem);\n            }\n        }\n", "        private class NullScope : IDisposable\n        {\n            public static NullScope Instance { get; } = new();\n\n            public void Dispose()\n            {\n            }\n        } \n    }\n}\n"]}
{"filename": "ServiceSelf/ServiceOptions.cs", "chunked_list": ["\ufeffusing System.Collections.Generic;\n\nnamespace ServiceSelf\n{\n    /// <summary>\n    /// \u670d\u52a1\u9009\u9879\n    /// </summary>\n    public sealed class ServiceOptions\n    {\n        /// <summary>\n        /// \u542f\u52a8\u53c2\u6570\n        /// </summary>\n        public IEnumerable<Argument>? Arguments { get; set; }\n\n        /// <summary>\n        /// \u5de5\u4f5c\u76ee\u5f55\n        /// </summary>\n        public string? WorkingDirectory { get; set; }\n\n        /// <summary>\n        /// \u670d\u52a1\u63cf\u8ff0\n        /// </summary>\n        public string? Description { get; set; }\n\n        /// <summary>\n        /// \u83b7\u53d6\u4ec5\u9002\u7528\u4e8elinux\u7684\u9009\u9879\n        /// </summary>", "        public LinuxServiceOptions Linux { get; } = new LinuxServiceOptions();\n\n        /// <summary>\n        /// \u83b7\u53d6\u4ec5\u9002\u7528\u4e8ewindows\u7684\u9009\u9879\n        /// </summary>\n        public WindowsServiceOptions Windows { get; } = new WindowsServiceOptions();\n    }\n}\n"]}
{"filename": "ServiceSelf/WindowsService.cs", "chunked_list": ["\ufeffusing System;\nusing System.ComponentModel;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Runtime.Versioning;\nusing System.Threading;\nusing static ServiceSelf.AdvApi32;\n", "using static ServiceSelf.AdvApi32;\n\nnamespace ServiceSelf\n{\n    sealed class WindowsService : Service\n    {\n        private const string WorkingDirArgName = \"WD\";\n\n\n        [SupportedOSPlatform(\"windows\")]\n        public WindowsService(string name)\n           : base(name)\n        {\n        }\n\n        /// <summary>\n        /// \u5e94\u7528\u5de5\u4f5c\u76ee\u5f55\n        /// </summary>\n        /// <param name=\"args\">\u542f\u52a8\u53c2\u6570</param>\n        /// <returns></returns>", "        public static bool UseWorkingDirectory(string[] args)\n        {\n            if (Argument.TryGetValue(args, WorkingDirArgName, out var workingDir))\n            {\n                Environment.CurrentDirectory = workingDir;\n                return true;\n            }\n            return false;\n        }\n\n        [SupportedOSPlatform(\"windows\")]", "        public override void CreateStart(string filePath, ServiceOptions options)\n        {\n            using var managerHandle = OpenSCManager(null, null, ServiceManagerAccess.SC_MANAGER_ALL_ACCESS);\n            if (managerHandle.IsInvalid == true)\n            {\n                throw new Win32Exception();\n            }\n\n            filePath = Path.GetFullPath(filePath);\n            using var oldServiceHandle = OpenService(managerHandle, this.Name, ServiceAccess.SERVICE_ALL_ACCESS);\n", "            if (oldServiceHandle.IsInvalid)\n            {\n                using var newServiceHandle = this.CreateService(managerHandle, filePath, options);\n                StartService(newServiceHandle);\n            }\n            else\n            {\n                var oldFilePath = QueryServiceFilePath(oldServiceHandle);\n                if (oldFilePath.Length > 0 && oldFilePath.Equals(filePath, StringComparison.OrdinalIgnoreCase) == false)\n                {\n                    throw new InvalidOperationException(\"\u7cfb\u7edf\u5df2\u5b58\u5728\u540c\u540d\u4f46\u4e0d\u540c\u8def\u5f84\u7684\u670d\u52a1\");\n                }\n                StartService(oldServiceHandle);\n            }\n        }\n", "                if (oldFilePath.Length > 0 && oldFilePath.Equals(filePath, StringComparison.OrdinalIgnoreCase) == false)\n                {\n                    throw new InvalidOperationException(\"\u7cfb\u7edf\u5df2\u5b58\u5728\u540c\u540d\u4f46\u4e0d\u540c\u8def\u5f84\u7684\u670d\u52a1\");\n                }\n                StartService(oldServiceHandle);\n            }\n        }\n\n        private unsafe SafeServiceHandle CreateService(SafeServiceHandle managerHandle, string filePath, ServiceOptions options)\n        {\n            var arguments = options.Arguments ?? Enumerable.Empty<Argument>();\n            arguments = string.IsNullOrEmpty(options.WorkingDirectory)\n                ? arguments.Append(new Argument(WorkingDirArgName, Path.GetDirectoryName(filePath)))\n                : arguments.Append(new Argument(WorkingDirArgName, Path.GetFullPath(options.WorkingDirectory)));\n\n            var serviceHandle = AdvApi32.CreateService(\n                managerHandle,\n                this.Name,\n                options.Windows.DisplayName,\n                ServiceAccess.SERVICE_ALL_ACCESS,\n                ServiceType.SERVICE_WIN32_OWN_PROCESS,\n                ServiceStartType.SERVICE_AUTO_START,\n                ServiceErrorControl.SERVICE_ERROR_NORMAL,\n                $@\"\"\"{filePath}\"\" {string.Join(' ', arguments)}\",\n                lpLoadOrderGroup: null,\n                lpdwTagId: 0,\n                lpDependencies: options.Windows.Dependencies,\n                lpServiceStartName: options.Windows.ServiceStartName,\n                lpPassword: options.Windows.Password);\n", "        private unsafe SafeServiceHandle CreateService(SafeServiceHandle managerHandle, string filePath, ServiceOptions options)\n        {\n            var arguments = options.Arguments ?? Enumerable.Empty<Argument>();\n            arguments = string.IsNullOrEmpty(options.WorkingDirectory)\n                ? arguments.Append(new Argument(WorkingDirArgName, Path.GetDirectoryName(filePath)))\n                : arguments.Append(new Argument(WorkingDirArgName, Path.GetFullPath(options.WorkingDirectory)));\n\n            var serviceHandle = AdvApi32.CreateService(\n                managerHandle,\n                this.Name,\n                options.Windows.DisplayName,\n                ServiceAccess.SERVICE_ALL_ACCESS,\n                ServiceType.SERVICE_WIN32_OWN_PROCESS,\n                ServiceStartType.SERVICE_AUTO_START,\n                ServiceErrorControl.SERVICE_ERROR_NORMAL,\n                $@\"\"\"{filePath}\"\" {string.Join(' ', arguments)}\",\n                lpLoadOrderGroup: null,\n                lpdwTagId: 0,\n                lpDependencies: options.Windows.Dependencies,\n                lpServiceStartName: options.Windows.ServiceStartName,\n                lpPassword: options.Windows.Password);\n", "            if (serviceHandle.IsInvalid == true)\n            {\n                throw new Win32Exception();\n            }\n\n            if (string.IsNullOrEmpty(options.Description) == false)\n            {\n                var desc = new ServiceDescription { lpDescription = options.Description };\n                var pDesc = Marshal.AllocHGlobal(Marshal.SizeOf(desc));\n                Marshal.StructureToPtr(desc, pDesc, false);\n                ChangeServiceConfig2(serviceHandle, ServiceInfoLevel.SERVICE_CONFIG_DESCRIPTION, pDesc.ToPointer());\n                Marshal.FreeHGlobal(pDesc);\n            }\n\n\n            var action = new SC_ACTION\n            {\n                Type = (SC_ACTION_TYPE)options.Windows.FailureActionType,\n            };\n            var failureAction = new SERVICE_FAILURE_ACTIONS\n            {\n                cActions = 1,\n                lpsaActions = &action,\n                dwResetPeriod = (int)TimeSpan.FromDays(1d).TotalSeconds\n            };\n", "            if (ChangeServiceConfig2(serviceHandle, ServiceInfoLevel.SERVICE_CONFIG_FAILURE_ACTIONS, &failureAction) == false)\n            {\n                throw new Win32Exception();\n            }\n\n            return serviceHandle;\n        }\n\n        private static ReadOnlySpan<char> QueryServiceFilePath(SafeServiceHandle serviceHandle)\n        {\n            const int ERROR_INSUFFICIENT_BUFFER = 122;", "        private static ReadOnlySpan<char> QueryServiceFilePath(SafeServiceHandle serviceHandle)\n        {\n            const int ERROR_INSUFFICIENT_BUFFER = 122;\n            if (QueryServiceConfig(serviceHandle, IntPtr.Zero, 0, out var bytesNeeded) == false)\n            {\n                if (Marshal.GetLastWin32Error() != ERROR_INSUFFICIENT_BUFFER)\n                {\n                    throw new Win32Exception();\n                }\n            }\n\n            var buffer = Marshal.AllocHGlobal(bytesNeeded);\n            try\n            {", "                if (QueryServiceConfig(serviceHandle, buffer, bytesNeeded, out _) == false)\n                {\n                    throw new Win32Exception();\n                }\n\n                var serviceConfig = Marshal.PtrToStructure<QUERY_SERVICE_CONFIG>(buffer);\n                var binaryPathName = serviceConfig.lpBinaryPathName.AsSpan();\n                if (binaryPathName.IsEmpty)\n                {\n                    return ReadOnlySpan<char>.Empty;\n                }\n", "                if (binaryPathName[0] == '\"')\n                {\n                    binaryPathName = binaryPathName[1..];\n                    var index = binaryPathName.IndexOf('\"');\n                    return index < 0 ? binaryPathName : binaryPathName[..index];\n                }\n                else\n                {\n                    var index = binaryPathName.IndexOf(' ');\n                    return index < 0 ? binaryPathName : binaryPathName[..index];\n                }\n            }\n            finally\n            {\n                Marshal.FreeHGlobal(buffer);\n            }\n        }\n", "        private static void StartService(SafeServiceHandle serviceHandle)\n        {\n            var status = new SERVICE_STATUS();\n            if (QueryServiceStatus(serviceHandle, ref status) == false)\n            {\n                throw new Win32Exception();\n            }\n\n            if (status.dwCurrentState == ServiceState.SERVICE_RUNNING ||\n                status.dwCurrentState == ServiceState.SERVICE_START_PENDING)\n            {\n                return;\n            }\n", "            if (status.dwCurrentState == ServiceState.SERVICE_RUNNING ||\n                status.dwCurrentState == ServiceState.SERVICE_START_PENDING)\n            {\n                return;\n            }\n\n            if (AdvApi32.StartService(serviceHandle, 0, null) == false)\n            {\n                throw new Win32Exception();\n            }\n        }\n\n        /// <summary>\n        /// \u505c\u6b62\u5e76\u5220\u9664\u670d\u52a1\n        /// </summary>  \n        [SupportedOSPlatform(\"windows\")]", "        public override void StopDelete()\n        {\n            using var managerHandle = OpenSCManager(null, null, ServiceManagerAccess.SC_MANAGER_ALL_ACCESS);\n            if (managerHandle.IsInvalid == true)\n            {\n                throw new Win32Exception();\n            }\n\n            using var serviceHandle = OpenService(managerHandle, this.Name, ServiceAccess.SERVICE_ALL_ACCESS);\n            if (serviceHandle.IsInvalid == true)\n            {\n                return;\n            }\n\n            StopService(serviceHandle, TimeSpan.FromSeconds(30d));", "            if (serviceHandle.IsInvalid == true)\n            {\n                return;\n            }\n\n            StopService(serviceHandle, TimeSpan.FromSeconds(30d));\n            if (DeleteService(serviceHandle) == false)\n            {\n                throw new Win32Exception();\n            }\n        }\n", "        private static unsafe void StopService(SafeServiceHandle serviceHandle, TimeSpan maxWaitTime)\n        {\n            var status = new SERVICE_STATUS();\n            if (QueryServiceStatus(serviceHandle, ref status) == false)\n            {\n                throw new Win32Exception();\n            }\n\n            if (status.dwCurrentState == ServiceState.SERVICE_STOPPED)\n            {\n                return;\n            }\n", "            if (status.dwCurrentState == ServiceState.SERVICE_STOPPED)\n            {\n                return;\n            }\n\n            if (status.dwCurrentState != ServiceState.SERVICE_STOP_PENDING)\n            {\n                var failureAction = new SERVICE_FAILURE_ACTIONS();\n                if (ChangeServiceConfig2(serviceHandle, ServiceInfoLevel.SERVICE_CONFIG_FAILURE_ACTIONS, &failureAction) == false)\n                {\n                    throw new Win32Exception();\n                }\n", "                if (ChangeServiceConfig2(serviceHandle, ServiceInfoLevel.SERVICE_CONFIG_FAILURE_ACTIONS, &failureAction) == false)\n                {\n                    throw new Win32Exception();\n                }\n\n                if (ControlService(serviceHandle, ServiceControl.SERVICE_CONTROL_STOP, ref status) == false)\n                {\n                    throw new Win32Exception();\n                }\n\n                // \u8fd9\u91cc\u4e0d\u9700\u8981\u6062\u590dSERVICE_CONFIG_FAILURE_ACTIONS\uff0c\u56e0\u4e3a\u4e0b\u9762\u6211\u4eec\u8981\u5220\u9664\u670d\u52a1\n            }\n\n            var stopwatch = Stopwatch.StartNew();\n            var statusQueryDelay = TimeSpan.FromMilliseconds(100d);", "            while (stopwatch.Elapsed < maxWaitTime)\n            {\n                if (status.dwCurrentState == ServiceState.SERVICE_STOPPED)\n                {\n                    return;\n                }\n\n                Thread.Sleep(statusQueryDelay);\n                if (QueryServiceStatus(serviceHandle, ref status) == false)\n                {\n                    throw new Win32Exception();\n                }\n            }\n\n            throw new TimeoutException($\"\u7b49\u5f85\u670d\u52a1\u505c\u6b62\u8d85\u8fc7\u4e86{maxWaitTime.TotalSeconds}\u79d2\");\n        }\n\n        /// <summary>\n        /// \u5c1d\u8bd5\u83b7\u53d6\u670d\u52a1\u7684\u8fdb\u7a0bid\n        /// </summary>\n        /// <param name=\"processId\"></param>\n        /// <returns></returns>", "                if (QueryServiceStatus(serviceHandle, ref status) == false)\n                {\n                    throw new Win32Exception();\n                }\n            }\n\n            throw new TimeoutException($\"\u7b49\u5f85\u670d\u52a1\u505c\u6b62\u8d85\u8fc7\u4e86{maxWaitTime.TotalSeconds}\u79d2\");\n        }\n\n        /// <summary>\n        /// \u5c1d\u8bd5\u83b7\u53d6\u670d\u52a1\u7684\u8fdb\u7a0bid\n        /// </summary>\n        /// <param name=\"processId\"></param>\n        /// <returns></returns>", "        protected unsafe override bool TryGetProcessId(out int processId)\n        {\n            processId = 0;\n            using var managerHandle = OpenSCManager(null, null, ServiceManagerAccess.SC_MANAGER_ALL_ACCESS);\n            if (managerHandle.IsInvalid == true)\n            {\n                throw new Win32Exception();\n            }\n\n            using var serviceHandle = OpenService(managerHandle, this.Name, ServiceAccess.SERVICE_ALL_ACCESS);\n            if (serviceHandle.IsInvalid == true)\n            {\n                return false;\n            }\n\n            var status = new SERVICE_STATUS_PROCESS();", "            if (serviceHandle.IsInvalid == true)\n            {\n                return false;\n            }\n\n            var status = new SERVICE_STATUS_PROCESS();\n            if (QueryServiceStatusEx(serviceHandle, SC_STATUS_TYPE.SC_STATUS_PROCESS_INFO, &status, sizeof(SERVICE_STATUS_PROCESS), out _) == false)\n            {\n                return false;\n            }\n\n            processId = (int)status.dwProcessId;\n            return processId > 0;\n        }\n    }\n}\n"]}
{"filename": "ServiceSelf/NamedPipeLoggerProvider.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.Logging;\nusing System;\n\nnamespace ServiceSelf\n{\n    /// <summary>\n    /// \u547d\u540d\u7ba1\u9053\u65e5\u5fd7\u63d0\u4f9b\u8005\n    /// </summary>\n    sealed class NamedPipeLoggerProvider : ILoggerProvider\n    {\n        private static readonly NamedPipeClient pipeClient = CreateNamedPipeClient();\n\n        /// <summary>\n        /// \u521b\u5efa\u4e0e\u5f53\u524dprocessId\u5bf9\u5e94\u7684NamedPipeClient\n        /// </summary>\n        /// <returns></returns>", "    sealed class NamedPipeLoggerProvider : ILoggerProvider\n    {\n        private static readonly NamedPipeClient pipeClient = CreateNamedPipeClient();\n\n        /// <summary>\n        /// \u521b\u5efa\u4e0e\u5f53\u524dprocessId\u5bf9\u5e94\u7684NamedPipeClient\n        /// </summary>\n        /// <returns></returns>\n        private static NamedPipeClient CreateNamedPipeClient()\n        {\n#if NET6_0_OR_GREATER\n            var processId = Environment.ProcessId;\n#else\n            var processId = System.Diagnostics.Process.GetCurrentProcess().Id;\n#endif\n            var pipeName = $\"{nameof(ServiceSelf)}_{processId}\";\n            return new NamedPipeClient(pipeName);\n        }\n\n        /// <summary>\n        /// \u521b\u5efa\u65e5\u5fd7\n        /// </summary>\n        /// <param name=\"categoryName\"></param>\n        /// <returns></returns>", "        private static NamedPipeClient CreateNamedPipeClient()\n        {\n#if NET6_0_OR_GREATER\n            var processId = Environment.ProcessId;\n#else\n            var processId = System.Diagnostics.Process.GetCurrentProcess().Id;\n#endif\n            var pipeName = $\"{nameof(ServiceSelf)}_{processId}\";\n            return new NamedPipeClient(pipeName);\n        }\n\n        /// <summary>\n        /// \u521b\u5efa\u65e5\u5fd7\n        /// </summary>\n        /// <param name=\"categoryName\"></param>\n        /// <returns></returns>", "        public ILogger CreateLogger(string categoryName)\n        {\n            return new NamedPipeLogger(categoryName, pipeClient);\n        }\n\n        public void Dispose()\n        {\n        }\n    }\n}\n"]}
{"filename": "App/AppHostedService.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace App\n{\n    sealed class AppHostedService : BackgroundService\n    {\n        private readonly ILogger<AppHostedService> logger;\n\n        public AppHostedService(ILogger<AppHostedService> logger)\n        {\n            this.logger = logger;\n        }\n", "    sealed class AppHostedService : BackgroundService\n    {\n        private readonly ILogger<AppHostedService> logger;\n\n        public AppHostedService(ILogger<AppHostedService> logger)\n        {\n            this.logger = logger;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {", "        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (stoppingToken.IsCancellationRequested == false)\n            {\n                await Task.Delay(TimeSpan.FromSeconds(1d), stoppingToken);\n                this.logger.LogInformation(DateTimeOffset.Now.ToString());\n            }\n        }\n    }\n}\n"]}
{"filename": "App/Program.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing ServiceSelf;\n\nnamespace App\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var serviceName = \"app\";\n            var serviceOptions = new ServiceOptions\n            {\n                Arguments = new[] { new Argument(\"key\", \"value\") },\n                Description = \"\u8fd9\u662f\u6f14\u793a\u793a\u4f8b\u5e94\u7528\",\n            };\n            serviceOptions.Linux.Service.Restart = \"always\";\n            serviceOptions.Linux.Service.RestartSec = \"10\";\n            serviceOptions.Windows.DisplayName = \"\u6f14\u793a\u793a\u4f8b\";\n            serviceOptions.Windows.FailureActionType = WindowsServiceActionType.Restart;\n", "            if (Service.UseServiceSelf(args, serviceName, serviceOptions))\n            {\n                var host = Host.CreateDefaultBuilder(args)\n                    // \u4e3aHost\u914d\u7f6eUseServiceSelf()\n                    .UseServiceSelf()\n                    .ConfigureServices(service =>\n                    {\n                        service.AddHostedService<AppHostedService>();\n                    })\n                    .Build();\n\n                host.Run();\n            }\n        }\n    }\n}"]}
