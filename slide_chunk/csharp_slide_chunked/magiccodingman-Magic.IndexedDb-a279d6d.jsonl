{"filename": "Magic.IndexedDb/MagicEncryptAttribute.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb\n{\n    [AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]\n    public class MagicEncryptAttribute : Attribute\n    {\n        public MagicEncryptAttribute()\n        {\n        }\n", "{\n    [AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]\n    public class MagicEncryptAttribute : Attribute\n    {\n        public MagicEncryptAttribute()\n        {\n        }\n\n        public void Validate(PropertyInfo property)\n        {\n            if (property.PropertyType != typeof(string))\n            {\n                throw new ArgumentException(\"EncryptDbAttribute can only be used on string properties\");\n            }\n        }\n    }\n}\n", "        public void Validate(PropertyInfo property)\n        {\n            if (property.PropertyType != typeof(string))\n            {\n                throw new ArgumentException(\"EncryptDbAttribute can only be used on string properties\");\n            }\n        }\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/IndexedDbFunctions.cs", "chunked_list": ["namespace Magic.IndexedDb\n{ \n    internal struct IndexedDbFunctions\n    {\n        public const string CREATE_DB = \"createDb\";\n        public const string DELETE_DB = \"deleteDb\";\n        public const string ADD_ITEM = \"addItem\";\n        public const string BULKADD_ITEM = \"bulkAddItem\";\n        public const string PUT_ITEM = \"putItem\";\n        public const string UPDATE_ITEM = \"updateItem\";\n        public const string BULKADD_UPDATE = \"bulkUpdateItem\";", "        public const string PUT_ITEM = \"putItem\";\n        public const string UPDATE_ITEM = \"updateItem\";\n        public const string BULKADD_UPDATE = \"bulkUpdateItem\";\n        public const string DELETE_ITEM = \"deleteItem\";\n        public const string CLEAR_TABLE = \"clear\";\n        public const string FIND_ITEM = \"findItem\";\n        public const string FIND_ITEMV2 = \"findItemv2\";\n        public const string TOARRAY = \"toArray\";\n        public const string WHERE = \"where\";\n        public const string WHEREV2 = \"wherev2\";\n        public const string BULK_DELETE = \"bulkDelete\";", "        public const string WHERE = \"where\";\n        public const string WHEREV2 = \"wherev2\";\n        public const string BULK_DELETE = \"bulkDelete\";\n        public const string GET_STORAGE_ESTIMATE = \"getStorageEstimate\";\n        public const string COUNT_TABLE = \"countTable\";\n\n\n    }\n}"]}
{"filename": "Magic.IndexedDb/IndexDbManager.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Dynamic;\nusing System.Linq.Expressions;\nusing System.Reflection;\nusing System.Security.Cryptography.X509Certificates;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Magic.IndexedDb.Helpers;", "using System.Threading.Tasks;\nusing Magic.IndexedDb.Helpers;\nusing Magic.IndexedDb.Models;\nusing Magic.IndexedDb.SchemaAnnotations;\nusing Microsoft.JSInterop;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\nusing Newtonsoft.Json.Serialization;\nusing static System.Collections.Specialized.BitVector32;\nusing static System.Runtime.InteropServices.JavaScript.JSType;", "using static System.Collections.Specialized.BitVector32;\nusing static System.Runtime.InteropServices.JavaScript.JSType;\n\nnamespace Magic.IndexedDb\n{\n    /// <summary>\n    /// Provides functionality for accessing IndexedDB from Blazor application\n    /// </summary>\n    public class IndexedDbManager\n    {\n        readonly DbStore _dbStore;\n        readonly IJSRuntime _jsRuntime;\n        const string InteropPrefix = \"window.magicBlazorDB\";\n        DotNetObjectReference<IndexedDbManager> _objReference;\n        IDictionary<Guid, WeakReference<Action<BlazorDbEvent>>> _transactions = new Dictionary<Guid, WeakReference<Action<BlazorDbEvent>>>();\n        IDictionary<Guid, TaskCompletionSource<BlazorDbEvent>> _taskTransactions = new Dictionary<Guid, TaskCompletionSource<BlazorDbEvent>>();\n\n        private IJSObjectReference? _module { get; set; }\n        /// <summary>\n        /// A notification event that is raised when an action is completed\n        /// </summary>", "    public class IndexedDbManager\n    {\n        readonly DbStore _dbStore;\n        readonly IJSRuntime _jsRuntime;\n        const string InteropPrefix = \"window.magicBlazorDB\";\n        DotNetObjectReference<IndexedDbManager> _objReference;\n        IDictionary<Guid, WeakReference<Action<BlazorDbEvent>>> _transactions = new Dictionary<Guid, WeakReference<Action<BlazorDbEvent>>>();\n        IDictionary<Guid, TaskCompletionSource<BlazorDbEvent>> _taskTransactions = new Dictionary<Guid, TaskCompletionSource<BlazorDbEvent>>();\n\n        private IJSObjectReference? _module { get; set; }\n        /// <summary>\n        /// A notification event that is raised when an action is completed\n        /// </summary>", "        public event EventHandler<BlazorDbEvent> ActionCompleted;\n\n        /// <summary>\n        /// Ctor\n        /// </summary>\n        /// <param name=\"dbStore\"></param>\n        /// <param name=\"jsRuntime\"></param>\n#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.\n        internal IndexedDbManager(DbStore dbStore, IJSRuntime jsRuntime)\n#pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.\n        {\n            _objReference = DotNetObjectReference.Create(this);\n            _dbStore = dbStore;\n            _jsRuntime = jsRuntime;\n        }\n", "        public async Task<IJSObjectReference> GetModule(IJSRuntime jsRuntime)\n        {\n            if (_module == null)\n            {\n                _module = await jsRuntime.InvokeAsync<IJSObjectReference>(\"import\", \"./_content/Magic.IndexedDb/magicDB.js\");\n            }\n            return _module;\n        }\n\n        public List<StoreSchema> Stores => _dbStore.StoreSchemas;\n        public string CurrentVersion => _dbStore.Version;", "        public string CurrentVersion => _dbStore.Version;\n        public string DbName => _dbStore.Name;\n\n        /// <summary>\n        /// Opens the IndexedDB defined in the DbStore. Under the covers will create the database if it does not exist\n        /// and create the stores defined in DbStore.\n        /// </summary>\n        /// <returns></returns>\n        public async Task<Guid> OpenDb(Action<BlazorDbEvent>? action = null)\n        {\n            var trans = GenerateTransaction(action);\n            await CallJavascriptVoid(IndexedDbFunctions.CREATE_DB, trans, _dbStore);\n            return trans;\n        }\n\n        /// <summary>\n        /// Deletes the database corresponding to the dbName passed in\n        /// </summary>\n        /// <param name=\"dbName\">The name of database to delete</param>\n        /// <returns></returns>", "        public async Task<Guid> OpenDb(Action<BlazorDbEvent>? action = null)\n        {\n            var trans = GenerateTransaction(action);\n            await CallJavascriptVoid(IndexedDbFunctions.CREATE_DB, trans, _dbStore);\n            return trans;\n        }\n\n        /// <summary>\n        /// Deletes the database corresponding to the dbName passed in\n        /// </summary>\n        /// <param name=\"dbName\">The name of database to delete</param>\n        /// <returns></returns>", "        public async Task<Guid> DeleteDb(string dbName, Action<BlazorDbEvent>? action = null)\n        {\n            if (string.IsNullOrEmpty(dbName))\n            {\n                throw new ArgumentException(\"dbName cannot be null or empty\", nameof(dbName));\n            }\n            var trans = GenerateTransaction(action);\n            await CallJavascriptVoid(IndexedDbFunctions.DELETE_DB, trans, dbName);\n            return trans;\n        }\n\n\n        /// <summary>\n        /// Deletes the database corresponding to the dbName passed in\n        /// Waits for response\n        /// </summary>\n        /// <param name=\"dbName\">The name of database to delete</param>\n        /// <returns></returns>", "        public async Task<BlazorDbEvent> DeleteDbAsync(string dbName)\n        {\n            if (string.IsNullOrEmpty(dbName))\n            {\n                throw new ArgumentException(\"dbName cannot be null or empty\", nameof(dbName));\n            }\n            var trans = GenerateTransaction();\n            await CallJavascriptVoid(IndexedDbFunctions.DELETE_DB, trans.trans, dbName);\n            return await trans.task;\n        }\n\n        /// <summary>\n        /// Adds a new record/object to the specified store\n        /// </summary>\n        /// <typeparam name=\"T\"></typeparam>\n        /// <param name=\"recordToAdd\">An instance of StoreRecord that provides the store name and the data to add</param>\n        /// <returns></returns>", "        private async Task<Guid> AddRecord<T>(StoreRecord<T> recordToAdd, Action<BlazorDbEvent>? action = null)\n        {\n            var trans = GenerateTransaction(action);\n            try\n            {\n                recordToAdd.DbName = DbName;\n                await CallJavascriptVoid(IndexedDbFunctions.ADD_ITEM, trans, recordToAdd);\n            }\n            catch (JSException e)\n            {\n                RaiseEvent(trans, true, e.Message);\n            }\n            return trans;\n        }\n", "            catch (JSException e)\n            {\n                RaiseEvent(trans, true, e.Message);\n            }\n            return trans;\n        }\n\n        public async Task<Guid> Add<T>(T record, Action<BlazorDbEvent>? action = null) where T : class\n        {\n            string schemaName = SchemaHelper.GetSchemaName<T>();\n\n            T? myClass = null;\n            object? processedRecord = await ProcessRecord(record);", "            if (processedRecord is ExpandoObject)\n                myClass = JsonConvert.DeserializeObject<T>(JsonConvert.SerializeObject(processedRecord));\n            else\n                myClass = (T?)processedRecord;\n\n            var trans = GenerateTransaction(action);\n            try\n            {\n                Dictionary<string, object?>? convertedRecord = null;\n                if (processedRecord is ExpandoObject)\n                {\n                    var result = ((ExpandoObject)processedRecord)?.ToDictionary(kv => kv.Key, kv => (object?)kv.Value);", "                if (processedRecord is ExpandoObject)\n                {\n                    var result = ((ExpandoObject)processedRecord)?.ToDictionary(kv => kv.Key, kv => (object?)kv.Value);\n                    if (result != null)\n                    {\n                        convertedRecord = result;\n                    }\n                }\n                else\n                {\n                    convertedRecord = ManagerHelper.ConvertRecordToDictionary(myClass);\n                }\n                var propertyMappings = ManagerHelper.GeneratePropertyMapping<T>();\n\n                // Convert the property names in the convertedRecord dictionary", "                if (convertedRecord != null)\n                {\n                    var updatedRecord = ManagerHelper.ConvertPropertyNamesUsingMappings(convertedRecord, propertyMappings);\n\n                    if (updatedRecord != null)\n                    {\n                        StoreRecord<Dictionary<string, object?>> RecordToSend = new StoreRecord<Dictionary<string, object?>>()\n                        {\n                            DbName = this.DbName,\n                            StoreName = schemaName,\n                            Record = updatedRecord\n                        };\n\n                        await CallJavascriptVoid(IndexedDbFunctions.ADD_ITEM, trans, RecordToSend);\n                    }\n                }\n            }", "            catch (JSException e)\n            {\n                RaiseEvent(trans, true, e.Message);\n            }\n            return trans;\n        }\n\n        public async Task<string> Decrypt(string EncryptedValue)\n        {\n            EncryptionFactory encryptionFactory = new EncryptionFactory(_jsRuntime, this);\n            string decryptedValue = await encryptionFactory.Decrypt(EncryptedValue, _dbStore.EncryptionKey);\n            return decryptedValue;\n        }\n", "        private async Task<object?> ProcessRecord<T>(T record) where T : class\n        {\n            string schemaName = SchemaHelper.GetSchemaName<T>();\n            StoreSchema? storeSchema = Stores.FirstOrDefault(s => s.Name == schemaName);\n\n            if (storeSchema == null)\n            {\n                throw new InvalidOperationException($\"StoreSchema not found for '{schemaName}'\");\n            }\n\n            // Encrypt properties with EncryptDb attribute\n            var propertiesToEncrypt = typeof(T).GetProperties()\n                .Where(p => p.GetCustomAttributes(typeof(MagicEncryptAttribute), false).Length > 0);\n\n            EncryptionFactory encryptionFactory = new EncryptionFactory(_jsRuntime, this);", "            foreach (var property in propertiesToEncrypt)\n            {\n                if (property.PropertyType != typeof(string))\n                {\n                    throw new InvalidOperationException(\"EncryptDb attribute can only be used on string properties.\");\n                }\n\n                string? originalValue = property.GetValue(record) as string;\n                if (!string.IsNullOrWhiteSpace(originalValue))\n                {\n                    string encryptedValue = await encryptionFactory.Encrypt(originalValue, _dbStore.EncryptionKey);\n                    property.SetValue(record, encryptedValue);\n                }\n                else\n                {\n                    property.SetValue(record, originalValue);\n                }\n            }\n\n            // Proceed with adding the record", "                if (!string.IsNullOrWhiteSpace(originalValue))\n                {\n                    string encryptedValue = await encryptionFactory.Encrypt(originalValue, _dbStore.EncryptionKey);\n                    property.SetValue(record, encryptedValue);\n                }\n                else\n                {\n                    property.SetValue(record, originalValue);\n                }\n            }\n\n            // Proceed with adding the record", "            if (storeSchema.PrimaryKeyAuto)\n            {\n                var primaryKeyProperty = typeof(T)\n                    .GetProperties()\n                    .FirstOrDefault(p => p.GetCustomAttributes(typeof(MagicPrimaryKeyAttribute), false).Length > 0);\n\n                if (primaryKeyProperty != null)\n                {\n                    Dictionary<string, object?> recordAsDict;\n\n                    var primaryKeyValue = primaryKeyProperty.GetValue(record);", "                    if (primaryKeyValue == null || primaryKeyValue.Equals(GetDefaultValue(primaryKeyValue.GetType())))\n                    {\n                        recordAsDict = typeof(T).GetProperties()\n                        .Where(p => p.Name != primaryKeyProperty.Name && p.GetCustomAttributes(typeof(MagicNotMappedAttribute), false).Length == 0)\n                        .ToDictionary(p => p.Name, p => p.GetValue(record));\n                    }\n                    else\n                    {\n                        recordAsDict = typeof(T).GetProperties()\n                        .Where(p => p.GetCustomAttributes(typeof(MagicNotMappedAttribute), false).Length == 0)\n                        .ToDictionary(p => p.Name, p => p.GetValue(record));\n                    }\n\n                    // Create a new ExpandoObject and copy the key-value pairs from the dictionary\n                    var expandoRecord = new ExpandoObject() as IDictionary<string, object?>;", "                    foreach (var kvp in recordAsDict)\n                    {\n                        expandoRecord.Add(kvp);\n                    }\n\n                    return expandoRecord as ExpandoObject;\n                }\n            }\n\n            return record;\n        }\n\n        // Returns the default value for the given type", "        private static object? GetDefaultValue(Type type)\n        {\n            return type.IsValueType ? Activator.CreateInstance(type) : null;\n        }\n\n        /// <summary>\n        /// Adds records/objects to the specified store in bulk\n        /// </summary>\n        /// <typeparam name=\"T\"></typeparam>\n        /// <param name=\"recordsToBulkAdd\">The data to add</param>\n        /// <returns></returns>", "        private async Task<Guid> BulkAddRecord<T>(string storeName, IEnumerable<T> recordsToBulkAdd, Action<BlazorDbEvent>? action = null)\n        {\n            var trans = GenerateTransaction(action);\n            try\n            {\n                await CallJavascriptVoid(IndexedDbFunctions.BULKADD_ITEM, trans, DbName, storeName, recordsToBulkAdd);\n            }\n            catch (JSException e)\n            {\n                RaiseEvent(trans, true, e.Message);\n            }\n            return trans;\n        }\n", "        //public async Task<Guid> AddRange<T>(IEnumerable<T> records, Action<BlazorDbEvent> action = null) where T : class\n        //{\n        //    string schemaName = SchemaHelper.GetSchemaName<T>();\n        //    var propertyMappings = ManagerHelper.GeneratePropertyMapping<T>();\n\n        //    List<object> processedRecords = new List<object>();\n        //    foreach (var record in records)\n        //    {\n        //        object processedRecord = await ProcessRecord(record);\n\n        //        if (processedRecord is ExpandoObject)\n        //        {\n        //            var convertedRecord = ((ExpandoObject)processedRecord).ToDictionary(kv => kv.Key, kv => (object)kv.Value);\n        //            processedRecords.Add(ManagerHelper.ConvertPropertyNamesUsingMappings(convertedRecord, propertyMappings));\n        //        }\n        //        else\n        //        {\n        //            var convertedRecord = ManagerHelper.ConvertRecordToDictionary((T)processedRecord);\n        //            processedRecords.Add(ManagerHelper.ConvertPropertyNamesUsingMappings(convertedRecord, propertyMappings));\n        //        }\n        //    }\n\n        //    return await BulkAddRecord(schemaName, processedRecords, action);\n        //}\n\n        /// <summary>\n        /// Adds records/objects to the specified store in bulk\n        /// Waits for response\n        /// </summary>\n        /// <typeparam name=\"T\"></typeparam>\n        /// <param name=\"recordsToBulkAdd\">An instance of StoreRecord that provides the store name and the data to add</param>\n        /// <returns></returns>", "        //        if (processedRecord is ExpandoObject)\n        //        {\n        //            var convertedRecord = ((ExpandoObject)processedRecord).ToDictionary(kv => kv.Key, kv => (object)kv.Value);\n        //            processedRecords.Add(ManagerHelper.ConvertPropertyNamesUsingMappings(convertedRecord, propertyMappings));\n        //        }\n        //        else\n        //        {\n        //            var convertedRecord = ManagerHelper.ConvertRecordToDictionary((T)processedRecord);\n        //            processedRecords.Add(ManagerHelper.ConvertPropertyNamesUsingMappings(convertedRecord, propertyMappings));\n        //        }\n        //    }\n\n        //    return await BulkAddRecord(schemaName, processedRecords, action);\n        //}\n\n        /// <summary>\n        /// Adds records/objects to the specified store in bulk\n        /// Waits for response\n        /// </summary>\n        /// <typeparam name=\"T\"></typeparam>\n        /// <param name=\"recordsToBulkAdd\">An instance of StoreRecord that provides the store name and the data to add</param>\n        /// <returns></returns>", "        private async Task<BlazorDbEvent> BulkAddRecordAsync<T>(string storeName, IEnumerable<T> recordsToBulkAdd)\n        {\n            var trans = GenerateTransaction();\n            try\n            {\n                await CallJavascriptVoid(IndexedDbFunctions.BULKADD_ITEM, trans.trans, DbName, storeName, recordsToBulkAdd);\n            }\n            catch (JSException e)\n            {\n                RaiseEvent(trans.trans, true, e.Message);\n            }\n            return await trans.task;\n        }\n", "        public async Task AddRange<T>(IEnumerable<T> records) where T : class\n        {\n            string schemaName = SchemaHelper.GetSchemaName<T>();\n\n            //var trans = GenerateTransaction(null);\n            //var TableCount = await CallJavascript<int>(IndexedDbFunctions.COUNT_TABLE, trans, DbName, schemaName);\n            List<Dictionary<string, object?>> processedRecords = new List<Dictionary<string, object?>>();\n            foreach (var record in records)\n            {\n                bool IsExpando = false;\n                T? myClass = null;\n\n                object? processedRecord = await ProcessRecord(record);", "                if (processedRecord is ExpandoObject)\n                {\n                    myClass = JsonConvert.DeserializeObject<T>(JsonConvert.SerializeObject(processedRecord));\n                    IsExpando = true;\n                }\n                else\n                    myClass = (T?)processedRecord;\n\n\n                Dictionary<string, object?>? convertedRecord = null;\n                if (processedRecord is ExpandoObject)\n                {\n                    var result = ((ExpandoObject)processedRecord)?.ToDictionary(kv => kv.Key, kv => (object?)kv.Value);", "                if (processedRecord is ExpandoObject)\n                {\n                    var result = ((ExpandoObject)processedRecord)?.ToDictionary(kv => kv.Key, kv => (object?)kv.Value);\n                    if (result != null)\n                        convertedRecord = result;\n                }\n                else\n                {\n                    convertedRecord = ManagerHelper.ConvertRecordToDictionary(myClass);\n                }\n                var propertyMappings = ManagerHelper.GeneratePropertyMapping<T>();\n\n                // Convert the property names in the convertedRecord dictionary", "                if (convertedRecord != null)\n                {\n                    var updatedRecord = ManagerHelper.ConvertPropertyNamesUsingMappings(convertedRecord, propertyMappings);\n\n                    if (updatedRecord != null)\n                    {\n                        if (IsExpando)\n                        {\n                            //var test = updatedRecord.Cast<Dictionary<string, object>();\n                            var dictionary = updatedRecord as Dictionary<string, object?>;\n                            processedRecords.Add(dictionary);\n                        }\n                        else\n                        {\n                            processedRecords.Add(updatedRecord);\n                        }\n                    }\n                }\n            }\n\n            await BulkAddRecordAsync(schemaName, processedRecords);\n        }\n\n\n", "        public async Task<Guid> Update<T>(T item, Action<BlazorDbEvent>? action = null) where T : class\n        {\n            var trans = GenerateTransaction(action);\n            try\n            {\n                string schemaName = SchemaHelper.GetSchemaName<T>();\n                PropertyInfo? primaryKeyProperty = typeof(T).GetProperties().FirstOrDefault(prop => Attribute.IsDefined(prop, typeof(MagicPrimaryKeyAttribute)));\n                if (primaryKeyProperty != null)\n                {\n                    object? primaryKeyValue = primaryKeyProperty.GetValue(item);\n                    var convertedRecord = ManagerHelper.ConvertRecordToDictionary(item);", "                    if (primaryKeyValue != null)\n                    {\n                        UpdateRecord<Dictionary<string, object?>> record = new UpdateRecord<Dictionary<string, object?>>()\n                        {\n                            Key = primaryKeyValue,\n                            DbName = this.DbName,\n                            StoreName = schemaName,\n                            Record = convertedRecord\n                        };\n\n                        // Get the primary key value of the item\n                        await CallJavascriptVoid(IndexedDbFunctions.UPDATE_ITEM, trans, record);\n                    }\n                    else\n                    {\n                        throw new ArgumentException(\"Item being updated must have a key.\");\n                    }\n                }\n            }", "            catch (JSException jse)\n            {\n                RaiseEvent(trans, true, jse.Message);\n            }\n            return trans;\n        }\n\n        public async Task<Guid> UpdateRange<T>(IEnumerable<T> items, Action<BlazorDbEvent>? action = null) where T : class\n        {\n            var trans = GenerateTransaction(action);\n            try\n            {\n                string schemaName = SchemaHelper.GetSchemaName<T>();\n                PropertyInfo? primaryKeyProperty = typeof(T).GetProperties().FirstOrDefault(prop => Attribute.IsDefined(prop, typeof(MagicPrimaryKeyAttribute)));\n", "                if (primaryKeyProperty != null)\n                {\n                    List<UpdateRecord<Dictionary<string, object?>>> recordsToUpdate = new List<UpdateRecord<Dictionary<string, object?>>>();\n\n                    foreach (var item in items)\n                    {\n                        object? primaryKeyValue = primaryKeyProperty.GetValue(item);\n                        var convertedRecord = ManagerHelper.ConvertRecordToDictionary(item);\n\n                        if (primaryKeyValue != null)\n                        {\n                            recordsToUpdate.Add(new UpdateRecord<Dictionary<string, object?>>()\n                            {\n                                Key = primaryKeyValue,\n                                DbName = this.DbName,\n                                StoreName = schemaName,\n                                Record = convertedRecord\n                            });\n                        }\n\n                        await CallJavascriptVoid(IndexedDbFunctions.BULKADD_UPDATE, trans, recordsToUpdate);\n                    }\n                }\n                else\n                {\n                    throw new ArgumentException(\"Item being update range item must have a key.\");\n                }\n            }", "                        if (primaryKeyValue != null)\n                        {\n                            recordsToUpdate.Add(new UpdateRecord<Dictionary<string, object?>>()\n                            {\n                                Key = primaryKeyValue,\n                                DbName = this.DbName,\n                                StoreName = schemaName,\n                                Record = convertedRecord\n                            });\n                        }\n\n                        await CallJavascriptVoid(IndexedDbFunctions.BULKADD_UPDATE, trans, recordsToUpdate);\n                    }\n                }\n                else\n                {\n                    throw new ArgumentException(\"Item being update range item must have a key.\");\n                }\n            }", "            catch (JSException jse)\n            {\n                RaiseEvent(trans, true, jse.Message);\n            }\n            return trans;\n        }\n\n        public async Task<TResult?> GetById<TResult>(object key) where TResult : class\n        {\n            string schemaName = SchemaHelper.GetSchemaName<TResult>();\n\n            // Find the primary key property\n            var primaryKeyProperty = typeof(TResult)\n                .GetProperties()\n                .FirstOrDefault(p => p.GetCustomAttributes(typeof(MagicPrimaryKeyAttribute), false).Length > 0);\n", "            if (primaryKeyProperty == null)\n            {\n                throw new InvalidOperationException(\"No primary key property found with PrimaryKeyDbAttribute.\");\n            }\n\n            // Check if the key is of the correct type\n            if (!primaryKeyProperty.PropertyType.IsInstanceOfType(key))\n            {\n                throw new ArgumentException($\"Invalid key type. Expected: {primaryKeyProperty.PropertyType}, received: {key.GetType()}\");\n            }\n\n            var trans = GenerateTransaction(null);\n\n            string columnName = primaryKeyProperty.GetPropertyColumnName<MagicPrimaryKeyAttribute>();\n\n            var data = new { DbName = DbName, StoreName = schemaName, Key = columnName, KeyValue = key };\n\n            try\n            {\n                var propertyMappings = ManagerHelper.GeneratePropertyMapping<TResult>();\n                var RecordToConvert = await CallJavascript<Dictionary<string, object>>(IndexedDbFunctions.FIND_ITEMV2, trans, data.DbName, data.StoreName, data.KeyValue);", "                if (RecordToConvert != null)\n                {\n                    var ConvertedResult = ConvertIndexedDbRecordToCRecord<TResult>(RecordToConvert, propertyMappings);\n                    return ConvertedResult;\n                }\n                else\n                {\n                    return default(TResult);\n                }\n\n            }", "            catch (JSException jse)\n            {\n                RaiseEvent(trans, true, jse.Message);\n            }\n\n            return default(TResult);\n        }\n\n        public MagicQuery<T> Where<T>(Expression<Func<T, bool>> predicate) where T : class\n        {\n            string schemaName = SchemaHelper.GetSchemaName<T>();\n            MagicQuery<T> query = new MagicQuery<T>(schemaName, this);\n\n            // Preprocess the predicate to break down Any and All expressions\n            var preprocessedPredicate = PreprocessPredicate(predicate);\n            var asdf = preprocessedPredicate.ToString();\n            CollectBinaryExpressions(preprocessedPredicate.Body, preprocessedPredicate, query.JsonQueries);\n\n            return query;\n        }\n\n        private Expression<Func<T, bool>> PreprocessPredicate<T>(Expression<Func<T, bool>> predicate)\n        {\n            var visitor = new PredicateVisitor<T>();\n            var newExpression = visitor.Visit(predicate.Body);\n\n            return Expression.Lambda<Func<T, bool>>(newExpression, predicate.Parameters);\n        }\n\n        internal async Task<IList<T>?> WhereV2<T>(string storeName, List<string> jsonQuery, MagicQuery<T> query) where T : class\n        {\n            var trans = GenerateTransaction(null);\n\n            try\n            {\n                string? jsonQueryAdditions = null;", "                if (query != null && query.storedMagicQueries != null && query.storedMagicQueries.Count > 0)\n                {\n                    jsonQueryAdditions = Newtonsoft.Json.JsonConvert.SerializeObject(query.storedMagicQueries.ToArray());\n                }\n                var propertyMappings = ManagerHelper.GeneratePropertyMapping<T>();\n                IList<Dictionary<string, object>>? ListToConvert =\n                    await CallJavascript<IList<Dictionary<string, object>>>\n                    (IndexedDbFunctions.WHEREV2, trans, DbName, storeName, jsonQuery.ToArray(), jsonQueryAdditions!, query?.ResultsUnique!);\n\n                var resultList = ConvertListToRecords<T>(ListToConvert, propertyMappings);\n\n                return resultList;\n            }", "            catch (Exception jse)\n            {\n                RaiseEvent(trans, true, jse.Message);\n            }\n\n            return default;\n        }\n\n        private void CollectBinaryExpressions<T>(Expression expression, Expression<Func<T, bool>> predicate, List<string> jsonQueries) where T : class\n        {\n            var binaryExpr = expression as BinaryExpression;\n", "        private void CollectBinaryExpressions<T>(Expression expression, Expression<Func<T, bool>> predicate, List<string> jsonQueries) where T : class\n        {\n            var binaryExpr = expression as BinaryExpression;\n\n            if (binaryExpr != null && binaryExpr.NodeType == ExpressionType.OrElse)\n            {\n                // Split the OR condition into separate expressions\n                var left = binaryExpr.Left;\n                var right = binaryExpr.Right;\n\n                // Process left and right expressions recursively\n                CollectBinaryExpressions(left, predicate, jsonQueries);\n                CollectBinaryExpressions(right, predicate, jsonQueries);\n            }\n            else\n            {\n                // If the expression is a single condition, create a query for it\n                var test = expression.ToString();\n                var tes2t = predicate.ToString();\n\n                string jsonQuery = GetJsonQueryFromExpression(Expression.Lambda<Func<T, bool>>(expression, predicate.Parameters));\n                jsonQueries.Add(jsonQuery);\n            }\n        }\n", "        private object ConvertValueToType(object value, Type targetType)\n        {\n            if (targetType == typeof(Guid) && value is string stringValue)\n            {\n                return Guid.Parse(stringValue);\n            }\n\n            return Convert.ChangeType(value, targetType);\n        }\n\n\n        private IList<TRecord> ConvertListToRecords<TRecord>(IList<Dictionary<string, object>> listToConvert, Dictionary<string, string> propertyMappings)\n        {\n            var records = new List<TRecord>();\n            var recordType = typeof(TRecord);\n", "            foreach (var item in listToConvert)\n            {\n                var record = Activator.CreateInstance<TRecord>();\n\n                foreach (var kvp in item)\n                {\n                    if (propertyMappings.TryGetValue(kvp.Key, out var propertyName))\n                    {\n                        var property = recordType.GetProperty(propertyName);\n                        var value = ManagerHelper.GetValueFromValueKind(kvp.Value);\n                        if (property != null)\n                        {\n                            property.SetValue(record, ConvertValueToType(value!, property.PropertyType));\n                        }\n                    }\n                }\n\n                records.Add(record);\n            }\n\n            return records;\n        }\n", "                        if (property != null)\n                        {\n                            property.SetValue(record, ConvertValueToType(value!, property.PropertyType));\n                        }\n                    }\n                }\n\n                records.Add(record);\n            }\n\n            return records;\n        }\n", "        private TRecord ConvertIndexedDbRecordToCRecord<TRecord>(Dictionary<string, object> item, Dictionary<string, string> propertyMappings)\n        {\n            var recordType = typeof(TRecord);\n            var record = Activator.CreateInstance<TRecord>();\n\n            foreach (var kvp in item)\n            {\n                if (propertyMappings.TryGetValue(kvp.Key, out var propertyName))\n                {\n                    var property = recordType.GetProperty(propertyName);\n                    var value = ManagerHelper.GetValueFromValueKind(kvp.Value);", "                    if (property != null)\n                    {\n                        property.SetValue(record, ConvertValueToType(value!, property.PropertyType));\n                    }\n                }\n            }\n\n            return record;\n        }\n\n        private string GetJsonQueryFromExpression<T>(Expression<Func<T, bool>> predicate) where T : class\n        {\n            var serializerSettings = new JsonSerializerSettings { ContractResolver = new CamelCasePropertyNamesContractResolver() };\n            var conditions = new List<JObject>();\n            var orConditions = new List<List<JObject>>();\n\n            void TraverseExpression(Expression expression, bool inOrBranch = false)\n            {", "        private string GetJsonQueryFromExpression<T>(Expression<Func<T, bool>> predicate) where T : class\n        {\n            var serializerSettings = new JsonSerializerSettings { ContractResolver = new CamelCasePropertyNamesContractResolver() };\n            var conditions = new List<JObject>();\n            var orConditions = new List<List<JObject>>();\n\n            void TraverseExpression(Expression expression, bool inOrBranch = false)\n            {\n                if (expression is BinaryExpression binaryExpression)\n                {\n                    if (binaryExpression.NodeType == ExpressionType.AndAlso)\n                    {\n                        TraverseExpression(binaryExpression.Left, inOrBranch);\n                        TraverseExpression(binaryExpression.Right, inOrBranch);\n                    }", "                if (expression is BinaryExpression binaryExpression)\n                {\n                    if (binaryExpression.NodeType == ExpressionType.AndAlso)\n                    {\n                        TraverseExpression(binaryExpression.Left, inOrBranch);\n                        TraverseExpression(binaryExpression.Right, inOrBranch);\n                    }\n                    else if (binaryExpression.NodeType == ExpressionType.OrElse)\n                    {\n                        if (inOrBranch)\n                        {\n                            throw new InvalidOperationException(\"Nested OR conditions are not supported.\");\n                        }\n\n                        TraverseExpression(binaryExpression.Left, !inOrBranch);\n                        TraverseExpression(binaryExpression.Right, !inOrBranch);\n                    }\n                    else\n                    {\n                        AddCondition(binaryExpression, inOrBranch);\n                    }\n                }", "                        if (inOrBranch)\n                        {\n                            throw new InvalidOperationException(\"Nested OR conditions are not supported.\");\n                        }\n\n                        TraverseExpression(binaryExpression.Left, !inOrBranch);\n                        TraverseExpression(binaryExpression.Right, !inOrBranch);\n                    }\n                    else\n                    {\n                        AddCondition(binaryExpression, inOrBranch);\n                    }\n                }", "                else if (expression is MethodCallExpression methodCallExpression)\n                {\n                    AddCondition(methodCallExpression, inOrBranch);\n                }\n            }\n\n            void AddCondition(Expression expression, bool inOrBranch)\n            {\n                if (expression is BinaryExpression binaryExpression)\n                {\n                    var leftMember = binaryExpression.Left as MemberExpression;\n                    var rightMember = binaryExpression.Right as MemberExpression;\n                    var leftConstant = binaryExpression.Left as ConstantExpression;\n                    var rightConstant = binaryExpression.Right as ConstantExpression;\n                    var operation = binaryExpression.NodeType.ToString();\n", "                if (expression is BinaryExpression binaryExpression)\n                {\n                    var leftMember = binaryExpression.Left as MemberExpression;\n                    var rightMember = binaryExpression.Right as MemberExpression;\n                    var leftConstant = binaryExpression.Left as ConstantExpression;\n                    var rightConstant = binaryExpression.Right as ConstantExpression;\n                    var operation = binaryExpression.NodeType.ToString();\n\n                    if (leftMember != null && rightConstant != null)\n                    {\n                        AddConditionInternal(leftMember, rightConstant, operation, inOrBranch);\n                    }", "                    if (leftMember != null && rightConstant != null)\n                    {\n                        AddConditionInternal(leftMember, rightConstant, operation, inOrBranch);\n                    }\n                    else if (leftConstant != null && rightMember != null)\n                    {\n                        // Swap the order of the left and right expressions and the operation\n                        if (operation == \"GreaterThan\")\n                        {\n                            operation = \"LessThan\";\n                        }", "                        else if (operation == \"LessThan\")\n                        {\n                            operation = \"GreaterThan\";\n                        }\n                        else if (operation == \"GreaterThanOrEqual\")\n                        {\n                            operation = \"LessThanOrEqual\";\n                        }\n                        else if (operation == \"LessThanOrEqual\")\n                        {\n                            operation = \"GreaterThanOrEqual\";\n                        }\n\n                        AddConditionInternal(rightMember, leftConstant, operation, inOrBranch);\n                    }\n                }", "                        else if (operation == \"LessThanOrEqual\")\n                        {\n                            operation = \"GreaterThanOrEqual\";\n                        }\n\n                        AddConditionInternal(rightMember, leftConstant, operation, inOrBranch);\n                    }\n                }\n                else if (expression is MethodCallExpression methodCallExpression)\n                {\n                    if (methodCallExpression.Method.DeclaringType == typeof(string) &&\n                        (methodCallExpression.Method.Name == \"Equals\" || methodCallExpression.Method.Name == \"Contains\" || methodCallExpression.Method.Name == \"StartsWith\"))\n                    {\n                        var left = methodCallExpression.Object as MemberExpression;\n                        var right = methodCallExpression.Arguments[0] as ConstantExpression;\n                        var operation = methodCallExpression.Method.Name;\n                        var caseSensitive = true;\n", "                else if (expression is MethodCallExpression methodCallExpression)\n                {\n                    if (methodCallExpression.Method.DeclaringType == typeof(string) &&\n                        (methodCallExpression.Method.Name == \"Equals\" || methodCallExpression.Method.Name == \"Contains\" || methodCallExpression.Method.Name == \"StartsWith\"))\n                    {\n                        var left = methodCallExpression.Object as MemberExpression;\n                        var right = methodCallExpression.Arguments[0] as ConstantExpression;\n                        var operation = methodCallExpression.Method.Name;\n                        var caseSensitive = true;\n\n                        if (methodCallExpression.Arguments.Count > 1)\n                        {\n                            var stringComparison = methodCallExpression.Arguments[1] as ConstantExpression;", "                        if (methodCallExpression.Arguments.Count > 1)\n                        {\n                            var stringComparison = methodCallExpression.Arguments[1] as ConstantExpression;\n                            if (stringComparison != null && stringComparison.Value is StringComparison comparisonValue)\n                            {\n                                caseSensitive = comparisonValue == StringComparison.Ordinal || comparisonValue == StringComparison.CurrentCulture;\n                            }\n                        }\n\n                        AddConditionInternal(left, right, operation == \"Equals\" ? \"StringEquals\" : operation, inOrBranch, caseSensitive);\n                    }\n                }\n            }\n\n            void AddConditionInternal(MemberExpression? left, ConstantExpression? right, string operation, bool inOrBranch, bool caseSensitive = false)\n            {", "                if (left != null && right != null)\n                {\n                    var propertyInfo = typeof(T).GetProperty(left.Member.Name);\n                    if (propertyInfo != null)\n                    {\n                        bool index = propertyInfo.GetCustomAttributes(typeof(MagicIndexAttribute), false).Length == 0;\n                        bool unique = propertyInfo.GetCustomAttributes(typeof(MagicUniqueIndexAttribute), false).Length == 0;\n                        bool primary = propertyInfo.GetCustomAttributes(typeof(MagicPrimaryKeyAttribute), false).Length == 0;\n\n                        if (index == true && unique == true && primary == true)\n                        {\n                            throw new InvalidOperationException($\"Property '{propertyInfo.Name}' does not have the IndexDbAttribute.\");\n                        }\n\n                        string? columnName = null;\n", "                        if (index == true && unique == true && primary == true)\n                        {\n                            throw new InvalidOperationException($\"Property '{propertyInfo.Name}' does not have the IndexDbAttribute.\");\n                        }\n\n                        string? columnName = null;\n\n                        if (index == false)\n                            columnName = propertyInfo.GetPropertyColumnName<MagicIndexAttribute>();\n                        else if (unique == false)\n                            columnName = propertyInfo.GetPropertyColumnName<MagicUniqueIndexAttribute>();", "                        else if (unique == false)\n                            columnName = propertyInfo.GetPropertyColumnName<MagicUniqueIndexAttribute>();\n                        else if (primary == false)\n                            columnName = propertyInfo.GetPropertyColumnName<MagicPrimaryKeyAttribute>();\n\n                        bool _isString = false;\n                        JToken? valSend = null;\n                        if (right != null && right.Value != null)\n                        {\n                            valSend = JToken.FromObject(right.Value);\n                            _isString = right.Value is string;\n                        }\n\n                        var jsonCondition = new JObject\n            {\n                { \"property\", columnName },\n                { \"operation\", operation },\n                { \"value\", valSend },\n                { \"isString\", _isString },\n                { \"caseSensitive\", caseSensitive }\n                        };\n", "                        if (inOrBranch)\n                        {\n                            var currentOrConditions = orConditions.LastOrDefault();\n                            if (currentOrConditions == null)\n                            {\n                                currentOrConditions = new List<JObject>();\n                                orConditions.Add(currentOrConditions);\n                            }\n                            currentOrConditions.Add(jsonCondition);\n                        }\n                        else\n                        {\n                            conditions.Add(jsonCondition);\n                        }\n                    }\n                }\n            }\n\n            TraverseExpression(predicate.Body);\n", "            if (conditions.Any())\n            {\n                orConditions.Add(conditions);\n            }\n\n            return JsonConvert.SerializeObject(orConditions, serializerSettings);\n        }\n\n        public class QuotaUsage\n        {\n            public long quota { get; set; }", "        public class QuotaUsage\n        {\n            public long quota { get; set; }\n            public long usage { get; set; }\n        }\n\n        /// <summary>\n        /// Returns Mb\n        /// </summary>\n        /// <returns></returns>\n        public async Task<(double quota, double usage)> GetStorageEstimateAsync()\n        {\n            var storageInfo = await CallJavascriptNoTransaction<QuotaUsage>(IndexedDbFunctions.GET_STORAGE_ESTIMATE);\n\n            double quotaInMB = ConvertBytesToMegabytes(storageInfo.quota);\n            double usageInMB = ConvertBytesToMegabytes(storageInfo.usage);\n            return (quotaInMB, usageInMB);\n        }\n\n", "        public async Task<(double quota, double usage)> GetStorageEstimateAsync()\n        {\n            var storageInfo = await CallJavascriptNoTransaction<QuotaUsage>(IndexedDbFunctions.GET_STORAGE_ESTIMATE);\n\n            double quotaInMB = ConvertBytesToMegabytes(storageInfo.quota);\n            double usageInMB = ConvertBytesToMegabytes(storageInfo.usage);\n            return (quotaInMB, usageInMB);\n        }\n\n\n        private static double ConvertBytesToMegabytes(long bytes)\n        {\n            return (double)bytes / (1024 * 1024);\n        }\n\n", "        private static double ConvertBytesToMegabytes(long bytes)\n        {\n            return (double)bytes / (1024 * 1024);\n        }\n\n\n        public async Task<IEnumerable<T>> GetAll<T>() where T : class\n        {\n            var trans = GenerateTransaction(null);\n\n            try\n            {\n                string schemaName = SchemaHelper.GetSchemaName<T>();\n                var propertyMappings = ManagerHelper.GeneratePropertyMapping<T>();\n                IList<Dictionary<string, object>>? ListToConvert = await CallJavascript<IList<Dictionary<string, object>>>(IndexedDbFunctions.TOARRAY, trans, DbName, schemaName);\n\n                var resultList = ConvertListToRecords<T>(ListToConvert, propertyMappings);\n                return resultList;\n            }", "            catch (JSException jse)\n            {\n                RaiseEvent(trans, true, jse.Message);\n            }\n\n            return Enumerable.Empty<T>();\n        }\n\n        public async Task<Guid> Delete<T>(T item, Action<BlazorDbEvent>? action = null) where T : class\n        {\n            var trans = GenerateTransaction(action);\n            try\n            {\n                string schemaName = SchemaHelper.GetSchemaName<T>();\n                PropertyInfo? primaryKeyProperty = typeof(T).GetProperties().FirstOrDefault(prop => Attribute.IsDefined(prop, typeof(MagicPrimaryKeyAttribute)));", "        public async Task<Guid> Delete<T>(T item, Action<BlazorDbEvent>? action = null) where T : class\n        {\n            var trans = GenerateTransaction(action);\n            try\n            {\n                string schemaName = SchemaHelper.GetSchemaName<T>();\n                PropertyInfo? primaryKeyProperty = typeof(T).GetProperties().FirstOrDefault(prop => Attribute.IsDefined(prop, typeof(MagicPrimaryKeyAttribute)));\n                if (primaryKeyProperty != null)\n                {\n                    object? primaryKeyValue = primaryKeyProperty.GetValue(item);\n                    var convertedRecord = ManagerHelper.ConvertRecordToDictionary(item);", "                    if (primaryKeyValue != null)\n                    {\n                        UpdateRecord<Dictionary<string, object?>> record = new UpdateRecord<Dictionary<string, object?>>()\n                        {\n                            Key = primaryKeyValue,\n                            DbName = this.DbName,\n                            StoreName = schemaName,\n                            Record = convertedRecord\n                        };\n\n                        // Get the primary key value of the item\n                        await CallJavascriptVoid(IndexedDbFunctions.DELETE_ITEM, trans, record);\n                    }\n                    else\n                    {\n                        throw new ArgumentException(\"Item being Deleted must have a key.\");\n                    }\n                }\n            }", "            catch (JSException jse)\n            {\n                RaiseEvent(trans, true, jse.Message);\n            }\n            return trans;\n        }\n\n        public async Task<int> DeleteRange<TResult>(IEnumerable<TResult> items) where TResult : class\n        {\n            List<object> keys = new List<object>();\n", "            foreach (var item in items)\n            {\n                PropertyInfo? primaryKeyProperty = typeof(TResult).GetProperties().FirstOrDefault(prop => Attribute.IsDefined(prop, typeof(MagicPrimaryKeyAttribute)));\n                if (primaryKeyProperty == null)\n                {\n                    throw new InvalidOperationException(\"No primary key property found with PrimaryKeyDbAttribute.\");\n                }\n                object? primaryKeyValue = primaryKeyProperty.GetValue(item);\n\n                if (primaryKeyValue != null)\n                    keys.Add(primaryKeyValue);\n            }\n            string schemaName = SchemaHelper.GetSchemaName<TResult>();\n\n            var trans = GenerateTransaction(null);\n\n            var data = new { DbName = DbName, StoreName = schemaName, Keys = keys };\n\n            try\n            {\n                var deletedCount = await CallJavascript<int>(IndexedDbFunctions.BULK_DELETE, trans, data.DbName, data.StoreName, data.Keys);\n                return deletedCount;\n            }", "                if (primaryKeyValue != null)\n                    keys.Add(primaryKeyValue);\n            }\n            string schemaName = SchemaHelper.GetSchemaName<TResult>();\n\n            var trans = GenerateTransaction(null);\n\n            var data = new { DbName = DbName, StoreName = schemaName, Keys = keys };\n\n            try\n            {\n                var deletedCount = await CallJavascript<int>(IndexedDbFunctions.BULK_DELETE, trans, data.DbName, data.StoreName, data.Keys);\n                return deletedCount;\n            }", "            catch (JSException jse)\n            {\n                RaiseEvent(trans, true, jse.Message);\n            }\n\n            return 0;\n        }\n\n\n        /// <summary>\n        /// Clears all data from a Table but keeps the table\n        /// </summary>\n        /// <param name=\"storeName\"></param>\n        /// <param name=\"action\"></param>\n        /// <returns></returns>", "        public async Task<Guid> ClearTable(string storeName, Action<BlazorDbEvent>? action = null)\n        {\n            var trans = GenerateTransaction(action);\n            try\n            {\n                await CallJavascriptVoid(IndexedDbFunctions.CLEAR_TABLE, trans, DbName, storeName);\n            }\n            catch (JSException jse)\n            {\n                RaiseEvent(trans, true, jse.Message);\n            }\n            return trans;\n        }\n", "        public async Task<Guid> ClearTable<T>(Action<BlazorDbEvent>? action = null) where T : class\n        {\n            var trans = GenerateTransaction(action);\n            try\n            {\n                string schemaName = SchemaHelper.GetSchemaName<T>();\n                await CallJavascriptVoid(IndexedDbFunctions.CLEAR_TABLE, trans, DbName, schemaName);\n            }\n            catch (JSException jse)\n            {\n                RaiseEvent(trans, true, jse.Message);\n            }\n            return trans;\n        }\n\n        /// <summary>\n        /// Clears all data from a Table but keeps the table\n        /// Wait for response\n        /// </summary>\n        /// <param name=\"storeName\"></param>\n        /// <returns></returns>", "            catch (JSException jse)\n            {\n                RaiseEvent(trans, true, jse.Message);\n            }\n            return trans;\n        }\n\n        /// <summary>\n        /// Clears all data from a Table but keeps the table\n        /// Wait for response\n        /// </summary>\n        /// <param name=\"storeName\"></param>\n        /// <returns></returns>", "        public async Task<BlazorDbEvent> ClearTableAsync(string storeName)\n        {\n            var trans = GenerateTransaction();\n            try\n            {\n                await CallJavascriptVoid(IndexedDbFunctions.CLEAR_TABLE, trans.trans, DbName, storeName);\n            }\n            catch (JSException jse)\n            {\n                RaiseEvent(trans.trans, true, jse.Message);\n            }\n            return await trans.task;\n        }\n\n        [JSInvokable(\"BlazorDBCallback\")]", "        public void CalledFromJS(Guid transaction, bool failed, string message)\n        {\n            if (transaction != Guid.Empty)\n            {\n                WeakReference<Action<BlazorDbEvent>>? r = null;\n                _transactions.TryGetValue(transaction, out r);\n                TaskCompletionSource<BlazorDbEvent>? t = null;\n                _taskTransactions.TryGetValue(transaction, out t);\n                if (r != null && r.TryGetTarget(out Action<BlazorDbEvent>? action))\n                {\n                    action?.Invoke(new BlazorDbEvent()\n                    {\n                        Transaction = transaction,\n                        Message = message,\n                        Failed = failed\n                    });\n                    _transactions.Remove(transaction);\n                }", "                if (r != null && r.TryGetTarget(out Action<BlazorDbEvent>? action))\n                {\n                    action?.Invoke(new BlazorDbEvent()\n                    {\n                        Transaction = transaction,\n                        Message = message,\n                        Failed = failed\n                    });\n                    _transactions.Remove(transaction);\n                }\n                else if (t != null)\n                {\n                    t.TrySetResult(new BlazorDbEvent()\n                    {\n                        Transaction = transaction,\n                        Message = message,\n                        Failed = failed\n                    });\n                    _taskTransactions.Remove(transaction);\n                }\n                else\n                    RaiseEvent(transaction, failed, message);\n            }\n        }\n\n        //async Task<TResult> CallJavascriptNoTransaction<TResult>(string functionName, params object[] args)\n        //{\n        //    return await _jsRuntime.InvokeAsync<TResult>($\"{InteropPrefix}.{functionName}\", args);\n        //}\n\n        async Task<TResult> CallJavascriptNoTransaction<TResult>(string functionName, params object[] args)\n        {\n            var mod = await GetModule(_jsRuntime);\n            return await mod.InvokeAsync<TResult>($\"{functionName}\", args);\n        }\n\n", "                else if (t != null)\n                {\n                    t.TrySetResult(new BlazorDbEvent()\n                    {\n                        Transaction = transaction,\n                        Message = message,\n                        Failed = failed\n                    });\n                    _taskTransactions.Remove(transaction);\n                }\n                else\n                    RaiseEvent(transaction, failed, message);\n            }\n        }\n\n        //async Task<TResult> CallJavascriptNoTransaction<TResult>(string functionName, params object[] args)\n        //{\n        //    return await _jsRuntime.InvokeAsync<TResult>($\"{InteropPrefix}.{functionName}\", args);\n        //}\n\n        async Task<TResult> CallJavascriptNoTransaction<TResult>(string functionName, params object[] args)\n        {\n            var mod = await GetModule(_jsRuntime);\n            return await mod.InvokeAsync<TResult>($\"{functionName}\", args);\n        }\n\n", "        private const string dynamicJsCaller = \"DynamicJsCaller\";\n        /// <summary>\n        /// \n        /// </summary>\n        /// <typeparam name=\"TResult\"></typeparam>\n        /// <param name=\"functionName\"></param>\n        /// <param name=\"transaction\"></param>\n        /// <param name=\"timeout\">in ms</param>\n        /// <param name=\"args\"></param>\n        /// <returns></returns>\n        /// <exception cref=\"ArgumentException\"></exception>", "        public async Task<TResult> CallJS<TResult>(string functionName, double Timeout, params object[] args)\n        {\n            List<object> modifiedArgs = new List<object>(args);\n            modifiedArgs.Insert(0, $\"{InteropPrefix}.{functionName}\");\n\n            Task<JsResponse<TResult>> task = _jsRuntime.InvokeAsync<JsResponse<TResult>>(dynamicJsCaller, modifiedArgs.ToArray()).AsTask();\n            Task delay = Task.Delay(TimeSpan.FromMilliseconds(Timeout));\n\n            if (await Task.WhenAny(task, delay) == task)\n            {\n                JsResponse<TResult> response = await task;", "            if (await Task.WhenAny(task, delay) == task)\n            {\n                JsResponse<TResult> response = await task;\n                if (response.Success)\n                    return response.Data;\n                else\n                    throw new ArgumentException(response.Message);\n            }\n            else\n            {\n                throw new ArgumentException(\"Timed out after 1 minute\");\n            }\n        }\n", "        //public async Task<TResult> CallJS<TResult>(string functionName, JsSettings Settings, params object[] args)\n        //{\n        //    var newArgs = GetNewArgs(Settings.Transaction, args);\n\n        //    Task<JsResponse<TResult>> task = _jsRuntime.InvokeAsync<JsResponse<TResult>>($\"{InteropPrefix}.{functionName}\", newArgs).AsTask();\n        //    Task delay = Task.Delay(TimeSpan.FromMilliseconds(Settings.Timeout));\n\n        //    if (await Task.WhenAny(task, delay) == task)\n        //    {\n        //        JsResponse<TResult> response = await task;\n        //        if (response.Success)\n        //            return response.Data;\n        //        else\n        //            throw new ArgumentException(response.Message);\n        //    }\n        //    else\n        //    {\n        //        throw new ArgumentException(\"Timed out after 1 minute\");\n        //    }\n        //}\n\n\n\n        //async Task<TResult> CallJavascript<TResult>(string functionName, Guid transaction, params object[] args)\n        //{\n        //    var newArgs = GetNewArgs(transaction, args);\n        //    return await _jsRuntime.InvokeAsync<TResult>($\"{InteropPrefix}.{functionName}\", newArgs);\n        //}\n        //async Task CallJavascriptVoid(string functionName, Guid transaction, params object[] args)\n        //{\n        //    var newArgs = GetNewArgs(transaction, args);\n        //    await _jsRuntime.InvokeVoidAsync($\"{InteropPrefix}.{functionName}\", newArgs);\n        //}\n\n        async Task<TResult> CallJavascript<TResult>(string functionName, Guid transaction, params object[] args)\n        {\n            var mod = await GetModule(_jsRuntime);\n            var newArgs = GetNewArgs(transaction, args);\n            return await mod.InvokeAsync<TResult>($\"{functionName}\", newArgs);\n        }\n        async Task CallJavascriptVoid(string functionName, Guid transaction, params object[] args)\n        {\n            var mod = await GetModule(_jsRuntime);\n            var newArgs = GetNewArgs(transaction, args);\n            await mod.InvokeVoidAsync($\"{functionName}\", newArgs);\n        }\n\n\n\n        object[] GetNewArgs(Guid transaction, params object[] args)\n        {\n            var newArgs = new object[args.Length + 2];\n            newArgs[0] = _objReference;\n            newArgs[1] = transaction;", "        //        if (response.Success)\n        //            return response.Data;\n        //        else\n        //            throw new ArgumentException(response.Message);\n        //    }\n        //    else\n        //    {\n        //        throw new ArgumentException(\"Timed out after 1 minute\");\n        //    }\n        //}\n\n\n\n        //async Task<TResult> CallJavascript<TResult>(string functionName, Guid transaction, params object[] args)\n        //{\n        //    var newArgs = GetNewArgs(transaction, args);\n        //    return await _jsRuntime.InvokeAsync<TResult>($\"{InteropPrefix}.{functionName}\", newArgs);\n        //}\n        //async Task CallJavascriptVoid(string functionName, Guid transaction, params object[] args)\n        //{\n        //    var newArgs = GetNewArgs(transaction, args);\n        //    await _jsRuntime.InvokeVoidAsync($\"{InteropPrefix}.{functionName}\", newArgs);\n        //}\n\n        async Task<TResult> CallJavascript<TResult>(string functionName, Guid transaction, params object[] args)\n        {\n            var mod = await GetModule(_jsRuntime);\n            var newArgs = GetNewArgs(transaction, args);\n            return await mod.InvokeAsync<TResult>($\"{functionName}\", newArgs);\n        }\n        async Task CallJavascriptVoid(string functionName, Guid transaction, params object[] args)\n        {\n            var mod = await GetModule(_jsRuntime);\n            var newArgs = GetNewArgs(transaction, args);\n            await mod.InvokeVoidAsync($\"{functionName}\", newArgs);\n        }\n\n\n\n        object[] GetNewArgs(Guid transaction, params object[] args)\n        {\n            var newArgs = new object[args.Length + 2];\n            newArgs[0] = _objReference;\n            newArgs[1] = transaction;", "            for (var i = 0; i < args.Length; i++)\n                newArgs[i + 2] = args[i];\n            return newArgs;\n        }\n\n        (Guid trans, Task<BlazorDbEvent> task) GenerateTransaction()\n        {\n            bool generated = false;\n            var transaction = Guid.Empty;\n            TaskCompletionSource<BlazorDbEvent> tcs = new TaskCompletionSource<BlazorDbEvent>();\n            do\n            {\n                transaction = Guid.NewGuid();", "                if (!_taskTransactions.ContainsKey(transaction))\n                {\n                    generated = true;\n                    _taskTransactions.Add(transaction, tcs);\n                }\n            } while (!generated);\n            return (transaction, tcs.Task);\n        }\n\n        Guid GenerateTransaction(Action<BlazorDbEvent>? action)\n        {\n            bool generated = false;\n            Guid transaction = Guid.Empty;\n            do\n            {\n                transaction = Guid.NewGuid();", "                if (!_transactions.ContainsKey(transaction))\n                {\n                    generated = true;\n                    _transactions.Add(transaction, new WeakReference<Action<BlazorDbEvent>>(action!));\n                }\n            } while (!generated);\n            return transaction;\n        }\n\n        void RaiseEvent(Guid transaction, bool failed, string message)\n            => ActionCompleted?.Invoke(this, new BlazorDbEvent { Transaction = transaction, Failed = failed, Message = message });\n\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/SchemaAnnotations/MagicColumnNameDesignatorAttribute.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb.SchemaAnnotations\n{\n    [AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]\n    public class MagicColumnNameDesignatorAttribute : Attribute\n    {", "    [AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]\n    public class MagicColumnNameDesignatorAttribute : Attribute\n    {\n        private static bool isApplied = false;\n\n        public MagicColumnNameDesignatorAttribute()\n        {\n            if (isApplied)\n            {\n                throw new InvalidOperationException(\"The SingleProperty attribute can only be applied to one property.\");\n            }\n            isApplied = true;\n        }\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/SchemaAnnotations/MagicUniqueIndexAttribute.cs", "chunked_list": ["\ufeffusing Magic.IndexedDb.SchemaAnnotations;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb\n{\n    [AttributeUsage(AttributeTargets.Property)]\n    public class MagicUniqueIndexAttribute : Attribute\n    {\n        [MagicColumnNameDesignator]", "{\n    [AttributeUsage(AttributeTargets.Property)]\n    public class MagicUniqueIndexAttribute : Attribute\n    {\n        [MagicColumnNameDesignator]\n        public string ColumnName { get; }\n\n        public MagicUniqueIndexAttribute(string columnName = null)\n        {\n            if (!String.IsNullOrWhiteSpace(columnName))\n            {\n                ColumnName = columnName;\n            }\n            else\n            {\n                ColumnName = null;\n            }\n        }\n    }\n}\n", "            if (!String.IsNullOrWhiteSpace(columnName))\n            {\n                ColumnName = columnName;\n            }\n            else\n            {\n                ColumnName = null;\n            }\n        }\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/SchemaAnnotations/MagicNotMappedAttribute.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb.SchemaAnnotations\n{\n    public class MagicNotMappedAttribute : Attribute { }\n}\n", "    public class MagicNotMappedAttribute : Attribute { }\n}\n"]}
{"filename": "Magic.IndexedDb/SchemaAnnotations/MagicIndexAttribute.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Magic.IndexedDb.SchemaAnnotations;\n\nnamespace Magic.IndexedDb.SchemaAnnotations\n{\n    [AttributeUsage(AttributeTargets.Property)]\n    public class MagicIndexAttribute : Attribute\n    {\n        [MagicColumnNameDesignator]", "{\n    [AttributeUsage(AttributeTargets.Property)]\n    public class MagicIndexAttribute : Attribute\n    {\n        [MagicColumnNameDesignator]\n        public string ColumnName { get; }\n\n        public MagicIndexAttribute(string columnName = null)\n        {\n            if (!String.IsNullOrWhiteSpace(columnName))\n            {\n                ColumnName = columnName;\n            }\n            else\n            {\n                ColumnName = null;\n            }\n        }\n    }\n}\n", "            if (!String.IsNullOrWhiteSpace(columnName))\n            {\n                ColumnName = columnName;\n            }\n            else\n            {\n                ColumnName = null;\n            }\n        }\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/SchemaAnnotations/MagicPrimaryKeyAttribute.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Magic.IndexedDb.SchemaAnnotations;\n\nnamespace Magic.IndexedDb\n{\n    [AttributeUsage(AttributeTargets.Property)]\n    public class MagicPrimaryKeyAttribute : Attribute\n    {\n        [MagicColumnNameDesignator]", "{\n    [AttributeUsage(AttributeTargets.Property)]\n    public class MagicPrimaryKeyAttribute : Attribute\n    {\n        [MagicColumnNameDesignator]\n        public string ColumnName { get; }\n\n        public MagicPrimaryKeyAttribute(string columnName = null)\n        {\n            if (!String.IsNullOrWhiteSpace(columnName))\n            {\n                ColumnName = columnName;\n            }\n            else\n            {\n                ColumnName = null;\n            }\n        }\n    }\n}\n", "            if (!String.IsNullOrWhiteSpace(columnName))\n            {\n                ColumnName = columnName;\n            }\n            else\n            {\n                ColumnName = null;\n            }\n        }\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/SchemaAnnotations/SchemaAnnotationDbAttribute.cs", "chunked_list": ["\ufeffusing Magic.IndexedDb.Helpers;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb\n{\n    public class MagicTableAttribute : Attribute\n    {", "{\n    public class MagicTableAttribute : Attribute\n    {\n        public string SchemaName { get; }\n        public string DatabaseName { get; }\n\n        public MagicTableAttribute(string schemaName, string databaseName = null)\n        {\n            SchemaName = schemaName;\n\n            if (!String.IsNullOrWhiteSpace(databaseName))\n                DatabaseName = databaseName;\n            else\n                DatabaseName = SchemaHelper.defaultNone;\n        }\n    }\n}\n", "            if (!String.IsNullOrWhiteSpace(databaseName))\n                DatabaseName = databaseName;\n            else\n                DatabaseName = SchemaHelper.defaultNone;\n        }\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/Factories/EncryptionFactory.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.JSInterop;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing static System.Runtime.InteropServices.JavaScript.JSType;\n\nnamespace Magic.IndexedDb", "\nnamespace Magic.IndexedDb\n{\n    public class EncryptionFactory: IEncryptionFactory\n    {\n        readonly IJSRuntime _jsRuntime;\n        readonly IndexedDbManager _indexDbManager;\n\n        public EncryptionFactory(IJSRuntime jsRuntime, IndexedDbManager indexDbManager)\n        {\n            _jsRuntime = jsRuntime;\n            _indexDbManager = indexDbManager;\n        }\n", "        public async Task<string> Encrypt(string data, string key)\n        {\n            var mod = await _indexDbManager.GetModule(_jsRuntime);\n            string encryptedData = await mod.InvokeAsync<string>(\"encryptString\", new[] { data, key });\n            return encryptedData;\n        }\n\n        public async Task<string> Decrypt(string encryptedData, string key)\n        {\n            var mod = await _indexDbManager.GetModule(_jsRuntime);\n            string decryptedData = await mod.InvokeAsync<string>(\"decryptString\", new[] { encryptedData, key });\n            return decryptedData;\n        }\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/Factories/IEncryptionFactory.cs", "chunked_list": ["using System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb\n{\n    public interface IEncryptionFactory\n    {\n        Task<string> Encrypt(string data, string key);\n\n        Task<string> Decrypt(string data, string key);\n    }\n}"]}
{"filename": "Magic.IndexedDb/Factories/IMagicDbFactory.cs", "chunked_list": ["using System.Threading.Tasks;\n\nnamespace Magic.IndexedDb\n{\n    public interface IMagicDbFactory\n    {\n        Task<IndexedDbManager> GetDbManager(string dbName);\n\n        Task<IndexedDbManager> GetDbManager(DbStore dbStore);\n    }\n}"]}
{"filename": "Magic.IndexedDb/Factories/MagicDbFactory.cs", "chunked_list": ["using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.JSInterop;\n\nnamespace Magic.IndexedDb\n{\n    public class MagicDbFactory : IMagicDbFactory\n    {\n        readonly IJSRuntime _jsRuntime;\n        readonly IServiceProvider _serviceProvider;\n        readonly IDictionary<string, IndexedDbManager> _dbs = new Dictionary<string, IndexedDbManager>();", "{\n    public class MagicDbFactory : IMagicDbFactory\n    {\n        readonly IJSRuntime _jsRuntime;\n        readonly IServiceProvider _serviceProvider;\n        readonly IDictionary<string, IndexedDbManager> _dbs = new Dictionary<string, IndexedDbManager>();\n        //private IJSObjectReference _module;\n\n        public MagicDbFactory(IServiceProvider serviceProvider, IJSRuntime jSRuntime)\n        {\n            _serviceProvider = serviceProvider;\n            _jsRuntime = jSRuntime;\n        }", "        //public async Task<IndexedDbManager> CreateAsync(DbStore dbStore)\n        //{\n        //    var manager = new IndexedDbManager(dbStore, _jsRuntime);\n        //    var importedManager = await _jsRuntime.InvokeAsync<IJSObjectReference>(\"import\", \"./_content/Magic.IndexedDb/magicDB.js\");\n        //    return manager;\n        //}\n\n        public async Task<IndexedDbManager> GetDbManager(string dbName)\n        {\n            if (!_dbs.Any())\n                await BuildFromServices();", "            if (!_dbs.Any())\n                await BuildFromServices();\n            if (_dbs.ContainsKey(dbName))\n                return _dbs[dbName];\n\n#pragma warning disable CS8603 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.\n            return null;\n#pragma warning restore CS8603 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.\n\n        }\n\n        public Task<IndexedDbManager> GetDbManager(DbStore dbStore)\n            => GetDbManager(dbStore.Name);\n\n        async Task BuildFromServices()\n        {\n            var dbStores = _serviceProvider.GetServices<DbStore>();", "            if (dbStores != null)\n            {\n                foreach (var dbStore in dbStores)\n                {\n                    Console.WriteLine($\"{dbStore.Name}{dbStore.Version}{dbStore.StoreSchemas.Count}\");\n                    var db = new IndexedDbManager(dbStore, _jsRuntime);\n                    await db.OpenDb();\n                    _dbs.Add(dbStore.Name, db);\n                }\n            }\n        }\n    }\n}"]}
{"filename": "Magic.IndexedDb/Helpers/ManagerHelper.cs", "chunked_list": ["\ufeffusing Magic.IndexedDb.SchemaAnnotations;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb.Helpers", "\nnamespace Magic.IndexedDb.Helpers\n{\n    public static class ManagerHelper\n    {\n        public static Dictionary<string, object?> ConvertPropertyNamesUsingMappings(Dictionary<string, object?> inputRecord, Dictionary<string, string> propertyMappings)\n        {\n            var updatedRecord = new Dictionary<string, object?>();\n            foreach (var kvp in inputRecord)\n            {\n                var targetKey = propertyMappings.FirstOrDefault(x => x.Value == kvp.Key).Key;", "            foreach (var kvp in inputRecord)\n            {\n                var targetKey = propertyMappings.FirstOrDefault(x => x.Value == kvp.Key).Key;\n                if (targetKey != null)\n                {\n                    updatedRecord[targetKey] = kvp.Value;\n                }\n                else\n                {\n                    updatedRecord[kvp.Key] = kvp.Value;\n                }\n            }\n            return updatedRecord;\n        }\n", "        public static Dictionary<string, object?> ConvertRecordToDictionary<TRecord>(TRecord record)\n        {\n            var propertyMappings = GeneratePropertyMapping<TRecord>();\n            var dictionary = new Dictionary<string, object?>();\n            var properties = typeof(TRecord).GetProperties();\n\n            foreach (var property in properties)\n            {\n                var value = property.GetValue(record);\n                var columnName = property.Name;\n", "                if (propertyMappings.ContainsValue(property.Name))\n                {\n                    columnName = propertyMappings.First(kvp => kvp.Value == property.Name).Key;\n                }\n\n                dictionary[columnName] = value!;\n            }\n\n            return dictionary;\n        }\n", "        public static Dictionary<string, string> GeneratePropertyMapping<TRecord>()\n        {\n            var propertyMappings = new Dictionary<string, string>();\n            var properties = typeof(TRecord).GetProperties();\n            foreach (var property in properties)\n            {\n                var indexDbAttr = property.GetCustomAttribute<MagicIndexAttribute>();\n                var uniqueIndexDbAttr = property.GetCustomAttribute<MagicUniqueIndexAttribute>();\n                var primaryKeyDbAttr = property.GetCustomAttribute<MagicPrimaryKeyAttribute>();\n\n                var columnName = property.Name;", "                if (indexDbAttr != null)\n                    columnName = property.GetPropertyColumnName<MagicIndexAttribute>();\n                else if (uniqueIndexDbAttr != null)\n                    columnName = property.GetPropertyColumnName<MagicUniqueIndexAttribute>();\n                else if (primaryKeyDbAttr != null)\n                    columnName = property.GetPropertyColumnName<MagicPrimaryKeyAttribute>();\n\n                propertyMappings[columnName] = property.Name;\n            }\n            return propertyMappings;\n        }\n", "        public static object? GetValueFromValueKind(object value)\n        {\n            if (value is JsonElement jsonElement)\n            {\n                return jsonElement.ValueKind switch\n                {\n                    JsonValueKind.Number => jsonElement.GetDecimal(),\n                    JsonValueKind.String => jsonElement.GetString(),\n                    JsonValueKind.True => true,\n                    JsonValueKind.False => false,\n                    _ => null\n                };\n            }\n\n            return value;\n        }\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/Helpers/SchemaHelper.cs", "chunked_list": ["\ufeffusing Magic.IndexedDb.SchemaAnnotations;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.Reflection;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb.Helpers", "\nnamespace Magic.IndexedDb.Helpers\n{\n    public static class SchemaHelper\n    {\n        public const string defaultNone = \"DefaultedNone\";\n\n        public static string GetSchemaName<T>() where T : class\n        {\n            Type type = typeof(T);\n            string schemaName;\n            var schemaAttribute = type.GetCustomAttribute<MagicTableAttribute>();", "            if (schemaAttribute != null)\n            {\n                schemaName = schemaAttribute.SchemaName;\n            }\n            else\n            {\n                schemaName = type.Name;\n            }\n            return schemaName;\n        }\n", "        public static List<string> GetPropertyNamesFromExpression<T>(Expression<Func<T, bool>> predicate) where T : class\n        {\n            var propertyNames = new List<string>();\n\n            if (predicate.Body is BinaryExpression binaryExpression)\n            {\n                var left = binaryExpression.Left as MemberExpression;\n                var right = binaryExpression.Right as MemberExpression;\n\n                if (left != null) propertyNames.Add(left.Member.Name);\n                if (right != null) propertyNames.Add(right.Member.Name);\n            }", "                if (left != null) propertyNames.Add(left.Member.Name);\n                if (right != null) propertyNames.Add(right.Member.Name);\n            }\n            else if (predicate.Body is MethodCallExpression methodCallExpression)\n            {\n                var argument = methodCallExpression.Object as MemberExpression;\n                if (argument != null) propertyNames.Add(argument.Member.Name);\n            }\n\n            return propertyNames;\n        }\n\n", "        public static List<StoreSchema> GetAllSchemas(string databaseName = null)\n        {\n            List<StoreSchema> schemas = new List<StoreSchema>();\n            var assemblies = AppDomain.CurrentDomain.GetAssemblies();\n\n            foreach (var assembly in assemblies)\n            {\n                var types = assembly.GetTypes();\n\n                foreach (var type in types)\n                {\n                    //var attributes = type.GetCustomAttributes(typeof(SchemaAnnotationDbAttribute), false);\n", "                foreach (var type in types)\n                {\n                    //var attributes = type.GetCustomAttributes(typeof(SchemaAnnotationDbAttribute), false);\n\n                    //if (attributes.Length > 0)\n                    //{\n                    var schemaAttribute = type.GetCustomAttribute<MagicTableAttribute>();\n                    if (schemaAttribute != null)\n                    {\n                        string DbName = null;\n", "                        if (!String.IsNullOrWhiteSpace(databaseName))\n                            DbName = databaseName;\n                        else\n                            DbName = defaultNone;\n\n                        if (schemaAttribute.DatabaseName.Equals(DbName))\n                        {\n                            //var schema = typeof(SchemaHelper).GetMethod(\"GetStoreSchema\").MakeGenericMethod(type).Invoke(null, new object[] { }) as StoreSchema;\n                            var schema = GetStoreSchema(type);\n                            schemas.Add(schema);\n                        }\n                    }\n                }\n            }\n\n            return schemas;\n        }\n", "        public static StoreSchema GetStoreSchema<T>(string name = null, bool PrimaryKeyAuto = true) where T : class\n        {\n            Type type = typeof(T);\n            return GetStoreSchema(type, name, PrimaryKeyAuto);\n        }\n\n        public static StoreSchema GetStoreSchema(Type type, string name = null, bool PrimaryKeyAuto = true)\n        {\n            StoreSchema schema = new StoreSchema();\n            schema.PrimaryKeyAuto = PrimaryKeyAuto;\n\n", "            //if (String.IsNullOrWhiteSpace(name))\n            //    schema.Name = type.Name;\n            //else\n            //    schema.Name = name;\n\n            // Get the schema name from the SchemaAnnotationDbAttribute if it exists\n            var schemaAttribute = type.GetCustomAttribute<MagicTableAttribute>();\n            if (schemaAttribute != null)\n            {\n                schema.Name = schemaAttribute.SchemaName;\n            }", "            else if (!String.IsNullOrWhiteSpace(name))\n            {\n                schema.Name = name;\n            }\n            else\n            {\n                schema.Name = type.Name;\n            }\n\n            // Get the primary key property\n            PropertyInfo? primaryKeyProperty = type.GetProperties().FirstOrDefault(prop => Attribute.IsDefined(prop, typeof(MagicPrimaryKeyAttribute)));\n", "            if (primaryKeyProperty == null)\n            {\n                throw new InvalidOperationException(\"The entity does not have a primary key attribute.\");\n            }\n\n            if (type.GetProperties().Count(prop => Attribute.IsDefined(prop, typeof(MagicPrimaryKeyAttribute))) > 1)\n            {\n                throw new InvalidOperationException(\"The entity has more than one primary key attribute.\");\n            }\n\n            schema.PrimaryKey = primaryKeyProperty.GetPropertyColumnName<MagicPrimaryKeyAttribute>();\n\n            // Get the unique index properties\n            var uniqueIndexProperties = type.GetProperties().Where(prop => Attribute.IsDefined(prop, typeof(MagicUniqueIndexAttribute)));\n", "            foreach (PropertyInfo? prop in uniqueIndexProperties)\n            {\n                if (prop != null)\n                {\n                    schema.UniqueIndexes.Add(prop.GetPropertyColumnName<MagicUniqueIndexAttribute>());\n                }\n            }\n\n            // Get the index properties\n            var indexProperties = type.GetProperties().Where(prop => Attribute.IsDefined(prop, typeof(MagicIndexAttribute)));\n", "            foreach (var prop in indexProperties)\n            {\n                schema.Indexes.Add(prop.GetPropertyColumnName<MagicIndexAttribute>());\n            }\n\n            return schema;\n        }\n\n        public static string GetPropertyColumnName(this PropertyInfo prop, Type attributeType)\n        {\n            Attribute? attribute = Attribute.GetCustomAttribute(prop, attributeType);\n\n            string columnName = prop.Name;\n", "        public static string GetPropertyColumnName(this PropertyInfo prop, Type attributeType)\n        {\n            Attribute? attribute = Attribute.GetCustomAttribute(prop, attributeType);\n\n            string columnName = prop.Name;\n\n            if (attribute != null)\n            {\n                PropertyInfo[] properties = attributeType.GetProperties();\n                foreach (PropertyInfo property in properties)\n                {", "                foreach (PropertyInfo property in properties)\n                {\n                    if (Attribute.IsDefined(property, typeof(MagicColumnNameDesignatorAttribute)))\n                    {\n                        object? designatedColumnNameObject = property.GetValue(attribute);\n                        if (designatedColumnNameObject != null)\n                        {\n                            string designatedColumnName = designatedColumnNameObject as string ?? designatedColumnNameObject.ToString();\n                            if (!string.IsNullOrWhiteSpace(designatedColumnName))\n                            {\n                                columnName = designatedColumnName;\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n\n            return columnName;\n        }", "                            if (!string.IsNullOrWhiteSpace(designatedColumnName))\n                            {\n                                columnName = designatedColumnName;\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n\n            return columnName;\n        }", "        public static string GetPropertyColumnName<T>(this PropertyInfo prop) where T : Attribute\n        {\n            T? attribute = (T?)Attribute.GetCustomAttribute(prop, typeof(T));\n\n            return prop.GetPropertyColumnName(typeof(T));\n\n        }\n\n\n        //public StoreSchema GetStoreSchema<T>(bool PrimaryKeyAuto = true) where T : class\n        //{\n        //    StoreSchema schema = new StoreSchema();\n        //    schema.PrimaryKeyAuto = PrimaryKeyAuto;\n\n\n        //    return schema;\n        //}\n    }\n}\n", "        //public StoreSchema GetStoreSchema<T>(bool PrimaryKeyAuto = true) where T : class\n        //{\n        //    StoreSchema schema = new StoreSchema();\n        //    schema.PrimaryKeyAuto = PrimaryKeyAuto;\n\n\n        //    return schema;\n        //}\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/Extensions/ServiceCollectionExtensions.cs", "chunked_list": ["\ufeffusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.DependencyInjection.Extensions;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb.Extensions\n{\n    public static class ServiceCollectionExtensions\n    {", "namespace Magic.IndexedDb.Extensions\n{\n    public static class ServiceCollectionExtensions\n    {\n        public static IServiceCollection AddBlazorDB(this IServiceCollection services, Action<DbStore> options)\n        {\n            var dbStore = new DbStore();\n            options(dbStore);\n\n            services.AddTransient<DbStore>((_) => dbStore);\n            services.TryAddSingleton<IMagicDbFactory, MagicDbFactory>();\n\n            return services;\n        }\n", "        public static IServiceCollection AddEncryptionFactory(this IServiceCollection services)\n        {\n            services.TryAddSingleton<IEncryptionFactory, EncryptionFactory>();\n\n            return services;\n        }\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/Models/StoredMagicQuery.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb.Models\n{\n    internal struct MagicQueryFunctions\n    {\n        public const string Take = \"take\";", "    internal struct MagicQueryFunctions\n    {\n        public const string Take = \"take\";\n        public const string Take_Last = \"takeLast\";\n        public const string Skip = \"skip\";\n        public const string Order_By = \"orderBy\";\n        public const string Order_By_Descending = \"orderByDescending\";\n        public const string Reverse = \"reverse\";\n        public const string First = \"first\";\n        public const string Last = \"last\";\n\n    }", "        public const string First = \"first\";\n        public const string Last = \"last\";\n\n    }\n    public class StoredMagicQuery\n    {\n        public string? Name { get; set; }\n        public int IntValue { get; set; } = 0;\n        public string? StringValue { get; set; }\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/Models/CustomContractResolver.cs", "chunked_list": ["\ufeffusing Newtonsoft.Json.Serialization;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb.Models\n{\n    public class CustomContractResolver : DefaultContractResolver\n    {", "{\n    public class CustomContractResolver : DefaultContractResolver\n    {\n        private readonly Dictionary<string, string> _propertyMappings;\n\n        public CustomContractResolver(Dictionary<string, string> propertyMappings)\n        {\n            _propertyMappings = propertyMappings;\n        }\n\n        protected override string ResolvePropertyName(string propertyName)\n        {", "        protected override string ResolvePropertyName(string propertyName)\n        {\n            if (_propertyMappings.TryGetValue(propertyName, out var resolvedName))\n            {\n                return resolvedName;\n            }\n\n            return base.ResolvePropertyName(propertyName);\n        }\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/Models/DbMigration.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb\n{\n    public class DbMigration\n    {\n        public string? FromVersion { get; set; }\n        public string? ToVersion { get; set; }\n        public List<DbMigrationInstruction> Instructions { get; set; } = new List<DbMigrationInstruction>();\n    }\n}\n", "    public class DbMigration\n    {\n        public string? FromVersion { get; set; }\n        public string? ToVersion { get; set; }\n        public List<DbMigrationInstruction> Instructions { get; set; } = new List<DbMigrationInstruction>();\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/Models/DbStore.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb\n{\n    public class DbStore\n    {\n        public string Name { get; set; }", "    public class DbStore\n    {\n        public string Name { get; set; }\n        public string Version { get; set; }\n        public string EncryptionKey { get; set; }\n        public List<StoreSchema> StoreSchemas { get; set; }\n        public List<DbMigration> DbMigrations { get; set; } = new List<DbMigration>();\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/Models/JsSettings.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb.Models\n{\n    public class JsSettings\n    {\n        public double Timeout { get; set; } = 100000;\n    }\n}\n", "    public class JsSettings\n    {\n        public double Timeout { get; set; } = 100000;\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/Models/StoreSchema.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb\n{\n    public class StoreSchema\n    {\n        public string Name { get; set; }", "    public class StoreSchema\n    {\n        public string Name { get; set; }\n        public string PrimaryKey { get; set; }\n        public bool PrimaryKeyAuto { get; set; }\n        public List<string> UniqueIndexes { get; set; } = new List<string>();\n        public List<string> Indexes { get; set; } = new List<string>();\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/Models/UpdateRecord.cs", "chunked_list": ["namespace Magic.IndexedDb\n{\n    public class UpdateRecord<T> : StoreRecord<T>\n    {\n        public object Key { get; set; }\n    }\n}"]}
{"filename": "Magic.IndexedDb/Models/JsResponse.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb.Models\n{\n    public class JsResponse<T>\n    {\n        public JsResponse(T data, bool success, string message)\n        {\n            Data = data;\n            Success = success;\n            Message = message;\n        }\n\n        /// <summary>\n        /// Dynamic typed response data\n        /// </summary>", "    public class JsResponse<T>\n    {\n        public JsResponse(T data, bool success, string message)\n        {\n            Data = data;\n            Success = success;\n            Message = message;\n        }\n\n        /// <summary>\n        /// Dynamic typed response data\n        /// </summary>", "        public T Data { get; set; }\n        /// <summary>\n        /// Boolean indicator for successful API call\n        /// </summary>\n        public bool Success { get; set; }\n        /// <summary>\n        /// Human readable message to describe success / error conditions\n        /// </summary>\n        public string Message { get; set; }\n    }\n}\n", "        public string Message { get; set; }\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/Models/StoreRecord.cs", "chunked_list": ["namespace Magic.IndexedDb\n{ \n    public class StoreRecord<T>\n    {\n        public string? DbName { get; set; }\n        public string? StoreName { get; set; }\n        public T? Record { get; set; }\n    }\n}"]}
{"filename": "Magic.IndexedDb/Models/BlazorEvent.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb\n{\n    public class BlazorDbEvent\n    {\n        public Guid Transaction { get; set; }", "    public class BlazorDbEvent\n    {\n        public Guid Transaction { get; set; }\n        public bool Failed { get; set; }\n        public string Message { get; set; }\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/Models/IndexFilterValue.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb.Models\n{\n    public class IndexFilterValue\n    {\n        public IndexFilterValue(string indexName, object filterValue)\n        {\n            IndexName = indexName;\n            FilterValue = filterValue;\n        }\n", "    public class IndexFilterValue\n    {\n        public IndexFilterValue(string indexName, object filterValue)\n        {\n            IndexName = indexName;\n            FilterValue = filterValue;\n        }\n\n        public string IndexName { get; set; }\n        public object FilterValue { get; set; }\n    }\n}\n", "        public string IndexName { get; set; }\n        public object FilterValue { get; set; }\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/Models/PredicateVisitor.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb.Models\n{\n    public class PredicateVisitor<T> : ExpressionVisitor\n    {", "namespace Magic.IndexedDb.Models\n{\n    public class PredicateVisitor<T> : ExpressionVisitor\n    {\n        protected override Expression VisitMethodCall(MethodCallExpression node)\n        {\n            if (node.Method.Name == \"Any\" && node.Arguments[0] is MemberExpression member)\n            {\n                // Handle Any expressions\n                var lambda = GetLambdaExpression(node.Arguments[1]);\n                var values = GetIEnumerableItems(member);\n                return values.Select(value => ReplaceParameter(lambda, value)).Aggregate<Expression>((left, right) => Expression.OrElse(left, right));\n            }", "            else if (node.Method.Name == \"All\" && node.Arguments[0] is MemberExpression member3)\n            {\n                // Handle All expressions\n                var lambda = GetLambdaExpression(node.Arguments[1]);\n                var values = GetIEnumerableItems(member3);\n                return values.Select(value => ReplaceParameter(lambda, value)).Aggregate<Expression>((left, right) => Expression.AndAlso(left, right));\n            }\n            else\n            {\n                return base.VisitMethodCall(node);\n            }\n        }\n", "        private LambdaExpression GetLambdaExpression(Expression expression)\n        {\n            if (expression is UnaryExpression unaryExpression)\n            {\n                if (unaryExpression.Operand is LambdaExpression lambdaExpression)\n                {\n                    return lambdaExpression;\n                }\n            }\n            else if (expression is LambdaExpression lambda)\n            {\n                return lambda;\n            }\n\n            throw new InvalidOperationException(\"Invalid expression type.\");\n        }\n\n        private IEnumerable<object> GetIEnumerableItems(MemberExpression member)\n        {\n            var compiledMember = Expression.Lambda<Func<IEnumerable>>(member).Compile();\n            var enumerable = compiledMember();\n            return enumerable.OfType<object>();\n        }\n", "            else if (expression is LambdaExpression lambda)\n            {\n                return lambda;\n            }\n\n            throw new InvalidOperationException(\"Invalid expression type.\");\n        }\n\n        private IEnumerable<object> GetIEnumerableItems(MemberExpression member)\n        {\n            var compiledMember = Expression.Lambda<Func<IEnumerable>>(member).Compile();\n            var enumerable = compiledMember();\n            return enumerable.OfType<object>();\n        }\n", "        private Expression ReplaceParameter(LambdaExpression lambda, object value)\n        {\n            var parameter = lambda.Parameters.FirstOrDefault();\n            if (parameter != null)\n            {\n                var constant = Expression.Constant(value, parameter.Type);\n                var body = new ParameterReplacer(parameter, constant).Visit(lambda.Body);\n                return body;\n            }\n            else\n            {\n                return Expression.Empty();\n            }\n        }\n", "        private class ParameterReplacer : ExpressionVisitor\n        {\n            private readonly ParameterExpression _parameter;\n            private readonly Expression _replacement;\n\n            public ParameterReplacer(ParameterExpression parameter, Expression replacement)\n            {\n                _parameter = parameter;\n                _replacement = replacement;\n            }\n", "            protected override Expression VisitParameter(ParameterExpression node)\n            {\n                if (node == _parameter)\n                {\n                    return _replacement;\n                }\n\n                return base.VisitParameter(node);\n            }\n        }\n    }\n\n\n\n\n}\n"]}
{"filename": "Magic.IndexedDb/Models/DbMigrationInstruction.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Magic.IndexedDb\n{\n    public class DbMigrationInstruction\n    {\n        public string Action { get; set; }", "    public class DbMigrationInstruction\n    {\n        public string Action { get; set; }\n        public string StoreName { get; set; }\n        public string Details { get; set; }\n    }\n}\n"]}
{"filename": "Magic.IndexedDb/Models/MagicQuery.cs", "chunked_list": ["\ufeffusing Magic.IndexedDb.Helpers;\nusing Magic.IndexedDb.SchemaAnnotations;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.Reflection;\nusing System.Text;\nusing System.Threading.Tasks;\n", "using System.Threading.Tasks;\n\nnamespace Magic.IndexedDb.Models\n{\n    public class MagicQuery<T> where T : class\n    {\n        public string SchemaName { get; }\n        public List<string> JsonQueries { get; }\n        public IndexedDbManager Manager { get; }\n\n        public MagicQuery(string schemaName, IndexedDbManager manager)\n        {\n            Manager = manager;\n            SchemaName = schemaName;\n            JsonQueries = new List<string>();\n        }\n\n        public List<StoredMagicQuery> storedMagicQueries { get; set; } = new List<StoredMagicQuery>();\n", "        public IndexedDbManager Manager { get; }\n\n        public MagicQuery(string schemaName, IndexedDbManager manager)\n        {\n            Manager = manager;\n            SchemaName = schemaName;\n            JsonQueries = new List<string>();\n        }\n\n        public List<StoredMagicQuery> storedMagicQueries { get; set; } = new List<StoredMagicQuery>();\n", "        public bool ResultsUnique { get; set; } = true;\n\n        /// <summary>\n        /// Return a list of items in which the items do not have to be unique. Therefore, you can get \n        /// duplicate instances of an object depending on how you write your query.\n        /// </summary>\n        /// <param name=\"amount\"></param>\n        /// <returns></returns>\n        public MagicQuery<T> ResultsNotUnique()\n        {\n            ResultsUnique = false;\n            return this;\n        }\n\n        public MagicQuery<T> Take(int amount)\n        {\n            StoredMagicQuery smq = new StoredMagicQuery();\n            smq.Name = MagicQueryFunctions.Take;\n            smq.IntValue = amount;\n            storedMagicQueries.Add(smq);\n            return this;\n        }\n\n        public MagicQuery<T> TakeLast(int amount)\n        {\n            StoredMagicQuery smq = new StoredMagicQuery();\n            smq.Name = MagicQueryFunctions.Take_Last;\n            smq.IntValue = amount;\n            storedMagicQueries.Add(smq);\n            return this;\n        }\n\n        public MagicQuery<T> Skip(int amount)\n        {\n            StoredMagicQuery smq = new StoredMagicQuery();\n            smq.Name = MagicQueryFunctions.Skip;\n            smq.IntValue = amount;\n            storedMagicQueries.Add(smq);\n            return this;\n        }\n\n        //public MagicQuery<T> Reverse()\n        //{\n        //    StoredMagicQuery smq = new StoredMagicQuery();\n        //    smq.Name = MagicQueryFunctions.Reverse;\n        //    storedMagicQueries.Add(smq);\n        //    return this;\n        //}\n\n        // Not yet working\n        private MagicQuery<T> First()\n        {\n            StoredMagicQuery smq = new StoredMagicQuery();\n            smq.Name = MagicQueryFunctions.First;\n            storedMagicQueries.Add(smq);\n            return this;\n        }\n\n        // Not yet working\n        private MagicQuery<T> Last()\n        {\n            StoredMagicQuery smq = new StoredMagicQuery();\n            smq.Name = MagicQueryFunctions.Last;\n            storedMagicQueries.Add(smq);\n            return this;\n        }\n", "        public async Task<IEnumerable<T>> Execute()\n        {\n            return await Manager.WhereV2<T>(SchemaName, JsonQueries, this) ?? Enumerable.Empty<T>();\n        }\n\n        public async Task<int> Count()\n        {\n            var result = await Manager.WhereV2<T>(SchemaName, JsonQueries, this);\n            int num = result?.Count() ?? 0;\n            return num;\n        }\n\n\n        // Not currently available in Dexie version 1,2, or 3\n        public MagicQuery<T> OrderBy(Expression<Func<T, object>> predicate)\n        {\n            var memberExpression = GetMemberExpressionFromLambda(predicate);\n            var propertyInfo = memberExpression.Member as PropertyInfo;\n", "            if (propertyInfo == null)\n            {\n                throw new ArgumentException(\"The expression must represent a single property access.\");\n            }\n\n            var indexDbAttr = propertyInfo.GetCustomAttribute<MagicIndexAttribute>();\n            var uniqueIndexDbAttr = propertyInfo.GetCustomAttribute<MagicUniqueIndexAttribute>();\n            var primaryKeyDbAttr = propertyInfo.GetCustomAttribute<MagicPrimaryKeyAttribute>();\n\n            if (indexDbAttr == null && uniqueIndexDbAttr == null && primaryKeyDbAttr == null)\n            {\n                throw new ArgumentException(\"The selected property must have either MagicIndexAttribute, MagicUniqueIndexAttribute, or MagicPrimaryKeyAttribute.\");\n            }\n\n            string? columnName = null;\n", "            if (indexDbAttr == null && uniqueIndexDbAttr == null && primaryKeyDbAttr == null)\n            {\n                throw new ArgumentException(\"The selected property must have either MagicIndexAttribute, MagicUniqueIndexAttribute, or MagicPrimaryKeyAttribute.\");\n            }\n\n            string? columnName = null;\n\n            if (indexDbAttr != null)\n                columnName = propertyInfo.GetPropertyColumnName<MagicIndexAttribute>();\n            else if (primaryKeyDbAttr != null)\n                columnName = propertyInfo.GetPropertyColumnName<MagicPrimaryKeyAttribute>();", "            else if (primaryKeyDbAttr != null)\n                columnName = propertyInfo.GetPropertyColumnName<MagicPrimaryKeyAttribute>();\n            else if (uniqueIndexDbAttr != null)\n                columnName = propertyInfo.GetPropertyColumnName<MagicUniqueIndexAttribute>();\n\n            StoredMagicQuery smq = new StoredMagicQuery();\n            smq.Name = MagicQueryFunctions.Order_By;\n            smq.StringValue = columnName;\n            storedMagicQueries.Add(smq);\n            return this;\n        }\n\n        // Not currently available in Dexie version 1,2, or 3\n        public MagicQuery<T> OrderByDescending(Expression<Func<T, object>> predicate)\n        {\n            var memberExpression = GetMemberExpressionFromLambda(predicate);\n            var propertyInfo = memberExpression.Member as PropertyInfo;\n", "            if (propertyInfo == null)\n            {\n                throw new ArgumentException(\"The expression must represent a single property access.\");\n            }\n\n            var indexDbAttr = propertyInfo.GetCustomAttribute<MagicIndexAttribute>();\n            var uniqueIndexDbAttr = propertyInfo.GetCustomAttribute<MagicUniqueIndexAttribute>();\n            var primaryKeyDbAttr = propertyInfo.GetCustomAttribute<MagicPrimaryKeyAttribute>();\n\n            if (indexDbAttr == null && uniqueIndexDbAttr == null && primaryKeyDbAttr == null)\n            {\n                throw new ArgumentException(\"The selected property must have either MagicIndexAttribute, MagicUniqueIndexAttribute, or MagicPrimaryKeyAttribute.\");\n            }\n\n            string? columnName = null;\n", "            if (indexDbAttr == null && uniqueIndexDbAttr == null && primaryKeyDbAttr == null)\n            {\n                throw new ArgumentException(\"The selected property must have either MagicIndexAttribute, MagicUniqueIndexAttribute, or MagicPrimaryKeyAttribute.\");\n            }\n\n            string? columnName = null;\n\n            if (indexDbAttr != null)\n                columnName = propertyInfo.GetPropertyColumnName<MagicIndexAttribute>();\n            else if (primaryKeyDbAttr != null)\n                columnName = propertyInfo.GetPropertyColumnName<MagicPrimaryKeyAttribute>();", "            else if (primaryKeyDbAttr != null)\n                columnName = propertyInfo.GetPropertyColumnName<MagicPrimaryKeyAttribute>();\n            else if (uniqueIndexDbAttr != null)\n                columnName = propertyInfo.GetPropertyColumnName<MagicUniqueIndexAttribute>();\n\n            StoredMagicQuery smq = new StoredMagicQuery();\n            smq.Name = MagicQueryFunctions.Order_By_Descending;\n            smq.StringValue = columnName;\n            storedMagicQueries.Add(smq);\n            return this;\n        }\n\n#pragma warning disable CS0693 // Mark members as static", "        private MemberExpression GetMemberExpressionFromLambda<T>(Expression<Func<T, object>> expression)\n#pragma warning restore CS0693 // Mark members as static\n        {\n            if (expression.Body is MemberExpression)\n            {\n                return (MemberExpression)expression.Body;\n            }\n            else if (expression.Body is UnaryExpression && ((UnaryExpression)expression.Body).Operand is MemberExpression)\n            {\n                return (MemberExpression)((UnaryExpression)expression.Body).Operand;\n            }\n            else\n            {\n                throw new ArgumentException(\"The expression must represent a single property access.\");\n            }\n        }\n\n    }\n}\n"]}
{"filename": "IndexDb.Example/Program.cs", "chunked_list": ["using IndexDb.Example;\nusing Magic.IndexedDb;\nusing Magic.IndexedDb.Extensions;\nusing Magic.IndexedDb.Helpers;\nusing Microsoft.AspNetCore.Components.Web;\nusing Microsoft.AspNetCore.Components.WebAssembly.Hosting;\n\nvar builder = WebAssemblyHostBuilder.CreateDefault(args);\nbuilder.RootComponents.Add<App>(\"#app\");\nbuilder.RootComponents.Add<HeadOutlet>(\"head::after\");", "builder.RootComponents.Add<App>(\"#app\");\nbuilder.RootComponents.Add<HeadOutlet>(\"head::after\");\n\nbuilder.Services.AddScoped(sp => new HttpClient { BaseAddress = new Uri(builder.HostEnvironment.BaseAddress) });\n\n\n/*\n * This is an example encryption key. You must make your own 128 bit or 256 bit \n * key! Do not use this example encryption key that I've provided here as that's\n * incredibly unsafe!", " * key! Do not use this example encryption key that I've provided here as that's\n * incredibly unsafe!\n */\nstring EncryptionKey = \"zQfTuWnZi8u7x!A%C*F-JaBdRlUkXp2l\";\n\nbuilder.Services.AddBlazorDB(options =>\n{\n    options.Name = DbNames.Client;\n    options.Version = \"1\";\n    options.EncryptionKey = EncryptionKey;", "    options.Version = \"1\";\n    options.EncryptionKey = EncryptionKey;\n    options.StoreSchemas = SchemaHelper.GetAllSchemas(DbNames.Client);\n    options.DbMigrations = new List<DbMigration>\n{\n        /*\n         * The DbMigration is not currently working or setup!\n         * This is an example and idea I'm thinking about, but \n         * this will very likely be depreciated so do not use or rely\n         * on any of this syntax right now. If you want to have ", "         * this will very likely be depreciated so do not use or rely\n         * on any of this syntax right now. If you want to have \n         * your own migration knowledge. Write JavaScript on the front end \n         * that will check the indedDb version and then apply migration code \n         * on the front end if needed. But this is only needed for complex \n         * migration projects.\n         */\n    new DbMigration\n    {\n        FromVersion = \"1.1\",", "    {\n        FromVersion = \"1.1\",\n        ToVersion = \"2.2\",\n        Instructions = new List<DbMigrationInstruction>\n        {\n            new DbMigrationInstruction\n            {\n                Action = \"renameStore\",\n                StoreName = \"oldStore\",\n                Details = \"newStore\"", "                StoreName = \"oldStore\",\n                Details = \"newStore\"\n            }\n        }\n    }\n};\n});\n\nawait builder.Build().RunAsync();\n", "await builder.Build().RunAsync();\n"]}
{"filename": "IndexDb.Example/Models/Person.cs", "chunked_list": ["\ufeffusing Magic.IndexedDb;\nusing Magic.IndexedDb.SchemaAnnotations;\n\nnamespace IndexDb.Example\n{\n    [MagicTable(\"Person\", DbNames.Client)]\n    public class Person\n    {\n        [MagicPrimaryKey(\"id\")]\n        public int _Id { get; set; }\n\n        [MagicIndex]", "        public int _Id { get; set; }\n\n        [MagicIndex]\n        public string Name { get; set; }\n\n        [MagicIndex(\"Age\")]\n        public int _Age { get; set; }\n\n        [MagicIndex]\n        public int TestInt { get; set; }\n\n        [MagicUniqueIndex(\"guid\")]", "        public int TestInt { get; set; }\n\n        [MagicUniqueIndex(\"guid\")]\n        public Guid GUIY { get; set; } = Guid.NewGuid();\n\n        [MagicEncrypt]\n        public string Secret { get; set; }\n\n        [MagicNotMapped]\n        public string DoNotMapTest { get; set; }\n\n        [MagicNotMapped]", "        public string DoNotMapTest { get; set; }\n\n        [MagicNotMapped]\n        public string SecretDecrypted { get; set; }\n\n        private bool testPrivate { get; set; } = false;\n\n        public bool GetTest()\n        {\n            return true;\n        }\n\n    }\n\n    \n}\n"]}
{"filename": "IndexDb.Example/Models/DbNames.cs", "chunked_list": ["\ufeffnamespace IndexDb.Example\n{\n    public static class DbNames\n    {\n        public const string Client = \"client\";\n    }\n}\n"]}
{"filename": "IndexDb.Example/Pages/Index.razor.cs", "chunked_list": ["\ufeffusing Magic.IndexedDb.Models;\nusing System;\n\nnamespace IndexDb.Example.Pages\n{\n    public partial class Index\n    {\n        private List<Person> allPeople { get; set; } = new List<Person>();\n\n        private IEnumerable<Person> WhereExample { get; set; } = Enumerable.Empty<Person>();\n", "        private double storageQuota { get; set; }\n        private double storageUsage { get; set; }\n        protected override async Task OnAfterRenderAsync(bool firstRender)\n        {\n            if (firstRender)\n            {\n\n                try\n                {\n                    var manager = await _MagicDb.GetDbManager(DbNames.Client);\n\n                    await manager.ClearTable<Person>();\n\n                    var AllThePeeps = await manager.GetAll<Person>();", "                    if (AllThePeeps.Count() < 1)\n                    {\n                        Person[] persons = new Person[] {\n                    new Person { Name = \"Zack\", TestInt = 9, _Age = 45, GUIY = Guid.NewGuid(), Secret = \"I buried treasure behind my house\"},\n                    new Person { Name = \"Luna\", TestInt = 9, _Age = 35, GUIY = Guid.NewGuid(), Secret = \"Jerry is my husband and I had an affair with Bob.\"},\n                    new Person { Name = \"Jerry\", TestInt = 9, _Age = 35, GUIY = Guid.NewGuid(), Secret = \"My wife is amazing\"},\n                    new Person { Name = \"Jon\", TestInt = 9, _Age = 37, GUIY = Guid.NewGuid(), Secret = \"I black mail Luna for money because I know her secret\"},\n                    new Person { Name = \"Jack\", TestInt = 9, _Age = 37, GUIY = Guid.NewGuid(), Secret = \"I have a drug problem\"},\n                    new Person { Name = \"Cathy\", TestInt = 9, _Age = 22, GUIY = Guid.NewGuid(), Secret = \"I got away with reading Bobs diary.\"},\n                    new Person { Name = \"Bob\", TestInt = 3 , _Age = 69, GUIY = Guid.NewGuid(), Secret = \"I caught Cathy reading my diary, but I'm too shy to confront her.\" },\n                    new Person { Name = \"Alex\", TestInt = 3 , _Age = 80, GUIY = Guid.NewGuid(), Secret = \"I'm naked! But nobody can know!\" }\n                    };\n\n                        await manager.AddRange(persons);\n                    }\n\n\n                    //var StorageLimit = await manager.GetStorageEstimateAsync();\n                    var storageInfo = await manager.GetStorageEstimateAsync();\n                    storageQuota = storageInfo.quota;\n                    storageUsage = storageInfo.usage;\n\n                    var allPeopleDecrypted = await manager.GetAll<Person>();\n", "                    foreach (Person person in allPeopleDecrypted)\n                    {\n                        person.SecretDecrypted = await manager.Decrypt(person.Secret);\n                        allPeople.Add(person);\n                    }\n\n                    WhereExample = await manager.Where<Person>(x => x.Name.StartsWith(\"c\", StringComparison.OrdinalIgnoreCase)\n                    || x.Name.StartsWith(\"l\", StringComparison.OrdinalIgnoreCase)\n                    || x.Name.StartsWith(\"j\", StringComparison.OrdinalIgnoreCase) && x._Age > 35\n                    ).OrderBy(x => x._Id).Skip(1).Execute();\n\n\n                    /*\n                     * Still working on allowing nested\n                     */\n                    //// Should return \"Zack\"\n                    //var NestedResult = await manager.Where<Person>(p => (p.Name == \"Zack\" || p.Name == \"Luna\") && (p._Age >= 35 && p._Age <= 45)).Execute();\n\n                    //// should return \"Luna\", \"Jerry\" and \"Jon\"\n                    //var NonNestedResult = await manager.Where<Person>(p => p.TestInt == 9 && p._Age >= 35 && p._Age <= 45).Execute();\n\n                    StateHasChanged();\n                }", "                catch (Exception ex)\n                {\n                    Console.WriteLine(ex.Message);\n                }\n\n            }\n        }\n    }\n}\n"]}
