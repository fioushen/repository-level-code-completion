{"filename": "Program.cs", "chunked_list": ["\ufeffusing Client.ClientBase.UI.Notification;\nusing Client.ClientBase.UI.Overlay;\nusing Client.ClientBase.Utils;\nusing Client.ClientBase.Fonts;\nusing Client.ClientBase;\nusing System.Diagnostics;\nusing System.Threading;\n\nnamespace Client\n{\n    partial class Program\n    {", "namespace Client\n{\n    partial class Program\n    {\n        public static int xSize = 1920;\n        public static int ySize = 1080;\n        public const int maxX = 110;\n        public const int maxY = 110;\n        public static Overlay form = new();\n        private static readonly System.Windows.Forms.Timer redrawTimer = new();\n        private static readonly ManualResetEvent mainThreadEvent = new(false);", "        public static Overlay form = new();\n        private static readonly System.Windows.Forms.Timer redrawTimer = new();\n        private static readonly ManualResetEvent mainThreadEvent = new(false);\n        public static readonly string fontPath = \"YOUR FOLDER PATH HERE\";\n        public static readonly string client_name = \"Rice\";\n\n\n        static void Main(string[] args)\n        {\n            if (fontPath == \"YOUR FOLDER PATH HERE\")\n            {\n                Console.WriteLine(\"Please set the folder path in Program.cs\");\n                return;\n            }\n\n            Console.WriteLine(\"Starting \" + client_name + \" Client\");\n            Console.WriteLine(\"I like \" + client_name);\n\n            Application.ApplicationExit += OnApplicationExit;\n\n            Thread uiApp = new(() =>\n            {\n                FontRenderer.Init();\n                ModuleManager.Init();\n\n                form = new Overlay();\n\n                NotificationManager.Init(form);\n\n                Console.WriteLine(\"Starting Keymapper...\");\n                Keymap.StartListening();\n                Keymap.KeyPressed += ListenForKeybinds;\n                Console.WriteLine(\"Keymapper started.\");\n\n                redrawTimer.Interval = 20;\n                redrawTimer.Tick += (sender, e) => form.Invalidate();\n                redrawTimer.Start();\n\n                System.Windows.Forms.Application.Run(form);\n            });\n\n            uiApp.Start();\n\n            Thread moduleThread = new(() =>\n            {", "            if (fontPath == \"YOUR FOLDER PATH HERE\")\n            {\n                Console.WriteLine(\"Please set the folder path in Program.cs\");\n                return;\n            }\n\n            Console.WriteLine(\"Starting \" + client_name + \" Client\");\n            Console.WriteLine(\"I like \" + client_name);\n\n            Application.ApplicationExit += OnApplicationExit;\n\n            Thread uiApp = new(() =>\n            {\n                FontRenderer.Init();\n                ModuleManager.Init();\n\n                form = new Overlay();\n\n                NotificationManager.Init(form);\n\n                Console.WriteLine(\"Starting Keymapper...\");\n                Keymap.StartListening();\n                Keymap.KeyPressed += ListenForKeybinds;\n                Console.WriteLine(\"Keymapper started.\");\n\n                redrawTimer.Interval = 20;\n                redrawTimer.Tick += (sender, e) => form.Invalidate();\n                redrawTimer.Start();\n\n                System.Windows.Forms.Application.Run(form);\n            });\n\n            uiApp.Start();\n\n            Thread moduleThread = new(() =>\n            {", "                while (true)\n                {\n                    try\n                    {\n                        ModuleManager.OnTick();\n                        Thread.Sleep(1);\n                    }\n                    catch (Exception)\n                    {\n                        // ignored\n                    }\n                }\n            });\n\n            moduleThread.Start();\n\n            mainThreadEvent.WaitOne();\n        }\n\n        // [System.Runtime.InteropServices.LibraryImport(\"user32.dll\", EntryPoint = \"GetForegroundWindowA\")]", "        // private static partial IntPtr GetForegroundWindow();\n\n        // [System.Runtime.InteropServices.LibraryImport(\"user32.dll\", EntryPoint = \"GetWindowThreadProcessIdA\", SetLastError = true)]\n        // private static partial uint GetWindowThreadProcessId(IntPtr hWnd, out int lpdwProcessId);\n\n        // public static bool IsGameForeground()\n        // {\n        //     IntPtr hwnd = GetForegroundWindow();\n        //     GetWindowThreadProcessId(hwnd, out int pid);\n        //     Process process = Process.GetProcessById(pid);\n\n        //     return pid == 19688 || process.ProcessName == \"Shatterline\";\n        // }\n", "        private static void ListenForKeybinds(char key)\n        {\n            // if (!IsGameForeground() && key != 0x2D) return;\n            ModuleManager.OnKeyPress(key);\n        }\n\n        private static void OnApplicationExit(object sender, EventArgs e)\n        {\n            redrawTimer.Stop();\n            Keymap.StopListening();\n            mainThreadEvent.Set();\n        }\n    }\n}\n"]}
{"filename": "ClientBase/Module.cs", "chunked_list": ["using System.Diagnostics;\nusing System.Runtime.InteropServices;\n\nnamespace Client.ClientBase\n{\n    public class Module\n    {\n        public readonly string category;\n        public readonly string name;\n        public readonly string desc;\n        public bool enabled;", "        public readonly string name;\n        public readonly string desc;\n        public bool enabled;\n        public char keybind;\n        private DateTime lastKeyPressTime = DateTime.MinValue;\n        public bool tickable = true;\n\n        protected Module(string name, char keybind, string category, string desc, bool tickable, bool enabled = false)\n        {\n            this.name = name;\n            this.keybind = keybind;\n            this.category = category;\n            this.enabled = enabled;\n            this.desc = desc;\n            this.tickable = tickable;\n        }\n", "        public virtual void OnEnable()\n        {\n            Client.ClientBase.UI.Notification.NotificationManager.AddNotification(name + \" has been enabled\", Color.FromArgb(102, 255, 71));\n            enabled = true;\n        }\n\n        public virtual void OnDisable()\n        {\n            Client.ClientBase.UI.Notification.NotificationManager.AddNotification(name + \" has been disabled\", Color.FromArgb(173, 28, 17));\n            enabled = false;\n        }\n", "        public virtual void OnTick()\n        {\n            if (!tickable)\n                return;\n            Task.Delay(100);\n        }\n\n        public bool MatchesKey(char key)\n        {\n            if (DateTime.Now.Subtract(lastKeyPressTime).TotalMilliseconds > 500)\n            {", "            if (DateTime.Now.Subtract(lastKeyPressTime).TotalMilliseconds > 500)\n            {\n                if (keybind == char.ToUpper(key))\n                {\n                    lastKeyPressTime = DateTime.Now;\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n}"]}
{"filename": "ClientBase/ModuleManager.cs", "chunked_list": ["namespace Client.ClientBase\n{\n    public static class ModuleManager\n    {\n        public static List<Module> modules = new List<Module>();\n\n        public static void AddModule(Module module)\n        {\n            modules.Add(module);\n        }\n", "        public static void RemoveModule(Module module)\n        {\n            modules.Remove(module);\n        }\n\n        public static void Init()\n        {\n            Console.WriteLine(\"Initializing modules...\");\n            AddModule(new Modules.AimAssist());\n            AddModule(new Modules.Aura());\n            AddModule(new Modules.ArrayList());\n            Console.WriteLine(\"Modules initialized.\");\n        }\n", "        public static Module GetModule(string name)\n        {\n            foreach (Module module in modules)\n            {\n                if (module.name == name)\n                {\n                    return module;\n                }\n            }\n\n            return null;\n        }\n", "        public static List<Module> GetModules()\n        {\n            return modules;\n        }\n\n        public static List<Module> GetModulesInCategory(string category)\n        {\n            List<Module> modulesInCategory = new List<Module>();\n\n            foreach (Module module in modules)\n            {", "            foreach (Module module in modules)\n            {\n                if (module.category == category)\n                {\n                    modulesInCategory.Add(module);\n                }\n            }\n\n            return modulesInCategory;\n        }\n", "        public static List<Module> GetEnabledModules()\n        {\n            List<Module> enabledModules = new List<Module>();\n\n            foreach (Module module in modules)\n            {\n                if (module.enabled)\n                {\n                    enabledModules.Add(module);\n                }\n            }\n\n            return enabledModules;\n        }\n", "        public static List<Module> GetEnabledModulesInCategory(string category)\n        {\n            List<Module> enabledModulesInCategory = new List<Module>();\n\n            foreach (Module module in modules)\n            {\n                if (module.enabled && module.category == category)\n                {\n                    enabledModulesInCategory.Add(module);\n                }\n            }\n\n            return enabledModulesInCategory;\n        }\n", "        public static void OnTick()\n        {\n            foreach (Module module in modules)\n            {\n                if (module.enabled && module.tickable)\n                {\n                    module.OnTick();\n                }\n            }\n        }\n", "        public static void OnKeyPress(char keyChar)\n        {\n            foreach (Module module in modules)\n            {\n                if (module.MatchesKey(keyChar))\n                {\n                    if (module.enabled)\n                    {\n                        module.OnDisable();\n                        Console.WriteLine(\"Disabled \" + module.name);\n                    }\n                    else\n                    {\n                        module.OnEnable();\n                        Console.WriteLine(\"Enabled \" + module.name);\n                    }\n                }\n            }\n        }\n    }\n}"]}
{"filename": "ClientBase/VisualModule.cs", "chunked_list": ["using System.Diagnostics;\nusing System.Runtime.InteropServices;\n\nnamespace Client.ClientBase\n{\n    public class VisualModule : Module\n    {\n        protected VisualModule(string name, char keybind, string category, string desc, bool enabled = false) : base(name, keybind, category, desc, enabled)\n        {\n        }\n", "        public virtual void OnDraw(Graphics graphics)\n        {\n\n        }\n    }\n}"]}
{"filename": "ClientBase/UI/Overlay/Overlay.cs", "chunked_list": ["using System.Windows.Forms;\nusing System;\nusing Client.ClientBase.UI.Notification;\nusing Client.ClientBase.Utils;\nusing Client.ClientBase.Fonts;\nusing System.Drawing.Drawing2D;\nusing System.Drawing.Text;\nusing System.Drawing.Imaging;\n\nnamespace Client.ClientBase.UI.Overlay", "\nnamespace Client.ClientBase.UI.Overlay\n{\n    public class Overlay : Form\n    {\n        private BufferedGraphics buffer;\n\n        public Overlay()\n        {\n            FormLayout();\n\n            Program.xSize = GetScreen().Width;\n            Program.ySize = GetScreen().Height;\n        }\n", "        protected override void OnLoad(EventArgs e)\n        {\n            base.OnLoad(e);\n            buffer = BufferedGraphicsManager.Current.Allocate(this.CreateGraphics(), this.ClientRectangle);\n        }\n\n        protected override void OnPaint(PaintEventArgs e)\n        {\n            base.OnPaint(e);\n            Graphics g = buffer.Graphics;\n\n            g.Clear(Color.FromArgb(77, 77, 77));\n            RenderUtil.RenderDropshadowText(g, Program.client_name, new Font(FontRenderer.comfortaaFamily, 26), Color.FromArgb(122, 183, 255), Color.FromArgb(150, 122, 183, 255), 65, new PointF(10, 10));\n            NotificationManager.UpdateNotifications(g);\n", "            foreach (Module mod in ModuleManager.modules)\n            {\n                if (mod.enabled && mod is VisualModule module)\n                {\n                    VisualModule visualMod = module;\n                    visualMod.OnDraw(g);\n                }\n            }\n\n            buffer.Render(e.Graphics);\n        }\n", "        public void FormLayout()\n        {\n            this.Name = Program.client_name;\n            this.Text = Program.client_name;\n            this.Size = new System.Drawing.Size(500, 500);\n            this.StartPosition = FormStartPosition.CenterScreen;\n            this.WindowState = FormWindowState.Maximized;\n            this.FormBorderStyle = FormBorderStyle.None;\n            this.TransparencyKey = Color.FromArgb(77, 77, 77);\n            this.BackColor = this.TransparencyKey;\n            this.BackColor = Color.FromArgb(77, 77, 77);\n            this.Opacity = .8;\n            this.Location = new System.Drawing.Point(0, 0);\n            this.AutoScaleMode = AutoScaleMode.None;\n            this.TopMost = true;\n            this.DoubleBuffered = true;\n        }\n", "        protected override void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                buffer.Dispose();\n            }\n            base.Dispose(disposing);\n        }\n\n        public Rectangle GetScreen()\n        {\n            return System.Windows.Forms.Screen.FromControl(this).Bounds;\n        }\n    }\n}", "        public Rectangle GetScreen()\n        {\n            return System.Windows.Forms.Screen.FromControl(this).Bounds;\n        }\n    }\n}"]}
{"filename": "ClientBase/UI/Notification/Notification.cs", "chunked_list": ["using System;\nusing System.Timers;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing Client.ClientBase.Utils;\n\nnamespace Client.ClientBase.UI.Notification\n{\n    public class Notification\n    {\n        private readonly string _text;", "    public class Notification\n    {\n        private readonly string _text;\n        public Rectangle _boxRect;\n        private readonly Font _titleFont;\n        private readonly Font _textFont;\n        private readonly Color _boxColor;\n        private readonly Color _lineColor;\n\n        public bool isShowing;\n        public event EventHandler Expired;", "        public bool isShowing;\n        public event EventHandler Expired;\n        public Form form;\n\n        private readonly System.Timers.Timer _timer;\n        private readonly int _timerInterval = 5000; // 5 seconds in milliseconds\n        private DateTime _startTime;\n        private readonly int _animationTime = 500; // animation time in milliseconds\n        private bool _enterAnimationCompleted = false;\n        private bool _exitAnimationCompleted = false;\n", "        private bool _enterAnimationCompleted = false;\n        private bool _exitAnimationCompleted = false;\n\n        private int _slideDistance;\n        private int _slideStartPos;\n\n        private readonly Action<Notification> _onTimerElapsedCallback;\n\n        public Notification(string text, Rectangle boxRect, Font titleFont, Font textFont, Color boxColor, Color lineColor, Form form, Action<Notification> onTimerElapsedCallback = null)\n        {\n            _text = text;\n            _boxRect = boxRect;\n            _titleFont = titleFont;\n            _textFont = textFont;\n            _boxColor = boxColor;\n            _lineColor = lineColor;\n            this.form = form;\n\n            _onTimerElapsedCallback = onTimerElapsedCallback;\n\n            _timer = new System.Timers.Timer();\n            _timer.Interval = _timerInterval;\n            _timer.Elapsed += TimerElapsed;\n            _timer.AutoReset = false;\n        }\n", "        public void Show()\n        {\n            _slideStartPos = _boxRect.X - _boxRect.Width;\n            _slideDistance = _boxRect.Width;\n            isShowing = true;\n            _startTime = DateTime.Now;\n            _enterAnimationCompleted = false;\n            _timer.Start();\n        }\n\n        private void TimerElapsed(object sender, ElapsedEventArgs e)\n        {\n            isShowing = false;\n            Expired?.Invoke(this, EventArgs.Empty);\n            _onTimerElapsedCallback?.Invoke(this);\n        }\n", "        private void TimerElapsed(object sender, ElapsedEventArgs e)\n        {\n            isShowing = false;\n            Expired?.Invoke(this, EventArgs.Empty);\n            _onTimerElapsedCallback?.Invoke(this);\n        }\n\n        public void OnDraw(Graphics g)\n        {\n            if (isShowing)\n            {", "            if (isShowing)\n            {\n                if (!_enterAnimationCompleted)\n                {\n                    TimeSpan timeElapsed = DateTime.Now - _startTime;\n                    float progress = (float)Math.Min(1, timeElapsed.TotalMilliseconds / _animationTime);\n\n                    _boxRect.X = (int)(_slideStartPos + _slideDistance * progress);\n                    if (progress >= 1)\n                    {\n                        _enterAnimationCompleted = true;\n                    }\n                }", "                    if (progress >= 1)\n                    {\n                        _enterAnimationCompleted = true;\n                    }\n                }\n                else if (_enterAnimationCompleted && (DateTime.Now - _startTime).TotalMilliseconds >= (_timerInterval - _animationTime) && !_exitAnimationCompleted)\n                {\n                    TimeSpan timeElapsed = DateTime.Now - _startTime - TimeSpan.FromMilliseconds(_timerInterval - _animationTime);\n                    float progress = (float)Math.Min(1, timeElapsed.TotalMilliseconds / _animationTime);\n                    _boxRect.X = (int)(_slideStartPos + _slideDistance * (1 - progress));\n                    if (progress >= .90)\n                    {\n                        _exitAnimationCompleted = true;\n                    }\n                }\n", "                    if (progress >= .90)\n                    {\n                        _exitAnimationCompleted = true;\n                    }\n                }\n\n                using (SolidBrush boxBrush = new SolidBrush(_boxColor))\n                using (SolidBrush lineBrush = new SolidBrush(Color.FromArgb(210, _lineColor)))\n                using (StringFormat format = new StringFormat())\n                {\n                    using (GraphicsPath path = RenderUtil.CustomRoundedRectangle(_boxRect, 0, 8, 8, 0))\n                    {\n                        g.FillPath(boxBrush, path);\n                    }\n\n                    TimeSpan timeElapsed = DateTime.Now - _startTime;\n                    int borderLength = _boxRect.Width - (int)(timeElapsed.TotalMilliseconds / _timerInterval * _boxRect.Width);\n                    g.FillRectangle(lineBrush, _boxRect.X, _boxRect.Y, borderLength, 3);\n\n                    format.Alignment = StringAlignment.Near;\n                    format.LineAlignment = StringAlignment.Near;\n\n                    Rectangle titleRect = new Rectangle(_boxRect.X + 3, _boxRect.Y + 1, _boxRect.Width - 20, _boxRect.Height - 20);\n                    g.DrawString(\"Notification\", _titleFont, Brushes.White, titleRect, format);\n                    Rectangle textRect = new Rectangle(_boxRect.X + 3, _boxRect.Y + 25, _boxRect.Width - 20, _boxRect.Height - 20);\n                    g.DrawString(_text, _textFont, Brushes.White, textRect, format);\n                }\n            }\n        }\n    }\n}", "                using (StringFormat format = new StringFormat())\n                {\n                    using (GraphicsPath path = RenderUtil.CustomRoundedRectangle(_boxRect, 0, 8, 8, 0))\n                    {\n                        g.FillPath(boxBrush, path);\n                    }\n\n                    TimeSpan timeElapsed = DateTime.Now - _startTime;\n                    int borderLength = _boxRect.Width - (int)(timeElapsed.TotalMilliseconds / _timerInterval * _boxRect.Width);\n                    g.FillRectangle(lineBrush, _boxRect.X, _boxRect.Y, borderLength, 3);\n\n                    format.Alignment = StringAlignment.Near;\n                    format.LineAlignment = StringAlignment.Near;\n\n                    Rectangle titleRect = new Rectangle(_boxRect.X + 3, _boxRect.Y + 1, _boxRect.Width - 20, _boxRect.Height - 20);\n                    g.DrawString(\"Notification\", _titleFont, Brushes.White, titleRect, format);\n                    Rectangle textRect = new Rectangle(_boxRect.X + 3, _boxRect.Y + 25, _boxRect.Width - 20, _boxRect.Height - 20);\n                    g.DrawString(_text, _textFont, Brushes.White, textRect, format);\n                }\n            }\n        }\n    }\n}"]}
{"filename": "ClientBase/UI/Notification/NotificationManager.cs", "chunked_list": ["using Client.ClientBase.Fonts;\n\nnamespace Client.ClientBase.UI.Notification\n{\n    public static class NotificationManager\n    {\n        public static Form overlay = null!;\n        public static List<Notification> notifications = new List<Notification>();\n\n        public static void Init(Form form)\n        {\n            overlay = form;\n        }\n", "        public static void Init(Form form)\n        {\n            overlay = form;\n        }\n\n        public static void AddNotification(string text, Color lineColor)\n        {\n            int x = notifications.Count > 0 ? notifications[0]._boxRect.X : 0;\n            int y = notifications.Count > 0 ? notifications[0]._boxRect.Y - notifications[0]._boxRect.Height - 10 : overlay.Height - 10;\n            var notification = new Notification(text, new Rectangle(x, y, 400, 50), new Font(\"Gadugi\", 15, System.Drawing.FontStyle.Bold), new Font(FontRenderer.sigmaFamily, 13, System.Drawing.FontStyle.Regular), Color.FromArgb(150, Color.Black), lineColor, overlay);\n            notifications.Add(notification);\n        }\n", "        public static void UpdateNotifications(Graphics graphics)\n        {\n            int yOffset = overlay.Height - 70;\n\n            foreach (Notification notification in notifications)\n            {\n                if (!notification.isShowing)\n                {\n                    notification._boxRect.Y = yOffset;\n                    notification.Show();\n                }\n\n                notification.OnDraw(graphics);\n\n                notification.Expired += (sender, e) =>\n                {\n                    notifications.Remove(notification);\n                };\n\n                yOffset -= notification._boxRect.Height + 10;\n            }\n        }\n    }\n}"]}
{"filename": "ClientBase/Utils/RenderUtil.cs", "chunked_list": ["using System.Drawing.Drawing2D;\nusing System.Runtime.InteropServices;\nusing Client.ClientBase.Fonts;\n\nnamespace Client.ClientBase.Utils\n{\n    public static class RenderUtil\n    {\n        public static GraphicsPath RoundedRectangle(Rectangle bounds, int radius)\n        {\n            int diameter = radius * 2;\n            Size size = new(diameter, diameter);\n            Rectangle arc = new(bounds.Location, size);\n            GraphicsPath path = new();\n\n            path.AddRectangle(bounds);\n\n            // top left arc  \n            path.AddArc(arc, 180, 90);\n\n            // top right arc  \n            arc.X = bounds.Right - diameter;\n            path.AddArc(arc, 270, 90);\n\n            // bottom right arc  \n            arc.Y = bounds.Bottom - diameter;\n            path.AddArc(arc, 0, 90);\n\n            // bottom left arc \n            arc.X = bounds.Left;\n            path.AddArc(arc, 90, 90);\n\n            path.CloseFigure();\n            return path;\n        }\n", "        public static GraphicsPath RoundedRectangle(Rectangle bounds, int radius)\n        {\n            int diameter = radius * 2;\n            Size size = new(diameter, diameter);\n            Rectangle arc = new(bounds.Location, size);\n            GraphicsPath path = new();\n\n            path.AddRectangle(bounds);\n\n            // top left arc  \n            path.AddArc(arc, 180, 90);\n\n            // top right arc  \n            arc.X = bounds.Right - diameter;\n            path.AddArc(arc, 270, 90);\n\n            // bottom right arc  \n            arc.Y = bounds.Bottom - diameter;\n            path.AddArc(arc, 0, 90);\n\n            // bottom left arc \n            arc.X = bounds.Left;\n            path.AddArc(arc, 90, 90);\n\n            path.CloseFigure();\n            return path;\n        }\n", "        public static GraphicsPath CustomRoundedRectangle(Rectangle bounds, int radius1, int radius2, int radius3, int radius4)\n        {\n            int diameter1 = radius1 * 2;\n            int diameter2 = radius2 * 2;\n            int diameter3 = radius3 * 2;\n            int diameter4 = radius4 * 2;\n\n            Rectangle arc1 = new(bounds.Location, new Size(diameter1, diameter1));\n            Rectangle arc2 = new(bounds.Location, new Size(diameter2, diameter2));\n            Rectangle arc3 = new(bounds.Location, new Size(diameter3, diameter3));\n            Rectangle arc4 = new(bounds.Location, new Size(diameter4, diameter4));\n            GraphicsPath path = new();\n\n            // top left arc  ", "            if (radius1 == 0)\n            {\n                path.AddLine(arc1.Location, arc1.Location);\n            }\n            else\n            {\n                path.AddArc(arc1, 180, 90);\n            }\n\n            // top right arc  \n            arc2.X = bounds.Right - diameter2;", "            if (radius2 == 0)\n            {\n                path.AddLine(arc2.Location, arc2.Location);\n            }\n            else\n            {\n                path.AddArc(arc2, 270, 90);\n            }\n\n            // bottom right arc  \n\n            arc3.X = bounds.Right - diameter3;\n            arc3.Y = bounds.Bottom - diameter3;", "            if (radius3 == 0)\n            {\n                path.AddLine(arc3.Location, arc3.Location);\n            }\n            else\n            {\n                path.AddArc(arc3, 0, 90);\n            }\n\n            // bottom left arc \n            arc4.X = bounds.Right - diameter4;\n            arc4.Y = bounds.Bottom - diameter4;\n            arc4.X = bounds.Left;", "            if (radius4 == 0)\n            {\n                path.AddLine(arc4.Location, arc4.Location);\n            }\n            else\n            {\n                path.AddArc(arc4, 90, 90);\n            }\n\n            path.CloseFigure();\n            return path;\n        }\n", "        public static void RenderDropshadowText(Graphics graphics, string text, Font font, Color foreground, Color shadow, int shadowAlpha, PointF location)\n        {\n            const int DISTANCE = 2;\n            for (int offset = 1; 0 <= offset; offset--)\n            {\n                Color color = ((offset < 1) ?\n                    foreground : Color.FromArgb(shadowAlpha, shadow));\n                using var brush = new SolidBrush(color);\n                var point = new PointF()\n                {\n                    X = location.X + (offset * DISTANCE),\n                    Y = location.Y + (offset * DISTANCE)\n                };\n                graphics.DrawString(text, font, brush, point);\n            }\n        }\n    }\n}"]}
{"filename": "ClientBase/Utils/Mouse.cs", "chunked_list": ["using System.Drawing;\nusing System.Runtime.InteropServices;\n\n\nnamespace Client.ClientBase.Utils\n{\n    public static partial class Mouse\n    {\n        [DllImport(\"user32.dll\")]\n        private static extern void mouse_event(uint dwFlags, int dx, int dy, uint dwData, int dwExtraInfo);\n\n        [DllImport(\"user32.dll\")]", "        private static extern void mouse_event(uint dwFlags, int dx, int dy, uint dwData, int dwExtraInfo);\n\n        [DllImport(\"user32.dll\")]\n        private static extern bool SetCursorPos(int X, int Y);\n\n        public const int MOUSEEVENTF_LEFTDOWN = 0x02;\n        public const int MOUSEEVENTF_LEFTUP = 0x04;\n\n        public static void LeftClick()\n        {\n            mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);\n        }\n", "        public static void LeftClick()\n        {\n            mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);\n        }\n\n        public static void CustomSetCursorPosition(int x, int y)\n        {\n            SetCursorPos(x, y);\n        }\n    }\n}"]}
{"filename": "ClientBase/Utils/Screen.cs", "chunked_list": ["using System;\nusing System.Drawing;\nusing System.Windows.Forms;\nusing System.Windows.Media.Imaging;\nusing System.IO;\nusing System.Text;\nusing System.Drawing.Imaging;\nusing System.Runtime.InteropServices;\n\nnamespace Client.ClientBase.Utils", "\nnamespace Client.ClientBase.Utils\n{\n    public static class Screen\n    {\n        public static Point FindText(string searchText)\n        {\n            Rectangle screenBounds = new(0, 0, 1920, 1080);\n\n            Bitmap screenshot = new(screenBounds.Width, screenBounds.Height);\n            Graphics graphics = Graphics.FromImage(screenshot);\n            graphics.CopyFromScreen(screenBounds.X, screenBounds.Y, 0, 0, screenBounds.Size);\n", "            for (int x = 0; x < screenshot.Width; x++)\n            {\n                for (int y = 0; y < screenshot.Height; y++)\n                {\n                    if (screenshot.GetPixel(x, y).ToArgb() == Color.Black.ToArgb())\n                    {\n                        bool found = true;\n                        for (int i = 1; i < searchText.Length; i++)\n                        {\n                            if (x + i >= screenshot.Width || screenshot.GetPixel(x + i, y).ToArgb() != Color.Black.ToArgb())\n                            {\n                                found = false;\n                                break;\n                            }\n                        }", "                            if (x + i >= screenshot.Width || screenshot.GetPixel(x + i, y).ToArgb() != Color.Black.ToArgb())\n                            {\n                                found = false;\n                                break;\n                            }\n                        }\n                        if (found)\n                        {\n                            return new Point(x, y);\n                        }\n                    }\n                }\n            }\n            return Point.Empty;\n        }\n", "        public static Point[] FindPixels(Rectangle rect, Color pixelColor, int shadeVariation)\n        {\n            List<Point> points = new();\n\n            using (Bitmap regionInBitmap = new(rect.Width, rect.Height, PixelFormat.Format24bppRgb))\n            {\n                using (Graphics graphics = Graphics.FromImage(regionInBitmap))\n                {\n                    graphics.CopyFromScreen(rect.X, rect.Y, 0, 0, rect.Size, CopyPixelOperation.SourceCopy);\n                }\n\n                BitmapData bitmapData = regionInBitmap.LockBits(new Rectangle(0, 0, regionInBitmap.Width, regionInBitmap.Height), ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);\n\n                int[] formattedColor = new int[] { pixelColor.B, pixelColor.G, pixelColor.R };\n                IntPtr scan0 = bitmapData.Scan0;\n                int stride = bitmapData.Stride;\n", "                for (int y = 0; y < bitmapData.Height; y++)\n                {\n                    for (int x = 0; x < bitmapData.Width; x++)\n                    {\n                        int offset = (y * stride) + (x * 3);\n                        byte blue = Marshal.ReadByte(scan0, offset);\n                        byte green = Marshal.ReadByte(scan0, offset + 1);\n                        byte red = Marshal.ReadByte(scan0, offset + 2);\n\n                        if (blue >= (formattedColor[0] - shadeVariation) && blue <= (formattedColor[0] + shadeVariation) &&\n                            green >= (formattedColor[1] - shadeVariation) && green <= (formattedColor[1] + shadeVariation) &&\n                            red >= (formattedColor[2] - shadeVariation) && red <= (formattedColor[2] + shadeVariation))\n                        {\n                            Point point = new(rect.X + x, rect.Y + y - 8);\n                            points.Add(point);\n                        }\n                    }\n                }\n\n                regionInBitmap.UnlockBits(bitmapData);\n            }\n\n            return points.ToArray();\n        }\n    }\n}", "                        if (blue >= (formattedColor[0] - shadeVariation) && blue <= (formattedColor[0] + shadeVariation) &&\n                            green >= (formattedColor[1] - shadeVariation) && green <= (formattedColor[1] + shadeVariation) &&\n                            red >= (formattedColor[2] - shadeVariation) && red <= (formattedColor[2] + shadeVariation))\n                        {\n                            Point point = new(rect.X + x, rect.Y + y - 8);\n                            points.Add(point);\n                        }\n                    }\n                }\n\n                regionInBitmap.UnlockBits(bitmapData);\n            }\n\n            return points.ToArray();\n        }\n    }\n}"]}
{"filename": "ClientBase/Utils/Keymap.cs", "chunked_list": ["using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\n\nnamespace Client.ClientBase.Utils\n{\n    static class Keymap\n    {\n        public delegate void KeyPressedEventHandler(char key);\n        public static event KeyPressedEventHandler KeyPressed;\n", "        public delegate void KeyPressedEventHandler(char key);\n        public static event KeyPressedEventHandler KeyPressed;\n\n        private static readonly LowLevelKeyboardProc _proc = HookCallback;\n        private static IntPtr _hookID = IntPtr.Zero;\n\n        public static void StartListening()\n        {\n            _hookID = SetHook(_proc);\n        }\n", "        public static void StopListening()\n        {\n            UnhookWindowsHookEx(_hookID);\n        }\n\n        private static IntPtr SetHook(LowLevelKeyboardProc proc)\n        {\n            using (Process curProcess = Process.GetCurrentProcess())\n            using (ProcessModule curModule = curProcess.MainModule)\n            {\n                return SetWindowsHookEx(13, proc, GetModuleHandle(curModule.ModuleName), 0);\n            }\n        }\n", "            using (ProcessModule curModule = curProcess.MainModule)\n            {\n                return SetWindowsHookEx(13, proc, GetModuleHandle(curModule.ModuleName), 0);\n            }\n        }\n\n        private delegate IntPtr LowLevelKeyboardProc(int nCode, IntPtr wParam, IntPtr lParam);\n\n        private static IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam)\n        {\n            if (nCode >= 0 && wParam == (IntPtr)WM_KEYDOWN)\n            {\n                int vkCode = Marshal.ReadInt32(lParam);\n                char key = Convert.ToChar(vkCode);\n\n                KeyPressed?.Invoke(key);\n            }\n\n            return CallNextHookEx(_hookID, nCode, wParam, lParam);\n        }\n", "        private static IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam)\n        {\n            if (nCode >= 0 && wParam == (IntPtr)WM_KEYDOWN)\n            {\n                int vkCode = Marshal.ReadInt32(lParam);\n                char key = Convert.ToChar(vkCode);\n\n                KeyPressed?.Invoke(key);\n            }\n\n            return CallNextHookEx(_hookID, nCode, wParam, lParam);\n        }\n", "        private const int WM_KEYDOWN = 0x0100;\n\n        [DllImport(\"user32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n        private static extern IntPtr SetWindowsHookEx(int idHook, LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);\n\n        [DllImport(\"user32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        private static extern bool UnhookWindowsHookEx(IntPtr hhk);\n\n        [DllImport(\"user32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n        private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, IntPtr wParam, IntPtr lParam);\n\n        [DllImport(\"kernel32.dll\", CharSet = CharSet.Auto, SetLastError = true)]", "        private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, IntPtr wParam, IntPtr lParam);\n\n        [DllImport(\"kernel32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n        private static extern IntPtr GetModuleHandle(string lpModuleName);\n    }\n}"]}
{"filename": "ClientBase/Fonts/FontRenderer.cs", "chunked_list": ["using System.Drawing.Text;\nusing System.IO;\nusing Client.ClientBase.Utils;\n\nnamespace Client.ClientBase.Fonts\n{\n    public static class FontRenderer\n    {\n        public static FontFamily comfortaaFamily = FontFamily.GenericSerif;\n        public static FontFamily sigmaFamily = FontFamily.GenericSerif;\n", "        public static FontFamily comfortaaFamily = FontFamily.GenericSerif;\n        public static FontFamily sigmaFamily = FontFamily.GenericSerif;\n\n        public static void Init()\n        {\n            Console.WriteLine(\"Loading fonts...\");\n            PrivateFontCollection fontCollection = new PrivateFontCollection();\n\n            foreach (string filePath in Directory.GetFiles(Program.fontPath, \"*.ttf\"))\n            {\n                fontCollection.AddFontFile(filePath);\n            }\n\n            FontFamily comfortaaFamily = fontCollection.Families.FirstOrDefault(f => f.Name == \"Comfortaa\");\n            FontFamily sigmaFamily = fontCollection.Families.FirstOrDefault(f => f.Name == \"SF UI Display\");\n\n            FontRenderer.comfortaaFamily = comfortaaFamily;\n            FontRenderer.sigmaFamily = sigmaFamily;\n\n            Console.WriteLine(\"Fonts loaded.\");\n        }\n    }\n}\n", "            foreach (string filePath in Directory.GetFiles(Program.fontPath, \"*.ttf\"))\n            {\n                fontCollection.AddFontFile(filePath);\n            }\n\n            FontFamily comfortaaFamily = fontCollection.Families.FirstOrDefault(f => f.Name == \"Comfortaa\");\n            FontFamily sigmaFamily = fontCollection.Families.FirstOrDefault(f => f.Name == \"SF UI Display\");\n\n            FontRenderer.comfortaaFamily = comfortaaFamily;\n            FontRenderer.sigmaFamily = sigmaFamily;\n\n            Console.WriteLine(\"Fonts loaded.\");\n        }\n    }\n}\n"]}
{"filename": "ClientBase/Modules/AimAssist.cs", "chunked_list": ["using System.Collections;\nusing System.Drawing.Imaging;\nusing System.Numerics;\nusing System.Runtime.InteropServices;\n\nnamespace Client.ClientBase.Modules\n{\n    public class AimAssist : Module\n    {\n\n        const int heightOffset = -7; //height offset\n        const int shotKnockback = 1; //shot knockback", "        public static bool autokill = false; //triggerbot\n        public static bool is_aiming = false; //aiming\n        const float speed = .25f; //0.35 slow\n        const int msBetweenShots = 350;\n        // COLOR\n        const int color = 0xc60912;//0xc60912 for shatterline; 0xf94f54 for valorant;\n        const int colorVariation = 15; //15 for shatterline, 50 for valorant\n\n        const double size = 75;  // DONT CHANGE\n        const int maxCount = 3;\n", "        public static System.DateTime last_aim = System.DateTime.Now; //aiming\n\n        public AimAssist() : base(\"AimAssist\", (char)0x4B, \"Combat\", \"Finds the closest entity and aims at it\", true) //0x4B = K\n        {\n        }\n\n        public override void OnTick()\n        {\n            // Console.WriteLine(\"[DEBUG] AimAssist.cs: OnTick()\");\n            System.DateTime lastshot = System.DateTime.Now;\n\n            Task.Delay(1); // ANTI CRASH\n", "            if (GetAsyncKeyState(0x02) != 0)\n            {\n                Rectangle rect = new Rectangle((Program.xSize - Program.maxX) / 2, (Program.ySize - Program.maxY) / 2, Program.maxX, Program.maxY);\n\n                var l = Client.ClientBase.Utils.Screen.FindPixels(rect, Color.FromArgb(color), colorVariation);\n\n                if (l.Length > 0)\n                {\n                    var q = l.OrderBy(t => t.Y).ToArray();\n\n                    List<Vector2> forbidden = new List<Vector2>();\n", "                    for (int i = 0; i < q.Length; i++)\n                    {\n                        Vector2 current = new Vector2(q[i].X, q[i].Y);\n                        if (forbidden.Where(t => (t - current).Length() < size || Math.Abs(t.X - current.X) < size).Count() < 1)\n                        {\n                            forbidden.Add(current);\n                            if (forbidden.Count > maxCount)\n                            {\n                                break;\n                            }\n                        }\n                    }\n\n                    var closes = forbidden.Select(t => (t - new Vector2(Program.xSize / 2, Program.ySize / 2))).OrderBy(t => t.Length()).ElementAt(0) + new Vector2(3, -3);\n\n                    Move((int)(closes.X * (speed)), (int)((closes.Y * (speed)) + 2));\n                }\n            }\n        }\n\n        [DllImport(\"user32.dll\")]\n        static extern void mouse_event(int dwFlags, int dx, int dy, uint dwData, UIntPtr dwExtraInfo);\n\n        [DllImport(\"user32.dll\")]\n        static extern short GetAsyncKeyState(int vKey);\n", "        public static void Move(int xDelta, int yDelta)\n        {\n            mouse_event(0x0001, xDelta, yDelta + shotKnockback, 0, UIntPtr.Zero);\n        }\n    }\n}"]}
{"filename": "ClientBase/Modules/ClickGUI.cs", "chunked_list": ["using System;\nusing System.Linq;\nusing System.Windows.Forms;\n\nnamespace Client.ClientBase.Modules\n{\n    public class ModuleList : VisualModule\n    {\n        private bool uiVisible = false;\n        private Point uiPosition = new Point(10, 10);\n        private Font uiFont = new Font(FontFamily.GenericSansSerif, 15);\n\n        public ModuleList() : base(\"ModuleList\", (char)0x2D, \"UI\", \"Displays a list of all modules\", false)\n        {\n        }\n", "        private bool uiVisible = false;\n        private Point uiPosition = new Point(10, 10);\n        private Font uiFont = new Font(FontFamily.GenericSansSerif, 15);\n\n        public ModuleList() : base(\"ModuleList\", (char)0x2D, \"UI\", \"Displays a list of all modules\", false)\n        {\n        }\n\n        public override void OnDraw(Graphics graphics)\n        {\n            var modules = ModuleManager.GetModules().OrderByDescending(x => x.name.Length).ThenBy(x => x.name);\n            var maxCategoryWidth = (int)Math.Ceiling(modules.Max(x => graphics.MeasureString(x.category, uiFont).Width));\n            var maxModuleWidth = (int)Math.Ceiling(modules.Max(x => graphics.MeasureString($\"[{x.keybind}] {x.name}\", uiFont).Width));\n\n            var x = uiPosition.X;\n            var y = uiPosition.Y;\n", "        public override void OnDraw(Graphics graphics)\n        {\n            var modules = ModuleManager.GetModules().OrderByDescending(x => x.name.Length).ThenBy(x => x.name);\n            var maxCategoryWidth = (int)Math.Ceiling(modules.Max(x => graphics.MeasureString(x.category, uiFont).Width));\n            var maxModuleWidth = (int)Math.Ceiling(modules.Max(x => graphics.MeasureString($\"[{x.keybind}] {x.name}\", uiFont).Width));\n\n            var x = uiPosition.X;\n            var y = uiPosition.Y;\n\n            foreach (var group in modules.GroupBy(x => x.category).OrderBy(x => x.Key))\n            {\n                string category = group.Key;\n                var moduleCount = group.Count();\n\n                var categoryHeight = (int)Math.Ceiling(graphics.MeasureString(category, uiFont).Height);\n                var moduleHeight = (int)Math.Ceiling(graphics.MeasureString($\"[{group.First().keybind}] {group.First().name}\", uiFont).Height);\n                var blockPadding = 5;\n                var blockWidth = maxModuleWidth + (2 * blockPadding);\n                var blockHeight = categoryHeight + (moduleHeight * moduleCount) + (blockPadding * (moduleCount + 1));\n\n                graphics.FillRectangle(Brushes.Gray, new Rectangle(x, y, blockWidth, blockHeight));\n                graphics.DrawString(category, uiFont, Brushes.White, new PointF(x + blockPadding, y + blockPadding));\n                var moduleY = y + categoryHeight + (blockPadding * 2);", "            foreach (var group in modules.GroupBy(x => x.category).OrderBy(x => x.Key))\n            {\n                string category = group.Key;\n                var moduleCount = group.Count();\n\n                var categoryHeight = (int)Math.Ceiling(graphics.MeasureString(category, uiFont).Height);\n                var moduleHeight = (int)Math.Ceiling(graphics.MeasureString($\"[{group.First().keybind}] {group.First().name}\", uiFont).Height);\n                var blockPadding = 5;\n                var blockWidth = maxModuleWidth + (2 * blockPadding);\n                var blockHeight = categoryHeight + (moduleHeight * moduleCount) + (blockPadding * (moduleCount + 1));\n\n                graphics.FillRectangle(Brushes.Gray, new Rectangle(x, y, blockWidth, blockHeight));\n                graphics.DrawString(category, uiFont, Brushes.White, new PointF(x + blockPadding, y + blockPadding));\n                var moduleY = y + categoryHeight + (blockPadding * 2);", "                foreach (var module in group)\n                {\n                    string name = $\"[{module.keybind}] {module.name}\";\n                    graphics.DrawString(name, uiFont, Brushes.White, new PointF(x + blockPadding, moduleY));\n                    moduleY += moduleHeight + blockPadding;\n                }\n\n                x += blockWidth + blockPadding;\n            }\n        }\n    }\n}"]}
{"filename": "ClientBase/Modules/Aura.cs", "chunked_list": ["using System.Collections;\nusing System.Drawing.Imaging;\nusing System.Numerics;\nusing System.Runtime.InteropServices;\n\nnamespace Client.ClientBase.Modules\n{\n    public class Aura : Module\n    {\n\n        const int heightOffset = 7;\n        const int shotKnockback = 1;", "        public static bool is_aiming = false;\n        const float speed = 0.5f;\n        const int msBetweenShots = 350;\n        // COLOR\n        const int color = 0xc60912;\n        const int colorVariation = 10;\n\n        const double size = 75;\n        const int maxCount = 3;\n        public static bool is_shooting = false;\n        public static System.DateTime last_aim = System.DateTime.Now;", "        public static bool is_shooting = false;\n        public static System.DateTime last_aim = System.DateTime.Now;\n        public readonly Pen _pen = new Pen(Color.Green, 3);\n        public static Vector2 lastTargetPosition = Vector2.Zero;\n        public static bool foundLastTarget = false;\n\n        public Aura() : base(\"Aura\", (char)0x4C, \"Combat\", \"Finds the closest entity and aims and shoots at it\", true) //0x4C = L\n        {\n        }\n\n        public override void OnTick()\n        {\n            DateTime lastshot = DateTime.UtcNow;\n            Rectangle rect = new((Program.xSize) / 4, (Program.ySize - Program.maxY) / 2, Program.xSize / 2, 80);\n            var l = Client.ClientBase.Utils.Screen.FindPixels(rect, Color.FromArgb(color), colorVariation);\n", "        public override void OnTick()\n        {\n            DateTime lastshot = DateTime.UtcNow;\n            Rectangle rect = new((Program.xSize) / 4, (Program.ySize - Program.maxY) / 2, Program.xSize / 2, 80);\n            var l = Client.ClientBase.Utils.Screen.FindPixels(rect, Color.FromArgb(color), colorVariation);\n\n            if (l.Length > 0)\n            {\n                var q = l.OrderBy(t => t.Y).ToArray();\n                List<Vector2> forbidden = new();\n", "                for (int i = 0; i < q.Length; i++)\n                {\n                    Vector2 current = new(q[i].X, q[i].Y);\n                    if (!forbidden.Any(t => (t - current).Length() < size || Math.Abs(t.X - current.X) < size))\n                    {\n                        forbidden.Add(current);\n                        if (forbidden.Count > maxCount)\n                        {\n                            break;\n                        }\n                    }\n                }\n\n                Vector2 currentTargetPosition = Vector2.Zero;", "                if (foundLastTarget)\n                {\n                    float closestDist = float.MaxValue;\n                    foreach (var target in forbidden)\n                    {\n                        float dist = (target - lastTargetPosition).Length();\n                        if (dist < closestDist)\n                        {\n                            closestDist = dist;\n                            currentTargetPosition = target;\n                        }\n                    }\n                }\n                else\n                {\n                    currentTargetPosition = forbidden[0];\n                    foundLastTarget = true;\n                }\n\n                var delta = currentTargetPosition - new Vector2(Program.xSize / 2, Program.ySize / 2);\n                Move((int)(delta.X * speed), (int)((delta.Y * speed) + 1));\n                aimIn();\n                lastTargetPosition = currentTargetPosition;\n", "                if (!is_shooting)\n                {\n                    mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, UIntPtr.Zero);\n                    is_shooting = true;\n                }\n            }\n            else\n            {\n                aimOut();\n                if (is_shooting)\n                {\n                    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, UIntPtr.Zero);\n                    is_shooting = false;\n                }\n                foundLastTarget = false;\n            }\n        }\n\n", "                if (is_shooting)\n                {\n                    mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, UIntPtr.Zero);\n                    is_shooting = false;\n                }\n                foundLastTarget = false;\n            }\n        }\n\n\n        public static void aimIn()\n        {", "        public static void aimIn()\n        {\n            if (!is_aiming)\n            {\n                mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, UIntPtr.Zero);\n                is_aiming = true;\n                last_aim = System.DateTime.Now;\n            }\n        }\n\n        public static void aimOut()\n        {", "        public static void aimOut()\n        {\n            if (DateTime.Now.Subtract(last_aim).TotalMilliseconds < 500)\n            {\n                return;\n            }\n\n            if (is_aiming)\n            {\n                mouse_event(MOUSEEVENTF_RIGHTUP, 0, 0, 0, UIntPtr.Zero);\n                is_aiming = false;\n            }\n        }\n\n        [DllImport(\"user32.dll\")]\n        static extern void mouse_event(int dwFlags, int dx, int dy, uint dwData, UIntPtr dwExtraInfo);\n\n        [DllImport(\"user32.dll\")]\n        static extern short GetAsyncKeyState(int vKey);\n", "        public static void Move(int xDelta, int yDelta)\n        {\n            mouse_event(0x0001, xDelta, yDelta + shotKnockback, 0, UIntPtr.Zero);\n        }\n\n        private const int MOUSEEVENTF_LEFTDOWN = 0x02;\n        private const int MOUSEEVENTF_LEFTUP = 0x04;\n        private const int MOUSEEVENTF_RIGHTDOWN = 0x08;\n        private const int MOUSEEVENTF_RIGHTUP = 0x10;\n    }\n}", "        private const int MOUSEEVENTF_RIGHTUP = 0x10;\n    }\n}"]}
{"filename": "ClientBase/Modules/ArrayList.cs", "chunked_list": ["using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Linq;\nusing System.Windows.Forms;\nusing Client.ClientBase.Fonts;\nusing Client.ClientBase.Utils;\n\nnamespace Client.ClientBase.Modules", "\nnamespace Client.ClientBase.Modules\n{\n    public class ArrayList : VisualModule\n    {\n        private Point uiPosition = new Point(0, 0);\n        private readonly Font uiFont = new Font(FontRenderer.sigmaFamily, 16);\n        private List<string> lastModuleNames = new List<string>();\n        private readonly Dictionary<string, float> modulePositions = new Dictionary<string, float>();\n\n        public ArrayList() : base(\"ArrayList\", (char)0x2D, \"UI\", \"Shows all enabled modules from longest name to shortest\", false) // 0x2D = INSERT\n        {\n        }\n", "        private readonly Dictionary<string, float> modulePositions = new Dictionary<string, float>();\n\n        public ArrayList() : base(\"ArrayList\", (char)0x2D, \"UI\", \"Shows all enabled modules from longest name to shortest\", false) // 0x2D = INSERT\n        {\n        }\n\n        public override void OnDraw(Graphics graphics)\n        {\n            List<Module> enabledModules = ModuleManager.GetEnabledModules();\n            List<string> moduleNames = enabledModules.Select(m => m.name).OrderByDescending(n => n.Length).ToList();\n\n            int lineHeight = (int)graphics.MeasureString(\"M\", uiFont).Height;\n            int maxWidth = 0;", "            foreach (string moduleName in moduleNames)\n            {\n                int width = (int)graphics.MeasureString(moduleName, uiFont).Width + 10;\n                if (width > maxWidth) maxWidth = width;\n            }\n\n            float uiXPosition = Program.xSize - maxWidth - 10;\n            float uiYPosition = uiPosition.Y + 10;\n\n            foreach (string moduleName in moduleNames)\n            {\n                int width = (int)graphics.MeasureString(moduleName, uiFont).Width + 10;\n                RectangleF textBoxRect = new RectangleF(uiXPosition + maxWidth - width, uiYPosition, width, lineHeight);\n\n                bool isNewModule = !lastModuleNames.Contains(moduleName);", "            foreach (string moduleName in moduleNames)\n            {\n                int width = (int)graphics.MeasureString(moduleName, uiFont).Width + 10;\n                RectangleF textBoxRect = new RectangleF(uiXPosition + maxWidth - width, uiYPosition, width, lineHeight);\n\n                bool isNewModule = !lastModuleNames.Contains(moduleName);\n                if (isNewModule)\n                {\n                    modulePositions.Add(moduleName, Program.xSize);\n                }\n", "                if (modulePositions.TryGetValue(moduleName, out float xPosition))\n                {\n                    float targetXPosition = uiXPosition + maxWidth - width;\n                    float delta = targetXPosition - xPosition;\n                    if (Math.Abs(delta) > 0.1)\n                    {\n                        xPosition += delta * 0.2f;\n                        modulePositions[moduleName] = xPosition;\n                        textBoxRect.X = xPosition;\n                    }\n                    else\n                    {\n                        modulePositions.Remove(moduleName);\n                    }\n                }\n\n                RectangleF gradientRect = new(textBoxRect.Right, textBoxRect.Top + 1, 3, textBoxRect.Height - 2);", "                using (LinearGradientBrush gradientBrush = new(gradientRect, Color.FromArgb(150, 122, 183, 255), Color.FromArgb(122, 183, 255), LinearGradientMode.Vertical))\n                {\n                    graphics.FillRectangle(gradientBrush, gradientRect);\n                }\n\n                Rectangle textBoxRect2 = new(\n                    (int)textBoxRect.X,\n                    (int)textBoxRect.Y,\n                    (int)textBoxRect.Width,\n                    (int)textBoxRect.Height\n                );\n", "                using (GraphicsPath path = RenderUtil.CustomRoundedRectangle(textBoxRect2, 2, 0, 0, 4))\n                {\n                    graphics.FillPath(new SolidBrush(Color.FromArgb(100, 0, 0, 0)), path);\n                }\n\n\n                graphics.DrawString(moduleName, uiFont, new SolidBrush(Color.White), textBoxRect, new StringFormat() { Alignment = StringAlignment.Center, LineAlignment = StringAlignment.Center });\n                uiYPosition += lineHeight;\n            }\n\n            lastModuleNames = moduleNames;\n        }\n    }\n}"]}
