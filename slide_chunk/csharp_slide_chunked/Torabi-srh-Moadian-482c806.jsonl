{"filename": "Moadian.cs", "chunked_list": ["\ufeffusing Moadian.API;\nusing Moadian.Dto;\nusing Moadian.Services;\nusing Newtonsoft.Json.Linq;\n\nnamespace Moadian\n{\n    public class Moadian\n    {\n        private TokenModel token;\n        protected readonly string publicKey;", "        private TokenModel token;\n        protected readonly string publicKey;\n        protected readonly string privateKey;\n        protected readonly string orgKeyId;\n        protected readonly string username;\n        protected readonly string baseURL;\n        protected readonly HttpClientService httpClient;\n\n        public Moadian(string publicKey, string privateKey, string orgKeyId, string username, string baseURL = \"https://tp.tax.gov.ir\")\n        {\n            this.PublicKey = publicKey;\n            this.PrivateKey = privateKey;\n            this.OrgKeyId = orgKeyId;\n            this.Username = username;\n            this.BaseURL = baseURL;\n\n            var signatureService = new SignatureService(PrivateKey);\n            var encryptionService = new EncryptionService(publicKey, orgKeyId);\n            this.httpClient = new HttpClientService(signatureService, encryptionService, baseURL);\n        }\n", "        public string PublicKey { get; }\n        public string PrivateKey { get; }\n        public string OrgKeyId { get; }\n        public string Username { get; }\n        public string BaseURL { get; }\n        public Moadian SetToken(TokenModel token)\n        {\n            this.token = token;\n\n            return this;\n        }\n", "        public async Task<object> SendInvoice(Packet packet)\n        {\n            if (this.token == null)\n            {\n                throw new ArgumentException(\"Set token before sending invoice!\");\n            }\n\n            var headers = new Dictionary<string, string>\n            {\n                { \"Authorization\", \"Bearer \" + this.token.Token },\n                { \"requestTraceId\", Guid.NewGuid().ToString() },\n                { \"timestamp\", DateTimeOffset.Now.ToUnixTimeMilliseconds().ToString() },\n            };\n\n            var path = \"req/api/self-tsp/async/normal-enqueue\";\n            var response = await httpClient.SendPackets(path, new List<Packet>() { packet }, headers, true, true);\n\n            return response;\n        }\n", "        public async Task<TokenModel> GetToken()\n        {\n            var api = new Api(this.Username, httpClient);\n\n            var token = await api.GetToken();\n\n            return token;\n        }\n\n        public string GenerateTaxId(DateTime invoiceCreatedAt, int internalInvoiceId)\n        {\n            var invoiceIdService = new InvoiceIdService(this.Username);\n\n            return invoiceIdService.GenerateInvoiceId(invoiceCreatedAt, internalInvoiceId);\n        }\n", "        public string GenerateTaxId(DateTime invoiceCreatedAt, int internalInvoiceId)\n        {\n            var invoiceIdService = new InvoiceIdService(this.Username);\n\n            return invoiceIdService.GenerateInvoiceId(invoiceCreatedAt, internalInvoiceId);\n        }\n\n        public async Task<dynamic> InquiryByReferenceNumber(string referenceNumber)\n        {\n            var api = new Api(this.Username, httpClient);\n\n            api.SetToken(this.token);\n\n            var response = await api.InquiryByReferenceNumber(referenceNumber);\n\n            return response;\n        }\n", "        public async Task<dynamic> GetEconomicCodeInformation(string taxID)\n        {\n            var api = new Api(this.Username, httpClient);\n\n            api.SetToken(this.token);\n\n            var response = await api.GetEconomicCodeInformation(taxID);\n\n            return response;\n        }\n", "        public object GetFiscalInfo()\n        {\n            var api = new Api(this.username, httpClient);\n            api.SetToken(this.token);\n            return api.GetFiscalInfo();\n        }\n\n    }\n}"]}
{"filename": "API/API.cs", "chunked_list": ["\ufeffusing Moadian.Dto;\nusing Moadian.Services;\nusing Newtonsoft.Json;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading.Tasks;\n", "using System.Threading.Tasks;\n\nnamespace Moadian.API\n{\n    public class Api\n    {\n        private TokenModel? token = null;\n        private readonly string username;\n        private readonly HttpClientService httpClient;\n\n        public Api(string username, HttpClientService httpClient)\n        {\n            this.username = username;\n            this.httpClient = httpClient;\n        }\n", "        private readonly HttpClientService httpClient;\n\n        public Api(string username, HttpClientService httpClient)\n        {\n            this.username = username;\n            this.httpClient = httpClient;\n        }\n\n        public async Task<TokenModel> GetToken()\n        {\n            var getTokenDto = new GetTokenDto() { username = this.username };\n            var packet = new Packet(Constants.PacketType.GET_TOKEN, getTokenDto);\n\n            packet.retry = false;\n            packet.fiscalId = this.username;\n\n            var headers = GetEssentialHeaders();\n\n            var response = await this.httpClient.SendPacket(\"req/api/self-tsp/sync/GET_TOKEN\", packet, headers);\n            return null;\n            //var tokenData = response[\"result\"][\"data\"];\n            //return new TokenModel(tokenData[\"token\"], tokenData[\"expiresIn\"]);\n        }\n", "        public async Task<TokenModel> GetToken()\n        {\n            var getTokenDto = new GetTokenDto() { username = this.username };\n            var packet = new Packet(Constants.PacketType.GET_TOKEN, getTokenDto);\n\n            packet.retry = false;\n            packet.fiscalId = this.username;\n\n            var headers = GetEssentialHeaders();\n\n            var response = await this.httpClient.SendPacket(\"req/api/self-tsp/sync/GET_TOKEN\", packet, headers);\n            return null;\n            //var tokenData = response[\"result\"][\"data\"];\n            //return new TokenModel(tokenData[\"token\"], tokenData[\"expiresIn\"]);\n        }\n", "        public async Task<dynamic> InquiryByReferenceNumberAsync(string referenceNumber)\n        {\n            var inquiryByReferenceNumberDto = new InquiryByReferenceNumberDto();\n            inquiryByReferenceNumberDto.SetReferenceNumber(referenceNumber);\n\n            var packet = new Packet(Constants.PacketType.PACKET_TYPE_INQUIRY_BY_REFERENCE_NUMBER, inquiryByReferenceNumberDto);\n\n            packet.retry = false;\n            packet.fiscalId = this.username;\n\n            var headers = GetEssentialHeaders();\n            headers[\"Authorization\"] = \"Bearer \" + this.token?.Token;\n\n            var path = \"req/api/self-tsp/sync/\" + Constants.PacketType.PACKET_TYPE_INQUIRY_BY_REFERENCE_NUMBER;\n\n            return await this.httpClient.SendPacket(path, packet, headers);\n        }\n", "        public async Task<dynamic> GetEconomicCodeInformationAsync(string taxID)\n        {\n            RequireToken();\n\n            var packet = new Packet(Constants.PacketType.GET_ECONOMIC_CODE_INFORMATION, JsonConvert.SerializeObject(new { economicCode = taxID }));\n\n            packet.retry = false;\n            packet.fiscalId = this.username;\n\n            var headers = GetEssentialHeaders();\n            headers[\"Authorization\"] = \"Bearer \" + this.token?.Token;\n\n            var path = \"req/api/self-tsp/sync/\" + Constants.PacketType.GET_ECONOMIC_CODE_INFORMATION;\n\n            return await this.httpClient.SendPacket(path, packet, headers);\n        }\n", "        public async Task<dynamic> SendInvoicesAsync(List<object> invoiceDtos)\n        {\n            var packets = new List<Packet>();\n\n            foreach (var invoiceDto in invoiceDtos)\n            {\n                var packet = new Packet(Constants.PacketType.INVOICE_V01, invoiceDto);\n                packet.uid = \"AAA\";\n                packets.Add(packet);\n            }\n\n            var headers = GetEssentialHeaders();\n\n            headers[Constants.TransferConstants.AUTHORIZATION_HEADER] = this.token?.Token;\n\n            dynamic res = null;\n            try\n            {\n                res = await this.httpClient.SendPackets(\"req/api/self-tsp/async/normal-enqueue\", packets, headers, true, true);\n            }", "            catch (Exception e)\n            {\n            }\n\n            return res?.GetBody().GetContents();\n        }\n\n        public async Task<dynamic> GetFiscalInfoAsync()\n        {\n            RequireToken();\n\n            var packet = new Packet(Constants.PacketType.GET_FISCAL_INFORMATION, this.username);\n\n            var headers = GetEssentialHeaders();\n\n            headers[\"Authorization\"] = \"Bearer \" + this.token?.Token;\n\n            return await this.httpClient.SendPacket(\"req/api/self-tsp/sync/GET_FISCAL_INFORMATION\", packet, headers);\n        }\n", "        public Api SetToken(TokenModel? token)\n        {\n            this.token = token;\n            return this;\n        }\n        public dynamic InquiryByReferenceNumber(string referenceNumber)\n        {\n            var inquiryByReferenceNumberDto = new InquiryByReferenceNumberDto();\n            inquiryByReferenceNumberDto.SetReferenceNumber(referenceNumber);\n\n            var packet = new Packet(Constants.PacketType.PACKET_TYPE_INQUIRY_BY_REFERENCE_NUMBER, inquiryByReferenceNumberDto);\n\n            packet.retry = false;\n            packet.fiscalId = this.username;\n            var headers = GetEssentialHeaders();\n            headers[\"Authorization\"] = \"Bearer \" + this.token.Token;\n\n            var path = \"req/api/self-tsp/sync/\" + Constants.PacketType.PACKET_TYPE_INQUIRY_BY_REFERENCE_NUMBER;\n\n            return this.httpClient.SendPacket(path, packet, headers);\n        }\n", "        public dynamic GetEconomicCodeInformation(string taxId)\n        {\n            RequireToken();\n\n            var packet = new Packet(Constants.PacketType.GET_ECONOMIC_CODE_INFORMATION, JsonConvert.SerializeObject(new { EconomicCode = taxId }));\n\n            packet.retry = false;\n            packet.fiscalId = this.username;\n            var headers = GetEssentialHeaders();\n            headers[\"Authorization\"] = \"Bearer \" + this.token.Token;\n\n            var path = \"req/api/self-tsp/sync/\" + Constants.PacketType.GET_ECONOMIC_CODE_INFORMATION;\n\n            return this.httpClient.SendPacket(path, packet, headers);\n        }\n", "        public dynamic SendInvoices(List<InvoiceDto> invoiceDtos)\n        {\n            var packets = new List<Packet>();\n\n            foreach (var invoiceDto in invoiceDtos)\n            {\n                var packet = new Packet(Constants.PacketType.INVOICE_V01, invoiceDto);\n                packet.uid = \"AAA\";\n                packets.Add(packet);\n            }\n\n            var headers = GetEssentialHeaders();\n\n            headers[Constants.TransferConstants.AUTHORIZATION_HEADER] = this.token.Token;\n\n            dynamic res = null;\n\n            try\n            {\n                res = this.httpClient.SendPackets(\n                    \"req/api/self-tsp/async/normal-enqueue\",\n                    packets,\n                    headers,\n                    true,\n                    true\n                );\n            }", "            catch (Exception e)\n            {\n            }\n\n            return res?.GetBody()?.GetContents();\n        }\n\n        public dynamic GetFiscalInfo()\n        {\n            RequireToken();\n\n            var packet = new Packet(Constants.PacketType.GET_FISCAL_INFORMATION, this.username);\n\n            var headers = GetEssentialHeaders();\n\n            headers[\"Authorization\"] = \"Bearer \" + this.token.Token;\n\n            return this.httpClient.SendPacket(\"req/api/self-tsp/sync/GET_FISCAL_INFORMATION\", packet, headers);\n        }\n\n        private Dictionary<string, string> GetEssentialHeaders()\n        {\n            return new Dictionary<string, string>\n            {\n                { Constants.TransferConstants.TIMESTAMP_HEADER, DateTimeOffset.Now.ToUnixTimeMilliseconds().ToString() },\n                { Constants.TransferConstants.REQUEST_TRACE_ID_HEADER, Guid.NewGuid().ToString() }\n            };\n        }\n", "        private async void RequireToken()\n        {\n            if (this.token == null || this.token.IsExpired())\n            {\n                this.token = await this.GetToken();\n            }\n        }\n\n    }\n}\n"]}
{"filename": "Services/SimpleNormalizer.cs", "chunked_list": ["\ufeffusing Moadian.Constants;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Moadian.Services\n{\n    public static class SimpleNormalizer\n    {", "{\n    public static class SimpleNormalizer\n    {\n        public static string Normalize(string data, Dictionary<string, string> headers)\n        {\n            if (headers == null || headers.Count == 0)\n            {\n                return data;\n            }\n\n            if (headers.ContainsKey(TransferConstants.AUTHORIZATION_HEADER))\n            {\n                data += headers[TransferConstants.AUTHORIZATION_HEADER];\n            }\n", "            if (headers.ContainsKey(TransferConstants.AUTHORIZATION_HEADER))\n            {\n                data += headers[TransferConstants.AUTHORIZATION_HEADER];\n            }\n\n            if (headers.ContainsKey(TransferConstants.REQUEST_TRACE_ID_HEADER))\n            {\n                data += headers[TransferConstants.REQUEST_TRACE_ID_HEADER];\n            }\n\n            if (headers.ContainsKey(TransferConstants.TIMESTAMP_HEADER))\n            {\n                data += headers[TransferConstants.TIMESTAMP_HEADER];\n            }\n\n            return data;\n        }\n    }\n}\n", "            if (headers.ContainsKey(TransferConstants.TIMESTAMP_HEADER))\n            {\n                data += headers[TransferConstants.TIMESTAMP_HEADER];\n            }\n\n            return data;\n        }\n    }\n}\n"]}
{"filename": "Services/SignatureService.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Moadian.Services\n{\n\n    public class SignatureService\n    {", "{\n\n    public class SignatureService\n    {\n        private readonly string keyId;\n        private readonly RSA taxOrgPrivateKey;\n\n        public SignatureService(string privateKey, string keyId = null)\n        {\n            // RSACryptoServiceProvider provider = PemKeyUtils.GetRSAProviderFromPemFile(privateKey, true); \n            // this.taxOrgPrivateKey = provider;\n            taxOrgPrivateKey = RSA.Create();\n            string pemstr = File.ReadAllText(privateKey).Trim();\n            taxOrgPrivateKey.ImportFromPem(pemstr.ToCharArray());\n            this.keyId = keyId;\n        }\n", "        public string Sign(string text)\n        {\n            byte[] data = Encoding.UTF8.GetBytes(text);\n\n            byte[] signature = this.taxOrgPrivateKey.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);\n\n            return Convert.ToBase64String(signature);\n        }\n\n        public string GetKeyId()\n        {\n            return keyId;\n        }\n    }\n}\n", "        public string GetKeyId()\n        {\n            return keyId;\n        }\n    }\n}\n"]}
{"filename": "Services/Normalizer.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Moadian.Services\n{\n    public static class Normalizer\n    {\n        public static string NormalizeArray(Dictionary<string, object> data)\n        {\n            var flattened = FlattenArray(data);\n\n            var sorted = flattened.OrderBy(x => x.Key);\n\n            return ArrayToValueString(sorted);\n        }\n", "    public static class Normalizer\n    {\n        public static string NormalizeArray(Dictionary<string, object> data)\n        {\n            var flattened = FlattenArray(data);\n\n            var sorted = flattened.OrderBy(x => x.Key);\n\n            return ArrayToValueString(sorted);\n        }\n", "        private static Dictionary<string, object> FlattenArray(Dictionary<string, object> array)\n        {\n            var result = new Dictionary<string, object>();\n\n            foreach (var pair in array)\n            {\n                if (pair.Value is Dictionary<string, object> nestedDict)\n                {\n                    var flattened = FlattenArray(nestedDict);\n\n                    var combined = flattened.ToDictionary(\n                        x => $\"{pair.Key}.{x.Key}\",\n                        x => x.Value\n                    );\n\n                    result = result.Concat(combined).ToDictionary(x => x.Key, x => x.Value);\n                }\n                else\n                {\n                    result[pair.Key] = pair.Value;\n                }\n            }\n\n            return result;\n        }\n", "        private static string ArrayToValueString(IEnumerable<KeyValuePair<string, object>> data)\n        {\n            var textValues = new List<string>();\n\n            foreach (var pair in data)\n            {\n                var value = pair.Value;\n\n                string textValue;\n\n                if (value is bool boolValue)\n                {\n                    textValue = boolValue ? \"true\" : \"false\";\n                }", "                if (value is bool boolValue)\n                {\n                    textValue = boolValue ? \"true\" : \"false\";\n                }\n                else if (value is null || value.ToString() == \"\")\n                {\n                    textValue = \"#\";\n                }\n                else\n                {\n                    textValue = value.ToString().Replace(\"#\", \"##\");\n                }\n\n                textValues.Add(textValue);\n            }\n\n            return string.Join(\"#\", textValues);\n        }\n    }\n}\n"]}
{"filename": "Services/InvoiceIdService.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Moadian.Services\n{\n    public class InvoiceIdService\n    {\n        private static readonly Dictionary<char, int> CHARACTER_TO_NUMBER_CODING = new Dictionary<char, int>()\n    {\n        {'A', 65}, {'B', 66}, {'C', 67}, {'D', 68}, {'E', 69}, {'F', 70}, {'G', 71}, {'H', 72}, {'I', 73},\n        {'J', 74}, {'K', 75}, {'L', 76}, {'M', 77}, {'N', 78}, {'O', 79}, {'P', 80}, {'Q', 81}, {'R', 82},\n        {'S', 83}, {'T', 84}, {'U', 85}, {'V', 86}, {'W', 87}, {'X', 88}, {'Y', 89}, {'Z', 90},\n    };\n", "    public class InvoiceIdService\n    {\n        private static readonly Dictionary<char, int> CHARACTER_TO_NUMBER_CODING = new Dictionary<char, int>()\n    {\n        {'A', 65}, {'B', 66}, {'C', 67}, {'D', 68}, {'E', 69}, {'F', 70}, {'G', 71}, {'H', 72}, {'I', 73},\n        {'J', 74}, {'K', 75}, {'L', 76}, {'M', 77}, {'N', 78}, {'O', 79}, {'P', 80}, {'Q', 81}, {'R', 82},\n        {'S', 83}, {'T', 84}, {'U', 85}, {'V', 86}, {'W', 87}, {'X', 88}, {'Y', 89}, {'Z', 90},\n    };\n\n        private readonly string clientId;\n\n        public InvoiceIdService(string clientId)\n        {\n            this.clientId = clientId;\n        }\n", "        private readonly string clientId;\n\n        public InvoiceIdService(string clientId)\n        {\n            this.clientId = clientId;\n        }\n\n        public string GenerateInvoiceId(DateTime date, int internalInvoiceId)\n        {\n            int daysPastEpoch = GetDaysPastEpoch(date);\n            string daysPastEpochPadded = daysPastEpoch.ToString().PadLeft(6, '0');\n            string hexDaysPastEpochPadded = daysPastEpoch.ToString(\"X\").PadLeft(5, '0');\n\n            string numericClientId = ClientIdToNumber(clientId);\n\n            string internalInvoiceIdPadded = internalInvoiceId.ToString().PadLeft(12, '0');\n            string hexInternalInvoiceIdPadded = internalInvoiceId.ToString(\"X\").PadLeft(10, '0');\n\n            string decimalInvoiceId = numericClientId + daysPastEpochPadded + internalInvoiceIdPadded;\n\n            int checksum = VerhoeffService.CheckSum(decimalInvoiceId);\n\n            return (clientId + hexDaysPastEpochPadded + hexInternalInvoiceIdPadded + checksum.ToString()).ToUpper();\n        }\n", "        private int GetDaysPastEpoch(DateTime date)\n        {\n            return (int)date.Subtract(new DateTime(1970, 1, 1)).TotalSeconds / (3600 * 24);\n        }\n\n        private string ClientIdToNumber(string clientId)\n        {\n            string result = \"\";\n            foreach (char c in clientId)\n            {\n                if (char.IsDigit(c))\n                {\n                    result += c;\n                }\n                else\n                {\n                    result += CHARACTER_TO_NUMBER_CODING[c];\n                }\n            }\n            return result;\n        }\n    }\n}\n", "            foreach (char c in clientId)\n            {\n                if (char.IsDigit(c))\n                {\n                    result += c;\n                }\n                else\n                {\n                    result += CHARACTER_TO_NUMBER_CODING[c];\n                }\n            }\n            return result;\n        }\n    }\n}\n"]}
{"filename": "Services/PemKeyUtils.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Security.Cryptography;\nusing System.Security;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Moadian.Services", "\nnamespace Moadian.Services\n{\n    public static class PemKeyUtils\n    {\n        const String pemprivheader = \"-----BEGIN RSA PRIVATE KEY-----\";\n        const String pemprivfooter = \"-----END RSA PRIVATE KEY-----\";\n        const String pempubheader = \"-----BEGIN PUBLIC KEY-----\";\n        const String pempubfooter = \"-----END PUBLIC KEY-----\";\n        const String pemp8header = \"-----BEGIN PRIVATE KEY-----\";\n        const String pemp8footer = \"-----END PRIVATE KEY-----\";\n        const String pemp8encheader = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\";\n        const String pemp8encfooter = \"-----END ENCRYPTED PRIVATE KEY-----\";\n\n        static bool verbose = true;\n", "        public static RSACryptoServiceProvider GetRSAProviderFromPemFile(String pemfile, bool isPrivateKeyFile)\n        {\n            string pemstr = File.ReadAllText(pemfile).Trim();\n            if (pemstr.StartsWith(pempubheader) && pemstr.EndsWith(pempubfooter))\n                isPrivateKeyFile = false;\n\n            byte[] pemkey;\n            if (isPrivateKeyFile)\n            {\n                pemkey = DecodeOpenSSLPrivateKey(pemstr);\n            }\n            else\n            {\n                pemkey = DecodeOpenSSLPublicKey(pemstr);\n            }\n", "            if (pemkey == null)\n                return null;\n\n            if (isPrivateKeyFile)\n                return DecodeRSAPrivateKey(pemkey);\n            else\n                return DecodeX509PublicKey(pemkey);\n\n        }\n\n\n\n        //--------   Get the binary RSA PUBLIC key   --------\n        static byte[] DecodeOpenSSLPublicKey(String instr)\n        {\n            String pemstr = instr.Trim();\n            byte[] binkey;", "            if (!pemstr.StartsWith(pempubheader) || !pemstr.EndsWith(pempubfooter))\n                return null;\n            StringBuilder sb = new StringBuilder(pemstr);\n            sb.Replace(pempubheader, \"\");  //remove headers/footers, if present\n            sb.Replace(pempubfooter, \"\");\n\n            String pubstr = sb.ToString().Trim();   //get string after removing leading/trailing whitespace\n\n            try\n            {\n                binkey = Convert.FromBase64String(pubstr);\n            }", "            catch (System.FormatException)\n            {       //if can't b64 decode, data is not valid\n                return null;\n            }\n            return binkey;\n        }\n\n        static RSACryptoServiceProvider DecodeX509PublicKey(byte[] x509Key)\n        {\n            // encoded OID sequence for  PKCS #1 rsaEncryption szOID_RSA_RSA = \"1.2.840.113549.1.1.1\"\n            byte[] seqOid = { 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00 };\n            // ---------  Set up stream to read the asn.1 encoded SubjectPublicKeyInfo blob  ------", "            using (var mem = new MemoryStream(x509Key))\n            {\n                using (var binr = new BinaryReader(mem))    //wrap Memory Stream with BinaryReader for easy reading\n                {\n                    try\n                    {\n                        var twobytes = binr.ReadUInt16();\n                        switch (twobytes)\n                        {\n                            case 0x8130:\n                                binr.ReadByte();    //advance 1 byte\n                                break;\n                            case 0x8230:\n                                binr.ReadInt16();   //advance 2 bytes\n                                break;\n                            default:\n                                return null;\n                        }\n\n                        var seq = binr.ReadBytes(15);", "                        if (!CompareBytearrays(seq, seqOid))  //make sure Sequence for OID is correct\n                            return null;\n\n                        twobytes = binr.ReadUInt16();\n                        if (twobytes == 0x8103) //data read as little endian order (actual data order for Bit String is 03 81)\n                            binr.ReadByte();    //advance 1 byte\n                        else if (twobytes == 0x8203)\n                            binr.ReadInt16();   //advance 2 bytes\n                        else\n                            return null;\n\n                        var bt = binr.ReadByte();", "                        if (bt != 0x00)     //expect null byte next\n                            return null;\n\n                        twobytes = binr.ReadUInt16();\n                        if (twobytes == 0x8130) //data read as little endian order (actual data order for Sequence is 30 81)\n                            binr.ReadByte();    //advance 1 byte\n                        else if (twobytes == 0x8230)\n                            binr.ReadInt16();   //advance 2 bytes\n                        else\n                            return null;\n\n                        twobytes = binr.ReadUInt16();\n                        byte lowbyte = 0x00;\n                        byte highbyte = 0x00;\n", "                        if (twobytes == 0x8102) //data read as little endian order (actual data order for Integer is 02 81)\n                            lowbyte = binr.ReadByte();  // read next bytes which is bytes in modulus\n                        else if (twobytes == 0x8202)\n                        {\n                            highbyte = binr.ReadByte(); //advance 2 bytes\n                            lowbyte = binr.ReadByte();\n                        }\n                        else\n                            return null;\n                        byte[] modint = { lowbyte, highbyte, 0x00, 0x00 };   //reverse byte order since asn.1 key uses big endian order\n                        int modsize = BitConverter.ToInt32(modint, 0);\n\n                        byte firstbyte = binr.ReadByte();\n                        binr.BaseStream.Seek(-1, SeekOrigin.Current);\n", "                        if (firstbyte == 0x00)\n                        {   //if first byte (highest order) of modulus is zero, don't include it\n                            binr.ReadByte();    //skip this null byte\n                            modsize -= 1;   //reduce modulus buffer size by 1\n                        }\n\n                        byte[] modulus = binr.ReadBytes(modsize); //read the modulus bytes\n\n                        if (binr.ReadByte() != 0x02)            //expect an Integer for the exponent data\n                            return null;\n                        int expbytes = binr.ReadByte();        // should only need one byte for actual exponent data (for all useful values)\n                        byte[] exponent = binr.ReadBytes(expbytes);\n\n                        // We don't really need to print anything but if we insist to...\n                        //showBytes(\"\\nExponent\", exponent);\n                        //showBytes(\"\\nModulus\", modulus);\n\n                        // ------- create RSACryptoServiceProvider instance and initialize with public key -----\n                        RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();\n                        RSAParameters rsaKeyInfo = new RSAParameters\n                        {\n                            Modulus = modulus,\n                            Exponent = exponent\n                        };\n                        rsa.ImportParameters(rsaKeyInfo);\n                        return rsa;\n                    }", "                        if (binr.ReadByte() != 0x02)            //expect an Integer for the exponent data\n                            return null;\n                        int expbytes = binr.ReadByte();        // should only need one byte for actual exponent data (for all useful values)\n                        byte[] exponent = binr.ReadBytes(expbytes);\n\n                        // We don't really need to print anything but if we insist to...\n                        //showBytes(\"\\nExponent\", exponent);\n                        //showBytes(\"\\nModulus\", modulus);\n\n                        // ------- create RSACryptoServiceProvider instance and initialize with public key -----\n                        RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();\n                        RSAParameters rsaKeyInfo = new RSAParameters\n                        {\n                            Modulus = modulus,\n                            Exponent = exponent\n                        };\n                        rsa.ImportParameters(rsaKeyInfo);\n                        return rsa;\n                    }", "                    catch (Exception)\n                    {\n                        return null;\n                    }\n                }\n            }\n        }\n\n        //------- Parses binary ans.1 RSA private key; returns RSACryptoServiceProvider  ---\n        static RSACryptoServiceProvider DecodeRSAPrivateKey(byte[] privkey)\n        {\n            byte[] MODULUS, E, D, P, Q, DP, DQ, IQ;\n\n            // ---------  Set up stream to decode the asn.1 encoded RSA private key  ------\n            MemoryStream mem = new MemoryStream(privkey);\n            BinaryReader binr = new BinaryReader(mem);    //wrap Memory Stream with BinaryReader for easy reading\n            byte bt = 0;\n            ushort twobytes = 0;\n            int elems = 0;\n            try\n            {\n                twobytes = binr.ReadUInt16();", "                if (twobytes == 0x8130) //data read as little endian order (actual data order for Sequence is 30 81)\n                    binr.ReadByte();    //advance 1 byte\n                else if (twobytes == 0x8230)\n                    binr.ReadInt16();   //advance 2 bytes\n                else\n                    return null;\n\n                twobytes = binr.ReadUInt16();\n                if (twobytes != 0x0102) //version number\n                    return null;\n                bt = binr.ReadByte();", "                if (twobytes != 0x0102) //version number\n                    return null;\n                bt = binr.ReadByte();\n                if (bt != 0x00)\n                    return null;\n\n\n                //------  all private key components are Integer sequences ----\n                elems = GetIntegerSize(binr);\n                MODULUS = binr.ReadBytes(elems);\n\n                elems = GetIntegerSize(binr);\n                E = binr.ReadBytes(elems);\n\n                elems = GetIntegerSize(binr);\n                D = binr.ReadBytes(elems);\n\n                elems = GetIntegerSize(binr);\n                P = binr.ReadBytes(elems);\n\n                elems = GetIntegerSize(binr);\n                Q = binr.ReadBytes(elems);\n\n                elems = GetIntegerSize(binr);\n                DP = binr.ReadBytes(elems);\n\n                elems = GetIntegerSize(binr);\n                DQ = binr.ReadBytes(elems);\n\n                elems = GetIntegerSize(binr);\n                IQ = binr.ReadBytes(elems);\n\n                Console.WriteLine(\"showing components ..\");", "                if (verbose)\n                {\n                    showBytes(\"\\nModulus\", MODULUS);\n                    showBytes(\"\\nExponent\", E);\n                    showBytes(\"\\nD\", D);\n                    showBytes(\"\\nP\", P);\n                    showBytes(\"\\nQ\", Q);\n                    showBytes(\"\\nDP\", DP);\n                    showBytes(\"\\nDQ\", DQ);\n                    showBytes(\"\\nIQ\", IQ);\n                }\n\n                // ------- create RSACryptoServiceProvider instance and initialize with public key -----\n                RSACryptoServiceProvider RSA = new RSACryptoServiceProvider();\n                RSAParameters RSAparams = new RSAParameters();\n                RSAparams.Modulus = MODULUS;\n                RSAparams.Exponent = E;\n                RSAparams.D = D;\n                RSAparams.P = P;\n                RSAparams.Q = Q;\n                RSAparams.DP = DP;\n                RSAparams.DQ = DQ;\n                RSAparams.InverseQ = IQ;\n                RSA.ImportParameters(RSAparams);\n                return RSA;\n            }", "            catch (Exception)\n            {\n                return null;\n            }\n            finally { binr.Close(); }\n        }\n\n        private static int GetIntegerSize(BinaryReader binr)\n        {\n            byte bt = 0;\n            byte lowbyte = 0x00;\n            byte highbyte = 0x00;\n            int count = 0;\n            bt = binr.ReadByte();", "            if (bt != 0x02)     //expect integer\n                return 0;\n            bt = binr.ReadByte();\n\n            if (bt == 0x81)\n                count = binr.ReadByte();    // data size in next byte\n            else\n                if (bt == 0x82)\n            {\n                highbyte = binr.ReadByte(); // data size in next 2 bytes\n                lowbyte = binr.ReadByte();\n                byte[] modint = { lowbyte, highbyte, 0x00, 0x00 };\n                count = BitConverter.ToInt32(modint, 0);\n            }\n            else\n            {\n                count = bt;     // we already have the data size\n            }\n\n\n", "            while (binr.ReadByte() == 0x00)\n            {   //remove high order zeros in data\n                count -= 1;\n            }\n            binr.BaseStream.Seek(-1, SeekOrigin.Current);     //last ReadByte wasn't a removed zero, so back up a byte\n            return count;\n        }\n\n        //-----  Get the binary RSA PRIVATE key, decrypting if necessary ----\n        static byte[] DecodeOpenSSLPrivateKey(String instr)\n        {\n            String pemstr = instr.Trim();\n            byte[] binkey;", "            if (!pemstr.StartsWith(pemprivheader) || !pemstr.EndsWith(pemprivfooter))\n                return null;\n\n            StringBuilder sb = new StringBuilder(pemstr);\n            sb.Replace(pemprivheader, \"\");  //remove headers/footers, if present\n            sb.Replace(pemprivfooter, \"\");\n\n            String pvkstr = sb.ToString().Trim();   //get string after removing leading/trailing whitespace\n\n            try\n            {        // if there are no PEM encryption info lines, this is an UNencrypted PEM private key\n                binkey = Convert.FromBase64String(pvkstr);\n                return binkey;\n            }", "            catch (System.FormatException)\n            {       //if can't b64 decode, it must be an encrypted private key\n                    //Console.WriteLine(\"Not an unencrypted OpenSSL PEM private key\");  \n            }\n\n            StringReader str = new StringReader(pvkstr);\n\n            //-------- read PEM encryption info. lines and extract salt -----\n            if (!str.ReadLine().StartsWith(\"Proc-Type: 4,ENCRYPTED\"))\n                return null;\n            String saltline = str.ReadLine();", "            if (!str.ReadLine().StartsWith(\"Proc-Type: 4,ENCRYPTED\"))\n                return null;\n            String saltline = str.ReadLine();\n            if (!saltline.StartsWith(\"DEK-Info: DES-EDE3-CBC,\"))\n                return null;\n            String saltstr = saltline.Substring(saltline.IndexOf(\",\") + 1).Trim();\n            byte[] salt = new byte[saltstr.Length / 2];\n            for (int i = 0; i < salt.Length; i++)\n                salt[i] = Convert.ToByte(saltstr.Substring(i * 2, 2), 16);\n            if (!(str.ReadLine() == \"\"))\n                return null;\n\n            //------ remaining b64 data is encrypted RSA key ----\n            String encryptedstr = str.ReadToEnd();\n\n            try\n            {   //should have b64 encrypted RSA key now\n                binkey = Convert.FromBase64String(encryptedstr);\n            }", "            if (!(str.ReadLine() == \"\"))\n                return null;\n\n            //------ remaining b64 data is encrypted RSA key ----\n            String encryptedstr = str.ReadToEnd();\n\n            try\n            {   //should have b64 encrypted RSA key now\n                binkey = Convert.FromBase64String(encryptedstr);\n            }\n            catch (System.FormatException)\n            {  // bad b64 data.\n                return null;\n            }\n\n            //------ Get the 3DES 24 byte key using PDK used by OpenSSL ----\n\n            SecureString despswd = GetSecPswd(\"Enter password to derive 3DES key==>\");\n            //Console.Write(\"\\nEnter password to derive 3DES key: \");\n            //String pswd = Console.ReadLine();\n            byte[] deskey = GetOpenSSL3deskey(salt, despswd, 1, 2);    // count=1 (for OpenSSL implementation); 2 iterations to get at least 24 bytes", "            catch (System.FormatException)\n            {  // bad b64 data.\n                return null;\n            }\n\n            //------ Get the 3DES 24 byte key using PDK used by OpenSSL ----\n\n            SecureString despswd = GetSecPswd(\"Enter password to derive 3DES key==>\");\n            //Console.Write(\"\\nEnter password to derive 3DES key: \");\n            //String pswd = Console.ReadLine();\n            byte[] deskey = GetOpenSSL3deskey(salt, despswd, 1, 2);    // count=1 (for OpenSSL implementation); 2 iterations to get at least 24 bytes", "            if (deskey == null)\n                return null;\n            //showBytes(\"3DES key\", deskey) ;\n\n            //------ Decrypt the encrypted 3des-encrypted RSA private key ------\n            byte[] rsakey = DecryptKey(binkey, deskey, salt); //OpenSSL uses salt value in PEM header also as 3DES IV\n            if (rsakey != null)\n                return rsakey;  //we have a decrypted RSA private key\n            else\n            {\n                Console.WriteLine(\"Failed to decrypt RSA private key; probably wrong password.\");\n                return null;\n            }\n        }\n\n\n        // ----- Decrypt the 3DES encrypted RSA private key ----------\n\n        static byte[] DecryptKey(byte[] cipherData, byte[] desKey, byte[] IV)\n        {\n            MemoryStream memst = new MemoryStream();\n            TripleDES alg = TripleDES.Create();\n            alg.Key = desKey;\n            alg.IV = IV;\n            try\n            {\n                CryptoStream cs = new CryptoStream(memst, alg.CreateDecryptor(), CryptoStreamMode.Write);\n                cs.Write(cipherData, 0, cipherData.Length);\n                cs.Close();\n            }", "            catch (Exception exc)\n            {\n                Console.WriteLine(exc.Message);\n                return null;\n            }\n            byte[] decryptedData = memst.ToArray();\n            return decryptedData;\n        }\n\n        //-----   OpenSSL PBKD uses only one hash cycle (count); miter is number of iterations required to build sufficient bytes ---\n        static byte[] GetOpenSSL3deskey(byte[] salt, SecureString secpswd, int count, int miter)\n        {\n            IntPtr unmanagedPswd = IntPtr.Zero;\n            int HASHLENGTH = 16;    //MD5 bytes\n            byte[] keymaterial = new byte[HASHLENGTH * miter];     //to store contatenated Mi hashed results\n\n\n            byte[] psbytes = new byte[secpswd.Length];\n            unmanagedPswd = Marshal.SecureStringToGlobalAllocAnsi(secpswd);\n            Marshal.Copy(unmanagedPswd, psbytes, 0, psbytes.Length);\n            Marshal.ZeroFreeGlobalAllocAnsi(unmanagedPswd);\n\n            //UTF8Encoding utf8 = new UTF8Encoding();\n            //byte[] psbytes = utf8.GetBytes(pswd);\n\n            // --- contatenate salt and pswd bytes into fixed data array ---\n            byte[] data00 = new byte[psbytes.Length + salt.Length];\n            Array.Copy(psbytes, data00, psbytes.Length);      //copy the pswd bytes\n            Array.Copy(salt, 0, data00, psbytes.Length, salt.Length); //concatenate the salt bytes\n\n            // ---- do multi-hashing and contatenate results  D1, D2 ...  into keymaterial bytes ----\n            MD5 md5 = new MD5CryptoServiceProvider();\n            byte[] result = null;\n            byte[] hashtarget = new byte[HASHLENGTH + data00.Length];   //fixed length initial hashtarget\n", "            for (int j = 0; j < miter; j++)\n            {\n                // ----  Now hash consecutively for count times ------\n                if (j == 0)\n                    result = data00;    //initialize \n                else\n                {\n                    Array.Copy(result, hashtarget, result.Length);\n                    Array.Copy(data00, 0, hashtarget, result.Length, data00.Length);\n                    result = hashtarget;\n                    //Console.WriteLine(\"Updated new initial hash target:\") ;\n                    //showBytes(result) ;\n                }\n", "                for (int i = 0; i < count; i++)\n                    result = md5.ComputeHash(result);\n                Array.Copy(result, 0, keymaterial, j * HASHLENGTH, result.Length);  //contatenate to keymaterial\n            }\n            //showBytes(\"Final key material\", keymaterial);\n            byte[] deskey = new byte[24];\n            Array.Copy(keymaterial, deskey, deskey.Length);\n\n            Array.Clear(psbytes, 0, psbytes.Length);\n            Array.Clear(data00, 0, data00.Length);\n            Array.Clear(result, 0, result.Length);\n            Array.Clear(hashtarget, 0, hashtarget.Length);\n            Array.Clear(keymaterial, 0, keymaterial.Length);\n\n            return deskey;\n        }\n\n        static SecureString GetSecPswd(String prompt)\n        {\n            SecureString password = new SecureString();\n\n            Console.ForegroundColor = ConsoleColor.Gray;\n            Console.Write(prompt);\n            Console.ForegroundColor = ConsoleColor.Magenta;\n", "            while (true)\n            {\n                ConsoleKeyInfo cki = Console.ReadKey(true);\n                if (cki.Key == ConsoleKey.Enter)\n                {\n                    Console.ForegroundColor = ConsoleColor.Gray;\n                    Console.WriteLine();\n                    return password;\n                }\n                else if (cki.Key == ConsoleKey.Backspace)\n                {\n                    // remove the last asterisk from the screen...", "                else if (cki.Key == ConsoleKey.Backspace)\n                {\n                    // remove the last asterisk from the screen...\n                    if (password.Length > 0)\n                    {\n                        Console.SetCursorPosition(Console.CursorLeft - 1, Console.CursorTop);\n                        Console.Write(\" \");\n                        Console.SetCursorPosition(Console.CursorLeft - 1, Console.CursorTop);\n                        password.RemoveAt(password.Length - 1);\n                    }\n                }", "                else if (cki.Key == ConsoleKey.Escape)\n                {\n                    Console.ForegroundColor = ConsoleColor.Gray;\n                    Console.WriteLine();\n                    return password;\n                }\n                else if (Char.IsLetterOrDigit(cki.KeyChar) || Char.IsSymbol(cki.KeyChar))\n                {\n                    if (password.Length < 20)\n                    {\n                        password.AppendChar(cki.KeyChar);\n                        Console.Write(\"*\");\n                    }\n                    else\n                    {\n                        Console.Beep();\n                    }\n                }\n                else\n                {\n                    Console.Beep();\n                }\n            }\n        }\n\n        static bool CompareBytearrays(byte[] a, byte[] b)\n        {", "                    if (password.Length < 20)\n                    {\n                        password.AppendChar(cki.KeyChar);\n                        Console.Write(\"*\");\n                    }\n                    else\n                    {\n                        Console.Beep();\n                    }\n                }\n                else\n                {\n                    Console.Beep();\n                }\n            }\n        }\n\n        static bool CompareBytearrays(byte[] a, byte[] b)\n        {", "            if (a.Length != b.Length)\n                return false;\n            int i = 0;\n            foreach (byte c in a)\n            {\n                if (c != b[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n\n        static void showBytes(String info, byte[] data)\n        {\n            Console.WriteLine(\"{0}  [{1} bytes]\", info, data.Length);", "            for (int i = 1; i <= data.Length; i++)\n            {\n                Console.Write(\"{0:X2}  \", data[i - 1]);\n                if (i % 16 == 0)\n                    Console.WriteLine();\n            }\n            Console.WriteLine(\"\\n\\n\");\n        }\n\n    }\n}\n"]}
{"filename": "Services/HttpClientService.cs", "chunked_list": ["\ufeffusing Moadian.Dto;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net.Http.Headers;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Threading.Tasks;", "using System.Text;\nusing System.Threading.Tasks;\n\nnamespace Moadian.Services\n{\n\n    public class HttpClientService\n    {\n        private readonly HttpClient client;\n        private readonly SignatureService signatureService;\n        private readonly EncryptionService encryptionService;\n\n        public HttpClientService(SignatureService signatureService, EncryptionService encryptionService, string baseUri = \"https://tp.tax.gov.ir\")\n        {\n            client = new HttpClient\n            {\n                BaseAddress = new Uri(baseUri)\n            };\n            client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n            this.signatureService = signatureService;\n            this.encryptionService = encryptionService;\n        }\n", "        private readonly HttpClient client;\n        private readonly SignatureService signatureService;\n        private readonly EncryptionService encryptionService;\n\n        public HttpClientService(SignatureService signatureService, EncryptionService encryptionService, string baseUri = \"https://tp.tax.gov.ir\")\n        {\n            client = new HttpClient\n            {\n                BaseAddress = new Uri(baseUri)\n            };\n            client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n            this.signatureService = signatureService;\n            this.encryptionService = encryptionService;\n        }\n", "        public async Task<object?> SendPacket(string path, Packet packet, Dictionary<string, string> headers)\n        {\n            var cloneHeader = new Dictionary<string, string>(headers);\n\n            if (cloneHeader.ContainsKey(\"Authorization\"))\n            {\n                cloneHeader[\"Authorization\"] = cloneHeader[\"Authorization\"].Replace(\"Bearer \", \"\");\n            }\n            var pack = packet.ToArray();\n            foreach (var item in cloneHeader)\n            {\n                pack.Add(item.Key, item.Value);\n            }\n            var normalizedData = Normalizer.NormalizeArray(pack);\n            var signature = signatureService.Sign(normalizedData);\n\n            var content = new Dictionary<string, object>\n            {\n                { \"packet\", packet.ToArray() },\n                { \"signature\", signature }\n            };\n            string contentJson = JsonConvert.SerializeObject(content);\n            var response = await Post(path, contentJson, headers);\n            var stringData = await response.Content.ReadAsStringAsync();\n            return JsonConvert.DeserializeObject(stringData);\n        }\n", "            foreach (var item in cloneHeader)\n            {\n                pack.Add(item.Key, item.Value);\n            }\n            var normalizedData = Normalizer.NormalizeArray(pack);\n            var signature = signatureService.Sign(normalizedData);\n\n            var content = new Dictionary<string, object>\n            {\n                { \"packet\", packet.ToArray() },\n                { \"signature\", signature }\n            };\n            string contentJson = JsonConvert.SerializeObject(content);\n            var response = await Post(path, contentJson, headers);\n            var stringData = await response.Content.ReadAsStringAsync();\n            return JsonConvert.DeserializeObject(stringData);\n        }\n", "        public async Task<object> SendPackets(string path, List<Packet> packets, Dictionary<string, string> headers, bool encrypt = false, bool sign = false)\n        {\n            headers = FillEssentialHeaders(headers);\n\n            if (sign)\n            {\n                foreach (var packet in packets)\n                {\n                    SignPacket(packet);\n                }\n            }\n", "            if (encrypt)\n            {\n                packets = EncryptPackets(packets);\n            }\n\n            var cloneHeader = new Dictionary<string, string>(headers);\n            cloneHeader[\"Authorization\"] = cloneHeader[\"Authorization\"].Replace(\"Bearer \", \"\");\n            var pack = packets[0].ToArray();\n            foreach (var item in cloneHeader)\n            {\n                pack.Add(item.Key, item.Value);\n            }\n            var normalized = Normalizer.NormalizeArray(pack);\n            var signature = signatureService.Sign(normalized);\n\n            var content = new Dictionary<string, object>\n        {\n            { \"packets\", packets.ConvertAll(p => p.ToArray()) },\n            { \"signature\", signature },\n            { \"signatureKeyId\", null }\n        };\n\n            return await Post(path, JsonConvert.SerializeObject(content), headers);\n        }\n", "            foreach (var item in cloneHeader)\n            {\n                pack.Add(item.Key, item.Value);\n            }\n            var normalized = Normalizer.NormalizeArray(pack);\n            var signature = signatureService.Sign(normalized);\n\n            var content = new Dictionary<string, object>\n        {\n            { \"packets\", packets.ConvertAll(p => p.ToArray()) },\n            { \"signature\", signature },\n            { \"signatureKeyId\", null }\n        };\n\n            return await Post(path, JsonConvert.SerializeObject(content), headers);\n        }\n", "        private void SignPacket(Packet packet)\n        {\n            var normalized = Normalizer.NormalizeArray(packet.data is string ? null : ((PacketDataInterface)packet.data)?.ToArray());\n            var signature = signatureService.Sign(normalized);\n\n            packet.dataSignature = signature;\n            // TODO: Not sure?\n            // packet.SetSignatureKeyId(signatureService.GetKeyId());\n        }\n\n        private List<Packet> EncryptPackets(List<Packet> packets)\n        {\n            var aesHex = BitConverter.ToString(RandomNumberGenerator.GetBytes(32)).Replace(\"-\", \"\");\n            var iv = BitConverter.ToString(RandomNumberGenerator.GetBytes(16)).Replace(\"-\", \"\");\n            var encryptedAesKey = encryptionService.EncryptAesKey(aesHex);\n", "            foreach (var packet in packets)\n            {\n                packet.iv = iv;\n                packet.symmetricKey = encryptedAesKey;\n                packet.encryptionKeyId = encryptionService.GetEncryptionKeyId();\n                packet.data = (Encoding.UTF8.GetBytes(encryptionService.Encrypt(JsonConvert.SerializeObject(packet.data is string ? packet.data : ((PacketDataInterface)packet.data)?.ToArray()), hex2bin(aesHex), hex2bin(iv))));\n            }\n\n            return packets;\n        }\n        private async Task<HttpResponseMessage> Post(string path, string content, Dictionary<string, string> headers = null)\n        {\n            var request = new HttpRequestMessage(HttpMethod.Post, path);\n            request.Content = new StringContent(content, Encoding.UTF8, \"application/json\");\n", "        private async Task<HttpResponseMessage> Post(string path, string content, Dictionary<string, string> headers = null)\n        {\n            var request = new HttpRequestMessage(HttpMethod.Post, path);\n            request.Content = new StringContent(content, Encoding.UTF8, \"application/json\");\n\n            if (headers != null)\n            {\n                foreach (var header in headers)\n                {\n                    request.Headers.Add(header.Key, header.Value);\n                }\n            }\n\n            return await client.SendAsync(request);\n        }\n\n        /**\n         * @param Dictionary<string, string> headers\n         * @return Dictionary<string, string>\n         */\n        private Dictionary<string, string> FillEssentialHeaders(Dictionary<string, string> headers)\n        {", "            if (!headers.ContainsKey(Constants.TransferConstants.TIMESTAMP_HEADER))\n            {\n                headers.Add(Constants.TransferConstants.TIMESTAMP_HEADER, \"1678654079000\");\n            }\n\n            if (!headers.ContainsKey(Constants.TransferConstants.REQUEST_TRACE_ID_HEADER))\n            {\n                headers.Add(Constants.TransferConstants.REQUEST_TRACE_ID_HEADER, \"AAA\");\n            }\n\n            return headers;\n        }\n\n        private byte[] hex2bin(string hexdata)\n        {", "            if (hexdata == null)\n                throw new ArgumentNullException(\"hexdata\");\n            if (hexdata.Length % 2 != 0)\n                throw new ArgumentException(\"hexdata should have even length\");\n\n            byte[] bytes = new byte[hexdata.Length / 2];\n            for (int i = 0; i < hexdata.Length; i += 2)\n                bytes[i / 2] = (byte)(HexValue(hexdata[i]) * 0x10\n                + HexValue(hexdata[i + 1]));\n            return bytes;\n        }", "        private int HexValue(char c)\n        {\n            int ch = (int)c;\n            if (ch >= (int)'0' && ch <= (int)'9')\n                return ch - (int)'0';\n            if (ch >= (int)'a' && ch <= (int)'f')\n                return ch - (int)'a' + 10;\n            if (ch >= (int)'A' && ch <= (int)'F')\n                return ch - (int)'A' + 10;\n            throw new ArgumentException(\"Not a hexadecimal digit.\");\n        }\n    }\n}\n"]}
{"filename": "Services/VerhoeffService.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Moadian.Services\n{\n    public static class VerhoeffService\n    {\n        private static readonly int[,] MULTIPLICATION_TABLE = new int[,]\n        {\n            { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 },\n            { 1, 2, 3, 4, 0, 6, 7, 8, 9, 5 },\n            { 2, 3, 4, 0, 1, 7, 8, 9, 5, 6 },\n            { 3, 4, 0, 1, 2, 8, 9, 5, 6, 7 },\n            { 4, 0, 1, 2, 3, 9, 5, 6, 7, 8 },\n            { 5, 9, 8, 7, 6, 0, 4, 3, 2, 1 },\n            { 6, 5, 9, 8, 7, 1, 0, 4, 3, 2 },\n            { 7, 6, 5, 9, 8, 2, 1, 0, 4, 3 },\n            { 8, 7, 6, 5, 9, 3, 2, 1, 0, 4 },\n            { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }\n        };\n", "    public static class VerhoeffService\n    {\n        private static readonly int[,] MULTIPLICATION_TABLE = new int[,]\n        {\n            { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 },\n            { 1, 2, 3, 4, 0, 6, 7, 8, 9, 5 },\n            { 2, 3, 4, 0, 1, 7, 8, 9, 5, 6 },\n            { 3, 4, 0, 1, 2, 8, 9, 5, 6, 7 },\n            { 4, 0, 1, 2, 3, 9, 5, 6, 7, 8 },\n            { 5, 9, 8, 7, 6, 0, 4, 3, 2, 1 },\n            { 6, 5, 9, 8, 7, 1, 0, 4, 3, 2 },\n            { 7, 6, 5, 9, 8, 2, 1, 0, 4, 3 },\n            { 8, 7, 6, 5, 9, 3, 2, 1, 0, 4 },\n            { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }\n        };\n", "        private static readonly int[,] PERMUTATION_TABLE = new int[,]\n        {\n            { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 },\n            { 1, 5, 7, 6, 2, 8, 3, 0, 9, 4 },\n            { 5, 8, 0, 3, 7, 9, 6, 1, 4, 2 },\n            { 8, 9, 1, 6, 0, 4, 3, 5, 2, 7 },\n            { 9, 4, 5, 3, 1, 2, 6, 8, 7, 0 },\n            { 4, 2, 8, 6, 5, 7, 3, 9, 0, 1 },\n            { 2, 7, 9, 3, 8, 0, 6, 4, 1, 5 },\n            { 7, 0, 4, 6, 9, 1, 3, 2, 5, 8 }\n        };\n", "        private static readonly int[] INVERSE_TABLE = new int[] { 0, 4, 3, 2, 1, 5, 6, 7, 8, 9 };\n\n        public static int CheckSum(string number)\n        {\n            int c = 0;\n            int len = number.Length;\n\n            for (int i = 0; i < len; ++i)\n            {\n                c = MULTIPLICATION_TABLE[c, PERMUTATION_TABLE[((i + 1) % 8), number[len - i - 1] - '0']];\n            }\n\n            return INVERSE_TABLE[c];\n        }\n", "        public static bool validate(string number)\n        {\n            var c = 0;\n            var len = number.Length;\n            for (int i = 0; i < len; i++)\n            {\n                c = MULTIPLICATION_TABLE[c, PERMUTATION_TABLE[(i % 8), number[len - i - 1] - '0']];\n            }\n            return c == 0;\n        }\n    }\n}\n"]}
{"filename": "Services/EncryptionService.cs", "chunked_list": ["\ufeffusing System;\nusing System.Security.Cryptography;\nusing System.Text;\n\nnamespace Moadian.Services\n{\n    public class EncryptionService\n    {\n        private const string CIPHER = \"aes-256-gcm\";\n        private const int TAG_LENGTH = 16;\n", "        private const string CIPHER = \"aes-256-gcm\";\n        private const int TAG_LENGTH = 16;\n\n        private readonly RSA taxOrgPublicKey;\n        private readonly string encryptionKeyId;\n\n        public EncryptionService(string publicKey, string encryptionKeyId)\n        {\n            //RSACryptoServiceProvider provider = PemKeyUtils.GetRSAProviderFromPemFile(taxOrgPublicKey, false);\n            //this.taxOrgPublicKey = provider;\n            this.taxOrgPublicKey = RSA.Create();\n            string pemstr = File.ReadAllText(publicKey).Trim();\n            this.taxOrgPublicKey.ImportFromPem(pemstr.ToCharArray());\n            this.encryptionKeyId = encryptionKeyId;\n        }\n", "        public string Encrypt(string text, byte[] key, byte[] iv)\n        {\n            text = XorStrings(text, Encoding.UTF8.GetString(key));\n\n            var cipher = new AesGcm(key);\n            byte[] tag = new byte[TAG_LENGTH];\n\n            byte[] cipherText = new byte[text.Length];\n            cipher.Encrypt(iv, Encoding.UTF8.GetBytes(text), cipherText, tag);\n\n            byte[] encrypted = new byte[cipherText.Length + tag.Length];\n            Array.Copy(cipherText, encrypted, cipherText.Length);\n            Array.Copy(tag, 0, encrypted, cipherText.Length, tag.Length);\n\n            return Convert.ToBase64String(encrypted);\n        }\n", "        public string Decrypt(string encryptedText, byte[] key, byte[] iv)\n        {\n            byte[] encrypted = Convert.FromBase64String(encryptedText);\n\n            byte[] cipherText = new byte[encrypted.Length - TAG_LENGTH];\n            Array.Copy(encrypted, cipherText, cipherText.Length);\n\n            byte[] tag = new byte[TAG_LENGTH];\n            Array.Copy(encrypted, cipherText.Length, tag, 0, tag.Length);\n\n            var cipher = new AesGcm(key);\n            byte[] decrypted = new byte[cipherText.Length];\n            cipher.Decrypt(iv, cipherText, tag, decrypted);\n\n            string text = Encoding.UTF8.GetString(decrypted);\n\n            return XorStrings(text, Encoding.UTF8.GetString(key));\n        }\n", "        public string EncryptAesKey(string aesKey)\n        {\n            byte[] encryptedKey = taxOrgPublicKey.Encrypt(Encoding.UTF8.GetBytes(aesKey), RSAEncryptionPadding.Pkcs1);\n            return Convert.ToBase64String(encryptedKey);\n        }\n\n        public string GetEncryptionKeyId()\n        {\n            return encryptionKeyId;\n        }\n", "        private static string XorStrings(string source, string key)\n        {\n            int sourceLength = source.Length;\n            int keyLength = key.Length;\n            StringBuilder result = new StringBuilder(sourceLength);\n            for (int i = 0; i < sourceLength; i++)\n            {\n                result.Append((char)(source[i] ^ key[i % keyLength]));\n            }\n            return result.ToString();\n        }\n    }\n}\n"]}
{"filename": "Constants/TransferConstants.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Moadian.Constants\n{\n    public static class TransferConstants\n    {\n        public const string AUTHORIZATION_HEADER = \"Authorization\";", "    public static class TransferConstants\n    {\n        public const string AUTHORIZATION_HEADER = \"Authorization\";\n        public const string REQUEST_TRACE_ID_HEADER = \"requestTraceId\";\n        public const string TIMESTAMP_HEADER = \"timestamp\";\n    }\n}\n"]}
{"filename": "Constants/PacketType.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Moadian.Constants\n{\n    public static class PacketType\n    {\n        public const string GET_TOKEN = \"GET_TOKEN\";", "    public static class PacketType\n    {\n        public const string GET_TOKEN = \"GET_TOKEN\";\n        public const string GET_FISCAL_INFORMATION = \"GET_FISCAL_INFORMATION\";\n        public const string INVOICE_V01 = \"INVOICE.V01\";\n        public const string PACKET_TYPE_INQUIRY_BY_REFERENCE_NUMBER = \"INQUIRY_BY_REFERENCE_NUMBER\";\n        public const string GET_ECONOMIC_CODE_INFORMATION = \"GET_ECONOMIC_CODE_INFORMATION\";\n    }\n}\n"]}
{"filename": "Dto/PrimitiveDto.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Moadian.Dto\n{\n    public abstract class PrimitiveDto\n    {\n        public Dictionary<string, object> ToArray()\n        {\n            var reflection = GetType();\n            var properties = reflection.GetProperties(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);\n\n            var array = new Dictionary<string, object>();\n", "{\n    public abstract class PrimitiveDto\n    {\n        public Dictionary<string, object> ToArray()\n        {\n            var reflection = GetType();\n            var properties = reflection.GetProperties(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);\n\n            var array = new Dictionary<string, object>();\n\n            foreach (var property in properties)\n            {", "            foreach (var property in properties)\n            {\n                if (property.GetValue(this) != null)\n                {\n                    var value = property.GetValue(this);\n\n                    if (value is string || value is int || value is null || value is decimal || value is bool)\n                    {\n                        array[property.Name] = value;\n                    }\n                    else\n                    {\n                        array[property.Name] = ((PrimitiveDto)value).ToArray();\n                    }\n                }\n            }\n\n            return array;\n        }\n    }\n\n}\n"]}
{"filename": "Dto/InvoiceBodyDto.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Moadian.Dto\n{\n    public class InvoiceBodyDto : PrimitiveDto\n    {\n        // service stuff ID\n        public string? sstid { get; set; }\n        // service stuff title", "    public class InvoiceBodyDto : PrimitiveDto\n    {\n        // service stuff ID\n        public string? sstid { get; set; }\n        // service stuff title\n        public string sstt { get; set; }\n\n        // amount\n        public int am { get; set; }\n\n        // measurement unit", "        public int am { get; set; }\n\n        // measurement unit\n        public string mu { get; set; }\n\n        // fee (pure price per item)\n        public int fee { get; set; }\n\n        // fee in foreign currency\n        public float? cfee { get; set; }\n\n        // currency type\n        public string? cut { get; set; }\n\n        // exchange rate\n        public int? exr { get; set; }\n\n        // pre discount", "        public int prdis { get; set; }\n\n        // discount\n        public int dis { get; set; }\n\n        // after discount\n        public int adis { get; set; }\n\n        // VAT rate\n        public int vra { get; set; }\n\n        // VAT amount", "        public int vra { get; set; }\n\n        // VAT amount\n        public int vam { get; set; }\n\n        // over duty title\n        public string? odt { get; set; }\n\n        // over duty rate\n        public float? odr { get; set; }\n\n        // over duty amount\n        public int? odam { get; set; }\n\n        // other legal title\n        public string? olt { get; set; }\n\n        // other legal rate\n        public float? olr { get; set; }\n\n        // other legal amount\n        public int? olam { get; set; }\n\n        // construction fee\n        public int? consfee { get; set; }\n\n        // seller profit\n        public int? spro { get; set; }\n\n        // broker salary\n        public int? bros { get; set; }\n\n        // total construction profit broker salary\n        public int? tcpbs { get; set; }\n\n        // cash share of payment\n        public int? cop { get; set; }\n\n        // vat of payment\n        public string? vop { get; set; }\n\n        // buyer register number\n        public string? bsrn { get; set; }\n\n        // total service stuff amount", "        public int tsstam { get; set; }\n    }\n}"]}
{"filename": "Dto/InvoiceHeaderDto.cs", "chunked_list": ["\ufeffnamespace Moadian.Dto\n{\n    public class InvoiceHeaderDto : PrimitiveDto\n    {\n        /**\n         * unique tax ID (should be generated using InvoiceIdService)\n         */\n        public string taxid { get; set; }\n\n        /**\n         * invoice timestamp (milliseconds from epoch)\n         */", "        public long indatim { get; set; }\n\n        /**\n         * invoice creation timestamp (milliseconds from epoch)\n         */\n        public long indati2m { get; set; }\n\n        /**\n         * invoice type\n         */\n        public int inty { get; set; }\n\n        /**\n         * internal invoice number\n         */", "        public int inty { get; set; }\n\n        /**\n         * internal invoice number\n         */\n        public string inno { get; set; }\n\n        /**\n         * invoice reference tax ID\n         */\n        public string irtaxid { get; set; }\n\n        /**\n         * invoice pattern\n         */", "        public string irtaxid { get; set; }\n\n        /**\n         * invoice pattern\n         */\n        public int inp { get; set; }\n\n        /**\n         * invoice subject\n         */\n        public int ins { get; set; }\n\n        /**\n         * seller tax identification number\n         */", "        public int ins { get; set; }\n\n        /**\n         * seller tax identification number\n         */\n        public string tins { get; set; }\n\n        /**\n         * type of buyer\n         */\n        public int? tob { get; set; }\n\n        /**\n         * buyer ID\n         */", "        public string bid { get; set; }\n\n        /**\n         * buyer tax identification number\n         */\n        public string tinb { get; set; }\n\n        /**\n         * seller branch code\n         */\n        public string sbc { get; set; }\n\n        /**\n         * buyer postal code\n         */", "        public string sbc { get; set; }\n\n        /**\n         * buyer postal code\n         */\n        public string bpc { get; set; }\n\n        /**\n         * buyer branch code\n         */\n        public string bbc { get; set; }\n\n        /**\n         * flight type\n         */\n        public int? ft { get; set; }\n\n        /**\n         * buyer passport number\n         */", "        public string bbc { get; set; }\n\n        /**\n         * flight type\n         */\n        public int? ft { get; set; }\n\n        /**\n         * buyer passport number\n         */\n        public string bpn { get; set; }\n\n        /**\n         * seller customs licence number\n         */\n        public int? scln { get; set; }\n\n        /**\n         * seller customs code\n         */", "        public string bpn { get; set; }\n\n        /**\n         * seller customs licence number\n         */\n        public int? scln { get; set; }\n\n        /**\n         * seller customs code\n         */\n        public string scc { get; set; }\n\n        /**\n         * contract registration number\n         */\n        public int? crn { get; set; }\n\n        /**\n         * billing ID\n         */", "        public string scc { get; set; }\n\n        /**\n         * contract registration number\n         */\n        public int? crn { get; set; }\n\n        /**\n         * billing ID\n         */\n        public string billid { get; set; }\n\n        /**\n         * total pre discount\n         */", "        public string billid { get; set; }\n\n        /**\n         * total pre discount\n         */\n        public int tprdis { get; set; }\n\n        /**\n         * total discount\n         */\n        public int tdis { get; set; }\n\n        /**\n         * total after discount\n         */", "        public int tdis { get; set; }\n\n        /**\n         * total after discount\n         */\n        public int tadis { get; set; }\n\n        /**\n         * total VAT amount\n         */\n        public int tvam { get; set; }\n\n        /**\n         * total other duty amount\n         */", "        public int tvam { get; set; }\n\n        /**\n         * total other duty amount\n         */\n        public int todam { get; set; }\n\n        /**\n         * total bill\n         */\n        public int tbill { get; set; }\n\n        /**\n         * settlement type\n         */\n        public int? setm { get; set; }\n\n        /**\n         * cash payment\n         */\n        public int? cap { get; set; }\n\n        /**\n         * installment payment\n         */\n        public int? insp { get; set; }\n\n        /**\n         * total VAT of payment\n         */", "        public int tbill { get; set; }\n\n        /**\n         * settlement type\n         */\n        public int? setm { get; set; }\n\n        /**\n         * cash payment\n         */\n        public int? cap { get; set; }\n\n        /**\n         * installment payment\n         */\n        public int? insp { get; set; }\n\n        /**\n         * total VAT of payment\n         */", "        public int tvop { get; set; }\n\n        /**\n         * tax17\n         */\n        public int tax17 { get; set; }\n    }\n}\n"]}
{"filename": "Dto/InquiryByReferenceNumberDto.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Moadian.Dto\n{\n    public class InquiryByReferenceNumberDto : PrimitiveDto\n    {\n        private string[] referenceNumber;\n", "    public class InquiryByReferenceNumberDto : PrimitiveDto\n    {\n        private string[] referenceNumber;\n\n        public void SetReferenceNumber(string referenceNumber)\n        {\n            this.referenceNumber = new string[] { referenceNumber };\n        }\n\n        public string[] GetReferenceNumber()\n        {\n            return referenceNumber;\n        }\n    }\n}\n"]}
{"filename": "Dto/PacketDataInterface.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Moadian.Dto\n{\n    public interface PacketDataInterface\n    {\n        public Dictionary<string, object> ToArray(); \n    }\n}\n", "    public interface PacketDataInterface\n    {\n        public Dictionary<string, object> ToArray(); \n    }\n}\n"]}
{"filename": "Dto/TokenModel.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Moadian.Dto\n{\n    public class TokenModel\n    {\n        public TokenModel(string token, int expiresAt)\n        {\n            this.Token = token;\n            this.ExpiresAt = expiresAt;\n        }\n", "    public class TokenModel\n    {\n        public TokenModel(string token, int expiresAt)\n        {\n            this.Token = token;\n            this.ExpiresAt = expiresAt;\n        }\n\n        public string Token { get; }\n\n        public int ExpiresAt { get; }\n", "        public string Token { get; }\n\n        public int ExpiresAt { get; }\n\n        public bool IsExpired()\n        {\n            return (int)(DateTime.UtcNow - new DateTime(1970, 1, 1)).TotalMilliseconds >= (this.ExpiresAt - 100 * 1000);\n        }\n    }\n}\n"]}
{"filename": "Dto/Packet.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Moadian.Dto\n{\n    using System;\n\n    public class Packet : PrimitiveDto\n    {", "    using System;\n\n    public class Packet : PrimitiveDto\n    {\n        public string uid { get; set; } = \"\";\n        public string packetType { get; set; } = \"\";\n        public bool retry { get; set; } = false;\n        public object data { get; set; } = null;\n        public string encryptionKeyId { get; set; } = null;\n        public string symmetricKey { get; set; } = null;\n        public string iv { get; set; } = null;", "        public string encryptionKeyId { get; set; } = null;\n        public string symmetricKey { get; set; } = null;\n        public string iv { get; set; } = null;\n        public string fiscalId { get; set; } = \"\";\n        public string dataSignature { get; set; } = null;\n        public string signatureKeyId { get; set; } = null;\n\n        public Packet(string packetType, object data = null)\n        {\n            this.packetType = packetType;\n            this.data = data;\n            this.uid = Guid.NewGuid().ToString();\n        }\n", "        //public object ToArray()\n        //{\n        //    if (this.signatureKeyId != null)\n        //    {\n        //        var array = new\n        //        {\n        //            uid = this.uid,\n        //            packetType = this.packetType,\n        //            retry = this.retry,\n        //            data = this.data is string ? this.data : ((PacketDataInterface)this.data)?.ToArray(),\n        //            encryptionKeyId = this.encryptionKeyId,\n        //            symmetricKey = this.symmetricKey,\n        //            iv = this.iv,\n        //            fiscalId = this.fiscalId,\n        //            dataSignature = this.dataSignature,\n        //            signatureKeyId = this.signatureKeyId\n        //        };\n        //        return array;\n        //    }\n        //    else\n        //    {\n        //        var array = new\n        //        {\n        //            uid = this.uid,\n        //            packetType = this.packetType,\n        //            retry = this.retry,\n        //            data = this.data is string ? this.data : ((PacketDataInterface)this.data)?.ToArray(),\n        //            encryptionKeyId = this.encryptionKeyId,\n        //            symmetricKey = this.symmetricKey,\n        //            iv = this.iv,\n        //            fiscalId = this.fiscalId,\n        //            dataSignature = this.dataSignature,\n        //        };\n\n        //        return array;\n        //    }\n        //}\n    }\n\n}\n"]}
{"filename": "Dto/InvoiceDto.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n    \nnamespace Moadian.Dto\n{\n    public class InvoiceDto : PrimitiveDto\n    {\n        public InvoiceHeaderDto header { get; set; }\n        public List<InvoiceBodyDto> body { get; set; }\n        public List<InvoicePaymentDto> payments { get; set; }\n         \n    }\n}\n", "    public class InvoiceDto : PrimitiveDto\n    {\n        public InvoiceHeaderDto header { get; set; }\n        public List<InvoiceBodyDto> body { get; set; }\n        public List<InvoicePaymentDto> payments { get; set; }\n         \n    }\n}\n"]}
{"filename": "Dto/GetTokenDto.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Moadian.Dto\n{\n    public class GetTokenDto : PrimitiveDto\n    {\n        public string username { get; set; }\n    }\n}\n", "    public class GetTokenDto : PrimitiveDto\n    {\n        public string username { get; set; }\n    }\n}\n"]}
{"filename": "Dto/InvoicePaymentDto.cs", "chunked_list": ["\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Moadian.Dto\n{\n    public class InvoicePaymentDto : PrimitiveDto\n    {\n        private string? iinn;\n        private string? acn;\n        private string? trmn;\n        private string? trn;\n        private string? pcn;\n        private string? pid;\n        private int? pmt;\n        private int? pdt;\n\n        public string? Iinn\n        {\n            get { return iinn; }\n            set { iinn = value; }\n        }\n\n        public string? Acn\n        {\n            get { return acn; }\n            set { acn = value; }\n        }\n\n        public string? Trmn\n        {\n            get { return trmn; }\n            set { trmn = value; }\n        }\n\n        public string? Trn\n        {\n            get { return trn; }\n            set { trn = value; }\n        }\n\n        public string? Pcn\n        {\n            get { return pcn; }\n            set { pcn = value; }\n        }\n\n        public string? Pid\n        {\n            get { return pid; }\n            set { pid = value; }\n        }\n\n        public int? Pmt\n        {\n            get { return pmt; }\n            set { pmt = value; }\n        }\n\n        public int? Pdt\n        {\n            get { return pdt; }\n            set { pdt = value; }\n        }\n    }\n}\n", "    public class InvoicePaymentDto : PrimitiveDto\n    {\n        private string? iinn;\n        private string? acn;\n        private string? trmn;\n        private string? trn;\n        private string? pcn;\n        private string? pid;\n        private int? pmt;\n        private int? pdt;\n\n        public string? Iinn\n        {\n            get { return iinn; }\n            set { iinn = value; }\n        }\n\n        public string? Acn\n        {\n            get { return acn; }\n            set { acn = value; }\n        }\n\n        public string? Trmn\n        {\n            get { return trmn; }\n            set { trmn = value; }\n        }\n\n        public string? Trn\n        {\n            get { return trn; }\n            set { trn = value; }\n        }\n\n        public string? Pcn\n        {\n            get { return pcn; }\n            set { pcn = value; }\n        }\n\n        public string? Pid\n        {\n            get { return pid; }\n            set { pid = value; }\n        }\n\n        public int? Pmt\n        {\n            get { return pmt; }\n            set { pmt = value; }\n        }\n\n        public int? Pdt\n        {\n            get { return pdt; }\n            set { pdt = value; }\n        }\n    }\n}\n"]}
