{"filename": "vite.config.ts", "chunked_list": ["/// <reference types=\"vitest\" />\n\t// Configure Vitest (https://vitest.dev/config/)\n\timport { defineConfig } from 'vite'\n\texport default defineConfig({\n\t  test: {\n\t    /* for example, use global to avoid globals imports (describe, test, expect): */\n\t    // globals: true,\n\t  },\n\t});\n"]}
{"filename": "test/test-app-bun-oauth.ts", "chunked_list": ["import { SlackAPIClient } from \"slack-web-api-client\";\n\timport {\n\t  Authorize,\n\t  SlackOAuthApp,\n\t  SlackOAuthEnv,\n\t  AuthorizeError,\n\t  Installation,\n\t  InstallationStore,\n\t  InstallationStoreQuery,\n\t} from \"../src/index\";\n", "class FileInstallationStore implements InstallationStore<SlackOAuthEnv> {\n\t  async save(\n\t    installation: Installation,\n\t    _request: Request | undefined\n\t  ): Promise<void> {\n\t    await Bun.write(\n\t      `./tmp/${installation.team_id}.json`,\n\t      JSON.stringify(installation)\n\t    );\n\t    await Bun.write(\n", "      `./tmp/${installation.team_id}-${installation.user_id}.json`,\n\t      JSON.stringify(installation)\n\t    );\n\t  }\n\t  async findBotInstallation(\n\t    query: InstallationStoreQuery\n\t  ): Promise<Installation | undefined> {\n\t    return await Bun.file(`./tmp/${query.teamId}.json`).json();\n\t  }\n\t  async findUserInstallation(\n", "    query: InstallationStoreQuery\n\t  ): Promise<Installation | undefined> {\n\t    return await Bun.file(`./tmp/${query.teamId}-${query.userId}.json`).json();\n\t  }\n\t  toAuthorize(): Authorize<SlackOAuthEnv> {\n\t    return async (req) => {\n\t      // Note that this implementation supports only bot token resolution\n\t      const installation = await this.findBotInstallation(req.context);\n\t      if (installation) {\n\t        const client = new SlackAPIClient();\n", "        const authTest = await client.auth.test({\n\t          token: installation.bot_token,\n\t        });\n\t        return {\n\t          enterpriseId: installation?.enterprise_id,\n\t          teamId: installation?.team_id,\n\t          botId: authTest.bot_id,\n\t          botUserId: installation.bot_user_id,\n\t          botToken: installation.bot_token,\n\t          botScopes: installation.bot_scopes,\n", "        };\n\t      }\n\t      throw new AuthorizeError(\n\t        `Failed to resolve the associated installation: ${req.context.teamId}`\n\t      );\n\t    };\n\t  }\n\t}\n\tconst app = new SlackOAuthApp({\n\t  env: {\n", "    SLACK_SIGNING_SECRET: process.env.SLACK_SIGNING_SECRET!,\n\t    SLACK_CLIENT_ID: process.env.SLACK_CLIENT_ID!,\n\t    SLACK_CLIENT_SECRET: process.env.SLACK_CLIENT_SECRET!,\n\t    SLACK_BOT_SCOPES: \"app_mentions:read,chat:write,channels:history,commands\",\n\t    SLACK_LOGGING_LEVEL: \"DEBUG\",\n\t  },\n\t  installationStore: new FileInstallationStore(),\n\t});\n\tapp.event(\"app_mention\", async ({ context, payload }) => {\n\t  console.log(payload);\n", "  await context.say({ text: \"Hey!\" });\n\t});\n\tapp.message(\"hey\", async ({ context }) => {\n\t  await context.say({ text: \"Hey!\" });\n\t});\n\tapp.event(\"message\", async () => {});\n\tapp.shortcut(\n\t  \"hello\",\n\t  async () => {},\n\t  async ({ context, payload }) => {\n", "    await context.client.views.open({\n\t      trigger_id: payload.trigger_id,\n\t      view: {\n\t        type: \"modal\",\n\t        callback_id: \"foo\",\n\t        title: { type: \"plain_text\", text: \"My App\" },\n\t        close: { type: \"plain_text\", text: \"Cancel\" },\n\t        blocks: [\n\t          {\n\t            type: \"section\",\n", "            text: {\n\t              type: \"plain_text\",\n\t              text: \"This is a plain text section block.\",\n\t            },\n\t          },\n\t        ],\n\t      },\n\t    });\n\t  }\n\t);\n", "// bun run --watch test/test-app-bun-oauth.ts\n\t// ngrok http 3000 --subdomain your-domain\n\texport default {\n\t  port: 3000,\n\t  async fetch(request) {\n\t    return await app.run(request);\n\t  },\n\t};\n"]}
{"filename": "test/oauth-app.test.ts", "chunked_list": ["import { assert, test, describe } from \"vitest\";\n\timport {\n\t  SlackOAuthApp,\n\t  InstallationStore,\n\t  SlackOAuthEnv,\n\t  Installation,\n\t  InstallationStoreQuery,\n\t  Authorize,\n\t} from \"../src/index\";\n\tclass MemoryInstallationStore implements InstallationStore<SlackOAuthEnv> {\n", "  async save(\n\t    installation: Installation,\n\t    request: Request | undefined\n\t  ): Promise<void> {\n\t    throw new Error();\n\t  }\n\t  async findBotInstallation(\n\t    query: InstallationStoreQuery\n\t  ): Promise<Installation | undefined> {\n\t    throw new Error();\n", "  }\n\t  async findUserInstallation(\n\t    query: InstallationStoreQuery\n\t  ): Promise<Installation | undefined> {\n\t    throw new Error();\n\t  }\n\t  toAuthorize(): Authorize<SlackOAuthEnv> {\n\t    return async (req) => {\n\t      throw new Error();\n\t    };\n", "  }\n\t}\n\tdescribe(\"SlackOAuthApp\", () => {\n\t  test(\"Initialization\", () => {\n\t    const app = new SlackOAuthApp({\n\t      env: {\n\t        SLACK_CLIENT_ID: \"111.222\",\n\t        SLACK_CLIENT_SECRET: \"xxx\",\n\t        SLACK_BOT_SCOPES: \"commands,chat:write\",\n\t        SLACK_SIGNING_SECRET: \"test\",\n", "      },\n\t      installationStore: new MemoryInstallationStore(),\n\t    });\n\t    assert.exists(app.client);\n\t  });\n\t});\n"]}
{"filename": "test/test-app-deno.ts", "chunked_list": ["import { SlackApp } from \"../src_deno/app.ts\";\n\tconst app = new SlackApp({\n\t  env: {\n\t    SLACK_SIGNING_SECRET: Deno.env.get(\"SLACK_SIGNING_SECRET\"),\n\t    SLACK_BOT_TOKEN: Deno.env.get(\"SLACK_BOT_TOKEN\"),\n\t    SLACK_LOGGING_LEVEL: \"DEBUG\",\n\t  },\n\t});\n\tapp.event(\"app_mention\", async ({ context, payload }) => {\n\t  console.log(payload);\n", "  await context.say({ text: \"Hey!\" });\n\t});\n\tapp.message(\"hey\", async ({ context }) => {\n\t  await context.say({ text: \"Hey!\" });\n\t});\n\tapp.event(\"message\", async () => {});\n\tapp.shortcut(\n\t  \"hello\",\n\t  async () => {},\n\t  async ({ context, payload }) => {\n", "    await context.client.views.open({\n\t      trigger_id: payload.trigger_id,\n\t      view: {\n\t        type: \"modal\",\n\t        title: { type: \"plain_text\", text: \"My App\" },\n\t        close: { type: \"plain_text\", text: \"Cancel\" },\n\t        blocks: [\n\t          {\n\t            type: \"section\",\n\t            text: {\n", "              type: \"plain_text\",\n\t              text: \"This is a plain text section block.\",\n\t            },\n\t          },\n\t        ],\n\t      },\n\t    });\n\t  }\n\t);\n\t// deno run --watch --allow-net --allow-env test/test-app-deno.ts\n", "// ngrok http 3000 --subdomain your-domain\n\timport { serve } from \"https://deno.land/std@0.192.0/http/server.ts\";\n\tawait serve(\n\t  async (request) => {\n\t    return await app.run(request);\n\t  },\n\t  { port: 3000 }\n\t);\n"]}
{"filename": "test/errors.test.ts", "chunked_list": ["import { assert, test, describe } from \"vitest\";\n\timport { ConfigError, AuthorizeError } from \"../src/index\";\n\tdescribe(\"Errors\", () => {\n\t  test(\"ConfigError\", () => {\n\t    const error = new ConfigError(\"test\");\n\t    assert.equal(error.toString(), \"ConfigError: test\");\n\t  });\n\t  test(\"AuthorizeError\", () => {\n\t    const error = new AuthorizeError(\"test\");\n\t    assert.equal(error.toString(), \"AuthorizeError: test\");\n", "  });\n\t});\n"]}
{"filename": "test/app.test.ts", "chunked_list": ["import { assert, test, describe } from \"vitest\";\n\timport { SlackApp } from \"../src/index\";\n\tdescribe(\"SlackApp\", () => {\n\t  test(\"initialization\", () => {\n\t    const app = new SlackApp({\n\t      env: { SLACK_SIGNING_SECRET: \"test\", SLACK_BOT_TOKEN: \"xoxb-\" },\n\t    });\n\t    assert.exists(app.client);\n\t  });\n\t});\n"]}
{"filename": "test/test-app-bun.ts", "chunked_list": ["import { SlackApp } from \"../src/app\";\n\tconst app = new SlackApp({\n\t  env: {\n\t    SLACK_SIGNING_SECRET: process.env.SLACK_SIGNING_SECRET!,\n\t    SLACK_BOT_TOKEN: process.env.SLACK_BOT_TOKEN,\n\t    SLACK_LOGGING_LEVEL: \"DEBUG\",\n\t  },\n\t});\n\tapp.event(\"app_mention\", async ({ context, payload }) => {\n\t  console.log(payload);\n", "  await context.say({ text: \"Hey!\" });\n\t});\n\tapp.message(\"hey\", async ({ context }) => {\n\t  await context.say({ text: \"Hey!\" });\n\t});\n\tapp.event(\"message\", async () => {});\n\tapp.shortcut(\n\t  \"hello\",\n\t  async () => {},\n\t  async ({ context, payload }) => {\n", "    await context.client.views.open({\n\t      trigger_id: payload.trigger_id,\n\t      view: {\n\t        type: \"modal\",\n\t        callback_id: \"foo\",\n\t        title: { type: \"plain_text\", text: \"My App\" },\n\t        close: { type: \"plain_text\", text: \"Cancel\" },\n\t        blocks: [\n\t          {\n\t            type: \"section\",\n", "            text: {\n\t              type: \"plain_text\",\n\t              text: \"This is a plain text section block.\",\n\t            },\n\t          },\n\t        ],\n\t      },\n\t    });\n\t  }\n\t);\n", "// bun run --watch test/test-app-bun.ts\n\t// ngrok http 3000 --subdomain your-domain\n\texport default {\n\t  port: 3000,\n\t  async fetch(request) {\n\t    return await app.run(request);\n\t  },\n\t};\n"]}
{"filename": "test/test-socket-mode-app-deno.ts", "chunked_list": ["import { SlackApp } from \"../src_deno/mod.ts\";\n\tconst app = new SlackApp({\n\t  env: {\n\t    SLACK_BOT_TOKEN: Deno.env.get(\"SLACK_BOT_TOKEN\"),\n\t    SLACK_APP_TOKEN: Deno.env.get(\"SLACK_APP_TOKEN\"),\n\t    SLACK_LOGGING_LEVEL: \"DEBUG\",\n\t  },\n\t});\n\tapp.event(\"app_mention\", async ({ context, payload }) => {\n\t  console.log(payload);\n", "  await context.say({ text: \"Hey!\" });\n\t});\n\tapp.message(\"hey\", async ({ context }) => {\n\t  await context.say({ text: \"Hey!\" });\n\t});\n\tapp.event(\"message\", async () => {});\n\tapp.shortcut(\n\t  \"hello\",\n\t  async () => {},\n\t  async ({ context, payload }) => {\n", "    await context.client.views.open({\n\t      trigger_id: payload.trigger_id,\n\t      view: {\n\t        type: \"modal\",\n\t        title: { type: \"plain_text\", text: \"My App\" },\n\t        close: { type: \"plain_text\", text: \"Cancel\" },\n\t        blocks: [\n\t          {\n\t            type: \"section\",\n\t            text: {\n", "              type: \"plain_text\",\n\t              text: \"This is a plain text section block.\",\n\t            },\n\t          },\n\t        ],\n\t      },\n\t    });\n\t  }\n\t);\n\tapp.command(\"/hello\", async () => \"Hello!\");\n", "// deno run --watch --allow-net --allow-env test/test-socket-mode-app-deno.ts\n\tawait app.connect();\n\tsetTimeout(() => {}, Number.MAX_SAFE_INTEGER);\n"]}
{"filename": "test/test-app-deno-oauth.ts", "chunked_list": ["import { SlackAPIClient } from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\timport {\n\t  Authorize,\n\t  SlackOAuthApp,\n\t  SlackOAuthEnv,\n\t  AuthorizeError,\n\t  Installation,\n\t  InstallationStore,\n\t  InstallationStoreQuery,\n\t} from \"../src_deno/mod.ts\";\n", "class FileInstallationStore implements InstallationStore<SlackOAuthEnv> {\n\t  async save(\n\t    installation: Installation,\n\t    _request: Request | undefined\n\t  ): Promise<void> {\n\t    const encoder = new TextEncoder();\n\t    await Deno.writeFile(\n\t      `./tmp/${installation.team_id}.json`,\n\t      encoder.encode(JSON.stringify(installation))\n\t    );\n", "    await Deno.writeFile(\n\t      `./tmp/${installation.team_id}-${installation.user_id}.json`,\n\t      encoder.encode(JSON.stringify(installation))\n\t    );\n\t  }\n\t  async findBotInstallation(\n\t    query: InstallationStoreQuery\n\t  ): Promise<Installation | undefined> {\n\t    return JSON.parse(await Deno.readTextFile(`./tmp/${query.teamId}.json`));\n\t  }\n", "  async findUserInstallation(\n\t    query: InstallationStoreQuery\n\t  ): Promise<Installation | undefined> {\n\t    return JSON.parse(\n\t      await Deno.readTextFile(`./tmp/${query.teamId}-${query.userId}.json`)\n\t    );\n\t  }\n\t  toAuthorize(): Authorize<SlackOAuthEnv> {\n\t    return async (req) => {\n\t      // Note that this implementation supports only bot token resolution\n", "      const installation = await this.findBotInstallation(req.context);\n\t      if (installation) {\n\t        const client = new SlackAPIClient();\n\t        const authTest = await client.auth.test({\n\t          token: installation.bot_token,\n\t        });\n\t        return {\n\t          enterpriseId: installation?.enterprise_id,\n\t          teamId: installation?.team_id,\n\t          botId: authTest.bot_id,\n", "          botUserId: installation.bot_user_id,\n\t          botToken: installation.bot_token,\n\t          botScopes: installation.bot_scopes,\n\t        };\n\t      }\n\t      throw new AuthorizeError(\n\t        `Failed to resolve the associated installation: ${req.context.teamId}`\n\t      );\n\t    };\n\t  }\n", "}\n\tconst app = new SlackOAuthApp({\n\t  env: {\n\t    SLACK_SIGNING_SECRET: Deno.env.get(\"SLACK_SIGNING_SECRET\"),\n\t    SLACK_CLIENT_ID: Deno.env.get(\"SLACK_CLIENT_ID\"),\n\t    SLACK_CLIENT_SECRET: Deno.env.get(\"SLACK_CLIENT_SECRET\"),\n\t    SLACK_BOT_SCOPES: \"app_mentions:read,chat:write,channels:history,commands\",\n\t    SLACK_LOGGING_LEVEL: \"DEBUG\",\n\t  },\n\t  installationStore: new FileInstallationStore(),\n", "});\n\tapp.event(\"app_mention\", async ({ context, payload }) => {\n\t  console.log(payload);\n\t  await context.say({ text: \"Hey!\" });\n\t});\n\tapp.message(\"hey\", async ({ context }) => {\n\t  await context.say({ text: \"Hey!\" });\n\t});\n\tapp.event(\"message\", async () => {});\n\tapp.shortcut(\n", "  \"hello\",\n\t  async () => {},\n\t  async ({ context, payload }) => {\n\t    await context.client.views.open({\n\t      trigger_id: payload.trigger_id,\n\t      view: {\n\t        type: \"modal\",\n\t        callback_id: \"foo\",\n\t        title: { type: \"plain_text\", text: \"My App\" },\n\t        close: { type: \"plain_text\", text: \"Cancel\" },\n", "        blocks: [\n\t          {\n\t            type: \"section\",\n\t            text: {\n\t              type: \"plain_text\",\n\t              text: \"This is a plain text section block.\",\n\t            },\n\t          },\n\t        ],\n\t      },\n", "    });\n\t  }\n\t);\n\t// deno run --watch --allow-net --allow-env --allow-read --allow-write test/test-app-deno-oauth.ts\n\t// ngrok http 3000 --subdomain your-domain\n\timport { serve } from \"https://deno.land/std@0.192.0/http/server.ts\";\n\tawait serve(\n\t  async (request) => {\n\t    return await app.run(request);\n\t  },\n", "  { port: 3000 }\n\t);\n"]}
{"filename": "src_deno/oauth-app.ts", "chunked_list": ["import { ExecutionContext, NoopExecutionContext } from \"./execution-context.ts\";\n\timport { SlackApp } from \"./app.ts\";\n\timport { SlackOAuthEnv } from \"./app-env.ts\";\n\timport { InstallationStore } from \"./oauth/installation-store.ts\";\n\timport { NoStorageStateStore, StateStore } from \"./oauth/state-store.ts\";\n\timport {\n\t  renderCompletionPage,\n\t  renderStartPage,\n\t} from \"./oauth/oauth-page-renderer.ts\";\n\timport { generateAuthorizeUrl } from \"./oauth/authorize-url-generator.ts\";\n", "import { parse as parseCookie } from \"./cookie.ts\";\n\timport {\n\t  OAuthV2AccessResponse,\n\t  OpenIDConnectTokenResponse,\n\t  SlackAPIClient,\n\t} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\timport { toInstallation } from \"./oauth/installation.ts\";\n\timport {\n\t  AfterInstallation,\n\t  BeforeInstallation,\n", "  defaultOnFailure,\n\t  defaultOnStateValidationError,\n\t  OnFailure,\n\t  OnStateValidationError,\n\t} from \"./oauth/callback.ts\";\n\timport {\n\t  defaultOpenIDConnectCallback,\n\t  OpenIDConnectCallback,\n\t} from \"./oidc/callback.ts\";\n\timport { generateOIDCAuthorizeUrl } from \"./oidc/authorize-url-generator.ts\";\n", "import {\n\t  CompletionPageError,\n\t  InstallationError,\n\t  InstallationStoreError,\n\t  MissingCode,\n\t  OpenIDConnectError,\n\t} from \"./oauth/error-codes.ts\";\n\texport interface SlackOAuthAppOptions<E extends SlackOAuthEnv> {\n\t  env: E;\n\t  installationStore: InstallationStore<E>;\n", "  stateStore?: StateStore;\n\t  oauth?: {\n\t    stateCookieName?: string;\n\t    beforeInstallation?: BeforeInstallation;\n\t    afterInstallation?: AfterInstallation;\n\t    onFailure?: OnFailure;\n\t    onStateValidationError?: OnStateValidationError;\n\t    redirectUri?: string;\n\t  };\n\t  oidc?: {\n", "    stateCookieName?: string;\n\t    callback: OpenIDConnectCallback;\n\t    onFailure?: OnFailure;\n\t    onStateValidationError?: OnStateValidationError;\n\t    redirectUri?: string;\n\t  };\n\t  routes?: {\n\t    events: string;\n\t    oauth: { start: string; callback: string };\n\t    oidc?: { start: string; callback: string };\n", "  };\n\t}\n\texport class SlackOAuthApp<E extends SlackOAuthEnv> extends SlackApp<E> {\n\t  public env: E;\n\t  public installationStore: InstallationStore<E>;\n\t  public stateStore: StateStore;\n\t  public oauth: {\n\t    stateCookieName?: string;\n\t    beforeInstallation?: BeforeInstallation;\n\t    afterInstallation?: AfterInstallation;\n", "    onFailure: OnFailure;\n\t    onStateValidationError: OnStateValidationError;\n\t    redirectUri?: string;\n\t  };\n\t  public oidc?: {\n\t    stateCookieName?: string;\n\t    callback: OpenIDConnectCallback;\n\t    onFailure: OnFailure;\n\t    onStateValidationError: OnStateValidationError;\n\t    redirectUri?: string;\n", "  };\n\t  public routes: {\n\t    events: string;\n\t    oauth: { start: string; callback: string };\n\t    oidc?: { start: string; callback: string };\n\t  };\n\t  constructor(options: SlackOAuthAppOptions<E>) {\n\t    super({\n\t      env: options.env,\n\t      authorize: options.installationStore.toAuthorize(),\n", "      routes: { events: options.routes?.events ?? \"/slack/events\" },\n\t    });\n\t    this.env = options.env;\n\t    this.installationStore = options.installationStore;\n\t    this.stateStore = options.stateStore ?? new NoStorageStateStore();\n\t    this.oauth = {\n\t      stateCookieName: options.oauth?.stateCookieName ??\n\t        \"slack-app-oauth-state\",\n\t      onFailure: options.oauth?.onFailure ?? defaultOnFailure,\n\t      onStateValidationError: options.oauth?.onStateValidationError ??\n", "        defaultOnStateValidationError,\n\t      redirectUri: options.oauth?.redirectUri ?? this.env.SLACK_REDIRECT_URI,\n\t    };\n\t    if (options.oidc) {\n\t      this.oidc = {\n\t        stateCookieName: options.oidc.stateCookieName ?? \"slack-app-oidc-state\",\n\t        onFailure: options.oidc.onFailure ?? defaultOnFailure,\n\t        onStateValidationError: options.oidc.onStateValidationError ??\n\t          defaultOnStateValidationError,\n\t        callback: defaultOpenIDConnectCallback(this.env),\n", "        redirectUri: options.oidc.redirectUri ??\n\t          this.env.SLACK_OIDC_REDIRECT_URI,\n\t      };\n\t    } else {\n\t      this.oidc = undefined;\n\t    }\n\t    this.routes = options.routes ? options.routes : {\n\t      events: \"/slack/events\",\n\t      oauth: {\n\t        start: \"/slack/install\",\n", "        callback: \"/slack/oauth_redirect\",\n\t      },\n\t      oidc: {\n\t        start: \"/slack/login\",\n\t        callback: \"/slack/login/callback\",\n\t      },\n\t    };\n\t  }\n\t  async run(\n\t    request: Request,\n", "    ctx: ExecutionContext = new NoopExecutionContext(),\n\t  ): Promise<Response> {\n\t    const url = new URL(request.url);\n\t    if (request.method === \"GET\") {\n\t      if (url.pathname === this.routes.oauth.start) {\n\t        return await this.handleOAuthStartRequest(request);\n\t      } else if (url.pathname === this.routes.oauth.callback) {\n\t        return await this.handleOAuthCallbackRequest(request);\n\t      }\n\t      if (this.routes.oidc) {\n", "        if (url.pathname === this.routes.oidc.start) {\n\t          return await this.handleOIDCStartRequest(request);\n\t        } else if (url.pathname === this.routes.oidc.callback) {\n\t          return await this.handleOIDCCallbackRequest(request);\n\t        }\n\t      }\n\t    } else if (request.method === \"POST\") {\n\t      if (url.pathname === this.routes.events) {\n\t        return await this.handleEventRequest(request, ctx);\n\t      }\n", "    }\n\t    return new Response(\"Not found\", { status: 404 });\n\t  }\n\t  async handleEventRequest(\n\t    request: Request,\n\t    ctx: ExecutionContext,\n\t  ): Promise<Response> {\n\t    return await super.handleEventRequest(request, ctx);\n\t  }\n\t  // deno-lint-ignore no-unused-vars\n", "  async handleOAuthStartRequest(request: Request): Promise<Response> {\n\t    const stateValue = await this.stateStore.issueNewState();\n\t    const authorizeUrl = generateAuthorizeUrl(stateValue, this.env);\n\t    return new Response(renderStartPage(authorizeUrl), {\n\t      status: 302,\n\t      headers: {\n\t        Location: authorizeUrl,\n\t        \"Set-Cookie\":\n\t          `${this.oauth.stateCookieName}=${stateValue}; Secure; HttpOnly; Path=/; Max-Age=300`,\n\t        \"Content-Type\": \"text/html; charset=utf-8\",\n", "      },\n\t    });\n\t  }\n\t  async handleOAuthCallbackRequest(request: Request): Promise<Response> {\n\t    // State parameter validation\n\t    await this.#validateStateParameter(\n\t      request,\n\t      this.routes.oauth.start,\n\t      this.oauth.stateCookieName!,\n\t    );\n", "    const { searchParams } = new URL(request.url);\n\t    const code = searchParams.get(\"code\");\n\t    if (!code) {\n\t      return await this.oauth.onFailure(\n\t        this.routes.oauth.start,\n\t        MissingCode,\n\t        request,\n\t      );\n\t    }\n\t    const client = new SlackAPIClient(undefined, {\n", "      logLevel: this.env.SLACK_LOGGING_LEVEL,\n\t    });\n\t    let oauthAccess: OAuthV2AccessResponse | undefined;\n\t    try {\n\t      // Execute the installation process\n\t      oauthAccess = await client.oauth.v2.access({\n\t        client_id: this.env.SLACK_CLIENT_ID,\n\t        client_secret: this.env.SLACK_CLIENT_SECRET,\n\t        redirect_uri: this.oauth.redirectUri,\n\t        code,\n", "      });\n\t    } catch (e) {\n\t      console.log(e);\n\t      return await this.oauth.onFailure(\n\t        this.routes.oauth.start,\n\t        InstallationError,\n\t        request,\n\t      );\n\t    }\n\t    try {\n", "      // Store the installation data on this app side\n\t      await this.installationStore.save(toInstallation(oauthAccess), request);\n\t    } catch (e) {\n\t      console.log(e);\n\t      return await this.oauth.onFailure(\n\t        this.routes.oauth.start,\n\t        InstallationStoreError,\n\t        request,\n\t      );\n\t    }\n", "    try {\n\t      // Build the completion page\n\t      const authTest = await client.auth.test({\n\t        token: oauthAccess.access_token,\n\t      });\n\t      const enterpriseUrl = authTest.url;\n\t      return new Response(\n\t        renderCompletionPage(\n\t          oauthAccess.app_id!,\n\t          oauthAccess.team?.id!,\n", "          oauthAccess.is_enterprise_install,\n\t          enterpriseUrl,\n\t        ),\n\t        {\n\t          status: 200,\n\t          headers: {\n\t            \"Set-Cookie\":\n\t              `${this.oauth.stateCookieName}=deleted; Secure; HttpOnly; Path=/; Max-Age=0`,\n\t            \"Content-Type\": \"text/html; charset=utf-8\",\n\t          },\n", "        },\n\t      );\n\t    } catch (e) {\n\t      console.log(e);\n\t      return await this.oauth.onFailure(\n\t        this.routes.oauth.start,\n\t        CompletionPageError,\n\t        request,\n\t      );\n\t    }\n", "  }\n\t  // deno-lint-ignore no-unused-vars\n\t  async handleOIDCStartRequest(request: Request): Promise<Response> {\n\t    if (!this.oidc) {\n\t      return new Response(\"Not found\", { status: 404 });\n\t    }\n\t    const stateValue = await this.stateStore.issueNewState();\n\t    const authorizeUrl = generateOIDCAuthorizeUrl(stateValue, this.env);\n\t    return new Response(renderStartPage(authorizeUrl), {\n\t      status: 302,\n", "      headers: {\n\t        Location: authorizeUrl,\n\t        \"Set-Cookie\":\n\t          `${this.oidc.stateCookieName}=${stateValue}; Secure; HttpOnly; Path=/; Max-Age=300`,\n\t        \"Content-Type\": \"text/html; charset=utf-8\",\n\t      },\n\t    });\n\t  }\n\t  async handleOIDCCallbackRequest(request: Request): Promise<Response> {\n\t    if (!this.oidc || !this.routes.oidc) {\n", "      return new Response(\"Not found\", { status: 404 });\n\t    }\n\t    // State parameter validation\n\t    await this.#validateStateParameter(\n\t      request,\n\t      this.routes.oidc.start,\n\t      this.oidc.stateCookieName!,\n\t    );\n\t    const { searchParams } = new URL(request.url);\n\t    const code = searchParams.get(\"code\");\n", "    if (!code) {\n\t      return await this.oidc.onFailure(\n\t        this.routes.oidc.start,\n\t        MissingCode,\n\t        request,\n\t      );\n\t    }\n\t    try {\n\t      const client = new SlackAPIClient(undefined, {\n\t        logLevel: this.env.SLACK_LOGGING_LEVEL,\n", "      });\n\t      const apiResponse: OpenIDConnectTokenResponse = await client.openid\n\t        .connect.token({\n\t          client_id: this.env.SLACK_CLIENT_ID,\n\t          client_secret: this.env.SLACK_CLIENT_SECRET,\n\t          redirect_uri: this.oidc.redirectUri,\n\t          code,\n\t        });\n\t      return await this.oidc.callback(apiResponse, request);\n\t    } catch (e) {\n", "      console.log(e);\n\t      return await this.oidc.onFailure(\n\t        this.routes.oidc.start,\n\t        OpenIDConnectError,\n\t        request,\n\t      );\n\t    }\n\t  }\n\t  async #validateStateParameter(\n\t    request: Request,\n", "    startPath: string,\n\t    cookieName: string,\n\t  ) {\n\t    const { searchParams } = new URL(request.url);\n\t    const queryState = searchParams.get(\"state\");\n\t    const cookie = parseCookie(request.headers.get(\"Cookie\") || \"\");\n\t    const cookieState = cookie[cookieName];\n\t    if (\n\t      queryState !== cookieState ||\n\t      !(await this.stateStore.consume(queryState))\n", "    ) {\n\t      if (startPath === this.routes.oauth.start) {\n\t        return await this.oauth.onStateValidationError(startPath, request);\n\t      } else if (\n\t        this.oidc &&\n\t        this.routes.oidc &&\n\t        startPath === this.routes.oidc.start\n\t      ) {\n\t        return await this.oidc.onStateValidationError(startPath, request);\n\t      }\n", "    }\n\t  }\n\t}\n"]}
{"filename": "src_deno/mod.ts", "chunked_list": ["export * from \"./index.ts\";\n"]}
{"filename": "src_deno/app.ts", "chunked_list": ["import {\n\t  SlackAppEnv,\n\t  SlackEdgeAppEnv,\n\t  SlackSocketModeAppEnv,\n\t} from \"./app-env.ts\";\n\timport { parseRequestBody } from \"./request/request-parser.ts\";\n\timport { verifySlackRequest } from \"./request/request-verification.ts\";\n\timport { AckResponse, SlackHandler } from \"./handler/handler.ts\";\n\timport { SlackRequestBody } from \"./request/request-body.ts\";\n\timport {\n", "  PreAuthorizeSlackMiddlwareRequest,\n\t  SlackMiddlwareRequest,\n\t  SlackRequest,\n\t  SlackRequestWithChannelId,\n\t  SlackRequestWithOptionalRespond,\n\t  SlackRequestWithRespond,\n\t} from \"./request/request.ts\";\n\timport { SlashCommand } from \"./request/payload/slash-command.ts\";\n\timport { toCompleteResponse } from \"./response/response.ts\";\n\timport {\n", "  AnySlackEvent,\n\t  AnySlackEventWithChannelId,\n\t  SlackEvent,\n\t} from \"./request/payload/event.ts\";\n\timport {\n\t  ResponseUrlSender,\n\t  SlackAPIClient,\n\t} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\timport {\n\t  builtBaseContext,\n", "  SlackAppContext,\n\t  SlackAppContextWithChannelId,\n\t  SlackAppContextWithRespond,\n\t} from \"./context/context.ts\";\n\timport { Middleware, PreAuthorizeMiddleware } from \"./middleware/middleware.ts\";\n\timport {\n\t  isDebugLogEnabled,\n\t  prettyPrint,\n\t} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\timport { Authorize } from \"./authorization/authorize.ts\";\n", "import { AuthorizeResult } from \"./authorization/authorize-result.ts\";\n\timport {\n\t  ignoringSelfEvents,\n\t  urlVerification,\n\t} from \"./middleware/built-in-middleware.ts\";\n\timport { ConfigError } from \"./errors.ts\";\n\timport { GlobalShortcut } from \"./request/payload/global-shortcut.ts\";\n\timport { MessageShortcut } from \"./request/payload/message-shortcut.ts\";\n\timport {\n\t  BlockAction,\n", "  BlockElementAction,\n\t  BlockElementTypes,\n\t} from \"./request/payload/block-action.ts\";\n\timport { ViewSubmission } from \"./request/payload/view-submission.ts\";\n\timport { ViewClosed } from \"./request/payload/view-closed.ts\";\n\timport { BlockSuggestion } from \"./request/payload/block-suggestion.ts\";\n\timport {\n\t  OptionsAckResponse,\n\t  SlackOptionsHandler,\n\t} from \"./handler/options-handler.ts\";\n", "import { SlackViewHandler, ViewAckResponse } from \"./handler/view-handler.ts\";\n\timport {\n\t  MessageAckResponse,\n\t  SlackMessageHandler,\n\t} from \"./handler/message-handler.ts\";\n\timport { singleTeamAuthorize } from \"./authorization/single-team-authorize.ts\";\n\timport { ExecutionContext, NoopExecutionContext } from \"./execution-context.ts\";\n\timport { PayloadType } from \"./request/payload-types.ts\";\n\timport { isPostedMessageEvent } from \"./utility/message-events.ts\";\n\timport { SocketModeClient } from \"./socket-mode/socket-mode-client.ts\";\n", "export interface SlackAppOptions<\n\t  E extends SlackEdgeAppEnv | SlackSocketModeAppEnv,\n\t> {\n\t  env: E;\n\t  authorize?: Authorize<E>;\n\t  routes?: {\n\t    events: string;\n\t  };\n\t  socketMode?: boolean;\n\t}\n", "export class SlackApp<E extends SlackEdgeAppEnv | SlackSocketModeAppEnv> {\n\t  public env: E;\n\t  public client: SlackAPIClient;\n\t  public authorize: Authorize<E>;\n\t  public routes: { events: string | undefined };\n\t  public signingSecret: string;\n\t  public appLevelToken: string | undefined;\n\t  public socketMode: boolean;\n\t  public socketModeClient: SocketModeClient | undefined;\n\t  // deno-lint-ignore no-explicit-any\n", "  public preAuthorizeMiddleware: PreAuthorizeMiddleware<any>[] = [\n\t    urlVerification,\n\t  ];\n\t  // deno-lint-ignore no-explicit-any\n\t  public postAuthorizeMiddleware: Middleware<any>[] = [ignoringSelfEvents];\n\t  #slashCommands: ((\n\t    body: SlackRequestBody,\n\t  ) => SlackMessageHandler<E, SlashCommand> | null)[] = [];\n\t  #events: ((\n\t    body: SlackRequestBody,\n", "  ) => SlackHandler<E, SlackEvent<string>> | null)[] = [];\n\t  #globalShorcuts: ((\n\t    body: SlackRequestBody,\n\t  ) => SlackHandler<E, GlobalShortcut> | null)[] = [];\n\t  #messageShorcuts: ((\n\t    body: SlackRequestBody,\n\t  ) => SlackHandler<E, MessageShortcut> | null)[] = [];\n\t  #blockActions: ((body: SlackRequestBody) =>\n\t    | SlackHandler<\n\t      E,\n", "      // deno-lint-ignore no-explicit-any\n\t      BlockAction<any>\n\t    >\n\t    | null)[] = [];\n\t  #blockSuggestions: ((\n\t    body: SlackRequestBody,\n\t  ) => SlackOptionsHandler<E, BlockSuggestion> | null)[] = [];\n\t  #viewSubmissions: ((\n\t    body: SlackRequestBody,\n\t  ) => SlackViewHandler<E, ViewSubmission> | null)[] = [];\n", "  #viewClosed: ((\n\t    body: SlackRequestBody,\n\t  ) => SlackViewHandler<E, ViewClosed> | null)[] = [];\n\t  constructor(options: SlackAppOptions<E>) {\n\t    if (\n\t      options.env.SLACK_BOT_TOKEN === undefined &&\n\t      (options.authorize === undefined ||\n\t        options.authorize === singleTeamAuthorize)\n\t    ) {\n\t      throw new ConfigError(\n", "        \"When you don't pass env.SLACK_BOT_TOKEN, your own authorize function, which supplies a valid token to use, needs to be passed instead.\",\n\t      );\n\t    }\n\t    this.env = options.env;\n\t    this.client = new SlackAPIClient(options.env.SLACK_BOT_TOKEN, {\n\t      logLevel: this.env.SLACK_LOGGING_LEVEL,\n\t    });\n\t    this.appLevelToken = options.env.SLACK_APP_TOKEN;\n\t    this.socketMode = options.socketMode ?? this.appLevelToken !== undefined;\n\t    if (this.socketMode) {\n", "      this.signingSecret = \"\";\n\t    } else {\n\t      if (!this.env.SLACK_SIGNING_SECRET) {\n\t        throw new ConfigError(\n\t          \"env.SLACK_SIGNING_SECRET is required to run your app on edge functions!\",\n\t        );\n\t      }\n\t      this.signingSecret = this.env.SLACK_SIGNING_SECRET;\n\t    }\n\t    this.authorize = options.authorize ?? singleTeamAuthorize;\n", "    this.routes = { events: options.routes?.events };\n\t  }\n\t  beforeAuthorize(middleware: PreAuthorizeMiddleware<E>): SlackApp<E> {\n\t    this.preAuthorizeMiddleware.push(middleware);\n\t    return this;\n\t  }\n\t  middleware(middleware: Middleware<E>): SlackApp<E> {\n\t    return this.afterAuthorize(middleware);\n\t  }\n\t  use(middleware: Middleware<E>): SlackApp<E> {\n", "    return this.afterAuthorize(middleware);\n\t  }\n\t  afterAuthorize(middleware: Middleware<E>): SlackApp<E> {\n\t    this.postAuthorizeMiddleware.push(middleware);\n\t    return this;\n\t  }\n\t  command(\n\t    pattern: StringOrRegExp,\n\t    ack: (\n\t      req: SlackRequestWithRespond<E, SlashCommand>,\n", "    ) => Promise<MessageAckResponse>,\n\t    lazy: (\n\t      req: SlackRequestWithRespond<E, SlashCommand>,\n\t    ) => Promise<void> = noopLazyListener,\n\t  ): SlackApp<E> {\n\t    const handler: SlackMessageHandler<E, SlashCommand> = { ack, lazy };\n\t    this.#slashCommands.push((body) => {\n\t      if (body.type || !body.command) {\n\t        return null;\n\t      }\n", "      if (typeof pattern === \"string\" && body.command === pattern) {\n\t        return handler;\n\t      } else if (\n\t        typeof pattern === \"object\" &&\n\t        pattern instanceof RegExp &&\n\t        body.command.match(pattern)\n\t      ) {\n\t        return handler;\n\t      }\n\t      return null;\n", "    });\n\t    return this;\n\t  }\n\t  event<Type extends string>(\n\t    event: Type,\n\t    lazy: (req: EventRequest<E, Type>) => Promise<void>,\n\t  ): SlackApp<E> {\n\t    this.#events.push((body) => {\n\t      if (body.type !== PayloadType.EventsAPI || !body.event) {\n\t        return null;\n", "      }\n\t      if (body.event.type === event) {\n\t        // deno-lint-ignore require-await\n\t        return { ack: async () => \"\", lazy };\n\t      }\n\t      return null;\n\t    });\n\t    return this;\n\t  }\n\t  anyMessage(lazy: MessageEventHandler<E>): SlackApp<E> {\n", "    return this.message(undefined, lazy);\n\t  }\n\t  message(\n\t    pattern: MessageEventPattern,\n\t    lazy: MessageEventHandler<E>,\n\t  ): SlackApp<E> {\n\t    this.#events.push((body) => {\n\t      if (\n\t        body.type !== PayloadType.EventsAPI ||\n\t        !body.event ||\n", "        body.event.type !== \"message\"\n\t      ) {\n\t        return null;\n\t      }\n\t      if (isPostedMessageEvent(body.event)) {\n\t        let matched = true;\n\t        if (pattern !== undefined) {\n\t          if (typeof pattern === \"string\") {\n\t            matched = body.event.text!.includes(pattern);\n\t          }\n", "          if (typeof pattern === \"object\") {\n\t            matched = body.event.text!.match(pattern) !== null;\n\t          }\n\t        }\n\t        if (matched) {\n\t          // deno-lint-ignore require-await\n\t          return { ack: async (_: EventRequest<E, \"message\">) => \"\", lazy };\n\t        }\n\t      }\n\t      return null;\n", "    });\n\t    return this;\n\t  }\n\t  shortcut(\n\t    callbackId: StringOrRegExp,\n\t    ack: (\n\t      req:\n\t        | SlackRequest<E, GlobalShortcut>\n\t        | SlackRequestWithRespond<E, MessageShortcut>,\n\t    ) => Promise<AckResponse>,\n", "    lazy: (\n\t      req:\n\t        | SlackRequest<E, GlobalShortcut>\n\t        | SlackRequestWithRespond<E, MessageShortcut>,\n\t    ) => Promise<void> = noopLazyListener,\n\t  ): SlackApp<E> {\n\t    return this.globalShortcut(callbackId, ack, lazy).messageShortcut(\n\t      callbackId,\n\t      ack,\n\t      lazy,\n", "    );\n\t  }\n\t  globalShortcut(\n\t    callbackId: StringOrRegExp,\n\t    ack: (req: SlackRequest<E, GlobalShortcut>) => Promise<AckResponse>,\n\t    lazy: (\n\t      req: SlackRequest<E, GlobalShortcut>,\n\t    ) => Promise<void> = noopLazyListener,\n\t  ): SlackApp<E> {\n\t    const handler: SlackHandler<E, GlobalShortcut> = { ack, lazy };\n", "    this.#globalShorcuts.push((body) => {\n\t      if (body.type !== PayloadType.GlobalShortcut || !body.callback_id) {\n\t        return null;\n\t      }\n\t      if (typeof callbackId === \"string\" && body.callback_id === callbackId) {\n\t        return handler;\n\t      } else if (\n\t        typeof callbackId === \"object\" &&\n\t        callbackId instanceof RegExp &&\n\t        body.callback_id.match(callbackId)\n", "      ) {\n\t        return handler;\n\t      }\n\t      return null;\n\t    });\n\t    return this;\n\t  }\n\t  messageShortcut(\n\t    callbackId: StringOrRegExp,\n\t    ack: (\n", "      req: SlackRequestWithRespond<E, MessageShortcut>,\n\t    ) => Promise<AckResponse>,\n\t    lazy: (\n\t      req: SlackRequestWithRespond<E, MessageShortcut>,\n\t    ) => Promise<void> = noopLazyListener,\n\t  ): SlackApp<E> {\n\t    const handler: SlackHandler<E, MessageShortcut> = { ack, lazy };\n\t    this.#messageShorcuts.push((body) => {\n\t      if (body.type !== PayloadType.MessageShortcut || !body.callback_id) {\n\t        return null;\n", "      }\n\t      if (typeof callbackId === \"string\" && body.callback_id === callbackId) {\n\t        return handler;\n\t      } else if (\n\t        typeof callbackId === \"object\" &&\n\t        callbackId instanceof RegExp &&\n\t        body.callback_id.match(callbackId)\n\t      ) {\n\t        return handler;\n\t      }\n", "      return null;\n\t    });\n\t    return this;\n\t  }\n\t  action<\n\t    T extends BlockElementTypes,\n\t    A extends BlockAction<BlockElementAction<T>> = BlockAction<\n\t      BlockElementAction<T>\n\t    >,\n\t  >(\n", "    constraints:\n\t      | StringOrRegExp\n\t      | { type: T; block_id?: string; action_id: string },\n\t    ack: (req: SlackRequestWithOptionalRespond<E, A>) => Promise<AckResponse>,\n\t    lazy: (\n\t      req: SlackRequestWithOptionalRespond<E, A>,\n\t    ) => Promise<void> = noopLazyListener,\n\t  ): SlackApp<E> {\n\t    const handler: SlackHandler<E, A> = { ack, lazy };\n\t    this.#blockActions.push((body) => {\n", "      if (\n\t        body.type !== PayloadType.BlockAction ||\n\t        !body.actions ||\n\t        !body.actions[0]\n\t      ) {\n\t        return null;\n\t      }\n\t      const action = body.actions[0];\n\t      if (typeof constraints === \"string\" && action.action_id === constraints) {\n\t        return handler;\n", "      } else if (typeof constraints === \"object\") {\n\t        if (constraints instanceof RegExp) {\n\t          if (action.action_id.match(constraints)) {\n\t            return handler;\n\t          }\n\t        } else if (constraints.type) {\n\t          if (action.type === constraints.type) {\n\t            if (action.action_id === constraints.action_id) {\n\t              if (\n\t                constraints.block_id &&\n", "                action.block_id !== constraints.block_id\n\t              ) {\n\t                return null;\n\t              }\n\t              return handler;\n\t            }\n\t          }\n\t        }\n\t      }\n\t      return null;\n", "    });\n\t    return this;\n\t  }\n\t  options(\n\t    constraints: StringOrRegExp | { block_id?: string; action_id: string },\n\t    ack: (req: SlackRequest<E, BlockSuggestion>) => Promise<OptionsAckResponse>,\n\t  ): SlackApp<E> {\n\t    // Note that block_suggestion response must be done within 3 seconds.\n\t    // So, we don't support the lazy handler for it.\n\t    const handler: SlackOptionsHandler<E, BlockSuggestion> = { ack };\n", "    this.#blockSuggestions.push((body) => {\n\t      if (body.type !== PayloadType.BlockSuggestion || !body.action_id) {\n\t        return null;\n\t      }\n\t      if (typeof constraints === \"string\" && body.action_id === constraints) {\n\t        return handler;\n\t      } else if (typeof constraints === \"object\") {\n\t        if (constraints instanceof RegExp) {\n\t          if (body.action_id.match(constraints)) {\n\t            return handler;\n", "          }\n\t        } else {\n\t          if (body.action_id === constraints.action_id) {\n\t            if (body.block_id && body.block_id !== constraints.block_id) {\n\t              return null;\n\t            }\n\t            return handler;\n\t          }\n\t        }\n\t      }\n", "      return null;\n\t    });\n\t    return this;\n\t  }\n\t  view(\n\t    callbackId: StringOrRegExp,\n\t    ack: (\n\t      req:\n\t        | SlackRequestWithOptionalRespond<E, ViewSubmission>\n\t        | SlackRequest<E, ViewClosed>,\n", "    ) => Promise<ViewAckResponse>,\n\t    lazy: (\n\t      req:\n\t        | SlackRequestWithOptionalRespond<E, ViewSubmission>\n\t        | SlackRequest<E, ViewClosed>,\n\t    ) => Promise<void> = noopLazyListener,\n\t  ): SlackApp<E> {\n\t    return this.viewSubmission(callbackId, ack, lazy).viewClosed(\n\t      callbackId,\n\t      ack,\n", "      lazy,\n\t    );\n\t  }\n\t  viewSubmission(\n\t    callbackId: StringOrRegExp,\n\t    ack: (\n\t      req: SlackRequestWithOptionalRespond<E, ViewSubmission>,\n\t    ) => Promise<ViewAckResponse>,\n\t    lazy: (\n\t      req: SlackRequestWithOptionalRespond<E, ViewSubmission>,\n", "    ) => Promise<void> = noopLazyListener,\n\t  ): SlackApp<E> {\n\t    const handler: SlackViewHandler<E, ViewSubmission> = { ack, lazy };\n\t    this.#viewSubmissions.push((body) => {\n\t      if (body.type !== PayloadType.ViewSubmission || !body.view) {\n\t        return null;\n\t      }\n\t      if (\n\t        typeof callbackId === \"string\" &&\n\t        body.view.callback_id === callbackId\n", "      ) {\n\t        return handler;\n\t      } else if (\n\t        typeof callbackId === \"object\" &&\n\t        callbackId instanceof RegExp &&\n\t        body.view.callback_id.match(callbackId)\n\t      ) {\n\t        return handler;\n\t      }\n\t      return null;\n", "    });\n\t    return this;\n\t  }\n\t  viewClosed(\n\t    callbackId: StringOrRegExp,\n\t    ack: (req: SlackRequest<E, ViewClosed>) => Promise<ViewAckResponse>,\n\t    lazy: (req: SlackRequest<E, ViewClosed>) => Promise<void> =\n\t      noopLazyListener,\n\t  ): SlackApp<E> {\n\t    const handler: SlackViewHandler<E, ViewClosed> = { ack, lazy };\n", "    this.#viewClosed.push((body) => {\n\t      if (body.type !== PayloadType.ViewClosed || !body.view) {\n\t        return null;\n\t      }\n\t      if (\n\t        typeof callbackId === \"string\" &&\n\t        body.view.callback_id === callbackId\n\t      ) {\n\t        return handler;\n\t      } else if (\n", "        typeof callbackId === \"object\" &&\n\t        callbackId instanceof RegExp &&\n\t        body.view.callback_id.match(callbackId)\n\t      ) {\n\t        return handler;\n\t      }\n\t      return null;\n\t    });\n\t    return this;\n\t  }\n", "  async run(\n\t    request: Request,\n\t    ctx: ExecutionContext = new NoopExecutionContext(),\n\t  ): Promise<Response> {\n\t    return await this.handleEventRequest(request, ctx);\n\t  }\n\t  async connect(): Promise<void> {\n\t    if (!this.socketMode) {\n\t      throw new ConfigError(\n\t        \"Both env.SLACK_APP_TOKEN and socketMode: true are required to start a Socket Mode connection!\",\n", "      );\n\t    }\n\t    this.socketModeClient = new SocketModeClient(this);\n\t    await this.socketModeClient.connect();\n\t  }\n\t  async disconnect(): Promise<void> {\n\t    if (this.socketModeClient) {\n\t      await this.socketModeClient.disconnect();\n\t    }\n\t  }\n", "  async handleEventRequest(\n\t    request: Request,\n\t    ctx: ExecutionContext,\n\t  ): Promise<Response> {\n\t    // If the routes.events is missing, any URLs can work for handing requests from Slack\n\t    if (this.routes.events) {\n\t      const { pathname } = new URL(request.url);\n\t      if (pathname !== this.routes.events) {\n\t        return new Response(\"Not found\", { status: 404 });\n\t      }\n", "    }\n\t    // To avoid the following warning by Cloudflware, parse the body as Blob first\n\t    // Called .text() on an HTTP body which does not appear to be text ..\n\t    const blobRequestBody = await request.blob();\n\t    // We can safely assume the incoming request body is always text data\n\t    const rawBody: string = await blobRequestBody.text();\n\t    // For Request URL verification\n\t    if (rawBody.includes(\"ssl_check=\")) {\n\t      // Slack does not send the x-slack-signature header for this pattern.\n\t      // Thus, we need to check the pattern before verifying a request.\n", "      const bodyParams = new URLSearchParams(rawBody);\n\t      if (bodyParams.get(\"ssl_check\") === \"1\" && bodyParams.get(\"token\")) {\n\t        return new Response(\"\", { status: 200 });\n\t      }\n\t    }\n\t    // Verify the request headers and body\n\t    const isRequestSignatureVerified = this.socketMode ||\n\t      (await verifySlackRequest(this.signingSecret, request.headers, rawBody));\n\t    if (isRequestSignatureVerified) {\n\t      // deno-lint-ignore no-explicit-any\n", "      const body: Record<string, any> = await parseRequestBody(\n\t        request.headers,\n\t        rawBody,\n\t      );\n\t      let retryNum: number | undefined = undefined;\n\t      try {\n\t        const retryNumHeader = request.headers.get(\"x-slack-retry-num\");\n\t        if (retryNumHeader) {\n\t          retryNum = Number.parseInt(retryNumHeader);\n\t        } else if (this.socketMode && body.retry_attempt) {\n", "          retryNum = Number.parseInt(body.retry_attempt);\n\t        }\n\t        // deno-lint-ignore no-unused-vars\n\t      } catch (e) {\n\t        // Ignore an exception here\n\t      }\n\t      const retryReason = request.headers.get(\"x-slack-retry-reason\") ??\n\t        body.retry_reason;\n\t      const preAuthorizeRequest: PreAuthorizeSlackMiddlwareRequest<E> = {\n\t        body,\n", "        rawBody,\n\t        retryNum,\n\t        retryReason,\n\t        context: builtBaseContext(body),\n\t        env: this.env,\n\t        headers: request.headers,\n\t      };\n\t      if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n\t        console.log(`*** Received request body ***\\n ${prettyPrint(body)}`);\n\t      }\n", "      for (const middlware of this.preAuthorizeMiddleware) {\n\t        const response = await middlware(preAuthorizeRequest);\n\t        if (response) {\n\t          return toCompleteResponse(response);\n\t        }\n\t      }\n\t      const authorizeResult: AuthorizeResult = await this.authorize(\n\t        preAuthorizeRequest,\n\t      );\n\t      const authorizedContext: SlackAppContext = {\n", "        ...preAuthorizeRequest.context,\n\t        authorizeResult,\n\t        client: new SlackAPIClient(authorizeResult.botToken, {\n\t          logLevel: this.env.SLACK_LOGGING_LEVEL,\n\t        }),\n\t        botToken: authorizeResult.botToken,\n\t        botId: authorizeResult.botId,\n\t        botUserId: authorizeResult.botUserId,\n\t        userToken: authorizeResult.userToken,\n\t      };\n", "      if (authorizedContext.channelId) {\n\t        const context = authorizedContext as SlackAppContextWithChannelId;\n\t        const client = new SlackAPIClient(context.botToken);\n\t        context.say = async (params) =>\n\t          await client.chat.postMessage({\n\t            channel: context.channelId,\n\t            ...params,\n\t          });\n\t      }\n\t      if (authorizedContext.responseUrl) {\n", "        const responseUrl = authorizedContext.responseUrl;\n\t        // deno-lint-ignore require-await\n\t        (authorizedContext as SlackAppContextWithRespond).respond = async (\n\t          params,\n\t        ) => {\n\t          return new ResponseUrlSender(responseUrl).call(params);\n\t        };\n\t      }\n\t      const baseRequest: SlackMiddlwareRequest<E> = {\n\t        ...preAuthorizeRequest,\n", "        context: authorizedContext,\n\t      };\n\t      for (const middlware of this.postAuthorizeMiddleware) {\n\t        const response = await middlware(baseRequest);\n\t        if (response) {\n\t          return toCompleteResponse(response);\n\t        }\n\t      }\n\t      const payload = body as SlackRequestBody;\n\t      if (body.type === PayloadType.EventsAPI) {\n", "        // Events API\n\t        const slackRequest: SlackRequest<E, SlackEvent<string>> = {\n\t          payload: body.event,\n\t          ...baseRequest,\n\t        };\n\t        for (const matcher of this.#events) {\n\t          const handler = matcher(payload);\n\t          if (handler) {\n\t            ctx.waitUntil(handler.lazy(slackRequest));\n\t            const slackResponse = await handler.ack(slackRequest);\n", "            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n\t              console.log(\n\t                `*** Slack response ***\\n${prettyPrint(slackResponse)}`,\n\t              );\n\t            }\n\t            return toCompleteResponse(slackResponse);\n\t          }\n\t        }\n\t      } else if (!body.type && body.command) {\n\t        // Slash commands\n", "        const slackRequest: SlackRequest<E, SlashCommand> = {\n\t          payload: body as SlashCommand,\n\t          ...baseRequest,\n\t        };\n\t        for (const matcher of this.#slashCommands) {\n\t          const handler = matcher(payload);\n\t          if (handler) {\n\t            ctx.waitUntil(handler.lazy(slackRequest));\n\t            const slackResponse = await handler.ack(slackRequest);\n\t            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n", "              console.log(\n\t                `*** Slack response ***\\n${prettyPrint(slackResponse)}`,\n\t              );\n\t            }\n\t            return toCompleteResponse(slackResponse);\n\t          }\n\t        }\n\t      } else if (body.type === PayloadType.GlobalShortcut) {\n\t        // Global shortcuts\n\t        const slackRequest: SlackRequest<E, GlobalShortcut> = {\n", "          payload: body as GlobalShortcut,\n\t          ...baseRequest,\n\t        };\n\t        for (const matcher of this.#globalShorcuts) {\n\t          const handler = matcher(payload);\n\t          if (handler) {\n\t            ctx.waitUntil(handler.lazy(slackRequest));\n\t            const slackResponse = await handler.ack(slackRequest);\n\t            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n\t              console.log(\n", "                `*** Slack response ***\\n${prettyPrint(slackResponse)}`,\n\t              );\n\t            }\n\t            return toCompleteResponse(slackResponse);\n\t          }\n\t        }\n\t      } else if (body.type === PayloadType.MessageShortcut) {\n\t        // Message shortcuts\n\t        const slackRequest: SlackRequest<E, MessageShortcut> = {\n\t          payload: body as MessageShortcut,\n", "          ...baseRequest,\n\t        };\n\t        for (const matcher of this.#messageShorcuts) {\n\t          const handler = matcher(payload);\n\t          if (handler) {\n\t            ctx.waitUntil(handler.lazy(slackRequest));\n\t            const slackResponse = await handler.ack(slackRequest);\n\t            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n\t              console.log(\n\t                `*** Slack response ***\\n${prettyPrint(slackResponse)}`,\n", "              );\n\t            }\n\t            return toCompleteResponse(slackResponse);\n\t          }\n\t        }\n\t      } else if (body.type === PayloadType.BlockAction) {\n\t        // Block actions\n\t        // deno-lint-ignore no-explicit-any\n\t        const slackRequest: SlackRequest<E, BlockAction<any>> = {\n\t          // deno-lint-ignore no-explicit-any\n", "          payload: body as BlockAction<any>,\n\t          ...baseRequest,\n\t        };\n\t        for (const matcher of this.#blockActions) {\n\t          const handler = matcher(payload);\n\t          if (handler) {\n\t            ctx.waitUntil(handler.lazy(slackRequest));\n\t            const slackResponse = await handler.ack(slackRequest);\n\t            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n\t              console.log(\n", "                `*** Slack response ***\\n${prettyPrint(slackResponse)}`,\n\t              );\n\t            }\n\t            return toCompleteResponse(slackResponse);\n\t          }\n\t        }\n\t      } else if (body.type === PayloadType.BlockSuggestion) {\n\t        // Block suggestions\n\t        const slackRequest: SlackRequest<E, BlockSuggestion> = {\n\t          payload: body as BlockSuggestion,\n", "          ...baseRequest,\n\t        };\n\t        for (const matcher of this.#blockSuggestions) {\n\t          const handler = matcher(payload);\n\t          if (handler) {\n\t            // Note that the only way to respond to a block_suggestion request\n\t            // is to send an HTTP response with options/option_groups.\n\t            // Thus, we don't support lazy handlers for this pattern.\n\t            const slackResponse = await handler.ack(slackRequest);\n\t            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n", "              console.log(\n\t                `*** Slack response ***\\n${prettyPrint(slackResponse)}`,\n\t              );\n\t            }\n\t            return toCompleteResponse(slackResponse);\n\t          }\n\t        }\n\t      } else if (body.type === PayloadType.ViewSubmission) {\n\t        // View submissions\n\t        const slackRequest: SlackRequest<E, ViewSubmission> = {\n", "          payload: body as ViewSubmission,\n\t          ...baseRequest,\n\t        };\n\t        for (const matcher of this.#viewSubmissions) {\n\t          const handler = matcher(payload);\n\t          if (handler) {\n\t            ctx.waitUntil(handler.lazy(slackRequest));\n\t            const slackResponse = await handler.ack(slackRequest);\n\t            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n\t              console.log(\n", "                `*** Slack response ***\\n${prettyPrint(slackResponse)}`,\n\t              );\n\t            }\n\t            return toCompleteResponse(slackResponse);\n\t          }\n\t        }\n\t      } else if (body.type === PayloadType.ViewClosed) {\n\t        // View closed\n\t        const slackRequest: SlackRequest<E, ViewClosed> = {\n\t          payload: body as ViewClosed,\n", "          ...baseRequest,\n\t        };\n\t        for (const matcher of this.#viewClosed) {\n\t          const handler = matcher(payload);\n\t          if (handler) {\n\t            ctx.waitUntil(handler.lazy(slackRequest));\n\t            const slackResponse = await handler.ack(slackRequest);\n\t            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n\t              console.log(\n\t                `*** Slack response ***\\n${prettyPrint(slackResponse)}`,\n", "              );\n\t            }\n\t            return toCompleteResponse(slackResponse);\n\t          }\n\t        }\n\t      }\n\t      // TODO: Add code suggestion here\n\t      console.log(\n\t        `*** No listener found ***\\n${JSON.stringify(baseRequest.body)}`,\n\t      );\n", "      return new Response(\"No listener found\", { status: 404 });\n\t    }\n\t    return new Response(\"Invalid signature\", { status: 401 });\n\t  }\n\t}\n\texport type StringOrRegExp = string | RegExp;\n\texport type EventRequest<E extends SlackAppEnv, T> = Extract<\n\t  AnySlackEventWithChannelId,\n\t  { type: T }\n\t> extends never ? SlackRequest<E, Extract<AnySlackEvent, { type: T }>>\n", "  : SlackRequestWithChannelId<\n\t    E,\n\t    Extract<AnySlackEventWithChannelId, { type: T }>\n\t  >;\n\texport type MessageEventPattern = string | RegExp | undefined;\n\texport type MessageEventRequest<\n\t  E extends SlackAppEnv,\n\t  ST extends string | undefined,\n\t> = SlackRequestWithChannelId<\n\t  E,\n", "  Extract<AnySlackEventWithChannelId, { subtype: ST }>\n\t>;\n\texport type MessageEventSubtypes =\n\t  | undefined\n\t  | \"bot_message\"\n\t  | \"thread_broadcast\"\n\t  | \"file_share\";\n\texport type MessageEventHandler<E extends SlackAppEnv> = (\n\t  req: MessageEventRequest<E, MessageEventSubtypes>,\n\t) => Promise<void>;\n", "export const noopLazyListener = async () => {};\n"]}
{"filename": "src_deno/execution-context.ts", "chunked_list": ["/**\n\t * An interface representing context parameter in Cloudflare Workers and Vercel Edge Functions.\n\t * Refer to the following resources:\n\t * - https://developers.cloudflare.com/workers/runtime-apis/fetch-event/\n\t * - https://vercel.com/docs/concepts/functions/edge-functions/edge-functions-api#waituntil\n\t */\n\texport interface ExecutionContext {\n\t  // deno-lint-ignore no-explicit-any\n\t  waitUntil(promise: Promise<any>): void;\n\t}\n", "export class NoopExecutionContext implements ExecutionContext {\n\t  // deno-lint-ignore no-explicit-any\n\t  waitUntil(promise: Promise<any>): void {\n\t    promise.catch((reason) => {\n\t      console.error(`Failed to run a lazy listener: ${reason}`);\n\t    });\n\t  }\n\t}\n"]}
{"filename": "src_deno/cookie.ts", "chunked_list": ["/*!\n\t * cookie\n\t * Copyright(c) 2012-2014 Roman Shtylman\n\t * Copyright(c) 2015 Douglas Christopher Wilson\n\t * MIT Licensed\n\t */\n\t/**\n\t * Parse a cookie header.\n\t *\n\t * Parse the given cookie header string into an object\n", " * The object has the various cookies as keys(names) => values\n\t */\n\texport function parse(\n\t  str: string,\n\t  // deno-lint-ignore no-explicit-any\n\t  options: any | undefined = undefined,\n\t): Record<string, string> {\n\t  if (typeof str !== \"string\") {\n\t    throw new TypeError(\"argument str must be a string\");\n\t  }\n", "  // deno-lint-ignore no-explicit-any\n\t  const obj: any = {};\n\t  const opt = options || {};\n\t  const dec = opt.decode || decode;\n\t  let index = 0;\n\t  while (index < str.length) {\n\t    const eqIdx = str.indexOf(\"=\", index);\n\t    // no more cookie pairs\n\t    if (eqIdx === -1) {\n\t      break;\n", "    }\n\t    let endIdx = str.indexOf(\";\", index);\n\t    if (endIdx === -1) {\n\t      endIdx = str.length;\n\t    } else if (endIdx < eqIdx) {\n\t      // backtrack on prior semicolon\n\t      index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n\t      continue;\n\t    }\n\t    const key = str.slice(index, eqIdx).trim();\n", "    // only assign once\n\t    if (undefined === obj[key]) {\n\t      let val = str.slice(eqIdx + 1, endIdx).trim();\n\t      // quoted values\n\t      if (val.charCodeAt(0) === 0x22) {\n\t        val = val.slice(1, -1);\n\t      }\n\t      obj[key] = tryDecode(val, dec);\n\t    }\n\t    index = endIdx + 1;\n", "  }\n\t  return obj;\n\t}\n\t/**\n\t * URL-decode string value. Optimized to skip native call when no %.\n\t */\n\tfunction decode(str: string): string {\n\t  return str.indexOf(\"%\") !== -1 ? decodeURIComponent(str) : str;\n\t}\n\t/**\n", " * Try decoding a string using a decoding function.\n\t */\n\tfunction tryDecode(str: string, decode: (val: string) => string) {\n\t  try {\n\t    return decode(str);\n\t    // deno-lint-ignore no-unused-vars\n\t  } catch (e) {\n\t    return str;\n\t  }\n\t}\n"]}
{"filename": "src_deno/errors.ts", "chunked_list": ["export class ConfigError extends Error {\n\t  constructor(message: string) {\n\t    super(message);\n\t    this.name = \"ConfigError\";\n\t  }\n\t}\n\texport class AuthorizeError extends Error {\n\t  constructor(message: string) {\n\t    super(message);\n\t    this.name = \"AuthorizeError\";\n", "  }\n\t}\n\texport class SocketModeError extends Error {\n\t  constructor(message: string) {\n\t    super(message);\n\t    this.name = \"SocketModeError\";\n\t  }\n\t}\n"]}
{"filename": "src_deno/index.ts", "chunked_list": ["export * from \"./app.ts\";\n\texport * from \"./app-env.ts\";\n\texport * from \"./execution-context.ts\";\n\texport * from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\texport * from \"./errors.ts\";\n\texport * from \"./oauth/error-codes.ts\";\n\texport * from \"./handler/handler.ts\";\n\texport * from \"./handler/message-handler.ts\";\n\texport * from \"./handler/options-handler.ts\";\n\texport * from \"./handler/view-handler.ts\";\n", "export * from \"./authorization/authorize.ts\";\n\texport * from \"./authorization/authorize-result.ts\";\n\texport * from \"./authorization/single-team-authorize.ts\";\n\texport * from \"./middleware/middleware.ts\";\n\texport * from \"./middleware/built-in-middleware.ts\";\n\texport * from \"./context/context.ts\";\n\texport * from \"./oauth-app.ts\";\n\texport * from \"./oauth/authorize-url-generator.ts\";\n\texport * from \"./oauth/callback.ts\";\n\texport * from \"./oauth/escape-html.ts\";\n", "export * from \"./oauth/installation.ts\";\n\texport * from \"./oauth/installation-store.ts\";\n\texport * from \"./oauth/oauth-page-renderer.ts\";\n\texport * from \"./oauth/state-store.ts\";\n\texport * from \"./oidc/authorize-url-generator.ts\";\n\texport * from \"./oidc/callback.ts\";\n\texport * from \"./oidc/login.ts\";\n\texport * from \"./request/request-body.ts\";\n\texport * from \"./request/request-verification.ts\";\n\texport * from \"./request/request.ts\";\n", "export * from \"./request/payload-types.ts\";\n\texport * from \"./request/payload/block-action.ts\";\n\texport * from \"./request/payload/block-suggestion.ts\";\n\texport * from \"./request/payload/event.ts\";\n\texport * from \"./request/payload/global-shortcut.ts\";\n\texport * from \"./request/payload/message-shortcut.ts\";\n\texport * from \"./request/payload/slash-command.ts\";\n\texport * from \"./request/payload/view-submission.ts\";\n\texport * from \"./request/payload/view-closed.ts\";\n\texport * from \"./request/payload/view-objects.ts\";\n", "export * from \"./response/response.ts\";\n\texport * from \"./socket-mode/socket-mode-client.ts\";\n\texport * from \"./utility/message-events.ts\";\n"]}
{"filename": "src_deno/app-env.ts", "chunked_list": ["export interface SlackLoggingLevel {\n\t  SLACK_LOGGING_LEVEL?: \"DEBUG\" | \"INFO\" | \"WARN\" | \"ERROR\";\n\t}\n\texport type SlackAppEnv = SlackLoggingLevel & {\n\t  SLACK_SIGNING_SECRET?: string;\n\t  SLACK_BOT_TOKEN?: string;\n\t  SLACK_APP_TOKEN?: string;\n\t};\n\texport type SlackEdgeAppEnv = SlackAppEnv & {\n\t  SLACK_SIGNING_SECRET: string;\n", "  SLACK_BOT_TOKEN?: string;\n\t};\n\texport type SlackSocketModeAppEnv = SlackAppEnv & {\n\t  SLACK_SIGNING_SECRET?: string;\n\t  SLACK_BOT_TOKEN?: string;\n\t  SLACK_APP_TOKEN: string;\n\t};\n\texport type SlackOAuthEnv = (SlackEdgeAppEnv | SlackSocketModeAppEnv) & {\n\t  SLACK_CLIENT_ID: string;\n\t  SLACK_CLIENT_SECRET: string;\n", "  SLACK_BOT_SCOPES: string;\n\t  SLACK_USER_SCOPES?: string;\n\t  SLACK_REDIRECT_URI?: string;\n\t  SLACK_OIDC_SCOPES?: string;\n\t  SLACK_OIDC_REDIRECT_URI?: string;\n\t  SLACK_USER_TOKEN_RESOLUTION?: \"installer\" | \"actor\";\n\t};\n\texport type SlackOIDCEnv = SlackAppEnv & {\n\t  SLACK_CLIENT_ID: string;\n\t  SLACK_CLIENT_SECRET: string;\n", "  SLACK_OIDC_SCOPES?: string;\n\t  SLACK_OIDC_REDIRECT_URI: string;\n\t};\n\texport type SlackOAuthAndOIDCEnv = SlackOAuthEnv & SlackOIDCEnv;\n"]}
{"filename": "src_deno/oidc/callback.ts", "chunked_list": ["import { SlackLoggingLevel } from \"../app-env.ts\";\n\timport {\n\t  OpenIDConnectTokenResponse,\n\t  SlackAPIClient,\n\t} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\timport { prettyPrint } from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\texport type OpenIDConnectCallback = (\n\t  apiResponse: OpenIDConnectTokenResponse,\n\t  req: Request,\n\t) => Promise<Response>;\n", "export function defaultOpenIDConnectCallback(\n\t  env: SlackLoggingLevel,\n\t): OpenIDConnectCallback {\n\t  // deno-lint-ignore no-unused-vars\n\t  return async (token, req) => {\n\t    const client = new SlackAPIClient(token.access_token, {\n\t      logLevel: env.SLACK_LOGGING_LEVEL,\n\t    });\n\t    const userInfo = await client.openid.connect.userInfo();\n\t    const body =\n", "      `<html><head><style>body {{ padding: 10px 15px; font-family: verdana; text-align: center; }}</style></head><body><h1>It works!</h1><p>This is the default handler. To change this, pass \\`oidc: { callback: async (token, req) => new Response(\"TODO\") }\\` to your SlackOAuthApp constructor.</p><pre>${\n\t        prettyPrint(\n\t          userInfo,\n\t        )\n\t      }</pre></body></html>`;\n\t    return new Response(body, {\n\t      status: 200,\n\t      headers: { \"Content-Type\": \"text/html; charset=utf-8\" },\n\t    });\n\t  };\n", "}\n"]}
{"filename": "src_deno/oidc/login.ts", "chunked_list": ["import {\n\t  OpenIDConnectTokenResponse,\n\t  OpenIDConnectUserInfoResponse,\n\t} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\texport interface Login {\n\t  enterprise_id?: string;\n\t  team_id: string;\n\t  user_id: string;\n\t  name?: string;\n\t  email?: string;\n", "  picture?: string;\n\t  access_token: string;\n\t  refresh_token?: string; // token rotation\n\t  token_expires_at?: number; // token rotation (epoch time seconds)\n\t}\n\texport function toLogin(\n\t  token: OpenIDConnectTokenResponse,\n\t  userInfo: OpenIDConnectUserInfoResponse,\n\t): Login {\n\t  return {\n", "    enterprise_id: userInfo[\"https://slack.com/enterprise_id\"],\n\t    team_id: userInfo[\"https://slack.com/team_id\"]!,\n\t    user_id: userInfo[\"https://slack.com/user_id\"]!,\n\t    email: userInfo.email,\n\t    picture: userInfo.picture,\n\t    access_token: token.access_token!,\n\t    refresh_token: token.refresh_token,\n\t    token_expires_at: token.expires_in\n\t      ? new Date().getTime() / 1000 + token.expires_in\n\t      : undefined,\n", "  };\n\t}\n"]}
{"filename": "src_deno/oidc/authorize-url-generator.ts", "chunked_list": ["import { SlackOAuthEnv } from \"../app-env.ts\";\n\timport { ConfigError } from \"../errors.ts\";\n\texport function generateOIDCAuthorizeUrl<E extends SlackOAuthEnv>(\n\t  state: string,\n\t  env: E,\n\t): string {\n\t  if (!env.SLACK_OIDC_SCOPES) {\n\t    throw new ConfigError(\n\t      \"env.SLACK_OIDC_SCOPES must be present when enabling Sign in with Slack (OpenID Connect)\",\n\t    );\n", "  }\n\t  if (!env.SLACK_OIDC_REDIRECT_URI) {\n\t    throw new ConfigError(\n\t      \"env.SLACK_OIDC_REDIRECT_URI must be present when enabling Sign in with Slack (OpenID Connect)\",\n\t    );\n\t  }\n\t  let url =\n\t    `https://slack.com/openid/connect/authorize?response_type=code&state=${state}`;\n\t  url += `&client_id=${env.SLACK_CLIENT_ID}`;\n\t  url += `&scope=${env.SLACK_OIDC_SCOPES}`;\n", "  url += `&redirect_uri=${env.SLACK_OIDC_REDIRECT_URI}`;\n\t  return url;\n\t}\n"]}
{"filename": "src_deno/context/context.ts", "chunked_list": ["import { AuthorizeResult } from \"../authorization/authorize-result.ts\";\n\timport {\n\t  ChatPostMessageRequest,\n\t  ChatPostMessageResponse,\n\t  SlackAPIClient,\n\t  WebhookParams,\n\t} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\texport interface PreAuthorizeSlackAppContext {\n\t  isEnterpriseinstall?: boolean;\n\t  enterpriseId?: string;\n", "  teamId?: string;\n\t  userId?: string;\n\t  actorEnterpriseId?: string;\n\t  actorTeamId?: string;\n\t  actorUserId?: string;\n\t  botId?: string;\n\t  botUserId?: string;\n\t  responseUrl?: string;\n\t  channelId?: string;\n\t  custom: {\n", "    // deno-lint-ignore no-explicit-any\n\t    [key: string]: any; // custom properties\n\t  };\n\t}\n\texport type SlackAppContext = {\n\t  client: SlackAPIClient;\n\t  botToken: string;\n\t  userToken?: string;\n\t  authorizeResult: AuthorizeResult;\n\t} & PreAuthorizeSlackAppContext;\n", "export type SlackAppContextWithChannelId = {\n\t  channelId: string;\n\t  say: (\n\t    params: Omit<ChatPostMessageRequest, \"channel\">,\n\t  ) => Promise<ChatPostMessageResponse>;\n\t} & SlackAppContext;\n\texport type SlackAppContextWithRespond = {\n\t  channelId: string;\n\t  respond: (params: WebhookParams) => Promise<Response>;\n\t} & SlackAppContext;\n", "export type SlackAppContextWithOptionalRespond = {\n\t  respond?: (params: WebhookParams) => Promise<Response>;\n\t} & SlackAppContext;\n\texport function builtBaseContext(\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>,\n\t): PreAuthorizeSlackAppContext {\n\t  return {\n\t    isEnterpriseinstall: extractIsEnterpriseInstall(body),\n\t    enterpriseId: extractEnterpriseId(body),\n", "    teamId: extractTeamId(body),\n\t    userId: extractUserId(body),\n\t    actorEnterpriseId: extractActorEnterpriseId(body),\n\t    actorTeamId: extractActorTeamId(body),\n\t    actorUserId: extractActorUserId(body),\n\t    botId: undefined, // will be set later\n\t    botUserId: undefined, // will be set later\n\t    responseUrl: extractResponseUrl(body),\n\t    channelId: extractChannelId(body),\n\t    custom: {},\n", "  };\n\t}\n\texport function extractIsEnterpriseInstall(\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>,\n\t): boolean | undefined {\n\t  if (body.authorizations && body.authorizations.length > 0) {\n\t    return body.authorizations[0].is_enterprise_install;\n\t  } else if (body.is_enterprise_install) {\n\t    if (typeof body.is_enterprise_install === \"string\") {\n", "      // slash command payloads\n\t      return body.is_enterprise_install === \"true\";\n\t    }\n\t    return body.is_enterprise_install == true;\n\t  }\n\t  return undefined;\n\t}\n\texport function extractEnterpriseId(\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>,\n", "): string | undefined {\n\t  if (body.enterprise) {\n\t    if (typeof body.enterprise === \"string\") {\n\t      return body.enterprise;\n\t    } else if (typeof body.enterprise === \"object\" && body.enterprise.id) {\n\t      return body.enterprise.id;\n\t    }\n\t  } else if (body.authorizations && body.authorizations.length > 0) {\n\t    return extractEnterpriseId(body.authorizations[0]);\n\t  } else if (body.enterprise_id) {\n", "    return body.enterprise_id;\n\t  } else if (\n\t    body.team &&\n\t    typeof body.team === \"object\" &&\n\t    body.team.enterprise_id\n\t  ) {\n\t    return body.team.enterprise_id;\n\t  } else if (body.event) {\n\t    return extractEnterpriseId(body.event);\n\t  }\n", "  return undefined;\n\t}\n\t// deno-lint-ignore no-explicit-any\n\texport function extractTeamId(body: Record<string, any>): string | undefined {\n\t  if (body.view && body.view.app_installed_team_id) {\n\t    // view_submission payloads can have `view.app_installed_team_id`\n\t    // when a modal view that was opened in a different workspace via some operations inside a Slack Connect channel.\n\t    // Note that the same for enterprise_id does not exist. When you need to know the enterprise_id as well,\n\t    // you have to run some query toward your InstallationStore to know the org where the team_id belongs to.\n\t    return body.view.app_installed_team_id;\n", "  } else if (body.team) {\n\t    // With org-wide installations, payload.team in interactivity payloads can be None\n\t    // You need to extract either payload.user.team_id or payload.view.team_id as below\n\t    if (typeof body.team === \"string\") {\n\t      return body.team;\n\t    } else if (body.team.id) {\n\t      return body.team.id;\n\t    }\n\t  } else if (body.authorizations && body.authorizations.length > 0) {\n\t    // To make Events API handling functioning also for shared channels,\n", "    // we should use .authorizations[0].team_id over .team_id\n\t    return extractTeamId(body.authorizations[0]);\n\t  } else if (body.team_id) {\n\t    return body.team_id;\n\t  } else if (body.user && typeof body.user === \"object\") {\n\t    return body.user.team_id;\n\t  } else if (body.view && typeof body.view === \"object\") {\n\t    return body.view.team_id;\n\t  }\n\t  return undefined;\n", "}\n\t// deno-lint-ignore no-explicit-any\n\texport function extractUserId(body: Record<string, any>): string | undefined {\n\t  if (body.user) {\n\t    if (typeof body.user === \"string\") {\n\t      return body.user;\n\t    }\n\t    if (typeof body.user === \"object\" && body.user.id) {\n\t      return body.user.id;\n\t    }\n", "  } else if (body.user_id) {\n\t    return body.user_id;\n\t  } else if (body.event) {\n\t    return extractUserId(body.event);\n\t  } else if (body.message) {\n\t    return extractUserId(body.message);\n\t  } else if (body.previous_message) {\n\t    return extractUserId(body.previous_message);\n\t  }\n\t  return undefined;\n", "}\n\texport function extractActorEnterpriseId(\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>,\n\t): string | undefined {\n\t  if (body.is_ext_shared_channel) {\n\t    if (body.type === \"event_callback\") {\n\t      const eventTeamId = body.event?.user_team || body.event?.team;\n\t      if (eventTeamId && eventTeamId.startsWith(\"E\")) {\n\t        return eventTeamId;\n", "      } else if (eventTeamId === body.team_id) {\n\t        return body.enterprise_id;\n\t      }\n\t    }\n\t  }\n\t  return extractEnterpriseId(body);\n\t}\n\texport function extractActorTeamId(\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>,\n", "): string | undefined {\n\t  if (body.is_ext_shared_channel) {\n\t    if (body.type === \"event_callback\") {\n\t      const eventType = body.event.type;\n\t      if (eventType === \"app_mention\") {\n\t        // The $.event.user_team can be an enterprise_id in app_mention events.\n\t        // In the scenario, there is no way to retrieve actor_team_id as of March 2023\n\t        const userTeam = body.event.user_team;\n\t        if (!userTeam) {\n\t          // working with an app installed in this user's org/workspace side\n", "          return body.event.team;\n\t        } else if (userTeam.startsWith(\"T\")) {\n\t          // interacting from a connected non-grid workspace\n\t          return userTeam;\n\t        }\n\t        // Interacting from a connected grid workspace; in this case, team_id cannot be resolved as of March 2023\n\t        return undefined;\n\t      }\n\t      const eventUserTeam = body.event.user_team;\n\t      if (eventUserTeam) {\n", "        if (eventUserTeam.startsWith(\"T\")) {\n\t          return eventUserTeam;\n\t        } else if (eventUserTeam.startsWith(\"E\")) {\n\t          if (eventUserTeam === body.enterprise_id) {\n\t            return body.team_id;\n\t          } else if (eventUserTeam === body.context_enterprise_id) {\n\t            return body.context_team_id;\n\t          }\n\t        }\n\t      }\n", "      const eventTeam = body.event.team;\n\t      if (eventTeam) {\n\t        if (eventTeam.startsWith(\"T\")) {\n\t          return eventTeam;\n\t        } else if (eventTeam.startsWith(\"E\")) {\n\t          if (eventTeam === body.enterprise_id) {\n\t            return body.team_id;\n\t          } else if (eventTeam === body.context_enterprise_id) {\n\t            return body.context_team_id;\n\t          }\n", "        }\n\t      }\n\t    }\n\t  }\n\t  return extractTeamId(body);\n\t}\n\texport function extractActorUserId(\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>,\n\t): string | undefined {\n", "  if (body.is_ext_shared_channel) {\n\t    if (body.type === \"event_callback\") {\n\t      if (body.event) {\n\t        if (extractActorEnterpriseId(body) && extractActorTeamId(body)) {\n\t          // When both enterprise_id and team_id are not identified, we skip returning user_id too for safety\n\t          return undefined;\n\t        }\n\t        return body.event.user || body.event.user_id;\n\t      } else {\n\t        return undefined;\n", "      }\n\t    }\n\t  }\n\t  return extractUserId(body);\n\t}\n\texport function extractResponseUrl(\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>,\n\t): string | undefined {\n\t  if (body.response_url) {\n", "    return body.response_url;\n\t  } else if (body.response_urls && body.response_urls.length > 0) {\n\t    return body.response_urls[0].response_url;\n\t  }\n\t  return undefined;\n\t}\n\texport function extractChannelId(\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>,\n\t): string | undefined {\n", "  if (body.channel) {\n\t    if (typeof body.channel === \"string\") {\n\t      return body.channel;\n\t    } else if (typeof body.channel === \"object\" && body.channel.id) {\n\t      return body.channel.id;\n\t    }\n\t  } else if (body.channel_id) {\n\t    return body.channel_id;\n\t  } else if (body.event) {\n\t    return extractChannelId(body.event);\n", "  } else if (body.item) {\n\t    // reaction_added: body[\"event\"][\"item\"]\n\t    return extractChannelId(body.item);\n\t  }\n\t  return undefined;\n\t}\n"]}
{"filename": "src_deno/authorization/single-team-authorize.ts", "chunked_list": ["import { AuthorizeError } from \"../errors.ts\";\n\timport {\n\t  AuthTestResponse,\n\t  SlackAPIClient,\n\t  SlackAPIError,\n\t} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\timport { Authorize } from \"./authorize.ts\";\n\texport const singleTeamAuthorize: Authorize = async (req) => {\n\t  // This authorize function supports only the bot token for a workspace\n\t  const botToken = req.env.SLACK_BOT_TOKEN!;\n", "  const client = new SlackAPIClient(botToken);\n\t  try {\n\t    const response: AuthTestResponse = await client.auth.test();\n\t    const scopes = response.headers.get(\"x-oauth-scopes\") ?? \"\";\n\t    return {\n\t      botToken,\n\t      enterpriseId: response.enterprise_id,\n\t      teamId: response.team_id,\n\t      team: response.team,\n\t      url: response.url,\n", "      botId: response.bot_id!,\n\t      botUserId: response.user_id!,\n\t      userId: response.user_id,\n\t      user: response.user,\n\t      botScopes: scopes.split(\",\"),\n\t      userToken: undefined, // As mentioned above, user tokens are not supported in this module\n\t      userScopes: undefined, // As mentioned above, user tokens are not supported in this module\n\t    };\n\t  } catch (e) {\n\t    throw new AuthorizeError(\n", "      `Failed to call auth.test API due to ${(e as SlackAPIError).message}`,\n\t    );\n\t  }\n\t};\n"]}
{"filename": "src_deno/authorization/authorize.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env.ts\";\n\timport { PreAuthorizeSlackMiddlwareRequest } from \"../request/request.ts\";\n\timport { AuthorizeResult } from \"./authorize-result.ts\";\n\texport type Authorize<E extends SlackAppEnv = SlackAppEnv> = (\n\t  req: PreAuthorizeSlackMiddlwareRequest<E>,\n\t) => Promise<AuthorizeResult>;\n"]}
{"filename": "src_deno/authorization/authorize-result.ts", "chunked_list": ["export interface AuthorizeResult {\n\t  enterpriseId?: string;\n\t  teamId?: string;\n\t  team?: string;\n\t  url?: string;\n\t  botId: string;\n\t  botUserId: string;\n\t  botToken: string;\n\t  botScopes: string[];\n\t  userId?: string;\n", "  user?: string;\n\t  userToken?: string;\n\t  userScopes?: string[];\n\t}\n"]}
{"filename": "src_deno/socket-mode/socket-mode-client.ts", "chunked_list": ["import {\n\t  isDebugLogEnabled,\n\t  SlackAPIClient,\n\t} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\timport { SlackApp } from \"../app.ts\";\n\timport { ConfigError, SocketModeError } from \"../errors.ts\";\n\timport { ExecutionContext } from \"../execution-context.ts\";\n\timport { SlackSocketModeAppEnv } from \"../app-env.ts\";\n\t// TODO: Implement proper reconnection logic\n\t// TODO: Add connection monitor like 1st party SDKs do\n", "// TODO: Add Bun support (the runtime does not work well with Socket Mode)\n\texport class SocketModeClient {\n\t  public app: SlackApp<SlackSocketModeAppEnv>;\n\t  public appLevelToken: string;\n\t  public ws: WebSocket | undefined;\n\t  constructor(\n\t    // deno-lint-ignore no-explicit-any\n\t    app: SlackApp<any>,\n\t  ) {\n\t    if (!app.socketMode) {\n", "      throw new ConfigError(\n\t        \"socketMode: true must be set for running with Socket Mode\",\n\t      );\n\t    }\n\t    if (!app.appLevelToken) {\n\t      throw new ConfigError(\n\t        \"appLevelToken must be set for running with Socket Mode\",\n\t      );\n\t    }\n\t    this.app = app as SlackApp<SlackSocketModeAppEnv>;\n", "    this.appLevelToken = app.appLevelToken;\n\t    console.warn(\n\t      \"WARNING: The Socket Mode support provided by slack-edge is still experimental and is not designed to handle reconnections for production-grade applications. It is recommended to use this mode only for local development and testing purposes.\",\n\t    );\n\t  }\n\t  async connect() {\n\t    const client = new SlackAPIClient(this.appLevelToken);\n\t    try {\n\t      const newConnection = await client.apps.connections.open();\n\t      this.ws = new WebSocket(newConnection.url!);\n", "    } catch (e) {\n\t      throw new SocketModeError(\n\t        `Failed to establish a new WSS connection: ${e}`,\n\t      );\n\t    }\n\t    if (this.ws) {\n\t      const ws = this.ws;\n\t      // deno-lint-ignore require-await\n\t      ws.onopen = async (ev) => {\n\t        // TODO: make this customizable\n", "        if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n\t          console.log(\n\t            `Now the Socket Mode client is connected to Slack: ${\n\t              JSON.stringify(\n\t                ev,\n\t              )\n\t            }`,\n\t          );\n\t        }\n\t      };\n", "      // deno-lint-ignore require-await\n\t      ws.onclose = async (ev) => {\n\t        // TODO: make this customizable\n\t        if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n\t          console.log(\n\t            `The Socket Mode client is disconnected from Slack: ${\n\t              JSON.stringify(\n\t                ev,\n\t              )\n\t            }`,\n", "          );\n\t        }\n\t      };\n\t      // deno-lint-ignore require-await\n\t      ws.onerror = async (e) => {\n\t        // TODO: make this customizable\n\t        console.error(\n\t          `An error was thrown by the Socket Mode connection: ${e}`,\n\t        );\n\t      };\n", "      const app = this.app;\n\t      ws.onmessage = async (ev) => {\n\t        try {\n\t          if (\n\t            ev.data &&\n\t            typeof ev.data === \"string\" &&\n\t            ev.data.startsWith(\"{\")\n\t          ) {\n\t            const data = JSON.parse(ev.data);\n\t            if (data.type === \"hello\") {\n", "              if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n\t                console.log(`*** Received hello data ***\\n ${ev.data}`);\n\t              }\n\t              return;\n\t            }\n\t            const payload = JSON.stringify(data.payload);\n\t            console.log(payload);\n\t            const request: Request = new Request(ws.url, {\n\t              method: \"POST\",\n\t              headers: new Headers({ \"content-type\": \"application/json\" }),\n", "              body: new Blob([payload]).stream(),\n\t            });\n\t            const context: ExecutionContext = {\n\t              // deno-lint-ignore require-await\n\t              waitUntil: async (promise) => {\n\t                promise\n\t                  .then((res) => {\n\t                    console.info(`Completed a lazy listener execution: ${res}`);\n\t                  })\n\t                  .catch((err) => {\n", "                    console.error(`Failed to run a lazy listener: ${err}`);\n\t                  });\n\t              },\n\t            };\n\t            const response = await app.run(request, context);\n\t            // deno-lint-ignore no-explicit-any\n\t            let ack: any = { envelope_id: data.envelope_id };\n\t            if (response.body) {\n\t              const contentType = response.headers.get(\"Content-Type\");\n\t              if (contentType && contentType.startsWith(\"text/plain\")) {\n", "                const text = await response.text();\n\t                ack = { envelope_id: data.envelope_id, payload: { text } };\n\t              } else {\n\t                const json = await response.json();\n\t                ack = { envelope_id: data.envelope_id, payload: { ...json } };\n\t              }\n\t            }\n\t            ws.send(JSON.stringify(ack));\n\t          } else {\n\t            if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n", "              console.log(`*** Received non-JSON data ***\\n ${ev.data}`);\n\t            }\n\t          }\n\t        } catch (e) {\n\t          console.error(`Failed to handle a WebSocke message: ${e}`);\n\t        }\n\t      };\n\t    }\n\t  }\n\t  // deno-lint-ignore require-await\n", "  async disconnect(): Promise<void> {\n\t    if (this.ws) {\n\t      this.ws.close();\n\t      this.ws = undefined;\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src_deno/handler/view-handler.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env.ts\";\n\timport { SlackRequest } from \"../request/request.ts\";\n\timport { SlackViewResponse } from \"../response/response.ts\";\n\texport type ViewAckResponse = SlackViewResponse | void;\n\texport type SlackViewHandler<E extends SlackAppEnv, Payload> = {\n\t  ack(request: SlackRequest<E, Payload>): Promise<ViewAckResponse>;\n\t  lazy(request: SlackRequest<E, Payload>): Promise<void>;\n\t};\n"]}
{"filename": "src_deno/handler/message-handler.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env.ts\";\n\timport { SlackRequest } from \"../request/request.ts\";\n\timport { MessageResponse } from \"../response/response-body.ts\";\n\timport { AckResponse } from \"./handler.ts\";\n\texport type MessageAckResponse = AckResponse | MessageResponse;\n\texport interface SlackMessageHandler<E extends SlackAppEnv, Payload> {\n\t  ack(request: SlackRequest<E, Payload>): Promise<MessageAckResponse>;\n\t  lazy(request: SlackRequest<E, Payload>): Promise<void>;\n\t}\n"]}
{"filename": "src_deno/handler/handler.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env.ts\";\n\timport { SlackRequest } from \"../request/request.ts\";\n\timport { SlackResponse } from \"../response/response.ts\";\n\texport type AckResponse = SlackResponse | string | void;\n\texport interface SlackHandler<E extends SlackAppEnv, Payload> {\n\t  ack(request: SlackRequest<E, Payload>): Promise<AckResponse>;\n\t  lazy(request: SlackRequest<E, Payload>): Promise<void>;\n\t}\n"]}
{"filename": "src_deno/handler/options-handler.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env.ts\";\n\timport { SlackRequest } from \"../request/request.ts\";\n\timport { SlackOptionsResponse } from \"../response/response.ts\";\n\texport type OptionsAckResponse = SlackOptionsResponse;\n\texport interface SlackOptionsHandler<E extends SlackAppEnv, Payload> {\n\t  ack(request: SlackRequest<E, Payload>): Promise<OptionsAckResponse>;\n\t  // Note that a block_suggestion response must be done synchronously.\n\t  // That's why we don't support lazy functions for the pattern.\n\t}\n"]}
{"filename": "src_deno/response/response-body.ts", "chunked_list": ["import {\n\t  AnyMessageBlock,\n\t  AnyTextField,\n\t  MessageAttachment,\n\t  MessageMetadata,\n\t  ModalView,\n\t} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\texport interface MessageResponse {\n\t  response_type?: \"ephemeral\" | \"in_channel\";\n\t  text: string;\n", "  blocks?: AnyMessageBlock[];\n\t  attachments?: MessageAttachment[];\n\t  metadata?: MessageMetadata;\n\t  thread_ts?: string;\n\t}\n\texport interface ViewUpdateResponse {\n\t  response_action: \"update\";\n\t  view: ModalView;\n\t}\n\texport interface ViewPushResponse {\n", "  response_action: \"push\";\n\t  view: ModalView;\n\t}\n\texport interface ViewClearResponse {\n\t  response_action: \"clear\";\n\t}\n\texport interface ViewErrorsResponse {\n\t  response_action: \"errors\";\n\t  errors: { [blockId: string]: string };\n\t}\n", "export type AnyViewResponse =\n\t  | ViewUpdateResponse\n\t  | ViewPushResponse\n\t  | ViewClearResponse\n\t  | ViewErrorsResponse;\n\texport interface Option {\n\t  value: string;\n\t  text: AnyTextField;\n\t}\n\texport interface OptionGroup {\n", "  label: AnyTextField;\n\t  options: Option[];\n\t}\n\texport interface OptionsResponse {\n\t  options: Option[];\n\t}\n\texport interface OptionGroupsResponse {\n\t  option_groups: OptionGroup[];\n\t}\n\texport type AnyOptionsResponse = OptionsResponse | OptionGroupsResponse;\n"]}
{"filename": "src_deno/response/response.ts", "chunked_list": ["import {\n\t  AnyOptionsResponse,\n\t  AnyViewResponse,\n\t  MessageResponse,\n\t} from \"./response-body.ts\";\n\texport interface SlackResponse {\n\t  status?: number;\n\t  contentType?: string;\n\t  // deno-lint-ignore no-explicit-any\n\t  body?: string | MessageResponse | Record<string, any>;\n", "}\n\texport type SlackViewResponse =\n\t  | (SlackResponse & {\n\t    body: \"\" | AnyViewResponse;\n\t  })\n\t  | \"\"\n\t  | AnyViewResponse\n\t  | undefined\n\t  | void;\n\texport type SlackOptionsResponse =\n", "  | (SlackResponse & {\n\t    body: AnyOptionsResponse;\n\t  })\n\t  | AnyOptionsResponse;\n\texport function toCompleteResponse(\n\t  slackResponse:\n\t    | SlackResponse\n\t    | MessageResponse\n\t    | SlackViewResponse\n\t    | SlackOptionsResponse\n", "    | string\n\t    | void,\n\t): Response {\n\t  if (!slackResponse) {\n\t    return new Response(\"\", {\n\t      status: 200,\n\t      headers: { \"Content-Type\": \"text/plain\" },\n\t    });\n\t  }\n\t  if (typeof slackResponse === \"string\") {\n", "    return new Response(slackResponse, {\n\t      status: 200,\n\t      headers: { \"Content-Type\": \"text/plain;charset=utf-8\" },\n\t    });\n\t  }\n\t  let completeResponse: SlackResponse = {};\n\t  if (\n\t    Object.prototype.hasOwnProperty.call(slackResponse, \"text\") ||\n\t    Object.prototype.hasOwnProperty.call(slackResponse, \"blocks\")\n\t  ) {\n", "    completeResponse = { status: 200, body: slackResponse as MessageResponse };\n\t  } else if (\n\t    Object.prototype.hasOwnProperty.call(slackResponse, \"response_action\")\n\t  ) {\n\t    completeResponse = { status: 200, body: slackResponse };\n\t  } else if (\n\t    Object.prototype.hasOwnProperty.call(slackResponse, \"options\") ||\n\t    Object.prototype.hasOwnProperty.call(slackResponse, \"option_groups\")\n\t  ) {\n\t    completeResponse = { status: 200, body: slackResponse };\n", "  } else {\n\t    completeResponse = slackResponse as SlackResponse;\n\t  }\n\t  const status = completeResponse.status ? completeResponse.status : 200;\n\t  let contentType = completeResponse.contentType\n\t    ? completeResponse.contentType\n\t    : \"text/plain;charset=utf-8\";\n\t  let bodyString = \"\";\n\t  if (typeof completeResponse.body === \"object\") {\n\t    contentType = \"application/json;charset=utf-8\";\n", "    bodyString = JSON.stringify(completeResponse.body);\n\t  } else {\n\t    bodyString = completeResponse.body || \"\";\n\t  }\n\t  return new Response(bodyString, {\n\t    status,\n\t    headers: { \"Content-Type\": contentType },\n\t  });\n\t}\n"]}
{"filename": "src_deno/utility/message-events.ts", "chunked_list": ["import {\n\t  BotMessageEvent,\n\t  FileShareMessageEvent,\n\t  GenericMessageEvent,\n\t  ThreadBroadcastMessageEvent,\n\t} from \"../request/payload/event.ts\";\n\texport const isPostedMessageEvent = (event: {\n\t  type: string;\n\t  subtype?: string;\n\t}): event is\n", "  | GenericMessageEvent\n\t  | BotMessageEvent\n\t  | FileShareMessageEvent\n\t  | ThreadBroadcastMessageEvent => {\n\t  return (\n\t    event.subtype === undefined ||\n\t    event.subtype === \"bot_message\" ||\n\t    event.subtype === \"file_share\" ||\n\t    event.subtype === \"thread_broadcast\"\n\t  );\n", "};\n"]}
{"filename": "src_deno/request/payload-types.ts", "chunked_list": ["export enum PayloadType {\n\t  BlockAction = \"block_actions\",\n\t  BlockSuggestion = \"block_suggestion\",\n\t  MessageShortcut = \"message_action\",\n\t  GlobalShortcut = \"shortcut\",\n\t  EventsAPI = \"event_callback\",\n\t  ViewSubmission = \"view_submission\",\n\t  ViewClosed = \"view_closed\",\n\t  // Note that Slash command payloads do not have \"type\" property\n\t}\n"]}
{"filename": "src_deno/request/request-parser.ts", "chunked_list": ["// deno-lint-ignore require-await\n\texport async function parseRequestBody(\n\t  requestHeaders: Headers,\n\t  requestBody: string,\n\t): // deno-lint-ignore no-explicit-any\n\tPromise<Record<string, any>> {\n\t  const contentType = requestHeaders.get(\"content-type\");\n\t  if (\n\t    contentType?.startsWith(\"application/json\") ||\n\t    requestBody.startsWith(\"{\")\n", "  ) {\n\t    return JSON.parse(requestBody);\n\t  }\n\t  const params = new URLSearchParams(requestBody);\n\t  if (params.has(\"payload\")) {\n\t    const payload = params.get(\"payload\")!;\n\t    return JSON.parse(payload);\n\t  }\n\t  // deno-lint-ignore no-explicit-any\n\t  const formBody: any = {};\n", "  for (const k of params.keys()) {\n\t    formBody[k] = params.get(k);\n\t  }\n\t  return formBody;\n\t}\n"]}
{"filename": "src_deno/request/request-verification.ts", "chunked_list": ["export async function verifySlackRequest(\n\t  signingSecret: string,\n\t  requsetHeaders: Headers,\n\t  requestBody: string,\n\t) {\n\t  const timestampHeader = requsetHeaders.get(\"x-slack-request-timestamp\");\n\t  if (!timestampHeader) {\n\t    console.log(\"x-slack-request-timestamp header is missing!\");\n\t    return false;\n\t  }\n", "  const fiveMinutesAgoSeconds = Math.floor(Date.now() / 1000) - 60 * 5;\n\t  if (Number.parseInt(timestampHeader) < fiveMinutesAgoSeconds) {\n\t    return false;\n\t  }\n\t  const signatureHeader = requsetHeaders.get(\"x-slack-signature\");\n\t  if (!timestampHeader || !signatureHeader) {\n\t    console.log(\"x-slack-signature header is missing!\");\n\t    return false;\n\t  }\n\t  const textEncoder = new TextEncoder();\n", "  return await crypto.subtle.verify(\n\t    \"HMAC\",\n\t    await crypto.subtle.importKey(\n\t      \"raw\",\n\t      textEncoder.encode(signingSecret),\n\t      { name: \"HMAC\", hash: \"SHA-256\" },\n\t      false,\n\t      [\"verify\"],\n\t    ),\n\t    fromHexStringToBytes(signatureHeader.substring(3)),\n", "    textEncoder.encode(`v0:${timestampHeader}:${requestBody}`),\n\t  );\n\t}\n\tfunction fromHexStringToBytes(hexString: string) {\n\t  const bytes = new Uint8Array(hexString.length / 2);\n\t  for (let idx = 0; idx < hexString.length; idx += 2) {\n\t    bytes[idx / 2] = parseInt(hexString.substring(idx, idx + 2), 16);\n\t  }\n\t  return bytes.buffer;\n\t}\n"]}
{"filename": "src_deno/request/request.ts", "chunked_list": ["import {\n\t  PreAuthorizeSlackAppContext,\n\t  SlackAppContext,\n\t  SlackAppContextWithChannelId,\n\t  SlackAppContextWithOptionalRespond,\n\t  SlackAppContextWithRespond,\n\t} from \"../context/context.ts\";\n\timport { SlackAppEnv } from \"../app-env.ts\";\n\texport interface SlackMiddlewareRequestBase<E extends SlackAppEnv> {\n\t  env: E;\n", "  context: PreAuthorizeSlackAppContext;\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>;\n\t  retryNum?: number;\n\t  retryReason?: string;\n\t  rawBody: string;\n\t  headers: Headers;\n\t}\n\texport type PreAuthorizeSlackMiddlwareRequest<E extends SlackAppEnv> =\n\t  & SlackMiddlewareRequestBase<E>\n", "  & {\n\t    context: PreAuthorizeSlackAppContext;\n\t  };\n\texport type SlackMiddlwareRequest<E extends SlackAppEnv> =\n\t  & SlackMiddlewareRequestBase<E>\n\t  & {\n\t    context: SlackAppContext;\n\t  };\n\texport type SlackRequest<\n\t  E extends SlackAppEnv,\n", "  Payload,\n\t> = SlackMiddlwareRequest<E> & {\n\t  payload: Payload;\n\t};\n\texport type SlackRequestWithChannelId<\n\t  E extends SlackAppEnv,\n\t  Payload,\n\t> = SlackMiddlwareRequest<E> & {\n\t  context: SlackAppContextWithChannelId;\n\t  payload: Payload;\n", "};\n\texport type SlackRequestWithRespond<\n\t  E extends SlackAppEnv,\n\t  Payload,\n\t> = SlackMiddlwareRequest<E> & {\n\t  context: SlackAppContextWithRespond;\n\t  payload: Payload;\n\t};\n\texport type SlackRequestWithOptionalRespond<\n\t  E extends SlackAppEnv,\n", "  Payload,\n\t> = SlackMiddlwareRequest<E> & {\n\t  context: SlackAppContextWithOptionalRespond;\n\t  payload: Payload;\n\t};\n"]}
{"filename": "src_deno/request/request-body.ts", "chunked_list": ["export interface SlackRequestBody {\n\t  type?: string;\n\t  // slash commands\n\t  command?: string;\n\t  // event_callback\n\t  event?: {\n\t    type: string;\n\t    subtype?: string;\n\t    text?: string;\n\t  };\n", "  // shortcut, message_action\n\t  callback_id?: string;\n\t  // block_actions\n\t  actions: {\n\t    type: string;\n\t    block_id: string;\n\t    action_id: string;\n\t  }[];\n\t  // block_suggestion\n\t  block_id?: string;\n", "  action_id?: string;\n\t  // view_submission / view_closed\n\t  view?: {\n\t    callback_id: string;\n\t  };\n\t}\n"]}
{"filename": "src_deno/request/payload/global-shortcut.ts", "chunked_list": ["export interface GlobalShortcut {\n\t  type: \"shortcut\";\n\t  callback_id: string;\n\t  trigger_id: string;\n\t  user: {\n\t    id: string;\n\t    username: string;\n\t    team_id: string;\n\t  };\n\t  team: {\n", "    id: string;\n\t    domain: string;\n\t    enterprise_id?: string;\n\t    enterprise_name?: string;\n\t  } | null;\n\t  token: string;\n\t  action_ts: string;\n\t  is_enterprise_install?: boolean;\n\t  enterprise?: { id: string; name: string };\n\t}\n"]}
{"filename": "src_deno/request/payload/block-suggestion.ts", "chunked_list": ["import { AnyOption } from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\timport { DataSubmissionView } from \"./view-objects.ts\";\n\texport interface BlockSuggestion {\n\t  type: \"block_suggestion\";\n\t  block_id: string;\n\t  action_id: string;\n\t  value: string;\n\t  api_app_id: string;\n\t  team: {\n\t    id: string;\n", "    domain: string;\n\t    enterprise_id?: string;\n\t    enterprise_name?: string;\n\t  } | null;\n\t  channel?: {\n\t    id: string;\n\t    name: string;\n\t  };\n\t  user: {\n\t    id: string;\n", "    name: string;\n\t    team_id?: string;\n\t  };\n\t  token: string;\n\t  // deno-lint-ignore no-explicit-any\n\t  container: any;\n\t  view?: DataSubmissionView;\n\t  is_enterprise_install?: boolean;\n\t  enterprise?: {\n\t    id: string;\n", "    name: string;\n\t  };\n\t}\n\texport interface BlockOptions {\n\t  options: AnyOption[];\n\t}\n\texport interface OptionGroups<Options> {\n\t  option_groups: ({ label: string } & Options)[];\n\t}\n"]}
{"filename": "src_deno/request/payload/slash-command.ts", "chunked_list": ["export interface SlashCommand {\n\t  token: string;\n\t  command: string;\n\t  text: string;\n\t  response_url: string;\n\t  trigger_id: string;\n\t  user_id: string;\n\t  user_name: string;\n\t  team_id: string;\n\t  team_domain: string;\n", "  channel_id: string;\n\t  channel_name: string;\n\t  api_app_id: string;\n\t  enterprise_id?: string;\n\t  enterprise_name?: string;\n\t  is_enterprise_install?: string;\n\t}\n"]}
{"filename": "src_deno/request/payload/view-submission.ts", "chunked_list": ["import { DataSubmissionView } from \"./view-objects.ts\";\n\texport interface ViewSubmission {\n\t  type: \"view_submission\";\n\t  team: {\n\t    id: string;\n\t    domain: string;\n\t    enterprise_id?: string;\n\t    enterprise_name?: string;\n\t  } | null;\n\t  user: {\n", "    id: string;\n\t    name: string;\n\t    team_id?: string;\n\t  };\n\t  view: DataSubmissionView;\n\t  api_app_id: string;\n\t  token: string;\n\t  trigger_id: string;\n\t  is_enterprise_install?: boolean;\n\t  enterprise?: {\n", "    id: string;\n\t    name: string;\n\t  };\n\t  response_urls?: {\n\t    block_id: string;\n\t    action_id: string;\n\t    channel_id: string;\n\t    response_url: string;\n\t  }[];\n\t}\n"]}
{"filename": "src_deno/request/payload/view-closed.ts", "chunked_list": ["import { DataSubmissionView } from \"./view-objects.ts\";\n\texport interface ViewClosed {\n\t  type: \"view_closed\";\n\t  team: {\n\t    id: string;\n\t    domain: string;\n\t    enterprise_id?: string;\n\t    enterprise_name?: string;\n\t  } | null;\n\t  user: {\n", "    id: string;\n\t    name: string;\n\t    team_id?: string;\n\t  };\n\t  view: DataSubmissionView;\n\t  api_app_id: string;\n\t  token: string;\n\t  is_cleared: boolean;\n\t  is_enterprise_install?: boolean;\n\t  enterprise?: { id: string; name: string };\n", "}\n"]}
{"filename": "src_deno/request/payload/view-objects.ts", "chunked_list": ["import {\n\t  AnyActionBlockElementType,\n\t  AnyModalBlock,\n\t  PlainTextField,\n\t} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\texport interface ViewStateSelectedOption {\n\t  text: PlainTextField;\n\t  value: string;\n\t}\n\texport interface ViewStateValue {\n", "  type: AnyActionBlockElementType;\n\t  value?: string | null;\n\t  selected_date?: string | null;\n\t  selected_time?: string | null;\n\t  selected_date_time?: number | null;\n\t  selected_conversation?: string | null;\n\t  selected_channel?: string | null;\n\t  selected_user?: string | null;\n\t  selected_option?: ViewStateSelectedOption | null;\n\t  selected_conversations?: string[];\n", "  selected_channels?: string[];\n\t  selected_users?: string[];\n\t  selected_options?: ViewStateSelectedOption[];\n\t}\n\texport interface DataSubmissionView {\n\t  id: string;\n\t  callback_id: string;\n\t  team_id: string;\n\t  app_installed_team_id?: string;\n\t  app_id: string | null;\n", "  bot_id: string;\n\t  title: PlainTextField;\n\t  type: string;\n\t  blocks: AnyModalBlock[];\n\t  close: PlainTextField | null;\n\t  submit: PlainTextField | null;\n\t  state: {\n\t    values: {\n\t      [blockId: string]: {\n\t        [actionId: string]: ViewStateValue;\n", "      };\n\t    };\n\t  };\n\t  hash: string;\n\t  private_metadata: string;\n\t  root_view_id: string | null;\n\t  previous_view_id: string | null;\n\t  clear_on_close: boolean;\n\t  notify_on_close: boolean;\n\t  external_id?: string;\n", "}\n"]}
{"filename": "src_deno/request/payload/event.ts", "chunked_list": ["import {\n\t  AnyMessageBlock,\n\t  HomeTabView,\n\t  MessageAttachment,\n\t  MessageMetadata,\n\t} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\texport type AnySlackEvent =\n\t  | AppRequestedEvent\n\t  | AppHomeOpenedEvent\n\t  | AppMentionEvent\n", "  | AppRateLimitedEvent\n\t  | AppUninstalledEvent\n\t  | ChannelArchiveEvent\n\t  | ChannelCreatedEvent\n\t  | ChannelDeletedEvent\n\t  | ChannelHistoryChangedEvent\n\t  | ChannelIDChangedEvent\n\t  | ChannelLeftEvent\n\t  | ChannelRenameEvent\n\t  | ChannelSharedEvent\n", "  | ChannelUnarchiveEvent\n\t  | ChannelUnsharedEvent\n\t  | DNDUpdatedEvent\n\t  | DNDUpdatedUserEvent\n\t  | EmailDomainChangedEvent\n\t  | EmojiChangedEvent\n\t  | FileChangeEvent\n\t  | FileCreatedEvent\n\t  | FileDeletedEvent\n\t  | FilePublicEvent\n", "  | FileSharedEvent\n\t  | FileUnsharedEvent\n\t  | GridMigrationFinishedEvent\n\t  | GridMigrationStartedEvent\n\t  | GroupArchiveEvent\n\t  | GroupCloseEvent\n\t  | GroupDeletedEvent\n\t  | GroupHistoryChangedEvent\n\t  | GroupLeftEvent\n\t  | GroupOpenEvent\n", "  | GroupRenameEvent\n\t  | GroupUnarchiveEvent\n\t  | IMCloseEvent\n\t  | IMCreatedEvent\n\t  | IMHistoryChangedEvent\n\t  | IMOpenEvent\n\t  | InviteRequestedEvent\n\t  | LinkSharedEvent\n\t  | MemberJoinedChannelEvent\n\t  | MemberLeftChannelEvent\n", "  | AnyMessageEvent\n\t  | AnyMessageMetadataEvent\n\t  | PinAddedEvent\n\t  | PinRemovedEvent\n\t  | ReactionAddedEvent\n\t  | ReactionRemovedEvent\n\t  | SharedChannelInviteReceivedEvent\n\t  | SharedChannelInviteAcceptedEvent\n\t  | SharedChannelInviteApprovedEvent\n\t  | SharedChannelInviteDeclinedEvent\n", "  | StarAddedEvent\n\t  | StarRemovedEvent\n\t  | SubteamCreatedEvent\n\t  | SubteamMembersChangedEvent\n\t  | SubteamSelfAddedEvent\n\t  | SubteamSelfRemovedEvent\n\t  | SubteamUpdatedEvent\n\t  | TeamAccessGrantedEvent\n\t  | TeamAccessRevokedEvent\n\t  | TeamDomainChangedEvent\n", "  | TeamJoinEvent\n\t  | TeamRenameEvent\n\t  | TokensRevokedEvent\n\t  | UserChangeEvent\n\t  | UserHuddleChangedEvent\n\t  | UserProfileChangedEvent\n\t  | UserStatusChangedEvent\n\t  | WorkflowDeletedEvent\n\t  | WorkflowPublishedEvent\n\t  | WorkflowUnpublishedEvent\n", "  | WorkflowStepDeletedEvent\n\t  | WorkflowStepExecuteEvent;\n\t// These union types may not be a complete set of events\n\texport type AnySlackEventWithChannelId =\n\t  | AppHomeOpenedEvent\n\t  | AppMentionEvent\n\t  | AppUninstalledEvent\n\t  | ChannelArchiveEvent\n\t  | ChannelCreatedEvent\n\t  | ChannelDeletedEvent\n", "  | ChannelIDChangedEvent\n\t  | ChannelLeftEvent\n\t  | ChannelRenameEvent\n\t  | ChannelSharedEvent\n\t  | ChannelUnarchiveEvent\n\t  | ChannelUnsharedEvent\n\t  | FileSharedEvent\n\t  | FileUnsharedEvent\n\t  | GroupArchiveEvent\n\t  | GroupCloseEvent\n", "  | GroupDeletedEvent\n\t  | GroupLeftEvent\n\t  | GroupOpenEvent\n\t  | GroupRenameEvent\n\t  | GroupUnarchiveEvent\n\t  | IMCloseEvent\n\t  | IMCreatedEvent\n\t  | IMOpenEvent\n\t  | InviteRequestedEvent\n\t  | LinkSharedEvent\n", "  | MemberJoinedChannelEvent\n\t  | MemberLeftChannelEvent\n\t  | AnyMessageEvent\n\t  | AnyMessageMetadataEvent\n\t  | PinAddedEvent\n\t  | PinRemovedEvent\n\t  | ReactionAddedEvent\n\t  | ReactionRemovedEvent\n\t  | SharedChannelInviteReceivedEvent\n\t  | SharedChannelInviteAcceptedEvent\n", "  | SharedChannelInviteApprovedEvent\n\t  | SharedChannelInviteDeclinedEvent\n\t  | StarAddedEvent\n\t  | StarRemovedEvent;\n\texport interface SlackEvent<Type extends string> {\n\t  type: Type;\n\t  subtype?: string;\n\t}\n\texport interface AppRequestedEvent extends SlackEvent<\"app_requested\"> {\n\t  type: \"app_requested\";\n", "  app_request: {\n\t    id: string;\n\t    app: {\n\t      id: string;\n\t      name: string;\n\t      description: string;\n\t      help_url: string;\n\t      privacy_policy_url: string;\n\t      app_homepage_url: string;\n\t      app_directory_url: string;\n", "      is_app_directory_approved: boolean;\n\t      is_internal: boolean;\n\t      additional_info: string;\n\t      icons?: {\n\t        image_32?: string;\n\t        image_36?: string;\n\t        image_48?: string;\n\t        image_64?: string;\n\t        image_72?: string;\n\t        image_96?: string;\n", "        image_128?: string;\n\t        image_192?: string;\n\t        image_512?: string;\n\t        image_1024?: string;\n\t        image_original?: string;\n\t      };\n\t    };\n\t  };\n\t  previous_resolution: {\n\t    status: \"approved\" | \"restricted\";\n", "    scopes: {\n\t      name: string;\n\t      description: string;\n\t      is_dangerous: boolean;\n\t      token_type: \"bot\" | \"user\" | \"app\" | null;\n\t    };\n\t  } | null;\n\t  is_user_app_collaborator: boolean;\n\t  user: {\n\t    id: string;\n", "    name: string;\n\t    email: string;\n\t  };\n\t  team: {\n\t    id: string;\n\t    name: string;\n\t    domain: string;\n\t  };\n\t  scopes: {\n\t    name: string;\n", "    description: string;\n\t    is_dangerous: boolean;\n\t    token_type: \"bot\" | \"user\" | \"app\" | null;\n\t  };\n\t  message: string;\n\t  date_created: number;\n\t}\n\texport interface AppHomeOpenedEvent extends SlackEvent<\"app_home_opened\"> {\n\t  type: \"app_home_opened\";\n\t  user: string;\n", "  channel: string;\n\t  tab: \"home\" | \"messages\";\n\t  view?: HomeTabView;\n\t  event_ts: string;\n\t}\n\texport interface AppMentionEvent extends SlackEvent<\"app_mention\"> {\n\t  type: \"app_mention\";\n\t  subtype?: string;\n\t  bot_id?: string;\n\t  bot_profile?: BotProfile;\n", "  username: string;\n\t  team?: string;\n\t  user?: string;\n\t  text: string;\n\t  attachments?: MessageAttachment[];\n\t  blocks?: AnyMessageBlock[];\n\t  edited?: {\n\t    user: string;\n\t    ts: string;\n\t  };\n", "  ts: string;\n\t  channel: string;\n\t  event_ts: string;\n\t  thread_ts?: string;\n\t}\n\texport interface AppRateLimitedEvent extends SlackEvent<\"app_rate_limited\"> {\n\t  type: \"app_rate_limited\";\n\t  token: string;\n\t  team_id: string;\n\t  minute_rate_limited: number;\n", "  api_app_id: string;\n\t}\n\texport interface AppUninstalledEvent extends SlackEvent<\"app_uninstalled\"> {\n\t  type: \"app_uninstalled\";\n\t}\n\texport interface ChannelArchiveEvent extends SlackEvent<\"channel_archive\"> {\n\t  type: \"channel_archive\";\n\t  channel: string;\n\t  user: string;\n\t  is_moved?: number;\n", "  event_ts: string;\n\t}\n\texport interface ChannelCreatedEvent extends SlackEvent<\"channel_created\"> {\n\t  type: \"channel_created\";\n\t  channel: {\n\t    id: string;\n\t    is_channel: boolean;\n\t    name: string;\n\t    name_normalized: string;\n\t    created: number;\n", "    creator: string;\n\t    is_shared: boolean;\n\t    is_org_shared: boolean;\n\t  };\n\t}\n\texport interface ChannelDeletedEvent extends SlackEvent<\"channel_deleted\"> {\n\t  type: \"channel_deleted\";\n\t  channel: string;\n\t}\n\texport interface ChannelHistoryChangedEvent\n", "  extends SlackEvent<\"channel_history_changed\"> {\n\t  type: \"channel_history_changed\";\n\t  latest: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelIDChangedEvent\n\t  extends SlackEvent<\"channel_id_changed\"> {\n\t  type: \"channel_id_changed\";\n\t  old_channel_id: string;\n", "  new_channel_id: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelLeftEvent extends SlackEvent<\"channel_left\"> {\n\t  type: \"channel_left\";\n\t  channel: string;\n\t  actor_id: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelRenameEvent extends SlackEvent<\"channel_rename\"> {\n", "  type: \"channel_rename\";\n\t  channel: {\n\t    id: string;\n\t    name: string;\n\t    name_normalized: string;\n\t    created: number;\n\t    is_channel: boolean;\n\t    is_mpim: boolean;\n\t  };\n\t  event_ts: string;\n", "}\n\texport interface ChannelSharedEvent extends SlackEvent<\"channel_shared\"> {\n\t  type: \"channel_shared\";\n\t  connected_team_id: string;\n\t  channel: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelUnarchiveEvent extends SlackEvent<\"channel_unarchive\"> {\n\t  type: \"channel_unarchive\";\n\t  channel: string;\n", "  user: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelUnsharedEvent extends SlackEvent<\"channel_unshared\"> {\n\t  type: \"channel_unshared\";\n\t  previously_connected_team_id: string;\n\t  channel: string;\n\t  is_ext_shared: boolean;\n\t  event_ts: string;\n\t}\n", "export interface DNDUpdatedEvent extends SlackEvent<\"dnd_updated\"> {\n\t  type: \"dnd_updated\";\n\t  user: string;\n\t  dnd_status: {\n\t    dnd_enabled: boolean;\n\t    next_dnd_start_ts: number;\n\t    next_dnd_end_ts: number;\n\t    snooze_enabled: boolean;\n\t    snooze_endtime: number;\n\t    snooze_remaining: number;\n", "  };\n\t  event_ts: string;\n\t}\n\texport interface DNDUpdatedUserEvent extends SlackEvent<\"dnd_updated_user\"> {\n\t  type: \"dnd_updated_user\";\n\t  user: string;\n\t  dnd_status: {\n\t    dnd_enabled: boolean;\n\t    next_dnd_start_ts: number;\n\t    next_dnd_end_ts: number;\n", "  };\n\t  event_ts: string;\n\t}\n\texport interface EmailDomainChangedEvent\n\t  extends SlackEvent<\"email_domain_changed\"> {\n\t  type: \"email_domain_changed\";\n\t  email_domain: string;\n\t  event_ts: string;\n\t}\n\t// NOTE: this should probably be broken into its two subtypes\n", "export interface EmojiChangedEvent extends SlackEvent<\"emoji_changed\"> {\n\t  type: \"emoji_changed\";\n\t  subtype: \"add\" | \"remove\" | \"rename\";\n\t  names?: string[]; // only for remove\n\t  name?: string; // only for add\n\t  value?: string; // only for add\n\t  old_name?: string;\n\t  new_name?: string;\n\t  event_ts: string;\n\t}\n", "export interface FileChangeEvent extends SlackEvent<\"file_change\"> {\n\t  type: \"file_change\";\n\t  file_id: string;\n\t  file: { id: string };\n\t}\n\texport interface FileCreatedEvent extends SlackEvent<\"file_created\"> {\n\t  type: \"file_created\";\n\t  file_id: string;\n\t  user_id: string;\n\t  file: { id: string };\n", "  event_ts: string;\n\t}\n\texport interface FileDeletedEvent extends SlackEvent<\"file_deleted\"> {\n\t  type: \"file_deleted\";\n\t  file_id: string;\n\t  channel_ids?: string[];\n\t  event_ts: string;\n\t}\n\texport interface FilePublicEvent extends SlackEvent<\"file_public\"> {\n\t  type: \"file_public\";\n", "  file_id: string;\n\t  user_id: string;\n\t  file: { id: string };\n\t  event_ts: string;\n\t}\n\texport interface FileSharedEvent extends SlackEvent<\"file_shared\"> {\n\t  type: \"file_shared\";\n\t  file_id: string;\n\t  user_id: string;\n\t  file: { id: string };\n", "  channel_id: string;\n\t  event_ts: string;\n\t}\n\texport interface FileUnsharedEvent extends SlackEvent<\"file_unshared\"> {\n\t  type: \"file_unshared\";\n\t  file_id: string;\n\t  user_id: string;\n\t  file: { id: string };\n\t  channel_id: string;\n\t  event_ts: string;\n", "}\n\texport interface GridMigrationFinishedEvent\n\t  extends SlackEvent<\"grid_migration_finished\"> {\n\t  type: \"grid_migration_finished\";\n\t  enterprise_id: string;\n\t}\n\texport interface GridMigrationStartedEvent\n\t  extends SlackEvent<\"grid_migration_started\"> {\n\t  type: \"grid_migration_started\";\n\t  enterprise_id: string;\n", "}\n\texport interface GroupArchiveEvent extends SlackEvent<\"group_archive\"> {\n\t  type: \"group_archive\";\n\t  channel: string;\n\t  user: string;\n\t  is_moved: number;\n\t  event_ts: string;\n\t}\n\texport interface GroupCloseEvent extends SlackEvent<\"group_close\"> {\n\t  type: \"group_close\";\n", "  user: string;\n\t  channel: string;\n\t}\n\texport interface GroupDeletedEvent extends SlackEvent<\"group_deleted\"> {\n\t  type: \"group_deleted\";\n\t  channel: string;\n\t  date_deleted: number;\n\t  actor_id: string;\n\t  event_ts: string;\n\t}\n", "export interface GroupHistoryChangedEvent\n\t  extends SlackEvent<\"group_history_changed\"> {\n\t  type: \"group_history_changed\";\n\t  latest: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n\texport interface GroupLeftEvent extends SlackEvent<\"group_left\"> {\n\t  type: \"group_left\";\n\t  channel: string;\n", "  actor_id: string;\n\t  event_ts: string;\n\t}\n\texport interface GroupOpenEvent extends SlackEvent<\"group_open\"> {\n\t  type: \"group_open\";\n\t  user: string;\n\t  channel: string;\n\t}\n\texport interface GroupRenameEvent extends SlackEvent<\"group_rename\"> {\n\t  type: \"group_rename\";\n", "  channel: {\n\t    id: string;\n\t    name: string;\n\t    name_normalized: string;\n\t    created: number;\n\t    is_channel: boolean;\n\t    is_mpim: boolean;\n\t  };\n\t  event_ts: string;\n\t}\n", "export interface GroupUnarchiveEvent extends SlackEvent<\"group_unarchive\"> {\n\t  type: \"group_unarchive\";\n\t  channel: string;\n\t  actor_id: string;\n\t  event_ts: string;\n\t}\n\texport interface IMCloseEvent extends SlackEvent<\"im_close\"> {\n\t  type: \"im_close\";\n\t  user: string;\n\t  channel: string;\n", "  event_ts: string;\n\t}\n\texport interface IMCreatedEvent extends SlackEvent<\"im_created\"> {\n\t  type: \"im_created\";\n\t  user: string;\n\t  channel: { id: string };\n\t}\n\texport interface IMHistoryChangedEvent\n\t  extends SlackEvent<\"im_history_changed\"> {\n\t  type: \"im_history_changed\";\n", "  latest: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n\texport interface IMOpenEvent extends SlackEvent<\"im_open\"> {\n\t  type: \"im_open\";\n\t  user: string;\n\t  channel: string;\n\t  event_ts: string;\n\t}\n", "export interface InviteRequestedEvent extends SlackEvent<\"invite_requested\"> {\n\t  type: \"invite_requested\";\n\t  invite_request: {\n\t    id: string;\n\t    email: string;\n\t    date_created: number;\n\t    requester_ids: string[];\n\t    channel_ids: string[];\n\t    invite_type: \"restricted\" | \"ultra_restricted\" | \"full_member\";\n\t    real_name: string;\n", "    date_expire: number;\n\t    request_reason: string;\n\t    team: {\n\t      id: string;\n\t      name: string;\n\t      domain: string;\n\t    };\n\t  };\n\t}\n\texport interface LinkSharedEvent extends SlackEvent<\"link_shared\"> {\n", "  type: \"link_shared\";\n\t  channel: string;\n\t  is_bot_user_member: boolean;\n\t  user: string;\n\t  message_ts: string;\n\t  thread_ts?: string;\n\t  links: {\n\t    domain: string;\n\t    url: string;\n\t  }[];\n", "  unfurl_id?: string;\n\t  source?: string;\n\t  event_ts: string;\n\t}\n\texport interface MemberJoinedChannelEvent\n\t  extends SlackEvent<\"member_joined_channel\"> {\n\t  type: \"member_joined_channel\";\n\t  user: string;\n\t  channel: string;\n\t  channel_type: string;\n", "  team: string;\n\t  inviter?: string;\n\t  event_ts: string;\n\t}\n\texport interface MemberLeftChannelEvent\n\t  extends SlackEvent<\"member_left_channel\"> {\n\t  type: \"member_left_channel\";\n\t  user: string;\n\t  channel: string;\n\t  channel_type: string;\n", "  team: string;\n\t  event_ts: string;\n\t}\n\texport interface PinAddedEvent extends SlackEvent<\"pin_added\"> {\n\t  type: \"pin_added\";\n\t  user: string;\n\t  channel_id: string;\n\t  item: PinnedItem;\n\t  item_user: string;\n\t  pin_count: string;\n", "  pinned_info: {\n\t    channel: string;\n\t    pinned_by: string;\n\t    pinned_ts: number;\n\t  };\n\t  event_ts: string;\n\t}\n\texport interface PinRemovedEvent extends SlackEvent<\"pin_removed\"> {\n\t  type: \"pin_removed\";\n\t  user: string;\n", "  channel_id: string;\n\t  item: PinnedItem;\n\t  item_user: string;\n\t  pin_count: string;\n\t  pinned_info: {\n\t    channel: string;\n\t    pinned_by: string;\n\t    pinned_ts: number;\n\t  };\n\t  has_pins: boolean;\n", "  event_ts: string;\n\t}\n\texport interface ReactionAddedEvent extends SlackEvent<\"reaction_added\"> {\n\t  type: \"reaction_added\";\n\t  user: string;\n\t  reaction: string;\n\t  item_user: string;\n\t  item: ReactionMessageItem;\n\t  event_ts: string;\n\t}\n", "export interface ReactionRemovedEvent extends SlackEvent<\"reaction_removed\"> {\n\t  type: \"reaction_removed\";\n\t  user: string;\n\t  reaction: string;\n\t  item_user: string;\n\t  item: ReactionMessageItem;\n\t  event_ts: string;\n\t}\n\texport interface SharedChannelInviteAcceptedEvent\n\t  extends SlackEvent<\"shared_channel_invite_accepted\"> {\n", "  type: \"shared_channel_invite_accepted\";\n\t  approval_required: boolean;\n\t  invite: SharedChannelInviteItem;\n\t  channel: SharedChannelItem;\n\t  teams_in_channel: SharedChannelTeamItem[];\n\t  accepting_user: SharedChannelUserItem;\n\t  event_ts: string;\n\t}\n\texport interface SharedChannelInviteApprovedEvent\n\t  extends SlackEvent<\"shared_channel_invite_approved\"> {\n", "  type: \"shared_channel_invite_approved\";\n\t  invite: SharedChannelInviteItem;\n\t  channel: SharedChannelItem;\n\t  approving_team_id: string;\n\t  teams_in_channel: SharedChannelTeamItem[];\n\t  approving_user: SharedChannelUserItem;\n\t  event_ts: string;\n\t}\n\texport interface SharedChannelInviteDeclinedEvent\n\t  extends SlackEvent<\"shared_channel_invite_declined\"> {\n", "  type: \"shared_channel_invite_declined\";\n\t  invite: SharedChannelInviteItem;\n\t  channel: SharedChannelItem;\n\t  declining_team_id: string;\n\t  teams_in_channel: SharedChannelTeamItem[];\n\t  declining_user: SharedChannelUserItem;\n\t  event_ts: string;\n\t}\n\texport interface SharedChannelInviteReceivedEvent\n\t  extends SlackEvent<\"shared_channel_invite_received\"> {\n", "  type: \"shared_channel_invite_received\";\n\t  invite: SharedChannelInviteItem;\n\t  channel: SharedChannelItem;\n\t  event_ts: string;\n\t}\n\texport interface StarAddedEvent extends SlackEvent<\"star_added\"> {\n\t  type: \"star_added\";\n\t  user: string;\n\t  item: StarItem;\n\t  event_ts: string;\n", "}\n\texport interface StarRemovedEvent extends SlackEvent<\"star_removed\"> {\n\t  type: \"star_removed\";\n\t  user: string;\n\t  item: StarItem;\n\t  event_ts: string;\n\t}\n\texport interface SubteamCreatedEvent extends SlackEvent<\"subteam_created\"> {\n\t  type: \"subteam_created\";\n\t  subteam: Subteam;\n", "  event_ts: string;\n\t}\n\texport interface SubteamMembersChangedEvent\n\t  extends SlackEvent<\"subteam_members_changed\"> {\n\t  type: \"subteam_members_changed\";\n\t  subteam_id: string;\n\t  team_id: string;\n\t  date_previous_update: number;\n\t  date_update: number;\n\t  added_users?: string[];\n", "  added_users_count?: number;\n\t  removed_users?: string[];\n\t  removed_users_count?: number;\n\t  event_ts: string;\n\t}\n\texport interface SubteamSelfAddedEvent\n\t  extends SlackEvent<\"subteam_self_added\"> {\n\t  type: \"subteam_self_added\";\n\t  subteam_id: string;\n\t  event_ts: string;\n", "}\n\texport interface SubteamSelfRemovedEvent\n\t  extends SlackEvent<\"subteam_self_removed\"> {\n\t  type: \"subteam_self_removed\";\n\t  subteam_id: string;\n\t  event_ts: string;\n\t}\n\texport interface SubteamUpdatedEvent extends SlackEvent<\"subteam_updated\"> {\n\t  type: \"subteam_updated\";\n\t  subteam: Subteam;\n", "  event_ts: string;\n\t}\n\texport interface TeamAccessGrantedEvent\n\t  extends SlackEvent<\"team_access_granted\"> {\n\t  type: \"team_access_granted\";\n\t  team_ids: string[];\n\t  event_ts: string;\n\t}\n\texport interface TeamAccessRevokedEvent\n\t  extends SlackEvent<\"team_access_revoked\"> {\n", "  type: \"team_access_revoked\";\n\t  team_ids: string[];\n\t  event_ts: string;\n\t}\n\texport interface TeamDomainChangedEvent\n\t  extends SlackEvent<\"team_domain_changed\"> {\n\t  type: \"team_domain_changed\";\n\t  url: string;\n\t  domain: string;\n\t}\n", "export interface TeamJoinEvent extends SlackEvent<\"team_join\"> {\n\t  type: \"team_join\";\n\t  user: { id: string };\n\t}\n\texport interface TeamRenameEvent extends SlackEvent<\"team_rename\"> {\n\t  type: \"team_rename\";\n\t  name: string;\n\t}\n\texport interface TokensRevokedEvent extends SlackEvent<\"tokens_revoked\"> {\n\t  type: \"tokens_revoked\";\n", "  tokens: {\n\t    oauth?: string[];\n\t    bot?: string[];\n\t  };\n\t}\n\texport interface UserChangeEvent extends SlackEvent<\"user_change\"> {\n\t  type: \"user_change\";\n\t  user: {\n\t    id: string;\n\t    team_id: string;\n", "    name: string;\n\t    deleted: boolean;\n\t    color: string;\n\t    real_name: string;\n\t    tz: string;\n\t    tz_label: string;\n\t    tz_offset: number;\n\t    profile: {\n\t      title: string;\n\t      phone: string;\n", "      skype: string;\n\t      real_name: string;\n\t      real_name_normalized: string;\n\t      display_name: string;\n\t      display_name_normalized: string;\n\t      status_text: string;\n\t      status_text_canonical: string;\n\t      status_emoji: string;\n\t      status_emoji_display_info: StatusEmojiDisplayInfo[];\n\t      status_expiration: number;\n", "      avatar_hash: string;\n\t      huddle_state?: string;\n\t      huddle_state_expiration_ts?: number;\n\t      first_name: string;\n\t      last_name: string;\n\t      email?: string;\n\t      image_original?: string;\n\t      is_custom_image?: boolean;\n\t      image_24: string;\n\t      image_32: string;\n", "      image_48: string;\n\t      image_72: string;\n\t      image_192: string;\n\t      image_512: string;\n\t      image_1024?: string;\n\t      team: string;\n\t      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n\t    };\n\t    is_admin: boolean;\n\t    is_owner: boolean;\n", "    is_primary_owner: boolean;\n\t    is_restricted: boolean;\n\t    is_ultra_restricted: boolean;\n\t    is_bot: boolean;\n\t    is_stranger?: boolean;\n\t    updated: number;\n\t    is_email_confirmed: boolean;\n\t    is_app_user: boolean;\n\t    is_invited_user?: boolean;\n\t    has_2fa?: boolean;\n", "    locale: string;\n\t    presence?: string;\n\t    enterprise_user?: {\n\t      id: string;\n\t      enterprise_id: string;\n\t      enterprise_name: string;\n\t      is_admin: boolean;\n\t      is_owner: boolean;\n\t      teams: string[];\n\t    };\n", "    two_factor_type?: string;\n\t    has_files?: boolean;\n\t    is_workflow_bot?: boolean;\n\t    who_can_share_contact_card: string;\n\t  };\n\t  cache_ts: number;\n\t  event_ts: string;\n\t}\n\texport interface UserHuddleChangedEvent\n\t  extends SlackEvent<\"user_huddle_changed\"> {\n", "  type: \"user_huddle_changed\";\n\t  user: {\n\t    id: string;\n\t    team_id: string;\n\t    name: string;\n\t    deleted: boolean;\n\t    color: string;\n\t    real_name: string;\n\t    tz: string;\n\t    tz_label: string;\n", "    tz_offset: number;\n\t    profile: {\n\t      title: string;\n\t      phone: string;\n\t      skype: string;\n\t      real_name: string;\n\t      real_name_normalized: string;\n\t      display_name: string;\n\t      display_name_normalized: string;\n\t      status_text: string;\n", "      status_text_canonical: string;\n\t      status_emoji: string;\n\t      status_emoji_display_info: StatusEmojiDisplayInfo[];\n\t      status_expiration: number;\n\t      avatar_hash: string;\n\t      huddle_state: string;\n\t      huddle_state_expiration_ts: number;\n\t      first_name: string;\n\t      last_name: string;\n\t      email?: string;\n", "      image_original?: string;\n\t      is_custom_image?: boolean;\n\t      image_24: string;\n\t      image_32: string;\n\t      image_48: string;\n\t      image_72: string;\n\t      image_192: string;\n\t      image_512: string;\n\t      image_1024?: string;\n\t      team: string;\n", "      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n\t    };\n\t    is_admin: boolean;\n\t    is_owner: boolean;\n\t    is_primary_owner: boolean;\n\t    is_restricted: boolean;\n\t    is_ultra_restricted: boolean;\n\t    is_bot: boolean;\n\t    is_stranger?: boolean;\n\t    updated: number;\n", "    is_email_confirmed: boolean;\n\t    is_app_user: boolean;\n\t    is_invited_user?: boolean;\n\t    has_2fa?: boolean;\n\t    locale: string;\n\t    presence?: string;\n\t    enterprise_user?: {\n\t      id: string;\n\t      enterprise_id: string;\n\t      enterprise_name: string;\n", "      is_admin: boolean;\n\t      is_owner: boolean;\n\t      teams: string[];\n\t    };\n\t    two_factor_type?: string;\n\t    has_files?: boolean;\n\t    is_workflow_bot?: boolean;\n\t    who_can_share_contact_card: string;\n\t  };\n\t  cache_ts: number;\n", "  event_ts: string;\n\t}\n\texport interface UserProfileChangedEvent\n\t  extends SlackEvent<\"user_profile_changed\"> {\n\t  type: \"user_profile_changed\";\n\t  user: {\n\t    id: string;\n\t    team_id: string;\n\t    name: string;\n\t    deleted: boolean;\n", "    color: string;\n\t    real_name: string;\n\t    tz: string;\n\t    tz_label: string;\n\t    tz_offset: number;\n\t    profile: {\n\t      title: string;\n\t      phone: string;\n\t      skype: string;\n\t      real_name: string;\n", "      real_name_normalized: string;\n\t      display_name: string;\n\t      display_name_normalized: string;\n\t      status_text: string;\n\t      status_text_canonical: string;\n\t      status_emoji: string;\n\t      status_emoji_display_info: StatusEmojiDisplayInfo[];\n\t      status_expiration: number;\n\t      avatar_hash: string;\n\t      huddle_state: string;\n", "      huddle_state_expiration_ts: number;\n\t      first_name: string;\n\t      last_name: string;\n\t      email?: string;\n\t      image_original?: string;\n\t      is_custom_image?: boolean;\n\t      image_24: string;\n\t      image_32: string;\n\t      image_48: string;\n\t      image_72: string;\n", "      image_192: string;\n\t      image_512: string;\n\t      image_1024?: string;\n\t      team: string;\n\t      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n\t    };\n\t    is_admin: boolean;\n\t    is_owner: boolean;\n\t    is_primary_owner: boolean;\n\t    is_restricted: boolean;\n", "    is_ultra_restricted: boolean;\n\t    is_bot: boolean;\n\t    is_stranger?: boolean;\n\t    updated: number;\n\t    is_email_confirmed: boolean;\n\t    is_app_user: boolean;\n\t    is_invited_user?: boolean;\n\t    has_2fa?: boolean;\n\t    locale: string;\n\t    presence?: string;\n", "    enterprise_user?: {\n\t      id: string;\n\t      enterprise_id: string;\n\t      enterprise_name: string;\n\t      is_admin: boolean;\n\t      is_owner: boolean;\n\t      teams: string[];\n\t    };\n\t    two_factor_type?: string;\n\t    has_files?: boolean;\n", "    is_workflow_bot?: boolean;\n\t    who_can_share_contact_card: string;\n\t  };\n\t  cache_ts: number;\n\t  event_ts: string;\n\t}\n\texport interface UserStatusChangedEvent\n\t  extends SlackEvent<\"user_status_changed\"> {\n\t  type: \"user_status_changed\";\n\t  user: {\n", "    id: string;\n\t    team_id: string;\n\t    name: string;\n\t    deleted: boolean;\n\t    color: string;\n\t    real_name: string;\n\t    tz: string;\n\t    tz_label: string;\n\t    tz_offset: number;\n\t    profile: {\n", "      title: string;\n\t      phone: string;\n\t      skype: string;\n\t      real_name: string;\n\t      real_name_normalized: string;\n\t      display_name: string;\n\t      display_name_normalized: string;\n\t      status_text: string;\n\t      status_text_canonical: string;\n\t      status_emoji: string;\n", "      status_emoji_display_info: StatusEmojiDisplayInfo[];\n\t      status_expiration: number;\n\t      avatar_hash: string;\n\t      first_name: string;\n\t      last_name: string;\n\t      email?: string;\n\t      image_original?: string;\n\t      is_custom_image?: boolean;\n\t      image_24: string;\n\t      image_32: string;\n", "      image_48: string;\n\t      image_72: string;\n\t      image_192: string;\n\t      image_512: string;\n\t      image_1024?: string;\n\t      team: string;\n\t      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n\t    };\n\t    is_admin: boolean;\n\t    is_owner: boolean;\n", "    is_primary_owner: boolean;\n\t    is_restricted: boolean;\n\t    is_ultra_restricted: boolean;\n\t    is_bot: boolean;\n\t    is_stranger?: boolean;\n\t    updated: number;\n\t    is_email_confirmed: boolean;\n\t    is_app_user: boolean;\n\t    is_invited_user?: boolean;\n\t    has_2fa?: boolean;\n", "    locale: string;\n\t    presence?: string;\n\t    enterprise_user?: {\n\t      id: string;\n\t      enterprise_id: string;\n\t      enterprise_name: string;\n\t      is_admin: boolean;\n\t      is_owner: boolean;\n\t      teams: string[];\n\t    };\n", "    two_factor_type?: string;\n\t    has_files?: boolean;\n\t    is_workflow_bot?: boolean;\n\t    who_can_share_contact_card: string;\n\t  };\n\t  cache_ts: number;\n\t  event_ts: string;\n\t}\n\texport interface WorkflowDeletedEvent extends SlackEvent<\"workflow_deleted\"> {\n\t  type: \"workflow_deleted\";\n", "  workflow_id: string;\n\t  workflow_draft_configuration: {\n\t    version_id: string;\n\t    app_steps: {\n\t      app_id: string;\n\t      workflow_step_id: string;\n\t      callback_id: string;\n\t    }[];\n\t  };\n\t  event_ts: string;\n", "}\n\texport interface WorkflowPublishedEvent\n\t  extends SlackEvent<\"workflow_published\"> {\n\t  type: \"workflow_published\";\n\t  workflow_id: string;\n\t  workflow_published_configuration: {\n\t    version_id: string;\n\t    app_steps: {\n\t      app_id: string;\n\t      workflow_step_id: string;\n", "      callback_id: string;\n\t    }[];\n\t  };\n\t  event_ts: string;\n\t}\n\texport interface WorkflowUnpublishedEvent\n\t  extends SlackEvent<\"workflow_unpublished\"> {\n\t  type: \"workflow_unpublished\";\n\t  workflow_id: string;\n\t  workflow_draft_configuration: {\n", "    version_id: string;\n\t    app_steps: {\n\t      app_id: string;\n\t      workflow_step_id: string;\n\t      callback_id: string;\n\t    }[];\n\t  };\n\t  event_ts: string;\n\t}\n\texport interface WorkflowStepDeletedEvent\n", "  extends SlackEvent<\"workflow_step_deleted\"> {\n\t  type: \"workflow_step_deleted\";\n\t  workflow_id: string;\n\t  workflow_draft_configuration: {\n\t    version_id: string;\n\t    app_steps: {\n\t      app_id: string;\n\t      workflow_step_id: string;\n\t      callback_id: string;\n\t    }[];\n", "  };\n\t  workflow_published_configuration?: {\n\t    version_id: string;\n\t    app_steps: {\n\t      app_id: string;\n\t      workflow_step_id: string;\n\t      callback_id: string;\n\t    }[];\n\t  };\n\t  event_ts: string;\n", "}\n\texport interface WorkflowStepExecuteEvent\n\t  extends SlackEvent<\"workflow_step_execute\"> {\n\t  type: \"workflow_step_execute\";\n\t  callback_id: string;\n\t  workflow_step: {\n\t    workflow_step_execute_id: string;\n\t    workflow_id: string;\n\t    workflow_instance_id: string;\n\t    step_id: string;\n", "    // deno-lint-ignore no-explicit-any\n\t    inputs: { [key: string]: { value: any } };\n\t    outputs: { name: string; type: string; label: string }[];\n\t  };\n\t  event_ts: string;\n\t}\n\texport type AnyMessageEvent =\n\t  | GenericMessageEvent\n\t  | BotMessageEvent\n\t  | ChannelArchiveMessageEvent\n", "  | ChannelJoinMessageEvent\n\t  | ChannelLeaveMessageEvent\n\t  | ChannelNameMessageEvent\n\t  | ChannelPostingPermissionsMessageEvent\n\t  | ChannelPurposeMessageEvent\n\t  | ChannelTopicMessageEvent\n\t  | ChannelUnarchiveMessageEvent\n\t  | EKMAccessDeniedMessageEvent\n\t  | FileShareMessageEvent\n\t  | MeMessageEvent\n", "  | MessageChangedEvent\n\t  | MessageDeletedEvent\n\t  | MessageRepliedEvent\n\t  | ThreadBroadcastMessageEvent;\n\texport type AnyMessageItem =\n\t  | GenericMessageEvent\n\t  | BotMessageEvent\n\t  | ChannelArchiveMessageEvent\n\t  | ChannelJoinMessageEvent\n\t  | ChannelLeaveMessageEvent\n", "  | ChannelNameMessageEvent\n\t  | ChannelPostingPermissionsMessageEvent\n\t  | ChannelPurposeMessageEvent\n\t  | ChannelTopicMessageEvent\n\t  | ChannelUnarchiveMessageEvent\n\t  | EKMAccessDeniedMessageEvent\n\t  | FileShareMessageEvent\n\t  | MeMessageEvent\n\t  | MessageRepliedEvent\n\t  | ThreadBroadcastMessageEvent;\n", "export type AnyMessageMetadataEvent =\n\t  | MessageMetadataPostedEvent\n\t  | MessageMetadataUpdatedEvent\n\t  | MessageMetadataDeletedEvent;\n\texport interface GenericMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: undefined;\n\t  event_ts: string;\n\t  team?: string;\n\t  channel: string;\n", "  user: string;\n\t  bot_id?: string;\n\t  bot_profile?: BotProfile;\n\t  text: string;\n\t  ts: string;\n\t  thread_ts?: string;\n\t  channel_type: AnyChannelType;\n\t  attachments?: MessageAttachment[];\n\t  blocks?: AnyMessageBlock[];\n\t  files?: File[];\n", "  edited?: {\n\t    user: string;\n\t    ts: string;\n\t  };\n\t  client_msg_id?: string;\n\t  parent_user_id?: string;\n\t  // TODO: optional types that maybe should flow into other subtypes?\n\t  is_starred?: boolean;\n\t  pinned_to?: string[];\n\t  reactions?: {\n", "    name: string;\n\t    count: number;\n\t    users: string[];\n\t  }[];\n\t}\n\texport interface BotMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"bot_message\";\n\t  event_ts: string;\n\t  channel: string;\n", "  channel_type: AnyChannelType;\n\t  ts: string;\n\t  text: string;\n\t  bot_id: string;\n\t  username?: string;\n\t  icons?: {\n\t    [size: string]: string;\n\t  };\n\t  // copied from MessageEvent\n\t  // TODO: is a user really optional? likely for things like IncomingWebhook authored messages\n", "  user?: string;\n\t  attachments?: MessageAttachment[];\n\t  blocks?: AnyMessageBlock[];\n\t  edited?: {\n\t    user: string;\n\t    ts: string;\n\t  };\n\t  thread_ts?: string;\n\t}\n\texport interface ChannelArchiveMessageEvent extends SlackEvent<\"message\"> {\n", "  type: \"message\";\n\t  subtype: \"channel_archive\";\n\t  team: string;\n\t  user: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  text: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n", "export interface ChannelJoinMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"channel_join\";\n\t  team: string;\n\t  user: string;\n\t  inviter: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  text: string;\n\t  ts: string;\n", "  event_ts: string;\n\t}\n\texport interface ChannelLeaveMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"channel_leave\";\n\t  team: string;\n\t  user: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  text: string;\n", "  ts: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelNameMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"channel_name\";\n\t  team: string;\n\t  user: string;\n\t  name: string;\n\t  old_name: string;\n", "  channel: string;\n\t  channel_type: AnyChannelType;\n\t  text: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelPostingPermissionsMessageEvent\n\t  extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"channel_posting_permissions\";\n", "  user: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  text: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelPurposeMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"channel_purpose\";\n", "  user: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  text: string;\n\t  purpose: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelTopicMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n", "  subtype: \"channel_topic\";\n\t  user: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  text: string;\n\t  topic: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelUnarchiveMessageEvent extends SlackEvent<\"message\"> {\n", "  type: \"message\";\n\t  subtype: \"channel_unarchive\";\n\t  team: string;\n\t  user: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  text: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n", "export interface EKMAccessDeniedMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"ekm_access_denied\";\n\t  event_ts: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  ts: string;\n\t  text: string; // This will not have any meaningful content within\n\t  user: \"UREVOKEDU\";\n\t}\n", "export interface FileShareMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"file_share\";\n\t  text: string;\n\t  attachments?: MessageAttachment[];\n\t  blocks?: AnyMessageBlock[];\n\t  files?: File[];\n\t  upload?: boolean;\n\t  display_as_bot?: boolean;\n\t  x_files?: string[];\n", "  user: string;\n\t  parent_user_id?: string;\n\t  ts: string;\n\t  thread_ts?: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  event_ts: string;\n\t}\n\texport interface MeMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n", "  subtype: \"me_message\";\n\t  event_ts: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  user: string;\n\t  text: string;\n\t  ts: string;\n\t}\n\texport interface MessageChangedEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n", "  subtype: \"message_changed\";\n\t  event_ts: string;\n\t  hidden: true;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  ts: string;\n\t  message: AnyMessageItem;\n\t  previous_message: AnyMessageItem;\n\t}\n\texport interface MessageDeletedEvent {\n", "  type: \"message\";\n\t  subtype: \"message_deleted\";\n\t  event_ts: string;\n\t  hidden: true;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  ts: string;\n\t  deleted_ts: string;\n\t  previous_message: AnyMessageItem;\n\t}\n", "export interface MessageRepliedEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"message_replied\";\n\t  event_ts: string;\n\t  hidden: true;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  ts: string;\n\t  message: AnyMessageItem & {\n\t    // TODO: should this be the union of all message events with type 'message'?\n", "    thread_ts: string;\n\t    reply_count: number;\n\t    replies: AnyMessageEvent[]; // TODO: should this be the union of all message events with type 'message'?\n\t  };\n\t}\n\t// the `reply_broadcast` message subtype is omitted because it is discontinued\n\texport interface ThreadBroadcastMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"thread_broadcast\";\n\t  event_ts: string;\n", "  text: string;\n\t  attachments?: MessageAttachment[];\n\t  blocks?: AnyMessageBlock[];\n\t  user: string;\n\t  ts: string;\n\t  thread_ts?: string;\n\t  root: (GenericMessageEvent | BotMessageEvent) & {\n\t    thread_ts: string;\n\t    reply_count: number;\n\t    reply_users_count: number;\n", "    latest_reply: string;\n\t    reply_users: string[];\n\t  };\n\t  client_msg_id: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t}\n\texport interface MessageMetadataPostedEvent\n\t  extends SlackEvent<\"message_metadata_posted\"> {\n\t  type: \"message_metadata_posted\";\n", "  app_id: string;\n\t  bot_id?: string;\n\t  user_id: string;\n\t  team_id: string;\n\t  channel_id: string;\n\t  metadata: MessageMetadata;\n\t  message_ts: string;\n\t  event_ts: string;\n\t}\n\texport interface MessageMetadataUpdatedEvent\n", "  extends SlackEvent<\"message_metadata_updated\"> {\n\t  type: \"message_metadata_updated\";\n\t  channel_id: string;\n\t  event_ts: string;\n\t  previous_metadata: MessageMetadata;\n\t  app_id: string;\n\t  bot_id?: string;\n\t  user_id: string;\n\t  team_id: string;\n\t  message_ts: string;\n", "  metadata: MessageMetadata;\n\t}\n\texport interface MessageMetadataDeletedEvent\n\t  extends SlackEvent<\"message_metadata_deleted\"> {\n\t  type: \"message_metadata_deleted\";\n\t  channel_id: string;\n\t  event_ts: string;\n\t  previous_metadata: MessageMetadata;\n\t  app_id: string;\n\t  bot_id?: string;\n", "  user_id: string;\n\t  team_id: string;\n\t  message_ts: string;\n\t  deleted_ts: string;\n\t}\n\texport type AnyChannelType = \"channel\" | \"group\" | \"im\" | \"mpim\" | \"app_home\";\n\t// -----------------------------------------------------------\n\texport interface BotProfile {\n\t  id: string;\n\t  name: string;\n", "  app_id: string;\n\t  team_id: string;\n\t  icons: { [size: string]: string };\n\t  updated: number;\n\t  deleted: boolean;\n\t}\n\texport interface PinnedItem {\n\t  type: string;\n\t  channel: string;\n\t  created_by: string;\n", "  created: number;\n\t  message?: MessageItem;\n\t  file?: FileItem;\n\t}\n\texport interface SharedChannelTeamItem {\n\t  id: string;\n\t  name: string;\n\t  icon: Record<string, unknown>;\n\t  is_verified: boolean;\n\t  domain: string;\n", "  date_created: number;\n\t}\n\texport interface SharedChannelUserItem {\n\t  id: string;\n\t  team_id: string;\n\t  name: string;\n\t  updated: number;\n\t  profile: {\n\t    real_name: string;\n\t    display_name: string;\n", "    real_name_normalized: string;\n\t    display_name_normalized: string;\n\t    team: string;\n\t    avatar_hash: string;\n\t    email: string;\n\t    image_24: string;\n\t    image_32: string;\n\t    image_48: string;\n\t    image_72: string;\n\t    image_192: string;\n", "    image_512: string;\n\t  };\n\t}\n\texport interface SharedChannelInviteItem {\n\t  id: string;\n\t  date_created: number;\n\t  date_invalid: number;\n\t  inviting_team: SharedChannelTeamItem;\n\t  inviting_user: SharedChannelUserItem;\n\t  recipient_email?: string;\n", "  recipient_user_id?: string;\n\t}\n\texport interface SharedChannelItem {\n\t  id: string;\n\t  is_private: boolean;\n\t  is_im: boolean;\n\t  name: string;\n\t}\n\texport interface Subteam {\n\t  id: string;\n", "  team_id?: string;\n\t  is_usergroup: boolean;\n\t  is_subteam: boolean;\n\t  name: string;\n\t  description?: string;\n\t  handle: string;\n\t  is_external: boolean;\n\t  date_create: number;\n\t  date_update?: number;\n\t  date_delete?: number;\n", "  auto_provision: boolean;\n\t  enterprise_subteam_id?: string;\n\t  created_by: string;\n\t  updated_by?: string;\n\t  prefs?: {\n\t    channels?: string[];\n\t    groups?: string[];\n\t  };\n\t  users: string[];\n\t  user_count: number;\n", "  channel_count?: number;\n\t}\n\texport interface StatusEmojiDisplayInfo {\n\t  emoji_name?: string;\n\t  display_alias?: string;\n\t  display_url?: string;\n\t}\n\texport interface ReactionMessageItem {\n\t  type: \"message\";\n\t  channel: string;\n", "  ts: string;\n\t}\n\texport interface FileInitialComment {\n\t  channel?: string;\n\t  comment?: string;\n\t  created?: number;\n\t  id?: string;\n\t  is_intro?: boolean;\n\t  timestamp?: number;\n\t  user?: string;\n", "}\n\texport interface StarItem {\n\t  date_create: number;\n\t  type: string;\n\t  channel?: string;\n\t  file?: FileItem;\n\t  message?: MessageItem;\n\t  comment?: {\n\t    channel?: string;\n\t    comment?: string;\n", "    created?: number;\n\t    id?: string;\n\t    is_intro?: boolean;\n\t    is_starred?: boolean;\n\t    num_stars?: number;\n\t    timestamp?: number;\n\t    user?: string;\n\t  };\n\t}\n\texport interface FileItem {\n", "  alt_txt?: string;\n\t  app_id?: string;\n\t  app_name?: string;\n\t  bot_id?: string;\n\t  cc?: EmailAddress[];\n\t  channel_actions_count?: number;\n\t  channel_actions_ts?: string;\n\t  channels?: string[];\n\t  comments_count?: number;\n\t  converted_pdf?: string;\n", "  created: number;\n\t  deanimate?: string;\n\t  deanimate_gif?: string;\n\t  display_as_bot?: boolean;\n\t  duration_ms?: number;\n\t  edit_link?: string;\n\t  editable?: boolean;\n\t  editor?: string;\n\t  external_id?: string;\n\t  external_type?: string;\n", "  external_url?: string;\n\t  file_access?: string;\n\t  filetype: string;\n\t  from?: EmailAddress[];\n\t  groups?: string[];\n\t  has_more?: boolean;\n\t  has_more_shares?: boolean;\n\t  has_rich_preview?: boolean;\n\t  headers?: EmailHeaders;\n\t  hls?: string;\n", "  hls_embed?: string;\n\t  id?: string;\n\t  image_exif_rotation?: number;\n\t  ims?: string[];\n\t  initial_comment?: FileInitialComment;\n\t  is_external?: boolean;\n\t  is_public?: boolean;\n\t  is_starred?: boolean;\n\t  last_editor?: string;\n\t  lines?: number;\n", "  lines_more?: number;\n\t  media_display_type?: string;\n\t  media_progress?: SlackVideoMediaProgress;\n\t  mimetype?: string;\n\t  mode?: string;\n\t  mp4?: string;\n\t  name: string;\n\t  non_owner_editable?: boolean;\n\t  num_stars?: number;\n\t  original_attachment_count?: number;\n", "  original_h?: string;\n\t  original_w?: string;\n\t  permalink: string;\n\t  permalink_public?: string;\n\t  pinned_to?: string[];\n\t  pjpeg?: string;\n\t  plain_text?: string;\n\t  pretty_type?: string;\n\t  preview?: string;\n\t  preview_highlight?: string;\n", "  preview_is_truncated?: boolean;\n\t  preview_plain_text?: string;\n\t  public_url_shared?: boolean;\n\t  reactions?: Reaction[];\n\t  sent_to_self?: boolean;\n\t  shares?: FileShares;\n\t  simplified_html?: string;\n\t  size?: number;\n\t  source_team?: string;\n\t  subject?: string;\n", "  subtype?: string;\n\t  thumb_1024?: string;\n\t  thumb_1024_gif?: string;\n\t  thumb_1024_h?: string;\n\t  thumb_1024_w?: string;\n\t  thumb_160?: string;\n\t  thumb_160_gif?: string;\n\t  thumb_160_h?: string;\n\t  thumb_160_w?: string;\n\t  thumb_360?: string;\n", "  thumb_360_gif?: string;\n\t  thumb_360_h?: string;\n\t  thumb_360_w?: string;\n\t  thumb_480?: string;\n\t  thumb_480_gif?: string;\n\t  thumb_480_h?: string;\n\t  thumb_480_w?: string;\n\t  thumb_64?: string;\n\t  thumb_64_gif?: string;\n\t  thumb_64_h?: string;\n", "  thumb_64_w?: string;\n\t  thumb_720?: string;\n\t  thumb_720_gif?: string;\n\t  thumb_720_h?: string;\n\t  thumb_720_w?: string;\n\t  thumb_80?: string;\n\t  thumb_800?: string;\n\t  thumb_800_gif?: string;\n\t  thumb_800_h?: string;\n\t  thumb_800_w?: string;\n", "  thumb_80_gif?: string;\n\t  thumb_80_h?: string;\n\t  thumb_80_w?: string;\n\t  thumb_960?: string;\n\t  thumb_960_gif?: string;\n\t  thumb_960_h?: string;\n\t  thumb_960_w?: string;\n\t  thumb_gif?: string;\n\t  thumb_pdf?: string;\n\t  thumb_pdf_h?: string;\n", "  thumb_pdf_w?: string;\n\t  thumb_tiny?: string;\n\t  thumb_video?: string;\n\t  thumb_video_h?: number;\n\t  thumb_video_w?: number;\n\t  timestamp?: number;\n\t  title?: string;\n\t  to?: EmailAddress[];\n\t  transcription?: FileTranscription;\n\t  updated?: number;\n", "  url_private: string;\n\t  url_private_download: string;\n\t  user: string;\n\t  user_team: string;\n\t  username: string;\n\t  vtt?: string;\n\t}\n\texport interface EmailAddress {\n\t  address: string;\n\t  name: string;\n", "  original: string;\n\t}\n\texport interface EmailHeaders {\n\t  date: string;\n\t  in_reply_to: string;\n\t  message_id: string;\n\t  reply_to: string;\n\t}\n\texport interface SlackVideoMediaProgress {\n\t  duration_ms: number;\n", "  max_offset_ms: number;\n\t  offset_ms: number;\n\t}\n\texport interface Reaction {\n\t  count: number;\n\t  name: string;\n\t  url: string;\n\t  users: string[];\n\t}\n\texport interface FileShares {\n", "  private?: { [key: string]: ShareDetails[] };\n\t  public?: { [key: string]: ShareDetails[] };\n\t}\n\texport interface ShareDetails {\n\t  share_user_id: string;\n\t  team_id: string;\n\t  channel_name: string;\n\t  ts: string;\n\t  latest_reply?: string;\n\t  reply_count?: number;\n", "  reply_users?: string[];\n\t  reply_users_count?: number;\n\t  thread_ts?: string;\n\t}\n\texport interface FileTranscription {\n\t  locale: string;\n\t  status: string;\n\t}\n\texport interface MessageItem {\n\t  attachments?: MessageAttachment[];\n", "  blocks?: AnyMessageBlock[];\n\t  bot_id?: string;\n\t  bot_profile?: BotProfile;\n\t  client_msg_id: string;\n\t  display_as_bot?: boolean;\n\t  edited?: MessageEdited;\n\t  files?: FileElement[];\n\t  inviter?: string;\n\t  is_locked?: boolean;\n\t  is_starred?: boolean;\n", "  last_read?: string;\n\t  latest_reply?: string;\n\t  permalink: string;\n\t  reactions?: Reaction[];\n\t  reply_count?: number;\n\t  reply_users?: string[];\n\t  reply_users_count?: number;\n\t  subscribed?: boolean;\n\t  subtype?: string;\n\t  team: string;\n", "  text: string;\n\t  thread_ts?: string;\n\t  ts: string;\n\t  type: string;\n\t  upload?: boolean;\n\t  user: string;\n\t  username: string;\n\t}\n\texport interface MessageEdited {\n\t  ts: string;\n", "  user: string;\n\t}\n\texport interface FileElement {\n\t  alt_txt?: string;\n\t  app_id?: string;\n\t  app_name?: string;\n\t  bot_id?: string;\n\t  cc?: EmailAddress[];\n\t  channel_actions_count?: number;\n\t  channel_actions_ts?: string;\n", "  channels?: string[];\n\t  comments_count?: number;\n\t  converted_pdf?: string;\n\t  created?: number;\n\t  deanimate?: string;\n\t  deanimate_gif?: string;\n\t  display_as_bot?: boolean;\n\t  duration_ms?: number;\n\t  edit_link?: string;\n\t  editable?: boolean;\n", "  editor?: string;\n\t  external_id?: string;\n\t  external_type?: string;\n\t  external_url?: string;\n\t  file_access?: string;\n\t  filetype?: string;\n\t  from?: EmailAddress[];\n\t  groups?: string[];\n\t  has_more?: boolean;\n\t  has_more_shares?: boolean;\n", "  has_rich_preview?: boolean;\n\t  headers?: Headers;\n\t  hls?: string;\n\t  hls_embed?: string;\n\t  id?: string;\n\t  image_exif_rotation?: number;\n\t  ims?: string[];\n\t  initial_comment?: FileInitialComment;\n\t  is_external: boolean;\n\t  is_public: boolean;\n", "  is_starred?: boolean;\n\t  last_editor?: string;\n\t  lines?: number;\n\t  lines_more?: number;\n\t  media_display_type?: string;\n\t  media_progress?: SlackVideoMediaProgress;\n\t  mimetype: string;\n\t  mode?: string;\n\t  mp4?: string;\n\t  name: string;\n", "  non_owner_editable?: boolean;\n\t  num_stars?: number;\n\t  original_attachment_count?: number;\n\t  original_h?: string;\n\t  original_w?: string;\n\t  permalink: string;\n\t  permalink_public?: string;\n\t  pinned_to?: string[];\n\t  pjpeg?: string;\n\t  plain_text?: string;\n", "  pretty_type?: string;\n\t  preview?: string;\n\t  preview_highlight?: string;\n\t  preview_is_truncated?: boolean;\n\t  preview_plain_text?: string;\n\t  public_url_shared?: boolean;\n\t  reactions?: Reaction[];\n\t  sent_to_self?: boolean;\n\t  shares?: FileShares;\n\t  simplified_html?: string;\n", "  size?: number;\n\t  source_team?: string;\n\t  subject?: string;\n\t  subtype?: string;\n\t  thumb_1024?: string;\n\t  thumb_1024_gif?: string;\n\t  thumb_1024_h?: string;\n\t  thumb_1024_w?: string;\n\t  thumb_160?: string;\n\t  thumb_160_gif?: string;\n", "  thumb_160_h?: string;\n\t  thumb_160_w?: string;\n\t  thumb_360?: string;\n\t  thumb_360_gif?: string;\n\t  thumb_360_h?: string;\n\t  thumb_360_w?: string;\n\t  thumb_480?: string;\n\t  thumb_480_gif?: string;\n\t  thumb_480_h?: string;\n\t  thumb_480_w?: string;\n", "  thumb_64?: string;\n\t  thumb_64_gif?: string;\n\t  thumb_64_h?: string;\n\t  thumb_64_w?: string;\n\t  thumb_720?: string;\n\t  thumb_720_gif?: string;\n\t  thumb_720_h?: string;\n\t  thumb_720_w?: string;\n\t  thumb_80?: string;\n\t  thumb_800?: string;\n", "  thumb_800_gif?: string;\n\t  thumb_800_h?: string;\n\t  thumb_800_w?: string;\n\t  thumb_80_gif?: string;\n\t  thumb_80_h?: string;\n\t  thumb_80_w?: string;\n\t  thumb_960?: string;\n\t  thumb_960_gif?: string;\n\t  thumb_960_h?: string;\n\t  thumb_960_w?: string;\n", "  thumb_gif?: string;\n\t  thumb_pdf?: string;\n\t  thumb_pdf_h?: string;\n\t  thumb_pdf_w?: string;\n\t  thumb_tiny?: string;\n\t  thumb_video?: string;\n\t  thumb_video_h?: number;\n\t  thumb_video_w?: number;\n\t  timestamp: number;\n\t  title: string;\n", "  to?: EmailAddress[];\n\t  transcription?: FileTranscription;\n\t  updated?: number;\n\t  url_private: string;\n\t  url_private_download: string;\n\t  user: string;\n\t  user_team: string;\n\t  username: string;\n\t  vtt?: string;\n\t}\n"]}
{"filename": "src_deno/request/payload/block-action.ts", "chunked_list": ["import {\n\t  AnyOption,\n\t  Confirm,\n\t  PlainTextField,\n\t} from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\timport { DataSubmissionView, ViewStateValue } from \"./view-objects.ts\";\n\texport interface BlockAction<A extends BlockElementAction> {\n\t  type: \"block_actions\";\n\t  actions: A[];\n\t  team: {\n", "    id: string;\n\t    domain: string;\n\t    enterprise_id?: string;\n\t    enterprise_name?: string;\n\t  } | null;\n\t  user: {\n\t    id: string;\n\t    name: string;\n\t    team_id?: string;\n\t  };\n", "  channel?: {\n\t    id: string;\n\t    name: string;\n\t  };\n\t  message?: {\n\t    type: \"message\";\n\t    user?: string;\n\t    ts: string;\n\t    text?: string;\n\t    // deno-lint-ignore no-explicit-any\n", "    [key: string]: any;\n\t  };\n\t  view?: DataSubmissionView;\n\t  state?: {\n\t    values: {\n\t      [blockId: string]: {\n\t        [actionId: string]: ViewStateValue;\n\t      };\n\t    };\n\t  };\n", "  token: string;\n\t  response_url: string;\n\t  trigger_id: string;\n\t  api_app_id: string;\n\t  // deno-lint-ignore no-explicit-any\n\t  container: any;\n\t  // deno-lint-ignore no-explicit-any\n\t  app_unfurl?: any;\n\t  is_enterprise_install?: boolean;\n\t  enterprise?: {\n", "    id: string;\n\t    name: string;\n\t  };\n\t}\n\texport interface BlockElementAction<T extends string = string> {\n\t  type: T;\n\t  block_id: string;\n\t  action_id: string;\n\t  action_ts: string;\n\t}\n", "export interface ButtonAction extends BlockElementAction<\"button\"> {\n\t  value: string;\n\t  text: PlainTextField;\n\t  url?: string;\n\t  confirm?: Confirm;\n\t  accessibility_label?: string;\n\t}\n\texport interface StaticSelectAction\n\t  extends BlockElementAction<\"static_select\"> {\n\t  selected_option: {\n", "    text: PlainTextField;\n\t    value: string;\n\t  };\n\t  initial_option?: AnyOption;\n\t  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n\t}\n\texport interface MultiStaticSelectAction\n\t  extends BlockElementAction<\"multi_static_select\"> {\n\t  selected_options: {\n", "    text: PlainTextField;\n\t    value: string;\n\t  }[];\n\t  initial_options?: AnyOption[];\n\t  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n\t}\n\texport interface UsersSelectAction extends BlockElementAction<\"users_select\"> {\n\t  selected_user: string;\n\t  initial_user?: string;\n", "  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n\t}\n\texport interface MultiUsersSelectAction\n\t  extends BlockElementAction<\"multi_users_select\"> {\n\t  selected_users: string[];\n\t  initial_users?: string[];\n\t  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n\t}\n", "export interface ConversationsSelectAction\n\t  extends BlockElementAction<\"conversations_select\"> {\n\t  selected_conversation: string;\n\t  initial_conversation?: string;\n\t  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n\t}\n\texport interface MultiConversationsSelectAction\n\t  extends BlockElementAction<\"multi_conversations_select\"> {\n\t  selected_conversations: string[];\n", "  initial_conversations?: string[];\n\t  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n\t}\n\texport interface ChannelsSelectAction\n\t  extends BlockElementAction<\"channels_select\"> {\n\t  selected_channel: string;\n\t  initial_channel?: string;\n\t  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n", "}\n\texport interface MultiChannelsSelectAction\n\t  extends BlockElementAction<\"multi_channels_select\"> {\n\t  selected_channels: string[];\n\t  initial_channels?: string[];\n\t  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n\t}\n\texport interface ExternalSelectAction\n\t  extends BlockElementAction<\"external_select\"> {\n", "  selected_option?: AnyOption;\n\t  initial_option?: AnyOption;\n\t  placeholder?: PlainTextField;\n\t  min_query_length?: number;\n\t  confirm?: Confirm;\n\t}\n\texport interface MultiExternalSelectAction\n\t  extends BlockElementAction<\"multi_external_select\"> {\n\t  selected_options?: AnyOption[];\n\t  initial_options?: AnyOption[];\n", "  placeholder?: PlainTextField;\n\t  min_query_length?: number;\n\t  confirm?: Confirm;\n\t}\n\texport interface OverflowAction extends BlockElementAction<\"overflow\"> {\n\t  selected_option: {\n\t    text: PlainTextField;\n\t    value: string;\n\t  };\n\t  confirm?: Confirm;\n", "}\n\texport interface DatepickerAction extends BlockElementAction<\"datepicker\"> {\n\t  selected_date: string | null;\n\t  initial_date?: string;\n\t  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n\t}\n\texport interface RadioButtonsAction\n\t  extends BlockElementAction<\"radio_buttons\"> {\n\t  selected_option: AnyOption | null;\n", "  initial_option?: AnyOption;\n\t  confirm?: Confirm;\n\t}\n\texport interface CheckboxesAction extends BlockElementAction<\"checkboxes\"> {\n\t  selected_options: AnyOption[];\n\t  initial_options?: AnyOption[];\n\t  confirm?: Confirm;\n\t}\n\texport interface PlainTextInputAction\n\t  extends BlockElementAction<\"plain_text_input\"> {\n", "  value: string;\n\t}\n\texport type Actions =\n\t  | ButtonAction\n\t  | StaticSelectAction\n\t  | MultiStaticSelectAction\n\t  | UsersSelectAction\n\t  | MultiUsersSelectAction\n\t  | ConversationsSelectAction\n\t  | MultiConversationsSelectAction\n", "  | ChannelsSelectAction\n\t  | MultiChannelsSelectAction\n\t  | ExternalSelectAction\n\t  | MultiExternalSelectAction\n\t  | OverflowAction\n\t  | DatepickerAction\n\t  | RadioButtonsAction\n\t  | CheckboxesAction\n\t  | PlainTextInputAction;\n\texport type BlockElementTypes = Actions[\"type\"];\n"]}
{"filename": "src_deno/request/payload/message-shortcut.ts", "chunked_list": ["export interface MessageShortcut {\n\t  type: \"message_action\";\n\t  callback_id: string;\n\t  trigger_id: string;\n\t  message_ts: string;\n\t  response_url: string;\n\t  message: {\n\t    type: \"message\";\n\t    user?: string;\n\t    ts: string;\n", "    text?: string;\n\t    // deno-lint-ignore no-explicit-any\n\t    [key: string]: any;\n\t  };\n\t  user: {\n\t    id: string;\n\t    name: string;\n\t    team_id?: string;\n\t    username?: string;\n\t  };\n", "  channel: {\n\t    id: string;\n\t    name: string;\n\t  };\n\t  team: {\n\t    id: string;\n\t    domain: string;\n\t    enterprise_id?: string;\n\t    enterprise_name?: string;\n\t  } | null;\n", "  token: string;\n\t  action_ts: string;\n\t  is_enterprise_install?: boolean;\n\t  enterprise?: {\n\t    id: string;\n\t    name: string;\n\t  };\n\t}\n"]}
{"filename": "src_deno/middleware/built-in-middleware.ts", "chunked_list": ["import { Middleware, PreAuthorizeMiddleware } from \"./middleware.ts\";\n\t// deno-lint-ignore require-await\n\texport const urlVerification: PreAuthorizeMiddleware = async (req) => {\n\t  if (req.body.type === \"url_verification\") {\n\t    return { status: 200, body: req.body.challenge };\n\t  }\n\t};\n\tconst eventTypesToKeep = [\"member_joined_channel\", \"member_left_channel\"];\n\t// deno-lint-ignore require-await\n\texport const ignoringSelfEvents: Middleware = async (req) => {\n", "  if (req.body.event) {\n\t    if (eventTypesToKeep.includes(req.body.event.type)) {\n\t      return;\n\t    }\n\t    if (\n\t      req.context.authorizeResult.botId === req.body.event.bot_id ||\n\t      req.context.authorizeResult.botUserId === req.context.userId\n\t    ) {\n\t      return { status: 200, body: \"\" };\n\t    }\n", "  }\n\t};\n"]}
{"filename": "src_deno/middleware/middleware.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env.ts\";\n\timport {\n\t  PreAuthorizeSlackMiddlwareRequest,\n\t  SlackMiddlwareRequest,\n\t} from \"../request/request.ts\";\n\timport { SlackResponse } from \"../response/response.ts\";\n\texport type PreAuthorizeMiddleware<E extends SlackAppEnv = SlackAppEnv> = (\n\t  req: PreAuthorizeSlackMiddlwareRequest<E>,\n\t) => Promise<SlackResponse | void>;\n\texport type Middleware<E extends SlackAppEnv = SlackAppEnv> = (\n", "  req: SlackMiddlwareRequest<E>,\n\t) => Promise<SlackResponse | void>;\n"]}
{"filename": "src_deno/oauth/callback.ts", "chunked_list": ["import { InvalidStateParameter, OAuthErrorCode } from \"./error-codes.ts\";\n\timport { Installation } from \"./installation.ts\";\n\timport { renderErrorPage } from \"./oauth-page-renderer.ts\";\n\texport type BeforeInstallation = (\n\t  req: Request,\n\t) => Promise<Response | undefined | void>;\n\texport type AfterInstallation = (\n\t  installation: Installation,\n\t  req: Request,\n\t) => Promise<Response | undefined | void>;\n", "export type OnStateValidationError = (\n\t  startPath: string,\n\t  req: Request,\n\t) => Promise<Response>;\n\t// deno-lint-ignore require-await\n\texport const defaultOnStateValidationError = async (\n\t  startPath: string,\n\t  // deno-lint-ignore no-unused-vars\n\t  req: Request,\n\t) => {\n", "  return new Response(renderErrorPage(startPath, InvalidStateParameter), {\n\t    status: 400,\n\t    headers: { \"Content-Type\": \"text/html; charset=utf-8\" },\n\t  });\n\t};\n\texport type OnFailure = (\n\t  startPath: string,\n\t  reason: OAuthErrorCode,\n\t  req: Request,\n\t) => Promise<Response>;\n", "// deno-lint-ignore require-await\n\texport const defaultOnFailure = async (\n\t  startPath: string,\n\t  reason: OAuthErrorCode,\n\t  // deno-lint-ignore no-unused-vars\n\t  req: Request,\n\t) => {\n\t  return new Response(renderErrorPage(startPath, reason), {\n\t    status: 400,\n\t    headers: { \"Content-Type\": \"text/html; charset=utf-8\" },\n", "  });\n\t};\n"]}
{"filename": "src_deno/oauth/installation.ts", "chunked_list": ["import { OAuthV2AccessResponse } from \"https://deno.land/x/slack_web_api_client@0.3.1/mod.ts\";\n\texport interface Installation {\n\t  app_id: string;\n\t  is_enterprise_install?: boolean;\n\t  enterprise_id?: string; // only for Enterprise Grid installations\n\t  team_id?: string; // can be absent when is_enterprise_install is true\n\t  user_id: string;\n\t  // bot token\n\t  bot_token?: string;\n\t  bot_user_id?: string;\n", "  bot_scopes?: string[];\n\t  bot_refresh_token?: string; // token rotation\n\t  bot_token_expires_at?: number; // token rotation (epoch time seconds)\n\t  // user token\n\t  user_token?: string;\n\t  user_scopes?: string[];\n\t  user_refresh_token?: string; // token rotation\n\t  user_token_expires_at?: number; // token rotation (epoch time seconds)\n\t  // Only when having incoming-webhooks\n\t  incoming_webhook_url?: string;\n", "  incoming_webhook_channel_id?: string;\n\t  incoming_webhook_configuration_url?: string;\n\t}\n\texport function toInstallation(\n\t  oauthAccess: OAuthV2AccessResponse,\n\t): Installation {\n\t  const installation: Installation = {\n\t    app_id: oauthAccess.app_id!,\n\t    is_enterprise_install: oauthAccess.is_enterprise_install,\n\t    enterprise_id: oauthAccess.enterprise?.id,\n", "    team_id: oauthAccess.team?.id,\n\t    user_id: oauthAccess.authed_user?.id!,\n\t    // bot token\n\t    bot_token: oauthAccess.access_token,\n\t    bot_user_id: oauthAccess.bot_user_id,\n\t    bot_scopes: oauthAccess.scope?.split(\",\"),\n\t    bot_refresh_token: oauthAccess.refresh_token,\n\t    bot_token_expires_at: oauthAccess.expires_in\n\t      ? new Date().getTime() / 1000 + oauthAccess.expires_in\n\t      : undefined,\n", "    // user token\n\t    user_token: oauthAccess.authed_user?.access_token,\n\t    user_scopes: oauthAccess.authed_user?.scope?.split(\",\"),\n\t    user_refresh_token: oauthAccess.authed_user?.refresh_token,\n\t    user_token_expires_at: oauthAccess.authed_user?.expires_in\n\t      ? new Date().getTime() / 1000 + oauthAccess.authed_user?.expires_in\n\t      : undefined,\n\t    // Only when having incoming-webhooks\n\t    incoming_webhook_url: oauthAccess.incoming_webhook?.url,\n\t    incoming_webhook_channel_id: oauthAccess.incoming_webhook?.channel_id,\n", "    incoming_webhook_configuration_url: oauthAccess.incoming_webhook?.url,\n\t  };\n\t  return installation;\n\t}\n"]}
{"filename": "src_deno/oauth/authorize-url-generator.ts", "chunked_list": ["import { SlackOAuthEnv } from \"../app-env.ts\";\n\texport function generateAuthorizeUrl<E extends SlackOAuthEnv>(\n\t  state: string,\n\t  env: E,\n\t  team: string | undefined = undefined,\n\t): string {\n\t  let url = `https://slack.com/oauth/v2/authorize?state=${state}`;\n\t  url += `&client_id=${env.SLACK_CLIENT_ID}`;\n\t  url += `&scope=${env.SLACK_BOT_SCOPES}`;\n\t  if (env.SLACK_USER_SCOPES) {\n", "    url += `&user_scope=${env.SLACK_USER_SCOPES}`;\n\t  }\n\t  if (env.SLACK_REDIRECT_URI) {\n\t    url += `&redirect_uri=${env.SLACK_REDIRECT_URI}`;\n\t  }\n\t  if (team) {\n\t    url += `&team=${team}`;\n\t  }\n\t  return url;\n\t}\n"]}
{"filename": "src_deno/oauth/error-codes.ts", "chunked_list": ["export interface OAuthErrorCode {\n\t  code: string;\n\t  message: string;\n\t}\n\texport const InvalidStateParameter: OAuthErrorCode = {\n\t  code: \"invalid-state\",\n\t  message: \"The state parameter is missing or invalid\",\n\t};\n\texport const MissingCode: OAuthErrorCode = {\n\t  code: \"missing-code\",\n", "  message: \"The code parameter is missing\",\n\t};\n\texport const InstallationError: OAuthErrorCode = {\n\t  code: \"installation-error\",\n\t  message: \"The installation process failed\",\n\t};\n\texport const InstallationStoreError: OAuthErrorCode = {\n\t  code: \"installation-store-error\",\n\t  message: \"Saving the installation data failed\",\n\t};\n", "export const CompletionPageError: OAuthErrorCode = {\n\t  code: \"completion-page-failure\",\n\t  message: \"Rendering the completion page failed\",\n\t};\n\texport const OpenIDConnectError: OAuthErrorCode = {\n\t  code: \"oidc-error\",\n\t  message: \"The OpenID Connect process failed\",\n\t};\n"]}
{"filename": "src_deno/oauth/oauth-page-renderer.ts", "chunked_list": ["import { OAuthErrorCode } from \"./error-codes.ts\";\n\timport { escapeHtml } from \"./escape-html.ts\";\n\texport function renderStartPage(url: string) {\n\t  return (\n\t    '<html><head><meta http-equiv=\"refresh\" content=\"2;url=' +\n\t    escapeHtml(url) +\n\t    '\" /><title>Redirecting to Slack ...</title></head><body>Redirecting to the Slack OAuth page ... Click <a href=\"' +\n\t    escapeHtml(url) +\n\t    '\">here</a> to continue.</body></html>'\n\t  );\n", "}\n\texport function renderErrorPage(installPath: string, reason: OAuthErrorCode) {\n\t  return (\n\t    '<html><head><style>body {{ padding: 10px 15px; font-family: verdana; text-align: center; }}</style></head><body><h2>Oops, Something Went Wrong!</h2><p>Please try again from <a href=\"' +\n\t    escapeHtml(installPath) +\n\t    '\">here</a> or contact the app owner (reason: ' +\n\t    escapeHtml(reason.message) +\n\t    \")</p></body></html>\"\n\t  );\n\t}\n", "export function renderCompletionPage(\n\t  appId: string,\n\t  teamId: string,\n\t  isEnterpriseInstall: boolean | undefined,\n\t  enterpriseUrl: string | undefined,\n\t) {\n\t  let url = `slack://app?team=${teamId}&id=${appId}`;\n\t  if (isEnterpriseInstall && enterpriseUrl !== undefined) {\n\t    url =\n\t      `${enterpriseUrl}manage/organization/apps/profile/${appId}/workspaces/add\"`;\n", "  }\n\t  const browserUrl = `https://app.slack.com/client/${teamId}`;\n\t  return (\n\t    '<html><head><meta http-equiv=\"refresh\" content=\"0; URL=' +\n\t    escapeHtml(url) +\n\t    '\"><style>body {{ padding: 10px 15px; font-family: verdana; text-align: center; }}</style></head><body><h2>Thank you!</h2><p>Redirecting to the Slack App... click <a href=\"' +\n\t    escapeHtml(url) +\n\t    '\">here</a>. If you use the browser version of Slack, click <a href=\"' +\n\t    escapeHtml(browserUrl) +\n\t    '\" target=\"_blank\">this link</a> instead.</p></body></html>'\n", "  );\n\t}\n"]}
{"filename": "src_deno/oauth/state-store.ts", "chunked_list": ["export interface StateStore {\n\t  issueNewState(): Promise<string>;\n\t  consume(state: string): Promise<boolean>;\n\t}\n\texport class NoStorageStateStore implements StateStore {\n\t  // deno-lint-ignore require-await\n\t  async issueNewState(): Promise<string> {\n\t    return crypto.randomUUID();\n\t  }\n\t  // deno-lint-ignore require-await no-unused-vars\n", "  async consume(state: string): Promise<boolean> {\n\t    return true;\n\t  }\n\t}\n"]}
{"filename": "src_deno/oauth/installation-store.ts", "chunked_list": ["import { SlackOAuthEnv } from \"../app-env.ts\";\n\timport { Authorize } from \"../authorization/authorize.ts\";\n\timport { Installation } from \"./installation.ts\";\n\texport interface InstallationStoreQuery {\n\t  enterpriseId?: string;\n\t  teamId?: string;\n\t  userId?: string;\n\t  isEnterpriseInstall?: boolean;\n\t}\n\texport interface InstallationStore<E extends SlackOAuthEnv> {\n", "  save(installation: Installation, request: Request | undefined): Promise<void>;\n\t  findBotInstallation(\n\t    query: InstallationStoreQuery,\n\t  ): Promise<Installation | undefined>;\n\t  findUserInstallation(\n\t    query: InstallationStoreQuery,\n\t  ): Promise<Installation | undefined>;\n\t  toAuthorize(): Authorize<E>;\n\t}\n"]}
{"filename": "src_deno/oauth/escape-html.ts", "chunked_list": ["export function escapeHtml(input: string | undefined | null): string {\n\t  if (input) {\n\t    return input\n\t      .replace(/&/g, \"&amp;\")\n\t      .replace(/</g, \"&lt;\")\n\t      .replace(/>/g, \"&gt;\")\n\t      .replace(/\"/g, \"&quot;\")\n\t      .replace(/'/g, \"&#x27;\");\n\t  }\n\t  return \"\";\n", "}\n"]}
{"filename": "src/oauth-app.ts", "chunked_list": ["import { ExecutionContext, NoopExecutionContext } from \"./execution-context\";\n\timport { SlackApp } from \"./app\";\n\timport { SlackOAuthEnv } from \"./app-env\";\n\timport { InstallationStore } from \"./oauth/installation-store\";\n\timport { NoStorageStateStore, StateStore } from \"./oauth/state-store\";\n\timport {\n\t  renderCompletionPage,\n\t  renderStartPage,\n\t} from \"./oauth/oauth-page-renderer\";\n\timport { generateAuthorizeUrl } from \"./oauth/authorize-url-generator\";\n", "import { parse as parseCookie } from \"./cookie\";\n\timport {\n\t  SlackAPIClient,\n\t  OAuthV2AccessResponse,\n\t  OpenIDConnectTokenResponse,\n\t} from \"slack-web-api-client\";\n\timport { toInstallation } from \"./oauth/installation\";\n\timport {\n\t  AfterInstallation,\n\t  BeforeInstallation,\n", "  OnFailure,\n\t  OnStateValidationError,\n\t  defaultOnFailure,\n\t  defaultOnStateValidationError,\n\t} from \"./oauth/callback\";\n\timport {\n\t  OpenIDConnectCallback,\n\t  defaultOpenIDConnectCallback,\n\t} from \"./oidc/callback\";\n\timport { generateOIDCAuthorizeUrl } from \"./oidc/authorize-url-generator\";\n", "import {\n\t  InstallationError,\n\t  MissingCode,\n\t  CompletionPageError,\n\t  InstallationStoreError,\n\t  OpenIDConnectError,\n\t} from \"./oauth/error-codes\";\n\texport interface SlackOAuthAppOptions<E extends SlackOAuthEnv> {\n\t  env: E;\n\t  installationStore: InstallationStore<E>;\n", "  stateStore?: StateStore;\n\t  oauth?: {\n\t    stateCookieName?: string;\n\t    beforeInstallation?: BeforeInstallation;\n\t    afterInstallation?: AfterInstallation;\n\t    onFailure?: OnFailure;\n\t    onStateValidationError?: OnStateValidationError;\n\t    redirectUri?: string;\n\t  };\n\t  oidc?: {\n", "    stateCookieName?: string;\n\t    callback: OpenIDConnectCallback;\n\t    onFailure?: OnFailure;\n\t    onStateValidationError?: OnStateValidationError;\n\t    redirectUri?: string;\n\t  };\n\t  routes?: {\n\t    events: string;\n\t    oauth: { start: string; callback: string };\n\t    oidc?: { start: string; callback: string };\n", "  };\n\t}\n\texport class SlackOAuthApp<E extends SlackOAuthEnv> extends SlackApp<E> {\n\t  public env: E;\n\t  public installationStore: InstallationStore<E>;\n\t  public stateStore: StateStore;\n\t  public oauth: {\n\t    stateCookieName?: string;\n\t    beforeInstallation?: BeforeInstallation;\n\t    afterInstallation?: AfterInstallation;\n", "    onFailure: OnFailure;\n\t    onStateValidationError: OnStateValidationError;\n\t    redirectUri?: string;\n\t  };\n\t  public oidc?: {\n\t    stateCookieName?: string;\n\t    callback: OpenIDConnectCallback;\n\t    onFailure: OnFailure;\n\t    onStateValidationError: OnStateValidationError;\n\t    redirectUri?: string;\n", "  };\n\t  public routes: {\n\t    events: string;\n\t    oauth: { start: string; callback: string };\n\t    oidc?: { start: string; callback: string };\n\t  };\n\t  constructor(options: SlackOAuthAppOptions<E>) {\n\t    super({\n\t      env: options.env,\n\t      authorize: options.installationStore.toAuthorize(),\n", "      routes: { events: options.routes?.events ?? \"/slack/events\" },\n\t    });\n\t    this.env = options.env;\n\t    this.installationStore = options.installationStore;\n\t    this.stateStore = options.stateStore ?? new NoStorageStateStore();\n\t    this.oauth = {\n\t      stateCookieName:\n\t        options.oauth?.stateCookieName ?? \"slack-app-oauth-state\",\n\t      onFailure: options.oauth?.onFailure ?? defaultOnFailure,\n\t      onStateValidationError:\n", "        options.oauth?.onStateValidationError ?? defaultOnStateValidationError,\n\t      redirectUri: options.oauth?.redirectUri ?? this.env.SLACK_REDIRECT_URI,\n\t    };\n\t    if (options.oidc) {\n\t      this.oidc = {\n\t        stateCookieName: options.oidc.stateCookieName ?? \"slack-app-oidc-state\",\n\t        onFailure: options.oidc.onFailure ?? defaultOnFailure,\n\t        onStateValidationError:\n\t          options.oidc.onStateValidationError ?? defaultOnStateValidationError,\n\t        callback: defaultOpenIDConnectCallback(this.env),\n", "        redirectUri:\n\t          options.oidc.redirectUri ?? this.env.SLACK_OIDC_REDIRECT_URI,\n\t      };\n\t    } else {\n\t      this.oidc = undefined;\n\t    }\n\t    this.routes = options.routes\n\t      ? options.routes\n\t      : {\n\t          events: \"/slack/events\",\n", "          oauth: {\n\t            start: \"/slack/install\",\n\t            callback: \"/slack/oauth_redirect\",\n\t          },\n\t          oidc: {\n\t            start: \"/slack/login\",\n\t            callback: \"/slack/login/callback\",\n\t          },\n\t        };\n\t  }\n", "  async run(\n\t    request: Request,\n\t    ctx: ExecutionContext = new NoopExecutionContext()\n\t  ): Promise<Response> {\n\t    const url = new URL(request.url);\n\t    if (request.method === \"GET\") {\n\t      if (url.pathname === this.routes.oauth.start) {\n\t        return await this.handleOAuthStartRequest(request);\n\t      } else if (url.pathname === this.routes.oauth.callback) {\n\t        return await this.handleOAuthCallbackRequest(request);\n", "      }\n\t      if (this.routes.oidc) {\n\t        if (url.pathname === this.routes.oidc.start) {\n\t          return await this.handleOIDCStartRequest(request);\n\t        } else if (url.pathname === this.routes.oidc.callback) {\n\t          return await this.handleOIDCCallbackRequest(request);\n\t        }\n\t      }\n\t    } else if (request.method === \"POST\") {\n\t      if (url.pathname === this.routes.events) {\n", "        return await this.handleEventRequest(request, ctx);\n\t      }\n\t    }\n\t    return new Response(\"Not found\", { status: 404 });\n\t  }\n\t  async handleEventRequest(\n\t    request: Request,\n\t    ctx: ExecutionContext\n\t  ): Promise<Response> {\n\t    return await super.handleEventRequest(request, ctx);\n", "  }\n\t  // deno-lint-ignore no-unused-vars\n\t  async handleOAuthStartRequest(request: Request): Promise<Response> {\n\t    const stateValue = await this.stateStore.issueNewState();\n\t    const authorizeUrl = generateAuthorizeUrl(stateValue, this.env);\n\t    return new Response(renderStartPage(authorizeUrl), {\n\t      status: 302,\n\t      headers: {\n\t        Location: authorizeUrl,\n\t        \"Set-Cookie\": `${this.oauth.stateCookieName}=${stateValue}; Secure; HttpOnly; Path=/; Max-Age=300`,\n", "        \"Content-Type\": \"text/html; charset=utf-8\",\n\t      },\n\t    });\n\t  }\n\t  async handleOAuthCallbackRequest(request: Request): Promise<Response> {\n\t    // State parameter validation\n\t    await this.#validateStateParameter(\n\t      request,\n\t      this.routes.oauth.start,\n\t      this.oauth.stateCookieName!\n", "    );\n\t    const { searchParams } = new URL(request.url);\n\t    const code = searchParams.get(\"code\");\n\t    if (!code) {\n\t      return await this.oauth.onFailure(\n\t        this.routes.oauth.start,\n\t        MissingCode,\n\t        request\n\t      );\n\t    }\n", "    const client = new SlackAPIClient(undefined, {\n\t      logLevel: this.env.SLACK_LOGGING_LEVEL,\n\t    });\n\t    let oauthAccess: OAuthV2AccessResponse | undefined;\n\t    try {\n\t      // Execute the installation process\n\t      oauthAccess = await client.oauth.v2.access({\n\t        client_id: this.env.SLACK_CLIENT_ID,\n\t        client_secret: this.env.SLACK_CLIENT_SECRET,\n\t        redirect_uri: this.oauth.redirectUri,\n", "        code,\n\t      });\n\t    } catch (e) {\n\t      console.log(e);\n\t      return await this.oauth.onFailure(\n\t        this.routes.oauth.start,\n\t        InstallationError,\n\t        request\n\t      );\n\t    }\n", "    try {\n\t      // Store the installation data on this app side\n\t      await this.installationStore.save(toInstallation(oauthAccess), request);\n\t    } catch (e) {\n\t      console.log(e);\n\t      return await this.oauth.onFailure(\n\t        this.routes.oauth.start,\n\t        InstallationStoreError,\n\t        request\n\t      );\n", "    }\n\t    try {\n\t      // Build the completion page\n\t      const authTest = await client.auth.test({\n\t        token: oauthAccess.access_token,\n\t      });\n\t      const enterpriseUrl = authTest.url;\n\t      return new Response(\n\t        renderCompletionPage(\n\t          oauthAccess.app_id!,\n", "          oauthAccess.team?.id!,\n\t          oauthAccess.is_enterprise_install,\n\t          enterpriseUrl\n\t        ),\n\t        {\n\t          status: 200,\n\t          headers: {\n\t            \"Set-Cookie\": `${this.oauth.stateCookieName}=deleted; Secure; HttpOnly; Path=/; Max-Age=0`,\n\t            \"Content-Type\": \"text/html; charset=utf-8\",\n\t          },\n", "        }\n\t      );\n\t    } catch (e) {\n\t      console.log(e);\n\t      return await this.oauth.onFailure(\n\t        this.routes.oauth.start,\n\t        CompletionPageError,\n\t        request\n\t      );\n\t    }\n", "  }\n\t  // deno-lint-ignore no-unused-vars\n\t  async handleOIDCStartRequest(request: Request): Promise<Response> {\n\t    if (!this.oidc) {\n\t      return new Response(\"Not found\", { status: 404 });\n\t    }\n\t    const stateValue = await this.stateStore.issueNewState();\n\t    const authorizeUrl = generateOIDCAuthorizeUrl(stateValue, this.env);\n\t    return new Response(renderStartPage(authorizeUrl), {\n\t      status: 302,\n", "      headers: {\n\t        Location: authorizeUrl,\n\t        \"Set-Cookie\": `${this.oidc.stateCookieName}=${stateValue}; Secure; HttpOnly; Path=/; Max-Age=300`,\n\t        \"Content-Type\": \"text/html; charset=utf-8\",\n\t      },\n\t    });\n\t  }\n\t  async handleOIDCCallbackRequest(request: Request): Promise<Response> {\n\t    if (!this.oidc || !this.routes.oidc) {\n\t      return new Response(\"Not found\", { status: 404 });\n", "    }\n\t    // State parameter validation\n\t    await this.#validateStateParameter(\n\t      request,\n\t      this.routes.oidc.start,\n\t      this.oidc.stateCookieName!\n\t    );\n\t    const { searchParams } = new URL(request.url);\n\t    const code = searchParams.get(\"code\");\n\t    if (!code) {\n", "      return await this.oidc.onFailure(\n\t        this.routes.oidc.start,\n\t        MissingCode,\n\t        request\n\t      );\n\t    }\n\t    try {\n\t      const client = new SlackAPIClient(undefined, {\n\t        logLevel: this.env.SLACK_LOGGING_LEVEL,\n\t      });\n", "      const apiResponse: OpenIDConnectTokenResponse =\n\t        await client.openid.connect.token({\n\t          client_id: this.env.SLACK_CLIENT_ID,\n\t          client_secret: this.env.SLACK_CLIENT_SECRET,\n\t          redirect_uri: this.oidc.redirectUri,\n\t          code,\n\t        });\n\t      return await this.oidc.callback(apiResponse, request);\n\t    } catch (e) {\n\t      console.log(e);\n", "      return await this.oidc.onFailure(\n\t        this.routes.oidc.start,\n\t        OpenIDConnectError,\n\t        request\n\t      );\n\t    }\n\t  }\n\t  async #validateStateParameter(\n\t    request: Request,\n\t    startPath: string,\n", "    cookieName: string\n\t  ) {\n\t    const { searchParams } = new URL(request.url);\n\t    const queryState = searchParams.get(\"state\");\n\t    const cookie = parseCookie(request.headers.get(\"Cookie\") || \"\");\n\t    const cookieState = cookie[cookieName];\n\t    if (\n\t      queryState !== cookieState ||\n\t      !(await this.stateStore.consume(queryState))\n\t    ) {\n", "      if (startPath === this.routes.oauth.start) {\n\t        return await this.oauth.onStateValidationError(startPath, request);\n\t      } else if (\n\t        this.oidc &&\n\t        this.routes.oidc &&\n\t        startPath === this.routes.oidc.start\n\t      ) {\n\t        return await this.oidc.onStateValidationError(startPath, request);\n\t      }\n\t    }\n", "  }\n\t}\n"]}
{"filename": "src/app.ts", "chunked_list": ["import { SlackAppEnv, SlackEdgeAppEnv, SlackSocketModeAppEnv } from \"./app-env\";\n\timport { parseRequestBody } from \"./request/request-parser\";\n\timport { verifySlackRequest } from \"./request/request-verification\";\n\timport { AckResponse, SlackHandler } from \"./handler/handler\";\n\timport { SlackRequestBody } from \"./request/request-body\";\n\timport {\n\t  PreAuthorizeSlackMiddlwareRequest,\n\t  SlackRequestWithRespond,\n\t  SlackMiddlwareRequest,\n\t  SlackRequestWithOptionalRespond,\n", "  SlackRequest,\n\t  SlackRequestWithChannelId,\n\t} from \"./request/request\";\n\timport { SlashCommand } from \"./request/payload/slash-command\";\n\timport { toCompleteResponse } from \"./response/response\";\n\timport {\n\t  SlackEvent,\n\t  AnySlackEvent,\n\t  AnySlackEventWithChannelId,\n\t} from \"./request/payload/event\";\n", "import { ResponseUrlSender, SlackAPIClient } from \"slack-web-api-client\";\n\timport {\n\t  builtBaseContext,\n\t  SlackAppContext,\n\t  SlackAppContextWithChannelId,\n\t  SlackAppContextWithRespond,\n\t} from \"./context/context\";\n\timport { PreAuthorizeMiddleware, Middleware } from \"./middleware/middleware\";\n\timport { isDebugLogEnabled, prettyPrint } from \"slack-web-api-client\";\n\timport { Authorize } from \"./authorization/authorize\";\n", "import { AuthorizeResult } from \"./authorization/authorize-result\";\n\timport {\n\t  ignoringSelfEvents,\n\t  urlVerification,\n\t} from \"./middleware/built-in-middleware\";\n\timport { ConfigError } from \"./errors\";\n\timport { GlobalShortcut } from \"./request/payload/global-shortcut\";\n\timport { MessageShortcut } from \"./request/payload/message-shortcut\";\n\timport {\n\t  BlockAction,\n", "  BlockElementAction,\n\t  BlockElementTypes,\n\t} from \"./request/payload/block-action\";\n\timport { ViewSubmission } from \"./request/payload/view-submission\";\n\timport { ViewClosed } from \"./request/payload/view-closed\";\n\timport { BlockSuggestion } from \"./request/payload/block-suggestion\";\n\timport {\n\t  OptionsAckResponse,\n\t  SlackOptionsHandler,\n\t} from \"./handler/options-handler\";\n", "import { SlackViewHandler, ViewAckResponse } from \"./handler/view-handler\";\n\timport {\n\t  MessageAckResponse,\n\t  SlackMessageHandler,\n\t} from \"./handler/message-handler\";\n\timport { singleTeamAuthorize } from \"./authorization/single-team-authorize\";\n\timport { ExecutionContext, NoopExecutionContext } from \"./execution-context\";\n\timport { PayloadType } from \"./request/payload-types\";\n\timport { isPostedMessageEvent } from \"./utility/message-events\";\n\timport { SocketModeClient } from \"./socket-mode/socket-mode-client\";\n", "export interface SlackAppOptions<\n\t  E extends SlackEdgeAppEnv | SlackSocketModeAppEnv\n\t> {\n\t  env: E;\n\t  authorize?: Authorize<E>;\n\t  routes?: {\n\t    events: string;\n\t  };\n\t  socketMode?: boolean;\n\t}\n", "export class SlackApp<E extends SlackEdgeAppEnv | SlackSocketModeAppEnv> {\n\t  public env: E;\n\t  public client: SlackAPIClient;\n\t  public authorize: Authorize<E>;\n\t  public routes: { events: string | undefined };\n\t  public signingSecret: string;\n\t  public appLevelToken: string | undefined;\n\t  public socketMode: boolean;\n\t  public socketModeClient: SocketModeClient | undefined;\n\t  // deno-lint-ignore no-explicit-any\n", "  public preAuthorizeMiddleware: PreAuthorizeMiddleware<any>[] = [\n\t    urlVerification,\n\t  ];\n\t  // deno-lint-ignore no-explicit-any\n\t  public postAuthorizeMiddleware: Middleware<any>[] = [ignoringSelfEvents];\n\t  #slashCommands: ((\n\t    body: SlackRequestBody\n\t  ) => SlackMessageHandler<E, SlashCommand> | null)[] = [];\n\t  #events: ((\n\t    body: SlackRequestBody\n", "  ) => SlackHandler<E, SlackEvent<string>> | null)[] = [];\n\t  #globalShorcuts: ((\n\t    body: SlackRequestBody\n\t  ) => SlackHandler<E, GlobalShortcut> | null)[] = [];\n\t  #messageShorcuts: ((\n\t    body: SlackRequestBody\n\t  ) => SlackHandler<E, MessageShortcut> | null)[] = [];\n\t  #blockActions: ((body: SlackRequestBody) => SlackHandler<\n\t    E,\n\t    // deno-lint-ignore no-explicit-any\n", "    BlockAction<any>\n\t  > | null)[] = [];\n\t  #blockSuggestions: ((\n\t    body: SlackRequestBody\n\t  ) => SlackOptionsHandler<E, BlockSuggestion> | null)[] = [];\n\t  #viewSubmissions: ((\n\t    body: SlackRequestBody\n\t  ) => SlackViewHandler<E, ViewSubmission> | null)[] = [];\n\t  #viewClosed: ((\n\t    body: SlackRequestBody\n", "  ) => SlackViewHandler<E, ViewClosed> | null)[] = [];\n\t  constructor(options: SlackAppOptions<E>) {\n\t    if (\n\t      options.env.SLACK_BOT_TOKEN === undefined &&\n\t      (options.authorize === undefined ||\n\t        options.authorize === singleTeamAuthorize)\n\t    ) {\n\t      throw new ConfigError(\n\t        \"When you don't pass env.SLACK_BOT_TOKEN, your own authorize function, which supplies a valid token to use, needs to be passed instead.\"\n\t      );\n", "    }\n\t    this.env = options.env;\n\t    this.client = new SlackAPIClient(options.env.SLACK_BOT_TOKEN, {\n\t      logLevel: this.env.SLACK_LOGGING_LEVEL,\n\t    });\n\t    this.appLevelToken = options.env.SLACK_APP_TOKEN;\n\t    this.socketMode = options.socketMode ?? this.appLevelToken !== undefined;\n\t    if (this.socketMode) {\n\t      this.signingSecret = \"\";\n\t    } else {\n", "      if (!this.env.SLACK_SIGNING_SECRET) {\n\t        throw new ConfigError(\n\t          \"env.SLACK_SIGNING_SECRET is required to run your app on edge functions!\"\n\t        );\n\t      }\n\t      this.signingSecret = this.env.SLACK_SIGNING_SECRET;\n\t    }\n\t    this.authorize = options.authorize ?? singleTeamAuthorize;\n\t    this.routes = { events: options.routes?.events };\n\t  }\n", "  beforeAuthorize(middleware: PreAuthorizeMiddleware<E>): SlackApp<E> {\n\t    this.preAuthorizeMiddleware.push(middleware);\n\t    return this;\n\t  }\n\t  middleware(middleware: Middleware<E>): SlackApp<E> {\n\t    return this.afterAuthorize(middleware);\n\t  }\n\t  use(middleware: Middleware<E>): SlackApp<E> {\n\t    return this.afterAuthorize(middleware);\n\t  }\n", "  afterAuthorize(middleware: Middleware<E>): SlackApp<E> {\n\t    this.postAuthorizeMiddleware.push(middleware);\n\t    return this;\n\t  }\n\t  command(\n\t    pattern: StringOrRegExp,\n\t    ack: (\n\t      req: SlackRequestWithRespond<E, SlashCommand>\n\t    ) => Promise<MessageAckResponse>,\n\t    lazy: (\n", "      req: SlackRequestWithRespond<E, SlashCommand>\n\t    ) => Promise<void> = noopLazyListener\n\t  ): SlackApp<E> {\n\t    const handler: SlackMessageHandler<E, SlashCommand> = { ack, lazy };\n\t    this.#slashCommands.push((body) => {\n\t      if (body.type || !body.command) {\n\t        return null;\n\t      }\n\t      if (typeof pattern === \"string\" && body.command === pattern) {\n\t        return handler;\n", "      } else if (\n\t        typeof pattern === \"object\" &&\n\t        pattern instanceof RegExp &&\n\t        body.command.match(pattern)\n\t      ) {\n\t        return handler;\n\t      }\n\t      return null;\n\t    });\n\t    return this;\n", "  }\n\t  event<Type extends string>(\n\t    event: Type,\n\t    lazy: (req: EventRequest<E, Type>) => Promise<void>\n\t  ): SlackApp<E> {\n\t    this.#events.push((body) => {\n\t      if (body.type !== PayloadType.EventsAPI || !body.event) {\n\t        return null;\n\t      }\n\t      if (body.event.type === event) {\n", "        // deno-lint-ignore require-await\n\t        return { ack: async () => \"\", lazy };\n\t      }\n\t      return null;\n\t    });\n\t    return this;\n\t  }\n\t  anyMessage(lazy: MessageEventHandler<E>): SlackApp<E> {\n\t    return this.message(undefined, lazy);\n\t  }\n", "  message(\n\t    pattern: MessageEventPattern,\n\t    lazy: MessageEventHandler<E>\n\t  ): SlackApp<E> {\n\t    this.#events.push((body) => {\n\t      if (\n\t        body.type !== PayloadType.EventsAPI ||\n\t        !body.event ||\n\t        body.event.type !== \"message\"\n\t      ) {\n", "        return null;\n\t      }\n\t      if (isPostedMessageEvent(body.event)) {\n\t        let matched = true;\n\t        if (pattern !== undefined) {\n\t          if (typeof pattern === \"string\") {\n\t            matched = body.event.text!.includes(pattern);\n\t          }\n\t          if (typeof pattern === \"object\") {\n\t            matched = body.event.text!.match(pattern) !== null;\n", "          }\n\t        }\n\t        if (matched) {\n\t          // deno-lint-ignore require-await\n\t          return { ack: async (_: EventRequest<E, \"message\">) => \"\", lazy };\n\t        }\n\t      }\n\t      return null;\n\t    });\n\t    return this;\n", "  }\n\t  shortcut(\n\t    callbackId: StringOrRegExp,\n\t    ack: (\n\t      req:\n\t        | SlackRequest<E, GlobalShortcut>\n\t        | SlackRequestWithRespond<E, MessageShortcut>\n\t    ) => Promise<AckResponse>,\n\t    lazy: (\n\t      req:\n", "        | SlackRequest<E, GlobalShortcut>\n\t        | SlackRequestWithRespond<E, MessageShortcut>\n\t    ) => Promise<void> = noopLazyListener\n\t  ): SlackApp<E> {\n\t    return this.globalShortcut(callbackId, ack, lazy).messageShortcut(\n\t      callbackId,\n\t      ack,\n\t      lazy\n\t    );\n\t  }\n", "  globalShortcut(\n\t    callbackId: StringOrRegExp,\n\t    ack: (req: SlackRequest<E, GlobalShortcut>) => Promise<AckResponse>,\n\t    lazy: (\n\t      req: SlackRequest<E, GlobalShortcut>\n\t    ) => Promise<void> = noopLazyListener\n\t  ): SlackApp<E> {\n\t    const handler: SlackHandler<E, GlobalShortcut> = { ack, lazy };\n\t    this.#globalShorcuts.push((body) => {\n\t      if (body.type !== PayloadType.GlobalShortcut || !body.callback_id) {\n", "        return null;\n\t      }\n\t      if (typeof callbackId === \"string\" && body.callback_id === callbackId) {\n\t        return handler;\n\t      } else if (\n\t        typeof callbackId === \"object\" &&\n\t        callbackId instanceof RegExp &&\n\t        body.callback_id.match(callbackId)\n\t      ) {\n\t        return handler;\n", "      }\n\t      return null;\n\t    });\n\t    return this;\n\t  }\n\t  messageShortcut(\n\t    callbackId: StringOrRegExp,\n\t    ack: (\n\t      req: SlackRequestWithRespond<E, MessageShortcut>\n\t    ) => Promise<AckResponse>,\n", "    lazy: (\n\t      req: SlackRequestWithRespond<E, MessageShortcut>\n\t    ) => Promise<void> = noopLazyListener\n\t  ): SlackApp<E> {\n\t    const handler: SlackHandler<E, MessageShortcut> = { ack, lazy };\n\t    this.#messageShorcuts.push((body) => {\n\t      if (body.type !== PayloadType.MessageShortcut || !body.callback_id) {\n\t        return null;\n\t      }\n\t      if (typeof callbackId === \"string\" && body.callback_id === callbackId) {\n", "        return handler;\n\t      } else if (\n\t        typeof callbackId === \"object\" &&\n\t        callbackId instanceof RegExp &&\n\t        body.callback_id.match(callbackId)\n\t      ) {\n\t        return handler;\n\t      }\n\t      return null;\n\t    });\n", "    return this;\n\t  }\n\t  action<\n\t    T extends BlockElementTypes,\n\t    A extends BlockAction<BlockElementAction<T>> = BlockAction<\n\t      BlockElementAction<T>\n\t    >\n\t  >(\n\t    constraints:\n\t      | StringOrRegExp\n", "      | { type: T; block_id?: string; action_id: string },\n\t    ack: (req: SlackRequestWithOptionalRespond<E, A>) => Promise<AckResponse>,\n\t    lazy: (\n\t      req: SlackRequestWithOptionalRespond<E, A>\n\t    ) => Promise<void> = noopLazyListener\n\t  ): SlackApp<E> {\n\t    const handler: SlackHandler<E, A> = { ack, lazy };\n\t    this.#blockActions.push((body) => {\n\t      if (\n\t        body.type !== PayloadType.BlockAction ||\n", "        !body.actions ||\n\t        !body.actions[0]\n\t      ) {\n\t        return null;\n\t      }\n\t      const action = body.actions[0];\n\t      if (typeof constraints === \"string\" && action.action_id === constraints) {\n\t        return handler;\n\t      } else if (typeof constraints === \"object\") {\n\t        if (constraints instanceof RegExp) {\n", "          if (action.action_id.match(constraints)) {\n\t            return handler;\n\t          }\n\t        } else if (constraints.type) {\n\t          if (action.type === constraints.type) {\n\t            if (action.action_id === constraints.action_id) {\n\t              if (\n\t                constraints.block_id &&\n\t                action.block_id !== constraints.block_id\n\t              ) {\n", "                return null;\n\t              }\n\t              return handler;\n\t            }\n\t          }\n\t        }\n\t      }\n\t      return null;\n\t    });\n\t    return this;\n", "  }\n\t  options(\n\t    constraints: StringOrRegExp | { block_id?: string; action_id: string },\n\t    ack: (req: SlackRequest<E, BlockSuggestion>) => Promise<OptionsAckResponse>\n\t  ): SlackApp<E> {\n\t    // Note that block_suggestion response must be done within 3 seconds.\n\t    // So, we don't support the lazy handler for it.\n\t    const handler: SlackOptionsHandler<E, BlockSuggestion> = { ack };\n\t    this.#blockSuggestions.push((body) => {\n\t      if (body.type !== PayloadType.BlockSuggestion || !body.action_id) {\n", "        return null;\n\t      }\n\t      if (typeof constraints === \"string\" && body.action_id === constraints) {\n\t        return handler;\n\t      } else if (typeof constraints === \"object\") {\n\t        if (constraints instanceof RegExp) {\n\t          if (body.action_id.match(constraints)) {\n\t            return handler;\n\t          }\n\t        } else {\n", "          if (body.action_id === constraints.action_id) {\n\t            if (body.block_id && body.block_id !== constraints.block_id) {\n\t              return null;\n\t            }\n\t            return handler;\n\t          }\n\t        }\n\t      }\n\t      return null;\n\t    });\n", "    return this;\n\t  }\n\t  view(\n\t    callbackId: StringOrRegExp,\n\t    ack: (\n\t      req:\n\t        | SlackRequestWithOptionalRespond<E, ViewSubmission>\n\t        | SlackRequest<E, ViewClosed>\n\t    ) => Promise<ViewAckResponse>,\n\t    lazy: (\n", "      req:\n\t        | SlackRequestWithOptionalRespond<E, ViewSubmission>\n\t        | SlackRequest<E, ViewClosed>\n\t    ) => Promise<void> = noopLazyListener\n\t  ): SlackApp<E> {\n\t    return this.viewSubmission(callbackId, ack, lazy).viewClosed(\n\t      callbackId,\n\t      ack,\n\t      lazy\n\t    );\n", "  }\n\t  viewSubmission(\n\t    callbackId: StringOrRegExp,\n\t    ack: (\n\t      req: SlackRequestWithOptionalRespond<E, ViewSubmission>\n\t    ) => Promise<ViewAckResponse>,\n\t    lazy: (\n\t      req: SlackRequestWithOptionalRespond<E, ViewSubmission>\n\t    ) => Promise<void> = noopLazyListener\n\t  ): SlackApp<E> {\n", "    const handler: SlackViewHandler<E, ViewSubmission> = { ack, lazy };\n\t    this.#viewSubmissions.push((body) => {\n\t      if (body.type !== PayloadType.ViewSubmission || !body.view) {\n\t        return null;\n\t      }\n\t      if (\n\t        typeof callbackId === \"string\" &&\n\t        body.view.callback_id === callbackId\n\t      ) {\n\t        return handler;\n", "      } else if (\n\t        typeof callbackId === \"object\" &&\n\t        callbackId instanceof RegExp &&\n\t        body.view.callback_id.match(callbackId)\n\t      ) {\n\t        return handler;\n\t      }\n\t      return null;\n\t    });\n\t    return this;\n", "  }\n\t  viewClosed(\n\t    callbackId: StringOrRegExp,\n\t    ack: (req: SlackRequest<E, ViewClosed>) => Promise<ViewAckResponse>,\n\t    lazy: (req: SlackRequest<E, ViewClosed>) => Promise<void> = noopLazyListener\n\t  ): SlackApp<E> {\n\t    const handler: SlackViewHandler<E, ViewClosed> = { ack, lazy };\n\t    this.#viewClosed.push((body) => {\n\t      if (body.type !== PayloadType.ViewClosed || !body.view) {\n\t        return null;\n", "      }\n\t      if (\n\t        typeof callbackId === \"string\" &&\n\t        body.view.callback_id === callbackId\n\t      ) {\n\t        return handler;\n\t      } else if (\n\t        typeof callbackId === \"object\" &&\n\t        callbackId instanceof RegExp &&\n\t        body.view.callback_id.match(callbackId)\n", "      ) {\n\t        return handler;\n\t      }\n\t      return null;\n\t    });\n\t    return this;\n\t  }\n\t  async run(\n\t    request: Request,\n\t    ctx: ExecutionContext = new NoopExecutionContext()\n", "  ): Promise<Response> {\n\t    return await this.handleEventRequest(request, ctx);\n\t  }\n\t  async connect(): Promise<void> {\n\t    if (!this.socketMode) {\n\t      throw new ConfigError(\n\t        \"Both env.SLACK_APP_TOKEN and socketMode: true are required to start a Socket Mode connection!\"\n\t      );\n\t    }\n\t    this.socketModeClient = new SocketModeClient(this);\n", "    await this.socketModeClient.connect();\n\t  }\n\t  async disconnect(): Promise<void> {\n\t    if (this.socketModeClient) {\n\t      await this.socketModeClient.disconnect();\n\t    }\n\t  }\n\t  async handleEventRequest(\n\t    request: Request,\n\t    ctx: ExecutionContext\n", "  ): Promise<Response> {\n\t    // If the routes.events is missing, any URLs can work for handing requests from Slack\n\t    if (this.routes.events) {\n\t      const { pathname } = new URL(request.url);\n\t      if (pathname !== this.routes.events) {\n\t        return new Response(\"Not found\", { status: 404 });\n\t      }\n\t    }\n\t    // To avoid the following warning by Cloudflware, parse the body as Blob first\n\t    // Called .text() on an HTTP body which does not appear to be text ..\n", "    const blobRequestBody = await request.blob();\n\t    // We can safely assume the incoming request body is always text data\n\t    const rawBody: string = await blobRequestBody.text();\n\t    // For Request URL verification\n\t    if (rawBody.includes(\"ssl_check=\")) {\n\t      // Slack does not send the x-slack-signature header for this pattern.\n\t      // Thus, we need to check the pattern before verifying a request.\n\t      const bodyParams = new URLSearchParams(rawBody);\n\t      if (bodyParams.get(\"ssl_check\") === \"1\" && bodyParams.get(\"token\")) {\n\t        return new Response(\"\", { status: 200 });\n", "      }\n\t    }\n\t    // Verify the request headers and body\n\t    const isRequestSignatureVerified =\n\t      this.socketMode ||\n\t      (await verifySlackRequest(this.signingSecret, request.headers, rawBody));\n\t    if (isRequestSignatureVerified) {\n\t      // deno-lint-ignore no-explicit-any\n\t      const body: Record<string, any> = await parseRequestBody(\n\t        request.headers,\n", "        rawBody\n\t      );\n\t      let retryNum: number | undefined = undefined;\n\t      try {\n\t        const retryNumHeader = request.headers.get(\"x-slack-retry-num\");\n\t        if (retryNumHeader) {\n\t          retryNum = Number.parseInt(retryNumHeader);\n\t        } else if (this.socketMode && body.retry_attempt) {\n\t          retryNum = Number.parseInt(body.retry_attempt);\n\t        }\n", "        // deno-lint-ignore no-unused-vars\n\t      } catch (e) {\n\t        // Ignore an exception here\n\t      }\n\t      const retryReason =\n\t        request.headers.get(\"x-slack-retry-reason\") ?? body.retry_reason;\n\t      const preAuthorizeRequest: PreAuthorizeSlackMiddlwareRequest<E> = {\n\t        body,\n\t        rawBody,\n\t        retryNum,\n", "        retryReason,\n\t        context: builtBaseContext(body),\n\t        env: this.env,\n\t        headers: request.headers,\n\t      };\n\t      if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n\t        console.log(`*** Received request body ***\\n ${prettyPrint(body)}`);\n\t      }\n\t      for (const middlware of this.preAuthorizeMiddleware) {\n\t        const response = await middlware(preAuthorizeRequest);\n", "        if (response) {\n\t          return toCompleteResponse(response);\n\t        }\n\t      }\n\t      const authorizeResult: AuthorizeResult = await this.authorize(\n\t        preAuthorizeRequest\n\t      );\n\t      const authorizedContext: SlackAppContext = {\n\t        ...preAuthorizeRequest.context,\n\t        authorizeResult,\n", "        client: new SlackAPIClient(authorizeResult.botToken, {\n\t          logLevel: this.env.SLACK_LOGGING_LEVEL,\n\t        }),\n\t        botToken: authorizeResult.botToken,\n\t        botId: authorizeResult.botId,\n\t        botUserId: authorizeResult.botUserId,\n\t        userToken: authorizeResult.userToken,\n\t      };\n\t      if (authorizedContext.channelId) {\n\t        const context = authorizedContext as SlackAppContextWithChannelId;\n", "        const client = new SlackAPIClient(context.botToken);\n\t        context.say = async (params) =>\n\t          await client.chat.postMessage({\n\t            channel: context.channelId,\n\t            ...params,\n\t          });\n\t      }\n\t      if (authorizedContext.responseUrl) {\n\t        const responseUrl = authorizedContext.responseUrl;\n\t        // deno-lint-ignore require-await\n", "        (authorizedContext as SlackAppContextWithRespond).respond = async (\n\t          params\n\t        ) => {\n\t          return new ResponseUrlSender(responseUrl).call(params);\n\t        };\n\t      }\n\t      const baseRequest: SlackMiddlwareRequest<E> = {\n\t        ...preAuthorizeRequest,\n\t        context: authorizedContext,\n\t      };\n", "      for (const middlware of this.postAuthorizeMiddleware) {\n\t        const response = await middlware(baseRequest);\n\t        if (response) {\n\t          return toCompleteResponse(response);\n\t        }\n\t      }\n\t      const payload = body as SlackRequestBody;\n\t      if (body.type === PayloadType.EventsAPI) {\n\t        // Events API\n\t        const slackRequest: SlackRequest<E, SlackEvent<string>> = {\n", "          payload: body.event,\n\t          ...baseRequest,\n\t        };\n\t        for (const matcher of this.#events) {\n\t          const handler = matcher(payload);\n\t          if (handler) {\n\t            ctx.waitUntil(handler.lazy(slackRequest));\n\t            const slackResponse = await handler.ack(slackRequest);\n\t            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n\t              console.log(\n", "                `*** Slack response ***\\n${prettyPrint(slackResponse)}`\n\t              );\n\t            }\n\t            return toCompleteResponse(slackResponse);\n\t          }\n\t        }\n\t      } else if (!body.type && body.command) {\n\t        // Slash commands\n\t        const slackRequest: SlackRequest<E, SlashCommand> = {\n\t          payload: body as SlashCommand,\n", "          ...baseRequest,\n\t        };\n\t        for (const matcher of this.#slashCommands) {\n\t          const handler = matcher(payload);\n\t          if (handler) {\n\t            ctx.waitUntil(handler.lazy(slackRequest));\n\t            const slackResponse = await handler.ack(slackRequest);\n\t            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n\t              console.log(\n\t                `*** Slack response ***\\n${prettyPrint(slackResponse)}`\n", "              );\n\t            }\n\t            return toCompleteResponse(slackResponse);\n\t          }\n\t        }\n\t      } else if (body.type === PayloadType.GlobalShortcut) {\n\t        // Global shortcuts\n\t        const slackRequest: SlackRequest<E, GlobalShortcut> = {\n\t          payload: body as GlobalShortcut,\n\t          ...baseRequest,\n", "        };\n\t        for (const matcher of this.#globalShorcuts) {\n\t          const handler = matcher(payload);\n\t          if (handler) {\n\t            ctx.waitUntil(handler.lazy(slackRequest));\n\t            const slackResponse = await handler.ack(slackRequest);\n\t            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n\t              console.log(\n\t                `*** Slack response ***\\n${prettyPrint(slackResponse)}`\n\t              );\n", "            }\n\t            return toCompleteResponse(slackResponse);\n\t          }\n\t        }\n\t      } else if (body.type === PayloadType.MessageShortcut) {\n\t        // Message shortcuts\n\t        const slackRequest: SlackRequest<E, MessageShortcut> = {\n\t          payload: body as MessageShortcut,\n\t          ...baseRequest,\n\t        };\n", "        for (const matcher of this.#messageShorcuts) {\n\t          const handler = matcher(payload);\n\t          if (handler) {\n\t            ctx.waitUntil(handler.lazy(slackRequest));\n\t            const slackResponse = await handler.ack(slackRequest);\n\t            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n\t              console.log(\n\t                `*** Slack response ***\\n${prettyPrint(slackResponse)}`\n\t              );\n\t            }\n", "            return toCompleteResponse(slackResponse);\n\t          }\n\t        }\n\t      } else if (body.type === PayloadType.BlockAction) {\n\t        // Block actions\n\t        // deno-lint-ignore no-explicit-any\n\t        const slackRequest: SlackRequest<E, BlockAction<any>> = {\n\t          // deno-lint-ignore no-explicit-any\n\t          payload: body as BlockAction<any>,\n\t          ...baseRequest,\n", "        };\n\t        for (const matcher of this.#blockActions) {\n\t          const handler = matcher(payload);\n\t          if (handler) {\n\t            ctx.waitUntil(handler.lazy(slackRequest));\n\t            const slackResponse = await handler.ack(slackRequest);\n\t            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n\t              console.log(\n\t                `*** Slack response ***\\n${prettyPrint(slackResponse)}`\n\t              );\n", "            }\n\t            return toCompleteResponse(slackResponse);\n\t          }\n\t        }\n\t      } else if (body.type === PayloadType.BlockSuggestion) {\n\t        // Block suggestions\n\t        const slackRequest: SlackRequest<E, BlockSuggestion> = {\n\t          payload: body as BlockSuggestion,\n\t          ...baseRequest,\n\t        };\n", "        for (const matcher of this.#blockSuggestions) {\n\t          const handler = matcher(payload);\n\t          if (handler) {\n\t            // Note that the only way to respond to a block_suggestion request\n\t            // is to send an HTTP response with options/option_groups.\n\t            // Thus, we don't support lazy handlers for this pattern.\n\t            const slackResponse = await handler.ack(slackRequest);\n\t            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n\t              console.log(\n\t                `*** Slack response ***\\n${prettyPrint(slackResponse)}`\n", "              );\n\t            }\n\t            return toCompleteResponse(slackResponse);\n\t          }\n\t        }\n\t      } else if (body.type === PayloadType.ViewSubmission) {\n\t        // View submissions\n\t        const slackRequest: SlackRequest<E, ViewSubmission> = {\n\t          payload: body as ViewSubmission,\n\t          ...baseRequest,\n", "        };\n\t        for (const matcher of this.#viewSubmissions) {\n\t          const handler = matcher(payload);\n\t          if (handler) {\n\t            ctx.waitUntil(handler.lazy(slackRequest));\n\t            const slackResponse = await handler.ack(slackRequest);\n\t            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n\t              console.log(\n\t                `*** Slack response ***\\n${prettyPrint(slackResponse)}`\n\t              );\n", "            }\n\t            return toCompleteResponse(slackResponse);\n\t          }\n\t        }\n\t      } else if (body.type === PayloadType.ViewClosed) {\n\t        // View closed\n\t        const slackRequest: SlackRequest<E, ViewClosed> = {\n\t          payload: body as ViewClosed,\n\t          ...baseRequest,\n\t        };\n", "        for (const matcher of this.#viewClosed) {\n\t          const handler = matcher(payload);\n\t          if (handler) {\n\t            ctx.waitUntil(handler.lazy(slackRequest));\n\t            const slackResponse = await handler.ack(slackRequest);\n\t            if (isDebugLogEnabled(this.env.SLACK_LOGGING_LEVEL)) {\n\t              console.log(\n\t                `*** Slack response ***\\n${prettyPrint(slackResponse)}`\n\t              );\n\t            }\n", "            return toCompleteResponse(slackResponse);\n\t          }\n\t        }\n\t      }\n\t      // TODO: Add code suggestion here\n\t      console.log(\n\t        `*** No listener found ***\\n${JSON.stringify(baseRequest.body)}`\n\t      );\n\t      return new Response(\"No listener found\", { status: 404 });\n\t    }\n", "    return new Response(\"Invalid signature\", { status: 401 });\n\t  }\n\t}\n\texport type StringOrRegExp = string | RegExp;\n\texport type EventRequest<E extends SlackAppEnv, T> = Extract<\n\t  AnySlackEventWithChannelId,\n\t  { type: T }\n\t> extends never\n\t  ? SlackRequest<E, Extract<AnySlackEvent, { type: T }>>\n\t  : SlackRequestWithChannelId<\n", "      E,\n\t      Extract<AnySlackEventWithChannelId, { type: T }>\n\t    >;\n\texport type MessageEventPattern = string | RegExp | undefined;\n\texport type MessageEventRequest<\n\t  E extends SlackAppEnv,\n\t  ST extends string | undefined\n\t> = SlackRequestWithChannelId<\n\t  E,\n\t  Extract<AnySlackEventWithChannelId, { subtype: ST }>\n", ">;\n\texport type MessageEventSubtypes =\n\t  | undefined\n\t  | \"bot_message\"\n\t  | \"thread_broadcast\"\n\t  | \"file_share\";\n\texport type MessageEventHandler<E extends SlackAppEnv> = (\n\t  req: MessageEventRequest<E, MessageEventSubtypes>\n\t) => Promise<void>;\n\texport const noopLazyListener = async () => {};\n"]}
{"filename": "src/execution-context.ts", "chunked_list": ["/**\n\t * An interface representing context parameter in Cloudflare Workers and Vercel Edge Functions.\n\t * Refer to the following resources:\n\t * - https://developers.cloudflare.com/workers/runtime-apis/fetch-event/\n\t * - https://vercel.com/docs/concepts/functions/edge-functions/edge-functions-api#waituntil\n\t */\n\texport interface ExecutionContext {\n\t  // deno-lint-ignore no-explicit-any\n\t  waitUntil(promise: Promise<any>): void;\n\t}\n", "export class NoopExecutionContext implements ExecutionContext {\n\t  // deno-lint-ignore no-explicit-any\n\t  waitUntil(promise: Promise<any>): void {\n\t    promise.catch((reason) => {\n\t      console.error(`Failed to run a lazy listener: ${reason}`);\n\t    });\n\t  }\n\t}\n"]}
{"filename": "src/cookie.ts", "chunked_list": ["/*!\n\t * cookie\n\t * Copyright(c) 2012-2014 Roman Shtylman\n\t * Copyright(c) 2015 Douglas Christopher Wilson\n\t * MIT Licensed\n\t */\n\t/**\n\t * Parse a cookie header.\n\t *\n\t * Parse the given cookie header string into an object\n", " * The object has the various cookies as keys(names) => values\n\t */\n\texport function parse(\n\t  str: string,\n\t  // deno-lint-ignore no-explicit-any\n\t  options: any | undefined = undefined\n\t): Record<string, string> {\n\t  if (typeof str !== \"string\") {\n\t    throw new TypeError(\"argument str must be a string\");\n\t  }\n", "  // deno-lint-ignore no-explicit-any\n\t  const obj: any = {};\n\t  const opt = options || {};\n\t  const dec = opt.decode || decode;\n\t  let index = 0;\n\t  while (index < str.length) {\n\t    const eqIdx = str.indexOf(\"=\", index);\n\t    // no more cookie pairs\n\t    if (eqIdx === -1) {\n\t      break;\n", "    }\n\t    let endIdx = str.indexOf(\";\", index);\n\t    if (endIdx === -1) {\n\t      endIdx = str.length;\n\t    } else if (endIdx < eqIdx) {\n\t      // backtrack on prior semicolon\n\t      index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n\t      continue;\n\t    }\n\t    const key = str.slice(index, eqIdx).trim();\n", "    // only assign once\n\t    if (undefined === obj[key]) {\n\t      let val = str.slice(eqIdx + 1, endIdx).trim();\n\t      // quoted values\n\t      if (val.charCodeAt(0) === 0x22) {\n\t        val = val.slice(1, -1);\n\t      }\n\t      obj[key] = tryDecode(val, dec);\n\t    }\n\t    index = endIdx + 1;\n", "  }\n\t  return obj;\n\t}\n\t/**\n\t * URL-decode string value. Optimized to skip native call when no %.\n\t */\n\tfunction decode(str: string): string {\n\t  return str.indexOf(\"%\") !== -1 ? decodeURIComponent(str) : str;\n\t}\n\t/**\n", " * Try decoding a string using a decoding function.\n\t */\n\tfunction tryDecode(str: string, decode: (val: string) => string) {\n\t  try {\n\t    return decode(str);\n\t    // deno-lint-ignore no-unused-vars\n\t  } catch (e) {\n\t    return str;\n\t  }\n\t}\n"]}
{"filename": "src/errors.ts", "chunked_list": ["export class ConfigError extends Error {\n\t  constructor(message: string) {\n\t    super(message);\n\t    this.name = \"ConfigError\";\n\t  }\n\t}\n\texport class AuthorizeError extends Error {\n\t  constructor(message: string) {\n\t    super(message);\n\t    this.name = \"AuthorizeError\";\n", "  }\n\t}\n\texport class SocketModeError extends Error {\n\t  constructor(message: string) {\n\t    super(message);\n\t    this.name = \"SocketModeError\";\n\t  }\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from \"./app\";\n\texport * from \"./app-env\";\n\texport * from \"./execution-context\";\n\texport * from \"slack-web-api-client\";\n\texport * from \"./errors\";\n\texport * from \"./oauth/error-codes\";\n\texport * from \"./handler/handler\";\n\texport * from \"./handler/message-handler\";\n\texport * from \"./handler/options-handler\";\n\texport * from \"./handler/view-handler\";\n", "export * from \"./authorization/authorize\";\n\texport * from \"./authorization/authorize-result\";\n\texport * from \"./authorization/single-team-authorize\";\n\texport * from \"./middleware/middleware\";\n\texport * from \"./middleware/built-in-middleware\";\n\texport * from \"./context/context\";\n\texport * from \"./oauth-app\";\n\texport * from \"./oauth/authorize-url-generator\";\n\texport * from \"./oauth/callback\";\n\texport * from \"./oauth/escape-html\";\n", "export * from \"./oauth/installation\";\n\texport * from \"./oauth/installation-store\";\n\texport * from \"./oauth/oauth-page-renderer\";\n\texport * from \"./oauth/state-store\";\n\texport * from \"./oidc/authorize-url-generator\";\n\texport * from \"./oidc/callback\";\n\texport * from \"./oidc/login\";\n\texport * from \"./request/request-body\";\n\texport * from \"./request/request-verification\";\n\texport * from \"./request/request\";\n", "export * from \"./request/payload-types\";\n\texport * from \"./request/payload/block-action\";\n\texport * from \"./request/payload/block-suggestion\";\n\texport * from \"./request/payload/event\";\n\texport * from \"./request/payload/global-shortcut\";\n\texport * from \"./request/payload/message-shortcut\";\n\texport * from \"./request/payload/slash-command\";\n\texport * from \"./request/payload/view-submission\";\n\texport * from \"./request/payload/view-closed\";\n\texport * from \"./request/payload/view-objects\";\n", "export * from \"./response/response\";\n\texport * from \"./socket-mode/socket-mode-client\";\n\texport * from \"./utility/message-events\";\n"]}
{"filename": "src/app-env.ts", "chunked_list": ["export interface SlackLoggingLevel {\n\t  SLACK_LOGGING_LEVEL?: \"DEBUG\" | \"INFO\" | \"WARN\" | \"ERROR\";\n\t}\n\texport type SlackAppEnv = SlackLoggingLevel & {\n\t  SLACK_SIGNING_SECRET?: string;\n\t  SLACK_BOT_TOKEN?: string;\n\t  SLACK_APP_TOKEN?: string;\n\t};\n\texport type SlackEdgeAppEnv = SlackAppEnv & {\n\t  SLACK_SIGNING_SECRET: string;\n", "  SLACK_BOT_TOKEN?: string;\n\t};\n\texport type SlackSocketModeAppEnv = SlackAppEnv & {\n\t  SLACK_SIGNING_SECRET?: string;\n\t  SLACK_BOT_TOKEN?: string;\n\t  SLACK_APP_TOKEN: string;\n\t};\n\texport type SlackOAuthEnv = (SlackEdgeAppEnv | SlackSocketModeAppEnv) & {\n\t  SLACK_CLIENT_ID: string;\n\t  SLACK_CLIENT_SECRET: string;\n", "  SLACK_BOT_SCOPES: string;\n\t  SLACK_USER_SCOPES?: string;\n\t  SLACK_REDIRECT_URI?: string;\n\t  SLACK_OIDC_SCOPES?: string;\n\t  SLACK_OIDC_REDIRECT_URI?: string;\n\t  SLACK_USER_TOKEN_RESOLUTION?: \"installer\" | \"actor\";\n\t};\n\texport type SlackOIDCEnv = SlackAppEnv & {\n\t  SLACK_CLIENT_ID: string;\n\t  SLACK_CLIENT_SECRET: string;\n", "  SLACK_OIDC_SCOPES?: string;\n\t  SLACK_OIDC_REDIRECT_URI: string;\n\t};\n\texport type SlackOAuthAndOIDCEnv = SlackOAuthEnv & SlackOIDCEnv;\n"]}
{"filename": "src/oidc/callback.ts", "chunked_list": ["import { SlackLoggingLevel } from \"../app-env\";\n\timport {\n\t  SlackAPIClient,\n\t  OpenIDConnectTokenResponse,\n\t} from \"slack-web-api-client\";\n\timport { prettyPrint } from \"slack-web-api-client\";\n\texport type OpenIDConnectCallback = (\n\t  apiResponse: OpenIDConnectTokenResponse,\n\t  req: Request\n\t) => Promise<Response>;\n", "export function defaultOpenIDConnectCallback(\n\t  env: SlackLoggingLevel\n\t): OpenIDConnectCallback {\n\t  // deno-lint-ignore no-unused-vars\n\t  return async (token, req) => {\n\t    const client = new SlackAPIClient(token.access_token, {\n\t      logLevel: env.SLACK_LOGGING_LEVEL,\n\t    });\n\t    const userInfo = await client.openid.connect.userInfo();\n\t    const body = `<html><head><style>body {{ padding: 10px 15px; font-family: verdana; text-align: center; }}</style></head><body><h1>It works!</h1><p>This is the default handler. To change this, pass \\`oidc: { callback: async (token, req) => new Response(\"TODO\") }\\` to your SlackOAuthApp constructor.</p><pre>${prettyPrint(\n", "      userInfo\n\t    )}</pre></body></html>`;\n\t    return new Response(body, {\n\t      status: 200,\n\t      headers: { \"Content-Type\": \"text/html; charset=utf-8\" },\n\t    });\n\t  };\n\t}\n"]}
{"filename": "src/oidc/login.ts", "chunked_list": ["import {\n\t  OpenIDConnectTokenResponse,\n\t  OpenIDConnectUserInfoResponse,\n\t} from \"slack-web-api-client\";\n\texport interface Login {\n\t  enterprise_id?: string;\n\t  team_id: string;\n\t  user_id: string;\n\t  name?: string;\n\t  email?: string;\n", "  picture?: string;\n\t  access_token: string;\n\t  refresh_token?: string; // token rotation\n\t  token_expires_at?: number; // token rotation (epoch time seconds)\n\t}\n\texport function toLogin(\n\t  token: OpenIDConnectTokenResponse,\n\t  userInfo: OpenIDConnectUserInfoResponse\n\t): Login {\n\t  return {\n", "    enterprise_id: userInfo[\"https://slack.com/enterprise_id\"],\n\t    team_id: userInfo[\"https://slack.com/team_id\"]!,\n\t    user_id: userInfo[\"https://slack.com/user_id\"]!,\n\t    email: userInfo.email,\n\t    picture: userInfo.picture,\n\t    access_token: token.access_token!,\n\t    refresh_token: token.refresh_token,\n\t    token_expires_at: token.expires_in\n\t      ? new Date().getTime() / 1000 + token.expires_in\n\t      : undefined,\n", "  };\n\t}\n"]}
{"filename": "src/oidc/authorize-url-generator.ts", "chunked_list": ["import { SlackOAuthEnv } from \"../app-env\";\n\timport { ConfigError } from \"../errors\";\n\texport function generateOIDCAuthorizeUrl<E extends SlackOAuthEnv>(\n\t  state: string,\n\t  env: E\n\t): string {\n\t  if (!env.SLACK_OIDC_SCOPES) {\n\t    throw new ConfigError(\n\t      \"env.SLACK_OIDC_SCOPES must be present when enabling Sign in with Slack (OpenID Connect)\"\n\t    );\n", "  }\n\t  if (!env.SLACK_OIDC_REDIRECT_URI) {\n\t    throw new ConfigError(\n\t      \"env.SLACK_OIDC_REDIRECT_URI must be present when enabling Sign in with Slack (OpenID Connect)\"\n\t    );\n\t  }\n\t  let url = `https://slack.com/openid/connect/authorize?response_type=code&state=${state}`;\n\t  url += `&client_id=${env.SLACK_CLIENT_ID}`;\n\t  url += `&scope=${env.SLACK_OIDC_SCOPES}`;\n\t  url += `&redirect_uri=${env.SLACK_OIDC_REDIRECT_URI}`;\n", "  return url;\n\t}\n"]}
{"filename": "src/context/context.ts", "chunked_list": ["import { AuthorizeResult } from \"../authorization/authorize-result\";\n\timport {\n\t  SlackAPIClient,\n\t  ChatPostMessageRequest,\n\t  ChatPostMessageResponse,\n\t  WebhookParams,\n\t} from \"slack-web-api-client\";\n\texport interface PreAuthorizeSlackAppContext {\n\t  isEnterpriseinstall?: boolean;\n\t  enterpriseId?: string;\n", "  teamId?: string;\n\t  userId?: string;\n\t  actorEnterpriseId?: string;\n\t  actorTeamId?: string;\n\t  actorUserId?: string;\n\t  botId?: string;\n\t  botUserId?: string;\n\t  responseUrl?: string;\n\t  channelId?: string;\n\t  custom: {\n", "    // deno-lint-ignore no-explicit-any\n\t    [key: string]: any; // custom properties\n\t  };\n\t}\n\texport type SlackAppContext = {\n\t  client: SlackAPIClient;\n\t  botToken: string;\n\t  userToken?: string;\n\t  authorizeResult: AuthorizeResult;\n\t} & PreAuthorizeSlackAppContext;\n", "export type SlackAppContextWithChannelId = {\n\t  channelId: string;\n\t  say: (\n\t    params: Omit<ChatPostMessageRequest, \"channel\">\n\t  ) => Promise<ChatPostMessageResponse>;\n\t} & SlackAppContext;\n\texport type SlackAppContextWithRespond = {\n\t  channelId: string;\n\t  respond: (params: WebhookParams) => Promise<Response>;\n\t} & SlackAppContext;\n", "export type SlackAppContextWithOptionalRespond = {\n\t  respond?: (params: WebhookParams) => Promise<Response>;\n\t} & SlackAppContext;\n\texport function builtBaseContext(\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>\n\t): PreAuthorizeSlackAppContext {\n\t  return {\n\t    isEnterpriseinstall: extractIsEnterpriseInstall(body),\n\t    enterpriseId: extractEnterpriseId(body),\n", "    teamId: extractTeamId(body),\n\t    userId: extractUserId(body),\n\t    actorEnterpriseId: extractActorEnterpriseId(body),\n\t    actorTeamId: extractActorTeamId(body),\n\t    actorUserId: extractActorUserId(body),\n\t    botId: undefined, // will be set later\n\t    botUserId: undefined, // will be set later\n\t    responseUrl: extractResponseUrl(body),\n\t    channelId: extractChannelId(body),\n\t    custom: {},\n", "  };\n\t}\n\texport function extractIsEnterpriseInstall(\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>\n\t): boolean | undefined {\n\t  if (body.authorizations && body.authorizations.length > 0) {\n\t    return body.authorizations[0].is_enterprise_install;\n\t  } else if (body.is_enterprise_install) {\n\t    if (typeof body.is_enterprise_install === \"string\") {\n", "      // slash command payloads\n\t      return body.is_enterprise_install === \"true\";\n\t    }\n\t    return body.is_enterprise_install == true;\n\t  }\n\t  return undefined;\n\t}\n\texport function extractEnterpriseId(\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>\n", "): string | undefined {\n\t  if (body.enterprise) {\n\t    if (typeof body.enterprise === \"string\") {\n\t      return body.enterprise;\n\t    } else if (typeof body.enterprise === \"object\" && body.enterprise.id) {\n\t      return body.enterprise.id;\n\t    }\n\t  } else if (body.authorizations && body.authorizations.length > 0) {\n\t    return extractEnterpriseId(body.authorizations[0]);\n\t  } else if (body.enterprise_id) {\n", "    return body.enterprise_id;\n\t  } else if (\n\t    body.team &&\n\t    typeof body.team === \"object\" &&\n\t    body.team.enterprise_id\n\t  ) {\n\t    return body.team.enterprise_id;\n\t  } else if (body.event) {\n\t    return extractEnterpriseId(body.event);\n\t  }\n", "  return undefined;\n\t}\n\t// deno-lint-ignore no-explicit-any\n\texport function extractTeamId(body: Record<string, any>): string | undefined {\n\t  if (body.view && body.view.app_installed_team_id) {\n\t    // view_submission payloads can have `view.app_installed_team_id`\n\t    // when a modal view that was opened in a different workspace via some operations inside a Slack Connect channel.\n\t    // Note that the same for enterprise_id does not exist. When you need to know the enterprise_id as well,\n\t    // you have to run some query toward your InstallationStore to know the org where the team_id belongs to.\n\t    return body.view.app_installed_team_id;\n", "  } else if (body.team) {\n\t    // With org-wide installations, payload.team in interactivity payloads can be None\n\t    // You need to extract either payload.user.team_id or payload.view.team_id as below\n\t    if (typeof body.team === \"string\") {\n\t      return body.team;\n\t    } else if (body.team.id) {\n\t      return body.team.id;\n\t    }\n\t  } else if (body.authorizations && body.authorizations.length > 0) {\n\t    // To make Events API handling functioning also for shared channels,\n", "    // we should use .authorizations[0].team_id over .team_id\n\t    return extractTeamId(body.authorizations[0]);\n\t  } else if (body.team_id) {\n\t    return body.team_id;\n\t  } else if (body.user && typeof body.user === \"object\") {\n\t    return body.user.team_id;\n\t  } else if (body.view && typeof body.view === \"object\") {\n\t    return body.view.team_id;\n\t  }\n\t  return undefined;\n", "}\n\t// deno-lint-ignore no-explicit-any\n\texport function extractUserId(body: Record<string, any>): string | undefined {\n\t  if (body.user) {\n\t    if (typeof body.user === \"string\") {\n\t      return body.user;\n\t    }\n\t    if (typeof body.user === \"object\" && body.user.id) {\n\t      return body.user.id;\n\t    }\n", "  } else if (body.user_id) {\n\t    return body.user_id;\n\t  } else if (body.event) {\n\t    return extractUserId(body.event);\n\t  } else if (body.message) {\n\t    return extractUserId(body.message);\n\t  } else if (body.previous_message) {\n\t    return extractUserId(body.previous_message);\n\t  }\n\t  return undefined;\n", "}\n\texport function extractActorEnterpriseId(\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>\n\t): string | undefined {\n\t  if (body.is_ext_shared_channel) {\n\t    if (body.type === \"event_callback\") {\n\t      const eventTeamId = body.event?.user_team || body.event?.team;\n\t      if (eventTeamId && eventTeamId.startsWith(\"E\")) {\n\t        return eventTeamId;\n", "      } else if (eventTeamId === body.team_id) {\n\t        return body.enterprise_id;\n\t      }\n\t    }\n\t  }\n\t  return extractEnterpriseId(body);\n\t}\n\texport function extractActorTeamId(\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>\n", "): string | undefined {\n\t  if (body.is_ext_shared_channel) {\n\t    if (body.type === \"event_callback\") {\n\t      const eventType = body.event.type;\n\t      if (eventType === \"app_mention\") {\n\t        // The $.event.user_team can be an enterprise_id in app_mention events.\n\t        // In the scenario, there is no way to retrieve actor_team_id as of March 2023\n\t        const userTeam = body.event.user_team;\n\t        if (!userTeam) {\n\t          // working with an app installed in this user's org/workspace side\n", "          return body.event.team;\n\t        } else if (userTeam.startsWith(\"T\")) {\n\t          // interacting from a connected non-grid workspace\n\t          return userTeam;\n\t        }\n\t        // Interacting from a connected grid workspace; in this case, team_id cannot be resolved as of March 2023\n\t        return undefined;\n\t      }\n\t      const eventUserTeam = body.event.user_team;\n\t      if (eventUserTeam) {\n", "        if (eventUserTeam.startsWith(\"T\")) {\n\t          return eventUserTeam;\n\t        } else if (eventUserTeam.startsWith(\"E\")) {\n\t          if (eventUserTeam === body.enterprise_id) {\n\t            return body.team_id;\n\t          } else if (eventUserTeam === body.context_enterprise_id) {\n\t            return body.context_team_id;\n\t          }\n\t        }\n\t      }\n", "      const eventTeam = body.event.team;\n\t      if (eventTeam) {\n\t        if (eventTeam.startsWith(\"T\")) {\n\t          return eventTeam;\n\t        } else if (eventTeam.startsWith(\"E\")) {\n\t          if (eventTeam === body.enterprise_id) {\n\t            return body.team_id;\n\t          } else if (eventTeam === body.context_enterprise_id) {\n\t            return body.context_team_id;\n\t          }\n", "        }\n\t      }\n\t    }\n\t  }\n\t  return extractTeamId(body);\n\t}\n\texport function extractActorUserId(\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>\n\t): string | undefined {\n", "  if (body.is_ext_shared_channel) {\n\t    if (body.type === \"event_callback\") {\n\t      if (body.event) {\n\t        if (extractActorEnterpriseId(body) && extractActorTeamId(body)) {\n\t          // When both enterprise_id and team_id are not identified, we skip returning user_id too for safety\n\t          return undefined;\n\t        }\n\t        return body.event.user || body.event.user_id;\n\t      } else {\n\t        return undefined;\n", "      }\n\t    }\n\t  }\n\t  return extractUserId(body);\n\t}\n\texport function extractResponseUrl(\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>\n\t): string | undefined {\n\t  if (body.response_url) {\n", "    return body.response_url;\n\t  } else if (body.response_urls && body.response_urls.length > 0) {\n\t    return body.response_urls[0].response_url;\n\t  }\n\t  return undefined;\n\t}\n\texport function extractChannelId(\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>\n\t): string | undefined {\n", "  if (body.channel) {\n\t    if (typeof body.channel === \"string\") {\n\t      return body.channel;\n\t    } else if (typeof body.channel === \"object\" && body.channel.id) {\n\t      return body.channel.id;\n\t    }\n\t  } else if (body.channel_id) {\n\t    return body.channel_id;\n\t  } else if (body.event) {\n\t    return extractChannelId(body.event);\n", "  } else if (body.item) {\n\t    // reaction_added: body[\"event\"][\"item\"]\n\t    return extractChannelId(body.item);\n\t  }\n\t  return undefined;\n\t}\n"]}
{"filename": "src/authorization/single-team-authorize.ts", "chunked_list": ["import { AuthorizeError } from \"../errors\";\n\timport {\n\t  SlackAPIClient,\n\t  AuthTestResponse,\n\t  SlackAPIError,\n\t} from \"slack-web-api-client\";\n\timport { Authorize } from \"./authorize\";\n\texport const singleTeamAuthorize: Authorize = async (req) => {\n\t  // This authorize function supports only the bot token for a workspace\n\t  const botToken = req.env.SLACK_BOT_TOKEN!;\n", "  const client = new SlackAPIClient(botToken);\n\t  try {\n\t    const response: AuthTestResponse = await client.auth.test();\n\t    const scopes = response.headers.get(\"x-oauth-scopes\") ?? \"\";\n\t    return {\n\t      botToken,\n\t      enterpriseId: response.enterprise_id,\n\t      teamId: response.team_id,\n\t      team: response.team,\n\t      url: response.url,\n", "      botId: response.bot_id!,\n\t      botUserId: response.user_id!,\n\t      userId: response.user_id,\n\t      user: response.user,\n\t      botScopes: scopes.split(\",\"),\n\t      userToken: undefined, // As mentioned above, user tokens are not supported in this module\n\t      userScopes: undefined, // As mentioned above, user tokens are not supported in this module\n\t    };\n\t  } catch (e) {\n\t    throw new AuthorizeError(\n", "      `Failed to call auth.test API due to ${(e as SlackAPIError).message}`\n\t    );\n\t  }\n\t};\n"]}
{"filename": "src/authorization/authorize.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env\";\n\timport { PreAuthorizeSlackMiddlwareRequest } from \"../request/request\";\n\timport { AuthorizeResult } from \"./authorize-result\";\n\texport type Authorize<E extends SlackAppEnv = SlackAppEnv> = (\n\t  req: PreAuthorizeSlackMiddlwareRequest<E>\n\t) => Promise<AuthorizeResult>;\n"]}
{"filename": "src/authorization/authorize-result.ts", "chunked_list": ["export interface AuthorizeResult {\n\t  enterpriseId?: string;\n\t  teamId?: string;\n\t  team?: string;\n\t  url?: string;\n\t  botId: string;\n\t  botUserId: string;\n\t  botToken: string;\n\t  botScopes: string[];\n\t  userId?: string;\n", "  user?: string;\n\t  userToken?: string;\n\t  userScopes?: string[];\n\t}\n"]}
{"filename": "src/socket-mode/socket-mode-client.ts", "chunked_list": ["import { SlackAPIClient, isDebugLogEnabled } from \"slack-web-api-client\";\n\timport { SlackApp } from \"../app\";\n\timport { ConfigError, SocketModeError } from \"../errors\";\n\timport { ExecutionContext } from \"../execution-context\";\n\timport { SlackSocketModeAppEnv } from \"../app-env\";\n\t// TODO: Implement proper reconnection logic\n\t// TODO: Add connection monitor like 1st party SDKs do\n\t// TODO: Add Bun support (the runtime does not work well with Socket Mode)\n\texport class SocketModeClient {\n\t  public app: SlackApp<SlackSocketModeAppEnv>;\n", "  public appLevelToken: string;\n\t  public ws: WebSocket | undefined;\n\t  constructor(\n\t    // deno-lint-ignore no-explicit-any\n\t    app: SlackApp<any>\n\t  ) {\n\t    if (!app.socketMode) {\n\t      throw new ConfigError(\n\t        \"socketMode: true must be set for running with Socket Mode\"\n\t      );\n", "    }\n\t    if (!app.appLevelToken) {\n\t      throw new ConfigError(\n\t        \"appLevelToken must be set for running with Socket Mode\"\n\t      );\n\t    }\n\t    this.app = app as SlackApp<SlackSocketModeAppEnv>;\n\t    this.appLevelToken = app.appLevelToken;\n\t    console.warn(\n\t      \"WARNING: The Socket Mode support provided by slack-edge is still experimental and is not designed to handle reconnections for production-grade applications. It is recommended to use this mode only for local development and testing purposes.\"\n", "    );\n\t  }\n\t  async connect() {\n\t    const client = new SlackAPIClient(this.appLevelToken);\n\t    try {\n\t      const newConnection = await client.apps.connections.open();\n\t      this.ws = new WebSocket(newConnection.url!);\n\t    } catch (e) {\n\t      throw new SocketModeError(\n\t        `Failed to establish a new WSS connection: ${e}`\n", "      );\n\t    }\n\t    if (this.ws) {\n\t      const ws = this.ws;\n\t      // deno-lint-ignore require-await\n\t      ws.onopen = async (ev) => {\n\t        // TODO: make this customizable\n\t        if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n\t          console.log(\n\t            `Now the Socket Mode client is connected to Slack: ${JSON.stringify(\n", "              ev\n\t            )}`\n\t          );\n\t        }\n\t      };\n\t      // deno-lint-ignore require-await\n\t      ws.onclose = async (ev) => {\n\t        // TODO: make this customizable\n\t        if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n\t          console.log(\n", "            `The Socket Mode client is disconnected from Slack: ${JSON.stringify(\n\t              ev\n\t            )}`\n\t          );\n\t        }\n\t      };\n\t      // deno-lint-ignore require-await\n\t      ws.onerror = async (e) => {\n\t        // TODO: make this customizable\n\t        console.error(\n", "          `An error was thrown by the Socket Mode connection: ${e}`\n\t        );\n\t      };\n\t      const app = this.app;\n\t      ws.onmessage = async (ev) => {\n\t        try {\n\t          if (\n\t            ev.data &&\n\t            typeof ev.data === \"string\" &&\n\t            ev.data.startsWith(\"{\")\n", "          ) {\n\t            const data = JSON.parse(ev.data);\n\t            if (data.type === \"hello\") {\n\t              if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n\t                console.log(`*** Received hello data ***\\n ${ev.data}`);\n\t              }\n\t              return;\n\t            }\n\t            const payload = JSON.stringify(data.payload);\n\t            console.log(payload);\n", "            const request: Request = new Request(ws.url, {\n\t              method: \"POST\",\n\t              headers: new Headers({ \"content-type\": \"application/json\" }),\n\t              body: new Blob([payload]).stream(),\n\t            });\n\t            const context: ExecutionContext = {\n\t              // deno-lint-ignore require-await\n\t              waitUntil: async (promise) => {\n\t                promise\n\t                  .then((res) => {\n", "                    console.info(`Completed a lazy listener execution: ${res}`);\n\t                  })\n\t                  .catch((err) => {\n\t                    console.error(`Failed to run a lazy listener: ${err}`);\n\t                  });\n\t              },\n\t            };\n\t            const response = await app.run(request, context);\n\t            // deno-lint-ignore no-explicit-any\n\t            let ack: any = { envelope_id: data.envelope_id };\n", "            if (response.body) {\n\t              const contentType = response.headers.get(\"Content-Type\");\n\t              if (contentType && contentType.startsWith(\"text/plain\")) {\n\t                const text = await response.text();\n\t                ack = { envelope_id: data.envelope_id, payload: { text } };\n\t              } else {\n\t                const json = await response.json();\n\t                ack = { envelope_id: data.envelope_id, payload: { ...json } };\n\t              }\n\t            }\n", "            ws.send(JSON.stringify(ack));\n\t          } else {\n\t            if (isDebugLogEnabled(app.env.SLACK_LOGGING_LEVEL)) {\n\t              console.log(`*** Received non-JSON data ***\\n ${ev.data}`);\n\t            }\n\t          }\n\t        } catch (e) {\n\t          console.error(`Failed to handle a WebSocke message: ${e}`);\n\t        }\n\t      };\n", "    }\n\t  }\n\t  // deno-lint-ignore require-await\n\t  async disconnect(): Promise<void> {\n\t    if (this.ws) {\n\t      this.ws.close();\n\t      this.ws = undefined;\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/handler/view-handler.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env\";\n\timport { SlackRequest } from \"../request/request\";\n\timport { SlackViewResponse } from \"../response/response\";\n\texport type ViewAckResponse = SlackViewResponse | void;\n\texport type SlackViewHandler<E extends SlackAppEnv, Payload> = {\n\t  ack(request: SlackRequest<E, Payload>): Promise<ViewAckResponse>;\n\t  lazy(request: SlackRequest<E, Payload>): Promise<void>;\n\t};\n"]}
{"filename": "src/handler/message-handler.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env\";\n\timport { SlackRequest } from \"../request/request\";\n\timport { MessageResponse } from \"../response/response-body\";\n\timport { AckResponse } from \"./handler\";\n\texport type MessageAckResponse = AckResponse | MessageResponse;\n\texport interface SlackMessageHandler<E extends SlackAppEnv, Payload> {\n\t  ack(request: SlackRequest<E, Payload>): Promise<MessageAckResponse>;\n\t  lazy(request: SlackRequest<E, Payload>): Promise<void>;\n\t}\n"]}
{"filename": "src/handler/handler.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env\";\n\timport { SlackRequest } from \"../request/request\";\n\timport { SlackResponse } from \"../response/response\";\n\texport type AckResponse = SlackResponse | string | void;\n\texport interface SlackHandler<E extends SlackAppEnv, Payload> {\n\t  ack(request: SlackRequest<E, Payload>): Promise<AckResponse>;\n\t  lazy(request: SlackRequest<E, Payload>): Promise<void>;\n\t}\n"]}
{"filename": "src/handler/options-handler.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env\";\n\timport { SlackRequest } from \"../request/request\";\n\timport { SlackOptionsResponse } from \"../response/response\";\n\texport type OptionsAckResponse = SlackOptionsResponse;\n\texport interface SlackOptionsHandler<E extends SlackAppEnv, Payload> {\n\t  ack(request: SlackRequest<E, Payload>): Promise<OptionsAckResponse>;\n\t  // Note that a block_suggestion response must be done synchronously.\n\t  // That's why we don't support lazy functions for the pattern.\n\t}\n"]}
{"filename": "src/response/response-body.ts", "chunked_list": ["import {\n\t  AnyMessageBlock,\n\t  MessageAttachment,\n\t  MessageMetadata,\n\t  AnyTextField,\n\t  ModalView,\n\t} from \"slack-web-api-client\";\n\texport interface MessageResponse {\n\t  response_type?: \"ephemeral\" | \"in_channel\";\n\t  text: string;\n", "  blocks?: AnyMessageBlock[];\n\t  attachments?: MessageAttachment[];\n\t  metadata?: MessageMetadata;\n\t  thread_ts?: string;\n\t}\n\texport interface ViewUpdateResponse {\n\t  response_action: \"update\";\n\t  view: ModalView;\n\t}\n\texport interface ViewPushResponse {\n", "  response_action: \"push\";\n\t  view: ModalView;\n\t}\n\texport interface ViewClearResponse {\n\t  response_action: \"clear\";\n\t}\n\texport interface ViewErrorsResponse {\n\t  response_action: \"errors\";\n\t  errors: { [blockId: string]: string };\n\t}\n", "export type AnyViewResponse =\n\t  | ViewUpdateResponse\n\t  | ViewPushResponse\n\t  | ViewClearResponse\n\t  | ViewErrorsResponse;\n\texport interface Option {\n\t  value: string;\n\t  text: AnyTextField;\n\t}\n\texport interface OptionGroup {\n", "  label: AnyTextField;\n\t  options: Option[];\n\t}\n\texport interface OptionsResponse {\n\t  options: Option[];\n\t}\n\texport interface OptionGroupsResponse {\n\t  option_groups: OptionGroup[];\n\t}\n\texport type AnyOptionsResponse = OptionsResponse | OptionGroupsResponse;\n"]}
{"filename": "src/response/response.ts", "chunked_list": ["import {\n\t  MessageResponse,\n\t  AnyOptionsResponse,\n\t  AnyViewResponse,\n\t} from \"./response-body\";\n\texport interface SlackResponse {\n\t  status?: number;\n\t  contentType?: string;\n\t  // deno-lint-ignore no-explicit-any\n\t  body?: string | MessageResponse | Record<string, any>;\n", "}\n\texport type SlackViewResponse =\n\t  | (SlackResponse & {\n\t      body: \"\" | AnyViewResponse;\n\t    })\n\t  | \"\"\n\t  | AnyViewResponse\n\t  | undefined\n\t  | void;\n\texport type SlackOptionsResponse =\n", "  | (SlackResponse & {\n\t      body: AnyOptionsResponse;\n\t    })\n\t  | AnyOptionsResponse;\n\texport function toCompleteResponse(\n\t  slackResponse:\n\t    | SlackResponse\n\t    | MessageResponse\n\t    | SlackViewResponse\n\t    | SlackOptionsResponse\n", "    | string\n\t    | void\n\t): Response {\n\t  if (!slackResponse) {\n\t    return new Response(\"\", {\n\t      status: 200,\n\t      headers: { \"Content-Type\": \"text/plain\" },\n\t    });\n\t  }\n\t  if (typeof slackResponse === \"string\") {\n", "    return new Response(slackResponse, {\n\t      status: 200,\n\t      headers: { \"Content-Type\": \"text/plain;charset=utf-8\" },\n\t    });\n\t  }\n\t  let completeResponse: SlackResponse = {};\n\t  if (\n\t    Object.prototype.hasOwnProperty.call(slackResponse, \"text\") ||\n\t    Object.prototype.hasOwnProperty.call(slackResponse, \"blocks\")\n\t  ) {\n", "    completeResponse = { status: 200, body: slackResponse as MessageResponse };\n\t  } else if (\n\t    Object.prototype.hasOwnProperty.call(slackResponse, \"response_action\")\n\t  ) {\n\t    completeResponse = { status: 200, body: slackResponse };\n\t  } else if (\n\t    Object.prototype.hasOwnProperty.call(slackResponse, \"options\") ||\n\t    Object.prototype.hasOwnProperty.call(slackResponse, \"option_groups\")\n\t  ) {\n\t    completeResponse = { status: 200, body: slackResponse };\n", "  } else {\n\t    completeResponse = slackResponse as SlackResponse;\n\t  }\n\t  const status = completeResponse.status ? completeResponse.status : 200;\n\t  let contentType = completeResponse.contentType\n\t    ? completeResponse.contentType\n\t    : \"text/plain;charset=utf-8\";\n\t  let bodyString = \"\";\n\t  if (typeof completeResponse.body === \"object\") {\n\t    contentType = \"application/json;charset=utf-8\";\n", "    bodyString = JSON.stringify(completeResponse.body);\n\t  } else {\n\t    bodyString = completeResponse.body || \"\";\n\t  }\n\t  return new Response(bodyString, {\n\t    status,\n\t    headers: { \"Content-Type\": contentType },\n\t  });\n\t}\n"]}
{"filename": "src/utility/message-events.ts", "chunked_list": ["import {\n\t  BotMessageEvent,\n\t  FileShareMessageEvent,\n\t  GenericMessageEvent,\n\t  ThreadBroadcastMessageEvent,\n\t} from \"../request/payload/event\";\n\texport const isPostedMessageEvent = (event: {\n\t  type: string;\n\t  subtype?: string;\n\t}): event is\n", "  | GenericMessageEvent\n\t  | BotMessageEvent\n\t  | FileShareMessageEvent\n\t  | ThreadBroadcastMessageEvent => {\n\t  return (\n\t    event.subtype === undefined ||\n\t    event.subtype === \"bot_message\" ||\n\t    event.subtype === \"file_share\" ||\n\t    event.subtype === \"thread_broadcast\"\n\t  );\n", "};\n"]}
{"filename": "src/request/payload-types.ts", "chunked_list": ["export enum PayloadType {\n\t  BlockAction = \"block_actions\",\n\t  BlockSuggestion = \"block_suggestion\",\n\t  MessageShortcut = \"message_action\",\n\t  GlobalShortcut = \"shortcut\",\n\t  EventsAPI = \"event_callback\",\n\t  ViewSubmission = \"view_submission\",\n\t  ViewClosed = \"view_closed\",\n\t  // Note that Slash command payloads do not have \"type\" property\n\t}\n"]}
{"filename": "src/request/request-parser.ts", "chunked_list": ["// deno-lint-ignore require-await\n\texport async function parseRequestBody(\n\t  requestHeaders: Headers,\n\t  requestBody: string\n\t): // deno-lint-ignore no-explicit-any\n\tPromise<Record<string, any>> {\n\t  const contentType = requestHeaders.get(\"content-type\");\n\t  if (\n\t    contentType?.startsWith(\"application/json\") ||\n\t    requestBody.startsWith(\"{\")\n", "  ) {\n\t    return JSON.parse(requestBody);\n\t  }\n\t  const params = new URLSearchParams(requestBody);\n\t  if (params.has(\"payload\")) {\n\t    const payload = params.get(\"payload\")!;\n\t    return JSON.parse(payload);\n\t  }\n\t  // deno-lint-ignore no-explicit-any\n\t  const formBody: any = {};\n", "  for (const k of params.keys()) {\n\t    formBody[k] = params.get(k);\n\t  }\n\t  return formBody;\n\t}\n"]}
{"filename": "src/request/request-verification.ts", "chunked_list": ["export async function verifySlackRequest(\n\t  signingSecret: string,\n\t  requsetHeaders: Headers,\n\t  requestBody: string\n\t) {\n\t  const timestampHeader = requsetHeaders.get(\"x-slack-request-timestamp\");\n\t  if (!timestampHeader) {\n\t    console.log(\"x-slack-request-timestamp header is missing!\");\n\t    return false;\n\t  }\n", "  const fiveMinutesAgoSeconds = Math.floor(Date.now() / 1000) - 60 * 5;\n\t  if (Number.parseInt(timestampHeader) < fiveMinutesAgoSeconds) {\n\t    return false;\n\t  }\n\t  const signatureHeader = requsetHeaders.get(\"x-slack-signature\");\n\t  if (!timestampHeader || !signatureHeader) {\n\t    console.log(\"x-slack-signature header is missing!\");\n\t    return false;\n\t  }\n\t  const textEncoder = new TextEncoder();\n", "  return await crypto.subtle.verify(\n\t    \"HMAC\",\n\t    await crypto.subtle.importKey(\n\t      \"raw\",\n\t      textEncoder.encode(signingSecret),\n\t      { name: \"HMAC\", hash: \"SHA-256\" },\n\t      false,\n\t      [\"verify\"]\n\t    ),\n\t    fromHexStringToBytes(signatureHeader.substring(3)),\n", "    textEncoder.encode(`v0:${timestampHeader}:${requestBody}`)\n\t  );\n\t}\n\tfunction fromHexStringToBytes(hexString: string) {\n\t  const bytes = new Uint8Array(hexString.length / 2);\n\t  for (let idx = 0; idx < hexString.length; idx += 2) {\n\t    bytes[idx / 2] = parseInt(hexString.substring(idx, idx + 2), 16);\n\t  }\n\t  return bytes.buffer;\n\t}\n"]}
{"filename": "src/request/request.ts", "chunked_list": ["import {\n\t  SlackAppContext,\n\t  PreAuthorizeSlackAppContext,\n\t  SlackAppContextWithRespond,\n\t  SlackAppContextWithOptionalRespond,\n\t  SlackAppContextWithChannelId,\n\t} from \"../context/context\";\n\timport { SlackAppEnv } from \"../app-env\";\n\texport interface SlackMiddlewareRequestBase<E extends SlackAppEnv> {\n\t  env: E;\n", "  context: PreAuthorizeSlackAppContext;\n\t  // deno-lint-ignore no-explicit-any\n\t  body: Record<string, any>;\n\t  retryNum?: number;\n\t  retryReason?: string;\n\t  rawBody: string;\n\t  headers: Headers;\n\t}\n\texport type PreAuthorizeSlackMiddlwareRequest<E extends SlackAppEnv> =\n\t  SlackMiddlewareRequestBase<E> & {\n", "    context: PreAuthorizeSlackAppContext;\n\t  };\n\texport type SlackMiddlwareRequest<E extends SlackAppEnv> =\n\t  SlackMiddlewareRequestBase<E> & {\n\t    context: SlackAppContext;\n\t  };\n\texport type SlackRequest<\n\t  E extends SlackAppEnv,\n\t  Payload\n\t> = SlackMiddlwareRequest<E> & {\n", "  payload: Payload;\n\t};\n\texport type SlackRequestWithChannelId<\n\t  E extends SlackAppEnv,\n\t  Payload\n\t> = SlackMiddlwareRequest<E> & {\n\t  context: SlackAppContextWithChannelId;\n\t  payload: Payload;\n\t};\n\texport type SlackRequestWithRespond<\n", "  E extends SlackAppEnv,\n\t  Payload\n\t> = SlackMiddlwareRequest<E> & {\n\t  context: SlackAppContextWithRespond;\n\t  payload: Payload;\n\t};\n\texport type SlackRequestWithOptionalRespond<\n\t  E extends SlackAppEnv,\n\t  Payload\n\t> = SlackMiddlwareRequest<E> & {\n", "  context: SlackAppContextWithOptionalRespond;\n\t  payload: Payload;\n\t};\n"]}
{"filename": "src/request/request-body.ts", "chunked_list": ["export interface SlackRequestBody {\n\t  type?: string;\n\t  // slash commands\n\t  command?: string;\n\t  // event_callback\n\t  event?: {\n\t    type: string;\n\t    subtype?: string;\n\t    text?: string;\n\t  };\n", "  // shortcut, message_action\n\t  callback_id?: string;\n\t  // block_actions\n\t  actions: {\n\t    type: string;\n\t    block_id: string;\n\t    action_id: string;\n\t  }[];\n\t  // block_suggestion\n\t  block_id?: string;\n", "  action_id?: string;\n\t  // view_submission / view_closed\n\t  view?: {\n\t    callback_id: string;\n\t  };\n\t}\n"]}
{"filename": "src/request/payload/global-shortcut.ts", "chunked_list": ["export interface GlobalShortcut {\n\t  type: \"shortcut\";\n\t  callback_id: string;\n\t  trigger_id: string;\n\t  user: {\n\t    id: string;\n\t    username: string;\n\t    team_id: string;\n\t  };\n\t  team: {\n", "    id: string;\n\t    domain: string;\n\t    enterprise_id?: string;\n\t    enterprise_name?: string;\n\t  } | null;\n\t  token: string;\n\t  action_ts: string;\n\t  is_enterprise_install?: boolean;\n\t  enterprise?: { id: string; name: string };\n\t}\n"]}
{"filename": "src/request/payload/block-suggestion.ts", "chunked_list": ["import { AnyOption } from \"slack-web-api-client\";\n\timport { DataSubmissionView } from \"./view-objects\";\n\texport interface BlockSuggestion {\n\t  type: \"block_suggestion\";\n\t  block_id: string;\n\t  action_id: string;\n\t  value: string;\n\t  api_app_id: string;\n\t  team: {\n\t    id: string;\n", "    domain: string;\n\t    enterprise_id?: string;\n\t    enterprise_name?: string;\n\t  } | null;\n\t  channel?: {\n\t    id: string;\n\t    name: string;\n\t  };\n\t  user: {\n\t    id: string;\n", "    name: string;\n\t    team_id?: string;\n\t  };\n\t  token: string;\n\t  // deno-lint-ignore no-explicit-any\n\t  container: any;\n\t  view?: DataSubmissionView;\n\t  is_enterprise_install?: boolean;\n\t  enterprise?: {\n\t    id: string;\n", "    name: string;\n\t  };\n\t}\n\texport interface BlockOptions {\n\t  options: AnyOption[];\n\t}\n\texport interface OptionGroups<Options> {\n\t  option_groups: ({ label: string } & Options)[];\n\t}\n"]}
{"filename": "src/request/payload/slash-command.ts", "chunked_list": ["export interface SlashCommand {\n\t  token: string;\n\t  command: string;\n\t  text: string;\n\t  response_url: string;\n\t  trigger_id: string;\n\t  user_id: string;\n\t  user_name: string;\n\t  team_id: string;\n\t  team_domain: string;\n", "  channel_id: string;\n\t  channel_name: string;\n\t  api_app_id: string;\n\t  enterprise_id?: string;\n\t  enterprise_name?: string;\n\t  is_enterprise_install?: string;\n\t}\n"]}
{"filename": "src/request/payload/view-submission.ts", "chunked_list": ["import { DataSubmissionView } from \"./view-objects\";\n\texport interface ViewSubmission {\n\t  type: \"view_submission\";\n\t  team: {\n\t    id: string;\n\t    domain: string;\n\t    enterprise_id?: string;\n\t    enterprise_name?: string;\n\t  } | null;\n\t  user: {\n", "    id: string;\n\t    name: string;\n\t    team_id?: string;\n\t  };\n\t  view: DataSubmissionView;\n\t  api_app_id: string;\n\t  token: string;\n\t  trigger_id: string;\n\t  is_enterprise_install?: boolean;\n\t  enterprise?: {\n", "    id: string;\n\t    name: string;\n\t  };\n\t  response_urls?: {\n\t    block_id: string;\n\t    action_id: string;\n\t    channel_id: string;\n\t    response_url: string;\n\t  }[];\n\t}\n"]}
{"filename": "src/request/payload/view-closed.ts", "chunked_list": ["import { DataSubmissionView } from \"./view-objects\";\n\texport interface ViewClosed {\n\t  type: \"view_closed\";\n\t  team: {\n\t    id: string;\n\t    domain: string;\n\t    enterprise_id?: string;\n\t    enterprise_name?: string;\n\t  } | null;\n\t  user: {\n", "    id: string;\n\t    name: string;\n\t    team_id?: string;\n\t  };\n\t  view: DataSubmissionView;\n\t  api_app_id: string;\n\t  token: string;\n\t  is_cleared: boolean;\n\t  is_enterprise_install?: boolean;\n\t  enterprise?: { id: string; name: string };\n", "}\n"]}
{"filename": "src/request/payload/view-objects.ts", "chunked_list": ["import {\n\t  AnyActionBlockElementType,\n\t  AnyModalBlock,\n\t  PlainTextField,\n\t} from \"slack-web-api-client\";\n\texport interface ViewStateSelectedOption {\n\t  text: PlainTextField;\n\t  value: string;\n\t}\n\texport interface ViewStateValue {\n", "  type: AnyActionBlockElementType;\n\t  value?: string | null;\n\t  selected_date?: string | null;\n\t  selected_time?: string | null;\n\t  selected_date_time?: number | null;\n\t  selected_conversation?: string | null;\n\t  selected_channel?: string | null;\n\t  selected_user?: string | null;\n\t  selected_option?: ViewStateSelectedOption | null;\n\t  selected_conversations?: string[];\n", "  selected_channels?: string[];\n\t  selected_users?: string[];\n\t  selected_options?: ViewStateSelectedOption[];\n\t}\n\texport interface DataSubmissionView {\n\t  id: string;\n\t  callback_id: string;\n\t  team_id: string;\n\t  app_installed_team_id?: string;\n\t  app_id: string | null;\n", "  bot_id: string;\n\t  title: PlainTextField;\n\t  type: string;\n\t  blocks: AnyModalBlock[];\n\t  close: PlainTextField | null;\n\t  submit: PlainTextField | null;\n\t  state: {\n\t    values: {\n\t      [blockId: string]: {\n\t        [actionId: string]: ViewStateValue;\n", "      };\n\t    };\n\t  };\n\t  hash: string;\n\t  private_metadata: string;\n\t  root_view_id: string | null;\n\t  previous_view_id: string | null;\n\t  clear_on_close: boolean;\n\t  notify_on_close: boolean;\n\t  external_id?: string;\n", "}\n"]}
{"filename": "src/request/payload/event.ts", "chunked_list": ["import {\n\t  AnyMessageBlock,\n\t  MessageAttachment,\n\t  MessageMetadata,\n\t  HomeTabView,\n\t} from \"slack-web-api-client\";\n\texport type AnySlackEvent =\n\t  | AppRequestedEvent\n\t  | AppHomeOpenedEvent\n\t  | AppMentionEvent\n", "  | AppRateLimitedEvent\n\t  | AppUninstalledEvent\n\t  | ChannelArchiveEvent\n\t  | ChannelCreatedEvent\n\t  | ChannelDeletedEvent\n\t  | ChannelHistoryChangedEvent\n\t  | ChannelIDChangedEvent\n\t  | ChannelLeftEvent\n\t  | ChannelRenameEvent\n\t  | ChannelSharedEvent\n", "  | ChannelUnarchiveEvent\n\t  | ChannelUnsharedEvent\n\t  | DNDUpdatedEvent\n\t  | DNDUpdatedUserEvent\n\t  | EmailDomainChangedEvent\n\t  | EmojiChangedEvent\n\t  | FileChangeEvent\n\t  | FileCreatedEvent\n\t  | FileDeletedEvent\n\t  | FilePublicEvent\n", "  | FileSharedEvent\n\t  | FileUnsharedEvent\n\t  | GridMigrationFinishedEvent\n\t  | GridMigrationStartedEvent\n\t  | GroupArchiveEvent\n\t  | GroupCloseEvent\n\t  | GroupDeletedEvent\n\t  | GroupHistoryChangedEvent\n\t  | GroupLeftEvent\n\t  | GroupOpenEvent\n", "  | GroupRenameEvent\n\t  | GroupUnarchiveEvent\n\t  | IMCloseEvent\n\t  | IMCreatedEvent\n\t  | IMHistoryChangedEvent\n\t  | IMOpenEvent\n\t  | InviteRequestedEvent\n\t  | LinkSharedEvent\n\t  | MemberJoinedChannelEvent\n\t  | MemberLeftChannelEvent\n", "  | AnyMessageEvent\n\t  | AnyMessageMetadataEvent\n\t  | PinAddedEvent\n\t  | PinRemovedEvent\n\t  | ReactionAddedEvent\n\t  | ReactionRemovedEvent\n\t  | SharedChannelInviteReceivedEvent\n\t  | SharedChannelInviteAcceptedEvent\n\t  | SharedChannelInviteApprovedEvent\n\t  | SharedChannelInviteDeclinedEvent\n", "  | StarAddedEvent\n\t  | StarRemovedEvent\n\t  | SubteamCreatedEvent\n\t  | SubteamMembersChangedEvent\n\t  | SubteamSelfAddedEvent\n\t  | SubteamSelfRemovedEvent\n\t  | SubteamUpdatedEvent\n\t  | TeamAccessGrantedEvent\n\t  | TeamAccessRevokedEvent\n\t  | TeamDomainChangedEvent\n", "  | TeamJoinEvent\n\t  | TeamRenameEvent\n\t  | TokensRevokedEvent\n\t  | UserChangeEvent\n\t  | UserHuddleChangedEvent\n\t  | UserProfileChangedEvent\n\t  | UserStatusChangedEvent\n\t  | WorkflowDeletedEvent\n\t  | WorkflowPublishedEvent\n\t  | WorkflowUnpublishedEvent\n", "  | WorkflowStepDeletedEvent\n\t  | WorkflowStepExecuteEvent;\n\t// These union types may not be a complete set of events\n\texport type AnySlackEventWithChannelId =\n\t  | AppHomeOpenedEvent\n\t  | AppMentionEvent\n\t  | AppUninstalledEvent\n\t  | ChannelArchiveEvent\n\t  | ChannelCreatedEvent\n\t  | ChannelDeletedEvent\n", "  | ChannelIDChangedEvent\n\t  | ChannelLeftEvent\n\t  | ChannelRenameEvent\n\t  | ChannelSharedEvent\n\t  | ChannelUnarchiveEvent\n\t  | ChannelUnsharedEvent\n\t  | FileSharedEvent\n\t  | FileUnsharedEvent\n\t  | GroupArchiveEvent\n\t  | GroupCloseEvent\n", "  | GroupDeletedEvent\n\t  | GroupLeftEvent\n\t  | GroupOpenEvent\n\t  | GroupRenameEvent\n\t  | GroupUnarchiveEvent\n\t  | IMCloseEvent\n\t  | IMCreatedEvent\n\t  | IMOpenEvent\n\t  | InviteRequestedEvent\n\t  | LinkSharedEvent\n", "  | MemberJoinedChannelEvent\n\t  | MemberLeftChannelEvent\n\t  | AnyMessageEvent\n\t  | AnyMessageMetadataEvent\n\t  | PinAddedEvent\n\t  | PinRemovedEvent\n\t  | ReactionAddedEvent\n\t  | ReactionRemovedEvent\n\t  | SharedChannelInviteReceivedEvent\n\t  | SharedChannelInviteAcceptedEvent\n", "  | SharedChannelInviteApprovedEvent\n\t  | SharedChannelInviteDeclinedEvent\n\t  | StarAddedEvent\n\t  | StarRemovedEvent;\n\texport interface SlackEvent<Type extends string> {\n\t  type: Type;\n\t  subtype?: string;\n\t}\n\texport interface AppRequestedEvent extends SlackEvent<\"app_requested\"> {\n\t  type: \"app_requested\";\n", "  app_request: {\n\t    id: string;\n\t    app: {\n\t      id: string;\n\t      name: string;\n\t      description: string;\n\t      help_url: string;\n\t      privacy_policy_url: string;\n\t      app_homepage_url: string;\n\t      app_directory_url: string;\n", "      is_app_directory_approved: boolean;\n\t      is_internal: boolean;\n\t      additional_info: string;\n\t      icons?: {\n\t        image_32?: string;\n\t        image_36?: string;\n\t        image_48?: string;\n\t        image_64?: string;\n\t        image_72?: string;\n\t        image_96?: string;\n", "        image_128?: string;\n\t        image_192?: string;\n\t        image_512?: string;\n\t        image_1024?: string;\n\t        image_original?: string;\n\t      };\n\t    };\n\t  };\n\t  previous_resolution: {\n\t    status: \"approved\" | \"restricted\";\n", "    scopes: {\n\t      name: string;\n\t      description: string;\n\t      is_dangerous: boolean;\n\t      token_type: \"bot\" | \"user\" | \"app\" | null;\n\t    };\n\t  } | null;\n\t  is_user_app_collaborator: boolean;\n\t  user: {\n\t    id: string;\n", "    name: string;\n\t    email: string;\n\t  };\n\t  team: {\n\t    id: string;\n\t    name: string;\n\t    domain: string;\n\t  };\n\t  scopes: {\n\t    name: string;\n", "    description: string;\n\t    is_dangerous: boolean;\n\t    token_type: \"bot\" | \"user\" | \"app\" | null;\n\t  };\n\t  message: string;\n\t  date_created: number;\n\t}\n\texport interface AppHomeOpenedEvent extends SlackEvent<\"app_home_opened\"> {\n\t  type: \"app_home_opened\";\n\t  user: string;\n", "  channel: string;\n\t  tab: \"home\" | \"messages\";\n\t  view?: HomeTabView;\n\t  event_ts: string;\n\t}\n\texport interface AppMentionEvent extends SlackEvent<\"app_mention\"> {\n\t  type: \"app_mention\";\n\t  subtype?: string;\n\t  bot_id?: string;\n\t  bot_profile?: BotProfile;\n", "  username: string;\n\t  team?: string;\n\t  user?: string;\n\t  text: string;\n\t  attachments?: MessageAttachment[];\n\t  blocks?: AnyMessageBlock[];\n\t  edited?: {\n\t    user: string;\n\t    ts: string;\n\t  };\n", "  ts: string;\n\t  channel: string;\n\t  event_ts: string;\n\t  thread_ts?: string;\n\t}\n\texport interface AppRateLimitedEvent extends SlackEvent<\"app_rate_limited\"> {\n\t  type: \"app_rate_limited\";\n\t  token: string;\n\t  team_id: string;\n\t  minute_rate_limited: number;\n", "  api_app_id: string;\n\t}\n\texport interface AppUninstalledEvent extends SlackEvent<\"app_uninstalled\"> {\n\t  type: \"app_uninstalled\";\n\t}\n\texport interface ChannelArchiveEvent extends SlackEvent<\"channel_archive\"> {\n\t  type: \"channel_archive\";\n\t  channel: string;\n\t  user: string;\n\t  is_moved?: number;\n", "  event_ts: string;\n\t}\n\texport interface ChannelCreatedEvent extends SlackEvent<\"channel_created\"> {\n\t  type: \"channel_created\";\n\t  channel: {\n\t    id: string;\n\t    is_channel: boolean;\n\t    name: string;\n\t    name_normalized: string;\n\t    created: number;\n", "    creator: string;\n\t    is_shared: boolean;\n\t    is_org_shared: boolean;\n\t  };\n\t}\n\texport interface ChannelDeletedEvent extends SlackEvent<\"channel_deleted\"> {\n\t  type: \"channel_deleted\";\n\t  channel: string;\n\t}\n\texport interface ChannelHistoryChangedEvent\n", "  extends SlackEvent<\"channel_history_changed\"> {\n\t  type: \"channel_history_changed\";\n\t  latest: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelIDChangedEvent\n\t  extends SlackEvent<\"channel_id_changed\"> {\n\t  type: \"channel_id_changed\";\n\t  old_channel_id: string;\n", "  new_channel_id: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelLeftEvent extends SlackEvent<\"channel_left\"> {\n\t  type: \"channel_left\";\n\t  channel: string;\n\t  actor_id: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelRenameEvent extends SlackEvent<\"channel_rename\"> {\n", "  type: \"channel_rename\";\n\t  channel: {\n\t    id: string;\n\t    name: string;\n\t    name_normalized: string;\n\t    created: number;\n\t    is_channel: boolean;\n\t    is_mpim: boolean;\n\t  };\n\t  event_ts: string;\n", "}\n\texport interface ChannelSharedEvent extends SlackEvent<\"channel_shared\"> {\n\t  type: \"channel_shared\";\n\t  connected_team_id: string;\n\t  channel: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelUnarchiveEvent extends SlackEvent<\"channel_unarchive\"> {\n\t  type: \"channel_unarchive\";\n\t  channel: string;\n", "  user: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelUnsharedEvent extends SlackEvent<\"channel_unshared\"> {\n\t  type: \"channel_unshared\";\n\t  previously_connected_team_id: string;\n\t  channel: string;\n\t  is_ext_shared: boolean;\n\t  event_ts: string;\n\t}\n", "export interface DNDUpdatedEvent extends SlackEvent<\"dnd_updated\"> {\n\t  type: \"dnd_updated\";\n\t  user: string;\n\t  dnd_status: {\n\t    dnd_enabled: boolean;\n\t    next_dnd_start_ts: number;\n\t    next_dnd_end_ts: number;\n\t    snooze_enabled: boolean;\n\t    snooze_endtime: number;\n\t    snooze_remaining: number;\n", "  };\n\t  event_ts: string;\n\t}\n\texport interface DNDUpdatedUserEvent extends SlackEvent<\"dnd_updated_user\"> {\n\t  type: \"dnd_updated_user\";\n\t  user: string;\n\t  dnd_status: {\n\t    dnd_enabled: boolean;\n\t    next_dnd_start_ts: number;\n\t    next_dnd_end_ts: number;\n", "  };\n\t  event_ts: string;\n\t}\n\texport interface EmailDomainChangedEvent\n\t  extends SlackEvent<\"email_domain_changed\"> {\n\t  type: \"email_domain_changed\";\n\t  email_domain: string;\n\t  event_ts: string;\n\t}\n\t// NOTE: this should probably be broken into its two subtypes\n", "export interface EmojiChangedEvent extends SlackEvent<\"emoji_changed\"> {\n\t  type: \"emoji_changed\";\n\t  subtype: \"add\" | \"remove\" | \"rename\";\n\t  names?: string[]; // only for remove\n\t  name?: string; // only for add\n\t  value?: string; // only for add\n\t  old_name?: string;\n\t  new_name?: string;\n\t  event_ts: string;\n\t}\n", "export interface FileChangeEvent extends SlackEvent<\"file_change\"> {\n\t  type: \"file_change\";\n\t  file_id: string;\n\t  file: { id: string };\n\t}\n\texport interface FileCreatedEvent extends SlackEvent<\"file_created\"> {\n\t  type: \"file_created\";\n\t  file_id: string;\n\t  user_id: string;\n\t  file: { id: string };\n", "  event_ts: string;\n\t}\n\texport interface FileDeletedEvent extends SlackEvent<\"file_deleted\"> {\n\t  type: \"file_deleted\";\n\t  file_id: string;\n\t  channel_ids?: string[];\n\t  event_ts: string;\n\t}\n\texport interface FilePublicEvent extends SlackEvent<\"file_public\"> {\n\t  type: \"file_public\";\n", "  file_id: string;\n\t  user_id: string;\n\t  file: { id: string };\n\t  event_ts: string;\n\t}\n\texport interface FileSharedEvent extends SlackEvent<\"file_shared\"> {\n\t  type: \"file_shared\";\n\t  file_id: string;\n\t  user_id: string;\n\t  file: { id: string };\n", "  channel_id: string;\n\t  event_ts: string;\n\t}\n\texport interface FileUnsharedEvent extends SlackEvent<\"file_unshared\"> {\n\t  type: \"file_unshared\";\n\t  file_id: string;\n\t  user_id: string;\n\t  file: { id: string };\n\t  channel_id: string;\n\t  event_ts: string;\n", "}\n\texport interface GridMigrationFinishedEvent\n\t  extends SlackEvent<\"grid_migration_finished\"> {\n\t  type: \"grid_migration_finished\";\n\t  enterprise_id: string;\n\t}\n\texport interface GridMigrationStartedEvent\n\t  extends SlackEvent<\"grid_migration_started\"> {\n\t  type: \"grid_migration_started\";\n\t  enterprise_id: string;\n", "}\n\texport interface GroupArchiveEvent extends SlackEvent<\"group_archive\"> {\n\t  type: \"group_archive\";\n\t  channel: string;\n\t  user: string;\n\t  is_moved: number;\n\t  event_ts: string;\n\t}\n\texport interface GroupCloseEvent extends SlackEvent<\"group_close\"> {\n\t  type: \"group_close\";\n", "  user: string;\n\t  channel: string;\n\t}\n\texport interface GroupDeletedEvent extends SlackEvent<\"group_deleted\"> {\n\t  type: \"group_deleted\";\n\t  channel: string;\n\t  date_deleted: number;\n\t  actor_id: string;\n\t  event_ts: string;\n\t}\n", "export interface GroupHistoryChangedEvent\n\t  extends SlackEvent<\"group_history_changed\"> {\n\t  type: \"group_history_changed\";\n\t  latest: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n\texport interface GroupLeftEvent extends SlackEvent<\"group_left\"> {\n\t  type: \"group_left\";\n\t  channel: string;\n", "  actor_id: string;\n\t  event_ts: string;\n\t}\n\texport interface GroupOpenEvent extends SlackEvent<\"group_open\"> {\n\t  type: \"group_open\";\n\t  user: string;\n\t  channel: string;\n\t}\n\texport interface GroupRenameEvent extends SlackEvent<\"group_rename\"> {\n\t  type: \"group_rename\";\n", "  channel: {\n\t    id: string;\n\t    name: string;\n\t    name_normalized: string;\n\t    created: number;\n\t    is_channel: boolean;\n\t    is_mpim: boolean;\n\t  };\n\t  event_ts: string;\n\t}\n", "export interface GroupUnarchiveEvent extends SlackEvent<\"group_unarchive\"> {\n\t  type: \"group_unarchive\";\n\t  channel: string;\n\t  actor_id: string;\n\t  event_ts: string;\n\t}\n\texport interface IMCloseEvent extends SlackEvent<\"im_close\"> {\n\t  type: \"im_close\";\n\t  user: string;\n\t  channel: string;\n", "  event_ts: string;\n\t}\n\texport interface IMCreatedEvent extends SlackEvent<\"im_created\"> {\n\t  type: \"im_created\";\n\t  user: string;\n\t  channel: { id: string };\n\t}\n\texport interface IMHistoryChangedEvent\n\t  extends SlackEvent<\"im_history_changed\"> {\n\t  type: \"im_history_changed\";\n", "  latest: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n\texport interface IMOpenEvent extends SlackEvent<\"im_open\"> {\n\t  type: \"im_open\";\n\t  user: string;\n\t  channel: string;\n\t  event_ts: string;\n\t}\n", "export interface InviteRequestedEvent extends SlackEvent<\"invite_requested\"> {\n\t  type: \"invite_requested\";\n\t  invite_request: {\n\t    id: string;\n\t    email: string;\n\t    date_created: number;\n\t    requester_ids: string[];\n\t    channel_ids: string[];\n\t    invite_type: \"restricted\" | \"ultra_restricted\" | \"full_member\";\n\t    real_name: string;\n", "    date_expire: number;\n\t    request_reason: string;\n\t    team: {\n\t      id: string;\n\t      name: string;\n\t      domain: string;\n\t    };\n\t  };\n\t}\n\texport interface LinkSharedEvent extends SlackEvent<\"link_shared\"> {\n", "  type: \"link_shared\";\n\t  channel: string;\n\t  is_bot_user_member: boolean;\n\t  user: string;\n\t  message_ts: string;\n\t  thread_ts?: string;\n\t  links: {\n\t    domain: string;\n\t    url: string;\n\t  }[];\n", "  unfurl_id?: string;\n\t  source?: string;\n\t  event_ts: string;\n\t}\n\texport interface MemberJoinedChannelEvent\n\t  extends SlackEvent<\"member_joined_channel\"> {\n\t  type: \"member_joined_channel\";\n\t  user: string;\n\t  channel: string;\n\t  channel_type: string;\n", "  team: string;\n\t  inviter?: string;\n\t  event_ts: string;\n\t}\n\texport interface MemberLeftChannelEvent\n\t  extends SlackEvent<\"member_left_channel\"> {\n\t  type: \"member_left_channel\";\n\t  user: string;\n\t  channel: string;\n\t  channel_type: string;\n", "  team: string;\n\t  event_ts: string;\n\t}\n\texport interface PinAddedEvent extends SlackEvent<\"pin_added\"> {\n\t  type: \"pin_added\";\n\t  user: string;\n\t  channel_id: string;\n\t  item: PinnedItem;\n\t  item_user: string;\n\t  pin_count: string;\n", "  pinned_info: {\n\t    channel: string;\n\t    pinned_by: string;\n\t    pinned_ts: number;\n\t  };\n\t  event_ts: string;\n\t}\n\texport interface PinRemovedEvent extends SlackEvent<\"pin_removed\"> {\n\t  type: \"pin_removed\";\n\t  user: string;\n", "  channel_id: string;\n\t  item: PinnedItem;\n\t  item_user: string;\n\t  pin_count: string;\n\t  pinned_info: {\n\t    channel: string;\n\t    pinned_by: string;\n\t    pinned_ts: number;\n\t  };\n\t  has_pins: boolean;\n", "  event_ts: string;\n\t}\n\texport interface ReactionAddedEvent extends SlackEvent<\"reaction_added\"> {\n\t  type: \"reaction_added\";\n\t  user: string;\n\t  reaction: string;\n\t  item_user: string;\n\t  item: ReactionMessageItem;\n\t  event_ts: string;\n\t}\n", "export interface ReactionRemovedEvent extends SlackEvent<\"reaction_removed\"> {\n\t  type: \"reaction_removed\";\n\t  user: string;\n\t  reaction: string;\n\t  item_user: string;\n\t  item: ReactionMessageItem;\n\t  event_ts: string;\n\t}\n\texport interface SharedChannelInviteAcceptedEvent\n\t  extends SlackEvent<\"shared_channel_invite_accepted\"> {\n", "  type: \"shared_channel_invite_accepted\";\n\t  approval_required: boolean;\n\t  invite: SharedChannelInviteItem;\n\t  channel: SharedChannelItem;\n\t  teams_in_channel: SharedChannelTeamItem[];\n\t  accepting_user: SharedChannelUserItem;\n\t  event_ts: string;\n\t}\n\texport interface SharedChannelInviteApprovedEvent\n\t  extends SlackEvent<\"shared_channel_invite_approved\"> {\n", "  type: \"shared_channel_invite_approved\";\n\t  invite: SharedChannelInviteItem;\n\t  channel: SharedChannelItem;\n\t  approving_team_id: string;\n\t  teams_in_channel: SharedChannelTeamItem[];\n\t  approving_user: SharedChannelUserItem;\n\t  event_ts: string;\n\t}\n\texport interface SharedChannelInviteDeclinedEvent\n\t  extends SlackEvent<\"shared_channel_invite_declined\"> {\n", "  type: \"shared_channel_invite_declined\";\n\t  invite: SharedChannelInviteItem;\n\t  channel: SharedChannelItem;\n\t  declining_team_id: string;\n\t  teams_in_channel: SharedChannelTeamItem[];\n\t  declining_user: SharedChannelUserItem;\n\t  event_ts: string;\n\t}\n\texport interface SharedChannelInviteReceivedEvent\n\t  extends SlackEvent<\"shared_channel_invite_received\"> {\n", "  type: \"shared_channel_invite_received\";\n\t  invite: SharedChannelInviteItem;\n\t  channel: SharedChannelItem;\n\t  event_ts: string;\n\t}\n\texport interface StarAddedEvent extends SlackEvent<\"star_added\"> {\n\t  type: \"star_added\";\n\t  user: string;\n\t  item: StarItem;\n\t  event_ts: string;\n", "}\n\texport interface StarRemovedEvent extends SlackEvent<\"star_removed\"> {\n\t  type: \"star_removed\";\n\t  user: string;\n\t  item: StarItem;\n\t  event_ts: string;\n\t}\n\texport interface SubteamCreatedEvent extends SlackEvent<\"subteam_created\"> {\n\t  type: \"subteam_created\";\n\t  subteam: Subteam;\n", "  event_ts: string;\n\t}\n\texport interface SubteamMembersChangedEvent\n\t  extends SlackEvent<\"subteam_members_changed\"> {\n\t  type: \"subteam_members_changed\";\n\t  subteam_id: string;\n\t  team_id: string;\n\t  date_previous_update: number;\n\t  date_update: number;\n\t  added_users?: string[];\n", "  added_users_count?: number;\n\t  removed_users?: string[];\n\t  removed_users_count?: number;\n\t  event_ts: string;\n\t}\n\texport interface SubteamSelfAddedEvent\n\t  extends SlackEvent<\"subteam_self_added\"> {\n\t  type: \"subteam_self_added\";\n\t  subteam_id: string;\n\t  event_ts: string;\n", "}\n\texport interface SubteamSelfRemovedEvent\n\t  extends SlackEvent<\"subteam_self_removed\"> {\n\t  type: \"subteam_self_removed\";\n\t  subteam_id: string;\n\t  event_ts: string;\n\t}\n\texport interface SubteamUpdatedEvent extends SlackEvent<\"subteam_updated\"> {\n\t  type: \"subteam_updated\";\n\t  subteam: Subteam;\n", "  event_ts: string;\n\t}\n\texport interface TeamAccessGrantedEvent\n\t  extends SlackEvent<\"team_access_granted\"> {\n\t  type: \"team_access_granted\";\n\t  team_ids: string[];\n\t  event_ts: string;\n\t}\n\texport interface TeamAccessRevokedEvent\n\t  extends SlackEvent<\"team_access_revoked\"> {\n", "  type: \"team_access_revoked\";\n\t  team_ids: string[];\n\t  event_ts: string;\n\t}\n\texport interface TeamDomainChangedEvent\n\t  extends SlackEvent<\"team_domain_changed\"> {\n\t  type: \"team_domain_changed\";\n\t  url: string;\n\t  domain: string;\n\t}\n", "export interface TeamJoinEvent extends SlackEvent<\"team_join\"> {\n\t  type: \"team_join\";\n\t  user: { id: string };\n\t}\n\texport interface TeamRenameEvent extends SlackEvent<\"team_rename\"> {\n\t  type: \"team_rename\";\n\t  name: string;\n\t}\n\texport interface TokensRevokedEvent extends SlackEvent<\"tokens_revoked\"> {\n\t  type: \"tokens_revoked\";\n", "  tokens: {\n\t    oauth?: string[];\n\t    bot?: string[];\n\t  };\n\t}\n\texport interface UserChangeEvent extends SlackEvent<\"user_change\"> {\n\t  type: \"user_change\";\n\t  user: {\n\t    id: string;\n\t    team_id: string;\n", "    name: string;\n\t    deleted: boolean;\n\t    color: string;\n\t    real_name: string;\n\t    tz: string;\n\t    tz_label: string;\n\t    tz_offset: number;\n\t    profile: {\n\t      title: string;\n\t      phone: string;\n", "      skype: string;\n\t      real_name: string;\n\t      real_name_normalized: string;\n\t      display_name: string;\n\t      display_name_normalized: string;\n\t      status_text: string;\n\t      status_text_canonical: string;\n\t      status_emoji: string;\n\t      status_emoji_display_info: StatusEmojiDisplayInfo[];\n\t      status_expiration: number;\n", "      avatar_hash: string;\n\t      huddle_state?: string;\n\t      huddle_state_expiration_ts?: number;\n\t      first_name: string;\n\t      last_name: string;\n\t      email?: string;\n\t      image_original?: string;\n\t      is_custom_image?: boolean;\n\t      image_24: string;\n\t      image_32: string;\n", "      image_48: string;\n\t      image_72: string;\n\t      image_192: string;\n\t      image_512: string;\n\t      image_1024?: string;\n\t      team: string;\n\t      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n\t    };\n\t    is_admin: boolean;\n\t    is_owner: boolean;\n", "    is_primary_owner: boolean;\n\t    is_restricted: boolean;\n\t    is_ultra_restricted: boolean;\n\t    is_bot: boolean;\n\t    is_stranger?: boolean;\n\t    updated: number;\n\t    is_email_confirmed: boolean;\n\t    is_app_user: boolean;\n\t    is_invited_user?: boolean;\n\t    has_2fa?: boolean;\n", "    locale: string;\n\t    presence?: string;\n\t    enterprise_user?: {\n\t      id: string;\n\t      enterprise_id: string;\n\t      enterprise_name: string;\n\t      is_admin: boolean;\n\t      is_owner: boolean;\n\t      teams: string[];\n\t    };\n", "    two_factor_type?: string;\n\t    has_files?: boolean;\n\t    is_workflow_bot?: boolean;\n\t    who_can_share_contact_card: string;\n\t  };\n\t  cache_ts: number;\n\t  event_ts: string;\n\t}\n\texport interface UserHuddleChangedEvent\n\t  extends SlackEvent<\"user_huddle_changed\"> {\n", "  type: \"user_huddle_changed\";\n\t  user: {\n\t    id: string;\n\t    team_id: string;\n\t    name: string;\n\t    deleted: boolean;\n\t    color: string;\n\t    real_name: string;\n\t    tz: string;\n\t    tz_label: string;\n", "    tz_offset: number;\n\t    profile: {\n\t      title: string;\n\t      phone: string;\n\t      skype: string;\n\t      real_name: string;\n\t      real_name_normalized: string;\n\t      display_name: string;\n\t      display_name_normalized: string;\n\t      status_text: string;\n", "      status_text_canonical: string;\n\t      status_emoji: string;\n\t      status_emoji_display_info: StatusEmojiDisplayInfo[];\n\t      status_expiration: number;\n\t      avatar_hash: string;\n\t      huddle_state: string;\n\t      huddle_state_expiration_ts: number;\n\t      first_name: string;\n\t      last_name: string;\n\t      email?: string;\n", "      image_original?: string;\n\t      is_custom_image?: boolean;\n\t      image_24: string;\n\t      image_32: string;\n\t      image_48: string;\n\t      image_72: string;\n\t      image_192: string;\n\t      image_512: string;\n\t      image_1024?: string;\n\t      team: string;\n", "      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n\t    };\n\t    is_admin: boolean;\n\t    is_owner: boolean;\n\t    is_primary_owner: boolean;\n\t    is_restricted: boolean;\n\t    is_ultra_restricted: boolean;\n\t    is_bot: boolean;\n\t    is_stranger?: boolean;\n\t    updated: number;\n", "    is_email_confirmed: boolean;\n\t    is_app_user: boolean;\n\t    is_invited_user?: boolean;\n\t    has_2fa?: boolean;\n\t    locale: string;\n\t    presence?: string;\n\t    enterprise_user?: {\n\t      id: string;\n\t      enterprise_id: string;\n\t      enterprise_name: string;\n", "      is_admin: boolean;\n\t      is_owner: boolean;\n\t      teams: string[];\n\t    };\n\t    two_factor_type?: string;\n\t    has_files?: boolean;\n\t    is_workflow_bot?: boolean;\n\t    who_can_share_contact_card: string;\n\t  };\n\t  cache_ts: number;\n", "  event_ts: string;\n\t}\n\texport interface UserProfileChangedEvent\n\t  extends SlackEvent<\"user_profile_changed\"> {\n\t  type: \"user_profile_changed\";\n\t  user: {\n\t    id: string;\n\t    team_id: string;\n\t    name: string;\n\t    deleted: boolean;\n", "    color: string;\n\t    real_name: string;\n\t    tz: string;\n\t    tz_label: string;\n\t    tz_offset: number;\n\t    profile: {\n\t      title: string;\n\t      phone: string;\n\t      skype: string;\n\t      real_name: string;\n", "      real_name_normalized: string;\n\t      display_name: string;\n\t      display_name_normalized: string;\n\t      status_text: string;\n\t      status_text_canonical: string;\n\t      status_emoji: string;\n\t      status_emoji_display_info: StatusEmojiDisplayInfo[];\n\t      status_expiration: number;\n\t      avatar_hash: string;\n\t      huddle_state: string;\n", "      huddle_state_expiration_ts: number;\n\t      first_name: string;\n\t      last_name: string;\n\t      email?: string;\n\t      image_original?: string;\n\t      is_custom_image?: boolean;\n\t      image_24: string;\n\t      image_32: string;\n\t      image_48: string;\n\t      image_72: string;\n", "      image_192: string;\n\t      image_512: string;\n\t      image_1024?: string;\n\t      team: string;\n\t      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n\t    };\n\t    is_admin: boolean;\n\t    is_owner: boolean;\n\t    is_primary_owner: boolean;\n\t    is_restricted: boolean;\n", "    is_ultra_restricted: boolean;\n\t    is_bot: boolean;\n\t    is_stranger?: boolean;\n\t    updated: number;\n\t    is_email_confirmed: boolean;\n\t    is_app_user: boolean;\n\t    is_invited_user?: boolean;\n\t    has_2fa?: boolean;\n\t    locale: string;\n\t    presence?: string;\n", "    enterprise_user?: {\n\t      id: string;\n\t      enterprise_id: string;\n\t      enterprise_name: string;\n\t      is_admin: boolean;\n\t      is_owner: boolean;\n\t      teams: string[];\n\t    };\n\t    two_factor_type?: string;\n\t    has_files?: boolean;\n", "    is_workflow_bot?: boolean;\n\t    who_can_share_contact_card: string;\n\t  };\n\t  cache_ts: number;\n\t  event_ts: string;\n\t}\n\texport interface UserStatusChangedEvent\n\t  extends SlackEvent<\"user_status_changed\"> {\n\t  type: \"user_status_changed\";\n\t  user: {\n", "    id: string;\n\t    team_id: string;\n\t    name: string;\n\t    deleted: boolean;\n\t    color: string;\n\t    real_name: string;\n\t    tz: string;\n\t    tz_label: string;\n\t    tz_offset: number;\n\t    profile: {\n", "      title: string;\n\t      phone: string;\n\t      skype: string;\n\t      real_name: string;\n\t      real_name_normalized: string;\n\t      display_name: string;\n\t      display_name_normalized: string;\n\t      status_text: string;\n\t      status_text_canonical: string;\n\t      status_emoji: string;\n", "      status_emoji_display_info: StatusEmojiDisplayInfo[];\n\t      status_expiration: number;\n\t      avatar_hash: string;\n\t      first_name: string;\n\t      last_name: string;\n\t      email?: string;\n\t      image_original?: string;\n\t      is_custom_image?: boolean;\n\t      image_24: string;\n\t      image_32: string;\n", "      image_48: string;\n\t      image_72: string;\n\t      image_192: string;\n\t      image_512: string;\n\t      image_1024?: string;\n\t      team: string;\n\t      fields: { [key: string]: { value: string; alt: string } } | [] | null;\n\t    };\n\t    is_admin: boolean;\n\t    is_owner: boolean;\n", "    is_primary_owner: boolean;\n\t    is_restricted: boolean;\n\t    is_ultra_restricted: boolean;\n\t    is_bot: boolean;\n\t    is_stranger?: boolean;\n\t    updated: number;\n\t    is_email_confirmed: boolean;\n\t    is_app_user: boolean;\n\t    is_invited_user?: boolean;\n\t    has_2fa?: boolean;\n", "    locale: string;\n\t    presence?: string;\n\t    enterprise_user?: {\n\t      id: string;\n\t      enterprise_id: string;\n\t      enterprise_name: string;\n\t      is_admin: boolean;\n\t      is_owner: boolean;\n\t      teams: string[];\n\t    };\n", "    two_factor_type?: string;\n\t    has_files?: boolean;\n\t    is_workflow_bot?: boolean;\n\t    who_can_share_contact_card: string;\n\t  };\n\t  cache_ts: number;\n\t  event_ts: string;\n\t}\n\texport interface WorkflowDeletedEvent extends SlackEvent<\"workflow_deleted\"> {\n\t  type: \"workflow_deleted\";\n", "  workflow_id: string;\n\t  workflow_draft_configuration: {\n\t    version_id: string;\n\t    app_steps: {\n\t      app_id: string;\n\t      workflow_step_id: string;\n\t      callback_id: string;\n\t    }[];\n\t  };\n\t  event_ts: string;\n", "}\n\texport interface WorkflowPublishedEvent\n\t  extends SlackEvent<\"workflow_published\"> {\n\t  type: \"workflow_published\";\n\t  workflow_id: string;\n\t  workflow_published_configuration: {\n\t    version_id: string;\n\t    app_steps: {\n\t      app_id: string;\n\t      workflow_step_id: string;\n", "      callback_id: string;\n\t    }[];\n\t  };\n\t  event_ts: string;\n\t}\n\texport interface WorkflowUnpublishedEvent\n\t  extends SlackEvent<\"workflow_unpublished\"> {\n\t  type: \"workflow_unpublished\";\n\t  workflow_id: string;\n\t  workflow_draft_configuration: {\n", "    version_id: string;\n\t    app_steps: {\n\t      app_id: string;\n\t      workflow_step_id: string;\n\t      callback_id: string;\n\t    }[];\n\t  };\n\t  event_ts: string;\n\t}\n\texport interface WorkflowStepDeletedEvent\n", "  extends SlackEvent<\"workflow_step_deleted\"> {\n\t  type: \"workflow_step_deleted\";\n\t  workflow_id: string;\n\t  workflow_draft_configuration: {\n\t    version_id: string;\n\t    app_steps: {\n\t      app_id: string;\n\t      workflow_step_id: string;\n\t      callback_id: string;\n\t    }[];\n", "  };\n\t  workflow_published_configuration?: {\n\t    version_id: string;\n\t    app_steps: {\n\t      app_id: string;\n\t      workflow_step_id: string;\n\t      callback_id: string;\n\t    }[];\n\t  };\n\t  event_ts: string;\n", "}\n\texport interface WorkflowStepExecuteEvent\n\t  extends SlackEvent<\"workflow_step_execute\"> {\n\t  type: \"workflow_step_execute\";\n\t  callback_id: string;\n\t  workflow_step: {\n\t    workflow_step_execute_id: string;\n\t    workflow_id: string;\n\t    workflow_instance_id: string;\n\t    step_id: string;\n", "    // deno-lint-ignore no-explicit-any\n\t    inputs: { [key: string]: { value: any } };\n\t    outputs: { name: string; type: string; label: string }[];\n\t  };\n\t  event_ts: string;\n\t}\n\texport type AnyMessageEvent =\n\t  | GenericMessageEvent\n\t  | BotMessageEvent\n\t  | ChannelArchiveMessageEvent\n", "  | ChannelJoinMessageEvent\n\t  | ChannelLeaveMessageEvent\n\t  | ChannelNameMessageEvent\n\t  | ChannelPostingPermissionsMessageEvent\n\t  | ChannelPurposeMessageEvent\n\t  | ChannelTopicMessageEvent\n\t  | ChannelUnarchiveMessageEvent\n\t  | EKMAccessDeniedMessageEvent\n\t  | FileShareMessageEvent\n\t  | MeMessageEvent\n", "  | MessageChangedEvent\n\t  | MessageDeletedEvent\n\t  | MessageRepliedEvent\n\t  | ThreadBroadcastMessageEvent;\n\texport type AnyMessageItem =\n\t  | GenericMessageEvent\n\t  | BotMessageEvent\n\t  | ChannelArchiveMessageEvent\n\t  | ChannelJoinMessageEvent\n\t  | ChannelLeaveMessageEvent\n", "  | ChannelNameMessageEvent\n\t  | ChannelPostingPermissionsMessageEvent\n\t  | ChannelPurposeMessageEvent\n\t  | ChannelTopicMessageEvent\n\t  | ChannelUnarchiveMessageEvent\n\t  | EKMAccessDeniedMessageEvent\n\t  | FileShareMessageEvent\n\t  | MeMessageEvent\n\t  | MessageRepliedEvent\n\t  | ThreadBroadcastMessageEvent;\n", "export type AnyMessageMetadataEvent =\n\t  | MessageMetadataPostedEvent\n\t  | MessageMetadataUpdatedEvent\n\t  | MessageMetadataDeletedEvent;\n\texport interface GenericMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: undefined;\n\t  event_ts: string;\n\t  team?: string;\n\t  channel: string;\n", "  user: string;\n\t  bot_id?: string;\n\t  bot_profile?: BotProfile;\n\t  text: string;\n\t  ts: string;\n\t  thread_ts?: string;\n\t  channel_type: AnyChannelType;\n\t  attachments?: MessageAttachment[];\n\t  blocks?: AnyMessageBlock[];\n\t  files?: File[];\n", "  edited?: {\n\t    user: string;\n\t    ts: string;\n\t  };\n\t  client_msg_id?: string;\n\t  parent_user_id?: string;\n\t  // TODO: optional types that maybe should flow into other subtypes?\n\t  is_starred?: boolean;\n\t  pinned_to?: string[];\n\t  reactions?: {\n", "    name: string;\n\t    count: number;\n\t    users: string[];\n\t  }[];\n\t}\n\texport interface BotMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"bot_message\";\n\t  event_ts: string;\n\t  channel: string;\n", "  channel_type: AnyChannelType;\n\t  ts: string;\n\t  text: string;\n\t  bot_id: string;\n\t  username?: string;\n\t  icons?: {\n\t    [size: string]: string;\n\t  };\n\t  // copied from MessageEvent\n\t  // TODO: is a user really optional? likely for things like IncomingWebhook authored messages\n", "  user?: string;\n\t  attachments?: MessageAttachment[];\n\t  blocks?: AnyMessageBlock[];\n\t  edited?: {\n\t    user: string;\n\t    ts: string;\n\t  };\n\t  thread_ts?: string;\n\t}\n\texport interface ChannelArchiveMessageEvent extends SlackEvent<\"message\"> {\n", "  type: \"message\";\n\t  subtype: \"channel_archive\";\n\t  team: string;\n\t  user: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  text: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n", "export interface ChannelJoinMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"channel_join\";\n\t  team: string;\n\t  user: string;\n\t  inviter: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  text: string;\n\t  ts: string;\n", "  event_ts: string;\n\t}\n\texport interface ChannelLeaveMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"channel_leave\";\n\t  team: string;\n\t  user: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  text: string;\n", "  ts: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelNameMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"channel_name\";\n\t  team: string;\n\t  user: string;\n\t  name: string;\n\t  old_name: string;\n", "  channel: string;\n\t  channel_type: AnyChannelType;\n\t  text: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelPostingPermissionsMessageEvent\n\t  extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"channel_posting_permissions\";\n", "  user: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  text: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelPurposeMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"channel_purpose\";\n", "  user: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  text: string;\n\t  purpose: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelTopicMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n", "  subtype: \"channel_topic\";\n\t  user: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  text: string;\n\t  topic: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n\texport interface ChannelUnarchiveMessageEvent extends SlackEvent<\"message\"> {\n", "  type: \"message\";\n\t  subtype: \"channel_unarchive\";\n\t  team: string;\n\t  user: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  text: string;\n\t  ts: string;\n\t  event_ts: string;\n\t}\n", "export interface EKMAccessDeniedMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"ekm_access_denied\";\n\t  event_ts: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  ts: string;\n\t  text: string; // This will not have any meaningful content within\n\t  user: \"UREVOKEDU\";\n\t}\n", "export interface FileShareMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"file_share\";\n\t  text: string;\n\t  attachments?: MessageAttachment[];\n\t  blocks?: AnyMessageBlock[];\n\t  files?: File[];\n\t  upload?: boolean;\n\t  display_as_bot?: boolean;\n\t  x_files?: string[];\n", "  user: string;\n\t  parent_user_id?: string;\n\t  ts: string;\n\t  thread_ts?: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  event_ts: string;\n\t}\n\texport interface MeMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n", "  subtype: \"me_message\";\n\t  event_ts: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  user: string;\n\t  text: string;\n\t  ts: string;\n\t}\n\texport interface MessageChangedEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n", "  subtype: \"message_changed\";\n\t  event_ts: string;\n\t  hidden: true;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  ts: string;\n\t  message: AnyMessageItem;\n\t  previous_message: AnyMessageItem;\n\t}\n\texport interface MessageDeletedEvent {\n", "  type: \"message\";\n\t  subtype: \"message_deleted\";\n\t  event_ts: string;\n\t  hidden: true;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  ts: string;\n\t  deleted_ts: string;\n\t  previous_message: AnyMessageItem;\n\t}\n", "export interface MessageRepliedEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"message_replied\";\n\t  event_ts: string;\n\t  hidden: true;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t  ts: string;\n\t  message: AnyMessageItem & {\n\t    // TODO: should this be the union of all message events with type 'message'?\n", "    thread_ts: string;\n\t    reply_count: number;\n\t    replies: AnyMessageEvent[]; // TODO: should this be the union of all message events with type 'message'?\n\t  };\n\t}\n\t// the `reply_broadcast` message subtype is omitted because it is discontinued\n\texport interface ThreadBroadcastMessageEvent extends SlackEvent<\"message\"> {\n\t  type: \"message\";\n\t  subtype: \"thread_broadcast\";\n\t  event_ts: string;\n", "  text: string;\n\t  attachments?: MessageAttachment[];\n\t  blocks?: AnyMessageBlock[];\n\t  user: string;\n\t  ts: string;\n\t  thread_ts?: string;\n\t  root: (GenericMessageEvent | BotMessageEvent) & {\n\t    thread_ts: string;\n\t    reply_count: number;\n\t    reply_users_count: number;\n", "    latest_reply: string;\n\t    reply_users: string[];\n\t  };\n\t  client_msg_id: string;\n\t  channel: string;\n\t  channel_type: AnyChannelType;\n\t}\n\texport interface MessageMetadataPostedEvent\n\t  extends SlackEvent<\"message_metadata_posted\"> {\n\t  type: \"message_metadata_posted\";\n", "  app_id: string;\n\t  bot_id?: string;\n\t  user_id: string;\n\t  team_id: string;\n\t  channel_id: string;\n\t  metadata: MessageMetadata;\n\t  message_ts: string;\n\t  event_ts: string;\n\t}\n\texport interface MessageMetadataUpdatedEvent\n", "  extends SlackEvent<\"message_metadata_updated\"> {\n\t  type: \"message_metadata_updated\";\n\t  channel_id: string;\n\t  event_ts: string;\n\t  previous_metadata: MessageMetadata;\n\t  app_id: string;\n\t  bot_id?: string;\n\t  user_id: string;\n\t  team_id: string;\n\t  message_ts: string;\n", "  metadata: MessageMetadata;\n\t}\n\texport interface MessageMetadataDeletedEvent\n\t  extends SlackEvent<\"message_metadata_deleted\"> {\n\t  type: \"message_metadata_deleted\";\n\t  channel_id: string;\n\t  event_ts: string;\n\t  previous_metadata: MessageMetadata;\n\t  app_id: string;\n\t  bot_id?: string;\n", "  user_id: string;\n\t  team_id: string;\n\t  message_ts: string;\n\t  deleted_ts: string;\n\t}\n\texport type AnyChannelType = \"channel\" | \"group\" | \"im\" | \"mpim\" | \"app_home\";\n\t// -----------------------------------------------------------\n\texport interface BotProfile {\n\t  id: string;\n\t  name: string;\n", "  app_id: string;\n\t  team_id: string;\n\t  icons: { [size: string]: string };\n\t  updated: number;\n\t  deleted: boolean;\n\t}\n\texport interface PinnedItem {\n\t  type: string;\n\t  channel: string;\n\t  created_by: string;\n", "  created: number;\n\t  message?: MessageItem;\n\t  file?: FileItem;\n\t}\n\texport interface SharedChannelTeamItem {\n\t  id: string;\n\t  name: string;\n\t  icon: Record<string, unknown>;\n\t  is_verified: boolean;\n\t  domain: string;\n", "  date_created: number;\n\t}\n\texport interface SharedChannelUserItem {\n\t  id: string;\n\t  team_id: string;\n\t  name: string;\n\t  updated: number;\n\t  profile: {\n\t    real_name: string;\n\t    display_name: string;\n", "    real_name_normalized: string;\n\t    display_name_normalized: string;\n\t    team: string;\n\t    avatar_hash: string;\n\t    email: string;\n\t    image_24: string;\n\t    image_32: string;\n\t    image_48: string;\n\t    image_72: string;\n\t    image_192: string;\n", "    image_512: string;\n\t  };\n\t}\n\texport interface SharedChannelInviteItem {\n\t  id: string;\n\t  date_created: number;\n\t  date_invalid: number;\n\t  inviting_team: SharedChannelTeamItem;\n\t  inviting_user: SharedChannelUserItem;\n\t  recipient_email?: string;\n", "  recipient_user_id?: string;\n\t}\n\texport interface SharedChannelItem {\n\t  id: string;\n\t  is_private: boolean;\n\t  is_im: boolean;\n\t  name: string;\n\t}\n\texport interface Subteam {\n\t  id: string;\n", "  team_id?: string;\n\t  is_usergroup: boolean;\n\t  is_subteam: boolean;\n\t  name: string;\n\t  description?: string;\n\t  handle: string;\n\t  is_external: boolean;\n\t  date_create: number;\n\t  date_update?: number;\n\t  date_delete?: number;\n", "  auto_provision: boolean;\n\t  enterprise_subteam_id?: string;\n\t  created_by: string;\n\t  updated_by?: string;\n\t  prefs?: {\n\t    channels?: string[];\n\t    groups?: string[];\n\t  };\n\t  users: string[];\n\t  user_count: number;\n", "  channel_count?: number;\n\t}\n\texport interface StatusEmojiDisplayInfo {\n\t  emoji_name?: string;\n\t  display_alias?: string;\n\t  display_url?: string;\n\t}\n\texport interface ReactionMessageItem {\n\t  type: \"message\";\n\t  channel: string;\n", "  ts: string;\n\t}\n\texport interface FileInitialComment {\n\t  channel?: string;\n\t  comment?: string;\n\t  created?: number;\n\t  id?: string;\n\t  is_intro?: boolean;\n\t  timestamp?: number;\n\t  user?: string;\n", "}\n\texport interface StarItem {\n\t  date_create: number;\n\t  type: string;\n\t  channel?: string;\n\t  file?: FileItem;\n\t  message?: MessageItem;\n\t  comment?: {\n\t    channel?: string;\n\t    comment?: string;\n", "    created?: number;\n\t    id?: string;\n\t    is_intro?: boolean;\n\t    is_starred?: boolean;\n\t    num_stars?: number;\n\t    timestamp?: number;\n\t    user?: string;\n\t  };\n\t}\n\texport interface FileItem {\n", "  alt_txt?: string;\n\t  app_id?: string;\n\t  app_name?: string;\n\t  bot_id?: string;\n\t  cc?: EmailAddress[];\n\t  channel_actions_count?: number;\n\t  channel_actions_ts?: string;\n\t  channels?: string[];\n\t  comments_count?: number;\n\t  converted_pdf?: string;\n", "  created: number;\n\t  deanimate?: string;\n\t  deanimate_gif?: string;\n\t  display_as_bot?: boolean;\n\t  duration_ms?: number;\n\t  edit_link?: string;\n\t  editable?: boolean;\n\t  editor?: string;\n\t  external_id?: string;\n\t  external_type?: string;\n", "  external_url?: string;\n\t  file_access?: string;\n\t  filetype: string;\n\t  from?: EmailAddress[];\n\t  groups?: string[];\n\t  has_more?: boolean;\n\t  has_more_shares?: boolean;\n\t  has_rich_preview?: boolean;\n\t  headers?: EmailHeaders;\n\t  hls?: string;\n", "  hls_embed?: string;\n\t  id?: string;\n\t  image_exif_rotation?: number;\n\t  ims?: string[];\n\t  initial_comment?: FileInitialComment;\n\t  is_external?: boolean;\n\t  is_public?: boolean;\n\t  is_starred?: boolean;\n\t  last_editor?: string;\n\t  lines?: number;\n", "  lines_more?: number;\n\t  media_display_type?: string;\n\t  media_progress?: SlackVideoMediaProgress;\n\t  mimetype?: string;\n\t  mode?: string;\n\t  mp4?: string;\n\t  name: string;\n\t  non_owner_editable?: boolean;\n\t  num_stars?: number;\n\t  original_attachment_count?: number;\n", "  original_h?: string;\n\t  original_w?: string;\n\t  permalink: string;\n\t  permalink_public?: string;\n\t  pinned_to?: string[];\n\t  pjpeg?: string;\n\t  plain_text?: string;\n\t  pretty_type?: string;\n\t  preview?: string;\n\t  preview_highlight?: string;\n", "  preview_is_truncated?: boolean;\n\t  preview_plain_text?: string;\n\t  public_url_shared?: boolean;\n\t  reactions?: Reaction[];\n\t  sent_to_self?: boolean;\n\t  shares?: FileShares;\n\t  simplified_html?: string;\n\t  size?: number;\n\t  source_team?: string;\n\t  subject?: string;\n", "  subtype?: string;\n\t  thumb_1024?: string;\n\t  thumb_1024_gif?: string;\n\t  thumb_1024_h?: string;\n\t  thumb_1024_w?: string;\n\t  thumb_160?: string;\n\t  thumb_160_gif?: string;\n\t  thumb_160_h?: string;\n\t  thumb_160_w?: string;\n\t  thumb_360?: string;\n", "  thumb_360_gif?: string;\n\t  thumb_360_h?: string;\n\t  thumb_360_w?: string;\n\t  thumb_480?: string;\n\t  thumb_480_gif?: string;\n\t  thumb_480_h?: string;\n\t  thumb_480_w?: string;\n\t  thumb_64?: string;\n\t  thumb_64_gif?: string;\n\t  thumb_64_h?: string;\n", "  thumb_64_w?: string;\n\t  thumb_720?: string;\n\t  thumb_720_gif?: string;\n\t  thumb_720_h?: string;\n\t  thumb_720_w?: string;\n\t  thumb_80?: string;\n\t  thumb_800?: string;\n\t  thumb_800_gif?: string;\n\t  thumb_800_h?: string;\n\t  thumb_800_w?: string;\n", "  thumb_80_gif?: string;\n\t  thumb_80_h?: string;\n\t  thumb_80_w?: string;\n\t  thumb_960?: string;\n\t  thumb_960_gif?: string;\n\t  thumb_960_h?: string;\n\t  thumb_960_w?: string;\n\t  thumb_gif?: string;\n\t  thumb_pdf?: string;\n\t  thumb_pdf_h?: string;\n", "  thumb_pdf_w?: string;\n\t  thumb_tiny?: string;\n\t  thumb_video?: string;\n\t  thumb_video_h?: number;\n\t  thumb_video_w?: number;\n\t  timestamp?: number;\n\t  title?: string;\n\t  to?: EmailAddress[];\n\t  transcription?: FileTranscription;\n\t  updated?: number;\n", "  url_private: string;\n\t  url_private_download: string;\n\t  user: string;\n\t  user_team: string;\n\t  username: string;\n\t  vtt?: string;\n\t}\n\texport interface EmailAddress {\n\t  address: string;\n\t  name: string;\n", "  original: string;\n\t}\n\texport interface EmailHeaders {\n\t  date: string;\n\t  in_reply_to: string;\n\t  message_id: string;\n\t  reply_to: string;\n\t}\n\texport interface SlackVideoMediaProgress {\n\t  duration_ms: number;\n", "  max_offset_ms: number;\n\t  offset_ms: number;\n\t}\n\texport interface Reaction {\n\t  count: number;\n\t  name: string;\n\t  url: string;\n\t  users: string[];\n\t}\n\texport interface FileShares {\n", "  private?: { [key: string]: ShareDetails[] };\n\t  public?: { [key: string]: ShareDetails[] };\n\t}\n\texport interface ShareDetails {\n\t  share_user_id: string;\n\t  team_id: string;\n\t  channel_name: string;\n\t  ts: string;\n\t  latest_reply?: string;\n\t  reply_count?: number;\n", "  reply_users?: string[];\n\t  reply_users_count?: number;\n\t  thread_ts?: string;\n\t}\n\texport interface FileTranscription {\n\t  locale: string;\n\t  status: string;\n\t}\n\texport interface MessageItem {\n\t  attachments?: MessageAttachment[];\n", "  blocks?: AnyMessageBlock[];\n\t  bot_id?: string;\n\t  bot_profile?: BotProfile;\n\t  client_msg_id: string;\n\t  display_as_bot?: boolean;\n\t  edited?: MessageEdited;\n\t  files?: FileElement[];\n\t  inviter?: string;\n\t  is_locked?: boolean;\n\t  is_starred?: boolean;\n", "  last_read?: string;\n\t  latest_reply?: string;\n\t  permalink: string;\n\t  reactions?: Reaction[];\n\t  reply_count?: number;\n\t  reply_users?: string[];\n\t  reply_users_count?: number;\n\t  subscribed?: boolean;\n\t  subtype?: string;\n\t  team: string;\n", "  text: string;\n\t  thread_ts?: string;\n\t  ts: string;\n\t  type: string;\n\t  upload?: boolean;\n\t  user: string;\n\t  username: string;\n\t}\n\texport interface MessageEdited {\n\t  ts: string;\n", "  user: string;\n\t}\n\texport interface FileElement {\n\t  alt_txt?: string;\n\t  app_id?: string;\n\t  app_name?: string;\n\t  bot_id?: string;\n\t  cc?: EmailAddress[];\n\t  channel_actions_count?: number;\n\t  channel_actions_ts?: string;\n", "  channels?: string[];\n\t  comments_count?: number;\n\t  converted_pdf?: string;\n\t  created?: number;\n\t  deanimate?: string;\n\t  deanimate_gif?: string;\n\t  display_as_bot?: boolean;\n\t  duration_ms?: number;\n\t  edit_link?: string;\n\t  editable?: boolean;\n", "  editor?: string;\n\t  external_id?: string;\n\t  external_type?: string;\n\t  external_url?: string;\n\t  file_access?: string;\n\t  filetype?: string;\n\t  from?: EmailAddress[];\n\t  groups?: string[];\n\t  has_more?: boolean;\n\t  has_more_shares?: boolean;\n", "  has_rich_preview?: boolean;\n\t  headers?: Headers;\n\t  hls?: string;\n\t  hls_embed?: string;\n\t  id?: string;\n\t  image_exif_rotation?: number;\n\t  ims?: string[];\n\t  initial_comment?: FileInitialComment;\n\t  is_external: boolean;\n\t  is_public: boolean;\n", "  is_starred?: boolean;\n\t  last_editor?: string;\n\t  lines?: number;\n\t  lines_more?: number;\n\t  media_display_type?: string;\n\t  media_progress?: SlackVideoMediaProgress;\n\t  mimetype: string;\n\t  mode?: string;\n\t  mp4?: string;\n\t  name: string;\n", "  non_owner_editable?: boolean;\n\t  num_stars?: number;\n\t  original_attachment_count?: number;\n\t  original_h?: string;\n\t  original_w?: string;\n\t  permalink: string;\n\t  permalink_public?: string;\n\t  pinned_to?: string[];\n\t  pjpeg?: string;\n\t  plain_text?: string;\n", "  pretty_type?: string;\n\t  preview?: string;\n\t  preview_highlight?: string;\n\t  preview_is_truncated?: boolean;\n\t  preview_plain_text?: string;\n\t  public_url_shared?: boolean;\n\t  reactions?: Reaction[];\n\t  sent_to_self?: boolean;\n\t  shares?: FileShares;\n\t  simplified_html?: string;\n", "  size?: number;\n\t  source_team?: string;\n\t  subject?: string;\n\t  subtype?: string;\n\t  thumb_1024?: string;\n\t  thumb_1024_gif?: string;\n\t  thumb_1024_h?: string;\n\t  thumb_1024_w?: string;\n\t  thumb_160?: string;\n\t  thumb_160_gif?: string;\n", "  thumb_160_h?: string;\n\t  thumb_160_w?: string;\n\t  thumb_360?: string;\n\t  thumb_360_gif?: string;\n\t  thumb_360_h?: string;\n\t  thumb_360_w?: string;\n\t  thumb_480?: string;\n\t  thumb_480_gif?: string;\n\t  thumb_480_h?: string;\n\t  thumb_480_w?: string;\n", "  thumb_64?: string;\n\t  thumb_64_gif?: string;\n\t  thumb_64_h?: string;\n\t  thumb_64_w?: string;\n\t  thumb_720?: string;\n\t  thumb_720_gif?: string;\n\t  thumb_720_h?: string;\n\t  thumb_720_w?: string;\n\t  thumb_80?: string;\n\t  thumb_800?: string;\n", "  thumb_800_gif?: string;\n\t  thumb_800_h?: string;\n\t  thumb_800_w?: string;\n\t  thumb_80_gif?: string;\n\t  thumb_80_h?: string;\n\t  thumb_80_w?: string;\n\t  thumb_960?: string;\n\t  thumb_960_gif?: string;\n\t  thumb_960_h?: string;\n\t  thumb_960_w?: string;\n", "  thumb_gif?: string;\n\t  thumb_pdf?: string;\n\t  thumb_pdf_h?: string;\n\t  thumb_pdf_w?: string;\n\t  thumb_tiny?: string;\n\t  thumb_video?: string;\n\t  thumb_video_h?: number;\n\t  thumb_video_w?: number;\n\t  timestamp: number;\n\t  title: string;\n", "  to?: EmailAddress[];\n\t  transcription?: FileTranscription;\n\t  updated?: number;\n\t  url_private: string;\n\t  url_private_download: string;\n\t  user: string;\n\t  user_team: string;\n\t  username: string;\n\t  vtt?: string;\n\t}\n"]}
{"filename": "src/request/payload/block-action.ts", "chunked_list": ["import { Confirm, AnyOption, PlainTextField } from \"slack-web-api-client\";\n\timport { DataSubmissionView, ViewStateValue } from \"./view-objects\";\n\texport interface BlockAction<A extends BlockElementAction> {\n\t  type: \"block_actions\";\n\t  actions: A[];\n\t  team: {\n\t    id: string;\n\t    domain: string;\n\t    enterprise_id?: string;\n\t    enterprise_name?: string;\n", "  } | null;\n\t  user: {\n\t    id: string;\n\t    name: string;\n\t    team_id?: string;\n\t  };\n\t  channel?: {\n\t    id: string;\n\t    name: string;\n\t  };\n", "  message?: {\n\t    type: \"message\";\n\t    user?: string;\n\t    ts: string;\n\t    text?: string;\n\t    // deno-lint-ignore no-explicit-any\n\t    [key: string]: any;\n\t  };\n\t  view?: DataSubmissionView;\n\t  state?: {\n", "    values: {\n\t      [blockId: string]: {\n\t        [actionId: string]: ViewStateValue;\n\t      };\n\t    };\n\t  };\n\t  token: string;\n\t  response_url: string;\n\t  trigger_id: string;\n\t  api_app_id: string;\n", "  // deno-lint-ignore no-explicit-any\n\t  container: any;\n\t  // deno-lint-ignore no-explicit-any\n\t  app_unfurl?: any;\n\t  is_enterprise_install?: boolean;\n\t  enterprise?: {\n\t    id: string;\n\t    name: string;\n\t  };\n\t}\n", "export interface BlockElementAction<T extends string = string> {\n\t  type: T;\n\t  block_id: string;\n\t  action_id: string;\n\t  action_ts: string;\n\t}\n\texport interface ButtonAction extends BlockElementAction<\"button\"> {\n\t  value: string;\n\t  text: PlainTextField;\n\t  url?: string;\n", "  confirm?: Confirm;\n\t  accessibility_label?: string;\n\t}\n\texport interface StaticSelectAction\n\t  extends BlockElementAction<\"static_select\"> {\n\t  selected_option: {\n\t    text: PlainTextField;\n\t    value: string;\n\t  };\n\t  initial_option?: AnyOption;\n", "  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n\t}\n\texport interface MultiStaticSelectAction\n\t  extends BlockElementAction<\"multi_static_select\"> {\n\t  selected_options: {\n\t    text: PlainTextField;\n\t    value: string;\n\t  }[];\n\t  initial_options?: AnyOption[];\n", "  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n\t}\n\texport interface UsersSelectAction extends BlockElementAction<\"users_select\"> {\n\t  selected_user: string;\n\t  initial_user?: string;\n\t  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n\t}\n\texport interface MultiUsersSelectAction\n", "  extends BlockElementAction<\"multi_users_select\"> {\n\t  selected_users: string[];\n\t  initial_users?: string[];\n\t  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n\t}\n\texport interface ConversationsSelectAction\n\t  extends BlockElementAction<\"conversations_select\"> {\n\t  selected_conversation: string;\n\t  initial_conversation?: string;\n", "  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n\t}\n\texport interface MultiConversationsSelectAction\n\t  extends BlockElementAction<\"multi_conversations_select\"> {\n\t  selected_conversations: string[];\n\t  initial_conversations?: string[];\n\t  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n\t}\n", "export interface ChannelsSelectAction\n\t  extends BlockElementAction<\"channels_select\"> {\n\t  selected_channel: string;\n\t  initial_channel?: string;\n\t  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n\t}\n\texport interface MultiChannelsSelectAction\n\t  extends BlockElementAction<\"multi_channels_select\"> {\n\t  selected_channels: string[];\n", "  initial_channels?: string[];\n\t  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n\t}\n\texport interface ExternalSelectAction\n\t  extends BlockElementAction<\"external_select\"> {\n\t  selected_option?: AnyOption;\n\t  initial_option?: AnyOption;\n\t  placeholder?: PlainTextField;\n\t  min_query_length?: number;\n", "  confirm?: Confirm;\n\t}\n\texport interface MultiExternalSelectAction\n\t  extends BlockElementAction<\"multi_external_select\"> {\n\t  selected_options?: AnyOption[];\n\t  initial_options?: AnyOption[];\n\t  placeholder?: PlainTextField;\n\t  min_query_length?: number;\n\t  confirm?: Confirm;\n\t}\n", "export interface OverflowAction extends BlockElementAction<\"overflow\"> {\n\t  selected_option: {\n\t    text: PlainTextField;\n\t    value: string;\n\t  };\n\t  confirm?: Confirm;\n\t}\n\texport interface DatepickerAction extends BlockElementAction<\"datepicker\"> {\n\t  selected_date: string | null;\n\t  initial_date?: string;\n", "  placeholder?: PlainTextField;\n\t  confirm?: Confirm;\n\t}\n\texport interface RadioButtonsAction\n\t  extends BlockElementAction<\"radio_buttons\"> {\n\t  selected_option: AnyOption | null;\n\t  initial_option?: AnyOption;\n\t  confirm?: Confirm;\n\t}\n\texport interface CheckboxesAction extends BlockElementAction<\"checkboxes\"> {\n", "  selected_options: AnyOption[];\n\t  initial_options?: AnyOption[];\n\t  confirm?: Confirm;\n\t}\n\texport interface PlainTextInputAction\n\t  extends BlockElementAction<\"plain_text_input\"> {\n\t  value: string;\n\t}\n\texport type Actions =\n\t  | ButtonAction\n", "  | StaticSelectAction\n\t  | MultiStaticSelectAction\n\t  | UsersSelectAction\n\t  | MultiUsersSelectAction\n\t  | ConversationsSelectAction\n\t  | MultiConversationsSelectAction\n\t  | ChannelsSelectAction\n\t  | MultiChannelsSelectAction\n\t  | ExternalSelectAction\n\t  | MultiExternalSelectAction\n", "  | OverflowAction\n\t  | DatepickerAction\n\t  | RadioButtonsAction\n\t  | CheckboxesAction\n\t  | PlainTextInputAction;\n\texport type BlockElementTypes = Actions[\"type\"];\n"]}
{"filename": "src/request/payload/message-shortcut.ts", "chunked_list": ["export interface MessageShortcut {\n\t  type: \"message_action\";\n\t  callback_id: string;\n\t  trigger_id: string;\n\t  message_ts: string;\n\t  response_url: string;\n\t  message: {\n\t    type: \"message\";\n\t    user?: string;\n\t    ts: string;\n", "    text?: string;\n\t    // deno-lint-ignore no-explicit-any\n\t    [key: string]: any;\n\t  };\n\t  user: {\n\t    id: string;\n\t    name: string;\n\t    team_id?: string;\n\t    username?: string;\n\t  };\n", "  channel: {\n\t    id: string;\n\t    name: string;\n\t  };\n\t  team: {\n\t    id: string;\n\t    domain: string;\n\t    enterprise_id?: string;\n\t    enterprise_name?: string;\n\t  } | null;\n", "  token: string;\n\t  action_ts: string;\n\t  is_enterprise_install?: boolean;\n\t  enterprise?: {\n\t    id: string;\n\t    name: string;\n\t  };\n\t}\n"]}
{"filename": "src/middleware/built-in-middleware.ts", "chunked_list": ["import { PreAuthorizeMiddleware, Middleware } from \"./middleware\";\n\t// deno-lint-ignore require-await\n\texport const urlVerification: PreAuthorizeMiddleware = async (req) => {\n\t  if (req.body.type === \"url_verification\") {\n\t    return { status: 200, body: req.body.challenge };\n\t  }\n\t};\n\tconst eventTypesToKeep = [\"member_joined_channel\", \"member_left_channel\"];\n\t// deno-lint-ignore require-await\n\texport const ignoringSelfEvents: Middleware = async (req) => {\n", "  if (req.body.event) {\n\t    if (eventTypesToKeep.includes(req.body.event.type)) {\n\t      return;\n\t    }\n\t    if (\n\t      req.context.authorizeResult.botId === req.body.event.bot_id ||\n\t      req.context.authorizeResult.botUserId === req.context.userId\n\t    ) {\n\t      return { status: 200, body: \"\" };\n\t    }\n", "  }\n\t};\n"]}
{"filename": "src/middleware/middleware.ts", "chunked_list": ["import { SlackAppEnv } from \"../app-env\";\n\timport {\n\t  PreAuthorizeSlackMiddlwareRequest,\n\t  SlackMiddlwareRequest,\n\t} from \"../request/request\";\n\timport { SlackResponse } from \"../response/response\";\n\texport type PreAuthorizeMiddleware<E extends SlackAppEnv = SlackAppEnv> = (\n\t  req: PreAuthorizeSlackMiddlwareRequest<E>\n\t) => Promise<SlackResponse | void>;\n\texport type Middleware<E extends SlackAppEnv = SlackAppEnv> = (\n", "  req: SlackMiddlwareRequest<E>\n\t) => Promise<SlackResponse | void>;\n"]}
{"filename": "src/oauth/callback.ts", "chunked_list": ["import { InvalidStateParameter, OAuthErrorCode } from \"./error-codes\";\n\timport { Installation } from \"./installation\";\n\timport { renderErrorPage } from \"./oauth-page-renderer\";\n\texport type BeforeInstallation = (\n\t  req: Request\n\t) => Promise<Response | undefined | void>;\n\texport type AfterInstallation = (\n\t  installation: Installation,\n\t  req: Request\n\t) => Promise<Response | undefined | void>;\n", "export type OnStateValidationError = (\n\t  startPath: string,\n\t  req: Request\n\t) => Promise<Response>;\n\t// deno-lint-ignore require-await\n\texport const defaultOnStateValidationError = async (\n\t  startPath: string,\n\t  // deno-lint-ignore no-unused-vars\n\t  req: Request\n\t) => {\n", "  return new Response(renderErrorPage(startPath, InvalidStateParameter), {\n\t    status: 400,\n\t    headers: { \"Content-Type\": \"text/html; charset=utf-8\" },\n\t  });\n\t};\n\texport type OnFailure = (\n\t  startPath: string,\n\t  reason: OAuthErrorCode,\n\t  req: Request\n\t) => Promise<Response>;\n", "// deno-lint-ignore require-await\n\texport const defaultOnFailure = async (\n\t  startPath: string,\n\t  reason: OAuthErrorCode,\n\t  // deno-lint-ignore no-unused-vars\n\t  req: Request\n\t) => {\n\t  return new Response(renderErrorPage(startPath, reason), {\n\t    status: 400,\n\t    headers: { \"Content-Type\": \"text/html; charset=utf-8\" },\n", "  });\n\t};\n"]}
{"filename": "src/oauth/installation.ts", "chunked_list": ["import { OAuthV2AccessResponse } from \"slack-web-api-client\";\n\texport interface Installation {\n\t  app_id: string;\n\t  is_enterprise_install?: boolean;\n\t  enterprise_id?: string; // only for Enterprise Grid installations\n\t  team_id?: string; // can be absent when is_enterprise_install is true\n\t  user_id: string;\n\t  // bot token\n\t  bot_token?: string;\n\t  bot_user_id?: string;\n", "  bot_scopes?: string[];\n\t  bot_refresh_token?: string; // token rotation\n\t  bot_token_expires_at?: number; // token rotation (epoch time seconds)\n\t  // user token\n\t  user_token?: string;\n\t  user_scopes?: string[];\n\t  user_refresh_token?: string; // token rotation\n\t  user_token_expires_at?: number; // token rotation (epoch time seconds)\n\t  // Only when having incoming-webhooks\n\t  incoming_webhook_url?: string;\n", "  incoming_webhook_channel_id?: string;\n\t  incoming_webhook_configuration_url?: string;\n\t}\n\texport function toInstallation(\n\t  oauthAccess: OAuthV2AccessResponse\n\t): Installation {\n\t  const installation: Installation = {\n\t    app_id: oauthAccess.app_id!,\n\t    is_enterprise_install: oauthAccess.is_enterprise_install,\n\t    enterprise_id: oauthAccess.enterprise?.id,\n", "    team_id: oauthAccess.team?.id,\n\t    user_id: oauthAccess.authed_user?.id!,\n\t    // bot token\n\t    bot_token: oauthAccess.access_token,\n\t    bot_user_id: oauthAccess.bot_user_id,\n\t    bot_scopes: oauthAccess.scope?.split(\",\"),\n\t    bot_refresh_token: oauthAccess.refresh_token,\n\t    bot_token_expires_at: oauthAccess.expires_in\n\t      ? new Date().getTime() / 1000 + oauthAccess.expires_in\n\t      : undefined,\n", "    // user token\n\t    user_token: oauthAccess.authed_user?.access_token,\n\t    user_scopes: oauthAccess.authed_user?.scope?.split(\",\"),\n\t    user_refresh_token: oauthAccess.authed_user?.refresh_token,\n\t    user_token_expires_at: oauthAccess.authed_user?.expires_in\n\t      ? new Date().getTime() / 1000 + oauthAccess.authed_user?.expires_in\n\t      : undefined,\n\t    // Only when having incoming-webhooks\n\t    incoming_webhook_url: oauthAccess.incoming_webhook?.url,\n\t    incoming_webhook_channel_id: oauthAccess.incoming_webhook?.channel_id,\n", "    incoming_webhook_configuration_url: oauthAccess.incoming_webhook?.url,\n\t  };\n\t  return installation;\n\t}\n"]}
{"filename": "src/oauth/authorize-url-generator.ts", "chunked_list": ["import { SlackOAuthEnv } from \"../app-env\";\n\texport function generateAuthorizeUrl<E extends SlackOAuthEnv>(\n\t  state: string,\n\t  env: E,\n\t  team: string | undefined = undefined\n\t): string {\n\t  let url = `https://slack.com/oauth/v2/authorize?state=${state}`;\n\t  url += `&client_id=${env.SLACK_CLIENT_ID}`;\n\t  url += `&scope=${env.SLACK_BOT_SCOPES}`;\n\t  if (env.SLACK_USER_SCOPES) {\n", "    url += `&user_scope=${env.SLACK_USER_SCOPES}`;\n\t  }\n\t  if (env.SLACK_REDIRECT_URI) {\n\t    url += `&redirect_uri=${env.SLACK_REDIRECT_URI}`;\n\t  }\n\t  if (team) {\n\t    url += `&team=${team}`;\n\t  }\n\t  return url;\n\t}\n"]}
{"filename": "src/oauth/error-codes.ts", "chunked_list": ["export interface OAuthErrorCode {\n\t  code: string;\n\t  message: string;\n\t}\n\texport const InvalidStateParameter: OAuthErrorCode = {\n\t  code: \"invalid-state\",\n\t  message: \"The state parameter is missing or invalid\",\n\t};\n\texport const MissingCode: OAuthErrorCode = {\n\t  code: \"missing-code\",\n", "  message: \"The code parameter is missing\",\n\t};\n\texport const InstallationError: OAuthErrorCode = {\n\t  code: \"installation-error\",\n\t  message: \"The installation process failed\",\n\t};\n\texport const InstallationStoreError: OAuthErrorCode = {\n\t  code: \"installation-store-error\",\n\t  message: \"Saving the installation data failed\",\n\t};\n", "export const CompletionPageError: OAuthErrorCode = {\n\t  code: \"completion-page-failure\",\n\t  message: \"Rendering the completion page failed\",\n\t};\n\texport const OpenIDConnectError: OAuthErrorCode = {\n\t  code: \"oidc-error\",\n\t  message: \"The OpenID Connect process failed\",\n\t};\n"]}
{"filename": "src/oauth/oauth-page-renderer.ts", "chunked_list": ["import { OAuthErrorCode } from \"./error-codes\";\n\timport { escapeHtml } from \"./escape-html\";\n\texport function renderStartPage(url: string) {\n\t  return (\n\t    '<html><head><meta http-equiv=\"refresh\" content=\"2;url=' +\n\t    escapeHtml(url) +\n\t    '\" /><title>Redirecting to Slack ...</title></head><body>Redirecting to the Slack OAuth page ... Click <a href=\"' +\n\t    escapeHtml(url) +\n\t    '\">here</a> to continue.</body></html>'\n\t  );\n", "}\n\texport function renderErrorPage(installPath: string, reason: OAuthErrorCode) {\n\t  return (\n\t    '<html><head><style>body {{ padding: 10px 15px; font-family: verdana; text-align: center; }}</style></head><body><h2>Oops, Something Went Wrong!</h2><p>Please try again from <a href=\"' +\n\t    escapeHtml(installPath) +\n\t    '\">here</a> or contact the app owner (reason: ' +\n\t    escapeHtml(reason.message) +\n\t    \")</p></body></html>\"\n\t  );\n\t}\n", "export function renderCompletionPage(\n\t  appId: string,\n\t  teamId: string,\n\t  isEnterpriseInstall: boolean | undefined,\n\t  enterpriseUrl: string | undefined\n\t) {\n\t  let url = `slack://app?team=${teamId}&id=${appId}`;\n\t  if (isEnterpriseInstall && enterpriseUrl !== undefined) {\n\t    url = `${enterpriseUrl}manage/organization/apps/profile/${appId}/workspaces/add\"`;\n\t  }\n", "  const browserUrl = `https://app.slack.com/client/${teamId}`;\n\t  return (\n\t    '<html><head><meta http-equiv=\"refresh\" content=\"0; URL=' +\n\t    escapeHtml(url) +\n\t    '\"><style>body {{ padding: 10px 15px; font-family: verdana; text-align: center; }}</style></head><body><h2>Thank you!</h2><p>Redirecting to the Slack App... click <a href=\"' +\n\t    escapeHtml(url) +\n\t    '\">here</a>. If you use the browser version of Slack, click <a href=\"' +\n\t    escapeHtml(browserUrl) +\n\t    '\" target=\"_blank\">this link</a> instead.</p></body></html>'\n\t  );\n", "}\n"]}
{"filename": "src/oauth/state-store.ts", "chunked_list": ["export interface StateStore {\n\t  issueNewState(): Promise<string>;\n\t  consume(state: string): Promise<boolean>;\n\t}\n\texport class NoStorageStateStore implements StateStore {\n\t  // deno-lint-ignore require-await\n\t  async issueNewState(): Promise<string> {\n\t    return crypto.randomUUID();\n\t  }\n\t  // deno-lint-ignore require-await no-unused-vars\n", "  async consume(state: string): Promise<boolean> {\n\t    return true;\n\t  }\n\t}\n"]}
{"filename": "src/oauth/installation-store.ts", "chunked_list": ["import { SlackOAuthEnv } from \"../app-env\";\n\timport { Authorize } from \"../authorization/authorize\";\n\timport { Installation } from \"./installation\";\n\texport interface InstallationStoreQuery {\n\t  enterpriseId?: string;\n\t  teamId?: string;\n\t  userId?: string;\n\t  isEnterpriseInstall?: boolean;\n\t}\n\texport interface InstallationStore<E extends SlackOAuthEnv> {\n", "  save(installation: Installation, request: Request | undefined): Promise<void>;\n\t  findBotInstallation(\n\t    query: InstallationStoreQuery\n\t  ): Promise<Installation | undefined>;\n\t  findUserInstallation(\n\t    query: InstallationStoreQuery\n\t  ): Promise<Installation | undefined>;\n\t  toAuthorize(): Authorize<E>;\n\t}\n"]}
{"filename": "src/oauth/escape-html.ts", "chunked_list": ["export function escapeHtml(input: string | undefined | null): string {\n\t  if (input) {\n\t    return input\n\t      .replace(/&/g, \"&amp;\")\n\t      .replace(/</g, \"&lt;\")\n\t      .replace(/>/g, \"&gt;\")\n\t      .replace(/\"/g, \"&quot;\")\n\t      .replace(/'/g, \"&#x27;\");\n\t  }\n\t  return \"\";\n", "}\n"]}
