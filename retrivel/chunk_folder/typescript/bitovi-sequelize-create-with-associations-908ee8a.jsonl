{"filename": "jest-unit-config.ts", "chunked_list": ["import config from \"./jest.config\";\n\texport default {\n\t  ...config,\n\t  testMatch: [\"**/*.test.ts\"],\n\t};\n"]}
{"filename": "jest-integration-config.ts", "chunked_list": ["import config from \"./jest.config\";\n\texport default {\n\t  ...config,\n\t  testMatch: [\"**/*.spec.ts\"],\n\t};\n"]}
{"filename": "jest.setup.ts", "chunked_list": ["function toPojo(error: Error) {\n\t  return Object.entries(error).reduce(\n\t    (acc, [key, value]) => ({ ...acc, [key]: value }),\n\t    {},\n\t  );\n\t}\n\texpect.extend({\n\t  toEqualErrors(actual, expected) {\n\t    const actualPojos = actual.map(toPojo);\n\t    const expectedPojos = expected.map(toPojo);\n", "    const stringifiedActual = JSON.stringify(actualPojos);\n\t    const stringifiedExpected = JSON.stringify(expectedPojos);\n\t    const pass = stringifiedActual === stringifiedExpected;\n\t    return {\n\t      pass,\n\t      message: pass\n\t        ? () =>\n\t            `expected ${stringifiedActual} not to equal ${stringifiedExpected}`\n\t        : () => `expected ${stringifiedActual} to equal ${stringifiedExpected}`,\n\t    };\n", "  },\n\t});\n"]}
{"filename": "jest.config.ts", "chunked_list": ["import type { JestConfigWithTsJest } from \"ts-jest\";\n\tconst config: JestConfigWithTsJest = {\n\t  roots: [\"<rootDir>/tests\"],\n\t  collectCoverageFrom: [\"<rootDir>/src/**/*.ts\"],\n\t  coverageDirectory: \"coverage\",\n\t  coverageProvider: \"v8\",\n\t  coverageReporters: [\"html\", \"text\", \"text-summary\"],\n\t  setupFilesAfterEnv: [\"./jest.setup.ts\"],\n\t  testEnvironment: \"node\",\n\t  transform: { \".+\\\\.ts$\": \"ts-jest\" },\n", "  testTimeout: 90000,\n\t  coverageThreshold: {\n\t    global: {\n\t      branches: 80,\n\t      functions: 100,\n\t      lines: 95,\n\t      statements: 95,\n\t    },\n\t  },\n\t};\n", "export default config;\n"]}
{"filename": "jest.d.ts", "chunked_list": ["type OwnMatcher<Params extends unknown[]> = (\n\t  this: jest.MatcherContext,\n\t  actual: Error[],\n\t  ...params: Params\n\t) => jest.CustomMatcherResult;\n\tdeclare global {\n\t  namespace jest {\n\t    interface ExpectExtendMap {\n\t      // A helper for comparing errors array. `toEqual` always returns `true`\n\t      toEqualErrors: OwnMatcher<[errors: Error[]]>;\n", "    }\n\t    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t    interface Matchers<R, T> {\n\t      toEqualErrors(errors: Error[]): T;\n\t    }\n\t  }\n\t}\n\texport {};\n"]}
{"filename": "tests/update.spec.ts", "chunked_list": ["import { Sequelize, DataTypes } from \"sequelize\";\n\timport * as dotenv from \"dotenv\";\n\timport { extendSequelize } from \"../src/sequelize/extended\";\n\timport type {\n\t  SingleSkillUserModel,\n\t  SkillModel,\n\t  UserModel,\n\t  UserSkillModel,\n\t} from \"./types\";\n\timport { NotFoundError, UnexpectedValueError } from \"../src/sequelize/types\";\n", "dotenv.config();\n\tdescribe(\"Update\", () => {\n\t  let sequelize: Sequelize;\n\t  beforeAll(async () => {\n\t    extendSequelize(Sequelize);\n\t    sequelize = new Sequelize(\"sqlite::memory:\", {\n\t      logging: false,\n\t    });\n\t  });\n\t  afterEach(async () => {\n", "    await sequelize.drop();\n\t    jest.clearAllMocks();\n\t  });\n\t  afterAll(async () => {\n\t    await sequelize.close();\n\t  });\n\t  it(\"Should update a record with no associations\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    await sequelize.sync();\n\t    const user = await User.create({\n\t      name: \"Justin\",\n\t      age: 33,\n", "    });\n\t    expect(user).toEqual(expect.objectContaining({ name: \"Justin\", age: 33 }));\n\t    const [updatedCount] = await User.update(\n\t      { age: 32 },\n\t      { where: { id: user.id } },\n\t    );\n\t    expect(updatedCount).toEqual(1);\n\t    const updatedUser = await User.findByPk(user.id);\n\t    expect(updatedUser).toEqual(\n\t      expect.objectContaining({ name: \"Justin\", age: 32 }),\n", "    );\n\t  });\n\t  it(\"Should update records associated through hasOne\", async () => {\n\t    const User = sequelize.define<SingleSkillUserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n", "      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n", "    );\n\t    User.hasOne(Skill, {\n\t      as: \"skill\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n", "    const justin = await User.create({\n\t      name: \"Justin\",\n\t      age: 33,\n\t      skill: { name: \"Programming\" },\n\t    });\n\t    const cooking = await Skill.create({ id: 10, name: \"Cooking\" });\n\t    const [updatedCount] = await User.update(\n\t      { age: 32, skill: { id: cooking.id } },\n\t      { where: { id: justin.id } },\n\t    );\n", "    expect(updatedCount).toEqual(1);\n\t    const updatedUser = await User.findByPk(justin.id, { include: [\"skill\"] });\n\t    expect(updatedUser).toEqual(\n\t      expect.objectContaining({\n\t        name: \"Justin\",\n\t        age: 32,\n\t        skill: expect.objectContaining({ name: \"Cooking\" }),\n\t      }),\n\t    );\n\t    expect(await Skill.count()).toEqual(2);\n", "  });\n\t  it(\"Should update records associated through hasOne - inverse\", async () => {\n\t    const User = sequelize.define<SingleSkillUserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n", "    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n", "    User.hasOne(Skill, {\n\t      as: \"skill\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n\t    const justin = await User.create({\n", "      name: \"Justin\",\n\t      age: 33,\n\t    });\n\t    const cooking = await Skill.create({\n\t      id: 10,\n\t      name: \"Cooking\",\n\t      user: { name: \"Kevin\", age: 32 },\n\t    });\n\t    const [updatedCount] = await Skill.update(\n\t      { name: \"Running\", user: { id: justin.id } },\n", "      { where: { id: cooking.id } },\n\t    );\n\t    expect(updatedCount).toEqual(1);\n\t    const updatedUser = await User.findByPk(justin.id, { include: [\"skill\"] });\n\t    expect(updatedUser).toEqual(\n\t      expect.objectContaining({\n\t        name: \"Justin\",\n\t        age: 33,\n\t        skill: expect.objectContaining({ name: \"Running\" }),\n\t      }),\n", "    );\n\t    expect(await Skill.count()).toEqual(1);\n\t  });\n\t  it(\"Should disassociate records associated through hasOne\", async () => {\n\t    const User = sequelize.define<SingleSkillUserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n", "      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n", "      { timestamps: false },\n\t    );\n\t    User.hasOne(Skill, {\n\t      as: \"skill\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n", "    await sequelize.sync();\n\t    const justin = await User.create({\n\t      name: \"Justin\",\n\t      age: 33,\n\t      skill: { name: \"Programming\" },\n\t    });\n\t    const [updatedCount] = await User.update(\n\t      { age: 32, skill: null },\n\t      { where: { id: justin.id } },\n\t    );\n", "    expect(updatedCount).toEqual(1);\n\t    const updatedUser = await User.findByPk(justin.id, { include: [\"skill\"] });\n\t    expect(updatedUser).toEqual(\n\t      expect.objectContaining({\n\t        name: \"Justin\",\n\t        age: 32,\n\t        skill: null,\n\t      }),\n\t    );\n\t    expect(await Skill.count()).toEqual(1);\n", "  });\n\t  it(\"Should throw with non-existing IDs through hasOne\", async () => {\n\t    const User = sequelize.define<SingleSkillUserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n", "    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n", "    User.hasOne(Skill, {\n\t      as: \"skill\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n\t    const justin = await User.create({\n", "      name: \"Justin\",\n\t      age: 33,\n\t      skill: { name: \"Programming\" },\n\t    });\n\t    await expect(\n\t      User.update({ age: 32, skill: { id: -1 } }, { where: { id: justin.id } }),\n\t    ).rejects.toEqualErrors([\n\t      new NotFoundError({\n\t        detail: \"Payload must include an ID of an existing 'Skill'.\",\n\t        pointer: \"/data/relationships/skill/data/id\",\n", "      }),\n\t    ]);\n\t  });\n\t  it(\"Should update records associated through hasMany\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n", "      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n", "      { timestamps: false },\n\t    );\n\t    User.hasMany(Skill, {\n\t      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n", "    await sequelize.sync();\n\t    const user = await User.create({\n\t      name: \"Justin\",\n\t      age: 33,\n\t      skills: [\n\t        { name: \"Acting\" },\n\t        { name: \"Cooking\" },\n\t        { name: \"Programming\" },\n\t      ],\n\t    });\n", "    const [cooking, programming, running] = await Promise.all([\n\t      Skill.findOne({\n\t        where: { name: \"Cooking\" },\n\t      }),\n\t      Skill.findOne({\n\t        where: { name: \"Programming\" },\n\t      }),\n\t      Skill.create({\n\t        name: \"Running\",\n\t      }),\n", "    ]);\n\t    await User.update(\n\t      {\n\t        name: \"Kevin\",\n\t        age: 32,\n\t        skills: [\n\t          { id: cooking?.id },\n\t          { id: programming?.id },\n\t          { id: running?.id },\n\t        ],\n", "      },\n\t      { where: { id: user.id } },\n\t    );\n\t    const updatedUser = await User.findByPk(user.id, { include: [\"skills\"] });\n\t    const skills = await Skill.findAll();\n\t    expect(updatedUser).toEqual(\n\t      expect.objectContaining({ name: \"Kevin\", age: 32 }),\n\t    );\n\t    expect(updatedUser?.skills?.map((skill) => skill.name).sort()).toEqual([\n\t      \"Cooking\",\n", "      \"Programming\",\n\t      \"Running\",\n\t    ]);\n\t    expect(skills).toHaveLength(4);\n\t  });\n\t  it(\"Should update records associated through hasMany - inverse\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n\t        id: {\n", "          type: DataTypes.INTEGER,\n\t          primaryKey: true,\n\t          autoIncrement: true,\n\t        },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n", "      \"Skill\",\n\t      {\n\t        id: {\n\t          type: DataTypes.INTEGER,\n\t          primaryKey: true,\n\t          autoIncrement: true,\n\t        },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n", "      { timestamps: false },\n\t    );\n\t    User.hasMany(Skill, {\n\t      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n", "    await sequelize.sync();\n\t    const [justin, kevin] = await User.bulkCreate([\n\t      {\n\t        name: \"Justin\",\n\t        age: 33,\n\t        skills: [{ name: \"Acting\" }, { name: \"Cooking\" }],\n\t      },\n\t      {\n\t        name: \"Kevin\",\n\t        age: 32,\n", "        skills: [{ name: \"Programming\" }],\n\t      },\n\t    ]);\n\t    const cookingId = (\n\t      await Skill.findOne({\n\t        where: { name: \"Cooking\" },\n\t      })\n\t    )?.id;\n\t    await Skill.update(\n\t      {\n", "        name: \"Running\",\n\t        user: { id: kevin.id },\n\t      },\n\t      { where: { id: cookingId } },\n\t    );\n\t    const [updatedJustin, updatedKevin] = await Promise.all([\n\t      User.findByPk(justin.id, {\n\t        include: [\"skills\"],\n\t      }),\n\t      User.findByPk(kevin.id, {\n", "        include: [\"skills\"],\n\t      }),\n\t    ]);\n\t    expect(updatedJustin).toEqual(\n\t      expect.objectContaining({ name: \"Justin\", age: 33 }),\n\t    );\n\t    expect(updatedKevin).toEqual(\n\t      expect.objectContaining({ name: \"Kevin\", age: 32 }),\n\t    );\n\t    expect(updatedJustin?.skills?.map((skill) => skill.name)).toEqual([\n", "      \"Acting\",\n\t    ]);\n\t    expect(updatedKevin?.skills?.map((skill) => skill.name).sort()).toEqual([\n\t      \"Programming\",\n\t      \"Running\",\n\t    ]);\n\t    expect(await Skill.count()).toEqual(3);\n\t  });\n\t  it(\"Should disassociate records associated through hasMany\", async () => {\n\t    const User = sequelize.define<UserModel>(\n", "      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n", "      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.hasMany(Skill, {\n\t      as: \"skills\",\n\t      foreignKey: \"userId\",\n", "    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n\t    const user = await User.create({\n\t      name: \"Justin\",\n\t      age: 33,\n\t      skills: [\n", "        { name: \"Acting\" },\n\t        { name: \"Cooking\" },\n\t        { name: \"Programming\" },\n\t      ],\n\t    });\n\t    await User.update(\n\t      {\n\t        name: \"Kevin\",\n\t        age: 32,\n\t        skills: [],\n", "      },\n\t      { where: { id: user.id } },\n\t    );\n\t    const updatedUser = await User.findByPk(user.id, { include: [\"skills\"] });\n\t    const skills = await Skill.findAll();\n\t    expect(updatedUser).toEqual(\n\t      expect.objectContaining({ name: \"Kevin\", age: 32 }),\n\t    );\n\t    expect(updatedUser?.skills).toEqual([]);\n\t    expect(skills).toHaveLength(3);\n", "  });\n\t  it(\"Should throw with non-existing IDs through hasMany\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n", "    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n", "    User.hasMany(Skill, {\n\t      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n\t    const user = await User.create({\n", "      name: \"Justin\",\n\t      age: 33,\n\t      skills: [\n\t        { name: \"Acting\" },\n\t        { name: \"Cooking\" },\n\t        { name: \"Programming\" },\n\t      ],\n\t    });\n\t    await expect(\n\t      User.update(\n", "        {\n\t          name: \"Kevin\",\n\t          age: 32,\n\t          skills: [{ id: -1 }, { id: -2 }],\n\t        },\n\t        { where: { id: user.id } },\n\t      ),\n\t    ).rejects.toEqualErrors([\n\t      new NotFoundError({\n\t        detail: \"Payload must include an ID of an existing 'Skill'.\",\n", "        pointer: \"/data/relationships/skills/data/0/id\",\n\t      }),\n\t      new NotFoundError({\n\t        detail: \"Payload must include an ID of an existing 'Skill'.\",\n\t        pointer: \"/data/relationships/skills/data/1/id\",\n\t      }),\n\t    ]);\n\t  });\n\t  it(\"Should update records associated through belongsToMany\", async () => {\n\t    const User = sequelize.define<UserModel>(\n", "      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n", "      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const UserSkill = sequelize.define<UserSkillModel>(\n\t      \"UserSkill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n", "        userId: DataTypes.INTEGER,\n\t        skillId: DataTypes.INTEGER,\n\t        selfGranted: DataTypes.BOOLEAN,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.belongsToMany(Skill, {\n\t      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t      through: UserSkill,\n", "    });\n\t    Skill.belongsToMany(User, {\n\t      as: \"users\",\n\t      foreignKey: \"skillId\",\n\t      through: UserSkill,\n\t    });\n\t    await sequelize.sync();\n\t    const user = await User.create({\n\t      name: \"Justin\",\n\t      age: 33,\n", "      skills: [\n\t        { name: \"Acting\", through: { selfGranted: true } },\n\t        { name: \"Cooking\" },\n\t        { name: \"Programming\", through: { selfGranted: false } },\n\t      ],\n\t    });\n\t    const [cooking, programming, running] = await Promise.all([\n\t      Skill.findOne({\n\t        where: { name: \"Cooking\" },\n\t      }),\n", "      Skill.findOne({\n\t        where: { name: \"Programming\" },\n\t      }),\n\t      Skill.create({\n\t        name: \"Running\",\n\t      }),\n\t    ]);\n\t    await User.update(\n\t      {\n\t        age: 32,\n", "        skills: [\n\t          { id: programming?.id },\n\t          { id: cooking?.id },\n\t          { id: running?.id },\n\t        ],\n\t      },\n\t      { where: { id: user.id } },\n\t    );\n\t    const updatedUser = await User.findByPk(user.id, { include: [\"skills\"] });\n\t    expect(sequelize.models).toHaveProperty(\"UserSkill\");\n", "    expect(updatedUser?.skills?.map((skill) => skill.name).sort()).toEqual([\n\t      \"Cooking\",\n\t      \"Programming\",\n\t      \"Running\",\n\t    ]);\n\t    const userSkill = await UserSkill.findAll({\n\t      attributes: [\"skillId\"],\n\t      where: { userId: user.id },\n\t    });\n\t    expect(userSkill.map(({ skillId }) => skillId).sort()).toEqual(\n", "      [cooking?.id, programming?.id, running?.id].sort(),\n\t    );\n\t    expect(await Skill.count()).toEqual(4);\n\t  });\n\t  it(\"Should update records associated through belongsToMany - inverse\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n", "        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t      },\n", "      { timestamps: false },\n\t    );\n\t    const UserSkill = sequelize.define<UserSkillModel>(\n\t      \"UserSkill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        userId: DataTypes.INTEGER,\n\t        skillId: DataTypes.INTEGER,\n\t        selfGranted: DataTypes.BOOLEAN,\n\t      },\n", "      { timestamps: false },\n\t    );\n\t    User.belongsToMany(Skill, {\n\t      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t      through: UserSkill,\n\t    });\n\t    Skill.belongsToMany(User, {\n\t      as: \"users\",\n\t      foreignKey: \"skillId\",\n", "      through: UserSkill,\n\t    });\n\t    await sequelize.sync();\n\t    const programming = await Skill.create({\n\t      name: \"Programming\",\n\t      users: [\n\t        {\n\t          name: \"Justin\",\n\t          age: 33,\n\t          through: { selfGranted: false },\n", "        } as UserModel,\n\t        {\n\t          name: \"Kevin\",\n\t          age: 32,\n\t        } as UserModel,\n\t      ],\n\t    });\n\t    const [justin] = await Promise.all([\n\t      User.findOne({\n\t        where: { name: \"Justin\", age: 33 },\n", "      }),\n\t      User.findOne({\n\t        where: { name: \"Kevin\", age: 32 },\n\t      }),\n\t    ]);\n\t    await Skill.update(\n\t      {\n\t        name: \"Cooking\",\n\t        users: [{ id: justin?.id } as UserModel],\n\t      },\n", "      { where: { id: programming.id } },\n\t    );\n\t    const updatedSkill = await Skill.findByPk(programming.id, {\n\t      include: [\"users\"],\n\t    });\n\t    expect(sequelize.models).toHaveProperty(\"UserSkill\");\n\t    expect(updatedSkill?.users?.map((user) => user?.name).sort()).toEqual([\n\t      \"Justin\",\n\t    ]);\n\t    const userSkill = await UserSkill.findAll({\n", "      attributes: [\"skillId\"],\n\t      where: { userId: programming.id },\n\t    });\n\t    expect(userSkill.map(({ skillId }) => skillId)).toEqual([justin?.id]);\n\t    expect(await Skill.count()).toEqual(1);\n\t  });\n\t  it(\"Should disassociate records associated through belongsToMany\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n", "        name: DataTypes.STRING,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const UserSkill = sequelize.define<UserSkillModel>(\n\t      \"UserSkill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        userId: DataTypes.INTEGER,\n\t        skillId: DataTypes.INTEGER,\n", "        selfGranted: DataTypes.BOOLEAN,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.belongsToMany(Skill, {\n\t      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t      through: UserSkill,\n\t    });\n\t    Skill.belongsToMany(User, {\n", "      as: \"users\",\n\t      foreignKey: \"skillId\",\n\t      through: UserSkill,\n\t    });\n\t    await sequelize.sync();\n\t    const user = await User.create({\n\t      name: \"Justin\",\n\t      age: 33,\n\t      skills: [\n\t        { name: \"Acting\", through: { selfGranted: true } },\n", "        { name: \"Cooking\" },\n\t        { name: \"Programming\", through: { selfGranted: false } },\n\t      ],\n\t    });\n\t    await User.update(\n\t      {\n\t        age: 32,\n\t        skills: [],\n\t      },\n\t      { where: { id: user.id } },\n", "    );\n\t    const updatedUser = await User.findByPk(user.id, { include: [\"skills\"] });\n\t    expect(sequelize.models).toHaveProperty(\"UserSkill\");\n\t    expect(updatedUser?.skills).toEqual([]);\n\t    const userSkill = await UserSkill.findAll({\n\t      attributes: [\"skillId\"],\n\t      where: { userId: user.id },\n\t    });\n\t    expect(userSkill).toEqual([]);\n\t    expect(await Skill.count()).toEqual(3);\n", "  });\n\t  it(\"Should throw with non-existing IDs through belongsToMany\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n", "    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const UserSkill = sequelize.define<UserSkillModel>(\n", "      \"UserSkill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        userId: DataTypes.INTEGER,\n\t        skillId: DataTypes.INTEGER,\n\t        selfGranted: DataTypes.BOOLEAN,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.belongsToMany(Skill, {\n", "      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t      through: UserSkill,\n\t    });\n\t    Skill.belongsToMany(User, {\n\t      as: \"users\",\n\t      foreignKey: \"skillId\",\n\t      through: UserSkill,\n\t    });\n\t    await sequelize.sync();\n", "    const user = await User.create({\n\t      name: \"Justin\",\n\t      age: 33,\n\t      skills: [\n\t        { name: \"Acting\", through: { selfGranted: true } },\n\t        { name: \"Cooking\" },\n\t        { name: \"Programming\", through: { selfGranted: false } },\n\t      ],\n\t    });\n\t    await expect(\n", "      User.update(\n\t        {\n\t          age: 32,\n\t          skills: [{ id: -1 }, { id: -2 }],\n\t        },\n\t        { where: { id: user.id } },\n\t      ),\n\t    ).rejects.toEqualErrors([\n\t      new NotFoundError({\n\t        detail: \"Payload must include an ID of an existing 'Skill'.\",\n", "        pointer: \"/data/relationships/skills/data/0/id\",\n\t      }),\n\t      new NotFoundError({\n\t        detail: \"Payload must include an ID of an existing 'Skill'.\",\n\t        pointer: \"/data/relationships/skills/data/1/id\",\n\t      }),\n\t    ]);\n\t  });\n\t  it(\"Should throw a proper error when trying to update without an ID through hasOne\", async () => {\n\t    const User = sequelize.define<SingleSkillUserModel>(\n", "      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n", "      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.hasOne(Skill, {\n\t      as: \"skill\",\n\t      foreignKey: \"userId\",\n", "    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n\t    const justin = await User.create({\n\t      name: \"Justin\",\n\t      age: 33,\n\t      skill: { name: \"Programming\" },\n", "    });\n\t    const cooking = await Skill.create({ id: 10, name: \"Cooking\" });\n\t    await expect(\n\t      User.update(\n\t        { age: 32, skill: { id: cooking.id } },\n\t        { where: { name: justin.name } },\n\t      ),\n\t    ).rejects.toEqualErrors([\n\t      new UnexpectedValueError({\n\t        detail: \"Only updating by the primary key is supported\",\n", "      }),\n\t    ]);\n\t  });\n\t  it(\"Should throw a proper error when trying to update without an ID through hasMany\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n", "      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n", "      { timestamps: false },\n\t    );\n\t    User.hasMany(Skill, {\n\t      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n", "    await sequelize.sync();\n\t    const user = await User.create({\n\t      name: \"Justin\",\n\t      age: 33,\n\t      skills: [\n\t        { name: \"Acting\" },\n\t        { name: \"Cooking\" },\n\t        { name: \"Programming\" },\n\t      ],\n\t    });\n", "    const [cooking, programming, running] = await Promise.all([\n\t      Skill.findOne({\n\t        where: { name: \"Cooking\" },\n\t      }),\n\t      Skill.findOne({\n\t        where: { name: \"Programming\" },\n\t      }),\n\t      Skill.create({\n\t        name: \"Running\",\n\t      }),\n", "    ]);\n\t    await expect(\n\t      User.update(\n\t        {\n\t          name: \"Kevin\",\n\t          age: 32,\n\t          skills: [\n\t            { id: cooking?.id },\n\t            { id: programming?.id },\n\t            { id: running?.id },\n", "          ],\n\t        },\n\t        { where: { name: user.name } },\n\t      ),\n\t    ).rejects.toEqualErrors([\n\t      new UnexpectedValueError({\n\t        detail: \"Only updating by the primary key is supported\",\n\t      }),\n\t    ]);\n\t  });\n", "});\n"]}
{"filename": "tests/types.ts", "chunked_list": ["import type {\n\t  InferAttributes,\n\t  InferCreationAttributes,\n\t  CreationOptional,\n\t  Model,\n\t} from \"sequelize\";\n\texport interface SkillModel\n\t  extends Model<\n\t    InferAttributes<SkillModel>,\n\t    InferCreationAttributes<SkillModel>\n", "  > {\n\t  id?: CreationOptional<number>;\n\t  name: string;\n\t  userId?: number;\n\t  user?: Partial<UserModel>;\n\t  through?: { selfGranted: boolean };\n\t  UserSkill?: { selfGranted: boolean };\n\t  users?: Partial<UserModel[]>;\n\t}\n\texport interface UserModel\n", "  extends Model<\n\t    InferAttributes<UserModel>,\n\t    InferCreationAttributes<UserModel>\n\t  > {\n\t  id: CreationOptional<number>;\n\t  name: string;\n\t  age: number;\n\t  skills?: Array<Partial<SkillModel>>;\n\t  UserSkill?: { selfGranted: boolean };\n\t  through?: { selfGranted: boolean };\n", "}\n\texport interface SingleSkillUserModel\n\t  extends Model<\n\t    InferAttributes<SingleSkillUserModel>,\n\t    InferCreationAttributes<SingleSkillUserModel>\n\t  > {\n\t  id: CreationOptional<number>;\n\t  name: string;\n\t  age: number;\n\t  skill?: Partial<SkillModel> | null;\n", "}\n\texport interface UserSkillModel\n\t  extends Model<\n\t    InferAttributes<UserSkillModel>,\n\t    InferCreationAttributes<UserSkillModel>\n\t  > {\n\t  id: CreationOptional<number>;\n\t  selfGranted: boolean;\n\t  userId: number;\n\t  skillId: number;\n", "}\n"]}
{"filename": "tests/readme.test.ts", "chunked_list": ["import { Sequelize, DataTypes } from \"sequelize\";\n\timport type {\n\t  CreationOptional,\n\t  InferAttributes,\n\t  InferCreationAttributes,\n\t  Model,\n\t} from \"sequelize\";\n\timport * as dotenv from \"dotenv\";\n\timport { extendSequelize } from \"../src/sequelize/extended\";\n\tdotenv.config();\n", "describe(\"Readme\", () => {\n\t  interface SkillModel\n\t    extends Model<\n\t      InferAttributes<SkillModel>,\n\t      InferCreationAttributes<SkillModel>\n\t    > {\n\t    id?: CreationOptional<number>;\n\t    name: string;\n\t    through?: { selfGranted: boolean };\n\t  }\n", "  interface UserModel\n\t    extends Model<\n\t      InferAttributes<UserModel>,\n\t      InferCreationAttributes<UserModel>\n\t    > {\n\t    id?: CreationOptional<number>;\n\t    name: string;\n\t    skills?: SkillModel[];\n\t  }\n\t  interface UserSkillModel\n", "    extends Model<\n\t      InferAttributes<UserSkillModel>,\n\t      InferCreationAttributes<UserSkillModel>\n\t    > {\n\t    id?: CreationOptional<number>;\n\t    userId?: number;\n\t    skillId?: number;\n\t    selfGranted: boolean;\n\t  }\n\t  let sequelize: Sequelize;\n", "  beforeAll(async () => {\n\t    extendSequelize(Sequelize);\n\t    sequelize = new Sequelize(\"sqlite::memory:\", {\n\t      logging: false,\n\t    });\n\t  });\n\t  afterEach(async () => {\n\t    await sequelize.drop();\n\t    jest.clearAllMocks();\n\t  });\n", "  afterAll(async () => {\n\t    await sequelize.close();\n\t  });\n\t  it(\"Should make sure readme example works\", async () => {\n\t    // define your models\n\t    const User = sequelize.define<UserModel>(\"User\", {\n\t      name: DataTypes.STRING,\n\t    });\n\t    const Skill = sequelize.define<SkillModel>(\"Skill\", {\n\t      name: DataTypes.STRING,\n", "    });\n\t    const UserSkill = sequelize.define<UserSkillModel>(\"UserSkill\", {\n\t      userId: DataTypes.INTEGER,\n\t      skillId: DataTypes.INTEGER,\n\t      selfGranted: DataTypes.BOOLEAN,\n\t    });\n\t    User.belongsToMany(Skill, {\n\t      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t      through: UserSkill,\n", "    });\n\t    Skill.belongsToMany(User, {\n\t      as: \"users\",\n\t      foreignKey: \"skillId\",\n\t      through: UserSkill,\n\t    });\n\t    // create the tables\n\t    await sequelize.sync();\n\t    // seed some data\n\t    const cooking = await Skill.create({ name: \"Cooking\" });\n", "    // create a record and associate existing data or create data on the fly\n\t    const justin = await User.create({\n\t      name: \"Justin\",\n\t      skills: [{ name: \"Programming\" }, { id: cooking.id }] as SkillModel[],\n\t    });\n\t    await User.update(\n\t      {\n\t        name: \"Kevin\",\n\t        skills: [{ id: cooking.id }] as SkillModel[],\n\t      },\n", "      { where: { id: justin.id } },\n\t    );\n\t    await User.bulkCreate([\n\t      {\n\t        name: \"John\",\n\t        skills: [{ id: cooking.id }] as SkillModel[],\n\t      },\n\t      {\n\t        name: \"Jane\",\n\t        skills: [\n", "          { name: \"Gaming\", through: { selfGranted: true } },\n\t        ] as SkillModel[],\n\t      },\n\t    ]);\n\t    const users = await User.findAll({\n\t      include: [\"skills\"],\n\t      order: [[\"id\", \"ASC\"]],\n\t    });\n\t    expect(users.map((user) => user.toJSON())).toEqual([\n\t      {\n", "        id: 1,\n\t        name: \"Kevin\",\n\t        skills: [\n\t          {\n\t            id: 1,\n\t            name: \"Cooking\",\n\t            UserSkill: {\n\t              userId: 1,\n\t              skillId: 1,\n\t              selfGranted: null,\n", "              createdAt: expect.any(Date),\n\t              updatedAt: expect.any(Date),\n\t            },\n\t            createdAt: expect.any(Date),\n\t            updatedAt: expect.any(Date),\n\t          },\n\t        ],\n\t        createdAt: expect.any(Date),\n\t        updatedAt: expect.any(Date),\n\t      },\n", "      {\n\t        id: 2,\n\t        name: \"John\",\n\t        skills: [\n\t          {\n\t            id: 1,\n\t            name: \"Cooking\",\n\t            UserSkill: {\n\t              userId: 2,\n\t              skillId: 1,\n", "              selfGranted: null,\n\t              createdAt: expect.any(Date),\n\t              updatedAt: expect.any(Date),\n\t            },\n\t            createdAt: expect.any(Date),\n\t            updatedAt: expect.any(Date),\n\t          },\n\t        ],\n\t        createdAt: expect.any(Date),\n\t        updatedAt: expect.any(Date),\n", "      },\n\t      {\n\t        id: 3,\n\t        name: \"Jane\",\n\t        skills: [\n\t          {\n\t            id: 3,\n\t            name: \"Gaming\",\n\t            UserSkill: {\n\t              userId: 3,\n", "              skillId: 3,\n\t              selfGranted: true,\n\t              createdAt: expect.any(Date),\n\t              updatedAt: expect.any(Date),\n\t            },\n\t            createdAt: expect.any(Date),\n\t            updatedAt: expect.any(Date),\n\t          },\n\t        ],\n\t        createdAt: expect.any(Date),\n", "        updatedAt: expect.any(Date),\n\t      },\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "tests/bulk_create.spec.ts", "chunked_list": ["import { Sequelize, DataTypes, Op } from \"sequelize\";\n\timport * as dotenv from \"dotenv\";\n\timport { extendSequelize } from \"../src/sequelize/extended\";\n\timport type {\n\t  SingleSkillUserModel,\n\t  SkillModel,\n\t  UserModel,\n\t  UserSkillModel,\n\t} from \"./types\";\n\timport { NotFoundError } from \"../src/sequelize/types\";\n", "dotenv.config();\n\tdescribe(\"Bulk Create\", () => {\n\t  let sequelize: Sequelize;\n\t  beforeAll(async () => {\n\t    extendSequelize(Sequelize);\n\t    sequelize = new Sequelize(\"sqlite::memory:\", {\n\t      logging: false,\n\t    });\n\t  });\n\t  afterEach(async () => {\n", "    await sequelize.drop();\n\t    jest.clearAllMocks();\n\t  });\n\t  afterAll(async () => {\n\t    await sequelize.close();\n\t  });\n\t  it(\"Should create records with no associations\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    await sequelize.sync();\n\t    const users = await User.bulkCreate([\n\t      {\n\t        name: \"Justin\",\n", "        age: 33,\n\t      },\n\t      {\n\t        name: \"Kevin\",\n\t        age: 32,\n\t      },\n\t    ]);\n\t    const fetchedUsers = await User.findAll({\n\t      where: { id: { [Op.in]: users.map((user) => user.id) } },\n\t    });\n", "    expect(users).toEqual([\n\t      expect.objectContaining({ name: \"Justin\", age: 33 }),\n\t      expect.objectContaining({ name: \"Kevin\", age: 32 }),\n\t    ]);\n\t    expect(fetchedUsers).toEqual([\n\t      expect.objectContaining({ name: \"Justin\", age: 33 }),\n\t      expect.objectContaining({ name: \"Kevin\", age: 32 }),\n\t    ]);\n\t  });\n\t  it(\"Should create records associated through hasOne\", async () => {\n", "    const User = sequelize.define<SingleSkillUserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n", "      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.hasOne(Skill, {\n\t      as: \"skill\",\n", "      foreignKey: \"userId\",\n\t    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n\t    const { id: cookingId } = await Skill.create({ name: \"Cooking\" });\n\t    const users = await User.bulkCreate([\n\t      {\n", "        name: \"Justin\",\n\t        age: 33,\n\t        skill: { name: \"Programming\" },\n\t      },\n\t      {\n\t        name: \"Kevin\",\n\t        age: 32,\n\t        skill: { id: cookingId },\n\t      },\n\t    ]);\n", "    const usersWithAssociations = await User.findAll({\n\t      where: { id: { [Op.in]: users.map((user) => user.id) } },\n\t      include: [\"skill\"],\n\t    });\n\t    expect(usersWithAssociations[0].name).toEqual(\"Justin\");\n\t    expect(usersWithAssociations[0].age).toEqual(33);\n\t    expect(usersWithAssociations[0].skill?.name).toEqual(\"Programming\");\n\t    expect(usersWithAssociations[1].name).toEqual(\"Kevin\");\n\t    expect(usersWithAssociations[1].age).toEqual(32);\n\t    expect(usersWithAssociations[1].skill?.name).toEqual(\"Cooking\");\n", "    const programming = await Skill.findByPk(\n\t      usersWithAssociations[0].skill?.id,\n\t      {\n\t        include: [\"user\"],\n\t      },\n\t    );\n\t    expect(programming?.user?.id).toEqual(users[0].id);\n\t    expect(programming?.user?.name).toEqual(\"Justin\");\n\t    expect(programming?.user?.age).toEqual(33);\n\t    const cooking = await Skill.findByPk(usersWithAssociations[1].skill?.id, {\n", "      include: [\"user\"],\n\t    });\n\t    expect(cooking?.user?.id).toEqual(users[1].id);\n\t    expect(cooking?.user?.name).toEqual(\"Kevin\");\n\t    expect(cooking?.user?.age).toEqual(32);\n\t  });\n\t  it(\"Should create records associated through hasOne - inverse\", async () => {\n\t    const User = sequelize.define<SingleSkillUserModel>(\n\t      \"User\",\n\t      {\n", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n", "        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.hasOne(Skill, {\n\t      as: \"skill\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    Skill.belongsTo(User, {\n", "      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n\t    const { id: kevinId } = await User.create({ name: \"Kevin\", age: 32 });\n\t    const skills = await Skill.bulkCreate([\n\t      {\n\t        name: \"Programming\",\n\t        user: {\n\t          name: \"Justin\",\n", "          age: 33,\n\t        },\n\t      },\n\t      {\n\t        name: \"Cooking\",\n\t        user: {\n\t          id: kevinId,\n\t        },\n\t      },\n\t    ]);\n", "    const skillsWithAssociations = await Skill.findAll({\n\t      where: { id: { [Op.in]: skills.map((skill) => skill.id as number) } },\n\t      include: [\"user\"],\n\t    });\n\t    expect(skillsWithAssociations[0].user?.name).toEqual(\"Justin\");\n\t    expect(skillsWithAssociations[0].user?.age).toEqual(33);\n\t    expect(skillsWithAssociations[1].user?.name).toEqual(\"Kevin\");\n\t    expect(skillsWithAssociations[1].user?.age).toEqual(32);\n\t    const users = await User.findAll({\n\t      where: {\n", "        id: {\n\t          [Op.in]: skillsWithAssociations.map(\n\t            (skill) => skill.user?.id as number,\n\t          ),\n\t        },\n\t      },\n\t      include: [\"skill\"],\n\t    });\n\t    expect(users[0].name).toEqual(\"Kevin\");\n\t    expect(users[0].age).toEqual(32);\n", "    expect(users[0].skill?.id).toEqual(skills[1].id);\n\t    expect(users[0].skill?.name).toEqual(\"Cooking\");\n\t    expect(users[1].name).toEqual(\"Justin\");\n\t    expect(users[1].age).toEqual(33);\n\t    expect(users[1].skill?.id).toEqual(skills[0].id);\n\t    expect(users[1].skill?.name).toEqual(\"Programming\");\n\t  });\n\t  it(\"Should throw with non-existing IDs through hasOne\", async () => {\n\t    const User = sequelize.define<SingleSkillUserModel>(\n\t      \"User\",\n", "      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.hasOne(Skill, {\n\t      as: \"skill\",\n\t      foreignKey: \"userId\",\n\t    });\n", "    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n\t    await expect(\n\t      User.bulkCreate([\n\t        {\n\t          name: \"Justin\",\n\t          age: 33,\n", "          skill: { name: \"Programming\" },\n\t        },\n\t        {\n\t          name: \"Kevin\",\n\t          age: 32,\n\t          skill: { id: -1 },\n\t        },\n\t      ]),\n\t    ).rejects.toEqualErrors([\n\t      new NotFoundError({\n", "        detail: \"Payload must include an ID of an existing 'Skill'.\",\n\t        pointer: \"/data/1/relationships/skill/data/id\",\n\t      }),\n\t    ]);\n\t  });\n\t  it(\"Should create records associated through hasMany\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n", "        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n", "        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.hasMany(Skill, {\n\t      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n", "      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n\t    const cookingId = (await Skill.create({ name: \"Cooking\" })).id;\n\t    const users = await User.bulkCreate([\n\t      {\n\t        name: \"Justin\",\n\t        age: 33,\n\t        skills: [{ name: \"Programming\" }, { id: cookingId }],\n\t      },\n", "      {\n\t        name: \"Kevin\",\n\t        age: 32,\n\t        skills: [{ name: \"Running\" }],\n\t      },\n\t    ]);\n\t    const usersWithAssociations = await User.findAll({\n\t      where: { id: { [Op.in]: users.map((user) => user.id) } },\n\t      include: \"skills\",\n\t    });\n", "    expect(usersWithAssociations[0].name).toEqual(\"Justin\");\n\t    expect(usersWithAssociations[0].age).toEqual(33);\n\t    expect(usersWithAssociations[0].skills).toHaveLength(2);\n\t    expect(usersWithAssociations[1].name).toEqual(\"Kevin\");\n\t    expect(usersWithAssociations[1].age).toEqual(32);\n\t    expect(usersWithAssociations[1].skills).toHaveLength(1);\n\t    const programming = usersWithAssociations[0].skills?.find(\n\t      ({ name }) => name === \"Programming\",\n\t    );\n\t    const cooking = usersWithAssociations[0].skills?.find(\n", "      ({ name }) => name === \"Cooking\",\n\t    );\n\t    const running = usersWithAssociations[1].skills?.find(\n\t      ({ name }) => name === \"Running\",\n\t    );\n\t    expect(programming).toBeTruthy();\n\t    expect(cooking).toBeTruthy();\n\t    expect(running).toBeTruthy();\n\t    const programmingWithUser = await Skill.findByPk(\n\t      usersWithAssociations[0].skills?.find(\n", "        ({ name }) => name === \"Programming\",\n\t      )?.id,\n\t      { include: [\"user\"] },\n\t    );\n\t    expect(programmingWithUser?.name).toEqual(\"Programming\");\n\t    expect(programmingWithUser?.user?.id).toEqual(users[0].id);\n\t    expect(programmingWithUser?.user?.name).toEqual(\"Justin\");\n\t    expect(programmingWithUser?.user?.age).toEqual(33);\n\t    const cookingWithUsers = await Skill.findByPk(\n\t      usersWithAssociations[0].skills?.find(({ name }) => name === \"Cooking\")\n", "        ?.id,\n\t      { include: [\"user\"] },\n\t    );\n\t    expect(cookingWithUsers?.name).toEqual(\"Cooking\");\n\t    expect(cookingWithUsers?.user?.id).toEqual(users[0].id);\n\t    expect(cookingWithUsers?.user?.name).toEqual(\"Justin\");\n\t    expect(cookingWithUsers?.user?.age).toEqual(33);\n\t    const runningWithUser = await Skill.findByPk(\n\t      usersWithAssociations[1].skills?.find(({ name }) => name === \"Running\")\n\t        ?.id,\n", "      { include: [\"user\"] },\n\t    );\n\t    expect(runningWithUser?.name).toEqual(\"Running\");\n\t    expect(runningWithUser?.user?.id).toEqual(users[1].id);\n\t    expect(runningWithUser?.user?.name).toEqual(\"Kevin\");\n\t    expect(runningWithUser?.user?.age).toEqual(32);\n\t  });\n\t  it(\"Should create records associated through hasMany - inverse\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n", "      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.hasMany(Skill, {\n\t      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t    });\n", "    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n\t    const { id: justinId } = await User.create({ name: \"Justin\", age: 33 });\n\t    const skills = await Skill.bulkCreate([\n\t      {\n\t        name: \"Programming\",\n\t        user: {\n", "          id: justinId,\n\t        },\n\t      },\n\t      {\n\t        name: \"Cooking\",\n\t        user: {\n\t          id: justinId,\n\t        },\n\t      },\n\t      {\n", "        name: \"Running\",\n\t        user: {\n\t          name: \"Kevin\",\n\t          age: 32,\n\t        },\n\t      },\n\t    ]);\n\t    const skillsWithAssociations = await Skill.findAll({\n\t      where: { id: { [Op.in]: skills.map((skill) => skill.id as number) } },\n\t      include: \"user\",\n", "    });\n\t    expect(skillsWithAssociations[0].name).toEqual(\"Programming\");\n\t    expect(skillsWithAssociations[0].user?.name).toEqual(\"Justin\");\n\t    expect(skillsWithAssociations[0].user?.age).toEqual(33);\n\t    expect(skillsWithAssociations[1].name).toEqual(\"Cooking\");\n\t    expect(skillsWithAssociations[1].user?.name).toEqual(\"Justin\");\n\t    expect(skillsWithAssociations[1].user?.age).toEqual(33);\n\t    expect(skillsWithAssociations[2].name).toEqual(\"Running\");\n\t    expect(skillsWithAssociations[2].user?.name).toEqual(\"Kevin\");\n\t    expect(skillsWithAssociations[2].user?.age).toEqual(32);\n", "    const usersWithAssociations = await User.findAll({\n\t      where: {\n\t        id: {\n\t          [Op.in]: skillsWithAssociations.map(\n\t            (skill) => skill.user?.id as number,\n\t          ),\n\t        },\n\t      },\n\t      include: [\"skills\"],\n\t    });\n", "    expect(usersWithAssociations[0].name).toEqual(\"Justin\");\n\t    expect(usersWithAssociations[0].age).toEqual(33);\n\t    expect(usersWithAssociations[0].skills).toHaveLength(2);\n\t    expect(usersWithAssociations[0].skills?.[0].name).toEqual(\"Programming\");\n\t    expect(usersWithAssociations[0].skills?.[1].name).toEqual(\"Cooking\");\n\t    expect(usersWithAssociations[1].name).toEqual(\"Kevin\");\n\t    expect(usersWithAssociations[1].age).toEqual(32);\n\t    expect(usersWithAssociations[1].skills).toHaveLength(1);\n\t    expect(usersWithAssociations[1].skills?.[0].name).toEqual(\"Running\");\n\t  });\n", "  it(\"Should throw with non-existing IDs through hasMany\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n", "    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.hasMany(Skill, {\n", "      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n\t    await expect(\n\t      User.bulkCreate([\n", "        {\n\t          name: \"Justin\",\n\t          age: 33,\n\t          skills: [{ name: \"Programming\" }, { id: -1 }],\n\t        },\n\t        {\n\t          name: \"Kevin\",\n\t          age: 32,\n\t          skills: [{ name: \"Running\" }, { id: -2 }, { id: -3 }],\n\t        },\n", "      ]),\n\t    ).rejects.toEqualErrors([\n\t      new NotFoundError({\n\t        detail: \"Payload must include an ID of an existing 'Skill'.\",\n\t        pointer: \"/data/0/relationships/skills/data/1/id\",\n\t      }),\n\t      new NotFoundError({\n\t        detail: \"Payload must include an ID of an existing 'Skill'.\",\n\t        pointer: \"/data/1/relationships/skills/data/1/id\",\n\t      }),\n", "      new NotFoundError({\n\t        detail: \"Payload must include an ID of an existing 'Skill'.\",\n\t        pointer: \"/data/1/relationships/skills/data/2/id\",\n\t      }),\n\t    ]);\n\t  });\n\t  it(\"Should create table and records associated through belongsToMany\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n", "        name: DataTypes.STRING,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const UserSkill = sequelize.define<UserSkillModel>(\n\t      \"UserSkill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        userId: DataTypes.INTEGER,\n\t        skillId: DataTypes.INTEGER,\n", "        selfGranted: DataTypes.BOOLEAN,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.belongsToMany(Skill, {\n\t      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t      through: UserSkill,\n\t    });\n\t    Skill.belongsToMany(User, {\n", "      as: \"users\",\n\t      foreignKey: \"skillId\",\n\t      through: UserSkill,\n\t    });\n\t    await sequelize.sync();\n\t    const { id: programmingId } = await Skill.create({ name: \"Programming\" });\n\t    const users = await User.bulkCreate([\n\t      {\n\t        name: \"Justin\",\n\t        age: 33,\n", "        skills: [\n\t          { id: programmingId },\n\t          { name: \"Cooking\", through: { selfGranted: true } },\n\t        ],\n\t      },\n\t      {\n\t        name: \"Kevin\",\n\t        age: 32,\n\t        skills: [{ id: programmingId, through: { selfGranted: false } }],\n\t      },\n", "    ]);\n\t    const usersWithAssociations = await User.findAll({\n\t      where: { id: { [Op.in]: users.map((user) => user.id) } },\n\t      include: \"skills\",\n\t    });\n\t    expect(usersWithAssociations[0].name).toEqual(\"Justin\");\n\t    expect(usersWithAssociations[0].age).toEqual(33);\n\t    expect(usersWithAssociations[0].skills).toHaveLength(2);\n\t    expect(usersWithAssociations[1].name).toEqual(\"Kevin\");\n\t    expect(usersWithAssociations[1].age).toEqual(32);\n", "    expect(usersWithAssociations[1].skills).toHaveLength(1);\n\t    const programming = usersWithAssociations[0].skills?.find(\n\t      ({ name }) => name === \"Programming\",\n\t    );\n\t    const cooking = usersWithAssociations[0].skills?.find(\n\t      ({ name }) => name === \"Cooking\",\n\t    );\n\t    const programming2 = usersWithAssociations[1].skills?.find(\n\t      ({ name }) => name === \"Programming\",\n\t    );\n", "    expect(programming?.UserSkill?.selfGranted).toBeNull();\n\t    expect(cooking?.UserSkill?.selfGranted).toEqual(true);\n\t    expect(programming2?.UserSkill?.selfGranted).toEqual(false);\n\t    const programmingWithUsers = await Skill.findByPk(\n\t      usersWithAssociations[0].skills?.find(\n\t        ({ name }) => name === \"Programming\",\n\t      )?.id,\n\t      { include: [\"users\"] },\n\t    );\n\t    expect(programmingWithUsers?.name).toEqual(\"Programming\");\n", "    expect(programmingWithUsers?.users?.[0]?.id).toEqual(users[0].id);\n\t    expect(programmingWithUsers?.users?.[0]?.name).toEqual(\"Justin\");\n\t    expect(programmingWithUsers?.users?.[0]?.age).toEqual(33);\n\t    expect(programmingWithUsers?.users?.[0]?.UserSkill?.selfGranted).toBeNull();\n\t    expect(programmingWithUsers?.users?.[1]?.id).toEqual(users[1].id);\n\t    expect(programmingWithUsers?.users?.[1]?.name).toEqual(\"Kevin\");\n\t    expect(programmingWithUsers?.users?.[1]?.age).toEqual(32);\n\t    expect(programmingWithUsers?.users?.[1]?.UserSkill?.selfGranted).toEqual(\n\t      false,\n\t    );\n", "    const cookingWithUser = await Skill.findByPk(\n\t      usersWithAssociations[0].skills?.find(({ name }) => name === \"Cooking\")\n\t        ?.id,\n\t      { include: [\"users\"] },\n\t    );\n\t    expect(cookingWithUser?.name).toEqual(\"Cooking\");\n\t    expect(cookingWithUser?.users?.[0]?.id).toEqual(users[0].id);\n\t    expect(cookingWithUser?.users?.[0]?.name).toEqual(\"Justin\");\n\t    expect(cookingWithUser?.users?.[0]?.age).toEqual(33);\n\t    expect(cookingWithUser?.users?.[0]?.UserSkill?.selfGranted).toEqual(true);\n", "  });\n\t  it(\"Should create table and records associated through belongsToMany - inverse\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n", "    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const UserSkill = sequelize.define<UserSkillModel>(\n", "      \"UserSkill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        userId: DataTypes.INTEGER,\n\t        skillId: DataTypes.INTEGER,\n\t        selfGranted: DataTypes.BOOLEAN,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.belongsToMany(Skill, {\n", "      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t      through: UserSkill,\n\t    });\n\t    Skill.belongsToMany(User, {\n\t      as: \"users\",\n\t      foreignKey: \"skillId\",\n\t      through: UserSkill,\n\t    });\n\t    await sequelize.sync();\n", "    const { id: justinId } = await User.create({ name: \"Justin\", age: 33 });\n\t    await Skill.bulkCreate([\n\t      {\n\t        name: \"Programming\",\n\t        users: [\n\t          {\n\t            id: justinId,\n\t          } as UserModel,\n\t          {\n\t            name: \"Kevin\",\n", "            age: 32,\n\t            through: { selfGranted: false },\n\t          } as UserModel,\n\t        ],\n\t      },\n\t      {\n\t        name: \"Cooking\",\n\t        users: [\n\t          {\n\t            id: justinId,\n", "            through: { selfGranted: true },\n\t          } as UserModel,\n\t        ],\n\t      },\n\t    ]);\n\t    const kevinId = (\n\t      await User.findOne({\n\t        where: { name: \"Kevin\", age: 32 },\n\t      })\n\t    )?.id;\n", "    const users = await User.findAll({\n\t      where: { id: { [Op.in]: [justinId, kevinId] as number[] } },\n\t      include: \"skills\",\n\t    });\n\t    expect(users[0].name).toEqual(\"Justin\");\n\t    expect(users[0].age).toEqual(33);\n\t    expect(users[0].skills).toHaveLength(2);\n\t    const programming = users[0].skills?.find(\n\t      ({ name }) => name === \"Programming\",\n\t    );\n", "    const cooking = users[0].skills?.find(({ name }) => name === \"Cooking\");\n\t    const programming2 = users[1].skills?.find(\n\t      ({ name }) => name === \"Programming\",\n\t    );\n\t    expect(programming?.UserSkill?.selfGranted).toBeNull();\n\t    expect(cooking?.UserSkill?.selfGranted).toEqual(true);\n\t    expect(programming2?.UserSkill?.selfGranted).toEqual(false);\n\t    const programmingWithUsers = await Skill.findByPk(programming?.id, {\n\t      include: [\"users\"],\n\t    });\n", "    expect(programmingWithUsers?.name).toEqual(\"Programming\");\n\t    expect(programmingWithUsers?.users).toHaveLength(2);\n\t    expect(programmingWithUsers?.users?.[0]?.id).toEqual(kevinId);\n\t    expect(programmingWithUsers?.users?.[0]?.name).toEqual(\"Kevin\");\n\t    expect(programmingWithUsers?.users?.[0]?.age).toEqual(32);\n\t    expect(programmingWithUsers?.users?.[0]?.UserSkill?.selfGranted).toEqual(\n\t      false,\n\t    );\n\t    expect(programmingWithUsers?.users?.[1]?.id).toEqual(justinId);\n\t    expect(programmingWithUsers?.users?.[1]?.name).toEqual(\"Justin\");\n", "    expect(programmingWithUsers?.users?.[1]?.age).toEqual(33);\n\t    expect(programmingWithUsers?.users?.[1]?.UserSkill?.selfGranted).toBeNull();\n\t    const cookingWithUser = await Skill.findByPk(cooking?.id, {\n\t      include: [\"users\"],\n\t    });\n\t    expect(cookingWithUser?.name).toEqual(\"Cooking\");\n\t    expect(cookingWithUser?.users).toHaveLength(1);\n\t    expect(cookingWithUser?.users?.[0]?.id).toEqual(justinId);\n\t    expect(cookingWithUser?.users?.[0]?.name).toEqual(\"Justin\");\n\t    expect(cookingWithUser?.users?.[0]?.age).toEqual(33);\n", "    expect(cookingWithUser?.users?.[0]?.UserSkill?.selfGranted).toEqual(true);\n\t  });\n\t  it(\"Should throw with non-existing IDs through belongsToMany\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n", "      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t      },\n\t      { timestamps: false },\n\t    );\n", "    const UserSkill = sequelize.define<UserSkillModel>(\n\t      \"UserSkill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        userId: DataTypes.INTEGER,\n\t        skillId: DataTypes.INTEGER,\n\t        selfGranted: DataTypes.BOOLEAN,\n\t      },\n\t      { timestamps: false },\n\t    );\n", "    User.belongsToMany(Skill, {\n\t      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t      through: UserSkill,\n\t    });\n\t    Skill.belongsToMany(User, {\n\t      as: \"users\",\n\t      foreignKey: \"skillId\",\n\t      through: UserSkill,\n\t    });\n", "    await sequelize.sync();\n\t    await expect(\n\t      User.bulkCreate([\n\t        {\n\t          name: \"Justin\",\n\t          age: 33,\n\t          skills: [\n\t            { id: -1 },\n\t            { name: \"Cooking\", through: { selfGranted: true } },\n\t          ],\n", "        },\n\t        {\n\t          name: \"Kevin\",\n\t          age: 32,\n\t          skills: [\n\t            { id: -2, through: { selfGranted: false } },\n\t            { id: -3, through: { selfGranted: true } },\n\t          ],\n\t        },\n\t      ]),\n", "    ).rejects.toEqualErrors([\n\t      new NotFoundError({\n\t        detail: \"Payload must include an ID of an existing 'Skill'.\",\n\t        pointer: \"/data/0/relationships/skills/data/0/id\",\n\t      }),\n\t      new NotFoundError({\n\t        detail: \"Payload must include an ID of an existing 'Skill'.\",\n\t        pointer: \"/data/1/relationships/skills/data/0/id\",\n\t      }),\n\t      new NotFoundError({\n", "        detail: \"Payload must include an ID of an existing 'Skill'.\",\n\t        pointer: \"/data/1/relationships/skills/data/1/id\",\n\t      }),\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "tests/extended.spec.ts", "chunked_list": ["import { Sequelize, DataTypes } from \"sequelize\";\n\timport * as dotenv from \"dotenv\";\n\timport { extendSequelize, getLookup } from \"../src/sequelize/extended\";\n\timport type {\n\t  SingleSkillUserModel,\n\t  SkillModel,\n\t  UserModel,\n\t  UserSkillModel,\n\t} from \"./types\";\n\tdotenv.config();\n", "describe(\"Extended\", () => {\n\t  let sequelize: Sequelize;\n\t  beforeAll(async () => {\n\t    extendSequelize(Sequelize);\n\t    sequelize = new Sequelize(\"sqlite::memory:\", {\n\t      logging: false,\n\t    });\n\t  });\n\t  afterEach(async () => {\n\t    await sequelize.drop();\n", "    jest.clearAllMocks();\n\t  });\n\t  afterAll(async () => {\n\t    await sequelize.close();\n\t  });\n\t  describe(\"getLookup\", () => {\n\t    it(\"Should get the associations for one to one\", () => {\n\t      const User = sequelize.define<SingleSkillUserModel>(\n\t        \"User\",\n\t        {\n", "          id: {\n\t            type: DataTypes.INTEGER,\n\t            primaryKey: true,\n\t            autoIncrement: true,\n\t          },\n\t          name: DataTypes.STRING,\n\t          age: DataTypes.INTEGER,\n\t        },\n\t        { timestamps: false },\n\t      );\n", "      const Skill = sequelize.define<SkillModel>(\n\t        \"Skill\",\n\t        {\n\t          id: {\n\t            type: DataTypes.INTEGER,\n\t            primaryKey: true,\n\t            autoIncrement: true,\n\t          },\n\t          name: DataTypes.STRING,\n\t          userId: DataTypes.INTEGER,\n", "        },\n\t        { timestamps: false },\n\t      );\n\t      User.hasOne(Skill, {\n\t        as: \"skill\",\n\t        foreignKey: \"userId\",\n\t      });\n\t      Skill.belongsTo(User, {\n\t        as: \"user\",\n\t        foreignKey: \"userId\",\n", "      });\n\t      expect(getLookup(sequelize)).toEqual({\n\t        User: {\n\t          skill: {\n\t            joinTable: undefined,\n\t            type: \"HasOne\",\n\t            key: \"userId\",\n\t            model: \"Skill\",\n\t          },\n\t        },\n", "        Skill: { user: { type: \"BelongsTo\", key: \"userId\", model: \"User\" } },\n\t      });\n\t    });\n\t    it(\"Should get the associations for one to many\", () => {\n\t      const User = sequelize.define<UserModel>(\n\t        \"User\",\n\t        {\n\t          id: {\n\t            type: DataTypes.INTEGER,\n\t            primaryKey: true,\n", "            autoIncrement: true,\n\t          },\n\t          name: DataTypes.STRING,\n\t          age: DataTypes.INTEGER,\n\t        },\n\t        { timestamps: false },\n\t      );\n\t      const Skill = sequelize.define<SkillModel>(\n\t        \"Skill\",\n\t        {\n", "          id: {\n\t            type: DataTypes.INTEGER,\n\t            primaryKey: true,\n\t            autoIncrement: true,\n\t          },\n\t          name: DataTypes.STRING,\n\t          userId: DataTypes.INTEGER,\n\t        },\n\t        { timestamps: false },\n\t      );\n", "      User.hasMany(Skill, {\n\t        as: \"skills\",\n\t        foreignKey: \"userId\",\n\t      });\n\t      Skill.belongsTo(User, {\n\t        as: \"user\",\n\t        foreignKey: \"userId\",\n\t      });\n\t      expect(getLookup(sequelize)).toEqual({\n\t        User: { skills: { type: \"HasMany\", key: \"userId\", model: \"Skill\" } },\n", "        Skill: { user: { type: \"BelongsTo\", key: \"userId\", model: \"User\" } },\n\t      });\n\t    });\n\t    it(\"Should get the associations for many to many\", () => {\n\t      const User = sequelize.define<UserModel>(\n\t        \"User\",\n\t        {\n\t          id: {\n\t            type: DataTypes.INTEGER,\n\t            primaryKey: true,\n", "            autoIncrement: true,\n\t          },\n\t          name: DataTypes.STRING,\n\t          age: DataTypes.INTEGER,\n\t        },\n\t        { timestamps: false },\n\t      );\n\t      const Skill = sequelize.define<SkillModel>(\n\t        \"Skill\",\n\t        {\n", "          id: {\n\t            type: DataTypes.INTEGER,\n\t            primaryKey: true,\n\t            autoIncrement: true,\n\t          },\n\t          name: DataTypes.STRING,\n\t        },\n\t        { timestamps: false },\n\t      );\n\t      const UserSkill = sequelize.define<UserSkillModel>(\n", "        \"UserSkill\",\n\t        {\n\t          id: {\n\t            type: DataTypes.INTEGER,\n\t            primaryKey: true,\n\t            autoIncrement: true,\n\t          },\n\t          userId: DataTypes.INTEGER,\n\t          skillId: DataTypes.INTEGER,\n\t          selfGranted: DataTypes.BOOLEAN,\n", "        },\n\t        { timestamps: false },\n\t      );\n\t      User.belongsToMany(Skill, {\n\t        as: \"skills\",\n\t        foreignKey: \"userId\",\n\t        through: UserSkill,\n\t      });\n\t      Skill.belongsToMany(User, {\n\t        as: \"users\",\n", "        foreignKey: \"skillId\",\n\t        through: UserSkill,\n\t      });\n\t      expect(getLookup(sequelize)).toEqual({\n\t        Skill: {\n\t          users: {\n\t            joinTable: expect.any(Function),\n\t            key: \"skillId\",\n\t            model: \"User\",\n\t            type: \"BelongsToMany\",\n", "          },\n\t        },\n\t        User: {\n\t          skills: {\n\t            joinTable: expect.any(Function),\n\t            key: \"userId\",\n\t            model: \"Skill\",\n\t            type: \"BelongsToMany\",\n\t          },\n\t        },\n", "        UserSkill: {},\n\t      });\n\t    });\n\t  });\n\t});\n"]}
{"filename": "tests/create.spec.ts", "chunked_list": ["import { Sequelize, DataTypes } from \"sequelize\";\n\timport * as dotenv from \"dotenv\";\n\timport { extendSequelize } from \"../src/sequelize/extended\";\n\timport type {\n\t  SingleSkillUserModel,\n\t  SkillModel,\n\t  UserModel,\n\t  UserSkillModel,\n\t} from \"./types\";\n\timport { NotFoundError } from \"../src/sequelize/types\";\n", "dotenv.config();\n\tdescribe(\"Create\", () => {\n\t  let sequelize: Sequelize;\n\t  beforeAll(async () => {\n\t    extendSequelize(Sequelize);\n\t    sequelize = new Sequelize(\"sqlite::memory:\", {\n\t      logging: false,\n\t    });\n\t  });\n\t  afterEach(async () => {\n", "    await sequelize.drop();\n\t    jest.clearAllMocks();\n\t  });\n\t  afterAll(async () => {\n\t    await sequelize.close();\n\t  });\n\t  it(\"Should create records with no associations\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    await sequelize.sync();\n\t    const user = await User.create({\n\t      name: \"Justin\",\n\t      age: 33,\n", "    });\n\t    const fetchedUser = await User.findByPk(user.id);\n\t    expect(user).toEqual(expect.objectContaining({ name: \"Justin\", age: 33 }));\n\t    expect(fetchedUser).toEqual(\n\t      expect.objectContaining({ name: \"Justin\", age: 33 }),\n\t    );\n\t  });\n\t  it(\"Should create records associated through hasOne\", async () => {\n\t    const User = sequelize.define<SingleSkillUserModel>(\n\t      \"User\",\n", "      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.hasOne(Skill, {\n\t      as: \"skill\",\n\t      foreignKey: \"userId\",\n\t    });\n", "    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n\t    const user = await User.create({\n\t      name: \"Justin\",\n\t      age: 32,\n\t      skill: { name: \"Programming\" },\n\t    });\n", "    const userWithAssociations = await User.findByPk(user.id, {\n\t      include: [\"skill\"],\n\t    });\n\t    expect(userWithAssociations?.name).toEqual(\"Justin\");\n\t    expect(userWithAssociations?.age).toEqual(32);\n\t    expect(userWithAssociations?.skill?.name).toEqual(\"Programming\");\n\t    const skill = await Skill.findByPk(userWithAssociations?.skill?.id, {\n\t      include: [\"user\"],\n\t    });\n\t    expect(skill?.user?.id).toEqual(user.id);\n", "    expect(skill?.user?.name).toEqual(\"Justin\");\n\t    expect(skill?.user?.age).toEqual(32);\n\t  });\n\t  it(\"Should create records associated through hasOne - id\", async () => {\n\t    const User = sequelize.define<SingleSkillUserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n", "      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n", "      { timestamps: false },\n\t    );\n\t    User.hasOne(Skill, {\n\t      as: \"skill\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n", "    await sequelize.sync();\n\t    const programming = await Skill.create({ name: \"Programming\" });\n\t    const user = await User.create({\n\t      name: \"Justin\",\n\t      age: 32,\n\t      skill: { id: programming.id },\n\t    });\n\t    const userWithAssociations = await User.findByPk(user.id, {\n\t      include: [\"skill\"],\n\t    });\n", "    expect(userWithAssociations?.name).toEqual(\"Justin\");\n\t    expect(userWithAssociations?.age).toEqual(32);\n\t    expect(userWithAssociations?.skill?.name).toEqual(\"Programming\");\n\t    const skill = await Skill.findByPk(userWithAssociations?.skill?.id, {\n\t      include: [\"user\"],\n\t    });\n\t    expect(skill?.user?.id).toEqual(user.id);\n\t    expect(skill?.user?.name).toEqual(\"Justin\");\n\t    expect(skill?.user?.age).toEqual(32);\n\t  });\n", "  it(\"Should create records associated through hasOne - inverse\", async () => {\n\t    const User = sequelize.define<SingleSkillUserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n", "    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.hasOne(Skill, {\n", "      as: \"skill\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n\t    const skill = await Skill.create({\n\t      name: \"Programming\",\n", "      user: {\n\t        name: \"Justin\",\n\t        age: 32,\n\t      },\n\t    });\n\t    const skillWithAssociations = await Skill.findByPk(skill.id, {\n\t      include: [\"user\"],\n\t    });\n\t    expect(skillWithAssociations?.user?.name).toEqual(\"Justin\");\n\t    expect(skillWithAssociations?.user?.age).toEqual(32);\n", "    const user = await User.findByPk(skillWithAssociations?.user?.id, {\n\t      include: [\"skill\"],\n\t    });\n\t    expect(user?.name).toEqual(\"Justin\");\n\t    expect(user?.age).toEqual(32);\n\t    expect(user?.skill?.id).toEqual(skill.id);\n\t    expect(user?.skill?.name).toEqual(\"Programming\");\n\t  });\n\t  it(\"Should throw with non-existing IDs through hasOne\", async () => {\n\t    const User = sequelize.define<SingleSkillUserModel>(\n", "      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n", "      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.hasOne(Skill, {\n\t      as: \"skill\",\n\t      foreignKey: \"userId\",\n", "    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n\t    await expect(\n\t      User.create({\n\t        name: \"Justin\",\n\t        age: 32,\n", "        skill: { id: -1 },\n\t      }),\n\t    ).rejects.toEqualErrors([\n\t      new NotFoundError({\n\t        detail: \"Payload must include an ID of an existing 'Skill'.\",\n\t        pointer: \"/data/relationships/skill/data/id\",\n\t      }),\n\t    ]);\n\t  });\n\t  it(\"Should create records associated through hasMany\", async () => {\n", "    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n", "      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.hasMany(Skill, {\n\t      as: \"skills\",\n", "      foreignKey: \"userId\",\n\t    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n\t    const cookingId = (await Skill.create({ name: \"Cooking\" })).id;\n\t    const user = await User.create({\n\t      name: \"Justin\",\n", "      age: 33,\n\t      skills: [{ name: \"Programming\" }, { id: cookingId }],\n\t    });\n\t    const userWithAssociations = await User.findByPk(user.id, {\n\t      include: \"skills\",\n\t    });\n\t    expect(userWithAssociations?.name).toEqual(\"Justin\");\n\t    expect(userWithAssociations?.age).toEqual(33);\n\t    expect(userWithAssociations?.skills).toHaveLength(2);\n\t    const programming = userWithAssociations?.skills?.find(\n", "      ({ name }) => name === \"Programming\",\n\t    );\n\t    const cooking = userWithAssociations?.skills?.find(\n\t      ({ name }) => name === \"Cooking\",\n\t    );\n\t    expect(programming).toBeTruthy();\n\t    expect(cooking).toBeTruthy();\n\t    const programmingWithUser = await Skill.findByPk(\n\t      userWithAssociations?.skills?.find(({ name }) => name === \"Programming\")\n\t        ?.id,\n", "      { include: [\"user\"] },\n\t    );\n\t    expect(programmingWithUser?.name).toEqual(\"Programming\");\n\t    expect(programmingWithUser?.user?.id).toEqual(user.id);\n\t    expect(programmingWithUser?.user?.name).toEqual(user.name);\n\t    expect(programmingWithUser?.user?.age).toEqual(user.age);\n\t    const cookingWithUser = await Skill.findByPk(\n\t      userWithAssociations?.skills?.find(({ name }) => name === \"Cooking\")?.id,\n\t      { include: [\"user\"] },\n\t    );\n", "    expect(cookingWithUser?.name).toEqual(\"Cooking\");\n\t    expect(cookingWithUser?.user?.id).toEqual(user.id);\n\t    expect(cookingWithUser?.user?.name).toEqual(user.name);\n\t    expect(cookingWithUser?.user?.age).toEqual(user.age);\n\t  });\n\t  it(\"Should create records associated through hasMany - inverse\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n", "        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n", "        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.hasMany(Skill, {\n\t      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    Skill.belongsTo(User, {\n\t      as: \"user\",\n", "      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n\t    const skill = await Skill.create({\n\t      name: \"Programming\",\n\t      user: {\n\t        name: \"Justin\",\n\t        age: 33,\n\t      },\n\t    });\n", "    const skillWithAssociations = await Skill.findByPk(skill.id, {\n\t      include: \"user\",\n\t    });\n\t    expect(skillWithAssociations?.name).toEqual(\"Programming\");\n\t    expect(skillWithAssociations?.user?.name).toEqual(\"Justin\");\n\t    expect(skillWithAssociations?.user?.age).toEqual(33);\n\t    const userWithAssociations = await User.findByPk(\n\t      skillWithAssociations?.user?.id,\n\t      {\n\t        include: [\"skills\"],\n", "      },\n\t    );\n\t    expect(userWithAssociations?.name).toEqual(\"Justin\");\n\t    expect(userWithAssociations?.age).toEqual(33);\n\t    expect(userWithAssociations?.skills).toHaveLength(1);\n\t    expect(userWithAssociations?.skills?.[0].name).toEqual(\"Programming\");\n\t  });\n\t  it(\"Should throw with non-existing IDs through hasMany\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n", "      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n", "        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        userId: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.hasMany(Skill, {\n\t      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t    });\n", "    Skill.belongsTo(User, {\n\t      as: \"user\",\n\t      foreignKey: \"userId\",\n\t    });\n\t    await sequelize.sync();\n\t    await expect(\n\t      User.create({\n\t        name: \"Justin\",\n\t        age: 33,\n\t        skills: [{ name: \"Programming\" }, { id: -1 }, { id: -2 }],\n", "      }),\n\t    ).rejects.toEqualErrors([\n\t      new NotFoundError({\n\t        detail: \"Payload must include an ID of an existing 'Skill'.\",\n\t        pointer: \"/data/relationships/skills/data/1/id\",\n\t      }),\n\t      new NotFoundError({\n\t        detail: \"Payload must include an ID of an existing 'Skill'.\",\n\t        pointer: \"/data/relationships/skills/data/2/id\",\n\t      }),\n", "    ]);\n\t  });\n\t  it(\"Should create table and records associated through belongsToMany\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n", "      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t      },\n\t      { timestamps: false },\n\t    );\n", "    const UserSkill = sequelize.define<UserSkillModel>(\n\t      \"UserSkill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        userId: DataTypes.INTEGER,\n\t        skillId: DataTypes.INTEGER,\n\t        selfGranted: DataTypes.BOOLEAN,\n\t      },\n\t      { timestamps: false },\n\t    );\n", "    User.belongsToMany(Skill, {\n\t      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t      through: UserSkill,\n\t    });\n\t    Skill.belongsToMany(User, {\n\t      as: \"users\",\n\t      foreignKey: \"skillId\",\n\t      through: UserSkill,\n\t    });\n", "    await sequelize.sync();\n\t    const user = await User.create({\n\t      name: \"Justin\",\n\t      age: 33,\n\t      skills: [\n\t        { name: \"Programming\" },\n\t        { name: \"Cooking\", through: { selfGranted: true } },\n\t      ],\n\t    });\n\t    const userWithAssociations = await User.findByPk(user.id, {\n", "      include: \"skills\",\n\t    });\n\t    expect(userWithAssociations?.name).toEqual(\"Justin\");\n\t    expect(userWithAssociations?.age).toEqual(33);\n\t    expect(userWithAssociations?.skills).toHaveLength(2);\n\t    const programming = userWithAssociations?.skills?.find(\n\t      ({ name }) => name === \"Programming\",\n\t    );\n\t    const cooking = userWithAssociations?.skills?.find(\n\t      ({ name }) => name === \"Cooking\",\n", "    );\n\t    expect(programming?.UserSkill?.selfGranted).toBeNull();\n\t    expect(cooking?.UserSkill?.selfGranted).toEqual(true);\n\t    const programmingWithUser = await Skill.findByPk(\n\t      userWithAssociations?.skills?.find(({ name }) => name === \"Programming\")\n\t        ?.id,\n\t      { include: [\"users\"] },\n\t    );\n\t    expect(programmingWithUser?.name).toEqual(\"Programming\");\n\t    expect(programmingWithUser?.users?.[0]?.id).toEqual(user.id);\n", "    expect(programmingWithUser?.users?.[0]?.name).toEqual(user.name);\n\t    expect(programmingWithUser?.users?.[0]?.age).toEqual(user.age);\n\t    expect(programmingWithUser?.users?.[0]?.UserSkill?.selfGranted).toBeNull();\n\t    const cookingWithUser = await Skill.findByPk(\n\t      userWithAssociations?.skills?.find(({ name }) => name === \"Cooking\")?.id,\n\t      { include: [\"users\"] },\n\t    );\n\t    expect(cookingWithUser?.name).toEqual(\"Cooking\");\n\t    expect(cookingWithUser?.users?.[0]?.id).toEqual(user.id);\n\t    expect(cookingWithUser?.users?.[0]?.name).toEqual(user.name);\n", "    expect(cookingWithUser?.users?.[0]?.age).toEqual(user.age);\n\t    expect(cookingWithUser?.users?.[0]?.UserSkill?.selfGranted).toEqual(true);\n\t  });\n\t  it(\"Should create table and records associated through belongsToMany - inverse\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n", "      },\n\t      { timestamps: false },\n\t    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t      },\n\t      { timestamps: false },\n", "    );\n\t    const UserSkill = sequelize.define<UserSkillModel>(\n\t      \"UserSkill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        userId: DataTypes.INTEGER,\n\t        skillId: DataTypes.INTEGER,\n\t        selfGranted: DataTypes.BOOLEAN,\n\t      },\n\t      { timestamps: false },\n", "    );\n\t    User.belongsToMany(Skill, {\n\t      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t      through: UserSkill,\n\t    });\n\t    Skill.belongsToMany(User, {\n\t      as: \"users\",\n\t      foreignKey: \"skillId\",\n\t      through: UserSkill,\n", "    });\n\t    await sequelize.sync();\n\t    await Skill.create({\n\t      name: \"Programming\",\n\t      users: [{ name: \"Justin\", age: 33 } as UserModel],\n\t    });\n\t    const userId = (\n\t      await User.findOne({\n\t        where: { name: \"Justin\", age: 33 },\n\t      })\n", "    )?.id;\n\t    await Skill.create({\n\t      name: \"Cooking\",\n\t      users: [\n\t        {\n\t          id: userId,\n\t          through: { selfGranted: true },\n\t        } as UserModel,\n\t      ],\n\t    });\n", "    const user = await User.findByPk(userId, {\n\t      include: \"skills\",\n\t    });\n\t    expect(user?.name).toEqual(\"Justin\");\n\t    expect(user?.age).toEqual(33);\n\t    expect(user?.skills).toHaveLength(2);\n\t    const programming = user?.skills?.find(\n\t      ({ name }) => name === \"Programming\",\n\t    );\n\t    const cooking = user?.skills?.find(({ name }) => name === \"Cooking\");\n", "    expect(programming?.UserSkill?.selfGranted).toBeNull();\n\t    expect(cooking?.UserSkill?.selfGranted).toEqual(true);\n\t    const programmingWithUser = await Skill.findByPk(\n\t      user?.skills?.find(({ name }) => name === \"Programming\")?.id,\n\t      { include: [\"users\"] },\n\t    );\n\t    expect(programmingWithUser?.name).toEqual(\"Programming\");\n\t    expect(programmingWithUser?.users?.[0]?.id).toEqual(userId);\n\t    expect(programmingWithUser?.users?.[0]?.name).toEqual(user?.name);\n\t    expect(programmingWithUser?.users?.[0]?.age).toEqual(user?.age);\n", "    expect(programmingWithUser?.users?.[0]?.UserSkill?.selfGranted).toBeNull();\n\t    const cookingWithUser = await Skill.findByPk(\n\t      user?.skills?.find(({ name }) => name === \"Cooking\")?.id,\n\t      { include: [\"users\"] },\n\t    );\n\t    expect(cookingWithUser?.name).toEqual(\"Cooking\");\n\t    expect(cookingWithUser?.users?.[0]?.id).toEqual(userId);\n\t    expect(cookingWithUser?.users?.[0]?.name).toEqual(user?.name);\n\t    expect(cookingWithUser?.users?.[0]?.age).toEqual(user?.age);\n\t    expect(cookingWithUser?.users?.[0]?.UserSkill?.selfGranted).toEqual(true);\n", "  });\n\t  it(\"Should throw with non-existing IDs through belongsToMany\", async () => {\n\t    const User = sequelize.define<UserModel>(\n\t      \"User\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t        age: DataTypes.INTEGER,\n\t      },\n\t      { timestamps: false },\n", "    );\n\t    const Skill = sequelize.define<SkillModel>(\n\t      \"Skill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        name: DataTypes.STRING,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    const UserSkill = sequelize.define<UserSkillModel>(\n", "      \"UserSkill\",\n\t      {\n\t        id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },\n\t        userId: DataTypes.INTEGER,\n\t        skillId: DataTypes.INTEGER,\n\t        selfGranted: DataTypes.BOOLEAN,\n\t      },\n\t      { timestamps: false },\n\t    );\n\t    User.belongsToMany(Skill, {\n", "      as: \"skills\",\n\t      foreignKey: \"userId\",\n\t      through: UserSkill,\n\t    });\n\t    Skill.belongsToMany(User, {\n\t      as: \"users\",\n\t      foreignKey: \"skillId\",\n\t      through: UserSkill,\n\t    });\n\t    await sequelize.sync();\n", "    await expect(\n\t      User.create({\n\t        name: \"Justin\",\n\t        age: 33,\n\t        skills: [\n\t          { name: \"Programming\" },\n\t          { id: -1, through: { selfGranted: true } },\n\t          { id: -2, through: { selfGranted: false } },\n\t        ],\n\t      }),\n", "    ).rejects.toEqualErrors([\n\t      new NotFoundError({\n\t        detail: \"Payload must include an ID of an existing 'Skill'.\",\n\t        pointer: \"/data/relationships/skills/data/1/id\",\n\t      }),\n\t      new NotFoundError({\n\t        detail: \"Payload must include an ID of an existing 'Skill'.\",\n\t        pointer: \"/data/relationships/skills/data/2/id\",\n\t      }),\n\t    ]);\n", "  });\n\t});\n"]}
{"filename": "src/index.ts", "chunked_list": ["export { extendSequelize } from \"./sequelize/extended\";\n"]}
{"filename": "src/sequelize/extended.ts", "chunked_list": ["import type {\n\t  Model,\n\t  CreateOptions,\n\t  Attributes,\n\t  UpdateOptions,\n\t} from \"sequelize\";\n\timport type {\n\t  Col,\n\t  Fn,\n\t  Literal,\n", "  MakeNullishOptional,\n\t} from \"sequelize/types/utils\";\n\timport {\n\t  getValidAttributesAndAssociations,\n\t  handleBulkCreateAssociations,\n\t  handleCreateAssociations,\n\t  handleUpdateAssociations,\n\t} from \"./associations\";\n\timport { UnexpectedValueError } from \"./types\";\n\timport type { IAssociation } from \"./types\";\n", "type AssociationLookup = Record<string, Record<string, IAssociation>>;\n\tlet associationsLookup: AssociationLookup;\n\tfunction calculateAssociationProp(associations) {\n\t  const result = {};\n\t  Object.keys(associations).forEach((key) => {\n\t    const association = {};\n\t    let propertyName;\n\t    if (associations[key].hasOwnProperty(\"options\")) {\n\t      const { associationType, target, foreignKey, throughModel } =\n\t        associations[key];\n", "      propertyName = key.toLocaleLowerCase();\n\t      association[propertyName] = {\n\t        type: associationType,\n\t        key: foreignKey,\n\t        model: target.name,\n\t        joinTable: throughModel,\n\t      };\n\t    }\n\t    result[propertyName] = association[propertyName];\n\t  });\n", "  return result;\n\t}\n\texport function getLookup(sequelize): AssociationLookup {\n\t  //TODO: Fix associations lookup being static\n\t  /*  if (!associationsLookup) { */\n\t  const lookup: any = {};\n\t  const models = sequelize.models;\n\t  const modelKeys = Object.keys(models);\n\t  modelKeys.forEach((key) => {\n\t    const associations = calculateAssociationProp(models[key].associations);\n", "    lookup[key] = associations;\n\t  });\n\t  associationsLookup = lookup;\n\t  return associationsLookup;\n\t}\n\texport const extendSequelize = (SequelizeClass: any) => {\n\t  const origCreate = SequelizeClass.Model.create;\n\t  const origUpdate = SequelizeClass.Model.update;\n\t  const origBulkCreate = SequelizeClass.Model.bulkCreate;\n\t  SequelizeClass.Model.create = async function <\n", "    M extends Model,\n\t    O extends CreateOptions<Attributes<M>> = CreateOptions<Attributes<M>>,\n\t  >(\n\t    attributes: MakeNullishOptional<M[\"_creationAttributes\"]> | undefined,\n\t    options?: O,\n\t  ) {\n\t    const { sequelize } = this.options;\n\t    const associations = getLookup(sequelize)[this.name];\n\t    const modelPrimaryKey = this.primaryKeyAttribute;\n\t    let modelData:\n", "      | undefined\n\t      | (O extends { returning: false } | { ignoreDuplicates: true }\n\t          ? void\n\t          : M);\n\t    const { externalAssociations, currentModelAttributes } =\n\t      getValidAttributesAndAssociations(attributes, associations);\n\t    // If there are no associations, create the model with all attributes.\n\t    if (!externalAssociations.length) {\n\t      return origCreate.apply(this, [attributes, options]);\n\t    }\n", "    const transaction =\n\t      options?.transaction ?? (await this.sequelize.transaction());\n\t    try {\n\t      // create the model first if it does not exist\n\t      if (!modelData) {\n\t        modelData = await origCreate.apply(this, [\n\t          currentModelAttributes,\n\t          { transaction },\n\t        ]);\n\t      }\n", "      await handleCreateAssociations(\n\t        this.sequelize,\n\t        this,\n\t        externalAssociations,\n\t        associations as Record<string, IAssociation>,\n\t        attributes,\n\t        transaction,\n\t        modelData?.[modelPrimaryKey],\n\t        modelPrimaryKey,\n\t      );\n", "      !options?.transaction && (await transaction.commit());\n\t    } catch (error) {\n\t      !options?.transaction && (await transaction.rollback());\n\t      throw error;\n\t    }\n\t    return modelData;\n\t  };\n\t  SequelizeClass.Model.bulkCreate = async function <\n\t    M extends Model,\n\t    O extends CreateOptions<Attributes<M>> = CreateOptions<Attributes<M>>,\n", "  >(\n\t    attributes: Array<MakeNullishOptional<M[\"_creationAttributes\"]>>,\n\t    options?: O,\n\t  ) {\n\t    const { sequelize } = this.options;\n\t    const associations = getLookup(sequelize)[this.name];\n\t    const modelPrimaryKey = this.primaryKeyAttribute;\n\t    let modelData:\n\t      | undefined\n\t      | Array<\n", "          O extends { returning: false } | { ignoreDuplicates: true } ? void : M\n\t        >;\n\t    const {\n\t      otherAssociationAttributes,\n\t      externalAssociations,\n\t      currentModelAttributes,\n\t    } = getValidAttributesAndAssociations(attributes, associations);\n\t    // If there are no associations, create the model with all attributes.\n\t    if (!externalAssociations.length) {\n\t      return origBulkCreate.apply(this, [attributes, options]);\n", "    }\n\t    const transaction =\n\t      options?.transaction ?? (await this.sequelize.transaction());\n\t    try {\n\t      // create the model first if it does not exist\n\t      if (!modelData) {\n\t        modelData = await origBulkCreate.apply(this, [\n\t          currentModelAttributes,\n\t          { transaction },\n\t        ]);\n", "      }\n\t      const modelIds = modelData?.map((data) =>\n\t        data.getDataValue(modelPrimaryKey),\n\t      ) as string[];\n\t      await handleBulkCreateAssociations(\n\t        this.sequelize,\n\t        this,\n\t        externalAssociations,\n\t        associations as Record<string, IAssociation>,\n\t        otherAssociationAttributes,\n", "        transaction,\n\t        modelIds,\n\t        modelPrimaryKey,\n\t      );\n\t      !options?.transaction && (await transaction.commit());\n\t    } catch (error) {\n\t      !options?.transaction && (await transaction.rollback());\n\t      throw error;\n\t    }\n\t    return modelData;\n", "  };\n\t  SequelizeClass.Model.update = async function <M extends Model<any, any>>(\n\t    attributes: {\n\t      [key in keyof Attributes<M>]?:\n\t        | Fn\n\t        | Col\n\t        | Literal\n\t        | Attributes<M>[key]\n\t        | undefined;\n\t    },\n", "    ops: Omit<UpdateOptions<Attributes<M>>, \"returning\"> & {\n\t      returning: Exclude<\n\t        UpdateOptions<Attributes<M>>[\"returning\"],\n\t        undefined | false\n\t      >;\n\t    },\n\t  ) {\n\t    const { sequelize } = this.options;\n\t    const associations = getLookup(sequelize)[this.name];\n\t    const modelPrimaryKey = this.primaryKeyAttribute;\n", "    const modelId = ops.where?.[modelPrimaryKey];\n\t    let modelUpdateData: [affectedCount: number, affectedRows: M[]] | undefined;\n\t    const { externalAssociations, currentModelAttributes } =\n\t      getValidAttributesAndAssociations(attributes, associations);\n\t    // If there are no associations, create the model with all attributes.\n\t    if (!externalAssociations.length) {\n\t      return origUpdate.apply(this, [attributes, ops]);\n\t    } else if (!modelId) {\n\t      throw [\n\t        new UnexpectedValueError({\n", "          detail: \"Only updating by the primary key is supported\",\n\t        }),\n\t      ];\n\t    }\n\t    const transaction = await this.sequelize.transaction();\n\t    try {\n\t      if (!modelUpdateData) {\n\t        modelUpdateData = await origUpdate.apply(this, [\n\t          currentModelAttributes,\n\t          {\n", "            ...ops,\n\t            transaction,\n\t          },\n\t        ]);\n\t      }\n\t      await handleUpdateAssociations(\n\t        this.sequelize,\n\t        this,\n\t        externalAssociations,\n\t        associations as Record<string, IAssociation>,\n", "        attributes,\n\t        transaction,\n\t        modelId,\n\t        modelPrimaryKey,\n\t      );\n\t      !ops?.transaction && (await transaction.commit());\n\t    } catch (error) {\n\t      !ops?.transaction && (await transaction.rollback());\n\t      throw error;\n\t    }\n", "    return modelUpdateData;\n\t  };\n\t};\n"]}
{"filename": "src/sequelize/constants.ts", "chunked_list": ["export enum codes {\n\t  ERR_NOT_FOUND = \"not-found\",\n\t  ERR_SERVER_ERROR = \"server-error\",\n\t  ERR_UNEXPECTED_VALUE = \"unexpected-value\",\n\t}\n\texport enum statusCodes {\n\t  BAD_REQUEST = 400,\n\t  NOT_FOUND = 404,\n\t  INTERNAL_SERVER_ERROR = 500,\n\t}\n"]}
{"filename": "src/sequelize/associations/sequelize.post.ts", "chunked_list": ["import type { Sequelize, Transaction } from \"sequelize\";\n\timport { NotFoundError } from \"../types\";\n\timport type { IAssociationBody, JSONAnyObject } from \"../types\";\n\timport { pluralize } from \"inflection\";\n\texport const handleCreateHasOne = async (\n\t  sequelize: Sequelize,\n\t  association: IAssociationBody<JSONAnyObject>,\n\t  model: { name: string; id: string },\n\t  transaction: Transaction,\n\t  primaryKey = \"id\",\n", "): Promise<void> => {\n\t  const modelName = association.details.model;\n\t  const modelInstance = await sequelize.models[model.name].findByPk(\n\t    model[primaryKey],\n\t    {\n\t      transaction,\n\t    },\n\t  );\n\t  if (!modelInstance) {\n\t    throw [new Error(\"Unable to find created model\")];\n", "  }\n\t  let joinId: string | undefined;\n\t  const isCreate = !association.attributes[primaryKey];\n\t  if (isCreate) {\n\t    const model = await sequelize.models[modelName].create(\n\t      association.attributes,\n\t      {\n\t        transaction,\n\t      },\n\t    );\n", "    joinId = model[primaryKey];\n\t  } else {\n\t    joinId = association.attributes[primaryKey];\n\t    if (!(await sequelize.models[modelName].findByPk(joinId))) {\n\t      throw [\n\t        new NotFoundError({\n\t          detail: `Payload must include an ID of an existing '${modelName}'.`,\n\t          pointer: `/data/relationships/${modelName.toLowerCase()}/data/id`,\n\t        }),\n\t      ];\n", "    }\n\t  }\n\t  await modelInstance[`set${modelName}`](joinId, {\n\t    transaction,\n\t  });\n\t};\n\texport const handleBulkCreateHasOne = async (\n\t  sequelize: Sequelize,\n\t  association: IAssociationBody<JSONAnyObject[]>,\n\t  model: { name: string; id: string[] },\n", "  transaction: Transaction,\n\t  primaryKey = \"id\",\n\t): Promise<void> => {\n\t  const modelInstances = await sequelize.models[model.name].findAll({\n\t    where: {\n\t      [primaryKey]: model.id,\n\t    },\n\t    transaction,\n\t  });\n\t  if (modelInstances.length !== model.id.length) {\n", "    throw [new Error(\"Not all models were successfully created\")];\n\t  }\n\t  const modelName = association.details.model;\n\t  await Promise.all(\n\t    association.attributes.map(async (attribute, index) => {\n\t      const isCreate = !attribute[primaryKey];\n\t      if (isCreate) {\n\t        const id = (\n\t          await sequelize.models[modelName].create(attribute, {\n\t            transaction,\n", "          })\n\t        )\n\t          .getDataValue(primaryKey)\n\t          .toString();\n\t        return modelInstances[index][`set${modelName}`](id, {\n\t          transaction,\n\t        });\n\t      }\n\t      if (\n\t        !(await sequelize.models[modelName].findByPk(attribute[primaryKey]))\n", "      ) {\n\t        throw [\n\t          new NotFoundError({\n\t            detail: `Payload must include an ID of an existing '${modelName}'.`,\n\t            pointer: `/data/${index}/relationships/${modelName.toLowerCase()}/data/id`,\n\t          }),\n\t        ];\n\t      }\n\t      return modelInstances[index][`set${modelName}`](attribute[primaryKey], {\n\t        transaction,\n", "      });\n\t    }),\n\t  );\n\t};\n\texport const handleCreateMany = async (\n\t  sequelize: Sequelize,\n\t  association: IAssociationBody<JSONAnyObject[]>,\n\t  model: { name: string; id: string },\n\t  transaction: Transaction,\n\t  primaryKey = \"id\",\n", "): Promise<void> => {\n\t  const modelInstance = await sequelize.models[model.name].findByPk(\n\t    model[primaryKey],\n\t    {\n\t      transaction,\n\t    },\n\t  );\n\t  if (!modelInstance) {\n\t    throw [new Error(\"Unable to find created model\")];\n\t  }\n", "  const modelName = association.details.model;\n\t  const results = await Promise.allSettled(\n\t    association.attributes.map(async (attribute, index) => {\n\t      const isCreate = !attribute[primaryKey];\n\t      if (isCreate) {\n\t        const id = (\n\t          await sequelize.models[association.details.model].create(\n\t            { ...attribute, through: undefined },\n\t            { transaction },\n\t          )\n", "        )\n\t          .getDataValue(primaryKey)\n\t          .toString();\n\t        return modelInstance[`add${modelName}`](id, {\n\t          through: attribute.through,\n\t          transaction,\n\t        });\n\t      }\n\t      if (\n\t        !(await sequelize.models[modelName].findByPk(attribute[primaryKey]))\n", "      ) {\n\t        throw new NotFoundError({\n\t          detail: `Payload must include an ID of an existing '${modelName}'.`,\n\t          pointer: `/data/relationships/${pluralize(\n\t            modelName.toLowerCase(),\n\t          )}/data/${index}/id`,\n\t        });\n\t      }\n\t      return modelInstance[`add${modelName}`](attribute[primaryKey], {\n\t        through: attribute.through,\n", "        transaction,\n\t      });\n\t    }),\n\t  );\n\t  const errors = results.reduce(\n\t    (acc, result) =>\n\t      result.status === \"fulfilled\" ? acc : [...acc, result.reason],\n\t    [],\n\t  );\n\t  if (errors.length) throw errors;\n", "};\n\texport const handleBulkCreateMany = async (\n\t  sequelize: Sequelize,\n\t  association: IAssociationBody<JSONAnyObject[][]>,\n\t  model: { name: string; id: string[] },\n\t  transaction: Transaction,\n\t  primaryKey = \"id\",\n\t): Promise<void> => {\n\t  // Create an instance of the model using the id\n\t  const modelInstances = await sequelize.models[model.name].findAll({\n", "    where: {\n\t      [primaryKey]: model.id,\n\t    },\n\t    transaction,\n\t  });\n\t  if (modelInstances.length !== model.id.length) {\n\t    throw [new Error(\"Not all models were successfully created\")];\n\t  }\n\t  const modelName = association.details.model;\n\t  const results = await Promise.all(\n", "    association.attributes.map(async (attributes, index) => {\n\t      return Promise.allSettled(\n\t        attributes.map(async (attribute, index2) => {\n\t          const isCreate = !attribute[primaryKey];\n\t          if (isCreate) {\n\t            // Create the models first and add their ids to the joinIds.\n\t            const id = (\n\t              await sequelize.models[modelName].create(\n\t                { ...attribute, through: undefined },\n\t                { transaction },\n", "              )\n\t            )\n\t              .getDataValue(primaryKey)\n\t              .toString();\n\t            return modelInstances[index][`add${modelName}`](id, {\n\t              through: attribute.through,\n\t              transaction,\n\t            });\n\t          }\n\t          if (\n", "            !(await sequelize.models[modelName].findByPk(attribute[primaryKey]))\n\t          ) {\n\t            throw new NotFoundError({\n\t              detail: `Payload must include an ID of an existing '${modelName}'.`,\n\t              pointer: `/data/${index}/relationships/${pluralize(\n\t                modelName.toLowerCase(),\n\t              )}/data/${index2}/id`,\n\t            });\n\t          }\n\t          return modelInstances[index][`add${modelName}`](\n", "            attribute[primaryKey],\n\t            {\n\t              through: attribute.through,\n\t              transaction,\n\t            },\n\t          );\n\t        }),\n\t      );\n\t    }),\n\t  );\n", "  const errors = results\n\t    .flat()\n\t    .reduce(\n\t      (acc, result) =>\n\t        result.status === \"fulfilled\" ? acc : [...acc, result.reason],\n\t      [],\n\t    );\n\t  if (errors.length) throw errors;\n\t};\n"]}
{"filename": "src/sequelize/associations/sequelize.patch.ts", "chunked_list": ["import { pluralize } from \"inflection\";\n\timport { Op } from \"sequelize\";\n\timport type { Sequelize, Transaction } from \"sequelize\";\n\timport { NotFoundError } from \"../types\";\n\timport type { IAssociationBody } from \"../types\";\n\texport const handleUpdateOne = async (\n\t  sequelize: Sequelize,\n\t  association: IAssociationBody<Array<Record<string, any>>>,\n\t  model: { name: string; id: string },\n\t  transaction: Transaction,\n", "  primaryKey = \"id\",\n\t): Promise<void> => {\n\t  const modelName = association.details.model;\n\t  const associatedId = association.attributes?.[primaryKey] || null;\n\t  const [modelInstance, associatedInstance] = await Promise.all([\n\t    sequelize.models[model.name].findByPk(model[primaryKey], {\n\t      transaction,\n\t    }),\n\t    associatedId\n\t      ? sequelize.models[modelName].findByPk(associatedId, {\n", "          transaction,\n\t        })\n\t      : null,\n\t  ]);\n\t  if (!modelInstance) {\n\t    throw [new Error(\"Unable to find created model\")];\n\t  }\n\t  if (associatedId && !associatedInstance) {\n\t    throw [\n\t      new NotFoundError({\n", "        detail: `Payload must include an ID of an existing '${modelName}'.`,\n\t        pointer: `/data/relationships/${modelName.toLowerCase()}/data/id`,\n\t      }),\n\t    ];\n\t  }\n\t  await modelInstance[`set${modelName}`](associatedId, {\n\t    transaction,\n\t  });\n\t};\n\texport const handleUpdateMany = async (\n", "  sequelize: Sequelize,\n\t  association: IAssociationBody<Array<Record<string, any>>>,\n\t  model: { name: string; id: string },\n\t  transaction: Transaction,\n\t  primaryKey = \"id\",\n\t): Promise<void> => {\n\t  const modelName = association.details.model;\n\t  const associatedIds = association.attributes.map((data) => data[primaryKey]);\n\t  const [modelInstance, associatedInstances] = await Promise.all([\n\t    sequelize.models[model.name].findByPk(model[primaryKey], {\n", "      transaction,\n\t    }),\n\t    associatedIds.length\n\t      ? sequelize.models[modelName].findAll({\n\t          where: { id: { [Op.in]: associatedIds } },\n\t          transaction,\n\t        })\n\t      : [],\n\t  ]);\n\t  if (!modelInstance) return;\n", "  if (\n\t    associatedIds.length &&\n\t    associatedInstances.length < associatedIds.length\n\t  ) {\n\t    throw associatedIds.reduce(\n\t      (acc, associatedId, index) =>\n\t        associatedInstances.some(\n\t          ({ dataValues: { id } }) => id === associatedId,\n\t        )\n\t          ? acc\n", "          : [\n\t              ...acc,\n\t              new NotFoundError({\n\t                detail: `Payload must include an ID of an existing '${modelName}'.`,\n\t                pointer: `/data/relationships/${pluralize(\n\t                  modelName.toLowerCase(),\n\t                )}/data/${index}/id`,\n\t              }),\n\t            ],\n\t      [],\n", "    );\n\t  }\n\t  await modelInstance[`set${pluralize(association.details.model)}`](\n\t    association.attributes.map((data) => data[primaryKey]),\n\t    {\n\t      transaction,\n\t    },\n\t  );\n\t};\n"]}
{"filename": "src/sequelize/associations/index.ts", "chunked_list": ["import type {\n\t  Attributes,\n\t  ModelStatic,\n\t  Sequelize,\n\t  Transaction,\n\t} from \"sequelize\";\n\timport type { IAssociation, JSONAnyObject } from \"../types\";\n\timport { handleUpdateMany, handleUpdateOne } from \"./sequelize.patch\";\n\timport {\n\t  handleBulkCreateHasOne,\n", "  handleBulkCreateMany,\n\t  handleCreateHasOne,\n\t  handleCreateMany,\n\t} from \"./sequelize.post\";\n\texport const getValidAttributesAndAssociations = (\n\t  attributes: Attributes<any> | Array<Attributes<any>>,\n\t  associations: Record<string, IAssociation> | undefined,\n\t) => {\n\t  const externalAssociations: string[] = [];\n\t  let currentModelAttributes = attributes;\n", "  const otherAssociationAttributes: JSONAnyObject = {};\n\t  if (associations) {\n\t    const associationsKeys = Object.keys(associations);\n\t    const attributeKeys = Array.isArray(currentModelAttributes)\n\t      ? Object.keys(attributes[0])\n\t      : Object.keys(attributes);\n\t    // GET ALL ASSOCIATION ATTRIBUTES AND SEPARATE THEM FROM DATA LEFT\n\t    associationsKeys.forEach((association) => {\n\t      if (attributeKeys.includes(association)) {\n\t        let data: any;\n", "        if (Array.isArray(currentModelAttributes)) {\n\t          data = currentModelAttributes.map((attribute: any) => {\n\t            const { [association]: _, ...attributesleft } = attribute;\n\t            const otherAttr = otherAssociationAttributes[association] ?? [];\n\t            otherAssociationAttributes[association] = [...otherAttr, _];\n\t            return attributesleft;\n\t          });\n\t        } else {\n\t          const { [association]: _, ...attributesLeft } =\n\t            currentModelAttributes;\n", "          data = attributesLeft;\n\t        }\n\t        currentModelAttributes = data;\n\t        externalAssociations.push(association);\n\t      }\n\t    });\n\t  }\n\t  return {\n\t    otherAssociationAttributes,\n\t    externalAssociations,\n", "    currentModelAttributes,\n\t  };\n\t};\n\texport const handleCreateAssociations = async (\n\t  sequelize: Sequelize,\n\t  model: ModelStatic<any>,\n\t  validAssociations: string[],\n\t  associations: Record<string, IAssociation>,\n\t  attributes: Attributes<any>,\n\t  transaction: Transaction,\n", "  modelId: string,\n\t  primaryKey = \"id\",\n\t): Promise<void> => {\n\t  for (const association of validAssociations) {\n\t    const associationDetails = associations[association];\n\t    const associationAttribute = attributes[association];\n\t    switch (associationDetails.type) {\n\t      case \"BelongsTo\":\n\t      case \"HasOne\":\n\t        await handleCreateHasOne(\n", "          sequelize,\n\t          {\n\t            details: associationDetails,\n\t            attributes: associationAttribute,\n\t          },\n\t          { name: model.name, id: modelId },\n\t          transaction,\n\t          primaryKey,\n\t        );\n\t        break;\n", "      case \"BelongsToMany\":\n\t      case \"HasMany\":\n\t        await handleCreateMany(\n\t          sequelize,\n\t          {\n\t            details: associationDetails,\n\t            attributes: associationAttribute,\n\t          },\n\t          { name: model.name, id: modelId },\n\t          transaction,\n", "          primaryKey,\n\t        );\n\t        break;\n\t      default:\n\t        break;\n\t    }\n\t  }\n\t};\n\texport const handleBulkCreateAssociations = async (\n\t  sequelize: Sequelize,\n", "  model: ModelStatic<any>,\n\t  validAssociations: string[],\n\t  associations: Record<string, IAssociation>,\n\t  attributes: JSONAnyObject,\n\t  transaction: Transaction,\n\t  modelIds: string[],\n\t  primaryKey = \"id\",\n\t): Promise<void> => {\n\t  for (const association of validAssociations) {\n\t    const associationDetails = associations[association];\n", "    const associationAttribute = attributes[association];\n\t    switch (associationDetails.type) {\n\t      case \"BelongsTo\":\n\t      case \"HasOne\":\n\t        await handleBulkCreateHasOne(\n\t          sequelize,\n\t          {\n\t            details: associationDetails,\n\t            attributes: associationAttribute,\n\t          },\n", "          { name: model.name, id: modelIds },\n\t          transaction,\n\t          primaryKey,\n\t        );\n\t        break;\n\t      case \"BelongsToMany\":\n\t      case \"HasMany\":\n\t        await handleBulkCreateMany(\n\t          sequelize,\n\t          {\n", "            details: associationDetails,\n\t            attributes: associationAttribute,\n\t          },\n\t          { name: model.name, id: modelIds },\n\t          transaction,\n\t          primaryKey,\n\t        );\n\t        break;\n\t      default:\n\t        break;\n", "    }\n\t  }\n\t};\n\texport const handleUpdateAssociations = async (\n\t  sequelize: Sequelize,\n\t  model: ModelStatic<any>,\n\t  validAssociations: string[],\n\t  associations: Record<string, IAssociation>,\n\t  attributes: Attributes<any>,\n\t  transaction: Transaction,\n", "  modelId: string,\n\t  primaryKey = \"id\",\n\t): Promise<void> => {\n\t  for (const association of validAssociations) {\n\t    const associationDetails = associations[association];\n\t    const associationAttribute = attributes[association];\n\t    switch (associationDetails.type) {\n\t      case \"BelongsTo\":\n\t      case \"HasOne\":\n\t        await handleUpdateOne(\n", "          sequelize,\n\t          {\n\t            details: associationDetails,\n\t            attributes: associationAttribute,\n\t          },\n\t          {\n\t            name: model.name,\n\t            id: modelId,\n\t          },\n\t          transaction,\n", "          primaryKey,\n\t        );\n\t        break;\n\t      case \"HasMany\":\n\t      case \"BelongsToMany\":\n\t        await handleUpdateMany(\n\t          sequelize,\n\t          {\n\t            details: associationDetails,\n\t            attributes: associationAttribute,\n", "          },\n\t          {\n\t            name: model.name,\n\t            id: modelId,\n\t          },\n\t          transaction,\n\t          primaryKey,\n\t        );\n\t        break;\n\t      default:\n", "        break;\n\t    }\n\t  }\n\t};\n"]}
{"filename": "src/sequelize/types/HatchifyError.ts", "chunked_list": ["import { codes, statusCodes } from \"../constants\";\n\tinterface Source {\n\t  pointer?: string;\n\t  parameter?: string;\n\t}\n\texport interface HatchifyErrorOptions {\n\t  pointer?: string;\n\t  status: number;\n\t  code: string;\n\t  detail?: string;\n", "  source?: Source;\n\t  title?: string;\n\t}\n\texport class HatchifyError extends Error {\n\t  status: number;\n\t  code: string;\n\t  title?: string;\n\t  detail?: string;\n\t  source?: Source;\n\t  constructor({\n", "    status = statusCodes.INTERNAL_SERVER_ERROR,\n\t    code = codes.ERR_SERVER_ERROR,\n\t    title = \"Server Error ocurred\",\n\t    detail,\n\t    pointer,\n\t  }: HatchifyErrorOptions) {\n\t    super();\n\t    this.status = status;\n\t    this.code = code;\n\t    this.title = title;\n", "    this.detail = detail;\n\t    if (pointer) {\n\t      this.source = { pointer };\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/sequelize/types/NotFoundError.ts", "chunked_list": ["import { codes, statusCodes } from \"../constants\";\n\timport { HatchifyError } from \"./HatchifyError\";\n\timport type { HatchifyErrorOptions } from \"./HatchifyError\";\n\texport class NotFoundError extends HatchifyError {\n\t  constructor({\n\t    detail,\n\t    pointer,\n\t  }: Pick<HatchifyErrorOptions, \"detail\" | \"pointer\">) {\n\t    super({\n\t      code: codes.ERR_NOT_FOUND,\n", "      status: statusCodes.NOT_FOUND,\n\t      title: \"Resource not found.\",\n\t      detail,\n\t      pointer,\n\t    });\n\t  }\n\t}\n"]}
{"filename": "src/sequelize/types/JSONAnyObject.ts", "chunked_list": ["export type JSONAnyObject = Record<string, any>;\n"]}
{"filename": "src/sequelize/types/IAssociation.ts", "chunked_list": ["export interface IAssociation {\n\t  type: string;\n\t  key: string;\n\t  model: string;\n\t  joinTable?: string;\n\t}\n"]}
{"filename": "src/sequelize/types/index.ts", "chunked_list": ["export * from \"./HatchifyError\";\n\texport * from \"./IAssociation\";\n\texport * from \"./IAssociationBody\";\n\texport * from \"./JSONAnyObject\";\n\texport * from \"./NotFoundError\";\n\texport * from \"./UnexpectedValueError\";\n"]}
{"filename": "src/sequelize/types/IAssociationBody.ts", "chunked_list": ["import type { IAssociation } from \"./IAssociation\";\n\texport interface IAssociationBody<T> {\n\t  attributes: T;\n\t  details: IAssociation;\n\t}\n"]}
{"filename": "src/sequelize/types/UnexpectedValueError.ts", "chunked_list": ["import { codes, statusCodes } from \"../constants\";\n\timport { HatchifyError } from \"./HatchifyError\";\n\timport type { HatchifyErrorOptions } from \"./HatchifyError\";\n\texport class UnexpectedValueError extends HatchifyError {\n\t  constructor({ detail }: Pick<HatchifyErrorOptions, \"detail\">) {\n\t    super({\n\t      code: codes.ERR_UNEXPECTED_VALUE,\n\t      status: statusCodes.BAD_REQUEST,\n\t      title: \"Unexpected Value.\",\n\t      detail,\n", "    });\n\t  }\n\t}\n"]}
