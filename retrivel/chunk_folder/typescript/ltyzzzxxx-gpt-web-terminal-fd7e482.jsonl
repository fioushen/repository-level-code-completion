{"filename": "components.d.ts", "chunked_list": ["// generated by unplugin-vue-components\n\t// We suggest you to commit this file into source control\n\t// Read more: https://github.com/vuejs/core/pull/3399\n\timport '@vue/runtime-core'\n\texport {}\n\tdeclare module '@vue/runtime-core' {\n\t  export interface GlobalComponents {\n\t    ACol: typeof import('ant-design-vue/es')['Col']\n\t    ACollapse: typeof import('ant-design-vue/es')['Collapse']\n\t    ACollapsePanel: typeof import('ant-design-vue/es')['CollapsePanel']\n", "    AInput: typeof import('ant-design-vue/es')['Input']\n\t    ARow: typeof import('ant-design-vue/es')['Row']\n\t    ATag: typeof import('ant-design-vue/es')['Tag']\n\t    ContentOutput: typeof import('./src/components/gpt-terminal/ContentOutput.vue')['default']\n\t    GptTerminal: typeof import('./src/components/gpt-terminal/GptTerminal.vue')['default']\n\t    RouterLink: typeof import('vue-router')['RouterLink']\n\t    RouterView: typeof import('vue-router')['RouterView']\n\t  }\n\t}\n"]}
{"filename": "vite.config.ts", "chunked_list": ["import { defineConfig, loadEnv } from \"vite\";\n\timport vue from \"@vitejs/plugin-vue\";\n\t// @ts-ignore\n\timport Components from \"unplugin-vue-components/vite\";\n\t// @ts-ignore\n\timport { AntDesignVueResolver } from \"unplugin-vue-components/resolvers\";\n\t// https://vitejs.dev/config/\n\texport default defineConfig((env) => {\n\t  const viteEnv = loadEnv(env.mode, process.cwd())\n\t  return {\n", "    plugins: [\n\t      vue(),\n\t      // 按需加载 ant-design-vue\n\t      Components({\n\t        resolvers: [AntDesignVueResolver()],\n\t      }),\n\t    ].filter(Boolean),\n\t    server: {\n\t      host: '0.0.0.0',\n\t      port: 3001,\n", "      open: false,\n\t      proxy: {\n\t        '/api': {\n\t          target: viteEnv.VITE_APP_API_BASE_URL,\n\t          changeOrigin: true, // 允许跨域\n\t          rewrite: path => path.replace('/api/', '/'),\n\t        },\n\t      },\n\t    },\n\t  };\n", "});"]}
{"filename": "service/tsup.config.ts", "chunked_list": ["import { defineConfig } from 'tsup'\n\texport default defineConfig({\n\t  entry: ['src/index.ts'],\n\t  outDir: 'build',\n\t  target: 'es2020',\n\t  format: ['esm'],\n\t  splitting: false,\n\t  sourcemap: true,\n\t  minify: false,\n\t  shims: true,\n", "  dts: false,\n\t})\n"]}
{"filename": "service/src/types.ts", "chunked_list": ["import type { FetchFn } from 'chatgpt'\n\texport interface RequestProps {\n\t  prompt: string\n\t  options?: ChatContext\n\t  systemMessage: string\n\t  temperature?: number\n\t  top_p?: number\n\t}\n\texport interface ChatContext {\n\t  conversationId?: string\n", "  parentMessageId?: string\n\t}\n\texport interface ChatGPTUnofficialProxyAPIOptions {\n\t  accessToken: string\n\t  apiReverseProxyUrl?: string\n\t  model?: string\n\t  debug?: boolean\n\t  headers?: Record<string, string>\n\t  fetch?: FetchFn\n\t}\n", "export interface ModelConfig {\n\t  apiModel?: ApiModel\n\t  reverseProxy?: string\n\t  timeoutMs?: number\n\t  socksProxy?: string\n\t  httpsProxy?: string\n\t  usage?: string\n\t}\n\texport type ApiModel = 'ChatGPTAPI' | 'ChatGPTUnofficialProxyAPI' | undefined\n"]}
{"filename": "service/src/index.ts", "chunked_list": ["import express from 'express'\n\timport type { RequestProps } from './types'\n\timport type { ChatMessage } from './chatgpt'\n\timport { chatConfig, chatReplyProcess, currentModel } from './chatgpt'\n\timport { limiter } from './middleware/limiter'\n\timport { isNotEmptyString } from './utils/is'\n\tconst app = express()\n\tconst router = express.Router()\n\tapp.use(express.static('public'))\n\tapp.use(express.json())\n", "app.all('*', (_, res, next) => {\n\t  res.header('Access-Control-Allow-Origin', '*')\n\t  res.header('Access-Control-Allow-Headers', 'authorization, Content-Type')\n\t  res.header('Access-Control-Allow-Methods', '*')\n\t  next()\n\t})\n\trouter.post('/chat-process', [limiter], async (req, res) => {\n\t  res.setHeader('Content-type', 'application/octet-stream')\n\t  try {\n\t    const { prompt, options = {}, systemMessage, temperature, top_p } = req.body as RequestProps\n", "    let firstChunk = true\n\t    await chatReplyProcess({\n\t      message: prompt,\n\t      lastContext: options,\n\t      process: (chat: ChatMessage) => {\n\t        res.write(firstChunk ? JSON.stringify(chat) : `\\n${JSON.stringify(chat)}`)\n\t        firstChunk = false\n\t      },\n\t      systemMessage,\n\t      temperature,\n", "      top_p,\n\t    })\n\t  }\n\t  catch (error) {\n\t    res.write(JSON.stringify(error))\n\t  }\n\t  finally {\n\t    res.end()\n\t  }\n\t})\n", "router.post('/config', async (req, res) => {\n\t  try {\n\t    const response = await chatConfig()\n\t    res.send(response)\n\t  }\n\t  catch (error) {\n\t    res.send(error)\n\t  }\n\t})\n\tapp.use('', router)\n", "app.use('/api', router)\n\tapp.set('trust proxy', 1)\n\tapp.listen(3002, () => globalThis.console.log('Server is running on port 3002'))\n"]}
{"filename": "service/src/utils/index.ts", "chunked_list": ["interface SendResponseOptions<T = any> {\n\t  type: 'Success' | 'Fail'\n\t  message?: string\n\t  data?: T\n\t}\n\texport function sendResponse<T>(options: SendResponseOptions<T>) {\n\t  if (options.type === 'Success') {\n\t    return Promise.resolve({\n\t      message: options.message ?? null,\n\t      data: options.data ?? null,\n", "      status: options.type,\n\t    })\n\t  }\n\t  // eslint-disable-next-line prefer-promise-reject-errors\n\t  return Promise.reject({\n\t    message: options.message ?? 'Failed',\n\t    data: options.data ?? null,\n\t    status: options.type,\n\t  })\n\t}\n"]}
{"filename": "service/src/utils/is.ts", "chunked_list": ["export function isNumber<T extends number>(value: T | unknown): value is number {\n\t  return Object.prototype.toString.call(value) === '[object Number]'\n\t}\n\texport function isString<T extends string>(value: T | unknown): value is string {\n\t  return Object.prototype.toString.call(value) === '[object String]'\n\t}\n\texport function isNotEmptyString(value: any): boolean {\n\t  return typeof value === 'string' && value.length > 0\n\t}\n\texport function isBoolean<T extends boolean>(value: T | unknown): value is boolean {\n", "  return Object.prototype.toString.call(value) === '[object Boolean]'\n\t}\n\texport function isFunction<T extends (...args: any[]) => any | void | never>(value: T | unknown): value is T {\n\t  return Object.prototype.toString.call(value) === '[object Function]'\n\t}\n"]}
{"filename": "service/src/chatgpt/types.ts", "chunked_list": ["import type { ChatMessage } from 'chatgpt'\n\timport type fetch from 'node-fetch'\n\texport interface RequestOptions {\n\t  message: string\n\t  lastContext?: { conversationId?: string; parentMessageId?: string }\n\t  process?: (chat: ChatMessage) => void\n\t  systemMessage?: string\n\t  temperature?: number\n\t  top_p?: number\n\t}\n", "export interface ImageRequestOptions {\n\t}\n\texport interface SetProxyOptions {\n\t  fetch?: typeof fetch\n\t}\n\texport interface UsageResponse {\n\t  total_usage: number\n\t}\n"]}
{"filename": "service/src/chatgpt/index.ts", "chunked_list": ["import * as dotenv from 'dotenv'\n\timport 'isomorphic-fetch'\n\timport type { ChatGPTAPIOptions, ChatMessage, SendMessageOptions } from 'chatgpt'\n\timport { ChatGPTAPI, ChatGPTUnofficialProxyAPI } from 'chatgpt'\n\timport { SocksProxyAgent } from 'socks-proxy-agent'\n\timport httpsProxyAgent from 'https-proxy-agent'\n\timport fetch from 'node-fetch'\n\timport { sendResponse } from '../utils'\n\timport { isNotEmptyString } from '../utils/is'\n\timport type { ApiModel, ChatContext, ChatGPTUnofficialProxyAPIOptions, ModelConfig } from '../types'\n", "import type { RequestOptions, SetProxyOptions, UsageResponse } from './types'\n\tconst { HttpsProxyAgent } = httpsProxyAgent\n\tdotenv.config()\n\tconst ErrorCodeMessage: Record<string, string> = {\n\t  401: '[OpenAI] 提供错误的API密钥 | Incorrect API key provided',\n\t  403: '[OpenAI] 服务器拒绝访问，请稍后再试 | Server refused to access, please try again later',\n\t  502: '[OpenAI] 错误的网关 |  Bad Gateway',\n\t  503: '[OpenAI] 服务器繁忙，请稍后再试 | Server is busy, please try again later',\n\t  504: '[OpenAI] 网关超时 | Gateway Time-out',\n\t  500: '[OpenAI] 服务器繁忙，请稍后再试 | Internal Server Error',\n", "}\n\tconst timeoutMs: number = !isNaN(+process.env.TIMEOUT_MS) ? +process.env.TIMEOUT_MS : 100 * 1000\n\tconst disableDebug: boolean = process.env.OPENAI_API_DISABLE_DEBUG === 'true'\n\tlet apiModel: ApiModel\n\tconst model = isNotEmptyString(process.env.OPENAI_API_MODEL) ? process.env.OPENAI_API_MODEL : 'gpt-3.5-turbo'\n\tif (!isNotEmptyString(process.env.OPENAI_API_KEY) && !isNotEmptyString(process.env.OPENAI_ACCESS_TOKEN))\n\t  throw new Error('Missing OPENAI_API_KEY or OPENAI_ACCESS_TOKEN environment variable')\n\tlet api: ChatGPTAPI | ChatGPTUnofficialProxyAPI\n\t(async () => {\n\t  // More Info: https://github.com/transitive-bullshit/chatgpt-api\n", "  if (isNotEmptyString(process.env.OPENAI_API_KEY)) {\n\t    const OPENAI_API_BASE_URL = process.env.OPENAI_API_BASE_URL\n\t    const options: ChatGPTAPIOptions = {\n\t      apiKey: process.env.OPENAI_API_KEY,\n\t      completionParams: { model },\n\t      debug: !disableDebug,\n\t    }\n\t    // increase max token limit if use gpt-4\n\t    if (model.toLowerCase().includes('gpt-4')) {\n\t      // if use 32k model\n", "      if (model.toLowerCase().includes('32k')) {\n\t        options.maxModelTokens = 32768\n\t        options.maxResponseTokens = 8192\n\t      }\n\t      else {\n\t        options.maxModelTokens = 8192\n\t        options.maxResponseTokens = 2048\n\t      }\n\t    }\n\t    else if (model.toLowerCase().includes('gpt-3.5')) {\n", "      if (model.toLowerCase().includes('16k')) {\n\t        options.maxModelTokens = 16384\n\t        options.maxResponseTokens = 4096\n\t      }\n\t    }\n\t    if (isNotEmptyString(OPENAI_API_BASE_URL))\n\t      options.apiBaseUrl = `${OPENAI_API_BASE_URL}/v1`\n\t    setupProxy(options)\n\t    api = new ChatGPTAPI({ ...options })\n\t    apiModel = 'ChatGPTAPI'\n", "  }\n\t  else {\n\t    const options: ChatGPTUnofficialProxyAPIOptions = {\n\t      accessToken: process.env.OPENAI_ACCESS_TOKEN,\n\t      apiReverseProxyUrl: isNotEmptyString(process.env.API_REVERSE_PROXY) ? process.env.API_REVERSE_PROXY : 'https://ai.fakeopen.com/api/conversation',\n\t      model,\n\t      debug: !disableDebug,\n\t    }\n\t    setupProxy(options)\n\t    api = new ChatGPTUnofficialProxyAPI({ ...options })\n", "    apiModel = 'ChatGPTUnofficialProxyAPI'\n\t  }\n\t})()\n\tasync function chatReplyProcess(options: RequestOptions) {\n\t  const { message, lastContext, process, systemMessage, temperature, top_p } = options\n\t  try {\n\t    let options: SendMessageOptions = { timeoutMs }\n\t    globalThis.console.log(systemMessage)\n\t    if (apiModel === 'ChatGPTAPI') {\n\t      if (isNotEmptyString(systemMessage)) {\n", "        options.systemMessage = systemMessage\n\t        globalThis.console.log(systemMessage)\n\t      }\n\t      options.completionParams = { model, temperature, top_p }\n\t    }\n\t    if (lastContext != null) {\n\t      if (apiModel === 'ChatGPTAPI')\n\t        options.parentMessageId = lastContext.parentMessageId\n\t      else\n\t        options = { ...lastContext }\n", "    }\n\t    const response = await api.sendMessage(message, {\n\t      ...options,\n\t      onProgress: (partialResponse) => {\n\t        process?.(partialResponse)\n\t      },\n\t    })\n\t    return sendResponse({ type: 'Success', data: response })\n\t  }\n\t  catch (error: any) {\n", "    const code = error.statusCode\n\t    global.console.log(error)\n\t    if (Reflect.has(ErrorCodeMessage, code))\n\t      return sendResponse({ type: 'Fail', message: ErrorCodeMessage[code] })\n\t    return sendResponse({ type: 'Fail', message: error.message ?? 'Please check the back-end console' })\n\t  }\n\t}\n\tasync function fetchUsage() {\n\t  const OPENAI_API_KEY = process.env.OPENAI_API_KEY\n\t  const OPENAI_API_BASE_URL = process.env.OPENAI_API_BASE_URL\n", "  if (!isNotEmptyString(OPENAI_API_KEY))\n\t    return Promise.resolve('-')\n\t  const API_BASE_URL = isNotEmptyString(OPENAI_API_BASE_URL)\n\t    ? OPENAI_API_BASE_URL\n\t    : 'https://api.openai.com'\n\t  const [startDate, endDate] = formatDate()\n\t  // 每月使用量\n\t  const urlUsage = `${API_BASE_URL}/v1/dashboard/billing/usage?start_date=${startDate}&end_date=${endDate}`\n\t  const headers = {\n\t    'Authorization': `Bearer ${OPENAI_API_KEY}`,\n", "    'Content-Type': 'application/json',\n\t  }\n\t  const options = {} as SetProxyOptions\n\t  setupProxy(options)\n\t  try {\n\t    // 获取已使用量\n\t    const useResponse = await options.fetch(urlUsage, { headers })\n\t    if (!useResponse.ok)\n\t      throw new Error('获取使用量失败')\n\t    const usageData = await useResponse.json() as UsageResponse\n", "    const usage = Math.round(usageData.total_usage) / 100\n\t    return Promise.resolve(usage ? `$${usage}` : '-')\n\t  }\n\t  catch (error) {\n\t    global.console.log(error)\n\t    return Promise.resolve('-')\n\t  }\n\t}\n\tfunction formatDate(): string[] {\n\t  const today = new Date()\n", "  const year = today.getFullYear()\n\t  const month = today.getMonth() + 1\n\t  const lastDay = new Date(year, month, 0)\n\t  const formattedFirstDay = `${year}-${month.toString().padStart(2, '0')}-01`\n\t  const formattedLastDay = `${year}-${month.toString().padStart(2, '0')}-${lastDay.getDate().toString().padStart(2, '0')}`\n\t  return [formattedFirstDay, formattedLastDay]\n\t}\n\tasync function chatConfig() {\n\t  const usage = await fetchUsage()\n\t  const reverseProxy = process.env.API_REVERSE_PROXY ?? '-'\n", "  const httpsProxy = (process.env.HTTPS_PROXY || process.env.ALL_PROXY) ?? '-'\n\t  const socksProxy = (process.env.SOCKS_PROXY_HOST && process.env.SOCKS_PROXY_PORT)\n\t    ? (`${process.env.SOCKS_PROXY_HOST}:${process.env.SOCKS_PROXY_PORT}`)\n\t    : '-'\n\t  return sendResponse<ModelConfig>({\n\t    type: 'Success',\n\t    data: { apiModel, reverseProxy, timeoutMs, socksProxy, httpsProxy, usage },\n\t  })\n\t}\n\tfunction setupProxy(options: SetProxyOptions) {\n", "  if (isNotEmptyString(process.env.SOCKS_PROXY_HOST) && isNotEmptyString(process.env.SOCKS_PROXY_PORT)) {\n\t    const agent = new SocksProxyAgent({\n\t      hostname: process.env.SOCKS_PROXY_HOST,\n\t      port: process.env.SOCKS_PROXY_PORT,\n\t      userId: isNotEmptyString(process.env.SOCKS_PROXY_USERNAME) ? process.env.SOCKS_PROXY_USERNAME : undefined,\n\t      password: isNotEmptyString(process.env.SOCKS_PROXY_PASSWORD) ? process.env.SOCKS_PROXY_PASSWORD : undefined,\n\t    })\n\t    options.fetch = (url, options) => {\n\t      return fetch(url, { agent, ...options })\n\t    }\n", "  }\n\t  else if (isNotEmptyString(process.env.HTTPS_PROXY) || isNotEmptyString(process.env.ALL_PROXY)) {\n\t    const httpsProxy = process.env.HTTPS_PROXY || process.env.ALL_PROXY\n\t    if (httpsProxy) {\n\t      const agent = new HttpsProxyAgent(httpsProxy)\n\t      options.fetch = (url, options) => {\n\t        return fetch(url, { agent, ...options })\n\t      }\n\t    }\n\t  }\n", "  else {\n\t    options.fetch = (url, options) => {\n\t      return fetch(url, { ...options })\n\t    }\n\t  }\n\t}\n\tfunction currentModel(): ApiModel {\n\t  return apiModel\n\t}\n\texport type { ChatContext, ChatMessage }\n", "export { chatReplyProcess, chatConfig, currentModel }\n"]}
{"filename": "service/src/middleware/limiter.ts", "chunked_list": ["import { rateLimit } from 'express-rate-limit'\n\timport { isNotEmptyString } from '../utils/is'\n\tconst MAX_REQUEST_PER_HOUR = process.env.MAX_REQUEST_PER_HOUR\n\tconst maxCount = (isNotEmptyString(MAX_REQUEST_PER_HOUR) && !isNaN(Number(MAX_REQUEST_PER_HOUR)))\n\t  ? parseInt(MAX_REQUEST_PER_HOUR)\n\t  : 0 // 0 means unlimited\n\tconst limiter = rateLimit({\n\t  windowMs: 60 * 60 * 1000, // Maximum number of accesses within an hour\n\t  max: maxCount,\n\t  statusCode: 200, // 200 means success，but the message is 'Too many request from this IP in 1 hour'\n", "  message: async (req, res) => {\n\t    res.send({ status: 'Fail', message: 'Too many request from this IP in 1 hour', data: null })\n\t  },\n\t})\n\texport { limiter }\n"]}
{"filename": "src/main.ts", "chunked_list": ["import { createApp } from \"vue\";\n\timport App from \"./App.vue\";\n\timport * as VueRouter from \"vue-router\";\n\timport routes from \"./configs/routes\";\n\timport { createPinia } from \"pinia\";\n\timport piniaPluginPersistedstate from \"pinia-plugin-persistedstate\";\n\timport 'highlight.js/styles/github.css'\n\tconst app = createApp(App);\n\t// 路由\n\tconst router = VueRouter.createRouter({\n", "  history: VueRouter.createWebHashHistory(),\n\t  routes,\n\t});\n\tapp.use(router);\n\t// 状态管理\n\tconst pinia = createPinia();\n\tpinia.use(piniaPluginPersistedstate);\n\tapp.use(pinia);\n\tapp.mount(\"#app\");\n"]}
{"filename": "src/env.d.ts", "chunked_list": ["/// <reference types=\"vite/client\" />\n\tdeclare module '*.vue' {\n\t  import type { DefineComponent } from 'vue'\n\t  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types\n\t  const component: DefineComponent<{}, {}, any>\n\t  export default component\n\t}"]}
{"filename": "src/plugins/myAxios.ts", "chunked_list": ["import axios from \"axios\";\n\tlet serverAddress = import.meta.env.VITE_SERVER_ADDRESS\n\tconst myAxios = axios.create({\n\t  baseURL: `http://${serverAddress}/api`,\n\t});\n\tmyAxios.defaults.withCredentials = true;\n\tmyAxios.interceptors.request.use(\n\t  function (config) {\n\t    return config;\n\t  },\n", "  function (error) {\n\t    return Promise.reject(error);\n\t  }\n\t);\n\tmyAxios.interceptors.response.use(\n\t  function (response) {\n\t    return response.data;\n\t  },\n\t  function (error) {\n\t    return Promise.reject(error);\n", "  }\n\t);\n\texport default myAxios;\n"]}
{"filename": "src/components/gpt-terminal/hint.ts", "chunked_list": ["import { ref } from \"vue\";\n\timport { getUsageStr } from \"../../core/commands/terminal/help/helpUtils\";\n\timport { commandMap } from \"../../core/commandRegister\";\n\timport _, { trim } from \"lodash\";\n\t/**\n\t * 命令提示功能\n\t * @author yupi\n\t */\n\tconst useHint = () => {\n\t  const hint = ref(\"\");\n", "  const setHint = (inputText: string) => {\n\t    if (!inputText) {\n\t      hint.value = \"\";\n\t      return;\n\t    }\n\t    const args = trim(inputText).split(\" \");\n\t    // 大小写无关\n\t    let func = args[0].toLowerCase();\n\t    // 前缀匹配\n\t    const likeKey = Object.keys(commandMap).filter((key) =>\n", "      key.startsWith(func)\n\t    )[0];\n\t    let command = commandMap[likeKey];\n\t    if (!command) {\n\t      hint.value = \"\";\n\t      return;\n\t    }\n\t    // 子命令提示\n\t    if (\n\t      command.subCommands &&\n", "      Object.keys(command.subCommands).length > 0 &&\n\t      args.length > 1\n\t    ) {\n\t      hint.value = getUsageStr(command.subCommands[args[1]], command);\n\t    } else {\n\t      hint.value = getUsageStr(command);\n\t    }\n\t  };\n\t  /**\n\t   * 输入提示防抖\n", "   */\n\t  const debounceSetHint = _.debounce(function (inputText: string) {\n\t    setHint(inputText);\n\t  }, 100);\n\t  return {\n\t    hint,\n\t    setHint,\n\t    debounceSetHint,\n\t  };\n\t};\n", "export default useHint;\n"]}
{"filename": "src/components/gpt-terminal/type.d.ts", "chunked_list": ["declare namespace GptTerminal {\n\t  type OutputStatusType =\n\t    | \"info\"\n\t    | \"success\"\n\t    | \"warning\"\n\t    | \"error\"\n\t    | \"system\"\n\t    | \"loading\";\n\t  // 输出父类型\n\t  interface OutputType {\n", "    type: \"command\" | \"text\" | \"component\";\n\t    text?: string;\n\t    resultList?: OutputType[];\n\t    component?: any;\n\t    status?: OutputStatusType;\n\t    props?: any;\n\t    collapsible?: boolean;\n\t  }\n\t  /**\n\t   * 命令类型输出\n", "   */\n\t  interface CommandOutputType extends OutputType {\n\t    type: \"command\";\n\t    text: string;\n\t    resultList: OutputType[];\n\t  }\n\t  /**\n\t   * 文本类型输出\n\t   */\n\t  interface TextOutputType extends OutputType {\n", "    type: \"text\";\n\t    text: string;\n\t  }\n\t  /**\n\t   * 组件类型输出\n\t   */\n\t  interface ComponentOutputType extends OutputType {\n\t    type: \"component\";\n\t    component: any;\n\t    props?: any;\n", "  }\n\t  /**\n\t   * 命令输入类型\n\t   */\n\t  interface CommandInputType {\n\t    text: string;\n\t    placeholder?: string;\n\t  }\n\t  /**\n\t   * GPT 对话记录类型\n", "   */\n\t  interface MessageElement {\n\t    role: string;\n\t    content: string;\n\t  }\n\t  interface MessageType {\n\t    roleKeyword: string | \"default\";\n\t    messageElements: MessageElement[];\n\t  }\n\t  /**\n", "   * 用户属性\n\t   */\n\t  interface UserType {\n\t    id: number;\n\t    username: string;\n\t    email?: string;\n\t    creatTime?: date;\n\t    updateTime?: date;\n\t  }\n\t  /**\n", "   * 终端类型（定义一组访问及操作终端的方法）\n\t   */\n\t  interface TerminalType {\n\t    // 是否运行\n\t    isRunning: boolean;\n\t    // 清屏\n\t    clear: () => void;\n\t    // 立即输出\n\t    writeOutput: (output: OutputType) => void;\n\t    // 立即输出文本\n", "    writeTextOutput: (text: string, status?: OutputStatusType) => void;\n\t    // 写命令文本结果\n\t    writeTextResult: (text: string, status?: OutputStatusType) => void;\n\t    // 写命令错误文本结果\n\t    writeTextErrorResult: (text: string) => void;\n\t    // 写命令等待状态 GPT\n\t    writeTextLoadingResult: (text: string) => void;\n\t    // 写命令成功文本结果\n\t    writeTextSuccessResult: (text: string) => void;\n\t    // 写命令结果\n", "    writeResult: (output: OutputType) => void;\n\t    // 移除 outputList 最后一个元素\n\t    removeLastOutput: () => void;\n\t    // 输入框聚焦\n\t    focusInput: () => void;\n\t    // 获取输入框是否聚焦\n\t    isInputFocused: () => boolean;\n\t    // 设置输入框的值\n\t    setTabCompletion: () => void;\n\t    // 提交命令\n", "    doSubmitCommand: () => void;\n\t    // 查看下一条命令\n\t    showNextCommand: () => void;\n\t    // 查看上一条命令\n\t    showPrevCommand: () => void;\n\t    // 查看历史命令\n\t    listCommandHistory: () => CommandOutputType[];\n\t    // 折叠 / 展开所有块\n\t    toggleAllCollapse: () => void;\n\t    // 设置命令是否可折叠\n", "    setCommandCollapsible: (collapsible: boolean) => void;\n\t    // GPT 历史对话记录\n\t    listGptHistory: () => MessageType[];\n\t    // 终止当前命令运行\n\t    terminateCurrentCommand: () => void;\n\t  }\n\t}\n"]}
{"filename": "src/components/gpt-terminal/shortcuts.ts", "chunked_list": ["/**\n\t * 快捷键系统\n\t * @author yupi\n\t */\n\timport TerminalType = GptTerminal.TerminalType;\n\t/**\n\t * 注册快捷键\n\t * @param terminal\n\t */\n\texport const registerShortcuts = (terminal: TerminalType) => {\n", "  document.onkeydown = (e) => {\n\t    // console.log(e);\n\t    let key = e.key;\n\t    // 自动聚焦输入框\n\t    if (key >= \"a\" && key <= \"z\" && !e.metaKey && !e.shiftKey && !e.ctrlKey) {\n\t      terminal.focusInput();\n\t      return;\n\t    }\n\t    // 匹配快捷键\n\t    let code = e.code;\n", "    for (const shortcut of shortcutList) {\n\t      if (\n\t        code === shortcut.code &&\n\t        e.ctrlKey == !!shortcut.ctrlKey &&\n\t        e.metaKey == !!shortcut.metaKey &&\n\t        e.shiftKey == !!shortcut.shiftKey\n\t      ) {\n\t        shortcut.action(e, terminal);\n\t      }\n\t    }\n", "  };\n\t};\n\t/**\n\t * 快捷键类型\n\t */\n\tinterface ShortcutType {\n\t  code: string; // 按键码\n\t  desc?: string; // 功能描述\n\t  keyDesc?: string; // 按键描述\n\t  ctrlKey?: boolean;\n", "  metaKey?: boolean;\n\t  shiftKey?: boolean;\n\t  action: (e: Event, terminal: TerminalType) => void;\n\t}\n\t/**\n\t * 快捷键列表\n\t */\n\texport const shortcutList: ShortcutType[] = [\n\t  {\n\t    desc: \"清屏\",\n", "    code: \"KeyL\",\n\t    keyDesc: \"Ctrl + L\",\n\t    ctrlKey: true,\n\t    action(e, terminal) {\n\t      e.preventDefault();\n\t      terminal.clear();\n\t    },\n\t  },\n\t  {\n\t    desc: \"折叠\",\n", "    code: \"KeyO\",\n\t    keyDesc: \"Ctrl + O\",\n\t    ctrlKey: true,\n\t    action(e, terminal) {\n\t      e.preventDefault();\n\t      terminal.toggleAllCollapse();\n\t    },\n\t  },\n\t  // {\n\t  //   desc: \"粘贴\",\n", "  //   code: \"KeyV\",\n\t  //   keyDesc: \"Ctrl + V\",\n\t  //   metaKey: true,\n\t  //   action(e, terminal) {\n\t  //     terminal.focusInput();\n\t  //   },\n\t  // },\n\t  {\n\t    desc: \"终止命令\",\n\t    code: \"KeyC\",\n", "    keyDesc: \"Ctrl + C\",\n\t    ctrlKey: true,\n\t    action(e, terminal) {\n\t      terminal.terminateCurrentCommand();\n\t    }\n\t  },\n\t  {\n\t    code: \"Tab\",\n\t    action(e, terminal) {\n\t      e.preventDefault();\n", "      if (terminal.isInputFocused()) {\n\t        terminal.setTabCompletion();\n\t      } else {\n\t        terminal.focusInput();\n\t      }\n\t    },\n\t  },\n\t  {\n\t    code: \"Backspace\",\n\t    action(e, terminal) {\n", "      terminal.focusInput();\n\t    },\n\t  },\n\t  {\n\t    code: \"Enter\",\n\t    action(e, terminal) {\n\t      terminal.focusInput();\n\t    },\n\t  },\n\t  {\n", "    desc: \"查看上一条命令\",\n\t    code: \"ArrowUp\",\n\t    keyDesc: \"↑\",\n\t    action(e, terminal) {\n\t      e.preventDefault();\n\t      if (!terminal.isRunning) {\n\t        terminal.showPrevCommand();\n\t      }\n\t    },\n\t  },\n", "  {\n\t    desc: \"查看下一条命令\",\n\t    code: \"ArrowDown\",\n\t    keyDesc: \"↓\",\n\t    action(e, terminal) {\n\t      e.preventDefault();\n\t      if (!terminal.isRunning) {\n\t        terminal.showNextCommand();\n\t      }\n\t    },\n", "  },\n\t];\n"]}
{"filename": "src/components/gpt-terminal/history.ts", "chunked_list": ["import { Ref, ref } from \"vue\";\n\timport CommandOutputType = GptTerminal.CommandOutputType;\n\timport CommandInputType = GptTerminal.CommandInputType;\n\t/**\n\t * 查看历史功能\n\t * @param commandList\n\t * @param inputCommand\n\t */\n\tconst useHistory = (\n\t  commandList: CommandOutputType[],\n", "  inputCommand: Ref<CommandInputType>\n\t) => {\n\t  /**\n\t   * 当前查看的命令位置\n\t   */\n\t  const commandHistoryPos = ref(commandList.length);\n\t  const listCommandHistory = () => {\n\t    return commandList;\n\t  };\n\t  const showNextCommand = () => {\n", "    console.log(commandHistoryPos.value, commandList, inputCommand);\n\t    if (commandHistoryPos.value < commandList.length - 1) {\n\t      commandHistoryPos.value++;\n\t      inputCommand.value.text = commandList[commandHistoryPos.value].text;\n\t    } else if (commandHistoryPos.value === commandList.length - 1) {\n\t      commandHistoryPos.value++;\n\t      inputCommand.value.text = \"\";\n\t    }\n\t  };\n\t  const showPrevCommand = () => {\n", "    console.log(commandHistoryPos.value, commandList, inputCommand);\n\t    if (commandHistoryPos.value >= 1) {\n\t      commandHistoryPos.value--;\n\t      inputCommand.value.text = commandList[commandHistoryPos.value].text;\n\t    }\n\t  };\n\t  return {\n\t    commandHistoryPos,\n\t    listCommandHistory,\n\t    showNextCommand,\n", "    showPrevCommand,\n\t  };\n\t};\n\texport default useHistory;\n"]}
{"filename": "src/configs/routes.ts", "chunked_list": ["import { RouteRecordRaw } from \"vue-router\";\n\timport IndexPage from \"../pages/IndexPage.vue\";\n\tconst route: RouteRecordRaw[] = [{ path: \"/\", component: IndexPage }];\n\texport default route;\n"]}
{"filename": "src/utils/smartText.ts", "chunked_list": ["/**\n\t * 匹配网址正则\n\t */\n\tconst URL_REG =\n\t  /(((https?:(?:\\/\\/)?)(?:[-;:&=\\+\\$,\\w]+@)?[A-Za-z0-9.-]+(?::\\d+)?|(?:www.|[-;:&=\\+\\$,\\w]+@)[A-Za-z0-9.-]+)((?:\\/[\\+~%\\/.\\w-_]*)?\\??(?:[-\\+=&;%@.\\w_]*)#?(?:[\\w]*))?)/;\n\t/**\n\t * 识别文本中的超链接\n\t * @param text\n\t */\n\tconst smartText = (text?: string) => {\n", "  if (!text) {\n\t    return text;\n\t  }\n\t  const reg = new RegExp(URL_REG, \"gi\");\n\t  return text.replaceAll(reg, \"<a href='$1' target='_blank'>$1</a>\");\n\t};\n\texport default smartText;\n"]}
{"filename": "src/utils/request/axios.ts", "chunked_list": ["import axios, { type AxiosResponse } from 'axios'\n\t// import { useAuthStore } from '@/store'\n\tconst service = axios.create({\n\t  baseURL: \"/api\",\n\t})\n\tservice.interceptors.request.use(\n\t  (config) => {\n\t    // const token = useAuthStore().token\n\t    // if (token)\n\t    //   config.headers.Authorization = `Bearer ${token}`\n", "    return config;\n\t  },\n\t  (error) => {\n\t    return Promise.reject(error.response)\n\t  },\n\t)\n\tservice.interceptors.response.use(\n\t  (response: AxiosResponse): AxiosResponse => {\n\t    if (response.status === 200)\n\t      return response\n", "    throw new Error(response.status.toString())\n\t  },\n\t  (error) => {\n\t    return Promise.reject(error)\n\t  },\n\t)\n\texport default service\n"]}
{"filename": "src/utils/request/index.ts", "chunked_list": ["import type { AxiosProgressEvent, AxiosResponse, GenericAbortSignal } from 'axios'\n\timport request from './axios'\n\texport interface HttpOption {\n\t  url: string\n\t  data?: any\n\t  method?: string\n\t  headers?: any\n\t  onDownloadProgress?: (progressEvent: AxiosProgressEvent) => void\n\t  signal?: GenericAbortSignal\n\t  beforeRequest?: () => void\n", "  afterRequest?: () => void\n\t}\n\texport interface Response<T = any> {\n\t  data: T\n\t  message: string | null\n\t  status: string\n\t}\n\tfunction http<T = any>(\n\t  { url, data, method, headers, onDownloadProgress, signal, beforeRequest, afterRequest }: HttpOption,\n\t) {\n", "  const successHandler = (res: AxiosResponse<Response<T>>) => {\n\t    if (res.data.status === 'Success' || typeof res.data === 'string')\n\t      return res.data\n\t    if (res.data.status === 'Unauthorized') {\n\t      window.location.reload()\n\t    }\n\t    return Promise.reject(res.data)\n\t  }\n\t  const failHandler = (error: Response<Error>) => {\n\t    afterRequest?.()\n", "    throw new Error(error?.message || 'Error')\n\t  }\n\t  beforeRequest?.()\n\t  method = method || 'GET'\n\t  const params = Object.assign(typeof data === 'function' ? data() : data ?? {}, {})\n\t  return method === 'GET'\n\t    ? request.get(url, { params, signal, onDownloadProgress }).then(successHandler, failHandler)\n\t    : request.post(url, params, { headers, signal, onDownloadProgress }).then(successHandler, failHandler)\n\t}\n\texport function get<T = any>(\n", "  { url, data, method = 'GET', onDownloadProgress, signal, beforeRequest, afterRequest }: HttpOption,\n\t): Promise<Response<T>> {\n\t  return http<T>({\n\t    url,\n\t    method,\n\t    data,\n\t    onDownloadProgress,\n\t    signal,\n\t    beforeRequest,\n\t    afterRequest,\n", "  })\n\t}\n\texport function post<T = any>(\n\t  { url, data, method = 'POST', headers, onDownloadProgress, signal, beforeRequest, afterRequest }: HttpOption,\n\t): Promise<Response<T>> {\n\t  return http<T>({\n\t    url,\n\t    method,\n\t    data,\n\t    headers,\n", "    onDownloadProgress,\n\t    signal,\n\t    beforeRequest,\n\t    afterRequest,\n\t  })\n\t}\n\texport default post\n"]}
{"filename": "src/core/commandExecutor.ts", "chunked_list": ["import getopts, { ParsedOptions } from \"getopts\";\n\timport { commandMap } from \"./commandRegister\";\n\timport { CommandOptionType, CommandType } from \"./command\";\n\timport TerminalType = GptTerminal.TerminalType;\n\timport helpCommand from \"./commands/terminal/help/helpCommand\";\n\texport const doCommandExecute = async (\n\t  text: string,\n\t  terminal: TerminalType,\n\t  parentCommand?: CommandType\n\t) => {\n", "  text = text.trim();\n\t  if (!text) {\n\t    return;\n\t  }\n\t  const command: CommandType | any = getCommand(terminal, text, parentCommand);\n\t  console.log(\"command\", command);\n\t  if (command == \"403\") {\n\t    terminal.writeTextErrorResult(\"请登录后再使用此命令\");\n\t    return;\n\t  }\n", "  if (!command) {\n\t    terminal.writeTextErrorResult(\"找不到命令\");\n\t    return;\n\t  }\n\t  const parsedOptions = doParse(text, command.options);\n\t  const { _ } = parsedOptions;\n\t  if (\n\t    _.length > 0 &&\n\t    command.subCommands &&\n\t    Object.keys(command.subCommands).length > 0\n", "  ) {\n\t    const subText = text.substring(text.indexOf(\" \") + 1);\n\t    await doCommandExecute(subText, terminal, command);\n\t    return;\n\t  }\n\t  await doAction(command, parsedOptions, terminal, parentCommand);\n\t};\n\tconst getCommand = (\n\t  terminal: TerminalType,\n\t  text: string,\n", "  parentCommand?: CommandType\n\t): CommandType | string => {\n\t  let func = text.split(\" \", 1)[0];\n\t  func = func.toLowerCase();\n\t  let commands = commandMap;\n\t  if (\n\t    parentCommand &&\n\t    parentCommand.subCommands &&\n\t    Object.keys(parentCommand.subCommands).length > 0\n\t  ) {\n", "    commands = parentCommand.subCommands;\n\t  }\n\t  const command = commands[func];\n\t  console.log(\"getCommand = \", command);\n\t  return command;\n\t};\n\tconst doParse = (\n\t  text: string,\n\t  commandOptions: CommandOptionType[]\n\t): getopts.ParsedOptions => {\n", "  const args: string[] = text.split(\" \").slice(1);\n\t  const options: getopts.Options = {\n\t    alias: {},\n\t    default: {},\n\t    string: [],\n\t    boolean: [],\n\t  };\n\t  console.log(\"commandOptions\", commandOptions);\n\t  commandOptions.forEach((commandOption) => {\n\t    const { alias, key, type, defaultValue } = commandOption;\n", "    console.log(\"解析...\");\n\t    if (alias && options.alias) {\n\t      console.log(\"alias boolean:\", Boolean(options.alias));\n\t      console.log(\"alias是：\", options.alias);\n\t      options.alias[key] = alias;\n\t    }\n\t    options[type]?.push(key);\n\t    if (defaultValue && options.default) {\n\t      options.default[key] = defaultValue;\n\t    }\n", "  });\n\t  const parsedOptions = getopts(args, options);\n\t  console.log(\"parsedOptions = \", parsedOptions);\n\t  return parsedOptions;\n\t};\n\tconst doAction = async (\n\t  command: CommandType,\n\t  options: ParsedOptions,\n\t  terminal: TerminalType,\n\t  parentCommand?: CommandType\n", ") => {\n\t  const { help, h } = options;\n\t  if (command.collapsible || help) {\n\t    terminal.setCommandCollapsible(true);\n\t  }\n\t  if (help || h) {\n\t    const newOptions = { ...options, _: [command.func] };\n\t    helpCommand.action(newOptions, terminal, parentCommand);\n\t    return;\n\t  }\n", "  await command.action(options, terminal);\n\t};\n"]}
{"filename": "src/core/command.d.ts", "chunked_list": ["import { ParsedOptions } from \"getopts\";\n\timport TerminalType = GptTerminal.TerminalType;\n\t// 命令类型\n\tinterface CommandType {\n\t  func: string; // 唯一命令英文\n\t  name: string; // 命令名称\n\t  desc?: string; // 命令描述\n\t  alias?: string[]; // 命令别名\n\t  params?: CommandParamsType[]; // 参数配置\n\t  options: CommandOptionType[]; // 选项配置\n", "  subCommands?: Record<string, CommandType>; // 子命令\n\t  // 执行功能\n\t  action: (\n\t    options: ParsedOptions,\n\t    terminal: TerminalType,\n\t    parentCommand?: CommandType\n\t  ) => void;\n\t  // 执行子功能\n\t  subAction?: (\n\t    options?: ParsedOptions,\n", "    terminal: TerminalType,\n\t    params?: Record<string, T>,\n\t    parentCommand?: CommandType,\n\t  ) => void;\n\t  // 结果是否允许折叠\n\t  collapsible?: boolean;\n\t  // 是否需要用户登录下才可访问\n\t  requireAuth?: boolean | false;\n\t}\n\t// 命令参数类型\n", "interface CommandParamsType {\n\t  key: string; // 参数名\n\t  desc?: string; // 参数描述\n\t  defaultValue?: string | boolean; // 默认值\n\t  required?: boolean; // 是否必填\n\t}\n\t// 命令选项类型\n\tinterface CommandOptionType {\n\t  key: string; // 参数名\n\t  alias?: string[]; // 别名\n", "  desc?: string; // 描述\n\t  type: \"string\" | \"boolean\";\n\t  defaultValue?: string | boolean; // 默认值\n\t  required?: boolean; // 是否必填\n\t}\n"]}
{"filename": "src/core/commandRegister.ts", "chunked_list": ["import { CommandType } from \"./command\";\n\timport clearCommand from \"./commands/terminal/clearCommand\";\n\timport historyCommand from \"./commands/terminal/historyCommand\";\n\timport helpCommand from \"./commands/terminal/help/helpCommand\";\n\timport shortcutCommand from \"./commands/terminal/shortcut/shortcutCommand\";\n\timport gptCommands from \"./commands/gpt/gptCommands\";\n\t/**\n\t * 命令列表（数组元素顺序会影响 help 命令的展示顺序）\n\t */\n\tconst commandList: CommandType[] = [\n", "  ...gptCommands,\n\t  shortcutCommand,\n\t  clearCommand,\n\t  historyCommand,\n\t  helpCommand,\n\t];\n\t/**\n\t * 命令字典\n\t */\n\tconst commandMap: Record<string, CommandType> = {};\n", "commandList.forEach((command) => {\n\t  commandMap[command.func] = command;\n\t  command.alias?.forEach((name) => {\n\t    commandMap[name] = command;\n\t  });\n\t});\n\texport { commandList, commandMap };\n"]}
{"filename": "src/core/commands/terminal/clearCommand.ts", "chunked_list": ["import { CommandType } from \"../../command\";\n\tconst clearCommand: CommandType = {\n\t  func: \"clear\",\n\t  name: \"清屏\",\n\t  alias: [\"cl\"],\n\t  options: [],\n\t  action(options, termial): void {\n\t    setTimeout(() => {\n\t      termial.clear();\n\t    }, 100);\n", "  },\n\t};\n\texport default clearCommand;\n"]}
{"filename": "src/core/commands/terminal/historyCommand.ts", "chunked_list": ["import { CommandType } from \"../../command\";\n\tconst historyCommand: CommandType = {\n\t  func: \"history\",\n\t  name: \"查看执行历史\",\n\t  alias: [\"h\"],\n\t  options: [],\n\t  collapsible: true,\n\t  action(options, terminal): void {\n\t    const commandOutputTypes = terminal.listCommandHistory();\n\t    commandOutputTypes.forEach((command, index) => {\n", "      terminal.writeTextResult(`${index + 1} ${command.text}`);\n\t    });\n\t  },\n\t};\n\texport default historyCommand;\n"]}
{"filename": "src/core/commands/terminal/help/helpUtils.ts", "chunked_list": ["import { CommandOptionType, CommandType } from \"../../../command\";\n\texport const getUsageStr = (\n\t  command: CommandType,\n\t  parentCommand?: CommandType\n\t) => {\n\t  if (!command) {\n\t    return \"\";\n\t  }\n\t  let str = \"\";\n\t  if (parentCommand) {\n", "    str = parentCommand.func + \" \";\n\t  }\n\t  str += command.func;\n\t  if (command.params && command.params.length > 0) {\n\t    const paramsStrList: string[] = command.params.map((param) => {\n\t      let word = param.key;\n\t      if (param.desc) {\n\t        word = param.desc;\n\t      }\n\t      if (param.required) {\n", "        return `<${word}>`;\n\t      } else {\n\t        return `[${word}]`;\n\t      }\n\t    });\n\t    str += \" \" + paramsStrList.join(\" \");\n\t  }\n\t  if (command.options?.length > 0) {\n\t    const optionStrList: string[] = command.options.map((option) => {\n\t      const optionKey = getOptionKey(option);\n", "      if (option.type === \"boolean\") {\n\t        let word = optionKey;\n\t        if (option.desc) {\n\t          word += ` ${option.desc}`;\n\t        }\n\t        if (option.required) {\n\t          return `<${word}>`;\n\t        } else {\n\t          return `[${word}]`;\n\t        }\n", "      } else {\n\t        let word = option.key;\n\t        if (option.desc) {\n\t          word = option.desc;\n\t        }\n\t        if (option.required) {\n\t          return `<${optionKey} ${word}>`;\n\t        } else {\n\t          return `[${optionKey} ${word}]`;\n\t        }\n", "      }\n\t    });\n\t    str += \" \" + optionStrList.join(\" \");\n\t  }\n\t  return str;\n\t};\n\t/**\n\t * 获取选项关键词\n\t * @param option\n\t */\n", "export const getOptionKey = (option: CommandOptionType) => {\n\t  // 优先用简写\n\t  if (option.alias && option.alias.length > 0) {\n\t    return \"-\" + option.alias[0];\n\t  }\n\t  return \"--\" + option.key;\n\t};\n\t/**\n\t * 获取选项关键词列表\n\t * @param option\n", " */\n\texport const getOptionKeyList = (option: CommandOptionType) => {\n\t  const list = [];\n\t  // 优先用简写\n\t  if (option.alias && option.alias.length > 0) {\n\t    list.push(\"-\" + option.alias[0]);\n\t  }\n\t  list.push(\"--\" + option.key);\n\t  return list;\n\t};\n"]}
{"filename": "src/core/commands/terminal/help/helpCommand.ts", "chunked_list": ["import { CommandType } from \"../../../command\";\n\timport { defineAsyncComponent } from \"vue\";\n\timport { commandMap } from \"../../../commandRegister\";\n\timport ComponentOutputType = GptTerminal.ComponentOutputType;\n\t/**\n\t * 帮助命令\n\t * @author yupi\n\t */\n\tconst helpCommand: CommandType = {\n\t  func: \"help\",\n", "  name: \"查看帮助\",\n\t  alias: [\"man\"],\n\t  params: [\n\t    {\n\t      key: \"commandName\",\n\t      desc: \"命令英文名称\",\n\t    },\n\t  ],\n\t  options: [],\n\t  collapsible: true,\n", "  action(options, terminal, parentCommand): void {\n\t    const { _ } = options;\n\t    if (_.length < 1) {\n\t      const output: ComponentOutputType = {\n\t        type: \"component\",\n\t        component: defineAsyncComponent(() => import(\"./HelpBox.vue\")),\n\t      };\n\t      terminal.writeResult(output);\n\t      return;\n\t    }\n", "    const commandName = _[0];\n\t    let commands = commandMap;\n\t    if (\n\t      parentCommand &&\n\t      parentCommand.subCommands &&\n\t      Object.keys(parentCommand.subCommands).length > 0\n\t    ) {\n\t      commands = parentCommand.subCommands;\n\t    }\n\t    const command = commands[commandName];\n", "    if (!command) {\n\t      terminal.writeTextErrorResult(\"找不到指定命令\");\n\t      return;\n\t    }\n\t    const output: ComponentOutputType = {\n\t      type: \"component\",\n\t      component: defineAsyncComponent(() => import(\"./CommandHelpBox.vue\")),\n\t      props: {\n\t        command,\n\t        parentCommand,\n", "      },\n\t    };\n\t    terminal.writeResult(output);\n\t  },\n\t};\n\texport default helpCommand;\n"]}
{"filename": "src/core/commands/terminal/shortcut/shortcutCommand.ts", "chunked_list": ["import { CommandType } from \"../../../command\";\n\timport { defineAsyncComponent } from \"vue\";\n\timport ComponentOutputType = GptTerminal.ComponentOutputType;\n\t/**\n\t * 快捷键命令\n\t * @author yupi\n\t */\n\tconst shortcutCommand: CommandType = {\n\t  func: \"shortcut\",\n\t  name: \"快捷键\",\n", "  desc: \"查看快捷键\",\n\t  alias: [],\n\t  params: [],\n\t  options: [],\n\t  collapsible: true,\n\t  action(options, terminal): void {\n\t    const output: ComponentOutputType = {\n\t      type: \"component\",\n\t      component: defineAsyncComponent(() => import(\"./ShortcutBox.vue\")),\n\t    };\n", "    terminal.writeResult(output);\n\t  },\n\t};\n\texport default shortcutCommand;\n"]}
{"filename": "src/core/commands/gpt/configStore.ts", "chunked_list": ["import { defineStore } from \"pinia\";\n\tinterface ConfigType {\n\t  model: string;\n\t}\n\texport const useConfigStore = defineStore(\"config\", {\n\t  state: () => ({\n\t    config: {} as ConfigType,\n\t  }),\n\t  getters: {},\n\t  persist: {\n", "    key: \"gpt-config\",\n\t    storage: window.localStorage,\n\t  },\n\t  actions: {\n\t    changeModel(model: string) {\n\t      this.config.model = model;\n\t    },\n\t  },\n\t});\n"]}
{"filename": "src/core/commands/gpt/type.d.ts", "chunked_list": ["declare namespace Gpt {\n\t  interface MessageElement {\n\t    role: string;\n\t    content: string;\n\t  }\n\t  interface MessageType {\n\t    roleKeyword: string | \"default\";\n\t    roleName: string;\n\t    roleDesc: string;\n\t    systemMessage: string;\n", "    parentMessageId: string;\n\t    messageElements: MessageElement[];\n\t  }\n\t}"]}
{"filename": "src/core/commands/gpt/gptCommands.ts", "chunked_list": ["import { CommandType } from \"../../command\";\n\timport chatCommand from \"./subCommands/chat/chatCommand\";\n\timport { defineAsyncComponent } from \"vue\";\n\timport ComponentOutputType = GptTerminal.ComponentOutputType;\n\timport roleCommand from \"./subCommands/role/roleCommand\";\n\timport historyCommand from \"./subCommands/history/historyCommand\";\n\timport diyCommand from \"./subCommands/diy/diyCommand\";\n\timport imageCommand from \"./subCommands/image/imageCommand\";\n\timport modelCommand from \"./subCommands/model/modelCommand\";\n\t/**\n", " * gpt命令\n\t */\n\tconst gptCommand: CommandType = {\n\t  func: \"gpt\",\n\t  name: \"gpt 机器人\",\n\t  alias: [],\n\t  subCommands: {\n\t    chat: chatCommand,\n\t    role: roleCommand,\n\t    history: historyCommand,\n", "    diy: diyCommand,\n\t    // image: imageCommand,\n\t    // model: modelCommand\n\t  },\n\t  options: [],\n\t  async action(options, terminal) {\n\t    const output: ComponentOutputType = {\n\t      type: \"component\",\n\t      component: defineAsyncComponent(\n\t        () => import(\"./subCommands/chat/ChatBox.vue\")\n", "      ),\n\t      props: {\n\t        message: \"您好，我是 「GPT Terminal」 机器人，请问我能为您做些什么呢？\",\n\t      },\n\t    };\n\t    terminal.writeResult(output);\n\t  },\n\t};\n\texport default [gptCommand];\n"]}
{"filename": "src/core/commands/gpt/messagesStore.ts", "chunked_list": ["import { defineStore } from \"pinia\";\n\texport const useMessagesStore = defineStore(\"messages\", {\n\t  state: () => ({\n\t    messages: [\n\t      {\n\t        roleKeyword: \"default\",\n\t        roleName: \"ChatGPT\",\n\t        roleDesc: \"默认角色\",\n\t        systemMessage: \"\",\n\t        parentMessageId: \"\",\n", "        messageElements: [],\n\t      },\n\t    ] as Gpt.MessageType[],\n\t  }),\n\t  getters: {},\n\t  persist: {\n\t    key: \"gpt-messages\",\n\t    storage: window.localStorage,\n\t  },\n\t  actions: {\n", "    addRole(\n\t      roleKeyword: string,\n\t      roleName: string,\n\t      roleDesc: string,\n\t      systemMessage: string\n\t    ) {\n\t      const { messages } = this.$state;\n\t      messages.push({\n\t        roleKeyword,\n\t        roleName,\n", "        roleDesc,\n\t        systemMessage,\n\t        parentMessageId: \"\",\n\t        messageElements: [],\n\t      });\n\t    },\n\t    addMessage(\n\t      msg: Gpt.MessageElement,\n\t      roleKeyword: string | \"default\",\n\t      parentMessageId: string\n", "    ) {\n\t      const { messages } = this.$state;\n\t      messages.forEach((m) => {\n\t        if (m.roleKeyword == roleKeyword) {\n\t          // 表示已找到\n\t          m.parentMessageId = parentMessageId;\n\t          if (m.messageElements.length >= 20) {\n\t            m.messageElements.shift();\n\t          }\n\t          m.messageElements.push(msg);\n", "        }\n\t      });\n\t    },\n\t    clearMessages() {\n\t      this.$state.messages = [];\n\t    },\n\t  },\n\t});\n"]}
{"filename": "src/core/commands/gpt/subCommands/chat/chatCommand.ts", "chunked_list": ["import { CommandType } from \"../../../../command\";\n\timport { defineAsyncComponent } from \"vue\";\n\timport ComponentOutputType = GptTerminal.ComponentOutputType;\n\timport { roleMap } from \"../role/roles\";\n\tconst chatCommand: CommandType = {\n\t  func: \"chat\",\n\t  name: \"与GPT聊天\",\n\t  params: [\n\t    {\n\t      key: \"message\",\n", "      desc: \"发送给 GPT 的内容\",\n\t      required: true,\n\t    },\n\t  ],\n\t  options: [\n\t    {\n\t      key: \"role\",\n\t      desc: \"GPT 角色唯一标识\",\n\t      alias: [\"r\"],\n\t      type: \"string\",\n", "      defaultValue: \"default\",\n\t    },\n\t    {\n\t      key: \"temperature\",\n\t      desc: \"GPT 采样温度，介于 0 ～ 2 之间，值越大输出越随机\",\n\t      alias: [\"t\"],\n\t      type: \"string\",\n\t      defaultValue: \"1\",\n\t    },\n\t  ],\n", "  async action(options, terminal) {\n\t    const { _, role, temperature } = options;\n\t    if (_.length < 1) {\n\t      terminal.writeTextErrorResult(\"内容不可为空\");\n\t      return;\n\t    }\n\t    if (temperature) {\n\t      if (\n\t        isNaN(temperature) ||\n\t        Number(temperature) < 0 ||\n", "        Number(temperature) > 2\n\t      ) {\n\t        terminal.writeTextErrorResult(\"temperature 必须为 0 ～ 2 之间的整数\");\n\t        return;\n\t      }\n\t    }\n\t    const message = _.join(\" \");\n\t    // const res: any = await getGptOutput(message, role);\n\t    // console.log(res);\n\t    // console.log(typeof(res))\n", "    // 调用接口放在 ChatBox 内部去做，传入 ChatBox的参数为用户输入的 message\n\t    const output: ComponentOutputType = {\n\t      type: \"component\",\n\t      component: defineAsyncComponent(() => import(\"./ChatBox.vue\")),\n\t      props: {\n\t        message: message,\n\t        role: role,\n\t        temperature: Number(temperature),\n\t      },\n\t    };\n", "    terminal.writeResult(output);\n\t    // if (res?.code === 0) {\n\t    //   console.log(\"gpt响应：\", res);\n\t    //   const output: ComponentOutputType = {\n\t    //     type: \"component\",\n\t    //     component: defineAsyncComponent(() => import(\"./ChatBox.vue\")),\n\t    //     props: {\n\t    //       message: res.data,\n\t    //     },\n\t    //   };\n", "    //   terminal.writeResult(output);\n\t    // } else {\n\t    //   terminal.writeTextErrorResult(res?.message ?? \"GPT请求失败\");\n\t    // }\n\t  },\n\t};\n\texport default chatCommand;\n"]}
{"filename": "src/core/commands/gpt/subCommands/chat/chatApi.ts", "chunked_list": ["import type { AxiosProgressEvent, GenericAbortSignal } from \"axios\";\n\timport { post } from \"../../../../../utils/request\";\n\timport myAxios from \"../../../../../plugins/myAxios\";\n\texport const getRoleElementsByKeyword = async (keyword: string) => {\n\t  return myAxios.post(\"/role/getRoleElementsByKeyword\", {\n\t    keyword,\n\t  });\n\t};\n\texport function fetchChatAPIProcess<T = any>(params: {\n\t  prompt: string;\n", "  options?: { conversationId?: string; parentMessageId?: string };\n\t  signal?: GenericAbortSignal;\n\t  systemMessage?: string;\n\t  temperature?: number;\n\t  onDownloadProgress?: (progressEvent: AxiosProgressEvent) => void;\n\t}) {\n\t  let data: Record<string, any> = {\n\t    prompt: params.prompt,\n\t    options: params.options,\n\t    systemMessage: params.systemMessage,\n", "    temperature: params.temperature\n\t  };\n\t  return post<T>({\n\t    url: \"/chat-process\",\n\t    data,\n\t    signal: params.signal,\n\t    onDownloadProgress: params.onDownloadProgress,\n\t  });\n\t}\n"]}
{"filename": "src/core/commands/gpt/subCommands/diy/diyCommand.ts", "chunked_list": ["import { CommandType } from \"../../../../command\";\n\timport { defineAsyncComponent } from \"vue\";\n\timport ComponentOutputType = GptTerminal.ComponentOutputType;\n\tconst diyCommand: CommandType = {\n\t  func: \"diy\",\n\t  name: \"自定义 GPT 角色\",\n\t  params: [],\n\t  requireAuth: true,\n\t  options: [\n\t    {\n", "      key: \"keyword\",\n\t      desc: \"GPT 角色唯一标识\",\n\t      alias: [\"k\"],\n\t      type: \"string\",\n\t      required: true,\n\t    },\n\t    {\n\t      key: \"name\",\n\t      desc: \"GPT 角色名\",\n\t      alias: [\"n\"],\n", "      type: \"string\",\n\t      required: true,\n\t    },\n\t    {\n\t      key: \"desc\",\n\t      desc: \"GPT 角色描述\",\n\t      alias: [\"d\"],\n\t      type: \"string\",\n\t      required: true,\n\t    },\n", "  ],\n\t  async action(options, terminal) {\n\t    const { keyword, name, desc } = options;\n\t    // TODO:用户自定义角色后，需要包含进来\n\t    if (!keyword) {\n\t      terminal.writeTextErrorResult(\"角色唯一标识必填\");\n\t      return;\n\t    }\n\t    if (!name) {\n\t      terminal.writeTextErrorResult(\"角色名称必填\");\n", "      return;\n\t    }\n\t    if (!desc) {\n\t      terminal.writeTextErrorResult(\"角色描述必填\");\n\t      return;\n\t    }\n\t    const diyBox: ComponentOutputType = {\n\t      type: \"component\",\n\t      component: defineAsyncComponent(() => import(\"./DiyBox.vue\")),\n\t      props: {\n", "        keyword: keyword,\n\t        name: name,\n\t        description: desc,\n\t      },\n\t    };\n\t    terminal.writeResult(diyBox);\n\t  },\n\t};\n\texport default diyCommand;\n"]}
{"filename": "src/core/commands/gpt/subCommands/role/roles.ts", "chunked_list": ["interface Role {\n\t  name: string;\n\t  desc: string;\n\t}\n\texport const roleMap: Map<string, Role> = new Map([\n\t  [\n\t    \"default\",\n\t    {\n\t      name: \"默认角色\",\n\t      desc: \"无任何定制的普通 GPT 聊天机器人\",\n", "    },\n\t  ],\n\t  [\n\t    \"cli\",\n\t    {\n\t      name: \"命令行翻译角色\",\n\t      desc: \"将你的自然语言指令翻译为 Window/Unix 终端命令\",\n\t    },\n\t  ],\n\t  [\n", "    \"translator\",\n\t    {\n\t      name: \"中英文互译角色\",\n\t      desc: \"将你所发的内容进行中英文互译\",\n\t    },\n\t  ],\n\t  [\n\t    \"sql\",\n\t    {\n\t      name: \"SQL 翻译角色\",\n", "      desc: \"将你的自然语言指令翻译为 SQL 代码\",\n\t    },\n\t  ],\n\t  [\n\t    \"ikun\",\n\t    {\n\t      name: \"忠实的 IKun\",\n\t      desc: \"小黑子～\"\n\t    }\n\t  ]\n", "]);\n"]}
{"filename": "src/core/commands/gpt/subCommands/role/roleCommand.ts", "chunked_list": ["import { CommandType } from \"../../../../command\";\n\timport { defineAsyncComponent } from \"vue\";\n\timport ComponentOutputType = GptTerminal.ComponentOutputType;\n\tconst roleCommand: CommandType = {\n\t  func: \"role\",\n\t  name: \"查看所有 GPT 角色\",\n\t  params: [],\n\t  options: [],\n\t  async action(options, terminal) {\n\t    const output: ComponentOutputType = {\n", "      type: \"component\",\n\t      component: defineAsyncComponent(() => import(\"./RoleBox.vue\")),\n\t    };\n\t    terminal.writeResult(output);\n\t    return;\n\t  },\n\t};\n\texport default roleCommand;\n"]}
{"filename": "src/core/commands/gpt/subCommands/model/models.ts", "chunked_list": ["export interface Model {\n\t  key: string;\n\t  name: string;\n\t}\n\texport const modelList: Model[] = [\n\t  {\n\t    key: \"gpt-3.5-turbo\",\n\t    name: \"gpt-3.5-turbo\",\n\t  },\n\t  {\n", "    key: \"gpt-3.5-turbo-16k\",\n\t    name: \"gpt-3.5-turbo-16k\",\n\t  },\n\t  {\n\t    key: \"gpt-3.5-turbo-0613\",\n\t    name: \"gpt-3.5-turbo-0613\",\n\t  },\n\t  {\n\t    key: \"gpt-3.5-turbo-16k-0613\",\n\t    name: \"gpt-3.5-turbo-16k-0613\",\n", "  },\n\t  {\n\t    key: \"gpt-4-0613\",\n\t    name: \"gpt-4-0613\",\n\t  },\n\t  {\n\t    key: \"gpt-4-32k\",\n\t    name: \"gpt-4-32k\",\n\t  },\n\t  {\n", "    key: \"gpt-4-32k-0613\",\n\t    name: \"gpt-4-32k-0613\",\n\t  }\n\t]"]}
{"filename": "src/core/commands/gpt/subCommands/model/modelCommand.ts", "chunked_list": ["import { CommandType } from \"../../../../command\";\n\timport { defineAsyncComponent } from \"vue\";\n\timport ComponentOutputType = GptTerminal.ComponentOutputType;\n\tconst modelCommand: CommandType = {\n\t  func: \"model\",\n\t  name: \"选择并设置 GPT 模型\",\n\t  params: [],\n\t  options: [],\n\t  async action(options, terminal) {\n\t    const output: ComponentOutputType = {\n", "      type: \"component\",\n\t      component: defineAsyncComponent(() => import(\"./ModelSelectBox.vue\")),\n\t    };\n\t    terminal.writeResult(output);\n\t    return;\n\t  },\n\t};\n\texport default modelCommand;\n"]}
{"filename": "src/core/commands/gpt/subCommands/image/imageApi.ts", "chunked_list": ["import myAxios from \"../../../../../plugins/myAxios\";\n\texport const getImage = async (\n\t  prompt: string,\n\t  number: number,\n\t  size: string\n\t) => {\n\t  return await myAxios.post(\"/gpt/getImage\", {\n\t    prompt,\n\t    number,\n\t    size,\n", "  });\n\t};\n"]}
{"filename": "src/core/commands/gpt/subCommands/image/imageCommand.ts", "chunked_list": ["import { defineAsyncComponent } from \"vue\";\n\timport { CommandType } from \"../../../../command\";\n\timport ComponentOutputType = GptTerminal.ComponentOutputType;\n\tconst sizeMap: Map<string, string> = new Map([\n\t  [\"256\", \"256x256\"],\n\t  [\"512\", \"512x512\"],\n\t  [\"1024\", \"1024x1024\"],\n\t]);\n\tconst imageCommand: CommandType = {\n\t  func: \"image\",\n", "  name: \"智能生成图片\",\n\t  params: [\n\t    {\n\t      key: \"prompt\",\n\t      desc: \"生成图片的提示文本\",\n\t      required: true,\n\t    },\n\t  ],\n\t  options: [\n\t    {\n", "      key: \"number\",\n\t      desc: \"生成图片的数量\",\n\t      alias: [\"n\"],\n\t      type: \"string\",\n\t      required: false,\n\t    },\n\t    {\n\t      key: \"size\",\n\t      desc: \"生成图片的尺寸，可选 256/512/1024\",\n\t      alias: [\"s\"],\n", "      type: \"string\",\n\t      required: false,\n\t    },\n\t  ],\n\t  async action(options, terminal) {\n\t    const { _, number, size } = options;\n\t    if (_.length < 1) {\n\t      terminal.writeTextErrorResult(\"图片生成提示内容不可为空\");\n\t      return;\n\t    }\n", "    if (number) {\n\t      if (isNaN(number) || Number(number) < 1 || Number(number) > 5) {\n\t        terminal.writeTextErrorResult(\"图片数量必须为1～5之间的整数\");\n\t        return;\n\t      }\n\t    }\n\t    if (size && !sizeMap.has(size)) {\n\t      terminal.writeTextErrorResult(\"图片尺寸格式不正确\");\n\t      return;\n\t    }\n", "    const prompt = _.join(\" \");\n\t    // const res: any = await getImage(prompt, number, size);\n\t    // if (res?.code !== 0) {\n\t    //   terminal.writeTextErrorResult(res.message);\n\t    //   return;\n\t    // }\n\t    const imageBox: ComponentOutputType = {\n\t      type: \"component\",\n\t      component: defineAsyncComponent(() => import(\"./ImageBox.vue\")),\n\t      props: {\n", "        prompt: prompt,\n\t        number: Number(number),\n\t        size: sizeMap.get(size),\n\t      },\n\t    };\n\t    terminal.writeResult(imageBox);\n\t  },\n\t};\n\texport default imageCommand;\n"]}
{"filename": "src/core/commands/gpt/subCommands/history/historyCommand.ts", "chunked_list": ["import { CommandType } from \"../../../../command\";\n\timport { defineAsyncComponent } from \"vue\";\n\timport ComponentOutputType = GptTerminal.ComponentOutputType;\n\t// import { useMessagesStore } from \"../../messagesStore\";\n\t// const messagesStore = useMessagesStore();\n\t// const messages = messagesStore.$state.messages;\n\tconst historyCommand: CommandType = {\n\t  func: \"history\",\n\t  name: \"查看过去提问与回答记录\",\n\t  params: [],\n", "  options: [\n\t    {\n\t      key: \"position\",\n\t      desc: \"聊天记录编号，输出相对应的单条问答记录\",\n\t      alias: [\"p\"],\n\t      type: \"string\",\n\t    },\n\t  ],\n\t  // 输入1，对应0\n\t  // 输入2，对应2\n", "  // 输入3，对应4\n\t  // 输入4，对应6\n\t  // 输入5，对应8\n\t  async action(options, terminal) {\n\t    const { position } = options;\n\t    const messages = terminal.listGptHistory();\n\t    console.log(\"messages:\", messages);\n\t    // const len = messages.reduce(\n\t    //   (acc, cur) => acc + cur.messageElements.length,\n\t    //   0\n", "    // );\n\t    // 列出全部 gpt 用户提问记录\n\t    const allMessages: any = [];\n\t    messages.forEach((message) => {\n\t      message?.messageElements?.forEach((e) => {\n\t        allMessages.push({ ...e, roleKeyword: message.roleKeyword });\n\t      });\n\t    });\n\t    if (!position) {\n\t      let index = 1;\n", "      allMessages?.forEach((e: any) => {\n\t        if (e.role == \"user\") {\n\t          terminal.writeTextResult(\n\t            `${index} gpt chat -r ${e.roleKeyword} ${e.content}`\n\t          );\n\t          index += 1;\n\t        }\n\t      });\n\t    } else if (position < 1 || position * 2 > allMessages.length) {\n\t      terminal.writeTextErrorResult(\"输入序号有误，请重新输入～\");\n", "    } else {\n\t      const inputMessage = allMessages[(position - 1) * 2];\n\t      const gptCommand = `gpt chat -r ${inputMessage.roleKeyword} ${inputMessage.content}`;\n\t      const outputMessage = allMessages[(position - 1) * 2 + 1];\n\t      const gptOutput = outputMessage.content;\n\t      const recordBox: ComponentOutputType = {\n\t        type: \"component\",\n\t        component: defineAsyncComponent(() => import(\"./RecordBox.vue\")),\n\t        props: {\n\t          gptCommand: gptCommand,\n", "          gptOutput: gptOutput,\n\t        },\n\t      };\n\t      terminal.writeResult(recordBox);\n\t    }\n\t  },\n\t};\n\texport default historyCommand;\n"]}
