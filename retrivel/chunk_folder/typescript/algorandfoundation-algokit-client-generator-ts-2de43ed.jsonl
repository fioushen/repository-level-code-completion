{"filename": "jest.config.ts", "chunked_list": ["/*\n\t * For a detailed explanation regarding each configuration property and type check, visit:\n\t * https://jestjs.io/docs/configuration\n\t */\n\timport type { Config } from 'jest'\n\tconst config: Config = {\n\t  verbose: true,\n\t  transform: {\n\t    '^.+\\\\.tsx?$': 'ts-jest',\n\t  },\n", "  testPathIgnorePatterns: ['node_modules', 'dist', '.venv'],\n\t}\n\texport default config\n"]}
{"filename": "scripts/update-approvals.ts", "chunked_list": ["import * as fs from 'fs'\n\timport * as path from 'path'\n\timport { colorConsole } from '../src/util/color-console'\n\tfunction updateApprovals() {\n\t  const dirs = ['helloworld', 'lifecycle', 'state', 'voting'].map((app) => path.join(process.cwd(), 'examples', app))\n\t  for (const exampleDir of dirs) {\n\t    const generatedPath = path.join(exampleDir, 'client.generated.ts')\n\t    const approvedPath = path.join(exampleDir, 'client.ts')\n\t    if (!fs.existsSync(generatedPath)) {\n\t      colorConsole.error`Need to run ${'npm run dev'} task first to generate latest clients. Could not find file ${generatedPath}`\n", "      process.exit(-1)\n\t    }\n\t    colorConsole.info`Overwriting ${approvedPath} with contents of ${generatedPath}`\n\t    fs.rmSync(approvedPath)\n\t    const generated = fs.readFileSync(generatedPath, 'utf-8')\n\t    fs.writeFileSync(approvedPath, generated, 'utf-8')\n\t  }\n\t  colorConsole.success`Operation completed successfully`\n\t}\n\tupdateApprovals()\n"]}
{"filename": "examples/helloworld/client.spec.ts", "chunked_list": ["import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\n\timport { beforeEach, describe, expect, test } from '@jest/globals'\n\timport { HelloWorldAppClient } from './client'\n\timport { AtomicTransactionComposer } from 'algosdk'\n\timport { microAlgos } from '@algorandfoundation/algokit-utils'\n\tdescribe('hello world typed client', () => {\n\t  const localnet = algorandFixture({\n\t    testAccountFunding: microAlgos(1_000_000),\n\t  })\n\t  beforeEach(localnet.beforeEach, 10_000)\n", "  test('Calls hello', async () => {\n\t    const { algod, indexer, testAccount } = localnet.context\n\t    const client = new HelloWorldAppClient(\n\t      {\n\t        resolveBy: 'creatorAndName',\n\t        sender: testAccount,\n\t        creatorAddress: testAccount.addr,\n\t        findExistingUsing: indexer,\n\t      },\n\t      algod,\n", "    )\n\t    await client.deploy()\n\t    const response = await client.hello({ name: 'World' })\n\t    expect(response.return).toBe('Hello, World')\n\t    const response2 = await client.hello(['World!'])\n\t    expect(response2.return).toBe('Hello, World!')\n\t    const response3 = await client.helloWorldCheck({ name: 'World' })\n\t    expect(response3.return).toBe(undefined)\n\t  })\n\t  test('Composer works with manually added transaction', async () => {\n", "    const { algod, indexer, testAccount } = localnet.context\n\t    const client = new HelloWorldAppClient(\n\t      {\n\t        resolveBy: 'creatorAndName',\n\t        sender: testAccount,\n\t        creatorAddress: testAccount.addr,\n\t        findExistingUsing: indexer,\n\t      },\n\t      algod,\n\t    )\n", "    await client.deploy()\n\t    const atc = new AtomicTransactionComposer()\n\t    await client.helloWorldCheck({ name: 'World' }, { sendParams: { atc, skipSending: true } })\n\t    const [transactionWithSigner] = atc.buildGroup()\n\t    const { transaction: rawTransaction } = await client.hello({ name: 'Bananas' }, { sendParams: { skipSending: true } })\n\t    // Add a transactions in the middle of the method calls and check that it doesn't mess up the return values\n\t    const result = await client\n\t      .compose()\n\t      .hello(['World'])\n\t      .addTransaction(transactionWithSigner)\n", "      .addTransaction(rawTransaction)\n\t      .addTransaction(\n\t        client.appClient.fundAppAccount({\n\t          amount: microAlgos(100_000),\n\t          sendParams: { skipSending: true },\n\t        }),\n\t      )\n\t      .hello({ name: 'World!' })\n\t      .execute()\n\t    expect(result.returns[0]).toBe('Hello, World')\n", "    expect(result.returns[1]).toBe('Hello, World!')\n\t    expect(result.txIds.length).toBe(5)\n\t  })\n\t})\n"]}
{"filename": "examples/helloworld/client.ts", "chunked_list": ["/* eslint-disable */\n\t/**\n\t * This file was automatically generated by @algorandfoundation/algokit-client-generator.\n\t * DO NOT MODIFY IT BY HAND.\n\t * requires: @algorandfoundation/algokit-utils: ^2\n\t */\n\timport * as algokit from '@algorandfoundation/algokit-utils'\n\timport type {\n\t  AppCallTransactionResult,\n\t  AppCallTransactionResultOfType,\n", "  CoreAppCallArgs,\n\t  RawAppCallArgs,\n\t  AppState,\n\t  TealTemplateParams,\n\t  ABIAppCallArg,\n\t} from '@algorandfoundation/algokit-utils/types/app'\n\timport type {\n\t  AppClientCallCoreParams,\n\t  AppClientCompilationParams,\n\t  AppClientDeployCoreParams,\n", "  AppDetails,\n\t  ApplicationClient,\n\t} from '@algorandfoundation/algokit-utils/types/app-client'\n\timport type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'\n\timport type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'\n\timport type { TransactionWithSigner } from 'algosdk'\n\timport { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer } from 'algosdk'\n\texport const APP_SPEC: AppSpec = {\n\t  \"hints\": {\n\t    \"hello(string)string\": {\n", "      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n\t    },\n\t    \"hello_world_check(string)void\": {\n\t      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n\t    }\n\t  },\n", "  \"source\": {\n\t    \"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDgKaW50Y2Jsb2NrIDAgMQp0eG4gTnVtQXBwQXJncwppbnRjXzAgLy8gMAo9PQpibnogbWFpbl9sNgp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDAyYmVjZTExIC8vICJoZWxsbyhzdHJpbmcpc3RyaW5nIgo9PQpibnogbWFpbl9sNQp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweGJmOWMxZWRmIC8vICJoZWxsb193b3JsZF9jaGVjayhzdHJpbmcpdm9pZCIKPT0KYm56IG1haW5fbDQKZXJyCm1haW5fbDQ6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKY2FsbHN1YiBoZWxsb3dvcmxkY2hlY2tfMwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sNToKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpjYWxsc3ViIGhlbGxvXzIKc3RvcmUgMApwdXNoYnl0ZXMgMHgxNTFmN2M3NSAvLyAweDE1MWY3Yzc1CmxvYWQgMApjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2w2Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CmJueiBtYWluX2wxMgp0eG4gT25Db21wbGV0aW9uCnB1c2hpbnQgNCAvLyBVcGRhdGVBcHBsaWNhdGlvbgo9PQpibnogbWFpbl9sMTEKdHhuIE9uQ29tcGxldGlvbgpwdXNoaW50IDUgLy8gRGVsZXRlQXBwbGljYXRpb24KPT0KYm56IG1haW5fbDEwCmVycgptYWluX2wxMDoKdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KYXNzZXJ0CmNhbGxzdWIgZGVsZXRlXzEKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDExOgp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQphc3NlcnQKY2FsbHN1YiB1cGRhdGVfMAppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMTI6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCj09CmFzc2VydAppbnRjXzEgLy8gMQpyZXR1cm4KCi8vIHVwZGF0ZQp1cGRhdGVfMDoKcHJvdG8gMCAwCnR4biBTZW5kZXIKZ2xvYmFsIENyZWF0b3JBZGRyZXNzCj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKcHVzaGludCBUTVBMX1VQREFUQUJMRSAvLyBUTVBMX1VQREFUQUJMRQovLyBDaGVjayBhcHAgaXMgdXBkYXRhYmxlCmFzc2VydApyZXRzdWIKCi8vIGRlbGV0ZQpkZWxldGVfMToKcHJvdG8gMCAwCnR4biBTZW5kZXIKZ2xvYmFsIENyZWF0b3JBZGRyZXNzCj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKcHVzaGludCBUTVBMX0RFTEVUQUJMRSAvLyBUTVBMX0RFTEVUQUJMRQovLyBDaGVjayBhcHAgaXMgZGVsZXRhYmxlCmFzc2VydApyZXRzdWIKCi8vIGhlbGxvCmhlbGxvXzI6CnByb3RvIDEgMQpwdXNoYnl0ZXMgMHggLy8gIiIKcHVzaGJ5dGVzIDB4NDg2NTZjNmM2ZjJjMjAgLy8gIkhlbGxvLCAiCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApjb25jYXQKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCmxlbgppdG9iCmV4dHJhY3QgNiAwCmZyYW1lX2RpZyAwCmNvbmNhdApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyBoZWxsb193b3JsZF9jaGVjawpoZWxsb3dvcmxkY2hlY2tfMzoKcHJvdG8gMSAwCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApwdXNoYnl0ZXMgMHg1NzZmNzI2YzY0IC8vICJXb3JsZCIKPT0KYXNzZXJ0CnJldHN1Yg==\",\n\t    \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDgKcHVzaGludCAwIC8vIDAKcmV0dXJu\"\n\t  },\n\t  \"state\": {\n\t    \"global\": {\n\t      \"num_byte_slices\": 0,\n\t      \"num_uints\": 0\n\t    },\n\t    \"local\": {\n", "      \"num_byte_slices\": 0,\n\t      \"num_uints\": 0\n\t    }\n\t  },\n\t  \"schema\": {\n\t    \"global\": {\n\t      \"declared\": {},\n\t      \"reserved\": {}\n\t    },\n\t    \"local\": {\n", "      \"declared\": {},\n\t      \"reserved\": {}\n\t    }\n\t  },\n\t  \"contract\": {\n\t    \"name\": \"HelloWorldApp\",\n\t    \"methods\": [\n\t      {\n\t        \"name\": \"hello\",\n\t        \"args\": [\n", "          {\n\t            \"type\": \"string\",\n\t            \"name\": \"name\"\n\t          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"string\"\n\t        },\n\t        \"desc\": \"Returns Hello, {name}\"\n\t      },\n", "      {\n\t        \"name\": \"hello_world_check\",\n\t        \"args\": [\n\t          {\n\t            \"type\": \"string\",\n\t            \"name\": \"name\"\n\t          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"void\"\n", "        },\n\t        \"desc\": \"Asserts {name} is \\\"World\\\"\"\n\t      }\n\t    ],\n\t    \"networks\": {}\n\t  },\n\t  \"bare_call_config\": {\n\t    \"delete_application\": \"CALL\",\n\t    \"no_op\": \"CREATE\",\n\t    \"update_application\": \"CALL\"\n", "  }\n\t}\n\t/**\n\t * Defines an onCompletionAction of 'no_op'\n\t */\n\texport type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }\n\t/**\n\t * Defines an onCompletionAction of 'opt_in'\n\t */\n\texport type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }\n", "/**\n\t * Defines an onCompletionAction of 'close_out'\n\t */\n\texport type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }\n\t/**\n\t * Defines an onCompletionAction of 'delete_application'\n\t */\n\texport type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }\n\t/**\n\t * Defines an onCompletionAction of 'update_application'\n", " */\n\texport type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }\n\t/**\n\t * A state record containing a single unsigned integer\n\t */\n\texport type IntegerState = {\n\t  /**\n\t   * Gets the state value as a BigInt \n\t   */\n\t  asBigInt(): bigint\n", "  /**\n\t   * Gets the state value as a number.\n\t   */\n\t  asNumber(): number\n\t}\n\t/**\n\t * A state record containing binary data\n\t */\n\texport type BinaryState = {\n\t  /**\n", "   * Gets the state value as a Uint8Array\n\t   */\n\t  asByteArray(): Uint8Array\n\t  /**\n\t   * Gets the state value as a string\n\t   */\n\t  asString(): string\n\t}\n\t/**\n\t * Defines the types of available calls and state of the HelloWorldApp smart contract.\n", " */\n\texport type HelloWorldApp = {\n\t  /**\n\t   * Maps method signatures / names to their argument and return types.\n\t   */\n\t  methods:\n\t    & Record<'hello(string)string' | 'hello', {\n\t      argsObj: {\n\t        name: string\n\t      }\n", "      argsTuple: [name: string]\n\t      returns: string\n\t    }>\n\t    & Record<'hello_world_check(string)void' | 'hello_world_check', {\n\t      argsObj: {\n\t        name: string\n\t      }\n\t      argsTuple: [name: string]\n\t      returns: void\n\t    }>\n", "}\n\t/**\n\t * Defines the possible abi call signatures\n\t */\n\texport type HelloWorldAppSig = keyof HelloWorldApp['methods']\n\t/**\n\t * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made\n\t */\n\texport type TypedCallParams<TSignature extends HelloWorldAppSig | undefined> = {\n\t  method: TSignature\n", "  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>\n\t} & AppClientCallCoreParams & CoreAppCallArgs\n\t/**\n\t * Defines the arguments required for a bare call\n\t */\n\texport type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>\n\t/**\n\t * Maps a method signature from the HelloWorldApp smart contract to the method's arguments in either tuple of struct form\n\t */\n\texport type MethodArgs<TSignature extends HelloWorldAppSig> = HelloWorldApp['methods'][TSignature]['argsObj' | 'argsTuple']\n", "/**\n\t * Maps a method signature from the HelloWorldApp smart contract to the method's return type\n\t */\n\texport type MethodReturn<TSignature extends HelloWorldAppSig> = HelloWorldApp['methods'][TSignature]['returns']\n\t/**\n\t * A factory for available 'create' calls\n\t */\n\texport type HelloWorldAppCreateCalls = (typeof HelloWorldAppCallFactory)['create']\n\t/**\n\t * Defines supported create methods for this smart contract\n", " */\n\texport type HelloWorldAppCreateCallParams =\n\t  | (TypedCallParams<undefined> & (OnCompleteNoOp))\n\t/**\n\t * A factory for available 'update' calls\n\t */\n\texport type HelloWorldAppUpdateCalls = (typeof HelloWorldAppCallFactory)['update']\n\t/**\n\t * Defines supported update methods for this smart contract\n\t */\n", "export type HelloWorldAppUpdateCallParams =\n\t  | TypedCallParams<undefined>\n\t/**\n\t * A factory for available 'delete' calls\n\t */\n\texport type HelloWorldAppDeleteCalls = (typeof HelloWorldAppCallFactory)['delete']\n\t/**\n\t * Defines supported delete methods for this smart contract\n\t */\n\texport type HelloWorldAppDeleteCallParams =\n", "  | TypedCallParams<undefined>\n\t/**\n\t * Defines arguments required for the deploy method.\n\t */\n\texport type HelloWorldAppDeployArgs = {\n\t  deployTimeParams?: TealTemplateParams\n\t  /**\n\t   * A delegate which takes a create call factory and returns the create call params for this smart contract\n\t   */\n\t  createCall?: (callFactory: HelloWorldAppCreateCalls) => HelloWorldAppCreateCallParams\n", "  /**\n\t   * A delegate which takes a update call factory and returns the update call params for this smart contract\n\t   */\n\t  updateCall?: (callFactory: HelloWorldAppUpdateCalls) => HelloWorldAppUpdateCallParams\n\t  /**\n\t   * A delegate which takes a delete call factory and returns the delete call params for this smart contract\n\t   */\n\t  deleteCall?: (callFactory: HelloWorldAppDeleteCalls) => HelloWorldAppDeleteCallParams\n\t}\n\t/**\n", " * Exposes methods for constructing all available smart contract calls\n\t */\n\texport abstract class HelloWorldAppCallFactory {\n\t  /**\n\t   * Gets available create call factories\n\t   */\n\t  static get create() {\n\t    return {\n\t      /**\n\t       * Constructs a create call for the HelloWorldApp smart contract using a bare call\n", "       *\n\t       * @param params Any parameters for the call\n\t       * @returns A TypedCallParams object for the call\n\t       */\n\t      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {\n\t        return {\n\t          method: undefined,\n\t          methodArgs: undefined,\n\t          ...params,\n\t        }\n", "      },\n\t    }\n\t  }\n\t  /**\n\t   * Gets available update call factories\n\t   */\n\t  static get update() {\n\t    return {\n\t      /**\n\t       * Constructs an update call for the HelloWorldApp smart contract using a bare call\n", "       *\n\t       * @param params Any parameters for the call\n\t       * @returns A TypedCallParams object for the call\n\t       */\n\t      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams = {}) {\n\t        return {\n\t          method: undefined,\n\t          methodArgs: undefined,\n\t          ...params,\n\t        }\n", "      },\n\t    }\n\t  }\n\t  /**\n\t   * Gets available delete call factories\n\t   */\n\t  static get delete() {\n\t    return {\n\t      /**\n\t       * Constructs a delete call for the HelloWorldApp smart contract using a bare call\n", "       *\n\t       * @param params Any parameters for the call\n\t       * @returns A TypedCallParams object for the call\n\t       */\n\t      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t        return {\n\t          method: undefined,\n\t          methodArgs: undefined,\n\t          ...params,\n\t        }\n", "      },\n\t    }\n\t  }\n\t  /**\n\t   * Constructs a no op call for the hello(string)string ABI method\n\t   *\n\t   * Returns Hello, {name}\n\t   *\n\t   * @param args Any args for the contract call\n\t   * @param params Any additional parameters for the call\n", "   * @returns A TypedCallParams object for the call\n\t   */\n\t  static hello(args: MethodArgs<'hello(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n\t    return {\n\t      method: 'hello(string)string' as const,\n\t      methodArgs: Array.isArray(args) ? args : [args.name],\n\t      ...params,\n\t    }\n\t  }\n\t  /**\n", "   * Constructs a no op call for the hello_world_check(string)void ABI method\n\t   *\n\t   * Asserts {name} is \"World\"\n\t   *\n\t   * @param args Any args for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n\t   */\n\t  static helloWorldCheck(args: MethodArgs<'hello_world_check(string)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n\t    return {\n", "      method: 'hello_world_check(string)void' as const,\n\t      methodArgs: Array.isArray(args) ? args : [args.name],\n\t      ...params,\n\t    }\n\t  }\n\t}\n\t/**\n\t * A client to make calls to the HelloWorldApp smart contract\n\t */\n\texport class HelloWorldAppClient {\n", "  /**\n\t   * The underlying `ApplicationClient` for when you want to have more flexibility\n\t   */\n\t  public readonly appClient: ApplicationClient\n\t  private readonly sender: SendTransactionFrom | undefined\n\t  /**\n\t   * Creates a new instance of `HelloWorldAppClient`\n\t   *\n\t   * @param appDetails appDetails The details to identify the app to deploy\n\t   * @param algod An algod client instance\n", "   */\n\t  constructor(appDetails: AppDetails, private algod: Algodv2) {\n\t    this.sender = appDetails.sender\n\t    this.appClient = algokit.getAppClient({\n\t      ...appDetails,\n\t      app: APP_SPEC\n\t    }, algod)\n\t  }\n\t  /**\n\t   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type\n", "   *\n\t   * @param result The AppCallTransactionResult to be mapped\n\t   * @param returnValueFormatter An optional delegate to format the return value if required\n\t   * @returns The smart contract response with an updated return value\n\t   */\n\t  protected mapReturnValue<TReturn>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> {\n\t    if(result.return?.decodeError) {\n\t      throw result.return.decodeError\n\t    }\n\t    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined\n", "      ? returnValueFormatter(result.return.returnValue)\n\t      : result.return?.returnValue as TReturn | undefined\n\t      return { ...result, return: returnValue }\n\t  }\n\t  /**\n\t   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP\n\t   *\n\t   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters\n\t   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type\n\t   * @returns The result of the smart contract call\n", "   */\n\t  public async call<TSignature extends keyof HelloWorldApp['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {\n\t    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)\n\t  }\n\t  /**\n\t   * Idempotently deploys the HelloWorldApp smart contract.\n\t   *\n\t   * @param params The arguments for the contract calls and any additional parameters for the call\n\t   * @returns The deployment result\n\t   */\n", "  public deploy(params: HelloWorldAppDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {\n\t    const createArgs = params.createCall?.(HelloWorldAppCallFactory.create)\n\t    const updateArgs = params.updateCall?.(HelloWorldAppCallFactory.update)\n\t    const deleteArgs = params.deleteCall?.(HelloWorldAppCallFactory.delete)\n\t    return this.appClient.deploy({\n\t      ...params,\n\t      updateArgs,\n\t      deleteArgs,\n\t      createArgs,\n\t      createOnCompleteAction: createArgs?.onCompleteAction,\n", "    })\n\t  }\n\t  /**\n\t   * Gets available create methods\n\t   */\n\t  public get create() {\n\t    const $this = this\n\t    return {\n\t      /**\n\t       * Creates a new instance of the HelloWorldApp smart contract using a bare call.\n", "       *\n\t       * @param args The arguments for the bare call\n\t       * @returns The create result\n\t       */\n\t      bare(args: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs & (OnCompleteNoOp) = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n\t        return $this.appClient.create(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n\t      },\n\t    }\n\t  }\n\t  /**\n", "   * Gets available update methods\n\t   */\n\t  public get update() {\n\t    const $this = this\n\t    return {\n\t      /**\n\t       * Updates an existing instance of the HelloWorldApp smart contract using a bare call.\n\t       *\n\t       * @param args The arguments for the bare call\n\t       * @returns The update result\n", "       */\n\t      bare(args: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n\t        return $this.appClient.update(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n\t      },\n\t    }\n\t  }\n\t  /**\n\t   * Gets available delete methods\n\t   */\n\t  public get delete() {\n", "    const $this = this\n\t    return {\n\t      /**\n\t       * Deletes an existing instance of the HelloWorldApp smart contract using a bare call.\n\t       *\n\t       * @param args The arguments for the bare call\n\t       * @returns The delete result\n\t       */\n\t      bare(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n\t        return $this.appClient.delete(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n", "      },\n\t    }\n\t  }\n\t  /**\n\t   * Makes a clear_state call to an existing instance of the HelloWorldApp smart contract.\n\t   *\n\t   * @param args The arguments for the bare call\n\t   * @returns The clear_state result\n\t   */\n\t  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {\n", "    return this.appClient.clearState(args)\n\t  }\n\t  /**\n\t   * Calls the hello(string)string ABI method.\n\t   *\n\t   * Returns Hello, {name}\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n", "   */\n\t  public hello(args: MethodArgs<'hello(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(HelloWorldAppCallFactory.hello(args, params))\n\t  }\n\t  /**\n\t   * Calls the hello_world_check(string)void ABI method.\n\t   *\n\t   * Asserts {name} is \"World\"\n\t   *\n\t   * @param args The arguments for the contract call\n", "   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n\t   */\n\t  public helloWorldCheck(args: MethodArgs<'hello_world_check(string)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(HelloWorldAppCallFactory.helloWorldCheck(args, params))\n\t  }\n\t  public compose(): HelloWorldAppComposer {\n\t    const client = this\n\t    const atc = new AtomicTransactionComposer()\n\t    let promiseChain:Promise<unknown> = Promise.resolve()\n", "    const resultMappers: Array<undefined | ((x: any) => any)> = []\n\t    return {\n\t      hello(args: MethodArgs<'hello(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.hello(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      helloWorldCheck(args: MethodArgs<'hello_world_check(string)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.helloWorldCheck(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n", "        return this\n\t      },\n\t      get update() {\n\t        const $this = this\n\t        return {\n\t          bare(args?: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs) {\n\t            promiseChain = promiseChain.then(() => client.update.bare({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n\t            resultMappers.push(undefined)\n\t            return $this\n\t          },\n", "        }\n\t      },\n\t      get delete() {\n\t        const $this = this\n\t        return {\n\t          bare(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {\n\t            promiseChain = promiseChain.then(() => client.delete.bare({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n\t            resultMappers.push(undefined)\n\t            return $this\n\t          },\n", "        }\n\t      },\n\t      clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {\n\t        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))\n\t        return this\n", "      },\n\t      async atc() {\n\t        await promiseChain\n\t        return atc\n\t      },\n\t      async execute() {\n\t        await promiseChain\n\t        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)\n\t        return {\n\t          ...result,\n", "          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)\n\t        }\n\t      }\n\t    } as unknown as HelloWorldAppComposer\n\t  }\n\t}\n\texport type HelloWorldAppComposer<TReturns extends [...any[]] = []> = {\n\t  /**\n\t   * Calls the hello(string)string ABI method.\n\t   *\n", "   * Returns Hello, {name}\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  hello(args: MethodArgs<'hello(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs): HelloWorldAppComposer<[...TReturns, MethodReturn<'hello(string)string'>]>\n\t  /**\n\t   * Calls the hello_world_check(string)void ABI method.\n\t   *\n", "   * Asserts {name} is \"World\"\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  helloWorldCheck(args: MethodArgs<'hello_world_check(string)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): HelloWorldAppComposer<[...TReturns, MethodReturn<'hello_world_check(string)void'>]>\n\t  /**\n\t   * Gets available update methods\n\t   */\n", "  readonly update: {\n\t    /**\n\t     * Updates an existing instance of the HelloWorldApp smart contract using a bare call.\n\t     *\n\t     * @param args The arguments for the bare call\n\t     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t     */\n\t    bare(args?: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs): HelloWorldAppComposer<[...TReturns, undefined]>\n\t  }\n\t  /**\n", "   * Gets available delete methods\n\t   */\n\t  readonly delete: {\n\t    /**\n\t     * Deletes an existing instance of the HelloWorldApp smart contract using a bare call.\n\t     *\n\t     * @param args The arguments for the bare call\n\t     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t     */\n\t    bare(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): HelloWorldAppComposer<[...TReturns, undefined]>\n", "  }\n\t  /**\n\t   * Makes a clear_state call to an existing instance of the HelloWorldApp smart contract.\n\t   *\n\t   * @param args The arguments for the bare call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): HelloWorldAppComposer<[...TReturns, undefined]>\n\t  /**\n\t   * Adds a transaction to the composer\n", "   *\n\t   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)\n\t   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.\n\t   */\n\t  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): HelloWorldAppComposer<TReturns>\n\t  /**\n\t   * Returns the underlying AtomicTransactionComposer instance\n\t   */\n\t  atc(): Promise<AtomicTransactionComposer>\n\t  /**\n", "   * Executes the transaction group and returns an array of results\n\t   */\n\t  execute(): Promise<HelloWorldAppComposerResults<TReturns>>\n\t}\n\texport type HelloWorldAppComposerResults<TReturns extends [...any[]]> = {\n\t  returns: TReturns\n\t  groupId: string\n\t  txIds: string[]\n\t  transactions: Transaction[]\n\t}\n"]}
{"filename": "examples/lifecycle/client.spec.ts", "chunked_list": ["import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\n\timport { beforeEach, describe, expect, test } from '@jest/globals'\n\timport { OnApplicationComplete } from 'algosdk'\n\timport invariant from 'tiny-invariant'\n\timport { expectType } from 'tsd'\n\timport { LifeCycleAppClient } from './client'\n\tdescribe('lifecycle typed client', () => {\n\t  const localnet = algorandFixture()\n\t  beforeEach(localnet.beforeEach, 10_000)\n\t  let client: LifeCycleAppClient\n", "  beforeEach(() => {\n\t    const { algod, indexer, testAccount } = localnet.context\n\t    client = new LifeCycleAppClient(\n\t      {\n\t        resolveBy: 'creatorAndName',\n\t        sender: testAccount,\n\t        creatorAddress: testAccount.addr,\n\t        findExistingUsing: indexer,\n\t      },\n\t      algod,\n", "    )\n\t  })\n\t  test('create_bare', async () => {\n\t    const createResult = await client.create.bare({ updatable: true })\n\t    expectType<undefined>(createResult.return)\n\t    expect(createResult.transaction.appOnComplete).toBe(OnApplicationComplete.NoOpOC)\n\t    const response = await client.helloStringString(['Bare'])\n\t    expectType<string | undefined>(response.return)\n\t    expect(response.return).toBe('Hello, Bare\\n')\n\t  })\n", "  test('create_bare_optin', async () => {\n\t    const createResult = await client.create.bare({ updatable: true, onCompleteAction: 'opt_in' })\n\t    expectType<undefined>(createResult.return)\n\t    expect(createResult.transaction.appOnComplete).toBe(OnApplicationComplete.OptInOC)\n\t    const response = await client.helloStringString(['Bare'])\n\t    expectType<string | undefined>(response.return)\n\t    expect(response.return).toBe('Hello, Bare\\n')\n\t  })\n\t  test('deploy_bare', async () => {\n\t    const createResult = await client.deploy()\n", "    invariant(createResult.operationPerformed === 'create')\n\t    // The return in deploy isn't strongly typed since it's too complex to do\n\t    expect(createResult.return?.returnValue).toBe(undefined)\n\t    expect(createResult.transaction.appOnComplete).toBe(OnApplicationComplete.NoOpOC)\n\t    const response = await client.helloStringString(['Bare'])\n\t    expectType<string | undefined>(response.return)\n\t    expect(response.return).toBe('Hello, Bare\\n')\n\t  })\n\t  test('deploy_bare_opt_in', async () => {\n\t    const createResult = await client.deploy({\n", "      createCall: (calls) => calls.bare({ onCompleteAction: 'opt_in' }),\n\t    })\n\t    invariant(createResult.operationPerformed === 'create')\n\t    // The return in deploy isn't strongly typed since it's too complex to do\n\t    expect(createResult.return?.returnValue).toBe(undefined)\n\t    expect(createResult.transaction.appOnComplete).toBe(OnApplicationComplete.OptInOC)\n\t    const response = await client.helloStringString(['Bare'])\n\t    expectType<string | undefined>(response.return)\n\t    expect(response.return).toBe('Hello, Bare\\n')\n\t  })\n", "  test('create_1arg', async () => {\n\t    const createResult = await client.create.createStringString({ greeting: 'greeting' }, { updatable: true })\n\t    expectType<string | undefined>(createResult.return)\n\t    expect(createResult.return).toBe('greeting_1')\n\t    const response = await client.helloStringString(['1 Arg'])\n\t    expectType<string | undefined>(response.return)\n\t    expect(response.return).toBe('greeting, 1 Arg\\n')\n\t  })\n\t  test('deploy_create_1arg', async () => {\n\t    const createResult = await client.deploy({\n", "      createCall: (calls) => calls.createStringString({ greeting: 'greeting' }),\n\t    })\n\t    invariant(createResult.operationPerformed === 'create')\n\t    // The return in deploy isn't strongly typed since it's too complex to do\n\t    expect(createResult.return?.returnValue).toBe('greeting_1')\n\t    const response = await client.helloStringString(['1 Arg'])\n\t    expectType<string | undefined>(response.return)\n\t    expect(response.return).toBe('greeting, 1 Arg\\n')\n\t  })\n\t  test('create_2arg', async () => {\n", "    const createResult = await client.create.createStringUint32Void({ greeting: 'Greetings', times: 2 }, { updatable: true })\n\t    expectType<void | undefined>(createResult.return)\n\t    const response = await client.helloStringString(['2 Arg'])\n\t    expectType<string | undefined>(response.return)\n\t    expect(response.return).toBe('Greetings, 2 Arg\\nGreetings, 2 Arg\\n')\n\t  })\n\t})\n"]}
{"filename": "examples/lifecycle/client.ts", "chunked_list": ["/* eslint-disable */\n\t/**\n\t * This file was automatically generated by @algorandfoundation/algokit-client-generator.\n\t * DO NOT MODIFY IT BY HAND.\n\t * requires: @algorandfoundation/algokit-utils: ^2\n\t */\n\timport * as algokit from '@algorandfoundation/algokit-utils'\n\timport type {\n\t  AppCallTransactionResult,\n\t  AppCallTransactionResultOfType,\n", "  CoreAppCallArgs,\n\t  RawAppCallArgs,\n\t  AppState,\n\t  TealTemplateParams,\n\t  ABIAppCallArg,\n\t} from '@algorandfoundation/algokit-utils/types/app'\n\timport type {\n\t  AppClientCallCoreParams,\n\t  AppClientCompilationParams,\n\t  AppClientDeployCoreParams,\n", "  AppDetails,\n\t  ApplicationClient,\n\t} from '@algorandfoundation/algokit-utils/types/app-client'\n\timport type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'\n\timport type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'\n\timport type { TransactionWithSigner } from 'algosdk'\n\timport { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer } from 'algosdk'\n\texport const APP_SPEC: AppSpec = {\n\t  \"hints\": {\n\t    \"hello(string)string\": {\n", "      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n\t    },\n\t    \"hello()string\": {\n\t      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n\t    },\n\t    \"create(string)string\": {\n", "      \"call_config\": {\n\t        \"no_op\": \"CREATE\"\n\t      }\n\t    },\n\t    \"create(string,uint32)void\": {\n\t      \"call_config\": {\n\t        \"no_op\": \"CREATE\"\n\t      }\n\t    }\n\t  },\n", "  \"source\": {\n\t    \"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDgKaW50Y2Jsb2NrIDAgMSAxMApieXRlY2Jsb2NrIDB4IDB4NzQ2OTZkNjU3MyAweDY3NzI2NTY1NzQ2OTZlNjcgMHgxNTFmN2M3NQp0eG4gTnVtQXBwQXJncwppbnRjXzAgLy8gMAo9PQpibnogbWFpbl9sMTAKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHgwMmJlY2UxMSAvLyAiaGVsbG8oc3RyaW5nKXN0cmluZyIKPT0KYm56IG1haW5fbDkKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhhYjA2YzFhOCAvLyAiaGVsbG8oKXN0cmluZyIKPT0KYm56IG1haW5fbDgKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHg5N2YxZmMxMSAvLyAiY3JlYXRlKHN0cmluZylzdHJpbmciCj09CmJueiBtYWluX2w3CnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4NjAxOTMyNjQgLy8gImNyZWF0ZShzdHJpbmcsdWludDMyKXZvaWQiCj09CmJueiBtYWluX2w2CmVycgptYWluX2w2Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCj09CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCnN0b3JlIDMKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgppbnRjXzAgLy8gMApleHRyYWN0X3VpbnQzMgpzdG9yZSA0CmxvYWQgMwpsb2FkIDQKY2FsbHN1YiBjcmVhdGVfNwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sNzoKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAo9PQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpjYWxsc3ViIGNyZWF0ZV82CnN0b3JlIDIKYnl0ZWNfMyAvLyAweDE1MWY3Yzc1CmxvYWQgMgpjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2w4Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydApjYWxsc3ViIGhlbGxvXzQKc3RvcmUgMQpieXRlY18zIC8vIDB4MTUxZjdjNzUKbG9hZCAxCmNvbmNhdApsb2cKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDk6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKY2FsbHN1YiBoZWxsb18zCnN0b3JlIDAKYnl0ZWNfMyAvLyAweDE1MWY3Yzc1CmxvYWQgMApjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2wxMDoKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQpibnogbWFpbl9sMTYKdHhuIE9uQ29tcGxldGlvbgppbnRjXzEgLy8gT3B0SW4KPT0KYm56IG1haW5fbDE1CnR4biBPbkNvbXBsZXRpb24KcHVzaGludCA0IC8vIFVwZGF0ZUFwcGxpY2F0aW9uCj09CmJueiBtYWluX2wxNAplcnIKbWFpbl9sMTQ6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CmFzc2VydApjYWxsc3ViIHVwZGF0ZV8yCmludGNfMSAvLyAxCnJldHVybgptYWluX2wxNToKdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKPT0KYXNzZXJ0CmNhbGxzdWIgYmFyZWNyZWF0ZV81CmludGNfMSAvLyAxCnJldHVybgptYWluX2wxNjoKdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKPT0KYXNzZXJ0CmNhbGxzdWIgYmFyZWNyZWF0ZV81CmludGNfMSAvLyAxCnJldHVybgoKLy8gaW50X3RvX2FzY2lpCmludHRvYXNjaWlfMDoKcHJvdG8gMSAxCnB1c2hieXRlcyAweDMwMzEzMjMzMzQzNTM2MzczODM5IC8vICIwMTIzNDU2Nzg5IgpmcmFtZV9kaWcgLTEKaW50Y18xIC8vIDEKZXh0cmFjdDMKcmV0c3ViCgovLyBpdG9hCml0b2FfMToKcHJvdG8gMSAxCmZyYW1lX2RpZyAtMQppbnRjXzAgLy8gMAo9PQpibnogaXRvYV8xX2w1CmZyYW1lX2RpZyAtMQppbnRjXzIgLy8gMTAKLwppbnRjXzAgLy8gMAo+CmJueiBpdG9hXzFfbDQKYnl0ZWNfMCAvLyAiIgppdG9hXzFfbDM6CmZyYW1lX2RpZyAtMQppbnRjXzIgLy8gMTAKJQpjYWxsc3ViIGludHRvYXNjaWlfMApjb25jYXQKYiBpdG9hXzFfbDYKaXRvYV8xX2w0OgpmcmFtZV9kaWcgLTEKaW50Y18yIC8vIDEwCi8KY2FsbHN1YiBpdG9hXzEKYiBpdG9hXzFfbDMKaXRvYV8xX2w1OgpwdXNoYnl0ZXMgMHgzMCAvLyAiMCIKaXRvYV8xX2w2OgpyZXRzdWIKCi8vIHVwZGF0ZQp1cGRhdGVfMjoKcHJvdG8gMCAwCnR4biBTZW5kZXIKZ2xvYmFsIENyZWF0b3JBZGRyZXNzCj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKcHVzaGludCBUTVBMX1VQREFUQUJMRSAvLyBUTVBMX1VQREFUQUJMRQovLyBDaGVjayBhcHAgaXMgdXBkYXRhYmxlCmFzc2VydApyZXRzdWIKCi8vIGhlbGxvCmhlbGxvXzM6CnByb3RvIDEgMQpieXRlY18wIC8vICIiCmJ5dGVjXzAgLy8gIiIKc3RvcmUgNQppbnRjXzAgLy8gMApzdG9yZSA2CmhlbGxvXzNfbDE6CmxvYWQgNgpieXRlY18xIC8vICJ0aW1lcyIKYXBwX2dsb2JhbF9nZXQKPApieiBoZWxsb18zX2wzCmxvYWQgNQpieXRlY18yIC8vICJncmVldGluZyIKYXBwX2dsb2JhbF9nZXQKY29uY2F0CnB1c2hieXRlcyAweDJjMjAgLy8gIiwgIgpjb25jYXQKZnJhbWVfZGlnIC0xCmV4dHJhY3QgMiAwCmNvbmNhdApwdXNoYnl0ZXMgMHgwYSAvLyAiXG4iCmNvbmNhdApzdG9yZSA1CmxvYWQgNgppbnRjXzEgLy8gMQorCnN0b3JlIDYKYiBoZWxsb18zX2wxCmhlbGxvXzNfbDM6CmxvYWQgNQpmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKbGVuCml0b2IKZXh0cmFjdCA2IDAKZnJhbWVfZGlnIDAKY29uY2F0CmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIGhlbGxvCmhlbGxvXzQ6CnByb3RvIDAgMQpieXRlY18wIC8vICIiCmJ5dGVjXzAgLy8gIiIKc3RvcmUgNwppbnRjXzAgLy8gMApzdG9yZSA4CmhlbGxvXzRfbDE6CmxvYWQgOApieXRlY18xIC8vICJ0aW1lcyIKYXBwX2dsb2JhbF9nZXQKPApieiBoZWxsb180X2wzCmxvYWQgNwpieXRlY18yIC8vICJncmVldGluZyIKYXBwX2dsb2JhbF9nZXQKY29uY2F0CnB1c2hieXRlcyAweDJjMjA2ZDc5NzM3NDY1NzI3OTIwNzA2NTcyNzM2ZjZlMGEgLy8gIiwgbXlzdGVyeSBwZXJzb25cbiIKY29uY2F0CnN0b3JlIDcKbG9hZCA4CmludGNfMSAvLyAxCisKc3RvcmUgOApiIGhlbGxvXzRfbDEKaGVsbG9fNF9sMzoKbG9hZCA3CmZyYW1lX2J1cnkgMApmcmFtZV9kaWcgMApsZW4KaXRvYgpleHRyYWN0IDYgMApmcmFtZV9kaWcgMApjb25jYXQKZnJhbWVfYnVyeSAwCnJldHN1YgoKLy8gYmFyZV9jcmVhdGUKYmFyZWNyZWF0ZV81Ogpwcm90byAwIDAKYnl0ZWNfMiAvLyAiZ3JlZXRpbmciCnB1c2hieXRlcyAweDQ4NjU2YzZjNmYgLy8gIkhlbGxvIgphcHBfZ2xvYmFsX3B1dApieXRlY18xIC8vICJ0aW1lcyIKaW50Y18xIC8vIDEKYXBwX2dsb2JhbF9wdXQKaW50Y18xIC8vIDEKcmV0dXJuCgovLyBjcmVhdGUKY3JlYXRlXzY6CnByb3RvIDEgMQpieXRlY18wIC8vICIiCmJ5dGVjXzIgLy8gImdyZWV0aW5nIgpmcmFtZV9kaWcgLTEKZXh0cmFjdCAyIDAKYXBwX2dsb2JhbF9wdXQKYnl0ZWNfMSAvLyAidGltZXMiCmludGNfMSAvLyAxCmFwcF9nbG9iYWxfcHV0CmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApwdXNoYnl0ZXMgMHg1ZiAvLyAiXyIKY29uY2F0CmJ5dGVjXzEgLy8gInRpbWVzIgphcHBfZ2xvYmFsX2dldApjYWxsc3ViIGl0b2FfMQpjb25jYXQKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCmxlbgppdG9iCmV4dHJhY3QgNiAwCmZyYW1lX2RpZyAwCmNvbmNhdApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyBjcmVhdGUKY3JlYXRlXzc6CnByb3RvIDIgMApieXRlY18yIC8vICJncmVldGluZyIKZnJhbWVfZGlnIC0yCmV4dHJhY3QgMiAwCmFwcF9nbG9iYWxfcHV0CmJ5dGVjXzEgLy8gInRpbWVzIgpmcmFtZV9kaWcgLTEKYXBwX2dsb2JhbF9wdXQKaW50Y18xIC8vIDEKcmV0dXJu\",\n\t    \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDgKaW50Y2Jsb2NrIDEKY2FsbHN1YiBjbGVhcl8wCmludGNfMCAvLyAxCnJldHVybgoKLy8gY2xlYXIKY2xlYXJfMDoKcHJvdG8gMCAwCmludGNfMCAvLyAxCnJldHVybg==\"\n\t  },\n\t  \"state\": {\n\t    \"global\": {\n\t      \"num_byte_slices\": 1,\n\t      \"num_uints\": 1\n\t    },\n\t    \"local\": {\n", "      \"num_byte_slices\": 0,\n\t      \"num_uints\": 0\n\t    }\n\t  },\n\t  \"schema\": {\n\t    \"global\": {\n\t      \"declared\": {\n\t        \"greeting\": {\n\t          \"type\": \"bytes\",\n\t          \"key\": \"greeting\",\n", "          \"descr\": \"\"\n\t        },\n\t        \"times\": {\n\t          \"type\": \"uint64\",\n\t          \"key\": \"times\",\n\t          \"descr\": \"\"\n\t        }\n\t      },\n\t      \"reserved\": {}\n\t    },\n", "    \"local\": {\n\t      \"declared\": {},\n\t      \"reserved\": {}\n\t    }\n\t  },\n\t  \"contract\": {\n\t    \"name\": \"LifeCycleApp\",\n\t    \"methods\": [\n\t      {\n\t        \"name\": \"hello\",\n", "        \"args\": [\n\t          {\n\t            \"type\": \"string\",\n\t            \"name\": \"name\"\n\t          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"string\"\n\t        }\n\t      },\n", "      {\n\t        \"name\": \"hello\",\n\t        \"args\": [],\n\t        \"returns\": {\n\t          \"type\": \"string\"\n\t        }\n\t      },\n\t      {\n\t        \"name\": \"create\",\n\t        \"args\": [\n", "          {\n\t            \"type\": \"string\",\n\t            \"name\": \"greeting\",\n\t            \"desc\": \"The greeting\"\n\t          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"string\",\n\t          \"desc\": \"The formatted greeting\"\n\t        },\n", "        \"desc\": \"ABI create method with 1 argument\"\n\t      },\n\t      {\n\t        \"name\": \"create\",\n\t        \"args\": [\n\t          {\n\t            \"type\": \"string\",\n\t            \"name\": \"greeting\"\n\t          },\n\t          {\n", "            \"type\": \"uint32\",\n\t            \"name\": \"times\"\n\t          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"void\"\n\t        },\n\t        \"desc\": \"ABI create method with 2 arguments\"\n\t      }\n\t    ],\n", "    \"networks\": {}\n\t  },\n\t  \"bare_call_config\": {\n\t    \"no_op\": \"CREATE\",\n\t    \"opt_in\": \"CREATE\",\n\t    \"update_application\": \"CALL\"\n\t  }\n\t}\n\t/**\n\t * Defines an onCompletionAction of 'no_op'\n", " */\n\texport type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }\n\t/**\n\t * Defines an onCompletionAction of 'opt_in'\n\t */\n\texport type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }\n\t/**\n\t * Defines an onCompletionAction of 'close_out'\n\t */\n\texport type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }\n", "/**\n\t * Defines an onCompletionAction of 'delete_application'\n\t */\n\texport type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }\n\t/**\n\t * Defines an onCompletionAction of 'update_application'\n\t */\n\texport type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }\n\t/**\n\t * A state record containing a single unsigned integer\n", " */\n\texport type IntegerState = {\n\t  /**\n\t   * Gets the state value as a BigInt \n\t   */\n\t  asBigInt(): bigint\n\t  /**\n\t   * Gets the state value as a number.\n\t   */\n\t  asNumber(): number\n", "}\n\t/**\n\t * A state record containing binary data\n\t */\n\texport type BinaryState = {\n\t  /**\n\t   * Gets the state value as a Uint8Array\n\t   */\n\t  asByteArray(): Uint8Array\n\t  /**\n", "   * Gets the state value as a string\n\t   */\n\t  asString(): string\n\t}\n\t/**\n\t * Defines the types of available calls and state of the LifeCycleApp smart contract.\n\t */\n\texport type LifeCycleApp = {\n\t  /**\n\t   * Maps method signatures / names to their argument and return types.\n", "   */\n\t  methods:\n\t    & Record<'hello(string)string', {\n\t      argsObj: {\n\t        name: string\n\t      }\n\t      argsTuple: [name: string]\n\t      returns: string\n\t    }>\n\t    & Record<'hello()string', {\n", "      argsObj: {\n\t      }\n\t      argsTuple: []\n\t      returns: string\n\t    }>\n\t    & Record<'create(string)string', {\n\t      argsObj: {\n\t        /**\n\t         * The greeting\n\t         */\n", "        greeting: string\n\t      }\n\t      argsTuple: [greeting: string]\n\t      /**\n\t       * The formatted greeting\n\t       */\n\t      returns: string\n\t    }>\n\t    & Record<'create(string,uint32)void', {\n\t      argsObj: {\n", "        greeting: string\n\t        times: number\n\t      }\n\t      argsTuple: [greeting: string, times: number]\n\t      returns: void\n\t    }>\n\t  /**\n\t   * Defines the shape of the global and local state of the application.\n\t   */\n\t  state: {\n", "    global: {\n\t      'greeting'?: BinaryState\n\t      'times'?: IntegerState\n\t    }\n\t  }\n\t}\n\t/**\n\t * Defines the possible abi call signatures\n\t */\n\texport type LifeCycleAppSig = keyof LifeCycleApp['methods']\n", "/**\n\t * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made\n\t */\n\texport type TypedCallParams<TSignature extends LifeCycleAppSig | undefined> = {\n\t  method: TSignature\n\t  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>\n\t} & AppClientCallCoreParams & CoreAppCallArgs\n\t/**\n\t * Defines the arguments required for a bare call\n\t */\n", "export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>\n\t/**\n\t * Maps a method signature from the LifeCycleApp smart contract to the method's arguments in either tuple of struct form\n\t */\n\texport type MethodArgs<TSignature extends LifeCycleAppSig> = LifeCycleApp['methods'][TSignature]['argsObj' | 'argsTuple']\n\t/**\n\t * Maps a method signature from the LifeCycleApp smart contract to the method's return type\n\t */\n\texport type MethodReturn<TSignature extends LifeCycleAppSig> = LifeCycleApp['methods'][TSignature]['returns']\n\t/**\n", " * A factory for available 'create' calls\n\t */\n\texport type LifeCycleAppCreateCalls = (typeof LifeCycleAppCallFactory)['create']\n\t/**\n\t * Defines supported create methods for this smart contract\n\t */\n\texport type LifeCycleAppCreateCallParams =\n\t  | (TypedCallParams<undefined> & (OnCompleteNoOp | OnCompleteOptIn))\n\t  | (TypedCallParams<'create(string)string'> & (OnCompleteNoOp))\n\t  | (TypedCallParams<'create(string,uint32)void'> & (OnCompleteNoOp))\n", "/**\n\t * A factory for available 'update' calls\n\t */\n\texport type LifeCycleAppUpdateCalls = (typeof LifeCycleAppCallFactory)['update']\n\t/**\n\t * Defines supported update methods for this smart contract\n\t */\n\texport type LifeCycleAppUpdateCallParams =\n\t  | TypedCallParams<undefined>\n\t/**\n", " * Defines arguments required for the deploy method.\n\t */\n\texport type LifeCycleAppDeployArgs = {\n\t  deployTimeParams?: TealTemplateParams\n\t  /**\n\t   * A delegate which takes a create call factory and returns the create call params for this smart contract\n\t   */\n\t  createCall?: (callFactory: LifeCycleAppCreateCalls) => LifeCycleAppCreateCallParams\n\t  /**\n\t   * A delegate which takes a update call factory and returns the update call params for this smart contract\n", "   */\n\t  updateCall?: (callFactory: LifeCycleAppUpdateCalls) => LifeCycleAppUpdateCallParams\n\t}\n\t/**\n\t * Exposes methods for constructing all available smart contract calls\n\t */\n\texport abstract class LifeCycleAppCallFactory {\n\t  /**\n\t   * Gets available create call factories\n\t   */\n", "  static get create() {\n\t    return {\n\t      /**\n\t       * Constructs a create call for the LifeCycleApp smart contract using a bare call\n\t       *\n\t       * @param params Any parameters for the call\n\t       * @returns A TypedCallParams object for the call\n\t       */\n\t      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp | OnCompleteOptIn) = {}) {\n\t        return {\n", "          method: undefined,\n\t          methodArgs: undefined,\n\t          ...params,\n\t        }\n\t      },\n\t      /**\n\t       * Constructs a create call for the LifeCycleApp smart contract using the create(string)string ABI method\n\t       *\n\t       * @param args Any args for the contract call\n\t       * @param params Any additional parameters for the call\n", "       * @returns A TypedCallParams object for the call\n\t       */\n\t      createStringString(args: MethodArgs<'create(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {\n\t        return {\n\t          method: 'create(string)string' as const,\n\t          methodArgs: Array.isArray(args) ? args : [args.greeting],\n\t          ...params,\n\t        }\n\t      },\n\t      /**\n", "       * Constructs a create call for the LifeCycleApp smart contract using the create(string,uint32)void ABI method\n\t       *\n\t       * @param args Any args for the contract call\n\t       * @param params Any additional parameters for the call\n\t       * @returns A TypedCallParams object for the call\n\t       */\n\t      createStringUint32Void(args: MethodArgs<'create(string,uint32)void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {\n\t        return {\n\t          method: 'create(string,uint32)void' as const,\n\t          methodArgs: Array.isArray(args) ? args : [args.greeting, args.times],\n", "          ...params,\n\t        }\n\t      },\n\t    }\n\t  }\n\t  /**\n\t   * Gets available update call factories\n\t   */\n\t  static get update() {\n\t    return {\n", "      /**\n\t       * Constructs an update call for the LifeCycleApp smart contract using a bare call\n\t       *\n\t       * @param params Any parameters for the call\n\t       * @returns A TypedCallParams object for the call\n\t       */\n\t      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams = {}) {\n\t        return {\n\t          method: undefined,\n\t          methodArgs: undefined,\n", "          ...params,\n\t        }\n\t      },\n\t    }\n\t  }\n\t  /**\n\t   * Constructs a no op call for the hello(string)string ABI method\n\t   *\n\t   * @param args Any args for the contract call\n\t   * @param params Any additional parameters for the call\n", "   * @returns A TypedCallParams object for the call\n\t   */\n\t  static helloStringString(args: MethodArgs<'hello(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n\t    return {\n\t      method: 'hello(string)string' as const,\n\t      methodArgs: Array.isArray(args) ? args : [args.name],\n\t      ...params,\n\t    }\n\t  }\n\t  /**\n", "   * Constructs a no op call for the hello()string ABI method\n\t   *\n\t   * @param args Any args for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n\t   */\n\t  static helloString(args: MethodArgs<'hello()string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n\t    return {\n\t      method: 'hello()string' as const,\n\t      methodArgs: Array.isArray(args) ? args : [],\n", "      ...params,\n\t    }\n\t  }\n\t}\n\t/**\n\t * A client to make calls to the LifeCycleApp smart contract\n\t */\n\texport class LifeCycleAppClient {\n\t  /**\n\t   * The underlying `ApplicationClient` for when you want to have more flexibility\n", "   */\n\t  public readonly appClient: ApplicationClient\n\t  private readonly sender: SendTransactionFrom | undefined\n\t  /**\n\t   * Creates a new instance of `LifeCycleAppClient`\n\t   *\n\t   * @param appDetails appDetails The details to identify the app to deploy\n\t   * @param algod An algod client instance\n\t   */\n\t  constructor(appDetails: AppDetails, private algod: Algodv2) {\n", "    this.sender = appDetails.sender\n\t    this.appClient = algokit.getAppClient({\n\t      ...appDetails,\n\t      app: APP_SPEC\n\t    }, algod)\n\t  }\n\t  /**\n\t   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type\n\t   *\n\t   * @param result The AppCallTransactionResult to be mapped\n", "   * @param returnValueFormatter An optional delegate to format the return value if required\n\t   * @returns The smart contract response with an updated return value\n\t   */\n\t  protected mapReturnValue<TReturn>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> {\n\t    if(result.return?.decodeError) {\n\t      throw result.return.decodeError\n\t    }\n\t    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined\n\t      ? returnValueFormatter(result.return.returnValue)\n\t      : result.return?.returnValue as TReturn | undefined\n", "      return { ...result, return: returnValue }\n\t  }\n\t  /**\n\t   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP\n\t   *\n\t   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters\n\t   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type\n\t   * @returns The result of the smart contract call\n\t   */\n\t  public async call<TSignature extends keyof LifeCycleApp['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {\n", "    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)\n\t  }\n\t  /**\n\t   * Idempotently deploys the LifeCycleApp smart contract.\n\t   *\n\t   * @param params The arguments for the contract calls and any additional parameters for the call\n\t   * @returns The deployment result\n\t   */\n\t  public deploy(params: LifeCycleAppDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {\n\t    const createArgs = params.createCall?.(LifeCycleAppCallFactory.create)\n", "    const updateArgs = params.updateCall?.(LifeCycleAppCallFactory.update)\n\t    return this.appClient.deploy({\n\t      ...params,\n\t      updateArgs,\n\t      createArgs,\n\t      createOnCompleteAction: createArgs?.onCompleteAction,\n\t    })\n\t  }\n\t  /**\n\t   * Gets available create methods\n", "   */\n\t  public get create() {\n\t    const $this = this\n\t    return {\n\t      /**\n\t       * Creates a new instance of the LifeCycleApp smart contract using a bare call.\n\t       *\n\t       * @param args The arguments for the bare call\n\t       * @returns The create result\n\t       */\n", "      bare(args: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs & (OnCompleteNoOp | OnCompleteOptIn) = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n\t        return $this.appClient.create(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n\t      },\n\t      /**\n\t       * Creates a new instance of the LifeCycleApp smart contract using the create(string)string ABI method.\n\t       *\n\t       * @param args The arguments for the smart contract call\n\t       * @param params Any additional parameters for the call\n\t       * @returns The create result: The formatted greeting\n\t       */\n", "      async createStringString(args: MethodArgs<'create(string)string'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}): Promise<AppCallTransactionResultOfType<MethodReturn<'create(string)string'>>> {\n\t        return $this.mapReturnValue(await $this.appClient.create(LifeCycleAppCallFactory.create.createStringString(args, params)))\n\t      },\n\t      /**\n\t       * Creates a new instance of the LifeCycleApp smart contract using the create(string,uint32)void ABI method.\n\t       *\n\t       * @param args The arguments for the smart contract call\n\t       * @param params Any additional parameters for the call\n\t       * @returns The create result\n\t       */\n", "      async createStringUint32Void(args: MethodArgs<'create(string,uint32)void'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}): Promise<AppCallTransactionResultOfType<MethodReturn<'create(string,uint32)void'>>> {\n\t        return $this.mapReturnValue(await $this.appClient.create(LifeCycleAppCallFactory.create.createStringUint32Void(args, params)))\n\t      },\n\t    }\n\t  }\n\t  /**\n\t   * Gets available update methods\n\t   */\n\t  public get update() {\n\t    const $this = this\n", "    return {\n\t      /**\n\t       * Updates an existing instance of the LifeCycleApp smart contract using a bare call.\n\t       *\n\t       * @param args The arguments for the bare call\n\t       * @returns The update result\n\t       */\n\t      bare(args: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n\t        return $this.appClient.update(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n\t      },\n", "    }\n\t  }\n\t  /**\n\t   * Makes a clear_state call to an existing instance of the LifeCycleApp smart contract.\n\t   *\n\t   * @param args The arguments for the bare call\n\t   * @returns The clear_state result\n\t   */\n\t  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.appClient.clearState(args)\n", "  }\n\t  /**\n\t   * Calls the hello(string)string ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n\t   */\n\t  public helloStringString(args: MethodArgs<'hello(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(LifeCycleAppCallFactory.helloStringString(args, params))\n", "  }\n\t  /**\n\t   * Calls the hello()string ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n\t   */\n\t  public helloString(args: MethodArgs<'hello()string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(LifeCycleAppCallFactory.helloString(args, params))\n", "  }\n\t  /**\n\t   * Extracts a binary state value out of an AppState dictionary\n\t   *\n\t   * @param state The state dictionary containing the state value\n\t   * @param key The key of the state value\n\t   * @returns A BinaryState instance containing the state value, or undefined if the key was not found\n\t   */\n\t  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {\n\t    const value = state[key]\n", "    if (!value) return undefined\n\t    if (!('valueRaw' in value))\n\t      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)\n\t    return {\n\t      asString(): string {\n\t        return value.value\n\t      },\n\t      asByteArray(): Uint8Array {\n\t        return value.valueRaw\n\t      }\n", "    }\n\t  }\n\t  /**\n\t   * Extracts a integer state value out of an AppState dictionary\n\t   *\n\t   * @param state The state dictionary containing the state value\n\t   * @param key The key of the state value\n\t   * @returns An IntegerState instance containing the state value, or undefined if the key was not found\n\t   */\n\t  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {\n", "    const value = state[key]\n\t    if (!value) return undefined\n\t    if ('valueRaw' in value)\n\t      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)\n\t    return {\n\t      asBigInt() {\n\t        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)\n\t      },\n\t      asNumber(): number {\n\t        return typeof value.value === 'bigint' ? Number(value.value) : value.value\n", "      },\n\t    }\n\t  }\n\t  /**\n\t   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value\n\t   */\n\t  public async getGlobalState(): Promise<LifeCycleApp['state']['global']> {\n\t    const state = await this.appClient.getGlobalState()\n\t    return {\n\t      get greeting() {\n", "        return LifeCycleAppClient.getBinaryState(state, 'greeting')\n\t      },\n\t      get times() {\n\t        return LifeCycleAppClient.getIntegerState(state, 'times')\n\t      },\n\t    }\n\t  }\n\t  public compose(): LifeCycleAppComposer {\n\t    const client = this\n\t    const atc = new AtomicTransactionComposer()\n", "    let promiseChain:Promise<unknown> = Promise.resolve()\n\t    const resultMappers: Array<undefined | ((x: any) => any)> = []\n\t    return {\n\t      helloStringString(args: MethodArgs<'hello(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.helloStringString(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      helloString(args: MethodArgs<'hello()string'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.helloString(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n", "        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      get update() {\n\t        const $this = this\n\t        return {\n\t          bare(args?: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs) {\n\t            promiseChain = promiseChain.then(() => client.update.bare({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n\t            resultMappers.push(undefined)\n\t            return $this\n", "          },\n\t        }\n\t      },\n\t      clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {\n\t        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))\n", "        return this\n\t      },\n\t      async atc() {\n\t        await promiseChain\n\t        return atc\n\t      },\n\t      async execute() {\n\t        await promiseChain\n\t        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)\n\t        return {\n", "          ...result,\n\t          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)\n\t        }\n\t      }\n\t    } as unknown as LifeCycleAppComposer\n\t  }\n\t}\n\texport type LifeCycleAppComposer<TReturns extends [...any[]] = []> = {\n\t  /**\n\t   * Calls the hello(string)string ABI method.\n", "   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  helloStringString(args: MethodArgs<'hello(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs): LifeCycleAppComposer<[...TReturns, MethodReturn<'hello(string)string'>]>\n\t  /**\n\t   * Calls the hello()string ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n", "   * @param params Any additional parameters for the call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  helloString(args: MethodArgs<'hello()string'>, params?: AppClientCallCoreParams & CoreAppCallArgs): LifeCycleAppComposer<[...TReturns, MethodReturn<'hello()string'>]>\n\t  /**\n\t   * Gets available update methods\n\t   */\n\t  readonly update: {\n\t    /**\n\t     * Updates an existing instance of the LifeCycleApp smart contract using a bare call.\n", "     *\n\t     * @param args The arguments for the bare call\n\t     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t     */\n\t    bare(args?: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs): LifeCycleAppComposer<[...TReturns, undefined]>\n\t  }\n\t  /**\n\t   * Makes a clear_state call to an existing instance of the LifeCycleApp smart contract.\n\t   *\n\t   * @param args The arguments for the bare call\n", "   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): LifeCycleAppComposer<[...TReturns, undefined]>\n\t  /**\n\t   * Adds a transaction to the composer\n\t   *\n\t   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)\n\t   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.\n\t   */\n\t  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): LifeCycleAppComposer<TReturns>\n", "  /**\n\t   * Returns the underlying AtomicTransactionComposer instance\n\t   */\n\t  atc(): Promise<AtomicTransactionComposer>\n\t  /**\n\t   * Executes the transaction group and returns an array of results\n\t   */\n\t  execute(): Promise<LifeCycleAppComposerResults<TReturns>>\n\t}\n\texport type LifeCycleAppComposerResults<TReturns extends [...any[]]> = {\n", "  returns: TReturns\n\t  groupId: string\n\t  txIds: string[]\n\t  transactions: Transaction[]\n\t}\n"]}
{"filename": "examples/voting/client.spec.ts", "chunked_list": ["import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\n\timport { beforeEach, describe, expect, test } from '@jest/globals'\n\timport * as ed from '@noble/ed25519'\n\timport algosdk, { AtomicTransactionComposer } from 'algosdk'\n\timport invariant from 'tiny-invariant'\n\timport { expectType } from 'tsd'\n\timport { VotingPreconditions, VotingRoundAppClient } from './client'\n\timport { microAlgos } from '@algorandfoundation/algokit-utils'\n\tconst rndInt = (min: number, max: number) => Math.floor(Math.random() * (max - min)) + min\n\tdescribe('voting typed client', () => {\n", "  const localnet = algorandFixture({\n\t    testAccountFunding: microAlgos(100_000_000_000),\n\t  })\n\t  beforeEach(localnet.beforeEach, 10_000)\n\t  let client: VotingRoundAppClient\n\t  beforeEach(() => {\n\t    const { algod, indexer, testAccount } = localnet.context\n\t    client = new VotingRoundAppClient(\n\t      {\n\t        resolveBy: 'creatorAndName',\n", "        sender: testAccount,\n\t        creatorAddress: testAccount.addr,\n\t        findExistingUsing: indexer,\n\t      },\n\t      algod,\n\t    )\n\t  })\n\t  async function createRandomVotingRoundApp() {\n\t    const { algod, testAccount } = localnet.context\n\t    const status = await algod.status().do()\n", "    const lastRound = Number(status['last-round'])\n\t    const round = await algod.block(lastRound).do()\n\t    const currentTime = Number(round.block.ts)\n\t    const quorum = rndInt(1, 1000)\n\t    const questionCount = rndInt(1, 10)\n\t    const questionCounts = new Array(questionCount).fill(0).map((_) => rndInt(1, 10))\n\t    const totalQuestionOptions = questionCounts.reduce((a, b) => a + b, 0)\n\t    const privateKey = Buffer.from(ed.utils.randomPrivateKey())\n\t    const publicKey = await ed.getPublicKey(privateKey)\n\t    const createResult = await client.create.create(\n", "      {\n\t        vote_id: `V${new Date().getTime().toString(32).toUpperCase()}`,\n\t        metadata_ipfs_cid: 'cid',\n\t        start_time: BigInt(currentTime), // todo: allow number and convert\n\t        end_time: BigInt(currentTime + 1000),\n\t        quorum: BigInt(quorum),\n\t        snapshot_public_key: publicKey,\n\t        nft_image_url: 'ipfs://cid',\n\t        option_counts: questionCounts,\n\t      },\n", "      { deletable: true, sendParams: { fee: (1_000 + 1_000 * 4).microAlgos() } },\n\t    )\n\t    expectType<void>(createResult.return)\n\t    const randomAnswerIds = questionCounts.map((c) => rndInt(0, c - 1))\n\t    const decoded = algosdk.decodeAddress(testAccount.addr)\n\t    const signature = await ed.sign(decoded.publicKey, privateKey)\n\t    return {\n\t      algod,\n\t      totalQuestionOptions,\n\t      testAccount,\n", "      privateKey,\n\t      quorum,\n\t      questionCount,\n\t      questionCounts,\n\t      publicKey,\n\t      currentTime,\n\t      signature,\n\t      randomAnswerIds,\n\t    }\n\t  }\n", "  test('struct_mapping', async () => {\n\t    const { testAccount, totalQuestionOptions, privateKey } = await createRandomVotingRoundApp()\n\t    await client.bootstrap(\n\t      {\n\t        fund_min_bal_req: client.appClient.fundAppAccount({\n\t          amount: microAlgos(200_000 + 1_000 + 2_500 + 400 * (1 + 8 * totalQuestionOptions)),\n\t          sendParams: { skipSending: true },\n\t        }),\n\t      },\n\t      {\n", "        boxes: ['V'],\n\t        sendParams: { fee: microAlgos(1_000 + 1_000 * 4) },\n\t      },\n\t    )\n\t    const decoded = algosdk.decodeAddress(testAccount.addr)\n\t    const signature = await ed.sign(decoded.publicKey, privateKey)\n\t    const preconditionsResult = await client.getPreconditions(\n\t      {\n\t        signature,\n\t      },\n", "      {\n\t        sendParams: { fee: microAlgos(1_000 + 3 * 1_000) },\n\t        boxes: [testAccount],\n\t      },\n\t    )\n\t    expect(preconditionsResult.return).toBeDefined()\n\t    expectType<VotingPreconditions | undefined>(preconditionsResult.return)\n\t  })\n\t  test('global_state', async () => {\n\t    const { questionCounts, currentTime, quorum, publicKey, totalQuestionOptions } = await createRandomVotingRoundApp()\n", "    const state = await client.getGlobalState()\n\t    invariant(state.snapshot_public_key !== undefined)\n\t    expect(state.snapshot_public_key.asByteArray()).toEqual(publicKey)\n\t    expect(state.metadata_ipfs_cid!.asString()).toBe('cid')\n\t    expect(state.start_time!.asNumber()).toBe(currentTime)\n\t    expect(state.end_time!.asNumber()).toBe(currentTime + 1000)\n\t    expect(state.close_time!.asNumber()).toBe(0)\n\t    expect(state.quorum!.asNumber()).toBe(quorum)\n\t    expect(state.is_bootstrapped!.asNumber()).toBe(0)\n\t    expect(state.voter_count!.asNumber()).toBe(0)\n", "    expect(state.nft_image_url!.asString()).toBe('ipfs://cid')\n\t    expect(state.nft_asset_id!.asNumber()).toBe(0)\n\t    expect(state.total_options!.asNumber()).toBe(totalQuestionOptions)\n\t    const optionCountsType = new algosdk.ABIArrayDynamicType(new algosdk.ABIUintType(8))\n\t    expect(optionCountsType.decode(state.option_counts!.asByteArray()).map(Number)).toEqual(questionCounts)\n\t  })\n\t  describe('given a usage scenario', () => {\n\t    test('it works with separate transactions', async () => {\n\t      const { signature, testAccount, totalQuestionOptions, randomAnswerIds } = await createRandomVotingRoundApp()\n\t      const preconditionsResultBefore = await client.getPreconditions(\n", "        {\n\t          signature,\n\t        },\n\t        {\n\t          sendParams: { fee: microAlgos(1_000 + 3 * 1_000) },\n\t          boxes: [testAccount],\n\t        },\n\t      )\n\t      expect(preconditionsResultBefore.return?.is_allowed_to_vote).toBe(1n)\n\t      expect(preconditionsResultBefore.return?.has_already_voted).toBe(0n)\n", "      await client.bootstrap(\n\t        {\n\t          fund_min_bal_req: client.appClient.fundAppAccount({\n\t            amount: microAlgos(200_000 + 1_000 + 2_500 + 400 * (1 + 8 * totalQuestionOptions)),\n\t            sendParams: { skipSending: true },\n\t          }),\n\t        },\n\t        {\n\t          boxes: ['V'],\n\t          sendParams: { fee: microAlgos(1_000 + 1_000 * 4) },\n", "        },\n\t      )\n\t      await client.vote(\n\t        {\n\t          answer_ids: randomAnswerIds,\n\t          fund_min_bal_req: client.appClient.fundAppAccount({\n\t            amount: microAlgos(400 * (32 + 2 + randomAnswerIds.length) + 2_500),\n\t            sendParams: { skipSending: true },\n\t          }),\n\t          signature,\n", "        },\n\t        {\n\t          boxes: ['V', testAccount],\n\t          sendParams: { fee: microAlgos(1_000 + 1_000 * 16) },\n\t        },\n\t      )\n\t      const preconditionsResultAfter = await client.getPreconditions(\n\t        {\n\t          signature,\n\t        },\n", "        {\n\t          sendParams: { fee: microAlgos(1_000 + 3 * 1_000) },\n\t          boxes: [testAccount],\n\t        },\n\t      )\n\t      expect(preconditionsResultAfter.return?.has_already_voted).toBe(1n)\n\t    })\n\t    test('it works with manual use of the AtomicTransactionComposer', async () => {\n\t      const { algod, signature, testAccount, totalQuestionOptions, randomAnswerIds } = await createRandomVotingRoundApp()\n\t      const atc = new AtomicTransactionComposer()\n", "      await client.getPreconditions(\n\t        {\n\t          signature,\n\t        },\n\t        {\n\t          sendParams: { fee: microAlgos(1_000 + 3 * 1_000), atc, skipSending: true },\n\t          boxes: [testAccount],\n\t        },\n\t      )\n\t      await client.bootstrap(\n", "        {\n\t          fund_min_bal_req: client.appClient.fundAppAccount({\n\t            amount: microAlgos(200_000 + 1_000 + 2_500 + 400 * (1 + 8 * totalQuestionOptions)),\n\t            sendParams: { skipSending: true },\n\t          }),\n\t        },\n\t        {\n\t          boxes: ['V'],\n\t          sendParams: { fee: microAlgos(1_000 + 1_000 * 4), atc, skipSending: true },\n\t        },\n", "      )\n\t      await client.vote(\n\t        {\n\t          answer_ids: randomAnswerIds,\n\t          fund_min_bal_req: client.appClient.fundAppAccount({\n\t            amount: microAlgos(400 * (32 + 2 + randomAnswerIds.length) + 2_500),\n\t            sendParams: { skipSending: true },\n\t          }),\n\t          signature,\n\t        },\n", "        {\n\t          boxes: ['V', testAccount],\n\t          sendParams: { fee: microAlgos(1_000 + 1_000 * 16), atc, skipSending: true },\n\t        },\n\t      )\n\t      await client.getPreconditions(\n\t        {\n\t          signature,\n\t        },\n\t        {\n", "          sendParams: { fee: microAlgos(1_000 + 3 * 1_000), atc, skipSending: true },\n\t          boxes: [testAccount],\n\t          note: 'hmmm',\n\t        },\n\t      )\n\t      atc.buildGroup()\n\t      const result = await atc.execute(algod, 5)\n\t      expect(result.methodResults).toBeDefined()\n\t    })\n\t    test('it works using the fluent composer', async () => {\n", "      const { signature, testAccount, totalQuestionOptions, randomAnswerIds } = await createRandomVotingRoundApp()\n\t      const result = await client\n\t        .compose()\n\t        .getPreconditions(\n\t          {\n\t            signature,\n\t          },\n\t          {\n\t            sendParams: { fee: microAlgos(1_000 + 3 * 1_000) },\n\t            boxes: [testAccount],\n", "          },\n\t        )\n\t        .bootstrap(\n\t          {\n\t            fund_min_bal_req: client.appClient.fundAppAccount({\n\t              amount: microAlgos(200_000 + 1_000 + 2_500 + 400 * (1 + 8 * totalQuestionOptions)),\n\t              sendParams: { skipSending: true },\n\t            }),\n\t          },\n\t          {\n", "            boxes: ['V'],\n\t            sendParams: { fee: microAlgos(1_000 + 1_000 * 4) },\n\t          },\n\t        )\n\t        .vote(\n\t          {\n\t            answer_ids: randomAnswerIds,\n\t            fund_min_bal_req: client.appClient.fundAppAccount({\n\t              amount: microAlgos(400 * (32 + 2 + randomAnswerIds.length) + 2_500),\n\t              sendParams: { skipSending: true },\n", "            }),\n\t            signature,\n\t          },\n\t          {\n\t            boxes: ['V', testAccount],\n\t            sendParams: { fee: microAlgos(1_000 + 1_000 * 16) },\n\t          },\n\t        )\n\t        .getPreconditions(\n\t          {\n", "            signature,\n\t          },\n\t          {\n\t            sendParams: { fee: microAlgos(1_000 + 3 * 1_000) },\n\t            boxes: [testAccount],\n\t            note: 'hmmm',\n\t          },\n\t        )\n\t        .execute()\n\t      expect(result.returns[0].has_already_voted).toBe(0n)\n", "      expect(result.returns[3].has_already_voted).toBe(1n)\n\t    })\n\t  })\n\t})\n"]}
{"filename": "examples/voting/client.ts", "chunked_list": ["/* eslint-disable */\n\t/**\n\t * This file was automatically generated by @algorandfoundation/algokit-client-generator.\n\t * DO NOT MODIFY IT BY HAND.\n\t * requires: @algorandfoundation/algokit-utils: ^2\n\t */\n\timport * as algokit from '@algorandfoundation/algokit-utils'\n\timport type {\n\t  AppCallTransactionResult,\n\t  AppCallTransactionResultOfType,\n", "  CoreAppCallArgs,\n\t  RawAppCallArgs,\n\t  AppState,\n\t  TealTemplateParams,\n\t  ABIAppCallArg,\n\t} from '@algorandfoundation/algokit-utils/types/app'\n\timport type {\n\t  AppClientCallCoreParams,\n\t  AppClientCompilationParams,\n\t  AppClientDeployCoreParams,\n", "  AppDetails,\n\t  ApplicationClient,\n\t} from '@algorandfoundation/algokit-utils/types/app-client'\n\timport type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'\n\timport type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'\n\timport type { TransactionWithSigner } from 'algosdk'\n\timport { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer } from 'algosdk'\n\texport const APP_SPEC: AppSpec = {\n\t  \"hints\": {\n\t    \"create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void\": {\n", "      \"call_config\": {\n\t        \"no_op\": \"CREATE\"\n\t      }\n\t    },\n\t    \"bootstrap(pay)void\": {\n\t      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n\t    },\n\t    \"close()void\": {\n", "      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n\t    },\n\t    \"get_preconditions(byte[])(uint64,uint64,uint64,uint64)\": {\n\t      \"read_only\": true,\n\t      \"structs\": {\n\t        \"output\": {\n\t          \"name\": \"VotingPreconditions\",\n\t          \"elements\": [\n", "            [\n\t              \"is_voting_open\",\n\t              \"uint64\"\n\t            ],\n\t            [\n\t              \"is_allowed_to_vote\",\n\t              \"uint64\"\n\t            ],\n\t            [\n\t              \"has_already_voted\",\n", "              \"uint64\"\n\t            ],\n\t            [\n\t              \"current_time\",\n\t              \"uint64\"\n\t            ]\n\t          ]\n\t        }\n\t      },\n\t      \"call_config\": {\n", "        \"no_op\": \"CALL\"\n\t      }\n\t    },\n\t    \"vote(pay,byte[],uint8[])void\": {\n\t      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n\t    }\n\t  },\n\t  \"source\": {\n", "    \"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDgKaW50Y2Jsb2NrIDAgMSAxMCA1CmJ5dGVjYmxvY2sgMHggMHgwNjgxMDEgMHg3NjZmNzQ2NTVmNjk2NCAweDZmNzA3NDY5NmY2ZTVmNjM2Zjc1NmU3NDczIDB4Njk3MzVmNjI2ZjZmNzQ3Mzc0NzI2MTcwNzA2NTY0IDB4NzY2Zjc0NjU3MjVmNjM2Zjc1NmU3NCAweDYzNmM2ZjczNjU1Zjc0Njk2ZDY1IDB4NzQ2Zjc0NjE2YzVmNmY3MDc0Njk2ZjZlNzMgMHg1NiAweDczNmU2MTcwNzM2ODZmNzQ1ZjcwNzU2MjZjNjk2MzVmNmI2NTc5IDB4NmQ2NTc0NjE2NDYxNzQ2MTVmNjk3MDY2NzM1ZjYzNjk2NCAweDczNzQ2MTcyNzQ1Zjc0Njk2ZDY1IDB4NjU2ZTY0NWY3NDY5NmQ2NSAweDcxNzU2ZjcyNzU2ZCAweDZlNjY3NDVmNjk2ZDYxNjc2NTVmNzU3MjZjIDB4NmU2Njc0NWY2MTczNzM2NTc0NWY2OTY0IDB4MmMKdHhuIE51bUFwcEFyZ3MKaW50Y18wIC8vIDAKPT0KYm56IG1haW5fbDEyCnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4YWU4OTdmNmIgLy8gImNyZWF0ZShzdHJpbmcsYnl0ZVtdLHN0cmluZyx1aW50NjQsdWludDY0LHVpbnQ4W10sdWludDY0LHN0cmluZyl2b2lkIgo9PQpibnogbWFpbl9sMTEKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhhNGU4ZDE2NCAvLyAiYm9vdHN0cmFwKHBheSl2b2lkIgo9PQpibnogbWFpbl9sMTAKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHg5NjU2MDQ3YSAvLyAiY2xvc2UoKXZvaWQiCj09CmJueiBtYWluX2w5CnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4YmNiMTU4OTYgLy8gImdldF9wcmVjb25kaXRpb25zKGJ5dGVbXSkodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSIKPT0KYm56IG1haW5fbDgKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHg4NGE1M2M2ZSAvLyAidm90ZShwYXksYnl0ZVtdLHVpbnQ4W10pdm9pZCIKPT0KYm56IG1haW5fbDcKZXJyCm1haW5fbDc6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKc3RvcmUgMTEKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgpzdG9yZSAxMgp0eG4gR3JvdXBJbmRleAppbnRjXzEgLy8gMQotCnN0b3JlIDEwCmxvYWQgMTAKZ3R4bnMgVHlwZUVudW0KaW50Y18xIC8vIHBheQo9PQphc3NlcnQKbG9hZCAxMApsb2FkIDExCmxvYWQgMTIKY2FsbHN1YiB2b3RlXzkKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDg6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKY2FsbHN1YiBnZXRwcmVjb25kaXRpb25zXzgKc3RvcmUgOQpwdXNoYnl0ZXMgMHgxNTFmN2M3NSAvLyAweDE1MWY3Yzc1CmxvYWQgOQpjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2w5Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydApjYWxsc3ViIGNsb3NlXzMKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDEwOgp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG4gR3JvdXBJbmRleAppbnRjXzEgLy8gMQotCnN0b3JlIDgKbG9hZCA4Cmd0eG5zIFR5cGVFbnVtCmludGNfMSAvLyBwYXkKPT0KYXNzZXJ0CmxvYWQgOApjYWxsc3ViIGJvb3RzdHJhcF8yCmludGNfMSAvLyAxCnJldHVybgptYWluX2wxMToKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAo9PQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpzdG9yZSAwCnR4bmEgQXBwbGljYXRpb25BcmdzIDIKc3RvcmUgMQp0eG5hIEFwcGxpY2F0aW9uQXJncyAzCnN0b3JlIDIKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNApidG9pCnN0b3JlIDMKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQpidG9pCnN0b3JlIDQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgpzdG9yZSA1CnR4bmEgQXBwbGljYXRpb25BcmdzIDcKYnRvaQpzdG9yZSA2CnR4bmEgQXBwbGljYXRpb25BcmdzIDgKc3RvcmUgNwpsb2FkIDAKbG9hZCAxCmxvYWQgMgpsb2FkIDMKbG9hZCA0CmxvYWQgNQpsb2FkIDYKbG9hZCA3CmNhbGxzdWIgY3JlYXRlXzEKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDEyOgp0eG4gT25Db21wbGV0aW9uCmludGNfMyAvLyBEZWxldGVBcHBsaWNhdGlvbgo9PQpibnogbWFpbl9sMTQKZXJyCm1haW5fbDE0Ogp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQphc3NlcnQKY2FsbHN1YiBkZWxldGVfMAppbnRjXzEgLy8gMQpyZXR1cm4KCi8vIGRlbGV0ZQpkZWxldGVfMDoKcHJvdG8gMCAwCnR4biBTZW5kZXIKZ2xvYmFsIENyZWF0b3JBZGRyZXNzCj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKcHVzaGludCBUTVBMX0RFTEVUQUJMRSAvLyBUTVBMX0RFTEVUQUJMRQovLyBDaGVjayBhcHAgaXMgZGVsZXRhYmxlCmFzc2VydApyZXRzdWIKCi8vIGNyZWF0ZQpjcmVhdGVfMToKcHJvdG8gOCAwCmludGNfMCAvLyAwCmR1cApieXRlY18wIC8vICIiCmludGNfMCAvLyAwCmR1cG4gMgpwdXNoaW50IDI4MDAgLy8gMjgwMAppbnRjXzIgLy8gMTAKKwpzdG9yZSAxMwpjcmVhdGVfMV9sMToKbG9hZCAxMwpnbG9iYWwgT3Bjb2RlQnVkZ2V0Cj4KYm56IGNyZWF0ZV8xX2w1CmZyYW1lX2RpZyAtNQpmcmFtZV9kaWcgLTQKPD0KLy8gRW5kIHRpbWUgc2hvdWxkIGJlIGFmdGVyIHN0YXJ0IHRpbWUKYXNzZXJ0CmZyYW1lX2RpZyAtNApnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCj49Ci8vIEVuZCB0aW1lIHNob3VsZCBiZSBpbiB0aGUgZnV0dXJlCmFzc2VydAppbnRjXzAgLy8gMApieXRlY18yIC8vICJ2b3RlX2lkIgphcHBfZ2xvYmFsX2dldF9leApzdG9yZSAxNQpzdG9yZSAxNApsb2FkIDE1CiEKYXNzZXJ0CmJ5dGVjXzIgLy8gInZvdGVfaWQiCmZyYW1lX2RpZyAtOApleHRyYWN0IDIgMAphcHBfZ2xvYmFsX3B1dAppbnRjXzAgLy8gMApieXRlYyA5IC8vICJzbmFwc2hvdF9wdWJsaWNfa2V5IgphcHBfZ2xvYmFsX2dldF9leApzdG9yZSAxNwpzdG9yZSAxNgpsb2FkIDE3CiEKYXNzZXJ0CmJ5dGVjIDkgLy8gInNuYXBzaG90X3B1YmxpY19rZXkiCmZyYW1lX2RpZyAtNwpleHRyYWN0IDIgMAphcHBfZ2xvYmFsX3B1dAppbnRjXzAgLy8gMApieXRlYyAxMCAvLyAibWV0YWRhdGFfaXBmc19jaWQiCmFwcF9nbG9iYWxfZ2V0X2V4CnN0b3JlIDE5CnN0b3JlIDE4CmxvYWQgMTkKIQphc3NlcnQKYnl0ZWMgMTAgLy8gIm1ldGFkYXRhX2lwZnNfY2lkIgpmcmFtZV9kaWcgLTYKZXh0cmFjdCAyIDAKYXBwX2dsb2JhbF9wdXQKaW50Y18wIC8vIDAKYnl0ZWMgMTEgLy8gInN0YXJ0X3RpbWUiCmFwcF9nbG9iYWxfZ2V0X2V4CnN0b3JlIDIxCnN0b3JlIDIwCmxvYWQgMjEKIQphc3NlcnQKYnl0ZWMgMTEgLy8gInN0YXJ0X3RpbWUiCmZyYW1lX2RpZyAtNQphcHBfZ2xvYmFsX3B1dAppbnRjXzAgLy8gMApieXRlYyAxMiAvLyAiZW5kX3RpbWUiCmFwcF9nbG9iYWxfZ2V0X2V4CnN0b3JlIDIzCnN0b3JlIDIyCmxvYWQgMjMKIQphc3NlcnQKYnl0ZWMgMTIgLy8gImVuZF90aW1lIgpmcmFtZV9kaWcgLTQKYXBwX2dsb2JhbF9wdXQKaW50Y18wIC8vIDAKYnl0ZWMgMTMgLy8gInF1b3J1bSIKYXBwX2dsb2JhbF9nZXRfZXgKc3RvcmUgMjUKc3RvcmUgMjQKbG9hZCAyNQohCmFzc2VydApieXRlYyAxMyAvLyAicXVvcnVtIgpmcmFtZV9kaWcgLTIKYXBwX2dsb2JhbF9wdXQKYnl0ZWMgNCAvLyAiaXNfYm9vdHN0cmFwcGVkIgppbnRjXzAgLy8gMAphcHBfZ2xvYmFsX3B1dApieXRlYyA1IC8vICJ2b3Rlcl9jb3VudCIKaW50Y18wIC8vIDAKYXBwX2dsb2JhbF9wdXQKYnl0ZWMgNiAvLyAiY2xvc2VfdGltZSIKaW50Y18wIC8vIDAKYXBwX2dsb2JhbF9wdXQKaW50Y18wIC8vIDAKYnl0ZWMgMTQgLy8gIm5mdF9pbWFnZV91cmwiCmFwcF9nbG9iYWxfZ2V0X2V4CnN0b3JlIDI3CnN0b3JlIDI2CmxvYWQgMjcKIQphc3NlcnQKYnl0ZWMgMTQgLy8gIm5mdF9pbWFnZV91cmwiCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMAphcHBfZ2xvYmFsX3B1dApieXRlYyAxNSAvLyAibmZ0X2Fzc2V0X2lkIgppbnRjXzAgLy8gMAphcHBfZ2xvYmFsX3B1dApmcmFtZV9kaWcgLTMKaW50Y18wIC8vIDAKZXh0cmFjdF91aW50MTYKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCi8vIG9wdGlvbl9jb3VudHMgc2hvdWxkIGJlIG5vbi1lbXB0eQphc3NlcnQKZnJhbWVfZGlnIC0zCmludGNfMCAvLyAwCmV4dHJhY3RfdWludDE2CmZyYW1lX2J1cnkgMQpmcmFtZV9kaWcgMQpwdXNoaW50IDExMiAvLyAxMTIKPD0KLy8gQ2FuJ3QgaGF2ZSBtb3JlIHRoYW4gMTEyIHF1ZXN0aW9ucwphc3NlcnQKaW50Y18wIC8vIDAKYnl0ZWNfMyAvLyAib3B0aW9uX2NvdW50cyIKYXBwX2dsb2JhbF9nZXRfZXgKc3RvcmUgMjkKc3RvcmUgMjgKbG9hZCAyOQohCmFzc2VydApieXRlY18zIC8vICJvcHRpb25fY291bnRzIgpmcmFtZV9kaWcgLTMKYXBwX2dsb2JhbF9wdXQKYnl0ZWNfMyAvLyAib3B0aW9uX2NvdW50cyIKYXBwX2dsb2JhbF9nZXQKZnJhbWVfYnVyeSAyCmludGNfMCAvLyAwCnN0b3JlIDMxCmZyYW1lX2RpZyAyCmludGNfMCAvLyAwCmV4dHJhY3RfdWludDE2CmZyYW1lX2J1cnkgMwpmcmFtZV9kaWcgMwpzdG9yZSAzMgppbnRjXzAgLy8gMApzdG9yZSAzMwpjcmVhdGVfMV9sMzoKbG9hZCAzMwpsb2FkIDMyCjwKYnogY3JlYXRlXzFfbDYKZnJhbWVfZGlnIDIKaW50Y18xIC8vIDEKbG9hZCAzMwoqCnB1c2hpbnQgMiAvLyAyCisKZ2V0Ynl0ZQpmcmFtZV9idXJ5IDQKbG9hZCAzMQpmcmFtZV9kaWcgNAorCnN0b3JlIDMxCmxvYWQgMzMKaW50Y18xIC8vIDEKKwpzdG9yZSAzMwpiIGNyZWF0ZV8xX2wzCmNyZWF0ZV8xX2w1OgppdHhuX2JlZ2luCnB1c2hpbnQgNiAvLyBhcHBsCml0eG5fZmllbGQgVHlwZUVudW0KaW50Y18wIC8vIDAKaXR4bl9maWVsZCBGZWUKaW50Y18zIC8vIERlbGV0ZUFwcGxpY2F0aW9uCml0eG5fZmllbGQgT25Db21wbGV0aW9uCmJ5dGVjXzEgLy8gMHgwNjgxMDEKaXR4bl9maWVsZCBBcHByb3ZhbFByb2dyYW0KYnl0ZWNfMSAvLyAweDA2ODEwMQppdHhuX2ZpZWxkIENsZWFyU3RhdGVQcm9ncmFtCml0eG5fc3VibWl0CmIgY3JlYXRlXzFfbDEKY3JlYXRlXzFfbDY6CmxvYWQgMzEKc3RvcmUgMzAKbG9hZCAzMApwdXNoaW50IDEyOCAvLyAxMjgKPD0KLy8gQ2FuJ3QgaGF2ZSBtb3JlIHRoYW4gMTI4IHZvdGUgb3B0aW9ucwphc3NlcnQKaW50Y18wIC8vIDAKYnl0ZWMgNyAvLyAidG90YWxfb3B0aW9ucyIKYXBwX2dsb2JhbF9nZXRfZXgKc3RvcmUgMzUKc3RvcmUgMzQKbG9hZCAzNQohCmFzc2VydApieXRlYyA3IC8vICJ0b3RhbF9vcHRpb25zIgpsb2FkIDMwCmFwcF9nbG9iYWxfcHV0CnJldHN1YgoKLy8gYm9vdHN0cmFwCmJvb3RzdHJhcF8yOgpwcm90byAxIDAKaW50Y18wIC8vIDAKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydApieXRlYyA0IC8vICJpc19ib290c3RyYXBwZWQiCmFwcF9nbG9iYWxfZ2V0CiEKLy8gQWxyZWFkeSBib290c3RyYXBwZWQKYXNzZXJ0CmJ5dGVjIDQgLy8gImlzX2Jvb3RzdHJhcHBlZCIKaW50Y18xIC8vIDEKYXBwX2dsb2JhbF9wdXQKcHVzaGludCAyMDM5MDAgLy8gMjAzOTAwCmJ5dGVjIDcgLy8gInRvdGFsX29wdGlvbnMiCmFwcF9nbG9iYWxfZ2V0CnB1c2hpbnQgMzIwMCAvLyAzMjAwCioKKwpzdG9yZSAzNgpmcmFtZV9kaWcgLTEKZ3R4bnMgUmVjZWl2ZXIKZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKPT0KLy8gUGF5bWVudCBtdXN0IGJlIHRvIGFwcCBhZGRyZXNzCmFzc2VydApsb2FkIDM2Cml0b2IKbG9nCmZyYW1lX2RpZyAtMQpndHhucyBBbW91bnQKbG9hZCAzNgo9PQovLyBQYXltZW50IG11c3QgYmUgZm9yIHRoZSBleGFjdCBtaW4gYmFsYW5jZSByZXF1aXJlbWVudAphc3NlcnQKYnl0ZWMgOCAvLyAiViIKYnl0ZWMgNyAvLyAidG90YWxfb3B0aW9ucyIKYXBwX2dsb2JhbF9nZXQKcHVzaGludCA4IC8vIDgKKgpib3hfY3JlYXRlCnBvcApyZXRzdWIKCi8vIGNsb3NlCmNsb3NlXzM6CnByb3RvIDAgMApieXRlY18wIC8vICIiCmludGNfMCAvLyAwCmR1cG4gMgp0eG4gU2VuZGVyCmdsb2JhbCBDcmVhdG9yQWRkcmVzcwo9PQovLyB1bmF1dGhvcml6ZWQKYXNzZXJ0CnB1c2hpbnQgMjAwMDAgLy8gMjAwMDAKaW50Y18yIC8vIDEwCisKc3RvcmUgMzcKY2xvc2VfM19sMToKbG9hZCAzNwpnbG9iYWwgT3Bjb2RlQnVkZ2V0Cj4KYm56IGNsb3NlXzNfbDE3CmJ5dGVjIDYgLy8gImNsb3NlX3RpbWUiCmFwcF9nbG9iYWxfZ2V0CmludGNfMCAvLyAwCj09Ci8vIEFscmVhZHkgY2xvc2VkCmFzc2VydApieXRlYyA2IC8vICJjbG9zZV90aW1lIgpnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCmFwcF9nbG9iYWxfcHV0CnB1c2hieXRlcyAweDdiMjI3Mzc0NjE2ZTY0NjE3MjY0MjIzYTIyNjE3MjYzMzYzOTIyMmMyMjY0NjU3MzYzNzI2OTcwNzQ2OTZmNmUyMjNhMjI1NDY4Njk3MzIwNjk3MzIwNjEyMDc2NmY3NDY5NmU2NzIwNzI2NTczNzU2Yzc0MjA0ZTQ2NTQyMDY2NmY3MjIwNzY2Zjc0Njk2ZTY3MjA3MjZmNzU2ZTY0MjA3NzY5NzQ2ODIwNDk0NDIwIC8vICJ7XCJzdGFuZGFyZFwiOlwiYXJjNjlcIixcImRlc2NyaXB0aW9uXCI6XCJUaGlzIGlzIGEgdm90aW5nIHJlc3VsdCBORlQgZm9yIHZvdGluZyByb3VuZCB3aXRoIElEICIKYnl0ZWNfMiAvLyAidm90ZV9pZCIKYXBwX2dsb2JhbF9nZXQKY29uY2F0CnB1c2hieXRlcyAweDJlMjIyYzIyNzA3MjZmNzA2NTcyNzQ2OTY1NzMyMjNhN2IyMjZkNjU3NDYxNjQ2MTc0NjEyMjNhMjI2OTcwNjY3MzNhMmYyZiAvLyAiLlwiLFwicHJvcGVydGllc1wiOntcIm1ldGFkYXRhXCI6XCJpcGZzOi8vIgpjb25jYXQKYnl0ZWMgMTAgLy8gIm1ldGFkYXRhX2lwZnNfY2lkIgphcHBfZ2xvYmFsX2dldApjb25jYXQKcHVzaGJ5dGVzIDB4MjIyYzIyNjk2NDIyM2EyMiAvLyAiXCIsXCJpZFwiOlwiIgpjb25jYXQKYnl0ZWNfMiAvLyAidm90ZV9pZCIKYXBwX2dsb2JhbF9nZXQKY29uY2F0CnB1c2hieXRlcyAweDIyMmMyMjcxNzU2ZjcyNzU2ZDIyM2EgLy8gIlwiLFwicXVvcnVtXCI6Igpjb25jYXQKYnl0ZWMgMTMgLy8gInF1b3J1bSIKYXBwX2dsb2JhbF9nZXQKY2FsbHN1YiBpdG9hXzcKY29uY2F0CnB1c2hieXRlcyAweDJjMjI3NjZmNzQ2NTcyNDM2Zjc1NmU3NDIyM2EgLy8gIixcInZvdGVyQ291bnRcIjoiCmNvbmNhdApieXRlYyA1IC8vICJ2b3Rlcl9jb3VudCIKYXBwX2dsb2JhbF9nZXQKY2FsbHN1YiBpdG9hXzcKY29uY2F0CnB1c2hieXRlcyAweDJjMjI3NDYxNmM2YzY5NjU3MzIyM2E1YiAvLyAiLFwidGFsbGllc1wiOlsiCmNvbmNhdApzdG9yZSAzOApieXRlY18zIC8vICJvcHRpb25fY291bnRzIgphcHBfZ2xvYmFsX2dldApmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKaW50Y18wIC8vIDAKZXh0cmFjdF91aW50MTYKZnJhbWVfYnVyeSAxCmZyYW1lX2RpZyAxCnN0b3JlIDM5CmludGNfMCAvLyAwCnN0b3JlIDQwCmludGNfMCAvLyAwCnN0b3JlIDQxCmludGNfMCAvLyAwCnN0b3JlIDQyCmNsb3NlXzNfbDM6CmxvYWQgNDIKbG9hZCAzOQo8CmJ6IGNsb3NlXzNfbDE4CmZyYW1lX2RpZyAwCmludGNfMSAvLyAxCmxvYWQgNDIKKgpwdXNoaW50IDIgLy8gMgorCmdldGJ5dGUKZnJhbWVfYnVyeSAyCmZyYW1lX2RpZyAyCnN0b3JlIDQzCmludGNfMCAvLyAwCnN0b3JlIDQ0CmNsb3NlXzNfbDU6CmxvYWQgNDQKbG9hZCA0Mwo8CmJueiBjbG9zZV8zX2w3CmxvYWQgNDIKaW50Y18xIC8vIDEKKwpzdG9yZSA0MgpiIGNsb3NlXzNfbDMKY2xvc2VfM19sNzoKcHVzaGludCA4IC8vIDgKbG9hZCA0MQoqCnN0b3JlIDQ1CmJ5dGVjIDggLy8gIlYiCmxvYWQgNDUKcHVzaGludCA4IC8vIDgKYm94X2V4dHJhY3QKYnRvaQpzdG9yZSA0MApsb2FkIDM4CmxvYWQgNDQKaW50Y18wIC8vIDAKPT0KYm56IGNsb3NlXzNfbDE2CmJ5dGVjXzAgLy8gIiIKY2xvc2VfM19sOToKY29uY2F0CmxvYWQgNDAKY2FsbHN1YiBpdG9hXzcKY29uY2F0CmxvYWQgNDQKbG9hZCA0MwppbnRjXzEgLy8gMQotCj09CmJueiBjbG9zZV8zX2wxMgpieXRlYyAxNiAvLyAiLCIKY2xvc2VfM19sMTE6CmNvbmNhdApzdG9yZSAzOApsb2FkIDQxCmludGNfMSAvLyAxCisKc3RvcmUgNDEKbG9hZCA0NAppbnRjXzEgLy8gMQorCnN0b3JlIDQ0CmIgY2xvc2VfM19sNQpjbG9zZV8zX2wxMjoKcHVzaGJ5dGVzIDB4NWQgLy8gIl0iCmxvYWQgNDIKbG9hZCAzOQppbnRjXzEgLy8gMQotCj09CmJueiBjbG9zZV8zX2wxNQpieXRlYyAxNiAvLyAiLCIKY2xvc2VfM19sMTQ6CmNvbmNhdApiIGNsb3NlXzNfbDExCmNsb3NlXzNfbDE1OgpieXRlY18wIC8vICIiCmIgY2xvc2VfM19sMTQKY2xvc2VfM19sMTY6CnB1c2hieXRlcyAweDViIC8vICJbIgpiIGNsb3NlXzNfbDkKY2xvc2VfM19sMTc6Cml0eG5fYmVnaW4KcHVzaGludCA2IC8vIGFwcGwKaXR4bl9maWVsZCBUeXBlRW51bQppbnRjXzAgLy8gMAppdHhuX2ZpZWxkIEZlZQppbnRjXzMgLy8gRGVsZXRlQXBwbGljYXRpb24KaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KYnl0ZWNfMSAvLyAweDA2ODEwMQppdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQpieXRlY18xIC8vIDB4MDY4MTAxCml0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KaXR4bl9zdWJtaXQKYiBjbG9zZV8zX2wxCmNsb3NlXzNfbDE4OgppdHhuX2JlZ2luCnB1c2hpbnQgMyAvLyBhY2ZnCml0eG5fZmllbGQgVHlwZUVudW0KaW50Y18xIC8vIDEKaXR4bl9maWVsZCBDb25maWdBc3NldFRvdGFsCmludGNfMCAvLyAwCml0eG5fZmllbGQgQ29uZmlnQXNzZXREZWNpbWFscwppbnRjXzAgLy8gMAppdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0RGVmYXVsdEZyb3plbgpwdXNoYnl0ZXMgMHg1YjU2NGY1NDQ1MjA1MjQ1NTM1NTRjNTQ1ZDIwIC8vICJbVk9URSBSRVNVTFRdICIKYnl0ZWNfMiAvLyAidm90ZV9pZCIKYXBwX2dsb2JhbF9nZXQKY29uY2F0Cml0eG5fZmllbGQgQ29uZmlnQXNzZXROYW1lCnB1c2hieXRlcyAweDU2NGY1NDQ1NTI1MzRjNTQgLy8gIlZPVEVSU0xUIgppdHhuX2ZpZWxkIENvbmZpZ0Fzc2V0VW5pdE5hbWUKYnl0ZWMgMTQgLy8gIm5mdF9pbWFnZV91cmwiCmFwcF9nbG9iYWxfZ2V0Cml0eG5fZmllbGQgQ29uZmlnQXNzZXRVUkwKbG9hZCAzOApwdXNoYnl0ZXMgMHg1ZDdkN2QgLy8gIl19fSIKY29uY2F0Cml0eG5fZmllbGQgTm90ZQppdHhuX3N1Ym1pdApieXRlYyAxNSAvLyAibmZ0X2Fzc2V0X2lkIgppdHhuIENyZWF0ZWRBc3NldElECmFwcF9nbG9iYWxfcHV0CnJldHN1YgoKLy8gYWxsb3dlZF90b192b3RlCmFsbG93ZWR0b3ZvdGVfNDoKcHJvdG8gMSAxCnB1c2hpbnQgMjAwMCAvLyAyMDAwCmludGNfMiAvLyAxMAorCnN0b3JlIDQ2CmFsbG93ZWR0b3ZvdGVfNF9sMToKbG9hZCA0NgpnbG9iYWwgT3Bjb2RlQnVkZ2V0Cj4KYnogYWxsb3dlZHRvdm90ZV80X2wzCml0eG5fYmVnaW4KcHVzaGludCA2IC8vIGFwcGwKaXR4bl9maWVsZCBUeXBlRW51bQppbnRjXzAgLy8gMAppdHhuX2ZpZWxkIEZlZQppbnRjXzMgLy8gRGVsZXRlQXBwbGljYXRpb24KaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KYnl0ZWNfMSAvLyAweDA2ODEwMQppdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQpieXRlY18xIC8vIDB4MDY4MTAxCml0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KaXR4bl9zdWJtaXQKYiBhbGxvd2VkdG92b3RlXzRfbDEKYWxsb3dlZHRvdm90ZV80X2wzOgp0eG4gU2VuZGVyCmZyYW1lX2RpZyAtMQpieXRlYyA5IC8vICJzbmFwc2hvdF9wdWJsaWNfa2V5IgphcHBfZ2xvYmFsX2dldAplZDI1NTE5dmVyaWZ5X2JhcmUKcmV0c3ViCgovLyB2b3Rpbmdfb3Blbgp2b3RpbmdvcGVuXzU6CnByb3RvIDAgMQpieXRlYyA0IC8vICJpc19ib290c3RyYXBwZWQiCmFwcF9nbG9iYWxfZ2V0CmludGNfMSAvLyAxCj09CmJ5dGVjIDYgLy8gImNsb3NlX3RpbWUiCmFwcF9nbG9iYWxfZ2V0CmludGNfMCAvLyAwCj09CiYmCmdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKYnl0ZWMgMTEgLy8gInN0YXJ0X3RpbWUiCmFwcF9nbG9iYWxfZ2V0Cj49CiYmCmdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKYnl0ZWMgMTIgLy8gImVuZF90aW1lIgphcHBfZ2xvYmFsX2dldAo8CiYmCnJldHN1YgoKLy8gYWxyZWFkeV92b3RlZAphbHJlYWR5dm90ZWRfNjoKcHJvdG8gMCAxCmJ5dGVjXzAgLy8gIiIKdHhuIFNlbmRlcgpmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKbGVuCnB1c2hpbnQgMzIgLy8gMzIKPT0KYXNzZXJ0CmZyYW1lX2RpZyAwCmJveF9sZW4Kc3RvcmUgNDgKc3RvcmUgNDcKbG9hZCA0OApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyBpdG9hCml0b2FfNzoKcHJvdG8gMSAxCmZyYW1lX2RpZyAtMQppbnRjXzAgLy8gMAo9PQpibnogaXRvYV83X2w1CmZyYW1lX2RpZyAtMQppbnRjXzIgLy8gMTAKLwppbnRjXzAgLy8gMAo+CmJueiBpdG9hXzdfbDQKYnl0ZWNfMCAvLyAiIgppdG9hXzdfbDM6CnB1c2hieXRlcyAweDMwMzEzMjMzMzQzNTM2MzczODM5IC8vICIwMTIzNDU2Nzg5IgpmcmFtZV9kaWcgLTEKaW50Y18yIC8vIDEwCiUKaW50Y18xIC8vIDEKZXh0cmFjdDMKY29uY2F0CmIgaXRvYV83X2w2Cml0b2FfN19sNDoKZnJhbWVfZGlnIC0xCmludGNfMiAvLyAxMAovCmNhbGxzdWIgaXRvYV83CmIgaXRvYV83X2wzCml0b2FfN19sNToKcHVzaGJ5dGVzIDB4MzAgLy8gIjAiCml0b2FfN19sNjoKcmV0c3ViCgovLyBnZXRfcHJlY29uZGl0aW9ucwpnZXRwcmVjb25kaXRpb25zXzg6CnByb3RvIDEgMQpieXRlY18wIC8vICIiCmludGNfMCAvLyAwCmR1cG4gNQpieXRlY18wIC8vICIiCmR1cApjYWxsc3ViIHZvdGluZ29wZW5fNQpmcmFtZV9idXJ5IDEKZnJhbWVfZGlnIC0xCmV4dHJhY3QgMiAwCmNhbGxzdWIgYWxsb3dlZHRvdm90ZV80CmZyYW1lX2J1cnkgMgpjYWxsc3ViIGFscmVhZHl2b3RlZF82CmZyYW1lX2J1cnkgMwpnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCmZyYW1lX2J1cnkgNApmcmFtZV9kaWcgMQppdG9iCmZyYW1lX2RpZyAyCml0b2IKY29uY2F0CmZyYW1lX2RpZyAzCml0b2IKY29uY2F0CmZyYW1lX2RpZyA0Cml0b2IKY29uY2F0CmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIHZvdGUKdm90ZV85Ogpwcm90byAzIDAKYnl0ZWNfMCAvLyAiIgppbnRjXzAgLy8gMApkdXBuIDcKYnl0ZWNfMCAvLyAiIgpwdXNoaW50IDc3MDAgLy8gNzcwMAppbnRjXzIgLy8gMTAKKwpzdG9yZSA0OQp2b3RlXzlfbDE6CmxvYWQgNDkKZ2xvYmFsIE9wY29kZUJ1ZGdldAo+CmJueiB2b3RlXzlfbDUKZnJhbWVfZGlnIC0yCmV4dHJhY3QgMiAwCmNhbGxzdWIgYWxsb3dlZHRvdm90ZV80Ci8vIE5vdCBhbGxvd2VkIHRvIHZvdGUKYXNzZXJ0CmNhbGxzdWIgdm90aW5nb3Blbl81Ci8vIFZvdGluZyBub3Qgb3Blbgphc3NlcnQKY2FsbHN1YiBhbHJlYWR5dm90ZWRfNgohCi8vIEFscmVhZHkgdm90ZWQKYXNzZXJ0CmJ5dGVjXzMgLy8gIm9wdGlvbl9jb3VudHMiCmFwcF9nbG9iYWxfZ2V0CmZyYW1lX2J1cnkgMApmcmFtZV9kaWcgMAppbnRjXzAgLy8gMApleHRyYWN0X3VpbnQxNgpmcmFtZV9idXJ5IDEKZnJhbWVfZGlnIDEKc3RvcmUgNTAKZnJhbWVfZGlnIC0xCmludGNfMCAvLyAwCmV4dHJhY3RfdWludDE2CmZyYW1lX2J1cnkgMgpmcmFtZV9kaWcgMgpsb2FkIDUwCj09Ci8vIE51bWJlciBvZiBhbnN3ZXJzIGluY29ycmVjdAphc3NlcnQKcHVzaGludCAyNTAwIC8vIDI1MDAKcHVzaGludCAzNCAvLyAzNAppbnRjXzEgLy8gMQpmcmFtZV9kaWcgLTEKaW50Y18wIC8vIDAKZXh0cmFjdF91aW50MTYKZnJhbWVfYnVyeSA0CmZyYW1lX2RpZyA0CioKKwpwdXNoaW50IDQwMCAvLyA0MDAKKgorCnN0b3JlIDUxCmZyYW1lX2RpZyAtMwpndHhucyBSZWNlaXZlcgpnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwo9PQovLyBQYXltZW50IG11c3QgYmUgdG8gYXBwIGFkZHJlc3MKYXNzZXJ0CmxvYWQgNTEKaXRvYgpsb2cKZnJhbWVfZGlnIC0zCmd0eG5zIEFtb3VudApsb2FkIDUxCj09Ci8vIFBheW1lbnQgbXVzdCBiZSB0aGUgZXhhY3QgbWluIGJhbGFuY2UgcmVxdWlyZW1lbnQKYXNzZXJ0CmludGNfMCAvLyAwCnN0b3JlIDUyCmludGNfMCAvLyAwCnN0b3JlIDUzCnZvdGVfOV9sMzoKbG9hZCA1Mwpsb2FkIDUwCjwKYnogdm90ZV85X2w2CmZyYW1lX2RpZyAtMQppbnRjXzEgLy8gMQpsb2FkIDUzCioKcHVzaGludCAyIC8vIDIKKwpnZXRieXRlCmZyYW1lX2J1cnkgNQpmcmFtZV9kaWcgMAppbnRjXzEgLy8gMQpsb2FkIDUzCioKcHVzaGludCAyIC8vIDIKKwpnZXRieXRlCmZyYW1lX2J1cnkgNwpmcmFtZV9kaWcgNQpmcmFtZV9kaWcgNwo8Ci8vIEFuc3dlciBvcHRpb24gaW5kZXggaW52YWxpZAphc3NlcnQKcHVzaGludCA4IC8vIDgKbG9hZCA1MgpmcmFtZV9kaWcgNQorCioKc3RvcmUgNTQKYnl0ZWMgOCAvLyAiViIKbG9hZCA1NApwdXNoaW50IDggLy8gOApib3hfZXh0cmFjdApidG9pCnN0b3JlIDU1CmJ5dGVjIDggLy8gIlYiCmxvYWQgNTQKbG9hZCA1NQppbnRjXzEgLy8gMQorCml0b2IKYm94X3JlcGxhY2UKbG9hZCA1MgpmcmFtZV9kaWcgNworCnN0b3JlIDUyCmxvYWQgNTMKaW50Y18xIC8vIDEKKwpzdG9yZSA1MwpiIHZvdGVfOV9sMwp2b3RlXzlfbDU6Cml0eG5fYmVnaW4KcHVzaGludCA2IC8vIGFwcGwKaXR4bl9maWVsZCBUeXBlRW51bQppbnRjXzAgLy8gMAppdHhuX2ZpZWxkIEZlZQppbnRjXzMgLy8gRGVsZXRlQXBwbGljYXRpb24KaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KYnl0ZWNfMSAvLyAweDA2ODEwMQppdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQpieXRlY18xIC8vIDB4MDY4MTAxCml0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KaXR4bl9zdWJtaXQKYiB2b3RlXzlfbDEKdm90ZV85X2w2Ogp0eG4gU2VuZGVyCmZyYW1lX2J1cnkgOQpmcmFtZV9kaWcgOQpsZW4KcHVzaGludCAzMiAvLyAzMgo9PQphc3NlcnQKZnJhbWVfZGlnIDkKYm94X2RlbApwb3AKZnJhbWVfZGlnIDkKZnJhbWVfZGlnIC0xCmJveF9wdXQKYnl0ZWMgNSAvLyAidm90ZXJfY291bnQiCmJ5dGVjIDUgLy8gInZvdGVyX2NvdW50IgphcHBfZ2xvYmFsX2dldAppbnRjXzEgLy8gMQorCmFwcF9nbG9iYWxfcHV0CnJldHN1Yg==\",\n\t    \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDgKcHVzaGludCAwIC8vIDAKcmV0dXJu\"\n\t  },\n\t  \"state\": {\n\t    \"global\": {\n\t      \"num_byte_slices\": 5,\n\t      \"num_uints\": 8\n\t    },\n\t    \"local\": {\n\t      \"num_byte_slices\": 0,\n", "      \"num_uints\": 0\n\t    }\n\t  },\n\t  \"schema\": {\n\t    \"global\": {\n\t      \"declared\": {\n\t        \"close_time\": {\n\t          \"type\": \"uint64\",\n\t          \"key\": \"close_time\",\n\t          \"descr\": \"The unix timestamp of the time the vote was closed\"\n", "        },\n\t        \"end_time\": {\n\t          \"type\": \"uint64\",\n\t          \"key\": \"end_time\",\n\t          \"descr\": \"The unix timestamp of the ending time of voting\"\n\t        },\n\t        \"is_bootstrapped\": {\n\t          \"type\": \"uint64\",\n\t          \"key\": \"is_bootstrapped\",\n\t          \"descr\": \"Whether or not the contract has been bootstrapped with answers\"\n", "        },\n\t        \"metadata_ipfs_cid\": {\n\t          \"type\": \"bytes\",\n\t          \"key\": \"metadata_ipfs_cid\",\n\t          \"descr\": \"The IPFS content ID of the voting metadata file\"\n\t        },\n\t        \"nft_asset_id\": {\n\t          \"type\": \"uint64\",\n\t          \"key\": \"nft_asset_id\",\n\t          \"descr\": \"The asset ID of a result NFT if one has been created\"\n", "        },\n\t        \"nft_image_url\": {\n\t          \"type\": \"bytes\",\n\t          \"key\": \"nft_image_url\",\n\t          \"descr\": \"The IPFS URL of the default image to use as the media of the result NFT\"\n\t        },\n\t        \"option_counts\": {\n\t          \"type\": \"bytes\",\n\t          \"key\": \"option_counts\",\n\t          \"descr\": \"The number of options for each question\"\n", "        },\n\t        \"quorum\": {\n\t          \"type\": \"uint64\",\n\t          \"key\": \"quorum\",\n\t          \"descr\": \"The minimum number of voters to reach quorum\"\n\t        },\n\t        \"snapshot_public_key\": {\n\t          \"type\": \"bytes\",\n\t          \"key\": \"snapshot_public_key\",\n\t          \"descr\": \"The public key of the Ed25519 compatible private key that was used to encrypt entries in the vote gating snapshot\"\n", "        },\n\t        \"start_time\": {\n\t          \"type\": \"uint64\",\n\t          \"key\": \"start_time\",\n\t          \"descr\": \"The unix timestamp of the starting time of voting\"\n\t        },\n\t        \"total_options\": {\n\t          \"type\": \"uint64\",\n\t          \"key\": \"total_options\",\n\t          \"descr\": \"The total number of options\"\n", "        },\n\t        \"vote_id\": {\n\t          \"type\": \"bytes\",\n\t          \"key\": \"vote_id\",\n\t          \"descr\": \"The identifier of this voting round\"\n\t        },\n\t        \"voter_count\": {\n\t          \"type\": \"uint64\",\n\t          \"key\": \"voter_count\",\n\t          \"descr\": \"The minimum number of voters who have voted\"\n", "        }\n\t      },\n\t      \"reserved\": {}\n\t    },\n\t    \"local\": {\n\t      \"declared\": {},\n\t      \"reserved\": {}\n\t    }\n\t  },\n\t  \"contract\": {\n", "    \"name\": \"VotingRoundApp\",\n\t    \"methods\": [\n\t      {\n\t        \"name\": \"create\",\n\t        \"args\": [\n\t          {\n\t            \"type\": \"string\",\n\t            \"name\": \"vote_id\"\n\t          },\n\t          {\n", "            \"type\": \"byte[]\",\n\t            \"name\": \"snapshot_public_key\"\n\t          },\n\t          {\n\t            \"type\": \"string\",\n\t            \"name\": \"metadata_ipfs_cid\"\n\t          },\n\t          {\n\t            \"type\": \"uint64\",\n\t            \"name\": \"start_time\"\n", "          },\n\t          {\n\t            \"type\": \"uint64\",\n\t            \"name\": \"end_time\"\n\t          },\n\t          {\n\t            \"type\": \"uint8[]\",\n\t            \"name\": \"option_counts\"\n\t          },\n\t          {\n", "            \"type\": \"uint64\",\n\t            \"name\": \"quorum\"\n\t          },\n\t          {\n\t            \"type\": \"string\",\n\t            \"name\": \"nft_image_url\"\n\t          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"void\"\n", "        }\n\t      },\n\t      {\n\t        \"name\": \"bootstrap\",\n\t        \"args\": [\n\t          {\n\t            \"type\": \"pay\",\n\t            \"name\": \"fund_min_bal_req\"\n\t          }\n\t        ],\n", "        \"returns\": {\n\t          \"type\": \"void\"\n\t        }\n\t      },\n\t      {\n\t        \"name\": \"close\",\n\t        \"args\": [],\n\t        \"returns\": {\n\t          \"type\": \"void\"\n\t        }\n", "      },\n\t      {\n\t        \"name\": \"get_preconditions\",\n\t        \"args\": [\n\t          {\n\t            \"type\": \"byte[]\",\n\t            \"name\": \"signature\",\n\t            \"desc\": \"The signature for the given voter account\"\n\t          }\n\t        ],\n", "        \"returns\": {\n\t          \"type\": \"(uint64,uint64,uint64,uint64)\",\n\t          \"desc\": \"The precondition values\"\n\t        },\n\t        \"desc\": \"Returns the calculated pre-conditions for the voting round.\"\n\t      },\n\t      {\n\t        \"name\": \"vote\",\n\t        \"args\": [\n\t          {\n", "            \"type\": \"pay\",\n\t            \"name\": \"fund_min_bal_req\"\n\t          },\n\t          {\n\t            \"type\": \"byte[]\",\n\t            \"name\": \"signature\"\n\t          },\n\t          {\n\t            \"type\": \"uint8[]\",\n\t            \"name\": \"answer_ids\"\n", "          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"void\"\n\t        }\n\t      }\n\t    ],\n\t    \"networks\": {}\n\t  },\n\t  \"bare_call_config\": {\n", "    \"delete_application\": \"CALL\"\n\t  }\n\t}\n\t/**\n\t * Defines an onCompletionAction of 'no_op'\n\t */\n\texport type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }\n\t/**\n\t * Defines an onCompletionAction of 'opt_in'\n\t */\n", "export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }\n\t/**\n\t * Defines an onCompletionAction of 'close_out'\n\t */\n\texport type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }\n\t/**\n\t * Defines an onCompletionAction of 'delete_application'\n\t */\n\texport type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }\n\t/**\n", " * Defines an onCompletionAction of 'update_application'\n\t */\n\texport type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }\n\t/**\n\t * A state record containing a single unsigned integer\n\t */\n\texport type IntegerState = {\n\t  /**\n\t   * Gets the state value as a BigInt \n\t   */\n", "  asBigInt(): bigint\n\t  /**\n\t   * Gets the state value as a number.\n\t   */\n\t  asNumber(): number\n\t}\n\t/**\n\t * A state record containing binary data\n\t */\n\texport type BinaryState = {\n", "  /**\n\t   * Gets the state value as a Uint8Array\n\t   */\n\t  asByteArray(): Uint8Array\n\t  /**\n\t   * Gets the state value as a string\n\t   */\n\t  asString(): string\n\t}\n\t/**\n", " * Defines the types of available calls and state of the VotingRoundApp smart contract.\n\t */\n\texport type VotingRoundApp = {\n\t  /**\n\t   * Maps method signatures / names to their argument and return types.\n\t   */\n\t  methods:\n\t    & Record<'create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void' | 'create', {\n\t      argsObj: {\n\t        vote_id: string\n", "        snapshot_public_key: Uint8Array\n\t        metadata_ipfs_cid: string\n\t        start_time: bigint | number\n\t        end_time: bigint | number\n\t        option_counts: number[]\n\t        quorum: bigint | number\n\t        nft_image_url: string\n\t      }\n\t      argsTuple: [vote_id: string, snapshot_public_key: Uint8Array, metadata_ipfs_cid: string, start_time: bigint | number, end_time: bigint | number, option_counts: number[], quorum: bigint | number, nft_image_url: string]\n\t      returns: void\n", "    }>\n\t    & Record<'bootstrap(pay)void' | 'bootstrap', {\n\t      argsObj: {\n\t        fund_min_bal_req: TransactionToSign | Transaction | Promise<SendTransactionResult>\n\t      }\n\t      argsTuple: [fund_min_bal_req: TransactionToSign | Transaction | Promise<SendTransactionResult>]\n\t      returns: void\n\t    }>\n\t    & Record<'close()void' | 'close', {\n\t      argsObj: {\n", "      }\n\t      argsTuple: []\n\t      returns: void\n\t    }>\n\t    & Record<'get_preconditions(byte[])(uint64,uint64,uint64,uint64)' | 'get_preconditions', {\n\t      argsObj: {\n\t        /**\n\t         * The signature for the given voter account\n\t         */\n\t        signature: Uint8Array\n", "      }\n\t      argsTuple: [signature: Uint8Array]\n\t      /**\n\t       * The precondition values\n\t       */\n\t      returns: VotingPreconditions\n\t    }>\n\t    & Record<'vote(pay,byte[],uint8[])void' | 'vote', {\n\t      argsObj: {\n\t        fund_min_bal_req: TransactionToSign | Transaction | Promise<SendTransactionResult>\n", "        signature: Uint8Array\n\t        answer_ids: number[]\n\t      }\n\t      argsTuple: [fund_min_bal_req: TransactionToSign | Transaction | Promise<SendTransactionResult>, signature: Uint8Array, answer_ids: number[]]\n\t      returns: void\n\t    }>\n\t  /**\n\t   * Defines the shape of the global and local state of the application.\n\t   */\n\t  state: {\n", "    global: {\n\t      /**\n\t       * The unix timestamp of the time the vote was closed\n\t       */\n\t      'close_time'?: IntegerState\n\t      /**\n\t       * The unix timestamp of the ending time of voting\n\t       */\n\t      'end_time'?: IntegerState\n\t      /**\n", "       * Whether or not the contract has been bootstrapped with answers\n\t       */\n\t      'is_bootstrapped'?: IntegerState\n\t      /**\n\t       * The IPFS content ID of the voting metadata file\n\t       */\n\t      'metadata_ipfs_cid'?: BinaryState\n\t      /**\n\t       * The asset ID of a result NFT if one has been created\n\t       */\n", "      'nft_asset_id'?: IntegerState\n\t      /**\n\t       * The IPFS URL of the default image to use as the media of the result NFT\n\t       */\n\t      'nft_image_url'?: BinaryState\n\t      /**\n\t       * The number of options for each question\n\t       */\n\t      'option_counts'?: BinaryState\n\t      /**\n", "       * The minimum number of voters to reach quorum\n\t       */\n\t      'quorum'?: IntegerState\n\t      /**\n\t       * The public key of the Ed25519 compatible private key that was used to encrypt entries in the vote gating snapshot\n\t       */\n\t      'snapshot_public_key'?: BinaryState\n\t      /**\n\t       * The unix timestamp of the starting time of voting\n\t       */\n", "      'start_time'?: IntegerState\n\t      /**\n\t       * The total number of options\n\t       */\n\t      'total_options'?: IntegerState\n\t      /**\n\t       * The identifier of this voting round\n\t       */\n\t      'vote_id'?: BinaryState\n\t      /**\n", "       * The minimum number of voters who have voted\n\t       */\n\t      'voter_count'?: IntegerState\n\t    }\n\t  }\n\t}\n\t/**\n\t * Defines the possible abi call signatures\n\t */\n\texport type VotingRoundAppSig = keyof VotingRoundApp['methods']\n", "/**\n\t * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made\n\t */\n\texport type TypedCallParams<TSignature extends VotingRoundAppSig | undefined> = {\n\t  method: TSignature\n\t  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>\n\t} & AppClientCallCoreParams & CoreAppCallArgs\n\t/**\n\t * Defines the arguments required for a bare call\n\t */\n", "export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>\n\t/**\n\t * Represents a VotingPreconditions result as a struct\n\t */\n\texport type VotingPreconditions = {\n\t  is_voting_open: bigint\n\t  is_allowed_to_vote: bigint\n\t  has_already_voted: bigint\n\t  current_time: bigint\n\t}\n", "/**\n\t * Converts the tuple representation of a VotingPreconditions to the struct representation\n\t */\n\texport function VotingPreconditions([is_voting_open, is_allowed_to_vote, has_already_voted, current_time]: [bigint, bigint, bigint, bigint] ) {\n\t  return {\n\t    is_voting_open,\n\t    is_allowed_to_vote,\n\t    has_already_voted,\n\t    current_time,\n\t  }\n", "}\n\t/**\n\t * Maps a method signature from the VotingRoundApp smart contract to the method's arguments in either tuple of struct form\n\t */\n\texport type MethodArgs<TSignature extends VotingRoundAppSig> = VotingRoundApp['methods'][TSignature]['argsObj' | 'argsTuple']\n\t/**\n\t * Maps a method signature from the VotingRoundApp smart contract to the method's return type\n\t */\n\texport type MethodReturn<TSignature extends VotingRoundAppSig> = VotingRoundApp['methods'][TSignature]['returns']\n\t/**\n", " * A factory for available 'create' calls\n\t */\n\texport type VotingRoundAppCreateCalls = (typeof VotingRoundAppCallFactory)['create']\n\t/**\n\t * Defines supported create methods for this smart contract\n\t */\n\texport type VotingRoundAppCreateCallParams =\n\t  | (TypedCallParams<'create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void'> & (OnCompleteNoOp))\n\t/**\n\t * A factory for available 'delete' calls\n", " */\n\texport type VotingRoundAppDeleteCalls = (typeof VotingRoundAppCallFactory)['delete']\n\t/**\n\t * Defines supported delete methods for this smart contract\n\t */\n\texport type VotingRoundAppDeleteCallParams =\n\t  | TypedCallParams<undefined>\n\t/**\n\t * Defines arguments required for the deploy method.\n\t */\n", "export type VotingRoundAppDeployArgs = {\n\t  deployTimeParams?: TealTemplateParams\n\t  /**\n\t   * A delegate which takes a create call factory and returns the create call params for this smart contract\n\t   */\n\t  createCall?: (callFactory: VotingRoundAppCreateCalls) => VotingRoundAppCreateCallParams\n\t  /**\n\t   * A delegate which takes a delete call factory and returns the delete call params for this smart contract\n\t   */\n\t  deleteCall?: (callFactory: VotingRoundAppDeleteCalls) => VotingRoundAppDeleteCallParams\n", "}\n\t/**\n\t * Exposes methods for constructing all available smart contract calls\n\t */\n\texport abstract class VotingRoundAppCallFactory {\n\t  /**\n\t   * Gets available create call factories\n\t   */\n\t  static get create() {\n\t    return {\n", "      /**\n\t       * Constructs a create call for the VotingRoundApp smart contract using the create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void ABI method\n\t       *\n\t       * @param args Any args for the contract call\n\t       * @param params Any additional parameters for the call\n\t       * @returns A TypedCallParams object for the call\n\t       */\n\t      create(args: MethodArgs<'create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {\n\t        return {\n\t          method: 'create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void' as const,\n", "          methodArgs: Array.isArray(args) ? args : [args.vote_id, args.snapshot_public_key, args.metadata_ipfs_cid, args.start_time, args.end_time, args.option_counts, args.quorum, args.nft_image_url],\n\t          ...params,\n\t        }\n\t      },\n\t    }\n\t  }\n\t  /**\n\t   * Gets available delete call factories\n\t   */\n\t  static get delete() {\n", "    return {\n\t      /**\n\t       * Constructs a delete call for the VotingRoundApp smart contract using a bare call\n\t       *\n\t       * @param params Any parameters for the call\n\t       * @returns A TypedCallParams object for the call\n\t       */\n\t      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t        return {\n\t          method: undefined,\n", "          methodArgs: undefined,\n\t          ...params,\n\t        }\n\t      },\n\t    }\n\t  }\n\t  /**\n\t   * Constructs a no op call for the bootstrap(pay)void ABI method\n\t   *\n\t   * @param args Any args for the contract call\n", "   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n\t   */\n\t  static bootstrap(args: MethodArgs<'bootstrap(pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n\t    return {\n\t      method: 'bootstrap(pay)void' as const,\n\t      methodArgs: Array.isArray(args) ? args : [args.fund_min_bal_req],\n\t      ...params,\n\t    }\n\t  }\n", "  /**\n\t   * Constructs a no op call for the close()void ABI method\n\t   *\n\t   * @param args Any args for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n\t   */\n\t  static close(args: MethodArgs<'close()void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n\t    return {\n\t      method: 'close()void' as const,\n", "      methodArgs: Array.isArray(args) ? args : [],\n\t      ...params,\n\t    }\n\t  }\n\t  /**\n\t   * Constructs a no op call for the get_preconditions(byte[])(uint64,uint64,uint64,uint64) ABI method\n\t   *\n\t   * Returns the calculated pre-conditions for the voting round.\n\t   *\n\t   * @param args Any args for the contract call\n", "   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n\t   */\n\t  static getPreconditions(args: MethodArgs<'get_preconditions(byte[])(uint64,uint64,uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n\t    return {\n\t      method: 'get_preconditions(byte[])(uint64,uint64,uint64,uint64)' as const,\n\t      methodArgs: Array.isArray(args) ? args : [args.signature],\n\t      ...params,\n\t    }\n\t  }\n", "  /**\n\t   * Constructs a no op call for the vote(pay,byte[],uint8[])void ABI method\n\t   *\n\t   * @param args Any args for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n\t   */\n\t  static vote(args: MethodArgs<'vote(pay,byte[],uint8[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n\t    return {\n\t      method: 'vote(pay,byte[],uint8[])void' as const,\n", "      methodArgs: Array.isArray(args) ? args : [args.fund_min_bal_req, args.signature, args.answer_ids],\n\t      ...params,\n\t    }\n\t  }\n\t}\n\t/**\n\t * A client to make calls to the VotingRoundApp smart contract\n\t */\n\texport class VotingRoundAppClient {\n\t  /**\n", "   * The underlying `ApplicationClient` for when you want to have more flexibility\n\t   */\n\t  public readonly appClient: ApplicationClient\n\t  private readonly sender: SendTransactionFrom | undefined\n\t  /**\n\t   * Creates a new instance of `VotingRoundAppClient`\n\t   *\n\t   * @param appDetails appDetails The details to identify the app to deploy\n\t   * @param algod An algod client instance\n\t   */\n", "  constructor(appDetails: AppDetails, private algod: Algodv2) {\n\t    this.sender = appDetails.sender\n\t    this.appClient = algokit.getAppClient({\n\t      ...appDetails,\n\t      app: APP_SPEC\n\t    }, algod)\n\t  }\n\t  /**\n\t   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type\n\t   *\n", "   * @param result The AppCallTransactionResult to be mapped\n\t   * @param returnValueFormatter An optional delegate to format the return value if required\n\t   * @returns The smart contract response with an updated return value\n\t   */\n\t  protected mapReturnValue<TReturn>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> {\n\t    if(result.return?.decodeError) {\n\t      throw result.return.decodeError\n\t    }\n\t    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined\n\t      ? returnValueFormatter(result.return.returnValue)\n", "      : result.return?.returnValue as TReturn | undefined\n\t      return { ...result, return: returnValue }\n\t  }\n\t  /**\n\t   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP\n\t   *\n\t   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters\n\t   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type\n\t   * @returns The result of the smart contract call\n\t   */\n", "  public async call<TSignature extends keyof VotingRoundApp['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {\n\t    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)\n\t  }\n\t  /**\n\t   * Idempotently deploys the VotingRoundApp smart contract.\n\t   *\n\t   * @param params The arguments for the contract calls and any additional parameters for the call\n\t   * @returns The deployment result\n\t   */\n\t  public deploy(params: VotingRoundAppDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {\n", "    const createArgs = params.createCall?.(VotingRoundAppCallFactory.create)\n\t    const deleteArgs = params.deleteCall?.(VotingRoundAppCallFactory.delete)\n\t    return this.appClient.deploy({\n\t      ...params,\n\t      deleteArgs,\n\t      createArgs,\n\t      createOnCompleteAction: createArgs?.onCompleteAction,\n\t    })\n\t  }\n\t  /**\n", "   * Gets available create methods\n\t   */\n\t  public get create() {\n\t    const $this = this\n\t    return {\n\t      /**\n\t       * Creates a new instance of the VotingRoundApp smart contract using the create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void ABI method.\n\t       *\n\t       * @param args The arguments for the smart contract call\n\t       * @param params Any additional parameters for the call\n", "       * @returns The create result\n\t       */\n\t      async create(args: MethodArgs<'create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}): Promise<AppCallTransactionResultOfType<MethodReturn<'create(string,byte[],string,uint64,uint64,uint8[],uint64,string)void'>>> {\n\t        return $this.mapReturnValue(await $this.appClient.create(VotingRoundAppCallFactory.create.create(args, params)))\n\t      },\n\t    }\n\t  }\n\t  /**\n\t   * Gets available delete methods\n\t   */\n", "  public get delete() {\n\t    const $this = this\n\t    return {\n\t      /**\n\t       * Deletes an existing instance of the VotingRoundApp smart contract using a bare call.\n\t       *\n\t       * @param args The arguments for the bare call\n\t       * @returns The delete result\n\t       */\n\t      bare(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n", "        return $this.appClient.delete(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n\t      },\n\t    }\n\t  }\n\t  /**\n\t   * Makes a clear_state call to an existing instance of the VotingRoundApp smart contract.\n\t   *\n\t   * @param args The arguments for the bare call\n\t   * @returns The clear_state result\n\t   */\n", "  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.appClient.clearState(args)\n\t  }\n\t  /**\n\t   * Calls the bootstrap(pay)void ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n\t   */\n", "  public bootstrap(args: MethodArgs<'bootstrap(pay)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(VotingRoundAppCallFactory.bootstrap(args, params))\n\t  }\n\t  /**\n\t   * Calls the close()void ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n\t   */\n", "  public close(args: MethodArgs<'close()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(VotingRoundAppCallFactory.close(args, params))\n\t  }\n\t  /**\n\t   * Calls the get_preconditions(byte[])(uint64,uint64,uint64,uint64) ABI method.\n\t   *\n\t   * Returns the calculated pre-conditions for the voting round.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n", "   * @returns The result of the call: The precondition values\n\t   */\n\t  public getPreconditions(args: MethodArgs<'get_preconditions(byte[])(uint64,uint64,uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(VotingRoundAppCallFactory.getPreconditions(args, params), VotingPreconditions)\n\t  }\n\t  /**\n\t   * Calls the vote(pay,byte[],uint8[])void ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n", "   * @returns The result of the call\n\t   */\n\t  public vote(args: MethodArgs<'vote(pay,byte[],uint8[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(VotingRoundAppCallFactory.vote(args, params))\n\t  }\n\t  /**\n\t   * Extracts a binary state value out of an AppState dictionary\n\t   *\n\t   * @param state The state dictionary containing the state value\n\t   * @param key The key of the state value\n", "   * @returns A BinaryState instance containing the state value, or undefined if the key was not found\n\t   */\n\t  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {\n\t    const value = state[key]\n\t    if (!value) return undefined\n\t    if (!('valueRaw' in value))\n\t      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)\n\t    return {\n\t      asString(): string {\n\t        return value.value\n", "      },\n\t      asByteArray(): Uint8Array {\n\t        return value.valueRaw\n\t      }\n\t    }\n\t  }\n\t  /**\n\t   * Extracts a integer state value out of an AppState dictionary\n\t   *\n\t   * @param state The state dictionary containing the state value\n", "   * @param key The key of the state value\n\t   * @returns An IntegerState instance containing the state value, or undefined if the key was not found\n\t   */\n\t  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {\n\t    const value = state[key]\n\t    if (!value) return undefined\n\t    if ('valueRaw' in value)\n\t      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)\n\t    return {\n\t      asBigInt() {\n", "        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)\n\t      },\n\t      asNumber(): number {\n\t        return typeof value.value === 'bigint' ? Number(value.value) : value.value\n\t      },\n\t    }\n\t  }\n\t  /**\n\t   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value\n\t   */\n", "  public async getGlobalState(): Promise<VotingRoundApp['state']['global']> {\n\t    const state = await this.appClient.getGlobalState()\n\t    return {\n\t      get close_time() {\n\t        return VotingRoundAppClient.getIntegerState(state, 'close_time')\n\t      },\n\t      get end_time() {\n\t        return VotingRoundAppClient.getIntegerState(state, 'end_time')\n\t      },\n\t      get is_bootstrapped() {\n", "        return VotingRoundAppClient.getIntegerState(state, 'is_bootstrapped')\n\t      },\n\t      get metadata_ipfs_cid() {\n\t        return VotingRoundAppClient.getBinaryState(state, 'metadata_ipfs_cid')\n\t      },\n\t      get nft_asset_id() {\n\t        return VotingRoundAppClient.getIntegerState(state, 'nft_asset_id')\n\t      },\n\t      get nft_image_url() {\n\t        return VotingRoundAppClient.getBinaryState(state, 'nft_image_url')\n", "      },\n\t      get option_counts() {\n\t        return VotingRoundAppClient.getBinaryState(state, 'option_counts')\n\t      },\n\t      get quorum() {\n\t        return VotingRoundAppClient.getIntegerState(state, 'quorum')\n\t      },\n\t      get snapshot_public_key() {\n\t        return VotingRoundAppClient.getBinaryState(state, 'snapshot_public_key')\n\t      },\n", "      get start_time() {\n\t        return VotingRoundAppClient.getIntegerState(state, 'start_time')\n\t      },\n\t      get total_options() {\n\t        return VotingRoundAppClient.getIntegerState(state, 'total_options')\n\t      },\n\t      get vote_id() {\n\t        return VotingRoundAppClient.getBinaryState(state, 'vote_id')\n\t      },\n\t      get voter_count() {\n", "        return VotingRoundAppClient.getIntegerState(state, 'voter_count')\n\t      },\n\t    }\n\t  }\n\t  public compose(): VotingRoundAppComposer {\n\t    const client = this\n\t    const atc = new AtomicTransactionComposer()\n\t    let promiseChain:Promise<unknown> = Promise.resolve()\n\t    const resultMappers: Array<undefined | ((x: any) => any)> = []\n\t    return {\n", "      bootstrap(args: MethodArgs<'bootstrap(pay)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.bootstrap(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      close(args: MethodArgs<'close()void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.close(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n", "      getPreconditions(args: MethodArgs<'get_preconditions(byte[])(uint64,uint64,uint64,uint64)'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.getPreconditions(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(VotingPreconditions)\n\t        return this\n\t      },\n\t      vote(args: MethodArgs<'vote(pay,byte[],uint8[])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.vote(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n", "      get delete() {\n\t        const $this = this\n\t        return {\n\t          bare(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {\n\t            promiseChain = promiseChain.then(() => client.delete.bare({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n\t            resultMappers.push(undefined)\n\t            return $this\n\t          },\n\t        }\n\t      },\n", "      clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {\n\t        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))\n\t        return this\n\t      },\n\t      async atc() {\n", "        await promiseChain\n\t        return atc\n\t      },\n\t      async execute() {\n\t        await promiseChain\n\t        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)\n\t        return {\n\t          ...result,\n\t          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)\n\t        }\n", "      }\n\t    } as unknown as VotingRoundAppComposer\n\t  }\n\t}\n\texport type VotingRoundAppComposer<TReturns extends [...any[]] = []> = {\n\t  /**\n\t   * Calls the bootstrap(pay)void ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n", "   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  bootstrap(args: MethodArgs<'bootstrap(pay)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): VotingRoundAppComposer<[...TReturns, MethodReturn<'bootstrap(pay)void'>]>\n\t  /**\n\t   * Calls the close()void ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n", "  close(args: MethodArgs<'close()void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): VotingRoundAppComposer<[...TReturns, MethodReturn<'close()void'>]>\n\t  /**\n\t   * Calls the get_preconditions(byte[])(uint64,uint64,uint64,uint64) ABI method.\n\t   *\n\t   * Returns the calculated pre-conditions for the voting round.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n", "  getPreconditions(args: MethodArgs<'get_preconditions(byte[])(uint64,uint64,uint64,uint64)'>, params?: AppClientCallCoreParams & CoreAppCallArgs): VotingRoundAppComposer<[...TReturns, MethodReturn<'get_preconditions(byte[])(uint64,uint64,uint64,uint64)'>]>\n\t  /**\n\t   * Calls the vote(pay,byte[],uint8[])void ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  vote(args: MethodArgs<'vote(pay,byte[],uint8[])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): VotingRoundAppComposer<[...TReturns, MethodReturn<'vote(pay,byte[],uint8[])void'>]>\n\t  /**\n", "   * Gets available delete methods\n\t   */\n\t  readonly delete: {\n\t    /**\n\t     * Deletes an existing instance of the VotingRoundApp smart contract using a bare call.\n\t     *\n\t     * @param args The arguments for the bare call\n\t     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t     */\n\t    bare(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): VotingRoundAppComposer<[...TReturns, undefined]>\n", "  }\n\t  /**\n\t   * Makes a clear_state call to an existing instance of the VotingRoundApp smart contract.\n\t   *\n\t   * @param args The arguments for the bare call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): VotingRoundAppComposer<[...TReturns, undefined]>\n\t  /**\n\t   * Adds a transaction to the composer\n", "   *\n\t   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)\n\t   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.\n\t   */\n\t  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): VotingRoundAppComposer<TReturns>\n\t  /**\n\t   * Returns the underlying AtomicTransactionComposer instance\n\t   */\n\t  atc(): Promise<AtomicTransactionComposer>\n\t  /**\n", "   * Executes the transaction group and returns an array of results\n\t   */\n\t  execute(): Promise<VotingRoundAppComposerResults<TReturns>>\n\t}\n\texport type VotingRoundAppComposerResults<TReturns extends [...any[]]> = {\n\t  returns: TReturns\n\t  groupId: string\n\t  txIds: string[]\n\t  transactions: Transaction[]\n\t}\n"]}
{"filename": "examples/state/client.spec.ts", "chunked_list": ["import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\n\timport { beforeEach, describe, expect, test } from '@jest/globals'\n\timport { StateAppClient } from './client'\n\timport { microAlgos } from '@algorandfoundation/algokit-utils'\n\tdescribe('state typed client', () => {\n\t  const localnet = algorandFixture()\n\t  beforeEach(localnet.beforeEach, 10_000)\n\t  test('Exposes state correctly', async () => {\n\t    const { algod, indexer, testAccount } = localnet.context\n\t    const client = new StateAppClient(\n", "      {\n\t        resolveBy: 'creatorAndName',\n\t        sender: testAccount,\n\t        creatorAddress: testAccount.addr,\n\t        findExistingUsing: indexer,\n\t      },\n\t      algod,\n\t    )\n\t    await client.deploy({ deployTimeParams: { VALUE: 1 } })\n\t    await client.setGlobal({ int1: 1, int2: 2, bytes1: 'asdf', bytes2: new Uint8Array([1, 2, 3, 4]) })\n", "    const globalState = await client.getGlobalState()\n\t    expect(globalState.int1?.asNumber()).toBe(1)\n\t    expect(globalState.int2?.asNumber()).toBe(2)\n\t    expect(globalState.bytes1?.asString()).toBe('asdf')\n\t    expect(globalState.bytes2?.asByteArray()).toEqual(new Uint8Array([1, 2, 3, 4]))\n\t    await client.optIn.optIn([])\n\t    await client.setLocal({ int1: 1, int2: 2, bytes1: 'asdf', bytes2: new Uint8Array([1, 2, 3, 4]) })\n\t    const localState = await client.getLocalState(testAccount)\n\t    expect(localState.local_int1?.asNumber()).toBe(1)\n\t    expect(localState.local_int2?.asNumber()).toBe(2)\n", "    expect(localState.local_bytes1?.asString()).toBe('asdf')\n\t    expect(localState.local_bytes2?.asByteArray()).toEqual(new Uint8Array([1, 2, 3, 4]))\n\t  })\n\t  test('Readonly methods do not consume algos', async () => {\n\t    const { algod, indexer, testAccount } = localnet.context\n\t    const client = new StateAppClient(\n\t      {\n\t        resolveBy: 'creatorAndName',\n\t        sender: testAccount,\n\t        creatorAddress: testAccount.addr,\n", "        findExistingUsing: indexer,\n\t      },\n\t      algod,\n\t    )\n\t    await client.deploy({ deployTimeParams: { VALUE: 1 } })\n\t    const minBalance = 100_000\n\t    const txCost = 1_000\n\t    const lowFundsAccount = await localnet.context.generateAccount({ initialFunds: microAlgos(minBalance + txCost) })\n\t    const result = await client.callAbi({ value: 'oh hi' }, { sender: lowFundsAccount })\n\t    expect(result.return).toBe('Hello, oh hi')\n", "    // If we can invoke this method twice it confirms that we are still above the min balance + single tx amount and the previous call\n\t    // did not consume algos\n\t    await client.callAbi({ value: 'oh hi' }, { sender: lowFundsAccount })\n\t  })\n\t  test('Arguments with defaults defined are not required, and use their default value strategies when set to undefined', async () => {\n\t    const { algod, indexer, testAccount } = localnet.context\n\t    const client = new StateAppClient(\n\t      {\n\t        resolveBy: 'creatorAndName',\n\t        sender: testAccount,\n", "        creatorAddress: testAccount.addr,\n\t        findExistingUsing: indexer,\n\t      },\n\t      algod,\n\t    )\n\t    await client.deploy({ deployTimeParams: { VALUE: 1 } })\n\t    await client.setGlobal({ int1: 50, int2: 2, bytes1: 'asdf', bytes2: new Uint8Array([1, 2, 3, 4]) })\n\t    await client.optIn.optIn({})\n\t    await client.setLocal({ bytes1: 'default value', int2: 0, int1: 0, bytes2: new Uint8Array([1, 2, 3, 4]) })\n\t    const constantDefined = await client.defaultValue({ arg_with_default: 'defined value' })\n", "    expect(constantDefined.return).toBe('defined value')\n\t    const constantDefault = await client.defaultValue({})\n\t    expect(constantDefault.return).toBe('default value')\n\t    const abiDefined = await client.defaultValueFromAbi({ arg_with_default: 'defined value' })\n\t    expect(abiDefined.return).toBe('ABI, defined value')\n\t    const abiDefault = await client.defaultValueFromAbi({})\n\t    expect(abiDefault.return).toBe('ABI, default value')\n\t    const intDefined = await client.defaultValueInt({ arg_with_default: 42 })\n\t    expect(intDefined.return).toBe(42n)\n\t    const intDefault = await client.defaultValueInt({})\n", "    expect(intDefault.return).toBe(123n)\n\t    const globalDefined = await client.defaultValueFromGlobalState({ arg_with_default: 123 })\n\t    expect(globalDefined.return).toBe(123n)\n\t    const globalState = await client.getGlobalState()\n\t    const globalDefault = await client.defaultValueFromGlobalState({})\n\t    expect(globalDefault.return).toBe(globalState.int1?.asBigInt())\n\t    const localDefined = await client.defaultValueFromLocalState({ arg_with_default: 'defined value' })\n\t    expect(localDefined.return).toBe('Local state, defined value')\n\t    const localState = await client.getLocalState(testAccount)\n\t    const localDefault = await client.defaultValueFromLocalState({})\n", "    expect(localDefault.return).toBe(`Local state, ${localState.local_bytes1?.asString()}`)\n\t  })\n\t  test('Methods can be composed', async () => {\n\t    const { algod, indexer, testAccount } = localnet.context\n\t    const client = new StateAppClient(\n\t      {\n\t        resolveBy: 'creatorAndName',\n\t        sender: testAccount,\n\t        creatorAddress: testAccount.addr,\n\t        findExistingUsing: indexer,\n", "      },\n\t      algod,\n\t    )\n\t    await client.deploy({ deployTimeParams: { VALUE: 1 } })\n\t    await client\n\t      .compose()\n\t      .optIn.optIn({})\n\t      .setLocal({ bytes1: 'default value', int2: 0, int1: 0, bytes2: new Uint8Array([1, 2, 3, 4]) })\n\t      .execute()\n\t    const localState = await client.getLocalState(testAccount)\n", "    expect(localState.local_bytes1?.asString()).toBe('default value')\n\t  })\n\t  test('ABI methods which take references can be called', async () => {\n\t    const { algod, indexer, testAccount } = localnet.context\n\t    const client = new StateAppClient(\n\t      {\n\t        resolveBy: 'creatorAndName',\n\t        sender: testAccount,\n\t        creatorAddress: testAccount.addr,\n\t        findExistingUsing: indexer,\n", "      },\n\t      algod,\n\t    )\n\t    await client.deploy({ deployTimeParams: { VALUE: 1 } })\n\t    // Call with number\n\t    await client.callWithReferences({\n\t      asset: 1234,\n\t      account: testAccount.addr,\n\t      application: (await client.appClient.getAppReference()).appId,\n\t    })\n", "  })\n\t})\n"]}
{"filename": "examples/state/client.ts", "chunked_list": ["/* eslint-disable */\n\t/**\n\t * This file was automatically generated by @algorandfoundation/algokit-client-generator.\n\t * DO NOT MODIFY IT BY HAND.\n\t * requires: @algorandfoundation/algokit-utils: ^2\n\t */\n\timport * as algokit from '@algorandfoundation/algokit-utils'\n\timport type {\n\t  AppCallTransactionResult,\n\t  AppCallTransactionResultOfType,\n", "  CoreAppCallArgs,\n\t  RawAppCallArgs,\n\t  AppState,\n\t  TealTemplateParams,\n\t  ABIAppCallArg,\n\t} from '@algorandfoundation/algokit-utils/types/app'\n\timport type {\n\t  AppClientCallCoreParams,\n\t  AppClientCompilationParams,\n\t  AppClientDeployCoreParams,\n", "  AppDetails,\n\t  ApplicationClient,\n\t} from '@algorandfoundation/algokit-utils/types/app-client'\n\timport type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'\n\timport type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'\n\timport type { TransactionWithSigner } from 'algosdk'\n\timport { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer } from 'algosdk'\n\texport const APP_SPEC: AppSpec = {\n\t  \"hints\": {\n\t    \"call_abi(string)string\": {\n", "      \"read_only\": true,\n\t      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n\t    },\n\t    \"call_abi_txn(pay,string)string\": {\n\t      \"read_only\": true,\n\t      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n", "    },\n\t    \"call_with_references(asset,account,application)uint64\": {\n\t      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n\t    },\n\t    \"set_global(uint64,uint64,string,byte[4])void\": {\n\t      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n", "    },\n\t    \"set_local(uint64,uint64,string,byte[4])void\": {\n\t      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n\t    },\n\t    \"set_box(byte[4],string)void\": {\n\t      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n", "    },\n\t    \"error()void\": {\n\t      \"read_only\": true,\n\t      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n\t    },\n\t    \"default_value(string)string\": {\n\t      \"read_only\": true,\n\t      \"default_arguments\": {\n", "        \"arg_with_default\": {\n\t          \"source\": \"constant\",\n\t          \"data\": \"default value\"\n\t        }\n\t      },\n\t      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n\t    },\n\t    \"default_value_int(uint64)uint64\": {\n", "      \"read_only\": true,\n\t      \"default_arguments\": {\n\t        \"arg_with_default\": {\n\t          \"source\": \"constant\",\n\t          \"data\": 123\n\t        }\n\t      },\n\t      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n", "    },\n\t    \"default_value_from_abi(string)string\": {\n\t      \"read_only\": true,\n\t      \"default_arguments\": {\n\t        \"arg_with_default\": {\n\t          \"source\": \"abi-method\",\n\t          \"data\": {\n\t            \"name\": \"default_value\",\n\t            \"args\": [\n\t              {\n", "                \"type\": \"string\",\n\t                \"name\": \"arg_with_default\"\n\t              }\n\t            ],\n\t            \"returns\": {\n\t              \"type\": \"string\"\n\t            }\n\t          }\n\t        }\n\t      },\n", "      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n\t    },\n\t    \"default_value_from_global_state(uint64)uint64\": {\n\t      \"read_only\": true,\n\t      \"default_arguments\": {\n\t        \"arg_with_default\": {\n\t          \"source\": \"global-state\",\n\t          \"data\": \"int1\"\n", "        }\n\t      },\n\t      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n\t    },\n\t    \"default_value_from_local_state(string)string\": {\n\t      \"read_only\": true,\n\t      \"default_arguments\": {\n\t        \"arg_with_default\": {\n", "          \"source\": \"local-state\",\n\t          \"data\": \"local_bytes1\"\n\t        }\n\t      },\n\t      \"call_config\": {\n\t        \"no_op\": \"CALL\"\n\t      }\n\t    },\n\t    \"create_abi(string)string\": {\n\t      \"call_config\": {\n", "        \"no_op\": \"CREATE\"\n\t      }\n\t    },\n\t    \"update_abi(string)string\": {\n\t      \"call_config\": {\n\t        \"update_application\": \"CALL\"\n\t      }\n\t    },\n\t    \"delete_abi(string)string\": {\n\t      \"call_config\": {\n", "        \"delete_application\": \"CALL\"\n\t      }\n\t    },\n\t    \"opt_in()void\": {\n\t      \"call_config\": {\n\t        \"opt_in\": \"CALL\"\n\t      }\n\t    }\n\t  },\n\t  \"source\": {\n", "    \"approval\": \"I3ByYWdtYSB2ZXJzaW9uIDgKaW50Y2Jsb2NrIDAgMSAxMCA1IFRNUExfVVBEQVRBQkxFIFRNUExfREVMRVRBQkxFCmJ5dGVjYmxvY2sgMHgxNTFmN2M3NSAweAp0eG4gTnVtQXBwQXJncwppbnRjXzAgLy8gMAo9PQpibnogbWFpbl9sMzQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhmMTdlODBhNSAvLyAiY2FsbF9hYmkoc3RyaW5nKXN0cmluZyIKPT0KYm56IG1haW5fbDMzCnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4MGE5MmE4MWUgLy8gImNhbGxfYWJpX3R4bihwYXksc3RyaW5nKXN0cmluZyIKPT0KYm56IG1haW5fbDMyCnR4bmEgQXBwbGljYXRpb25BcmdzIDAKcHVzaGJ5dGVzIDB4ZmVmZGYxMWUgLy8gImNhbGxfd2l0aF9yZWZlcmVuY2VzKGFzc2V0LGFjY291bnQsYXBwbGljYXRpb24pdWludDY0Igo9PQpibnogbWFpbl9sMzEKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhhNGNmOGRlYSAvLyAic2V0X2dsb2JhbCh1aW50NjQsdWludDY0LHN0cmluZyxieXRlWzRdKXZvaWQiCj09CmJueiBtYWluX2wzMAp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweGNlYzI4MzRhIC8vICJzZXRfbG9jYWwodWludDY0LHVpbnQ2NCxzdHJpbmcsYnl0ZVs0XSl2b2lkIgo9PQpibnogbWFpbl9sMjkKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhhNGI0YTIzMCAvLyAic2V0X2JveChieXRlWzRdLHN0cmluZyl2b2lkIgo9PQpibnogbWFpbl9sMjgKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHg0NGQwZGEwZCAvLyAiZXJyb3IoKXZvaWQiCj09CmJueiBtYWluX2wyNwp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDU3NGI1NWM4IC8vICJkZWZhdWx0X3ZhbHVlKHN0cmluZylzdHJpbmciCj09CmJueiBtYWluX2wyNgp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDM2MDM2MmU5IC8vICJkZWZhdWx0X3ZhbHVlX2ludCh1aW50NjQpdWludDY0Igo9PQpibnogbWFpbl9sMjUKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHg0NmQyMTFhMyAvLyAiZGVmYXVsdF92YWx1ZV9mcm9tX2FiaShzdHJpbmcpc3RyaW5nIgo9PQpibnogbWFpbl9sMjQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHgwY2ZjYmIwMCAvLyAiZGVmYXVsdF92YWx1ZV9mcm9tX2dsb2JhbF9zdGF0ZSh1aW50NjQpdWludDY0Igo9PQpibnogbWFpbl9sMjMKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMApwdXNoYnl0ZXMgMHhkMGYwYmFmOCAvLyAiZGVmYXVsdF92YWx1ZV9mcm9tX2xvY2FsX3N0YXRlKHN0cmluZylzdHJpbmciCj09CmJueiBtYWluX2wyMgp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDlkNTIzMDQwIC8vICJjcmVhdGVfYWJpKHN0cmluZylzdHJpbmciCj09CmJueiBtYWluX2wyMQp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDNjYTVjZWI3IC8vICJ1cGRhdGVfYWJpKHN0cmluZylzdHJpbmciCj09CmJueiBtYWluX2wyMAp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDI3MWI0ZWU5IC8vICJkZWxldGVfYWJpKHN0cmluZylzdHJpbmciCj09CmJueiBtYWluX2wxOQp0eG5hIEFwcGxpY2F0aW9uQXJncyAwCnB1c2hieXRlcyAweDMwYzZkNThhIC8vICJvcHRfaW4oKXZvaWQiCj09CmJueiBtYWluX2wxOAplcnIKbWFpbl9sMTg6CnR4biBPbkNvbXBsZXRpb24KaW50Y18xIC8vIE9wdEluCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydApjYWxsc3ViIG9wdGluXzE5CmludGNfMSAvLyAxCnJldHVybgptYWluX2wxOToKdHhuIE9uQ29tcGxldGlvbgppbnRjXzMgLy8gRGVsZXRlQXBwbGljYXRpb24KPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKY2FsbHN1YiBkZWxldGVhYmlfMTgKc3RvcmUgMjUKYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CmxvYWQgMjUKY29uY2F0CmxvZwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMjA6CnR4biBPbkNvbXBsZXRpb24KcHVzaGludCA0IC8vIFVwZGF0ZUFwcGxpY2F0aW9uCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCmNhbGxzdWIgdXBkYXRlYWJpXzE2CnN0b3JlIDI0CmJ5dGVjXzAgLy8gMHgxNTFmN2M3NQpsb2FkIDI0CmNvbmNhdApsb2cKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDIxOgp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCj09CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCmNhbGxzdWIgY3JlYXRlYWJpXzE0CnN0b3JlIDIzCmJ5dGVjXzAgLy8gMHgxNTFmN2M3NQpsb2FkIDIzCmNvbmNhdApsb2cKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDIyOgp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCmNhbGxzdWIgZGVmYXVsdHZhbHVlZnJvbWxvY2Fsc3RhdGVfMTIKc3RvcmUgMjIKYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CmxvYWQgMjIKY29uY2F0CmxvZwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMjM6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKYnRvaQpjYWxsc3ViIGRlZmF1bHR2YWx1ZWZyb21nbG9iYWxzdGF0ZV8xMQpzdG9yZSAyMQpieXRlY18wIC8vIDB4MTUxZjdjNzUKbG9hZCAyMQppdG9iCmNvbmNhdApsb2cKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDI0Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCmNhbGxzdWIgZGVmYXVsdHZhbHVlZnJvbWFiaV8xMApzdG9yZSAyMApieXRlY18wIC8vIDB4MTUxZjdjNzUKbG9hZCAyMApjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2wyNToKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpidG9pCmNhbGxzdWIgZGVmYXVsdHZhbHVlaW50XzkKc3RvcmUgMTkKYnl0ZWNfMCAvLyAweDE1MWY3Yzc1CmxvYWQgMTkKaXRvYgpjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2wyNjoKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpjYWxsc3ViIGRlZmF1bHR2YWx1ZV84CnN0b3JlIDE4CmJ5dGVjXzAgLy8gMHgxNTFmN2M3NQpsb2FkIDE4CmNvbmNhdApsb2cKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDI3Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydApjYWxsc3ViIGVycm9yXzcKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDI4Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCnN0b3JlIDE2CnR4bmEgQXBwbGljYXRpb25BcmdzIDIKc3RvcmUgMTcKbG9hZCAxNgpsb2FkIDE3CmNhbGxzdWIgc2V0Ym94XzYKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDI5Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CiYmCmFzc2VydAp0eG5hIEFwcGxpY2F0aW9uQXJncyAxCmJ0b2kKc3RvcmUgMTIKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgpidG9pCnN0b3JlIDEzCnR4bmEgQXBwbGljYXRpb25BcmdzIDMKc3RvcmUgMTQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNApzdG9yZSAxNQpsb2FkIDEyCmxvYWQgMTMKbG9hZCAxNApsb2FkIDE1CmNhbGxzdWIgc2V0bG9jYWxfNQppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMzA6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKYnRvaQpzdG9yZSA4CnR4bmEgQXBwbGljYXRpb25BcmdzIDIKYnRvaQpzdG9yZSA5CnR4bmEgQXBwbGljYXRpb25BcmdzIDMKc3RvcmUgMTAKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNApzdG9yZSAxMQpsb2FkIDgKbG9hZCA5CmxvYWQgMTAKbG9hZCAxMQpjYWxsc3ViIHNldGdsb2JhbF80CmludGNfMSAvLyAxCnJldHVybgptYWluX2wzMToKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQppbnRjXzAgLy8gMApnZXRieXRlCnN0b3JlIDQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgppbnRjXzAgLy8gMApnZXRieXRlCnN0b3JlIDUKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwppbnRjXzAgLy8gMApnZXRieXRlCnN0b3JlIDYKbG9hZCA0CmxvYWQgNQpsb2FkIDYKY2FsbHN1YiBjYWxsd2l0aHJlZmVyZW5jZXNfMwpzdG9yZSA3CmJ5dGVjXzAgLy8gMHgxNTFmN2M3NQpsb2FkIDcKaXRvYgpjb25jYXQKbG9nCmludGNfMSAvLyAxCnJldHVybgptYWluX2wzMjoKdHhuIE9uQ29tcGxldGlvbgppbnRjXzAgLy8gTm9PcAo9PQp0eG4gQXBwbGljYXRpb25JRAppbnRjXzAgLy8gMAohPQomJgphc3NlcnQKdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQpzdG9yZSAyCnR4biBHcm91cEluZGV4CmludGNfMSAvLyAxCi0Kc3RvcmUgMQpsb2FkIDEKZ3R4bnMgVHlwZUVudW0KaW50Y18xIC8vIHBheQo9PQphc3NlcnQKbG9hZCAxCmxvYWQgMgpjYWxsc3ViIGNhbGxhYml0eG5fMgpzdG9yZSAzCmJ5dGVjXzAgLy8gMHgxNTFmN2M3NQpsb2FkIDMKY29uY2F0CmxvZwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sMzM6CnR4biBPbkNvbXBsZXRpb24KaW50Y18wIC8vIE5vT3AKPT0KdHhuIEFwcGxpY2F0aW9uSUQKaW50Y18wIC8vIDAKIT0KJiYKYXNzZXJ0CnR4bmEgQXBwbGljYXRpb25BcmdzIDEKY2FsbHN1YiBjYWxsYWJpXzAKc3RvcmUgMApieXRlY18wIC8vIDB4MTUxZjdjNzUKbG9hZCAwCmNvbmNhdApsb2cKaW50Y18xIC8vIDEKcmV0dXJuCm1haW5fbDM0Ogp0eG4gT25Db21wbGV0aW9uCmludGNfMCAvLyBOb09wCj09CmJueiBtYWluX2w0Mgp0eG4gT25Db21wbGV0aW9uCmludGNfMSAvLyBPcHRJbgo9PQpibnogbWFpbl9sNDEKdHhuIE9uQ29tcGxldGlvbgpwdXNoaW50IDQgLy8gVXBkYXRlQXBwbGljYXRpb24KPT0KYm56IG1haW5fbDQwCnR4biBPbkNvbXBsZXRpb24KaW50Y18zIC8vIERlbGV0ZUFwcGxpY2F0aW9uCj09CmJueiBtYWluX2wzOQplcnIKbWFpbl9sMzk6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CmFzc2VydApjYWxsc3ViIGRlbGV0ZV8xNwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sNDA6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCiE9CmFzc2VydApjYWxsc3ViIHVwZGF0ZV8xNQppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sNDE6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCj09CmFzc2VydApjYWxsc3ViIGNyZWF0ZV8xMwppbnRjXzEgLy8gMQpyZXR1cm4KbWFpbl9sNDI6CnR4biBBcHBsaWNhdGlvbklECmludGNfMCAvLyAwCj09CmFzc2VydApjYWxsc3ViIGNyZWF0ZV8xMwppbnRjXzEgLy8gMQpyZXR1cm4KCi8vIGNhbGxfYWJpCmNhbGxhYmlfMDoKcHJvdG8gMSAxCmJ5dGVjXzEgLy8gIiIKcHVzaGJ5dGVzIDB4NDg2NTZjNmM2ZjJjMjAgLy8gIkhlbGxvLCAiCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApjb25jYXQKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCmxlbgppdG9iCmV4dHJhY3QgNiAwCmZyYW1lX2RpZyAwCmNvbmNhdApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyBpdG9hCml0b2FfMToKcHJvdG8gMSAxCmZyYW1lX2RpZyAtMQppbnRjXzAgLy8gMAo9PQpibnogaXRvYV8xX2w1CmZyYW1lX2RpZyAtMQppbnRjXzIgLy8gMTAKLwppbnRjXzAgLy8gMAo+CmJueiBpdG9hXzFfbDQKYnl0ZWNfMSAvLyAiIgppdG9hXzFfbDM6CnB1c2hieXRlcyAweDMwMzEzMjMzMzQzNTM2MzczODM5IC8vICIwMTIzNDU2Nzg5IgpmcmFtZV9kaWcgLTEKaW50Y18yIC8vIDEwCiUKaW50Y18xIC8vIDEKZXh0cmFjdDMKY29uY2F0CmIgaXRvYV8xX2w2Cml0b2FfMV9sNDoKZnJhbWVfZGlnIC0xCmludGNfMiAvLyAxMAovCmNhbGxzdWIgaXRvYV8xCmIgaXRvYV8xX2wzCml0b2FfMV9sNToKcHVzaGJ5dGVzIDB4MzAgLy8gIjAiCml0b2FfMV9sNjoKcmV0c3ViCgovLyBjYWxsX2FiaV90eG4KY2FsbGFiaXR4bl8yOgpwcm90byAyIDEKYnl0ZWNfMSAvLyAiIgpwdXNoYnl0ZXMgMHg1MzY1NmU3NDIwIC8vICJTZW50ICIKZnJhbWVfZGlnIC0yCmd0eG5zIEFtb3VudApjYWxsc3ViIGl0b2FfMQpjb25jYXQKcHVzaGJ5dGVzIDB4MmUyMCAvLyAiLiAiCmNvbmNhdApmcmFtZV9kaWcgLTEKZXh0cmFjdCAyIDAKY29uY2F0CmZyYW1lX2J1cnkgMApmcmFtZV9kaWcgMApsZW4KaXRvYgpleHRyYWN0IDYgMApmcmFtZV9kaWcgMApjb25jYXQKZnJhbWVfYnVyeSAwCnJldHN1YgoKLy8gY2FsbF93aXRoX3JlZmVyZW5jZXMKY2FsbHdpdGhyZWZlcmVuY2VzXzM6CnByb3RvIDMgMQppbnRjXzAgLy8gMApmcmFtZV9kaWcgLTMKdHhuYXMgQXNzZXRzCi8vIGFzc2V0IG5vdCBwcm92aWRlZAphc3NlcnQKZnJhbWVfZGlnIC0yCnR4bmFzIEFjY291bnRzCmxlbgovLyBhY2NvdW50IG5vdCBwcm92aWRlZAphc3NlcnQKZnJhbWVfZGlnIC0xCnR4bmFzIEFwcGxpY2F0aW9ucwovLyBhcHBsaWNhdGlvbiBub3QgcHJvdmlkZWQKYXNzZXJ0CmludGNfMSAvLyAxCmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIHNldF9nbG9iYWwKc2V0Z2xvYmFsXzQ6CnByb3RvIDQgMApwdXNoYnl0ZXMgMHg2OTZlNzQzMSAvLyAiaW50MSIKZnJhbWVfZGlnIC00CmFwcF9nbG9iYWxfcHV0CnB1c2hieXRlcyAweDY5NmU3NDMyIC8vICJpbnQyIgpmcmFtZV9kaWcgLTMKYXBwX2dsb2JhbF9wdXQKcHVzaGJ5dGVzIDB4NjI3OTc0NjU3MzMxIC8vICJieXRlczEiCmZyYW1lX2RpZyAtMgpleHRyYWN0IDIgMAphcHBfZ2xvYmFsX3B1dApwdXNoYnl0ZXMgMHg2Mjc5NzQ2NTczMzIgLy8gImJ5dGVzMiIKZnJhbWVfZGlnIC0xCmFwcF9nbG9iYWxfcHV0CnJldHN1YgoKLy8gc2V0X2xvY2FsCnNldGxvY2FsXzU6CnByb3RvIDQgMAp0eG4gU2VuZGVyCnB1c2hieXRlcyAweDZjNmY2MzYxNmM1ZjY5NmU3NDMxIC8vICJsb2NhbF9pbnQxIgpmcmFtZV9kaWcgLTQKYXBwX2xvY2FsX3B1dAp0eG4gU2VuZGVyCnB1c2hieXRlcyAweDZjNmY2MzYxNmM1ZjY5NmU3NDMyIC8vICJsb2NhbF9pbnQyIgpmcmFtZV9kaWcgLTMKYXBwX2xvY2FsX3B1dAp0eG4gU2VuZGVyCnB1c2hieXRlcyAweDZjNmY2MzYxNmM1ZjYyNzk3NDY1NzMzMSAvLyAibG9jYWxfYnl0ZXMxIgpmcmFtZV9kaWcgLTIKZXh0cmFjdCAyIDAKYXBwX2xvY2FsX3B1dAp0eG4gU2VuZGVyCnB1c2hieXRlcyAweDZjNmY2MzYxNmM1ZjYyNzk3NDY1NzMzMiAvLyAibG9jYWxfYnl0ZXMyIgpmcmFtZV9kaWcgLTEKYXBwX2xvY2FsX3B1dApyZXRzdWIKCi8vIHNldF9ib3gKc2V0Ym94XzY6CnByb3RvIDIgMApmcmFtZV9kaWcgLTIKYm94X2RlbApwb3AKZnJhbWVfZGlnIC0yCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApib3hfcHV0CnJldHN1YgoKLy8gZXJyb3IKZXJyb3JfNzoKcHJvdG8gMCAwCmludGNfMCAvLyAwCi8vIERlbGliZXJhdGUgZXJyb3IKYXNzZXJ0CnJldHN1YgoKLy8gZGVmYXVsdF92YWx1ZQpkZWZhdWx0dmFsdWVfODoKcHJvdG8gMSAxCmJ5dGVjXzEgLy8gIiIKZnJhbWVfZGlnIC0xCmV4dHJhY3QgMiAwCmZyYW1lX2J1cnkgMApmcmFtZV9kaWcgMApsZW4KaXRvYgpleHRyYWN0IDYgMApmcmFtZV9kaWcgMApjb25jYXQKZnJhbWVfYnVyeSAwCnJldHN1YgoKLy8gZGVmYXVsdF92YWx1ZV9pbnQKZGVmYXVsdHZhbHVlaW50Xzk6CnByb3RvIDEgMQppbnRjXzAgLy8gMApmcmFtZV9kaWcgLTEKZnJhbWVfYnVyeSAwCnJldHN1YgoKLy8gZGVmYXVsdF92YWx1ZV9mcm9tX2FiaQpkZWZhdWx0dmFsdWVmcm9tYWJpXzEwOgpwcm90byAxIDEKYnl0ZWNfMSAvLyAiIgpwdXNoYnl0ZXMgMHg0MTQyNDkyYzIwIC8vICJBQkksICIKZnJhbWVfZGlnIC0xCmV4dHJhY3QgMiAwCmNvbmNhdApmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKbGVuCml0b2IKZXh0cmFjdCA2IDAKZnJhbWVfZGlnIDAKY29uY2F0CmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIGRlZmF1bHRfdmFsdWVfZnJvbV9nbG9iYWxfc3RhdGUKZGVmYXVsdHZhbHVlZnJvbWdsb2JhbHN0YXRlXzExOgpwcm90byAxIDEKaW50Y18wIC8vIDAKZnJhbWVfZGlnIC0xCmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIGRlZmF1bHRfdmFsdWVfZnJvbV9sb2NhbF9zdGF0ZQpkZWZhdWx0dmFsdWVmcm9tbG9jYWxzdGF0ZV8xMjoKcHJvdG8gMSAxCmJ5dGVjXzEgLy8gIiIKcHVzaGJ5dGVzIDB4NGM2ZjYzNjE2YzIwNzM3NDYxNzQ2NTJjMjAgLy8gIkxvY2FsIHN0YXRlLCAiCmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApjb25jYXQKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCmxlbgppdG9iCmV4dHJhY3QgNiAwCmZyYW1lX2RpZyAwCmNvbmNhdApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyBjcmVhdGUKY3JlYXRlXzEzOgpwcm90byAwIDAKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydApwdXNoYnl0ZXMgMHg3NjYxNmM3NTY1IC8vICJ2YWx1ZSIKcHVzaGludCBUTVBMX1ZBTFVFIC8vIFRNUExfVkFMVUUKYXBwX2dsb2JhbF9wdXQKcmV0c3ViCgovLyBjcmVhdGVfYWJpCmNyZWF0ZWFiaV8xNDoKcHJvdG8gMSAxCmJ5dGVjXzEgLy8gIiIKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydApmcmFtZV9kaWcgLTEKZXh0cmFjdCAyIDAKZnJhbWVfYnVyeSAwCmZyYW1lX2RpZyAwCmxlbgppdG9iCmV4dHJhY3QgNiAwCmZyYW1lX2RpZyAwCmNvbmNhdApmcmFtZV9idXJ5IDAKcmV0c3ViCgovLyB1cGRhdGUKdXBkYXRlXzE1Ogpwcm90byAwIDAKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydAppbnRjIDQgLy8gVE1QTF9VUERBVEFCTEUKLy8gQ2hlY2sgYXBwIGlzIHVwZGF0YWJsZQphc3NlcnQKcmV0c3ViCgovLyB1cGRhdGVfYWJpCnVwZGF0ZWFiaV8xNjoKcHJvdG8gMSAxCmJ5dGVjXzEgLy8gIiIKdHhuIFNlbmRlcgpnbG9iYWwgQ3JlYXRvckFkZHJlc3MKPT0KLy8gdW5hdXRob3JpemVkCmFzc2VydAppbnRjIDQgLy8gVE1QTF9VUERBVEFCTEUKLy8gQ2hlY2sgYXBwIGlzIHVwZGF0YWJsZQphc3NlcnQKZnJhbWVfZGlnIC0xCmV4dHJhY3QgMiAwCmZyYW1lX2J1cnkgMApmcmFtZV9kaWcgMApsZW4KaXRvYgpleHRyYWN0IDYgMApmcmFtZV9kaWcgMApjb25jYXQKZnJhbWVfYnVyeSAwCnJldHN1YgoKLy8gZGVsZXRlCmRlbGV0ZV8xNzoKcHJvdG8gMCAwCnR4biBTZW5kZXIKZ2xvYmFsIENyZWF0b3JBZGRyZXNzCj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKaW50YyA1IC8vIFRNUExfREVMRVRBQkxFCi8vIENoZWNrIGFwcCBpcyBkZWxldGFibGUKYXNzZXJ0CnJldHN1YgoKLy8gZGVsZXRlX2FiaQpkZWxldGVhYmlfMTg6CnByb3RvIDEgMQpieXRlY18xIC8vICIiCnR4biBTZW5kZXIKZ2xvYmFsIENyZWF0b3JBZGRyZXNzCj09Ci8vIHVuYXV0aG9yaXplZAphc3NlcnQKaW50YyA1IC8vIFRNUExfREVMRVRBQkxFCi8vIENoZWNrIGFwcCBpcyBkZWxldGFibGUKYXNzZXJ0CmZyYW1lX2RpZyAtMQpleHRyYWN0IDIgMApmcmFtZV9idXJ5IDAKZnJhbWVfZGlnIDAKbGVuCml0b2IKZXh0cmFjdCA2IDAKZnJhbWVfZGlnIDAKY29uY2F0CmZyYW1lX2J1cnkgMApyZXRzdWIKCi8vIG9wdF9pbgpvcHRpbl8xOToKcHJvdG8gMCAwCmludGNfMSAvLyAxCnJldHVybg==\",\n\t    \"clear\": \"I3ByYWdtYSB2ZXJzaW9uIDgKcHVzaGludCAwIC8vIDAKcmV0dXJu\"\n\t  },\n\t  \"state\": {\n\t    \"global\": {\n\t      \"num_byte_slices\": 3,\n\t      \"num_uints\": 3\n\t    },\n\t    \"local\": {\n\t      \"num_byte_slices\": 3,\n", "      \"num_uints\": 2\n\t    }\n\t  },\n\t  \"schema\": {\n\t    \"global\": {\n\t      \"declared\": {\n\t        \"bytes1\": {\n\t          \"type\": \"bytes\",\n\t          \"key\": \"bytes1\",\n\t          \"descr\": \"\"\n", "        },\n\t        \"bytes2\": {\n\t          \"type\": \"bytes\",\n\t          \"key\": \"bytes2\",\n\t          \"descr\": \"\"\n\t        },\n\t        \"int1\": {\n\t          \"type\": \"uint64\",\n\t          \"key\": \"int1\",\n\t          \"descr\": \"\"\n", "        },\n\t        \"int2\": {\n\t          \"type\": \"uint64\",\n\t          \"key\": \"int2\",\n\t          \"descr\": \"\"\n\t        },\n\t        \"value\": {\n\t          \"type\": \"uint64\",\n\t          \"key\": \"value\",\n\t          \"descr\": \"\"\n", "        }\n\t      },\n\t      \"reserved\": {\n\t        \"reserved_global_bytes\": {\n\t          \"type\": \"bytes\",\n\t          \"max_keys\": 1,\n\t          \"descr\": \"Reserved global state description\"\n\t        }\n\t      }\n\t    },\n", "    \"local\": {\n\t      \"declared\": {\n\t        \"local_bytes1\": {\n\t          \"type\": \"bytes\",\n\t          \"key\": \"local_bytes1\",\n\t          \"descr\": \"\"\n\t        },\n\t        \"local_bytes2\": {\n\t          \"type\": \"bytes\",\n\t          \"key\": \"local_bytes2\",\n", "          \"descr\": \"\"\n\t        },\n\t        \"local_int1\": {\n\t          \"type\": \"uint64\",\n\t          \"key\": \"local_int1\",\n\t          \"descr\": \"\"\n\t        },\n\t        \"local_int2\": {\n\t          \"type\": \"uint64\",\n\t          \"key\": \"local_int2\",\n", "          \"descr\": \"\"\n\t        }\n\t      },\n\t      \"reserved\": {\n\t        \"reserved_local_bytes\": {\n\t          \"type\": \"bytes\",\n\t          \"max_keys\": 1,\n\t          \"descr\": \"Reserved local state description\"\n\t        }\n\t      }\n", "    }\n\t  },\n\t  \"contract\": {\n\t    \"name\": \"StateApp\",\n\t    \"methods\": [\n\t      {\n\t        \"name\": \"call_abi\",\n\t        \"args\": [\n\t          {\n\t            \"type\": \"string\",\n", "            \"name\": \"value\"\n\t          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"string\"\n\t        }\n\t      },\n\t      {\n\t        \"name\": \"call_abi_txn\",\n\t        \"args\": [\n", "          {\n\t            \"type\": \"pay\",\n\t            \"name\": \"txn\"\n\t          },\n\t          {\n\t            \"type\": \"string\",\n\t            \"name\": \"value\"\n\t          }\n\t        ],\n\t        \"returns\": {\n", "          \"type\": \"string\"\n\t        }\n\t      },\n\t      {\n\t        \"name\": \"call_with_references\",\n\t        \"args\": [\n\t          {\n\t            \"type\": \"asset\",\n\t            \"name\": \"asset\"\n\t          },\n", "          {\n\t            \"type\": \"account\",\n\t            \"name\": \"account\"\n\t          },\n\t          {\n\t            \"type\": \"application\",\n\t            \"name\": \"application\"\n\t          }\n\t        ],\n\t        \"returns\": {\n", "          \"type\": \"uint64\"\n\t        }\n\t      },\n\t      {\n\t        \"name\": \"set_global\",\n\t        \"args\": [\n\t          {\n\t            \"type\": \"uint64\",\n\t            \"name\": \"int1\"\n\t          },\n", "          {\n\t            \"type\": \"uint64\",\n\t            \"name\": \"int2\"\n\t          },\n\t          {\n\t            \"type\": \"string\",\n\t            \"name\": \"bytes1\"\n\t          },\n\t          {\n\t            \"type\": \"byte[4]\",\n", "            \"name\": \"bytes2\"\n\t          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"void\"\n\t        }\n\t      },\n\t      {\n\t        \"name\": \"set_local\",\n\t        \"args\": [\n", "          {\n\t            \"type\": \"uint64\",\n\t            \"name\": \"int1\"\n\t          },\n\t          {\n\t            \"type\": \"uint64\",\n\t            \"name\": \"int2\"\n\t          },\n\t          {\n\t            \"type\": \"string\",\n", "            \"name\": \"bytes1\"\n\t          },\n\t          {\n\t            \"type\": \"byte[4]\",\n\t            \"name\": \"bytes2\"\n\t          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"void\"\n\t        }\n", "      },\n\t      {\n\t        \"name\": \"set_box\",\n\t        \"args\": [\n\t          {\n\t            \"type\": \"byte[4]\",\n\t            \"name\": \"name\"\n\t          },\n\t          {\n\t            \"type\": \"string\",\n", "            \"name\": \"value\"\n\t          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"void\"\n\t        }\n\t      },\n\t      {\n\t        \"name\": \"error\",\n\t        \"args\": [],\n", "        \"returns\": {\n\t          \"type\": \"void\"\n\t        }\n\t      },\n\t      {\n\t        \"name\": \"default_value\",\n\t        \"args\": [\n\t          {\n\t            \"type\": \"string\",\n\t            \"name\": \"arg_with_default\"\n", "          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"string\"\n\t        }\n\t      },\n\t      {\n\t        \"name\": \"default_value_int\",\n\t        \"args\": [\n\t          {\n", "            \"type\": \"uint64\",\n\t            \"name\": \"arg_with_default\"\n\t          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"uint64\"\n\t        }\n\t      },\n\t      {\n\t        \"name\": \"default_value_from_abi\",\n", "        \"args\": [\n\t          {\n\t            \"type\": \"string\",\n\t            \"name\": \"arg_with_default\"\n\t          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"string\"\n\t        }\n\t      },\n", "      {\n\t        \"name\": \"default_value_from_global_state\",\n\t        \"args\": [\n\t          {\n\t            \"type\": \"uint64\",\n\t            \"name\": \"arg_with_default\"\n\t          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"uint64\"\n", "        }\n\t      },\n\t      {\n\t        \"name\": \"default_value_from_local_state\",\n\t        \"args\": [\n\t          {\n\t            \"type\": \"string\",\n\t            \"name\": \"arg_with_default\"\n\t          }\n\t        ],\n", "        \"returns\": {\n\t          \"type\": \"string\"\n\t        }\n\t      },\n\t      {\n\t        \"name\": \"create_abi\",\n\t        \"args\": [\n\t          {\n\t            \"type\": \"string\",\n\t            \"name\": \"input\"\n", "          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"string\"\n\t        }\n\t      },\n\t      {\n\t        \"name\": \"update_abi\",\n\t        \"args\": [\n\t          {\n", "            \"type\": \"string\",\n\t            \"name\": \"input\"\n\t          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"string\"\n\t        }\n\t      },\n\t      {\n\t        \"name\": \"delete_abi\",\n", "        \"args\": [\n\t          {\n\t            \"type\": \"string\",\n\t            \"name\": \"input\"\n\t          }\n\t        ],\n\t        \"returns\": {\n\t          \"type\": \"string\"\n\t        }\n\t      },\n", "      {\n\t        \"name\": \"opt_in\",\n\t        \"args\": [],\n\t        \"returns\": {\n\t          \"type\": \"void\"\n\t        }\n\t      }\n\t    ],\n\t    \"networks\": {}\n\t  },\n", "  \"bare_call_config\": {\n\t    \"delete_application\": \"CALL\",\n\t    \"no_op\": \"CREATE\",\n\t    \"opt_in\": \"CREATE\",\n\t    \"update_application\": \"CALL\"\n\t  }\n\t}\n\t/**\n\t * Defines an onCompletionAction of 'no_op'\n\t */\n", "export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }\n\t/**\n\t * Defines an onCompletionAction of 'opt_in'\n\t */\n\texport type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }\n\t/**\n\t * Defines an onCompletionAction of 'close_out'\n\t */\n\texport type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }\n\t/**\n", " * Defines an onCompletionAction of 'delete_application'\n\t */\n\texport type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }\n\t/**\n\t * Defines an onCompletionAction of 'update_application'\n\t */\n\texport type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }\n\t/**\n\t * A state record containing a single unsigned integer\n\t */\n", "export type IntegerState = {\n\t  /**\n\t   * Gets the state value as a BigInt \n\t   */\n\t  asBigInt(): bigint\n\t  /**\n\t   * Gets the state value as a number.\n\t   */\n\t  asNumber(): number\n\t}\n", "/**\n\t * A state record containing binary data\n\t */\n\texport type BinaryState = {\n\t  /**\n\t   * Gets the state value as a Uint8Array\n\t   */\n\t  asByteArray(): Uint8Array\n\t  /**\n\t   * Gets the state value as a string\n", "   */\n\t  asString(): string\n\t}\n\t/**\n\t * Defines the types of available calls and state of the StateApp smart contract.\n\t */\n\texport type StateApp = {\n\t  /**\n\t   * Maps method signatures / names to their argument and return types.\n\t   */\n", "  methods:\n\t    & Record<'call_abi(string)string' | 'call_abi', {\n\t      argsObj: {\n\t        value: string\n\t      }\n\t      argsTuple: [value: string]\n\t      returns: string\n\t    }>\n\t    & Record<'call_abi_txn(pay,string)string' | 'call_abi_txn', {\n\t      argsObj: {\n", "        txn: TransactionToSign | Transaction | Promise<SendTransactionResult>\n\t        value: string\n\t      }\n\t      argsTuple: [txn: TransactionToSign | Transaction | Promise<SendTransactionResult>, value: string]\n\t      returns: string\n\t    }>\n\t    & Record<'call_with_references(asset,account,application)uint64' | 'call_with_references', {\n\t      argsObj: {\n\t        asset: number | bigint\n\t        account: string | Uint8Array\n", "        application: number | bigint\n\t      }\n\t      argsTuple: [asset: number | bigint, account: string | Uint8Array, application: number | bigint]\n\t      returns: bigint\n\t    }>\n\t    & Record<'set_global(uint64,uint64,string,byte[4])void' | 'set_global', {\n\t      argsObj: {\n\t        int1: bigint | number\n\t        int2: bigint | number\n\t        bytes1: string\n", "        bytes2: Uint8Array\n\t      }\n\t      argsTuple: [int1: bigint | number, int2: bigint | number, bytes1: string, bytes2: Uint8Array]\n\t      returns: void\n\t    }>\n\t    & Record<'set_local(uint64,uint64,string,byte[4])void' | 'set_local', {\n\t      argsObj: {\n\t        int1: bigint | number\n\t        int2: bigint | number\n\t        bytes1: string\n", "        bytes2: Uint8Array\n\t      }\n\t      argsTuple: [int1: bigint | number, int2: bigint | number, bytes1: string, bytes2: Uint8Array]\n\t      returns: void\n\t    }>\n\t    & Record<'set_box(byte[4],string)void' | 'set_box', {\n\t      argsObj: {\n\t        name: Uint8Array\n\t        value: string\n\t      }\n", "      argsTuple: [name: Uint8Array, value: string]\n\t      returns: void\n\t    }>\n\t    & Record<'error()void' | 'error', {\n\t      argsObj: {\n\t      }\n\t      argsTuple: []\n\t      returns: void\n\t    }>\n\t    & Record<'default_value(string)string' | 'default_value', {\n", "      argsObj: {\n\t        arg_with_default?: string\n\t      }\n\t      argsTuple: [arg_with_default: string | undefined]\n\t      returns: string\n\t    }>\n\t    & Record<'default_value_int(uint64)uint64' | 'default_value_int', {\n\t      argsObj: {\n\t        arg_with_default?: bigint | number\n\t      }\n", "      argsTuple: [arg_with_default: bigint | number | undefined]\n\t      returns: bigint\n\t    }>\n\t    & Record<'default_value_from_abi(string)string' | 'default_value_from_abi', {\n\t      argsObj: {\n\t        arg_with_default?: string\n\t      }\n\t      argsTuple: [arg_with_default: string | undefined]\n\t      returns: string\n\t    }>\n", "    & Record<'default_value_from_global_state(uint64)uint64' | 'default_value_from_global_state', {\n\t      argsObj: {\n\t        arg_with_default?: bigint | number\n\t      }\n\t      argsTuple: [arg_with_default: bigint | number | undefined]\n\t      returns: bigint\n\t    }>\n\t    & Record<'default_value_from_local_state(string)string' | 'default_value_from_local_state', {\n\t      argsObj: {\n\t        arg_with_default?: string\n", "      }\n\t      argsTuple: [arg_with_default: string | undefined]\n\t      returns: string\n\t    }>\n\t    & Record<'create_abi(string)string' | 'create_abi', {\n\t      argsObj: {\n\t        input: string\n\t      }\n\t      argsTuple: [input: string]\n\t      returns: string\n", "    }>\n\t    & Record<'update_abi(string)string' | 'update_abi', {\n\t      argsObj: {\n\t        input: string\n\t      }\n\t      argsTuple: [input: string]\n\t      returns: string\n\t    }>\n\t    & Record<'delete_abi(string)string' | 'delete_abi', {\n\t      argsObj: {\n", "        input: string\n\t      }\n\t      argsTuple: [input: string]\n\t      returns: string\n\t    }>\n\t    & Record<'opt_in()void' | 'opt_in', {\n\t      argsObj: {\n\t      }\n\t      argsTuple: []\n\t      returns: void\n", "    }>\n\t  /**\n\t   * Defines the shape of the global and local state of the application.\n\t   */\n\t  state: {\n\t    global: {\n\t      'bytes1'?: BinaryState\n\t      'bytes2'?: BinaryState\n\t      'int1'?: IntegerState\n\t      'int2'?: IntegerState\n", "      'value'?: IntegerState\n\t    }\n\t    local: {\n\t      'local_bytes1'?: BinaryState\n\t      'local_bytes2'?: BinaryState\n\t      'local_int1'?: IntegerState\n\t      'local_int2'?: IntegerState\n\t    }\n\t  }\n\t}\n", "/**\n\t * Defines the possible abi call signatures\n\t */\n\texport type StateAppSig = keyof StateApp['methods']\n\t/**\n\t * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made\n\t */\n\texport type TypedCallParams<TSignature extends StateAppSig | undefined> = {\n\t  method: TSignature\n\t  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>\n", "} & AppClientCallCoreParams & CoreAppCallArgs\n\t/**\n\t * Defines the arguments required for a bare call\n\t */\n\texport type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>\n\t/**\n\t * Maps a method signature from the StateApp smart contract to the method's arguments in either tuple of struct form\n\t */\n\texport type MethodArgs<TSignature extends StateAppSig> = StateApp['methods'][TSignature]['argsObj' | 'argsTuple']\n\t/**\n", " * Maps a method signature from the StateApp smart contract to the method's return type\n\t */\n\texport type MethodReturn<TSignature extends StateAppSig> = StateApp['methods'][TSignature]['returns']\n\t/**\n\t * A factory for available 'create' calls\n\t */\n\texport type StateAppCreateCalls = (typeof StateAppCallFactory)['create']\n\t/**\n\t * Defines supported create methods for this smart contract\n\t */\n", "export type StateAppCreateCallParams =\n\t  | (TypedCallParams<undefined> & (OnCompleteNoOp | OnCompleteOptIn))\n\t  | (TypedCallParams<'create_abi(string)string'> & (OnCompleteNoOp))\n\t/**\n\t * A factory for available 'update' calls\n\t */\n\texport type StateAppUpdateCalls = (typeof StateAppCallFactory)['update']\n\t/**\n\t * Defines supported update methods for this smart contract\n\t */\n", "export type StateAppUpdateCallParams =\n\t  | TypedCallParams<undefined>\n\t  | TypedCallParams<'update_abi(string)string'>\n\t/**\n\t * A factory for available 'delete' calls\n\t */\n\texport type StateAppDeleteCalls = (typeof StateAppCallFactory)['delete']\n\t/**\n\t * Defines supported delete methods for this smart contract\n\t */\n", "export type StateAppDeleteCallParams =\n\t  | TypedCallParams<undefined>\n\t  | TypedCallParams<'delete_abi(string)string'>\n\t/**\n\t * Defines arguments required for the deploy method.\n\t */\n\texport type StateAppDeployArgs = {\n\t  deployTimeParams?: TealTemplateParams\n\t  /**\n\t   * A delegate which takes a create call factory and returns the create call params for this smart contract\n", "   */\n\t  createCall?: (callFactory: StateAppCreateCalls) => StateAppCreateCallParams\n\t  /**\n\t   * A delegate which takes a update call factory and returns the update call params for this smart contract\n\t   */\n\t  updateCall?: (callFactory: StateAppUpdateCalls) => StateAppUpdateCallParams\n\t  /**\n\t   * A delegate which takes a delete call factory and returns the delete call params for this smart contract\n\t   */\n\t  deleteCall?: (callFactory: StateAppDeleteCalls) => StateAppDeleteCallParams\n", "}\n\t/**\n\t * Exposes methods for constructing all available smart contract calls\n\t */\n\texport abstract class StateAppCallFactory {\n\t  /**\n\t   * Gets available create call factories\n\t   */\n\t  static get create() {\n\t    return {\n", "      /**\n\t       * Constructs a create call for the StateApp smart contract using a bare call\n\t       *\n\t       * @param params Any parameters for the call\n\t       * @returns A TypedCallParams object for the call\n\t       */\n\t      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp | OnCompleteOptIn) = {}) {\n\t        return {\n\t          method: undefined,\n\t          methodArgs: undefined,\n", "          ...params,\n\t        }\n\t      },\n\t      /**\n\t       * Constructs a create call for the StateApp smart contract using the create_abi(string)string ABI method\n\t       *\n\t       * @param args Any args for the contract call\n\t       * @param params Any additional parameters for the call\n\t       * @returns A TypedCallParams object for the call\n\t       */\n", "      createAbi(args: MethodArgs<'create_abi(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {\n\t        return {\n\t          method: 'create_abi(string)string' as const,\n\t          methodArgs: Array.isArray(args) ? args : [args.input],\n\t          ...params,\n\t        }\n\t      },\n\t    }\n\t  }\n\t  /**\n", "   * Gets available update call factories\n\t   */\n\t  static get update() {\n\t    return {\n\t      /**\n\t       * Constructs an update call for the StateApp smart contract using a bare call\n\t       *\n\t       * @param params Any parameters for the call\n\t       * @returns A TypedCallParams object for the call\n\t       */\n", "      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams = {}) {\n\t        return {\n\t          method: undefined,\n\t          methodArgs: undefined,\n\t          ...params,\n\t        }\n\t      },\n\t      /**\n\t       * Constructs an update call for the StateApp smart contract using the update_abi(string)string ABI method\n\t       *\n", "       * @param args Any args for the contract call\n\t       * @param params Any additional parameters for the call\n\t       * @returns A TypedCallParams object for the call\n\t       */\n\t      updateAbi(args: MethodArgs<'update_abi(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams = {}) {\n\t        return {\n\t          method: 'update_abi(string)string' as const,\n\t          methodArgs: Array.isArray(args) ? args : [args.input],\n\t          ...params,\n\t        }\n", "      },\n\t    }\n\t  }\n\t  /**\n\t   * Gets available delete call factories\n\t   */\n\t  static get delete() {\n\t    return {\n\t      /**\n\t       * Constructs a delete call for the StateApp smart contract using a bare call\n", "       *\n\t       * @param params Any parameters for the call\n\t       * @returns A TypedCallParams object for the call\n\t       */\n\t      bare(params: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t        return {\n\t          method: undefined,\n\t          methodArgs: undefined,\n\t          ...params,\n\t        }\n", "      },\n\t      /**\n\t       * Constructs a delete call for the StateApp smart contract using the delete_abi(string)string ABI method\n\t       *\n\t       * @param args Any args for the contract call\n\t       * @param params Any additional parameters for the call\n\t       * @returns A TypedCallParams object for the call\n\t       */\n\t      deleteAbi(args: MethodArgs<'delete_abi(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t        return {\n", "          method: 'delete_abi(string)string' as const,\n\t          methodArgs: Array.isArray(args) ? args : [args.input],\n\t          ...params,\n\t        }\n\t      },\n\t    }\n\t  }\n\t  /**\n\t   * Gets available optIn call factories\n\t   */\n", "  static get optIn() {\n\t    return {\n\t      /**\n\t       * Constructs an opt in call for the StateApp smart contract using the opt_in()void ABI method\n\t       *\n\t       * @param args Any args for the contract call\n\t       * @param params Any additional parameters for the call\n\t       * @returns A TypedCallParams object for the call\n\t       */\n\t      optIn(args: MethodArgs<'opt_in()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n", "        return {\n\t          method: 'opt_in()void' as const,\n\t          methodArgs: Array.isArray(args) ? args : [],\n\t          ...params,\n\t        }\n\t      },\n\t    }\n\t  }\n\t  /**\n\t   * Constructs a no op call for the call_abi(string)string ABI method\n", "   *\n\t   * @param args Any args for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n\t   */\n\t  static callAbi(args: MethodArgs<'call_abi(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n\t    return {\n\t      method: 'call_abi(string)string' as const,\n\t      methodArgs: Array.isArray(args) ? args : [args.value],\n\t      ...params,\n", "    }\n\t  }\n\t  /**\n\t   * Constructs a no op call for the call_abi_txn(pay,string)string ABI method\n\t   *\n\t   * @param args Any args for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n\t   */\n\t  static callAbiTxn(args: MethodArgs<'call_abi_txn(pay,string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n", "    return {\n\t      method: 'call_abi_txn(pay,string)string' as const,\n\t      methodArgs: Array.isArray(args) ? args : [args.txn, args.value],\n\t      ...params,\n\t    }\n\t  }\n\t  /**\n\t   * Constructs a no op call for the call_with_references(asset,account,application)uint64 ABI method\n\t   *\n\t   * @param args Any args for the contract call\n", "   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n\t   */\n\t  static callWithReferences(args: MethodArgs<'call_with_references(asset,account,application)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n\t    return {\n\t      method: 'call_with_references(asset,account,application)uint64' as const,\n\t      methodArgs: Array.isArray(args) ? args : [args.asset, args.account, args.application],\n\t      ...params,\n\t    }\n\t  }\n", "  /**\n\t   * Constructs a no op call for the set_global(uint64,uint64,string,byte[4])void ABI method\n\t   *\n\t   * @param args Any args for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n\t   */\n\t  static setGlobal(args: MethodArgs<'set_global(uint64,uint64,string,byte[4])void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n\t    return {\n\t      method: 'set_global(uint64,uint64,string,byte[4])void' as const,\n", "      methodArgs: Array.isArray(args) ? args : [args.int1, args.int2, args.bytes1, args.bytes2],\n\t      ...params,\n\t    }\n\t  }\n\t  /**\n\t   * Constructs a no op call for the set_local(uint64,uint64,string,byte[4])void ABI method\n\t   *\n\t   * @param args Any args for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n", "   */\n\t  static setLocal(args: MethodArgs<'set_local(uint64,uint64,string,byte[4])void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n\t    return {\n\t      method: 'set_local(uint64,uint64,string,byte[4])void' as const,\n\t      methodArgs: Array.isArray(args) ? args : [args.int1, args.int2, args.bytes1, args.bytes2],\n\t      ...params,\n\t    }\n\t  }\n\t  /**\n\t   * Constructs a no op call for the set_box(byte[4],string)void ABI method\n", "   *\n\t   * @param args Any args for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n\t   */\n\t  static setBox(args: MethodArgs<'set_box(byte[4],string)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n\t    return {\n\t      method: 'set_box(byte[4],string)void' as const,\n\t      methodArgs: Array.isArray(args) ? args : [args.name, args.value],\n\t      ...params,\n", "    }\n\t  }\n\t  /**\n\t   * Constructs a no op call for the error()void ABI method\n\t   *\n\t   * @param args Any args for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n\t   */\n\t  static error(args: MethodArgs<'error()void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n", "    return {\n\t      method: 'error()void' as const,\n\t      methodArgs: Array.isArray(args) ? args : [],\n\t      ...params,\n\t    }\n\t  }\n\t  /**\n\t   * Constructs a no op call for the default_value(string)string ABI method\n\t   *\n\t   * @param args Any args for the contract call\n", "   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n\t   */\n\t  static defaultValue(args: MethodArgs<'default_value(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n\t    return {\n\t      method: 'default_value(string)string' as const,\n\t      methodArgs: Array.isArray(args) ? args : [args.arg_with_default],\n\t      ...params,\n\t    }\n\t  }\n", "  /**\n\t   * Constructs a no op call for the default_value_int(uint64)uint64 ABI method\n\t   *\n\t   * @param args Any args for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n\t   */\n\t  static defaultValueInt(args: MethodArgs<'default_value_int(uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n\t    return {\n\t      method: 'default_value_int(uint64)uint64' as const,\n", "      methodArgs: Array.isArray(args) ? args : [args.arg_with_default],\n\t      ...params,\n\t    }\n\t  }\n\t  /**\n\t   * Constructs a no op call for the default_value_from_abi(string)string ABI method\n\t   *\n\t   * @param args Any args for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n", "   */\n\t  static defaultValueFromAbi(args: MethodArgs<'default_value_from_abi(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n\t    return {\n\t      method: 'default_value_from_abi(string)string' as const,\n\t      methodArgs: Array.isArray(args) ? args : [args.arg_with_default],\n\t      ...params,\n\t    }\n\t  }\n\t  /**\n\t   * Constructs a no op call for the default_value_from_global_state(uint64)uint64 ABI method\n", "   *\n\t   * @param args Any args for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n\t   */\n\t  static defaultValueFromGlobalState(args: MethodArgs<'default_value_from_global_state(uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n\t    return {\n\t      method: 'default_value_from_global_state(uint64)uint64' as const,\n\t      methodArgs: Array.isArray(args) ? args : [args.arg_with_default],\n\t      ...params,\n", "    }\n\t  }\n\t  /**\n\t   * Constructs a no op call for the default_value_from_local_state(string)string ABI method\n\t   *\n\t   * @param args Any args for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns A TypedCallParams object for the call\n\t   */\n\t  static defaultValueFromLocalState(args: MethodArgs<'default_value_from_local_state(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {\n", "    return {\n\t      method: 'default_value_from_local_state(string)string' as const,\n\t      methodArgs: Array.isArray(args) ? args : [args.arg_with_default],\n\t      ...params,\n\t    }\n\t  }\n\t}\n\t/**\n\t * A client to make calls to the StateApp smart contract\n\t */\n", "export class StateAppClient {\n\t  /**\n\t   * The underlying `ApplicationClient` for when you want to have more flexibility\n\t   */\n\t  public readonly appClient: ApplicationClient\n\t  private readonly sender: SendTransactionFrom | undefined\n\t  /**\n\t   * Creates a new instance of `StateAppClient`\n\t   *\n\t   * @param appDetails appDetails The details to identify the app to deploy\n", "   * @param algod An algod client instance\n\t   */\n\t  constructor(appDetails: AppDetails, private algod: Algodv2) {\n\t    this.sender = appDetails.sender\n\t    this.appClient = algokit.getAppClient({\n\t      ...appDetails,\n\t      app: APP_SPEC\n\t    }, algod)\n\t  }\n\t  /**\n", "   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type\n\t   *\n\t   * @param result The AppCallTransactionResult to be mapped\n\t   * @param returnValueFormatter An optional delegate to format the return value if required\n\t   * @returns The smart contract response with an updated return value\n\t   */\n\t  protected mapReturnValue<TReturn>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> {\n\t    if(result.return?.decodeError) {\n\t      throw result.return.decodeError\n\t    }\n", "    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined\n\t      ? returnValueFormatter(result.return.returnValue)\n\t      : result.return?.returnValue as TReturn | undefined\n\t      return { ...result, return: returnValue }\n\t  }\n\t  /**\n\t   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP\n\t   *\n\t   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters\n\t   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type\n", "   * @returns The result of the smart contract call\n\t   */\n\t  public async call<TSignature extends keyof StateApp['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {\n\t    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)\n\t  }\n\t  /**\n\t   * Idempotently deploys the StateApp smart contract.\n\t   *\n\t   * @param params The arguments for the contract calls and any additional parameters for the call\n\t   * @returns The deployment result\n", "   */\n\t  public deploy(params: StateAppDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {\n\t    const createArgs = params.createCall?.(StateAppCallFactory.create)\n\t    const updateArgs = params.updateCall?.(StateAppCallFactory.update)\n\t    const deleteArgs = params.deleteCall?.(StateAppCallFactory.delete)\n\t    return this.appClient.deploy({\n\t      ...params,\n\t      updateArgs,\n\t      deleteArgs,\n\t      createArgs,\n", "      createOnCompleteAction: createArgs?.onCompleteAction,\n\t    })\n\t  }\n\t  /**\n\t   * Gets available create methods\n\t   */\n\t  public get create() {\n\t    const $this = this\n\t    return {\n\t      /**\n", "       * Creates a new instance of the StateApp smart contract using a bare call.\n\t       *\n\t       * @param args The arguments for the bare call\n\t       * @returns The create result\n\t       */\n\t      bare(args: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs & (OnCompleteNoOp | OnCompleteOptIn) = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n\t        return $this.appClient.create(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n\t      },\n\t      /**\n\t       * Creates a new instance of the StateApp smart contract using the create_abi(string)string ABI method.\n", "       *\n\t       * @param args The arguments for the smart contract call\n\t       * @param params Any additional parameters for the call\n\t       * @returns The create result\n\t       */\n\t      async createAbi(args: MethodArgs<'create_abi(string)string'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}): Promise<AppCallTransactionResultOfType<MethodReturn<'create_abi(string)string'>>> {\n\t        return $this.mapReturnValue(await $this.appClient.create(StateAppCallFactory.create.createAbi(args, params)))\n\t      },\n\t    }\n\t  }\n", "  /**\n\t   * Gets available update methods\n\t   */\n\t  public get update() {\n\t    const $this = this\n\t    return {\n\t      /**\n\t       * Updates an existing instance of the StateApp smart contract using a bare call.\n\t       *\n\t       * @param args The arguments for the bare call\n", "       * @returns The update result\n\t       */\n\t      bare(args: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n\t        return $this.appClient.update(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n\t      },\n\t      /**\n\t       * Updates an existing instance of the StateApp smart contract using the update_abi(string)string ABI method.\n\t       *\n\t       * @param args The arguments for the smart contract call\n\t       * @param params Any additional parameters for the call\n", "       * @returns The update result\n\t       */\n\t      async updateAbi(args: MethodArgs<'update_abi(string)string'>, params: AppClientCallCoreParams & AppClientCompilationParams = {}): Promise<AppCallTransactionResultOfType<MethodReturn<'update_abi(string)string'>>> {\n\t        return $this.mapReturnValue(await $this.appClient.update(StateAppCallFactory.update.updateAbi(args, params)))\n\t      },\n\t    }\n\t  }\n\t  /**\n\t   * Gets available delete methods\n\t   */\n", "  public get delete() {\n\t    const $this = this\n\t    return {\n\t      /**\n\t       * Deletes an existing instance of the StateApp smart contract using a bare call.\n\t       *\n\t       * @param args The arguments for the bare call\n\t       * @returns The delete result\n\t       */\n\t      bare(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}): Promise<AppCallTransactionResultOfType<undefined>> {\n", "        return $this.appClient.delete(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>\n\t      },\n\t      /**\n\t       * Deletes an existing instance of the StateApp smart contract using the delete_abi(string)string ABI method.\n\t       *\n\t       * @param args The arguments for the smart contract call\n\t       * @param params Any additional parameters for the call\n\t       * @returns The delete result\n\t       */\n\t      async deleteAbi(args: MethodArgs<'delete_abi(string)string'>, params: AppClientCallCoreParams = {}): Promise<AppCallTransactionResultOfType<MethodReturn<'delete_abi(string)string'>>> {\n", "        return $this.mapReturnValue(await $this.appClient.delete(StateAppCallFactory.delete.deleteAbi(args, params)))\n\t      },\n\t    }\n\t  }\n\t  /**\n\t   * Gets available optIn methods\n\t   */\n\t  public get optIn() {\n\t    const $this = this\n\t    return {\n", "      /**\n\t       * Opts the user into an existing instance of the StateApp smart contract using the opt_in()void ABI method.\n\t       *\n\t       * @param args The arguments for the smart contract call\n\t       * @param params Any additional parameters for the call\n\t       * @returns The optIn result\n\t       */\n\t      async optIn(args: MethodArgs<'opt_in()void'>, params: AppClientCallCoreParams = {}): Promise<AppCallTransactionResultOfType<MethodReturn<'opt_in()void'>>> {\n\t        return $this.mapReturnValue(await $this.appClient.optIn(StateAppCallFactory.optIn.optIn(args, params)))\n\t      },\n", "    }\n\t  }\n\t  /**\n\t   * Makes a clear_state call to an existing instance of the StateApp smart contract.\n\t   *\n\t   * @param args The arguments for the bare call\n\t   * @returns The clear_state result\n\t   */\n\t  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.appClient.clearState(args)\n", "  }\n\t  /**\n\t   * Calls the call_abi(string)string ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n\t   */\n\t  public callAbi(args: MethodArgs<'call_abi(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(StateAppCallFactory.callAbi(args, params))\n", "  }\n\t  /**\n\t   * Calls the call_abi_txn(pay,string)string ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n\t   */\n\t  public callAbiTxn(args: MethodArgs<'call_abi_txn(pay,string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(StateAppCallFactory.callAbiTxn(args, params))\n", "  }\n\t  /**\n\t   * Calls the call_with_references(asset,account,application)uint64 ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n\t   */\n\t  public callWithReferences(args: MethodArgs<'call_with_references(asset,account,application)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(StateAppCallFactory.callWithReferences(args, params))\n", "  }\n\t  /**\n\t   * Calls the set_global(uint64,uint64,string,byte[4])void ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n\t   */\n\t  public setGlobal(args: MethodArgs<'set_global(uint64,uint64,string,byte[4])void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(StateAppCallFactory.setGlobal(args, params))\n", "  }\n\t  /**\n\t   * Calls the set_local(uint64,uint64,string,byte[4])void ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n\t   */\n\t  public setLocal(args: MethodArgs<'set_local(uint64,uint64,string,byte[4])void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(StateAppCallFactory.setLocal(args, params))\n", "  }\n\t  /**\n\t   * Calls the set_box(byte[4],string)void ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n\t   */\n\t  public setBox(args: MethodArgs<'set_box(byte[4],string)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(StateAppCallFactory.setBox(args, params))\n", "  }\n\t  /**\n\t   * Calls the error()void ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n\t   */\n\t  public error(args: MethodArgs<'error()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(StateAppCallFactory.error(args, params))\n", "  }\n\t  /**\n\t   * Calls the default_value(string)string ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n\t   */\n\t  public defaultValue(args: MethodArgs<'default_value(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(StateAppCallFactory.defaultValue(args, params))\n", "  }\n\t  /**\n\t   * Calls the default_value_int(uint64)uint64 ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n\t   */\n\t  public defaultValueInt(args: MethodArgs<'default_value_int(uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(StateAppCallFactory.defaultValueInt(args, params))\n", "  }\n\t  /**\n\t   * Calls the default_value_from_abi(string)string ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n\t   */\n\t  public defaultValueFromAbi(args: MethodArgs<'default_value_from_abi(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(StateAppCallFactory.defaultValueFromAbi(args, params))\n", "  }\n\t  /**\n\t   * Calls the default_value_from_global_state(uint64)uint64 ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n\t   */\n\t  public defaultValueFromGlobalState(args: MethodArgs<'default_value_from_global_state(uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(StateAppCallFactory.defaultValueFromGlobalState(args, params))\n", "  }\n\t  /**\n\t   * Calls the default_value_from_local_state(string)string ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The result of the call\n\t   */\n\t  public defaultValueFromLocalState(args: MethodArgs<'default_value_from_local_state(string)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {\n\t    return this.call(StateAppCallFactory.defaultValueFromLocalState(args, params))\n", "  }\n\t  /**\n\t   * Extracts a binary state value out of an AppState dictionary\n\t   *\n\t   * @param state The state dictionary containing the state value\n\t   * @param key The key of the state value\n\t   * @returns A BinaryState instance containing the state value, or undefined if the key was not found\n\t   */\n\t  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {\n\t    const value = state[key]\n", "    if (!value) return undefined\n\t    if (!('valueRaw' in value))\n\t      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)\n\t    return {\n\t      asString(): string {\n\t        return value.value\n\t      },\n\t      asByteArray(): Uint8Array {\n\t        return value.valueRaw\n\t      }\n", "    }\n\t  }\n\t  /**\n\t   * Extracts a integer state value out of an AppState dictionary\n\t   *\n\t   * @param state The state dictionary containing the state value\n\t   * @param key The key of the state value\n\t   * @returns An IntegerState instance containing the state value, or undefined if the key was not found\n\t   */\n\t  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {\n", "    const value = state[key]\n\t    if (!value) return undefined\n\t    if ('valueRaw' in value)\n\t      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)\n\t    return {\n\t      asBigInt() {\n\t        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)\n\t      },\n\t      asNumber(): number {\n\t        return typeof value.value === 'bigint' ? Number(value.value) : value.value\n", "      },\n\t    }\n\t  }\n\t  /**\n\t   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value\n\t   */\n\t  public async getGlobalState(): Promise<StateApp['state']['global']> {\n\t    const state = await this.appClient.getGlobalState()\n\t    return {\n\t      get bytes1() {\n", "        return StateAppClient.getBinaryState(state, 'bytes1')\n\t      },\n\t      get bytes2() {\n\t        return StateAppClient.getBinaryState(state, 'bytes2')\n\t      },\n\t      get int1() {\n\t        return StateAppClient.getIntegerState(state, 'int1')\n\t      },\n\t      get int2() {\n\t        return StateAppClient.getIntegerState(state, 'int2')\n", "      },\n\t      get value() {\n\t        return StateAppClient.getIntegerState(state, 'value')\n\t      },\n\t    }\n\t  }\n\t  /**\n\t   * Returns the smart contract's local state wrapped in a strongly typed accessor with options to format the stored value\n\t   *\n\t   * @param account The address of the account for which to read local state from\n", "   */\n\t  public async getLocalState(account: string | SendTransactionFrom): Promise<StateApp['state']['local']> {\n\t    const state = await this.appClient.getLocalState(account)\n\t    return {\n\t      get local_bytes1() {\n\t        return StateAppClient.getBinaryState(state, 'local_bytes1')\n\t      },\n\t      get local_bytes2() {\n\t        return StateAppClient.getBinaryState(state, 'local_bytes2')\n\t      },\n", "      get local_int1() {\n\t        return StateAppClient.getIntegerState(state, 'local_int1')\n\t      },\n\t      get local_int2() {\n\t        return StateAppClient.getIntegerState(state, 'local_int2')\n\t      },\n\t    }\n\t  }\n\t  public compose(): StateAppComposer {\n\t    const client = this\n", "    const atc = new AtomicTransactionComposer()\n\t    let promiseChain:Promise<unknown> = Promise.resolve()\n\t    const resultMappers: Array<undefined | ((x: any) => any)> = []\n\t    return {\n\t      callAbi(args: MethodArgs<'call_abi(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.callAbi(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      callAbiTxn(args: MethodArgs<'call_abi_txn(pay,string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n", "        promiseChain = promiseChain.then(() => client.callAbiTxn(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      callWithReferences(args: MethodArgs<'call_with_references(asset,account,application)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.callWithReferences(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      setGlobal(args: MethodArgs<'set_global(uint64,uint64,string,byte[4])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n", "        promiseChain = promiseChain.then(() => client.setGlobal(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      setLocal(args: MethodArgs<'set_local(uint64,uint64,string,byte[4])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.setLocal(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      setBox(args: MethodArgs<'set_box(byte[4],string)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n", "        promiseChain = promiseChain.then(() => client.setBox(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      error(args: MethodArgs<'error()void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.error(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      defaultValue(args: MethodArgs<'default_value(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n", "        promiseChain = promiseChain.then(() => client.defaultValue(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      defaultValueInt(args: MethodArgs<'default_value_int(uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.defaultValueInt(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      defaultValueFromAbi(args: MethodArgs<'default_value_from_abi(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n", "        promiseChain = promiseChain.then(() => client.defaultValueFromAbi(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      defaultValueFromGlobalState(args: MethodArgs<'default_value_from_global_state(uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.defaultValueFromGlobalState(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      defaultValueFromLocalState(args: MethodArgs<'default_value_from_local_state(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {\n", "        promiseChain = promiseChain.then(() => client.defaultValueFromLocalState(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      get update() {\n\t        const $this = this\n\t        return {\n\t          bare(args?: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs) {\n\t            promiseChain = promiseChain.then(() => client.update.bare({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n\t            resultMappers.push(undefined)\n", "            return $this\n\t          },\n\t          updateAbi(args: MethodArgs<'update_abi(string)string'>, params?: AppClientCallCoreParams & AppClientCompilationParams) {\n\t            promiseChain = promiseChain.then(() => client.update.updateAbi(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t            resultMappers.push(undefined)\n\t            return $this\n\t          },\n\t        }\n\t      },\n\t      get delete() {\n", "        const $this = this\n\t        return {\n\t          bare(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {\n\t            promiseChain = promiseChain.then(() => client.delete.bare({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n\t            resultMappers.push(undefined)\n\t            return $this\n\t          },\n\t          deleteAbi(args: MethodArgs<'delete_abi(string)string'>, params?: AppClientCallCoreParams) {\n\t            promiseChain = promiseChain.then(() => client.delete.deleteAbi(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t            resultMappers.push(undefined)\n", "            return $this\n\t          },\n\t        }\n\t      },\n\t      get optIn() {\n\t        const $this = this\n\t        return {\n\t          optIn(args: MethodArgs<'opt_in()void'>, params?: AppClientCallCoreParams) {\n\t            promiseChain = promiseChain.then(() => client.optIn.optIn(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))\n\t            resultMappers.push(undefined)\n", "            return $this\n\t          },\n\t        }\n\t      },\n\t      clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {\n\t        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))\n\t        resultMappers.push(undefined)\n\t        return this\n\t      },\n\t      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {\n", "        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))\n\t        return this\n\t      },\n\t      async atc() {\n\t        await promiseChain\n\t        return atc\n\t      },\n\t      async execute() {\n\t        await promiseChain\n\t        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)\n", "        return {\n\t          ...result,\n\t          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)\n\t        }\n\t      }\n\t    } as unknown as StateAppComposer\n\t  }\n\t}\n\texport type StateAppComposer<TReturns extends [...any[]] = []> = {\n\t  /**\n", "   * Calls the call_abi(string)string ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  callAbi(args: MethodArgs<'call_abi(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'call_abi(string)string'>]>\n\t  /**\n\t   * Calls the call_abi_txn(pay,string)string ABI method.\n\t   *\n", "   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  callAbiTxn(args: MethodArgs<'call_abi_txn(pay,string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'call_abi_txn(pay,string)string'>]>\n\t  /**\n\t   * Calls the call_with_references(asset,account,application)uint64 ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n", "   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  callWithReferences(args: MethodArgs<'call_with_references(asset,account,application)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'call_with_references(asset,account,application)uint64'>]>\n\t  /**\n\t   * Calls the set_global(uint64,uint64,string,byte[4])void ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n", "  setGlobal(args: MethodArgs<'set_global(uint64,uint64,string,byte[4])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'set_global(uint64,uint64,string,byte[4])void'>]>\n\t  /**\n\t   * Calls the set_local(uint64,uint64,string,byte[4])void ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  setLocal(args: MethodArgs<'set_local(uint64,uint64,string,byte[4])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'set_local(uint64,uint64,string,byte[4])void'>]>\n\t  /**\n", "   * Calls the set_box(byte[4],string)void ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  setBox(args: MethodArgs<'set_box(byte[4],string)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'set_box(byte[4],string)void'>]>\n\t  /**\n\t   * Calls the error()void ABI method.\n\t   *\n", "   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  error(args: MethodArgs<'error()void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'error()void'>]>\n\t  /**\n\t   * Calls the default_value(string)string ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n", "   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  defaultValue(args: MethodArgs<'default_value(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'default_value(string)string'>]>\n\t  /**\n\t   * Calls the default_value_int(uint64)uint64 ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n", "  defaultValueInt(args: MethodArgs<'default_value_int(uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'default_value_int(uint64)uint64'>]>\n\t  /**\n\t   * Calls the default_value_from_abi(string)string ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  defaultValueFromAbi(args: MethodArgs<'default_value_from_abi(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'default_value_from_abi(string)string'>]>\n\t  /**\n", "   * Calls the default_value_from_global_state(uint64)uint64 ABI method.\n\t   *\n\t   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  defaultValueFromGlobalState(args: MethodArgs<'default_value_from_global_state(uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'default_value_from_global_state(uint64)uint64'>]>\n\t  /**\n\t   * Calls the default_value_from_local_state(string)string ABI method.\n\t   *\n", "   * @param args The arguments for the contract call\n\t   * @param params Any additional parameters for the call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  defaultValueFromLocalState(args: MethodArgs<'default_value_from_local_state(string)string'>, params?: AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, MethodReturn<'default_value_from_local_state(string)string'>]>\n\t  /**\n\t   * Gets available update methods\n\t   */\n\t  readonly update: {\n\t    /**\n", "     * Updates an existing instance of the StateApp smart contract using a bare call.\n\t     *\n\t     * @param args The arguments for the bare call\n\t     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t     */\n\t    bare(args?: BareCallArgs & AppClientCallCoreParams & AppClientCompilationParams & CoreAppCallArgs): StateAppComposer<[...TReturns, undefined]>\n\t    /**\n\t     * Updates an existing instance of the StateApp smart contract using the update_abi(string)string ABI method.\n\t     *\n\t     * @param args The arguments for the smart contract call\n", "     * @param params Any additional parameters for the call\n\t     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t     */\n\t    updateAbi(args: MethodArgs<'update_abi(string)string'>, params?: AppClientCallCoreParams & AppClientCompilationParams): StateAppComposer<[...TReturns, MethodReturn<'update_abi(string)string'>]>\n\t  }\n\t  /**\n\t   * Gets available delete methods\n\t   */\n\t  readonly delete: {\n\t    /**\n", "     * Deletes an existing instance of the StateApp smart contract using a bare call.\n\t     *\n\t     * @param args The arguments for the bare call\n\t     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t     */\n\t    bare(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, undefined]>\n\t    /**\n\t     * Deletes an existing instance of the StateApp smart contract using the delete_abi(string)string ABI method.\n\t     *\n\t     * @param args The arguments for the smart contract call\n", "     * @param params Any additional parameters for the call\n\t     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t     */\n\t    deleteAbi(args: MethodArgs<'delete_abi(string)string'>, params?: AppClientCallCoreParams): StateAppComposer<[...TReturns, MethodReturn<'delete_abi(string)string'>]>\n\t  }\n\t  /**\n\t   * Gets available optIn methods\n\t   */\n\t  readonly optIn: {\n\t    /**\n", "     * Opts the user into an existing instance of the StateApp smart contract using the opt_in()void ABI method.\n\t     *\n\t     * @param args The arguments for the smart contract call\n\t     * @param params Any additional parameters for the call\n\t     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t     */\n\t    optIn(args: MethodArgs<'opt_in()void'>, params?: AppClientCallCoreParams): StateAppComposer<[...TReturns, MethodReturn<'opt_in()void'>]>\n\t  }\n\t  /**\n\t   * Makes a clear_state call to an existing instance of the StateApp smart contract.\n", "   *\n\t   * @param args The arguments for the bare call\n\t   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions\n\t   */\n\t  clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): StateAppComposer<[...TReturns, undefined]>\n\t  /**\n\t   * Adds a transaction to the composer\n\t   *\n\t   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)\n\t   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.\n", "   */\n\t  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): StateAppComposer<TReturns>\n\t  /**\n\t   * Returns the underlying AtomicTransactionComposer instance\n\t   */\n\t  atc(): Promise<AtomicTransactionComposer>\n\t  /**\n\t   * Executes the transaction group and returns an array of results\n\t   */\n\t  execute(): Promise<StateAppComposerResults<TReturns>>\n", "}\n\texport type StateAppComposerResults<TReturns extends [...any[]]> = {\n\t  returns: TReturns\n\t  groupId: string\n\t  txIds: string[]\n\t  transactions: Transaction[]\n\t}\n"]}
{"filename": "src/cli.ts", "chunked_list": ["import { Command } from 'commander'\n\timport { load } from './schema/load'\n\timport * as path from 'path'\n\timport { generate } from './client/generate'\n\timport { writeDocumentPartsToStream } from './output/writer'\n\timport fs from 'fs'\n\timport { colorConsole } from './util/color-console'\n\texport function cli(workingDirectory: string, args: string[]) {\n\t  const program = new Command()\n\t  program\n", "    .command('generate')\n\t    .description('Generates a TypeScript client for the given application.json file')\n\t    .requiredOption('-a --application <path>', 'Specifies the application.json file')\n\t    .requiredOption('-o --output <path>', 'Specifies the output file path')\n\t    .action(({ application, output }: { application: string; output: string }): void => {\n\t      const resolvedAppJsonPath = path.resolve(workingDirectory, application)\n\t      const resolvedOutPath = path.resolve(workingDirectory, output)\n\t      const resolvedOutDir = path.dirname(resolvedOutPath)\n\t      colorConsole.info`Reading application.json file from path ${resolvedAppJsonPath}`\n\t      const spec = load(resolvedAppJsonPath)\n", "      colorConsole.info`Generating TS client for ${spec.contract.name}`\n\t      const parts = generate(spec)\n\t      if (!fs.existsSync(resolvedOutDir)) {\n\t        colorConsole.warn`Output directory ${resolvedOutDir} does not exist and will be created.`\n\t        fs.mkdirSync(resolvedOutDir, { recursive: true })\n\t      }\n\t      colorConsole.info`Writing TS client to ${resolvedOutPath}`\n\t      const file = fs.createWriteStream(resolvedOutPath, {\n\t        flags: 'w',\n\t      })\n", "      writeDocumentPartsToStream(parts, file)\n\t      colorConsole.success`Operation completed successfully`\n\t    })\n\t    .configureOutput({\n\t      writeErr(str: string) {\n\t        colorConsole.error`${str}`\n\t      },\n\t    })\n\t  try {\n\t    program.parse(args)\n", "  } catch (err) {\n\t    if (err instanceof Error) {\n\t      colorConsole.error`Unhandled error: \\n\\n${err.stack}`\n\t    } else {\n\t      colorConsole.error`Unhandled error: \\n\\n${err}`\n\t    }\n\t    process.exit(-1)\n\t  }\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { cli } from './cli'\n\tcli(process.cwd(), process.argv)\n"]}
{"filename": "src/tests/approval-tests.spec.ts", "chunked_list": ["import fs from 'fs'\n\timport path from 'path'\n\timport { generate } from '../client/generate'\n\timport { writeDocumentPartsToString } from '../output/writer'\n\timport { load } from '../schema/load'\n\tconst writeActual = process.env.TEST_ENV !== 'ci'\n\tconst testContracts = ['helloworld', 'lifecycle', 'state', 'voting'] as const\n\tdescribe('When generating a ts client for a the contract', () => {\n\t  test.each(testContracts)('%s approval', (contractName) => {\n\t    const dir = path.join(__dirname, `../../examples/${contractName}/`)\n", "    const spec = load(path.join(dir, `application.json`))\n\t    const result = writeDocumentPartsToString(generate(spec))\n\t    if (writeActual) fs.writeFileSync(path.join(dir, `client.generated.ts`), result)\n\t    const approvedClient = fs.readFileSync(path.join(dir, `client.ts`), 'utf-8')\n\t    expect(result).toBe(approvedClient)\n\t  })\n\t})\n"]}
{"filename": "src/util/color-console.ts", "chunked_list": ["import chalk from 'chalk'\n\ttype ColorFn = (text: string) => string\n\tconst createColorFormatter =\n\t  (textColor: ColorFn, argColor: ColorFn, consoleFn: 'log' | 'error' | 'info' | 'warn') =>\n\t  (textParts: TemplateStringsArray, ...args: unknown[]): void => {\n\t    // eslint-disable-next-line no-console\n\t    console[consoleFn](\n\t      textParts\n\t        .flatMap((t, i) => (args.length > i ? [textColor(t), argColor(`${args[i]}`)] : textColor(t)))\n\t        .reduce((acc, cur) => acc + cur, ''),\n", "    )\n\t  }\n\texport const colorConsole = {\n\t  info: createColorFormatter(chalk.cyan, chalk.blue, 'info'),\n\t  warn: createColorFormatter(chalk.yellow, chalk.yellow.bold, 'warn'),\n\t  success: createColorFormatter(chalk.green, chalk.green.bold, 'info'),\n\t  error: createColorFormatter(chalk.red, chalk.red.bold, 'error'),\n\t}\n"]}
{"filename": "src/util/boom.ts", "chunked_list": ["export const boom = (reason: string): never => {\n\t  throw new Error(reason)\n\t}\n"]}
{"filename": "src/util/sanitization.ts", "chunked_list": ["import { camelCase, pascalCase } from 'change-case'\n\tconst replaceInvalidWithUnderscore = (value: string) => value.replace(/[^a-z0-9_$]+/gi, '_')\n\texport const makeSafeTypeIdentifier = (value: string) => pascalCase(replaceInvalidWithUnderscore(value))\n\texport const makeSafeMethodIdentifier = (value: string) => camelCase(replaceInvalidWithUnderscore(value))\n\texport const isSafeVariableIdentifier = (value: string) => /^[a-z$_][a-z0-9_$]*$/i.test(value)\n\texport const makeSafeVariableIdentifier = (value: string) =>\n\t  isSafeVariableIdentifier(value) ? value : camelCase(replaceInvalidWithUnderscore(value)) || 'arg'\n\tconst escapeQuotes = (value: string) => value.replace(/['\"]/g, (val) => `\\\\${val}`)\n\texport const makeSafePropertyIdentifier = (value: string) => (isSafeVariableIdentifier(value) ? value : `'${escapeQuotes(value)}'`)\n"]}
{"filename": "src/util/not-falsy.ts", "chunked_list": ["export const notFalsy = <T>(value: T): value is Exclude<T, 0 | false | undefined | null | ''> => Boolean(value)\n"]}
{"filename": "src/output/writer.ts", "chunked_list": ["import type fs from 'fs'\n\texport const IncIndent = Symbol('Increase Indent')\n\texport const DecIndent = Symbol('Decrease Indent')\n\texport const DecIndentAndCloseBlock = Symbol('Decrease Indent and write a closing brace')\n\texport const NewLineMode = Symbol('New Line Mode')\n\texport const RestoreLineMode = Symbol('Restore Line Mode')\n\texport const PropertyDelimiter = Symbol('Property Delimiter')\n\texport const InlineMode = Symbol('Inline Mode')\n\texport const NewLine = Symbol('New Line')\n\texport type Part =\n", "  | string\n\t  | typeof IncIndent\n\t  | typeof DecIndent\n\t  | typeof NewLineMode\n\t  | typeof DecIndentAndCloseBlock\n\t  | typeof InlineMode\n\t  | typeof NewLine\n\t  | typeof RestoreLineMode\n\t  | typeof PropertyDelimiter\n\texport type DocumentParts = Generator<Part, void>\n", "export type WriteOptions = {\n\t  indent?: string\n\t  disableEslint?: boolean\n\t  header?: string\n\t}\n\tinterface StringWriter {\n\t  write(value: string): void\n\t  get last(): string\n\t}\n\texport function writeDocumentPartsToStream(document: DocumentParts, stream: fs.WriteStream, options: WriteOptions = {}) {\n", "  const writer = {\n\t    _last: '',\n\t    write(val: string) {\n\t      this._last = val\n\t      stream.write(val)\n\t    },\n\t    get last() {\n\t      return this._last\n\t    },\n\t  }\n", "  writeDocumentPartsTo(document, options, writer)\n\t}\n\texport function writeDocumentPartsToString(document: DocumentParts, options: WriteOptions = {}) {\n\t  const writer = {\n\t    result: [] as string[],\n\t    _last: '',\n\t    write(val: string) {\n\t      this._last = val\n\t      this.result.push(val)\n\t    },\n", "    get last() {\n\t      return this._last\n\t    },\n\t    toString() {\n\t      return this.result.join('')\n\t    },\n\t  }\n\t  writeDocumentPartsTo(document, options, writer)\n\t  return writer.toString()\n\t}\n", "export function* inline(...parts: Array<Part | DocumentParts>) {\n\t  yield InlineMode\n\t  for (const part of parts) {\n\t    if (typeof part === 'string' || typeof part === 'symbol') yield part\n\t    else yield* part\n\t  }\n\t  yield RestoreLineMode\n\t}\n\texport function* indent(...parts: Array<Part | DocumentParts>) {\n\t  yield IncIndent\n", "  for (const part of parts) {\n\t    if (typeof part === 'string' || typeof part === 'symbol') yield part\n\t    else yield* part\n\t  }\n\t  yield DecIndent\n\t}\n\texport function* jsDoc(docs: string | { description: string; abiDescription?: string; params?: Record<string, string>; returns?: string }) {\n\t  yield `/**`\n\t  if (typeof docs === 'string') {\n\t    yield ` * ${docs}`\n", "  } else {\n\t    yield ` * ${docs.description}`\n\t    if (docs.abiDescription) {\n\t      yield ' *'\n\t      yield ` * ${docs.abiDescription}`\n\t    }\n\t    if (docs.params || docs.returns) {\n\t      yield ' *'\n\t    }\n\t    for (const [paramName, paramDesc] of Object.entries(docs.params ?? {})) {\n", "      yield ` * @param ${paramName} ${paramDesc}`\n\t    }\n\t    if (docs.returns) yield ` * @returns ${docs.returns}`\n\t  }\n\t  yield ' */'\n\t}\n\tfunction writeDocumentPartsTo(document: DocumentParts, { indent = '  ', ...options }: WriteOptions, writer: StringWriter): void {\n\t  if (options.header) writer.write(`${options.header}\\n`)\n\t  if (options.disableEslint) writer.write('/* eslint-disable */\\n')\n\t  const lineModes = [NewLineMode]\n", "  const currentLineMode = () => lineModes.at(-1) ?? NewLineMode\n\t  let curIndent = ''\n\t  for (const part of document) {\n\t    switch (part) {\n\t      case IncIndent:\n\t        curIndent += indent\n\t        break\n\t      case DecIndent:\n\t        curIndent = curIndent.slice(0, -indent.length)\n\t        break\n", "      case DecIndentAndCloseBlock:\n\t        curIndent = curIndent.slice(0, -indent.length)\n\t        writer.write(`${curIndent}}\\n`)\n\t        break\n\t      case NewLineMode:\n\t        lineModes.push(NewLineMode)\n\t        if (writer.last.slice(-1)[0] !== '\\n') {\n\t          writer.write('\\n')\n\t        }\n\t        break\n", "      case InlineMode:\n\t        lineModes.push(InlineMode)\n\t        break\n\t      case RestoreLineMode:\n\t        lineModes.pop()\n\t        if (currentLineMode() === NewLineMode && writer.last.slice(-1)[0] !== '\\n') {\n\t          writer.write('\\n')\n\t        }\n\t        break\n\t      case PropertyDelimiter:\n", "        if (currentLineMode() === NewLineMode) {\n\t          writer.write('\\n')\n\t        } else {\n\t          writer.write(', ')\n\t        }\n\t        break\n\t      case NewLine:\n\t        writer.write('\\n')\n\t        break\n\t      default:\n", "        if (writer.last.slice(-1)[0] === '\\n') writer.write(curIndent)\n\t        writer.write(part)\n\t        if (currentLineMode() === NewLineMode) writer.write('\\n')\n\t        break\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/client/call-factory.ts", "chunked_list": ["import { ContractMethod } from '../schema/application'\n\timport { DecIndent, DecIndentAndCloseBlock, DocumentParts, IncIndent, jsDoc, NewLine } from '../output/writer'\n\timport { isSafeVariableIdentifier, makeSafeMethodIdentifier, makeSafePropertyIdentifier } from '../util/sanitization'\n\timport * as algokit from '@algorandfoundation/algokit-utils'\n\timport { GeneratorContext } from './generator-context'\n\timport { BARE_CALL, MethodList } from './helpers/get-call-config-summary'\n\timport { getCreateOnCompleteOptions } from './deploy-types'\n\texport function* callFactory(ctx: GeneratorContext): DocumentParts {\n\t  yield* jsDoc('Exposes methods for constructing all available smart contract calls')\n\t  yield `export abstract class ${ctx.name}CallFactory {`\n", "  yield IncIndent\n\t  yield* opMethods(ctx)\n\t  for (const method of ctx.app.contract.methods) {\n\t    yield* callFactoryMethod(ctx, method)\n\t  }\n\t  yield DecIndent\n\t  yield '}'\n\t}\n\tfunction* opMethods(ctx: GeneratorContext): DocumentParts {\n\t  const { app, callConfig } = ctx\n", "  yield* operationMethod(\n\t    ctx,\n\t    `Constructs a create call for the ${app.contract.name} smart contract`,\n\t    callConfig.createMethods,\n\t    'create',\n\t    true,\n\t  )\n\t  yield* operationMethod(\n\t    ctx,\n\t    `Constructs an update call for the ${app.contract.name} smart contract`,\n", "    callConfig.updateMethods,\n\t    'update',\n\t    true,\n\t  )\n\t  yield* operationMethod(ctx, `Constructs a delete call for the ${app.contract.name} smart contract`, callConfig.deleteMethods, 'delete')\n\t  yield* operationMethod(ctx, `Constructs an opt in call for the ${app.contract.name} smart contract`, callConfig.optInMethods, 'optIn')\n\t  yield* operationMethod(\n\t    ctx,\n\t    `Constructs a close out call for the ${app.contract.name} smart contract`,\n\t    callConfig.closeOutMethods,\n", "    'closeOut',\n\t  )\n\t}\n\tfunction* operationMethod(\n\t  { app, methodSignatureToUniqueName }: GeneratorContext,\n\t  description: string,\n\t  methods: MethodList,\n\t  verb: 'create' | 'update' | 'optIn' | 'closeOut' | 'delete',\n\t  includeCompilation?: boolean,\n\t): DocumentParts {\n", "  if (methods.length) {\n\t    yield* jsDoc(`Gets available ${verb} call factories`)\n\t    yield `static get ${verb}() {`\n\t    yield IncIndent\n\t    yield `return {`\n\t    yield IncIndent\n\t    for (const methodSig of methods) {\n\t      const onComplete = verb === 'create' ? getCreateOnCompleteOptions(methodSig, app) : undefined\n\t      if (methodSig === BARE_CALL) {\n\t        yield* jsDoc({\n", "          description: `${description} using a bare call`,\n\t          params: {\n\t            params: `Any parameters for the call`,\n\t          },\n\t          returns: `A TypedCallParams object for the call`,\n\t        })\n\t        yield* factoryMethod({\n\t          isNested: true,\n\t          name: 'bare',\n\t          paramTypes: `BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs${\n", "            includeCompilation ? ' & AppClientCompilationParams' : ''\n\t          }${onComplete?.type ? ` & ${onComplete.type}` : ''}${onComplete?.isOptional !== false ? ' = {}' : ''}`,\n\t        })\n\t      } else {\n\t        const method = app.contract.methods.find((m) => algokit.getABIMethodSignature(m) === methodSig)!\n\t        const uniqueName = methodSignatureToUniqueName[methodSig]\n\t        yield* jsDoc({\n\t          description: `${description} using the ${methodSig} ABI method`,\n\t          params: {\n\t            args: `Any args for the contract call`,\n", "            params: `Any additional parameters for the call`,\n\t          },\n\t          returns: `A TypedCallParams object for the call`,\n\t        })\n\t        yield* factoryMethod({\n\t          isNested: true,\n\t          name: makeSafeMethodIdentifier(uniqueName),\n\t          signature: methodSig,\n\t          args: method.args,\n\t          paramTypes: `AppClientCallCoreParams & CoreAppCallArgs${includeCompilation ? ' & AppClientCompilationParams' : ''}${\n", "            onComplete?.type ? ` & ${onComplete.type}` : ''\n\t          }${onComplete?.isOptional !== false ? ' = {}' : ''}`,\n\t        })\n\t      }\n\t    }\n\t    yield DecIndentAndCloseBlock\n\t    yield DecIndentAndCloseBlock\n\t    yield NewLine\n\t  }\n\t}\n", "function* callFactoryMethod({ methodSignatureToUniqueName, callConfig }: GeneratorContext, method: ContractMethod) {\n\t  const methodSignature = algokit.getABIMethodSignature(method)\n\t  if (!callConfig.callMethods.includes(methodSignature)) return\n\t  yield* jsDoc({\n\t    description: `Constructs a no op call for the ${methodSignature} ABI method`,\n\t    abiDescription: method.desc,\n\t    params: {\n\t      args: `Any args for the contract call`,\n\t      params: `Any additional parameters for the call`,\n\t    },\n", "    returns: `A TypedCallParams object for the call`,\n\t  })\n\t  yield* factoryMethod({\n\t    isNested: false,\n\t    name: makeSafeMethodIdentifier(methodSignatureToUniqueName[methodSignature]),\n\t    signature: methodSignature,\n\t    args: method.args,\n\t    paramTypes: 'AppClientCallCoreParams & CoreAppCallArgs',\n\t  })\n\t}\n", "function* factoryMethod({\n\t  isNested,\n\t  name,\n\t  signature,\n\t  args,\n\t  paramTypes,\n\t}:\n\t  | {\n\t      isNested: boolean\n\t      name?: string\n", "      signature?: undefined\n\t      args?: undefined\n\t      paramTypes: string\n\t    }\n\t  | {\n\t      isNested: boolean\n\t      name?: string\n\t      signature: string\n\t      args: Array<{ name: string }>\n\t      paramTypes: string\n", "    }) {\n\t  yield `${isNested ? '' : 'static '}${name}(${signature === undefined ? '' : `args: MethodArgs<'${signature}'>, `}params: ${paramTypes}) {`\n\t  yield IncIndent\n\t  yield `return {`\n\t  yield IncIndent\n\t  if (signature) {\n\t    yield `method: '${signature}' as const,`\n\t    yield `methodArgs: Array.isArray(args) ? args : [${args\n\t      .map((a) => (isSafeVariableIdentifier(a.name) ? `args.${a.name}` : `args['${makeSafePropertyIdentifier(a.name)}']`))\n\t      .join(', ')}],`\n", "  } else {\n\t    yield `method: undefined,`\n\t    yield `methodArgs: undefined,`\n\t  }\n\t  yield '...params,'\n\t  yield DecIndent\n\t  yield '}'\n\t  yield DecIndent\n\t  yield `}${isNested ? ',' : ''}`\n\t}\n"]}
{"filename": "src/client/imports.ts", "chunked_list": ["import { DocumentParts } from '../output/writer'\n\texport function* imports(): DocumentParts {\n\t  yield `import * as algokit from '@algorandfoundation/algokit-utils'\n\timport type {\n\t  AppCallTransactionResult,\n\t  AppCallTransactionResultOfType,\n\t  CoreAppCallArgs,\n\t  RawAppCallArgs,\n\t  AppState,\n\t  TealTemplateParams,\n", "  ABIAppCallArg,\n\t} from '@algorandfoundation/algokit-utils/types/app'\n\timport type {\n\t  AppClientCallCoreParams,\n\t  AppClientCompilationParams,\n\t  AppClientDeployCoreParams,\n\t  AppDetails,\n\t  ApplicationClient,\n\t} from '@algorandfoundation/algokit-utils/types/app-client'\n\timport type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'\n", "import type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'\n\timport type { TransactionWithSigner } from 'algosdk'\n\timport { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer } from 'algosdk'`\n\t}\n"]}
{"filename": "src/client/call-composer.ts", "chunked_list": ["import { DecIndent, DecIndentAndCloseBlock, DocumentParts, IncIndent } from '../output/writer'\n\timport { GeneratorContext } from './generator-context'\n\timport * as algokit from '@algorandfoundation/algokit-utils'\n\timport { makeSafeMethodIdentifier } from '../util/sanitization'\n\timport { BARE_CALL, MethodList } from './helpers/get-call-config-summary'\n\timport { getCreateOnCompleteOptions } from './deploy-types'\n\texport function* composeMethod(ctx: GeneratorContext): DocumentParts {\n\t  const { name, callConfig } = ctx\n\t  yield `public compose(): ${name}Composer {`\n\t  yield IncIndent\n", "  yield `const client = this`\n\t  yield `const atc = new AtomicTransactionComposer()`\n\t  yield `let promiseChain:Promise<unknown> = Promise.resolve()`\n\t  yield `const resultMappers: Array<undefined | ((x: any) => any)> = []`\n\t  yield `return {`\n\t  yield IncIndent\n\t  yield* callComposerNoops(ctx)\n\t  yield* callComposerOperationMethods(ctx, callConfig.updateMethods, 'update', true)\n\t  yield* callComposerOperationMethods(ctx, callConfig.deleteMethods, 'delete')\n\t  yield* callComposerOperationMethods(ctx, callConfig.optInMethods, 'optIn')\n", "  yield* callComposerOperationMethods(ctx, callConfig.closeOutMethods, 'closeOut')\n\t  yield* callComposerClearState()\n\t  yield `addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {`\n\t  yield IncIndent\n\t  yield 'promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ??' +\n\t    ' client.sender)))'\n\t  yield 'return this'\n\t  yield DecIndent\n\t  yield '},'\n\t  yield `async atc() {`\n", "  yield IncIndent\n\t  yield 'await promiseChain'\n\t  yield 'return atc'\n\t  yield DecIndent\n\t  yield '},'\n\t  yield `async execute() {`\n\t  yield IncIndent\n\t  yield `await promiseChain`\n\t  yield `const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)`\n\t  yield `return {`\n", "  yield IncIndent\n\t  yield `...result,`\n\t  yield `returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)`\n\t  yield DecIndentAndCloseBlock\n\t  yield DecIndentAndCloseBlock\n\t  yield DecIndent\n\t  yield `} as unknown as ${name}Composer`\n\t  yield DecIndentAndCloseBlock\n\t}\n\tfunction* callComposerNoops({ app, callConfig, methodSignatureToUniqueName }: GeneratorContext): DocumentParts {\n", "  for (const method of app.contract.methods) {\n\t    const methodSignature = algokit.getABIMethodSignature(method)\n\t    const methodName = makeSafeMethodIdentifier(methodSignatureToUniqueName[methodSignature])\n\t    // Skip methods which don't support a no_op call config\n\t    if (!callConfig.callMethods.includes(methodSignature)) continue\n\t    yield `${methodName}(args: MethodArgs<'${methodSignature}'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {`\n\t    yield IncIndent\n\t    yield `promiseChain = promiseChain.then(() => client.${methodName}(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))`\n\t    const outputTypeName = app.hints?.[methodSignature]?.structs?.output?.name\n\t    yield `resultMappers.push(${outputTypeName ?? 'undefined'})`\n", "    yield `return this`\n\t    yield DecIndent\n\t    yield '},'\n\t  }\n\t}\n\tfunction* callComposerClearState(): DocumentParts {\n\t  yield `clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {`\n\t  yield IncIndent\n\t  yield `promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))`\n\t  yield `resultMappers.push(undefined)`\n", "  yield `return this`\n\t  yield DecIndent\n\t  yield '},'\n\t}\n\tfunction* callComposerOperationMethods(\n\t  { app, methodSignatureToUniqueName }: GeneratorContext,\n\t  methods: MethodList,\n\t  verb: 'create' | 'update' | 'optIn' | 'closeOut' | 'delete',\n\t  includeCompilation?: boolean,\n\t): DocumentParts {\n", "  if (methods.length) {\n\t    yield `get ${verb}() {`\n\t    yield IncIndent\n\t    yield `const $this = this`\n\t    yield `return {`\n\t    yield IncIndent\n\t    for (const methodSig of methods) {\n\t      const onComplete = verb === 'create' ? getCreateOnCompleteOptions(methodSig, app) : undefined\n\t      if (methodSig === BARE_CALL) {\n\t        yield `bare(args${onComplete?.isOptional !== false ? '?' : ''}: BareCallArgs & AppClientCallCoreParams ${\n", "          includeCompilation ? '& AppClientCompilationParams ' : ''\n\t        }& CoreAppCallArgs${onComplete?.type ? ` & ${onComplete.type}` : ''}) {`\n\t        yield IncIndent\n\t        yield `promiseChain = promiseChain.then(() => client.${verb}.bare({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))`\n\t        yield `resultMappers.push(undefined)`\n\t        yield `return $this`\n\t        yield DecIndent\n\t        yield '},'\n\t      } else {\n\t        const uniqueName = methodSignatureToUniqueName[methodSig]\n", "        const methodName = makeSafeMethodIdentifier(uniqueName)\n\t        yield `${methodName}(args: MethodArgs<'${methodSig}'>, params${\n\t          onComplete?.isOptional !== false ? '?' : ''\n\t        }: AppClientCallCoreParams${includeCompilation ? ' & AppClientCompilationParams' : ''}${\n\t          onComplete?.type ? ` & ${onComplete.type}` : ''\n\t        }) {`\n\t        yield IncIndent\n\t        yield `promiseChain = promiseChain.then(() => client.${verb}.${methodName}(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))`\n\t        const outputTypeName = app.hints?.[methodSig]?.structs?.output?.name\n\t        yield `resultMappers.push(${outputTypeName ?? 'undefined'})`\n", "        yield `return $this`\n\t        yield DecIndent\n\t        yield '},'\n\t      }\n\t    }\n\t    yield DecIndentAndCloseBlock\n\t    yield DecIndent\n\t    yield '},'\n\t  }\n\t}\n"]}
{"filename": "src/client/utility-types.ts", "chunked_list": ["import { DecIndentAndCloseBlock, DocumentParts, IncIndent, jsDoc } from '../output/writer'\n\texport function* utilityTypes(): DocumentParts {\n\t  yield* jsDoc(`Defines an onCompletionAction of 'no_op'`)\n\t  yield `export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }`\n\t  yield* jsDoc(`Defines an onCompletionAction of 'opt_in'`)\n\t  yield `export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }`\n\t  yield* jsDoc(`Defines an onCompletionAction of 'close_out'`)\n\t  yield `export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }`\n\t  yield* jsDoc(`Defines an onCompletionAction of 'delete_application'`)\n\t  yield `export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }`\n", "  yield* jsDoc(`Defines an onCompletionAction of 'update_application'`)\n\t  yield `export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }`\n\t  yield* jsDoc('A state record containing a single unsigned integer')\n\t  yield `export type IntegerState = {`\n\t  yield IncIndent\n\t  yield* jsDoc('Gets the state value as a BigInt ')\n\t  yield `asBigInt(): bigint`\n\t  yield* jsDoc('Gets the state value as a number.')\n\t  yield `asNumber(): number`\n\t  yield DecIndentAndCloseBlock\n", "  yield* jsDoc('A state record containing binary data')\n\t  yield `export type BinaryState = {`\n\t  yield IncIndent\n\t  yield* jsDoc('Gets the state value as a Uint8Array')\n\t  yield `asByteArray(): Uint8Array`\n\t  yield* jsDoc('Gets the state value as a string')\n\t  yield `asString(): string`\n\t  yield DecIndentAndCloseBlock\n\t}\n\texport const OnCompleteCodeMap = {\n", "  no_op: 'OnCompleteNoOp',\n\t  opt_in: 'OnCompleteOptIn',\n\t  close_out: 'OnCompleteCloseOut',\n\t  delete_application: 'OnCompleteDelApp',\n\t  update_application: 'OnCompleteUpdApp',\n\t}\n"]}
{"filename": "src/client/call-client.ts", "chunked_list": ["import * as algokit from '@algorandfoundation/algokit-utils'\n\timport { DecIndent, DecIndentAndCloseBlock, DocumentParts, IncIndent, indent, inline, jsDoc, NewLine } from '../output/writer'\n\timport { makeSafeMethodIdentifier, makeSafeTypeIdentifier } from '../util/sanitization'\n\timport { BARE_CALL, MethodList } from './helpers/get-call-config-summary'\n\timport { GeneratorContext } from './generator-context'\n\timport { getCreateOnCompleteOptions } from './deploy-types'\n\timport { composeMethod } from './call-composer'\n\texport function* callClient(ctx: GeneratorContext): DocumentParts {\n\t  const { app, name } = ctx\n\t  yield* jsDoc(`A client to make calls to the ${app.contract.name} smart contract`)\n", "  yield `export class ${makeSafeTypeIdentifier(app.contract.name)}Client {`\n\t  yield IncIndent\n\t  yield* jsDoc(`The underlying \\`ApplicationClient\\` for when you want to have more flexibility`)\n\t  yield 'public readonly appClient: ApplicationClient'\n\t  yield NewLine\n\t  yield `private readonly sender: SendTransactionFrom | undefined`\n\t  yield NewLine\n\t  yield* jsDoc({\n\t    description: `Creates a new instance of \\`${makeSafeTypeIdentifier(app.contract.name)}Client\\``,\n\t    params: {\n", "      appDetails: 'appDetails The details to identify the app to deploy',\n\t      algod: 'An algod client instance',\n\t    },\n\t  })\n\t  yield `constructor(appDetails: AppDetails, private algod: Algodv2) {`\n\t  yield IncIndent\n\t  yield `this.sender = appDetails.sender`\n\t  yield 'this.appClient = algokit.getAppClient({'\n\t  yield* indent('...appDetails,', 'app: APP_SPEC')\n\t  yield '}, algod)'\n", "  yield DecIndent\n\t  yield '}'\n\t  yield NewLine\n\t  yield* jsDoc({\n\t    description: 'Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type',\n\t    params: {\n\t      result: 'The AppCallTransactionResult to be mapped',\n\t      returnValueFormatter: 'An optional delegate to format the return value if required',\n\t    },\n\t    returns: 'The smart contract response with an updated return value',\n", "  })\n\t  yield* inline(\n\t    `protected mapReturnValue<TReturn>`,\n\t    `(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): `,\n\t    `AppCallTransactionResultOfType<TReturn> {`,\n\t  )\n\t  yield IncIndent\n\t  yield `if(result.return?.decodeError) {`\n\t  yield* indent(`throw result.return.decodeError`)\n\t  yield `}`\n", "  yield `const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined`\n\t  yield IncIndent\n\t  yield `? returnValueFormatter(result.return.returnValue)`\n\t  yield `: result.return?.returnValue as TReturn | undefined`\n\t  yield `return { ...result, return: returnValue }`\n\t  yield DecIndent\n\t  yield DecIndentAndCloseBlock\n\t  yield NewLine\n\t  yield* jsDoc({\n\t    description: 'Calls the ABI method with the matching signature using an onCompletion code of NO_OP',\n", "    params: {\n\t      typedCallParams: 'An object containing the method signature, args, and any other relevant parameters',\n\t      returnValueFormatter: 'An optional delegate which when provided will be used to map non-undefined return values to the target type',\n\t    },\n\t    returns: 'The result of the smart contract call',\n\t  })\n\t  yield `public async call<TSignature extends keyof ${name}['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {`\n\t  yield IncIndent\n\t  yield `return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)`\n\t  yield DecIndentAndCloseBlock\n", "  yield NewLine\n\t  yield* opMethods(ctx)\n\t  yield* clearState(ctx)\n\t  yield* noopMethods(ctx)\n\t  yield* getStateMethods(ctx)\n\t  yield* composeMethod(ctx)\n\t  yield DecIndentAndCloseBlock\n\t}\n\tfunction* opMethods(ctx: GeneratorContext): DocumentParts {\n\t  const { app, callConfig, name } = ctx\n", "  yield* jsDoc({\n\t    description: `Idempotently deploys the ${app.contract.name} smart contract.`,\n\t    params: {\n\t      params: 'The arguments for the contract calls and any additional parameters for the call',\n\t    },\n\t    returns: 'The deployment result',\n\t  })\n\t  yield `public deploy(params: ${name}DeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {`\n\t  yield IncIndent\n\t  if (callConfig.createMethods.length) yield `const createArgs = params.createCall?.(${name}CallFactory.create)`\n", "  if (callConfig.updateMethods.length) yield `const updateArgs = params.updateCall?.(${name}CallFactory.update)`\n\t  if (callConfig.deleteMethods.length) yield `const deleteArgs = params.deleteCall?.(${name}CallFactory.delete)`\n\t  yield `return this.appClient.deploy({`\n\t  yield IncIndent\n\t  yield `...params,`\n\t  if (callConfig.updateMethods.length) yield 'updateArgs,'\n\t  if (callConfig.deleteMethods.length) yield 'deleteArgs,'\n\t  if (callConfig.createMethods.length) {\n\t    yield 'createArgs,'\n\t    yield `createOnCompleteAction: createArgs?.onCompleteAction,`\n", "  }\n\t  yield DecIndent\n\t  yield `})`\n\t  yield DecIndentAndCloseBlock\n\t  yield NewLine\n\t  yield* operationMethod(ctx, `Creates a new instance of the ${app.contract.name} smart contract`, callConfig.createMethods, 'create', true)\n\t  yield* operationMethod(\n\t    ctx,\n\t    `Updates an existing instance of the ${app.contract.name} smart contract`,\n\t    callConfig.updateMethods,\n", "    'update',\n\t    true,\n\t  )\n\t  yield* operationMethod(ctx, `Deletes an existing instance of the ${app.contract.name} smart contract`, callConfig.deleteMethods, 'delete')\n\t  yield* operationMethod(\n\t    ctx,\n\t    `Opts the user into an existing instance of the ${app.contract.name} smart contract`,\n\t    callConfig.optInMethods,\n\t    'optIn',\n\t  )\n", "  yield* operationMethod(\n\t    ctx,\n\t    `Makes a close out call to an existing instance of the ${app.contract.name} smart contract`,\n\t    callConfig.closeOutMethods,\n\t    'closeOut',\n\t  )\n\t}\n\tfunction* operationMethod(\n\t  { app, methodSignatureToUniqueName, name }: GeneratorContext,\n\t  description: string,\n", "  methods: MethodList,\n\t  verb: 'create' | 'update' | 'optIn' | 'closeOut' | 'delete',\n\t  includeCompilation?: boolean,\n\t): DocumentParts {\n\t  if (methods.length) {\n\t    yield* jsDoc(`Gets available ${verb} methods`)\n\t    yield `public get ${verb}() {`\n\t    yield IncIndent\n\t    yield `const $this = this`\n\t    yield `return {`\n", "    yield IncIndent\n\t    for (const methodSig of methods) {\n\t      const onComplete = verb === 'create' ? getCreateOnCompleteOptions(methodSig, app) : undefined\n\t      if (methodSig === BARE_CALL) {\n\t        yield* jsDoc({\n\t          description: `${description} using a bare call.`,\n\t          params: {\n\t            args: `The arguments for the bare call`,\n\t          },\n\t          returns: `The ${verb} result`,\n", "        })\n\t        yield `bare(args: BareCallArgs & AppClientCallCoreParams ${\n\t          includeCompilation ? '& AppClientCompilationParams ' : ''\n\t        }& CoreAppCallArgs${onComplete?.type ? ` & ${onComplete.type}` : ''}${\n\t          onComplete?.isOptional !== false ? ' = {}' : ''\n\t        }): Promise<AppCallTransactionResultOfType<undefined>> {`\n\t        yield* indent(`return $this.appClient.${verb}(args) as unknown as Promise<AppCallTransactionResultOfType<undefined>>`)\n\t        yield '},'\n\t      } else {\n\t        const uniqueName = methodSignatureToUniqueName[methodSig]\n", "        const method = app.contract.methods.find((m) => algokit.getABIMethodSignature(m) === methodSig)\n\t        yield* jsDoc({\n\t          description: `${description} using the ${methodSig} ABI method.`,\n\t          params: {\n\t            args: `The arguments for the smart contract call`,\n\t            params: `Any additional parameters for the call`,\n\t          },\n\t          returns: `The ${verb} result${method?.returns?.desc ? `: ${method.returns.desc}` : ''}`,\n\t        })\n\t        yield `async ${makeSafeMethodIdentifier(uniqueName)}(args: MethodArgs<'${methodSig}'>, params: AppClientCallCoreParams${\n", "          includeCompilation ? ' & AppClientCompilationParams' : ''\n\t        }${onComplete?.type ? ` & ${onComplete.type}` : ''}${\n\t          onComplete?.isOptional !== false ? ' = {}' : ''\n\t        }): Promise<AppCallTransactionResultOfType<MethodReturn<'${methodSig}'>>> {`\n\t        yield* indent(\n\t          `return $this.mapReturnValue(await $this.appClient.${verb}(${name}CallFactory.${verb}.${makeSafeMethodIdentifier(\n\t            uniqueName,\n\t          )}(args, params)))`,\n\t        )\n\t        yield '},'\n", "      }\n\t    }\n\t    yield DecIndentAndCloseBlock\n\t    yield DecIndentAndCloseBlock\n\t    yield NewLine\n\t  }\n\t}\n\tfunction* clearState({ app }: GeneratorContext): DocumentParts {\n\t  yield* jsDoc({\n\t    description: `Makes a clear_state call to an existing instance of the ${app.contract.name} smart contract.`,\n", "    params: {\n\t      args: `The arguments for the bare call`,\n\t    },\n\t    returns: `The clear_state result`,\n\t  })\n\t  yield `public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {`\n\t  yield IncIndent\n\t  yield `return this.appClient.clearState(args)`\n\t  yield DecIndentAndCloseBlock\n\t  yield NewLine\n", "}\n\tfunction* noopMethods({ app, name, callConfig, methodSignatureToUniqueName }: GeneratorContext): DocumentParts {\n\t  for (const method of app.contract.methods) {\n\t    const methodSignature = algokit.getABIMethodSignature(method)\n\t    const methodName = makeSafeMethodIdentifier(methodSignatureToUniqueName[methodSignature])\n\t    // Skip methods which don't support a no_op call config\n\t    if (!callConfig.callMethods.includes(methodSignature)) continue\n\t    yield* jsDoc({\n\t      description: `Calls the ${algokit.getABIMethodSignature(method)} ABI method.`,\n\t      abiDescription: method.desc,\n", "      params: {\n\t        args: `The arguments for the contract call`,\n\t        params: `Any additional parameters for the call`,\n\t      },\n\t      returns: `The result of the call${method?.returns?.desc ? `: ${method.returns.desc}` : ''}`,\n\t    })\n\t    yield `public ${methodName}(args: MethodArgs<'${methodSignature}'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {`\n\t    yield IncIndent\n\t    const outputTypeName = app.hints?.[methodSignature]?.structs?.output?.name\n\t    yield `return this.call(${name}CallFactory.${methodName}(args, params)${\n", "      outputTypeName === undefined ? '' : `, ${makeSafeTypeIdentifier(outputTypeName)}`\n\t    })`\n\t    yield DecIndent\n\t    yield '}'\n\t    yield NewLine\n\t  }\n\t}\n\tfunction* getStateMethods({ app, name }: GeneratorContext): DocumentParts {\n\t  const globalStateValues = app.schema.global?.declared && Object.values(app.schema.global?.declared)\n\t  const localStateValues = app.schema.local?.declared && Object.values(app.schema.local?.declared)\n", "  if (globalStateValues?.length || localStateValues?.length) {\n\t    yield* jsDoc({\n\t      description: 'Extracts a binary state value out of an AppState dictionary',\n\t      params: {\n\t        state: 'The state dictionary containing the state value',\n\t        key: 'The key of the state value',\n\t      },\n\t      returns: 'A BinaryState instance containing the state value, or undefined if the key was not found',\n\t    })\n\t    yield `private static getBinaryState(state: AppState, key: string): BinaryState | undefined {`\n", "    yield IncIndent\n\t    yield `const value = state[key]`\n\t    yield `if (!value) return undefined`\n\t    yield `if (!('valueRaw' in value))`\n\t    yield* indent(`throw new Error(\\`Failed to parse state value for \\${key}; received an int when expected a byte array\\`)`)\n\t    yield `return {`\n\t    yield IncIndent\n\t    yield `asString(): string {`\n\t    yield* indent(`return value.value`)\n\t    yield `},`\n", "    yield `asByteArray(): Uint8Array {`\n\t    yield* indent(`return value.valueRaw`)\n\t    yield `}`\n\t    yield DecIndentAndCloseBlock\n\t    yield DecIndentAndCloseBlock\n\t    yield NewLine\n\t    yield* jsDoc({\n\t      description: 'Extracts a integer state value out of an AppState dictionary',\n\t      params: {\n\t        state: 'The state dictionary containing the state value',\n", "        key: 'The key of the state value',\n\t      },\n\t      returns: 'An IntegerState instance containing the state value, or undefined if the key was not found',\n\t    })\n\t    yield `private static getIntegerState(state: AppState, key: string): IntegerState | undefined {`\n\t    yield IncIndent\n\t    yield `const value = state[key]`\n\t    yield `if (!value) return undefined`\n\t    yield `if ('valueRaw' in value)`\n\t    yield* indent(`throw new Error(\\`Failed to parse state value for \\${key}; received a byte array when expected a number\\`)`)\n", "    yield `return {`\n\t    yield IncIndent\n\t    yield `asBigInt() {`\n\t    yield* indent(`return typeof value.value === 'bigint' ? value.value : BigInt(value.value)`)\n\t    yield `},`\n\t    yield `asNumber(): number {`\n\t    yield* indent(`return typeof value.value === 'bigint' ? Number(value.value) : value.value`)\n\t    yield `},`\n\t    yield DecIndentAndCloseBlock\n\t    yield DecIndentAndCloseBlock\n", "    yield NewLine\n\t  }\n\t  if (globalStateValues?.length) {\n\t    yield* jsDoc(`Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value`)\n\t    yield `public async getGlobalState(): Promise<${name}['state']['global']> {`\n\t    yield IncIndent\n\t    yield `const state = await this.appClient.getGlobalState()`\n\t    yield `return {`\n\t    yield IncIndent\n\t    for (const stateValue of globalStateValues) {\n", "      yield `get ${stateValue.key}() {`\n\t      if (stateValue.type === 'uint64') {\n\t        yield* indent(`return ${name}Client.getIntegerState(state, '${stateValue.key}')`)\n\t      } else {\n\t        yield* indent(`return ${name}Client.getBinaryState(state, '${stateValue.key}')`)\n\t      }\n\t      yield '},'\n\t    }\n\t    yield DecIndentAndCloseBlock\n\t    yield DecIndentAndCloseBlock\n", "    yield NewLine\n\t  }\n\t  if (localStateValues?.length) {\n\t    yield* jsDoc({\n\t      description: `Returns the smart contract's local state wrapped in a strongly typed accessor with options to format the stored value`,\n\t      params: {\n\t        account: `The address of the account for which to read local state from`,\n\t      },\n\t    })\n\t    yield `public async getLocalState(account: string | SendTransactionFrom): Promise<${name}['state']['local']> {`\n", "    yield IncIndent\n\t    yield `const state = await this.appClient.getLocalState(account)`\n\t    yield `return {`\n\t    yield IncIndent\n\t    for (const stateValue of localStateValues) {\n\t      yield `get ${stateValue.key}() {`\n\t      if (stateValue.type === 'uint64') {\n\t        yield* indent(`return ${name}Client.getIntegerState(state, '${stateValue.key}')`)\n\t      } else {\n\t        yield* indent(`return ${name}Client.getBinaryState(state, '${stateValue.key}')`)\n", "      }\n\t      yield '},'\n\t    }\n\t    yield DecIndentAndCloseBlock\n\t    yield DecIndentAndCloseBlock\n\t    yield NewLine\n\t  }\n\t}\n"]}
{"filename": "src/client/app-types.ts", "chunked_list": ["import { GeneratorContext } from './generator-context'\n\timport { DecIndent, DecIndentAndCloseBlock, DocumentParts, IncIndent, inline, jsDoc, NewLine } from '../output/writer'\n\timport * as algokit from '@algorandfoundation/algokit-utils'\n\timport { getEquivalentType } from './helpers/get-equivalent-type'\n\timport { makeSafePropertyIdentifier, makeSafeTypeIdentifier, makeSafeVariableIdentifier } from '../util/sanitization'\n\texport function* appTypes(ctx: GeneratorContext): DocumentParts {\n\t  const { app, methodSignatureToUniqueName, name } = ctx\n\t  yield* jsDoc(`Defines the types of available calls and state of the ${name} smart contract.`)\n\t  yield `export type ${name} = {`\n\t  yield IncIndent\n", "  yield* jsDoc('Maps method signatures / names to their argument and return types.')\n\t  yield 'methods:'\n\t  yield IncIndent\n\t  for (const method of app.contract.methods) {\n\t    const methodSig = algokit.getABIMethodSignature(method)\n\t    const uniqueName = methodSignatureToUniqueName[methodSig]\n\t    yield `& Record<'${methodSig}'${methodSig !== uniqueName ? ` | '${uniqueName}'` : ''}, {`\n\t    yield IncIndent\n\t    yield `argsObj: {`\n\t    yield IncIndent\n", "    const argsMeta = method.args.map((arg) => ({\n\t      ...arg,\n\t      hasDefault: app.hints?.[methodSig]?.default_arguments?.[arg.name],\n\t      tsType: getEquivalentType(arg.type, 'input'),\n\t    }))\n\t    for (const arg of argsMeta) {\n\t      if (arg.desc) yield* jsDoc(arg.desc)\n\t      yield `${makeSafePropertyIdentifier(arg.name)}${arg.hasDefault ? '?' : ''}: ${arg.tsType}`\n\t    }\n\t    yield DecIndentAndCloseBlock\n", "    yield* inline(\n\t      `argsTuple: [`,\n\t      argsMeta\n\t        .map(\n\t          (arg) =>\n\t            `${makeSafeVariableIdentifier(arg.name)}: ${getEquivalentType(arg.type, 'input')}${arg.hasDefault ? ' | undefined' : ''}`,\n\t        )\n\t        .join(', '),\n\t      ']',\n\t    )\n", "    const outputStruct = ctx.app.hints?.[methodSig]?.structs?.output\n\t    if (method.returns.desc) yield* jsDoc(method.returns.desc)\n\t    if (outputStruct) {\n\t      yield `returns: ${makeSafeTypeIdentifier(outputStruct.name)}`\n\t    } else {\n\t      yield `returns: ${getEquivalentType(method.returns.type ?? 'void', 'output')}`\n\t    }\n\t    yield DecIndent\n\t    yield '}>'\n\t  }\n", "  yield DecIndent\n\t  yield* appState(ctx)\n\t  yield DecIndentAndCloseBlock\n\t  yield* jsDoc('Defines the possible abi call signatures')\n\t  yield `export type ${name}Sig = keyof ${name}['methods']`\n\t  yield* jsDoc(\n\t    'Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a' +\n\t      ' bare call is made',\n\t  )\n\t  yield `export type TypedCallParams<TSignature extends ${name}Sig | undefined> = {`\n", "  yield IncIndent\n\t  yield 'method: TSignature'\n\t  yield 'methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>'\n\t  yield DecIndent\n\t  yield '} & AppClientCallCoreParams & CoreAppCallArgs'\n\t  yield* jsDoc('Defines the arguments required for a bare call')\n\t  yield `export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>`\n\t  yield* structs(ctx)\n\t  yield* jsDoc(`Maps a method signature from the ${name} smart contract to the method's arguments in either tuple of struct form`)\n\t  yield `export type MethodArgs<TSignature extends ${name}Sig> = ${name}['methods'][TSignature]['argsObj' | 'argsTuple']`\n", "  yield* jsDoc(`Maps a method signature from the ${name} smart contract to the method's return type`)\n\t  yield `export type MethodReturn<TSignature extends ${name}Sig> = ${name}['methods'][TSignature]['returns']`\n\t  yield NewLine\n\t}\n\tfunction* structs({ app }: GeneratorContext): DocumentParts {\n\t  if (app.hints === undefined) return\n\t  for (const methodHint of Object.values(app.hints)) {\n\t    if (methodHint.structs === undefined) continue\n\t    for (const struct of Object.values(methodHint.structs)) {\n\t      yield* jsDoc(`Represents a ${struct.name} result as a struct`)\n", "      yield `export type ${makeSafeTypeIdentifier(struct.name)} = {`\n\t      yield IncIndent\n\t      for (const [key, type] of struct.elements) {\n\t        yield `${makeSafePropertyIdentifier(key)}: ${getEquivalentType(type, 'output')}`\n\t      }\n\t      yield DecIndentAndCloseBlock\n\t      yield* jsDoc(`Converts the tuple representation of a ${struct.name} to the struct representation`)\n\t      yield* inline(\n\t        `export function ${makeSafeTypeIdentifier(struct.name)}(`,\n\t        `[${struct.elements.map(([key]) => makeSafeVariableIdentifier(key)).join(', ')}]: `,\n", "        `[${struct.elements.map(([_, type]) => getEquivalentType(type, 'output')).join(', ')}] ) {`,\n\t      )\n\t      yield IncIndent\n\t      yield `return {`\n\t      yield IncIndent\n\t      for (const [key] of struct.elements) {\n\t        const prop = makeSafePropertyIdentifier(key)\n\t        const param = makeSafeVariableIdentifier(key)\n\t        yield `${prop}${prop !== param ? `: ${param}` : ''},`\n\t      }\n", "      yield DecIndentAndCloseBlock\n\t      yield DecIndentAndCloseBlock\n\t    }\n\t  }\n\t}\n\tfunction* appState({ app }: GeneratorContext): DocumentParts {\n\t  const hasLocal = app.schema.local?.declared && Object.keys(app.schema.local.declared).length\n\t  const hasGlobal = app.schema.global?.declared && Object.keys(app.schema.global.declared).length\n\t  if (hasLocal || hasGlobal) {\n\t    yield* jsDoc('Defines the shape of the global and local state of the application.')\n", "    yield 'state: {'\n\t    yield IncIndent\n\t    if (hasGlobal) {\n\t      yield 'global: {'\n\t      yield IncIndent\n\t      for (const prop of Object.values(app.schema.global!.declared!)) {\n\t        if (prop.descr) {\n\t          yield* jsDoc(prop.descr)\n\t        }\n\t        yield `'${prop.key}'?: ${prop.type === 'uint64' ? 'IntegerState' : 'BinaryState'}`\n", "      }\n\t      yield DecIndentAndCloseBlock\n\t    }\n\t    if (hasLocal) {\n\t      yield 'local: {'\n\t      yield IncIndent\n\t      for (const prop of Object.values(app.schema.local!.declared!)) {\n\t        if (prop.descr) {\n\t          yield* jsDoc(prop.descr)\n\t        }\n", "        yield `'${prop.key}'?: ${prop.type === 'uint64' ? 'IntegerState' : 'BinaryState'}`\n\t      }\n\t      yield DecIndentAndCloseBlock\n\t    }\n\t    yield DecIndentAndCloseBlock\n\t  }\n\t}\n"]}
{"filename": "src/client/call-composer-types.ts", "chunked_list": ["import { DecIndentAndCloseBlock, DocumentParts, IncIndent, jsDoc, NewLine } from '../output/writer'\n\timport { GeneratorContext } from './generator-context'\n\timport * as algokit from '@algorandfoundation/algokit-utils'\n\timport { makeSafeMethodIdentifier } from '../util/sanitization'\n\timport { BARE_CALL, MethodList } from './helpers/get-call-config-summary'\n\timport { getCreateOnCompleteOptions } from './deploy-types'\n\texport function* callComposerType(ctx: GeneratorContext): DocumentParts {\n\t  const { name, callConfig, app } = ctx\n\t  yield `export type ${name}Composer<TReturns extends [...any[]] = []> = {`\n\t  yield IncIndent\n", "  yield* callComposerTypeNoops(ctx)\n\t  yield* callComposerOperationMethodType(\n\t    ctx,\n\t    `Updates an existing instance of the ${app.contract.name} smart contract`,\n\t    callConfig.updateMethods,\n\t    'update',\n\t    true,\n\t  )\n\t  yield* callComposerOperationMethodType(\n\t    ctx,\n", "    `Deletes an existing instance of the ${app.contract.name} smart contract`,\n\t    callConfig.deleteMethods,\n\t    'delete',\n\t  )\n\t  yield* callComposerOperationMethodType(\n\t    ctx,\n\t    `Opts the user into an existing instance of the ${app.contract.name} smart contract`,\n\t    callConfig.optInMethods,\n\t    'optIn',\n\t  )\n", "  yield* callComposerOperationMethodType(\n\t    ctx,\n\t    `Makes a close out call to an existing instance of the ${app.contract.name} smart contract`,\n\t    callConfig.closeOutMethods,\n\t    'closeOut',\n\t  )\n\t  yield* callComposerTypeClearState(ctx)\n\t  yield* jsDoc({\n\t    description: 'Adds a transaction to the composer',\n\t    params: {\n", "      txn: 'One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)',\n\t      defaultSender:\n\t        'The default sender to be used to obtain a signer where the object provided to the transaction parameter does not' +\n\t        ' include a signer.',\n\t    },\n\t  })\n\t  yield `addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): ${name}Composer<TReturns>`\n\t  yield* jsDoc({\n\t    description: 'Returns the underlying AtomicTransactionComposer instance',\n\t  })\n", "  yield `atc(): Promise<AtomicTransactionComposer>`\n\t  yield* jsDoc({\n\t    description: 'Executes the transaction group and returns an array of results',\n\t  })\n\t  yield `execute(): Promise<${name}ComposerResults<TReturns>>`\n\t  yield DecIndentAndCloseBlock\n\t  yield `export type ${name}ComposerResults<TReturns extends [...any[]]> = {`\n\t  yield IncIndent\n\t  yield `returns: TReturns`\n\t  yield `groupId: string`\n", "  yield `txIds: string[]`\n\t  yield `transactions: Transaction[]`\n\t  yield DecIndentAndCloseBlock\n\t}\n\tfunction* callComposerTypeClearState({ app, name }: GeneratorContext): DocumentParts {\n\t  yield* jsDoc({\n\t    description: `Makes a clear_state call to an existing instance of the ${app.contract.name} smart contract.`,\n\t    params: {\n\t      args: `The arguments for the bare call`,\n\t    },\n", "    returns: `The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions`,\n\t  })\n\t  yield `clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): ${name}Composer<[...TReturns, undefined]>`\n\t  yield NewLine\n\t}\n\tfunction* callComposerTypeNoops({ app, name, callConfig, methodSignatureToUniqueName }: GeneratorContext): DocumentParts {\n\t  for (const method of app.contract.methods) {\n\t    const methodSignature = algokit.getABIMethodSignature(method)\n\t    const methodName = makeSafeMethodIdentifier(methodSignatureToUniqueName[methodSignature])\n\t    // Skip methods which don't support a no_op call config\n", "    if (!callConfig.callMethods.includes(methodSignature)) continue\n\t    yield* jsDoc({\n\t      description: `Calls the ${algokit.getABIMethodSignature(method)} ABI method.`,\n\t      abiDescription: method.desc,\n\t      params: {\n\t        args: `The arguments for the contract call`,\n\t        params: `Any additional parameters for the call`,\n\t      },\n\t      returns: `The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions`,\n\t    })\n", "    yield `${methodName}(args: MethodArgs<'${methodSignature}'>, params?: AppClientCallCoreParams & CoreAppCallArgs): ${name}Composer<[...TReturns, MethodReturn<'${methodSignature}'>]>`\n\t    yield NewLine\n\t  }\n\t}\n\tfunction* callComposerOperationMethodType(\n\t  { app, methodSignatureToUniqueName, name }: GeneratorContext,\n\t  description: string,\n\t  methods: MethodList,\n\t  verb: 'create' | 'update' | 'optIn' | 'closeOut' | 'delete',\n\t  includeCompilation?: boolean,\n", "): DocumentParts {\n\t  if (methods.length) {\n\t    yield* jsDoc(`Gets available ${verb} methods`)\n\t    yield `readonly ${verb}: {`\n\t    yield IncIndent\n\t    for (const methodSig of methods) {\n\t      const onComplete = verb === 'create' ? getCreateOnCompleteOptions(methodSig, app) : undefined\n\t      if (methodSig === BARE_CALL) {\n\t        yield* jsDoc({\n\t          description: `${description} using a bare call.`,\n", "          params: {\n\t            args: `The arguments for the bare call`,\n\t          },\n\t          returns: `The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions`,\n\t        })\n\t        yield `bare(args${onComplete?.isOptional !== false ? '?' : ''}: BareCallArgs & AppClientCallCoreParams ${\n\t          includeCompilation ? '& AppClientCompilationParams ' : ''\n\t        }& CoreAppCallArgs${onComplete?.type ? ` & ${onComplete.type}` : ''}): ${name}Composer<[...TReturns, undefined]>`\n\t      } else {\n\t        const uniqueName = methodSignatureToUniqueName[methodSig]\n", "        yield* jsDoc({\n\t          description: `${description} using the ${methodSig} ABI method.`,\n\t          params: {\n\t            args: `The arguments for the smart contract call`,\n\t            params: `Any additional parameters for the call`,\n\t          },\n\t          returns: `The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions`,\n\t        })\n\t        yield `${makeSafeMethodIdentifier(uniqueName)}(args: MethodArgs<'${methodSig}'>, params${\n\t          onComplete?.isOptional !== false ? '?' : ''\n", "        }: AppClientCallCoreParams${includeCompilation ? ' & AppClientCompilationParams' : ''}${\n\t          onComplete?.type ? ` & ${onComplete.type}` : ''\n\t        }): ${name}Composer<[...TReturns, MethodReturn<'${methodSig}'>]>`\n\t      }\n\t    }\n\t    yield DecIndentAndCloseBlock\n\t    yield NewLine\n\t  }\n\t}\n"]}
{"filename": "src/client/generate.ts", "chunked_list": ["import { DocumentParts, inline, NewLine } from '../output/writer'\n\timport { AlgoAppSpec } from '../schema/application'\n\timport { callFactory } from './call-factory'\n\timport { callClient } from './call-client'\n\timport { deployTypes } from './deploy-types'\n\timport { utilityTypes } from './utility-types'\n\timport { imports } from './imports'\n\timport { createGeneratorContext } from './generator-context'\n\timport { appTypes } from './app-types'\n\timport { callComposerType } from './call-composer-types'\n", "export function* generate(app: AlgoAppSpec): DocumentParts {\n\t  const ctx = createGeneratorContext(app)\n\t  yield `/* eslint-disable */`\n\t  yield `/**`\n\t  yield ` * This file was automatically generated by @algorandfoundation/algokit-client-generator.`\n\t  yield ` * DO NOT MODIFY IT BY HAND.`\n\t  yield ` * requires: @algorandfoundation/algokit-utils: ^2`\n\t  yield ` */`\n\t  yield* imports()\n\t  yield* inline('export const APP_SPEC: AppSpec = ', JSON.stringify(app, undefined, 2))\n", "  yield NewLine\n\t  yield* utilityTypes()\n\t  yield NewLine\n\t  yield* appTypes(ctx)\n\t  yield* deployTypes(ctx)\n\t  yield NewLine\n\t  // Write a call factory\n\t  yield* callFactory(ctx)\n\t  yield NewLine\n\t  // Write a client\n", "  yield* callClient(ctx)\n\t  yield* callComposerType(ctx)\n\t}\n"]}
{"filename": "src/client/generator-context.ts", "chunked_list": ["import { AlgoAppSpec } from '../schema/application'\n\timport { CallConfigSummary, getCallConfigSummary } from './helpers/get-call-config-summary'\n\timport { makeSafeTypeIdentifier } from '../util/sanitization'\n\timport * as algokit from '@algorandfoundation/algokit-utils'\n\texport type GeneratorContext = {\n\t  app: AlgoAppSpec\n\t  name: string\n\t  callConfig: CallConfigSummary\n\t  methodSignatureToUniqueName: Record<string, string>\n\t}\n", "export const createGeneratorContext = (app: AlgoAppSpec) => ({\n\t  app,\n\t  name: makeSafeTypeIdentifier(app.contract.name),\n\t  callConfig: getCallConfigSummary(app),\n\t  methodSignatureToUniqueName: app.contract.methods.reduce((acc, cur) => {\n\t    const signature = algokit.getABIMethodSignature(cur)\n\t    acc[signature] = app.contract.methods.some((m) => m.name === cur.name && m !== cur) ? signature : cur.name\n\t    return acc\n\t  }, {} as Record<string, string>),\n\t})\n"]}
{"filename": "src/client/deploy-types.ts", "chunked_list": ["import { DecIndent, DecIndentAndCloseBlock, DocumentParts, IncIndent, jsDoc, NewLine } from '../output/writer'\n\timport { makeSafeTypeIdentifier } from '../util/sanitization'\n\timport { BARE_CALL, MethodIdentifier } from './helpers/get-call-config-summary'\n\timport { GeneratorContext } from './generator-context'\n\timport { AlgoAppSpec, CallConfig } from '../schema/application'\n\timport { OnCompleteCodeMap } from './utility-types'\n\texport function getCreateOnCompleteOptions(method: MethodIdentifier, app: AlgoAppSpec) {\n\t  const callConfig = method === BARE_CALL ? app.bare_call_config : app.hints?.[method]?.call_config\n\t  const hasNoOp = callConfig?.no_op === 'ALL' || callConfig?.no_op === 'CREATE'\n\t  const onCompleteType = callConfig\n", "    ? `(${Object.entries(callConfig)\n\t        .filter(([_, value]) => value === 'ALL' || value === 'CREATE')\n\t        .map(([oc]) => OnCompleteCodeMap[oc as keyof CallConfig])\n\t        .join(' | ')})`\n\t    : {}\n\t  return {\n\t    type: onCompleteType,\n\t    isOptional: hasNoOp,\n\t  }\n\t}\n", "export function* deployTypes({ app, callConfig }: GeneratorContext): DocumentParts {\n\t  const name = makeSafeTypeIdentifier(app.contract.name)\n\t  if (callConfig.createMethods.length > 0) {\n\t    yield* jsDoc(`A factory for available 'create' calls`)\n\t    yield `export type ${name}CreateCalls = (typeof ${name}CallFactory)['create']`\n\t    yield* jsDoc('Defines supported create methods for this smart contract')\n\t    yield `export type ${name}CreateCallParams =`\n\t    yield IncIndent\n\t    for (const method of callConfig.createMethods) {\n\t      const onComplete = getCreateOnCompleteOptions(method, app)\n", "      if (method === BARE_CALL) {\n\t        yield `| (TypedCallParams<undefined> & ${onComplete.type})`\n\t      } else {\n\t        yield `| (TypedCallParams<'${method}'> & ${onComplete.type})`\n\t      }\n\t    }\n\t    yield DecIndent\n\t  }\n\t  if (callConfig.updateMethods.length > 0) {\n\t    yield* jsDoc(`A factory for available 'update' calls`)\n", "    yield `export type ${name}UpdateCalls = (typeof ${name}CallFactory)['update']`\n\t    yield* jsDoc('Defines supported update methods for this smart contract')\n\t    yield `export type ${name}UpdateCallParams =`\n\t    yield IncIndent\n\t    for (const method of callConfig.updateMethods) {\n\t      if (method === BARE_CALL) {\n\t        yield `| TypedCallParams<undefined>`\n\t      } else {\n\t        yield `| TypedCallParams<'${method}'>`\n\t      }\n", "    }\n\t    yield DecIndent\n\t  }\n\t  if (callConfig.deleteMethods.length > 0) {\n\t    yield* jsDoc(`A factory for available 'delete' calls`)\n\t    yield `export type ${name}DeleteCalls = (typeof ${name}CallFactory)['delete']`\n\t    yield* jsDoc('Defines supported delete methods for this smart contract')\n\t    yield `export type ${name}DeleteCallParams =`\n\t    yield IncIndent\n\t    for (const method of callConfig.deleteMethods) {\n", "      if (method === BARE_CALL) {\n\t        yield `| TypedCallParams<undefined>`\n\t      } else {\n\t        yield `| TypedCallParams<'${method}'>`\n\t      }\n\t    }\n\t    yield DecIndent\n\t  }\n\t  yield* jsDoc('Defines arguments required for the deploy method.')\n\t  yield `export type ${name}DeployArgs = {`\n", "  yield IncIndent\n\t  yield `deployTimeParams?: TealTemplateParams`\n\t  if (callConfig.createMethods.length) {\n\t    yield* jsDoc('A delegate which takes a create call factory and returns the create call params for this smart contract')\n\t    yield `createCall?: (callFactory: ${name}CreateCalls) => ${name}CreateCallParams`\n\t  }\n\t  if (callConfig.updateMethods.length) {\n\t    yield* jsDoc('A delegate which takes a update call factory and returns the update call params for this smart contract')\n\t    yield `updateCall?: (callFactory: ${name}UpdateCalls) => ${name}UpdateCallParams`\n\t  }\n", "  if (callConfig.deleteMethods.length) {\n\t    yield* jsDoc('A delegate which takes a delete call factory and returns the delete call params for this smart contract')\n\t    yield `deleteCall?: (callFactory: ${name}DeleteCalls) => ${name}DeleteCallParams`\n\t  }\n\t  yield DecIndentAndCloseBlock\n\t  yield NewLine\n\t}\n"]}
{"filename": "src/client/helpers/get-call-config-summary.ts", "chunked_list": ["import { pascalCase } from 'change-case'\n\timport { AlgoAppSpec, CallConfig, CallConfigValue } from '../../schema/application'\n\texport const BARE_CALL = Symbol('bare')\n\texport type MethodIdentifier = string | typeof BARE_CALL\n\texport type MethodList = Array<MethodIdentifier>\n\texport type CallConfigSummary = {\n\t  createMethods: MethodList\n\t  callMethods: MethodList\n\t  deleteMethods: MethodList\n\t  updateMethods: MethodList\n", "  optInMethods: MethodList\n\t  closeOutMethods: MethodList\n\t}\n\texport const getCallConfigSummary = (app: AlgoAppSpec) => {\n\t  const result: CallConfigSummary = {\n\t    createMethods: [],\n\t    callMethods: [],\n\t    deleteMethods: [],\n\t    updateMethods: [],\n\t    optInMethods: [],\n", "    closeOutMethods: [],\n\t  }\n\t  if (app.bare_call_config) {\n\t    addToConfig(result, BARE_CALL, app.bare_call_config)\n\t  }\n\t  if (app.hints) {\n\t    for (const [method, hints] of Object.entries(app.hints)) {\n\t      if (hints.call_config) {\n\t        addToConfig(result, method, hints.call_config)\n\t      }\n", "    }\n\t  }\n\t  return result\n\t}\n\texport const getCreateOnComplete = (app: AlgoAppSpec, method: MethodIdentifier) => {\n\t  const callConfig = method === BARE_CALL ? app.bare_call_config : app.hints?.[method]?.call_config\n\t  if (!callConfig) {\n\t    return ''\n\t  }\n\t  const hasNoOp = callConfig.no_op === 'ALL' || callConfig.no_op === 'CREATE'\n", "  return `{ onCompleteAction${hasNoOp ? '?' : ''}: ${getCreateOnCompleteTypes(callConfig)} }`\n\t}\n\tconst getCreateOnCompleteTypes = (config: CallConfig) => {\n\t  return Object.keys(config)\n\t    .map((oc) => oc as keyof CallConfig)\n\t    .filter((oc) => config[oc] === 'ALL' || config[oc] === 'CREATE')\n\t    .map((oc) => `'${oc}' | OnApplicationComplete.${pascalCase(oc)}OC`)\n\t    .join(' | ')\n\t}\n\tconst addToConfig = (result: CallConfigSummary, method: MethodIdentifier, config: CallConfig) => {\n", "  if (hasCall(config.no_op)) {\n\t    result.callMethods.push(method)\n\t  }\n\t  if (\n\t    hasCreate(config.no_op) ||\n\t    hasCreate(config.opt_in) ||\n\t    hasCreate(config.close_out) ||\n\t    hasCreate(config.update_application) ||\n\t    hasCreate(config.delete_application)\n\t  ) {\n", "    result.createMethods.push(method)\n\t  }\n\t  if (hasCall(config.delete_application)) {\n\t    result.deleteMethods.push(method)\n\t  }\n\t  if (hasCall(config.update_application)) {\n\t    result.updateMethods.push(method)\n\t  }\n\t  if (hasCall(config.opt_in)) {\n\t    result.optInMethods.push(method)\n", "  }\n\t  if (hasCall(config.close_out)) {\n\t    result.closeOutMethods.push(method)\n\t  }\n\t}\n\tconst hasCall = (config: CallConfigValue | undefined) => {\n\t  return config === 'CALL' || config === 'ALL'\n\t}\n\tconst hasCreate = (config: CallConfigValue | undefined) => {\n\t  return config === 'CREATE' || config === 'ALL'\n", "}\n"]}
{"filename": "src/client/helpers/get-equivalent-type.ts", "chunked_list": ["import {\n\t  ABIAddressType,\n\t  ABIArrayDynamicType,\n\t  ABIArrayStaticType,\n\t  ABIBoolType,\n\t  ABIByteType,\n\t  ABIReferenceType,\n\t  ABIStringType,\n\t  ABITupleType,\n\t  ABIType,\n", "  ABIUfixedType,\n\t  ABIUintType,\n\t  abiTypeIsTransaction,\n\t} from 'algosdk'\n\texport function getEquivalentType(abiTypeStr: string, ioType: 'input' | 'output'): string {\n\t  if (abiTypeStr == 'void') {\n\t    return 'void'\n\t  }\n\t  if (abiTypeIsTransaction(abiTypeStr)) {\n\t    return 'TransactionToSign | Transaction | Promise<SendTransactionResult>'\n", "  }\n\t  if (abiTypeStr == ABIReferenceType.account) {\n\t    return 'string | Uint8Array'\n\t  }\n\t  if (abiTypeStr == ABIReferenceType.application || abiTypeStr == ABIReferenceType.asset) {\n\t    return 'number | bigint'\n\t  }\n\t  const abiType = ABIType.from(abiTypeStr)\n\t  return abiTypeToTs(abiType, ioType)\n\t  function abiTypeToTs(abiType: ABIType, ioType: 'input' | 'output'): string {\n", "    if (abiType instanceof ABIUintType) {\n\t      if (abiType.bitSize <= 51) return 'number'\n\t      return ioType === 'input' ? 'bigint | number' : 'bigint'\n\t    }\n\t    if (abiType instanceof ABIArrayDynamicType) {\n\t      if (abiType.childType instanceof ABIByteType) return 'Uint8Array'\n\t      return `${abiTypeToTs(abiType.childType, ioType)}[]`\n\t    }\n\t    if (abiType instanceof ABIArrayStaticType) {\n\t      if (abiType.childType instanceof ABIByteType) return 'Uint8Array'\n", "      return `[${new Array(abiType.staticLength).fill(abiTypeToTs(abiType.childType, ioType)).join(', ')}]`\n\t    }\n\t    if (abiType instanceof ABIAddressType) {\n\t      return 'string'\n\t    }\n\t    if (abiType instanceof ABIBoolType) {\n\t      return 'boolean'\n\t    }\n\t    if (abiType instanceof ABIUfixedType) {\n\t      return 'number'\n", "    }\n\t    if (abiType instanceof ABITupleType) {\n\t      return `[${abiType.childTypes.map((c) => abiTypeToTs(c, ioType)).join(', ')}]`\n\t    }\n\t    if (abiType instanceof ABIByteType) {\n\t      return 'number'\n\t    }\n\t    if (abiType instanceof ABIStringType) {\n\t      return 'string'\n\t    }\n", "    return 'unknown'\n\t  }\n\t}\n"]}
{"filename": "src/schema/application.d.ts", "chunked_list": ["/* eslint-disable */\n\t/**\n\t * This file was automatically generated by json-schema-to-typescript.\n\t * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n\t * and run json-schema-to-typescript to regenerate this file.\n\t */\n\t/**\n\t * @minItems 2\n\t */\n\texport type StructElement = [FieldName, ABIType];\n", "export type FieldName = string;\n\texport type ABIType = string;\n\t/**\n\t * Defines a strategy for obtaining a default value for a given ABI arg.\n\t */\n\texport type DefaultArgument =\n\t  | {\n\t      /**\n\t       * The default value should be fetched by invoking an ABI method\n\t       */\n", "      source: \"abi-method\";\n\t      data: ContractMethod;\n\t    }\n\t  | {\n\t      /**\n\t       * The default value should be fetched from global state\n\t       */\n\t      source: \"global-state\";\n\t      /**\n\t       * The key of the state variable\n", "       */\n\t      data: string;\n\t    }\n\t  | {\n\t      /**\n\t       * The default value should be fetched from the local state of the sender user\n\t       */\n\t      source: \"local-state\";\n\t      /**\n\t       * The key of the state variable\n", "       */\n\t      data: string;\n\t    }\n\t  | {\n\t      /**\n\t       * The default value is a constant.\n\t       */\n\t      source: \"constant\";\n\t      /**\n\t       * The static default value to use.\n", "       */\n\t      data: string | number;\n\t    };\n\texport type CallConfigValue = \"NEVER\" | \"CALL\" | \"CREATE\" | \"ALL\";\n\texport interface AlgoAppSpec {\n\t  hints?: {\n\t    [k: string]: Hint;\n\t  };\n\t  source: AppSources;\n\t  contract: AbiContract;\n", "  schema: SchemaSpec;\n\t  state: StateSchemaSpec;\n\t  bare_call_config?: CallConfig;\n\t}\n\texport interface Hint {\n\t  read_only?: boolean;\n\t  structs?: {\n\t    output?: Struct;\n\t    [k: string]: Struct;\n\t  };\n", "  default_arguments?: {\n\t    [k: string]: DefaultArgument;\n\t  };\n\t  call_config?: CallConfig;\n\t}\n\texport interface Struct {\n\t  name: string;\n\t  elements: StructElement[];\n\t}\n\t/**\n", " * The contract of the ABI method to invoke.\n\t */\n\texport interface ContractMethod {\n\t  name: string;\n\t  args: ContractMethodArg[];\n\t  desc?: string;\n\t  returns: {\n\t    desc?: string;\n\t    /**\n\t     * Catch all for fixed length arrays and tuples\n", "     */\n\t    type: string;\n\t  };\n\t}\n\texport interface ContractMethodArg {\n\t  desc?: string;\n\t  /**\n\t   * Catch all for fixed length arrays and tuples\n\t   */\n\t  type: string;\n", "  name: string;\n\t}\n\texport interface CallConfig {\n\t  no_op?: CallConfigValue;\n\t  opt_in?: CallConfigValue;\n\t  close_out?: CallConfigValue;\n\t  update_application?: CallConfigValue;\n\t  delete_application?: CallConfigValue;\n\t}\n\texport interface AppSources {\n", "  approval?: string;\n\t  clear?: string;\n\t}\n\texport interface AbiContract {\n\t  name: string;\n\t  desc?: string;\n\t  methods: ContractMethod1[];\n\t  networks?: {\n\t    [k: string]: {\n\t      appID: number;\n", "    };\n\t  };\n\t}\n\texport interface ContractMethod1 {\n\t  name: string;\n\t  args: ContractMethodArg[];\n\t  desc?: string;\n\t  returns: {\n\t    desc?: string;\n\t    /**\n", "     * Catch all for fixed length arrays and tuples\n\t     */\n\t    type: string;\n\t  };\n\t}\n\t/**\n\t * The schema for global and local storage\n\t */\n\texport interface SchemaSpec {\n\t  global?: Schema;\n", "  local?: Schema;\n\t}\n\texport interface Schema {\n\t  declared?: {\n\t    [k: string]: DeclaredSchemaValueSpec;\n\t  };\n\t  reserved?: {\n\t    [k: string]: ReservedSchemaValueSpec;\n\t  };\n\t}\n", "export interface DeclaredSchemaValueSpec {\n\t  /**\n\t   * The type of the value\n\t   */\n\t  type: \"uint64\" | \"bytes\";\n\t  /**\n\t   * The name of the key\n\t   */\n\t  key: string;\n\t  /**\n", "   * A description of the variable\n\t   */\n\t  descr?: string;\n\t  /**\n\t   * Whether the value is set statically (at create time only) or dynamically\n\t   */\n\t  static?: boolean;\n\t}\n\texport interface ReservedSchemaValueSpec {\n\t  /**\n", "   * The type of the value\n\t   */\n\t  type: \"uint64\" | \"bytes\";\n\t  /**\n\t   * A description of the variable\n\t   */\n\t  descr?: string;\n\t  /**\n\t   * The maximum number of slots to reserve\n\t   */\n", "  max_keys?: number;\n\t  [k: string]: unknown;\n\t}\n\texport interface StateSchemaSpec {\n\t  global: StateSchema;\n\t  local: StateSchema;\n\t}\n\texport interface StateSchema {\n\t  num_uints: number;\n\t  num_byte_slices: number;\n", "}\n"]}
{"filename": "src/schema/load.ts", "chunked_list": ["import * as fs from 'fs'\n\timport { Schema, Validator } from 'jsonschema'\n\timport { boom } from '../util/boom'\n\timport { AlgoAppSpec } from './application'\n\timport appJsonSchema from './application.schema.json'\n\timport contractSchema from './contract.schema.json'\n\texport function load(appJsonPath: string) {\n\t  if (!fs.existsSync(appJsonPath)) boom(`Could not find application.json file at ${appJsonPath}`)\n\t  const validator = new Validator()\n\t  validator.addSchema(contractSchema, '/contract.schema.json')\n", "  const file = JSON.parse(fs.readFileSync(appJsonPath, 'utf-8'))\n\t  const result = validator.validate(file, appJsonSchema as unknown as Schema)\n\t  if (!result.valid) boom(result.toString())\n\t  return file as AlgoAppSpec\n\t}\n"]}
