{"filename": "tests/mocks/handlers.ts", "chunked_list": ["import { rest, PathParams, RestRequest } from 'msw';\n\timport deployments from '../../testdata/deployments.json';\n\timport issues from '../../testdata/issues.json';\n\tconst GITHUB_API = 'https://api.github.com/graphql';\n\tconst logInterceptedRequest = (req: RestRequest<any, PathParams>) =>\n\t  console.log('Mocking call to:', req.url.href);\n\texport const handlers = [\n\t  rest.post(`${GITHUB_API}`, (req, res, ctx) => {\n\t    logInterceptedRequest(req);\n\t    const authorization = req.headers.get('Authorization') || '';\n", "    const content = (() => {\n\t      const requestType = req.headers.get('X-Request-Type') || '';\n\t      if (requestType === 'deployments') return deployments;\n\t      if (requestType === 'issues') return issues;\n\t      console.warn('No request type found for:', requestType);\n\t      return {};\n\t    })();\n\t    if (authorization === 'Bearer fake_t0ken') return res(ctx.status(200), ctx.json(content));\n\t    return res(ctx.status(401), ctx.json({ message: 'Bad credentials used when calling GitHub!' }));\n\t  })\n", "];\n"]}
{"filename": "tests/mocks/index.ts", "chunked_list": ["import { setupServer } from 'msw/node';\n\timport { handlers } from './handlers';\n\texport const mockServer = setupServer(...handlers);\n"]}
{"filename": "tests/unit/queries.test.ts", "chunked_list": ["import test from 'ava';\n\timport { issuesQuery, deploymentsQuery } from '../../src/frameworks/network/queries';\n\tconst owner = 'someorg';\n\tconst repo = 'somerepo';\n\tconst date = '2023-01-01';\n\tconst after = 'asdf1234';\n\ttest('It should get issues with parameters set correctly', (t) => {\n\t  const response = issuesQuery(owner, repo, date);\n\t  const isMatch = response.includes(\n\t    `query: \"repo:${owner}/${repo} type:issue is:closed created:>=${date}`\n", "  );\n\t  t.is(isMatch, true);\n\t});\n\ttest('It should get issues with parameters set correctly, including the `after` argument', (t) => {\n\t  const response = issuesQuery(owner, repo, date, after);\n\t  const isMatch = response.includes(\n\t    `query: \"repo:${owner}/${repo} type:issue is:closed created:>=${date}`\n\t  );\n\t  const isMatchAfter = response.includes(`after: \"${after}\"`);\n\t  t.is(isMatch, true);\n", "  t.is(isMatchAfter, true);\n\t});\n\ttest('It should get deployments with parameters set correctly', (t) => {\n\t  const response = deploymentsQuery(owner, repo, date);\n\t  const isMatch = response.includes(`repository(owner: \"${owner}\", name: \"${repo}\")`);\n\t  const isMatchDate = response.includes(`after: \"${date}\"`);\n\t  t.is(isMatch, true);\n\t  t.is(isMatchDate, true);\n\t});\n"]}
{"filename": "tests/unit/getDeployments.test.ts", "chunked_list": ["import test from 'ava';\n\timport { getDeployments } from '../../src/frameworks/network/getDeployments';\n\t/**\n\t * NEGATIVE TESTS\n\t */\n\ttest('It should throw a GitHubCredentialsError', async (t) => {\n\t  const expected = 'GitHubCredentialsError';\n\t  // @ts-ignore\n\t  const error: any = await t.throwsAsync(\n\t    async () => await getDeployments('someorg', 'somerepo', '')\n", "  );\n\t  t.is(error.name, expected);\n\t});\n"]}
{"filename": "tests/unit/GitHubMetricsService.test.ts", "chunked_list": ["import test from 'ava';\n\timport { GitHubMetricsService } from '../../src/domain/services/GitHubMetricsService';\n\ttest('It should return a basic, zeroed response when getting empty inputs', async (t) => {\n\t  const expected = {\n\t    changeFailureRate: '0.00%',\n\t    deploymentFrequency: '0.00/day',\n\t    leadTimeForChange: '00:00:00:00',\n\t    meanTimeToRepair: '00:00:00:00'\n\t  };\n\t  const metrics = new GitHubMetricsService();\n", "  const response = metrics.getMetrics([], []);\n\t  t.deepEqual(response, expected);\n\t});\n\ttest('It should skip lead time calculations for deployments that lack `deployment.commit.committedDate`', async (t) => {\n\t  const expected = {\n\t    changeFailureRate: '0.00%',\n\t    deploymentFrequency: '0.03/day',\n\t    leadTimeForChange: '00:00:00:00',\n\t    meanTimeToRepair: '00:00:00:00'\n\t  };\n", "  const metrics = new GitHubMetricsService();\n\t  const response = metrics.getMetrics(\n\t    [],\n\t    [\n\t      // @ts-ignore\n\t      {\n\t        state: 'ACTIVE',\n\t        createdAt: '2023-04-20T07:22:14Z',\n\t        updatedAt: '2023-04-20T07:22:27Z'\n\t      }\n", "    ]\n\t  );\n\t  t.deepEqual(response, expected);\n\t});\n\ttest('It should return 0 for an issue lead time if the issue is not closed', async (t) => {\n\t  const expected = {\n\t    changeFailureRate: '0.00%',\n\t    deploymentFrequency: '0.00/day',\n\t    leadTimeForChange: '00:00:00:00',\n\t    meanTimeToRepair: '00:00:00:00'\n", "  };\n\t  const metrics = new GitHubMetricsService();\n\t  const response = metrics.getMetrics(\n\t    [\n\t      // @ts-ignore\n\t      {\n\t        state: 'OPEN',\n\t        createdAt: '2023-04-20T08:28:50Z'\n\t      }\n\t    ],\n", "    []\n\t  );\n\t  t.deepEqual(response, expected);\n\t});\n\ttest('It should calculate mean time to repair for a closed issue', async (t) => {\n\t  const expected = {\n\t    changeFailureRate: '0.00%',\n\t    deploymentFrequency: '0.00/day',\n\t    leadTimeForChange: '00:00:00:00',\n\t    meanTimeToRepair: '00:01:01:28'\n", "  };\n\t  const metrics = new GitHubMetricsService();\n\t  const response = metrics.getMetrics(\n\t    [\n\t      {\n\t        state: 'CLOSED',\n\t        createdAt: '2023-04-20T08:28:32Z',\n\t        closedAt: '2023-04-20T09:30:00Z'\n\t      }\n\t    ],\n", "    []\n\t  );\n\t  t.deepEqual(response, expected);\n\t});\n"]}
{"filename": "tests/unit/getDTO.test.ts", "chunked_list": ["import test from 'ava';\n\timport { getDTO } from '../../src/application/getDTO';\n\tconst fullRepoName = 'someorg/somerepo';\n\tconst [owner, repo] = fullRepoName.split('/');\n\tconst token = 'SOME-fake-t0ken';\n\tconst expected = {\n\t  owner,\n\t  repo,\n\t  token,\n\t  isBadge: false\n", "};\n\ttest('It should get the owner and repo values', (t) => {\n\t  const response = getDTO(\n\t    {\n\t      repo: fullRepoName\n\t    },\n\t    {}\n\t  );\n\t  t.deepEqual(response, {\n\t    owner,\n", "    repo,\n\t    token: '',\n\t    isBadge: false\n\t  });\n\t});\n\ttest('It should get the token from a query string parameter', (t) => {\n\t  const response = getDTO(\n\t    {\n\t      repo: fullRepoName,\n\t      token\n", "    },\n\t    {}\n\t  );\n\t  t.deepEqual(response, expected);\n\t});\n\ttest('It should get the token from an upper-case Authorization header', (t) => {\n\t  const response = getDTO(\n\t    {\n\t      repo: fullRepoName\n\t    },\n", "    {\n\t      Authorization: token\n\t    }\n\t  );\n\t  t.deepEqual(response, expected);\n\t});\n\ttest('It should get the token from an lower-case Authorization header', (t) => {\n\t  const response = getDTO(\n\t    {\n\t      repo: fullRepoName\n", "    },\n\t    {\n\t      authorization: token\n\t    }\n\t  );\n\t  t.deepEqual(response, expected);\n\t});\n\t/**\n\t * NEGATIVE TESTS\n\t */\n", "test('It should throw a MissingQueryStringParamsError if no query string parameters are passed in', (t) => {\n\t  const expected = 'MissingQueryStringParamsError';\n\t  // @ts-ignore\n\t  const error: any = t.throws(() => getDTO());\n\t  t.is(error.name, expected);\n\t});\n\ttest('It should throw a InputValidationError if input is not valid', (t) => {\n\t  const expected = 'InputValidationError';\n\t  // @ts-ignore\n\t  const error: any = t.throws(() => getDTO({ repo: 1 }));\n", "  t.is(error.name, expected);\n\t});\n"]}
{"filename": "tests/unit/checkIfDateIsInRange.test.ts", "chunked_list": ["import test from 'ava';\n\timport { checkIfDateIsInRange } from '../../src/application/checkIfDateIsInRange';\n\tconst getTime = (numberOfDays: number) => {\n\t  const timeNow = Date.now();\n\t  const diff = timeNow - numberOfDays * (24 * 60 * 60 * 1000);\n\t  return new Date(diff).toISOString().substring(0, 10);\n\t};\n\ttest('It should return true for a value within the allowed time period', (t) => {\n\t  const response = checkIfDateIsInRange(getTime(29));\n\t  t.is(response, true);\n", "});\n\ttest('It should return false for a value outside the allowed time period', (t) => {\n\t  const response = checkIfDateIsInRange(getTime(31));\n\t  t.is(response, false);\n\t});\n"]}
{"filename": "tests/unit/filterResponses.test.ts", "chunked_list": ["import test from 'ava';\n\timport {\n\t  filterDeploymentsResponse,\n\t  filterIssuesResponse\n\t} from '../../src/frameworks/filterResponses';\n\timport deployments from '../../testdata/deployments.json';\n\timport issues from '../../testdata/issues.json';\n\ttest('It should return undefined from an invalid issues input', (t) => {\n\t  const response = filterIssuesResponse({});\n\t  t.deepEqual(response, undefined);\n", "});\n\ttest('It should return a filtered and cleaned set of issues', (t) => {\n\t  const expected = [\n\t    {\n\t      closedAt: '2023-04-20T14:49:47Z',\n\t      createdAt: '2023-04-20T08:28:32Z',\n\t      state: 'CLOSED'\n\t    }\n\t  ];\n\t  const response = filterIssuesResponse(issues);\n", "  t.deepEqual(response, expected);\n\t});\n\ttest('It should return undefined from an invalid deployments input', (t) => {\n\t  const response = filterDeploymentsResponse({});\n\t  t.deepEqual(response, undefined);\n\t});\n\ttest('It should return a filtered and cleaned set of deployments', (t) => {\n\t  const expected = [\n\t    {\n\t      commit: {\n", "        committedDate: '2023-04-20T07:21:54Z'\n\t      },\n\t      createdAt: '2023-04-20T07:22:14Z',\n\t      state: 'ACTIVE',\n\t      updatedAt: '2023-04-20T07:22:27Z'\n\t    },\n\t    {\n\t      commit: {\n\t        committedDate: '2023-04-19T18:09:03Z'\n\t      },\n", "      createdAt: '2023-04-19T18:09:23Z',\n\t      state: 'INACTIVE',\n\t      updatedAt: '2023-04-20T07:22:27Z'\n\t    },\n\t    {\n\t      commit: {\n\t        committedDate: '2023-04-19T18:03:41Z'\n\t      },\n\t      createdAt: '2023-04-19T18:04:02Z',\n\t      state: 'ACTIVE',\n", "      updatedAt: '2023-04-19T18:04:11Z'\n\t    }\n\t  ];\n\t  const response = filterDeploymentsResponse(deployments);\n\t  t.deepEqual(response, expected);\n\t});\n\ttest('It should return an empty array if deployments lack `createdAt` field', (t) => {\n\t  const expected: any = [];\n\t  const response = filterDeploymentsResponse({\n\t    data: {\n", "      rateLimit: {\n\t        limit: 5000,\n\t        cost: 1,\n\t        remaining: 4927\n\t      },\n\t      repository: {\n\t        deployments: {\n\t          edges: [\n\t            {\n\t              node: {\n", "                state: 'ACTIVE',\n\t                updatedAt: '2023-04-20T07:22:27Z',\n\t                commit: {\n\t                  committedDate: '2023-04-20T07:21:54Z'\n\t                }\n\t              }\n\t            }\n\t          ]\n\t        }\n\t      }\n", "    }\n\t  });\n\t  t.deepEqual(response, expected);\n\t});\n"]}
{"filename": "tests/unit/GetMetrics.test.ts", "chunked_list": ["import test from 'ava';\n\timport { GetMetricsUsecase } from '../../src/usecases/GetMetricsUsecase';\n\timport { mockServer } from '../mocks';\n\tconst fullRepoName = 'someorg/somerepo';\n\tconst [owner, repo] = fullRepoName.split('/');\n\tconst token = 'fake_t0ken';\n\tconst open = () => mockServer.listen();\n\tconst close = () => {\n\t  mockServer.resetHandlers();\n\t  mockServer.close();\n", "};\n\ttest('It should get metrics in the standard format', async (t) => {\n\t  open();\n\t  const expected = {\n\t    changeFailureRate: '33.33%',\n\t    deploymentFrequency: '0.10/day',\n\t    leadTimeForChange: '00:00:00:20',\n\t    meanTimeToRepair: '00:06:21:15'\n\t  };\n\t  const response = await GetMetricsUsecase({\n", "    owner,\n\t    repo,\n\t    token,\n\t    isBadge: false\n\t  });\n\t  t.deepEqual(response, expected);\n\t  close();\n\t});\n\ttest('It should get metrics in the badge-optimized format', async (t) => {\n\t  open();\n", "  const expected = {\n\t    color: 'black',\n\t    label: 'DORA metrics',\n\t    labelColor: 'blue',\n\t    message: 'CFR: 33.33% | DF: 0.10/day | LTC: 00:00:00:20 | MTTR: 00:06:21:15',\n\t    schemaVersion: 1,\n\t    style: 'for-the-badge'\n\t  };\n\t  const response = await GetMetricsUsecase({\n\t    owner,\n", "    repo,\n\t    token,\n\t    isBadge: true\n\t  });\n\t  t.deepEqual(response, expected);\n\t  close();\n\t});\n\t/**\n\t * NEGATIVE TESTS\n\t */\n", "test('It should throw a MissingTokenError if missing a token', async (t) => {\n\t  const expected = 'MissingTokenError';\n\t  // @ts-ignore\n\t  const error: any = await t.throwsAsync(async () => await GetMetricsUsecase());\n\t  t.is(error.name, expected);\n\t});\n\ttest('It should throw a GitHubCredentialsError if missing credentials', async (t) => {\n\t  const expected = 'GitHubCredentialsError';\n\t  // @ts-ignore\n\t  const error: any = await t.throwsAsync(async () => await GetMetricsUsecase({ token: 'asdf' }));\n", "  t.is(error.name, expected);\n\t});\n"]}
{"filename": "src/application/checkIfDateIsInRange.ts", "chunked_list": ["/**\n\t * @description Checks if a date is within the allowed range of dates (30 days back).\n\t *\n\t * Takes input in the form of `2023-03-19T18:04:02Z`.\n\t */\n\texport function checkIfDateIsInRange(time: string) {\n\t  const date = new Date(time).getTime();\n\t  const now = new Date().getTime();\n\t  const daysBetweenDates = Math.abs(date - now) / (24 * 60 * 60 * 1000);\n\t  const maxPeriodInDays = parseInt(process.env.MAX_PERIOD_IN_DAYS || '30');\n", "  return daysBetweenDates < maxPeriodInDays ? true : false;\n\t}\n"]}
{"filename": "src/application/errors.ts", "chunked_list": ["/**\n\t * @description Used calling GitHub with invalid credentials.\n\t */\n\texport class GitHubCredentialsError extends Error {\n\t  constructor(statusCode: string) {\n\t    super(statusCode);\n\t    this.name = 'GitHubCredentialsError';\n\t    const message = `Bad credentials used when calling GitHub!`;\n\t    this.message = message;\n\t    // @ts-ignore\n", "    this.cause = {\n\t      statusCode: parseInt(statusCode)\n\t    };\n\t  }\n\t}\n\t/**\n\t * @description Used an input validation process fails.\n\t */\n\texport class InputValidationError extends Error {\n\t  constructor() {\n", "    super();\n\t    this.name = 'InputValidationError';\n\t    const message = `Provided value could not be validated!`;\n\t    this.message = message;\n\t    // @ts-ignore\n\t    this.cause = {\n\t      statusCode: 400\n\t    };\n\t  }\n\t}\n", "/**\n\t * @description Used when no GitHub token is present.\n\t */\n\texport class MissingTokenError extends Error {\n\t  constructor() {\n\t    super();\n\t    this.name = 'MissingTokenError';\n\t    const message = `Missing GitHub token!`;\n\t    this.message = message;\n\t    // @ts-ignore\n", "    this.cause = {\n\t      statusCode: 500\n\t    };\n\t  }\n\t}\n\t/**\n\t * @description Used when required query string parameters are missing.\n\t */\n\texport class MissingQueryStringParamsError extends Error {\n\t  constructor() {\n", "    super();\n\t    this.name = 'MissingQueryStringParamsError';\n\t    const message = `Missing required query string parameters!`;\n\t    this.message = message;\n\t    // @ts-ignore\n\t    this.cause = {\n\t      statusCode: 400\n\t    };\n\t  }\n\t}\n"]}
{"filename": "src/application/getDTO.ts", "chunked_list": ["import { InputDTO } from '../interfaces/InputDTO';\n\timport { InputValidationError, MissingQueryStringParamsError } from './errors';\n\t/**\n\t * @description Retrieves the expected input in a well-defined shape.\n\t */\n\texport function getDTO(\n\t  queryStringParameters: Record<string, any>,\n\t  headers: Record<string, any>\n\t): InputDTO {\n\t  if (!queryStringParameters) throw new MissingQueryStringParamsError();\n", "  const fullRepoName = validate(queryStringParameters.repo);\n\t  const [owner, repo] = fullRepoName.split('/');\n\t  const token = getToken(queryStringParameters, headers);\n\t  const isBadge = queryStringParameters['badge'] === 'true' || false;\n\t  return {\n\t    owner,\n\t    repo,\n\t    token,\n\t    isBadge\n\t  };\n", "}\n\t/**\n\t * @description Validates a field to check there is a non-null value and that it's a string.\n\t */\n\tfunction validate(value: string) {\n\t  if (!value || typeof value !== 'string') throw new InputValidationError();\n\t  return value;\n\t}\n\t/**\n\t * @description Check query string parameters or headers for a user-provided GitHub personal access token.\n", " */\n\tfunction getToken(queryStringParameters: Record<string, any>, headers: Record<string, any>) {\n\t  return (\n\t    headers['Authorization'] || headers['authorization'] || queryStringParameters['token'] || ''\n\t  );\n\t}\n"]}
{"filename": "src/domain/services/GitHubMetricsService.ts", "chunked_list": ["import { getDiffInSeconds, prettifyTime } from 'chrono-utils';\n\timport { Deployment } from '../../interfaces/Deployment';\n\timport { Issue } from '../../interfaces/Issue';\n\timport { MetricsResponse } from '../../interfaces/MetricsResponse';\n\t/**\n\t * @description Calculates the DORA metrics from GitHub data.\n\t */\n\texport class GitHubMetricsService {\n\t  /**\n\t   * @description Get the DORA metrics from GitHub issues and deployments.\n", "   */\n\t  public getMetrics(\n\t    issues: Issue[],\n\t    deployments: Deployment[],\n\t    isForBadge = false\n\t  ): MetricsResponse {\n\t    const changeFailureRate = this.calculateChangeFailureRate(issues, deployments);\n\t    const deploymentFrequency = this.calculateDeploymentFrequency(deployments);\n\t    const leadTimeForChange = this.calculateLeadTimeForChange(deployments);\n\t    const meanTimeToRepair = this.calculateMeanTimeToRepair(issues);\n", "    if (isForBadge)\n\t      return {\n\t        schemaVersion: 1,\n\t        label: 'DORA metrics',\n\t        message: `CFR: ${changeFailureRate} | DF: ${deploymentFrequency} | LTC: ${leadTimeForChange} | MTTR: ${meanTimeToRepair}`,\n\t        color: 'black',\n\t        labelColor: 'blue',\n\t        style: 'for-the-badge'\n\t      };\n\t    return {\n", "      changeFailureRate,\n\t      deploymentFrequency,\n\t      leadTimeForChange,\n\t      meanTimeToRepair\n\t    };\n\t  }\n\t  /**\n\t   * HIGH-LEVEL CALCULATION FUNCTIONS\n\t   */\n\t  /**\n", "   * @description Get the change failure rate, calculated from the\n\t   * number of issues divided by the number of deployments, and returned\n\t   * as a 0-100 percent value.\n\t   */\n\t  private calculateChangeFailureRate(issues: Issue[], deployments: Deployment[]): string {\n\t    if (deployments.length === 0) return '0.00%';\n\t    return ((issues.length / deployments.length) * 100).toFixed(2) + '%';\n\t  }\n\t  /**\n\t   * @description Get the deployment frequency, calculated from the\n", "   * average number of deployments in a 30-day period.\n\t   */\n\t  private calculateDeploymentFrequency(deployments: Deployment[]): string {\n\t    const numberOfDays = parseInt(process.env.MAX_PERIOD_IN_DAYS || '30');\n\t    return (deployments.length / numberOfDays).toFixed(2) + '/day';\n\t  }\n\t  /**\n\t   * @description Get the lead time for change, calculated from the\n\t   * median time between a commit being pushed to the deployment being\n\t   * created.\n", "   */\n\t  private calculateLeadTimeForChange(deployments: Deployment[]): string {\n\t    const leadTimes = this.getLeadTimes(deployments) as number[];\n\t    return this.getPrettifiedMedianValue(leadTimes);\n\t  }\n\t  /**\n\t   * @description Get the mean (median) time to repair, calculated from an\n\t   * array of issues.\n\t   *\n\t   */\n", "  private calculateMeanTimeToRepair(issues: Issue[]): string {\n\t    const timeNow = Math.floor(Date.now()).toString();\n\t    const issueTimes = this.getIssueTimes(issues, timeNow);\n\t    return this.getPrettifiedMedianValue(issueTimes);\n\t  }\n\t  /**\n\t   * INTERNAL UTILITY FUNCTIONS\n\t   */\n\t  /**\n\t   * @description Retrieve all lead times from an array of deployments.\n", "   * A lead time is the period of time between commit pushed and it being deployed.\n\t   */\n\t  private getLeadTimes(deployments: Deployment[]) {\n\t    return deployments\n\t      .map((deployment: Deployment) => {\n\t        if (!deployment?.commit?.committedDate) return;\n\t        const timeCommitted = new Date(deployment.commit.committedDate).getTime();\n\t        const timeDeployed = new Date(deployment.createdAt).getTime();\n\t        return (timeDeployed - timeCommitted) / 1000; // Convert to full seconds\n\t      })\n", "      .filter((leadTime: number | void) => leadTime);\n\t  }\n\t  /**\n\t   * @description Retrieve all issue times from an array of issues.\n\t   */\n\t  private getIssueTimes(issues: Issue[], timeNow: string) {\n\t    return issues.map((issue: Issue) => {\n\t      if (issue.state !== 'CLOSED') return 0;\n\t      const createdAt = new Date(issue.createdAt).getTime().toString();\n\t      const closedAt = issue.closedAt ? new Date(issue.closedAt).getTime().toString() : timeNow;\n", "      return getDiffInSeconds(createdAt, closedAt);\n\t    });\n\t  }\n\t  /**\n\t   * @description Get the median value from an array of values,\n\t   * in a prettified format, `DD:HH:MM:SS`.\n\t   */\n\t  private getPrettifiedMedianValue(array: number[]) {\n\t    const midpoint = Math.floor(array.length / 2);\n\t    const sorted = array.sort((a: number, b: number) => a - b);\n", "    return prettifyTime(sorted[midpoint] || 0);\n\t  }\n\t}\n"]}
{"filename": "src/infrastructure/adapters/GetMetrics.ts", "chunked_list": ["import { APIGatewayEvent } from 'aws-lambda';\n\timport { GetMetricsUsecase } from '../../usecases/GetMetricsUsecase';\n\timport { getDTO } from '../../application/getDTO';\n\timport { end } from '../../frameworks/end';\n\t/**\n\t * @description The AWS Lambda event handler.\n\t */\n\texport const handler = async (event: APIGatewayEvent) => {\n\t  try {\n\t    const input = getDTO(\n", "      event?.['queryStringParameters'] as Record<string, any>,\n\t      event?.['headers'] as Record<string, any>\n\t    );\n\t    const result = await GetMetricsUsecase(input);\n\t    return end(result);\n\t  } catch (error: any) {\n\t    const statusCode: number = error?.['cause']?.['statusCode'] || 400;\n\t    const message: string = error.message;\n\t    return end(message, statusCode);\n\t  }\n", "};\n"]}
{"filename": "src/interfaces/InputDTO.ts", "chunked_list": ["/**\n\t * @description The input data transfer object to use in our business logic.\n\t */\n\texport type InputDTO = {\n\t  /**\n\t   * The owner of the repo.\n\t   * @example microsoft\n\t   * @example facebook\n\t   */\n\t  owner: string;\n", "  /**\n\t   * The repository name.\n\t   * @example playwright\n\t   * @example react\n\t   */\n\t  repo: string;\n\t  /**\n\t   * An optional GitHub personal access token\n\t   * that may be passed in. If it's not passed in\n\t   * explicitly, this will be an empty string.\n", "   */\n\t  token: string;\n\t  /**\n\t   * Is this response meant to be used when\n\t   * generating a `shields.io` badge?\n\t   * @see https://shields.io/endpoint\n\t   */\n\t  isBadge: boolean;\n\t};\n"]}
{"filename": "src/interfaces/Issue.ts", "chunked_list": ["/**\n\t * @description Cleaned GitHub Issue response.\n\t */\n\texport type Issue = {\n\t  state: IssueState;\n\t  /**\n\t   * Date in the format `2023-04-20T08:28:50Z`;\n\t   */\n\t  createdAt: string;\n\t  closedAt: string | null;\n", "};\n\ttype IssueState = 'OPEN' | 'CLOSED';\n"]}
{"filename": "src/interfaces/MetricsResponse.ts", "chunked_list": ["/**\n\t * @description The returned output metrics reponse.\n\t *\n\t * @see https://shields.io/endpoint for the badge-optimized response\n\t */\n\texport type MetricsResponse =\n\t  | {\n\t      schemaVersion: 1;\n\t      label: string;\n\t      message: string;\n", "      color: string;\n\t      labelColor: string;\n\t      style: string;\n\t    }\n\t  | {\n\t      changeFailureRate: string;\n\t      deploymentFrequency: string;\n\t      leadTimeForChange: string;\n\t      meanTimeToRepair: string;\n\t    };\n"]}
{"filename": "src/interfaces/Deployment.ts", "chunked_list": ["/**\n\t * @description Cleaned Deployment response from GitHub.\n\t */\n\texport type Deployment = {\n\t  state: DeploymentState;\n\t  /**\n\t   * Date in the format `2023-04-20T07:22:14Z`;\n\t   */\n\t  createdAt: string;\n\t  /**\n", "   * Date in the format `2023-04-20T07:22:14Z`;\n\t   */\n\t  updatedAt: string;\n\t  commit: DeploymentCommit;\n\t};\n\ttype DeploymentState = 'ACTIVE' | 'INACTIVE';\n\ttype DeploymentCommit = {\n\t  /**\n\t   * Date in the format `2023-04-20T07:22:14Z`;\n\t   */\n", "  committedDate: string;\n\t};\n"]}
{"filename": "src/frameworks/filterResponses.ts", "chunked_list": ["import { Deployment } from '../interfaces/Deployment';\n\timport { Issue } from '../interfaces/Issue';\n\timport { checkIfDateIsInRange } from '../application/checkIfDateIsInRange';\n\t/**\n\t * @description Filter out issues in the expected format.\n\t */\n\texport function filterIssuesResponse(response: any): Issue[] | void {\n\t  const nodes: Record<string, any>[] = response?.['data']?.['search']?.['edges'];\n\t  if (!nodes) return;\n\t  return getCleanedInnerNodes(nodes) as unknown as Issue[];\n", "}\n\t/**\n\t * @description Filter out deployments in the expected format.\n\t */\n\texport function filterDeploymentsResponse(response: any): Deployment[] | void {\n\t  const nodes: Record<string, any>[] =\n\t    response?.['data']?.['repository']?.['deployments']?.['edges'];\n\t  if (!nodes) return;\n\t  return getCleanedInnerNodes(nodes) as unknown as Deployment[];\n\t}\n", "/**\n\t * @description Push cleaned inner nodes.\n\t */\n\tfunction getCleanedInnerNodes(nodes: Record<string, any>[]) {\n\t  return Object.values(nodes)\n\t    .map((node: Record<string, any>) => {\n\t      const createdAt = node?.node?.createdAt || 0;\n\t      // @ts-ignore\n\t      if (checkIfDateIsInRange(createdAt)) return node.node; // Only add any events with a set recency (default: 30 days)\n\t    })\n", "    .filter((item: Deployment | Issue) => item);\n\t}\n"]}
{"filename": "src/frameworks/end.ts", "chunked_list": ["/**\n\t * @description Ends the Lambda request in the appropriate way.\n\t */\n\texport function end(message: string | Record<string, any>, statusCode = 200) {\n\t  return {\n\t    statusCode,\n\t    body: JSON.stringify(message),\n\t    headers: {\n\t      'Access-Control-Allow-Origin': '*',\n\t      'Access-Control-Allow-Credentials': true\n", "    }\n\t  };\n\t}\n"]}
{"filename": "src/frameworks/network/getDeployments.ts", "chunked_list": ["import { fetch } from 'cross-fetch';\n\timport { Deployment } from '../../interfaces/Deployment';\n\timport { GitHubCredentialsError } from '../../application/errors';\n\timport { deploymentsQuery } from './queries';\n\timport { filterDeploymentsResponse } from '../filterResponses';\n\tconst GITHUB_API = 'https://api.github.com/graphql';\n\t/**\n\t * @description Get deployments from GitHub.\n\t */\n\texport async function getDeployments(\n", "  repoOwner: string,\n\t  repoName: string,\n\t  token: string,\n\t  cursor?: string,\n\t  prevLoopDeployments?: Deployment[]\n\t): Promise<Deployment[]> {\n\t  const response = await fetch(GITHUB_API, {\n\t    body: JSON.stringify({ query: deploymentsQuery(repoOwner, repoName, cursor) }),\n\t    method: 'POST',\n\t    headers: {\n", "      Authorization: `Bearer ${token.replace('Bearer ', '')}`,\n\t      Accept: 'application/vnd.github.v3+json',\n\t      'Content-Type': 'application/json',\n\t      'X-Request-Type': 'deployments'\n\t    }\n\t  }).then((res: any) => {\n\t    if (res.status === 200) return res.json();\n\t    if (res.status === 401 || res.status === 403) throw new GitHubCredentialsError(`${res.status}`);\n\t  });\n\t  const filteredDeployments = filterDeploymentsResponse(response) || [];\n", "  const allDeployments = prevLoopDeployments\n\t    ? [...filteredDeployments, ...prevLoopDeployments]\n\t    : filteredDeployments;\n\t  const hasNextPage =\n\t    response?.['data']?.['repository']?.['deployments']?.['pageInfo']?.['hasNextPage'];\n\t  const endCursor =\n\t    response?.['data']?.['repository']?.['deployments']?.['pageInfo']?.['endCursor'];\n\t  /* istanbul ignore next */\n\t  if (hasNextPage)\n\t    return await getDeployments(repoOwner, repoName, token, endCursor, allDeployments);\n", "  return allDeployments;\n\t}\n"]}
{"filename": "src/frameworks/network/queries.ts", "chunked_list": ["/**\n\t * @description Query that will get the issues for a given repository after the provided date.\n\t */\n\texport const issuesQuery = (owner: string, name: string, date: string, after?: string) => {\n\t  const query = `query {\n\t\t\trateLimit {\n\t\t\t\tlimit\n\t\t\t\tcost\n\t\t\t\tremaining\n\t\t\t}\n", "\t\tsearch(\n\t\t\t\tquery: \"repo:REPO type:issue is:closed created:>=DATE sort:created-desc\"\n\t\t\t\ttype: ISSUE\n\t\t\t\tlast: 100\n\t\t\t\tafter: CURSOR\n\t\t\t) {\n\t\t\t\tpageInfo {\n\t\t\t\t\thasNextPage\n\t\t\t\t\tendCursor\n\t\t\t\t}\n", "\t\t\tedges {\n\t\t\t\t\tnode {\n\t\t\t\t\t\t... on Issue {\n\t\t\t\t\t\t\tstate\n\t\t\t\t\t\t\tcreatedAt\n\t\t\t\t\t\t\tclosedAt\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n", "\t}\n\t\t`;\n\t  // Because of no string interpolation (...!?), let's do this manually\n\t  const updatedQuery = query\n\t    .replace('repo:REPO', `repo:${owner}/${name}`)\n\t    .replace('>=DATE', `>=${date}`)\n\t    .replace('after: CURSOR', after ? `after: \"${after}\"` : '');\n\t  return updatedQuery;\n\t};\n\t/**\n", " * @description Query that will get deployments for a given repositor in batches of 100 at a time.\n\t */\n\texport const deploymentsQuery = (owner: string, name: string, after?: string) => {\n\t  const query = `query {\n\t\t\trateLimit {\n\t\t\t\tlimit\n\t\t\t\tcost\n\t\t\t\tremaining\n\t\t\t}\n\t\t\trepository(owner: OWNER, name: NAME) {\n", "\t\t\tdeployments(last: 100, after: CURSOR, environments: [\"prd\", \"prod\", \"production\", \"live\"], orderBy: { field: CREATED_AT, direction: DESC }) {\n\t\t\t\t\tpageInfo {\n\t\t\t\t\t\thasNextPage\n\t\t\t\t\t\tendCursor\n\t\t\t\t\t}\n\t\t\t\t\tedges {\n\t\t\t\t\t\tnode {\n\t\t\t\t\t\t\tstate\n\t\t\t\t\t\t\tcreatedAt\n\t\t\t\t\t\t\tupdatedAt\n", "\t\t\t\t\t\tcommit {\n\t\t\t\t\t\t\t\tcommittedDate\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t`;\n\t  // In order to follow the same convention as with the other query, just do regular string replacements instead of variables\n", "  const updatedQuery = query\n\t    .replace('owner: OWNER', `owner: \"${owner}\"`)\n\t    .replace('name: NAME', `name: \"${name}\"`)\n\t    .replace('after: CURSOR, ', after ? `after: \"${after}\", ` : '');\n\t  return updatedQuery;\n\t};\n"]}
{"filename": "src/frameworks/network/getDataFromGitHub.ts", "chunked_list": ["import { getIssues } from './getIssues';\n\timport { getDeployments } from './getDeployments';\n\t/**\n\t * @description Gets and wrangles several GitHub requests into one object response.\n\t */\n\texport async function getDataFromGitHub(repoOwner: string, repoName: string, token: string) {\n\t  const issues = await getIssues(repoOwner, repoName, token);\n\t  const deployments = await getDeployments(repoOwner, repoName, token);\n\t  return {\n\t    issues,\n", "    deployments\n\t  };\n\t}\n"]}
{"filename": "src/frameworks/network/getIssues.ts", "chunked_list": ["import { fetch } from 'cross-fetch';\n\timport { getMaxTimestampFromDate } from 'chrono-utils';\n\timport { Issue } from '../../interfaces/Issue';\n\timport { GitHubCredentialsError } from '../../application/errors';\n\timport { issuesQuery } from './queries';\n\timport { filterIssuesResponse } from '../filterResponses';\n\tconst GITHUB_API = 'https://api.github.com/graphql';\n\t/**\n\t * @description Get issues from GitHub.\n\t */\n", "export async function getIssues(\n\t  repoOwner: string,\n\t  repoName: string,\n\t  token: string,\n\t  cursor?: string,\n\t  prevLoopIssues?: Issue[]\n\t): Promise<Issue[]> {\n\t  const maxPeriodInDays = parseInt(process.env.MAX_PERIOD_IN_DAYS || '30');\n\t  // Get the date from 30 days ago in the format `YYYY-MM-DD`\n\t  const date = new Date(parseInt(`${getMaxTimestampFromDate(maxPeriodInDays, 0)}000`))\n", "    .toISOString()\n\t    .substring(0, 10);\n\t  const response = await fetch(GITHUB_API, {\n\t    body: JSON.stringify({ query: issuesQuery(repoOwner, repoName, date, cursor) }),\n\t    method: 'POST',\n\t    headers: {\n\t      Authorization: `Bearer ${token.replace('Bearer ', '')}`,\n\t      Accept: 'application/vnd.github.v3+json',\n\t      'Content-Type': 'application/json',\n\t      'X-Request-Type': 'issues'\n", "    }\n\t  }).then((res: any) => {\n\t    if (res.status === 200) return res.json();\n\t    if (res.status === 401 || res.status === 403) throw new GitHubCredentialsError(`${res.status}`);\n\t  });\n\t  const filteredIssues = filterIssuesResponse(response) || [];\n\t  const allIssues = prevLoopIssues ? [...filteredIssues, ...prevLoopIssues] : filteredIssues;\n\t  const hasNextPage = response?.['data']?.['search']?.['pageInfo']?.['hasNextPage'];\n\t  const endCursor = response?.['data']?.['search']?.['pageInfo']?.['endCursor'];\n\t  /* istanbul ignore next */\n", "  if (hasNextPage) return await getIssues(repoOwner, repoName, token, endCursor, allIssues);\n\t  return allIssues;\n\t}\n"]}
{"filename": "src/usecases/GetMetricsUsecase.ts", "chunked_list": ["import { GitHubMetricsService } from '../domain/services/GitHubMetricsService';\n\timport { InputDTO } from '../interfaces/InputDTO';\n\timport { getDataFromGitHub } from '../frameworks/network/getDataFromGitHub';\n\timport { MissingTokenError } from '../application/errors';\n\t/**\n\t * @description Controls the business logic for getting metrics.\n\t */\n\texport async function GetMetricsUsecase(input: InputDTO) {\n\t  const token = input?.token || process.env.GH_PAT || null;\n\t  if (!token) throw new MissingTokenError();\n", "  const { owner, repo, isBadge } = input;\n\t  const data = await getDataFromGitHub(owner, repo, token);\n\t  const { issues, deployments } = data;\n\t  const metricsService = new GitHubMetricsService();\n\t  return metricsService.getMetrics(issues, deployments, isBadge);\n\t}\n"]}
