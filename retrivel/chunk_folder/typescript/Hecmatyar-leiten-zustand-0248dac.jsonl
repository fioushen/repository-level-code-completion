{"filename": "src/index.ts", "chunked_list": ["export * from \"./helpers\";\n\texport * from \"./interfaces/IContentLoading\";\n\texport * from \"./store/contextStore\";\n\texport * from \"./store/resettableStore\";\n"]}
{"filename": "src/interfaces/dotNestedKeys.ts", "chunked_list": ["type DotPrefix<T extends string> = T extends \"\" ? \"\" : `.${T}`;\n\texport type DotNestedKeys<T> = (\n\t  T extends object\n\t    ? T extends Array<any>\n\t      ? \"\"\n\t      :\n\t          | {\n\t              [K in Exclude<keyof T, symbol>]: `${K}${DotPrefix<\n\t                DotNestedKeys<T[K]>\n\t              >}`;\n", "            }[Exclude<keyof T, symbol>]\n\t          | keyof T\n\t    : \"\"\n\t) extends infer D\n\t  ? Extract<D, string>\n\t  : never;\n\texport type DotNestedValue<\n\t  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t  O extends Record<string, any>,\n\t  Path extends string\n", "> = Path extends `${infer Head}.${infer Tail}`\n\t  ? DotNestedValue<O[Head], Tail>\n\t  : O[Path];\n\texport type ValueOf<T> = T extends Record<infer _K, infer V> ? V : never;\n"]}
{"filename": "src/interfaces/IContentLoading.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-explicit-any */\n\texport type ILoadingStatus =\n\t  | \"init\"\n\t  | \"loading\"\n\t  | \"loaded\"\n\t  | \"waiting\"\n\t  | \"progress\"\n\t  | \"error\";\n\texport interface IContentLoading<Content, Payload = undefined> {\n\t  content: Content | null;\n", "  status: ILoadingStatus;\n\t  error?: any;\n\t  payload?: Payload | null;\n\t  requestId?: string;\n\t}\n\texport const initialContentLoading = <Content, Payload>(\n\t  value: Content | null,\n\t  initialStatus?: ILoadingStatus\n\t): IContentLoading<Content, Payload> => ({\n\t  content: value,\n", "  status: initialStatus || \"loading\",\n\t  error: undefined,\n\t  payload: undefined,\n\t  requestId: undefined,\n\t});\n\texport type ILeitenLoading<Payload, Result> = Omit<\n\t  IContentLoading<Result, Payload>,\n\t  \"content\"\n\t>;\n\texport const initialLeitenLoading = <Payload, Result>(\n", "  initialStatus?: ILoadingStatus\n\t): ILeitenLoading<Payload, Result> => ({\n\t  status: initialStatus || \"init\",\n\t  error: undefined,\n\t  payload: undefined,\n\t  requestId: undefined,\n\t});\n"]}
{"filename": "src/helpers/leitenPrimitive.ts", "chunked_list": ["import { produce } from \"immer\";\n\timport { get, set } from \"lodash-es\";\n\timport { StoreApi } from \"zustand\";\n\timport { DotNestedKeys, DotNestedValue } from \"../interfaces/dotNestedKeys\";\n\tinterface ILeitenPrimitiveEffects<VALUE, State> {\n\t  patchEffect?: (value: VALUE) => Partial<State>;\n\t  sideEffect?: (value: { prev: VALUE; next: VALUE }) => void;\n\t}\n\texport type ILeitenPrimitive<VALUE> = {\n\t  set: (value: VALUE) => void;\n", "  get: () => VALUE;\n\t  clear: () => void;\n\t};\n\texport const leitenPrimitive = <\n\t  Store extends object,\n\t  P extends DotNestedKeys<Store>\n\t>(\n\t  store: StoreApi<Store>,\n\t  path: P extends string ? P : never,\n\t  effects?: ILeitenPrimitiveEffects<DotNestedValue<Store, P>, Store>\n", "): ILeitenPrimitive<DotNestedValue<Store, P>> => {\n\t  type VALUE = DotNestedValue<Store, P>;\n\t  const initialValue = get(store.getState(), path, \"_empty\") as VALUE;\n\t  if (initialValue === \"_empty\") {\n\t    throw new Error(\"[leitenPrimitive] The defined path does not exist\");\n\t  }\n\t  const getState = (): VALUE => {\n\t    const value = get(store.getState(), path, \"_empty\") as VALUE | \"_empty\";\n\t    return value !== \"_empty\" ? value : initialValue;\n\t  };\n", "  const setState = (next: VALUE) => {\n\t    const prev = getState();\n\t    const draftState = produce(store.getState(), (draft) => {\n\t      set(draft, path, next);\n\t    });\n\t    const nextState = effects?.patchEffect\n\t      ? { ...draftState, ...effects.patchEffect(next) }\n\t      : draftState;\n\t    store.setState(nextState);\n\t    effects?.sideEffect?.({ prev, next });\n", "  };\n\t  const clear = () => {\n\t    const nextState = produce(store.getState(), (draft) => {\n\t      set(draft, path, initialValue);\n\t    });\n\t    store.setState(nextState);\n\t  };\n\t  return { set: setState, get: getState, clear };\n\t};\n"]}
{"filename": "src/helpers/leitenNormalizedList.ts", "chunked_list": ["import { produce } from \"immer\";\n\timport { get, set } from \"lodash-es\";\n\timport { StoreApi } from \"zustand/esm\";\n\timport { DotNestedKeys, DotNestedValue } from \"../interfaces/dotNestedKeys\";\n\timport { ILeitenList } from \"./leitenList\";\n\t/* eslint-disable @typescript-eslint/no-explicit-any */\n\ttype NormalizedType<ITEM> = Record<string, ITEM>;\n\ttype ValueOf<T> = T extends Record<infer _K, infer V> ? V : never;\n\texport const leitenNormalizedList = <\n\t  Store extends object,\n", "  P extends DotNestedKeys<Store>\n\t>(\n\t  store: StoreApi<Store>,\n\t  path: P extends string\n\t    ? DotNestedValue<Store, P> extends Record<string, unknown>\n\t      ? P\n\t      : never\n\t    : never,\n\t  params: {\n\t    compare?: (\n", "      left: ValueOf<DotNestedValue<Store, P>>,\n\t      right: ValueOf<DotNestedValue<Store, P>>\n\t    ) => boolean;\n\t    sideEffect?: () => void;\n\t    patchEffect?: (\n\t      items: NormalizedType<ValueOf<DotNestedValue<Store, P>>>\n\t    ) => Partial<Store>;\n\t    getKey: (item: ValueOf<DotNestedValue<Store, P>>) => string;\n\t  }\n\t): ILeitenList<ValueOf<DotNestedValue<Store, P>>> & {\n", "  removeByKey: (value: string | string[]) => void;\n\t  get: () => NormalizedType<ValueOf<DotNestedValue<Store, P>>>;\n\t} => {\n\t  type ITEM = ValueOf<DotNestedValue<Store, P>>;\n\t  const initialValue = get(\n\t    store.getState(),\n\t    path,\n\t    \"_empty\"\n\t  ) as NormalizedType<ITEM>;\n\t  if ((initialValue as any) === \"_empty\" || typeof initialValue !== \"object\") {\n", "    throw new Error(\n\t      \"[leitenNormalizedList] The defined path does not match the required structure\"\n\t    );\n\t  }\n\t  const compare = params?.compare || defaultCompareList;\n\t  const setState = (value: NormalizedType<ITEM>) => {\n\t    const draftState = produce(store.getState(), (draft) => {\n\t      set(draft, path, value);\n\t    });\n\t    const nextState = params?.patchEffect\n", "      ? { ...draftState, ...params.patchEffect(value) }\n\t      : draftState;\n\t    store.setState(nextState);\n\t    params?.sideEffect?.();\n\t  };\n\t  const _get = (): NormalizedType<ITEM> => {\n\t    const list = get(store.getState(), path, \"_empty\") as\n\t      | NormalizedType<ITEM>\n\t      | \"_empty\";\n\t    if (list !== \"_empty\") {\n", "      return list;\n\t    } else {\n\t      return initialValue;\n\t    }\n\t  };\n\t  const getMap = (items: ITEM[]): NormalizedType<ITEM> => {\n\t    return items.reduce<NormalizedType<ITEM>>((acc, val) => {\n\t      const key = params.getKey(val);\n\t      acc[key] = val;\n\t      return acc;\n", "    }, {});\n\t  };\n\t  const _set = (items: ITEM[]) => {\n\t    setState(getMap(items));\n\t  };\n\t  const add = (items: ITEM | ITEM[]) => {\n\t    setState({\n\t      ..._get(),\n\t      ...getMap(Array.isArray(items) ? items : [items]),\n\t    });\n", "  };\n\t  const clear = () => {\n\t    const nextState = produce(store.getState(), (draft) => {\n\t      set(draft, path, initialValue);\n\t    });\n\t    store.setState(nextState);\n\t  };\n\t  const removeByKey = (removeKeys: string[] | string) => {\n\t    const acc: NormalizedType<ITEM> = {};\n\t    for (const [key, item] of Object.entries(_get())) {\n", "      if (\n\t        Array.isArray(removeKeys)\n\t          ? !removeKeys.includes(key)\n\t          : removeKeys !== key\n\t      ) {\n\t        acc[key] = item;\n\t      }\n\t    }\n\t    setState(acc);\n\t  };\n", "  const remove = (remove: ITEM[] | ITEM) => {\n\t    const acc: NormalizedType<ITEM> = {};\n\t    for (const [key, item] of Object.entries(_get())) {\n\t      if (\n\t        Array.isArray(remove)\n\t          ? !remove.some((i) => compare(item, i))\n\t          : !compare(item, remove)\n\t      ) {\n\t        acc[key] = item;\n\t      }\n", "    }\n\t    setState(acc);\n\t  };\n\t  const filter = (validate: (item: ITEM) => boolean) => {\n\t    setState(\n\t      Object.fromEntries(\n\t        Object.entries(_get()).filter(([_, item]) => validate(item))\n\t      )\n\t    );\n\t  };\n", "  const update = (items: ITEM[] | ITEM) => {\n\t    const updated = getMap(Array.isArray(items) ? items : [items]);\n\t    setState({ ..._get(), ...updated });\n\t  };\n\t  const toggle = (item: ITEM) => {\n\t    const key = params.getKey(item);\n\t    const isChecked = key in _get();\n\t    if (isChecked) {\n\t      removeByKey(key);\n\t    } else {\n", "      add(item);\n\t    }\n\t  };\n\t  return {\n\t    set: _set,\n\t    get: _get,\n\t    clear,\n\t    toggle,\n\t    update,\n\t    filter,\n", "    remove,\n\t    add,\n\t    removeByKey,\n\t  };\n\t};\n\texport const defaultCompareList = <ITEM>(left: ITEM, right: ITEM): boolean =>\n\t  left === right;\n"]}
{"filename": "src/helpers/leitenList.ts", "chunked_list": ["import { produce } from \"immer\";\n\timport { get, isArray, set } from \"lodash-es\";\n\timport { StoreApi } from \"zustand/esm\";\n\timport { DotNestedKeys, DotNestedValue } from \"../interfaces/dotNestedKeys\";\n\timport { defaultCompareList } from \"./leitenNormalizedList\";\n\t/* eslint-disable @typescript-eslint/no-explicit-any */\n\texport type ILeitenList<ITEM> = {\n\t  set: (items: ITEM[]) => void;\n\t  add: (items: ITEM[] | ITEM) => void;\n\t  remove: (items: ITEM[] | ITEM) => void;\n", "  toggle: (item: ITEM) => void;\n\t  update: (item: ITEM[] | ITEM) => void;\n\t  clear: () => void;\n\t  filter: (validate: (item: ITEM) => boolean) => void;\n\t};\n\ttype ArrayElement<ArrType> = ArrType extends readonly (infer ElementType)[]\n\t  ? ElementType\n\t  : never;\n\texport interface ILeitenListEffects<ITEM, State> {\n\t  compare?: (left: ITEM, right: ITEM) => boolean;\n", "  sideEffect?: () => void;\n\t  patchEffect?: (items: ITEM[]) => Partial<State>;\n\t}\n\texport const leitenList = <\n\t  Store extends object,\n\t  P extends DotNestedKeys<Store>\n\t>(\n\t  store: StoreApi<Store>,\n\t  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t  path: P extends string\n", "    ? DotNestedValue<Store, P> extends Array<any> | null\n\t      ? P\n\t      : never\n\t    : never,\n\t  params?: ILeitenListEffects<ArrayElement<DotNestedValue<Store, P>>, Store>\n\t): ILeitenList<ArrayElement<DotNestedValue<Store, P>>> & {\n\t  get: () => ArrayElement<DotNestedValue<Store, P>>[];\n\t} => {\n\t  type ITEM = ArrayElement<DotNestedValue<Store, P>>;\n\t  const initialValue = get(store.getState(), path, \"_empty\") as ITEM[];\n", "  if ((initialValue as any) === \"_empty\") {\n\t    throw new Error(\n\t      \"[leitenList] The defined path does not match the required structure\"\n\t    );\n\t  }\n\t  const compare = params?.compare || defaultCompareList;\n\t  const _set = (value: ITEM[]) => {\n\t    const draftState = produce(store.getState(), (draft) => {\n\t      set(draft, path, value);\n\t    });\n", "    const nextState = params?.patchEffect\n\t      ? { ...draftState, ...params.patchEffect(value) }\n\t      : draftState;\n\t    store.setState(nextState);\n\t    params?.sideEffect?.();\n\t  };\n\t  const _get = (): ITEM[] => {\n\t    const array = get(store.getState(), path, initialValue);\n\t    if (isArray(array)) {\n\t      return array;\n", "    } else {\n\t      return [];\n\t    }\n\t  };\n\t  const add = (items: ITEM[] | ITEM) => {\n\t    if (Array.isArray(items)) {\n\t      const values = items.filter((existing) =>\n\t        _get().every((item) => !compare(existing, item))\n\t      );\n\t      _set([..._get(), ...values]);\n", "    } else {\n\t      const values = _get().every((item) => !compare(items, item))\n\t        ? [items]\n\t        : [];\n\t      _set([..._get(), ...values]);\n\t    }\n\t  };\n\t  const clear = () => {\n\t    const nextState = produce(store.getState(), (draft) => {\n\t      set(draft, path, initialValue || []);\n", "    });\n\t    store.setState(nextState);\n\t  };\n\t  const remove = (items: ITEM[] | ITEM) => {\n\t    if (Array.isArray(items)) {\n\t      _set(\n\t        _get().filter(\n\t          (item) => !items.find((removeItem) => compare(item, removeItem))\n\t        )\n\t      );\n", "    } else {\n\t      _set(_get().filter((item) => !compare(item, items)));\n\t    }\n\t  };\n\t  const filter = (validate: (item: ITEM) => boolean) => {\n\t    _set(_get().filter(validate));\n\t  };\n\t  const update = (items: ITEM[] | ITEM) => {\n\t    if (Array.isArray(items)) {\n\t      _set(\n", "        _get().map((existing) => {\n\t          const item = items.find((item) => compare(existing, item));\n\t          return item || existing;\n\t        })\n\t      );\n\t    } else {\n\t      _set(\n\t        _get().map((existing) => (compare(existing, items) ? items : existing))\n\t      );\n\t    }\n", "  };\n\t  const toggle = (item: ITEM) => {\n\t    const exist = !!_get().find((_item) => compare(item, _item));\n\t    if (exist) {\n\t      remove(item);\n\t    } else {\n\t      add(item);\n\t    }\n\t  };\n\t  return { set: _set, get: _get, clear, toggle, update, filter, remove, add };\n", "};\n"]}
{"filename": "src/helpers/leitenFilterRequest.ts", "chunked_list": ["import { cloneDeep, get, isEqual } from \"lodash-es\";\n\timport { StoreApi, UseBoundStore } from \"zustand\";\n\timport { DotNestedKeys, DotNestedValue } from \"../interfaces/dotNestedKeys\";\n\timport { ILeitenPrimitive, leitenPrimitive } from \"./leitenPrimitive\";\n\timport {\n\t  ILeitenRecord,\n\t  ILeitenRecordEffects,\n\t  leitenRecord,\n\t} from \"./leitenRecord\";\n\timport {\n", "  IExtraArgument,\n\t  ILeitenRequestOptions,\n\t  leitenRequest,\n\t  resettableStoreSubscription,\n\t} from \"./leitenRequest\";\n\t/* eslint-disable @typescript-eslint/no-explicit-any */\n\ttype RecordFilter<T> = {\n\t  (initialObject?: T): IObjectDifferent[];\n\t} & ILeitenRecord<T>;\n\ttype PrimitiveFilter<Y> = {\n", "  (initialObject?: Y): IObjectDifferent[];\n\t} & ILeitenPrimitive<Y>;\n\texport const leitenFilterRequest = <\n\t  Store extends object,\n\t  Path extends DotNestedKeys<Store>,\n\t  Result extends DotNestedValue<Store, Path> | null | void\n\t>(\n\t  store: UseBoundStore<StoreApi<Store>>,\n\t  path: Path extends string\n\t    ? Result extends void\n", "      ? Path\n\t      : DotNestedValue<Store, Path> extends Result | null\n\t      ? Path\n\t      : never\n\t    : never,\n\t  request: (params: void, extraArgument?: IExtraArgument) => Promise<Result>,\n\t  options?: ILeitenRequestOptions<void, Result>\n\t) => {\n\t  const leiten = leitenRequest(store, path, request, {\n\t    ...options,\n", "    action: (args) => {\n\t      updatePrevFilters();\n\t      return options?.action?.(args);\n\t    },\n\t  });\n\t  const filters: Record<string, ILeitenRecord<any> | ILeitenPrimitive<any>> =\n\t    {};\n\t  let prevFilters: Record<string, any> = {};\n\t  const initialFilters: Record<string, any> = {};\n\t  const createFilter = <Path extends DotNestedKeys<Store>>(\n", "    path: Path extends string ? Path : never,\n\t    options?: ILeitenRecordEffects<DotNestedValue<Store, Path>, Store>\n\t  ): DotNestedValue<Store, Path> extends object\n\t    ? RecordFilter<DotNestedValue<Store, Path>>\n\t    : PrimitiveFilter<DotNestedValue<Store, Path>> => {\n\t    type Response = DotNestedValue<Store, Path> extends object\n\t      ? RecordFilter<DotNestedValue<Store, Path>>\n\t      : PrimitiveFilter<DotNestedValue<Store, Path>>;\n\t    const initial = get(store.getState(), path, undefined);\n\t    function hook(\n", "      initialObject?: DotNestedValue<Store, Path>\n\t    ): IObjectDifferent[] {\n\t      return store((state) =>\n\t        getObjectDifference(\n\t          get(state, path, initialObject || initial),\n\t          initialObject || initial\n\t        )\n\t      );\n\t    }\n\t    const controller =\n", "      typeof initial !== \"object\" ? leitenPrimitive : leitenRecord;\n\t    const record = controller(store, path, {\n\t      sideEffect: (side) => {\n\t        options?.sideEffect?.(side);\n\t        action(path).then();\n\t      },\n\t      patchEffect: options?.patchEffect,\n\t    });\n\t    prevFilters[path] = record.get();\n\t    filters[path] = record;\n", "    initialFilters[path] = record.get();\n\t    return Object.assign(hook, record) as Response;\n\t  };\n\t  const listen = <\n\t    ExternalStore extends object,\n\t    ExternalPath extends DotNestedKeys<ExternalStore>\n\t  >(\n\t    store: UseBoundStore<StoreApi<ExternalStore>>,\n\t    path: ExternalPath extends string ? ExternalPath : never,\n\t    options?: {\n", "      sideEffect?: (value: {\n\t        prev: DotNestedValue<ExternalStore, ExternalPath>;\n\t        next: DotNestedValue<ExternalStore, ExternalPath>;\n\t      }) => void;\n\t    }\n\t  ) => {\n\t    let prevValue = get(store.getState(), path);\n\t    const haveSubscription = () =>\n\t      !!Object.values((leiten as any)._usages || {}).filter((item) => item)\n\t        .length;\n", "    return store.subscribe((state) => {\n\t      const value = get(state, path);\n\t      if (haveSubscription() && !isEqual(prevValue, value)) {\n\t        prevValue = value;\n\t        options?.sideEffect?.({ prev: prevValue, next: value });\n\t        pureAction().then();\n\t      }\n\t    });\n\t  };\n\t  const pureAction = async () => {\n", "    updatePrevFilters();\n\t    leiten.action();\n\t  };\n\t  const action = async (path: string) => {\n\t    const filter = get(store.getState(), path);\n\t    if (JSON.stringify(filter) !== JSON.stringify(prevFilters[path])) {\n\t      leiten.action();\n\t    }\n\t  };\n\t  const updatePrevFilters = () => {\n", "    prevFilters = Object.keys(filters).reduce(\n\t      (acc, item) => ({\n\t        ...acc,\n\t        [item]: get(store.getState(), item),\n\t      }),\n\t      {}\n\t    );\n\t  };\n\t  resettableStoreSubscription(store, () => {\n\t    prevFilters = cloneDeep(initialFilters);\n", "  });\n\t  const clearAll = () => {\n\t    leiten.clear();\n\t    Object.keys(filters).forEach((key) => filters[key].clear());\n\t    leiten.action();\n\t  };\n\t  return Object.assign(leiten, { createFilter, clearAll, listen });\n\t};\n\texport interface IObjectDifferent<S = any> {\n\t  field: string;\n", "  prev: S;\n\t  next: S;\n\t}\n\texport const getObjectDifference = <S>(\n\t  next: any,\n\t  prev: any\n\t): IObjectDifferent<S>[] => {\n\t  if (typeof next !== \"object\") {\n\t    if (!isEqual(next, prev)) {\n\t      return [{ field: \"_\", prev, next }];\n", "    } else {\n\t      return [];\n\t    }\n\t  } else {\n\t    return Object.keys(next).reduce((result, field) => {\n\t      if (!isEqual(next[field], prev[field])) {\n\t        result.push({ field, prev: prev[field], next: next[field] });\n\t      }\n\t      return result;\n\t    }, [] as IObjectDifferent<S>[]);\n", "  }\n\t};\n"]}
{"filename": "src/helpers/leitenRequest.ts", "chunked_list": ["import { produce } from \"immer\";\n\timport { get, isEqual, set } from \"lodash-es\";\n\timport { nanoid } from \"nanoid\";\n\timport { useEffect, useState } from \"react\";\n\timport { StoreApi } from \"zustand\";\n\timport { shallow } from \"zustand/shallow\";\n\timport { useLeitenRequests } from \"../hooks/useLeitenRequest\";\n\timport { DotNestedKeys, DotNestedValue } from \"../interfaces/dotNestedKeys\";\n\timport {\n\t  ILeitenLoading,\n", "  ILoadingStatus,\n\t  initialLeitenLoading,\n\t} from \"../interfaces/IContentLoading\";\n\t/* eslint-disable @typescript-eslint/no-explicit-any */\n\texport type UseRequestType<Payload, Result> = <\n\t  U = ILeitenLoading<Payload, Result>\n\t>(\n\t  selector?: (state: ILeitenLoading<Payload, Result>) => U,\n\t  equals?: (a: U, b: U) => boolean\n\t) => U;\n", "export interface ILeitenRequest<Payload, Result>\n\t  extends UseRequestType<Payload, Result> {\n\t  abort: () => void;\n\t  clear: () => void;\n\t  action: (\n\t    params: Payload,\n\t    extraParams?: { status?: ILoadingStatus; requestId?: string }\n\t  ) => void;\n\t  set: (value: Partial<Result> | void, rewrite?: boolean) => void;\n\t  key: string;\n", "  get: () => ILeitenLoading<Payload, Result>;\n\t}\n\texport interface ILeitenRequestCallback<Payload, Result> {\n\t  previousResult: Result;\n\t  result: Result;\n\t  payload: Payload;\n\t  requestId: string;\n\t  error?: string;\n\t}\n\texport interface ILeitenRequestOptions<Payload, Result> {\n", "  fulfilled?: (\n\t    options: Omit<ILeitenRequestCallback<Payload, Result>, \"error\">\n\t  ) => void;\n\t  rejected?: (\n\t    options: Omit<ILeitenRequestCallback<Payload, Result>, \"result\">\n\t  ) => void;\n\t  abort?: (\n\t    options: Omit<ILeitenRequestCallback<Payload, Result>, \"error\" | \"result\">\n\t  ) => void;\n\t  resolved?: (\n", "    options: Omit<ILeitenRequestCallback<Payload, Result>, \"result\" | \"error\">\n\t  ) => void;\n\t  action?: (\n\t    options: Omit<ILeitenRequestCallback<Payload, Result>, \"error\" | \"result\">\n\t  ) => void;\n\t  initialStatus?: ILoadingStatus;\n\t  optimisticUpdate?: (params: Payload) => Result;\n\t}\n\texport const leitenRequest = <\n\t  Store extends object,\n", "  P extends DotNestedKeys<Store>,\n\t  Payload,\n\t  Result extends DotNestedValue<Store, P> | null | void\n\t>(\n\t  store: StoreApi<Store>,\n\t  path: P extends string\n\t    ? Result extends void\n\t      ? P\n\t      : DotNestedValue<Store, P> extends Result | null\n\t      ? P\n", "      : never\n\t    : never,\n\t  payloadCreator: (\n\t    params: Payload,\n\t    extraArgument?: IExtraArgument\n\t  ) => Promise<Result>,\n\t  options?: ILeitenRequestOptions<Payload, Result>\n\t): ILeitenRequest<Payload, Result> => {\n\t  const key = nanoid(12);\n\t  const initialState = initialLeitenLoading<Payload, Result>(\n", "    options?.initialStatus\n\t  );\n\t  const initialContent = get(store.getState(), path, null) as Result;\n\t  const setState = (state: ILeitenLoading<Payload, Result>) => {\n\t    useLeitenRequests.setState({ [key]: state });\n\t  };\n\t  setState(initialState); //init request\n\t  const setContent = (content: Result) => {\n\t    const nextState = produce(store.getState(), (draft) => {\n\t      set(draft, path, content);\n", "    });\n\t    store.setState(nextState);\n\t  };\n\t  const getState = (): ILeitenLoading<Payload, Result> => {\n\t    return useLeitenRequests.getState()[key] || initialState;\n\t  };\n\t  const getContent = (): Result => {\n\t    const result = get(store.getState(), path, \"_empty\") as Result | \"_empty\";\n\t    if (result !== \"_empty\") {\n\t      return result || initialContent;\n", "    } else {\n\t      return initialContent;\n\t    }\n\t  };\n\t  const _set = (value: Partial<Result> | void, rewrite = false) => {\n\t    if (typeof value === \"object\") {\n\t      const state = getContent();\n\t      const objectContent = rewrite\n\t        ? ({ ...value } as Result)\n\t        : ({ ...state, ...value } as Result);\n", "      const content = typeof value === \"object\" ? objectContent : value;\n\t      setContent(content);\n\t    } else {\n\t      value !== undefined && value !== null && setContent(value);\n\t    }\n\t  };\n\t  let previousResult: Result = getContent();\n\t  const reactions = {\n\t    action: (payload: Payload, status?: ILoadingStatus, requestId?: string) => {\n\t      setState({\n", "        status: status ?? \"loading\",\n\t        payload,\n\t        error: undefined,\n\t        requestId: requestId,\n\t      });\n\t      options?.action?.({\n\t        previousResult,\n\t        requestId: requestId || \"\",\n\t        payload,\n\t      });\n", "      previousResult = getContent();\n\t      if (options?.optimisticUpdate) {\n\t        setContent(options.optimisticUpdate(payload));\n\t      }\n\t    },\n\t    fulfilled: (result: Result, payload: Payload, requestId: string) => {\n\t      const state = getState();\n\t      if (requestId === state.requestId) {\n\t        setState({ ...state, status: \"loaded\" });\n\t        if (\n", "          result !== undefined &&\n\t          (!options?.optimisticUpdate || !isEqual(previousResult, result))\n\t        ) {\n\t          setContent(result);\n\t        }\n\t        options?.fulfilled?.({ previousResult, requestId, payload, result });\n\t      }\n\t    },\n\t    rejected: (payload: Payload, error: string, requestId?: string) => {\n\t      const state = getState();\n", "      setState({ ...state, status: \"error\", error });\n\t      options?.rejected?.({\n\t        previousResult,\n\t        requestId: requestId || \"\",\n\t        payload,\n\t        error,\n\t      });\n\t      if (options?.optimisticUpdate) {\n\t        setContent(previousResult);\n\t      }\n", "    },\n\t    abort: (payload: Payload, requestId: string) => {\n\t      setState(initialState);\n\t      options?.abort?.({ previousResult, requestId, payload });\n\t      if (options?.optimisticUpdate) {\n\t        setContent(previousResult);\n\t      }\n\t    },\n\t    resolved: (payload: Payload, requestId: string) => {\n\t      options?.resolved?.({ previousResult, requestId, payload });\n", "    },\n\t  };\n\t  const { action, abort } = createAsyncActions(payloadCreator, reactions);\n\t  const _abort = () => {\n\t    abort();\n\t  };\n\t  const clear = () => {\n\t    setState(initialState);\n\t    setContent(initialContent);\n\t  };\n", "  const usages: Record<string, boolean> = {};\n\t  const useRequest: UseRequestType<Payload, Result> = (selector, equals) => {\n\t    const [id] = useState(() => nanoid());\n\t    useEffect(() => {\n\t      usages[id] = true;\n\t      return () => {\n\t        usages[id] = false;\n\t      };\n\t    }, []);\n\t    return useLeitenRequests(\n", "      (state) => (selector || nonTypedReturn)(state[key] || initialState),\n\t      shallow || equals\n\t    );\n\t  };\n\t  resettableStoreSubscription(store, () => setState(initialState));\n\t  const _get = () => {\n\t    return useLeitenRequests.getState()[key];\n\t  };\n\t  return Object.assign(useRequest, {\n\t    abort: _abort,\n", "    action,\n\t    clear,\n\t    set: _set,\n\t    key,\n\t    get: _get,\n\t    _usages: usages,\n\t  });\n\t};\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tconst nonTypedReturn = (value: any) => value;\n", "export const resettableStoreSubscription = (\n\t  store: StoreApi<object>,\n\t  callback: () => void\n\t) => {\n\t  setTimeout(() => {\n\t    const resettable =\n\t      (store.getState() as any)[\"_resettableLifeCycle\"] !== undefined;\n\t    if (resettable) {\n\t      store.subscribe((next, prev) => {\n\t        if (\n", "          (next as any)[\"_resettableLifeCycle\"] === false &&\n\t          (prev as any)[\"_resettableLifeCycle\"] === true\n\t        )\n\t          callback();\n\t      });\n\t    }\n\t  }, 0);\n\t};\n\tfunction createAsyncActions<Payload, Result>(\n\t  payloadCreator: (\n", "    params: Payload,\n\t    extraArgument?: IExtraArgument\n\t  ) => Promise<Result>,\n\t  extra?: IReaction<Payload, Result>\n\t) {\n\t  let controller = new AbortController();\n\t  let signal = controller.signal;\n\t  const abort = () => {\n\t    controller.abort();\n\t    controller = new AbortController();\n", "    signal = controller.signal;\n\t  };\n\t  const action = (\n\t    params: Payload,\n\t    options?: { status?: ILoadingStatus; requestId?: string }\n\t  ) => {\n\t    const requestId = options?.requestId || nanoid();\n\t    extra?.action?.(params, options?.status, requestId);\n\t    payloadCreator(params, { signal })\n\t      .then((result) => {\n", "        extra?.fulfilled?.(result, params, requestId);\n\t      })\n\t      .catch((error) => {\n\t        if (error.message === \"The user aborted a request.\") {\n\t          extra?.abort?.(params, requestId);\n\t        } else {\n\t          extra?.rejected?.(params, error, requestId);\n\t        }\n\t      })\n\t      .finally(() => {\n", "        extra?.resolved?.(params, requestId);\n\t      });\n\t  };\n\t  return { action, abort };\n\t}\n\tinterface IReaction<Payload, Result> {\n\t  fulfilled?: (result: Result, params: Payload, requestId: string) => void;\n\t  rejected?: (params: Payload, error: string, requestId?: string) => void;\n\t  abort?: (params: Payload, requestId: string) => void;\n\t  resolved?: (params: Payload, requestId: string) => void;\n", "  action?: (\n\t    params: Payload,\n\t    status?: ILoadingStatus,\n\t    requestId?: string\n\t  ) => void;\n\t}\n\texport type IExtraArgument = {\n\t  signal: AbortSignal;\n\t  // requestId: string\n\t};\n"]}
{"filename": "src/helpers/leitenGroupRequest.ts", "chunked_list": ["import { produce } from \"immer\";\n\timport { get, set } from \"lodash-es\";\n\timport { StoreApi } from \"zustand/esm\";\n\timport { shallow } from \"zustand/shallow\";\n\timport { useLeitenRequests } from \"../hooks/useLeitenRequest\";\n\timport { DotNestedKeys, DotNestedValue } from \"../interfaces/dotNestedKeys\";\n\timport {\n\t  ILeitenLoading,\n\t  ILoadingStatus,\n\t  initialLeitenLoading,\n", "} from \"../interfaces/IContentLoading\";\n\timport {\n\t  ILeitenRequest,\n\t  ILeitenRequestOptions,\n\t  leitenRequest,\n\t  resettableStoreSubscription,\n\t} from \"./leitenRequest\";\n\t/* eslint-disable @typescript-eslint/no-explicit-any */\n\texport interface ILeitenGroupRequestParams<Params> {\n\t  key: string;\n", "  params: Params;\n\t}\n\texport interface IGroupCallOptions {\n\t  status?: ILoadingStatus;\n\t  requestId?: string;\n\t}\n\texport type AcceptableGroupRequestType<Store extends object> =\n\t  void | DotNestedValue<Store, DotNestedKeys<Store>> | null;\n\ttype LeitenState<Payload, Result> = ILeitenLoading<\n\t  ILeitenGroupRequestParams<Payload>,\n", "  Result\n\t>;\n\ttype UseRequestType<Payload, Result> = <U = LeitenState<Payload, Result>>(\n\t  key: string,\n\t  selector?: (state: LeitenState<Payload, Result>) => U,\n\t  equals?: (a: U, b: U) => boolean\n\t) => U;\n\ttype UseGroupRequestType<Payload, Result> = <U = LeitenState<Payload, Result>>(\n\t  selector?: (state: Record<string, LeitenState<Payload, Result>>) => U,\n\t  equals?: (a: U, b: U) => boolean\n", ") => U;\n\texport type ILeitenGroupRequest<Payload, Result> = {\n\t  clear: (key?: string) => void;\n\t  action: (\n\t    params: ILeitenGroupRequestParams<Payload>[],\n\t    options?: IGroupCallOptions\n\t  ) => void;\n\t  requests: Record<\n\t    string,\n\t    ILeitenRequest<ILeitenGroupRequestParams<Payload>, Result>\n", "  >;\n\t} & UseRequestType<Payload, Result> &\n\t  UseGroupRequestType<Payload, Result>;\n\texport interface ILeitenGroupRequestOption<Payload, Result>\n\t  extends ILeitenRequestOptions<ILeitenGroupRequestParams<Payload>, Result> {\n\t  initialContent?: Result | ((key: string) => Result);\n\t}\n\texport interface ILeitenGroupRequestArrayOption<Payload, Result>\n\t  extends ILeitenGroupRequestOption<Payload, Result> {\n\t  getKey: (value: Result) => string;\n", "}\n\texport const leitenGroupRequest = <\n\t  Store extends object,\n\t  P extends DotNestedKeys<Store>,\n\t  Payload,\n\t  Result extends DotNestedValue<Store, P> extends Record<\n\t    string,\n\t    AcceptableGroupRequestType<Store>\n\t  >\n\t    ? DotNestedValue<Store, P>[string]\n", "    : DotNestedValue<Store, P> extends Array<AcceptableGroupRequestType<Store>>\n\t    ? DotNestedValue<Store, P>[number]\n\t    : DotNestedValue<Store, P>\n\t>(\n\t  store: StoreApi<Store>,\n\t  path: P extends string\n\t    ? Result extends void\n\t      ? P\n\t      : DotNestedValue<Store, P> extends Record<string, Result> | Array<Result>\n\t      ? P\n", "      : never\n\t    : never,\n\t  payloadCreator: (\n\t    params: ILeitenGroupRequestParams<Payload>\n\t  ) => Promise<Result>,\n\t  options?: DotNestedValue<Store, P> extends Record<\n\t    string,\n\t    AcceptableGroupRequestType<Store>\n\t  >\n\t    ? ILeitenGroupRequestOption<Payload, Result>\n", "    : ILeitenGroupRequestArrayOption<Payload, Result>\n\t): ILeitenGroupRequest<Payload, Result> => {\n\t  const initialRequestState = initialLeitenLoading<\n\t    ILeitenGroupRequestParams<Payload>,\n\t    Result\n\t  >(options?.initialStatus);\n\t  let requests: Record<\n\t    string,\n\t    ILeitenRequest<ILeitenGroupRequestParams<Payload>, Result>\n\t  > = {};\n", "  const isArray = Array.isArray(get(store.getState(), path));\n\t  const getPathToArrayItem = (key: string) => {\n\t    const raw = get(store.getState(), path, []);\n\t    const source = Array.isArray(raw) ? raw : [];\n\t    const find = source.findIndex(\n\t      (s) =>\n\t        (options as ILeitenGroupRequestArrayOption<Payload, Result>)?.getKey?.(\n\t          s\n\t        ) === key\n\t    );\n", "    const index = find !== -1 ? find : source.length;\n\t    const withKey = (path + `[\"${index}\"]`) as DotNestedKeys<Store>;\n\t    return { withKey, isNew: find === -1 };\n\t  };\n\t  const add = (key: string) => {\n\t    let pathWithKey = \"\" as DotNestedKeys<Store>;\n\t    let payload = payloadCreator;\n\t    if (isArray) {\n\t      const before = getPathToArrayItem(key);\n\t      pathWithKey = before.withKey;\n", "      // eslint-disable-next-line\n\t      // @ts-ignore\n\t      payload = async (params: ILeitenGroupRequestParams<Payload>) => {\n\t        const result = await payloadCreator(params);\n\t        const after = getPathToArrayItem(key);\n\t        if ((before.isNew && after.isNew) || !after.isNew) {\n\t          const nextState = produce(store.getState(), (draft) => {\n\t            set(draft, after.withKey, result);\n\t          });\n\t          store.setState(nextState);\n", "        }\n\t      };\n\t    } else {\n\t      pathWithKey = (path + `.${key}`) as DotNestedKeys<Store>;\n\t      if (options?.initialContent) {\n\t        const initial = checkInitial(options.initialContent)\n\t          ? options.initialContent(key)\n\t          : options.initialContent;\n\t        const nextState = produce(store.getState(), (draft) => {\n\t          set(draft, pathWithKey, initial);\n", "        });\n\t        store.setState(nextState);\n\t      }\n\t    }\n\t    requests[key] = leitenRequest(store, pathWithKey, payload, options);\n\t  };\n\t  const action = (\n\t    params: ILeitenGroupRequestParams<Payload>[],\n\t    options?: IGroupCallOptions\n\t  ) => {\n", "    params.forEach(({ key, params }) => {\n\t      const request = requests[key];\n\t      const payload = { key, params };\n\t      if (request && !isArray) {\n\t        request.action(payload, options);\n\t      } else {\n\t        add(key);\n\t        requests[key].action(payload);\n\t      }\n\t    });\n", "  };\n\t  const clear = (key?: string) => {\n\t    if (key) {\n\t      !isArray && requests[key].clear();\n\t      delete requests[key];\n\t    } else {\n\t      set(store, path, {});\n\t      requests = {};\n\t    }\n\t  };\n", "  const useRequest: UseRequestType<Payload, Result> = (\n\t    key,\n\t    selector,\n\t    equals\n\t  ) => {\n\t    return useLeitenRequests((state) => {\n\t      const id = requests[key]?.key;\n\t      return (selector || nonTypedReturn)(\n\t        (id && state[id]) || initialRequestState\n\t      );\n", "    }, shallow || equals);\n\t  };\n\t  const useGroupRequest: UseGroupRequestType<Payload, Result> = (\n\t    selector,\n\t    equals\n\t  ) => {\n\t    return useLeitenRequests(\n\t      (state: Record<string, LeitenState<Payload, Result>>) => {\n\t        const keys = Object.entries(requests).map(([id, value]) => ({\n\t          id,\n", "          key: value.key,\n\t        }));\n\t        const requestsStore: typeof state = keys.reduce((acc, { id, key }) => {\n\t          return Object.assign(acc, { [id]: state[key] });\n\t        }, {} as typeof state);\n\t        return (selector || nonTypedReturn)(requestsStore);\n\t      },\n\t      shallow || equals\n\t    );\n\t  };\n", "  function hook<Payload, Result, U = LeitenState<Payload, Result>>(\n\t    key: string,\n\t    selector?: (state: LeitenState<Payload, Result>) => U,\n\t    equals?: (a: U, b: U) => boolean\n\t  ): U;\n\t  function hook<Payload, Result, U = LeitenState<Payload, Result>>(\n\t    selector?: (state: Record<string, LeitenState<Payload, Result>>) => U,\n\t    equals?: (a: U, b: U) => boolean\n\t  ): U;\n\t  function hook<Payload, Result, U = LeitenState<Payload, Result>>(\n", "    first?:\n\t      | string\n\t      | ((state: Record<string, LeitenState<Payload, Result>>) => U),\n\t    second?:\n\t      | ((state: LeitenState<Payload, Result>) => U)\n\t      | ((a: U, b: U) => boolean),\n\t    third?: (a: U, b: U) => boolean\n\t  ): U {\n\t    if (first !== undefined && typeof first === \"string\") {\n\t      return useRequest(first, second as any, third);\n", "    } else {\n\t      return useGroupRequest(first as any, second as any) as any;\n\t    }\n\t  }\n\t  resettableStoreSubscription(store, () => clear());\n\t  return Object.assign(hook, { clear, action, requests, call: action });\n\t};\n\tconst nonTypedReturn = (value: any) => value;\n\tconst checkInitial = <Result>(\n\t  value: Result | ((key: string) => Result)\n", "): value is (key: string) => Result => typeof value === \"function\";\n"]}
{"filename": "src/helpers/leitenGroupFilterRequest.ts", "chunked_list": ["import { produce } from \"immer\";\n\timport { get, set } from \"lodash-es\";\n\timport { StoreApi } from \"zustand\";\n\timport { UseBoundStore } from \"zustand/esm\";\n\timport {\n\t  DotNestedKeys,\n\t  DotNestedValue,\n\t  ValueOf,\n\t} from \"../interfaces/dotNestedKeys\";\n\timport { getObjectDifference, IObjectDifferent } from \"./leitenFilterRequest\";\n", "import {\n\t  AcceptableGroupRequestType,\n\t  ILeitenGroupRequestArrayOption,\n\t  ILeitenGroupRequestOption,\n\t  ILeitenGroupRequestParams,\n\t  leitenGroupRequest,\n\t} from \"./leitenGroupRequest\";\n\timport { ILeitenRecordEffects } from \"./leitenRecord\";\n\timport { resettableStoreSubscription } from \"./leitenRequest\";\n\t/* eslint-disable @typescript-eslint/no-explicit-any */\n", "export const leitenGroupFilterRequest = <\n\t  Store extends object,\n\t  P extends DotNestedKeys<Store>,\n\t  Result extends DotNestedValue<Store, P> extends Record<\n\t    string,\n\t    AcceptableGroupRequestType<Store>\n\t  >\n\t    ? NonNullable<DotNestedValue<Store, P>[string]>\n\t    : DotNestedValue<Store, P> extends Array<AcceptableGroupRequestType<Store>>\n\t    ? NonNullable<DotNestedValue<Store, P>[number]>\n", "    : DotNestedValue<Store, P>\n\t>(\n\t  store: UseBoundStore<StoreApi<Store>>,\n\t  path: P extends string\n\t    ? Result extends void\n\t      ? P\n\t      : DotNestedValue<Store, P> extends Record<string, Result> | Array<Result>\n\t      ? P\n\t      : never\n\t    : never,\n", "  request: (params: ILeitenGroupRequestParams<void>) => Promise<Result>,\n\t  options?: DotNestedValue<Store, P> extends Record<\n\t    string,\n\t    AcceptableGroupRequestType<Store>\n\t  >\n\t    ? ILeitenGroupRequestOption<void, Result>\n\t    : ILeitenGroupRequestArrayOption<void, Result>\n\t) => {\n\t  const leiten = leitenGroupRequest(store, path, request, {\n\t    ...options,\n", "    action: (args) => {\n\t      const key = args.payload.key;\n\t      updatePrevFilters(key);\n\t      return options?.action?.(args);\n\t    },\n\t  } as DotNestedValue<Store, P> extends Record<string, AcceptableGroupRequestType<Store>> ? ILeitenGroupRequestOption<void, Result> : ILeitenGroupRequestArrayOption<void, Result>);\n\t  const filters: Record<string, IGroupRecord<any>> = {};\n\t  const prevFilters: Record<string, Record<string, any>> = {};\n\t  const createFilter = <Path extends DotNestedKeys<Store>>(\n\t    path: Path extends string\n", "      ? DotNestedValue<Store, Path> extends Record<string, unknown>\n\t        ? Path\n\t        : never\n\t      : never,\n\t    options: ILeitenRecordEffects<\n\t      ValueOf<DotNestedValue<Store, Path>>,\n\t      Store\n\t    > & {\n\t      initialValue: ValueOf<DotNestedValue<Store, Path>>;\n\t    }\n", "  ) => {\n\t    prevFilters[path] = {};\n\t    type VALUE = ValueOf<DotNestedValue<Store, Path>>;\n\t    function hook(\n\t      key: string,\n\t      referenceObject?: VALUE\n\t    ): IObjectDifferent<VALUE>[] {\n\t      return store((state) =>\n\t        getObjectDifference(get(state, `${path}.${key}`), referenceObject)\n\t      );\n", "    }\n\t    const getState = (key: string): VALUE | undefined => {\n\t      return get(store.getState(), `${path}.${key}`, undefined);\n\t    };\n\t    const setState = (key: string, next: VALUE) => {\n\t      const prev = getState(key);\n\t      const draftState = produce(store.getState(), (draft) => {\n\t        set(draft, `${path}.${key}`, next);\n\t      });\n\t      const nextState = options.patchEffect\n", "        ? { ...draftState, ...options.patchEffect(next) }\n\t        : draftState;\n\t      store.setState(nextState);\n\t      options.sideEffect?.({ prev: prev || options.initialValue, next });\n\t      action(key, path, options.initialValue);\n\t    };\n\t    const clear = (key: string) => {\n\t      setState(key, options.initialValue);\n\t    };\n\t    const patch = (key: string, value: Partial<VALUE>) => {\n", "      const prev: object = (getState(key) || options.initialValue) as any;\n\t      setState(key, { ...prev, ...value } as VALUE);\n\t    };\n\t    const record = { clear, patch, set: setState, get: getState };\n\t    filters[path] = record;\n\t    return Object.assign(hook, record);\n\t  };\n\t  const action = async (key: string, path: string, initialValue: any) => {\n\t    const nextFilters = get(store.getState(), `${path}.${key}`);\n\t    if (\n", "      JSON.stringify(nextFilters) !==\n\t      JSON.stringify(prevFilters[path][key] || initialValue)\n\t    ) {\n\t      leiten.action([{ key, params: undefined }]);\n\t    }\n\t  };\n\t  const updatePrevFilters = (key: string) => {\n\t    Object.keys(filters).forEach((item) => {\n\t      prevFilters[item][key] = get(store.getState(), `${item}.${key}`);\n\t    });\n", "  };\n\t  resettableStoreSubscription(store, () => {\n\t    Object.keys(filters).forEach((path) => {\n\t      prevFilters[path] = {};\n\t    });\n\t  });\n\t  const clearAll = () => {\n\t    leiten.clear();\n\t    const keys = Object.keys(leiten.requests);\n\t    Object.keys(filters).forEach((key) =>\n", "      keys.forEach((k) => filters[key]?.clear(k))\n\t    );\n\t  };\n\t  return Object.assign(leiten, { createFilter, clearAll });\n\t};\n\tinterface IGroupRecord<VALUE> {\n\t  clear: (key: string) => void;\n\t  patch: (key: string, value: Partial<VALUE>) => void;\n\t  set: (key: string, next: VALUE) => void;\n\t  get: (key: string) => VALUE | undefined;\n", "}\n"]}
{"filename": "src/helpers/leitenRecord.ts", "chunked_list": ["import { produce } from \"immer\";\n\timport { get, set } from \"lodash-es\";\n\timport { StoreApi } from \"zustand/esm\";\n\timport { DotNestedKeys, DotNestedValue } from \"../interfaces/dotNestedKeys\";\n\t/* eslint-disable @typescript-eslint/no-explicit-any */\n\texport interface ILeitenRecordEffects<VALUE, State> {\n\t  patchEffect?: (value: VALUE) => Partial<State>;\n\t  sideEffect?: (value: { prev: VALUE; next: VALUE }) => void;\n\t}\n\texport interface ILeitenRecord<VALUE> {\n", "  patch: (value: Partial<VALUE>) => void;\n\t  set: (value: VALUE) => void;\n\t  get: () => VALUE;\n\t  clear: () => void;\n\t}\n\texport const leitenRecord = <\n\t  Store extends object,\n\t  P extends DotNestedKeys<Store>\n\t>(\n\t  store: StoreApi<Store>,\n", "  path: P extends string\n\t    ? DotNestedValue<Store, P> extends Array<any>\n\t      ? never\n\t      : DotNestedValue<Store, P> extends object | null\n\t      ? P\n\t      : never\n\t    : never,\n\t  effects?: ILeitenRecordEffects<DotNestedValue<Store, P>, Store>\n\t): ILeitenRecord<DotNestedValue<Store, P>> => {\n\t  type VALUE = DotNestedValue<Store, P>;\n", "  const initialValue = get(store.getState(), path, \"_empty\") as VALUE;\n\t  if (initialValue === \"_empty\" || typeof initialValue !== \"object\") {\n\t    throw new Error(\n\t      \"[leitenRecord] The defined path does not match the required structure\"\n\t    );\n\t  }\n\t  const getState = (): VALUE => {\n\t    const value = get(store.getState(), path, \"_empty\") as VALUE | \"_empty\";\n\t    return value !== \"_empty\" ? value : initialValue;\n\t  };\n", "  const setState = (next: VALUE) => {\n\t    const prev = getState();\n\t    const draftState = produce(store.getState(), (draft) => {\n\t      set(draft, path, next);\n\t    });\n\t    const nextState = effects?.patchEffect\n\t      ? { ...draftState, ...effects.patchEffect(next) }\n\t      : draftState;\n\t    store.setState(nextState);\n\t    effects?.sideEffect?.({ prev, next });\n", "  };\n\t  const clear = () => {\n\t    const nextState = produce(store.getState(), (draft) => {\n\t      set(draft, path, initialValue);\n\t    });\n\t    store.setState(nextState);\n\t  };\n\t  const patch = (value: Partial<VALUE>) => {\n\t    setState({ ...getState(), ...value });\n\t  };\n", "  return { clear, set: setState, get: getState, patch };\n\t};\n"]}
{"filename": "src/helpers/index.ts", "chunked_list": ["export * from \"../hooks/useLeitenModals\";\n\texport * from \"../hooks/useLeitenRequest\";\n\texport * from \"./leitenFilterRequest\";\n\texport * from \"./leitenGroupFilterRequest\";\n\texport * from \"./leitenGroupRequest\";\n\texport * from \"./leitenList\";\n\texport * from \"./leitenModal\";\n\texport * from \"./leitenNormalizedList\";\n\texport * from \"./leitenPrimitive\";\n\texport * from \"./leitenRecord\";\n", "export * from \"./leitenRequest\";\n"]}
{"filename": "src/helpers/leitenModal.ts", "chunked_list": ["import { produce } from \"immer\";\n\timport { get, set } from \"lodash-es\";\n\timport { nanoid } from \"nanoid\";\n\timport { StoreApi } from \"zustand\";\n\timport { shallow } from \"zustand/shallow\";\n\timport {\n\t  leitenModalManagerAction,\n\t  useLeitenModalStack,\n\t} from \"../hooks/useLeitenModals\";\n\timport { DotNestedKeys, DotNestedValue } from \"../interfaces/dotNestedKeys\";\n", "type ActionType = \"OPEN\" | \"CLOSE\" | \"TOGGLE\" | \"SET_DATA\";\n\texport interface ILeitenModal<Data> {\n\t  open: (data?: Data, replace?: boolean) => void;\n\t  close: () => void;\n\t  action: (params: {\n\t    type: ActionType;\n\t    payload?: Data;\n\t    replace?: boolean;\n\t  }) => void;\n\t  (): [boolean, boolean];\n", "}\n\texport const leitenModal = <\n\t  Store extends object,\n\t  P extends DotNestedKeys<Store>\n\t>(\n\t  store: StoreApi<Store>,\n\t  path: P extends string ? P : never,\n\t  extra?: {\n\t    reaction?: (params: {\n\t      type: ActionType;\n", "      payload?: DotNestedValue<Store, P>;\n\t    }) => void;\n\t    clearOnClose?: boolean;\n\t  }\n\t): ILeitenModal<DotNestedValue<Store, P>> => {\n\t  type Data = DotNestedValue<Store, P>;\n\t  const initialData = get(store.getState(), path, \"_empty\") as Data;\n\t  if (initialData === \"_empty\") {\n\t    throw new Error(\"[leitenModal] The defined path does not exist\");\n\t  }\n", "  const key = nanoid(10);\n\t  const setContent = (value: Data) => {\n\t    const nextState = produce(store.getState(), (draft) => {\n\t      set(draft, path, value);\n\t    });\n\t    store.setState(nextState);\n\t  };\n\t  const setState = (value: boolean, replace?: boolean) => {\n\t    leitenModalManagerAction(key, value, replace);\n\t  };\n", "  const action = (params: {\n\t    type: ActionType;\n\t    payload?: Data;\n\t    replace?: boolean;\n\t  }) => {\n\t    if (params.type === \"CLOSE\") {\n\t      setState(false);\n\t      if (extra?.clearOnClose) {\n\t        setContent(initialData);\n\t      }\n", "    } else if (params.type === \"OPEN\") {\n\t      setState(true, params.replace);\n\t      params.payload && setContent(params.payload);\n\t    } else if (params.type === \"TOGGLE\") {\n\t      const isOpen = () => useLeitenModalStack.getState().queue.includes(key);\n\t      setState(!isOpen());\n\t      if (!isOpen() && extra?.clearOnClose) {\n\t        setContent(initialData);\n\t      }\n\t    } else if (params.type === \"SET_DATA\") {\n", "      params.payload && setContent(params.payload);\n\t    }\n\t    extra?.reaction?.(params);\n\t  };\n\t  const open = (data?: DotNestedValue<Store, P>, replace?: boolean) => {\n\t    action({ type: \"OPEN\", payload: data, replace });\n\t  };\n\t  const close = () => action({ type: \"CLOSE\" });\n\t  const useOpen = () => {\n\t    return useLeitenModalStack((state) => {\n", "      const open = state.queue.includes(key);\n\t      const hidden = open && state.queue[state.queue.length - 1] !== key;\n\t      return [open, hidden] as [boolean, boolean];\n\t    }, shallow);\n\t  };\n\t  return Object.assign(useOpen, { action, close, open });\n\t};\n"]}
{"filename": "src/hooks/useLeitenModals.ts", "chunked_list": ["import { produce } from \"immer\";\n\timport { create } from \"zustand\";\n\texport interface LeitenModalManagerState {\n\t  queue: string[];\n\t}\n\texport const useLeitenModalStack = create<LeitenModalManagerState>(() => ({\n\t  queue: [],\n\t}));\n\texport const leitenModalManagerAction = (\n\t  key: string,\n", "  value: boolean,\n\t  replace?: boolean\n\t) => {\n\t  const nextState = produce(useLeitenModalStack.getState(), (draft) => {\n\t    let queue = draft.queue.filter((modal) => modal !== key);\n\t    if (replace) {\n\t      queue = [];\n\t    }\n\t    if (value) {\n\t      queue.push(key);\n", "    }\n\t    draft.queue = queue;\n\t  });\n\t  useLeitenModalStack.setState(nextState);\n\t};\n"]}
{"filename": "src/hooks/useLeitenRequest.ts", "chunked_list": ["import { create } from \"zustand\";\n\timport {\n\t  ILeitenLoading,\n\t  initialLeitenLoading,\n\t} from \"../interfaces/IContentLoading\";\n\t/* eslint-disable @typescript-eslint/no-explicit-any */\n\texport const useLeitenRequests = create<{\n\t  [key: string]: ILeitenLoading<any, any>;\n\t}>(() => ({}));\n\ttype TupleOfKeys = [string] | string[];\n", "type TupleOfStates<T extends TupleOfKeys> = {\n\t  [K in keyof T]: ILeitenLoading<any, any>;\n\t};\n\texport const leitenMap = <T extends TupleOfKeys, Response>(\n\t  keys: T,\n\t  selector: (values: TupleOfStates<T>) => Response\n\t) => {\n\t  return (state: { [key: string]: ILeitenLoading<any, any> }) =>\n\t    selector(\n\t      keys.map(\n", "        (key) => state[key] || initialLeitenLoading()\n\t      ) as TupleOfStates<T>\n\t    );\n\t};\n"]}
{"filename": "src/examples/requests.ts", "chunked_list": ["export interface IKeyword {\n\t  value: string;\n\t  bid: number;\n\t}\n\texport interface ICard {\n\t  value: string;\n\t  type: \"bid\" | \"defaultBid\";\n\t}\n\texport interface IUser {\n\t  name: string;\n", "  surname: string;\n\t  keywords: IKeyword[];\n\t  cards: string[];\n\t}\n\texport const getUser = async (\n\t  id: string,\n\t  signal?: AbortSignal\n\t): Promise<IUser> => {\n\t  return new Promise((resolve) => {\n\t    setTimeout(() => {\n", "      const result: IUser = {\n\t        name: \"Name\" + id,\n\t        surname: \"Surname\",\n\t        keywords: [],\n\t        cards: [\"1\", \"2\"],\n\t      };\n\t      resolve(result);\n\t    }, 2000);\n\t  });\n\t};\n", "export const updateUser = async (user: IUser): Promise<void> => {\n\t  return new Promise((resolve) => {\n\t    setTimeout(() => {\n\t      // console.log(user); // send to server\n\t      resolve();\n\t    }, 2000);\n\t  });\n\t};\n\texport const getCard = async (param: string): Promise<ICard> => {\n\t  return new Promise((resolve) => {\n", "    setTimeout(() => {\n\t      const result: ICard = {\n\t        type: \"bid\",\n\t        value: \"test\" + param,\n\t      };\n\t      resolve(result);\n\t    }, 2000);\n\t  });\n\t};\n\texport interface IChartFilter {\n", "  period: \"today\" | \"yesterday\" | \"latsWeek\" | \"lastMonth\";\n\t  type: \"sales\" | \"income\";\n\t}\n\texport const getChart = async (\n\t  filter: IChartFilter,\n\t  signal?: AbortSignal\n\t): Promise<number[]> => {\n\t  return new Promise((resolve) => {\n\t    setTimeout(() => {\n\t      const result: number[] = Array(100).fill(2);\n", "      resolve(result);\n\t    }, 2000);\n\t  });\n\t};\n"]}
