{"filename": "src/main.ts", "chunked_list": ["import { NestFactory } from '@nestjs/core';\n\timport { AppModule } from './app.module';\n\timport { setupSwagger } from './common/modules';\n\timport helmet from 'helmet';\n\timport { ValidationPipe } from '@nestjs/common';\n\timport { NotFoundFilter, UnauthorizedFilter } from './common/filters';\n\tasync function bootstrap() {\n\t  const app = await NestFactory.create(AppModule);\n\t  app.enableCors();\n\t  app.use(helmet({ contentSecurityPolicy: false }));\n", "  app.useGlobalPipes(new ValidationPipe());\n\t  app.useGlobalFilters(new NotFoundFilter());\n\t  app.useGlobalFilters(new UnauthorizedFilter());\n\t  await setupSwagger(app);\n\t  const port = parseInt(process.env.WEB_PORT) || 5000;\n\t  await app.listen(port);\n\t}\n\tbootstrap();\n"]}
{"filename": "src/app.service.ts", "chunked_list": ["import { Injectable, Logger } from '@nestjs/common';\n\timport { ClusterDto, Deployment } from './common/dto';\n\timport _ from 'lodash';\n\timport os from 'os';\n\t@Injectable()\n\texport class AppService {\n\t  private cluster: ClusterDto;\n\t  private readonly logger = new Logger(AppService.name);\n\t  private DisplayMode = {\n\t    dev: 'Development Mode',\n", "    prod: 'Production Mode',\n\t  };\n\t  async onModuleInit() {\n\t    await this.getBackendInfo();\n\t    this.logger.log(`Package name: ${this.cluster.name}`);\n\t    this.logger.log(`Package version: ${this.cluster.version}`);\n\t    this.logger.log(`Package description: ${this.cluster.description}`);\n\t    this.logger.log(`Package author: ${this.cluster.author}`);\n\t    this.logger.log(`Cluster name: ${this.cluster.hostname}`);\n\t    this.logger.log(`Cluster mode: ${this.DisplayMode[this.cluster.mode]}`);\n", "  }\n\t  async getBackendInfo(): Promise<ClusterDto> {\n\t    if (this.cluster) return this.cluster;\n\t    const packageFile = await import(`${process.cwd()}/package.json`);\n\t    const packageInfo = _.pick(packageFile, [\n\t      'name',\n\t      'version',\n\t      'description',\n\t      'author',\n\t    ]);\n", "    const hostname = os.hostname();\n\t    const mode = (process.env.NODE_ENV as Deployment) || 'prod';\n\t    this.cluster = { ...packageInfo, hostname, mode };\n\t    return this.cluster;\n\t  }\n\t}\n"]}
{"filename": "src/app.module.ts", "chunked_list": ["import { MiddlewareConsumer, Module, NestModule } from '@nestjs/common';\n\timport { AppService } from './app.service';\n\timport { JwtExpireMiddleware, LoggerMiddleware } from './common/middlewares';\n\timport { JwtModule } from '@nestjs/jwt';\n\timport { ConfigModule } from '@nestjs/config';\n\timport { MongooseModule } from '@nestjs/mongoose';\n\timport { AuthModule } from './api/auth/auth.module';\n\timport { UserModule } from './api/user/user.module';\n\timport { PostModule } from './api/post/post.module';\n\tConfigModule.forRoot();\n", "@Module({\n\t  imports: [\n\t    MongooseModule.forRoot(process.env.MONGO_URI),\n\t    JwtModule.register({\n\t      global: true,\n\t      secret: process.env.JWT_SECRET_KEY,\n\t      signOptions: { expiresIn: '1h' },\n\t    }),\n\t    AuthModule,\n\t    UserModule,\n", "    PostModule,\n\t  ],\n\t  controllers: [],\n\t  providers: [AppService],\n\t})\n\texport class AppModule implements NestModule {\n\t  configure(consumer: MiddlewareConsumer) {\n\t    consumer.apply(LoggerMiddleware).forRoutes('*');\n\t    consumer.apply(JwtExpireMiddleware).exclude('/auth/(.*)').forRoutes('*');\n\t  }\n", "}\n"]}
{"filename": "src/common/opcode.ts", "chunked_list": ["import { HttpException, HttpStatus } from '@nestjs/common';\n\texport type OpcodeNames =\n\t  | 'Success'\n\t  | 'InvalidError'\n\t  | 'NoPermission'\n\t  | 'ValidateFailed'\n\t  | 'NotFound';\n\texport type OpcodeItem = (details?: { [key: string]: any }) => HttpException;\n\texport const globalOpcode: { [key in OpcodeNames]: OpcodeItem } = {\n\t  Success: $(0, HttpStatus.OK, '요청에 성공하였습니다.'),\n", "  InvalidError: $(\n\t    -999,\n\t    HttpStatus.INTERNAL_SERVER_ERROR,\n\t    '알 수 없는 내부 오류가 발생하였습니다.',\n\t  ),\n\t  NoPermission: $(\n\t    -401,\n\t    HttpStatus.UNAUTHORIZED,\n\t    '인증되지 않았습니다. JWT 토큰을 넣어주세요.',\n\t  ),\n", "  ValidateFailed: $(\n\t    -1,\n\t    HttpStatus.BAD_REQUEST,\n\t    '잘못된 형식입니다. 모든 정보를 올바르게 입력해주세요.',\n\t  ),\n\t  NotFound: $(\n\t    -404,\n\t    HttpStatus.NOT_FOUND,\n\t    '잘못된 요청입니다. 해당 Route가 존재하는지 다시 한번 확인해주세요.',\n\t  ),\n", "};\n\texport function $(\n\t  opcode: number,\n\t  statusCode: number,\n\t  message?: string,\n\t): OpcodeItem {\n\t  return (details: { [key: string]: any } = {}) =>\n\t    new HttpException({ opcode, message, ...details }, statusCode);\n\t}\n"]}
{"filename": "src/common/types.ts", "chunked_list": ["// export const Values = [1, 2, 3] as const;\n\tinterface AccessTokenResponse {\n\t  accessToken: string;\n\t}\n"]}
{"filename": "src/common/filters/Unauthorized.filter.ts", "chunked_list": ["import {\n\t  ArgumentsHost,\n\t  Catch,\n\t  ExceptionFilter,\n\t  UnauthorizedException,\n\t} from '@nestjs/common';\n\timport { globalOpcode } from '../opcode';\n\t@Catch(UnauthorizedException)\n\texport class UnauthorizedFilter implements ExceptionFilter {\n\t  catch(exception: UnauthorizedException, host: ArgumentsHost) {\n", "    const body = globalOpcode.NotFound().getResponse();\n\t    host.switchToHttp().getResponse().status(401).json(body);\n\t  }\n\t}\n"]}
{"filename": "src/common/filters/NotFound.filter.ts", "chunked_list": ["import {\n\t  ArgumentsHost,\n\t  Catch,\n\t  ExceptionFilter,\n\t  NotFoundException,\n\t} from '@nestjs/common';\n\timport { globalOpcode } from '../opcode';\n\t@Catch(NotFoundException)\n\texport class NotFoundFilter implements ExceptionFilter {\n\t  catch(exception: NotFoundException, host: ArgumentsHost) {\n", "    const body = globalOpcode.NotFound().getResponse();\n\t    host.switchToHttp().getResponse().status(404).json(body);\n\t  }\n\t}\n"]}
{"filename": "src/common/filters/index.ts", "chunked_list": ["export * from './NotFound.filter';\n\texport * from './Unauthorized.filter';\n"]}
{"filename": "src/common/schemas/post.schema.ts", "chunked_list": ["import { Prop, Schema, SchemaFactory, SchemaOptions } from '@nestjs/mongoose';\n\timport { Document } from 'mongoose';\n\timport { Types } from 'mongoose';\n\texport type PostDocument = Post & Document;\n\tconst options: SchemaOptions = {\n\t  timestamps: false,\n\t  versionKey: false,\n\t};\n\tenum PostCategory {\n\t  WEB = 'web',\n", "  PWN = 'pwn',\n\t  REV = 'rev',\n\t}\n\t@Schema(options)\n\texport class Post {\n\t  @Prop({\n\t    required: true,\n\t    type: Types.ObjectId,\n\t    ref: 'Users',\n\t  })\n", "  user: Types.ObjectId;\n\t  @Prop({\n\t    required: true,\n\t    enum: PostCategory,\n\t  })\n\t  category: string;\n\t  @Prop({\n\t    required: true,\n\t  })\n\t  title: string;\n", "  @Prop({\n\t    required: true,\n\t  })\n\t  content: string;\n\t  // todo: file upload\n\t}\n\texport const PostSchema = SchemaFactory.createForClass(Post);\n"]}
{"filename": "src/common/schemas/user.schema.ts", "chunked_list": ["import { Prop, Schema, SchemaFactory, SchemaOptions } from '@nestjs/mongoose';\n\timport { Document } from 'mongoose';\n\timport { Types } from 'mongoose';\n\texport type UserDocument = User & Document;\n\tconst options: SchemaOptions = {\n\t  timestamps: false,\n\t  versionKey: false,\n\t};\n\t@Schema(options)\n\texport class User {\n", "  @Prop({\n\t    required: true,\n\t    unique: true,\n\t  })\n\t  username: string;\n\t  @Prop({\n\t    required: true,\n\t  })\n\t  password: string;\n\t  @Prop({\n", "    required: true,\n\t    enum: ['USER', 'ADMIN'],\n\t  })\n\t  role: string;\n\t}\n\texport const UserSchema = SchemaFactory.createForClass(User);\n"]}
{"filename": "src/common/schemas/index.ts", "chunked_list": ["export * from './user.schema';\n\texport * from './post.schema';\n\texport * from './assignment.schema';\n"]}
{"filename": "src/common/schemas/assignment.schema.ts", "chunked_list": ["import { Prop, Schema, SchemaFactory, SchemaOptions } from '@nestjs/mongoose';\n\timport { Document } from 'mongoose';\n\timport { Types } from 'mongoose';\n\texport type AssignmentDocument = Assignment & Document;\n\tconst options: SchemaOptions = {\n\t  timestamps: false,\n\t  versionKey: false,\n\t};\n\t@Schema(options)\n\texport class Assignment {\n", "  @Prop({\n\t    required: true,\n\t    type: Types.ObjectId,\n\t    ref: 'Users',\n\t  })\n\t  user: Types.ObjectId;\n\t  @Prop({\n\t    required: true,\n\t  })\n\t  title: string;\n", "  @Prop({\n\t    required: true,\n\t  })\n\t  content: string;\n\t  @Prop({\n\t    required: true,\n\t  })\n\t  completed: boolean;\n\t}\n\texport const AssignmentSchema = SchemaFactory.createForClass(Assignment);\n"]}
{"filename": "src/common/middlewares/logger.middleware.ts", "chunked_list": ["import { Injectable, NestMiddleware, Logger } from '@nestjs/common';\n\timport { Request, Response, NextFunction } from 'express';\n\t@Injectable()\n\texport class LoggerMiddleware implements NestMiddleware {\n\t  private logger = new Logger(LoggerMiddleware.name);\n\t  use(req: Request, res: Response, next: NextFunction) {\n\t    const startTimestamp = Date.now();\n\t    const requestMethod = req.method;\n\t    const originURL = req.url || req.originalUrl;\n\t    const httpVersion = `HTTP/${req.httpVersion}`;\n", "    const userAgent = req.headers['user-agent'];\n\t    const ipAddress =\n\t      req.headers['x-forwarded-for'] || req.socket.remoteAddress;\n\t    if (!ipAddress) return next();\n\t    res.on('finish', () => {\n\t      const statusCode = res.statusCode;\n\t      const endTimestamp = Date.now() - startTimestamp;\n\t      this.logger.log(\n\t        `${ipAddress} (${userAgent}) - \"${requestMethod} ${originURL} ${httpVersion}\" ${statusCode} +${endTimestamp}ms`,\n\t      );\n", "      if (Object.keys(req.body).length > 0)\n\t        this.logger.log(`Request Body: ${JSON.stringify(req.body)}`);\n\t    });\n\t    next();\n\t  }\n\t}\n"]}
{"filename": "src/common/middlewares/jwt-expiration.middleware.ts", "chunked_list": ["import { Injectable, NestMiddleware } from '@nestjs/common';\n\timport { Request, Response, NextFunction } from 'express';\n\timport { JwtService } from '@nestjs/jwt';\n\t@Injectable()\n\texport class JwtExpireMiddleware implements NestMiddleware {\n\t  constructor(private readonly jwtService: JwtService) {}\n\t  async use(req: Request, res: Response, next: NextFunction) {\n\t    const token = req.headers.authorization?.split(' ')[1];\n\t    if (token) {\n\t      try {\n", "        const decoded = await this.jwtService.verifyAsync(token);\n\t        req.user = decoded;\n\t        next();\n\t      } catch (err) {\n\t        res\n\t          .status(401)\n\t          .json({ message: 'JWT 토큰이 올바르지 않거나 만료되었습니다.' });\n\t      }\n\t    } else {\n\t      res\n", "        .status(401)\n\t        .json({ message: 'JWT 토큰을 Baerer에 넣어서 전달해주세요.' });\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/common/middlewares/index.ts", "chunked_list": ["export * from './logger.middleware';\n\texport * from './jwt-expiration.middleware';\n"]}
{"filename": "src/common/modules/swagger.module.ts", "chunked_list": ["import { INestApplication } from '@nestjs/common';\n\timport { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';\n\timport { AppService } from 'src/app.service';\n\texport const setupSwagger = async (app: INestApplication) => {\n\t  const cluster = await new AppService().getBackendInfo();\n\t  const config = new DocumentBuilder()\n\t    .setTitle(cluster.name)\n\t    .setDescription(cluster.description)\n\t    .setVersion(cluster.version)\n\t    .addBearerAuth(\n", "      { type: 'http', scheme: 'bearer', bearerFormat: 'JWT', in: 'header' },\n\t      'access-token',\n\t    )\n\t    .build();\n\t  const document = SwaggerModule.createDocument(app, config);\n\t  SwaggerModule.setup('api-docs', app, document);\n\t};\n"]}
{"filename": "src/common/modules/index.ts", "chunked_list": ["export * from './swagger.module';\n"]}
{"filename": "src/common/guard/test.guard.ts", "chunked_list": ["import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\n\timport { Observable } from 'rxjs';\n\t@Injectable()\n\texport class TestGuard implements CanActivate {\n\t  canActivate(\n\t    context: ExecutionContext,\n\t  ): boolean | Promise<boolean> | Observable<boolean> {\n\t    const req = context.switchToHttp().getRequest();\n\t    // console.log(req);\n\t    return true;\n", "  }\n\t}\n"]}
{"filename": "src/common/guard/index.ts", "chunked_list": []}
{"filename": "src/common/dto/assignment.dto.ts", "chunked_list": ["import { ApiProperty } from '@nestjs/swagger';\n\timport { IsBoolean, IsString } from 'class-validator';\n\texport class AssignmentDto {\n\t  @ApiProperty()\n\t  @IsString()\n\t  username: string;\n\t  @ApiProperty()\n\t  @IsString()\n\t  readonly title: string;\n\t  @ApiProperty()\n", "  @IsString()\n\t  readonly content: string;\n\t}\n\texport class AssignmentStatus {\n\t  @ApiProperty()\n\t  @IsString()\n\t  readonly assignId: string;\n\t  @ApiProperty()\n\t  @IsBoolean()\n\t  readonly status: boolean;\n", "}\n"]}
{"filename": "src/common/dto/cluster.dto.ts", "chunked_list": ["import { IsString, IsEnum } from 'nestjs-swagger-dto';\n\texport const deployment = ['prod', 'dev'] as const;\n\texport type Deployment = (typeof deployment)[number];\n\texport class ClusterDto {\n\t  @IsString({\n\t    description: '프로젝트 이름',\n\t    example: 'Backend',\n\t  })\n\t  name: string;\n\t  @IsString({\n", "    description: '프로젝트 버전',\n\t    example: '1.0.0',\n\t  })\n\t  version: string;\n\t  @IsString({\n\t    description: '프로젝트 설명',\n\t    example: '~~~ 프로젝트의 백엔드입니다.',\n\t  })\n\t  description: string;\n\t  @IsEnum({\n", "    enum: { deployment } as any,\n\t    description: '배포 모드',\n\t    example: deployment[0],\n\t  })\n\t  mode: Deployment;\n\t  @IsString({\n\t    description: '클러스터 이름',\n\t    example: '',\n\t  })\n\t  hostname: string;\n", "  @IsString({\n\t    description: '작성자',\n\t    example: '조현재 (whguswo0818@gmail.com)',\n\t  })\n\t  author: string;\n\t}\n"]}
{"filename": "src/common/dto/user.dto.ts", "chunked_list": ["import { ApiProperty } from '@nestjs/swagger';\n\timport { IsBoolean, IsString } from 'class-validator';\n\texport class CreateUserDto {\n\t  @ApiProperty()\n\t  @IsString()\n\t  readonly username: string;\n\t  @ApiProperty()\n\t  @IsString()\n\t  password: string;\n\t}\n", "export class LoginDto {\n\t  @ApiProperty()\n\t  @IsString()\n\t  readonly username: string;\n\t  @ApiProperty()\n\t  @IsString()\n\t  readonly password: string;\n\t}\n"]}
{"filename": "src/common/dto/index.ts", "chunked_list": ["export * from './cluster.dto';\n\texport * from './user.dto';\n\texport * from './assignment.dto';\n\texport * from './response.dto';\n\texport * from './post.dto';\n"]}
{"filename": "src/common/dto/post.dto.ts", "chunked_list": ["import { IsIn, IsString } from 'class-validator';\n\timport { ApiProperty } from '@nestjs/swagger';\n\texport class CreatePostDto {\n\t  @ApiProperty()\n\t  @IsString()\n\t  @IsIn(['web', 'pwn', 'rev'])\n\t  readonly category: string;\n\t  @ApiProperty()\n\t  @IsString()\n\t  readonly title: string;\n", "  @ApiProperty()\n\t  @IsString()\n\t  readonly content: string;\n\t}\n"]}
{"filename": "src/common/dto/response.dto.ts", "chunked_list": ["import { IsString } from 'class-validator';\n\timport { IsNumber } from 'nestjs-swagger-dto';\n\texport class ResponseDto {\n\t  @IsNumber({ description: '응답 코드', example: 0 })\n\t  status: number;\n\t  @IsString()\n\t  message: string;\n\t}\n"]}
{"filename": "src/api/auth/auth.module.ts", "chunked_list": ["import { forwardRef, Global, Module } from '@nestjs/common';\n\timport { MongooseModule } from '@nestjs/mongoose';\n\timport { User, UserSchema } from 'src/common/schemas';\n\timport { UserModule } from '../user/user.module';\n\timport { AuthController } from './auth.controller';\n\timport { AuthService } from './auth.service';\n\t@Module({\n\t  imports: [\n\t    MongooseModule.forFeature([\n\t      { name: User.name, schema: UserSchema },\n", "    ]),\n\t    UserModule,\n\t  ],\n\t  controllers: [AuthController],\n\t  providers: [AuthService],\n\t  exports: [AuthService],\n\t})\n\texport class AuthModule {}\n"]}
{"filename": "src/api/auth/auth.controller.ts", "chunked_list": ["import {\n\t  Body,\n\t  Controller,\n\t  Get,\n\t  Post,\n\t} from '@nestjs/common';\n\timport { Request } from 'express';\n\timport { User, UserDocument } from 'src/common/schemas';\n\timport { LoginDto } from 'src/common/dto';\n\timport { AuthService } from './auth.service';\n", "@Controller('auth')\n\texport class AuthController {\n\t  constructor(private readonly authService: AuthService) {}\n\t  @Post('/login')\n\t  async login(@Body() data: LoginDto): Promise<AccessTokenResponse> {\n\t    const user = await this.authService.login(data);\n\t    return await this.authService.getAccessToken(user);\n\t  }\n\t}\n"]}
{"filename": "src/api/auth/auth.service.ts", "chunked_list": ["import { forwardRef, HttpException, Injectable } from '@nestjs/common';\n\timport { InjectModel } from '@nestjs/mongoose';\n\timport { Model } from 'mongoose';\n\timport { LoginDto } from 'src/common/dto';\n\timport {\n\t  User,\n\t  UserDocument,\n\t} from 'src/common/schemas';\n\timport * as bcrypt from 'bcrypt';\n\timport { JwtService } from '@nestjs/jwt';\n", "@Injectable()\n\texport class AuthService {\n\t  constructor(\n\t    @InjectModel(User.name)\n\t    private userModel: Model<UserDocument>,\n\t    private readonly jwtService: JwtService,\n\t  ) {}\n\t  private async verifyPassword(\n\t    password: string,\n\t    hashedPassword: string\n", "  ): Promise<boolean> {\n\t    return bcrypt.compare(password + process.env.HASH_SALT, hashedPassword);\n\t  }\n\t  async login(data: LoginDto): Promise<UserDocument> {\n\t    const user = await this.userModel.findOne({ username: data.username }).lean();\n\t    if (!user) throw new HttpException('계정 또는 비밀번호가 잘못되었습니다.', 404);\n\t    return user;\n\t  }\n\t  async getAccessToken(user: UserDocument): Promise<AccessTokenResponse> {\n\t    delete user['password'];\n", "    const payload = { ...user };\n\t    const accessToken = this.jwtService.sign(payload);\n\t    return { accessToken };\n\t  }\n\t}\n"]}
{"filename": "src/api/user/user.module.ts", "chunked_list": ["import { forwardRef, Global, Module } from '@nestjs/common';\n\timport { MongooseModule } from '@nestjs/mongoose';\n\timport { User, UserSchema } from 'src/common/schemas';\n\timport { UserController } from './user.controller';\n\timport { UserService } from './user.service';\n\t@Global()\n\t@Module({\n\t  imports: [\n\t    MongooseModule.forFeature([\n\t      { name: User.name, schema: UserSchema },\n", "    ]),\n\t  ],\n\t  controllers: [UserController],\n\t  providers: [UserService],\n\t  exports: [UserService],\n\t})\n\texport class UserModule {}\n"]}
{"filename": "src/api/user/user.controller.ts", "chunked_list": ["import {\n\t  Body,\n\t  Controller,\n\t  Get,\n\t  Post,\n\t} from '@nestjs/common';\n\timport { UserService } from './user.service';\n\timport { Request } from 'express';\n\timport { User, UserDocument } from 'src/common/schemas';\n\timport { CreateUserDto, ResponseDto } from 'src/common/dto';\n", "@Controller('user')\n\texport class UserController {\n\t  constructor(private readonly userService: UserService) {}\n\t  @Get()\n\t  async getAllUser(): Promise<UserDocument[]> {\n\t    return await this.userService.getAllUser();\n\t  }\n\t  @Post()\n\t  async createUser(@Body() data: CreateUserDto): Promise<ResponseDto> {\n\t    return await this.userService.createUser(data);\n", "  }\n\t}\n"]}
{"filename": "src/api/user/user.service.ts", "chunked_list": ["import { forwardRef, HttpException, Inject, Injectable } from '@nestjs/common';\n\timport { InjectModel } from '@nestjs/mongoose';\n\timport { Model, Types } from 'mongoose';\n\timport { CreateUserDto, ResponseDto } from 'src/common/dto';\n\timport {\n\t  User,\n\t  UserDocument,\n\t} from 'src/common/schemas';\n\timport * as bcrypt from 'bcrypt';\n\t@Injectable()\n", "export class UserService {\n\t  constructor(\n\t    @InjectModel(User.name)\n\t    private userModel: Model<UserDocument>,\n\t  ) {}\n\t  async getAllUser(): Promise<UserDocument[]> {\n\t    const users = await this.userModel.find().lean();\n\t    users.map(user => {\n\t      delete user['password'];\n\t    });\n", "    return users;\n\t  }\n\t  async createUser(data: CreateUserDto): Promise<ResponseDto> {\n\t    const existingUser = await this.userModel.findOne({ username: data.username });\n\t    if (existingUser) throw new HttpException('해당 사용자가 이미 존재합니다.', 404);\n\t    const hashedPassword = await bcrypt.hash(data.password, 10);\n\t    const user = new this.userModel({\n\t      username: data.username,\n\t      password: hashedPassword,\n\t      role: 'USER',\n", "      assignments: [],\n\t    })\n\t    await user.save();\n\t    return { status: 200, message: '사용자가 등록되었습니다.' };\n\t  }\n\t}\n"]}
{"filename": "src/api/post/post.controller.ts", "chunked_list": ["import {\n\t  Body,\n\t  Controller,\n\t  Delete,\n\t  Get,\n\t  Param,\n\t  Patch,\n\t  Post,\n\t  Req,\n\t} from '@nestjs/common';\n", "import { Request } from 'express';\n\timport { PostDocument } from 'src/common/schemas';\n\timport { CreatePostDto } from 'src/common/dto';\n\timport { PostService } from './post.service';\n\t@Controller('post')\n\texport class PostController {\n\t  constructor(private readonly postService: PostService) {}\n\t  @Get('/id/:id')\n\t  getPost(@Param('id') id: string): Promise<PostDocument> {\n\t    return this.postService.getPostById(id);\n", "  }\n\t  @Get('/my')\n\t  getMyPost(@Req() request: Request): Promise<PostDocument[]> {\n\t    return this.postService.getMyPost(request.user);\n\t  }\n\t  @Post()\n\t  createPost(\n\t    @Req() request: Request,\n\t    @Body() data: CreatePostDto,\n\t  ): Promise<PostDocument> {\n", "    return this.postService.createPost(data, request.user);\n\t  }\n\t  @Delete('/:id')\n\t  removePost(\n\t    @Req() request: Request,\n\t    @Param('id') id: string,\n\t  ): Promise<boolean> {\n\t    return this.postService.removePost(id, request.user);\n\t  }\n\t  @Patch('/:id')\n", "  modifyPost(\n\t    @Req() request: Request,\n\t    @Param('id') id: string,\n\t    @Body() data: CreatePostDto,\n\t  ): Promise<PostDocument> {\n\t    return this.postService.modifyPost(data, id, request.user);\n\t  }\n\t}\n"]}
{"filename": "src/api/post/post.service.ts", "chunked_list": ["import { forwardRef, HttpException, Injectable } from '@nestjs/common';\n\timport { InjectModel } from '@nestjs/mongoose';\n\timport { Model, Types } from 'mongoose';\n\timport { CreatePostDto } from 'src/common/dto';\n\timport {\n\t  Post,\n\t  PostDocument,\n\t  User,\n\t  UserDocument,\n\t} from 'src/common/schemas';\n", "@Injectable()\n\texport class PostService {\n\t  constructor(\n\t    @InjectModel(Post.name)\n\t    private postModel: Model<PostDocument>,\n\t  ) {}\n\t  async getPostById(_id: string): Promise<PostDocument> {\n\t    const post = await this.postModel.findById(new Types.ObjectId(_id));\n\t    if (!post) throw new HttpException('No Post', 404);\n\t    return post;\n", "  }\n\t  async getMyPost(user: UserDocument): Promise<PostDocument[]> {\n\t    const posts = await this.postModel.find({ user: user._id });\n\t    return posts;\n\t  }\n\t  async getPostByUserId(_id: string): Promise<PostDocument[]> {\n\t    const posts = await this.postModel.find({ user: new Types.ObjectId(_id) });\n\t    return posts;\n\t  }\n\t  async createPost(data: CreatePostDto, user: UserDocument): Promise<PostDocument> {\n", "    const post = new this.postModel({\n\t      ...data,\n\t      user: new Types.ObjectId(user._id),\n\t    });\n\t    await post.save();\n\t    return post;\n\t  }\n\t  async removePost(_id: string, user: UserDocument): Promise<boolean> {\n\t    const post = await this.postModel.findById(new Types.ObjectId(_id));\n\t    if (!post) throw new HttpException('해당 Post가 존재하지 않습니다.', 404);\n", "    if (post.user.equals(user._id) && user.role !== 'ADMIN')\n\t      throw new HttpException('Permission denied', 403);\n\t    const result = await this.postModel.deleteOne({ _id });\n\t    return result.deletedCount > 0;\n\t  }\n\t  async modifyPost(\n\t    data: CreatePostDto,\n\t    _id: string,\n\t    user: UserDocument,\n\t  ): Promise<PostDocument> {\n", "    const post = await this.postModel.findById(new Types.ObjectId(_id));\n\t    if (!post) throw new HttpException('해당 Post가 존재하지 않습니다.', 404);\n\t    if (post.user.equals(user._id) && user.role !== 'ADMIN')\n\t      throw new HttpException('Permission denied', 403);\n\t    post.title = data.title;\n\t    post.content = data.content;\n\t    post.category = data.category;\n\t    post.save();\n\t    return post;\n\t  }\n", "}\n"]}
{"filename": "src/api/post/post.module.ts", "chunked_list": ["import { forwardRef, Global, Module } from '@nestjs/common';\n\timport { MongooseModule } from '@nestjs/mongoose';\n\timport { Post, PostSchema } from 'src/common/schemas';\n\timport { UserModule } from '../user/user.module';\n\timport { PostController } from './post.controller';\n\timport { PostService } from './post.service';\n\t@Module({\n\t  imports: [\n\t    MongooseModule.forFeature([\n\t      { name: Post.name, schema: PostSchema },\n", "    ]),\n\t    UserModule,\n\t  ],\n\t  controllers: [PostController],\n\t  providers: [PostService],\n\t  exports: [PostService],\n\t})\n\texport class PostModule {}\n"]}
{"filename": "src/typings/express.d.ts", "chunked_list": ["import { UserDocument } from \"src/common/schemas\";\n\tdeclare module 'express' {\n\t  interface Request {\n\t    user?: UserDocument;\n\t  }\n\t}\n"]}
