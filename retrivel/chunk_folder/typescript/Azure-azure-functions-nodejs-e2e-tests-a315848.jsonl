{"filename": "app/v3/index.ts", "chunked_list": ["import * as app from '@azure/functions';\n\tapp.setup();"]}
{"filename": "app/v3/storageBlobTrigger1/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { AzureFunction, Context } from '@azure/functions';\n\tconst blobTrigger: AzureFunction = async function (_context: Context, myBlob: any): Promise<any> {\n\t    console.log(`storageBlobTrigger1 was triggered by \"${myBlob.toString()}\"`);\n\t    return myBlob;\n\t};\n\texport default blobTrigger;\n"]}
{"filename": "app/v3/serviceBusQueueTrigger1/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { AzureFunction, Context } from '@azure/functions';\n\tconst serviceBusQueueTrigger: AzureFunction = async function (_context: Context, mySbMsg: any): Promise<string> {\n\t    console.log(`serviceBusQueueTrigger1 was triggered by \"${mySbMsg}\"`);\n\t    return mySbMsg;\n\t};\n\texport default serviceBusQueueTrigger;\n"]}
{"filename": "app/v3/cosmosDBTrigger1/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { AzureFunction, Context } from '@azure/functions';\n\tconst cosmosDBTrigger: AzureFunction = async function (_context: Context, documents: any[]): Promise<any[]> {\n\t    console.log(`cosmosDBTrigger1 processed ${documents.length} documents`);\n\t    for (const document of documents) {\n\t        console.log(`cosmosDBTrigger1 was triggered by \"${document.message}\"`);\n\t    }\n\t    return documents;\n\t};\n", "export default cosmosDBTrigger;\n"]}
{"filename": "app/v3/eventHubTriggerMany/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { AzureFunction, Context } from '@azure/functions';\n\tconst eventHubTrigger: AzureFunction = async function (_context: Context, messages: unknown[]): Promise<void> {\n\t    console.log(`eventHubTriggerMany processed ${messages.length} messages`);\n\t    for (const message of messages) {\n\t        console.log(`eventHubTriggerMany was triggered by \"${message}\"`);\n\t    }\n\t};\n\texport default eventHubTrigger;\n"]}
{"filename": "app/v3/storageQueueTrigger2/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { AzureFunction, Context } from '@azure/functions';\n\tconst queueTrigger: AzureFunction = async function (_context: Context, myQueueItem: string): Promise<void> {\n\t    console.log(`storageQueueTrigger2 was triggered by \"${myQueueItem}\"`);\n\t};\n\texport default queueTrigger;\n"]}
{"filename": "app/v3/helloWorld1/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { AzureFunction, Context, HttpRequest } from '@azure/functions';\n\tconst httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {\n\t    console.log(`Http function processed request for url \"${req.url}\"`);\n\t    const name = req.query.name || req.body || 'world';\n\t    context.res = {\n\t        body: `Hello, ${name}!`,\n\t    };\n\t};\n", "export default httpTrigger;\n"]}
{"filename": "app/v3/timerTrigger1/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { AzureFunction, Context } from '@azure/functions';\n\tconst timerTrigger: AzureFunction = async function (_context: Context, _myTimer: any): Promise<void> {\n\t    console.log('timerTrigger1 was triggered');\n\t};\n\texport default timerTrigger;\n"]}
{"filename": "app/v3/httpRawBody/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { AzureFunction, Context, HttpRequest } from '@azure/functions';\n\timport * as util from 'util';\n\tconst httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {\n\t    console.log(`Http function processed request for url \"${req.url}\"`);\n\t    context.res = {\n\t        body: {\n\t            body: formatIfBuffer(req.body),\n\t            rawBody: formatIfBuffer(req.rawBody),\n", "            bufferBody: formatIfBuffer(req.bufferBody),\n\t        },\n\t    };\n\t};\n\texport default httpTrigger;\n\tfunction formatIfBuffer(data: any): any {\n\t    return Buffer.isBuffer(data) ? util.format(data) : data;\n\t}\n"]}
{"filename": "app/v3/eventHubTriggerOne/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { AzureFunction, Context } from '@azure/functions';\n\tconst eventHubTrigger: AzureFunction = async function (_context: Context, message: unknown): Promise<void> {\n\t    console.log(`eventHubTriggerOne was triggered by \"${message}\"`);\n\t};\n\texport default eventHubTrigger;\n"]}
{"filename": "app/v3/storageQueueTrigger1/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { AzureFunction, Context } from '@azure/functions';\n\tconst queueTrigger: AzureFunction = async function (_context: Context, myQueueItem: string): Promise<string> {\n\t    console.log(`storageQueueTrigger1 was triggered by \"${myQueueItem}\"`);\n\t    return myQueueItem;\n\t};\n\texport default queueTrigger;\n"]}
{"filename": "app/v3/httpCookies/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { AzureFunction, Context, HttpRequest } from '@azure/functions';\n\tconst httpCookies: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {\n\t    console.log(`Http function processed request for url \"${req.url}\"`);\n\t    context.res = {\n\t        cookies: [\n\t            {\n\t                name: 'mycookie',\n\t                value: 'myvalue',\n", "                maxAge: 200000,\n\t            },\n\t            {\n\t                name: 'mycookie2',\n\t                value: 'myvalue',\n\t                path: '/',\n\t                maxAge: '200000',\n\t            },\n\t            {\n\t                name: 'mycookie3-expires',\n", "                value: 'myvalue3-expires',\n\t                maxAge: 0,\n\t            },\n\t            {\n\t                name: 'mycookie4-samesite-lax',\n\t                value: 'myvalue',\n\t                sameSite: 'Lax',\n\t            },\n\t            {\n\t                name: 'mycookie5-samesite-strict',\n", "                value: 'myvalue',\n\t                sameSite: 'Strict',\n\t            },\n\t        ],\n\t    };\n\t};\n\texport default httpCookies;\n"]}
{"filename": "app/v3/serviceBusTopicTrigger1/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { AzureFunction, Context } from '@azure/functions';\n\tconst serviceBusTopicTrigger: AzureFunction = async function (_context: Context, mySbMsg: any): Promise<string> {\n\t    console.log(`serviceBusTopicTrigger1 was triggered by \"${mySbMsg}\"`);\n\t    return mySbMsg;\n\t};\n\texport default serviceBusTopicTrigger;\n"]}
{"filename": "app/v3/storageBlobTrigger2/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { AzureFunction, Context } from '@azure/functions';\n\tconst blobTrigger: AzureFunction = async function (_context: Context, myBlob: any): Promise<void> {\n\t    console.log(`storageBlobTrigger2 was triggered by \"${myBlob.toString()}\"`);\n\t};\n\texport default blobTrigger;\n"]}
{"filename": "app/v3/serviceBusTopicTrigger2/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { AzureFunction, Context } from '@azure/functions';\n\tconst serviceBusTopicTrigger: AzureFunction = async function (_context: Context, mySbMsg: any): Promise<void> {\n\t    console.log(`serviceBusTopicTrigger2 was triggered by \"${mySbMsg}\"`);\n\t};\n\texport default serviceBusTopicTrigger;\n"]}
{"filename": "app/v3/cosmosDBTrigger2/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { AzureFunction, Context } from '@azure/functions';\n\tconst cosmosDBTrigger: AzureFunction = async function (_context: Context, documents: any[]): Promise<void> {\n\t    console.log(`cosmosDBTrigger2 processed ${documents.length} documents`);\n\t    for (const document of documents) {\n\t        console.log(`cosmosDBTrigger2 was triggered by \"${document.message}\"`);\n\t    }\n\t};\n\texport default cosmosDBTrigger;\n"]}
{"filename": "app/v3/serviceBusQueueTrigger2/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { AzureFunction, Context } from '@azure/functions';\n\tconst serviceBusQueueTrigger: AzureFunction = async function (_context: Context, mySbMsg: any): Promise<void> {\n\t    console.log(`serviceBusQueueTrigger2 was triggered by \"${mySbMsg}\"`);\n\t};\n\texport default serviceBusQueueTrigger;\n"]}
{"filename": "app/v4/src/functions/storageBlobTrigger2.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { app, InvocationContext } from '@azure/functions';\n\texport async function storageBlobTrigger2(blob: Buffer, _context: InvocationContext): Promise<void> {\n\t    console.log(`storageBlobTrigger2 was triggered by \"${blob.toString()}\"`);\n\t}\n\tapp.storageBlob('storageBlobTrigger2', {\n\t    path: 'e2etestcontainer/e2etestblob2',\n\t    connection: 'e2eTest_storage',\n\t    handler: storageBlobTrigger2,\n", "});\n"]}
{"filename": "app/v4/src/functions/serviceBusQueueTrigger2.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { app, InvocationContext } from '@azure/functions';\n\texport async function serviceBusQueueTrigger2(message: unknown, _context: InvocationContext): Promise<void> {\n\t    console.log(`serviceBusQueueTrigger2 was triggered by \"${message}\"`);\n\t}\n\tapp.serviceBusQueue('serviceBusQueueTrigger2', {\n\t    connection: 'e2eTest_serviceBus',\n\t    queueName: 'e2etestqueue2',\n\t    handler: serviceBusQueueTrigger2,\n", "});\n"]}
{"filename": "app/v4/src/functions/storageQueueTrigger1.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { app, InvocationContext, output } from '@azure/functions';\n\texport async function storageQueueTrigger1(queueItem: string, _context: InvocationContext): Promise<string> {\n\t    console.log(`storageQueueTrigger1 was triggered by \"${queueItem}\"`);\n\t    return queueItem;\n\t}\n\tapp.storageQueue('storageQueueTrigger1', {\n\t    queueName: 'e2etestqueue1',\n\t    connection: 'e2eTest_storage',\n", "    return: output.storageQueue({\n\t        queueName: 'e2etestqueue2',\n\t        connection: 'e2eTest_storage',\n\t    }),\n\t    handler: storageQueueTrigger1,\n\t});\n"]}
{"filename": "app/v4/src/functions/storageQueueTrigger2.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { app, InvocationContext } from '@azure/functions';\n\texport async function storageQueueTrigger2(queueItem: string, _context: InvocationContext): Promise<void> {\n\t    console.log(`storageQueueTrigger2 was triggered by \"${queueItem}\"`);\n\t}\n\tapp.storageQueue('storageQueueTrigger2', {\n\t    queueName: 'e2etestqueue2',\n\t    connection: 'e2eTest_storage',\n\t    handler: storageQueueTrigger2,\n", "});\n"]}
{"filename": "app/v4/src/functions/cosmosDBTrigger1.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { app, InvocationContext, output } from '@azure/functions';\n\texport async function cosmosDBTrigger1(documents: unknown[], _context: InvocationContext): Promise<unknown[]> {\n\t    console.log(`cosmosDBTrigger1 processed ${documents.length} documents`);\n\t    for (const document of documents) {\n\t        console.log(`cosmosDBTrigger1 was triggered by \"${(<any>document).message}\"`);\n\t    }\n\t    return documents;\n\t}\n", "app.cosmosDB('cosmosDBTrigger1', {\n\t    connection: 'e2eTest_cosmosDB',\n\t    databaseName: 'e2eTestDB',\n\t    containerName: 'e2eTestContainer1',\n\t    createLeaseContainerIfNotExists: true,\n\t    leaseContainerPrefix: '1',\n\t    return: output.cosmosDB({\n\t        connection: 'e2eTest_cosmosDB',\n\t        databaseName: 'e2eTestDB',\n\t        containerName: 'e2eTestContainer2',\n", "    }),\n\t    handler: cosmosDBTrigger1,\n\t});\n"]}
{"filename": "app/v4/src/functions/serviceBusTopicTrigger2.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { app, InvocationContext } from '@azure/functions';\n\texport async function serviceBusTopicTrigger2(message: unknown, _context: InvocationContext): Promise<void> {\n\t    console.log(`serviceBusTopicTrigger2 was triggered by \"${message}\"`);\n\t}\n\tapp.serviceBusTopic('serviceBusTopicTrigger2', {\n\t    connection: 'e2eTest_serviceBus',\n\t    topicName: 'e2etesttopic2',\n\t    subscriptionName: 'e2etestsub',\n", "    handler: serviceBusTopicTrigger2,\n\t});\n"]}
{"filename": "app/v4/src/functions/timerTrigger1.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { app, InvocationContext, Timer } from '@azure/functions';\n\texport async function timerTrigger1(_myTimer: Timer, _context: InvocationContext): Promise<void> {\n\t    console.log('timerTrigger1 was triggered');\n\t}\n\tapp.timer('timerTrigger1', {\n\t    schedule: '*/30 * * * * *',\n\t    handler: timerTrigger1,\n\t});\n"]}
{"filename": "app/v4/src/functions/helloWorld1.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { app, HttpRequest, HttpResponseInit, InvocationContext } from '@azure/functions';\n\texport async function helloWorld1(request: HttpRequest, _context: InvocationContext): Promise<HttpResponseInit> {\n\t    console.log(`Http function processed request for url \"${request.url}\"`);\n\t    const name = request.query.get('name') || (await request.text()) || 'world';\n\t    return { body: `Hello, ${name}!` };\n\t}\n\tapp.http('helloWorld1', {\n\t    methods: ['GET', 'POST'],\n", "    authLevel: 'anonymous',\n\t    handler: helloWorld1,\n\t});\n"]}
{"filename": "app/v4/src/functions/serviceBusTopicTrigger1.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { app, InvocationContext, output } from '@azure/functions';\n\texport async function serviceBusTopicTrigger1(message: unknown, _context: InvocationContext): Promise<unknown> {\n\t    console.log(`serviceBusTopicTrigger1 was triggered by \"${message}\"`);\n\t    return message;\n\t}\n\tapp.serviceBusTopic('serviceBusTopicTrigger1', {\n\t    connection: 'e2eTest_serviceBus',\n\t    topicName: 'e2etesttopic1',\n", "    subscriptionName: 'e2etestsub',\n\t    return: output.serviceBusTopic({\n\t        connection: 'e2eTest_serviceBus',\n\t        topicName: 'e2etesttopic2',\n\t    }),\n\t    handler: serviceBusTopicTrigger1,\n\t});\n"]}
{"filename": "app/v4/src/functions/eventHubTriggerMany.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { app, InvocationContext } from '@azure/functions';\n\texport async function eventHubTriggerMany(messages: unknown[], _context: InvocationContext): Promise<void> {\n\t    console.log(`eventHubTriggerMany processed ${messages.length} messages`);\n\t    for (const message of messages) {\n\t        console.log(`eventHubTriggerMany was triggered by \"${message}\"`);\n\t    }\n\t}\n\tapp.eventHub('eventHubTriggerMany', {\n", "    connection: 'e2eTest_eventHub',\n\t    eventHubName: 'e2etesteventhubmany',\n\t    cardinality: 'many',\n\t    handler: eventHubTriggerMany,\n\t});\n"]}
{"filename": "app/v4/src/functions/cosmosDBTrigger2.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { app, InvocationContext } from '@azure/functions';\n\texport async function cosmosDBTrigger2(documents: unknown[], _context: InvocationContext): Promise<void> {\n\t    console.log(`cosmosDBTrigger2 processed ${documents.length} documents`);\n\t    for (const document of documents) {\n\t        console.log(`cosmosDBTrigger2 was triggered by \"${(<any>document).message}\"`);\n\t    }\n\t}\n\tapp.cosmosDB('cosmosDBTrigger2', {\n", "    connection: 'e2eTest_cosmosDB',\n\t    databaseName: 'e2eTestDB',\n\t    containerName: 'e2eTestContainer2',\n\t    createLeaseContainerIfNotExists: true,\n\t    leaseContainerPrefix: '2',\n\t    handler: cosmosDBTrigger2,\n\t});\n"]}
{"filename": "app/v4/src/functions/eventHubTriggerOne.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { app, InvocationContext } from '@azure/functions';\n\texport async function eventHubTriggerOne(message: unknown, _context: InvocationContext): Promise<void> {\n\t    console.log(`eventHubTriggerOne was triggered by \"${message}\"`);\n\t}\n\tapp.eventHub('eventHubTriggerOne', {\n\t    connection: 'e2eTest_eventHub',\n\t    eventHubName: 'e2etesteventhubone',\n\t    cardinality: 'one',\n", "    handler: eventHubTriggerOne,\n\t});\n"]}
{"filename": "app/v4/src/functions/serviceBusQueueTrigger1.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { app, InvocationContext, output } from '@azure/functions';\n\texport async function serviceBusQueueTrigger1(message: unknown, _context: InvocationContext): Promise<unknown> {\n\t    console.log(`serviceBusQueueTrigger1 was triggered by \"${message}\"`);\n\t    return message;\n\t}\n\tapp.serviceBusQueue('serviceBusQueueTrigger1', {\n\t    connection: 'e2eTest_serviceBus',\n\t    queueName: 'e2etestqueue1',\n", "    return: output.serviceBusQueue({\n\t        connection: 'e2eTest_serviceBus',\n\t        queueName: 'e2etestqueue2',\n\t    }),\n\t    handler: serviceBusQueueTrigger1,\n\t});\n"]}
{"filename": "app/v4/src/functions/storageBlobTrigger1.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { app, InvocationContext, output } from '@azure/functions';\n\texport async function storageBlobTrigger1(blob: Buffer, _context: InvocationContext): Promise<Buffer> {\n\t    console.log(`storageBlobTrigger1 was triggered by \"${blob.toString()}\"`);\n\t    return blob;\n\t}\n\tapp.storageBlob('storageBlobTrigger1', {\n\t    path: 'e2etestcontainer/e2etestblob1',\n\t    connection: 'e2eTest_storage',\n", "    return: output.storageBlob({\n\t        path: 'e2etestcontainer/e2etestblob2',\n\t        connection: 'e2eTest_storage',\n\t    }),\n\t    handler: storageBlobTrigger1,\n\t});\n"]}
{"filename": "app/v4/src/functions/httpCookies.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { app, HttpRequest, HttpResponseInit, InvocationContext } from '@azure/functions';\n\texport async function httpCookies(request: HttpRequest, _context: InvocationContext): Promise<HttpResponseInit> {\n\t    console.log(`Http function processed request for url \"${request.url}\"`);\n\t    return {\n\t        cookies: [\n\t            {\n\t                name: 'mycookie',\n\t                value: 'myvalue',\n", "                maxAge: 200000,\n\t            },\n\t            {\n\t                name: 'mycookie2',\n\t                value: 'myvalue',\n\t                path: '/',\n\t                maxAge: <any>'200000',\n\t            },\n\t            {\n\t                name: 'mycookie3-expires',\n", "                value: 'myvalue3-expires',\n\t                maxAge: 0,\n\t            },\n\t            {\n\t                name: 'mycookie4-samesite-lax',\n\t                value: 'myvalue',\n\t                sameSite: 'Lax',\n\t            },\n\t            {\n\t                name: 'mycookie5-samesite-strict',\n", "                value: 'myvalue',\n\t                sameSite: 'Strict',\n\t            },\n\t        ],\n\t    };\n\t}\n\tapp.http('httpCookies', {\n\t    methods: ['GET', 'POST'],\n\t    authLevel: 'anonymous',\n\t    handler: httpCookies,\n", "});\n"]}
{"filename": "app/v4-oldBundle/src/functions/cosmosDBTrigger1.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { app, InvocationContext, output } from '@azure/functions';\n\texport async function cosmosDBTrigger1(documents: unknown[], _context: InvocationContext): Promise<unknown[]> {\n\t    console.log(`cosmosDBTrigger1 processed ${documents.length} documents`);\n\t    for (const document of documents) {\n\t        console.log(`cosmosDBTrigger1 was triggered by \"${(<any>document).message}\"`);\n\t    }\n\t    return documents;\n\t}\n", "app.cosmosDB('cosmosDBTrigger1', {\n\t    connectionStringSetting: 'e2eTest_cosmosDB',\n\t    databaseName: 'e2eTestDB',\n\t    collectionName: 'e2eTestContainer1',\n\t    createLeaseCollectionIfNotExists: true,\n\t    leaseCollectionPrefix: '1',\n\t    return: output.cosmosDB({\n\t        connectionStringSetting: 'e2eTest_cosmosDB',\n\t        databaseName: 'e2eTestDB',\n\t        collectionName: 'e2eTestContainer2',\n", "    }),\n\t    handler: cosmosDBTrigger1,\n\t});\n"]}
{"filename": "app/v4-oldBundle/src/functions/cosmosDBTrigger2.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { app, InvocationContext } from '@azure/functions';\n\texport async function cosmosDBTrigger2(documents: unknown[], _context: InvocationContext): Promise<void> {\n\t    console.log(`cosmosDBTrigger2 processed ${documents.length} documents`);\n\t    for (const document of documents) {\n\t        console.log(`cosmosDBTrigger2 was triggered by \"${(<any>document).message}\"`);\n\t    }\n\t}\n\tapp.cosmosDB('cosmosDBTrigger2', {\n", "    connectionStringSetting: 'e2eTest_cosmosDB',\n\t    databaseName: 'e2eTestDB',\n\t    collectionName: 'e2eTestContainer2',\n\t    createLeaseCollectionIfNotExists: true,\n\t    leaseCollectionPrefix: '2',\n\t    handler: cosmosDBTrigger2,\n\t});\n"]}
{"filename": "src/eventHub.test.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { EventHubProducerClient } from '@azure/event-hubs';\n\timport { waitForOutput } from './global.test';\n\timport { eventHubConnectionString } from './resources/connectionStrings';\n\timport { eventHubMany, eventHubOne } from './resources/eventHub';\n\timport { getRandomTestData } from './utils/getRandomTestData';\n\tdescribe('eventHub', () => {\n\t    let clientOne: EventHubProducerClient;\n\t    let clientMany: EventHubProducerClient;\n", "    before(() => {\n\t        clientOne = new EventHubProducerClient(eventHubConnectionString, eventHubOne);\n\t        clientMany = new EventHubProducerClient(eventHubConnectionString, eventHubMany);\n\t    });\n\t    after(async () => {\n\t        await Promise.all([clientOne.close(), clientMany.close()]);\n\t    });\n\t    it('event hub cardinality one', async () => {\n\t        const message = getRandomTestData();\n\t        await clientOne.sendBatch([{ body: message }]);\n", "        await waitForOutput(`eventHubTriggerOne was triggered by \"${message}\"`);\n\t    });\n\t    it('event hub cardinality many', async () => {\n\t        const message = getRandomTestData();\n\t        const message2 = getRandomTestData();\n\t        await clientMany.sendBatch([{ body: message }, { body: message2 }]);\n\t        await waitForOutput(`eventHubTriggerMany processed 2 messages`);\n\t        await waitForOutput(`eventHubTriggerMany was triggered by \"${message}\"`);\n\t        await waitForOutput(`eventHubTriggerMany was triggered by \"${message2}\"`);\n\t    });\n", "});\n"]}
{"filename": "src/timer.test.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { waitForOutput } from './global.test';\n\tdescribe('timer', () => {\n\t    it('hello world', async () => {\n\t        await waitForOutput('timerTrigger1 was triggered', true);\n\t    });\n\t});\n"]}
{"filename": "src/cosmosDB.test.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { CosmosClient } from '@azure/cosmos';\n\timport { waitForOutput } from './global.test';\n\timport { cosmosDBConnectionString } from './resources/connectionStrings';\n\timport { container1Name, dbName } from './resources/cosmosDB';\n\timport { getRandomTestData } from './utils/getRandomTestData';\n\tdescribe('cosmosDB', () => {\n\t    it('trigger and output', async () => {\n\t        const client = new CosmosClient(cosmosDBConnectionString);\n", "        const container = client.database(dbName).container(container1Name);\n\t        const message = getRandomTestData();\n\t        await container.items.create({ message });\n\t        await waitForOutput(`cosmosDBTrigger1 processed 1 documents`);\n\t        await waitForOutput(`cosmosDBTrigger1 was triggered by \"${message}\"`);\n\t        await waitForOutput(`cosmosDBTrigger2 processed 1 documents`);\n\t        await waitForOutput(`cosmosDBTrigger2 was triggered by \"${message}\"`);\n\t    });\n\t});\n"]}
{"filename": "src/serviceBus.test.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { ServiceBusClient } from '@azure/service-bus';\n\timport { waitForOutput } from './global.test';\n\timport { serviceBusConnectionString } from './resources/connectionStrings';\n\timport { serviceBusQueue1, serviceBusTopic1 } from './resources/serviceBus';\n\timport { getRandomTestData } from './utils/getRandomTestData';\n\tdescribe('serviceBus', () => {\n\t    let client: ServiceBusClient;\n\t    before(() => {\n", "        client = new ServiceBusClient(serviceBusConnectionString);\n\t    });\n\t    after(async () => {\n\t        await client.close();\n\t    });\n\t    it('queue', async () => {\n\t        const message = getRandomTestData();\n\t        const sender = client.createSender(serviceBusQueue1);\n\t        const batch = await sender.createMessageBatch();\n\t        batch.tryAddMessage({ body: message });\n", "        await sender.sendMessages(batch);\n\t        await waitForOutput(`serviceBusQueueTrigger1 was triggered by \"${message}\"`);\n\t        await waitForOutput(`serviceBusQueueTrigger2 was triggered by \"${message}\"`);\n\t    });\n\t    it('topic', async () => {\n\t        const message = getRandomTestData();\n\t        const sender = client.createSender(serviceBusTopic1);\n\t        const batch = await sender.createMessageBatch();\n\t        batch.tryAddMessage({ body: message });\n\t        await sender.sendMessages(batch);\n", "        await waitForOutput(`serviceBusTopicTrigger1 was triggered by \"${message}\"`);\n\t        await waitForOutput(`serviceBusTopicTrigger2 was triggered by \"${message}\"`);\n\t    });\n\t});\n"]}
{"filename": "src/http.test.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { expect } from 'chai';\n\timport { encode } from 'iconv-lite';\n\t// Node.js core added support for fetch in v18, but while we're testing versions <18 we'll use \"node-fetch\"\n\timport { HeadersInit, default as fetch } from 'node-fetch';\n\timport util from 'util';\n\timport { model } from './global.test';\n\tfunction getFuncUrl(functionName: string): string {\n\t    return `http://127.0.0.1:7071/api/${functionName}`;\n", "}\n\tconst helloWorld1Url = getFuncUrl('helloWorld1');\n\tconst httpRawBodyUrl = getFuncUrl('httpRawBody');\n\tfunction getContentTypeHeaders(contentType: string): HeadersInit {\n\t    return {\n\t        'content-type': contentType,\n\t    };\n\t}\n\tconst applicationJsonHeaders = getContentTypeHeaders('application/json');\n\tconst octetStreamHeaders = getContentTypeHeaders('application/octet-stream');\n", "const multipartFormHeaders = getContentTypeHeaders('multipart/form');\n\tconst textPlainHeaders = getContentTypeHeaders('text/plain');\n\tdescribe('http', () => {\n\t    it('hello world', async () => {\n\t        const response = await fetch(helloWorld1Url);\n\t        const body = await response.text();\n\t        expect(body).to.equal('Hello, world!');\n\t        expect(response.status).to.equal(200);\n\t    });\n\t    it('hello world name in body', async () => {\n", "        const response = await fetch(helloWorld1Url, { method: 'POST', body: 'testName' });\n\t        const body = await response.text();\n\t        expect(body).to.equal('Hello, testName!');\n\t        expect(response.status).to.equal(200);\n\t    });\n\t    it('hello world name in query', async () => {\n\t        const response = await fetch(`${helloWorld1Url}?name=testName`);\n\t        const body = await response.text();\n\t        expect(body).to.equal('Hello, testName!');\n\t        expect(response.status).to.equal(200);\n", "    });\n\t    it('No function', async () => {\n\t        const response = await fetch(getFuncUrl('doesntExist'));\n\t        const body = await response.text();\n\t        expect(body).to.equal('');\n\t        expect(response.status).to.equal(404);\n\t    });\n\t    it('Cookies', async () => {\n\t        const response = await fetch(getFuncUrl('httpCookies'));\n\t        const body = await response.text();\n", "        expect(body).to.equal('');\n\t        expect(response.status).to.equal(200);\n\t        const cookies = response.headers.get('Set-Cookie');\n\t        expect(cookies).to.equal(\n\t            'mycookie=myvalue; max-age=200000; path=/, mycookie2=myvalue; max-age=200000; path=/, mycookie3-expires=myvalue3-expires; max-age=0; path=/, mycookie4-samesite-lax=myvalue; path=/; samesite=lax, mycookie5-samesite-strict=myvalue; path=/; samesite=strict'\n\t        );\n\t    });\n\t    describe('v3 only', () => {\n\t        before(function (this: Mocha.Context) {\n\t            if (model !== 'v3') {\n", "                this.skip();\n\t            }\n\t        });\n\t        it('Json body', async () => {\n\t            for (const headers of [applicationJsonHeaders, textPlainHeaders]) {\n\t                const content = '{ \"a\": 1 }';\n\t                const response = await fetch(httpRawBodyUrl, {\n\t                    method: 'POST',\n\t                    body: content,\n\t                    headers,\n", "                });\n\t                const body = await response.json();\n\t                expect(body.body, 'body').to.deep.equal(JSON.parse(content));\n\t                expect(body.rawBody, 'rawBody').to.equal(content);\n\t                expect(body.bufferBody, 'bufferBody').to.equal(util.format(Buffer.from(content)));\n\t                expect(response.status).to.equal(200);\n\t            }\n\t        });\n\t        it('Json body invalid', async () => {\n\t            const content = '{ \"a\": 1, \"b\": }';\n", "            const response = await fetch(httpRawBodyUrl, {\n\t                method: 'POST',\n\t                body: content,\n\t                headers: applicationJsonHeaders,\n\t            });\n\t            const body = await response.json();\n\t            expect(body.body, 'body').to.equal(content);\n\t            expect(body.rawBody, 'rawBody').to.equal(content);\n\t            expect(body.bufferBody, 'bufferBody').to.equal(util.format(Buffer.from(content)));\n\t            expect(response.status).to.equal(200);\n", "        });\n\t        it('Json body stream/multipart type', async () => {\n\t            for (const headers of [\n\t                octetStreamHeaders,\n\t                multipartFormHeaders,\n\t                getContentTypeHeaders('multipart/whatever'),\n\t            ]) {\n\t                const content = '{ \"a\": 1 }';\n\t                const response = await fetch(httpRawBodyUrl, {\n\t                    method: 'POST',\n", "                    body: content,\n\t                    headers,\n\t                });\n\t                const body = await response.json();\n\t                const expectedBuffer = util.format(Buffer.from(content));\n\t                expect(body.body, 'body').to.equal(expectedBuffer);\n\t                expect(body.rawBody, 'rawBody').to.deep.equal(content);\n\t                expect(body.bufferBody, 'bufferBody').to.equal(expectedBuffer);\n\t                expect(response.status).to.equal(200);\n\t            }\n", "        });\n\t        it('Plain text', async () => {\n\t            for (const encoding of ['utf16be', 'utf16le', 'utf32le', 'utf8', 'utf32be']) {\n\t                const buffer = encode('abc', encoding);\n\t                const response = await fetch(httpRawBodyUrl, {\n\t                    method: 'POST',\n\t                    body: buffer,\n\t                    headers: textPlainHeaders,\n\t                });\n\t                const body = await response.json();\n", "                expect(body.body, 'body').to.equal(buffer.toString());\n\t                expect(body.rawBody, 'rawBody').to.equal(buffer.toString());\n\t                expect(body.bufferBody, 'bufferBody').to.equal(util.format(buffer));\n\t                expect(response.status).to.equal(200);\n\t            }\n\t        });\n\t    });\n\t});\n"]}
{"filename": "src/constants.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\texport namespace EnvVarNames {\n\t    export const storage = 'e2eTest_storage';\n\t    export const cosmosDB = 'e2eTest_cosmosDB';\n\t    export const eventHub = 'e2eTest_eventHub';\n\t    export const serviceBus = 'e2eTest_serviceBus';\n\t}\n\texport const defaultTimeout = 3 * 60 * 1000;\n\texport const combinedFolder = 'combined';\n", "export const oldBundleSuffix = '-oldBundle';\n"]}
{"filename": "src/getModelArg.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport parseArgs from 'minimist';\n\texport type Model = 'v3' | 'v4';\n\texport function getModelArg(): Model {\n\t    const args = parseArgs(process.argv.slice(2));\n\t    const modelArg: string = args.model || args.m;\n\t    if (modelArg === 'v3' || modelArg === 'v4') {\n\t        return modelArg;\n\t    } else {\n", "        throw new Error('You must pass in the model argument with \"--model\" or \"-m\". Valid values are \"v3\" or \"v4\".');\n\t    }\n\t}\n\texport function getOldBundleArg(): boolean {\n\t    const flag = 'oldBundle';\n\t    const args = parseArgs(process.argv.slice(2), { boolean: flag });\n\t    return args[flag];\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport globby from 'globby';\n\timport Mocha from 'mocha';\n\timport path from 'path';\n\timport { defaultTimeout } from './constants';\n\timport { getModelArg, getOldBundleArg } from './getModelArg';\n\texport async function run(): Promise<void> {\n\t    try {\n\t        const bundleSuffix = getOldBundleArg() ? '_oldBundle' : '';\n", "        const fileName = `${process.platform}_model-${getModelArg()}_Node-${process.version}${bundleSuffix}.xml`;\n\t        const options: Mocha.MochaOptions = {\n\t            color: true,\n\t            timeout: defaultTimeout,\n\t            reporter: 'mocha-multi-reporters',\n\t            reporterOptions: {\n\t                reporterEnabled: 'spec, mocha-junit-reporter',\n\t                mochaJunitReporterReporterOptions: {\n\t                    mochaFile: path.resolve(__dirname, '..', 'e2e-test-results', fileName),\n\t                },\n", "            },\n\t        };\n\t        addEnvVarsToMochaOptions(options);\n\t        const mocha = new Mocha(options);\n\t        const files: string[] = await globby('**/**.test.js', { cwd: __dirname });\n\t        files.forEach((f) => mocha.addFile(path.resolve(__dirname, f)));\n\t        const failures = await new Promise<number>((resolve) => mocha.run(resolve));\n\t        if (failures > 0) {\n\t            throw new Error(`${failures} tests failed.`);\n\t        }\n", "    } catch (err) {\n\t        console.error(err);\n\t        console.error('Test run failed');\n\t        process.exit(1);\n\t    }\n\t}\n\tfunction addEnvVarsToMochaOptions(options: Mocha.MochaOptions): void {\n\t    for (const envVar of Object.keys(process.env)) {\n\t        const match: RegExpMatchArray | null = envVar.match(/^mocha_(.+)/i);\n\t        if (match) {\n", "            const [, option] = match;\n\t            let value: string | number = process.env[envVar] || '';\n\t            if (typeof value === 'string' && !isNaN(parseInt(value))) {\n\t                value = parseInt(value);\n\t            }\n\t            (<any>options)[option] = value;\n\t        }\n\t    }\n\t}\n\tvoid run();\n"]}
{"filename": "src/global.test.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport cp from 'child_process';\n\timport path from 'path';\n\timport semver from 'semver';\n\timport { EnvVarNames, combinedFolder, defaultTimeout, oldBundleSuffix } from './constants';\n\timport { Model, getModelArg, getOldBundleArg } from './getModelArg';\n\timport {\n\t    cosmosDBConnectionString,\n\t    eventHubConnectionString,\n", "    initializeConnectionStrings,\n\t    serviceBusConnectionString,\n\t    storageConnectionString,\n\t} from './resources/connectionStrings';\n\timport { delay } from './utils/delay';\n\timport findProcess = require('find-process');\n\tlet perTestFuncOutput = '';\n\tlet fullFuncOutput = '';\n\texport let model: Model | undefined;\n\tlet childProc: cp.ChildProcess | undefined;\n", "let testsDone = false;\n\tbefore(async function (this: Mocha.Context): Promise<void> {\n\t    model = getModelArg();\n\t    if (model === 'v4' && semver.lt(process.versions.node, '18.0.0')) {\n\t        this.skip();\n\t    }\n\t    await killFuncProc();\n\t    await initializeConnectionStrings();\n\t    const appPath = getOldBundleArg()\n\t        ? path.join(__dirname, '..', 'app', combinedFolder, model + oldBundleSuffix)\n", "        : path.join(__dirname, '..', 'app', model);\n\t    startFuncProcess(appPath);\n\t    await waitForOutput('Host lock lease acquired by instance ID');\n\t    // Add slight delay after starting func to hopefully increase reliability of tests\n\t    await delay(30 * 1000);\n\t});\n\tafter(async () => {\n\t    testsDone = true;\n\t    await killFuncProc();\n\t});\n", "afterEach(async () => {\n\t    perTestFuncOutput = '';\n\t});\n\tasync function killFuncProc(): Promise<void> {\n\t    const results = await findProcess('port', 7071);\n\t    for (const result of results) {\n\t        console.log(`Killing process ${result.name} with id ${result.pid}`);\n\t        process.kill(result.pid, 'SIGINT');\n\t    }\n\t}\n", "export async function waitForOutput(data: string, checkFullOutput = false): Promise<void> {\n\t    const start = Date.now();\n\t    while (true) {\n\t        if (checkFullOutput && fullFuncOutput.includes(data)) {\n\t            return;\n\t        } else if (perTestFuncOutput.includes(data)) {\n\t            return;\n\t        } else if (Date.now() > start + defaultTimeout * 0.9) {\n\t            throw new Error(`Timed out while waiting for \"${data}\"`);\n\t        } else {\n", "            await delay(200);\n\t        }\n\t    }\n\t}\n\tfunction startFuncProcess(appPath: string): void {\n\t    const options: cp.SpawnOptions = {\n\t        cwd: appPath,\n\t        shell: true,\n\t        env: {\n\t            ...process.env,\n", "            AzureWebJobsStorage: storageConnectionString,\n\t            FUNCTIONS_WORKER_RUNTIME: 'node',\n\t            AzureWebJobsFeatureFlags: 'EnableWorkerIndexing',\n\t            logging__logLevel__Worker: 'debug',\n\t            [EnvVarNames.storage]: storageConnectionString,\n\t            [EnvVarNames.eventHub]: eventHubConnectionString,\n\t            [EnvVarNames.cosmosDB]: cosmosDBConnectionString,\n\t            [EnvVarNames.serviceBus]: serviceBusConnectionString,\n\t        },\n\t    };\n", "    const funcPath = path.join(__dirname, '..', 'func-cli', 'func');\n\t    childProc = cp.spawn(funcPath, ['start'], options);\n\t    childProc.stdout?.on('data', (data: string | Buffer) => {\n\t        data = data.toString();\n\t        process.stdout.write(data);\n\t        perTestFuncOutput += data;\n\t        fullFuncOutput += data;\n\t    });\n\t    childProc.stderr?.on('data', (data: string | Buffer) => {\n\t        data = data.toString();\n", "        process.stderr.write(data);\n\t        perTestFuncOutput += data;\n\t        fullFuncOutput += data;\n\t    });\n\t    childProc.on('error', (err) => {\n\t        if (!testsDone) {\n\t            console.error(err.message);\n\t            process.exit(1);\n\t        }\n\t    });\n", "    childProc.on('close', (code: number) => {\n\t        if (!testsDone) {\n\t            console.error(`func exited with code ${code}`);\n\t            process.exit(1);\n\t        }\n\t    });\n\t}\n"]}
{"filename": "src/createCombinedApps.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport fs from 'fs/promises';\n\timport path from 'path';\n\timport { combinedFolder, oldBundleSuffix } from './constants';\n\tasync function createCombinedApps(): Promise<void> {\n\t    const appRoot = path.join(__dirname, '..', 'app');\n\t    for (const model of ['v3', 'v4']) {\n\t        const modelRoot = path.join(appRoot, model);\n\t        const oldBundleRoot = path.join(appRoot, model + oldBundleSuffix);\n", "        const combinedRoot = path.join(appRoot, combinedFolder, model + oldBundleSuffix);\n\t        await fs.cp(modelRoot, combinedRoot, {\n\t            recursive: true,\n\t            filter: (source) => {\n\t                const foldersToExclude = ['dist', 'node_modules'];\n\t                return !foldersToExclude.find((f) => source.includes(f));\n\t            },\n\t        });\n\t        await fs.cp(oldBundleRoot, combinedRoot, { recursive: true });\n\t    }\n", "}\n\tvoid createCombinedApps();\n"]}
{"filename": "src/storage.test.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { ContainerClient } from '@azure/storage-blob';\n\timport { QueueClient } from '@azure/storage-queue';\n\timport { waitForOutput } from './global.test';\n\timport { storageConnectionString } from './resources/connectionStrings';\n\timport { getRandomTestData } from './utils/getRandomTestData';\n\tdescribe('storage', () => {\n\t    it('queue trigger and output', async () => {\n\t        const client = new QueueClient(storageConnectionString, 'e2etestqueue1');\n", "        await client.createIfNotExists();\n\t        const message = getRandomTestData();\n\t        await client.sendMessage(Buffer.from(message).toString('base64'));\n\t        await waitForOutput(`storageQueueTrigger1 was triggered by \"${message}\"`);\n\t        await waitForOutput(`storageQueueTrigger2 was triggered by \"${message}\"`);\n\t    });\n\t    it('blob trigger and output', async () => {\n\t        const client = new ContainerClient(storageConnectionString, 'e2etestcontainer');\n\t        await client.createIfNotExists();\n\t        const message = getRandomTestData();\n", "        const messageBuffer = Buffer.from(message);\n\t        await client.uploadBlockBlob('e2etestblob1', messageBuffer, messageBuffer.byteLength);\n\t        await waitForOutput(`storageBlobTrigger1 was triggered by \"${message}\"`);\n\t        await waitForOutput(`storageBlobTrigger2 was triggered by \"${message}\"`);\n\t    });\n\t});\n"]}
{"filename": "src/utils/nonNull.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\t/**\n\t * Retrieves a property by name from an object and checks that it's not null and not undefined.  It is strongly typed\n\t * for the property and will give a compile error if the given name is not a property of the source.\n\t */\n\texport function nonNullProp<TSource, TKey extends keyof TSource>(\n\t    source: TSource,\n\t    name: TKey\n\t): NonNullable<TSource[TKey]> {\n", "    const value: NonNullable<TSource[TKey]> = <NonNullable<TSource[TKey]>>source[name];\n\t    return nonNullValue(value, <string>name);\n\t}\n\t/**\n\t * Validates that a given value is not null and not undefined.\n\t */\n\texport function nonNullValue<T>(value: T | undefined | null, propertyNameOrMessage?: string): T {\n\t    if (value === null || value === undefined) {\n\t        throw new Error(\n\t            'Internal error: Expected value to be neither null nor undefined' +\n", "                (propertyNameOrMessage ? `: ${propertyNameOrMessage}` : '')\n\t        );\n\t    }\n\t    return value;\n\t}\n\texport function copyPropIfDefined<TData, TKey extends keyof TData>(source: TData, destination: TData, key: TKey): void {\n\t    if (source[key] !== null && source[key] !== undefined) {\n\t        destination[key] = source[key];\n\t    }\n\t}\n", "export function isDefined<T>(data: T | undefined | null): data is T {\n\t    return data !== null && data !== undefined;\n\t}\n"]}
{"filename": "src/utils/delay.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\texport async function delay(ms: number): Promise<void> {\n\t    await new Promise((resolve) => setTimeout(resolve, ms));\n\t}\n"]}
{"filename": "src/utils/getRandomTestData.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport crypto from 'crypto';\n\texport function getRandomTestData(): string {\n\t    // This should start with non-numeric data to prevent this bug from causing a test failure\n\t    // https://github.com/Azure/azure-functions-nodejs-library/issues/90\n\t    return `testData${getRandomHexString()}`;\n\t}\n\texport function getRandomHexString(length = 10): string {\n\t    const buffer: Buffer = crypto.randomBytes(Math.ceil(length / 2));\n", "    return buffer.toString('hex').slice(0, length);\n\t}\n"]}
{"filename": "src/utils/validateEnvVar.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { isDefined } from './nonNull';\n\texport function validateEnvVar(name: string): string {\n\t    const value = process.env[name];\n\t    if (!isDefined(value)) {\n\t        throw new Error(`You must set the environment variable \"${name}\".`);\n\t    }\n\t    return value;\n\t}\n"]}
{"filename": "src/resources/deleteResources.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { ResourceManagementClient } from '@azure/arm-resources';\n\timport { getResourceInfo } from './ResourceInfo';\n\tasync function deleteResources(): Promise<void> {\n\t    try {\n\t        const info = getResourceInfo();\n\t        const resourceClient = new ResourceManagementClient(info.creds, info.subscriptionId);\n\t        await resourceClient.resourceGroups.beginDelete(info.resourceGroupName);\n\t    } catch (err) {\n", "        console.error(err);\n\t        console.error('Delete resources failed');\n\t        process.exit(1);\n\t    }\n\t}\n\tvoid deleteResources();\n"]}
{"filename": "src/resources/cosmosDB.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { CosmosDBManagementClient } from '@azure/arm-cosmosdb';\n\timport { CosmosClient } from '@azure/cosmos';\n\timport { nonNullProp } from '../utils/nonNull';\n\timport { ResourceInfo } from './ResourceInfo';\n\tfunction getCosmosDBAccountName(info: ResourceInfo): string {\n\t    return info.resourcePrefix + 'comsosdb';\n\t}\n\texport const dbName = 'e2eTestDB';\n", "export const container1Name = 'e2eTestContainer1';\n\texport const container2Name = 'e2eTestContainer2';\n\texport async function createCosmosDB(info: ResourceInfo): Promise<void> {\n\t    const accountName = getCosmosDBAccountName(info);\n\t    const armClient = new CosmosDBManagementClient(info.creds, info.subscriptionId);\n\t    await armClient.databaseAccounts.beginCreateOrUpdateAndWait(info.resourceGroupName, accountName, {\n\t        location: info.location,\n\t        databaseAccountOfferType: 'Standard',\n\t        locations: [{ locationName: info.location }],\n\t    });\n", "    const connectionString = await getCosmosDBConnectionString(info);\n\t    const client = new CosmosClient(connectionString);\n\t    const res = await client.databases.create({\n\t        id: dbName,\n\t        throughput: 400,\n\t    });\n\t    for (const containerName of [container1Name, container2Name]) {\n\t        await res.database.containers.create({\n\t            id: containerName,\n\t        });\n", "    }\n\t}\n\texport async function getCosmosDBConnectionString(info: ResourceInfo): Promise<string> {\n\t    const accountName = getCosmosDBAccountName(info);\n\t    const client = new CosmosDBManagementClient(info.creds, info.subscriptionId);\n\t    const keys = await client.databaseAccounts.listKeys(info.resourceGroupName, accountName);\n\t    const key = nonNullProp(keys, 'primaryMasterKey');\n\t    return `AccountEndpoint=https://${accountName}.documents.azure.com:443/;AccountKey=${key};`;\n\t}\n"]}
{"filename": "src/resources/connectionStrings.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { getResourceInfo } from './ResourceInfo';\n\timport { getCosmosDBConnectionString } from './cosmosDB';\n\timport { getEventHubConnectionString } from './eventHub';\n\timport { getServiceBusConnectionString } from './serviceBus';\n\timport { getStorageConnectionString } from './storage';\n\texport let storageConnectionString: string;\n\texport let eventHubConnectionString: string;\n\texport let cosmosDBConnectionString: string;\n", "export let serviceBusConnectionString: string;\n\texport async function initializeConnectionStrings(): Promise<void> {\n\t    const info = getResourceInfo();\n\t    [storageConnectionString, eventHubConnectionString, cosmosDBConnectionString, serviceBusConnectionString] =\n\t        await Promise.all([\n\t            getStorageConnectionString(info),\n\t            getEventHubConnectionString(info),\n\t            getCosmosDBConnectionString(info),\n\t            getServiceBusConnectionString(info),\n\t        ]);\n", "}\n"]}
{"filename": "src/resources/createResources.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { ResourceManagementClient } from '@azure/arm-resources';\n\timport { getResourceInfo } from './ResourceInfo';\n\timport { createCosmosDB } from './cosmosDB';\n\timport { createEventHub } from './eventHub';\n\timport { createServiceBus } from './serviceBus';\n\timport { createStorageAccount } from './storage';\n\tasync function createResources(): Promise<void> {\n\t    try {\n", "        const info = getResourceInfo();\n\t        const resourceClient = new ResourceManagementClient(info.creds, info.subscriptionId);\n\t        await resourceClient.resourceGroups.createOrUpdate(info.resourceGroupName, { location: info.location });\n\t        await Promise.all([\n\t            createStorageAccount(info),\n\t            createEventHub(info),\n\t            createCosmosDB(info),\n\t            createServiceBus(info),\n\t        ]);\n\t    } catch (err) {\n", "        console.error(err);\n\t        console.error('Create resources failed');\n\t        process.exit(1);\n\t    }\n\t}\n\tvoid createResources();\n"]}
{"filename": "src/resources/storage.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { KnownKind, KnownSkuName, StorageManagementClient } from '@azure/arm-storage';\n\timport { nonNullProp, nonNullValue } from '../utils/nonNull';\n\timport { ResourceInfo } from './ResourceInfo';\n\tfunction getAccountName(info: ResourceInfo): string {\n\t    return info.resourcePrefix + 'sto';\n\t}\n\texport async function createStorageAccount(info: ResourceInfo): Promise<void> {\n\t    const client = new StorageManagementClient(info.creds, info.subscriptionId);\n", "    await client.storageAccounts.beginCreateAndWait(info.resourceGroupName, getAccountName(info), {\n\t        kind: KnownKind.StorageV2,\n\t        location: info.location,\n\t        sku: {\n\t            name: KnownSkuName.StandardLRS,\n\t        },\n\t    });\n\t}\n\texport async function getStorageConnectionString(info: ResourceInfo): Promise<string> {\n\t    const client = new StorageManagementClient(info.creds, info.subscriptionId);\n", "    const accountName = getAccountName(info);\n\t    const keys = await client.storageAccounts.listKeys(info.resourceGroupName, accountName);\n\t    const key = nonNullValue(nonNullProp(keys, 'keys')[0]?.value, 'storageKey');\n\t    return `DefaultEndpointsProtocol=https;AccountName=${accountName};AccountKey=${key};EndpointSuffix=core.windows.net`;\n\t}\n"]}
{"filename": "src/resources/eventHub.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { EventHubManagementClient, KnownSkuName } from '@azure/arm-eventhub';\n\timport { nonNullProp } from '../utils/nonNull';\n\timport { ResourceInfo } from './ResourceInfo';\n\tfunction getNamespaceName(info: ResourceInfo): string {\n\t    return info.resourcePrefix + 'eventhub';\n\t}\n\texport const eventHubOne = 'e2etesteventhubone';\n\texport const eventHubMany = 'e2etesteventhubmany';\n", "export async function createEventHub(info: ResourceInfo): Promise<void> {\n\t    const client = new EventHubManagementClient(info.creds, info.subscriptionId);\n\t    const namespaceName = getNamespaceName(info);\n\t    await client.namespaces.beginCreateOrUpdateAndWait(info.resourceGroupName, namespaceName, {\n\t        location: info.location,\n\t        sku: {\n\t            name: KnownSkuName.Standard,\n\t        },\n\t    });\n\t    for (const eventHubName of [eventHubOne, eventHubMany]) {\n", "        await client.eventHubs.createOrUpdate(info.resourceGroupName, namespaceName, eventHubName, {\n\t            messageRetentionInDays: 1,\n\t        });\n\t    }\n\t}\n\texport async function getEventHubConnectionString(info: ResourceInfo): Promise<string> {\n\t    const client = new EventHubManagementClient(info.creds, info.subscriptionId);\n\t    const keys = await client.namespaces.listKeys(\n\t        info.resourceGroupName,\n\t        getNamespaceName(info),\n", "        'RootManageSharedAccessKey'\n\t    );\n\t    return nonNullProp(keys, 'primaryConnectionString');\n\t}\n"]}
{"filename": "src/resources/serviceBus.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { ServiceBusManagementClient } from '@azure/arm-servicebus';\n\timport { nonNullProp } from '../utils/nonNull';\n\timport { ResourceInfo } from './ResourceInfo';\n\tfunction getNamespaceName(info: ResourceInfo): string {\n\t    return info.resourcePrefix + 'servicebus';\n\t}\n\texport const serviceBusQueue1 = 'e2etestqueue1';\n\texport const serviceBusQueue2 = 'e2etestqueue2';\n", "export const serviceBusTopic1 = 'e2etesttopic1';\n\texport const serviceBusTopic2 = 'e2etesttopic2';\n\texport const serviceBusSub = 'e2etestsub';\n\texport async function createServiceBus(info: ResourceInfo): Promise<void> {\n\t    const client = new ServiceBusManagementClient(info.creds, info.subscriptionId);\n\t    const namespaceName = getNamespaceName(info);\n\t    await client.namespaces.beginCreateOrUpdateAndWait(info.resourceGroupName, namespaceName, {\n\t        location: info.location,\n\t        sku: {\n\t            name: 'Standard',\n", "        },\n\t    });\n\t    for (const queueName of [serviceBusQueue1, serviceBusQueue2]) {\n\t        await client.queues.createOrUpdate(info.resourceGroupName, namespaceName, queueName, {});\n\t    }\n\t    for (const topicName of [serviceBusTopic1, serviceBusTopic2]) {\n\t        await client.topics.createOrUpdate(info.resourceGroupName, namespaceName, topicName, {});\n\t        await client.subscriptions.createOrUpdate(info.resourceGroupName, namespaceName, topicName, serviceBusSub, {});\n\t    }\n\t}\n", "export async function getServiceBusConnectionString(info: ResourceInfo): Promise<string> {\n\t    const client = new ServiceBusManagementClient(info.creds, info.subscriptionId);\n\t    const keys = await client.namespaces.listKeys(\n\t        info.resourceGroupName,\n\t        getNamespaceName(info),\n\t        'RootManageSharedAccessKey'\n\t    );\n\t    return nonNullProp(keys, 'primaryConnectionString');\n\t}\n"]}
{"filename": "src/resources/ResourceInfo.ts", "chunked_list": ["// Copyright (c) .NET Foundation. All rights reserved.\n\t// Licensed under the MIT License.\n\timport { EnvironmentCredential } from '@azure/identity';\n\timport { validateEnvVar } from '../utils/validateEnvVar';\n\texport interface ResourceInfo {\n\t    creds: EnvironmentCredential;\n\t    subscriptionId: string;\n\t    resourceGroupName: string;\n\t    resourcePrefix: string;\n\t    location: string;\n", "}\n\tfunction getResourcePrefix(): string {\n\t    const buildNumber = validateEnvVar('BUILD_BUILDNUMBER');\n\t    const jobAttempt = process.env['SYSTEM_JOBATTEMPT'] || '';\n\t    const result = 'e2e' + process.platform + buildNumber + jobAttempt;\n\t    return result.replace(/[^0-9a-zA-Z]/g, '');\n\t}\n\texport function getResourceInfo(): ResourceInfo {\n\t    validateEnvVar('AZURE_TENANT_ID');\n\t    validateEnvVar('AZURE_CLIENT_ID');\n", "    validateEnvVar('AZURE_CLIENT_SECRET');\n\t    const subscriptionId: string = validateEnvVar('AZURE_SUBSCRIPTION_ID');\n\t    const resourcePrefix = getResourcePrefix();\n\t    const creds = new EnvironmentCredential();\n\t    return {\n\t        creds,\n\t        subscriptionId,\n\t        resourcePrefix,\n\t        resourceGroupName: resourcePrefix + 'group',\n\t        location: 'eastus',\n", "    };\n\t}\n"]}
