{"filename": "src/main.ts", "chunked_list": ["import { NestFactory } from '@nestjs/core';\n\timport { AppModule } from './app.module';\n\timport { IoAdapter } from '@nestjs/platform-socket.io';\n\timport * as dotenv from 'dotenv';\n\timport * as path from 'path';\n\timport { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';\n\tdotenv.config({ path: path.resolve(__dirname, '../.env') });\n\tasync function bootstrap() {\n\t  const app = await NestFactory.create(AppModule);\n\t  const options = new DocumentBuilder()\n", "        .setTitle('API')\n\t        .setDescription('The API description')\n\t        .setVersion('1.0')\n\t        .addTag('nestjs-game-api')\n\t        .build();\n\t  const document = SwaggerModule.createDocument(app, options);\n\t  SwaggerModule.setup('api-docs', app, document);\n\t  app.useWebSocketAdapter(new IoAdapter(app));\n\t  app.enableCors();\n\t  await app.listen(3000);\n", "}\n\tbootstrap();\n"]}
{"filename": "src/app.module.ts", "chunked_list": ["import { CacheModule, MiddlewareConsumer, Module, RequestMethod } from '@nestjs/common';\n\timport { GatewayModule } from './socket-gateways/gateway.module';\n\timport path from 'path';\n\timport { resolve } from 'path';\n\timport * as dotenv from 'dotenv';\n\timport { ConfigModule } from '@nestjs/config';\n\timport { TypeOrmModule } from '@nestjs/typeorm';\n\timport { AuthModule } from './auth/auth.module';\n\timport { AuthTokenMiddleware } from './auth/authToken.middleware';\n\timport { UsersModule } from './pages/users/users.module';\n", "import { User } from './pages/users/user.entity';\n\timport { SchedulerModule } from './pages/schedule/scheduler.module';\n\timport { MatchModule } from './pages/match/match.module';\n\tdotenv.config({ path: resolve(__dirname, '../.env') });\n\t@Module({\n\t  imports: [\n\t    CacheModule.register(\n\t      {\n\t        isGlobal: true,\n\t        ttl: 60*60*12, // seconds\n", "        max: 1000, // maximum number of items in cache\n\t      },\n\t    ),\n\t    ConfigModule.forRoot({\n\t      isGlobal: true,\n\t      envFilePath: '.env',\n\t    }),\n\t    TypeOrmModule.forRoot({\n\t      type: 'mariadb',\n\t      host: process.env.DB_HOST || 'localhost',\n", "      port: parseInt(process.env.DB_PORT) as number,\n\t      username: process.env.DB_USER as string || 'abcd',\n\t      password: process.env.DB_PASS,\n\t      database: process.env.DB_DATABASE,\n\t      timezone: '+09:00',\n\t      entities: [User,],\n\t      synchronize: true,\n\t    }),\n\t    GatewayModule,\n\t    UsersModule,\n", "    AuthModule,\n\t    SchedulerModule,\n\t    MatchModule,\n\t  ],\n\t})\n\texport class AppModule {\n\t  configure(consumer: MiddlewareConsumer) {\n\t    consumer\n\t      .apply(AuthTokenMiddleware)\n\t      .forRoutes({ path: '*', method: RequestMethod.ALL });\n", "  }\n\t}\n"]}
{"filename": "src/socket-gateways/gateway.module.ts", "chunked_list": ["import { Module, forwardRef } from '@nestjs/common';\n\timport { CoreGateway } from './gateway.core';\n\timport { PlayerGateway } from './player/gateway.player';\n\timport { UsersModule } from 'src/pages/users/users.module';\n\timport { AuthModule } from 'src/auth/auth.module';\n\timport { BroadcastModule } from 'src/pages/broadcast/broadcast.module';\n\timport { Movement2dModule } from 'src/movement2d/movement2d.module';\n\timport { RedisCacheModule } from 'src/cache/redis.module';\n\timport { ChatModule } from 'src/pages/chat/chat.module';\n\timport { ChatGateWay } from './chat/gateway.chat';\n", "import { MatchModule } from 'src/pages/match/match.module';\n\timport { MatchGateway } from './match/gateway.match';\n\t@Module({\n\t    imports:[\n\t        UsersModule,\n\t        AuthModule,\n\t        BroadcastModule,\n\t        Movement2dModule,\n\t        RedisCacheModule,\n\t        forwardRef(() => MatchModule),\n", "        ChatModule,\n\t    ],\n\t    providers: [\n\t        CoreGateway,\n\t        PlayerGateway,\n\t        ChatGateWay,\n\t        MatchGateway,\n\t    ],\n\t    exports: [\n\t        CoreGateway,\n", "        PlayerGateway,\n\t        ChatGateWay,\n\t        MatchGateway,\n\t    ],\n\t})\n\texport class GatewayModule { }"]}
{"filename": "src/socket-gateways/gateway.core.ts", "chunked_list": ["import {\n\t    MessageBody,\n\t    SubscribeMessage,\n\t    WebSocketGateway,\n\t    WebSocketServer,\n\t} from '@nestjs/websockets';\n\timport { Server, Socket } from 'socket.io';\n\t@WebSocketGateway(8080, { \n\t    transports: ['websocket'] ,\n\t    cors: {\n", "        origin: '*',\n\t    },\n\t})\n\texport class CoreGateway {\n\t    @WebSocketServer()\n\t    server: Server;\n\t    @SubscribeMessage('ClientToServer')\n\t    async handleMessage(@MessageBody() data) {\n\t        const returnText = 'Server received: ' + data;\n\t        console.log(returnText);\n", "        this.server.emit('ServerToClient', returnText);\n\t    }\n\t    @SubscribeMessage('ping')\n\t    async handlePing(@MessageBody() data) {\n\t        this.server.emit('pong', 'pong');\n\t    }\n\t    async getClients(){\n\t        const socket = this.server.sockets.sockets;\n\t        return socket;\n\t    }\n", "}"]}
{"filename": "src/socket-gateways/player/gateway.player.ts", "chunked_list": ["import {\n\t    ConnectedSocket,\n\t    MessageBody,\n\t    SubscribeMessage,\n\t    WebSocketGateway,\n\t    WebSocketServer,\n\t} from '@nestjs/websockets';\n\timport { Server, Socket } from 'socket.io';\n\timport { UsersService } from 'src/pages/users/users.service';\n\timport { Movement2dService } from 'src/movement2d/movement2d.service';\n", "import { BroadcastService } from 'src/pages/broadcast/broadcast.service';\n\timport { RedisCacheService } from 'src/cache/redis.service';\n\timport { generateSessionId } from 'src/utils/util';\n\t/**\n\t * 본인의 캐릭터와 다른 플레이어의 캐릭터 정보를 주고 받는 게이트웨이\n\t * @Todo\n\t * 1. 본인의 캐릭터 정보를 Broadcast\n\t * 2. 다른 플레이어의 캐릭터 정보를 Broadcast\n\t * 3. 본인의 캐릭터 정보를 특정 플레이어에게 전송\n\t * 4. 다른 플레이어의 캐릭터 정보를 특정 플레이어에게 전송\n", " * \n\t * @Memo\n\t * - 데드레커닝은 충돌체로 인한 위치 정보가 바뀌지 않을 때 사용하기에 적합하다.\n\t */\n\t@WebSocketGateway(8080, { \n\t    transports: ['websocket'] ,\n\t    cors: {\n\t        origin: '*',\n\t    },\n\t})\n", "export class PlayerGateway {\n\t    constructor(\n\t        private userService: UsersService,\n\t        private broadcastService: BroadcastService,\n\t        private movemoent2dService: Movement2dService,\n\t        private redisService: RedisCacheService,\n\t    ) {}\n\t    @WebSocketServer()\n\t    server: Server;\n\t    /**\n", "     * \n\t     * @todo\n\t     * - 다중 클라이언트 접속 시 처리 \n\t     */\n\t    async handleConnection(client: Socket) {\n\t        // const test = setInterval(async () => {\n\t        //     console.log('ping');\n\t        // }, 1000);\n\t        // const testId = test[Symbol.toPrimitive]() as number;\n\t        // console.log(testId)\n", "        // const end = setTimeout(async () => {\n\t        //     clearInterval(testId);\n\t        //     console.log('pong');\n\t        // }, 5000);\n\t        const reqHeaders = client.handshake.headers;\n\t        let refreshToken = '';\n\t        if(reqHeaders.refresh_token) refreshToken = reqHeaders.refresh_token as string;\n\t        else refreshToken = client.handshake.auth.refresh_token as string;\n\t        // if(!reqHeaders.refreshToken) throw new Error('No refreshToken');\n\t        try{\n", "            const user = await this.userService.getUser(refreshToken);\n\t            if(user.statusCode == '404') throw new Error('User not found');\n\t            const userObj = user.contents;\n\t            const socketId = client.id;\n\t            const socketIdUpdate = await this.userService.socketIdUpdate(userObj, socketId);\n\t            if(socketIdUpdate.statusCode == '404') throw new Error('User not found');\n\t            await this.redisService.set(socketId, userObj.customId);\n\t            console.log('PlayerGateway: ' + userObj.customId + ' connected');\n\t            // 유저 정보 broadcast\n\t            const {x , y} = await this.redisService.get(userObj.customId + \"_position\") || {x: 0, y: 0};\n", "            // connection to socket\n\t            const otherUsers = await this.userService.getConnectedUser();\n\t            const otherPlayerInfo : {\n\t                customId: string,\n\t                x: number,\n\t                y: number,\n\t            }[] = [];\n\t            for(let i = 0; i < otherUsers.contents.length; i++){\n\t                const {customId} = otherUsers.contents[i];\n\t                if(customId == userObj.customId) continue;\n", "                const {x, y} = await this.redisService.get(customId + \"_position\") || {x: 0, y: 0};\n\t                otherPlayerInfo.push({\n\t                    customId: customId,\n\t                    x: x,\n\t                    y: y,\n\t                });\n\t            }\n\t            client.emit(\"connection\", {\n\t                myInfo: {\n\t                    customId : userObj.customId,\n", "                    x: x,\n\t                    y: y,\n\t                },\n\t                otherPlayer : otherPlayerInfo,\n\t            });\n\t            await this.broadcastService.serverBroadcast(this.server, 'enter_lobby', {\n\t                player: userObj.customId,\n\t                x: x,\n\t                y: y,\n\t            });\n", "        }\n\t        catch(e){\n\t            console.log(e);\n\t            client.disconnect();\n\t        }\n\t    }\n\t    async handleDisconnect(client: Socket) {\n\t        const reqHeaders = client.handshake.headers;\n\t        let refreshToken = '';\n\t        if(reqHeaders.refresh_token) refreshToken = reqHeaders.refresh_token as string;\n", "        else refreshToken = client.handshake.auth.refresh_token as string;\n\t        try{\n\t            const socketIdUpdate = await this.userService.disconnectSocketId(client.id);\n\t            if(socketIdUpdate.statusCode == '404') throw new Error('User not found');\n\t            console.log('PlayerGateway: ' + socketIdUpdate.contents.customId + ' disconnected');\n\t            const check = await this.redisService.get(client.id);\n\t            if(check){\n\t                await this.redisService.del(client.id);\n\t            }\n\t            ['w','a','s','d'].forEach(async (key) => {\n", "                const interval = await this.redisService.get(socketIdUpdate.contents.customId + \"_interval_\" + key);\n\t                if(interval){\n\t                    clearInterval(interval);\n\t                    await this.redisService.del(socketIdUpdate.contents.customId + \"_interval_\" + key);\n\t                }\n\t            });\n\t            await this.broadcastService.serverBroadcast(this.server, 'disconnection', {\n\t                player: socketIdUpdate.contents.customId,\n\t            });\n\t        }       \n", "        catch(e){\n\t            client.disconnect();\n\t        }\n\t    }\n\t    /**\n\t     * @Description\n\t     * 2Directional Movement (2D)를 처리하는 메소드.\n\t     * 키보드 입력을 받아서 처리함.\n\t     */\n\t    @SubscribeMessage('move2d_key')\n", "    async handleMove2d(\n\t        @MessageBody() data : { key: string, isUp: boolean, timestamp: number },\n\t        @ConnectedSocket() client: Socket,\n\t    ) {\n\t        try{\n\t            const userCustomId = await this.redisService.get(client.id);\n\t            if(!userCustomId) throw new Error('User not found');\n\t            if(!data.key) throw new Error('Key not found');\n\t            if(data.isUp == undefined) throw new Error('isUp not found');\n\t            const pos = await this.redisService.get(userCustomId + \"_position\");\n", "            if (!pos||!pos.hasOwnProperty('x')||!pos.hasOwnProperty('y')||pos.x==undefined||pos.y==undefined) {\n\t                const rand_session_id = generateSessionId();\n\t                client.emit(\"request_position\", userCustomId + \"_\" + rand_session_id);\n\t                await this.redisService.set(userCustomId + \"_\" + rand_session_id, { clientId: client.id, key: data.key, isUp: data.isUp, timestamp: data.timestamp});\n\t                return;\n\t            }\n\t            await this.movemoent2dService.move2d_key(this.server, 'returnMove2dKey', userCustomId, data.key, data.isUp);\n\t        }catch(e){\n\t            client.emit('error', e.message);\n\t        }\n", "    }\n\t    /**\n\t     * @Description\n\t     * 클라이언트로부터 본인의 위치 정보를 받아서 처리하는 메소드.\n\t     * request 전용.\n\t     */\n\t    @SubscribeMessage('response_position_key')\n\t    async handlePlayerPosition(\n\t        @MessageBody() data: { x: number, y: number, session_id: string},\n\t        @ConnectedSocket() client: Socket,\n", "    ) {\n\t        try{\n\t            const userCustomId = await this.redisService.get(client.id);\n\t            if(!userCustomId) throw new Error('User not found');\n\t            if(data.x == undefined || data.y == undefined) throw new Error('Position not found');\n\t            if(!data.session_id) throw new Error('Session id not found');\n\t            const session_data = await this.redisService.get(data.session_id);\n\t            if(!session_data||session_data.clientId != client.id) throw new Error('Invalid session');\n\t            await this.redisService.set(userCustomId + \"_position\", { x: data.x, y: data.y });\n\t            const key = session_data.key;\n", "            const isUp = session_data.isUp;\n\t            await this.movemoent2dService.move2d_key(this.server, 'returnMove2dKey', userCustomId, key, isUp);\n\t            await this.redisService.del(data.session_id);\n\t        }catch(e){\n\t            client.emit('error', e.message);\n\t        }\n\t    }\n\t    /**\n\t     * @Description\n\t     * 2Directional Movement (2D)를 처리하는 메소드.\n", "     * 이동 방향을 받아서 처리함.\n\t     */\n\t    @SubscribeMessage('move2d_direction')\n\t    async handleMove2dDirection(\n\t        @MessageBody() data: { direction: string },\n\t        @ConnectedSocket() client: Socket,\n\t    ) {\n\t        try{\n\t            const userCustomId = await this.redisService.get(client.id);\n\t            if(!userCustomId) throw new Error('User not found');\n", "            if(!data.direction) throw new Error('Direction not found');\n\t            await this.movemoent2dService.move2d_direction(this.server, 'returnMove2dDirection', userCustomId, data.direction);\n\t        }catch(e){\n\t            client.emit('error', e.message);\n\t        }\n\t    }\n\t}"]}
{"filename": "src/socket-gateways/chat/gateway.chat.ts", "chunked_list": ["import { ConnectedSocket, MessageBody, SubscribeMessage, WebSocketGateway, WebSocketServer } from \"@nestjs/websockets\";\n\timport { Server, Socket } from \"socket.io\";\n\timport { RedisCacheService } from \"src/cache/redis.service\";\n\timport { BroadcastService } from \"src/pages/broadcast/broadcast.service\";\n\timport { UsersService } from \"src/pages/users/users.service\";\n\t@WebSocketGateway(8080, {\n\t    transports: ['websocket'],\n\t    cors: {\n\t        origin: '*',\n\t    },\n", "})\n\texport class ChatGateWay {\n\t    constructor(\n\t        private userService: UsersService,\n\t        private broadcastService: BroadcastService,\n\t        private redisService: RedisCacheService,\n\t    ) { }\n\t    @WebSocketServer()\n\t    server: Server;\n\t    @SubscribeMessage('send_chat')\n", "    async handleChat(\n\t        @MessageBody() data: { message: string },\n\t        @ConnectedSocket() client: Socket\n\t    ) {\n\t        try {\n\t            const userCustomId = await this.redisService.get(client.id);\n\t            if (!userCustomId) throw new Error('User not found');\n\t            if (!data.message) throw new Error('Message is undefined');\n\t            if (data.message.replace(/\\s/g, '').length == 0) throw new Error('Message is empty');\n\t            if (data.message.length > 100) throw new Error('Message is too long');\n", "            const returnObj = {\n\t                type: \"message\",\n\t                message: data.message,\n\t                sender: userCustomId,\n\t                timestamp: new Date().getTime(),\n\t            }\n\t            const chatLog: Object[] = await this.redisService.get('chatLog');\n\t            if(chatLog) await this.redisService.set('chatLog', [...chatLog, returnObj]);\n\t            else await this.redisService.set('chatLog', [returnObj]);\n\t            this.server.emit('receive_chat', returnObj);\n", "        } catch (err) {\n\t            client.emit('error', err.message);\n\t        }\n\t    }\n\t}"]}
{"filename": "src/socket-gateways/match/gateway.match.ts", "chunked_list": ["import { WebSocketGateway, WebSocketServer } from \"@nestjs/websockets\";\n\timport { Server } from \"socket.io\";\n\timport { MatchStatus, MatchDto, CustomMatchDto } from \"src/pages/match/dto/match.dto\";\n\t@WebSocketGateway(8080, {\n\t    transports: ['websocket'],\n\t    cors: {\n\t        origin: '*',\n\t    },\n\t})\n\texport class MatchGateway {\n", "    constructor() { }\n\t    @WebSocketServer()\n\t    server: Server;\n\t    async broadcastMatchinfo(\n\t        info_type: MatchStatus,\n\t        socketId: string,\n\t        userId: string,\n\t        matchInfo: MatchDto | CustomMatchDto\n\t    ) {\n\t        this.server.to(socketId).emit(info_type, {\n", "            userId: userId,\n\t            matchInfo: matchInfo,\n\t        });\n\t    }\n\t}"]}
{"filename": "src/pages/chat/chat.module.ts", "chunked_list": ["import { Module, forwardRef } from '@nestjs/common';\n\timport { TypeOrmModule } from '@nestjs/typeorm';\n\timport { AuthModule } from 'src/auth/auth.module';\n\timport { ChatService } from './chat.service';\n\timport { RedisCacheModule } from 'src/cache/redis.module';\n\timport { ChatController } from './chat.controller';\n\timport { GatewayModule } from 'src/socket-gateways/gateway.module';\n\t@Module({\n\t    imports: [\n\t        TypeOrmModule.forFeature([]),\n", "        AuthModule,\n\t        RedisCacheModule,\n\t        forwardRef(() => GatewayModule),\n\t    ],\n\t    controllers: [ChatController],\n\t    providers: [ChatService],\n\t    exports: [ChatService],\n\t})\n\texport class ChatModule { }\n"]}
{"filename": "src/pages/chat/chat.service.ts", "chunked_list": ["import { Injectable } from \"@nestjs/common\";\n\timport { Server, Socket } from \"socket.io\";\n\timport { RedisCacheService } from \"src/cache/redis.service\";\n\timport { ChatDto } from \"./dto/chat.dto\";\n\t@Injectable()\n\texport class ChatService {\n\t    constructor(\n\t        private redisService: RedisCacheService,\n\t    ){}\n\t    async getChatLog(limit: number): Promise<ChatDto[]>{\n", "        try{\n\t            const chatLog = await this.redisService.get(\"chatLog\");\n\t            if(!chatLog) {\n\t                await this.redisService.set(\"chatLog\", []);\n\t                return [];\n\t            }\n\t            if(chatLog.length > limit) return chatLog.slice(chatLog.length - limit, chatLog.length);\n\t            else return chatLog;\n\t        }catch(e){\n\t            throw new Error(e);\n", "        }\n\t    }\n\t}"]}
{"filename": "src/pages/chat/chat.controller.ts", "chunked_list": ["import{ Controller, Get, Param, Query } from '@nestjs/common';\n\timport { ApiOperation, ApiResponse, ApiTags } from '@nestjs/swagger';\n\timport { ChatService } from './chat.service';\n\timport { ChatDto } from './dto/chat.dto';\n\t@Controller('chat')\n\t@ApiTags('채팅')\n\texport class ChatController {\n\t    constructor(\n\t        private readonly chatService: ChatService,\n\t    ){}\n", "    @Get('log')\n\t    @ApiOperation({\n\t        summary: '채팅 로그 가져오기',\n\t        description: '채팅 로그를 가져옵니다.'\n\t    })\n\t    @ApiResponse({\n\t        description: '채팅 로그 가져오기 성공',\n\t        type: ChatDto,\n\t        status: 200\n\t    })\n", "    async getChatLog(\n\t        @Query('limit') limit: number = 10\n\t    ): Promise<ChatDto[]>{\n\t        try{\n\t            const result = await this.chatService.getChatLog(limit);\n\t            return result;\n\t        }catch(e){\n\t            throw new Error(e);\n\t        }\n\t    }\n", "}"]}
{"filename": "src/pages/chat/dto/chat.dto.ts", "chunked_list": ["export class ChatDto {\n\t    type: string;\n\t    message: string;\n\t    sender: string;\n\t    timestamp: number;\n\t}"]}
{"filename": "src/pages/users/user.repository.ts", "chunked_list": ["import { DataSource, Repository } from \"typeorm\";\n\timport { User } from \"./user.entity\";\n\timport * as bcrypt from 'bcryptjs';\n\timport { ConflictException, Injectable, InternalServerErrorException } from \"@nestjs/common\";\n\timport { AuthCredentialDto } from \"src/auth/dto/auth-credential.dto\";\n\t@Injectable()\n\texport class UserRepository extends Repository<User>{\n\t    constructor(private dataSource: DataSource) {\n\t        super(User, dataSource.createEntityManager());\n\t    }\n", "    async createUser(authCredentialDto: AuthCredentialDto): Promise<User> {\n\t        const { customId, name, email, password } = authCredentialDto;\n\t        const salt = await bcrypt.genSalt();\n\t        const hashedPassword = await bcrypt.hash(password, salt);\n\t        const user = this.create({\n\t            customId,\n\t            name,\n\t            email,\n\t            password : hashedPassword\n\t        })\n", "        try{\n\t            await this.save(user);\n\t            return user;\n\t        }\n\t        catch(error){\n\t            if(error.code === '23505'){\n\t                throw new ConflictException('User already exists');\n\t            }\n\t            else{\n\t                console.log(error);\n", "                throw new InternalServerErrorException();\n\t            }\n\t        }\n\t    }\n\t}"]}
{"filename": "src/pages/users/user.entity.ts", "chunked_list": ["import { ApiProperty } from '@nestjs/swagger';\n\timport { BaseEntity, Column, Entity, PrimaryGeneratedColumn, Unique } from 'typeorm';\n\t@Entity()\n\t@Unique(['customId'])\n\texport class User extends BaseEntity{\n\t    @ApiProperty({description: '사용자 고유번호', example: '1'})\n\t    @PrimaryGeneratedColumn()\n\t    id: number;\n\t    @ApiProperty({description: '사용자 아이디', example: 'jswcyber'})\n\t    @Column()\n", "    customId: string;\n\t    @ApiProperty({description: '사용자 이름', example: '정성욱'})\n\t    @Column({ length: 30 })\n\t    name: string;\n\t    @ApiProperty({description: '사용자 이메일', example: 'jswcyber@naver.com'})\n\t    @Column({ length: 60 })\n\t    email: string;\n\t    @ApiProperty({description: '사용자 비밀번호', example: 'Qlalfqjsgh1234!@'})\n\t    @Column()\n\t    password: string;\n", "    @ApiProperty({description: '사용자 권한', example: 'admin'})\n\t    @Column({ default:1 })\n\t    role: number;\n\t    @ApiProperty({description: 'Refresh Token'})\n\t    @Column({ nullable: true })\n\t    refreshToken: string;\n\t    @ApiProperty({description: '소켓 아이디'})\n\t    @Column({ nullable: true })\n\t    socketId: string;\n\t    @ApiProperty({description: '가입일', example: '2021-01-01 00:00:00'})\n", "    @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })\n\t    createdAt: Date;\n\t    @ApiProperty({description: '마지막 접속일', example: '2021-01-01 00:00:00'})\n\t    @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })\n\t    updatedAt: Date;\n\t    @ApiProperty({description: '접속 종료일', example: '2021-01-01 00:00:00'})\n\t    @Column({ type: 'timestamp', nullable: true })\n\t    exitAt: Date;\n\t}"]}
{"filename": "src/pages/users/users.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { UsersService } from './users.service';\n\timport { UsersController } from './users.controller';\n\timport { TypeOrmModule } from '@nestjs/typeorm';\n\timport { UserRepository } from './user.repository';\n\timport { AuthModule } from 'src/auth/auth.module';\n\timport { User } from './user.entity';\n\t@Module({\n\t  imports: [\n\t    TypeOrmModule.forFeature([User]),\n", "    AuthModule\n\t  ],\n\t  controllers: [UsersController],\n\t  providers: [UsersService, UserRepository],\n\t  exports: [UsersService],\n\t})\n\texport class UsersModule {}\n"]}
{"filename": "src/pages/users/users.service.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\n\timport { InjectRepository } from '@nestjs/typeorm';\n\timport { CreateUserDto } from './dto/create-user.dto';\n\timport { User } from './user.entity';\n\timport { UserRepository } from './user.repository';\n\timport { EntityManager, IsNull, Not } from 'typeorm';\n\timport * as bcrypt from 'bcryptjs';\n\timport * as jwt from 'jsonwebtoken';\n\timport { Server, Socket } from 'socket.io';\n\t@Injectable()\n", "export class UsersService {\n\t  constructor(\n\t    @InjectRepository(UserRepository)\n\t    private userRepository: UserRepository\n\t  ) { }\n\t  async getAllUsers(): Promise<{ statusCode: string, contents: User[] }> {\n\t    const userObj = await this.userRepository.find();\n\t    return { statusCode: '200', contents: userObj };\n\t  }\n\t  async getUserInfo(user: User): Promise<{ statusCode: string, contents: User }> {\n", "    const userObj = await this.userRepository.findOne({ where: { customId: user.customId } });\n\t    return { statusCode: '200', contents: userObj };\n\t  }\n\t  async getUser(refreshToken: string): Promise<{ statusCode: string, contents: User }> {\n\t    const userId = await jwt.verify(refreshToken, process.env.JWT_REFRESH_TOKEN_SECRET, (err, decoded) => {\n\t      if (err) {\n\t        return null;\n\t      }\n\t      return decoded['id'];\n\t    });\n", "    if (userId == null) {\n\t      return { statusCode: '404', contents: null };\n\t    }\n\t    const userObj = await this.userRepository.createQueryBuilder(\"user\")\n\t      .select([\"user.id\", \"user.customId\", \"user.name\", \"user.email\", \"user.role\", \"user.refreshToken\", \"user.socketId\"])\n\t      .where('user.id = :id', { id: userId })\n\t      .getOne();\n\t    return { statusCode: '200', contents: userObj };\n\t  }\n\t  async socketIdUpdate(user: User, socketId: string): Promise<{ statusCode: string, contents: User }> {\n", "    const userObj = await this.userRepository.findOne({ where: { customId: user.customId } });\n\t    userObj.socketId = socketId;\n\t    userObj.updatedAt = new Date();\n\t    await this.userRepository.save(userObj);\n\t    return { statusCode: '200', contents: userObj };\n\t  }\n\t  async disconnectSocketId(socketId: string): Promise<{ statusCode: string, contents: User }> {\n\t    const userObj = await this.userRepository.findOne({ where: { socketId: socketId } });\n\t    userObj.socketId = null;\n\t    userObj.exitAt = new Date();\n", "    await this.userRepository.save(userObj);\n\t    return { statusCode: '200', contents: userObj };\n\t  }\n\t  async updateDisconnectSocketId(customId: string): Promise<{ statusCode: string, contents: User }> {\n\t    const userObj = await this.userRepository.findOne({ where: { customId: customId } });\n\t    userObj.socketId = null;\n\t    userObj.exitAt = new Date();\n\t    await this.userRepository.save(userObj);\n\t    return { statusCode: '200', contents: userObj };\n\t  }\n", "  async userSocketConnectionCheck(userId: number) {\n\t    const userObj = await this.userRepository.findOne({ where: { id: userId } });\n\t    if (userObj.socketId == null) {\n\t      return;\n\t    }\n\t    return { statusCode: '200', contents: userObj };\n\t  }\n\t  async getUserByCustomId(customId: string): Promise<{ statusCode: string, contents: User }> {\n\t    const userObj = await this.userRepository.findOne({ where: { customId: customId } });\n\t    return { statusCode: '200', contents: userObj };\n", "  }\n\t  async getConnectedUser(): Promise<{ statusCode: string, contents: User[] }> {\n\t    //socketId가 null이 아닌 유저들을 가져온다.\n\t    const userObj = await this.userRepository.find({ where: { socketId: Not(IsNull()) } });\n\t    return { statusCode: '200', contents: userObj };\n\t  }\n\t}"]}
{"filename": "src/pages/users/users.controller.ts", "chunked_list": ["import { Controller, Get, Post, Body, Patch, Param, Delete, UseGuards } from '@nestjs/common';\n\timport { UsersService } from './users.service';\n\timport { CreateUserDto } from './dto/create-user.dto';\n\timport { AuthGuard } from '@nestjs/passport';\n\timport { User } from './user.entity';\n\timport { GetUser } from 'src/auth/get-user.decorator';\n\timport { ApiTags } from '@nestjs/swagger';\n\t@Controller('users')\n\t@ApiTags('회원 정보')\n\texport class UsersController {\n", "  constructor(private readonly usersService: UsersService) {}\n\t  @Get()\n\t  @UseGuards(AuthGuard(\"jwt\"))\n\t  getUserInfo(@GetUser() user:User) : Promise<{statusCode:string, contents:User}> {\n\t    return this.usersService.getUserInfo(user);\n\t  }\n\t}"]}
{"filename": "src/pages/users/dto/user-info.dto.ts", "chunked_list": ["export enum UserStatus {\n\t    ONLINE = 'online',\n\t    OFFLINE = 'offline',\n\t    RANDOM_MATCHING = 'random_matching',\n\t    CUSTOM_MATCHING = 'custom_matching',\n\t    MATCHING_SUCCESS = 'matching_success',\n\t}\n\texport class UserInfo {\n\t    status: UserStatus;\n\t}"]}
{"filename": "src/pages/users/dto/create-user.dto.ts", "chunked_list": ["import { IsNotEmpty } from \"class-validator\";\n\texport class CreateUserDto {\n\t    @IsNotEmpty()\n\t    customId: string;\n\t    @IsNotEmpty()\n\t    name: string;\n\t    @IsNotEmpty()\n\t    email: string;\n\t    @IsNotEmpty()\n\t    password: string;\n", "}\n"]}
{"filename": "src/pages/match/match.service.ts", "chunked_list": ["import { HttpException, HttpStatus, Injectable } from \"@nestjs/common\";\n\timport { Server, Socket } from \"socket.io\";\n\timport { RedisCacheService } from \"src/cache/redis.service\";\n\timport { MatchStatus, MatchDto, MatchType, MatchCreateDto, MatchJoinDto, CustomMatchDto } from \"./dto/match.dto\";\n\timport { generateSessionId } from \"src/utils/util\";\n\timport { MatchGateway } from \"src/socket-gateways/match/gateway.match\";\n\timport { UsersService } from \"../users/users.service\";\n\timport { UserInfo, UserStatus } from \"../users/dto/user-info.dto\";\n\t/**\n\t * @todo\n", " * @notice\n\t * - 모든 대기열이나 방들은 Redis 에 저장되어야 한다.\n\t * - 끝에 _queue 를 붙여서 저장한다.\n\t */\n\t@Injectable()\n\texport class MatchService {\n\t    constructor(\n\t        private redisService: RedisCacheService,\n\t        private matchGateway: MatchGateway,\n\t        private usersService: UsersService,\n", "    ) { }\n\t    async updateMatchQueue(matchType: MatchType, queue: MatchDto[]): Promise<void> {\n\t        try {\n\t            await this.redisService.set(matchType + \"_queue\", queue);\n\t        } catch (e) {\n\t            throw new Error(e);\n\t        }\n\t    }\n\t    async getMatchQueue(matchType: string): Promise<MatchDto[]> {\n\t        try {\n", "            const queue: MatchDto[] = await this.redisService.get(matchType + \"_queue\");\n\t            return queue;\n\t        }\n\t        catch (e) {\n\t            throw new Error(e);\n\t        }\n\t    }\n\t    // Cron 에서 유저를 다른 매치로 옮기는 작업을 수행할 때 사용한다.\n\t    async replaceMatchQueue(customIds: string[]): Promise<void> {\n\t        try {\n", "            customIds.forEach(async (customId: string) => {\n\t                const match = await this.randomMatch_1on1_queue(customId);\n\t                const socketId = (await this.usersService.getUser(customId)).contents.socketId;\n\t                await this.matchGateway.broadcastMatchinfo(MatchStatus.MATCH_CHANGE, socketId, customId, match);\n\t            });\n\t        }\n\t        catch (e) {\n\t            throw new Error(e);\n\t        }\n\t    }\n", "    async randomMatch_1on1_queue(customId: string) {\n\t        try {\n\t            const user = await this.usersService.getUserByCustomId(customId);\n\t            const queue: MatchDto[] = await this.redisService.get(MatchType.RANDOM_MATCH_1ON1 + \"_queue\");\n\t            if (!queue) {\n\t                const newQueue: MatchDto[] = [];\n\t                const matchId = generateSessionId();\n\t                const newMatch: MatchDto = {\n\t                    match_id: matchId,\n\t                    match_type: MatchType.RANDOM_MATCH_1ON1,\n", "                    match_status: MatchStatus.MATCH_START,\n\t                    match_start_time: new Date(),\n\t                    match_end_time: null,\n\t                    join_user: [customId],\n\t                };\n\t                newQueue.push(newMatch);\n\t                await this.redisService.set(MatchType.RANDOM_MATCH_1ON1 + \"_queue\", newQueue);\n\t                this.matchGateway.broadcastMatchinfo(MatchStatus.MATCH_START, user.contents.socketId, customId, newMatch);\n\t                return newMatch;\n\t            }\n", "            const match: MatchDto = queue.find((match: MatchDto) => match.match_status === MatchStatus.MATCH_START && match.join_user.length < 2);\n\t            if (match) {\n\t                match.join_user.push(customId);\n\t                await this.redisService.set(MatchType.RANDOM_MATCH_1ON1 + \"_queue\", queue);\n\t                this.matchGateway.broadcastMatchinfo(MatchStatus.MATCH_START, user.contents.socketId, customId, match);\n\t                return match;\n\t            } else {\n\t                const matchId = generateSessionId();\n\t                const newMatch: MatchDto = {\n\t                    match_id: matchId,\n", "                    match_type: MatchType.RANDOM_MATCH_1ON1,\n\t                    match_status: MatchStatus.MATCH_START,\n\t                    match_start_time: new Date(),\n\t                    match_end_time: null,\n\t                    join_user: [customId],\n\t                };\n\t                queue.push(newMatch);\n\t                await this.redisService.set(MatchType.RANDOM_MATCH_1ON1 + \"_queue\", queue);\n\t                this.matchGateway.broadcastMatchinfo(MatchStatus.MATCH_START, user.contents.socketId, customId, newMatch);\n\t                return newMatch;\n", "            }\n\t        } catch (e) {\n\t            throw new Error(e);\n\t        }\n\t    }\n\t    async createCustomMatch(customId: string, dto: MatchCreateDto) {\n\t        try {\n\t            const user = await this.usersService.getUserByCustomId(customId);\n\t            const user_status: UserInfo = await this.redisService.get(customId + \"_info\");\n\t            if (\n", "                !user_status\n\t                || !user_status.status\n\t                || user_status.status == UserStatus.CUSTOM_MATCHING\n\t                || user_status.status == UserStatus.MATCHING_SUCCESS\n\t                || user_status.status == UserStatus.RANDOM_MATCHING\n\t                || user_status.status == UserStatus.OFFLINE\n\t            ) throw new Error(\"방을 생성할 수 없습니다.\");\n\t            const match: CustomMatchDto = {\n\t                match_id: generateSessionId(),\n\t                match_type: dto.match_type,\n", "                match_status: MatchStatus.MATCH_START,\n\t                match_start_time: new Date(),\n\t                match_end_time: null,\n\t                join_user: [customId],\n\t                match_title: dto.match_title,\n\t                match_private: dto.match_private,\n\t                match_owner: customId,\n\t            }\n\t            if(match.match_private) match.match_password = dto.match_password;\n\t            await this.redisService.push(dto.match_type + \"_queue\", match);\n", "            await this.matchGateway.broadcastMatchinfo(MatchStatus.MATCH_CREATE, user.contents.socketId, customId, match);\n\t            return match;\n\t        } catch (e) {\n\t            throw new Error(e);\n\t        }\n\t    }\n\t    async joinCustomMatch(body: MatchJoinDto, customId: string) {\n\t        try {\n\t            const user = await this.usersService.getUserByCustomId(customId);\n\t            const user_status: UserInfo = await this.redisService.get(customId + \"_info\");\n", "            if (\n\t                !user_status\n\t                || !user_status.status\n\t                || user_status.status == UserStatus.CUSTOM_MATCHING\n\t                || user_status.status == UserStatus.MATCHING_SUCCESS\n\t                || user_status.status == UserStatus.RANDOM_MATCHING\n\t                || user_status.status == UserStatus.OFFLINE\n\t            ) throw new Error(\"방에 참여할 수 없습니다.\");\n\t            const match: CustomMatchDto = await this.getCustomMatch(body.match_id);\n\t            if (!match) throw new Error(\"방이 존재하지 않습니다.\");\n", "            if (match.join_user.length >= 2) throw new Error(\"방이 꽉 찼습니다.\");\n\t            if (match.match_private){\n\t                if (match.match_password != body.match_password) throw new Error(\"비밀번호가 틀렸습니다.\");\n\t            }\n\t            match.join_user.push(customId);\n\t            await this.redisService.set(match.match_type + \"_queue\", match);\n\t            await this.matchGateway.broadcastMatchinfo(MatchStatus.MATCH_JOIN, user.contents.socketId, customId, match);\n\t            return match;\n\t        } catch (e) {\n\t            throw new Error(e);\n", "        }\n\t    }\n\t    async leaveMatch_1on1(socket: Socket, server: Server) {\n\t    }\n\t    async getCustomMatches() {\n\t        const matches: MatchDto[] = [];\n\t        for (const type in MatchType) {\n\t            const match: MatchDto[] = await this.redisService.get(type + \"_queue\");\n\t            if(match) matches.push(...match);\n\t        }\n", "        if(!matches) return [];\n\t        return matches;\n\t    }\n\t    async getCustomMatch(matchId: string): Promise<CustomMatchDto> {\n\t        const matches: CustomMatchDto[] = [];\n\t        for (const type in MatchType) {\n\t            const match: CustomMatchDto[] = await this.redisService.get(type + \"_queue\");\n\t            if(match) matches.push(...match);\n\t        }\n\t        if(!matches) throw new HttpException(\"방이 존재하지 않습니다.\", HttpStatus.BAD_REQUEST);\n", "        const match: CustomMatchDto = matches.find((match: CustomMatchDto) => match.match_id === matchId);\n\t        return match;\n\t    }\n\t    async getMyMatchProgress(customId: string) {\n\t        try {\n\t            let match_type: string[] = Object.values(MatchType);\n\t            match_type.forEach(async (type: string) => {\n\t                const matches: MatchDto[] = await this.redisService.get(type + \"_queue\");\n\t                if (matches) {\n\t                    const match: MatchDto = matches.find((match: MatchDto) => match.join_user.includes(customId));\n", "                    if (match) {\n\t                        return match;\n\t                    }\n\t                }\n\t            });\n\t            return null\n\t        } catch (e) {\n\t            throw new Error(e);\n\t        }\n\t    }\n", "}"]}
{"filename": "src/pages/match/match.controller.ts", "chunked_list": ["import { Body, Controller, Get, HttpException, Param, Post, UseGuards } from \"@nestjs/common\";\n\timport { ApiOperation, ApiResponse, ApiTags } from \"@nestjs/swagger\";\n\timport { MatchService } from \"./match.service\";\n\timport { AuthGuard } from \"@nestjs/passport\";\n\timport { GetUser } from \"src/auth/get-user.decorator\";\n\timport { User } from \"../users/user.entity\";\n\timport { DefaultResponseMatchDto, MatchCreateDto, MatchDto, MatchJoinDto } from \"./dto/match.dto\";\n\t@Controller('match')\n\t@ApiTags('매칭')\n\texport class MatchController {\n", "    constructor(private readonly matchService: MatchService) { }\n\t    @Get('random-match-1on1-queue')\n\t    @ApiOperation({\n\t        summary: '랜덤 매칭 1:1 대기열',\n\t        description: '랜덤 매칭 1:1 대기열에 참가합니다.'\n\t    })\n\t    @ApiResponse({\n\t        description: '랜덤 매칭 1:1 대기열 참가 성공',\n\t        type: DefaultResponseMatchDto,\n\t        status: 200\n", "    })\n\t    @UseGuards(AuthGuard(\"jwt\"))\n\t    async randomMatch_1on1_queue(\n\t        @GetUser() user: User\n\t    ): Promise<DefaultResponseMatchDto> {\n\t        try {\n\t            const result = await this.matchService.randomMatch_1on1_queue(user.customId);\n\t            return {\n\t                statusCode: 200,\n\t                contents: result\n", "            }\n\t        } catch (e) {\n\t            throw new HttpException(e.message, e.status);\n\t        }\n\t    }\n\t    @Post('create-custom-match')\n\t    @ApiOperation({\n\t        summary: '커스텀 매칭생성',\n\t        description: '커스텀 매칭을 생성합니다.'\n\t    })\n", "    @ApiResponse({\n\t        description: '커스텀 매칭 생성 성공',\n\t        type: DefaultResponseMatchDto,\n\t        status: 200\n\t    })\n\t    @UseGuards(AuthGuard(\"jwt\"))\n\t    async createMatch_1on1(\n\t        @GetUser() user: User,\n\t        @Body() body:MatchCreateDto\n\t    ): Promise<DefaultResponseMatchDto> {\n", "        try {\n\t            const result = await this.matchService.createCustomMatch(user.customId, body);\n\t            return {\n\t                statusCode: 200,\n\t                contents: result\n\t            }\n\t        } catch (e) {\n\t            throw new HttpException(e.message, e.status);\n\t        }\n\t    }\n", "    @Post('join-custom-match')\n\t    @ApiOperation({\n\t        summary: '커스텀 매칭 참가',\n\t        description: '커스텀 매칭에 참가합니다.'\n\t    })\n\t    @ApiResponse({\n\t        description: '커스텀 매칭 참가 성공',\n\t        type: DefaultResponseMatchDto,\n\t        status: 200\n\t    })\n", "    @UseGuards(AuthGuard(\"jwt\"))\n\t    async joinMatch_1on1(\n\t        @GetUser() user: User,\n\t        @Body() body: MatchJoinDto\n\t    ): Promise<DefaultResponseMatchDto> {\n\t        try {\n\t            const result = await this.matchService.joinCustomMatch(body, user.customId);\n\t            return {\n\t                statusCode: 200,\n\t                contents: result\n", "            }\n\t        } catch (e) {\n\t            throw new HttpException(e.message, e.status);\n\t        }\n\t    }\n\t    @Get('custom-matches')\n\t    @ApiOperation({\n\t        summary: '커스텀 매칭 1:1 목록',\n\t        description: '커스텀 매칭 1:1 목록을 가져옵니다.'\n\t    })\n", "    async getCustomMatch(\n\t    ) {\n\t        try {\n\t            const result = await this.matchService.getCustomMatches();\n\t            return {\n\t                statusCode: 200,\n\t                contents: result\n\t            }\n\t        } catch (e) {\n\t            throw new Error(e);\n", "        }\n\t    }\n\t    @Get('custom-match/:matchId')\n\t    @ApiOperation({\n\t        summary: '커스텀 매칭 1:1 정보',\n\t        description: '커스텀 매칭 1:1 정보를 가져옵니다.'\n\t    })\n\t    async getCustomMatchById(\n\t        @Param('matchId') matchId: string\n\t    ): Promise<DefaultResponseMatchDto> {\n", "        try {\n\t            const result = await this.matchService.getCustomMatch(matchId);\n\t            return {\n\t                statusCode: 200,\n\t                contents: result\n\t            }\n\t        } catch (e) {\n\t            throw new HttpException(e.message, e.status);\n\t        }\n\t    }\n", "    @Get('my-match-progress')\n\t    @ApiOperation({\n\t        summary: '내 매칭 진행 상황',\n\t        description: '내 매칭 진행 상황을 가져옵니다.'\n\t    })\n\t    @ApiResponse({\n\t        description: '내 매칭 진행 상황 가져오기 성공',\n\t        type: DefaultResponseMatchDto,\n\t        status: 200\n\t    })\n", "    @UseGuards(AuthGuard(\"jwt\"))\n\t    async getMyMatchProgress(\n\t        @GetUser() user: User\n\t    ): Promise<DefaultResponseMatchDto> {\n\t        try {\n\t            const result = await this.matchService.getMyMatchProgress(user.customId);\n\t            return {\n\t                statusCode: 200,\n\t                contents: result\n\t            }\n", "        } catch (e) {\n\t            throw new HttpException(e.message, e.status);\n\t        }\n\t    }\n\t}"]}
{"filename": "src/pages/match/match.module.ts", "chunked_list": ["import { Module, forwardRef } from '@nestjs/common';\n\timport { TypeOrmModule } from '@nestjs/typeorm';\n\timport { AuthModule } from 'src/auth/auth.module';\n\timport { MatchService } from './match.service';\n\timport { RedisCacheModule } from 'src/cache/redis.module';\n\timport { GatewayModule } from 'src/socket-gateways/gateway.module';\n\timport { UsersModule } from '../users/users.module';\n\timport { MatchController } from './match.controller';\n\t@Module({\n\t    imports: [\n", "        TypeOrmModule.forFeature([]),\n\t        AuthModule,\n\t        RedisCacheModule,\n\t        UsersModule,\n\t        forwardRef(() => GatewayModule),\n\t    ],\n\t    controllers: [MatchController,],\n\t    providers: [MatchService,],\n\t    exports: [MatchService],\n\t})\n", "export class MatchModule { }\n"]}
{"filename": "src/pages/match/dto/match.dto.ts", "chunked_list": ["import { ApiProperty } from \"@nestjs/swagger\";\n\texport class MatchDto {\n\t    @ApiProperty({\n\t        description: '매치 ID',\n\t        example: '1234567890',\n\t    })\n\t    match_id: string;\n\t    @ApiProperty({\n\t        description: '매치 타입',\n\t        example: 'random_match_1on1',\n", "    })\n\t    match_type: MatchType;\n\t    @ApiProperty({\n\t        description: '매치 상태',\n\t        example: 'match_change',\n\t    })\n\t    match_status: MatchStatus;\n\t    @ApiProperty({\n\t        description: '매치 생성 시간',\n\t        example: '2021-01-01T00:00:00.000Z',\n", "    })\n\t    match_start_time: Date;\n\t    @ApiProperty({\n\t        description: '매치 종료 시간',\n\t        example: '2021-01-01T00:00:00.000Z',\n\t    })\n\t    match_end_time?: Date;\n\t    @ApiProperty({\n\t        description: '매치 랭크 점수',\n\t        example: 1000,\n", "    })\n\t    match_rank_score?: number;\n\t    @ApiProperty({\n\t        description: '매치 참가 유저',\n\t        example: ['jswcyber', 'abc123'],\n\t    })\n\t    join_user: string[];\n\t}\n\texport class CustomMatchDto extends MatchDto {\n\t    @ApiProperty({\n", "        description: '방 제목',\n\t        example: '랜덤 매칭 1:1',\n\t    })\n\t    match_title: string;\n\t    @ApiProperty({\n\t        description: '방 비밀번호',\n\t        example: '1234',\n\t    })\n\t    match_password?: string;\n\t    @ApiProperty({\n", "        description: '비밀 방 여부',\n\t        example: true,\n\t    })\n\t    match_private: boolean;\n\t    @ApiProperty({\n\t        description: '방장 유저',\n\t        example: 'jswcyber',\n\t    })\n\t    match_owner: string;\n\t}\n", "export class DefaultResponseMatchDto {\n\t    @ApiProperty({\n\t        description: '응답 코드',\n\t        example: 200,\n\t    })\n\t    statusCode: number;\n\t    @ApiProperty({\n\t        description: '전달 데이터'\n\t    })\n\t    contents: MatchDto;\n", "}\n\texport class MatchCreateDto {\n\t    @ApiProperty({\n\t        description: '매치 타입',\n\t        example: 'random_match_1on1',\n\t    })\n\t    match_type: MatchType;\n\t    @ApiProperty({\n\t        description: '방 제목',\n\t        example: '랜덤 매칭 1:1',\n", "    })\n\t    match_title: string;\n\t    @ApiProperty({\n\t        description: '방 비밀번호',\n\t        example: '1234',\n\t    })\n\t    match_password?: string;\n\t    @ApiProperty({\n\t        description: '비밀 방 여부',\n\t        example: true,\n", "    })\n\t    match_private: boolean;\n\t}\n\texport class MatchJoinDto {\n\t    @ApiProperty({\n\t        description: '매치 ID',\n\t        example: '1234567890',\n\t    })\n\t    match_id: string;\n\t    @ApiProperty({\n", "        description: '매치 타입',\n\t        example: 'random_match_1on1',\n\t    })\n\t    match_type: MatchType;\n\t    @ApiProperty({\n\t        description: '방 비밀번호',\n\t        example: '1234',\n\t    })\n\t    match_password: string;\n\t}\n", "export enum MatchType {\n\t    RANDOM_MATCH_1ON1 = \"random_match_1on1\",\n\t    RANDOM_MATCH_2ON2 = \"random_match_2on2\",\n\t    CUSTOM_MATCH_1ON1 = \"custom_match_1on1\",\n\t}\n\texport enum MatchStatus {\n\t    MATCH_CHANGE = \"match_change\",\n\t    MATCH_START = \"match_start\",\n\t    MATCH_SUCCESS = \"match_success\",\n\t    MATCH_CANCEL = \"match_cancel\",\n", "    MATCH_CREATE = \"match_create\",\n\t    MATCH_JOIN = \"match_join\",\n\t}"]}
{"filename": "src/pages/broadcast/broadcast.service.ts", "chunked_list": ["import { Injectable } from \"@nestjs/common\";\n\timport { Server, Socket } from \"socket.io\";\n\t@Injectable()\n\texport class BroadcastService {\n\t    constructor(){}\n\t    async serverBroadcast(server: Server, channel: string, data: any){\n\t        server.emit(channel, data);\n\t    }\n\t}"]}
{"filename": "src/pages/broadcast/broadcast.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { TypeOrmModule } from '@nestjs/typeorm';\n\timport { AuthModule } from 'src/auth/auth.module';\n\timport { BroadcastService } from './broadcast.service';\n\t@Module({\n\t  imports: [\n\t    TypeOrmModule.forFeature([]),\n\t    AuthModule\n\t  ],\n\t  controllers: [],\n", "  providers: [BroadcastService],\n\t  exports: [BroadcastService],\n\t})\n\texport class BroadcastModule {}\n"]}
{"filename": "src/pages/schedule/scheduler.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { TypeOrmModule } from '@nestjs/typeorm';\n\timport { AuthModule } from 'src/auth/auth.module';\n\timport { SchedulerService } from './scheduler.service';\n\timport { ScheduleModule } from '@nestjs/schedule';\n\timport { UsersModule } from '../users/users.module';\n\timport { GatewayModule } from 'src/socket-gateways/gateway.module';\n\timport { MatchModule } from '../match/match.module';\n\t@Module({\n\t    imports: [\n", "        TypeOrmModule.forFeature([]),\n\t        ScheduleModule.forRoot(),\n\t        AuthModule,\n\t        UsersModule,\n\t        GatewayModule,\n\t        MatchModule,\n\t    ],\n\t    controllers: [],\n\t    providers: [SchedulerService],\n\t    exports: [SchedulerService],\n", "})\n\texport class SchedulerModule { }\n"]}
{"filename": "src/pages/schedule/scheduler.service.ts", "chunked_list": ["import { Injectable } from \"@nestjs/common\";\n\timport { Server, Socket } from \"socket.io\";\n\timport { Cron, CronExpression, SchedulerRegistry } from \"@nestjs/schedule\";\n\timport { CronJob } from \"cron\";\n\timport { UsersService } from \"../users/users.service\";\n\timport { WebSocketServer } from \"@nestjs/websockets\";\n\timport { CoreGateway } from \"src/socket-gateways/gateway.core\";\n\timport { MatchService } from \"../match/match.service\";\n\timport { MatchStatus, MatchDto, MatchType } from \"../match/dto/match.dto\";\n\timport { MatchGateway } from \"src/socket-gateways/match/gateway.match\";\n", "import { async } from \"rxjs\";\n\t@Injectable()\n\texport class SchedulerService {\n\t    constructor(\n\t        private schedulerRegistry: SchedulerRegistry,\n\t        private usersService: UsersService,\n\t        private matchService: MatchService,\n\t        private coreGateway: CoreGateway,\n\t        private matchGateway: MatchGateway,\n\t    ) { }\n", "    async createCronJob(name: string, time: string, callback: () => void) {\n\t        const job = new CronJob(time, callback);\n\t        this.schedulerRegistry.addCronJob(name, job);\n\t        job.start();\n\t    }\n\t    async deleteCronJob(name: string) {\n\t        const job = this.schedulerRegistry.getCronJob(name);\n\t        job.stop();\n\t        this.schedulerRegistry.deleteCronJob(name);\n\t    }\n", "    async getCronJob(name: string) {\n\t        return this.schedulerRegistry.getCronJob(name);\n\t    }\n\t    /**\n\t     * @description\n\t     * - 1분 간격으로 접속한 유저와 접속하지 않은 유저를 구분함.\n\t     * - 접속이 끊긴 유저의 소켓을 제거.\n\t     */\n\t    @Cron(CronExpression.EVERY_10_SECONDS, {\n\t        name: \"disconnect-user-cron\",\n", "    })\n\t    async disconnectUserCron() {\n\t        const allUsers = (await this.usersService.getAllUsers()).contents;\n\t        const socket = await this.coreGateway.getClients();\n\t        const disconnectedUser = [];\n\t        const connectedUser = [];\n\t        for (let i = 0; i < allUsers.length; i++) {\n\t            const user = allUsers[i];\n\t            const isHas = socket.has(user.socketId);\n\t            if (isHas) {\n", "                connectedUser.push(user);\n\t            } else {\n\t                disconnectedUser.push(user);\n\t            }\n\t        }\n\t        disconnectedUser.forEach(async (user) => {\n\t            if (user.socketId === null) return;\n\t            await this.usersService.updateDisconnectSocketId(user.customId);\n\t        });\n\t    }\n", "    /**\n\t     * @description\n\t     * - Match Queue에 있는 유저들을 매칭시킴.\n\t     * @todo\n\t     * - 매치 성사 시 history를 DB에 저장함.\n\t     */\n\t    @Cron(CronExpression.EVERY_5_SECONDS, {\n\t        name: \"match-queue-cron\",\n\t    })\n\t    async matchQueueCron() {\n", "        const queue : MatchDto[] = await this.matchService.getMatchQueue(MatchType.RANDOM_MATCH_1ON1);\n\t        if (!queue) return;\n\t        await this.matchService.updateMatchQueue(MatchType.RANDOM_MATCH_1ON1, []);\n\t        for (const match of queue) {\n\t            if (match.join_user.length >= 2) {\n\t                if (match.join_user.length > 2) {\n\t                    const overUsers: string[] = match.join_user.splice(2, match.join_user.length - 2);\n\t                    this.matchService.replaceMatchQueue(overUsers);\n\t                }\n\t                match.match_status = MatchStatus.MATCH_SUCCESS;\n", "                match.match_end_time = new Date();\n\t                const broadUserInfo = [];\n\t                for(const userId of match.join_user) {\n\t                    const user = (await this.usersService.getUserByCustomId(userId)).contents;\n\t                    if (!user || user.socketId === null) {\n\t                        match.match_status = MatchStatus.MATCH_START;\n\t                        match.match_end_time = null;\n\t                        match.join_user.splice(match.join_user.indexOf(userId), 1);\n\t                        break;\n\t                    }\n", "                    broadUserInfo.push({\n\t                        userId: userId,\n\t                        socketId: user.socketId,\n\t                    });\n\t                }\n\t                if (match.match_status === MatchStatus.MATCH_SUCCESS) {\n\t                    broadUserInfo.forEach(async(user) => {\n\t                        await this.matchGateway.broadcastMatchinfo(\n\t                            MatchStatus.MATCH_SUCCESS,\n\t                            user.socketId,\n", "                            user.customId,\n\t                            match\n\t                        );\n\t                    });\n\t                    queue.splice(queue.indexOf(match), 1);\n\t                }\n\t            }\n\t        }\n\t        const nowQueue = await this.matchService.getMatchQueue(MatchType.RANDOM_MATCH_1ON1);\n\t        await this.matchService.updateMatchQueue(MatchType.RANDOM_MATCH_1ON1, [...nowQueue, ...queue]);\n", "    }\n\t}"]}
{"filename": "src/auth/get-user.decorator.ts", "chunked_list": ["import { createParamDecorator, ExecutionContext } from \"@nestjs/common\";\n\timport { User } from \"src/pages/users/user.entity\";\n\texport const GetUser = createParamDecorator((data, ctx: ExecutionContext): User => {\n\t    const req = ctx.switchToHttp().getRequest();\n\t    return req.user;\n\t})"]}
{"filename": "src/auth/auth.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { JwtModule } from '@nestjs/jwt';\n\timport { TypeOrmModule } from '@nestjs/typeorm';\n\timport { UserRepository } from 'src/pages/users/user.repository';\n\timport { AuthController } from './auth.controller';\n\timport { AuthService } from './auth.service';\n\timport { PassportModule } from '@nestjs/passport';\n\timport { JwtStrategy } from './jwt.strategy';\n\timport { UsersService } from 'src/pages/users/users.service';\n\timport { ConfigService } from '@nestjs/config';\n", "import { User } from 'src/pages/users/user.entity';\n\timport { JwtRefreshStrategy } from './jwt-refresh.strategy';\n\t@Module({\n\t  imports: [\n\t    PassportModule.register({ defaultStrategy: 'jwt' }),\n\t    JwtModule.registerAsync({\n\t      inject: [ConfigService],\n\t      useFactory: (config: ConfigService) => ({\n\t        secret : process.env.JWT_SECRET,\n\t        signOptions : {\n", "          expiresIn : 3600\n\t        },\n\t      }),\n\t    }),\n\t    TypeOrmModule.forFeature([User]),\n\t  ],\n\t  controllers: [AuthController],\n\t  providers: [AuthService, JwtStrategy, JwtRefreshStrategy, UsersService, UserRepository],\n\t  exports: [JwtStrategy, JwtRefreshStrategy, PassportModule]\n\t})\n", "export class AuthModule {}\n"]}
{"filename": "src/auth/auth.controller.ts", "chunked_list": ["import { Body, Controller, Post, ValidationPipe, UseGuards, UseInterceptors, Get, Req, Res, HttpException } from '@nestjs/common';\n\timport { User } from 'src/pages/users/user.entity';\n\timport { AuthGuard } from '@nestjs/passport';\n\timport { AuthService } from './auth.service';\n\timport { AuthCredentialDto } from './dto/auth-credential.dto';\n\timport { GetUser } from './get-user.decorator';\n\timport { AuthLoginDto } from './dto/auth-login.dto';\n\timport { ApiTags, ApiOperation, ApiCreatedResponse, ApiResponse } from '@nestjs/swagger';\n\timport { DefaultResponseDto } from './dto/default-response.dto';\n\timport { ErrorResponseDto } from './dto/error-response.dto';\n", "import { TransactionInterceptor } from 'src/decorators/TransactionInterceptor.decorator';\n\timport { TransactionManager } from 'src/decorators/TransactionManager.decorator';\n\timport { EntityManager } from 'typeorm';\n\t@Controller('auth')\n\t@UseInterceptors(TransactionInterceptor)\n\t@ApiTags('유저 인증')\n\texport class AuthController {\n\t    constructor(\n\t        private authService: AuthService\n\t    ) {}\n", "    @Post('/signup')\n\t    @ApiOperation({summary: '회원가입', description: '회원가입 진행'})\n\t    @ApiResponse({description: '회원가입 성공', type: DefaultResponseDto, status: 201})\n\t    @ApiResponse({description: '회원가입 실패', type: ErrorResponseDto , status: 401})\n\t    async signUp(\n\t        @Body(ValidationPipe) authCredentialDto: AuthCredentialDto,\n\t        @TransactionManager() queryRunnerManager: EntityManager,\n\t    ): Promise<DefaultResponseDto> {\n\t        try{\n\t            const result = await this.authService.signUp({\n", "                authCredentialDto,\n\t                queryRunner:queryRunnerManager,\n\t            });\n\t            return result;\n\t        }catch(error){\n\t            throw new HttpException(error.message, 401);\n\t        }\n\t    }\n\t    @Post('/signin')\n\t    @ApiOperation({summary: '로그인', description: '로그인 진행'})\n", "    @ApiResponse({description: '로그인 성공', type: DefaultResponseDto})\n\t    @ApiResponse({description: '로그인 실패', type: ErrorResponseDto , status: 401})\n\t    async signIn(\n\t        @Body(ValidationPipe) authLoginDto: AuthLoginDto,\n\t        @TransactionManager() queryRunnerManager: EntityManager,\n\t        @Res({ passthrough: true }) response,\n\t    ): Promise<DefaultResponseDto> {\n\t        try{\n\t            const result = await this.authService.signIn({\n\t                authLoginDto,\n", "                queryRunnerManager,\n\t            });\n\t            response.cookie('Refresh', result.contents.refreshToken, {\n\t                httpOnly: true,\n\t                maxAge: process.env.JWT_REFRESH_EXPIRATION_TIME,\n\t            });\n\t            return {\n\t                statusCode: result.statusCode,\n\t                contents: {\n\t                    accessToken: result.contents.accessToken,\n", "                    refreshToken: result.contents.refreshToken,\n\t                },\n\t            };\n\t        }catch(error){\n\t            throw new HttpException(error.message, 404);\n\t        }\n\t    }\n\t    @Get('/signout')\n\t    @ApiOperation({summary: '로그아웃', description: '로그아웃 진행'})\n\t    @ApiResponse({description: '로그아웃 성공', type: DefaultResponseDto})\n", "    @ApiResponse({description: '로그아웃 실패', type: ErrorResponseDto , status: 401})\n\t    async signOut(\n\t        @Res({ passthrough: true }) response,\n\t        @GetUser() user: User,\n\t    ): Promise<DefaultResponseDto> {\n\t        try{\n\t            if(!user) throw new Error('로그인이 되어있지 않습니다.');\n\t            await this.authService.signOut(user);\n\t            response.clearCookie('Refresh');\n\t            return {\n", "                statusCode: \"200\",\n\t                contents: \"로그아웃 성공\",\n\t            };\n\t        }catch(error){\n\t            throw new HttpException(error.message, 500);\n\t        }\n\t    }\n\t    @Get('/refresh')\n\t    @ApiOperation({summary: 'Refresh Token 으로 AccessToken 발급', description: '헤더인경우 refresh_token, 쿠키인 경우 Refresh'})\n\t    @ApiResponse({description: '로그인 성공', type: DefaultResponseDto})\n", "    @ApiResponse({description: '로그인 실패', type: ErrorResponseDto , status: 401})\n\t    @UseGuards(AuthGuard('jwt-refresh-token'))\n\t    async signInByRefreshToken(\n\t        @TransactionManager() queryRunnerManager: EntityManager,\n\t        @GetUser() user: User,\n\t    ): Promise<DefaultResponseDto> {\n\t        try{\n\t            const accessToken = await this.authService.getAccessToken(user);\n\t            return {\n\t                statusCode: \"200\",\n", "                contents: accessToken,\n\t            };\n\t        }catch(error){\n\t            throw new HttpException(error.message, 401);\n\t        }\n\t    }\n\t    @Get('/islogin')\n\t    @ApiOperation({summary: '로그인 여부 확인', description: '로그인 여부 확인'})\n\t    @ApiResponse({description: '로그인 여부 확인', type: DefaultResponseDto})\n\t    @UseGuards(AuthGuard(\"jwt\"))\n", "    async isLogin(\n\t        @GetUser() user: User,\n\t    ): Promise<DefaultResponseDto> {\n\t        try{\n\t            return {\n\t                statusCode: \"200\",\n\t                contents: {\n\t                    id: user.id,\n\t                    email: user.email,\n\t                    name: user.name,\n", "                    role: user.role,\n\t                    customId: user.customId,\n\t                },\n\t            };\n\t        }catch(error){\n\t            throw new HttpException(error.message, 500);\n\t        }\n\t    }\n\t}\n"]}
{"filename": "src/auth/jwt.strategy.ts", "chunked_list": ["import { PassportStrategy } from \"@nestjs/passport\";\n\timport { ExtractJwt, Strategy } from \"passport-jwt\";\n\timport { AuthService } from \"./auth.service\";\n\timport { UserRepository } from \"src/pages/users/user.repository\";\n\timport { UnauthorizedException } from \"@nestjs/common\";\n\timport { User } from \"src/pages/users/user.entity\";\n\timport { InjectRepository } from \"@nestjs/typeorm\";\n\texport class JwtStrategy extends PassportStrategy(Strategy) {\n\t    constructor(\n\t        @InjectRepository(UserRepository)\n", "        private UserRepository: UserRepository\n\t    ) {\n\t        super({\n\t            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n\t            secretOrKey: process.env.JWT_SECRET,\n\t        });\n\t    }\n\t    async validate(payload) : Promise<User> {\n\t        const { customId } = payload;\n\t        const user = await this.UserRepository.findOne({ where : {customId} });\n", "        if (!user) {\n\t            throw new UnauthorizedException();\n\t        }\n\t        return user;\n\t    }\n\t}"]}
{"filename": "src/auth/authToken.middleware.ts", "chunked_list": ["import { Injectable, NestMiddleware } from '@nestjs/common'\n\timport { InjectRepository } from '@nestjs/typeorm'\n\timport { Request, Response } from 'express'\n\timport * as jwt from 'jsonwebtoken'\n\timport { User } from 'src/pages/users/user.entity'\n\t@Injectable()\n\texport class AuthTokenMiddleware implements NestMiddleware {\n\t    public async use(req: any, res: Response, next: () => void) {\n\t        req.user = await this.verifyUser(req)\n\t        return next()\n", "    }\n\t    private async verifyUser(req: Request): Promise<User> {\n\t        let user: User = null\n\t        try {\n\t            const { authorization } = req.headers\n\t            const token = authorization.replace('Bearer ', '').replace('bearer ', '')\n\t            const decoded = await this.verifyToken(token)\n\t            // user = await this.userRepository.findOne({ where : {customId : decoded.customId} });\n\t            user = decoded;\n\t        } catch (e) {}\n", "        return user;\n\t    }\n\t    private async verifyToken(token: string): Promise<any> {\n\t        return new Promise((resolve, reject) => {\n\t            jwt.verify(token, process.env.JWT_SECRET, (err, decoded) => {\n\t                if (err) reject(err)\n\t                resolve(decoded)\n\t            })\n\t        })\n\t    }\n", "}"]}
{"filename": "src/auth/auth.service.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\n\timport { JwtService } from '@nestjs/jwt';\n\timport { InjectRepository } from '@nestjs/typeorm';\n\timport { User } from 'src/pages/users/user.entity';\n\timport { UserRepository } from 'src/pages/users/user.repository';\n\timport { AuthCredentialDto } from './dto/auth-credential.dto';\n\timport { UnauthorizedException } from \"@nestjs/common/exceptions\";\n\timport * as bcrypt from 'bcryptjs';\n\timport { AuthLoginDto } from './dto/auth-login.dto';\n\timport { DefaultResponseDto } from './dto/default-response.dto';\n", "import { EntityManager } from 'typeorm';\n\t@Injectable()\n\texport class AuthService {\n\t    constructor(\n\t        @InjectRepository(UserRepository)\n\t        private userRepository: UserRepository,\n\t        private jwtService: JwtService\n\t    ) {}\n\t    async signUp(args:{\n\t        authCredentialDto: AuthCredentialDto,\n", "        queryRunner: EntityManager,\n\t    }) : Promise<DefaultResponseDto> {\n\t        try{\n\t            const IdCheck = await args.queryRunner.findOne(User,{\n\t                where:{ customId : args.authCredentialDto.customId }\n\t            });\n\t            if(IdCheck){\n\t                throw new UnauthorizedException('Id already exists');\n\t            }\n\t            const EmailCheck = await args.queryRunner.findOne(User,{\n", "                where:{ email : args.authCredentialDto.email }\n\t            });\n\t            if(EmailCheck){\n\t                throw new UnauthorizedException('Email already exists');\n\t            }\n\t        } catch (error) {\n\t            throw new UnauthorizedException(error.message);\n\t        }\n\t        const user = await this.userRepository.createUser(args.authCredentialDto);\n\t        return {statusCode:\"200\", contents : user};\n", "    }\n\t    async signIn(args:{\n\t        authLoginDto: AuthLoginDto,\n\t        queryRunnerManager: EntityManager,\n\t    }) : Promise<DefaultResponseDto> {\n\t        const {customId , password } = args.authLoginDto;\n\t        const user = await this.userRepository.findOne(\n\t            {where:{ customId : customId }}\n\t        );\n\t        if(user && await bcrypt.compare(password, user.password)){\n", "            const payload = { customId : user.customId };\n\t            const accessToken = await this.jwtService.sign(payload, {\n\t                secret: process.env.JWT_SECRET,\n\t                expiresIn: process.env.JWT_SECRET_EXPIRATION_TIME,\n\t            });\n\t            const refreshToken = await this.jwtService.sign({id: user.id}, { \n\t                secret: process.env.JWT_REFRESH_TOKEN_SECRET,\n\t                expiresIn: process.env.JWT_REFRESH_TOKEN_EXPIRATION_TIME,\n\t            });\n\t            await this.setCurrentRefreshToken(refreshToken, user.id)\n", "            return {statusCode:\"200\", contents : {accessToken, refreshToken}};\n\t        }\n\t        else{\n\t            throw new UnauthorizedException('login failed');\n\t        }\n\t    }\n\t    async setCurrentRefreshToken(refreshToken: string, id: number) {\n\t        const hashedRefreshToken = await bcrypt.hash(refreshToken, 10);\n\t        await this.userRepository.update(id, { refreshToken : hashedRefreshToken });\n\t    }\n", "    async getUserIfRefreshTokenMatches(refreshToken: string, id: number) {\n\t        const user = await this.userRepository.findOne({\n\t            where: { id },\n\t        });\n\t        if(user.refreshToken == null){\n\t            throw new UnauthorizedException('refresh token is null');\n\t        }\n\t        const isRefreshTokenMatching = await bcrypt.compare(\n\t            refreshToken,\n\t            user.refreshToken,\n", "        );\n\t        if (isRefreshTokenMatching) {\n\t            return user;\n\t        }else{\n\t            throw new UnauthorizedException('not matching refresh token');\n\t        }\n\t    }\n\t    async removeRefreshToken(id: number) {\n\t        return this.userRepository.update(id, {\n\t            refreshToken: null,\n", "        });\n\t    }\n\t    async getAccessToken(user:User) {\n\t        try{\n\t            const payload = { customId : user.customId };\n\t            const accessToken = await this.jwtService.sign(payload);\n\t            return accessToken;\n\t        }catch(e){\n\t            throw new UnauthorizedException(e.message);\n\t        }\n", "    }\n\t    async signOut(user:User){\n\t        const userObject = await this.userRepository.findOne({\n\t            where: { customId : user.customId },\n\t        });\n\t        if(userObject){\n\t            await this.removeRefreshToken(userObject.id);\n\t            return {statusCode:\"200\", contents : \"sign out success\"};\n\t        }\n\t        else{\n", "            throw new UnauthorizedException('user not found');\n\t        }\n\t    }\n\t}\n"]}
{"filename": "src/auth/jwt-refresh.strategy.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\n\timport { ConfigService } from '@nestjs/config';\n\timport { PassportStrategy } from '@nestjs/passport';\n\timport { ExtractJwt, Strategy } from 'passport-jwt';\n\timport { AuthService } from './auth.service';\n\t@Injectable()\n\texport class JwtRefreshStrategy extends PassportStrategy(\n\t    Strategy,\n\t    'jwt-refresh-token',\n\t) {\n", "    constructor(\n\t        private readonly authService: AuthService,\n\t    ) {\n\t        super({\n\t            jwtFromRequest: ExtractJwt.fromExtractors([\n\t                (request) => {\n\t                    if(request?.headers?.refresh_token){\n\t                        return request?.headers?.refresh_token;\n\t                    }\n\t                    return request?.cookies?.Refresh;\n", "                },\n\t            ]),\n\t            secretOrKey: process.env.JWT_REFRESH_TOKEN_SECRET,\n\t            passReqToCallback: true,\n\t        });\n\t    }\n\t    async validate(req, payload: any) {\n\t        const refreshToken = req.cookies?.Refresh || req.headers?.refresh_token;\n\t        return this.authService.getUserIfRefreshTokenMatches(\n\t            refreshToken,\n", "            payload.id,\n\t        );\n\t    }\n\t}"]}
{"filename": "src/auth/dto/auth-credential.dto.ts", "chunked_list": ["import { ApiProperty } from \"@nestjs/swagger\";\n\timport { IsNotEmpty } from \"class-validator\";\n\texport class AuthCredentialDto {\n\t    @ApiProperty({description: '사용자 아이디', example: 'jswcyber'})\n\t    @IsNotEmpty()\n\t    customId: string;\n\t    @ApiProperty({description: '사용자 이름', example: '정성욱'})\n\t    @IsNotEmpty()\n\t    name: string;\n\t    @ApiProperty({description: '사용자 이메일', example: 'jswcyber@naver.com'})\n", "    @IsNotEmpty()\n\t    email: string;\n\t    @ApiProperty({description: '사용자 비밀번호', example: 'Qlalfqjsgh1234!@'})\n\t    @IsNotEmpty()\n\t    password: string;\n\t}\n"]}
{"filename": "src/auth/dto/error-response.dto.ts", "chunked_list": ["import { ApiProperty } from \"@nestjs/swagger\";\n\timport { IsNotEmpty } from \"class-validator\";\n\texport class ErrorResponseDto {\n\t    @ApiProperty({description: '응답 코드', example: '4xx'})\n\t    @IsNotEmpty()\n\t    statusCode: string;\n\t    @ApiProperty({description: '에러 전달', example: ''})\n\t    @IsNotEmpty()\n\t    contents: any;\n\t}\n"]}
{"filename": "src/auth/dto/default-response.dto.ts", "chunked_list": ["import { ApiProperty } from \"@nestjs/swagger\";\n\timport { IsNotEmpty } from \"class-validator\";\n\texport class DefaultResponseDto {\n\t    @ApiProperty({description: '응답 코드', example: '2xx'})\n\t    @IsNotEmpty()\n\t    statusCode: string;\n\t    @ApiProperty({description: '응답 내용', example: ''})\n\t    @IsNotEmpty()\n\t    contents: any;\n\t}\n"]}
{"filename": "src/auth/dto/auth-login.dto.ts", "chunked_list": ["import { ApiProperty } from \"@nestjs/swagger\";\n\timport { IsNotEmpty } from \"class-validator\";\n\texport class AuthLoginDto {\n\t    @ApiProperty({description: '사용자 아이디', example: 'jswcyber'})\n\t    @IsNotEmpty()\n\t    customId: string;\n\t    @ApiProperty({description: '사용자 비밀번호', example: 'Qlalfqjsgh1234!@'})\n\t    @IsNotEmpty()\n\t    password: string;\n\t}\n"]}
{"filename": "src/utils/util.ts", "chunked_list": ["export const generateSessionId = () => {\n\t    const rand_session_id = Math.random().toString(36).substr(2, 11);\n\t    return rand_session_id;\n\t}"]}
{"filename": "src/movement2d/movement2d.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { TypeOrmModule } from '@nestjs/typeorm';\n\timport { AuthModule } from 'src/auth/auth.module';\n\timport { Movement2dService } from './movement2d.service';\n\timport { RedisCacheModule } from 'src/cache/redis.module';\n\t@Module({\n\t  imports: [\n\t    TypeOrmModule.forFeature([]),\n\t    AuthModule,\n\t    RedisCacheModule,\n", "  ],\n\t  controllers: [],\n\t  providers: [Movement2dService],\n\t  exports: [Movement2dService],\n\t})\n\texport class Movement2dModule {}\n"]}
{"filename": "src/movement2d/movement2d.service.ts", "chunked_list": ["import { Injectable } from \"@nestjs/common\";\n\timport { Server, Socket } from \"socket.io\";\n\timport { RedisCacheService } from \"src/cache/redis.service\";\n\t/**\n\t * 2D 환경에서의 움직임을 처리하는 서비스\n\t */\n\t@Injectable()\n\texport class Movement2dService {\n\t    constructor(\n\t        private redisService: RedisCacheService,\n", "    ) { }\n\t    /**\n\t     * 키보드의 입력을 받아서 도착 지점을 계산한 후, 그 결과를 클라이언트에게 전송한다.\n\t     * @param server \n\t     * @param channel \n\t     * @param userCustomId\n\t     * @param key\n\t     * @param isUp\n\t     */\n\t    async move2d_key(server: Server, channel: string, userCustomId: any, key:any, isUp: boolean) {\n", "        try {\n\t            const { x, y } = await this.redisService.get(userCustomId+\"_position\");\n\t            let newX = x;\n\t            let newY = y;\n\t            if(!isUp){\n\t                switch (key) {\n\t                    case \"s\":\n\t                        newY -= 5;\n\t                        break;\n\t                    case \"w\":\n", "                        newY += 5;\n\t                        break;\n\t                    case \"a\":\n\t                        newX -= 5;\n\t                        break;\n\t                    case \"d\":\n\t                        newX += 5;\n\t                        break;\n\t                }\n\t                // 전체 사용자들에게 이동을 알림. (현재 위치, 이동 방향, 이동 속도)\n", "                // 서버에서도 이동을 계산해서 위치를 업데이트.\n\t                const already = await this.redisService.get(userCustomId+\"_interval_\"+key);\n\t                if(already) return;\n\t                const interval = setInterval(this.calculatePosition, 100, this.redisService, server, channel, userCustomId, key, isUp, 5);\n\t                await this.redisService.set(userCustomId+\"_interval_\"+key, interval[Symbol.toPrimitive]() as number);\n\t                server.emit(\"position_start\",{\n\t                    player: userCustomId,\n\t                    x: newX,\n\t                    y: newY,\n\t                    direction: key,\n", "                    speed: 5\n\t                })\n\t            }else{\n\t                // 전체 사용자들에게 이동이 멈춤을 알림.( 서버에서 계산된 위치 )\n\t                // 서버에서도 이동을 계산해서 위치를 업데이트.\n\t                const interval : number = await this.redisService.get(userCustomId+\"_interval_\"+key);\n\t                clearInterval(interval);\n\t                await this.redisService.del(userCustomId+\"_interval_\"+key);\n\t                server.emit(\"position_stop\",{\n\t                    player: userCustomId,\n", "                    x: newX,\n\t                    y: newY,\n\t                    speed: 0\n\t                })\n\t            }\n\t            await this.redisService.set(userCustomId+\"_position\", { x: newX, y: newY });\n\t        } catch (e) {\n\t            throw new Error(e);\n\t        }\n\t    }\n", "    async calculatePosition(redisService: RedisCacheService ,server: Server, channel: string, userCustomId: any, key:any, isUp: boolean, speed: number) {\n\t        try {\n\t            const { x, y } = await redisService.get(userCustomId+\"_position\");\n\t            let newX = x;\n\t            let newY = y;\n\t            if(!isUp){\n\t                switch (key) {\n\t                    case \"s\":\n\t                        newY -= speed;\n\t                        break;\n", "                    case \"w\":\n\t                        newY += speed;\n\t                        break;\n\t                    case \"a\":\n\t                        newX -= speed;\n\t                        break;\n\t                    case \"d\":\n\t                        newX += speed;\n\t                        break;\n\t                    default:\n", "                        break;\n\t                }\n\t            }\n\t            await redisService.set(userCustomId+\"_position\", { x: newX, y: newY });\n\t            // 실시간으로 이동을 알림. //////////////////////////////\n\t            server.emit(channel, {\n\t                player: userCustomId,\n\t                x: newX,\n\t                y: newY,\n\t                direction: key,\n", "                speed: speed\n\t            });\n\t            ///////////////////////////////////////////////////////\n\t        } catch (e) {\n\t            throw new Error(e);\n\t        }\n\t    }\n\t    /**\n\t     * 이동 방향을 입력받아서 해당 이동 방향을 클라이언트에게 전송한다.\n\t     * 서버에서도 이동 방향을 계산해서 위치를 업데이트한다.\n", "     * @param server\n\t     * @param channel\n\t     * @param userCustomId\n\t     * @param direction\n\t    */\n\t    async move2d_direction(server: Server, channel: string, userCustomId: any, direction: any) {\n\t        try {\n\t            server.emit(channel, {\n\t                direction: direction,\n\t                player: userCustomId\n", "            });\n\t        } catch (e){\n\t            throw new Error(e);\n\t        }\n\t    }\n\t}"]}
{"filename": "src/cache/redis.service.ts", "chunked_list": ["import { Injectable, Inject, CACHE_MANAGER } from '@nestjs/common';\n\timport { Cache } from 'cache-manager';\n\t@Injectable()\n\texport class RedisCacheService {\n\t    constructor(@Inject(CACHE_MANAGER) private readonly cache: Cache) { }\n\t    async get(key: string): Promise<any> {\n\t        return await this.cache.get(key);\n\t    }\n\t    async set(key: string, value: any, option?: any) {\n\t        await this.cache.set(key, value, option);\n", "    }\n\t    async reset() {\n\t        await this.cache.reset();\n\t    }\n\t    async del(key: string) {\n\t        await this.cache.del(key);\n\t    }\n\t    async concat(key: string, value: any[]) {\n\t        const data : any[] = await this.get(key);\n\t        if (data) {\n", "            await this.set(key, data.concat(value));\n\t        }else{\n\t            await this.set(key, [value]);\n\t        }\n\t    }\n\t    async push(key: string, value: any) {\n\t        const data : any[] = await this.get(key);\n\t        if (data) {\n\t            await this.set(key, data.push(value));\n\t        }else{\n", "            await this.set(key, [value]);\n\t        }\n\t    }\n\t}"]}
{"filename": "src/cache/redis.module.ts", "chunked_list": ["import { CacheModule, Module } from '@nestjs/common';\n\timport * as redisStore from 'cache-manager-redis-store';\n\timport * as dotenv from 'dotenv';\n\timport { RedisCacheService } from './redis.service';\n\tdotenv.config();\n\tconst cacheModule = CacheModule.register({\n\t    useFactory: async () => ({\n\t        store: redisStore,\n\t        host: process.env.REDIS_HOST,   // env에서 정의함\n\t        port: process.env.REDIS_PORT,   // env에서 정의함\n", "        ttl: 60 * 60 * 12, // 캐시 유지 시간\n\t    }),\n\t});\n\t@Module({\n\t    imports: [cacheModule],\n\t    providers: [RedisCacheService],\n\t    exports: [RedisCacheService],\n\t})\n\texport class RedisCacheModule { }"]}
{"filename": "src/decorators/TransactionManager.decorator.ts", "chunked_list": ["import { ExecutionContext, createParamDecorator } from \"@nestjs/common\";\n\texport const TransactionManager = createParamDecorator(\n\t    (data: unknown, ctx: ExecutionContext) => {\n\t      const req = ctx.switchToHttp().getRequest();\n\t      return req.queryRunnerManager;\n\t    },\n\t  );"]}
{"filename": "src/decorators/TransactionInterceptor.decorator.ts", "chunked_list": ["import { CallHandler, ExecutionContext, HttpException, Injectable, InternalServerErrorException, NestInterceptor } from \"@nestjs/common\";\n\timport { Observable, catchError, tap } from \"rxjs\";\n\timport { QueryRunner, DataSource } from \"typeorm\";\n\t@Injectable()\n\texport class TransactionInterceptor implements NestInterceptor {\n\t  constructor(private readonly dataSource: DataSource) {}\n\t  async intercept(\n\t    context: ExecutionContext,\n\t    next: CallHandler,\n\t  ): Promise<Observable<any>> {\n", "    const req = context.switchToHttp().getRequest();\n\t    const queryRunner: QueryRunner = await this.dbInit();\n\t    req.queryRunnerManager = queryRunner.manager;\n\t    return next.handle().pipe(\n\t      catchError(async (e) => {\n\t        await queryRunner.rollbackTransaction();\n\t        await queryRunner.release();\n\t        if (e instanceof HttpException) {\n\t          throw new HttpException(e.message, e.getStatus());\n\t        } else {\n", "          throw new InternalServerErrorException(e.message);\n\t        }\n\t      }),\n\t      tap(async () => {\n\t        await queryRunner.commitTransaction();\n\t        await queryRunner.release();\n\t      }),\n\t    );\n\t  }\n\t  private async dbInit(): Promise<QueryRunner> {\n", "    const queryRunner = this.dataSource.createQueryRunner();\n\t    await queryRunner.connect();\n\t    await queryRunner.startTransaction();\n\t    return queryRunner;\n\t  }\n\t}"]}
