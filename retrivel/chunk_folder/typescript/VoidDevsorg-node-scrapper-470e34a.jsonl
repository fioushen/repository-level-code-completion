{"filename": "dist/src/index.d.ts", "chunked_list": ["export * from '../src/engines';\n\texport { default as Engine } from '../src/lib';\n"]}
{"filename": "dist/src/engines/index.d.ts", "chunked_list": ["export { Google } from './lib/Google';\n\texport { Bing } from './lib/Bing';\n\texport { Wikipedia } from './lib/Wikipedia';\n\texport { YouTube } from './lib/YouTube';\n"]}
{"filename": "dist/src/engines/lib/Bing.d.ts", "chunked_list": ["import { Options } from \"../../types/Bing\";\n\timport useProxies from \"../../utils/useProxies\";\n\texport declare class Bing {\n\t    private options;\n\t    private updateQueries;\n\t    constructor(options?: Options);\n\t    useProxies: typeof useProxies;\n\t    search(query: string): Promise<{}>;\n\t    private _search;\n\t    suggestions(query: string): Promise<{}>;\n", "    private _suggestions;\n\t    images(query: string): Promise<{}>;\n\t}\n"]}
{"filename": "dist/src/engines/lib/YouTube.d.ts", "chunked_list": ["import { Options } from \"../../types/YouTube\";\n\timport useProxies from \"../../utils/useProxies\";\n\texport declare class YouTube {\n\t    private options;\n\t    private updateQueries;\n\t    constructor(options?: Options);\n\t    useProxies: typeof useProxies;\n\t    search(query: string): Promise<{}>;\n\t    private _search;\n\t}\n"]}
{"filename": "dist/src/engines/lib/Google.d.ts", "chunked_list": ["import { Options } from \"../../types/Google\";\n\timport useProxies from \"../../utils/useProxies\";\n\texport declare class Google {\n\t    private options;\n\t    private updateQueries;\n\t    constructor(options?: Options);\n\t    useProxies: typeof useProxies;\n\t    search(query: string): Promise<{}>;\n\t    private _search;\n\t    suggestions(query: string): Promise<{}>;\n", "    private _suggestions;\n\t    images(query: string): Promise<{}>;\n\t}\n"]}
{"filename": "dist/src/engines/lib/Wikipedia.d.ts", "chunked_list": ["import { Options } from \"../../types/Wikipedia\";\n\timport useProxies from \"../../utils/useProxies\";\n\texport declare class Wikipedia {\n\t    private options;\n\t    private updateQueries;\n\t    constructor(options?: Options);\n\t    useProxies: typeof useProxies;\n\t    get(query: string): Promise<{}>;\n\t    private _get;\n\t}\n"]}
{"filename": "dist/src/utils/handleUrl.d.ts", "chunked_list": ["export default function _url(url: string, queries: {}): string;\n"]}
{"filename": "dist/src/utils/useProxies.d.ts", "chunked_list": ["export default function useProxies(callback: Function): Promise<unknown>;\n"]}
{"filename": "dist/src/utils/getAgent.d.ts", "chunked_list": ["export default function getAgent(): string;\n"]}
{"filename": "dist/src/lib/index.d.ts", "chunked_list": ["import { Options as GoogleOptions } from '../types/Google';\n\timport { Options as BingOptions } from '../types/Bing';\n\timport { Options as WikipediaOptions } from '../types/Wikipedia';\n\timport { Options as YouTubeOptions } from '../types/YouTube';\n\tdeclare const _default: {\n\t    google: (query: string, options?: GoogleOptions, engine?: 0 | 1) => Promise<{}>;\n\t    bing: (query: string, options?: BingOptions, engine?: 0 | 1) => Promise<{}>;\n\t    wikipedia: (query: string, options?: WikipediaOptions) => Promise<{}>;\n\t    youtube: (query: string, options?: YouTubeOptions) => Promise<{}>;\n\t};\n", "export default _default;\n"]}
{"filename": "dist/src/types/Bing.d.ts", "chunked_list": ["export declare const getOptions: () => Options;\n\texport interface _proxy {\n\t    host: string;\n\t    port: number;\n\t    auth?: {\n\t        username: string;\n\t        password: string;\n\t    };\n\t}\n\texport interface Options {\n", "    mkt?: string;\n\t    page?: number;\n\t    perPage?: number;\n\t    safe?: 'off' | 'moderate' | 'strict';\n\t    headers?: {\n\t        [key: string]: any;\n\t    };\n\t    proxy?: _proxy;\n\t    proxies?: _proxy[];\n\t    queries?: {\n", "        [key: string]: any;\n\t    } | undefined;\n\t}\n"]}
{"filename": "dist/src/types/YouTube.d.ts", "chunked_list": ["export declare const getOptions: () => Options;\n\texport interface _proxy {\n\t    host: string;\n\t    port: number;\n\t    auth?: {\n\t        username: string;\n\t        password: string;\n\t    };\n\t}\n\texport interface Options {\n", "    headers?: {\n\t        [key: string]: any;\n\t    };\n\t    proxy?: _proxy;\n\t    proxies?: _proxy[];\n\t    queries?: {\n\t        [key: string]: any;\n\t    } | undefined;\n\t}\n"]}
{"filename": "dist/src/types/Google.d.ts", "chunked_list": ["export declare const getOptions: () => Options;\n\texport interface _proxy {\n\t    host: string;\n\t    port: number;\n\t    auth?: {\n\t        username: string;\n\t        password: string;\n\t    };\n\t}\n\texport interface Options {\n", "    mkt?: string;\n\t    page?: number;\n\t    perPage?: number;\n\t    safe?: 'off' | 'active' | 'high' | 'medium' | 'safeUndefined';\n\t    headers?: {\n\t        [key: string]: any;\n\t    };\n\t    proxy?: _proxy;\n\t    proxies?: _proxy[];\n\t    queries?: {\n", "        [key: string]: any;\n\t    } | undefined;\n\t}\n"]}
{"filename": "dist/src/types/Wikipedia.d.ts", "chunked_list": ["export declare const getOptions: () => Options;\n\texport interface _proxy {\n\t    host: string;\n\t    port: number;\n\t    auth?: {\n\t        username: string;\n\t        password: string;\n\t    };\n\t}\n\texport interface Options {\n", "    language?: string;\n\t    headers?: {\n\t        [key: string]: any;\n\t    };\n\t    proxy?: _proxy;\n\t    proxies?: _proxy[];\n\t    queries?: {\n\t        [key: string]: any;\n\t    } | undefined;\n\t}\n"]}
{"filename": "examples/youtube.spec.ts", "chunked_list": ["import { YouTube } from '../src';\n\tconst youtube = new YouTube({\n\t    proxies: [\n\t        // ...\n\t    ]\n\t});\n\tyoutube.search('Barış Özcan').then(data => {\n\t    console.log(data);\n\t}).catch(error => {\n\t    console.log(error);\n", "});\n"]}
{"filename": "examples/bing.spec.ts", "chunked_list": ["import { Bing } from '../src';\n\tconst bing = new Bing({\n\t    mkt: 'tr-tr',\n\t    perPage: 10,\n\t    safe: 'off',\n\t    proxies: [\n\t        // ...\n\t    ]\n\t});\n\tbing.search('Youtube').then(data => {\n", "    console.log(data);\n\t}).catch(error => {\n\t    console.log(error);\n\t});\n"]}
{"filename": "examples/index.spec.ts", "chunked_list": ["import { Engine } from '../src';\n\tEngine.google('Google', {\n\t    mkt: 'tr-TR',\n\t    perPage: 20,\n\t    safe: 'off',\n\t    proxies: [\n\t        // ...\n\t    ]\n\t}, 0).then(data => {\n\t    console.log(data);\n", "}).catch(error => {\n\t    console.log(error);\n\t});\n"]}
{"filename": "examples/google.spec.ts", "chunked_list": ["import { Google } from '../src';\n\tconst google = new Google({\n\t    mkt: 'tr-TR',\n\t    perPage: 5,\n\t    safe: 'off',\n\t    proxies: [\n\t        // ...\n\t    ]\n\t});\n\tgoogle.suggestions('Google').then(data => {\n", "    console.log(data);\n\t}).catch(error => {\n\t    console.log(error);\n\t});\n"]}
{"filename": "examples/wikipedia.spec.ts", "chunked_list": ["import { Wikipedia } from '../src';\n\tconst wikipedia = new Wikipedia({\n\t    language: 'tr',\n\t    proxies: [\n\t        // ...\n\t    ]\n\t});\n\twikipedia.get('Google').then(data => {\n\t    console.log(data);\n\t}).catch(error => {\n", "    console.log(error);\n\t});\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from '../src/engines';\n\texport { default as Engine } from '../src/lib';"]}
{"filename": "src/engines/index.ts", "chunked_list": ["export { Google } from './lib/Google';\n\texport { Bing } from './lib/Bing';\n\texport { Wikipedia } from './lib/Wikipedia';\n\texport { YouTube } from './lib/YouTube';\n"]}
{"filename": "src/engines/lib/Wikipedia.ts", "chunked_list": ["import axios from \"axios\";\n\timport { getOptions, Options } from \"../../types/Wikipedia\";\n\timport * as cheerio from 'cheerio';\n\timport HttpsProxyAgent from 'https-proxy-agent';\n\timport _url from \"../../utils/handleUrl\";\n\timport useProxies from \"../../utils/useProxies\";\n\timport https from 'https';\n\texport class Wikipedia {\n\t    private options: Options = getOptions();\n\t    private updateQueries: (name: string, value: any) => void;\n", "    constructor(options: Options = getOptions()) {\n\t        let _options = {\n\t            ...getOptions(),\n\t            ...options\n\t        };\n\t        function updateQueries(name: string, value: any) {\n\t            _options.queries = {\n\t                ..._options.queries,\n\t                [name]: value\n\t            }\n", "        }\n\t        this.updateQueries = updateQueries;\n\t        this.options = _options;\n\t    }\n\t    useProxies = useProxies;\n\t    public async get(query: string): Promise<{}> {\n\t        const __proxy = this.options.proxy;\n\t        if (__proxy) {\n\t            this.options.proxies.push(__proxy);\n\t            this.options.proxy = undefined;\n", "        }\n\t        return await this.useProxies(() => this._get(query));\n\t    }\n\t    private async _get(query: string): Promise<{}> {\n\t        return new Promise(async (resolve, reject) => {\n\t            const agent = this.options.proxy ? HttpsProxyAgent({\n\t                host: this.options.proxy?.host,\n\t                port: this.options.proxy?.port,\n\t                auth: this.options.proxy?.auth ? this.options.proxy?.auth?.username + ':' + this.options.proxy?.auth?.password : undefined\n\t            }) : new https.Agent({\n", "                rejectUnauthorized: false\n\t            });\n\t            return await axios(Object.assign({\n\t                url: _url(`https://${this.options.language}.wikipedia.org/wiki/${query.replace(/ /g, '_')}`, this.options.queries),\n\t                method: 'GET',\n\t                headers: this.options.headers,\n\t            }, (agent ? {\n\t                proxy: this.options.proxy ? {\n\t                    host: this.options.proxy?.host,\n\t                    port: this.options.proxy?.port,\n", "                    auth: {\n\t                        username: this.options.proxy?.auth?.username,\n\t                        password: this.options.proxy?.auth?.password\n\t                    }\n\t                } : undefined,\n\t                httpsAgent: agent\n\t            } : {}))).then(response => {\n\t                const html = response.data;\n\t                const $ = cheerio.load(html);\n\t                let result: {\n", "                    title?: string,\n\t                    image?: string,\n\t                    description?: {\n\t                        clean?: string,\n\t                        links?: any[],\n\t                        markdown?: string\n\t                    }\n\t                    infobox?: any[]\n\t                } = {\n\t                    title: undefined,\n", "                    image: undefined,\n\t                    description: {\n\t                        clean: undefined,\n\t                        links: undefined,\n\t                        markdown: undefined\n\t                    },\n\t                    infobox: undefined\n\t                };\n\t                const fixText = (text: string) => text.replace(/(\\r\\n|\\n|\\r)/gm, '').replace(/\\s+/g, ' ').trim();\n\t                const formatLink = (text: string) => {\n", "                    let _ = text;\n\t                    const regex = /\\(([^)]+)\\)/;\n\t                    const match = regex.exec(_);\n\t                    if (match) {\n\t                        const m = match[1];\n\t                        _ = _.replace(`_(${m})`, '');\n\t                    }\n\t                    _ = _.replace('/wiki/', '').replace(/_/g, '+').toLowerCase();\n\t                    if (_.endsWith('.')) _ = _.slice(0, _.length - 1);\n\t                    return `https://nustry.com/search?q=${_}`\n", "                }\n\t                $('.mw-parser-output').each((i, element) => {\n\t                    const $element = $(element);\n\t                    const $p = $element.find('p').not('.mw-empty-elt');\n\t                    $p.find('sup').remove();\n\t                    $p.first().each((i, element) => {\n\t                        const $element = $(element);\n\t                        const text = $element.text();\n\t                        const links: any[] = [];\n\t                        $element.find('a').each((i, element) => {\n", "                            const $element = $(element);\n\t                            const href = $element.attr('href');\n\t                            if (href && href.startsWith('/wiki/')) {\n\t                                links.push({\n\t                                    href: href,\n\t                                    text: $element.text()\n\t                                })\n\t                            }\n\t                        });\n\t                        result.description.clean = fixText(text);\n", "                        result.description.links = links;\n\t                        result.description.markdown = links.reduce((prev, curr) => {\n\t                            return prev.replace(curr.text, `[${curr.text}](${formatLink(curr.href)})`);\n\t                        }, fixText(text));\n\t                    });\n\t                });\n\t                $('.infobox').each((i, element) => {\n\t                    const $element = $(element);\n\t                    result.title = $element.find('caption').first().text();\n\t                    result.image = $element.find('a.image img').first().attr('src');\n", "                    const $tr = $element.find('tr');\n\t                    let values: any[] = [];\n\t                    $tr.each((i, element) => {\n\t                        const $element = $(element);\n\t                        const $th = $element.find('th');\n\t                        const $td = $element.find('td');\n\t                        $td.find('sup').remove();\n\t                        const th = $th.text();\n\t                        if (!th) return;\n\t                        const isHaveLI = $td.find('li').length > 0;\n", "                        const isHaveTable = $td.find('table').length > 0;\n\t                        const isHaveBR = $td.find('br').length > 0;\n\t                        let res: any = [fixText($td.text())];\n\t                        if (isHaveLI) {\n\t                            const $li = $td.find('li');\n\t                            const li: string[] = [];\n\t                            $li.each((i, element) => {\n\t                                const $element = $(element);\n\t                                li.push(fixText($element.text()));\n\t                            });\n", "                            res = li;\n\t                        } else if (isHaveTable) {\n\t                            const $table = $td.find('table');\n\t                            const table: {\n\t                                [key: string]: any\n\t                            } = {};\n\t                            $table.each((i, element) => {\n\t                                const $element = $(element);\n\t                                const $tr = $element.find('tr');\n\t                                $tr.each((i, element) => {\n", "                                    const $element = $(element);\n\t                                    const $th = $element.find('th');\n\t                                    const $td = $element.find('td');\n\t                                    const th = fixText($th.text());\n\t                                    if (!th) return;\n\t                                    table[th] = fixText($td.text());\n\t                                });\n\t                            });\n\t                            res = table;\n\t                        } else if (isHaveBR) {\n", "                            const removeTags = (text: string) => text.replace(/(<([^>]+)>)/gi, '');\n\t                            res = $td.html().split('<br>').map((text: string) => {\n\t                                return fixText(removeTags(text));\n\t                            })\n\t                        }\n\t                        const response = res;\n\t                        const $a = $td.find('a');\n\t                        const href = $a.attr('href');\n\t                        let links: any[] = [];\n\t                        if (href) {\n", "                            $a.map((i, element) => {\n\t                                const $element = $(element);\n\t                                links.push({\n\t                                    href: $element.attr('href'),\n\t                                    text: $element.text(),\n\t                                    isFound: $element.attr('href').startsWith('/wiki/')\n\t                                });\n\t                            });\n\t                        }\n\t                        const _ = {\n", "                            label: th,\n\t                            response: {\n\t                                clean: response,\n\t                                markdown: links.reduce((prev, curr) => {\n\t                                    return prev.replace(curr.text, `[${curr.text}](${formatLink(curr.href)})`);\n\t                                }, fixText($td.text()))\n\t                            },\n\t                            links\n\t                        };\n\t                        values.push(_);\n", "                    });\n\t                    result['infobox'] = values\n\t                });\n\t                const data = {\n\t                    result,\n\t                    proxy: this.options.proxy,\n\t                    queries: this.options.queries\n\t                };\n\t                return resolve(data);\n\t            }).catch(error => {\n", "                return reject(error);\n\t            });\n\t        });\n\t    }\n\t}"]}
{"filename": "src/engines/lib/Bing.ts", "chunked_list": ["import axios from \"axios\";\n\timport { getOptions, Options } from \"../../types/Bing\";\n\timport * as cheerio from 'cheerio';\n\timport HttpsProxyAgent from 'https-proxy-agent';\n\timport _url from \"../../utils/handleUrl\";\n\timport useProxies from \"../../utils/useProxies\";\n\timport https from 'https';\n\texport class Bing {\n\t    private options: Options = getOptions();\n\t    private updateQueries: (name: string, value: any) => void;\n", "    constructor(options: Options = getOptions()) {\n\t        let _options = {\n\t            ...getOptions(),\n\t            ...options\n\t        };\n\t        function updateQueries(name: string, value: any) {\n\t            _options.queries = {\n\t                ..._options.queries,\n\t                [name]: value\n\t            }\n", "        }\n\t        if (_options?.mkt) {\n\t            if (!_options?.queries?.mkt) updateQueries('mkt', _options?.mkt);\n\t            if (!_options?.queries?.setlang) updateQueries('setlang', _options?.mkt);\n\t        }\n\t        if (_options?.safe) {\n\t            if (!_options?.queries?.safe) updateQueries('safeSearch', _options?.safe);\n\t        }\n\t        if (_options?.perPage) {\n\t            if (!_options?.queries?.count) updateQueries('count', _options?.perPage);\n", "            if (!_options?.queries?.offset) updateQueries('offset', (_options?.perPage * (_options?.page - 1)));\n\t        }\n\t        if (!_options?.queries?.pt) updateQueries('pt', 'page.serp');\n\t        if (!_options?.queries?.mkt) updateQueries('mkt', 'en-us');\n\t        if (!_options?.queries?.cp) updateQueries('cp', 6);\n\t        if (!_options?.queries?.msbqf) updateQueries('msbqf', false);\n\t        if (!_options?.queries?.cvid) updateQueries('cvid', 'void_development');\n\t        this.updateQueries = updateQueries;\n\t        this.options = _options;\n\t    }\n", "    useProxies = useProxies;\n\t    public async search(query: string): Promise<{}> {\n\t        if (!this.options?.queries?.bq) this.updateQueries('bq', query);\n\t        if (!this.options?.queries?.q) this.updateQueries('q', query);\n\t        if (!this.options?.queries?.qry) this.updateQueries('qry', query);\n\t        const __proxy = this.options.proxy;\n\t        if (__proxy) {\n\t            this.options.proxies.push(__proxy);\n\t            this.options.proxy = undefined;\n\t        }\n", "        return await this.useProxies(() => this._search(query));\n\t    }\n\t    private async _search(query: string): Promise<{}> {\n\t        return new Promise(async (resolve, reject) => {\n\t            const agent = this.options.proxy ? HttpsProxyAgent({\n\t                host: this.options.proxy?.host,\n\t                port: this.options.proxy?.port,\n\t                auth: this.options.proxy?.auth?.username + ':' + this.options.proxy?.auth?.password\n\t            }) : new https.Agent({\n\t                rejectUnauthorized: false\n", "            });\n\t            return await axios(Object.assign({\n\t                url: _url(`https://www.bing.com/search`, this.options.queries),\n\t                method: 'GET',\n\t                headers: this.options.headers\n\t            }, (agent ? {\n\t                proxy: this.options.proxy ? {\n\t                    host: this.options.proxy?.host,\n\t                    port: this.options.proxy?.port,\n\t                    auth: {\n", "                        username: this.options.proxy?.auth?.username,\n\t                        password: this.options.proxy?.auth?.password\n\t                    }\n\t                } : undefined,\n\t                httpsAgent: agent\n\t            } : {}))).then(response => {\n\t                const html = response.data;\n\t                const $ = cheerio.load(html);\n\t                const results: any[] = [];\n\t                $('#b_results .b_algo').each((i, el) => {\n", "                    const title = $(el).find('h2 a').first().text();\n\t                    const description = $(el).find('.b_algoSlug').each((i, el) => {\n\t                        $(el).find('span').remove();\n\t                    }).text();\n\t                    const link = $(el).find('a').first().attr('href');\n\t                    const deepLinks: any[] = [];\n\t                    $(el).find('.b_deep li').each((i, el) => {\n\t                        deepLinks.push({\n\t                            title: $(el).find('a').text(),\n\t                            link: $(el).find('a').attr('href'),\n", "                            description: $(el).find('p').text()\n\t                        });\n\t                    });\n\t                    results.push({\n\t                        title,\n\t                        description,\n\t                        link,\n\t                        deepLinks\n\t                    });\n\t                });\n", "                const data = {\n\t                    results,\n\t                    proxy: this.options.proxy,\n\t                    queries: this.options.queries\n\t                };\n\t                return resolve(data);\n\t            }).catch(error => {\n\t                return reject(error);\n\t            });\n\t        });\n", "    }\n\t    public async suggestions(query: string): Promise<{}> {\n\t        if (!this.options?.queries?.bq) this.updateQueries('bq', query);\n\t        if (!this.options?.queries?.q) this.updateQueries('q', query);\n\t        if (!this.options?.queries?.qry) this.updateQueries('qry', query);\n\t        const __proxy = this.options.proxy;\n\t        if (__proxy) {\n\t            this.options.proxies.push(__proxy);\n\t            this.options.proxy = undefined;\n\t        }\n", "        return await this.useProxies(() => this._suggestions(query));\n\t    }\n\t    private async _suggestions(query: string): Promise<{}> {\n\t        return new Promise(async (resolve, reject) => {\n\t            const agent = this.options.proxy ? HttpsProxyAgent({\n\t                host: this.options.proxy?.host,\n\t                port: this.options.proxy?.port,\n\t                auth: this.options.proxy?.auth?.username + ':' + this.options.proxy?.auth?.password\n\t            }) : new https.Agent({\n\t                rejectUnauthorized: false\n", "            });\n\t            return await axios(Object.assign({\n\t                url: _url(`https://www.bing.com/AS/Suggestions`, this.options.queries),\n\t                method: 'GET',\n\t                headers: this.options.headers\n\t            }, (agent ? {\n\t                proxy: this.options.proxy ? {\n\t                    host: this.options.proxy?.host,\n\t                    port: this.options.proxy?.port,\n\t                    auth: {\n", "                        username: this.options.proxy?.auth?.username,\n\t                        password: this.options.proxy?.auth?.password\n\t                    }\n\t                } : undefined,\n\t                httpsAgent: agent\n\t            } : {}))).then(response => {\n\t                const html = response.data;\n\t                const $ = cheerio.load(html);\n\t                const suggestions: any[] = [];\n\t                $('#sa_ul li').each((i, el) => {\n", "                    suggestions.push({\n\t                        text: $(el).find('.pp_title').text() || $(el).find('.sa_tm_text').text() || null,\n\t                        image: $(el).find('img').attr('src') ? 'https://th.bing.com' + $(el).find('img').attr('src') : null\n\t                    });\n\t                });\n\t                const data = {\n\t                    suggestions: suggestions.filter(s => s.text),\n\t                    proxy: this.options.proxy,\n\t                    queries: this.options.queries\n\t                };\n", "                return resolve(data);\n\t            }).catch(error => {\n\t                return reject(error);\n\t            });\n\t        });\n\t    }\n\t    public async images(query: string): Promise<{}> {\n\t        return new Error('Not implemented yet');\n\t    }\n\t}"]}
{"filename": "src/engines/lib/Google.ts", "chunked_list": ["import axios from \"axios\";\n\timport { getOptions, Options } from \"../../types/Google\";\n\timport * as cheerio from 'cheerio';\n\timport HttpsProxyAgent from 'https-proxy-agent';\n\timport _url from \"../../utils/handleUrl\";\n\timport useProxies from \"../../utils/useProxies\";\n\timport https from 'https';\n\texport class Google {\n\t    private options: Options = getOptions();\n\t    private updateQueries: (name: string, value: any) => void;\n", "    constructor(options: Options = getOptions()) {\n\t        let _options = {\n\t            ...getOptions(),\n\t            ...options\n\t        };\n\t        function updateQueries(name: string, value: any) {\n\t            _options.queries = {\n\t                ..._options.queries,\n\t                [name]: value\n\t            }\n", "        }\n\t        if (_options?.mkt) {\n\t            if (!_options?.queries?.lr) updateQueries('lr', 'lang_' + (_options?.mkt?.split('-')?.[0] || 'en'));\n\t            if (!_options?.queries?.hl) updateQueries('hl', _options?.mkt?.split('-')?.[0] || 'en');\n\t            if (!_options?.queries?.gl) updateQueries('gl', _options?.mkt?.split('-')?.[1] || 'US');\n\t        }\n\t        if (_options?.safe) {\n\t            if (!_options?.queries?.safe) updateQueries('safe', _options?.safe);\n\t        }\n\t        if (_options?.perPage) {\n", "            if (!_options?.queries?.num) updateQueries('num', _options?.perPage);\n\t            if (!_options?.queries?.start) updateQueries('start', (_options?.page - 1) * _options?.perPage);\n\t        }\n\t        this.updateQueries = updateQueries;\n\t        this.options = _options;\n\t    }\n\t    useProxies = useProxies;\n\t    public async search(query: string): Promise<{}> {\n\t        if (!this.options?.queries?.q) this.updateQueries('q', query);\n\t        const __proxy = this.options.proxy;\n", "        if (__proxy) {\n\t            this.options.proxies.push(__proxy);\n\t            this.options.proxy = undefined;\n\t        }\n\t        return await this.useProxies(() => this._search(query));\n\t    }\n\t    private async _search(query: string): Promise<{}> {\n\t        return new Promise(async (resolve, reject) => {\n\t            const agent = this.options.proxy ? HttpsProxyAgent({\n\t                host: this.options.proxy?.host,\n", "                port: this.options.proxy?.port,\n\t                auth: this.options.proxy?.auth?.username + ':' + this.options.proxy?.auth?.password\n\t            }) : new https.Agent({\n\t                rejectUnauthorized: false\n\t            });\n\t            return await axios(Object.assign({\n\t                url: _url(`https://www.google.com/search`, this.options.queries),\n\t                method: 'GET',\n\t                headers: this.options.headers\n\t            }, (agent ? {\n", "                proxy: this.options.proxy ? {\n\t                    host: this.options.proxy?.host,\n\t                    port: this.options.proxy?.port,\n\t                    auth: {\n\t                        username: this.options.proxy?.auth?.username,\n\t                        password: this.options.proxy?.auth?.password\n\t                    }\n\t                } : undefined,\n\t                httpsAgent: agent\n\t            } : {}))).then(response => {\n", "                const html = response.data;\n\t                const $ = cheerio.load(html);\n\t                const results: any[] = [];\n\t                const stats: any = {};\n\t                const relatedSearches: any[] = [];\n\t                $('#search .g').each((i, elem) => {\n\t                    if ($(elem).hasClass('VjDLd')) return;\n\t                    const favicon = $(elem).find('img').first().attr('src');\n\t                    const title = $(elem).find('.DKV0Md').first().text();\n\t                    const link = $(elem).find('a').first().attr('href');\n", "                    const description = $(elem).find('.yDYNvb').first().text();\n\t                    const deepLinks: any[] = [];\n\t                    $(elem).find('.mslg').each((i, elem) => {\n\t                        const h3 = $(elem).find('h3').text();\n\t                        const link = $(elem).find('a').attr('href');\n\t                        const description = $(elem).find('.zz3gNc').text();\n\t                        deepLinks.push({\n\t                            title: h3,\n\t                            link: link?.replace('/url?q=', ''),\n\t                            description\n", "                        });\n\t                    });\n\t                    $(elem).find('.XN9cAe').each((i, elem) => {\n\t                        const h3 = $(elem).find('h3').text();\n\t                        const link = $(elem).find('a').attr('href');\n\t                        const description = $(elem).find('.yDYNvb').text();\n\t                        deepLinks.push({\n\t                            title: h3,\n\t                            link: link?.replace('/url?q=', ''),\n\t                            description\n", "                        });\n\t                    });\n\t                    results.push({\n\t                        favicon,\n\t                        title,\n\t                        link,\n\t                        description,\n\t                        deepLinks\n\t                    });\n\t                });\n", "                const resultStats = $('#result-stats').text();\n\t                if (resultStats.match(/\\(([^)]+)\\)/)) {\n\t                    const onlyInBrackets = resultStats.match(/\\(([^)]+)\\)/);\n\t                    const onlyNumbers = resultStats.split(onlyInBrackets[0])[0].match(/\\d+/g).join('');\n\t                    stats.totalResults = Number(onlyNumbers);\n\t                    stats.timeTaken = onlyInBrackets[1];\n\t                }\n\t                $('#botstuff').each((i, elem) => {\n\t                    $(elem).find('b').each((i, elem) => {\n\t                        relatedSearches.push($(elem).text());\n", "                    });\n\t                });\n\t                const data = {\n\t                    results,\n\t                    relatedSearches,\n\t                    stats,\n\t                    proxy: this.options.proxy,\n\t                    queries: this.options.queries\n\t                };\n\t                return resolve(data);\n", "            }).catch(error => {\n\t                return reject(error);\n\t            });\n\t        });\n\t    }\n\t    public async suggestions(query: string): Promise<{}> {\n\t        if (!this.options?.queries?.q) this.updateQueries('q', query);\n\t        this.updateQueries('cp', 6);\n\t        this.updateQueries('xssi', 't');\n\t        this.updateQueries('authuser', 0);\n", "        this.updateQueries('client', 'gws-wiz');\n\t        this.updateQueries('dpr', 1);\n\t        const __proxy = this.options.proxy;\n\t        if (__proxy) {\n\t            this.options.proxies.push(__proxy);\n\t            this.options.proxy = undefined;\n\t        }\n\t        return await this.useProxies(() => this._suggestions(query));\n\t    }\n\t    private async _suggestions(query: string): Promise<{}> {\n", "        return new Promise(async (resolve, reject) => {\n\t            const agent = this.options.proxy ? HttpsProxyAgent({\n\t                host: this.options.proxy?.host,\n\t                port: this.options.proxy?.port,\n\t                auth: this.options.proxy?.auth?.username + ':' + this.options.proxy?.auth?.password\n\t            }) : new https.Agent({\n\t                rejectUnauthorized: false\n\t            });\n\t            return await axios(Object.assign({\n\t                url: _url(`https://www.google.com/complete/search`, this.options.queries),\n", "                method: 'GET',\n\t                headers: this.options.headers\n\t            }, (agent ? {\n\t                proxy: this.options.proxy ? {\n\t                    host: this.options.proxy?.host,\n\t                    port: this.options.proxy?.port,\n\t                    auth: {\n\t                        username: this.options.proxy?.auth?.username,\n\t                        password: this.options.proxy?.auth?.password\n\t                    }\n", "                } : undefined,\n\t                httpsAgent: agent\n\t            } : {}))).then(response => {\n\t                const html = response.data;\n\t                const suggestions: any[] = [];\n\t                const _data = html.split(')]}\\'')[1];\n\t                const json = JSON.parse(_data);\n\t                json[0].forEach((elem: any) => {\n\t                    const string = elem[0];\n\t                    const type = elem[1];\n", "                    const weight = elem[2];\n\t                    const data = elem[3];\n\t                    suggestions.push({\n\t                        string: {\n\t                            text: string.replace(/<b>/g, '').replace(/<\\/b>/g, ''),\n\t                            html: string,\n\t                            markdown: string.replace(/<b>/g, '**').replace(/<\\/b>/g, '**')\n\t                        },\n\t                        type,\n\t                        weight,\n", "                        data\n\t                    });\n\t                });\n\t                const data = {\n\t                    suggestions,\n\t                    proxy: this.options.proxy,\n\t                    queries: this.options.queries\n\t                };\n\t                return resolve(data);\n\t            }).catch(error => {\n", "                console.log(error);\n\t                return reject(error);\n\t            });\n\t        });\n\t    }\n\t    public async images(query: string): Promise<{}> {\n\t        return new Error('Not implemented yet');\n\t    }\n\t}"]}
{"filename": "src/engines/lib/YouTube.ts", "chunked_list": ["import axios from \"axios\";\n\timport { getOptions, Options } from \"../../types/YouTube\";\n\timport * as cheerio from 'cheerio';\n\timport HttpsProxyAgent from 'https-proxy-agent';\n\timport _url from \"../../utils/handleUrl\";\n\timport useProxies from \"../../utils/useProxies\";\n\timport https from 'https';\n\texport class YouTube {\n\t    private options: Options = getOptions();\n\t    private updateQueries: (name: string, value: any) => void;\n", "    constructor(options: Options = getOptions()) {\n\t        let _options = {\n\t            ...getOptions(),\n\t            ...options\n\t        };\n\t        function updateQueries(name: string, value: any) {\n\t            _options.queries = {\n\t                ..._options.queries,\n\t                [name]: value\n\t            }\n", "        }\n\t        this.updateQueries = updateQueries;\n\t        this.options = _options;\n\t    }\n\t    useProxies = useProxies;\n\t    public async search(query: string): Promise<{}> {\n\t        this.updateQueries('search_query', encodeURIComponent(query));\n\t        const __proxy = this.options.proxy;\n\t        if (__proxy) {\n\t            this.options.proxies.push(__proxy);\n", "            this.options.proxy = undefined;\n\t        }\n\t        return await this.useProxies(() => this._search(query));\n\t    }\n\t    private async _search(query: string): Promise<{}> {\n\t        return new Promise(async (resolve, reject) => {\n\t            const agent = this.options.proxy ? HttpsProxyAgent({\n\t                host: this.options.proxy?.host,\n\t                port: this.options.proxy?.port,\n\t                auth: this.options.proxy?.auth?.username + ':' + this.options.proxy?.auth?.password\n", "            }) : new https.Agent({\n\t                rejectUnauthorized: false\n\t            });\n\t            return await axios(Object.assign({\n\t                url: _url(`https://www.youtube.com/results`, this.options.queries),\n\t                method: 'GET',\n\t                headers: this.options.headers\n\t            }, (agent ? {\n\t                proxy: this.options.proxy ? {\n\t                    host: this.options.proxy?.host,\n", "                    port: this.options.proxy?.port,\n\t                    auth: {\n\t                        username: this.options.proxy?.auth?.username,\n\t                        password: this.options.proxy?.auth?.password\n\t                    }\n\t                } : undefined,\n\t                httpsAgent: agent\n\t            } : {}))).then((response) => {\n\t                const html = response.data;\n\t                const $ = cheerio.load(html);\n", "                let results: any[] = [];\n\t                $('script').each((index, element) => {\n\t                    const text = $(element).text();\n\t                    if (text.includes('ytInitialData')) {\n\t                        const regex = /var ytInitialData = \\{(.|\\n)*\\}/gm;\n\t                        const data = text.match(regex);\n\t                        if (data) {\n\t                            const json = JSON.parse(data[0].replace('var ytInitialData = ', ''));\n\t                            const contents = json.contents.twoColumnSearchResultsRenderer.primaryContents.sectionListRenderer.contents[0].itemSectionRenderer.contents.filter((content: any) => content.videoRenderer);\n\t                            for (let i = 0; i < contents.length; i++) {\n", "                                const content = contents[i];\n\t                                if (content.videoRenderer) {\n\t                                    const video = content.videoRenderer;\n\t                                    const result = {\n\t                                        id: video.videoId,\n\t                                        title: video.title.runs[0].text,\n\t                                        description: video.detailedMetadataSnippets?.[0]?.snippetText?.runs?.map((run: any) => run.text).join('') || null,\n\t                                        duration: video.lengthText?.simpleText,\n\t                                        views: Number(video.viewCountText?.simpleText?.replace(/[^0-9]/g, '')),\n\t                                        thumbnail: video.thumbnail.thumbnails[0].url,\n", "                                        channel: {\n\t                                            id: video.ownerText.runs[0].navigationEndpoint.browseEndpoint.browseId,\n\t                                            name: video.ownerText.runs[0].text,\n\t                                            url: video.ownerText.runs[0].navigationEndpoint.browseEndpoint.canonicalBaseUrl,\n\t                                            verified: video.ownerBadges[0]?.metadataBadgeRenderer.tooltip === 'Verified' ? true : false\n\t                                        },\n\t                                        url: video.navigationEndpoint.commandMetadata.webCommandMetadata.url,\n\t                                        published: video.publishedTimeText?.simpleText\n\t                                    };\n\t                                    results.push(result);\n", "                                }\n\t                            }\n\t                        }\n\t                    }\n\t                });\n\t                const data = {\n\t                    results,\n\t                    proxy: this.options.proxy,\n\t                    queries: this.options.queries\n\t                };\n", "                return resolve(data);\n\t            }).catch(error => {\n\t                return reject(error);\n\t            });\n\t        });\n\t    }\n\t}"]}
{"filename": "src/utils/handleUrl.ts", "chunked_list": ["export default function _url(url: string, queries: {}): string {\n\t    if (url.includes('?')) {\n\t        url += '&' + Object.keys(queries || {}).map(key => `${key}=${(queries as any)[key]}`).join('&');\n\t    } else {\n\t        url += '?' + Object.keys(queries || {}).map(key => `${key}=${(queries as any)[key]}`).join('&');\n\t    }\n\t    return url;\n\t}"]}
{"filename": "src/utils/useProxies.ts", "chunked_list": ["export default function useProxies(callback: Function) {\n\t    return new Promise(async (resolve, reject) => {\n\t        try {\n\t            const _proxy = Array.isArray(this.options.proxies);\n\t            if (this.options.proxies && _proxy) {\n\t                for (let i = 0; i < this.options.proxies.length; i++) {\n\t                    const proxy = this.options.proxies[i];\n\t                    this.options.proxy = proxy;\n\t                    try {\n\t                        const cb = await callback();\n", "                        return resolve(cb);\n\t                    } catch (error) {\n\t                        if (this.options.proxies.length - 1 === i) {\n\t                            throw new Error(error);\n\t                        }\n\t                        continue;\n\t                    }\n\t                }\n\t            }\n\t            const cb = await callback();\n", "            return resolve(cb);\n\t        } catch (error) {\n\t            return reject(error);\n\t        }\n\t    })\n\t}"]}
{"filename": "src/utils/getAgent.ts", "chunked_list": ["export default function getAgent(): string {\n\t    const agents: string[] = [\n\t        \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\"\n\t    ];\n\t    return agents[Math.floor(Math.random() * agents.length)];\n\t}"]}
{"filename": "src/lib/index.ts", "chunked_list": ["import * as Engines from '../engines';\n\t// TYPES\n\timport { getOptions as getGoogleOptions, Options as GoogleOptions } from '../types/Google';\n\timport { getOptions as getBingOptions, Options as BingOptions } from '../types/Bing';\n\timport { getOptions as getWikipediaOptions, Options as WikipediaOptions } from '../types/Wikipedia';\n\timport { getOptions as getYouTubeOptions, Options as YouTubeOptions } from '../types/YouTube';\n\texport default {\n\t    /*\n\t        *   Google\n\t        @param query: string\n", "        @param options: GoogleOptions\n\t        @param engine: 0 = Google, 1 = Google Suggestions\n\t    */\n\t    google: (query: string, options: GoogleOptions = getGoogleOptions(), engine: 0 | 1 = 0) => {\n\t        if (engine === 0) return new Engines.Google(options).search(query);\n\t        else if (engine === 1) return new Engines.Google(options).suggestions(query);\n\t        return new Engines.Google(options).search(query);\n\t    },\n\t    /*\n\t        *   Bing\n", "        @param query: string\n\t        @param options: GoogleOptions\n\t        @param engine: 0 = Google, 1 = Google Suggestions\n\t    */\n\t    bing: (query: string, options: BingOptions = getBingOptions(), engine: 0 | 1 = 0) => {\n\t        if (engine === 0) return new Engines.Bing(options).search(query);\n\t        else if (engine === 1) return new Engines.Bing(options).suggestions(query);\n\t        return new Engines.Bing(options).search(query);\n\t    },\n\t    wikipedia: (query: string, options: WikipediaOptions = getWikipediaOptions()) => {\n", "        return new Engines.Wikipedia(options).get(query);\n\t    },\n\t    youtube: (query: string, options: YouTubeOptions = getYouTubeOptions()) => {\n\t        return new Engines.YouTube(options).search(query);\n\t    }\n\t}; "]}
{"filename": "src/types/Wikipedia.ts", "chunked_list": ["import getAgent from \"../utils/getAgent\";\n\texport const getOptions = (): Options => {\n\t    return {\n\t        language: 'en',\n\t        headers: {\n\t            'Connection': 'keep-alive',\n\t            'Host': 'www.wikipedia.com',\n\t            'Pragma': 'no-cache',\n\t            'Referer': 'https://www.wikipedia.com/',\n\t            'Sec-Fetch-Mode': 'navigate',\n", "            'Sec-Fetch-Site': 'same-origin',\n\t            'Sec-Fetch-User': '?1',\n\t            'Upgrade-Insecure-Requests': '1',\n\t            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n\t            'accept-encoding': 'gzip, deflate, br',\n\t            'accept-language': 'en-US,en;q=0.9',\n\t            'cache-control': 'no-cache',\n\t            'sec-ch-ua-arch': '\"x86\"',\n\t            'sec-ch-ua-bitness': '\"64\"',\n\t            'sec-ch-ua-full-version': '\"110.0.5481.178\"',\n", "            'sec-ch-ua-full-version-list': '\"Chromium\";v=\"110.0.5481.178\", \"Not A(Brand\";v=\"24.0.0.0\", \"Google Chrome\";v=\"110.0.5481.178\"',\n\t            'sec-ch-ua-mobile': '?0',\n\t            'sec-ch-ua-model': '',\n\t            'sec-ch-ua-platform': '\"Windows\"',\n\t            'sec-ch-ua-platform-version': '\"10.0.0\"',\n\t            'sec-ch-ua-wow64': '?0',\n\t            'sec-ch-ua': '\"Chromium\";v=\"92\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"92\"',\n\t            'User-Agent': getAgent()\n\t        }\n\t    }\n", "}\n\texport interface _proxy {\n\t    host: string;\n\t    port: number;\n\t    auth?: {\n\t        username: string;\n\t        password: string;\n\t    }\n\t}\n\texport interface Options {\n", "    language?: string;\n\t    headers?: {\n\t        [key: string]: any;\n\t    }\n\t    proxy?: _proxy;\n\t    proxies?: _proxy[];\n\t    queries?: {\n\t        [key: string]: any;\n\t    } | undefined;\n\t}"]}
{"filename": "src/types/Bing.ts", "chunked_list": ["import getAgent from \"../utils/getAgent\";\n\texport const getOptions = (): Options => {\n\t    return {\n\t        mkt: 'en-US',\n\t        page: 1,\n\t        perPage: 10,\n\t        safe: 'off',\n\t        headers: {\n\t            'Connection': 'keep-alive',\n\t            'Host': 'www.bing.com',\n", "            'Pragma': 'no-cache',\n\t            'Referer': 'https://www.bing.com/',\n\t            'Sec-Fetch-Mode': 'navigate',\n\t            'Sec-Fetch-Site': 'same-origin',\n\t            'Sec-Fetch-User': '?1',\n\t            'Upgrade-Insecure-Requests': '1',\n\t            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n\t            'accept-encoding': 'gzip, deflate, br',\n\t            'accept-language': 'en-US,en;q=0.9',\n\t            'cache-control': 'no-cache',\n", "            'sec-ch-ua-arch': '\"x86\"',\n\t            'sec-ch-ua-bitness': '\"64\"',\n\t            'sec-ch-ua-full-version': '\"110.0.5481.178\"',\n\t            'sec-ch-ua-full-version-list': '\"Chromium\";v=\"110.0.5481.178\", \"Not A(Brand\";v=\"24.0.0.0\", \"Google Chrome\";v=\"110.0.5481.178\"',\n\t            'sec-ch-ua-mobile': '?0',\n\t            'sec-ch-ua-model': '',\n\t            'sec-ch-ua-platform': '\"Windows\"',\n\t            'sec-ch-ua-platform-version': '\"10.0.0\"',\n\t            'sec-ch-ua-wow64': '?0',\n\t            'sec-ch-ua': '\"Chromium\";v=\"92\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"92\"',\n", "            'User-Agent': getAgent()\n\t        }\n\t    }\n\t}\n\texport interface _proxy {\n\t    host: string;\n\t    port: number;\n\t    auth?: {\n\t        username: string;\n\t        password: string;\n", "    }\n\t}\n\texport interface Options {\n\t    mkt?: string;\n\t    page?: number;\n\t    perPage?: number;\n\t    safe?: 'off' | 'moderate' | 'strict';\n\t    headers?: {\n\t        [key: string]: any;\n\t    }\n", "    proxy?: _proxy;\n\t    proxies?: _proxy[];\n\t    queries?: {\n\t        [key: string]: any;\n\t    } | undefined;\n\t}"]}
{"filename": "src/types/Google.ts", "chunked_list": ["import getAgent from \"../utils/getAgent\";\n\texport const getOptions = (): Options => {\n\t    return {\n\t        mkt: 'en-US',\n\t        page: 1,\n\t        perPage: 10,\n\t        safe: 'off',\n\t        headers: {\n\t            'Connection': 'keep-alive',\n\t            'Host': 'www.google.com',\n", "            'Pragma': 'no-cache',\n\t            'Referer': 'https://www.google.com/',\n\t            'Sec-Fetch-Mode': 'navigate',\n\t            'Sec-Fetch-Site': 'same-origin',\n\t            'Sec-Fetch-User': '?1',\n\t            'Upgrade-Insecure-Requests': '1',\n\t            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n\t            'accept-encoding': 'gzip, deflate, br',\n\t            'accept-language': 'en-US,en;q=0.9',\n\t            'cache-control': 'no-cache',\n", "            'sec-ch-ua-arch': '\"x86\"',\n\t            'sec-ch-ua-bitness': '\"64\"',\n\t            'sec-ch-ua-full-version': '\"110.0.5481.178\"',\n\t            'sec-ch-ua-full-version-list': '\"Chromium\";v=\"110.0.5481.178\", \"Not A(Brand\";v=\"24.0.0.0\", \"Google Chrome\";v=\"110.0.5481.178\"',\n\t            'sec-ch-ua-mobile': '?0',\n\t            'sec-ch-ua-model': '',\n\t            'sec-ch-ua-platform': '\"Windows\"',\n\t            'sec-ch-ua-platform-version': '\"10.0.0\"',\n\t            'sec-ch-ua-wow64': '?0',\n\t            'sec-ch-ua': '\"Chromium\";v=\"92\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"92\"',\n", "            'User-Agent': getAgent()\n\t        }\n\t    }\n\t}\n\texport interface _proxy {\n\t    host: string;\n\t    port: number;\n\t    auth?: {\n\t        username: string;\n\t        password: string;\n", "    }\n\t}\n\texport interface Options {\n\t    mkt?: string;\n\t    page?: number;\n\t    perPage?: number;\n\t    safe?: 'off' | 'active' | 'high' | 'medium' | 'safeUndefined';\n\t    headers?: {\n\t        [key: string]: any;\n\t    }\n", "    proxy?: _proxy;\n\t    proxies?: _proxy[];\n\t    queries?: {\n\t        [key: string]: any;\n\t    } | undefined;\n\t}"]}
{"filename": "src/types/YouTube.ts", "chunked_list": ["import getAgent from \"../utils/getAgent\";\n\texport const getOptions = (): Options => {\n\t    return {\n\t        headers: {\n\t            'Connection': 'keep-alive',\n\t            'Host': 'www.youtube.com',\n\t            'Pragma': 'no-cache',\n\t            'Referer': 'https://www.youtube.com/results?search_query=',\n\t            'Sec-Fetch-Mode': 'navigate',\n\t            'Sec-Fetch-Site': 'same-origin',\n", "            'Sec-Fetch-User': '?1',\n\t            'Upgrade-Insecure-Requests': '1',\n\t            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',\n\t            'accept-encoding': 'gzip, deflate, br',\n\t            'accept-language': 'en-US,en;q=0.9',\n\t            'cache-control': 'no-cache',\n\t            'sec-ch-ua-arch': '\"x86\"',\n\t            'sec-ch-ua-bitness': '\"64\"',\n\t            'sec-ch-ua-full-version': '\"110.0.5481.178\"',\n\t            'sec-ch-ua-full-version-list': '\"Chromium\";v=\"110.0.5481.178\", \"Not A(Brand\";v=\"24.0.0.0\", \"Google Chrome\";v=\"110.0.5481.178\"',\n", "            'sec-ch-ua-mobile': '?0',\n\t            'sec-ch-ua-model': '',\n\t            'sec-ch-ua-platform': '\"Windows\"',\n\t            'sec-ch-ua-platform-version': '\"10.0.0\"',\n\t            'sec-ch-ua-wow64': '?0',\n\t            'sec-ch-ua': '\"Chromium\";v=\"92\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"92\"',\n\t            'User-Agent': getAgent()\n\t        }\n\t    }\n\t}\n", "export interface _proxy {\n\t    host: string;\n\t    port: number;\n\t    auth?: {\n\t        username: string;\n\t        password: string;\n\t    }\n\t}\n\texport interface Options {\n\t    headers?: {\n", "        [key: string]: any;\n\t    }\n\t    proxy?: _proxy;\n\t    proxies?: _proxy[];\n\t    queries?: {\n\t        [key: string]: any;\n\t    } | undefined;\n\t}"]}
