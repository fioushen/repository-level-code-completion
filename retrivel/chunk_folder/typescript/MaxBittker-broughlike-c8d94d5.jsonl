{"filename": "src/index.ts", "chunked_list": ["import Game from \"Game\";\n\timport * as PIXI from \"pixi.js\";\n\timport \"./style.css\";\n\tlet timeout: any = null;\n\tfunction onLoad() {\n\t  function doResize() {\n\t    game.resize();\n\t  }\n\t  const app = new PIXI.Application({\n\t    width: window.innerWidth,\n", "    height: window.innerHeight,\n\t    antialias: true,\n\t    transparent: false,\n\t    resolution: window.devicePixelRatio || 1,\n\t  });\n\t  app.renderer.view.style.position = \"absolute\";\n\t  app.renderer.view.style.display = \"block\";\n\t  app.renderer.plugins.interaction.interactionFrequency = 60;\n\t  const game = new Game(app);\n\t  clearTimeout(timeout);\n", "  timeout = setTimeout(doResize, 1000);\n\t  document.body.appendChild(app.view);\n\t  document.body.style.backgroundColor =\n\t  \"#\" + Game.BACKGROUND_COLOUR.toString(16).padStart(6, \"0\");\n\t  window.onresize = function (event: Event) {\n\t    doResize();\n\t    clearTimeout(timeout);\n\t    timeout = setTimeout(doResize, 500);\n\t  };\n\t  window.onkeydown = function (event: KeyboardEvent) {\n", "    if (\n\t      [\"Space\", \"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"].indexOf(\n\t        event.code\n\t      ) > -1\n\t    ) {\n\t      event.preventDefault();\n\t    }\n\t    game.keydown(event.code);\n\t  };\n\t}\n", "if (window.hasOwnProperty(\"cordova\")) {\n\t  document.addEventListener(\"deviceready\", onLoad, false);\n\t} else {\n\t  window.onload = onLoad;\n\t}\n"]}
{"filename": "src/Game.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\n\timport { Sound, sound } from \"@pixi/sound\";\n\timport { Actions } from \"pixi-actions\";\n\timport { Screen, GameScreen, MenuScreen } from \"screens\";\n\timport { Font } from \"utils\";\n\timport Save from \"./save/Save\";\n\timport * as _ from \"underscore\";\n\texport default class Game {\n\t  // Display options\n\t  static TARGET_WIDTH = 225;\n", "  static TARGET_HEIGHT = 345;\n\t  static INTEGER_SCALING = false;\n\t  static MAINTAIN_RATIO = false;\n\t  static BACKGROUND_COLOUR = 0x333333;\n\t  // Mouse\n\t  static HOLD_INITIAL_TIME_MS = 500;\n\t  static HOLD_REPEAT_TIME_MS = 400;\n\t  static SWIPE_TRIGGER_THRESHOLD = 10;\n\t  static SWIPE_MAX_TIME_MS = 500;\n\t  // Game options\n", "  static EXIT_TYPE: \"stairs\" | \"door\" = \"door\";\n\t  static DIMENSION = 5;\n\t  // Debug stuff\n\t  static DEBUG_SHOW_FRAMERATE = true;\n\t  // Helpers\n\t  static instance: Game;\n\t  resources: any;\n\t  spritesheet: PIXI.Spritesheet;\n\t  app: PIXI.Application;\n\t  stage: PIXI.Container;\n", "  fpsLabel: PIXI.BitmapText;\n\t  backgroundSprite: PIXI.Sprite;\n\t  innerBackgroundSprite: PIXI.Sprite;\n\t  // Full size of app\n\t  width: number = window.innerWidth;\n\t  height: number = window.innerHeight;\n\t  // Size of stage (on mobile, may include inset areas)\n\t  stageWidth: number = window.innerWidth;\n\t  stageHeight: number = window.innerHeight;\n\t  scale: number = 1;\n", "  currentScreen: Screen;\n\t  startTouch: { x: number; y: number };\n\t  startTouchTime: number;\n\t  touchPosition: { x: number; y: number } = {x: 0, y: 0};\n\t  previousHoldPosition: { x: number; y: number } = {x: 0, y: 0};\n\t  isHoldRepeating: boolean = false;\n\t  playerHash: string;\n\t  playerName: string;\n\t  muted: boolean;\n\t  stretchDisplay: boolean;\n", "  fpsAverageShort: number[] = [];\n\t  fpsAverageLong: number[] = [];\n\t  constructor(app: PIXI.Application) {\n\t    this.app = app;\n\t    this.muted = false;\n\t    this.stretchDisplay = !Game.INTEGER_SCALING;\n\t    this.stage = new PIXI.Container();\n\t    this.app.stage.addChild(this.stage);\n\t    Save.initialise();\n\t    this.resize();\n", "    this.init();\n\t  }\n\t  setStretchDisplay(s: boolean) {\n\t    this.stretchDisplay = s;\n\t    this.resize();\n\t  }\n\t  static tex(name: string): PIXI.Texture {\n\t    return Game.instance.spritesheet.textures[name];\n\t  }\n\t  init() {\n", "    sound.init();\n\t    Game.instance = this;\n\t    PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.LINEAR;\n\t    PIXI.settings.ROUND_PIXELS = false;\n\t    PIXI.Loader.shared\n\t      .add(\"spritesheet\", \"packed.json\")\n\t      .add(\"Kaph\", \"font/kaph.fnt\")\n\t      .add(\"sound-attack\", \"sound/attack.wav\")\n\t      .add(\"sound-bump\", \"sound/bump.wav\")\n\t      .add(\"sound-step1\", \"sound/step1.wav\")\n", "      .add(\"sound-step2\", \"sound/step2.wav\")\n\t      .add(\"sound-step3\", \"sound/step3.wav\")\n\t      .add(\"sound-step4\", \"sound/step4.wav\")\n\t      .use((resource, next) => {\n\t        // Load sounds into sound system\n\t        if (resource) {\n\t          if ([\"wav\", \"ogg\", \"mp3\", \"mpeg\"].includes(resource.extension)) {\n\t            sound.add(resource.name, Sound.from(resource.data));\n\t          }\n\t        }\n", "        next();\n\t      })\n\t      .load((_, resources) => {\n\t        this.resources = resources;\n\t        this.spritesheet = this.resources[\"spritesheet\"].spritesheet;\n\t        this.postInit();\n\t      });\n\t  }\n\t  gotoGameScreen() {\n\t    const gameScreen = new GameScreen();\n", "    if (!Save.loadGameState(gameScreen)) {\n\t      gameScreen.nextLevel();\n\t    }\n\t    this.setScreen(gameScreen);\n\t  }\n\t  gotoMenuScreen() {\n\t    this.setScreen(new MenuScreen());\n\t  }\n\t  setScreen(screen: Screen) {\n\t    if (this.currentScreen != null) {\n", "      // Remove it!\n\t      Actions.fadeOutAndRemove(this.currentScreen, 0.2).play();\n\t    }\n\t    // Add new one\n\t    screen.alpha = 0;\n\t    Actions.fadeIn(screen, 0.2).play();\n\t    this.currentScreen = screen;\n\t    this.stage.addChild(screen);\n\t    this.notifyScreensOfSize();\n\t  }\n", "  postInit() {\n\t    // FPS label\n\t    this.fpsLabel = new PIXI.BitmapText(\n\t      \"0\",\n\t      Font.makeFontOptions(\"medium\", \"left\")\n\t    );\n\t    this.fpsLabel.anchor.set(0);\n\t    this.fpsLabel.position.set(10, 10);\n\t    this.fpsLabel.tint = 0xffffff;\n\t    if (Game.DEBUG_SHOW_FRAMERATE) {\n", "      this.app.stage.addChild(this.fpsLabel);\n\t    }\n\t    // Add background\n\t    this.backgroundSprite = PIXI.Sprite.from(PIXI.Texture.WHITE);\n\t    this.backgroundSprite.tint = 0xffffff;\n\t    this.backgroundSprite.width = this.width;\n\t    this.backgroundSprite.height = this.height;\n\t    this.app.stage.addChildAt(this.backgroundSprite, 0);\n\t    // Inner background\n\t    this.innerBackgroundSprite = PIXI.Sprite.from(PIXI.Texture.WHITE);\n", "    this.innerBackgroundSprite.tint = Game.BACKGROUND_COLOUR;\n\t    this.innerBackgroundSprite.width = Game.TARGET_WIDTH;\n\t    this.innerBackgroundSprite.height = Game.TARGET_HEIGHT;\n\t    this.stage.addChild(this.innerBackgroundSprite);\n\t    if (Save.hasGameState()) {\n\t      this.gotoGameScreen();\n\t    } else {\n\t      this.gotoMenuScreen();\n\t    }\n\t    this.resize();\n", "    this.notifyScreensOfSize();\n\t    // Register swipe listeners\n\t    // EventEmitter types issue - see https://github.com/pixijs/pixijs/issues/7429\n\t    const stage = this.backgroundSprite as any;\n\t    stage.interactive = true;\n\t    stage.on(\"pointerdown\", (e: any) => {\n\t      this.isHoldRepeating = false;\n\t      this.startTouch = { x: e.data.global.x, y: e.data.global.y };\n\t      this.startTouchTime = Date.now();\n\t    });\n", "    stage.on(\"pointermove\", (e: any) => {\n\t      if (!this.startTouch) return;\n\t      this.touchPosition.x = e.data.global.x;\n\t      this.touchPosition.y = e.data.global.y;\n\t    });\n\t    stage.on(\"pointerup\", (e: any) => {\n\t      if (!this.startTouch) return;\n\t      if (this.isHoldRepeating) {\n\t        this.startTouch = null;\n\t        return;\n", "      }\n\t      const deltaTime = Date.now() - this.startTouchTime;\n\t      if (deltaTime > Game.SWIPE_MAX_TIME_MS) return;\n\t      const deltaX = e.data.global.x - this.startTouch.x;\n\t      const deltaY = e.data.global.y - this.startTouch.y;\n\t      this.performSwipe(deltaX, deltaY);\n\t      this.startTouch = null;\n\t    });\n\t    this.app.ticker.add((delta: number) => this.tick(delta));\n\t  }\n", "  playSound(name: string | string[]) {\n\t    if (this.muted) return;\n\t    const theName = Array.isArray(name) ? _.sample(name) : name;\n\t    const resource = this.resources[\"sound-\" + theName];\n\t    if (resource?.sound) {\n\t      resource.sound.play();\n\t    }\n\t  }\n\t  performSwipe(deltaX: number, deltaY: number) {\n\t    const absDeltaX = Math.abs(deltaX);\n", "    const absDeltaY = Math.abs(deltaY);\n\t    const absMin = Math.min(absDeltaX, absDeltaY);\n\t    const absMax = Math.max(absDeltaX, absDeltaY);\n\t    // The other axis must be smaller than this to avoid a diagonal swipe\n\t    const confusionThreshold = absMax / 2;\n\t    if (absMin < confusionThreshold) {\n\t      if (absMax > Game.SWIPE_TRIGGER_THRESHOLD) {\n\t        if (absMax == absDeltaX) {\n\t          // Right or left\n\t          this.keydown(deltaX > 0 ? \"KeyD\" : \"KeyA\");\n", "        } else {\n\t          // Up or down\n\t          this.keydown(deltaY > 0 ? \"KeyS\" : \"KeyW\");\n\t        }\n\t      }\n\t    }\n\t  }\n\t  tick(delta: number) {\n\t    // delta is in frames\n\t    let elapsedSeconds = delta / 60;\n", "    Actions.tick(elapsedSeconds);\n\t    // If pointer is held down, trigger movements.\n\t    if (this.startTouch) {\n\t      const elapsed = Date.now() - this.startTouchTime;\n\t      if (this.isHoldRepeating) {\n\t        if (elapsed > Game.HOLD_REPEAT_TIME_MS) {\n\t          const deltaX = this.touchPosition.x - this.startTouch.x;\n\t          const deltaY = this.touchPosition.y - this.startTouch.y;\n\t          this.performSwipe(deltaX, deltaY);\n\t          this.startTouchTime = Date.now();\n", "        }\n\t      } else if (elapsed > Game.HOLD_INITIAL_TIME_MS) {\n\t        // Held down for some time Trigger a swipe!\n\t        const deltaX = this.touchPosition.x - this.startTouch.x;\n\t        const deltaY = this.touchPosition.y - this.startTouch.y;\n\t        this.performSwipe(deltaX, deltaY);\n\t        // From now on, when we pass HOLD_REPEAT_TIME_MS, we perform another swipe\n\t        this.isHoldRepeating = true;\n\t        this.startTouchTime = Date.now();\n\t      }\n", "    }\n\t    this.fpsAverageShort.push(this.app.ticker.FPS);\n\t    this.fpsAverageLong.push(this.app.ticker.FPS);\n\t    // Keep most recent only\n\t    if (this.fpsAverageShort.length > 100) {\n\t      this.fpsAverageShort.shift();\n\t    }\n\t    if (this.fpsAverageLong.length > 1000) {\n\t      this.fpsAverageLong.shift();\n\t    }\n", "    const avgShort =\n\t      _.reduce(this.fpsAverageShort, (a, b) => a + b, 0) /\n\t      (this.fpsAverageShort.length === 0 ? 1 : this.fpsAverageShort.length);\n\t    const avgLong =\n\t      _.reduce(this.fpsAverageLong, (a, b) => a + b, 0) /\n\t      (this.fpsAverageLong.length === 0 ? 1 : this.fpsAverageLong.length);\n\t    this.fpsLabel.text =\n\t      \"\" +\n\t      Math.round(this.app.ticker.FPS) +\n\t      \"\\n\" +\n", "      Math.round(avgShort) +\n\t      \"\\n\" +\n\t      Math.round(avgLong) +\n\t      \"\\n\";\n\t  }\n\t  notifyScreensOfSize() {\n\t    // Let screens now\n\t    for (const s of this.stage.children) {\n\t      if (s instanceof Screen) {\n\t        if (Game.MAINTAIN_RATIO) {\n", "          s.resize(Game.TARGET_WIDTH, Game.TARGET_HEIGHT);\n\t        } else {\n\t          s.resize(this.width / this.scale, this.height / this.scale);\n\t        }\n\t      }\n\t    }\n\t  }\n\t  resize() {\n\t    const rootStyle = getComputedStyle(document.documentElement);\n\t    const resizeInfo = {\n", "      width: window.innerWidth,\n\t      height: window.innerHeight,\n\t      safeInsets: {\n\t        left: parseInt(rootStyle.getPropertyValue('--safe-area-left')) || 0,\n\t        right: parseInt(rootStyle.getPropertyValue('--safe-area-right')) || 0,\n\t        top: parseInt(rootStyle.getPropertyValue('--safe-area-top')) || 0,\n\t        bottom: parseInt(rootStyle.getPropertyValue('--safe-area-bottom')) || 0\n\t      }\n\t    };\n\t    //this part resizes the canvas but keeps ratio the same\n", "    this.app.renderer.view.style.width = resizeInfo.width + \"px\";\n\t    this.app.renderer.view.style.height = resizeInfo.height + \"px\";\n\t    this.width = resizeInfo.width;\n\t    this.height = resizeInfo.height;\n\t    if (this.backgroundSprite) {\n\t      this.backgroundSprite.width = resizeInfo.width;\n\t      this.backgroundSprite.height = resizeInfo.height;\n\t      this.backgroundSprite.alpha = Game.MAINTAIN_RATIO ? 1 : 0;\n\t    }\n\t    this.app.renderer.resize(resizeInfo.width, resizeInfo.height);\n", "    // Ensure stage can fit inside the view!\n\t    // Scale it if it's not snug\n\t    // Stage side sits inside the safe insets\n\t    this.stageWidth = resizeInfo.width - resizeInfo.safeInsets.left - resizeInfo.safeInsets.right;\n\t    this.stageHeight = resizeInfo.height - resizeInfo.safeInsets.top - resizeInfo.safeInsets.bottom;\n\t    const targetScaleX = resizeInfo.width / Game.TARGET_WIDTH;\n\t    const targetScaleY = resizeInfo.height / Game.TARGET_HEIGHT;\n\t    const smoothScaling = Math.min(targetScaleX, targetScaleY);\n\t    // Pick integer scale which best fits\n\t    this.scale = !this.stretchDisplay\n", "      ? Math.max(1, Math.floor(smoothScaling))\n\t      : smoothScaling;\n\t    this.stage.scale.set(this.scale, this.scale);\n\t    if (this.innerBackgroundSprite) {\n\t      if (Game.MAINTAIN_RATIO) {\n\t        this.innerBackgroundSprite.width = Game.TARGET_WIDTH * this.scale;\n\t        this.innerBackgroundSprite.height = Game.TARGET_HEIGHT * this.scale;\n\t      } else {\n\t        this.innerBackgroundSprite.width = resizeInfo.width;\n\t        this.innerBackgroundSprite.height = resizeInfo.height;\n", "      }\n\t    }\n\t    // Centre stage\n\t    if (Game.MAINTAIN_RATIO) {\n\t      this.stage.position.set(\n\t        resizeInfo.safeInsets.left + (this.stageWidth - Game.TARGET_WIDTH * this.scale) / 2,\n\t        resizeInfo.safeInsets.top + (this.stageHeight - Game.TARGET_HEIGHT * this.scale) / 2\n\t      );\n\t      if (this.innerBackgroundSprite) {\n\t        this.innerBackgroundSprite.position.set(this.stage.position.x, this.stage.position.y);\n", "      }\n\t    } else {\n\t      this.stage.position.set(resizeInfo.safeInsets.left, resizeInfo.safeInsets.top);\n\t    }\n\t    this.notifyScreensOfSize();\n\t  }\n\t  keydown(code: string) {\n\t    if (this.currentScreen) this.currentScreen.keydown(code);\n\t  }\n\t}\n"]}
{"filename": "src/utils/Font.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\n\ttype FontSize = \"small\" | \"medium\" | \"large\";\n\texport default class Font {\n\t  static fonts = {\n\t    Kaph: {\n\t      baseSize: 24,\n\t      license: \"https://opensource.org/licenses/OFL-1.1\",\n\t    },\n\t  };\n\t  static makeFontOptions(\n", "    size: FontSize,\n\t    align: PIXI.TextStyleAlign = \"center\",\n\t    face: \"Kaph\" = \"Kaph\"\n\t  ) {\n\t    const font = this.fonts[face];\n\t    return {\n\t      fontName: face,\n\t      fontSize: this.multiplier(size) * font.baseSize,\n\t      align,\n\t    };\n", "  }\n\t  static multiplier(size: FontSize): number {\n\t    if (size === \"small\") return 0.5;\n\t    if (size === \"medium\") return 1;\n\t    if (size === \"large\") return 1.5;\n\t    else return 1;\n\t  }\n\t}\n"]}
{"filename": "src/utils/Coords.ts", "chunked_list": ["export default class Coords {\n\t  col: number;\n\t  row: number;\n\t  constructor(col: number, row: number) {\n\t    this.col = col;\n\t    this.row = row;\n\t  }\n\t  add(dx: number, dy: number) {\n\t    this.col += dx;\n\t    this.row += dy;\n", "    return this;\n\t  }\n\t  set(col: number | Coords, row: number = null) {\n\t    if (typeof col == \"number\") {\n\t      this.col = col;\n\t      this.row = row;\n\t    } else {\n\t      this.col = col.col;\n\t      this.row = col.row;\n\t    }\n", "    return this;\n\t  }\n\t  clone(): Coords {\n\t    return new Coords(this.col, this.row);\n\t  }\n\t  equals(col: number | Coords, row: number = null) {\n\t    let c = 0;\n\t    let r = 0;\n\t    if (typeof col == \"number\") {\n\t      c = col;\n", "      r = row;\n\t    } else {\n\t      c = col.col;\n\t      r = col.row;\n\t    }\n\t    return this.col == c && this.row == r;\n\t  }\n\t}\n"]}
{"filename": "src/utils/index.ts", "chunked_list": ["import Coords from \"./Coords\";\n\timport Font from \"./Font\";\n\texport { Coords, Font };\n"]}
{"filename": "src/save/Save.ts", "chunked_list": ["import Engine from \"./engine/Engine\";\n\timport LocalStorageEngine from \"./engine/LocalStorageEngine\";\n\timport MemoryEngine from \"./engine/MemoryEngine\";\n\timport GameScreen from \"../screens/game/GameScreen\";\n\timport DungeonGrid from \"../screens/game/grid/DungeonGrid\";\n\timport Wall from \"../screens/game/grid/Wall\";\n\timport { PlayerCharacter, EnemyCharacter, Character } from \"../screens/game/character\";\n\timport type { CharacterType } from \"../screens/game/character/Character\";\n\timport { Coords } from \"utils\";\n\texport default class Save {\n", "  static engine: Engine;\n\t  static initialise() {\n\t    if (LocalStorageEngine.isSupported()) {\n\t      this.engine = new LocalStorageEngine();\n\t    } else {\n\t      this.engine = new MemoryEngine();\n\t    }\n\t  }\n\t  // Coords\n\t  private static serialiseCoords(coords: Coords) {\n", "    if (!coords) return null;\n\t    return [coords.col, coords.row];\n\t  }\n\t  private static deserialiseCoords(coords: any): Coords {\n\t    if (!coords) return null;\n\t    return new Coords(coords[0], coords[1]);\n\t  }\n\t  // Walls\n\t  private static serialiseWalls(walls: Wall[]) {\n\t    return walls.map((w) => {\n", "      return {\n\t        from: this.serialiseCoords(w.from),\n\t        to: this.serialiseCoords(w.to),\n\t      };\n\t    });\n\t  }\n\t  private static deserialiseWalls(walls: any): Wall[] {\n\t    return walls.map(\n\t      (w: any) =>\n\t        new Wall(this.deserialiseCoords(w.from), this.deserialiseCoords(w.to))\n", "    );\n\t  }\n\t  // Characters\n\t  private static serialiseCharacters(characters: Character[]) {\n\t    return characters.map((c) => {\n\t      return {\n\t        type: c.type,\n\t        coords: this.serialiseCoords(c.coords),\n\t        hp: c.hp,\n\t      };\n", "    });\n\t  }\n\t  private static deserialiseCharacters(characters: any): Character[] {\n\t    return characters.map(\n\t      (c: any) => this.createCharacter(c.type, c.hp, this.deserialiseCoords(c.coords))\n\t    );\n\t  }\n\t  private static createCharacter(type: CharacterType, hp: number, coords: Coords) {\n\t    let c;\n\t    if (type === \"player\") {\n", "      c = new PlayerCharacter();\n\t    } else {\n\t      c = new EnemyCharacter(type);\n\t    }\n\t    c.coords = coords;\n\t    c.hp = hp;\n\t    return c;\n\t  }\n\t  // Dungeon grid\n\t  private static serialiseDungeonGrid(dungeonGrid: DungeonGrid) {\n", "    return {\n\t      characters: this.serialiseCharacters(dungeonGrid.characters),\n\t      walls: this.serialiseWalls(dungeonGrid.walls),\n\t      edgeWalls: this.serialiseWalls(dungeonGrid.edgeWalls),\n\t      dimension: dungeonGrid.dimension,\n\t      exitCoords: this.serialiseCoords(dungeonGrid.exitCoords),\n\t      exitDir: this.serialiseCoords(dungeonGrid.exitDir),\n\t    };\n\t  }\n\t  private static deserialiseDungeonGrid(gameScreen: GameScreen, data: any) {\n", "    const dungeonGrid = new DungeonGrid(gameScreen, data.dimension);\n\t    const chars = this.deserialiseCharacters(data.characters);\n\t    for (const c of chars) {\n\t        dungeonGrid.addCharacter(c);\n\t    }\n\t    dungeonGrid.walls = this.deserialiseWalls(data.walls);\n\t    dungeonGrid.edgeWalls = this.deserialiseWalls(data.edgeWalls);\n\t    dungeonGrid.exitCoords = this.deserialiseCoords(data.exitCoords);\n\t    dungeonGrid.exitDir = this.deserialiseCoords(data.exitDir);\n\t    dungeonGrid.drawWalls(dungeonGrid.walls);\n", "    dungeonGrid.updateExitCoords();\n\t    return dungeonGrid;\n\t  }\n\t  // Game state\n\t  private static serialiseGameState(gameScreen: GameScreen) {\n\t    return {\n\t      level: gameScreen.level,\n\t      state: gameScreen.state,\n\t      score: gameScreen.score,\n\t      dungeonGrid: this.serialiseDungeonGrid(gameScreen.dungeonGrid),\n", "    };\n\t  }\n\t  private static deserialiseGameState(gameScreen: GameScreen, data: any) {\n\t    gameScreen.level = data.level;\n\t    gameScreen.state = data.state;\n\t    gameScreen.score = data.score;\n\t    // Remove the old dungeon grid:\n\t    if (gameScreen.dungeonGrid) {\n\t        gameScreen.gameContainer.removeChild(gameScreen.dungeonGrid);\n\t    }\n", "    gameScreen.dungeonGrid = this.deserialiseDungeonGrid(gameScreen, data.dungeonGrid);\n\t    gameScreen.gameContainer.addChild(gameScreen.dungeonGrid);\n\t    const pc = gameScreen.dungeonGrid.characters.find(c => c.isPlayer);\n\t    gameScreen.playerCharacter = pc;\n\t    gameScreen.incScore(0);\n\t  }\n\t  static hasGameState() {\n\t    return !!this.engine.load(\"currentGameState\");\n\t  }\n\t  static saveGameState(gameScreen: GameScreen) {\n", "    // Save game state...\n\t    const data = this.serialiseGameState(gameScreen);\n\t    this.engine.save(\"currentGameState\", data);\n\t  }\n\t  static loadGameState(gameScreen: GameScreen) {\n\t    // Save game state...\n\t    const data = this.engine.load(\"currentGameState\");\n\t    if (data) {\n\t        // Load data into gameScreen...\n\t        this.deserialiseGameState(gameScreen, data);\n", "        return true;\n\t    }\n\t    return false;\n\t  }\n\t  static clearGameState() {\n\t    this.engine.remove(\"currentGameState\");\n\t  }\n\t}\n"]}
{"filename": "src/save/engine/LocalStorageEngine.ts", "chunked_list": ["import Engine from \"./Engine\";\n\texport default class LocalStorageEngine implements Engine {\n\t  storage: Storage = null;\n\t  constructor() {\n\t    if (LocalStorageEngine.isSupported()) {\n\t      this.storage = localStorage;\n\t    } else {\n\t      this.storage = null;\n\t    }\n\t  }\n", "  static isSupported() {\n\t    try {\n\t      localStorage.setItem(\"__test\", \"1\");\n\t      localStorage.removeItem(\"__test\");\n\t      return true;\n\t    } catch (e) {\n\t      return false;\n\t    }\n\t  }\n\t  save(key: string, value: any): void {\n", "    if (!this.storage) return;\n\t    this.storage.setItem(key, JSON.stringify(value));\n\t  }\n\t  load(key: string): any {\n\t    if (!this.storage) null;\n\t    const value = this.storage.getItem(key);\n\t    if (!value) return null;\n\t    try {\n\t      return JSON.parse(value);\n\t    } catch (e) {\n", "      // Invalid JSON...\n\t      this.storage.removeItem(key);\n\t      return null;\n\t    }\n\t  }\n\t  remove(key: string): void {\n\t    if (!this.storage) return;\n\t    this.storage.removeItem(key);\n\t  }\n\t}\n"]}
{"filename": "src/save/engine/MemoryEngine.ts", "chunked_list": ["import Engine from \"./Engine\";\n\texport default class MemoryEngine implements Engine {\n\t  storage = new Map();\n\t  save(key: string, value: any): void {\n\t    this.storage.set(key, value);\n\t  }\n\t  load(key: string): any {\n\t    if (!this.storage.has(key)) return null;\n\t    return this.storage.get(key);\n\t  }\n", "  remove(key: string): void {\n\t    if (!this.storage) return;\n\t    this.storage.delete(key);\n\t  }\n\t}\n"]}
{"filename": "src/save/engine/Engine.ts", "chunked_list": ["export default interface Engine {\n\t  save(key: string, value: any): void;\n\t  load(key: string): any;\n\t  remove(key: string): void;\n\t}\n"]}
{"filename": "src/ui/Button.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\n\timport { Font } from \"utils\";\n\texport default class Button extends PIXI.Container {\n\t  label: PIXI.BitmapText;\n\t  onclick: () => void;\n\t  constructor(text: string, onclick: () => void) {\n\t    super();\n\t    this.onclick = onclick;\n\t    // Make a label!\n\t    const theLabel = new PIXI.BitmapText(text, Font.makeFontOptions(\"small\"));\n", "    theLabel.tint = 0;\n\t    theLabel.anchor.set(0.5);\n\t    theLabel.position.x = 0;\n\t    theLabel.position.y = 0;\n\t    this.label = theLabel;\n\t    // Background\n\t    const holderBackground = PIXI.Sprite.from(PIXI.Texture.WHITE);\n\t    holderBackground.width = 200;\n\t    holderBackground.height = 25;\n\t    holderBackground.position.set(\n", "      -holderBackground.width / 2,\n\t      -holderBackground.height / 2\n\t    );\n\t    this.addChild(holderBackground);\n\t    this.addChild(theLabel);\n\t    const ee = this as any;\n\t    ee.interactive = true;\n\t    ee.on(\"pointertap\", () => {\n\t      this.onclick();\n\t    });\n", "  }\n\t}\n"]}
{"filename": "src/ui/index.ts", "chunked_list": ["import Button from \"./Button\";\n\texport { Button };\n"]}
{"filename": "src/screens/index.ts", "chunked_list": ["import Screen from \"./Screen\";\n\timport MenuScreen from \"./menu/MenuScreen\";\n\timport GameScreen from \"./game/GameScreen\";\n\texport { Screen, GameScreen, MenuScreen };\n"]}
{"filename": "src/screens/Screen.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\n\texport default class Screen extends PIXI.Container {\n\t  keydown(code: string) {}\n\t  resize(width: number, height: number) {}\n\t}\n"]}
{"filename": "src/screens/menu/MenuScreen.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\n\timport Game from \"Game\";\n\timport { Button } from \"ui\";\n\timport { Font } from \"utils\";\n\timport Screen from \"../Screen\";\n\texport default class MenuScreen extends Screen {\n\t  static PADDING = 20;\n\t  startButton: Button;\n\t  logo: PIXI.BitmapText;\n\t  w: number;\n", "  h: number;\n\t  constructor() {\n\t    super();\n\t    // Logo at top\n\t    this.logo = new PIXI.BitmapText(\"TEMPLATE\", Font.makeFontOptions(\"large\"));\n\t    this.logo.anchor.set(0.5, 0);\n\t    this.logo.tint = 0xffffff;\n\t    this.addChild(this.logo);\n\t    // Button to continue or start\n\t    this.startButton = new Button(\"Start\", () => {\n", "      // Start new game!\n\t      Game.instance.gotoGameScreen();\n\t    });\n\t    this.addChild(this.startButton);\n\t  }\n\t  resize(width: number, height: number) {\n\t    this.w = width;\n\t    this.h = height;\n\t    this.logo.position.set(width / 2, MenuScreen.PADDING);\n\t    this.startButton.position.set(\n", "      width / 2,\n\t      height - this.startButton.height / 2 - MenuScreen.PADDING\n\t    );\n\t  }\n\t  keydown(code: string) {\n\t    if (code == \"Enter\") {\n\t      this.startButton.onclick();\n\t      return;\n\t    }\n\t  }\n", "}\n"]}
{"filename": "src/screens/game/GameOverModal.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\n\timport Game from \"Game\";\n\timport { Font } from \"utils\";\n\timport * as _ from \"underscore\";\n\timport GameScreen from \"./GameScreen\";\n\texport default class GameOverModal extends PIXI.Container {\n\t  game: GameScreen;\n\t  scoresTable: PIXI.Container;\n\t  constructor(game: GameScreen) {\n\t    super();\n", "    this.game = game;\n\t    // Leaderboard\n\t    const titleLabel = new PIXI.BitmapText(\n\t      \"Game Over\",\n\t      Font.makeFontOptions(\"small\")\n\t    );\n\t    titleLabel.anchor.set(0.5, 0.5);\n\t    titleLabel.position.x = Game.TARGET_WIDTH / 2;\n\t    titleLabel.position.y = 20;\n\t    this.addChild(titleLabel);\n", "    {\n\t      // Your score\n\t      const lbl = new PIXI.BitmapText(\n\t        \"Your score - \" + game.score,\n\t        Font.makeFontOptions(\"small\")\n\t      );\n\t      lbl.anchor.set(0.5, 0.5);\n\t      lbl.position.x = Game.TARGET_WIDTH / 2;\n\t      lbl.position.y = 55;\n\t      this.addChild(lbl);\n", "    }\n\t    // Play Again buttons\n\t    {\n\t      const button = new PIXI.BitmapText(\n\t        \"[ Return to Menu ]\",\n\t        Font.makeFontOptions(\"small\")\n\t      );\n\t      button.anchor.set(0.5, 0.5);\n\t      button.position.x = Game.TARGET_WIDTH / 2;\n\t      button.position.y = 115;\n", "      this.addChild(button);\n\t      // Clicker\n\t      const clicker = PIXI.Sprite.from(PIXI.Texture.WHITE);\n\t      clicker.tint = 0xff0000;\n\t      clicker.alpha = 0;\n\t      clicker.anchor.set(0.5, 0.5);\n\t      clicker.width = button.width * 1.5;\n\t      clicker.height = button.height * 2;\n\t      clicker.position.set(button.position.x, button.position.y);\n\t      this.addChild(clicker);\n", "      const ee = clicker as any;\n\t      ee.interactive = true;\n\t      ee.on(\"pointertap\", () => {\n\t        Game.instance.gotoMenuScreen();\n\t      });\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/screens/game/GameScreen.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\n\timport { Actions } from \"pixi-actions\";\n\timport Game from \"Game\";\n\timport Screen from \"../Screen\";\n\timport { Font } from \"utils\";\n\timport Save from \"../../save/Save\";\n\timport DungeonGrid from \"./grid/DungeonGrid\";\n\timport { PlayerCharacter, EnemyCharacter } from \"./character\";\n\timport GameOverModal from \"./GameOverModal\";\n\timport * as _ from \"underscore\";\n", "type GameState = \"play\" | \"gameover\";\n\texport default class GameScreen extends Screen {\n\t  playerCharacter: PlayerCharacter;\n\t  dungeonGrid: DungeonGrid;\n\t  darkOverlay: PIXI.Container;\n\t  gameContainer: PIXI.Container;\n\t  gameOverModal: GameOverModal;\n\t  readyToMove: boolean;\n\t  queuedMove: { dx: number; dy: number };\n\t  level: number;\n", "  state: GameState = \"play\";\n\t  modals: PIXI.Container[] = [];\n\t  score: number;\n\t  scoreLabel: PIXI.BitmapText;\n\t  prevWidth: number = 0;\n\t  prevHeight: number = 0;\n\t  constructor() {\n\t    super();\n\t    // Setup\n\t    this.readyToMove = true;\n", "    this.queuedMove = null;\n\t    this.level = 0;\n\t    this.score = 0;\n\t    this.gameContainer = new PIXI.Container();\n\t    this.addChild(this.gameContainer);\n\t    // Score\n\t    this.scoreLabel = new PIXI.BitmapText(\"0\", Font.makeFontOptions(\"small\"));\n\t    this.scoreLabel.anchor.set(0.5);\n\t    this.scoreLabel.tint = 0xffffff;\n\t    this.gameContainer.addChild(this.scoreLabel);\n", "    // Add a character\n\t    this.playerCharacter = new PlayerCharacter();\n\t    this.playerCharacter.coords.set(2, 4);\n\t    // Dark overlay\n\t    this.darkOverlay = new PIXI.Container();\n\t    this.darkOverlay.visible = false;\n\t    {\n\t      const rect = PIXI.Sprite.from(PIXI.Texture.WHITE);\n\t      rect.tint = 0;\n\t      rect.alpha = 0.8;\n", "      this.darkOverlay.addChild(rect);\n\t    }\n\t    this.addChild(this.darkOverlay);\n\t  }\n\t  incScore(amt: number) {\n\t    this.score += amt;\n\t    this.scoreLabel.text = \"\" + this.score;\n\t  }\n\t  showDarkOverlay(delay: number = 0) {\n\t    this.darkOverlay.visible = true;\n", "    this.darkOverlay.alpha = 0;\n\t    Actions.sequence(\n\t      Actions.delay(delay),\n\t      Actions.fadeIn(this.darkOverlay, 0.2)\n\t    ).play();\n\t  }\n\t  hideDarkOverlay(delay: number = 0) {\n\t    Actions.sequence(\n\t      Actions.delay(delay),\n\t      Actions.runFunc(() => {\n", "        this.darkOverlay.visible = false;\n\t        this.darkOverlay.alpha = 0;\n\t      })\n\t    ).play();\n\t  }\n\t  gameOver() {\n\t    this.state = \"gameover\";\n\t    Save.clearGameState();\n\t    this.showDarkOverlay(0.5);\n\t    this.gameOverModal = new GameOverModal(this);\n", "    this.gameOverModal.alpha = 0;\n\t    Actions.sequence(\n\t      Actions.delay(2),\n\t      Actions.fadeIn(this.gameOverModal, 0.2)\n\t    ).play();\n\t    this.addChild(this.gameOverModal);\n\t    this.resizeAgain();\n\t  }\n\t  nextLevel() {\n\t    this.incScore(1);\n", "    this.level++;\n\t    this.readyToMove = true;\n\t    const nextGrid = new DungeonGrid(this, Game.DIMENSION);\n\t    if (this.dungeonGrid) {\n\t      // Slide the new one in!\n\t      if (Game.EXIT_TYPE == \"door\" && this.dungeonGrid.exitDir) {\n\t        const dx = this.dungeonGrid.exitDir.col * this.dungeonGrid.edgeSize;\n\t        const dy = this.dungeonGrid.exitDir.row * this.dungeonGrid.edgeSize;\n\t        nextGrid.position.set(\n\t          this.dungeonGrid.position.x + dx,\n", "          this.dungeonGrid.position.y + dy\n\t        );\n\t        nextGrid.alpha = 0;\n\t        Actions.parallel(\n\t          Actions.fadeIn(nextGrid, 0.2),\n\t          Actions.moveTo(\n\t            nextGrid,\n\t            this.dungeonGrid.position.x,\n\t            this.dungeonGrid.position.y,\n\t            0.5\n", "          )\n\t        ).play();\n\t        Actions.sequence(\n\t          Actions.parallel(\n\t            Actions.fadeOut(this.dungeonGrid, 0.2),\n\t            Actions.moveTo(\n\t              this.dungeonGrid,\n\t              this.dungeonGrid.position.x - dx,\n\t              this.dungeonGrid.position.y - dy,\n\t              0.5\n", "            )\n\t          ),\n\t          Actions.remove(this.dungeonGrid)\n\t        ).play();\n\t        // Move the player to opposite side of the dungeon\n\t        if (this.dungeonGrid.exitDir.col != 0) {\n\t          this.playerCharacter.coords.col = this.dungeonGrid.dimension - this.playerCharacter.coords.col - 1;\n\t        } else {\n\t          this.playerCharacter.coords.row = this.dungeonGrid.dimension - this.playerCharacter.coords.row - 1;\n\t        }\n", "        // Ensure that any pending animations don't intefere with positioning in next level\n\t        Actions.clear(this.playerCharacter);\n\t      } else {\n\t        nextGrid.position.set(this.dungeonGrid.position.x, this.dungeonGrid.position.y);\n\t        nextGrid.alpha = 0;\n\t        Actions.fadeIn(nextGrid, 0.5).play();\n\t        Actions.fadeOutAndRemove(this.dungeonGrid, 0.5).play();\n\t      }\n\t    } else {\n\t      // If this is the first grid, we need to place it in the correct place\n", "      this.resizeAgain();\n\t      nextGrid.alpha = 0;\n\t      Actions.fadeIn(nextGrid, 0.5).play();\n\t    }\n\t    this.dungeonGrid = nextGrid;\n\t    this.dungeonGrid.addCharacter(this.playerCharacter);\n\t    this.dungeonGrid.clearEnemies();\n\t    this.dungeonGrid.generateWalls(Math.min(3 + this.level, 8));\n\t    this.dungeonGrid.setExitCell();\n\t    this.gameContainer.addChild(this.dungeonGrid);\n", "    const monsterLevel = Math.min(this.level, 20);\n\t    const numEnemies =\n\t      2 +\n\t      Math.min(5, Math.floor(monsterLevel / 5)) +\n\t      Math.min(10, Math.max(0, monsterLevel - 40));\n\t    this.spawnEnemy(numEnemies);\n\t    Save.saveGameState(this);\n\t  }\n\t  spawnEnemy(n: number) {\n\t    for (let i = 0; i < n; i++) {\n", "      const enemyCharacter = new EnemyCharacter(\"enemy1\");\n\t      // Random empty cell\n\t      const coord = this.dungeonGrid.getRandomEmptyCell();\n\t      if (!coord) return;\n\t      enemyCharacter.coords.set(coord.col, coord.row);\n\t      this.dungeonGrid.addCharacter(enemyCharacter);\n\t    }\n\t  }\n\t  pumpQueuedMove() {\n\t    if (this.queuedMove) {\n", "      this.doMove(this.queuedMove.dx, this.queuedMove.dy);\n\t      this.queuedMove = null;\n\t    }\n\t  }\n\t  doMove(dx: number, dy: number) {\n\t    if (this.state != \"play\") {\n\t      // Can't move!\n\t      return;\n\t    }\n\t    // 1. If you aren't yet ready to move, then queue the direction\n", "    if (this.readyToMove) {\n\t      // 2. Otherwise, do the move\n\t      const moveResult = this.dungeonGrid.moveCharacter(\n\t        this.playerCharacter,\n\t        dx,\n\t        dy\n\t      );\n\t      // 3. If the move was successful, then say we aren't ready to move yet\n\t      if (moveResult.wentThroughExit) {\n\t        // Load in new level\n", "        // Snazzy animation too, if I could handle it!\n\t        this.nextLevel();\n\t      } else if (moveResult.didMove) {\n\t        this.postMove(moveResult.delay);\n\t      } else {\n\t        this.readyToMove = false;\n\t        // After a delay, let the player move again\n\t        Actions.sequence(\n\t          Actions.delay(moveResult.delay),\n\t          Actions.runFunc(() => {\n", "            this.readyToMove = true;\n\t            this.pumpQueuedMove();\n\t          })\n\t        ).play();\n\t      }\n\t    } else {\n\t      this.queuedMove = { dx, dy };\n\t    }\n\t  }\n\t  postMove(delay: number) {\n", "    this.readyToMove = false;\n\t    // Any character on exit\n\t    let onExit = false;\n\t    if (Game.EXIT_TYPE == \"stairs\" && this.dungeonGrid.exitCoords) {\n\t      if (this.dungeonGrid.exitCoords.equals(this.playerCharacter.coords)) {\n\t        onExit = true;\n\t      }\n\t    }\n\t    if (onExit) {\n\t      this.nextLevel();\n", "    } else {\n\t      Actions.sequence(\n\t        Actions.delay(delay),\n\t        Actions.runFunc(() => {\n\t          if (this.state != \"gameover\") {\n\t            this.doEnemyMove();\n\t          }\n\t        })\n\t      ).play();\n\t    }\n", "    if (this.state == \"play\")\n\t      Save.saveGameState(this);\n\t  }\n\t  doEnemyMove() {\n\t    // Move enemies, after a delay!\n\t    const enemyMoveResult = this.dungeonGrid.moveEnemies();\n\t    let delay = enemyMoveResult.delay;\n\t    // After a delay, let the player move again\n\t    // Fudge this value, I like to be able to move really soon\n\t    Actions.sequence(\n", "      Actions.delay(delay),\n\t      Actions.runFunc(() => {\n\t        this.readyToMove = true;\n\t        this.pumpQueuedMove();\n\t      })\n\t    ).play();\n\t    if (this.state == \"play\")\n\t      Save.saveGameState(this);\n\t  }\n\t  resizeAgain() {\n", "    this.resize(this.prevWidth, this.prevHeight);\n\t  }\n\t  resize(width: number, height: number) {\n\t    if (!this.parent) return;\n\t    this.prevWidth = width;\n\t    this.prevHeight = height;\n\t    this.darkOverlay.width = Game.instance.width / Game.instance.scale;\n\t    this.darkOverlay.height = Game.instance.height / Game.instance.scale;\n\t    this.darkOverlay.position.set(\n\t      -this.parent.position.x / Game.instance.scale,\n", "      -this.parent.position.y / Game.instance.scale\n\t    );\n\t    // Dungeon grid position\n\t    let dungeonY = (height - this.dungeonGrid.edgeSize) / 2;\n\t    let dungeonX = (width - this.dungeonGrid.edgeSize) / 2;\n\t    // Grids\n\t    // Move it\n\t    this.dungeonGrid.position.set(dungeonX, dungeonY);\n\t    this.scoreLabel.position.set(dungeonX + this.dungeonGrid.edgeSize / 2, 16);\n\t    // Modals\n", "    const modals = [this.gameOverModal];\n\t    for (const m of modals) {\n\t      if (m) {\n\t        // Centre it!\n\t        const x = (width - Game.TARGET_WIDTH) / 2;\n\t        const y = (height - Game.TARGET_HEIGHT) / 2;\n\t        m.position.set(x, y);\n\t      }\n\t    }\n\t  }\n", "  keydown(code: string) {\n\t    let dx = 0;\n\t    let dy = 0;\n\t    if (code == \"ArrowLeft\" || code == \"KeyA\") {\n\t      dx = -1;\n\t    } else if (code == \"ArrowRight\" || code == \"KeyD\") {\n\t      dx = 1;\n\t    } else if (code == \"ArrowUp\" || code == \"KeyW\") {\n\t      dy = -1;\n\t    } else if (code == \"ArrowDown\" || code == \"KeyS\") {\n", "      dy = 1;\n\t    }\n\t    if (dx != 0 || dy != 0) {\n\t      // Attempted move\n\t      this.doMove(dx, dy);\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/screens/game/grid/Wall.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\n\timport { Coords } from \"utils\";\n\timport * as _ from \"underscore\";\n\texport default class Wall extends PIXI.Container {\n\t  static CONNECTION_PREFERRED_RATIO = 0.6;\n\t  static PREDETERMINED_LAYOUTS: any = { shrine: [] };\n\t  from: Coords;\n\t  to: Coords;\n\t  sprite: PIXI.Sprite;\n\t  constructor(from: Coords, to: Coords) {\n", "    super();\n\t    this.from = from;\n\t    this.to = to;\n\t    this.sprite = PIXI.Sprite.from(PIXI.Texture.WHITE);\n\t    this.sprite.tint = 0x4d3206;\n\t    this.addChild(this.sprite);\n\t  }\n\t  setCellSize(cellSize: number) {\n\t    const withSize = cellSize * 1.1;\n\t    const againstSize = 5;\n", "    this.sprite.width = this.isHorizontal ? withSize : againstSize;\n\t    this.sprite.height = this.isHorizontal ? againstSize : withSize;\n\t  }\n\t  blocks(start: Coords, dx: number, dy: number) {\n\t    if (this.isHorizontal) {\n\t      if (dy == 0) return false;\n\t      if (dy < 0 && this.from.equals(start)) {\n\t        // Hitting a wall\n\t        return true;\n\t      }\n", "      if (\n\t        dy > 0 &&\n\t        this.from.col == start.col &&\n\t        this.from.row == start.row + 1\n\t      ) {\n\t        // Hitting a wall\n\t        return true;\n\t      }\n\t    }\n\t    if (!this.isHorizontal) {\n", "      if (dx == 0) return false;\n\t      if (dx < 0 && this.from.equals(start)) {\n\t        // Hitting a wall\n\t        return true;\n\t      }\n\t      if (\n\t        dx > 0 &&\n\t        this.from.col == start.col + 1 &&\n\t        this.from.row == start.row\n\t      ) {\n", "        // Hitting a wall\n\t        return true;\n\t      }\n\t    }\n\t    return false;\n\t  }\n\t  get isHorizontal(): boolean {\n\t    return this.from.row == this.to.row;\n\t  }\n\t  static floodFillAddToQueue(\n", "    Q: number[][],\n\t    n: number[],\n\t    dx: number,\n\t    dy: number,\n\t    dimension: number,\n\t    walls: Wall[],\n\t    prospective: Wall,\n\t    flood: boolean[][]\n\t  ) {\n\t    const col = n[0] + dx;\n", "    const row = n[1] + dy;\n\t    const from = new Coords(n[0], n[1]);\n\t    // If not in bounds, don't add to Q\n\t    if (col < 0 || row < 0) return;\n\t    if (col >= dimension || row >= dimension) return;\n\t    // If already flooded, don't add\n\t    if (flood[col][row]) return;\n\t    // If a wall blocks, don't add\n\t    for (const w of walls) {\n\t      if (w.blocks(from, dx, dy)) return;\n", "    }\n\t    // If the prospective blocks, don't add\n\t    if (prospective.blocks(from, dx, dy)) return;\n\t    Q.push([col, row]);\n\t  }\n\t  static floodFill(\n\t    flood: boolean[][],\n\t    walls: Wall[],\n\t    prospective: Wall,\n\t    dimension: number\n", "  ): boolean {\n\t    for (let i = 0; i < flood.length; i++) {\n\t      for (let j = 0; j < flood[i].length; j++) {\n\t        flood[i][j] = false;\n\t      }\n\t    }\n\t    const Q = [];\n\t    Q.push([0, 0]);\n\t    while (Q.length > 0) {\n\t      const n = Q.pop();\n", "      flood[n[0]][n[1]] = true;\n\t      Wall.floodFillAddToQueue(\n\t        Q,\n\t        n,\n\t        0,\n\t        1,\n\t        dimension,\n\t        walls,\n\t        prospective,\n\t        flood\n", "      );\n\t      Wall.floodFillAddToQueue(\n\t        Q,\n\t        n,\n\t        0,\n\t        -1,\n\t        dimension,\n\t        walls,\n\t        prospective,\n\t        flood\n", "      );\n\t      Wall.floodFillAddToQueue(\n\t        Q,\n\t        n,\n\t        1,\n\t        0,\n\t        dimension,\n\t        walls,\n\t        prospective,\n\t        flood\n", "      );\n\t      Wall.floodFillAddToQueue(\n\t        Q,\n\t        n,\n\t        -1,\n\t        0,\n\t        dimension,\n\t        walls,\n\t        prospective,\n\t        flood\n", "      );\n\t    }\n\t    for (let i = 0; i < flood.length; i++) {\n\t      for (let j = 0; j < flood[i].length; j++) {\n\t        if (!flood[i][j]) return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t  static edges(dimension: number) {\n", "    // Generate walls which go all around the edges\n\t    const walls: Wall[] = [];\n\t    for (let edge = 0; edge < 4; edge++) {\n\t      for (let i = 0; i < dimension; i++) {\n\t        const startCoords = new Coords(0, 0);\n\t        const endCoords = new Coords(0, 0);\n\t        if (edge == 0 || edge == 2) {\n\t          // Top/bottom\n\t          startCoords.col = i;\n\t          endCoords.col = i + 1;\n", "          startCoords.row = edge == 0 ? 0 : dimension;\n\t          endCoords.row = startCoords.row;\n\t        } else {\n\t          // Left/right\n\t          startCoords.row = i;\n\t          endCoords.row = i + 1;\n\t          startCoords.col = edge == 1 ? 0 : dimension;\n\t          endCoords.col = startCoords.col;\n\t        }\n\t        walls.push(new Wall(startCoords, endCoords));\n", "      }\n\t    }\n\t    return walls;\n\t  }\n\t  static randomLayout(numWalls: number, dimension: number): Wall[] {\n\t    const walls: Wall[] = [];\n\t    const flood: boolean[][] = [];\n\t    for (let i = 0; i < dimension; i++) {\n\t      const col: boolean[] = [];\n\t      for (let j = 0; j < dimension; j++) {\n", "        col.push(false);\n\t      }\n\t      flood.push(col);\n\t    }\n\t    // Create N wall segments. If a wall segment would create a blockage, don't add it.\n\t    let limit = 0;\n\t    while (walls.length < numWalls) {\n\t      if (limit++ > 1000) {\n\t        break;\n\t      }\n", "      let prospective: Wall = null;\n\t      if (walls.length > 0 && Math.random() < Wall.CONNECTION_PREFERRED_RATIO) {\n\t        // Try to join onto an existing wall\n\t        const prevWall = _.sample(walls);\n\t        const connectingWalls = [];\n\t        if (prevWall.isHorizontal) {\n\t          connectingWalls.push(\n\t            // 2 parallel\n\t            [prevWall.from.clone().add(-1, 0), prevWall.to.clone().add(-1, 0)],\n\t            [prevWall.from.clone().add(1, 0), prevWall.to.clone().add(1, 0)],\n", "            // 4 perpendicular\n\t            [prevWall.from.clone(), prevWall.from.clone().add(0, 1)],\n\t            [prevWall.from.clone().add(0, -1), prevWall.from.clone()],\n\t            [prevWall.to.clone(), prevWall.to.clone().add(0, 1)],\n\t            [prevWall.to.clone().add(0, -1), prevWall.to.clone()]\n\t          );\n\t        } else {\n\t          connectingWalls.push(\n\t            // 2 parallel\n\t            [prevWall.from.clone().add(0, -1), prevWall.to.clone().add(0, -1)],\n", "            [prevWall.from.clone().add(0, 1), prevWall.to.clone().add(0, 1)],\n\t            // 4 perpendicular\n\t            [prevWall.from.clone(), prevWall.from.clone().add(1, 0)],\n\t            [prevWall.from.clone().add(-1, 0), prevWall.from.clone()],\n\t            [prevWall.to.clone(), prevWall.to.clone().add(1, 0)],\n\t            [prevWall.to.clone().add(-1, 0), prevWall.to.clone()]\n\t          );\n\t        }\n\t        // Remove any which are duplicated, or out of bounds\n\t        const viableConnectingWalls: Coords[][] = [];\n", "        outer: for (const w of connectingWalls) {\n\t          // If not in bounds, don't add to Q\n\t          if (w[0].col < 0 || w[0].row < 0) continue;\n\t          if (w[0].col >= dimension || w[0].row >= dimension) continue;\n\t          if (w[1].col < 0 || w[1].row < 0) continue;\n\t          if (w[1].col >= dimension || w[1].row >= dimension) continue;\n\t          const isHorizontal = w[0].row == w[1].row;\n\t          if (isHorizontal) {\n\t            // If it's horizontal, you can't go on top or bottom\n\t            if (w[0].row == 0 || w[0].row == dimension - 1) continue;\n", "          } else {\n\t            // If it's vertical, you can't go on either edge\n\t            if (w[0].col == 0 || w[0].col == dimension - 1) continue;\n\t          }\n\t          // If another wall here, don't add\n\t          for (const w2 of walls) {\n\t            if (w2.from.equals(w[0]) && w2.to.equals(w[1])) {\n\t              continue outer;\n\t            }\n\t          }\n", "          viableConnectingWalls.push(w);\n\t        }\n\t        if (viableConnectingWalls.length > 0) {\n\t          const coords = _.sample(viableConnectingWalls);\n\t          prospective = new Wall(coords[0], coords[1]);\n\t        }\n\t      }\n\t      if (prospective == null) {\n\t        // Random wall\n\t        const horizontal = Math.random() < 0.5;\n", "        const dx = horizontal ? 1 : 0;\n\t        const dy = horizontal ? 0 : 1;\n\t        let startX = null,\n\t          startY = null;\n\t        startX = _.random(horizontal ? 0 : 1, dimension - 1);\n\t        startY = _.random(horizontal ? 1 : 0, dimension - 1);\n\t        const from = new Coords(startX, startY);\n\t        const to = from.clone().add(dx, dy);\n\t        // If there is already a wall here, skip!\n\t        let alreadyExists = false;\n", "        for (const w of walls) {\n\t          if (w.from.equals(from) && w.to.equals(to)) {\n\t            alreadyExists = true;\n\t            break;\n\t          }\n\t        }\n\t        if (alreadyExists) continue;\n\t        prospective = new Wall(from, to);\n\t      }\n\t      // If we can't flood fill, skip!\n", "      const canFloodFill = Wall.floodFill(flood, walls, prospective, dimension);\n\t      if (!canFloodFill) continue;\n\t      walls.push(prospective);\n\t    }\n\t    return walls;\n\t  }\n\t}\n"]}
{"filename": "src/screens/game/grid/Grid.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\n\timport { Action, Actions } from \"pixi-actions\";\n\timport Character from \"../character/Character\";\n\timport { Coords } from \"utils\";\n\timport Wall from \"./Wall\";\n\texport default class Grid extends PIXI.Container {\n\t  dimension: number;\n\t  edgeSize: number;\n\t  constructor(dimension: number) {\n\t    super();\n", "    this.dimension = dimension;\n\t    this.edgeSize = 28 * this.dimension;\n\t  }\n\t  get cellSize(): number {\n\t    return this.edgeSize / this.dimension;\n\t  }\n\t  inBounds(col: number | Coords, row: number = null) {\n\t    let c = 0,\n\t      r = 0;\n\t    if (typeof col == \"number\") {\n", "      c = col;\n\t      r = row;\n\t    } else {\n\t      c = col.col;\n\t      r = col.row;\n\t    }\n\t    return !(c < 0 || c >= this.dimension || r < 0 || r >= this.dimension);\n\t  }\n\t  makeMoveTo(\n\t    character: Character,\n", "    dx: number = 0,\n\t    dy: number = 0,\n\t    time: number = 0.1\n\t  ): Action {\n\t    return Actions.moveTo(\n\t      character,\n\t      this.cellSize * (character.coords.col + dx) + this.cellSize / 2,\n\t      this.cellSize * (character.coords.row + dy) + this.cellSize - 3,\n\t      time\n\t    );\n", "  }\n\t  setPositionTo(\n\t    actor: PIXI.Container,\n\t    coords: Coords,\n\t    isWall: boolean = false\n\t  ) {\n\t    if (isWall) {\n\t      if ((actor as Wall).isHorizontal) {\n\t        actor.position.set(\n\t          this.cellSize * coords.col + (this.cellSize - actor.width) / 2,\n", "          this.cellSize * coords.row + -actor.height / 2\n\t        );\n\t      } else {\n\t        actor.position.set(\n\t          this.cellSize * coords.col + -actor.width / 2,\n\t          this.cellSize * coords.row + (this.cellSize - actor.height) / 2\n\t        );\n\t      }\n\t    } else {\n\t      actor.position.set(\n", "        this.cellSize * coords.col + this.cellSize / 2,\n\t        this.cellSize * coords.row + this.cellSize - 3\n\t      );\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/screens/game/grid/DungeonGrid.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\n\timport { Actions } from \"pixi-actions\";\n\timport { Character, EnemyCharacter, PlayerCharacter } from \"../character\";\n\timport GameScreen from \"../GameScreen\";\n\timport Grid from \"./Grid\";\n\timport Wall from \"./Wall\";\n\timport { Coords } from \"utils\";\n\timport * as _ from \"underscore\";\n\timport Game from \"Game\";\n\texport default class DungeonGrid extends Grid {\n", "  characters: Character[] = [];\n\t  walls: Wall[] = [];\n\t  edgeWalls: Wall[] = [];\n\t  wallsHolder: PIXI.Container = new PIXI.Container();\n\t  charactersHolder: PIXI.Container = new PIXI.Container();\n\t  gameScreen: GameScreen;\n\t  coords: Coords[] = [];\n\t  cellSquares: PIXI.Sprite[][] = [];\n\t  cellStairs: PIXI.Sprite[][] = [];\n\t  exitCoords: Coords;\n", "  exitDir: Coords = null;\n\t  constructor(gameScreen: GameScreen, dimension: number) {\n\t    super(dimension);\n\t    this.gameScreen = gameScreen;\n\t    // Add cell backgrounds\n\t    const background = PIXI.Sprite.from(PIXI.Texture.WHITE);\n\t    background.tint = 0xd3c8a2;\n\t    background.width = this.edgeSize;\n\t    background.height = this.edgeSize;\n\t    background.alpha = 1;\n", "    background.anchor.set(0, 0);\n\t    this.addChild(background);\n\t    for (let i = 0; i < this.dimension; i++) {\n\t      const col1 = [];\n\t      const col2 = [];\n\t      for (let j = 0; j < this.dimension; j++) {\n\t        const cell = PIXI.Sprite.from(PIXI.Texture.WHITE);\n\t        cell.tint = 0;\n\t        cell.alpha = (i + j) % 2 == 0 ? 0 : 0.2;\n\t        cell.width = this.cellSize;\n", "        cell.height = this.cellSize;\n\t        const offset1 = (this.cellSize - cell.width) / 2;\n\t        cell.position.set(\n\t          i * this.cellSize + offset1,\n\t          j * this.cellSize + offset1\n\t        );\n\t        col1.push(cell);\n\t        this.addChild(cell);\n\t        const stair = PIXI.Sprite.from(Game.tex(\"stairs.png\"));\n\t        stair.width = this.cellSize * 0.8;\n", "        stair.height = this.cellSize * 0.8;\n\t        const offset2 = (this.cellSize - stair.width) / 2;\n\t        stair.position.set(\n\t          i * this.cellSize + offset2,\n\t          j * this.cellSize + offset2\n\t        );\n\t        stair.visible = false;\n\t        col2.push(stair);\n\t        this.addChild(stair);\n\t      }\n", "      this.cellSquares.push(col1);\n\t      this.cellStairs.push(col2);\n\t    }\n\t    this.addChild(this.wallsHolder);\n\t    this.addChild(this.charactersHolder);\n\t    for (let i = 0; i < this.dimension; i++) {\n\t      for (let j = 0; j < this.dimension; j++) {\n\t        this.coords.push(new Coords(i, j));\n\t      }\n\t    }\n", "  }\n\t  clearEnemies() {\n\t    for (let i = this.characters.length - 1; i >= 0; i--) {\n\t      const c = this.characters[i];\n\t      if (!c.isPlayer) {\n\t        Actions.fadeOutAndRemove(c, 0.2).play();\n\t        this.characters.splice(i, 1);\n\t      }\n\t    }\n\t  }\n", "  unsetExitCell() {\n\t    this.exitCoords = null;\n\t    this.updateExitCoords();\n\t  }\n\t  setExitCell(minDistanceFromPlayer: number = 7) {\n\t    const possibles = [];\n\t    const backups = [];\n\t    let dijks = null;\n\t    dijks = this.dijkstra(this.gameScreen.playerCharacter.coords, false);\n\t    for (let i = 0; i < this.dimension; i++) {\n", "      for (let j = 0; j < this.dimension; j++) {\n\t        if (i == 2 && j == 2) continue;\n\t        if (\n\t          Game.EXIT_TYPE == \"door\" &&\n\t          ![0, this.dimension - 1].includes(i) &&\n\t          ![0, this.dimension - 1].includes(j)\n\t        )\n\t          continue;\n\t        if (dijks.distance[i][j] >= minDistanceFromPlayer) {\n\t          possibles.push(new Coords(i, j));\n", "        }\n\t        if (dijks.distance[i][j] >= 3) {\n\t          backups.push(new Coords(i, j));\n\t        }\n\t      }\n\t    }\n\t    if (possibles.length == 0) {\n\t      possibles.push(...backups);\n\t    }\n\t    if (possibles.length == 0) {\n", "      for (let i = 0; i < this.dimension; i++) {\n\t        for (let j = 0; j < this.dimension; j++) {\n\t          if (i == 2 && j == 2) continue;\n\t          if (\n\t            Game.EXIT_TYPE == \"door\" &&\n\t            ![0, this.dimension - 1].includes(i) &&\n\t            ![0, this.dimension - 1].includes(j)\n\t          )\n\t            continue;\n\t          const c = new Coords(i, j);\n", "          let anyCoincidence = false;\n\t          if (this.gameScreen.playerCharacter.coords.equals(c)) {\n\t            anyCoincidence = true;\n\t            break;\n\t          }\n\t          if (!anyCoincidence) {\n\t            possibles.push(c);\n\t          }\n\t        }\n\t      }\n", "    }\n\t    const coords = _.sample(possibles);\n\t    this.exitCoords = coords;\n\t    if (Game.EXIT_TYPE == \"door\") {\n\t      const possibleDirs = [];\n\t      if (coords.row == 0) possibleDirs.push(new Coords(0, -1));\n\t      if (coords.row == this.dimension - 1) possibleDirs.push(new Coords(0, 1));\n\t      if (coords.col == 0) possibleDirs.push(new Coords(-1, 0));\n\t      if (coords.col == this.dimension - 1) possibleDirs.push(new Coords(1, 0));\n\t      if (possibleDirs.length > 0) this.exitDir = _.sample(possibleDirs);\n", "    }\n\t    this.updateExitCoords();\n\t  }\n\t  updateExitCoords() {\n\t    if (Game.EXIT_TYPE == \"stairs\") {\n\t      this.cellStairs.forEach((a, i) =>\n\t        a.forEach(\n\t          (stairs, j) =>\n\t            (stairs.visible =\n\t              this.exitCoords &&\n", "              this.exitCoords.col == i &&\n\t              this.exitCoords.row == j)\n\t        )\n\t      );\n\t    } else {\n\t      // Remove other edge walls (if there are any)\n\t      for (const c of this.edgeWalls) {\n\t        this.wallsHolder.removeChild(c);\n\t      }\n\t      this.edgeWalls = [];\n", "      // Add outer wall\n\t      let walls: Wall[] = Wall.edges(this.dimension);\n\t      // Make hole where exit is\n\t      if (this.exitCoords && this.exitDir) {\n\t        walls = walls.filter(\n\t          (w) => !w.blocks(this.exitCoords, this.exitDir.col, this.exitDir.row)\n\t        );\n\t      }\n\t      // Draw walls\n\t      this.drawWalls(walls);\n", "      this.walls.push(...walls);\n\t      this.edgeWalls.push(...walls);\n\t    }\n\t  }\n\t  getRandomEmptyCell(): Coords {\n\t    let dijks = null;\n\t    dijks = this.dijkstra(this.gameScreen.playerCharacter.coords, false);\n\t    const shuffledCoords = _.shuffle(this.coords);\n\t    for (const coord of shuffledCoords) {\n\t      if (this.exitCoords && this.exitCoords.equals(coord)) continue;\n", "      if (\n\t        !this.getCharacterAt(coord) &&\n\t        (!dijks || dijks.distance[coord.col][coord.row] > 1)\n\t      ) {\n\t        return coord;\n\t      }\n\t    }\n\t    return null;\n\t  }\n\t  generateWalls(numWalls: number) {\n", "    // Delete all old walls\n\t    for (const w of this.walls) {\n\t      Actions.fadeOutAndRemove(w, 0.2).play();\n\t    }\n\t    this.walls = Wall.randomLayout(numWalls, this.dimension);\n\t    // Add some new walls... they must generate any closed areas\n\t    this.drawWalls(this.walls);\n\t  }\n\t  drawWalls(walls: Wall[]) {\n\t    for (const w of walls) {\n", "      w.alpha = 0;\n\t      Actions.fadeIn(w, 0.2).play();\n\t      this.wallsHolder.addChild(w);\n\t      w.setCellSize(this.cellSize);\n\t      // Place in the correct place\n\t      this.setPositionTo(w, w.from, true);\n\t    }\n\t  }\n\t  addCharacter(character: Character) {\n\t    character.scale.set(0.2);\n", "    character.alpha = 0;\n\t    Actions.fadeIn(character, 0.2).play();\n\t    this.characters.push(character);\n\t    this.charactersHolder.addChild(character);\n\t    // Place in the correct place!\n\t    this.setPositionTo(character, character.coords);\n\t  }\n\t  getCharacterAt(col: number | Coords, row: number = null): Character {\n\t    let c = 0;\n\t    let r = 0;\n", "    if (typeof col == \"number\") {\n\t      c = col;\n\t      r = row;\n\t    } else {\n\t      c = col.col;\n\t      r = col.row;\n\t    }\n\t    for (const char of this.characters) {\n\t      if (char.coords.col == c && char.coords.row == r) {\n\t        return char;\n", "      }\n\t    }\n\t    return null;\n\t  }\n\t  bumpAnimation(character: Character, dx: number, dy: number) {\n\t    const time = 0.1;\n\t    Actions.sequence(\n\t      this.makeMoveTo(character, dx * 0.1, dy * 0.1, time / 2),\n\t      this.makeMoveTo(character, 0, 0, time / 2)\n\t    ).play();\n", "    return time;\n\t  }\n\t  damageEnemy(targetCharacter: EnemyCharacter) {\n\t    let delay = 0;\n\t    const didDie = targetCharacter.damage(1);\n\t    if (didDie) {\n\t      // Remove from characters array\n\t      const index = this.characters.indexOf(targetCharacter);\n\t      if (index >= 0) {\n\t        this.characters.splice(index, 1);\n", "      }\n\t      // Remove from charactersHolder\n\t      targetCharacter.position.x += this.position.x;\n\t      targetCharacter.position.y += this.position.y;\n\t      this.charactersHolder.removeChild(targetCharacter);\n\t      delay = 0;\n\t    }\n\t    return delay;\n\t  }\n\t  moveCharacter(\n", "    character: Character,\n\t    dx: number,\n\t    dy: number\n\t  ): { didMove: boolean; delay: number; wentThroughExit: boolean } {\n\t    // Check the target space is available\n\t    const targetCoord = character.coords.clone().add(dx, dy);\n\t    // Edge of grid!\n\t    if (!this.inBounds(targetCoord)) {\n\t      if (\n\t        this.exitCoords &&\n", "        character.coords.equals(this.exitCoords) &&\n\t        Game.EXIT_TYPE == \"door\" &&\n\t        this.exitDir &&\n\t        this.exitDir.equals(dx, dy)\n\t      ) {\n\t        // We are going through the exit!\n\t        return { didMove: true, delay: 0, wentThroughExit: true };\n\t      }\n\t      // Hitting the edge of the grid\n\t      Game.instance.playSound(\"bump\");\n", "      const delay = this.bumpAnimation(character, dx, dy);\n\t      return { didMove: false, delay, wentThroughExit: false };\n\t    }\n\t    // Hitting a wall?\n\t    if (this.doesWallSeparate(character.coords, dx, dy)) {\n\t      Game.instance.playSound(\"bump\");\n\t      const delay = this.bumpAnimation(character, dx, dy);\n\t      return { didMove: false, delay, wentThroughExit: false };\n\t    }\n\t    // Is there another character here?\n", "    try {\n\t      const targetCharacter = this.getCharacterAt(targetCoord);\n\t      if (targetCharacter) {\n\t        let delay = this.bumpAnimation(character, dx, dy);\n\t        if (character.isPlayer && targetCharacter.isEnemy) {\n\t          // Attack the character\n\t          Game.instance.playSound(\"attack\");\n\t          delay += this.damageEnemy(targetCharacter as EnemyCharacter);\n\t          return { didMove: true, delay, wentThroughExit: false };\n\t        } else if (character.isEnemy && targetCharacter.isPlayer) {\n", "          const player = targetCharacter as PlayerCharacter;\n\t          // Take a damage!\n\t          if (player.damage(1)) {\n\t            this.gameScreen.gameOver();\n\t          }\n\t          return { didMove: true, delay, wentThroughExit: false };\n\t        } else {\n\t          return { didMove: false, delay, wentThroughExit: false };\n\t        }\n\t      }\n", "    } catch (e) {\n\t      // The game is over\n\t      this.gameScreen.gameOver();\n\t      return { didMove: true, delay: 0, wentThroughExit: false };\n\t    }\n\t    // Move the character\n\t    if (character.isPlayer) {\n\t      Game.instance.playSound([\"step1\", \"step2\", \"step3\", \"step4\"]);\n\t    }\n\t    character.coords.set(targetCoord);\n", "    // Animate to the new position\n\t    this.makeMoveTo(character).play();\n\t    return { didMove: true, delay: 0.05, wentThroughExit: false };\n\t  }\n\t  doesWallSeparate(start: Coords, dx: number, dy: number) {\n\t    for (const w of this.walls) {\n\t      if (w.blocks(start, dx, dy)) {\n\t        return true;\n\t      }\n\t    }\n", "    return false;\n\t  }\n\t  moveEnemies() {\n\t    let delay = 0;\n\t    // 1. Dijkstra the grid, ignoring enemies\n\t    // Pick the closest character\n\t    const dijks = this.dijkstra(this.gameScreen.playerCharacter.coords, false);\n\t    const enemiesAndDistances = [];\n\t    for (const char of this.characters) {\n\t      if (char.isEnemy) {\n", "        let distance = dijks.distance[char.coords.col][char.coords.row];\n\t        enemiesAndDistances.push({\n\t          distance,\n\t          char,\n\t        });\n\t      }\n\t    }\n\t    // 2. Sort by closest to furthest\n\t    let sortedEnemies = _.sortBy(enemiesAndDistances, \"distance\");\n\t    // 3. For each enemy, pathfind (properly) to the player\n", "    let atLeastOneMove = false;\n\t    for (let tries = 0; tries < 5; tries++) {\n\t      const tryAgainLater = [];\n\t      for (const e of sortedEnemies) {\n\t        const char = e.char;\n\t        const dijks = this.dijkstra(\n\t          this.gameScreen.playerCharacter.coords,\n\t          true,\n\t          char.coords\n\t        );\n", "        // Move in the direction which has the lowest distance\n\t        let targetCol = dijks.col[char.coords.col][char.coords.row];\n\t        let targetRow = dijks.row[char.coords.col][char.coords.row];\n\t        if (targetCol == null || targetRow == null) {\n\t          const neighbours: Coords[] = [];\n\t          this.addPotentialNeighbour(neighbours, char.coords, 1, 0);\n\t          this.addPotentialNeighbour(neighbours, char.coords, 0, 1);\n\t          this.addPotentialNeighbour(neighbours, char.coords, -1, 0);\n\t          this.addPotentialNeighbour(neighbours, char.coords, 0, -1);\n\t          if (neighbours.length > 0) {\n", "            // If there is no good route, then random direction\n\t            const dir = _.sample(neighbours);\n\t            targetCol = dir.col;\n\t            targetRow = dir.row;\n\t          } else {\n\t            // If there is no route at all, then wait, we'll try again in a bit\n\t            tryAgainLater.push(e);\n\t            continue;\n\t          }\n\t        }\n", "        const dx = targetCol - char.coords.col;\n\t        const dy = targetRow - char.coords.row;\n\t        atLeastOneMove = true;\n\t        delay = Math.max(this.moveCharacter(char, dx, dy).delay, delay);\n\t      }\n\t      if (tryAgainLater.length == 0) {\n\t        break;\n\t      } else {\n\t        sortedEnemies = tryAgainLater;\n\t      }\n", "    }\n\t    return { didMove: true, delay };\n\t  }\n\t  addPotentialNeighbour(\n\t    list: Coords[],\n\t    coords: Coords,\n\t    dx: number,\n\t    dy: number\n\t  ) {\n\t    if (!this.inBounds(coords.col + dx, coords.row + dy)) {\n", "      // Out of bounds, ignore!\n\t      return;\n\t    }\n\t    if (this.doesWallSeparate(coords, dx, dy)) {\n\t      // There is no path, ignore!\n\t      return;\n\t    }\n\t    const char = this.getCharacterAt(coords.col + dx, coords.row + dy);\n\t    if (char && char.isEnemy) {\n\t      // There is a monster on the target square, ignore!\n", "      return;\n\t    }\n\t    list.push(coords.clone().add(dx, dy));\n\t  }\n\t  updateTentativeDistance(\n\t    withEnemiesAsObstacles: boolean,\n\t    tentativeDistance: number[][],\n\t    tentativeSourceCol: number[][],\n\t    tentativeSourceRow: number[][],\n\t    coords: Coords,\n", "    dx: number,\n\t    dy: number\n\t  ) {\n\t    if (!this.inBounds(coords.col + dx, coords.row + dy)) {\n\t      // Out of bounds, ignore!\n\t      return;\n\t    }\n\t    if (this.doesWallSeparate(coords, dx, dy)) {\n\t      // There is no path, ignore!\n\t      return;\n", "    }\n\t    if (withEnemiesAsObstacles) {\n\t      const char = this.getCharacterAt(coords.col + dx, coords.row + dy);\n\t      if (char && char.isEnemy) {\n\t        // There is a monster on the target square, ignore!\n\t        return;\n\t      }\n\t    }\n\t    const newTentativeDistance = tentativeDistance[coords.col][coords.row] + 1;\n\t    if (\n", "      tentativeDistance[coords.col + dx][coords.row + dy] > newTentativeDistance\n\t    ) {\n\t      tentativeDistance[coords.col + dx][coords.row + dy] =\n\t        newTentativeDistance;\n\t      tentativeSourceCol[coords.col + dx][coords.row + dy] = coords.col;\n\t      tentativeSourceRow[coords.col + dx][coords.row + dy] = coords.row;\n\t    }\n\t  }\n\t  dijkstra(\n\t    target: Coords,\n", "    withEnemiesAsObstacles: boolean,\n\t    stopAt: Coords = null\n\t  ): { distance: number[][]; col: number[][]; row: number[][] } {\n\t    const current = target.clone();\n\t    const visited: boolean[][] = [];\n\t    const tentativeDistance: number[][] = [];\n\t    const tentativeSourceCol: number[][] = [];\n\t    const tentativeSourceRow: number[][] = [];\n\t    for (let i = 0; i < this.dimension; i++) {\n\t      // col\n", "      const c1 = [];\n\t      const c2 = [];\n\t      const c3 = [];\n\t      const c4 = [];\n\t      for (let j = 0; j < this.dimension; j++) {\n\t        // row\n\t        c1.push(false);\n\t        if (target.row == j && target.col == i) {\n\t          c2.push(0);\n\t        } else {\n", "          c2.push(99999);\n\t        }\n\t        c3.push(null);\n\t        c4.push(null);\n\t      }\n\t      visited.push(c1);\n\t      tentativeDistance.push(c2);\n\t      tentativeSourceCol.push(c3);\n\t      tentativeSourceRow.push(c4);\n\t    }\n", "    do {\n\t      // Consider all unvisited neighbours of `current`\n\t      const utd = (dx: number, dy: number) => {\n\t        this.updateTentativeDistance(\n\t          stopAt && stopAt.equals(current.col + dx, current.row + dy)\n\t            ? false\n\t            : withEnemiesAsObstacles,\n\t          tentativeDistance,\n\t          tentativeSourceCol,\n\t          tentativeSourceRow,\n", "          current,\n\t          dx,\n\t          dy\n\t        );\n\t      };\n\t      utd(1, 0);\n\t      utd(-1, 0);\n\t      utd(0, -1);\n\t      utd(0, 1);\n\t      // Mark current as visited\n", "      visited[current.col][current.row] = true;\n\t      // Stop if we've connected our two target points\n\t      if (stopAt && stopAt.equals(current)) break;\n\t      let smallestTentativeDistance = 9999999;\n\t      let smallests = [];\n\t      for (let i = 0; i < this.dimension; i++) {\n\t        for (let j = 0; j < this.dimension; j++) {\n\t          if (visited[i][j]) continue;\n\t          if (\n\t            smallests.length == 0 ||\n", "            tentativeDistance[i][j] < smallestTentativeDistance\n\t          ) {\n\t            smallestTentativeDistance = tentativeDistance[i][j];\n\t            smallests = [];\n\t          }\n\t          if (tentativeDistance[i][j] == smallestTentativeDistance) {\n\t            smallests.push([i, j]);\n\t          }\n\t        }\n\t      }\n", "      // If there are no unvisited, we are done\n\t      if (smallests.length == 0) break;\n\t      // Otherwise, set current to unvisited with smallest tentative\n\t      const randomSmallest = _.sample(smallests);\n\t      current.set(randomSmallest[0], randomSmallest[1]);\n\t    } while (true);\n\t    // Return the dijkstra map for the whole grid\n\t    return {\n\t      distance: tentativeDistance,\n\t      col: tentativeSourceCol,\n", "      row: tentativeSourceRow,\n\t    };\n\t  }\n\t}\n"]}
{"filename": "src/screens/game/character/EnemyCharacter.ts", "chunked_list": ["import Character from \"./Character\";\n\timport * as _ from \"underscore\";\n\texport type EnemyCharacterType = \"enemy1\" | \"enemy2\" | \"enemy3\";\n\texport default class EnemyCharacter extends Character {\n\t  constructor(type: EnemyCharacterType) {\n\t    const spriteName = \"enemy-character.png\";\n\t    super(spriteName);\n\t    this.type = type;\n\t    if (this.type === \"enemy1\") {\n\t      this.hp = 1;\n", "      this.maxHp = 1;\n\t    } else if (this.type === \"enemy2\") {\n\t      this.hp = 2;\n\t      this.maxHp = 2;\n\t    } else if (this.type === \"enemy3\") {\n\t      this.hp = 3;\n\t      this.maxHp = 3;\n\t    }\n\t  }\n\t  get isEnemy() {\n", "    return true;\n\t  }\n\t}\n"]}
{"filename": "src/screens/game/character/Character.ts", "chunked_list": ["import * as PIXI from \"pixi.js\";\n\timport Game from \"Game\";\n\timport { Coords } from \"utils\";\n\timport type { EnemyCharacterType } from \"./EnemyCharacter\";\n\texport type CharacterType = \"player\" | EnemyCharacterType;\n\texport default class Character extends PIXI.Container {\n\t  coords: Coords;\n\t  _hp: number = 1;\n\t  _maxHp: number = 1;\n\t  type: CharacterType;\n", "  sprite: PIXI.Sprite;\n\t  heartsHolder: PIXI.Container;\n\t  constructor(backgroundPath: string) {\n\t    super();\n\t    this.coords = new Coords(0, 0);\n\t    this.sprite = PIXI.Sprite.from(Game.tex(backgroundPath));\n\t    this.sprite.anchor.set(0.5, 1);\n\t    this.addChild(this.sprite);\n\t    // Add holder for hearts\n\t    this.heartsHolder = new PIXI.Container();\n", "    this.addChild(this.heartsHolder);\n\t  }\n\t  get isEnemy() {\n\t    return false;\n\t  }\n\t  get isPlayer() {\n\t    return false;\n\t  }\n\t  get hp() {\n\t    return this._hp;\n", "  }\n\t  set hp(hp: number) {\n\t    this._hp = hp;\n\t    // CHANGE WHITE/REDNESS\n\t    for (let i = 0; i < this.heartsHolder.children.length; i++) {\n\t      const heart = this.heartsHolder.children[i];\n\t      (heart as PIXI.Sprite).tint = (i < this._hp) ? 0xff0000 : 0xffffff;\n\t    }\n\t  }\n\t  get maxHp() {\n", "    return this._maxHp;\n\t  }\n\t  set maxHp(maxHp: number) {\n\t    this._maxHp = maxHp;\n\t    this.heartsHolder.removeChildren();\n\t    for (let i = 0; i < this._maxHp; i++) {\n\t      const heart = PIXI.Sprite.from(Game.tex(\"heart.png\"));\n\t      heart.anchor.set(0.5);\n\t      heart.position.set(\n\t        -(this._maxHp * heart.width)/2 + heart.width * (i + 0.5),\n", "        0\n\t      );\n\t      heart.tint = (i < this._hp) ? 0xff0000 : 0xffffff;\n\t      this.heartsHolder.addChild(heart);\n\t    }\n\t  }\n\t  damage(amount: number): boolean {\n\t    this.hp -= amount;\n\t    return this.hp <= 0;\n\t  }\n", "}\n"]}
{"filename": "src/screens/game/character/PlayerCharacter.ts", "chunked_list": ["import Character from \"./Character\";\n\texport default class PlayerCharacter extends Character {\n\t  constructor() {\n\t    super(\"player-character.png\");\n\t    this.type = \"player\";\n\t    this.hp = 4;\n\t    this.maxHp = 4;\n\t  }\n\t  get isPlayer() {\n\t    return true;\n", "  }\n\t}\n"]}
{"filename": "src/screens/game/character/index.ts", "chunked_list": ["import Character from \"./Character\";\n\timport EnemyCharacter from \"./EnemyCharacter\";\n\timport PlayerCharacter from \"./PlayerCharacter\";\n\texport { Character, EnemyCharacter, PlayerCharacter };\n"]}
