{"filename": "test/mutator.spec.ts", "chunked_list": ["import axios from \"axios\";\n\timport { beforeEach } from \"@jest/globals\";\n\timport { RulePilot } from \"../src\";\n\timport { valid1Json } from \"./rulesets/valid1.json\";\n\timport { valid3Json } from \"./rulesets/valid3.json\";\n\tconst mutation1 = async (value) => {\n\t  const result = await axios.get(\n\t    `https://restcountries.com/v3.1/name/${value}?fullText=true`\n\t  );\n\t  return result.data[0].cca2;\n", "};\n\tconst mutation2 = async (value) => {\n\t  const result = await axios.get(\n\t    `https://restcountries.com/v3.1/name/${value[0]}?fullText=true`\n\t  );\n\t  return result.data[0].cca2;\n\t};\n\tconst criteria = [\n\t  {\n\t    CountryIso: \"United Kingdom\",\n", "    Leverage: 60,\n\t    Monetization: \"Real\",\n\t  },\n\t  {\n\t    CountryIso: \"United Kingdom\",\n\t    Leverage: 200,\n\t    Monetization: \"Real\",\n\t  },\n\t  {\n\t    CountryIso: \"United Kingdom\",\n", "    Leverage: 60,\n\t    Monetization: \"Real\",\n\t  },\n\t];\n\tdescribe(\"RulePilot mutator correctly\", () => {\n\t  beforeEach(() => {\n\t    console.debug = jest.fn();\n\t    process.env.DEBUG = \"true\";\n\t  });\n\t  it(\"Performs desired mutation\", async () => {\n", "    const rp = new RulePilot();\n\t    rp.addMutation(\"ProfitPercentage\", (value) => value * 2);\n\t    expect(await rp.evaluate(valid1Json, { ProfitPercentage: 5 })).toEqual(\n\t      true\n\t    );\n\t  });\n\t  it(\"Performs multiple mutations\", async () => {\n\t    const rp = new RulePilot();\n\t    rp.addMutation(\"WinRate\", (value) => value * 2);\n\t    rp.addMutation(\"AverageTradeDuration\", (value) => value / 2);\n", "    expect(\n\t      await rp.evaluate(valid1Json, {\n\t        WinRate: 31,\n\t        AverageTradeDuration: 60,\n\t        Duration: 99999999,\n\t        TotalDaysTraded: 3,\n\t      })\n\t    ).toEqual(true);\n\t  });\n\t  it(\"Performs async mutation\", async () => {\n", "    const rp = new RulePilot();\n\t    rp.addMutation(\"CountryIso\", mutation1);\n\t    expect(\n\t      await rp.evaluate(valid3Json, {\n\t        CountryIso: \"United Kingdom\",\n\t        Leverage: 60,\n\t        Monetization: \"Real\",\n\t        foo: {\n\t          CountryIso: \"United Kingdom\",\n\t        },\n", "      })\n\t    ).toEqual(3);\n\t  });\n\t  it(\"Performs nested mutation\", async () => {\n\t    const rp = new RulePilot();\n\t    rp.addMutation(\"foo.bar\", (value) => value * 2);\n\t    expect(\n\t      await rp.evaluate(\n\t        {\n\t          conditions: [\n", "            {\n\t              all: [{ field: \"foo.bar\", operator: \">\", value: 6 }],\n\t            },\n\t          ],\n\t        },\n\t        { foo: { bar: 5 } }\n\t      )\n\t    ).toEqual(true);\n\t  });\n\t  it(\"Caches async mutation results\", async () => {\n", "    const rp = new RulePilot();\n\t    rp.addMutation(\"Leverage\", (value) => value);\n\t    rp.addMutation(\"CountryIso\", mutation1);\n\t    const result = await rp.evaluate(valid3Json, criteria);\n\t    expect(console.debug).toBeCalledWith(\n\t      'Waiting on mutation \"CountryIso\" with param \"United Kingdom\"'\n\t    );\n\t    expect(console.debug).toBeCalledTimes(9);\n\t    expect(result).toEqual([3, 2, 3]);\n\t  });\n", "  it(\"Performs a migration with an array parameter\", async () => {\n\t    const rp = new RulePilot();\n\t    rp.addMutation(\"CountryIso\", mutation2);\n\t    const result = await rp.evaluate(\n\t      {\n\t        conditions: [\n\t          {\n\t            all: [{ field: \"CountryIso\", operator: \"==\", value: \"GB\" }],\n\t          },\n\t        ],\n", "      },\n\t      { CountryIso: [\"United Kingdom\", \"Finland\"] }\n\t    );\n\t    expect(result).toEqual(true);\n\t  });\n\t  it(\"Performs a migration with a nested array parameter\", async () => {\n\t    const rp = new RulePilot();\n\t    rp.addMutation(\"foo.bar\", mutation2);\n\t    const result = await rp.evaluate(\n\t      {\n", "        conditions: [\n\t          {\n\t            all: [{ field: \"foo.bar\", operator: \"==\", value: \"GB\" }],\n\t          },\n\t        ],\n\t      },\n\t      { foo: { bar: [\"United Kingdom\", \"Finland\"] } }\n\t    );\n\t    expect(result).toEqual(true);\n\t  });\n", "  it(\"Mutation cache works properly\", async () => {\n\t    const rp = new RulePilot();\n\t    rp.addMutation(\"Leverage\", (value) => value);\n\t    rp.addMutation(\"CountryIso\", mutation1);\n\t    await rp.evaluate(valid3Json, criteria);\n\t    setTimeout(async () => {\n\t      const result = await rp.evaluate(valid3Json, criteria);\n\t      expect(console.debug).toBeCalledWith(\n\t        'Cache hit on \"CountryIso\" with param \"United Kingdom\"'\n\t      );\n", "      expect(result).toEqual([3, 2, 3]);\n\t    }, 1500);\n\t  });\n\t  it(\"Removes a mutation properly\", async () => {\n\t    const rp = new RulePilot();\n\t    rp.addMutation(\"CountryIso\", mutation1);\n\t    rp.removeMutation(\"CountryIso\");\n\t    const result = await rp.evaluate(valid3Json, {\n\t      CountryIso: \"United Kingdom\",\n\t      Leverage: 60,\n", "      Monetization: \"Real\",\n\t    });\n\t    expect(console.debug).not.toHaveBeenCalled();\n\t    expect(result).toEqual(2);\n\t  });\n\t  it(\"Clears mutation cache properly\", async () => {\n\t    const rp = new RulePilot();\n\t    rp.addMutation(\"CountryIso\", mutation1);\n\t    await rp.evaluate(valid3Json, {\n\t      CountryIso: \"United Kingdom\",\n", "      Leverage: 60,\n\t      Monetization: \"Real\",\n\t    });\n\t    rp.clearMutationCache(\"CountryIso\");\n\t    const result = await rp.evaluate(valid3Json, {\n\t      CountryIso: \"United Kingdom\",\n\t      Leverage: 60,\n\t      Monetization: \"Real\",\n\t    });\n\t    expect(console.debug).not.toHaveBeenCalledWith(\n", "      'Waiting on mutation \"CountryIso\" with param \"United Kingdom\"'\n\t    );\n\t    expect(result).toEqual(3);\n\t  });\n\t  it(\"Clears all mutation cache properly\", async () => {\n\t    const rp = new RulePilot();\n\t    rp.addMutation(\"CountryIso\", mutation1);\n\t    await rp.evaluate(valid3Json, {\n\t      CountryIso: \"United Kingdom\",\n\t      Leverage: 60,\n", "      Monetization: \"Real\",\n\t    });\n\t    rp.clearMutationCache();\n\t    const result = await rp.evaluate(valid3Json, {\n\t      CountryIso: \"United Kingdom\",\n\t      Leverage: 60,\n\t      Monetization: \"Real\",\n\t    });\n\t    expect(console.debug).not.toHaveBeenCalledWith(\n\t      'Waiting on mutation \"CountryIso\" with param \"United Kingdom\"'\n", "    );\n\t    expect(result).toEqual(3);\n\t  });\n\t  it(\"Static methods behave as expected\", async () => {\n\t    const rp = new RulePilot();\n\t    RulePilot.addMutation(\"CountryIso\", mutation1);\n\t    const result1 = await RulePilot.evaluate(valid3Json, {\n\t      CountryIso: \"United Kingdom\",\n\t      Leverage: 60,\n\t      Monetization: \"Real\",\n", "    });\n\t    expect(result1).toEqual(3);\n\t    RulePilot.removeMutation(\"CountryIso\");\n\t    const result2 = await rp.evaluate(valid3Json, {\n\t      CountryIso: \"United Kingdom\",\n\t      Leverage: 60,\n\t      Monetization: \"Real\",\n\t    });\n\t    expect(result2).toEqual(2);\n\t    RulePilot.clearMutationCache();\n", "    const result3 = await rp.evaluate(valid3Json, {\n\t      CountryIso: \"United Kingdom\",\n\t      Leverage: 60,\n\t      Monetization: \"Real\",\n\t    });\n\t    expect(console.debug).not.toHaveBeenCalledWith(\n\t      'Waiting on mutation \"CountryIso\" with param \"United Kingdom\"'\n\t    );\n\t    expect(result3).toEqual(2);\n\t  });\n", "});\n"]}
{"filename": "test/validator.spec.ts", "chunked_list": ["import { RulePilot, Operator, Condition, Constraint } from \"../src\";\n\timport { valid1Json } from \"./rulesets/valid1.json\";\n\timport { valid3Json } from \"./rulesets/valid3.json\";\n\timport { invalid1Json } from \"./rulesets/invalid1.json\";\n\tdescribe(\"RulePilot validator correctly\", () => {\n\t  it(\"Identifies a bad operator\", () => {\n\t    expect(\n\t      RulePilot.validate({\n\t        conditions: [\n\t          {\n", "            all: [{ field: \"name\", operator: \"*\" as Operator, value: \"test\" }],\n\t          },\n\t        ],\n\t      }).isValid\n\t    ).toEqual(false);\n\t  });\n\t  it(\"Identifies an invalid field\", () => {\n\t    expect(\n\t      RulePilot.validate({\n\t        conditions: [\n", "          {\n\t            all: [\n\t              {\n\t                field: true as unknown as string,\n\t                operator: \"==\",\n\t                value: \"test\",\n\t              },\n\t            ],\n\t          },\n\t        ],\n", "      }).isValid\n\t    ).toEqual(false);\n\t  });\n\t  it(\"Identifies an invalid condition\", () => {\n\t    expect(\n\t      RulePilot.validate({\n\t        conditions: [\n\t          {\n\t            all: [\n\t              {\n", "                field: \"foo\",\n\t                operator: \"==\",\n\t                value: \"bar\",\n\t              },\n\t            ],\n\t            any: [],\n\t          },\n\t        ],\n\t      }).isValid\n\t    ).toEqual(false);\n", "  });\n\t  it(\"Identifies an invalid node\", () => {\n\t    expect(\n\t      RulePilot.validate({\n\t        conditions: [\n\t          {\n\t            all: [\n\t              {\n\t                operator: \"==\",\n\t                value: \"bar\",\n", "              } as Constraint,\n\t            ],\n\t          },\n\t        ],\n\t      }).isValid\n\t    ).toEqual(false);\n\t  });\n\t  it(\"Identifies an badly constructed condition\", () => {\n\t    expect(\n\t      RulePilot.validate({\n", "        conditions: [\n\t          {\n\t            foo: [\n\t              {\n\t                field: \"foo\",\n\t                operator: \"==\",\n\t                value: \"bar\",\n\t              },\n\t            ],\n\t          } as Condition,\n", "        ],\n\t      }).isValid\n\t    ).toEqual(false);\n\t  });\n\t  it(\"Identifies an invalid rule\", () => {\n\t    const validation = RulePilot.validate(invalid1Json);\n\t    expect(validation.isValid).toEqual(false);\n\t    expect(validation.error.message).toEqual(\n\t      'Nested conditions cannot have a property \"result\".'\n\t    );\n", "  });\n\t  it(\"Identifies an empty rule\", () => {\n\t    const validation = RulePilot.validate({ conditions: [] });\n\t    expect(validation.isValid).toEqual(false);\n\t    expect(validation.error.message).toEqual(\n\t      \"The conditions property must contain at least one condition.\"\n\t    );\n\t  });\n\t  it(\"Identifies invalid values for In/Not In operators\", () => {\n\t    expect(\n", "      RulePilot.validate({\n\t        conditions: [\n\t          { all: [{ field: \"name\", operator: \"in\", value: \"test\" }] },\n\t        ],\n\t      }).isValid\n\t    ).toEqual(false);\n\t    expect(\n\t      RulePilot.validate({\n\t        conditions: [\n\t          { all: [{ field: \"name\", operator: \"not in\", value: \"test\" }] },\n", "        ],\n\t      }).isValid\n\t    ).toEqual(false);\n\t  });\n\t  it(\"Validates a correct rule\", () => {\n\t    expect(\n\t      RulePilot.validate({\n\t        conditions: [\n\t          { all: [{ field: \"name\", operator: \"==\", value: \"test\" }] },\n\t        ],\n", "      }).isValid\n\t    ).toEqual(true);\n\t  });\n\t  it(\"Validates a simple correct rule\", () => {\n\t    expect(RulePilot.validate(valid1Json).isValid).toEqual(true);\n\t  });\n\t  it(\"Validates a nested correct rule\", () => {\n\t    expect(RulePilot.validate(valid3Json).isValid).toEqual(true);\n\t  });\n\t});\n"]}
{"filename": "test/engine.spec.ts", "chunked_list": ["import { RulePilot, Operator, RuleError } from \"../src\";\n\timport { valid1Json } from \"./rulesets/valid1.json\";\n\timport { valid2Json } from \"./rulesets/valid2.json\";\n\timport { valid3Json } from \"./rulesets/valid3.json\";\n\timport { valid4Json } from \"./rulesets/valid4.json\";\n\timport { invalid1Json } from \"./rulesets/invalid1.json\";\n\tdescribe(\"RulePilot engine correctly\", () => {\n\t  it(\"Evaluates a simple ruleset\", async () => {\n\t    expect(\n\t      await RulePilot.evaluate(valid1Json, { ProfitPercentage: 20 })\n", "    ).toEqual(true);\n\t    expect(\n\t      await RulePilot.evaluate(valid1Json, { ProfitPercentage: 2 })\n\t    ).toEqual(false);\n\t    expect(\n\t      await RulePilot.evaluate(valid1Json, {\n\t        WinRate: 80,\n\t        AverageTradeDuration: 5,\n\t        Duration: 9000000,\n\t      })\n", "    ).toEqual(false);\n\t    expect(\n\t      await RulePilot.evaluate(valid1Json, {\n\t        WinRate: 80,\n\t        AverageTradeDuration: 5,\n\t        Duration: 9000000,\n\t        TotalDaysTraded: 5,\n\t      })\n\t    ).toEqual(true);\n\t  });\n", "  it(\"Evaluates to false if operator is unknown\", async () => {\n\t    expect(\n\t      await RulePilot.evaluate(\n\t        {\n\t          conditions: [\n\t            {\n\t              all: [\n\t                { field: \"name\", operator: \"foo\" as Operator, value: \"test\" },\n\t              ],\n\t            },\n", "          ],\n\t        },\n\t        { name: \"test\" },\n\t        true\n\t      )\n\t    ).toEqual(false);\n\t  });\n\t  it(\"Resolves nested field definitions\", async () => {\n\t    expect(\n\t      await RulePilot.evaluate(\n", "        {\n\t          conditions: [\n\t            {\n\t              all: [{ field: \"foo.bar\", operator: \"==\", value: \"test\" }],\n\t            },\n\t          ],\n\t        },\n\t        {\n\t          foo: {\n\t            bar: \"test\",\n", "          },\n\t        }\n\t      )\n\t    ).toEqual(true);\n\t  });\n\t  it(\"Handles missing nested field definitions\", async () => {\n\t    expect(\n\t      await RulePilot.evaluate(\n\t        {\n\t          conditions: [\n", "            {\n\t              all: [{ field: \"foo.foo\", operator: \"==\", value: \"test\" }],\n\t            },\n\t          ],\n\t        },\n\t        {\n\t          foo: {\n\t            bar: \"test\",\n\t          },\n\t        }\n", "      )\n\t    ).toEqual(false);\n\t  });\n\t  it(\"Handles array of criteria properly\", async () => {\n\t    expect(\n\t      await RulePilot.evaluate(\n\t        {\n\t          conditions: [\n\t            {\n\t              all: [{ field: \"foo.bar\", operator: \"==\", value: \"bar\" }],\n", "            },\n\t          ],\n\t        },\n\t        [\n\t          {\n\t            foo: {\n\t              bar: \"test\",\n\t            },\n\t          },\n\t          {\n", "            foo: {\n\t              bar: \"bar\",\n\t            },\n\t          },\n\t          {},\n\t        ]\n\t      )\n\t    ).toEqual([false, true, false]);\n\t  });\n\t  it(\"Throws an error on invalid not runnable ruleset\", () => {\n", "    expect(\n\t      async () => await RulePilot.evaluate({ conditions: [] }, {})\n\t    ).rejects.toThrow(RuleError);\n\t  });\n\t  it(\"Evaluates an invalid but runnable ruleset if marked as trusted\", async () => {\n\t    expect(await RulePilot.evaluate(invalid1Json, {}, true)).toEqual(2);\n\t  });\n\t  it(\"Evaluates a nested ruleset\", async () => {\n\t    expect(await RulePilot.evaluate(valid3Json, {})).toEqual(2);\n\t    expect(await RulePilot.evaluate(valid3Json, { Leverage: 1000 })).toEqual(3);\n", "    expect(await RulePilot.evaluate(valid3Json, { Leverage: 999 })).toEqual(2);\n\t    expect(\n\t      await RulePilot.evaluate(valid3Json, { Category: \"Islamic\" })\n\t    ).toEqual(4);\n\t    expect(\n\t      await RulePilot.evaluate(valid3Json, { Monetization: \"Real\" })\n\t    ).toEqual(2);\n\t    expect(\n\t      await RulePilot.evaluate(valid3Json, {\n\t        Monetization: \"Real\",\n", "        Leverage: 150,\n\t        CountryIso: \"FI\",\n\t      })\n\t    ).toEqual(3);\n\t    expect(\n\t      await RulePilot.evaluate(valid3Json, {\n\t        Monetization: \"Real\",\n\t        Leverage: 150,\n\t        CountryIso: \"FI\",\n\t        foo: \"bar\",\n", "        another: false,\n\t      })\n\t    ).toEqual(3);\n\t  });\n\t  it(\"Evaluates a simple ruleset with redundant condition\", async () => {\n\t    expect(await RulePilot.evaluate(valid4Json, { foo: true }, true)).toEqual(\n\t      2\n\t    );\n\t    expect(\n\t      await RulePilot.evaluate(valid4Json, { Category: \"Islamic\" }, true)\n", "    ).toEqual(4);\n\t  });\n\t  it(\"Evaluates a simple ruleset with none type condition\", async () => {\n\t    expect(\n\t      await RulePilot.evaluate(valid2Json, {\n\t        Leverage: 100,\n\t        WinRate: 80,\n\t        AverageTradeDuration: 5,\n\t        Duration: 9000000,\n\t        TotalDaysTraded: 5,\n", "      })\n\t    ).toEqual(true);\n\t    expect(\n\t      await RulePilot.evaluate(valid2Json, {\n\t        AverageTradeDuration: 10,\n\t        Foo: 10,\n\t      })\n\t    ).toEqual(true);\n\t  });\n\t});\n"]}
{"filename": "test/builder.spec.ts", "chunked_list": ["import { Rule, RulePilot } from \"../src\";\n\tdescribe(\"RulePilot builder correctly\", () => {\n\t  it(\"Creates a valid ruleset\", () => {\n\t    const builder = RulePilot.builder();\n\t    expect(\n\t      RulePilot.validate(\n\t        builder\n\t          .add(\n\t            builder.condition(\"all\", [\n\t              builder.constraint(\"field\", \"==\", \"value\"),\n", "            ])\n\t          )\n\t          .build()\n\t      ).isValid\n\t    ).toEqual(true);\n\t  });\n\t  it(\"Creates a complex ruleset properly\", () => {\n\t    const builder = RulePilot.builder();\n\t    const rule: Rule = builder\n\t      .add(\n", "        builder.condition(\n\t          \"all\",\n\t          [\n\t            builder.condition(\"any\", [\n\t              builder.constraint(\"fieldA\", \"==\", \"bar\"),\n\t              builder.constraint(\"fieldB\", \">=\", 2),\n\t            ]),\n\t            builder.constraint(\"fieldC\", \"not in\", [1, 2, 3]),\n\t          ],\n\t          3\n", "        )\n\t      )\n\t      .add(builder.condition(\"none\", [], 5))\n\t      .add(\n\t        builder.condition(\"any\", [builder.constraint(\"fieldA\", \"==\", \"value\")])\n\t      )\n\t      .default(2)\n\t      .build(true);\n\t    expect(rule).toEqual({\n\t      conditions: [\n", "        {\n\t          all: [\n\t            {\n\t              any: [\n\t                { field: \"fieldA\", operator: \"==\", value: \"bar\" },\n\t                { field: \"fieldB\", operator: \">=\", value: 2 },\n\t              ],\n\t            },\n\t            { field: \"fieldC\", operator: \"not in\", value: [1, 2, 3] },\n\t          ],\n", "          result: 3,\n\t        },\n\t        { none: [], result: 5 },\n\t        {\n\t          any: [{ field: \"fieldA\", operator: \"==\", value: \"value\" }],\n\t        },\n\t      ],\n\t      default: 2,\n\t    });\n\t  });\n", "  it(\"Throws an error when validating an invalid ruleset\", () => {\n\t    const builder = RulePilot.builder();\n\t    expect(() =>\n\t      builder\n\t        .add(\n\t          builder.condition(\n\t            \"all\",\n\t            [\n\t              builder.condition(\n\t                \"any\",\n", "                [\n\t                  builder.constraint(\"fieldA\", \"==\", \"bar\"),\n\t                  builder.constraint(\"fieldB\", \">=\", 2),\n\t                ],\n\t                \"Invalid!!\"\n\t              ),\n\t              builder.constraint(\"fieldC\", \"not in\", [1, 2, 3]),\n\t            ],\n\t            3\n\t          )\n", "        )\n\t        .build(true)\n\t    ).toThrowError();\n\t  });\n\t});\n"]}
{"filename": "test/rulesets/valid3.json.ts", "chunked_list": ["import { Rule } from \"../../src\";\n\texport const valid3Json: Rule = {\n\t  conditions: [\n\t    {\n\t      any: [\n\t        {\n\t          all: [\n\t            {\n\t              field: \"CountryIso\",\n\t              operator: \"in\",\n", "              value: [\"GB\", \"FI\"],\n\t            },\n\t            {\n\t              field: \"Leverage\",\n\t              operator: \"<\",\n\t              value: 200,\n\t            },\n\t            {\n\t              field: \"Monetization\",\n\t              operator: \"==\",\n", "              value: \"Real\",\n\t            },\n\t          ],\n\t        },\n\t        {\n\t          field: \"Leverage\",\n\t          operator: \">=\",\n\t          value: 1000,\n\t        },\n\t      ],\n", "      result: 3,\n\t    },\n\t    {\n\t      all: [\n\t        {\n\t          field: \"Category\",\n\t          operator: \"==\",\n\t          value: \"Islamic\",\n\t        },\n\t      ],\n", "      result: 4,\n\t    },\n\t  ],\n\t  default: 2,\n\t};\n"]}
{"filename": "test/rulesets/invalid1.json.ts", "chunked_list": ["import { Rule } from \"../../src\";\n\texport const invalid1Json: Rule = {\n\t  conditions: [\n\t    {\n\t      any: [\n\t        {\n\t          all: [\n\t            {\n\t              field: \"CountryIso\",\n\t              operator: \"in\",\n", "              value: [\"GB\", \"FI\"],\n\t            },\n\t            {\n\t              field: \"Leverage\",\n\t              operator: \"<\",\n\t              value: 200,\n\t            },\n\t            {\n\t              field: \"Monetization\",\n\t              operator: \"==\",\n", "              value: \"Real\",\n\t            },\n\t          ],\n\t          // Result property is only allowed on the top level conditions\n\t          result: \"This is invalid!!!!!!!\",\n\t        },\n\t        {\n\t          all: [\n\t            {\n\t              field: \"Leverage\",\n", "              operator: \">=\",\n\t              value: 1000,\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t      result: 3,\n\t    },\n\t    {\n\t      all: [\n", "        {\n\t          field: \"Category\",\n\t          operator: \"==\",\n\t          value: \"Islamic\",\n\t        },\n\t      ],\n\t      result: 4,\n\t    },\n\t  ],\n\t  default: 2,\n", "};\n"]}
{"filename": "test/rulesets/valid2.json.ts", "chunked_list": ["import { Rule } from \"../../src\";\n\texport const valid2Json: Rule = {\n\t  conditions: {\n\t    any: [\n\t      {\n\t        all: [\n\t          {\n\t            field: \"Leverage\",\n\t            operator: \"<=\",\n\t            value: 100,\n", "          },\n\t          {\n\t            field: \"WinRate\",\n\t            operator: \">\",\n\t            value: 60,\n\t          },\n\t          {\n\t            field: \"AverageTradeDuration\",\n\t            operator: \"<\",\n\t            value: 60,\n", "          },\n\t          {\n\t            field: \"Duration\",\n\t            operator: \">\",\n\t            value: 259200,\n\t          },\n\t          {\n\t            field: \"TotalDaysTraded\",\n\t            operator: \">=\",\n\t            value: 3,\n", "          },\n\t        ],\n\t      },\n\t      {\n\t        none: [\n\t          {\n\t            field: \"AverageTradeDuration\",\n\t            operator: \"!=\",\n\t            value: 10,\n\t          },\n", "          {\n\t            field: \"Foo\",\n\t            operator: \"not in\",\n\t            value: [10, 11, 12],\n\t          },\n\t        ],\n\t      },\n\t    ],\n\t  },\n\t} as Rule;\n"]}
{"filename": "test/rulesets/valid1.json.ts", "chunked_list": ["import { Rule } from \"../../src\";\n\texport const valid1Json: Rule = {\n\t  conditions: {\n\t    any: [\n\t      {\n\t        all: [\n\t          {\n\t            field: \"WinRate\",\n\t            operator: \">\",\n\t            value: 60,\n", "          },\n\t          {\n\t            field: \"AverageTradeDuration\",\n\t            operator: \"<\",\n\t            value: 60,\n\t          },\n\t          {\n\t            field: \"Duration\",\n\t            operator: \">\",\n\t            value: 259200,\n", "          },\n\t          {\n\t            field: \"TotalDaysTraded\",\n\t            operator: \">=\",\n\t            value: 3,\n\t          },\n\t        ],\n\t      },\n\t      {\n\t        all: [\n", "          {\n\t            field: \"ProfitPercentage\",\n\t            operator: \">=\",\n\t            value: 10,\n\t          },\n\t        ],\n\t      },\n\t    ],\n\t  },\n\t};\n"]}
{"filename": "test/rulesets/valid4.json.ts", "chunked_list": ["import { Condition, Rule } from \"../../src\";\n\texport const valid4Json: Rule = {\n\t  conditions: [\n\t    {\n\t      any: [\n\t        {\n\t          all: [\n\t            {\n\t              field: \"CountryIso\",\n\t              operator: \"in\",\n", "              value: [\"GB\", \"FI\"],\n\t            },\n\t            {\n\t              field: \"Leverage\",\n\t              operator: \"<\",\n\t              value: 200,\n\t            },\n\t            {\n\t              field: \"Monetization\",\n\t              operator: \"==\",\n", "              value: \"Real\",\n\t            },\n\t          ],\n\t        },\n\t        {\n\t          field: \"Leverage\",\n\t          operator: \">=\",\n\t          value: 1000,\n\t        },\n\t      ],\n", "      result: 3,\n\t    },\n\t    {\n\t      all: [\n\t        {\n\t          field: \"Category\",\n\t          operator: \"==\",\n\t          value: \"Islamic\",\n\t        },\n\t      ],\n", "      result: 4,\n\t    },\n\t    {\n\t      foo: \"bar\",\n\t    } as Condition,\n\t  ],\n\t  default: 2,\n\t};\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from \"./types/rule\";\n\texport * from \"./types/error\";\n\texport { RulePilot } from \"./services/rule-pilot\";\n\texport { ValidationResult } from \"./services/validator\";\n"]}
{"filename": "src/types/rule.ts", "chunked_list": ["export type ConditionType = \"any\" | \"all\" | \"none\";\n\texport type Operator = \"==\" | \"!=\" | \">\" | \"<\" | \">=\" | \"<=\" | \"in\" | \"not in\";\n\texport interface Constraint {\n\t  field: string;\n\t  operator: Operator;\n\t  value:\n\t    | string\n\t    | number\n\t    | boolean\n\t    | object\n", "    | (string | number | boolean | object)[];\n\t}\n\texport interface Condition<R = any> {\n\t  any?: (Constraint | Condition<R>)[];\n\t  all?: (Constraint | Condition<R>)[];\n\t  none?: (Constraint | Condition<R>)[];\n\t  result?: R;\n\t}\n\texport interface Rule<R = any> {\n\t  conditions: Condition<R> | Condition<R>[];\n", "  default?: R;\n\t}\n"]}
{"filename": "src/types/error.ts", "chunked_list": ["import { ValidationResult } from \"../services/validator\";\n\texport class RuleError extends Error {\n\t  constructor(validationResult: ValidationResult) {\n\t    super(validationResult.error.message);\n\t    this.element = validationResult.error.element;\n\t  }\n\t  /** The name/type of the error. */\n\t  type: string = RuleError.name;\n\t  /** The element that caused the error. */\n\t  element: object;\n", "}\n"]}
{"filename": "src/services/evaluator.ts", "chunked_list": ["import { ObjectDiscovery } from \"./object-discovery\";\n\timport { Condition, Constraint, Rule } from \"../types/rule\";\n\texport class Evaluator {\n\t  private _objectDiscovery: ObjectDiscovery = new ObjectDiscovery();\n\t  /**\n\t   * Evaluates a rule against a set of criteria and returns the result.\n\t   * If the criteria is an array (indicating multiple criteria to test),\n\t   * the rule will be evaluated against each item in the array and\n\t   * an array of results will be returned.\n\t   *\n", "   * @param rule The rule to evaluate.\n\t   * @param criteria The criteria to evaluate the rule against.\n\t   */\n\t  evaluate(rule: Rule, criteria: object | object[]): boolean | any {\n\t    // Cater for the case where the conditions property is not an array.\n\t    const conditions =\n\t      rule.conditions instanceof Array ? rule.conditions : [rule.conditions];\n\t    if (criteria instanceof Array) {\n\t      const result = [];\n\t      for (const c of criteria) {\n", "        result.push(this.evaluateRule(conditions, c, rule?.default));\n\t      }\n\t      return result;\n\t    }\n\t    return this.evaluateRule(conditions, criteria, rule?.default);\n\t  }\n\t  /**\n\t   * Evaluates a rule against a set of criteria and returns the result.\n\t   * @param conditions The conditions to evaluate.\n\t   * @param criteria The criteria to evaluate the conditions against.\n", "   * @param defaultResult The default result to return if no conditions pass.\n\t   */\n\t  private evaluateRule(\n\t    conditions: Condition[],\n\t    criteria: object,\n\t    defaultResult?: any\n\t  ): boolean | any {\n\t    // We should evaluate all conditions and return the result\n\t    // of the first condition that passes.\n\t    for (const condition of conditions) {\n", "      const result = this.evaluateCondition(condition, criteria);\n\t      if (result) {\n\t        return condition?.result ?? true;\n\t      }\n\t    }\n\t    // If no conditions pass, we should return the default result of\n\t    // the rule or false if no default result is provided.\n\t    return defaultResult ?? false;\n\t  }\n\t  /**\n", "   * Evaluates a condition against a set of criteria and returns the result.\n\t   * Uses recursion to evaluate nested conditions.\n\t   * @param condition The condition to evaluate.\n\t   * @param criteria The criteria to evaluate the condition against.\n\t   */\n\t  private evaluateCondition(condition: Condition, criteria: object): boolean {\n\t    // The condition must have an 'any' or 'all' property.\n\t    const type = this._objectDiscovery.conditionType(condition);\n\t    if (!type) {\n\t      return false;\n", "    }\n\t    // If the type is 'all' or 'none', we should set the initial\n\t    // result to true, otherwise we should set it to false.\n\t    let result = [\"all\", \"none\"].includes(type);\n\t    // Check each node in the condition.\n\t    for (const node of condition[type]) {\n\t      let fn;\n\t      if (this._objectDiscovery.isCondition(node)) {\n\t        fn = \"evaluateCondition\";\n\t      }\n", "      if (this._objectDiscovery.isConstraint(node)) {\n\t        fn = \"checkConstraint\";\n\t      }\n\t      // Process the node\n\t      switch (type) {\n\t        case \"any\":\n\t          result = result || this[fn](node, criteria);\n\t          break;\n\t        case \"all\":\n\t          result = result && this[fn](node, criteria);\n", "          break;\n\t        case \"none\":\n\t          result = result && !this[fn](node, criteria);\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t  /**\n\t   * Checks a constraint against a set of criteria and returns true whenever the constraint passes.\n\t   * @param constraint The constraint to evaluate.\n", "   * @param criteria The criteria to evaluate the constraint with.\n\t   */\n\t  private checkConstraint(constraint: Constraint, criteria: object): boolean {\n\t    // If the value contains '.' we should assume it is a nested property\n\t    const criterion = constraint.field.includes(\".\")\n\t      ? this._objectDiscovery.resolveNestedProperty(constraint.field, criteria)\n\t      : criteria[constraint.field];\n\t    // If the criteria object does not have the field\n\t    // we are looking for, we should return false.\n\t    if (!criterion) {\n", "      return false;\n\t    }\n\t    switch (constraint.operator) {\n\t      case \"==\":\n\t        return criterion == constraint.value;\n\t      case \"!=\":\n\t        return criterion != constraint.value;\n\t      case \">\":\n\t        return criterion > constraint.value;\n\t      case \">=\":\n", "        return criterion >= constraint.value;\n\t      case \"<\":\n\t        return criterion < constraint.value;\n\t      case \"<=\":\n\t        return criterion <= constraint.value;\n\t      case \"in\":\n\t        return (\n\t          Array.isArray(constraint.value) &&\n\t          constraint.value.includes(criterion as never)\n\t        );\n", "      case \"not in\":\n\t        return (\n\t          !Array.isArray(constraint.value) ||\n\t          !constraint.value.includes(criterion as never)\n\t        );\n\t      default:\n\t        return false;\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/services/mutator.ts", "chunked_list": ["import { createHash } from \"crypto\";\n\timport { EventEmitter } from \"events\";\n\timport { Logger } from \"./logger\";\n\timport { ObjectDiscovery } from \"./object-discovery\";\n\texport class Mutator {\n\t  private _cache: Map<string, any> = new Map();\n\t  private _buffer: Map<string, boolean> = new Map();\n\t  private _mutations: Map<string, Function> = new Map();\n\t  private _objectDiscovery = new ObjectDiscovery();\n\t  private _eventEmitter = new EventEmitter();\n", "  /**\n\t   * Adds a mutation to the mutator instance.\n\t   * @param name The name of the mutation.\n\t   * @param mutation The mutation function.\n\t   */\n\t  add(name: string, mutation: Function): void {\n\t    this._mutations.set(name, mutation);\n\t  }\n\t  /**\n\t   * Removes a mutation to the mutator instance.\n", "   * Any cached mutation values for this mutation will be purged.\n\t   * @param name The name of the mutation.\n\t   */\n\t  remove(name: string): void {\n\t    this.clearCache(name);\n\t    this._mutations.delete(name);\n\t  }\n\t  /**\n\t   * Clears the mutator cache.\n\t   * The entire cache, or cache for a specific mutator, can be cleared\n", "   * by passing or omitting the mutator name as an argument.\n\t   * @param name The mutator name to clear the cache for.\n\t   */\n\t  clearCache(name?: string): void {\n\t    if (!name) {\n\t      this._cache.clear();\n\t      return;\n\t    }\n\t    for (const key of this._cache.keys()) {\n\t      if (key.startsWith(name)) {\n", "        this._cache.delete(key);\n\t      }\n\t    }\n\t  }\n\t  /**\n\t   * Mutates and returns a criteria object.\n\t   * @param criteria The criteria to mutate.\n\t   */\n\t  async mutate(criteria: object | object[]): Promise<object | object[]> {\n\t    // Handles checking the mutability of a criteria object\n", "    // If it is mutable it will be cloned, mutated and returned\n\t    const exec = async (criteria) => {\n\t      // If there are no mutations or the criteria does not contain\n\t      // any of the mutation keys, return the criteria as is.\n\t      if (!this._mutations.size || !this.hasMutations(criteria)) {\n\t        return criteria;\n\t      }\n\t      // Make a copy of the criteria.\n\t      const copy = { ...criteria };\n\t      // Apply the mutations to the copy and return it.\n", "      await this.applyMutations(copy);\n\t      return copy;\n\t    };\n\t    // If the criteria is an array, we want to apply the mutations\n\t    // to each item in the array in parallel.\n\t    if (criteria instanceof Array) {\n\t      return await Promise.all(\n\t        criteria.map(\n\t          (c) =>\n\t            new Promise(async (resolve) => {\n", "              resolve(await exec(c));\n\t            })\n\t        )\n\t      );\n\t    } else {\n\t      return await exec(criteria);\n\t    }\n\t  }\n\t  /**\n\t   * Checks if the criteria contains any mutate-able properties.\n", "   * @param criteria The criteria to check.\n\t   * @param result Whether a mutate-able property has been found.\n\t   * @param parentPath The parent path to the current property.\n\t   */\n\t  private hasMutations(\n\t    criteria: object,\n\t    result: boolean = false,\n\t    parentPath: string = \"\"\n\t  ): boolean {\n\t    // If we have already found a mutation, we can stop.\n", "    if (result) return true;\n\t    for (const key of Object.keys(criteria)) {\n\t      if (result) return true;\n\t      // Prepare dotted path to the current property.\n\t      const path = parentPath ? `${parentPath}.${key}` : key;\n\t      // If the value is an object, we should recurse.\n\t      result = this._objectDiscovery.isObject(criteria[key])\n\t        ? result || this.hasMutations(criteria[key], result, path)\n\t        : result || this._mutations.has(path);\n\t    }\n", "    return result;\n\t  }\n\t  /**\n\t   * Recursively applies mutations to the criteria.\n\t   * @param criteria The criteria to mutate.\n\t   * @param parentPath The parent path to the current property.\n\t   */\n\t  private async applyMutations(\n\t    criteria: object,\n\t    parentPath: string = \"\"\n", "  ): Promise<void> {\n\t    const promises = Object.keys(criteria).map(\n\t      async (key) =>\n\t        new Promise(async (resolve) => {\n\t          // Prepare dotted path to the current property.\n\t          const path = parentPath ? `${parentPath}.${key}` : key;\n\t          if (this._objectDiscovery.isObject(criteria[key])) {\n\t            await this.applyMutations(criteria[key], path);\n\t          }\n\t          if (this._mutations.has(path)) {\n", "            criteria[key] = await this.execMutation(key, criteria, path);\n\t          }\n\t          resolve(criteria[key]);\n\t        })\n\t    );\n\t    await Promise.all(promises);\n\t  }\n\t  /**\n\t   * Executes a mutation.\n\t   * Defers duplicate executions to the same object from a memory cache.\n", "   * @param criteriaProp The criteria property to execute the mutation on.\n\t   * @param criteria The criteria to execute the mutation with.\n\t   * @param mutationKey The key of the mutation to execute.\n\t   */\n\t  private async execMutation(\n\t    criteriaProp: string,\n\t    criteria: unknown,\n\t    mutationKey: string\n\t  ): Promise<any> {\n\t    const value = criteria[criteriaProp];\n", "    // Create a cache key\n\t    const cacheKey = `${mutationKey}${createHash(\"md5\")\n\t      .update(value.toString())\n\t      .digest(\"hex\")}`;\n\t    // If the mutation has already been executed, return the cached result.\n\t    if (this._cache.has(cacheKey)) {\n\t      Logger.debug(`Cache hit on \"${mutationKey}\" with param \"${value}\"`);\n\t      return this._cache.get(cacheKey);\n\t    }\n\t    // If the mutation is already in progress, wait for it to finish.\n", "    if (this._buffer.get(cacheKey)) {\n\t      return await new Promise((resolve) => {\n\t        Logger.debug(\n\t          `Waiting on mutation \"${mutationKey}\" with param \"${value}\"`\n\t        );\n\t        this._eventEmitter.once(`mutation:${cacheKey}`, (result) => {\n\t          Logger.debug(\n\t            `Resolved mutation \"${mutationKey}\" with param \"${value}\"`\n\t          );\n\t          resolve(result);\n", "        });\n\t      });\n\t    }\n\t    // Set the buffer to true to indicate that the mutation is in progress.\n\t    // This prevents duplicate executions of the same mutation.\n\t    this._buffer.set(cacheKey, true);\n\t    // Execute the mutation\n\t    Logger.debug(`Running mutation \"${mutationKey}\" with param \"${value}\"`);\n\t    const mutation = this._mutations.get(mutationKey);\n\t    const result = await mutation(value, criteria);\n", "    // Cache the result and release the buffer to false.\n\t    this._cache.set(cacheKey, result);\n\t    this._buffer.set(cacheKey, false);\n\t    // Emit an event to indicate that the mutation has been executed.\n\t    this._eventEmitter.emit(`mutation:${cacheKey}`, result);\n\t    return result;\n\t  }\n\t}\n"]}
{"filename": "src/services/builder.ts", "chunked_list": ["import {\n\t  Rule,\n\t  Operator,\n\t  Condition,\n\t  Constraint,\n\t  ConditionType,\n\t} from \"../types/rule\";\n\timport { Validator } from \"./validator\";\n\timport { RuleError } from \"../types/error\";\n\texport class Builder {\n", "  constructor(validator: Validator) {\n\t    this.validator = validator;\n\t  }\n\t  /** Stores to rule being constructed */\n\t  private rule: Rule = { conditions: [] };\n\t  /** Holds a reference to the Validator class */\n\t  private validator: Validator;\n\t  /**\n\t   * Adds a node (in the root) to the rule being constructed\n\t   * @param node The node to add to the rule\n", "   */\n\t  add(node: Condition): Builder {\n\t    (this.rule.conditions as Condition[]).push(node);\n\t    return this;\n\t  }\n\t  /**\n\t   * Sets the default value of the rule being constructed\n\t   * @param value The default value of the rule\n\t   */\n\t  default(value: Rule[\"default\"]): Builder {\n", "    this.rule.default = value;\n\t    return this;\n\t  }\n\t  /**\n\t   * Builds the rule being and returns it\n\t   * @param validate Whether to validate the rule before returning it\n\t   * @throws Error if validation is enabled and the rule is invalid\n\t   */\n\t  build(validate?: boolean): Rule {\n\t    if (!validate) {\n", "      return this.rule;\n\t    }\n\t    const validationResult = this.validator.validate(this.rule);\n\t    if (validationResult.isValid) {\n\t      return this.rule;\n\t    }\n\t    throw new RuleError(validationResult);\n\t  }\n\t  /**\n\t   * Creates a new condition node\n", "   * @param type The type of condition\n\t   * @param nodes Any child nodes of the condition\n\t   * @param result The result of the condition node (for granular rules)\n\t   */\n\t  condition(\n\t    type: ConditionType,\n\t    nodes: Condition[ConditionType],\n\t    result?: Condition[\"result\"]\n\t  ): Condition {\n\t    return {\n", "      [type]: nodes,\n\t      ...(result ? { result } : {}),\n\t    };\n\t  }\n\t  /**\n\t   * Creates a new constraint node\n\t   * @param field The field to apply the constraint to\n\t   * @param operator The operator to apply to the field\n\t   * @param value The value to compare the field to\n\t   */\n", "  constraint(\n\t    field: string,\n\t    operator: Operator,\n\t    value: Constraint[\"value\"]\n\t  ): Constraint {\n\t    return {\n\t      field,\n\t      operator,\n\t      value,\n\t    };\n", "  }\n\t}\n"]}
{"filename": "src/services/logger.ts", "chunked_list": ["export class Logger {\n\t  static debug(message: string): void {\n\t    if (!process.env.DEBUG) return;\n\t    console.debug(message);\n\t  }\n\t}\n"]}
{"filename": "src/services/object-discovery.ts", "chunked_list": ["import { Condition, ConditionType, Constraint } from \"../types/rule\";\n\texport class ObjectDiscovery {\n\t  /**\n\t   * Returns the type of condition passed to the function.\n\t   * @param condition The condition to check.\n\t   */\n\t  conditionType(condition: Condition): ConditionType | null {\n\t    if (\"any\" in condition) return \"any\";\n\t    if (\"all\" in condition) return \"all\";\n\t    if (\"none\" in condition) return \"none\";\n", "    return null;\n\t  }\n\t  /**\n\t   * Checks an object to see if it is a valid condition.\n\t   * @param obj The object to check.\n\t   */\n\t  isCondition(obj: unknown): obj is Condition {\n\t    return !this.isObject(obj)\n\t      ? false\n\t      : \"any\" in obj || \"all\" in obj || \"none\" in obj;\n", "  }\n\t  /**\n\t   * Checks an object to see if it is a valid constraint.\n\t   * @param obj The object to check.\n\t   */\n\t  isConstraint(obj: unknown): obj is Constraint {\n\t    return !this.isObject(obj)\n\t      ? false\n\t      : \"field\" in obj && \"operator\" in obj && \"value\" in obj;\n\t  }\n", "  /**\n\t   * Returns true if the passed parameter is an object.\n\t   * @param obj The item to test.\n\t   */\n\t  isObject(obj: unknown): obj is object {\n\t    return \"object\" === typeof obj && !Array.isArray(obj) && obj !== null;\n\t  }\n\t  /**\n\t   * Resolves a nested property from a sting as an object path.\n\t   * @param path The path to resolve.\n", "   * @param obj The object to resolve the path against.\n\t   */\n\t  resolveNestedProperty(path, obj): any {\n\t    return path.split(\".\").reduce((prev, curr) => prev?.[curr], obj);\n\t  }\n\t}\n"]}
{"filename": "src/services/rule-pilot.ts", "chunked_list": ["import { Builder } from \"./builder\";\n\timport { Mutator } from \"./mutator\";\n\timport { Evaluator } from \"./evaluator\";\n\timport { ValidationResult, Validator } from \"./validator\";\n\timport { Rule } from \"../types/rule\";\n\timport { RuleError } from \"../types/error\";\n\texport class RulePilot {\n\t  private static _rulePilot = new RulePilot();\n\t  private _mutator: Mutator = new Mutator();\n\t  private _validator: Validator = new Validator();\n", "  private _evaluator: Evaluator = new Evaluator();\n\t  /**\n\t   * Returns a rule builder class instance.\n\t   * Allows for the construction of rules using a fluent interface.\n\t   */\n\t  builder(): Builder {\n\t    return new Builder(this._validator);\n\t  }\n\t  /**\n\t   * Adds a mutation to the rule pilot instance.\n", "   * Mutations allow for the modification of the criteria before\n\t   * it is evaluated against a rule.\n\t   *\n\t   * @param name The name of the mutation.\n\t   * @param mutation The mutation function.\n\t   */\n\t  addMutation(name: string, mutation: Function): RulePilot {\n\t    this._mutator.add(name, mutation);\n\t    return this;\n\t  }\n", "  /**\n\t   * Removes a mutation to the rule pilot instance.\n\t   * Any cached mutation values for this mutation will be purged.\n\t   *\n\t   * @param name The name of the mutation.\n\t   */\n\t  removeMutation(name: string): RulePilot {\n\t    this._mutator.remove(name);\n\t    return this;\n\t  }\n", "  /**\n\t   * Clears the mutator cache.\n\t   * The entire cache, or cache for a specific mutator, can be cleared\n\t   * by passing or omitting the mutator name as an argument.\n\t   *\n\t   * @param name The mutator name to clear the cache for.\n\t   */\n\t  clearMutationCache(name?: string): RulePilot {\n\t    this._mutator.clearCache(name);\n\t    return this;\n", "  }\n\t  /**\n\t   * Evaluates a rule against a set of criteria and returns the result.\n\t   * If the criteria is an array (indicating multiple criteria to test),\n\t   * the rule will be evaluated against each item in the array and\n\t   * an array of results will be returned.\n\t   *\n\t   * @param rule The rule to evaluate.\n\t   * @param criteria The criteria to evaluate the rule against.\n\t   * @param trustRule Set true to avoid validating the rule before evaluating it (faster).\n", "   * @throws Error if the rule is invalid.\n\t   */\n\t  async evaluate<T>(\n\t    rule: Rule,\n\t    criteria: object | object[],\n\t    trustRule = false\n\t  ): Promise<T> {\n\t    // Before we evaluate the rule, we should validate it.\n\t    // If `trustRuleset` is set to true, we will skip validation.\n\t    const validationResult = !trustRule && this.validate(rule);\n", "    if (!trustRule && !validationResult.isValid) {\n\t      throw new RuleError(validationResult);\n\t    }\n\t    return this._evaluator.evaluate(rule, await this._mutator.mutate(criteria));\n\t  }\n\t  /**\n\t   * Takes in a rule as a parameter and returns a ValidationResult\n\t   * indicating whether the rule is valid or not.\n\t   *\n\t   * Invalid rules will contain an error property which contains a message and the element\n", "   * that caused the validation to fail.\n\t   *\n\t   * @param rule The rule to validate.\n\t   */\n\t  validate(rule: Rule): ValidationResult {\n\t    return this._validator.validate(rule);\n\t  }\n\t  /**\n\t   * Returns a rule builder class instance.\n\t   * Allows for the construction of rules using a fluent interface.\n", "   */\n\t  static builder(): Builder {\n\t    return this._rulePilot.builder();\n\t  }\n\t  /**\n\t   * Evaluates a rule against a set of criteria and returns the result.\n\t   * If the criteria is an array (indicating multiple criteria to test),\n\t   * the rule will be evaluated against each item in the array and\n\t   * an array of results will be returned.\n\t   *\n", "   * @param rule The rule to evaluate.\n\t   * @param criteria The criteria to evaluate the rule against.\n\t   * @param trustRule Set true to avoid validating the rule before evaluating it (faster).\n\t   * @throws Error if the rule is invalid.\n\t   */\n\t  static async evaluate<T>(\n\t    rule: Rule,\n\t    criteria: object | object[],\n\t    trustRule = false\n\t  ): Promise<T> {\n", "    return RulePilot._rulePilot.evaluate<T>(rule, criteria, trustRule);\n\t  }\n\t  /**\n\t   * Takes in a rule as a parameter and returns a ValidationResult\n\t   * indicating whether the rule is valid or not.\n\t   *\n\t   * Invalid rules will contain an error property which contains a message and the element\n\t   * that caused the validation to fail.\n\t   *\n\t   * @param rule The rule to validate.\n", "   */\n\t  static validate(rule: Rule): ValidationResult {\n\t    return RulePilot._rulePilot.validate(rule);\n\t  }\n\t  /**\n\t   * Adds a mutation.\n\t   *\n\t   * Mutations allow for the modification of the criteria before\n\t   * it is evaluated against a rule.\n\t   *\n", "   * @param name The name of the mutation.\n\t   * @param mutation The mutation function.\n\t   */\n\t  static addMutation(name: string, mutation: Function): RulePilot {\n\t    return RulePilot._rulePilot.addMutation(name, mutation);\n\t  }\n\t  /**\n\t   * Removes a mutation to the rule pilot instance.\n\t   * Any cached mutation values for this mutation will be purged.\n\t   *\n", "   * @param name The name of the mutation.\n\t   */\n\t  static removeMutation(name: string): RulePilot {\n\t    return RulePilot._rulePilot.removeMutation(name);\n\t  }\n\t  /**\n\t   * Clears the mutator cache.\n\t   * The entire cache, or cache for a specific mutator, can be cleared\n\t   * by passing or omitting the mutator name as an argument.\n\t   *\n", "   * @param name The mutator name to clear the cache for.\n\t   */\n\t  static clearMutationCache(name?: string): RulePilot {\n\t    return RulePilot._rulePilot.clearMutationCache(name);\n\t  }\n\t}\n"]}
{"filename": "src/services/validator.ts", "chunked_list": ["import { ObjectDiscovery } from \"./object-discovery\";\n\timport { Condition, Constraint, Operator, Rule } from \"../types/rule\";\n\texport interface ValidationResult {\n\t  isValid: boolean;\n\t  error?: {\n\t    message: string;\n\t    element: object;\n\t  };\n\t}\n\texport class Validator {\n", "  private objectDiscovery: ObjectDiscovery = new ObjectDiscovery();\n\t  /**\n\t   * Takes in a rule as a parameter and returns a boolean indicating whether the rule is valid or not.\n\t   * @param rule The rule to validate.\n\t   */\n\t  validate(rule: Rule): ValidationResult {\n\t    // Assume the rule is valid.\n\t    let result: ValidationResult = { isValid: true };\n\t    // Check the rule is a valid JSON\n\t    if (!this.objectDiscovery.isObject(rule)) {\n", "      return {\n\t        isValid: false,\n\t        error: {\n\t          message: \"The rule must be a valid JSON object.\",\n\t          element: rule,\n\t        },\n\t      };\n\t    }\n\t    // Cater for the case where the conditions property is not an array.\n\t    const conditions =\n", "      rule.conditions instanceof Array ? rule.conditions : [rule.conditions];\n\t    // Validate the 'conditions' property.\n\t    if (\n\t      conditions.length === 0 ||\n\t      (this.objectDiscovery.isObject(conditions[0]) &&\n\t        !Object.keys(conditions[0]).length)\n\t    ) {\n\t      return {\n\t        isValid: false,\n\t        error: {\n", "          message:\n\t            \"The conditions property must contain at least one condition.\",\n\t          element: rule,\n\t        },\n\t      };\n\t    }\n\t    // Validate each condition in the rule.\n\t    for (const condition of conditions) {\n\t      const subResult = this.validateCondition(condition);\n\t      result.isValid = result.isValid && subResult.isValid;\n", "      result.error = result?.error ?? subResult?.error;\n\t    }\n\t    return result;\n\t  }\n\t  /** ml/l.k,\n\t   * Evaluates a condition to ensure it is syntactically correct.\n\t   * @param condition The condition to validate.\n\t   * @param depth The current recursion depth\n\t   */\n\t  private validateCondition(\n", "    condition: Condition,\n\t    depth: number = 0\n\t  ): ValidationResult {\n\t    // Check to see if the condition is valid.\n\t    let result = this.isValidCondition(condition);\n\t    if (!result.isValid) {\n\t      return result;\n\t    }\n\t    // Set the type of condition.\n\t    const type = this.objectDiscovery.conditionType(condition);\n", "    // Check if the condition is iterable\n\t    if(!Array.isArray(condition[type])) {\n\t      return {\n\t        isValid: false,\n\t        error: {\n\t          message: `The condition '${type}' should be iterable.`,\n\t          element: condition,\n\t        },\n\t      };\n\t    }\n", "    // Validate each item in the condition.\n\t    for (const node of condition[type]) {\n\t      const isCondition = this.objectDiscovery.isCondition(node);\n\t      if (isCondition) {\n\t        const subResult = this.validateCondition(node as Condition, depth + 1);\n\t        result.isValid = result.isValid && subResult.isValid;\n\t        result.error = result?.error ?? subResult?.error;\n\t      }\n\t      const isConstraint = this.objectDiscovery.isConstraint(node);\n\t      if (isConstraint) {\n", "        const subResult = this.validateConstraint(node as Constraint);\n\t        result.isValid = result.isValid && subResult.isValid;\n\t        result.error = result?.error ?? subResult?.error;\n\t      }\n\t      if (!isConstraint && !isCondition) {\n\t        return {\n\t          isValid: false,\n\t          error: {\n\t            message: \"Each node should be a condition or constraint.\",\n\t            element: node,\n", "          },\n\t        };\n\t      }\n\t      // Result is only valid on the root condition.\n\t      if (depth > 0 && \"result\" in condition) {\n\t        return {\n\t          isValid: false,\n\t          error: {\n\t            message: 'Nested conditions cannot have a property \"result\".',\n\t            element: node,\n", "          },\n\t        };\n\t      }\n\t      // If any part fails validation there is no point to continue.\n\t      if (!result.isValid) {\n\t        break;\n\t      }\n\t    }\n\t    return result;\n\t  }\n", "  /**\n\t   * Checks a constraint to ensure it is syntactically correct.\n\t   * @param constraint The constraint to validate.\n\t   */\n\t  private validateConstraint(constraint: Constraint): ValidationResult {\n\t    if (\"string\" !== typeof constraint.field) {\n\t      return {\n\t        isValid: false,\n\t        error: {\n\t          message: 'Constraint \"field\" must be of type string.',\n", "          element: constraint,\n\t        },\n\t      };\n\t    }\n\t    const operators = [\"==\", \"!=\", \">\", \"<\", \">=\", \"<=\", \"in\", \"not in\"];\n\t    if (!operators.includes(constraint.operator as Operator)) {\n\t      return {\n\t        isValid: false,\n\t        error: {\n\t          message: 'Constraint \"operator\" has invalid type.',\n", "          element: constraint,\n\t        },\n\t      };\n\t    }\n\t    // We must check that the value is an array if the operator is 'in' or 'not in'.\n\t    if (\n\t      [\"in\", \"not in\"].includes(constraint.operator) &&\n\t      !Array.isArray(constraint.value)\n\t    ) {\n\t      return {\n", "        isValid: false,\n\t        error: {\n\t          message:\n\t            'Constraint \"value\" must be an array if the \"operator\" is \"in\" or \"not in\"',\n\t          element: constraint,\n\t        },\n\t      };\n\t    }\n\t    return { isValid: true };\n\t  }\n", "  /**\n\t   * Checks an object to see if it is a valid condition.\n\t   * @param obj The object to check.\n\t   */\n\t  private isValidCondition(obj: any): ValidationResult {\n\t    if (!this.objectDiscovery.isCondition(obj)) {\n\t      return {\n\t        isValid: false,\n\t        error: {\n\t          message: \"Invalid condition structure.\",\n", "          element: obj,\n\t        },\n\t      };\n\t    }\n\t    const isAny = \"any\" in obj;\n\t    const isAll = \"all\" in obj;\n\t    const isNone = \"none\" in obj;\n\t    // A valid condition must have an 'any', 'all', or 'none' property,\n\t    // but cannot have more than one.\n\t    if ((isAny && isAll) || (isAny && isNone) || (isAll && isNone)) {\n", "      return {\n\t        isValid: false,\n\t        error: {\n\t          message:\n\t            'A condition cannot have more than one \"any\", \"all\", or \"none\" property.',\n\t          element: obj,\n\t        },\n\t      };\n\t    }\n\t    return { isValid: true };\n", "  }\n\t}\n"]}
