{"filename": "utils.d.ts", "chunked_list": ["import { Locator } from 'testcafe';\n\texport function getElement(alias: string): Promise<Locator>;\n\texport function getValue(alias: string): any;\n\texport function getConditionWait(condition: string): Function;\n\texport function getValueWait(condition: string): Function;\n"]}
{"filename": "test/utilsImport.spec.ts", "chunked_list": ["import { getValue, getValueWait, getConditionWait, getElement } from '../utils.js'\n\timport { test, expect } from 'vitest';\n\ttest.each([\n\t    getValue,\n\t    getValueWait,\n\t    getConditionWait,\n\t    getElement\n\t])('util function %p', (fn) => {\n\t    expect(fn).toBeInstanceOf(Function);\n\t});\n"]}
{"filename": "test-e2e/webui.ts", "chunked_list": ["import Memory from './memory';\n\timport App from './page_object';\n\timport localServer from './support/server';\n\tconst common = {\n\t    paths: ['test-e2e/features/*.feature'],\n\t    require: ['test-e2e/step-definitions/*.ts', 'src/*.ts'],\n\t    browser: {\n\t        logLevel: 'warn',\n\t        timeout: {\n\t            page: 5000\n", "        },\n\t        capabilities: {\n\t            browserName: 'chrome:headless'\n\t        },\n\t        reuseSession: true\n\t    },\n\t    format: [\n\t        '@qavajs/console-formatter',\n\t        '@qavajs/html-formatter:test-e2e/report.html',\n\t        '@qavajs/xunit-formatter:test-e2e/report.xml'\n", "    ],\n\t    memory: new Memory(),\n\t    pageObject: new App(),\n\t    parallel: 3,\n\t    publishQuiet: true,\n\t    retry: 1,\n\t    service: [localServer],\n\t    screenshot: ['onFail'],\n\t    defaultTimeout: 20000\n\t}\n", "export default common;\n\texport const debug = {\n\t    ...common,\n\t    retry: 0,\n\t    tags: '@debug',\n\t    browser: {\n\t        logLevel: 'warn',\n\t        timeout: {\n\t            page: 5000\n\t        },\n", "        capabilities: {\n\t            browserName: 'chrome'\n\t        },\n\t        reuseSession: true\n\t    },\n\t    parallel: 1\n\t}\n"]}
{"filename": "test-e2e/page_object/index.ts", "chunked_list": ["import { $, $$, Component } from '@qavajs/po-testcafe';\n\texport default class App {\n\t    SimpleTextElement = $('#textValue');\n\t    SimpleTextListItems = $$('#textValueList li');\n\t    SimpleTextInput = $('#textInput');\n\t    FileInput = $('#fileInput');\n\t    Action = $('#action');\n\t    AlertButton = $('#confirm');\n\t    PromptButton = $('#prompt');\n\t    Button = $('#button');\n", "    ButtonHover = $('#buttonHover');\n\t    Input = $('#input');\n\t    Select = $('#select');\n\t    Buttons = $$('.button');\n\t    FrameElement = $('#frameElement');\n\t    NewTabLink = $('#newTabLink');\n\t    PresentElement = $('#present');\n\t    DetachElement = $('#detach');\n\t    VisibleElement = $('#visible');\n\t    HiddenElement = $('#hidden');\n", "    Loading = $('#loading');\n\t    LoadingInput = $('#loadingInput');\n\t    WaitCollection = $$('#waitCollection > div');\n\t    PressCounter = $('#pressCounter');\n\t    Users = $$('#users > li');\n\t    OverflowContainer = $('#overflowContainer');\n\t    IgnoreHierarchyComponent = $(new IgnoreHierarchyComponent('#ignoreHierarchyComponent'));\n\t    ComponentWithoutSelector = $(new ComponentWithoutSelector());\n\t    KeyDump = $('#keywordevent');\n\t    Cookie = $('#cookie');\n", "    LocalStorage = $('#localStorage');\n\t    SessionStorage = $('#sessionStorage');\n\t}\n\tclass IgnoreHierarchyComponent extends Component {\n\t    Input = $('#input', { ignoreHierarchy: true });\n\t}\n\tclass ComponentWithoutSelector {\n\t    Input = $('#input');\n\t}\n"]}
{"filename": "test-e2e/step-definitions/index.ts", "chunked_list": ["import { Then } from '@cucumber/cucumber';\n\timport memory from '@qavajs/memory';\n\timport { expect } from 'chai';\n\timport * as testcafe from 'testcafe';\n\tdeclare global {\n\t    var t: TestController;\n\t    var testcafe: TestCafe;\n\t    var runner: Runner;\n\t    var taskPromise: any;\n\t    var config: any;\n", "}\n\tThen('I expect {string} memory value to be equal {string}', async function(actual, expected) {\n\t    const actualValue = memory.getValue(actual);\n\t    const expectedValue = memory.getValue(expected);\n\t    expect(expectedValue).to.eql(actualValue);\n\t});\n"]}
{"filename": "test-e2e/support/server.ts", "chunked_list": ["// @ts-ignore\n\timport express, { Express } from 'express';\n\timport { createServer } from 'http';\n\tclass Service {\n\t    httpServer: any;\n\t    before() {\n\t        const app: Express = express();\n\t        const port = 3000;\n\t        app.use(express.static('./test-e2e/apps'))\n\t        this.httpServer = createServer(app);\n", "        this.httpServer.listen(port);\n\t    };\n\t    after() {\n\t        this.httpServer.close();\n\t    }\n\t}\n\texport default new Service();\n"]}
{"filename": "test-e2e/memory/index.ts", "chunked_list": ["import { resolve } from 'path';\n\tconst file = (path: string) => `file://${path}`\n\texport default class Memory {\n\t    valuesPage = file(resolve('./test-e2e/apps/values.html'));\n\t    actionsPage = file(resolve('./test-e2e/apps/actions.html'));\n\t    framePage = file(resolve('./test-e2e/apps/frame.html'));\n\t    waitsPage = file(resolve('./test-e2e/apps/waits.html'));\n\t    mockPage = file(resolve('./test-e2e/apps/mock.html'));\n\t    storagePage = file(resolve('./test-e2e/apps/storage.html'));\n\t    array = (...args: Array<any>) => args;\n", "    // @ts-ignore\n\t    setInputValue = () => document.querySelector('#input').value = 'some value';\n\t    // @ts-ignore\n\t    getActionInnerText = () => document.querySelector(\"#action\").innerText;\n\t    // @ts-ignore\n\t    clickJS = () => target().click();\n\t    // @ts-ignore\n\t    getInnerText = () => target().innerText;\n\t    userFromMemory = 'Mock 3';\n\t    users = JSON.stringify([\n", "        {\"name\": \"Memory Mock 1\"},\n\t        {\"name\": \"Memory Mock 2\"},\n\t        {\"name\": \"Memory Mock 3\"}\n\t    ]);\n\t    uploadFile = resolve('./test-e2e/apps/actions.html');\n\t    button2 = 'Button2';\n\t    userInterceptionPredicate = (request: any) => request.url.includes('users');\n\t}\n"]}
{"filename": "src/defaultTimeouts.ts", "chunked_list": ["export default {\n\t    present: 10000,\n\t    visible: 10000,\n\t    page: 10000\n\t}\n"]}
{"filename": "src/transformers.ts", "chunked_list": ["import { conditionWait, conditionWaitExtractRegexp } from './conditionWait';\n\timport { valueWait, valueWaitExtractRegexp } from './valueWait';\n\timport { po } from '@qavajs/po-testcafe';\n\timport memory from '@qavajs/memory';\n\timport { Selector } from 'testcafe';\n\texport function getValue(alias: string): any {\n\t    return memory.getValue(alias)\n\t}\n\texport async function getElement(alias: string): Promise<Selector> {\n\t    return po.getElement(await memory.getValue(alias))\n", "}\n\texport function getConditionWait(condition: string): Function {\n\t    const match = condition.match(conditionWaitExtractRegexp) as RegExpMatchArray;\n\t    if (!match) throw new Error(`${condition} wait is not implemented`);\n\t    const [ _, reverse, validation ] = match;\n\t    return async function (element: Selector, timeout: number) {\n\t        await conditionWait(element, validation, timeout, Boolean(reverse))\n\t    }\n\t}\n\texport function getValueWait(condition: string): Function {\n", "    const match = condition.match(valueWaitExtractRegexp) as RegExpMatchArray;\n\t    if (!match) throw new Error(`${condition} wait is not implemented`);\n\t    const [ _, reverse, validation ] = match;\n\t    return async function (valueFn: ClientFunction, expected: any, timeout: number) {\n\t        await valueWait(valueFn, expected, validation, timeout, Boolean(reverse))\n\t    }\n\t}\n"]}
{"filename": "src/hooks.ts", "chunked_list": ["import { After, AfterStep, AfterAll, Before, BeforeStep, BeforeAll } from '@cucumber/cucumber';\n\timport defaultTimeouts from './defaultTimeouts';\n\timport { po } from '@qavajs/po-testcafe';\n\timport { saveScreenshotAfterStep, saveScreenshotBeforeStep, takeScreenshot } from './utils/utils';\n\timport createTestCafe from 'testcafe';\n\timport { join } from 'path';\n\tdeclare global {\n\t    var t: TestController;\n\t    var testcafe: TestCafe;\n\t    var runner: Runner;\n", "    var taskPromise: any;\n\t    var config: any;\n\t}\n\tBeforeAll(async function (){\n\t    global.testcafe = await createTestCafe('localhost');\n\t})\n\tBefore(async function () {\n\t    const driverConfig = config.browser ?? config.driver;\n\t    driverConfig.timeout = {\n\t        ...defaultTimeouts,\n", "        ...driverConfig.timeout\n\t    }\n\t    global.config.driverConfig = driverConfig;\n\t    if (!global.t || !config.driverConfig.reuseSession) {\n\t        global.runner = await testcafe.createRunner();\n\t        global.taskPromise = global.runner\n\t            .src(join(__dirname, 'testController/bootstrap.{ts,js}'))\n\t            .browsers([config.driverConfig.capabilities.browserName])\n\t            .run({\n\t                nativeAutomation: config.driverConfig.capabilities.nativeAutomation ?? false\n", "            });\n\t        await new Promise((resolve) => {\n\t            const interval = setInterval(() => {\n\t                if (global.t) {\n\t                    clearInterval(interval)\n\t                    resolve(t);\n\t                }\n\t            }, 500)\n\t        });\n\t    }\n", "    po.init({timeout: config.driverConfig.timeout.present});\n\t    po.register(config.pageObject);\n\t    this.log(`browser instance started:\\n${JSON.stringify(config.driverConfig, null, 2)}`);\n\t});\n\tBeforeStep(async function () {\n\t    if (saveScreenshotBeforeStep(config)) {\n\t        try {\n\t            this.attach(await takeScreenshot(), 'image/png');\n\t        } catch (err) {\n\t            console.warn(err)\n", "        }\n\t    }\n\t});\n\tAfterStep(async function (step) {\n\t    try {\n\t        if (saveScreenshotAfterStep(config, step)) {\n\t            this.attach(await takeScreenshot(), 'image/png');\n\t        }\n\t    } catch (err) {\n\t        console.warn(err)\n", "    }\n\t});\n\tAfter(async function (scenario) {\n\t    if (global.config.driverConfig.reuseSession) {\n\t        let close = true;\n\t        while (close) {\n\t            try {\n\t                await t.closeWindow();\n\t            } catch (err) {\n\t                close = false\n", "            }\n\t        }\n\t    }\n\t    if (global.t && !global.config.driverConfig.reuseSession) {\n\t        await global.taskPromise.cancel();\n\t        await global.runner.stop();\n\t        // @ts-ignore\n\t        global.t = null;\n\t        // @ts-ignore\n\t        global.runner = null;\n", "        // @ts-ignore\n\t        global.taskPromise = null;\n\t    }\n\t});\n\tAfterAll(async function () {\n\t    await global.testcafe.close();\n\t});\n"]}
{"filename": "src/conditionWait.ts", "chunked_list": ["import { Selector } from 'testcafe';\n\texport const conditionValidations = {\n\t    PRESENT: 'present',\n\t    // CLICKABLE: 'clickable',\n\t    VISIBLE: 'visible',\n\t    INVISIBLE: 'invisible',\n\t    IN_VIEWPORT: 'in viewport',\n\t    // ENABLED: 'enabled',\n\t    // DISABLED: 'disabled'\n\t}\n", "const notClause = '(not )?';\n\tconst toBeClause = 'to (?:be )?';\n\tconst validationClause = `(${Object.values(conditionValidations).join('|')})`;\n\texport const conditionWaitExtractRegexp = new RegExp(`^${notClause}${toBeClause}${validationClause}$`);\n\texport const conditionWaitRegexp = new RegExp(`(${notClause}${toBeClause}${validationClause})`);\n\tconst executeWait = (expect: Assertion<any>, reverse: boolean, timeout: number, timeoutMsg: string) => {\n\t    return reverse\n\t        ? expect.eql(0, timeoutMsg, { timeout })\n\t        : expect.gt(0, timeoutMsg, { timeout });\n\t}\n", "const waits = {\n\t    [conditionValidations.PRESENT]: (\n\t        element: Selector,\n\t        reverse: boolean,\n\t        timeout: number,\n\t        timeoutMsg: string\n\t    ) => {\n\t        const expect = t.expect(element.with({ boundTestRun: t }).count);\n\t        return executeWait(expect, reverse, timeout, timeoutMsg);\n\t    },\n", "    [conditionValidations.VISIBLE]: (\n\t        element: Selector,\n\t        reverse: boolean,\n\t        timeout: number,\n\t        timeoutMsg: string\n\t    ) => {\n\t        const expect = t.expect(element.filterVisible().with({ boundTestRun: t }).count)\n\t        return executeWait(expect, reverse, timeout, timeoutMsg);\n\t    },\n\t    [conditionValidations.INVISIBLE]: (\n", "        element: Selector,\n\t        reverse: boolean,\n\t        timeout: number,\n\t        timeoutMsg: string\n\t    ) => {\n\t        const expect = t.expect(element.filterHidden().with({ boundTestRun: t }).count)\n\t        return executeWait(expect, reverse, timeout, timeoutMsg);\n\t    },\n\t}\n\t/**\n", " * Wait for condition\n\t * @param {Selector} element - element\n\t * @param {string} validationType - validation to perform\n\t * @param {number} [timeout] - timeout to wait\n\t * @param {boolean} [reverse] - negate flag\n\t * @return {Promise<void>}\n\t */\n\texport async function conditionWait(\n\t    element: Selector,\n\t    validationType: string,\n", "    timeout: number = 10000,\n\t    reverse: boolean = false\n\t) {\n\t    const timeoutMsg: string = `Element is${reverse ? '' : ' not'} ${validationType}`;\n\t    const waitFn = waits[validationType];\n\t    await waitFn(element, reverse, timeout, timeoutMsg);\n\t}\n"]}
{"filename": "src/actions.ts", "chunked_list": ["import { When } from '@cucumber/cucumber';\n\timport { getValue, getElement } from './transformers';\n\timport { ClientFunction, Selector } from 'testcafe';\n\timport {parseCoords} from './utils/utils';\n\t/**\n\t * Opens provided url\n\t * @param {string} url - url to navigate\n\t * @example I open 'https://google.com'\n\t */\n\tWhen('I open {string} url', async function (url: string) {\n", "    const urlValue = await getValue(url);\n\t    await t.navigateTo(urlValue);\n\t});\n\t/**\n\t * Type text to element\n\t * @param {string} alias - element to type\n\t * @param {string} value - value to type\n\t * @example I type 'wikipedia' to 'Google Input'\n\t */\n\tWhen('I type {string} to {string}', async function (value: string, alias: string) {\n", "    const element = await getElement(alias);\n\t    const typeValue = await getValue(value);\n\t    await t.typeText(element, typeValue);\n\t});\n\t/**\n\t * Click element\n\t * @param {string} alias - element to click\n\t * @example I click 'Google Button'\n\t */\n\tWhen('I click {string}', async function (alias: string) {\n", "    const element = await getElement(alias);\n\t    await t.click(element);\n\t});\n\t/**\n\t * Click element via script\n\t * @param {string} alias - element to click\n\t * @example I force click 'Google Button'\n\t */\n\tWhen('I force click {string}', async function (alias: string) {\n\t    const element = await getElement(alias);\n", "    // @ts-ignore\n\t    await t.eval(() => element().click(), { dependencies: { element } });\n\t});\n\t/**\n\t * Right click element\n\t * @param {string} alias - element to right click\n\t * @example I right click 'Google Button'\n\t */\n\tWhen('I right click {string}', async function (alias: string) {\n\t    const element = await getElement(alias);\n", "    await t.rightClick(element);\n\t});\n\t/**\n\t * Double click element\n\t * @param {string} alias - double element to click\n\t * @example I double click 'Google Button'\n\t */\n\tWhen('I double click {string}', async function (alias: string) {\n\t    const element = await getElement(alias);\n\t    await t.doubleClick(element);\n", "});\n\t/**\n\t * Clear input\n\t * @param {string} alias - element to clear\n\t * @example I clear 'Google Input'\n\t */\n\tWhen('I clear {string}', async function (alias: string) {\n\t    const element = await getElement(alias);\n\t    await t.selectText(element).pressKey('delete');\n\t});\n", "/**\n\t * Switch to parent frame\n\t * @example I switch to parent frame\n\t */\n\tWhen('I switch to parent frame', async function () {\n\t    await t.switchToMainWindow();\n\t});\n\t/**\n\t * Switch to frame by index\n\t * @param {number} index - index to switch\n", " * @example I switch to 2 frame\n\t */\n\tWhen('I switch to {int} frame', async function (index: number) {\n\t    await t.switchToIframe(Selector('iframe').nth(index - 1));\n\t});\n\t/**\n\t * Switch to frame by index\n\t * @param {number} index - index to switch\n\t * @example I switch to 2 frame\n\t */\n", "When('I switch to {string} window', async function (hrefOrTitleKey: string) {\n\t    const hrefOrTitle = await getValue(hrefOrTitleKey);\n\t    await t.switchToWindow((win: WindowFilterData) =>\n\t        win.title.includes(hrefOrTitle) || win.url.href.includes(hrefOrTitle)\n\t    );\n\t});\n\t/**\n\t * Refresh current page\n\t * @example I refresh page\n\t */\n", "When('I refresh page', async function () {\n\t    await ClientFunction(() => {\n\t        document.location.reload();\n\t    }).with({ boundTestRun: t })();\n\t});\n\t/**\n\t * Press button\n\t * @param {string} key - key to press\n\t * @example I press 'Enter' key\n\t * @example I press 'Control+C' keys\n", " */\n\tWhen('I press {string} key(s)', async function (key: string) {\n\t    const resolvedKey = await getValue(key);\n\t    await t.pressKey(resolvedKey.toLowerCase());\n\t});\n\t/**\n\t * Press button given number of times\n\t * @param {string} key - key to press\n\t * @param {number} num - number of times\n\t * @example I press 'Enter' key 5 times\n", " * @example I press 'Control+V' keys 5 times\n\t */\n\tWhen('I press {string} key(s) {int} time(s)', async function (key: string, num: number) {\n\t    const resolvedKey = await getValue(key)\n\t    for (let i: number = 0; i < num; i++) {\n\t        await t.pressKey(resolvedKey.toLowerCase());\n\t    }\n\t});\n\t/**\n\t * Hover over element\n", " * @param {string} alias - element to hover over\n\t * @example I hover over 'Google Button'\n\t */\n\tWhen('I hover over {string}', async function (alias: string) {\n\t    const element = await getElement(alias);\n\t    await t.hover(element);\n\t});\n\t/**\n\t * Select option with certain text from select element\n\t * @param {string} option - option to select\n", " * @param {string} alias - alias of select\n\t * @example I select '1900' option from 'Registration Form > Date Of Birth'\n\t * @example I select '$dateOfBirth' option from 'Registration Form > Date Of Birth' dropdown\n\t */\n\tWhen('I select {string} option from {string} dropdown', async function (option: string, alias: string) {\n\t    const optionValue = await getValue(option);\n\t    const select = await getElement(alias);\n\t    await t\n\t        .click(select)\n\t        .click(select.find('option').withText(optionValue));\n", "});\n\t/**\n\t * Select option with certain text from select element\n\t * @param {number} optionIndex - index of option to select\n\t * @param {string} alias - alias of select\n\t * @example I select 1 option from 'Registration Form > Date Of Birth' dropdown\n\t */\n\tWhen('I select {int}(st|nd|rd|th) option from {string} dropdown', async function (optionIndex: number, alias: string) {\n\t    const select = await getElement(alias);\n\t    await t\n", "        .click(select)\n\t        .click(select.find('option').nth(optionIndex - 1));\n\t});\n\t/**\n\t * Click on element with desired text in collection\n\t * @param {string} expectedText - text to click\n\t * @param {string} alias - collection to search text\n\t * @example I click 'google' text in 'Search Engines' collection\n\t * @example I click '$someVarWithText' text in 'Search Engines' collection\n\t */\n", "When(\n\t    'I click {string} text in {string} collection',\n\t    async function (value: string, alias: string) {\n\t        const resolvedValue = await getValue(value);\n\t        const collection = await getElement(alias);\n\t        await t.click(collection.withText(resolvedValue));\n\t    }\n\t);\n\t/**\n\t * Scroll by provided offset\n", " * @param {string} - offset string in 'x, y' format\n\t * @example\n\t * When I scroll by '0, 100'\n\t */\n\tWhen('I scroll by {string}', async function (offset: string) {\n\t    const [x, y] = parseCoords(await getValue(offset));\n\t    await t.scrollBy(x, y);\n\t});\n\t/**\n\t * Scroll by provided offset in element\n", " * @param {string} - offset string in 'x, y' format\n\t * @param {string} - element alias\n\t * @example\n\t * When I scroll by '0, 100' in 'Overflow Container'\n\t */\n\tWhen('I scroll by {string} in {string}', async function (offset: string, alias: string) {\n\t    const element = await getElement(alias);\n\t    const [x, y] = parseCoords(await getValue(offset));\n\t    await t.scrollBy(element, x, y);\n\t});\n", "/**\n\t * Provide file url to upload input\n\t * @param {string} alias - element to upload file\n\t * @param {string} value - file path\n\t * @example I upload '/folder/file.txt' to 'File Input'\n\t */\n\tWhen('I upload {string} file to {string}', async function (value: string, alias: string) {\n\t    const element = await getElement(alias);\n\t    const filePath = await getValue(value);\n\t    await t.setFilesToUpload(element, [filePath]).click(element);\n", "});\n\t/**\n\t * Set alert handler\n\t * @example I will accept alert\n\t */\n\tWhen('I will accept alert', async function () {\n\t    await t.setNativeDialogHandler(() => true);\n\t});\n\t/**\n\t * Dismiss alert\n", " * testcafe automatically dismisses all dialogs. This step is just to make it implicitly.\n\t * @example I will dismiss alert\n\t */\n\tWhen('I will dismiss alert', async function () {\n\t    await t.setNativeDialogHandler(() => false);\n\t});\n\t/**\n\t * Type text to prompt\n\t * I type {string} to alert\n\t * @example I will type 'coffee' to alert\n", " */\n\tWhen('I will type {string} to alert', async function (valueKey: string) {\n\t    const value = await getValue(valueKey);\n\t    await t.setNativeDialogHandler(() => value, { dependencies: { value }});\n\t});\n"]}
{"filename": "src/cookies.ts", "chunked_list": ["import { When } from '@cucumber/cucumber';\n\timport { getValue } from './transformers';\n\timport memory from '@qavajs/memory';\n\t/**\n\t * Set cookie\n\t * @param {string} cookie - cookie name\n\t * @param {string} value - value to set\n\t * @example I set 'userID' cookie 'user1'\n\t * @example I set 'userID' cookie '$userIdCookie'\n\t */\n", "When('I set {string} cookie as {string}', async function (cookie, value) {\n\t    const cookieValue = await getValue(value);\n\t    const cookieObject = typeof cookieValue === 'object' ? cookieValue : { name: cookie, value: cookieValue };\n\t    await t.setCookies(cookieObject);\n\t});\n\t/**\n\t * Save cookie value to memory\n\t * @param {string} cookie - cookie name\n\t * @param {string} key - memory key\n\t * @example I save value of 'auth' cookie as 'authCookie'\n", " */\n\tWhen('I save value of {string} cookie as {string}', async function (cookie, key) {\n\t    const cookieName = await getValue(cookie);\n\t    const cookies = await t.getCookies([cookieName]);\n\t    memory.setValue(key, cookies.pop());\n\t});\n"]}
{"filename": "src/intercept.ts", "chunked_list": ["import { When } from '@cucumber/cucumber';\n\timport { getValue } from './transformers';\n\timport memory from '@qavajs/memory';\n\timport { RequestLogger } from 'testcafe';\n\t/**\n\t * Create interception for url or predicate function\n\t * @param {string | function} url - url or predicate function to listen\n\t * @param {string} key - memory key to save\n\t * @example I create interception for '.+\\/api\\/qavajs' as 'intercept'\n\t * @example I create interception for '$interceptHandler' as 'intercept' // if you need to pass function as interception handler\n", " */\n\tWhen('I create interception for {string} as {string}', async function (urlTemplate: string, key: string) {\n\t    const url = await getValue(urlTemplate);\n\t    const predicate = typeof url === 'string' ? new RegExp(url, 'g') : url;\n\t    const requestLogger = RequestLogger(predicate, {\n\t        logRequestBody: true,\n\t        logRequestHeaders: true,\n\t        logResponseBody: true,\n\t        logResponseHeaders: true\n\t    });\n", "    memory.setValue(key, requestLogger);\n\t    await t.addRequestHooks(requestLogger);\n\t});\n\t/**\n\t * Wait for interception response\n\t * @param {string} interception - key of saved interception promise\n\t * @example I wait for '$interception' response\n\t */\n\tWhen('I wait for {string} response', async function (interception: string) {\n\t    const requestLogger: RequestLogger = await getValue(interception);\n", "    await t.expect(requestLogger.requests.length).gt(0);\n\t    await t.expect(requestLogger.contains(request => !!request.response)).ok();\n\t});\n\t/**\n\t * Save interception response\n\t * @param {string} interception - key of saved interception promise\n\t * @example I save '$interception' response as 'response'\n\t */\n\tWhen('I save {string} response as {string}', async function (interception: string, key: string) {\n\t    const requestLogger: RequestLogger = await getValue(interception);\n", "    await t.expect(requestLogger.requests.length).gt(0);\n\t    await t.expect(requestLogger.contains(request => !!request.response)).ok();\n\t    const requests = requestLogger.requests;\n\t    memory.setValue(key, requests[requests.length - 1]);\n\t});\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { defineParameterType } from '@cucumber/cucumber';\n\tdefineParameterType({\n\t    name: 'testcafeValidation',\n\t    regexp: /((?:is |do |does |to )?(not |to not )?(?:to )?(?:be )?(equal|strictly equal|deeply equal|have member|match|contain|above|below|greater than|less than|have type)(?:s|es)?)/,\n\t    transformer: p => p,\n\t    useForSnippets: false\n\t});\n\tdefineParameterType({\n\t    name: 'testcafeValueWait',\n\t    regexp: /((not )?to (?:be )?(equal|contain|above|below|match))/,\n", "    transformer: p => p,\n\t    useForSnippets: false\n\t});\n\tdefineParameterType({\n\t    name: 'testcafeConditionWait',\n\t    regexp: /((not )?to (?:be )?(present|clickable|visible|invisible|enabled|disabled|in viewport))/,\n\t    transformer: p => p,\n\t    useForSnippets: false\n\t});\n\tdefineParameterType({\n", "    name: 'testcafeTimeout',\n\t    regexp: /(?:\\(timeout: (\\d+)\\))?/,\n\t    transformer: p => p ? parseInt(p) : null,\n\t    useForSnippets: false\n\t});\n\tdefineParameterType({\n\t    name: 'testcafePoType',\n\t    regexp: /(element|collection)/,\n\t    transformer: p => p,\n\t    useForSnippets: false\n", "});\n"]}
{"filename": "src/execute.ts", "chunked_list": ["import { When } from '@cucumber/cucumber';\n\timport { getValue, getElement } from './transformers';\n\timport memory from '@qavajs/memory';\n\timport { ClientFunction } from 'testcafe';\n\tconst resolveFunction = (fnDef: string | Function) => typeof fnDef === 'string' ? eval(`() => ${fnDef}`) : fnDef;\n\t/**\n\t * Execute client function\n\t * @param {string} functionKey - memory key of function\n\t * @example I execute '$fn' function // fn is function reference\n\t * @example I execute 'window.scrollBy(0, 100)' function\n", " */\n\tWhen('I execute {string} function', async function (functionKey) {\n\t    const fnDef = await getValue(functionKey);\n\t    const clientFunction = ClientFunction(resolveFunction(fnDef));\n\t    await clientFunction.with({ boundTestRun: t })();\n\t});\n\t/**\n\t * Execute client function and save result into memory\n\t * @param {string} functionKey - memory key of function\n\t * @param {string} memoryKey - memory key to store result\n", " * @example I execute '$fn' function and save result as 'result' // fn is function reference\n\t * @example I execute 'window.scrollY' function and save result as 'scroll'\n\t */\n\tWhen('I execute {string} function and save result as {string}', async function (functionKey, memoryKey) {\n\t    const fnDef = await getValue(functionKey);\n\t    const clientFunction = ClientFunction(resolveFunction(fnDef));\n\t    memory.setValue(memoryKey, await clientFunction.with({ boundTestRun: t })());\n\t});\n\t/**\n\t * Execute client function on certain element\n", " * @param {string} functionKey - memory key of function\n\t * @param {string} alias - alias of target element\n\t * @example I execute '$fn' function on 'Component > Element' // fn is function reference\n\t * @example I execute 'target.scrollIntoView()' function on 'Component > Element'\n\t */\n\tWhen('I execute {string} function on {string}', async function (functionKey, alias) {\n\t    const fnDef = await getValue(functionKey);\n\t    const element = await getElement(alias);\n\t    const clientFunction = ClientFunction(resolveFunction(fnDef), {\n\t        dependencies: { target: element }\n", "    });\n\t    await clientFunction.with({ boundTestRun: t })();\n\t});\n\t/**\n\t * Execute client function on certain element\n\t * @param {string} functionKey - memory key of function\n\t * @param {string} alias - alias of target element\n\t * @example I execute '$fn' function on 'Component > Element' and save result as 'innerText' // fn is function reference\n\t * @example I execute 'target.innerText' function on 'Component > Element' and save result as 'innerText'\n\t */\n", "When(\n\t    'I execute {string} function on {string} and save result as {string}',\n\t    async function (functionKey, alias, memoryKey) {\n\t        const fnDef = await getValue(functionKey);\n\t        const element = await getElement(alias);\n\t        const clientFunction = ClientFunction(resolveFunction(fnDef), {\n\t            dependencies: { target: element }\n\t        });\n\t        memory.setValue(memoryKey, await clientFunction.with({ boundTestRun: t })());\n\t    }\n", ");\n"]}
{"filename": "src/waits.ts", "chunked_list": ["import { When } from '@cucumber/cucumber';\n\timport { getValue, getElement, getConditionWait, getValueWait } from './transformers';\n\timport {ClientFunction} from 'testcafe';\n\t/**\n\t * Wait for element condition\n\t * @param {string} alias - element to wait condition\n\t * @param {string} wait - wait condition\n\t * @param {number|null} [timeout] - custom timeout in ms\n\t * @example I wait until 'Header' to be visible\n\t * @example I wait until 'Loading' not to be present\n", " * @example I wait until 'Search Bar > Submit Button' to be clickable\n\t * @example I wait until 'Search Bar > Submit Button' to be clickable (timeout: 3000)\n\t */\n\tWhen(\n\t    'I wait until {string} {testcafeConditionWait}( ){testcafeTimeout}',\n\t    async function (alias: string, waitType: string, timeout: number | null) {\n\t        const wait = getConditionWait(waitType);\n\t        const element = await getElement(alias);\n\t        await wait(element, timeout ? timeout : config.browser.timeout.page);\n\t    }\n", ");\n\t/**\n\t * Wait for element text condition\n\t * @param {string} alias - element to wait condition\n\t * @param {string} wait - wait condition\n\t * @param {string} value - expected value to wait\n\t * @param {number|null} [timeout] - custom timeout in ms\n\t * @example I wait until text of 'Header' to be equal 'Javascript'\n\t * @example I wait until text of 'Header' not to be equal 'Python'\n\t * @example I wait until text of 'Header' to be equal 'Javascript' (timeout: 3000)\n", " */\n\tWhen(\n\t    'I wait until text of {string} {testcafeValueWait} {string}( ){testcafeTimeout}',\n\t    async function (alias: string, waitType: string, value: string, timeout: number | null) {\n\t        const wait = getValueWait(waitType);\n\t        const element = await getElement(alias);\n\t        const expectedValue = await getValue(value);\n\t        await wait(\n\t            element.with({ boundTestRun: t }).innerText,\n\t            expectedValue,\n", "            timeout ? timeout : config.browser.timeout.page\n\t        );\n\t    }\n\t);\n\t/**\n\t * Wait for collection length condition\n\t * @param {string} alias - element to wait condition\n\t * @param {string} wait - wait condition\n\t * @param {string} value - expected value to wait\n\t * @param {number|null} [timeout] - custom timeout in ms\n", " * @example I wait until number of elements in 'Search Results' collection to be equal '50'\n\t * @example I wait until number of elements in 'Search Results' collection to be above '49'\n\t * @example I wait until number of elements in 'Search Results' collection to be below '51'\n\t * @example I wait until number of elements in 'Search Results' collection to be below '51' (timeout: 3000)\n\t */\n\tWhen(\n\t    'I wait until number of elements in {string} collection {testcafeValueWait} {string}( ){testcafeTimeout}',\n\t    async function (alias: string, waitType: string, value: string, timeout: number | null) {\n\t        const wait = getValueWait(waitType);\n\t        const collection = await getElement(alias);\n", "        const expectedValue = await getValue(value);\n\t        await wait(\n\t            collection.with({ boundTestRun: t }).count,\n\t            parseFloat(expectedValue),\n\t            timeout ? timeout : config.browser.timeout.page\n\t        );\n\t    }\n\t);\n\t/**\n\t * Wait for element property condition\n", " * @param {string} property - property\n\t * @param {string} alias - element to wait condition\n\t * @param {string} wait - wait condition\n\t * @param {string} value - expected value to wait\n\t * @param {number|null} [timeout] - custom timeout in ms\n\t * @example I wait until 'value' property of 'Search Input' to be equal 'Javascript'\n\t * @example I wait until 'value' property of 'Search Input' to be equal 'Javascript' (timeout: 3000)\n\t */\n\tWhen(\n\t    'I wait until {string} property of {string} {testcafeValueWait} {string}( ){testcafeTimeout}',\n", "    async function (property: string, alias: string, waitType: string, value: string, timeout: number | null) {\n\t        const propertyName = await getValue(property);\n\t        const wait = getValueWait(waitType);\n\t        const element = await getElement(alias);\n\t        const expectedValue = await getValue(value);\n\t        // @ts-ignore\n\t        const getValueFn = element.with({ boundTestRun: t })[propertyName];\n\t        await wait(getValueFn, expectedValue, timeout ? timeout : config.browser.timeout.page);\n\t    }\n\t);\n", "/**\n\t * Wait for element attribute condition\n\t * @param {string} attribute - attribute\n\t * @param {string} alias - element to wait condition\n\t * @param {string} wait - wait condition\n\t * @param {string} value - expected value to wait\n\t * @param {number|null} [timeout] - custom timeout in ms\n\t * @example I wait until 'href' attribute of 'Home Link' to be equal '/javascript'\n\t * @example I wait until 'href' attribute of 'Home Link' to be equal '/javascript' (timeout: 3000)\n\t */\n", "When(\n\t    'I wait until {string} attribute of {string} {testcafeValueWait} {string}( ){testcafeTimeout}',\n\t    async function (attribute: string, alias: string, waitType: string, value: string, timeout: number | null) {\n\t        const attributeName = await getValue(attribute);\n\t        const wait = getValueWait(waitType);\n\t        const element = await getElement(alias);\n\t        const expectedValue = await getValue(value);\n\t        const getValueFn = element.with({ boundTestRun: t }).getAttribute(attributeName);\n\t        await wait(getValueFn, expectedValue, timeout ? timeout : config.browser.timeout.page);\n\t    }\n", ");\n\t/**\n\t * Wait\n\t * @param {number} ms - milliseconds\n\t * @example I wait 1000 ms\n\t */\n\tWhen('I wait {int} ms', async function (ms) {\n\t    await new Promise((resolve: Function): void => {\n\t        setTimeout(() => resolve(), ms)\n\t    });\n", "});\n\t/**\n\t * Wait for url condition\n\t * @param {string} wait - wait condition\n\t * @param {string} value - expected value to wait\n\t * @param {number|null} [timeout] - custom timeout in ms\n\t * @example I wait until current url to be equal 'https://qavajs.github.io/'\n\t * @example I wait until current url not to contain 'java'\n\t * @example I wait until current url not to contain 'java' (timeout: 3000)\n\t */\n", "When(\n\t    'I wait until current url {testcafeValueWait} {string}( ){testcafeTimeout}',\n\t    async function (waitType: string, value: string, timeout: number | null) {\n\t        const wait = getValueWait(waitType);\n\t        const expectedValue = await getValue(value);\n\t        const getValueFn = await ClientFunction(() => window.location.href )\n\t            .with({ boundTestRun: t });\n\t        await wait(getValueFn(), expectedValue, timeout ? timeout : config.browser.timeout.page);\n\t    }\n\t);\n", "/**\n\t * Wait for title condition\n\t * @param {string} wait - wait condition\n\t * @param {string} value - expected value to wait\n\t * @param {number|null} [timeout] - custom timeout in ms\n\t * @example I wait until page title to be equal 'qavajs'\n\t * @example I wait until page title not to contain 'java'\n\t * @example I wait until page title to be equal 'qavajs' (timeout: 3000)\n\t */\n\tWhen(\n", "    'I wait until page title {testcafeValueWait} {string}( ){testcafeTimeout}',\n\t    async function (waitType: string, value: string, timeout: number | null) {\n\t        const wait = getValueWait(waitType);\n\t        const expectedValue = await getValue(value);\n\t        const getValueFn = await ClientFunction(() => window.document.title )\n\t            .with({ boundTestRun: t });\n\t        await wait(getValueFn(), expectedValue, timeout ? timeout : config.browser.timeout.page);\n\t    }\n\t);\n"]}
{"filename": "src/localSessionStorage.ts", "chunked_list": ["import { When } from '@cucumber/cucumber';\n\timport { getValue } from './transformers';\n\timport memory from '@qavajs/memory';\n\timport {ClientFunction} from 'testcafe';\n\t/**\n\t * Set value of local/session storage\n\t * @param {string} storageKey - local/session storage key to set value\n\t * @param {string} storageType - storage type (local or session)\n\t * @param {string} value - value to set\n\t * @example I set 'username' local storage value as 'user1'\n", " * @example I set '$sessionStorageKey' session storage value as '$sessionStorageValue'\n\t */\n\tWhen('I set {string} {word} storage value as {string}', async function (storageKey, storageType, value) {\n\t    await ClientFunction(function () {\n\t        const storage: string = storageType + 'Storage';\n\t        // @ts-ignore\n\t        window[storage].setItem(storageKey, value);\n\t    }, {\n\t        dependencies: {\n\t            storageKey: await getValue(storageKey),\n", "            storageType,\n\t            value: await getValue(value)\n\t        }\n\t    }).with({ boundTestRun: t })();\n\t});\n\t/**\n\t * Save value of local/session storage to memory\n\t * @param {string} storageKey - local/session storage key to set value\n\t * @param {string} storageType - storage type (local or session)\n\t * @param {string} key - memory key\n", " * @example I save value of 'username' local storage as 'localStorageValue'\n\t * @example I save value of '$sessionStorageKey' session storage value as 'sessionStorageValue'\n\t */\n\tWhen('I save value of {string} {word} storage as {string}', async function (storageKey, storageType, key) {\n\t    const value = await ClientFunction(function () {\n\t        const storage: string = storageType + 'Storage';\n\t        // @ts-ignore\n\t        return window[storage].getItem(storageKey);\n\t    }, {\n\t        dependencies: {\n", "            storageKey: await getValue(storageKey),\n\t            storageType,\n\t        }\n\t    }).with({ boundTestRun: t })();\n\t    memory.setValue(key, value);\n\t});\n"]}
{"filename": "src/mock.ts", "chunked_list": ["import { When } from '@cucumber/cucumber';\n\timport { getValue } from './transformers';\n\timport memory from '@qavajs/memory';\n\timport {RequestMock} from 'testcafe';\n\tlet mocks: {[prop: string]: RequestMock} = {};\n\t/**\n\t * Create simple mock instance\n\t * @param {string} urlTemplate - minimatch url template to mock\n\t * @param {string} memoryKey - memory key to store mock instance\n\t * @example When I create mock for '.+/yourservice/.+' as 'mock1'\n", " * @example When I create mock for '$mockUrlTemplate' as 'mock1'\n\t */\n\tWhen('I create mock for {string} as {string}', async function (urlTemplate: string, memoryKey: string) {\n\t    const url = await getValue(urlTemplate);\n\t    memory.setValue(memoryKey, url);\n\t});\n\tasync function respondWith(mockKey: string, statusCode: string, body: string): Promise<void> {\n\t    const url: any = await getValue(mockKey);\n\t    const responseStatusCode: number = parseInt(await getValue(statusCode));\n\t    const responseBody = await getValue(body);\n", "    const mockTemplate = typeof url === 'string' ? new RegExp(url, 'g') : url;\n\t    const response = RequestMock()\n\t        .onRequestTo(mockTemplate)\n\t        .respond(\n\t            responseBody,\n\t            responseStatusCode,\n\t            { 'access-control-allow-origin': '*' }\n\t        );\n\t    mocks[mockKey] = response;\n\t    await t.addRequestHooks(response);\n", "}\n\t/**\n\t * Add mocking rule to respond with desired status code and payload\n\t * @param {string} mockKey - memory key to get mock instance\n\t * @param {string} statusCode - status code\n\t * @param {string} body - response body\n\t * @example\n\t * When I create mock for '/yourservice/**' with filter options as 'myServiceMock'\n\t * And I set '$myServiceMock' mock to respond '200' with:\n\t * \"\"\"\n", " * {\n\t *     \"status\": \"success\"\n\t * }\n\t * \"\"\"\n\t */\n\tWhen('I set {string} mock to respond {string} with:', respondWith);\n\t/**\n\t * Add mocking rule to respond with desired status code and payload\n\t * @param {string} mockKey - memory key to get mock instance\n\t * @param {string} statusCode - status code\n", " * @param {string} body - response body\n\t * @example\n\t * When I create mock for '/yourservice/**' with filter options as 'myServiceMock'\n\t * And I set '$myServiceMock' mock to respond '200' with '$response'\n\t */\n\tWhen('I set {string} mock to respond {string} with {string}', respondWith);\n\t/**\n\t * Restore mock\n\t * @param {string} mockKey - memory key to get mock instance\n\t * @example When I restore '$myServiceMock'\n", " */\n\tWhen('I restore {string} mock', async function (mockKey: string) {\n\t    const mock = mocks[mockKey];\n\t    await t.removeRequestHooks(mock);\n\t    delete mocks[mockKey];\n\t});\n\t/**\n\t * Restore all mocks\n\t * @example When I restore all mocks\n\t */\n", "When('I restore all mocks', async function () {\n\t    await t.removeRequestHooks(...Object.values(mocks));\n\t    mocks = {};\n\t});\n"]}
{"filename": "src/poDefine.ts", "chunked_list": ["import { When } from '@cucumber/cucumber';\n\timport { po, $, $$ } from '@qavajs/po-testcafe';\n\timport { getValue } from './transformers';\n\t/**\n\t * Register selector as page object\n\t * @param {string} selectorKey - selector to register\n\t * @param {string} aliasKey - alias of element\n\t * @example\n\t * When I define '#someId' as 'My Button' element\n\t * And I click 'My Button'\n", " *\n\t * When I define 'li.selected' as 'Selected Items' collection\n\t * And I expect number of element in 'Selected Items' collection to equal '3'\n\t */\n\tWhen('I define {string} as {string} {testcafePoType}', async function (\n\t    selectorKey: string, aliasKey: string, poType: string\n\t) {\n\t    const selector = await getValue(selectorKey);\n\t    const alias = (await getValue(aliasKey)).replace(/\\s/g, '');\n\t    const defineElement = poType === 'element' ? $ : $$;\n", "    po.register({ [alias]: defineElement(selector) });\n\t});\n"]}
{"filename": "src/memory.ts", "chunked_list": ["import memory from '@qavajs/memory';\n\timport { When } from '@cucumber/cucumber';\n\timport { getElement, getValue } from './transformers';\n\timport {ClientFunction} from 'testcafe';\n\t/**\n\t * Save text of element to memory\n\t * @param {string} alias - element to get value\n\t * @param {string} key - key to store value\n\t * @example I save text of '#1 of Search Results' as 'firstSearchResult'\n\t */\n", "When('I save text of {string} as {string}', async function (alias, key) {\n\t    const element = await getElement(alias);\n\t    const value = await element.with({ boundTestRun: t }).innerText;\n\t    memory.setValue(key, value);\n\t});\n\t/**\n\t * Save property of element to memory\n\t * @param {string} property - property to store\n\t * @param {string} alias - element to get value\n\t * @param {string} key - key to store value\n", " * @example I save 'checked' property of 'Checkbox' as 'checked'\n\t * @example I save '$prop' property of 'Checkbox' as 'checked'\n\t */\n\tWhen('I save {string} property of {string} as {string}', async function (property, alias, key) {\n\t    const element = await getElement(alias);\n\t    const propertyName = await getValue(property);\n\t    // @ts-ignore\n\t    const value = await element.with({ boundTestRun: t })[propertyName];\n\t    memory.setValue(key, value);\n\t});\n", "/**\n\t * Save attribute of element to memory\n\t * @param {string} attribute - attribute to store\n\t * @param {string} alias - element to get value\n\t * @param {string} key - key to store value\n\t * @example I save 'href' attribute of 'Link' as 'linkHref'\n\t * @example I save '$prop' attribute of 'Link' as 'linkHref'\n\t */\n\tWhen('I save {string} attribute of {string} as {string}', async function (attribute, alias, key) {\n\t    const element = await getElement(alias);\n", "    const attributeName = await getValue(attribute);\n\t    const value = await element.with({ boundTestRun: t }).getAttribute(attributeName);\n\t    memory.setValue(key, value);\n\t});\n\t/**\n\t * Save number of elements in collection to memory\n\t * @param {string} alias - collection to get value\n\t * @param {string} key - key to store value\n\t * @example I save number of elements in 'Search Results' as 'numberOfSearchResults'\n\t */\n", "When('I save number of elements in {string} collection as {string}', async function (alias, key) {\n\t    const collection = await getElement(alias);\n\t    const value = await collection.with({ boundTestRun: t }).count;\n\t    memory.setValue(key, value);\n\t});\n\t/**\n\t * Save array of texts of collection to memory\n\t * @param {string} alias - collection to get values\n\t * @param {string} key - key to store value\n\t * @example I save text of every element of 'Search Results' collection as 'searchResults'\n", " */\n\tWhen(\n\t    'I save text of every element of {string} collection as {string}',\n\t    async function (alias: string, key: string) {\n\t        const collection = await getElement(alias);\n\t        const count = await collection.with({ boundTestRun: t }).count;\n\t        const values = [];\n\t        for (let i = 0; i < count; i++) {\n\t            values.push(await collection.nth(i).with({ boundTestRun: t }).innerText);\n\t        }\n", "        memory.setValue(key, values);\n\t    }\n\t);\n\t/**\n\t * Save array of attributes of collection to memory\n\t * @param {string} alias - collection to get values\n\t * @param {string} key - key to store value\n\t * @example I save 'checked' attribute of every element of 'Search > Checkboxes' collection as 'checkboxes'\n\t */\n\tWhen(\n", "    'I save {string} attribute of every element of {string} collection as {string}',\n\t    async function (attribute: string, alias: string, key: string) {\n\t        const collection = await getElement(alias);\n\t        const count = await collection.with({ boundTestRun: t }).count;\n\t        const values = [];\n\t        for (let i = 0; i < count; i++) {\n\t            values.push(await collection.nth(i).with({ boundTestRun: t }).getAttribute(attribute));\n\t        }\n\t        memory.setValue(key, values);\n\t    }\n", ");\n\t/**\n\t * Save array of property of collection to memory\n\t * @param {string} alias - collection to get values\n\t * @param {string} key - key to store value\n\t * @example I save 'href' property of every element of 'Search > Links' collection as 'hrefs'\n\t */\n\tWhen(\n\t    'I save {string} property of every element of {string} collection as {string}',\n\t    async function (property: string, alias: string, key: string) {\n", "        const propertyName = await getValue(property);\n\t        const collection = await getElement(alias);\n\t        const count = await collection.with({ boundTestRun: t }).count;\n\t        const values = [];\n\t        for (let i = 0; i < count; i++) {\n\t            const element = collection.nth(i).with({ boundTestRun: t });\n\t            // @ts-ignore\n\t            values.push(await element[propertyName]);\n\t        }\n\t        memory.setValue(key, values);\n", "    }\n\t);\n\t/**\n\t * Save current url to memory\n\t * @param {string} key - key to store value\n\t * @example I save current url as 'currentUrl'\n\t */\n\tWhen('I save current url as {string}', async function (key: string) {\n\t    const url = await ClientFunction(() => window.location.href )\n\t        .with({ boundTestRun: t })();\n", "    memory.setValue(key, url);\n\t});\n\t/**\n\t * Save current page title to memory\n\t * @param {string} key - key to store value\n\t * @example I save page title as 'currentTitle'\n\t */\n\tWhen('I save page title as {string}', async function (key: string) {\n\t    const title = await ClientFunction(() => window.document.title )\n\t        .with({ boundTestRun: t })();\n", "    memory.setValue(key, title);\n\t});\n\t/**\n\t * Save page screenshot into memory\n\t * @param {string} key - key to store value\n\t * @example I save screenshot as 'screenshot'\n\t */\n\tWhen('I save screenshot as {string}', async function(key: string) {\n\t    const screenshot = await t.takeScreenshot();\n\t    memory.setValue(key, screenshot);\n", "});\n\t/**\n\t * Save css property of element to memory\n\t * @param {string} property - property to store\n\t * @param {string} alias - element to get value\n\t * @param {string} key - key to store value\n\t * @example I save 'color' css property of 'Checkbox' as 'checkboxColor'\n\t * @example I save '$propertyName' property of 'Checkbox' as 'checkboxColor'\n\t */\n\tWhen('I save {string} css property of {string} as {string}', async function (property, alias, key) {\n", "    const element = await getElement(alias);\n\t    const propertyName = await getValue(property);\n\t    const value = await ClientFunction(() => {\n\t        // @ts-ignore\n\t        return getComputedStyle(element()).getPropertyValue(propertyName)\n\t    }, { dependencies: { element, propertyName }}).with({ boundTestRun: t })();\n\t    memory.setValue(key, value);\n\t});\n"]}
{"filename": "src/valueWait.ts", "chunked_list": ["function regexp(regexpLike: string | RegExp) {\n\t    if (typeof regexpLike === 'string') {\n\t        return new RegExp(regexpLike, 'gmi')\n\t    }\n\t    return regexpLike\n\t}\n\texport const valueValidations = {\n\t    EQUAL: 'equal',\n\t    CONTAIN: 'contain',\n\t    ABOVE: 'above',\n", "    BELOW: 'below',\n\t    MATCH: 'match'\n\t}\n\tconst notClause = '(not )?';\n\tconst toBeClause = 'to (?:be )?';\n\tconst validationClause = `(${Object.values(valueValidations).join('|')})`;\n\texport const valueWaitExtractRegexp = new RegExp(`^${notClause}${toBeClause}${validationClause}$`);\n\texport const valueWaitRegexp = new RegExp(`(${notClause}${toBeClause}${validationClause})`);\n\tconst waits = {\n\t    [valueValidations.EQUAL]: async (poll: Assertion, expected: any, reverse: boolean, timeout: number, message: string) =>\n", "        reverse\n\t            ? poll.notEql(expected, message, { timeout })\n\t            : poll.eql(expected, message, { timeout }),\n\t    [valueValidations.CONTAIN]: async (poll: Assertion, expected: any, reverse: boolean, timeout: number, message: string) =>\n\t        reverse\n\t            ? poll.notContains(expected, message, { timeout })\n\t            : poll.contains(expected, message, { timeout }),\n\t    [valueValidations.ABOVE]: async (poll: Assertion, expected: any, reverse: boolean, timeout: number, message: string) =>\n\t        reverse\n\t            ? poll.lte(parseFloat(expected), message, { timeout })\n", "            : poll.gt(parseFloat(expected), message, { timeout }),\n\t    [valueValidations.BELOW]: async (poll: Assertion, expected: any, reverse: boolean, timeout: number, message: string) =>\n\t        reverse\n\t            ? poll.gte(parseFloat(expected), message, { timeout })\n\t            : poll.lt(parseFloat(expected), message, { timeout }),\n\t    [valueValidations.MATCH]: async (poll: Assertion, expected: any, reverse: boolean, timeout: number, message: string) =>\n\t        reverse\n\t            ? poll.notMatch(regexp(expected), message, { timeout })\n\t            : poll.match(regexp(expected), message, { timeout })\n\t}\n", "/**\n\t * Wait for condition\n\t * @param {any} valueFn - function to return value\n\t * @param {any} expected - expected value\n\t * @param {string} validationType - validation to perform\n\t * @param {number} [timeout] - timeout to wait\n\t * @param {boolean} [reverse] - negate flag\n\t * @return {Promise<void>}\n\t */\n\texport async function valueWait(\n", "    valueFn: ClientFunction | Selector,\n\t    expected: any,\n\t    validationType: string,\n\t    timeout: number = 10000,\n\t    reverse: boolean\n\t) {\n\t    const message: string = `Value is${reverse ? '' : ' not'} ${validationType} ${expected}`;\n\t    const waitFn = waits[validationType];\n\t    const poll: Assertion = t.expect(valueFn);\n\t    await waitFn(poll, expected, reverse, timeout, message);\n", "}\n"]}
{"filename": "src/validations.ts", "chunked_list": ["import { Then } from '@cucumber/cucumber';\n\timport { getValue, getElement, getConditionWait } from './transformers';\n\timport { getValidation } from '@qavajs/validation';\n\timport { ClientFunction } from 'testcafe';\n\t/**\n\t * Verify element condition\n\t * @param {string} alias - element to wait condition\n\t * @param {string} condition - wait condition\n\t * @example I expect 'Header' to be visible\n\t * @example I expect 'Loading' not to be present\n", " * @example I expect 'Search Bar > Submit Button' to be clickable\n\t */\n\tThen('I expect {string} {testcafeConditionWait}', async function (alias: string, condition: string) {\n\t    const element = await getElement(alias);\n\t    const wait = getConditionWait(condition);\n\t    await wait(element, config.browser.timeout.page);\n\t});\n\t/**\n\t * Verify that text of element satisfies condition\n\t * @param {string} alias - element to get text\n", " * @param {string} validationType - validation\n\t * @param {string} value - expected result\n\t * @example I expect text of '#1 of Search Results' equals to 'google'\n\t * @example I expect text of '#2 of Search Results' does not contain 'yandex'\n\t */\n\tThen(\n\t    'I expect text of {string} {testcafeValidation} {string}',\n\t    async function (alias: string, validationType: string, value: any) {\n\t        const expectedValue = await getValue(value);\n\t        const element = await getElement(alias);\n", "        const validation = getValidation(validationType);\n\t        const elementText: string = await element.with({ boundTestRun: t }).innerText;\n\t        this.log(`AR: ${elementText}`);\n\t        this.log(`ER: ${expectedValue}`);\n\t        validation(elementText, expectedValue);\n\t    }\n\t);\n\t/**\n\t * Verify that property of element satisfies condition\n\t * @param {string} property - element to verify\n", " * @param {string} alias - element to verify\n\t * @param {string} validationType - validation\n\t * @param {string} value - expected value\n\t * @example I expect 'value' property of 'Search Input' to be equal 'text'\n\t * @example I expect 'innerHTML' property of 'Label' to contain '<b>'\n\t */\n\tThen(\n\t    'I expect {string} property of {string} {testcafeValidation} {string}',\n\t    async function (property: string, alias: string, validationType: string, value: string) {\n\t        const propertyName = await getValue(property);\n", "        const expectedValue = await getValue(value);\n\t        const element = await getElement(alias);\n\t        const validation = getValidation(validationType);\n\t        // @ts-ignore\n\t        const actualValue: string = await element.with({ boundTestRun: t })[propertyName];\n\t        this.log(`AR: ${actualValue}`);\n\t        this.log(`ER: ${expectedValue}`);\n\t        validation(actualValue, expectedValue);\n\t    }\n\t);\n", "/**\n\t * Verify that attribute of element satisfies condition\n\t * @param {string} attribute - element to verify\n\t * @param {string} alias - element to verify\n\t * @param {string} validationType - validation\n\t * @param {string} value - expected value\n\t * @example I expect 'href' attribute of 'Home Link' to contain '/home'\n\t */\n\tThen(\n\t    'I expect {string} attribute of {string} {testcafeValidation} {string}',\n", "    async function (attribute: string, alias: string, validationType: string, value: string) {\n\t        const attributeName = await getValue(attribute);\n\t        const expectedValue = await getValue(value);\n\t        const element = await getElement(alias);\n\t        const validation = getValidation(validationType);\n\t        const actualValue: string | null = await element.with({ boundTestRun: t }).getAttribute(attributeName);\n\t        this.log(`AR: ${actualValue}`);\n\t        this.log(`ER: ${expectedValue}`);\n\t        validation(actualValue, expectedValue);\n\t    }\n", ");\n\t/**\n\t * Verify that current url satisfies condition\n\t * @param {string} validationType - validation\n\t * @param {string} expected - expected value\n\t * @example I expect current url contains 'wikipedia'\n\t * @example I expect current url equals 'https://wikipedia.org'\n\t */\n\tThen(\n\t    'I expect current url {testcafeValidation} {string}',\n", "    async function (validationType: string, expected: string) {\n\t        const validation = getValidation(validationType);\n\t        const expectedUrl = await getValue(expected);\n\t        const actualUrl = await ClientFunction(() => window.location.href )\n\t            .with({ boundTestRun: t })();\n\t        this.log(`AR: ${actualUrl}`);\n\t        this.log(`ER: ${expectedUrl}`);\n\t        validation(actualUrl, expectedUrl);\n\t    }\n\t);\n", "//\n\t/**\n\t * Verify that number of element in collection satisfies condition\n\t * @param {string} alias - collection to verify\n\t * @param {string} validationType - validation\n\t * @param {string} value - expected value\n\t * @example I expect number of elements in 'Search Results' collection to be equal '50'\n\t * @example I expect number of elements in 'Search Results' collection to be above '49'\n\t * @example I expect number of elements in 'Search Results' collection to be below '51'\n\t */\n", "Then(\n\t    'I expect number of elements in {string} collection {testcafeValidation} {string}',\n\t    async function (alias: string, validationType: string, value: string) {\n\t        const expectedValue = await getValue(value);\n\t        const collection = await getElement(alias);\n\t        const validation = getValidation(validationType);\n\t        const actualCount = await collection.with({ boundTestRun: t }).count;\n\t        this.log(`AR: ${actualCount}`);\n\t        this.log(`ER: ${expectedValue}`);\n\t        validation(actualCount, expectedValue);\n", "    }\n\t);\n\t/**\n\t * Verify that page title satisfies condition\n\t * @param {string} validationType - validation\n\t * @param {string} expected - expected value\n\t * @example I expect page title equals 'Wikipedia'\n\t */\n\tThen(\n\t    'I expect page title {testcafeValidation} {string}',\n", "    async function (validationType: string, expected: string) {\n\t        const validation = getValidation(validationType);\n\t        const expectedTitle = await getValue(expected);\n\t        const actualTitle = await ClientFunction(() => window.document.title )\n\t            .with({ boundTestRun: t })();\n\t        this.log(`AR: ${actualTitle}`);\n\t        this.log(`ER: ${expectedTitle}`);\n\t        validation(actualTitle, expectedTitle);\n\t    }\n\t);\n", "/**\n\t * Verify that all texts in collection satisfy condition\n\t * @param {string} alias - collection to get texts\n\t * @param {string} validationType - validation\n\t * @param {string} value - expected result\n\t * @example I expect text of every element in 'Search Results' collection equals to 'google'\n\t * @example I expect text of every element in 'Search Results' collection does not contain 'yandex'\n\t */\n\tThen(\n\t    'I expect text of every element in {string} collection {testcafeValidation} {string}',\n", "    async function (alias: string, validationType: string, value: string) {\n\t        const expectedValue = await getValue(value);\n\t        const collection = await getElement(alias);\n\t        const validation = getValidation(validationType);\n\t        const count = await collection.with({ boundTestRun: t }).count;\n\t        for (let i = 0; i < count; i++) {\n\t            const text = await collection.nth(i).with({ boundTestRun: t }).innerText;\n\t            validation(text, expectedValue);\n\t        }\n\t    }\n", ");\n\t/**\n\t * Verify that all particular attributes in collection satisfy condition\n\t * @param {string} alias - collection to get attrs\n\t * @param {string} validationType - validation\n\t * @param {string} value - expected result\n\t * @example I expect 'href' attribute of every element in 'Search Results' collection to contain 'google'\n\t */\n\tThen(\n\t    'I expect {string} attribute of every element in {string} collection {testcafeValidation} {string}',\n", "    async function (attributeKey: string, alias: string, validationType: string, value: string) {\n\t        const attribute = await getValue(attributeKey);\n\t        const expectedValue = await getValue(value);\n\t        const collection = await getElement(alias);\n\t        const validation = getValidation(validationType);\n\t        const count = await collection.with({ boundTestRun: t }).count;\n\t        for (let i = 0; i < count; i++) {\n\t            const attr = await collection.nth(i).with({ boundTestRun: t }).getAttribute(attribute);\n\t            validation(attr, expectedValue);\n\t        }\n", "    }\n\t);\n\t/**\n\t * Verify that all particular properties in collection satisfy condition\n\t * @param {string} alias - collection to get props\n\t * @param {string} validationType - validation\n\t * @param {string} value - expected result\n\t * @example I expect 'href' property of every element in 'Search Results' collection to contain 'google'\n\t */\n\tThen(\n", "    'I expect {string} property of every element in {string} collection {testcafeValidation} {string}',\n\t    async function (propertyKey: string, alias: string, validationType: string, value: string) {\n\t        const property = await getValue(propertyKey);\n\t        const expectedValue = await getValue(value);\n\t        const collection = await getElement(alias);\n\t        const validation = getValidation(validationType);\n\t        const count = await collection.with({ boundTestRun: t }).count;\n\t        for (let i = 0; i < count; i++) {\n\t            // @ts-ignore\n\t            const prop = await collection.nth(i).with({ boundTestRun: t })[property];\n", "            validation(prop, expectedValue);\n\t        }\n\t    }\n\t);\n\t/**\n\t * Verify that css property of element satisfies condition\n\t * @param {string} property - element to verify\n\t * @param {string} alias - element to verify\n\t * @param {string} validationType - validation\n\t * @param {string} value - expected value\n", " * @example I expect 'color' css property of 'Search Input' to be equal 'rgb(42, 42, 42)'\n\t * @example I expect 'font-family' css property of 'Label' to contain 'Fira'\n\t */\n\tThen(\n\t    'I expect {string} css property of {string} {testcafeValidation} {string}',\n\t    async function (property: string, alias: string, validationType: string, value: string) {\n\t        const propertyName = await getValue(property);\n\t        const expectedValue = await getValue(value);\n\t        const element = await getElement(alias);\n\t        const validation = getValidation(validationType);\n", "        const actualValue = await ClientFunction(() => {\n\t            // @ts-ignore\n\t            return getComputedStyle(element()).getPropertyValue(propertyName)\n\t        }, { dependencies: { element, propertyName }}).with({ boundTestRun: t })();\n\t        this.log(`AR: ${actualValue}`);\n\t        this.log(`ER: ${expectedValue}`);\n\t        validation(actualValue, expectedValue);\n\t    }\n\t);\n\t// /**\n", "//  * Verify that text of an alert meets expectation\n\t//  * @param {string} validationType - validation\n\t//  * @param {string} value - expected text value\n\t//  * @example I expect text of alert does not contain 'coffee'\n\t//  */\n\t// Then('I expect text of alert {testcafeValidation} {string}', async function (validationType: string, expectedValue: string) {\n\t//         const alertText = await new Promise<string>(resolve => page.once('dialog', async (dialog) => {\n\t//             resolve(dialog.message());\n\t//         }));\n\t//         const expected = await getValue(expectedValue);\n", "//         const validation = getValidation(validationType);\n\t//         this.log(`AR: ${alertText}`);\n\t//         this.log(`ER: ${expected}`);\n\t//         validation(alertText, expectedValue);\n\t//     }\n\t// );\n"]}
{"filename": "src/testController/bootstrap.ts", "chunked_list": ["import testController from './testController';\n\tfixture`qavajs`;\n\ttest('testcafe', testController.setup);\n"]}
{"filename": "src/testController/testController.ts", "chunked_list": ["const testController = {\n\t    testController: null,\n\t    setup: function(t: TestController) {\n\t        global.t = t;\n\t        return new Promise(() => {});\n\t    },\n\t    get: function() {\n\t        return testController.testController;\n\t    }\n\t};\n", "export default testController;\n"]}
{"filename": "src/utils/screenshotEvent.ts", "chunked_list": ["export enum ScreenshotEvent {\n\t    ON_FAIL = 'onFail',\n\t    BEFORE_STEP = 'beforeStep',\n\t    AFTER_STEP = 'afterStep'\n\t}\n"]}
{"filename": "src/utils/utils.ts", "chunked_list": ["import { ScreenshotEvent } from './screenshotEvent';\n\timport { TraceEvent } from './traceEvent';\n\timport { Status, ITestStepHookParameter, ITestCaseHookParameter } from '@cucumber/cucumber';\n\timport { join } from 'path';\n\timport { readFile } from 'fs/promises';\n\texport function saveScreenshotAfterStep(config: any, step: ITestStepHookParameter): boolean {\n\t    const isAfterStepScreenshot = equalOrIncludes(config.screenshot, ScreenshotEvent.AFTER_STEP);\n\t    const isOnFailScreenshot = equalOrIncludes(config.screenshot, ScreenshotEvent.ON_FAIL);\n\t    return (isOnFailScreenshot && step.result.status === Status.FAILED) || isAfterStepScreenshot\n\t}\n", "export function saveScreenshotBeforeStep(config: any): boolean {\n\t    return equalOrIncludes(config.screenshot, ScreenshotEvent.BEFORE_STEP)\n\t}\n\texport function saveTrace(driverConfig: any, scenario: ITestCaseHookParameter): boolean {\n\t    return driverConfig?.trace && (\n\t        (equalOrIncludes(driverConfig?.trace.event, TraceEvent.AFTER_SCENARIO)) ||\n\t        (scenario.result?.status === Status.FAILED && equalOrIncludes(driverConfig?.trace.event, TraceEvent.ON_FAIL))\n\t    )\n\t}\n\tfunction normalizeScenarioName(name: string): string {\n", "    return name.replace(/\\W/g, '-')\n\t}\n\texport function traceArchive(driverConfig: any, scenario: ITestCaseHookParameter): string {\n\t    return join(\n\t        driverConfig.trace?.dir ?? 'traces',\n\t        `${normalizeScenarioName(scenario.pickle.name)}-${scenario.testCaseStartedId}.zip`\n\t    )\n\t}\n\t/**\n\t * Parse 'x, y' string to coordinates array\n", " * @param {string} coords - 'x, y' string\n\t * @return {number[]} - coords array\n\t */\n\texport function parseCoords(coords: string): number[] {\n\t    return coords.split(/\\s?,\\s?/).map((c: string) => parseFloat(c ?? 0))\n\t}\n\texport function equalOrIncludes(value: string | string[], argument: string) {\n\t    return Array.isArray(value)\n\t        ? value.includes(argument)\n\t        : value === argument;\n", "}\n\texport async function throwTimeoutError(fn: Function, message: string) {\n\t    try {\n\t        await fn()\n\t    } catch (err: any) {\n\t        if (err.message.includes('exceeded while waiting on the predicate')) {\n\t            throw new Error(message);\n\t        }\n\t        throw err\n\t    }\n", "}\n\texport async function takeScreenshot(): Promise<string> {\n\t    const screenshotPath = await t.takeScreenshot();\n\t    const screenshot = await readFile(screenshotPath);\n\t    return screenshot.toString('base64');\n\t}\n\texport function isChromium(browserName: string): boolean {\n\t   return browserName.includes('chrom')\n\t}\n"]}
{"filename": "src/utils/traceEvent.ts", "chunked_list": ["export enum TraceEvent {\n\t    ON_FAIL = 'onFail',\n\t    AFTER_SCENARIO = 'afterScenario'\n\t}\n"]}
