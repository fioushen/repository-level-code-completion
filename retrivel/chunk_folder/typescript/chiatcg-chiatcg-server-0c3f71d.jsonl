{"filename": "src/models.ts", "chunked_list": ["import { appraiseCard } from './appraise';\n\timport { IAuthProvider, IDataSource } from './dependencies';\n\texport const toClientPlayer = (player: IDataSource.IPlayer, authProvider: IAuthProvider) => {\n\t    return {\n\t        ...player,\n\t        authToken: authProvider.getAuthTokenForPlayer(player),\n\t    };\n\t}\n\texport const toClientDeck = (player: IDataSource.IPlayer, deck: IDataSource.ICardDeck | null) => {\n\t    if (!deck) return null;\n", "    return {\n\t        id: deck.createdAt,\n\t        label: deck.label,\n\t        cards: deck.cards.map(appraiseCard),\n\t        isActiveDeck: player.activeDeckId === deck.createdAt,\n\t    };\n\t};"]}
{"filename": "src/appraise.ts", "chunked_list": ["const MINT_HEIGHT_THRESHOLD = 3200000;\n\texport type CoreScriptNames = typeof _CoreScriptNames[IAppraisedCard['faction']][number];\n\texport interface IAppraisedCard {\n\t    nftId: string;\n\t    faction: 'backdoor' | 'bruteforce' | 'malware';\n\t    coreScript: CoreScriptNames;\n\t    tier: number;\n\t    cpu: number;\n\t    mem: number;\n\t    url: string;\n", "}\n\t/**\n\t * Generates card stats based on the number of digits in the last 9 chars of the nftId,\n\t */\n\texport const appraiseCard = ({ nftId, mintHeight, url }: { nftId: string, mintHeight: number, url: string }): IAppraisedCard => {\n\t    // Last 9 chars of the nftId determine the card qualifier, Q\n\t    const Q = nftId.substring(nftId.length - 8).split('');\n\t    // Q[0] determines faction\n\t    //   Since 34 potential characters does not divide cleanly by 3 factions,\n\t    //   distribution will not come out even - Backdoor will appear 10% less than other factions\n", "    let faction: IAppraisedCard['faction'];\n\t    const factionQualifier = Q[0]!.charCodeAt(0);\n\t    if (factionQualifier < 99) faction = 'backdoor'; // 0-9, a, b (10 chars, '1' and 'b' do not exist)\n\t    else if (factionQualifier < 111) faction = 'bruteforce'; // c-n (11 chars, 'i' does not exist)\n\t    else faction = 'malware'; // o-z (11 chars, 'o' does not exist)\n\t    // The sum of the char codes of Q, sumQ, determines faction core script\n\t    const sumQ = Q.reduce((sum, c) => sum + c.charCodeAt(0), 0);\n\t    const coreScripts = _CoreScriptNames[faction];\n\t    const coreScript = coreScripts[sumQ % coreScripts.length]!;\n\t    // Q[2:] is the card statistics qualifier, SQ, each granted statistic increases card tier\n", "    const SQ = Q.slice(2);\n\t    const tier = SQ.reduce((sum, c) => isNaN(+c) ? sum : (sum + 1), 0);\n\t    if (tier < 2 || mintHeight >= MINT_HEIGHT_THRESHOLD) {\n\t        // Less than 2 digits or minted after threshold is a T1; either 1/2 or 2/1\n\t        const singleQualifier = Q[1]; // Only either 's' or 'q'\n\t        const cpu = singleQualifier === 's' ? 2 : 1;\n\t        const mem = 3 - cpu;\n\t        return {\n\t            nftId,\n\t            faction,\n", "            tier: 1,\n\t            cpu,\n\t            mem,\n\t            coreScript,\n\t            url,\n\t        };\n\t    }\n\t    // For each character c in SQ, grant CPU or MEM if c is numeric, nothing otherwise\n\t    //   Since there are only 9 possible digits per character, we use 2-5 for MEM, 6-9 for CPU, 0 is treated special\n\t    let cpu = 1;\n", "    let mem = 1;\n\t    for (const c of SQ) {\n\t        if (+c > 5) {\n\t            cpu++; // 6, 7, 8, 9\n\t        } else if (+c > 0) {\n\t            mem++; // 2, 3, 4, 5 ('1' does not exist)\n\t        } else if (+c === 0) {\n\t            // For 0, we flip a coin on the char code sum of Q which results in 50:50 CPU:MEM distribution\n\t            (sumQ % 2) ? (cpu++) : (mem++);\n\t        }\n", "    }\n\t    return {\n\t        nftId,\n\t        faction,\n\t        tier,\n\t        cpu,\n\t        mem,\n\t        coreScript,\n\t        url,\n\t    };\n", "};\n\tconst _CoreScriptNames = {\n\t    backdoor: [\n\t        'bd_exploit',\n\t        'bd_decode',\n\t        'bd_secure',\n\t    ] as const,\n\t    bruteforce: [\n\t        'bf_firewall',\n\t        'bf_overclock',\n", "        'bf_spam',\n\t    ] as const,\n\t    malware: [\n\t        'mw_redirect',\n\t        'mw_freeware',\n\t        'mw_worm',\n\t    ] as const,\n\t};\n\t(_CoreScriptNames as Record<IAppraisedCard['faction'], readonly string[]>);\n"]}
{"filename": "src/net-utils.ts", "chunked_list": ["export enum StatusCodes {\n\t    ok = 200,\n\t    /**\n\t     *  Missing or incorrect params\n\t     */\n\t    badRequest = 400,\n\t    /**\n\t     * Auth failed\n\t     */\n\t    unauthorized = 401,\n", "    /**\n\t     * Server state is incompatible with request, e.g. leaving a game without being in a game.\n\t     * This could be due to stale state on the client or wrong client logic.\n\t     */\n\t    forbidden = 403, // retry won't help\n\t    /**\n\t     * Resource specified in the request does not exist and it is unknown whether it ever existed\n\t     */\n\t    notFound = 404,\n\t    /**\n", "     * API exists but wrong method was used\n\t     */\n\t    methodNotAllowed = 405,\n\t    /**\n\t     * Request is no longer valid and should start over from handshake.\n\t     */\n\t    timeout = 408,\n\t    /**\n\t     * Request was valid at the time it was received but server state changed since. The request\n\t     * should be retried.\n", "     */\n\t    conflict = 409,\n\t    /**\n\t     * Resource specified in the request did exist at one point but not anymore\n\t     */\n\t    gone = 410,\n\t    /**\n\t     * Slow down\n\t     */\n\t    tooManyRequests = 429,\n", "    /**\n\t     * Uncaught/unhandled server error - should not happen\n\t     */\n\t    internalServerError = 500,\n\t    /**\n\t     * A downstream resource that the server depends on is unavailable\n\t     */\n\t    badGateway = 502, // downstream resource error\n\t    /**\n\t     * Planned outage\n", "     */\n\t    serviceUnavailable = 503,\n\t}\n\texport interface IHttpRequest {\n\t    path: string;\n\t    httpMethod: string;\n\t    headers?: { [header: string]: string; };\n\t    queryStringParameters?: { [header: string]: string; };\n\t    body?: string;\n\t}\n", "export type IHttpRouteHandler = (\n\t    path: string[],\n\t    query: Record<string, string | number>,\n\t    body: Record<string, any>,\n\t    req: IHttpRequest,\n\t) => Promise<[StatusCodes] | [StatusCodes, Record<string, any>] | [StatusCodes, Record<string, any>, Record<string, string>] | undefined>;\n\texport class RouteError extends Error {\n\t    constructor(\n\t        public statusCode: StatusCodes,\n\t        message: string,\n", "    ) {\n\t        super(message);\n\t    }\n\t}"]}
{"filename": "src/extensions.d.ts", "chunked_list": ["declare interface Array<T> {\n\t    findAndRemoveFirst(predicate: (item: T) => boolean): boolean;\n\t    random(): T;\n\t    randomOrUndefined(): T | undefined;\n\t    removeFirst(item: T): boolean;\n\t    filter(booleanCtor: typeof Boolean): NonNullableVoid<T>[];\n\t}\n\tdeclare type NonNullableVoid<T> = Exclude<NonNullable<T>, void>;\n\tdeclare type StringsStartingWith<T extends string, K extends string> = T extends `${K}${infer _X}` ? T : never;\n\tdeclare type KeyOfFilteredByValueType<T, F> = NonNullable<{ [K in keyof T]: T[K] extends F ? K : never }[keyof T]>;\n", "declare type TypeConstructor<T> = { new(...args: any[]): T };"]}
{"filename": "src/dependencies.d.ts", "chunked_list": ["import { GameEngine } from './game/game-engine';\n\timport { IHttpRequest } from './net-utils';\n\tdeclare namespace IDataSource {\n\t    export type GetterSingle<MODEL> = (id: string) => Promise<MODEL | null>;\n\t    export type GetterPair<MODEL> = (id1: string, id2: string) => Promise<MODEL | null>;\n\t    export type UpdateRequest = any;\n\t    export type Updater<MODEL> = {\n\t        /**\n\t         * Creates an UpdateRequest for the specified item that can be used with execUpdates(...).\n\t         */\n", "        make(item: MODEL, overwrite?: boolean): UpdateRequest;\n\t        /**\n\t         * Updates the specified item. Fails if the specified item has changed since it was retrieved if `overwrite` is true.\n\t         */\n\t        exec(item: MODEL, overwrite?: boolean): Promise<typeof item>;\n\t    };\n\t    export type Query<KEY, MODEL> = (key: NonNullable<KEY>, limit?: number, ct?: string) => Promise<{ items: MODEL[]; ct?: typeof ct; }>;\n\t    export interface ICardDeck {\n\t        readonly playerId: string;\n\t        readonly createdAt: string;\n", "        cards: { nftId: string, mintHeight: number, url: string }[];\n\t        label: string;\n\t    }\n\t    export type CardDecks = {\n\t        get: GetterPair<ICardDeck>;\n\t        update: Updater<ICardDeck>;\n\t        queryByDid: Query<ICardDeck['playerId'], ICardDeck>;\n\t    };\n\t    export interface ICoopGame {\n\t        id: string;\n", "        difficulty: number;\n\t        createdAt: string;\n\t        gameState: 'open' | 'private' | `ended_${string}`;\n\t        playersIds: Set<string>;\n\t        ingorePlayerIds: Set<string>;\n\t        startedAt: string;\n\t        endedAt: string;\n\t        isCompleted: boolean;\n\t        _dbTtl?: number;\n\t    }\n", "    export type CoopGames = {\n\t        get: GetterSingle<ICoopGame>;\n\t        update: Updater<ICoopGame>;\n\t        queryByGameState: Query<ICoopGame['gameState'], ICoopGame>;\n\t    };\n\t    export interface IPlayer {\n\t        id: string;\n\t        createdAt: string;\n\t        lastSeenAt: string;\n\t        secret: string;\n", "        authExpiresAt: string;\n\t        activeGameId: string;\n\t        activeDeckId: string;\n\t        score: number;\n\t    }\n\t    export type Players = {\n\t        get: GetterSingle<IPlayer>;\n\t        update: Updater<IPlayer>;\n\t    };\n\t    export interface IPlayerCoopGame {\n", "        playerId: string;\n\t        endedAt: string;\n\t        gameId: string;\n\t        gameResult: 'win' | 'loss' | 'abandoned' | 'unknown';\n\t        teammates: string[];\n\t        score: number;\n\t        turns: number;\n\t        difficulty: number;\n\t        rulesetIds: string[];\n\t    }\n", "    export type PlayerCoopGame = {\n\t        update: Updater<IPlayerCoopGame>;\n\t        queryByPlayerId: Query<string, IPlayerCoopGame>;\n\t    }\n\t    export type GameData = {\n\t        get: GetterSingle<GameEngine.IGameData>;\n\t        update: Updater<GameEngine.IGameData>;\n\t    };\n\t    export type Leaderboard = {\n\t        getTopN(n: number): Promise<[string, number][]>;\n", "        set(playerId: string, score: number): Promise<void>;\n\t    };\n\t}\n\tdeclare interface IDataSource {\n\t    CardDecks: IDataSource.CardDecks;\n\t    CoopGames: IDataSource.CoopGames;\n\t    GameData: IDataSource.GameData;\n\t    Leaderboard: IDataSource.Leaderboard;\n\t    PlayerCoopGames: IDataSource.PlayerCoopGame;\n\t    Players: IDataSource.Players;\n", "    /**\n\t     * Transactionlly executes all UpdateRequests; no changes are made if any one of the UpdateRquests fail.\n\t     */\n\t    execUpdates(...updateRequests: IDataSource.UpdateRequest[]): Promise<void>;\n\t}\n\tdeclare interface IAuthProvider {\n\t    generateNewSecret(): string;\n\t    getAuthTokenForPlayer(player: IDataSource.IPlayer): string;\n\t    getPlayerFromRequest(req: IHttpRequest): Promise<IDataSource.IPlayer>;\n\t    getPlayerIdFromRequest(req: IHttpRequest): string;\n", "}\n\tdeclare namespace IPlayerPushProvider {\n\t    export interface IPushMessage {\n\t        [key: string]: any;\n\t        type: string;\n\t    }\n\t}\n\tdeclare interface IPlayerPushProvider {\n\t    push(playerId: string, messages: IPlayerPushProvider.IPushMessage[]): Promise<void>;\n\t}\n", "declare interface IRateLimitProvider {\n\t    shouldRateLimitCreateGame(playerId: string): Promise<boolean>;\n\t    shouldRateLimitSearchGame(playerId: string): Promise<boolean>;\n\t}\n\tdeclare interface IMetricsProvider {\n\t    userPresence(playerId: string): void;\n\t    httpRequest(path: string, status: number): void;\n\t    wsRequest(api: string, isSuccess: boolean): void;\n\t    newUser(playerId: string): void;\n\t    deckUpdated(playerId: string, deckId: string): void;\n", "    nftOwnershipConflict(playerId: string): void;\n\t    gameCreated(gameId: string, playerId: string, initialRulesetId: string, visibility: string, difficulty: number): void;\n\t    gameStarted(gameId: string, initialRulesetId: string, players: string[], fromMatchmaking: boolean): void;\n\t    gameJoined(gameId: string, midGame: boolean): void;\n\t    gameEnded(gameId: string, result: string, rulesets: string[], players: string[], turns: number, totalScore: number): void;\n\t    playerCardPlayed(gameId: string, currentRulesetId: string, playerId: string, card: GameEngine.IPlayerCardState, scriptName: string): void;\n\t    idlePlayerRemoved(gameId: string, idlePlayerId: string): void;\n\t    flush(): Promise<void>;\n\t}"]}
{"filename": "src/reference-example.ts", "chunked_list": ["import * as moment from 'moment';\n\timport { createCoopHandler } from './apis/coop.api';\n\timport { IAuthProvider, IDataSource, IPlayerPushProvider, IRateLimitProvider } from './dependencies';\n\timport { CardMod } from './game/card-mods';\n\timport { CardScript } from './game/card-scripts';\n\timport { GameEngine, createGameEngineProvider } from './game/game-engine';\n\timport { GameEngineUtils } from './game/game-engine-utils';\n\timport { IHttpRequest, IHttpRouteHandler, StatusCodes } from './net-utils';\n\timport { FULL_DATETIME_FORMAT } from './utils';\n\t/**\n", " * Main entry point\n\t */\n\t// TODO: this should be replaced with node:http or expressjs\n\texport const handleRequest = async (req: IHttpRequest) => {\n\t    const split = req.path.split('/').filter(Boolean);\n\t    const subPath = split.slice(1);\n\t    const body = req.body ? JSON.parse(req.body) : null;\n\t    const query = req.queryStringParameters || {};\n\t    let handler: IHttpRouteHandler | undefined = undefined;\n\t    switch (split[0]) {\n", "        case 'coop':\n\t            handler = coopHandler;\n\t        // ... Note: implement remaining route handlers\n\t    }\n\t    const result = handler ? (await handler(subPath, query, body, req)) : null;\n\t    return result || [StatusCodes.badRequest, { reason: 'invalid api' }];\n\t};\n\t/**\n\t * Dependencies\n\t */\n", "// Note: replace with an actual database\n\tconst cardDecksTable = createMockTableDualKey<IDataSource.ICardDeck>('playerId', 'createdAt');\n\tconst coopGamesTable = createMockTableSingleKey<IDataSource.ICoopGame>('id');\n\tconst playersTable = createMockTableSingleKey<IDataSource.IPlayer>('id');\n\tconst playerCoopGamesTable = createMockTableSingleKey<IDataSource.IPlayerCoopGame>('playerId');\n\tconst dataSource: IDataSource = {\n\t    CardDecks: {\n\t        ...cardDecksTable,\n\t        async queryByDid(did) {\n\t            return { items: [...cardDecksTable._db.values()].filter(x => x.playerId === did) };\n", "        },\n\t    },\n\t    CoopGames: {\n\t        ...coopGamesTable,\n\t        async queryByGameState(gameState) {\n\t            return { items: [...coopGamesTable._db.values()].filter(x => x.gameState === gameState) };\n\t        },\n\t    },\n\t    GameData: {\n\t        ...createMockTableSingleKey<GameEngine.IGameData>('id'),\n", "    },\n\t    Players: {\n\t        ...playersTable,\n\t    },\n\t    PlayerCoopGames: {\n\t        ...playerCoopGamesTable,\n\t        async queryByPlayerId(playerId: string) {\n\t            return { items: [...playerCoopGamesTable._db.values()].filter(x => x.playerId === playerId) };\n\t        },\n\t    },\n", "    Leaderboard: {\n\t        getTopN(_n) { return [] as any; },\n\t        async set(_playerId, _score) { },\n\t    },\n\t    async execUpdates(...updateRequests) {\n\t        updateRequests.forEach(x => x());\n\t    },\n\t};\n\t// Note: replace with an actual auth provider\n\tconst authProvider: IAuthProvider = {\n", "    generateNewSecret: () => `${Math.random()}`,\n\t    getAuthTokenForPlayer: player => player.secret,\n\t    getPlayerFromRequest: async () => [...playersTable._db.values()][0]!,\n\t    getPlayerIdFromRequest: () => [...playersTable._db.values()][0]?.id!,\n\t};\n\t// Note: replace with an actual push provider\n\tconst pushProvider: IPlayerPushProvider = {\n\t    async push(playerId, messages) {\n\t        console.log(`Push messages for player [${playerId}]:`);\n\t        messages.forEach(x => console.log(x));\n", "    }\n\t};\n\tconst rateLimitProvider: IRateLimitProvider = {\n\t    async shouldRateLimitCreateGame(_playerId) {\n\t        return false;\n\t    },\n\t    async shouldRateLimitSearchGame(_playerId) {\n\t        return false;\n\t    },\n\t};\n", "// Note: replace with custom game content\n\tconst gameContent: GameEngine.IRuleset = {\n\t    cardMods: { /** Custom card modifiers **/ },\n\t    cardScripts: { /** Custom card scripts **/ },\n\t    initGame(engine) {\n\t        const testEnemy: GameEngine.IEnemyCardState = {\n\t            id: engine.nextId(),\n\t            enemyClass: 'testEnemy',\n\t            cpu: 1,\n\t            mem: 1,\n", "            maxMem: 1,\n\t            mods: [],\n\t            scripts: [],\n\t            sec: 10,\n\t        };\n\t        testEnemy.mods.push(new CardMod.Content._standardAi().serialize());\n\t        testEnemy.scripts.push(new CardScript.Content._attack(testEnemy, engine.gameData.difficulty).serialize());\n\t        GameEngineUtils.addEnemy(engine, testEnemy, 0, true);\n\t    },\n\t    addAdditionalScriptsFor(_card) {\n", "        // Note: Called by GameEngine when a player is joined; this hook allows for dynamic scripts for a given card\n\t    },\n\t};\n\tconst gameEngine = createGameEngineProvider({ mfrm: gameContent }, dataSource, pushProvider);\n\tconst coopHandler = createCoopHandler(dataSource, gameEngine, authProvider, rateLimitProvider);\n\t/**\n\t * Example\n\t */\n\t(async () => {\n\t    /**\n", "     * Players are normally created via /players/connectDid; to keep this example concise,\n\t     * we'll inject one with CO8's DID into the mock database.\n\t     */\n\t    const mockPlayer = {\n\t        id: 'did:chia:1sc5hxvcs26e4zsc7uvlfuc7x9sjj5aw6cu0g8vcyvscy49ffp8zqwh63tq',\n\t        activeDeckId: '',\n\t        activeGameId: '',\n\t        secret: '',\n\t        authExpiresAt: '2100-01-01',\n\t        createdAt: moment.utc().format(FULL_DATETIME_FORMAT),\n", "        lastSeenAt: moment.utc().format(FULL_DATETIME_FORMAT),\n\t        score: 0,\n\t    }\n\t    playersTable._db.set(mockPlayer.id, mockPlayer);\n\t    /**\n\t     * This calls into /coop/create which is a complex API.\n\t     * Step thru this to learn about how the route handlers work.\n\t     */\n\t    console.log('Creating game...');\n\t    await handleRequest({\n", "        httpMethod: 'POST',\n\t        path: '/coop/create',\n\t        body: JSON.stringify({\n\t            gameVisibility: 'private',\n\t            difficulty: 1,\n\t        }),\n\t    });\n\t    console.log('Game created, gameId: ' + mockPlayer.activeGameId);\n\t    /**\n\t     * Games normally start automatically when enough players join via /coop/join or /coop/search,\n", "     * to keep this example concise, we'll start it directly via the gameEngine reference.\n\t     * Step thru this to learn about how the game engine works.\n\t     */\n\t    console.log('Starting game...');\n\t    await gameEngine.startGame(mockPlayer.activeGameId);\n\t})();\n\t/**\n\t * In-memory DB helpers\n\t * Note: this is a mock database that only satisfies the example above and is\n\t * not meant to be starting point for production.\n", " */\n\tfunction createMockTableSingleKey<T extends Record<string, any>>(idKey: keyof T) {\n\t    const _db = new Map<string, T>();\n\t    return {\n\t        _db,\n\t        async get(id: string) {\n\t            return _db.get(id) || null;\n\t        },\n\t        update: {\n\t            make(item: T) {\n", "                return () => this.exec(item);\n\t            },\n\t            async exec(item: T) {\n\t                _db.set(item[idKey], item);\n\t                return item;\n\t            },\n\t        },\n\t    };\n\t}\n\tfunction createMockTableDualKey<T extends Record<string, any>>(id1Key: keyof T, id2Key: keyof T) {\n", "    const _db = new Map<string, T>();\n\t    return {\n\t        _db,\n\t        async get(id1: string, id2: string) {\n\t            return _db.get(`${id1}_${id2}`) || null;\n\t        },\n\t        update: {\n\t            make(item: T) {\n\t                return () => this.exec(item);\n\t            },\n", "            async exec(item: T) {\n\t                _db.set(`${item[id1Key]}_${item[id2Key]}`, item);\n\t                return item;\n\t            },\n\t        },\n\t    };\n\t}\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import './extensions';\n\texport const FULL_DATETIME_FORMAT = 'YYYY-MM-DDTHH:mm:ss';\n\texport const DATE_FORMAT = 'YYYY-MM-DD';\n\texport const SECS_IN_MIN = 60;\n\texport const MINS_IN_HOUR = 60;\n\texport const HOURS_IN_DAY = 24;\n\texport const SECS_IN_HOUR = SECS_IN_MIN * MINS_IN_HOUR;\n\texport const MINS_IN_DAY = MINS_IN_HOUR * HOURS_IN_DAY;\n\texport const SECS_IN_DAY = MINS_IN_DAY * SECS_IN_MIN;\n\texport const jsonReplacer = (_: string, value: any) => {\n", "    if (value instanceof Map) {\n\t        return {\n\t            __reviverType: 'map',\n\t            value: Object.fromEntries(value.entries()),\n\t        };\n\t    }\n\t    return value;\n\t};\n\texport const jsonReviver = (_: string, value: any) => {\n\t    if (value?.__reviverType === 'map') {\n", "        return new Map(Object.entries(value.value));\n\t    }\n\t    return value;\n\t};\n\texport const clamp = (value: number, min: number, max: number) => {\n\t    return value < min ? min : (value > max) ? max : value;\n\t}\n\texport const rand = (minIncl: number, maxExcl: number) =>\n\t    minIncl + Math.random() * (maxExcl - minIncl);\n\texport const randInt = (min: number, max: number) =>\n", "    Math.round(rand(min, max));\n\texport const round = (num: number, precision: number) =>\n\t    +num.toFixed(precision);"]}
{"filename": "src/external-dependencies.ts", "chunked_list": ["///<reference lib='dom' />\n\texport namespace ExtDeps {\n\t    export interface INft {\n\t        nftId: string;\n\t        wallet: string;\n\t        firstBlock: number;\n\t        lastBlock: number;\n\t        urls: string[];\n\t        did?: string;\n\t    }\n", "    export interface IDidProof {\n\t        latestCoinId: string;\n\t        pubkey: string;\n\t        signature: string;\n\t        message: string;\n\t    };\n\t    export async function getNft(nftId: string) {\n\t        try {\n\t            const resp = await fetch('https://api.chiapi.io/v0/nfts/' + nftId);\n\t            if (resp.ok) {\n", "                return await resp.json() as { nft: INft };\n\t            }\n\t        } catch {\n\t        }\n\t        return null;\n\t    }\n\t    export async function getNftsByDidOrWallet(didOrWallet: string, count?: number, ct?: string) {\n\t        try {\n\t            const queryParams = [count && `count=${count}`, ct && `ct=${ct}`].filter(Boolean);\n\t            const query = queryParams.length ? `?${queryParams.join('&')}` : '';\n", "            const resp = await fetch(`https://api.chiapi.io/v0/nfts/${didOrWallet}${query}`);\n\t            return await resp.json() as { nfts: INft[], ct?: string };\n\t        } catch {\n\t        }\n\t        return null;\n\t    }\n\t    export async function verifyDidProof(proof: IDidProof) {\n\t        try {\n\t            const resp = await fetch(`https://api.chiapi.io/v0/dids/verify`, {\n\t                method: 'POST',\n", "                body: JSON.stringify({ proof }),\n\t                headers: {\n\t                    'content-type': 'application/json',\n\t                },\n\t            });\n\t            return await resp.json() as { did: string };\n\t        } catch {\n\t        }\n\t        return null;\n\t    }\n", "}"]}
{"filename": "src/extensions.ts", "chunked_list": ["/// <reference path='extensions.d.ts' />\n\tArray.prototype.removeFirst = function (item) {\n\t    const i = this.indexOf(item);\n\t    if (i === -1) return false;\n\t    this.splice(i, 1);\n\t    return true;\n\t};\n\tArray.prototype.findAndRemoveFirst = function (predicate) {\n\t    for (let i = 0; i < this.length; i++) {\n\t        if (predicate(this[i])) {\n", "            this.splice(i, 1);\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t};\n\tArray.prototype.random = function () {\n\t    const item = this.randomOrUndefined();\n\t    if (!item) {\n\t        throw new Error('Array is empty');\n", "    }\n\t    return item;\n\t};\n\tArray.prototype.randomOrUndefined = function () {\n\t    if (!this.length) return undefined;\n\t    return this[Math.random() * this.length | 0];\n\t};"]}
{"filename": "src/apis/cards.api.ts", "chunked_list": ["import { appraiseCard } from '../appraise';\n\timport { ExtDeps } from '../external-dependencies';\n\timport { IHttpRouteHandler, StatusCodes } from \"../net-utils\";\n\texport const createCardsHandler = (): IHttpRouteHandler => {\n\t    return async (path, query) => {\n\t        const id = path[0];\n\t        if (id) {\n\t            if (id.startsWith('xch1') || id.startsWith('did:chia:1')) {\n\t                return _handleCardsDidOrXch(id, query.ct as string, +(query.count || 5));\n\t            }\n", "            if (id.startsWith('nft1')) {\n\t                return _handleCardsNft(id);\n\t            }\n\t        }\n\t        return [StatusCodes.badRequest, { reason: 'invalid id' }];\n\t    };\n\t    async function _handleCardsNft(nftId: string): Promise<ReturnType<IHttpRouteHandler>> {\n\t        const resp = await ExtDeps.getNft(nftId);\n\t        if (resp?.nft) {\n\t            return [StatusCodes.ok, {\n", "                card: {\n\t                    ...appraiseCard({ nftId: resp.nft.nftId, mintHeight: resp.nft.firstBlock, url: resp.nft.urls[0] || '' }),\n\t                    urls: resp.nft.urls,\n\t                },\n\t            }];\n\t        }\n\t        return [StatusCodes.notFound, { reason: 'nft not found' }];\n\t    }\n\t    async function _handleCardsDidOrXch(did: string, ct?: string, count = 5): Promise<ReturnType<IHttpRouteHandler>> {\n\t        const resp = await ExtDeps.getNftsByDidOrWallet(did, count, ct);\n", "        if (resp?.nfts.length) {\n\t            return [StatusCodes.ok, {\n\t                cards: resp.nfts.map(nft => ({\n\t                    ...appraiseCard({ nftId: nft.nftId, mintHeight: nft.firstBlock, url: nft.urls[0] || '' }),\n\t                    urls: nft.urls,\n\t                })),\n\t                ct: resp.ct,\n\t            }];\n\t        }\n\t        return [StatusCodes.notFound, { reason: 'no nfts found' }];\n", "    }\n\t}"]}
{"filename": "src/apis/decks.api.ts", "chunked_list": ["import * as moment from 'moment';\n\timport { z } from 'zod';\n\timport { IAuthProvider, IDataSource, IMetricsProvider } from '../dependencies';\n\timport { ExtDeps } from '../external-dependencies';\n\timport { toClientDeck, toClientPlayer } from '../models';\n\timport { IHttpRouteHandler, StatusCodes } from '../net-utils';\n\timport { FULL_DATETIME_FORMAT } from '../utils';\n\texport const createDeckHandler = (ds: IDataSource, authProvider: IAuthProvider, metrics?: IMetricsProvider): IHttpRouteHandler =>\n\t    async (path, query, body, req) => {\n\t        switch (path[0]) {\n", "            case 'activate': {\n\t                const schema = z.object({\n\t                    deckId: z.string(),\n\t                });\n\t                const payload = schema.parse(body);\n\t                const player = await authProvider.getPlayerFromRequest(req);\n\t                const deck = await ds.CardDecks.get(player.id, payload.deckId);\n\t                if (!deck) return [StatusCodes.notFound];\n\t                player.activeDeckId = deck.createdAt;\n\t                await ds.Players.update.exec(player);\n", "                return [StatusCodes.ok, { player: toClientPlayer(player, authProvider), deck: toClientDeck(player, deck) }];\n\t            }\n\t            case 'create': {\n\t                const schema = z.object({\n\t                    deckLabel: z.string().min(1).max(20),\n\t                    nftIds: z.array(z.string().startsWith('nft1')).length(6),\n\t                });\n\t                const payload = schema.parse(body);\n\t                const player = await authProvider.getPlayerFromRequest(req);\n\t                const nfts = (await Promise.all((payload.nftIds).slice(0, 6).map(ExtDeps.getNft))).filter(Boolean).map(x => x.nft);\n", "                if (nfts.length !== 6) {\n\t                    return [StatusCodes.forbidden, { reason: `not enough nftIds, need 6, got ${nfts.length}` }];\n\t                }\n\t                const deck = await ds.CardDecks.update.exec({\n\t                    playerId: player.id,\n\t                    createdAt: moment.utc().format(FULL_DATETIME_FORMAT),\n\t                    label: payload.deckLabel,\n\t                    cards: nfts.map(x => ({ nftId: x.nftId, mintHeight: x.firstBlock, url: x.urls[0] || '' })),\n\t                });\n\t                metrics?.deckUpdated(player.id, deck.createdAt);\n", "                return [StatusCodes.ok, { deck: toClientDeck(player, deck) }];\n\t            }\n\t            case 'list': {\n\t                const schema = z.object({\n\t                    ct: z.string().optional(),\n\t                });\n\t                const q = schema.parse(query);\n\t                const player = await authProvider.getPlayerFromRequest(req);\n\t                const decks = await Promise.all((await ds.CardDecks.queryByDid(player.id, 10, q.ct)).items);\n\t                if (!decks.length) {\n", "                    const defaultDeck = await getOrCreateActiveDeck(player, ds);\n\t                    defaultDeck && decks.push(defaultDeck)\n\t                }\n\t                return [StatusCodes.ok, { decks: decks.map(deck => toClientDeck(player, deck)) }];\n\t            }\n\t            case 'update': {\n\t                const schema = z.object({\n\t                    deckId: z.string(),\n\t                    deckLabel: z.string().min(1).max(20),\n\t                    nftIds: z.array(z.string().startsWith('nft1')).length(6),\n", "                });\n\t                const payload = schema.parse(body);\n\t                const uniqueNftIds = new Set<string>(payload.nftIds);\n\t                if (uniqueNftIds.size !== 6) {\n\t                    return [StatusCodes.badRequest, { reason: 'nftIds must contain 6 unique NFT ids that belong to the player' }];\n\t                }\n\t                const player = await authProvider.getPlayerFromRequest(req);\n\t                const deck = await ds.CardDecks.get(player.id, payload.deckId);\n\t                if (!deck) {\n\t                    return [StatusCodes.notFound, { reason: 'invalid deck id' }];\n", "                }\n\t                payload.deckLabel && (deck.label = deck.label);\n\t                const nfts = (await Promise.all((payload.nftIds).map(ExtDeps.getNft))).filter((x): x is NonNullable<typeof x> => x?.nft.did === player.id).map(x => x.nft);\n\t                if (nfts.length !== payload.nftIds.length) {\n\t                    return [StatusCodes.notFound, { reason: 'one or more nft ids were not found, or did not belong to the player' }];\n\t                }\n\t                deck.cards = nfts.map(x => ({ nftId: x.nftId, mintHeight: x.firstBlock, url: x.urls[0] || '' }));\n\t                await ds.CardDecks.update.exec(deck);\n\t                metrics?.deckUpdated(player.id, deck.createdAt);\n\t                return [StatusCodes.ok, { deck: toClientDeck(player, deck) }];\n", "            }\n\t            case 'activeDeck': {\n\t                const player = await authProvider.getPlayerFromRequest(req);\n\t                return [StatusCodes.ok, { deck: toClientDeck(player, await getOrCreateActiveDeck(player, ds)) }];\n\t            }\n\t            default: {\n\t                if (!path[0]) {\n\t                    return;\n\t                }\n\t                const player = await authProvider.getPlayerFromRequest(req);\n", "                const deck = await ds.CardDecks.get(player.id, path[0]);\n\t                if (!deck) {\n\t                    return [StatusCodes.notFound];\n\t                }\n\t                return [StatusCodes.ok, { deck: toClientDeck(player, deck) }];\n\t            }\n\t        }\n\t    };\n\texport const getOrCreateActiveDeck = async (player: IDataSource.IPlayer, ds: IDataSource) => {\n\t    let deck = player.activeDeckId ? (await ds.CardDecks.get(player.id, player.activeDeckId)) : null;\n", "    if (deck) {\n\t        return deck;\n\t    }\n\t    const cards = (await ExtDeps.getNftsByDidOrWallet(player.id, 6))?.nfts.filter(Boolean) || [];\n\t    if (cards.length < 6) {\n\t        return null;\n\t    }\n\t    const nowStr = moment.utc().format(FULL_DATETIME_FORMAT);\n\t    player.activeDeckId = nowStr;\n\t    deck = {\n", "        playerId: player.id,\n\t        createdAt: nowStr,\n\t        cards: cards.map(x => ({ nftId: x.nftId, mintHeight: x.firstBlock, url: x.urls[0] || '' })),\n\t        label: 'default',\n\t    };\n\t    await ds.execUpdates(\n\t        ds.Players.update.make(player, true),\n\t        ds.CardDecks.update.make(deck, true),\n\t    );\n\t    return deck;\n", "};"]}
{"filename": "src/apis/coop.api.ts", "chunked_list": ["import { randomBytes } from 'crypto';\n\timport * as moment from 'moment';\n\timport { z } from 'zod';\n\timport { appraiseCard } from '../appraise';\n\timport { IAuthProvider, IDataSource, IMetricsProvider, IRateLimitProvider } from '../dependencies';\n\timport { ExtDeps } from '../external-dependencies';\n\timport { GameEngine, GameEngineProvider } from '../game/game-engine';\n\timport { toClientPlayer } from '../models';\n\timport { IHttpRequest, IHttpRouteHandler, RouteError, StatusCodes } from '../net-utils';\n\timport { DATE_FORMAT, FULL_DATETIME_FORMAT } from '../utils';\n", "import { getOrCreateActiveDeck } from './decks.api';\n\texport const createCoopHandler = (ds: IDataSource, gameEngineProvider: GameEngineProvider, authProvider: IAuthProvider, rateLimit: IRateLimitProvider, metrics?: IMetricsProvider): IHttpRouteHandler => {\n\t    return async function handler(path, query, body, req): ReturnType<IHttpRouteHandler> {\n\t        switch (path[0]) {\n\t            case 'create': {\n\t                const schema = z.object({\n\t                    gameVisibility: z.union([z.literal('public'), z.literal('private'), z.literal('solo')]),\n\t                    difficulty: z.number(),\n\t                });\n\t                const payload = schema.parse(body);\n", "                const player = await _expectAuthPlayerNotInGame(req);\n\t                const deck = await _expectValidActiveDeck(player, true);\n\t                if (await rateLimit.shouldRateLimitCreateGame(player.id)) {\n\t                    return [StatusCodes.tooManyRequests];\n\t                }\n\t                const now = moment.utc();\n\t                const game: IDataSource.ICoopGame = {\n\t                    id: randomBytes(16).toString('hex'),\n\t                    createdAt: now.format(FULL_DATETIME_FORMAT),\n\t                    difficulty: payload.difficulty,\n", "                    playersIds: new Set([player.id]),\n\t                    gameState: payload.gameVisibility === 'public' ? 'open' : 'private',\n\t                    startedAt: '',\n\t                    endedAt: '',\n\t                    ingorePlayerIds: new Set(),\n\t                    isCompleted: false,\n\t                    _dbTtl: moment.utc(now).add({ days: 1 }).unix(),\n\t                };\n\t                const initialRulesetId = 'mfrm';\n\t                metrics?.gameCreated(game.id, player.id, initialRulesetId, payload.gameVisibility, payload.difficulty);\n", "                await gameEngineProvider.createGame(game.id, initialRulesetId, payload.difficulty);\n\t                await gameEngineProvider.addPlayer(game.id, player.id, deck.cards.map(x => x.nftId));\n\t                if (payload.gameVisibility === 'solo') {\n\t                    await _onGameStart(game, false);\n\t                }\n\t                player.activeGameId = game.id;\n\t                await ds.execUpdates(\n\t                    ds.CoopGames.update.make(game),\n\t                    ds.Players.update.make(player),\n\t                );\n", "                return [StatusCodes.ok, { player: toClientPlayer(player, authProvider), status: 'gamecreated' }];\n\t            }\n\t            case 'history': {\n\t                const playerId = authProvider.getPlayerIdFromRequest(req);\n\t                const games = await ds.PlayerCoopGames.queryByPlayerId(playerId, +(query.count || 10), query.ct ? `${query.ct}` : undefined);\n\t                return [StatusCodes.ok, games];\n\t            }\n\t            case 'join': {\n\t                const schema = z.object({\n\t                    teammateDid: z.string().nonempty(),\n", "                    fromMatchmaking: z.boolean().optional(),\n\t                });\n\t                const payload = schema.parse(body);\n\t                const [player, teammate] = await Promise.all([\n\t                    _expectAuthPlayerNotInGame(req),\n\t                    ds.Players.get(payload.teammateDid),\n\t                ]);\n\t                if (!teammate?.activeGameId) {\n\t                    return [StatusCodes.notFound];\n\t                }\n", "                const [deck, game] = await Promise.all([\n\t                    _expectValidActiveDeck(player, true),\n\t                    _expectCoopGameJoinable(teammate.activeGameId),\n\t                ]);\n\t                const gameData = await gameEngineProvider.addPlayer(game.id, player.id, deck.cards.map(x => x.nftId));\n\t                player.activeGameId = game.id;\n\t                game.playersIds.add(player.id);\n\t                game.ingorePlayerIds.delete(player.id);\n\t                await ds.execUpdates(\n\t                    ds.Players.update.make(player),\n", "                    ds.CoopGames.update.make(game),\n\t                );\n\t                if (!game.startedAt && game.playersIds.size >= 2) {\n\t                    await _onGameStart(game, !!payload.fromMatchmaking);\n\t                }\n\t                metrics?.gameJoined(game.id, gameData.turn >= 2);\n\t                return [StatusCodes.ok, { player: toClientPlayer(player, authProvider), status: 'gamejoined' }];\n\t            }\n\t            case 'leave': {\n\t                const { player, game } = await _expectAuthPlayerInGame(req);\n", "                player.activeGameId = '';\n\t                if (!game.gameState.startsWith('ended')) {\n\t                    game.playersIds.delete(player.id);\n\t                    game.ingorePlayerIds.add(player.id);\n\t                }\n\t                await ds.execUpdates(\n\t                    ds.Players.update.make(player),\n\t                    ds.CoopGames.update.make(game),\n\t                );\n\t                try {\n", "                    const gameData = await gameEngineProvider.getGameData(game.id);\n\t                    const playerState = gameData.players.get(player.id);\n\t                    if (!game.gameState.startsWith('ended') && playerState && gameData.state !== 'created' && gameData.turn > 1) {\n\t                        const now = moment.utc().format(FULL_DATETIME_FORMAT);\n\t                        await ds.PlayerCoopGames.update.exec({\n\t                            playerId: player.id,\n\t                            endedAt: now,\n\t                            gameId: game.id,\n\t                            gameResult: _getGameResult(gameData),\n\t                            score: playerState.score,\n", "                            teammates: _getOtherPlayerIds(player.id, game),\n\t                            turns: gameData.turn,\n\t                            difficulty: gameData.difficulty,\n\t                            rulesetIds: gameData.rulesetIds,\n\t                        }, true);\n\t                    }\n\t                } catch (e: any) {\n\t                    console.error(e);\n\t                }\n\t                try {\n", "                    await gameEngineProvider.removePlayer(game.id, player.id, 'leave');\n\t                } catch {\n\t                    // Respect the player's request to leave even if the gameData couldn't be updated for some reason\n\t                }\n\t                if (!game.playersIds.size) {\n\t                    await finalizeGame(game.id, true, ds, gameEngineProvider, metrics);\n\t                }\n\t                return [StatusCodes.ok, { player: toClientPlayer(player, authProvider) }];\n\t            }\n\t            case 'rankings': {\n", "                const rankings = await ds.Leaderboard.getTopN(20);\n\t                return [StatusCodes.ok, { rankings }];\n\t            }\n\t            case 'search': {\n\t                const player = await _expectAuthPlayerNotInGame(req);\n\t                // Don't need to validate nft ownership yet, either join() or create() will do this\n\t                const deck = await _expectValidActiveDeck(player, false);\n\t                let ct: any = undefined;\n\t                do {\n\t                    const result = await ds.CoopGames.queryByGameState('open', 10, ct);\n", "                    const games = result.items.sort((a, b) => a.ingorePlayerIds.size - b.ingorePlayerIds.size);\n\t                    for (const game of games) {\n\t                        if (game.playersIds.size < 2 && !game.ingorePlayerIds.has(player.id)) {\n\t                            const gameData = await ds.GameData.get(game.id);\n\t                            if (!gameData || !game.playersIds.size) {\n\t                                // GameData already TTL'd this is a dead session\n\t                                await finalizeGame(game.id, true, ds, gameEngineProvider, metrics);\n\t                                continue;\n\t                            }\n\t                            if (gameData.players.size >= 2 || (gameData.state !== 'created' && gameData.state !== 'started')) {\n", "                                // Game is full or not in a joinable state\n\t                                continue;\n\t                            }\n\t                            if (await rateLimit.shouldRateLimitSearchGame(player.id)) {\n\t                                return [StatusCodes.tooManyRequests];\n\t                            }\n\t                            return await handler(['join'], {}, { teammateDid: [...gameData.pendingPlayers.keys()][0] || [...gameData.players.keys()][0], fromMatchmaking: true }, req);\n\t                        }\n\t                    }\n\t                    ct = result.ct;\n", "                } while (ct);\n\t                // No joinable game found - proceed to create a public game\n\t                const difficulty = body?.difficulty || (1 + (deck.cards.map(appraiseCard).reduce((sum, x) => sum + x.tier, 0) / deck.cards.length) | 0);\n\t                return await handler(['create'], {}, { gameVisibility: 'public', difficulty }, req);\n\t            }\n\t            case 'start': {\n\t                const { game } = await _expectAuthPlayerInGame(req);\n\t                const gameData = await ds.GameData.get(game.id);\n\t                if (gameData?.state !== 'created') {\n\t                    return [StatusCodes.forbidden];\n", "                }\n\t                await _onGameStart(game, false);\n\t                return [StatusCodes.ok];\n\t            }\n\t        }\n\t        return;\n\t    }\n\t    async function _onGameStart(game: IDataSource.ICoopGame, fromMatchmaking: boolean) {\n\t        const gameData = await gameEngineProvider.startGame(game.id);\n\t        const now = moment.utc();\n", "        game.startedAt = now.format(FULL_DATETIME_FORMAT);\n\t        game._dbTtl = 9999999999;\n\t        await ds.CoopGames.update.exec(game);\n\t        metrics?.gameStarted(game.id, gameData.rulesetIds[0] || 'unknown', [...gameData.players.keys()], fromMatchmaking);\n\t    }\n\t    async function _expectAuthPlayerInGame(req: IHttpRequest) {\n\t        const player = await authProvider.getPlayerFromRequest(req);\n\t        if (!player.activeGameId) throw new RouteError(StatusCodes.forbidden, 'player has no active game id');\n\t        const game = await ds.CoopGames.get(player.activeGameId);\n\t        if (game) {\n", "            return {\n\t                player,\n\t                game,\n\t            };\n\t        }\n\t        player.activeGameId = '';\n\t        await ds.Players.update.exec(player);\n\t        throw new RouteError(StatusCodes.forbidden, 'player is not in game');\n\t    }\n\t    async function _expectAuthPlayerNotInGame(req: IHttpRequest) {\n", "        const player = await authProvider.getPlayerFromRequest(req);\n\t        if (player.activeGameId) throw new RouteError(StatusCodes.forbidden, 'player has an active game id');\n\t        return player;\n\t    }\n\t    async function _expectCoopGameJoinable(gameId: string) {\n\t        const game = await ds.CoopGames.get(gameId);\n\t        if (!game) throw new RouteError(StatusCodes.forbidden, 'game not found');\n\t        if (game.playersIds.size >= 2) throw new RouteError(StatusCodes.forbidden, 'game is full');\n\t        if (game.endedAt) throw new RouteError(StatusCodes.forbidden, 'game has ended');\n\t        return game;\n", "    }\n\t    async function _expectValidActiveDeck(player: IDataSource.IPlayer, validateNftOwnership: boolean) {\n\t        const deck = await getOrCreateActiveDeck(player, ds);\n\t        if (!deck) throw new RouteError(StatusCodes.forbidden, 'player has no active deck');\n\t        if (validateNftOwnership) {\n\t            const nfts = await Promise.all(deck.cards.map(x => ExtDeps.getNft(x.nftId)));\n\t            if (nfts.find(x => !x || x.nft.did !== player.id)) {\n\t                metrics?.nftOwnershipConflict(player.id);\n\t                throw new RouteError(StatusCodes.conflict, 'some cards do not belong to the did');\n\t            }\n", "        }\n\t        return deck;\n\t    }\n\t};\n\texport async function finalizeGame(gameId: string, removePlayers: boolean, ds: IDataSource, gameEngineProvider: GameEngineProvider, metrics?: IMetricsProvider) {\n\t    const game = await ds.CoopGames.get(gameId);\n\t    if (!game) throw new Error('game not found: ' + gameId);\n\t    if (game.gameState.startsWith('ended')) return;\n\t    const now = moment.utc();\n\t    game.gameState = `ended_${now.format(DATE_FORMAT)}`;\n", "    game.endedAt = now.format(FULL_DATETIME_FORMAT);\n\t    let gameData: GameEngine.IGameData | undefined = undefined;\n\t    let gameResult: IDataSource.IPlayerCoopGame['gameResult'] = 'unknown';\n\t    try {\n\t        gameData = await gameEngineProvider.getGameData(game.id);\n\t        gameResult = _getGameResult(gameData);\n\t    } catch { }\n\t    metrics?.gameEnded(\n\t        game.id,\n\t        gameResult,\n", "        gameData?.rulesetIds || [],\n\t        [...game.playersIds], gameData?.turn || -1, [...gameData?.players.values() || []].reduce((sum, x) => sum + x.score, 0),\n\t    );\n\t    const playerUpdates = (await Promise.all([...game.playersIds].map(async playerId => {\n\t        const player = await ds.Players.get(playerId);\n\t        if (!player) {\n\t            console.error(`_onGameEnd: player ${playerId} in ${game.id} not found`);\n\t            return;\n\t        }\n\t        if (player.activeGameId === game.id) {\n", "            removePlayers && (player.activeGameId = '');\n\t            const playerState = gameData?.players.get(playerId);\n\t            if (playerState?.score) {\n\t                player.score += playerState?.score || 0;\n\t                await ds.Leaderboard.set(player.id, player.score);\n\t            }\n\t            return [\n\t                ds.PlayerCoopGames.update.make({\n\t                    playerId,\n\t                    endedAt: game.endedAt,\n", "                    gameId: game.id,\n\t                    gameResult,\n\t                    score: playerState?.score || 0,\n\t                    teammates: _getOtherPlayerIds(playerId, game),\n\t                    turns: gameData?.turn || -1,\n\t                    difficulty: game.difficulty,\n\t                    rulesetIds: gameData?.rulesetIds || [],\n\t                }, true),\n\t                ds.Players.update.make(player, true),\n\t            ];\n", "        }\n\t        return;\n\t    }))).filter(Boolean).flat();\n\t    await ds.execUpdates(\n\t        ...playerUpdates,\n\t        ds.CoopGames.update.make(game),\n\t    );\n\t    try {\n\t        await gameEngineProvider.endGame(game.id);\n\t    } catch {\n", "    }\n\t}\n\tfunction _getGameResult(gameData: GameEngine.IGameData): IDataSource.IPlayerCoopGame['gameResult'] {\n\t    switch (gameData.state) {\n\t        case 'abandoned': return 'abandoned';\n\t        case 'players_lost': return 'loss';\n\t        case 'players_won': return 'win';\n\t        case 'started': return 'abandoned';\n\t        default:\n\t            return 'unknown';\n", "    }\n\t}\n\tfunction _getOtherPlayerIds(playerId: string, game: IDataSource.ICoopGame) {\n\t    return [\n\t        ...[...game.playersIds.keys()].filter(x => x !== playerId),\n\t        // ...[...game.ingorePlayerIds.keys()].filter(x => x !== playerId),\n\t    ];\n\t}"]}
{"filename": "src/apis/players.api.ts", "chunked_list": ["import * as moment from 'moment';\n\timport { z } from 'zod';\n\timport { IAuthProvider, IDataSource, IMetricsProvider } from '../dependencies';\n\timport { ExtDeps } from '../external-dependencies';\n\timport { toClientPlayer } from '../models';\n\timport { IHttpRouteHandler, StatusCodes } from '../net-utils';\n\timport { FULL_DATETIME_FORMAT } from '../utils';\n\texport const createPlayerHandler = (ds: IDataSource, authProvider: IAuthProvider, metrics?: IMetricsProvider): IHttpRouteHandler =>\n\t    async (path, _query, body, req) => {\n\t        switch (path[0]) {\n", "            case 'connectDid': {\n\t                const schema = z.object({\n\t                    didProof: z.object({\n\t                        latestCoinId: z.string(),\n\t                        pubkey: z.string(),\n\t                        signature: z.string(),\n\t                    }),\n\t                });\n\t                const payload = schema.parse(body);\n\t                const did = (await ExtDeps.verifyDidProof({\n", "                    ...payload.didProof,\n\t                    message: 'Proof of DID ownership for ChiaTCG',\n\t                }))?.did;\n\t                if (!did) {\n\t                    return [StatusCodes.unauthorized, { reason: 'unable to validate did proof' }];\n\t                }\n\t                let player = await ds.Players.get(did);\n\t                const isNew = !player;\n\t                const now = moment.utc();\n\t                const newSecret = authProvider.generateNewSecret();\n", "                const newAuthExpireAt = moment.utc(now).add({ days: 14 }).format(FULL_DATETIME_FORMAT);\n\t                if (!player) {\n\t                    const nowStr = now.format(FULL_DATETIME_FORMAT);\n\t                    player = await ds.Players.update.exec({\n\t                        id: did,\n\t                        createdAt: nowStr,\n\t                        lastSeenAt: nowStr,\n\t                        secret: newSecret,\n\t                        authExpiresAt: newAuthExpireAt,\n\t                        activeGameId: '',\n", "                        activeDeckId: 'default',\n\t                        score: 0,\n\t                    });\n\t                    metrics?.newUser(player.id);\n\t                } else {\n\t                    ds.Leaderboard.set(player.id, player.score);\n\t                    player.secret = newSecret;\n\t                    player.authExpiresAt = newAuthExpireAt;\n\t                    await ds.Players.update.exec(player);\n\t                }\n", "                return [StatusCodes.ok, {\n\t                    player: toClientPlayer(player, authProvider),\n\t                    status: isNew ? 'new' : 'existing',\n\t                }];\n\t            }\n\t            case 'me': {\n\t                const player = await authProvider.getPlayerFromRequest(req);\n\t                return [StatusCodes.ok, { player: toClientPlayer(player, authProvider) }];\n\t            }\n\t        }\n", "        return;\n\t    };"]}
{"filename": "src/tests/appraise.test.ts", "chunked_list": ["import { randomInt } from 'crypto';\n\timport { appraiseCard } from '../appraise';\n\tconst excludedChars = ['1', 'b', 'i', 'o'];\n\tconst testSize = 1000000;\n\tfunction generateId() {\n\t    let id = 'nft1'.padEnd(54, '_');\n\t    while (id.length < 62) {\n\t        const i = randomInt(0, 36);\n\t        let c: string;\n\t        if (i >= 10) {\n", "            c = String.fromCharCode(97 + i - 10);\n\t        } else {\n\t            c = String.fromCharCode(48 + i);\n\t        }\n\t        if (!excludedChars.includes(c)) {\n\t            id += c;\n\t        }\n\t    }\n\t    id = id.substring(0, 55) + (Math.random() < 0.5 ? 's' : 'q') + id.substring(56);\n\t    return id;\n", "}\n\ttest('appraiseCard', () => {\n\t    const results = {\n\t        factions: {\n\t            backdoor: 0,\n\t            bruteforce: 0,\n\t            malware: 0,\n\t        },\n\t        scripts: {\n\t            bd_exploit: 0,\n", "            bd_decode: 0,\n\t            bd_secure: 0,\n\t            bf_firewall: 0,\n\t            bf_overclock: 0,\n\t            bf_spam: 0,\n\t            mw_redirect: 0,\n\t            mw_freeware: 0,\n\t            mw_worm: 0,\n\t        },\n\t        tiers: [0, 0, 0, 0, 0, 0, 0],\n", "        cpu: 0,\n\t        mem: 0,\n\t    };\n\t    for (let i = 0; i < testSize; i++) {\n\t        const card = appraiseCard({ nftId: generateId(), mintHeight: 1, url: '' });\n\t        results.factions[card.faction]++;\n\t        results.tiers[card.tier]++;\n\t        results.cpu += card.cpu;\n\t        results.mem += card.mem;\n\t        results.scripts[card.coreScript]++;\n", "        if (card.cpu + card.mem !== card.tier + 2) {\n\t            // This assertion is not done using expect() as it would slow down the test too much\n\t            throw new Error('CPU + MEM is expected to be Tier + 2');\n\t        }\n\t    }\n\t    expect(results.factions.bruteforce / results.factions.malware).toBeCloseTo(1, 1);\n\t    expect(results.factions.bruteforce / results.factions.backdoor).toBeCloseTo(1.1, 1);\n\t    expect(results.cpu / results.mem).toBeCloseTo(1);\n\t    expect(results.scripts.bd_decode / results.scripts.bd_exploit).toBeCloseTo(1, 1);\n\t    expect(results.scripts.bd_decode / results.scripts.bd_secure).toBeCloseTo(1, 1);\n", "    expect(results.scripts.bf_firewall / results.scripts.bf_overclock).toBeCloseTo(1, 1);\n\t    expect(results.scripts.bf_firewall / results.scripts.bf_spam).toBeCloseTo(1, 1);\n\t    expect(results.scripts.mw_redirect / results.scripts.mw_freeware).toBeCloseTo(1, 1);\n\t    expect(results.scripts.mw_redirect / results.scripts.mw_worm).toBeCloseTo(1, 1);\n\t    expect(results.tiers[1]! / testSize).toBeCloseTo(.46156);\n\t    expect(results.tiers[2]! / testSize).toBeCloseTo(.31667);\n\t    expect(results.tiers[3]! / testSize).toBeCloseTo(.16521);\n\t    expect(results.tiers[4]! / testSize).toBeCloseTo(.04849);\n\t    expect(results.tiers[5]! / testSize).toBeCloseTo(.00759, 3);\n\t    // Cannot reliably test T6 as the numbers are so small but if T1-T5 pass then by process of elimination we can assert T6 is correct\n", "});"]}
{"filename": "src/game/card-script-parts.ts", "chunked_list": ["import { CardMod } from './card-mods';\n\timport { CardScript } from './card-scripts';\n\timport { GameEngine } from './game-engine';\n\timport { GameEngineUtils } from './game-engine-utils';\n\texport namespace CardScriptParts {\n\t    export interface IScriptPart {\n\t        (engine: GameEngine.IGameEngine, sourceCard: GameEngine.ICardState, targetCard: GameEngine.ICardState): void;\n\t    }\n\t    export const _Chance = (chance: number, curriedPart: IScriptPart): IScriptPart =>\n\t        (engine, sourceCard, targetCard) => {\n", "            if (Math.random() < chance) {\n\t                curriedPart(engine, sourceCard, targetCard);\n\t            }\n\t        };\n\t    export const _TargetHasMod = <T extends CardMod.ModLibrary, K extends keyof T>(modName: K, curry: (mod: InstanceType<T[K]>) => IScriptPart): IScriptPart =>\n\t        (engine, sourceCard, targetCard) => {\n\t            const mod = targetCard.mods.find(x => x[0] === modName);\n\t            if (mod) {\n\t                curry(CardMod.deserialize(engine, mod) as InstanceType<T[K]>)(engine, sourceCard, targetCard);\n\t            }\n", "        };\n\t    export const AddMod = (mod: CardMod): IScriptPart =>\n\t        (engine, sourceCard, targetCard) => {\n\t            CardMod.addMod(engine, targetCard, mod, sourceCard);\n\t        };\n\t    export const Attack = (damage: number, dontTriggerOut = false, dontTriggerIn = false): IScriptPart =>\n\t        (engine, sourceCard, targetCard) => {\n\t            const secExceeded = SecDmg(damage, dontTriggerOut, dontTriggerIn)(engine, sourceCard, targetCard) as unknown;\n\t            if (secExceeded) {\n\t                MemDmg(1)(engine, sourceCard, targetCard);\n", "            }\n\t        };\n\t    export const SecDmg = (secDmg: number, dontTriggerOut = false, dontTriggerIn = false): IScriptPart =>\n\t        (engine, sourceCard, targetCard) => {\n\t            let resolvedDamage = secDmg;\n\t            if (!dontTriggerOut) {\n\t                resolvedDamage += GameEngineUtils.triggerMods('onSecDamageOut', { engine, sourceCard, contextCard: targetCard }, resolvedDamage)\n\t                    .reduce((sum, x) => sum + (!!x ? x.secDmgBonus : 0), 0);\n\t            }\n\t            if (!dontTriggerIn) {\n", "                resolvedDamage += GameEngineUtils.triggerMods('onSecDamageIn', { engine, sourceCard: targetCard, contextCard: sourceCard }, resolvedDamage, sourceCard)\n\t                    .reduce((sum, x) => sum + (!!x ? x.secDmgBonus : 0), 0);\n\t            }\n\t            if (CardMod.findModOfType(targetCard, CardMod.Content.impervious)) {\n\t                return false;\n\t            }\n\t            resolvedDamage = Math.max(0, resolvedDamage);\n\t            const secExceeded = resolvedDamage > targetCard.sec;\n\t            GameEngineUtils.changeSec(engine, targetCard, -resolvedDamage, false, sourceCard);\n\t            return secExceeded;\n", "        };\n\t    export const MemDmg = (memDmg: number): IScriptPart =>\n\t        (engine, sourceCard, targetCard) => {\n\t            GameEngineUtils.triggerMods('onMemDmgOut', { engine, sourceCard, contextCard: targetCard }, memDmg);\n\t            GameEngineUtils.triggerMods('onMemDmgIn', { engine, sourceCard: targetCard, contextCard: sourceCard }, memDmg);\n\t            if (CardMod.findModOfType(targetCard, CardMod.Content.impervious)) {\n\t                return;\n\t            }\n\t            targetCard.mem -= memDmg;\n\t            engine.broadcast.push({\n", "                type: 'memDamage',\n\t                cardId: targetCard.id,\n\t                newMem: targetCard.mem,\n\t                value: -memDmg,\n\t            });\n\t            const player = GameEngineUtils.findPlayerByCardIdMaybe(engine.gameData, sourceCard.id);\n\t            player && (player.stats.memDmg += memDmg);\n\t            if (targetCard.mem <= 0) {\n\t                GameEngineUtils.removeCard(engine, targetCard, sourceCard);\n\t            }\n", "        };\n\t    export const ChangeCpu = (cpuDelta: number): IScriptPart =>\n\t        (engine, _sourceCard, targetCard) => {\n\t            GameEngineUtils.changeCpu(engine, targetCard, cpuDelta);\n\t        };\n\t    export const RaiseMem = (memBonus: number): IScriptPart =>\n\t        (engine, _sourceCard, targetCard) => {\n\t            targetCard.mem += memBonus;\n\t            engine.broadcast.push({\n\t                type: 'memBonus',\n", "                cardId: targetCard.id,\n\t                newMem: targetCard.mem,\n\t                value: memBonus,\n\t            });\n\t        };\n\t    export const RaiseSec = (secBonus: number): IScriptPart =>\n\t        (engine, sourceCard, targetCard) => {\n\t            GameEngineUtils.changeSec(engine, targetCard, secBonus, false, sourceCard);\n\t        };\n\t    export const RedirectIntentRandom: IScriptPart =\n", "        (engine, _sourceCard, targetCard) => {\n\t            if (!GameEngineUtils.isEnemyCard(engine.gameData, targetCard) || !targetCard.intent) return;\n\t            const script = CardScript.deserialize(engine, targetCard, targetCard.intent.scriptData);\n\t            if (script.targetFinder === CardScript.TargetFinders.Self) return;\n\t            const targets = script.targetFinder(engine.gameData, targetCard);\n\t            if (!targets.length || (targets.length === 1 && targets[0]?.id === targetCard.intent.targetCardId)) return;\n\t            const origTargetId = targetCard.intent.targetCardId;\n\t            while (targetCard.intent.targetCardId === origTargetId) {\n\t                targetCard.intent.targetCardId = targets.random().id;\n\t            }\n", "            engine.broadcast.push({\n\t                type: 'cardIntent',\n\t                cardId: targetCard.id,\n\t                intent: targetCard.intent,\n\t            });\n\t        };\n\t    export const RemoveMod = <T extends CardMod.ModLibrary, K extends (keyof T & string)>(modName: K, mustRemove = false): IScriptPart =>\n\t        (engine, sourceCard, targetCard) => {\n\t            if (mustRemove) {\n\t                if (!targetCard.mods.find(x => x[0] === modName)) {\n", "                    throw new Error(`Could not find [${modName}] to remove`);\n\t                }\n\t            }\n\t            CardMod.removeModByName(engine, targetCard, modName, sourceCard);\n\t        };\n\t    export const SpawnEnemy = (enemyClass: string, spawnPosition?: 'relLeft' | 'relRight' | 'absLeft' | 'absRight', generateIntent = false): IScriptPart =>\n\t        (engine, sourceCard, _targetCard) => {\n\t            let spawnIndex = engine.gameData.enemies.findIndex(x => x.id === sourceCard.id);\n\t            switch (spawnPosition) {\n\t                case 'absLeft': spawnIndex = 0; break;\n", "                case 'absRight': spawnIndex = engine.gameData.enemies.length; break;\n\t                case 'relRight': spawnIndex++; break;\n\t            }\n\t            GameEngineUtils.spawnEnemy(engine, enemyClass, spawnIndex, generateIntent);\n\t        };\n\t}"]}
{"filename": "src/game/card-mods.ts", "chunked_list": ["import { CardScript } from './card-scripts';\n\timport { GameEngine } from './game-engine';\n\timport { GameEngineUtils } from './game-engine-utils';\n\texport abstract class CardMod {\n\t    duration = -1;\n\t    stackingConfig: Parameters<typeof CardMod['makeStackingData']>[0] = { behavior: CardMod.StackingBehavior.neverReplace };\n\t    readonly modName: string;\n\t    constructor(\n\t        private _extraModData?: IArguments,\n\t    ) {\n", "        this.modName = this.constructor.name;\n\t    }\n\t    onSecDamageIn?(deps: CardMod.ICardModDeps, damage: number, attacker: GameEngine.ICardState): { secDmgBonus: number } | void;\n\t    onSecDamageOut?(deps: CardMod.ICardModDeps, baseDmg: number): { secDmgBonus: number } | void;\n\t    onMemDmgIn?(deps: CardMod.ICardModDeps, memDmg: number): void;\n\t    onMemDmgOut?(deps: CardMod.ICardModDeps, memDmg: number): void;\n\t    onInitMod?(deps: CardMod.ICardModDeps): void;\n\t    onRemoveMod?(deps: CardMod.ICardModDeps): void;\n\t    onCardDestroyed?(deps: CardMod.ICardModDeps): void;\n\t    onStackMod?(deps: CardMod.ICardModDeps, stackDelta: number): void;\n", "    onTurnStart?(deps: CardMod.ICardModDeps): void;\n\t    onTurnEnd?(deps: CardMod.ICardModDeps): void;\n\t    onEnemyDestroyed?(deps: CardMod.ICardModDeps): void;\n\t    serialize() {\n\t        const stackingData = CardMod.makeStackingData(this.stackingConfig);\n\t        const modData = [this.modName, stackingData] as CardMod.ModData;\n\t        (this.duration >= 0) && (modData.push(CardMod.makeDurationData(this.duration)));\n\t        this._extraModData && modData.push(...this._extraModData);\n\t        return modData;\n\t    }\n", "    static addMod(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, mod: CardMod, contextCard?: GameEngine.ICardState) {\n\t        const modData = mod.serialize();\n\t        switch (mod.stackingConfig.behavior) {\n\t            case CardMod.StackingBehavior.append: {\n\t                card.mods.push(modData);\n\t                break;\n\t            }\n\t            case CardMod.StackingBehavior.neverReplace: {\n\t                const existingModData = card.mods.find(x => x[0] === mod.modName);\n\t                if (existingModData) return;\n", "                card.mods.push(modData);\n\t                break;\n\t            }\n\t            case CardMod.StackingBehavior.ranked: {\n\t                const existingModData = card.mods.find(x => x[0] === mod.modName);\n\t                if (existingModData) {\n\t                    const existingStackingData = existingModData[1] as CardMod.RankedStackingData;\n\t                    if (existingStackingData[2] >= mod.stackingConfig.rank) {\n\t                        return;\n\t                    }\n", "                    this.removeMod(engine, card, existingModData, contextCard);\n\t                    if (card.isRemoved) return;\n\t                }\n\t                card.mods.push(modData);\n\t                break;\n\t            }\n\t            case CardMod.StackingBehavior.replace: {\n\t                const existingModData = card.mods.find(x => x[0] === mod.modName);\n\t                if (existingModData) {\n\t                    this.removeMod(engine, card, existingModData, contextCard);\n", "                    if (card.isRemoved) return;\n\t                }\n\t                card.mods.push(modData);\n\t                break;\n\t            }\n\t            case CardMod.StackingBehavior.stack: {\n\t                const existingModData = card.mods.find(x => x[0] === mod.modName);\n\t                if (existingModData) {\n\t                    const existingStackingData = existingModData[1] as CardMod.RankedStackingData;\n\t                    existingStackingData && (existingStackingData[2] += mod.stackingConfig.stackCount);\n", "                    engine.broadcast.push({\n\t                        type: 'modStackChanged',\n\t                        cardId: card.id,\n\t                        modData: existingModData,\n\t                        stackDelta: mod.stackingConfig.stackCount,\n\t                        newStackCount: existingStackingData[2],\n\t                    });\n\t                    this.trigger('onStackMod', existingModData, { engine, sourceCard: card, contextCard }, mod.stackingConfig.stackCount);\n\t                    return;\n\t                }\n", "                card.mods.push(modData);\n\t                break;\n\t            }\n\t        }\n\t        engine.broadcast.push({\n\t            type: 'modAdded',\n\t            cardId: card.id,\n\t            modData,\n\t        });\n\t        this.trigger('onInitMod', modData, { engine, sourceCard: card, contextCard });\n", "    }\n\t    static areEqual(left: CardMod.ModData, right: CardMod.ModData) {\n\t        // Caveat: could collide since join() flattens array but highly unlikely\n\t        return left.join('') === right.join('');\n\t    }\n\t    static deserialize(engine: GameEngine.IGameEngine, modData: CardMod.ModData) {\n\t        const modCtor = engine.ruleset.cardMods?.[modData[0]];\n\t        if (!modCtor) throw new Error('mod not found: ' + modData.join());\n\t        const durationData = this.findDurationData(modData);\n\t        const mod = new modCtor(...modData.slice(durationData ? 3 : 2));\n", "        durationData && (mod.duration = durationData[1]);\n\t        const stackingData = modData[1];\n\t        mod.stackingConfig.behavior = stackingData[1];\n\t        switch (stackingData[1]) {\n\t            case CardMod.StackingBehavior.ranked:\n\t                (mod.stackingConfig as any).rank = stackingData[2];\n\t                break;\n\t            case CardMod.StackingBehavior.stack:\n\t                (mod.stackingConfig as any).stackCount = stackingData[2];\n\t                break;\n", "        }\n\t        return mod;\n\t    }\n\t    static findDurationData(modData: CardMod.ModData) {\n\t        const maybeDurationData = modData[2];\n\t        return (Array.isArray(maybeDurationData) && maybeDurationData[0] === '$duration') ? (modData[2] as CardMod.DurationData) : undefined;\n\t    }\n\t    static findModOfType(card: GameEngine.ICardState, modType: CardMod.ModConstructor) {\n\t        return card.mods.find(x => x[0] === modType.name);\n\t    }\n", "    static getStackCount(modData: CardMod.ModData) {\n\t        return modData[1][1] === CardMod.StackingBehavior.stack ? modData[1][2] : 0;\n\t    }\n\t    static makeDurationData(duration: number): CardMod.DurationData {\n\t        return ['$duration', duration];\n\t    }\n\t    static makeStackingData(\n\t        stackConfig: { behavior: CardMod.StackingBehavior.append }\n\t            | { behavior: CardMod.StackingBehavior.neverReplace }\n\t            | { behavior: CardMod.StackingBehavior.ranked, rank: number }\n", "            | { behavior: CardMod.StackingBehavior.replace }\n\t            | { behavior: CardMod.StackingBehavior.stack, stackCount: number }\n\t    ) {\n\t        const stackingData = ['$stack', stackConfig.behavior];\n\t        (stackConfig.behavior === CardMod.StackingBehavior.ranked) && stackingData.push(stackConfig.rank);\n\t        (stackConfig.behavior === CardMod.StackingBehavior.stack) && stackingData.push(stackConfig.stackCount);\n\t        return stackingData as CardMod.StackingData;\n\t    }\n\t    static removeMod(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, modData: CardMod.ModData, contextCard?: GameEngine.ICardState) {\n\t        engine.broadcast.push({\n", "            type: 'modRemoved',\n\t            cardId: card.id,\n\t            modData,\n\t        });\n\t        if (!card.mods.find(x => this.areEqual(x, modData))) {\n\t            throw new Error('mod not found');\n\t        }\n\t        this.trigger('onRemoveMod', modData, { engine, sourceCard: card, contextCard });\n\t        card.mods.findAndRemoveFirst(x => this.areEqual(x, modData));\n\t    }\n", "    static removeModByName<T extends CardMod.ModLibrary, K extends keyof T>(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, modName: K, contextCard?: GameEngine.ICardState) {\n\t        const mod = card.mods.find(x => x[0] === modName);\n\t        mod && this.removeMod(engine, card, mod, contextCard);\n\t    }\n\t    static trigger<T extends CardMod.ModEvent>(ev: T, modData: CardMod.ModData, ...args: Parameters<NonNullable<CardMod[typeof ev]>>) {\n\t        const deps = args[0];\n\t        const modDataFromCard = deps.sourceCard.mods.find(x => this.areEqual(x, modData));\n\t        if (!modDataFromCard) {\n\t            throw new Error(`card [${deps.sourceCard.id}] does not have mod [${modData.join()}], mods are ${deps.sourceCard.mods.join('|')}`);\n\t        }\n", "        const mod = this.deserialize(deps.engine, modDataFromCard);\n\t        const evnt = mod[ev];\n\t        const evntRetVal = evnt ? (evnt as any).apply(mod, args) : undefined;\n\t        if (deps.sourceCard.isRemoved) {\n\t            return;\n\t        }\n\t        if (ev === 'onTurnStart') {\n\t            const durationData = this.findDurationData(modDataFromCard);\n\t            if (durationData) {\n\t                if (durationData[1] > 1) {\n", "                    durationData[1]--;\n\t                    deps.engine.broadcast.push({\n\t                        type: 'modDurationChanged',\n\t                        cardId: deps.sourceCard.id,\n\t                        modData: modData,\n\t                        newDuration: durationData[1],\n\t                    });\n\t                } else {\n\t                    this.removeMod(deps.engine, deps.sourceCard, modData);\n\t                }\n", "            }\n\t        }\n\t        return evntRetVal as ReturnType<NonNullable<CardMod[T]>> | undefined;\n\t    }\n\t}\n\texport namespace CardMod {\n\t    export type ModData = [string, StackingData, ...unknown[],];\n\t    export type DurationData = ['$duration', number];\n\t    export type EnemyModData = unknown[];\n\t    export type ModConstructor = TypeConstructor<CardMod>;\n", "    export type ModEvent = KeyOfFilteredByValueType<CardMod, ((deps: ICardModDeps, ...args: any) => any) | undefined> & StringsStartingWith<keyof CardMod, 'on'>;\n\t    export type ModLibrary = Record<string, ModConstructor>;\n\t    export type AppendStackingData = ['$stack', StackingBehavior.append];\n\t    export type NeverReplaceStackingData = ['$stack', StackingBehavior.neverReplace];\n\t    export type RankedStackingData = ['$stack', StackingBehavior.ranked, number];\n\t    export type ReplaceStackingData = ['$stack', StackingBehavior.replace];\n\t    export type StackStackingData = ['$stack', StackingBehavior.stack, number];\n\t    export type StackingData = AppendStackingData | NeverReplaceStackingData | RankedStackingData | ReplaceStackingData | StackStackingData;\n\t    export enum StackingBehavior {\n\t        append,\n", "        neverReplace,\n\t        ranked,\n\t        replace,\n\t        stack,\n\t    }\n\t    export interface ICardModDeps {\n\t        engine: GameEngine.IGameEngine;\n\t        sourceCard: GameEngine.ICardState;\n\t        contextCard?: GameEngine.ICardState;\n\t    }\n", "    export namespace Content {\n\t        // Defines a card modifier - the class name is treated as the mod name\n\t        export class backdoor extends CardMod {\n\t            override stackingConfig = {\n\t                behavior: CardMod.StackingBehavior.ranked as const,\n\t                rank: 0,\n\t            };\n\t            constructor(public damage: number) {\n\t                // Any extra data to serialize into this.modData as a 'memo' which can serve two purposes:\n\t                // 1) the client relies on the memo to display modifier effects in the UI instead calculating it independently\n", "                // 2) memo is passed back into the constructor during deserialization, useful for dynamic AI modifiers,\n\t                //      see _standardAi below for example\n\t                super(arguments);\n\t                this.stackingConfig.rank = damage;\n\t            }\n\t        }\n\t        export class diagnostics extends CardMod {\n\t            override stackingConfig = {\n\t                behavior: CardMod.StackingBehavior.stack as const,\n\t                stackCount: 0,\n", "            };\n\t            constructor(public secBonus: number, override duration: number) {\n\t                super(arguments);\n\t                this.stackingConfig.stackCount = secBonus;\n\t            }\n\t            override onTurnEnd(deps: ICardModDeps): void {\n\t                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, this.stackingConfig.stackCount, false);\n\t            }\n\t        }\n\t        export class firewall extends CardMod {\n", "            override stackingConfig = {\n\t                behavior: CardMod.StackingBehavior.ranked as const,\n\t                rank: 0,\n\t            };\n\t            constructor(override duration: number) {\n\t                super(arguments);\n\t                this.stackingConfig.rank = duration;\n\t            }\n\t            override onInitMod(deps: ICardModDeps) {\n\t                if (GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n", "                    return;\n\t                }\n\t                GameEngineUtils.revalidateIntents(deps.engine, true);\n\t            }\n\t        }\n\t        export class impervious extends CardMod {\n\t            constructor(override duration = -1) {\n\t                super(arguments);\n\t            }\n\t            override onSecDamageIn(_deps: ICardModDeps, _damage: number, _attacker: GameEngine.ICardState) {\n", "                return {\n\t                    secDmgBonus: -9999,\n\t                };\n\t            }\n\t        }\n\t        export class lag extends CardMod {\n\t            constructor(override duration: number) {\n\t                super(arguments);\n\t            }\n\t            override onInitMod(deps: CardMod.ICardModDeps) {\n", "                if (GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n\t                    GameEngineUtils.clearIntent(deps.engine, deps.sourceCard);\n\t                } else {\n\t                    GameEngineUtils.changeCardIsUsed(deps.engine, deps.sourceCard, true);\n\t                }\n\t            }\n\t            override onTurnStart(deps: CardMod.ICardModDeps) {\n\t                if (GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n\t                    GameEngineUtils.clearIntent(deps.engine, deps.sourceCard);\n\t                } else {\n", "                    GameEngineUtils.changeCardIsUsed(deps.engine, deps.sourceCard, true);\n\t                }\n\t            }\n\t            override onRemoveMod(deps: ICardModDeps): void {\n\t                if (GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n\t                    GameEngineUtils.generateIntent(deps.engine, deps.sourceCard);\n\t                } else {\n\t                    GameEngineUtils.changeCardIsUsed(deps.engine, deps.sourceCard, false);\n\t                }\n\t            }\n", "        }\n\t        export class offline extends CardMod {\n\t            constructor(override duration: number) {\n\t                super(arguments);\n\t            }\n\t            override onInitMod(deps: CardMod.ICardModDeps) {\n\t                if (GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n\t                    GameEngineUtils.clearIntent(deps.engine, deps.sourceCard);\n\t                }\n\t                GameEngineUtils.revalidateIntents(deps.engine, GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard));\n", "            }\n\t            override onTurnStart(deps: CardMod.ICardModDeps) {\n\t                if (GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n\t                    GameEngineUtils.clearIntent(deps.engine, deps.sourceCard);\n\t                } else {\n\t                    GameEngineUtils.changeCardIsUsed(deps.engine, deps.sourceCard, true);\n\t                }\n\t            }\n\t            override onRemoveMod(deps: ICardModDeps): void {\n\t                if (GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n", "                    GameEngineUtils.generateIntent(deps.engine, deps.sourceCard);\n\t                } else {\n\t                    GameEngineUtils.changeCardIsUsed(deps.engine, deps.sourceCard, false);\n\t                }\n\t            }\n\t        }\n\t        export class secured extends CardMod {\n\t            override stackingConfig = {\n\t                behavior: CardMod.StackingBehavior.stack as const,\n\t                stackCount: 0,\n", "            };\n\t            constructor(public tempSecBonus: number, override duration: number) {\n\t                super(arguments);\n\t                this.stackingConfig.stackCount = tempSecBonus;\n\t            }\n\t            override onInitMod(deps: ICardModDeps) {\n\t                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, this.stackingConfig.stackCount, false);\n\t            }\n\t            override onStackMod(deps: ICardModDeps, stackDelta: number): void {\n\t                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, stackDelta, false);\n", "            }\n\t            override onRemoveMod(deps: ICardModDeps) {\n\t                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, -this.stackingConfig.stackCount, true);\n\t            }\n\t        }\n\t        export class _waveBonus_extraMove extends CardMod {\n\t            override onInitMod(deps: ICardModDeps): void {\n\t                const player = GameEngineUtils.findPlayerByCardId(deps.engine.gameData, deps.sourceCard.id);\n\t                player.movesPerTurn++;\n\t                player.movesLeft = player.movesPerTurn;\n", "                deps.engine.broadcast.push({\n\t                    type: 'movesPerTurnsChange',\n\t                    playerId: player.id,\n\t                    newMovesLeft: player.movesLeft,\n\t                    newMovesPerTurn: player.movesPerTurn,\n\t                });\n\t            }\n\t        }\n\t        export class _winOnDeath extends CardMod {\n\t            override onCardDestroyed(deps: ICardModDeps) {\n", "                const player = deps.contextCard ? GameEngineUtils.findPlayerByCardIdMaybe(deps.engine.gameData, deps.contextCard.id) : null;\n\t                player && player.stats.kills++;\n\t                deps.engine.onWinGame();\n\t                player && player.stats.kills--;\n\t            }\n\t        }\n\t        export class _standardAi extends CardMod {\n\t            override onTurnStart(deps: ICardModDeps) {\n\t                if (!GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n\t                    throw new Error('not an enemy card');\n", "                }\n\t                GameEngineUtils.generateIntent(deps.engine, deps.sourceCard);\n\t            }\n\t            override onTurnEnd(deps: ICardModDeps) {\n\t                if (!GameEngineUtils.isEnemyCard(deps.engine.gameData, deps.sourceCard)) {\n\t                    throw new Error('not an enemy card');\n\t                }\n\t                GameEngineUtils.executeIntent(deps.engine, deps.sourceCard);\n\t            }\n\t        }\n", "        export class _yieldScript extends CardMod {\n\t            constructor(\n\t                public scriptData: CardScript.ScriptData,\n\t                override duration: number,\n\t            ) {\n\t                super(arguments);\n\t            }\n\t            override onRemoveMod(deps: ICardModDeps) {\n\t                CardScript.addScript(deps.engine, deps.sourceCard, this.scriptData);\n\t            }\n", "        }\n\t        export class _waveTrigger extends CardMod {\n\t            constructor(\n\t                public rulesetIds: string[],\n\t                override duration = -1,\n\t            ) {\n\t                super(arguments);\n\t            }\n\t            override onInitMod(deps: ICardModDeps): void {\n\t                deps.engine.gameData.difficulty < 3 && GameEngineUtils.changeSec(deps.engine, deps.sourceCard, 25, true);\n", "            }\n\t            override onCardDestroyed(deps: ICardModDeps) {\n\t                deps.engine.onNextWave(this.rulesetIds.random());\n\t                deps.contextCard && CardMod.addMod(deps.engine, deps.contextCard, new _waveBonus_extraMove());\n\t            }\n\t            override onRemoveMod(deps: ICardModDeps): void {\n\t                CardMod.addMod(deps.engine, deps.sourceCard, new _winOnDeath());\n\t            }\n\t        }\n\t    }\n", "}\n"]}
{"filename": "src/game/card-scripts.ts", "chunked_list": ["import { CoreScriptNames } from '../appraise';\n\timport { IPlayerPushProvider } from '../dependencies';\n\timport { randInt, round } from '../utils';\n\timport { CardMod } from './card-mods';\n\timport { CardScriptParts } from './card-script-parts';\n\timport { GameEngine } from './game-engine';\n\timport { GameEngineUtils } from './game-engine-utils';\n\texport class CardScript {\n\t    cooldownMax = -1;\n\t    cooldownCur = 0;\n", "    readonly scriptName: string;\n\t    constructor(\n\t        private _extraScriptData: unknown[],\n\t        public targetFinder: CardScript.ITargetFinder,\n\t        public targetScriptParts: { targetResolver: CardScript.ITargetResolver, parts: CardScriptParts.IScriptPart[] }[],\n\t    ) {\n\t        this.scriptName = this.constructor.name;\n\t    }\n\t    serialize() {\n\t        const retVal = [this.scriptName, ...this._extraScriptData] as CardScript.ScriptData;\n", "        (this.cooldownCur > 0 || this.cooldownMax > 0) && retVal.push(CardScript.makeCooldownData(this.cooldownMax, this.cooldownCur));\n\t        return retVal;\n\t    }\n\t    static addScript(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, scriptData: CardScript.ScriptData) {\n\t        card.scripts.push(scriptData);\n\t        engine.broadcast.push({\n\t            type: 'scriptAdded',\n\t            cardId: card.id,\n\t            scriptData,\n\t        });\n", "    }\n\t    static areEqual(left: CardScript.ScriptData, right: CardScript.ScriptData) {\n\t        // Caveat: could collide since join() flattens array but highly unlikely\n\t        return left.join('') === right.join('');\n\t    }\n\t    static deserialize(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, scriptData: CardScript.ScriptData) {\n\t        const scriptCtor = engine.ruleset.cardScripts?.[scriptData[0]];\n\t        if (!scriptCtor) throw new Error('script not found: ' + scriptData.join());\n\t        const script = new scriptCtor(card, ...scriptData.slice(1));\n\t        const cooldownData = CardScript.findCooldownData(scriptData);\n", "        if (cooldownData) {\n\t            script.cooldownCur = cooldownData[1];\n\t            script.cooldownMax = cooldownData[2];\n\t        }\n\t        return script;\n\t    }\n\t    static execute(engine: GameEngine.IGameEngine, sourceCard: GameEngine.ICardState, sourceCardScript: CardScript.ScriptData, targetCard: GameEngine.ICardState) {\n\t        engine.broadcast.push({\n\t            type: 'cardExecuting',\n\t            cardId: sourceCard.id,\n", "            targetCardId: targetCard.id,\n\t            scriptData: sourceCardScript,\n\t        });\n\t        if (this.isOnCooldown(sourceCardScript)) {\n\t            throw new Error('Script is on cooldown: ' + sourceCardScript.join());\n\t        }\n\t        const scriptDataFromCard = sourceCard.scripts.find(x => CardScript.areEqual(x, sourceCardScript));\n\t        const isEnemy = GameEngineUtils.isEnemyCard(engine.gameData, sourceCard);\n\t        if (!isEnemy) {\n\t            if (!scriptDataFromCard) {\n", "                throw new Error('PlayerCard does not have script: ' + sourceCardScript.join());\n\t            }\n\t        }\n\t        const cooldownData = CardScript.findCooldownData(scriptDataFromCard || sourceCardScript);\n\t        if (cooldownData) {\n\t            cooldownData[1] = cooldownData[2] + 1;\n\t        }\n\t        const script = this.deserialize(engine, sourceCard, sourceCardScript);\n\t        const targets = script.targetFinder(engine.gameData, sourceCard);\n\t        if (!isEnemy && (!targets.length || !targets.find(x => x.id === targetCard.id))) {\n", "            throw new Error('Invalid target ' + targets.map(x => x.id).join());\n\t        }\n\t        for (const pair of script.targetScriptParts) {\n\t            const resolvedTargets = pair.targetResolver(engine.gameData, sourceCard, targetCard);\n\t            for (const part of pair.parts) {\n\t                for (const resolvedTarget of resolvedTargets) {\n\t                    if (resolvedTarget.isRemoved) continue;\n\t                    part(engine, sourceCard, resolvedTarget);\n\t                }\n\t            }\n", "        }\n\t        engine.broadcast.push({\n\t            type: 'cardExecuted',\n\t            cardId: sourceCard.id,\n\t            targetCardId: targetCard.id,\n\t            scriptData: scriptDataFromCard || sourceCardScript,\n\t        });\n\t    }\n\t    static findCooldownData(data: CardScript.ScriptData) {\n\t        return data.find((x): x is CardScript.CooldownData => Array.isArray(x) && x[0] === '$cooldown');\n", "    }\n\t    static fromScriptName(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, scriptName: string) {\n\t        return this.deserialize(engine, card, [scriptName]).serialize();\n\t    }\n\t    static isOnCooldown(data: CardScript.ScriptData) {\n\t        return (this.findCooldownData(data)?.[1] || 0) > 0;\n\t    }\n\t    static makeCooldownData(max: number, cur = 0): CardScript.CooldownData {\n\t        return ['$cooldown', cur, max];\n\t    }\n", "    static removeScript(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, scriptType: CardScript.ScriptConstructor) {\n\t        const removed = card.scripts.findAndRemoveFirst(x => x[0] === scriptType.name);\n\t        if (!removed) throw new Error('script not found: ' + scriptType.name);\n\t        engine.broadcast.push({\n\t            type: 'scriptRemoved',\n\t            cardId: card.id,\n\t            removedScript: scriptType.name,\n\t        });\n\t    }\n\t    static tickCooldowns(card: GameEngine.ICardState, broadcast: IPlayerPushProvider.IPushMessage[]) {\n", "        for (const script of card.scripts) {\n\t            const cooldownData = CardScript.findCooldownData(script);\n\t            if (!cooldownData?.[1]) {\n\t                continue;\n\t            }\n\t            cooldownData[1]--;\n\t            broadcast.push({\n\t                type: 'scriptChanged',\n\t                cardId: card.id,\n\t                scriptData: script,\n", "            });\n\t        }\n\t    }\n\t}\n\texport namespace CardScript {\n\t    export type ScriptData = [string, ...unknown[]];\n\t    export type CooldownData = ['$cooldown', number, number];\n\t    export type ScriptConstructor = { new(card: GameEngine.ICardState, ...args: any[]): CardScript };\n\t    export type ScriptLibrary = Record<string, ScriptConstructor>;\n\t    export interface ITargetResolver {\n", "        (gameData: GameEngine.IGameData, sourceCard: GameEngine.ICardState, targetCard: GameEngine.ICardState): GameEngine.ICardState[];\n\t    }\n\t    export interface ITargetFinder {\n\t        (gameData: GameEngine.IGameData, card: GameEngine.ICardState): GameEngine.ICardState[];\n\t    }\n\t    export namespace TargetResolvers {\n\t        export const Self: ITargetResolver = (_, sourceCard) => [sourceCard];\n\t        export const Target: ITargetResolver = (_, _2, targetCard) => [targetCard];\n\t        export const TargetAndAdjacents: ITargetResolver = (gameData, _, targetCard) => {\n\t            const cards = GameEngineUtils.isEnemyCard(gameData, targetCard) ? gameData.enemies : (GameEngineUtils.findPlayerByCardId(gameData, targetCard.id).cards);\n", "            const i = cards.findIndex(x => x.id === targetCard.id);\n\t            return [cards[i], cards[i - 1], cards[i + 1]].filter(Boolean);\n\t        };\n\t        export const AllAllies: ITargetResolver = (gameData, sourceCard) => {\n\t            if (GameEngineUtils.isEnemyCard(gameData, sourceCard)) {\n\t                return TargetFinders._excludeOffline(gameData.enemies);\n\t            } else {\n\t                return TargetFinders._excludeOffline(GameEngineUtils.getPlayerCards(gameData));\n\t            }\n\t        };\n", "        export const RandomAlly: ITargetResolver = (gameData, sourceCard, targetCard) => {\n\t            return [AllAllies(gameData, sourceCard, targetCard).random()];\n\t        };\n\t        export const AllOpponents: ITargetResolver = (gameData, sourceCard) => {\n\t            if (GameEngineUtils.isEnemyCard(gameData, sourceCard)) {\n\t                return TargetFinders._excludeImperviousAndOffline(GameEngineUtils.getPlayerCards(gameData));\n\t            } else {\n\t                return TargetFinders._excludeImperviousAndOffline(gameData.enemies);\n\t            }\n\t        };\n", "        export const RandomOpponent: ITargetResolver = (gameData, sourceCard, targetCard) => {\n\t            return TargetFinders._excludeImperviousAndOffline([AllOpponents(gameData, sourceCard, targetCard).random()]);\n\t        };\n\t    }\n\t    export namespace TargetFinders {\n\t        export const Self: ITargetFinder = (_gameData, card) => [card];\n\t        export const Allies = (excludeSelf = false): ITargetFinder =>\n\t            (gameData, card) => {\n\t                let targets: GameEngine.ICardState[] = GameEngineUtils.isEnemyCard(gameData, card) ? gameData.enemies : GameEngineUtils.getPlayerCards(gameData);\n\t                excludeSelf && (targets = targets.filter(x => x.id !== card.id));\n", "                return _excludeOffline(targets);\n\t            };\n\t        export const Opponents = (ignoreTaunt = false): ITargetFinder =>\n\t            (gameData, card) => {\n\t                const targets = GameEngineUtils.isEnemyCard(gameData, card) ? GameEngineUtils.getPlayerCards(gameData) : gameData.enemies;\n\t                const standardTargets = _excludeImperviousAndOffline(targets);\n\t                if (!ignoreTaunt) {\n\t                    const taunts = _filterForFirewall(standardTargets);\n\t                    if (taunts.length) {\n\t                        return taunts;\n", "                    }\n\t                }\n\t                return standardTargets;\n\t            };\n\t        export const Any = (ignoreTaunt = false): ITargetFinder =>\n\t            (gameData, card) => [\n\t                ...Opponents(ignoreTaunt)(gameData, card),\n\t                ...Allies()(gameData, card),\n\t            ];\n\t        export const _ModFilter = <T extends CardMod.ModLibrary, K extends (keyof T & string)>(modFilter: K[], targetFinder: ITargetFinder): ITargetFinder =>\n", "            (gameData, card) => {\n\t                const targets = targetFinder(gameData, card);\n\t                const modMatches = targets.filter(target => target.mods.find(modData => modFilter.find(x => x === modData[0])));\n\t                return _excludeImperviousAndOffline(modMatches);\n\t            };\n\t        const _excludeImpervious = (cards: GameEngine.ICardState[]) => {\n\t            return cards.filter(x => !x.mods.find(y => y[0] === CardMod.Content.impervious.name));\n\t        };\n\t        export const _excludeOffline = (cards: GameEngine.ICardState[]) => {\n\t            return cards.filter(x => !x.mods.find(y => y[0] === CardMod.Content.offline.name));\n", "        };\n\t        export const _excludeImperviousAndOffline = (cards: GameEngine.ICardState[]) => _excludeImpervious(_excludeOffline(cards));\n\t        const _filterForFirewall = (cards: GameEngine.ICardState[]) => {\n\t            return cards.filter(x => x.mods.find(y => y[0] === CardMod.Content.firewall.name));\n\t        };\n\t    }\n\t    export namespace Content {\n\t        // Defines a card script - the class name is treated as the script name\n\t        export class bd_decode extends CardScript {\n\t            constructor(\n", "                // MUST always be the first parameter even if not used\n\t                card: GameEngine.ICardState,\n\t                // Not used but declared to show how the memo is passed back here, see first argument in super(...) below\n\t                _secDamage: number,\n\t            ) {\n\t                const secDamage = GameEngineUtils.scaleByCpuMem(12, card.cpu);\n\t                const bdChance = round(GameEngineUtils.scaleByCpuMem(20, card.mem, 'high') / 100, 2);\n\t                const bdDamage = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n\t                super(\n\t                    // Any extra data to serialize into scriptData[1:] as a 'memo' which can serve two purposes:\n", "                    // 1) the client relies on the memo to display potential card effects in the UI instead calculating it independently\n\t                    // 2) memo is passed back into the constructor during deserialization, useful for dynamic AI scripts\n\t                    [secDamage, bdChance, bdDamage],\n\t                    // Which cards are valid targets for this card; AI will typically .random()\n\t                    TargetFinders.Opponents(),\n\t                    // A composition of CardScriptParts that get executed when this card is played; this allows for\n\t                    // composition effects such as \"((damage and debuff) to target) AND (chance to stun neighbors)\":\n\t                    // The first part would use the Target resolver and Attack and ApplyMod parts\n\t                    // The second part would use the Neighbors resolver and curry Stun part into _Chance part\n\t                    [\n", "                        {\n\t                            // Given a chosen target, which actual targets these parts will execute on; this allows\n\t                            // a card to, for example, deal damage to the neighbors of the specified target\n\t                            targetResolver: TargetResolvers.Target,\n\t                            // CardScriptParts to execute on the resolved targets\n\t                            parts: [\n\t                                CardScriptParts.SecDmg(secDamage),\n\t                                CardScriptParts._Chance(bdChance,\n\t                                    CardScriptParts.AddMod(\n\t                                        new CardMod.Content.backdoor(bdDamage),\n", "                                    )\n\t                                ),\n\t                            ],\n\t                        }\n\t                    ],\n\t                );\n\t            }\n\t        }\n\t        export class bd_exploit extends CardScript {\n\t            constructor(card: GameEngine.ICardState) {\n", "                const damage = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n\t                const bdChance = round(GameEngineUtils.scaleByCpuMem(40, card.mem, 'more') / 100, 2);\n\t                super(\n\t                    [damage, bdChance],\n\t                    (gameData: GameEngine.IGameData, card: GameEngine.ICardState) => [\n\t                        ...TargetFinders.Opponents()(gameData, card),\n\t                        ...TargetFinders._ModFilter<typeof CardMod.Content, 'backdoor'>(['backdoor'],\n\t                            TargetFinders.Opponents(true))(gameData, card),\n\t                    ],\n\t                    [\n", "                        {\n\t                            targetResolver: TargetResolvers.Target,\n\t                            parts: [\n\t                                CardScriptParts._TargetHasMod<typeof CardMod.Content, 'backdoor'>('backdoor', mod => CardScriptParts.SecDmg(mod.stackingConfig.rank, true)),\n\t                                CardScriptParts.Attack(damage),\n\t                                CardScriptParts._Chance(bdChance,\n\t                                    CardScriptParts.AddMod(\n\t                                        new CardMod.Content.backdoor(damage),\n\t                                    )\n\t                                ),\n", "                            ],\n\t                        }\n\t                    ],\n\t                );\n\t            }\n\t        }\n\t        export class bd_secure extends CardScript {\n\t            constructor(card: GameEngine.ICardState) {\n\t                const secBonus = GameEngineUtils.scaleByCpuMem(10, card.cpu);\n\t                super(\n", "                    [secBonus],\n\t                    TargetFinders.Any(),\n\t                    [\n\t                        {\n\t                            targetResolver: TargetResolvers.Target,\n\t                            parts: [\n\t                                CardScriptParts.RaiseSec(secBonus),\n\t                            ],\n\t                        }\n\t                    ],\n", "                );\n\t                this.cooldownMax = 1;\n\t            }\n\t        }\n\t        export class bf_spam extends CardScript {\n\t            constructor(card: GameEngine.ICardState) {\n\t                const damage = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n\t                super(\n\t                    [damage],\n\t                    TargetFinders.Opponents(),\n", "                    [\n\t                        {\n\t                            targetResolver: TargetResolvers.Target,\n\t                            parts: [\n\t                                CardScriptParts.Attack(damage),\n\t                                CardScriptParts.Attack(damage),\n\t                            ],\n\t                        }\n\t                    ]\n\t                );\n", "            }\n\t        }\n\t        export class bf_firewall extends CardScript {\n\t            constructor(card: GameEngine.ICardState) {\n\t                const secBonus = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n\t                const modDuration = Math.ceil(card.mem / 2);\n\t                super(\n\t                    [secBonus, modDuration],\n\t                    TargetFinders.Self,\n\t                    [\n", "                        {\n\t                            targetResolver: TargetResolvers.Self,\n\t                            parts: [\n\t                                CardScriptParts.RaiseSec(secBonus),\n\t                                CardScriptParts.AddMod(\n\t                                    new CardMod.Content.firewall(modDuration),\n\t                                ),\n\t                            ],\n\t                        }\n\t                    ],\n", "                );\n\t                this.cooldownMax = 1;\n\t            }\n\t        }\n\t        export class bf_overclock extends CardScript {\n\t            constructor(card: GameEngine.ICardState) {\n\t                const damage = GameEngineUtils.scaleByCpuMem(17, card.cpu);\n\t                const lagChance = round((100 - GameEngineUtils.scaleByCpuMem(30, card.mem)) / 100, 2);\n\t                const lagDuration = 2;\n\t                super(\n", "                    [damage, lagChance, lagDuration],\n\t                    CardScript.TargetFinders.Opponents(),\n\t                    [\n\t                        {\n\t                            targetResolver: CardScript.TargetResolvers.Target,\n\t                            parts: [\n\t                                CardScriptParts.Attack(damage),\n\t                            ],\n\t                        },\n\t                        {\n", "                            targetResolver: CardScript.TargetResolvers.Self,\n\t                            parts: [\n\t                                CardScriptParts._Chance(lagChance,\n\t                                    CardScriptParts.AddMod(\n\t                                        new CardMod.Content.lag(lagDuration),\n\t                                    ),\n\t                                ),\n\t                            ],\n\t                        }\n\t                    ],\n", "                );\n\t            }\n\t        }\n\t        export class mw_freeware extends CardScript {\n\t            constructor(card: GameEngine.ICardState) {\n\t                const minBonus = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n\t                const maxBonus = GameEngineUtils.scaleByCpuMem(12, card.cpu, 'more');\n\t                super(\n\t                    [minBonus, maxBonus],\n\t                    TargetFinders.Any(),\n", "                    [\n\t                        {\n\t                            targetResolver: TargetResolvers.Target,\n\t                            parts: [\n\t                                CardScriptParts.RaiseSec(randInt(minBonus, maxBonus)),\n\t                            ],\n\t                        }\n\t                    ],\n\t                );\n\t                this.cooldownMax = 1;\n", "            }\n\t        }\n\t        export class mw_redirect extends CardScript {\n\t            constructor(card: GameEngine.ICardState) {\n\t                const tempSecBonus = GameEngineUtils.scaleByCpuMem(10, card.cpu);\n\t                const duration = Math.ceil(card.mem / 2);\n\t                super(\n\t                    [tempSecBonus, duration],\n\t                    TargetFinders.Allies(true),\n\t                    [\n", "                        {\n\t                            targetResolver: TargetResolvers.Target,\n\t                            parts: [\n\t                                CardScriptParts.AddMod(\n\t                                    new CardMod.Content.secured(tempSecBonus, duration),\n\t                                ),\n\t                                CardScriptParts.AddMod(\n\t                                    new CardMod.Content.firewall(duration),\n\t                                ),\n\t                            ],\n", "                        }\n\t                    ],\n\t                );\n\t                this.cooldownMax = 1;\n\t            }\n\t        }\n\t        export class mw_worm extends CardScript {\n\t            constructor(card: GameEngine.ICardState) {\n\t                const minDamage = GameEngineUtils.scaleByCpuMem(7, card.cpu);\n\t                const maxDamage = GameEngineUtils.scaleByCpuMem(13, card.cpu);\n", "                super(\n\t                    [minDamage, maxDamage],\n\t                    TargetFinders.Opponents(),\n\t                    [\n\t                        {\n\t                            targetResolver: TargetResolvers.Target,\n\t                            parts: [\n\t                                CardScriptParts.Attack(randInt(minDamage, maxDamage)),\n\t                            ],\n\t                        }\n", "                    ],\n\t                );\n\t            }\n\t        }\n\t        export class _attack extends CardScript {\n\t            constructor(card: GameEngine.ICardState, difficulty: number, strength: 'weak' | 'normal' | 'strong' = 'normal', cooldown = 0) {\n\t                let minDmg = 0;\n\t                let maxDmg = 0;\n\t                switch (strength) {\n\t                    case 'weak':\n", "                        minDmg = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n\t                        maxDmg = GameEngineUtils.scaleByCpuMem(8, card.cpu);\n\t                        break;\n\t                    case 'normal':\n\t                        minDmg = GameEngineUtils.scaleByCpuMem(8, card.cpu);\n\t                        maxDmg = GameEngineUtils.scaleByCpuMem(12, card.cpu);\n\t                        break;\n\t                    case 'strong':\n\t                        minDmg = GameEngineUtils.scaleByCpuMem(11, card.cpu);\n\t                        maxDmg = GameEngineUtils.scaleByCpuMem(15, card.cpu);\n", "                        break;\n\t                }\n\t                minDmg = GameEngineUtils.scaleByDifficulty(minDmg, difficulty);\n\t                maxDmg = GameEngineUtils.scaleByDifficulty(maxDmg, difficulty);\n\t                super(\n\t                    [difficulty, strength, cooldown, minDmg, maxDmg],\n\t                    TargetFinders.Opponents(),\n\t                    [\n\t                        {\n\t                            targetResolver: TargetResolvers.Target,\n", "                            parts: [\n\t                                CardScriptParts.Attack(randInt(minDmg, maxDmg)),\n\t                            ],\n\t                        }\n\t                    ],\n\t                );\n\t                this.cooldownMax = cooldown;\n\t            }\n\t        }\n\t        export class _defend extends CardScript {\n", "            constructor(card: GameEngine.ICardState, difficulty: number, strength: 'weak' | 'normal' | 'strong' = 'normal', cooldown = 0) {\n\t                let minBonus = 0;\n\t                let maxBonus = 0;\n\t                switch (strength) {\n\t                    case 'weak':\n\t                        minBonus = GameEngineUtils.scaleByCpuMem(4, card.cpu);\n\t                        maxBonus = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n\t                        break;\n\t                    case 'normal':\n\t                        minBonus = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n", "                        maxBonus = GameEngineUtils.scaleByCpuMem(8, card.cpu);\n\t                        break;\n\t                    case 'strong':\n\t                        minBonus = GameEngineUtils.scaleByCpuMem(8, card.cpu);\n\t                        maxBonus = GameEngineUtils.scaleByCpuMem(11, card.cpu);\n\t                        break;\n\t                }\n\t                minBonus = GameEngineUtils.scaleByDifficulty(minBonus, difficulty);\n\t                maxBonus = GameEngineUtils.scaleByDifficulty(maxBonus, difficulty);\n\t                super(\n", "                    [difficulty, strength, cooldown, minBonus, maxBonus],\n\t                    TargetFinders.Allies(),\n\t                    [\n\t                        {\n\t                            targetResolver: TargetResolvers.Target,\n\t                            parts: [\n\t                                CardScriptParts.RaiseSec(randInt(minBonus, maxBonus)),\n\t                            ],\n\t                        }\n\t                    ],\n", "                );\n\t                this.cooldownMax = cooldown;\n\t            }\n\t        }\n\t        export class _firewallSelf extends CardScript {\n\t            constructor(_card: GameEngine.ICardState, duration = 1, cooldown = 0, startingCooldown = 0) {\n\t                super(\n\t                    [duration, cooldown],\n\t                    TargetFinders.Self,\n\t                    [\n", "                        {\n\t                            targetResolver: TargetResolvers.Target,\n\t                            parts: [\n\t                                CardScriptParts.AddMod(\n\t                                    new CardMod.Content.firewall(duration + 1),\n\t                                ),\n\t                            ],\n\t                        }\n\t                    ],\n\t                );\n", "                this.cooldownCur = startingCooldown;\n\t                this.cooldownMax = cooldown;\n\t            }\n\t        }\n\t        export class _spawn extends CardScript {\n\t            constructor(_card: GameEngine.ICardState, enemyClass: string, spawnPosition: Parameters<typeof CardScriptParts['SpawnEnemy']>[1] = 'relLeft', generateIntent = false, cooldown = 0) {\n\t                super(\n\t                    [enemyClass, spawnPosition, generateIntent, cooldown],\n\t                    TargetFinders.Self,\n\t                    [\n", "                        {\n\t                            targetResolver: TargetResolvers.Self,\n\t                            parts: [\n\t                                CardScriptParts.SpawnEnemy(enemyClass, spawnPosition, generateIntent),\n\t                            ],\n\t                        }\n\t                    ],\n\t                );\n\t                this.cooldownMax = cooldown;\n\t            }\n", "        }\n\t    }\n\t    (Content as Record<CoreScriptNames, ScriptConstructor>);\n\t}"]}
{"filename": "src/game/game-engine.ts", "chunked_list": ["import * as moment from 'moment';\n\timport { IAppraisedCard, appraiseCard } from '../appraise';\n\timport { IDataSource, IMetricsProvider, IPlayerPushProvider } from '../dependencies';\n\timport { ExtDeps } from '../external-dependencies';\n\timport { SECS_IN_MIN } from '../utils';\n\timport { CardMod } from './card-mods';\n\timport { CardScript } from './card-scripts';\n\timport { GameContent_v1 } from './game-content-v1';\n\timport { GameEngineUtils } from './game-engine-utils';\n\texport namespace GameEngine {\n", "    interface _ICommonCardState {\n\t        id: number;\n\t        cpu: number;\n\t        mem: number;\n\t        sec: number;\n\t        mods: CardMod.ModData[];\n\t        scripts: CardScript.ScriptData[];\n\t        isRemoved?: boolean;\n\t    }\n\t    export interface IGameData {\n", "        id: string;\n\t        difficulty: number;\n\t        state: 'created' | 'started' | 'players_won' | 'players_lost' | 'abandoned';\n\t        enemies: IEnemyCardState[];\n\t        maxEnemies: number;\n\t        players: Map<string, IPlayerState>;\n\t        defaultMovesPerTurn: number;\n\t        turn: number;\n\t        nextId: number;\n\t        pendingPlayers: Map<string, string[]>;\n", "        rulesetIds: string[];\n\t    }\n\t    export interface IPlayerState {\n\t        id: string;\n\t        cards: IPlayerCardState[];\n\t        endedTurn: boolean;\n\t        idleKickTime: number;\n\t        movesLeft: number;\n\t        movesPerTurn: number;\n\t        score: number;\n", "        stats: {\n\t            kills: number;\n\t            secDmg: number;\n\t            memDmg: number;\n\t            secBonus: number;\n\t        };\n\t    }\n\t    export interface IPlayerCardState extends _ICommonCardState {\n\t        card: IAppraisedCard;\n\t        isUsed: boolean;\n", "    }\n\t    export interface IEnemyCardState extends _ICommonCardState {\n\t        enemyClass: string;\n\t        intent?: { scriptData: CardScript.ScriptData, targetCardId: number };\n\t        maxMem: number;\n\t    }\n\t    export type ICardState = IPlayerCardState | IEnemyCardState;\n\t    export abstract class GameEngineError extends Error {\n\t        constructor(\n\t            public gameId: string,\n", "        ) {\n\t            super();\n\t            this.message = `${this.constructor.name} processing game ${gameId}`;\n\t        }\n\t    }\n\t    export class GameNotFoundError extends GameEngineError { }\n\t    export interface IRulesetContent {\n\t        cardMods?: CardMod.ModLibrary;\n\t        cardScripts?: CardScript.ScriptLibrary;\n\t        enemyCards?: Record<string, (engine: IGameEngine) => IEnemyCardState>;\n", "    }\n\t    export interface IRuleset extends IRulesetContent {\n\t        initGame(engine: IGameEngine): void;\n\t        addAdditionalScriptsFor?(engine: GameEngine.IGameEngine, card: IPlayerCardState): void;\n\t    }\n\t    export function mergeRulesetContents(...rulesets: IRulesetContent[]): IRulesetContent {\n\t        const modLibs = rulesets.map(x => x.cardMods).filter(Boolean);\n\t        const scriptLibs = rulesets.map(x => x.cardScripts).filter(Boolean);\n\t        const enemyLibs = rulesets.map(x => x.enemyCards).filter(Boolean);\n\t        return {\n", "            cardMods: Object.fromEntries(modLibs.map(modLib => Object.keys(modLib).map(modName => [modName, modLib[modName]!] as const)).flat()),\n\t            cardScripts: Object.fromEntries(scriptLibs.map(scriptLib => Object.keys(scriptLib).map(scriptName => [scriptName, scriptLib[scriptName]!] as const)).flat()),\n\t            enemyCards: Object.fromEntries(enemyLibs.map(enemyLib => Object.keys(enemyLib).map(enemyClass => [enemyClass, enemyLib[enemyClass]!] as const)).flat()),\n\t        };\n\t    }\n\t    export type IGameEngine = InstanceType<ReturnType<typeof createGameEngineProvider>>;\n\t}\n\texport const createGameEngineProvider = (rulesets: Record<string, GameEngine.IRuleset>, ds: IDataSource, playerPushProvider: IPlayerPushProvider, metrics?: IMetricsProvider) => {\n\t    return class _Engine {\n\t        readonly broadcast: IPlayerPushProvider.IPushMessage[] = [];\n", "        ruleset!: GameEngine.IRuleset;\n\t        constructor(\n\t            readonly gameData: GameEngine.IGameData,\n\t        ) {\n\t            const currentRuleset = rulesets[gameData.rulesetIds.at(-1)!];\n\t            if (!currentRuleset) throw new Error('invalid initial ruleSet id: ' + gameData.rulesetIds[0]);\n\t            this._setRuleset(currentRuleset);\n\t        }\n\t        private static async _withEngine(gameId: string, stateAssertion: GameEngine.IGameData['state'][], func: (engine: _Engine) => Promise<void>): Promise<GameEngine.IGameData> {\n\t            const gameData = await ds.GameData.get(gameId);\n", "            if (!gameData) throw new GameEngine.GameNotFoundError(gameId);\n\t            const engine = new _Engine(gameData);\n\t            try {\n\t                if (stateAssertion.length && !stateAssertion.includes(gameData.state)) throw new Error('wrong game state, expected: ' + stateAssertion.join() + ', got: ' + gameData.state);\n\t                await func(engine);\n\t                await ds.GameData.update.exec(gameData);\n\t            } catch (e: any) {\n\t                e.broadcast = engine.broadcast;\n\t                throw e;\n\t            }\n", "            if (engine.broadcast.length) {\n\t                await Promise.all(\n\t                    [...gameData.players.keys()].map(playerId => playerPushProvider.push(playerId, engine.broadcast)),\n\t                );\n\t            }\n\t            return gameData;\n\t        }\n\t        static async createGame(gameId: string, rulesetId: string, difficulty: number) {\n\t            const ruleset = rulesets[rulesetId];\n\t            if (!ruleset) throw new Error('invalid ruleSet id: ' + rulesetId);\n", "            const existingGameData = await ds.GameData.get(gameId);\n\t            if (existingGameData) throw new Error('game with id already exists: ' + gameId);\n\t            const gameData: GameEngine.IGameData = {\n\t                id: gameId,\n\t                difficulty: Math.max(1, difficulty),\n\t                state: 'created',\n\t                turn: 1,\n\t                players: new Map(),\n\t                defaultMovesPerTurn: 3,\n\t                enemies: [],\n", "                maxEnemies: 9,\n\t                nextId: 1,\n\t                pendingPlayers: new Map(),\n\t                rulesetIds: [rulesetId],\n\t            };\n\t            await ds.GameData.update.exec(gameData);\n\t        }\n\t        static async startGame(gameId: string) {\n\t            const gameData = await _Engine._withEngine(gameId, ['created'], async engine => {\n\t                for (const [playerId, cardIds] of engine.gameData.pendingPlayers) {\n", "                    const playerState = await engine._createPlayerState(playerId, cardIds);\n\t                    engine.gameData.players.set(playerId, playerState);\n\t                    engine.broadcast.push({ type: 'playerJoin', playerState });\n\t                }\n\t                engine.gameData.pendingPlayers.clear();\n\t                engine.gameData.state = 'started';\n\t                engine.broadcast.push({ type: 'gameStart' });\n\t                engine.ruleset.initGame(engine);\n\t            });\n\t            return gameData;\n", "        }\n\t        static async endGame(gameId: string) {\n\t            return await _Engine._withEngine(gameId, ['created', 'started'], async engine => {\n\t                engine.gameData.state = 'abandoned';\n\t                engine.broadcast.push({ type: 'gameEnd' });\n\t            });\n\t        }\n\t        static async addPlayer(gameId: string, playerId: string, cardIds: string[]) {\n\t            return await _Engine._withEngine(gameId, ['created', 'started'], async engine => {\n\t                if (engine.gameData.players.has(playerId)) throw new Error('player already in game');\n", "                if (engine.gameData.players.size >= 2) throw new Error('game is full: ' + gameId);\n\t                if (engine.gameData.state === 'started') {\n\t                    const playerState = await engine._createPlayerState(playerId, cardIds);\n\t                    engine.gameData.players.set(playerId, playerState);\n\t                    if (engine.gameData.turn >= 2) {\n\t                        playerState.endedTurn = true;\n\t                        playerState.movesLeft = 0;\n\t                    }\n\t                    engine.broadcast.push({\n\t                        type: 'playerJoin',\n", "                        playerState,\n\t                    });\n\t                } else {\n\t                    engine.gameData.pendingPlayers.set(playerId, cardIds);\n\t                }\n\t            });\n\t        }\n\t        static async removePlayer(gameId: string, playerId: string, reason: 'idle' | 'leave') {\n\t            return await _Engine._withEngine(gameId, [], async engine => {\n\t                if (!engine.gameData.players.delete(playerId)) throw new Error('player not found');\n", "                engine.broadcast.push({ type: 'playerLeave', playerId, reason });\n\t                GameEngineUtils.revalidateIntents(engine, true);\n\t                for (const remainingPlayer of engine.gameData.players.values()) {\n\t                    remainingPlayer.endedTurn = false;\n\t                    engine.broadcast.push({\n\t                        type: 'playerToggleEndTurn',\n\t                        playerId: remainingPlayer.id,\n\t                        state: false,\n\t                    });\n\t                }\n", "            });\n\t        }\n\t        static async requestCardTargets(gameId: string, playerId: string, cardId: number, scriptName: string) {\n\t            const gameData = await _Engine.getGameData(gameId);\n\t            const card = GameEngineUtils.findPlayerCardById(gameData, cardId);\n\t            let targets = [] as number[];\n\t            try {\n\t                if (card.isUsed) {\n\t                    return;\n\t                }\n", "                const scriptData = card.scripts.find(x => x[0] === scriptName);\n\t                if (!scriptData) {\n\t                    throw new Error(`Script [${scriptName}] not found in card [${cardId}]`);\n\t                }\n\t                if (CardScript.isOnCooldown(scriptData)) {\n\t                    return;\n\t                }\n\t                const engine = new _Engine(gameData);\n\t                const script = CardScript.deserialize(engine, card, scriptData);\n\t                targets = script.targetFinder(gameData, card).map(x => x.id);\n", "            } finally {\n\t                await playerPushProvider.push(playerId, [{\n\t                    type: 'cardTargets',\n\t                    cardId,\n\t                    scriptName,\n\t                    targetCardIds: targets,\n\t                }]);\n\t            }\n\t        }\n\t        static async intent(gameId: string, playerId: string, sourceCardId?: string, sourceCardScript?: string, targetCardId?: string) {\n", "            const gameData = await _Engine.getGameData(gameId);\n\t            const pushMessage: IPlayerPushProvider.IPushMessage[] = [{\n\t                type: 'cardIntent',\n\t                cardId: sourceCardId,\n\t                intent: {\n\t                    scriptData: sourceCardScript,\n\t                    targetCardId,\n\t                },\n\t                playerId,\n\t            }];\n", "            await Promise.all(\n\t                [...gameData.players.keys()].filter(x => x !== playerId).map(x => playerPushProvider?.push(x, pushMessage)),\n\t            );\n\t        }\n\t        static async makeMove(gameId: string, playerId: string, sourceCardId: number, sourceCardScript: CardScript.ScriptData, targetCardId: number) {\n\t            return await _Engine._withEngine(gameId, ['started'], async engine => {\n\t                const playerState = GameEngineUtils.findPlayerByCardId(engine.gameData, sourceCardId);\n\t                if (playerState.id !== playerId) {\n\t                    throw new Error(`Player ${playerId} cannot make move on card ${sourceCardId} from owner ${playerState.id}`);\n\t                }\n", "                if (!playerState.movesLeft) {\n\t                    throw new Error(`No moves left`);\n\t                }\n\t                const sourceCard = playerState.cards.find(x => x.id === sourceCardId)!;\n\t                if (sourceCard.isUsed) {\n\t                    throw new Error(`Card is used`);\n\t                }\n\t                const now = moment.now();\n\t                playerState.idleKickTime = now + 2 * SECS_IN_MIN * 1000;\n\t                playerState.movesLeft--;\n", "                const targetCard = GameEngineUtils.findCardById(engine.gameData, targetCardId);\n\t                CardScript.execute(engine, sourceCard, sourceCardScript, targetCard);\n\t                GameEngineUtils.changeCardIsUsed(engine, sourceCard, true);\n\t                metrics?.playerCardPlayed(gameId, engine.gameData.rulesetIds[0] || 'unknown', playerId, sourceCard, sourceCardScript[0]);\n\t            });\n\t        }\n\t        static async toggleEndTurn(gameId: string, playerId: string) {\n\t            return await _Engine._withEngine(gameId, ['started'], async engine => {\n\t                const playerState = engine.gameData.players.get(playerId);\n\t                if (!playerState) throw new Error('player not found');\n", "                if (playerState.endedTurn) {\n\t                    playerState.endedTurn = false;\n\t                    engine.broadcast.push({\n\t                        type: 'playerToggleEndTurn',\n\t                        playerId,\n\t                        state: false,\n\t                    });\n\t                    return;\n\t                }\n\t                playerState.endedTurn = true;\n", "                engine.broadcast.push({\n\t                    type: 'playerToggleEndTurn',\n\t                    playerId,\n\t                    state: true,\n\t                });\n\t                if (![...engine.gameData.players.values()].reduce((numNotReady, playerState) => playerState.endedTurn ? numNotReady : (numNotReady + 1), 0)) {\n\t                    const now = moment.now();\n\t                    [...engine.gameData.players.values()].forEach(x => x.idleKickTime = now + 2 * SECS_IN_MIN * 1000);\n\t                    engine.onEndTurn();\n\t                    if (engine.gameData.state !== 'started') {\n", "                        // Stop if the game was won/lost due to an EndTurn effect\n\t                        return;\n\t                    }\n\t                    engine.onTurnStart();\n\t                }\n\t            });\n\t        }\n\t        static async kickTeammateIfIdle(gameId: string, kickRequestingPlayerId: string) {\n\t            let kickedPlayerId = '';\n\t            await _Engine._withEngine(gameId, ['started'], async engine => {\n", "                const playerToKick = [...engine.gameData.players.values()].find(x => x.id !== kickRequestingPlayerId) || '';\n\t                if (!playerToKick) throw new Error('kickIfIdle: player not found');\n\t                if (playerToKick.idleKickTime < moment.now()) {\n\t                    if (!engine.gameData.players.delete(playerToKick.id)) throw new Error('player not found');\n\t                    engine.broadcast.push({ type: 'playerLeave', playerId: playerToKick.id, reason: 'idle' });\n\t                    GameEngineUtils.revalidateIntents(engine, true);\n\t                    for (const remainingPlayer of engine.gameData.players.values()) {\n\t                        remainingPlayer.endedTurn = false;\n\t                        engine.broadcast.push({\n\t                            type: 'playerToggleEndTurn',\n", "                            playerId: remainingPlayer.id,\n\t                            state: false,\n\t                        });\n\t                    }\n\t                    kickedPlayerId = playerToKick.id;\n\t                }\n\t            });\n\t            return kickedPlayerId || null;\n\t        }\n\t        static async getGameData(gameId: string) {\n", "            const gameData = await ds.GameData.get(gameId);\n\t            if (!gameData) throw new GameEngine.GameNotFoundError(gameId);\n\t            return gameData;\n\t        }\n\t        private async _createPlayerState(playerId: string, cardIds: string[]): Promise<GameEngine.IPlayerState> {\n\t            const cards = (await Promise.all(cardIds.map(ExtDeps.getNft)))\n\t                .filter((resp): resp is NonNullable<typeof resp> => !!resp?.nft)\n\t                .map(resp => appraiseCard({ nftId: resp.nft.nftId, mintHeight: resp.nft.firstBlock, url: resp.nft.urls[0] || '' }));\n\t            if (cards.length !== cardIds.length) {\n\t                throw `could not resolve all cards for player ${playerId}`;\n", "            }\n\t            const player: GameEngine.IPlayerState = {\n\t                id: playerId,\n\t                cards: cards.map(card => ({\n\t                    id: this.nextId(),\n\t                    card,\n\t                    isUsed: false,\n\t                    cpu: card.cpu,\n\t                    mem: card.mem,\n\t                    sec: card.mem * 6 + card.cpu * 3,\n", "                    mods: [],\n\t                    scripts: [],\n\t                })),\n\t                endedTurn: false,\n\t                movesLeft: this.gameData.defaultMovesPerTurn,\n\t                movesPerTurn: this.gameData.defaultMovesPerTurn,\n\t                stats: {\n\t                    kills: 0,\n\t                    memDmg: 0,\n\t                    secBonus: 0,\n", "                    secDmg: 0,\n\t                },\n\t                score: 0,\n\t                idleKickTime: moment.now() + 2 * SECS_IN_MIN * 1000,\n\t            };\n\t            for (const card of player.cards) {\n\t                card.scripts = [\n\t                    CardScript.fromScriptName(this, card, card.card.coreScript),\n\t                ];\n\t                this.ruleset.addAdditionalScriptsFor && this.ruleset.addAdditionalScriptsFor(this, card);\n", "            }\n\t            return player;\n\t        }\n\t        findRuleset(rulesetId: string) {\n\t            return rulesets[rulesetId];\n\t        }\n\t        onTurnStart() {\n\t            this.gameData.turn++;\n\t            this.broadcast.push({\n\t                type: 'newTurn',\n", "                turn: this.gameData.turn,\n\t            });\n\t            for (const player of this.gameData.players.values()) {\n\t                player.endedTurn = false;\n\t                player.movesLeft = player.movesPerTurn;\n\t            }\n\t            const playerCards = GameEngineUtils.getPlayerCards(this.gameData);\n\t            for (const playerCard of playerCards) {\n\t                GameEngineUtils.changeCardIsUsed(this, playerCard, false);\n\t            }\n", "            for (const playerCard of [...playerCards]) {\n\t                if (!playerCards.includes(playerCard)) continue;\n\t                GameEngineUtils.triggerMods('onTurnStart', { engine: this, sourceCard: playerCard });\n\t            }\n\t            for (const enemy of [...this.gameData.enemies]) {\n\t                if (!this.gameData.enemies.includes(enemy)) continue;\n\t                GameEngineUtils.triggerMods('onTurnStart', { engine: this, sourceCard: enemy });\n\t            }\n\t            this._checkGameOver();\n\t        }\n", "        onEndTurn() {\n\t            const playerCards = GameEngineUtils.getPlayerCards(this.gameData);\n\t            for (const playerCard of [...playerCards]) {\n\t                if (!playerCards.includes(playerCard)) continue;\n\t                GameEngineUtils.triggerMods('onTurnEnd', { engine: this, sourceCard: playerCard });\n\t                CardScript.tickCooldowns(playerCard, this.broadcast);\n\t            }\n\t            this.broadcast.push({\n\t                type: 'playerTurnEnded',\n\t            });\n", "            for (const enemy of [...this.gameData.enemies]) {\n\t                if (!this.gameData.enemies.includes(enemy)) continue;\n\t                GameEngineUtils.triggerMods('onTurnEnd', { engine: this, sourceCard: enemy });\n\t                CardScript.tickCooldowns(enemy, this.broadcast);\n\t            }\n\t            this.broadcast.push({\n\t                type: 'enemyTurnEnded',\n\t            });\n\t            this._checkGameOver();\n\t        }\n", "        onNextWave(nextRulesetId: string) {\n\t            while (this.gameData.enemies[0]) {\n\t                GameEngineUtils.removeCard(this, this.gameData.enemies[0]);\n\t            }\n\t            [...this.gameData.players.values()].forEach(player => {\n\t                player.endedTurn = false;\n\t                player.movesLeft = player.movesPerTurn;\n\t                player.cards.forEach(card => {\n\t                    card.isUsed = false;\n\t                });\n", "            });\n\t            this.gameData.turn++;\n\t            this.broadcast.push({\n\t                type: 'nextWave',\n\t                turn: this.gameData.turn,\n\t                nextRulesetId,\n\t            });\n\t            const nextRuleset = this.findRuleset(nextRulesetId);\n\t            if (!nextRuleset) {\n\t                throw new Error('invalid rulesetId: ' + nextRulesetId);\n", "            }\n\t            this.gameData.rulesetIds.push(nextRulesetId);\n\t            this._setRuleset(nextRuleset);\n\t            nextRuleset.initGame(this);\n\t        }\n\t        onWinGame() {\n\t            this.gameData.state = 'players_won';\n\t            this.broadcast.push({\n\t                type: 'players_won',\n\t                stats: [...this.gameData.players.values()].map(player => {\n", "                    let score =\n\t                        player.cards.length * 50\n\t                        + player.stats.kills * 25\n\t                        + player.stats.memDmg * 50\n\t                        + player.stats.secDmg\n\t                        + player.stats.secBonus * 2\n\t                        + ((this.gameData.rulesetIds.length - 1) * 2000);\n\t                    score = GameEngineUtils.scaleByDifficulty(score, this.gameData.difficulty + 1);\n\t                    player.score = score;\n\t                    return { playerId: player.id, stats: player.stats, score };\n", "                }),\n\t            });\n\t        }\n\t        nextId() {\n\t            return this.gameData.nextId++;\n\t        }\n\t        private _checkGameOver() {\n\t            if (!GameEngineUtils.getPlayerCards(this.gameData).length) {\n\t                this.gameData.state = 'players_lost';\n\t                this.broadcast.push({\n", "                    type: 'players_lost',\n\t                });\n\t            }\n\t        }\n\t        private _setRuleset(nextRuleset: GameEngine.IRuleset) {\n\t            this.ruleset = {\n\t                addAdditionalScriptsFor: GameContent_v1.addAdditionalScriptsFor,\n\t                ...nextRuleset,\n\t                ...GameEngine.mergeRulesetContents(\n\t                    nextRuleset,\n", "                    {\n\t                        cardMods: CardMod.Content,\n\t                        cardScripts: CardScript.Content,\n\t                    },\n\t                    {\n\t                        cardMods: GameContent_v1.cardMods,\n\t                        cardScripts: GameContent_v1.cardScripts,\n\t                        enemyCards: GameContent_v1.enemyCards,\n\t                    }\n\t                ),\n", "            };\n\t        }\n\t    }\n\t}\n\texport type GameEngineProvider = ReturnType<typeof createGameEngineProvider>;"]}
{"filename": "src/game/game-content-v1.ts", "chunked_list": ["import { randInt } from '../utils';\n\timport { CardMod } from './card-mods';\n\timport { CardScriptParts } from './card-script-parts';\n\timport { CardScript } from './card-scripts';\n\timport { GameEngine } from './game-engine';\n\timport { GameEngineUtils } from './game-engine-utils';\n\tconst _cardMods = {\n\t    // Increases incoming damage\n\t    exposed: class extends CardMod {\n\t        override stackingConfig = {\n", "            behavior: CardMod.StackingBehavior.stack as const,\n\t            stackCount: 0,\n\t        };\n\t        constructor(public stackCount: number) {\n\t            super(arguments);\n\t            this.stackingConfig.stackCount = stackCount;\n\t        }\n\t        override onSecDamageIn(_deps: CardMod.ICardModDeps, _damage: number, _attacker: GameEngine.ICardState) {\n\t            return { secDmgBonus: this.stackingConfig.stackCount };\n\t        }\n", "    },\n\t    // Returns damage to attacker\n\t    feedback: class extends CardMod {\n\t        override stackingConfig = {\n\t            behavior: CardMod.StackingBehavior.stack as const,\n\t            stackCount: 0,\n\t        };\n\t        constructor(public damage: number) {\n\t            super(arguments);\n\t            this.stackingConfig.stackCount = damage;\n", "        }\n\t        override onSecDamageIn(deps: CardMod.ICardModDeps, _damage: number, attacker: GameEngine.ICardState) {\n\t            CardScriptParts.SecDmg(this.stackingConfig.stackCount, false, true)(deps.engine, deps.sourceCard, attacker);\n\t        }\n\t    },\n\t    // Increases CPU\n\t    optimized: class extends CardMod {\n\t        override stackingConfig = {\n\t            behavior: CardMod.StackingBehavior.stack as const,\n\t            stackCount: 0,\n", "        };\n\t        constructor(cpuBonus: number, override duration: number) {\n\t            super(arguments);\n\t            this.stackingConfig.stackCount = cpuBonus;\n\t        }\n\t        override onInitMod(deps: CardMod.ICardModDeps) {\n\t            GameEngineUtils.changeCpu(deps.engine, deps.sourceCard, this.stackingConfig.stackCount);\n\t        }\n\t        override onStackMod(deps: CardMod.ICardModDeps, stackDelta: number) {\n\t            deps.sourceCard.cpu += stackDelta;\n", "            deps.engine.broadcast.push({\n\t                type: 'cpuChanged',\n\t                cardId: deps.sourceCard.id,\n\t                newCpu: deps.sourceCard.cpu,\n\t            });\n\t            GameEngineUtils.recalculateScripts(deps.engine, deps.sourceCard);\n\t        }\n\t        override onRemoveMod(deps: CardMod.ICardModDeps) {\n\t            deps.sourceCard.cpu -= this.stackingConfig.stackCount;\n\t            deps.engine.broadcast.push({\n", "                type: 'cpuChanged',\n\t                cardId: deps.sourceCard.id,\n\t                newCpu: deps.sourceCard.cpu,\n\t            });\n\t            GameEngineUtils.recalculateScripts(deps.engine, deps.sourceCard);\n\t        }\n\t    },\n\t    // Damages on turn end\n\t    virus: class extends CardMod {\n\t        override stackingConfig = {\n", "            behavior: CardMod.StackingBehavior.stack as const,\n\t            stackCount: 0,\n\t        };\n\t        constructor(public dot: number) {\n\t            super(arguments);\n\t            this.stackingConfig.stackCount = dot;\n\t        }\n\t        override onTurnEnd(deps: CardMod.ICardModDeps) {\n\t            CardScriptParts.SecDmg(this.stackingConfig.stackCount, true, true)(deps.engine, deps.sourceCard, deps.sourceCard);\n\t        }\n", "    },\n\t};\n\tconst _cardScripts = {\n\t    //\n\t    // Backdoor scripts\n\t    //\n\t    // Swap MEM for CPU\n\t    bd_caching: class extends CardScript {\n\t        constructor(_card: GameEngine.ICardState) {\n\t            super(\n", "                [],\n\t                (gameData, card) => CardScript.TargetFinders.Allies()(gameData, card).filter(x => x.mem > 1),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n\t                            CardScriptParts.RaiseMem(-1),\n\t                            CardScriptParts.ChangeCpu(1),\n\t                        ],\n\t                    }\n", "                ],\n\t            );\n\t            this.cooldownMax = 1;\n\t        }\n\t    },\n\t    // Raise MEM\n\t    bd_defrag: class extends CardScript {\n\t        constructor(_card: GameEngine.ICardState) {\n\t            const memBonus = 1;\n\t            super(\n", "                [memBonus],\n\t                CardScript.TargetFinders.Any(),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n\t                            CardScriptParts.RaiseMem(1),\n\t                        ],\n\t                    }\n\t                ],\n", "            );\n\t            this.cooldownMax = 4;\n\t        }\n\t    },\n\t    // Heal over time\n\t    bd_diagnostics: class extends CardScript {\n\t        constructor(card: GameEngine.ICardState) {\n\t            const secBonus = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n\t            const duration = 1 + Math.round(card.mem / 2);\n\t            super(\n", "                [secBonus, duration],\n\t                CardScript.TargetFinders.Any(),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n\t                            CardScriptParts.AddMod(\n\t                                new CardMod.Content.diagnostics(secBonus, duration)\n\t                            ),\n\t                        ],\n", "                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = 4;\n\t        }\n\t    },\n\t    // Attack and stun (Backdoor finisher)\n\t    bd_disrupt: class extends CardScript {\n\t        constructor(card: GameEngine.ICardState) {\n\t            const damage = GameEngineUtils.scaleByCpuMem(9, card.cpu);\n", "            const stunDuration = 1;\n\t            super(\n\t                [damage, stunDuration],\n\t                CardScript.TargetFinders._ModFilter<typeof CardMod.Content, 'backdoor'>(['backdoor'],\n\t                    CardScript.TargetFinders.Opponents(true),\n\t                ),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n", "                            CardScriptParts.Attack(damage),\n\t                            CardScriptParts.AddMod(\n\t                                new CardMod.Content.lag(stunDuration),\n\t                            ),\n\t                            CardScriptParts.RemoveMod<typeof CardMod.Content, 'backdoor'>('backdoor', true),\n\t                        ],\n\t                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = 2;\n", "        }\n\t    },\n\t    // Attack and raise CPU on kill\n\t    bd_extraction: class extends CardScript {\n\t        constructor(_card: GameEngine.ICardState) {\n\t            super(\n\t                [],\n\t                (gameData, card) =>\n\t                    CardScript.TargetFinders.Opponents(true)(gameData, card)\n\t                        .filter(target => !target.sec && target.mem === 1),\n", "                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n\t                            CardScriptParts.Attack(1, true, true),\n\t                        ],\n\t                    },\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Self,\n\t                        parts: [\n", "                            CardScriptParts.ChangeCpu(1),\n\t                        ],\n\t                    },\n\t                ],\n\t            );\n\t        }\n\t    },\n\t    // Raises CPU\n\t    bd_optimize: class extends CardScript {\n\t        constructor(card: GameEngine.ICardState) {\n", "            const cpuBonus = 1;\n\t            const duration = Math.round(card.cpu / 2);\n\t            super(\n\t                [cpuBonus, duration],\n\t                CardScript.TargetFinders.Allies(),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n\t                            CardScriptParts.AddMod(\n", "                                new _cardMods.optimized(cpuBonus, duration),\n\t                            ),\n\t                        ],\n\t                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = 4;\n\t        }\n\t    },\n\t    // Raises SEC\n", "    bd_patch: class extends CardScript {\n\t        constructor(card: GameEngine.ICardState) {\n\t            const secBonus = GameEngineUtils.scaleByCpuMem(11, card.cpu);\n\t            super(\n\t                [secBonus],\n\t                CardScript.TargetFinders.Any(),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n", "                            CardScriptParts.RaiseSec(secBonus),\n\t                        ],\n\t                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = 2;\n\t        }\n\t    },\n\t    // Steal SEC and remove Firewall (Backdoor finisher)\n\t    bd_proxy: class extends CardScript {\n", "        constructor(card: GameEngine.ICardState) {\n\t            const secDelta = GameEngineUtils.scaleByCpuMem(5, card.cpu);\n\t            super(\n\t                [secDelta],\n\t                CardScript.TargetFinders._ModFilter<typeof CardMod.Content, 'backdoor'>(['backdoor'],\n\t                    CardScript.TargetFinders.Opponents(true),\n\t                ),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n", "                        parts: [\n\t                            CardScriptParts.SecDmg(secDelta),\n\t                            CardScriptParts.RemoveMod<typeof CardMod.Content, 'firewall'>('firewall'),\n\t                            CardScriptParts.RemoveMod<typeof CardMod.Content, 'backdoor'>('backdoor', true),\n\t                        ],\n\t                    },\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Self,\n\t                        parts: [\n\t                            CardScriptParts.RaiseSec(secDelta),\n", "                        ],\n\t                    },\n\t                ],\n\t            );\n\t        }\n\t    },\n\t    // Steal SEC and causes offline (Backdoor finisher)\n\t    bd_reboot: class extends CardScript {\n\t        constructor(_card: GameEngine.ICardState) {\n\t            const secDelta = GameEngineUtils.scaleByCpuMem(5, _card.cpu);\n", "            const offlineDuration = 1;\n\t            super(\n\t                [secDelta, offlineDuration],\n\t                CardScript.TargetFinders._ModFilter<typeof CardMod.Content, 'backdoor'>(['backdoor'],\n\t                    CardScript.TargetFinders.Opponents(true),\n\t                ),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n", "                            CardScriptParts.SecDmg(secDelta),\n\t                            CardScriptParts.AddMod(\n\t                                new CardMod.Content.offline(offlineDuration),\n\t                            ),\n\t                            CardScriptParts.RemoveMod<typeof CardMod.Content, 'backdoor'>('backdoor', true),\n\t                        ],\n\t                    },\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Self,\n\t                        parts: [\n", "                            CardScriptParts.RaiseSec(secDelta),\n\t                        ],\n\t                    },\n\t                ],\n\t            );\n\t            this.cooldownMax = 2;\n\t        }\n\t    },\n\t    // Cause Exposed (Backdoor finisher)\n\t    bd_trace: class extends CardScript {\n", "        constructor(card: GameEngine.ICardState) {\n\t            const stacks = GameEngineUtils.scaleByCpuMem(7, card.cpu);\n\t            super(\n\t                [stacks],\n\t                CardScript.TargetFinders._ModFilter<typeof CardMod.Content, 'backdoor'>(['backdoor'],\n\t                    CardScript.TargetFinders.Opponents(true),\n\t                ),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n", "                        parts: [\n\t                            CardScriptParts.AddMod(\n\t                                new _cardMods.exposed(stacks),\n\t                            ),\n\t                            CardScriptParts.RemoveMod<typeof CardMod.Content, 'backdoor'>('backdoor', true),\n\t                        ],\n\t                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = 2;\n", "        }\n\t    },\n\t    // Attack and remove 1 MEM\n\t    bd_tunnel: class extends CardScript {\n\t        constructor(_card: GameEngine.ICardState) {\n\t            const memDmg = 1;\n\t            super(\n\t                [memDmg],\n\t                CardScript.TargetFinders._ModFilter<typeof CardMod.Content, 'backdoor'>(['backdoor'],\n\t                    CardScript.TargetFinders.Opponents(true),\n", "                ),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n\t                            CardScriptParts.MemDmg(memDmg),\n\t                            CardScriptParts.RemoveMod<typeof CardMod.Content, 'backdoor'>('backdoor', true),\n\t                        ],\n\t                    }\n\t                ],\n", "            );\n\t            this.cooldownMax = 3;\n\t        }\n\t    },\n\t    //\n\t    // Bruteforce scripts\n\t    //\n\t    // Swap CPU for MEM\n\t    bf_compression: class extends CardScript {\n\t        constructor(_card: GameEngine.ICardState) {\n", "            super(\n\t                [],\n\t                (gameData, card) =>\n\t                    CardScript.TargetFinders.Allies()(gameData, card).filter(x => x.cpu > 1),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n\t                            CardScriptParts.ChangeCpu(-1),\n\t                            CardScriptParts.RaiseMem(1),\n", "                        ],\n\t                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = 1;\n\t        }\n\t    },\n\t    // Cause Offline\n\t    bf_ddos: class extends CardScript {\n\t        constructor(_card: GameEngine.ICardState) {\n", "            const offlineDuration = 1;\n\t            super(\n\t                [offlineDuration],\n\t                CardScript.TargetFinders.Any(),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n\t                            CardScriptParts.AddMod(\n\t                                new CardMod.Content.offline(offlineDuration),\n", "                            ),\n\t                        ],\n\t                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = 3;\n\t        }\n\t    },\n\t    // Cause Lag\n\t    bf_dos: class extends CardScript {\n", "        constructor(_card: GameEngine.ICardState) {\n\t            const lagDuration = 1;\n\t            super(\n\t                [lagDuration],\n\t                CardScript.TargetFinders.Any(),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n\t                            CardScriptParts.AddMod(\n", "                                new CardMod.Content.lag(lagDuration),\n\t                            ),\n\t                        ],\n\t                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = 4;\n\t        }\n\t    },\n\t    // Gain feedback\n", "    bf_feedback: class extends CardScript {\n\t        constructor(card: GameEngine.ICardState) {\n\t            const damage = GameEngineUtils.scaleByCpuMem(10, card.cpu);\n\t            const cooldown = Math.max(0, 4 - Math.round(card.mem / 2));\n\t            super(\n\t                [damage, cooldown],\n\t                CardScript.TargetFinders.Self,\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Self,\n", "                        parts: [\n\t                            CardScriptParts.AddMod(\n\t                                new GameContent_v1.cardMods.feedback(damage),\n\t                            ),\n\t                        ],\n\t                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = cooldown;\n\t        }\n", "    },\n\t    // Triple SEC attack\n\t    bf_flood: class extends CardScript {\n\t        constructor(card: GameEngine.ICardState) {\n\t            const damage = GameEngineUtils.scaleByCpuMem(3, card.cpu);\n\t            const numAttacks = 3;\n\t            super(\n\t                [damage, numAttacks],\n\t                CardScript.TargetFinders.Opponents(),\n\t                [\n", "                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n\t                            ...Array.from(Array(numAttacks)).map(() => CardScriptParts.SecDmg(damage)),\n\t                        ],\n\t                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = 2;\n\t        }\n", "    },\n\t    // AOE attack\n\t    bf_multicast: class extends CardScript {\n\t        constructor(card: GameEngine.ICardState) {\n\t            const damage = GameEngineUtils.scaleByCpuMem(4, card.cpu);\n\t            super(\n\t                [damage],\n\t                CardScript.TargetFinders.Opponents(),\n\t                [\n\t                    {\n", "                        targetResolver: CardScript.TargetResolvers.TargetAndAdjacents,\n\t                        parts: [\n\t                            CardScriptParts.Attack(damage),\n\t                        ],\n\t                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = 1;\n\t        }\n\t    },\n", "    // Raise SEC\n\t    bf_obfuscate: class extends CardScript {\n\t        constructor(card: GameEngine.ICardState) {\n\t            const secBonus = GameEngineUtils.scaleByCpuMem(10, card.cpu);\n\t            super(\n\t                [secBonus],\n\t                CardScript.TargetFinders.Any(),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n", "                        parts: [\n\t                            CardScriptParts.RaiseSec(secBonus),\n\t                        ],\n\t                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = 3;\n\t        }\n\t    },\n\t    // Strong attack\n", "    bf_pod: class extends CardScript {\n\t        constructor(card: GameEngine.ICardState) {\n\t            const damage = GameEngineUtils.scaleByCpuMem(16, card.cpu);\n\t            super(\n\t                [damage],\n\t                CardScript.TargetFinders.Opponents(),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n", "                            CardScriptParts.Attack(damage),\n\t                        ],\n\t                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = 2;\n\t        }\n\t    },\n\t    // Raises CPU\n\t    bf_precompute: class extends CardScript {\n", "        constructor(card: GameEngine.ICardState) {\n\t            const cpuBonus = 1;\n\t            const duration = Math.round(card.cpu / 2);\n\t            super(\n\t                [cpuBonus, duration],\n\t                CardScript.TargetFinders.Allies(),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n", "                            CardScriptParts.AddMod(\n\t                                new _cardMods.optimized(cpuBonus, duration),\n\t                            ),\n\t                        ],\n\t                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = 4;\n\t        }\n\t    },\n", "    //\n\t    // Malware scripts\n\t    //\n\t    // Causes Lag\n\t    mw_bloatware: class extends CardScript {\n\t        constructor(_card: GameEngine.ICardState) {\n\t            super(\n\t                [1],\n\t                CardScript.TargetFinders.Opponents(),\n\t                [\n", "                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n\t                            CardScriptParts.AddMod(\n\t                                new CardMod.Content.lag(1),\n\t                            ),\n\t                        ],\n\t                    }\n\t                ],\n\t            );\n", "            this.cooldownMax = 3;\n\t        }\n\t    },\n\t    // Swap for another card's secondary script\n\t    mw_copypaste: class extends CardScript {\n\t        constructor(_card: GameEngine.ICardState) {\n\t            super(\n\t                [],\n\t                CardScript.TargetFinders.Allies(),\n\t                [\n", "                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n\t                            (engine, sourceCard, targetCard) => {\n\t                                CardScript.removeScript(engine, sourceCard, _cardScripts.mw_copypaste);\n\t                                if (!targetCard.scripts[1]) return;\n\t                                CardScript.addScript(engine, sourceCard, CardScript.fromScriptName(engine, sourceCard, targetCard.scripts[1][0]));\n\t                            },\n\t                        ],\n\t                    }\n", "                ],\n\t            );\n\t        }\n\t    },\n\t    // Grant Feedback\n\t    mw_honeypot: class extends CardScript {\n\t        constructor(card: GameEngine.ICardState) {\n\t            const damage = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n\t            const cooldown = Math.max(0, 4 - Math.round(card.mem / 2));\n\t            super(\n", "                [damage, cooldown],\n\t                CardScript.TargetFinders.Allies(),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n\t                            CardScriptParts.AddMod(\n\t                                new GameContent_v1.cardMods.feedback(damage),\n\t                            ),\n\t                        ],\n", "                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = cooldown;\n\t        }\n\t    },\n\t    // Steal SEC\n\t    mw_leech: class extends CardScript {\n\t        constructor(card: GameEngine.ICardState) {\n\t            const secDelta = GameEngineUtils.scaleByCpuMem(6, card.cpu);\n", "            super(\n\t                [secDelta],\n\t                CardScript.TargetFinders.Opponents(),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n\t                            CardScriptParts.SecDmg(secDelta),\n\t                        ],\n\t                    },\n", "                    {\n\t                        targetResolver: CardScript.TargetResolvers.Self,\n\t                        parts: [\n\t                            CardScriptParts.RaiseSec(secDelta),\n\t                        ],\n\t                    },\n\t                ],\n\t            );\n\t            this.cooldownMax = 1;\n\t        }\n", "    },\n\t    // Attack random target\n\t    mw_phishing: class extends CardScript {\n\t        constructor(card: GameEngine.ICardState) {\n\t            const minDamage = GameEngineUtils.scaleByCpuMem(9, card.cpu);\n\t            const maxDamage = GameEngineUtils.scaleByCpuMem(18, card.cpu);\n\t            super(\n\t                [minDamage, maxDamage],\n\t                CardScript.TargetFinders.Self,\n\t                [\n", "                    {\n\t                        targetResolver: CardScript.TargetResolvers.RandomOpponent,\n\t                        parts: [\n\t                            CardScriptParts.Attack(randInt(minDamage, maxDamage)),\n\t                        ],\n\t                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = 1;\n\t        }\n", "    },\n\t    // Redistribute CPU/MEM\n\t    mw_reimage: class extends CardScript {\n\t        constructor(_card: GameEngine.ICardState) {\n\t            super(\n\t                [],\n\t                CardScript.TargetFinders.Allies(),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n", "                        parts: [\n\t                            (engine, _sourceCard, targetCard) => {\n\t                                const totalStats = targetCard.cpu + targetCard.mem;\n\t                                const newCpu = randInt(1, totalStats - 1);\n\t                                const cpuDelta = newCpu - targetCard.cpu;\n\t                                GameEngineUtils.changeCpu(engine, targetCard, cpuDelta);\n\t                                const newMem = totalStats - newCpu;\n\t                                const memDelta = newMem - targetCard.mem;\n\t                                GameEngineUtils.changeMem(engine, targetCard, memDelta);\n\t                            },\n", "                        ],\n\t                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = 1;\n\t        }\n\t    },\n\t    // Raise SEC on random ally\n\t    mw_shareware: class extends CardScript {\n\t        constructor(card: GameEngine.ICardState) {\n", "            const minBonus = GameEngineUtils.scaleByCpuMem(10, card.cpu);\n\t            const maxBonus = GameEngineUtils.scaleByCpuMem(20, card.cpu);\n\t            super(\n\t                [minBonus, maxBonus],\n\t                CardScript.TargetFinders.Self,\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.RandomAlly,\n\t                        parts: [\n\t                            CardScriptParts.RaiseSec(randInt(minBonus, maxBonus)),\n", "                        ],\n\t                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = 3;\n\t        }\n\t    },\n\t    // Redirect intent\n\t    mw_spoof: class extends CardScript {\n\t        constructor(_card: GameEngine.ICardState) {\n", "            super(\n\t                [],\n\t                CardScript.TargetFinders.Opponents(),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n\t                            CardScriptParts.RedirectIntentRandom,\n\t                        ],\n\t                    }\n", "                ],\n\t            );\n\t        }\n\t    },\n\t    // Cause Exposed\n\t    mw_spyware: class extends CardScript {\n\t        constructor(card: GameEngine.ICardState) {\n\t            const stacks = GameEngineUtils.scaleByCpuMem(4, card.cpu);\n\t            super(\n\t                [stacks],\n", "                CardScript.TargetFinders.Opponents(),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n\t                            CardScriptParts.AddMod(\n\t                                new _cardMods.exposed(stacks),\n\t                            ),\n\t                        ],\n\t                    }\n", "                ],\n\t            );\n\t            this.cooldownMax = 1;\n\t        }\n\t    },\n\t    // Cause Virus\n\t    mw_virus: class extends CardScript {\n\t        constructor(card: GameEngine.ICardState) {\n\t            const dot = GameEngineUtils.scaleByCpuMem(4, card.cpu);\n\t            super(\n", "                [dot],\n\t                CardScript.TargetFinders.Opponents(),\n\t                [\n\t                    {\n\t                        targetResolver: CardScript.TargetResolvers.Target,\n\t                        parts: [\n\t                            CardScriptParts.AddMod(\n\t                                new _cardMods.virus(dot),\n\t                            ),\n\t                        ],\n", "                    }\n\t                ],\n\t            );\n\t            this.cooldownMax = 2;\n\t        }\n\t    },\n\t};\n\texport const GameContent_v1 = {\n\t    cardMods: _cardMods,\n\t    cardScripts: _cardScripts,\n", "    enemyCards: {},\n\t    initGame(_engine: GameEngine.IGameEngine) {\n\t        throw new Error('not a startable scenario');\n\t    },\n\t    addAdditionalScriptsFor(engine: GameEngine.IGameEngine, card: GameEngine.IPlayerCardState) {\n\t        if (card.card.tier < 2) return;\n\t        switch (card.card.faction) {\n\t            case 'backdoor':\n\t                card.scripts.push(CardScript.deserialize(engine, card, [Object.keys(_cardScripts).filter(x => x.startsWith('bd_')).random()]).serialize());\n\t                return;\n", "            case 'bruteforce':\n\t                card.scripts.push(CardScript.deserialize(engine, card, [Object.keys(_cardScripts).filter(x => x.startsWith('bf_')).random()]).serialize());\n\t                return;\n\t            case 'malware':\n\t                card.scripts.push(CardScript.deserialize(engine, card, [Object.keys(_cardScripts).filter(x => x.startsWith('mw_')).random()]).serialize());\n\t                return;\n\t        }\n\t    },\n\t};\n\t(GameContent_v1 as GameEngine.IRuleset);"]}
{"filename": "src/game/game-engine-utils.ts", "chunked_list": ["import { clamp, round } from '../utils';\n\timport { CardMod } from './card-mods';\n\timport { CardScript } from './card-scripts';\n\timport { GameEngine } from './game-engine';\n\texport namespace GameEngineUtils {\n\t    export function addEnemy(engine: GameEngine.IGameEngine, enemy: GameEngine.IEnemyCardState, spawnIndex: number, generateIntent: boolean) {\n\t        if (engine.gameData.enemies.length >= engine.gameData.maxEnemies) return;\n\t        spawnIndex = clamp(spawnIndex, 0, engine.gameData.enemies.length);\n\t        engine.gameData.enemies.splice(spawnIndex, 0, enemy);\n\t        engine.broadcast.push({\n", "            type: 'cardAdded',\n\t            enemy,\n\t            position: spawnIndex,\n\t        });\n\t        GameEngineUtils.triggerMods('onInitMod', { engine, sourceCard: enemy });\n\t        if (generateIntent) {\n\t            GameEngineUtils.generateIntent(engine, enemy);\n\t        }\n\t        return enemy;\n\t    }\n", "    export function changeCardIsUsed(engine: GameEngine.IGameEngine, card: GameEngine.IPlayerCardState, isUsed: boolean) {\n\t        card.isUsed = isUsed;\n\t        engine.broadcast.push({\n\t            type: 'cardIsUsedChanged',\n\t            cardId: card.id,\n\t            isUsed,\n\t        });\n\t    }\n\t    export function clearIntent(engine: GameEngine.IGameEngine, enemy: GameEngine.IEnemyCardState) {\n\t        const intent = enemy.intent;\n", "        if (!intent) {\n\t            return false;\n\t        }\n\t        enemy.intent = undefined;\n\t        engine.broadcast.push({\n\t            type: 'cardIntent',\n\t            cardId: enemy.id,\n\t        });\n\t        return true;\n\t    }\n", "    export function changeCpu(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, cpuDelta: number) {\n\t        card.cpu += cpuDelta;\n\t        engine.broadcast.push({\n\t            type: 'cpuChanged',\n\t            cardId: card.id,\n\t            newCpu: card.cpu,\n\t            cpuDelta,\n\t        });\n\t        GameEngineUtils.recalculateScripts(engine, card);\n\t    }\n", "    export function changeMem(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, memDelta: number) {\n\t        card.mem += memDelta;\n\t        engine.broadcast.push({\n\t            type: 'memChanged',\n\t            cardId: card.id,\n\t            newMem: card.mem,\n\t            memDelta,\n\t        });\n\t        GameEngineUtils.recalculateScripts(engine, card);\n\t    }\n", "    export function changeSec(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, secDelta: number, isPassive: boolean, contextCard?: GameEngine.ICardState) {\n\t        const clampedSecDelta = (card.sec < -secDelta) ? -card.sec : secDelta;\n\t        card.sec += clampedSecDelta;\n\t        engine.broadcast.push({\n\t            type: isPassive ? 'secChange' : (secDelta < 0 ? 'secDamage' : 'secBonus'),\n\t            cardId: card.id,\n\t            newSec: card.sec,\n\t            value: secDelta,\n\t        });\n\t        if (!isPassive && contextCard) {\n", "            const player = GameEngineUtils.findPlayerByCardIdMaybe(engine.gameData, contextCard.id);\n\t            if (player) {\n\t                (clampedSecDelta >= 0) ? (player.stats.secBonus += clampedSecDelta) : (player.stats.secDmg += -clampedSecDelta);\n\t            }\n\t        }\n\t    }\n\t    export function executeIntent(engine: GameEngine.IGameEngine, enemy: GameEngine.IEnemyCardState, dontClearIntent = false) {\n\t        const intent = enemy.intent;\n\t        if (!intent) {\n\t            return false;\n", "        }\n\t        enemy.intent = dontClearIntent ? enemy.intent : undefined;\n\t        let targetCard: GameEngine.ICardState | undefined;\n\t        if (intent.targetCardId >= 0) {\n\t            targetCard = findCardByIdMaybe(engine.gameData, intent.targetCardId);\n\t            if (!targetCard) {\n\t                // Intent target could've been removed between intent generation and execution\n\t                return false;\n\t            }\n\t        } else {\n", "            targetCard = enemy;\n\t        }\n\t        CardScript.execute(engine, enemy, intent.scriptData, targetCard);\n\t        return true;\n\t    }\n\t    export function findCardById(gameData: GameEngine.IGameData, cardId: number) {\n\t        const card = findCardByIdMaybe(gameData, cardId);\n\t        if (card) return card;\n\t        throw new Error('card not found');\n\t    }\n", "    export function findCardByIdMaybe(gameData: GameEngine.IGameData, cardId: number) {\n\t        const enemy = gameData.enemies.find(x => x.id === cardId);\n\t        if (enemy) return enemy;\n\t        const player = findPlayerByCardIdMaybe(gameData, cardId);\n\t        if (player) {\n\t            return player.cards.find(x => x.id === cardId);\n\t        }\n\t        return;\n\t    }\n\t    export function findPlayerCardById(gameData: GameEngine.IGameData, cardId: number) {\n", "        const player = findPlayerByCardIdMaybe(gameData, cardId);\n\t        if (!player) throw new Error('player not found');\n\t        return player.cards.find(x => x.id === cardId)!;\n\t    }\n\t    export function findPlayerByCardId(gameData: GameEngine.IGameData, cardId: number) {\n\t        const player = findPlayerByCardIdMaybe(gameData, cardId);\n\t        if (player) return player;\n\t        throw new Error('player not found');\n\t    }\n\t    export function findPlayerByCardIdMaybe(gameData: GameEngine.IGameData, cardId: number) {\n", "        return [...gameData.players.values()].find(x => x.cards.find(x => x.id === cardId));\n\t    }\n\t    export function generateIntent(engine: GameEngine.IGameEngine, enemy: GameEngine.IEnemyCardState) {\n\t        enemy.intent = undefined;\n\t        const isOffline = !!enemy.mods.find(x => x[0] === 'offline');\n\t        if (isOffline) return;\n\t        const scriptData = enemy.scripts.filter(x => !CardScript.isOnCooldown(x)).randomOrUndefined();\n\t        if (!scriptData) {\n\t            return;\n\t        }\n", "        const script = CardScript.deserialize(engine, enemy, scriptData);\n\t        const target = script.targetFinder(engine.gameData, enemy).randomOrUndefined();\n\t        if (!target) {\n\t            return;\n\t        }\n\t        enemy.intent = {\n\t            scriptData,\n\t            targetCardId: target.id,\n\t        };\n\t        engine.broadcast.push({\n", "            type: 'cardIntent',\n\t            cardId: enemy.id,\n\t            intent: enemy.intent,\n\t        });\n\t    }\n\t    export function getEnemyIds(gameData: GameEngine.IGameData) {\n\t        return gameData.enemies.map(x => x.id);\n\t    }\n\t    export function getPlayerIds(gameData: GameEngine.IGameData, ...excludePlayer: string[]) {\n\t        return [...gameData.players.keys()].filter(x => !excludePlayer.includes(x));\n", "    }\n\t    export function getPlayerCards(gameData: GameEngine.IGameData) {\n\t        return [...gameData.players.values()].map(x => x.cards).flat();\n\t    }\n\t    export function getPlayerCardIds(gameData: GameEngine.IGameData) {\n\t        return getPlayerCards(gameData).map(x => x.id);\n\t    }\n\t    export function isEnemyCard(gameData: GameEngine.IGameData, card: GameEngine.ICardState): card is GameEngine.IEnemyCardState {\n\t        return !!gameData.enemies.find(x => x.id === card.id);\n\t    }\n", "    export function isPlayerCard(gameData: GameEngine.IGameData, card: GameEngine.ICardState): card is GameEngine.IPlayerCardState {\n\t        return !isEnemyCard(gameData, card);\n\t    }\n\t    export function recalculateScripts(engine: GameEngine.IGameEngine, card: GameEngine.ICardState) {\n\t        if (card.isRemoved) return;\n\t        card.scripts = card.scripts.map(x => CardScript.deserialize(engine, card, x).serialize());\n\t        engine.broadcast.push(...card.scripts.map(x => ({\n\t            type: 'scriptChanged',\n\t            cardId: card.id,\n\t            scriptData: x,\n", "        })));\n\t        if (isEnemyCard(engine.gameData, card) && card.intent?.scriptData) {\n\t            card.intent.scriptData = CardScript.deserialize(engine, card, card.intent.scriptData).serialize();\n\t            engine.broadcast.push({\n\t                type: 'cardIntent',\n\t                cardId: card.id,\n\t                intent: card.intent,\n\t            });\n\t        }\n\t    }\n", "    export function revalidateIntents(engine: GameEngine.IGameEngine, regenerateIfInvalid: boolean) {\n\t        for (const enemy of engine.gameData.enemies) {\n\t            if (!enemy.intent || enemy.intent.targetCardId === -1) {\n\t                continue;\n\t            }\n\t            const script = CardScript.deserialize(engine, enemy, enemy.intent.scriptData);\n\t            const validTargets = script.targetFinder(engine.gameData, enemy);\n\t            if (validTargets.find(x => x.id === enemy.intent?.targetCardId)) {\n\t                continue;\n\t            }\n", "            enemy.intent = undefined;\n\t            if (regenerateIfInvalid) {\n\t                generateIntent(engine, enemy);\n\t            }\n\t        }\n\t    }\n\t    export function removeCard(engine: GameEngine.IGameEngine, card: GameEngine.ICardState, contextCard?: GameEngine.ICardState) {\n\t        if (card.isRemoved) {\n\t            return;\n\t        }\n", "        if (isEnemyCard(engine.gameData, card)) {\n\t            engine.gameData.enemies.removeFirst(card)\n\t            engine.broadcast.push({\n\t                type: 'cardRemoved',\n\t                cardId: card.id,\n\t            });\n\t            GameEngineUtils.triggerMods('onCardDestroyed', { engine, contextCard, sourceCard: card });\n\t            card.isRemoved = true;\n\t            for (const enemy of [...engine.gameData.enemies]) {\n\t                if (enemy.isRemoved) continue;\n", "                triggerMods('onEnemyDestroyed', { engine, sourceCard: card, contextCard });\n\t            }\n\t            if (contextCard) {\n\t                const player = findPlayerByCardIdMaybe(engine.gameData, contextCard.id);\n\t                player && player.stats.kills++;\n\t            }\n\t            GameEngineUtils.revalidateIntents(engine, true);\n\t        } else {\n\t            const player = GameEngineUtils.findPlayerByCardId(engine.gameData, card.id);\n\t            player.cards.removeFirst(card);\n", "            engine.broadcast.push({\n\t                type: 'cardRemoved',\n\t                cardId: card.id,\n\t            });\n\t            GameEngineUtils.triggerMods('onCardDestroyed', { engine, contextCard, sourceCard: card });\n\t            card.isRemoved = true;\n\t            GameEngineUtils.revalidateIntents(engine, false);\n\t        }\n\t    }\n\t    export function scaleByCpuMem(baseValue: number, cpuMem: number, cpuMemScaling: 'normal' | 'less' | 'more' | 'minimal' | 'high' = 'normal') {\n", "        let valuePerCpu = baseValue / 2;\n\t        switch (cpuMemScaling) {\n\t            case 'high': valuePerCpu * 1.5; break;\n\t            case 'more': valuePerCpu * 1.25; break;\n\t            case 'less': valuePerCpu * .75; break;\n\t            case 'minimal': valuePerCpu * .5; break;\n\t        }\n\t        return Math.round(baseValue + ((cpuMem - 1) * valuePerCpu));\n\t    }\n\t    export function scaleByDifficulty(value: number, difficulty: number, decimals = 0) {\n", "        return round(value * Math.pow(1.1, difficulty - 1), decimals);\n\t    }\n\t    export function spawnEnemy(engine: GameEngine.IGameEngine, enemyClass: string, spawnIndex: number, generateIntent: boolean) {\n\t        const enemyFactory = engine.ruleset.enemyCards?.[enemyClass];\n\t        if (!enemyFactory) throw new Error('EnemyClass not found for spawning: ' + enemyClass);\n\t        const enemy = enemyFactory(engine);\n\t        enemy.enemyClass = enemyClass;\n\t        return addEnemy(engine, enemy, spawnIndex, generateIntent);\n\t    }\n\t    export function triggerMods<T extends CardMod.ModEvent>(ev: T, ...args: Parameters<NonNullable<CardMod[typeof ev]>>): ReturnType<NonNullable<CardMod[typeof ev]>>[] {\n", "        const deps = args[0];\n\t        const card = deps.sourceCard;\n\t        return [...card.mods]\n\t            .map(modData => (!card.isRemoved && card.mods.find(x => CardMod.areEqual(x, modData))) ? CardMod.trigger(ev, modData, ...args) : undefined)\n\t            .filter(Boolean);\n\t    }\n\t}"]}
{"filename": "src/game/rulesets/reaper.ts", "chunked_list": ["import { randInt } from '../../utils';\n\timport { CardMod } from '../card-mods';\n\timport { CardScriptParts } from '../card-script-parts';\n\timport { CardScript } from '../card-scripts';\n\timport { GameContent_v1 } from '../game-content-v1';\n\timport { GameEngine } from '../game-engine';\n\timport { GameEngineUtils } from '../game-engine-utils';\n\texport const RulesetReaper = {\n\t    cardMods: {\n\t        reaper_feederCorrupted: class extends CardMod {\n", "        },\n\t        reaper_feederPower: class extends CardMod {\n\t            override onSecDamageIn(deps: CardMod.ICardModDeps, damage: number, attacker: GameEngine.ICardState) {\n\t                if (deps.sourceCard.sec - damage > 0) return;\n\t                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, -deps.sourceCard.sec, true);\n\t                CardMod.removeModByName(deps.engine, deps.sourceCard, this.constructor.name, attacker);\n\t                CardMod.addMod(deps.engine, deps.sourceCard, new RulesetReaper.cardMods.reaper_feederCorrupted(), attacker);\n\t                CardMod.addMod(deps.engine, deps.sourceCard, new CardMod.Content.impervious(), attacker);\n\t                const player = GameEngineUtils.findPlayerByCardIdMaybe(deps.engine.gameData, attacker.id);\n\t                player && player.stats.kills++;\n", "                return { secDmgBonus: -9999 };\n\t            }\n\t        },\n\t    },\n\t    cardScripts: {\n\t        reaper_bossEat: class extends CardScript {\n\t            constructor(_card: GameEngine.ICardState) {\n\t                super(\n\t                    [],\n\t                    (gameData, _card) => {\n", "                        return gameData.enemies.filter(x => x.enemyClass === RulesetReaper.enemyCards.reaper_feeder.name);\n\t                    },\n\t                    [\n\t                        {\n\t                            targetResolver: CardScript.TargetResolvers.Target,\n\t                            parts: [\n\t                                (engine, source, target) => {\n\t                                    GameEngineUtils.removeCard(engine, target, source);\n\t                                    if (target.mods.find(x => x[0] === RulesetReaper.cardMods.reaper_feederCorrupted.name)) {\n\t                                        GameEngineUtils.changeSec(engine, source, -50, false);\n", "                                        if (source.sec <= 0) {\n\t                                            GameEngineUtils.removeCard(engine, source);\n\t                                            return;\n\t                                        }\n\t                                    } else {\n\t                                        GameEngineUtils.changeSec(engine, source, Math.round(target.sec / 2), false);\n\t                                        GameEngineUtils.changeCpu(engine, source, 1);\n\t                                        for (const guardian of engine.gameData.enemies.filter(x => x.enemyClass === RulesetReaper.enemyCards.reaper_guardian.name)) {\n\t                                            CardMod.addMod(engine, guardian, new GameContent_v1.cardMods.optimized(1, -1));\n\t                                        }\n", "                                    }\n\t                                    const highDiff = engine.gameData.difficulty >= 7;\n\t                                    if (engine.gameData.enemies.length <= (highDiff ? 6 : 4)) {\n\t                                        while (engine.gameData.enemies.findIndex(x => x.id === source.id) < (highDiff ? 4 : 3)) {\n\t                                            CardScriptParts.SpawnEnemy('reaper_feeder', 'absLeft')(engine, source, target);\n\t                                        }\n\t                                        while (engine.gameData.enemies.length < (highDiff ? 9 : 7)) {\n\t                                            CardScriptParts.SpawnEnemy('reaper_feeder', 'absRight')(engine, source, target);\n\t                                        }\n\t                                    }\n", "                                },\n\t                            ],\n\t                        }\n\t                    ],\n\t                );\n\t            }\n\t        },\n\t    },\n\t    enemyCards: {\n\t        reaper_feeder: (engine: GameEngine.IGameEngine): GameEngine.IEnemyCardState => {\n", "            return {\n\t                id: engine.nextId(),\n\t                enemyClass: 'reaper_feeder',\n\t                cpu: 0,\n\t                mem: 0,\n\t                maxMem: 0,\n\t                sec: randInt(\n\t                    GameEngineUtils.scaleByDifficulty(50, engine.gameData.difficulty),\n\t                    GameEngineUtils.scaleByDifficulty(100, engine.gameData.difficulty),\n\t                ),\n", "                mods: [\n\t                    new RulesetReaper.cardMods.reaper_feederPower().serialize(),\n\t                ],\n\t                scripts: [],\n\t            };\n\t        },\n\t        reaper_guardian: (engine: GameEngine.IGameEngine) => {\n\t            const enemy: GameEngine.IEnemyCardState = {\n\t                id: engine.nextId(),\n\t                enemyClass: 'reaper_guardian',\n", "                cpu: 2,\n\t                mem: 0,\n\t                maxMem: 0,\n\t                sec: 1,\n\t                mods: [\n\t                    new CardMod.Content._standardAi().serialize(),\n\t                    new CardMod.Content.impervious().serialize(),\n\t                ],\n\t                scripts: [],\n\t            };\n", "            enemy.scripts.push(\n\t                new CardScript.Content._attack(enemy, engine.gameData.difficulty).serialize(),\n\t            );\n\t            return enemy;\n\t        },\n\t        reaper_lesser_guardian: (engine: GameEngine.IGameEngine) => {\n\t            const enemy: GameEngine.IEnemyCardState = {\n\t                id: engine.nextId(),\n\t                enemyClass: 'reaper_lesser_guardian',\n\t                cpu: 2,\n", "                mem: 0,\n\t                maxMem: 0,\n\t                sec: 1,\n\t                mods: [\n\t                    new CardMod.Content._standardAi().serialize(),\n\t                    new CardMod.Content.impervious().serialize(),\n\t                ],\n\t                scripts: [],\n\t            };\n\t            enemy.scripts.push(\n", "                new CardScript.Content._attack(enemy, engine.gameData.difficulty, 'weak', 1).serialize(),\n\t            );\n\t            return enemy;\n\t        },\n\t    },\n\t    initGame(engine: GameEngine.IGameEngine) {\n\t        const boss: GameEngine.IEnemyCardState = {\n\t            id: engine.nextId(),\n\t            enemyClass: 'reaper_boss',\n\t            cpu: 0,\n", "            mem: 0,\n\t            maxMem: 0,\n\t            sec: GameEngineUtils.scaleByDifficulty(250, engine.gameData.difficulty),\n\t            mods: [\n\t                new CardMod.Content._standardAi().serialize(),\n\t                new CardMod.Content._winOnDeath().serialize(),\n\t                new CardMod.Content.impervious().serialize(),\n\t            ],\n\t            scripts: [],\n\t        };\n", "        boss.scripts.push(\n\t            new RulesetReaper.cardScripts.reaper_bossEat(boss).serialize(),\n\t        );\n\t        GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_feeder(engine), 0, true);\n\t        engine.gameData.difficulty >= 7 && GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_lesser_guardian(engine), 0, true);\n\t        GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_guardian(engine), 0, true);\n\t        GameEngineUtils.addEnemy(engine, boss, 0, true);\n\t        GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_guardian(engine), 0, true);\n\t        engine.gameData.difficulty >= 7 && GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_lesser_guardian(engine), 0, true);\n\t        GameEngineUtils.addEnemy(engine, RulesetReaper.enemyCards.reaper_feeder(engine), 0, true);\n", "    },\n\t};\n"]}
{"filename": "src/game/rulesets/goliath.ts", "chunked_list": ["import { CardMod } from '../card-mods';\n\timport { CardScript } from '../card-scripts';\n\timport { GameContent_v1 } from '../game-content-v1';\n\timport { GameEngine } from '../game-engine';\n\timport { GameEngineUtils } from '../game-engine-utils';\n\tconst GOLIATH_ID = 9999;\n\texport const RulesetGoliath = {\n\t    cardMods: {\n\t        goliath_power_supply: class extends CardMod {\n\t            override onCardDestroyed(deps: CardMod.ICardModDeps) {\n", "                const goliath = GameEngineUtils.findCardById(deps.engine.gameData, GOLIATH_ID);\n\t                CardMod.addMod(deps.engine, goliath, new RulesetGoliath.cardMods.goliath_boss_power(), deps.sourceCard);\n\t            }\n\t        },\n\t        goliath_shield_supply: class extends CardMod {\n\t            override onCardDestroyed(deps: CardMod.ICardModDeps) {\n\t                const goliath = GameEngineUtils.findCardById(deps.engine.gameData, GOLIATH_ID);\n\t                CardMod.addMod(deps.engine, goliath, new RulesetGoliath.cardMods.goliath_boss_shield(), deps.sourceCard);\n\t            }\n\t        },\n", "        goliath_boss_ai: class extends CardMod {\n\t            override onTurnStart(deps: CardMod.ICardModDeps) {\n\t                GameEngineUtils.generateIntent(deps.engine, deps.sourceCard as GameEngine.IEnemyCardState);\n\t            }\n\t            override onTurnEnd(deps: CardMod.ICardModDeps) {\n\t                const boss = deps.sourceCard as GameEngine.IEnemyCardState;\n\t                const targetId = boss.intent?.targetCardId;\n\t                if (!targetId) return;\n\t                let numAttacks = 1;\n\t                const powerBuff = CardMod.findModOfType(boss, RulesetGoliath.cardMods.goliath_boss_power);\n", "                if (powerBuff) {\n\t                    const powerStacks = CardMod.getStackCount(powerBuff);\n\t                    numAttacks += powerStacks;\n\t                }\n\t                for (let i = 0; i < numAttacks - 1; i++) {\n\t                    GameEngineUtils.executeIntent(deps.engine, boss, true);\n\t                }\n\t                GameEngineUtils.executeIntent(deps.engine, boss);\n\t            }\n\t            override onMemDmgIn(deps: CardMod.ICardModDeps, memDmg: number) {\n", "                if (deps.sourceCard.mem - memDmg <= 0) return;\n\t                const boss = deps.sourceCard as GameEngine.IEnemyCardState;\n\t                let secBonus = 100;\n\t                const shieldBuff = CardMod.findModOfType(boss, RulesetGoliath.cardMods.goliath_boss_shield);\n\t                if (shieldBuff) {\n\t                    secBonus += CardMod.getStackCount(shieldBuff) * 100;\n\t                }\n\t                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, GameEngineUtils.scaleByDifficulty(secBonus, deps.engine.gameData.difficulty), false, deps.sourceCard);\n\t                for (const enemy of [...deps.engine.gameData.enemies]) {\n\t                    if (enemy === boss) continue;\n", "                    CardMod.addMod(deps.engine, enemy, new GameContent_v1.cardMods.optimized(1, -1), boss);\n\t                }\n\t            }\n\t        },\n\t        goliath_boss_power: class extends CardMod {\n\t            override stackingConfig = {\n\t                behavior: CardMod.StackingBehavior.stack as const,\n\t                stackCount: 1,\n\t            };\n\t        },\n", "        goliath_boss_shield: class extends CardMod {\n\t            override stackingConfig = {\n\t                behavior: CardMod.StackingBehavior.stack as const,\n\t                stackCount: 1,\n\t            };\n\t        },\n\t    },\n\t    enemyCards: {\n\t        goliath_power_node: (engine: GameEngine.IGameEngine) => {\n\t            const enemy: GameEngine.IEnemyCardState = {\n", "                id: engine.nextId(),\n\t                enemyClass: '',\n\t                cpu: 2,\n\t                mem: 2,\n\t                maxMem: 2,\n\t                sec: GameEngineUtils.scaleByDifficulty(35, engine.gameData.difficulty),\n\t                mods: [\n\t                    new CardMod.Content._standardAi().serialize(),\n\t                    new RulesetGoliath.cardMods.goliath_power_supply().serialize(),\n\t                ],\n", "                scripts: [],\n\t            };\n\t            enemy.scripts.push(\n\t                new CardScript.Content._attack(enemy, engine.gameData.difficulty, 'weak').serialize(),\n\t            );\n\t            return enemy;\n\t        },\n\t        goliath_shield_node: (engine: GameEngine.IGameEngine) => {\n\t            const enemy: GameEngine.IEnemyCardState = {\n\t                id: engine.nextId(),\n", "                enemyClass: '',\n\t                cpu: 1,\n\t                mem: 2,\n\t                maxMem: 2,\n\t                sec: GameEngineUtils.scaleByDifficulty(45, engine.gameData.difficulty),\n\t                mods: [\n\t                    new CardMod.Content._standardAi().serialize(),\n\t                    new RulesetGoliath.cardMods.goliath_shield_supply().serialize(),\n\t                ],\n\t                scripts: [],\n", "            };\n\t            enemy.scripts.push(\n\t                new CardScript.Content._defend(enemy, engine.gameData.difficulty, 'weak').serialize(),\n\t                new CardScript.Content._firewallSelf(enemy, 1, 2).serialize(),\n\t            );\n\t            return enemy;\n\t        },\n\t    },\n\t    initGame(engine: GameEngine.IGameEngine) {\n\t        const boss: GameEngine.IEnemyCardState = {\n", "            id: GOLIATH_ID,\n\t            enemyClass: 'goliath_boss',\n\t            cpu: 2,\n\t            mem: 4,\n\t            maxMem: 4,\n\t            sec: GameEngineUtils.scaleByDifficulty(100, engine.gameData.difficulty),\n\t            mods: [\n\t                new RulesetGoliath.cardMods.goliath_boss_ai().serialize(),\n\t                new CardMod.Content._winOnDeath().serialize(),\n\t            ],\n", "            scripts: [],\n\t        };\n\t        boss.scripts.push(\n\t            new CardScript.Content._attack(boss, engine.gameData.difficulty).serialize(),\n\t        );\n\t        engine.gameData.difficulty >= 7 && GameEngineUtils.spawnEnemy(engine, RulesetGoliath.enemyCards.goliath_shield_node.name, 0, true);\n\t        GameEngineUtils.spawnEnemy(engine, RulesetGoliath.enemyCards.goliath_power_node.name, 0, true);\n\t        GameEngineUtils.spawnEnemy(engine, RulesetGoliath.enemyCards.goliath_shield_node.name, 0, true);\n\t        GameEngineUtils.addEnemy(engine, boss, 0, true);\n\t        GameEngineUtils.spawnEnemy(engine, RulesetGoliath.enemyCards.goliath_shield_node.name, 0, true);\n", "        GameEngineUtils.spawnEnemy(engine, RulesetGoliath.enemyCards.goliath_power_node.name, 0, true);\n\t        engine.gameData.difficulty >= 7 && GameEngineUtils.spawnEnemy(engine, RulesetGoliath.enemyCards.goliath_shield_node.name, 0, true);\n\t    },\n\t};"]}
{"filename": "src/game/rulesets/intro.ts", "chunked_list": ["import { CardMod } from '../card-mods';\n\timport { CardScript } from '../card-scripts';\n\timport { GameEngine } from '../game-engine';\n\timport { GameEngineUtils } from '../game-engine-utils';\n\texport const RulesetMfrm = {\n\t    enemyCards: {\n\t        intro_sentinel: (engine: GameEngine.IGameEngine) => {\n\t            const enemy: GameEngine.IEnemyCardState = {\n\t                id: engine.nextId(),\n\t                enemyClass: 'intro_sentinel',\n", "                cpu: 2,\n\t                mem: 2,\n\t                maxMem: 2,\n\t                sec: GameEngineUtils.scaleByDifficulty(50, engine.gameData.difficulty),\n\t                mods: [new CardMod.Content._standardAi().serialize()],\n\t                scripts: [],\n\t            };\n\t            enemy.scripts.push(\n\t                new CardScript.Content._attack(enemy, engine.gameData.difficulty).serialize(),\n\t                new CardScript.Content._defend(enemy, engine.gameData.difficulty).serialize(),\n", "                new CardScript.Content._firewallSelf(enemy, 1, 2).serialize(),\n\t            );\n\t            return enemy;\n\t        },\n\t        intro_perimeter: (engine: GameEngine.IGameEngine) => {\n\t            const enemy: GameEngine.IEnemyCardState = {\n\t                id: engine.nextId(),\n\t                enemyClass: 'intro_perimeter',\n\t                cpu: 1,\n\t                mem: 1,\n", "                maxMem: 1,\n\t                sec: GameEngineUtils.scaleByDifficulty(30, engine.gameData.difficulty),\n\t                mods: [new CardMod.Content._standardAi().serialize()],\n\t                scripts: [],\n\t            };\n\t            enemy.scripts.push(\n\t                new CardScript.Content._attack(enemy, engine.gameData.difficulty, 'weak').serialize(),\n\t            );\n\t            return enemy;\n\t        },\n", "    },\n\t    initGame(engine: GameEngine.IGameEngine) {\n\t        const boss: GameEngine.IEnemyCardState = {\n\t            id: engine.nextId(),\n\t            enemyClass: 'intro_boss',\n\t            cpu: 3,\n\t            mem: 3,\n\t            maxMem: 3,\n\t            sec: GameEngineUtils.scaleByDifficulty(125, engine.gameData.difficulty),\n\t            mods: [],\n", "            scripts: [],\n\t        };\n\t        boss.mods.push(\n\t            new CardMod.Content._standardAi().serialize(),\n\t            new CardMod.Content._waveTrigger(['reaper', 'goliath', 'stasis', 'stasis'], 12).serialize(),\n\t            new CardMod.Content._yieldScript(new CardScript.Content._spawn(boss, RulesetMfrm.enemyCards.intro_perimeter.name, undefined, undefined, 2).serialize(), 2).serialize(),\n\t        );\n\t        boss.scripts.push(\n\t            new CardScript.Content._defend(boss, engine.gameData.difficulty).serialize(),\n\t        );\n", "        GameEngineUtils.addEnemy(engine, boss, 0, true);\n\t        GameEngineUtils.addEnemy(engine, RulesetMfrm.enemyCards.intro_sentinel(engine), 0, true);\n\t        GameEngineUtils.addEnemy(engine, RulesetMfrm.enemyCards.intro_perimeter(engine), 0, true);\n\t        engine.gameData.difficulty >= 7 && GameEngineUtils.addEnemy(engine, RulesetMfrm.enemyCards.intro_perimeter(engine), 0, true);\n\t        GameEngineUtils.addEnemy(engine, RulesetMfrm.enemyCards.intro_sentinel(engine), engine.gameData.enemies.length, true);\n\t        GameEngineUtils.addEnemy(engine, RulesetMfrm.enemyCards.intro_perimeter(engine), engine.gameData.enemies.length, true);\n\t        engine.gameData.difficulty >= 7 && GameEngineUtils.addEnemy(engine, RulesetMfrm.enemyCards.intro_perimeter(engine), engine.gameData.enemies.length, true);\n\t    }\n\t};"]}
{"filename": "src/game/rulesets/stasis.ts", "chunked_list": ["import { CardMod } from '../card-mods';\n\timport { CardScriptParts } from '../card-script-parts';\n\timport { CardScript } from '../card-scripts';\n\timport { GameEngine } from '../game-engine';\n\timport { GameEngineUtils } from '../game-engine-utils';\n\texport const RulesetStasis = {\n\t    cardMods: {\n\t        stasis_boss_ai: class extends CardMod.Content._standardAi {\n\t            override onMemDmgIn(deps: CardMod.ICardModDeps, memDmg: number) {\n\t                if (deps.sourceCard.mem - memDmg <= 0) return;\n", "                for (const playerCard of GameEngineUtils.getPlayerCards(deps.engine.gameData)) {\n\t                    CardMod.addMod(deps.engine, playerCard, new CardMod.Content.lag(1), deps.sourceCard);\n\t                }\n\t                GameEngineUtils.changeSec(deps.engine, deps.sourceCard, GameEngineUtils.scaleByDifficulty(125, deps.engine.gameData.difficulty), false, deps.contextCard);\n\t                if (![...deps.engine.gameData.enemies].find(x => x.enemyClass === RulesetStasis.enemyCards.stasis_disruptor.name)) {\n\t                    GameEngineUtils.spawnEnemy(deps.engine, RulesetStasis.enemyCards.stasis_disruptor.name, 0, true);\n\t                }\n\t            }\n\t        },\n\t    },\n", "    enemyCards: {\n\t        stasis_disruptor: (engine: GameEngine.IGameEngine) => {\n\t            const enemy: GameEngine.IEnemyCardState = {\n\t                id: engine.nextId(),\n\t                enemyClass: '',\n\t                cpu: 1,\n\t                mem: 3,\n\t                maxMem: 3,\n\t                sec: GameEngineUtils.scaleByDifficulty(35, engine.gameData.difficulty),\n\t                mods: [\n", "                    new CardMod.Content._standardAi().serialize(),\n\t                ],\n\t                scripts: [],\n\t            };\n\t            enemy.scripts.push(\n\t                new CardScript.Content._attack(enemy, engine.gameData.difficulty).serialize(),\n\t                new RulesetStasis.cardScripts.stasis_disrupt(enemy, engine.gameData.difficulty).serialize(),\n\t            );\n\t            return enemy;\n\t        },\n", "        stasis_shocker: (engine: GameEngine.IGameEngine) => {\n\t            const enemy: GameEngine.IEnemyCardState = {\n\t                id: engine.nextId(),\n\t                enemyClass: '',\n\t                cpu: 1,\n\t                mem: 2,\n\t                maxMem: 2,\n\t                sec: GameEngineUtils.scaleByDifficulty(45, engine.gameData.difficulty),\n\t                mods: [\n\t                    new CardMod.Content._standardAi().serialize(),\n", "                ],\n\t                scripts: [],\n\t            };\n\t            enemy.scripts.push(\n\t                new CardScript.Content._attack(enemy, engine.gameData.difficulty).serialize(),\n\t            );\n\t            return enemy;\n\t        },\n\t    },\n\t    cardScripts: {\n", "        stasis_disrupt: class extends CardScript {\n\t            constructor(card: GameEngine.ICardState, difficulty: number) {\n\t                const dmg = GameEngineUtils.scaleByDifficulty(GameEngineUtils.scaleByCpuMem(5, card.cpu), difficulty);\n\t                super(\n\t                    [difficulty, dmg],\n\t                    CardScript.TargetFinders.Opponents(),\n\t                    [\n\t                        {\n\t                            targetResolver: CardScript.TargetResolvers.Target,\n\t                            parts: [\n", "                                CardScriptParts.Attack(dmg),\n\t                                CardScriptParts.AddMod(new CardMod.Content.lag(2)),\n\t                            ],\n\t                        }\n\t                    ],\n\t                );\n\t            }\n\t        }\n\t    },\n\t    initGame(engine: GameEngine.IGameEngine) {\n", "        const boss: GameEngine.IEnemyCardState = {\n\t            id: engine.nextId(),\n\t            enemyClass: 'stasis_boss',\n\t            cpu: 3,\n\t            mem: 3,\n\t            maxMem: 3,\n\t            sec: GameEngineUtils.scaleByDifficulty(125, engine.gameData.difficulty),\n\t            mods: [\n\t                new RulesetStasis.cardMods.stasis_boss_ai().serialize(),\n\t                new CardMod.Content._winOnDeath().serialize(),\n", "            ],\n\t            scripts: [],\n\t        };\n\t        boss.scripts.push(\n\t            new CardScript.Content._attack(boss, engine.gameData.difficulty, 'strong').serialize(),\n\t            new RulesetStasis.cardScripts.stasis_disrupt(boss, engine.gameData.difficulty).serialize(),\n\t        );\n\t        engine.gameData.difficulty >= 7 && GameEngineUtils.spawnEnemy(engine, RulesetStasis.enemyCards.stasis_disruptor.name, 0, true);\n\t        GameEngineUtils.spawnEnemy(engine, RulesetStasis.enemyCards.stasis_shocker.name, 0, true);\n\t        GameEngineUtils.spawnEnemy(engine, RulesetStasis.enemyCards.stasis_disruptor.name, 0, true);\n", "        GameEngineUtils.addEnemy(engine, boss, 0, true);\n\t        GameEngineUtils.spawnEnemy(engine, RulesetStasis.enemyCards.stasis_disruptor.name, 0, true);\n\t        GameEngineUtils.spawnEnemy(engine, RulesetStasis.enemyCards.stasis_shocker.name, 0, true);\n\t        engine.gameData.difficulty >= 7 && GameEngineUtils.spawnEnemy(engine, RulesetStasis.enemyCards.stasis_disruptor.name, 0, true);\n\t    },\n\t};"]}
