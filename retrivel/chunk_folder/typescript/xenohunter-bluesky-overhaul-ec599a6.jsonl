{"filename": "src/interfaces.d.ts", "chunked_list": ["import {TSetting} from './types';\n\timport {APP_SETTINGS} from './shared/appSettings';\n\texport interface IPausable {\n\t  start(): void;\n\t  pause(): void;\n\t}\n\texport interface ISettingsSubscriber {\n\t  onSettingChange(name: APP_SETTINGS, value: TSetting): void;\n\t  get SETTINGS(): APP_SETTINGS[];\n\t}\n"]}
{"filename": "src/types.d.ts", "chunked_list": ["import '@types/chrome';\n\timport '@types/firefox';\n\timport {APP_SETTINGS} from './shared/appSettings';\n\texport type TSetting = boolean | number | string;\n\texport type TSettings = { [key in APP_SETTINGS]: TSetting };\n\texport type TEventKey = keyof HTMLElementEventMap;\n\texport type TEventListener<T> = (this: Element, ev: T) => any;\n\texport type TEventOptions = boolean | AddEventListenerOptions;\n"]}
{"filename": "src/popup/settingsKeeper.ts", "chunked_list": ["import {TSetting} from '../types';\n\timport {APP_SETTINGS, DEFAULT_SETTINGS} from '../shared/appSettings';\n\timport {setSettings} from '../shared/browserApi';\n\timport {SettingsProvider} from '../shared/settingsProvider';\n\tclass SettingsKeeper extends SettingsProvider {\n\t  async set(settingName: APP_SETTINGS, value: TSetting): Promise<void> {\n\t    if (!this.isInitialized) throw new Error('SettingsKeeper are not initialized');\n\t    if (!(settingName in DEFAULT_SETTINGS)) throw new Error(`Unknown setting: ${settingName}`);\n\t    const oldSettings = this.getAll();\n\t    try {\n", "      this.settings[settingName] = value;\n\t      await setSettings(this.settings);\n\t    } catch (e) {\n\t      this.settings = oldSettings;\n\t      throw e;\n\t    }\n\t  }\n\t}\n\tconst settingsKeeper = new SettingsKeeper();\n\texport const getSettingsKeeper = async (): Promise<SettingsKeeper> => {\n", "  await settingsKeeper.initialize();\n\t  return settingsKeeper;\n\t};\n"]}
{"filename": "src/shared/appSettings.ts", "chunked_list": ["import {TSettings} from '../types';\n\texport enum APP_SETTINGS {\n\t  BLUESKY_OVERHAUL_ENABLED = 'bluesky-overhaul-enabled',\n\t  HANDLE_VIM_KEYBINDINGS = 'vim-keybindings',\n\t  HIDE_FOLLOWERS_COUNT = 'hide-followers-count',\n\t  HIDE_FOLLOWING_COUNT = 'hide-following-count',\n\t  HIDE_POSTS_COUNT = 'hide-posts-count',\n\t  SHOW_POST_DATETIME = 'show-post-datetime',\n\t  BSKY_IDENTIFIER = 'bsky-identifier',\n\t  BSKY_PASSWORD = 'bsky-password'\n", "}\n\texport const DEFAULT_SETTINGS: TSettings = {\n\t  [APP_SETTINGS.BLUESKY_OVERHAUL_ENABLED]: true,\n\t  [APP_SETTINGS.HANDLE_VIM_KEYBINDINGS]: false,\n\t  [APP_SETTINGS.HIDE_FOLLOWERS_COUNT]: false,\n\t  [APP_SETTINGS.HIDE_FOLLOWING_COUNT]: false,\n\t  [APP_SETTINGS.HIDE_POSTS_COUNT]: false,\n\t  [APP_SETTINGS.SHOW_POST_DATETIME]: true,\n\t  [APP_SETTINGS.BSKY_IDENTIFIER]: '',\n\t  [APP_SETTINGS.BSKY_PASSWORD]: ''\n", "};\n"]}
{"filename": "src/shared/browserApi.ts", "chunked_list": ["import {TSettings} from '../types';\n\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t// @ts-ignore\n\tconst browserAPI = window.browser || chrome;\n\tconst SETTINGS_KEY = 'settings';\n\texport const clearStorage = async (): Promise<void> => {\n\t  await browserAPI.storage.local.clear();\n\t};\n\texport const getSettings = async (): Promise<TSettings> => {\n\t  const storage = await browserAPI.storage.local.get();\n", "  return storage[SETTINGS_KEY] || {};\n\t};\n\texport const setSettings = async (newSettings: TSettings): Promise<void> => {\n\t  await browserAPI.storage.local.set({[SETTINGS_KEY]: newSettings});\n\t};\n\texport const subscribeToSettings = (listener: (newSettings: TSettings) => void): void => {\n\t  browserAPI.storage.onChanged.addListener((changes: any, namespace: any) => {\n\t    if (namespace === 'local' && changes[SETTINGS_KEY]) {\n\t      listener(changes[SETTINGS_KEY].newValue);\n\t    }\n", "  });\n\t};\n"]}
{"filename": "src/shared/settingsProvider.ts", "chunked_list": ["import {TSetting, TSettings} from '../types';\n\timport {APP_SETTINGS, DEFAULT_SETTINGS} from './appSettings';\n\timport {getSettings} from './browserApi';\n\texport class SettingsProvider {\n\t  protected settings: TSettings = {...DEFAULT_SETTINGS};\n\t  protected isInitialized = false;\n\t  async initialize(): Promise<void> {\n\t    if (this.isInitialized) return;\n\t    const savedSettings = await getSettings();\n\t    this.settings = {...DEFAULT_SETTINGS, ...savedSettings};\n", "    this.isInitialized = true;\n\t  }\n\t  getAll(): TSettings {\n\t    if (!this.isInitialized) throw new Error('SettingsKeeper are not initialized');\n\t    return {...this.settings};\n\t  }\n\t  get(settingName: APP_SETTINGS): TSetting {\n\t    if (!this.isInitialized) throw new Error('SettingsKeeper are not initialized');\n\t    if (!(settingName in this.settings)) throw new Error(`Setting ${settingName} is not present`);\n\t    return this.settings[settingName];\n", "  }\n\t}\n"]}
{"filename": "src/shared/misc.ts", "chunked_list": ["// eslint-disable-next-line @typescript-eslint/no-empty-function\n\texport const noop = (): void => {};\n\texport const preventDefault = (e: any): void => e.preventDefault();\n\texport const delay = (ms: number): Promise<void> => {\n\t  return new Promise((resolve) => setTimeout(resolve, ms));\n\t};\n"]}
{"filename": "src/content/main.ts", "chunked_list": ["import '@webcomponents/custom-elements';\n\timport {APP_SETTINGS} from '../shared/appSettings';\n\timport {getSettingsManager} from './browser/settingsManager';\n\timport {ultimatelyFind} from './dom/utils';\n\timport {ROOT_CONTAINER, FEED_CONTAINER, MODAL_CONTAINER, COMPOSE_MODAL} from './dom/selectors';\n\timport {CountersConcealer} from './watchers/countersConcealer';\n\timport {KeydownWatcher} from './watchers/keydown';\n\timport {PostDatetimeWatcher} from './watchers/postDatetime';\n\timport {YoutubeWatcher} from './watchers/youtube';\n\timport {PostModalPipeline} from './pipelines/postModal';\n", "import {EmojiPipeline} from './pipelines/emoji';\n\timport {QuotePostPipeline} from './pipelines/quotePost';\n\timport {log} from './utils/logger';\n\timport {PipelineManager} from './utils/pipelineManager';\n\tconst REPO_LINK = 'https://github.com/xenohunter/bluesky-overhaul';\n\tconst EXTENSION_DISABLED_CODE = 'EXTENSION_DISABLED';\n\tconst run = async (): Promise<void> => {\n\t  const settingsManager = await getSettingsManager();\n\t  if (settingsManager.get(APP_SETTINGS.BLUESKY_OVERHAUL_ENABLED) === false) {\n\t    return Promise.reject(EXTENSION_DISABLED_CODE);\n", "  }\n\t  return ultimatelyFind(document.body, ROOT_CONTAINER).then((rootContainer) => Promise.all([\n\t    Promise.resolve(rootContainer),\n\t    ultimatelyFind(rootContainer, FEED_CONTAINER),\n\t    ultimatelyFind(rootContainer, MODAL_CONTAINER)\n\t  ]).then(([rootContainer, feedContainer, modalContainer]) => {\n\t    const countersConcealer = new CountersConcealer(document.body);\n\t    settingsManager.subscribe(countersConcealer);\n\t    countersConcealer.watch();\n\t    const keydownWatcher = new KeydownWatcher(rootContainer, feedContainer);\n", "    settingsManager.subscribe(keydownWatcher);\n\t    keydownWatcher.watch();\n\t    const postDatetimeWatcher = new PostDatetimeWatcher(feedContainer);\n\t    settingsManager.subscribe(postDatetimeWatcher);\n\t    postDatetimeWatcher.watch();\n\t    const youtubeWatcher = new YoutubeWatcher(feedContainer);\n\t    youtubeWatcher.watch();\n\t    const postModalPipeline = new PostModalPipeline(() => keydownWatcher.pause(), () => keydownWatcher.start());\n\t    const emojiPipeline = new EmojiPipeline(() => postModalPipeline.pause(), () => postModalPipeline.start());\n\t    const quotePostPipeline = new QuotePostPipeline();\n", "    const pipelineManager = new PipelineManager({\n\t      compose: [postModalPipeline, emojiPipeline, quotePostPipeline]\n\t    });\n\t    const observer = new MutationObserver((mutations) => {\n\t      mutations.forEach((mutation) => {\n\t        if (mutation.target === modalContainer) {\n\t          const composePostModal = modalContainer.querySelector(COMPOSE_MODAL.selector) as HTMLElement | null;\n\t          if (composePostModal !== null) {\n\t            pipelineManager.terminateExcept('compose');\n\t            pipelineManager.deploy('compose', composePostModal);\n", "          } else {\n\t            pipelineManager.terminateAll();\n\t          }\n\t        }\n\t      });\n\t    });\n\t    observer.observe(modalContainer, {childList: true, subtree: true});\n\t  }));\n\t};\n\trun().then(() => {\n", "  log('Launched');\n\t}).catch(() => {\n\t  setTimeout(() => {\n\t    run().then(() => {\n\t      log('Launched after the second attempt (1000ms delay)');\n\t    }).catch((e) => {\n\t      if (e === EXTENSION_DISABLED_CODE) return;\n\t      console.error(`Failed to launch Bluesky Overhaul. Please, copy the error and report this issue: ${REPO_LINK}`);\n\t      console.error(e);\n\t    });\n", "  }, 1000);\n\t});\n"]}
{"filename": "src/content/pipelines/pipeline.ts", "chunked_list": ["export abstract class Pipeline {\n\t  abstract deploy(modal: HTMLElement): void;\n\t  abstract terminate(): void;\n\t}\n"]}
{"filename": "src/content/pipelines/postModal.ts", "chunked_list": ["import {IPausable} from '../../interfaces';\n\timport {log} from '../utils/logger';\n\timport {Pipeline} from './pipeline';\n\timport {EventKeeper} from '../utils/eventKeeper';\n\timport {COMPOSE_CANCEL_BUTTON, COMPOSE_CONTENT_EDITABLE} from '../dom/selectors';\n\timport {ultimatelyFind} from '../dom/utils';\n\texport class PostModalPipeline extends Pipeline implements IPausable {\n\t  #modal: HTMLElement | null;\n\t  #exitButton: HTMLElement | null;\n\t  #contentEditable: HTMLElement | null;\n", "  readonly #eventKeeper: EventKeeper;\n\t  readonly #pauseOuterServices: () => void;\n\t  readonly #resumeOuterServices: () => void;\n\t  #paused = false;\n\t  constructor(pauseCallback: () => void, resumeCallback: () => void) {\n\t    super();\n\t    this.#modal = null;\n\t    this.#exitButton = null;\n\t    this.#contentEditable = null;\n\t    this.#eventKeeper = new EventKeeper();\n", "    this.#pauseOuterServices = pauseCallback;\n\t    this.#resumeOuterServices = resumeCallback;\n\t  }\n\t  deploy(modal: HTMLElement): void {\n\t    if (this.#modal !== null) {\n\t      log('PostModalPipeline is already deployed');\n\t      return;\n\t    }\n\t    this.#pauseOuterServices();\n\t    this.#modal = modal;\n", "    Promise.all([\n\t      ultimatelyFind(modal, COMPOSE_CANCEL_BUTTON),\n\t      ultimatelyFind(modal, COMPOSE_CONTENT_EDITABLE)\n\t    ]).then(([exitButton, contentEditable]) => {\n\t      this.#exitButton = exitButton;\n\t      this.#contentEditable = contentEditable;\n\t      this.#eventKeeper.add(document, 'click', this.#onClick.bind(this));\n\t      this.#eventKeeper.add(contentEditable, 'mousedown', this.#onPresumedSelect.bind(this));\n\t      this.#eventKeeper.add(exitButton, 'click', () => this.#eventKeeper.cancelAll());\n\t    });\n", "  }\n\t  terminate(): void {\n\t    if (this.#modal === null) {\n\t      log('PostModalPipeline is not deployed');\n\t      return;\n\t    }\n\t    this.start();\n\t    this.#eventKeeper.cancelAll();\n\t    this.#modal = this.#exitButton = this.#contentEditable = null;\n\t    this.#resumeOuterServices();\n", "  }\n\t  start(): void {\n\t    this.#paused = false;\n\t  }\n\t  pause(): void {\n\t    this.#paused = true;\n\t  }\n\t  #onClick(event: MouseEvent): void {\n\t    if (this.#paused) return;\n\t    const target = event.target as HTMLElement;\n", "    if (target?.tagName.toLowerCase() === 'button') return;\n\t    if (!this.#modal?.contains(event.target as Node) && event.target !== this.#exitButton) {\n\t      this.#eventKeeper.cancelAll();\n\t      this.#exitButton?.click();\n\t    }\n\t  }\n\t  #onPresumedSelect(): void {\n\t    if (this.#paused) return;\n\t    this.pause();\n\t    document.addEventListener('mouseup', () => setTimeout(this.start.bind(this), 0), {once: true});\n", "  }\n\t}\n"]}
{"filename": "src/content/pipelines/emoji.ts", "chunked_list": ["import {Picker} from 'emoji-mart';\n\timport {emojiData} from '../hacks/emojiDataWrapper';\n\timport {ultimatelyFind} from '../dom/utils';\n\timport {COMPOSE_PHOTO_BUTTON, COMPOSE_CONTENT_EDITABLE} from '../dom/selectors';\n\timport {Cursor} from '../utils/cursor';\n\timport {EventKeeper} from '../utils/eventKeeper';\n\timport {log} from '../utils/logger';\n\timport {typeText} from '../utils/text';\n\timport {Pipeline} from './pipeline';\n\timport {noop} from '../../shared/misc';\n", "const EMOJI_CHARACTER_LENGTH = 2;\n\tconst createEmojiButton = (rightmostButton: HTMLElement): HTMLElement => {\n\t  const emojiButton = rightmostButton.cloneNode(false) as HTMLElement;\n\t  emojiButton.innerHTML = 'ðŸ˜€';\n\t  return emojiButton;\n\t};\n\tconst createEmojiPopup = (modal: HTMLElement, emojiButton: HTMLElement): HTMLElement => {\n\t  const emojiPopup = document.createElement('div');\n\t  emojiPopup.style.position = 'absolute';\n\t  emojiPopup.style.display = 'none';\n", "  const modalCoords = modal.getBoundingClientRect();\n\t  const emojiButtonCoords = emojiButton.getBoundingClientRect();\n\t  emojiPopup.style.left = emojiButtonCoords.x - modalCoords.x + 'px';\n\t  emojiPopup.style.top = emojiButtonCoords.y - modalCoords.y + emojiButtonCoords.height + 'px';\n\t  return emojiPopup;\n\t};\n\texport class EmojiPipeline extends Pipeline {\n\t  #modal: HTMLElement | null;\n\t  #picker: Picker | null;\n\t  #cursor: Cursor | null;\n", "  readonly #eventKeeper: EventKeeper;\n\t  #elems: { [key: string]: HTMLElement };\n\t  #expanded: boolean;\n\t  readonly #pauseOuterServices: () => void;\n\t  readonly #resumeOuterServices: () => void;\n\t  constructor(pauseCallback: () => void, resumeCallback: () => void) {\n\t    super();\n\t    this.#modal = null;\n\t    this.#picker = null;\n\t    this.#cursor = null;\n", "    this.#eventKeeper = new EventKeeper();\n\t    this.#elems = {};\n\t    this.#expanded = false;\n\t    this.#pauseOuterServices = pauseCallback;\n\t    this.#resumeOuterServices = resumeCallback;\n\t  }\n\t  deploy(modal: HTMLElement): void {\n\t    if (this.#modal !== null) {\n\t      log('EmojiPipeline already deployed');\n\t      return;\n", "    }\n\t    this.#modal = modal;\n\t    this.#picker = this.#createPicker();\n\t    Promise.all([\n\t      ultimatelyFind(modal, [COMPOSE_PHOTO_BUTTON]),\n\t      ultimatelyFind(modal, COMPOSE_CONTENT_EDITABLE)\n\t    ]).then(([photoButton, contentEditable]) => {\n\t      this.#elems.photoButton = photoButton;\n\t      this.#elems.contentEditable = contentEditable;\n\t      this.#elems.emojiButton = createEmojiButton(this.#elems.photoButton);\n", "      this.#elems.photoButton.insertAdjacentElement('afterend', this.#elems.emojiButton);\n\t      this.#elems.emojiPopup = createEmojiPopup(modal, this.#elems.emojiButton);\n\t      this.#elems.emojiPopup.appendChild(this.#picker as unknown as HTMLElement);\n\t      modal.appendChild(this.#elems.emojiPopup);\n\t      this.#eventKeeper.add(this.#elems.emojiButton, 'click', this.#onButtonClick.bind(this));\n\t      this.#cursor = new Cursor(this.#elems.contentEditable);\n\t      const outerCallback = (): void => this.#cursor?.save();\n\t      this.#eventKeeper.add(this.#elems.contentEditable, 'keyup', outerCallback);\n\t      this.#eventKeeper.add(this.#elems.contentEditable, 'mouseup', outerCallback);\n\t    });\n", "  }\n\t  terminate(): void {\n\t    if (this.#modal === null) {\n\t      log('EmojiPipeline already terminated');\n\t      return;\n\t    }\n\t    this.#removeElements();\n\t    this.#eventKeeper.cancelAll();\n\t    this.#modal = this.#picker = this.#cursor = null;\n\t  }\n", "  #createPicker(): Picker {\n\t    return new Picker({\n\t      emojiData,\n\t      emojiSize: 22,\n\t      onEmojiSelect: (emoji: { [key: string]: any }): void => {\n\t        this.#cursor?.restore();\n\t        typeText(emoji.native);\n\t        this.#cursor?.move(EMOJI_CHARACTER_LENGTH);\n\t        this.#focusOnPickerSearch();\n\t      }\n", "    });\n\t  }\n\t  #focusOnPickerSearch(): void {\n\t    if (!this.#picker) return;\n\t    this.#getPickerSearch()?.focus();\n\t  }\n\t  #clearPickerSearch(): void {\n\t    if (!this.#picker) return;\n\t    const pickerSearch = this.#getPickerSearch();\n\t    if (pickerSearch) pickerSearch.value = '';\n", "  }\n\t  #getPickerSearch(): HTMLInputElement | null {\n\t    const picker = this.#picker as unknown as HTMLElement;\n\t    return picker.shadowRoot?.querySelector('input[type=\"search\"]') as HTMLInputElement;\n\t  }\n\t  #onButtonClick(): void {\n\t    if (this.#expanded) return;\n\t    this.#elems.emojiPopup.style.display = 'block';\n\t    this.#expanded = true;\n\t    this.#pauseOuterServices();\n", "    this.#focusOnPickerSearch();\n\t    const clickOutside = (event: Event): void => {\n\t      const target = event.target as HTMLElement;\n\t      if (this.#elems.emojiPopup && !this.#elems.emojiPopup.contains(target) && target !== this.#elems.emojiButton) {\n\t        this.#elems.emojiPopup.style.display = 'none';\n\t        this.#clearPickerSearch();\n\t        this.#expanded = false;\n\t        this.#modal?.removeEventListener('click', clickOutside);\n\t        document.removeEventListener('click', clickOutside);\n\t        this.#resumeOuterServices();\n", "        this.#elems.contentEditable.focus();\n\t      }\n\t    };\n\t    this.#modal?.addEventListener('click', clickOutside);\n\t    document.addEventListener('click', clickOutside);\n\t  }\n\t  #removeElements(): void {\n\t    for (const element of Object.values(this.#elems)) {\n\t      try {\n\t        if (element.parentElement) {\n", "          element.parentElement.removeChild(element);\n\t        } else {\n\t          element.remove();\n\t        }\n\t      } catch (e) {\n\t        noop();\n\t      }\n\t    }\n\t    this.#elems = {};\n\t  }\n", "}\n"]}
{"filename": "src/content/pipelines/quotePost.ts", "chunked_list": ["import {COMPOSE_CONTENT_EDITABLE, COMPOSE_LINK_CARD_BUTTON} from '../dom/selectors';\n\timport {log} from '../utils/logger';\n\timport {typeText, backspace} from '../utils/text';\n\timport {Pipeline} from './pipeline';\n\timport {ultimatelyFind} from '../dom/utils';\n\timport {EventKeeper} from '../utils/eventKeeper';\n\tconst STAGING_URL_REGEX = /.*(https:\\/\\/staging\\.bsky\\.app\\/profile\\/.*\\/post\\/.*\\/?)$/;\n\tconst URL_REGEX = /.*(https:\\/\\/bsky\\.app\\/profile\\/.*\\/post\\/.*\\/?)$/;\n\texport class QuotePostPipeline extends Pipeline {\n\t  #modal: HTMLElement | null;\n", "  #contentEditable: HTMLElement | null;\n\t  readonly #eventKeeper: EventKeeper;\n\t  constructor() {\n\t    super();\n\t    this.#modal = null;\n\t    this.#contentEditable = null;\n\t    this.#eventKeeper = new EventKeeper();\n\t  }\n\t  deploy(modal: HTMLElement): void {\n\t    if (this.#modal !== null) {\n", "      log('QuotePostPipeline is already deployed');\n\t      return;\n\t    }\n\t    this.#modal = modal;\n\t    ultimatelyFind(modal, COMPOSE_CONTENT_EDITABLE).then((contentEditable) => {\n\t      this.#contentEditable = contentEditable;\n\t      this.#eventKeeper.add(contentEditable, 'paste', this.onPaste.bind(this), {capture: true});\n\t    });\n\t  }\n\t  terminate(): void {\n", "    if (this.#modal === null) {\n\t      log('QuotePostPipeline is not deployed');\n\t      return;\n\t    }\n\t    this.#eventKeeper.cancelAll();\n\t    this.#modal = this.#contentEditable = null;\n\t  }\n\t  onPaste(event: ClipboardEvent): void {\n\t    if (!event.clipboardData || !this.#contentEditable) return;\n\t    if (event.clipboardData.types.indexOf('text/plain') === -1) return;\n", "    event.preventDefault();\n\t    const contentEditable = this.#contentEditable;\n\t    let data = event.clipboardData.getData('text/plain');\n\t    if (data.match(STAGING_URL_REGEX) !== null) {\n\t      data = data.replace('https://staging.bsky.app/', 'https://bsky.app/');\n\t    }\n\t    contentEditable.focus();\n\t    typeText(data);\n\t    typeText(' '); // Add a space after the link for it to resolve as one\n\t    // Wait for the text to be inserted into the contentEditable\n", "    setTimeout(() => {\n\t      const lastChar = contentEditable.textContent?.slice(-1) ?? '';\n\t      if (lastChar === ' ') backspace();\n\t      if (data.match(URL_REGEX) !== null) {\n\t        this.#modal && ultimatelyFind(this.#modal, COMPOSE_LINK_CARD_BUTTON).then((linkCardButton) => {\n\t          linkCardButton.click();\n\t        });\n\t      }\n\t    }, 50);\n\t  }\n", "}\n"]}
{"filename": "src/content/utils/pipelineManager.ts", "chunked_list": ["import {Pipeline} from '../pipelines/pipeline';\n\timport {log} from './logger';\n\texport class PipelineManager {\n\t  pipelines: { [key: string]: Pipeline[] };\n\t  constructor(pipelines: { [key: string]: Pipeline[] }) {\n\t    this.pipelines = pipelines;\n\t  }\n\t  deploy(type: string, target: HTMLElement): void {\n\t    this.pipelines[type].forEach((pipeline) => {\n\t      try {\n", "        pipeline.deploy(target);\n\t      } catch (e) {\n\t        log(`Pipeline ${pipeline.constructor.name} was deployed with errors`, e);\n\t      }\n\t    });\n\t  }\n\t  terminate(type: string): void {\n\t    this.pipelines[type].forEach((pipeline) => {\n\t      try {\n\t        pipeline.terminate();\n", "      } catch (e) {\n\t        log(`Pipeline ${pipeline.constructor.name} was terminated with errors`, e);\n\t      }\n\t    });\n\t  }\n\t  terminateAll(): void {\n\t    Object.keys(this.pipelines).forEach((t) => this.terminate(t));\n\t  }\n\t  terminateExcept(type: string): void {\n\t    Object.keys(this.pipelines).filter((t) => t !== type).forEach((t) => this.terminate(t));\n", "  }\n\t}\n"]}
{"filename": "src/content/utils/eventKeeper.ts", "chunked_list": ["import type {TEventKey, TEventListener, TEventOptions} from '../../types';\n\timport {noop} from '../../shared/misc';\n\ttype TElement = Element | Document | Window;\n\ttype TEventListenerUnion = TEventListener<Event> | TEventListener<KeyboardEvent> | TEventListener<ClipboardEvent> | TEventListener<MouseEvent>;\n\ttype TEventRequisites = {\n\t  element: TElement;\n\t  event: TEventKey;\n\t  listener: TEventListenerUnion;\n\t  options?: TEventOptions;\n\t};\n", "export class EventKeeper {\n\t  #events: TEventRequisites[] = [];\n\t  add(element: TElement, eventKey: TEventKey, listener: TEventListenerUnion, options?: TEventOptions): void {\n\t    try {\n\t      element.addEventListener(eventKey, listener as TEventListener<Event>, options);\n\t      this.#events.push({element, event: eventKey, listener, options});\n\t    } catch (e) {\n\t      noop();\n\t    }\n\t  }\n", "  cancelAll(): void {\n\t    for (const {element, event, listener, options} of this.#events) {\n\t      try {\n\t        element.removeEventListener(event, listener as TEventListener<Event>, options);\n\t      } catch (e) {\n\t        noop();\n\t      }\n\t    }\n\t    this.#events = [];\n\t  }\n", "}\n"]}
{"filename": "src/content/utils/text.ts", "chunked_list": ["export const typeText = (text: string): boolean => document.execCommand('insertText', false, text);\n\texport const backspace = (): boolean => document.execCommand('delete', false, undefined);\n"]}
{"filename": "src/content/utils/logger.ts", "chunked_list": ["export const log = (message: string, ...args: any): void => {\n\t  console.debug(`Bluesky Overhaul: ${message}`, ...args);\n\t};\n"]}
{"filename": "src/content/utils/callThrottler.ts", "chunked_list": ["export class CallThrottler {\n\t  readonly #delay: number;\n\t  #locked: boolean;\n\t  constructor (delay: number) {\n\t    this.#delay = delay;\n\t    this.#locked = false;\n\t  }\n\t  call (fn: (...args: any) => any, ...args: any): void {\n\t    if (this.#locked) return;\n\t    this.#locked = true;\n", "    fn(...args);\n\t    setTimeout(() => {\n\t      this.#locked = false;\n\t    }, this.#delay);\n\t  }\n\t}\n"]}
{"filename": "src/content/utils/notifications.ts", "chunked_list": ["import AWN from 'awesome-notifications';\n\ttype NotificationFn = (message: string) => void;\n\tconst DURATION = 3000;\n\t// TODO : fix the source of why notifications are updated so often\n\tconst throttle = (fn: NotificationFn, delay = DURATION - 1000): NotificationFn => {\n\t  const lastCalls = {} as { [key: string]: number };\n\t  return (message: string): void => {\n\t    const now = (new Date()).getTime();\n\t    const lastCall = lastCalls[message] || 0;\n\t    if (now - lastCall > delay) {\n", "      lastCalls[message] = now;\n\t      fn(message);\n\t    }\n\t  };\n\t};\n\tconst notifier = new AWN({\n\t  maxNotifications: 3,\n\t  durations: {\n\t    global: DURATION\n\t  }\n", "});\n\texport const alert = throttle((message: string): void => {\n\t  notifier.alert(message);\n\t});\n\texport const modal = throttle((message: string): void => {\n\t  notifier.modal(message);\n\t});\n\texport const success = throttle((message: string): void => {\n\t  notifier.success(message);\n\t});\n", "export const tip = throttle((message: string): void => {\n\t  notifier.tip(message);\n\t});\n"]}
{"filename": "src/content/utils/cursor.ts", "chunked_list": ["import {getCurrentCursorPosition, setCurrentCursorPosition} from './selection';\n\texport class Cursor {\n\t  #position: number;\n\t  readonly #contentEditable: HTMLElement;\n\t  constructor(contentEditable: HTMLElement) {\n\t    this.#contentEditable = contentEditable;\n\t    this.#position = 0;\n\t  }\n\t  save(): void {\n\t    this.#position = getCurrentCursorPosition(this.#contentEditable);\n", "  }\n\t  restore(): void {\n\t    this.#contentEditable.focus();\n\t    setCurrentCursorPosition(this.#position, this.#contentEditable);\n\t  }\n\t  move(step: number): void {\n\t    if (this.#contentEditable.textContent === null) return;\n\t    this.#position += step;\n\t    if (this.#position < 0) {\n\t      this.#position = 0;\n", "    } else if (this.#position > this.#contentEditable.textContent.length) {\n\t      this.#position = this.#contentEditable.textContent.length;\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/content/utils/selection.ts", "chunked_list": ["// This code is courtesy of https://stackoverflow.com/a/62700928/1887427\n\t// Here, it has been restructured into exported and non-exported functions\n\tconst createRange = (node: Node, chars: { count: number }, range?: Range): Range => {\n\t  if (!range) {\n\t    range = document.createRange();\n\t    range.selectNode(node);\n\t    range.setStart(node, 0);\n\t  }\n\t  if (chars.count === 0) {\n\t    range.setEnd(node, chars.count);\n", "  } else if (node && node.textContent && chars.count > 0) {\n\t    if (node.nodeType === Node.TEXT_NODE) {\n\t      if (node.textContent.length < chars.count) {\n\t        chars.count -= node.textContent.length;\n\t      } else {\n\t        range.setEnd(node, chars.count);\n\t        chars.count = 0;\n\t      }\n\t    } else {\n\t      for (let lp = 0; lp < node.childNodes.length; lp++) {\n", "        range = createRange(node.childNodes[lp], chars, range);\n\t        if (chars.count === 0) break;\n\t      }\n\t    }\n\t  }\n\t  return range;\n\t};\n\tconst isChildOf = (node: Node, parentElement: Node): boolean => {\n\t  while (node !== null) {\n\t    if (node === parentElement) return true;\n", "    node = node.parentNode as Node;\n\t  }\n\t  return false;\n\t};\n\texport const getCurrentCursorPosition = (parentElement: HTMLElement): number => {\n\t  const selection = window.getSelection();\n\t  let charCount = -1;\n\t  let node = null;\n\t  if (selection && selection.focusNode) {\n\t    if (isChildOf(selection.focusNode, parentElement)) {\n", "      node = selection.focusNode;\n\t      charCount = selection.focusOffset;\n\t      while (node) {\n\t        if (node === parentElement) break;\n\t        if (node.previousSibling) {\n\t          node = node.previousSibling;\n\t          charCount += node.textContent?.length ?? 0;\n\t        } else {\n\t          node = node.parentNode;\n\t          if (node === null) break;\n", "        }\n\t      }\n\t    }\n\t  }\n\t  return charCount;\n\t};\n\texport const setCurrentCursorPosition = (chars: number, element: HTMLElement): void => {\n\t  if (chars >= 0) {\n\t    const selection = window.getSelection();\n\t    const range = createRange(element, {count: chars});\n", "    if (selection && range) {\n\t      range.collapse(false);\n\t      selection.removeAllRanges();\n\t      selection.addRange(range);\n\t    }\n\t  }\n\t};\n"]}
{"filename": "src/content/bsky/api.ts", "chunked_list": ["import {Post} from '@atproto/api/dist/src/types/app/bsky/getPostThread';\n\timport {BskyAgent} from '@atproto/api';\n\texport class LoginError extends Error {}\n\texport const getAgent = async (identifier: string, password: string): Promise<BskyAgent> => {\n\t  const agent = new BskyAgent({service: 'https://bsky.social'});\n\t  // TODO : cache session\n\t  try {\n\t    await agent.login({identifier, password});\n\t    return agent;\n\t  } catch {\n", "    throw new LoginError();\n\t  }\n\t};\n\texport const fetchPost = async (agent: BskyAgent, username: string, postId: string): Promise<Post> => {\n\t  const did = await agent.resolveHandle({ handle: username }).then((response) => response.data.did);\n\t  const response = await agent.getPostThread({uri: `at://${did}/app.bsky.feed.post/${postId}`});\n\t  return response.data.thread.post as Post;\n\t};\n"]}
{"filename": "src/content/dom/selectors.ts", "chunked_list": ["import {FIRST_CHILD_MARKER, LAST_CHILD_MARKER, POST_ITEM_LINK_INJECTED_MARKER} from './constants';\n\timport {Selector} from './selector';\n\timport {SelectorGroup} from './selectorGroup';\n\t// TODO : remake Selector and SelectorGroup in such a way they could support relative chaining\n\texport const FIRST_CHILD = new Selector(FIRST_CHILD_MARKER);\n\texport const LAST_CHILD = new Selector(LAST_CHILD_MARKER);\n\texport const ROOT_CONTAINER = new Selector('#root > div > div');\n\texport const FEED_CONTAINER = [FIRST_CHILD, FIRST_CHILD, FIRST_CHILD]; // relative to ROOT_CONTAINER\n\texport const MODAL_CONTAINER = LAST_CHILD; // relative to ROOT_CONTAINER\n\texport const COMPOSE_MODAL = new Selector('[data-testid=\"composePostView\"]'); // relative to MODAL_CONTAINER\n", "// All the following are relative to COMPOSE_MODAL\n\texport const COMPOSE_CANCEL_BUTTON = new Selector('[data-testid=\"composerCancelButton\"]');\n\texport const COMPOSE_CONTENT_EDITABLE = new Selector('div.ProseMirror');\n\texport const COMPOSE_LINK_CARD_BUTTON = new Selector('[data-testid=\"addLinkCardBtn\"]');\n\texport const COMPOSE_PHOTO_BUTTON = new Selector('[data-testid=\"openGalleryBtn\"]');\n\texport const SEARCH_BAR = new Selector('[data-testid=\"searchTextInput\"]'); // relative to FEED_CONTAINER\n\texport const POST_ITEMS = new SelectorGroup([\n\t  new Selector('[data-testid^=\"postThreadItem\"]', {exhaustAfter: 5000}),\n\t  new Selector('[data-testid^=\"feedItem\"]', {exhaustAfter: 5000})\n\t]);\n", "// relative to POST_ITEMS\n\texport const POST_ITEM_LINKS = new SelectorGroup([\n\t  new Selector(`a[href*=\"youtu.be/\"]:not([${POST_ITEM_LINK_INJECTED_MARKER}])`),\n\t  new Selector(`a[href*=\"youtube.com/watch\"]:not([${POST_ITEM_LINK_INJECTED_MARKER}])`)\n\t]);\n"]}
{"filename": "src/content/dom/selector.ts", "chunked_list": ["import {FIRST_CHILD_MARKER, LAST_CHILD_MARKER} from './constants';\n\tconst DEFAULT_SEARCH_TIMEOUT = 2000;\n\t// TODO : make an InstantSelector class that would have exhaustAfter = 0\n\texport class Selector {\n\t  // TODO : add .matches(element: HTMLElement) method\n\t  readonly selector: string;\n\t  readonly #firstOnly: boolean;\n\t  readonly exhaustAfter: number;\n\t  constructor(selector: string, {firstOnly = false, exhaustAfter = DEFAULT_SEARCH_TIMEOUT} = {}) {\n\t    this.selector = selector;\n", "    this.#firstOnly = firstOnly;\n\t    this.exhaustAfter = exhaustAfter;\n\t  }\n\t  retrieveFrom(elements: HTMLElement[]): HTMLElement[] {\n\t    let result;\n\t    if (this.selector === FIRST_CHILD_MARKER) {\n\t      result = elements.map((elem) => elem.firstChild);\n\t    } else if (this.selector === LAST_CHILD_MARKER) {\n\t      result = elements.map((elem) => elem.lastChild);\n\t    } else if (this.#firstOnly) {\n", "      result = elements.map((elem) => elem.querySelector(this.selector));\n\t    } else {\n\t      result = elements.map((elem) => Array.from(elem.querySelectorAll(this.selector))).flat();\n\t    }\n\t    return result.filter((elem) => elem !== null && elem !== undefined) as HTMLElement[];\n\t  }\n\t  clone(): Selector {\n\t    return new Selector(this.selector, {firstOnly: this.#firstOnly, exhaustAfter: this.exhaustAfter});\n\t  }\n\t}\n"]}
{"filename": "src/content/dom/constants.ts", "chunked_list": ["export const FIRST_CHILD_MARKER = '~~FIRST_CHILD~~';\n\texport const LAST_CHILD_MARKER = '~~LAST_CHILD~~';\n\texport const POST_ITEM_LINK_INJECTED_MARKER = 'bluesky-overhaul-youtube-injected';\n"]}
{"filename": "src/content/dom/utils.ts", "chunked_list": ["import {Selector} from './selector';\n\timport {SelectorGroup} from './selectorGroup';\n\texport type TSelectorLike = Selector | SelectorGroup;\n\ttype TSelectorOrArray = TSelectorLike | TSelectorLike[];\n\tconst findInElements = (selector: TSelectorLike, elements: HTMLElement[]): Promise<HTMLElement[]> => {\n\t  return new Promise((resolve, reject) => {\n\t    const firstAttemptResult = selector.retrieveFrom(elements);\n\t    if (firstAttemptResult.length > 0) {\n\t      resolve(firstAttemptResult);\n\t    } else {\n", "      const observer = new MutationObserver(() => {\n\t        const foundElements = selector.retrieveFrom(elements);\n\t        if (foundElements.length > 0) {\n\t          observer.disconnect();\n\t          resolve(foundElements);\n\t        }\n\t      });\n\t      for (const element of elements) {\n\t        observer.observe(element, {childList: true, subtree: true});\n\t      }\n", "      setTimeout(() => {\n\t        observer.disconnect();\n\t        reject();\n\t      }, selector.exhaustAfter);\n\t    }\n\t  });\n\t};\n\texport const ultimatelyFindAll = (rootElement: HTMLElement, selectors: TSelectorOrArray): Promise<HTMLElement[]> => {\n\t  if (!(selectors instanceof Array)) selectors = [selectors];\n\t  return selectors.reduce(async (previousPromise, selector): Promise<HTMLElement[]> => {\n", "    const foundElements = await previousPromise;\n\t    return findInElements(selector, foundElements);\n\t  }, Promise.resolve([rootElement]));\n\t};\n\texport const ultimatelyFind = (rootElement: HTMLElement, selectors: TSelectorOrArray): Promise<HTMLElement> => {\n\t  return ultimatelyFindAll(rootElement, selectors).then((foundElements) => foundElements?.[0] ?? null);\n\t};\n"]}
{"filename": "src/content/dom/selectorGroup.ts", "chunked_list": ["import {Selector} from './selector';\n\texport class SelectorGroup {\n\t  readonly #selectors: Selector[];\n\t  readonly exhaustAfter: number;\n\t  constructor(selectors: Selector[]) {\n\t    // TODO : add .merge() method to SelectorGroup (probably a static one)\n\t    // TODO : add .extend() method to SelectorGroup (probably a static one)\n\t    if (selectors.some((selector) => selector.exhaustAfter !== selectors[0].exhaustAfter)) {\n\t      throw new Error('All selectors in a group must have the same exhaustAfter value');\n\t    }\n", "    this.#selectors = selectors;\n\t    this.exhaustAfter = selectors[0].exhaustAfter;\n\t  }\n\t  retrieveFrom(elements: HTMLElement[]): HTMLElement[] {\n\t    const result = this.#selectors.map((selector) => selector.retrieveFrom(elements));\n\t    return result.flat();\n\t  }\n\t  clone(): SelectorGroup {\n\t    return new SelectorGroup(this.#selectors.map((selector) => selector.clone()));\n\t  }\n", "}\n"]}
{"filename": "src/content/browser/settingsManager.ts", "chunked_list": ["import {TSetting, TSettings} from '../../types';\n\timport {ISettingsSubscriber} from '../../interfaces';\n\timport {APP_SETTINGS} from '../../shared/appSettings';\n\timport {subscribeToSettings} from '../../shared/browserApi';\n\timport {SettingsProvider} from '../../shared/settingsProvider';\n\timport {success} from '../utils/notifications';\n\texport type TListener = (settingName: APP_SETTINGS, value: TSetting) => void;\n\tclass SettingsManager extends SettingsProvider {\n\t  readonly #listeners: { [key in APP_SETTINGS]?: TListener[] } = {};\n\t  async initialize(): Promise<void> {\n", "    await super.initialize();\n\t    subscribeToSettings(this.#onSettingsChange.bind(this));\n\t  }\n\t  subscribe(subscriber: ISettingsSubscriber): void {\n\t    if (!this.isInitialized) throw new Error('SettingsManager is not initialized');\n\t    subscriber.SETTINGS.forEach((settingName: APP_SETTINGS) => {\n\t      if (!this.#listeners[settingName]) {\n\t        this.#listeners[settingName] = [];\n\t      }\n\t      const callback = subscriber.onSettingChange.bind(subscriber);\n", "      this.#listeners[settingName]?.push(callback);\n\t      if (settingName in this.settings) {\n\t        callback(settingName, this.settings[settingName] as TSetting);\n\t      }\n\t    });\n\t  }\n\t  #onSettingsChange(newSettings: TSettings): void {\n\t    this.settings = {...this.settings, ...newSettings};\n\t    for (const [key, value] of Object.entries(newSettings)) {\n\t      if (key in this.#listeners) {\n", "        const settingName = key as APP_SETTINGS;\n\t        const listeners = this.#listeners[settingName] as TListener[];\n\t        listeners.forEach((listener) => listener(settingName, value));\n\t      }\n\t    }\n\t    success('Settings updated');\n\t  }\n\t}\n\tconst settingsManager = new SettingsManager();\n\texport const getSettingsManager = async (): Promise<SettingsManager> => {\n", "  await settingsManager.initialize();\n\t  return settingsManager;\n\t};\n"]}
{"filename": "src/content/watchers/postDatetime.ts", "chunked_list": ["import { createPopper } from '@popperjs/core';\n\timport {TSetting, TSettings} from '../../types';\n\timport {APP_SETTINGS} from '../../shared/appSettings';\n\timport {ISettingsSubscriber} from '../../interfaces';\n\timport {Watcher} from './watcher';\n\timport {getSettingsManager} from '../browser/settingsManager';\n\timport {getAgent, fetchPost, LoginError} from '../bsky/api';\n\timport {alert} from '../utils/notifications';\n\tconst DEFAULT_SETTINGS: Partial<TSettings> = {\n\t  [APP_SETTINGS.SHOW_POST_DATETIME]: false,\n", "  [APP_SETTINGS.BSKY_IDENTIFIER]: '',\n\t  [APP_SETTINGS.BSKY_PASSWORD]: ''\n\t};\n\ttype PostUrl = {\n\t  username: string;\n\t  postId: string;\n\t};\n\tconst POST_HREF_REGEX = /profile\\/(.+)\\/post\\/([a-zA-Z0-9]+)$/;\n\tconst DATETIME_MARKER = 'data-bluesky-overhaul-datetime';\n\tconst getCredentials = async (): Promise<[string, string]> => {\n", "  const settingsManager = await getSettingsManager();\n\t  return await Promise.all([\n\t    settingsManager.get(APP_SETTINGS.BSKY_IDENTIFIER) as string,\n\t    settingsManager.get(APP_SETTINGS.BSKY_PASSWORD) as string\n\t  ]);\n\t};\n\tconst parsePostUrl = (url: string | null): PostUrl => {\n\t  if (!url) throw new Error('Missing post URL');\n\t  const match = url.match(POST_HREF_REGEX);\n\t  if (!match) throw new Error('Invalid post URL');\n", "  return {username: match[1], postId: match[2]};\n\t};\n\tconst parsePostDatetime = (datetime: string): string => {\n\t  const date = new Date(datetime);\n\t  return date.toLocaleString('en-US', {\n\t    month: 'long', day: 'numeric', year: 'numeric', hour: 'numeric', minute: 'numeric'\n\t  });\n\t};\n\tconst createDatetimeTooltip = (datetime: string): HTMLElement => {\n\t  const tooltip = document.createElement('div');\n", "  tooltip.role = 'tooltip';\n\t  tooltip.className = 'bluesky-overhaul-tooltip';\n\t  tooltip.textContent = datetime;\n\t  return tooltip;\n\t};\n\texport class PostDatetimeWatcher extends Watcher implements ISettingsSubscriber {\n\t  #container: HTMLElement;\n\t  #enabled: boolean;\n\t  constructor(container: HTMLElement) {\n\t    super();\n", "    this.#container = container;\n\t    this.#enabled = DEFAULT_SETTINGS[APP_SETTINGS.SHOW_POST_DATETIME] as boolean;\n\t  }\n\t  watch(): void {\n\t    this.#container.addEventListener('mouseover', this.#handleMouseOver.bind(this));\n\t  }\n\t  onSettingChange(name: APP_SETTINGS, value: TSetting): void {\n\t    if (!this.SETTINGS.includes(name)) throw new Error(`Unknown setting name \"${name}\"`);\n\t    if (typeof value !== typeof DEFAULT_SETTINGS[name]) throw new Error(`Invalid value \"${value}\" for \"${name}\"`);\n\t    if (name === APP_SETTINGS.SHOW_POST_DATETIME) {\n", "      this.#enabled = value as boolean;\n\t    }\n\t  }\n\t  get SETTINGS(): APP_SETTINGS[] {\n\t    return Object.keys(DEFAULT_SETTINGS) as APP_SETTINGS[];\n\t  }\n\t  async #handleMouseOver(event: MouseEvent): Promise<void> {\n\t    if (!this.#enabled) return;\n\t    const target = event.target as HTMLElement;\n\t    if (target.tagName.toLowerCase() !== 'a') return;\n", "    let datetime = target.getAttribute(DATETIME_MARKER);\n\t    if (!datetime) {\n\t      try {\n\t        const {username, postId} = parsePostUrl(target.getAttribute('href'));\n\t        if (username && postId) {\n\t          const [identifier, password] = await getCredentials();\n\t          try {\n\t            const agent = await getAgent(identifier, password);\n\t            const post = await fetchPost(agent, username, postId);\n\t            datetime = parsePostDatetime(post.indexedAt);\n", "            target.setAttribute(DATETIME_MARKER, datetime);\n\t          } catch (error) {\n\t            if (error instanceof LoginError) alert('Login failed: wrong identifier or password');\n\t            return;\n\t          }\n\t        } else {\n\t          return;\n\t        }\n\t      } catch {\n\t        return;\n", "      }\n\t    }\n\t    const tooltip = createDatetimeTooltip(datetime);\n\t    document.body.appendChild(tooltip);\n\t    const instance = createPopper(target, tooltip, {\n\t      placement: 'top'\n\t    });\n\t    target.addEventListener('mouseleave', () => {\n\t      instance.destroy();\n\t      tooltip.remove();\n", "    }, {once: true});\n\t  }\n\t}\n"]}
{"filename": "src/content/watchers/youtube.ts", "chunked_list": ["import {Watcher} from './watcher';\n\timport {CallThrottler} from '../utils/callThrottler';\n\timport {POST_ITEM_LINK_INJECTED_MARKER} from '../dom/constants';\n\timport {POST_ITEMS, POST_ITEM_LINKS} from '../dom/selectors';\n\timport {ultimatelyFindAll} from '../dom/utils';\n\timport {noop} from '../../shared/misc';\n\tconst THROTTLING_INTERVAL = 500;\n\tconst YOUTU_BE_REGEX = /youtu\\.be\\/([a-zA-Z0-9_-]+)/;\n\tconst YOUTUBE_WATCH_REGEX = /youtube\\.com\\/watch\\?v=([a-zA-Z0-9_-]+)/;\n\tconst resolveYoutubeId = (url: string): string | null => {\n", "  let match;\n\t  if (url.includes('youtu.be')) {\n\t    match = url.match(YOUTU_BE_REGEX);\n\t  } else if (url.includes('youtube.com/watch')) {\n\t    match = url.match(YOUTUBE_WATCH_REGEX);\n\t  }\n\t  return match?.[1] ?? null;\n\t};\n\tconst injectYoutubePlayers = (youtubeLinks: HTMLLinkElement[]): void => {\n\t  youtubeLinks.forEach((link) => {\n", "    if (link.getAttribute(POST_ITEM_LINK_INJECTED_MARKER)) return;\n\t    const videoId = resolveYoutubeId(link.href ?? '');\n\t    if (!videoId) return;\n\t    const iframe = document.createElement('iframe');\n\t    iframe.setAttribute('src', `https://www.youtube.com/embed/${videoId}`);\n\t    iframe.setAttribute('allow', 'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture');\n\t    iframe.setAttribute('allowfullscreen', 'true');\n\t    iframe.style.width = '100%';\n\t    iframe.style.height = '400px';\n\t    iframe.style.border = 'none';\n", "    iframe.style.flexGrow = '1';\n\t    iframe.style.paddingTop = '10px';\n\t    link.parentNode?.parentNode?.appendChild(iframe);\n\t    link.setAttribute(POST_ITEM_LINK_INJECTED_MARKER, 'true');\n\t    const blueskyYoutubePreview = iframe.parentNode?.nextSibling as HTMLElement;\n\t    if (blueskyYoutubePreview?.getAttribute('tabindex') === '0') {\n\t      blueskyYoutubePreview.style.display = 'none';\n\t    }\n\t  });\n\t};\n", "const createYoutubePlayers = (container: HTMLElement): void => {\n\t  ultimatelyFindAll(container, [POST_ITEMS, POST_ITEM_LINKS])\n\t    .then((links) => injectYoutubePlayers(links as HTMLLinkElement[]))\n\t    .catch(noop);\n\t};\n\texport class YoutubeWatcher extends Watcher {\n\t  readonly #container: HTMLElement;\n\t  readonly #throttler: CallThrottler = new CallThrottler(THROTTLING_INTERVAL);\n\t  readonly #observer: MutationObserver;\n\t  constructor(container: HTMLElement) {\n", "    super();\n\t    this.#container = container;\n\t    this.#observer = new MutationObserver(() => {\n\t      const currentLayout = this.#container.lastChild as HTMLElement;\n\t      this.#throttler.call(() => createYoutubePlayers(currentLayout));\n\t    });\n\t  }\n\t  watch(): void {\n\t    const initialLayout = this.#container.lastChild as HTMLElement;\n\t    this.#throttler.call(() => createYoutubePlayers(initialLayout));\n", "    this.#observer.observe(this.#container, {childList: true, subtree: true});\n\t  }\n\t}\n"]}
{"filename": "src/content/watchers/keydown.ts", "chunked_list": ["import {TSetting, TSettings} from '../../types';\n\timport {IPausable, ISettingsSubscriber} from '../../interfaces';\n\timport {APP_SETTINGS} from '../../shared/appSettings';\n\timport {Watcher} from './watcher';\n\timport {VimKeybindingsHandler} from './helpers/vimKeybindings';\n\timport {ultimatelyFind} from '../dom/utils';\n\timport {Selector} from '../dom/selector';\n\tconst DEFAULT_SETTINGS: Partial<TSettings> = {\n\t  [APP_SETTINGS.HANDLE_VIM_KEYBINDINGS]: false\n\t};\n", "const LEFT_ARROW_BUTTON = new Selector('[aria-label=\"Previous image\"]', {exhaustAfter: 0});\n\tconst RIGHT_ARROW_BUTTON = new Selector('[aria-label=\"Next image\"]', {exhaustAfter: 0});\n\tconst PHOTO_KEYS = ['ArrowLeft', 'ArrowRight'];\n\texport class KeydownWatcher extends Watcher implements IPausable, ISettingsSubscriber {\n\t  readonly #container: HTMLElement;\n\t  readonly #vimHandler: VimKeybindingsHandler;\n\t  #isPaused = false;\n\t  constructor(targetContainer: HTMLElement, vimContainer: HTMLElement) {\n\t    super();\n\t    this.#container = targetContainer;\n", "    this.#vimHandler = new VimKeybindingsHandler(vimContainer, true);\n\t  }\n\t  watch(): void {\n\t    document.addEventListener('keydown', this.#onKeydown.bind(this));\n\t  }\n\t  start(): void {\n\t    if (!this.#isPaused) return;\n\t    this.#vimHandler.start();\n\t    this.#isPaused = false;\n\t  }\n", "  pause(): void {\n\t    if (this.#isPaused) return;\n\t    this.#vimHandler.pause();\n\t    this.#isPaused = true;\n\t  }\n\t  onSettingChange(name: APP_SETTINGS, value: TSetting): void {\n\t    if (!this.SETTINGS.includes(name)) throw new Error(`Unknown setting name \"${name}\"`);\n\t    if (typeof value !== typeof DEFAULT_SETTINGS[name]) throw new Error(`Invalid value \"${value}\" for \"${name}\"`);\n\t    if (name === APP_SETTINGS.HANDLE_VIM_KEYBINDINGS) {\n\t      if (value === true) {\n", "        this.#vimHandler.start();\n\t      } else {\n\t        this.#vimHandler.pause();\n\t      }\n\t    }\n\t  }\n\t  get SETTINGS(): APP_SETTINGS[] {\n\t    return Object.keys(DEFAULT_SETTINGS) as APP_SETTINGS[];\n\t  }\n\t  #onKeydown(event: KeyboardEvent): void {\n", "    if (this.#isPaused || event.ctrlKey || event.metaKey) return;\n\t    if (PHOTO_KEYS.includes(event.key)) {\n\t      Promise.all([\n\t        ultimatelyFind(this.#container, LEFT_ARROW_BUTTON).catch(() => null),\n\t        ultimatelyFind(this.#container, RIGHT_ARROW_BUTTON).catch(() => null)\n\t      ]).then(([leftArrow, rightArrow]) => {\n\t        if (event.key === 'ArrowLeft' && leftArrow !== null) {\n\t          leftArrow.click();\n\t        } else if (event.key === 'ArrowRight' && rightArrow !== null) {\n\t          rightArrow.click();\n", "        }\n\t      });\n\t    } else {\n\t      this.#vimHandler.handle(event);\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/content/watchers/watcher.ts", "chunked_list": ["export abstract class Watcher {\n\t  abstract watch(): void;\n\t}\n"]}
{"filename": "src/content/watchers/countersConcealer.ts", "chunked_list": ["import {TSetting, TSettings} from '../../types';\n\timport {APP_SETTINGS} from '../../shared/appSettings';\n\timport {ISettingsSubscriber} from '../../interfaces';\n\timport {Watcher} from './watcher';\n\tconst DEFAULT_SETTINGS: Partial<TSettings> = {\n\t  [APP_SETTINGS.HIDE_FOLLOWERS_COUNT]: false,\n\t  [APP_SETTINGS.HIDE_FOLLOWING_COUNT]: false,\n\t  [APP_SETTINGS.HIDE_POSTS_COUNT]: false\n\t};\n\tconst CONCEALER_CLASS = 'bluesky-overhaul-concealer';\n", "const HIDE_FOLLOWERS_CLASS = 'bluesky-overhaul-hide-followers';\n\tconst HIDE_FOLLOWING_CLASS = 'bluesky-overhaul-hide-following';\n\tconst HIDE_POSTS_CLASS = 'bluesky-overhaul-hide-posts';\n\texport class CountersConcealer extends Watcher implements ISettingsSubscriber {\n\t  #container: HTMLElement;\n\t  constructor(documentBody: HTMLElement) {\n\t    super();\n\t    this.#container = documentBody;\n\t  }\n\t  watch(): void {\n", "    this.#container.classList.add(CONCEALER_CLASS);\n\t  }\n\t  onSettingChange(name: APP_SETTINGS, value: TSetting): void {\n\t    if (!this.SETTINGS.includes(name)) throw new Error(`Unknown setting name \"${name}\"`);\n\t    if (typeof value !== typeof DEFAULT_SETTINGS[name]) throw new Error(`Invalid value \"${value}\" for \"${name}\"`);\n\t    if (name === APP_SETTINGS.HIDE_FOLLOWERS_COUNT) {\n\t      this.#toggleClass(value as boolean, HIDE_FOLLOWERS_CLASS);\n\t    } else if (name === APP_SETTINGS.HIDE_FOLLOWING_COUNT) {\n\t      this.#toggleClass(value as boolean, HIDE_FOLLOWING_CLASS);\n\t    } else if (name === APP_SETTINGS.HIDE_POSTS_COUNT) {\n", "      this.#toggleClass(value as boolean, HIDE_POSTS_CLASS);\n\t    }\n\t  }\n\t  get SETTINGS(): APP_SETTINGS[] {\n\t    return Object.keys(DEFAULT_SETTINGS) as APP_SETTINGS[];\n\t  }\n\t  #toggleClass(enable: boolean, className: string): void {\n\t    if (enable) {\n\t      this.#container.classList.add(className);\n\t    } else {\n", "      this.#container.classList.remove(className);\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/content/watchers/helpers/postList.ts", "chunked_list": ["import {IPausable} from '../../../interfaces';\n\timport {TSelectorLike, ultimatelyFindAll} from '../../dom/utils';\n\timport {LAST_CHILD, POST_ITEMS} from '../../dom/selectors';\n\timport {Selector} from '../../dom/selector';\n\timport {EventKeeper} from '../../utils/eventKeeper';\n\tconst LAG = 100;\n\tconst FOLLOWING_DATA = 'homeScreenFeedTabs-Following';\n\tconst WHATSHOT_DATA = 'homeScreenFeedTabs-What\\'s hot';\n\tconst TAB_BUTTONS = new Selector('[data-testid=\"homeScreenFeedTabs\"]', {exhaustAfter: LAG});\n\tconst FOLLOWING_FEED = new Selector('[data-testid=\"followingFeedPage\"]');\n", "const WHATSHOT_FEED = new Selector('[data-testid=\"whatshotFeedPage\"]');\n\tconst getNextPost = (post: HTMLElement): HTMLElement | null => {\n\t  if (post.nextSibling) {\n\t    return post.nextSibling as HTMLElement;\n\t  } else {\n\t    const parent = post.parentElement;\n\t    if (parent && parent.nextSibling) {\n\t      return parent.nextSibling.firstChild as HTMLElement;\n\t    } else {\n\t      return null;\n", "    }\n\t  }\n\t};\n\tconst getPreviousPost = (post: HTMLElement): HTMLElement | null => {\n\t  if (post.previousSibling) {\n\t    return post.previousSibling as HTMLElement;\n\t  } else {\n\t    const parent = post.parentElement;\n\t    if (parent && parent.previousSibling) {\n\t      return parent.previousSibling.lastChild as HTMLElement;\n", "    } else {\n\t      return null;\n\t    }\n\t  }\n\t};\n\tconst isPostThreadDelimiter = (postCandidate: HTMLElement): boolean => {\n\t  return postCandidate.getAttribute('role') === 'link' && postCandidate.getAttribute('tabindex') === '0';\n\t};\n\texport class PostList implements IPausable {\n\t  readonly #container: HTMLElement;\n", "  readonly #mutationObserver: MutationObserver;\n\t  readonly #tabButtonEventKeeper = new EventKeeper();\n\t  #activeTabSelector: Selector = FOLLOWING_FEED;\n\t  #currentPost: HTMLElement | null = null;\n\t  #isPaused: boolean;\n\t  constructor(targetContainer: HTMLElement, startPaused = true) {\n\t    this.#container = targetContainer;\n\t    this.#mutationObserver = new MutationObserver(this.#onContainerMutation.bind(this));\n\t    this.#isPaused = startPaused;\n\t    if (!startPaused) this.start();\n", "  }\n\t  start(): void {\n\t    this.#isPaused = false;\n\t  }\n\t  pause(): void {\n\t    this.#isPaused = true;\n\t  }\n\t  getCurrentFeedTab(): Promise<Selector> {\n\t    return this.#isMainPage().then((isMainPage) => {\n\t      if (isMainPage) {\n", "        return this.#activeTabSelector.clone();\n\t      } else {\n\t        return Promise.reject('Not on main page');\n\t      }\n\t    });\n\t  }\n\t  setCurrentPost(element: HTMLElement): Promise<HTMLElement> {\n\t    return this.#resolveList().then((posts) => {\n\t      for (const post of posts) {\n\t        if (post === element || post.parentElement === element || post.contains(element)) {\n", "          this.#currentPost = post;\n\t          return this.#currentPost;\n\t        }\n\t      }\n\t      return Promise.reject('Element is not a post');\n\t    });\n\t  }\n\t  getNextPost(): Promise<HTMLElement> {\n\t    return this.#getNeighborPost(getNextPost);\n\t  }\n", "  getPreviousPost(): Promise<HTMLElement> {\n\t    return this.#getNeighborPost(getPreviousPost);\n\t  }\n\t  #getNeighborPost(retrieveFn: (post: HTMLElement) => HTMLElement | null): Promise<HTMLElement> {\n\t    if (this.#isPaused) return Promise.reject('PostList is paused');\n\t    return this.#resolveList().then((posts) => {\n\t      if (posts.length === 0) {\n\t        return Promise.reject('No posts found');\n\t      } else if (this.#currentPost) {\n\t        const neighborPost = retrieveFn(this.#currentPost);\n", "        if (neighborPost && (posts.includes(neighborPost) || isPostThreadDelimiter(neighborPost))) {\n\t          this.#currentPost = neighborPost;\n\t        } else if (!posts.includes(this.#currentPost)) {\n\t          this.#currentPost = posts[0];\n\t        }\n\t      } else {\n\t        this.#currentPost = posts[0];\n\t      }\n\t      return this.#currentPost;\n\t    });\n", "  }\n\t  #isMainPage(): Promise<boolean> {\n\t    return this.#findElements([TAB_BUTTONS]).then((tabButtonsList) => {\n\t      if (tabButtonsList.length !== 1) throw new Error('There should be exactly one tab button container');\n\t      this.#subscribeToTabButtons(tabButtonsList[0]);\n\t      return true;\n\t    }).catch(() => false);\n\t  }\n\t  #resolveList(): Promise<HTMLElement[]> {\n\t    return this.#isMainPage().then((isMainPage) => {\n", "      const prefixingSelectors = isMainPage ? [this.#activeTabSelector] : [];\n\t      return this.#findElements([...prefixingSelectors, POST_ITEMS]).then((posts) => {\n\t        if (posts.length === 0) {\n\t          return Promise.reject('No posts found');\n\t        } else {\n\t          return posts;\n\t        }\n\t      });\n\t    });\n\t  }\n", "  #subscribeToTabButtons(tabButtons: HTMLElement): void {\n\t    this.#tabButtonEventKeeper.cancelAll();\n\t    this.#tabButtonEventKeeper.add(tabButtons, 'click', this.#onTabButtonClick.bind(this));\n\t  }\n\t  #onContainerMutation(mutations: MutationRecord[]): void {\n\t    mutations.forEach((mutation) => {\n\t      if (mutation.target === this.#container) {\n\t        this.#currentPost = null;\n\t      }\n\t    });\n", "  }\n\t  #onTabButtonClick(event: MouseEvent): void {\n\t    const target = event.target as HTMLElement;\n\t    const data = target.getAttribute('data-testid');\n\t    if (data === FOLLOWING_DATA || target.querySelector(`[data-testid=\"${FOLLOWING_DATA}\"]`)) {\n\t      if (this.#activeTabSelector !== FOLLOWING_FEED) this.#currentPost = null;\n\t      this.#activeTabSelector = FOLLOWING_FEED;\n\t    } else if (data === WHATSHOT_DATA || target.querySelector(`[data-testid=\"${WHATSHOT_DATA}\"]`)) {\n\t      if (this.#activeTabSelector !== WHATSHOT_FEED) this.#currentPost = null;\n\t      this.#activeTabSelector = WHATSHOT_FEED;\n", "    }\n\t  }\n\t  #findElements(selectors: TSelectorLike[]): Promise<HTMLElement[]> {\n\t    return ultimatelyFindAll(this.#container, [LAST_CHILD, ...selectors]);\n\t  }\n\t}\n"]}
{"filename": "src/content/watchers/helpers/vimActions.ts", "chunked_list": ["export enum VIM_ACTIONS {\n\t  EXPAND_IMAGE = 'expand_image',\n\t  LIKE = 'like',\n\t  LOAD_NEW_POSTS = 'load_new_posts',\n\t  CREATE_POST = 'create_post',\n\t  NEXT_POST = 'next_post',\n\t  OPEN_POST = 'open_post',\n\t  PREVIOUS_POST = 'previous_post',\n\t  REPLY = 'reply',\n\t  REPOST = 'repost',\n", "  SEARCH = 'search',\n\t  SHOW_HELP = 'show_help'\n\t}\n\texport const VIM_KEY_MAP = {\n\t  '?': VIM_ACTIONS.SHOW_HELP,\n\t  '/': VIM_ACTIONS.SEARCH,\n\t  '.': VIM_ACTIONS.LOAD_NEW_POSTS,\n\t  'j': VIM_ACTIONS.NEXT_POST,\n\t  'k': VIM_ACTIONS.PREVIOUS_POST,\n\t  'l': VIM_ACTIONS.LIKE,\n", "  'n': VIM_ACTIONS.CREATE_POST,\n\t  'o': VIM_ACTIONS.EXPAND_IMAGE,\n\t  'r': VIM_ACTIONS.REPLY,\n\t  't': VIM_ACTIONS.REPOST,\n\t  'ArrowDown': VIM_ACTIONS.NEXT_POST,\n\t  'ArrowUp': VIM_ACTIONS.PREVIOUS_POST,\n\t  'Enter': VIM_ACTIONS.OPEN_POST\n\t};\n\tconst toNormalText = (name: string): string => {\n\t  name = name.replace(/_/g, ' ');\n", "  return name.charAt(0).toUpperCase() + name.slice(1);\n\t};\n\texport const generateHelpMessage = (): string => {\n\t  const actions: { [key: string]: string[] } = {};\n\t  for (const [key, action] of Object.entries(VIM_KEY_MAP)) {\n\t    if (!(action in actions)) actions[action] = [];\n\t    actions[action].push(`<span class=\"mono\">${key}</span>`);\n\t  }\n\t  const helpMessage = [];\n\t  for (const [action, buttons] of Object.entries(actions)) {\n", "    helpMessage.push(`<b>${toNormalText(action)}</b>: ${buttons.join('&nbsp;')}`);\n\t  }\n\t  return `\n\t    <div class=\"bluesky-overhaul-help\">\n\t      <h3>Bluesky Overhaul Vim Keybindings</h3>\n\t      <p>${helpMessage.join('<br/>')}</p>\n\t      <p>You can also Alt+Click to focus any specific post</p>\n\t    </div>\n\t  `;\n\t};\n"]}
{"filename": "src/content/watchers/helpers/vimKeybindings.ts", "chunked_list": ["import {IPausable} from '../../../interfaces';\n\timport {ROOT_CONTAINER, SEARCH_BAR} from '../../dom/selectors';\n\timport {EventKeeper} from '../../utils/eventKeeper';\n\timport {noop} from '../../../shared/misc';\n\timport {modal, tip} from '../../utils/notifications';\n\timport {PostList} from './postList';\n\timport {generateHelpMessage, VIM_ACTIONS, VIM_KEY_MAP} from './vimActions';\n\timport {ultimatelyFind} from '../../dom/utils';\n\tenum DIRECTION { NEXT, PREVIOUS }\n\tconst FOCUSED_POST_CLASS = 'bluesky-overhaul-focused-post';\n", "const MISSING_POST_ERROR = 'No post is focused';\n\tconst REPLY_BUTTON_SELECTOR = '[data-testid=\"replyBtn\"]';\n\tconst REPOST_BUTTON_SELECTOR = '[data-testid=\"repostBtn\"]';\n\tconst LIKE_BUTTON_SELECTOR = '[data-testid=\"likeBtn\"]';\n\texport class VimKeybindingsHandler implements IPausable {\n\t  readonly #container: HTMLElement;\n\t  readonly #postList: PostList;\n\t  readonly #postClickEventKeeper = new EventKeeper();\n\t  readonly #searchBarEventKeeper = new EventKeeper();\n\t  #currentPost: HTMLElement | null = null;\n", "  #stashedPost: HTMLElement | null = null;\n\t  #isPaused: boolean;\n\t  constructor(targetContainer: HTMLElement, startPaused = true) {\n\t    this.#container = targetContainer;\n\t    this.#postList = new PostList(targetContainer, startPaused);\n\t    this.#isPaused = startPaused;\n\t  }\n\t  start(): void {\n\t    if (!this.#isPaused) return;\n\t    this.#postList.start();\n", "    this.#postClickEventKeeper.add(this.#container, 'click', this.#onPostAltClick.bind(this));\n\t    this.#blurSearchBar();\n\t    this.#isPaused = false;\n\t  }\n\t  pause(): void {\n\t    if (this.#isPaused) return;\n\t    this.#postList.pause();\n\t    this.#postClickEventKeeper.cancelAll();\n\t    this.#searchBarEventKeeper.cancelAll();\n\t    this.#removeHighlight();\n", "    this.#isPaused = true;\n\t  }\n\t  handle(event: KeyboardEvent): void {\n\t    if (this.#isPaused) return;\n\t    event.preventDefault();\n\t    const key = event.key;\n\t    if (!(key in VIM_KEY_MAP)) return;\n\t    const action = VIM_KEY_MAP[key as keyof typeof VIM_KEY_MAP];\n\t    switch (action) {\n\t    case VIM_ACTIONS.SHOW_HELP:\n", "      modal(generateHelpMessage());\n\t      break;\n\t    case VIM_ACTIONS.SEARCH:\n\t      this.#focusSearchBar();\n\t      break;\n\t    case VIM_ACTIONS.LOAD_NEW_POSTS:\n\t      this.#loadNewPosts();\n\t      break;\n\t    case VIM_ACTIONS.NEXT_POST:\n\t      this.#selectPost(DIRECTION.NEXT);\n", "      break;\n\t    case VIM_ACTIONS.PREVIOUS_POST:\n\t      this.#selectPost(DIRECTION.PREVIOUS);\n\t      break;\n\t    case VIM_ACTIONS.LIKE:\n\t      this.#likePost();\n\t      break;\n\t    case VIM_ACTIONS.CREATE_POST:\n\t      this.#newPost();\n\t      break;\n", "    case VIM_ACTIONS.EXPAND_IMAGE:\n\t      this.#expandImage();\n\t      break;\n\t    case VIM_ACTIONS.REPLY:\n\t      this.#replyToPost();\n\t      break;\n\t    case VIM_ACTIONS.REPOST:\n\t      this.#repostPost();\n\t      break;\n\t    case VIM_ACTIONS.OPEN_POST:\n", "      this.#currentPost?.click();\n\t      break;\n\t    default:\n\t      tip(`Action \"${action}\" is not implemented yet`);\n\t    }\n\t  }\n\t  #selectPost(direction: DIRECTION): void {\n\t    if (direction === DIRECTION.NEXT) {\n\t      this.#postList.getNextPost().then((p) => this.#highlightPost(p));\n\t    } else {\n", "      this.#postList.getPreviousPost().then((p) => this.#highlightPost(p));\n\t    }\n\t  }\n\t  #replyToPost(): void {\n\t    if (!this.#currentPost) return tip(MISSING_POST_ERROR);\n\t    const reply = this.#currentPost.querySelector(REPLY_BUTTON_SELECTOR) as HTMLElement;\n\t    reply?.click();\n\t  }\n\t  #repostPost(): void {\n\t    if (!this.#currentPost) return tip(MISSING_POST_ERROR);\n", "    const repost = this.#currentPost.querySelector(REPOST_BUTTON_SELECTOR) as HTMLElement;\n\t    repost?.click();\n\t  }\n\t  #likePost(): void {\n\t    if (!this.#currentPost) return tip(MISSING_POST_ERROR);\n\t    const like = this.#currentPost.querySelector(LIKE_BUTTON_SELECTOR) as HTMLElement;\n\t    like?.click();\n\t  }\n\t  #expandImage(): void {\n\t    if (!this.#currentPost) return tip(MISSING_POST_ERROR);\n", "    const imageContainer = this.#currentPost.querySelector('div.expo-image-container') as HTMLElement;\n\t    imageContainer?.click();\n\t  }\n\t  #onPostAltClick(event: MouseEvent): void {\n\t    if (this.#isPaused || !event.altKey) return;\n\t    event.preventDefault();\n\t    this.#postList.setCurrentPost(event.target as HTMLElement).then((p) => this.#highlightPost(p)).catch(noop);\n\t  }\n\t  #highlightPost(post: HTMLElement): void {\n\t    if (post === this.#currentPost) return;\n", "    this.#removeHighlight();\n\t    this.#stashedPost = null;\n\t    this.#currentPost = post;\n\t    this.#currentPost.classList.add(FOCUSED_POST_CLASS);\n\t    this.#currentPost.scrollIntoView({block: 'center', behavior: 'smooth'});\n\t  }\n\t  #removeHighlight(): void {\n\t    this.#stashedPost = this.#currentPost;\n\t    this.#currentPost?.classList.remove(FOCUSED_POST_CLASS);\n\t    this.#currentPost = null;\n", "  }\n\t  #focusSearchBar(): void {\n\t    this.#removeHighlight();\n\t    this.#findSearchBar().then((searchBar) => {\n\t      this.#searchBarEventKeeper.cancelAll();\n\t      searchBar.focus();\n\t      this.#searchBarEventKeeper.add(searchBar, 'blur', this.#blurSearchBar.bind(this));\n\t      this.#searchBarEventKeeper.add(searchBar, 'keydown', (event: KeyboardEvent) => {\n\t        if (event.key === 'Escape') searchBar.blur();\n\t      });\n", "    }).catch(() => tip('Search bar not found'));\n\t  }\n\t  #blurSearchBar(): void {\n\t    this.#searchBarEventKeeper.cancelAll();\n\t    this.#findSearchBar().then((searchBar) => {\n\t      searchBar.blur();\n\t      this.#stashedPost && this.#highlightPost(this.#stashedPost);\n\t      this.#searchBarEventKeeper.add(searchBar, 'focus', this.#focusSearchBar.bind(this));\n\t    });\n\t  }\n", "  #findSearchBar(): Promise<HTMLElement> {\n\t    return ultimatelyFind(document.body, SEARCH_BAR);\n\t  }\n\t  async #loadNewPosts(): Promise<void> {\n\t    try {\n\t      const tab = await this.#postList.getCurrentFeedTab();\n\t      const tabContainer = await ultimatelyFind(this.#container, tab);\n\t      const newPostsButton = tabContainer.childNodes[1] as HTMLElement;\n\t      if (newPostsButton && newPostsButton.nextSibling) {\n\t        newPostsButton.click();\n", "        this.#container.scrollIntoView({block: 'start', behavior: 'smooth'});\n\t      } else {\n\t        tip('No new posts to load');\n\t      }\n\t    } catch {\n\t      tip('You are not on the feed page');\n\t    }\n\t  }\n\t  async #newPost(): Promise<void> {\n\t    const rootContainer = await ultimatelyFind(document.body, ROOT_CONTAINER);\n", "    const children = rootContainer.childNodes;\n\t    const menuItems = children[1].childNodes;\n\t    const newPostButton = menuItems[menuItems.length - 1] as HTMLElement;\n\t    if (newPostButton) {\n\t      newPostButton.click();\n\t    } else {\n\t      tip('No new post button found');\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/content/hacks/emojiDataWrapper.ts", "chunked_list": ["import * as data from '@emoji-mart/data';\n\t// This is done to make `data.categories` amenable to being rewritten by the emoji-mart library\n\texport const emojiData = { ...data };\n"]}
