{"filename": "test/index.test.ts", "chunked_list": ["import { helloWorld } from '../src';\n\tdescribe('index tests', () => {\n\t  beforeEach(() => {\n\t    jest.spyOn(global.console, 'log');\n\t  });\n\t  afterEach(() => {\n\t    // for mocks\n\t    jest.resetAllMocks();\n\t    // for spies\n\t    jest.restoreAllMocks();\n", "  });\n\t  it('logs hello world to the console', () => {\n\t    helloWorld();\n\t    expect(global.console.log).toBeCalled();\n\t    expect(global.console.log).toBeCalledWith('Hello world!');\n\t  });\n\t});"]}
{"filename": "test/mocks/MockCache.ts", "chunked_list": ["export class MockCache {\n\t  cacheName?: string;\n\t  options?: Record<string, any>;\n\t  get: jest.Mock<(key: string) => Promise<any>>;\n\t  set: jest.Mock<(key: string, value: any) => Promise<void>>;\n\t  getOrElse: jest.Mock<(key: string, refreshFunction: (...args: any[]) => Promise<any>) => Promise<any>>;\n\t  constructor (cacheName?: string, options?: Record<string, any>) {\n\t    this.cacheName = cacheName;\n\t    this.options = options;\n\t    this.get = jest.fn();\n", "    this.set = jest.fn();\n\t    this.getOrElse = jest.fn();\n\t  }\n\t  reset () {\n\t    this.get.mockReset();\n\t    this.set.mockReset();\n\t    this.getOrElse.mockReset();\n\t  }\n\t  restore () {\n\t    this.get.mockRestore();\n", "    this.set.mockRestore();\n\t    this.getOrElse.mockRestore();\n\t  }\n\t}\n\texport function mockCache (cacheName: string, options: Record<string, any>): MockCache {\n\t  return new MockCache(cacheName, options);\n\t}"]}
{"filename": "test/service-utilizations/aws-cloudwatch-logs-utilization.test.ts", "chunked_list": ["jest.useFakeTimers();\n\tjest.setSystemTime(new Date('2023-04-14T00:00:00.000Z'));\n\tconst mockCloudWatchLogs = jest.fn();\n\tconst mockDescribeLogGroups = jest.fn();\n\tconst mockDescribeLogStreams = jest.fn();\n\tconst mockGetCredentials = jest.fn();\n\tconst mockPutRetentionPolicy = jest.fn();\n\tconst mockDeleteLogGroup = jest.fn();\n\tconst mockCreateExportTask = jest.fn();\n\tconst mockAccount = jest.fn();\n", "const mockListRegions = jest.fn();\n\tconst mockCloudFormation = jest.fn();\n\tconst mockDescribeStackResources = jest.fn();\n\tconst mockCloudWatch = jest.fn();\n\tconst mockGetMetricData = jest.fn();\n\tjest.mock('@aws-sdk/client-cloudwatch-logs', () => {\n\t  const original = jest.requireActual('@aws-sdk/client-cloudwatch-logs');\n\t  return {\n\t    ...original,\n\t    CloudWatchLogs: mockCloudWatchLogs\n", "  };\n\t});\n\tjest.mock('@aws-sdk/client-account', () => {\n\t  const original = jest.requireActual('@aws-sdk/client-account');\n\t  return {\n\t    ...original,\n\t    Account: mockAccount\n\t  };\n\t});\n\tjest.mock('@aws-sdk/client-cloudformation', () => {\n", "  return {\n\t    CloudFormation: mockCloudFormation\n\t  }\n\t});\n\tjest.mock('@aws-sdk/client-cloudwatch', () => {\n\t  return {\n\t    CloudWatch: mockCloudWatch\n\t  }\n\t});\n\tconst TEN_GB_IN_BYTES = 10737418240;\n", "import { CloudWatchLogs } from \"@aws-sdk/client-cloudwatch-logs\";\n\timport { AwsCredentialsProvider } from \"@tinystacks/ops-aws-core-widgets\";\n\timport { AwsCloudwatchLogsUtilization } from \"../../src/service-utilizations/aws-cloudwatch-logs-utilization\";\n\tdescribe('AwsCloudwatchLogsUtilization', () => {\n\t  beforeEach(() => {\n\t    mockCloudWatchLogs.mockReturnValue({\n\t      describeLogGroups: mockDescribeLogGroups,\n\t      describeLogStreams: mockDescribeLogStreams,\n\t      putRetentionPolicy: mockPutRetentionPolicy,\n\t      deleteLogGroup: mockDeleteLogGroup,\n", "      createExportTask: mockCreateExportTask\n\t    });\n\t    mockAccount.mockReturnValue({\n\t      listRegions: mockListRegions\n\t    });\n\t    mockCloudFormation.mockReturnValue({\n\t      describeStackResources: mockDescribeStackResources\n\t    });\n\t    mockCloudWatch.mockReturnValue({\n\t      getMetricData: mockGetMetricData\n", "    });\n\t  });\n\t  afterEach(() => {\n\t    // for mocks\n\t    jest.resetAllMocks();\n\t    // for spies\n\t    jest.restoreAllMocks();\n\t  });\n\t  describe('getUtilization', () => {\n\t    beforeEach(() => {\n", "      mockListRegions.mockResolvedValue({\n\t        Regions: [{\n\t          RegionName: 'us-east-1'\n\t        }]\n\t      });\n\t      mockDescribeStackResources.mockResolvedValue({\n\t        StackResources: [{\n\t          StackId: 'mock-stack'\n\t        }]\n\t      });\n", "    });\n\t    afterEach(() => {\n\t      // for mocks\n\t      jest.resetAllMocks();\n\t      // for spies\n\t      jest.restoreAllMocks();\n\t    });\n\t    it('suggests adding a retention policy if one does not exist', async () => {\n\t      mockDescribeLogGroups.mockResolvedValueOnce({\n\t        logGroups: [{\n", "          arn: 'mock-log-group-arn',\n\t          logGroupName: '/aws/mock-service/mock-resource',\n\t          retentionInDays: undefined\n\t        }]\n\t      });\n\t      mockDescribeLogStreams.mockResolvedValueOnce({\n\t        logStreams: [{\n\t          lastEventTimestamp: new Date()\n\t        }]\n\t      });\n", "      mockGetMetricData.mockResolvedValueOnce({\n\t        MetricDataResults: [\n\t          {\n\t            Values: [ 0 ]\n\t          }\n\t        ]\n\t      });\n\t      const cloudwatchLogsUtilization = new AwsCloudwatchLogsUtilization();\n\t      const provider = {\n\t        getCredentials: mockGetCredentials\n", "      } as unknown as AwsCredentialsProvider;\n\t      await cloudwatchLogsUtilization.getUtilization(provider);\n\t      expect(mockDescribeLogGroups).toBeCalled();\n\t      expect(mockDescribeLogGroups).toBeCalledWith({\n\t        NextToken: undefined\n\t      });\n\t      expect(mockDescribeLogStreams).toBeCalled();\n\t      expect(mockDescribeLogStreams).toBeCalledTimes(1);\n\t      expect(cloudwatchLogsUtilization.utilization).toHaveProperty('mock-log-group-arn', {\n\t        scenarios: {\n", "          hasRetentionPolicy: {\n\t            value: undefined,\n\t            optimize: {\n\t              action: 'setRetentionPolicy',\n\t              isActionable: true,\n\t              reason: 'this log group does not have a retention policy',\n\t              monthlySavings: 0\n\t            }\n\t          }\n\t        },\n", "        data: {\n\t          resourceId: '/aws/mock-service/mock-resource',\n\t          region: 'us-east-1',\n\t          associatedResourceId: 'mock-resource',\n\t          stack: 'mock-stack',\n\t          hourlyCost: 0,\n\t          monthlyCost: 0,\n\t          maxMonthlySavings: 0\n\t        }\n\t      });\n", "    });\n\t    it('suggests optimizing log group if the log group has not had an event in the past 7 days', async () => {\n\t      mockDescribeLogGroups.mockResolvedValueOnce({\n\t        logGroups: [{\n\t          arn: 'mock-log-group-arn',\n\t          logGroupName: 'mock-log-group',\n\t          retentionInDays: undefined\n\t        }]\n\t      });\n\t      mockDescribeLogStreams.mockResolvedValueOnce({\n", "        logStreams: [{\n\t          lastEventTimestamp: Date.now() - (8 * 24 * 60 * 60 * 1000)\n\t        }]\n\t      });\n\t      mockGetMetricData.mockResolvedValueOnce({\n\t        MetricDataResults: [\n\t          {\n\t            Values: [ 0 ]\n\t          }\n\t        ]\n", "      });\n\t      const cloudwatchLogsUtilization = new AwsCloudwatchLogsUtilization();\n\t      const provider = {\n\t        getCredentials: mockGetCredentials\n\t      } as unknown as AwsCredentialsProvider;\n\t      await cloudwatchLogsUtilization.getUtilization(provider);\n\t      expect(mockDescribeLogGroups).toBeCalled();\n\t      expect(mockDescribeLogGroups).toBeCalledWith({\n\t        NextToken: undefined\n\t      });\n", "      expect(mockDescribeLogStreams).toBeCalled();\n\t      expect(mockDescribeLogStreams).toBeCalledTimes(1);\n\t      expect(cloudwatchLogsUtilization.utilization).toHaveProperty('mock-log-group-arn', {\n\t        scenarios: {\n\t          hasRetentionPolicy: {\n\t            value: undefined,\n\t            optimize: {\n\t              action: 'setRetentionPolicy',\n\t              isActionable: true,\n\t              reason: 'this log group does not have a retention policy',\n", "              monthlySavings: 0\n\t            }\n\t          },\n\t          lastEventTime: {\n\t            value: new Date(1680739200000).toLocaleString(),\n\t            optimize: {\n\t              action: '',\n\t              isActionable: false,\n\t              reason: 'this log group has not had an event in over 7 days'\n\t            }\n", "          }\n\t        },\n\t        data: {\n\t          resourceId: 'mock-log-group',\n\t          region: 'us-east-1',\n\t          stack: 'mock-stack',\n\t          hourlyCost: 0,\n\t          monthlyCost: 0,\n\t          maxMonthlySavings: 0\n\t        }\n", "      });\n\t    });\n\t    it('suggests deleting log group if the log group has not had an event in the past 30 days', async () => {\n\t      mockDescribeLogGroups.mockResolvedValueOnce({\n\t        logGroups: [{\n\t          arn: 'mock-log-group-arn',\n\t          logGroupName: 'mock-log-group',\n\t          retentionInDays: undefined\n\t        }]\n\t      });\n", "      mockDescribeLogStreams.mockResolvedValueOnce({\n\t        logStreams: [{\n\t          lastEventTimestamp: Date.now() - (31 * 24 * 60 * 60 * 1000)\n\t        }]\n\t      });\n\t      mockGetMetricData.mockResolvedValueOnce({\n\t        MetricDataResults: [\n\t          {\n\t            Values: [ 0 ]\n\t          }\n", "        ]\n\t      });\n\t      const cloudwatchLogsUtilization = new AwsCloudwatchLogsUtilization();\n\t      const provider = {\n\t        getCredentials: mockGetCredentials\n\t      } as unknown as AwsCredentialsProvider;\n\t      await cloudwatchLogsUtilization.getUtilization(provider);\n\t      expect(mockDescribeLogGroups).toBeCalled();\n\t      expect(mockDescribeLogGroups).toBeCalledWith({\n\t        NextToken: undefined\n", "      });\n\t      expect(mockDescribeLogStreams).toBeCalled();\n\t      expect(mockDescribeLogStreams).toBeCalledTimes(1);\n\t      expect(cloudwatchLogsUtilization.utilization).toHaveProperty('mock-log-group-arn', {\n\t        scenarios: {\n\t          hasRetentionPolicy: {\n\t            value: undefined,\n\t            optimize: {\n\t              action: 'setRetentionPolicy',\n\t              isActionable: true,\n", "              reason: 'this log group does not have a retention policy',\n\t              monthlySavings: 0\n\t            }\n\t          },\n\t          lastEventTime: {\n\t            value: new Date(1678752000000).toLocaleString(),\n\t            delete: {\n\t              action: 'deleteLogGroup',\n\t              isActionable: true,\n\t              reason: 'this log group has not had an event in over 30 days',\n", "              monthlySavings: 0\n\t            }\n\t          }\n\t        },\n\t        data: {\n\t          resourceId: 'mock-log-group',\n\t          region: 'us-east-1',\n\t          stack: 'mock-stack',\n\t          hourlyCost: 0,\n\t          monthlyCost: 0,\n", "          maxMonthlySavings: 0\n\t        }\n\t      });\n\t    });\n\t    it('suggests creating export task if the log group has more than 100 bytes of stored data', async () => {\n\t      mockDescribeLogGroups.mockResolvedValueOnce({\n\t        logGroups: [{\n\t          arn: 'mock-log-group-arn',\n\t          logGroupName: 'mock-log-group',\n\t          retentionInDays: undefined,\n", "          storedBytes: TEN_GB_IN_BYTES\n\t        }]\n\t      });\n\t      mockDescribeLogStreams.mockResolvedValueOnce({\n\t        logStreams: [{\n\t          lastEventTimestamp: Date.now()\n\t        }]\n\t      });\n\t      mockGetMetricData.mockResolvedValueOnce({\n\t        MetricDataResults: [\n", "          {\n\t            Values: [ 0 ]\n\t          }\n\t        ]\n\t      });\n\t      const cloudwatchLogsUtilization = new AwsCloudwatchLogsUtilization();\n\t      const provider = {\n\t        getCredentials: mockGetCredentials\n\t      } as unknown as AwsCredentialsProvider;\n\t      await cloudwatchLogsUtilization.getUtilization(provider);\n", "      expect(mockDescribeLogGroups).toBeCalled();\n\t      expect(mockDescribeLogGroups).toBeCalledWith({\n\t        NextToken: undefined\n\t      });\n\t      expect(mockDescribeLogStreams).toBeCalled();\n\t      expect(mockDescribeLogStreams).toBeCalledTimes(1);\n\t      expect(cloudwatchLogsUtilization.utilization).toHaveProperty('mock-log-group-arn', {\n\t        scenarios: {\n\t          hasRetentionPolicy: {\n\t            value: undefined,\n", "            optimize: {\n\t              action: 'setRetentionPolicy',\n\t              isActionable: true,\n\t              reason: 'this log group does not have a retention policy',\n\t              monthlySavings: 0.3\n\t            }\n\t          },\n\t          storedBytes: {\n\t            value: TEN_GB_IN_BYTES.toString(),\n\t            scaleDown: {\n", "              action: 'createExportTask',\n\t              isActionable: false,\n\t              reason: 'this log group has more than 100 MB of stored data',\n\t              monthlySavings: 0.3\n\t            }\n\t          }\n\t        },\n\t        data: {\n\t          resourceId: 'mock-log-group',\n\t          region: 'us-east-1',\n", "          stack: 'mock-stack',\n\t          hourlyCost: (0.3 / 30) / 24,\n\t          monthlyCost: 0.3,\n\t          maxMonthlySavings: 0.3\n\t        }\n\t      });\n\t    });\n\t  });\n\t  describe('doAction', () => {\n\t    describe('setRetentionPolicy', () => {\n", "      it('sets retention policy', async () => {\n\t        mockPutRetentionPolicy.mockResolvedValueOnce({});\n\t        const cloudwatchLogsUtilization = new AwsCloudwatchLogsUtilization();\n\t        const provider = {\n\t          getCredentials: mockGetCredentials\n\t        } as unknown as AwsCredentialsProvider;\n\t        await cloudwatchLogsUtilization.doAction(provider, 'setRetentionPolicy', 'arn:mock-log-group:*', 'us-east-1');\n\t        expect(mockPutRetentionPolicy).toBeCalled();\n\t        expect(mockPutRetentionPolicy).toBeCalledWith({\n\t          logGroupName: 'mock-log-group',\n", "          retentionInDays: 90\n\t        });\n\t      });\n\t    });\n\t    describe('deleteLogGroup', () => {\n\t      it('deletes log group', async () => {\n\t        mockDeleteLogGroup.mockResolvedValueOnce({});\n\t        const cloudwatchLogsUtilization = new AwsCloudwatchLogsUtilization();\n\t        const provider = {\n\t          getCredentials: mockGetCredentials\n", "        } as unknown as AwsCredentialsProvider;\n\t        await cloudwatchLogsUtilization.doAction(provider, 'deleteLogGroup', 'arn:mock-log-group:*', 'us-east-1');\n\t        expect(mockDeleteLogGroup).toBeCalled();\n\t        expect(mockDeleteLogGroup).toBeCalledWith({\n\t          logGroupName: 'mock-log-group',\n\t        });\n\t      });\n\t    });\n\t    describe('createExportTask', () => {\n\t      it('creates export task', async () => {\n", "        mockCreateExportTask.mockResolvedValueOnce({});\n\t        const cloudwatchLogsUtilization = new AwsCloudwatchLogsUtilization();\n\t        const cloudwatchLogsClient = new CloudWatchLogs({});\n\t        await cloudwatchLogsUtilization.createExportTask(cloudwatchLogsClient, 'mock-log-group', 'mock-bucket');\n\t        expect(mockCreateExportTask).toBeCalled();\n\t        expect(mockCreateExportTask).toBeCalledWith({\n\t          logGroupName: 'mock-log-group',\n\t          destination: 'mock-bucket',\n\t          from: 0,\n\t          to: Date.now()\n", "        });\n\t      });\n\t    });\n\t  });\n\t});\n"]}
{"filename": "test/service-utilizations/aws-ecs-utilization.test.ts", "chunked_list": ["import { MockCache } from \"../mocks/MockCache\";\n\tjest.useFakeTimers();\n\tjest.setSystemTime(new Date('2023-04-14T00:00:00.000Z'));\n\tconst mockGetCredentials = jest.fn();\n\tconst mockEcs = jest.fn();\n\tconst mockEc2 = jest.fn();\n\tconst mockElbV2 = jest.fn();\n\tconst mockApiGatewayV2 = jest.fn();\n\tconst mockCloudWatch = jest.fn();\n\t// ECS\n", "const mockDescribeServices = jest.fn();\n\tconst mockListClusters = jest.fn();\n\tconst mockListServices = jest.fn();\n\tconst mockListTasks = jest.fn();\n\tconst mockDescribeTasks = jest.fn();\n\tconst mockDescribeContainerInstances = jest.fn();\n\tconst mockDeleteService = jest.fn();\n\tconst mockDescribeTaskDefinition = jest.fn();\n\tconst mockRegisterTaskDefinition = jest.fn();\n\tconst mockUpdateService = jest.fn();\n", "// EC2\n\tconst mockDescribeInstances = jest.fn();\n\tconst mockDescribeInstanceTypes = jest.fn();\n\t// ElbV2\n\tconst mockDescribeTargetGroups = jest.fn();\n\t// CloudWatch\n\tconst mockGetMetricData = jest.fn();\n\t// ApiGatewayV2\n\tconst mockGetApis = jest.fn();\n\tconst mockGetIntegrations = jest.fn();\n", "// ec2 utils\n\tconst mockGetInstanceCost = jest.fn();\n\tconst mockCache = new MockCache();\n\tjest.mock('cached', () => () => mockCache);\n\tjest.mock('@aws-sdk/client-ecs', () => {\n\t  const original = jest.requireActual('@aws-sdk/client-ecs');\n\t  const {\n\t    ContainerInstance,\n\t    DesiredStatus,\n\t    LaunchType,\n", "    ListClustersCommandOutput,\n\t    ListServicesCommandOutput,\n\t    ListTasksCommandOutput,\n\t    Service,\n\t    Task,\n\t    TaskDefinitionField,\n\t    DescribeContainerInstancesCommandOutput\n\t  } = original;\n\t  return {\n\t    ECS: mockEcs,\n", "    ContainerInstance,\n\t    DesiredStatus,\n\t    LaunchType,\n\t    ListClustersCommandOutput,\n\t    ListServicesCommandOutput,\n\t    ListTasksCommandOutput,\n\t    Service,\n\t    Task,\n\t    TaskDefinitionField,\n\t    DescribeContainerInstancesCommandOutput\n", "  };\n\t});\n\tjest.mock('@aws-sdk/client-ec2', () => {\n\t  const original = jest.requireActual('@aws-sdk/client-ec2');\n\t  const { DescribeInstanceTypesCommandOutput, Instance, InstanceTypeInfo, _InstanceType } = original;\n\t  return {\n\t    EC2: mockEc2,\n\t    DescribeInstanceTypesCommandOutput,\n\t    Instance,\n\t    InstanceTypeInfo,\n", "    _InstanceType\n\t  };\n\t});\n\tjest.mock('@aws-sdk/client-apigatewayv2', () => {\n\t  const original = jest.requireActual('@aws-sdk/client-apigatewayv2');\n\t  const {\n\t    Api,\n\t    GetApisCommandOutput,\n\t    Integration\n\t  } = original;\n", "  return {\n\t    ApiGatewayV2: mockApiGatewayV2,\n\t    Api,\n\t    GetApisCommandOutput,\n\t    Integration\n\t  };\n\t});\n\tjest.mock('@aws-sdk/client-elastic-load-balancing-v2', () => ({\n\t  ElasticLoadBalancingV2: mockElbV2\n\t}));\n", "jest.mock('@aws-sdk/client-cloudwatch', () => {\n\t  const original = jest.requireActual('@aws-sdk/client-cloudwatch');\n\t  const { MetricDataQuery, MetricDataResult } = original;\n\t  return {\n\t    CloudWatch: mockCloudWatch,\n\t    MetricDataQuery,\n\t    MetricDataResult\n\t  };\n\t});\n\tjest.mock('../../src/utils/ec2-utils.js', () => {\n", "  const original = jest.requireActual('../../src/utils/ec2-utils.js');\n\t  return {\n\t    ...original,\n\t    getInstanceCost: mockGetInstanceCost\n\t  }\n\t});\n\timport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\n\timport { AwsEcsUtilization } from '../../src/service-utilizations/aws-ecs-utilization';\n\timport t2Micro from '../mocks/T2Micro.json';\n\timport t2Nano from '../mocks/T2Nano.json';\n", "import fargateTaskDef from '../mocks/FargateTaskDef.json';\n\timport { ALB_REQUEST_COUNT, APIG_REQUEST_COUNT, AVG_CPU, AVG_MEMORY, AVG_NETWORK_BYTES_IN, AVG_NETWORK_BYTES_OUT, DISK_READ_OPS, DISK_WRITE_OPS, MAX_CPU, MAX_MEMORY, MAX_NETWORK_BYTES_IN, MAX_NETWORK_BYTES_OUT } from \"../../src/types/constants.js\";\n\tdescribe('AwsEcsUtilization', () => {\n\t  beforeEach(() => {\n\t    mockEcs.mockReturnValue({\n\t      describeServices: mockDescribeServices,\n\t      listClusters: mockListClusters,\n\t      listServices: mockListServices,\n\t      listTasks: mockListTasks,\n\t      describeTasks: mockDescribeTasks,\n", "      describeContainerInstances: mockDescribeContainerInstances,\n\t      deleteService: mockDeleteService,\n\t      describeTaskDefinition: mockDescribeTaskDefinition,\n\t      registerTaskDefinition: mockRegisterTaskDefinition,\n\t      updateService: mockUpdateService\n\t    });\n\t    mockEc2.mockReturnValue({\n\t      describeInstances: mockDescribeInstances,\n\t      describeInstanceTypes: mockDescribeInstanceTypes\n\t    });\n", "    mockElbV2.mockReturnValue({\n\t      describeTargetGroups: mockDescribeTargetGroups\n\t    })\n\t    mockCloudWatch.mockReturnValue({\n\t      getMetricData: mockGetMetricData\n\t    });\n\t    mockApiGatewayV2.mockReturnValue({\n\t      getApis: mockGetApis,\n\t      getIntegrations: mockGetIntegrations\n\t    })\n", "  });\n\t  afterEach(() => {\n\t    // for mocks\n\t    jest.resetAllMocks();\n\t    // for spies\n\t    jest.restoreAllMocks();\n\t    mockCache.reset();\n\t    mockCache.restore();\n\t  });\n\t  describe('getRegionalUtilization', () => {\n", "    it('Calls describeServices with cluster name and service arns if provided', async () => {\n\t      mockDescribeServices.mockResolvedValue({\n\t        services: []\n\t      });\n\t      const ecsUtil = new AwsEcsUtilization(true);\n\t      const provider = {\n\t        getCredentials: mockGetCredentials\n\t      } as unknown as AwsCredentialsProvider;\n\t      await ecsUtil.getRegionalUtilization(provider, 'us-east-1', {\n\t          services: [\n", "            {\n\t              clusterArn: 'mock-cluster-a',\n\t              serviceArn: 'mock-service-a'\n\t            },\n\t            {\n\t              clusterArn: 'mock-cluster-a',\n\t              serviceArn: 'mock-service-a-2'\n\t            },\n\t            {\n\t              clusterArn: 'mock-cluster-b',\n", "              serviceArn: 'mock-service-b'\n\t            }\n\t          ]\n\t        }\n\t      );\n\t      expect(mockDescribeServices).toBeCalled();\n\t      expect(mockDescribeServices).toBeCalledTimes(2);\n\t      expect(mockDescribeServices).toBeCalledWith({\n\t        cluster: 'mock-cluster-a',\n\t        services: ['mock-service-a', 'mock-service-a-2']\n", "      });\n\t      expect(mockDescribeServices).toBeCalledWith({\n\t        cluster: 'mock-cluster-b',\n\t        services: ['mock-service-b']\n\t      });\n\t    });\n\t    it('lists all services if cluster name and service arns if provided', async () => {\n\t      mockListClusters.mockResolvedValueOnce({\n\t        clusterArns: ['mock-cluster-a'],\n\t        nextToken: 'next-token'\n", "      });\n\t      mockListClusters.mockResolvedValueOnce({\n\t        clusterArns: ['mock-cluster-b']\n\t      });\n\t      mockListServices.mockResolvedValueOnce({\n\t        serviceArns: ['mock-service-a'],\n\t        nextToken: 'next-token'\n\t      });\n\t      mockListServices.mockResolvedValueOnce({\n\t        serviceArns: ['mock-service-a-2']\n", "      });\n\t      mockListServices.mockResolvedValueOnce({\n\t        serviceArns: ['mock-service-b']\n\t      });\n\t      mockDescribeServices.mockResolvedValue({\n\t        services: []\n\t      });\n\t      const ecsUtil = new AwsEcsUtilization(true);\n\t      const provider = {\n\t        getCredentials: mockGetCredentials\n", "      } as unknown as AwsCredentialsProvider;\n\t      await ecsUtil.getRegionalUtilization(provider, 'us-east-1');\n\t      expect(mockListClusters).toBeCalled();\n\t      expect(mockListClusters).toBeCalledTimes(2);\n\t      expect(mockListClusters).toBeCalledWith({});\n\t      expect(mockListClusters).toBeCalledWith({ nextToken: 'next-token' });\n\t      expect(mockListServices).toBeCalled();\n\t      expect(mockListServices).toBeCalledTimes(3);\n\t      expect(mockListServices).toBeCalledWith({ cluster: 'mock-cluster-a' });\n\t      expect(mockListServices).toBeCalledWith({ cluster: 'mock-cluster-a', nextToken: 'next-token' });\n", "      expect(mockListServices).toBeCalledWith({ cluster: 'mock-cluster-b' });\n\t      expect(mockDescribeServices).toBeCalled();\n\t      expect(mockDescribeServices).toBeCalledTimes(2);\n\t      expect(mockDescribeServices).toBeCalledWith({\n\t        cluster: 'mock-cluster-a',\n\t        services: ['mock-service-a', 'mock-service-a-2']\n\t      });\n\t      expect(mockDescribeServices).toBeCalledWith({\n\t        cluster: 'mock-cluster-b',\n\t        services: ['mock-service-b']\n", "      });\n\t    });\n\t    it('Suggests termination if a service appears to not be used', async () => {\n\t      mockDescribeServices.mockResolvedValue({\n\t        services: [\n\t          {\n\t            serviceArn: 'mock-service',\n\t            serviceName: 'mock-service',\n\t            clusterArn: 'mock-cluster',\n\t            loadBalancers: [\n", "              {\n\t                targetGroupArn: 'mock-target-group'\n\t              }\n\t            ],\n\t            serviceRegistries: []\n\t          }\n\t        ]\n\t      });\n\t      mockDescribeTargetGroups.mockResolvedValue({\n\t        TargetGroups: [\n", "          {\n\t            LoadBalancerArns: ['mock-load-balancer']\n\t          }\n\t        ]\n\t      });\n\t      mockGetMetricData.mockResolvedValueOnce({\n\t        MetricDataResults: [\n\t          {\n\t            Id: AVG_CPU,\n\t            Values: [0.01, 0.02, 0.03]\n", "          },\n\t          {\n\t            Id: MAX_CPU,\n\t            Values: [0.01, 0.02, 0.03]\n\t          },\n\t          {\n\t            Id: AVG_MEMORY,\n\t            Values: [0.01, 0.02, 0.03]\n\t          },\n\t          {\n", "            Id: MAX_MEMORY,\n\t            Values: [0.01, 0.02, 0.03]\n\t          },\n\t          {\n\t            Id: ALB_REQUEST_COUNT,\n\t            Values: [0, 0, 0]\n\t          }\n\t        ]\n\t      });\n\t      mockListTasks.mockResolvedValueOnce({\n", "        taskArns: ['mock-task']\n\t      });\n\t      mockDescribeTasks.mockResolvedValueOnce({\n\t        tasks: [\n\t          {\n\t            cpu: 1024,\n\t            memory: 4\n\t          }\n\t        ]\n\t      });\n", "      mockDescribeContainerInstances.mockResolvedValueOnce({\n\t        containerInstances: [\n\t          {\n\t            registeredResources: [\n\t              {\n\t                name: 'CPU',\n\t                integerValue: '1024'\n\t              }\n\t            ],\n\t            attributes: [\n", "              {\n\t                name: 'ecs.instance-type',\n\t                value: 't3.medium'\n\t              }\n\t            ]\n\t          }\n\t        ]\n\t      });\n\t      mockGetInstanceCost.mockResolvedValueOnce(50);\n\t      const ecsUtil = new AwsEcsUtilization(true);\n", "      const provider = {\n\t        getCredentials: mockGetCredentials\n\t      } as unknown as AwsCredentialsProvider;\n\t      await ecsUtil.getRegionalUtilization(provider.getCredentials(), 'us-east-1', {\n\t          services: [\n\t            {\n\t              clusterArn: 'mock-cluster',\n\t              serviceArn: 'mock-service'\n\t            }\n\t          ]\n", "        }\n\t      );\n\t      expect(mockDescribeServices).toBeCalled();\n\t      expect(mockDescribeServices).toBeCalledTimes(1);\n\t      expect(mockDescribeServices).toBeCalledWith({\n\t        cluster: 'mock-cluster',\n\t        services: ['mock-service']\n\t      });\n\t      expect(mockDescribeTargetGroups).toBeCalled();\n\t      expect(mockDescribeTargetGroups).toBeCalledTimes(1);\n", "      expect(mockDescribeTargetGroups).toBeCalledWith({\n\t        TargetGroupArns: ['mock-target-group']\n\t      });\n\t      expect(mockGetMetricData).toBeCalled();\n\t      expect(ecsUtil.utilization).toHaveProperty('mock-service', {\n\t        data: {\n\t          resourceId: 'mock-service',\n\t          region: 'us-east-1',\n\t          hourlyCost: (50 / 30) / 24,\n\t          monthlyCost: 50\n", "        },\n\t        scenarios: {\n\t          unused: {\n\t            value: 'true',\n\t            delete: {\n\t              action: 'deleteService',\n\t              isActionable: true,\n\t              reason: 'This ECS service appears to be unused based on its CPU utilizaiton, Memory utilizaiton, and network traffic.',\n\t              monthlySavings: 50\n\t            }\n", "          }\n\t        }\n\t      });\n\t    });\n\t    it('Suggests scale down if a fargate service appears to be used but underutilized', async () => {\n\t      mockDescribeServices.mockResolvedValue({\n\t        services: [\n\t          {\n\t            serviceArn: 'mock-service',\n\t            serviceName: 'mock-service',\n", "            clusterArn: 'mock-cluster',\n\t            launchType: 'FARGATE',\n\t            loadBalancers: [],\n\t            serviceRegistries: [\n\t              {\n\t                registryArn: 'mock-registry'\n\t              }\n\t            ]\n\t          }\n\t        ]\n", "      });\n\t      mockGetApis.mockResolvedValue({\n\t        Items: [\n\t          {\n\t            ApiId: 'mock-api'\n\t          }\n\t        ]\n\t      });\n\t      mockGetIntegrations.mockResolvedValue({\n\t        Items: [\n", "          {\n\t            IntegrationUri: 'mock-registry'\n\t          }\n\t        ]\n\t      });\n\t      mockGetMetricData.mockResolvedValueOnce({\n\t        MetricDataResults: [\n\t          {\n\t            Id: AVG_CPU,\n\t            Values: [0.10, 0.12, 0.13]\n", "          },\n\t          {\n\t            Id: MAX_CPU,\n\t            Values: [0.11, 0.22, 0.33]\n\t          },\n\t          {\n\t            Id: AVG_MEMORY,\n\t            Values: [0.10, 0.12, 0.13]\n\t          },\n\t          {\n", "            Id: MAX_MEMORY,\n\t            Values: [0.11, 0.22, 0.33]\n\t          },\n\t          {\n\t            Id: APIG_REQUEST_COUNT,\n\t            Values: [10, 20, 30]\n\t          }\n\t        ]\n\t      });\n\t      mockListTasks.mockResolvedValueOnce({\n", "        taskArns: ['mock-task']\n\t      });\n\t      mockDescribeTasks.mockResolvedValueOnce({\n\t        tasks: [\n\t          {\n\t            cpu: 1024,\n\t            memory: 4,\n\t            attributes: [{\n\t              name: 'ecs.cpu-architecture',\n\t              value: 'x86_64'\n", "            }]\n\t          }\n\t        ]\n\t      });\n\t      const ecsUtil = new AwsEcsUtilization(true);\n\t      const provider = {\n\t        getCredentials: mockGetCredentials\n\t      } as unknown as AwsCredentialsProvider;\n\t      await ecsUtil.getRegionalUtilization(provider.getCredentials(), 'us-east-1', {\n\t          services: [\n", "            {\n\t              clusterArn: 'mock-cluster',\n\t              serviceArn: 'mock-service'\n\t            }\n\t          ]\n\t        }\n\t      );\n\t      expect(mockDescribeServices).toBeCalled();\n\t      expect(mockDescribeServices).toBeCalledTimes(1);\n\t      expect(mockDescribeServices).toBeCalledWith({\n", "        cluster: 'mock-cluster',\n\t        services: ['mock-service']\n\t      });\n\t      expect(mockGetApis).toBeCalled();\n\t      expect(mockGetApis).toBeCalledTimes(1);\n\t      expect(mockGetIntegrations).toBeCalled();\n\t      expect(mockGetIntegrations).toBeCalledTimes(1);\n\t      expect(mockGetIntegrations).toBeCalledWith({\n\t        ApiId: 'mock-api'\n\t      });\n", "      expect(mockGetMetricData).toBeCalled();\n\t      const monthlyCost = 29.158101562500004;\n\t      expect(ecsUtil.utilization).toHaveProperty('mock-service', {\n\t        data: {\n\t          resourceId: 'mock-service',\n\t          region: 'us-east-1',\n\t          hourlyCost: (monthlyCost / 30) / 24,\n\t          monthlyCost\n\t        },\n\t        scenarios: {\n", "          overAllocated: {\n\t            value: 'overAllocated',\n\t            scaleDown: {\n\t              action: 'scaleDownFargateService',\n\t              isActionable: false,\n\t              reason: 'This ECS service appears to be over allocated based on its CPU, Memory, and network utilization. We suggest scaling the CPU down to 512 and the Memory to 2048 MiB.',\n\t              monthlySavings: 8.184501562500003\n\t            }\n\t          }\n\t        }\n", "      });\n\t    });\n\t    it('Suggests scale down if an Ec2 services appears to be used but underutilized', async () => {\n\t      mockDescribeServices.mockResolvedValue({\n\t        services: [\n\t          {\n\t            serviceArn: 'mock-service',\n\t            serviceName: 'mock-service',\n\t            clusterArn: 'mock-cluster',\n\t            loadBalancers: [],\n", "            serviceRegistries: [\n\t              {\n\t                registryArn: 'mock-registry'\n\t              }\n\t            ]\n\t          }\n\t        ]\n\t      });\n\t      mockGetApis.mockResolvedValue({\n\t        Items: [\n", "          {\n\t            ApiId: 'mock-api'\n\t          }\n\t        ]\n\t      });\n\t      mockGetIntegrations.mockResolvedValue({\n\t        Items: [\n\t          {\n\t            IntegrationUri: 'mock-registry'\n\t          }\n", "        ]\n\t      });\n\t      mockGetMetricData.mockResolvedValueOnce({\n\t        MetricDataResults: [\n\t          {\n\t            Id: AVG_CPU,\n\t            Values: [0.01, 0.02, 0.03, 0.10, 0.15]\n\t          },\n\t          {\n\t            Id: MAX_CPU,\n", "            Values: [0.01, 0.02, 0.03, 0.10, 0.15]\n\t          },\n\t          {\n\t            Id: AVG_MEMORY,\n\t            Values: [0.01, 0.02, 0.03, 0.10, 0.15]\n\t          },\n\t          {\n\t            Id: MAX_MEMORY,\n\t            Values: [0.01, 0.02, 0.03, 0.10, 0.15]\n\t          },\n", "          {\n\t            Id: APIG_REQUEST_COUNT,\n\t            Values: [10, 20, 30, 40, 50]\n\t          }\n\t        ]\n\t      });\n\t      mockListTasks.mockResolvedValueOnce({\n\t        taskArns: ['mock-task']\n\t      });\n\t      mockDescribeTasks.mockResolvedValueOnce({\n", "        tasks: [\n\t          {\n\t            cpu: '0',\n\t            memory: '4096'\n\t          }\n\t        ]\n\t      });\n\t      mockDescribeContainerInstances.mockResolvedValueOnce({\n\t        containerInstances: [\n\t          {\n", "            registeredResources: [\n\t              {\n\t                name: 'CPU',\n\t                integerValue: '1024'\n\t              }\n\t            ],\n\t            attributes: [\n\t              {\n\t                name: 'ecs.instance-type',\n\t                value: 't3.medium'\n", "              }\n\t            ]\n\t          }\n\t        ]\n\t      });\n\t      mockDescribeInstanceTypes.mockResolvedValueOnce({\n\t        InstanceTypes: [\n\t          t2Nano,\n\t          t2Micro\n\t        ]\n", "      });\n\t      mockGetInstanceCost.mockResolvedValueOnce(50);\n\t      mockCache.getOrElse.mockImplementationOnce((_key, refreshFunction) => {\n\t        return refreshFunction();\n\t      });\n\t      const ecsUtil = new AwsEcsUtilization(true);\n\t      const provider = {\n\t        getCredentials: mockGetCredentials\n\t      } as unknown as AwsCredentialsProvider;\n\t      await ecsUtil.getRegionalUtilization(provider, 'us-east-1', {\n", "          services: [\n\t            {\n\t              clusterArn: 'mock-cluster',\n\t              serviceArn: 'mock-service'\n\t            }\n\t          ]\n\t        }\n\t      );\n\t      expect(mockDescribeServices).toBeCalled();\n\t      expect(mockDescribeServices).toBeCalledTimes(1);\n", "      expect(mockDescribeServices).toBeCalledWith({\n\t        cluster: 'mock-cluster',\n\t        services: ['mock-service']\n\t      });\n\t      expect(mockGetApis).toBeCalled();\n\t      expect(mockGetApis).toBeCalledTimes(1);\n\t      expect(mockGetIntegrations).toBeCalled();\n\t      expect(mockGetIntegrations).toBeCalledTimes(1);\n\t      expect(mockGetIntegrations).toBeCalledWith({\n\t        ApiId: 'mock-api'\n", "      });\n\t      expect(mockGetMetricData).toBeCalled();\n\t      expect(ecsUtil.utilization).toHaveProperty('mock-service', {\n\t        data: {},\n\t        scenarios: {\n\t          overAllocated: {\n\t            value: 'overAllocated',\n\t            scaleDown: {\n\t              action: 'scaleDownEc2Service',\n\t              reason: 'The EC2 instances used in this Service\\'s cluster appears to be over allocated based on its CPU and Memory utilization.  We suggest scaling down to a t2.micro.'\n", "            }\n\t          }\n\t        }\n\t      });\n\t    });\n\t  });\n\t  it('deleteService', async () => {\n\t    const ecsUtil = new AwsEcsUtilization(true);\n\t    const provider = {\n\t      getCredentials: mockGetCredentials\n", "    } as unknown as AwsCredentialsProvider;\n\t    await ecsUtil.deleteService(provider, 'mock-cluster', 'mock-service', 'us-mock-1');\n\t    expect(mockDeleteService).toBeCalled();\n\t    expect(mockDeleteService).toBeCalledWith({\n\t      service: 'mock-service',\n\t      cluster: 'mock-cluster'\n\t    });\n\t  });\n\t  it('scaleDownFargateService', async () => {\n\t    mockDescribeServices.mockResolvedValue({\n", "      services: [\n\t        {\n\t          serviceArn: 'mock-service',\n\t          serviceName: 'mock-service',\n\t          clusterArn: 'mock-cluster',\n\t          taskDefinition: 'mock-task-def',\n\t          launchType: 'FARGATE',\n\t          loadBalancers: [],\n\t          serviceRegistries: [\n\t            {\n", "              registryArn: 'mock-registry'\n\t            }\n\t          ]\n\t        }\n\t      ]\n\t    });\n\t    mockDescribeTaskDefinition.mockResolvedValue(fargateTaskDef)\n\t    mockRegisterTaskDefinition.mockResolvedValue({\n\t      taskDefinition: {\n\t        taskDefinitionArn: 'mock-task-def:2'\n", "      }\n\t    });\n\t    const ecsUtil = new AwsEcsUtilization(true);\n\t    const provider = {\n\t      getCredentials: mockGetCredentials\n\t    } as unknown as AwsCredentialsProvider;\n\t    await ecsUtil.scaleDownFargateService(provider, 'mock-cluster', 'mock-service', 'us-mock-1', 256, 1024);\n\t    expect(mockDescribeServices).toBeCalled();\n\t    expect(mockDescribeServices).toBeCalledWith({\n\t      services: ['mock-service'],\n", "      cluster: 'mock-cluster'\n\t    });\n\t    expect(mockDescribeTaskDefinition).toBeCalled();\n\t    expect(mockDescribeTaskDefinition).toBeCalledWith({\n\t      taskDefinition: 'mock-task-def',\n\t      include: ['TAGS']\n\t    });\n\t    expect(mockRegisterTaskDefinition).toBeCalled();\n\t    expect(mockRegisterTaskDefinition).toBeCalledWith({\n\t      cpu: '256',\n", "      memory: '1024',\n\t      containerDefinitions: fargateTaskDef.taskDefinition.containerDefinitions,\n\t      family: fargateTaskDef.taskDefinition.family,\n\t      executionRoleArn: fargateTaskDef.taskDefinition.executionRoleArn,\n\t      networkMode: fargateTaskDef.taskDefinition.networkMode,\n\t      placementConstraints: fargateTaskDef.taskDefinition.placementConstraints,\n\t      requiresCompatibilities: fargateTaskDef.taskDefinition.requiresCompatibilities,\n\t      taskRoleArn: fargateTaskDef.taskDefinition.taskRoleArn,\n\t      volumes: fargateTaskDef.taskDefinition.volumes,\n\t      tags: fargateTaskDef.tags\n", "    });\n\t    expect(mockUpdateService).toBeCalled();\n\t    expect(mockUpdateService).toBeCalledWith({\n\t      cluster: 'mock-cluster',\n\t      service: 'mock-service',\n\t      taskDefinition: 'mock-task-def:2',\n\t      forceNewDeployment: true\n\t    });\n\t  });\n\t});"]}
{"filename": "test/service-utilizations/aws-nat-gateway-utilization.test.ts", "chunked_list": ["const mockSts = jest.fn();\n\tconst mockEc2 = jest.fn();\n\tconst mockCloudWatch = jest.fn();\n\tconst mockAccount = jest.fn();\n\tconst mockCloudFormation = jest.fn();\n\tconst mockGetCallerIdentity = jest.fn();\n\tconst mockDescribeNatGateways = jest.fn();\n\tconst mockDeleteNatGateway = jest.fn();\n\tconst mockGetMetricData = jest.fn();\n\tconst mockGetCredentials = jest.fn();\n", "const mockListRegions = jest.fn();\n\tconst mockDescribeStackResources = jest.fn();\n\tjest.mock('@aws-sdk/client-sts', () => {\n\t  return {\n\t    STS: mockSts\n\t  }\n\t});\n\tjest.mock('@aws-sdk/client-ec2', () => {\n\t  const original = jest.requireActual('@aws-sdk/client-ec2');\n\t  return {\n", "    ...original,\n\t    EC2: mockEc2\n\t  };\n\t});\n\tjest.mock('@aws-sdk/client-cloudwatch', () => {\n\t  const original = jest.requireActual('@aws-sdk/client-cloudwatch');\n\t  const { MetricDataQuery, MetricDataResult } = original;\n\t  return {\n\t    CloudWatch: mockCloudWatch,\n\t    MetricDataQuery,\n", "    MetricDataResult\n\t  };\n\t});\n\tjest.mock('@aws-sdk/client-account', () => {\n\t  const original = jest.requireActual('@aws-sdk/client-account');\n\t  return {\n\t    ...original,\n\t    Account: mockAccount\n\t  };\n\t});\n", "jest.mock('@aws-sdk/client-cloudformation', () => {\n\t  return {\n\t    CloudFormation: mockCloudFormation\n\t  }\n\t});\n\timport { EC2 } from \"@aws-sdk/client-ec2\";\n\timport { AwsCredentialsProvider } from \"@tinystacks/ops-aws-core-widgets\";\n\timport { AwsNatGatewayUtilization } from \"../../src/service-utilizations/aws-nat-gateway-utilization\";\n\timport { Arns } from \"../../src/types/constants\";\n\tdescribe('AwsNatGatewayUtilization', () => {\n", "  beforeEach(() => {\n\t    mockSts.mockReturnValue({\n\t      getCallerIdentity: mockGetCallerIdentity\n\t    });\n\t    mockGetCallerIdentity.mockResolvedValue({\n\t      Account: '123456789'\n\t    });\n\t    mockEc2.mockReturnValue({\n\t      describeNatGateways: mockDescribeNatGateways,\n\t      deleteNatGateway: mockDeleteNatGateway\n", "    });\n\t    mockCloudWatch.mockReturnValue({\n\t      getMetricData: mockGetMetricData\n\t    });\n\t    mockAccount.mockReturnValue({\n\t      listRegions: mockListRegions\n\t    });\n\t    mockCloudFormation.mockReturnValue({\n\t      describeStackResources: mockDescribeStackResources\n\t    });\n", "  });\n\t  afterEach(() => {\n\t    // for mocks\n\t    jest.resetAllMocks();\n\t    // for spies\n\t    jest.restoreAllMocks();\n\t  });\n\t  describe('getUtilization', () => {\n\t    beforeEach(() => {\n\t      mockListRegions.mockResolvedValue({\n", "        Regions: [{\n\t          RegionName: 'us-east-1'\n\t        }]\n\t      });\n\t      mockDescribeStackResources.mockResolvedValue({\n\t        StackResources: [{\n\t          StackId: 'mock-stack'\n\t        }]\n\t      });\n\t    });\n", "    afterEach(() => {\n\t      // for mocks\n\t      jest.resetAllMocks();\n\t      // for spies\n\t      jest.restoreAllMocks();\n\t    });\n\t    it('suggests deletion if number of active connections is 0', async () => {\n\t      mockDescribeNatGateways.mockResolvedValueOnce({\n\t        NatGateways: [{\n\t          NatGatewayId: 'mock-nat-gateway',\n", "          SubnetId: 'mock-subnet',\n\t          VpcId: 'mock-vpc'\n\t        }]\n\t      });\n\t      mockGetMetricData.mockResolvedValueOnce({\n\t        MetricDataResults: [\n\t          {\n\t            Id: 'activeConnectionCount',\n\t            Values: [0]\n\t          },\n", "          {\n\t            Id: 'bytesInFromDestination',\n\t            Values: [1]\n\t          },\n\t          {\n\t            Id: 'bytesInFromSource',\n\t            Values: [1]\n\t          },\n\t          {\n\t            Id: 'bytesOutToDestination',\n", "            Values: [1]\n\t          },\n\t          {\n\t            Id: 'bytesOutToSource',\n\t            Values: [1]\n\t          }\n\t        ]\n\t      });\n\t      const natGatewayUtilization = new AwsNatGatewayUtilization();\n\t      const provider = {\n", "        getCredentials: mockGetCredentials\n\t      } as unknown as AwsCredentialsProvider;\n\t      await natGatewayUtilization.getUtilization(provider);\n\t      expect(mockDescribeNatGateways).toBeCalled();\n\t      expect(mockDescribeNatGateways).toBeCalledWith({});\n\t      expect(mockGetMetricData).toBeCalled();\n\t      const natGatewayArn = Arns.NatGateway('us-east-1', '123456789', 'mock-nat-gateway');\n\t      expect(natGatewayUtilization.utilization).toHaveProperty(natGatewayArn, {\n\t        scenarios: {\n\t          activeConnectionCount: {\n", "            value: '0',\n\t            delete: {\n\t              action: 'deleteNatGateway',\n\t              reason: 'This NAT Gateway has had 0 active connections over the past week. It appears to be unused.'\n\t            }\n\t          }\n\t        },\n\t        data: {\n\t          resourceId: 'mock-nat-gateway',\n\t          region: 'us-east-1',\n", "          stack: 'mock-stack'\n\t        }\n\t      });\n\t    });\n\t    it('suggests deletion if total throughput is 0', async () => {\n\t      mockDescribeNatGateways.mockResolvedValueOnce({\n\t        NatGateways: [{\n\t          NatGatewayId: 'mock-nat-gateway',\n\t          SubnetId: 'mock-subnet',\n\t          VpcId: 'mock-vpc'\n", "        }]\n\t      });\n\t      mockGetMetricData.mockResolvedValueOnce({\n\t        MetricDataResults: [\n\t          {\n\t            Id: 'activeConnectionCount',\n\t            Values: [3]\n\t          },\n\t          {\n\t            Id: 'bytesInFromDestination',\n", "            Values: [0]\n\t          },\n\t          {\n\t            Id: 'bytesInFromSource',\n\t            Values: [0]\n\t          },\n\t          {\n\t            Id: 'bytesOutToDestination',\n\t            Values: [0]\n\t          },\n", "          {\n\t            Id: 'bytesOutToSource',\n\t            Values: [0]\n\t          }\n\t        ]\n\t      });\n\t      const natGatewayUtilization = new AwsNatGatewayUtilization();\n\t      const provider = {\n\t        getCredentials: mockGetCredentials\n\t      } as unknown as AwsCredentialsProvider;\n", "      await natGatewayUtilization.getUtilization(provider);\n\t      expect(mockDescribeNatGateways).toBeCalled();\n\t      expect(mockDescribeNatGateways).toBeCalledWith({});\n\t      expect(mockGetMetricData).toBeCalled();\n\t      const natGatewayArn = Arns.NatGateway('us-east-1', '123456789', 'mock-nat-gateway');\n\t      expect(natGatewayUtilization.utilization).toHaveProperty(natGatewayArn, {\n\t        scenarios: {\n\t          totalThroughput: {\n\t            value: '0',\n\t            delete: {\n", "              action: 'deleteNatGateway',\n\t              reason: 'This NAT Gateway has had 0 total throughput over the past week. It appears to be unused.'\n\t            }\n\t          }\n\t        },\n\t        data: {\n\t          resourceId: 'mock-nat-gateway',\n\t          region: 'us-east-1',\n\t          stack: 'mock-stack'\n\t        }\n", "      });\n\t    });\n\t  });\n\t  describe('actions', () => {\n\t    describe('deleteNatGateway', () => {\n\t      it('sets retention policy', async () => {\n\t        mockDeleteNatGateway.mockResolvedValueOnce({});\n\t        const natGatewayUtilization = new AwsNatGatewayUtilization();\n\t        const ec2Client = new EC2({});\n\t        await natGatewayUtilization.deleteNatGateway(ec2Client, 'mock-nat-gateway');\n", "        expect(mockDeleteNatGateway).toBeCalled();\n\t        expect(mockDeleteNatGateway).toBeCalledWith({\n\t          NatGatewayId: 'mock-nat-gateway'\n\t        });\n\t      });\n\t    });\n\t  });\n\t});\n"]}
{"filename": "test/service-utilizations/aws-ec2-instance-utilization.test.ts", "chunked_list": ["import { MockCache } from \"../mocks/MockCache\";\n\tjest.useFakeTimers();\n\tjest.setSystemTime(new Date('2023-04-14T00:00:00.000Z'));\n\tconst mockGetCredentials = jest.fn();\n\tconst mockEc2 = jest.fn();\n\tconst mockDescribeInstances = jest.fn();\n\tconst mockDescribeInstanceTypes = jest.fn();\n\tconst mockAutoScaling = jest.fn();\n\tconst mockDescribeAutoScalingInstances = jest.fn();\n\tconst mockCloudWatch = jest.fn();\n", "const mockGetMetricData = jest.fn();\n\tconst mockGetInstanceCost = jest.fn();\n\tconst mockTerminateInstances = jest.fn();\n\tconst mockModifyInstanceAttribute = jest.fn();\n\tconst mockCache = new MockCache();\n\tjest.mock('cached', () => () => mockCache);\n\tjest.mock('@aws-sdk/client-ec2', () => {\n\t  const original = jest.requireActual('@aws-sdk/client-ec2');\n\t  const { DescribeInstanceTypesCommandOutput, Instance, InstanceTypeInfo, _InstanceType } = original;\n\t  return {\n", "    EC2: mockEc2,\n\t    DescribeInstanceTypesCommandOutput,\n\t    Instance,\n\t    InstanceTypeInfo,\n\t    _InstanceType\n\t  };\n\t});\n\tjest.mock('@aws-sdk/client-auto-scaling', () => ({\n\t    AutoScaling: mockAutoScaling\n\t}));\n", "jest.mock('@aws-sdk/client-cloudwatch', () => {\n\t  const original = jest.requireActual('@aws-sdk/client-cloudwatch');\n\t  const { MetricDataQuery, MetricDataResult } = original;\n\t  return {\n\t    CloudWatch: mockCloudWatch,\n\t    MetricDataQuery,\n\t    MetricDataResult\n\t  };\n\t});\n\tjest.mock('../../src/utils/ec2-utils.js', () => {\n", "  const original = jest.requireActual('../../src/utils/ec2-utils.js');\n\t  return {\n\t    ...original,\n\t    getInstanceCost: mockGetInstanceCost\n\t  }\n\t});\n\tconst mockInstance1 = {\n\t  InstanceId: 'mock-instance-1',\n\t  InstanceType: 't2.micro'\n\t};\n", "const mockInstance2 = {\n\t  InstanceId: 'mock-instance-2',\n\t  InstanceType: 'm5.medium'\n\t};\n\timport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\n\timport { AwsEc2InstanceUtilization } from '../../src/service-utilizations/aws-ec2-instance-utilization';\n\timport t2Micro from '../mocks/T2Micro.json';\n\timport t2Nano from '../mocks/T2Nano.json';\n\timport { AVG_CPU, AVG_NETWORK_BYTES_IN, AVG_NETWORK_BYTES_OUT, DISK_READ_OPS, DISK_WRITE_OPS, MAX_CPU, MAX_NETWORK_BYTES_IN, MAX_NETWORK_BYTES_OUT } from \"../../src/types/constants\";\n\tdescribe('AwsEc2InstanceUtilization', () => {\n", "  beforeEach(() => {\n\t    mockEc2.mockReturnValue({\n\t      describeInstances: mockDescribeInstances,\n\t      describeInstanceTypes: mockDescribeInstanceTypes,\n\t      terminateInstances: mockTerminateInstances,\n\t      modifyInstanceAttribute: mockModifyInstanceAttribute\n\t    });\n\t    mockAutoScaling.mockReturnValue({\n\t      describeAutoScalingInstances: mockDescribeAutoScalingInstances\n\t    });\n", "    mockCloudWatch.mockReturnValue({\n\t      getMetricData: mockGetMetricData\n\t    });\n\t  });\n\t  afterEach(() => {\n\t    // for mocks\n\t    jest.resetAllMocks();\n\t    // for spies\n\t    jest.restoreAllMocks();\n\t    mockCache.reset();\n", "    mockCache.restore();\n\t  });\n\t  describe('getRegionalUtilization', () => {\n\t    it('Calls describeInstances with instanceIds if provided', async () => {\n\t      mockDescribeInstances.mockResolvedValueOnce({\n\t        Reservations: [], // Return empty to short circuit test\n\t        NextToken: 'nextToken'\n\t      });\n\t      mockDescribeInstances.mockResolvedValueOnce({\n\t        Reservations: []\n", "      });\n\t      mockDescribeInstanceTypes.mockResolvedValueOnce({});\n\t      const ec2Util = new AwsEc2InstanceUtilization(true);\n\t      const provider = {\n\t        getCredentials: mockGetCredentials\n\t      } as unknown as AwsCredentialsProvider;\n\t      await ec2Util.getRegionalUtilization(provider.getCredentials(), 'us-east-1', { instanceIds: ['mock-instance-1', 'mock-instance-2'] });\n\t      expect(mockDescribeInstances).toBeCalled();\n\t      expect(mockDescribeInstances).toBeCalledTimes(2);\n\t      expect(mockDescribeInstances).toBeCalledWith({\n", "        InstanceIds: ['mock-instance-1', 'mock-instance-2']\n\t      });\n\t      expect(mockDescribeInstances).toBeCalledWith({\n\t        InstanceIds: ['mock-instance-1', 'mock-instance-2'],\n\t        NextToken: 'nextToken'\n\t      });\n\t    });\n\t    it('Filters out instances that are part of an ASG', async () => {\n\t      mockDescribeInstances.mockResolvedValueOnce({\n\t        Reservations: [\n", "          {\n\t            Instances: [mockInstance1]\n\t          },\n\t          {\n\t            Instances: [mockInstance2]\n\t          }\n\t        ]\n\t      });\n\t      mockDescribeAutoScalingInstances.mockResolvedValueOnce({\n\t        AutoScalingInstances: [mockInstance1, mockInstance2] // return both to short circuit test\n", "      });\n\t      const ec2Util = new AwsEc2InstanceUtilization(true);\n\t      const provider = {\n\t        getCredentials: mockGetCredentials\n\t      } as unknown as AwsCredentialsProvider;\n\t      await ec2Util.getRegionalUtilization(provider.getCredentials(), 'us-east-1');\n\t      expect(mockDescribeInstances).toBeCalled();\n\t      expect(mockDescribeInstances).toBeCalledWith({});\n\t      expect(mockDescribeAutoScalingInstances).toBeCalled();\n\t      expect(mockDescribeAutoScalingInstances).toBeCalledWith({\n", "        InstanceIds: ['mock-instance-1', 'mock-instance-2']\n\t      });\n\t      expect(mockDescribeInstanceTypes).not.toBeCalled();\n\t    });\n\t    it('Suggests termination if an instance appears to not be used', async () => {\n\t      mockDescribeInstances.mockResolvedValueOnce({\n\t        Reservations: [\n\t          {\n\t            Instances: [mockInstance1]\n\t          }\n", "        ]\n\t      });\n\t      mockDescribeAutoScalingInstances.mockResolvedValueOnce({\n\t        AutoScalingInstances: []\n\t      });\n\t      mockDescribeInstanceTypes.mockResolvedValueOnce({\n\t        InstanceTypes: [\n\t          t2Micro\n\t        ]\n\t      });\n", "      mockGetMetricData.mockResolvedValueOnce({\n\t        MetricDataResults: [\n\t          {\n\t            Id: AVG_CPU,\n\t            Values: [0.01, 0.02, 0.03]\n\t          },\n\t          {\n\t            Id: MAX_CPU,\n\t            Values: [0.01, 0.02, 0.03]\n\t          },\n", "          {\n\t            Id: DISK_READ_OPS,\n\t            Values: [0, 0, 0]\n\t          },\n\t          {\n\t            Id: DISK_WRITE_OPS,\n\t            Values: [0, 0, 0]\n\t          },\n\t          {\n\t            Id: AVG_NETWORK_BYTES_IN,\n", "            Values: [1500, 1750, 2250]\n\t          },\n\t          {\n\t            Id: AVG_NETWORK_BYTES_OUT,\n\t            Values: [1250, 1500, 1750]\n\t          }\n\t        ]\n\t      });\n\t      mockGetInstanceCost.mockResolvedValueOnce(50);\n\t      const ec2Util = new AwsEc2InstanceUtilization(true);\n", "      const provider = {\n\t        getCredentials: mockGetCredentials\n\t      } as unknown as AwsCredentialsProvider;\n\t      try { \n\t        await ec2Util.getRegionalUtilization(provider.getCredentials(), 'us-east-1');\n\t      } catch (error) {\n\t        console.error(error);\n\t      }\n\t      expect(mockDescribeInstances).toBeCalled();\n\t      expect(mockDescribeInstances).toBeCalledWith({});\n", "      expect(mockDescribeAutoScalingInstances).toBeCalled();\n\t      expect(mockDescribeAutoScalingInstances).toBeCalledWith({\n\t        InstanceIds: ['mock-instance-1']\n\t      });\n\t      expect(mockDescribeInstanceTypes).toBeCalled();\n\t      expect(mockDescribeInstanceTypes).toBeCalledTimes(1);\n\t      expect(mockDescribeInstanceTypes).toBeCalledWith({\n\t        InstanceTypes: ['t2.micro']\n\t      });\n\t      expect(mockGetMetricData).toBeCalled();\n", "      expect(ec2Util.utilization).toHaveProperty('arn:aws:ec2:us-east-1:undefined:instance/mock-instance-1', {\n\t        data: {\n\t          resourceId: 'mock-instance-1',\n\t          region: 'us-east-1',\n\t          hourlyCost: (50 / 30) / 24,\n\t          monthlyCost: 50,\n\t          maxMonthlySavings: 50\n\t        },\n\t        scenarios: {\n\t          unused: {\n", "            value: 'true',\n\t            delete: {\n\t              action: 'terminateInstance',\n\t              isActionable: true,\n\t              reason: 'This EC2 instance appears to be unused based on its CPU utilization, disk IOPS, and network traffic.',\n\t              monthlySavings: 50\n\t            }\n\t          }\n\t        }\n\t      });\n", "    });\n\t    it('Suggests scale down if an instance appears to be used but underutilized', async () => {\n\t      mockDescribeInstances.mockResolvedValueOnce({\n\t        Reservations: [\n\t          {\n\t            Instances: [mockInstance1]\n\t          }\n\t        ]\n\t      });\n\t      mockDescribeAutoScalingInstances.mockResolvedValueOnce({\n", "        AutoScalingInstances: []\n\t      });\n\t      mockDescribeInstanceTypes.mockResolvedValueOnce({\n\t        InstanceTypes: [\n\t          t2Micro\n\t        ]\n\t      });\n\t      mockDescribeInstanceTypes.mockResolvedValueOnce({\n\t        InstanceTypes: [\n\t          t2Nano,\n", "          t2Micro\n\t        ]\n\t      });\n\t      mockGetMetricData.mockResolvedValueOnce({\n\t        MetricDataResults: [\n\t          {\n\t            Id: AVG_CPU,\n\t            Values: [0.01, 0.02, 0.03, 0.10, 0.15]\n\t          },\n\t          {\n", "            Id: MAX_CPU,\n\t            Values: [0.01, 0.02, 0.03, 0.10, 0.15]\n\t          },\n\t          {\n\t            Id: DISK_READ_OPS,\n\t            Values: [0, 0, 0, 1, 2]\n\t          },\n\t          {\n\t            Id: DISK_WRITE_OPS,\n\t            Values: [0, 0, 0, 1, 2]\n", "          },\n\t          {\n\t            Id: AVG_NETWORK_BYTES_IN,\n\t            Values: [1500, 1750, 2250, (1.45 * Math.pow(10, 6)), (1.6 * Math.pow(10, 6))]\n\t          },\n\t          {\n\t            Id: AVG_NETWORK_BYTES_OUT,\n\t            Values: [1250, 1500, 1750, (4.60 * Math.pow(10, 6)), (5.02 * Math.pow(10, 6))]\n\t          },\n\t          {\n", "            Id: MAX_NETWORK_BYTES_IN,\n\t            Values: [1500, 1750, 2250, (1.45 * Math.pow(10, 6)), (1.6 * Math.pow(10, 6))]\n\t          },\n\t          {\n\t            Id: MAX_NETWORK_BYTES_OUT,\n\t            Values: [1250, 1500, 1750, (4.60 * Math.pow(10, 6)), (5.02 * Math.pow(10, 6))]\n\t          }\n\t        ]\n\t      });\n\t      mockGetInstanceCost.mockResolvedValueOnce(50);\n", "      mockGetInstanceCost.mockResolvedValueOnce(30);\n\t      mockCache.getOrElse.mockImplementationOnce((_key, refreshFunction) => {\n\t        return refreshFunction();\n\t      });\n\t      const ec2Util = new AwsEc2InstanceUtilization(true);\n\t      const provider = {\n\t        getCredentials: mockGetCredentials\n\t      } as unknown as AwsCredentialsProvider;\n\t      await ec2Util.getRegionalUtilization(provider, 'us-east-1');\n\t      expect(mockDescribeInstances).toBeCalled();\n", "      expect(mockDescribeInstances).toBeCalledWith({});\n\t      expect(mockDescribeAutoScalingInstances).toBeCalled();\n\t      expect(mockDescribeAutoScalingInstances).toBeCalledWith({\n\t        InstanceIds: ['mock-instance-1']\n\t      });\n\t      expect(mockDescribeInstanceTypes).toBeCalled();\n\t      expect(mockDescribeInstanceTypes).toBeCalledTimes(2);\n\t      expect(mockDescribeInstanceTypes).toBeCalledWith({\n\t        InstanceTypes: [\n\t          't2.2xlarge',\n", "          't2.large',\n\t          't2.medium',\n\t          't2.micro',\n\t          't2.nano',\n\t          't2.small',\n\t          't2.xlarge'\n\t        ]\n\t      });\n\t      expect(mockGetMetricData).toBeCalled();\n\t      expect(ec2Util.utilization).toHaveProperty('arn:aws:ec2:us-east-1:undefined:instance/mock-instance-1', {\n", "        data: {\n\t          resourceId: 'mock-instance-1',\n\t          region: 'us-east-1',\n\t          hourlyCost: (50 / 30) / 24,\n\t          monthlyCost: 50,\n\t          maxMonthlySavings: 20\n\t        },\n\t        scenarios: {\n\t          overAllocated: {\n\t            value: 'overAllocated',\n", "            scaleDown: {\n\t              action: 'scaleDownInstance',\n\t              isActionable: false,\n\t              reason: `This EC2 instance appears to be over allocated based on its CPU and network utilization.  We suggest scaling down to a t2.nano`,\n\t              monthlySavings: 20\n\t            }\n\t          }\n\t        }\n\t      });\n\t    });\n", "  });\n\t  describe('doAction', () => {\n\t    describe('terminateInstance', () => {\n\t      it('terminates instance', async () => {\n\t        mockTerminateInstances.mockResolvedValueOnce({});\n\t        const ec2InstanceUtilization = new AwsEc2InstanceUtilization();\n\t        const provider = {\n\t          getCredentials: mockGetCredentials\n\t        } as unknown as AwsCredentialsProvider;\n\t        await ec2InstanceUtilization.doAction(provider, 'terminateInstance', 'arn:aws:ec2:us-east-1:undefined:instance/mock-instance-1', 'us-east-1');\n", "        expect(mockTerminateInstances).toBeCalled();\n\t        expect(mockTerminateInstances).toBeCalledWith({\n\t          InstanceIds: [ 'mock-instance-1' ],\n\t        });\n\t      });\n\t    });\n\t    describe('scaleDownInstance', () => {\n\t      it('scales down instance', async () => {\n\t        mockModifyInstanceAttribute.mockResolvedValueOnce({});\n\t        const ec2InstanceUtilization = new AwsEc2InstanceUtilization();\n", "        const provider = {\n\t          getCredentials: mockGetCredentials\n\t        } as unknown as AwsCredentialsProvider;\n\t        await ec2InstanceUtilization.scaleDownInstance(provider, 'mock-instance-1', 'us-east-1', 't2-nano');\n\t        expect(mockModifyInstanceAttribute).toBeCalled();\n\t        expect(mockModifyInstanceAttribute).toBeCalledWith({\n\t          InstanceId: 'mock-instance-1',\n\t          InstanceType: {\n\t            Value: 't2-nano'\n\t          }\n", "        });\n\t      })\n\t    });\n\t  });\n\t});"]}
{"filename": "src/ops-types.ts", "chunked_list": ["import { Provider, Widget } from '@tinystacks/ops-model';\n\t/**\n\t * @example\n\t * ```yaml\n\t * AwsUtilizationRecommendations:\n\t    type: AwsUtilizationRecommendations\n\t    displayName: TinyStacks Recommendations\n\t    providers: \n\t      - $ref: '#/Console/providers/AwsProvider'\n\t      - $ref: '#/Console/providers/UtilizationProvider'\n", " * ```\n\t */\n\texport interface AwsUtilizationRecommendations extends Widget {\n\t  regions?: string[]\n\t}\n\texport interface AwsUtilization extends Widget {\n\t  region?: string\n\t}\n\t/**\n\t * @example\n", " * ```yaml\n\t * UtilizationProvider:\n\t    type: AwsUtilizationProvider\n\t * ```\n\t */\n\texport interface AwsUtilizationProvider extends Provider {\n\t  services?: AwsResourceType[];\n\t  regions?: string[];\n\t}\n\texport type AwsResourceType = 'Account' |\n", "  'CloudwatchLogs' |\n\t  'AutoscalingGroup' |\n\t  'Ec2Instance' |\n\t  'EcsService' |\n\t  'NatGateway' |\n\t  'S3Bucket' |\n\t  'EbsVolume' |\n\t  'RdsInstance';"]}
{"filename": "src/aws-utilization-provider.ts", "chunked_list": ["import cached from 'cached';\n\timport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\n\timport { BaseProvider } from '@tinystacks/ops-core';\n\timport {\n\t  ActionType,\n\t  AwsResourceType,\n\t  AwsServiceOverrides,\n\t  AwsUtilizationOverrides,\n\t  HistoryEvent,\n\t  Utilization\n", "} from './types/types.js';\n\timport { AwsServiceUtilization } from './service-utilizations/aws-service-utilization.js';\n\timport { AwsServiceUtilizationFactory } from './service-utilizations/aws-service-utilization-factory.js';\n\timport { AwsUtilizationProvider as AwsUtilizationProviderType } from './ops-types.js';\n\tconst utilizationCache = cached<Utilization<string>>('utilization', {\n\t  backend: {\n\t    type: 'memory'\n\t  }\n\t});\n\tconst sessionHistoryCache = cached<Array<HistoryEvent>>('session-history', {\n", "  backend: {\n\t    type: 'memory'\n\t  }\n\t});\n\ttype AwsUtilizationProviderProps = AwsUtilizationProviderType & {\n\t  utilization?: {\n\t    [key: AwsResourceType | string]: Utilization<string>\n\t  };\n\t  region?: string;\n\t};\n", "class AwsUtilizationProvider extends BaseProvider {\n\t  static type = 'AwsUtilizationProvider';\n\t  services: AwsResourceType[];\n\t  utilizationClasses: {\n\t    [key: AwsResourceType | string]: AwsServiceUtilization<string>\n\t  };\n\t  utilization: {\n\t    [key: AwsResourceType | string]: Utilization<string>\n\t  };\n\t  region: string;\n", "  constructor (props: AwsUtilizationProviderProps) {\n\t    super(props);\n\t    const { \n\t      services\n\t    } = props;\n\t    this.utilizationClasses = {};\n\t    this.utilization = {};\n\t    this.initServices(services || [\n\t      'Account',\n\t      'CloudwatchLogs',\n", "      'Ec2Instance',\n\t      'EcsService',\n\t      'NatGateway',\n\t      'S3Bucket',\n\t      'EbsVolume',\n\t      'RdsInstance'\n\t    ]);\n\t  }\n\t  static fromJson (props: AwsUtilizationProviderProps) {\n\t    return new AwsUtilizationProvider(props);\n", "  }\n\t  toJson (): AwsUtilizationProviderProps {\n\t    return {\n\t      ...super.toJson(),\n\t      services: this.services,\n\t      utilization: this.utilization\n\t    };\n\t  }\n\t  initServices (services: AwsResourceType[]) {\n\t    this.services = services;\n", "    for (const service of this.services) {\n\t      this.utilizationClasses[service] = AwsServiceUtilizationFactory.createObject(service);\n\t    }\n\t  }\n\t  async refreshUtilizationData (\n\t    service: AwsResourceType, \n\t    credentialsProvider: AwsCredentialsProvider,\n\t    region: string,\n\t    overrides?: AwsServiceOverrides\n\t  ): Promise<Utilization<string>> {\n", "    try {\n\t      await this.utilizationClasses[service]?.getUtilization(credentialsProvider, [ region ], overrides);\n\t      return this.utilizationClasses[service]?.utilization;\n\t    } catch (e) {\n\t      console.error(e);\n\t      return {};\n\t    }\n\t  }\n\t  async doAction (\n\t    service: AwsResourceType,\n", "    credentialsProvider: AwsCredentialsProvider,\n\t    actionName: string,\n\t    actionType: ActionType,\n\t    resourceArn: string,\n\t    region: string\n\t  ) {\n\t    const event: HistoryEvent = {\n\t      service,\n\t      actionType,\n\t      actionName,\n", "      resourceArn,\n\t      region,\n\t      timestamp: new Date().toISOString()\n\t    };\n\t    const history: HistoryEvent[] = await this.getSessionHistory();\n\t    history.push(event);\n\t    await this.utilizationClasses[service].doAction(credentialsProvider, actionName, resourceArn, region);\n\t    await sessionHistoryCache.set('history', history);\n\t  }\n\t  async hardRefresh (\n", "    credentialsProvider: AwsCredentialsProvider, region: string, overrides: AwsUtilizationOverrides = {}\n\t  ) {\n\t    for (const service of this.services) {\n\t      const serviceOverrides = overrides[service];\n\t      this.utilization[service] = await this.refreshUtilizationData(\n\t        service, credentialsProvider, region, serviceOverrides\n\t      );\n\t      await utilizationCache.set(service, this.utilization[service]);\n\t    }\n\t    return this.utilization;\n", "  }\n\t  async getUtilization (\n\t    credentialsProvider: AwsCredentialsProvider, region: string, overrides: AwsUtilizationOverrides = {}\n\t  ) {\n\t    for (const service of this.services) {\n\t      const serviceOverrides = overrides[service];\n\t      if (serviceOverrides?.forceRefesh) {\n\t        this.utilization[service] = await this.refreshUtilizationData(\n\t          service, credentialsProvider, region, serviceOverrides\n\t        );\n", "        await utilizationCache.set(service, this.utilization[service]);\n\t      } else {\n\t        this.utilization[service] = await utilizationCache.getOrElse(\n\t          service,\n\t          async () => await this.refreshUtilizationData(service, credentialsProvider, region, serviceOverrides)\n\t        );\n\t      }\n\t    }\n\t    return this.utilization;\n\t  }\n", "  async getSessionHistory (): Promise<HistoryEvent[]> {\n\t    return sessionHistoryCache.getOrElse('history', []);\n\t  }\n\t}\n\texport {\n\t  AwsUtilizationProvider\n\t};"]}
{"filename": "src/index.ts", "chunked_list": ["import { AwsUtilization } from './widgets/aws-utilization.js';\n\timport { AwsUtilizationProvider } from './aws-utilization-provider.js';\n\timport { AwsUtilizationRecommendations } from './widgets/aws-utilization-recommendations.js';\n\texport { \n\t  AwsUtilization,\n\t  AwsUtilizationProvider,\n\t  AwsUtilizationRecommendations\n\t};"]}
{"filename": "src/utils/utilization.ts", "chunked_list": ["import isEmpty from 'lodash.isempty';\n\timport { ActionType, HistoryEvent, Scenarios, Utilization } from '../types/types.js';\n\texport function filterUtilizationForActionType (\n\t  utilization: { [service: string]: Utilization<string> }, actionType: ActionType,  session: HistoryEvent[]\n\t):\n\t{ [service: string]: Utilization<string> } {\n\t  const filtered: { [service: string]: Utilization<string> } = {};\n\t  if (!utilization) {\n\t    return filtered;\n\t  }\n", "  Object.keys(utilization).forEach((service) => {\n\t    filtered[service] = filterServiceForActionType(utilization, service, actionType, session);\n\t  });\n\t  return filtered;\n\t}\n\texport function filterServiceForActionType (\n\t  utilization: { [service: string]: Utilization<string> }, service: string, \n\t  actionType: ActionType, session: HistoryEvent[]\n\t) {\n\t  const resourcesInProgress = session.map((historyevent) => {\n", "    return historyevent.resourceArn;\n\t  });  \n\t  const serviceUtil = utilization[service];\n\t  const actionFilteredServiceUtil = \n\t    Object.entries(serviceUtil).reduce<Utilization<string>>((aggUtil, [id, resource]) => {\n\t      if(resourcesInProgress.includes(id)){ \n\t        delete aggUtil[id];\n\t        return aggUtil;\n\t      }\n\t      const filteredScenarios: Scenarios<string> = {};\n", "      Object.entries(resource.scenarios).forEach(([sType, details]) => {\n\t        if (Object.hasOwn(details, actionType)) {\n\t          filteredScenarios[sType] = details;\n\t        }\n\t      });\n\t      if (!filteredScenarios || isEmpty(filteredScenarios)) {\n\t        return aggUtil;\n\t      }\n\t      aggUtil[id] = {\n\t        ...resource,\n", "        scenarios: filteredScenarios \n\t      };\n\t      return aggUtil;\n\t    }, {});\n\t  return actionFilteredServiceUtil;\n\t}\n\texport function getNumberOfResourcesFromFilteredActions (filtered: { [service: string]: Utilization<string> }): number {\n\t  let total = 0;\n\t  Object.keys(filtered).forEach((s) => {\n\t    if (!filtered[s] || isEmpty(filtered[s])) return;\n", "    total += Object.keys(filtered[s]).length;\n\t  });\n\t  return total;\n\t}\n\texport function getNumberOfResourcesInProgress (session: HistoryEvent[]): { [ key in ActionType ]: number } {\n\t  const result: { [ key in ActionType ]: number } = {\n\t    [ActionType.OPTIMIZE]: 0,\n\t    [ActionType.DELETE]: 0,\n\t    [ActionType.SCALE_DOWN]: 0\n\t  };  \n", "  session.forEach((historyEvent) => { \n\t    result[historyEvent.actionType] ++;\n\t  });\n\t  return result;\n\t}\n\texport function getTotalNumberOfResources ( utilization: { [service: string]: Utilization<string> }): number { \n\t  let total = 0; \n\t  Object.keys(utilization).forEach((service) => {\n\t    if (!utilization[service] || isEmpty(utilization[service])) return;\n\t    total += Object.keys(utilization[service]).length;\n", "  });\n\t  return total;\n\t}\n\texport function getTotalMonthlySavings (utilization: { [service: string]: Utilization<string> }): string { \n\t  const usd = new Intl.NumberFormat('en-US', {\n\t    style: 'currency',\n\t    currency: 'USD'\n\t  });\n\t  let totalSavings = 0; \n\t  Object.keys(utilization).forEach((service) => {\n", "    if (!utilization[service] || isEmpty(utilization[service])) return;\n\t    Object.keys(utilization[service]).forEach((resource) => { \n\t      totalSavings += utilization[service][resource].data?.maxMonthlySavings || 0;\n\t    });\n\t  });\n\t  return usd.format(totalSavings);\n\t}\n\texport function sentenceCase (name: string): string { \n\t  const result = name.replace(/([A-Z])/g, ' $1');\n\t  return result[0].toUpperCase() + result.substring(1).toLowerCase();\n", "}\n\texport function splitServiceName (name: string) {\n\t  return name?.split(/(?=[A-Z])/).join(' ');\n\t}"]}
{"filename": "src/utils/stats.ts", "chunked_list": ["import * as stats from 'simple-statistics';\n\timport { StabilityStats, StabilityStatsOptions } from '../types/types';\n\timport isEmpty from 'lodash.isempty';\n\t/**\n\t * \n\t * @param dataSet - The data to run stats on.\n\t * @param options - {@link StabilityStatsOptions}\n\t * @returns - {@link StabilityStats}\n\t */\n\texport function getStabilityStats (dataSet: number[], options?: StabilityStatsOptions): StabilityStats {\n", "  const {\n\t    removeOutliers = false,\n\t    outlierZScore = 5,\n\t    anomalyThreshold = 0.5,\n\t    stabilityZScore = 3\n\t  } = options || {};\n\t  if (isEmpty(dataSet)) {\n\t    return {\n\t      mean: 0,\n\t      max: 0,\n", "      maxZScore: 0,\n\t      standardDeviation: 0,\n\t      wasFiltered: false,\n\t      isStable: false\n\t    };\n\t  }\n\t  let wasFiltered = removeOutliers;\n\t  const mean = stats.mean(dataSet);\n\t  const stdev = stats.standardDeviation(dataSet);\n\t  let filteredDataSet = dataSet;\n", "  let anomalyPercentage;\n\t  if (removeOutliers) {\n\t    const nonAnomolousData = dataSet.filter(val => stats.zScore(val, mean, stdev) < outlierZScore);\n\t    const dataSetSize = dataSet.length;\n\t    const anomolousDataSize = dataSetSize - nonAnomolousData.length;\n\t    anomalyPercentage = (anomolousDataSize / dataSetSize) * 100;\n\t    if (anomalyPercentage < anomalyThreshold) {\n\t      filteredDataSet = nonAnomolousData;\n\t    } else {\n\t      wasFiltered = false;\n", "    }\n\t  }\n\t  const filteredMean = stats.mean(filteredDataSet);\n\t  const filteredStdev = stats.standardDeviation(filteredDataSet);\n\t  const max = stats.max(filteredDataSet);\n\t  const maxZScore = stats.zScore(max, filteredMean, filteredStdev);\n\t  const isStable = maxZScore < stabilityZScore;\n\t  const anomalyPercentageString = anomalyPercentage ? `${Math.round(anomalyPercentage * 10000) / 10000}%` : undefined;\n\t  return {\n\t    mean: filteredMean,\n", "    max,\n\t    maxZScore,\n\t    standardDeviation: filteredStdev,\n\t    anomalyPercentage: anomalyPercentageString,\n\t    wasFiltered,\n\t    isStable\n\t  };\n\t}"]}
{"filename": "src/utils/ec2-utils.ts", "chunked_list": ["import { Pricing } from '@aws-sdk/client-pricing';\n\texport async function getInstanceCost (pricingClient: Pricing, instanceType: string) {\n\t  const res = await pricingClient.getProducts({\n\t    Filters: [\n\t      {\n\t        Type: 'TERM_MATCH',\n\t        Field: 'instanceType',\n\t        Value: instanceType\n\t      },\n\t      {\n", "        Type: 'TERM_MATCH',\n\t        Field: 'regionCode',\n\t        Value: 'us-east-1'\n\t      },\n\t      {\n\t        Type: 'TERM_MATCH',\n\t        Field: 'operatingSystem',\n\t        Value: 'Linux'\n\t      },\n\t      {\n", "        Type: 'TERM_MATCH',\n\t        Field: 'usageType',\n\t        Value: `BoxUsage:${instanceType}`\n\t      },\n\t      {\n\t        Type: 'TERM_MATCH',\n\t        Field: 'preInstalledSw',\n\t        Value: 'NA'\n\t      }\n\t    ],\n", "    ServiceCode: 'AmazonEC2'\n\t  });\n\t  const onDemandData = JSON.parse(res.PriceList[0] as string).terms.OnDemand;\n\t  const onDemandKeys = Object.keys(onDemandData);\n\t  const priceDimensionsData = onDemandData[onDemandKeys[0]].priceDimensions;\n\t  const priceDimensionsKeys = Object.keys(priceDimensionsData);\n\t  const pricePerHour = priceDimensionsData[priceDimensionsKeys[0]].pricePerUnit.USD;\n\t  return pricePerHour * 24 * 30;\n\t}"]}
{"filename": "src/utils/utils.ts", "chunked_list": ["import { Account, ListRegionsCommandOutput } from '@aws-sdk/client-account';\n\timport { STS } from '@aws-sdk/client-sts';\n\timport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\n\timport { BaseProvider } from '@tinystacks/ops-core';\n\timport isEmpty from 'lodash.isempty';\n\timport { AwsUtilizationProvider } from '../aws-utilization-provider.js';\n\texport function getAwsUtilizationProvider (providers?: BaseProvider[]): AwsUtilizationProvider {\n\t  if (!providers || isEmpty(providers)) {\n\t    throw new Error('No AwsUtilizationProvider provided');\n\t  }\n", "  const provider = providers.find(p => p.type === AwsUtilizationProvider.type);\n\t  if (!provider) {\n\t    throw new Error('No AwsUtilizationProvider provided');\n\t  }\n\t  return provider as AwsUtilizationProvider;\n\t}\n\texport function getAwsCredentialsProvider (providers?: BaseProvider[]): AwsCredentialsProvider {\n\t  if (!providers || isEmpty(providers)) {\n\t    throw new Error('No AwsCredentialsProvider provided');\n\t  }\n", "  const provider = providers.find(p => p.type === AwsCredentialsProvider.type);\n\t  if (!provider) {\n\t    throw new Error('No AwsCredentialsProvider provided');\n\t  }\n\t  return provider as AwsCredentialsProvider;\n\t}\n\texport function findProvider<T extends BaseProvider> (providers: BaseProvider[] = [], providerType: string): T {\n\t  if (!providers || isEmpty(providers)) {\n\t    throw new Error('No providers are available!');\n\t  }\n", "  const provider = providers.find(p => p.type === providerType);\n\t  if (!provider) {\n\t    throw new Error(`No ${providerType}s are available!`);\n\t  }\n\t  return provider as T;\n\t}\n\texport async function listAllRegions (awsCredentialsProvider: AwsCredentialsProvider) {\n\t  const accountClient = new Account({\n\t    credentials: await awsCredentialsProvider.getCredentials(),\n\t    region: 'us-east-1'\n", "  });\n\t  let regions: string[] = [];\n\t  let listRegionsRes: ListRegionsCommandOutput;\n\t  do {\n\t    listRegionsRes = await accountClient.listRegions({\n\t      RegionOptStatusContains: ['ENABLED', 'ENABLED_BY_DEFAULT'],\n\t      NextToken: listRegionsRes?.NextToken\n\t    });\n\t    regions = [...regions, ...listRegionsRes.Regions.map(region => region.RegionName)];\n\t  } while (listRegionsRes?.NextToken);\n", "  return regions;\n\t}\n\texport async function getAccountId (credentials: any) {\n\t  const stsClient = new STS({\n\t    credentials,\n\t    region: 'us-east-1'\n\t  });\n\t  return (await stsClient.getCallerIdentity({}))?.Account;\n\t}\n\texport async function addFullJitter (attempt: number, cap = 5000, base = 3000, min = 3000) {\n", "  const randomBetween = Math.floor(Math.random() * (Math.min(cap, base * 2 ** attempt) - min + 1) + min);\n\t  await new Promise(r => setTimeout(r, randomBetween));\n\t}\n\texport function rateLimitMap (\n\t  array: any[], requestsPerSec: number, maxInFlight: number, fn: (...args: any[]) => Promise<void>\n\t) {\n\t  return new Promise((resolve, reject) => {\n\t    let index = 0;\n\t    let inFlightCntr = 0;\n\t    let doneCntr = 0;\n", "    const launchTimes: number[] = [];\n\t    const results = new Array(array.length);\n\t    // calculate num requests in last second\n\t    function calcRequestsInLastSecond () {\n\t      const now = Date.now();\n\t      // look backwards in launchTimes to see how many were launched within the last second\n\t      let cnt = 0;\n\t      for (let i = launchTimes.length - 1; i >= 0; i--) {\n\t        if (now - launchTimes[i] < 1000) {\n\t          ++cnt;\n", "        } else {\n\t          break;\n\t        }\n\t      }\n\t      return cnt;\n\t    }\n\t    function runMore () {\n\t      while (index < array.length && inFlightCntr < maxInFlight && calcRequestsInLastSecond() < requestsPerSec) {\n\t        (function (i) {\n\t          ++inFlightCntr;\n", "          launchTimes.push(Date.now());\n\t          fn(array[i]).then((val: any) => {\n\t            results[i] = val;\n\t            --inFlightCntr;\n\t            ++doneCntr;\n\t            runMore();\n\t          }, reject);\n\t        })(index);\n\t        ++index;\n\t      }\n", "      // see if we're done\n\t      if (doneCntr === array.length) {\n\t        resolve(results);\n\t      } else if (launchTimes.length >= requestsPerSec) {\n\t        // calc how long we have to wait before sending more\n\t        let delta = 1000 - (Date.now() - launchTimes[launchTimes.length - requestsPerSec]);\n\t        if (delta >= 0) {\n\t          setTimeout(runMore, ++delta);\n\t        }\n\t      }\n", "    }\n\t    runMore();\n\t  });\n\t}\n\texport function round (val: number, decimalPlace: number) {\n\t  const factor = 10 ** decimalPlace;\n\t  return Math.round(val * factor) / factor;\n\t}\n\texport function getHourlyCost (monthlyCost: number) {\n\t  return (monthlyCost / 30) / 24;\n", "}"]}
{"filename": "src/types/types.ts", "chunked_list": ["import { Tag } from '@aws-sdk/client-ec2';\n\texport type Data = {\n\t  region: string,\n\t  resourceId: string,\n\t  associatedResourceId?: string,\n\t  stack?: string,\n\t  hourlyCost?: number,\n\t  monthlyCost?: number,\n\t  maxMonthlySavings?: number,\n\t  [ key: string ]: any;\n", "  tags?: Tag[];\n\t}\n\texport type Metrics = { \n\t  [ metricName: string ]: Metric\n\t}\n\texport type Metric = { \n\t  yAxisLabel: string, \n\t  yLimits?: number, \n\t  values: MetricData[]\n\t}\n", "export type MetricData = { \n\t  timestamp?: number | Date;\n\t  value: number\n\t}\n\texport enum ActionType {\n\t  OPTIMIZE='optimize',\n\t  DELETE='delete',\n\t  SCALE_DOWN='scaleDown'\n\t}\n\texport const actionTypeText = {\n", "  [ActionType.OPTIMIZE]: 'optimize',\n\t  [ActionType.DELETE]: 'delete',\n\t  [ActionType.SCALE_DOWN]: 'scale down'\n\t};\n\texport const actionTypeToEnum = {\n\t  [ActionType.OPTIMIZE.toString()]: ActionType.OPTIMIZE,\n\t  [ActionType.DELETE.toString()]: ActionType.DELETE,\n\t  [ActionType.SCALE_DOWN.toString()]: ActionType.SCALE_DOWN\n\t};\n\texport type Action = {\n", "  action: string,\n\t  isActionable: boolean,\n\t  reason: string\n\t  monthlySavings?: number\n\t}\n\texport type Scenario = {\n\t  value: string,\n\t  delete?: Action,\n\t  scaleDown?: Action,\n\t  optimize?: Action\n", "}\n\texport type Scenarios<ScenarioTypes extends string> = {\n\t  [ scenarioType in ScenarioTypes ]: Scenario\n\t}\n\texport type Resource<ScenarioTypes extends string> = {\n\t  scenarios: Scenarios<ScenarioTypes>,\n\t  data: Data,\n\t  metrics: Metrics\n\t}\n\texport type Utilization<ScenarioTypes extends string> = {\n", "  [ resourceArn: string ]: Resource<ScenarioTypes>\n\t}\n\texport type UserInput = { [ key: string ]: any }\n\texport type AwsServiceOverrides = {\n\t  resourceArn: string,\n\t  scenarioType: string,\n\t  delete?: boolean,\n\t  scaleDown?: boolean,\n\t  optimize?: boolean,\n\t  forceRefesh?: boolean,\n", "  userInput?: UserInput\n\t}\n\texport type AwsUtilizationOverrides = {\n\t  [ serviceName: string ]: AwsServiceOverrides\n\t}\n\texport type StabilityStats = {\n\t  mean: number;\n\t  max: number;\n\t  maxZScore: number;\n\t  standardDeviation: number;\n", "  anomalyPercentage?: string;\n\t  wasFiltered: boolean;\n\t  isStable: boolean;\n\t};\n\t/**\n\t * \n\t * @param removeOutliers - default false; Whether to remove outliers from the dataset before running the final stats.\n\t * @param outlierZScore - default 5; The cutoff Z score (number of standard deviations away from the mean) that is\n\t *                        considered an outlier.\n\t * @param anomalyThreshold - default 0.5; The maximum threshold, as a percentage, of anomalies in the dataset required\n", " *                           to perform outlier removal.  If the percentage of outliers in the dataset is higher that\n\t *                           this threshold, outliers will not be removed.\n\t * @param stabilityZScore - default 3; The cutoff Z score (non-inclusive) used to check for stability in the dataset.\n\t *                          If there are values above this, the dataset is considered unstable.\n\t */\n\texport type StabilityStatsOptions = {\n\t  removeOutliers?: boolean;\n\t  outlierZScore?: number;\n\t  anomalyThreshold?: number;\n\t  stabilityZScore?: number;\n", "};\n\texport type AwsResourceType = 'Account' |\n\t  'CloudwatchLogs' |\n\t  'AutoscalingGroup' |\n\t  'Ec2Instance' |\n\t  'EcsService' |\n\t  'NatGateway' |\n\t  'S3Bucket' |\n\t  'EbsVolume' |\n\t  'RdsInstance';\n", "export type HistoryEvent = {\n\t  service: AwsResourceType;\n\t  actionType: ActionType;\n\t  actionName: string;\n\t  resourceArn: string;\n\t  region: string;\n\t  timestamp: string;\n\t}"]}
{"filename": "src/types/utilization-recommendations-types.ts", "chunked_list": ["import { Widget } from '@tinystacks/ops-model';\n\timport { ActionType, AwsResourceType, HistoryEvent, Utilization } from './types.js';\n\texport type HasActionType = {\n\t  actionType: ActionType;\n\t}\n\texport type HasUtilization = {\n\t  utilization: { [key: AwsResourceType | string]: Utilization<string> };\n\t  sessionHistory: HistoryEvent[];\n\t}\n\tinterface RemovableResource {\n", "  onRemoveResource: (resourceArn: string) => void;\n\t}\n\tinterface HasResourcesAction {\n\t  onResourcesAction: (resourceArns: string[], actionType: string) => void;\n\t}\n\tinterface Refresh {\n\t  onRefresh: () => void;\n\t}\n\texport type UtilizationRecommendationsWidget = Widget & HasActionType & HasUtilization & {\n\t  region: string\n", "};\n\texport interface Regions {\n\t  onRegionChange: (region: string) => void;\n\t  allRegions: string[];\n\t  region: string;\n\t}\n\texport type UtilizationRecommendationsUiProps = HasUtilization & HasResourcesAction & Refresh & Regions;\n\texport type RecommendationsCallback = (props: RecommendationsOverrides) => void;\n\texport type RecommendationsOverrides = {\n\t  refresh?: boolean;\n", "  resourceActions?: {\n\t    actionType: string,\n\t    resourceArns: string[]\n\t  };\n\t  region?: string;\n\t};\n\texport type RecommendationsTableProps = HasActionType & HasUtilization & {\n\t  onContinue: (resourceArns: string[]) => void;\n\t  onBack: () => void;\n\t  onRefresh: () => void;\n", "};\n\texport type RecommendationsActionsSummaryProps = Widget & HasUtilization;\n\texport type RecommendationsActionSummaryProps = HasUtilization & Regions & {\n\t  onContinue: (selectedActionType: ActionType) => void;\n\t  onRefresh: () => void;\n\t};\n\texport type ConfirmSingleRecommendationProps = RemovableResource & HasActionType & HasResourcesAction & {\n\t  resourceArn: string;\n\t};\n\texport type ConfirmRecommendationsProps = RemovableResource & HasActionType & HasResourcesAction & HasUtilization & {\n", "  resourceArns: string[];\n\t  onBack: () => void;\n\t};\n\texport type ServiceTableRowProps = {\n\t  serviceUtil: Utilization<string>;\n\t  serviceName: string;\n\t  children?: React.ReactNode;\n\t  onServiceCheckChange: (e: React.ChangeEvent<HTMLInputElement>) => void;\n\t  isChecked: boolean;\n\t};"]}
{"filename": "src/types/constants.ts", "chunked_list": ["import { AwsResourceType } from './types.js';\n\texport const Arns = {\n\t  NatGateway (region: string, accountId: string, natGatewayId: string) {\n\t    return `arn:aws:ec2:${region}:${accountId}:natgateway/${natGatewayId}`;\n\t  },\n\t  Ec2 (region: string, accountId: string, instanceId: string) {\n\t    return `arn:aws:ec2:${region}:${accountId}:instance/${instanceId}`;\n\t  },\n\t  S3 (bucketName: string) {\n\t    return `arn:aws:s3:::${bucketName}`;\n", "  },\n\t  Ebs (region: string, accountId: string, volumeId: string) {\n\t    return `arn:aws:ec2:${region}:${accountId}:volume/${volumeId}`;\n\t  }\n\t};\n\t// Because typescript enums transpile strangely and are even discouraged by typescript themselves:\n\t// Source: https://www.typescriptlang.org/docs/handbook/enums.html#objects-vs-enums\n\texport const AwsResourceTypes: {\n\t  [key: AwsResourceType | string]: AwsResourceType\n\t} = {\n", "  Account: 'Account',\n\t  CloudwatchLogs: 'CloudwatchLogs',\n\t  AutoscalingGroup: 'AutoscalingGroup',\n\t  Ec2Instance: 'Ec2Instance',\n\t  EcsService: 'EcsService',\n\t  NatGateway: 'NatGateway',\n\t  S3Bucket: 'S3Bucket',\n\t  EbsVolume: 'EbsVolume',\n\t  RdsInstance: 'RdsInstance'\n\t} as const;\n", "export const ONE_GB_IN_BYTES = 1073741824;\n\texport const AVG_CPU = 'avgCpu';\n\texport const MAX_CPU = 'maxCpu';\n\texport const AVG_MEMORY = 'avgMemory';\n\texport const MAX_MEMORY = 'maxMemory';\n\texport const DISK_READ_OPS = 'diskReadOps';\n\texport const DISK_WRITE_OPS = 'diskWriteOps';\n\texport const MAX_NETWORK_BYTES_IN = 'maxNetworkBytesIn';\n\texport const MAX_NETWORK_BYTES_OUT = 'maxNetworkBytesOut';\n\texport const AVG_NETWORK_BYTES_IN = 'avgNetworkBytesIn';\n", "export const AVG_NETWORK_BYTES_OUT = 'avgNetworkBytesOut';\n\texport const ALB_REQUEST_COUNT = 'albRequestCount';\n\texport const APIG_REQUEST_COUNT = 'apigRequestCount';"]}
{"filename": "src/service-utilizations/aws-cloudwatch-logs-utilization.ts", "chunked_list": ["import get from 'lodash.get';\n\timport { CloudWatch } from '@aws-sdk/client-cloudwatch';\n\timport { CloudWatchLogs, DescribeLogGroupsCommandOutput, LogGroup } from '@aws-sdk/client-cloudwatch-logs';\n\timport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\n\timport { ONE_GB_IN_BYTES } from '../types/constants.js';\n\timport { AwsServiceOverrides } from '../types/types.js';\n\timport { getHourlyCost, rateLimitMap } from '../utils/utils.js';\n\timport { AwsServiceUtilization } from './aws-service-utilization.js';\n\tconst ONE_HUNDRED_MB_IN_BYTES = 104857600;\n\tconst NOW = Date.now();\n", "const oneMonthAgo = NOW - (30 * 24 * 60 * 60 * 1000);\n\tconst thirtyDaysAgo = NOW - (30 * 24 * 60 * 60 * 1000);\n\tconst sevenDaysAgo = NOW - (7 * 24 * 60 * 60 * 1000);\n\tconst twoWeeksAgo = NOW - (14 * 24 * 60 * 60 * 1000);\n\ttype AwsCloudwatchLogsUtilizationScenarioTypes = 'hasRetentionPolicy' | 'lastEventTime' | 'storedBytes';\n\tconst AwsCloudWatchLogsMetrics = ['IncomingBytes'];\n\texport class AwsCloudwatchLogsUtilization extends AwsServiceUtilization<AwsCloudwatchLogsUtilizationScenarioTypes> {\n\t  constructor () {\n\t    super();\n\t  }\n", "  async doAction (\n\t    awsCredentialsProvider: AwsCredentialsProvider, actionName: string, resourceArn: string, region: string\n\t  ): Promise<void> {\n\t    const resourceId = resourceArn.split(':').at(-2);\n\t    if (actionName === 'deleteLogGroup') {\n\t      const cwLogsClient = new CloudWatchLogs({\n\t        credentials: await awsCredentialsProvider.getCredentials(),\n\t        region\n\t      });\n\t      await this.deleteLogGroup(cwLogsClient, resourceId);\n", "    }\n\t    if(actionName === 'setRetentionPolicy'){ \n\t      const cwLogsClient = new CloudWatchLogs({\n\t        credentials: await awsCredentialsProvider.getCredentials(),\n\t        region\n\t      });\n\t      await this.setRetentionPolicy(cwLogsClient, resourceId, 90);\n\t    }\n\t  }\n\t  async setRetentionPolicy (cwLogsClient: CloudWatchLogs, logGroupName: string, retentionInDays: number) {\n", "    await cwLogsClient.putRetentionPolicy({\n\t      logGroupName,\n\t      retentionInDays\n\t    });\n\t  }\n\t  async deleteLogGroup (cwLogsClient: CloudWatchLogs, logGroupName: string) {\n\t    await cwLogsClient.deleteLogGroup({\n\t      logGroupName\n\t    });\n\t  }\n", "  async createExportTask (cwLogsClient: CloudWatchLogs, logGroupName: string, bucket: string) {\n\t    await cwLogsClient.createExportTask({\n\t      logGroupName,\n\t      destination: bucket,\n\t      from: 0,\n\t      to: Date.now()\n\t    });\n\t  }\n\t  private async getAllLogGroups (credentials: any, region: string) {\n\t    let allLogGroups: LogGroup[] = [];\n", "    const cwLogsClient = new CloudWatchLogs({\n\t      credentials,\n\t      region\n\t    });\n\t    let describeLogGroupsRes: DescribeLogGroupsCommandOutput;\n\t    do {\n\t      describeLogGroupsRes = await cwLogsClient.describeLogGroups({\n\t        nextToken: describeLogGroupsRes?.nextToken\n\t      });\n\t      allLogGroups = [ ...allLogGroups, ...describeLogGroupsRes?.logGroups || [] ];\n", "    } while (describeLogGroupsRes?.nextToken);\n\t    return allLogGroups;\n\t  }\n\t  private async getEstimatedMonthlyIncomingBytes (\n\t    credentials: any, region: string, logGroupName: string, lastEventTime: number\n\t  ) {\n\t    if (!lastEventTime || lastEventTime < twoWeeksAgo) {\n\t      return 0;\n\t    }\n\t    const cwClient = new CloudWatch({\n", "      credentials,\n\t      region\n\t    });\n\t    // total bytes over last month\n\t    const res = await cwClient.getMetricData({\n\t      StartTime: new Date(oneMonthAgo),\n\t      EndTime: new Date(),\n\t      MetricDataQueries: [\n\t        {\n\t          Id: 'incomingBytes',\n", "          MetricStat: {\n\t            Metric: {\n\t              Namespace: 'AWS/Logs',\n\t              MetricName: 'IncomingBytes',\n\t              Dimensions: [{ Name: 'LogGroupName', Value: logGroupName }]\n\t            },\n\t            Period: 30 * 24 * 12 * 300, // 1 month\n\t            Stat: 'Sum'\n\t          }\n\t        }\n", "      ]\n\t    });\n\t    const monthlyIncomingBytes = get(res, 'MetricDataResults[0].Values[0]', 0);\n\t    return monthlyIncomingBytes;\n\t  }\n\t  private async getLogGroupData (credentials: any, region: string, logGroup: LogGroup) {\n\t    const cwLogsClient = new CloudWatchLogs({\n\t      credentials,\n\t      region\n\t    });\n", "    const logGroupName = logGroup?.logGroupName;\n\t    // get data and cost estimate for stored bytes \n\t    const storedBytes = logGroup?.storedBytes || 0;\n\t    const storedBytesCost = (storedBytes / ONE_GB_IN_BYTES) * 0.03;\n\t    const dataProtectionEnabled = logGroup?.dataProtectionStatus === 'ACTIVATED';\n\t    const dataProtectionCost = dataProtectionEnabled ? storedBytes * 0.12 : 0;\n\t    const monthlyStorageCost = storedBytesCost + dataProtectionCost;\n\t    // get data and cost estimate for ingested bytes\n\t    const describeLogStreamsRes = await cwLogsClient.describeLogStreams({\n\t      logGroupName,\n", "      orderBy: 'LastEventTime',\n\t      descending: true,\n\t      limit: 1\n\t    });\n\t    const lastEventTime = describeLogStreamsRes.logStreams[0]?.lastEventTimestamp;\n\t    const estimatedMonthlyIncomingBytes = await this.getEstimatedMonthlyIncomingBytes(\n\t      credentials, \n\t      region, \n\t      logGroupName, \n\t      lastEventTime\n", "    );\n\t    const logIngestionCost = (estimatedMonthlyIncomingBytes / ONE_GB_IN_BYTES) * 0.5;\n\t    // get associated resource\n\t    let associatedResourceId = '';\n\t    if (logGroupName.startsWith('/aws/rds')) {\n\t      associatedResourceId = logGroupName.split('/')[4];\n\t    } else if (logGroupName.startsWith('/aws')) {\n\t      associatedResourceId = logGroupName.split('/')[3];\n\t    }\n\t    return {\n", "      storedBytes,\n\t      lastEventTime,\n\t      monthlyStorageCost,\n\t      totalMonthlyCost: logIngestionCost + monthlyStorageCost,\n\t      associatedResourceId\n\t    };\n\t  }\n\t  private async getRegionalUtilization (credentials: any, region: string, _overrides?: AwsServiceOverrides) {\n\t    const allLogGroups = await this.getAllLogGroups(credentials, region);\n\t    const analyzeLogGroup = async (logGroup: LogGroup) => {\n", "      const logGroupName = logGroup?.logGroupName;\n\t      const logGroupArn = logGroup?.arn;\n\t      const retentionInDays = logGroup?.retentionInDays;\n\t      if (!retentionInDays) {\n\t        const {\n\t          storedBytes,\n\t          lastEventTime,\n\t          monthlyStorageCost,\n\t          totalMonthlyCost,\n\t          associatedResourceId\n", "        } = await this.getLogGroupData(credentials, region, logGroup);\n\t        this.addScenario(logGroupArn, 'hasRetentionPolicy', {\n\t          value: retentionInDays?.toString(),\n\t          optimize: {\n\t            action: 'setRetentionPolicy',\n\t            isActionable: true,\n\t            reason: 'this log group does not have a retention policy',\n\t            monthlySavings: monthlyStorageCost\n\t          }\n\t        });\n", "        // TODO: change limit compared\n\t        if (storedBytes > ONE_HUNDRED_MB_IN_BYTES) {\n\t          this.addScenario(logGroupArn, 'storedBytes', {\n\t            value: storedBytes.toString(),\n\t            scaleDown: {\n\t              action: 'createExportTask',\n\t              isActionable: false,\n\t              reason: 'this log group has more than 100 MB of stored data',\n\t              monthlySavings: monthlyStorageCost\n\t            }\n", "          });\n\t        }\n\t        if (lastEventTime < thirtyDaysAgo) {\n\t          this.addScenario(logGroupArn, 'lastEventTime', {\n\t            value: new Date(lastEventTime).toLocaleString(),\n\t            delete: {\n\t              action: 'deleteLogGroup',\n\t              isActionable: true,\n\t              reason: 'this log group has not had an event in over 30 days',\n\t              monthlySavings: totalMonthlyCost\n", "            }\n\t          });\n\t        } else if (lastEventTime < sevenDaysAgo) {\n\t          this.addScenario(logGroupArn, 'lastEventTime', {\n\t            value: new Date(lastEventTime).toLocaleString(),\n\t            optimize: {\n\t              isActionable: false,\n\t              action: '',\n\t              reason: 'this log group has not had an event in over 7 days'\n\t            }\n", "          });\n\t        }\n\t        await this.fillData(\n\t          logGroupArn,\n\t          credentials,\n\t          region,\n\t          {\n\t            resourceId: logGroupName,\n\t            ...(associatedResourceId && { associatedResourceId }),\n\t            region,\n", "            monthlyCost: totalMonthlyCost,\n\t            hourlyCost: getHourlyCost(totalMonthlyCost)\n\t          }\n\t        );\n\t        AwsCloudWatchLogsMetrics.forEach(async (metricName) => {  \n\t          await this.getSidePanelMetrics(\n\t            credentials, \n\t            region, \n\t            logGroupArn,\n\t            'AWS/Logs', \n", "            metricName, \n\t            [{ Name: 'LogGroupName', Value: logGroupName }]);\n\t        });\n\t      }\n\t    };\n\t    await rateLimitMap(allLogGroups, 5, 5, analyzeLogGroup);\n\t  }\n\t  async getUtilization (\n\t    awsCredentialsProvider: AwsCredentialsProvider, regions?: string[], overrides?: AwsServiceOverrides\n\t  ) {\n", "    const credentials = await awsCredentialsProvider.getCredentials();\n\t    for (const region of regions) {\n\t      await this.getRegionalUtilization(credentials, region, overrides);\n\t    }\n\t  }\n\t}"]}
{"filename": "src/service-utilizations/aws-service-utilization.ts", "chunked_list": ["import { CloudFormation } from '@aws-sdk/client-cloudformation';\n\timport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\n\timport { Data, Metric, Resource, Scenario, Utilization, MetricData } from '../types/types';\n\timport { CloudWatch, Dimension } from '@aws-sdk/client-cloudwatch';\n\texport abstract class AwsServiceUtilization<ScenarioTypes extends string> {\n\t  private _utilization: Utilization<ScenarioTypes>;\n\t  constructor () {\n\t    this._utilization = {};\n\t  }\n\t  /* TODO: all services have a sub getRegionalUtilization function that needs to be deprecated\n", "   * since calls are now region specific\n\t   */\n\t  abstract getUtilization (\n\t    awsCredentialsProvider: AwsCredentialsProvider, regions?: string[], overrides?: any\n\t  ): void | Promise<void>;\n\t  abstract doAction (\n\t    awsCredentialsProvider: AwsCredentialsProvider, actionName: string, resourceId: string, region: string\n\t  ): void | Promise<void>;\n\t  protected addScenario (resourceArn: string, scenarioType: ScenarioTypes, scenario: Scenario) {\n\t    if (!(resourceArn in this.utilization)) {\n", "      this.utilization[resourceArn] = {\n\t        scenarios: {},\n\t        data: {}, \n\t        metrics: {}\n\t      } as Resource<ScenarioTypes>;\n\t    }\n\t    this.utilization[resourceArn].scenarios[scenarioType] = scenario;\n\t  }\n\t  protected async fillData (\n\t    resourceArn: string, \n", "    credentials: any, \n\t    region: string, \n\t    data: { [ key: keyof Data ]: Data[keyof Data] }\n\t  ) {\n\t    for (const key in data) {\n\t      this.addData(resourceArn, key, data[key]);\n\t    }\n\t    await this.identifyCloudformationStack(\n\t      credentials, \n\t      region, \n", "      resourceArn, \n\t      data.resourceId,\n\t      data.associatedResourceId\n\t    );\n\t    this.getEstimatedMaxMonthlySavings(resourceArn);\n\t  }\n\t  protected addData (resourceArn: string, dataType: keyof Data, value: any) {\n\t    // only add data if recommendation exists for resource\n\t    if (resourceArn in this.utilization) {\n\t      this.utilization[resourceArn].data[dataType] = value;\n", "    }\n\t  }\n\t  protected addMetric (resourceArn: string, metricName: string, metric: Metric){ \n\t    if(resourceArn in this.utilization){ \n\t      this.utilization[resourceArn].metrics[metricName] = metric;\n\t    }\n\t  }\n\t  protected async identifyCloudformationStack (\n\t    credentials: any, region: string, resourceArn: string, resourceId: string, associatedResourceId?: string\n\t  ) {\n", "    if (resourceArn in this.utilization) {\n\t      const cfnClient = new CloudFormation({\n\t        credentials,\n\t        region\n\t      });\n\t      await cfnClient.describeStackResources({\n\t        PhysicalResourceId: associatedResourceId ? associatedResourceId : resourceId\n\t      }).then((res) => {\n\t        const stack = res.StackResources[0].StackId;\n\t        this.addData(resourceArn, 'stack', stack);\n", "      }).catch(() => { return; });\n\t    }\n\t  }\n\t  protected getEstimatedMaxMonthlySavings (resourceArn: string) {\n\t    // for (const resourceArn in this.utilization) {\n\t    if (resourceArn in this.utilization) {\n\t      const scenarios = (this.utilization as Utilization<string>)[resourceArn].scenarios;\n\t      const maxSavingsPerScenario = Object.values(scenarios).map((scenario) => {\n\t        return Math.max(\n\t          scenario.delete?.monthlySavings || 0,\n", "          scenario.scaleDown?.monthlySavings || 0,\n\t          scenario.optimize?.monthlySavings || 0\n\t        );\n\t      });\n\t      const maxSavingsForResource = Math.max(...maxSavingsPerScenario);\n\t      this.addData(resourceArn, 'maxMonthlySavings', maxSavingsForResource);\n\t    }\n\t  }\n\t  protected async getSidePanelMetrics (\n\t    credentials: any, region: string, resourceArn: string, \n", "    nameSpace: string, metricName: string, dimensions: Dimension[]\n\t  ){ \n\t    if(resourceArn in this.utilization){\n\t      const cloudWatchClient = new CloudWatch({ \n\t        credentials: credentials, \n\t        region: region\n\t      }); \n\t      const endTime = new Date(Date.now()); \n\t      const startTime = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000); //7 days ago\n\t      const period = 43200; \n", "      const metrics = await cloudWatchClient.getMetricStatistics({ \n\t        Namespace: nameSpace, \n\t        MetricName: metricName, \n\t        StartTime: startTime,\n\t        EndTime: endTime,\n\t        Period: period,\n\t        Statistics: ['Average'],\n\t        Dimensions: dimensions\n\t      });\n\t      const values: MetricData[] =  metrics.Datapoints.map(dp => ({ \n", "        timestamp: dp.Timestamp.getTime(), \n\t        value: dp.Average\n\t      })).sort((dp1, dp2) => dp1.timestamp - dp2.timestamp);\n\t      const metricResuls: Metric = { \n\t        yAxisLabel: metrics.Label || metricName, \n\t        values: values\n\t      }; \n\t      this.addMetric(resourceArn , metricName, metricResuls);\n\t    }\n\t  }\n", "  public set utilization (utilization: Utilization<ScenarioTypes>) { this._utilization = utilization; }\n\t  public get utilization () { return this._utilization; }\n\t}"]}
{"filename": "src/service-utilizations/aws-ec2-instance-utilization.ts", "chunked_list": ["import cached from 'cached';\n\timport dayjs from 'dayjs';\n\timport isNil from 'lodash.isnil';\n\timport chunk from 'lodash.chunk';\n\timport * as stats from 'simple-statistics';\n\timport {\n\t  DescribeInstanceTypesCommandOutput, DescribeInstancesCommandOutput, EC2, Instance, InstanceTypeInfo, _InstanceType\n\t} from '@aws-sdk/client-ec2';\n\timport { AutoScaling } from '@aws-sdk/client-auto-scaling';\n\timport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\n", "import { AwsServiceUtilization } from './aws-service-utilization.js';\n\timport {\n\t  CloudWatch,\n\t  MetricDataQuery,\n\t  MetricDataResult\n\t} from '@aws-sdk/client-cloudwatch';\n\timport { getStabilityStats } from '../utils/stats.js';\n\timport {\n\t  AVG_CPU,\n\t  MAX_CPU,\n", "  DISK_READ_OPS,\n\t  DISK_WRITE_OPS,\n\t  MAX_NETWORK_BYTES_IN,\n\t  MAX_NETWORK_BYTES_OUT,\n\t  AVG_NETWORK_BYTES_IN,\n\t  AVG_NETWORK_BYTES_OUT\n\t} from '../types/constants.js';\n\timport { AwsServiceOverrides } from '../types/types.js';\n\timport { Pricing } from '@aws-sdk/client-pricing';\n\timport { getAccountId, getHourlyCost } from '../utils/utils.js';\n", "import { getInstanceCost } from '../utils/ec2-utils.js';\n\timport { Arns } from '../types/constants.js';\n\tconst cache = cached<string>('ec2-util-cache', {\n\t  backend: {\n\t    type: 'memory'\n\t  }\n\t});\n\ttype AwsEc2InstanceUtilizationScenarioTypes = 'unused' | 'overAllocated';\n\tconst AwsEc2InstanceMetrics = ['CPUUtilization', 'NetworkIn'];\n\ttype AwsEc2InstanceUtilizationOverrides = AwsServiceOverrides & {\n", "  instanceIds: string[];\n\t}\n\texport class AwsEc2InstanceUtilization extends AwsServiceUtilization<AwsEc2InstanceUtilizationScenarioTypes> {\n\t  instanceIds: string[];\n\t  instances: Instance[];\n\t  accountId: string;\n\t  DEBUG_MODE: boolean;\n\t  constructor (enableDebugMode?: boolean) {\n\t    super();\n\t    this.instanceIds = [];\n", "    this.instances = [];\n\t    this.DEBUG_MODE = enableDebugMode || false;\n\t  }\n\t  async doAction (\n\t    awsCredentialsProvider: AwsCredentialsProvider, actionName: string, resourceArn: string, region: string\n\t  ): Promise<void> {\n\t    const resourceId = (resourceArn.split(':').at(-1)).split('/').at(-1);\n\t    if (actionName === 'terminateInstance') {\n\t      await this.terminateInstance(awsCredentialsProvider, resourceId, region);\n\t    }\n", "  }\n\t  private async describeAllInstances (ec2Client: EC2, instanceIds?: string[]): Promise<Instance[]> {\n\t    const instances: Instance[] = [];\n\t    let nextToken;\n\t    do {\n\t      const response: DescribeInstancesCommandOutput = await ec2Client.describeInstances({\n\t        InstanceIds: instanceIds,\n\t        NextToken: nextToken\n\t      });\n\t      response?.Reservations.forEach((reservation) => {\n", "        instances.push(...reservation.Instances?.filter(i => !isNil(i.InstanceId)) || []);\n\t      });\n\t      nextToken = response?.NextToken;\n\t    } while (nextToken);\n\t    return instances;\n\t  }\n\t  private getMetricDataQueries (instanceId: string, period: number): MetricDataQuery[] {\n\t    function metricStat (metricName: string, statistic: string) {\n\t      return {\n\t        Metric: {\n", "          Namespace: 'AWS/EC2',\n\t          MetricName: metricName,\n\t          Dimensions: [{\n\t            Name: 'InstanceId',\n\t            Value: instanceId\n\t          }]\n\t        },\n\t        Period: period,\n\t        Stat: statistic\n\t      };\n", "    }\n\t    return [\n\t      {\n\t        Id: AVG_CPU,\n\t        MetricStat: metricStat('CPUUtilization', 'Average')\n\t      },\n\t      {\n\t        Id: MAX_CPU,\n\t        MetricStat: metricStat('CPUUtilization', 'Maximum')\n\t      },\n", "      {\n\t        Id: DISK_READ_OPS,\n\t        MetricStat: metricStat('DiskReadOps', 'Sum')\n\t      },\n\t      {\n\t        Id: DISK_WRITE_OPS,\n\t        MetricStat: metricStat('DiskWriteOps', 'Sum')\n\t      },\n\t      {\n\t        Id: MAX_NETWORK_BYTES_IN,\n", "        MetricStat: metricStat('NetworkIn', 'Maximum')\n\t      },\n\t      {\n\t        Id: MAX_NETWORK_BYTES_OUT,\n\t        MetricStat: metricStat('NetworkOut', 'Maximum')\n\t      },\n\t      {\n\t        Id: AVG_NETWORK_BYTES_IN,\n\t        MetricStat: metricStat('NetworkIn', 'Average')\n\t      },\n", "      {\n\t        Id: AVG_NETWORK_BYTES_OUT,\n\t        MetricStat: metricStat('NetworkOut', 'Average')\n\t      }\n\t    ];\n\t  }\n\t  private async getInstanceTypes (instanceTypeNames: string[], ec2Client: EC2): Promise<InstanceTypeInfo[]> {\n\t    const instanceTypes = [];\n\t    let nextToken;\n\t    do {\n", "      const instanceTypeResponse: DescribeInstanceTypesCommandOutput = await ec2Client.describeInstanceTypes({\n\t        InstanceTypes: instanceTypeNames,\n\t        NextToken: nextToken\n\t      });\n\t      const {\n\t        InstanceTypes = [],\n\t        NextToken\n\t      } = instanceTypeResponse;\n\t      instanceTypes.push(...InstanceTypes);\n\t      nextToken = NextToken;\n", "    } while (nextToken);\n\t    return instanceTypes;\n\t  }\n\t  private async getMetrics (args: {\n\t    instanceId: string;\n\t    startTime: Date;\n\t    endTime: Date; \n\t    period: number;\n\t    cwClient: CloudWatch;\n\t  }): Promise<{[ key: string ]: MetricDataResult}> {\n", "    const {\n\t      instanceId,\n\t      startTime,\n\t      endTime,\n\t      period,\n\t      cwClient\n\t    } = args;\n\t    const metrics: {[ key: string ]: MetricDataResult} = {};\n\t    let nextToken;\n\t    do {\n", "      const metricDataResponse = await cwClient.getMetricData({\n\t        MetricDataQueries: this.getMetricDataQueries(instanceId, period),\n\t        StartTime: startTime,\n\t        EndTime: endTime\n\t      });\n\t      const {\n\t        MetricDataResults,\n\t        NextToken\n\t      } = metricDataResponse || {};\n\t      MetricDataResults?.forEach((metricData: MetricDataResult) => {\n", "        const {\n\t          Id,\n\t          Timestamps = [],\n\t          Values = []\n\t        } = metricData;\n\t        if (!metrics[Id]) {\n\t          metrics[Id] = metricData;\n\t        } else {\n\t          metrics[Id].Timestamps.push(...Timestamps);\n\t          metrics[Id].Values.push(...Values);\n", "        }\n\t      });\n\t      nextToken = NextToken;\n\t    } while (nextToken);\n\t    return metrics;\n\t  }\n\t  private getInstanceNetworkSetting (networkSetting: string): number | string {\n\t    const numValue = networkSetting.split(' ').find(word => !Number.isNaN(Number(word)));\n\t    if (!isNil(numValue)) return Number(numValue);\n\t    return networkSetting;\n", "  }\n\t  async getRegionalUtilization (credentials: any, region: string, overrides?: AwsEc2InstanceUtilizationOverrides) {\n\t    const ec2Client = new EC2({\n\t      credentials,\n\t      region\n\t    });\n\t    const autoScalingClient = new AutoScaling({\n\t      credentials,\n\t      region\n\t    });\n", "    const cwClient = new CloudWatch({\n\t      credentials,\n\t      region\n\t    });\n\t    const pricingClient = new Pricing({\n\t      credentials,\n\t      region\n\t    });\n\t    this.instances = await this.describeAllInstances(ec2Client, overrides?.instanceIds);\n\t    const instanceIds = this.instances.map(i => i.InstanceId);\n", "    const idPartitions = chunk(instanceIds, 50);\n\t    for (const partition of idPartitions) {\n\t      const { AutoScalingInstances = [] } = await autoScalingClient.describeAutoScalingInstances({\n\t        InstanceIds: partition\n\t      });\n\t      const asgInstances = AutoScalingInstances.map(instance => instance.InstanceId);\n\t      this.instanceIds.push(\n\t        ...partition.filter(instanceId => !asgInstances.includes(instanceId))\n\t      );\n\t    }\n", "    this.instances = this.instances.filter(i => this.instanceIds.includes(i.InstanceId));\n\t    if (this.instances.length === 0) return;\n\t    const instanceTypeNames = this.instances.map(i => i.InstanceType);\n\t    const instanceTypes = await this.getInstanceTypes(instanceTypeNames, ec2Client);\n\t    const allInstanceTypes = Object.values(_InstanceType);\n\t    for (const instanceId of this.instanceIds) {\n\t      const instanceArn = Arns.Ec2(region, this.accountId, instanceId);\n\t      const instance = this.instances.find(i => i.InstanceId === instanceId);\n\t      const instanceType = instanceTypes.find(it => it.InstanceType === instance.InstanceType);\n\t      const instanceFamily = instanceType.InstanceType?.split('.')?.at(0);\n", "      const now = dayjs();\n\t      const startTime = now.subtract(2, 'weeks');\n\t      const fiveMinutes = 5 * 60;\n\t      const metrics = await this.getMetrics({\n\t        instanceId,\n\t        startTime: startTime.toDate(),\n\t        endTime: now.toDate(),\n\t        period: fiveMinutes,\n\t        cwClient\n\t      });\n", "      const {\n\t        [AVG_CPU]: avgCpuMetrics,\n\t        [MAX_CPU]: maxCpuMetrics,\n\t        [DISK_READ_OPS]: diskReadOps,\n\t        [DISK_WRITE_OPS]: diskWriteOps,\n\t        [MAX_NETWORK_BYTES_IN]: maxNetworkBytesIn,\n\t        [MAX_NETWORK_BYTES_OUT]: maxNetworkBytesOut,\n\t        [AVG_NETWORK_BYTES_IN]: avgNetworkBytesIn,\n\t        [AVG_NETWORK_BYTES_OUT]: avgNetworkBytesOut\n\t      } = metrics;\n", "      const { isStable: avgCpuIsStable } = getStabilityStats(avgCpuMetrics.Values);\n\t      const {\n\t        max: maxCpu,\n\t        isStable: maxCpuIsStable\n\t      } = getStabilityStats(maxCpuMetrics.Values);\n\t      const lowCpuUtilization = (\n\t        (avgCpuIsStable && maxCpuIsStable) ||\n\t        maxCpu < 10 // Source: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/UsingAlarmActions.html\n\t      );\n\t      const allDiskReads = stats.sum(diskReadOps.Values);\n", "      const allDiskWrites = stats.sum(diskWriteOps.Values);\n\t      const totalDiskIops = allDiskReads + allDiskWrites;\n\t      const { isStable: networkInIsStable, mean: networkInAvg } = getStabilityStats(avgNetworkBytesIn.Values);\n\t      const { isStable: networkOutIsStable, mean: networkOutAvg } = getStabilityStats(avgNetworkBytesOut.Values);\n\t      const avgNetworkThroughputMb = (networkInAvg + networkOutAvg) / (Math.pow(1024, 2));\n\t      const lowNetworkUtilization = (\n\t        (networkInIsStable && networkOutIsStable) || \n\t        // v Source: https://www.trendmicro.com/cloudoneconformity/knowledge-base/aws/EC2/idle-instance.html\n\t        (avgNetworkThroughputMb < 5) \n\t      );\n", "      const cost = await getInstanceCost(pricingClient, instanceType.InstanceType);\n\t      if (\n\t        lowCpuUtilization &&\n\t        totalDiskIops === 0 &&\n\t        lowNetworkUtilization\n\t      ) {\n\t        this.addScenario(instanceArn, 'unused', {\n\t          value: 'true',\n\t          delete: {\n\t            action: 'terminateInstance',\n", "            isActionable: true,\n\t            reason: 'This EC2 instance appears to be unused based on its CPU utilization, disk IOPS, ' +\n\t                    'and network traffic.', \n\t            monthlySavings: cost\n\t          }\n\t        });\n\t      } else {\n\t        // TODO: For burstable instance types, we need to factor in credit consumption and baseline utilization\n\t        const networkInMax = stats.max(maxNetworkBytesIn.Values);\n\t        const networkOutMax = stats.max(maxNetworkBytesOut.Values);\n", "        const optimizedVcpuCount = Math.ceil(maxCpu * instanceType.VCpuInfo.DefaultVCpus);\n\t        const minimumNetworkThroughput = Math.ceil((networkInMax + networkOutMax) / (Math.pow(1024, 3)));\n\t        const currentNetworkThroughput = this.getInstanceNetworkSetting(instanceType.NetworkInfo.NetworkPerformance);\n\t        const currentNetworkThroughputIsDefined = typeof currentNetworkThroughput === 'number';\n\t        const instanceTypeNamesInFamily = allInstanceTypes.filter(it => it.startsWith(`${instanceFamily}.`));\n\t        const cachedInstanceTypes = await cache.getOrElse(\n\t          instanceFamily, async () => JSON.stringify(await this.getInstanceTypes(instanceTypeNamesInFamily, ec2Client))\n\t        );\n\t        const instanceTypesInFamily = JSON.parse(cachedInstanceTypes || '[]');\n\t        const smallerInstances = instanceTypesInFamily.filter((it: InstanceTypeInfo) => {\n", "          const availableNetworkThroughput = this.getInstanceNetworkSetting(it.NetworkInfo.NetworkPerformance);\n\t          const availableNetworkThroughputIsDefined = typeof availableNetworkThroughput === 'number';\n\t          return (\n\t            it.VCpuInfo.DefaultVCpus >= optimizedVcpuCount &&\n\t            it.VCpuInfo.DefaultVCpus <= instanceType.VCpuInfo.DefaultVCpus\n\t          ) &&\n\t          (\n\t            (currentNetworkThroughputIsDefined && availableNetworkThroughputIsDefined) ?\n\t              (\n\t                availableNetworkThroughput >= minimumNetworkThroughput &&\n", "                availableNetworkThroughput <= currentNetworkThroughput\n\t              ) :\n\t              // Best we can do for t2 burstable network defs is find one that's the same because they're not\n\t              // quantifiable\n\t              currentNetworkThroughput === availableNetworkThroughput\n\t          );\n\t        }).sort((a: InstanceTypeInfo, b: InstanceTypeInfo) => {\n\t          const aNetwork = this.getInstanceNetworkSetting(a.NetworkInfo.NetworkPerformance);\n\t          const aNetworkIsNumeric = typeof aNetwork === 'number';\n\t          const bNetwork = this.getInstanceNetworkSetting(b.NetworkInfo.NetworkPerformance);\n", "          const bNetworkIsNumeric = typeof bNetwork === 'number';\n\t          const networkScore = (aNetworkIsNumeric && bNetworkIsNumeric) ?\n\t            (aNetwork < bNetwork ? -1 : 1) :\n\t            0;\n\t          const vCpuScore = a.VCpuInfo.DefaultVCpus < b.VCpuInfo.DefaultVCpus ? -1 : 1;\n\t          return networkScore + vCpuScore;\n\t        });\n\t        const targetInstanceType: InstanceTypeInfo | undefined = smallerInstances?.at(0);\n\t        if (targetInstanceType) {\n\t          const targetInstanceCost = await getInstanceCost(pricingClient, targetInstanceType.InstanceType);\n", "          const monthlySavings = cost - targetInstanceCost;\n\t          this.addScenario(instanceArn, 'overAllocated', {\n\t            value: 'overAllocated',\n\t            scaleDown: {\n\t              action: 'scaleDownInstance',\n\t              isActionable: false,\n\t              reason: 'This EC2 instance appears to be over allocated based on its CPU and network utilization.  We ' + \n\t                      `suggest scaling down to a ${targetInstanceType.InstanceType}`,\n\t              monthlySavings\n\t            }\n", "          });\n\t        }\n\t      }\n\t      await this.fillData(\n\t        instanceArn,\n\t        credentials,\n\t        region,\n\t        {\n\t          resourceId: instanceId,\n\t          region,\n", "          monthlyCost: cost,\n\t          hourlyCost: getHourlyCost(cost)\n\t        }\n\t      );\n\t      AwsEc2InstanceMetrics.forEach(async (metricName) => { \n\t        await this.getSidePanelMetrics(\n\t          credentials, \n\t          region, \n\t          instanceArn,\n\t          'AWS/EC2', \n", "          metricName, \n\t          [{ Name: 'InstanceId', Value: instanceId }]);\n\t      });\n\t    }\n\t  }\n\t  async getUtilization (\n\t    awsCredentialsProvider: AwsCredentialsProvider, regions?: string[], overrides?: AwsEc2InstanceUtilizationOverrides\n\t  ) {\n\t    const credentials = await awsCredentialsProvider.getCredentials();\n\t    this.accountId = await getAccountId(credentials);\n", "    for (const region of regions) {\n\t      await this.getRegionalUtilization(credentials, region, overrides);\n\t    }\n\t    // this.getEstimatedMaxMonthlySavings();\n\t  }\n\t  async terminateInstance (awsCredentialsProvider: AwsCredentialsProvider, instanceId: string, region: string) {\n\t    const credentials = await awsCredentialsProvider.getCredentials();\n\t    const ec2Client = new EC2({\n\t      credentials,\n\t      region\n", "    });\n\t    await ec2Client.terminateInstances({\n\t      InstanceIds: [instanceId]\n\t    });\n\t    // TODO: Remove scenario?\n\t  }\n\t  async scaleDownInstance (\n\t    awsCredentialsProvider: AwsCredentialsProvider, instanceId: string, region: string, instanceType: string\n\t  ) {\n\t    const credentials = await awsCredentialsProvider.getCredentials();\n", "    const ec2Client = new EC2({\n\t      credentials,\n\t      region\n\t    });\n\t    await ec2Client.modifyInstanceAttribute({\n\t      InstanceId: instanceId,\n\t      InstanceType: {\n\t        Value: instanceType\n\t      }\n\t    });\n", "  }\n\t}"]}
{"filename": "src/service-utilizations/aws-nat-gateway-utilization.ts", "chunked_list": ["import { CloudWatch } from '@aws-sdk/client-cloudwatch';\n\timport { DescribeNatGatewaysCommandOutput, EC2, NatGateway } from '@aws-sdk/client-ec2';\n\timport { Pricing } from '@aws-sdk/client-pricing';\n\timport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\n\timport get from 'lodash.get';\n\timport { Arns } from '../types/constants.js';\n\timport { AwsServiceOverrides } from '../types/types.js';\n\timport { getAccountId, getHourlyCost, rateLimitMap } from '../utils/utils.js';\n\timport { AwsServiceUtilization } from './aws-service-utilization.js';\n\t/**\n", " * const DEFAULT_RECOMMENDATION = 'review this NAT Gateway and the Route Tables associated with its VPC. If another' +\n\t * 'NAT Gateway exists in the VPC, repoint routes to that gateway and delete this gateway. If this is the only' +\n\t * 'NAT Gateway in your VPC and resources depend on network traffic, retain this gateway.';\n\t*/\n\ttype AwsNatGatewayUtilizationScenarioTypes = 'activeConnectionCount' | 'totalThroughput';\n\tconst AwsNatGatewayMetrics = ['ActiveConnectionCount', 'BytesInFromDestination'];\n\texport class AwsNatGatewayUtilization extends AwsServiceUtilization<AwsNatGatewayUtilizationScenarioTypes> {\n\t  accountId: string;\n\t  cost: number;\n\t  constructor () {\n", "    super();\n\t  }\n\t  async doAction (\n\t    awsCredentialsProvider: AwsCredentialsProvider, actionName: string, resourceArn: string, region: string\n\t  ): Promise<void> {\n\t    if (actionName === 'deleteNatGateway') {\n\t      const ec2Client = new EC2({\n\t        credentials: await awsCredentialsProvider.getCredentials(),\n\t        region\n\t      });\n", "      const resourceId = resourceArn.split('/')[1];\n\t      await this.deleteNatGateway(ec2Client, resourceId);\n\t    }\n\t  }\n\t  async deleteNatGateway (ec2Client: EC2, natGatewayId: string) {\n\t    await ec2Client.deleteNatGateway({\n\t      NatGatewayId: natGatewayId\n\t    });\n\t  }\n\t  private async getAllNatGateways (credentials: any, region: string) {\n", "    const ec2Client = new EC2({\n\t      credentials,\n\t      region\n\t    });\n\t    let allNatGateways: NatGateway[] = [];\n\t    let describeNatGatewaysRes: DescribeNatGatewaysCommandOutput;\n\t    do {\n\t      describeNatGatewaysRes = await ec2Client.describeNatGateways({\n\t        NextToken: describeNatGatewaysRes?.NextToken\n\t      });\n", "      allNatGateways = [...allNatGateways, ...describeNatGatewaysRes?.NatGateways || []];\n\t    } while (describeNatGatewaysRes?.NextToken);\n\t    return allNatGateways;\n\t  }\n\t  private async getNatGatewayMetrics (credentials: any, region: string, natGatewayId: string) {\n\t    const cwClient = new CloudWatch({\n\t      credentials,\n\t      region\n\t    });\n\t    const fiveMinutesAgo = new Date(Date.now() - (7 * 24 * 60 * 60 * 1000));\n", "    const metricDataRes = await cwClient.getMetricData({\n\t      MetricDataQueries: [\n\t        {\n\t          Id: 'activeConnectionCount',\n\t          MetricStat: {\n\t            Metric: {\n\t              Namespace: 'AWS/NATGateway',\n\t              MetricName: 'ActiveConnectionCount',\n\t              Dimensions: [{\n\t                Name: 'NatGatewayId',\n", "                Value: natGatewayId\n\t              }]\n\t            },\n\t            Period: 5 * 60, // 5 minutes\n\t            Stat: 'Maximum'\n\t          }\n\t        },\n\t        {\n\t          Id: 'bytesInFromDestination',\n\t          MetricStat: {\n", "            Metric: {\n\t              Namespace: 'AWS/NATGateway',\n\t              MetricName: 'BytesInFromDestination',\n\t              Dimensions: [{\n\t                Name: 'NatGatewayId',\n\t                Value: natGatewayId\n\t              }]\n\t            },\n\t            Period: 5 * 60, // 5 minutes\n\t            Stat: 'Sum'\n", "          }\n\t        },\n\t        {\n\t          Id: 'bytesInFromSource',\n\t          MetricStat: {\n\t            Metric: {\n\t              Namespace: 'AWS/NATGateway',\n\t              MetricName: 'BytesInFromSource',\n\t              Dimensions: [{\n\t                Name: 'NatGatewayId',\n", "                Value: natGatewayId\n\t              }]\n\t            },\n\t            Period: 5 * 60, // 5 minutes\n\t            Stat: 'Sum'\n\t          }\n\t        },\n\t        {\n\t          Id: 'bytesOutToDestination',\n\t          MetricStat: {\n", "            Metric: {\n\t              Namespace: 'AWS/NATGateway',\n\t              MetricName: 'BytesOutToDestination',\n\t              Dimensions: [{\n\t                Name: 'NatGatewayId',\n\t                Value: natGatewayId\n\t              }]\n\t            },\n\t            Period: 5 * 60, // 5 minutes\n\t            Stat: 'Sum'\n", "          }\n\t        },\n\t        {\n\t          Id: 'bytesOutToSource',\n\t          MetricStat: {\n\t            Metric: {\n\t              Namespace: 'AWS/NATGateway',\n\t              MetricName: 'BytesOutToSource',\n\t              Dimensions: [{\n\t                Name: 'NatGatewayId',\n", "                Value: natGatewayId\n\t              }]\n\t            },\n\t            Period: 5 * 60, // 5 minutes\n\t            Stat: 'Sum'\n\t          }\n\t        }\n\t      ],\n\t      StartTime: fiveMinutesAgo,\n\t      EndTime: new Date()\n", "    });\n\t    return metricDataRes.MetricDataResults;\n\t  }\n\t  private async getRegionalUtilization (credentials: any, region: string) {\n\t    const allNatGateways = await this.getAllNatGateways(credentials, region);\n\t    const analyzeNatGateway = async (natGateway: NatGateway) => {\n\t      const natGatewayId = natGateway.NatGatewayId;\n\t      const natGatewayArn = Arns.NatGateway(region, this.accountId, natGatewayId);\n\t      const results = await this.getNatGatewayMetrics(credentials, region, natGatewayId);\n\t      const activeConnectionCount = get(results, '[0].Values[0]') as number;\n", "      if (activeConnectionCount === 0) {\n\t        this.addScenario(natGatewayArn, 'activeConnectionCount', {\n\t          value: activeConnectionCount.toString(),\n\t          delete: {\n\t            action: 'deleteNatGateway',\n\t            isActionable: true,\n\t            reason: 'This NAT Gateway has had 0 active connections over the past week. It appears to be unused.',\n\t            monthlySavings: this.cost\n\t          }\n\t        });\n", "      }\n\t      const totalThroughput = \n\t        get(results, '[1].Values[0]', 0) + \n\t        get(results, '[2].Values[0]', 0) + \n\t        get(results, '[3].Values[0]', 0) +\n\t        get(results, '[4].Values[0]', 0);\n\t      if (totalThroughput === 0) {\n\t        this.addScenario(natGatewayArn, 'totalThroughput', {\n\t          value: totalThroughput.toString(),\n\t          delete: {\n", "            action: 'deleteNatGateway',\n\t            isActionable: true,\n\t            reason: 'This NAT Gateway has had 0 total throughput over the past week. It appears to be unused.',\n\t            monthlySavings: this.cost\n\t          }\n\t        });\n\t      }\n\t      await this.fillData(\n\t        natGatewayArn,\n\t        credentials,\n", "        region,\n\t        {\n\t          resourceId: natGatewayId,\n\t          region,\n\t          monthlyCost: this.cost,\n\t          hourlyCost: getHourlyCost(this.cost)\n\t        }\n\t      );\n\t      AwsNatGatewayMetrics.forEach(async (metricName) => {  \n\t        await this.getSidePanelMetrics(\n", "          credentials, \n\t          region, \n\t          natGatewayArn,\n\t          'AWS/NATGateway', \n\t          metricName, \n\t          [{ Name: 'NatGatewayId', Value: natGatewayId }]);\n\t      });\n\t    };\n\t    await rateLimitMap(allNatGateways, 5, 5, analyzeNatGateway);\n\t  }\n", "  async getUtilization (\n\t    awsCredentialsProvider: AwsCredentialsProvider, regions?: string[], _overrides?: AwsServiceOverrides\n\t  ) {\n\t    const credentials = await awsCredentialsProvider.getCredentials();\n\t    this.accountId = await getAccountId(credentials);\n\t    this.cost = await this.getNatGatewayPrice(credentials);  \n\t    for (const region of regions) {\n\t      await this.getRegionalUtilization(credentials, region);\n\t    }\n\t  }\n", "  private async getNatGatewayPrice (credentials: any) {\n\t    const pricingClient = new Pricing({\n\t      credentials,\n\t      // global but have to specify region\n\t      region: 'us-east-1'\n\t    });\n\t    const res = await pricingClient.getProducts({\n\t      ServiceCode: 'AmazonEC2',\n\t      Filters: [\n\t        {\n", "          Type: 'TERM_MATCH',\n\t          Field: 'productFamily',\n\t          Value: 'NAT Gateway'\n\t        },\n\t        {\n\t          Type: 'TERM_MATCH',\n\t          Field: 'usageType',\n\t          Value: 'NatGateway-Hours'\n\t        }\n\t      ]\n", "    });\n\t    const onDemandData = JSON.parse(res.PriceList[0] as string).terms.OnDemand;\n\t    const onDemandKeys = Object.keys(onDemandData);\n\t    const priceDimensionsData = onDemandData[onDemandKeys[0]].priceDimensions;\n\t    const priceDimensionsKeys = Object.keys(priceDimensionsData);\n\t    const pricePerHour = priceDimensionsData[priceDimensionsKeys[0]].pricePerUnit.USD;\n\t    // monthly cost\n\t    return pricePerHour * 24 * 30;\n\t  }\n\t}"]}
{"filename": "src/service-utilizations/aws-service-utilization-factory.ts", "chunked_list": ["import { awsAccountUtilization } from './aws-account-utilization.js';\n\timport { AwsCloudwatchLogsUtilization } from './aws-cloudwatch-logs-utilization.js';\n\timport { AwsNatGatewayUtilization } from './aws-nat-gateway-utilization.js';\n\timport { s3Utilization } from './aws-s3-utilization.js';\n\timport { ebsVolumesUtilization } from './ebs-volumes-utilization.js';\n\timport { rdsInstancesUtilization } from './rds-utilization.js';\n\timport HttpError from 'http-errors';\n\timport { AwsResourceType } from '../types/types.js';\n\timport { AwsResourceTypes } from '../types/constants.js';\n\timport { AwsEc2InstanceUtilization } from './aws-ec2-instance-utilization.js';\n", "import { AwsEcsUtilization } from './aws-ecs-utilization.js';\n\timport { AwsServiceUtilization } from './aws-service-utilization.js';\n\texport class AwsServiceUtilizationFactory {\n\t  static createObject (awsService: AwsResourceType): AwsServiceUtilization<string> {\n\t    switch (awsService) {\n\t      case AwsResourceTypes.CloudwatchLogs:\n\t        return new AwsCloudwatchLogsUtilization();\n\t      case AwsResourceTypes.S3Bucket: \n\t        return new s3Utilization(); \n\t      case AwsResourceTypes.RdsInstance: \n", "        return new rdsInstancesUtilization();\n\t      case AwsResourceTypes.Account: \n\t        return new awsAccountUtilization(); \n\t      case AwsResourceTypes.NatGateway: \n\t        return new AwsNatGatewayUtilization(); \n\t      case AwsResourceTypes.EbsVolume: \n\t        return new ebsVolumesUtilization();\n\t      case AwsResourceTypes.Ec2Instance:\n\t        return new AwsEc2InstanceUtilization();\n\t      case AwsResourceTypes.EcsService:\n", "        return new AwsEcsUtilization();\n\t      default:\n\t        throw HttpError.BadRequest(`${awsService} is not supported!`);\n\t    }\n\t  }\n\t}"]}
{"filename": "src/service-utilizations/aws-ecs-utilization.ts", "chunked_list": ["import cached from 'cached';\n\timport dayjs from 'dayjs';\n\timport chunk from 'lodash.chunk';\n\timport * as stats from 'simple-statistics';\n\timport HttpError from 'http-errors';\n\timport { AwsCredentialsProvider } from '@tinystacks/ops-aws-core-widgets';\n\timport {\n\t  ContainerInstance,\n\t  DesiredStatus,\n\t  ECS,\n", "  LaunchType,\n\t  ListClustersCommandOutput,\n\t  ListServicesCommandOutput,\n\t  ListTasksCommandOutput,\n\t  Service,\n\t  Task,\n\t  TaskDefinition,\n\t  TaskDefinitionField,\n\t  DescribeContainerInstancesCommandOutput\n\t} from '@aws-sdk/client-ecs';\n", "import {\n\t  CloudWatch,\n\t  MetricDataQuery,\n\t  MetricDataResult\n\t} from '@aws-sdk/client-cloudwatch';\n\timport { ElasticLoadBalancingV2 } from '@aws-sdk/client-elastic-load-balancing-v2';\n\timport {\n\t  Api,\n\t  ApiGatewayV2,\n\t  GetApisCommandOutput,\n", "  Integration\n\t} from '@aws-sdk/client-apigatewayv2';\n\timport {\n\t  DescribeInstanceTypesCommandOutput,\n\t  EC2,\n\t  InstanceTypeInfo,\n\t  _InstanceType\n\t} from '@aws-sdk/client-ec2';\n\timport { getStabilityStats } from '../utils/stats.js';\n\timport {\n", "  AVG_CPU,\n\t  MAX_CPU,\n\t  MAX_MEMORY,\n\t  AVG_MEMORY,\n\t  ALB_REQUEST_COUNT,\n\t  APIG_REQUEST_COUNT\n\t} from '../types/constants.js';\n\timport { AwsServiceUtilization } from './aws-service-utilization.js';\n\timport { AwsServiceOverrides } from '../types/types.js';\n\timport { getInstanceCost } from '../utils/ec2-utils.js';\n", "import { Pricing } from '@aws-sdk/client-pricing';\n\timport { getHourlyCost } from '../utils/utils.js';\n\timport get from 'lodash.get';\n\timport isEmpty from 'lodash.isempty';\n\tconst cache = cached<string>('ecs-util-cache', {\n\t  backend: {\n\t    type: 'memory'\n\t  }\n\t});\n\ttype AwsEcsUtilizationScenarioTypes = 'unused' | 'overAllocated';\n", "const AwsEcsMetrics = ['CPUUtilization', 'MemoryUtilization'];\n\ttype EcsService = {\n\t  clusterArn: string;\n\t  serviceArn: string;\n\t}\n\ttype ClusterServices = {\n\t  [clusterArn: string]: {\n\t    serviceArns: string[];\n\t  }\n\t}\n", "type FargateScaleRange = {\n\t  min: number;\n\t  max: number;\n\t  increment: number;\n\t};\n\ttype FargateScaleOption = {\n\t  [cpu: number]: {\n\t    discrete?: number[];\n\t    range?: FargateScaleRange;\n\t  }\n", "}\n\ttype FargateScale = {\n\t  cpu: number,\n\t  memory: number\n\t}\n\ttype AwsEcsUtilizationOverrides = AwsServiceOverrides & {\n\t  services: EcsService[];\n\t}\n\texport class AwsEcsUtilization extends AwsServiceUtilization<AwsEcsUtilizationScenarioTypes> {\n\t  serviceArns: string[];\n", "  services: Service[];\n\t  ecsClient: ECS;\n\t  ec2Client: EC2;\n\t  cwClient: CloudWatch;\n\t  elbV2Client: ElasticLoadBalancingV2;\n\t  apigClient: ApiGatewayV2;\n\t  pricingClient: Pricing;\n\t  serviceCosts: { [ service: string ]: number };\n\t  DEBUG_MODE: boolean;\n\t  constructor (enableDebugMode?: boolean) {\n", "    super();\n\t    this.serviceArns = [];\n\t    this.services = [];\n\t    this.serviceCosts = {};\n\t    this.DEBUG_MODE = enableDebugMode || false;\n\t  }\n\t  async doAction (\n\t    awsCredentialsProvider: AwsCredentialsProvider, actionName: string, resourceArn: string, region: string\n\t  ): Promise<void> {\n\t    if (actionName === 'deleteService') {\n", "      await this.deleteService(awsCredentialsProvider, resourceArn.split('/')[1], resourceArn, region);\n\t    }\n\t  }\n\t  private async listAllClusters (): Promise<string[]> {\n\t    const allClusterArns: string[] = [];\n\t    let nextToken;\n\t    do {\n\t      const response: ListClustersCommandOutput = await this.ecsClient.listClusters({\n\t        nextToken\n\t      });\n", "      const {\n\t        clusterArns = [],\n\t        nextToken: nextClusterToken\n\t      } = response || {};\n\t      allClusterArns.push(...clusterArns);\n\t      nextToken = nextClusterToken;\n\t    } while (nextToken);\n\t    return allClusterArns;\n\t  }\n\t  private async listServicesForClusters (clusterArn: string): Promise<ClusterServices> {\n", "    const services: string[] = [];\n\t    let nextToken;\n\t    do {\n\t      const response: ListServicesCommandOutput = await this.ecsClient.listServices({\n\t        cluster: clusterArn,\n\t        nextToken\n\t      });\n\t      const {\n\t        serviceArns = [],\n\t        nextToken: nextServicesToken\n", "      } = response || {};\n\t      services.push(...serviceArns);\n\t      nextToken = nextServicesToken;\n\t    } while (nextToken);\n\t    return {\n\t      [clusterArn]: {\n\t        serviceArns: services\n\t      }\n\t    };\n\t  }\n", "  private async describeAllServices (): Promise<Service[]> {\n\t    const clusterArns = await this.listAllClusters();\n\t    const allServices: EcsService[] = [];\n\t    for (const clusterArn of clusterArns) {\n\t      const servicesForCluster = await this.listServicesForClusters(clusterArn);\n\t      allServices.push(...servicesForCluster[clusterArn].serviceArns.map(s => ({\n\t        clusterArn,\n\t        serviceArn: s\n\t      })));\n\t    }\n", "    return this.describeTheseServices(allServices);\n\t  }\n\t  private async describeTheseServices (ecsServices: EcsService[]): Promise<Service[]> {\n\t    const clusters = ecsServices.reduce<ClusterServices>((acc, ecsService) => {\n\t      acc[ecsService.clusterArn] = acc[ecsService.clusterArn] || {\n\t        serviceArns: []\n\t      };\n\t      acc[ecsService.clusterArn].serviceArns.push(ecsService.serviceArn);\n\t      return acc;\n\t    }, {});\n", "    const services: Service[] = [];\n\t    for (const [clusterArn, clusterServices] of Object.entries(clusters)) {\n\t      const serviceChunks = chunk(clusterServices.serviceArns, 10);\n\t      for (const serviceChunk of serviceChunks) {\n\t        const response = await this.ecsClient.describeServices({\n\t          cluster: clusterArn,\n\t          services: serviceChunk\n\t        });\n\t        services.push(...(response?.services || []));\n\t      }\n", "    }\n\t    return services;\n\t  }\n\t  private async getLoadBalacerArnForService (service: Service): Promise<string> {\n\t    const response = await this.elbV2Client.describeTargetGroups({\n\t      TargetGroupArns: [service.loadBalancers?.at(0)?.targetGroupArn]\n\t    });\n\t    return response?.TargetGroups?.at(0)?.LoadBalancerArns?.at(0);\n\t  }\n\t  private async findIntegration (apiId: string, registryArn: string): Promise<Integration | undefined> {\n", "    let nextToken: string;\n\t    let registeredIntegration: Integration;\n\t    do {\n\t      const response = await this.apigClient.getIntegrations({\n\t        ApiId: apiId,\n\t        NextToken: nextToken\n\t      });\n\t      const {\n\t        Items = [],\n\t        NextToken\n", "      } = response || {};\n\t      registeredIntegration = Items.find(i => i.IntegrationUri === registryArn);\n\t      if (!registeredIntegration) {\n\t        nextToken = NextToken;\n\t      }\n\t    } while (nextToken);\n\t    return registeredIntegration;\n\t  }\n\t  private async findRegisteredApi (service: Service, apis: Api[]): Promise<Api | undefined> {\n\t    const registryArn = service.serviceRegistries?.at(0)?.registryArn;\n", "    let registeredApi: Api;\n\t    for (const api of apis) {\n\t      const registeredIntegration = await this.findIntegration(api.ApiId, registryArn);\n\t      if (registeredIntegration) {\n\t        registeredApi = api;\n\t        break;\n\t      }\n\t    }\n\t    return registeredApi;\n\t  }\n", "  private async getApiIdForService (service: Service): Promise<string> {\n\t    let nextToken: string;\n\t    let registeredApi: Api;\n\t    do {\n\t      const apiResponse: GetApisCommandOutput = await this.apigClient.getApis({ NextToken: nextToken });\n\t      const {\n\t        Items = [],\n\t        NextToken\n\t      } = apiResponse || {};\n\t      registeredApi = await this.findRegisteredApi(service, Items);\n", "      if (!registeredApi) {\n\t        nextToken = NextToken;\n\t      }    \n\t    } while (nextToken);\n\t    return registeredApi.ApiId;\n\t  }\n\t  private async getTask (service: Service): Promise<Task> {\n\t    const taskListResponse = await this.ecsClient.listTasks({\n\t      cluster: service.clusterArn,\n\t      serviceName: service.serviceName,\n", "      maxResults: 1,\n\t      desiredStatus: DesiredStatus.RUNNING\n\t    });\n\t    const {\n\t      taskArns = []\n\t    } = taskListResponse || {};\n\t    const describeTasksResponse = await this.ecsClient.describeTasks({\n\t      cluster: service.clusterArn,\n\t      tasks: [taskArns.at(0)]\n\t    });\n", "    const task = describeTasksResponse?.tasks?.at(0);\n\t    return task;\n\t  }\n\t  private async getAllTasks (service: Service): Promise<Task[]> {\n\t    const taskIds = [];\n\t    let nextTaskToken;\n\t    do {\n\t      const taskListResponse: ListTasksCommandOutput = await this.ecsClient.listTasks({\n\t        cluster: service.clusterArn,\n\t        serviceName: service.serviceName,\n", "        desiredStatus: DesiredStatus.RUNNING,\n\t        nextToken: nextTaskToken\n\t      });\n\t      const {\n\t        taskArns = [],\n\t        nextToken\n\t      } = taskListResponse || {};\n\t      taskIds.push(...taskArns);\n\t      nextTaskToken = nextToken;\n\t    } while (nextTaskToken);\n", "    const allTasks = [];\n\t    const taskIdPartitions = chunk(taskIds, 100);\n\t    for (const taskIdPartition of taskIdPartitions) {\n\t      const describeTasksResponse = await this.ecsClient.describeTasks({\n\t        cluster: service.clusterArn,\n\t        tasks: taskIdPartition\n\t      });\n\t      const {\n\t        tasks = []\n\t      } = describeTasksResponse;\n", "      allTasks.push(...tasks);\n\t    }\n\t    return allTasks;\n\t  }\n\t  private async getInstanceFamilyForContainerInstance (containerInstance: ContainerInstance): Promise<string> {\n\t    const ec2InstanceResponse = await this.ec2Client.describeInstances({\n\t      InstanceIds: [containerInstance.ec2InstanceId]\n\t    });\n\t    const instanceType = ec2InstanceResponse?.Reservations?.at(0)?.Instances?.at(0)?.InstanceType;\n\t    const instanceFamily = instanceType?.split('.')?.at(0);\n", "    return instanceFamily;\n\t  }\n\t  private async getInstanceTypes (instanceTypeNames: string[]): Promise<InstanceTypeInfo[]> {\n\t    const instanceTypes = [];\n\t    let nextToken;\n\t    do {\n\t      const instanceTypeResponse: DescribeInstanceTypesCommandOutput = await this.ec2Client.describeInstanceTypes({\n\t        InstanceTypes: instanceTypeNames,\n\t        NextToken: nextToken\n\t      });\n", "      const {\n\t        InstanceTypes = [],\n\t        NextToken\n\t      } = instanceTypeResponse;\n\t      instanceTypes.push(...InstanceTypes);\n\t      nextToken = NextToken;\n\t    } while (nextToken);\n\t    return instanceTypes;\n\t  }\n\t  private getEcsServiceDataQueries (serviceName: string, clusterName: string, period: number): MetricDataQuery[] {\n", "    function metricStat (metricName: string, statistic: string) {\n\t      return {\n\t        Metric: {\n\t          Namespace: 'AWS/ECS',\n\t          MetricName: metricName,\n\t          Dimensions: [\n\t            {\n\t              Name: 'ServiceName',\n\t              Value: serviceName\n\t            },\n", "            {\n\t              Name: 'ClusterName',\n\t              Value: clusterName\n\t            }\n\t          ]\n\t        },\n\t        Period: period,\n\t        Stat: statistic\n\t      };\n\t    }\n", "    return [\n\t      {\n\t        Id: AVG_CPU,\n\t        MetricStat: metricStat('CPUUtilization', 'Average')\n\t      },\n\t      {\n\t        Id: MAX_CPU,\n\t        MetricStat: metricStat('CPUUtilization', 'Maximum')\n\t      },\n\t      {\n", "        Id: AVG_MEMORY,\n\t        MetricStat: metricStat('MemoryUtilization', 'Average')\n\t      },\n\t      {\n\t        Id: MAX_MEMORY,\n\t        MetricStat: metricStat('MemoryUtilization', 'Maximum')\n\t      }\n\t    ];\n\t  }\n\t  private getAlbRequestCountQuery (loadBalancerArn: string, period: number): MetricDataQuery {\n", "    return {\n\t      Id: ALB_REQUEST_COUNT,\n\t      MetricStat: {\n\t        Metric: {\n\t          Namespace: 'AWS/ApplicationELB',\n\t          MetricName: 'RequestCount',\n\t          Dimensions: [\n\t            {\n\t              Name: 'ServiceName',\n\t              Value: loadBalancerArn\n", "            }\n\t          ]\n\t        },\n\t        Period: period,\n\t        Stat: 'Sum'\n\t      }\n\t    };\n\t  }\n\t  private getApigRequestCountQuery (apiId: string, period: number): MetricDataQuery {\n\t    return {\n", "      Id: APIG_REQUEST_COUNT,\n\t      MetricStat: {\n\t        Metric: {\n\t          Namespace: 'AWS/ApiGateway',\n\t          MetricName: 'Count',\n\t          Dimensions: [\n\t            {\n\t              Name: 'ApiId',\n\t              Value: apiId\n\t            }\n", "          ]\n\t        },\n\t        Period: period,\n\t        Stat: 'Sum'\n\t      }\n\t    };\n\t  }\n\t  private async getMetrics (args: {\n\t    service: Service,\n\t    startTime: Date;\n", "    endTime: Date; \n\t    period: number;\n\t  }): Promise<{[ key: string ]: MetricDataResult}> {\n\t    const {\n\t      service,\n\t      startTime,\n\t      endTime,\n\t      period\n\t    } = args;\n\t    const {\n", "      serviceName,\n\t      clusterArn,\n\t      loadBalancers,\n\t      serviceRegistries\n\t    } = service;\n\t    const clusterName = clusterArn?.split('/').pop();\n\t    const queries: MetricDataQuery[] = this.getEcsServiceDataQueries(serviceName, clusterName, period);\n\t    if (loadBalancers && loadBalancers.length > 0) {\n\t      const loadBalancerArn = await this.getLoadBalacerArnForService(service);\n\t      queries.push(this.getAlbRequestCountQuery(loadBalancerArn, period));\n", "    } else if (serviceRegistries && serviceRegistries.length > 0) {\n\t      const apiId = await this.getApiIdForService(service);\n\t      queries.push(this.getApigRequestCountQuery(apiId, period));\n\t    }\n\t    const metrics: {[ key: string ]: MetricDataResult} = {};\n\t    let nextToken;\n\t    do {\n\t      const metricDataResponse = await this.cwClient.getMetricData({\n\t        MetricDataQueries: queries,\n\t        StartTime: startTime,\n", "        EndTime: endTime\n\t      });\n\t      const {\n\t        MetricDataResults,\n\t        NextToken\n\t      } = metricDataResponse || {};\n\t      MetricDataResults?.forEach((metricData: MetricDataResult) => {\n\t        const {\n\t          Id,\n\t          Timestamps = [],\n", "          Values = []\n\t        } = metricData;\n\t        if (!metrics[Id]) {\n\t          metrics[Id] = metricData;\n\t        } else {\n\t          metrics[Id].Timestamps.push(...Timestamps);\n\t          metrics[Id].Values.push(...Values);\n\t        }\n\t      });\n\t      nextToken = NextToken;\n", "    } while (nextToken);\n\t    return metrics;\n\t  }\n\t  private createDiscreteValuesForRange (range: FargateScaleRange): number[] {\n\t    const {\n\t      min,\n\t      max,\n\t      increment\n\t    } = range;\n\t    const discreteVales: number[] = [];\n", "    let i = min;\n\t    do {\n\t      i = i + increment;\n\t      discreteVales.push(i);\n\t    } while (i <= max);\n\t    return discreteVales;\n\t  }\n\t  private async getEc2ContainerInfo (service: Service) {\n\t    const tasks = await this.getAllTasks(service);\n\t    const taskCpu = Number(tasks.at(0)?.cpu);\n", "    const allocatedMemory = Number(tasks.at(0)?.memory);\n\t    let allocatedCpu = taskCpu;\n\t    let containerInstance: ContainerInstance;\n\t    let containerInstanceResponse: DescribeContainerInstancesCommandOutput;\n\t    if (!taskCpu || taskCpu === 0) {\n\t      const containerInstanceTaskGroupObject = tasks.reduce<{\n\t        [containerInstanceArn: string]: {\n\t          containerInstanceArn: string;\n\t          tasks: Task[];\n\t        }\n", "      }>((acc, task) => {\n\t        const { containerInstanceArn } = task;\n\t        acc[containerInstanceArn] = acc[containerInstanceArn] || {\n\t          containerInstanceArn,\n\t          tasks: []\n\t        };\n\t        acc[containerInstanceArn].tasks.push(task);\n\t        return acc;\n\t      }, {});\n\t      const containerInstanceTaskGroups  = Object.values(containerInstanceTaskGroupObject);\n", "      containerInstanceTaskGroups.sort((a, b) => {\n\t        if (a.tasks.length > b.tasks.length) {\n\t          return -1;\n\t        } else if (a.tasks.length < b.tasks.length) {\n\t          return 1;\n\t        }\n\t        return 0;\n\t      });\n\t      const largestContainerInstance = containerInstanceTaskGroups.at(0);\n\t      const maxTaskCount = get(largestContainerInstance, 'tasks.length') || 0;\n", "      const filteredTaskGroups = containerInstanceTaskGroups\n\t        .filter(taskGroup => !isEmpty(taskGroup.containerInstanceArn));\n\t      if (isEmpty(filteredTaskGroups)) {\n\t        return undefined;\n\t      } else {\n\t        containerInstanceResponse = await this.ecsClient.describeContainerInstances({\n\t          cluster: service.clusterArn,\n\t          containerInstances: containerInstanceTaskGroups.map(taskGroup => taskGroup.containerInstanceArn)\n\t        });\n\t        // largest container instance\n", "        containerInstance = containerInstanceResponse?.containerInstances?.at(0);\n\t        const containerInstanceCpuResource = containerInstance.registeredResources?.find(r => r.name === 'CPU');\n\t        const containerInstanceCpu = Number(\n\t          containerInstanceCpuResource?.doubleValue || containerInstanceCpuResource?.integerValue\n\t          || containerInstanceCpuResource?.longValue\n\t        );\n\t        allocatedCpu = containerInstanceCpu / maxTaskCount;\n\t      }\n\t    } else {\n\t      containerInstanceResponse = await this.ecsClient.describeContainerInstances({\n", "        cluster: service.clusterArn,\n\t        containerInstances: tasks.map(task => task.containerInstanceArn)\n\t      });\n\t      containerInstance = containerInstanceResponse?.containerInstances?.at(0);\n\t    }\n\t    const uniqueEc2Instances = containerInstanceResponse.containerInstances.reduce<Set<string>>((acc, instance) => {\n\t      acc.add(instance.ec2InstanceId);\n\t      return acc;\n\t    }, new Set<string>());\n\t    const numEc2Instances = uniqueEc2Instances.size;\n", "    const instanceType = containerInstance.attributes.find(attr => attr.name === 'ecs.instance-type')?.value;\n\t    const monthlyInstanceCost = await getInstanceCost(this.pricingClient, instanceType);\n\t    const monthlyCost = monthlyInstanceCost * numEc2Instances;\n\t    this.serviceCosts[service.serviceName] = monthlyCost;\n\t    return {\n\t      allocatedCpu,\n\t      allocatedMemory,\n\t      containerInstance,\n\t      instanceType,\n\t      monthlyCost,\n", "      numEc2Instances\n\t    };\n\t  }\n\t  private async checkForEc2ScaleDown (service: Service, maxCpuPercentage: number, maxMemoryPercentage: number) {\n\t    const info = await this.getEc2ContainerInfo(service);\n\t    if (!info) {\n\t      return;\n\t    }\n\t    const {\n\t      allocatedCpu,\n", "      allocatedMemory,\n\t      containerInstance,\n\t      instanceType,\n\t      monthlyCost,\n\t      numEc2Instances\n\t    } = info;\n\t    const maxConsumedVcpus = (maxCpuPercentage * allocatedCpu) / 1024;\n\t    const maxConsumedMemory = maxMemoryPercentage * allocatedMemory;\n\t    const instanceVcpus = allocatedCpu / 1024;\n\t    let instanceFamily = instanceType?.split('.')?.at(0);\n", "    if (!instanceFamily) {\n\t      instanceFamily = await this.getInstanceFamilyForContainerInstance(containerInstance);\n\t    }\n\t    const allInstanceTypes = Object.values(_InstanceType);\n\t    const instanceTypeNamesInFamily = allInstanceTypes.filter(it => it.startsWith(`${instanceFamily}.`));\n\t    const cachedInstanceTypes = await cache.getOrElse(\n\t      instanceFamily, async () => JSON.stringify(await this.getInstanceTypes(instanceTypeNamesInFamily))\n\t    );\n\t    const instanceTypesInFamily = JSON.parse(cachedInstanceTypes || '[]');\n\t    const smallerInstances = instanceTypesInFamily.filter((it: InstanceTypeInfo) => {\n", "      const betterFitCpu = (\n\t        it.VCpuInfo.DefaultVCpus >= maxConsumedVcpus &&\n\t        it.VCpuInfo.DefaultVCpus <= instanceVcpus\n\t      );\n\t      const betterFitMemory = (\n\t        it.MemoryInfo.SizeInMiB >= maxConsumedMemory &&\n\t        it.MemoryInfo.SizeInMiB <= allocatedMemory\n\t      );\n\t      return betterFitCpu && betterFitMemory;\n\t    }).sort((a: InstanceTypeInfo, b: InstanceTypeInfo) => {\n", "      const vCpuScore = a.VCpuInfo.DefaultVCpus < b.VCpuInfo.DefaultVCpus ? -1 : 1;\n\t      const memoryScore = a.MemoryInfo.SizeInMiB < b.MemoryInfo.SizeInMiB ? -1 : 1;\n\t      return memoryScore + vCpuScore;\n\t    });\n\t    const targetInstanceType: InstanceTypeInfo | undefined = smallerInstances?.at(0);\n\t    if (targetInstanceType) {\n\t      const targetMonthlyInstanceCost = await getInstanceCost(this.pricingClient, targetInstanceType.InstanceType);\n\t      const targetMonthlyCost = targetMonthlyInstanceCost * numEc2Instances;\n\t      this.addScenario(service.serviceArn, 'overAllocated', {\n\t        value: 'true',\n", "        scaleDown: {\n\t          action: 'scaleDownEc2Service',\n\t          isActionable: false,\n\t          reason: 'The EC2 instances used in this Service\\'s cluster appears to be over allocated based on its CPU' + \n\t                  `and Memory utilization.  We suggest scaling down to a ${targetInstanceType.InstanceType}.`,\n\t          monthlySavings: monthlyCost - targetMonthlyCost\n\t        }\n\t      });\n\t    }\n\t  }\n", "  private calculateFargateCost (platform: string, cpuArch: string, vcpu: number, memory: number, numTasks: number) {\n\t    let monthlyCost = 0;\n\t    if (platform.toLowerCase() === 'windows') {\n\t      monthlyCost = (((0.09148 + 0.046) * vcpu) + (0.01005 * memory)) * numTasks * 24 * 30;\n\t    } else {\n\t      if (cpuArch === 'x86_64') {\n\t        monthlyCost = ((0.04048 * vcpu) + (0.004445 * memory)) * numTasks * 24 * 30; \n\t      } else {\n\t        monthlyCost = ((0.03238 * vcpu) + (0.00356 * memory)) * numTasks * 24 * 30;\n\t      }\n", "    }\n\t    return monthlyCost;\n\t  }\n\t  private async getFargateInfo (service: Service) {\n\t    const tasks = await this.getAllTasks(service);\n\t    const numTasks = tasks.length;\n\t    const task = tasks.at(0);\n\t    const allocatedCpu = Number(task?.cpu);\n\t    const allocatedMemory = Number(task?.memory);\n\t    const platform = task.platformFamily || '';\n", "    const cpuArch = (task.attributes.find(attr => attr.name === 'ecs.cpu-architecture'))?.value || 'x86_64';\n\t    const vcpu = allocatedCpu / 1024;\n\t    const memory = allocatedMemory / 1024;\n\t    const monthlyCost = this.calculateFargateCost(platform, cpuArch, vcpu, memory, numTasks);\n\t    this.serviceCosts[service.serviceName] = monthlyCost;\n\t    return {\n\t      allocatedCpu,\n\t      allocatedMemory,\n\t      platform,\n\t      cpuArch,\n", "      numTasks,\n\t      monthlyCost\n\t    }; \n\t  }\n\t  private async checkForFargateScaleDown (service: Service, maxCpuPercentage: number, maxMemoryPercentage: number) {\n\t    // Source:  https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-cpu-memory-error.html\n\t    const fargateScaleOptions: FargateScaleOption = {\n\t      256: {\n\t        discrete: [0.5, 1, 2]\n\t      },\n", "      512: {\n\t        range: {\n\t          min: 1,\n\t          max: 4,\n\t          increment: 1\n\t        }\n\t      },\n\t      1024: {\n\t        range: {\n\t          min: 2,\n", "          max: 8,\n\t          increment: 1\n\t        }\n\t      },\n\t      2048: {\n\t        range: {\n\t          min: 4,\n\t          max: 16,\n\t          increment: 1\n\t        }\n", "      },\n\t      4096: {\n\t        range: {\n\t          min: 8,\n\t          max: 30,\n\t          increment: 1\n\t        }\n\t      },\n\t      8192: {\n\t        range: {\n", "          min: 16,\n\t          max: 60,\n\t          increment: 4\n\t        }\n\t      },\n\t      16384: {\n\t        range: {\n\t          min: 32,\n\t          max: 120,\n\t          increment: 4\n", "        }\n\t      }\n\t    };\n\t    const {\n\t      allocatedCpu,\n\t      allocatedMemory,\n\t      platform,\n\t      cpuArch,\n\t      numTasks,\n\t      monthlyCost\n", "    } = await this.getFargateInfo(service);\n\t    const maxConsumedCpu = maxCpuPercentage * allocatedCpu;\n\t    const maxConsumedMemory = maxMemoryPercentage * allocatedMemory;\n\t    const lowerCpuOptions = Object.keys(fargateScaleOptions).filter((cpuString) => {\n\t      const cpu = Number(cpuString);\n\t      return cpu < allocatedCpu && cpu > maxConsumedCpu; \n\t    }).sort();\n\t    let targetScaleOption: FargateScale;\n\t    for (const cpuOption of lowerCpuOptions) {\n\t      const scalingOption = fargateScaleOptions[Number(cpuOption)];\n", "      const memoryOptionValues = [];\n\t      const discreteMemoryOptionValues = scalingOption.discrete || [];\n\t      memoryOptionValues.push(...discreteMemoryOptionValues);\n\t      const rangeMemoryOptionsValues = scalingOption.range ?\n\t        this.createDiscreteValuesForRange(scalingOption.range) : [];\n\t      memoryOptionValues.push(...rangeMemoryOptionsValues);\n\t      const optimizedMemory = memoryOptionValues.filter(mem => (mem > maxConsumedMemory)).sort().at(0);\n\t      if (optimizedMemory) {\n\t        targetScaleOption = {\n\t          cpu: Number(cpuOption),\n", "          memory: (optimizedMemory * 1024)\n\t        };\n\t        break;\n\t      }\n\t    }\n\t    if (targetScaleOption) {\n\t      const targetMonthlyCost = this.calculateFargateCost(\n\t        platform, \n\t        cpuArch, \n\t        targetScaleOption.cpu / 1024,\n", "        targetScaleOption.memory / 1024,\n\t        numTasks\n\t      );\n\t      this.addScenario(service.serviceArn, 'overAllocated', {\n\t        value: 'overAllocated',\n\t        scaleDown: {\n\t          action: 'scaleDownFargateService',\n\t          isActionable: false,\n\t          reason: 'This ECS service appears to be over allocated based on its CPU, Memory, and network utilization. ' +\n\t                  `We suggest scaling the CPU down to ${targetScaleOption.cpu} and the Memory to ` +\n", "                  `${targetScaleOption.memory} MiB.`,\n\t          monthlySavings: monthlyCost - targetMonthlyCost\n\t        }\n\t      });\n\t    }\n\t  }\n\t  async getRegionalUtilization (credentials: any, region: string, overrides?: AwsEcsUtilizationOverrides) {\n\t    this.ecsClient = new ECS({\n\t      credentials,\n\t      region\n", "    });\n\t    this.ec2Client = new EC2({\n\t      credentials,\n\t      region\n\t    });\n\t    this.cwClient = new CloudWatch({\n\t      credentials,\n\t      region\n\t    });\n\t    this.elbV2Client = new ElasticLoadBalancingV2({\n", "      credentials,\n\t      region\n\t    });\n\t    this.apigClient = new ApiGatewayV2({\n\t      credentials,\n\t      region\n\t    });\n\t    this.pricingClient = new Pricing({\n\t      credentials,\n\t      region\n", "    });\n\t    if (overrides?.services) {\n\t      this.services = await this.describeTheseServices(overrides?.services);\n\t    } else {\n\t      this.services = await this.describeAllServices();\n\t    }\n\t    if (this.services.length === 0) return;\n\t    for (const service of this.services) {\n\t      const now = dayjs();\n\t      const startTime = now.subtract(2, 'weeks');\n", "      const fiveMinutes = 5 * 60;\n\t      const metrics = await this.getMetrics({\n\t        service,\n\t        startTime: startTime.toDate(),\n\t        endTime: now.toDate(),\n\t        period: fiveMinutes\n\t      });\n\t      const {\n\t        [AVG_CPU]: avgCpuMetrics,\n\t        [MAX_CPU]: maxCpuMetrics,\n", "        [AVG_MEMORY]: avgMemoryMetrics,\n\t        [MAX_MEMORY]: maxMemoryMetrics,\n\t        [ALB_REQUEST_COUNT]: albRequestCountMetrics,\n\t        [APIG_REQUEST_COUNT]: apigRequestCountMetrics\n\t      } = metrics;\n\t      const { isStable: avgCpuIsStable } = getStabilityStats(avgCpuMetrics.Values);\n\t      const {\n\t        max: maxCpu,\n\t        isStable: maxCpuIsStable\n\t      } = getStabilityStats(maxCpuMetrics.Values);\n", "      const lowCpuUtilization = (\n\t        (avgCpuIsStable && maxCpuIsStable) ||\n\t        maxCpu < 10 // Source: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/UsingAlarmActions.html\n\t      );\n\t      const { isStable: avgMemoryIsStable } = getStabilityStats(avgMemoryMetrics.Values);\n\t      const {\n\t        max: maxMemory,\n\t        isStable: maxMemoryIsStable\n\t      } = getStabilityStats(maxMemoryMetrics.Values);\n\t      const lowMemoryUtilization = (\n", "        (avgMemoryIsStable && maxMemoryIsStable) ||\n\t        maxMemory < 10\n\t      );\n\t      const requestCountMetricValues = [\n\t        ...(albRequestCountMetrics?.Values || []), ...(apigRequestCountMetrics?.Values || [])\n\t      ];\n\t      const totalRequestCount = stats.sum(requestCountMetricValues);\n\t      const noNetworkUtilization = totalRequestCount === 0;\n\t      if (\n\t        lowCpuUtilization &&\n", "        lowMemoryUtilization &&\n\t        noNetworkUtilization\n\t      ) {\n\t        const info = service.launchType === LaunchType.FARGATE ? \n\t          await this.getFargateInfo(service) : \n\t          await this.getEc2ContainerInfo(service);\n\t        if (!info) {\n\t          return;\n\t        }\n\t        const { monthlyCost } = info;\n", "        this.addScenario(service.serviceArn, 'unused', {\n\t          value: 'true',\n\t          delete: {\n\t            action: 'deleteService',\n\t            isActionable: true,\n\t            reason: 'This ECS service appears to be unused based on its CPU utilizaiton, Memory utilizaiton, and'\n\t                  + ' network traffic.',\n\t            monthlySavings: monthlyCost\n\t          }\n\t        });\n", "      } else if (maxCpu < 0.8 && maxMemory < 0.8) {\n\t        if (service.launchType === LaunchType.FARGATE) {\n\t          await this.checkForFargateScaleDown(service, maxCpu, maxMemory);\n\t        } else {\n\t          await this.checkForEc2ScaleDown(service, maxCpu, maxMemory);\n\t        }\n\t      }\n\t      const monthlyCost = this.serviceCosts[service.serviceName] || 0;\n\t      await this.fillData(\n\t        service.serviceArn,\n", "        credentials,\n\t        region,\n\t        {\n\t          resourceId: service.serviceName,\n\t          region,\n\t          monthlyCost,\n\t          hourlyCost: getHourlyCost(monthlyCost)\n\t        }\n\t      );\n\t      AwsEcsMetrics.forEach(async (metricName) => { \n", "        await this.getSidePanelMetrics(\n\t          credentials, \n\t          region, \n\t          service.serviceArn,  \n\t          'AWS/ECS', \n\t          metricName, \n\t          [{\n\t            Name: 'ServiceName',\n\t            Value: service.serviceName\n\t          },\n", "          {\n\t            Name: 'ClusterName',\n\t            Value: service.clusterArn?.split('/').pop()\n\t          }]);\n\t      });\n\t    }\n\t    console.info('this.utilization:\\n', JSON.stringify(this.utilization, null, 2));\n\t  }\n\t  async getUtilization (\n\t    awsCredentialsProvider: AwsCredentialsProvider, regions?: string[], overrides?: AwsEcsUtilizationOverrides\n", "  ) {\n\t    const credentials = await awsCredentialsProvider.getCredentials();\n\t    for (const region of regions) {\n\t      await this.getRegionalUtilization(credentials, region, overrides);\n\t    }\n\t  }\n\t  async deleteService (\n\t    awsCredentialsProvider: AwsCredentialsProvider, clusterName: string, serviceArn: string, region: string\n\t  ) {\n\t    const credentials = await awsCredentialsProvider.getCredentials();\n", "    const ecsClient = new ECS({\n\t      credentials,\n\t      region\n\t    });\n\t    await ecsClient.deleteService({\n\t      service: serviceArn,\n\t      cluster: clusterName\n\t    });\n\t  }\n\t  async scaleDownFargateService (\n", "    awsCredentialsProvider: AwsCredentialsProvider, clusterName: string, serviceArn: string, region: string,\n\t    cpu: number, memory: number\n\t  ) {\n\t    const credentials = await awsCredentialsProvider.getCredentials();\n\t    const ecsClient = new ECS({\n\t      credentials,\n\t      region\n\t    });\n\t    const serviceResponse = await ecsClient.describeServices({\n\t      cluster: clusterName,\n", "      services: [serviceArn]\n\t    });\n\t    const taskDefinitionArn = serviceResponse?.services?.at(0)?.taskDefinition;\n\t    const taskDefResponse = await ecsClient.describeTaskDefinition(\n\t      { taskDefinition: taskDefinitionArn, include: [TaskDefinitionField.TAGS]  }\n\t    );\n\t    const taskDefinition: TaskDefinition = taskDefResponse?.taskDefinition;\n\t    const tags = taskDefResponse?.tags;    \n\t    const {\n\t      containerDefinitions,\n", "      family,\n\t      ephemeralStorage,\n\t      executionRoleArn,\n\t      inferenceAccelerators,\n\t      ipcMode,\n\t      networkMode,\n\t      pidMode,\n\t      placementConstraints,\n\t      proxyConfiguration,\n\t      requiresCompatibilities,\n", "      runtimePlatform,\n\t      taskRoleArn,\n\t      volumes\n\t    } = taskDefinition;\n\t    // TODO: CPU and Memory validation?\n\t    const revisionResponse = await ecsClient.registerTaskDefinition({\n\t      cpu: cpu.toString(),\n\t      memory: memory.toString(),\n\t      containerDefinitions,\n\t      family,\n", "      ephemeralStorage,\n\t      executionRoleArn,\n\t      inferenceAccelerators,\n\t      ipcMode,\n\t      networkMode,\n\t      pidMode,\n\t      placementConstraints,\n\t      proxyConfiguration,\n\t      requiresCompatibilities,\n\t      runtimePlatform,\n", "      taskRoleArn,\n\t      volumes,\n\t      tags\n\t    });\n\t    await ecsClient.updateService({\n\t      cluster: clusterName,\n\t      service: serviceArn,\n\t      taskDefinition: revisionResponse?.taskDefinition?.taskDefinitionArn,\n\t      forceNewDeployment: true\n\t    });\n", "  }\n\t  async scaleDownEc2Service (_serviceArn: string, _cpu: number, _memory: number) {\n\t    /*\n\t      TODO:\n\t        Update Asg/Capacity provider? Or update memory/cpu allocation on the tasks? Or both?\n\t     */\n\t    throw HttpError.NotImplemented('Automatic scale down for EC2 backed ECS Clusters is not yet supported.');\n\t  }\n\t}"]}
