{"filename": "examples/worker/src/handler.ts", "chunked_list": ["import { trace } from '@opentelemetry/api'\n\texport interface Env {\n\t\tOTEL_TEST: KVNamespace\n\t\tTest_Otel_DO: DurableObjectNamespace\n\t\t'otel.exporter.headers.x-honeycomb-team': string\n\t}\n\tconst handleDO = async (request: Request, env: Env): Promise<Response> => {\n\t\tconst ns = env.Test_Otel_DO\n\t\tconst id = ns.idFromName('testing')\n\t\tconst stub = ns.get(id)\n", "\treturn await stub.fetch('https://does-not-exist.com/blah')\n\t}\n\tconst handleRest = async (request: Request, env: Env, ctx: ExecutionContext): Promise<Response> => {\n\t\tawait fetch('https://cloudflare.com')\n\t\tconst cache = await caches.open('stuff')\n\t\tconst promises = [env.OTEL_TEST.get('non-existant'), cache.match(new Request('https://no-exist.com'))]\n\t\tawait Promise.all(promises)\n\t\tconst greeting = \"G'day World\"\n\t\ttrace.getActiveSpan()?.setAttribute('greeting', greeting)\n\t\tctx.waitUntil(fetch('https://workers.dev'))\n", "\treturn new Response(`${greeting}!`)\n\t}\n\texport default {\n\t\tasync fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\n\t\t\tconst pathname = new URL(request.url).pathname\n\t\t\tif (pathname === '/do') {\n\t\t\t\treturn handleDO(request, env)\n\t\t\t} else if (pathname === '/error') {\n\t\t\t\tthrow new Error('You asked for it!')\n\t\t\t} else {\n", "\t\t\treturn handleRest(request, env, ctx)\n\t\t\t}\n\t\t},\n\t}\n\texport class OtelDO implements DurableObject {\n\t\tconstructor(protected state: DurableObjectState, protected env: Env) {\n\t\t\tstate.blockConcurrencyWhile(async () => {\n\t\t\t\tawait this.state.storage.getAlarm()\n\t\t\t})\n\t\t}\n", "\tasync fetch(request: Request): Promise<Response> {\n\t\t\tawait fetch('https://cloudflare.com')\n\t\t\tawait this.state.storage.put('something', 'else')\n\t\t\tawait this.state.storage.setAlarm(Date.now() + 1000)\n\t\t\treturn new Response('Hello World!')\n\t\t}\n\t\tasync alarm(): Promise<void> {\n\t\t\tconsole.log('ding ding!')\n\t\t\tawait this.state.storage.get('something')\n\t\t\tawait this.state.storage.get('something_else')\n", "\t}\n\t}\n"]}
{"filename": "examples/worker/src/index.ts", "chunked_list": ["import { instrument, instrumentDO, ResolveConfigFn } from '../../../src/index'\n\timport handler, { Env, OtelDO } from './handler'\n\tconst config: ResolveConfigFn = (env: Env, _trigger) => {\n\t\treturn {\n\t\t\texporter: {\n\t\t\t\turl: 'https://api.honeycomb.io/v1/traces',\n\t\t\t\theaders: { 'x-honeycomb-team': env['otel.exporter.headers.x-honeycomb-team'] },\n\t\t\t},\n\t\t\tservice: {\n\t\t\t\tname: 'greetings',\n", "\t\t\tversion: '0.1',\n\t\t\t},\n\t\t}\n\t}\n\tconst doConfig: ResolveConfigFn = (env: Env, _trigger) => {\n\t\treturn {\n\t\t\texporter: {\n\t\t\t\turl: 'https://api.honeycomb.io/v1/traces',\n\t\t\t\theaders: { 'x-honeycomb-team': env['otel.exporter.headers.x-honeycomb-team'] },\n\t\t\t},\n", "\t\tservice: { name: 'greetings-do' },\n\t\t}\n\t}\n\tconst TestOtelDO = instrumentDO(OtelDO, doConfig)\n\texport default instrument(handler, config)\n\texport { TestOtelDO }\n"]}
{"filename": "examples/queue/src/index.ts", "chunked_list": ["import { instrument, ResolveConfigFn } from '../../../src/index'\n\tinterface QueueData {\n\t\tpathname: string\n\t}\n\texport interface Env {\n\t\tQUEUE: Queue<QueueData>\n\t\tAPI_KEY: string\n\t}\n\tconst handler: ExportedHandler<Env, QueueData> = {\n\t\tasync fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\n", "\t\tconst url = new URL(request.url)\n\t\t\tawait env.QUEUE.send({ pathname: url.pathname })\n\t\t\treturn new Response('Hello World!')\n\t\t},\n\t\tasync queue(batch: MessageBatch<QueueData>, env: Env, ctx: ExecutionContext) {\n\t\t\tfor (const message of batch.messages) {\n\t\t\t\tconsole.log(message.body.pathname)\n\t\t\t\tmessage.ack()\n\t\t\t}\n\t\t},\n", "}\n\tconst config: ResolveConfigFn = (env: Env, trigger) => {\n\t\treturn {\n\t\t\texporter: {\n\t\t\t\turl: 'https://api.honeycomb.io/v1/traces',\n\t\t\t\theaders: { 'x-honeycomb-team': env.API_KEY },\n\t\t\t},\n\t\t\tservice: {\n\t\t\t\tname: 'greetings',\n\t\t\t\tversion: '0.1',\n", "\t\t},\n\t\t}\n\t}\n\texport default instrument(handler, config)\n"]}
{"filename": "src/spanprocessor.ts", "chunked_list": ["import { Context, Span } from '@opentelemetry/api'\n\timport { ReadableSpan, SpanExporter, SpanProcessor } from '@opentelemetry/sdk-trace-base'\n\timport { ExportResult, ExportResultCode } from '@opentelemetry/core'\n\timport { Action, State, stateMachine } from 'ts-checked-fsm'\n\timport { getActiveConfig } from './config.js'\n\timport { TailSampleFn } from './sampling.js'\n\timport { PostProcessorFn } from './types.js'\n\ttype CompletedTrace = {\n\t\ttraceId: string\n\t\tlocalRootSpan: ReadableSpan\n", "\tcompletedSpans: ReadableSpan[]\n\t}\n\ttype InProgressTrace = {\n\t\tinProgressSpanIds: Set<string>\n\t} & CompletedTrace\n\ttype InitialState = State<'not_started'>\n\ttype InProgressTraceState = State<'in_progress', InProgressTrace>\n\ttype TraceCompleteState = State<'trace_complete', CompletedTrace>\n\ttype ExportingState = State<'exporting', { promise: Promise<ExportResult> }>\n\ttype DoneState = State<'done'>\n", "type StartExportArguments = {\n\t\texporter: SpanExporter\n\t\ttailSampler: TailSampleFn\n\t\tpostProcessor: PostProcessorFn\n\t}\n\ttype StartSpanAction = Action<'startSpan', { span: Span }>\n\ttype EndSpanAction = Action<'endSpan', { span: ReadableSpan }>\n\ttype StartExportAction = Action<'startExport', { args: StartExportArguments }>\n\tfunction newTrace(currentState: InitialState, { span }: StartSpanAction): InProgressTraceState {\n\t\tconst spanId = span.spanContext().spanId\n", "\treturn {\n\t\t\t...currentState,\n\t\t\tstateName: 'in_progress',\n\t\t\ttraceId: span.spanContext().traceId,\n\t\t\tlocalRootSpan: span as unknown as ReadableSpan,\n\t\t\tcompletedSpans: [] as ReadableSpan[],\n\t\t\tinProgressSpanIds: new Set([spanId]),\n\t\t} as const\n\t}\n\tfunction newSpan(currentState: InProgressTraceState, { span }: StartSpanAction): InProgressTraceState {\n", "\tconst spanId = span.spanContext().spanId\n\t\tcurrentState.inProgressSpanIds.add(spanId)\n\t\treturn { ...currentState }\n\t}\n\tfunction endSpan(\n\t\tcurrentState: InProgressTraceState,\n\t\t{ span }: EndSpanAction\n\t): InProgressTraceState | TraceCompleteState {\n\t\tcurrentState.completedSpans.push(span)\n\t\tcurrentState.inProgressSpanIds.delete(span.spanContext().spanId)\n", "\tif (currentState.inProgressSpanIds.size === 0) {\n\t\t\treturn {\n\t\t\t\tstateName: 'trace_complete',\n\t\t\t\ttraceId: currentState.traceId,\n\t\t\t\tlocalRootSpan: currentState.localRootSpan,\n\t\t\t\tcompletedSpans: currentState.completedSpans,\n\t\t\t} as const\n\t\t} else {\n\t\t\treturn { ...currentState }\n\t\t}\n", "}\n\tfunction startExport(currentState: TraceCompleteState, { args }: StartExportAction): ExportingState | DoneState {\n\t\tconst { exporter, tailSampler, postProcessor } = args\n\t\tconst { traceId, localRootSpan, completedSpans: spans } = currentState\n\t\tconst shouldExport = tailSampler({ traceId, localRootSpan, spans })\n\t\tif (shouldExport) {\n\t\t\tconst exportSpans = postProcessor(spans)\n\t\t\tconst promise = new Promise<ExportResult>((resolve) => {\n\t\t\t\texporter.export(exportSpans, resolve)\n\t\t\t})\n", "\t\treturn { stateName: 'exporting', promise }\n\t\t} else {\n\t\t\treturn { stateName: 'done' }\n\t\t}\n\t}\n\tconst { nextState } = stateMachine()\n\t\t.state('not_started')\n\t\t.state<'in_progress', InProgressTraceState>('in_progress')\n\t\t.state<'trace_complete', TraceCompleteState>('trace_complete')\n\t\t.state<'exporting', ExportingState>('exporting')\n", "\t.state('done')\n\t\t.transition('not_started', 'in_progress')\n\t\t.transition('in_progress', 'in_progress')\n\t\t.transition('in_progress', 'trace_complete')\n\t\t.transition('trace_complete', 'exporting')\n\t\t.transition('trace_complete', 'done')\n\t\t.transition('exporting', 'done')\n\t\t.action<'startSpan', StartSpanAction>('startSpan')\n\t\t.action<'endSpan', EndSpanAction>('endSpan')\n\t\t.action<'startExport', StartExportAction>('startExport')\n", "\t.action('exportDone')\n\t\t.actionHandler('not_started', 'startSpan', newTrace)\n\t\t.actionHandler('in_progress', 'startSpan', newSpan)\n\t\t.actionHandler('in_progress', 'endSpan', endSpan)\n\t\t.actionHandler('trace_complete', 'startExport', startExport)\n\t\t.actionHandler('exporting', 'exportDone', (_c, _a) => {\n\t\t\treturn { stateName: 'done' } as const\n\t\t})\n\t\t.done()\n\ttype AnyTraceState = Parameters<typeof nextState>[0]\n", "type AnyTraceAction = Parameters<typeof nextState>[1]\n\texport class BatchTraceSpanProcessor implements SpanProcessor {\n\t\tprivate traces: Map<string, AnyTraceState> = new Map()\n\t\tprivate inprogressExports: Map<string, Promise<ExportResult>> = new Map()\n\t\tprivate action(traceId: string, action: AnyTraceAction): AnyTraceState {\n\t\t\tconst state = this.traces.get(traceId) || { stateName: 'not_started' }\n\t\t\tconst newState = nextState(state, action)\n\t\t\tif (newState.stateName === 'done') {\n\t\t\t\tthis.traces.delete(traceId)\n\t\t\t} else {\n", "\t\t\tthis.traces.set(traceId, newState)\n\t\t\t}\n\t\t\treturn newState\n\t\t}\n\t\tprivate export(traceId: string) {\n\t\t\tconst { exporter, sampling, postProcessor } = getActiveConfig()\n\t\t\tconst exportArgs = { exporter, tailSampler: sampling.tailSampler, postProcessor }\n\t\t\tconst newState = this.action(traceId, { actionName: 'startExport', args: exportArgs })\n\t\t\tif (newState.stateName === 'exporting') {\n\t\t\t\tconst promise = newState.promise\n", "\t\t\tthis.inprogressExports.set(traceId, promise)\n\t\t\t\tpromise.then((result) => {\n\t\t\t\t\tif (result.code === ExportResultCode.FAILED) {\n\t\t\t\t\t\tconsole.log('Error sending spans to exporter:', result.error)\n\t\t\t\t\t}\n\t\t\t\t\tthis.action(traceId, { actionName: 'exportDone' })\n\t\t\t\t\tthis.inprogressExports.delete(traceId)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n", "\tonStart(span: Span, _parentContext: Context): void {\n\t\t\tconst traceId = span.spanContext().traceId\n\t\t\tthis.action(traceId, { actionName: 'startSpan', span })\n\t\t}\n\t\tonEnd(span: ReadableSpan): void {\n\t\t\tconst traceId = span.spanContext().traceId\n\t\t\tconst state = this.action(traceId, { actionName: 'endSpan', span })\n\t\t\tif (state.stateName === 'trace_complete') {\n\t\t\t\tthis.export(traceId)\n\t\t\t}\n", "\t}\n\t\tasync forceFlush(): Promise<void> {\n\t\t\tawait Promise.allSettled(this.inprogressExports.values())\n\t\t}\n\t\tasync shutdown(): Promise<void> {}\n\t}\n"]}
{"filename": "src/buffer.ts", "chunked_list": ["//@ts-ignore\n\timport { Buffer } from 'node:buffer'\n\t//@ts-ignore\n\tglobalThis.Buffer = Buffer\n"]}
{"filename": "src/wrap.ts", "chunked_list": ["const unwrapSymbol = Symbol('unwrap')\n\ttype Wrapped<T> = { [unwrapSymbol]: T } & T\n\texport function isWrapped<T>(item: T): item is Wrapped<T> {\n\t\treturn !!(item as Wrapped<T>)[unwrapSymbol]\n\t}\n\texport function wrap<T extends object>(item: T, handler: ProxyHandler<T>, autoPassthrough: boolean = true): T {\n\t\tif (isWrapped(item)) {\n\t\t\treturn item\n\t\t}\n\t\tconst proxyHandler = Object.assign({}, handler)\n", "\tproxyHandler.get = (target, prop, receiver) => {\n\t\t\tif (prop === unwrapSymbol) {\n\t\t\t\treturn item\n\t\t\t} else {\n\t\t\t\tif (handler.get) {\n\t\t\t\t\treturn handler.get(target, prop, receiver)\n\t\t\t\t} else if (autoPassthrough) {\n\t\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t\t}\n\t\t\t}\n", "\t}\n\t\tproxyHandler.apply = (target, thisArg, argArray) => {\n\t\t\tif (handler.apply) {\n\t\t\t\treturn handler.apply(unwrap(target), unwrap(thisArg), argArray)\n\t\t\t}\n\t\t}\n\t\treturn new Proxy(item, proxyHandler)\n\t}\n\texport function unwrap<T extends object>(item: T): T {\n\t\tif (item && isWrapped(item)) {\n", "\t\treturn item[unwrapSymbol]\n\t\t} else {\n\t\t\treturn item\n\t\t}\n\t}\n\texport function passthroughGet(target: any, prop: string | symbol, thisArg?: any) {\n\t\tconst value = Reflect.get(unwrap(target), prop)\n\t\tif (typeof value === 'function') {\n\t\t\tthisArg = thisArg || unwrap(target)\n\t\t\tconst bound = value.bind(thisArg)\n", "\t\treturn bound\n\t\t} else {\n\t\t\treturn value\n\t\t}\n\t}\n"]}
{"filename": "src/tracer.ts", "chunked_list": ["import {\n\t\tTracer,\n\t\tTraceFlags,\n\t\tSpan,\n\t\tSpanKind,\n\t\tSpanOptions,\n\t\tContext,\n\t\tcontext as api_context,\n\t\ttrace,\n\t} from '@opentelemetry/api'\n", "import { sanitizeAttributes } from '@opentelemetry/core'\n\timport { Resource } from '@opentelemetry/resources'\n\timport { SpanProcessor, RandomIdGenerator, ReadableSpan, SamplingDecision } from '@opentelemetry/sdk-trace-base'\n\timport { SpanImpl } from './span.js'\n\timport { getActiveConfig } from './config.js'\n\texport class WorkerTracer implements Tracer {\n\t\tprivate readonly _spanProcessor: SpanProcessor\n\t\tprivate readonly resource: Resource\n\t\tprivate readonly idGenerator: RandomIdGenerator = new RandomIdGenerator()\n\t\tconstructor(spanProcessor: SpanProcessor, resource: Resource) {\n", "\t\tthis._spanProcessor = spanProcessor\n\t\t\tthis.resource = resource\n\t\t}\n\t\tget spanProcessor() {\n\t\t\treturn this._spanProcessor\n\t\t}\n\t\taddToResource(extra: Resource) {\n\t\t\tthis.resource.merge(extra)\n\t\t}\n\t\tstartSpan(name: string, options: SpanOptions = {}, context = api_context.active()): Span {\n", "\t\tif (options.root) {\n\t\t\t\tcontext = trace.deleteSpan(context)\n\t\t\t}\n\t\t\tconst parentSpan = trace.getSpan(context)\n\t\t\tconst parentSpanContext = parentSpan?.spanContext()\n\t\t\tconst hasParentContext = parentSpanContext && trace.isSpanContextValid(parentSpanContext)\n\t\t\tconst traceId = hasParentContext ? parentSpanContext.traceId : this.idGenerator.generateTraceId()\n\t\t\tconst spanKind = options.kind || SpanKind.INTERNAL\n\t\t\tconst sanitisedAttrs = sanitizeAttributes(options.attributes)\n\t\t\tconst sampler = getActiveConfig().sampling.headSampler\n", "\t\tconst samplingDecision = sampler.shouldSample(context, traceId, name, spanKind, sanitisedAttrs, [])\n\t\t\tconst { decision, traceState, attributes: attrs } = samplingDecision\n\t\t\tconst attributes = Object.assign({}, sanitisedAttrs, attrs)\n\t\t\tconst spanId = this.idGenerator.generateSpanId()\n\t\t\tconst parentSpanId = hasParentContext ? parentSpanContext.spanId : undefined\n\t\t\tconst traceFlags = decision === SamplingDecision.RECORD_AND_SAMPLED ? TraceFlags.SAMPLED : TraceFlags.NONE\n\t\t\tconst spanContext = { traceId, spanId, traceFlags, traceState }\n\t\t\tconst span = new SpanImpl({\n\t\t\t\tattributes,\n\t\t\t\tname,\n", "\t\t\tonEnd: (span) => {\n\t\t\t\t\tthis.spanProcessor.onEnd(span as unknown as ReadableSpan)\n\t\t\t\t},\n\t\t\t\tresource: this.resource,\n\t\t\t\tspanContext,\n\t\t\t\tparentSpanId,\n\t\t\t\tspanKind,\n\t\t\t\tstartTime: options.startTime,\n\t\t\t})\n\t\t\t//Do not get me started on the idosyncracies of the Otel JS libraries.\n", "\t\t//@ts-ignore\n\t\t\tthis.spanProcessor.onStart(span, context)\n\t\t\treturn span\n\t\t}\n\t\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(name: string, fn: F): ReturnType<F>\n\t\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(name: string, options: SpanOptions, fn: F): ReturnType<F>\n\t\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(\n\t\t\tname: string,\n\t\t\toptions: SpanOptions,\n\t\t\tcontext: Context,\n", "\t\tfn: F\n\t\t): ReturnType<F>\n\t\tstartActiveSpan<F extends (span: Span) => ReturnType<F>>(name: string, ...args: unknown[]): ReturnType<F> {\n\t\t\tconst options = args.length > 1 ? (args[0] as SpanOptions) : undefined\n\t\t\tconst parentContext = args.length > 2 ? (args[1] as Context) : api_context.active()\n\t\t\tconst fn = args[args.length - 1] as F\n\t\t\tconst span = this.startSpan(name, options, parentContext)\n\t\t\tconst contextWithSpanSet = trace.setSpan(parentContext, span)\n\t\t\treturn api_context.with(contextWithSpanSet, fn, undefined, span)\n\t\t}\n", "}\n"]}
{"filename": "src/sampling.ts", "chunked_list": ["import { TraceFlags, SpanStatusCode } from '@opentelemetry/api'\n\timport { ReadableSpan } from '@opentelemetry/sdk-trace-base'\n\texport interface LocalTrace {\n\t\treadonly traceId: string\n\t\treadonly localRootSpan: ReadableSpan\n\t\treadonly spans: ReadableSpan[]\n\t}\n\texport type TailSampleFn = (traceInfo: LocalTrace) => boolean\n\texport function multiTailSampler(samplers: TailSampleFn[]): TailSampleFn {\n\t\treturn (traceInfo) => {\n", "\t\treturn samplers.reduce((result, sampler) => result || sampler(traceInfo), false)\n\t\t}\n\t}\n\texport const isHeadSampled: TailSampleFn = (traceInfo) => {\n\t\tconst localRootSpan = traceInfo.localRootSpan as unknown as ReadableSpan\n\t\treturn localRootSpan.spanContext().traceFlags === TraceFlags.SAMPLED\n\t}\n\texport const isRootErrorSpan: TailSampleFn = (traceInfo) => {\n\t\tconst localRootSpan = traceInfo.localRootSpan as unknown as ReadableSpan\n\t\treturn localRootSpan.status.code === SpanStatusCode.ERROR\n", "}\n"]}
{"filename": "src/sdk.ts", "chunked_list": ["import { propagation } from '@opentelemetry/api'\n\timport { W3CTraceContextPropagator } from '@opentelemetry/core'\n\timport { Resource } from '@opentelemetry/resources'\n\timport { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions'\n\timport {\n\t\tAlwaysOnSampler,\n\t\tParentBasedSampler,\n\t\tReadableSpan,\n\t\tSampler,\n\t\tSpanExporter,\n", "\tTraceIdRatioBasedSampler,\n\t} from '@opentelemetry/sdk-trace-base'\n\timport { Initialiser } from './config.js'\n\timport { OTLPExporter } from './exporter.js'\n\timport { WorkerTracerProvider } from './provider.js'\n\timport { isHeadSampled, isRootErrorSpan, multiTailSampler } from './sampling.js'\n\timport { BatchTraceSpanProcessor } from './spanprocessor.js'\n\timport { Trigger, TraceConfig, ResolvedTraceConfig, ExporterConfig, ParentRatioSamplingConfig } from './types.js'\n\timport { unwrap } from './wrap.js'\n\timport { createFetchHandler, instrumentGlobalFetch } from './instrumentation/fetch.js'\n", "import { instrumentGlobalCache } from './instrumentation/cache.js'\n\timport { createQueueHandler } from './instrumentation/queue.js'\n\timport { DOClass, instrumentDOClass } from './instrumentation/do.js'\n\ttype FetchHandler = ExportedHandlerFetchHandler<unknown, unknown>\n\ttype QueueHandler = ExportedHandlerQueueHandler\n\texport type ResolveConfigFn = (env: any, trigger: Trigger) => TraceConfig\n\texport type ConfigurationOption = TraceConfig | ResolveConfigFn\n\texport function isRequest(trigger: Trigger): trigger is Request {\n\t\treturn trigger instanceof Request\n\t}\n", "export function isMessageBatch(trigger: Trigger): trigger is MessageBatch {\n\t\treturn !!(trigger as MessageBatch).ackAll\n\t}\n\texport function isAlarm(trigger: Trigger): trigger is 'do-alarm' {\n\t\treturn trigger === 'do-alarm'\n\t}\n\tconst createResource = (config: ResolvedTraceConfig): Resource => {\n\t\tconst workerResourceAttrs = {\n\t\t\t[SemanticResourceAttributes.CLOUD_PROVIDER]: 'cloudflare',\n\t\t\t[SemanticResourceAttributes.CLOUD_PLATFORM]: 'cloudflare.workers',\n", "\t\t[SemanticResourceAttributes.CLOUD_REGION]: 'earth',\n\t\t\t// [SemanticResourceAttributes.FAAS_NAME]: '//TODO',\n\t\t\t// [SemanticResourceAttributes.FAAS_VERSION]: '//TODO',\n\t\t\t[SemanticResourceAttributes.FAAS_MAX_MEMORY]: 128,\n\t\t\t[SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE]: 'JavaScript',\n\t\t\t[SemanticResourceAttributes.TELEMETRY_SDK_NAME]: '@microlabs/otel-workers-sdk',\n\t\t}\n\t\tconst serviceResource = new Resource({\n\t\t\t[SemanticResourceAttributes.SERVICE_NAME]: config.service.name,\n\t\t\t[SemanticResourceAttributes.SERVICE_NAMESPACE]: config.service.namespace,\n", "\t\t[SemanticResourceAttributes.SERVICE_VERSION]: config.service.version,\n\t\t})\n\t\tconst resource = new Resource(workerResourceAttrs)\n\t\treturn resource.merge(serviceResource)\n\t}\n\tfunction isSpanExporter(exporterConfig: ExporterConfig): exporterConfig is SpanExporter {\n\t\treturn !!(exporterConfig as SpanExporter).export\n\t}\n\tlet initialised = false\n\tfunction init(config: ResolvedTraceConfig): void {\n", "\tif (!initialised) {\n\t\t\tinstrumentGlobalCache()\n\t\t\tinstrumentGlobalFetch()\n\t\t\tpropagation.setGlobalPropagator(new W3CTraceContextPropagator())\n\t\t\tconst resource = createResource(config)\n\t\t\tconst spanProcessor = new BatchTraceSpanProcessor()\n\t\t\tconst provider = new WorkerTracerProvider(spanProcessor, resource)\n\t\t\tprovider.register()\n\t\t\tinitialised = true\n\t\t}\n", "}\n\tfunction isSampler(sampler: Sampler | ParentRatioSamplingConfig): sampler is Sampler {\n\t\treturn !!(sampler as Sampler).shouldSample\n\t}\n\tfunction createSampler(conf: ParentRatioSamplingConfig): Sampler {\n\t\tconst ratioSampler = new TraceIdRatioBasedSampler(conf.ratio)\n\t\tif (typeof conf.acceptRemote === 'boolean' && !conf.acceptRemote) {\n\t\t\treturn new ParentBasedSampler({\n\t\t\t\troot: ratioSampler,\n\t\t\t\tremoteParentSampled: ratioSampler,\n", "\t\t\tremoteParentNotSampled: ratioSampler,\n\t\t\t})\n\t\t} else {\n\t\t\treturn new ParentBasedSampler({ root: ratioSampler })\n\t\t}\n\t}\n\tfunction parseConfig(supplied: TraceConfig): ResolvedTraceConfig {\n\t\tconst headSampleConf = supplied.sampling?.headSampler\n\t\tconst headSampler = headSampleConf\n\t\t\t? isSampler(headSampleConf)\n", "\t\t\t? headSampleConf\n\t\t\t\t: createSampler(headSampleConf)\n\t\t\t: new AlwaysOnSampler()\n\t\treturn {\n\t\t\texporter: isSpanExporter(supplied.exporter) ? supplied.exporter : new OTLPExporter(supplied.exporter),\n\t\t\tfetch: {\n\t\t\t\tincludeTraceContext: supplied.fetch?.includeTraceContext ?? true,\n\t\t\t},\n\t\t\thandlers: {\n\t\t\t\tfetch: {\n", "\t\t\t\tacceptTraceContext: supplied.handlers?.fetch?.acceptTraceContext ?? true,\n\t\t\t\t},\n\t\t\t},\n\t\t\tpostProcessor: supplied.postProcessor || ((spans: ReadableSpan[]) => spans),\n\t\t\tsampling: {\n\t\t\t\theadSampler,\n\t\t\t\ttailSampler: supplied.sampling?.tailSampler || multiTailSampler([isHeadSampled, isRootErrorSpan]),\n\t\t\t},\n\t\t\tservice: supplied.service,\n\t\t}\n", "}\n\tfunction createInitialiser(config: ConfigurationOption): Initialiser {\n\t\tif (typeof config === 'function') {\n\t\t\treturn (env, trigger) => {\n\t\t\t\tconst conf = parseConfig(config(env, trigger))\n\t\t\t\tinit(conf)\n\t\t\t\treturn conf\n\t\t\t}\n\t\t} else {\n\t\t\treturn () => {\n", "\t\t\tconst conf = parseConfig(config)\n\t\t\t\tinit(conf)\n\t\t\t\treturn conf\n\t\t\t}\n\t\t}\n\t}\n\texport function instrument<E, Q, C>(\n\t\thandler: ExportedHandler<E, Q, C>,\n\t\tconfig: ConfigurationOption\n\t): ExportedHandler<E, Q, C> {\n", "\tconst initialiser = createInitialiser(config)\n\t\tif (handler.fetch) {\n\t\t\tconst fetcher = unwrap(handler.fetch) as FetchHandler\n\t\t\thandler.fetch = createFetchHandler(fetcher, initialiser)\n\t\t}\n\t\tif (handler.queue) {\n\t\t\tconst queuer = unwrap(handler.queue) as QueueHandler\n\t\t\thandler.queue = createQueueHandler(queuer, initialiser)\n\t\t}\n\t\treturn handler\n", "}\n\texport function instrumentDO(doClass: DOClass, config: ConfigurationOption) {\n\t\tconst initialiser = createInitialiser(config)\n\t\treturn instrumentDOClass(doClass, initialiser)\n\t}\n\texport { waitUntilTrace } from './instrumentation/fetch.js'\n"]}
{"filename": "src/span.ts", "chunked_list": ["import {\n\t\tSpanContext,\n\t\tLink,\n\t\tSpanKind,\n\t\tTimeInput,\n\t\tException,\n\t\tAttributes,\n\t\tHrTime,\n\t\tSpan,\n\t\tSpanStatus,\n", "\tSpanStatusCode,\n\t\tAttributeValue,\n\t} from '@opentelemetry/api'\n\timport {\n\t\thrTimeDuration,\n\t\tInstrumentationLibrary,\n\t\tisAttributeKey,\n\t\tisAttributeValue,\n\t\tisTimeInput,\n\t\tsanitizeAttributes,\n", "} from '@opentelemetry/core'\n\timport { IResource } from '@opentelemetry/resources'\n\timport { ReadableSpan, TimedEvent } from '@opentelemetry/sdk-trace-base'\n\timport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\n\ttype OnSpanEnd = (span: Span) => void\n\tinterface SpanInit {\n\t\tattributes: unknown\n\t\tname: string\n\t\tonEnd: OnSpanEnd\n\t\tresource: IResource\n", "\tspanContext: SpanContext\n\t\tlinks?: Link[]\n\t\tparentSpanId?: string\n\t\tspanKind?: SpanKind\n\t\tstartTime?: TimeInput\n\t}\n\tfunction transformExceptionAttributes(exception: Exception): Attributes {\n\t\tconst attributes: Attributes = {}\n\t\tif (typeof exception === 'string') {\n\t\t\tattributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception\n", "\t} else {\n\t\t\tif (exception.code) {\n\t\t\t\tattributes[SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString()\n\t\t\t} else if (exception.name) {\n\t\t\t\tattributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name\n\t\t\t}\n\t\t\tif (exception.message) {\n\t\t\t\tattributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message\n\t\t\t}\n\t\t\tif (exception.stack) {\n", "\t\t\tattributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack\n\t\t\t}\n\t\t}\n\t\treturn attributes\n\t}\n\tfunction millisToHr(millis: number): HrTime {\n\t\treturn [Math.trunc(millis / 1000), (millis % 1000) * 1e6]\n\t}\n\tfunction getHrTime(input?: TimeInput): HrTime {\n\t\tconst now = Date.now()\n", "\tif (!input) {\n\t\t\treturn millisToHr(now)\n\t\t} else if (input instanceof Date) {\n\t\t\treturn millisToHr(input.getTime())\n\t\t} else if (typeof input === 'number') {\n\t\t\t//TODO: do something with performance.now something\n\t\t\treturn millisToHr(input)\n\t\t} else {\n\t\t\tthrow new Error('No valid time')\n\t\t}\n", "}\n\texport class SpanImpl implements Span, ReadableSpan {\n\t\tname: string\n\t\tprivate readonly _spanContext: SpanContext\n\t\tprivate readonly onEnd: OnSpanEnd\n\t\treadonly parentSpanId?: string\n\t\treadonly kind: SpanKind\n\t\treadonly attributes: Attributes\n\t\tstatus: SpanStatus = {\n\t\t\tcode: SpanStatusCode.UNSET,\n", "\t}\n\t\tendTime: HrTime = [0, 0]\n\t\tprivate _duration: HrTime = [0, 0]\n\t\treadonly startTime: HrTime\n\t\treadonly events: TimedEvent[] = []\n\t\treadonly links: Link[]\n\t\treadonly resource: IResource\n\t\tinstrumentationLibrary: InstrumentationLibrary = { name: '@microlabs/otel-cf-workers' }\n\t\tprivate _ended: boolean = false\n\t\tprivate _droppedAttributesCount: number = 0\n", "\tprivate _droppedEventsCount: number = 0\n\t\tprivate _droppedLinksCount: number = 0\n\t\tconstructor(init: SpanInit) {\n\t\t\tthis.name = init.name\n\t\t\tthis._spanContext = init.spanContext\n\t\t\tthis.parentSpanId = init.parentSpanId\n\t\t\tthis.kind = init.spanKind || SpanKind.INTERNAL\n\t\t\tthis.attributes = sanitizeAttributes(init.attributes)\n\t\t\tthis.startTime = getHrTime(init.startTime)\n\t\t\tthis.links = init.links || []\n", "\t\tthis.resource = init.resource\n\t\t\tthis.onEnd = init.onEnd\n\t\t}\n\t\tspanContext(): SpanContext {\n\t\t\treturn this._spanContext\n\t\t}\n\t\tsetAttribute(key: string, value?: AttributeValue): this {\n\t\t\tif (isAttributeKey(key) && isAttributeValue(value)) {\n\t\t\t\tthis.attributes[key] = value\n\t\t\t}\n", "\t\treturn this\n\t\t}\n\t\tsetAttributes(attributes: Attributes): this {\n\t\t\tfor (const [key, value] of Object.entries(attributes)) {\n\t\t\t\tthis.setAttribute(key, value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\t\taddEvent(name: string, attributesOrStartTime?: Attributes | TimeInput, startTime?: TimeInput): this {\n\t\t\tif (isTimeInput(attributesOrStartTime)) {\n", "\t\t\tstartTime = attributesOrStartTime\n\t\t\t\tattributesOrStartTime = undefined\n\t\t\t}\n\t\t\tconst attributes = sanitizeAttributes(attributesOrStartTime)\n\t\t\tconst time = getHrTime(startTime)\n\t\t\tthis.events.push({ name, attributes, time })\n\t\t\treturn this\n\t\t}\n\t\tsetStatus(status: SpanStatus): this {\n\t\t\tthis.status = status\n", "\t\treturn this\n\t\t}\n\t\tupdateName(name: string): this {\n\t\t\tthis.name = name\n\t\t\treturn this\n\t\t}\n\t\tend(endTime?: TimeInput): void {\n\t\t\tif (this._ended) {\n\t\t\t\treturn\n\t\t\t}\n", "\t\tthis._ended = true\n\t\t\tthis.endTime = getHrTime(endTime)\n\t\t\tthis._duration = hrTimeDuration(this.startTime, this.endTime)\n\t\t\tthis.onEnd(this)\n\t\t}\n\t\tisRecording(): boolean {\n\t\t\treturn true\n\t\t}\n\t\trecordException(exception: Exception, time?: TimeInput): void {\n\t\t\tconst attributes = transformExceptionAttributes(exception)\n", "\t\tthis.addEvent('exception', attributes, time)\n\t\t}\n\t\tget duration(): HrTime {\n\t\t\treturn this._duration\n\t\t}\n\t\tget ended(): boolean {\n\t\t\treturn this._ended\n\t\t}\n\t\tget droppedAttributesCount(): number {\n\t\t\treturn this._droppedAttributesCount\n", "\t}\n\t\tget droppedEventsCount(): number {\n\t\t\treturn this._droppedEventsCount\n\t\t}\n\t\tget droppedLinksCount(): number {\n\t\t\treturn this._droppedLinksCount\n\t\t}\n\t}\n"]}
{"filename": "src/config.ts", "chunked_list": ["import { context } from '@opentelemetry/api'\n\timport { ResolvedTraceConfig, Trigger } from './types.js'\n\tconst configSymbol = Symbol('Otel Workers Tracing Configuration')\n\texport type Initialiser = (env: Record<string, unknown>, trigger: Trigger) => ResolvedTraceConfig\n\texport function setConfig(config: ResolvedTraceConfig, ctx = context.active()) {\n\t\treturn ctx.setValue(configSymbol, config)\n\t}\n\texport function getActiveConfig(): ResolvedTraceConfig {\n\t\tconst config = context.active().getValue(configSymbol) as ResolvedTraceConfig\n\t\treturn config\n", "}\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { ReadableSpan, Sampler, SpanExporter } from '@opentelemetry/sdk-trace-base'\n\timport { OTLPExporterConfig } from './exporter.js'\n\timport { FetchHandlerConfig, FetcherConfig } from './instrumentation/fetch.js'\n\timport { TailSampleFn } from './sampling.js'\n\texport type PostProcessorFn = (spans: ReadableSpan[]) => ReadableSpan[]\n\texport type ExporterConfig = OTLPExporterConfig | SpanExporter\n\texport interface HandlerConfig {\n\t\tfetch?: FetchHandlerConfig\n\t}\n\texport interface ServiceConfig {\n", "\tname: string\n\t\tnamespace?: string\n\t\tversion?: string\n\t}\n\texport interface ParentRatioSamplingConfig {\n\t\tacceptRemote?: boolean\n\t\tratio: number\n\t}\n\ttype HeadSamplerConf = Sampler | ParentRatioSamplingConfig\n\texport interface SamplingConfig<HS extends HeadSamplerConf = HeadSamplerConf> {\n", "\theadSampler?: HS\n\t\ttailSampler?: TailSampleFn\n\t}\n\texport interface TraceConfig<EC extends ExporterConfig = ExporterConfig> {\n\t\texporter: EC\n\t\thandlers?: HandlerConfig\n\t\tfetch?: FetcherConfig\n\t\tpostProcessor?: PostProcessorFn\n\t\tsampling?: SamplingConfig\n\t\tservice: ServiceConfig\n", "}\n\texport interface ResolvedTraceConfig extends TraceConfig {\n\t\texporter: SpanExporter\n\t\thandlers: Required<HandlerConfig>\n\t\tfetch: Required<FetcherConfig>\n\t\tpostProcessor: PostProcessorFn\n\t\tsampling: Required<SamplingConfig<Sampler>>\n\t}\n\texport interface DOConstructorTrigger {\n\t\tid: string\n", "\tname?: string\n\t}\n\texport type Trigger = Request | MessageBatch | DOConstructorTrigger | 'do-alarm'\n"]}
{"filename": "src/exporter.ts", "chunked_list": ["import { createExportTraceServiceRequest } from '@opentelemetry/otlp-transformer'\n\timport { ExportServiceError, OTLPExporterError } from '@opentelemetry/otlp-exporter-base'\n\timport { ExportResult, ExportResultCode } from '@opentelemetry/core'\n\timport { SpanExporter } from '@opentelemetry/sdk-trace-base'\n\timport { unwrap } from './wrap.js'\n\texport interface OTLPExporterConfig {\n\t\turl: string\n\t\theaders?: Record<string, string>\n\t}\n\tconst defaultHeaders: Record<string, string> = {\n", "\taccept: 'application/json',\n\t\t'content-type': 'application/json',\n\t}\n\texport class OTLPExporter implements SpanExporter {\n\t\tprivate headers: Record<string, string>\n\t\tprivate url: string\n\t\tconstructor(config: OTLPExporterConfig) {\n\t\t\tthis.url = config.url\n\t\t\tthis.headers = Object.assign({}, defaultHeaders, config.headers)\n\t\t}\n", "\texport(items: any[], resultCallback: (result: ExportResult) => void): void {\n\t\t\tthis._export(items)\n\t\t\t\t.then(() => {\n\t\t\t\t\tresultCallback({ code: ExportResultCode.SUCCESS })\n\t\t\t\t})\n\t\t\t\t.catch((error: ExportServiceError) => {\n\t\t\t\t\tresultCallback({ code: ExportResultCode.FAILED, error })\n\t\t\t\t})\n\t\t}\n\t\tprivate _export(items: any[]): Promise<unknown> {\n", "\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.send(items, resolve, reject)\n\t\t\t\t} catch (e) {\n\t\t\t\t\treject(e)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\tsend(items: any[], onSuccess: () => void, onError: (error: OTLPExporterError) => void): void {\n\t\t\tconst exportMessage = createExportTraceServiceRequest(items, true)\n", "\t\tconst body = JSON.stringify(exportMessage)\n\t\t\tconst params: RequestInit = {\n\t\t\t\tmethod: 'POST',\n\t\t\t\theaders: this.headers,\n\t\t\t\tbody,\n\t\t\t}\n\t\t\tunwrap(fetch)(this.url, params)\n\t\t\t\t.then((response) => {\n\t\t\t\t\tif (response.ok) {\n\t\t\t\t\t\tonSuccess()\n", "\t\t\t\t} else {\n\t\t\t\t\t\tonError(new OTLPExporterError(`Exporter received a statusCode: ${response.status}`))\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.catch((error) => {\n\t\t\t\t\tonError(new OTLPExporterError(`Exception during export: ${error.toString()}`, error.code, error.stack))\n\t\t\t\t})\n\t\t}\n\t\tasync shutdown(): Promise<void> {}\n\t}\n"]}
{"filename": "src/provider.ts", "chunked_list": ["import { context, trace, Tracer, TracerOptions, TracerProvider } from '@opentelemetry/api'\n\timport { SpanProcessor } from '@opentelemetry/sdk-trace-base'\n\timport { Resource } from '@opentelemetry/resources'\n\timport { AsyncLocalStorageContextManager } from './context.js'\n\timport { WorkerTracer } from './tracer.js'\n\t/**\n\t * Register this TracerProvider for use with the OpenTelemetry API.\n\t * Undefined values may be replaced with defaults, and\n\t * null values will be skipped.\n\t *\n", " * @param config Configuration object for SDK registration\n\t */\n\texport class WorkerTracerProvider implements TracerProvider {\n\t\tprivate spanProcessor: SpanProcessor\n\t\tprivate resource: Resource\n\t\tprivate tracers: Record<string, Tracer> = {}\n\t\tconstructor(spanProcessor: SpanProcessor, resource: Resource) {\n\t\t\tthis.spanProcessor = spanProcessor\n\t\t\tthis.resource = resource\n\t\t}\n", "\tgetTracer(name: string, version?: string, options?: TracerOptions): Tracer {\n\t\t\tconst key = `${name}@${version || ''}:${options?.schemaUrl || ''}`\n\t\t\tif (!this.tracers[key]) {\n\t\t\t\tthis.tracers[key] = new WorkerTracer(this.spanProcessor, this.resource)\n\t\t\t}\n\t\t\treturn this.tracers[key]\n\t\t}\n\t\tregister(): void {\n\t\t\ttrace.setGlobalTracerProvider(this)\n\t\t\tcontext.setGlobalContextManager(new AsyncLocalStorageContextManager())\n", "\t}\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './buffer.js'\n\texport * from './sampling.js'\n\texport * from './sdk.js'\n\texport * from './span.js'\n\texport type * from './types.js'\n"]}
{"filename": "src/context.ts", "chunked_list": ["/*\n\t * Copyright The OpenTelemetry Authors\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      https://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n", " * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\timport { ContextManager, Context, ROOT_CONTEXT } from '@opentelemetry/api'\n\t//@ts-ignore\n\timport { AsyncLocalStorage } from 'node:async_hooks'\n\t//@ts-ignore\n\timport { EventEmitter } from 'node:events'\n", "type Func<T> = (...args: unknown[]) => T\n\t/**\n\t * Store a map for each event of all original listeners and their \"patched\"\n\t * version. So when a listener is removed by the user, the corresponding\n\t * patched function will be also removed.\n\t */\n\tinterface PatchMap {\n\t\t[name: string]: WeakMap<Func<void>, Func<void>>\n\t}\n\tconst ADD_LISTENER_METHODS = [\n", "\t'addListener' as const,\n\t\t'on' as const,\n\t\t'once' as const,\n\t\t'prependListener' as const,\n\t\t'prependOnceListener' as const,\n\t]\n\tabstract class AbstractAsyncHooksContextManager implements ContextManager {\n\t\tabstract active(): Context\n\t\tabstract with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n\t\t\tcontext: Context,\n", "\t\tfn: F,\n\t\t\tthisArg?: ThisParameterType<F>,\n\t\t\t...args: A\n\t\t): ReturnType<F>\n\t\tabstract enable(): this\n\t\tabstract disable(): this\n\t\t/**\n\t\t * Binds a the certain context or the active one to the target function and then returns the target\n\t\t * @param context A context (span) to be bind to target\n\t\t * @param target a function or event emitter. When target or one of its callbacks is called,\n", "\t *  the provided context will be used as the active context for the duration of the call.\n\t\t */\n\t\tbind<T>(context: Context, target: T): T {\n\t\t\tif (target instanceof EventEmitter) {\n\t\t\t\treturn this._bindEventEmitter(context, target)\n\t\t\t}\n\t\t\tif (typeof target === 'function') {\n\t\t\t\treturn this._bindFunction(context, target)\n\t\t\t}\n\t\t\treturn target\n", "\t}\n\t\tprivate _bindFunction<T extends Function>(context: Context, target: T): T {\n\t\t\tconst manager = this\n\t\t\tconst contextWrapper = function (this: never, ...args: unknown[]) {\n\t\t\t\treturn manager.with(context, () => target.apply(this, args))\n\t\t\t}\n\t\t\tObject.defineProperty(contextWrapper, 'length', {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: false,\n", "\t\t\tvalue: target.length,\n\t\t\t})\n\t\t\t/**\n\t\t\t * It isn't possible to tell Typescript that contextWrapper is the same as T\n\t\t\t * so we forced to cast as any here.\n\t\t\t */\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\treturn contextWrapper as any\n\t\t}\n\t\t/**\n", "\t * By default, EventEmitter call their callback with their context, which we do\n\t\t * not want, instead we will bind a specific context to all callbacks that\n\t\t * go through it.\n\t\t * @param context the context we want to bind\n\t\t * @param ee EventEmitter an instance of EventEmitter to patch\n\t\t */\n\t\tprivate _bindEventEmitter<T extends EventEmitter>(context: Context, ee: T): T {\n\t\t\tconst map = this._getPatchMap(ee)\n\t\t\tif (map !== undefined) return ee\n\t\t\tthis._createPatchMap(ee)\n", "\t\t// patch methods that add a listener to propagate context\n\t\t\tADD_LISTENER_METHODS.forEach((methodName) => {\n\t\t\t\tif (ee[methodName] === undefined) return\n\t\t\t\tee[methodName] = this._patchAddListener(ee, ee[methodName], context)\n\t\t\t})\n\t\t\t// patch methods that remove a listener\n\t\t\tif (typeof ee.removeListener === 'function') {\n\t\t\t\tee.removeListener = this._patchRemoveListener(ee, ee.removeListener)\n\t\t\t}\n\t\t\tif (typeof ee.off === 'function') {\n", "\t\t\tee.off = this._patchRemoveListener(ee, ee.off)\n\t\t\t}\n\t\t\t// patch method that remove all listeners\n\t\t\tif (typeof ee.removeAllListeners === 'function') {\n\t\t\t\tee.removeAllListeners = this._patchRemoveAllListeners(ee, ee.removeAllListeners)\n\t\t\t}\n\t\t\treturn ee\n\t\t}\n\t\t/**\n\t\t * Patch methods that remove a given listener so that we match the \"patched\"\n", "\t * version of that listener (the one that propagate context).\n\t\t * @param ee EventEmitter instance\n\t\t * @param original reference to the patched method\n\t\t */\n\t\tprivate _patchRemoveListener(ee: EventEmitter, original: Function) {\n\t\t\tconst contextManager = this\n\t\t\treturn function (this: never, event: string, listener: Func<void>) {\n\t\t\t\tconst events = contextManager._getPatchMap(ee)?.[event]\n\t\t\t\tif (events === undefined) {\n\t\t\t\t\treturn original.call(this, event, listener)\n", "\t\t\t}\n\t\t\t\tconst patchedListener = events.get(listener)\n\t\t\t\treturn original.call(this, event, patchedListener || listener)\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Patch methods that remove all listeners so we remove our\n\t\t * internal references for a given event.\n\t\t * @param ee EventEmitter instance\n\t\t * @param original reference to the patched method\n", "\t */\n\t\tprivate _patchRemoveAllListeners(ee: EventEmitter, original: Function) {\n\t\t\tconst contextManager = this\n\t\t\treturn function (this: never, event: string) {\n\t\t\t\tconst map = contextManager._getPatchMap(ee)\n\t\t\t\tif (map !== undefined) {\n\t\t\t\t\tif (arguments.length === 0) {\n\t\t\t\t\t\tcontextManager._createPatchMap(ee)\n\t\t\t\t\t} else if (map[event] !== undefined) {\n\t\t\t\t\t\tdelete map[event]\n", "\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn original.apply(this, arguments)\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Patch methods on an event emitter instance that can add listeners so we\n\t\t * can force them to propagate a given context.\n\t\t * @param ee EventEmitter instance\n\t\t * @param original reference to the patched method\n", "\t * @param [context] context to propagate when calling listeners\n\t\t */\n\t\tprivate _patchAddListener(ee: EventEmitter, original: Function, context: Context) {\n\t\t\tconst contextManager = this\n\t\t\treturn function (this: never, event: string, listener: Func<void>) {\n\t\t\t\t/**\n\t\t\t\t * This check is required to prevent double-wrapping the listener.\n\t\t\t\t * The implementation for ee.once wraps the listener and calls ee.on.\n\t\t\t\t * Without this check, we would wrap that wrapped listener.\n\t\t\t\t * This causes an issue because ee.removeListener depends on the onceWrapper\n", "\t\t\t * to properly remove the listener. If we wrap their wrapper, we break\n\t\t\t\t * that detection.\n\t\t\t\t */\n\t\t\t\tif (contextManager._wrapped) {\n\t\t\t\t\treturn original.call(this, event, listener)\n\t\t\t\t}\n\t\t\t\tlet map = contextManager._getPatchMap(ee)\n\t\t\t\tif (map === undefined) {\n\t\t\t\t\tmap = contextManager._createPatchMap(ee)\n\t\t\t\t}\n", "\t\t\tlet listeners = map[event]\n\t\t\t\tif (listeners === undefined) {\n\t\t\t\t\tlisteners = new WeakMap()\n\t\t\t\t\tmap[event] = listeners\n\t\t\t\t}\n\t\t\t\tconst patchedListener = contextManager.bind(context, listener)\n\t\t\t\t// store a weak reference of the user listener to ours\n\t\t\t\tlisteners.set(listener, patchedListener)\n\t\t\t\t/**\n\t\t\t\t * See comment at the start of this function for the explanation of this property.\n", "\t\t\t */\n\t\t\t\tcontextManager._wrapped = true\n\t\t\t\ttry {\n\t\t\t\t\treturn original.call(this, event, patchedListener)\n\t\t\t\t} finally {\n\t\t\t\t\tcontextManager._wrapped = false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprivate _createPatchMap(ee: EventEmitter): PatchMap {\n", "\t\tconst map = Object.create(null)\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t;(ee as any)[this._kOtListeners] = map\n\t\t\treturn map\n\t\t}\n\t\tprivate _getPatchMap(ee: EventEmitter): PatchMap | undefined {\n\t\t\treturn (ee as never)[this._kOtListeners]\n\t\t}\n\t\tprivate readonly _kOtListeners = Symbol('OtListeners')\n\t\tprivate _wrapped = false\n", "}\n\texport class AsyncLocalStorageContextManager extends AbstractAsyncHooksContextManager {\n\t\tprivate _asyncLocalStorage: AsyncLocalStorage<Context>\n\t\tconstructor() {\n\t\t\tsuper()\n\t\t\tthis._asyncLocalStorage = new AsyncLocalStorage()\n\t\t}\n\t\tactive(): Context {\n\t\t\treturn this._asyncLocalStorage.getStore() ?? ROOT_CONTEXT\n\t\t}\n", "\twith<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n\t\t\tcontext: Context,\n\t\t\tfn: F,\n\t\t\tthisArg?: ThisParameterType<F>,\n\t\t\t...args: A\n\t\t): ReturnType<F> {\n\t\t\tconst cb = thisArg == null ? fn : fn.bind(thisArg)\n\t\t\treturn this._asyncLocalStorage.run(context, cb as never, ...args)\n\t\t}\n\t\tenable(): this {\n", "\t\treturn this\n\t\t}\n\t\tdisable(): this {\n\t\t\tthis._asyncLocalStorage.disable()\n\t\t\treturn this\n\t\t}\n\t}\n"]}
{"filename": "src/instrumentation/queue.ts", "chunked_list": ["import { trace, SpanOptions, SpanKind, Attributes, Exception, context as api_context } from '@opentelemetry/api'\n\timport { Initialiser, setConfig } from '../config.js'\n\timport { exportSpans, proxyExecutionContext } from './common.js'\n\timport { instrumentEnv } from './env.js'\n\timport { unwrap, wrap } from '../wrap.js'\n\ttype QueueHandler = ExportedHandlerQueueHandler<unknown, unknown>\n\texport type QueueHandlerArgs = Parameters<QueueHandler>\n\tconst traceIdSymbol = Symbol('traceId')\n\tclass MessageStatusCount {\n\t\tsucceeded = 0\n", "\tfailed = 0\n\t\treadonly total: number\n\t\tconstructor(total: number) {\n\t\t\tthis.total = total\n\t\t}\n\t\tack() {\n\t\t\tthis.succeeded = this.succeeded + 1\n\t\t}\n\t\tackRemaining() {\n\t\t\tthis.succeeded = this.total - this.failed\n", "\t}\n\t\tretry() {\n\t\t\tthis.failed = this.failed + 1\n\t\t}\n\t\tretryRemaining() {\n\t\t\tthis.failed = this.total - this.succeeded\n\t\t}\n\t\ttoAttributes(): Attributes {\n\t\t\treturn {\n\t\t\t\t'queue.messages_count': this.total,\n", "\t\t\t'queue.messages_success': this.succeeded,\n\t\t\t\t'queue.messages_failed': this.failed,\n\t\t\t\t'queue.batch_success': this.succeeded === this.total,\n\t\t\t}\n\t\t}\n\t}\n\tconst addEvent = (name: string, msg?: Message) => {\n\t\tconst attrs: Attributes = {}\n\t\tif (msg) {\n\t\t\tattrs['queue.message_id'] = msg.id\n", "\t\tattrs['queue.message_timestamp'] = msg.timestamp.toISOString()\n\t\t}\n\t\ttrace.getActiveSpan()?.addEvent(name, attrs)\n\t}\n\tconst proxyQueueMessage = <Q>(msg: Message<Q>, count: MessageStatusCount): Message<Q> => {\n\t\tconst msgHandler: ProxyHandler<Message<Q>> = {\n\t\t\tget: (target, prop) => {\n\t\t\t\tif (prop === 'ack') {\n\t\t\t\t\tconst ackFn = Reflect.get(target, prop)\n\t\t\t\t\treturn new Proxy(ackFn, {\n", "\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\t\taddEvent('messageAck', msg)\n\t\t\t\t\t\t\tcount.ack()\n\t\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\t\tReflect.apply(fnTarget, msg, [])\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t} else if (prop === 'retry') {\n\t\t\t\t\tconst retryFn = Reflect.get(target, prop)\n\t\t\t\t\treturn new Proxy(retryFn, {\n", "\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\t\taddEvent('messageRetry', msg)\n\t\t\t\t\t\t\tcount.retry()\n\t\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\t\tconst result = Reflect.apply(fnTarget, msg, [])\n\t\t\t\t\t\t\treturn result\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\treturn Reflect.get(target, prop, msg)\n", "\t\t\t}\n\t\t\t},\n\t\t}\n\t\treturn wrap(msg, msgHandler)\n\t}\n\tconst proxyMessageBatch = <E, Q>(batch: MessageBatch, count: MessageStatusCount) => {\n\t\tconst batchHandler: ProxyHandler<MessageBatch> = {\n\t\t\tget: (target, prop) => {\n\t\t\t\tif (prop === 'messages') {\n\t\t\t\t\tconst messages = Reflect.get(target, prop)\n", "\t\t\t\tconst messagesHandler: ProxyHandler<MessageBatch['messages']> = {\n\t\t\t\t\t\tget: (target, prop) => {\n\t\t\t\t\t\t\tif (typeof prop === 'string' && !isNaN(parseInt(prop))) {\n\t\t\t\t\t\t\t\tconst message = Reflect.get(target, prop)\n\t\t\t\t\t\t\t\treturn proxyQueueMessage(message, count)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n", "\t\t\t\treturn wrap(messages, messagesHandler)\n\t\t\t\t} else if (prop === 'ackAll') {\n\t\t\t\t\tconst ackFn = Reflect.get(target, prop)\n\t\t\t\t\treturn new Proxy(ackFn, {\n\t\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\t\taddEvent('ackAll')\n\t\t\t\t\t\t\tcount.ackRemaining()\n\t\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\t\tReflect.apply(fnTarget, batch, [])\n\t\t\t\t\t\t},\n", "\t\t\t\t})\n\t\t\t\t} else if (prop === 'retryAll') {\n\t\t\t\t\tconst retryFn = Reflect.get(target, prop)\n\t\t\t\t\treturn new Proxy(retryFn, {\n\t\t\t\t\t\tapply: (fnTarget) => {\n\t\t\t\t\t\t\taddEvent('retryAll')\n\t\t\t\t\t\t\tcount.retryRemaining()\n\t\t\t\t\t\t\t//TODO: handle errors\n\t\t\t\t\t\t\tReflect.apply(fnTarget, batch, [])\n\t\t\t\t\t\t},\n", "\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t},\n\t\t}\n\t\treturn wrap(batch, batchHandler)\n\t}\n\texport function executeQueueHandler(queueFn: QueueHandler, [batch, env, ctx]: QueueHandlerArgs): Promise<void> {\n\t\tconst count = new MessageStatusCount(batch.messages.length)\n\t\tbatch = proxyMessageBatch(batch, count)\n", "\tconst tracer = trace.getTracer('queueHandler')\n\t\tconst options: SpanOptions = {\n\t\t\tattributes: {\n\t\t\t\t'queue.name': batch.queue,\n\t\t\t},\n\t\t\tkind: SpanKind.CONSUMER,\n\t\t}\n\t\tconst promise = tracer.startActiveSpan(`queueHandler:${batch.queue}`, options, async (span) => {\n\t\t\tconst traceId = span.spanContext().traceId\n\t\t\tapi_context.active().setValue(traceIdSymbol, traceId)\n", "\t\ttry {\n\t\t\t\tconst result = queueFn(batch, env, ctx)\n\t\t\t\tawait span.setAttribute('queue.implicitly_acked', count.total - count.succeeded - count.failed)\n\t\t\t\tcount.ackRemaining()\n\t\t\t\tspan.setAttributes(count.toAttributes())\n\t\t\t\tspan.end()\n\t\t\t\treturn result\n\t\t\t} catch (error) {\n\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\tspan.setAttribute('queue.implicitly_retried', count.total - count.succeeded - count.failed)\n", "\t\t\tcount.retryRemaining()\n\t\t\t\tspan.end()\n\t\t\t\tthrow error\n\t\t\t}\n\t\t})\n\t\treturn promise\n\t}\n\texport function createQueueHandler(queueFn: QueueHandler, initialiser: Initialiser) {\n\t\tconst queueHandler: ProxyHandler<QueueHandler> = {\n\t\t\tasync apply(target, _thisArg, argArray: Parameters<QueueHandler>): Promise<void> {\n", "\t\t\tconst [batch, orig_env, orig_ctx] = argArray\n\t\t\t\tconst config = initialiser(orig_env as Record<string, unknown>, batch)\n\t\t\t\tconst env = instrumentEnv(orig_env as Record<string, unknown>)\n\t\t\t\tconst { ctx, tracker } = proxyExecutionContext(orig_ctx)\n\t\t\t\tconst context = setConfig(config)\n\t\t\t\ttry {\n\t\t\t\t\tconst args: QueueHandlerArgs = [batch, env, ctx]\n\t\t\t\t\treturn await api_context.with(context, executeQueueHandler, undefined, target, args)\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow error\n", "\t\t\t} finally {\n\t\t\t\t\torig_ctx.waitUntil(exportSpans(tracker))\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\treturn wrap(queueFn, queueHandler)\n\t}\n\tfunction instrumentQueueSend(fn: Queue<unknown>['send'], name: string): Queue<unknown>['send'] {\n\t\tconst tracer = trace.getTracer('queueSender')\n\t\tconst handler: ProxyHandler<Queue<unknown>['send']> = {\n", "\t\tapply: (target, thisArg, argArray) => {\n\t\t\t\treturn tracer.startActiveSpan(`queueSend: ${name}`, async (span) => {\n\t\t\t\t\tspan.setAttribute('queue.operation', 'send')\n\t\t\t\t\tawait Reflect.apply(target, unwrap(thisArg), argArray)\n\t\t\t\t\tspan.end()\n\t\t\t\t})\n\t\t\t},\n\t\t}\n\t\treturn wrap(fn, handler)\n\t}\n", "function instrumentQueueSendBatch(fn: Queue<unknown>['sendBatch'], name: string): Queue<unknown>['sendBatch'] {\n\t\tconst tracer = trace.getTracer('queueSender')\n\t\tconst handler: ProxyHandler<Queue<unknown>['sendBatch']> = {\n\t\t\tapply: (target, thisArg, argArray) => {\n\t\t\t\treturn tracer.startActiveSpan(`queueSendBatch: ${name}`, async (span) => {\n\t\t\t\t\tspan.setAttribute('queue.operation', 'sendBatch')\n\t\t\t\t\tawait Reflect.apply(target, unwrap(thisArg), argArray)\n\t\t\t\t\tspan.end()\n\t\t\t\t})\n\t\t\t},\n", "\t}\n\t\treturn wrap(fn, handler)\n\t}\n\texport function instrumentQueueSender(queue: Queue<unknown>, name: string) {\n\t\tconst queueHandler: ProxyHandler<Queue<unknown>> = {\n\t\t\tget: (target, prop) => {\n\t\t\t\tif (prop === 'send') {\n\t\t\t\t\tconst sendFn = Reflect.get(target, prop)\n\t\t\t\t\treturn instrumentQueueSend(sendFn, name)\n\t\t\t\t} else if (prop === 'sendBatch') {\n", "\t\t\t\tconst sendFn = Reflect.get(target, prop)\n\t\t\t\t\treturn instrumentQueueSendBatch(sendFn, name)\n\t\t\t\t} else {\n\t\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\treturn wrap(queue, queueHandler)\n\t}\n"]}
{"filename": "src/instrumentation/env.ts", "chunked_list": ["import { wrap } from '../wrap.js'\n\timport { instrumentDOBinding } from './do.js'\n\timport { instrumentKV } from './kv.js'\n\timport { instrumentQueueSender } from './queue.js'\n\tconst isKVNamespace = (item?: unknown): item is KVNamespace => {\n\t\treturn !!(item as KVNamespace)?.getWithMetadata\n\t}\n\tconst isQueue = (item?: unknown): item is Queue<unknown> => {\n\t\treturn !!(item as Queue<unknown>)?.sendBatch\n\t}\n", "const isDurableObject = (item?: unknown): item is DurableObjectNamespace => {\n\t\treturn !!(item as DurableObjectNamespace)?.idFromName\n\t}\n\tconst instrumentEnv = (env: Record<string, unknown>): Record<string, unknown> => {\n\t\tconst envHandler: ProxyHandler<Record<string, unknown>> = {\n\t\t\tget: (target, prop, receiver) => {\n\t\t\t\tconst item = Reflect.get(target, prop, receiver)\n\t\t\t\tif (isKVNamespace(item)) {\n\t\t\t\t\treturn instrumentKV(item, String(prop))\n\t\t\t\t} else if (isQueue(item)) {\n", "\t\t\t\treturn instrumentQueueSender(item, String(prop))\n\t\t\t\t} else if (isDurableObject(item)) {\n\t\t\t\t\treturn instrumentDOBinding(item, String(prop))\n\t\t\t\t} else {\n\t\t\t\t\treturn item\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\treturn wrap(env, envHandler)\n\t}\n", "export { instrumentEnv }\n"]}
{"filename": "src/instrumentation/do.ts", "chunked_list": ["import { context as api_context, trace, SpanOptions, SpanKind, Exception, SpanStatusCode } from '@opentelemetry/api'\n\timport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\n\timport { passthroughGet, unwrap, wrap } from '../wrap.js'\n\timport {\n\t\tgetParentContextFromHeaders,\n\t\tgatherIncomingCfAttributes,\n\t\tgatherRequestAttributes,\n\t\tgatherResponseAttributes,\n\t\tinstrumentFetcher,\n\t} from './fetch.js'\n", "import { instrumentEnv } from './env.js'\n\timport { Initialiser, setConfig } from '../config.js'\n\timport { exportSpans } from './common.js'\n\timport { instrumentStorage } from './do-storage.js'\n\timport { DOConstructorTrigger } from '../types.js'\n\ttype FetchFn = DurableObject['fetch']\n\ttype AlarmFn = DurableObject['alarm']\n\ttype Env = Record<string, unknown>\n\tfunction instrumentBindingStub(stub: DurableObjectStub, nsName: string): DurableObjectStub {\n\t\tconst stubHandler: ProxyHandler<typeof stub> = {\n", "\t\tget(target, prop) {\n\t\t\t\tif (prop === 'fetch') {\n\t\t\t\t\tconst fetcher = Reflect.get(target, prop)\n\t\t\t\t\tconst attrs = {\n\t\t\t\t\t\tname: `durable_object:${nsName}`,\n\t\t\t\t\t\t'do.namespace': nsName,\n\t\t\t\t\t\t'do.id': target.id.toString(),\n\t\t\t\t\t\t'do.id.name': target.id.name,\n\t\t\t\t\t}\n\t\t\t\t\treturn instrumentFetcher(fetcher, () => ({ includeTraceContext: true }), attrs)\n", "\t\t\t} else {\n\t\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\treturn wrap(stub, stubHandler)\n\t}\n\tfunction instrumentBindingGet(getFn: DurableObjectNamespace['get'], nsName: string): DurableObjectNamespace['get'] {\n\t\tconst getHandler: ProxyHandler<DurableObjectNamespace['get']> = {\n\t\t\tapply(target, thisArg, argArray) {\n", "\t\t\tconst stub: DurableObjectStub = Reflect.apply(target, thisArg, argArray)\n\t\t\t\treturn instrumentBindingStub(stub, nsName)\n\t\t\t},\n\t\t}\n\t\treturn wrap(getFn, getHandler)\n\t}\n\texport function instrumentDOBinding(ns: DurableObjectNamespace, nsName: string) {\n\t\tconst nsHandler: ProxyHandler<typeof ns> = {\n\t\t\tget(target, prop) {\n\t\t\t\tif (prop === 'get') {\n", "\t\t\t\tconst fn = Reflect.get(ns, prop)\n\t\t\t\t\treturn instrumentBindingGet(fn, nsName)\n\t\t\t\t} else {\n\t\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\treturn wrap(ns, nsHandler)\n\t}\n\texport function instrumentState(state: DurableObjectState) {\n", "\tconst stateHandler: ProxyHandler<DurableObjectState> = {\n\t\t\tget(target, prop, receiver) {\n\t\t\t\tconst result = Reflect.get(target, prop, unwrap(receiver))\n\t\t\t\tif (prop === 'storage') {\n\t\t\t\t\treturn instrumentStorage(result)\n\t\t\t\t} else if (typeof result === 'function') {\n\t\t\t\t\treturn result.bind(target)\n\t\t\t\t} else {\n\t\t\t\t\treturn result\n\t\t\t\t}\n", "\t\t},\n\t\t}\n\t\treturn wrap(state, stateHandler)\n\t}\n\tlet cold_start = true\n\texport type DOClass = { new (state: DurableObjectState, env: any): DurableObject }\n\texport function executeDOFetch(fetchFn: FetchFn, request: Request, id: DurableObjectId): Promise<Response> {\n\t\tconst spanContext = getParentContextFromHeaders(request.headers)\n\t\tconst tracer = trace.getTracer('DO fetchHandler')\n\t\tconst attributes = {\n", "\t\t[SemanticAttributes.FAAS_TRIGGER]: 'http',\n\t\t\t[SemanticAttributes.FAAS_COLDSTART]: cold_start,\n\t\t}\n\t\tcold_start = false\n\t\tObject.assign(attributes, gatherRequestAttributes(request))\n\t\tObject.assign(attributes, gatherIncomingCfAttributes(request))\n\t\tconst options: SpanOptions = {\n\t\t\tattributes,\n\t\t\tkind: SpanKind.SERVER,\n\t\t}\n", "\tconst name = id.name || ''\n\t\tconst promise = tracer.startActiveSpan(`do.fetchHandler:${name}`, options, spanContext, async (span) => {\n\t\t\ttry {\n\t\t\t\tconst response: Response = await fetchFn(request)\n\t\t\t\tif (response.ok) {\n\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.OK })\n\t\t\t\t}\n\t\t\t\tspan.setAttributes(gatherResponseAttributes(response))\n\t\t\t\tspan.end()\n\t\t\t\treturn response\n", "\t\t} catch (error) {\n\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\tspan.end()\n\t\t\t\tthrow error\n\t\t\t}\n\t\t})\n\t\treturn promise\n\t}\n\texport function executeDOAlarm(alarmFn: NonNullable<AlarmFn>, id: DurableObjectId): Promise<void> {\n", "\tconst tracer = trace.getTracer('DO alarmHandler')\n\t\tconst name = id.name || ''\n\t\tconst promise = tracer.startActiveSpan(`do.alarmHandler:${name}`, async (span) => {\n\t\t\tspan.setAttribute(SemanticAttributes.FAAS_COLDSTART, cold_start)\n\t\t\tcold_start = false\n\t\t\tspan.setAttribute('do.id', id.toString())\n\t\t\tif (id.name) span.setAttribute('do.name', id.name)\n\t\t\ttry {\n\t\t\t\tawait alarmFn()\n\t\t\t\tspan.end()\n", "\t\t} catch (error) {\n\t\t\t\tspan.recordException(error as Exception)\n\t\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\tspan.end()\n\t\t\t\tthrow error\n\t\t\t}\n\t\t})\n\t\treturn promise\n\t}\n\tfunction instrumentFetchFn(fetchFn: FetchFn, initialiser: Initialiser, env: Env, id: DurableObjectId): FetchFn {\n", "\tconst fetchHandler: ProxyHandler<FetchFn> = {\n\t\t\tasync apply(target, thisArg, argArray: Parameters<FetchFn>) {\n\t\t\t\tconst request = argArray[0]\n\t\t\t\tconst config = initialiser(env, request)\n\t\t\t\tconst context = setConfig(config)\n\t\t\t\ttry {\n\t\t\t\t\tconst bound = target.bind(unwrap(thisArg))\n\t\t\t\t\treturn await api_context.with(context, executeDOFetch, undefined, bound, request, id)\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow error\n", "\t\t\t} finally {\n\t\t\t\t\texportSpans()\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\treturn wrap(fetchFn, fetchHandler)\n\t}\n\tfunction instrumentAlarmFn(alarmFn: AlarmFn, initialiser: Initialiser, env: Env, id: DurableObjectId) {\n\t\tif (!alarmFn) return undefined\n\t\tconst alarmHandler: ProxyHandler<NonNullable<AlarmFn>> = {\n", "\t\tasync apply(target, thisArg) {\n\t\t\t\tconst config = initialiser(env, 'do-alarm')\n\t\t\t\tconst context = setConfig(config)\n\t\t\t\ttry {\n\t\t\t\t\tconst bound = target.bind(unwrap(thisArg))\n\t\t\t\t\treturn await api_context.with(context, executeDOAlarm, undefined, bound, id)\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthrow error\n\t\t\t\t} finally {\n\t\t\t\t\texportSpans()\n", "\t\t\t}\n\t\t\t},\n\t\t}\n\t\treturn wrap(alarmFn, alarmHandler)\n\t}\n\tfunction instrumentDurableObject(doObj: DurableObject, initialiser: Initialiser, env: Env, state: DurableObjectState) {\n\t\tconst objHandler: ProxyHandler<DurableObject> = {\n\t\t\tget(target, prop) {\n\t\t\t\tif (prop === 'fetch') {\n\t\t\t\t\tconst fetchFn = Reflect.get(target, prop)\n", "\t\t\t\treturn instrumentFetchFn(fetchFn, initialiser, env, state.id)\n\t\t\t\t} else if (prop === 'alarm') {\n\t\t\t\t\tconst alarmFn = Reflect.get(target, prop)\n\t\t\t\t\treturn instrumentAlarmFn(alarmFn, initialiser, env, state.id)\n\t\t\t\t} else {\n\t\t\t\t\tconst result = Reflect.get(target, prop)\n\t\t\t\t\tif (typeof result === 'function') {\n\t\t\t\t\t\tresult.bind(doObj)\n\t\t\t\t\t}\n\t\t\t\t\treturn result\n", "\t\t\t}\n\t\t\t},\n\t\t}\n\t\treturn wrap(doObj, objHandler)\n\t}\n\texport function instrumentDOClass(doClass: DOClass, initialiser: Initialiser): DOClass {\n\t\tconst classHandler: ProxyHandler<DOClass> = {\n\t\t\tconstruct(target, [orig_state, orig_env]: ConstructorParameters<DOClass>) {\n\t\t\t\tconst trigger: DOConstructorTrigger = {\n\t\t\t\t\tid: orig_state.id.toString(),\n", "\t\t\t\tname: orig_state.id.name,\n\t\t\t\t}\n\t\t\t\tconst constructorConfig = initialiser(orig_env, trigger)\n\t\t\t\tconst context = setConfig(constructorConfig)\n\t\t\t\tconst state = instrumentState(orig_state)\n\t\t\t\tconst env = instrumentEnv(orig_env)\n\t\t\t\tconst createDO = () => {\n\t\t\t\t\treturn new target(state, env)\n\t\t\t\t}\n\t\t\t\tconst doObj = api_context.with(context, createDO)\n", "\t\t\treturn instrumentDurableObject(doObj, initialiser, env, state)\n\t\t\t},\n\t\t}\n\t\treturn wrap(doClass, classHandler)\n\t}\n"]}
{"filename": "src/instrumentation/do-storage.ts", "chunked_list": ["import { Attributes, SpanKind, SpanOptions, trace } from '@opentelemetry/api'\n\timport { wrap } from '../wrap.js'\n\ttype ExtraAttributeFn = (argArray: any[], result: any) => Attributes\n\tconst StorageAttributes: Record<string | symbol, ExtraAttributeFn> = {\n\t\tdelete(argArray, result) {\n\t\t\tlet attrs = {}\n\t\t\tif (Array.isArray(argArray[0])) {\n\t\t\t\tconst keys = argArray[0]\n\t\t\t\tattrs = {\n\t\t\t\t\t'do.storage.key': keys[0],\n", "\t\t\t\t'do.storage.number_of_keys': keys.length,\n\t\t\t\t\t'do.storage.keys_deleted': result,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tattrs = {\n\t\t\t\t\t'do.storage.key': argArray[0],\n\t\t\t\t\t'do.storage.success': result,\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argArray.length > 1) {\n", "\t\t\tObject.assign(attrs, argArray[1])\n\t\t\t}\n\t\t\treturn attrs\n\t\t},\n\t\tget(argArray) {\n\t\t\tlet attrs = {}\n\t\t\tif (Array.isArray(argArray[0])) {\n\t\t\t\tconst keys = argArray[0]\n\t\t\t\tattrs = {\n\t\t\t\t\t'do.storage.key': keys[0],\n", "\t\t\t\t'do.storage.number_of_keys': keys.length,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tattrs = {\n\t\t\t\t\t'do.storage.key': argArray[0],\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (argArray.length > 1) {\n\t\t\t\tObject.assign(attrs, argArray[1])\n\t\t\t}\n", "\t\treturn attrs\n\t\t},\n\t\tlist(argArray, result: Map<string, unknown>) {\n\t\t\t// list may be called with no arguments\n\t\t\tconst attrs: Attributes = {\n\t\t\t\t'do.storage.number_of_results': result.size,\n\t\t\t}\n\t\t\tObject.assign(attrs, argArray[0])\n\t\t\treturn attrs\n\t\t},\n", "\tput(argArray) {\n\t\t\tconst attrs = {\n\t\t\t\t'do.storage.key': argArray[0],\n\t\t\t}\n\t\t\tif (argArray.length > 2) {\n\t\t\t\tObject.assign(attrs, argArray[2])\n\t\t\t}\n\t\t\treturn attrs\n\t\t},\n\t}\n", "function instrumentStorageFn(fn: Function, operation: string) {\n\t\tconst tracer = trace.getTracer('do_storage')\n\t\tconst fnHandler: ProxyHandler<any> = {\n\t\t\tapply: (target, thisArg, argArray) => {\n\t\t\t\tconst options: SpanOptions = {\n\t\t\t\t\tkind: SpanKind.CLIENT,\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\toperation,\n\t\t\t\t\t},\n\t\t\t\t}\n", "\t\t\treturn tracer.startActiveSpan(`do:storage:${operation}`, options, async (span) => {\n\t\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\t\tconst extraAttrs = StorageAttributes[operation] ? StorageAttributes[operation](argArray, result) : {}\n\t\t\t\t\tspan.setAttributes(extraAttrs)\n\t\t\t\t\tspan.setAttribute('hasResult', !!result)\n\t\t\t\t\tspan.end()\n\t\t\t\t\treturn result\n\t\t\t\t})\n\t\t\t},\n\t\t}\n", "\treturn wrap(fn, fnHandler)\n\t}\n\texport function instrumentStorage(storage: DurableObjectStorage): DurableObjectStorage {\n\t\tconst storageHandler: ProxyHandler<DurableObjectStorage> = {\n\t\t\tget: (target, prop, receiver) => {\n\t\t\t\tconst operation = String(prop)\n\t\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\t\treturn instrumentStorageFn(fn, operation)\n\t\t\t},\n\t\t}\n", "\treturn wrap(storage, storageHandler)\n\t}\n"]}
{"filename": "src/instrumentation/common.ts", "chunked_list": ["import { trace } from '@opentelemetry/api'\n\timport { WorkerTracer } from '../tracer.js'\n\timport { passthroughGet, wrap } from '../wrap.js'\n\ttype ContextAndTracker = { ctx: ExecutionContext; tracker: PromiseTracker }\n\ttype WaitUntilFn = ExecutionContext['waitUntil']\n\texport class PromiseTracker {\n\t\t_outstandingPromises: Promise<unknown>[] = []\n\t\tget outstandingPromiseCount() {\n\t\t\treturn this._outstandingPromises.length\n\t\t}\n", "\ttrack(promise: Promise<unknown>): void {\n\t\t\tthis._outstandingPromises.push(promise)\n\t\t}\n\t\tasync wait() {\n\t\t\tawait allSettledMutable(this._outstandingPromises)\n\t\t}\n\t}\n\tfunction createWaitUntil(fn: WaitUntilFn, context: ExecutionContext, tracker: PromiseTracker): WaitUntilFn {\n\t\tconst handler: ProxyHandler<WaitUntilFn> = {\n\t\t\tapply(target, thisArg, argArray) {\n", "\t\t\ttracker.track(argArray[0])\n\t\t\t\treturn Reflect.apply(target, context, argArray)\n\t\t\t},\n\t\t}\n\t\treturn wrap(fn, handler)\n\t}\n\texport function proxyExecutionContext(context: ExecutionContext): ContextAndTracker {\n\t\tconst tracker = new PromiseTracker()\n\t\tconst ctx = new Proxy(context, {\n\t\t\tget(target, prop) {\n", "\t\t\tif (prop === 'waitUntil') {\n\t\t\t\t\tconst fn = Reflect.get(target, prop)\n\t\t\t\t\treturn createWaitUntil(fn, context, tracker)\n\t\t\t\t} else {\n\t\t\t\t\treturn passthroughGet(target, prop)\n\t\t\t\t}\n\t\t\t},\n\t\t})\n\t\treturn { ctx, tracker }\n\t}\n", "export async function exportSpans(tracker?: PromiseTracker) {\n\t\tconst tracer = trace.getTracer('export')\n\t\tif (tracer instanceof WorkerTracer) {\n\t\t\tawait scheduler.wait(1)\n\t\t\tif (tracker) {\n\t\t\t\tawait tracker.wait()\n\t\t\t}\n\t\t\tawait tracer.spanProcessor.forceFlush()\n\t\t} else {\n\t\t\tconsole.error('The global tracer is not of type WorkerTracer and can not export spans')\n", "\t}\n\t}\n\t/** Like `Promise.allSettled`, but handles modifications to the promises array */\n\texport async function allSettledMutable(promises: Promise<unknown>[]): Promise<PromiseSettledResult<unknown>[]> {\n\t\tlet values: PromiseSettledResult<unknown>[]\n\t\t// when the length of the array changes, there has been a nested call to waitUntil\n\t\t// and we should await the promises again\n\t\tdo {\n\t\t\tvalues = await Promise.allSettled(promises)\n\t\t} while (values.length !== promises.length)\n", "\treturn values\n\t}\n"]}
{"filename": "src/instrumentation/fetch.ts", "chunked_list": ["import {\n\t\ttrace,\n\t\tSpanOptions,\n\t\tSpanKind,\n\t\tpropagation,\n\t\tcontext as api_context,\n\t\tAttributes,\n\t\tException,\n\t\tContext,\n\t\tSpanStatusCode,\n", "} from '@opentelemetry/api'\n\timport { SemanticAttributes } from '@opentelemetry/semantic-conventions'\n\timport { Initialiser, getActiveConfig, setConfig } from '../config.js'\n\timport { wrap } from '../wrap.js'\n\timport { instrumentEnv } from './env.js'\n\timport { exportSpans, proxyExecutionContext } from './common.js'\n\timport { ResolvedTraceConfig } from '../types.js'\n\texport type IncludeTraceContextFn = (request: Request) => boolean\n\texport interface FetcherConfig {\n\t\tincludeTraceContext?: boolean | IncludeTraceContextFn\n", "}\n\texport type AcceptTraceContextFn = (request: Request) => boolean\n\texport interface FetchHandlerConfig {\n\t\t/**\n\t\t * Whether to enable context propagation for incoming requests to `fetch`.\n\t\t * This enables or disables distributed tracing from W3C Trace Context headers.\n\t\t * @default true\n\t\t */\n\t\tacceptTraceContext?: boolean | AcceptTraceContextFn\n\t}\n", "type FetchHandler = ExportedHandlerFetchHandler\n\ttype FetchHandlerArgs = Parameters<FetchHandler>\n\texport function sanitiseURL(url: string): string {\n\t\tconst u = new URL(url)\n\t\treturn `${u.protocol}//${u.host}${u.pathname}${u.search}`\n\t}\n\tconst gatherOutgoingCfAttributes = (cf: RequestInitCfProperties): Attributes => {\n\t\tconst attrs: Record<string, string | number> = {}\n\t\tObject.keys(cf).forEach((key) => {\n\t\t\tconst value = cf[key]\n", "\t\tif (typeof value === 'string' || typeof value === 'number') {\n\t\t\t\tattrs[`cf.${key}`] = value\n\t\t\t} else {\n\t\t\t\tattrs[`cf.${key}`] = JSON.stringify(value)\n\t\t\t}\n\t\t})\n\t\treturn attrs\n\t}\n\texport function gatherRequestAttributes(request: Request): Attributes {\n\t\tconst attrs: Record<string, string | number> = {}\n", "\tconst headers = request.headers\n\t\t// attrs[SemanticAttributes.HTTP_CLIENT_IP] = '1.1.1.1'\n\t\tattrs[SemanticAttributes.HTTP_METHOD] = request.method\n\t\tattrs[SemanticAttributes.HTTP_URL] = sanitiseURL(request.url)\n\t\tattrs[SemanticAttributes.HTTP_USER_AGENT] = headers.get('user-agent')!\n\t\tattrs[SemanticAttributes.HTTP_REQUEST_CONTENT_LENGTH] = headers.get('content-length')!\n\t\tattrs['http.request_content-type'] = headers.get('content-type')!\n\t\tattrs['http.accepts'] = headers.get('accepts')!\n\t\treturn attrs\n\t}\n", "export function gatherResponseAttributes(response: Response): Attributes {\n\t\tconst attrs: Record<string, string | number> = {}\n\t\tattrs[SemanticAttributes.HTTP_STATUS_CODE] = response.status\n\t\tattrs[SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH] = response.headers.get('content-length')!\n\t\tattrs['http.response_content-type'] = response.headers.get('content-type')!\n\t\treturn attrs\n\t}\n\texport function gatherIncomingCfAttributes(request: Request): Attributes {\n\t\tconst attrs: Record<string, string | number> = {}\n\t\tattrs[SemanticAttributes.HTTP_SCHEME] = request.cf?.httpProtocol as string\n", "\tattrs['net.colo'] = request.cf?.colo as string\n\t\tattrs['net.country'] = request.cf?.country as string\n\t\tattrs['net.request_priority'] = request.cf?.requestPriority as string\n\t\tattrs['net.tls_cipher'] = request.cf?.tlsCipher as string\n\t\tattrs['net.tls_version'] = request.cf?.tlsVersion as string\n\t\tattrs['net.asn'] = request.cf?.asn as number\n\t\tattrs['net.tcp_rtt'] = request.cf?.clientTcpRtt as number\n\t\treturn attrs\n\t}\n\texport function getParentContextFromHeaders(headers: Headers): Context {\n", "\treturn propagation.extract(api_context.active(), headers, {\n\t\t\tget(headers, key) {\n\t\t\t\treturn headers.get(key) || undefined\n\t\t\t},\n\t\t\tkeys(headers) {\n\t\t\t\treturn [...headers.keys()]\n\t\t\t},\n\t\t})\n\t}\n\tfunction getParentContextFromRequest(request: Request) {\n", "\tconst workerConfig = getActiveConfig()\n\t\tconst acceptTraceContext =\n\t\t\ttypeof workerConfig.handlers.fetch.acceptTraceContext === 'function'\n\t\t\t\t? workerConfig.handlers.fetch.acceptTraceContext(request)\n\t\t\t\t: workerConfig.handlers.fetch.acceptTraceContext ?? true\n\t\treturn acceptTraceContext ? getParentContextFromHeaders(request.headers) : api_context.active()\n\t}\n\texport function waitUntilTrace(fn: () => Promise<any>): Promise<void> {\n\t\tconst tracer = trace.getTracer('waitUntil')\n\t\treturn tracer.startActiveSpan('waitUntil', async (span) => {\n", "\t\tawait fn()\n\t\t\tspan.end()\n\t\t})\n\t}\n\tlet cold_start = true\n\texport function executeFetchHandler(fetchFn: FetchHandler, [request, env, ctx]: FetchHandlerArgs): Promise<Response> {\n\t\tconst spanContext = getParentContextFromRequest(request)\n\t\tconst tracer = trace.getTracer('fetchHandler')\n\t\tconst attributes = {\n\t\t\t[SemanticAttributes.FAAS_TRIGGER]: 'http',\n", "\t\t[SemanticAttributes.FAAS_COLDSTART]: cold_start,\n\t\t\t[SemanticAttributes.FAAS_EXECUTION]: request.headers.get('cf-ray') ?? undefined,\n\t\t}\n\t\tcold_start = false\n\t\tObject.assign(attributes, gatherRequestAttributes(request))\n\t\tObject.assign(attributes, gatherIncomingCfAttributes(request))\n\t\tconst options: SpanOptions = {\n\t\t\tattributes,\n\t\t\tkind: SpanKind.SERVER,\n\t\t}\n", "\tconst promise = tracer.startActiveSpan('fetchHandler', options, spanContext, async (span) => {\n\t\t\ttry {\n\t\t\t\tconst response: Response = await fetchFn(request, env, ctx)\n\t\t\t\tif (response.status < 500) {\n\t\t\t\t\tspan.setStatus({ code: SpanStatusCode.OK })\n\t\t\t\t}\n\t\t\t\tspan.setAttributes(gatherResponseAttributes(response))\n\t\t\t\tspan.end()\n\t\t\t\treturn response\n\t\t\t} catch (error) {\n", "\t\t\tspan.recordException(error as Exception)\n\t\t\t\tspan.setStatus({ code: SpanStatusCode.ERROR })\n\t\t\t\tspan.end()\n\t\t\t\tthrow error\n\t\t\t}\n\t\t})\n\t\treturn promise\n\t}\n\texport function createFetchHandler(fetchFn: FetchHandler, initialiser: Initialiser) {\n\t\tconst fetchHandler: ProxyHandler<FetchHandler> = {\n", "\t\tapply: async (target, _thisArg, argArray: Parameters<FetchHandler>): Promise<Response> => {\n\t\t\t\tconst [request, orig_env, orig_ctx] = argArray\n\t\t\t\tconst config = initialiser(orig_env as Record<string, unknown>, request)\n\t\t\t\tconst env = instrumentEnv(orig_env as Record<string, unknown>)\n\t\t\t\tconst { ctx, tracker } = proxyExecutionContext(orig_ctx)\n\t\t\t\tconst context = setConfig(config)\n\t\t\t\ttry {\n\t\t\t\t\tconst args: FetchHandlerArgs = [request, env, ctx]\n\t\t\t\t\treturn await api_context.with(context, executeFetchHandler, undefined, target, args)\n\t\t\t\t} catch (error) {\n", "\t\t\t\tthrow error\n\t\t\t\t} finally {\n\t\t\t\t\torig_ctx.waitUntil(exportSpans(tracker))\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\treturn wrap(fetchFn, fetchHandler)\n\t}\n\ttype getFetchConfig = (config: ResolvedTraceConfig) => FetcherConfig\n\texport function instrumentFetcher(\n", "\tfetchFn: Fetcher['fetch'],\n\t\tconfigFn: getFetchConfig,\n\t\tattrs?: Attributes\n\t): Fetcher['fetch'] {\n\t\tconst handler: ProxyHandler<typeof fetch> = {\n\t\t\tapply: (target, thisArg, argArray): ReturnType<typeof fetch> => {\n\t\t\t\tconst workerConfig = getActiveConfig()\n\t\t\t\tconst config = configFn(workerConfig)\n\t\t\t\tconst request = new Request(argArray[0], argArray[1])\n\t\t\t\tconst tracer = trace.getTracer('fetcher')\n", "\t\t\tconst options: SpanOptions = { kind: SpanKind.CLIENT, attributes: attrs }\n\t\t\t\tconst host = new URL(request.url).host\n\t\t\t\tconst spanName = typeof attrs?.['name'] === 'string' ? attrs?.['name'] : `fetch: ${host}`\n\t\t\t\tconst promise = tracer.startActiveSpan(spanName, options, async (span) => {\n\t\t\t\t\tconst includeTraceContext =\n\t\t\t\t\t\ttypeof config.includeTraceContext === 'function'\n\t\t\t\t\t\t\t? config.includeTraceContext(request)\n\t\t\t\t\t\t\t: config.includeTraceContext\n\t\t\t\t\tif (includeTraceContext ?? true) {\n\t\t\t\t\t\tpropagation.inject(api_context.active(), request.headers, {\n", "\t\t\t\t\t\tset: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\tspan.setAttributes(gatherRequestAttributes(request))\n\t\t\t\t\tif (request.cf) span.setAttributes(gatherOutgoingCfAttributes(request.cf))\n\t\t\t\t\tconst response: Response = await Reflect.apply(target, thisArg, [request])\n\t\t\t\t\tspan.setAttributes(gatherResponseAttributes(response))\n\t\t\t\t\tspan.end()\n\t\t\t\t\treturn response\n\t\t\t\t})\n", "\t\t\treturn promise\n\t\t\t},\n\t\t}\n\t\treturn wrap(fetchFn, handler, true)\n\t}\n\texport function instrumentGlobalFetch(): void {\n\t\tglobalThis.fetch = instrumentFetcher(globalThis.fetch, (config) => config.fetch)\n\t}\n"]}
{"filename": "src/instrumentation/cache.ts", "chunked_list": ["import { SpanKind, SpanOptions, trace } from '@opentelemetry/api'\n\timport { wrap } from '../wrap.js'\n\timport { sanitiseURL } from './fetch.js'\n\ttype CacheFns = Cache[keyof Cache]\n\tconst tracer = trace.getTracer('cache instrumentation')\n\tfunction instrumentFunction<T extends CacheFns>(fn: T, cacheName: string, op: string): T {\n\t\tconst handler: ProxyHandler<typeof fn> = {\n\t\t\tasync apply(target, thisArg, argArray) {\n\t\t\t\tconst attributes = {\n\t\t\t\t\t'cache.name': cacheName,\n", "\t\t\t\t'http.url': argArray[0].url ? sanitiseURL(argArray[0].url) : undefined,\n\t\t\t\t\t'cache.operation': op,\n\t\t\t\t}\n\t\t\t\tconst options: SpanOptions = { kind: SpanKind.CLIENT, attributes }\n\t\t\t\treturn tracer.startActiveSpan(`cache:${cacheName}:${op}`, options, async (span) => {\n\t\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\t\tif (op === 'match') {\n\t\t\t\t\t\tspan.setAttribute('cache.hit', !result)\n\t\t\t\t\t}\n\t\t\t\t\tspan.end()\n", "\t\t\t\treturn result\n\t\t\t\t})\n\t\t\t},\n\t\t}\n\t\treturn wrap(fn, handler)\n\t}\n\tfunction instrumentCache(cache: Cache, cacheName: string): Cache {\n\t\tconst handler: ProxyHandler<typeof cache> = {\n\t\t\tget(target, prop) {\n\t\t\t\tif (prop === 'delete' || prop === 'match' || prop === 'put') {\n", "\t\t\t\tconst fn = Reflect.get(target, prop).bind(target)\n\t\t\t\t\treturn instrumentFunction(fn, cacheName, prop)\n\t\t\t\t} else {\n\t\t\t\t\treturn Reflect.get(target, prop)\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\treturn wrap(cache, handler)\n\t}\n\tfunction instrumentOpen(openFn: CacheStorage['open']): CacheStorage['open'] {\n", "\tconst handler: ProxyHandler<typeof openFn> = {\n\t\t\tasync apply(target, thisArg, argArray) {\n\t\t\t\tconst cacheName = argArray[0]\n\t\t\t\tconst cache = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\treturn instrumentCache(cache, cacheName)\n\t\t\t},\n\t\t}\n\t\treturn wrap(openFn, handler)\n\t}\n\tfunction _instrumentGlobalCache() {\n", "\tconst handler: ProxyHandler<typeof caches> = {\n\t\t\tget(target, prop) {\n\t\t\t\tif (prop === 'default') {\n\t\t\t\t\tconst cache = target.default\n\t\t\t\t\treturn instrumentCache(cache, 'default')\n\t\t\t\t} else if (prop === 'open') {\n\t\t\t\t\tconst openFn = Reflect.get(target, prop).bind(target)\n\t\t\t\t\treturn instrumentOpen(openFn)\n\t\t\t\t} else {\n\t\t\t\t\treturn Reflect.get(target, prop)\n", "\t\t\t}\n\t\t\t},\n\t\t}\n\t\t//@ts-ignore\n\t\tglobalThis.caches = wrap(caches, handler)\n\t}\n\texport function instrumentGlobalCache() {\n\t\treturn _instrumentGlobalCache()\n\t}\n"]}
{"filename": "src/instrumentation/kv.ts", "chunked_list": ["import { Attributes, SpanKind, SpanOptions, trace } from '@opentelemetry/api'\n\timport { wrap } from '../wrap.js'\n\ttype ExtraAttributeFn = (argArray: any[], result: any) => Attributes\n\tconst KVAttributes: Record<string | symbol, ExtraAttributeFn> = {\n\t\tdelete(argArray) {\n\t\t\treturn {\n\t\t\t\t'kv.key': argArray[0],\n\t\t\t}\n\t\t},\n\t\tget(argArray) {\n", "\t\tconst attrs: Attributes = {\n\t\t\t\t'kv.key': argArray[0],\n\t\t\t}\n\t\t\tconst opts = argArray[1]\n\t\t\tif (typeof opts === 'string') {\n\t\t\t\tattrs['type'] = opts\n\t\t\t} else if (typeof opts === 'object') {\n\t\t\t\tattrs['type'] = opts.type\n\t\t\t\tattrs['cacheTtl'] = opts.cacheTtl\n\t\t\t}\n", "\t\treturn attrs\n\t\t},\n\t\tgetWithMetadata(argArray, result) {\n\t\t\tconst attrs = this.get(argArray, result)\n\t\t\tattrs['withMetadata'] = true\n\t\t\treturn attrs\n\t\t},\n\t\tlist(argArray, result) {\n\t\t\tconst attrs: Attributes = {}\n\t\t\tconst opts: KVNamespaceListOptions = argArray[0] || {}\n", "\t\tconst { cursor, limit, prefix } = opts\n\t\t\tattrs['kv.list_prefix'] = prefix || undefined\n\t\t\tattrs['kv.list_request_cursor'] = cursor || undefined\n\t\t\tattrs['kv.list_limit'] = limit || undefined\n\t\t\tconst { list_complete } = result as KVNamespaceListResult<any, any>\n\t\t\tattrs['kv.list_complete'] = limit || undefined\n\t\t\tif (!list_complete) {\n\t\t\t\tattrs['kv.list_response_cursor'] = cursor || undefined\n\t\t\t}\n\t\t\treturn attrs\n", "\t},\n\t\tput(argArray) {\n\t\t\tconst attrs: Attributes = {\n\t\t\t\t'kv.key': argArray[0],\n\t\t\t}\n\t\t\tif (argArray.length > 2 && argArray[2]) {\n\t\t\t\tconst { expiration, expirationTtl, metadata } = argArray[2] as KVNamespacePutOptions\n\t\t\t\tattrs['kv.expiration'] = expiration\n\t\t\t\tattrs['kv.expirationTtl'] = expirationTtl\n\t\t\t\tattrs['kv.withMetadata'] = !!metadata\n", "\t\t}\n\t\t\treturn attrs\n\t\t},\n\t}\n\tfunction instrumentKVFn(fn: Function, name: string, operation: string) {\n\t\tconst tracer = trace.getTracer('KV')\n\t\tconst fnHandler: ProxyHandler<any> = {\n\t\t\tapply: (target, thisArg, argArray) => {\n\t\t\t\tconst options: SpanOptions = {\n\t\t\t\t\tkind: SpanKind.CLIENT,\n", "\t\t\t\tattributes: {\n\t\t\t\t\t\tbinding_type: 'KV',\n\t\t\t\t\t\tkv_namespace: name,\n\t\t\t\t\t\toperation,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\treturn tracer.startActiveSpan(`kv:${name}:${operation}`, options, async (span) => {\n\t\t\t\t\tconst result = await Reflect.apply(target, thisArg, argArray)\n\t\t\t\t\tconst extraAttrs = KVAttributes[operation] ? KVAttributes[operation](argArray, result) : {}\n\t\t\t\t\tspan.setAttributes(extraAttrs)\n", "\t\t\t\tspan.setAttribute('hasResult', !!result)\n\t\t\t\t\tspan.end()\n\t\t\t\t\treturn result\n\t\t\t\t})\n\t\t\t},\n\t\t}\n\t\treturn wrap(fn, fnHandler)\n\t}\n\texport function instrumentKV(kv: KVNamespace, name: string): KVNamespace {\n\t\tconst kvHandler: ProxyHandler<KVNamespace> = {\n", "\t\tget: (target, prop, receiver) => {\n\t\t\t\tconst operation = String(prop)\n\t\t\t\tconst fn = Reflect.get(target, prop, receiver)\n\t\t\t\treturn instrumentKVFn(fn, name, operation)\n\t\t\t},\n\t\t}\n\t\treturn wrap(kv, kvHandler)\n\t}\n"]}
