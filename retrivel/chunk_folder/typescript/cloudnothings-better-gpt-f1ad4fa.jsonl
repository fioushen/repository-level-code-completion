{"filename": "src/pages/api/trpc/[trpc].ts", "chunked_list": ["import { createNextApiHandler } from \"@trpc/server/adapters/next\";\n\timport { env } from \"~/env.mjs\";\n\timport { createTRPCContext } from \"~/server/api/trpc\";\n\timport { appRouter } from \"~/server/api/root\";\n\t// export API handler\n\texport default createNextApiHandler({\n\t  router: appRouter,\n\t  createContext: createTRPCContext,\n\t  onError:\n\t    env.NODE_ENV === \"development\"\n", "      ? ({ path, error }) => {\n\t          console.error(\n\t            `‚ùå tRPC failed on ${path ?? \"<no-path>\"}: ${error.message}`,\n\t          );\n\t        }\n\t      : undefined,\n\t});\n"]}
{"filename": "src/pages/api/auth/[...nextauth].ts", "chunked_list": ["import NextAuth from \"next-auth\";\n\timport { authOptions } from \"~/server/auth\";\n\texport default NextAuth(authOptions);\n"]}
{"filename": "src/store/store.ts", "chunked_list": ["import { create } from \"zustand\";\n\timport type { Model, Profile, Thread } from \"~/types/appstate\";\n\tconst models = [\n\t  {\n\t    name: \"GPT-3.5-TURBO\",\n\t    id: \"gpt-3.5-turbo\",\n\t    description:\n\t      \"Most capable GPT-3.5 model and optimized for chat at 1/10th the cost of text-davinci-003. Will be updated with our latest model iteration.\",\n\t    maxTokens: 4096,\n\t    usageCost: 0.002,\n", "    trainingData: \"Up to Sep 2021\",\n\t  },\n\t  {\n\t    name: \"GPT-3.5-TURBO-0301\",\n\t    id: \"gpt-3.5-turbo-0301\",\n\t    description:\n\t      \"Snapshot of gpt-3.5-turbo from March 1st 2023. Unlike gpt-3.5-turbo, this model will not receive updates, and will only be supported for a three month period ending on June 1st 2023.\",\n\t    maxTokens: 4096,\n\t    usageCost: 0.002,\n\t    trainingData: \"Up to Sep 2021\",\n", "  },\n\t  {\n\t    name: \"GPT-4 (Limited Beta)\",\n\t    id: \"gpt-4\",\n\t    description:\n\t      \"More capable than any GPT-3.5 model, able to do more complex tasks, and optimized for chat. Will be updated with our latest model iteration.\",\n\t    maxTokens: 8192,\n\t    promptCost: 0.03,\n\t    completionCost: 0.06,\n\t    trainingData: \"Up to Sep 2021\",\n", "    note: \"you need API Access to GPT-4 to use this model. If you haven't already, join the waitlist here: https://openai.com/waitlist/gpt-4-api\",\n\t  },\n\t  {\n\t    name: \"GPT-4-0314 (Limited Beta)\",\n\t    id: \"gpt-4-0314\",\n\t    description:\n\t      \"Snapshot of gpt-4 from March 14th 2023. Unlike gpt-4, this model will not receive updates, and will only be supported for a three month period ending on June 14th 2023.\",\n\t    maxTokens: 8192,\n\t    promptCost: 0.03,\n\t    completionCost: 0.06,\n", "    trainingData: \"Up to Sep 2021\",\n\t    note: \"you need API Access to GPT-4 to use this model. If you haven't already, join the waitlist here: https://openai.com/waitlist/gpt-4-api\",\n\t  },\n\t  {\n\t    name: \"GPT-4-32K (Limited Beta)\",\n\t    id: \"gpt-4-32k\",\n\t    description:\n\t      \"Same capabilities as GPT-4, but with 4x the context length. Will be updated with our latest model iteration.\",\n\t    trainingData: \"Up to Sep 2021\",\n\t    promptCost: 0.06,\n", "    completionCost: 0.12,\n\t    maxTokens: 32768,\n\t    note: \"you need API Access to GPT-4 to use this model. If you haven't already, join the waitlist here: https://openai.com/waitlist/gpt-4-api\",\n\t  },\n\t  {\n\t    name: \"GPT-4-32K-0314 (Limited Beta)\",\n\t    id: \"gpt-4-32k-0314\",\n\t    description:\n\t      \"Snapshot of gpt-4-32k from March 14th 2023. Unlike gpt-4-32k, this model will not receive updates, and will only be supported for a three month period ending on June 14th 2023.\",\n\t    trainingData: \"Up to Sep 2021\",\n", "    promptCost: 0.06,\n\t    completionCost: 0.12,\n\t    maxTokens: 32768,\n\t    note: \"you need API Access to GPT-4 to use this model. If you haven't already, join the waitlist here: https://openai.com/waitlist/gpt-4-api\",\n\t  },\n\t] as Model[];\n\tconst initialThread = {\n\t  id: \"\",\n\t  name: \"\",\n\t  profileId: \"\",\n", "  budget: 0,\n\t  cost: 0,\n\t  description: \"\",\n\t  initialSystemInstruction: \"\",\n\t  messages: [],\n\t  model: models[0] as Model,\n\t  starred: false,\n\t  title: \"\",\n\t} as Thread;\n\texport const initialValues = {\n", "  profile: {\n\t    id: \"\",\n\t    name: \"\",\n\t    model: models[0] as Model,\n\t    budget: 0,\n\t    cost: 0,\n\t    usage: {\n\t      completion_tokens: 0,\n\t      prompt_tokens: 0,\n\t      total_tokens: 0,\n", "    },\n\t    key: \"\",\n\t    threadIds: [],\n\t    organization: \"\",\n\t  } as Profile,\n\t  profiles: [] as Profile[],\n\t  selectedProfile: \"\",\n\t  thread: initialThread,\n\t  threads: [] as Thread[],\n\t  selectedApiKey: 0,\n", "  apiKeyModal: false,\n\t  apiKeyError: false,\n\t  modelModal: false,\n\t  models,\n\t  width: 0,\n\t};\n\tconst getLocalProfileList = () => {\n\t  const raw = localStorage.getItem(\"Profiles\");\n\t  if (!raw) {\n\t    return null;\n", "  }\n\t  return JSON.parse(raw) as string[];\n\t};\n\tconst getSelectedProfile = () => {\n\t  const raw = localStorage.getItem(\"SelectedProfile\");\n\t  if (!raw) {\n\t    return null;\n\t  }\n\t  return JSON.parse(raw) as string;\n\t};\n", "export const getProfile = (id: string) => {\n\t  const raw = localStorage.getItem(\"Profile_\" + id);\n\t  if (!raw) {\n\t    return;\n\t  }\n\t  return JSON.parse(raw) as Profile;\n\t};\n\tconst loadProfiles = () => {\n\t  const profileList = getLocalProfileList();\n\t  if (!profileList) {\n", "    return null;\n\t  }\n\t  const selectedProfile = getSelectedProfile();\n\t  if (!selectedProfile) {\n\t    return null;\n\t  }\n\t  const profiles: Profile[] = [];\n\t  for (const id of profileList) {\n\t    const profile = getProfile(id);\n\t    if (!profile) {\n", "      continue;\n\t    }\n\t    profiles.push(profile);\n\t  }\n\t  if (profiles.length === 0) {\n\t    return null;\n\t  }\n\t  const profile = profiles.find((p) => p.id === selectedProfile);\n\t  if (!profile) {\n\t    const profile = profiles[0] as Profile;\n", "    return { profiles, profile, selectedProfile: profile.id };\n\t  }\n\t  return { profiles, profile, selectedProfile };\n\t};\n\texport const getThread = (id: string) => {\n\t  const raw = localStorage.getItem(\"Thread_\" + id);\n\t  if (raw) {\n\t    return JSON.parse(raw) as Thread;\n\t  }\n\t};\n", "export const loadData = () => {\n\t  const profileData = loadProfiles();\n\t  if (!profileData) {\n\t    return null;\n\t  }\n\t  const { profiles, profile, selectedProfile } = profileData;\n\t  const threads = profile.threadIds\n\t    .map((id) => getThread(id))\n\t    .filter((t) => t !== undefined) as Thread[];\n\t  return { profiles, profile, selectedProfile, threads };\n", "};\n\tinterface Store {\n\t  profile: Profile;\n\t  setProfile: (value: Profile) => void;\n\t  addProfile: (value: Profile) => void;\n\t  deleteProfile: (value: Profile) => void;\n\t  selectedProfile: string;\n\t  setSelectedProfile: (value: string) => void;\n\t  profiles: Profile[];\n\t  setProfiles: (value: Profile[]) => void;\n", "  thread: Thread;\n\t  setThread: (value: Thread) => void;\n\t  addThread: (value: Thread) => void;\n\t  deleteThread: (value: Thread) => void;\n\t  threads: Thread[];\n\t  setThreads: (value: Thread[]) => void;\n\t  apiKeyModal: boolean;\n\t  setApiKeyModal: (value: boolean) => void;\n\t  apiKeyError: boolean;\n\t  setApiKeyError: (value: boolean) => void;\n", "  models: Model[];\n\t  setModels: (value: Model[]) => void;\n\t  modelModal: boolean;\n\t  setModelModal: (value: boolean) => void;\n\t  selectedApiKey: number;\n\t  setSelectedApiKey: (value: number) => void;\n\t  width: number;\n\t  setWidth: (value: number) => void;\n\t  resetValues: () => void;\n\t  resetThread: () => void;\n", "  load: () => void;\n\t}\n\tconst updateSelectedProfile = (id: string) => {\n\t  localStorage.setItem(\"SelectedProfile\", JSON.stringify(id));\n\t};\n\tconst updateProfile = (profile: Profile) => {\n\t  localStorage.setItem(\"Profile_\" + profile.id, JSON.stringify(profile));\n\t};\n\tconst addProfile = (profile: Profile) => {\n\t  localStorage.setItem(\"Profile_\" + profile.id, JSON.stringify(profile));\n", "  const profileList = getLocalProfileList();\n\t  if (profileList) {\n\t    localStorage.setItem(\n\t      \"Profiles\",\n\t      JSON.stringify([...profileList, profile.id])\n\t    );\n\t  } else {\n\t    localStorage.setItem(\"Profiles\", JSON.stringify([profile.id]));\n\t  }\n\t};\n", "const deleteProfile = (profile: Profile) => {\n\t  profile.threadIds.forEach((id) => deleteThread(id));\n\t  localStorage.removeItem(\"Profile_\" + profile.id);\n\t  const profileList = getLocalProfileList();\n\t  if (profileList) {\n\t    const newProfileList = profileList.filter((p) => p !== profile.id);\n\t    localStorage.setItem(\"Profiles\", JSON.stringify(newProfileList));\n\t    const selectedProfile = getSelectedProfile();\n\t    if (selectedProfile === profile.id) {\n\t      localStorage.removeItem(\"SelectedProfile\");\n", "    }\n\t    if (newProfileList.length === 0) {\n\t      localStorage.removeItem(\"Profiles\");\n\t    } else {\n\t      const newSelectedProfile = newProfileList[0];\n\t      localStorage.setItem(\n\t        \"SelectedProfile\",\n\t        JSON.stringify(newSelectedProfile)\n\t      );\n\t    }\n", "  }\n\t};\n\tconst updateThread = (thread: Thread) => {\n\t  localStorage.setItem(\"Thread_\" + thread.id, JSON.stringify(thread));\n\t};\n\tconst deleteThread = (id: string) => {\n\t  localStorage.removeItem(\"Thread_\" + id);\n\t};\n\tconst useStore = create<Store>((set) => ({\n\t  ...initialValues,\n", "  setProfiles: (value: Profile[]) => set({ profiles: value }),\n\t  setProfile: (value: Profile) => {\n\t    updateProfile(value);\n\t    set({ profile: value });\n\t  },\n\t  addProfile: (value: Profile) => {\n\t    addProfile(value);\n\t    set((state) => ({ profiles: [...state.profiles, value] }));\n\t  },\n\t  deleteProfile: (value: Profile) => {\n", "    deleteProfile(value);\n\t    set((state) => ({\n\t      profiles: state.profiles.filter((p) => p.id !== value.id),\n\t    }));\n\t  },\n\t  addThread: (value: Thread) => {\n\t    updateThread(value);\n\t    set((state) => ({\n\t      threads: [...state.threads, value],\n\t    }));\n", "  },\n\t  deleteThread: (value: Thread) => {\n\t    deleteThread(value.id);\n\t    set((state) => ({\n\t      threads: state.threads.filter((t) => t.id !== value.id),\n\t    }));\n\t  },\n\t  setSelectedProfile: (value: string) => {\n\t    updateSelectedProfile(value);\n\t    set({ selectedProfile: value });\n", "  },\n\t  setThread: (value: Thread) => {\n\t    updateThread(value);\n\t    set((state) => ({ thread: value, threads: [...state.threads, value] }));\n\t  },\n\t  setThreads: (value: Thread[]) => {\n\t    set({ threads: value });\n\t  },\n\t  setApiKeyModal: (value: boolean) => set({ apiKeyModal: value }),\n\t  setApiKeyError: (value: boolean) => set({ apiKeyError: value }),\n", "  setModels: (value: Model[]) => set({ models: value }),\n\t  setModelModal: (value: boolean) => set({ modelModal: value }),\n\t  setWidth: (value: number) => set({ width: value }),\n\t  setSelectedApiKey: (value: number) => set({ selectedApiKey: value }),\n\t  load: () => set({ ...initialValues, ...loadData() }),\n\t  resetThread: () => set({ thread: initialValues.thread }),\n\t  resetValues: () => set(initialValues),\n\t}));\n\texport default useStore;\n"]}
{"filename": "src/utils/api.ts", "chunked_list": ["/**\n\t * This is the client-side entrypoint for your tRPC API. It is used to create the `api` object which\n\t * contains the Next.js App-wrapper, as well as your type-safe React Query hooks.\n\t *\n\t * We also create a few inference helpers for input and output types.\n\t */\n\timport { httpBatchLink, loggerLink } from \"@trpc/client\";\n\timport { createTRPCNext } from \"@trpc/next\";\n\timport { type inferRouterInputs, type inferRouterOutputs } from \"@trpc/server\";\n\timport superjson from \"superjson\";\n", "import { type AppRouter } from \"~/server/api/root\";\n\tconst getBaseUrl = () => {\n\t  if (typeof window !== \"undefined\") return \"\"; // browser should use relative url\n\t  if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`; // SSR should use vercel url\n\t  return `http://localhost:${process.env.PORT ?? 3000}`; // dev SSR should use localhost\n\t};\n\t/** A set of type-safe react-query hooks for your tRPC API. */\n\texport const api = createTRPCNext<AppRouter>({\n\t  config() {\n\t    return {\n", "      /**\n\t       * Transformer used for data de-serialization from the server.\n\t       *\n\t       * @see https://trpc.io/docs/data-transformers\n\t       */\n\t      transformer: superjson,\n\t      /**\n\t       * Links used to determine request flow from client to server.\n\t       *\n\t       * @see https://trpc.io/docs/links\n", "       */\n\t      links: [\n\t        loggerLink({\n\t          enabled: (opts) =>\n\t            process.env.NODE_ENV === \"development\" ||\n\t            (opts.direction === \"down\" && opts.result instanceof Error),\n\t        }),\n\t        httpBatchLink({\n\t          url: `${getBaseUrl()}/api/trpc`,\n\t        }),\n", "      ],\n\t    };\n\t  },\n\t  /**\n\t   * Whether tRPC should await queries when server rendering pages.\n\t   *\n\t   * @see https://trpc.io/docs/nextjs#ssr-boolean-default-false\n\t   */\n\t  ssr: false,\n\t});\n", "/**\n\t * Inference helper for inputs.\n\t *\n\t * @example type HelloInput = RouterInputs['example']['hello']\n\t */\n\texport type RouterInputs = inferRouterInputs<AppRouter>;\n\t/**\n\t * Inference helper for outputs.\n\t *\n\t * @example type HelloOutput = RouterOutputs['example']['hello']\n", " */\n\texport type RouterOutputs = inferRouterOutputs<AppRouter>;\n"]}
{"filename": "src/server/auth.ts", "chunked_list": ["import { type GetServerSidePropsContext } from \"next\";\n\timport {\n\t  getServerSession,\n\t  type NextAuthOptions,\n\t  type DefaultSession,\n\t} from \"next-auth\";\n\timport AzureADProvider from \"next-auth/providers/azure-ad\";\n\timport { PrismaAdapter } from \"@next-auth/prisma-adapter\";\n\timport { env } from \"~/env.mjs\";\n\timport { prisma } from \"~/server/db\";\n", "/**\n\t * Module augmentation for `next-auth` types. Allows us to add custom properties to the `session`\n\t * object and keep type safety.\n\t *\n\t * @see https://next-auth.js.org/getting-started/typescript#module-augmentation\n\t */\n\tdeclare module \"next-auth\" {\n\t  interface Session extends DefaultSession {\n\t    user: {\n\t      id: string;\n", "      // ...other properties\n\t      // role: UserRole;\n\t    } & DefaultSession[\"user\"];\n\t  }\n\t  // interface User {\n\t  //   // ...other properties\n\t  //   // role: UserRole;\n\t  // }\n\t}\n\t/**\n", " * Options for NextAuth.js used to configure adapters, providers, callbacks, etc.\n\t *\n\t * @see https://next-auth.js.org/configuration/options\n\t */\n\texport const authOptions: NextAuthOptions = {\n\t  callbacks: {\n\t    session({ session, user }) {\n\t      if (session.user) {\n\t        session.user.id = user.id;\n\t        // session.user.role = user.role; <-- put other properties on the session here\n", "      }\n\t      return session;\n\t    },\n\t  },\n\t  adapter: PrismaAdapter(prisma),\n\t  providers: [\n\t    AzureADProvider({\n\t      clientId: env.AZURE_CLIENT_ID,\n\t      clientSecret: env.AZURE_CLIENT_SECRET,\n\t    }),\n", "    /**\n\t     * ...add more providers here.\n\t     *\n\t     * Most other providers require a bit more work than the Discord provider. For example, the\n\t     * GitHub provider requires you to add the `refresh_token_expires_in` field to the Account\n\t     * model. Refer to the NextAuth.js docs for the provider you want to use. Example:\n\t     *\n\t     * @see https://next-auth.js.org/providers/github\n\t     */\n\t  ],\n", "};\n\t/**\n\t * Wrapper for `getServerSession` so that you don't need to import the `authOptions` in every file.\n\t *\n\t * @see https://next-auth.js.org/configuration/nextjs\n\t */\n\texport const getServerAuthSession = (ctx: {\n\t  req: GetServerSidePropsContext[\"req\"];\n\t  res: GetServerSidePropsContext[\"res\"];\n\t}) => {\n", "  return getServerSession(ctx.req, ctx.res, authOptions);\n\t};\n"]}
{"filename": "src/server/db.ts", "chunked_list": ["import { PrismaClient } from \"@prisma/client\";\n\timport { env } from \"~/env.mjs\";\n\tconst globalForPrisma = globalThis as unknown as { prisma: PrismaClient };\n\texport const prisma =\n\t  globalForPrisma.prisma ||\n\t  new PrismaClient({\n\t    log:\n\t      env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n\t  });\n\tif (env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n"]}
{"filename": "src/server/api/trpc.ts", "chunked_list": ["/**\n\t * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:\n\t * 1. You want to modify request context (see Part 1).\n\t * 2. You want to create a new middleware or type of procedure (see Part 3).\n\t *\n\t * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will\n\t * need to use are documented accordingly near the end.\n\t */\n\t/**\n\t * 1. CONTEXT\n", " *\n\t * This section defines the \"contexts\" that are available in the backend API.\n\t *\n\t * These allow you to access things when processing a request, like the database, the session, etc.\n\t */\n\timport { type CreateNextContextOptions } from \"@trpc/server/adapters/next\";\n\timport { type Session } from \"next-auth\";\n\timport { getServerAuthSession } from \"~/server/auth\";\n\timport { prisma } from \"~/server/db\";\n\ttype CreateContextOptions = {\n", "  session: Session | null;\n\t};\n\t/**\n\t * This helper generates the \"internals\" for a tRPC context. If you need to use it, you can export\n\t * it from here.\n\t *\n\t * Examples of things you may need it for:\n\t * - testing, so we don't have to mock Next.js' req/res\n\t * - tRPC's `createSSGHelpers`, where we don't have req/res\n\t *\n", " * @see https://create.t3.gg/en/usage/trpc#-servertrpccontextts\n\t */\n\tconst createInnerTRPCContext = (opts: CreateContextOptions) => {\n\t  return {\n\t    session: opts.session,\n\t    prisma,\n\t  };\n\t};\n\t/**\n\t * This is the actual context you will use in your router. It will be used to process every request\n", " * that goes through your tRPC endpoint.\n\t *\n\t * @see https://trpc.io/docs/context\n\t */\n\texport const createTRPCContext = async (opts: CreateNextContextOptions) => {\n\t  const { req, res } = opts;\n\t  // Get the session from the server using the getServerSession wrapper function\n\t  const session = await getServerAuthSession({ req, res });\n\t  return createInnerTRPCContext({\n\t    session,\n", "  });\n\t};\n\t/**\n\t * 2. INITIALIZATION\n\t *\n\t * This is where the tRPC API is initialized, connecting the context and transformer. We also parse\n\t * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation\n\t * errors on the backend.\n\t */\n\timport { initTRPC, TRPCError } from \"@trpc/server\";\n", "import superjson from \"superjson\";\n\timport { ZodError } from \"zod\";\n\tconst t = initTRPC.context<typeof createTRPCContext>().create({\n\t  transformer: superjson,\n\t  errorFormatter({ shape, error }) {\n\t    return {\n\t      ...shape,\n\t      data: {\n\t        ...shape.data,\n\t        zodError:\n", "          error.cause instanceof ZodError ? error.cause.flatten() : null,\n\t      },\n\t    };\n\t  },\n\t});\n\t/**\n\t * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)\n\t *\n\t * These are the pieces you use to build your tRPC API. You should import these a lot in the\n\t * \"/src/server/api/routers\" directory.\n", " */\n\t/**\n\t * This is how you create new routers and sub-routers in your tRPC API.\n\t *\n\t * @see https://trpc.io/docs/router\n\t */\n\texport const createTRPCRouter = t.router;\n\t/**\n\t * Public (unauthenticated) procedure\n\t *\n", " * This is the base piece you use to build new queries and mutations on your tRPC API. It does not\n\t * guarantee that a user querying is authorized, but you can still access user session data if they\n\t * are logged in.\n\t */\n\texport const publicProcedure = t.procedure;\n\t/** Reusable middleware that enforces users are logged in before running the procedure. */\n\tconst enforceUserIsAuthed = t.middleware(({ ctx, next }) => {\n\t  if (!ctx.session || !ctx.session.user) {\n\t    throw new TRPCError({ code: \"UNAUTHORIZED\" });\n\t  }\n", "  return next({\n\t    ctx: {\n\t      // infers the `session` as non-nullable\n\t      session: { ...ctx.session, user: ctx.session.user },\n\t    },\n\t  });\n\t});\n\t/**\n\t * Protected (authenticated) procedure\n\t *\n", " * If you want a query or mutation to ONLY be accessible to logged in users, use this. It verifies\n\t * the session is valid and guarantees `ctx.session.user` is not null.\n\t *\n\t * @see https://trpc.io/docs/procedures\n\t */\n\texport const protectedProcedure = t.procedure.use(enforceUserIsAuthed);\n"]}
{"filename": "src/server/api/root.ts", "chunked_list": ["import { createTRPCRouter } from \"~/server/api/trpc\";\n\timport { exampleRouter } from \"~/server/api/routers/example\";\n\timport { gptRouter } from \"./routers/gpt\";\n\t/**\n\t * This is the primary router for your server.\n\t *\n\t * All routers added in /api/routers should be manually added here.\n\t */\n\texport const appRouter = createTRPCRouter({\n\t  example: exampleRouter,\n", "  gpt: gptRouter,\n\t});\n\t// export type definition of API\n\texport type AppRouter = typeof appRouter;\n"]}
{"filename": "src/server/api/routers/gpt.ts", "chunked_list": ["import { TRPCError } from \"@trpc/server\";\n\timport { Configuration, OpenAIApi } from \"openai\";\n\timport { type AxiosError } from \"axios\";\n\timport { z } from \"zod\";\n\timport {\n\t  createTRPCRouter,\n\t  publicProcedure,\n\t  protectedProcedure,\n\t} from \"~/server/api/trpc\";\n\timport type { Message } from \"~/types/appstate\";\n", "export type ChatResponse = {\n\t  id: string;\n\t  created: number;\n\t  model: string;\n\t  choices: [\n\t    {\n\t      finish_reason: string;\n\t      index: number;\n\t      message: Message;\n\t    }\n", "  ];\n\t  object: string;\n\t  usage: {\n\t    completion_tokens: number;\n\t    prompt_tokens: number;\n\t    total_tokens: number;\n\t  };\n\t};\n\texport const gptRouter = createTRPCRouter({\n\t  post: publicProcedure\n", "    .input(\n\t      z.object({\n\t        apiKey: z.string(),\n\t        model: z.string(),\n\t        messages: z.array(\n\t          z.object({\n\t            role: z.enum([\"user\", \"system\", \"assistant\"]),\n\t            content: z.string(),\n\t          })\n\t        ),\n", "      })\n\t    )\n\t    .mutation(async ({ input }) => {\n\t      const configuration = new Configuration({\n\t        apiKey: input.apiKey,\n\t      });\n\t      const openai = new OpenAIApi(configuration);\n\t      const response = await openai\n\t        .createChatCompletion({\n\t          model: input.model,\n", "          messages: input.messages,\n\t        })\n\t        .catch((error: AxiosError) => {\n\t          console.error(error);\n\t          if (error.response) {\n\t            console.log(error.response.status);\n\t            console.log(error.response.data);\n\t            throw new TRPCError({\n\t              code: \"INTERNAL_SERVER_ERROR\",\n\t              cause: error.response.data,\n", "              message: error.message,\n\t            });\n\t          } else {\n\t            console.log(error.message);\n\t            throw new TRPCError({\n\t              code: \"INTERNAL_SERVER_ERROR\",\n\t              message: error.message,\n\t            });\n\t          }\n\t        });\n", "      return response.data as ChatResponse;\n\t    }),\n\t});\n"]}
{"filename": "src/server/api/routers/example.ts", "chunked_list": ["import { z } from \"zod\";\n\timport {\n\t  createTRPCRouter,\n\t  publicProcedure,\n\t  protectedProcedure,\n\t} from \"~/server/api/trpc\";\n\texport const exampleRouter = createTRPCRouter({\n\t  hello: publicProcedure\n\t    .input(z.object({ text: z.string() }))\n\t    .query(({ input }) => {\n", "      return {\n\t        greeting: `Hello ${input.text}`,\n\t      };\n\t    }),\n\t  getAll: publicProcedure.query(({ ctx }) => {\n\t    return ctx.prisma.example.findMany();\n\t  }),\n\t  getSecretMessage: protectedProcedure.query(() => {\n\t    return \"you can now see this secret message!\";\n\t  }),\n", "});\n"]}
{"filename": "src/types/appstate.ts", "chunked_list": ["// appstate.ts\n\texport type Message = {\n\t  role: \"user\" | \"system\" | \"assistant\";\n\t  content: string;\n\t};\n\texport type Usage = {\n\t  total_tokens: number;\n\t  completion_tokens: number;\n\t  prompt_tokens: number;\n\t};\n", "export type Profile = {\n\t  id: string;\n\t  key: string;\n\t  name: string;\n\t  organization?: string;\n\t  usage: {\n\t    total_tokens: number;\n\t    completion_tokens: number;\n\t    prompt_tokens: number;\n\t  };\n", "  cost: number;\n\t  budget: number;\n\t  threadIds: string[];\n\t};\n\texport interface Model {\n\t  id: string;\n\t  maxTokens: number;\n\t  name: string;\n\t  description: string;\n\t  trainingData: string;\n", "  promptCost?: number;\n\t  completionCost?: number;\n\t  usageCost?: number;\n\t  note?: string;\n\t}\n\texport type Thread = {\n\t  id: string;\n\t  profileId: string;\n\t  messages: Message[];\n\t  model: Model;\n", "  initialSystemInstruction: string;\n\t  title: string;\n\t  description: string;\n\t  starred: boolean;\n\t  cost: number;\n\t  budget: number;\n\t};\n"]}
