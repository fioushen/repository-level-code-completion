{"filename": "index.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\texport { Compiler } from './src/compiler/main.js'\n\texport { refsBuilder } from './src/refs_builder.js'\n"]}
{"filename": "bin/test.ts", "chunked_list": ["import { AssertionError } from 'node:assert'\n\timport { assert, Assert } from '@japa/assert'\n\timport { processCLIArgs, configure, run } from '@japa/runner'\n\timport { beautifyCode } from '../factories/code_beautifier.js'\n\tAssert.macro('assertFormatted', function assertFormatted(this: Assert, actual, expected) {\n\t  try {\n\t    this.deepEqual(beautifyCode(actual).toArray(), beautifyCode(expected).toArray())\n\t  } catch (error) {\n\t    throw new AssertionError({\n\t      message: error.message,\n", "      actual: error.actual,\n\t      expected: error.expected,\n\t      stackStartFn: assertFormatted,\n\t    })\n\t  }\n\t})\n\t/*\n\t|--------------------------------------------------------------------------\n\t| Configure tests\n\t|--------------------------------------------------------------------------\n", "|\n\t| The configure method accepts the configuration to configure the Japa\n\t| tests runner.\n\t|\n\t| The first method call \"processCliArgs\" process the command line arguments\n\t| and turns them into a config object. Using this method is not mandatory.\n\t|\n\t| Please consult japa.dev/runner-config for the config docs.\n\t*/\n\tprocessCLIArgs(process.argv.slice(2))\n", "configure({\n\t  plugins: [assert()],\n\t  suites: [\n\t    {\n\t      name: 'unit',\n\t      files: ['tests/unit/**/*.spec.ts'],\n\t    },\n\t    {\n\t      name: 'integration',\n\t      files: ['tests/integration/**/*.spec.ts'],\n", "    },\n\t  ],\n\t})\n\t/*\n\t|--------------------------------------------------------------------------\n\t| Run tests\n\t|--------------------------------------------------------------------------\n\t|\n\t| The following \"run\" method is required to execute all the tests.\n\t|\n", "*/\n\trun()\n"]}
{"filename": "bin/japa_types.ts", "chunked_list": ["import '@japa/assert'\n\tdeclare module '@japa/assert' {\n\t  interface Assert {\n\t    assertFormatted(actual: string | string[], expected: string | string[]): void\n\t  }\n\t}\n"]}
{"filename": "tests/integration/compiler/object_node.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '../../../index.js'\n", "import { ValidationRule } from '../../../src/types.js'\n\timport { Compiler } from '../../../src/compiler/main.js'\n\timport { ErrorReporterFactory } from '../../../factories/error_reporter.js'\n\timport { MessagesProviderFactory } from '../../../factories/messages_provider.js'\n\ttest.group('Object node', () => {\n\t  test('process an object field', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n", "        groups: [],\n\t        bail: true,\n\t        fieldName: '',\n\t        validations: [],\n\t        propertyName: '',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [],\n\t      },\n", "    })\n\t    const data: any = {}\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, {})\n\t    // Mutation test:\n", "    data.profile = {}\n\t    assert.deepEqual(output, {})\n\t  })\n\t  test('dis-allow undefined value', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n", "        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [],\n\t      },\n\t    })\n", "    const data = undefined\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n", "      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n\t  test('dis-allow null value', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n", "        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [],\n\t      },\n\t    })\n", "    const data = null\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n", "      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n\t  test('dis-allow non-object values', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n", "        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n", "            bail: true,\n\t            fieldName: 'username',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: 'userName',\n\t            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n", "    const data = 'hello world'\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n", "      assert.deepEqual(error.messages, ['value is not a valid object'])\n\t    }\n\t  })\n\t  test('ignore object properties when children nodes are not defined', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        bail: true,\n", "        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [],\n\t      },\n\t    })\n\t    const data = { username: 'virk', age: 34 }\n", "    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, {})\n\t    // Mutation test:\n\t    data.age = 22\n\t    assert.deepEqual(output, {})\n", "  })\n\t  test('validate object children', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        bail: true,\n\t        fieldName: '*',\n", "        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: 'username',\n", "            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: 'userName',\n\t            validations: [],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: 'age',\n\t            allowNull: false,\n", "            isOptional: false,\n\t            propertyName: 'age',\n\t            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = {}\n\t    const meta = {}\n\t    const refs = {}\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is required', 'value is required'])\n\t    }\n\t  })\n", "  test('process children nodes', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n", "        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: 'username',\n\t            allowNull: false,\n\t            isOptional: false,\n", "            propertyName: 'userName',\n\t            validations: [],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: 'age',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: 'age',\n", "            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = { username: 'virk', age: 34 }\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, { userName: 'virk', age: 34 })\n\t    // Mutation test:\n\t    data.age = 22\n\t    assert.deepEqual(output, { userName: 'virk', age: 34 })\n\t  })\n\t  test('process nested object nodes', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n", "        properties: [\n\t          {\n\t            type: 'object',\n\t            groups: [],\n\t            bail: true,\n\t            fieldName: 'social',\n\t            validations: [],\n\t            propertyName: 'social',\n\t            allowNull: false,\n\t            isOptional: false,\n", "            allowUnknownProperties: false,\n\t            properties: [\n\t              {\n\t                type: 'literal',\n\t                bail: true,\n\t                fieldName: 'twitter_handle',\n\t                allowNull: false,\n\t                isOptional: false,\n\t                propertyName: 'twitterHandle',\n\t                validations: [],\n", "              },\n\t              {\n\t                type: 'literal',\n\t                bail: true,\n\t                fieldName: 'github_username',\n\t                allowNull: false,\n\t                isOptional: false,\n\t                propertyName: 'githubUsername',\n\t                validations: [],\n\t              },\n", "            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = {\n\t      social: {\n\t        github_username: 'thetutlage',\n\t        twitter_handle: 'AmanVirk1',\n\t      },\n", "    }\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, {\n\t      social: {\n\t        githubUsername: 'thetutlage',\n", "        twitterHandle: 'AmanVirk1',\n\t      },\n\t    })\n\t    // Mutation test:\n\t    data.social.github_username = 'foo'\n\t    assert.deepEqual(output, {\n\t      social: {\n\t        githubUsername: 'thetutlage',\n\t        twitterHandle: 'AmanVirk1',\n\t      },\n", "    })\n\t  })\n\t  test('run object validations', async ({ assert }) => {\n\t    assert.plan(7)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        bail: true,\n", "        fieldName: '*',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: false,\n", "            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: '*',\n\t        allowUnknownProperties: false,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        properties: [],\n\t      },\n\t    })\n", "    const data = {}\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, {})\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n", "            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t        },\n\t      },\n\t      'ref://3': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, {})\n", "          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t        },\n", "      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, {})\n\t  })\n\t  test('stop validations after first error', async ({ assert }) => {\n\t    assert.plan(5)\n", "    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n", "            implicit: false,\n\t            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: '*',\n", "        allowUnknownProperties: false,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        properties: [],\n\t      },\n\t    })\n\t    const data = {}\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n", "        validator(value, options, field) {\n\t          assert.deepEqual(value, {})\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n", "          })\n\t          field.report('ref://2 validation failed', 'ref', field)\n\t        },\n\t      },\n\t      'ref://3': {\n\t        validator() {\n\t          throw new Error('Never expected to be called')\n\t        },\n\t      },\n\t    }\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n\t    }\n\t  })\n", "  test('continue validations after error when bail mode is disabled', async ({ assert }) => {\n\t    assert.plan(8)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        bail: false,\n\t        fieldName: '*',\n\t        validations: [\n", "          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n", "        ],\n\t        propertyName: '*',\n\t        allowUnknownProperties: false,\n\t        allowNull: false,\n\t        isOptional: false,\n\t        properties: [],\n\t      },\n\t    })\n\t    const data = {}\n\t    const meta = {}\n", "    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, {})\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n", "            parent: data,\n\t            data,\n\t          })\n\t          field.report('ref://2 validation failed', 'ref', field)\n\t        },\n\t      },\n\t      'ref://3': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, {})\n\t          assert.isUndefined(options)\n", "          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: false,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t        },\n\t      },\n", "    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n\t    }\n", "  })\n\t  test('do not process children when object is invalid', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [\n", "          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n", "        properties: [\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: 'username',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: 'userName',\n\t            validations: [\n\t              {\n", "                ruleFnId: 'ref://3',\n\t                implicit: false,\n\t                isAsync: false,\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: 'age',\n", "            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: 'age',\n\t            validations: [\n\t              {\n\t                ruleFnId: 'ref://3',\n\t                implicit: false,\n\t                isAsync: false,\n\t              },\n\t            ],\n", "          },\n\t        ],\n\t      },\n\t    })\n\t    const data = { username: 'virk', age: 34 }\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, { username: 'virk', age: 34 })\n", "          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t          field.report('ref://2 validation failed', 'ref', field)\n", "        },\n\t      },\n\t      'ref://3': {\n\t        validator() {\n\t          throw new Error('Never expected to be called')\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n\t    }\n\t  })\n\t  test('process children for invalid object when bail mode is disabled', async ({ assert }) => {\n\t    assert.plan(11)\n", "    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        bail: false,\n\t        fieldName: '*',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n", "            implicit: false,\n\t            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n", "            type: 'literal',\n\t            bail: true,\n\t            fieldName: 'username',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: 'userName',\n\t            validations: [\n\t              {\n\t                ruleFnId: 'ref://3',\n\t                implicit: false,\n", "                isAsync: false,\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: 'age',\n\t            allowNull: false,\n\t            isOptional: false,\n", "            propertyName: 'age',\n\t            validations: [\n\t              {\n\t                ruleFnId: 'ref://3',\n\t                implicit: false,\n\t                isAsync: false,\n\t              },\n\t            ],\n\t          },\n\t        ],\n", "      },\n\t    })\n\t    const data = { username: 'virk', age: 34 }\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, { username: 'virk', age: 34 })\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n", "            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t          field.report('ref://2 validation failed', 'ref', field)\n\t        },\n\t      },\n", "      'ref://3': {\n\t        validator(value, options, field) {\n\t          if (field.name === 'username') {\n\t            assert.equal(value, 'virk')\n\t            assert.isUndefined(options)\n\t            assert.containsSubset(field, {\n\t              name: 'username',\n\t              wildCardPath: 'username',\n\t              isArrayMember: false,\n\t              isValid: true,\n", "              meta: {},\n\t              parent: { username: 'virk', age: 34 },\n\t              data,\n\t            })\n\t          } else {\n\t            assert.equal(value, 34)\n\t            assert.isUndefined(options)\n\t            assert.containsSubset(field, {\n\t              name: 'age',\n\t              wildCardPath: 'age',\n", "              isArrayMember: false,\n\t              isValid: true,\n\t              meta: {},\n\t              parent: { username: 'virk', age: 34 },\n\t              data,\n\t            })\n\t          }\n\t        },\n\t      },\n\t    }\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n\t    }\n\t  })\n", "  test('process object groups', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [\n\t          {\n\t            type: 'group',\n\t            conditions: [\n\t              {\n", "                conditionalFnRefId: 'ref://1',\n\t                schema: {\n\t                  type: 'sub_object',\n\t                  groups: [],\n\t                  properties: [\n\t                    {\n\t                      type: 'literal',\n\t                      allowNull: false,\n\t                      isOptional: false,\n\t                      bail: true,\n", "                      fieldName: 'username',\n\t                      propertyName: 'username',\n\t                      validations: [],\n\t                    },\n\t                  ],\n\t                },\n\t              },\n\t              {\n\t                conditionalFnRefId: 'ref://2',\n\t                schema: {\n", "                  type: 'sub_object',\n\t                  groups: [],\n\t                  properties: [\n\t                    {\n\t                      type: 'literal',\n\t                      allowNull: false,\n\t                      isOptional: false,\n\t                      bail: true,\n\t                      fieldName: 'email',\n\t                      propertyName: 'email',\n", "                      validations: [],\n\t                    },\n\t                  ],\n\t                },\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t        bail: true,\n\t        fieldName: '*',\n", "        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [],\n\t      },\n\t    })\n\t    const data: any = {\n\t      username: 'virk',\n", "    }\n\t    const meta = {}\n\t    const refs = {\n\t      'ref://1': () => true,\n\t      'ref://2': () => false,\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n", "    assert.deepEqual(output, { username: 'virk' })\n\t    // Mutation test:\n\t    data.username = 'foo'\n\t    assert.deepEqual(output, { username: 'virk' })\n\t  })\n\t  test('allow unknowProperties when object groups are defined', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n", "        groups: [\n\t          {\n\t            type: 'group',\n\t            conditions: [\n\t              {\n\t                conditionalFnRefId: 'ref://1',\n\t                schema: {\n\t                  type: 'sub_object',\n\t                  groups: [],\n\t                  properties: [\n", "                    {\n\t                      type: 'literal',\n\t                      allowNull: false,\n\t                      isOptional: false,\n\t                      bail: true,\n\t                      fieldName: 'username',\n\t                      propertyName: 'userName',\n\t                      validations: [],\n\t                    },\n\t                  ],\n", "                },\n\t              },\n\t              {\n\t                conditionalFnRefId: 'ref://2',\n\t                schema: {\n\t                  type: 'sub_object',\n\t                  groups: [],\n\t                  properties: [\n\t                    {\n\t                      type: 'literal',\n", "                      allowNull: false,\n\t                      isOptional: false,\n\t                      bail: true,\n\t                      fieldName: 'email',\n\t                      propertyName: 'email',\n\t                      validations: [],\n\t                    },\n\t                  ],\n\t                },\n\t              },\n", "            ],\n\t          },\n\t        ],\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: true,\n", "        properties: [],\n\t      },\n\t    })\n\t    const data: any = {\n\t      username: 'virk',\n\t      foo: 'bar',\n\t      baz: 'bam',\n\t    }\n\t    const meta = {}\n\t    const refs = {\n", "      'ref://1': () => true,\n\t      'ref://2': () => false,\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, { userName: 'virk', foo: 'bar', baz: 'bam' })\n\t    // Mutation test:\n\t    data.username = 'foo'\n", "    assert.deepEqual(output, { userName: 'virk', foo: 'bar', baz: 'bam' })\n\t  })\n\t  test('convert empty string to null', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler(\n\t      {\n\t        type: 'root',\n\t        schema: {\n\t          type: 'object',\n\t          groups: [],\n", "          bail: true,\n\t          fieldName: '',\n\t          validations: [],\n\t          propertyName: '',\n\t          allowNull: false,\n\t          isOptional: false,\n\t          allowUnknownProperties: false,\n\t          properties: [],\n\t        },\n\t      },\n", "      { convertEmptyStringsToNull: true }\n\t    )\n\t    const data: any = ''\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n", "    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n\t  test('call parse fn', async ({ assert }) => {\n\t    assert.plan(3)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n", "        type: 'object',\n\t        groups: [],\n\t        bail: true,\n\t        fieldName: '',\n\t        validations: [],\n\t        propertyName: '',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        parseFnId: 'ref://1',\n", "        properties: [],\n\t      },\n\t    })\n\t    const data: any = {}\n\t    const meta = {}\n\t    const refs = refsBuilder()\n\t    refs.trackParser((value) => {\n\t      assert.deepEqual(value, {})\n\t      return value\n\t    })\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs.toJSON(), messagesProvider, errorReporter)\n\t    assert.deepEqual(output, {})\n\t    // Mutation test:\n\t    data.profile = {}\n\t    assert.deepEqual(output, {})\n\t  })\n\t})\n", "test.group('Object node | optional: true', () => {\n\t  test('process an object field', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n", "        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: true,\n\t        allowUnknownProperties: false,\n\t        properties: [],\n\t      },\n\t    })\n\t    const data = {}\n\t    const meta = {}\n\t    const refs = {}\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, {})\n\t  })\n\t  test('allow undefined value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n", "        type: 'object',\n\t        groups: [],\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: true,\n\t        allowUnknownProperties: false,\n\t        properties: [],\n", "      },\n\t    })\n\t    const data = undefined\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, undefined)\n", "  })\n\t  test('allow null value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n", "        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: true,\n\t        allowUnknownProperties: false,\n\t        properties: [],\n\t      },\n\t    })\n\t    const data = null\n\t    const meta = {}\n\t    const refs = {}\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, undefined)\n\t  })\n\t  test('dis-allow non-object values', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: true,\n\t        allowUnknownProperties: false,\n", "        properties: [],\n\t      },\n\t    })\n\t    const data = 'hello world'\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n", "      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is not a valid object'])\n\t    }\n\t  })\n\t  test('convert empty string to null', async ({ assert }) => {\n\t    const compiler = new Compiler(\n\t      {\n\t        type: 'root',\n", "        schema: {\n\t          type: 'object',\n\t          groups: [],\n\t          bail: true,\n\t          fieldName: '',\n\t          validations: [],\n\t          propertyName: '',\n\t          allowNull: false,\n\t          isOptional: true,\n\t          allowUnknownProperties: false,\n", "          properties: [],\n\t        },\n\t      },\n\t      { convertEmptyStringsToNull: true }\n\t    )\n\t    const data: any = ''\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.isUndefined(output)\n\t  })\n\t})\n\ttest.group('Object node | allowNull: true', () => {\n\t  test('process an object field', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n", "        type: 'object',\n\t        groups: [],\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [],\n", "      },\n\t    })\n\t    const data = {}\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, {})\n", "  })\n\t  test('allow null value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n", "        propertyName: '*',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [],\n\t      },\n\t    })\n\t    const data = null\n\t    const meta = {}\n\t    const refs = {}\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, null)\n\t  })\n\t  test('dis-allow undefined value', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n", "        properties: [],\n\t      },\n\t    })\n\t    const data = undefined\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n", "      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n\t  test('dis-allow non-object values', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n", "        properties: [],\n\t      },\n\t    })\n\t    const data = 'hello world'\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n", "      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is not a valid object'])\n\t    }\n\t  })\n\t  test('convert empty string to null', async ({ assert }) => {\n\t    const compiler = new Compiler(\n\t      {\n\t        type: 'root',\n", "        schema: {\n\t          type: 'object',\n\t          groups: [],\n\t          bail: true,\n\t          fieldName: '',\n\t          validations: [],\n\t          propertyName: '',\n\t          allowNull: true,\n\t          isOptional: false,\n\t          allowUnknownProperties: false,\n", "          properties: [],\n\t        },\n\t      },\n\t      { convertEmptyStringsToNull: true }\n\t    )\n\t    const data: any = ''\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.isNull(output)\n\t  })\n\t})\n\ttest.group('Object node | allowUnknownProperties', () => {\n\t  test('keep object properties when unknown properties are allowed', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n", "        type: 'object',\n\t        groups: [],\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: true,\n\t        properties: [],\n", "      },\n\t    })\n\t    const data = { username: 'virk', age: 34 }\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, { username: 'virk', age: 34 })\n", "    // Mutation test:\n\t    data.age = 22\n\t    assert.deepEqual(output, { username: 'virk', age: 34 })\n\t  })\n\t  test('validate known properties when unknown properties are allowed', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n", "        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: true,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n", "            bail: true,\n\t            fieldName: 'username',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: 'userName',\n\t            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n", "    const data = { age: 34 }\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n", "      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n\t  test('process known properties when unknown properties are allowed', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        bail: true,\n", "        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: true,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n", "            fieldName: 'username',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: 'userName',\n\t            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = { username: 'virk', age: 34 }\n", "    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, {\n\t      userName: 'virk',\n\t      age: 34,\n\t    })\n", "    // Mutation test:\n\t    data.age = 22\n\t    assert.deepEqual(output, {\n\t      userName: 'virk',\n\t      age: 34,\n\t    })\n\t  })\n\t  test('allow unknown properties with nested object', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: true,\n", "        properties: [\n\t          {\n\t            type: 'object',\n\t            groups: [],\n\t            bail: true,\n\t            fieldName: 'social',\n\t            validations: [],\n\t            propertyName: 'social',\n\t            allowNull: false,\n\t            isOptional: false,\n", "            allowUnknownProperties: true,\n\t            properties: [\n\t              {\n\t                type: 'literal',\n\t                bail: true,\n\t                fieldName: 'twitter_handle',\n\t                allowNull: false,\n\t                isOptional: false,\n\t                propertyName: 'twitterHandle',\n\t                validations: [],\n", "              },\n\t              {\n\t                type: 'literal',\n\t                bail: true,\n\t                fieldName: 'github_username',\n\t                allowNull: false,\n\t                isOptional: false,\n\t                propertyName: 'githubUsername',\n\t                validations: [],\n\t              },\n", "            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = {\n\t      social: {\n\t        github_username: 'thetutlage',\n\t        twitter_handle: 'AmanVirk1',\n\t        soundcloud_account: 'foobar',\n", "      },\n\t      username: 'foo',\n\t    }\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, {\n", "      social: {\n\t        githubUsername: 'thetutlage',\n\t        soundcloud_account: 'foobar',\n\t        twitterHandle: 'AmanVirk1',\n\t      },\n\t      username: 'foo',\n\t    })\n\t    // Mutation test:\n\t    data.social.github_username = 'foo'\n\t    data.username = 'bar'\n", "    assert.deepEqual(output, {\n\t      social: {\n\t        githubUsername: 'thetutlage',\n\t        soundcloud_account: 'foobar',\n\t        twitterHandle: 'AmanVirk1',\n\t      },\n\t      username: 'foo',\n\t    })\n\t  })\n\t})\n"]}
{"filename": "tests/integration/compiler/union_node.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { Refs } from '../../../src/types.js'\n", "import { refsBuilder } from '../../../index.js'\n\timport { Compiler } from '../../../src/compiler/main.js'\n\timport { ErrorReporterFactory } from '../../../factories/error_reporter.js'\n\timport { MessagesProviderFactory } from '../../../factories/messages_provider.js'\n\ttest.group('Union node', () => {\n\t  test('create a union of literal values', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'union',\n", "        fieldName: '*',\n\t        propertyName: '*',\n\t        conditions: [\n\t          {\n\t            conditionalFnRefId: 'ref://1',\n\t            schema: {\n\t              type: 'literal',\n\t              bail: true,\n\t              fieldName: 'uid',\n\t              propertyName: 'uid',\n", "              allowNull: false,\n\t              isOptional: false,\n\t              validations: [\n\t                {\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://3',\n\t                },\n\t              ],\n\t            },\n", "          },\n\t          {\n\t            conditionalFnRefId: 'ref://2',\n\t            schema: {\n\t              type: 'literal',\n\t              bail: true,\n\t              fieldName: 'uid',\n\t              propertyName: 'uid',\n\t              allowNull: false,\n\t              isOptional: false,\n", "              validations: [],\n\t            },\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = 'virk'\n\t    const meta = {}\n\t    const refs = {\n\t      'ref://1': () => false,\n", "      'ref://2': () => true,\n\t      'ref://3': {\n\t        validator() {\n\t          throw new Error('Never expected to be called')\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n", "    assert.deepEqual(await fn(data, meta, refs, messagesProvider, errorReporter), 'virk')\n\t  })\n\t  test('create a union of objects', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'union',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        conditions: [\n", "          {\n\t            conditionalFnRefId: 'ref://1',\n\t            schema: {\n\t              type: 'object',\n\t              groups: [],\n\t              bail: true,\n\t              fieldName: 'profile',\n\t              validations: [],\n\t              propertyName: 'profile',\n\t              allowNull: false,\n", "              isOptional: false,\n\t              allowUnknownProperties: false,\n\t              properties: [\n\t                {\n\t                  type: 'literal',\n\t                  bail: true,\n\t                  fieldName: 'username',\n\t                  allowNull: false,\n\t                  isOptional: false,\n\t                  propertyName: 'userName',\n", "                  validations: [],\n\t                },\n\t                {\n\t                  type: 'literal',\n\t                  bail: true,\n\t                  fieldName: 'age',\n\t                  allowNull: false,\n\t                  isOptional: false,\n\t                  propertyName: 'age',\n\t                  validations: [],\n", "                },\n\t              ],\n\t            },\n\t          },\n\t          {\n\t            conditionalFnRefId: 'ref://2',\n\t            schema: {\n\t              type: 'object',\n\t              groups: [],\n\t              bail: true,\n", "              fieldName: 'profile',\n\t              validations: [],\n\t              propertyName: 'profile',\n\t              allowNull: false,\n\t              isOptional: false,\n\t              allowUnknownProperties: false,\n\t              properties: [\n\t                {\n\t                  type: 'literal',\n\t                  bail: true,\n", "                  fieldName: 'email',\n\t                  allowNull: false,\n\t                  isOptional: false,\n\t                  propertyName: 'email',\n\t                  validations: [],\n\t                },\n\t              ],\n\t            },\n\t          },\n\t        ],\n", "      },\n\t    })\n\t    const data = { email: 'foo@bar.com' }\n\t    const meta = {}\n\t    const refs = {\n\t      'ref://1': () => false,\n\t      'ref://2': () => true,\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    assert.deepEqual(await fn(data, meta, refs, messagesProvider, errorReporter), {\n\t      email: 'foo@bar.com',\n\t    })\n\t  })\n\t  test('create a union of arrays', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'union',\n", "        fieldName: '*',\n\t        propertyName: '*',\n\t        conditions: [\n\t          {\n\t            conditionalFnRefId: 'ref://1',\n\t            schema: {\n\t              type: 'array',\n\t              bail: true,\n\t              fieldName: '*',\n\t              validations: [],\n", "              propertyName: '*',\n\t              allowNull: false,\n\t              isOptional: false,\n\t              each: {\n\t                type: 'object',\n\t                groups: [],\n\t                allowNull: false,\n\t                allowUnknownProperties: false,\n\t                bail: false,\n\t                fieldName: '*',\n", "                isOptional: false,\n\t                propertyName: '*',\n\t                validations: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n\t                    bail: true,\n\t                    fieldName: 'email',\n\t                    allowNull: false,\n\t                    isOptional: false,\n", "                    propertyName: 'email',\n\t                    validations: [],\n\t                  },\n\t                ],\n\t              },\n\t            },\n\t          },\n\t          {\n\t            conditionalFnRefId: 'ref://2',\n\t            schema: {\n", "              type: 'array',\n\t              bail: true,\n\t              fieldName: '*',\n\t              validations: [],\n\t              propertyName: '*',\n\t              allowNull: false,\n\t              isOptional: false,\n\t              each: {\n\t                type: 'object',\n\t                groups: [],\n", "                allowNull: false,\n\t                allowUnknownProperties: false,\n\t                bail: false,\n\t                fieldName: '*',\n\t                isOptional: false,\n\t                propertyName: '*',\n\t                validations: [],\n\t                properties: [\n\t                  {\n\t                    type: 'literal',\n", "                    bail: true,\n\t                    fieldName: 'phone',\n\t                    allowNull: false,\n\t                    isOptional: false,\n\t                    propertyName: 'phone',\n\t                    validations: [],\n\t                  },\n\t                ],\n\t              },\n\t            },\n", "          },\n\t        ],\n\t      },\n\t    })\n\t    const data = [{ phone: '123456789' }]\n\t    const meta = {}\n\t    const refs = {\n\t      'ref://1': () => false,\n\t      'ref://2': () => true,\n\t    }\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    assert.deepEqual(await fn(data, meta, refs, messagesProvider, errorReporter), [\n\t      { phone: '123456789' },\n\t    ])\n\t  })\n\t  test('create a union of unions', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'union',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        conditions: [\n\t          {\n\t            conditionalFnRefId: 'ref://1',\n\t            schema: {\n\t              type: 'union',\n\t              fieldName: '*',\n", "              propertyName: '*',\n\t              conditions: [\n\t                {\n\t                  conditionalFnRefId: 'ref://3',\n\t                  schema: {\n\t                    type: 'object',\n\t                    groups: [],\n\t                    allowNull: false,\n\t                    allowUnknownProperties: false,\n\t                    bail: true,\n", "                    validations: [],\n\t                    fieldName: '*',\n\t                    propertyName: '*',\n\t                    isOptional: false,\n\t                    properties: [\n\t                      {\n\t                        type: 'literal',\n\t                        fieldName: 'twitter_handle',\n\t                        allowNull: false,\n\t                        isOptional: false,\n", "                        bail: true,\n\t                        propertyName: 'twitter_handle',\n\t                        validations: [],\n\t                      },\n\t                    ],\n\t                  },\n\t                },\n\t                {\n\t                  conditionalFnRefId: 'ref://4',\n\t                  schema: {\n", "                    type: 'object',\n\t                    groups: [],\n\t                    allowNull: false,\n\t                    allowUnknownProperties: false,\n\t                    bail: true,\n\t                    validations: [],\n\t                    fieldName: '*',\n\t                    propertyName: '*',\n\t                    isOptional: false,\n\t                    properties: [\n", "                      {\n\t                        type: 'literal',\n\t                        fieldName: 'github_username',\n\t                        allowNull: false,\n\t                        isOptional: false,\n\t                        bail: true,\n\t                        propertyName: 'github_username',\n\t                        validations: [],\n\t                      },\n\t                    ],\n", "                  },\n\t                },\n\t              ],\n\t            },\n\t          },\n\t          {\n\t            conditionalFnRefId: 'ref://2',\n\t            schema: {\n\t              type: 'union',\n\t              fieldName: '*',\n", "              propertyName: '*',\n\t              conditions: [\n\t                {\n\t                  conditionalFnRefId: 'ref://5',\n\t                  schema: {\n\t                    type: 'object',\n\t                    groups: [],\n\t                    allowNull: false,\n\t                    allowUnknownProperties: false,\n\t                    bail: true,\n", "                    validations: [],\n\t                    fieldName: '*',\n\t                    propertyName: '*',\n\t                    isOptional: false,\n\t                    properties: [\n\t                      {\n\t                        type: 'literal',\n\t                        fieldName: 'email',\n\t                        allowNull: false,\n\t                        isOptional: false,\n", "                        bail: true,\n\t                        propertyName: 'email',\n\t                        validations: [],\n\t                      },\n\t                    ],\n\t                  },\n\t                },\n\t                {\n\t                  conditionalFnRefId: 'ref://6',\n\t                  schema: {\n", "                    type: 'object',\n\t                    groups: [],\n\t                    allowNull: false,\n\t                    allowUnknownProperties: false,\n\t                    bail: true,\n\t                    validations: [],\n\t                    fieldName: '*',\n\t                    propertyName: '*',\n\t                    isOptional: false,\n\t                    properties: [\n", "                      {\n\t                        type: 'literal',\n\t                        fieldName: 'phone',\n\t                        allowNull: false,\n\t                        isOptional: false,\n\t                        bail: true,\n\t                        propertyName: 'phone',\n\t                        validations: [],\n\t                      },\n\t                    ],\n", "                  },\n\t                },\n\t              ],\n\t            },\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = {\n\t      email: 'foo@bar.com',\n", "    }\n\t    const meta = {}\n\t    const refs = {\n\t      'ref://1': () => false,\n\t      'ref://2': () => true,\n\t      'ref://3': () => false,\n\t      'ref://4': () => false,\n\t      'ref://5': () => true,\n\t      'ref://6': () => false,\n\t    }\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    assert.deepEqual(await fn(data, meta, refs, messagesProvider, errorReporter), {\n\t      email: 'foo@bar.com',\n\t    })\n\t  })\n\t  test('create a union of records', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'union',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        conditions: [\n\t          {\n\t            conditionalFnRefId: 'ref://1',\n\t            schema: {\n\t              type: 'record',\n\t              bail: true,\n", "              fieldName: '*',\n\t              validations: [],\n\t              propertyName: '*',\n\t              allowNull: false,\n\t              isOptional: false,\n\t              each: {\n\t                type: 'literal',\n\t                bail: true,\n\t                fieldName: '*',\n\t                allowNull: false,\n", "                isOptional: false,\n\t                propertyName: '*',\n\t                validations: [],\n\t              },\n\t            },\n\t          },\n\t          {\n\t            conditionalFnRefId: 'ref://2',\n\t            schema: {\n\t              type: 'record',\n", "              bail: true,\n\t              fieldName: '*',\n\t              validations: [],\n\t              propertyName: '*',\n\t              allowNull: false,\n\t              isOptional: false,\n\t              each: {\n\t                type: 'literal',\n\t                bail: true,\n\t                fieldName: '*',\n", "                allowNull: false,\n\t                isOptional: false,\n\t                propertyName: '*',\n\t                validations: [],\n\t                transformFnId: 'ref://3',\n\t              },\n\t            },\n\t          },\n\t        ],\n\t      },\n", "    })\n\t    const data = { white: '#ffffff', black: '#000000' }\n\t    const meta = {}\n\t    const refs: Refs = {\n\t      'ref://1': () => false,\n\t      'ref://2': () => true,\n\t      'ref://3': (hex: unknown) => {\n\t        if (typeof hex === 'string') {\n\t          const r = Number.parseInt(hex.slice(1, 3), 16)\n\t          const g = Number.parseInt(hex.slice(3, 5), 16)\n", "          const b = Number.parseInt(hex.slice(5, 7), 16)\n\t          return { r, g, b }\n\t        }\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    assert.deepEqual(await fn(data, meta, refs, messagesProvider, errorReporter), {\n\t      white: { r: 255, g: 255, b: 255 },\n", "      black: { r: 0, g: 0, b: 0 },\n\t    })\n\t  })\n\t  test('create a union of tuples', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'union',\n\t        fieldName: '*',\n\t        propertyName: '*',\n", "        conditions: [\n\t          {\n\t            conditionalFnRefId: 'ref://1',\n\t            schema: {\n\t              type: 'tuple',\n\t              bail: true,\n\t              fieldName: '*',\n\t              validations: [],\n\t              propertyName: '*',\n\t              allowNull: false,\n", "              isOptional: false,\n\t              allowUnknownProperties: false,\n\t              properties: [\n\t                {\n\t                  type: 'object',\n\t                  groups: [],\n\t                  allowNull: false,\n\t                  allowUnknownProperties: false,\n\t                  bail: false,\n\t                  fieldName: '0',\n", "                  isOptional: false,\n\t                  propertyName: '0',\n\t                  validations: [],\n\t                  properties: [\n\t                    {\n\t                      type: 'literal',\n\t                      bail: true,\n\t                      fieldName: 'email',\n\t                      allowNull: false,\n\t                      isOptional: false,\n", "                      propertyName: 'email',\n\t                      validations: [],\n\t                    },\n\t                  ],\n\t                },\n\t              ],\n\t            },\n\t          },\n\t          {\n\t            conditionalFnRefId: 'ref://2',\n", "            schema: {\n\t              type: 'tuple',\n\t              bail: true,\n\t              fieldName: '*',\n\t              validations: [],\n\t              propertyName: '*',\n\t              allowNull: false,\n\t              isOptional: false,\n\t              allowUnknownProperties: false,\n\t              properties: [\n", "                {\n\t                  type: 'object',\n\t                  groups: [],\n\t                  allowNull: false,\n\t                  allowUnknownProperties: false,\n\t                  bail: false,\n\t                  fieldName: '0',\n\t                  isOptional: false,\n\t                  propertyName: '0',\n\t                  validations: [],\n", "                  properties: [\n\t                    {\n\t                      type: 'literal',\n\t                      bail: true,\n\t                      fieldName: 'phone',\n\t                      allowNull: false,\n\t                      isOptional: false,\n\t                      propertyName: 'phone',\n\t                      validations: [],\n\t                    },\n", "                  ],\n\t                },\n\t              ],\n\t            },\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = [{ phone: '123456789' }]\n\t    const meta = {}\n", "    const refs = {\n\t      'ref://1': () => false,\n\t      'ref://2': () => true,\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    assert.deepEqual(await fn(data, meta, refs, messagesProvider, errorReporter), [\n\t      { phone: '123456789' },\n\t    ])\n", "  })\n\t  test('call parse function', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'union',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        conditions: [\n\t          {\n", "            conditionalFnRefId: 'ref://1',\n\t            schema: {\n\t              type: 'literal',\n\t              bail: true,\n\t              fieldName: 'uid',\n\t              propertyName: 'uid',\n\t              allowNull: false,\n\t              isOptional: false,\n\t              validations: [\n\t                {\n", "                  implicit: false,\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://4',\n\t                },\n\t              ],\n\t            },\n\t          },\n\t          {\n\t            conditionalFnRefId: 'ref://2',\n\t            schema: {\n", "              type: 'literal',\n\t              bail: true,\n\t              fieldName: 'uid',\n\t              propertyName: 'uid',\n\t              parseFnId: 'ref://3',\n\t              allowNull: false,\n\t              isOptional: false,\n\t              validations: [],\n\t            },\n\t          },\n", "        ],\n\t      },\n\t    })\n\t    const data = 'virk'\n\t    const meta = {}\n\t    const refs = refsBuilder()\n\t    refs.trackConditional(() => false)\n\t    refs.trackConditional(() => true)\n\t    refs.trackParser((value) => {\n\t      return typeof value === 'string' ? value.toUpperCase() : value\n", "    })\n\t    refs.trackValidation({\n\t      validator() {\n\t        throw new Error('Never expected to be called')\n\t      },\n\t    })\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    assert.deepEqual(await fn(data, meta, refs.toJSON(), messagesProvider, errorReporter), 'VIRK')\n", "  })\n\t})\n"]}
{"filename": "tests/integration/compiler/tuple_node.spec.ts", "chunked_list": ["/*\n\t * @adonisjs/validator\n\t *\n\t * (c) Validator\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '../../../index.js'\n", "import { ValidationRule } from '../../../src/types.js'\n\timport { Compiler } from '../../../src/compiler/main.js'\n\timport { ErrorReporterFactory } from '../../../factories/error_reporter.js'\n\timport { MessagesProviderFactory } from '../../../factories/messages_provider.js'\n\ttest.group('Tuple node', () => {\n\t  test('process children nodes', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n", "        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n", "            bail: true,\n\t            fieldName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '0',\n\t            validations: [],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n", "            fieldName: '1',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '1',\n\t            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = ['hello world', 'hi world']\n", "    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, ['hello world', 'hi world'])\n\t    // Mutation test\n\t    data[0] = 'foo'\n\t    assert.deepEqual(output, ['hello world', 'hi world'])\n", "  })\n\t  test('dis-allow undefined value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n", "        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n", "            propertyName: '0',\n\t            validations: [],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '1',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '1',\n", "            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = undefined\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n\t  test('dis-allow null value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n", "      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n", "        properties: [\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '0',\n\t            validations: [],\n\t          },\n", "          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '1',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '1',\n\t            validations: [],\n\t          },\n\t        ],\n", "      },\n\t    })\n\t    const data = null\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n", "    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n\t  test('dis-allow non-array values', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n", "        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n", "            bail: true,\n\t            fieldName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '0',\n\t            validations: [],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n", "            fieldName: '1',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '1',\n\t            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = 'hello world'\n", "    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is not a valid array'])\n", "    }\n\t  })\n\t  test('ignore additional array items', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        bail: true,\n\t        fieldName: '',\n\t        validations: [],\n", "        propertyName: '',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '0',\n\t            allowNull: false,\n", "            isOptional: false,\n\t            propertyName: '0',\n\t            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = ['hello world', 'hi world']\n\t    const meta = {}\n\t    const refs = {}\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, ['hello world'])\n\t    // Mutation test\n\t    data[0] = 'foo'\n\t    assert.deepEqual(output, ['hello world'])\n\t  })\n\t  test('keep additional array items when unknown properties are allowed', async ({ assert }) => {\n", "    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        bail: true,\n\t        fieldName: 'contacts',\n\t        validations: [],\n\t        propertyName: 'contacts',\n\t        allowNull: false,\n\t        isOptional: false,\n", "        allowUnknownProperties: true,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '0',\n\t            validations: [],\n", "          },\n\t        ],\n\t      },\n\t    })\n\t    const data = ['hello world', 'hi world']\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n", "    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, ['hello world', 'hi world'])\n\t    // Mutation test\n\t    data[0] = 'foo'\n\t    assert.deepEqual(output, ['hello world', 'hi world'])\n\t  })\n\t  test('process nested children nodes', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n", "        type: 'tuple',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n", "            type: 'tuple',\n\t            bail: true,\n\t            fieldName: '0',\n\t            validations: [],\n\t            propertyName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            allowUnknownProperties: false,\n\t            properties: [\n\t              {\n", "                type: 'literal',\n\t                bail: true,\n\t                fieldName: '0',\n\t                allowNull: false,\n\t                isOptional: false,\n\t                propertyName: '0',\n\t                validations: [],\n\t              },\n\t              {\n\t                type: 'literal',\n", "                bail: true,\n\t                fieldName: '1',\n\t                allowNull: false,\n\t                isOptional: false,\n\t                propertyName: '1',\n\t                validations: [],\n\t              },\n\t            ],\n\t          },\n\t          {\n", "            type: 'tuple',\n\t            bail: true,\n\t            fieldName: '1',\n\t            validations: [],\n\t            propertyName: '1',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            allowUnknownProperties: false,\n\t            properties: [\n\t              {\n", "                type: 'literal',\n\t                bail: true,\n\t                fieldName: '0',\n\t                allowNull: false,\n\t                isOptional: false,\n\t                propertyName: '0',\n\t                validations: [],\n\t              },\n\t              {\n\t                type: 'literal',\n", "                bail: true,\n\t                fieldName: '1',\n\t                allowNull: false,\n\t                isOptional: false,\n\t                propertyName: '1',\n\t                validations: [],\n\t              },\n\t            ],\n\t          },\n\t        ],\n", "      },\n\t    })\n\t    const data = [\n\t      ['hello world', 'hi world'],\n\t      ['hi world', 'hello world'],\n\t    ]\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, [\n\t      ['hello world', 'hi world'],\n\t      ['hi world', 'hello world'],\n\t    ])\n\t    // Mutation test\n\t    data[0][0] = 'foo'\n\t    assert.deepEqual(output, [\n\t      ['hello world', 'hi world'],\n", "      ['hi world', 'hello world'],\n\t    ])\n\t  })\n\t  test('allow unknown properties in nested tuple', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        bail: true,\n\t        fieldName: '*',\n", "        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: true,\n\t        properties: [\n\t          {\n\t            type: 'tuple',\n\t            bail: true,\n\t            fieldName: '0',\n", "            validations: [],\n\t            propertyName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            allowUnknownProperties: true,\n\t            properties: [\n\t              {\n\t                type: 'literal',\n\t                bail: true,\n\t                fieldName: '0',\n", "                allowNull: false,\n\t                isOptional: false,\n\t                propertyName: '0',\n\t                validations: [],\n\t              },\n\t              {\n\t                type: 'literal',\n\t                bail: true,\n\t                fieldName: '1',\n\t                allowNull: false,\n", "                isOptional: false,\n\t                propertyName: '1',\n\t                validations: [],\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'tuple',\n\t            bail: true,\n\t            fieldName: '1',\n", "            validations: [],\n\t            propertyName: '1',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            allowUnknownProperties: true,\n\t            properties: [\n\t              {\n\t                type: 'literal',\n\t                bail: true,\n\t                fieldName: '0',\n", "                allowNull: false,\n\t                isOptional: false,\n\t                propertyName: '0',\n\t                validations: [],\n\t              },\n\t              {\n\t                type: 'literal',\n\t                bail: true,\n\t                fieldName: '1',\n\t                allowNull: false,\n", "                isOptional: false,\n\t                propertyName: '1',\n\t                validations: [],\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = [\n", "      ['hello world', 'hi world', 'foo bar'],\n\t      ['hi world', 'hello world', 'foo bar'],\n\t      ['hi world', 'hello world', 'foo bar'],\n\t    ]\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n", "    assert.deepEqual(output, [\n\t      ['hello world', 'hi world', 'foo bar'],\n\t      ['hi world', 'hello world', 'foo bar'],\n\t      ['hi world', 'hello world', 'foo bar'],\n\t    ])\n\t    // Mutation test\n\t    data[0][0] = 'foo'\n\t    assert.deepEqual(output, [\n\t      ['hello world', 'hi world', 'foo bar'],\n\t      ['hi world', 'hello world', 'foo bar'],\n", "      ['hi world', 'hello world', 'foo bar'],\n\t    ])\n\t  })\n\t  test('run array validations', async ({ assert }) => {\n\t    assert.plan(7)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        bail: true,\n", "        fieldName: '*',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: false,\n", "            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [],\n\t      },\n\t    })\n", "    const data: any[] = []\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, [])\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n", "            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t        },\n\t      },\n\t      'ref://3': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, [])\n", "          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t        },\n", "      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, [])\n\t  })\n\t  test('stop validation after first error', async ({ assert }) => {\n\t    assert.plan(5)\n", "    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n", "            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: '*',\n\t        allowNull: false,\n", "        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [],\n\t      },\n\t    })\n\t    const data: any[] = []\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n", "          assert.deepEqual(value, [])\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n", "          field.report('ref://2 validation failed', 'ref', field)\n\t        },\n\t      },\n\t      'ref://3': {\n\t        validator() {\n\t          throw new Error('Never expected to be called')\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n", "    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n\t    }\n\t  })\n\t  test('continue validations after error when bail mode is disabled', async ({ assert }) => {\n", "    assert.plan(8)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        bail: false,\n\t        fieldName: '*',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n", "            implicit: false,\n\t            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: '*',\n", "        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [],\n\t      },\n\t    })\n\t    const data: any[] = []\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n", "        validator(value, options, field) {\n\t          assert.deepEqual(value, [])\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n", "          })\n\t          field.report('ref://2 validation failed', 'ref', field)\n\t        },\n\t      },\n\t      'ref://3': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, [])\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n", "            isArrayMember: false,\n\t            isValid: false,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n", "    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n\t    }\n\t  })\n\t  test('do not process properties when array is invalid', async ({ assert }) => {\n", "    assert.plan(5)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n", "            implicit: false,\n\t            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n", "            type: 'literal',\n\t            bail: true,\n\t            fieldName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '0',\n\t            validations: [\n\t              {\n\t                ruleFnId: 'ref://3',\n\t                implicit: false,\n", "                isAsync: false,\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '1',\n\t            allowNull: false,\n\t            isOptional: false,\n", "            propertyName: '1',\n\t            validations: [\n\t              {\n\t                ruleFnId: 'ref://3',\n\t                implicit: false,\n\t                isAsync: false,\n\t              },\n\t            ],\n\t          },\n\t        ],\n", "      },\n\t    })\n\t    const data: any[] = ['hello world', 'hi world']\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, ['hello world', 'hi world'])\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n", "            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t          field.report('ref://2 validation failed', 'ref', field)\n\t        },\n\t      },\n", "      'ref://3': {\n\t        validator() {\n\t          throw new Error('Never expected to be called')\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n", "      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n\t    }\n\t  })\n\t  test('process properties of invalid array when bail mode is disabled', async ({ assert }) => {\n\t    assert.plan(11)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'tuple',\n\t        bail: false,\n\t        fieldName: '*',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n", "        ],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '0',\n", "            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '0',\n\t            validations: [\n\t              {\n\t                ruleFnId: 'ref://3',\n\t                implicit: false,\n\t                isAsync: false,\n\t              },\n\t            ],\n", "          },\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '1',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '1',\n\t            validations: [\n\t              {\n", "                ruleFnId: 'ref://3',\n\t                implicit: false,\n\t                isAsync: false,\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data: any[] = ['hello world', 'hi world']\n", "    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, ['hello world', 'hi world'])\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n", "            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t          field.report('ref://2 validation failed', 'ref', field)\n\t        },\n\t      },\n\t      'ref://3': {\n\t        validator(value, options, field) {\n\t          if (field.name === 0) {\n", "            assert.equal(value, 'hello world')\n\t            assert.isUndefined(options)\n\t            assert.containsSubset(field, {\n\t              name: 0,\n\t              wildCardPath: '0',\n\t              isArrayMember: true,\n\t              isValid: true,\n\t              meta: {},\n\t              parent: ['hello world', 'hi world'],\n\t              data,\n", "            })\n\t          } else {\n\t            assert.equal(value, 'hi world')\n\t            assert.isUndefined(options)\n\t            assert.containsSubset(field, {\n\t              name: 1,\n\t              wildCardPath: '1',\n\t              isArrayMember: true,\n\t              isValid: true,\n\t              meta: {},\n", "              parent: ['hello world', 'hi world'],\n\t              data,\n\t            })\n\t          }\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n", "    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n\t    }\n\t  })\n\t  test('convert empty string to null', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler(\n", "      {\n\t        type: 'root',\n\t        schema: {\n\t          type: 'tuple',\n\t          bail: true,\n\t          fieldName: '*',\n\t          validations: [],\n\t          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n", "          allowUnknownProperties: false,\n\t          properties: [\n\t            {\n\t              type: 'literal',\n\t              bail: true,\n\t              fieldName: '0',\n\t              allowNull: false,\n\t              isOptional: false,\n\t              propertyName: '0',\n\t              validations: [],\n", "            },\n\t            {\n\t              type: 'literal',\n\t              bail: true,\n\t              fieldName: '1',\n\t              allowNull: false,\n\t              isOptional: false,\n\t              propertyName: '1',\n\t              validations: [],\n\t            },\n", "          ],\n\t        },\n\t      },\n\t      { convertEmptyStringsToNull: true }\n\t    )\n\t    const data = ''\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n\t  test('call parse function', async ({ assert }) => {\n\t    assert.plan(3)\n", "    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n", "        allowUnknownProperties: false,\n\t        parseFnId: 'ref://1',\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '0',\n", "            validations: [],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '1',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '1',\n\t            validations: [],\n", "          },\n\t        ],\n\t      },\n\t    })\n\t    const data = ['hello world', 'hi world']\n\t    const meta = {}\n\t    const refs = refsBuilder()\n\t    refs.trackParser((value) => {\n\t      assert.deepEqual(value, data)\n\t      return value\n", "    })\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs.toJSON(), messagesProvider, errorReporter)\n\t    assert.deepEqual(output, ['hello world', 'hi world'])\n\t    // Mutation test\n\t    data[0] = 'foo'\n\t    assert.deepEqual(output, ['hello world', 'hi world'])\n\t  })\n", "})\n\ttest.group('Tuple node | optional: true', () => {\n\t  test('process children nodes', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n", "        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: true,\n\t        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '0',\n\t            allowNull: false,\n", "            isOptional: false,\n\t            propertyName: '0',\n\t            validations: [],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '1',\n\t            allowNull: false,\n\t            isOptional: false,\n", "            propertyName: '1',\n\t            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = ['hello world', 'hi world']\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n", "    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, ['hello world', 'hi world'])\n\t    // Mutation test\n\t    data[0] = 'foo'\n\t    assert.deepEqual(output, ['hello world', 'hi world'])\n\t  })\n\t  test('allow undefined value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n", "      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: true,\n\t        allowUnknownProperties: false,\n", "        properties: [\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '0',\n\t            validations: [],\n\t          },\n", "          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '1',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '1',\n\t            validations: [],\n\t          },\n\t        ],\n", "      },\n\t    })\n\t    const data = undefined\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.isUndefined(output)\n", "  })\n\t  test('allow null value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n", "        allowNull: false,\n\t        isOptional: true,\n\t        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n", "            propertyName: '0',\n\t            validations: [],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '1',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '1',\n", "            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = null\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.isUndefined(output)\n\t  })\n\t  test('dis-allow non-array values', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        bail: true,\n", "        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: true,\n\t        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n", "            fieldName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '0',\n\t            validations: [],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '1',\n", "            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '1',\n\t            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = 'hello world'\n\t    const meta = {}\n", "    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is not a valid array'])\n\t    }\n", "  })\n\t  test('convert empty string to null', async ({ assert }) => {\n\t    const compiler = new Compiler(\n\t      {\n\t        type: 'root',\n\t        schema: {\n\t          type: 'tuple',\n\t          bail: true,\n\t          fieldName: '*',\n\t          validations: [],\n", "          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: true,\n\t          allowUnknownProperties: false,\n\t          properties: [\n\t            {\n\t              type: 'literal',\n\t              bail: true,\n\t              fieldName: '0',\n\t              allowNull: false,\n", "              isOptional: false,\n\t              propertyName: '0',\n\t              validations: [],\n\t            },\n\t            {\n\t              type: 'literal',\n\t              bail: true,\n\t              fieldName: '1',\n\t              allowNull: false,\n\t              isOptional: false,\n", "              propertyName: '1',\n\t              validations: [],\n\t            },\n\t          ],\n\t        },\n\t      },\n\t      { convertEmptyStringsToNull: true }\n\t    )\n\t    const data = ''\n\t    const meta = {}\n", "    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.isUndefined(output)\n\t  })\n\t})\n\ttest.group('Tuple node | allowNull: true', () => {\n\t  test('process children nodes', async ({ assert }) => {\n", "    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: true,\n\t        isOptional: false,\n", "        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '0',\n\t            validations: [],\n", "          },\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '1',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '1',\n\t            validations: [],\n\t          },\n", "        ],\n\t      },\n\t    })\n\t    const data = ['hello world', 'hi world']\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n", "    assert.deepEqual(output, ['hello world', 'hi world'])\n\t    // Mutation test\n\t    data[0] = 'foo'\n\t    assert.deepEqual(output, ['hello world', 'hi world'])\n\t  })\n\t  test('dis-allow undefined value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n", "        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n", "            bail: true,\n\t            fieldName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '0',\n\t            validations: [],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n", "            fieldName: '1',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '1',\n\t            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = undefined\n", "    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is required'])\n", "    }\n\t  })\n\t  test('allow null value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n", "        propertyName: '*',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '0',\n\t            allowNull: false,\n", "            isOptional: false,\n\t            propertyName: '0',\n\t            validations: [],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '1',\n\t            allowNull: false,\n\t            isOptional: false,\n", "            propertyName: '1',\n\t            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = null\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n", "    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.isNull(output)\n\t  })\n\t  test('dis-allow non-array values', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n", "        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n", "            bail: true,\n\t            fieldName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '0',\n\t            validations: [],\n\t          },\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n", "            fieldName: '1',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '1',\n\t            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const data = 'hello world'\n", "    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is not a valid array'])\n", "    }\n\t  })\n\t  test('convert empty string to null', async ({ assert }) => {\n\t    const compiler = new Compiler(\n\t      {\n\t        type: 'root',\n\t        schema: {\n\t          type: 'tuple',\n\t          bail: true,\n\t          fieldName: '*',\n", "          validations: [],\n\t          propertyName: '*',\n\t          allowNull: true,\n\t          isOptional: false,\n\t          allowUnknownProperties: false,\n\t          properties: [\n\t            {\n\t              type: 'literal',\n\t              bail: true,\n\t              fieldName: '0',\n", "              allowNull: false,\n\t              isOptional: false,\n\t              propertyName: '0',\n\t              validations: [],\n\t            },\n\t            {\n\t              type: 'literal',\n\t              bail: true,\n\t              fieldName: '1',\n\t              allowNull: false,\n", "              isOptional: false,\n\t              propertyName: '1',\n\t              validations: [],\n\t            },\n\t          ],\n\t        },\n\t      },\n\t      { convertEmptyStringsToNull: true }\n\t    )\n\t    const data = ''\n", "    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.isNull(output)\n\t  })\n\t})\n"]}
{"filename": "tests/integration/compiler/literal_node.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '../../../index.js'\n", "import { Compiler } from '../../../src/compiler/main.js'\n\timport type { ValidationRule } from '../../../src/types.js'\n\timport { ErrorReporterFactory } from '../../../factories/error_reporter.js'\n\timport { MessagesProviderFactory } from '../../../factories/messages_provider.js'\n\ttest.group('Literal node', () => {\n\t  test('process value for a field', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n", "        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t      },\n\t    })\n\t    const data = 'virk'\n\t    const meta = {}\n", "    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, 'virk')\n\t  })\n\t  test('allow empty string value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'literal',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t      },\n\t    })\n", "    const data = ''\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, '')\n\t  })\n\t  test('dis-allow undefined value', async ({ assert }) => {\n", "    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n\t        bail: true,\n\t        fieldName: 'username',\n\t        validations: [],\n\t        propertyName: 'userName',\n\t        allowNull: false,\n", "        isOptional: false,\n\t      },\n\t    })\n\t    const data = undefined\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n", "      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n\t  test('dis-allow null value', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'literal',\n\t        bail: true,\n\t        fieldName: 'username',\n\t        validations: [],\n\t        propertyName: 'userName',\n\t        allowNull: false,\n\t        isOptional: false,\n\t      },\n\t    })\n", "    const data = null\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n", "      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n\t  test('run validations', async ({ assert }) => {\n\t    assert.plan(7)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n\t        bail: true,\n", "        fieldName: '',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: false,\n", "            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: '',\n\t        allowNull: false,\n\t        isOptional: false,\n\t      },\n\t    })\n\t    const data = 'virk'\n\t    const meta = {}\n", "    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.equal(value, 'virk')\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n", "            parent: data,\n\t            data,\n\t          })\n\t        },\n\t      },\n\t      'ref://3': {\n\t        validator(value, options, field) {\n\t          assert.equal(value, 'virk')\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n", "            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t        },\n\t      },\n\t    }\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, 'virk')\n\t  })\n\t  test('stop validations after first error', async ({ assert }) => {\n\t    assert.plan(5)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'literal',\n\t        bail: true,\n\t        fieldName: 'username',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n", "          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: 'userName',\n\t        allowNull: false,\n\t        isOptional: false,\n\t      },\n", "    })\n\t    const data = 'virk'\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.equal(value, 'virk')\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n", "            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t          field.report('ref://2 validation failed', 'ref://2', field)\n\t        },\n\t      },\n\t      'ref://3': {\n", "        validator(value, options, field) {\n\t          assert.equal(value, 'virk')\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n", "          })\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n", "      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n\t    }\n\t  })\n\t  test('continue validations after error when bail mode is disabled', async ({ assert }) => {\n\t    assert.plan(8)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n", "        bail: false,\n\t        fieldName: '*',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n", "            implicit: false,\n\t            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t      },\n\t    })\n\t    const data = 'virk'\n", "    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.equal(value, 'virk')\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n", "            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t          field.report('ref://2 validation failed', 'ref://2', field)\n\t        },\n\t      },\n\t      'ref://3': {\n\t        validator(value, options, field) {\n\t          assert.equal(value, 'virk')\n", "          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: false,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t        },\n", "      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n", "    }\n\t  })\n\t  test('do not call transform when field is invalid', async ({ assert }) => {\n\t    assert.plan(5)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n\t        bail: true,\n\t        fieldName: 'username',\n", "        transformFnId: 'ref://1',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: 'userName',\n\t        allowNull: false,\n", "        isOptional: false,\n\t      },\n\t    })\n\t    const data = 'virk'\n\t    const meta = {}\n\t    const refs = refsBuilder()\n\t    refs.trackTransformer(() => {\n\t      throw new Error('Never expected to reach here')\n\t    })\n\t    refs.trackValidation({\n", "      validator(value, options, field) {\n\t        assert.equal(value, 'virk')\n\t        assert.isUndefined(options)\n\t        assert.containsSubset(field, {\n\t          name: '',\n\t          isArrayMember: false,\n\t          isValid: true,\n\t          meta: {},\n\t          parent: data,\n\t          data,\n", "        })\n\t        field.report('ref://2 failed', 'ref', field)\n\t      },\n\t    })\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs.toJSON(), messagesProvider, errorReporter)\n\t    } catch (error) {\n", "      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 failed'])\n\t    }\n\t  })\n\t  test('call transform when field is valid', async ({ assert }) => {\n\t    assert.plan(4)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n", "        bail: true,\n\t        fieldName: '*',\n\t        transformFnId: 'ref://1',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t        ],\n", "        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t      },\n\t    })\n\t    const data = 'virk'\n\t    const meta = {}\n\t    const refs = refsBuilder()\n\t    refs.trackTransformer((value: string) => {\n\t      return value.toUpperCase()\n", "    })\n\t    refs.trackValidation({\n\t      validator(value, options, field) {\n\t        assert.equal(value, 'virk')\n\t        assert.isUndefined(options)\n\t        assert.containsSubset(field, {\n\t          name: '',\n\t          isArrayMember: false,\n\t          isValid: true,\n\t          meta: {},\n", "          parent: data,\n\t          data,\n\t        })\n\t      },\n\t    })\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    assert.deepEqual(await fn(data, meta, refs.toJSON(), messagesProvider, errorReporter), 'VIRK')\n\t  })\n", "  test('convert empty string to null', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler(\n\t      {\n\t        type: 'root',\n\t        schema: {\n\t          type: 'literal',\n\t          bail: true,\n\t          fieldName: '*',\n\t          validations: [],\n", "          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n\t        },\n\t      },\n\t      { convertEmptyStringsToNull: true }\n\t    )\n\t    const data = ''\n\t    const meta = {}\n\t    const refs = {}\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n", "  test('call parse function', async ({ assert }) => {\n\t    assert.plan(3)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n", "        allowNull: false,\n\t        isOptional: false,\n\t        parseFnId: 'ref://1',\n\t      },\n\t    })\n\t    const data = 'virk'\n\t    const meta = {}\n\t    const refs = refsBuilder()\n\t    refs.trackParser((value, ctx) => {\n\t      assert.equal(value, 'virk')\n", "      assert.deepEqual(ctx, {\n\t        data: 'virk',\n\t        meta: {},\n\t        parent: 'virk',\n\t      })\n\t      return value\n\t    })\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n", "    const output = await fn(data, meta, refs.toJSON(), messagesProvider, errorReporter)\n\t    assert.deepEqual(output, 'virk')\n\t  })\n\t})\n\ttest.group('Literal node | optional: true', () => {\n\t  test('process value for an optional field', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n", "        bail: true,\n\t        fieldName: 'username',\n\t        validations: [],\n\t        propertyName: 'userName',\n\t        allowNull: false,\n\t        isOptional: true,\n\t      },\n\t    })\n\t    const data = 'virk'\n\t    const meta = {}\n", "    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, 'virk')\n\t  })\n\t  test('allow empty string value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'literal',\n\t        bail: true,\n\t        fieldName: 'username',\n\t        validations: [],\n\t        propertyName: 'userName',\n\t        allowNull: false,\n\t        isOptional: true,\n\t      },\n\t    })\n", "    const data = ''\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, '')\n\t  })\n\t  test('allow undefined value', async ({ assert }) => {\n", "    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n\t        bail: true,\n\t        fieldName: 'username',\n\t        validations: [],\n\t        propertyName: 'userName',\n\t        allowNull: false,\n\t        isOptional: true,\n", "      },\n\t    })\n\t    const data = undefined\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, undefined)\n", "  })\n\t  test('allow null value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n\t        bail: true,\n\t        fieldName: 'username',\n\t        validations: [],\n\t        propertyName: 'userName',\n", "        allowNull: false,\n\t        isOptional: true,\n\t      },\n\t    })\n\t    const data = null\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n", "    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, undefined)\n\t  })\n\t  test('run validations', async ({ assert }) => {\n\t    assert.plan(7)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n\t        bail: true,\n", "        fieldName: 'username',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: false,\n", "            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: 'userName',\n\t        allowNull: false,\n\t        isOptional: true,\n\t      },\n\t    })\n\t    const data = 'virk'\n\t    const meta = {}\n", "    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.equal(value, 'virk')\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n", "            parent: data,\n\t            data,\n\t          })\n\t        },\n\t      },\n\t      'ref://3': {\n\t        validator(value, options, field) {\n\t          assert.equal(value, 'virk')\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n", "            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t        },\n\t      },\n\t    }\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, 'virk')\n\t  })\n\t  test('do not run validations when value is undefined', async ({ assert }) => {\n\t    assert.plan(1)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'literal',\n\t        bail: true,\n\t        fieldName: '',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n", "          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: '',\n\t        allowNull: false,\n\t        isOptional: true,\n\t      },\n", "    })\n\t    const data = undefined\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator() {\n\t          throw new Error('Never expected to reach here')\n\t        },\n\t      },\n\t      'ref://3': {\n", "        validator() {\n\t          throw new Error('Never expected to reach here')\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, undefined)\n", "  })\n\t  test('run validations for implicit rules when value is undefined', async ({ assert }) => {\n\t    assert.plan(4)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [\n", "          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: true,\n\t            isAsync: false,\n\t          },\n", "        ],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: true,\n\t      },\n\t    })\n\t    const data = undefined\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n", "        validator() {\n\t          throw new Error('Never expected to reach here')\n\t        },\n\t      },\n\t      'ref://3': {\n\t        validator(value, options, field) {\n\t          assert.equal(value, undefined)\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n", "            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n", "    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, undefined)\n\t  })\n\t  test('convert empty string to null', async ({ assert }) => {\n\t    const compiler = new Compiler(\n\t      {\n\t        type: 'root',\n\t        schema: {\n", "          type: 'literal',\n\t          bail: true,\n\t          fieldName: '*',\n\t          validations: [],\n\t          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: true,\n\t        },\n\t      },\n\t      { convertEmptyStringsToNull: true }\n", "    )\n\t    const data = ''\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.isUndefined(output)\n\t  })\n", "})\n\ttest.group('Literal node | allowNull: true', () => {\n\t  test('process value for a nullable field', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n\t        bail: true,\n\t        fieldName: 'username',\n\t        validations: [],\n", "        propertyName: 'userName',\n\t        allowNull: true,\n\t        isOptional: false,\n\t      },\n\t    })\n\t    const data = 'virk'\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, 'virk')\n\t  })\n\t  test('allow empty string value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n\t        bail: true,\n", "        fieldName: 'username',\n\t        validations: [],\n\t        propertyName: 'userName',\n\t        allowNull: true,\n\t        isOptional: false,\n\t      },\n\t    })\n\t    const data = ''\n\t    const meta = {}\n\t    const refs = {}\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, '')\n\t  })\n\t  test('allow null value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n", "        type: 'literal',\n\t        bail: true,\n\t        fieldName: 'username',\n\t        validations: [],\n\t        propertyName: 'userName',\n\t        allowNull: true,\n\t        isOptional: false,\n\t      },\n\t    })\n\t    const data = null\n", "    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, null)\n\t  })\n\t  test('dis-allow undefined value', async ({ assert }) => {\n\t    assert.plan(2)\n", "    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n\t        bail: true,\n\t        fieldName: 'username',\n\t        validations: [],\n\t        propertyName: 'userName',\n\t        allowNull: true,\n\t        isOptional: false,\n", "      },\n\t    })\n\t    const data = undefined\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n", "    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n\t  test('run validations', async ({ assert }) => {\n\t    assert.plan(7)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n", "        type: 'literal',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t          {\n", "            ruleFnId: 'ref://3',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: '*',\n\t        allowNull: true,\n\t        isOptional: false,\n\t      },\n\t    })\n", "    const data = 'virk'\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.equal(value, 'virk')\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n", "            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t        },\n\t      },\n\t      'ref://3': {\n\t        validator(value, options, field) {\n\t          assert.equal(value, 'virk')\n", "          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t        },\n", "      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, 'virk')\n\t  })\n\t  test('do not run validations when value is null', async ({ assert }) => {\n\t    assert.plan(1)\n", "    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n\t        bail: true,\n\t        fieldName: 'username',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n", "            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: 'userName',\n\t        allowNull: true,\n", "        isOptional: false,\n\t      },\n\t    })\n\t    const data = null\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator() {\n\t          throw new Error('Never expected to reach here')\n\t        },\n", "      },\n\t      'ref://3': {\n\t        validator() {\n\t          throw new Error('Never expected to reach here')\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n", "    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, null)\n\t  })\n\t  test('run validations for implicit rules when value is null', async ({ assert }) => {\n\t    assert.plan(4)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n\t        bail: true,\n", "        fieldName: 'username',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: true,\n", "            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: 'userName',\n\t        allowNull: true,\n\t        isOptional: false,\n\t      },\n\t    })\n\t    const data = null\n\t    const meta = {}\n", "    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator() {\n\t          throw new Error('Never expected to reach here')\n\t        },\n\t      },\n\t      'ref://3': {\n\t        validator(value, options, field) {\n\t          assert.isNull(value)\n\t          assert.isUndefined(options)\n", "          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t        },\n\t      },\n", "    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, null)\n\t  })\n\t  test('convert empty string to null', async ({ assert }) => {\n\t    const compiler = new Compiler(\n\t      {\n", "        type: 'root',\n\t        schema: {\n\t          type: 'literal',\n\t          bail: true,\n\t          fieldName: '*',\n\t          validations: [],\n\t          propertyName: '*',\n\t          allowNull: true,\n\t          isOptional: false,\n\t        },\n", "      },\n\t      { convertEmptyStringsToNull: true }\n\t    )\n\t    const data = ''\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n", "    assert.isNull(output)\n\t  })\n\t})\n"]}
{"filename": "tests/integration/compiler/record_node.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '../../../index.js'\n", "import { ValidationRule } from '../../../src/types.js'\n\timport { Compiler } from '../../../src/compiler/main.js'\n\timport { ErrorReporterFactory } from '../../../factories/error_reporter.js'\n\timport { MessagesProviderFactory } from '../../../factories/messages_provider.js'\n\ttest.group('Record node', () => {\n\t  test('process a record field', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n", "        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          allowNull: false,\n", "          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data: any = {}\n\t    const meta = {}\n\t    const refs = {}\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, {})\n\t    // Mutation test:\n\t    data.colors = { white: '#fff' }\n\t    assert.deepEqual(output, {})\n\t  })\n\t  test('dis-allow undefined value', async ({ assert }) => {\n", "    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n", "        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n", "      },\n\t    })\n\t    const data = undefined\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n", "    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n\t  test('dis-allow null value', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n", "        type: 'record',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n", "          allowNull: false,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = null\n\t    const meta = {}\n", "    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n", "  })\n\t  test('dis-allow non-object values', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n", "        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n", "          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = 'hello world'\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n", "    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is not a valid object'])\n\t    }\n\t  })\n\t  test('process each element', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'record',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n", "          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = { white: '#fff', black: '#000' }\n", "    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, { white: '#fff', black: '#000' })\n\t    // Mutation test:\n\t    data.white = 'white'\n\t    assert.deepEqual(output, { white: '#fff', black: '#000' })\n", "  })\n\t  test('validate nested each elements', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n", "        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'record',\n\t          bail: true,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n", "          validations: [],\n\t          each: {\n\t            type: 'literal',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            fieldName: '*',\n\t            propertyName: '*',\n\t            validations: [],\n\t          },\n", "        },\n\t      },\n\t    })\n\t    const data = { white: '#fff', black: '#000' }\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n", "      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, [\n\t        'value is not a valid object',\n\t        'value is not a valid object',\n\t      ])\n\t    }\n\t  })\n\t  test('process nested each elements', async ({ assert }) => {\n", "    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n", "        each: {\n\t          type: 'record',\n\t          bail: true,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n\t          validations: [],\n\t          each: {\n\t            type: 'literal',\n", "            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            fieldName: '*',\n\t            propertyName: '*',\n\t            validations: [],\n\t          },\n\t        },\n\t      },\n\t    })\n", "    const data = {\n\t      white: { bg: '#f3f3f3', fg: '#fff' },\n\t      black: { bg: '#000', fg: '#000' },\n\t    }\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n", "    assert.deepEqual(output, {\n\t      white: { bg: '#f3f3f3', fg: '#fff' },\n\t      black: { bg: '#000', fg: '#000' },\n\t    })\n\t    // Mutation test:\n\t    data.white.bg = 'white'\n\t    assert.deepEqual(output, {\n\t      white: { bg: '#f3f3f3', fg: '#fff' },\n\t      black: { bg: '#000', fg: '#000' },\n\t    })\n", "  })\n\t  test('run validations', async ({ assert }) => {\n\t    assert.plan(7)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [\n", "          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n", "        ],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          fieldName: '*',\n", "          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = { white: '#fff', black: '#000' }\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n", "          assert.deepEqual(value, { white: '#fff', black: '#000' })\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n", "        },\n\t      },\n\t      'ref://3': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, { white: '#fff', black: '#000' })\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n", "            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n", "    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, { white: '#fff', black: '#000' })\n\t  })\n\t  test('stop validations after first error', async ({ assert }) => {\n\t    assert.plan(5)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        bail: true,\n", "        fieldName: '*',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: false,\n", "            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          allowNull: false,\n", "          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = { white: '#fff', black: '#000' }\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n", "      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, { white: '#fff', black: '#000' })\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n", "            data,\n\t          })\n\t          field.report('ref://2 validation failed', 'ref', field)\n\t        },\n\t      },\n\t      'ref://3': {\n\t        validator() {\n\t          throw new Error('Never expected to reach here')\n\t        },\n\t      },\n", "    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n\t    }\n", "  })\n\t  test('continue validations after error when bail mode is disabled', async ({ assert }) => {\n\t    assert.plan(8)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        bail: false,\n\t        fieldName: '*',\n\t        validations: [\n", "          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n", "        ],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          fieldName: '*',\n", "          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = { white: '#fff', black: '#000' }\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n", "          assert.deepEqual(value, { white: '#fff', black: '#000' })\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n", "          field.report('ref://2 validation failed', 'ref', field)\n\t        },\n\t      },\n\t      'ref://3': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, { white: '#fff', black: '#000' })\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n", "            isValid: false,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n\t    }\n\t  })\n\t  test('do not process children when record is invalid', async ({ assert }) => {\n\t    assert.plan(5)\n", "    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n", "            isAsync: false,\n\t          },\n\t        ],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          allowNull: false,\n", "          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [\n\t            {\n\t              ruleFnId: 'ref://3',\n\t              implicit: false,\n\t              isAsync: false,\n\t            },\n\t          ],\n", "        },\n\t      },\n\t    })\n\t    const data = { white: '#fff', black: '#000' }\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, { white: '#fff', black: '#000' })\n\t          assert.isUndefined(options)\n", "          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t          field.report('ref://2 validation failed', 'ref', field)\n\t        },\n", "      },\n\t      'ref://3': {\n\t        validator() {\n\t          throw new Error('Never expected to be called')\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n", "    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n\t    }\n\t  })\n\t  test('process children for invalid record when bail mode is disabled', async ({ assert }) => {\n\t    assert.plan(15)\n\t    const compiler = new Compiler({\n", "      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        bail: false,\n\t        fieldName: '*',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n", "          },\n\t        ],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n", "          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [\n\t            {\n\t              ruleFnId: 'ref://3',\n\t              implicit: false,\n\t              isAsync: false,\n\t            },\n\t          ],\n\t        },\n", "      },\n\t    })\n\t    const data = { white: '#fff', black: '#000' }\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, { white: '#fff', black: '#000' })\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n", "            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t          field.report('ref://2 validation failed', 'ref', field)\n\t        },\n\t      },\n", "      'ref://3': {\n\t        validator(value, options, field) {\n\t          assert.oneOf(field.name, ['white', 'black'])\n\t          assert.equal(field.wildCardPath, '*')\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: { white: '#fff', black: '#000' },\n", "            data,\n\t          })\n\t          if (!field.isArrayMember) {\n\t            assert.equal(field.parent[field.name], value)\n\t          }\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n\t    }\n\t  })\n\t  test('convert empty string to null', async ({ assert }) => {\n\t    assert.plan(2)\n", "    const compiler = new Compiler(\n\t      {\n\t        type: 'root',\n\t        schema: {\n\t          type: 'record',\n\t          bail: true,\n\t          fieldName: '*',\n\t          validations: [],\n\t          propertyName: '*',\n\t          allowNull: false,\n", "          isOptional: false,\n\t          each: {\n\t            type: 'literal',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            fieldName: '*',\n\t            propertyName: '*',\n\t            validations: [],\n\t          },\n", "        },\n\t      },\n\t      { convertEmptyStringsToNull: true }\n\t    )\n\t    const data: any = ''\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n", "    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n\t  test('call parse function', async ({ assert }) => {\n\t    assert.plan(3)\n\t    const compiler = new Compiler({\n", "      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        parseFnId: 'ref://1',\n", "        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n", "    })\n\t    const data: any = {}\n\t    const meta = {}\n\t    const refs = refsBuilder()\n\t    refs.trackParser((value) => {\n\t      assert.deepEqual(value, {})\n\t      return value\n\t    })\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs.toJSON(), messagesProvider, errorReporter)\n\t    assert.deepEqual(output, {})\n\t    // Mutation test:\n\t    data.colors = { white: '#fff' }\n\t    assert.deepEqual(output, {})\n\t  })\n\t})\n\ttest.group('Record node | optional: true', () => {\n\t  test('process a record field', async ({ assert }) => {\n", "    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: true,\n", "        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n", "    })\n\t    const data = {}\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, {})\n\t  })\n", "  test('allow undefined value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n", "        isOptional: true,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n", "      },\n\t    })\n\t    const data = undefined\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, undefined)\n", "  })\n\t  test('allow null value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n", "        allowNull: false,\n\t        isOptional: true,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n", "        },\n\t      },\n\t    })\n\t    const data = null\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n", "    assert.deepEqual(output, undefined)\n\t  })\n\t  test('dis-allow non-object values', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        bail: true,\n\t        fieldName: '*',\n", "        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: true,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          fieldName: '*',\n", "          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = 'hello world'\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is not a valid object'])\n\t    }\n\t  })\n\t  test('convert empty string to null', async ({ assert }) => {\n\t    const compiler = new Compiler(\n", "      {\n\t        type: 'root',\n\t        schema: {\n\t          type: 'record',\n\t          bail: true,\n\t          fieldName: '*',\n\t          validations: [],\n\t          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: true,\n", "          each: {\n\t            type: 'literal',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            fieldName: '*',\n\t            propertyName: '*',\n\t            validations: [],\n\t          },\n\t        },\n", "      },\n\t      { convertEmptyStringsToNull: true }\n\t    )\n\t    const data: any = ''\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n", "    assert.isUndefined(output)\n\t  })\n\t})\n\ttest.group('Record node | allowNull: true', () => {\n\t  test('process a record field', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        bail: true,\n", "        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n", "          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = {}\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n", "    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, {})\n\t  })\n\t  test('dis-allow undefined value', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n", "        type: 'record',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n", "          allowNull: false,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = undefined\n\t    const meta = {}\n", "    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n", "  })\n\t  test('allow null value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n", "        allowNull: true,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n", "        },\n\t      },\n\t    })\n\t    const data = null\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n", "    assert.deepEqual(output, null)\n\t  })\n\t  test('dis-allow non-object values', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        bail: true,\n\t        fieldName: '*',\n", "        validations: [],\n\t        propertyName: '*',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          allowNull: false,\n\t          isOptional: false,\n\t          fieldName: '*',\n", "          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = 'hello world'\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is not a valid object'])\n\t    }\n\t  })\n\t  test('convert empty string to null', async ({ assert }) => {\n\t    const compiler = new Compiler(\n", "      {\n\t        type: 'root',\n\t        schema: {\n\t          type: 'record',\n\t          bail: true,\n\t          fieldName: '*',\n\t          validations: [],\n\t          propertyName: '*',\n\t          allowNull: true,\n\t          isOptional: false,\n", "          each: {\n\t            type: 'literal',\n\t            bail: true,\n\t            allowNull: false,\n\t            isOptional: false,\n\t            fieldName: '*',\n\t            propertyName: '*',\n\t            validations: [],\n\t          },\n\t        },\n", "      },\n\t      { convertEmptyStringsToNull: true }\n\t    )\n\t    const data: any = ''\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n", "    assert.isNull(output)\n\t  })\n\t})\n"]}
{"filename": "tests/integration/compiler/array_node.spec.ts", "chunked_list": ["/*\n\t * @adonisjs/validator\n\t *\n\t * (c) Validator\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { refsBuilder } from '../../../index.js'\n", "import { Compiler } from '../../../src/compiler/main.js'\n\timport type { ValidationRule } from '../../../src/types.js'\n\timport { ErrorReporterFactory } from '../../../factories/error_reporter.js'\n\timport { MessagesProviderFactory } from '../../../factories/messages_provider.js'\n\ttest.group('Array node', () => {\n\t  test('process an array field', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'array',\n", "        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          allowNull: false,\n\t          bail: true,\n", "          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data: any[] = []\n\t    const meta = {}\n\t    const refs = {}\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, [])\n\t    // Mutation test\n\t    data[0] = 'foo'\n\t    assert.deepEqual(output, [])\n\t  })\n\t  test('dis-allow undefined value', async ({ assert }) => {\n", "    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n", "        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          allowNull: false,\n\t          bail: true,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n", "      },\n\t    })\n\t    const data = undefined\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n", "    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n\t  test('dis-allow null value', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n", "        type: 'array',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          allowNull: false,\n", "          bail: true,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = null\n\t    const meta = {}\n", "    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n", "  })\n\t  test('dis-allow non-array values', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n", "        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          allowNull: false,\n\t          bail: true,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n", "          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = 'hello world'\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n", "    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is not a valid array'])\n\t    }\n\t  })\n\t  test('validate each node', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n", "      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n", "          type: 'literal',\n\t          bail: true,\n\t          fieldName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n", "    const data = [undefined]\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n", "      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n\t  test('process each node', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        bail: true,\n\t        fieldName: '*',\n", "        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          fieldName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n", "          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = ['hello world', 'hi world']\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, ['hello world', 'hi world'])\n\t    // Mutation test\n\t    data[0] = 'foo'\n\t    assert.deepEqual(output, ['hello world', 'hi world'])\n\t  })\n\t  test('process nested array nodes', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'array',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'array',\n", "          bail: true,\n\t          fieldName: '*',\n\t          validations: [],\n\t          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n\t          each: {\n\t            type: 'literal',\n\t            bail: true,\n\t            fieldName: '*',\n", "            allowNull: false,\n\t            isOptional: false,\n\t            propertyName: '*',\n\t            validations: [],\n\t          },\n\t        },\n\t      },\n\t    })\n\t    const data: any = [['hello world'], ['hi world']]\n\t    const meta = {}\n", "    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, [['hello world'], ['hi world']])\n\t    // Mutation test\n\t    data[0][0] = 'foo'\n\t    assert.deepEqual(output, [['hello world'], ['hi world']])\n\t  })\n", "  test('run validations', async ({ assert }) => {\n\t    assert.plan(7)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        bail: true,\n\t        fieldName: '',\n\t        validations: [\n\t          {\n", "            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t        ],\n", "        propertyName: '',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          fieldName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n\t          propertyName: '*',\n", "          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = ['hello world', 'hi world']\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, ['hello world', 'hi world'])\n", "          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t        },\n", "      },\n\t      'ref://3': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, ['hello world', 'hi world'])\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n", "            parent: data,\n\t            data,\n\t          })\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n", "    assert.deepEqual(output, ['hello world', 'hi world'])\n\t  })\n\t  test('stop validations after first error', async ({ assert }) => {\n\t    assert.plan(5)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        bail: true,\n\t        fieldName: '*',\n", "        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: false,\n\t            isAsync: false,\n", "          },\n\t        ],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          fieldName: '*',\n\t          allowNull: false,\n", "          isOptional: false,\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = ['hello world', 'hi world']\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n", "        validator(value, options, field) {\n\t          assert.deepEqual(value, ['hello world', 'hi world'])\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n", "          })\n\t          field.report('ref://2 validation failed', 'ref', field)\n\t        },\n\t      },\n\t      'ref://3': {\n\t        validator() {\n\t          throw new Error('Never expected to be called')\n\t        },\n\t      },\n\t    }\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n\t    }\n\t  })\n", "  test('continue validations after error when bail mode is disabled', async ({ assert }) => {\n\t    assert.plan(8)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        bail: false,\n\t        fieldName: '*',\n\t        validations: [\n\t          {\n", "            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t          {\n\t            ruleFnId: 'ref://3',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n\t        ],\n", "        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          fieldName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n\t          propertyName: '*',\n", "          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = ['hello world', 'hi world']\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, ['hello world', 'hi world'])\n", "          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t          field.report('ref://2 validation failed', 'ref', field)\n", "        },\n\t      },\n\t      'ref://3': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, ['hello world', 'hi world'])\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n\t            isArrayMember: false,\n\t            isValid: false,\n", "            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n", "    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n\t    }\n\t  })\n\t  test('do not process children when array is invalid', async ({ assert }) => {\n\t    assert.plan(5)\n\t    const compiler = new Compiler({\n", "      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        bail: true,\n\t        fieldName: 'contacts',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n", "          },\n\t        ],\n\t        propertyName: 'contacts',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          fieldName: '*',\n\t          allowNull: false,\n", "          isOptional: false,\n\t          propertyName: '*',\n\t          validations: [\n\t            {\n\t              ruleFnId: 'ref://3',\n\t              implicit: false,\n\t              isAsync: false,\n\t            },\n\t          ],\n\t        },\n", "      },\n\t    })\n\t    const data = ['hello world', 'hi world']\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, ['hello world', 'hi world'])\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n", "            name: '',\n\t            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t          field.report('ref://2 validation failed', 'ref', field)\n\t        },\n\t      },\n", "      'ref://3': {\n\t        validator() {\n\t          throw new Error('Never expected to be called')\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n", "      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n\t    }\n\t  })\n\t  test('process children for invalid array when bail mode is disabled', async ({ assert }) => {\n\t    assert.plan(17)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'array',\n\t        bail: false,\n\t        fieldName: 'contacts',\n\t        validations: [\n\t          {\n\t            ruleFnId: 'ref://2',\n\t            implicit: false,\n\t            isAsync: false,\n\t          },\n", "        ],\n\t        propertyName: 'contacts',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          bail: true,\n\t          fieldName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n", "          propertyName: '*',\n\t          validations: [\n\t            {\n\t              ruleFnId: 'ref://3',\n\t              implicit: false,\n\t              isAsync: false,\n\t            },\n\t          ],\n\t        },\n\t      },\n", "    })\n\t    const data = ['hello world', 'hi world']\n\t    const meta = {}\n\t    const refs: Record<string, ValidationRule> = {\n\t      'ref://2': {\n\t        validator(value, options, field) {\n\t          assert.deepEqual(value, ['hello world', 'hi world'])\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            name: '',\n", "            isArrayMember: false,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: data,\n\t            data,\n\t          })\n\t          field.report('ref://2 validation failed', 'ref', field)\n\t        },\n\t      },\n\t      'ref://3': {\n", "        validator(value, options, field) {\n\t          assert.oneOf(value, ['hello world', 'hi world'])\n\t          assert.isUndefined(options)\n\t          assert.containsSubset(field, {\n\t            isArrayMember: true,\n\t            isValid: true,\n\t            meta: {},\n\t            parent: ['hello world', 'hi world'],\n\t            data,\n\t          })\n", "          assert.oneOf(field.name, [0, 1])\n\t          assert.equal(field.wildCardPath, '*')\n\t          if (field.isArrayMember) {\n\t            assert.equal(field.parent[field.name], value)\n\t          }\n\t        },\n\t      },\n\t    }\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['ref://2 validation failed'])\n\t    }\n\t  })\n\t  test('convert empty string to null', async ({ assert }) => {\n\t    assert.plan(2)\n", "    const compiler = new Compiler(\n\t      {\n\t        type: 'root',\n\t        schema: {\n\t          type: 'array',\n\t          bail: true,\n\t          fieldName: '*',\n\t          validations: [],\n\t          propertyName: '*',\n\t          allowNull: false,\n", "          isOptional: false,\n\t          each: {\n\t            type: 'literal',\n\t            allowNull: false,\n\t            bail: true,\n\t            isOptional: false,\n\t            fieldName: '*',\n\t            propertyName: '*',\n\t            validations: [],\n\t          },\n", "        },\n\t      },\n\t      { convertEmptyStringsToNull: true }\n\t    )\n\t    const data: any = ''\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n", "    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n\t  test('call parse function', async ({ assert }) => {\n\t    assert.plan(3)\n\t    const compiler = new Compiler({\n", "      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        bail: true,\n\t        fieldName: '*',\n\t        validations: [],\n\t        propertyName: '*',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        parseFnId: 'ref://1',\n", "        each: {\n\t          type: 'literal',\n\t          allowNull: false,\n\t          bail: true,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n", "    })\n\t    const data: any[] = []\n\t    const meta = {}\n\t    const refs = refsBuilder()\n\t    refs.trackParser((value) => {\n\t      assert.deepEqual(value, [])\n\t      return value\n\t    })\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs.toJSON(), messagesProvider, errorReporter)\n\t    assert.deepEqual(output, [])\n\t    // Mutation test\n\t    data[0] = 'foo'\n\t    assert.deepEqual(output, [])\n\t  })\n\t})\n\ttest.group('Array node | optional: true', () => {\n\t  test('process an array field', async ({ assert }) => {\n", "    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        bail: true,\n\t        fieldName: 'contacts',\n\t        validations: [],\n\t        propertyName: 'contacts',\n\t        allowNull: false,\n\t        isOptional: true,\n", "        each: {\n\t          type: 'literal',\n\t          allowNull: false,\n\t          bail: true,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n", "    })\n\t    const data: any = []\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, [])\n\t    // Mutation test\n", "    data[0] = 'foo'\n\t    assert.deepEqual(output, [])\n\t  })\n\t  test('allow undefined value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        bail: true,\n\t        fieldName: 'contacts',\n", "        validations: [],\n\t        propertyName: 'contacts',\n\t        allowNull: false,\n\t        isOptional: true,\n\t        each: {\n\t          type: 'literal',\n\t          allowNull: false,\n\t          bail: true,\n\t          isOptional: false,\n\t          fieldName: '*',\n", "          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data: any = undefined\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, undefined)\n\t  })\n\t  test('allow null value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        bail: true,\n", "        fieldName: 'contacts',\n\t        validations: [],\n\t        propertyName: 'contacts',\n\t        allowNull: false,\n\t        isOptional: true,\n\t        each: {\n\t          type: 'literal',\n\t          allowNull: false,\n\t          bail: true,\n\t          isOptional: false,\n", "          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = null\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n", "    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, undefined)\n\t  })\n\t  test('dis-allow non-array values', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n", "        type: 'array',\n\t        bail: true,\n\t        fieldName: 'contacts',\n\t        validations: [],\n\t        propertyName: 'contacts',\n\t        allowNull: false,\n\t        isOptional: true,\n\t        each: {\n\t          type: 'literal',\n\t          allowNull: false,\n", "          bail: true,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = 'hello world'\n\t    const meta = {}\n", "    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is not a valid array'])\n\t    }\n", "  })\n\t  test('convert empty string to null', async ({ assert }) => {\n\t    const compiler = new Compiler(\n\t      {\n\t        type: 'root',\n\t        schema: {\n\t          type: 'array',\n\t          bail: true,\n\t          fieldName: '*',\n\t          validations: [],\n", "          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: true,\n\t          each: {\n\t            type: 'literal',\n\t            allowNull: false,\n\t            bail: true,\n\t            isOptional: false,\n\t            fieldName: '*',\n\t            propertyName: '*',\n", "            validations: [],\n\t          },\n\t        },\n\t      },\n\t      { convertEmptyStringsToNull: true }\n\t    )\n\t    const data: any = ''\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n", "    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.isUndefined(output)\n\t  })\n\t})\n\ttest.group('Array node | allowNull: true', () => {\n\t  test('process an array field', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'array',\n\t        bail: true,\n\t        fieldName: 'contacts',\n\t        validations: [],\n\t        propertyName: 'contacts',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n", "          allowNull: false,\n\t          bail: true,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data: any = []\n", "    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, [])\n\t  })\n\t  test('dis-allow undefined value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n", "      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        bail: true,\n\t        fieldName: 'contacts',\n\t        validations: [],\n\t        propertyName: 'contacts',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        each: {\n", "          type: 'literal',\n\t          allowNull: false,\n\t          bail: true,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n", "    const data = undefined\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n", "      assert.deepEqual(error.messages, ['value is required'])\n\t    }\n\t  })\n\t  test('allow null value', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        bail: true,\n\t        fieldName: 'contacts',\n", "        validations: [],\n\t        propertyName: 'contacts',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          allowNull: false,\n\t          bail: true,\n\t          isOptional: false,\n\t          fieldName: '*',\n", "          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data: any = null\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.deepEqual(output, null)\n\t  })\n\t  test('dis-allow non-array values', async ({ assert }) => {\n\t    assert.plan(2)\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'array',\n", "        bail: true,\n\t        fieldName: 'contacts',\n\t        validations: [],\n\t        propertyName: 'contacts',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'literal',\n\t          allowNull: false,\n\t          bail: true,\n", "          isOptional: false,\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const data = 'hello world'\n\t    const meta = {}\n\t    const refs = {}\n", "    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n\t    const fn = compiler.compile()\n\t    try {\n\t      await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    } catch (error) {\n\t      assert.equal(error.message, 'Validation failure')\n\t      assert.deepEqual(error.messages, ['value is not a valid array'])\n\t    }\n\t  })\n", "  test('convert empty string to null', async ({ assert }) => {\n\t    const compiler = new Compiler(\n\t      {\n\t        type: 'root',\n\t        schema: {\n\t          type: 'array',\n\t          bail: true,\n\t          fieldName: '*',\n\t          validations: [],\n\t          propertyName: '*',\n", "          allowNull: true,\n\t          isOptional: false,\n\t          each: {\n\t            type: 'literal',\n\t            allowNull: false,\n\t            bail: true,\n\t            isOptional: false,\n\t            fieldName: '*',\n\t            propertyName: '*',\n\t            validations: [],\n", "          },\n\t        },\n\t      },\n\t      { convertEmptyStringsToNull: true }\n\t    )\n\t    const data: any = ''\n\t    const meta = {}\n\t    const refs = {}\n\t    const messagesProvider = new MessagesProviderFactory().create()\n\t    const errorReporter = new ErrorReporterFactory().create()\n", "    const fn = compiler.compile()\n\t    const output = await fn(data, meta, refs, messagesProvider, errorReporter)\n\t    assert.isNull(output)\n\t  })\n\t})\n"]}
{"filename": "tests/unit/move_properties.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { defineInlineFunctions } from '../../src/scripts/define_inline_functions.js'\n", "const fn = new Function(\n\t  'data',\n\t  'output',\n\t  'ignoreProperties',\n\t  `\n\t  ${defineInlineFunctions({ convertEmptyStringsToNull: false })}\n\t  moveProperties(data, output, ignoreProperties)\n\t  `\n\t)\n\ttest.group('Move properties', () => {\n", "  test('move properties from a flat object', ({ assert }) => {\n\t    const data = {\n\t      username: 'virk',\n\t      password: 'secret',\n\t      age: 32,\n\t    }\n\t    const output = {\n\t      username: 'VIRK',\n\t    }\n\t    fn(data, output, ['username'])\n", "    assert.deepEqual(output, {\n\t      username: 'VIRK',\n\t      password: 'secret',\n\t      age: 32,\n\t    })\n\t    // Mutating source\n\t    data.age = 34\n\t    assert.deepEqual(output, {\n\t      username: 'VIRK',\n\t      password: 'secret',\n", "      age: 32,\n\t    })\n\t  })\n\t  test('move properties from a nested object', ({ assert }) => {\n\t    const data = {\n\t      username: 'virk',\n\t      password: 'secret',\n\t      meta: {\n\t        age: 32,\n\t        password: 'secret',\n", "        sigfile: 'file://foobar',\n\t      },\n\t    }\n\t    const output = {\n\t      username: 'VIRK',\n\t      password: 'SECRET',\n\t    }\n\t    fn(data, output, ['username', 'password'])\n\t    assert.deepEqual(output, {\n\t      username: 'VIRK',\n", "      password: 'SECRET',\n\t      meta: {\n\t        age: 32,\n\t        password: 'secret',\n\t        sigfile: 'file://foobar',\n\t      },\n\t    })\n\t    // Mutating source\n\t    data.meta.age = 34\n\t    assert.deepEqual(output, {\n", "      username: 'VIRK',\n\t      password: 'SECRET',\n\t      meta: {\n\t        age: 32,\n\t        password: 'secret',\n\t        sigfile: 'file://foobar',\n\t      },\n\t    })\n\t  })\n\t  test('dereference arrays', ({ assert }) => {\n", "    const data = {\n\t      username: 'virk',\n\t      password: 'secret',\n\t      meta: [\n\t        {\n\t          age: 32,\n\t          password: 'secret',\n\t          sigfile: 'file://foobar',\n\t        },\n\t      ],\n", "    }\n\t    const output = {\n\t      username: 'VIRK',\n\t      password: 'SECRET',\n\t    }\n\t    fn(data, output, ['username', 'password'])\n\t    assert.deepEqual(output, {\n\t      username: 'VIRK',\n\t      password: 'SECRET',\n\t      meta: [\n", "        {\n\t          age: 32,\n\t          password: 'secret',\n\t          sigfile: 'file://foobar',\n\t        },\n\t      ],\n\t    })\n\t    // Mutating source\n\t    data.meta[0].age = 34\n\t    data.meta.push({ age: 34, password: 'foo', sigfile: 'file://foo' })\n", "    assert.deepEqual(output, {\n\t      username: 'VIRK',\n\t      password: 'SECRET',\n\t      meta: [\n\t        {\n\t          age: 32,\n\t          password: 'secret',\n\t          sigfile: 'file://foobar',\n\t        },\n\t      ],\n", "    })\n\t  })\n\t})\n"]}
{"filename": "tests/unit/nodes/union.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { Compiler } from '../../../src/compiler/main.js'\n", "import { validateCode } from '../../../factories/code_validator.js'\n\timport { getClosingOutput, getInitialOutput } from '../../../factories/output.js'\n\ttest.group('Union node', () => {\n\t  test('create JS output for a union node', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'union',\n\t        fieldName: '*',\n\t        propertyName: '*',\n", "        conditions: [\n\t          {\n\t            conditionalFnRefId: 'ref://1',\n\t            schema: {\n\t              type: 'literal',\n\t              fieldName: '*',\n\t              allowNull: false,\n\t              isOptional: false,\n\t              propertyName: '*',\n\t              bail: true,\n", "              validations: [\n\t                {\n\t                  ruleFnId: 'ref://2',\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                },\n\t              ],\n\t            },\n\t          },\n\t          {\n", "            conditionalFnRefId: 'ref://3',\n\t            schema: {\n\t              type: 'literal',\n\t              fieldName: '*',\n\t              allowNull: false,\n\t              isOptional: false,\n\t              propertyName: '*',\n\t              bail: true,\n\t              validations: [\n\t                {\n", "                  ruleFnId: 'ref://4',\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                },\n\t              ],\n\t            },\n\t          },\n\t        ],\n\t      },\n\t    })\n", "    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `data: root,`,\n\t      `meta: meta,`,\n\t      `name: '',`,\n\t      `wildCardPath: '',`,\n\t      `mutate: defineValue,`,\n", "      `report: report,`,\n\t      `isValid: true,`,\n\t      `parent: root,`,\n\t      `isArrayMember: false,`,\n\t      '});',\n\t      `if(refs['ref://1'](root_item.value, root_item)) {`,\n\t      `ensureExists(root_item);`,\n\t      `if (root_item.isValid && root_item.isDefined) {`,\n\t      `refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n\t      `}`,\n", "      `if (root_item.isDefined && root_item.isValid) {`,\n\t      `out = root_item.value;`,\n\t      `}`,\n\t      `}`,\n\t      `else if(refs['ref://3'](root_item.value, root_item)) {`,\n\t      `ensureExists(root_item);`,\n\t      `if (root_item.isValid && root_item.isDefined) {`,\n\t      `refs['ref://4'].validator(root_item.value, refs['ref://4'].options, root_item);`,\n\t      `}`,\n\t      `if (root_item.isDefined && root_item.isValid) {`,\n", "      `out = root_item.value;`,\n\t      `}`,\n\t      `}`,\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('define union else block', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n", "        type: 'union',\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        elseConditionalFnRefId: 'ref://10',\n\t        conditions: [\n\t          {\n\t            conditionalFnRefId: 'ref://1',\n\t            schema: {\n\t              type: 'literal',\n\t              fieldName: '*',\n", "              allowNull: false,\n\t              isOptional: false,\n\t              propertyName: '*',\n\t              bail: true,\n\t              validations: [\n\t                {\n\t                  ruleFnId: 'ref://2',\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                },\n", "              ],\n\t            },\n\t          },\n\t          {\n\t            conditionalFnRefId: 'ref://3',\n\t            schema: {\n\t              type: 'literal',\n\t              fieldName: '*',\n\t              allowNull: false,\n\t              isOptional: false,\n", "              propertyName: '*',\n\t              bail: true,\n\t              validations: [\n\t                {\n\t                  ruleFnId: 'ref://4',\n\t                  implicit: false,\n\t                  isAsync: false,\n\t                },\n\t              ],\n\t            },\n", "          },\n\t        ],\n\t      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `data: root,`,\n", "      `meta: meta,`,\n\t      `name: '',`,\n\t      `wildCardPath: '',`,\n\t      `mutate: defineValue,`,\n\t      `report: report,`,\n\t      `isValid: true,`,\n\t      `parent: root,`,\n\t      `isArrayMember: false,`,\n\t      '});',\n\t      `if(refs['ref://1'](root_item.value, root_item)) {`,\n", "      `ensureExists(root_item);`,\n\t      `if (root_item.isValid && root_item.isDefined) {`,\n\t      `refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n\t      `}`,\n\t      `if (root_item.isDefined && root_item.isValid) {`,\n\t      `out = root_item.value;`,\n\t      `}`,\n\t      `}`,\n\t      `else if(refs['ref://3'](root_item.value, root_item)) {`,\n\t      `ensureExists(root_item);`,\n", "      `if (root_item.isValid && root_item.isDefined) {`,\n\t      `refs['ref://4'].validator(root_item.value, refs['ref://4'].options, root_item);`,\n\t      `}`,\n\t      `if (root_item.isDefined && root_item.isValid) {`,\n\t      `out = root_item.value;`,\n\t      `}`,\n\t      `} else {`,\n\t      `refs['ref://10'](root_item.value, root_item);`,\n\t      `}`,\n\t      ...getClosingOutput(),\n", "    ])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/nodes/literal.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { Compiler } from '../../../src/compiler/main.js'\n", "import { validateCode } from '../../../factories/code_validator.js'\n\timport { getClosingOutput, getInitialOutput } from '../../../factories/output.js'\n\ttest.group('Literal node', () => {\n\t  test('create JS output for a literal node', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n\t        allowNull: false,\n\t        isOptional: false,\n", "        bail: true,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        validations: [\n\t          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://2',\n\t          },\n\t        ],\n", "      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n", "      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureExists(root_item);`,\n\t      `if (root_item.isValid && root_item.isDefined) {`,\n\t      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n", "      `}`,\n\t      `if (root_item.isDefined && root_item.isValid) {`,\n\t      `  out = root_item.value;`,\n\t      `}`,\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output for nullable field', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'literal',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        bail: true,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        validations: [\n\t          {\n\t            implicit: false,\n", "            isAsync: false,\n\t            ruleFnId: 'ref://2',\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n", "      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n", "      '});',\n\t      `ensureIsDefined(root_item);`,\n\t      `if (root_item.isValid && root_item.isDefined) {`,\n\t      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n\t      `}`,\n\t      `if (root_item.isDefined && root_item.isValid) {`,\n\t      `  out = root_item.value;`,\n\t      `} else if (root_item.value === null) {`,\n\t      `  out = null;`,\n\t      `}`,\n", "      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output with bail mode disabled', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'literal',\n\t        allowNull: true,\n\t        isOptional: false,\n", "        bail: false,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        validations: [\n\t          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://2',\n\t          },\n\t        ],\n", "      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n", "      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureIsDefined(root_item);`,\n\t      `if (root_item.isDefined) {`,\n\t      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n", "      `}`,\n\t      `if (root_item.isDefined && root_item.isValid) {`,\n\t      `  out = root_item.value;`,\n\t      `} else if (root_item.value === null) {`,\n\t      `  out = null;`,\n\t      `}`,\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/nodes/object.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { Compiler } from '../../../src/compiler/main.js'\n", "import { validateCode } from '../../../factories/code_validator.js'\n\timport { getClosingOutput, getInitialOutput } from '../../../factories/output.js'\n\ttest.group('Object node', () => {\n\t  test('create JS output for an object node', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        allowNull: false,\n", "        isOptional: false,\n\t        bail: true,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        validations: [\n\t          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://2',\n\t          },\n", "        ],\n\t        properties: [],\n\t        allowUnknownProperties: false,\n\t      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n", "      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n", "      `ensureExists(root_item);`,\n\t      `if (ensureIsObject(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n\t      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n\t      `}`,\n\t      `if (root_item.isValid) {`,\n\t      `const root_item_out = {};`,\n\t      `out = root_item_out;`,\n\t      '}',\n\t      `}`,\n", "      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output for a nullable object node', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        allowNull: true,\n", "        isOptional: false,\n\t        bail: true,\n\t        fieldName: 'profile',\n\t        propertyName: 'userProfile',\n\t        validations: [\n\t          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://2',\n\t          },\n", "        ],\n\t        properties: [],\n\t        allowUnknownProperties: false,\n\t      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n", "      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n", "      `ensureIsDefined(root_item);`,\n\t      `if (ensureIsObject(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n\t      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n\t      `}`,\n\t      `if (root_item.isValid) {`,\n\t      `const root_item_out = {};`,\n\t      `out = root_item_out;`,\n\t      '}',\n\t      `}`,\n", "      'else if(root_item.value === null) {',\n\t      `  out = null;`,\n\t      '}',\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output without object validations', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n", "        type: 'object',\n\t        groups: [],\n\t        allowNull: true,\n\t        isOptional: false,\n\t        bail: true,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        validations: [],\n\t        properties: [],\n\t        allowUnknownProperties: false,\n", "      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n", "      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureIsDefined(root_item);`,\n\t      `if (ensureIsObject(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n", "      `const root_item_out = {};`,\n\t      `out = root_item_out;`,\n\t      '}',\n\t      `}`,\n\t      'else if(root_item.value === null) {',\n\t      `  out = null;`,\n\t      '}',\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n", "  test('create JS output for object children', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        allowNull: true,\n\t        isOptional: false,\n\t        bail: true,\n\t        fieldName: 'profile',\n", "        propertyName: 'userProfile',\n\t        validations: [],\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            bail: true,\n\t            fieldName: 'username',\n\t            propertyName: 'username',\n", "            validations: [\n\t              {\n\t                implicit: false,\n\t                isAsync: false,\n\t                ruleFnId: 'ref://2',\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t        allowUnknownProperties: false,\n", "      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n", "      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureIsDefined(root_item);`,\n\t      `if (ensureIsObject(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n", "      `const root_item_out = {};`,\n\t      `out = root_item_out;`,\n\t      `const username_2 = defineValue(root_item.value['username'], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'username',`,\n\t      `  wildCardPath: 'username',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n", "      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n\t      `ensureExists(username_2);`,\n\t      `if (username_2.isValid && username_2.isDefined) {`,\n\t      `  refs['ref://2'].validator(username_2.value, refs['ref://2'].options, username_2);`,\n\t      `}`,\n\t      `if (username_2.isDefined && username_2.isValid) {`,\n\t      `  root_item_out['username'] = username_2.value;`,\n\t      `}`,\n", "      '}',\n\t      `}`,\n\t      'else if(root_item.value === null) {',\n\t      `  out = null;`,\n\t      '}',\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output for object with bail mode disabled', async ({ assert }) => {\n\t    const compiler = new Compiler({\n", "      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        allowNull: true,\n\t        isOptional: false,\n\t        bail: false,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        validations: [\n", "          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://2',\n\t          },\n\t        ],\n\t        properties: [],\n\t        allowUnknownProperties: false,\n\t      },\n\t    })\n", "    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n", "      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureIsDefined(root_item);`,\n\t      `if (ensureIsObject(root_item)) {`,\n\t      `refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n\t      `const root_item_out = {};`,\n\t      `out = root_item_out;`,\n", "      `}`,\n\t      'else if(root_item.value === null) {',\n\t      `  out = null;`,\n\t      '}',\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output for node object with unknownProperties allowed', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'object',\n\t        groups: [],\n\t        allowNull: false,\n\t        isOptional: false,\n\t        bail: true,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        validations: [\n\t          {\n", "            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://2',\n\t          },\n\t        ],\n\t        properties: [],\n\t        allowUnknownProperties: true,\n\t      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n", "    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n", "      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureExists(root_item);`,\n\t      `if (ensureIsObject(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n\t      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n\t      `}`,\n\t      `if (root_item.isValid) {`,\n", "      `const root_item_out = {};`,\n\t      `out = root_item_out;`,\n\t      `moveProperties(root_item.value, root_item_out, []);`,\n\t      '}',\n\t      `}`,\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output for object groups', async ({ assert }) => {\n\t    const compiler = new Compiler({\n", "      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        bail: true,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        validations: [],\n\t        properties: [\n", "          {\n\t            type: 'literal',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            bail: true,\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            validations: [],\n\t          },\n\t        ],\n", "        groups: [\n\t          {\n\t            type: 'group',\n\t            conditions: [\n\t              {\n\t                conditionalFnRefId: 'ref://1',\n\t                schema: {\n\t                  type: 'sub_object',\n\t                  groups: [],\n\t                  properties: [\n", "                    {\n\t                      type: 'literal',\n\t                      allowNull: false,\n\t                      isOptional: false,\n\t                      bail: true,\n\t                      fieldName: 'username',\n\t                      propertyName: 'username',\n\t                      validations: [],\n\t                    },\n\t                  ],\n", "                },\n\t              },\n\t              {\n\t                conditionalFnRefId: 'ref://2',\n\t                schema: {\n\t                  type: 'sub_object',\n\t                  groups: [],\n\t                  properties: [\n\t                    {\n\t                      type: 'literal',\n", "                      allowNull: false,\n\t                      isOptional: false,\n\t                      bail: true,\n\t                      fieldName: 'email',\n\t                      propertyName: 'email',\n\t                      validations: [],\n\t                    },\n\t                  ],\n\t                },\n\t              },\n", "            ],\n\t          },\n\t        ],\n\t        allowUnknownProperties: false,\n\t      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n", "      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n", "      '});',\n\t      `ensureIsDefined(root_item);`,\n\t      `if (ensureIsObject(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n\t      `const root_item_out = {};`,\n\t      `out = root_item_out;`,\n\t      `const password_2 = defineValue(root_item.value['password'], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'password',`,\n", "      `  wildCardPath: 'password',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n\t      `ensureExists(password_2);`,\n\t      `if (password_2.isDefined && password_2.isValid) {`,\n\t      `  root_item_out['password'] = password_2.value;`,\n", "      `}`,\n\t      `if (refs['ref://1'](root_item.value, root_item)) {`,\n\t      `  const username_3 = defineValue(root_item.value['username'], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'username',`,\n\t      `  wildCardPath: 'username',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n", "      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n\t      `ensureExists(username_3);`,\n\t      `if (username_3.isDefined && username_3.isValid) {`,\n\t      `  root_item_out['username'] = username_3.value;`,\n\t      `}`,\n\t      `}`,\n\t      `else if (refs['ref://2'](root_item.value, root_item)) {`,\n\t      `  const email_4 = defineValue(root_item.value['email'], {`,\n", "      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'email',`,\n\t      `  wildCardPath: 'email',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n", "      `ensureExists(email_4);`,\n\t      `if (email_4.isDefined && email_4.isValid) {`,\n\t      `  root_item_out['email'] = email_4.value;`,\n\t      `}`,\n\t      `}`,\n\t      '}',\n\t      `}`,\n\t      'else if(root_item.value === null) {',\n\t      `  out = null;`,\n\t      '}',\n", "      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output for multiple object groups', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        allowNull: true,\n\t        isOptional: false,\n", "        bail: true,\n\t        fieldName: 'login',\n\t        propertyName: 'login',\n\t        validations: [],\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            bail: true,\n", "            fieldName: 'password',\n\t            propertyName: 'password',\n\t            validations: [],\n\t          },\n\t        ],\n\t        groups: [\n\t          {\n\t            type: 'group',\n\t            conditions: [\n\t              {\n", "                conditionalFnRefId: 'ref://1',\n\t                schema: {\n\t                  type: 'sub_object',\n\t                  groups: [],\n\t                  properties: [\n\t                    {\n\t                      type: 'literal',\n\t                      allowNull: false,\n\t                      isOptional: false,\n\t                      bail: true,\n", "                      fieldName: 'username',\n\t                      propertyName: 'username',\n\t                      validations: [],\n\t                    },\n\t                  ],\n\t                },\n\t              },\n\t              {\n\t                conditionalFnRefId: 'ref://2',\n\t                schema: {\n", "                  type: 'sub_object',\n\t                  groups: [],\n\t                  properties: [\n\t                    {\n\t                      type: 'literal',\n\t                      allowNull: false,\n\t                      isOptional: false,\n\t                      bail: true,\n\t                      fieldName: 'email',\n\t                      propertyName: 'email',\n", "                      validations: [],\n\t                    },\n\t                  ],\n\t                },\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'group',\n\t            conditions: [\n", "              {\n\t                conditionalFnRefId: 'ref://3',\n\t                schema: {\n\t                  type: 'sub_object',\n\t                  groups: [],\n\t                  properties: [\n\t                    {\n\t                      type: 'literal',\n\t                      allowNull: false,\n\t                      isOptional: false,\n", "                      bail: true,\n\t                      fieldName: 'oauth_token',\n\t                      propertyName: 'oauthToken',\n\t                      validations: [],\n\t                    },\n\t                  ],\n\t                },\n\t              },\n\t              {\n\t                conditionalFnRefId: 'ref://4',\n", "                schema: {\n\t                  type: 'sub_object',\n\t                  groups: [],\n\t                  properties: [\n\t                    {\n\t                      type: 'literal',\n\t                      allowNull: false,\n\t                      isOptional: false,\n\t                      bail: true,\n\t                      fieldName: 'secret_key',\n", "                      propertyName: 'secretKey',\n\t                      validations: [],\n\t                    },\n\t                  ],\n\t                },\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t        allowUnknownProperties: false,\n", "      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n", "      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureIsDefined(root_item);`,\n\t      `if (ensureIsObject(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n", "      `const root_item_out = {};`,\n\t      `out = root_item_out;`,\n\t      `const password_2 = defineValue(root_item.value['password'], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'password',`,\n\t      `  wildCardPath: 'password',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n", "      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n\t      `ensureExists(password_2);`,\n\t      `if (password_2.isDefined && password_2.isValid) {`,\n\t      `  root_item_out['password'] = password_2.value;`,\n\t      `}`,\n\t      `if (refs['ref://1'](root_item.value, root_item)) {`,\n\t      `  const username_3 = defineValue(root_item.value['username'], {`,\n\t      `  data: root,`,\n", "      `  meta: meta,`,\n\t      `  name: 'username',`,\n\t      `  wildCardPath: 'username',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n\t      `ensureExists(username_3);`,\n", "      `if (username_3.isDefined && username_3.isValid) {`,\n\t      `  root_item_out['username'] = username_3.value;`,\n\t      `}`,\n\t      `}`,\n\t      `else if (refs['ref://2'](root_item.value, root_item)) {`,\n\t      `  const email_4 = defineValue(root_item.value['email'], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'email',`,\n\t      `  wildCardPath: 'email',`,\n", "      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n\t      `ensureExists(email_4);`,\n\t      `if (email_4.isDefined && email_4.isValid) {`,\n\t      `  root_item_out['email'] = email_4.value;`,\n\t      `}`,\n", "      `}`,\n\t      `if (refs['ref://3'](root_item.value, root_item)) {`,\n\t      `  const oauthToken_5 = defineValue(root_item.value['oauth_token'], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'oauth_token',`,\n\t      `  wildCardPath: 'oauth_token',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n", "      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n\t      `ensureExists(oauthToken_5);`,\n\t      `if (oauthToken_5.isDefined && oauthToken_5.isValid) {`,\n\t      `  root_item_out['oauthToken'] = oauthToken_5.value;`,\n\t      `}`,\n\t      `}`,\n\t      `else if (refs['ref://4'](root_item.value, root_item)) {`,\n\t      `  const secretKey_6 = defineValue(root_item.value['secret_key'], {`,\n", "      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'secret_key',`,\n\t      `  wildCardPath: 'secret_key',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n", "      `ensureExists(secretKey_6);`,\n\t      `if (secretKey_6.isDefined && secretKey_6.isValid) {`,\n\t      `  root_item_out['secretKey'] = secretKey_6.value;`,\n\t      `}`,\n\t      `}`,\n\t      '}',\n\t      `}`,\n\t      'else if(root_item.value === null) {',\n\t      `  out = null;`,\n\t      '}',\n", "      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output for nested object groups', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        allowNull: true,\n\t        isOptional: false,\n", "        bail: true,\n\t        fieldName: 'login',\n\t        propertyName: 'login',\n\t        validations: [],\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            bail: true,\n", "            fieldName: 'password',\n\t            propertyName: 'password',\n\t            validations: [],\n\t          },\n\t        ],\n\t        groups: [\n\t          {\n\t            type: 'group',\n\t            conditions: [\n\t              {\n", "                conditionalFnRefId: 'ref://1',\n\t                schema: {\n\t                  type: 'sub_object',\n\t                  groups: [],\n\t                  properties: [\n\t                    {\n\t                      type: 'literal',\n\t                      allowNull: false,\n\t                      isOptional: false,\n\t                      bail: true,\n", "                      fieldName: 'username',\n\t                      propertyName: 'username',\n\t                      validations: [],\n\t                    },\n\t                  ],\n\t                },\n\t              },\n\t              {\n\t                conditionalFnRefId: 'ref://2',\n\t                schema: {\n", "                  type: 'sub_object',\n\t                  properties: [],\n\t                  groups: [\n\t                    {\n\t                      type: 'group',\n\t                      conditions: [\n\t                        {\n\t                          conditionalFnRefId: 'ref://3',\n\t                          schema: {\n\t                            type: 'sub_object',\n", "                            groups: [],\n\t                            properties: [\n\t                              {\n\t                                type: 'literal',\n\t                                allowNull: false,\n\t                                isOptional: false,\n\t                                bail: true,\n\t                                fieldName: 'hotmail',\n\t                                propertyName: 'hotmail',\n\t                                validations: [],\n", "                              },\n\t                            ],\n\t                          },\n\t                        },\n\t                        {\n\t                          conditionalFnRefId: 'ref://4',\n\t                          schema: {\n\t                            type: 'sub_object',\n\t                            groups: [],\n\t                            properties: [\n", "                              {\n\t                                type: 'literal',\n\t                                allowNull: false,\n\t                                isOptional: false,\n\t                                bail: true,\n\t                                fieldName: 'email',\n\t                                propertyName: 'email',\n\t                                validations: [],\n\t                              },\n\t                            ],\n", "                          },\n\t                        },\n\t                      ],\n\t                    },\n\t                  ],\n\t                },\n\t              },\n\t            ],\n\t          },\n\t        ],\n", "        allowUnknownProperties: false,\n\t      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n", "      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureIsDefined(root_item);`,\n\t      `if (ensureIsObject(root_item)) {`,\n", "      `if (root_item.isValid) {`,\n\t      `const root_item_out = {};`,\n\t      `out = root_item_out;`,\n\t      `const password_2 = defineValue(root_item.value['password'], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'password',`,\n\t      `  wildCardPath: 'password',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n", "      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n\t      `ensureExists(password_2);`,\n\t      `if (password_2.isDefined && password_2.isValid) {`,\n\t      `  root_item_out['password'] = password_2.value;`,\n\t      `}`,\n\t      `if (refs['ref://1'](root_item.value, root_item)) {`,\n\t      `  const username_3 = defineValue(root_item.value['username'], {`,\n", "      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'username',`,\n\t      `  wildCardPath: 'username',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n", "      `ensureExists(username_3);`,\n\t      `if (username_3.isDefined && username_3.isValid) {`,\n\t      `  root_item_out['username'] = username_3.value;`,\n\t      `}`,\n\t      `}`,\n\t      `else if (refs['ref://2'](root_item.value, root_item)) {`,\n\t      `if (refs['ref://3'](root_item.value, root_item)) {`,\n\t      `  const hotmail_4 = defineValue(root_item.value['hotmail'], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n", "      `  name: 'hotmail',`,\n\t      `  wildCardPath: 'hotmail',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n\t      `ensureExists(hotmail_4);`,\n\t      `if (hotmail_4.isDefined && hotmail_4.isValid) {`,\n", "      `  root_item_out['hotmail'] = hotmail_4.value;`,\n\t      `}`,\n\t      `}`,\n\t      `else if (refs['ref://4'](root_item.value, root_item)) {`,\n\t      `  const email_5 = defineValue(root_item.value['email'], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'email',`,\n\t      `  wildCardPath: 'email',`,\n\t      `  mutate: defineValue,`,\n", "      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n\t      `ensureExists(email_5);`,\n\t      `if (email_5.isDefined && email_5.isValid) {`,\n\t      `  root_item_out['email'] = email_5.value;`,\n\t      `}`,\n\t      `}`,\n", "      `}`,\n\t      '}',\n\t      `}`,\n\t      'else if(root_item.value === null) {',\n\t      `  out = null;`,\n\t      '}',\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('define else block for conditions', async ({ assert }) => {\n", "    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'object',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        bail: true,\n\t        fieldName: 'login',\n\t        propertyName: 'login',\n\t        validations: [],\n", "        properties: [\n\t          {\n\t            type: 'literal',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            bail: true,\n\t            fieldName: 'password',\n\t            propertyName: 'password',\n\t            validations: [],\n\t          },\n", "        ],\n\t        groups: [\n\t          {\n\t            type: 'group',\n\t            elseConditionalFnRefId: 'ref://10',\n\t            conditions: [\n\t              {\n\t                conditionalFnRefId: 'ref://1',\n\t                schema: {\n\t                  type: 'sub_object',\n", "                  groups: [],\n\t                  properties: [\n\t                    {\n\t                      type: 'literal',\n\t                      allowNull: false,\n\t                      isOptional: false,\n\t                      bail: true,\n\t                      fieldName: 'username',\n\t                      propertyName: 'username',\n\t                      validations: [],\n", "                    },\n\t                  ],\n\t                },\n\t              },\n\t              {\n\t                conditionalFnRefId: 'ref://2',\n\t                schema: {\n\t                  type: 'sub_object',\n\t                  groups: [],\n\t                  properties: [\n", "                    {\n\t                      type: 'literal',\n\t                      allowNull: false,\n\t                      isOptional: false,\n\t                      bail: true,\n\t                      fieldName: 'email',\n\t                      propertyName: 'email',\n\t                      validations: [],\n\t                    },\n\t                  ],\n", "                },\n\t              },\n\t            ],\n\t          },\n\t          {\n\t            type: 'group',\n\t            elseConditionalFnRefId: 'ref://11',\n\t            conditions: [\n\t              {\n\t                conditionalFnRefId: 'ref://3',\n", "                schema: {\n\t                  type: 'sub_object',\n\t                  groups: [],\n\t                  properties: [\n\t                    {\n\t                      type: 'literal',\n\t                      allowNull: false,\n\t                      isOptional: false,\n\t                      bail: true,\n\t                      fieldName: 'oauth_token',\n", "                      propertyName: 'oauthToken',\n\t                      validations: [],\n\t                    },\n\t                  ],\n\t                },\n\t              },\n\t              {\n\t                conditionalFnRefId: 'ref://4',\n\t                schema: {\n\t                  type: 'sub_object',\n", "                  groups: [],\n\t                  properties: [\n\t                    {\n\t                      type: 'literal',\n\t                      allowNull: false,\n\t                      isOptional: false,\n\t                      bail: true,\n\t                      fieldName: 'secret_key',\n\t                      propertyName: 'secretKey',\n\t                      validations: [],\n", "                    },\n\t                  ],\n\t                },\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t        allowUnknownProperties: false,\n\t      },\n\t    })\n", "    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n", "      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureIsDefined(root_item);`,\n\t      `if (ensureIsObject(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n\t      `const root_item_out = {};`,\n\t      `out = root_item_out;`,\n", "      `const password_2 = defineValue(root_item.value['password'], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'password',`,\n\t      `  wildCardPath: 'password',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n", "      `});`,\n\t      `ensureExists(password_2);`,\n\t      `if (password_2.isDefined && password_2.isValid) {`,\n\t      `  root_item_out['password'] = password_2.value;`,\n\t      `}`,\n\t      `if (refs['ref://1'](root_item.value, root_item)) {`,\n\t      `  const username_3 = defineValue(root_item.value['username'], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'username',`,\n", "      `  wildCardPath: 'username',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n\t      `ensureExists(username_3);`,\n\t      `if (username_3.isDefined && username_3.isValid) {`,\n\t      `  root_item_out['username'] = username_3.value;`,\n", "      `}`,\n\t      `}`,\n\t      `else if (refs['ref://2'](root_item.value, root_item)) {`,\n\t      `  const email_4 = defineValue(root_item.value['email'], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'email',`,\n\t      `  wildCardPath: 'email',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n", "      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n\t      `ensureExists(email_4);`,\n\t      `if (email_4.isDefined && email_4.isValid) {`,\n\t      `  root_item_out['email'] = email_4.value;`,\n\t      `}`,\n\t      `} else {`,\n\t      `refs['ref://10'](root_item.value, root_item);`,\n", "      `}`,\n\t      `if (refs['ref://3'](root_item.value, root_item)) {`,\n\t      `  const oauthToken_5 = defineValue(root_item.value['oauth_token'], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'oauth_token',`,\n\t      `  wildCardPath: 'oauth_token',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n", "      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n\t      `ensureExists(oauthToken_5);`,\n\t      `if (oauthToken_5.isDefined && oauthToken_5.isValid) {`,\n\t      `  root_item_out['oauthToken'] = oauthToken_5.value;`,\n\t      `}`,\n\t      `}`,\n\t      `else if (refs['ref://4'](root_item.value, root_item)) {`,\n\t      `  const secretKey_6 = defineValue(root_item.value['secret_key'], {`,\n", "      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'secret_key',`,\n\t      `  wildCardPath: 'secret_key',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n", "      `ensureExists(secretKey_6);`,\n\t      `if (secretKey_6.isDefined && secretKey_6.isValid) {`,\n\t      `  root_item_out['secretKey'] = secretKey_6.value;`,\n\t      `}`,\n\t      `} else {`,\n\t      `refs['ref://11'](root_item.value, root_item);`,\n\t      `}`,\n\t      '}',\n\t      `}`,\n\t      'else if(root_item.value === null) {',\n", "      `  out = null;`,\n\t      '}',\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/nodes/record.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { Compiler } from '../../../src/compiler/main.js'\n", "import { validateCode } from '../../../factories/code_validator.js'\n\timport { getClosingOutput, getInitialOutput } from '../../../factories/output.js'\n\ttest.group('Record node', () => {\n\t  test('create JS output for record node', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        allowNull: false,\n\t        isOptional: false,\n", "        bail: true,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        validations: [\n\t          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://2',\n\t          },\n\t        ],\n", "        each: {\n\t          type: 'literal',\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n\t          bail: false,\n\t          validations: [],\n\t        },\n\t      },\n", "    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n", "      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureExists(root_item);`,\n\t      `if (ensureIsObject(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n\t      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n", "      `}`,\n\t      `if (root_item.isValid) {`,\n\t      `const root_item_out = {};`,\n\t      `out = root_item_out;`,\n\t      `const root_item_keys = Object.keys(root_item.value);`,\n\t      `const root_item_keys_size = root_item_keys.length;`,\n\t      `for (let root_item_key_i = 0; root_item_key_i < root_item_keys_size; root_item_key_i++) {`,\n\t      `const root_item_i = root_item_keys[root_item_key_i];`,\n\t      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n\t      `  data: root,`,\n", "      `  meta: meta,`,\n\t      `  name: root_item_i,`,\n\t      `  wildCardPath: '*',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureExists(root_item_item);`,\n", "      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n\t      `  root_item_out[root_item_i] = root_item_item.value;`,\n\t      `}`,\n\t      `}`,\n\t      `}`,\n\t      `}`,\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output for nullable record node', async ({ assert }) => {\n", "    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        bail: true,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        validations: [\n", "          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://2',\n\t          },\n\t        ],\n\t        each: {\n\t          type: 'literal',\n\t          fieldName: '*',\n\t          propertyName: '*',\n", "          allowNull: false,\n\t          isOptional: false,\n\t          bail: false,\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n", "      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n", "      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureIsDefined(root_item);`,\n\t      `if (ensureIsObject(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n\t      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n\t      `}`,\n\t      `if (root_item.isValid) {`,\n\t      `const root_item_out = {};`,\n\t      `out = root_item_out;`,\n", "      `const root_item_keys = Object.keys(root_item.value);`,\n\t      `const root_item_keys_size = root_item_keys.length;`,\n\t      `for (let root_item_key_i = 0; root_item_key_i < root_item_keys_size; root_item_key_i++) {`,\n\t      `const root_item_i = root_item_keys[root_item_key_i];`,\n\t      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: root_item_i,`,\n\t      `  wildCardPath: '*',`,\n\t      `  mutate: defineValue,`,\n", "      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureExists(root_item_item);`,\n\t      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n\t      `  root_item_out[root_item_i] = root_item_item.value;`,\n\t      `}`,\n\t      `}`,\n", "      `}`,\n\t      `}`,\n\t      `else if(root_item.value === null) {`,\n\t      `  out = null;`,\n\t      `}`,\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output without record validations', async ({ assert }) => {\n\t    const compiler = new Compiler({\n", "      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        bail: true,\n\t        fieldName: 'colors',\n\t        propertyName: 'colorPalette',\n\t        validations: [],\n\t        each: {\n", "          type: 'literal',\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n\t          bail: false,\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n", "    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n", "      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureIsDefined(root_item);`,\n\t      `if (ensureIsObject(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n\t      `const root_item_out = {};`,\n\t      `out = root_item_out;`,\n", "      `const root_item_keys = Object.keys(root_item.value);`,\n\t      `const root_item_keys_size = root_item_keys.length;`,\n\t      `for (let root_item_key_i = 0; root_item_key_i < root_item_keys_size; root_item_key_i++) {`,\n\t      `const root_item_i = root_item_keys[root_item_key_i];`,\n\t      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: root_item_i,`,\n\t      `  wildCardPath: '*',`,\n\t      `  mutate: defineValue,`,\n", "      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureExists(root_item_item);`,\n\t      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n\t      `  root_item_out[root_item_i] = root_item_item.value;`,\n\t      `}`,\n\t      `}`,\n", "      `}`,\n\t      `}`,\n\t      `else if(root_item.value === null) {`,\n\t      `  out = null;`,\n\t      `}`,\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output with record children validations', async ({ assert }) => {\n\t    const compiler = new Compiler({\n", "      type: 'root',\n\t      schema: {\n\t        type: 'record',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        bail: true,\n\t        fieldName: 'colors',\n\t        propertyName: 'colorPalette',\n\t        validations: [],\n\t        each: {\n", "          type: 'literal',\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n\t          bail: false,\n\t          validations: [\n\t            {\n\t              implicit: false,\n\t              isAsync: false,\n", "              ruleFnId: 'ref://2',\n\t            },\n\t          ],\n\t        },\n\t      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n", "      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n", "      '});',\n\t      `ensureIsDefined(root_item);`,\n\t      `if (ensureIsObject(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n\t      `const root_item_out = {};`,\n\t      `out = root_item_out;`,\n\t      `const root_item_keys = Object.keys(root_item.value);`,\n\t      `const root_item_keys_size = root_item_keys.length;`,\n\t      `for (let root_item_key_i = 0; root_item_key_i < root_item_keys_size; root_item_key_i++) {`,\n\t      `const root_item_i = root_item_keys[root_item_key_i];`,\n", "      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: root_item_i,`,\n\t      `  wildCardPath: '*',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n", "      '});',\n\t      `ensureExists(root_item_item);`,\n\t      `if (root_item_item.isDefined) {`,\n\t      `  refs['ref://2'].validator(root_item_item.value, refs['ref://2'].options, root_item_item);`,\n\t      `}`,\n\t      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n\t      `  root_item_out[root_item_i] = root_item_item.value;`,\n\t      `}`,\n\t      `}`,\n\t      `}`,\n", "      `}`,\n\t      `else if(root_item.value === null) {`,\n\t      `  out = null;`,\n\t      `}`,\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output for record node with bail mode disabled', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'record',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        bail: false,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        validations: [\n\t          {\n\t            implicit: false,\n", "            isAsync: false,\n\t            ruleFnId: 'ref://2',\n\t          },\n\t        ],\n\t        each: {\n\t          type: 'literal',\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n", "          bail: false,\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n", "      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n", "      `ensureIsDefined(root_item);`,\n\t      `if (ensureIsObject(root_item)) {`,\n\t      `refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n\t      `const root_item_out = {};`,\n\t      `out = root_item_out;`,\n\t      `const root_item_keys = Object.keys(root_item.value);`,\n\t      `const root_item_keys_size = root_item_keys.length;`,\n\t      `for (let root_item_key_i = 0; root_item_key_i < root_item_keys_size; root_item_key_i++) {`,\n\t      `const root_item_i = root_item_keys[root_item_key_i];`,\n\t      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n", "      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: root_item_i,`,\n\t      `  wildCardPath: '*',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n", "      `ensureExists(root_item_item);`,\n\t      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n\t      `  root_item_out[root_item_i] = root_item_item.value;`,\n\t      `}`,\n\t      `}`,\n\t      `}`,\n\t      `else if(root_item.value === null) {`,\n\t      `  out = null;`,\n\t      `}`,\n\t      ...getClosingOutput(),\n", "    ])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/nodes/tuple.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { Compiler } from '../../../src/compiler/main.js'\n", "import { validateCode } from '../../../factories/code_validator.js'\n\timport { getClosingOutput, getInitialOutput } from '../../../factories/output.js'\n\ttest.group('Tuple node', () => {\n\t  test('create JS output for tuple node', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        allowNull: false,\n\t        isOptional: false,\n", "        bail: true,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        allowUnknownProperties: false,\n\t        validations: [\n\t          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://2',\n\t          },\n", "        ],\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: '0',\n\t            propertyName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            bail: false,\n\t            validations: [],\n", "          },\n\t        ],\n\t      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n", "      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureExists(root_item);`,\n", "      `if (ensureIsArray(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n\t      `refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n\t      `}`,\n\t      `if (root_item.isValid) {`,\n\t      `const root_item_out = [];`,\n\t      `out = root_item_out;`,\n\t      `const root_item_item_0 = defineValue(root_item.value[0], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n", "      `  name: 0,`,\n\t      `  wildCardPath: '0',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: true,`,\n\t      '});',\n\t      `ensureExists(root_item_item_0);`,\n\t      `if (root_item_item_0.isDefined && root_item_item_0.isValid) {`,\n", "      `root_item_out[0] = root_item_item_0.value;`,\n\t      `}`,\n\t      `}`,\n\t      `}`,\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output for nullable tuple node', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'tuple',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        bail: true,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        properties: [\n", "          {\n\t            type: 'literal',\n\t            fieldName: '0',\n\t            propertyName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            bail: false,\n\t            validations: [],\n\t          },\n\t        ],\n", "      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n", "      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureIsDefined(root_item);`,\n\t      `if (ensureIsArray(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n", "      `const root_item_out = [];`,\n\t      `out = root_item_out;`,\n\t      `const root_item_item_0 = defineValue(root_item.value[0], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 0,`,\n\t      `  wildCardPath: '0',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n", "      `  parent: root_item.value,`,\n\t      `  isArrayMember: true,`,\n\t      '});',\n\t      `ensureExists(root_item_item_0);`,\n\t      `if (root_item_item_0.isDefined && root_item_item_0.isValid) {`,\n\t      `root_item_out[0] = root_item_item_0.value;`,\n\t      `}`,\n\t      `}`,\n\t      `} else if (root_item.value === null) {`,\n\t      `  out = null;`,\n", "      `}`,\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output for tuple node when unknownProperties are allowed', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        allowNull: true,\n", "        isOptional: false,\n\t        bail: true,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        allowUnknownProperties: true,\n\t        validations: [],\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: '0',\n", "            propertyName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            bail: false,\n\t            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n", "    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n", "      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureIsDefined(root_item);`,\n\t      `if (ensureIsArray(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n\t      `const root_item_out = copyProperties(root_item.value);`,\n\t      `out = root_item_out;`,\n\t      `const root_item_item_0 = defineValue(root_item.value[0], {`,\n", "      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 0,`,\n\t      `  wildCardPath: '0',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: true,`,\n\t      '});',\n", "      `ensureExists(root_item_item_0);`,\n\t      `if (root_item_item_0.isDefined && root_item_item_0.isValid) {`,\n\t      `root_item_out[0] = root_item_item_0.value;`,\n\t      `}`,\n\t      `}`,\n\t      `} else if (root_item.value === null) {`,\n\t      `  out = null;`,\n\t      `}`,\n\t      ...getClosingOutput(),\n\t    ])\n", "  })\n\t  test('create JS output for tuple node without array validations', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'tuple',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        bail: true,\n\t        fieldName: '*',\n", "        propertyName: '*',\n\t        allowUnknownProperties: false,\n\t        validations: [],\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: '0',\n\t            propertyName: '0',\n\t            allowNull: false,\n\t            isOptional: false,\n", "            bail: false,\n\t            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n", "      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n", "      '});',\n\t      `ensureExists(root_item);`,\n\t      `if (ensureIsArray(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n\t      `const root_item_out = [];`,\n\t      `out = root_item_out;`,\n\t      `const root_item_item_0 = defineValue(root_item.value[0], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 0,`,\n", "      `  wildCardPath: '0',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: true,`,\n\t      '});',\n\t      `ensureExists(root_item_item_0);`,\n\t      `if (root_item_item_0.isDefined && root_item_item_0.isValid) {`,\n\t      `root_item_out[0] = root_item_item_0.value;`,\n", "      `}`,\n\t      `}`,\n\t      `}`,\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output for tuple node with bail mode disabled', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n", "        type: 'tuple',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        bail: false,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        allowUnknownProperties: false,\n\t        validations: [\n\t          {\n\t            implicit: false,\n", "            isAsync: false,\n\t            ruleFnId: 'ref://2',\n\t          },\n\t        ],\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            fieldName: '0',\n\t            propertyName: '0',\n\t            allowNull: false,\n", "            isOptional: false,\n\t            bail: false,\n\t            validations: [],\n\t          },\n\t        ],\n\t      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n", "      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n", "      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureExists(root_item);`,\n\t      `if (ensureIsArray(root_item)) {`,\n\t      `refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n\t      `const root_item_out = [];`,\n\t      `out = root_item_out;`,\n\t      `const root_item_item_0 = defineValue(root_item.value[0], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n", "      `  name: 0,`,\n\t      `  wildCardPath: '0',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: true,`,\n\t      '});',\n\t      `ensureExists(root_item_item_0);`,\n\t      `if (root_item_item_0.isDefined && root_item_item_0.isValid) {`,\n", "      `root_item_out[0] = root_item_item_0.value;`,\n\t      `}`,\n\t      `}`,\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/nodes/array.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { Compiler } from '../../../src/compiler/main.js'\n", "import { validateCode } from '../../../factories/code_validator.js'\n\timport { getClosingOutput, getInitialOutput } from '../../../factories/output.js'\n\ttest.group('Array node', () => {\n\t  test('create JS output for array node', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        allowNull: false,\n\t        isOptional: false,\n", "        bail: true,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        validations: [\n\t          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://2',\n\t          },\n\t        ],\n", "        each: {\n\t          type: 'literal',\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n\t          bail: false,\n\t          validations: [],\n\t        },\n\t      },\n", "    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n", "      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureExists(root_item);`,\n\t      `if (ensureIsArray(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n\t      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n", "      `}`,\n\t      `if (root_item.isValid) {`,\n\t      `const root_item_out = [];`,\n\t      `out = root_item_out;`,\n\t      `const root_item_items_size = root_item.value.length;`,\n\t      `for (let root_item_i = 0; root_item_i < root_item_items_size; root_item_i++) {`,\n\t      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: root_item_i,`,\n", "      `  wildCardPath: '*',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: true,`,\n\t      '});',\n\t      `ensureExists(root_item_item);`,\n\t      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n\t      `  root_item_out[root_item_i] = root_item_item.value;`,\n", "      `}`,\n\t      `}`,\n\t      `}`,\n\t      `}`,\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output for nullable array node', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n", "      schema: {\n\t        type: 'array',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        bail: true,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        validations: [\n\t          {\n\t            implicit: false,\n", "            isAsync: false,\n\t            ruleFnId: 'ref://2',\n\t          },\n\t        ],\n\t        each: {\n\t          type: 'literal',\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n", "          bail: false,\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n", "      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n", "      `ensureIsDefined(root_item);`,\n\t      `if (ensureIsArray(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n\t      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n\t      `}`,\n\t      `if (root_item.isValid) {`,\n\t      `const root_item_out = [];`,\n\t      `out = root_item_out;`,\n\t      `const root_item_items_size = root_item.value.length;`,\n\t      `for (let root_item_i = 0; root_item_i < root_item_items_size; root_item_i++) {`,\n", "      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: root_item_i,`,\n\t      `  wildCardPath: '*',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: true,`,\n", "      '});',\n\t      `ensureExists(root_item_item);`,\n\t      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n\t      `  root_item_out[root_item_i] = root_item_item.value;`,\n\t      `}`,\n\t      `}`,\n\t      `}`,\n\t      `} else if (root_item.value === null) {`,\n\t      `  out = null;`,\n\t      `}`,\n", "      ...getClosingOutput(),\n\t    ])\n\t  })\n\t  test('create JS output without array validations', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        allowNull: true,\n\t        isOptional: false,\n", "        bail: true,\n\t        fieldName: '*',\n\t        propertyName: '*',\n\t        validations: [],\n\t        each: {\n\t          type: 'literal',\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n", "          bail: false,\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n", "      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n", "      `ensureIsDefined(root_item);`,\n\t      `if (ensureIsArray(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n\t      `const root_item_out = [];`,\n\t      `out = root_item_out;`,\n\t      `const root_item_items_size = root_item.value.length;`,\n\t      `for (let root_item_i = 0; root_item_i < root_item_items_size; root_item_i++) {`,\n\t      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n", "      `  name: root_item_i,`,\n\t      `  wildCardPath: '*',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: true,`,\n\t      '});',\n\t      `ensureExists(root_item_item);`,\n\t      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n", "      `  root_item_out[root_item_i] = root_item_item.value;`,\n\t      `}`,\n\t      `}`,\n\t      `}`,\n\t      `} else if (root_item.value === null) {`,\n\t      `  out = null;`,\n\t      `}`,\n\t      ...getClosingOutput(),\n\t    ])\n\t  })\n", "  test('create JS output for array with bail mode disabled', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        allowNull: true,\n\t        isOptional: false,\n\t        bail: false,\n\t        fieldName: '*',\n\t        propertyName: '*',\n", "        validations: [\n\t          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://2',\n\t          },\n\t        ],\n\t        each: {\n\t          type: 'literal',\n\t          fieldName: '*',\n", "          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n\t          bail: false,\n\t          validations: [],\n\t        },\n\t      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n", "    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n\t      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n", "      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureIsDefined(root_item);`,\n\t      `if (ensureIsArray(root_item)) {`,\n\t      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n\t      `const root_item_out = [];`,\n\t      `out = root_item_out;`,\n\t      `const root_item_items_size = root_item.value.length;`,\n\t      `for (let root_item_i = 0; root_item_i < root_item_items_size; root_item_i++) {`,\n", "      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: root_item_i,`,\n\t      `  wildCardPath: '*',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: true,`,\n", "      '});',\n\t      `ensureExists(root_item_item);`,\n\t      `if (root_item_item.isDefined && root_item_item.isValid) {`,\n\t      `  root_item_out[root_item_i] = root_item_item.value;`,\n\t      `}`,\n\t      `}`,\n\t      `} else if (root_item.value === null) {`,\n\t      `  out = null;`,\n\t      `}`,\n\t      ...getClosingOutput(),\n", "    ])\n\t  })\n\t  test('compute wildcard path to nested arrays', async ({ assert }) => {\n\t    const compiler = new Compiler({\n\t      type: 'root',\n\t      schema: {\n\t        type: 'array',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        bail: true,\n", "        fieldName: '*',\n\t        propertyName: '*',\n\t        validations: [\n\t          {\n\t            implicit: false,\n\t            isAsync: false,\n\t            ruleFnId: 'ref://2',\n\t          },\n\t        ],\n\t        each: {\n", "          type: 'object',\n\t          fieldName: '*',\n\t          propertyName: '*',\n\t          allowNull: false,\n\t          isOptional: false,\n\t          bail: false,\n\t          validations: [],\n\t          groups: [],\n\t          allowUnknownProperties: false,\n\t          properties: [\n", "            {\n\t              type: 'array',\n\t              fieldName: 'contacts',\n\t              propertyName: 'contacts',\n\t              allowNull: false,\n\t              isOptional: false,\n\t              bail: false,\n\t              each: {\n\t                type: 'literal',\n\t                fieldName: '*',\n", "                propertyName: '*',\n\t                allowNull: false,\n\t                isOptional: false,\n\t                bail: false,\n\t                validations: [],\n\t              },\n\t              validations: [],\n\t            },\n\t          ],\n\t        },\n", "      },\n\t    })\n\t    const compiledOutput = compiler.compile().toString()\n\t    validateCode(compiledOutput)\n\t    assert.assertFormatted(compiledOutput, [\n\t      ...getInitialOutput(),\n\t      `const root_item = defineValue(root, {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: '',`,\n", "      `  wildCardPath: '',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t      `ensureExists(root_item);`,\n\t      `if (ensureIsArray(root_item)) {`,\n\t      `if (root_item.isValid) {`,\n", "      `  refs['ref://2'].validator(root_item.value, refs['ref://2'].options, root_item);`,\n\t      `}`,\n\t      `if (root_item.isValid) {`,\n\t      `const root_item_out = [];`,\n\t      `out = root_item_out;`,\n\t      `const root_item_items_size = root_item.value.length;`,\n\t      `for (let root_item_i = 0; root_item_i < root_item_items_size; root_item_i++) {`,\n\t      `const root_item_item = defineValue(root_item.value[root_item_i], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n", "      `  name: root_item_i,`,\n\t      `  wildCardPath: '*',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: root_item.value,`,\n\t      `  isArrayMember: true,`,\n\t      '});',\n\t      `ensureExists(root_item_item);`,\n\t      `if (ensureIsObject(root_item_item)) {`,\n", "      `const root_item_item_out = {};`,\n\t      `root_item_out[root_item_i] = root_item_item_out;`,\n\t      `const contacts_3 = defineValue(root_item_item.value['contacts'], {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'contacts',`,\n\t      `  wildCardPath: '*.contacts',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n", "      `  parent: root_item_item.value,`,\n\t      `  isArrayMember: false,`,\n\t      `});`,\n\t      `ensureExists(contacts_3);`,\n\t      `if (ensureIsArray(contacts_3)) {`,\n\t      `const contacts_3_out = [];`,\n\t      `root_item_item_out['contacts'] = contacts_3_out;`,\n\t      `const contacts_3_items_size = contacts_3.value.length;`,\n\t      `for (let contacts_3_i = 0; contacts_3_i < contacts_3_items_size; contacts_3_i++) {`,\n\t      `const contacts_3_item = defineValue(contacts_3.value[contacts_3_i], {`,\n", "      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: contacts_3_i,`,\n\t      `  wildCardPath: '*.contacts.*',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n\t      `  parent: contacts_3.value,`,\n\t      `  isArrayMember: true,`,\n\t      `});`,\n", "      `ensureExists(contacts_3_item);`,\n\t      `if (contacts_3_item.isDefined && contacts_3_item.isValid) {`,\n\t      `contacts_3_out[contacts_3_i]  = contacts_3_item.value;`,\n\t      `}`,\n\t      `}`,\n\t      `}`,\n\t      `}`,\n\t      `}`,\n\t      `}`,\n\t      `}`,\n", "      ...getClosingOutput(),\n\t    ])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/scripts/object/guard.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { validateCode } from '../../../../factories/code_validator.js'\n", "import { defineObjectGuard } from '../../../../src/scripts/object/guard.js'\n\ttest.group('Scripts | define object guard', () => {\n\t  test('wrap code inside object guard conditional', ({ assert }) => {\n\t    const jsOutput = defineObjectGuard({\n\t      variableName: 'profile',\n\t      guardedCodeSnippet: 'console.log(profile)',\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `if (ensureIsObject(profile)) {`,\n", "      `console.log(profile)`,\n\t      `}`,\n\t    ])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/scripts/object/initial_output.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { validateCode } from '../../../../factories/code_validator.js'\n", "import { defineObjectInitialOutput } from '../../../../src/scripts/object/initial_output.js'\n\ttest.group('Scripts | define object initial output', () => {\n\t  test('define initial object for object', ({ assert }) => {\n\t    const jsOutput = defineObjectInitialOutput({\n\t      outputExpression: `out['profile']`,\n\t      variableName: 'profile',\n\t      outputValueExpression: `{}`,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [`const profile_out = {};`, `out['profile'] = profile_out;`])\n", "  })\n\t})\n"]}
{"filename": "tests/unit/scripts/union/call_parse.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { validateCode } from '../../../../factories/code_validator.js'\n", "import { callParseFunction } from '../../../../src/scripts/union/parse.js'\n\ttest.group('Scripts | call parse function', () => {\n\t  test('get snippet to mutate the field value', ({ assert }) => {\n\t    const jsOutput = callParseFunction({\n\t      variableName: 'colors',\n\t      parseFnRefId: 'ref://1',\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [`colors.value = refs['ref://1'](colors.value);`])\n\t  })\n", "  test('return empty string when parseFnRefId is not defined', ({ assert }) => {\n\t    const jsOutput = callParseFunction({\n\t      variableName: 'colors',\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [''])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/scripts/record/loop.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { validateCode } from '../../../../factories/code_validator.js'\n", "import { defineRecordLoop } from '../../../../src/scripts/record/loop.js'\n\ttest.group('Scripts | define record loop', () => {\n\t  test('wrap code inside record loop', ({ assert }) => {\n\t    const jsOutput = defineRecordLoop({\n\t      variableName: 'colors',\n\t      loopCodeSnippet: 'console.log(colors_i)',\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `const colors_keys = Object.keys(colors.value);`,\n", "      `const colors_keys_size = colors_keys.length;`,\n\t      `for (let colors_key_i = 0; colors_key_i < colors_keys_size; colors_key_i++) {`,\n\t      `const colors_i = colors_keys[colors_key_i];`,\n\t      `console.log(colors_i)`,\n\t      `}`,\n\t    ])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/scripts/array/guard.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { validateCode } from '../../../../factories/code_validator.js'\n", "import { defineArrayGuard } from '../../../../src/scripts/array/guard.js'\n\ttest.group('Scripts | define array guard', () => {\n\t  test('wrap code inside array guard conditional', ({ assert }) => {\n\t    const jsOutput = defineArrayGuard({\n\t      variableName: 'contacts',\n\t      guardedCodeSnippet: 'console.log(contacts)',\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `if (ensureIsArray(contacts)) {`,\n", "      `console.log(contacts)`,\n\t      `}`,\n\t    ])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/scripts/array/loop.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { validateCode } from '../../../../factories/code_validator.js'\n", "import { defineArrayLoop } from '../../../../src/scripts/array/loop.js'\n\ttest.group('Scripts | define array loop', () => {\n\t  test('wrap code inside array loop', ({ assert }) => {\n\t    const jsOutput = defineArrayLoop({\n\t      variableName: 'contacts',\n\t      loopCodeSnippet: 'console.log(contacts_i)',\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `const contacts_items_size = contacts.value.length;`,\n", "      `for (let contacts_i = 0; contacts_i < contacts_items_size; contacts_i++) {`,\n\t      `console.log(contacts_i)`,\n\t      `}`,\n\t    ])\n\t  })\n\t  test('wrap code inside array loop with a custom starting index', ({ assert }) => {\n\t    const jsOutput = defineArrayLoop({\n\t      variableName: 'contacts',\n\t      startingIndex: 3,\n\t      loopCodeSnippet: 'console.log(contacts_i)',\n", "    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `const contacts_items_size = contacts.value.length;`,\n\t      `for (let contacts_i = 3; contacts_i < contacts_items_size; contacts_i++) {`,\n\t      `console.log(contacts_i)`,\n\t      `}`,\n\t    ])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/scripts/array/initial_output.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { validateCode } from '../../../../factories/code_validator.js'\n", "import { defineArrayInitialOutput } from '../../../../src/scripts/array/initial_output.js'\n\ttest.group('Scripts | define array initial output', () => {\n\t  test('define initial output for array', ({ assert }) => {\n\t    const jsOutput = defineArrayInitialOutput({\n\t      outputExpression: `out['contacts']`,\n\t      variableName: 'root_item',\n\t      outputValueExpression: `[]`,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n", "      `const root_item_out = [];`,\n\t      `out['contacts'] = root_item_out;`,\n\t    ])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/scripts/field/existence_validation.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { validateCode } from '../../../../factories/code_validator.js'\n", "import { defineFieldExistenceValidations } from '../../../../src/scripts/field/existence_validations.js'\n\ttest.group('Scripts | define field existence valitions', () => {\n\t  test('get JS output for field existence validations', ({ assert }) => {\n\t    const jsOutput = defineFieldExistenceValidations({\n\t      variableName: 'username',\n\t      isOptional: false,\n\t      allowNull: false,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [`ensureExists(username);`])\n", "  })\n\t  test('get JS output for optional field', ({ assert }) => {\n\t    const jsOutput = defineFieldExistenceValidations({\n\t      variableName: 'username',\n\t      isOptional: true,\n\t      allowNull: false,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [''])\n\t  })\n", "  test('get JS output for nullable field', ({ assert }) => {\n\t    const jsOutput = defineFieldExistenceValidations({\n\t      variableName: 'username',\n\t      isOptional: false,\n\t      allowNull: true,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, ['ensureIsDefined(username);'])\n\t  })\n\t  test('get JS output for optional and nullable field', ({ assert }) => {\n", "    const jsOutput = defineFieldExistenceValidations({\n\t      variableName: 'username',\n\t      isOptional: true,\n\t      allowNull: true,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [''])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/scripts/field/null_output.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { EOL } from 'node:os'\n\timport { test } from '@japa/runner'\n", "import { validateCode } from '../../../../factories/code_validator.js'\n\timport { defineFieldNullOutput } from '../../../../src/scripts/field/null_output.js'\n\ttest.group('Scripts | define field null output', () => {\n\t  test('get JS output for writing null output value', ({ assert }) => {\n\t    const jsOutput = defineFieldNullOutput({\n\t      variableName: 'username',\n\t      allowNull: true,\n\t      outputExpression: `out['username']`,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n", "    assert.assertFormatted(jsOutput, [\n\t      `if(username.value === null) {`,\n\t      `  out['username'] = null;`,\n\t      `}`,\n\t    ])\n\t  })\n\t  test('get JS output when allowNull is disabled', ({ assert }) => {\n\t    const jsOutput = defineFieldNullOutput({\n\t      variableName: 'username',\n\t      allowNull: false,\n", "      outputExpression: `out['username']`,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput.split(EOL), [``])\n\t  })\n\t  test('transform null value using transform ref id', ({ assert }) => {\n\t    const jsOutput = defineFieldNullOutput({\n\t      variableName: 'username',\n\t      allowNull: true,\n\t      transformFnRefId: 'ref://1',\n", "      outputExpression: `out['username']`,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `if(username.value === null) {`,\n\t      `out['username'] = refs['ref://1'](null, username);`,\n\t      `}`,\n\t    ])\n\t  })\n\t  test('generate else if conditional', ({ assert }) => {\n", "    const jsOutput = `if (foo) {} ${defineFieldNullOutput({\n\t      variableName: 'username',\n\t      allowNull: true,\n\t      transformFnRefId: 'ref://1',\n\t      conditional: 'else if',\n\t      outputExpression: `out['username']`,\n\t    })}`\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `if (foo) {} else if(username.value === null) {`,\n", "      `out['username'] = refs['ref://1'](null, username);`,\n\t      `}`,\n\t    ])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/scripts/field/variables.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { validateCode } from '../../../../factories/code_validator.js'\n", "import { defineFieldVariables } from '../../../../src/scripts/field/variables.js'\n\ttest.group('Scripts | define field variables', () => {\n\t  test('get JS output for field variables', ({ assert }) => {\n\t    const jsOutput = defineFieldVariables({\n\t      variableName: 'username',\n\t      valueExpression: `root['username']`,\n\t      fieldNameExpression: `'username'`,\n\t      parentValueExpression: 'root',\n\t      wildCardPath: 'username',\n\t      isArrayMember: false,\n", "    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `const username = defineValue(root['username'], {`,\n\t      `data: root,`,\n\t      `meta: meta,`,\n\t      `name: 'username',`,\n\t      `wildCardPath: 'username',`,\n\t      `mutate: defineValue,`,\n\t      `report: report,`,\n", "      `isValid: true,`,\n\t      `parent: root,`,\n\t      `isArrayMember: false,`,\n\t      '});',\n\t    ])\n\t  })\n\t  test('get JS output with parse function', ({ assert }) => {\n\t    const jsOutput = defineFieldVariables({\n\t      variableName: 'username',\n\t      valueExpression: `root['username']`,\n", "      fieldNameExpression: `'username'`,\n\t      parentValueExpression: 'root',\n\t      wildCardPath: 'username',\n\t      isArrayMember: false,\n\t      parseFnRefId: 'ref://1',\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `const username = defineValue(refs['ref://1'](root['username'], {`,\n\t      `  data: root,`,\n", "      `  meta: meta,`,\n\t      `  parent: root`,\n\t      `}), {`,\n\t      `  data: root,`,\n\t      `  meta: meta,`,\n\t      `  name: 'username',`,\n\t      `  wildCardPath: 'username',`,\n\t      `  mutate: defineValue,`,\n\t      `  report: report,`,\n\t      `  isValid: true,`,\n", "      `  parent: root,`,\n\t      `  isArrayMember: false,`,\n\t      '});',\n\t    ])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/scripts/field/validations.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { validateCode } from '../../../../factories/code_validator.js'\n", "import { defineFieldValidations } from '../../../../src/scripts/field/validations.js'\n\ttest.group('Scripts | define field validations', () => {\n\t  test('get JS output for validations', ({ assert }) => {\n\t    const jsOutput = defineFieldValidations({\n\t      variableName: 'username',\n\t      dropMissingCheck: false,\n\t      validations: [\n\t        {\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n", "          implicit: false,\n\t        },\n\t      ],\n\t      bail: true,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `if (username.isValid && username.isDefined) {`,\n\t      `refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n\t      `}`,\n", "    ])\n\t  })\n\t  test('get JS output with bail disabled', ({ assert }) => {\n\t    const jsOutput = defineFieldValidations({\n\t      variableName: 'username',\n\t      dropMissingCheck: false,\n\t      validations: [\n\t        {\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n", "          implicit: false,\n\t        },\n\t      ],\n\t      bail: false,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `if (username.isDefined) {`,\n\t      `  refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n\t      `}`,\n", "    ])\n\t  })\n\t  test('get JS output for implict rule', ({ assert }) => {\n\t    const jsOutput = defineFieldValidations({\n\t      variableName: 'username',\n\t      dropMissingCheck: false,\n\t      validations: [\n\t        {\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n", "          implicit: true,\n\t        },\n\t      ],\n\t      bail: true,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `if (username.isValid) {`,\n\t      `  refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n\t      `}`,\n", "    ])\n\t  })\n\t  test('get JS output with bail disabled and for implict rule', ({ assert }) => {\n\t    const jsOutput = defineFieldValidations({\n\t      variableName: 'username',\n\t      dropMissingCheck: false,\n\t      validations: [\n\t        {\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n", "          implicit: true,\n\t        },\n\t      ],\n\t      bail: false,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n\t    ])\n\t  })\n", "  test('get JS output for multiple validations', ({ assert }) => {\n\t    const jsOutput = defineFieldValidations({\n\t      variableName: 'username',\n\t      dropMissingCheck: false,\n\t      validations: [\n\t        {\n\t          isAsync: false,\n\t          ruleFnId: 'ref://1',\n\t          implicit: false,\n\t        },\n", "        {\n\t          isAsync: false,\n\t          ruleFnId: 'ref://2',\n\t          implicit: false,\n\t        },\n\t      ],\n\t      bail: true,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n", "      `if (username.isValid && username.isDefined) {`,\n\t      `refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n\t      `}`,\n\t      `if (username.isValid && username.isDefined) {`,\n\t      `refs['ref://2'].validator(username.value, refs['ref://2'].options, username);`,\n\t      `}`,\n\t    ])\n\t  })\n\t})\n\ttest.group('Scripts | async | define field validations', () => {\n", "  test('get JS output for validations', ({ assert }) => {\n\t    const jsOutput = defineFieldValidations({\n\t      variableName: 'username',\n\t      dropMissingCheck: false,\n\t      validations: [\n\t        {\n\t          isAsync: true,\n\t          ruleFnId: 'ref://1',\n\t          implicit: false,\n\t        },\n", "      ],\n\t      bail: true,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `if (username.isValid && username.isDefined) {`,\n\t      `  await refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n\t      `}`,\n\t    ])\n\t  })\n", "  test('get JS output with bail disabled', ({ assert }) => {\n\t    const jsOutput = defineFieldValidations({\n\t      variableName: 'username',\n\t      dropMissingCheck: false,\n\t      validations: [\n\t        {\n\t          isAsync: true,\n\t          ruleFnId: 'ref://1',\n\t          implicit: false,\n\t        },\n", "      ],\n\t      bail: false,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `if (username.isDefined) {`,\n\t      ` await refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n\t      `}`,\n\t    ])\n\t  })\n", "  test('get JS output for implict rule', ({ assert }) => {\n\t    const jsOutput = defineFieldValidations({\n\t      variableName: 'username',\n\t      dropMissingCheck: false,\n\t      validations: [\n\t        {\n\t          isAsync: true,\n\t          ruleFnId: 'ref://1',\n\t          implicit: true,\n\t        },\n", "      ],\n\t      bail: true,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `if (username.isValid) {`,\n\t      `await refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n\t      `}`,\n\t    ])\n\t  })\n", "  test('get JS output with bail disabled and for implict rule', ({ assert }) => {\n\t    const jsOutput = defineFieldValidations({\n\t      variableName: 'username',\n\t      dropMissingCheck: false,\n\t      validations: [\n\t        {\n\t          isAsync: true,\n\t          ruleFnId: 'ref://1',\n\t          implicit: true,\n\t        },\n", "      ],\n\t      bail: false,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `await refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n\t    ])\n\t  })\n\t  test('get JS output for multiple validations', ({ assert }) => {\n\t    const jsOutput = defineFieldValidations({\n", "      variableName: 'username',\n\t      dropMissingCheck: false,\n\t      validations: [\n\t        {\n\t          isAsync: true,\n\t          ruleFnId: 'ref://1',\n\t          implicit: false,\n\t        },\n\t        {\n\t          isAsync: true,\n", "          ruleFnId: 'ref://2',\n\t          implicit: false,\n\t        },\n\t      ],\n\t      bail: true,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `if (username.isValid && username.isDefined) {`,\n\t      `  await refs['ref://1'].validator(username.value, refs['ref://1'].options, username);`,\n", "      `}`,\n\t      `if (username.isValid && username.isDefined) {`,\n\t      `  await refs['ref://2'].validator(username.value, refs['ref://2'].options, username);`,\n\t      `}`,\n\t    ])\n\t  })\n\t})\n"]}
{"filename": "tests/unit/scripts/field/value_output.spec.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { test } from '@japa/runner'\n\timport { validateCode } from '../../../../factories/code_validator.js'\n", "import { defineFieldValueOutput } from '../../../../src/scripts/field/value_output.js'\n\ttest.group('Scripts | define field value output', () => {\n\t  test('get JS output for writing output value', ({ assert }) => {\n\t    const jsOutput = defineFieldValueOutput({\n\t      variableName: 'username',\n\t      outputExpression: `out['username']`,\n\t    })\n\t    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `if (username.isDefined && username.isValid) {`,\n", "      `out['username'] = username.value;`,\n\t      `}`,\n\t    ])\n\t  })\n\t  test('get JS output for writing output value with transform function', ({ assert }) => {\n\t    const jsOutput = defineFieldValueOutput({\n\t      variableName: 'username',\n\t      transformFnRefId: 'ref://2',\n\t      outputExpression: `out['username']`,\n\t    })\n", "    assert.doesNotThrows(() => validateCode(jsOutput))\n\t    assert.assertFormatted(jsOutput, [\n\t      `if (username.isDefined && username.isValid) {`,\n\t      `out['username'] = refs['ref://2'](username.value, username);`,\n\t      `}`,\n\t    ])\n\t  })\n\t})\n"]}
{"filename": "benchmarks/nested_object.ts", "chunked_list": ["import { z } from 'zod'\n\t// @ts-ignore\n\timport Benchmark from 'benchmark'\n\timport Ajv, { AsyncValidateFunction } from 'ajv'\n\timport { Compiler } from '../src/compiler/main.js'\n\timport { ErrorReporterFactory } from '../factories/error_reporter.js'\n\timport { MessagesProviderFactory } from '../factories/messages_provider.js'\n\tconst suite = new Benchmark.Suite()\n\tconst data = { profile: { username: 'virk' } }\n\tconst meta = {}\n", "const refs = {\n\t  'ref://1': {\n\t    validator(value: unknown, _: any, field: any) {\n\t      if (typeof value !== 'string') {\n\t        field.report('Value is not a string')\n\t      }\n\t    },\n\t    options: {},\n\t  },\n\t}\n", "const messagesProvider = new MessagesProviderFactory().create()\n\tconst errorReporter = new ErrorReporterFactory().create()\n\tconst zodSchema = z.object({\n\t  profile: z.object({\n\t    username: z.string(),\n\t  }),\n\t})\n\tconst compiler = new Compiler({\n\t  type: 'root',\n\t  schema: {\n", "    type: 'object',\n\t    allowNull: false,\n\t    isOptional: false,\n\t    fieldName: '*',\n\t    allowUnknownProperties: false,\n\t    bail: true,\n\t    properties: [\n\t      {\n\t        type: 'object',\n\t        propertyName: 'profile',\n", "        allowNull: false,\n\t        allowUnknownProperties: false,\n\t        isOptional: false,\n\t        fieldName: 'profile',\n\t        bail: true,\n\t        groups: [],\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            bail: true,\n", "            allowNull: false,\n\t            fieldName: 'username',\n\t            propertyName: 'userName',\n\t            isOptional: false,\n\t            validations: [\n\t              {\n\t                isAsync: false,\n\t                ruleFnId: 'ref://1',\n\t                implicit: false,\n\t              },\n", "            ],\n\t          },\n\t        ],\n\t        validations: [],\n\t      },\n\t    ],\n\t    groups: [],\n\t    propertyName: '*',\n\t    validations: [],\n\t  },\n", "})\n\tcompiler.compile()\n\tconst fn = compiler.compile()\n\tconst ajv = new Ajv.default()\n\tconst ajvSchema = {\n\t  $async: true,\n\t  type: 'object',\n\t  properties: {\n\t    profile: {\n\t      type: 'object',\n", "      properties: {\n\t        username: { type: 'string' },\n\t      },\n\t      required: ['username'],\n\t    },\n\t  },\n\t  required: ['profile'],\n\t  additionalProperties: false,\n\t}\n\tconst ajvValidate = ajv.compile(ajvSchema) as AsyncValidateFunction<any>\n", "suite\n\t  .add('VineJS compiler', {\n\t    defer: true,\n\t    // benchmark test function\n\t    fn: function (deferred: any) {\n\t      fn(data, meta, refs, messagesProvider, errorReporter).then(() => deferred.resolve())\n\t    },\n\t  })\n\t  .add('Ajv', {\n\t    defer: true,\n", "    // benchmark test function\n\t    fn: function (deferred: any) {\n\t      ajvValidate(data).then(() => deferred.resolve())\n\t    },\n\t  })\n\t  .add('Zod', {\n\t    defer: true,\n\t    fn(deferred: any) {\n\t      zodSchema.parseAsync(data).then(() => deferred.resolve())\n\t    },\n", "  })\n\t  .on('cycle', function (event: any) {\n\t    console.log(String(event.target))\n\t  })\n\t  .on('complete', function (this: any) {\n\t    console.log('Fastest is ' + this.filter('fastest').map('name'))\n\t  })\n\t  .run({ async: true })\n"]}
{"filename": "benchmarks/object_with_arrays.ts", "chunked_list": ["import { z } from 'zod'\n\t// @ts-ignore\n\timport Benchmark from 'benchmark'\n\timport Ajv, { AsyncValidateFunction } from 'ajv'\n\timport { Compiler } from '../src/compiler/main.js'\n\timport { ErrorReporterFactory } from '../factories/error_reporter.js'\n\timport { MessagesProviderFactory } from '../factories/messages_provider.js'\n\tconst suite = new Benchmark.Suite()\n\tconst data = { contacts: [{ email: 'foo@bar.com' }] }\n\tconst meta = {}\n", "const refs = {\n\t  'ref://1': {\n\t    validator(value: unknown, _: any, field: any) {\n\t      if (typeof value !== 'string') {\n\t        field.report('Value is not a string', field)\n\t      }\n\t    },\n\t    options: {},\n\t  },\n\t}\n", "const messagesProvider = new MessagesProviderFactory().create()\n\tconst errorReporter = new ErrorReporterFactory().create()\n\tconst zodSchema = z.object({\n\t  contacts: z.array(\n\t    z.object({\n\t      email: z.string(),\n\t    })\n\t  ),\n\t})\n\tconst compiler = new Compiler({\n", "  type: 'root',\n\t  schema: {\n\t    type: 'object',\n\t    allowNull: false,\n\t    isOptional: false,\n\t    fieldName: '*',\n\t    allowUnknownProperties: false,\n\t    bail: true,\n\t    properties: [\n\t      {\n", "        type: 'array',\n\t        fieldName: 'contacts',\n\t        propertyName: 'contacts',\n\t        allowNull: false,\n\t        bail: true,\n\t        isOptional: false,\n\t        each: {\n\t          type: 'object',\n\t          propertyName: '*',\n\t          allowNull: false,\n", "          allowUnknownProperties: false,\n\t          isOptional: false,\n\t          fieldName: '*',\n\t          bail: true,\n\t          groups: [],\n\t          properties: [\n\t            {\n\t              type: 'literal',\n\t              bail: true,\n\t              allowNull: false,\n", "              fieldName: 'email',\n\t              propertyName: 'email',\n\t              isOptional: false,\n\t              validations: [\n\t                {\n\t                  isAsync: false,\n\t                  ruleFnId: 'ref://1',\n\t                  implicit: false,\n\t                },\n\t              ],\n", "            },\n\t          ],\n\t          validations: [],\n\t        },\n\t        validations: [],\n\t      },\n\t    ],\n\t    groups: [],\n\t    propertyName: '*',\n\t    validations: [],\n", "  },\n\t})\n\tcompiler.compile()\n\tconst fn = compiler.compile()\n\tconst ajv = new Ajv.default({ removeAdditional: true })\n\tconst ajvSchema = {\n\t  $async: true,\n\t  type: 'object',\n\t  properties: {\n\t    contacts: {\n", "      type: 'array',\n\t      items: {\n\t        type: 'object',\n\t        properties: {\n\t          email: { type: 'string' },\n\t        },\n\t        required: ['email'],\n\t      },\n\t    },\n\t  },\n", "  required: ['contacts'],\n\t}\n\tconst ajvValidate = ajv.compile(ajvSchema) as AsyncValidateFunction<any>\n\tsuite\n\t  .add('VineJS compiler', {\n\t    defer: true,\n\t    // benchmark test function\n\t    fn: function (deferred: any) {\n\t      fn(data, meta, refs, messagesProvider, errorReporter).then(() => deferred.resolve())\n\t    },\n", "  })\n\t  .add('Ajv', {\n\t    defer: true,\n\t    // benchmark test function\n\t    fn: function (deferred: any) {\n\t      ajvValidate(data).then(() => deferred.resolve())\n\t    },\n\t  })\n\t  .add('Zod', {\n\t    defer: true,\n", "    fn(deferred: any) {\n\t      zodSchema.parseAsync(data).then(() => deferred.resolve())\n\t    },\n\t  })\n\t  .on('cycle', function (event: any) {\n\t    console.log(String(event.target))\n\t  })\n\t  .on('complete', function (this: any) {\n\t    console.log('Fastest is ' + this.filter('fastest').map('name'))\n\t  })\n", "  .run({ async: true })\n"]}
{"filename": "benchmarks/flat_object.ts", "chunked_list": ["import { z } from 'zod'\n\t// @ts-ignore\n\timport Benchmark from 'benchmark'\n\timport Ajv, { AsyncValidateFunction } from 'ajv'\n\timport { Compiler } from '../src/compiler/main.js'\n\timport { ErrorReporterFactory } from '../factories/error_reporter.js'\n\timport { MessagesProviderFactory } from '../factories/messages_provider.js'\n\tconst suite = new Benchmark.Suite()\n\tconst data = { username: 'virk' }\n\tconst meta = {}\n", "const refs = {\n\t  'ref://1': {\n\t    validator(value: unknown, _: any, field: any) {\n\t      if (typeof value !== 'string') {\n\t        field.report('Value is not a string')\n\t      }\n\t    },\n\t    options: {},\n\t  },\n\t}\n", "const messagesProvider = new MessagesProviderFactory().create()\n\tconst errorReporter = new ErrorReporterFactory().create()\n\tconst zodSchema = z.object({\n\t  username: z.string(),\n\t})\n\tconst compiler = new Compiler({\n\t  type: 'root',\n\t  schema: {\n\t    type: 'object',\n\t    allowNull: false,\n", "    isOptional: false,\n\t    fieldName: '*',\n\t    allowUnknownProperties: false,\n\t    bail: true,\n\t    properties: [\n\t      {\n\t        type: 'literal',\n\t        bail: true,\n\t        allowNull: false,\n\t        fieldName: 'username',\n", "        propertyName: 'userName',\n\t        isOptional: false,\n\t        validations: [\n\t          {\n\t            isAsync: false,\n\t            ruleFnId: 'ref://1',\n\t            implicit: false,\n\t          },\n\t        ],\n\t      },\n", "    ],\n\t    groups: [],\n\t    propertyName: '*',\n\t    validations: [],\n\t  },\n\t})\n\tcompiler.compile()\n\tconst fn = compiler.compile()\n\tconst ajv = new Ajv.default()\n\tconst ajvSchema = {\n", "  $async: true,\n\t  type: 'object',\n\t  properties: {\n\t    username: { type: 'string' },\n\t  },\n\t  required: ['username'],\n\t  additionalProperties: false,\n\t}\n\tconst ajvValidate = ajv.compile(ajvSchema) as AsyncValidateFunction<any>\n\tsuite\n", "  .add('VineJS compiler', {\n\t    defer: true,\n\t    // benchmark test function\n\t    fn: function (deferred: any) {\n\t      fn(data, meta, refs, messagesProvider, errorReporter).then(() => deferred.resolve())\n\t    },\n\t  })\n\t  .add('Ajv', {\n\t    defer: true,\n\t    // benchmark test function\n", "    fn: function (deferred: any) {\n\t      ajvValidate(data).then(() => deferred.resolve())\n\t    },\n\t  })\n\t  .add('Zod', {\n\t    defer: true,\n\t    fn(deferred: any) {\n\t      zodSchema.parseAsync(data).then(() => deferred.resolve())\n\t    },\n\t  })\n", "  .on('cycle', function (event: any) {\n\t    console.log(String(event.target))\n\t  })\n\t  .on('complete', function (this: any) {\n\t    console.log('Fastest is ' + this.filter('fastest').map('name'))\n\t  })\n\t  .run({ async: true })\n"]}
{"filename": "factories/create_root.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { ObjectNode, RootNode } from '../src/types.js'\n\texport function createRoot(schema: ObjectNode): RootNode {\n", "  return {\n\t    type: 'root',\n\t    schema: schema,\n\t  }\n\t}\n\texport function createObjectRoot(nodes: ObjectNode['properties']): RootNode {\n\t  return createRoot({\n\t    type: 'object',\n\t    fieldName: '*',\n\t    propertyName: '*',\n", "    isOptional: false,\n\t    allowNull: false,\n\t    allowUnknownProperties: false,\n\t    bail: true,\n\t    properties: nodes,\n\t    groups: [],\n\t    validations: [],\n\t  })\n\t}\n"]}
{"filename": "factories/output.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { EOL } from 'node:os'\n\timport type { CompilerOptions } from '../src/types.js'\n", "import { defineInlineErrorMessages } from '../src/scripts/define_error_messages.js'\n\timport { defineInlineFunctions } from '../src/scripts/define_inline_functions.js'\n\t/**\n\t * Returns code for the initial output\n\t */\n\texport function getInitialOutput(options?: CompilerOptions) {\n\t  return [\n\t    `async function anonymous(root,meta,refs,messagesProvider,errorReporter) {`,\n\t    ...defineInlineErrorMessages({\n\t      required: 'value is required',\n", "      object: 'value is not a valid object',\n\t      array: 'value is not a valid array',\n\t    }).split(EOL),\n\t    ...defineInlineFunctions(options || { convertEmptyStringsToNull: false }).split(EOL),\n\t    'let out;',\n\t  ]\n\t}\n\t/**\n\t * Returns code for the closing output.\n\t */\n", "export function getClosingOutput() {\n\t  return [\n\t    `if(errorReporter.hasErrors) {`,\n\t    `  throw errorReporter.createError();`,\n\t    `}`,\n\t    `return out;`,\n\t    '}',\n\t  ]\n\t}\n"]}
{"filename": "factories/messages_provider.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { MessagesProviderContact } from '../src/types.js'\n\texport class MessagesProviderFactory {\n", "  create() {\n\t    const provider: MessagesProviderContact = {\n\t      getMessage(defaultMessage) {\n\t        return defaultMessage\n\t      },\n\t    }\n\t    return provider\n\t  }\n\t}\n"]}
{"filename": "factories/code_validator.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { parse } from 'acorn'\n\t/**\n", " * Validates a JS snippet using acorn\n\t */\n\texport function validateCode(input: string) {\n\t  parse(input, { ecmaVersion: 2020, allowAwaitOutsideFunction: true })\n\t}\n"]}
{"filename": "factories/code_beautifier.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\t// @ts-expect-error\n\timport js from 'js-beautify'\n", "/**\n\t * Validates a JS snippet using acorn\n\t */\n\texport function beautifyCode(input: string | string[]) {\n\t  return {\n\t    value: js(Array.isArray(input) ? input.join('\\n') : input, {\n\t      indent_size: '2',\n\t      indent_char: ' ',\n\t      max_preserve_newlines: '-1',\n\t      preserve_newlines: false,\n", "      keep_array_indentation: false,\n\t      break_chained_methods: false,\n\t      indent_scripts: 'normal',\n\t      brace_style: 'collapse',\n\t      space_before_conditional: true,\n\t      unescape_strings: false,\n\t      jslint_happy: false,\n\t      end_with_newline: false,\n\t      wrap_line_length: '0',\n\t      indent_inner_html: false,\n", "      comma_first: false,\n\t      e4x: false,\n\t      indent_empty_lines: false,\n\t    }),\n\t    toString() {\n\t      return this.value\n\t    },\n\t    toArray() {\n\t      return this.value.split('\\n')\n\t    },\n", "  }\n\t}\n"]}
{"filename": "factories/error_reporter.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { ErrorReporterContract } from '../src/types.js'\n\tclass ValidationError extends Error {\n", "  declare messages: string[]\n\t}\n\texport class ErrorReporterFactory {\n\t  create() {\n\t    const reporter = {\n\t      messages: [] as string[],\n\t      hasErrors: false,\n\t      report(message: string) {\n\t        this.hasErrors = true\n\t        this.messages.push(message)\n", "      },\n\t      createError() {\n\t        const error = new ValidationError('Validation failure')\n\t        error.messages = this.messages\n\t        return error\n\t      },\n\t    }\n\t    return reporter satisfies ErrorReporterContract\n\t  }\n\t}\n"]}
{"filename": "examples/object_groups/run.ts", "chunked_list": ["import { Compiler } from '../../src/compiler/main.js'\n\timport { beautifyCode } from '../../factories/code_beautifier.js'\n\timport { refs, schema } from './schema.js'\n\timport { ErrorReporterFactory } from '../../factories/error_reporter.js'\n\timport { MessagesProviderFactory } from '../../factories/messages_provider.js'\n\tconst compiler = new Compiler(schema)\n\tconst fn = compiler.compile()\n\tconsole.log('========= COMPILED OUTPUT =========')\n\tconsole.log(beautifyCode(fn.toString()).toString())\n\tconsole.log('========= END COMPILED OUTPUT =========')\n", "const data = {\n\t  email: 'foo',\n\t  password: 'secret',\n\t}\n\tconst messagesProvider = new MessagesProviderFactory().create()\n\tconst errorReporter = new ErrorReporterFactory().create()\n\tconst output = await fn(data, {}, refs, messagesProvider, errorReporter)\n\tconsole.log('')\n\tconsole.log('========= VALIDATED OUTPUT =========')\n\tconsole.log(output)\n", "console.log('========= END VALIDATED OUTPUT =========')\n"]}
{"filename": "examples/object_groups/schema.ts", "chunked_list": ["import { RootNode } from '../../src/types.js'\n\texport const schema: RootNode = {\n\t  type: 'root',\n\t  schema: {\n\t    type: 'object',\n\t    fieldName: '*',\n\t    propertyName: '*',\n\t    allowNull: false,\n\t    isOptional: false,\n\t    allowUnknownProperties: false,\n", "    bail: true,\n\t    validations: [],\n\t    groups: [\n\t      {\n\t        type: 'group',\n\t        conditions: [\n\t          {\n\t            conditionalFnRefId: 'ref://1',\n\t            schema: {\n\t              type: 'sub_object',\n", "              groups: [],\n\t              properties: [\n\t                {\n\t                  type: 'literal',\n\t                  fieldName: 'email',\n\t                  propertyName: 'email',\n\t                  allowNull: false,\n\t                  isOptional: false,\n\t                  bail: true,\n\t                  validations: [],\n", "                },\n\t              ],\n\t            },\n\t          },\n\t          {\n\t            conditionalFnRefId: 'ref://2',\n\t            schema: {\n\t              type: 'sub_object',\n\t              groups: [],\n\t              properties: [\n", "                {\n\t                  type: 'literal',\n\t                  fieldName: 'username',\n\t                  propertyName: 'username',\n\t                  allowNull: false,\n\t                  isOptional: false,\n\t                  bail: true,\n\t                  validations: [],\n\t                },\n\t              ],\n", "            },\n\t          },\n\t        ],\n\t      },\n\t    ],\n\t    properties: [\n\t      {\n\t        type: 'literal',\n\t        fieldName: 'password',\n\t        propertyName: 'password',\n", "        allowNull: false,\n\t        isOptional: false,\n\t        bail: true,\n\t        validations: [],\n\t      },\n\t    ],\n\t  },\n\t}\n\texport const refs = {\n\t  'ref://1': () => true,\n", "  'ref://2': () => false,\n\t}\n"]}
{"filename": "examples/nested_object/run.ts", "chunked_list": ["import { Compiler } from '../../src/compiler/main.js'\n\timport { beautifyCode } from '../../factories/code_beautifier.js'\n\timport { refs, schema } from './schema.js'\n\timport { ErrorReporterFactory } from '../../factories/error_reporter.js'\n\timport { MessagesProviderFactory } from '../../factories/messages_provider.js'\n\tconst compiler = new Compiler(schema)\n\tconst fn = compiler.compile()\n\tconsole.log('========= COMPILED OUTPUT =========')\n\tconsole.log(beautifyCode(fn.toString()).toString())\n\tconsole.log('========= END COMPILED OUTPUT =========')\n", "const data = {\n\t  id: 1,\n\t  profile: {\n\t    twitter_handle: 'foo',\n\t    github_username: 'foo',\n\t  },\n\t}\n\tconst messagesProvider = new MessagesProviderFactory().create()\n\tconst errorReporter = new ErrorReporterFactory().create()\n\tconst output = await fn(data, {}, refs, messagesProvider, errorReporter)\n", "console.log('')\n\tconsole.log('========= VALIDATED OUTPUT =========')\n\tconsole.log(output)\n\tconsole.log('========= END VALIDATED OUTPUT =========')\n"]}
{"filename": "examples/nested_object/schema.ts", "chunked_list": ["import { RootNode } from '../../src/types.js'\n\texport const schema: RootNode = {\n\t  type: 'root',\n\t  schema: {\n\t    type: 'object',\n\t    allowNull: false,\n\t    isOptional: false,\n\t    fieldName: '*',\n\t    propertyName: '*',\n\t    allowUnknownProperties: false,\n", "    bail: true,\n\t    properties: [\n\t      {\n\t        type: 'literal',\n\t        fieldName: 'id',\n\t        propertyName: 'id',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        bail: true,\n\t        validations: [],\n", "      },\n\t      {\n\t        type: 'object',\n\t        fieldName: 'profile',\n\t        propertyName: 'profile',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        bail: true,\n\t        validations: [],\n\t        groups: [],\n", "        allowUnknownProperties: false,\n\t        properties: [\n\t          {\n\t            type: 'literal',\n\t            allowNull: false,\n\t            isOptional: true,\n\t            bail: true,\n\t            fieldName: 'twitter_handle',\n\t            propertyName: 'twitterHandle',\n\t            validations: [],\n", "          },\n\t          {\n\t            type: 'literal',\n\t            allowNull: false,\n\t            isOptional: false,\n\t            bail: true,\n\t            fieldName: 'github_username',\n\t            propertyName: 'githubUsername',\n\t            validations: [],\n\t          },\n", "        ],\n\t      },\n\t    ],\n\t    groups: [],\n\t    validations: [],\n\t  },\n\t}\n\texport const refs = {}\n"]}
{"filename": "examples/array_union/run.ts", "chunked_list": ["import { Compiler } from '../../src/compiler/main.js'\n\timport { beautifyCode } from '../../factories/code_beautifier.js'\n\timport { refs, schema } from './schema.js'\n\timport { ErrorReporterFactory } from '../../factories/error_reporter.js'\n\timport { MessagesProviderFactory } from '../../factories/messages_provider.js'\n\tconst compiler = new Compiler(schema)\n\tconst fn = compiler.compile()\n\tconsole.log('========= COMPILED OUTPUT =========')\n\tconsole.log(beautifyCode(fn.toString()).toString())\n\tconsole.log('========= END COMPILED OUTPUT =========')\n", "const data = [\n\t  {\n\t    phone: '1234',\n\t  },\n\t  {\n\t    phone: '5678',\n\t  },\n\t]\n\tconst messagesProvider = new MessagesProviderFactory().create()\n\tconst errorReporter = new ErrorReporterFactory().create()\n", "const output = await fn(data, {}, refs, messagesProvider, errorReporter)\n\tconsole.log('')\n\tconsole.log('========= VALIDATED OUTPUT =========')\n\tconsole.log(output)\n\tconsole.log('========= END VALIDATED OUTPUT =========')\n"]}
{"filename": "examples/array_union/schema.ts", "chunked_list": ["import { RootNode } from '../../src/types.js'\n\texport const schema: RootNode = {\n\t  type: 'root',\n\t  schema: {\n\t    type: 'array',\n\t    fieldName: '*',\n\t    propertyName: '*',\n\t    allowNull: false,\n\t    isOptional: false,\n\t    bail: true,\n", "    validations: [],\n\t    each: {\n\t      fieldName: '*',\n\t      propertyName: '*',\n\t      type: 'union',\n\t      conditions: [\n\t        {\n\t          conditionalFnRefId: 'ref://1',\n\t          schema: {\n\t            type: 'object',\n", "            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n\t            groups: [],\n\t            properties: [\n\t              {\n\t                type: 'literal',\n\t                fieldName: 'phone',\n\t                propertyName: 'phone',\n\t                allowNull: false,\n", "                isOptional: false,\n\t                bail: true,\n\t                validations: [],\n\t              },\n\t            ],\n\t            fieldName: '*',\n\t            propertyName: '*',\n\t            isOptional: false,\n\t            validations: [],\n\t          },\n", "        },\n\t        {\n\t          conditionalFnRefId: 'ref://2',\n\t          schema: {\n\t            type: 'object',\n\t            allowNull: false,\n\t            allowUnknownProperties: false,\n\t            bail: true,\n\t            groups: [],\n\t            properties: [\n", "              {\n\t                type: 'literal',\n\t                fieldName: 'email',\n\t                propertyName: 'email',\n\t                allowNull: false,\n\t                isOptional: false,\n\t                bail: true,\n\t                validations: [],\n\t              },\n\t            ],\n", "            fieldName: '*',\n\t            propertyName: '*',\n\t            isOptional: false,\n\t            validations: [],\n\t          },\n\t        },\n\t      ],\n\t    },\n\t  },\n\t}\n", "export const refs = {\n\t  'ref://1': () => true,\n\t  'ref://2': () => false,\n\t}\n"]}
{"filename": "examples/flat_object/run.ts", "chunked_list": ["import { Compiler } from '../../src/compiler/main.js'\n\timport { beautifyCode } from '../../factories/code_beautifier.js'\n\timport { refs, schema } from './schema.js'\n\timport { ErrorReporterFactory } from '../../factories/error_reporter.js'\n\timport { MessagesProviderFactory } from '../../factories/messages_provider.js'\n\tconst compiler = new Compiler(schema)\n\tconst fn = compiler.compile()\n\tconsole.log('========= COMPILED OUTPUT =========')\n\tconsole.log(beautifyCode(fn.toString()).toString())\n\tconsole.log('========= END COMPILED OUTPUT =========')\n", "const data = {\n\t  username: 'virk',\n\t  email: 'foo@bar.com',\n\t  password: 'secret',\n\t  additionalProperty: 'foo',\n\t}\n\tconst messagesProvider = new MessagesProviderFactory().create()\n\tconst errorReporter = new ErrorReporterFactory().create()\n\tconst output = await fn(data, {}, refs, messagesProvider, errorReporter)\n\tconsole.log('')\n", "console.log('========= VALIDATED OUTPUT =========')\n\tconsole.log(output)\n\tconsole.log('========= END VALIDATED OUTPUT =========')\n"]}
{"filename": "examples/flat_object/schema.ts", "chunked_list": ["import { RootNode } from '../../src/types.js'\n\texport const schema: RootNode = {\n\t  type: 'root',\n\t  schema: {\n\t    type: 'object',\n\t    fieldName: '*',\n\t    propertyName: '*',\n\t    allowNull: false,\n\t    isOptional: false,\n\t    allowUnknownProperties: false,\n", "    bail: true,\n\t    properties: [\n\t      {\n\t        type: 'literal',\n\t        fieldName: 'username',\n\t        propertyName: 'userName',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        bail: true,\n\t        validations: [],\n", "      },\n\t      {\n\t        type: 'literal',\n\t        fieldName: 'email',\n\t        propertyName: 'email',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        bail: true,\n\t        validations: [],\n\t      },\n", "      {\n\t        type: 'literal',\n\t        fieldName: 'password',\n\t        propertyName: 'password',\n\t        allowNull: false,\n\t        isOptional: false,\n\t        bail: true,\n\t        validations: [],\n\t      },\n\t    ],\n", "    groups: [],\n\t    validations: [],\n\t  },\n\t}\n\texport const refs = {}\n"]}
{"filename": "src/refs_builder.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport type {\n\t  Refs,\n", "  ParseFn,\n\t  RefsStore,\n\t  TransformFn,\n\t  ConditionalFn,\n\t  RefIdentifier,\n\t  ValidationRule,\n\t} from './types.js'\n\t/**\n\t * Creates a refs store for parsing the schema\n\t */\n", "export function refsBuilder(): RefsStore {\n\t  let counter = 0\n\t  const refs: Refs = {}\n\t  return {\n\t    toJSON() {\n\t      return refs\n\t    },\n\t    /**\n\t     * Track a value inside refs\n\t     */\n", "    track(value: Refs[keyof Refs]): RefIdentifier {\n\t      counter++\n\t      const ref = `ref://${counter}` as const\n\t      refs[ref] = value\n\t      return ref\n\t    },\n\t    /**\n\t     * Track a validation inside refs\n\t     */\n\t    trackValidation(validation: ValidationRule): RefIdentifier {\n", "      return this.track(validation)\n\t    },\n\t    /**\n\t     * Track input value parser inside refs\n\t     */\n\t    trackParser(fn: ParseFn): RefIdentifier {\n\t      return this.track(fn)\n\t    },\n\t    /**\n\t     * Track output value transformer inside refs\n", "     */\n\t    trackTransformer(fn: TransformFn<any, any>): RefIdentifier {\n\t      return this.track(fn)\n\t    },\n\t    /**\n\t     * Track a conditional inside refs\n\t     */\n\t    trackConditional(fn: ConditionalFn<any>): RefIdentifier {\n\t      return this.track(fn)\n\t    },\n", "  }\n\t}\n"]}
{"filename": "src/types.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\t/**\n\t * Represenation of a ref id\n", " */\n\texport type RefIdentifier = `ref://${number}`\n\t/**\n\t * Allowed values for refs\n\t */\n\texport type Refs = Record<\n\t  RefIdentifier,\n\t  ValidationRule | TransformFn<any, any> | ParseFn | ConditionalFn<any>\n\t>\n\t/**\n", " * Refs store to track runtime values as refs with\n\t * type safety\n\t */\n\texport type RefsStore = {\n\t  toJSON(): Refs\n\t  /**\n\t   * Track a value inside refs\n\t   */\n\t  track(value: Refs[keyof Refs]): RefIdentifier\n\t  /**\n", "   * Track a validation inside refs\n\t   */\n\t  trackValidation(validation: ValidationRule): RefIdentifier\n\t  /**\n\t   * Track input value parser inside refs\n\t   */\n\t  trackParser(fn: ParseFn): RefIdentifier\n\t  /**\n\t   * Track output value transformer inside refs\n\t   */\n", "  trackTransformer(fn: TransformFn<any, any>): RefIdentifier\n\t  /**\n\t   * Track a conditional inside refs\n\t   */\n\t  trackConditional(fn: ConditionalFn<any>): RefIdentifier\n\t}\n\t/**\n\t * The context shared with the entire validation pipeline.\n\t * Each field gets its own context object.\n\t */\n", "export type FieldContext = {\n\t  /**\n\t   * Field value\n\t   */\n\t  value: unknown\n\t  /**\n\t   * The data property is the top-level object under validation.\n\t   */\n\t  data: any\n\t  /**\n", "   * Shared metadata across the entire validation lifecycle. It can be\n\t   * used to pass data between validation rules\n\t   */\n\t  meta: Record<string, any>\n\t  /**\n\t   * Mutate the value of field under validation.\n\t   */\n\t  mutate(newValue: any, field: FieldContext): void\n\t  /**\n\t   * Report error to the error reporter\n", "   */\n\t  report: ErrorReporterContract['report']\n\t  /**\n\t   * Is this field valid. Default: true\n\t   */\n\t  isValid: boolean\n\t  /**\n\t   * Is this field has value defined.\n\t   */\n\t  isDefined: boolean\n", "  /**\n\t   * Wildcard path for the field. The value is a nested\n\t   * pointer to the field under validation.\n\t   *\n\t   * In case of arrays, the `*` wildcard is used.\n\t   */\n\t  wildCardPath: string\n\t  /**\n\t   * The parent property is the parent of the field. It could be an\n\t   * array or an object.\n", "   */\n\t  parent: any\n\t  /**\n\t   * Name of the field under validation. In case of an array, the field\n\t   * name will be a number\n\t   */\n\t  name: string | number\n\t  /**\n\t   * Is this field an array member\n\t   */\n", "  isArrayMember: boolean\n\t}\n\t/**\n\t * The shape of validation rule picked from the\n\t * refs\n\t */\n\texport type ValidationRule = {\n\t  /**\n\t   * Performs validation\n\t   */\n", "  validator(value: unknown, options: any, field: FieldContext): any\n\t  /**\n\t   * Options to pass\n\t   */\n\t  options?: any\n\t}\n\t/**\n\t * The shape of parse function picked from the refs\n\t */\n\texport type ParseFn = (value: unknown, ctx: Pick<FieldContext, 'data' | 'parent' | 'meta'>) => any\n", "/**\n\t * The shape of transform function picked from the refs\n\t */\n\texport type TransformFn<Input, Output> = (value: Input, field: FieldContext) => Output\n\t/**\n\t * The shape of conditional function used for narrowing down unions.\n\t */\n\texport type ConditionalFn<Input> = (value: Input, field: FieldContext) => boolean\n\t/**\n\t * Shape of a validation rule accepted by the compiler\n", " */\n\texport type ValidationNode = {\n\t  /**\n\t   * Rule implementation function id.\n\t   */\n\t  ruleFnId: RefIdentifier\n\t  /**\n\t   * Is this an async rule. This flag helps creating an optimized output\n\t   */\n\t  isAsync: boolean\n", "  /**\n\t   * The rules are skipped when the value of a field is \"null\" or \"undefined\".\n\t   * Unless, the \"implicit\" flag is true\n\t   */\n\t  implicit: boolean\n\t}\n\t/**\n\t * Shape of field inside a schema.\n\t */\n\texport type FieldNode = {\n", "  /**\n\t   * Should the validation cycle stop after the first error.\n\t   * Defaults to true\n\t   */\n\t  bail: boolean\n\t  /**\n\t   * Field name refers to the name of the field under the data\n\t   * object\n\t   */\n\t  fieldName: string\n", "  /**\n\t   * Name of the output property. This allows validating a field with a different name, but\n\t   * storing its output value with a different name.\n\t   */\n\t  propertyName: string\n\t  /**\n\t   * Are we expecting this field to be undefined or null\n\t   */\n\t  isOptional: boolean\n\t  /**\n", "   * Are we expecting this field to be null\n\t   */\n\t  allowNull: boolean\n\t  /**\n\t   * The reference id for the parse method. Parse method is called to mutate the\n\t   * initial value. The function is executed always even when value is undefined\n\t   * or null.\n\t   *\n\t   * @see [[ParseFn]]\n\t   */\n", "  parseFnId?: RefIdentifier\n\t  /**\n\t   * A set of validations to apply on the field\n\t   */\n\t  validations: ValidationNode[]\n\t}\n\t/**\n\t * Shape of a single field accepted by the compiler\n\t */\n\texport type LiteralNode = FieldNode & {\n", "  type: 'literal'\n\t  /**\n\t   * Transform the output value of a field. The output of this method is the\n\t   * final source of truth. The function is executed at the time of writing the\n\t   * value to the output.\n\t   */\n\t  transformFnId?: RefIdentifier\n\t}\n\t/**\n\t * Shape of the object node accepted by the compiler\n", " */\n\texport type ObjectNode = FieldNode & {\n\t  type: 'object'\n\t  /**\n\t   * Whether or not to allow unknown properties. When disabled, the\n\t   * output object will have only validated properties.\n\t   *\n\t   * Default: false\n\t   */\n\t  allowUnknownProperties: boolean\n", "  /**\n\t   * Object known properties\n\t   */\n\t  properties: CompilerNodes[]\n\t  /**\n\t   * A collection of object groups to merge into the main object.\n\t   * Each group is a collection of conditionals with a sub-object\n\t   * inside them.\n\t   */\n\t  groups: ObjectGroupNode[]\n", "}\n\t/**\n\t * A compiler object group produces a single sub object based upon\n\t * the defined conditions.\n\t */\n\texport type ObjectGroupNode = {\n\t  type: 'group'\n\t  /**\n\t   * An optional function to call when all of the conditions\n\t   * are false.\n", "   */\n\t  elseConditionalFnRefId?: RefIdentifier\n\t  /**\n\t   * Conditions to evaluate\n\t   */\n\t  conditions: {\n\t    /**\n\t     * The conditional function reference id\n\t     */\n\t    conditionalFnRefId: RefIdentifier\n", "    /**\n\t     * Schema to use when condition is true\n\t     */\n\t    schema: {\n\t      type: 'sub_object'\n\t      /**\n\t       * Object known properties\n\t       */\n\t      properties: CompilerNodes[]\n\t      /**\n", "       * A collection of object groups to merge into the main object.\n\t       * Each group is a collection of conditionals with a sub-object\n\t       * inside them.\n\t       */\n\t      groups: ObjectGroupNode[]\n\t    }\n\t  }[]\n\t}\n\t/**\n\t * Shape of the tuple node accepted by the compiler\n", " */\n\texport type TupleNode = FieldNode & {\n\t  type: 'tuple'\n\t  /**\n\t   * Whether or not to allow unknown properties. When disabled, the\n\t   * output array will have only validated properties.\n\t   *\n\t   * Default: false\n\t   */\n\t  allowUnknownProperties: boolean\n", "  /**\n\t   * Tuple known properties\n\t   */\n\t  properties: CompilerNodes[]\n\t}\n\t/**\n\t * Shape of the record node accepted by the compiler\n\t */\n\texport type RecordNode = FieldNode & {\n\t  type: 'record'\n", "  /**\n\t   * Captures object elements\n\t   */\n\t  each: CompilerNodes\n\t}\n\t/**\n\t * Shape of the array node accepted by the compiler\n\t */\n\texport type ArrayNode = FieldNode & {\n\t  type: 'array'\n", "  /**\n\t   * Captures array elements\n\t   */\n\t  each: CompilerNodes\n\t}\n\t/**\n\t * Shape of the union node accepted by the compiler. A union is a combination\n\t * of conditionals.\n\t */\n\texport type UnionNode = {\n", "  type: 'union'\n\t  /**\n\t   * Field name refers to the name of the field under the data\n\t   * object\n\t   */\n\t  fieldName: string\n\t  /**\n\t   * Name of the output property. This allows validating a field with a different name, but\n\t   * storing its value with a different name.\n\t   */\n", "  propertyName: string\n\t  /**\n\t   * An optional function to call when all of the conditions\n\t   * are false.\n\t   */\n\t  elseConditionalFnRefId?: RefIdentifier\n\t  /**\n\t   * Conditions to evaluate\n\t   */\n\t  conditions: {\n", "    /**\n\t     * The conditional function reference id\n\t     */\n\t    conditionalFnRefId: RefIdentifier\n\t    /**\n\t     * Schema to use when condition is true\n\t     */\n\t    schema: CompilerNodes\n\t  }[]\n\t}\n", "/**\n\t * The root of the schema\n\t */\n\texport type RootNode = {\n\t  type: 'root'\n\t  /**\n\t   * Schema at the root level\n\t   */\n\t  schema: CompilerNodes\n\t}\n", "/**\n\t * Known tree nodes accepted by the compiler\n\t */\n\texport type CompilerNodes =\n\t  | LiteralNode\n\t  | ObjectNode\n\t  | ArrayNode\n\t  | UnionNode\n\t  | RecordNode\n\t  | TupleNode\n", "/**\n\t * Properties of a parent node as the compiler loops through the\n\t * rules tree and constructs JS code.\n\t */\n\texport type CompilerParent = {\n\t  type: 'array' | 'object' | 'tuple' | 'record' | 'root'\n\t  /**\n\t   * Wildcard path to the field\n\t   */\n\t  wildCardPath: string\n", "  /**\n\t   * Name of the variable for the parent property. The variable name\n\t   * is used to lookup values from the parent\n\t   */\n\t  variableName: string\n\t  /**\n\t   * Nested path to the parent field. If the parent is nested inside\n\t   * an object or array.\n\t   */\n\t  fieldPathExpression: string\n", "  /**\n\t   * The expression for the output value.\n\t   */\n\t  outputExpression: string\n\t}\n\t/**\n\t * Compiler field is used to compute the variable and property\n\t * names for the JS output.\n\t */\n\texport type CompilerField = {\n", "  parentValueExpression: string\n\t  fieldNameExpression: string\n\t  fieldPathExpression: string\n\t  variableName: string\n\t  wildCardPath: string\n\t  valueExpression: string\n\t  outputExpression: string\n\t  isArrayMember: boolean\n\t}\n\t/**\n", " * The error reporter is used for reporting validation\n\t * errors.\n\t */\n\texport interface ErrorReporterContract {\n\t  /**\n\t   * A boolean to known if there are one or more\n\t   * errors.\n\t   */\n\t  hasErrors: boolean\n\t  /**\n", "   * Creates an instance of an exception to throw\n\t   */\n\t  createError(): Error\n\t  /**\n\t   * Report error for a field\n\t   */\n\t  report(message: string, rule: string, field: FieldContext, args?: Record<string, any>): any\n\t}\n\t/**\n\t * Messages provider is used to resolve validation error messages\n", " * during validation.\n\t */\n\texport interface MessagesProviderContact {\n\t  /**\n\t   * Returns a validation message for a given field + rule. The args\n\t   * may get passed by a validation rule to share additional context.\n\t   */\n\t  getMessage(\n\t    defaultMessage: string,\n\t    rule: string,\n", "    field: FieldContext,\n\t    args?: Record<string, any>\n\t  ): string\n\t}\n\t/**\n\t * Options accepted by the compiler\n\t */\n\texport type CompilerOptions = {\n\t  /**\n\t   * Convert empty string values to null for sake of\n", "   * normalization\n\t   */\n\t  convertEmptyStringsToNull: boolean\n\t  /**\n\t   * Provide messages to use for required, object and\n\t   * array validations.\n\t   */\n\t  messages?: Partial<{\n\t    required: string\n\t    object: string\n", "    array: string\n\t  }>\n\t}\n"]}
{"filename": "src/scripts/define_inline_functions.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\t/**\n\t * Returns JS fragment for inline function needed by the\n", " * validation runtime code.\n\t */\n\texport function defineInlineFunctions(options: { convertEmptyStringsToNull: boolean }) {\n\t  return `function report(message, rule, field, args) {\n\t  field.isValid = false;\n\t  errorReporter.report(messagesProvider.getMessage(message, rule, field, args), rule, field, args);\n\t};\n\tfunction defineValue(value, field) {\n\t  ${options.convertEmptyStringsToNull ? `if (value === '') { value = null; }` : ''}\n\t  field.value = value;\n", "  field.isDefined = value !== undefined && value !== null;\n\t  return field;\n\t};\n\tfunction ensureExists(field) {\n\t  if (field.value === undefined || field.value === null) {\n\t    field.report(REQUIRED, 'required', field);\n\t    return false;\n\t  }\n\t  return true;\n\t};\n", "function ensureIsDefined(field) {\n\t  if (field.value === undefined) {\n\t    field.report(REQUIRED, 'required', field);\n\t    return false;\n\t  }\n\t  return true;\n\t};\n\tfunction ensureIsObject(field) {\n\t  if (!field.isDefined) {\n\t    return false;\n", "  }\n\t  if (typeof field.value == 'object' && !Array.isArray(field.value)) {\n\t    return true;\n\t  }\n\t  field.report(NOT_AN_OBJECT, 'object', field);\n\t  return false;\n\t};\n\tfunction ensureIsArray(field) {\n\t  if (!field.isDefined) {\n\t    return false;\n", "  }\n\t  if (Array.isArray(field.value)) {\n\t    return true;\n\t  }\n\t  field.report(NOT_AN_ARRAY, 'array', field);\n\t  return false;\n\t};\n\tfunction copyProperties(val) {\n\t  let k, out, tmp;\n\t  if (Array.isArray(val)) {\n", "    out = Array((k = val.length))\n\t    while (k--) out[k] = (tmp = val[k]) && typeof tmp == 'object' ? copyProperties(tmp) : tmp\n\t    return out\n\t  }\n\t  if (Object.prototype.toString.call(val) === '[object Object]') {\n\t    out = {} // null\n\t    for (k in val) {\n\t      out[k] = (tmp = val[k]) && typeof tmp == 'object' ? copyProperties(tmp) : tmp\n\t    }\n\t    return out\n", "  }\n\t  return val\n\t};\n\tfunction moveProperties(source, destination, ignoreKeys) {\n\t  for (let key in source) {\n\t    if (!ignoreKeys.includes(key)) {\n\t      const value = source[key]\n\t      destination[key] = copyProperties(value)\n\t    }\n\t  }\n", "};`\n\t}\n"]}
{"filename": "src/scripts/define_else_conditon.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\ttype ConditionalGuardOptions = {\n\t  variableName: string\n", "  conditionalFnRefId: string\n\t}\n\t/**\n\t * Returns JS fragment to invoke a function inside else block\n\t */\n\texport function defineElseCondition({ variableName, conditionalFnRefId }: ConditionalGuardOptions) {\n\t  return `else {\n\trefs['${conditionalFnRefId}'](${variableName}.value, ${variableName});\n\t}`\n\t}\n"]}
{"filename": "src/scripts/report_errors.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\t/**\n\t * Returns JS fragment to report errors\n", " */\n\texport function reportErrors() {\n\t  return `if(errorReporter.hasErrors) {\n\t  throw errorReporter.createError();\n\t}`\n\t}\n"]}
{"filename": "src/scripts/define_error_messages.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { CompilerOptions } from '../types.js'\n\t/**\n", " * Returns JS fragment for inline error messages for errors raised\n\t * by the compiler.\n\t */\n\texport function defineInlineErrorMessages(\n\t  messages: Required<Exclude<CompilerOptions['messages'], undefined>>\n\t) {\n\t  return `const REQUIRED = '${messages.required}';\n\tconst NOT_AN_OBJECT = '${messages.object}';\n\tconst NOT_AN_ARRAY = '${messages.array}';`\n\t}\n"]}
{"filename": "src/scripts/define_conditional_guard.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\ttype ConditionalGuardOptions = {\n\t  variableName: string\n", "  conditionalFnRefId: string\n\t  guardedCodeSnippet: string\n\t  conditional: 'if' | 'else if'\n\t}\n\t/**\n\t * Returns JS fragment to wrap code inside a conditional guard\n\t */\n\texport function defineConditionalGuard({\n\t  conditional,\n\t  variableName,\n", "  conditionalFnRefId,\n\t  guardedCodeSnippet,\n\t}: ConditionalGuardOptions) {\n\t  return `${conditional}(refs['${conditionalFnRefId}'](${variableName}.value, ${variableName})) {\n\t${guardedCodeSnippet}\n\t}`\n\t}\n"]}
{"filename": "src/scripts/object/initial_output.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\t/**\n\t * Options accepts by the output script\n", " */\n\ttype OutputOptions = {\n\t  variableName: string\n\t  outputExpression: string\n\t  outputValueExpression: string\n\t}\n\t/**\n\t * Returns JS fragment for writing the initial output for an object\n\t */\n\texport function defineObjectInitialOutput({\n", "  variableName,\n\t  outputExpression,\n\t  outputValueExpression,\n\t}: OutputOptions) {\n\t  return `const ${variableName}_out = ${outputValueExpression};\n\t${outputExpression} = ${variableName}_out;`\n\t}\n"]}
{"filename": "src/scripts/object/move_unknown_properties.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { inspect } from 'node:util'\n\t/**\n", " * Options accepts by the output script\n\t */\n\ttype MovePropertiesOptions = {\n\t  variableName: string\n\t  allowUnknownProperties: boolean\n\t  fieldsToIgnore: string[]\n\t}\n\t/**\n\t * Returns JS fragment for moving properties from the source\n\t * to destination\n", " */\n\texport function defineMoveProperties({\n\t  variableName,\n\t  fieldsToIgnore,\n\t  allowUnknownProperties,\n\t}: MovePropertiesOptions) {\n\t  if (!allowUnknownProperties) {\n\t    return ''\n\t  }\n\t  return `moveProperties(${variableName}.value, ${variableName}_out, ${inspect(fieldsToIgnore)});`\n", "}\n"]}
{"filename": "src/scripts/object/guard.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\ttype ObjectGuardOptions = {\n\t  variableName: string\n", "  guardedCodeSnippet: string\n\t}\n\t/**\n\t * Returns JS fragment to wrap code inside an object conditional\n\t */\n\texport function defineObjectGuard({ variableName, guardedCodeSnippet }: ObjectGuardOptions) {\n\t  return `if (ensureIsObject(${variableName})) {\n\t${guardedCodeSnippet}\n\t}`\n\t}\n"]}
{"filename": "src/scripts/union/parse.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport type { RefIdentifier } from '../../types.js'\n\ttype FieldOptions = {\n", "  variableName: string\n\t  parseFnRefId?: RefIdentifier\n\t}\n\t/**\n\t * Returns JS fragment to call the parse function on the union conditional\n\t * schema.\n\t */\n\texport function callParseFunction({ parseFnRefId, variableName }: FieldOptions) {\n\t  if (parseFnRefId) {\n\t    return `${variableName}.value = refs['${parseFnRefId}'](${variableName}.value);`\n", "  }\n\t  return ''\n\t}\n"]}
{"filename": "src/scripts/record/loop.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\t/**\n\t * Options accepts by the loop script\n", " */\n\ttype RecordLoopOptions = {\n\t  variableName: string\n\t  loopCodeSnippet: string\n\t}\n\t/**\n\t * Returns JS fragment for wrapping code inside an record loop\n\t */\n\texport function defineRecordLoop({ variableName, loopCodeSnippet }: RecordLoopOptions) {\n\t  return `const ${variableName}_keys = Object.keys(${variableName}.value);\n", "const ${variableName}_keys_size = ${variableName}_keys.length;\n\tfor (let ${variableName}_key_i = 0; ${variableName}_key_i < ${variableName}_keys_size; ${variableName}_key_i++) {\n\tconst ${variableName}_i = ${variableName}_keys[${variableName}_key_i];\n\t${loopCodeSnippet}\n\t}`\n\t}\n"]}
{"filename": "src/scripts/array/loop.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\t/**\n\t * Options accepts by the loop script\n", " */\n\ttype ArrayLoopOptions = {\n\t  variableName: string\n\t  loopCodeSnippet: string\n\t  startingIndex?: number\n\t}\n\t/**\n\t * Returns JS fragment for wrapping code inside an array loop\n\t */\n\texport function defineArrayLoop({\n", "  variableName,\n\t  loopCodeSnippet,\n\t  startingIndex,\n\t}: ArrayLoopOptions) {\n\t  startingIndex = startingIndex || 0\n\t  return `const ${variableName}_items_size = ${variableName}.value.length;\n\tfor (let ${variableName}_i = ${startingIndex}; ${variableName}_i < ${variableName}_items_size; ${variableName}_i++) {\n\t${loopCodeSnippet}\n\t}`\n\t}\n"]}
{"filename": "src/scripts/array/initial_output.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\t/**\n\t * Options accepts by the output script\n", " */\n\ttype OutputOptions = {\n\t  variableName: string\n\t  outputExpression: string\n\t  outputValueExpression: string\n\t}\n\t/**\n\t * Returns JS fragment for writing the initial output for an array\n\t */\n\texport function defineArrayInitialOutput({\n", "  variableName,\n\t  outputExpression,\n\t  outputValueExpression,\n\t}: OutputOptions) {\n\t  return `const ${variableName}_out = ${outputValueExpression};\n\t${outputExpression} = ${variableName}_out;`\n\t}\n"]}
{"filename": "src/scripts/array/guard.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\ttype ArrayGuardOptions = {\n\t  variableName: string\n", "  guardedCodeSnippet: string\n\t}\n\t/**\n\t * Returns JS fragment to wrap code inside an array conditional\n\t */\n\texport function defineArrayGuard({ variableName, guardedCodeSnippet }: ArrayGuardOptions) {\n\t  return `if (ensureIsArray(${variableName})) {\n\t${guardedCodeSnippet}\n\t}`\n\t}\n"]}
{"filename": "src/scripts/field/existence_validations.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\ttype FieldOptions = {\n\t  variableName: string\n", "  isOptional: boolean\n\t  allowNull: boolean\n\t}\n\t/**\n\t * Returns JS fragment to validate a field's value for existence.\n\t */\n\texport function defineFieldExistenceValidations({\n\t  allowNull,\n\t  isOptional,\n\t  variableName,\n", "}: FieldOptions): string {\n\t  /**\n\t   * Validations are only performed when `isOptional` flag\n\t   * is disabled.\n\t   */\n\t  if (isOptional === false) {\n\t    /**\n\t     * When `allowNull` flag is disabled, we should ensure the value\n\t     * is not null and neither undefined.\n\t     */\n", "    if (allowNull === false) {\n\t      return `ensureExists(${variableName});`\n\t    } else {\n\t      /**\n\t       * Otherwise ensure the value is not undefined.\n\t       */\n\t      return `ensureIsDefined(${variableName});`\n\t    }\n\t  }\n\t  return ''\n", "}\n"]}
{"filename": "src/scripts/field/variables.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { RefIdentifier } from '../../types.js'\n\ttype FieldOptions = {\n", "  variableName: string\n\t  valueExpression: string\n\t  fieldNameExpression: string\n\t  wildCardPath: string\n\t  parentValueExpression: string\n\t  isArrayMember: boolean\n\t  parseFnRefId?: RefIdentifier\n\t}\n\t/**\n\t * Returns JS fragment for defining the field variables. It includes, the field\n", " * value variable, context variable, and a boolean to know if the field\n\t * exists.\n\t */\n\texport function defineFieldVariables({\n\t  parseFnRefId,\n\t  variableName,\n\t  wildCardPath,\n\t  isArrayMember,\n\t  valueExpression,\n\t  fieldNameExpression,\n", "  parentValueExpression,\n\t}: FieldOptions) {\n\t  const inValueExpression = parseFnRefId\n\t    ? `refs['${parseFnRefId}'](${valueExpression}, {\n\t      data: root,\n\t      meta: meta,\n\t      parent: ${parentValueExpression}\n\t    })`\n\t    : valueExpression\n\t  return `const ${variableName} = defineValue(${inValueExpression}, {\n", "  data: root,\n\t  meta: meta,\n\t  name: ${fieldNameExpression},\n\t  wildCardPath: '${wildCardPath}',\n\t  mutate: defineValue,\n\t  report: report,\n\t  isValid: true,\n\t  parent: ${parentValueExpression},\n\t  isArrayMember: ${isArrayMember},\n\t});`\n", "}\n"]}
{"filename": "src/scripts/field/is_valid_guard.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\ttype ObjectGuardOptions = {\n\t  variableName: string\n", "  bail: boolean\n\t  guardedCodeSnippet: string\n\t}\n\t/**\n\t * Returns JS fragment to wrap code inside a valid guard\n\t */\n\texport function defineIsValidGuard({ variableName, bail, guardedCodeSnippet }: ObjectGuardOptions) {\n\t  if (!bail) {\n\t    return guardedCodeSnippet\n\t  }\n", "  return `if (${variableName}.isValid) {\n\t${guardedCodeSnippet}\n\t}`\n\t}\n"]}
{"filename": "src/scripts/field/value_output.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { RefIdentifier } from '../../types.js'\n\t/**\n", " * Options accepts by the output script\n\t */\n\ttype OutputOptions = {\n\t  outputExpression: string\n\t  variableName: string\n\t  transformFnRefId?: RefIdentifier\n\t}\n\t/**\n\t * Returns JS fragment for writing the validated value to the output.\n\t */\n", "export function defineFieldValueOutput({\n\t  variableName,\n\t  outputExpression,\n\t  transformFnRefId,\n\t}: OutputOptions) {\n\t  const outputValueExpression = transformFnRefId\n\t    ? `refs['${transformFnRefId}'](${variableName}.value, ${variableName})`\n\t    : `${variableName}.value`\n\t  return `if (${variableName}.isDefined && ${variableName}.isValid) {\n\t  ${outputExpression} = ${outputValueExpression};\n", "}`\n\t}\n"]}
{"filename": "src/scripts/field/null_output.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { RefIdentifier } from '../../types.js'\n\t/**\n", " * Options accepts by the output script\n\t */\n\ttype OutputOptions = {\n\t  outputExpression: string\n\t  variableName: string\n\t  allowNull: boolean\n\t  transformFnRefId?: RefIdentifier\n\t  conditional?: 'if' | 'else if'\n\t}\n\t/**\n", " * Returns JS fragment for writing the null value to the output.\n\t */\n\texport function defineFieldNullOutput({\n\t  allowNull,\n\t  conditional,\n\t  variableName,\n\t  outputExpression,\n\t  transformFnRefId,\n\t}: OutputOptions) {\n\t  if (!allowNull) {\n", "    return ''\n\t  }\n\t  return `${conditional || 'if'}(${variableName}.value === null) {\n\t  ${outputExpression} = ${\n\t    transformFnRefId ? `refs['${transformFnRefId}'](null, ${variableName});` : 'null;'\n\t  }\n\t}`\n\t}\n"]}
{"filename": "src/scripts/field/validations.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { ValidationNode } from '../../types.js'\n\t/**\n", " * Options accepts by the validation script\n\t */\n\ttype ValidationOptions = {\n\t  bail: boolean\n\t  variableName: string\n\t  validations: ValidationNode[]\n\t  /**\n\t   * Drop missing conditional check regardless of whether\n\t   * rule is implicit or not\n\t   */\n", "  dropMissingCheck: boolean\n\t}\n\t/**\n\t * Helper to generate a conditional based upon enabled conditions.\n\t */\n\tfunction wrapInConditional(conditions: [string, string], wrappingCode: string) {\n\t  const [first, second] = conditions\n\t  if (first && second) {\n\t    return `if (${first} && ${second}) {\n\t  ${wrappingCode}\n", "}`\n\t  }\n\t  if (first) {\n\t    return `if (${first}) {\n\t  ${wrappingCode}\n\t}`\n\t  }\n\t  if (second) {\n\t    return `if (${second}) {\n\t  ${wrappingCode}\n", "}`\n\t  }\n\t  return wrappingCode\n\t}\n\t/**\n\t * Emits code for executing a validation function\n\t */\n\tfunction emitValidationSnippet(\n\t  { isAsync, implicit, ruleFnId }: ValidationNode,\n\t  variableName: string,\n", "  bail: boolean,\n\t  dropMissingCheck: boolean\n\t) {\n\t  const rule = `refs['${ruleFnId}']`\n\t  const callable = `${rule}.validator(${variableName}.value, ${rule}.options, ${variableName});`\n\t  /**\n\t   * Add \"isValid\" condition when the bail flag is turned on.\n\t   */\n\t  const bailCondition = bail ? `${variableName}.isValid` : ''\n\t  /**\n", "   * Add the \"!is_[variableName]_missing\" conditional when the rule is not implicit.\n\t   */\n\t  const implicitCondition = implicit || dropMissingCheck ? '' : `${variableName}.isDefined`\n\t  /**\n\t   * Wrapping the validation invocation inside conditionals based upon\n\t   * enabled flags.\n\t   */\n\t  return wrapInConditional(\n\t    [bailCondition, implicitCondition],\n\t    isAsync ? `await ${callable}` : `${callable}`\n", "  )\n\t}\n\t/**\n\t * Returns JS fragment for executing validations for a given field.\n\t */\n\texport function defineFieldValidations({\n\t  bail,\n\t  validations,\n\t  variableName,\n\t  dropMissingCheck,\n", "}: ValidationOptions) {\n\t  return `${validations\n\t    .map((one) => emitValidationSnippet(one, variableName, bail, dropMissingCheck))\n\t    .join('\\n')}`\n\t}\n"]}
{"filename": "src/compiler/buffer.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\t/**\n\t * Compiler buffer to collect JS fragments in memory\n", " */\n\texport class CompilerBuffer {\n\t  #content: string = ''\n\t  /**\n\t   * The character used to create a new line\n\t   */\n\t  newLine = '\\n'\n\t  /**\n\t   * Write statement ot the output\n\t   */\n", "  writeStatement(statement: string) {\n\t    this.#content = `${this.#content}${this.newLine}${statement}`\n\t  }\n\t  /**\n\t   * Creates a child buffer\n\t   */\n\t  child() {\n\t    return new CompilerBuffer()\n\t  }\n\t  /**\n", "   * Returns the buffer contents as string\n\t   */\n\t  toString() {\n\t    return this.#content\n\t  }\n\t  /**\n\t   * Flush in-memory string\n\t   */\n\t  flush() {\n\t    this.#content = ''\n", "  }\n\t}\n"]}
{"filename": "src/compiler/main.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { CompilerBuffer } from './buffer.js'\n\timport { TupleNodeCompiler } from './nodes/tuple.js'\n", "import { ArrayNodeCompiler } from './nodes/array.js'\n\timport { UnionNodeCompiler } from './nodes/union.js'\n\timport { RecordNodeCompiler } from './nodes/record.js'\n\timport { ObjectNodeCompiler } from './nodes/object.js'\n\timport { createRootField } from './fields/root_field.js'\n\timport { LiteralNodeCompiler } from './nodes/literal.js'\n\timport { createArrayField } from './fields/array_field.js'\n\timport { createTupleField } from './fields/tuple_field.js'\n\timport { reportErrors } from '../scripts/report_errors.js'\n\timport { createObjectField } from './fields/object_field.js'\n", "import { createRecordField } from './fields/record_field.js'\n\timport { defineInlineFunctions } from '../scripts/define_inline_functions.js'\n\timport { defineInlineErrorMessages } from '../scripts/define_error_messages.js'\n\timport type {\n\t  Refs,\n\t  RootNode,\n\t  CompilerField,\n\t  CompilerNodes,\n\t  CompilerParent,\n\t  CompilerOptions,\n", "  ErrorReporterContract,\n\t  MessagesProviderContact,\n\t} from '../types.js'\n\t/**\n\t * Representation of an async function\n\t */\n\tconst AsyncFunction = Object.getPrototypeOf(async function () {}).constructor\n\t/**\n\t * Compiler is used to compile an array of schema nodes into a re-usable\n\t * JavaScript.\n", " */\n\texport class Compiler {\n\t  /**\n\t   * Variables counter is used to generate unique variable\n\t   * names with a counter suffix.\n\t   */\n\t  variablesCounter: number = 0\n\t  /**\n\t   * An array of nodes to process\n\t   */\n", "  #rootNode: RootNode\n\t  /**\n\t   * Options to configure the compiler behavior\n\t   */\n\t  #options: CompilerOptions\n\t  /**\n\t   * Buffer for collection the JS output string\n\t   */\n\t  #buffer: CompilerBuffer = new CompilerBuffer()\n\t  constructor(rootNode: RootNode, options?: CompilerOptions) {\n", "    this.#rootNode = rootNode\n\t    this.#options = options || { convertEmptyStringsToNull: false }\n\t  }\n\t  /**\n\t   * Initiates the JS output\n\t   */\n\t  #initiateJSOutput() {\n\t    this.#buffer.writeStatement(\n\t      defineInlineErrorMessages({\n\t        required: 'value is required',\n", "        object: 'value is not a valid object',\n\t        array: 'value is not a valid array',\n\t        ...this.#options.messages,\n\t      })\n\t    )\n\t    this.#buffer.writeStatement(defineInlineFunctions(this.#options))\n\t    this.#buffer.writeStatement('let out;')\n\t  }\n\t  /**\n\t   * Finished the JS output\n", "   */\n\t  #finishJSOutput() {\n\t    this.#buffer.writeStatement(reportErrors())\n\t    this.#buffer.writeStatement('return out;')\n\t  }\n\t  /**\n\t   * Compiles all the nodes\n\t   */\n\t  #compileNodes() {\n\t    this.compileNode(this.#rootNode.schema, this.#buffer, {\n", "      type: 'root',\n\t      variableName: 'root',\n\t      outputExpression: 'out',\n\t      fieldPathExpression: 'out',\n\t      wildCardPath: '',\n\t    })\n\t  }\n\t  /**\n\t   * Returns compiled output as a function\n\t   */\n", "  #toAsyncFunction<T extends Record<string, any>>(): (\n\t    data: any,\n\t    meta: Record<string, any>,\n\t    refs: Refs,\n\t    messagesProvider: MessagesProviderContact,\n\t    errorReporter: ErrorReporterContract\n\t  ) => Promise<T> {\n\t    return new AsyncFunction(\n\t      'root',\n\t      'meta',\n", "      'refs',\n\t      'messagesProvider',\n\t      'errorReporter',\n\t      this.#buffer.toString()\n\t    )\n\t  }\n\t  /**\n\t   * Converts a node to a field. Optionally accepts a parent node to create\n\t   * a field for a specific parent type.\n\t   */\n", "  createFieldFor(node: CompilerNodes, parent: CompilerParent) {\n\t    switch (parent.type) {\n\t      case 'array':\n\t        return createArrayField(parent)\n\t      case 'root':\n\t        return createRootField(parent)\n\t      case 'object':\n\t        return createObjectField(node, this.variablesCounter, parent)\n\t      case 'tuple':\n\t        return createTupleField(node, parent)\n", "      case 'record':\n\t        return createRecordField(parent)\n\t    }\n\t  }\n\t  /**\n\t   * Compiles a given compiler node\n\t   */\n\t  compileNode(\n\t    node: CompilerNodes,\n\t    buffer: CompilerBuffer,\n", "    parent: CompilerParent,\n\t    parentField?: CompilerField\n\t  ) {\n\t    switch (node.type) {\n\t      case 'literal':\n\t        return new LiteralNodeCompiler(node, buffer, this, parent, parentField).compile()\n\t      case 'array':\n\t        return new ArrayNodeCompiler(node, buffer, this, parent, parentField).compile()\n\t      case 'record':\n\t        return new RecordNodeCompiler(node, buffer, this, parent, parentField).compile()\n", "      case 'object':\n\t        return new ObjectNodeCompiler(node, buffer, this, parent, parentField).compile()\n\t      case 'tuple':\n\t        return new TupleNodeCompiler(node, buffer, this, parent, parentField).compile()\n\t      case 'union':\n\t        return new UnionNodeCompiler(node, buffer, this, parent, parentField).compile()\n\t    }\n\t  }\n\t  /**\n\t   * Compile schema nodes to an async function\n", "   */\n\t  compile() {\n\t    this.#initiateJSOutput()\n\t    this.#compileNodes()\n\t    this.#finishJSOutput()\n\t    const outputFunction = this.#toAsyncFunction()\n\t    this.variablesCounter = 0\n\t    this.#buffer.flush()\n\t    return outputFunction\n\t  }\n", "}\n"]}
{"filename": "src/compiler/nodes/base.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport type { Compiler } from '../main.js'\n\timport type { CompilerBuffer } from '../buffer.js'\n", "import { defineFieldVariables } from '../../scripts/field/variables.js'\n\timport type { CompilerField, CompilerNodes, CompilerParent } from '../../types.js'\n\texport abstract class BaseNode {\n\t  #node: CompilerNodes\n\t  #parentField?: CompilerField\n\t  protected field: CompilerField\n\t  constructor(\n\t    node: CompilerNodes,\n\t    compiler: Compiler,\n\t    parent: CompilerParent,\n", "    parentField?: CompilerField\n\t  ) {\n\t    this.#parentField = parentField\n\t    this.#node = node\n\t    if (this.#parentField) {\n\t      this.field = this.#parentField\n\t    } else {\n\t      compiler.variablesCounter++\n\t      this.field = compiler.createFieldFor(node, parent)\n\t    }\n", "  }\n\t  protected defineField(buffer: CompilerBuffer) {\n\t    if (!this.#parentField) {\n\t      buffer.writeStatement(\n\t        defineFieldVariables({\n\t          fieldNameExpression: this.field.fieldNameExpression,\n\t          isArrayMember: this.field.isArrayMember,\n\t          parentValueExpression: this.field.parentValueExpression,\n\t          valueExpression: this.field.valueExpression,\n\t          variableName: this.field.variableName,\n", "          wildCardPath: this.field.wildCardPath,\n\t          parseFnRefId: 'parseFnId' in this.#node ? this.#node.parseFnId : undefined,\n\t        })\n\t      )\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/compiler/nodes/literal.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { BaseNode } from './base.js'\n\timport type { Compiler } from '../main.js'\n", "import type { CompilerBuffer } from '../buffer.js'\n\timport { defineFieldValidations } from '../../scripts/field/validations.js'\n\timport { defineFieldNullOutput } from '../../scripts/field/null_output.js'\n\timport { defineFieldValueOutput } from '../../scripts/field/value_output.js'\n\timport type { LiteralNode, CompilerParent, CompilerField } from '../../types.js'\n\timport { defineFieldExistenceValidations } from '../../scripts/field/existence_validations.js'\n\t/**\n\t * Compiles a literal schema node to JS string output.\n\t */\n\texport class LiteralNodeCompiler extends BaseNode {\n", "  #node: LiteralNode\n\t  #buffer: CompilerBuffer\n\t  constructor(\n\t    node: LiteralNode,\n\t    buffer: CompilerBuffer,\n\t    compiler: Compiler,\n\t    parent: CompilerParent,\n\t    parentField?: CompilerField\n\t  ) {\n\t    super(node, compiler, parent, parentField)\n", "    this.#node = node\n\t    this.#buffer = buffer\n\t  }\n\t  compile() {\n\t    /**\n\t     * Define 1: Define field variable\n\t     */\n\t    this.defineField(this.#buffer)\n\t    /**\n\t     * Step 2: Define block to validate the existence of field\n", "     */\n\t    this.#buffer.writeStatement(\n\t      defineFieldExistenceValidations({\n\t        allowNull: this.#node.allowNull,\n\t        isOptional: this.#node.isOptional,\n\t        variableName: this.field.variableName,\n\t      })\n\t    )\n\t    /**\n\t     * Step 3: Define code to run validations on field\n", "     */\n\t    this.#buffer.writeStatement(\n\t      defineFieldValidations({\n\t        variableName: this.field.variableName,\n\t        validations: this.#node.validations,\n\t        bail: this.#node.bail,\n\t        dropMissingCheck: false,\n\t      })\n\t    )\n\t    /**\n", "     * Step 4: Define block to save the output value or the null value\n\t     */\n\t    this.#buffer.writeStatement(\n\t      `${defineFieldValueOutput({\n\t        variableName: this.field.variableName,\n\t        outputExpression: this.field.outputExpression,\n\t        transformFnRefId: this.#node.transformFnId,\n\t      })}${this.#buffer.newLine}${defineFieldNullOutput({\n\t        variableName: this.field.variableName,\n\t        allowNull: this.#node.allowNull,\n", "        outputExpression: this.field.outputExpression,\n\t        transformFnRefId: this.#node.transformFnId,\n\t        conditional: 'else if',\n\t      })}`\n\t    )\n\t  }\n\t}\n"]}
{"filename": "src/compiler/nodes/object.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { BaseNode } from './base.js'\n\timport type { Compiler } from '../main.js'\n", "import type { CompilerBuffer } from '../buffer.js'\n\timport { defineObjectGuard } from '../../scripts/object/guard.js'\n\timport { defineElseCondition } from '../../scripts/define_else_conditon.js'\n\timport { defineIsValidGuard } from '../../scripts/field/is_valid_guard.js'\n\timport { defineFieldNullOutput } from '../../scripts/field/null_output.js'\n\timport { defineFieldValidations } from '../../scripts/field/validations.js'\n\timport { defineConditionalGuard } from '../../scripts/define_conditional_guard.js'\n\timport { defineObjectInitialOutput } from '../../scripts/object/initial_output.js'\n\timport { defineMoveProperties } from '../../scripts/object/move_unknown_properties.js'\n\timport { defineFieldExistenceValidations } from '../../scripts/field/existence_validations.js'\n", "import type { CompilerField, CompilerParent, ObjectNode, ObjectGroupNode } from '../../types.js'\n\t/**\n\t * Compiles an object schema node to JS string output.\n\t */\n\texport class ObjectNodeCompiler extends BaseNode {\n\t  #node: ObjectNode\n\t  #buffer: CompilerBuffer\n\t  #compiler: Compiler\n\t  constructor(\n\t    node: ObjectNode,\n", "    buffer: CompilerBuffer,\n\t    compiler: Compiler,\n\t    parent: CompilerParent,\n\t    parentField?: CompilerField\n\t  ) {\n\t    super(node, compiler, parent, parentField)\n\t    this.#node = node\n\t    this.#buffer = buffer\n\t    this.#compiler = compiler\n\t  }\n", "  /**\n\t   * Returns known field names for the object\n\t   */\n\t  #getFieldNames(node: Pick<ObjectNode, 'properties' | 'groups'>): string[] {\n\t    let fieldNames = node.properties.map((child) => child.fieldName)\n\t    const groupsFieldNames = node.groups.flatMap((group) => this.#getGroupFieldNames(group))\n\t    return fieldNames.concat(groupsFieldNames)\n\t  }\n\t  /**\n\t   * Returns field names of a group.\n", "   */\n\t  #getGroupFieldNames(group: ObjectGroupNode): string[] {\n\t    return group.conditions.flatMap((condition) => {\n\t      return this.#getFieldNames(condition.schema)\n\t    })\n\t  }\n\t  /**\n\t   * Compiles object children to JS output\n\t   */\n\t  #compileObjectChildren() {\n", "    const buffer = this.#buffer.child()\n\t    const parent = {\n\t      type: 'object',\n\t      fieldPathExpression: this.field.fieldPathExpression,\n\t      outputExpression: this.field.outputExpression,\n\t      variableName: this.field.variableName,\n\t      wildCardPath: this.field.wildCardPath,\n\t    } as const\n\t    this.#node.properties.forEach((child) => this.#compiler.compileNode(child, buffer, parent))\n\t    return buffer.toString()\n", "  }\n\t  /**\n\t   * Compiles object groups with conditions to JS output.\n\t   */\n\t  #compileObjectGroups() {\n\t    const buffer = this.#buffer.child()\n\t    const parent = {\n\t      type: 'object',\n\t      fieldPathExpression: this.field.fieldPathExpression,\n\t      outputExpression: this.field.outputExpression,\n", "      variableName: this.field.variableName,\n\t      wildCardPath: this.field.wildCardPath,\n\t    } as const\n\t    this.#node.groups.forEach((group) => this.#compileObjectGroup(group, buffer, parent))\n\t    return buffer.toString()\n\t  }\n\t  /**\n\t   * Compiles an object groups recursively\n\t   */\n\t  #compileObjectGroup(group: ObjectGroupNode, buffer: CompilerBuffer, parent: CompilerParent) {\n", "    group.conditions.forEach((condition, index) => {\n\t      const guardBuffer = buffer.child()\n\t      condition.schema.properties.forEach((child) => {\n\t        this.#compiler.compileNode(child, guardBuffer, parent)\n\t      })\n\t      condition.schema.groups.forEach((child) => {\n\t        this.#compileObjectGroup(child, guardBuffer, parent)\n\t      })\n\t      buffer.writeStatement(\n\t        defineConditionalGuard({\n", "          variableName: this.field.variableName,\n\t          conditional: index === 0 ? 'if' : 'else if',\n\t          conditionalFnRefId: condition.conditionalFnRefId,\n\t          guardedCodeSnippet: guardBuffer.toString(),\n\t        })\n\t      )\n\t    })\n\t    /**\n\t     * Define else block\n\t     */\n", "    if (group.elseConditionalFnRefId && group.conditions.length) {\n\t      buffer.writeStatement(\n\t        defineElseCondition({\n\t          variableName: this.field.variableName,\n\t          conditionalFnRefId: group.elseConditionalFnRefId,\n\t        })\n\t      )\n\t    }\n\t  }\n\t  compile() {\n", "    /**\n\t     * Define 1: Define field variable\n\t     */\n\t    this.defineField(this.#buffer)\n\t    /**\n\t     * Step 2: Define code to validate the existence of field.\n\t     */\n\t    this.#buffer.writeStatement(\n\t      defineFieldExistenceValidations({\n\t        allowNull: this.#node.allowNull,\n", "        isOptional: this.#node.isOptional,\n\t        variableName: this.field.variableName,\n\t      })\n\t    )\n\t    /**\n\t     * Wrapping initialization of output + object children validations\n\t     * validation inside `if object field is valid` block.\n\t     *\n\t     * Pre step: 3\n\t     */\n", "    const isObjectValidBlock = defineIsValidGuard({\n\t      variableName: this.field.variableName,\n\t      bail: this.#node.bail,\n\t      guardedCodeSnippet: `${defineObjectInitialOutput({\n\t        variableName: this.field.variableName,\n\t        outputExpression: this.field.outputExpression,\n\t        outputValueExpression: '{}',\n\t      })}${this.#buffer.newLine}${this.#compileObjectChildren()}${\n\t        this.#buffer.newLine\n\t      }${this.#compileObjectGroups()}${this.#buffer.newLine}${defineMoveProperties({\n", "        variableName: this.field.variableName,\n\t        allowUnknownProperties: this.#node.allowUnknownProperties,\n\t        fieldsToIgnore: this.#node.allowUnknownProperties ? this.#getFieldNames(this.#node) : [],\n\t      })}`,\n\t    })\n\t    /**\n\t     * Wrapping field validations + \"isObjectValidBlock\" inside\n\t     * `if value is object` check.\n\t     *\n\t     * Pre step: 3\n", "     */\n\t    const isValueAnObject = defineObjectGuard({\n\t      variableName: this.field.variableName,\n\t      guardedCodeSnippet: `${defineFieldValidations({\n\t        variableName: this.field.variableName,\n\t        validations: this.#node.validations,\n\t        bail: this.#node.bail,\n\t        dropMissingCheck: true,\n\t      })}${isObjectValidBlock}`,\n\t    })\n", "    /**\n\t     * Step 3: Define `if value is an object` block and `else if value is null`\n\t     * block.\n\t     */\n\t    this.#buffer.writeStatement(\n\t      `${isValueAnObject}${this.#buffer.newLine}${defineFieldNullOutput({\n\t        variableName: this.field.variableName,\n\t        allowNull: this.#node.allowNull,\n\t        outputExpression: this.field.outputExpression,\n\t        conditional: 'else if',\n", "      })}`\n\t    )\n\t  }\n\t}\n"]}
{"filename": "src/compiler/nodes/array.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { BaseNode } from './base.js'\n\timport type { Compiler } from '../main.js'\n", "import type { CompilerBuffer } from '../buffer.js'\n\timport { defineArrayLoop } from '../../scripts/array/loop.js'\n\timport { defineArrayGuard } from '../../scripts/array/guard.js'\n\timport { defineIsValidGuard } from '../../scripts/field/is_valid_guard.js'\n\timport { defineFieldNullOutput } from '../../scripts/field/null_output.js'\n\timport { defineFieldValidations } from '../../scripts/field/validations.js'\n\timport type { CompilerField, CompilerParent, ArrayNode } from '../../types.js'\n\timport { defineArrayInitialOutput } from '../../scripts/array/initial_output.js'\n\timport { defineFieldExistenceValidations } from '../../scripts/field/existence_validations.js'\n\t/**\n", " * Compiles an array schema node to JS string output.\n\t */\n\texport class ArrayNodeCompiler extends BaseNode {\n\t  #node: ArrayNode\n\t  #buffer: CompilerBuffer\n\t  #compiler: Compiler\n\t  constructor(\n\t    node: ArrayNode,\n\t    buffer: CompilerBuffer,\n\t    compiler: Compiler,\n", "    parent: CompilerParent,\n\t    parentField?: CompilerField\n\t  ) {\n\t    super(node, compiler, parent, parentField)\n\t    this.#node = node\n\t    this.#buffer = buffer\n\t    this.#compiler = compiler\n\t  }\n\t  /**\n\t   * Compiles the array elements to a JS fragment\n", "   */\n\t  #compileArrayElements() {\n\t    const arrayElementsBuffer = this.#buffer.child()\n\t    this.#compiler.compileNode(this.#node.each, arrayElementsBuffer, {\n\t      type: 'array',\n\t      fieldPathExpression: this.field.fieldPathExpression,\n\t      outputExpression: this.field.outputExpression,\n\t      variableName: this.field.variableName,\n\t      wildCardPath: this.field.wildCardPath,\n\t    })\n", "    const buffer = this.#buffer.child()\n\t    buffer.writeStatement(\n\t      defineArrayLoop({\n\t        variableName: this.field.variableName,\n\t        startingIndex: 0,\n\t        loopCodeSnippet: arrayElementsBuffer.toString(),\n\t      })\n\t    )\n\t    arrayElementsBuffer.flush()\n\t    return buffer.toString()\n", "  }\n\t  compile() {\n\t    /**\n\t     * Define 1: Define field variable\n\t     */\n\t    this.defineField(this.#buffer)\n\t    /**\n\t     * Step 2: Define code to validate the existence of field.\n\t     */\n\t    this.#buffer.writeStatement(\n", "      defineFieldExistenceValidations({\n\t        allowNull: this.#node.allowNull,\n\t        isOptional: this.#node.isOptional,\n\t        variableName: this.field.variableName,\n\t      })\n\t    )\n\t    /**\n\t     * Wrapping initialization of output + array elements\n\t     * validation inside `if array field is valid` block.\n\t     *\n", "     * Pre step: 3\n\t     */\n\t    const isArrayValidBlock = defineIsValidGuard({\n\t      variableName: this.field.variableName,\n\t      bail: this.#node.bail,\n\t      guardedCodeSnippet: `${defineArrayInitialOutput({\n\t        variableName: this.field.variableName,\n\t        outputExpression: this.field.outputExpression,\n\t        outputValueExpression: `[]`,\n\t      })}${this.#buffer.newLine}${this.#compileArrayElements()}`,\n", "    })\n\t    /**\n\t     * Wrapping field validations + \"isArrayValidBlock\" inside\n\t     * `if value is array` check.\n\t     *\n\t     * Pre step: 3\n\t     */\n\t    const isValueAnArrayBlock = defineArrayGuard({\n\t      variableName: this.field.variableName,\n\t      guardedCodeSnippet: `${defineFieldValidations({\n", "        variableName: this.field.variableName,\n\t        validations: this.#node.validations,\n\t        bail: this.#node.bail,\n\t        dropMissingCheck: true,\n\t      })}${this.#buffer.newLine}${isArrayValidBlock}`,\n\t    })\n\t    /**\n\t     * Step 3: Define `if value is an array` block and `else if value is null`\n\t     * block.\n\t     */\n", "    this.#buffer.writeStatement(\n\t      `${isValueAnArrayBlock}${this.#buffer.newLine}${defineFieldNullOutput({\n\t        allowNull: this.#node.allowNull,\n\t        outputExpression: this.field.outputExpression,\n\t        variableName: this.field.variableName,\n\t        conditional: 'else if',\n\t      })}`\n\t    )\n\t  }\n\t}\n"]}
{"filename": "src/compiler/nodes/union.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { BaseNode } from './base.js'\n\timport type { Compiler } from '../main.js'\n", "import type { CompilerBuffer } from '../buffer.js'\n\timport { callParseFunction } from '../../scripts/union/parse.js'\n\timport { defineElseCondition } from '../../scripts/define_else_conditon.js'\n\timport type { CompilerField, CompilerParent, UnionNode } from '../../types.js'\n\timport { defineConditionalGuard } from '../../scripts/define_conditional_guard.js'\n\t/**\n\t * Compiles a union schema node to JS string output.\n\t */\n\texport class UnionNodeCompiler extends BaseNode {\n\t  #compiler: Compiler\n", "  #node: UnionNode\n\t  #buffer: CompilerBuffer\n\t  #parent: CompilerParent\n\t  constructor(\n\t    node: UnionNode,\n\t    buffer: CompilerBuffer,\n\t    compiler: Compiler,\n\t    parent: CompilerParent,\n\t    parentField?: CompilerField\n\t  ) {\n", "    super(node, compiler, parent, parentField)\n\t    this.#node = node\n\t    this.#buffer = buffer\n\t    this.#parent = parent\n\t    this.#compiler = compiler\n\t  }\n\t  /**\n\t   * Compiles union children by wrapping each conditon inside a conditional\n\t   * guard block\n\t   */\n", "  #compileUnionChildren() {\n\t    const childrenBuffer = this.#buffer.child()\n\t    this.#node.conditions.forEach((child, index) => {\n\t      const conditionalBuffer = this.#buffer.child()\n\t      /**\n\t       * Parse the value once the condition is true\n\t       */\n\t      if ('parseFnId' in child.schema) {\n\t        conditionalBuffer.writeStatement(\n\t          callParseFunction({\n", "            parseFnRefId: child.schema.parseFnId,\n\t            variableName: this.field.variableName,\n\t          })\n\t        )\n\t      }\n\t      this.#compiler.compileNode(child.schema, conditionalBuffer, this.#parent, this.field)\n\t      childrenBuffer.writeStatement(\n\t        defineConditionalGuard({\n\t          conditional: index === 0 ? 'if' : 'else if',\n\t          variableName: this.field.variableName,\n", "          conditionalFnRefId: child.conditionalFnRefId,\n\t          guardedCodeSnippet: conditionalBuffer.toString(),\n\t        })\n\t      )\n\t      conditionalBuffer.flush()\n\t    })\n\t    /**\n\t     * Define else block\n\t     */\n\t    if (this.#node.elseConditionalFnRefId && this.#node.conditions.length) {\n", "      childrenBuffer.writeStatement(\n\t        defineElseCondition({\n\t          variableName: this.field.variableName,\n\t          conditionalFnRefId: this.#node.elseConditionalFnRefId,\n\t        })\n\t      )\n\t    }\n\t    return childrenBuffer.toString()\n\t  }\n\t  compile() {\n", "    /**\n\t     * Define 1: Define field variable\n\t     */\n\t    this.defineField(this.#buffer)\n\t    /**\n\t     * Step 2: Compile union children wrapped inside predicate\n\t     * condition.\n\t     */\n\t    this.#buffer.writeStatement(this.#compileUnionChildren())\n\t  }\n", "}\n"]}
{"filename": "src/compiler/nodes/record.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { BaseNode } from './base.js'\n\timport type { Compiler } from '../main.js'\n", "import type { CompilerBuffer } from '../buffer.js'\n\timport { defineRecordLoop } from '../../scripts/record/loop.js'\n\timport { defineObjectGuard } from '../../scripts/object/guard.js'\n\timport { defineFieldNullOutput } from '../../scripts/field/null_output.js'\n\timport { defineIsValidGuard } from '../../scripts/field/is_valid_guard.js'\n\timport { defineFieldValidations } from '../../scripts/field/validations.js'\n\timport type { CompilerField, CompilerParent, RecordNode } from '../../types.js'\n\timport { defineObjectInitialOutput } from '../../scripts/object/initial_output.js'\n\timport { defineFieldExistenceValidations } from '../../scripts/field/existence_validations.js'\n\t/**\n", " * Compiles a record schema node to JS string output.\n\t */\n\texport class RecordNodeCompiler extends BaseNode {\n\t  #node: RecordNode\n\t  #buffer: CompilerBuffer\n\t  #compiler: Compiler\n\t  constructor(\n\t    node: RecordNode,\n\t    buffer: CompilerBuffer,\n\t    compiler: Compiler,\n", "    parent: CompilerParent,\n\t    parentField?: CompilerField\n\t  ) {\n\t    super(node, compiler, parent, parentField)\n\t    this.#node = node\n\t    this.#buffer = buffer\n\t    this.#compiler = compiler\n\t  }\n\t  /**\n\t   * Compiles the record elements to a JS fragment\n", "   */\n\t  #compileRecordElements() {\n\t    const buffer = this.#buffer.child()\n\t    const recordElementsBuffer = this.#buffer.child()\n\t    this.#compiler.compileNode(this.#node.each, recordElementsBuffer, {\n\t      type: 'record',\n\t      fieldPathExpression: this.field.fieldPathExpression,\n\t      outputExpression: this.field.outputExpression,\n\t      variableName: this.field.variableName,\n\t      wildCardPath: this.field.wildCardPath,\n", "    })\n\t    buffer.writeStatement(\n\t      defineRecordLoop({\n\t        variableName: this.field.variableName,\n\t        loopCodeSnippet: recordElementsBuffer.toString(),\n\t      })\n\t    )\n\t    recordElementsBuffer.flush()\n\t    return buffer.toString()\n\t  }\n", "  compile() {\n\t    /**\n\t     * Define 1: Define field variable\n\t     */\n\t    this.defineField(this.#buffer)\n\t    /**\n\t     * Step 2: Define code to validate the existence of field.\n\t     */\n\t    this.#buffer.writeStatement(\n\t      defineFieldExistenceValidations({\n", "        allowNull: this.#node.allowNull,\n\t        isOptional: this.#node.isOptional,\n\t        variableName: this.field.variableName,\n\t      })\n\t    )\n\t    /**\n\t     * Wrapping initialization of output + tuple validation + array elements\n\t     * validation inside `if array field is valid` block.\n\t     *\n\t     * Pre step: 3\n", "     */\n\t    const isObjectValidBlock = defineIsValidGuard({\n\t      variableName: this.field.variableName,\n\t      bail: this.#node.bail,\n\t      guardedCodeSnippet: `${defineObjectInitialOutput({\n\t        variableName: this.field.variableName,\n\t        outputExpression: this.field.outputExpression,\n\t        outputValueExpression: `{}`,\n\t      })}${this.#compileRecordElements()}`,\n\t    })\n", "    /**\n\t     * Wrapping field validations + \"isArrayValidBlock\" inside\n\t     * `if value is array` check.\n\t     *\n\t     * Pre step: 3\n\t     */\n\t    const isValueAnObjectBlock = defineObjectGuard({\n\t      variableName: this.field.variableName,\n\t      guardedCodeSnippet: `${defineFieldValidations({\n\t        variableName: this.field.variableName,\n", "        validations: this.#node.validations,\n\t        bail: this.#node.bail,\n\t        dropMissingCheck: true,\n\t      })}${this.#buffer.newLine}${isObjectValidBlock}`,\n\t    })\n\t    /**\n\t     * Step 3: Define `if value is an object` block and `else if value is null`\n\t     * block.\n\t     */\n\t    this.#buffer.writeStatement(\n", "      `${isValueAnObjectBlock}${this.#buffer.newLine}${defineFieldNullOutput({\n\t        allowNull: this.#node.allowNull,\n\t        outputExpression: this.field.outputExpression,\n\t        variableName: this.field.variableName,\n\t        conditional: 'else if',\n\t      })}`\n\t    )\n\t  }\n\t}\n"]}
{"filename": "src/compiler/nodes/tuple.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport { BaseNode } from './base.js'\n\timport type { Compiler } from '../main.js'\n", "import type { CompilerBuffer } from '../buffer.js'\n\timport { defineArrayGuard } from '../../scripts/array/guard.js'\n\timport { defineIsValidGuard } from '../../scripts/field/is_valid_guard.js'\n\timport { defineFieldNullOutput } from '../../scripts/field/null_output.js'\n\timport { defineFieldValidations } from '../../scripts/field/validations.js'\n\timport type { CompilerField, CompilerParent, TupleNode } from '../../types.js'\n\timport { defineArrayInitialOutput } from '../../scripts/array/initial_output.js'\n\timport { defineFieldExistenceValidations } from '../../scripts/field/existence_validations.js'\n\t/**\n\t * Compiles a tuple schema node to JS string output.\n", " */\n\texport class TupleNodeCompiler extends BaseNode {\n\t  #node: TupleNode\n\t  #buffer: CompilerBuffer\n\t  #compiler: Compiler\n\t  constructor(\n\t    node: TupleNode,\n\t    buffer: CompilerBuffer,\n\t    compiler: Compiler,\n\t    parent: CompilerParent,\n", "    parentField?: CompilerField\n\t  ) {\n\t    super(node, compiler, parent, parentField)\n\t    this.#node = node\n\t    this.#buffer = buffer\n\t    this.#compiler = compiler\n\t  }\n\t  /**\n\t   * Compiles the tuple children to a JS fragment\n\t   */\n", "  #compileTupleChildren() {\n\t    const buffer = this.#buffer.child()\n\t    const parent = {\n\t      type: 'tuple',\n\t      fieldPathExpression: this.field.fieldPathExpression,\n\t      outputExpression: this.field.outputExpression,\n\t      variableName: this.field.variableName,\n\t      wildCardPath: this.field.wildCardPath,\n\t    } as const\n\t    this.#node.properties.forEach((child) => {\n", "      this.#compiler.compileNode(child, buffer, parent)\n\t    })\n\t    return buffer.toString()\n\t  }\n\t  compile() {\n\t    /**\n\t     * Define 1: Define field variable\n\t     */\n\t    this.defineField(this.#buffer)\n\t    /**\n", "     * Step 2: Define code to validate the existence of field.\n\t     */\n\t    this.#buffer.writeStatement(\n\t      defineFieldExistenceValidations({\n\t        allowNull: this.#node.allowNull,\n\t        isOptional: this.#node.isOptional,\n\t        variableName: this.field.variableName,\n\t      })\n\t    )\n\t    /**\n", "     * Wrapping initialization of output + tuple validation\n\t     * validation inside `if array field is valid` block.\n\t     *\n\t     * Pre step: 3\n\t     */\n\t    const isArrayValidBlock = defineIsValidGuard({\n\t      variableName: this.field.variableName,\n\t      bail: this.#node.bail,\n\t      guardedCodeSnippet: `${defineArrayInitialOutput({\n\t        variableName: this.field.variableName,\n", "        outputExpression: this.field.outputExpression,\n\t        outputValueExpression: this.#node.allowUnknownProperties\n\t          ? `copyProperties(${this.field.variableName}.value)`\n\t          : `[]`,\n\t      })}${this.#compileTupleChildren()}`,\n\t    })\n\t    /**\n\t     * Wrapping field validations + \"isArrayValidBlock\" inside\n\t     * `if value is array` check.\n\t     *\n", "     * Pre step: 3\n\t     */\n\t    const isValueAnArrayBlock = defineArrayGuard({\n\t      variableName: this.field.variableName,\n\t      guardedCodeSnippet: `${defineFieldValidations({\n\t        variableName: this.field.variableName,\n\t        validations: this.#node.validations,\n\t        bail: this.#node.bail,\n\t        dropMissingCheck: true,\n\t      })}${this.#buffer.newLine}${isArrayValidBlock}`,\n", "    })\n\t    /**\n\t     * Step 3: Define `if value is an array` block and `else if value is null`\n\t     * block.\n\t     */\n\t    this.#buffer.writeStatement(\n\t      `${isValueAnArrayBlock}${this.#buffer.newLine}${defineFieldNullOutput({\n\t        allowNull: this.#node.allowNull,\n\t        outputExpression: this.field.outputExpression,\n\t        variableName: this.field.variableName,\n", "        conditional: 'else if',\n\t      })}`\n\t    )\n\t  }\n\t}\n"]}
{"filename": "src/compiler/fields/tuple_field.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport type { CompilerField, FieldNode, CompilerParent } from '../../types.js'\n\texport function createTupleField(\n", "  node: Pick<FieldNode, 'fieldName' | 'propertyName'>,\n\t  parent: CompilerParent\n\t): CompilerField {\n\t  /**\n\t   * Commented to see if a use case arrives for using this.\n\t   */\n\t  // const fieldPathExpression =\n\t  //   parent.fieldPathExpression !== `''`\n\t  //     ? `${parent.fieldPathExpression} + '.' + '${node.fieldName}'`\n\t  //     : `'${node.fieldName}'`\n", "  const wildCardPath =\n\t    parent.wildCardPath !== '' ? `${parent.wildCardPath}.${node.fieldName}` : node.fieldName\n\t  return {\n\t    parentValueExpression: `${parent.variableName}.value`,\n\t    fieldNameExpression: `${node.fieldName}`,\n\t    fieldPathExpression: wildCardPath,\n\t    wildCardPath: wildCardPath,\n\t    variableName: `${parent.variableName}_item_${node.fieldName}`,\n\t    valueExpression: `${parent.variableName}.value[${node.fieldName}]`,\n\t    outputExpression: `${parent.variableName}_out[${node.propertyName}]`,\n", "    isArrayMember: true,\n\t  }\n\t}\n"]}
{"filename": "src/compiler/fields/array_field.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport type { CompilerField, CompilerParent } from '../../types.js'\n\texport function createArrayField(parent: CompilerParent): CompilerField {\n", "  /**\n\t   * Commented to see if a use case arrives for using this.\n\t   */\n\t  // const fieldPathExpression =\n\t  //   parent.fieldPathExpression !== `''`\n\t  //     ? `${parent.fieldPathExpression} + '.' + ${parent.variableName}_i`\n\t  //     : `${parent.variableName}_i`\n\t  const wildCardPath = parent.wildCardPath !== '' ? `${parent.wildCardPath}.*` : `*`\n\t  return {\n\t    parentValueExpression: `${parent.variableName}.value`,\n", "    fieldNameExpression: `${parent.variableName}_i`,\n\t    fieldPathExpression: wildCardPath,\n\t    wildCardPath: wildCardPath,\n\t    variableName: `${parent.variableName}_item`,\n\t    valueExpression: `${parent.variableName}.value[${parent.variableName}_i]`,\n\t    outputExpression: `${parent.variableName}_out[${parent.variableName}_i]`,\n\t    isArrayMember: true,\n\t  }\n\t}\n"]}
{"filename": "src/compiler/fields/record_field.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport type { CompilerField, CompilerParent } from '../../types.js'\n\texport function createRecordField(parent: CompilerParent): CompilerField {\n", "  /**\n\t   * Commented to see if a use case arrives for using this.\n\t   */\n\t  // const fieldPathExpression =\n\t  //   parent.fieldPathExpression !== `''`\n\t  //     ? `${parent.fieldPathExpression} + '.' + ${parent.variableName}_i`\n\t  //     : `${parent.variableName}_i`\n\t  const wildCardPath = parent.wildCardPath !== '' ? `${parent.wildCardPath}.*` : `*`\n\t  return {\n\t    parentValueExpression: `${parent.variableName}.value`,\n", "    fieldNameExpression: `${parent.variableName}_i`,\n\t    fieldPathExpression: wildCardPath,\n\t    wildCardPath: wildCardPath,\n\t    variableName: `${parent.variableName}_item`,\n\t    valueExpression: `${parent.variableName}.value[${parent.variableName}_i]`,\n\t    outputExpression: `${parent.variableName}_out[${parent.variableName}_i]`,\n\t    isArrayMember: false,\n\t  }\n\t}\n"]}
{"filename": "src/compiler/fields/object_field.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport type { CompilerField, FieldNode, CompilerParent } from '../../types.js'\n\texport function createObjectField(\n", "  node: Pick<FieldNode, 'fieldName' | 'propertyName'>,\n\t  variablesCounter: number,\n\t  parent: CompilerParent\n\t): CompilerField {\n\t  /**\n\t   * Commented to see if a use case arrives for using this.\n\t   */\n\t  // const fieldPathExpression =\n\t  //   parent.fieldPathExpression !== `''`\n\t  //     ? `${parent.fieldPathExpression} + '.' + '${node.fieldName}'`\n", "  //     : `'${node.fieldName}'`\n\t  const wildCardPath =\n\t    parent.wildCardPath !== '' ? `${parent.wildCardPath}.${node.fieldName}` : node.fieldName\n\t  return {\n\t    parentValueExpression: `${parent.variableName}.value`,\n\t    fieldNameExpression: `'${node.fieldName}'`,\n\t    fieldPathExpression: wildCardPath,\n\t    wildCardPath: wildCardPath,\n\t    variableName: `${node.propertyName}_${variablesCounter}`,\n\t    valueExpression: `${parent.variableName}.value['${node.fieldName}']`,\n", "    outputExpression: `${parent.variableName}_out['${node.propertyName}']`,\n\t    isArrayMember: false,\n\t  }\n\t}\n"]}
{"filename": "src/compiler/fields/root_field.ts", "chunked_list": ["/*\n\t * @vinejs/compiler\n\t *\n\t * (c) VineJS\n\t *\n\t * For the full copyright and license information, please view the LICENSE\n\t * file that was distributed with this source code.\n\t */\n\timport type { CompilerField, CompilerParent } from '../../types.js'\n\texport function createRootField(parent: CompilerParent): CompilerField {\n", "  return {\n\t    parentValueExpression: parent.variableName,\n\t    fieldNameExpression: `''`,\n\t    fieldPathExpression: `''`,\n\t    wildCardPath: '',\n\t    variableName: `${parent.variableName}_item`,\n\t    valueExpression: 'root',\n\t    outputExpression: parent.outputExpression,\n\t    isArrayMember: false,\n\t  }\n", "}\n"]}
