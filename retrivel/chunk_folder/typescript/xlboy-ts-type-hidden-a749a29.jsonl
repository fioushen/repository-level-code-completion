{"filename": "vitest.config.ts", "chunked_list": ["import { defineConfig } from 'vitest/config';\n\texport default defineConfig({\n\t  test: {\n\t    include: ['src/**/*.test.ts'],\n\t    exclude: ['.history/**/*']\n\t  }\n\t});\n"]}
{"filename": "tsup.config.ts", "chunked_list": ["import { defineConfig } from 'tsup';\n\texport default defineConfig({\n\t  entry: ['src/index.ts'],\n\t  format: ['cjs'],\n\t  external: ['vscode'],\n\t  sourcemap: true\n\t});\n"]}
{"filename": "scripts/vsce-package.ts", "chunked_list": ["import { execa } from 'execa';\n\tasync function main(toPublish: boolean) {\n\t  if (toPublish) {\n\t    await execa('vsce', ['publish', '--no-dependencies', '-p', process.env.VSCE_TOKEN!], {\n\t      stdio: 'inherit'\n\t    });\n\t  } else {\n\t    await execa('vsce', ['package', '--no-dependencies'], { stdio: 'inherit' });\n\t  }\n\t}\n", "const args = process.argv.slice(2);\n\tconst toPublish = args.includes('--publish');\n\tmain(toPublish);\n"]}
{"filename": "src/index.ts", "chunked_list": ["import vscode from 'vscode';\n\timport { version } from '../package.json';\n\timport { registerCommand } from './core/command';\n\timport { Config } from './core/config';\n\timport { EditorContext } from './core/editor-context';\n\timport { log } from './core/log';\n\timport { StatusBar } from './core/status-bar';\n\timport { GlobalState } from './core/global-state';\n\texport function activate(vscodeContext: vscode.ExtensionContext) {\n\t  log.appendLine(`TS Type Hidden for VS Code v${version}\\n`);\n", "  if (!Config.i.get().enabled) {\n\t    log.appendLine('Extension disabled, exiting...');\n\t    return;\n\t  }\n\t  GlobalState.init(vscodeContext);\n\t  EditorContext.init();\n\t  StatusBar.init(vscodeContext);\n\t  registerCommand(vscodeContext);\n\t}\n"]}
{"filename": "src/core/config.ts", "chunked_list": ["import type { ReadonlyDeep } from 'type-fest';\n\timport vscode from 'vscode';\n\timport fs from 'fs-extra';\n\timport { log } from './log';\n\timport { TYPE_KIND } from './helpers/type-analyzer/constants';\n\tinterface ExtensionConfig {\n\t  /** @default true */\n\t  enabled: boolean;\n\t  /** @default `{$ExtensionRootPath}/res/type-icon.png` */\n\t  typeIconPath: string;\n", "  /** @default [] */\n\t  ignoreTypeKinds: TYPE_KIND[];\n\t}\n\tconst defaultTypeIconPath = `${__dirname}/../res/type-icon.png`;\n\texport class Config {\n\t  private static _instance: Config;\n\t  /** instance */\n\t  static get i(): Config {\n\t    return (Config._instance ??= new Config());\n\t  }\n", "  get(): ReadonlyDeep<ExtensionConfig> {\n\t    return Object.freeze(this.config);\n\t  }\n\t  private sync() {\n\t    const config = vscode.workspace.getConfiguration('ts-type-hidden');\n\t    this.config = {\n\t      enabled: config.get('enabled', true),\n\t      typeIconPath: config.get('typeIconPath') || defaultTypeIconPath,\n\t      ignoreTypeKinds: config.get('ignoreTypeKinds', [])\n\t    } satisfies ExtensionConfig;\n", "  }\n\t  private config!: ExtensionConfig;\n\t  private watchCallbacks: Array<Function> = [];\n\t  private constructor() {\n\t    this.sync();\n\t    this.verify();\n\t    this.watch();\n\t  }\n\t  update() {\n\t    this.sync();\n", "    log.appendLine(`Config updated:\n\t${JSON.stringify(this.config, null, 2)}\n\t`);\n\t  }\n\t  registerWatchCallback(fn: Function) {\n\t    this.watchCallbacks.push(fn);\n\t  }\n\t  private verify() {\n\t    if (!fs.existsSync(this.config.typeIconPath)) {\n\t      vscode.window.showErrorMessage(\n", "        '[ts-type-hidden configuration]: \\n`typeIconPath` is not a valid path'\n\t      );\n\t      this.config.typeIconPath = defaultTypeIconPath;\n\t    }\n\t    for (let i = this.config.ignoreTypeKinds.length - 1; i >= 0; i--) {\n\t      const typeKindToIgnore = this.config.ignoreTypeKinds[i];\n\t      const isInvalid = !Object.values(TYPE_KIND).includes(typeKindToIgnore);\n\t      if (isInvalid) {\n\t        this.config.ignoreTypeKinds.splice(i, 1);\n\t        vscode.window.showErrorMessage(\n", "          `[ts-type-hidden configuration]: \\n\\`ignoreTypeKinds.${typeKindToIgnore}\\` is not a valid value`\n\t        );\n\t      }\n\t    }\n\t  }\n\t  private watch() {\n\t    vscode.workspace.onDidChangeConfiguration(() => {\n\t      this.update();\n\t      this.verify();\n\t      this.watchCallbacks.forEach(cb => cb());\n", "    });\n\t  }\n\t}\n"]}
{"filename": "src/core/editor-context.ts", "chunked_list": ["import vscode from 'vscode';\n\timport { type AnalyzedType, TypeAnalyzer } from './helpers/type-analyzer';\n\timport { debounce, isEqual } from 'lodash-es';\n\timport { GlobalState } from './global-state';\n\timport { Config } from './config';\n\ttype FoldingRange = Record<'start' | 'end', /* lineNumber */ number>;\n\tinterface EditorInfo {\n\t  code: string;\n\t  analyzedTypes: AnalyzedType[];\n\t  isTSX: boolean;\n", "  foldedTypeRanges: FoldingRange[];\n\t}\n\texport class EditorContext {\n\t  private static _instance: EditorContext;\n\t  /** instance */\n\t  public static get i(): EditorContext {\n\t    if (!EditorContext._instance) {\n\t      throw new Error('EditorContext not initialized');\n\t    }\n\t    return EditorContext._instance;\n", "  }\n\t  public static init() {\n\t    EditorContext._instance = new EditorContext();\n\t  }\n\t  private editors = new Map</* filePath */ string, EditorInfo>();\n\t  private curFocusedTypes: AnalyzedType[] = [];\n\t  private constructor() {\n\t    this.register();\n\t    this.initVisibleEditors();\n\t    this.decoration.init();\n", "    Config.i.registerWatchCallback(this.decoration.refreshIcon);\n\t    if (GlobalState.i.isHiddenMode) this.hideType(true);\n\t  }\n\t  hideType(needToFold = false) {\n\t    const activeEditorWindow = vscode.window.activeTextEditor;\n\t    if (activeEditorWindow && this.utils.isTargetDocument(activeEditorWindow.document)) {\n\t      const activeEditorInfo = this.editors.get(activeEditorWindow.document.fileName);\n\t      if (!activeEditorInfo) return;\n\t      const filteredAnalyzedTypes = activeEditorInfo.analyzedTypes\n\t        .filter(type => !Config.i.get().ignoreTypeKinds.includes(type.kind))\n", "        .filter(type => !this.curFocusedTypes.some(curFType => isEqual(type, curFType)));\n\t      const typeRangesToHide = filteredAnalyzedTypes.map(\n\t        type =>\n\t          new vscode.Range(\n\t            activeEditorWindow.document.positionAt(type.range.pos),\n\t            activeEditorWindow.document.positionAt(type.range.end)\n\t          )\n\t      );\n\t      activeEditorWindow.setDecorations(this.decoration.get().hidden, typeRangesToHide);\n\t      activeEditorWindow.setDecorations(this.decoration.get().icon, typeRangesToHide);\n", "      if (needToFold) {\n\t        setTimeout(() => {\n\t          handleMultiLineFold.call(this, activeEditorWindow, activeEditorInfo);\n\t        }, 200);\n\t        // Q：↑为什么需要 200ms 延时？\n\t        // A：在初次打开文件时，执行了相关代码后走到此方法内时，获取到的 `currentCursorPos` 是不正确的“头位置”\n\t        // A：为什么是头位置？猜测是未初始化好等原因，因而没能及时将光标位置同步到 `selection.active` 中…\n\t      }\n\t    }\n\t    return;\n", "    async function handleMultiLineFold(\n\t      this: EditorContext,\n\t      activeEditorWindow: vscode.TextEditor,\n\t      activeEditorInfo: EditorInfo\n\t    ) {\n\t      const currentCursorPos = activeEditorWindow.selection.active;\n\t      const filteredAnalyzedTypes = activeEditorInfo.analyzedTypes.filter(\n\t        type => !Config.i.get().ignoreTypeKinds.includes(type.kind)\n\t      );\n\t      let foldedCount = 0;\n", "      activeEditorInfo.foldedTypeRanges = [];\n\t      for await (const type of filteredAnalyzedTypes) {\n\t        const typeRange = new vscode.Range(\n\t          activeEditorWindow.document.positionAt(type.range.pos),\n\t          activeEditorWindow.document.positionAt(type.range.end)\n\t        );\n\t        const typeText = activeEditorWindow.document.getText(typeRange);\n\t        const typeLineCount = typeText.split('\\n').length;\n\t        if (typeLineCount > 2) {\n\t          const inFoldingRange = (() => {\n", "            const curFoldingRanges = this.utils.getActiveEditorFoldingRanges();\n\t            for (const curFRange of curFoldingRanges) {\n\t              if (\n\t                curFRange.start <= typeRange.start.line &&\n\t                curFRange.end >= typeRange.end.line\n\t              ) {\n\t                return true;\n\t              }\n\t            }\n\t            return false;\n", "          })();\n\t          if (!inFoldingRange) {\n\t            foldedCount++;\n\t            const lineToFold = {\n\t              start: typeRange.start.line,\n\t              end: typeRange.end.line + 1\n\t            };\n\t            activeEditorWindow.selection = new vscode.Selection(\n\t              lineToFold.start,\n\t              0,\n", "              lineToFold.end,\n\t              0\n\t            );\n\t            activeEditorInfo.foldedTypeRanges.push(lineToFold);\n\t            await vscode.commands.executeCommand(\n\t              'editor.createFoldingRangeFromSelection'\n\t            );\n\t          }\n\t        }\n\t      }\n", "      if (foldedCount > 0) {\n\t        activeEditorWindow.selection = new vscode.Selection(\n\t          currentCursorPos,\n\t          currentCursorPos\n\t        );\n\t        activeEditorWindow.revealRange(\n\t          new vscode.Range(currentCursorPos.line, 0, currentCursorPos.line, 0),\n\t          vscode.TextEditorRevealType.InCenter\n\t        );\n\t      }\n", "    }\n\t  }\n\t  async showType() {\n\t    const activeEditorWindow = vscode.window.activeTextEditor;\n\t    if (activeEditorWindow && this.utils.isTargetDocument(activeEditorWindow.document)) {\n\t      activeEditorWindow.setDecorations(this.decoration.get().hidden, []);\n\t      activeEditorWindow.setDecorations(this.decoration.get().icon, []);\n\t      const curEditorInfo = this.editors.get(activeEditorWindow.document.fileName);\n\t      if (curEditorInfo) {\n\t        const curPos = activeEditorWindow.selection.active;\n", "        for await (const range of curEditorInfo.foldedTypeRanges) {\n\t          activeEditorWindow.selection = new vscode.Selection(\n\t            range.start,\n\t            0,\n\t            range.end,\n\t            0\n\t          );\n\t          await vscode.commands.executeCommand('editor.unfold');\n\t        }\n\t        activeEditorWindow.selection = new vscode.Selection(curPos, curPos);\n", "        activeEditorWindow.revealRange(\n\t          new vscode.Range(curPos.line, 0, curPos.line, 0),\n\t          vscode.TextEditorRevealType.InCenter\n\t        );\n\t      }\n\t    }\n\t  }\n\t  private register() {\n\t    vscode.window.onDidChangeActiveTextEditor(editor => {\n\t      if (editor && this.utils.isTargetDocument(editor.document)) {\n", "        const filePath = editor.document.fileName;\n\t        let isFirstOpen = false;\n\t        if (!this.editors.has(filePath)) {\n\t          isFirstOpen = true;\n\t          const fileCode = editor.document.getText();\n\t          const isTSX = editor.document.languageId === 'typescriptreact';\n\t          this.editors.set(filePath, {\n\t            code: fileCode,\n\t            analyzedTypes: new TypeAnalyzer(fileCode, isTSX).analyze(),\n\t            isTSX,\n", "            foldedTypeRanges: []\n\t          });\n\t        }\n\t        if (GlobalState.i.isHiddenMode) this.hideType(isFirstOpen);\n\t      }\n\t    });\n\t    vscode.workspace.onDidChangeTextDocument(\n\t      debounce<(event: vscode.TextDocumentChangeEvent) => void>(event => {\n\t        const curChangedEditorInfo = this.editors.get(event.document.fileName);\n\t        if (curChangedEditorInfo) {\n", "          const newCode = event.document.getText();\n\t          curChangedEditorInfo.code = newCode;\n\t          curChangedEditorInfo.analyzedTypes = new TypeAnalyzer(\n\t            newCode,\n\t            curChangedEditorInfo.isTSX\n\t          ).analyze();\n\t          this.curFocusedTypes = this.getActiveEditorFocusedTypes();\n\t          if (GlobalState.i.isHiddenMode) this.hideType();\n\t        }\n\t      }, 1000)\n", "    );\n\t    vscode.window.onDidChangeTextEditorSelection(event => {\n\t      if (this.utils.isTargetDocument(event.textEditor.document)) {\n\t        const curEditorInfo = this.editors.get(event.textEditor.document.fileName);\n\t        if (!curEditorInfo) return;\n\t        const focusedTypes = this.getActiveEditorFocusedTypes();\n\t        if (!isEqual(focusedTypes, this.curFocusedTypes)) {\n\t          this.curFocusedTypes = focusedTypes;\n\t          const cursorPositionUpdateOnly =\n\t            curEditorInfo.code === event.textEditor.document.getText();\n", "          if (cursorPositionUpdateOnly && GlobalState.i.isHiddenMode) {\n\t            this.hideType();\n\t          }\n\t        }\n\t      }\n\t    });\n\t  }\n\t  private initVisibleEditors() {\n\t    vscode.window.visibleTextEditors.forEach(editor => {\n\t      if (this.utils.isTargetDocument(editor.document)) {\n", "        const fileCode = editor.document.getText();\n\t        const isTSX = editor.document.languageId === 'typescriptreact';\n\t        this.editors.set(editor.document.fileName, {\n\t          code: fileCode,\n\t          analyzedTypes: new TypeAnalyzer(fileCode, isTSX).analyze(),\n\t          isTSX,\n\t          foldedTypeRanges: []\n\t        });\n\t      }\n\t    });\n", "  }\n\t  private getActiveEditorFocusedTypes() {\n\t    const activeEditorWindow = vscode.window.activeTextEditor;\n\t    if (!activeEditorWindow) return [];\n\t    const curEditrInfo = this.editors.get(activeEditorWindow.document.fileName);\n\t    if (!curEditrInfo) return [];\n\t    const cursorPos = activeEditorWindow.selection.active;\n\t    const cursorOffset = activeEditorWindow.document.offsetAt(cursorPos);\n\t    const focusedTypes = curEditrInfo.analyzedTypes.filter(type => {\n\t      const start = activeEditorWindow.document.positionAt(type.range.pos);\n", "      return (\n\t        cursorPos.line === start.line ||\n\t        (cursorOffset >= type.range.pos && cursorOffset <= type.range.end)\n\t      );\n\t    });\n\t    return focusedTypes;\n\t  }\n\t  private utils = {\n\t    isTargetDocument(document: vscode.TextDocument) {\n\t      return (\n", "        (document.languageId === 'typescript' ||\n\t          document.languageId === 'typescriptreact') &&\n\t        !document.isUntitled &&\n\t        !document.fileName.endsWith('.d.ts')\n\t      );\n\t    },\n\t    getActiveEditorFoldingRanges(): FoldingRange[] {\n\t      const activeEditorWindow = vscode.window.activeTextEditor;\n\t      if (!activeEditorWindow) return [];\n\t      const foldingRanges: FoldingRange[] = [];\n", "      // `[[0, 11], [25, 44]]`, get `[11, 25]`\n\t      activeEditorWindow.visibleRanges.forEach((range, index, visibleRanges) => {\n\t        if (visibleRanges.length === 1 || index === visibleRanges.length - 1) return;\n\t        const endLine = range.end.line;\n\t        const nextStartLine = visibleRanges[index + 1]!.start.line;\n\t        foldingRanges.push({ start: endLine, end: nextStartLine });\n\t      });\n\t      return foldingRanges;\n\t    }\n\t  };\n", "  private decoration = (() => {\n\t    let value: Record<'hidden' | 'icon', vscode.TextEditorDecorationType>;\n\t    const createIcon = () =>\n\t      vscode.window.createTextEditorDecorationType({\n\t        gutterIconPath: vscode.Uri.file(Config.i.get().typeIconPath),\n\t        gutterIconSize: 'contain'\n\t      });\n\t    return {\n\t      get: () => value,\n\t      refreshIcon() {\n", "        value.icon.dispose();\n\t        value.icon = createIcon();\n\t      },\n\t      init() {\n\t        value = {\n\t          hidden: vscode.window.createTextEditorDecorationType({\n\t            textDecoration: 'opacity: 0; font-size: 0; display: none'\n\t          }),\n\t          icon: createIcon()\n\t        };\n", "      }\n\t    };\n\t  })();\n\t}\n"]}
{"filename": "src/core/global-state.ts", "chunked_list": ["import vscode from 'vscode';\n\texport class GlobalState {\n\t  private static _instance: GlobalState;\n\t  /** instance */\n\t  public static get i(): GlobalState {\n\t    if (!GlobalState._instance) {\n\t      throw new Error('GlobalState not initialized');\n\t    }\n\t    return GlobalState._instance;\n\t  }\n", "  public static init(vscodeContext: vscode.ExtensionContext) {\n\t    GlobalState._instance = new GlobalState(vscodeContext);\n\t  }\n\t  private constructor(private readonly vscodeContext: vscode.ExtensionContext) {}\n\t  get isHiddenMode() {\n\t    return this.vscodeContext.globalState.get('isHiddenMode', true);\n\t  }\n\t  set isHiddenMode(value: boolean) {\n\t    this.vscodeContext.globalState.update('isHiddenMode', value);\n\t  }\n", "}\n"]}
{"filename": "src/core/log.ts", "chunked_list": ["import vscode from 'vscode';\n\texport const log = vscode.window.createOutputChannel('TS Type Hidden');\n"]}
{"filename": "src/core/status-bar.ts", "chunked_list": ["import vscode from 'vscode';\n\texport class StatusBar {\n\t  private static _instance: StatusBar;\n\t  /** instance */\n\t  public static get i(): StatusBar {\n\t    if (!StatusBar._instance) {\n\t      throw new Error('StatusBar not initialized');\n\t    }\n\t    return StatusBar._instance;\n\t  }\n", "  public static init(vscodeContext: vscode.ExtensionContext) {\n\t    StatusBar._instance = new StatusBar(vscodeContext);\n\t  }\n\t  private statusBarItem: vscode.StatusBarItem;\n\t  constructor(vscodeContext: vscode.ExtensionContext) {\n\t    const isHiddenMode = vscodeContext.globalState.get('isHiddenMode', true);\n\t    this.statusBarItem = vscode.window.createStatusBarItem();\n\t    this.statusBarItem.command = 'ts-type-hidden.toogle';\n\t    this.statusBarItem.show();\n\t    this.changeStatus(isHiddenMode);\n", "    vscodeContext.subscriptions.push(this.statusBarItem);\n\t  }\n\t  changeStatus(isHiddenMode: boolean) {\n\t    this.statusBarItem.text = isHiddenMode ? 'TH ✅' : 'TH ❌';\n\t    this.statusBarItem.tooltip =\n\t      '[TS Type Hidden] - Click to toggle hidden mode (Current mode: ' +\n\t      (isHiddenMode ? 'On' : 'Off') +\n\t      ')';\n\t  }\n\t}\n"]}
{"filename": "src/core/command.ts", "chunked_list": ["import vscode from 'vscode';\n\timport { EditorContext } from './editor-context';\n\timport { log } from './log';\n\timport { GlobalState } from './global-state';\n\timport { StatusBar } from './status-bar';\n\texport function registerCommand(vscodeContext: vscode.ExtensionContext) {\n\t  vscodeContext.subscriptions.push(\n\t    vscode.commands.registerCommand('ts-type-hidden.toogle', () => {\n\t      GlobalState.i.isHiddenMode = !GlobalState.i.isHiddenMode;\n\t      GlobalState.i.isHiddenMode\n", "        ? EditorContext.i.hideType(true)\n\t        : EditorContext.i.showType();\n\t      StatusBar.i.changeStatus(GlobalState.i.isHiddenMode);\n\t      log.appendLine(\n\t        `[command.toogle] Toogle hidden mode, Current mode: ${\n\t          !GlobalState.i.isHiddenMode ? 'On' : 'Off'\n\t        }`\n\t      );\n\t    }),\n\t    vscode.commands.registerCommand('ts-type-hidden.open', () => {\n", "      log.appendLine(`[command.open] Open hidden mode`);\n\t      GlobalState.i.isHiddenMode = true;\n\t      EditorContext.i.hideType(true);\n\t      StatusBar.i.changeStatus(true);\n\t    }),\n\t    vscode.commands.registerCommand('ts-type-hidden.close', () => {\n\t      log.appendLine(`[command.close] Close hidden mode`);\n\t      GlobalState.i.isHiddenMode = false;\n\t      EditorContext.i.showType();\n\t      StatusBar.i.changeStatus(false);\n", "    })\n\t  );\n\t}\n"]}
{"filename": "src/core/helpers/type-analyzer/index.test.ts", "chunked_list": ["import { describe, expect, it } from 'vitest';\n\timport { TypeAnalyzer } from '.';\n\timport { TYPE_KIND } from './constants';\n\tdescribe('function', () => {\n\t  it('overloading', () => {\n\t    const analyzer = new TypeAnalyzer(`\n\tconst t = 1\n\tfunction a<B extends 222>(): void;\n\tfunction b<A>(o: A): string;\n\t`);\n", "    analyzer.analyze();\n\t    expect(analyzer.analyzedTypes).toMatchObject([\n\t      {\n\t        range: { pos: 14, end: 48 },\n\t        text: 'function a<B extends 222>(): void;',\n\t        kind: TYPE_KIND.FUNCTION_OVERLOAD\n\t      },\n\t      {\n\t        range: { pos: 49, end: 77 },\n\t        text: 'function b<A>(o: A): string;',\n", "        kind: TYPE_KIND.FUNCTION_OVERLOAD\n\t      }\n\t    ]);\n\t  });\n\t  it('function-generic-definition - a`<B extends ...>`()', () => {\n\t    const analyzer = new TypeAnalyzer(\n\t      `\n\tfunction a<B extends 111, C extends 111>() {}\n\tconst b = <B extends 222, C extends 222>() => {};\n\tconst c = function<B extends 333, C extends 333>() {}\n", "const d = {\n\t  a<B extends 444, C extends 444>() {}\n\t}\n\t`\n\t    );\n\t    analyzer.analyze();\n\t    expect(analyzer.analyzedTypes).toMatchObject([\n\t      {\n\t        range: { pos: 11, end: 41 },\n\t        text: '<B extends 111, C extends 111>',\n", "        kind: TYPE_KIND.FUNCTION_GENERIC_DEFINITION\n\t      },\n\t      {\n\t        range: { pos: 57, end: 87 },\n\t        text: '<B extends 222, C extends 222>',\n\t        kind: TYPE_KIND.FUNCTION_GENERIC_DEFINITION\n\t      },\n\t      {\n\t        range: { pos: 115, end: 145 },\n\t        text: '<B extends 333, C extends 333>',\n", "        kind: TYPE_KIND.FUNCTION_GENERIC_DEFINITION\n\t      },\n\t      {\n\t        range: { pos: 166, end: 196 },\n\t        text: '<B extends 444, C extends 444>',\n\t        kind: TYPE_KIND.FUNCTION_GENERIC_DEFINITION\n\t      }\n\t    ]);\n\t  });\n\t  it('function-parameter - (`a: number, b: string, ...`)', () => {\n", "    const analyzer = new TypeAnalyzer(`\n\tfunction a(a1: A111, a2?: A222) {}\n\tconst b = (b1: B111, b2?: B222) => {};\n\tconst c = function(c1: C111, c2?: C222) {}\n\tconst d = {\n\t  e(d1: E111, d2?: E222) {}\n\t  f: (f1: F111, f2?: F222) => {}\n\t}\n\t`);\n\t    analyzer.analyze();\n", "    expect(analyzer.analyzedTypes).toMatchObject([\n\t      {\n\t        range: { pos: 14, end: 20 },\n\t        text: ': A111',\n\t        kind: TYPE_KIND.FUNCTION_PARAMETER\n\t      },\n\t      {\n\t        range: { pos: 24, end: 31 },\n\t        text: '?: A222',\n\t        kind: TYPE_KIND.FUNCTION_PARAMETER\n", "      },\n\t      {\n\t        range: { pos: 49, end: 55 },\n\t        text: ': B111',\n\t        kind: TYPE_KIND.FUNCTION_PARAMETER\n\t      },\n\t      {\n\t        range: { pos: 59, end: 66 },\n\t        text: '?: B222',\n\t        kind: TYPE_KIND.FUNCTION_PARAMETER\n", "      },\n\t      {\n\t        range: { pos: 96, end: 102 },\n\t        text: ': C111',\n\t        kind: TYPE_KIND.FUNCTION_PARAMETER\n\t      },\n\t      {\n\t        range: { pos: 106, end: 113 },\n\t        text: '?: C222',\n\t        kind: TYPE_KIND.FUNCTION_PARAMETER\n", "      },\n\t      {\n\t        range: { pos: 136, end: 142 },\n\t        text: ': E111',\n\t        kind: TYPE_KIND.FUNCTION_PARAMETER\n\t      },\n\t      {\n\t        range: { pos: 146, end: 153 },\n\t        text: '?: E222',\n\t        kind: TYPE_KIND.FUNCTION_PARAMETER\n", "      },\n\t      {\n\t        range: { pos: 166, end: 172 },\n\t        text: ': F111',\n\t        kind: TYPE_KIND.FUNCTION_PARAMETER\n\t      },\n\t      {\n\t        range: { pos: 176, end: 183 },\n\t        text: '?: F222',\n\t        kind: TYPE_KIND.FUNCTION_PARAMETER\n", "      }\n\t    ]);\n\t  });\n\t  it('function-return - ()`: number`', () => {\n\t    const analyzer = new TypeAnalyzer(`n\n\tfunction a(): A111 {}\n\tconst b = (): B111 => {};\n\tconst c = function(): C111 {}\n\tconst d = {\n\t  d(): D111 {}\n", "  e: (): E111 => {}\n\t}\n\t`);\n\t    analyzer.analyze();\n\t    expect(analyzer.analyzedTypes).toMatchObject([\n\t      {\n\t        range: { pos: 14, end: 20 },\n\t        text: ': A111',\n\t        kind: TYPE_KIND.FUNCTION_RETURN\n\t      },\n", "      {\n\t        range: { pos: 36, end: 42 },\n\t        text: ': B111',\n\t        kind: TYPE_KIND.FUNCTION_RETURN\n\t      },\n\t      {\n\t        range: { pos: 70, end: 76 },\n\t        text: ': C111',\n\t        kind: TYPE_KIND.FUNCTION_RETURN\n\t      },\n", "      {\n\t        range: { pos: 97, end: 103 },\n\t        text: ': D111',\n\t        kind: TYPE_KIND.FUNCTION_RETURN\n\t      },\n\t      {\n\t        range: { pos: 114, end: 120 },\n\t        text: ': E111',\n\t        kind: TYPE_KIND.FUNCTION_RETURN\n\t      }\n", "    ]);\n\t  });\n\t  it('function-type-predicate - (a: any)`: asserts a is ...)`', () => {\n\t    const analyzer = new TypeAnalyzer(`\n\tfunction a(value): asserts a is aaa {}\n\tconst b = (value): asserts b is bbb => {};\n\tconst c = function (value): asserts d is ddd {};\n\tconst d = {\n\t  e(value): asserts e is eee {},\n\t  f: (value): asserts f is fff => {}\n", "};\n\t`);\n\t    analyzer.analyze();\n\t    expect(analyzer.analyzedTypes).toMatchObject([\n\t      {\n\t        range: { pos: 18, end: 36 },\n\t        text: ': asserts a is aaa',\n\t        kind: TYPE_KIND.FUNCTION_TYPE_PREDICATE\n\t      },\n\t      {\n", "        range: { pos: 58, end: 76 },\n\t        text: ': asserts b is bbb',\n\t        kind: TYPE_KIND.FUNCTION_TYPE_PREDICATE\n\t      },\n\t      {\n\t        range: { pos: 111, end: 129 },\n\t        text: ': asserts d is ddd',\n\t        kind: TYPE_KIND.FUNCTION_TYPE_PREDICATE\n\t      },\n\t      {\n", "        range: { pos: 157, end: 175 },\n\t        text: ': asserts e is eee',\n\t        kind: TYPE_KIND.FUNCTION_TYPE_PREDICATE\n\t      },\n\t      {\n\t        range: { pos: 192, end: 210 },\n\t        text: ': asserts f is fff',\n\t        kind: TYPE_KIND.FUNCTION_TYPE_PREDICATE\n\t      }\n\t    ]);\n", "  });\n\t});\n\tit('interface', () => {\n\t  const analyzer = new TypeAnalyzer(`\n\tinterface t {};\n\tinterface A111 {\n\t  a: number;\n\t  b: string;\n\t  c: {\n\t    e: 1\n", "  }\n\t}`);\n\t  analyzer.analyze();\n\t  expect(analyzer.analyzedTypes).toMatchObject([\n\t    {\n\t      range: { pos: 1, end: 15 },\n\t      text: 'interface t {}',\n\t      kind: TYPE_KIND.INTERFACE\n\t    },\n\t    {\n", "      range: { pos: 17, end: 81 },\n\t      text: 'interface A111 {\\n  a: number;\\n  b: string;\\n  c: {\\n    e: 1\\n  }\\n}',\n\t      kind: TYPE_KIND.INTERFACE\n\t    }\n\t  ]);\n\t});\n\tit('type alias', () => {\n\t  const analyzer = new TypeAnalyzer(`\n\ttype t = number;\n\ttype A111  = {\n", "  a: number;\n\t} | 123 & {}`);\n\t  analyzer.analyze();\n\t  expect(analyzer.analyzedTypes).toMatchObject([\n\t    {\n\t      range: { pos: 1, end: 17 },\n\t      text: 'type t = number;',\n\t      kind: TYPE_KIND.TYPE_ALIAS\n\t    },\n\t    {\n", "      range: { pos: 18, end: 58 },\n\t      text: 'type A111  = {\\n  a: number;\\n} | 123 & {}',\n\t      kind: TYPE_KIND.TYPE_ALIAS\n\t    }\n\t  ]);\n\t});\n\tit('variable type definition', () => {\n\t  const analyzer = new TypeAnalyzer(`\n\tconst a = 1;\n\tdeclare const b: number, c: string;\n", "const d: number, e: string;\n\tconst eee: null | string = ''\n\tlet fff!: string = ''\n\tusing ggg: usingAny = fn();\n\t`);\n\t  analyzer.analyze();\n\t  expect(analyzer.analyzedTypes).toMatchObject([\n\t    {\n\t      range: { pos: 14, end: 49 },\n\t      text: 'declare const b: number, c: string;',\n", "      kind: TYPE_KIND.DECLARE_STATEMENT\n\t    },\n\t    {\n\t      range: { pos: 57, end: 65 },\n\t      text: ': number',\n\t      kind: TYPE_KIND.VARIABLE_TYPE_DEFINITION\n\t    },\n\t    {\n\t      range: { pos: 68, end: 76 },\n\t      text: ': string',\n", "      kind: TYPE_KIND.VARIABLE_TYPE_DEFINITION\n\t    },\n\t    {\n\t      range: { pos: 87, end: 102 },\n\t      text: ': null | string',\n\t      kind: TYPE_KIND.VARIABLE_TYPE_DEFINITION\n\t    },\n\t    {\n\t      range: { pos: 115, end: 124 },\n\t      text: '!: string',\n", "      kind: TYPE_KIND.VARIABLE_TYPE_DEFINITION\n\t    },\n\t    {\n\t      range: { pos: 139, end: 149 },\n\t      text: ': usingAny',\n\t      kind: TYPE_KIND.VARIABLE_TYPE_DEFINITION\n\t    }\n\t  ]);\n\t});\n\tit('declare statement', () => {\n", "  const analyzer = new TypeAnalyzer(`\n\tdeclare const a: number;\n\tdeclare function b(): number;\n\tdeclare class c {}\n\tdeclare module d {}\n\tdeclare namespace e {}\n\tdeclare enum f {}\n\tdeclare global {}\n\tdeclare module 'g' {}\n\t`);\n", "  analyzer.analyze();\n\t  expect(analyzer.analyzedTypes).toMatchObject([\n\t    {\n\t      range: { pos: 1, end: 25 },\n\t      text: 'declare const a: number;',\n\t      kind: TYPE_KIND.DECLARE_STATEMENT\n\t    },\n\t    {\n\t      range: { pos: 26, end: 55 },\n\t      text: 'declare function b(): number;',\n", "      kind: TYPE_KIND.DECLARE_STATEMENT\n\t    },\n\t    {\n\t      range: { pos: 56, end: 74 },\n\t      text: 'declare class c {}',\n\t      kind: TYPE_KIND.DECLARE_STATEMENT\n\t    },\n\t    {\n\t      range: { pos: 75, end: 94 },\n\t      text: 'declare module d {}',\n", "      kind: TYPE_KIND.DECLARE_STATEMENT\n\t    },\n\t    {\n\t      range: { pos: 95, end: 117 },\n\t      text: 'declare namespace e {}',\n\t      kind: TYPE_KIND.DECLARE_STATEMENT\n\t    },\n\t    {\n\t      range: { pos: 118, end: 135 },\n\t      text: 'declare enum f {}',\n", "      kind: TYPE_KIND.DECLARE_STATEMENT\n\t    },\n\t    {\n\t      range: { pos: 136, end: 153 },\n\t      text: 'declare global {}',\n\t      kind: TYPE_KIND.DECLARE_STATEMENT\n\t    },\n\t    {\n\t      range: { pos: 154, end: 175 },\n\t      text: \"declare module 'g' {}\",\n", "      kind: TYPE_KIND.DECLARE_STATEMENT\n\t    }\n\t  ]);\n\t});\n\tit('as expression', () => {\n\t  const analyzer = new TypeAnalyzer(`\n\tconst a = 1 as number;\n\tconst b = 1 as number | string;\n\tconst c = 1 as number | string | null as 111 as 3;\n\t`);\n", "  analyzer.analyze();\n\t  expect(analyzer.analyzedTypes).toMatchObject([\n\t    {\n\t      range: { pos: 12, end: 22 },\n\t      text: ' as number',\n\t      kind: TYPE_KIND.AS_ASSERTION\n\t    },\n\t    {\n\t      range: { pos: 35, end: 54 },\n\t      text: ' as number | string',\n", "      kind: TYPE_KIND.AS_ASSERTION\n\t    },\n\t    {\n\t      range: { pos: 67, end: 93 },\n\t      text: ' as number | string | null',\n\t      kind: TYPE_KIND.AS_ASSERTION\n\t    },\n\t    {\n\t      range: { pos: 93, end: 100 },\n\t      text: ' as 111',\n", "      kind: TYPE_KIND.AS_ASSERTION\n\t    },\n\t    {\n\t      range: { pos: 100, end: 105 },\n\t      text: ' as 3',\n\t      kind: TYPE_KIND.AS_ASSERTION\n\t    }\n\t  ]);\n\t});\n\tit('satisfies expression', () => {\n", "  const analyzer = new TypeAnalyzer(`\n\tconst a = 1 satisfies number;\n\tconst b = 1 satisfies number | string;\n\tconst c = 1 satisfies number | string | null;\n\tconst d = () => {\n\t  return 333 satisfies any\n\t}\n\t`);\n\t  analyzer.analyze();\n\t  expect(analyzer.analyzedTypes).toMatchObject([\n", "    {\n\t      range: { pos: 12, end: 29 },\n\t      text: ' satisfies number',\n\t      kind: TYPE_KIND.SATISFIES_OPERATOR\n\t    },\n\t    {\n\t      range: { pos: 42, end: 68 },\n\t      text: ' satisfies number | string',\n\t      kind: TYPE_KIND.SATISFIES_OPERATOR\n\t    },\n", "    {\n\t      range: { pos: 81, end: 114 },\n\t      text: ' satisfies number | string | null',\n\t      kind: TYPE_KIND.SATISFIES_OPERATOR\n\t    },\n\t    {\n\t      range: { pos: 147, end: 161 },\n\t      text: ' satisfies any',\n\t      kind: TYPE_KIND.SATISFIES_OPERATOR\n\t    }\n", "  ]);\n\t});\n\tit('satisfies & as', () => {\n\t  const analyzer = new TypeAnalyzer(`\n\tconst a = {} satisfies {} as const;\n\tconst b = {} as const satisfies {};\n\t`);\n\t  analyzer.analyze();\n\t  expect(analyzer.analyzedTypes).toMatchObject([\n\t    {\n", "      kind: TYPE_KIND.SATISFIES_OPERATOR,\n\t      range: { pos: 13, end: 26 },\n\t      text: ' satisfies {}'\n\t    },\n\t    {\n\t      kind: TYPE_KIND.AS_ASSERTION,\n\t      range: { pos: 26, end: 35 },\n\t      text: ' as const'\n\t    },\n\t    {\n", "      kind: TYPE_KIND.AS_ASSERTION,\n\t      range: { pos: 49, end: 58 },\n\t      text: ' as const'\n\t    },\n\t    {\n\t      kind: TYPE_KIND.SATISFIES_OPERATOR,\n\t      range: { pos: 58, end: 71 },\n\t      text: ' satisfies {}'\n\t    }\n\t  ]);\n", "});\n\tit('type assertion', () => {\n\t  const analyzer = new TypeAnalyzer(`\n\tconst a =<number>1;\n\tconst b = <number | string>1;\n\tconst c = <number | string | null>1;\n\t`);\n\t  analyzer.analyze();\n\t  expect(analyzer.analyzedTypes).toMatchObject([\n\t    {\n", "      range: { pos: 10, end: 18 },\n\t      text: '<number>',\n\t      kind: TYPE_KIND.ANGLE_BRACKETS_ASSERTION\n\t    },\n\t    {\n\t      range: { pos: 31, end: 48 },\n\t      text: '<number | string>',\n\t      kind: TYPE_KIND.ANGLE_BRACKETS_ASSERTION\n\t    },\n\t    {\n", "      range: { pos: 61, end: 85 },\n\t      text: '<number | string | null>',\n\t      kind: TYPE_KIND.ANGLE_BRACKETS_ASSERTION\n\t    }\n\t  ]);\n\t});\n\tit('call expression', () => {\n\t  const analyzer = new TypeAnalyzer(`\n\tb<number>();\n\tnew d<number, string>();\n", "f<number, string, null>();\n\tnew Set<PersistListener<S>>()\n\t`);\n\t  analyzer.analyze();\n\t  expect(analyzer.analyzedTypes).toMatchObject([\n\t    {\n\t      range: { pos: 2, end: 10 },\n\t      text: '<number>',\n\t      kind: TYPE_KIND.FUNCTION_CALL_GENERIC\n\t    },\n", "    {\n\t      range: { pos: 19, end: 35 },\n\t      text: '<number, string>',\n\t      kind: TYPE_KIND.FUNCTION_CALL_GENERIC\n\t    },\n\t    {\n\t      range: { pos: 40, end: 62 },\n\t      text: '<number, string, null>',\n\t      kind: TYPE_KIND.FUNCTION_CALL_GENERIC\n\t    },\n", "    {\n\t      range: { end: 93, pos: 73 },\n\t      text: '<PersistListener<S>>',\n\t      kind: TYPE_KIND.FUNCTION_CALL_GENERIC\n\t    }\n\t  ]);\n\t});\n\tdescribe('class', () => {\n\t  it('property type definition', () => {\n\t    const analyzer = new TypeAnalyzer(`\n", "class A {\n\t  a: number;\n\t  public b: string;\n\t  protected c: {\n\t    e: 1\n\t  }\n\t  private d: () => void = () => {}\n\t  e!: boolean;\n\t  g?: string; \n\t}\n", "  `);\n\t    analyzer.analyze();\n\t    expect(analyzer.analyzedTypes).toMatchObject([\n\t      {\n\t        range: { pos: 14, end: 22 },\n\t        text: ': number',\n\t        kind: TYPE_KIND.CLASS_PROPERTY_TYPE_DEFINITION\n\t      },\n\t      {\n\t        range: { pos: 34, end: 42 },\n", "        text: ': string',\n\t        kind: TYPE_KIND.CLASS_PROPERTY_TYPE_DEFINITION\n\t      },\n\t      {\n\t        range: { pos: 57, end: 73 },\n\t        text: ': {\\n    e: 1\\n  }',\n\t        kind: TYPE_KIND.CLASS_PROPERTY_TYPE_DEFINITION\n\t      },\n\t      {\n\t        range: { pos: 85, end: 97 },\n", "        text: ': () => void',\n\t        kind: TYPE_KIND.CLASS_PROPERTY_TYPE_DEFINITION\n\t      },\n\t      {\n\t        range: { pos: 112, end: 122 },\n\t        text: '!: boolean',\n\t        kind: TYPE_KIND.CLASS_PROPERTY_TYPE_DEFINITION\n\t      },\n\t      {\n\t        range: { end: 136, pos: 127 },\n", "        text: '?: string',\n\t        kind: TYPE_KIND.CLASS_PROPERTY_TYPE_DEFINITION\n\t      }\n\t    ]);\n\t  });\n\t  it('method declaration', () => {\n\t    const analyzer = new TypeAnalyzer(`\n\tclass A {\n\t  public a(p: 1): boolean;\n\t  public a(p: 2): number;\n", "  public a(p: 1 | 2): boolean | number {\n\t    return '' as any;\n\t  }\n\t  public b(a: number): string;\n\t  protected c(b: number | 1): {\n\t    e: 1\n\t  }\n\t  protected get compileUtils(): any | 'compileUtils' {\n\t    const abc = {\n\t      getConfig: (): ReadonlyDeep<InnerCompilerConfig> => {\n", "        return getCurrentCompileConfig() as any as unknown;\n\t      },\n\t      b(): void {}\n\t    }\n\t  }\n\t}\n\t  `);\n\t    analyzer.analyze();\n\t    expect(analyzer.analyzedTypes).toMatchObject([\n\t      {\n", "        range: { pos: 11, end: 37 },\n\t        text: '  public a(p: 1): boolean;',\n\t        kind: TYPE_KIND.FUNCTION_OVERLOAD\n\t      },\n\t      {\n\t        range: { pos: 38, end: 63 },\n\t        text: '  public a(p: 2): number;',\n\t        kind: TYPE_KIND.FUNCTION_OVERLOAD\n\t      },\n\t      {\n", "        range: { pos: 76, end: 83 },\n\t        text: ': 1 | 2',\n\t        kind: TYPE_KIND.FUNCTION_PARAMETER\n\t      },\n\t      {\n\t        range: { pos: 84, end: 102 },\n\t        text: ': boolean | number',\n\t        kind: TYPE_KIND.FUNCTION_RETURN\n\t      },\n\t      {\n", "        range: { pos: 118, end: 125 },\n\t        text: ' as any',\n\t        kind: TYPE_KIND.AS_ASSERTION\n\t      },\n\t      {\n\t        range: { pos: 131, end: 161 },\n\t        text: '  public b(a: number): string;',\n\t        kind: TYPE_KIND.FUNCTION_OVERLOAD\n\t      },\n\t      {\n", "        range: { pos: 162, end: 206 },\n\t        text: '  protected c(b: number | 1): {\\n    e: 1\\n  }',\n\t        kind: TYPE_KIND.FUNCTION_OVERLOAD\n\t      },\n\t      {\n\t        range: { pos: 237, end: 259 },\n\t        text: \": any | 'compileUtils'\",\n\t        kind: TYPE_KIND.FUNCTION_RETURN\n\t      },\n\t      {\n", "        range: { pos: 299, end: 334 },\n\t        text: ': ReadonlyDeep<InnerCompilerConfig>',\n\t        kind: TYPE_KIND.FUNCTION_RETURN\n\t      },\n\t      {\n\t        range: { pos: 380, end: 387 },\n\t        text: ' as any',\n\t        kind: TYPE_KIND.AS_ASSERTION\n\t      },\n\t      {\n", "        range: { pos: 387, end: 398 },\n\t        text: ' as unknown',\n\t        kind: TYPE_KIND.AS_ASSERTION\n\t      },\n\t      {\n\t        range: { pos: 418, end: 424 },\n\t        text: ': void',\n\t        kind: TYPE_KIND.FUNCTION_RETURN\n\t      }\n\t    ]);\n", "  });\n\t  it('constructor', () => {\n\t    const analyzer = new TypeAnalyzer(`\n\tclass A {\n\t  constructor(a: number) {}\n\t}\n\t  `);\n\t    analyzer.analyze();\n\t    expect(analyzer.analyzedTypes).toMatchObject([\n\t      {\n", "        range: { pos: 26, end: 34 },\n\t        text: ': number',\n\t        kind: TYPE_KIND.FUNCTION_PARAMETER\n\t      }\n\t    ]);\n\t  });\n\t});\n\tdescribe('tsx', () => {\n\t  it('generic arguments', () => {\n\t    const analyzer = new TypeAnalyzer(\n", "      `\n\t  const a = <Component<number> />\n\t  const b = <A<number, string> />\n\t  const c = <A<number, string, null> />\n\t  const d = <A\n\t    <number, string, null, 1, 2 | 3, [22]>\n\t  />\n\t  `,\n\t      true\n\t    );\n", "    analyzer.analyze();\n\t    expect(analyzer.analyzedTypes).toMatchObject([\n\t      {\n\t        range: { pos: 23, end: 31 },\n\t        text: '<number>',\n\t        kind: TYPE_KIND.TSX_COMPONENT_GENERIC\n\t      },\n\t      {\n\t        range: { pos: 49, end: 65 },\n\t        text: '<number, string>',\n", "        kind: TYPE_KIND.TSX_COMPONENT_GENERIC\n\t      },\n\t      {\n\t        range: { pos: 83, end: 105 },\n\t        text: '<number, string, null>',\n\t        kind: TYPE_KIND.TSX_COMPONENT_GENERIC\n\t      },\n\t      {\n\t        range: { pos: 128, end: 166 },\n\t        text: '<number, string, null, 1, 2 | 3, [22]>',\n", "        kind: TYPE_KIND.TSX_COMPONENT_GENERIC\n\t      }\n\t    ]);\n\t  });\n\t  it('integration', () => {\n\t    const analyzer = new TypeAnalyzer(\n\t      `\n\t  const a = <Component<number>\n\t      name\n\t      test={111 as any}\n", "      t2={\\`...\\${11 as string}\\`}\n\t      {...test as object}\n\t    />\n\t  `,\n\t      true\n\t    );\n\t    analyzer.analyze();\n\t    expect(analyzer.analyzedTypes).toMatchObject([\n\t      {\n\t        range: { pos: 23, end: 31 },\n", "        text: '<number>',\n\t        kind: TYPE_KIND.TSX_COMPONENT_GENERIC\n\t      },\n\t      {\n\t        range: { pos: 58, end: 65 },\n\t        text: ' as any',\n\t        kind: TYPE_KIND.AS_ASSERTION\n\t      },\n\t      {\n\t        range: { pos: 85, end: 95 },\n", "        text: ' as string',\n\t        kind: TYPE_KIND.AS_ASSERTION\n\t      },\n\t      {\n\t        range: { pos: 113, end: 123 },\n\t        text: ' as object',\n\t        kind: TYPE_KIND.AS_ASSERTION\n\t      }\n\t    ]);\n\t  });\n", "});\n"]}
{"filename": "src/core/helpers/type-analyzer/constants.ts", "chunked_list": ["export enum TYPE_KIND {\n\t  /**\n\t   * ```ts\n\t   * type A  = ({ ... } & { ... }) | string[]\n\t   * ```\n\t   * ⏭️  `type A = ({ ... } & { ... }) | string[]`\n\t   */\n\t  TYPE_ALIAS = 'type-alias',\n\t  /**\n\t   * ```ts\n", "   * interface A {\n\t   *   ...\n\t   * }\n\t   * ```\n\t   * ⏭️  `interface A { ... }`\n\t   */\n\t  INTERFACE = 'interface',\n\t  /**\n\t   * ```ts\n\t   * function fn(a: number): number[];\n", "   * function fn(a: number[], opts: { ... }): number[];\n\t   * ```\n\t   * ⏭️  `function fn(a: number): number[];`\n\t   *\n\t   * ⏭️  `function fn(a: number[], opts: { ... }): number[];`\n\t   */\n\t  FUNCTION_OVERLOAD = 'function-overload',\n\t  /**\n\t   * ```ts\n\t   * function fn(): number {}\n", "   * ```\n\t   * ⏭️  `: number`\n\t   */\n\t  FUNCTION_RETURN = 'function-return',\n\t  /**\n\t   * ```ts\n\t   * function fn(a: any): a is number {}\n\t   * ```\n\t   * ⏭️  `: a is number`\n\t   */\n", "  FUNCTION_TYPE_PREDICATE = 'function-type-predicate',\n\t  /**\n\t   * ```ts\n\t   * function fn<A extends string>(a: A, b: number) {}\n\t   * ```\n\t   * ⏭️  `: A`\n\t   *\n\t   * ⏭️  `: number`\n\t   */\n\t  FUNCTION_PARAMETER = 'function-parameter',\n", "  /**\n\t   * ```ts\n\t   * function fn<A extends string, B = [A, '']>() {}\n\t   * ```\n\t   * ⏭️  `<A extends string, B = [A, '']>`\n\t   */\n\t  FUNCTION_GENERIC_DEFINITION = 'function-generic-definition',\n\t  /**\n\t   * ```ts\n\t   * const name = get<UserModule>(userModule, 'info.name');\n", "   * const userModel = new UserModel<UserEntity>({ ... });\n\t   * ```\n\t   * ⏭️  `<UserModule>`\n\t   *\n\t   * ⏭️  `<UserEntity>`\n\t   */\n\t  FUNCTION_CALL_GENERIC = 'function-call-generic',\n\t  /**\n\t   * ```ts\n\t   * const EditUserForm = <ProForm<UserModel> id={userId} />;\n", "   * ```\n\t   * ⏭️  `<UserModel>`\n\t   */\n\t  TSX_COMPONENT_GENERIC = 'tsx-component-generic',\n\t  /**\n\t   * ```ts\n\t   * const a: number = 1;\n\t   * ```\n\t   * ⏭️  `: number`\n\t   */\n", "  VARIABLE_TYPE_DEFINITION = 'variable-type-definition',\n\t  /**\n\t   * ```ts\n\t   * class A {\n\t   *   public size?: number;\n\t   *   private setSize!: Function = () => {}\n\t   * }\n\t   * ```\n\t   * ⏭️  `?: number`\n\t   *\n", "   * ⏭️  `!: Function`\n\t   */\n\t  CLASS_PROPERTY_TYPE_DEFINITION = 'class-property-type-definition',\n\t  /**\n\t   * ```ts\n\t   * const num: any = 77;\n\t   * const num1 = (<number>num).toFixed(2);\n\t   * ```\n\t   * ⏭️  `<number>`\n\t   */\n", "  ANGLE_BRACKETS_ASSERTION = 'angle-brackets-assertion',\n\t  /**\n\t   * ```ts\n\t   * fn() as any;\n\t   * ```\n\t   * ⏭️  ` as any`\n\t   */\n\t  AS_ASSERTION = 'as-assertion',\n\t  /**\n\t   * ```ts\n", "   * const user = { ... } satisfies UserModel;\n\t   * ```\n\t   * ⏭️  ` satisfies UserModel`\n\t   */\n\t  SATISFIES_OPERATOR = 'satisfies-operator',\n\t  /**\n\t   * ```ts\n\t   * declare const a: number;\n\t   * declare function b(): number;\n\t   * declare class c {}\n", "   * declare module d {}\n\t   * declare namespace e {}\n\t   * declare enum f {}\n\t   * declare global {}\n\t   * declare module 'g' {}\n\t   * ```\n\t   * ⏭️  👆 All statements that begin with `declare`\n\t   */\n\t  DECLARE_STATEMENT = 'declare-statement'\n\t}\n"]}
{"filename": "src/core/helpers/type-analyzer/index.ts", "chunked_list": ["import { isEqual } from 'lodash-es';\n\timport ts from 'typescript';\n\timport { TYPE_KIND } from './constants';\n\texport interface AnalyzedType {\n\t  kind: TYPE_KIND;\n\t  range: ts.TextRange;\n\t  text: string;\n\t}\n\texport class TypeAnalyzer {\n\t  public sourceFile: ts.SourceFile;\n", "  public analyzedTypes: AnalyzedType[] = [];\n\t  constructor(code: string, isTSX = false) {\n\t    this.sourceFile = ts.createSourceFile(\n\t      `temp.ts${isTSX ? 'x' : ''}`,\n\t      code,\n\t      ts.ScriptTarget.Latest,\n\t      true,\n\t      isTSX ? ts.ScriptKind.TSX : ts.ScriptKind.TS\n\t    );\n\t  }\n", "  analyze() {\n\t    this.visit(this.sourceFile, null);\n\t    this.cleanAnalyzedTypes();\n\t    return this.analyzedTypes;\n\t  }\n\t  private cleanAnalyzedTypes() {\n\t    clearUselessTypes.call(this);\n\t    clearLineBreakOfStartOrEnd.call(this);\n\t    return;\n\t    function clearLineBreakOfStartOrEnd(this: TypeAnalyzer) {\n", "      this.analyzedTypes.forEach(type => {\n\t        const oldTextLength = type.text.length;\n\t        type.text = type.text.replace(/^[\\r\\n]+/, '');\n\t        const startLineBreakCount = oldTextLength - type.text.length;\n\t        type.text = type.text.replace(/[\\r\\n]+$/, '');\n\t        const endLineBreakCount = oldTextLength - startLineBreakCount - type.text.length;\n\t        type.range.pos += startLineBreakCount;\n\t        type.range.end -= endLineBreakCount;\n\t      });\n\t    }\n", "    // [1]. `declare const a: number`, [2]. `: number`. remove [2]\n\t    function clearUselessTypes(this: TypeAnalyzer) {\n\t      const indexsToRemove = new Set<number>();\n\t      this.analyzedTypes.forEach((type, index) => {\n\t        if (indexsToRemove.has(index)) return;\n\t        this.analyzedTypes.forEach((_type, _index) => {\n\t          if (index === _index || indexsToRemove.has(_index)) return;\n\t          if (isEqual(_type, type)) return indexsToRemove.add(index);\n\t          if (type.range.pos >= _type.range.pos) {\n\t            if (type.range.end < _type.range.end) indexsToRemove.add(index);\n", "          }\n\t        });\n\t      });\n\t      const sortedToRemoveIndexs = Array.from(indexsToRemove).sort((a, b) => b - a);\n\t      sortedToRemoveIndexs.forEach(index => this.analyzedTypes.splice(index, 1));\n\t    }\n\t  }\n\t  private visit(node: ts.Node, parent: ts.Node | null) {\n\t    if (\n\t      ts.isTypeNode(node) ||\n", "      ts.isTypeElement(node) ||\n\t      ts.isTypeOfExpression(node) ||\n\t      ts.isTypeOperatorNode(node) ||\n\t      ts.isTypeParameterDeclaration(node) ||\n\t      ts.isTypePredicateNode(node) ||\n\t      ts.isTypeQueryNode(node) ||\n\t      ts.isTypeReferenceNode(node) ||\n\t      ts.isTypeAliasDeclaration(node) ||\n\t      ts.isInterfaceDeclaration(node) ||\n\t      ts.isTypeLiteralNode(node) ||\n", "      ts.isVariableStatement(node) ||\n\t      ts.isClassDeclaration(node) ||\n\t      ts.isModuleDeclaration(node) ||\n\t      ts.isEnumDeclaration(node)\n\t    ) {\n\t      if (parent) {\n\t        this.handleDifferentNode(parent!, node);\n\t      } else {\n\t        console.error('[Error]: parent is null');\n\t      }\n", "    } else {\n\t      ts.forEachChild(node, child => this.visit(child, node));\n\t    }\n\t  }\n\t  private handleDifferentNode(parent: ts.Node, child: ts.Node) {\n\t    type NodeHandlers = Partial<Record<ts.SyntaxKind, Function>>;\n\t    const parentNodeHandlers: NodeHandlers = {\n\t      [ts.SyntaxKind.FunctionDeclaration]: handleParentFunction.bind(this),\n\t      [ts.SyntaxKind.MethodDeclaration]: handleParentFunction.bind(this),\n\t      [ts.SyntaxKind.FunctionExpression]: handleParentFunction.bind(this),\n", "      [ts.SyntaxKind.ArrowFunction]: handleParentFunction.bind(this),\n\t      [ts.SyntaxKind.GetAccessor]: handleParentFunction.bind(this),\n\t      [ts.SyntaxKind.Parameter]: handleParentParameter.bind(this),\n\t      [ts.SyntaxKind.VariableDeclaration]: handleParentVariableDeclaration.bind(this),\n\t      [ts.SyntaxKind.AsExpression]: handleParentAsOrSatisfiesExpr.bind(this),\n\t      [ts.SyntaxKind.SatisfiesExpression]: handleParentAsOrSatisfiesExpr.bind(this),\n\t      [ts.SyntaxKind.TypeAssertionExpression]: handleParentTypeAssertionExpr.bind(this),\n\t      [ts.SyntaxKind.CallExpression]: handleParentCallOrNewExpr.bind(this),\n\t      [ts.SyntaxKind.NewExpression]: handleParentCallOrNewExpr.bind(this),\n\t      [ts.SyntaxKind.PropertyDeclaration]: handleParentPropertyDeclaration.bind(this),\n", "      [ts.SyntaxKind.JsxSelfClosingElement]: handleParentJsxElement.bind(this)\n\t    };\n\t    const childNodeHandlers: NodeHandlers = {\n\t      [ts.SyntaxKind.InterfaceDeclaration]: handleChildInterfaceOrTypeAlias.bind(this),\n\t      [ts.SyntaxKind.TypeAliasDeclaration]: handleChildInterfaceOrTypeAlias.bind(this),\n\t      [ts.SyntaxKind.VariableStatement]: handleChildDeclareStatement.bind(this),\n\t      [ts.SyntaxKind.ClassDeclaration]: handleChildDeclareStatement.bind(this),\n\t      [ts.SyntaxKind.ModuleDeclaration]: handleChildDeclareStatement.bind(this),\n\t      [ts.SyntaxKind.EnumDeclaration]: handleChildDeclareStatement.bind(this),\n\t      [ts.SyntaxKind.GetAccessor]: handleChildGetOrSetAccessor.bind(this),\n", "      [ts.SyntaxKind.SetAccessor]: handleChildGetOrSetAccessor.bind(this)\n\t    };\n\t    parentNodeHandlers[parent.kind]?.(parent, child);\n\t    childNodeHandlers[child.kind]?.(child);\n\t    return;\n\t    // [tsx] context: `<Component<number, string> .../>`, get `<number, string>`\n\t    function handleParentJsxElement(\n\t      this: TypeAnalyzer,\n\t      parent: ts.JsxSelfClosingElement,\n\t      curChild: ts.Node\n", "    ) {\n\t      if (parent.typeArguments && parent.typeArguments.length > 0) {\n\t        const children = parent.getChildren(this.sourceFile);\n\t        const startIndex = children.findIndex(\n\t          child => child.pos === parent.typeArguments![0].pos\n\t        );\n\t        const endIndex = children.findIndex(\n\t          child => child.pos === parent.typeArguments!.at(-1)!.end\n\t        );\n\t        // <\n", "        const prevNode = children[startIndex - 1];\n\t        // >\n\t        const nextNode = children[endIndex + 1];\n\t        return this.pushAnalyzedType(TYPE_KIND.TSX_COMPONENT_GENERIC, [\n\t          prevNode.end - 1,\n\t          nextNode.pos\n\t        ]);\n\t      }\n\t    }\n\t    // [class] context: `class A { a?: number }`, get `?: number`\n", "    function handleParentPropertyDeclaration(\n\t      this: TypeAnalyzer,\n\t      parent: ts.PropertyDeclaration,\n\t      curChild: ts.Node\n\t    ) {\n\t      if (curChild === parent.type) {\n\t        const children = parent.getChildren(this.sourceFile);\n\t        const index = children.findIndex(child => child.pos === parent.type!.pos);\n\t        // :\n\t        const prevNode = children[index - 1];\n", "        // ? or !\n\t        const operatorNode = children[index - 2];\n\t        const hasOperatorNode = [\n\t          ts.SyntaxKind.QuestionToken,\n\t          ts.SyntaxKind.ExclamationToken\n\t        ].includes(operatorNode.kind);\n\t        return this.pushAnalyzedType(TYPE_KIND.CLASS_PROPERTY_TYPE_DEFINITION, [\n\t          hasOperatorNode ? operatorNode.end - 1 : prevNode.end - 1,\n\t          parent.type!.end\n\t        ]);\n", "      }\n\t    }\n\t    // parent = `fn<number>()` | `new fn<number>()`, get `<number>`(typeArguments)\n\t    function handleParentCallOrNewExpr(\n\t      this: TypeAnalyzer,\n\t      parent: ts.CallExpression | ts.NewExpression,\n\t      curChild: ts.Node\n\t    ) {\n\t      if (parent.typeArguments && parent.typeArguments.length > 0) {\n\t        const children = parent.getChildren(this.sourceFile);\n", "        const startIndex = children.findIndex(\n\t          child => child.pos === parent.typeArguments![0].pos\n\t        );\n\t        const endIndex = children.findIndex(\n\t          child => child.end === parent.typeArguments!.at(-1)!.end\n\t        );\n\t        // <\n\t        const prevNode = children[startIndex - 1];\n\t        // >\n\t        const nextNode = children[endIndex + 1];\n", "        return this.pushAnalyzedType(TYPE_KIND.FUNCTION_CALL_GENERIC, [\n\t          prevNode.end - 1,\n\t          nextNode.pos + 1\n\t        ]);\n\t      }\n\t    }\n\t    // context: `<number>a`, get `<number>`\n\t    function handleParentTypeAssertionExpr(\n\t      this: TypeAnalyzer,\n\t      parent: ts.TypeAssertion,\n", "      curChild: ts.Node\n\t    ) {\n\t      const children = parent.getChildren(this.sourceFile);\n\t      const index = children.findIndex(\n\t        child => child.pos === curChild.pos && child.end === curChild.end\n\t      );\n\t      // <\n\t      const prevNode = children[index - 1];\n\t      // >\n\t      const nextNode = children[index + 1];\n", "      return this.pushAnalyzedType(TYPE_KIND.ANGLE_BRACKETS_ASSERTION, [\n\t        prevNode.end - 1,\n\t        nextNode.pos + 1\n\t      ]);\n\t    }\n\t    // context = `a as number` | `a satisfies number`, curChild = `number`\n\t    function handleParentAsOrSatisfiesExpr(\n\t      this: TypeAnalyzer,\n\t      parent: ts.AsExpression | ts.SatisfiesExpression,\n\t      curChild: ts.Node\n", "    ) {\n\t      const children = parent.getChildren(this.sourceFile);\n\t      const index = children.findIndex(\n\t        child => child.pos === curChild.pos && child.end === curChild.end\n\t      );\n\t      // as, satisfies\n\t      const prevNode = children[index - 1];\n\t      const kind =\n\t        prevNode.kind === ts.SyntaxKind.AsKeyword\n\t          ? TYPE_KIND.AS_ASSERTION\n", "          : TYPE_KIND.SATISFIES_OPERATOR;\n\t      return this.pushAnalyzedType(kind, [prevNode.pos, curChild.end]);\n\t    }\n\t    // VariableStatement, ClassDeclaration, ModuleDeclaration, EnumDeclaration\n\t    function handleChildDeclareStatement(\n\t      this: TypeAnalyzer,\n\t      child:\n\t        | ts.VariableStatement\n\t        | ts.ClassDeclaration\n\t        | ts.ModuleDeclaration\n", "        | ts.EnumDeclaration\n\t    ) {\n\t      const hasDeclareKeyword = child.modifiers?.some(\n\t        modifier => modifier.kind === ts.SyntaxKind.DeclareKeyword\n\t      );\n\t      if (hasDeclareKeyword) {\n\t        this.pushAnalyzedType(TYPE_KIND.DECLARE_STATEMENT, [child.pos, child.end]);\n\t      } else {\n\t        ts.forEachChild(child, _child => this.visit(_child, child));\n\t      }\n", "    }\n\t    // context = `const a: number`, curChild = `number`, get `: number`\n\t    function handleParentVariableDeclaration(\n\t      this: TypeAnalyzer,\n\t      parent: ts.VariableDeclaration,\n\t      curChild: ts.Node\n\t    ) {\n\t      const children = parent.getChildren(this.sourceFile);\n\t      const index = children.findIndex(\n\t        child => child.pos === curChild.pos && child.end === curChild.end\n", "      );\n\t      // :\n\t      const prevNode = children[index - 1];\n\t      // !\n\t      const operatorNode = children[index - 2];\n\t      const hasOperatorNode = operatorNode.kind === ts.SyntaxKind.ExclamationToken;\n\t      this.pushAnalyzedType(TYPE_KIND.VARIABLE_TYPE_DEFINITION, [\n\t        hasOperatorNode ? operatorNode.end - 1 : prevNode.end - 1,\n\t        curChild.end\n\t      ]);\n", "    }\n\t    function handleChildGetOrSetAccessor(\n\t      this: TypeAnalyzer,\n\t      curChild: ts.GetAccessorDeclaration | ts.SetAccessorDeclaration\n\t    ) {\n\t      ts.forEachChild(curChild, _child => this.visit(_child, curChild));\n\t    }\n\t    function handleChildInterfaceOrTypeAlias(\n\t      this: TypeAnalyzer,\n\t      child: ts.InterfaceDeclaration | ts.TypeAliasDeclaration\n", "    ) {\n\t      const kind =\n\t        child.kind === ts.SyntaxKind.InterfaceDeclaration\n\t          ? TYPE_KIND.INTERFACE\n\t          : TYPE_KIND.TYPE_ALIAS;\n\t      this.pushAnalyzedType(kind, [child.pos, child.end]);\n\t    }\n\t    // context = `a: number`, curChild = `number`\n\t    function handleParentParameter(\n\t      this: TypeAnalyzer,\n", "      parent: ts.ParameterDeclaration,\n\t      curChild: ts.Node\n\t    ) {\n\t      const children = parent.getChildren(this.sourceFile);\n\t      const index = children.findIndex(\n\t        child => child.pos === curChild.pos && child.end === curChild.end\n\t      );\n\t      // :\n\t      const prevNode = children[index - 1];\n\t      // ?\n", "      const optionalNode = children[index - 2];\n\t      const hasOptionalNode = optionalNode.kind === ts.SyntaxKind.QuestionToken;\n\t      this.pushAnalyzedType(TYPE_KIND.FUNCTION_PARAMETER, [\n\t        hasOptionalNode ? optionalNode.pos : prevNode.pos,\n\t        curChild.end\n\t      ]);\n\t    }\n\t    // FunctionDeclaration | MethodDeclaration | FunctionExpression\n\t    function handleParentFunction(\n\t      this: TypeAnalyzer,\n", "      parent: ts.FunctionDeclaration | ts.MethodDeclaration | ts.FunctionExpression,\n\t      curChild: ts.Node\n\t    ) {\n\t      const hasDeclareKeyword = parent.modifiers?.some(\n\t        modifier => modifier.kind === ts.SyntaxKind.DeclareKeyword\n\t      );\n\t      if (hasDeclareKeyword) {\n\t        return this.pushAnalyzedType(TYPE_KIND.DECLARE_STATEMENT, [\n\t          parent.pos,\n\t          parent.end\n", "        ]);\n\t      }\n\t      // function a<B extends 222>(test: ...): void;\n\t      const isOverload = parent.body === undefined;\n\t      if (isOverload) {\n\t        // public a<B extends 222>(test: ...): void;\n\t        if (ts.isMethodDeclaration(parent)) {\n\t          let startPos = parent.name.end;\n\t          if (parent.modifiers && parent.modifiers.length > 0) {\n\t            startPos = parent.modifiers[0].pos;\n", "          }\n\t          return this.pushAnalyzedType(TYPE_KIND.FUNCTION_OVERLOAD, [\n\t            startPos,\n\t            parent.end\n\t          ]);\n\t        } else {\n\t          return this.pushAnalyzedType(TYPE_KIND.FUNCTION_OVERLOAD, [\n\t            parent.pos,\n\t            parent.end\n\t          ]);\n", "        }\n\t      }\n\t      const children = parent.getChildren(this.sourceFile);\n\t      const index = children.findIndex(\n\t        child => child.pos === curChild.pos && child.end === curChild.end\n\t      );\n\t      // ↓↓ function a<B extends 222>(test: ...) { ... } ↓↓\n\t      if (ts.isTypeParameterDeclaration(curChild) && parent.typeParameters) {\n\t        // children.slice(startIndex, endIndex) = B extends 222, C extends ...\n\t        const startIndex = children.findIndex(\n", "          child => child.pos === parent.typeParameters!.pos\n\t        );\n\t        const endIndex = children.findIndex(\n\t          child => child.end === parent.typeParameters!.end\n\t        );\n\t        // <\n\t        const prevNode = children[startIndex - 1];\n\t        // >\n\t        const nextNode = children[endIndex + 1];\n\t        return this.pushAnalyzedType(TYPE_KIND.FUNCTION_GENERIC_DEFINITION, [\n", "          prevNode.end - 1,\n\t          nextNode.pos + 1\n\t        ]);\n\t      }\n\t      if (ts.isTypePredicateNode(curChild)) {\n\t        // children[index], node = x is any\n\t        // :\n\t        const prevNode = children[index - 1];\n\t        return this.pushAnalyzedType(TYPE_KIND.FUNCTION_TYPE_PREDICATE, [\n\t          prevNode.end - 1,\n", "          curChild.end\n\t        ]);\n\t      }\n\t      if (parent.type === curChild) {\n\t        // children[index], node = function return type\n\t        // :\n\t        const prevNode = children[index - 1];\n\t        return this.pushAnalyzedType(TYPE_KIND.FUNCTION_RETURN, [\n\t          prevNode.end - 1,\n\t          curChild.end\n", "        ]);\n\t      }\n\t    }\n\t  }\n\t  private pushAnalyzedType(\n\t    kind: AnalyzedType['kind'],\n\t    range: [pos: number, end: number]\n\t  ) {\n\t    const [pos, end] = range;\n\t    const text = this.sourceFile.text.slice(pos, end);\n", "    this.analyzedTypes.push({ kind, range: { pos, end }, text });\n\t  }\n\t}\n"]}
