{"filename": "src/pages/api/pusher.ts", "chunked_list": ["import { NextApiRequest, NextApiResponse } from \"next\";\n\timport { pusher } from \"../../utils/pusher\";\n\texport default async function handler(\n\t  req: NextApiRequest,\n\t  res: NextApiResponse\n\t) {\n\t  const { message, sender } = req.body;\n\t  console.log(\"here\", message, sender);\n\t  const response = await pusher.trigger(\"chat\", \"chat-event\", {\n\t    message,\n", "    sender,\n\t  });\n\t  res.json({ message: \"completed\" });\n\t}\n"]}
{"filename": "src/pages/api/trpc/[trpc].ts", "chunked_list": ["import { createNextApiHandler } from \"@trpc/server/adapters/next\";\n\timport { env } from \"~/env.mjs\";\n\timport { createTRPCContext } from \"~/server/api/trpc\";\n\timport { appRouter } from \"~/server/api/root\";\n\t// export API handler\n\texport default createNextApiHandler({\n\t  router: appRouter,\n\t  createContext: createTRPCContext,\n\t  onError:\n\t    env.NODE_ENV === \"development\"\n", "      ? ({ path, error }) => {\n\t          console.error(\n\t            `‚ùå tRPC failed on ${path ?? \"<no-path>\"}: ${error.message}`,\n\t          );\n\t        }\n\t      : undefined,\n\t});\n"]}
{"filename": "src/pages/api/auth/[...nextauth].ts", "chunked_list": ["import NextAuth from \"next-auth\";\n\timport { authOptions } from \"~/server/auth\";\n\texport default NextAuth(authOptions);\n"]}
{"filename": "src/utils/api.ts", "chunked_list": ["/**\n\t * This is the client-side entrypoint for your tRPC API. It is used to create the `api` object which\n\t * contains the Next.js App-wrapper, as well as your type-safe React Query hooks.\n\t *\n\t * We also create a few inference helpers for input and output types.\n\t */\n\timport { httpBatchLink, loggerLink } from \"@trpc/client\";\n\timport { createTRPCNext } from \"@trpc/next\";\n\timport { type inferRouterInputs, type inferRouterOutputs } from \"@trpc/server\";\n\timport superjson from \"superjson\";\n", "import { type AppRouter } from \"~/server/api/root\";\n\tconst getBaseUrl = () => {\n\t  if (typeof window !== \"undefined\") return \"\"; // browser should use relative url\n\t  if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`; // SSR should use vercel url\n\t  return `http://localhost:${process.env.PORT ?? 3000}`; // dev SSR should use localhost\n\t};\n\t/** A set of type-safe react-query hooks for your tRPC API. */\n\texport const api = createTRPCNext<AppRouter>({\n\t  config() {\n\t    return {\n", "      /**\n\t       * Transformer used for data de-serialization from the server.\n\t       *\n\t       * @see https://trpc.io/docs/data-transformers\n\t       */\n\t      transformer: superjson,\n\t      /**\n\t       * Links used to determine request flow from client to server.\n\t       *\n\t       * @see https://trpc.io/docs/links\n", "       */\n\t      links: [\n\t        loggerLink({\n\t          enabled: (opts) =>\n\t            process.env.NODE_ENV === \"development\" ||\n\t            (opts.direction === \"down\" && opts.result instanceof Error),\n\t        }),\n\t        httpBatchLink({\n\t          url: `${getBaseUrl()}/api/trpc`,\n\t        }),\n", "      ],\n\t    };\n\t  },\n\t  /**\n\t   * Whether tRPC should await queries when server rendering pages.\n\t   *\n\t   * @see https://trpc.io/docs/nextjs#ssr-boolean-default-false\n\t   */\n\t  ssr: false,\n\t});\n", "/**\n\t * Inference helper for inputs.\n\t *\n\t * @example type HelloInput = RouterInputs['example']['hello']\n\t */\n\texport type RouterInputs = inferRouterInputs<AppRouter>;\n\t/**\n\t * Inference helper for outputs.\n\t *\n\t * @example type HelloOutput = RouterOutputs['example']['hello']\n", " */\n\texport type RouterOutputs = inferRouterOutputs<AppRouter>;\n"]}
{"filename": "src/utils/pusher.ts", "chunked_list": ["import Pusher from \"pusher\";\n\texport const pusher = new Pusher({\n\t  appId: process.env.PUSHER_APP_ID as string,\n\t  key: process.env.PUSHER_KEY as string,\n\t  secret: process.env.PUSHER_SECRET as string,\n\t  cluster: process.env.PUSHER_CLUSTER as string,\n\t  useTLS: true,\n\t});\n"]}
{"filename": "src/utils/speak.ts", "chunked_list": ["import { transliterate } from \"transliteration\";\n\tlet lastSpokenText = \"\";\n\tconst speakOut = async (text: string, isEmpty: boolean, lang?: string) => {\n\t  if (text === lastSpokenText) {\n\t    console.log(\"Skipping speaking text again:\", text);\n\t    return;\n\t  }\n\t  if (isEmpty) lastSpokenText = \"\";\n\t  console.log(\"speakOut function called with text:\", text);\n\t  let speech = new SpeechSynthesisUtterance();\n", "  speech.lang = lang || \"en-US\";\n\t  let englishText = transliterate(text);\n\t  speech.text = englishText;\n\t  console.log(\"SpeechSynthesisUtterance:\", speech);\n\t  speechSynthesis.speak(speech);\n\t  lastSpokenText = text;\n\t};\n\texport default speakOut;\n"]}
{"filename": "src/lib/serverUtils.ts", "chunked_list": ["import { RoomServiceClient } from \"livekit-server-sdk\";\n\texport function getRoomClient(): RoomServiceClient {\n\t  checkKeys();\n\t  return new RoomServiceClient(getLiveKitURL());\n\t}\n\texport function getLiveKitURL(region?: string | string[]): string {\n\t  let targetKey = \"LIVEKIT_URL\";\n\t  if (region && !Array.isArray(region)) {\n\t    targetKey = `LIVEKIT_URL_${region}`.toUpperCase();\n\t  }\n", "  const url = process.env[targetKey];\n\t  if (!url) {\n\t    throw new Error(`${targetKey} is not defined`);\n\t  }\n\t  return url;\n\t}\n\tfunction checkKeys() {\n\t  if (typeof process.env.LIVEKIT_API_KEY === \"undefined\") {\n\t    throw new Error(\"LIVEKIT_API_KEY is not defined\");\n\t  }\n", "  if (typeof process.env.LIVEKIT_API_SECRET === \"undefined\") {\n\t    throw new Error(\"LIVEKIT_API_SECRET is not defined\");\n\t  }\n\t}\n"]}
{"filename": "src/lib/type.ts", "chunked_list": ["import { LocalAudioTrack, LocalVideoTrack } from \"livekit-client\";\n\texport interface SessionProps {\n\t  roomName: string;\n\t  identity: string;\n\t  audioTrack?: LocalAudioTrack;\n\t  videoTrack?: LocalVideoTrack;\n\t  region?: string;\n\t  turnServer?: RTCIceServer;\n\t  forceRelay?: boolean;\n\t}\n", "export interface TokenResult {\n\t  identity: string;\n\t  accessToken: string;\n\t}\n"]}
{"filename": "src/server/auth.ts", "chunked_list": ["import { type GetServerSidePropsContext } from \"next\";\n\timport {\n\t  getServerSession,\n\t  type NextAuthOptions,\n\t  type DefaultSession,\n\t} from \"next-auth\";\n\timport GoogleProvider from \"next-auth/providers/google\";\n\timport { PrismaAdapter } from \"@next-auth/prisma-adapter\";\n\timport { env } from \"~/env.mjs\";\n\timport { prisma } from \"~/server/db\";\n", "/**\n\t * Module augmentation for `next-auth` types. Allows us to add custom properties to the `session`\n\t * object and keep type safety.\n\t *\n\t * @see https://next-auth.js.org/getting-started/typescript#module-augmentation\n\t */\n\tdeclare module \"next-auth\" {\n\t  interface Session extends DefaultSession {\n\t    user: {\n\t      id: string;\n", "      // ...other properties\n\t      // role: UserRole;\n\t    } & DefaultSession[\"user\"];\n\t  }\n\t  // interface User {\n\t  //   // ...other properties\n\t  //   // role: UserRole;\n\t  // }\n\t}\n\t/**\n", " * Options for NextAuth.js used to configure adapters, providers, callbacks, etc.\n\t *\n\t * @see https://next-auth.js.org/configuration/options\n\t */\n\texport const authOptions: NextAuthOptions = {\n\t  callbacks: {\n\t    session({ session, user }) {\n\t      if (session.user) {\n\t        session.user.id = user.id;\n\t        // session.user.role = user.role; <-- put other properties on the session here\n", "      }\n\t      return session;\n\t    },\n\t  },\n\t  adapter: PrismaAdapter(prisma),\n\t  providers: [\n\t    GoogleProvider({\n\t      clientId: env.GOOGLE_CLIENT_ID,\n\t      clientSecret: env.GOOGLE_CLIENT_SECRET,\n\t    }),\n", "  ],\n\t};\n\t/**\n\t * Wrapper for `getServerSession` so that you don't need to import the `authOptions` in every file.\n\t *\n\t * @see https://next-auth.js.org/configuration/nextjs\n\t */\n\texport const getServerAuthSession = (ctx: {\n\t  req: GetServerSidePropsContext[\"req\"];\n\t  res: GetServerSidePropsContext[\"res\"];\n", "}) => {\n\t  return getServerSession(ctx.req, ctx.res, authOptions);\n\t};\n"]}
{"filename": "src/server/db.ts", "chunked_list": ["import { PrismaClient } from \"@prisma/client\";\n\timport { env } from \"~/env.mjs\";\n\tconst globalForPrisma = globalThis as unknown as { prisma: PrismaClient };\n\texport const prisma =\n\t  globalForPrisma.prisma ||\n\t  new PrismaClient({\n\t    log:\n\t      env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n\t  });\n\tif (env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n"]}
{"filename": "src/server/api/trpc.ts", "chunked_list": ["/**\n\t * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:\n\t * 1. You want to modify request context (see Part 1).\n\t * 2. You want to create a new middleware or type of procedure (see Part 3).\n\t *\n\t * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will\n\t * need to use are documented accordingly near the end.\n\t */\n\t/**\n\t * 1. CONTEXT\n", " *\n\t * This section defines the \"contexts\" that are available in the backend API.\n\t *\n\t * These allow you to access things when processing a request, like the database, the session, etc.\n\t */\n\timport { type CreateNextContextOptions } from \"@trpc/server/adapters/next\";\n\timport { type Session } from \"next-auth\";\n\timport { getServerAuthSession } from \"~/server/auth\";\n\timport { prisma } from \"~/server/db\";\n\ttype CreateContextOptions = {\n", "  session: Session | null;\n\t};\n\t/**\n\t * This helper generates the \"internals\" for a tRPC context. If you need to use it, you can export\n\t * it from here.\n\t *\n\t * Examples of things you may need it for:\n\t * - testing, so we don't have to mock Next.js' req/res\n\t * - tRPC's `createSSGHelpers`, where we don't have req/res\n\t *\n", " * @see https://create.t3.gg/en/usage/trpc#-servertrpccontextts\n\t */\n\tconst createInnerTRPCContext = (opts: CreateContextOptions) => {\n\t  return {\n\t    session: opts.session,\n\t    prisma,\n\t  };\n\t};\n\t/**\n\t * This is the actual context you will use in your router. It will be used to process every request\n", " * that goes through your tRPC endpoint.\n\t *\n\t * @see https://trpc.io/docs/context\n\t */\n\texport const createTRPCContext = async (opts: CreateNextContextOptions) => {\n\t  const { req, res } = opts;\n\t  // Get the session from the server using the getServerSession wrapper function\n\t  const session = await getServerAuthSession({ req, res });\n\t  return createInnerTRPCContext({\n\t    session,\n", "  });\n\t};\n\t/**\n\t * 2. INITIALIZATION\n\t *\n\t * This is where the tRPC API is initialized, connecting the context and transformer.\n\t */\n\timport { initTRPC, TRPCError } from \"@trpc/server\";\n\timport superjson from \"superjson\";\n\tconst t = initTRPC.context<typeof createTRPCContext>().create({\n", "  transformer: superjson,\n\t  errorFormatter({ shape }) {\n\t    return shape;\n\t  },\n\t});\n\t/**\n\t * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)\n\t *\n\t * These are the pieces you use to build your tRPC API. You should import these a lot in the\n\t * \"/src/server/api/routers\" directory.\n", " */\n\t/**\n\t * This is how you create new routers and sub-routers in your tRPC API.\n\t *\n\t * @see https://trpc.io/docs/router\n\t */\n\texport const createTRPCRouter = t.router;\n\t/**\n\t * Public (unauthenticated) procedure\n\t *\n", " * This is the base piece you use to build new queries and mutations on your tRPC API. It does not\n\t * guarantee that a user querying is authorized, but you can still access user session data if they\n\t * are logged in.\n\t */\n\texport const publicProcedure = t.procedure;\n\t/** Reusable middleware that enforces users are logged in before running the procedure. */\n\tconst enforceUserIsAuthed = t.middleware(({ ctx, next }) => {\n\t  if (!ctx.session || !ctx.session.user) {\n\t    throw new TRPCError({ code: \"UNAUTHORIZED\" });\n\t  }\n", "  return next({\n\t    ctx: {\n\t      // infers the `session` as non-nullable\n\t      session: { ...ctx.session, user: ctx.session.user },\n\t    },\n\t  });\n\t});\n\t/**\n\t * Protected (authenticated) procedure\n\t *\n", " * If you want a query or mutation to ONLY be accessible to logged in users, use this. It verifies\n\t * the session is valid and guarantees `ctx.session.user` is not null.\n\t *\n\t * @see https://trpc.io/docs/procedures\n\t */\n\texport const protectedProcedure = t.procedure.use(enforceUserIsAuthed);\n"]}
{"filename": "src/server/api/root.ts", "chunked_list": ["import { createTRPCRouter } from \"~/server/api/trpc\";\n\timport { roomsRouter } from \"./routers/rooms\";\n\timport { pusherRouter } from \"./routers/pusher\";\n\t/**\n\t * This is the primary router for your server.\n\t *\n\t * All routers added in /api/routers should be manually added here.\n\t */\n\texport const appRouter = createTRPCRouter({\n\t  rooms: roomsRouter,\n", "  pusher: pusherRouter,\n\t});\n\t// export type definition of API\n\texport type AppRouter = typeof appRouter;\n"]}
{"filename": "src/server/api/routers/pusher.ts", "chunked_list": ["import { string, z } from \"zod\";\n\timport { pusher } from \"~/utils/pusher\";\n\timport {\n\t  createTRPCRouter,\n\t  publicProcedure,\n\t  protectedProcedure,\n\t} from \"~/server/api/trpc\";\n\timport { translate } from \"@vitalets/google-translate-api\";\n\texport const pusherRouter = createTRPCRouter({\n\t  send: protectedProcedure\n", "    .input(\n\t      z.object({\n\t        message: string(),\n\t        roomName: string(),\n\t        isFinal: z.boolean(),\n\t      })\n\t    )\n\t    .mutation(async ({ input, ctx }) => {\n\t      const { message } = input;\n\t      const { user } = ctx.session;\n", "      const response = await pusher.trigger(\n\t        input.roomName,\n\t        \"transcribe-event\",\n\t        {\n\t          message,\n\t          sender: user.name,\n\t          isFinal: input.isFinal,\n\t          senderId: user.id,\n\t        }\n\t      );\n", "      const { text } = await translate(message, {\n\t        to: \"en\",\n\t      });\n\t      await ctx.prisma.transcript.create({\n\t        data: {\n\t          text: text,\n\t          Room: {\n\t            connect: {\n\t              name: input.roomName,\n\t            },\n", "          },\n\t          User: {\n\t            connect: {\n\t              id: user.id,\n\t            },\n\t          },\n\t        },\n\t      });\n\t      return response;\n\t    }),\n", "});\n"]}
{"filename": "src/server/api/routers/rooms.ts", "chunked_list": ["import { nullable, string, z } from \"zod\";\n\timport { AccessToken, RoomServiceClient } from \"livekit-server-sdk\";\n\timport type {\n\t  AccessTokenOptions,\n\t  VideoGrant,\n\t  CreateOptions,\n\t} from \"livekit-server-sdk\";\n\timport { translate } from \"@vitalets/google-translate-api\";\n\tconst createToken = (userInfo: AccessTokenOptions, grant: VideoGrant) => {\n\t  const at = new AccessToken(apiKey, apiSecret, userInfo);\n", "  at.ttl = \"5m\";\n\t  at.addGrant(grant);\n\t  return at.toJwt();\n\t};\n\timport axios from \"axios\";\n\tconst apiKey = process.env.LIVEKIT_API_KEY;\n\tconst apiSecret = process.env.LIVEKIT_API_SECRET;\n\tconst apiHost = process.env.NEXT_PUBLIC_LIVEKIT_API_HOST as string;\n\timport {\n\t  createTRPCRouter,\n", "  publicProcedure,\n\t  protectedProcedure,\n\t} from \"~/server/api/trpc\";\n\timport { TokenResult } from \"~/lib/type\";\n\timport { CreateRoomRequest } from \"livekit-server-sdk/dist/proto/livekit_room\";\n\tconst roomClient = new RoomServiceClient(apiHost, apiKey, apiSecret);\n\tconst configuration = new Configuration({\n\t  apiKey: process.env.OPEN_API_SECRET,\n\t});\n\timport { Configuration, OpenAIApi } from \"openai\";\n", "const openai = new OpenAIApi(configuration);\n\texport const roomsRouter = createTRPCRouter({\n\t  joinRoom: protectedProcedure\n\t    .input(\n\t      z.object({\n\t        roomName: z.string(),\n\t      })\n\t    )\n\t    .query(async ({ input, ctx }) => {\n\t      const identity = ctx.session.user.id;\n", "      const name = ctx.session.user.name;\n\t      const grant: VideoGrant = {\n\t        room: input.roomName,\n\t        roomJoin: true,\n\t        canPublish: true,\n\t        canPublishData: true,\n\t        canSubscribe: true,\n\t      };\n\t      const { roomName } = input;\n\t      const token = createToken({ identity, name: name as string }, grant);\n", "      const result: TokenResult = {\n\t        identity,\n\t        accessToken: token,\n\t      };\n\t      try {\n\t        // check if user is already in room\n\t        console.log(\"here\");\n\t        const participant = await ctx.prisma.participant.findUnique({\n\t          where: {\n\t            UserId_RoomName: {\n", "              UserId: ctx.session.user.id,\n\t              RoomName: roomName,\n\t            },\n\t          },\n\t        });\n\t        if (participant === null)\n\t          await ctx.prisma.participant.create({\n\t            data: {\n\t              User: {\n\t                connect: {\n", "                  id: ctx.session.user.id,\n\t                },\n\t              },\n\t              Room: {\n\t                connect: {\n\t                  name: roomName,\n\t                },\n\t              },\n\t            },\n\t          });\n", "      } catch (error) {\n\t        console.log(error);\n\t      }\n\t      return result;\n\t    }),\n\t  createRoom: protectedProcedure.mutation(async ({ ctx }) => {\n\t    const identity = ctx.session.user.id;\n\t    const name = ctx.session.user.name;\n\t    const room = await ctx.prisma.room.create({\n\t      data: {\n", "        Owner: {\n\t          connect: {\n\t            id: ctx.session.user.id,\n\t          },\n\t        },\n\t      },\n\t    });\n\t    await roomClient.createRoom({\n\t      name: room.name,\n\t    });\n", "    const grant: VideoGrant = {\n\t      room: room.name,\n\t      roomJoin: true,\n\t      canPublish: true,\n\t      canPublishData: true,\n\t      canSubscribe: true,\n\t    };\n\t    const token = createToken({ identity, name: name as string }, grant);\n\t    const result = {\n\t      roomName: room.name,\n", "    };\n\t    return result;\n\t  }),\n\t  getRoomsByUser: protectedProcedure.query(async ({ ctx }) => {\n\t    const rooms = await ctx.prisma.room.findMany({\n\t      where: {\n\t        OR: [\n\t          {\n\t            Owner: {\n\t              id: ctx.session.user.id,\n", "            },\n\t          },\n\t          {\n\t            Participant: {\n\t              some: {\n\t                UserId: ctx.session.user.id,\n\t              },\n\t            },\n\t          },\n\t        ],\n", "      },\n\t    });\n\t    return rooms;\n\t  }),\n\t  getRoomSummary: protectedProcedure\n\t    .input(\n\t      z.object({\n\t        roomName: z.string(),\n\t      })\n\t    )\n", "    .query(async ({ input, ctx }) => {\n\t      // order all transcripts by createdAt in ascending order\n\t      const transcripts = await ctx.prisma.transcript.findMany({\n\t        where: {\n\t          Room: {\n\t            name: input.roomName,\n\t          },\n\t        },\n\t        include: {\n\t          User: true,\n", "        },\n\t        orderBy: {\n\t          createdAt: \"asc\",\n\t        },\n\t      });\n\t      const chatLog = transcripts.map((transcript) => ({\n\t        speaker: transcript.User.name,\n\t        utterance: transcript.text,\n\t        timestamp: transcript.createdAt.toISOString(),\n\t      }));\n", "      if (chatLog.length === 0) {\n\t        return null;\n\t      }\n\t      const apiKey = process.env.ONEAI_API_KEY;\n\t      console.log(chatLog);\n\t      try {\n\t        const config = {\n\t          method: \"POST\",\n\t          url: \"https://api.oneai.com/api/v0/pipeline\",\n\t          headers: {\n", "            \"api-key\": apiKey,\n\t            \"Content-Type\": \"application/json\",\n\t          },\n\t          data: {\n\t            input: chatLog,\n\t            input_type: \"conversation\",\n\t            content_type: \"application/json\",\n\t            output_type: \"json\",\n\t            multilingual: {\n\t              enabled: true,\n", "            },\n\t            steps: [\n\t              {\n\t                skill: \"article-topics\",\n\t              },\n\t              {\n\t                skill: \"numbers\",\n\t              },\n\t              {\n\t                skill: \"names\",\n", "              },\n\t              {\n\t                skill: \"emotions\",\n\t              },\n\t              {\n\t                skill: \"summarize\",\n\t              },\n\t            ],\n\t          },\n\t        };\n", "        const res = await axios.request(config);\n\t        console.log(res.status);\n\t        return res.data;\n\t      } catch (error) {\n\t        console.log(error);\n\t      }\n\t    }),\n\t});\n"]}
{"filename": "src/hooks/useTranscribe.ts", "chunked_list": ["import { useEffect } from \"react\";\n\timport SpeechRecognition, {\n\t  useSpeechRecognition,\n\t} from \"react-speech-recognition\";\n\timport { api } from \"~/utils/api\";\n\ttype UseTranscribeProps = {\n\t  roomName: string;\n\t  audioEnabled: boolean;\n\t  languageCode?: string;\n\t};\n", "const useTranscribe = ({\n\t  roomName,\n\t  audioEnabled,\n\t  languageCode,\n\t}: UseTranscribeProps) => {\n\t  const {\n\t    transcript,\n\t    resetTranscript,\n\t    finalTranscript,\n\t    browserSupportsSpeechRecognition,\n", "  } = useSpeechRecognition();\n\t  const pusherMutation = api.pusher.send.useMutation();\n\t  useEffect(() => {\n\t    if (finalTranscript !== \"\") {\n\t      pusherMutation.mutate({\n\t        message: transcript,\n\t        roomName: roomName,\n\t        isFinal: true,\n\t      });\n\t      resetTranscript();\n", "    }\n\t  }, [finalTranscript]);\n\t  useEffect(() => {\n\t    if (audioEnabled) {\n\t      SpeechRecognition.startListening({\n\t        continuous: true,\n\t        language: languageCode,\n\t      });\n\t    }\n\t  }, [audioEnabled]);\n", "  return null;\n\t};\n\texport default useTranscribe;\n"]}
