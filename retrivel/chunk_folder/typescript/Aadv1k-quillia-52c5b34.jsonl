{"filename": "src/server.ts", "chunked_list": ["import http from \"node:http\";\n\timport { sendPublicFile } from \"./common/utils\";\n\timport RouteSignup from \"./routes/Signup\"\n\timport RouteLogin from \"./routes/Login\";\n\timport RouteBooks from \"./routes/Books\";\n\timport RouteIssue from \"./routes/Issue\";\n\texport default http.createServer( async (req: http.IncomingMessage, res: http.ServerResponse) => {\n\t  const url: string  = new URL(`https://foo.com${req.url}`).pathname;\n\t  if (url === \"/\") {\n\t    sendPublicFile(res, \"index.html\");\n", "  } else if (url ===\"/api/signup\") {\n\t    await RouteSignup(req, res);\n\t  } else if (url ===\"/api/login\") {\n\t    await RouteLogin(req, res);\n\t  } else if (url.match(/^\\/api\\/books/)) {\n\t    await RouteBooks(req, res);\n\t  } else if (url.match(/^\\/api\\/issue/))  {\n\t    await RouteIssue(req, res);\n\t  } else {\n\t    sendPublicFile(res, url);\n", "  }\n\t  res.end();\n\t})\n"]}
{"filename": "src/index.ts", "chunked_list": ["import server from \"./server\";\n\timport { PORT } from \"./common/const\";\n\tserver.listen(PORT, () => {\n\t  console.log(`Server listening at http://localhost:${PORT}`);\n\t})\n"]}
{"filename": "src/common/types.ts", "chunked_list": ["export interface User {\n\t  id?: string,\n\t  email: string;\n\t  password: string;\n\t}\n\texport interface Issue {\n\t  id: string,\n\t  lenderid: string,\n\t  borrowerid: string,\n\t  bookid: string\n", "}\n\texport interface Book {\n\t  id: string,\n\t  userid: string,\n\t  title: string,\n\t  author: string,\n\t  path: string,\n\t  signature: string\n\t  cover?: string,\n\t}\n", "export enum TokStatus {\n\t  EXPIRED,\n\t  INVALID,\n\t  INVALID_SIG,\n\t  VALID\n\t}\n"]}
{"filename": "src/common/const.ts", "chunked_list": ["import dotenv from \"dotenv\";\n\timport path from \"node:path\";\n\tdotenv.config({\n\t  path: path.join(__dirname, \"../../.env\"),\n\t});\n\texport const DB = {\n\t  USER: process.env.PG_USER,\n\t  PASSWORD: process.env.PG_PASSWORD,\n\t  HOST: process.env.PG_HOST,\n\t  PORT: parseInt(process.env.PG_PORT),\n", "  DB_NAME: process.env.PG_DB,\n\t}\n\texport const CLOUDINARY_CONF = {\n\t  API_KEY: process.env.CLOUDINARY_API_KEY,\n\t  API_SECRET: process.env.CLOUDINARY_API_SECRET,\n\t  CLOUD_NAME: \"dbloby3uq\",\n\t}\n\texport const JWT = {\n\t  SECRET: process.env.JWT_SECRET ?? \"default\",\n\t  ALGO: \"HS256\",\n", "  HASH: \"sha256\"\n\t}\n\texport const ERROR = {\n\t  internalErr: {\n\t    message: \"something went wrong internally\",\n\t    status: 500,\n\t    error: \"internal-error\"\n\t  },\n\t  invalidChapterID: {\n\t    message: \"the chapter id requested for the issue was invalid\",\n", "    status: 400,\n\t    error: \"invalid-chapter-id\"\n\t  },\n\t  chapterOutOfRange: {\n\t    message: \"the requested chapter was out of range\",\n\t    status: 400,\n\t    error: \"chapter-out-of-range\"\n\t  },\n\t  resourceExists: {\n\t    message: \"resource already exists\",\n", "    status: 409,\n\t    error: \"resource-exists\"\n\t  },\n\t  resourceNotExists: {\n\t    message: \"resource does not exist\",\n\t    status: 404,\n\t    error: \"resource-not-found\"\n\t  },\n\t  unauthorized: {\n\t    message: \"the given credentials were invalid\",\n", "    status: 401,\n\t    error: \"unauthorized\"\n\t  },\n\t  userNotFound: {\n\t    message: \"unable to find user\",\n\t    status: 404,\n\t    error: \"user-not-found\"\n\t  },\n\t  methodNotAllowed: {\n\t    message: \"the method is not allowed for the endpoint\",\n", "    status: 405,\n\t    error: \"method-not-allowed\"\n\t  },\n\t  userAlreadyExists: {\n\t    message: \"the given user already exists, login instead.\",\n\t    status: 409,\n\t    error: \"user-already-exists\"\n\t  },\n\t  invalidJSONData: {\n\t    message: \"received invalid JSON data\",\n", "    status: 400,\n\t    error: \"invalid-json-data\"\n\t  },\n\t  invalidMimeForResource: {\n\t    message: \"the mime recieved for the resource is not valid\",\n\t    status: 415,\n\t    error: \"invalid-mime-for-resource\"\n\t  },\n\t  badRequest: {\n\t    message: \"the request was invalid\",\n", "    status: 400,\n\t    error: \"bad-request\"\n\t  },\n\t  fileTooLarge: {\n\t    message: \"the file is too large\",\n\t    status: 400,\n\t    error: \"file-too-large\",\n\t  }\n\t} \n\texport enum MIME {\n", "  js = \"text/javascript\",\n\t  html = \"text/html\",\n\t  css = \"text/css\",\n\t  png = \"image/png\",\n\t  jpg = \"image/jpeg\",\n\t  ico =  \"image/x-icon\",\n\t}\n\texport const PORT = process.env.PORT || 4000;\n\texport const MAX_EPUB_SIZE_MB = 20;\n"]}
{"filename": "src/common/utils.ts", "chunked_list": ["import crypto from \"node:crypto\";\n\timport http from \"node:http\";\n\timport https from \"node:https\";\n\timport path from \"node:path\";\n\timport { ServerResponse } from \"node:http\";\n\timport {  existsSync, readFileSync } from \"node:fs\";\n\timport * as nanoid from \"nanoid\";\n\timport {IncomingForm, Fields, Files} from \"formidable\";\n\timport { MIME } from \"./const\";\n\texport function sendJsonResponse(res: ServerResponse, error: object, status: number = 200) {\n", "  res.writeHead(status, {\n\t    \"Content-type\": \"application/json\",\n\t    \"Access-Control-Allow-Origin\": '*',\n\t    \"Access-Control-Allow-Methods\": 'GET, POST, PUT, DELETE',\n\t    \"Access-Control-Allow-Headers\": 'Content-type, authorization',\n\t    \"Access-Control-Allow-Credentials\": \"true\",\n\t  })\n\t  res.write(JSON.stringify(error), \"utf-8\");\n\t}\n\texport function sendEpubResponse(res: ServerResponse, epubBuffer: Buffer, code?: number) {\n", "  res.writeHead(code ?? 200, {\n\t    \"Content-type\": \"application/epub+zip\"\n\t  });\n\t  res.write(epubBuffer);\n\t}\n\texport function uuid(): string {\n\t  const nid = nanoid.customAlphabet(\"1234567890abcdef\", 10);\n\t  let id = nid();\n\t  return id;\n\t}\n", "export async function getBufferFromRawURL(resourceUrl: string): Promise<Buffer | null> {\n\t  let url = new URL(resourceUrl);\n\t  try {\n\t    let buffArr: Buffer[] = await new Promise((resolve, reject) => {\n\t      let func = url.protocol === \"https:\" ? https : http;\n\t      func.get(url, (res) => {\n\t        let data: Buffer[] = [];\n\t        res.on(\"data\", (d: Buffer) => data.push(d))\n\t        res.on(\"error\", reject)\n\t        res.on(\"end\", () => resolve(data))\n", "      })\n\t    })\n\t    let buffer = Buffer.concat(buffArr);\n\t    return buffer;\n\t  } catch (err) {\n\t    console.error(err);\n\t    return null;\n\t  }\n\t} \n\texport function sendHtmlResponse(res: ServerResponse, html: string, status: number = 200) {\n", "  res.writeHead(status, {\n\t    \"Content-type\": \"text/html\",\n\t  })\n\t  res.write(html, \"utf-8\");\n\t}\n\texport function parsePostData(req: http.IncomingMessage): Promise<Array<object>> {\n\t  let form = new IncomingForm({ multiples: false });\n\t  return new Promise((resolve, reject) => {\n\t    form.parse(req, (error, fields: Fields, files: Files) => {\n\t      if (error) reject(error);\n", "      resolve([fields, files]);\n\t    })\n\t  })\n\t}\n\texport function parseSimplePostData(req: http.IncomingMessage): Promise<Buffer> {\n\t  return new Promise((resolve, reject) => {\n\t    let data: Buffer[] = [];\n\t    req.on(\"data\", (chunk: Buffer) => data.push(chunk))\n\t    req.on(\"end\", () => { \n\t      const buf = Buffer.concat(data);\n", "      resolve(buf);\n\t    });\n\t    req.on(\"error\", reject);\n\t  })\n\t}\n\texport function md5(data: string): string {\n\t  return crypto\n\t    .createHash(\"md5\")\n\t    .update(data)\n\t    .digest(\"hex\");\n", "}\n\texport function sendPublicFile(res: ServerResponse, filepath: string) {\n\t  let resourcePath = path.join(__dirname, \"../../public\", filepath)\n\t  if (!existsSync(resourcePath)) {\n\t    // we hope to handle the 404 state on the frontend\n\t    resourcePath = path.join(__dirname, \"../../public\", \"index.html\")\n\t  }\n\t  let ext = resourcePath.split('.').pop();\n\t  res.writeHead(200, { \"Content-type\": MIME[ext] });\n\t  res.write(readFileSync(resourcePath))\n", "}\n"]}
{"filename": "src/lib/GenerateToken.ts", "chunked_list": ["import { TokStatus } from \"../common/types\";\n\timport { JWT  } from \"../common/const\"\n\timport { createHmac } from \"node:crypto\";\n\texport default class Token {\n\t  generate(user: object, expiresIn?: number): string {\n\t    const head = { algorithm: JWT.ALGO, typ: \"JWT\"};\n\t    const createdAt = Math.floor(Date.now() / 1000);\n\t    const body = { ...user, iat: createdAt, exp: null}\n\t    if (expiresIn) {\n\t      body.exp = createdAt + expiresIn;\n", "    }\n\t    let b64Head = Buffer.from(JSON.stringify(head)).toString(\"base64\").replace(/=/g, \"\");\n\t    let b64Body = Buffer.from(JSON.stringify(body)).toString(\"base64\").replace(/=/g, \"\");\n\t    let signature = this.sign(`${b64Head}.${b64Body}`);\n\t    return `${b64Head}.${b64Body}.${signature}`\n\t  }\n\t  verify(token: string): TokStatus {\n\t    let [head, body, signature] = token.split('.');\n\t    if (!head || !body || !signature) {\n\t      return TokStatus.INVALID;\n", "    }\n\t    if (this.sign(`${head}.${body}`) !== signature) {\n\t      return TokStatus.INVALID_SIG\n\t    }\n\t    let decodedBody = Buffer.from(body, \"base64\").toString(\"utf-8\");\n\t    const curTime = Math.floor(Date.now() / 1000);\n\t    if (JSON.parse(decodedBody)?.exp > curTime) {\n\t      return TokStatus.EXPIRED;\n\t    }\n\t    return TokStatus.VALID\n", "  }\n\t  // assumes that the token is valid\n\t  UNSAFE_parse(token: string): object {\n\t    const [ _a, body, _b ] = token.split(\".\");\n\t    const parsedBody = Buffer.from(body, \"base64\").toString(\"utf-8\");\n\t    const parsedJson = JSON.parse(parsedBody);\n\t    return parsedJson;\n\t  } \n\t  private sign(data: string): string {\n\t    return createHmac(JWT.HASH, JWT.SECRET)\n", "      .update(data)\n\t      .digest(\"base64\")\n\t      .replace(/=/g, '')\n\t  }\n\t}\n"]}
{"filename": "src/lib/isEmailValid.ts", "chunked_list": ["export default function(email: string): boolean {\n\t  let emailRegex = /^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$/\n\t  if (!email.match(emailRegex)) {\n\t    return false;\n\t  }\n\t  return true;\n\t}\n"]}
{"filename": "src/models/Bucket.ts", "chunked_list": ["import { CLOUDINARY_CONF } from \"../common/const\";\n\timport { v2 as cloudinary } from \"cloudinary\";\n\timport { Readable } from \"node:stream\";\n\timport fs from \"node:fs\";\n\timport path from \"node:path\";\n\texport default class Bucket {\n\t  bucket: any;\n\t  isLocal: boolean;\n\t  bucketPath: string;\n\t  constructor() {\n", "    this.isLocal = false;\n\t    if (!CLOUDINARY_CONF.API_SECRET) {\n\t      this.isLocal = true;\n\t      this.bucketPath = path.join(__dirname, \"../BUCKET\");\n\t    } else {\n\t      cloudinary.config({\n\t        cloud_name: CLOUDINARY_CONF.CLOUD_NAME,\n\t        api_key: CLOUDINARY_CONF.API_KEY,\n\t        api_secret: CLOUDINARY_CONF.API_SECRET\n\t      })\n", "      this.bucket = cloudinary;\n\t    }\n\t  }\n\t  async init() {\n\t    if (this.isLocal) {\n\t      await new Promise((_, _a) => {\n\t        fs.mkdir(this.bucketPath, (_b) => {});\n\t      })    \n\t    }\n\t    // syntactical consistency\n", "  }\n\t  async pushBufferWithName(buffer: Buffer, name: string): Promise<string | null> {\n\t    const stream = new Readable({\n\t      read: function() {\n\t        this.push(buffer);\n\t        this.push(null);\n\t      }\n\t    });\n\t    console.log(this.isLocal)\n\t    if (this.isLocal) {\n", "      let p = path.join(this.bucketPath, name);\n\t      console.log(p);\n\t      fs.writeFileSync(p, buffer);\n\t      return p;\n\t    }\n\t    let response = new Promise((resolve, reject) => {\n\t      const writeStream = this.bucket.uploader.upload_stream({\n\t        public_id: name,\n\t        resource_type: \"raw\",\n\t        format: name.split('.').pop() // ideally \"unsafe\" files should not reach this point\n", "      }, (error: any, result: any) => {\n\t        if (error) reject(error);\n\t        resolve(result);\n\t      })\n\t      stream.pipe(writeStream);\n\t    })\n\t    try {\n\t      let data: any = await response;\n\t      return data.secure_url;\n\t    } catch (error) {\n", "      console.error(error);\n\t      return null;\n\t    }\n\t  }\n\t  async close() {\n\t    // syntactical consistency\n\t  }\n\t}\n"]}
{"filename": "src/models/BookModel.ts", "chunked_list": ["import { Client } from \"pg\";\n\timport { DB as DBConfig } from \"../common/const\";\n\timport { Book } from \"../common/types\";\n\texport default class BookModel {\n\t  private readonly client: Client;\n\t  constructor() {\n\t    this.client = new Client({\n\t      host: DBConfig.HOST,\n\t      user: DBConfig.USER,\n\t      password: DBConfig.PASSWORD,\n", "      database: DBConfig.DB_NAME,\n\t      port: DBConfig.PORT,\n\t      ssl: true\n\t    })\n\t  }\n\t  async init(): Promise<void> {\n\t    try {\n\t      await this.client.connect();\n\t      await this.client.query(`CREATE TABLE IF NOT EXISTS books (\n\t         id VARCHAR(255) UNIQUE NOT NULL,\n", "         userid VARCHAR(255) UNIQUE NOT NULL,\n\t         title VARCHAR(255) NOT NULL,\n\t         author VARCHAR(255) NOT NULL,\n\t         signature VARCHAR(255) NOT NULL,\n\t         path VARCHAR(255) NOT NULL,\n\t         cover VARCHAR(255) NOT NULL\n\t        )\n\t        `);\n\t    } catch (error) {\n\t      throw error;\n", "    }\n\t  }\n\t  async bookExists(bookid: string): Promise<boolean> {\n\t    const result = await this.client.query(\"SELECT EXISTS (SELECT 1 FROM books WHERE id = $1)\", [bookid])\n\t    return result.rows[0].exists\n\t  } \n\t  async getBooks(): Promise<Array<Book> | null> {\n\t    try {\n\t      let response = await this.client.query(\"SELECT * FROM books\");\n\t      return response.rows;\n", "    } catch (error) {\n\t      console.error(error);\n\t      return;\n\t    }\n\t  }\n\t  async pushBook(book: Book): Promise<Book | null> {\n\t    try {\n\t      await this.client.query(`\n\t        INSERT INTO books (id, userid, author, title, path, cover, signature) \n\t        VALUES ($1, $2, $3, $4, $5, $6, $7)`, \n", "        [book.id, book.userid, book.author, book.title, book.path, book?.cover ?? \"\", book.signature]\n\t      )\n\t      return book;\n\t    } catch (error) {\n\t      console.error(error); \n\t      return null;\n\t    }\n\t  }\n\t  async deleteBook(bookid: string, userid?: string) {\n\t    try {\n", "      await this.client.query(`DELETE FROM books WHERE id = $1 ${userid && \"AND userid = $2\"}`, [bookid, userid ?? \"\"]);\n\t      return bookid;\n\t    } catch (error) {\n\t      console.error(error); \n\t      return null;\n\t    }\n\t  }\n\t  async getBook(bookid: string, sig?: string): Promise<Book | null> {\n\t    try {\n\t      const response = await this.client.query(`SELECT * FROM books WHERE ${bookid ? \"id = $1\" : \"signature = $1\"}`, [bookid || sig]);\n", "      return response.rows[0];\n\t    } catch (error) {\n\t      console.error(error);\n\t      return null;\n\t    }\n\t  }\n\t  async updateBook() { /* TODO */ }\n\t  async close(): Promise<void> {\n\t    await this.client.end();\n\t  }\n", "}\n"]}
{"filename": "src/models/UserModel.ts", "chunked_list": ["import { Client } from \"pg\";\n\timport { DB as DBConfig } from \"../common/const\";\n\timport { User } from \"../common/types\";\n\texport default class UserModel {\n\t  private readonly client: Client;\n\t  constructor() {\n\t    this.client = new Client({\n\t      host: DBConfig.HOST,\n\t      user: DBConfig.USER,\n\t      password: DBConfig.PASSWORD,\n", "      database: DBConfig.DB_NAME,\n\t      port: DBConfig.PORT,\n\t      ssl: true\n\t    })\n\t  }\n\t  async init(): Promise<void> {\n\t    try {\n\t      await this.client.connect();\n\t      await this.client.query(`\n\t        CREATE TABLE IF NOT EXISTS users (\n", "         id VARCHAR(255) UNIQUE NOT NULL,\n\t         email VARCHAR(255) NOT NULL,\n\t         password VARCHAR(255) NOT NULL\n\t        )\n\t        `);\n\t    } catch (error) {\n\t      throw error\n\t    }\n\t  }\n\t  async userExists(email?: string): Promise<boolean> {\n", "    const result = await this.client.query(\"SELECT EXISTS (SELECT 1 FROM users WHERE email = $1)\", [email])\n\t    return result.rows[0].exists\n\t  } \n\t  async getUserByID(id: string): Promise<User | null> {\n\t    try {\n\t      const response = await this.client.query(\n\t        `SELECT * FROM users \n\t        WHERE id = $1`, \n\t        [id]\n\t      );\n", "      return response.rows[0]\n\t    } catch (error) {\n\t      return null;\n\t    }\n\t  }\n\t  async getUser(email: string, id?: string): Promise<User | null> {\n\t    try {\n\t      const response = await this.client.query(\n\t        `SELECT * FROM users \n\t        WHERE email = $1\n", "        OR id = $2`, \n\t        [email, id ?? \"\"]\n\t      );\n\t      return response.rows[0]\n\t    } catch (error) {\n\t      return null;\n\t    }\n\t  }\n\t  async getUsers(): Promise <Array<object> | null> {\n\t    try {\n", "      let data = await this.client.query(`SELECT * FROM users`)\n\t      return data.rows;\n\t    } catch (error) {\n\t      console.error(error);\n\t      return null;\n\t    }\n\t  }\n\t  async updateUser(user: User, toUpdate: object ) {\n\t    let blobs = Object.keys(toUpdate).map((e, i) => {return `${e} = \\$${i+1}`})\n\t    let toUpdateQuery = blobs.join(\" AND \");\n", "    let query = `UPDATE users SET ${toUpdateQuery} WHERE $1 OR $2`\n\t    try {\n\t      this.client.query(query, [user.id, user.email]);\n\t    } catch (error) {\n\t      console.error(error);\n\t      return null;\n\t    }\n\t  }\n\t  async deleteUser(user: User): Promise<User | void> {\n\t    try {\n", "      await this.client.query(`DELETE FROM users WHERE id = $1 OR email = $2`, [user.id, user.email]);\n\t      return user;\n\t    } catch (error) {\n\t      throw error;\n\t    }\n\t  }\n\t  async pushUser(user: User): Promise<User | void> {\n\t    try {\n\t      await this.client.query(\"INSERT INTO users (id, email, password) VALUES ($1, $2, $3)\", [user.id, user.email, user.password]);\n\t      return user;\n", "    } catch (error) {\n\t      throw error;\n\t    }\n\t  }\n\t  async pushTokenForUser(token: string, userid: string): Promise<void | null> {\n\t    try {\n\t      await this.client.query(\"INSERT INTO tokens (userid, token) VALUES ($1, $2)\", [userid, token]);\n\t    } catch (error) {\n\t      console.error(error);\n\t      return null;\n", "    }\n\t  }\n\t  async deleteTokenForUser(token?: string, userid?: string): Promise<void | null>  {\n\t    try {\n\t      await this.client.query(\"DELETE FROM tokens WHERE token = $1 OR userid = $2\", [token, userid]);\n\t    } catch (error) {\n\t      console.error(error);\n\t      return null;\n\t    }\n\t  }\n", "  async close(): Promise<void> {\n\t    await this.client.end();\n\t  }\n\t}\n"]}
{"filename": "src/models/IssueModel.ts", "chunked_list": ["import { Client } from \"pg\";\n\timport { DB as DBConfig } from \"../common/const\";\n\timport { Issue } from \"../common/types\";\n\texport default class IssueModel {\n\t  private readonly client: Client;\n\t  constructor() {\n\t    this.client = new Client({\n\t      host: DBConfig.HOST,\n\t      user: DBConfig.USER,\n\t      password: DBConfig.PASSWORD,\n", "      database: DBConfig.DB_NAME,\n\t      port: DBConfig.PORT,\n\t      ssl: true,\n\t    });\n\t  }\n\t  async init(): Promise<void> {\n\t    try {\n\t      await this.client.connect();\n\t      await this.client.query(`CREATE TABLE IF NOT EXISTS issues (\n\t         id VARCHAR(255) UNIQUE NOT NULL,\n", "         lenderid VARCHAR(255) NOT NULL,\n\t         borrowerid VARCHAR(255) NOT NULL,\n\t         bookid VARCHAR(255) NOT NULL\n\t       )\n\t        `);\n\t    } catch (error) {\n\t      throw error;\n\t    }\n\t  }\n\t  async issueExists(issueid: string): Promise<boolean> {\n", "    const result = await this.client.query(\"SELECT EXISTS (SELECT 1 FROM issues WHERE id = $1)\", [issueid])\n\t    return result.rows[0].exists\n\t  } \n\t  async pushIssue(data: Issue): Promise<Issue | null> {\n\t    try {\n\t      await this.client.query(\n\t        \"INSERT INTO issues (id, lenderid, borrowerid, bookid) VALUES ($1, $2, $3, $4)\",\n\t        [data.id, data.lenderid, data.borrowerid, data.bookid]\n\t      );\n\t      return data;\n", "    } catch (error) {\n\t      console.error(error);\n\t      return null;\n\t    }\n\t  }\n\t  async removeIssue(\n\t    issueid: string,\n\t    borrowerid?: string,\n\t    lenderid?: string\n\t  ): Promise<void | null> {\n", "    try {\n\t      await this.client.query(\n\t        \"DELETE FROM issues WHERE issueid = $1 OR borrowerid = $2 OR lenderid = $3\",\n\t        [issueid ?? \"\", borrowerid ?? \"\", lenderid ?? \"\"]\n\t      );\n\t    } catch (error) {\n\t      console.error(error);\n\t      return null;\n\t    }\n\t  }\n", "  async getIssues(borrowerid: string): Promise<Array<Issue> | null> {\n\t    try {\n\t      let response = await this.client.query(\n\t        \"SELECT * FROM issues WHERE borrowerid = $1\",\n\t        [borrowerid]\n\t      );\n\t      return response.rows;\n\t    } catch (error) {\n\t      console.error(error);\n\t      return null;\n", "    }\n\t  }\n\t  async getIssue(\n\t    lenderid: string,\n\t    bookid?: string,\n\t    borrowerid?: string,\n\t  ): Promise<Issue | null> {\n\t    try {\n\t      let response = await this.client.query(\n\t        `SELECT * FROM issues \n", "          WHERE borrowerid = $1\n\t          AND bookid = $2\n\t        `,\n\t        [borrowerid ?? null, bookid ?? null]\n\t      );\n\t      return response.rows[0];\n\t    } catch (error) {\n\t      console.error(error);\n\t      return null;\n\t    }\n", "  }\n\t  async close(): Promise<void> {\n\t    await this.client.end();\n\t  }\n\t}\n"]}
{"filename": "src/routes/Signup.ts", "chunked_list": ["import http from \"node:http\";\n\timport { sendJsonResponse, md5, uuid, parseSimplePostData } from \"../common/utils\";\n\timport { ERROR } from \"../common/const\";\n\timport { User } from \"../common/types\";\n\timport UserModel from \"../models/UserModel\";\n\timport Token from \"../lib/GenerateToken\";\n\timport isEmailValid from \"../lib/isEmailValid\";\n\texport default async function (\n\t  req: http.IncomingMessage,\n\t  res: http.ServerResponse\n", ") {\n\t  const DB = new UserModel();\n\t  if (req.method !== \"POST\") {\n\t    sendJsonResponse(res, ERROR.methodNotAllowed, 405);\n\t    return;\n\t  }\n\t  let data: any = await parseSimplePostData(req);\n\t  data = data.toString();\n\t  let parsedData: User;\n\t  try {\n", "    parsedData = JSON.parse(data === \"\" ? '{}' : data);\n\t  } catch {\n\t    sendJsonResponse(res, ERROR.invalidJSONData, 400)\n\t    return;\n\t  }\n\t  if (!parsedData.email || !parsedData.password) {\n\t    sendJsonResponse(res, ERROR.badRequest, 400);\n\t    return;\n\t  }\n\t  if (!isEmailValid(parsedData.email)) {\n", "    sendJsonResponse(res, ERROR.badRequest, 400);\n\t    return;\n\t  }\n\t  await DB.init();\n\t  let foundUser = await DB.getUser(parsedData.email);\n\t  if (foundUser) {\n\t    sendJsonResponse(res, ERROR.userAlreadyExists, 409)\n\t    return;\n\t  }\n\t  let user: User = {\n", "    id: uuid(),\n\t    email: parsedData.email,\n\t    password: md5(parsedData.password),\n\t  } \n\t  const token = new Token();\n\t    let pushed = await DB.pushUser(user)\n\t    const { password, ...tokenBody} = user;\n\t    let accessToken = token.generate(tokenBody);\n\t  if (pushed !== null) {\n\t    sendJsonResponse(res, {\n", "      status: 201,\n\t      message: \"successfully created new user\",\n\t      error: null,\n\t      token: accessToken,\n\t      data: {\n\t        email: user.email,\n\t        id: user.id\n\t      }\n\t    }, 201)\n\t  } else {\n", "    sendJsonResponse(res, ERROR.internalErr, 500);\n\t  }\n\t  await DB.close();\n\t}\n"]}
{"filename": "src/routes/Issue.ts", "chunked_list": ["import IssueModel from \"../models/IssueModel\";\n\timport BookModel from \"../models/BookModel\";\n\timport UserModel from \"../models/UserModel\";\n\timport Token from \"../lib/GenerateToken\";\n\timport { ERROR } from \"../common/const\";\n\timport { TokStatus, Issue } from \"../common/types\";\n\timport {\n\t  sendJsonResponse,\n\t  sendEpubResponse,\n\t  parseSimplePostData,\n", "  uuid,\n\t  getBufferFromRawURL,\n\t} from \"../common/utils\";\n\timport http from \"node:http\";\n\timport https from \"node:https\";\n\texport default async function (\n\t  req: http.IncomingMessage,\n\t  res: http.ServerResponse\n\t) {\n\t  const ISSUE_DB = new IssueModel();\n", "  const BOOK_DB = new BookModel();\n\t  const USER_DB = new UserModel();\n\t  const authorization = req.headers?.authorization;\n\t  const authToken = authorization?.split(\" \")?.pop()?.trim();\n\t  try {\n\t    if (req.method === \"OPTIONS\") {\n\t      sendJsonResponse(res, {}, 200);\n\t      return;\n\t    }\n\t    if (!authorization || !authToken) {\n", "      sendJsonResponse(res, ERROR.unauthorized, 401);\n\t      return;\n\t    }\n\t    const token = new Token();\n\t    const tokenStatus: TokStatus = token.verify(authToken);\n\t    if (\n\t      tokenStatus === TokStatus.INVALID ||\n\t      tokenStatus === TokStatus.INVALID_SIG\n\t    ) {\n\t      sendJsonResponse(res, ERROR.unauthorized, 401);\n", "      return;\n\t    }\n\t    await ISSUE_DB.init();\n\t    await BOOK_DB.init();\n\t    await USER_DB.init();\n\t    const parsedAuthToken: any = token.UNSAFE_parse(authToken);\n\t    if (req.method === \"GET\") {\n\t      let URLParams = req.url.split(\"/\").slice(3);\n\t      let requestedBook = URLParams?.[0];\n\t      if (requestedBook) {\n", "        let targetBook = await BOOK_DB.getBook(requestedBook);\n\t        if (!targetBook) {\n\t          sendJsonResponse(res, ERROR.resourceNotExists, 404);\n\t          return;\n\t        }\n\t        let epubResourcePath = targetBook.path;\n\t        const response: Array<Buffer> = await new Promise((resolve, reject) => {\n\t          https.get(epubResourcePath, (res) => {\n\t            let data: Array<Buffer> = [];\n\t            res.on(\"data\", (d: Buffer) => data.push(d));\n", "            res.on(\"end\", () => resolve(data));\n\t            res.on(\"error\", (error) => reject(error));\n\t          });\n\t        });\n\t        let epubBuffer = Buffer.concat(response);\n\t        sendEpubResponse(res, epubBuffer);\n\t        return;\n\t      } else {\n\t        let userIssues = await ISSUE_DB.getIssues(parsedAuthToken.id);\n\t        if (!userIssues) {\n", "          sendJsonResponse(res, ERROR.resourceNotExists, 404);\n\t        } else {\n\t          sendJsonResponse(res, userIssues, 200);\n\t        }\n\t      }\n\t    } else if (req.method === \"POST\") {\n\t      if (req.headers?.[\"content-type\"] != \"application/json\") {\n\t        sendJsonResponse(res, ERROR.invalidMimeForResource, 415);\n\t        return;\n\t      }\n", "      let issueData: Issue;\n\t      try {\n\t        let issuePostData = await parseSimplePostData(req);\n\t        issueData = JSON.parse(issuePostData.toString());\n\t      } catch (error) {\n\t        console.error(error);\n\t        sendJsonResponse(res, ERROR.badRequest, 400);\n\t        return;\n\t      }\n\t      if (!issueData.lenderid || !issueData.bookid) {\n", "        sendJsonResponse(res, ERROR.badRequest, 400);\n\t        return;\n\t      }\n\t      let foundLender = await USER_DB.getUserByID(issueData.lenderid);\n\t      let foundBook = await BOOK_DB.getBook(issueData.bookid);\n\t      if (!foundLender || !foundBook) {\n\t        sendJsonResponse(res, ERROR.resourceNotExists, 404);\n\t        return;\n\t      }\n\t      let foundIssue = await ISSUE_DB.getIssue(\n", "        foundLender.id,\n\t        foundBook.id,\n\t        parsedAuthToken.id\n\t      );\n\t      if (foundIssue) {\n\t        sendJsonResponse(\n\t          res,\n\t          {\n\t            ...ERROR.resourceExists,\n\t            data: {\n", "              id: foundIssue.id,\n\t              bookid: foundIssue.bookid,\n\t            },\n\t          },\n\t          409\n\t        );\n\t        return;\n\t      }\n\t      let issueid = uuid();\n\t      let issueEntry: Issue = {\n", "        id: issueid,\n\t        borrowerid: parsedAuthToken.id,\n\t        lenderid: foundLender.id,\n\t        bookid: foundBook.id,\n\t      };\n\t      const pushed = await ISSUE_DB.pushIssue(issueEntry);\n\t      if (!pushed) {\n\t        sendJsonResponse(res, ERROR.internalErr, 500);\n\t        return;\n\t      }\n", "      sendJsonResponse(\n\t        res,\n\t        {\n\t          error: null,\n\t          message: `successfully created a new issue of id ${issueEntry.id}`,\n\t          data: {\n\t            id: pushed.id,\n\t            borrower: pushed.borrowerid,\n\t            lender: pushed.lenderid,\n\t            book: foundBook.title,\n", "          },\n\t        },\n\t        201\n\t      );\n\t    }\n\t  } finally {\n\t    await ISSUE_DB.close();\n\t    await BOOK_DB.close();\n\t    await USER_DB.close();\n\t  }\n", "}\n"]}
{"filename": "src/routes/Books.ts", "chunked_list": ["import BookModel from \"../models/BookModel\";\n\timport Bucket from \"../models/Bucket\";\n\timport Token from \"../lib/GenerateToken\";\n\timport { ERROR, MAX_EPUB_SIZE_MB } from \"../common/const\";\n\timport { TokStatus, Book } from \"../common/types\";\n\timport {\n\t  sendJsonResponse,\n\t  parseSimplePostData,\n\t  md5,\n\t  uuid,\n", "} from \"../common/utils\";\n\timport filetype from \"file-type-cjs\";\n\timport fs from \"node:fs\";\n\timport EPub from \"epub\";\n\timport os from \"node:os\";\n\timport path from \"node:path\";\n\timport crypto from \"node:crypto\";\n\timport { exec } from \"node:child_process\";\n\timport http from \"node:http\";\n\tasync function getEpubCoverFromEpubFile_UNIX(\n", "  epubFilepath: string\n\t): Promise<[Buffer, string] | null> {\n\t  let randomString = crypto.randomBytes(16).toString(\"hex\");\n\t  let tempDir = path.join(os.tmpdir(), `tmp-${randomString}`);\n\t  fs.mkdirSync(tempDir);\n\t  let unzipCMD = `unzip -q ${epubFilepath} -d ${tempDir}`;\n\t  let unzipCMDExec = new Promise((resolve, reject) => {\n\t    exec(unzipCMD, (err: any, stdout: any, stderr: any) => {\n\t      if (err) reject(err);\n\t      resolve(stdout);\n", "    });\n\t  });\n\t  try {\n\t    await unzipCMDExec;\n\t  } catch (err) {\n\t    console.error(err);\n\t    fs.rmSync(tempDir, { recursive: true }); // we r good boys!\n\t    return null;\n\t  }\n\t  let findCMD = `find ${tempDir} -type f \\\\( -iname \\\\*.jpeg -o -iname \\\\*.jpg -o -iname \\\\*.png \\\\) | grep -Ei 'cover\\\\.|index-1_1'`;\n", "  let findCMDExec: Promise<string> = new Promise((resolve, reject) => {\n\t    exec(findCMD, (err: any, stdout: any, stderr: any) => {\n\t      if (err) reject(err);\n\t      resolve(stdout);\n\t    });\n\t  });\n\t  let selectedFilePath: string;\n\t  try {\n\t    selectedFilePath = await findCMDExec;\n\t    selectedFilePath = selectedFilePath.trim();\n", "  } catch (err) {\n\t    console.error(err);\n\t    fs.rmSync(tempDir, { recursive: true }); // we r good boys!\n\t    return null;\n\t  }\n\t  let ret: [Buffer, string] = [\n\t    Buffer.from(fs.readFileSync(selectedFilePath)),\n\t    selectedFilePath,\n\t  ];\n\t  fs.rmSync(tempDir, { recursive: true }); // we r good boys!\n", "  return ret;\n\t}\n\texport default async function (\n\t  req: http.IncomingMessage,\n\t  res: http.ServerResponse\n\t) {\n\t  const BOOK_DB = new BookModel();\n\t  const BUCKET = new Bucket();\n\t  await BOOK_DB.init();\n\t  await BUCKET.init();\n", "  try {\n\t    if (req.method === \"GET\") {\n\t      try {\n\t        let userBooks = await BOOK_DB.getBooks();\n\t        userBooks = userBooks.map((e) => {\n\t          delete e.path;\n\t          return e;\n\t        });\n\t        sendJsonResponse(res, userBooks, 200);\n\t      } catch (error) {\n", "        console.error(error);\n\t        sendJsonResponse(res, ERROR.internalErr);\n\t      }\n\t    } else if (req.method === \"POST\") {\n\t      const authorization = req.headers?.authorization;\n\t      const authToken = authorization?.split(\" \")?.pop();\n\t      if (!authorization || !authToken) {\n\t        sendJsonResponse(res, ERROR.unauthorized, 401);\n\t        return;\n\t      }\n", "      const token = new Token();\n\t      const tokenStatus: TokStatus = token.verify(authToken);\n\t      if (\n\t        tokenStatus === TokStatus.INVALID ||\n\t        tokenStatus === TokStatus.INVALID_SIG\n\t      ) {\n\t        sendJsonResponse(res, ERROR.unauthorized, 401);\n\t        return;\n\t      }\n\t      const parsedAuthToken: any = token.UNSAFE_parse(authToken);\n", "      let epubBuffer: Buffer;\n\t      epubBuffer = await parseSimplePostData(req);\n\t      let epubSizeInMB = Math.ceil(epubBuffer.length / 1e6);\n\t      let bufferMime = await filetype.fromBuffer(epubBuffer);\n\t      if (bufferMime.mime != \"application/epub+zip\") {\n\t        sendJsonResponse(res, ERROR.invalidMimeForResource, 415);\n\t        return;\n\t      }\n\t      if (epubSizeInMB > MAX_EPUB_SIZE_MB) {\n\t        sendJsonResponse(res, ERROR.fileTooLarge, 400);\n", "        return;\n\t      }\n\t      let randomString = crypto.randomBytes(16).toString(\"hex\");\n\t      const tempEpubFilePath = path.join(os.tmpdir(), `tmp-${randomString}.epub`);\n\t      fs.writeFileSync(tempEpubFilePath, epubBuffer);\n\t      const epub: any = await new Promise((resolve, reject) => {\n\t        const epub = new EPub(tempEpubFilePath);\n\t        epub.on(\"end\", () => resolve(epub));\n\t        epub.on(\"error\", reject);\n\t        epub.parse();\n", "      });\n\t      let epubCoverBuffer = await getEpubCoverFromEpubFile_UNIX(tempEpubFilePath);\n\t      console.log(epubCoverBuffer);\n\t      let epubSignature = md5(epubBuffer.toString(\"hex\"));\n\t      let foundBook = await BOOK_DB.getBook(\"\", epubSignature);\n\t      if (foundBook) {\n\t        sendJsonResponse(\n\t          res,\n\t          {\n\t            ...ERROR.resourceExists,\n", "            data: {\n\t              id: foundBook.id,\n\t            },\n\t          },\n\t          409\n\t        );\n\t        return;\n\t      }\n\t      let epubFilePermalink = await BUCKET.pushBufferWithName(\n\t        epubBuffer,\n", "        `${epubSignature}.epub`\n\t      );\n\t      let epubCoverPermalink = null;\n\t      if (epubCoverBuffer) {\n\t        epubCoverPermalink = await BUCKET.pushBufferWithName(\n\t          epubCoverBuffer[0],\n\t          `${epubSignature}.${epubCoverBuffer[1].split(\".\").pop()}`\n\t        );\n\t      }\n\t      let epubID = uuid();\n", "      let epubEntry: Book = {\n\t        id: epubID,\n\t        userid: parsedAuthToken.id,\n\t        title: epub.metadata?.title ?? epubID.split(\"-\").pop(),\n\t        author: epub.metadata?.creator ?? parsedAuthToken.email,\n\t        path: epubFilePermalink,\n\t        signature: epubSignature,\n\t        cover: epubCoverPermalink,\n\t      };\n\t      const pushed = await BOOK_DB.pushBook(epubEntry);\n", "      if (!pushed) {\n\t        sendJsonResponse(res, ERROR.internalErr, 500);\n\t        return;\n\t      }\n\t      sendJsonResponse(\n\t        res,\n\t        {\n\t          error: null,\n\t          message: `successfully published a book of id ${epubEntry.id}`,\n\t          data: {\n", "            id: epubEntry.id,\n\t          },\n\t        },\n\t        201\n\t      );\n\t    } else if (req.method === \"DELETE\") {\n\t      const authorization = req.headers?.authorization;\n\t      const authToken = authorization?.split(\" \")?.pop();\n\t      if (!authorization || !authToken) {\n\t        sendJsonResponse(res, ERROR.unauthorized, 401);\n", "        return;\n\t      }\n\t      const token = new Token();\n\t      const tokenStatus: TokStatus = token.verify(authToken);\n\t      if (\n\t        tokenStatus === TokStatus.INVALID ||\n\t        tokenStatus === TokStatus.INVALID_SIG\n\t      ) {\n\t        sendJsonResponse(res, ERROR.unauthorized, 401);\n\t        return;\n", "      }\n\t      const parsedAuthToken: any = token.UNSAFE_parse(authToken);\n\t      let body: Buffer;\n\t      body = await parseSimplePostData(req);\n\t      let data: any;\n\t      try {\n\t        data = JSON.parse(body.toString());\n\t      } catch {\n\t        sendJsonResponse(res, ERROR.invalidJSONData, 400);\n\t        return;\n", "      }\n\t      if (!data.bookid) {\n\t        sendJsonResponse(res, ERROR.badRequest, 400);\n\t        return;\n\t      }\n\t      let bookDeleted = await BOOK_DB.deleteBook(data.bookid, parsedAuthToken.id);\n\t      if (!bookDeleted) {\n\t        sendJsonResponse(res, {\n\t          error: \"unable-to-delete-book\",\n\t          message: `was unable to delete book ${data.bookid}, perhaps the id was invalid?`,\n", "          status: 404\n\t        }, 404)\n\t        return;\n\t      }\n\t      sendJsonResponse(res, {\n\t        error: null,\n\t        message: `successfully deleted book of id ${data.bookid}`,\n\t        status: 204,\n\t        data: {\n\t          id: data.bookid,\n", "        }\n\t      }, 204)\n\t    }\n\t  } finally {\n\t    await BOOK_DB.close();\n\t  }\n\t}\n"]}
{"filename": "src/routes/Login.ts", "chunked_list": ["import http from \"node:http\";\n\timport { sendJsonResponse, md5, parseSimplePostData } from \"../common/utils\";\n\timport Token from \"../lib/GenerateToken\";\n\timport { ERROR } from \"../common/const\";\n\timport UserModel from \"../models/UserModel\";\n\timport { User } from \"../common/types\";\n\texport default async function (\n\t  req: http.IncomingMessage,\n\t  res: http.ServerResponse\n\t) {\n", "  const DB = new UserModel();\n\t  let data: any = await parseSimplePostData(req);\n\t  data = data.toString();\n\t  if (req.method !== \"POST\") {\n\t    sendJsonResponse(res, ERROR.methodNotAllowed, 405);\n\t    return;\n\t  }\n\t  let parsedData: User;\n\t  try {\n\t    parsedData = JSON.parse(data);\n", "  } catch(error) {\n\t    sendJsonResponse(res, ERROR.invalidJSONData, 400)\n\t    return;\n\t  }\n\t  await DB.init();\n\t  const foundUser: User = await DB.getUser(parsedData.email);\n\t  await DB.close();\n\t  if (!foundUser) {\n\t    sendJsonResponse(res, ERROR.userNotFound, 404);\n\t    return;\n", "  }\n\t  if (md5(parsedData.password) !== foundUser.password) {\n\t    sendJsonResponse(res, ERROR.unauthorized, 401);\n\t    return;\n\t  }\n\t  const token = new Token();\n\t  const { password, ...tokenBody} = foundUser;\n\t  let accessToken = token.generate(tokenBody);\n\t  sendJsonResponse(res, {\n\t    messaged: \"found the given user\",\n", "    status: 200,\n\t    error: null,\n\t    token: accessToken,\n\t    data: {\n\t      email: foundUser.email,\n\t      id: foundUser.id,\n\t    }\n\t  }, 200)\n\t}\n"]}
