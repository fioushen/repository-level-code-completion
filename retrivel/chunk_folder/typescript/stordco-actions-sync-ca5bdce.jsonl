{"filename": "src/config.ts", "chunked_list": ["import { ok } from \"assert\";\n\timport * as core from \"@actions/core\";\n\timport { join } from \"path\";\n\timport { createTempPath } from \"./utility\";\n\texport type Config = {\n\t  commitBranch: string;\n\t  commitMessage: string;\n\t  commitUserEmail: string;\n\t  commitUserName: string;\n\t  fullPath: string;\n", "  path: string;\n\t  prAssignee?: string;\n\t  prBody: string;\n\t  prEnabled: boolean;\n\t  prLabels: string[];\n\t  prReviewUsers: string[];\n\t  prTitle: string;\n\t  prToken?: string;\n\t  syncAuth?: string;\n\t  syncPath: string;\n", "  syncRepository: string;\n\t  syncTree: string;\n\t  templateVariables: Record<string, string>;\n\t};\n\texport function getConfig(): Config {\n\t  const path = core.getInput(\"path\", { required: false });\n\t  const workspace = process.env.GITHUB_WORKSPACE;\n\t  ok(workspace, \"Expected GITHUB_WORKSPACE to be defined\");\n\t  return {\n\t    commitBranch: core.getInput(\"commit-branch\", { required: true }),\n", "    commitMessage: core.getInput(\"commit-message\", { required: true }),\n\t    commitUserEmail: core.getInput(\"commit-user-email\", { required: true }),\n\t    commitUserName: core.getInput(\"commit-user-name\", { required: true }),\n\t    fullPath: join(workspace, path),\n\t    path: path,\n\t    prBody: core.getInput(\"pr-body\", { required: false }),\n\t    prEnabled: core.getBooleanInput(\"pr-enabled\", { required: true }),\n\t    prLabels: core.getMultilineInput(\"pr-labels\", { required: false }),\n\t    prReviewUsers: core.getMultilineInput(\"pr-review-users\", {\n\t      required: false,\n", "    }),\n\t    prTitle: core.getInput(\"pr-title\", { required: true }),\n\t    prToken: core.getInput(\"pr-token\", { required: false }),\n\t    syncAuth: core.getInput(\"sync-auth\", { required: false }),\n\t    syncPath: createTempPath(),\n\t    syncRepository: core.getInput(\"sync-repository\", { required: true }),\n\t    syncTree:\n\t      core.getInput(\"sync-branch\", { required: false }) ||\n\t      core.getInput(\"sync-tree\", { required: true }),\n\t    templateVariables: {},\n", "  };\n\t}\n"]}
{"filename": "src/git.ts", "chunked_list": ["import { ok } from \"assert\";\n\timport * as core from \"@actions/core\";\n\timport { exec } from \"@actions/exec\";\n\timport { RequestError } from \"@octokit/request-error\";\n\timport { mkdirP } from \"@actions/io\";\n\timport { Config } from \"./config\";\n\timport { getOctokit } from \"./octokit\";\n\texport async function cloneRepository(config: Config): Promise<void> {\n\t  const { syncAuth, syncPath, syncRepository, syncTree } = config;\n\t  const tempDirectory = await mkdirP(syncPath);\n", "  await exec(\n\t    `git clone https://${syncAuth}@${syncRepository} ${syncPath}`,\n\t    [],\n\t    {\n\t      silent: !core.isDebug(),\n\t    },\n\t  );\n\t  await exec(`git fetch`, [], {\n\t    cwd: syncPath,\n\t    silent: !core.isDebug(),\n", "  });\n\t  await exec(`git checkout --progress --force ${syncTree}`, [], {\n\t    cwd: syncPath,\n\t    silent: !core.isDebug(),\n\t  });\n\t}\n\texport async function configureRepository(config: Config): Promise<void> {\n\t  await exec(\"git\", [\"config\", \"user.email\", config.commitUserEmail], {\n\t    cwd: config.fullPath,\n\t    silent: !core.isDebug(),\n", "  });\n\t  await exec(\"git\", [\"config\", \"user.name\", config.commitUserName], {\n\t    cwd: config.fullPath,\n\t    silent: !core.isDebug(),\n\t  });\n\t  await exec(\"git\", [\"checkout\", \"-f\", \"-b\", config.commitBranch], {\n\t    cwd: config.fullPath,\n\t    silent: !core.isDebug(),\n\t  });\n\t}\n", "export async function commitChanges(config: Config): Promise<boolean> {\n\t  await exec(\"git\", [\"add\", \"-A\"], {\n\t    cwd: config.fullPath,\n\t    failOnStdErr: false,\n\t    ignoreReturnCode: true,\n\t    silent: !core.isDebug(),\n\t  });\n\t  const exitCode = await exec(\"git\", [\"commit\", \"-m\", config.commitMessage], {\n\t    cwd: config.fullPath,\n\t    failOnStdErr: false,\n", "    ignoreReturnCode: true,\n\t    silent: !core.isDebug(),\n\t  });\n\t  return exitCode === 0;\n\t}\n\texport async function createPr(config: Config): Promise<void> {\n\t  await exec(\"git\", [\"push\", \"-f\", \"-u\", \"origin\", config.commitBranch], {\n\t    cwd: config.fullPath,\n\t    silent: !core.isDebug(),\n\t  });\n", "  ok(process.env.GITHUB_REPOSITORY, \"Expected GITHUB_REPOSITORY to be defined\");\n\t  ok(config.prToken, \"Expected PR_TOKEN to be defined\");\n\t  const [owner, repo] = process.env.GITHUB_REPOSITORY.split(\"/\");\n\t  const octokit = getOctokit(config.prToken);\n\t  const { data: repository } = await octokit.rest.repos.get({ owner, repo });\n\t  for (const name of config.prLabels) {\n\t    core.debug(`Creating issue label ${name}`);\n\t    try {\n\t      await octokit.rest.issues.createLabel({ owner, repo, name });\n\t    } catch (err) {\n", "      if (err instanceof RequestError && err.status === 422) {\n\t        core.debug(`Issue label ${name} already exists`);\n\t      } else {\n\t        throw err;\n\t      }\n\t    }\n\t  }\n\t  try {\n\t    const res = await octokit.rest.pulls.create({\n\t      owner,\n", "      repo,\n\t      base: repository.default_branch,\n\t      body: config.prBody,\n\t      head: config.commitBranch,\n\t      maintainer_can_modify: true,\n\t      title: config.prTitle,\n\t    });\n\t    await octokit.rest.issues.addLabels({\n\t      owner,\n\t      repo,\n", "      issue_number: res.data.number,\n\t      labels: config.prLabels,\n\t    });\n\t    await octokit.rest.pulls.requestReviewers({\n\t      owner,\n\t      repo,\n\t      pull_number: res.data.number,\n\t      reviewers: config.prReviewUsers,\n\t    });\n\t    core.setOutput(\"pr-url\", res.data.html_url);\n", "  } catch (err) {\n\t    if (err instanceof RequestError && err.status === 422) {\n\t      core.debug(\"PR already exists\");\n\t    } else {\n\t      throw err;\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/octokit.ts", "chunked_list": ["import type { Octokit } from \"@octokit/core\";\n\timport { getOctokit as upstreamOctokit } from \"@actions/github\";\n\timport { retry } from \"@octokit/plugin-retry\";\n\timport { throttling } from \"@octokit/plugin-throttling\";\n\tfunction onLimit(\n\t  retryAfter: number,\n\t  { method, url }: { method: string; url: string },\n\t  octokit: Octokit,\n\t) {\n\t  octokit.log.warn(`Request quota exhausted for request ${method} ${url}`);\n", "  octokit.log.info(`Retrying after ${retryAfter} seconds`);\n\t  return true;\n\t}\n\texport function getOctokit(token: string) {\n\t  return upstreamOctokit(\n\t    token,\n\t    {\n\t      retry: {\n\t        enabled: true,\n\t      },\n", "      throttle: {\n\t        enabled: true,\n\t        onSecondaryRateLimit: onLimit,\n\t        onRateLimit: onLimit,\n\t        timeout: 1000 * 60 * 20,\n\t      },\n\t    },\n\t    retry,\n\t    throttling,\n\t  );\n", "}\n"]}
{"filename": "src/scripts.test.ts", "chunked_list": ["import { describe, expect, it } from \"vitest\";\n\timport { resolve } from \"path\";\n\timport { readOutput } from \"./scripts\";\n\tdescribe.concurrent(\"scripts\", () => {\n\t  it(\"parses single line output\", async () => {\n\t    const fixturePath = resolve(\n\t      __dirname,\n\t      \"../test/fixtures/scripts/single-line-output\",\n\t    );\n\t    const output = await readOutput(fixturePath);\n", "    expect(output).toEqual({\n\t      keyone: \"valueone\",\n\t      key_two: \"value_two\",\n\t      keyThree: \"valueThree\",\n\t    });\n\t  });\n\t  it(\"parses quoted string output\", async () => {\n\t    const fixturePath = resolve(\n\t      __dirname,\n\t      \"../test/fixtures/scripts/single-line-quoted-string-output\",\n", "    );\n\t    const output = await readOutput(fixturePath);\n\t    expect(output).toEqual({\n\t      keyone: \"valueone\",\n\t      key_two: \"value_two\",\n\t      keyThree: \"valueThree\",\n\t    });\n\t  });\n\t  it(\"parses multi line heredocs\", async () => {\n\t    // NOTE: This trims whitespace due to how we parse and the ugly regex. Should be fine for our use case.\n", "    const fixturePath = resolve(\n\t      __dirname,\n\t      \"../test/fixtures/scripts/multi-line-heredoc-output\",\n\t    );\n\t    const output = await readOutput(fixturePath);\n\t    expect(output).toEqual({\n\t      keyone: \"testing line one\\ntesting line two\",\n\t      key_two:\n\t        'testing line one\\n\"testing line two\"\\nextra empty line after this',\n\t    });\n", "  });\n\t});\n"]}
{"filename": "src/templates.test.ts", "chunked_list": ["import { readFile, mkdtemp, rm } from \"fs/promises\";\n\timport { afterEach, beforeEach, describe, expect, it } from \"vitest\";\n\timport { join, resolve } from \"path\";\n\timport { tmpdir } from \"os\";\n\timport { v4 as uuid } from \"uuid\";\n\timport { Config } from \"./config\";\n\timport { templateFiles } from \"./templates\";\n\tinterface LocalTestContext {\n\t  config: Config;\n\t}\n", "describe.concurrent(\"templates\", () => {\n\t  beforeEach<LocalTestContext>(async (ctx) => {\n\t    const fullPath = await mkdtemp(join(tmpdir(), \"actions-sync\"));\n\t    ctx.config = {\n\t      commitBranch: \"main\",\n\t      commitMessage: \"commit message\",\n\t      commitUserEmail: \"test@example.com\",\n\t      commitUserName: \"testing\",\n\t      fullPath,\n\t      path: \"\",\n", "      prAssignee: \"\",\n\t      prBody: \"testing\",\n\t      prEnabled: false,\n\t      prLabels: [],\n\t      prReviewUsers: [],\n\t      prTitle: \"testing\",\n\t      syncAuth: \"\",\n\t      syncBranch: \"main\",\n\t      syncPath: resolve(__dirname, \"../test/fixtures\"),\n\t      syncRepository: \"test/test\",\n", "      templateVariables: {},\n\t    };\n\t  });\n\t  afterEach<LocalTestContext>(async (ctx) => {\n\t    await rm(ctx.config.fullPath, { recursive: true });\n\t  });\n\t  it<LocalTestContext>(\"can template basic json files\", async (ctx) => {\n\t    await templateFiles(ctx.config);\n\t    const path = join(ctx.config.fullPath, \"basic.json\");\n\t    const data = await readFile(path, \"utf8\");\n", "    expect(data).toEqual(\n\t      `{\\n  \"keyOne\": true,\\n  \"keyThree\": \"valueThree\"\\n}\\n`,\n\t    );\n\t  });\n\t  it<LocalTestContext>(\"can use template variables\", async (ctx) => {\n\t    await templateFiles({\n\t      ...ctx.config,\n\t      templateVariables: { KEY_TWO: \"true\" },\n\t    });\n\t    const path = join(ctx.config.fullPath, \"basic.json\");\n", "    const data = await readFile(path, \"utf8\");\n\t    expect(data).toEqual(\n\t      `{\\n  \"keyOne\": true,\\n  \"keyTwo\": \"valueTwo\",\\n  \"keyThree\": \"valueThree\"\\n}\\n`,\n\t    );\n\t  });\n\t});\n"]}
{"filename": "src/utility.ts", "chunked_list": ["import { ok } from \"assert\";\n\timport { join } from \"path\";\n\timport { v4 as uuid } from \"uuid\";\n\texport function createTempPath(): string {\n\t  return join(getTempDirectory(), uuid());\n\t}\n\texport function getTempDirectory(): string {\n\t  const tempDirectory = process.env[\"RUNNER_TEMP\"] || \"\";\n\t  ok(tempDirectory, \"Expected RUNNER_TEMP to be defined\");\n\t  return tempDirectory;\n", "}\n"]}
{"filename": "src/templates.ts", "chunked_list": ["import * as core from \"@actions/core\";\n\timport * as glob from \"@actions/glob\";\n\timport { open, readFile, writeFile } from \"fs/promises\";\n\timport Handlebars from \"handlebars\";\n\timport { dirname, join, relative } from \"path\";\n\timport { mkdirP } from \"@actions/io\";\n\timport { Config } from \"./config\";\n\texport async function templateFiles(config: Config): Promise<void> {\n\t  const templateGlob = await glob.create(`${config.syncPath}/templates/*`, {\n\t    matchDirectories: false,\n", "  });\n\t  const templatePaths = await templateGlob.glob();\n\t  core.info(`Templating ${templatePaths.length} files...`);\n\t  for (const templatePath of templatePaths) {\n\t    const relativePath = relative(`${config.syncPath}/templates`, templatePath);\n\t    core.info(`Template ${relativePath}`);\n\t    try {\n\t      const templateData = await readFile(templatePath, \"utf8\");\n\t      const templateHandlebar = Handlebars.compile(templateData);\n\t      const fileData = templateHandlebar(config.templateVariables);\n", "      core.debug(fileData);\n\t      const writePath = join(config.fullPath, relativePath);\n\t      core.debug(`Writing: ${writePath}`);\n\t      await mkdirP(dirname(writePath));\n\t      const io = await open(writePath, \"a\");\n\t      await io.close();\n\t      await writeFile(writePath, fileData);\n\t      core.debug(\"File written.\");\n\t    } catch (err) {\n\t      core.error(`Error templating ${relativePath}: ${err}`);\n", "    }\n\t  }\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import * as core from \"@actions/core\";\n\timport {\n\t  configureRepository,\n\t  cloneRepository,\n\t  commitChanges,\n\t  createPr,\n\t} from \"./git\";\n\timport { getConfig } from \"./config\";\n\timport { templateFiles } from \"./templates\";\n\timport { runScripts } from \"./scripts\";\n", "export async function run() {\n\t  const config = getConfig();\n\t  await configureRepository(config);\n\t  await cloneRepository(config);\n\t  await runScripts(config);\n\t  await templateFiles(config);\n\t  if (config.prEnabled) {\n\t    const hasChanges = await commitChanges(config);\n\t    if (hasChanges === false) {\n\t      core.info(\"No changes to commit.\");\n", "      return;\n\t    }\n\t    core.info(\"Creating PR\");\n\t    await createPr(config);\n\t    core.info(\"Created PR\");\n\t  } else {\n\t    core.info(\"Skipping PR creation\");\n\t  }\n\t}\n"]}
{"filename": "src/scripts.ts", "chunked_list": ["import * as core from \"@actions/core\";\n\timport { exec } from \"@actions/exec\";\n\timport * as glob from \"@actions/glob\";\n\timport { relative } from \"path\";\n\timport { open, readFile, utimes } from \"fs/promises\";\n\timport { Config } from \"./config\";\n\timport { createTempPath } from \"./utility\";\n\timport { rmRF } from \"@actions/io\";\n\tconst LINE_REGEX =\n\t  /(?:^)([\\w.-]+)=(?:<<([\\w.-]+)\\n([\\s\\S]*)\\n\\2)?(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:$|$)/gm;\n", "export async function runScripts(config: Config): Promise<void> {\n\t  const scriptGlob = await glob.create(`${config.syncPath}/scripts/*`);\n\t  const scriptPathsUnsorted = await scriptGlob.glob();\n\t  const scriptPaths = scriptPathsUnsorted.sort();\n\t  core.info(`Running ${scriptPaths.length} scripts...`);\n\t  for (const scriptPath of scriptPaths) {\n\t    core.startGroup(`Run ${relative(config.syncPath, scriptPath)}`);\n\t    const newTemplateVariables = await runScript(scriptPath, config);\n\t    core.debug(\n\t      \"Adding new template variables\\n\" +\n", "        JSON.stringify(newTemplateVariables, null, 2),\n\t    );\n\t    config.templateVariables = {\n\t      ...config.templateVariables,\n\t      ...newTemplateVariables,\n\t    };\n\t    core.endGroup();\n\t  }\n\t}\n\texport async function runScript(\n", "  scriptPath: string,\n\t  config: Config,\n\t): Promise<Record<string, string>> {\n\t  const outputFilePath = createTempPath();\n\t  const io = await open(outputFilePath, \"a\");\n\t  await io.close();\n\t  await exec(scriptPath, [], {\n\t    cwd: config.fullPath,\n\t    env: {\n\t      ...process.env,\n", "      ...config.templateVariables,\n\t      SYNC_BRANCH: config.syncTree,\n\t      SYNC_PATH: config.syncPath,\n\t      SYNC_REPOSITORY: config.syncRepository,\n\t      SYNC_TREE: config.syncTree,\n\t      TEMPLATE_ENV: outputFilePath,\n\t    },\n\t    silent: false,\n\t    failOnStdErr: false,\n\t    ignoreReturnCode: true,\n", "  });\n\t  const newTemplateVariables = await readOutput(outputFilePath);\n\t  await rmRF(outputFilePath);\n\t  return newTemplateVariables;\n\t}\n\t// Most of the code taken from dotenv and adapted for heredocs to match GitHub Actions output\n\texport async function readOutput(\n\t  path: string,\n\t): Promise<Record<string, string>> {\n\t  const result = {} as Record<string, string>;\n", "  const lines = (await readFile(path, \"utf8\")).replace(/\\r\\n?/gm, \"\\n\");\n\t  let match;\n\t  while ((match = LINE_REGEX.exec(lines)) != null) {\n\t    const key = match[1];\n\t    const isHeredoc = match[3] != null;\n\t    let value = ((isHeredoc ? match[3] : match[4]) || \"\").trim();\n\t    if (!isHeredoc) {\n\t      const maybeQuote = value[0];\n\t      value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/gm, \"$2\");\n\t      if (maybeQuote === '\"') {\n", "        value = value.replace(/\\\\n/g, \"\\n\");\n\t        value = value.replace(/\\\\r/g, \"\\r\");\n\t      }\n\t    }\n\t    result[key] = value;\n\t  }\n\t  return result;\n\t}\n"]}
{"filename": "src/entrypoint.ts", "chunked_list": ["import * as core from \"@actions/core\";\n\timport { run } from \"./index\";\n\t(async () => {\n\t  try {\n\t    await run();\n\t  } catch (error) {\n\t    if (error instanceof Error) {\n\t      core.setFailed(error.message);\n\t    } else if (typeof error === \"string\") {\n\t      core.setFailed(error);\n", "    } else {\n\t      core.setFailed(\"Unknown error occurred\");\n\t    }\n\t    process.exit(1);\n\t  }\n\t})();\n"]}
