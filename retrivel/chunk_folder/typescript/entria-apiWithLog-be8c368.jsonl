{"filename": "scripts/test.ts", "chunked_list": ["import { apiWithLog } from '../src/apiWithLog';\n\tconst run = async () => {\n\t  const url = 'https://cat-fact.herokuapp.com/facts'\n\t  await apiWithLog(url);\n\t};\n\t(async () => {\n\t  try {\n\t    await run();\n\t  } catch (err) {\n\t    // eslint-disable-next-line\n", "    console.log({\n\t      err,\n\t    });\n\t    process.exit(1);\n\t  }\n\t  process.exit(0);\n\t})();\n"]}
{"filename": "src/apiWithLog.ts", "chunked_list": ["import { RequestInfo, RequestInit, Response } from 'node-fetch';\n\timport { cloneResponse } from './cloneResponse';\n\timport { timeSpan } from './timeSpan';\n\timport { apiDebug }from './apiDebug';\n\timport { apiReport } from './apiReport';\n\timport { getRequestMock, saveRequestMock } from './apiCache';\n\tconst fetch = (url: URL | RequestInfo, init?: RequestInit) =>\n\t  import('node-fetch').then(({ default: fetch }) => fetch(url, init));\n\ttype RequestOptions = RequestInit & {\n\t  shouldReport?: boolean;\n", "};\n\texport const apiWithLog = async (\n\t  init: RequestInfo,\n\t  optionsApi: RequestOptions = { method: 'GET' },\n\t): Promise<Response> => {\n\t  const end = timeSpan();\n\t  const options = {\n\t    ...optionsApi,\n\t    headers: {\n\t      ...(optionsApi.headers || {}),\n", "      'user-agent': 'node-fetch',\n\t    },\n\t  };\n\t  const requestMock = await getRequestMock(init, options);\n\t  if (requestMock) {\n\t    return requestMock;\n\t  }\n\t  return fetch(init, options).then(async (response) => {\n\t    const durationTime = end();\n\t    const text = await response.text();\n", "    let json: any = null;\n\t    try {\n\t      json = JSON.parse(text);\n\t    } catch (err) {\n\t      // eslint-disable-next-line\n\t    }\n\t    const getBody = (): Record<string, string> => {\n\t      if (json) {\n\t        return {\n\t          json,\n", "        };\n\t      }\n\t      return {\n\t        text,\n\t      };\n\t    };\n\t    await saveRequestMock(init, options, text, response);\n\t    apiDebug({\n\t      init,\n\t      options,\n", "      durationTime,\n\t      getBody,\n\t      response,\n\t    });\n\t    await apiReport({\n\t      init,\n\t      options,\n\t      getBody,\n\t      response,\n\t      json,\n", "      text,\n\t    });\n\t    const { responseCopy } = await cloneResponse(response, text);\n\t    return responseCopy;\n\t  });\n\t};\n"]}
{"filename": "src/apiCache.ts", "chunked_list": ["import fs from 'fs';\n\timport path from 'path';\n\timport util from 'util';\n\timport writeFileAtomicCallback from 'write-file-atomic';\n\timport { RequestInfo, RequestInit, Response } from 'node-fetch';\n\timport { cloneResponse } from './cloneResponse';\n\timport { debugConsole } from './debugConsole';\n\timport { getCurl } from './getCurl';\n\tconst readFile = util.promisify(fs.readFile);\n\tconst writeFile = util.promisify(fs.writeFile);\n", "const writeFileAtomic = util.promisify(writeFileAtomicCallback);\n\tconst cwd = process.cwd();\n\tconst dirPath = 'mock-requests.json';\n\tconst output = path.join(cwd, dirPath);\n\texport const getRequestKey = (init: RequestInfo, options: RequestInit) => {\n\t  if (!options?.body) {\n\t    return `${options.method}:${init}`;\n\t  }\n\t  return `${options.method}:${init}:${JSON.stringify(options.body)}`;\n\t};\n", "export const saveRequestMock = async (\n\t  init: RequestInfo,\n\t  options: RequestInit,\n\t  text: string,\n\t  response: Response,\n\t) => {\n\t  if (process.env.WRITE_MOCK !== 'true') {\n\t    return;\n\t  }\n\t  // only save ok requests 200\n", "  if (!response.ok) {\n\t    return;\n\t  }\n\t  const requestKey = getRequestKey(init, options);\n\t  let dataString = null;\n\t  try {\n\t    if (fs.existsSync(output)) {\n\t      dataString = await readFile(output, 'utf8');\n\t      console.log(dataString);\n\t    } else {\n", "      await writeFile(output, '');\n\t    }\n\t  } catch (err) {\n\t    // eslint-disable-next-line\n\t    console.log({ err });\n\t  }\n\t  try {\n\t    const currentMock = dataString ? JSON.parse(dataString) : {};\n\t    const newRequest = {\n\t      text,\n", "      response: {\n\t        status: response.status,\n\t        statusText: response.statusText,\n\t        headers: response.headers,\n\t        ok: response?.ok,\n\t        size: response?.size,\n\t        url: response?.url,\n\t      },\n\t    };\n\t    const newMock = {\n", "      ...currentMock,\n\t      [requestKey]: newRequest,\n\t    };\n\t    const newMockString = JSON.stringify(newMock);\n\t    await writeFileAtomic(output, newMockString);\n\t    //eslint-disable-next-line\n\t    console.log(`saved to ${output}`);\n\t  } catch (err) {\n\t    // eslint-disable-next-line\n\t    console.log({ err });\n", "  }\n\t};\n\texport const getRequestMock = async (\n\t  init: RequestInfo,\n\t  options: RequestInit,\n\t) => {\n\t  if (process.env.USE_MOCK !== 'true') {\n\t    return;\n\t  }\n\t  const requestKey = getRequestKey(init, options);\n", "  try {\n\t    const dataString = await readFile(output, 'utf8');\n\t    if (!dataString) {\n\t      return null;\n\t    }\n\t    const currentMock = JSON.parse(dataString);\n\t    const mock = currentMock[requestKey];\n\t    if (!mock) {\n\t      return null;\n\t    }\n", "    const { text, response } = mock;\n\t    const { responseCopy } = await cloneResponse(response, text);\n\t    // eslint-disable-next-line\n\t    console.log('mock-cache: ', requestKey);\n\t    if (process.env.DEBUG === 'true') {\n\t      // eslint-disable-next-line\n\t      const { agent, ...optionsWithoutAgent } = options;\n\t      const curl = getCurl(init, options);\n\t      const getBody = () => {\n\t        let json = null;\n", "        try {\n\t          json = JSON.parse(text);\n\t        } catch (err) {}\n\t        if (json) {\n\t          return {\n\t            json,\n\t          };\n\t        }\n\t        return {\n\t          text,\n", "        };\n\t      };\n\t      // eslint-disable-next-line\n\t      debugConsole({\n\t        init,\n\t        options: optionsWithoutAgent,\n\t        ...getBody(),\n\t        ok: response.ok,\n\t        status: response.status,\n\t        curl,\n", "      });\n\t    }\n\t    return responseCopy;\n\t  } catch (err) {\n\t    // eslint-disable-next-line\n\t    console.log({ err });\n\t  }\n\t  return null;\n\t};\n"]}
{"filename": "src/logSecurity.ts", "chunked_list": ["// find a b\n\texport const ignoredHeaders = ['host', 'method', 'path', 'scheme', 'version', 'Api-Access-Key', 'Authorization'];"]}
{"filename": "src/timeSpan.ts", "chunked_list": ["type timeMeasureProps = \n\t  | \"milliseconds\"\n\t  | \"nanoseconds\"\n\t  | \"seconds\"\n\tconst conversionFactors: Record<timeMeasureProps, number> = {\n\t  'nanoseconds': 1,\n\t  'milliseconds': 1e6,\n\t  'seconds': 1e9,\n\t};\n\texport const timeSpan = () => {\n", "  const start = process.hrtime.bigint();\n\t  const end = (timeMeasure: timeMeasureProps) => {\n\t    const diff = process.hrtime.bigint() - start;\n\t    const factor = conversionFactors[timeMeasure];\n\t    return Number(diff) / factor;\n\t  };\n\t  const returnValue = () => end('milliseconds');\n\t  returnValue.rounded = () => Math.round(end('milliseconds'));\n\t  returnValue.seconds = () => end('seconds');\n\t  returnValue.nanoseconds = () => end('nanoseconds');\n", "  return returnValue;\n\t};\n"]}
{"filename": "src/apiReport.ts", "chunked_list": ["import * as Sentry from '@sentry/node';\n\timport { RequestInfo, RequestInit, Response } from 'node-fetch';\n\timport prettyFormat from 'pretty-format';\n\timport { getCurl } from './getCurl';\n\t// TODO: implement\n\tconst shouldReport = (..._: unknown[]) => false;\n\t// TODO: implement\n\tconst sendtoSlack = (..._: unknown[]) => {};\n\ttype RequestOptions = RequestInit & {\n\t  shouldReport?: boolean;\n", "};\n\ttype ApiReport = {\n\t  init: RequestInfo;\n\t  options: RequestOptions;\n\t  // durationTime: number;\n\t  getBody: () => Record<string, string>;\n\t  response: Response;\n\t  json: Record<string, string>;\n\t  text: string;\n\t};\n", "export const apiReport = async ({\n\t  init,\n\t  options,\n\t  getBody,\n\t  response,\n\t  json,\n\t  text,\n\t}: ApiReport) => {\n\t  const canReport =\n\t    typeof options?.shouldReport === 'boolean' ? options.shouldReport : true;\n", "  if (canReport && shouldReport(init, response, json, text)) {\n\t    const info = {\n\t      url: init,\n\t      method: options.method,\n\t      body: options.body,\n\t      status: response.status,\n\t      ...getBody(),\n\t    };\n\t    const curl = getCurl(init, options);\n\t    // do not send to slack error 500\n", "    if (response.status >= 500) {\n\t      // some external api is not working well\n\t      await sendtoSlack({\n\t        channel: 'pix',\n\t        icon_emoji: 'bug',\n\t        attachments: [\n\t          {\n\t            text: prettyFormat(info),\n\t          },\n\t          {\n", "            text: curl,\n\t          },\n\t        ],\n\t      });\n\t    }\n\t    const error = new Error(prettyFormat(info));\n\t    Sentry.setExtra('error', error);\n\t    Sentry.setExtra('curl', curl);\n\t    Sentry.captureException(error);\n\t  }\n", "};\n"]}
{"filename": "src/debugConsole.ts", "chunked_list": ["import util from 'util';\n\t// import prettyFormat from 'pretty-format';\n\texport const debugConsole = (obj: Record<string, unknown>) => {\n\t  // eslint-disable-next-line\n\t  console.log(\n\t    util.inspect(obj, {\n\t      showHidden: false,\n\t      depth: null,\n\t      colors: true,\n\t      showProxy: false,\n", "    }),\n\t  );\n\t  // eslint-disable-next-line\n\t  // console.log(prettyFormat(obj));\n\t};\n"]}
{"filename": "src/apiDebug.ts", "chunked_list": ["import chalk from 'chalk';\n\timport { RequestInfo, RequestInit, Response } from 'node-fetch';\n\timport { getCurl } from './getCurl';\n\timport { debugConsole } from './debugConsole';\n\timport { ignoredHeaders } from './logSecurity';\n\ttype ApiDebug = {\n\t  init: RequestInfo;\n\t  options: RequestInit;\n\t  durationTime: number;\n\t  getBody: () => Record<string, string>;\n", "  response: Response;\n\t};\n\texport const apiDebug = ({\n\t  init,\n\t  options,\n\t  durationTime,\n\t  getBody,\n\t  response,\n\t}: ApiDebug) => {\n\t  if (process.env.DEBUG !== 'true') {\n", "    return;\n\t  }\n\t  // eslint-disable-next-line\n\t  const { agent, headers, ...optionsWithoutAgent } = options;\n\t  const cleanHeaders = Object.keys(headers || {}).reduce((acc, key) => {\n\t    if (!headers || ignoredHeaders.includes(key)) {\n\t      return acc;\n\t    }\n\t    return {\n\t      ...acc,\n", "      [key]: (headers as Record<string, string>)[key],\n\t    };\n\t  }, {});\n\t  const cleanOptions = {\n\t    ...optionsWithoutAgent,\n\t    headers: cleanHeaders,\n\t  };\n\t  const curl = getCurl(init, options);\n\t  // eslint-disable-next-line\n\t  console.log(chalk.yellow(options.method || 'GET'), chalk.blue(init));\n", "  // eslint-disable-next-line\n\t  debugConsole({\n\t    time: `${durationTime}ms`,\n\t    init,\n\t    options: cleanOptions,\n\t    // text,\n\t    // json,\n\t    ...getBody(),\n\t    ok: response.ok,\n\t    status: response.status,\n", "    curl,\n\t  });\n\t};\n"]}
{"filename": "src/index.ts", "chunked_list": ["export { apiWithLog } from \"./apiWithLog\""]}
{"filename": "src/getCurl.ts", "chunked_list": ["import { Headers, Request, RequestInfo, RequestInit } from \"node-fetch\";\n\t// find a b\n\texport const ignoredHeaders = [\n\t  'host',\n\t  'method',\n\t  'path',\n\t  'scheme',\n\t  'version',\n\t  'Api-Access-Key',\n\t  'Authorization',\n", "];\n\t/**\n\t * see https://fetch.spec.whatwg.org/#methods\n\t *\n\t * @export\n\t * @param {any} options\n\t * @returns {string}\n\t */\n\texport const generateMethod = (options: Request | RequestInit): string => {\n\t  const method = options.method;\n", "  if (!method) return '';\n\t  const type: Record<string, string> = {\n\t    GET: ' -X GET',\n\t    POST: ' -X POST',\n\t    PUT: ' -X PUT',\n\t    PATCH: ' -X PATCH',\n\t    DELETE: ' -X DELETE',\n\t    HEAD: ' -X HEAD',\n\t    OPTIONS: ' -X OPTIONS',\n\t  };\n", "  return type[method.toUpperCase()] || '';\n\t};\n\t/**\n\t * @export\n\t * @param {any} val\n\t * @returns true if the envirtonment supports Headers and val is of instance Headers\n\t */\n\texport const isInstanceOfHeaders = (val: any): val is Headers => {\n\t  if (typeof Headers !== 'function') {\n\t    /**\n", "     * Environment does not support the Headers constructor\n\t     * old internet explorer?\n\t     */\n\t    return false;\n\t  }\n\t  return val instanceof Headers;\n\t};\n\t/**\n\t * @typedef {Object} HeaderParams\n\t * @property {Boolean} isEncode - A flag which is set to true if the request should set the --compressed flag\n", " * @property {String} params - The header params as string\n\t */\n\tconst getHeaderString = (name: string, val: string) => {\n\t  if (!val) {\n\t    return '';\n\t  }\n\t  return ` -H \"${name}: ${val.replace(/(\\\\|\")/g, '\\\\$1')}\"`;\n\t};\n\t/**\n\t * @export\n", " * @param {object={}} options\n\t * @param {object|Headers} options.headers\n\t * @returns {HeaderParams} An Object with the header info\n\t */\n\texport const generateHeader = (options = {} as any) => {\n\t  const { headers } = options;\n\t  let isEncode = false;\n\t  let headerParam = '';\n\t  if (isInstanceOfHeaders(headers)) {\n\t    headers.forEach((val: string, name: string) => {\n", "      if (ignoredHeaders.indexOf(name) === -1) {\n\t        if (name.toLocaleLowerCase() !== 'content-length') {\n\t          headerParam += getHeaderString(name, val);\n\t        }\n\t        if (name.toLocaleLowerCase() === 'accept-encoding') {\n\t          isEncode = true;\n\t        }\n\t      }\n\t    });\n\t  } else if (headers) {\n", "    Object.keys(headers)\n\t      .filter((name) => ignoredHeaders.indexOf(name) === -1)\n\t      .map((name) => {\n\t        if (name.toLocaleLowerCase() !== 'content-length') {\n\t          headerParam += getHeaderString(name, headers[name]);\n\t        }\n\t        if (name.toLocaleLowerCase() === 'accept-encoding') {\n\t          isEncode = true;\n\t        }\n\t      });\n", "  }\n\t  return {\n\t    params: headerParam,\n\t    isEncode,\n\t  };\n\t};\n\t/**\n\t *\n\t *\n\t * @export\n", " * @param {Object} body\n\t * @returns {string}\n\t */\n\texport function generateBody(body: string | object | null | undefined): string {\n\t  if (!body) return '';\n\t  if (typeof body === 'object') {\n\t    if (body.hasOwnProperty('has')) {\n\t      return ` --data-urlencode '${body.toString()}'`;\n\t    }\n\t    return ` --data-binary '${JSON.stringify(body)}'`;\n", "  }\n\t  return ` --data-binary '${body}'`;\n\t}\n\t/**\n\t *\n\t *\n\t * @export\n\t * @param {boolean} isEncode\n\t * @return {string}\n\t */\n", "export function generateCompress(isEncode: boolean): string {\n\t  return isEncode ? ' --compressed' : '';\n\t}\n\t/**\n\t *\n\t *\n\t * @export\n\t * @param {string|object} requestInfo\n\t * @param {object={}} requestInit\n\t */\n", "export const getCurl = (requestInfo: RequestInfo, requestInit: RequestInit) => {\n\t  let url;\n\t  let options;\n\t  /**\n\t   * initialization with an empty object is done here to\n\t   * keep everything backwards compatible to 0.4.0 and below\n\t   */\n\t  if (typeof requestInfo === 'string') {\n\t    url = requestInfo;\n\t    options = requestInit || {};\n", "  } else {\n\t    url = (requestInfo || {}).url;\n\t    options = requestInfo || {};\n\t  }\n\t  const { body } = options;\n\t  const headers = generateHeader(options);\n\t  return `curl '${url}'${generateMethod(options)}${\n\t    headers.params || ''\n\t  }${generateBody(body)}${generateCompress(headers.isEncode)}`;\n\t};\n"]}
{"filename": "src/jsonOrText.ts", "chunked_list": ["import { Response } from \"node-fetch\";\n\texport const jsonOrText = async (\n\t  response: Response,\n\t): Promise<string | Record<string, unknown>> => {\n\t  const text = await response.text();\n\t  try {\n\t    return JSON.parse(text);\n\t  } catch (err) {\n\t    return text;\n\t  }\n", "};\n"]}
{"filename": "src/cloneResponse.ts", "chunked_list": ["import { Response } from \"node-fetch\";\n\t// This function clone the response consume your body and return the same response\n\t// `clone()` is broken in `node-fetch` and results in a stalled Promise\n\t// for responses above a certain size threshold. So construct a similar\n\t// clone ourselves...\n\ttype CloneResponse = {\n\t  responseCopy: Response;\n\t  text: string;\n\t  json: string;\n\t};\n", "export const cloneResponse = async (\n\t  response: Response,\n\t  responseText?: string | null,\n\t): Promise<CloneResponse> => {\n\t  const text = responseText ?? (await response.text());\n\t  let json = null;\n\t  try {\n\t    json = JSON.parse(text);\n\t  } catch (err) {\n\t    // eslint-disable-next-line\n", "  }\n\t  // eslint-disable-next-line\n\t  // @ts-ignore\n\t  const ResponseConstructor = fetch.Response || global.Response || response.constructor;\n\t  const responseCopy = new ResponseConstructor(text, {\n\t    status: response.status,\n\t    statusText: response.statusText,\n\t    headers: response.headers,\n\t    // These are not spec-compliant `Response` options, but `node-fetch`\n\t    // has them.\n", "    ok: response?.ok,\n\t    size: response?.size,\n\t    url: response?.url,\n\t  });\n\t  return {\n\t    responseCopy,\n\t    text,\n\t    json,\n\t  };\n\t};\n"]}
{"filename": "src/isMainScript.ts", "chunked_list": ["import path from 'path';\n\tconst cwd = process.cwd();\n\t// make it stable for all\n\t// node\n\t// yarn w\n\t// yarn b\n\t// yarn es\n\texport const isMainScript = (require: NodeJS.Require, module: NodeJS.Module, filename: string) => {\n\t  // webpack_entry is the real\n\t  if (process.env.WEBPACK_ENTRY) {\n", "    const fullEntry = path.join(cwd, process.env.WEBPACK_ENTRY);\n\t    const fullFilename = path.join(cwd, filename);\n\t    if (fullEntry === fullFilename) {\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t  if (!module.parent) {\n\t    return true;\n\t  }\n", "  if (process.env.DEBUG === 'true') {\n\t    // eslint-disable-next-line\n\t    console.log('not main script, check your script code');\n\t  }\n\t  return false;\n\t};\n"]}
