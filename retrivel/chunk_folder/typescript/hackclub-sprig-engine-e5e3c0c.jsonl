{"filename": "image-data.d.ts", "chunked_list": ["export * from './dist/image-data'"]}
{"filename": "web.d.ts", "chunked_list": ["export * from './dist/web'"]}
{"filename": "base.d.ts", "chunked_list": ["export * from './dist/base'"]}
{"filename": "src/api.ts", "chunked_list": ["export const VALID_INPUTS = [ 'w', 's', 'a', 'd', 'i', 'j', 'k', 'l' ] as const\n\texport type InputKey = typeof VALID_INPUTS[number]\n\texport interface AddTextOptions {\n\t\tx?: number\n\t\ty?: number\n\t\tcolor?: string\n\t}\n\texport declare class SpriteType {\n\t\ttype: string\n\t\tx: number\n", "\ty: number\n\t\treadonly dx: number\n\t\treadonly dy: number\n\t\tremove(): void\n\t}\n\texport type Rgba = [number, number, number, number]\n\texport interface TextElement {\n\t\tx: number\n\t\ty: number\n\t\tcolor: Rgba\n", "\tcontent: string\n\t}\n\texport interface GameState {\n\t\tlegend: [string, string][]\n\t\ttexts: TextElement[]\n\t\tdimensions: {\n\t\t\twidth: number\n\t\t\theight: number\n\t\t}\n\t\tsprites: SpriteType[]\n", "\tsolids: string[]\n\t\tpushable: Record<string, string[]>\n\t\tbackground: string | null\n\t}\n\texport interface PlayTuneRes {\n\t\tend(): void\n\t\tisPlaying(): boolean\n\t}\n\texport const tones: Record<string, number> = {\n\t\t'B0': 31,\n", "\t'C1': 33,\n\t\t'C#1': 35,\n\t\t'D1': 37,\n\t\t'D#1': 39,\n\t\t'E1': 41,\n\t\t'F1': 44,\n\t\t'F#1': 46,\n\t\t'G1': 49,\n\t\t'G#1': 52,\n\t\t'A1': 55,\n", "\t'A#1': 58,\n\t\t'B1': 62,\n\t\t'C2': 65,\n\t\t'C#2': 69,\n\t\t'D2': 73,\n\t\t'D#2': 78,\n\t\t'E2': 82,\n\t\t'F2': 87,\n\t\t'F#2': 93,\n\t\t'G2': 98,\n", "\t'G#2': 104,\n\t\t'A2': 110,\n\t\t'A#2': 117,\n\t\t'B2': 123,\n\t\t'C3': 131,\n\t\t'C#3': 139,\n\t\t'D3': 147,\n\t\t'D#3': 156,\n\t\t'E3': 165,\n\t\t'F3': 175,\n", "\t'F#3': 185,\n\t\t'G3': 196,\n\t\t'G#3': 208,\n\t\t'A3': 220,\n\t\t'A#3': 233,\n\t\t'B3': 247,\n\t\t'C4': 262,\n\t\t'C#4': 277,\n\t\t'D4': 294,\n\t\t'D#4': 311,\n", "\t'E4': 330,\n\t\t'F4': 349,\n\t\t'F#4': 370,\n\t\t'G4': 392,\n\t\t'G#4': 415,\n\t\t'A4': 440,\n\t\t'A#4': 466,\n\t\t'B4': 494,\n\t\t'C5': 523,\n\t\t'C#5': 554,\n", "\t'D5': 587,\n\t\t'D#5': 622,\n\t\t'E5': 659,\n\t\t'F5': 698,\n\t\t'F#5': 740,\n\t\t'G5': 784,\n\t\t'G#5': 831,\n\t\t'A5': 880,\n\t\t'A#5': 932,\n\t\t'B5': 988,\n", "\t'C6': 1047,\n\t\t'C#6': 1109,\n\t\t'D6': 1175,\n\t\t'D#6': 1245,\n\t\t'E6': 1319,\n\t\t'F6': 1397,\n\t\t'F#6': 1480,\n\t\t'G6': 1568,\n\t\t'G#6': 1661,\n\t\t'A6': 1760,\n", "\t'A#6': 1865,\n\t\t'B6': 1976,\n\t\t'C7': 2093,\n\t\t'C#7': 2217,\n\t\t'D7': 2349,\n\t\t'D#7': 2489,\n\t\t'E7': 2637,\n\t\t'F7': 2794,\n\t\t'F#7': 2960,\n\t\t'G7': 3136,\n", "\t'G#7': 3322,\n\t\t'A7': 3520,\n\t\t'A#7': 3729,\n\t\t'B7': 3951,\n\t\t'C8': 4186,\n\t\t'C#8': 4435,\n\t\t'D8': 4699,\n\t\t'D#8': 4978\n\t}\n\texport const instruments = [ 'sine', 'triangle', 'square', 'sawtooth' ] as const\n", "export type InstrumentType = typeof instruments[number]\n\texport const instrumentKey: Record<string, InstrumentType> = {\n\t\t'~': 'sine',\n\t\t'-': 'square',\n\t\t'^': 'triangle',\n\t\t'/': 'sawtooth'\n\t}\n\texport const reverseInstrumentKey = Object.fromEntries(\n\t\tObject.entries(instrumentKey).map(([ k, v ]) => [ v, k ])\n\t) as Record<InstrumentType, string>\n", "export type Tune = [number, ...(InstrumentType | number | string)[]][]\n\texport interface FullSprigAPI {\n\t\tmap(template: TemplateStringsArray, ...params: string[]): string\n\t\tbitmap(template: TemplateStringsArray, ...params: string[]): string\n\t\tcolor(template: TemplateStringsArray, ...params: string[]): string\n\t\ttune(template: TemplateStringsArray, ...params: string[]): string\n\t\tsetMap(string: string): void\n\t\taddText(str: string, opts?: AddTextOptions): void\n\t\tclearText(): void\n\t\taddSprite(x: number, y: number, type: string): void\n", "\tgetGrid(): SpriteType[][]\n\t\tgetTile(x: number, y: number): SpriteType[]\n\t\ttilesWith(...matchingTypes: string[]): SpriteType[][]\n\t\tclearTile(x: number, y: number): void\n\t\tsetSolids(types: string[]): void\n\t\tsetPushables(map: Record<string, string[]>): void\n\t\tsetBackground(type: string): void\n\t\tgetFirst(type: string): SpriteType | undefined\n\t\tgetAll(type: string): SpriteType[]\n\t\twidth(): number\n", "\theight(): number\n\t\tsetLegend(...bitmaps: [string, string][]): void\n\t\tonInput(key: InputKey, fn: () => void): void \n\t\tafterInput(fn: () => void): void\n\t\tplayTune(text: string, n?: number): PlayTuneRes\n\t\tsetTimeout(fn: TimerHandler, ms: number): number\n\t\tsetInterval(fn: TimerHandler, ms: number): number\n\t\tclearTimeout(id: number): void\n\t\tclearInterval(id: number): void\n\t}"]}
{"filename": "src/base/tune.ts", "chunked_list": ["/*\n\tsong form\n\t[\n\t\t[duration, instrument, pitch, duration, ...],\n\t]\n\tSyntax:\n\t500: 64.4~500 + c5~1000\n\t[500, 'sine', 64.4, 500, 'sine', 'c5', 1000]\n\tComma between each tune element. Whitespace ignored.\n\t*/\n", "import { type Tune, instrumentKey, InstrumentType, reverseInstrumentKey } from '../api.js'\n\texport const textToTune = (text: string): Tune => {\n\t\tconst elements = text.replace(/\\s/g, '').split(',')\n\t\tconst tune = []\n\t\tfor (const element of elements) {\n\t\t\tif (!element) continue\n\t\t\tconst [durationRaw, notesRaw] = element.split(':')\n\t\t\tconst duration = Math.round(parseInt(durationRaw ?? '0', 10))\n\t\t\tconst notes = (notesRaw || '').split('+').map((noteRaw) => {\n\t\t\t\tif (!noteRaw) return []\n", "\t\t\tconst [, pitchRaw, instrumentRaw, durationRaw] = noteRaw.match(/^(.+)([~\\-^\\/])(.+)$/)!\n\t\t\t\treturn [\n\t\t\t\t\tinstrumentKey[instrumentRaw!] ?? 'sine',\n\t\t\t\t\tisNaN(parseInt(pitchRaw ?? '', 10)) ? pitchRaw! : parseInt(pitchRaw!, 10),\n\t\t\t\t\tparseInt(durationRaw ?? '0', 10)\n\t\t\t\t]\n\t\t\t})\n\t\t\ttune.push([duration, ...notes].flat())\n\t\t}\n\t\treturn tune as Tune\n", "}\n\texport const tuneToText = (tune: Tune): string => {\n\t\tconst groupNotes = (notes: (number | string)[]) => {\n\t\t\tconst groups = []\n\t\t\tfor (let i = 0; i < notes.length; i++) {\n\t\t\t\tif (i % 3 === 0) {\n\t\t\t\t\tgroups.push([notes[i]!])\n\t\t\t\t} else {\n\t\t\t\t\tgroups[groups.length-1]!.push(notes[i]!)\n\t\t\t\t}\n", "\t\t}\n\t\t\treturn groups\n\t\t}\n\t\tconst notesToString = ([duration, ...notes]: Tune[number]) => (\n\t\t\tnotes.length === 0 \n\t\t\t\t? duration \n\t\t\t\t: `${duration}: ${groupNotes(notes).map(notesToStringHelper).join(' + ')}`\n\t\t)\n\t\tconst notesToStringHelper = ([instrument, duration, note]: (number | string)[]) => (\n\t\t\t`${duration}${reverseInstrumentKey[instrument as InstrumentType]}${note}`\n", "\t)\n\t\treturn tune.map(notesToString).join(',\\n')\n\t}"]}
{"filename": "src/base/palette.ts", "chunked_list": ["import type { Rgba } from '../api.js'\n\texport type PaletteItem = [string, Rgba]\n\texport const palette: PaletteItem[] = [\n\t\t// Grey\n\t\t['0', [0, 0, 0, 255]],\n\t\t['L', [73, 80, 87, 255]],\n\t\t['1', [145, 151, 156, 255]],\n\t\t['2', [248, 249, 250, 255]],\n\t\t// Red\n\t\t['3', [235, 44, 71, 255]],\n", "\t['C', [139, 65, 46, 255]],\n\t\t// Blue\n\t\t['7', [25, 177, 248, 255]],\n\t\t['5', [19, 21, 224, 255]],\n\t\t// Yellow\n\t\t['6', [254, 230, 16, 255]],\n\t\t['F', [149, 140, 50, 255]],\n\t\t// Green\n\t\t['4', [45, 225, 62, 255]],\n\t\t['D', [29, 148, 16, 255]],\n", "\t// Pink and purple\n\t\t['8', [245, 109, 187, 255]],\n\t\t['H', [170, 58, 197, 255]],\n\t\t// Orange\n\t\t['9', [245, 113, 23, 255]],\n\t\t// Transparent\n\t\t['.', [0, 0, 0, 0]]\n\t]\n\texport const transparent: PaletteItem = palette.at(-1)!\n\texport const hexToRgba = (hex: string): Rgba => {\n", "\tconst [ r, g, b, a ] = hex.match(/\\w\\w/g)?.map((x) => parseInt(x, 16)) ?? []\n\t\treturn [ r!, g!, b!, a ?? 255 ]\n\t}\n\texport const rgbaToHex = (rgba: Rgba): string => {\n\t\treturn '#' + rgba.map(n => n.toString(16).padStart(2, '0')).join('')\n\t}"]}
{"filename": "src/base/text.ts", "chunked_list": ["import type { Rgba, TextElement } from '../api.js'\n\texport function composeText(texts: TextElement[]): { char: string, color: Rgba }[][] {\n\t\tconst emptyCell = () => ({ char: ' ', color: [0, 0, 0, 0] as Rgba })\n\t\tconst range = <T>(length: number, fn: () => T): T[] => Array.from({ length }, fn)\n\t\tconst gridFromSize = (w: number, h: number) => range(h, () => range(w, emptyCell))\n\t\tconst CHARS_MAX_X = 20\n\t\tconst CHARS_MAX_Y = 16\n\t\tconst grid = gridFromSize(CHARS_MAX_X, CHARS_MAX_Y)\n\t\tfor (const { x: sx, y: sy, content, color } of texts) {\n\t\t\tlet y = sy\n", "\t\tfor (const line of content.split('\\n')) {\n\t\t\t\tlet x = sx\n\t\t\t\tfor (const char of line.split('')) {\n\t\t\t\t\tif (\" !\\\"#%&\\'()*+,./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\\^_-`abcdefghijklmnopqrstuvwxyz|~¦§¨©¬®¯°±´¶·¸ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ÙÚÛÜÝÞßàáâãäåæçèéêëìíîïñòóôõö÷ùúûüýþÿĀāĂăĄąĆćĊċČčĎĐđĒēĖėĘęĚěĞğĠġĦħĪīĮįİıŃńŇňŌōŒœŞşŨũŪūŮůŲųŴŵŶŷŸǍǎǏǐǑǒǓǔˆˇ˘˙˚˛˜˝ẀẁẂẃẄẅỲỳ†‡•…‰⁄™∂∅∏∑−√∞∫≈≠≤≥◊\".indexOf(char) === -1)\n\t\t\t\t\t\tthrow new Error(`Character ${char} is not in the font. It will be rendered incorrectly.`)\n\t\t\t\t\tif (x <= CHARS_MAX_X && y < CHARS_MAX_Y)\n\t\t\t\t\t\tgrid[y]![x++] = {color: color, char}\n\t\t\t\t}\n\t\t\t\ty++\n\t\t\t}\n", "\t}\n\t\treturn grid\n\t}\n"]}
{"filename": "src/base/font.ts", "chunked_list": ["export const font = [\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0xFF, // 00\n\t\t0x00, 0x00, 0x22, 0x72, 0x22, 0x3E, 0x00, 0x00, // 01\n\t\t0x00, 0x00, 0x12, 0x32, 0x7E, 0x32, 0x12, 0x00, // 02\n\t\t0x7E, 0x81, 0xB9, 0xA5, 0xB9, 0xA5, 0xB9, 0x81, // 03\n\t\t0x55, 0xFF, 0x55, 0xFF, 0x55, 0xFF, 0x55, 0xFF, // 04\n\t\t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, // 05\n\t\t0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, // 06\n\t\t0x00, 0x00, 0x3C, 0x42, 0x42, 0x7E, 0x00, 0x00, // 07\n\t\t0x00, 0x10, 0x30, 0x7E, 0x30, 0x10, 0x00, 0x00, // 08\n", "\t0x00, 0x08, 0x0C, 0x7E, 0x0C, 0x08, 0x00, 0x00, // 09\n\t\t0x00, 0x10, 0x10, 0x10, 0x7C, 0x38, 0x10, 0x00, // 0A\n\t\t0x08, 0x1C, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x00, // 0B\n\t\t0x38, 0x30, 0x28, 0x08, 0x08, 0x08, 0x3E, 0x00, // 0C\n\t\t0x00, 0x00, 0x12, 0x32, 0x7E, 0x30, 0x10, 0x00, // 0D\n\t\t0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, // 0E\n\t\t0x3E, 0x7C, 0x7C, 0x3E, 0x3E, 0x7C, 0xF8, 0xF8, // 0F\n\t\t0x38, 0x30, 0x28, 0x04, 0x04, 0x04, 0x04, 0x00, // 10\n\t\t0x7F, 0x08, 0x1C, 0x2A, 0x08, 0x08, 0x08, 0x00, // 11\n\t\t0x00, 0x08, 0x08, 0x08, 0x2A, 0x1C, 0x08, 0x7F, // 12\n", "\t0x7E, 0x81, 0x9D, 0xA1, 0xB9, 0x85, 0x85, 0xB9, // 13\n\t\t0x00, 0x3C, 0x42, 0x5A, 0x5A, 0x42, 0x3C, 0x00, // 14\n\t\t0x88, 0x44, 0x22, 0x11, 0x88, 0x44, 0x22, 0x11, // 15\n\t\t0x00, 0x7F, 0x22, 0x72, 0x27, 0x22, 0x7F, 0x00, // 16\n\t\t0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88, // 17\n\t\t0x00, 0x01, 0x09, 0x0D, 0x7F, 0x0D, 0x09, 0x01, // 18\n\t\t0x00, 0x90, 0xB0, 0xFE, 0xB0, 0x90, 0x00, 0x00, // 19\n\t\t0x00, 0x08, 0x7C, 0x06, 0x7C, 0x08, 0x00, 0x00, // 1A\n\t\t0xCC, 0xCC, 0x33, 0x33, 0xCC, 0xCC, 0x33, 0x33, // 1B\n\t\t0x7E, 0x81, 0xA1, 0xA1, 0xA1, 0xA1, 0xBD, 0x81, // 1C\n", "\t0x7E, 0x81, 0xB9, 0xA5, 0xB9, 0xA5, 0xA5, 0x81, // 1D\n\t\t0x7E, 0x81, 0x99, 0xA1, 0xA1, 0xA1, 0x99, 0x81, // 1E\n\t\t0x00, 0x10, 0x3E, 0x60, 0x3E, 0x10, 0x00, 0x00, // 1F\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 20\n\t\t0x30, 0x30, 0x30, 0x30, 0x30, 0x00, 0x30, 0x00, // 21\n\t\t0x77, 0x33, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, // 22\n\t\t0x36, 0x36, 0xFE, 0x6C, 0xFE, 0xD8, 0xD8, 0x00, // 23\n\t\t0x18, 0x3E, 0x6C, 0x3E, 0x1B, 0x1B, 0x7E, 0x18, // 24\n\t\t0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00, // 25\n\t\t0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00, // 26\n", "\t0x1C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, // 27\n\t\t0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00, // 28\n\t\t0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00, // 29\n\t\t0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, // 2A\n\t\t0x00, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x00, 0x00, // 2B\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x0C, 0x18, // 2C\n\t\t0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, // 2D\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, // 2E\n\t\t0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, // 2F\n\t\t0x7C, 0xC6, 0xCE, 0xDE, 0xF6, 0xE6, 0x7C, 0x00, // 30\n", "\t0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00, // 31\n\t\t0x78, 0xCC, 0x0C, 0x38, 0x60, 0xCC, 0xFC, 0x00, // 32\n\t\t0xFC, 0x18, 0x30, 0x78, 0x0C, 0xCC, 0x78, 0x00, // 33\n\t\t0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00, // 34\n\t\t0xFC, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00, // 35\n\t\t0x38, 0x60, 0xC0, 0xF8, 0xCC, 0xCC, 0x78, 0x00, // 36\n\t\t0xFC, 0xCC, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00, // 37\n\t\t0x78, 0xCC, 0xCC, 0x78, 0xCC, 0xCC, 0x78, 0x00, // 38\n\t\t0x78, 0xCC, 0xCC, 0x7C, 0x0C, 0x18, 0x70, 0x00, // 39\n\t\t0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, // 3A\n", "\t0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60, // 3B\n\t\t0x18, 0x30, 0x60, 0xC0, 0x60, 0x30, 0x18, 0x00, // 3C\n\t\t0x00, 0x00, 0xFC, 0x00, 0xFC, 0x00, 0x00, 0x00, // 3D\n\t\t0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00, // 3E\n\t\t0x78, 0xCC, 0x0C, 0x18, 0x30, 0x00, 0x30, 0x00, // 3F\n\t\t0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x78, 0x00, // 40\n\t\t0x30, 0x78, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0x00, // 41\n\t\t0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00, // 42\n\t\t0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00, // 43\n\t\t0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, // 44\n", "\t0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00, // 45\n\t\t0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00, // 46\n\t\t0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3C, 0x00, // 47\n\t\t0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00, // 48\n\t\t0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, // 49\n\t\t0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00, // 4A\n\t\t0xE6, 0x66, 0x6C, 0x70, 0x6C, 0x66, 0xE6, 0x00, // 4B\n\t\t0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, // 4C\n\t\t0xC6, 0xEE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0x00, // 4D\n\t\t0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00, // 4E\n", "\t0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, // 4F\n\t\t0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00, // 50\n\t\t0x78, 0xCC, 0xCC, 0xCC, 0xDC, 0x78, 0x1C, 0x00, // 51\n\t\t0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00, // 52\n\t\t0x7C, 0xC6, 0xF0, 0x3C, 0x0E, 0xC6, 0x7C, 0x00, // 53\n\t\t0xFC, 0xB4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, // 54\n\t\t0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x00, // 55\n\t\t0xCC, 0xCC, 0xCC, 0x78, 0x78, 0x30, 0x30, 0x00, // 56\n\t\t0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00, // 57\n\t\t0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00, // 58\n", "\t0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x30, 0x78, 0x00, // 59\n\t\t0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00, // 5A\n\t\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // 5B\n\t\t0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, // 5C\n\t\t0x00, 0xFE, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, // 5D\n\t\t0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, // 5E\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, // 5F\n\t\t0x3C, 0x42, 0x99, 0xA1, 0xA1, 0x99, 0x42, 0x3C, // 60\n\t\t0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00, // 61\n\t\t0xE0, 0x60, 0x7C, 0x66, 0x66, 0x66, 0xDC, 0x00, // 62\n", "\t0x00, 0x00, 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x00, // 63\n\t\t0x1C, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, // 64\n\t\t0x00, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00, // 65\n\t\t0x38, 0x6C, 0x60, 0xF0, 0x60, 0x60, 0xF0, 0x00, // 66\n\t\t0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, // 67\n\t\t0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00, // 68\n\t\t0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0xFC, 0x00, // 69\n\t\t0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, // 6A\n\t\t0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00, // 6B\n\t\t0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00, // 6C\n", "\t0x00, 0x00, 0xCC, 0xFE, 0xFE, 0xD6, 0xC6, 0x00, // 6D\n\t\t0x00, 0x00, 0xF8, 0xCC, 0xCC, 0xCC, 0xCC, 0x00, // 6E\n\t\t0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00, // 6F\n\t\t0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0, // 70\n\t\t0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E, // 71\n\t\t0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0xF0, 0x00, // 72\n\t\t0x00, 0x00, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x00, // 73\n\t\t0x10, 0x30, 0x7C, 0x30, 0x30, 0x34, 0x18, 0x00, // 74\n\t\t0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, // 75\n\t\t0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00, // 76\n", "\t0x00, 0x00, 0xC6, 0xD6, 0xFE, 0xFE, 0x6C, 0x00, // 77\n\t\t0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00, // 78\n\t\t0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, // 79\n\t\t0x00, 0x00, 0xFC, 0x98, 0x30, 0x64, 0xFC, 0x00, // 7A\n\t\t0x6C, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00, // 7B\n\t\t0xCC, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00, // 7C\n\t\t0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, // 7D\n\t\t0x3C, 0x66, 0x66, 0x6C, 0x66, 0x66, 0x6C, 0xF0, // 7E\n\t\t0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF, // 7F\n\t\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E, 0x00, // 80\n", "\t0xFF, 0xFF, 0xDD, 0x8D, 0xDD, 0xC1, 0xFF, 0xFF, // 81\n\t\t0xFF, 0xFF, 0xED, 0xCD, 0x81, 0xCD, 0xED, 0xFF, // 82\n\t\t0x81, 0x7E, 0x46, 0x5A, 0x46, 0x5A, 0x46, 0x7E, // 83\n\t\t0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, // 84\n\t\t0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, // 85\n\t\t0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, // 86\n\t\t0xFF, 0xFF, 0xC3, 0xBD, 0xBD, 0x81, 0xFF, 0xFF, // 87\n\t\t0xFF, 0xEF, 0xCF, 0x81, 0xCF, 0xEF, 0xFF, 0xFF, // 88\n\t\t0xFF, 0xF7, 0xF3, 0x81, 0xF3, 0xF7, 0xFF, 0xFF, // 89\n\t\t0xFF, 0xEF, 0xEF, 0xEF, 0x83, 0xC7, 0xEF, 0xFF, // 8A\n", "\t0xF7, 0xE3, 0xC1, 0xF7, 0xF7, 0xF7, 0xF7, 0xFF, // 8B\n\t\t0xC7, 0xCF, 0xD7, 0xF7, 0xF7, 0xF7, 0xC1, 0xFF, // 8C\n\t\t0xFF, 0xFF, 0xED, 0xCD, 0x81, 0xCF, 0xEF, 0xFF, // 8D\n\t\t0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, // 8E\n\t\t0xC1, 0x83, 0x83, 0xC1, 0xC1, 0x83, 0x07, 0x07, // 8F\n\t\t0xC7, 0xCF, 0xD7, 0xFB, 0xFB, 0xFB, 0xFB, 0xFF, // 90\n\t\t0x80, 0xF7, 0xE3, 0xD5, 0xF7, 0xF7, 0xF7, 0xFF, // 91\n\t\t0xFF, 0xF7, 0xF7, 0xF7, 0xD5, 0xE3, 0xF7, 0x80, // 92\n\t\t0x81, 0x7E, 0x62, 0x5E, 0x46, 0x7A, 0x7A, 0x46, // 93\n\t\t0xFF, 0xC3, 0xBD, 0xA5, 0xA5, 0xBD, 0xC3, 0xFF, // 94\n", "\t0x77, 0xBB, 0xDD, 0xEE, 0x77, 0xBB, 0xDD, 0xEE, // 95\n\t\t0xFF, 0x80, 0xDD, 0x8D, 0xD8, 0xDD, 0x80, 0xFF, // 96\n\t\t0xEE, 0xDD, 0xBB, 0x77, 0xEE, 0xDD, 0xBB, 0x77, // 97\n\t\t0xFF, 0xFE, 0xF6, 0xF2, 0x80, 0xF2, 0xF6, 0xFE, // 98\n\t\t0xFF, 0x6F, 0x4F, 0x01, 0x4F, 0x6F, 0xFF, 0xFF, // 99\n\t\t0xFF, 0xF7, 0x83, 0xF9, 0x83, 0xF7, 0xFF, 0xFF, // 9A\n\t\t0x33, 0x33, 0xCC, 0xCC, 0x33, 0x33, 0xCC, 0xCC, // 9B\n\t\t0x81, 0x7E, 0x5E, 0x5E, 0x5E, 0x5E, 0x42, 0x7E, // 9C\n\t\t0x81, 0x7E, 0x46, 0x5A, 0x46, 0x5A, 0x5A, 0x7E, // 9D\n\t\t0x81, 0x7E, 0x66, 0x5E, 0x5E, 0x5E, 0x66, 0x7E, // 9E\n", "\t0xFF, 0xEF, 0xC1, 0x9F, 0xC1, 0xEF, 0xFF, 0xFF, // 9F\n\t\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // A0\n\t\t0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xFF, 0xCF, 0xFF, // A1\n\t\t0x88, 0xCC, 0x99, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // A2\n\t\t0xC9, 0xC9, 0x01, 0x93, 0x01, 0x27, 0x27, 0xFF, // A3\n\t\t0xE7, 0xC1, 0x93, 0xC1, 0xE4, 0xE4, 0x81, 0xE7, // A4\n\t\t0xFF, 0x39, 0x33, 0xE7, 0xCF, 0x99, 0x39, 0xFF, // A5\n\t\t0xC7, 0x93, 0xC7, 0x89, 0x23, 0x33, 0x89, 0xFF, // A6\n\t\t0xE3, 0xF3, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // A7\n\t\t0xE7, 0xCF, 0x9F, 0x9F, 0x9F, 0xCF, 0xE7, 0xFF, // A8\n", "\t0x9F, 0xCF, 0xE7, 0xE7, 0xE7, 0xCF, 0x9F, 0xFF, // A9\n\t\t0xFF, 0x99, 0xC3, 0x00, 0xC3, 0x99, 0xFF, 0xFF, // AA\n\t\t0xFF, 0xCF, 0xCF, 0x03, 0xCF, 0xCF, 0xFF, 0xFF, // AB\n\t\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE3, 0xF3, 0xE7, // AC\n\t\t0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, // AD\n\t\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xCF, 0xFF, // AE\n\t\t0xF9, 0xF3, 0xE7, 0xCF, 0x9F, 0x3F, 0x7F, 0xFF, // AF\n\t\t0x83, 0x39, 0x31, 0x21, 0x09, 0x19, 0x83, 0xFF, // B0\n\t\t0xCF, 0x8F, 0xCF, 0xCF, 0xCF, 0xCF, 0x03, 0xFF, // B1\n\t\t0x87, 0x33, 0xF3, 0xC7, 0x9F, 0x33, 0x03, 0xFF, // B2\n", "\t0x03, 0xE7, 0xCF, 0x87, 0xF3, 0x33, 0x87, 0xFF, // B3\n\t\t0xE3, 0xC3, 0x93, 0x33, 0x01, 0xF3, 0xE1, 0xFF, // B4\n\t\t0x03, 0x3F, 0x07, 0xF3, 0xF3, 0x33, 0x87, 0xFF, // B5\n\t\t0xC7, 0x9F, 0x3F, 0x07, 0x33, 0x33, 0x87, 0xFF, // B6\n\t\t0x03, 0x33, 0xF3, 0xE7, 0xCF, 0xCF, 0xCF, 0xFF, // B7\n\t\t0x87, 0x33, 0x33, 0x87, 0x33, 0x33, 0x87, 0xFF, // B8\n\t\t0x87, 0x33, 0x33, 0x83, 0xF3, 0xE7, 0x8F, 0xFF, // B9\n\t\t0xFF, 0xFF, 0xCF, 0xCF, 0xFF, 0xCF, 0xCF, 0xFF, // BA\n\t\t0xFF, 0xFF, 0xCF, 0xCF, 0xFF, 0xCF, 0xCF, 0x9F, // BB\n\t\t0xE7, 0xCF, 0x9F, 0x3F, 0x9F, 0xCF, 0xE7, 0xFF, // BC\n", "\t0xFF, 0xFF, 0x03, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, // BD\n\t\t0x9F, 0xCF, 0xE7, 0xF3, 0xE7, 0xCF, 0x9F, 0xFF, // BE\n\t\t0x87, 0x33, 0xF3, 0xE7, 0xCF, 0xFF, 0xCF, 0xFF, // BF\n\t\t0x83, 0x39, 0x21, 0x21, 0x21, 0x3F, 0x87, 0xFF, // C0\n\t\t0xCF, 0x87, 0x33, 0x33, 0x03, 0x33, 0x33, 0xFF, // C1\n\t\t0x03, 0x99, 0x99, 0x83, 0x99, 0x99, 0x03, 0xFF, // C2\n\t\t0xC3, 0x99, 0x3F, 0x3F, 0x3F, 0x99, 0xC3, 0xFF, // C3\n\t\t0x07, 0x93, 0x99, 0x99, 0x99, 0x93, 0x07, 0xFF, // C4\n\t\t0x01, 0x9D, 0x97, 0x87, 0x97, 0x9D, 0x01, 0xFF, // C5\n\t\t0x01, 0x9D, 0x97, 0x87, 0x97, 0x9F, 0x0F, 0xFF, // C6\n", "\t0xC3, 0x99, 0x3F, 0x3F, 0x31, 0x99, 0xC3, 0xFF, // C7\n\t\t0x33, 0x33, 0x33, 0x03, 0x33, 0x33, 0x33, 0xFF, // C8\n\t\t0x87, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0x87, 0xFF, // C9\n\t\t0xE1, 0xF3, 0xF3, 0xF3, 0x33, 0x33, 0x87, 0xFF, // CA\n\t\t0x19, 0x99, 0x93, 0x8F, 0x93, 0x99, 0x19, 0xFF, // CB\n\t\t0x0F, 0x9F, 0x9F, 0x9F, 0x9D, 0x99, 0x01, 0xFF, // CC\n\t\t0x39, 0x11, 0x01, 0x29, 0x39, 0x39, 0x39, 0xFF, // CD\n\t\t0x39, 0x19, 0x09, 0x21, 0x31, 0x39, 0x39, 0xFF, // CE\n\t\t0xC7, 0x93, 0x39, 0x39, 0x39, 0x93, 0xC7, 0xFF, // CF\n\t\t0x03, 0x99, 0x99, 0x83, 0x9F, 0x9F, 0x0F, 0xFF, // D0\n", "\t0x87, 0x33, 0x33, 0x33, 0x23, 0x87, 0xE3, 0xFF, // D1\n\t\t0x03, 0x99, 0x99, 0x83, 0x93, 0x99, 0x19, 0xFF, // D2\n\t\t0x83, 0x39, 0x0F, 0xC3, 0xF1, 0x39, 0x83, 0xFF, // D3\n\t\t0x03, 0x4B, 0xCF, 0xCF, 0xCF, 0xCF, 0x87, 0xFF, // D4\n\t\t0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x87, 0xFF, // D5\n\t\t0x33, 0x33, 0x33, 0x87, 0x87, 0xCF, 0xCF, 0xFF, // D6\n\t\t0x39, 0x39, 0x39, 0x29, 0x01, 0x11, 0x39, 0xFF, // D7\n\t\t0x39, 0x39, 0x93, 0xC7, 0x93, 0x39, 0x39, 0xFF, // D8\n\t\t0x33, 0x33, 0x33, 0x87, 0xCF, 0xCF, 0x87, 0xFF, // D9\n\t\t0x01, 0x39, 0x73, 0xE7, 0xCD, 0x99, 0x01, 0xFF, // DA\n", "\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // DB\n\t\t0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xE7, 0xFF, // DC\n\t\t0xFF, 0x01, 0xF9, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, // DD\n\t\t0xEF, 0xC7, 0x93, 0x39, 0xFF, 0xFF, 0xFF, 0xFF, // DE\n\t\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, // DF\n\t\t0xC3, 0xBD, 0x66, 0x5E, 0x5E, 0x66, 0xBD, 0xC3, // E0\n\t\t0xFF, 0xFF, 0x87, 0xF3, 0x83, 0x33, 0x89, 0xFF, // E1\n\t\t0x1F, 0x9F, 0x83, 0x99, 0x99, 0x99, 0x23, 0xFF, // E2\n\t\t0xFF, 0xFF, 0x87, 0x33, 0x3F, 0x33, 0x87, 0xFF, // E3\n\t\t0xE3, 0xF3, 0x83, 0x33, 0x33, 0x33, 0x89, 0xFF, // E4\n", "\t0xFF, 0xFF, 0x87, 0x33, 0x03, 0x3F, 0x87, 0xFF, // E5\n\t\t0xC7, 0x93, 0x9F, 0x0F, 0x9F, 0x9F, 0x0F, 0xFF, // E6\n\t\t0xFF, 0xFF, 0x89, 0x33, 0x33, 0x83, 0xF3, 0x07, // E7\n\t\t0x1F, 0x9F, 0x93, 0x89, 0x99, 0x99, 0x19, 0xFF, // E8\n\t\t0xCF, 0xFF, 0x8F, 0xCF, 0xCF, 0xCF, 0x03, 0xFF, // E9\n\t\t0xF3, 0xFF, 0xE3, 0xF3, 0xF3, 0x33, 0x33, 0x87, // EA\n\t\t0x1F, 0x9F, 0x99, 0x93, 0x87, 0x93, 0x19, 0xFF, // EB\n\t\t0x8F, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0x03, 0xFF, // EC\n\t\t0xFF, 0xFF, 0x33, 0x01, 0x01, 0x29, 0x39, 0xFF, // ED\n\t\t0xFF, 0xFF, 0x07, 0x33, 0x33, 0x33, 0x33, 0xFF, // EE\n", "\t0xFF, 0xFF, 0x87, 0x33, 0x33, 0x33, 0x87, 0xFF, // EF\n\t\t0xFF, 0xFF, 0x23, 0x99, 0x99, 0x83, 0x9F, 0x0F, // F0\n\t\t0xFF, 0xFF, 0x89, 0x33, 0x33, 0x83, 0xF3, 0xE1, // F1\n\t\t0xFF, 0xFF, 0x23, 0x89, 0x99, 0x9F, 0x0F, 0xFF, // F2\n\t\t0xFF, 0xFF, 0x83, 0x3F, 0x87, 0xF3, 0x07, 0xFF, // F3\n\t\t0xEF, 0xCF, 0x83, 0xCF, 0xCF, 0xCB, 0xE7, 0xFF, // F4\n\t\t0xFF, 0xFF, 0x33, 0x33, 0x33, 0x33, 0x89, 0xFF, // F5\n\t\t0xFF, 0xFF, 0x33, 0x33, 0x33, 0x87, 0xCF, 0xFF, // F6\n\t\t0xFF, 0xFF, 0x39, 0x29, 0x01, 0x01, 0x93, 0xFF, // F7\n\t\t0xFF, 0xFF, 0x39, 0x93, 0xC7, 0x93, 0x39, 0xFF, // F8\n", "\t0xFF, 0xFF, 0x33, 0x33, 0x33, 0x83, 0xF3, 0x07, // F9\n\t\t0xFF, 0xFF, 0x03, 0x67, 0xCF, 0x9B, 0x03, 0xFF, // FA\n\t\t0x93, 0xFF, 0x87, 0xF3, 0x83, 0x33, 0x89, 0xFF, // FB\n\t\t0x33, 0xFF, 0x87, 0x33, 0x33, 0x33, 0x87, 0xFF, // FC\n\t\t0x33, 0xFF, 0x33, 0x33, 0x33, 0x33, 0x89, 0xFF, // FD\n\t\t0xC3, 0x99, 0x99, 0x93, 0x99, 0x99, 0x93, 0x0F, // FE\n\t\t0x00, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x00, // FF\n\t]"]}
{"filename": "src/base/index.ts", "chunked_list": ["import type { AddTextOptions, FullSprigAPI, GameState, SpriteType } from '../api.js'\n\timport { palette } from './palette.js'\n\texport * from './font.js'\n\texport * from './palette.js'\n\texport * from './text.js'\n\texport * from './tune.js'\n\t// Tagged template literal factory go brrr\n\tconst _makeTag = <T>(cb: (string: string) => T) => {\n\t\treturn (strings: TemplateStringsArray, ...interps: string[]) => {\n\t\t\tif (typeof strings === 'string') {\n", "\t\t\tthrow new Error('Tagged template literal must be used like name`text`, instead of name(`text`)')\n\t\t\t}\n\t\t\tconst string = strings.reduce((p, c, i) => p + c + (interps[i] ?? ''), '')\n\t\t\treturn cb(string)\n\t\t}\n\t}\n\texport type BaseEngineAPI = Pick<\n\t\tFullSprigAPI,\n\t\t| 'setMap'\n\t\t| 'addText'\n", "\t| 'clearText'\n\t\t| 'addSprite'\n\t\t| 'getGrid'\n\t\t| 'getTile'\n\t\t| 'tilesWith'\n\t\t| 'clearTile'\n\t\t| 'setSolids'\n\t\t| 'setPushables'\n\t\t| 'setBackground'\n\t\t| 'map'\n", "\t| 'bitmap'\n\t\t| 'color'\n\t\t| 'tune'\n\t\t| 'getFirst'\n\t\t| 'getAll'\n\t\t| 'width'\n\t\t| 'height'\n\t>\n\texport function baseEngine(): { api: BaseEngineAPI, state: GameState } {\n\t\tconst gameState: GameState = {\n", "\t\tlegend: [],\n\t\t\ttexts: [],\n\t\t\tdimensions: {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0,\n\t\t\t},\n\t\t\tsprites: [],\n\t\t\tsolids: [],\n\t\t\tpushable: {},\n\t\t\tbackground: null\n", "\t}\n\t\tclass Sprite implements SpriteType {\n\t\t\t_type: string\n\t\t\t_x: number\n\t\t\t_y: number\n\t\t\tdx: number\n\t\t\tdy: number\n\t\t\tconstructor(type: string, x: number, y: number) {\n\t\t\t\tthis._type = type\n\t\t\t\tthis._x = x\n", "\t\t\tthis._y = y\n\t\t\t\tthis.dx = 0\n\t\t\t\tthis.dy = 0\n\t\t\t}\n\t\t\tset type(newType) {\n\t\t\t\tconst legendDict = Object.fromEntries(gameState.legend)\n\t\t\t\tif (!(newType in legendDict)) throw new Error(`\"${newType}\" isn\\'t in the legend.`)\n\t\t\t\tthis.remove()\n\t\t\t\taddSprite(this._x, this._y, newType)\n\t\t\t}\n", "\t\tget type() {\n\t\t\t\treturn this._type\n\t\t\t}\n\t\t\tset x(newX) {\n\t\t\t\tconst dx = newX - this.x\n\t\t\t\tif (_canMoveToPush(this, dx, 0)) this.dx = dx\n\t\t\t}\n\t\t\tget x() {\n\t\t\t\treturn this._x\n\t\t\t}\n", "\t\tset y(newY) {\n\t\t\t\tconst dy = newY - this.y\n\t\t\t\tif (_canMoveToPush(this, 0, dy)) this.dy = dy\n\t\t\t}\n\t\t\tget y() {\n\t\t\t\treturn this._y\n\t\t\t}\n\t\t\tremove() {\n\t\t\t\tgameState.sprites = gameState.sprites.filter(s => s !== this)\n\t\t\t\treturn this\n", "\t\t}\n\t\t}\n\t\tconst _canMoveToPush = (sprite: Sprite, dx: number, dy: number): boolean => {\n\t\t\tconst { x, y, type } = sprite\n\t\t\tconst { width, height } = gameState.dimensions\n\t\t\tconst i = (x+dx)+(y+dy)*width\n\t\t\tconst inBounds = (x+dx < width && x+dx >= 0 && y+dy < height && y+dy >= 0)\n\t\t\tif (!inBounds) return false\n\t\t\tconst grid = getGrid()\n\t\t\tconst notSolid = !gameState.solids.includes(type)\n", "\t\tconst noMovement = dx === 0 && dy === 0\n\t\t\tconst movingToEmpty = i < grid.length && grid[i]!.length === 0\n\t\t\tif (notSolid || noMovement || movingToEmpty) {\n\t\t\t\tsprite._x += dx\n\t\t\t\tsprite._y += dy\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tlet canMove = true\n\t\t\tconst { pushable }  = gameState\n\t\t\tgrid[i]!.forEach(sprite => {\n", "\t\t\tconst isSolid = gameState.solids.includes(sprite.type)\n\t\t\t\tconst isPushable = (type in pushable) && pushable[type]!.includes(sprite.type)\n\t\t\t\tif (isSolid && !isPushable)\n\t\t\t\t\tcanMove = false\n\t\t\t\tif (isSolid && isPushable) {\n\t\t\t\t\tcanMove = canMove && _canMoveToPush(sprite as Sprite, dx, dy)\n\t\t\t\t}\n\t\t\t})\n\t\t\tif (canMove) {\n\t\t\t\tsprite._x += dx\n", "\t\t\tsprite._y += dy\n\t\t\t}\n\t\t\treturn canMove\n\t\t}\n\t\tconst getGrid = (): SpriteType[][] => {\n\t\t\tconst { width, height } = gameState.dimensions\n\t\t\tconst grid: SpriteType[][] = new Array(width*height).fill(0).map(_ => [])\n\t\t\tgameState.sprites.forEach(s => {\n\t\t\t\tconst i = s.x+s.y*width\n\t\t\t\tgrid[i]!.push(s)\n", "\t\t})\n\t\t\tconst legendIndex = (t: SpriteType) => gameState.legend.findIndex(l => l[0] == t.type)\n\t\t\tfor (const tile of grid) tile.sort((a, b) => legendIndex(a) - legendIndex(b))\n\t\t\treturn grid\n\t\t}\n\t\tconst _checkBounds = (x: number, y: number): void => {\n\t\t\tconst { width, height } = gameState.dimensions\n\t\t\tif (x >= width || x < 0 || y < 0 || y >= height) throw new Error(`Sprite out of bounds.`)\n\t\t}\n\t\tconst _checkLegend = (type: string): void => {\n", "\t\tif (!(type in Object.fromEntries(gameState.legend)))\n\t\t\t\tthrow new Error(`Unknown sprite type: ${type}`)\n\t\t}\n\t\tconst addSprite = (x: number, y: number, type: string): void => {\n\t\t\tif (type === '.') return\n\t\t\t_checkBounds(x, y)\n\t\t\t_checkLegend(type)\n\t\t\tconst s = new Sprite(type, x, y)\n\t\t\tgameState.sprites.push(s)\n\t\t}\n", "\tconst _allEqual = <T>(arr: T[]): boolean => arr.every(val => val === arr[0])\n\t\tconst setMap = (string: string): void => {\n\t\t\tif (!string) throw new Error('Tried to set empty map.')\n\t\t\tif (string.constructor == Object) throw new Error('setMap() takes a string, not a dict.') // https://stackoverflow.com/a/51285298\n\t\t\tif (Array.isArray(string)) throw new Error('It looks like you passed an array into setMap(). Did you mean to use something like setMap(levels[level]) instead of setMap(levels)?')\n\t\t\tconst rows = string.trim().split(\"\\n\").map(x => x.trim())\n\t\t\tconst rowLengths = rows.map(x => x.length)\n\t\t\tconst isRect = _allEqual(rowLengths)\n\t\t\tif (!isRect) throw new Error('Level must be rectangular.')\n\t\t\tconst w = rows[0]?.length ?? 0\n", "\t\tconst h = rows.length\n\t\t\tgameState.dimensions.width = w\n\t\t\tgameState.dimensions.height = h\n\t\t\tgameState.sprites = []\n\t\t\tconst nonSpace = string.split(\"\").filter(x => x !== \" \" && x !== \"\\n\") // \\S regex was too slow\n\t\t\tfor (let i = 0; i < w*h; i++) {\n\t\t\t\tconst type = nonSpace[i]!\n\t\t\t\tif (type === '.') continue\n\t\t\t\tconst x = i%w \n\t\t\t\tconst y = Math.floor(i/w)\n", "\t\t\taddSprite(x, y, type)\n\t\t\t}\n\t\t}\n\t\tconst clearTile = (x: number, y: number): void => {\n\t\t\tgameState.sprites = gameState.sprites.filter(s => s.x !== x || s.y !== y)\n\t\t}\n\t\tconst addText = (str: string, opts: AddTextOptions = {}): void => {\n\t\t\tconst CHARS_MAX_X = 21\n\t\t\tconst padLeft = Math.floor((CHARS_MAX_X - str.length)/2)\n\t\t\tif (Array.isArray(opts.color)) throw new Error('addText no longer takes an RGBA color. Please use a Sprig color instead with \\\"{ color: color`` }\\\"')\n", "\t\tconst [, rgba ] = palette.find(([key]) => key === opts.color) ?? palette.find(([key]) => key === 'L')!\n\t\t\tgameState.texts.push({\n\t\t\t\tx: opts.x ?? padLeft,\n\t\t\t\ty: opts.y ?? 0,\n\t\t\t\tcolor: rgba,\n\t\t\t\tcontent: str\n\t\t\t})\n\t\t}\n\t\tconst clearText = (): void => { gameState.texts = [] }\n\t\tconst getTile = (x: number, y: number): SpriteType[] => {\n", "\t\tif (y < 0) return []\n\t\t\tif (x < 0) return []\n\t\t\tif (y >= gameState.dimensions.height) return []\n\t\t\tif (x >= gameState.dimensions.width) return []\n\t\t\treturn getGrid()[gameState.dimensions.width*y+x] ?? []\n\t\t}\n\t\tconst _hasDuplicates = <T>(array: T[]): boolean => (new Set(array)).size !== array.length\n\t\tconst tilesWith = (...matchingTypes: string[]): SpriteType[][] => {\n\t\t\tconst { width, height } = gameState.dimensions\n\t\t\tconst tiles: SpriteType[][] = []\n", "\t\tconst grid = getGrid()\n\t\t\tfor (let x = 0; x < width; x++) {\n\t\t\t\tfor (let y = 0; y < height; y++) {\n\t\t\t\t\tconst tile = grid[width*y+x] || []\n\t\t\t\t\tconst matchIndices = matchingTypes.map(type => {\n\t\t\t\t\t\treturn tile.map(s => s.type).indexOf(type)\n\t\t\t\t\t})\n\t\t\t\t\tif (!_hasDuplicates(matchIndices) && !matchIndices.includes(-1)) tiles.push(tile)\n\t\t\t\t}\n\t\t\t}\n", "\t\treturn tiles\n\t\t}\n\t\tconst setSolids = (arr: string[]): void => { \n\t\t\tif (!Array.isArray(arr)) throw new Error('The sprites passed into setSolids() need to be an array.')\n\t\t\tgameState.solids = arr \n\t\t}\n\t\tconst setPushables = (map: Record<string, string[]>): void => { \n\t\t\tfor (const key in map) {\n\t\t\t\tif(key.length != 1) {\n\t\t\t\t\tthrow new Error('Your sprite name must be wrapped in [] brackets here.');\n", "\t\t\t}\n\t\t\t\t_checkLegend(key)\n\t\t\t}\n\t\t\tgameState.pushable = map \n\t\t}\n\t\tconst api: BaseEngineAPI = {\n\t\t\tsetMap, \n\t\t\taddText,\n\t\t\tclearText,\n\t\t\taddSprite,\n", "\t\tgetGrid,\n\t\t\tgetTile,\n\t\t\ttilesWith,\n\t\t\tclearTile, \n\t\t\tsetSolids, \n\t\t\tsetPushables, \n\t\t\tsetBackground: (type: string) => { gameState.background = type },\n\t\t\tmap: _makeTag(text => text),\n\t\t\tbitmap: _makeTag(text => text),\n\t\t\tcolor: _makeTag(text => text),\n", "\t\ttune: _makeTag(text => text),\n\t\t\tgetFirst: (type: string): SpriteType | undefined => gameState.sprites.find(t => t.type === type), // **\n\t\t\tgetAll: (type: string): SpriteType[] => type ? gameState.sprites.filter(t => t.type === type) : gameState.sprites, // **\n\t\t\twidth: () => gameState.dimensions.width,\n\t\t\theight: () => gameState.dimensions.height\n\t\t}\n\t\treturn { api, state: gameState }\n\t}\n"]}
{"filename": "src/image-data/bitmap.ts", "chunked_list": ["import { palette } from '../base/index.js'\n\t// At odds with in-game behavior... doesn't enforce a size with stretching.\n\texport const bitmapTextToImageData = (text: string): ImageData => {\n\t  const rows = text.trim().split(\"\\n\").map(x => x.trim())\n\t  const rowLengths = rows.map(x => x.length)\n\t  const isRect = rowLengths.every(val => val === rowLengths[0])\n\t  if (!isRect) throw new Error(\"Level must be rect.\")\n\t  const width = rows[0]!.length || 1\n\t  const height = rows.length || 1\n\t  const data = new Uint8ClampedArray(width*height*4)\n", "  const colors = Object.fromEntries(palette)\n\t  const nonSpace = text.split('').filter(x => x !== ' ' && x !== '\\n') // \\S regex led to massive perf problems\n\t  for (let i = 0; i < width*height; i++) {\n\t    const type = nonSpace[i] || \".\"\n\t    if (!(type in colors)) {\n\t      const err = `in sprite string: no known color for char \"${type}\"`\n\t      console.error(err + '\\n' + text)\n\t      throw new Error(err + ' (invalid sprite in console)')\n\t    }\n\t    const [ r, g, b, a ] = colors[type] ?? colors['.']!\n", "    data[i*4] = r\n\t    data[i*4 + 1] = g\n\t    data[i*4 + 2] = b\n\t    data[i*4 + 3] = a\n\t  }\n\t  return new ImageData(data, width, height)\n\t}"]}
{"filename": "src/image-data/index.ts", "chunked_list": ["import type { FullSprigAPI, GameState, InputKey } from '../api.js'\n\timport { type BaseEngineAPI, baseEngine } from '../base/index.js'\n\timport { bitmapTextToImageData } from './bitmap.js'\n\texport * from './bitmap.js'\n\texport type ImageDataEngineAPI = BaseEngineAPI & Pick<\n\t\tFullSprigAPI,\n\t\t| 'onInput'\n\t\t| 'afterInput'\n\t\t| 'setLegend'\n\t\t| 'setBackground'\n", "\t| 'setTimeout'\n\t\t| 'setInterval'\n\t\t| 'playTune'\n\t>\n\texport const imageDataEngine = (): {\n\t\tapi: ImageDataEngineAPI,\n\t\trender(): ImageData,\n\t\tbutton(key: InputKey): void,\n\t\tcleanup(): void,\n\t\tstate: GameState\n", "} => {\n\t\tconst game = baseEngine()\n\t\tlet legendImages: Record<string, ImageData> = {}\n\t\tlet background: string = '.'\n\t\tconst timeouts: number[] = []\n\t\tconst intervals: number[] = []\n\t\tconst keyHandlers: Record<InputKey, (() => void)[]> = {\n\t\t\tw: [],\n\t\t\ts: [],\n\t\t\ta: [],\n", "\t\td: [],\n\t\t\ti: [],\n\t\t\tj: [],\n\t\t\tk: [],\n\t\t\tl: []\n\t\t}\n\t\tconst afterInputs: (() => void)[] = []\n\t\tconst cleanup = () => {\n\t\t\ttimeouts.forEach(clearTimeout)\n\t\t\tintervals.forEach(clearInterval)\n", "\t}\n\t\tconst api = {\n\t\t\t...game.api,\n\t\t\tonInput: (key: InputKey, fn: () => void) => keyHandlers[key].push(fn),\n\t\t\tafterInput: (fn: () => void) => afterInputs.push(fn),\n\t\t\tsetLegend: (...bitmaps: [string, string][]) => {\n\t\t\t\tgame.state.legend = bitmaps\n\t\t\t\tlegendImages = {}\n\t\t\t\tfor (const [ id, desc ] of bitmaps)\n\t\t\t\t\tlegendImages[id] = bitmapTextToImageData(desc)\n", "\t\t},\n\t\t\tsetBackground: (kind: string) => background = kind,\n\t\t\tsetTimeout: (fn: TimerHandler, ms: number) => {\n\t\t\t\tconst timer = setTimeout(fn, ms)\n\t\t\t\ttimeouts.push(timer)\n\t\t\t\treturn timer\n\t\t\t},\n\t\t\tsetInterval: (fn: TimerHandler, ms: number) => {\n\t\t\t\tconst timer = setInterval(fn, ms)\n\t\t\t\tintervals.push(timer)\n", "\t\t\treturn timer\n\t\t\t},\n\t\t\tplayTune: () => ({ end() {}, isPlaying() { return false } })\n\t\t}\n\t\treturn {\n\t\t\tapi,\n\t\t\tbutton(key: InputKey): void {\n\t\t\t\tfor (const fn of keyHandlers[key]) fn()\n\t\t\t\tfor (const fn of afterInputs) fn()\n\t\t\t\tgame.state.sprites.forEach((s: any) => {\n", "\t\t\t\ts.dx = 0\n\t\t\t\t\ts.dy = 0\n\t\t\t\t})\n\t\t\t},\n\t\t\trender(): ImageData {\n\t\t\t\tconst width = () => game.state.dimensions.width\n\t\t\t\tconst height = () => game.state.dimensions.height\n\t\t\t\tconst tSize = () => 16\n\t\t\t\tconst sw = width() * tSize()\n\t\t\t\tconst sh = height() * tSize()\n", "\t\t\tconst out = new ImageData(sw, sh)\n\t\t\t\tout.data.fill(255)\n\t\t\t\tfor (const t of game.api.getGrid().flat()) {\n\t\t\t\t\tconst img = legendImages[t.type ?? background]\n\t\t\t\t\tif (!img) continue\n\t\t\t\t\tfor (let x = 0; x < tSize(); x++)\n\t\t\t\t\t\tfor (let y = 0; y < tSize(); y++) {\n\t\t\t\t\t\t\tconst tx = t.x * tSize() + x\n\t\t\t\t\t\t\tconst ty = t.y * tSize() + y\n\t\t\t\t\t\t\tconst src_alpha = img.data[(y * 16 + x) * 4 + 3]\n", "\t\t\t\t\t\tif (!src_alpha) continue\n\t\t\t\t\t\t\tout.data[(ty * sw + tx) * 4 + 0] = img.data[(y * 16 + x) * 4 + 0]!\n\t\t\t\t\t\t\tout.data[(ty * sw + tx) * 4 + 1] = img.data[(y * 16 + x) * 4 + 1]!\n\t\t\t\t\t\t\tout.data[(ty * sw + tx) * 4 + 2] = img.data[(y * 16 + x) * 4 + 2]!\n\t\t\t\t\t\t\tout.data[(ty * sw + tx) * 4 + 3] = img.data[(y * 16 + x) * 4 + 3]!\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn out\n\t\t\t},\n\t\t\tcleanup,\n", "\t\tstate: game.state\n\t\t}\n\t}"]}
{"filename": "src/web/tune.ts", "chunked_list": ["import { type InstrumentType, type PlayTuneRes, type Tune, instruments, tones } from '../api.js'\n\texport function playFrequency(frequency: number, duration: number, instrument: InstrumentType, ctx: AudioContext, dest: AudioNode) {\n\t\tconst osc = ctx.createOscillator()\n\t\tconst rampGain = ctx.createGain()\n\t\tosc.connect(rampGain)\n\t\trampGain.connect(dest)\n\t\tosc.frequency.value = frequency\n\t\tosc.type = instrument ?? 'sine'\n\t\tosc.start()\n\t\tconst endTime = ctx.currentTime + duration*2/1000\n", "\tosc.stop(endTime)\n\t\trampGain.gain.setValueAtTime(0, ctx.currentTime)\n\t\trampGain.gain.linearRampToValueAtTime(.2, ctx.currentTime + duration/5/1000)\n\t\trampGain.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + duration/1000)\n\t\trampGain.gain.linearRampToValueAtTime(0, ctx.currentTime + duration*2/1000) // does this ramp from the last ramp\n\t\tosc.onended = () => {\n\t\t\tosc.disconnect()\n\t\t\trampGain.disconnect()\n\t\t}\n\t}\n", "const sleep = async (duration: number) => new Promise(resolve => setTimeout(resolve, duration))\n\texport async function playTuneHelper(tune: Tune, number: number, playingRef: { playing: boolean }, ctx: AudioContext, dest: AudioNode) {\n\t\tfor (let i = 0; i < tune.length*number; i++) {\n\t\t\tconst index = i%tune.length\n\t\t\tif (!playingRef.playing) break\n\t\t\tconst noteSet = tune[index]!\n\t\t\tconst sleepTime = noteSet[0]\n\t\t\tfor (let j = 1; j < noteSet.length; j += 3) {\n\t\t\t\tconst instrument = noteSet[j] as InstrumentType\n\t\t\t\tconst note = noteSet[j+1]!\n", "\t\t\tconst duration = noteSet[j+2] as number\n\t\t\t\tconst frequency = typeof note === 'string' \n\t\t\t\t\t? tones[note.toUpperCase()]\n\t\t\t\t\t: 2**((note-69)/12)*440\n\t\t\t\tif (instruments.includes(instrument) && frequency !== undefined) playFrequency(frequency, duration, instrument, ctx, dest)\n\t\t\t}\n\t\t\tawait sleep(sleepTime)\n\t\t}\n\t}\n\tlet audioCtx: AudioContext | null = null\n", "export function playTune(tune: Tune, number = 1): PlayTuneRes {\n\t\tconst playingRef = { playing: true }\n\t\tif (audioCtx === null) audioCtx = new AudioContext()\n\t\tplayTuneHelper(tune, number, playingRef, audioCtx, audioCtx.destination)\n\t\treturn {\n\t\t\tend() { playingRef.playing = false },\n\t\t\tisPlaying() { return playingRef.playing }\n\t\t}\n\t}"]}
{"filename": "src/web/text.ts", "chunked_list": ["import type { TextElement } from '../api.js'\n\timport { font, composeText } from '../base/index.js'\n\timport { makeCanvas } from './util.js'\n\texport const getTextImg = (texts: TextElement[]): CanvasImageSource => {\n\t\tconst charGrid = composeText(texts)\n\t\tconst img = new ImageData(160, 128)\n\t\timg.data.fill(0)\n\t\tfor (const [i, row] of Object.entries(charGrid)) {\n\t\t\tlet xt = 0\n\t\t\tfor (const { char, color } of row) {\n", "\t\t\tconst cc = char.charCodeAt(0)\n\t\t\t\tlet y = Number(i)*8\n\t\t\t\tfor (const bits of font.slice(cc*8, (1+cc)*8)) {\n\t\t\t\t\t\tfor (let x = 0; x < 8; x++) {\n\t\t\t\t\t\t\tconst val = (bits>>(7-x)) & 1\n\t\t\t\t\t\t\timg.data[(y*img.width + xt + x)*4 + 0] = val*color[0]\n\t\t\t\t\t\t\timg.data[(y*img.width + xt + x)*4 + 1] = val*color[1]\n\t\t\t\t\t\t\timg.data[(y*img.width + xt + x)*4 + 2] = val*color[2]\n\t\t\t\t\t\t\timg.data[(y*img.width + xt + x)*4 + 3] = val*255\n\t\t\t\t\t\t}\n", "\t\t\t\t\ty++\n\t\t\t\t}\n\t\t\t\txt += 8\n\t\t\t}\n\t\t}\n\t\tconst canvas = makeCanvas(160, 128)\n\t\tcanvas.getContext('2d')!.putImageData(img, 0, 0)\n\t\treturn canvas\n\t}"]}
{"filename": "src/web/index.ts", "chunked_list": ["import { type InputKey, type PlayTuneRes, VALID_INPUTS, type FullSprigAPI, type GameState } from '../api.js'\n\timport { type BaseEngineAPI, baseEngine, textToTune } from '../base/index.js'\n\timport { bitmapTextToImageData } from '../image-data/index.js'\n\timport { getTextImg } from './text.js'\n\timport { playTune } from './tune.js'\n\timport { makeCanvas } from './util.js'\n\texport * from './text.js'\n\texport * from './tune.js'\n\texport type WebEngineAPI = BaseEngineAPI & Pick<\n\t\tFullSprigAPI,\n", "\t| 'setLegend'\n\t\t| 'onInput'\n\t\t| 'afterInput'\n\t\t| 'playTune'\n\t> & {\n\t\tgetState(): GameState // For weird backwards-compatibility reasons, not part of API\n\t}\n\texport function webEngine(canvas: HTMLCanvasElement): {\n\t\tapi: WebEngineAPI,\n\t\tstate: GameState,\n", "\tcleanup(): void\n\t} {\n\t\tconst { api, state } = baseEngine()\n\t\tconst ctx = canvas.getContext('2d')!\n\t\tconst offscreenCanvas = makeCanvas(1, 1)\n\t\tconst offscreenCtx = offscreenCanvas.getContext('2d')!\n\t\tconst _bitmaps: Record<string, CanvasImageSource> = {}\n\t\tlet _zOrder: string[] = []\n\t\tctx.imageSmoothingEnabled = false\n\t\tconst _gameloop = (): void => {\n", "\t\tconst { width, height } = state.dimensions\n\t\t\tif (width === 0 || height === 0) return\n\t\t\tctx.clearRect(0, 0, canvas.width, canvas.height)\n\t\t\toffscreenCanvas.width = width*16\n\t\t\toffscreenCanvas.height = height*16\n\t\t\toffscreenCtx.fillStyle = 'white'\n\t\t\toffscreenCtx.fillRect(0, 0, width*16, height*16)\n\t\t\tconst grid = api.getGrid()\n\t\t\tfor (let i = 0; i < width * height; i++) {\n\t\t\t\tconst x = i % width\n", "\t\t\tconst y = Math.floor(i/width)\n\t\t\t\tconst sprites = grid[i]!\n\t\t\t\tif (state.background) {\n\t\t\t\t\tconst imgData = _bitmaps[state.background]!\n\t\t\t\t\toffscreenCtx.drawImage(imgData, x*16, y*16)\n\t\t\t\t}\n\t\t\t\tsprites\n\t\t\t\t\t.sort((a, b) => _zOrder.indexOf(b.type) - _zOrder.indexOf(a.type))\n\t\t\t\t\t.forEach((sprite) => {\n\t\t\t\t\t\tconst imgData = _bitmaps[sprite.type]!\n", "\t\t\t\t\toffscreenCtx.drawImage(imgData, x*16, y*16)\n\t\t\t\t\t})\n\t\t\t}\n\t\t\tconst scale = Math.min(canvas.width/(width*16), canvas.height/(height*16))\n\t\t\tconst actualWidth = offscreenCanvas.width*scale\n\t\t\tconst actualHeight = offscreenCanvas.height*scale\n\t\t\tctx.drawImage(\n\t\t\t\toffscreenCanvas, \n\t\t\t\t(canvas.width-actualWidth)/2, \n\t\t\t\t(canvas.height-actualHeight)/2, \n", "\t\t\tactualWidth, \n\t\t\t\tactualHeight\n\t\t\t)\n\t\t\tconst textCanvas = getTextImg(state.texts)\n\t\t\tctx.drawImage(\n\t\t\t\ttextCanvas, \n\t\t\t\t0,\n\t\t\t\t0, \n\t\t\t\tcanvas.width, \n\t\t\t\tcanvas.height\n", "\t\t)\n\t\t\tanimationId = window.requestAnimationFrame(_gameloop)\n\t\t}\n\t\tlet animationId = window.requestAnimationFrame(_gameloop)\n\t\tconst setLegend = (...bitmaps: [string, string][]): void => {\n\t\t\tif (bitmaps.length == 0) throw new Error('There needs to be at least one sprite in the legend.')\n\t\t\tif (!Array.isArray(bitmaps[0])) throw new Error('The sprites passed into setLegend each need to be in square brackets, like setLegend([player, bitmap`...`]).')\n\t\t\tbitmaps.forEach(([ key ]) => {\n\t\t\t\tif (key === '.') throw new Error(`Can't reassign \".\" bitmap`)\n\t\t\t\tif (key.length !== 1) throw new Error(`Bitmaps must have one character names`)\n", "\t\t})\n\t\t\tstate.legend = bitmaps\n\t\t\t_zOrder = bitmaps.map(x => x[0])\n\t\t\tfor (let i = 0; i < bitmaps.length; i++) {\n\t\t\t\tconst [ key, value ] = bitmaps[i]!\n\t\t\t\tconst imgData = bitmapTextToImageData(value)\n\t\t\t\tconst littleCanvas = makeCanvas(16, 16)\n\t\t\t\tlittleCanvas.getContext('2d')!.putImageData(imgData, 0, 0)\n\t\t\t\t_bitmaps[key] = littleCanvas\n\t\t\t}\n", "\t}\n\t\tlet tileInputs: Record<InputKey, (() => void)[]> = {\n\t\t\tw: [],\n\t\t\ts: [],\n\t\t\ta: [],\n\t\t\td: [],\n\t\t\ti: [],\n\t\t\tj: [],\n\t\t\tk: [],\n\t\t\tl: []\n", "\t}\n\t\tconst afterInputs: (() => void)[] = []\n\t\tconst keydown = (e: KeyboardEvent) => {\n\t\t\tconst key = e.key\n\t\t\tif (!VALID_INPUTS.includes(key as any)) return\n\t\t\tfor (const validKey of VALID_INPUTS)\n\t\t\t\tif (key === validKey) tileInputs[key].forEach(fn => fn())\n\t\t\tafterInputs.forEach(f => f())\n\t\t\tstate.sprites.forEach((s: any) => {\n\t\t\t\ts.dx = 0\n", "\t\t\ts.dy = 0\n\t\t\t})\n\t\t\te.preventDefault()\n\t\t}\n\t\tcanvas.addEventListener('keydown', keydown)\n\t\tconst onInput = (key: InputKey, fn: () => void): void => {\n\t\t\tif (!VALID_INPUTS.includes(key))\n\t\t\t\tthrow new Error(`Unknown input key, \"${key}\": expected one of ${VALID_INPUTS.join(', ')}`)\n\t\t\ttileInputs[key].push(fn)\n\t\t}\n", "\tconst afterInput = (fn: () => void): void => { afterInputs.push(fn) }\n\t\tconst tunes: PlayTuneRes[] = []\n\t\treturn {\n\t\t\tapi: {\n\t\t\t\t...api,\n\t\t\t\tsetLegend,\n\t\t\t\tonInput, \n\t\t\t\tafterInput,\n\t\t\t\tgetState: () => state,\n\t\t\t\tplayTune: (text: string, n: number) => {\n", "\t\t\t\tconst tune = textToTune(text)\n\t\t\t\t\tconst playTuneRes = playTune(tune, n)\n\t\t\t\t\ttunes.push(playTuneRes)\n\t\t\t\t\treturn playTuneRes\n\t\t\t\t}\n\t\t\t},\n\t\t\tstate,\n\t\t\tcleanup: () => {\n\t\t\t\tctx.clearRect(0, 0, canvas.width, canvas.height)\n\t\t\t\twindow.cancelAnimationFrame(animationId)\n", "\t\t\tcanvas.removeEventListener('keydown', keydown)\n\t\t\t\ttunes.forEach(tune => tune.end())\n\t\t\t}\n\t\t}\n\t}\n"]}
{"filename": "src/web/util.ts", "chunked_list": ["export function makeCanvas(width: number, height: number): HTMLCanvasElement {\n\t\tconst canvas = document.createElement('canvas')\n\t\tcanvas.width = width\n\t\tcanvas.height = height\n\t\treturn canvas\n\t}"]}
