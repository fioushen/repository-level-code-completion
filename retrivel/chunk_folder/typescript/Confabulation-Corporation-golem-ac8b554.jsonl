{"filename": "tests/parser.test.ts", "chunked_list": ["import { parseGolemFile } from '../src/parser';\n\timport fs from 'fs';\n\tdescribe('Golem file parsing tests', () => {\n\t  test('Valid Golem file', () => {\n\t    const golemFileContent = fs.readFileSync('golems/valid_golem_file.yaml', 'utf-8');\n\t    const golemFile = parseGolemFile(golemFileContent);\n\t    expect(golemFile.default).toBeDefined();\n\t    expect(golemFile.say_hello?.prompt).toBe(\"Generate a 'Hello, world!' message.\");\n\t  });\n\t  test('Golem file with multiple targets', () => {\n", "    const golemFileContent = fs.readFileSync('golems/multiple_targets_golem_file.yaml', 'utf-8');\n\t    const golemFile = parseGolemFile(golemFileContent);\n\t    expect(golemFile.default).toBeDefined();\n\t    expect(golemFile.greet_person?.prompt).toBe(\"{{get_greeting}} {{get_name}}.\");\n\t    expect(golemFile.get_name?.prompt).toBe(\"Provide a person's name.\");\n\t    expect(golemFile.get_greeting?.prompt).toBe(\"Generate a greeting word.\");\n\t  });\n\t  test('Invalid Golem file (missing default target)', () => {\n\t    const golemFileContent = fs.readFileSync('golems/missing_default_target_golem_file.yaml', 'utf-8');\n\t    const golemFile = parseGolemFile(golemFileContent);\n", "    expect(golemFile.default).toBeUndefined();\n\t  });\n\t  test('Invalid Golem file (missing dependency)', () => {\n\t    const golemFileContent = fs.readFileSync('golems/missing_dependency_golem_file.yaml', 'utf-8');\n\t    const golemFile = parseGolemFile(golemFileContent);\n\t    expect(golemFile.default).toBeDefined();\n\t    expect(golemFile.greet_person?.prompt).toBe(\"{{get_greeting}} {{get_name}}.\");\n\t    expect(golemFile.get_name?.prompt).toBe(\"Provide a person's name.\");\n\t    expect(golemFile.get_greeting).toBeUndefined();\n\t  });\n", "  test('Golem file with model configuration', () => {\n\t    const golemFileContent = fs.readFileSync('golems/model_configuration_golem_file.yaml', 'utf-8');\n\t    const golemFile = parseGolemFile(golemFileContent);\n\t    expect(golemFile.default).toBeDefined();\n\t    expect(golemFile.generate_message?.model).toBe('gpt-3.5-turbo');\n\t    expect(golemFile.generate_message?.prompt).toBe(\"Create a unique message that includes the word 'cache'.\");\n\t  });\n\t});\n"]}
{"filename": "tests/nested_dependencies.test.ts", "chunked_list": ["import { parseGolemFile } from '../src/parser';\n\timport fs from 'fs';\n\timport { executeTarget } from '../src/executor';\n\tdescribe('Nested dependencies test', () => {\n\t  test('Check if the executor can handle complex dependency structures', async () => {\n\t    const golemFileContent = fs.readFileSync('golems/nested_dependencies.yaml', 'utf-8');\n\t    const golemFile = parseGolemFile(golemFileContent);\n\t    const context = new Map();\n\t    await executeTarget('default', golemFile, golemFileContent, context);\n\t    expect(context.get('level_1')).toBe(\"Level 1 result: Level 2 result: Level 3 result: This is the final level.\");\n", "  });\n\t});\n"]}
{"filename": "tests/dynamic_task_creation.test.ts", "chunked_list": ["import { executeTarget } from '../src/executor';\n\timport { parseGolemFile } from '../src/parser';\n\timport { GolemFile } from '../src/types';\n\tdescribe('Dynamic Task Creation', () => {\n\t  let golemFile: GolemFile;\n\t  beforeEach(() => {\n\t    // Load the Golem file with dynamic task generation\n\t    const golemFileContent = `\n\t    default:\n\t      dependencies:\n", "        - initial_task\n\t    initial_task:\n\t      dependencies: []\n\t      prompt: \"Create a Python function that adds two numbers.\"\n\t      task_generation_prompt: \"Based on the outcome of the initial_task, generate new targets to create functions for other arithmetic operations.\"\n\t    `;\n\t    golemFile = parseGolemFile(golemFileContent);\n\t  });\n\t  test('successful dynamic task creation', async () => {\n\t    const initialContext = new Map();\n", "    await executeTarget('initial_task', golemFile, initialContext);\n\t    const newTargets = Object.keys(golemFile).filter(target => target !== 'default' && target !== 'initial_task');\n\t    expect(newTargets.length).toBeGreaterThan(0);\n\t  });\n\t  test('dynamic task creation with AI chat failure', async () => {\n\t    const initialContext = new Map();\n\t    const originalApiKey = process.env.OPENAI_API_KEY;\n\t    process.env.OPENAI_API_KEY = 'INVALID_KEY';\n\t    try {\n\t      await executeTarget('initial_task', golemFile, initialContext);\n", "    } catch (error: any) {\n\t      expect(error.message).toContain('Error generating AI response');\n\t    } finally {\n\t      process.env.OPENAI_API_KEY = originalApiKey;\n\t    }\n\t  });\n\t  test('dynamic task creation with duplicate or invalid target names', async () => {\n\t    if (golemFile['initial_task']) {\n\t      golemFile['initial_task'].task_generation_prompt = 'Generate a new target with the same name as the initial_task.';\n\t    }\n", "    const initialContext = new Map();\n\t    await executeTarget('initial_task', golemFile, initialContext);\n\t    const newTargets = Object.keys(golemFile).filter(target => target !== 'default' && target !== 'initial_task');\n\t    expect(newTargets.length).toBe(0);\n\t  });\n\t  test('dynamic task creation with no new tasks generated', async () => {\n\t    if (golemFile['initial_task']) {\n\t      golemFile['initial_task'].task_generation_prompt = 'Do not generate any new targets.';\n\t    }\n\t    const initialContext = new Map<string, any>();\n", "    await executeTarget('initial_task', golemFile, initialContext);\n\t    const newTargets = Object.keys(golemFile).filter(target => target !== 'default' && target !== 'initial_task');\n\t    expect(newTargets.length).toBe(0);\n\t  });\n\t});"]}
{"filename": "src/chat_gpt.ts", "chunked_list": ["import { Configuration, OpenAIApi } from 'openai';\n\timport logger from './logger';\n\texport interface ChatGPTMessage {\n\t  role: 'system' | 'user' | 'assistant';\n\t  content: string;\n\t}\n\t// My environment variable is saving the open ai api key as OPENAI_API_KEY not OPENAI_TOKEN. Commented for pull request\n\tconst OPENAI_TOKEN = process.env.OPENAI_API_KEY;\n\t// const OPENAI_TOKEN = process.env.OPENAI_TOKEN;\n\texport async function ChatGPT_completion(\n", "  messages: ChatGPTMessage[],\n\t  model: \"gpt-3.5-turbo\" | \"gpt-3.5-turbo-0301\" | \"gpt-4-0314\" | \"gpt-4-32k\",\n\t  temperature: number = 0.7,\n\t  top_p: number = 0.9,\n\t  maxRetries: number = 3\n\t): Promise<string> {\n\t  const config = new Configuration({\n\t    apiKey: OPENAI_TOKEN,\n\t  });\n\t  const openai = new OpenAIApi(config);\n", "  for (let i = 0; i < maxRetries; i++) {\n\t    try {\n\t      const completion = await openai.createChatCompletion({\n\t        model: model,\n\t        messages: messages,\n\t      });\n\t      return (completion.data!.choices[0]!.message?.content || \"\").trim();\n\t    } catch (error: any) {\n\t      if (error.response && (error.response.status === 429 || (error.response.status >= 500 && error.response.status < 600))) {\n\t        const resetMs = parseInt(error.response.headers['x-ratelimit-reset-requests']) || 1000;\n", "        const waitTime = resetMs + Math.random() * 1000;\n\t        logger.warn(\n\t          `Rate limit or server error encountered (status: ${error.response.status}). Retrying in ${waitTime} ms...`\n\t        );\n\t        await new Promise((resolve) => setTimeout(resolve, waitTime));\n\t      } else {\n\t        throw error;\n\t      }\n\t    }\n\t  }\n", "  throw new Error('Max retries reached. Request failed.');\n\t}"]}
{"filename": "src/parser.ts", "chunked_list": ["import * as yaml from 'js-yaml';\n\timport { GolemFile } from './types';\n\texport function parseGolemFile(content: string): GolemFile {\n\t  try {\n\t    const parsedContent = yaml.load(content) as GolemFile;\n\t    // Update the parsing logic to handle the task_generation_prompt field\n\t    return parsedContent;\n\t  } catch (error: any) {\n\t    throw new Error(`Error parsing Golem file: ${error.message}`);\n\t  }\n", "}"]}
{"filename": "src/types.ts", "chunked_list": ["export interface GolemTarget {\n\t  dependencies: string[];\n\t  prompt: string;\n\t  model?: string; // Add this line\n\t  task_generation_prompt?: string; // Add this line\n\t  [key: string]: string[] | string | undefined;\n\t}\n\texport type GolemFile = {\n\t  default: string[];\n\t} & {\n", "  [target: string]: GolemTarget | undefined;\n\t};\n\texport function isGolemTarget(target: GolemTarget | string[] | undefined): target is GolemTarget {\n\t  return target !== undefined && (target as GolemTarget).dependencies !== undefined;\n\t}\n"]}
{"filename": "src/logger.ts", "chunked_list": ["import pino from 'pino';\n\tconst logger = pino({\n\t  level: process.env.LOG_LEVEL || 'warn',\n\t});\n\texport default logger;\n"]}
{"filename": "src/errors.ts", "chunked_list": ["import logger from './logger';\n\texport class GolemError extends Error {\n\t  constructor(message: string) {\n\t    super(message);\n\t    this.name = 'GolemError';\n\t  }\n\t}\n\texport function handleGolemError(error: GolemError): void {\n\t  logger.error(`[${error.name}] ${error.message}`);\n\t}"]}
{"filename": "src/utils.ts", "chunked_list": ["import { createHash } from 'crypto';\n\timport { existsSync, readFileSync, writeFileSync, mkdirSync, appendFileSync } from 'fs';\n\timport { join } from 'path';\n\texport function generateCacheKey(target: string, dependencies: string[], furtherInstructionsArr: string[]): string {\n\t  const stringToHash = JSON.stringify(furtherInstructionsArr);\n\t  const inputString = `${target}:${dependencies.join(',')}_${stringToHash}`;\n\t  const hash = createHash('sha1').update(inputString).digest('hex');\n\t  return hash;\n\t}\n\texport function getCachedOutputPath(target: string, cacheKey: string): string {\n", "  return join('.golem', `${target}_${cacheKey}_output.txt`);\n\t}\n\texport function isCacheValid(target: string, cacheKey: string): boolean {\n\t  const cachedOutputPath = getCachedOutputPath(target, cacheKey);\n\t  return existsSync(cachedOutputPath);\n\t}\n\texport function saveOutputToCache(target: string, cacheKey: string, context: Map<string, any>): void {\n\t  const cachedOutputPath = getCachedOutputPath(target, cacheKey);\n\t  const defaultMap = new Map();\n\t  if (context.has(\"default\")) {\n", "    defaultMap.set(\"default\", context.get(\"default\"));\n\t    writeFileSync(cachedOutputPath, JSON.stringify(Object.fromEntries(defaultMap), null, 2), 'utf-8');\n\t  }else{\n\t    writeFileSync(cachedOutputPath, JSON.stringify(Object.fromEntries(context), null, 2), 'utf-8');\n\t  }\n\t}\n\texport function appendToGolemFile(golemFilePath: string, target: string): void {\n\t  appendFileSync(golemFilePath, target, 'utf-8');\n\t}\n\texport function loadOutputFromCache(target: string, cacheKey: string): string {\n", "  const cachedOutputPath = getCachedOutputPath(target, cacheKey);\n\t  return readFileSync(cachedOutputPath, 'utf-8');\n\t}\n\texport function createGolemCacheDir(): void {\n\t  if (!existsSync('.golem')) {\n\t    mkdirSync('.golem');\n\t  }\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export { parseGolemFile } from './parser';\n\texport { GolemFile } from './types';\n\texport { resolveDependencies } from './dependencies';\n\texport { executeTarget } from './executor';\n\texport { GolemError, handleGolemError } from './errors';\n"]}
{"filename": "src/golem.ts", "chunked_list": ["#!/usr/bin/env node\n\timport yargs from 'yargs';\n\timport { executeTarget } from './executor';\n\timport { parseGolemFile } from './parser';\n\timport fs from 'fs';\n\timport logger from './logger';\n\timport { createGolemCacheDir } from './utils'; // Add this import\n\tyargs\n\t  .command(\n\t    'golem [golemFile]',\n", "    'Run the specified Golem file or the default Golem file if none is provided.',\n\t    (yargs) => {\n\t      yargs.positional('golemFile', {\n\t        describe: 'Path to the Golem file',\n\t        default: 'Golem.yaml',\n\t        type: 'string',\n\t      });\n\t    },\n\t    async (argv) => {\n\t      try {\n", "        const golemFilePath = argv.golemFile as string;\n\t        // console.log(golemFilePath);\n\t        // Add this line to create the .golem/ directory\n\t        createGolemCacheDir();\n\t        // Read the Golem file content\n\t        const golemFileContent = fs.readFileSync(golemFilePath, 'utf8');\n\t        const golemFile = parseGolemFile(golemFileContent);\n\t        console.log(golemFile);\n\t        // Execute the default target with an empty context\n\t        await executeTarget('default', golemFile, golemFilePath, new Map());\n", "      } catch (error: any) {\n\t        logger.error(`Error: ${error.message}`);\n\t      }\n\t    }\n\t  )\n\t  .demandCommand(1, 'You must provide a valid command.')\n\t  .help()\n\t  .alias('h', 'help')\n\t  .strict().argv;\n"]}
{"filename": "src/dependencies.ts", "chunked_list": ["import { GolemFile, isGolemTarget } from './types';\n\timport { GolemError } from './errors';\n\texport function resolveDependencies(golemFile: GolemFile): string[] {\n\t  const resolvedDependencies: string[] = [];\n\t  if (!golemFile.default) {\n\t    throw new GolemError(\"No default target specified\");\n\t  }\n\t  const defaultTarget = golemFile.default;\n\t  if (isGolemTarget(defaultTarget)) {\n\t    const defaultDependencies = defaultTarget.dependencies;\n", "    if (Array.isArray(defaultDependencies)) {\n\t      resolvedDependencies.push(...defaultDependencies);\n\t    }\n\t  }\n\t  return resolvedDependencies;\n\t}\n"]}
{"filename": "src/executor.ts", "chunked_list": ["import { exec } from 'child_process';\n\timport { GolemFile, GolemTarget, isGolemTarget } from './types';\n\timport { ChatGPTMessage, ChatGPT_completion } from './chat_gpt';\n\timport { readFile } from 'fs/promises';\n\timport { dirname } from 'path';\n\timport logger from './logger';\n\timport {\n\t  generateCacheKey,\n\t  isCacheValid,\n\t  saveOutputToCache,\n", "  loadOutputFromCache,\n\t  appendToGolemFile\n\t} from './utils';\n\timport { writeFileSync} from 'fs';\n\t// TODO 1: Check if prompt asks for additional targets.\n\t// TODO 2: Check if targets have other dependencies.\n\t// TODO 3: Saving properly (for example, it saves all of the previous context for imp task)\n\t// TODO 4: Use different files\n\tinterface ExecutionContext {\n\t  [key: string]: any;\n", "}\n\tconst mainPrompt: ChatGPTMessage = {\n\t  role: 'system',\n\t  content: `You are an Agentic LLM assistant, designed only to produce code and helpful information. You may be asked to generate new targets. If the prompt given to you contains the phrase 'generate new targets', your response will be to generate a list of targets to help answer the prompt. The targets must be written as unnumbered items separated by lines starting with 'Target:'. \n\t  The items in the list will not be arranged in any particular order. For example:\n\t  Prompt: As an agentic LLM, generate new targets for the next iteration.\n\t  Response:\n\t  Target: Write a function to divide two numbers.\n\t  Target: Create a class called Employee.\n\t  Target: Write unit tests for the function GetPeopleInterests.\n", "  It is not always the case that you will be asked to generate new targets. If the prompt does not contain the phrase 'generate new targets', then proceed to answer the prompt as truthfully as possible. For example:\n\t  Prompt: What is capital of France?\n\t  Response: Paris.\n\t  Prompt: How many days are in the month of April?\n\t  Response: 30 days.\n\t  You are opinionated. If asked to provide a subjective answer, start by saying 'In my opinion' then answer the prompt. For example:\n\t  Prompt: What is the best sport?\n\t  Response: In my opinion, soccer.\n\t  `\n\t}\n", "export async function executeTarget(target: string, golemFile: GolemFile, golemFilePath: string, context: Map<string, any> = new Map()): Promise<void> {\n\t  const golemTarget = golemFile[target];\n\t  if (!golemTarget) {\n\t    throw new Error(`Target \"${target}\" not found in Golem file.`);\n\t  }\n\t  console.log(`Executing target: ${target}`);\n\t  if (golemTarget.dependencies) {\n\t    console.log(`Dependencies for ${target}: ${golemTarget.dependencies}`);\n\t    for (const dependency of golemTarget.dependencies) {\n\t      if (dependency) {\n", "        await executeTarget(dependency, golemFile, golemFilePath, context);\n\t      }\n\t    }\n\t  }\n\t  await executeAIChatWithCache(target, golemFile, golemFilePath, context);\n\t  console.log(`Context after ${target} execution:`, context);\n\t}\n\tfunction executeCommand(command: string): Promise<void> {\n\t  return new Promise((resolve, reject) => {\n\t    exec(command, (error, stdout, stderr) => {\n", "      if (error) {\n\t        logger.error(`Error executing command: ${command}`);\n\t        logger.error(stderr);\n\t        reject(error);\n\t      } else {\n\t        logger.debug(stdout);\n\t        resolve();\n\t      }\n\t    });\n\t  });\n", "}\n\tasync function executeAIChatWithCache(target: string, golemFile: GolemFile, golemFilePath: string, context: Map<string, any>): Promise<void> {\n\t  const golemFileToArray: any = [];\n\t  for (const key in golemFile){\n\t    const val = golemFile[key as keyof typeof golemFile];\n\t    golemFileToArray.push(val);\n\t  }\n\t  const golemTarget = golemFile[target];\n\t  if (!golemTarget || !isGolemTarget(golemTarget)) {\n\t    return;\n", "  }\n\t  const cacheKey = generateCacheKey(target, golemTarget.dependencies || [], [...golemFileToArray] || '');\n\t  if (isCacheValid(target, cacheKey)) {\n\t    console.log(\"Returning Cached output\");\n\t    const cachedOutput = loadOutputFromCache(target, cacheKey);\n\t    context.set(target, cachedOutput);\n\t  } else {\n\t    await executeAIChat(target, golemFile, golemFilePath, context);\n\t    saveOutputToCache(target, cacheKey, context);\n\t  }\n", "}\n\tasync function executeAIChat(target: string, golemFile: GolemFile, golemFilePath: string, context: Map<string, any>): Promise<void> {\n\t  // ============== Setup start ====================================\n\t  const contextOfCurrentTarget: string[] = [];\n\t  const allOutputs: {[key: string]: any} = {}; \n\t  const golemTarget = golemFile[target];\n\t  console.log(\"gT\", golemTarget);\n\t  if (!golemTarget) {\n\t    throw new Error(`Target \"${target}\" not found in Golem file.`);\n\t  }\n", "  if (!isGolemTarget(golemTarget)) {\n\t    return;\n\t  }\n\t  if (!golemTarget.prompt && !golemTarget.model) {\n\t    golemTarget.model = 'cat';\n\t  }\n\t  let prompt = golemTarget.prompt ?? \"{no prompt}\";\n\t  if (isGolemTarget(golemTarget) && golemTarget.prompt) {\n\t    prompt = golemTarget.prompt;\n\t    const placeholderRegex = /{{\\s*([\\w\\/.-]+)\\s*}}/g;\n", "    let match;\n\t    while ((match = placeholderRegex.exec(prompt)) !== null) {\n\t      const key = match[1];\n\t      if (context.has(key)) {\n\t        prompt = prompt.replace(match[0], context.get(key));\n\t      } else {\n\t        prompt = prompt.replace(match[0], \"\");\n\t      }\n\t    }\n\t  }\n", "  else if (!golemTarget.prompt) {\n\t    const defaultValues = new Map(context.entries());\n\t    context.set(\"default\", Object.fromEntries(defaultValues));\n\t    return;\n\t  }\n\t  const model = golemTarget.model ?? 'gpt-3.5-turbo';\n\t  // ============== Setup end ====================================\n\t  if (model === 'cat') {\n\t    const concatenatedOutput = golemTarget.dependencies.map(dep => context.get(dep)).join('');\n\t    context.set(target, concatenatedOutput);\n", "  } else if (model == \"gpt-3.5-turbo\" || model == \"gpt-3.5-turbo-0301\" || model == \"gpt-4-0314\" || model == \"gpt-4-32k\") {\n\t    if (\"model\" in golemTarget) {\n\t      delete golemTarget.model;\n\t    }\n\t    // This gets the 'keys' (subtasks) of a target (task)\n\t    const golemTargetKeys: string[] = Object.keys(golemTarget);\n\t    // It starts from 1 as index 0 is dependencies. This can be changed if needed\n\t    for (let i = 1; i < golemTargetKeys.length; i++){\n\t      // console.log(\"gTKi\", golemTargetKeys[i]);\n\t      const val: any = golemTarget[golemTargetKeys[i] as keyof typeof golemTarget];\n", "      // console.log(\"val\", val);\n\t      const previousContext: string | undefined = contextOfCurrentTarget[0] || '';\n\t      // Concat the previousContext (if undefined) to the current subtask (here, named val)\n\t      const content = previousContext + val;\n\t      // console.log(\"content\", content);\n\t      // This block of code replaces the {{}} placeholders in the string from the yaml file \n\t      // with the output of the subtask or task it requires\n\t      const replacedString = content.replace(/{{(.*?)}}/g, (match, p1) => {\n\t        // Remove the curly braces from the placeholder\n\t        const placeholder = p1.trim();\n", "        // Replace the placeholder with the corresponding value from the map\n\t        return context.get(placeholder) || placeholder;\n\t      });\n\t      // console.log(\"context\", context);\n\t      // console.log(\"replacedString\", replacedString);\n\t      const taskGenerationMessages: ChatGPTMessage[] = [\n\t        mainPrompt,\n\t        {\n\t          role: 'user',\n\t          content: replacedString,\n", "        },\n\t      ];\n\t      const response = await ChatGPT_completion(taskGenerationMessages, model, 0.7, 0.9);\n\t      contextOfCurrentTarget.length = 0; //clear the previous context\n\t      contextOfCurrentTarget.push(response); //append the new context to be used in the next iteration\n\t      allOutputs[golemTargetKeys[i]] = response;\n\t      const lines: string[] = response.split('\\n');\n\t      // Extract the targets from the lines that start with \"Target:\"\n\t      const targets: string[] = lines.filter((line: string) => line.startsWith(\"Target:\"))\n\t      .map((line: string) => line.slice(8));\n", "      let count = 1;\n\t      targets.forEach((createdTarget: string) => {\n\t        const targetName = target.concat(\"_target\".concat(count.toString())); \n\t        const newTarget: string = `\\n${targetName}:\\n  dependencies: []\\n  prompt: ${createdTarget}`; \n\t        appendToGolemFile(golemFilePath, newTarget);\n\t        golemTargetKeys.push(targetName);\n\t        golemTarget[targetName] = createdTarget;\n\t        count += 1;\n\t      });  \n\t      if (golemTargetKeys.length === 2){\n", "        if (!response) {\n\t          context.set(target, `Default value for ${target}`);\n\t        } else {\n\t          context.set(target, response);\n\t          console.log(context);\n\t        }\n\t      }\n\t      else if (golemTargetKeys.length > 2){\n\t        try {          \n\t          for (const key in allOutputs) {\n", "            context.set(key, allOutputs[key]);\n\t          }\n\t        }catch (error: any) {\n\t          logger.error(`Error generating AI response: ${error.message}`);\n\t        }  \n\t      }\n\t    }\n\t  }else {\n\t    throw new Error(`No such supported model ${model}`);\n\t  }\n", "}"]}
{"filename": "src/validator.ts", "chunked_list": ["import { GolemFile } from './types';\n\t// import { GolemFileError } from './errors';\n\texport function validateGolemFile(golemFile: GolemFile): void {\n\t  // Validate the Golem file structure and content\n\t  // If any errors are found, throw a GolemFileError with a specific error message\n\t}"]}
