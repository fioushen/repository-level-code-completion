{"filename": "dist/config.d.ts", "chunked_list": ["import { Config } from './types';\n\tdeclare const config: Config;\n\texport default config;\n"]}
{"filename": "dist/types.d.ts", "chunked_list": ["export type Import = string;\n\texport type ImportData = {\n\t    raw: string;\n\t    path: string;\n\t};\n\texport type ImportGroup = 'libraries' | 'aliases' | 'relatives' | 'directRelatives';\n\texport type ImportGroups = Record<ImportGroup, ImportData[]>;\n\texport type LibraryRuleName = 'exact' | 'starts' | 'includes';\n\texport declare enum LibraryRule {\n\t    'EXACT' = \"exact\",\n", "    'STARTS' = \"starts\",\n\t    'INCLUDES' = \"includes\"\n\t}\n\texport type LibraryConfig = {\n\t    name: string;\n\t    rule: LibraryRuleName;\n\t};\n\texport type Config = {\n\t    libs?: LibraryConfig[];\n\t    aliases?: string[];\n", "};\n"]}
{"filename": "dist/preprocess.d.ts", "chunked_list": ["export declare const preprocess: (code: string) => string;\n"]}
{"filename": "dist/getters.d.ts", "chunked_list": ["import { Config } from './types';\n\texport declare const getExtractor: () => Config['extractor'];\n"]}
{"filename": "dist/constants.d.ts", "chunked_list": ["export declare const libraries: {\n\t    name: string;\n\t    rule: string;\n\t}[];\n"]}
{"filename": "dist/index.d.ts", "chunked_list": ["export {};\n"]}
{"filename": "dist/extractors/common-extractor.d.ts", "chunked_list": ["export declare const commonExtractor: (code: string) => RegExpMatchArray | [];\n"]}
{"filename": "dist/extractors/index.d.ts", "chunked_list": ["export * from './common-extractor';\n"]}
{"filename": "dist/utils/sort-input-groups.d.ts", "chunked_list": []}
{"filename": "dist/utils/split-imports-to-groups.d.ts", "chunked_list": ["import { Import, ImportGroups } from '../types';\n\texport declare const splitImportsIntoGroups: (imports: Import[]) => ImportGroups;\n"]}
{"filename": "dist/utils/get-code-before-imports.d.ts", "chunked_list": ["export declare const getCodeBeforeImports: (code: string) => string;\n"]}
{"filename": "dist/utils/replace-imports.d.ts", "chunked_list": ["export declare const replaceImports: (imports: string, code: string) => string;\n"]}
{"filename": "dist/utils/sort-import-groups.d.ts", "chunked_list": ["import { ImportGroups } from '../types';\n\texport declare const sortImportGroups: (inputGroups: ImportGroups) => {\n\t    libraries: any[];\n\t    aliases: any[];\n\t    relatives: any[];\n\t    directRelatives: any[];\n\t};\n"]}
{"filename": "dist/utils/prepare-code.d.ts", "chunked_list": ["import { ImportGroups } from '../types';\n\texport declare const prepareCode: (importGroups: ImportGroups) => string;\n"]}
{"filename": "dist/utils/index.d.ts", "chunked_list": ["export * from './split-imports-to-groups';\n\texport * from './sort-import-groups';\n\texport * from './prepare-code';\n"]}
{"filename": "src/config.ts", "chunked_list": ["import { Config } from './types'\n\tconst config: Config = {\n\t  libs: [\n\t    {\n\t      name: 'react',\n\t      rule: 'exact',\n\t    },\n\t    {\n\t      name: 'next',\n\t      rule: 'starts',\n", "    },\n\t  ],\n\t  aliases: [],\n\t}\n\ttry {\n\t  const userConfig: Config = require('../../../sort-plugin.config.js')\n\t  if (userConfig.libs) {\n\t    config.libs = userConfig.libs\n\t  }\n\t  if (userConfig.aliases) {\n", "    config.aliases = userConfig.aliases\n\t  }\n\t} catch (e) {}\n\texport default config\n"]}
{"filename": "src/types.ts", "chunked_list": ["export type Import = string\n\texport type ImportData = {\n\t  raw: string\n\t  path: string\n\t}\n\texport type ImportGroup = 'libraries' | 'aliases' | 'relatives' | 'directRelatives'\n\texport type ImportGroups = Record<ImportGroup, ImportData[]>\n\texport type LibraryRuleName = 'exact' | 'starts' | 'includes'\n\texport enum LibraryRule {\n\t  'EXACT' = 'exact',\n", "  'STARTS' = 'starts',\n\t  'INCLUDES' = 'includes',\n\t}\n\texport type LibraryConfig = {\n\t  name: string\n\t  rule: LibraryRuleName\n\t}\n\texport type Config = {\n\t  libs?: LibraryConfig[]\n\t  aliases?: string[]\n", "}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { parsers as javascriptParsers } from 'prettier/parser-babel'\n\timport { parsers as typescriptParsers } from 'prettier/parser-typescript'\n\timport { preprocess } from './preprocess'\n\tmodule.exports = {\n\t  parsers: {\n\t    typescript: {\n\t      ...typescriptParsers.typescript,\n\t      preprocess,\n\t    },\n\t    babel: {\n", "      ...javascriptParsers.babel,\n\t      preprocess,\n\t    },\n\t  },\n\t}\n"]}
{"filename": "src/preprocess.ts", "chunked_list": ["import { prepareCode, sortImportGroups, splitImportsIntoGroups } from './utils'\n\timport { ImportGroups } from './types'\n\timport { commonExtractor } from './extractors'\n\timport { replaceImports } from './utils/replace-imports'\n\texport const preprocess = (code: string) => {\n\t  const imports = commonExtractor(code)\n\t  const importGroups: ImportGroups = splitImportsIntoGroups(imports)\n\t  const sortedImportGroups = sortImportGroups(importGroups)\n\t  const preparedCode = prepareCode(sortedImportGroups)\n\t  return replaceImports(preparedCode, code)\n", "}\n"]}
{"filename": "src/extractors/index.ts", "chunked_list": ["export * from './common-extractor'\n"]}
{"filename": "src/extractors/common-extractor.ts", "chunked_list": ["export const commonExtractor = (code: string) => {\n\t  return code.match(/^import[\\s\\S]+?['\"`].+/gm) || []\n\t}\n"]}
{"filename": "src/utils/get-code-before-imports.ts", "chunked_list": ["export const getCodeBeforeImports = (code: string) => {\n\t  const result = code.match(/^[\\s\\S]+?import/m)\n\t  if (result && result[0]) {\n\t    return result[0].replace(/import([\\s\\S]+)?/, '')\n\t  }\n\t  return ''\n\t}\n"]}
{"filename": "src/utils/replace-imports.ts", "chunked_list": ["import { getCodeBeforeImports } from './get-code-before-imports'\n\texport const replaceImports = (imports: string, code: string) => {\n\t  const codeBeforeImports = getCodeBeforeImports(code)\n\t  let codeWithoutImports = code.replace(/^import[\\s\\S]+?['\"`].+/gm, '')\n\t  if (codeBeforeImports) {\n\t    codeWithoutImports = codeWithoutImports.replace(codeBeforeImports, '')\n\t    return `${codeBeforeImports}\\n${imports}\\n${codeWithoutImports}`\n\t  }\n\t  return `${imports}\\n${codeWithoutImports}`\n\t}\n"]}
{"filename": "src/utils/split-imports-to-groups.ts", "chunked_list": ["import config from '../config'\n\timport { Config, Import, ImportData, ImportGroups } from '../types'\n\tconst extractImportPath = (importString: string): string => {\n\t  const matches = importString.match(/from.+/)\n\t  if (matches !== null) {\n\t    return matches[0].replace(/['\"]/gm, '').replace('from', '').trim()\n\t  }\n\t  return importString.replace(/['\"]/gm, '').replace('import', '').trim()\n\t}\n\tconst matchToUserAlias = (importSource: string, aliases: Config['aliases']) => {\n", "  for (const alias of aliases) {\n\t    if (importSource.startsWith(`@${alias}`)) {\n\t      return true\n\t    }\n\t  }\n\t  return false\n\t}\n\tconst isDireactAliasImport = (importSource: string, importString: string) => {\n\t  return importSource.startsWith('@') && !importString.includes('from')\n\t}\n", "export const splitImportsIntoGroups = (imports: Import[]): ImportGroups => {\n\t  const libraries: ImportData[] = []\n\t  const aliases: ImportData[] = []\n\t  const relatives: ImportData[] = []\n\t  const directRelatives: ImportData[] = []\n\t  const userAliases = config.aliases\n\t  for (const importString of imports) {\n\t    const importSource = extractImportPath(importString)\n\t    if (\n\t      ((userAliases.length < 1 && importSource.startsWith('@')) ||\n", "        matchToUserAlias(importSource, userAliases)) &&\n\t      !isDireactAliasImport(importSource, importString)\n\t    ) {\n\t      aliases.push({ raw: importString, path: importSource })\n\t    } else if (importSource.startsWith('.') && importString.includes('from')) {\n\t      relatives.push({ raw: importString, path: importSource })\n\t    } else if (importSource.startsWith('.') || isDireactAliasImport(importSource, importString)) {\n\t      directRelatives.push({ raw: importString, path: importSource })\n\t    } else {\n\t      libraries.push({ raw: importString, path: importSource })\n", "    }\n\t  }\n\t  return {\n\t    libraries,\n\t    aliases,\n\t    relatives,\n\t    directRelatives,\n\t  }\n\t}\n"]}
{"filename": "src/utils/sort-import-groups.ts", "chunked_list": ["import config from '../config'\n\timport { ImportData, ImportGroups, LibraryRule } from '../types'\n\tconst getImportDepth = (path: string) => {\n\t  return path.split('/').length\n\t}\n\tconst asc = (a, b) => {\n\t  const depthA = getImportDepth(a.path)\n\t  const depthB = getImportDepth(b.path)\n\t  if (depthA !== depthB) {\n\t    return depthA - depthB\n", "  } else {\n\t    return a.path.localeCompare(b.path)\n\t  }\n\t}\n\tconst desc = (a, b) => {\n\t  const depthA = getImportDepth(a.path)\n\t  const depthB = getImportDepth(b.path)\n\t  if (depthA !== depthB) {\n\t    return depthB - depthA\n\t  } else {\n", "    return a.path.localeCompare(b.path)\n\t  }\n\t}\n\tconst sortLibraries = (imports: ImportData[]) => {\n\t  let result: ImportData[] = []\n\t  const groups = {}\n\t  for (const library of config.libs) {\n\t    groups[library.name] = []\n\t    for (let i = 0; i < imports.length; i++) {\n\t      const importData = imports[i]\n", "      if (\n\t        (library.rule === LibraryRule.EXACT && importData.path === library.name) ||\n\t        (library.rule === LibraryRule.STARTS && importData.path.startsWith(library.name)) ||\n\t        (library.rule === LibraryRule.INCLUDES && importData.path.includes(library.name))\n\t      ) {\n\t        groups[library.name].push(importData)\n\t        imports.splice(i, 1)\n\t        i--\n\t      }\n\t    }\n", "  }\n\t  for (const groupKey in groups) {\n\t    groups[groupKey].sort(asc)\n\t    result = [...result, ...groups[groupKey]]\n\t  }\n\t  imports.sort(asc)\n\t  result = [...result, ...imports]\n\t  return destructuringSort(result)\n\t}\n\tconst sortAliases = (imports: ImportData[]) => {\n", "  const sortedImports = imports.sort(asc)\n\t  return destructuringSort(sortedImports)\n\t}\n\tconst sortRelatives = (imports: ImportData[]) => {\n\t  const outFolderImports = []\n\t  const currentFolderImports = []\n\t  for (const importData of imports) {\n\t    if (importData.path.startsWith('./')) {\n\t      currentFolderImports.push(importData)\n\t    } else {\n", "      outFolderImports.push(importData)\n\t    }\n\t  }\n\t  outFolderImports.sort(desc)\n\t  currentFolderImports.sort(desc)\n\t  return destructuringSort(outFolderImports.concat(currentFolderImports))\n\t}\n\tconst destructuringSort = (imports: ImportData[]) => {\n\t  const result = []\n\t  for (const importData of imports) {\n", "    const searchResult = importData.raw.match(/\\{[\\s\\S]+?}/gm)\n\t    if (searchResult) {\n\t      const importElementsString = searchResult[0].replace(/[{}\\s]/gm, '')\n\t      const importElements = importElementsString\n\t        .split(',')\n\t        .filter((importElement) => importElement)\n\t      importElements.sort(function (a, b) {\n\t        if (a.length === b.length) {\n\t          return a.localeCompare(b)\n\t        } else {\n", "          return a.length - b.length\n\t        }\n\t      })\n\t      result.push({\n\t        raw: importData.raw.replace(/\\{[\\s\\S]+?}/gm, `{ ${importElements.join(',')} }`),\n\t        path: importData.path,\n\t      })\n\t    } else {\n\t      result.push(importData)\n\t    }\n", "  }\n\t  return result\n\t}\n\texport const sortImportGroups = (inputGroups: ImportGroups) => {\n\t  return {\n\t    libraries: sortLibraries(inputGroups.libraries),\n\t    aliases: sortAliases(inputGroups.aliases),\n\t    relatives: sortRelatives(inputGroups.relatives),\n\t    directRelatives: sortRelatives(inputGroups.directRelatives),\n\t  }\n", "}\n"]}
{"filename": "src/utils/index.ts", "chunked_list": ["export * from './split-imports-to-groups'\n\texport * from './sort-import-groups'\n\texport * from './prepare-code'\n"]}
{"filename": "src/utils/prepare-code.ts", "chunked_list": ["import { ImportGroups } from '../types'\n\texport const prepareCode = (importGroups: ImportGroups) => {\n\t  let result = ''\n\t  for (const importData of importGroups.libraries) {\n\t    result += `${importData.raw}\\n`\n\t  }\n\t  result += '\\n'\n\t  for (const importData of importGroups.aliases) {\n\t    result += `${importData.raw}\\n`\n\t  }\n", "  result += '\\n'\n\t  for (const importData of importGroups.relatives) {\n\t    result += `${importData.raw}\\n`\n\t  }\n\t  if (importGroups.directRelatives.length > 0) {\n\t    result += '\\n'\n\t    for (const importData of importGroups.directRelatives) {\n\t      result += `${importData.raw}\\n`\n\t    }\n\t  }\n", "  return result\n\t}\n"]}
