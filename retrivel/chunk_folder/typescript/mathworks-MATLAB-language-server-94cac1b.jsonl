{"filename": "src/server.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport { TextDocument } from 'vscode-languageserver-textdocument'\n\timport { ClientCapabilities, createConnection, InitializeParams, InitializeResult, ProposedFeatures, TextDocuments } from 'vscode-languageserver/node'\n\timport DocumentIndexer from './indexing/DocumentIndexer'\n\timport WorkspaceIndexer from './indexing/WorkspaceIndexer'\n\timport ConfigurationManager, { ConnectionTiming } from './lifecycle/ConfigurationManager'\n\timport MatlabLifecycleManager, { MatlabConnectionStatusParam } from './lifecycle/MatlabLifecycleManager'\n\timport Logger from './logging/Logger'\n\timport { Actions, reportTelemetryAction } from './logging/TelemetryUtils'\n\timport NotificationService, { Notification } from './notifications/NotificationService'\n", "import CompletionProvider from './providers/completion/CompletionSupportProvider'\n\timport FormatSupportProvider from './providers/formatting/FormatSupportProvider'\n\timport LintingSupportProvider from './providers/linting/LintingSupportProvider'\n\timport ExecuteCommandProvider, { MatlabLSCommands } from './providers/lspCommands/ExecuteCommandProvider'\n\timport NavigationSupportProvider, { RequestType } from './providers/navigation/NavigationSupportProvider'\n\t// Create a connection for the server\n\texport const connection = createConnection(ProposedFeatures.all)\n\t// Initialize Logger\n\tLogger.initialize(connection.console)\n\t// Create basic text document manager\n", "const documentManager: TextDocuments<TextDocument> = new TextDocuments(TextDocument)\n\tMatlabLifecycleManager.addMatlabLifecycleListener((error, lifecycleEvent) => {\n\t    if (error != null) {\n\t        Logger.error(`MATLAB Lifecycle Error: ${error.message}\\n${error.stack ?? ''}`)\n\t    }\n\t    if (lifecycleEvent.matlabStatus === 'connected') {\n\t        // Handle things after MATLAB® has launched\n\t        // Initiate workspace indexing\n\t        void WorkspaceIndexer.indexWorkspace()\n\t        documentManager.all().forEach(textDocument => {\n", "            void LintingSupportProvider.lintDocument(textDocument, connection)\n\t            void DocumentIndexer.indexDocument(textDocument)\n\t        })\n\t    }\n\t})\n\tlet capabilities: ClientCapabilities\n\t// Handles an initialization request\n\tconnection.onInitialize((params: InitializeParams) => {\n\t    capabilities = params.capabilities\n\t    // Defines the capabilities supported by this language server\n", "    const initResult: InitializeResult = {\n\t        capabilities: {\n\t            codeActionProvider: true,\n\t            completionProvider: {\n\t                triggerCharacters: [\n\t                    '.', // Struct/class properties, package names, etc.\n\t                    '(', // Function call\n\t                    ' ', // Command-style function call\n\t                    ',', // Function arguments\n\t                    '/', // File path\n", "                    '\\\\' // File path\n\t                ]\n\t            },\n\t            definitionProvider: true,\n\t            documentFormattingProvider: true,\n\t            executeCommandProvider: {\n\t                commands: Object.values(MatlabLSCommands)\n\t            },\n\t            referencesProvider: true,\n\t            signatureHelpProvider: {\n", "                triggerCharacters: ['(', ',']\n\t            },\n\t            documentSymbolProvider: true\n\t        }\n\t    }\n\t    return initResult\n\t})\n\t// Handles the initialized notification\n\tconnection.onInitialized(() => {\n\t    ConfigurationManager.setup(capabilities)\n", "    WorkspaceIndexer.setupCallbacks(capabilities)\n\t    void startMatlabIfOnStartLaunch()\n\t})\n\tasync function startMatlabIfOnStartLaunch (): Promise<void> {\n\t    // Launch MATLAB if it should be launched early\n\t    const connectionTiming = (await ConfigurationManager.getConfiguration()).matlabConnectionTiming\n\t    if (connectionTiming === ConnectionTiming.OnStart) {\n\t        void MatlabLifecycleManager.connectToMatlab(connection)\n\t    }\n\t}\n", "// Handles a shutdown request\n\tconnection.onShutdown(() => {\n\t    // Shut down MATLAB\n\t    MatlabLifecycleManager.disconnectFromMatlab()\n\t})\n\t// Set up connection notification listeners\n\tNotificationService.registerNotificationListener(\n\t    Notification.MatlabConnectionClientUpdate,\n\t    data => MatlabLifecycleManager.handleConnectionStatusChange(data as MatlabConnectionStatusParam)\n\t)\n", "// Handles files opened\n\tdocumentManager.onDidOpen(params => {\n\t    reportFileOpened(params.document)\n\t    void LintingSupportProvider.lintDocument(params.document, connection)\n\t    void DocumentIndexer.indexDocument(params.document)\n\t})\n\tdocumentManager.onDidClose(params => {\n\t    LintingSupportProvider.clearDiagnosticsForDocument(params.document)\n\t})\n\t// Handles files saved\n", "documentManager.onDidSave(params => {\n\t    void LintingSupportProvider.lintDocument(params.document, connection)\n\t})\n\t// Handles changes to the text document\n\tdocumentManager.onDidChangeContent(params => {\n\t    if (MatlabLifecycleManager.isMatlabReady()) {\n\t        // Only want to lint on content changes when linting is being backed by MATLAB\n\t        LintingSupportProvider.queueLintingForDocument(params.document, connection)\n\t        DocumentIndexer.queueIndexingForDocument(params.document)\n\t    }\n", "})\n\t// Handle execute command requests\n\tconnection.onExecuteCommand(params => {\n\t    void ExecuteCommandProvider.handleExecuteCommand(params, documentManager, connection)\n\t})\n\t/** -------------------- COMPLETION SUPPORT -------------------- **/\n\tconnection.onCompletion(async params => {\n\t    // Gather a list of possible completions to be displayed by the IDE\n\t    return await CompletionProvider.handleCompletionRequest(params, documentManager)\n\t})\n", "connection.onSignatureHelp(async params => {\n\t    // Gather a list of possible function signatures to be displayed by the IDE\n\t    return await CompletionProvider.handleSignatureHelpRequest(params, documentManager)\n\t})\n\t/** -------------------- FORMATTING SUPPORT -------------------- **/\n\tconnection.onDocumentFormatting(async params => {\n\t    // Gather a set of document edits required for formatting, which the IDE will execute\n\t    return await FormatSupportProvider.handleDocumentFormatRequest(params, documentManager)\n\t})\n\t/** --------------------  LINTING SUPPORT   -------------------- **/\n", "connection.onCodeAction(params => {\n\t    // Retrieve a list of possible code actions to be displayed by the IDE\n\t    return LintingSupportProvider.handleCodeActionRequest(params)\n\t})\n\t/** --------------------  NAVIGATION SUPPORT   -------------------- **/\n\tconnection.onDefinition(async params => {\n\t    return await NavigationSupportProvider.handleDefOrRefRequest(params, documentManager, RequestType.Definition)\n\t})\n\tconnection.onReferences(async params => {\n\t    return await NavigationSupportProvider.handleDefOrRefRequest(params, documentManager, RequestType.References)\n", "})\n\tconnection.onDocumentSymbol(async params => {\n\t    return await NavigationSupportProvider.handleDocumentSymbol(params, documentManager, RequestType.DocumentSymbol)\n\t})\n\t// Start listening to open/change/close text document events\n\tdocumentManager.listen(connection)\n\t/** -------------------- Helper Functions -------------------- **/\n\tfunction reportFileOpened (document: TextDocument): void {\n\t    const roughSize = Math.ceil(document.getText().length / 1024) // in KB\n\t    reportTelemetryAction(Actions.OpenFile, roughSize.toString())\n", "}\n"]}
{"filename": "src/index.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\t// Start up the LSP server\n\timport { connection } from './server'\n\t// Listen on the connection\n\tconnection.listen()\n"]}
{"filename": "src/utils/PositionUtils.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport { Position } from 'vscode-languageserver'\n\t/**\n\t * Determines whether a position is less than another position.\n\t *\n\t * @param a The first position\n\t * @param b The second position\n\t * @returns true if position A is before position B\n\t */\n\texport function isPositionLessThan (a: Position, b: Position): boolean {\n", "    return checkLessThan(a, b)\n\t}\n\t/**\n\t * Determines whether a position is less than or equal to another position.\n\t *\n\t * @param a The first position\n\t * @param b The second position\n\t * @returns true if position A is before position B, or the same position\n\t */\n\texport function isPositionLessThanOrEqualTo (a: Position, b: Position): boolean {\n", "    return checkLessThan(a, b, true)\n\t}\n\t/**\n\t * Determines whether a position is greater than another position.\n\t *\n\t * @param a The first position\n\t * @param b The second position\n\t * @returns True if position A is after position B\n\t */\n\texport function isPositionGreaterThan (a: Position, b: Position): boolean {\n", "    return checkGreaterThan(a, b)\n\t}\n\t/**\n\t * Determines whether a position is greater than or equal to another position.\n\t *\n\t * @param a The first position\n\t * @param b The second position\n\t * @returns True if position A is after position B, or the same position\n\t */\n\texport function isPositionGreaterThanOrEqualTo (a: Position, b: Position): boolean {\n", "    return checkGreaterThan(a, b, true)\n\t}\n\t/**\n\t * Performs a \"less than (or equal to)\" check on two positions.\n\t *\n\t * @param a The first position\n\t * @param b The second position\n\t * @param orEqual Whether or not an \"or equal to\" check should be performed\n\t * @returns true if position A is before position B\n\t */\n", "function checkLessThan (a: Position, b: Position, orEqual = false): boolean {\n\t    if (a.line < b.line) {\n\t        return true\n\t    }\n\t    if (a.line === b.line) {\n\t        return orEqual\n\t            ? a.character <= b.character\n\t            : a.character < b.character\n\t    }\n\t    return false\n", "}\n\t/**\n\t * Performs a \"greater than (or equal to)\" check on two positions.\n\t *\n\t * @param a The first position\n\t * @param b The second position\n\t * @param orEqual Whether or not an \"or equal to\" check should be performed\n\t * @returns true if position A is after position B\n\t */\n\tfunction checkGreaterThan (a: Position, b: Position, orEqual = false): boolean {\n", "    if (a.line > b.line) {\n\t        return true\n\t    }\n\t    if (a.line === b.line) {\n\t        return orEqual\n\t            ? a.character >= b.character\n\t            : a.character > b.character\n\t    }\n\t    return false\n\t}\n"]}
{"filename": "src/utils/TextDocumentUtils.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport { Range } from 'vscode-languageserver'\n\timport { TextDocument } from 'vscode-languageserver-textdocument'\n\t/**\n\t * Gets a Range within a text document from the given line/column position to\n\t * the end of the provided line.\n\t *\n\t * @param doc The text document\n\t * @param line The line number\n\t * @param char The character number on the line\n", " * @returns A range\n\t */\n\texport function getRangeUntilLineEnd (doc: TextDocument, line: number, char: number): Range {\n\t    const lineText = getTextOnLine(doc, line)\n\t    return Range.create(line, char, line, lineText.length)\n\t}\n\t/**\n\t * Gets the text on the given line of the document.\n\t *\n\t * @param doc The text document\n", " * @param line The line number\n\t * @returns The text on the line\n\t */\n\texport function getTextOnLine (doc: TextDocument, line: number): string {\n\t    return doc.getText().split('\\n')[line]\n\t}\n"]}
{"filename": "src/utils/CliUtils.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport * as yargs from 'yargs'\n\timport { Argument } from '../lifecycle/ConfigurationManager'\n\texport interface CliArgs {\n\t    [Argument.MatlabLaunchCommandArguments]?: string\n\t    [Argument.MatlabInstallationPath]?: string\n\t    [Argument.MatlabConnectionTiming]?: string\n\t    [Argument.ShouldIndexWorkspace]?: boolean\n\t    [Argument.MatlabUrl]?: string\n\t}\n", "/**\n\t * Creates a yargs parser to extract command line arguments.\n\t *\n\t * @returns The parsed command line arguments\n\t */\n\tfunction makeParser (): yargs.Argv<CliArgs> {\n\t    const argParser = yargs.option(Argument.MatlabLaunchCommandArguments, {\n\t        description: 'Arguments passed to MATLAB when launching',\n\t        type: 'string',\n\t        requiresArg: true\n", "    }).option(Argument.MatlabInstallationPath, {\n\t        description: 'The full path to the top-level directory of the MATLAB installation. If not specified, the environment path will be checked for the location of the `matlab` executable.',\n\t        type: 'string',\n\t        default: ''\n\t    }).option(Argument.MatlabConnectionTiming, {\n\t        description: 'When the language server should attempt to connect to MATLAB.',\n\t        type: 'string',\n\t        default: 'onStart',\n\t        choices: ['onStart', 'onDemand', 'never']\n\t    }).option(Argument.ShouldIndexWorkspace, {\n", "        boolean: true,\n\t        default: false,\n\t        description: 'Whether or not the user\\'s workspace should be indexed.',\n\t        requiresArg: false\n\t    }).option(Argument.MatlabUrl, {\n\t        type: 'string',\n\t        description: 'URL for communicating with an existing MATLAB instance',\n\t        requiresArg: true\n\t    }).usage(\n\t        'Usage: $0 {--node-ipc | --stdio | --socket=socket} options\\n' +\n", "        '\\n' +\n\t        '\\tAn LSP server for MATLAB. This is meant to be invoked from an editor or IDE.\\n'\n\t    ).group(\n\t        ['node-ipc', 'stdio', 'socket'],\n\t        'Required IPC flag'\n\t    ).option('node-ipc', {\n\t        description: 'Use Node IPC'\n\t    }).option('stdio', {\n\t        description: 'Use stdio for IPC'\n\t    }).option('socket', {\n", "        description: 'Use specified socket for IPC',\n\t        requiresArg: true\n\t    }).help('help').alias('h', 'help')\n\t    return argParser\n\t}\n\t/**\n\t * Parse the command line arguments.\n\t *\n\t * @param args If provided, these are the arguments to parse. Otherwise, the true\n\t * command line arguments will be parsed. This is primarily meant for testing.\n", " * @returns The parsed CLI arguments\n\t */\n\texport function getCliArgs (args?: string[]): CliArgs {\n\t    const cliParser = makeParser()\n\t    return (args != null) ? cliParser.parseSync(args) : cliParser.parseSync()\n\t}\n"]}
{"filename": "src/logging/TelemetryUtils.ts", "chunked_list": ["// Copyright 2023 The MathWorks, Inc.\n\timport NotificationService, { Notification } from '../notifications/NotificationService'\n\tenum EventKeys {\n\t    Action = 'ACTIONS',\n\t    SettingChange = 'SETTING_CHANGE'\n\t}\n\texport enum Actions {\n\t    OpenFile = 'openFile',\n\t    StartMatlab = 'startMATLAB',\n\t    ShutdownMatlab = 'shutdownMATLAB',\n", "    FormatDocument = 'formatDocument',\n\t    GoToReference = 'goToReference',\n\t    GoToDefinition = 'goToDefinition',\n\t    DocumentSymbol = 'documentSymbol'\n\t}\n\texport enum ActionErrorConditions {\n\t    MatlabUnavailable = 'MATLAB unavailable'\n\t}\n\t/**\n\t * Reports a telemetry event to the client\n", " *\n\t * @param eventKey The event key\n\t * @param data The event's data\n\t */\n\tfunction reportTelemetry (eventKey: string, data: unknown): void {\n\t    NotificationService.sendNotification(Notification.LogTelemetryData, {\n\t        eventKey,\n\t        data\n\t    })\n\t}\n", "/**\n\t * Reports telemetry about a simple action\n\t *\n\t * @param actionType The action's type\n\t * @param data The action's data\n\t */\n\texport function reportTelemetryAction (actionType: string, data = ''): void {\n\t    reportTelemetry(EventKeys.Action, {\n\t        action_type: actionType,\n\t        result: data\n", "    })\n\t}\n\t/**\n\t * Reports telemetry about a settings change\n\t *\n\t * @param settingName The setting's name\n\t * @param newValue The new value\n\t * @param oldValue The old value\n\t */\n\texport function reportTelemetrySettingsChange (settingName: string, newValue: string, oldValue: string): void {\n", "    reportTelemetry(EventKeys.SettingChange, {\n\t        setting_name: settingName,\n\t        new_value: newValue,\n\t        old_value: oldValue\n\t    })\n\t}\n"]}
{"filename": "src/logging/Logger.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport * as fs from 'fs'\n\timport * as os from 'os'\n\timport * as path from 'path'\n\timport { RemoteConsole } from 'vscode-languageserver'\n\tconst SERVER_LOG = 'languageServerLog.txt'\n\tconst MATLAB_LOG = 'matlabLog.txt'\n\tclass Logger {\n\t    private readonly _logDir: string\n\t    private readonly languageServerLogFile: string\n", "    private readonly matlabLogFile: string\n\t    private _console: RemoteConsole | null = null\n\t    constructor () {\n\t        // Create Log Directory\n\t        const pid = process.pid\n\t        this._logDir = path.join(os.tmpdir(), `matlabls_${pid}`)\n\t        if (fs.existsSync(this._logDir)) {\n\t            let i = 1\n\t            while (fs.existsSync(`${this._logDir}_${i}`)) { i++ }\n\t            this._logDir = `${this._logDir}_${i}`\n", "        }\n\t        fs.mkdirSync(this._logDir)\n\t        // Get name of log file\n\t        this.languageServerLogFile = path.join(this._logDir, SERVER_LOG)\n\t        this.matlabLogFile = path.join(this._logDir, MATLAB_LOG)\n\t    }\n\t    /**\n\t     * Initializes the logger with an output console.\n\t     *\n\t     * @param console The console which the Logger should output to\n", "     */\n\t    initialize (console: RemoteConsole): void {\n\t        this._console = console\n\t        this.log(`Log Directory: ${this._logDir}`)\n\t    }\n\t    /**\n\t     * Logs an informational message to both the console and the log file.\n\t     *\n\t     * @param message The message\n\t     */\n", "    log (message: string): void {\n\t        const msg = `(${getCurrentTimeString()}) matlabls: ${message}`\n\t        this._console?.log(msg)\n\t        this._writeToLogFile(msg, this.languageServerLogFile)\n\t    }\n\t    /**\n\t     * Logs a warning message to both the console and the log file.\n\t     *\n\t     * @param message The warning message\n\t     */\n", "    warn (message: string): void {\n\t        const msg = `(${getCurrentTimeString()}) matlabls - WARNING: ${message}`\n\t        this._console?.warn(msg)\n\t        this._writeToLogFile(msg, this.languageServerLogFile)\n\t    }\n\t    /**\n\t     * Logs an error message to both the console and the log file.\n\t     *\n\t     * @param message The error message\n\t     */\n", "    error (message: string): void {\n\t        const msg = `(${getCurrentTimeString()}) matlabls - ERROR: ${message}`\n\t        this._console?.error(msg)\n\t        this._writeToLogFile(msg, this.languageServerLogFile)\n\t    }\n\t    /**\n\t     * Log MATLAB application output to a log file on disk, separate from\n\t     * the language server logs.\n\t     *\n\t     * @param message The message\n", "     */\n\t    writeMatlabLog (message: string): void {\n\t        this._writeToLogFile(message, this.matlabLogFile)\n\t    }\n\t    public get logDir (): string {\n\t        return this._logDir\n\t    }\n\t    private _writeToLogFile (message: string, filePath: string): void {\n\t        // Log to file\n\t        fs.writeFile(\n", "            filePath,\n\t            `${message}\\n`,\n\t            { flag: 'a+' },\n\t            err => {\n\t                if (err !== null) {\n\t                    this._console?.error('Failed to write to log file')\n\t                }\n\t            }\n\t        )\n\t    }\n", "}\n\tfunction getCurrentTimeString (): string {\n\t    const d = new Date()\n\t    const strFormatter = (x: number): string => x.toString().padStart(2, '0')\n\t    return `${strFormatter(d.getHours())}:${strFormatter(d.getMinutes())}:${strFormatter(d.getSeconds())}`\n\t}\n\texport default new Logger()\n"]}
{"filename": "src/indexing/Indexer.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport { TextDocument } from 'vscode-languageserver-textdocument'\n\timport { URI } from 'vscode-uri'\n\timport { MatlabConnection } from '../lifecycle/MatlabCommunicationManager'\n\timport MatlabLifecycleManager from '../lifecycle/MatlabLifecycleManager'\n\timport FileInfoIndex, { MatlabCodeData, RawCodeData } from './FileInfoIndex'\n\timport * as fs from 'fs/promises'\n\timport PathResolver from '../providers/navigation/PathResolver'\n\tinterface WorkspaceFileIndexedResponse {\n\t    isDone: boolean\n", "    filePath: string\n\t    codeData: RawCodeData\n\t}\n\tclass Indexer {\n\t    private readonly INDEX_DOCUMENT_REQUEST_CHANNEL = '/matlabls/indexDocument/request'\n\t    private readonly INDEX_DOCUMENT_RESPONSE_CHANNEL = '/matlabls/indexDocument/response/' // Needs to be appended with requestId\n\t    private readonly INDEX_FOLDERS_REQUEST_CHANNEL = '/matlabls/indexFolders/request'\n\t    private readonly INDEX_FOLDERS_RESPONSE_CHANNEL = '/matlabls/indexFolders/response/' // Needs to be appended with requestId\n\t    private requestCt = 1\n\t    /**\n", "     * Indexes the given TextDocument and caches the data.\n\t     *\n\t     * @param textDocument The document being indexed\n\t     */\n\t    async indexDocument (textDocument: TextDocument): Promise<void> {\n\t        const matlabConnection = MatlabLifecycleManager.getMatlabConnection()\n\t        if (matlabConnection == null || !MatlabLifecycleManager.isMatlabReady()) {\n\t            return\n\t        }\n\t        const rawCodeData = await this.getCodeData(textDocument.getText(), textDocument.uri, matlabConnection)\n", "        const parsedCodeData = FileInfoIndex.parseAndStoreCodeData(textDocument.uri, rawCodeData)\n\t        void this.indexAdditionalClassData(parsedCodeData, matlabConnection, textDocument.uri)\n\t    }\n\t    /**\n\t     * Indexes all M files within the given list of folders.\n\t     *\n\t     * @param folders A list of folder URIs to be indexed\n\t     */\n\t    indexFolders (folders: string[]): void {\n\t        const matlabConnection = MatlabLifecycleManager.getMatlabConnection()\n", "        if (matlabConnection == null || !MatlabLifecycleManager.isMatlabReady()) {\n\t            return\n\t        }\n\t        const requestId = this.requestCt++\n\t        const responseSub = matlabConnection.subscribe(`${this.INDEX_FOLDERS_RESPONSE_CHANNEL}${requestId}`, message => {\n\t            const fileResults = message as WorkspaceFileIndexedResponse\n\t            if (fileResults.isDone) {\n\t                // No more files being indexed - safe to unsubscribe\n\t                matlabConnection.unsubscribe(responseSub)\n\t            }\n", "            // Convert file path to URI, which is used as an index when storing the code data\n\t            const fileUri = URI.file(fileResults.filePath).toString()\n\t            FileInfoIndex.parseAndStoreCodeData(fileUri, fileResults.codeData)\n\t        })\n\t        matlabConnection.publish(this.INDEX_FOLDERS_REQUEST_CHANNEL, {\n\t            folders,\n\t            requestId\n\t        })\n\t    }\n\t    /**\n", "     * Indexes the file for the given URI and caches the data.\n\t     *\n\t     * @param uri The URI for the file being indexed\n\t     */\n\t    async indexFile (uri: string): Promise<void> {\n\t        const matlabConnection = MatlabLifecycleManager.getMatlabConnection()\n\t        if (matlabConnection == null || !MatlabLifecycleManager.isMatlabReady()) {\n\t            return\n\t        }\n\t        const fileContentBuffer = await fs.readFile(URI.parse(uri).fsPath)\n", "        const code = fileContentBuffer.toString()\n\t        const rawCodeData = await this.getCodeData(code, uri, matlabConnection)\n\t        FileInfoIndex.parseAndStoreCodeData(uri, rawCodeData)\n\t    }\n\t    /**\n\t     * Retrieves data about classes, functions, and variables from the given document.\n\t     *\n\t     * @param code The code being parsed\n\t     * @param uri The URI associated with the code\n\t     * @param matlabConnection The connection to MATLAB®\n", "     *\n\t     * @returns The raw data extracted from the document\n\t     */\n\t    private async getCodeData (code: string, uri: string, matlabConnection: MatlabConnection): Promise<RawCodeData> {\n\t        const filePath = URI.parse(uri).fsPath\n\t        return await new Promise(resolve => {\n\t            const requestId = this.requestCt++\n\t            const responseSub = matlabConnection.subscribe(`${this.INDEX_DOCUMENT_RESPONSE_CHANNEL}${requestId}`, message => {\n\t                matlabConnection.unsubscribe(responseSub)\n\t                resolve(message as RawCodeData)\n", "            })\n\t            matlabConnection.publish(this.INDEX_DOCUMENT_REQUEST_CHANNEL, {\n\t                code,\n\t                filePath,\n\t                requestId\n\t            })\n\t        })\n\t    }\n\t    /**\n\t     * Indexes any supplemental files if the parsed code data represents a class.\n", "     * This will index any other files in a @ directory, as well as any direct base classes.\n\t     *\n\t     * @param parsedCodeData The parsed code data\n\t     * @param matlabConnection The connection to MATLAB\n\t     * @param uri The document's URI\n\t     */\n\t    private async indexAdditionalClassData (parsedCodeData: MatlabCodeData, matlabConnection: MatlabConnection, uri: string): Promise<void> {\n\t        if (parsedCodeData.classInfo == null) {\n\t            return\n\t        }\n", "        // Queue indexing for other files in @ class directory\n\t        const classDefFolder = parsedCodeData.classInfo.classDefFolder\n\t        if (classDefFolder !== '') {\n\t            this.indexFolders([classDefFolder])\n\t        }\n\t        // Find and queue indexing for parent classes\n\t        const baseClasses = parsedCodeData.classInfo.baseClasses\n\t        const resolvedBaseClasses = await PathResolver.resolvePaths(baseClasses, uri, matlabConnection)\n\t        resolvedBaseClasses.forEach(resolvedBaseClass => {\n\t            const uri = resolvedBaseClass.uri\n", "            if (uri !== '') {\n\t                void this.indexFile(uri)\n\t            }\n\t        })\n\t    }\n\t}\n\texport default new Indexer()\n"]}
{"filename": "src/indexing/FileInfoIndex.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport { Position, Range } from 'vscode-languageserver'\n\timport { isPositionGreaterThan, isPositionLessThanOrEqualTo } from '../utils/PositionUtils'\n\t/**\n\t * Defines the structure of the raw data retrieved from MATLAB®.\n\t */\n\texport interface RawCodeData {\n\t    classInfo: CodeDataClassInfo\n\t    functionInfo: CodeDataFunctionInfo[]\n\t    packageName: string\n", "    references: CodeDataReference[]\n\t}\n\t/**\n\t * Contains raw information about the file's class data\n\t */\n\tinterface CodeDataClassInfo {\n\t    isClassDef: boolean // Whether or not the file represents a class definition\n\t    hasClassInfo: boolean // Whether or not the file contains data related to a class (could be a class definition, or within a classdef folder)\n\t    name: string\n\t    range: CodeDataRange\n", "    declaration: CodeDataRange\n\t    properties: CodeDataMemberInfo[]\n\t    enumerations: CodeDataMemberInfo[]\n\t    classDefFolder: string\n\t    baseClasses: string[]\n\t}\n\t/**\n\t * Contains raw information about a function\n\t */\n\tinterface CodeDataFunctionInfo {\n", "    name: string\n\t    range: CodeDataRange\n\t    parentClass: string\n\t    isPublic: boolean\n\t    declaration?: CodeDataRange // Will be undefined if function is prototype\n\t    variableInfo: CodeDataFunctionVariableInfo\n\t    globals: string[]\n\t    isPrototype: boolean\n\t}\n\t/**\n", " * Contains raw information about variables within a function\n\t */\n\tinterface CodeDataFunctionVariableInfo {\n\t    definitions: CodeDataReference[]\n\t    references: CodeDataReference[]\n\t}\n\t/**\n\t * Represents a reference to a variable or function. The first element is the\n\t * name of the variable. The second element is the range of that reference.\n\t */\n", "type CodeDataReference = [string, CodeDataRange]\n\t/**\n\t * Represents members of a class (e.g. Properties or Enumerations)\n\t */\n\tinterface CodeDataMemberInfo {\n\t    name: string\n\t    range: CodeDataRange\n\t    parentClass: string\n\t    isPublic: boolean\n\t}\n", "/**\n\t * Represents a range in the document.\n\t * Line and column values are 1-based.\n\t */\n\tinterface CodeDataRange {\n\t    lineStart: number\n\t    charStart: number\n\t    lineEnd: number\n\t    charEnd: number\n\t}\n", "export enum FunctionVisibility {\n\t    Public,\n\t    Private\n\t}\n\t/**\n\t * Serves as an cache of data extracted from files\n\t */\n\tclass FileInfoIndex {\n\t    /**\n\t     * Maps document URI to the code data\n", "     */\n\t    readonly codeDataCache = new Map<string, MatlabCodeData>()\n\t    /**\n\t     * Maps class name to class info\n\t     */\n\t    readonly classInfoCache = new Map<string, MatlabClassInfo>()\n\t    /**\n\t     * Parses the raw data into a more usable form. Caches the resulting data\n\t     * in the code data index.\n\t     *\n", "     * @param uri The uri of the document from which the data was extracted\n\t     * @param rawCodeData The raw data\n\t     * @returns An object containing the parsed data\n\t     */\n\t    parseAndStoreCodeData (uri: string, rawCodeData: RawCodeData): MatlabCodeData {\n\t        let parsedCodeData: MatlabCodeData\n\t        if (rawCodeData.classInfo.hasClassInfo) {\n\t            let classInfo = this.classInfoCache.get(rawCodeData.classInfo.name)\n\t            if (classInfo == null) {\n\t                // Class not discovered yet - need to create info object\n", "                classInfo = new MatlabClassInfo(rawCodeData.classInfo, uri)\n\t                this.classInfoCache.set(classInfo.name, classInfo)\n\t            } else {\n\t                // Class already known - update data\n\t                classInfo.appendClassData(rawCodeData.classInfo, uri)\n\t            }\n\t            parsedCodeData = new MatlabCodeData(uri, rawCodeData, classInfo)\n\t        } else {\n\t            parsedCodeData = new MatlabCodeData(uri, rawCodeData)\n\t        }\n", "        // Store in cache\n\t        this.codeDataCache.set(uri, parsedCodeData)\n\t        return parsedCodeData\n\t    }\n\t}\n\t/**\n\t * Class to contain info about a class\n\t */\n\texport class MatlabClassInfo {\n\t    readonly methods: Map<string, MatlabFunctionInfo>\n", "    readonly properties: Map<string, MatlabClassMemberInfo>\n\t    readonly enumerations: Map<string, MatlabClassMemberInfo>\n\t    readonly name: string\n\t    baseClasses: string[]\n\t    readonly classDefFolder: string\n\t    range?: Range\n\t    declaration?: Range\n\t    constructor (rawClassInfo: CodeDataClassInfo, public uri?: string) {\n\t        this.methods = new Map<string, MatlabFunctionInfo>()\n\t        this.properties = new Map<string, MatlabClassMemberInfo>()\n", "        this.enumerations = new Map<string, MatlabClassMemberInfo>()\n\t        this.name = rawClassInfo.name\n\t        this.baseClasses = rawClassInfo.baseClasses\n\t        this.classDefFolder = rawClassInfo.classDefFolder\n\t        if (rawClassInfo.isClassDef) {\n\t            this.range = convertRange(rawClassInfo.range)\n\t            this.declaration = convertRange(rawClassInfo.declaration)\n\t        }\n\t        this.parsePropertiesAndEnums(rawClassInfo)\n\t    }\n", "    /**\n\t     * Appends the new data to the existing class data.\n\t     *\n\t     * Specifically, when the new data represents the classdef file, information about\n\t     * the URI, base classes, and range/declaration are added to the existing data.\n\t     *\n\t     * @param rawClassInfo The raw class data being appended\n\t     * @param uri The document URI corresponding to the class data\n\t     */\n\t    appendClassData (rawClassInfo: CodeDataClassInfo, uri?: string): void {\n", "        if (rawClassInfo.isClassDef) {\n\t            // Data contains class definition\n\t            this.uri = uri\n\t            this.baseClasses = rawClassInfo.baseClasses\n\t            this.range = convertRange(rawClassInfo.range)\n\t            this.declaration = convertRange(rawClassInfo.declaration)\n\t            // Since this is the classdef, we'll update all members. Clear them out here.\n\t            this.enumerations.clear()\n\t            this.properties.clear()\n\t            this.methods.clear()\n", "            this.parsePropertiesAndEnums(rawClassInfo)\n\t        } else {\n\t            // Data contains supplementary class info - nothing to do in this situation\n\t        }\n\t    }\n\t    /**\n\t     * Appends info about a method to the class's info.\n\t     *\n\t     * This will not replace info about a method's implementation with info about a method prototype.\n\t     *\n", "     * @param functionInfo The method's information\n\t     */\n\t    addMethod (functionInfo: MatlabFunctionInfo): void {\n\t        // Only store the method if a non-prototype version of it is not\n\t        // already stored, as that will contain better information.\n\t        const name = functionInfo.name\n\t        const shouldStoreMethod = !functionInfo.isPrototype || (this.methods.get(name)?.isPrototype ?? true)\n\t        if (shouldStoreMethod) {\n\t            this.methods.set(name, functionInfo)\n\t        }\n", "    }\n\t    /**\n\t     * Parses information about the class's properties and enums from the raw data.\n\t     *\n\t     * @param rawClassInfo The raw class info\n\t     */\n\t    private parsePropertiesAndEnums (rawClassInfo: CodeDataClassInfo): void {\n\t        rawClassInfo.properties.forEach(propertyInfo => {\n\t            const name = propertyInfo.name\n\t            this.properties.set(name, new MatlabClassMemberInfo(propertyInfo))\n", "        })\n\t        rawClassInfo.enumerations.forEach(enumerationInfo => {\n\t            const name = enumerationInfo.name\n\t            this.enumerations.set(name, new MatlabClassMemberInfo(enumerationInfo))\n\t        })\n\t    }\n\t}\n\t/**\n\t * Class to contain info about members of a class (e.g. Properties or Enumerations)\n\t */\n", "export class MatlabClassMemberInfo {\n\t    readonly name: string\n\t    readonly range: Range\n\t    readonly parentClass: string\n\t    constructor (rawPropertyInfo: CodeDataMemberInfo) {\n\t        this.name = rawPropertyInfo.name\n\t        this.range = convertRange(rawPropertyInfo.range)\n\t        this.parentClass = rawPropertyInfo.parentClass\n\t    }\n\t}\n", "/**\n\t * Class to contain info about functions\n\t */\n\texport class MatlabFunctionInfo {\n\t    name: string\n\t    range: Range\n\t    declaration: Range | null\n\t    isPrototype: boolean\n\t    parentClass: string\n\t    isClassMethod: boolean\n", "    visibility: FunctionVisibility\n\t    variableInfo: Map<string, MatlabVariableInfo>\n\t    constructor (rawFunctionInfo: CodeDataFunctionInfo, public uri: string) {\n\t        this.name = rawFunctionInfo.name\n\t        this.range = convertRange(rawFunctionInfo.range)\n\t        this.declaration = rawFunctionInfo.declaration != null ? convertRange(rawFunctionInfo.declaration) : null\n\t        this.isPrototype = rawFunctionInfo.isPrototype\n\t        this.parentClass = rawFunctionInfo.parentClass\n\t        this.isClassMethod = this.parentClass !== ''\n\t        this.visibility = rawFunctionInfo.isPublic ? FunctionVisibility.Public : FunctionVisibility.Private\n", "        this.variableInfo = new Map<string, MatlabVariableInfo>()\n\t        this.parseVariableInfo(rawFunctionInfo)\n\t    }\n\t    /**\n\t     * Parses information about variables within the function from the raw data.\n\t     *\n\t     * @param rawFunctionInfo The raw function info\n\t     */\n\t    private parseVariableInfo (rawFunctionInfo: CodeDataFunctionInfo): void {\n\t        const variableInfo = rawFunctionInfo.variableInfo\n", "        const globals = rawFunctionInfo.globals\n\t        variableInfo.definitions.forEach(varDefinition => {\n\t            const name = varDefinition[0]\n\t            const range = convertRange(varDefinition[1])\n\t            const varInfo = this.getOrCreateVariableInfo(name, globals)\n\t            varInfo.addDefinition(range)\n\t        })\n\t        variableInfo.references.forEach(varReference => {\n\t            const name = varReference[0]\n\t            const range = convertRange(varReference[1])\n", "            const varInfo = this.getOrCreateVariableInfo(name, globals)\n\t            varInfo.addReference(range)\n\t        })\n\t    }\n\t    /**\n\t     * Attempts to retrieve an existing MatlabVariableInfo object for the requested variable.\n\t     * Creates a new instance if one does not already exist.\n\t     *\n\t     * @param name The variable's name\n\t     * @param globals The list of global variables\n", "     * @returns The MatlabVariableInfo object for the variable\n\t     */\n\t    private getOrCreateVariableInfo (name: string, globals: string[]): MatlabVariableInfo {\n\t        let variableInfo = this.variableInfo.get(name)\n\t        if (variableInfo == null) {\n\t            const isGlobal = globals.includes(name)\n\t            variableInfo = new MatlabVariableInfo(name, isGlobal)\n\t            this.variableInfo.set(name, variableInfo)\n\t        }\n\t        return variableInfo\n", "    }\n\t}\n\t/**\n\t * Class to contain info about variables\n\t */\n\tclass MatlabVariableInfo {\n\t    readonly definitions: Range[] = []\n\t    readonly references: Range[] = []\n\t    constructor (public name: string, public isGlobal: boolean) {}\n\t    /**\n", "     * Add a definition for the variable\n\t     *\n\t     * @param range The range of the definition\n\t     */\n\t    addDefinition (range: Range): void {\n\t        this.definitions.push(range)\n\t    }\n\t    /**\n\t     * Add a reference for the variable\n\t     *\n", "     * @param range The range of the reference\n\t     */\n\t    addReference (range: Range): void {\n\t        this.references.push(range)\n\t    }\n\t}\n\t/**\n\t * Class to contain info about an entire file\n\t */\n\texport class MatlabCodeData {\n", "    readonly functions: Map<string, MatlabFunctionInfo>\n\t    readonly references: Map<string, Range[]>\n\t    readonly packageName: string\n\t    constructor (public uri: string, rawCodeData: RawCodeData, public classInfo?: MatlabClassInfo) {\n\t        this.functions = new Map<string, MatlabFunctionInfo>()\n\t        this.references = new Map<string, Range[]>()\n\t        this.packageName = rawCodeData.packageName\n\t        this.parseFunctions(rawCodeData.functionInfo)\n\t        this.parseReferences(rawCodeData.references)\n\t    }\n", "    /**\n\t     * Whether or not the code data represents a class definition\n\t     */\n\t    get isClassDef (): boolean {\n\t        return this.classInfo != null\n\t    }\n\t    /**\n\t     * Whether or not the code data represents a main classdef file.\n\t     * For @aclass/aclass.m this returns true\n\t     * For @aclass/amethod.m this returns false.\n", "     */\n\t    get isMainClassDefDocument (): boolean {\n\t        return this.isClassDef && this.uri === this.classInfo?.uri\n\t    }\n\t    /**\n\t     * Finds the info for the function containing the given position.\n\t     *\n\t     * @param position A position in the document\n\t     * @returns The info for the function containing the position, or null if no function contains that position.\n\t     */\n", "    findContainingFunction (position: Position): MatlabFunctionInfo | null {\n\t        let containingFunction: MatlabFunctionInfo | null = null\n\t        for (const functionInfo of this.functions.values()) {\n\t            const start = functionInfo.range.start\n\t            const end = functionInfo.range.end\n\t            // Check if position is within range\n\t            if (isPositionLessThanOrEqualTo(start, position) && isPositionGreaterThan(end, position)) {\n\t                if (containingFunction == null) {\n\t                    containingFunction = functionInfo\n\t                } else {\n", "                    // Prefer a narrower function if we already have a match (e.g. nested functions)\n\t                    if (isPositionGreaterThan(start, containingFunction.range.start)) {\n\t                        containingFunction = functionInfo\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return containingFunction\n\t    }\n\t    /**\n", "     * Parses information about the file's functions.\n\t     *\n\t     * @param functionInfos The raw information about the functions in the file\n\t     */\n\t    private parseFunctions (functionInfos: CodeDataFunctionInfo[]): void {\n\t        functionInfos.forEach(functionInfo => {\n\t            const fcnInfo = new MatlabFunctionInfo(functionInfo, this.uri)\n\t            this.functions.set(fcnInfo.name, fcnInfo)\n\t            if (fcnInfo.isClassMethod) {\n\t                // Store the function info with the class as well\n", "                this.classInfo?.addMethod(fcnInfo)\n\t            }\n\t        })\n\t    }\n\t    /**\n\t     * Parses information about the file's variable and function references.\n\t     *\n\t     * @param references The raw information about the references in the file\n\t     */\n\t    private parseReferences (references: CodeDataReference[]): void {\n", "        references.forEach(reference => {\n\t            const funcName = reference[0]\n\t            const range = convertRange(reference[1])\n\t            if (!this.references.has(funcName)) {\n\t                // First time seeing this reference\n\t                this.references.set(funcName, [range])\n\t            } else {\n\t                this.references.get(funcName)?.push(range)\n\t            }\n\t        })\n", "    }\n\t}\n\t/**\n\t * Converts from a CodeDataRange to a Range as expected by the language server APIs.\n\t *\n\t * @param codeDataRange The CodeDataRange\n\t * @returns A Range corresponding to the inputted range\n\t */\n\tfunction convertRange (codeDataRange: CodeDataRange): Range {\n\t    // When converting, need to change value from 1-based to 0-based\n", "    return Range.create(\n\t        codeDataRange.lineStart - 1,\n\t        codeDataRange.charStart - 1,\n\t        codeDataRange.lineEnd - 1,\n\t        codeDataRange.charEnd - 1\n\t    )\n\t}\n\texport default new FileInfoIndex()\n"]}
{"filename": "src/indexing/WorkspaceIndexer.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport { ClientCapabilities, WorkspaceFolder, WorkspaceFoldersChangeEvent } from 'vscode-languageserver'\n\timport ConfigurationManager from '../lifecycle/ConfigurationManager'\n\timport { connection } from '../server'\n\timport Indexer from './Indexer'\n\t/**\n\t * Handles indexing files in the user's workspace to gather data about classes,\n\t * functions, and variables.\n\t */\n\tclass WorkspaceIndexer {\n", "    private isWorkspaceIndexingSupported = false\n\t    /**\n\t     * Sets up workspace change listeners, if supported.\n\t     *\n\t     * @param capabilities The client capabilities, which contains information about\n\t     * whether the client supports workspaces.\n\t     */\n\t    setupCallbacks (capabilities: ClientCapabilities): void {\n\t        this.isWorkspaceIndexingSupported = capabilities.workspace?.workspaceFolders ?? false\n\t        if (!this.isWorkspaceIndexingSupported) {\n", "            // Workspace indexing not supported\n\t            return\n\t        }\n\t        connection.workspace.onDidChangeWorkspaceFolders((params: WorkspaceFoldersChangeEvent) => {\n\t            void this.handleWorkspaceFoldersAdded(params.added)\n\t        })\n\t    }\n\t    /**\n\t     * Attempts to index the files in the user's workspace.\n\t     */\n", "    async indexWorkspace (): Promise<void> {\n\t        if (!(await this.shouldIndexWorkspace())) {\n\t            return\n\t        }\n\t        const folders = await connection.workspace.getWorkspaceFolders()\n\t        if (folders == null) {\n\t            return\n\t        }\n\t        Indexer.indexFolders(folders.map(folder => folder.uri))\n\t    }\n", "    /**\n\t     * Handles when new folders are added to the user's workspace by indexing them.\n\t     *\n\t     * @param folders The list of folders added to the workspace\n\t     */\n\t    private async handleWorkspaceFoldersAdded (folders: WorkspaceFolder[]): Promise<void> {\n\t        if (!(await this.shouldIndexWorkspace())) {\n\t            return\n\t        }\n\t        Indexer.indexFolders(folders.map(folder => folder.uri))\n", "    }\n\t    /**\n\t     * Determines whether or not the workspace should be indexed.\n\t     * The workspace should be indexed if the client supports workspaces, and if the\n\t     * workspace indexing setting is true.\n\t     *\n\t     * @returns True if workspace indexing should occurr, false otherwise.\n\t     */\n\t    private async shouldIndexWorkspace (): Promise<boolean> {\n\t        const shouldIndexWorkspace = (await ConfigurationManager.getConfiguration()).indexWorkspace\n", "        return this.isWorkspaceIndexingSupported && shouldIndexWorkspace\n\t    }\n\t}\n\texport default new WorkspaceIndexer()\n"]}
{"filename": "src/indexing/DocumentIndexer.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport { TextDocument } from 'vscode-languageserver-textdocument'\n\timport Indexer from './Indexer'\n\timport FileInfoIndex from './FileInfoIndex'\n\tconst INDEXING_DELAY = 500 // Delay (in ms) after keystroke before attempting to re-index the document\n\t/**\n\t * Handles indexing a currently open document to gather data about classes,\n\t * functions, and variables.\n\t */\n\tclass DocumentIndexer {\n", "    private readonly pendingFilesToIndex = new Map<string, NodeJS.Timer>()\n\t    /**\n\t     * Queues a document to be indexed. This handles debouncing so that\n\t     * indexing is not performed on every keystroke.\n\t     *\n\t     * @param textDocument The document to be indexed\n\t     */\n\t    queueIndexingForDocument (textDocument: TextDocument): void {\n\t        const uri = textDocument.uri\n\t        this.clearTimerForDocumentUri(uri)\n", "        this.pendingFilesToIndex.set(\n\t            uri,\n\t            setTimeout(() => {\n\t                this.indexDocument(textDocument)\n\t            }, INDEXING_DELAY) // Specify timeout for debouncing, to avoid re-indexing every keystroke while a user types\n\t        )\n\t    }\n\t    /**\n\t     * Indexes the document and caches the data.\n\t     *\n", "     * @param textDocument The document being indexed\n\t     */\n\t    indexDocument (textDocument: TextDocument): void {\n\t        void Indexer.indexDocument(textDocument)\n\t    }\n\t    /**\n\t     * Clears any active indexing timers for the provided document URI.\n\t     *\n\t     * @param uri The document URI\n\t     */\n", "    private clearTimerForDocumentUri (uri: string): void {\n\t        const timerId = this.pendingFilesToIndex.get(uri)\n\t        if (timerId != null) {\n\t            clearTimeout(timerId)\n\t            this.pendingFilesToIndex.delete(uri)\n\t        }\n\t    }\n\t    /**\n\t     * Ensure that @param textDocument is fully indexed and up to date by flushing any pending indexing tasks\n\t     * and then forcing an index. This is intended to service requests like documentSymbols where returning\n", "     * stale info could be confusing.\n\t     *\n\t     * @param textDocument The document to index\n\t     */\n\t    async ensureDocumentIndexIsUpdated (textDocument: TextDocument): Promise<void> {\n\t        const uri = textDocument.uri\n\t        if (this.pendingFilesToIndex.has(uri)) {\n\t            this.clearTimerForDocumentUri(uri)\n\t            await Indexer.indexDocument(textDocument)\n\t        }\n", "        if (!FileInfoIndex.codeDataCache.has(uri)) {\n\t            await Indexer.indexDocument(textDocument)\n\t        }\n\t    }\n\t}\n\texport default new DocumentIndexer()\n"]}
{"filename": "src/providers/formatting/FormatSupportProvider.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport { DocumentFormattingParams, FormattingOptions, HandlerResult, Position, Range, TextDocuments, TextEdit } from 'vscode-languageserver'\n\timport { TextDocument } from 'vscode-languageserver-textdocument'\n\timport LifecycleNotificationHelper from '../../lifecycle/LifecycleNotificationHelper'\n\timport MatlabLifecycleManager from '../../lifecycle/MatlabLifecycleManager'\n\timport { ActionErrorConditions, Actions, reportTelemetryAction } from '../../logging/TelemetryUtils'\n\timport { connection } from '../../server'\n\timport * as TextDocumentUtils from '../../utils/TextDocumentUtils'\n\tinterface FormatDocumentResponse {\n\t    data: string // The formatted document contents\n", "}\n\t/**\n\t * Handles requests for format-related features.\n\t * Currently, this handles formatting the entire document. In the future, this may be expanded to\n\t * include formatting a range witin the documemt.\n\t */\n\tclass FormatSupportProvider {\n\t    private readonly REQUEST_CHANNEL = '/matlabls/formatDocument/request'\n\t    private readonly RESPONSE_CHANNEL = '/matlabls/formatDocument/response'\n\t    /**\n", "     * Handles a request for document formatting.\n\t     *\n\t     * @param params Parameters from the onDocumentFormatting request\n\t     * @param documentManager The text document manager\n\t     * @param connection The language server connection\n\t     * @returns An array of text edits required for the formatting operation, or null if the operation cannot be performed\n\t     */\n\t    async handleDocumentFormatRequest (params: DocumentFormattingParams, documentManager: TextDocuments<TextDocument>): Promise<HandlerResult<TextEdit[] | null | undefined, void>> {\n\t        const docToFormat = documentManager.get(params.textDocument.uri)\n\t        if (docToFormat == null) {\n", "            return null\n\t        }\n\t        return await this.formatDocument(docToFormat, params.options)\n\t    }\n\t    /**\n\t     * Determines the edits required to format the given document.\n\t     *\n\t     * @param doc The document being formatted\n\t     * @param options The formatting options\n\t     * @returns An array of text edits required to format the document\n", "     */\n\t    private async formatDocument (doc: TextDocument, options: FormattingOptions): Promise<TextEdit[]> {\n\t        // For format, we try to instantiate MATLAB® if it is not already running\n\t        const matlabConnection = await MatlabLifecycleManager.getOrCreateMatlabConnection(connection)\n\t        // If MATLAB is not available, no-op\n\t        if (matlabConnection == null || !MatlabLifecycleManager.isMatlabReady()) {\n\t            LifecycleNotificationHelper.notifyMatlabRequirement()\n\t            reportTelemetryAction(Actions.FormatDocument, ActionErrorConditions.MatlabUnavailable)\n\t            return []\n\t        }\n", "        return await new Promise<TextEdit[]>(resolve => {\n\t            const responseSub = matlabConnection.subscribe(this.RESPONSE_CHANNEL, message => {\n\t                matlabConnection.unsubscribe(responseSub)\n\t                const newCode = (message as FormatDocumentResponse).data\n\t                const endRange = TextDocumentUtils.getRangeUntilLineEnd(doc, doc.lineCount - 1, 0)\n\t                const edit = TextEdit.replace(Range.create(\n\t                    Position.create(0, 0),\n\t                    endRange.end\n\t                ), newCode)\n\t                reportTelemetryAction(Actions.FormatDocument)\n", "                resolve([edit])\n\t            })\n\t            matlabConnection.publish(this.REQUEST_CHANNEL, {\n\t                data: doc.getText(),\n\t                insertSpaces: options.insertSpaces,\n\t                tabSize: options.tabSize\n\t            })\n\t        })\n\t    }\n\t}\n", "export default new FormatSupportProvider()\n"]}
{"filename": "src/providers/navigation/NavigationSupportProvider.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport { DefinitionParams, DocumentSymbolParams, Location, Position, Range, ReferenceParams, SymbolInformation, SymbolKind, TextDocuments } from 'vscode-languageserver'\n\timport { TextDocument } from 'vscode-languageserver-textdocument'\n\timport { URI } from 'vscode-uri'\n\timport * as fs from 'fs/promises'\n\timport FileInfoIndex, { FunctionVisibility, MatlabClassMemberInfo, MatlabCodeData, MatlabFunctionInfo } from '../../indexing/FileInfoIndex'\n\timport Indexer from '../../indexing/Indexer'\n\timport { MatlabConnection } from '../../lifecycle/MatlabCommunicationManager'\n\timport MatlabLifecycleManager from '../../lifecycle/MatlabLifecycleManager'\n\timport { getTextOnLine } from '../../utils/TextDocumentUtils'\n", "import PathResolver from './PathResolver'\n\timport { connection } from '../../server'\n\timport LifecycleNotificationHelper from '../../lifecycle/LifecycleNotificationHelper'\n\timport { ActionErrorConditions, Actions, reportTelemetryAction } from '../../logging/TelemetryUtils'\n\timport DocumentIndexer from '../../indexing/DocumentIndexer'\n\t/**\n\t * Represents a code expression, either a single identifier or a dotted expression.\n\t * For example, \"plot\" or \"pkg.Class.func\".\n\t */\n\tclass Expression {\n", "    constructor (public components: string[], public selectedComponent: number) {}\n\t    /**\n\t     * The full, dotted expression\n\t     */\n\t    get fullExpression (): string {\n\t        return this.components.join('.')\n\t    }\n\t    /**\n\t     * The dotted expression up to and including the selected component\n\t     */\n", "    get targetExpression (): string {\n\t        return this.components.slice(0, this.selectedComponent + 1).join('.')\n\t    }\n\t    /**\n\t     * Only the selected component of the expression\n\t     */\n\t    get unqualifiedTarget (): string {\n\t        return this.components[this.selectedComponent]\n\t    }\n\t    /**\n", "     * The first component of the expression\n\t     */\n\t    get first (): string {\n\t        return this.components[0]\n\t    }\n\t    /**\n\t     * The last component of the expression\n\t     */\n\t    get last (): string {\n\t        return this.components[this.components.length - 1]\n", "    }\n\t}\n\texport enum RequestType {\n\t    Definition,\n\t    References,\n\t    DocumentSymbol\n\t}\n\tfunction reportTelemetry (type: RequestType, errorCondition = ''): void {\n\t    let action: Actions\n\t    switch (type) {\n", "        case RequestType.Definition:\n\t            action = Actions.GoToDefinition\n\t            break\n\t        case RequestType.References:\n\t            action = Actions.GoToReference\n\t            break\n\t        case RequestType.DocumentSymbol:\n\t            action = Actions.DocumentSymbol\n\t            break\n\t    }\n", "    reportTelemetryAction(action, errorCondition)\n\t}\n\t/**\n\t * Handles requests for navigation-related features.\n\t * Currently, this handles Go-to-Definition and Go-to-References.\n\t */\n\tclass NavigationSupportProvider {\n\t    private readonly DOTTED_IDENTIFIER_REGEX = /[\\w.]+/\n\t    /**\n\t     * Handles requests for definitions or references.\n", "     *\n\t     * @param params Parameters for the definition or references request\n\t     * @param documentManager The text document manager\n\t     * @param requestType The type of request (definition or references)\n\t     * @returns An array of locations\n\t     */\n\t    async handleDefOrRefRequest (params: DefinitionParams | ReferenceParams, documentManager: TextDocuments<TextDocument>, requestType: RequestType): Promise<Location[]> {\n\t        const matlabConnection = await MatlabLifecycleManager.getOrCreateMatlabConnection(connection)\n\t        if (matlabConnection == null) {\n\t            LifecycleNotificationHelper.notifyMatlabRequirement()\n", "            reportTelemetry(requestType, ActionErrorConditions.MatlabUnavailable)\n\t            return []\n\t        }\n\t        const uri = params.textDocument.uri\n\t        const textDocument = documentManager.get(uri)\n\t        if (textDocument == null) {\n\t            reportTelemetry(requestType, 'No document')\n\t            return []\n\t        }\n\t        // Find ID for which to find the definition or references\n", "        const expression = this.getTarget(textDocument, params.position)\n\t        if (expression == null) {\n\t            // No target found\n\t            reportTelemetry(requestType, 'No navigation target')\n\t            return []\n\t        }\n\t        if (requestType === RequestType.Definition) {\n\t            return await this.findDefinition(uri, params.position, expression, matlabConnection)\n\t        } else {\n\t            return this.findReferences(uri, params.position, expression)\n", "        }\n\t    }\n\t    /**\n\t     * Caches document symbols for URIs to deal with the case when indexing\n\t     * temporarily fails while the user is in the middle of an edit. We might\n\t     * consider moving logic like this into the indexer logic later as clearing\n\t     * out index data in the middle of an edit will have other ill effects.\n\t     */\n\t    private readonly _documentSymbolCache = new Map<string, SymbolInformation[]>()\n\t    /**\n", "     *\n\t     * @param params Parameters for the document symbol request\n\t     * @param documentManager The text document manager\n\t     * @param requestType The type of request\n\t     * @returns Array of symbols found in the document\n\t     */\n\t    async handleDocumentSymbol (params: DocumentSymbolParams, documentManager: TextDocuments<TextDocument>, requestType: RequestType): Promise<SymbolInformation[]> {\n\t        // Get or wait for MATLAB connection to handle files opened before MATLAB is ready.\n\t        // Calling getOrCreateMatlabConnection would effectively make the onDemand launch\n\t        // setting act as onStart.\n", "        const matlabConnection = await MatlabLifecycleManager.getMatlabConnectionAsync()\n\t        if (matlabConnection == null) {\n\t            reportTelemetry(requestType, ActionErrorConditions.MatlabUnavailable)\n\t            return []\n\t        }\n\t        const uri = params.textDocument.uri\n\t        const textDocument = documentManager.get(uri)\n\t        if (textDocument == null) {\n\t            reportTelemetry(requestType, 'No document')\n\t            return []\n", "        }\n\t        // Ensure document index is up to date\n\t        await DocumentIndexer.ensureDocumentIndexIsUpdated(textDocument)\n\t        const codeData = FileInfoIndex.codeDataCache.get(uri)\n\t        if (codeData == null) {\n\t            reportTelemetry(requestType, 'No code data')\n\t            return []\n\t        }\n\t        // Result symbols in documented\n\t        const result: SymbolInformation[] = []\n", "        // Avoid duplicates coming from different data sources\n\t        const visitedRanges: Set<Range> = new Set()\n\t        /**\n\t         * Push symbol info to result set\n\t         */\n\t        function pushSymbol (name: string, kind: SymbolKind, symbolRange: Range): void {\n\t            if (!visitedRanges.has(symbolRange)) {\n\t                result.push(SymbolInformation.create(name, kind, symbolRange, uri))\n\t                visitedRanges.add(symbolRange)\n\t            }\n", "        }\n\t        if (codeData.isMainClassDefDocument && codeData.classInfo != null) {\n\t            const classInfo = codeData.classInfo\n\t            if (codeData.classInfo.range != null) {\n\t                pushSymbol(classInfo.name, SymbolKind.Class, codeData.classInfo.range)\n\t            }\n\t            classInfo.methods.forEach((info, name) => pushSymbol(name, SymbolKind.Method, info.range))\n\t            classInfo.enumerations.forEach((info, name) => pushSymbol(name, SymbolKind.EnumMember, info.range))\n\t            classInfo.properties.forEach((info, name) => pushSymbol(name, SymbolKind.Property, info.range))\n\t        }\n", "        codeData.functions.forEach((info, name) => pushSymbol(name, info.isClassMethod ? SymbolKind.Method : SymbolKind.Function, info.range))\n\t        /**\n\t         * Handle a case when the indexer fails due to the user being in the middle of an edit.\n\t         * Here the documentSymbol cache has some symbols but the codeData cache has none. So we\n\t         * assume that the user will soon fix their code and just fall back to what we knew for now.\n\t         */\n\t        if (result.length === 0) {\n\t            const cached = this._documentSymbolCache.get(uri) ?? result\n\t            if (cached.length > 0) {\n\t                return cached\n", "            }\n\t        }\n\t        this._documentSymbolCache.set(uri, result)\n\t        return result\n\t    }\n\t    /**\n\t     * Gets the definition/references request target expression.\n\t     *\n\t     * @param textDocument The text document\n\t     * @param position The position in the document\n", "     * @returns The expression at the given position, or null if no expression is found\n\t     */\n\t    private getTarget (textDocument: TextDocument, position: Position): Expression | null {\n\t        const idAtPosition = this.getIdentifierAtPosition(textDocument, position)\n\t        if (idAtPosition.identifier === '') {\n\t            return null\n\t        }\n\t        const idComponents = idAtPosition.identifier.split('.')\n\t        // Determine what component was targeted\n\t        let length = 0\n", "        let i = 0\n\t        while (i < idComponents.length && length <= position.character - idAtPosition.start) {\n\t            length += idComponents[i].length + 1 // +1 for '.'\n\t            i++\n\t        }\n\t        return new Expression(idComponents, i - 1) // Compensate for extra increment in loop\n\t    }\n\t    /**\n\t     * Determines the identifier (or dotted expression) at the given position in the document.\n\t     *\n", "     * @param textDocument The text document\n\t     * @param position The position in the document\n\t     * @returns An object containing the string identifier at the position, as well as the column number at which the identifier starts.\n\t     */\n\t    private getIdentifierAtPosition (textDocument: TextDocument, position: Position): { identifier: string, start: number } {\n\t        let lineText = getTextOnLine(textDocument, position.line)\n\t        const result = {\n\t            identifier: '',\n\t            start: -1\n\t        }\n", "        let matchResults = lineText.match(this.DOTTED_IDENTIFIER_REGEX)\n\t        let offset = 0\n\t        while (matchResults != null) {\n\t            if (matchResults.index == null || matchResults.index > position.character) {\n\t                // Already passed the cursor - no match found\n\t                break\n\t            }\n\t            const startChar = offset + matchResults.index\n\t            if (startChar + matchResults[0].length >= position.character) {\n\t                // Found overlapping identifier\n", "                result.identifier = matchResults[0]\n\t                result.start = startChar\n\t                break\n\t            }\n\t            // Match found too early in line - check for following matches\n\t            lineText = lineText.substring(matchResults.index + matchResults[0].length)\n\t            offset = startChar + matchResults[0].length\n\t            matchResults = lineText.match(this.DOTTED_IDENTIFIER_REGEX)\n\t        }\n\t        return result\n", "    }\n\t    /**\n\t     * Finds the definition(s) of an expression.\n\t     *\n\t     * @param uri The URI of the document containing the expression\n\t     * @param position The position of the expression\n\t     * @param expression The expression for which we are looking for the definition\n\t     * @param matlabConnection The connection to MATLAB®\n\t     * @returns The definition location(s)\n\t     */\n", "    private async findDefinition (uri: string, position: Position, expression: Expression, matlabConnection: MatlabConnection): Promise<Location[]> {\n\t        // Get code data for current file\n\t        const codeData = FileInfoIndex.codeDataCache.get(uri)\n\t        if (codeData == null) {\n\t            // File not indexed - unable to look for definition\n\t            reportTelemetry(RequestType.Definition, 'File not indexed')\n\t            return []\n\t        }\n\t        // First check within the current file's code data\n\t        const definitionInCodeData = this.findDefinitionInCodeData(uri, position, expression, codeData)\n", "        if (definitionInCodeData != null) {\n\t            reportTelemetry(RequestType.Definition)\n\t            return definitionInCodeData\n\t        }\n\t        // Check the MATLAB path\n\t        const definitionOnPath = await this.findDefinitionOnPath(uri, position, expression, matlabConnection)\n\t        if (definitionOnPath != null) {\n\t            reportTelemetry(RequestType.Definition)\n\t            return definitionOnPath\n\t        }\n", "        // If not on path, may be in user's workspace\n\t        reportTelemetry(RequestType.Definition)\n\t        return this.findDefinitionInWorkspace(uri, expression)\n\t    }\n\t    /**\n\t     * Searches the given code data for the definition(s) of the given expression\n\t     *\n\t     * @param uri The URI corresponding to the provided code data\n\t     * @param position The position of the expression\n\t     * @param expression The expression for which we are looking for the definition\n", "     * @param codeData The code data which is being searched\n\t     * @returns The definition location(s), or null if no definition was found\n\t     */\n\t    private findDefinitionInCodeData (uri: string, position: Position, expression: Expression, codeData: MatlabCodeData): Location[] | null {\n\t        // If first part of expression targeted - look for a local variable\n\t        if (expression.selectedComponent === 0) {\n\t            const containingFunction = codeData.findContainingFunction(position)\n\t            if (containingFunction != null) {\n\t                const varDefs = this.getVariableDefsOrRefs(containingFunction, expression.unqualifiedTarget, uri, RequestType.Definition)\n\t                if (varDefs != null) {\n", "                    return varDefs\n\t                }\n\t            }\n\t        }\n\t        // Check for functions in file\n\t        let functionDeclaration = this.getFunctionDeclaration(codeData, expression.fullExpression)\n\t        if (functionDeclaration != null) {\n\t            return [this.getLocationForFunctionDeclaration(functionDeclaration)]\n\t        }\n\t        // Check for definitions within classes\n", "        if (codeData.isClassDef && codeData.classInfo != null) {\n\t            // Look for methods/properties within class definitions (e.g. obj.foo)\n\t            functionDeclaration = this.getFunctionDeclaration(codeData, expression.last)\n\t            if (functionDeclaration != null) {\n\t                return [this.getLocationForFunctionDeclaration(functionDeclaration)]\n\t            }\n\t            // Look for possible properties\n\t            if (expression.selectedComponent === 1) {\n\t                const propertyDeclaration = this.getPropertyDeclaration(codeData, expression.last)\n\t                if (propertyDeclaration != null) {\n", "                    const propertyRange = Range.create(propertyDeclaration.range.start, propertyDeclaration.range.end)\n\t                    const uri = codeData.classInfo.uri\n\t                    if (uri != null) {\n\t                        return [Location.create(uri, propertyRange)]\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return null\n\t    }\n", "    /**\n\t     * Gets the location of the given function's declaration. If the function does not have\n\t     * a definite declaration, provides a location at the beginning of the file. For example,\n\t     * this may be the case for built-in functions like 'plot'.\n\t     *\n\t     * @param functionInfo Info about the function\n\t     * @returns The location of the function declaration\n\t     */\n\t    private getLocationForFunctionDeclaration (functionInfo: MatlabFunctionInfo): Location {\n\t        const range = functionInfo.declaration ?? Range.create(0, 0, 0, 0)\n", "        return Location.create(functionInfo.uri, range)\n\t    }\n\t    /**\n\t     * Searches the MATLAB path for the definition of the given expression\n\t     *\n\t     * @param uri The URI of the file containing the expression\n\t     * @param position The position of the expression\n\t     * @param expression The expression for which we are looking for the definition\n\t     * @param matlabConnection The connection to MATLAB\n\t     * @returns The definition location(s), or null if no definition was found\n", "     */\n\t    private async findDefinitionOnPath (uri: string, position: Position, expression: Expression, matlabConnection: MatlabConnection): Promise<Location[] | null> {\n\t        const resolvedPath = await PathResolver.resolvePaths([expression.targetExpression], uri, matlabConnection)\n\t        const resolvedUri = resolvedPath[0].uri\n\t        if (resolvedUri === '') {\n\t            // Not found\n\t            return null\n\t        }\n\t        // Ensure URI is not a directory. This can occur with some packages.\n\t        const fileStats = await fs.stat(URI.parse(resolvedUri).fsPath)\n", "        if (fileStats.isDirectory()) {\n\t            return null\n\t        }\n\t        if (!FileInfoIndex.codeDataCache.has(resolvedUri)) {\n\t            // Index target file, if necessary\n\t            await Indexer.indexFile(resolvedUri)\n\t        }\n\t        const codeData = FileInfoIndex.codeDataCache.get(resolvedUri)\n\t        // Find definition location within determined file\n\t        if (codeData != null) {\n", "            const definition = this.findDefinitionInCodeData(resolvedUri, position, expression, codeData)\n\t            if (definition != null) {\n\t                return definition\n\t            }\n\t        }\n\t        // If a definition location cannot be identified, default to the beginning of the file.\n\t        // This could be the case for builtin functions which don't actually have a definition in a .m file (e.g. plot).\n\t        return [Location.create(resolvedUri, Range.create(0, 0, 0, 0))]\n\t    }\n\t    /**\n", "     * Searches the (indexed) workspace for the definition of the given expression. These files may not be on the MATLAB path.\n\t     *\n\t     * @param uri The URI of the file containing the expression\n\t     * @param expression The expression for which we are looking for the definition\n\t     * @returns The definition location(s). Returns an empty array if no definitions found.\n\t     */\n\t    private findDefinitionInWorkspace (uri: string, expression: Expression): Location[] {\n\t        const expressionToMatch = expression.fullExpression\n\t        for (const [fileUri, fileCodeData] of FileInfoIndex.codeDataCache) {\n\t            if (uri === fileUri) continue // Already looked in the current file\n", "            let match = fileCodeData.packageName === '' ? '' : fileCodeData.packageName + '.'\n\t            if (fileCodeData.classInfo != null) {\n\t                const classUri = fileCodeData.classInfo.uri\n\t                if (classUri == null) continue\n\t                // Check class name\n\t                match += fileCodeData.classInfo.name\n\t                if (expressionToMatch === match) {\n\t                    const range = fileCodeData.classInfo.declaration ?? Range.create(0, 0, 0, 0)\n\t                    return [Location.create(classUri, range)]\n\t                }\n", "                // Check properties\n\t                const matchedProperty = this.findMatchingClassMember(expressionToMatch, match, classUri, fileCodeData.classInfo.properties)\n\t                if (matchedProperty != null) {\n\t                    return matchedProperty\n\t                }\n\t                // Check enums\n\t                const matchedEnum = this.findMatchingClassMember(expressionToMatch, match, classUri, fileCodeData.classInfo.enumerations)\n\t                if (matchedEnum != null) {\n\t                    return matchedEnum\n\t                }\n", "            }\n\t            // Check functions\n\t            for (const [funcName, funcData] of fileCodeData.functions) {\n\t                const funcMatch = (match === '') ? funcName : match + '.' + funcName\n\t                // Need to ensure that a function with a matching name should also be visible from the current file.\n\t                if (expressionToMatch === funcMatch && this.isFunctionVisibleFromUri(uri, funcData)) {\n\t                    const range = funcData.declaration ?? Range.create(0, 0, 0, 0)\n\t                    return [Location.create(funcData.uri, range)]\n\t                }\n\t            }\n", "        }\n\t        return []\n\t    }\n\t    /**\n\t     * Finds the class member (property or enumeration) in the given map which matches to given expression.\n\t     *\n\t     * @param expressionToMatch The expression being compared against\n\t     * @param matchPrefix The prefix which should be attached to the class members before comparison\n\t     * @param classUri The URI for the current class\n\t     * @param classMemberMap The map of class members\n", "     * @returns An array containing the location of the matched class member, or null if one was not found\n\t     */\n\t    private findMatchingClassMember (expressionToMatch: string, matchPrefix: string, classUri: string, classMemberMap: Map<string, MatlabClassMemberInfo>): Location[] | null {\n\t        for (const [memberName, memberData] of classMemberMap) {\n\t            const match = matchPrefix + '.' + memberName\n\t            if (expressionToMatch === match) {\n\t                return [Location.create(classUri, memberData.range)]\n\t            }\n\t        }\n\t        return null\n", "    }\n\t    /**\n\t     * Determines whether the given function should be visible from the given file URI.\n\t     * The function is visible if it is contained within the same file, or is public.\n\t     *\n\t     * @param uri The file's URI\n\t     * @param funcData The function data\n\t     * @returns true if the function should be visible from the given URI; false otherwise\n\t     */\n\t    private isFunctionVisibleFromUri (uri: string, funcData: MatlabFunctionInfo): boolean {\n", "        return uri === funcData.uri || funcData.visibility === FunctionVisibility.Public\n\t    }\n\t    /**\n\t     * Finds references of an expression.\n\t     *\n\t     * @param uri The URI of the document containing the expression\n\t     * @param position The position of the expression\n\t     * @param expression The expression for which we are looking for references\n\t     * @returns The references' locations\n\t     */\n", "    private findReferences (uri: string, position: Position, expression: Expression): Location[] {\n\t        // Get code data for current file\n\t        const codeData = FileInfoIndex.codeDataCache.get(uri)\n\t        if (codeData == null) {\n\t            // File not indexed - unable to look for references\n\t            reportTelemetry(RequestType.References, 'File not indexed')\n\t            return []\n\t        }\n\t        const referencesInCodeData = this.findReferencesInCodeData(uri, position, expression, codeData)\n\t        reportTelemetry(RequestType.References)\n", "        if (referencesInCodeData != null) {\n\t            return referencesInCodeData\n\t        }\n\t        return []\n\t    }\n\t    /**\n\t     * Searches for references, starting within the given code data. If the expression does not correspond to a local variable,\n\t     *  the search is broadened to other indexed files in the user's workspace.\n\t     *\n\t     * @param uri The URI corresponding to the provided code data\n", "     * @param position The position of the expression\n\t     * @param expression The expression for which we are looking for references\n\t     * @param codeData The code data which is being searched\n\t     * @returns The references' locations, or null if no reference was found\n\t     */\n\t    private findReferencesInCodeData (uri: string, position: Position, expression: Expression, codeData: MatlabCodeData): Location[] | null {\n\t        // If first part of expression is targeted - look for a local variable\n\t        if (expression.selectedComponent === 0) {\n\t            const containingFunction = codeData.findContainingFunction(position)\n\t            if (containingFunction != null) {\n", "                const varRefs = this.getVariableDefsOrRefs(containingFunction, expression.unqualifiedTarget, uri, RequestType.References)\n\t                if (varRefs != null) {\n\t                    return varRefs\n\t                }\n\t            }\n\t        }\n\t        // Check for functions in file\n\t        const functionDeclaration = this.getFunctionDeclaration(codeData, expression.fullExpression)\n\t        if (functionDeclaration != null && functionDeclaration.visibility === FunctionVisibility.Private) {\n\t            // Found a local function. Look through this file's references\n", "            return codeData.references.get(functionDeclaration.name)?.map(range => Location.create(uri, range)) ?? []\n\t        }\n\t        // Check other files\n\t        const refs: Location[] = []\n\t        for (const [, fileCodeData] of FileInfoIndex.codeDataCache) {\n\t            if (fileCodeData.functions.get(expression.fullExpression)?.visibility === FunctionVisibility.Private) {\n\t                // Skip files with other local functions\n\t                continue\n\t            }\n\t            const varRefs = fileCodeData.references.get(expression.fullExpression)\n", "            if (varRefs != null) {\n\t                varRefs.forEach(range => refs.push(Location.create(fileCodeData.uri, range)))\n\t            }\n\t        }\n\t        return refs\n\t    }\n\t    /**\n\t     * Gets the definition/references of a variable within a function.\n\t     *\n\t     * @param containingFunction Info about a function\n", "     * @param variableName The variable name for which we are looking for definitions or references\n\t     * @param uri The URI of the file\n\t     * @param requestType The type of request (definition or references)\n\t     * @returns The locations of the definition(s) or references of the given variable name within the given function info, or null if none can be found\n\t     */\n\t    private getVariableDefsOrRefs (containingFunction: MatlabFunctionInfo, variableName: string, uri: string, requestType: RequestType): Location[] | null {\n\t        const variableInfo = containingFunction.variableInfo.get(variableName)\n\t        if (variableInfo == null) {\n\t            return null\n\t        }\n", "        const varInfoRanges = requestType === RequestType.Definition ? variableInfo.definitions : variableInfo.references\n\t        return varInfoRanges.map(range => {\n\t            return Location.create(uri, range)\n\t        })\n\t    }\n\t    /**\n\t     * Searches for info about a function within the given code data.\n\t     *\n\t     * @param codeData The code data being searched\n\t     * @param functionName The name of the function being searched for\n", "     * @returns The info about the desired function, or null if it cannot be found\n\t     */\n\t    private getFunctionDeclaration (codeData: MatlabCodeData, functionName: string): MatlabFunctionInfo | null {\n\t        let functionDecl = codeData.functions.get(functionName)\n\t        if (codeData.isClassDef && (functionDecl == null || functionDecl.isPrototype)) {\n\t            // For classes, look in the methods list to better handle @folders\n\t            functionDecl = codeData.classInfo?.methods.get(functionName) ?? functionDecl\n\t        }\n\t        return functionDecl ?? null\n\t    }\n", "    /**\n\t     * Searches for info about a property within the given code data.\n\t     *\n\t     * @param codeData The code data being searched\n\t     * @param propertyName The name of the property being searched for\n\t     * @returns The info about the desired property, or null if it cannot be found\n\t     */\n\t    private getPropertyDeclaration (codeData: MatlabCodeData, propertyName: string): MatlabClassMemberInfo | null {\n\t        if (codeData.classInfo == null) {\n\t            return null\n", "        }\n\t        return codeData.classInfo.properties.get(propertyName) ?? null\n\t    }\n\t}\n\texport default new NavigationSupportProvider()\n"]}
{"filename": "src/providers/navigation/PathResolver.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport { URI } from 'vscode-uri'\n\timport { MatlabConnection } from '../../lifecycle/MatlabCommunicationManager'\n\tinterface ResolvePathResponse {\n\t    data: ResolvedPath[]\n\t}\n\tinterface ResolvedPath {\n\t    name: string\n\t    path: string\n\t}\n", "interface ResolvedUri {\n\t    name: string\n\t    uri: string\n\t}\n\tclass PathResolver {\n\t    private readonly REQUEST_CHANNEL = '/matlabls/navigation/resolvePath/request'\n\t    private readonly RESPONSE_CHANNEL = '/matlabls/navigation/resolvePath/response'\n\t    /**\n\t     * Attempts to resolve the given names to the files in which the names are defined.\n\t     * For example, 'MyClass' may be resolved to 'file:///path/to/MyClass.m'.\n", "     *\n\t     * @param names The names which should be resolved to paths\n\t     * @param contextFileUri The file from which the context of the path resolution should be made\n\t     * @param matlabConnection The connection to MATLAB®\n\t     *\n\t     * @returns The resolved URIs. Any URIs which could not be determiend are denoted by empty strings.\n\t     */\n\t    async resolvePaths (names: string[], contextFileUri: string, matlabConnection: MatlabConnection): Promise<ResolvedUri[]> {\n\t        const contextFile = URI.parse(contextFileUri).fsPath\n\t        return await new Promise(resolve => {\n", "            const responseSub = matlabConnection.subscribe(this.RESPONSE_CHANNEL, message => {\n\t                matlabConnection.unsubscribe(responseSub)\n\t                const resolvedPaths = (message as ResolvePathResponse).data\n\t                // Convert file system paths from MATLAB to URIs\n\t                const resolvedUris: ResolvedUri[] = resolvedPaths.map(resolvedPath => {\n\t                    const filePath = resolvedPath.path\n\t                    const uri = (filePath === '') ? '' : URI.file(filePath).toString()\n\t                    return {\n\t                        name: resolvedPath.name,\n\t                        uri\n", "                    }\n\t                })\n\t                resolve(resolvedUris)\n\t            })\n\t            matlabConnection.publish(this.REQUEST_CHANNEL, {\n\t                names,\n\t                contextFile\n\t            })\n\t        })\n\t    }\n", "}\n\texport default new PathResolver()\n"]}
{"filename": "src/providers/lspCommands/ExecuteCommandProvider.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport { ExecuteCommandParams, Range, TextDocuments, _Connection } from 'vscode-languageserver'\n\timport { TextDocument } from 'vscode-languageserver-textdocument'\n\timport LintingSupportProvider from '../linting/LintingSupportProvider'\n\tinterface LintSuppressionArgs {\n\t    id: string\n\t    range: Range\n\t    uri: string\n\t}\n\texport const MatlabLSCommands = {\n", "    MLINT_SUPPRESS_ON_LINE: 'matlabls.lint.suppress.line',\n\t    MLINT_SUPPRESS_IN_FILE: 'matlabls.lint.suppress.file'\n\t}\n\t/**\n\t * Handles requests to execute commands\n\t */\n\tclass ExecuteCommandProvider {\n\t    /**\n\t     * Handles command execution requests.\n\t     *\n", "     * @param params Parameters from the onExecuteCommand request\n\t     * @param documentManager The text document manager\n\t     * @param connection The language server connection\n\t     */\n\t    async handleExecuteCommand (params: ExecuteCommandParams, documentManager: TextDocuments<TextDocument>, connection: _Connection): Promise<void> {\n\t        switch (params.command) {\n\t            case MatlabLSCommands.MLINT_SUPPRESS_ON_LINE:\n\t            case MatlabLSCommands.MLINT_SUPPRESS_IN_FILE:\n\t                void this.handleLintingSuppression(params, documentManager, connection)\n\t        }\n", "    }\n\t    /**\n\t     * Handles command to suppress a linting diagnostic.\n\t     *\n\t     * @param params Parameters from the onExecuteCommand request\n\t     * @param documentManager The text document manager\n\t     * @param connection The language server connection\n\t     */\n\t    private async handleLintingSuppression (params: ExecuteCommandParams, documentManager: TextDocuments<TextDocument>, connection: _Connection): Promise<void> {\n\t        const args = params.arguments?.[0] as LintSuppressionArgs\n", "        const range = args.range\n\t        const uri = args.uri\n\t        const doc = documentManager.get(uri)\n\t        if (doc == null) {\n\t            return\n\t        }\n\t        const shouldSuppressThroughoutFile = params.command === MatlabLSCommands.MLINT_SUPPRESS_IN_FILE\n\t        LintingSupportProvider.suppressDiagnostic(doc, range, args.id, shouldSuppressThroughoutFile)\n\t    }\n\t}\n", "export default new ExecuteCommandProvider()\n"]}
{"filename": "src/providers/linting/LintingSupportProvider.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport { execFile, ExecFileException } from 'child_process'\n\timport { CodeAction, CodeActionKind, CodeActionParams, Command, Diagnostic, DiagnosticSeverity, Position, Range, TextDocumentEdit, TextEdit, VersionedTextDocumentIdentifier, WorkspaceEdit, _Connection } from 'vscode-languageserver'\n\timport { TextDocument } from 'vscode-languageserver-textdocument'\n\timport { URI } from 'vscode-uri'\n\timport ConfigurationManager from '../../lifecycle/ConfigurationManager'\n\timport { MatlabConnection } from '../../lifecycle/MatlabCommunicationManager'\n\timport MatlabLifecycleManager from '../../lifecycle/MatlabLifecycleManager'\n\timport Logger from '../../logging/Logger'\n\timport * as path from 'path'\n", "import which = require('which')\n\timport { MatlabLSCommands } from '../lspCommands/ExecuteCommandProvider'\n\timport { connection } from '../../server'\n\ttype mlintSeverity = '0' | '1' | '2' | '3' | '4'\n\tinterface RawLintResults {\n\t    lintData: string[]\n\t}\n\tinterface DiagnosticSuppressionResults {\n\t    suppressionEdits: TextEdit[]\n\t}\n", "const LINT_DELAY = 500 // Delay (in ms) after keystroke before attempting to lint the document\n\t// Lint result parsing constants\n\tconst LINT_MESSAGE_REGEX = /L (\\d+) \\(C (\\d+)-?(\\d*)\\): ([\\dA-Za-z]+): ML(\\d): (.*)/\n\tconst FIX_FLAG_REGEX = /\\(CAN FIX\\)/\n\tconst FIX_MESSAGE_REGEX = /----FIX MESSAGE<\\w+>\\s+<([^>]*)>/\n\tconst FIX_CHANGE_REGEX = /----CHANGE MESSAGE L (\\d+) \\(C (\\d+)\\);\\s+L (\\d+) \\(C (\\d+)\\):\\s+<([^>]*)>/\n\t/**\n\t * Handles requests for linting-related features.\n\t * Currently, this handles displaying diagnostics, providing quick-fixes,\n\t * and suppressing diagnostics.\n", " *\n\t * Note: When MATLAB® is not connected, diagnostics are only updated when\n\t * the file is saved and suppressing warnings is not available.\n\t */\n\tclass LintingSupportProvider {\n\t    private readonly LINTING_REQUEST_CHANNEL = '/matlabls/linting/request'\n\t    private readonly LINTING_RESPONSE_CHANNEL = '/matlabls/linting/response'\n\t    private readonly SUPPRESS_DIAGNOSTIC_REQUEST_CHANNEL = '/matlabls/linting/suppressdiagnostic/request'\n\t    private readonly SUPPRESS_DIAGNOSTIC_RESPONSE_CHANNEL = '/matlabls/linting/suppressdiagnostic/response'\n\t    private readonly SEVERITY_MAP = {\n", "        0: DiagnosticSeverity.Information,\n\t        1: DiagnosticSeverity.Warning,\n\t        2: DiagnosticSeverity.Error,\n\t        3: DiagnosticSeverity.Error,\n\t        4: DiagnosticSeverity.Error\n\t    }\n\t    private readonly _pendingFilesToLint = new Map<string, NodeJS.Timer>()\n\t    private readonly _availableCodeActions = new Map<string, CodeAction[]>()\n\t    /**\n\t     * Queues a document to be linted. This handles debouncing so\n", "     * that linting is not performed on every keystroke.\n\t     *\n\t     * @param textDocument The document to be linted\n\t     * @param connection The language server connection\n\t     */\n\t    queueLintingForDocument (textDocument: TextDocument, connection: _Connection): void {\n\t        const uri = textDocument.uri\n\t        this.clearTimerForDocumentUri(uri)\n\t        this._pendingFilesToLint.set(\n\t            uri,\n", "            setTimeout(() => {\n\t                void this.lintDocument(textDocument, connection)\n\t            }, LINT_DELAY) // Specify timeout for debouncing, to avoid re-linting every keystroke while a user types\n\t        )\n\t    }\n\t    /**\n\t     * Lints the document and displays diagnostics.\n\t     *\n\t     * @param textDocument The document being linted\n\t     * @param connection The language server connection\n", "     */\n\t    async lintDocument (textDocument: TextDocument, connection: _Connection): Promise<void> {\n\t        const uri = textDocument.uri\n\t        this.clearTimerForDocumentUri(uri)\n\t        this.clearCodeActionsForDocumentUri(uri)\n\t        const matlabConnection = MatlabLifecycleManager.getMatlabConnection()\n\t        const isMatlabAvailable = (matlabConnection != null) && MatlabLifecycleManager.isMatlabReady()\n\t        const fileName = URI.parse(uri).fsPath\n\t        let lintData: string[] = []\n\t        if (isMatlabAvailable) {\n", "            // Use MATLAB-based linting for better results and fixes\n\t            const code = textDocument.getText()\n\t            lintData = await this.getLintResultsFromMatlab(code, fileName, matlabConnection)\n\t        } else {\n\t            // Try to use mlint executable for basic linting\n\t            lintData = await this.getLintResultsFromExecutable(fileName)\n\t        }\n\t        const lintResults = this.processLintResults(uri, lintData)\n\t        const diagnostics = lintResults.diagnostics\n\t        // Store code actions\n", "        this._availableCodeActions.set(uri, lintResults.codeActions)\n\t        // Report diagnostics\n\t        void connection.sendDiagnostics({\n\t            uri,\n\t            diagnostics\n\t        })\n\t    }\n\t    clearDiagnosticsForDocument (textDocument: TextDocument): void {\n\t        void connection.sendDiagnostics({\n\t            uri: textDocument.uri,\n", "            diagnostics: []\n\t        })\n\t    }\n\t    /**\n\t     * Handles a request for code actions.\n\t     *\n\t     * @param params Parameters from the onCodeAction request\n\t     */\n\t    handleCodeActionRequest (params: CodeActionParams): CodeAction[] {\n\t        const uri = params.textDocument.uri\n", "        const actions = this._availableCodeActions.get(uri) ?? []\n\t        let codeActions = [...actions]\n\t        // Filter to find unique diagnostics\n\t        codeActions = codeActions.filter(action => {\n\t            const diagnostic = action.diagnostics?.[0]\n\t            if (diagnostic == null) {\n\t                return false\n\t            }\n\t            return params.context.diagnostics.some(diag => this.isSameDiagnostic(diagnostic, diag))\n\t        })\n", "        if (!MatlabLifecycleManager.isMatlabReady()) {\n\t            // Cannot suppress warnings without MATLAB\n\t            return codeActions\n\t        }\n\t        // Add suppression commands\n\t        const diagnostics = params.context.diagnostics\n\t        const commands: Command[] = []\n\t        diagnostics.forEach(diagnostic => {\n\t            // Don't allow suppressing errors\n\t            if (diagnostic.severity === DiagnosticSeverity.Error) {\n", "                return\n\t            }\n\t            const diagnosticCode = diagnostic.code as string\n\t            // Add suppress-on-line option\n\t            commands.push(Command.create(\n\t                `Suppress message ${diagnosticCode} on this line`,\n\t                MatlabLSCommands.MLINT_SUPPRESS_ON_LINE,\n\t                {\n\t                    id: diagnosticCode,\n\t                    range: diagnostic.range,\n", "                    uri\n\t                }\n\t            ))\n\t            // Add suppress-in-file option\n\t            commands.push(Command.create(\n\t                `Suppress message ${diagnosticCode} in this file`,\n\t                MatlabLSCommands.MLINT_SUPPRESS_IN_FILE,\n\t                {\n\t                    id: diagnosticCode,\n\t                    range: diagnostic.range,\n", "                    uri\n\t                }\n\t            ))\n\t        })\n\t        commands.forEach(command => {\n\t            // Add suppression actions as Commands to be processed later.\n\t            codeActions.push(CodeAction.create(command.title, command, CodeActionKind.QuickFix))\n\t        })\n\t        return codeActions\n\t    }\n", "    /**\n\t     * Attempt to suppress a diagnostic.\n\t     *\n\t     * @param textDocument The document\n\t     * @param range The range of the diagnostic being suppress\n\t     * @param id The diagnostic's ID\n\t     * @param shouldSuppressThroughoutFile Whether or not to suppress the diagnostic throughout the entire file\n\t     */\n\t    suppressDiagnostic (textDocument: TextDocument, range: Range, id: string, shouldSuppressThroughoutFile: boolean): void {\n\t        const matlabConnection = MatlabLifecycleManager.getMatlabConnection()\n", "        if (matlabConnection == null || !MatlabLifecycleManager.isMatlabReady()) {\n\t            return\n\t        }\n\t        const responseSub = matlabConnection.subscribe(this.SUPPRESS_DIAGNOSTIC_RESPONSE_CHANNEL, message => {\n\t            matlabConnection.unsubscribe(responseSub)\n\t            const suppressionEdits: TextEdit[] = (message as DiagnosticSuppressionResults).suppressionEdits\n\t            const edit: WorkspaceEdit = {\n\t                changes: {\n\t                    [textDocument.uri]: suppressionEdits\n\t                },\n", "                documentChanges: [\n\t                    TextDocumentEdit.create(\n\t                        VersionedTextDocumentIdentifier.create(textDocument.uri, textDocument.version),\n\t                        suppressionEdits\n\t                    )\n\t                ]\n\t            }\n\t            void connection.workspace.applyEdit(edit)\n\t        })\n\t        matlabConnection.publish(this.SUPPRESS_DIAGNOSTIC_REQUEST_CHANNEL, {\n", "            code: textDocument.getText(),\n\t            diagnosticId: id,\n\t            line: range.start.line + 1,\n\t            suppressInFile: shouldSuppressThroughoutFile\n\t        })\n\t    }\n\t    /**\n\t     * Clears any active linting timers for the provided document URI.\n\t     *\n\t     * @param uri The document URI\n", "     */\n\t    private clearTimerForDocumentUri (uri: string): void {\n\t        const timerId = this._pendingFilesToLint.get(uri)\n\t        if (timerId != null) {\n\t            clearTimeout(timerId)\n\t            this._pendingFilesToLint.delete(uri)\n\t        }\n\t    }\n\t    /**\n\t     * Clears any cached code actions for the provided document URI.\n", "     *\n\t     * @param uri The document URI\n\t     */\n\t    private clearCodeActionsForDocumentUri (uri: string): void {\n\t        this._availableCodeActions.set(uri, [])\n\t    }\n\t    /**\n\t     * Gets raw linting data from MATLAB.\n\t     *\n\t     * @param code The code to be linted\n", "     * @param fileName The file's name\n\t     * @param matlabConnection The connection to MATLAB\n\t     * @returns Raw lint data for the code\n\t     */\n\t    private async getLintResultsFromMatlab (code: string, fileName: string, matlabConnection: MatlabConnection): Promise<string[]> {\n\t        return await new Promise<string[]>(resolve => {\n\t            const responseSub = matlabConnection.subscribe(this.LINTING_RESPONSE_CHANNEL, message => {\n\t                matlabConnection.unsubscribe(responseSub)\n\t                resolve((message as RawLintResults).lintData)\n\t            })\n", "            matlabConnection.publish(this.LINTING_REQUEST_CHANNEL, {\n\t                code,\n\t                fileName\n\t            })\n\t        })\n\t    }\n\t    /**\n\t     * Gets raw linting data using the mlint executable.\n\t     *\n\t     * @param fileName The file's name\n", "     * @returns Raw lint data for the file\n\t     */\n\t    private async getLintResultsFromExecutable (fileName: string): Promise<string[]> {\n\t        const mlintExecutable = await this.getMlintExecutable()\n\t        if (mlintExecutable == null) {\n\t            // Unable to locate executable\n\t            return []\n\t        }\n\t        const mlintArgs = [\n\t            fileName,\n", "            '-id',\n\t            '-severity',\n\t            '-fix'\n\t        ]\n\t        return await new Promise<string[]>(resolve => {\n\t            try {\n\t                execFile(\n\t                    mlintExecutable,\n\t                    mlintArgs,\n\t                    (error: ExecFileException | null, stdout: string, stderr: string) => {\n", "                        if (error != null) {\n\t                            Logger.error(`Error from mlint executable: ${error.message}\\n${error.stack ?? ''}`)\n\t                            resolve([])\n\t                        }\n\t                        resolve(stderr.split('\\n')) // For some reason, mlint appears to output on stderr instead of stdout\n\t                    }\n\t                )\n\t            } catch (e) {\n\t                Logger.error(`Error executing mlint executable at ${mlintExecutable}`)\n\t            }\n", "        })\n\t    }\n\t    /**\n\t     * Attempts to determine the path to the mlint executable.\n\t     *\n\t     * @returns The path to the mlint executable, or null if it cannot be determined\n\t     */\n\t    private async getMlintExecutable (): Promise<string | null> {\n\t        const platformDir = this.getBinDirectoryForPlatform()\n\t        if (platformDir == null) {\n", "            // Unable to determine platform\n\t            return null\n\t        }\n\t        const matlabInstallPath = (await ConfigurationManager.getConfiguration()).installPath\n\t        let binPath = ''\n\t        if (matlabInstallPath !== '') {\n\t            // Find the executable from the root installation directory\n\t            binPath = path.normalize(path.join(matlabInstallPath, 'bin'))\n\t        } else {\n\t            // Try to find the executable based on the location of the `matlab` executable\n", "            try {\n\t                const resolvedPath = await which('matlab')\n\t                if (resolvedPath !== '') {\n\t                    binPath = path.dirname(resolvedPath)\n\t                }\n\t            } catch {\n\t                // `matlab` not found on path - no action\n\t            }\n\t        }\n\t        if (binPath === '') {\n", "            return null\n\t        }\n\t        const mlintExecutablePath = path.normalize(path.join(\n\t            binPath,\n\t            platformDir,\n\t            'mlint'\n\t        ))\n\t        return mlintExecutablePath\n\t    }\n\t    /**\n", "     * Gets the name of platform-specific binary directory.\n\t     *\n\t     * @returns The binary directory name, or null if the platform is not recognized\n\t     */\n\t    private getBinDirectoryForPlatform (): string | null {\n\t        switch (process.platform) {\n\t            case 'win32':\n\t                return 'win64'\n\t            case 'darwin':\n\t                return 'maci64'\n", "            case 'linux':\n\t                return 'glnxa64'\n\t            default:\n\t                return null\n\t        }\n\t    }\n\t    /**\n\t     * Parses diagnostics and code actions from the raw lint data.\n\t     *\n\t     * @param uri THe linted document's URI\n", "     * @param lintData The lint data for the document\n\t     * @returns Parsed diagnostics and code actions\n\t     */\n\t    private processLintResults (uri: string, lintData: string[]): { diagnostics: Diagnostic[], codeActions: CodeAction[] } {\n\t        const diagnostics: Diagnostic[] = []\n\t        const codeActions: CodeAction[] = []\n\t        let dataIndex = 0\n\t        while (dataIndex < lintData.length) {\n\t            const message = lintData[dataIndex++]\n\t            if (message === '') {\n", "                continue\n\t            }\n\t            // Parse lint message\n\t            // Diagnostics will be reported with a line like the following:\n\t            //     L {lineNumber} (C {columnNumber}): {diagnosticId}: ML{severity}: {diagnosticMessage} (CAN FIX)\n\t            // If the diagnostic cannot be fixed, the '(CAN FIX)' will not be present\n\t            const parsedLine = message.match(LINT_MESSAGE_REGEX)\n\t            if (parsedLine == null) {\n\t                continue\n\t            }\n", "            const line = Math.max(parseInt(parsedLine[1]) - 1, 0)\n\t            const startColumn = Math.max(parseInt(parsedLine[2]) - 1, 0)\n\t            const endColumn = (parsedLine[3] !== '') ? parseInt(parsedLine[3]) : startColumn + 1 // +1 for open interval\n\t            const id = parsedLine[4]\n\t            const severity = this.SEVERITY_MAP[parsedLine[5] as mlintSeverity]\n\t            let lintMessage: string = parsedLine[6]\n\t            // Check if there are available fixes for this diagnostic\n\t            const fixMatch = lintMessage.match(FIX_FLAG_REGEX)\n\t            if (fixMatch != null) {\n\t                lintMessage = lintMessage.replace(FIX_FLAG_REGEX, '').trim()\n", "            }\n\t            const diagnostic = Diagnostic.create(Range.create(line, startColumn, line, endColumn), lintMessage, severity, id, 'MATLAB')\n\t            diagnostics.push(diagnostic)\n\t            // Parse fix data for this diagnostic, if it exists\n\t            if (fixMatch == null) {\n\t                continue\n\t            }\n\t            const fixInfo = lintData[dataIndex++]\n\t            // Parse fix message\n\t            // Diagnostic fixes will be reported with lines like the following:\n", "            //     ----FIX MESSAGE<{diagnosticFixId}> <{message}>\n\t            //     ----CHANGE MESSAGE L {lineNumber} (C {columnNumber});  L {lineNumber} (C {columnNumber}):  <{text}>\n\t            const fixMsgMatch = fixInfo.match(FIX_MESSAGE_REGEX)\n\t            if (fixMsgMatch == null) {\n\t                continue\n\t            }\n\t            const fixMsg = fixMsgMatch[1]\n\t            // Gather fixes\n\t            const changes = {\n\t                [uri]: [] as TextEdit[]\n", "            }\n\t            const wsEdit: WorkspaceEdit = {\n\t                changes\n\t            }\n\t            while (dataIndex < lintData.length) {\n\t                const actionMsg = lintData[dataIndex]\n\t                const actionMsgMatch = actionMsg.match(FIX_CHANGE_REGEX)\n\t                if (actionMsgMatch == null) {\n\t                    break\n\t                }\n", "                // Consume, since we matched\n\t                dataIndex++\n\t                const startLine = parseInt(actionMsgMatch[1]) - 1\n\t                const startColumn = parseInt(actionMsgMatch[2]) - 1\n\t                const endLine = parseInt(actionMsgMatch[3]) - 1\n\t                const endColumn = parseInt(actionMsgMatch[4])\n\t                const replaceText = actionMsgMatch[5]\n\t                // Translate data into edits\n\t                let edit: TextEdit\n\t                if (startLine === endLine && startColumn === endColumn) {\n", "                    // 1. Insert\n\t                    edit = TextEdit.insert(Position.create(startLine, startColumn + 1), replaceText)\n\t                } else if (replaceText.length === 0) {\n\t                    // 2. Delete\n\t                    edit = TextEdit.del(Range.create(startLine, startColumn, endLine, endColumn))\n\t                } else {\n\t                    // 3. Replace\n\t                    edit = TextEdit.replace(Range.create(startLine, startColumn, endLine, endColumn), replaceText)\n\t                }\n\t                changes[uri].push(edit)\n", "            }\n\t            // If a fix has been processed, create a code action\n\t            if (changes[uri].length > 0) {\n\t                const action = CodeAction.create(fixMsg, wsEdit, CodeActionKind.QuickFix)\n\t                action.diagnostics = [diagnostics[diagnostics.length - 1]]\n\t                codeActions.push(action)\n\t            }\n\t        }\n\t        return {\n\t            diagnostics,\n", "            codeActions\n\t        }\n\t    }\n\t    /**\n\t     * Determines whether two diagnostics are equivalent.\n\t     *\n\t     * @param a The first diagnostic\n\t     * @param b The second diagnostic\n\t     * @returns True if the diagnostics are the same. False otherwise.\n\t     */\n", "    private isSameDiagnostic (a: Diagnostic, b: Diagnostic): boolean {\n\t        return a.code === b.code &&\n\t            a.message === b.message &&\n\t            a.range.start.character === b.range.start.character &&\n\t            a.range.start.line === b.range.start.line &&\n\t            a.range.end.character === b.range.end.character &&\n\t            a.range.end.line === b.range.end.line &&\n\t            a.severity === b.severity &&\n\t            a.source === b.source\n\t    }\n", "}\n\texport default new LintingSupportProvider()\n"]}
{"filename": "src/providers/completion/CompletionSupportProvider.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport { CompletionItem, CompletionItemKind, CompletionList, CompletionParams, ParameterInformation, Position, SignatureHelp, SignatureHelpParams, SignatureInformation, TextDocuments } from 'vscode-languageserver'\n\timport { TextDocument } from 'vscode-languageserver-textdocument'\n\timport { URI } from 'vscode-uri'\n\timport MatlabLifecycleManager from '../../lifecycle/MatlabLifecycleManager'\n\tinterface MCompletionData {\n\t    widgetData?: MWidgetData\n\t    widgetType?: string\n\t    signatures?: MSignatureData | MSignatureData[] // If there is only one signature, it is not given as an array\n\t}\n", "interface MWidgetData {\n\t    choices?: MCompletionChoice | MCompletionChoice[] // If there is only one choice, it is not given as an array\n\t    truncated?: boolean\n\t}\n\tinterface MCompletionChoice {\n\t    completion: string\n\t    matchType: string\n\t    purpose: string\n\t    displayString?: string\n\t}\n", "interface MSignatureData {\n\t    functionName: string\n\t    inputArguments?: MArgumentData | MArgumentData[] // If there is only one argument, it is not given as an array\n\t    outputArguments?: MArgumentData | MArgumentData[] // If there is only one argument, it is not given as an array\n\t}\n\tinterface MArgumentData {\n\t    name: string\n\t    widgetType: string\n\t    widgetData?: MWidgetData\n\t    status?: string\n", "    purpose?: string\n\t    valueSummary?: string\n\t}\n\t// Maps the completion type, as returned by MATLAB®, to the corresponding CompletionItemKind\n\tconst MatlabCompletionToKind: { [index: string]: CompletionItemKind } = {\n\t    literal: CompletionItemKind.Text,\n\t    unknown: CompletionItemKind.Function,\n\t    pathItem: CompletionItemKind.File,\n\t    mFile: CompletionItemKind.Function,\n\t    pFile: CompletionItemKind.Function,\n", "    mlxFile: CompletionItemKind.Function,\n\t    mlappFile: CompletionItemKind.Function,\n\t    mex: CompletionItemKind.Function,\n\t    mdlFile: CompletionItemKind.Function,\n\t    slxFile: CompletionItemKind.Function,\n\t    slxpFile: CompletionItemKind.Function,\n\t    sscFile: CompletionItemKind.Function,\n\t    sscpFile: CompletionItemKind.Function,\n\t    sfxFile: CompletionItemKind.Class,\n\t    folder: CompletionItemKind.Folder,\n", "    logical: CompletionItemKind.Value,\n\t    function: CompletionItemKind.Function,\n\t    filename: CompletionItemKind.File,\n\t    localFunction: CompletionItemKind.Function,\n\t    fieldname: CompletionItemKind.Field,\n\t    username: CompletionItemKind.Text,\n\t    variable: CompletionItemKind.Variable,\n\t    feature: CompletionItemKind.Text,\n\t    cellString: CompletionItemKind.Value,\n\t    class: CompletionItemKind.Class,\n", "    package: CompletionItemKind.Module,\n\t    property: CompletionItemKind.Property,\n\t    method: CompletionItemKind.Method,\n\t    enumeration: CompletionItemKind.EnumMember,\n\t    messageId: CompletionItemKind.Text,\n\t    keyword: CompletionItemKind.Keyword,\n\t    attribute: CompletionItemKind.Keyword\n\t}\n\t/**\n\t * Handles requests for completion-related features.\n", " * Currently, this handles auto-completion as well as function signature help.\n\t */\n\tclass CompletionProvider {\n\t    private readonly REQUEST_CHANNEL = '/matlabls/completions/request'\n\t    private readonly RESPONSE_CHANNEL = '/matlabls/completions/response'\n\t    /**\n\t     * Handles a request for auto-completion choices.\n\t     *\n\t     * @param params Parameters from the onCompletion request\n\t     * @param documentManager The text document manager\n", "     * @returns An array of possible completions\n\t     */\n\t    async handleCompletionRequest (params: CompletionParams, documentManager: TextDocuments<TextDocument>): Promise<CompletionList> {\n\t        const doc = documentManager.get(params.textDocument.uri)\n\t        if (doc == null) {\n\t            return CompletionList.create()\n\t        }\n\t        const completionData = await this.retrieveCompletionData(doc, params.position)\n\t        return this.parseCompletionItems(completionData)\n\t    }\n", "    /**\n\t     * Handles a request for function signature help.\n\t     *\n\t     * @param params Parameters from the onSignatureHelp request\n\t     * @param documentManager The text document manager\n\t     * @returns The signature help, or null if no signature help is available\n\t     */\n\t    async handleSignatureHelpRequest (params: SignatureHelpParams, documentManager: TextDocuments<TextDocument>): Promise<SignatureHelp | null> {\n\t        const doc = documentManager.get(params.textDocument.uri)\n\t        if (doc == null) {\n", "            return null\n\t        }\n\t        const completionData = await this.retrieveCompletionData(doc, params.position)\n\t        return this.parseSignatureHelp(completionData)\n\t    }\n\t    /**\n\t     * Retrieves raw completion data from MATLAB.\n\t     *\n\t     * @param doc The text document\n\t     * @param position The cursor position in the document\n", "     * @returns The raw completion data\n\t     */\n\t    private async retrieveCompletionData (doc: TextDocument, position: Position): Promise<MCompletionData> {\n\t        const docUri = doc.uri\n\t        const code = doc.getText()\n\t        const fileName = URI.parse(docUri).fsPath\n\t        const cursorPosition = doc.offsetAt(position)\n\t        const matlabConnection = MatlabLifecycleManager.getMatlabConnection()\n\t        if (matlabConnection == null || !MatlabLifecycleManager.isMatlabReady()) {\n\t            return {}\n", "        }\n\t        return await new Promise(resolve => {\n\t            const responseSub = matlabConnection.subscribe(this.RESPONSE_CHANNEL, message => {\n\t                matlabConnection.unsubscribe(responseSub)\n\t                resolve(message as MCompletionData)\n\t            })\n\t            matlabConnection.publish(this.REQUEST_CHANNEL, {\n\t                code,\n\t                fileName,\n\t                cursorPosition\n", "            })\n\t        })\n\t    }\n\t    /**\n\t     * Parses the raw completion data to extract possible auto-completions.\n\t     *\n\t     * @param completionData The raw completion data\n\t     * @returns A list of completion items\n\t     */\n\t    private parseCompletionItems (completionData: MCompletionData): CompletionList {\n", "        const completionItems: CompletionItem[] = []\n\t        const completionsMap = new Map<string, { kind: CompletionItemKind, doc: string }>()\n\t        // Gather completions from top-level object. This should find function completions.\n\t        this.gatherCompletions(completionData, completionsMap)\n\t        // Gather completions from each signature. This should find function argument completions.\n\t        let signatures = completionData.signatures\n\t        if (signatures != null) {\n\t            signatures = Array.isArray(signatures) ? signatures : [signatures]\n\t            signatures.forEach(signature => {\n\t                let inputArguments = signature.inputArguments\n", "                if (inputArguments == null) {\n\t                    return\n\t                }\n\t                inputArguments = Array.isArray(inputArguments) ? inputArguments : [inputArguments]\n\t                inputArguments.forEach(inputArgument => {\n\t                    this.gatherCompletions(inputArgument, completionsMap)\n\t                })\n\t            })\n\t        }\n\t        let index = 0\n", "        completionsMap.forEach((completionData, completionName) => {\n\t            // Preserve the sorting from MATLAB\n\t            const sortText = String(index).padStart(10, '0')\n\t            const completionItem = CompletionItem.create(completionName)\n\t            completionItem.kind = completionData.kind\n\t            completionItem.detail = completionData.doc\n\t            completionItem.data = index++\n\t            completionItem.sortText = sortText\n\t            completionItems.push(completionItem)\n\t        })\n", "        return CompletionList.create(completionItems, completionData.widgetData?.truncated ?? false)\n\t    }\n\t    /**\n\t     * Parses raw completion and argument data and stores info about possible completions in the provided map.\n\t     *\n\t     * @param completionDataObj Raw completion or argument data\n\t     * @param completionMap A map in which to store info about possible completions\n\t     */\n\t    private gatherCompletions (completionDataObj: MCompletionData | MArgumentData, completionMap: Map<string, { kind: CompletionItemKind, doc: string }>): void {\n\t        let choices = completionDataObj.widgetData?.choices\n", "        if (choices == null) {\n\t            return\n\t        }\n\t        choices = Array.isArray(choices) ? choices : [choices]\n\t        choices.forEach(choice => {\n\t            let completion: string = choice.completion\n\t            let isPath = false\n\t            switch (choice.matchType) {\n\t                case 'folder':\n\t                case 'filename':\n", "                    // For files and folders, the completion is the full path whereas the displayString is the path to be added\n\t                    completion = choice.displayString ?? ''\n\t                    isPath = true\n\t                    break\n\t                case 'messageId':\n\t                    // Remove quotes from completion\n\t                    completion = (choice.displayString ?? '').replace(/['\"]/g, '')\n\t                    break\n\t            }\n\t            const dotIdx = choice.completion.lastIndexOf('.')\n", "            if (dotIdx > 0 && !isPath) {\n\t                completion = completion.slice(dotIdx + 1)\n\t            }\n\t            completionMap.set(completion, {\n\t                kind: MatlabCompletionToKind[choice.matchType] ?? CompletionItemKind.Function,\n\t                doc: choice.purpose\n\t            })\n\t        })\n\t    }\n\t    /**\n", "     * Parses the raw completion data to extract function signature help.\n\t     *\n\t     * @param completionData The raw completion data\n\t     * @returns The signature help, or null if no signature help is available\n\t     */\n\t    private parseSignatureHelp (completionData: MCompletionData): SignatureHelp | null {\n\t        let signatureData = completionData.signatures\n\t        if (signatureData == null) {\n\t            return null\n\t        }\n", "        signatureData = Array.isArray(signatureData) ? signatureData : [signatureData]\n\t        const signatureHelp: SignatureHelp = {\n\t            activeParameter: 0,\n\t            activeSignature: 0,\n\t            signatures: []\n\t        }\n\t        // Parse each signature\n\t        signatureData.forEach(sigData => {\n\t            const params: ParameterInformation[] = []\n\t            // Handle function inputs\n", "            const argNames: string[] = []\n\t            let inputArguments = sigData.inputArguments\n\t            if (inputArguments == null) {\n\t                return\n\t            }\n\t            inputArguments = Array.isArray(inputArguments) ? inputArguments : [inputArguments]\n\t            inputArguments.forEach((inputArg, index) => {\n\t                let paramDoc = ''\n\t                if (inputArg.purpose != null) {\n\t                    paramDoc += inputArg.purpose\n", "                }\n\t                if (inputArg.valueSummary != null) {\n\t                    paramDoc += (paramDoc.length > 0 ? '\\n' : '') + inputArg.valueSummary\n\t                }\n\t                const paramDocArgs = paramDoc.length > 0 ? [paramDoc] : []\n\t                params.push(ParameterInformation.create(inputArg.name, ...paramDocArgs))\n\t                argNames.push(inputArg.name)\n\t                if (inputArg.status === 'presenting') {\n\t                    signatureHelp.activeParameter = index\n\t                }\n", "            })\n\t            let argStr = ''\n\t            if (argNames.length === 1) {\n\t                argStr = argNames[0]\n\t            } else if (argNames.length > 1) {\n\t                argStr = argNames.join(', ')\n\t            }\n\t            // Handle function outputs\n\t            let outStr = ''\n\t            let outputArguments = sigData.outputArguments\n", "            if (outputArguments != null) {\n\t                outputArguments = Array.isArray(outputArguments) ? outputArguments : [outputArguments]\n\t                outStr = outputArguments.length === 1\n\t                    ? outputArguments[0].name\n\t                    : `[${outputArguments.map(output => output.name).join(', ')}]`\n\t                outStr += ' = '\n\t            }\n\t            const id = `${outStr}${sigData.functionName}(${argStr})`\n\t            signatureHelp.signatures.push(SignatureInformation.create(\n\t                id,\n", "                undefined,\n\t                ...params\n\t            ))\n\t        })\n\t        return signatureHelp\n\t    }\n\t}\n\texport default new CompletionProvider()\n"]}
{"filename": "src/notifications/NotificationService.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport { GenericNotificationHandler } from 'vscode-languageserver'\n\timport { connection } from '../server'\n\texport enum Notification {\n\t    // Connection Status Updates\n\t    MatlabConnectionClientUpdate = 'matlab/connection/update/client',\n\t    MatlabConnectionServerUpdate = 'matlab/connection/update/server',\n\t    // Errors\n\t    MatlabLaunchFailed = 'matlab/launchfailed',\n\t    MatlabFeatureUnavailable = 'feature/needsmatlab',\n", "    MatlabFeatureUnavailableNoMatlab = 'feature/needsmatlab/nomatlab',\n\t    // Telemetry\n\t    LogTelemetryData = 'telemetry/logdata'\n\t}\n\tclass NotificationService {\n\t    /**\n\t     * Sends a notification to the language client\n\t     *\n\t     * @param name The name of the notification\n\t     * @param params Any parameters to send with the notification\n", "     */\n\t    sendNotification (name: string, params?: unknown): void {\n\t        void connection.sendNotification(name, params)\n\t    }\n\t    /**\n\t     * Sets up a listener for notifications from the language client\n\t     *\n\t     * @param name The name of the notification\n\t     * @param callback The callback\n\t     */\n", "    registerNotificationListener (name: string, callback: GenericNotificationHandler): void {\n\t        connection.onNotification(name, callback)\n\t    }\n\t}\n\texport default new NotificationService()\n"]}
{"filename": "src/lifecycle/MatlabCommunicationManager.d.ts", "chunked_list": ["/// <reference types=\"node\" />\n\timport { ChildProcess } from 'child_process';\n\tdeclare const Faye: any;\n\tdeclare type Client = typeof Faye.Client;\n\tdeclare type Subscription = typeof Faye.Client.Subscription;\n\texport declare enum LifecycleEventType {\n\t    CONNECTED = 0,\n\t    DISCONNECTED = 1\n\t}\n\tinterface MatlabProcessInfo {\n", "    matlabProcess: ChildProcess;\n\t    matlabConnection: MatlabConnection;\n\t}\n\t/**\n\t * Manages launching and communicating with MATLAB\n\t */\n\tdeclare class MatlabCommunicationManager {\n\t    /**\n\t     * Launches and connects to MATLAB.\n\t     *\n", "     * @param launchCommand The command with which MATLAB is launched\n\t     * @param launchArguments The arguments with which MATLAB is launched\n\t     * @param logDirectory The directory in which MATLAB should log data\n\t     *\n\t     * @returns Information about the new MATLAB process and the connection to it.\n\t     * Returns null if the MATLAB process cannot be started.\n\t     */\n\t    connectToNewMatlab(launchCommand: string, launchArguments: string[], logDirectory: string): Promise<MatlabProcessInfo | null>;\n\t    /**\n\t     * Attempts to connect to an existing instance of MATLAB at the given URL.\n", "     *\n\t     * @param url The URL at which to find MATLAB\n\t     * @returns The connection to MATLAB\n\t     */\n\t    connectToExistingMatlab(url: string): Promise<MatlabConnection>;\n\t    /**\n\t     * Gets a random available TCP port.\n\t     *\n\t     * @returns A random available TCP port, as a string\n\t     */\n", "    private _getAvailablePort;\n\t    /**\n\t     * Gets a random API key for MATLAB.\n\t     *\n\t     * @returns A random API key\n\t     */\n\t    private _makeApiKey;\n\t}\n\tdeclare type LifecycleListenerCallback = (eventType: LifecycleEventType) => void;\n\t/**\n", " * Abstract class representing a connection with the MATLAB application.\n\t */\n\texport declare abstract class MatlabConnection {\n\t    protected _client?: Client;\n\t    protected _url?: string;\n\t    protected _lifecycleCallback: LifecycleListenerCallback | null;\n\t    /**\n\t     * Initializes the connection with MATLAB\n\t     */\n\t    abstract initialize(): Promise<void>;\n", "    /**\n\t     * Closes the connection with MATLAB.\n\t     * Does not attempt to close MATLAB.\n\t     */\n\t    close(): void;\n\t    /**\n\t     * Publishes a message to the given channel.\n\t     *\n\t     * @param channel The channel to which the message is being published\n\t     * @param message The message being published\n", "     */\n\t    publish(channel: string, message: unknown): void;\n\t    /**\n\t     * Subscribe to messages published on the given channel. The messages will\n\t     * be passed to hte given calback function.\n\t     *\n\t     * @param channel The channel for which to subscribe\n\t     * @param callback The callback function\n\t     * @returns The subscription object\n\t     */\n", "    subscribe(channel: string, callback: (message: unknown) => void): Subscription;\n\t    /**\n\t     * Unsubscribe from the given subscription.\n\t     *\n\t     * @param subscription The subscription which is being unsubscribed\n\t     */\n\t    unsubscribe(subscription: Subscription): void;\n\t    /**\n\t     * Sets a lifecycle listened callback. This will be called when there are\n\t     * changes to the state of the connection with MATLAB.\n", "     *\n\t     * @param callback The callback function\n\t     */\n\t    setLifecycleListener(callback: LifecycleListenerCallback): void;\n\t    protected onConnectionSuccess(): void;\n\t    protected onConnectionFailure(): void;\n\t    protected setupConnectionCallbacks(): void;\n\t    /**\n\t     * Prepends a channel name with '/matlab' as expected by MATLAB\n\t     *\n", "     * @param channel A channel name, in the format '/message/channel'\n\t     * @returns A channel prepended with '/matlab', such as '/matlab/message/channel'\n\t     */\n\t    private _prependChannel;\n\t}\n\tdeclare const _default: MatlabCommunicationManager;\n\texport default _default;\n"]}
{"filename": "src/lifecycle/LifecycleNotificationHelper.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport NotificationService, { Notification } from '../notifications/NotificationService'\n\texport enum ConnectionState {\n\t    CONNECTING = 'connecting',\n\t    CONNECTED = 'connected',\n\t    DISCONNECTED = 'disconnected'\n\t}\n\tclass LifecycleNotificationHelper {\n\t    didMatlabLaunchFail = false\n\t    /**\n", "     * Sends notification to the language client of a change in the MATLAB® connection state.\n\t     *\n\t     * @param connectionStatus The connection state\n\t     */\n\t    notifyConnectionStatusChange (connectionStatus: ConnectionState): void {\n\t        NotificationService.sendNotification(Notification.MatlabConnectionServerUpdate, {\n\t            connectionStatus\n\t        })\n\t    }\n\t    /**\n", "     * Sends notification to the language client to inform user that MATLAB is required for an action.\n\t     */\n\t    notifyMatlabRequirement (): void {\n\t        // Indicate different messages if MATLAB failed to launch (i.e. could not be found)\n\t        const notification = this.didMatlabLaunchFail ? Notification.MatlabFeatureUnavailableNoMatlab : Notification.MatlabFeatureUnavailable\n\t        NotificationService.sendNotification(notification)\n\t    }\n\t}\n\texport default new LifecycleNotificationHelper()\n"]}
{"filename": "src/lifecycle/MatlabLifecycleManager.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport { ChildProcess } from 'child_process'\n\timport { _Connection } from 'vscode-languageserver'\n\timport * as fs from 'fs'\n\timport * as os from 'os'\n\timport * as path from 'path'\n\timport MatlabCommunicationManager, { LifecycleEventType, MatlabConnection } from './MatlabCommunicationManager'\n\timport Logger from '../logging/Logger'\n\timport ConfigurationManager, { Argument, ConnectionTiming } from './ConfigurationManager'\n\timport { connection } from '../server'\n", "import LifecycleNotificationHelper from './LifecycleNotificationHelper'\n\timport NotificationService, { Notification } from '../notifications/NotificationService'\n\timport { Actions, reportTelemetryAction } from '../logging/TelemetryUtils'\n\tenum ConnectionState {\n\t    CONNECTING = 'connecting',\n\t    CONNECTED = 'connected',\n\t    DISCONNECTED = 'disconnected'\n\t}\n\tinterface MatlabLifecycleEvent {\n\t    matlabStatus: 'connected' | 'disconnected'\n", "}\n\texport interface MatlabConnectionStatusParam {\n\t    connectionAction: 'connect' | 'disconnect'\n\t}\n\ttype MatlabLifecycleCallback = (error: Error | null, evt: MatlabLifecycleEvent) => void\n\t/**\n\t * Manages the lifecycle of the connected MATLAB® application.\n\t */\n\tclass MatlabLifecycleManager {\n\t    private _matlabProcess: MatlabProcess | null = null\n", "    private readonly _matlabLifecycleCallbacks: MatlabLifecycleCallback[] = []\n\t    /**\n\t     * Connects to MATLAB.\n\t     *\n\t     * @param connection The language server connection\n\t     * @returns The MATLAB process\n\t     */\n\t    async connectToMatlab (connection: _Connection): Promise<MatlabProcess> {\n\t        if (this._shouldConnectToExistingMatlab()) {\n\t            return await this._connectToExistingMatlab(connection)\n", "        } else {\n\t            return await this._launchAndConnectToMatlab(connection)\n\t        }\n\t    }\n\t    /**\n\t     * Disconnects from MATLAB.\n\t     */\n\t    disconnectFromMatlab (): void {\n\t        if (this._matlabProcess == null || !this._matlabProcess.isValid) {\n\t            return\n", "        }\n\t        this._matlabProcess?.shutdown()\n\t        this._matlabProcess = null\n\t        this._handleMatlabLifecycleUpdate('disconnected')\n\t    }\n\t    /**\n\t     * Gets whether or not MATLAB is ready for communication.\n\t     *\n\t     * @returns Whether or not MATLAB can be communicated with.\n\t     */\n", "    isMatlabReady (): boolean {\n\t        return Boolean(this._matlabProcess?.isMatlabReady())\n\t    }\n\t    /**\n\t     * Gets the active connection to MATLAB. Does not attempt to create a connection if\n\t     * one does not currently exist.\n\t     *\n\t     * @returns The connection to MATLAB, or null if there is no active connection.\n\t     */\n\t    getMatlabConnection (): MatlabConnection | null {\n", "        const isMatlabValid = this._matlabProcess?.isValid ?? false\n\t        if (isMatlabValid) {\n\t            return this._matlabProcess?.getConnection() ?? null\n\t        }\n\t        return null\n\t    }\n\t    /**\n\t     * Gets the active connection to MATLAB or waits for one to be established.\n\t     * Does not attempt to create a connection if one does not currently exist.\n\t     * Immediately returns null if the user set the MATLAB connection timing to\n", "     * never.\n\t     *\n\t     * @returns The connection to MATLAB, or null if connection timing is never\n\t     * and MATLAB has not been manually launched.\n\t     */\n\t    async getMatlabConnectionAsync (): Promise<MatlabConnection | null> {\n\t        // If MATLAB is up and running return the connection\n\t        const isMatlabReady = this._matlabProcess?.isMatlabReady() ?? false\n\t        if (isMatlabReady) {\n\t            const conn = this._matlabProcess?.getConnection()\n", "            if (conn !== null && conn !== undefined) {\n\t                return conn\n\t            }\n\t        }\n\t        // MATLAB isn't running and the user has said we shouldn't start it\n\t        if (await this._isMatlabConnectionTimingNever()) {\n\t            return null\n\t        }\n\t        // MATLAB might start later on. Return a promise to wait for it.\n\t        const result = new Promise<MatlabConnection>((resolve, reject) => {\n", "            this.addMatlabLifecycleListener((error, evt) => {\n\t                if (error !== null) {\n\t                    reject(error)\n\t                }\n\t                if (evt.matlabStatus === 'connected') {\n\t                    const conn = this.getMatlabConnection()\n\t                    if (conn !== null) {\n\t                        resolve(conn)\n\t                    }\n\t                }\n", "            })\n\t        })\n\t        return await result\n\t    }\n\t    /**\n\t     * Gets the active connection to MATLAB. If one does not currently exist, this will\n\t     * attempt to establish a connection.\n\t     *\n\t     * @param connection The language server connection\n\t     * @returns The connection to MATLAB, or null if one cannot be established.\n", "     */\n\t    async getOrCreateMatlabConnection (connection: _Connection): Promise<MatlabConnection | null> {\n\t        // Check if there is already an active connection\n\t        const activeConnection = this.getMatlabConnection()\n\t        if (activeConnection != null) {\n\t            return activeConnection\n\t        }\n\t        // No active connection - should create a connection if desired\n\t        if (!(await this._isMatlabConnectionTimingNever())) {\n\t            const matlabProcess = await this.connectToMatlab(connection)\n", "            return matlabProcess.getConnection()\n\t        }\n\t        // No connection should be created\n\t        return null\n\t    }\n\t    /**\n\t     * Adds a callback for MATLAB lifecycle events, such as when a connection is\n\t     * established or broken.\n\t     *\n\t     * @param callback The callback function\n", "     */\n\t    addMatlabLifecycleListener (callback: MatlabLifecycleCallback): void {\n\t        this._matlabLifecycleCallbacks.push(callback)\n\t    }\n\t    /**\n\t     * Handles requests from the language client to either connect to or disconnect from MATLAB\n\t     *\n\t     * @param data Data about whether or not MATLAB should be connected or disconnected\n\t     */\n\t    handleConnectionStatusChange (data: MatlabConnectionStatusParam): void {\n", "        if (data.connectionAction === 'connect') {\n\t            void this.connectToMatlab(connection)\n\t        } else {\n\t            this.disconnectFromMatlab()\n\t        }\n\t    }\n\t    /**\n\t     * Whether or not the language server should attempt to connect to an existing\n\t     * MATLAB instance.\n\t     *\n", "     * @returns True if the language server should attempt to connect to an\n\t     * already-running instance of MATLAB. False otherwise.\n\t     */\n\t    private _shouldConnectToExistingMatlab (): boolean {\n\t        // Assume we should connect to existing MATLAB if the matlabUrl startup flag has been provided\n\t        return Boolean(ConfigurationManager.getArgument(Argument.MatlabUrl))\n\t    }\n\t    /**\n\t     * Attempts to connect to an existing MATLAB process.\n\t     *\n", "     * @param connection The language server connection\n\t     * @returns The connected MATLAB process\n\t     */\n\t    private async _connectToExistingMatlab (connection: _Connection): Promise<MatlabProcess> {\n\t        const url = ConfigurationManager.getArgument(Argument.MatlabUrl)\n\t        if (this._matlabProcess == null || !this._matlabProcess.isValid) {\n\t            this._matlabProcess = new MatlabProcess(connection)\n\t        }\n\t        await this._matlabProcess.connectToMatlab(url)\n\t        return this._matlabProcess\n", "    }\n\t    /**\n\t     * Attempts to launch and then connect to MATLAB.\n\t     *\n\t     * @param connection The language server connection\n\t     * @returns The connected MATLAB process\n\t     */\n\t    private async _launchAndConnectToMatlab (connection: _Connection): Promise<MatlabProcess> {\n\t        if (this._matlabProcess == null || !this._matlabProcess.isValid) {\n\t            this._matlabProcess = new MatlabProcess(connection)\n", "        }\n\t        if (!this._matlabProcess.isMatlabReady()) {\n\t            await this._matlabProcess.launchMatlab()\n\t            this._handleMatlabLifecycleUpdate('connected')\n\t        }\n\t        return this._matlabProcess\n\t    }\n\t    /**\n\t     * Emits a lifecycle update to all listeners.\n\t     *\n", "     * @param status The connected status of MATLAB\n\t     */\n\t    private _handleMatlabLifecycleUpdate (status: 'connected' | 'disconnected'): void {\n\t        this._matlabLifecycleCallbacks.forEach(callback => {\n\t            callback(null, {\n\t                matlabStatus: status\n\t            })\n\t        })\n\t    }\n\t    /**\n", "     *\n\t     * @returns True if the MATLAB connection timing setting is set to never. Returns false otherwise.\n\t     */\n\t    private async _isMatlabConnectionTimingNever (): Promise<boolean> {\n\t        const connectionTiming = (await ConfigurationManager.getConfiguration()).matlabConnectionTiming\n\t        return connectionTiming === ConnectionTiming.Never\n\t    }\n\t}\n\t/**\n\t * Represents a MATLAB process\n", " */\n\tclass MatlabProcess {\n\t    private _matlabProcess?: ChildProcess\n\t    private _matlabConnection: MatlabConnection | null = null\n\t    private _matlabPid = 0\n\t    private _isReady = false // Whether MATLAB is ready for communication\n\t    isValid = true // Gets set to false when the process is terminated\n\t    isExistingInstance = false\n\t    constructor (private readonly _connection: _Connection) {}\n\t    /**\n", "     * Gets the connection to MATLAB, if one exists.\n\t     *\n\t     * @returns The MATLAB connection, or null if none exists\n\t     */\n\t    getConnection (): MatlabConnection | null {\n\t        return this._matlabConnection\n\t    }\n\t    /**\n\t     Gets whether or not MATLAB is ready for communication\n\t     * @returns True if MATLAB can be communicated with, false otherwise\n", "     */\n\t    isMatlabReady (): boolean {\n\t        return this.isValid && this._isReady\n\t    }\n\t    /**\n\t     * Shuts down the MATLAB process\n\t     */\n\t    shutdown (): void {\n\t        if (!this.isValid) {\n\t            return\n", "        }\n\t        if (this.isExistingInstance) {\n\t            // Only want to close the connection\n\t            this._matlabConnection?.close()\n\t        } else {\n\t            // Close connection and kill MATLAB process\n\t            if (os.platform() === 'win32' && this._matlabPid > 0) {\n\t                // Need to kill the child process which is launched on Windows\n\t                process.kill(this._matlabPid)\n\t            }\n", "            this._matlabConnection?.close()\n\t            this._matlabProcess?.kill()\n\t        }\n\t        this.isValid = false\n\t        LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.DISCONNECTED)\n\t        reportTelemetryAction(Actions.ShutdownMatlab)\n\t    }\n\t    /**\n\t     * Attempts to launch a new instance of MATLAB\n\t     */\n", "    async launchMatlab (): Promise<void> {\n\t        LifecycleNotificationHelper.didMatlabLaunchFail = false\n\t        LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.CONNECTING)\n\t        return await new Promise<void>(resolve => {\n\t            const outFile = path.join(Logger.logDir, 'matlabls_conn.json')\n\t            if (!fs.existsSync(outFile)) {\n\t                fs.writeFileSync(outFile, '', { mode: '600' })\n\t            }\n\t            fs.watchFile(outFile, () => {\n\t                Logger.log('Started MATLAB')\n", "                this._isReady = true\n\t                const data = fs.readFileSync(outFile)\n\t                const info = JSON.parse(data.toString())\n\t                this._matlabPid = info.matlabPid\n\t                const matlabRelease = info.matlabRelease as string // e.g. R2023a\n\t                this._matlabConnection?.initialize().then(() => {\n\t                    fs.unwatchFile(outFile)\n\t                    LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.CONNECTED)\n\t                    reportTelemetryAction(Actions.StartMatlab, matlabRelease)\n\t                    resolve()\n", "                }).catch(() => {\n\t                    Logger.error('Failed to connect to MATLAB')\n\t                    reportTelemetryAction(Actions.StartMatlab, 'Failed to connect to MATLAB')\n\t                })\n\t            })\n\t            void this._launchMatlabProcess(outFile)\n\t        })\n\t    }\n\t    /**\n\t     * Attempts to connect to an existing instance of MATLAB at the given URL.\n", "     *\n\t     * @param url The URL at which to find MATLAB\n\t     */\n\t    async connectToMatlab (url: string): Promise<void> {\n\t        LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.CONNECTING)\n\t        this._matlabConnection = await MatlabCommunicationManager.connectToExistingMatlab(url)\n\t        this._matlabConnection.setLifecycleListener(lifecycleEvent => {\n\t            if (lifecycleEvent === LifecycleEventType.CONNECTED) {\n\t                this._isReady = true\n\t                LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.CONNECTED)\n", "            } else if (lifecycleEvent === LifecycleEventType.DISCONNECTED) {\n\t                // Connection failed - retry after delay\n\t                this._matlabConnection?.close()\n\t                this._matlabConnection = null\n\t                this._isReady = false\n\t                LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.DISCONNECTED)\n\t                setTimeout(() => {\n\t                    void this.connectToMatlab(url)\n\t                }, 1000)\n\t            }\n", "        })\n\t        await this._matlabConnection.initialize()\n\t    }\n\t    /**\n\t     * Launches a MATLAB process.\n\t     *\n\t     * @param outFile The file in which MATLAB should output connection details\n\t     */\n\t    private async _launchMatlabProcess (outFile: string): Promise<void> {\n\t        const { command, args } = await this._getMatlabLaunchCommand(outFile)\n", "        Logger.log('Launching MATLAB...')\n\t        const matlabProcessInfo = await MatlabCommunicationManager.connectToNewMatlab(command, args, Logger.logDir)\n\t        if (matlabProcessInfo == null) {\n\t            Logger.error(`Error launching MATLAB with command: ${command}`)\n\t            this.isValid = false\n\t            LifecycleNotificationHelper.didMatlabLaunchFail = true\n\t            LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.DISCONNECTED)\n\t            NotificationService.sendNotification(Notification.MatlabLaunchFailed)\n\t            return\n\t        }\n", "        const { matlabProcess, matlabConnection } = matlabProcessInfo\n\t        this._matlabProcess = matlabProcess\n\t        this._matlabConnection = matlabConnection\n\t        // Handle messages from MATLAB's standard err channel. Because MATLAB is launched\n\t        // with the -log flag, all of MATLAB's output is pushed through stderr. Write this\n\t        // to a log file.\n\t        this._matlabProcess.stderr?.on('data', data => {\n\t            const stderrStr: string = data.toString().trim()\n\t            Logger.writeMatlabLog(stderrStr)\n\t        })\n", "        /**\n\t         * Handles the MATLAB process being terminated unexpectedly.\n\t         * This could include the user killing the process.\n\t         */\n\t        this._matlabProcess.on('close', () => {\n\t            // Close connection\n\t            Logger.log('MATLAB process terminated')\n\t            this._matlabConnection?.close()\n\t            this.isValid = false\n\t            LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.DISCONNECTED)\n", "        })\n\t        // Handles errors with the MATLAB process\n\t        this._matlabProcess.on('error', error => {\n\t            Logger.error(`Error launching MATLAB: ${error.message}`)\n\t            Logger.error(`Error launching MATLAB: ${error.name}`)\n\t            if (error.stack != null) {\n\t                Logger.error(`Error launching MATLAB: ${error.stack}`)\n\t            }\n\t            LifecycleNotificationHelper.didMatlabLaunchFail = true\n\t            NotificationService.sendNotification(Notification.MatlabLaunchFailed)\n", "        })\n\t        this._matlabConnection.setLifecycleListener(lifecycleEvent => {\n\t            if (lifecycleEvent === LifecycleEventType.DISCONNECTED) {\n\t                Logger.warn('Error while communicating with MATLAB - disconnecting')\n\t                this._matlabConnection?.close()\n\t                this.isValid = false\n\t                LifecycleNotificationHelper.notifyConnectionStatusChange(ConnectionState.DISCONNECTED)\n\t                reportTelemetryAction(Actions.ShutdownMatlab, 'Error while communicating with MATLAB')\n\t            }\n\t        })\n", "    }\n\t    /**\n\t     * Gets the command with which MATLAB should be launched.\n\t     *\n\t     * @param outFile The file in which MATLAB should output connection details\n\t     * @returns The matlab launch command\n\t     */\n\t    private async _getMatlabLaunchCommand (outFile: string): Promise<{ command: string, args: string[] }> {\n\t        const matlabInstallPath = (await ConfigurationManager.getConfiguration()).installPath\n\t        let command = 'matlab'\n", "        if (matlabInstallPath !== '') {\n\t            command = path.normalize(path.join(\n\t                matlabInstallPath,\n\t                'bin',\n\t                'matlab'\n\t            ))\n\t        }\n\t        const args = [\n\t            '-log',\n\t            '-memmgr', 'release', // Memory manager\n", "            '-noAppIcon', // Hide MATLAB application icon in taskbar/dock, if applicable\n\t            '-nosplash', // Hide splash screen\n\t            '-r', `addpath(fullfile('${__dirname}', '..', 'matlab')); initmatlabls('${outFile}')`, // Startup command\n\t            '-useStartupFolderPref' // Startup folder flag\n\t        ]\n\t        if (os.platform() === 'win32') {\n\t            args.push('-noDisplayDesktop') // Workaround for '-nodesktop' on Windows until a better solution is implemented\n\t            args.push('-wait')\n\t        } else {\n\t            args.push('-nodesktop')\n", "        }\n\t        const argsFromSettings = ConfigurationManager.getArgument(Argument.MatlabLaunchCommandArguments) ?? null\n\t        if (argsFromSettings != null) {\n\t            args.push(argsFromSettings)\n\t        }\n\t        return {\n\t            command,\n\t            args\n\t        }\n\t    }\n", "}\n\texport default new MatlabLifecycleManager()\n"]}
{"filename": "src/lifecycle/ConfigurationManager.ts", "chunked_list": ["// Copyright 2022 - 2023 The MathWorks, Inc.\n\timport { ClientCapabilities, DidChangeConfigurationNotification, DidChangeConfigurationParams } from 'vscode-languageserver'\n\timport { reportTelemetrySettingsChange } from '../logging/TelemetryUtils'\n\timport { connection } from '../server'\n\timport { getCliArgs } from '../utils/CliUtils'\n\texport enum Argument {\n\t    // Basic arguments\n\t    MatlabLaunchCommandArguments = 'matlabLaunchCommandArgs',\n\t    MatlabInstallationPath = 'matlabInstallPath',\n\t    MatlabConnectionTiming = 'matlabConnectionTiming',\n", "    ShouldIndexWorkspace = 'indexWorkspace',\n\t    // Advanced arguments\n\t    MatlabUrl = 'matlabUrl'\n\t}\n\texport enum ConnectionTiming {\n\t    OnStart = 'onStart',\n\t    OnDemand = 'onDemand',\n\t    Never = 'never'\n\t}\n\tinterface CliArguments { \n", "    [Argument.MatlabLaunchCommandArguments]: string\n\t    [Argument.MatlabUrl]: string\n\t}\n\tinterface Settings {\n\t    installPath: string\n\t    matlabConnectionTiming: ConnectionTiming\n\t    indexWorkspace: boolean\n\t    telemetry: boolean\n\t}\n\ttype SettingName = 'installPath' | 'matlabConnectionTiming' | 'indexWorkspace' | 'telemetry'\n", "const SETTING_NAMES: SettingName[] = [\n\t    'installPath',\n\t    'matlabConnectionTiming',\n\t    'indexWorkspace',\n\t    'telemetry'\n\t]\n\tclass ConfigurationManager {\n\t    private configuration: Settings | null = null\n\t    private readonly defaultConfiguration: Settings\n\t    private globalSettings: Settings\n", "    // Holds additional command line arguments that are not part of the configuration\n\t    private readonly additionalArguments: CliArguments\n\t    private hasConfigurationCapability = false\n\t    constructor () {\n\t        const cliArgs = getCliArgs()\n\t        this.defaultConfiguration = {\n\t            installPath: '',\n\t            matlabConnectionTiming: ConnectionTiming.OnStart,\n\t            indexWorkspace: false,\n\t            telemetry: true\n", "        }\n\t        this.globalSettings = {\n\t            installPath: cliArgs[Argument.MatlabInstallationPath] ?? this.defaultConfiguration.installPath,\n\t            matlabConnectionTiming: cliArgs[Argument.MatlabConnectionTiming] as ConnectionTiming ?? this.defaultConfiguration.matlabConnectionTiming,\n\t            indexWorkspace: cliArgs[Argument.ShouldIndexWorkspace] ?? this.defaultConfiguration.indexWorkspace,\n\t            telemetry: this.defaultConfiguration.telemetry\n\t        }\n\t        this.additionalArguments = {\n\t            [Argument.MatlabLaunchCommandArguments]: cliArgs[Argument.MatlabLaunchCommandArguments] ?? '',\n\t            [Argument.MatlabUrl]: cliArgs[Argument.MatlabUrl] ?? ''\n", "        }\n\t    }\n\t    /**\n\t     * Sets up the configuration manager\n\t     *\n\t     * @param capabilities The client capabilities\n\t     */\n\t    setup (capabilities: ClientCapabilities): void {\n\t        this.hasConfigurationCapability = capabilities.workspace?.configuration != null\n\t        if (this.hasConfigurationCapability) {\n", "            // Register for configuration changes\n\t            void connection.client.register(DidChangeConfigurationNotification.type)\n\t        }\n\t        connection.onDidChangeConfiguration(params => { void this.handleConfigurationChanged(params) })\n\t    }\n\t    /**\n\t     * Gets the configuration for the langauge server\n\t     *\n\t     * @returns The current configuration\n\t     */\n", "    async getConfiguration (): Promise<Settings> {\n\t        if (this.hasConfigurationCapability) {\n\t            if (this.configuration == null) {\n\t                this.configuration = await connection.workspace.getConfiguration('MATLAB') as Settings\n\t            }\n\t            return this.configuration\n\t        }\n\t        return this.globalSettings\n\t    }\n\t    /**\n", "     * Gets the value of the given argument\n\t     *\n\t     * @param argument The argument\n\t     * @returns The argument's value\n\t     */\n\t    getArgument (argument: Argument.MatlabLaunchCommandArguments | Argument.MatlabUrl): string {\n\t        return this.additionalArguments[argument]\n\t    }\n\t    /**\n\t     * Handles a change in the configuration\n", "     * @param params The configuration changed params\n\t     */\n\t    private async handleConfigurationChanged (params: DidChangeConfigurationParams): Promise<void> {\n\t        let oldConfig: Settings | null\n\t        let newConfig: Settings\n\t        if (this.hasConfigurationCapability) {\n\t            oldConfig = this.configuration\n\t            // Clear cached configuration\n\t            this.configuration = null\n\t            // Force load new configuration\n", "            newConfig = await this.getConfiguration()\n\t        } else {\n\t            oldConfig = this.globalSettings\n\t            this.globalSettings = params.settings?.matlab ?? this.defaultConfiguration\n\t            newConfig = this.globalSettings\n\t        }\n\t        this.compareSettingChanges(oldConfig, newConfig)\n\t    }\n\t    private compareSettingChanges (oldConfiguration: Settings | null, newConfiguration: Settings): void {\n\t        if (oldConfiguration == null) {\n", "            // Not yet initialized\n\t            return\n\t        }\n\t        for (let i = 0; i < SETTING_NAMES.length; i++) {\n\t            const settingName = SETTING_NAMES[i]\n\t            const oldValue = oldConfiguration[settingName]\n\t            const newValue = newConfiguration[settingName]\n\t            if (oldValue !== newValue) {\n\t                reportTelemetrySettingsChange(settingName, newValue.toString(), oldValue.toString())\n\t            }\n", "        }\n\t    }\n\t}\n\texport default new ConfigurationManager()\n"]}
