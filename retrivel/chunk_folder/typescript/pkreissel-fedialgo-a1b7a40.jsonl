{"filename": "dist/Storage.d.ts", "chunked_list": ["import { serverFeatureType, accFeatureType, weightsType } from \"./types\";\n\timport { mastodon } from \"masto\";\n\texport declare enum Key {\n\t    TOP_FAVS = \"favs\",\n\t    TOP_REBLOGS = \"reblogs\",\n\t    TOP_INTERACTS = \"interacts\",\n\t    CORE_SERVER = \"coreServer\",\n\t    USER = \"algouser\",\n\t    WEIGHTS = \"weights\",\n\t    OPENINGS = \"openings\"\n", "}\n\ttype StorageValue = serverFeatureType | accFeatureType | mastodon.v1.Account | weightsType | string;\n\texport default class Storage {\n\t    protected static get(key: Key, groupedByUser?: boolean, suffix?: string): Promise<StorageValue>;\n\t    protected static set(key: Key, value: StorageValue, groupedByUser?: boolean, suffix?: string): Promise<void>;\n\t    static suffix(key: Key, suffix: any): string;\n\t    protected static remove(key: Key, groupedByUser?: boolean, suffix?: string): Promise<void>;\n\t    protected static prefix(key: string): Promise<string>;\n\t    static logOpening(): Promise<void>;\n\t    static getOpenings(): Promise<number>;\n", "    static getIdentity(): Promise<mastodon.v1.Account>;\n\t    static setIdentity(user: mastodon.v1.Account): Promise<void>;\n\t}\n\texport {};\n"]}
{"filename": "dist/types.d.ts", "chunked_list": ["import { mastodon } from 'masto';\n\texport interface weightsType {\n\t    [key: string]: number;\n\t}\n\texport type accFeatureType = {\n\t    [key: mastodon.v1.Account[\"acct\"]]: number;\n\t};\n\texport type serverFeatureType = {\n\t    [key: mastodon.v1.Instance[\"uri\"]]: number;\n\t};\n", "export interface StatusType extends mastodon.v1.Status {\n\t    topPost?: boolean;\n\t    scores?: weightsType;\n\t    value?: number;\n\t    reblog?: StatusType;\n\t    reblogBy?: string;\n\t}\n\texport type FeedFetcher = (api: mastodon.Client) => Promise<StatusType[]>;\n\texport type Scorer = (api: mastodon.Client, status: StatusType) => number;\n"]}
{"filename": "dist/index.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\timport { FeedFetcher, StatusType, weightsType } from \"./types\";\n\timport { favsFeatureScorer, interactsFeatureScorer, reblogsFeatureScorer, diversityFeedScorer, reblogsFeedScorer, FeatureScorer, FeedScorer, topPostFeatureScorer } from \"./scorer\";\n\timport getHomeFeed from \"./feeds/homeFeed\";\n\texport default class TheAlgorithm {\n\t    user: mastodon.v1.Account;\n\t    fetchers: (typeof getHomeFeed)[];\n\t    featureScorer: (favsFeatureScorer | interactsFeatureScorer | reblogsFeatureScorer | topPostFeatureScorer)[];\n\t    feedScorer: (diversityFeedScorer | reblogsFeedScorer)[];\n\t    feed: StatusType[];\n", "    api: mastodon.Client;\n\t    constructor(api: mastodon.Client, user: mastodon.v1.Account, valueCalculator?: (((scores: weightsType) => Promise<number>) | null));\n\t    getFeedAdvanced(fetchers: Array<FeedFetcher>, featureScorer: Array<FeatureScorer>, feedScorer: Array<FeedScorer>): Promise<StatusType[]>;\n\t    getFeed(): Promise<StatusType[]>;\n\t    private _getScoreObj;\n\t    private _getValueFromScores;\n\t    getWeightNames(): string[];\n\t    setDefaultWeights(): Promise<void>;\n\t    getWeightDescriptions(): string[];\n\t    getWeights(): Promise<weightsType>;\n", "    setWeights(weights: weightsType): Promise<StatusType[]>;\n\t    getDescription(verboseName: string): string;\n\t    weightAdjust(statusWeights: weightsType): Promise<weightsType | undefined>;\n\t}\n"]}
{"filename": "dist/Paginator.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\timport { StatusType } from \"./types\";\n\texport declare class StaticArrayPaginator implements AsyncIterableIterator<StatusType[]> {\n\t    private currentIndex;\n\t    private pageSize;\n\t    private dataArray;\n\t    private algo;\n\t    constructor(api: mastodon.Client, user: mastodon.v1.Account, pageSize?: number);\n\t    next(): Promise<IteratorResult<StatusType[]>>;\n\t    [Symbol.asyncIterator](): this;\n", "}\n"]}
{"filename": "dist/features/favsFeature.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\timport { accFeatureType } from \"../types\";\n\texport default function favFeature(api: mastodon.Client): Promise<accFeatureType>;\n"]}
{"filename": "dist/features/FeatureStore.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\timport { serverFeatureType, accFeatureType } from \"../types\";\n\timport Storage from \"../Storage\";\n\texport default class FeatureStorage extends Storage {\n\t    static getTopFavs(api: mastodon.Client): Promise<accFeatureType>;\n\t    static getTopReblogs(api: mastodon.Client): Promise<accFeatureType>;\n\t    static getTopInteracts(api: mastodon.Client): Promise<accFeatureType>;\n\t    static getCoreServer(api: mastodon.Client): Promise<serverFeatureType>;\n\t}\n"]}
{"filename": "dist/features/reblogsFeature.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\texport default function getReblogsFeature(api: mastodon.Client): Promise<any>;\n"]}
{"filename": "dist/features/interactsFeature.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\timport { accFeatureType } from \"../types\";\n\texport default function interactFeature(api: mastodon.Client): Promise<accFeatureType>;\n"]}
{"filename": "dist/features/coreServerFeature.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\timport { serverFeatureType } from \"../types\";\n\texport default function coreServerFeature(api: mastodon.Client, user: mastodon.v1.Account): Promise<serverFeatureType>;\n"]}
{"filename": "dist/weights/weightsStore.d.ts", "chunked_list": ["import { weightsType } from \"../types\";\n\timport Storage from \"../Storage\";\n\texport default class weightsStore extends Storage {\n\t    static getWeight(verboseName: string): Promise<weightsType>;\n\t    static setWeights(weights: weightsType, verboseName: string): Promise<void>;\n\t    static getWeightsMulti(verboseNames: string[]): Promise<weightsType>;\n\t    static setWeightsMulti(weights: weightsType): Promise<void>;\n\t    static defaultFallback(verboseName: string, defaultWeight: number): Promise<boolean>;\n\t}\n"]}
{"filename": "dist/scorer/index.d.ts", "chunked_list": ["import favsFeatureScorer from \"./feature/favsFeatureScorer\";\n\timport interactsFeatureScorer from \"./feature/interactsFeatureScorer\";\n\timport reblogsFeatureScorer from \"./feature/reblogsFeatureScorer\";\n\timport topPostFeatureScorer from \"./feature/topPostFeatureScorer\";\n\timport diversityFeedScorer from \"./feed/diversityFeedScorer\";\n\timport reblogsFeedScorer from \"./feed/reblogsFeedScorer\";\n\timport FeedScorer from \"./FeedScorer\";\n\timport FeatureScorer from \"./FeatureScorer\";\n\texport { favsFeatureScorer, interactsFeatureScorer, reblogsFeatureScorer, topPostFeatureScorer, diversityFeedScorer, reblogsFeedScorer, FeedScorer, FeatureScorer };\n"]}
{"filename": "dist/scorer/FeedScorer.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\timport { StatusType } from \"../types\";\n\texport default class FeedScorer {\n\t    private _verboseName;\n\t    private _isReady;\n\t    private _description;\n\t    private _defaultWeight;\n\t    features: any;\n\t    constructor(verboseName: string, description?: string, defaultWeight?: number);\n\t    setFeed(feed: StatusType[]): Promise<void>;\n", "    feedExtractor(feed: StatusType[]): any;\n\t    score(status: mastodon.v1.Status): Promise<number>;\n\t    getVerboseName(): string;\n\t    getDescription(): string;\n\t    getDefaultWeight(): number;\n\t}\n"]}
{"filename": "dist/scorer/FeatureScorer.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\timport { StatusType, accFeatureType } from \"../types\";\n\tinterface RankParams {\n\t    featureGetter: (api: mastodon.Client) => Promise<accFeatureType>;\n\t    verboseName: string;\n\t    description?: string;\n\t    defaultWeight?: number;\n\t}\n\texport default class FeatureScorer {\n\t    featureGetter: (api: mastodon.Client) => Promise<accFeatureType>;\n", "    private _verboseName;\n\t    private _isReady;\n\t    private _description;\n\t    feature: accFeatureType;\n\t    private _defaultWeight;\n\t    constructor(params: RankParams);\n\t    getFeature(api: mastodon.Client): Promise<void>;\n\t    score(api: mastodon.Client, status: StatusType): Promise<number>;\n\t    getVerboseName(): string;\n\t    getDescription(): string;\n", "    getDefaultWeight(): number;\n\t}\n\texport {};\n"]}
{"filename": "dist/scorer/feed/diversityFeedScorer.d.ts", "chunked_list": ["import FeedScorer from \"../FeedScorer\";\n\timport { StatusType } from \"../../types\";\n\texport default class diversityFeedScorer extends FeedScorer {\n\t    constructor();\n\t    feedExtractor(feed: StatusType[]): any;\n\t    score(status: StatusType): Promise<any>;\n\t}\n"]}
{"filename": "dist/scorer/feed/reblogsFeedScorer.d.ts", "chunked_list": ["import FeedScorer from \"../FeedScorer\";\n\timport { StatusType } from \"../../types\";\n\texport default class reblogsFeedScorer extends FeedScorer {\n\t    constructor();\n\t    feedExtractor(feed: StatusType[]): any;\n\t    score(status: StatusType): Promise<any>;\n\t}\n"]}
{"filename": "dist/scorer/feature/favsFeatureScorer.d.ts", "chunked_list": ["import FeatureScorer from '../FeatureScorer';\n\timport { StatusType } from '../../types';\n\timport { mastodon } from 'masto';\n\texport default class favsFeatureScorer extends FeatureScorer {\n\t    constructor();\n\t    score(api: mastodon.Client, status: StatusType): Promise<number>;\n\t}\n"]}
{"filename": "dist/scorer/feature/topPostFeatureScorer.d.ts", "chunked_list": ["import FeatureScorer from '../FeatureScorer';\n\timport { StatusType } from \"../../types\";\n\timport { mastodon } from \"masto\";\n\texport default class topPostFeatureScorer extends FeatureScorer {\n\t    constructor();\n\t    score(api: mastodon.Client, status: StatusType): Promise<0 | 1>;\n\t}\n"]}
{"filename": "dist/scorer/feature/reblogsFeatureScorer.d.ts", "chunked_list": ["import FeatureScorer from \"../FeatureScorer\";\n\timport { StatusType } from \"../../types\";\n\timport { mastodon } from \"masto\";\n\texport default class reblogsFeatureScorer extends FeatureScorer {\n\t    constructor();\n\t    score(api: mastodon.Client, status: StatusType): Promise<number>;\n\t}\n"]}
{"filename": "dist/scorer/feature/interactsFeatureScorer.d.ts", "chunked_list": ["import FeatureScorer from \"../FeatureScorer\";\n\timport { StatusType } from \"../../types\";\n\timport { mastodon } from \"masto\";\n\texport default class interactsFeatureScorer extends FeatureScorer {\n\t    constructor();\n\t    score(api: mastodon.Client, status: StatusType): Promise<number>;\n\t}\n"]}
{"filename": "dist/feeds/homeFeed.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\texport default function getHomeFeed(api: mastodon.Client, user: mastodon.v1.Account): Promise<any[]>;\n"]}
{"filename": "dist/feeds/topPostsFeed.d.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\texport default function getTopPostFeed(api: mastodon.Client): Promise<mastodon.v1.Status[]>;\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { mastodon } from 'masto';\n\texport interface weightsType {\n\t    [key: string]: number; // Replace 'any' with the desired value type (e.g., string, number, etc.)\n\t}\n\texport type accFeatureType = {\n\t    [key: mastodon.v1.Account[\"acct\"]]: number; // Replace 'any' with the desired value type (e.g., string, number, etc.)\n\t}\n\texport type serverFeatureType = {\n\t    [key: mastodon.v1.Instance[\"uri\"]]: number; // Replace 'any' with the desired value type (e.g., string, number, etc.)\n\t}\n", "export interface StatusType extends mastodon.v1.Status {\n\t    topPost?: boolean;\n\t    scores?: weightsType;\n\t    value?: number;\n\t    reblog?: StatusType;\n\t    reblogBy?: string;\n\t}\n\texport type FeedFetcher = (api: mastodon.Client) => Promise<StatusType[]>;\n\texport type Scorer = (api: mastodon.Client, status: StatusType) => number;"]}
{"filename": "src/index.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\timport { FeedFetcher, Scorer, StatusType, weightsType } from \"./types\";\n\timport {\n\t    favsFeatureScorer,\n\t    interactsFeatureScorer,\n\t    reblogsFeatureScorer,\n\t    diversityFeedScorer,\n\t    reblogsFeedScorer,\n\t    FeatureScorer,\n\t    FeedScorer,\n", "    topPostFeatureScorer\n\t} from \"./scorer\";\n\timport weightsStore from \"./weights/weightsStore\";\n\timport getHomeFeed from \"./feeds/homeFeed\";\n\timport topPostsFeed from \"./feeds/topPostsFeed\";\n\timport Storage from \"./Storage\";\n\timport { StaticArrayPaginator } from \"./Paginator\"\n\texport default class TheAlgorithm {\n\t    user: mastodon.v1.Account;\n\t    fetchers = [getHomeFeed, topPostsFeed]\n", "    featureScorer = [new favsFeatureScorer(), new reblogsFeatureScorer(), new interactsFeatureScorer(), new topPostFeatureScorer()]\n\t    feedScorer = [new reblogsFeedScorer(), new diversityFeedScorer()]\n\t    feed: StatusType[] = [];\n\t    api: mastodon.Client;\n\t    constructor(api: mastodon.Client, user: mastodon.v1.Account, valueCalculator: (((scores: weightsType) => Promise<number>) | null) = null) {\n\t        this.api = api;\n\t        this.user = user;\n\t        Storage.setIdentity(user);\n\t        Storage.logOpening();\n\t        if (valueCalculator) {\n", "            this._getValueFromScores = valueCalculator;\n\t        }\n\t        this.setDefaultWeights();\n\t    }\n\t    async getFeedAdvanced(\n\t        fetchers: Array<FeedFetcher>,\n\t        featureScorer: Array<FeatureScorer>,\n\t        feedScorer: Array<FeedScorer>\n\t    ) {\n\t        this.fetchers = fetchers;\n", "        this.featureScorer = featureScorer;\n\t        this.feedScorer = feedScorer;\n\t        return this.getFeed();\n\t    }\n\t    async getFeed(): Promise<StatusType[]> {\n\t        const { fetchers, featureScorer, feedScorer } = this;\n\t        const response = await Promise.all(fetchers.map(fetcher => fetcher(this.api, this.user)))\n\t        this.feed = response.flat();\n\t        // Load and Prepare Features\n\t        await Promise.all(featureScorer.map(scorer => scorer.getFeature(this.api)));\n", "        await Promise.all(feedScorer.map(scorer => scorer.setFeed(this.feed)));\n\t        // Get Score Names\n\t        const scoreNames = featureScorer.map(scorer => scorer.getVerboseName());\n\t        const feedScoreNames = feedScorer.map(scorer => scorer.getVerboseName());\n\t        // Score Feed\n\t        let scoredFeed: StatusType[] = []\n\t        for (const status of this.feed) {\n\t            // Load Scores for each status\n\t            const featureScore = await Promise.all(featureScorer.map(scorer => scorer.score(this.api, status)));\n\t            const feedScore = await Promise.all(feedScorer.map(scorer => scorer.score(status)));\n", "            // Turn Scores into Weight Objects\n\t            const featureScoreObj = this._getScoreObj(scoreNames, featureScore);\n\t            const feedScoreObj = this._getScoreObj(feedScoreNames, feedScore);\n\t            const scoreObj = { ...featureScoreObj, ...feedScoreObj };\n\t            // Add Weight Object to Status\n\t            status[\"scores\"] = scoreObj;\n\t            status[\"value\"] = await this._getValueFromScores(scoreObj);\n\t            scoredFeed.push(status);\n\t        }\n\t        // Remove Replies, Stuff Already Retweeted, and Nulls\n", "        scoredFeed = scoredFeed\n\t            .filter((item: StatusType) => item != undefined)\n\t            .filter((item: StatusType) => item.inReplyToId === null)\n\t            .filter((item: StatusType) => item.content.includes(\"RT @\") === false)\n\t            .filter((item: StatusType) => !(item?.reblog?.reblogged ?? false))\n\t        // Add Time Penalty\n\t        scoredFeed = scoredFeed.map((item: StatusType) => {\n\t            const seconds = Math.floor((new Date().getTime() - new Date(item.createdAt).getTime()) / 1000);\n\t            const timediscount = Math.pow((1 + 0.7 * 0.2), -Math.pow((seconds / 3600), 2));\n\t            item.value = (item.value ?? 0) * timediscount\n", "            return item;\n\t        })\n\t        // Sort Feed\n\t        scoredFeed = scoredFeed.sort((a, b) => (b.value ?? 0) - (a.value ?? 0));\n\t        //Remove duplicates\n\t        scoredFeed = [...new Map(scoredFeed.map((item: StatusType) => [item[\"uri\"], item])).values()];\n\t        this.feed = scoredFeed\n\t        console.log(this.feed);\n\t        return this.feed;\n\t    }\n", "    private _getScoreObj(scoreNames: string[], scores: number[]): weightsType {\n\t        return scoreNames.reduce((obj: weightsType, cur, i) => {\n\t            obj[cur] = scores[i];\n\t            return obj;\n\t        }, {});\n\t    }\n\t    private async _getValueFromScores(scores: weightsType): Promise<number> {\n\t        const weights = await weightsStore.getWeightsMulti(Object.keys(scores));\n\t        const weightedScores = Object.keys(scores).reduce((obj: number, cur) => {\n\t            obj = obj + (scores[cur] * weights[cur] ?? 0)\n", "            return obj;\n\t        }, 0);\n\t        return weightedScores;\n\t    }\n\t    getWeightNames(): string[] {\n\t        const scorers = [...this.featureScorer, ...this.feedScorer];\n\t        return [...scorers.map(scorer => scorer.getVerboseName())]\n\t    }\n\t    async setDefaultWeights(): Promise<void> {\n\t        //Set Default Weights if they don't exist\n", "        const scorers = [...this.featureScorer, ...this.feedScorer];\n\t        Promise.all(scorers.map(scorer => weightsStore.defaultFallback(scorer.getVerboseName(), scorer.getDefaultWeight())))\n\t    }\n\t    getWeightDescriptions(): string[] {\n\t        const scorers = [...this.featureScorer, ...this.feedScorer];\n\t        return [...scorers.map(scorer => scorer.getDescription())]\n\t    }\n\t    async getWeights(): Promise<weightsType> {\n\t        const verboseNames = this.getWeightNames();\n\t        const weights = await weightsStore.getWeightsMulti(verboseNames);\n", "        return weights;\n\t    }\n\t    async setWeights(weights: weightsType): Promise<StatusType[]> {\n\t        await weightsStore.setWeightsMulti(weights);\n\t        const scoredFeed: StatusType[] = []\n\t        for (const status of this.feed) {\n\t            if (!status[\"scores\"]) {\n\t                return this.getFeed();\n\t            }\n\t            status[\"value\"] = await this._getValueFromScores(status[\"scores\"]);\n", "            scoredFeed.push(status);\n\t        }\n\t        this.feed = scoredFeed.sort((a, b) => (b.value ?? 0) - (a.value ?? 0));\n\t        return this.feed;\n\t    }\n\t    getDescription(verboseName: string): string {\n\t        const scorers = [...this.featureScorer, ...this.feedScorer];\n\t        const scorer = scorers.find(scorer => scorer.getVerboseName() === verboseName);\n\t        if (scorer) {\n\t            return scorer.getDescription();\n", "        }\n\t        return \"\";\n\t    }\n\t    async weightAdjust(statusWeights: weightsType): Promise<weightsType | undefined> {\n\t        //Adjust Weights based on user interaction\n\t        if (statusWeights == undefined) return;\n\t        const mean = Object.values(statusWeights).reduce((accumulator, currentValue) => accumulator + Math.abs(currentValue), 0) / Object.values(statusWeights).length;\n\t        const currentWeight: weightsType = await this.getWeights()\n\t        const currentMean = Object.values(currentWeight).reduce((accumulator, currentValue) => accumulator + currentValue, 0) / Object.values(currentWeight).length;\n\t        for (let key in currentWeight) {\n", "            let reweight = 1 - (Math.abs(statusWeights[key]) / mean) / (currentWeight[key] / currentMean);\n\t            currentWeight[key] = currentWeight[key] + 0.02 * currentWeight[key] * reweight;\n\t            console.log(reweight);\n\t        }\n\t        await this.setWeights(currentWeight);\n\t        return currentWeight;\n\t    }\n\t}"]}
{"filename": "src/Storage.ts", "chunked_list": ["import AsyncStorage from '@react-native-async-storage/async-storage';\n\timport { serverFeatureType, accFeatureType, weightsType } from \"./types\";\n\timport { mastodon } from \"masto\";\n\texport enum Key {\n\t    TOP_FAVS = 'favs',\n\t    TOP_REBLOGS = 'reblogs',\n\t    TOP_INTERACTS = 'interacts',\n\t    CORE_SERVER = 'coreServer',\n\t    USER = 'algouser',\n\t    WEIGHTS = 'weights',\n", "    OPENINGS = \"openings\",\n\t}\n\ttype StorageValue = serverFeatureType | accFeatureType | mastodon.v1.Account | weightsType | string\n\texport default class Storage {\n\t    protected static async get(key: Key, groupedByUser = true, suffix = \"\"): Promise<StorageValue> {\n\t        const suffixKey = this.suffix(key, suffix);\n\t        const storageKey = groupedByUser ? await this.prefix(suffixKey) : suffixKey;\n\t        const jsonValue = await AsyncStorage.getItem(storageKey);\n\t        const value = jsonValue != null ? JSON.parse(jsonValue) : null;\n\t        return value != null ? value[storageKey] : null;\n", "    }\n\t    protected static async set(key: Key, value: StorageValue, groupedByUser = true, suffix = \"\") {\n\t        const suffixKey = this.suffix(key, suffix);\n\t        const storageKey = groupedByUser ? await this.prefix(suffixKey) : suffixKey;\n\t        const jsonValue = JSON.stringify({ [storageKey]: value })\n\t        await AsyncStorage.setItem(storageKey, jsonValue);\n\t    }\n\t    static suffix(key: Key, suffix: any) {\n\t        if (suffix === \"\") return key;\n\t        return `${key}_${suffix}`;\n", "    }\n\t    protected static async remove(key: Key, groupedByUser = true, suffix = \"\") {\n\t        const suffixKey = this.suffix(key, suffix);\n\t        const storageKey = groupedByUser ? await Storage.prefix(suffixKey) : suffixKey;\n\t        await AsyncStorage.removeItem(storageKey);\n\t    }\n\t    protected static async prefix(key: string) {\n\t        const user = await this.getIdentity();\n\t        return `${user.id}_${key}`;\n\t    }\n", "    static async logOpening() {\n\t        console.log(\"Logging Opening\")\n\t        const openings = parseInt(await this.get(Key.OPENINGS, true) as string);\n\t        if (openings == null || isNaN(openings)) {\n\t            await this.set(Key.OPENINGS, \"1\", true);\n\t        } else {\n\t            await this.set(Key.OPENINGS, (openings + 1).toString(), true);\n\t        }\n\t    }\n\t    static async getOpenings() {\n", "        const openings = parseInt(await this.get(Key.OPENINGS, true) as string);\n\t        return openings;\n\t    }\n\t    static async getIdentity(): Promise<mastodon.v1.Account> {\n\t        const userJson = await AsyncStorage.getItem(Key.USER);\n\t        const user: mastodon.v1.Account = userJson != null ? JSON.parse(userJson) : null;\n\t        return user;\n\t    }\n\t    static async setIdentity(user: mastodon.v1.Account) {\n\t        const userJson = JSON.stringify(user);\n", "        await AsyncStorage.setItem(Key.USER, userJson);\n\t    }\n\t}"]}
{"filename": "src/Paginator.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\timport TheAlgorithm from \"./index\";\n\timport { StatusType } from \"./types\";\n\tinterface PaginationResult<StatusType> {\n\t    data: StatusType[];\n\t    hasNextPage: boolean;\n\t}\n\texport class StaticArrayPaginator implements AsyncIterableIterator<StatusType[]> {\n\t    private currentIndex: number = 0;\n\t    private pageSize: number;\n", "    private dataArray: StatusType[] = [];\n\t    private algo: TheAlgorithm;\n\t    constructor(api: mastodon.Client, user: mastodon.v1.Account, pageSize: number = 10) {\n\t        this.algo = new TheAlgorithm(api, user);\n\t        this.pageSize = pageSize;\n\t    }\n\t    async next(): Promise<IteratorResult<StatusType[]>> {\n\t        if (this.dataArray.length == 0) {\n\t            this.dataArray = await this.algo.getFeed();\n\t        }\n", "        const data: StatusType[] = [];\n\t        let hasNextPage = false;\n\t        const startIndex = this.currentIndex;\n\t        const endIndex = this.currentIndex + this.pageSize;\n\t        const currentData = this.dataArray.slice(startIndex, endIndex);\n\t        currentData.forEach((item) => data.push(item));\n\t        if (endIndex < this.dataArray.length) {\n\t            hasNextPage = true;\n\t        }\n\t        this.currentIndex += this.pageSize;\n", "        return {\n\t            done: !hasNextPage,\n\t            value: data as StatusType[]\n\t        };\n\t    }\n\t    [Symbol.asyncIterator]() {\n\t        return this\n\t    }\n\t}"]}
{"filename": "src/features/coreServerFeature.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\timport { serverFeatureType } from \"../types\";\n\texport default async function coreServerFeature(api: mastodon.Client, user: mastodon.v1.Account): Promise<serverFeatureType> {\n\t    let results: mastodon.v1.Account[] = [];\n\t    let pages = 10;\n\t    for await (const page of api.v1.accounts.listFollowing(user.id, { limit: 80 })) {\n\t        results = results.concat(page)\n\t        pages--;\n\t        if (pages === 0 || results.length < 80) {\n\t            break;\n", "        }\n\t    }\n\t    const serverFrequ = results.reduce((accumulator: serverFeatureType, follower: mastodon.v1.Account) => {\n\t        const server = follower.url.split(\"@\")[0].split(\"https://\")[1];\n\t        if (server in accumulator) {\n\t            accumulator[server] += 1;\n\t        } else {\n\t            accumulator[server] = 1;\n\t        }\n\t        return accumulator\n", "    }, {})\n\t    return serverFrequ;\n\t}"]}
{"filename": "src/features/interactsFeature.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\timport { accFeatureType } from \"../types\";\n\texport default async function interactFeature(api: mastodon.Client): Promise<accFeatureType> {\n\t    let results: any[] = [];\n\t    let pages = 3;\n\t    for await (const page of api.v1.notifications.list({ limit: 80 })) {\n\t        results = results.concat(page)\n\t        pages--;\n\t        if (pages === 0 || results.length < 80) {\n\t            break;\n", "        }\n\t    }\n\t    const interactFrequ = results.reduce((accumulator: any, status: mastodon.v1.Status,) => {\n\t        if (!status.account) return accumulator;\n\t        if (status.account.acct in accumulator) {\n\t            accumulator[status.account.acct] += 1;\n\t        } else {\n\t            accumulator[status.account.acct] = 1;\n\t        }\n\t        return accumulator\n", "    }, {})\n\t    return interactFrequ;\n\t}"]}
{"filename": "src/features/FeatureStore.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\timport { serverFeatureType, accFeatureType } from \"../types\";\n\timport FavsFeature from \"./favsFeature\";\n\timport reblogsFeature from \"./reblogsFeature\";\n\timport interactsFeature from \"./interactsFeature\";\n\timport coreServerFeature from \"./coreServerFeature\";\n\timport Storage, { Key } from \"../Storage\";\n\texport default class FeatureStorage extends Storage {\n\t    static async getTopFavs(api: mastodon.Client): Promise<accFeatureType> {\n\t        const topFavs: accFeatureType = await this.get(Key.TOP_FAVS) as accFeatureType;\n", "        console.log(topFavs);\n\t        if (topFavs != null && await this.getOpenings() < 10) {\n\t            return topFavs;\n\t        } else {\n\t            const favs = await FavsFeature(api);\n\t            await this.set(Key.TOP_FAVS, favs);\n\t            return favs;\n\t        }\n\t    }\n\t    static async getTopReblogs(api: mastodon.Client): Promise<accFeatureType> {\n", "        const topReblogs: accFeatureType = await this.get(Key.TOP_REBLOGS) as accFeatureType;\n\t        console.log(topReblogs);\n\t        if (topReblogs != null && await this.getOpenings() < 10) {\n\t            return topReblogs;\n\t        } else {\n\t            const reblogs = await reblogsFeature(api);\n\t            await this.set(Key.TOP_REBLOGS, reblogs);\n\t            return reblogs;\n\t        }\n\t    }\n", "    static async getTopInteracts(api: mastodon.Client): Promise<accFeatureType> {\n\t        const topInteracts: accFeatureType = await this.get(Key.TOP_INTERACTS) as accFeatureType;\n\t        console.log(topInteracts);\n\t        if (topInteracts != null && await this.getOpenings() < 10) {\n\t            return topInteracts;\n\t        } else {\n\t            const interacts = await interactsFeature(api);\n\t            await this.set(Key.TOP_INTERACTS, interacts);\n\t            return interacts;\n\t        }\n", "    }\n\t    static async getCoreServer(api: mastodon.Client): Promise<serverFeatureType> {\n\t        const coreServer: serverFeatureType = await this.get(Key.CORE_SERVER) as serverFeatureType;\n\t        console.log(coreServer);\n\t        if (coreServer != null && await this.getOpenings() < 10) {\n\t            return coreServer;\n\t        } else {\n\t            const user = await this.getIdentity();\n\t            const server = await coreServerFeature(api, user);\n\t            await this.set(Key.CORE_SERVER, server);\n", "            return server;\n\t        }\n\t    }\n\t}\n"]}
{"filename": "src/features/favsFeature.ts", "chunked_list": ["import { login, mastodon } from \"masto\";\n\timport { accFeatureType } from \"../types\";\n\texport default async function favFeature(api: mastodon.Client): Promise<accFeatureType> {\n\t    let results: mastodon.v1.Status[] = [];\n\t    let pages = 3;\n\t    for await (const page of api.v1.favourites.list({ limit: 80 })) {\n\t        results = results.concat(page)\n\t        pages--;\n\t        if (pages === 0 || results.length < 80) {\n\t            break;\n", "        }\n\t    }\n\t    const favFrequ = results.reduce((accumulator: accFeatureType, status: mastodon.v1.Status,) => {\n\t        if (!status.account) return accumulator;\n\t        if (status.account.acct in accumulator) {\n\t            accumulator[status.account.acct] += 1;\n\t        } else {\n\t            accumulator[status.account.acct] = 1;\n\t        }\n\t        return accumulator\n", "    }, {})\n\t    return favFrequ;\n\t}"]}
{"filename": "src/features/reblogsFeature.ts", "chunked_list": ["import { login, mastodon } from \"masto\";\n\texport default async function getReblogsFeature(api: mastodon.Client) {\n\t    let results: any[] = [];\n\t    let pages = 3;\n\t    for await (const page of api.v1.timelines.listHome({ limit: 80 })) {\n\t        results = results.concat(page)\n\t        pages--;\n\t        if (pages === 0 || results.length < 80) {\n\t            break;\n\t        }\n", "    }\n\t    const reblogFrequ = results.reduce((accumulator: any, status: mastodon.v1.Status) => {\n\t        if (status.reblog) {\n\t            if (status.reblog.account.acct in accumulator) {\n\t                accumulator[status.reblog.account.acct] += 1;\n\t            } else {\n\t                accumulator[status.reblog.account.acct] = 1;\n\t            }\n\t        }\n\t        return accumulator\n", "    }, {})\n\t    return reblogFrequ;\n\t}"]}
{"filename": "src/weights/weightsStore.ts", "chunked_list": ["import { weightsType } from \"../types\";\n\timport Storage, { Key } from \"../Storage\";\n\texport default class weightsStore extends Storage {\n\t    static async getWeight(verboseName: string) {\n\t        const weight = await this.get(Key.WEIGHTS, true, verboseName) as weightsType;\n\t        if (weight != null) {\n\t            return weight;\n\t        }\n\t        return { [verboseName]: 1 };\n\t    }\n", "    static async setWeights(weights: weightsType, verboseName: string) {\n\t        await this.set(Key.WEIGHTS, weights, true, verboseName);\n\t    }\n\t    static async getWeightsMulti(verboseNames: string[]) {\n\t        const weights: weightsType = {}\n\t        for (const verboseName of verboseNames) {\n\t            const weight = await this.getWeight(verboseName);\n\t            weights[verboseName] = weight[verboseName]\n\t        }\n\t        return weights;\n", "    }\n\t    static async setWeightsMulti(weights: weightsType) {\n\t        for (const verboseName in weights) {\n\t            await this.setWeights({ [verboseName]: weights[verboseName] }, verboseName);\n\t        }\n\t    }\n\t    static async defaultFallback(verboseName: string, defaultWeight: number): Promise<boolean> {\n\t        // If the weight is not set, set it to the default weight\n\t        const weight = await this.get(Key.WEIGHTS, true, verboseName) as weightsType;\n\t        if (weight == null) {\n", "            await this.setWeights({ [verboseName]: defaultWeight }, verboseName);\n\t            return true;\n\t        }\n\t        return false;\n\t    }\n\t}"]}
{"filename": "src/scorer/FeatureScorer.ts", "chunked_list": ["import { mastodon } from \"masto\"\n\timport { StatusType, accFeatureType } from \"../types\";\n\tinterface RankParams {\n\t    featureGetter: (api: mastodon.Client) => Promise<accFeatureType>,\n\t    verboseName: string,\n\t    description?: string,\n\t    defaultWeight?: number,\n\t}\n\texport default class FeatureScorer {\n\t    featureGetter: (api: mastodon.Client) => Promise<accFeatureType>;\n", "    private _verboseName: string;\n\t    private _isReady: boolean = false;\n\t    private _description: string = \"\";\n\t    feature: accFeatureType = {};\n\t    private _defaultWeight: number = 1;\n\t    constructor(params: RankParams) {\n\t        this.featureGetter = params.featureGetter;\n\t        this._verboseName = params.verboseName;\n\t        this._description = params.description || \"\";\n\t        this._defaultWeight = params.defaultWeight || 1;\n", "    }\n\t    async getFeature(api: mastodon.Client) {\n\t        this._isReady = true;\n\t        this.feature = await this.featureGetter(api);\n\t    }\n\t    async score(api: mastodon.Client, status: StatusType): Promise<number> {\n\t        if (!this._isReady) {\n\t            await this.getFeature(api);\n\t            this._isReady = true;\n\t        }\n", "        return 0\n\t    }\n\t    getVerboseName() {\n\t        return this._verboseName;\n\t    }\n\t    getDescription() {\n\t        return this._description;\n\t    }\n\t    getDefaultWeight() {\n\t        return this._defaultWeight;\n", "    }\n\t}"]}
{"filename": "src/scorer/FeedScorer.ts", "chunked_list": ["import { mastodon } from \"masto\"\n\timport { StatusType } from \"../types\";\n\texport default class FeedScorer {\n\t    private _verboseName: string = \"BaseScorer\";\n\t    private _isReady: boolean = false;\n\t    private _description: string = \"\";\n\t    private _defaultWeight: number = 1;\n\t    features: any = {};\n\t    constructor(verboseName: string, description?: string, defaultWeight?: number) {\n\t        this._verboseName = verboseName;\n", "        this._description = description || \"\";\n\t        this._defaultWeight = defaultWeight || 1;\n\t    }\n\t    async setFeed(feed: StatusType[]) {\n\t        this.features = await this.feedExtractor(feed);\n\t        this._isReady = true;\n\t    }\n\t    feedExtractor(feed: StatusType[]): any {\n\t        throw new Error(\"Method not implemented.\");\n\t    }\n", "    async score(status: mastodon.v1.Status) {\n\t        if (!this._isReady) {\n\t            throw new Error(\"FeedScorer not ready\");\n\t        }\n\t        return 0;\n\t    }\n\t    getVerboseName() {\n\t        return this._verboseName;\n\t    }\n\t    getDescription() {\n", "        return this._description;\n\t    }\n\t    getDefaultWeight() {\n\t        return this._defaultWeight;\n\t    }\n\t}"]}
{"filename": "src/scorer/index.ts", "chunked_list": ["import favsFeatureScorer from \"./feature/favsFeatureScorer\";\n\timport interactsFeatureScorer from \"./feature/interactsFeatureScorer\";\n\timport reblogsFeatureScorer from \"./feature/reblogsFeatureScorer\";\n\timport topPostFeatureScorer from \"./feature/topPostFeatureScorer\";\n\timport diversityFeedScorer from \"./feed/diversityFeedScorer\";\n\timport reblogsFeedScorer from \"./feed/reblogsFeedScorer\";\n\timport FeedScorer from \"./FeedScorer\";\n\timport FeatureScorer from \"./FeatureScorer\";\n\texport {\n\t    favsFeatureScorer,\n", "    interactsFeatureScorer,\n\t    reblogsFeatureScorer,\n\t    topPostFeatureScorer,\n\t    diversityFeedScorer,\n\t    reblogsFeedScorer,\n\t    FeedScorer,\n\t    FeatureScorer\n\t}"]}
{"filename": "src/scorer/feed/diversityFeedScorer.ts", "chunked_list": ["import FeedScorer from \"../FeedScorer\";\n\timport { StatusType } from \"../../types\";\n\texport default class diversityFeedScorer extends FeedScorer {\n\t    constructor() {\n\t        super(\"Diversity\", \"Downranks posts from users that you have seen a lot of posts from\");\n\t    }\n\t    feedExtractor(feed: StatusType[]) {\n\t        return feed.reduce((obj: any, status) => {\n\t            obj[status.account.acct] = (obj[status.account.acct] || 0) - 1;\n\t            return obj;\n", "        }, {});\n\t    }\n\t    async score(status: StatusType) {\n\t        super.score(status);\n\t        const frequ = this.features[status.account.acct]\n\t        this.features[status.account.acct] = frequ + 1\n\t        return frequ + 1\n\t    }\n\t}"]}
{"filename": "src/scorer/feed/reblogsFeedScorer.ts", "chunked_list": ["import FeedScorer from \"../FeedScorer\";\n\timport { StatusType } from \"../../types\";\n\timport { mastodon } from \"masto\";\n\texport default class reblogsFeedScorer extends FeedScorer {\n\t    constructor() {\n\t        super(\"reblogsFeed\", \"More Weight to posts that are reblogged a lot\", 6);\n\t    }\n\t    feedExtractor(feed: StatusType[]) {\n\t        return feed.reduce((obj: any, status) => {\n\t            if (status.reblog) {\n", "                obj[status.reblog.uri] = (obj[status.reblog.uri] || 0) + 1;\n\t            } else {\n\t                obj[status.uri] = (obj[status.uri] || 0) + 1;\n\t            }\n\t            return obj;\n\t        }, {});\n\t    }\n\t    async score(status: StatusType) {\n\t        super.score(status);\n\t        const features = this.features;\n", "        if (status.reblog) {\n\t            return features[status.reblog.uri] || 0;\n\t        }\n\t        return 0;\n\t    }\n\t}"]}
{"filename": "src/scorer/feature/favsFeatureScorer.ts", "chunked_list": ["import FeatureScorer from '../FeatureScorer'\n\timport favsFeature from '../../features/favsFeature'\n\timport { StatusType, accFeatureType } from '../../types'\n\timport { mastodon } from 'masto'\n\timport FeatureStorage from '../../features/FeatureStore'\n\texport default class favsFeatureScorer extends FeatureScorer {\n\t    constructor() {\n\t        super({\n\t            featureGetter: (api: mastodon.Client) => FeatureStorage.getTopFavs(api),\n\t            verboseName: \"Favs\",\n", "            description: \"Posts that are from your most favorited users\",\n\t            defaultWeight: 1,\n\t        })\n\t    }\n\t    async score(api: mastodon.Client, status: StatusType) {\n\t        return (status.account.acct in this.feature) ? this.feature[status.account.acct] : 0\n\t    }\n\t}"]}
{"filename": "src/scorer/feature/topPostFeatureScorer.ts", "chunked_list": ["import FeatureScorer from '../FeatureScorer';\n\timport { StatusType, accFeatureType } from \"../../types\";\n\timport { mastodon } from \"masto\";\n\timport FeatureStorage from \"../../features/FeatureStore\";\n\texport default class topPostFeatureScorer extends FeatureScorer {\n\t    constructor() {\n\t        super({\n\t            featureGetter: (api: mastodon.Client) => { return Promise.resolve({}) },\n\t            verboseName: \"TopPosts\",\n\t            description: \"Posts that are trending on multiple of your most popular instances\",\n", "            defaultWeight: 1,\n\t        })\n\t    }\n\t    async score(api: mastodon.Client, status: StatusType) {\n\t        return status.topPost ? 1 : 0\n\t    }\n\t}"]}
{"filename": "src/scorer/feature/interactsFeatureScorer.ts", "chunked_list": ["import FeatureScorer from \"../FeatureScorer\";\n\timport { StatusType, accFeatureType } from \"../../types\";\n\timport { mastodon } from \"masto\";\n\timport FeatureStorage from \"../../features/FeatureStore\";\n\texport default class interactsFeatureScorer extends FeatureScorer {\n\t    constructor() {\n\t        super({\n\t            featureGetter: (api: mastodon.Client) => { return FeatureStorage.getTopInteracts(api) },\n\t            verboseName: \"Interacts\",\n\t            description: \"Posts that are from users, that often interact with your posts\",\n", "            defaultWeight: 2,\n\t        })\n\t    }\n\t    async score(api: mastodon.Client, status: StatusType) {\n\t        return (status.account.acct in this.feature) ? this.feature[status.account.acct] : 0\n\t    }\n\t}"]}
{"filename": "src/scorer/feature/reblogsFeatureScorer.ts", "chunked_list": ["import FeatureScorer from \"../FeatureScorer\";\n\timport { StatusType, accFeatureType } from \"../../types\";\n\timport { mastodon } from \"masto\";\n\timport FeatureStorage from \"../../features/FeatureStore\";\n\texport default class reblogsFeatureScorer extends FeatureScorer {\n\t    constructor() {\n\t        super({\n\t            featureGetter: (api: mastodon.Client) => { return FeatureStorage.getTopReblogs(api) },\n\t            verboseName: \"Reblogs\",\n\t            description: \"Posts that are from your most reblogger users\",\n", "            defaultWeight: 3,\n\t        })\n\t    }\n\t    async score(api: mastodon.Client, status: StatusType) {\n\t        const authorScore = (status.account.acct in this.feature) ? this.feature[status.account.acct] : 0\n\t        const reblogScore = (status.reblog && status.reblog.account.acct in this.feature) ? this.feature[status.reblog.account.acct] : 0\n\t        return authorScore + reblogScore\n\t    }\n\t}"]}
{"filename": "src/feeds/homeFeed.ts", "chunked_list": ["import { mastodon } from \"masto\";\n\texport default async function getHomeFeed(api: mastodon.Client, user: mastodon.v1.Account) {\n\t    let results: any[] = [];\n\t    let pages = 10;\n\t    for await (const page of api.v1.timelines.listHome()) {\n\t        results = results.concat(page)\n\t        pages--;\n\t        //check if status is less than 12 hours old\n\t        if (pages === 0 || new Date(page[0].createdAt) < new Date(Date.now() - 43200000)) {\n\t            break;\n", "        }\n\t    }\n\t    return results;\n\t}"]}
{"filename": "src/feeds/topPostsFeed.ts", "chunked_list": ["import { SerializerNativeImpl, mastodon } from \"masto\";\n\timport FeatureStore from \"../features/FeatureStore\";\n\texport default async function getTopPostFeed(api: mastodon.Client): Promise<mastodon.v1.Status[]> {\n\t    const core_servers = await FeatureStore.getCoreServer(api)\n\t    let results: any[] = [];\n\t    const serializer = new SerializerNativeImpl();\n\t    //Get Top Servers\n\t    const servers = Object.keys(core_servers).sort((a, b) => {\n\t        return core_servers[b] - core_servers[a]\n\t    }).slice(0, 10)\n", "    results = await Promise.all(servers.map(async (server: string): Promise<mastodon.v1.Status[]> => {\n\t        if (server === \"undefined\" || typeof server == \"undefined\" || server === \"\") return [];\n\t        let res;\n\t        try {\n\t            res = await fetch(\"https://\" + server + \"/api/v1/trends/statuses\")\n\t        }\n\t        catch (e) {\n\t            return [];\n\t        }\n\t        if (!res.ok) {\n", "            return [];\n\t        }\n\t        const data: any[] = serializer.deserialize('application/json', await res.text());\n\t        if (data === undefined) {\n\t            return [];\n\t        }\n\t        return data.map((status: any) => {\n\t            status.topPost = true;\n\t            return status;\n\t        }).slice(0, 10)\n", "    }))\n\t    console.log(results)\n\t    return results.flat();\n\t}"]}
