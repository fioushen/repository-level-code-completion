{"filename": "vitest.config.ts", "chunked_list": ["import { defineConfig } from 'vitest/config'\n\texport default defineConfig({\n\t  test: {\n\t    coverage: {\n\t      include: ['src/**/*.ts'],\n\t      reporter: ['text', 'json', 'html'],\n\t    },\n\t  },\n\t})\n"]}
{"filename": "test/proxy.test.ts", "chunked_list": ["import { describe, beforeEach, expect, it } from 'vitest'\n\timport supertest from 'supertest'\n\timport type { SuperTest, Test } from 'supertest'\n\timport type { App } from 'h3'\n\timport { createApp, toNodeListener, eventHandler } from 'h3'\n\timport { createProxyEventHandler } from '../src'\n\tdescribe('Validate proxy event handler', () => {\n\t  let app: App\n\t  let request: SuperTest<Test>\n\t  beforeEach(() => {\n", "    app = createApp({ debug: false })\n\t    app.use(\n\t      '/test',\n\t      eventHandler(() => 'Hello World!')\n\t    )\n\t    request = supertest(toNodeListener(app))\n\t  })\n\t  const proxyEventHandler = createProxyEventHandler({\n\t    target: 'http://127.0.0.1:3000',\n\t    pathRewrite: {\n", "      '/api': '',\n\t    },\n\t    pathFilter: ['/api/**'],\n\t  })\n\t  it('returns 200 OK if proxy request is success', async () => {\n\t    app.use(eventHandler(proxyEventHandler))\n\t    const res = await request.get('/api/test')\n\t    expect(res.statusCode).toEqual(200)\n\t  })\n\t})\n"]}
{"filename": "lib/index.d.ts", "chunked_list": ["import { H3Event, ProxyOptions, EventHandler } from 'h3';\n\timport { IncomingMessage } from 'http';\n\timport { ConsolaOptions } from 'consola';\n\ttype CustomPathFilter = (\n\t  pathname: string,\n\t  req: IncomingMessage\n\t) => boolean\n\ttype PathFilterParams = string | string[] | CustomPathFilter\n\ttype CustomPathRewriter = (\n\t  pathname: string,\n", "  req: IncomingMessage\n\t) => string | Promise<string>\n\ttype RewriteRecord = Record<string, string>\n\ttype PathRewriterParams = RewriteRecord | CustomPathRewriter\n\ttype ProxyRequestOptions = ProxyOptions\n\ttype ConfigureProxyRequest = (event: H3Event) => ProxyRequestOptions\n\tinterface CreateProxyEventHandlerOptions {\n\t  target: string\n\t  pathFilter?: PathFilterParams\n\t  pathRewrite?: PathRewriterParams\n", "  // Configure options of proxyRequest which is h3's built-in util\n\t  configureProxyRequest?: ConfigureProxyRequest\n\t  // Whether to enable logger\n\t  enableLogger?: boolean\n\t  // Configure the options of consola\n\t  loggerOptions?: ConsolaOptions\n\t  // true/false, Default: false - changes the origin of the host header to the target URL\n\t  changeOrigin?: boolean\n\t}\n\ttype CreateProxyEventHandler = (\n", "  options: CreateProxyEventHandlerOptions\n\t) => EventHandler\n\tdeclare const createProxyEventHandler: CreateProxyEventHandler\n\texport { ConfigureProxyRequest, CreateProxyEventHandlerOptions, PathFilterParams, PathRewriterParams, createProxyEventHandler };\n"]}
{"filename": "types/index.d.ts", "chunked_list": ["import type {\n\t  CreateProxyEventHandler,\n\t  CreateProxyEventHandlerOptions,\n\t  ConfigureProxyRequest,\n\t} from '../src/interfaces/core'\n\timport type { PathFilterParams } from '../src/interfaces/pathFilter'\n\timport type { PathRewriterParams } from '../src/interfaces/pathRewriter'\n\tdeclare const createProxyEventHandler: CreateProxyEventHandler\n\texport {\n\t  createProxyEventHandler,\n", "  CreateProxyEventHandlerOptions,\n\t  ConfigureProxyRequest,\n\t  PathFilterParams,\n\t  PathRewriterParams,\n\t}\n"]}
{"filename": "src/proxyRequestStrategy.ts", "chunked_list": ["import type {\n\t  CreateProxyEventHandlerOptions,\n\t  ProxyRequestOptions,\n\t} from './interfaces/core'\n\timport type { H3Event } from 'h3'\n\timport { parseUrlToObject } from './urlParser'\n\tconst generateOutgoingHost = (target: string) => {\n\t  const { hostname, port } = parseUrlToObject(target)\n\t  if (port) {\n\t    return `${hostname}:${port}`\n", "  }\n\t  return `${hostname}`\n\t}\n\tconst createProxyRequestOptions = (\n\t  event: H3Event,\n\t  options: CreateProxyEventHandlerOptions\n\t): ProxyRequestOptions | undefined => {\n\t  const { configureProxyRequest, changeOrigin, target } = options\n\t  const defaultOptions: ProxyRequestOptions = {\n\t    headers: {},\n", "  }\n\t  if (changeOrigin) {\n\t    defaultOptions.headers.host = generateOutgoingHost(target)\n\t  }\n\t  const incomingOptions =\n\t    typeof configureProxyRequest === 'function'\n\t      ? configureProxyRequest(event)\n\t      : {}\n\t  const finalOptions: ProxyRequestOptions = Object.assign(\n\t    defaultOptions,\n", "    incomingOptions\n\t  )\n\t  finalOptions.headers = Object.assign(\n\t    defaultOptions.headers,\n\t    incomingOptions.headers\n\t  )\n\t  return finalOptions\n\t}\n\texport { createProxyRequestOptions }\n"]}
{"filename": "src/pathRewriter.ts", "chunked_list": ["import type {\n\t  CreatePathRewriter,\n\t  PathRewriterParams,\n\t  RewriteRule,\n\t  RewriteRecord,\n\t} from './interfaces/pathRewriter'\n\timport isPlainObj from 'lodash/isPlainObject'\n\timport { ERRORS } from './errors'\n\timport type { Logger } from './interfaces/logger'\n\tfunction isValidRewriteConfig(rewriteConfig?: PathRewriterParams) {\n", "  if (typeof rewriteConfig === 'function') {\n\t    return true\n\t  } else if (isPlainObj(rewriteConfig)) {\n\t    return Object.keys(rewriteConfig as object).length !== 0\n\t  } else if (rewriteConfig === undefined || rewriteConfig === null) {\n\t    return false\n\t  } else {\n\t    throw new Error(ERRORS.ERR_PATH_REWRITER_CONFIG)\n\t  }\n\t}\n", "function parsePathRewriteRules(rewriteRecord: RewriteRecord, logger?: Logger) {\n\t  const rules: RewriteRule[] = []\n\t  if (isPlainObj(rewriteRecord)) {\n\t    for (const [key, value] of Object.entries(rewriteRecord)) {\n\t      rules.push({\n\t        regex: new RegExp(key),\n\t        value: value,\n\t      })\n\t      logger && logger.info('rewrite rule created: \"%s\" ~> \"%s\"', key, value)\n\t    }\n", "  }\n\t  return rules\n\t}\n\t/**\n\t * Create a path rewriter function\n\t */\n\tconst createPathRewriter: CreatePathRewriter = (rewriteConfig, logger) => {\n\t  if (!isValidRewriteConfig(rewriteConfig)) {\n\t    return\n\t  }\n", "  let rulesCache: RewriteRule[]\n\t  function rewritePath(path: string) {\n\t    let result = path\n\t    for (const rule of rulesCache) {\n\t      if (rule.regex.test(path)) {\n\t        result = result.replace(rule.regex, rule.value)\n\t        logger && logger.info('rewriting path from \"%s\" to \"%s\"', path, result)\n\t        break\n\t      }\n\t    }\n", "    return result\n\t  }\n\t  if (typeof rewriteConfig === 'function') {\n\t    const customRewriteFn = rewriteConfig\n\t    return customRewriteFn\n\t  } else {\n\t    rulesCache = parsePathRewriteRules(rewriteConfig as RewriteRecord, logger)\n\t    return rewritePath\n\t  }\n\t}\n", "export { createPathRewriter }\n"]}
{"filename": "src/pathFilter.ts", "chunked_list": ["import isGlob from 'is-glob'\n\timport micromatch from 'micromatch'\n\timport type { IsTargetFilterPath } from './interfaces/pathFilter'\n\timport { ERRORS } from './errors'\n\tconst isStringPath = (pathFilter?: string | string[]): pathFilter is string => {\n\t  return typeof pathFilter === 'string' && !isGlob(pathFilter)\n\t}\n\tconst isGlobPath = (pattern?: string | string[]): pattern is string => {\n\t  return typeof pattern === 'string' && isGlob(pattern)\n\t}\n", "const isMultiPath = (\n\t  pathFilter?: string | string[]\n\t): pathFilter is string[] => {\n\t  return Array.isArray(pathFilter)\n\t}\n\tconst matchSingleStringPath = (\n\t  pathname: string,\n\t  pathFilter?: string\n\t): boolean => {\n\t  if (!pathFilter) return false\n", "  return pathname.indexOf(pathFilter) >= 0\n\t}\n\tconst matchMultiPath = (pathname: string, pathFilterList: string[]) => {\n\t  return pathFilterList.some((pattern) =>\n\t    matchSingleStringPath(pathname, pattern)\n\t  )\n\t}\n\tconst matchSingleGlobPath = (\n\t  pathname: string,\n\t  pattern?: string | string[]\n", "): boolean => {\n\t  if (!pattern) return false\n\t  const matches = micromatch([pathname], pattern)\n\t  return matches && matches.length > 0\n\t}\n\tconst matchMultiGlobPath = (pathname: string, patterns?: string | string[]) => {\n\t  return matchSingleGlobPath(pathname, patterns)\n\t}\n\t/**\n\t * checkout weather the path is target filter path\n", " */\n\tconst isTargetFilterPath: IsTargetFilterPath = (\n\t  pathname = '',\n\t  { pathFilter, req }\n\t) => {\n\t  // custom path filter\n\t  if (typeof pathFilter === 'function') {\n\t    return pathFilter(pathname, req)\n\t  }\n\t  // single glob\n", "  if (isGlobPath(pathFilter)) {\n\t    return matchSingleGlobPath(pathname, pathFilter)\n\t  }\n\t  // single string\n\t  if (isStringPath(pathFilter)) {\n\t    return matchSingleStringPath(pathname, pathFilter)\n\t  }\n\t  // multi path\n\t  if (isMultiPath(pathFilter)) {\n\t    if (pathFilter.every(isStringPath)) {\n", "      return matchMultiPath(pathname, pathFilter)\n\t    }\n\t    if ((pathFilter as string[]).every(isGlobPath)) {\n\t      return matchMultiGlobPath(pathname, pathFilter)\n\t    }\n\t    throw new Error(ERRORS.ERR_CONTEXT_MATCHER_INVALID_ARRAY)\n\t  }\n\t  return true\n\t}\n\texport { isTargetFilterPath }\n"]}
{"filename": "src/logger.ts", "chunked_list": ["import consola from 'consola'\n\timport type { CreateLogger } from './interfaces/logger'\n\texport const createLogger: CreateLogger = ({ enableLogger, loggerOptions }) => {\n\t  const finalLoggerOptions = Object.assign({}, loggerOptions)\n\t  if (enableLogger) {\n\t    return consola.create(finalLoggerOptions)\n\t  }\n\t}\n"]}
{"filename": "src/errors.ts", "chunked_list": ["export enum ERRORS {\n\t  ERR_CONFIG_FACTORY_TARGET_MISSING = '[h3-proxy] Missing \"target\" option. Example: {target: \"http://www.example.org\"}',\n\t  ERR_CONTEXT_MATCHER_INVALID_ARRAY = '[h3-proxy] Invalid pathFilter. Expecting something like: [\"/api\", \"/ajax\"] or [\"/api/**\", \"!**.html\"]',\n\t  ERR_PATH_REWRITER_CONFIG = '[h3-proxy] Invalid pathRewrite config. Expecting object with pathRewrite config or a rewrite function',\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { isTargetFilterPath } from './pathFilter'\n\timport type { CreateProxyEventHandler } from './interfaces/core'\n\timport { createPathRewriter } from './pathRewriter'\n\timport { proxyRequest } from 'h3'\n\timport { ERRORS } from './errors'\n\timport { createLogger } from './logger'\n\timport { createProxyRequestOptions } from './proxyRequestStrategy'\n\timport { getUrlPath } from './urlParser'\n\tconst createProxyEventHandler: CreateProxyEventHandler = (options) => {\n\t  const finalOptions = Object.assign({ enableLogger: true }, options)\n", "  const { target, pathFilter, pathRewrite, enableLogger, loggerOptions } =\n\t    finalOptions\n\t  if (!target) {\n\t    throw new Error(ERRORS.ERR_CONFIG_FACTORY_TARGET_MISSING)\n\t  }\n\t  const logger = createLogger({\n\t    enableLogger,\n\t    loggerOptions,\n\t  })\n\t  return async (event) => {\n", "    const { req } = event.node\n\t    const path = getUrlPath(req.url, target)\n\t    // generate proxy request options via default strategy\n\t    const proxyRequestOptions = createProxyRequestOptions(event, finalOptions)\n\t    if (isTargetFilterPath(path, { pathFilter, req })) {\n\t      const pathRewriter = createPathRewriter(pathRewrite, logger)\n\t      let rewritedPath = path\n\t      if (pathRewriter) {\n\t        rewritedPath = await pathRewriter(path, req)\n\t      }\n", "      const targetUrl = `${target}${rewritedPath}`\n\t      logger && logger.success('proxy to target url:', targetUrl)\n\t      return proxyRequest(event, targetUrl, proxyRequestOptions)\n\t    }\n\t  }\n\t}\n\texport { createProxyEventHandler }\n"]}
{"filename": "src/urlParser.ts", "chunked_list": ["import { URL } from 'node:url'\n\tconst parseUrlToObject = (url: string) => {\n\t  return new URL(url)\n\t}\n\tconst getUrlPath = (url?: string, base?: string) => {\n\t  if (!url) return ''\n\t  const { pathname, search } = new URL(url, base)\n\t  return `${pathname}${search}`\n\t}\n\texport { parseUrlToObject, getUrlPath }\n"]}
{"filename": "src/interfaces/pathRewriter.ts", "chunked_list": ["import type { IncomingMessage } from 'http'\n\timport type { Logger } from './logger'\n\texport type CustomPathRewriter = (\n\t  pathname: string,\n\t  req: IncomingMessage\n\t) => string | Promise<string>\n\texport type RewriteRecord = Record<string, string>\n\texport type PathRewriterParams = RewriteRecord | CustomPathRewriter\n\texport type CreatePathRewriter = (\n\t  pathRewrite?: PathRewriterParams,\n", "  logger?: Logger\n\t) => CustomPathRewriter | undefined\n\texport type RewriteRule = { regex: RegExp; value: string }\n"]}
{"filename": "src/interfaces/core.ts", "chunked_list": ["import type { EventHandler, ProxyOptions, H3Event } from 'h3'\n\timport type { PathFilterParams } from './pathFilter'\n\timport type { PathRewriterParams } from './pathRewriter'\n\timport type { ConsolaOptions } from 'consola'\n\texport type ProxyRequestOptions = ProxyOptions\n\texport type ConfigureProxyRequest = (event: H3Event) => ProxyRequestOptions\n\texport interface CreateProxyEventHandlerOptions {\n\t  target: string\n\t  pathFilter?: PathFilterParams\n\t  pathRewrite?: PathRewriterParams\n", "  // Configure options of proxyRequest which is h3's built-in util\n\t  configureProxyRequest?: ConfigureProxyRequest\n\t  // Whether to enable logger\n\t  enableLogger?: boolean\n\t  // Configure the options of consola\n\t  loggerOptions?: ConsolaOptions\n\t  // true/false, Default: false - changes the origin of the host header to the target URL\n\t  changeOrigin?: boolean\n\t}\n\texport type CreateProxyEventHandler = (\n", "  options: CreateProxyEventHandlerOptions\n\t) => EventHandler\n"]}
{"filename": "src/interfaces/pathFilter.ts", "chunked_list": ["import type { IncomingMessage } from 'http'\n\texport type CustomPathFilter = (\n\t  pathname: string,\n\t  req: IncomingMessage\n\t) => boolean\n\texport type PathFilterParams = string | string[] | CustomPathFilter\n\texport type IsTargetFilterPath = (\n\t  pathname: string | undefined,\n\t  opts: {\n\t    pathFilter?: PathFilterParams\n", "    req: IncomingMessage\n\t  }\n\t) => boolean\n"]}
{"filename": "src/interfaces/logger.ts", "chunked_list": ["import type { ConsolaOptions, Consola } from 'consola'\n\texport interface CreateLoggerOptions {\n\t  // Whether to enable logger\n\t  enableLogger?: boolean\n\t  // Configure the options of consola\n\t  loggerOptions?: ConsolaOptions\n\t}\n\texport type Logger = Consola\n\texport type CreateLogger = (options: CreateLoggerOptions) => Logger | undefined\n"]}
