{"filename": "examples/generate-react-component-inline.ts", "chunked_list": ["import \"auto\";\n\tconst files = {\n\t  index: 'export * from \"./__name__\";',\n\t  component: `\n\timport React from \"react\";\n\texport interface __name__Props {\n\t}\n\texport const __name__ = (props: __name__Props) => {\n\t  return (\n\t    <div>__name__</div>\n", "  );\n\t};`.trim(),\n\t  storybook: `\n\timport { ComponentStory } from \"@storybook/react\";\n\timport { __name__, __name__Props } from \"./__name__\";\n\texport default {\n\t  title: \"__name__\",\n\t  component: __name__,\n\t};\n\tconst Template: ComponentStory<typeof __name__> = (props: __name__Props) => {\n", "  return <__name__ {...props} />;\n\t};\n\texport const Default = Template.bind({});\n\tDefault.args = {};`.trim(),\n\t};\n\texport default auto({\n\t  id: \"react-component-inline\",\n\t  title: \"React Component (inline)\",\n\t  params: {\n\t    name: {\n", "      title: \"Component Name\",\n\t      type: \"string\",\n\t    },\n\t  },\n\t  isValid: (project) => project.hasDependency(\"react\"),\n\t  run: async ({ project, params, self, t }) => {\n\t    console.log(\"Running:\", self.id);\n\t    const componentDirectoryPath = await prompt.input({\n\t      message: \"Target path:\",\n\t      default: `${project.hasDirectory(\"src/components\") ? \"src/components\" : \"\"}/${params.name}`,\n", "    });\n\t    // component directory\n\t    console.log(\"Creating directory:\", componentDirectoryPath);\n\t    project.createDirectory(componentDirectoryPath);\n\t    // component\n\t    project.writeFile(t(`${componentDirectoryPath}/__name__.tsx`), t(files.component));\n\t    // index\n\t    project.writeFile(t(`${componentDirectoryPath}/index.ts`), t(files.index));\n\t    // story (storybook)\n\t    if (project.hasDependency(\"@storybook/react\")) {\n", "      project.writeFile(t(`${componentDirectoryPath}/__name__.stories.tsx`), t(files.storybook));\n\t    }\n\t    // test (testing-library)\n\t    if (project.hasDependency(\"@testing-library/react\")) {\n\t      const hasUserEvent = project.hasDependency(\"@testing-library/user-event\");\n\t      const content = t(\n\t        [\n\t          'import { render, screen } from \"@testing-library/react\";',\n\t          hasUserEvent && 'import userEvent from \"@testing-library/user-event\";',\n\t          `\n", "import { __name__ } from \"./__name__\";\n\tdescribe(\"__name__\", () => {\n\t  beforeEach(() => {\n\t    jest.clearAllMocks();\n\t  });\n\t  it.todo(\"should render\");\n\t});`.trim(),\n\t        ]\n\t          .filter(Boolean)\n\t          .join(\"\\n\")\n", "      );\n\t      project.writeFile(t(`${componentDirectoryPath}/__name__.test.tsx`), content);\n\t    }\n\t  },\n\t});\n"]}
{"filename": "examples/shell.ts", "chunked_list": ["import \"auto\";\n\timport { ExecaChildProcess } from \"execa\";\n\texport default auto({\n\t  id: \"shell\",\n\t  title: \"Shell-like usage\",\n\t  run: async ({ project }) => {\n\t    cd(project.rootDirectory);\n\t    console.log((await execa(\"cat\", [\"package.json\"]).pipeStdout?.(execa(\"grep\", [\"license\"])))?.stdout);\n\t    const whoami = await $`whoami`;\n\t    await $`echo \"Hello, ${whoami}\"`.pipeStdout?.(process.stdout);\n", "    console.log(\n\t      (\n\t        await Promise.all(\n\t          [\n\t            async () => {\n\t              await sleep(100);\n\t              return $`echo \"1\"`.pipeStdout?.(process.stdout);\n\t            },\n\t            async () => {\n\t              await sleep(200);\n", "              return $`echo \"2\"`.pipeStdout?.(process.stdout);\n\t            },\n\t          ].map((f) => f())\n\t        )\n\t      ).map((p) => p?.stdout)\n\t    );\n\t    const name = \"auto-foo-bar-baz\";\n\t    await $`mkdir -p /tmp/${name}`;\n\t    console.log((await $`ls /tmp/${name}`).exitCode);\n\t  },\n", "});\n"]}
{"filename": "examples/prompts.ts", "chunked_list": ["import \"auto\";\n\texport default auto({\n\t  id: \"prompts\",\n\t  title: \"Auto prompts\",\n\t  params: {\n\t    boolean: {\n\t      title: \"Boolean param\",\n\t      type: \"boolean\",\n\t    },\n\t    number: {\n", "      title: \"Number param\",\n\t      type: \"number\",\n\t    },\n\t    string: {\n\t      title: \"String param\",\n\t      type: \"string\",\n\t    },\n\t  },\n\t  run: async ({ params }) => {\n\t    console.log(\"Params:\", params);\n", "    const boolean = await prompt.confirm({ message: \"On-demand boolean prompt\" });\n\t    console.log(\"Boolean value:\", boolean);\n\t    const string = await prompt.input({ message: \"On-demand string prompt\" });\n\t    console.log(\"String value:\", string);\n\t    const choice = await prompt.select({\n\t      message: \"Choose\",\n\t      choices: [\n\t        {\n\t          name: \"Blue pill\",\n\t          value: \"blue\",\n", "          description: \"Take the blue pill\",\n\t        },\n\t        {\n\t          name: \"Red pill\",\n\t          value: \"red\",\n\t          description: \"Take the red pill\",\n\t        },\n\t        new prompt.Separator(),\n\t        {\n\t          name: \"Green pill\",\n", "          value: \"green\",\n\t          description: \"Take the green pill\",\n\t        },\n\t      ],\n\t    });\n\t    console.log(\"Choice:\", choice);\n\t  },\n\t});\n"]}
{"filename": "examples/fetch.ts", "chunked_list": ["import \"auto\";\n\texport default auto({\n\t  id: \"fetch\",\n\t  title: \"Fetch\",\n\t  run: async () => {\n\t    const response = await fetch(\"http://localhost:9123\");\n\t    const text = await response.text();\n\t    console.log(text);\n\t  },\n\t});\n"]}
{"filename": "examples/generate-react-component/index.ts", "chunked_list": ["export * from \"./__name__\";\n"]}
{"filename": "examples/generate-react-component/generate-react-component.ts", "chunked_list": ["import \"auto\";\n\texport default auto({\n\t  id: \"react-component\",\n\t  title: \"React Component\",\n\t  params: {\n\t    name: {\n\t      title: \"Component Name\",\n\t      type: \"string\",\n\t      required: true,\n\t    },\n", "    path: {\n\t      title: \"Component Path\",\n\t      type: \"string\",\n\t      defaultValue: ({ project, params }) => {\n\t        if (project.hasDirectory(\"src/components\")) {\n\t          return `src/components/${params.name}`;\n\t        }\n\t        if (project.hasDirectory(\"components\")) {\n\t          return `components/${params.name}`;\n\t        }\n", "      },\n\t    },\n\t  },\n\t  isValid: (project) => project.hasDependency(\"react\"),\n\t  run: async ({ project, params, fileMap, self, t }) => {\n\t    console.log(\"Running:\", self.id);\n\t    project.createDirectory(params.path);\n\t    project.writeFile(t(`${params.path}/index.ts`), t(fileMap[\"index.ts\"]));\n\t    project.writeFile(t(`${params.path}/${params.name}.tsx`), t(fileMap[\"__name__.tsx\"]));\n\t    if (project.hasDependency(\"jest\")) {\n", "      project.writeFile(t(`${params.path}/${params.name}.test.tsx`), t(fileMap[\"__name__.test.tsx\"]));\n\t    }\n\t    if (project.hasDependency(\"storybook\")) {\n\t      project.writeFile(t(`${params.path}/${params.name}.stories.tsx`), t(fileMap[\"__name__.stories.tsx\"]));\n\t    }\n\t  },\n\t});\n"]}
{"filename": "src/main.ts", "chunked_list": ["/* eslint-disable no-await-in-loop */\n\timport { dirname, resolve } from \"node:path\";\n\timport { fileURLToPath } from \"node:url\";\n\timport { cli as cleye } from \"cleye\";\n\timport chalk from \"chalk\";\n\timport fs from \"fs-extra\";\n\timport spawn from \"cross-spawn\";\n\timport { globSync } from \"glob\";\n\timport * as inquirer from \"@inquirer/prompts\";\n\timport packageJson from \"../package.json\";\n", "import Project from \"./Project\";\n\timport { getGlobalRepositoryPath, resolveProjectRoot, tildify } from \"./utils/path\";\n\timport { createListCommand } from \"./commands/list\";\n\timport { createRunCommand } from \"./commands/run\";\n\timport { createReplCommand } from \"./commands/repl\";\n\timport { autoSymbol, AutoReturnType } from \"./types\";\n\timport { setupTSConfig } from \"./setup\";\n\tconst main = async () => {\n\t  const isParentProcess = typeof process.send !== \"function\";\n\t  // main repo\n", "  const developmentRepositoryPath = resolve(dirname(fileURLToPath(import.meta.url)), \"..\", \"examples\");\n\t  const configRepositoryPath = getGlobalRepositoryPath();\n\t  const envRepositoryPath = process.env.AUTO_REPO;\n\t  let mainRepositoryPath = fs.existsSync(developmentRepositoryPath)\n\t    ? developmentRepositoryPath\n\t    : envRepositoryPath ?? configRepositoryPath;\n\t  const hasMainRepository = fs.existsSync(mainRepositoryPath);\n\t  if (hasMainRepository && isParentProcess) {\n\t    console.log(chalk.blue(\"Info:\"), \"Using main repository:\", chalk.magenta(tildify(mainRepositoryPath)));\n\t  }\n", "  // local repo\n\t  const projectRoot = resolveProjectRoot(process.cwd());\n\t  const localRepositoryPaths = [\"./auto\", \"./.auto\"].map((p) => resolve(projectRoot, p));\n\t  const localRepositoryPath = localRepositoryPaths.find((p) => fs.existsSync(p));\n\t  if (localRepositoryPath && isParentProcess) {\n\t    console.log(chalk.blue(\"Info:\"), \"Using local repository:\", chalk.magenta(tildify(localRepositoryPath)));\n\t  }\n\t  // resolve repos\n\t  const repositoryPaths: string[] = [];\n\t  if (hasMainRepository) repositoryPaths.push(mainRepositoryPath);\n", "  if (localRepositoryPath) repositoryPaths.push(localRepositoryPath);\n\t  // no repo found\n\t  if (repositoryPaths.length === 0) {\n\t    console.error(chalk.red(\"Error:\"), \"Cannot resolve repository directory, to fix this either:\");\n\t    console.log(`- Create a directory at: ${chalk.magenta(tildify(configRepositoryPath))}`);\n\t    console.log(\n\t      `- Create a directory at:\\n  ${chalk.magenta(resolve(projectRoot, \"auto\"))}\\nor\\n  ${chalk.magenta(\n\t        resolve(projectRoot, \".auto\")\n\t      )}`\n\t    );\n", "    console.log(`- Or set the ${chalk.cyan(\"$AUTO_REPO\")} environment variable.`);\n\t    // auto-create main repo (~/.config/auto)\n\t    const ok = await inquirer.confirm({\n\t      message: `Do you want me to create a directory at ${chalk.magenta(tildify(configRepositoryPath))}?`,\n\t    });\n\t    if (ok) {\n\t      await fs.mkdirp(configRepositoryPath);\n\t      console.log(chalk.green(\"Success:\"), \"Created directory at\", chalk.magenta(tildify(configRepositoryPath)));\n\t      mainRepositoryPath = configRepositoryPath;\n\t    } else {\n", "      process.exit(1);\n\t    }\n\t  }\n\t  if (isParentProcess) {\n\t    const argv = process.argv.slice(1);\n\t    const esmLoaderPath = require.resolve(\"tsx\");\n\t    const cjsAutoLoaderPath = resolve(dirname(fileURLToPath(import.meta.url)), \"loader-cjs.cjs\");\n\t    const esmAutoLoaderPath = resolve(dirname(fileURLToPath(import.meta.url)), \"loader-esm.mjs\");\n\t    // auto-setup repo/tsconfig.json\n\t    for (const repoPath of repositoryPaths) {\n", "      const tsConfigPath = resolve(repoPath, \"tsconfig.json\");\n\t      if (!fs.existsSync(tsConfigPath)) {\n\t        console.log(\n\t          chalk.yellow.bold(\"Warning:\"),\n\t          \"Cannot find\",\n\t          // eslint-disable-next-line sonarjs/no-nested-template-literals\n\t          `${chalk.magenta(`${tildify(repoPath)}/`)}${chalk.cyan(\"tsconfig.json\")}`\n\t        );\n\t        const ok = await inquirer.confirm({ message: \"Do you want me to set it up?\" });\n\t        if (ok) {\n", "          await setupTSConfig(tsConfigPath);\n\t          console.log(\n\t            chalk.green(\"Success:\"),\n\t            \"Wrote\",\n\t            chalk.cyan(\"tsconfig.json\"),\n\t            \"to\",\n\t            chalk.magenta(tildify(tsConfigPath))\n\t          );\n\t        }\n\t      }\n", "    }\n\t    const childProcess = spawn(\n\t      process.execPath,\n\t      [\"-r\", cjsAutoLoaderPath, \"--loader\", esmLoaderPath, \"--loader\", esmAutoLoaderPath, ...argv],\n\t      {\n\t        stdio: [\"inherit\", \"inherit\", \"inherit\", \"ipc\"],\n\t        env: {\n\t          ...process.env,\n\t          NODE_OPTIONS: [\"--experimental-specifier-resolution=node\", \"--no-warnings=ExperimentalWarning\"].join(\" \"),\n\t        },\n", "      }\n\t    );\n\t    childProcess.on(\"close\", (code) => process.exit(code!));\n\t    return;\n\t  }\n\t  const scriptMap: Record<string, AutoReturnType> = {};\n\t  const files = repositoryPaths.flatMap((repositoryPath) =>\n\t    globSync(`${repositoryPath}/**/*.ts`).map((path) => ({ repositoryPath, path }))\n\t  );\n\t  const importedModules = await Promise.all(\n", "    files.map(async (file) => {\n\t      try {\n\t        return { file, module: await import(file.path) };\n\t      } catch {\n\t        // console.log(chalk.red(\"Skipped:\"), \"Loading error:\", chalk.magenta(file.path));\n\t        // console.error(error);\n\t        return null;\n\t      }\n\t    })\n\t  );\n", "  const modules = importedModules.filter(Boolean) as {\n\t    file: (typeof files)[0];\n\t    module: { default?: AutoReturnType };\n\t  }[];\n\t  for (const { file, module } of modules) {\n\t    if (!file || !module) continue;\n\t    if (module.default?.[autoSymbol]) {\n\t      const { repositoryPath, path } = file;\n\t      const isLocal = repositoryPath === localRepositoryPath;\n\t      const script: AutoReturnType = { ...module.default, path, isLocal };\n", "      const previousScript = scriptMap[script.id];\n\t      if (\n\t        (previousScript?.isLocal && script.isLocal) ||\n\t        (previousScript && !previousScript.isLocal && !script.isLocal)\n\t      ) {\n\t        console.error(chalk.red(\"Fatal:\"), \"Duplicate script:\", chalk.magenta(script.id));\n\t        console.log(chalk.grey(\"-\"), \"First found at:\", chalk.magenta(tildify(previousScript.path)));\n\t        console.log(chalk.grey(\"-\"), \"Second found at:\", chalk.magenta(tildify(path)));\n\t        process.exit(1);\n\t      }\n", "      scriptMap[script.id] = script;\n\t      // console.log(chalk.green(\"Success:\"), \"Loaded:\", chalk.magenta(path));\n\t    } else {\n\t      // console.log(chalk.yellow(\"Skipped:\"), \"Not a module:\", chalk.magenta(file.path));\n\t    }\n\t  }\n\t  const project = Project.resolveFromPath(process.cwd());\n\t  const scripts = Object.values(scriptMap);\n\t  const cli = cleye({\n\t    name: \"auto\",\n", "    version: packageJson.version,\n\t    commands: [\n\t      createListCommand(project, scripts),\n\t      createRunCommand(project, scripts),\n\t      createReplCommand(project, scripts),\n\t    ],\n\t  });\n\t  if (!cli.command) cli.showHelp();\n\t};\n\tmain();\n"]}
{"filename": "src/types.ts", "chunked_list": ["import Project from \"./Project\";\n\texport type ParamType = \"boolean\" | \"number\" | \"string\";\n\texport type ParamValueType<T extends ParamType> = T extends \"boolean\"\n\t  ? boolean\n\t  : T extends \"number\"\n\t  ? number\n\t  : T extends \"string\"\n\t  ? string\n\t  : never;\n\texport type ScriptParam<T extends ParamType, P extends Record<string, ParamType>> = {\n", "  title: string;\n\t  type: T;\n\t  defaultValue?:\n\t    | ParamValueType<T>\n\t    | ((args: { project: Project; params: { [K in keyof P]: ParamValueType<P[K]> } }) => ParamValueType<T> | undefined);\n\t  required?: boolean;\n\t};\n\texport type Params<T extends Record<string, ParamType> = Record<string, ParamType>> = {\n\t  [K in keyof T]: ScriptParam<T[K], T> & { type: T[K] };\n\t};\n", "export type Script<P extends Record<string, ParamType>> = {\n\t  id: string;\n\t  title?: string;\n\t  params?: Params<P>;\n\t  isValid?: (project: Project) => boolean;\n\t  run: (args: {\n\t    cwd: string;\n\t    project: Project;\n\t    self: Script<P>;\n\t    params: { [K in keyof P]: ParamValueType<P[K]> };\n", "    files: { path: string; content: string }[];\n\t    fileMap: Record<string, string>;\n\t    t: (text: string, params?: Record<string, boolean | number | string>) => string;\n\t  }) => void;\n\t};\n\tconst getDefaultParamValue = <T extends ParamType>(type: T) => {\n\t  const defaultValues: Record<ParamType, ParamValueType<ParamType>> = {\n\t    boolean: false,\n\t    number: 0,\n\t    string: \"\",\n", "  };\n\t  return defaultValues[type] as ParamValueType<T>;\n\t};\n\texport const autoSymbol = Symbol.for(\"auto\");\n\texport const auto = <P extends Record<string, ParamType>>(script: Script<P>) => {\n\t  return {\n\t    [autoSymbol]: true,\n\t    ...script,\n\t    isLocal: false,\n\t    path: \"\",\n", "    bootstrapParams: () => {\n\t      if (!script.params) return {};\n\t      return Object.fromEntries(\n\t        Object.entries(script.params).map(([key, param]) => {\n\t          let value = getDefaultParamValue(param.type);\n\t          if (typeof param.defaultValue !== \"function\" && param.defaultValue !== undefined) {\n\t            value = param.defaultValue;\n\t          }\n\t          return [key, { ...param, value }];\n\t        }) as [keyof P, ScriptParam<P[keyof P], P> & { value: ParamValueType<P[keyof P]> }][]\n", "      );\n\t    },\n\t  };\n\t};\n\texport type AutoType = typeof auto;\n\texport type AutoReturnType = ReturnType<AutoType>;\n"]}
{"filename": "src/loader-esm.ts", "chunked_list": ["import { resolve as nodeResolve, dirname } from \"node:path\";\n\timport { fileURLToPath } from \"node:url\";\n\timport fs from \"fs\";\n\tconst autoLoaderPath = nodeResolve(dirname(fileURLToPath(import.meta.url)), \"globals/index.mjs\");\n\texport async function resolve(specifier: string, context: unknown, next: Function) {\n\t  if (specifier === \"auto\") {\n\t    return { url: `file://${autoLoaderPath}`, shortCircuit: true };\n\t  }\n\t  return next(specifier, context);\n\t}\n", "export async function load(url: string, context: unknown, next: Function) {\n\t  if (url === autoLoaderPath) {\n\t    const code = fs.readFileSync(autoLoaderPath, \"utf8\");\n\t    return {\n\t      format: \"module\",\n\t      source: code,\n\t    };\n\t  }\n\t  return next(url, context);\n\t}\n"]}
{"filename": "src/Project.ts", "chunked_list": ["import fs from \"fs-extra\";\n\timport { resolve } from \"node:path\";\n\timport chalk from \"chalk\";\n\timport { resolveProjectRoot } from \"./utils/path\";\n\ttype Dependency = {\n\t  name: string;\n\t  version?: string;\n\t};\n\tclass Project {\n\t  rootDirectory: string;\n", "  constructor(rootDirectory: string) {\n\t    this.rootDirectory = rootDirectory;\n\t  }\n\t  static resolveFromPath(path: string = process.cwd()) {\n\t    return new Project(resolveProjectRoot(path));\n\t  }\n\t  get isGoProject() {\n\t    return this.hasFile(\"go.mod\");\n\t  }\n\t  get isJavaScriptProject() {\n", "    return this.hasFile(\"package.json\");\n\t  }\n\t  get isTypeScriptProject() {\n\t    return this.isJavaScriptProject && this.hasFile(\"tsconfig.json\");\n\t  }\n\t  get isNodeProject() {\n\t    if (!this.isJavaScriptProject) return false;\n\t    if (this.hasDependency(\"@types/node\")) return true;\n\t    const packageJson = this.readJSON(\"package.json\");\n\t    return packageJson?.engines?.node !== undefined;\n", "  }\n\t  get dependencies() {\n\t    const dependencies: Dependency[] = [];\n\t    if (this.isJavaScriptProject) {\n\t      const packageJson = this.readJSON(\"package.json\");\n\t      for (const [name, version] of Object.entries({\n\t        ...(packageJson.dependencies ?? []),\n\t        ...(packageJson.devDependencies ?? []),\n\t        ...(packageJson.peerDependencies ?? []),\n\t      })) {\n", "        dependencies.push({ name, version: typeof version === \"string\" ? version : undefined });\n\t      }\n\t    }\n\t    if (this.isGoProject) {\n\t      const goMod = this.readFile(\"go.mod\");\n\t      const requireLines = /require \\(([\\S\\s]*?)\\)/.exec(goMod)?.[1];\n\t      if (requireLines) {\n\t        for (const module of requireLines.trim().split(\"\\n\")) {\n\t          const [name, version] = module.trim().split(\" \");\n\t          dependencies.push({ name, version });\n", "        }\n\t      }\n\t    }\n\t    return dependencies;\n\t  }\n\t  resolvePath(...paths: string[]) {\n\t    return resolve(this.rootDirectory, ...paths);\n\t  }\n\t  hasPath(...paths: string[]) {\n\t    return fs.existsSync(this.resolvePath(...paths));\n", "  }\n\t  hasFile(...paths: string[]) {\n\t    return this.hasPath(...paths) && fs.lstatSync(this.resolvePath(...paths)).isFile();\n\t  }\n\t  readFile(...path: string[]) {\n\t    return fs.readFileSync(this.resolvePath(...path), \"utf8\");\n\t  }\n\t  writeFile(path: string, content: string) {\n\t    const resolvedPath = this.resolvePath(path);\n\t    console.log(chalk.blue(\"Writing file:\"), resolvedPath);\n", "    if (fs.existsSync(resolvedPath)) {\n\t      throw new Error(`File already exists: ${resolvedPath}`);\n\t    }\n\t    fs.outputFileSync(resolvedPath, content);\n\t  }\n\t  hasDirectory(path: string) {\n\t    return this.hasPath(path) && fs.lstatSync(this.resolvePath(path)).isDirectory();\n\t  }\n\t  createDirectory(path: string) {\n\t    const resolvedPath = this.resolvePath(path);\n", "    console.log(chalk.blue(\"Creating directory:\"), resolvedPath);\n\t    if (fs.existsSync(resolvedPath)) {\n\t      throw new Error(`Directory already exists: ${resolvedPath}`);\n\t    }\n\t    fs.mkdirSync(resolvedPath, { recursive: true });\n\t  }\n\t  readJSON(path: string) {\n\t    return fs.readJsonSync(this.resolvePath(path));\n\t  }\n\t  hasDependency(name: string, version?: string) {\n", "    return this.dependencies.some((dependency) => {\n\t      if (dependency.name !== name) return false;\n\t      if (version && dependency.version !== version) return false;\n\t      return true;\n\t    });\n\t  }\n\t  hasAnyDependency(names: string[]) {\n\t    return this.dependencies.some((dependency) => names.includes(dependency.name));\n\t  }\n\t}\n", "export default Project;\n"]}
{"filename": "src/Project.test.ts", "chunked_list": ["import test from \"ava\";\n\timport sinon from \"sinon\";\n\timport { stub } from \"./utils/test\";\n\timport Project from \"./Project\";\n\ttest.beforeEach(() => {\n\t  sinon.restore();\n\t});\n\ttest(\"detects Go project\", async (t) => {\n\t  const hasFile = stub(Project.prototype, \"hasFile\");\n\t  hasFile.returns(false);\n", "  hasFile.withArgs(\"go.mod\").returns(true);\n\t  t.true(Project.resolveFromPath().isGoProject);\n\t});\n\ttest(\"detects JavaScript project\", async (t) => {\n\t  const hasFile = stub(Project.prototype, \"hasFile\");\n\t  hasFile.returns(false);\n\t  hasFile.withArgs(\"package.json\").returns(true);\n\t  t.true(Project.resolveFromPath().isJavaScriptProject);\n\t});\n\ttest(\"detects TypeScript project\", async (t) => {\n", "  const hasFile = stub(Project.prototype, \"hasFile\");\n\t  hasFile.returns(false);\n\t  hasFile.withArgs(\"package.json\").returns(true);\n\t  hasFile.withArgs(\"tsconfig.json\").returns(true);\n\t  t.true(Project.resolveFromPath().isJavaScriptProject);\n\t  t.true(Project.resolveFromPath().isTypeScriptProject);\n\t});\n\ttest(\"detects Node project\", async (t) => {\n\t  const hasFile = stub(Project.prototype, \"hasFile\");\n\t  hasFile.returns(false);\n", "  hasFile.withArgs(\"package.json\").returns(true);\n\t  const readJSON = stub(Project.prototype, \"readJSON\");\n\t  // not a Node project\n\t  readJSON.returns({});\n\t  t.false(Project.resolveFromPath().isNodeProject);\n\t  // Node project with engines.node\n\t  readJSON.returns({ engines: { node: \"x\" } });\n\t  t.true(Project.resolveFromPath().isNodeProject);\n\t  // Node project with @types/node\n\t  readJSON.returns({ dependencies: { \"@types/node\": \"x\" } });\n", "  t.true(Project.resolveFromPath().isNodeProject);\n\t});\n\ttest(\"gets JavaScript dependencies\", async (t) => {\n\t  const hasFile = stub(Project.prototype, \"hasFile\");\n\t  hasFile.returns(false);\n\t  hasFile.withArgs(\"package.json\").returns(true);\n\t  const readJSON = stub(Project.prototype, \"readJSON\");\n\t  readJSON.returns({\n\t    dependencies: { foo: \"1.0.0\" },\n\t    devDependencies: { bar: \"2.0.0\" },\n", "    peerDependencies: { baz: \"3.0.0\" },\n\t  });\n\t  t.deepEqual(Project.resolveFromPath().dependencies, [\n\t    { name: \"foo\", version: \"1.0.0\" },\n\t    { name: \"bar\", version: \"2.0.0\" },\n\t    { name: \"baz\", version: \"3.0.0\" },\n\t  ]);\n\t});\n\ttest(\"gets Go dependencies\", async (t) => {\n\t  const hasFile = stub(Project.prototype, \"hasFile\");\n", "  hasFile.returns(false);\n\t  hasFile.withArgs(\"go.mod\").returns(true);\n\t  const readFile = stub(Project.prototype, \"readFile\");\n\t  readFile.returns(`\n\t    module github.com/owner/repo\n\t    require (\n\t      github.com/foo/bar v1.0.0\n\t      github.com/baz/qux v2.0.0\n\t    )\n\t  `);\n", "  t.deepEqual(Project.resolveFromPath().dependencies, [\n\t    { name: \"github.com/foo/bar\", version: \"v1.0.0\" },\n\t    { name: \"github.com/baz/qux\", version: \"v2.0.0\" },\n\t  ]);\n\t});\n\ttest(\"gets multi-source dependencies\", async (t) => {\n\t  const hasFile = stub(Project.prototype, \"hasFile\");\n\t  hasFile.returns(false);\n\t  hasFile.withArgs(\"package.json\").returns(true);\n\t  hasFile.withArgs(\"go.mod\").returns(true);\n", "  const readJSON = stub(Project.prototype, \"readJSON\");\n\t  readJSON.returns({\n\t    dependencies: { foo: \"1.0.0\" },\n\t    devDependencies: { bar: \"2.0.0\" },\n\t    peerDependencies: { baz: \"3.0.0\" },\n\t  });\n\t  const readFile = stub(Project.prototype, \"readFile\");\n\t  readFile.returns(`\n\t    module github.com/owner/repo\n\t    require (\n", "      github.com/foo/bar v1.0.0\n\t      github.com/baz/qux v2.0.0\n\t    )\n\t  `);\n\t  t.deepEqual(Project.resolveFromPath().dependencies, [\n\t    { name: \"foo\", version: \"1.0.0\" },\n\t    { name: \"bar\", version: \"2.0.0\" },\n\t    { name: \"baz\", version: \"3.0.0\" },\n\t    { name: \"github.com/foo/bar\", version: \"v1.0.0\" },\n\t    { name: \"github.com/baz/qux\", version: \"v2.0.0\" },\n", "  ]);\n\t});\n\ttest(\"checks if dependency exists\", async (t) => {\n\t  const hasFile = stub(Project.prototype, \"hasFile\");\n\t  hasFile.returns(false);\n\t  hasFile.withArgs(\"package.json\").returns(true);\n\t  const readJSON = stub(Project.prototype, \"readJSON\");\n\t  readJSON.returns({\n\t    dependencies: { foo: \"1.0.0\" },\n\t    devDependencies: { bar: \"2.0.0\" },\n", "    peerDependencies: { baz: \"3.0.0\" },\n\t  });\n\t  t.true(Project.resolveFromPath().hasDependency(\"foo\"));\n\t  t.true(Project.resolveFromPath().hasDependency(\"bar\"));\n\t  t.true(Project.resolveFromPath().hasDependency(\"baz\"));\n\t  t.false(Project.resolveFromPath().hasDependency(\"brr\"));\n\t});\n\ttest(\"checks if any of dependency[] exists\", async (t) => {\n\t  const hasFile = stub(Project.prototype, \"hasFile\");\n\t  hasFile.returns(false);\n", "  hasFile.withArgs(\"package.json\").returns(true);\n\t  const readJSON = stub(Project.prototype, \"readJSON\");\n\t  readJSON.returns({\n\t    dependencies: { foo: \"1.0.0\" },\n\t  });\n\t  t.true(Project.resolveFromPath().hasAnyDependency([\"foo\", \"bar\", \"baz\"]));\n\t  t.false(Project.resolveFromPath().hasAnyDependency([\"moo\", \"bar\", \"baz\"]));\n\t});\n"]}
{"filename": "src/loader-cjs.ts", "chunked_list": ["import _Module from \"module\";\n\timport { resolve, dirname } from \"node:path\";\n\timport { fileURLToPath } from \"node:url\";\n\ttype ModuleType = {\n\t  _resolveFilename: ResolveFilenameSignature;\n\t};\n\ttype ResolveFilenameSignature = (\n\t  request: string,\n\t  parent: NodeJS.Module | null,\n\t  isMain?: boolean,\n", "  options?: any\n\t) => string;\n\tconst Module = _Module as unknown as ModuleType;\n\tconst autoLoaderPath = resolve(dirname(fileURLToPath(import.meta.url)), \"globals/index.cjs\");\n\tconst resolveFilename = Module._resolveFilename;\n\tModule._resolveFilename = function (request, parent, isMain, options) {\n\t  if (request === \"auto\") {\n\t    return autoLoaderPath;\n\t  }\n\t  return resolveFilename.call(this, request, parent, isMain, options);\n", "};\n"]}
{"filename": "src/setup.ts", "chunked_list": ["import { dirname, resolve } from \"node:path\";\n\timport { fileURLToPath } from \"node:url\";\n\timport fs from \"fs-extra\";\n\texport const setupTSConfig = (tsConfigPath: string) => {\n\t  const pathToDistGlobals = resolve(dirname(fileURLToPath(import.meta.url)), \"..\", \"dist\", \"globals\");\n\t  return fs.writeFile(\n\t    tsConfigPath,\n\t    JSON.stringify(\n\t      {\n\t        compilerOptions: {\n", "          strict: true,\n\t          lib: [],\n\t          jsx: \"react-jsx\",\n\t          baseUrl: \".\",\n\t          typeRoots: [pathToDistGlobals],\n\t          paths: {\n\t            auto: [pathToDistGlobals],\n\t          },\n\t        },\n\t      },\n", "      null,\n\t      2\n\t    )\n\t  );\n\t};\n"]}
{"filename": "src/commands/repl.ts", "chunked_list": ["/* eslint-disable no-await-in-loop */\n\timport { resolve } from \"node:path\";\n\timport repl from \"node:repl\";\n\timport { command } from \"cleye\";\n\timport chalk from \"chalk\";\n\timport envPaths from \"env-paths\";\n\timport Project from \"../Project\";\n\timport { AutoReturnType } from \"../types\";\n\timport packageJson from \"../../package.json\";\n\texport const createReplCommand = (project: Project, scripts: AutoReturnType[]) =>\n", "  command({ name: \"repl\" }, async () => {\n\t    (global as any).project = project;\n\t    (global as any).scripts = scripts;\n\t    const r = repl.start({\n\t      prompt: chalk.greenBright(\"> \"),\n\t      useGlobal: true,\n\t      terminal: true,\n\t    });\n\t    // eslint-disable-next-line @typescript-eslint/no-empty-function\n\t    r.setupHistory(resolve(envPaths(packageJson.name, { suffix: \"\" }).cache, \"history\"), () => {});\n", "  });\n"]}
{"filename": "src/commands/run.ts", "chunked_list": ["/* eslint-disable no-await-in-loop */\n\timport { command } from \"cleye\";\n\timport chalk from \"chalk\";\n\timport Project from \"../Project\";\n\timport { AutoReturnType } from \"../types\";\n\timport { tildify } from \"../utils/path\";\n\timport { dirname, resolve } from \"node:path\";\n\timport { globSync } from \"glob\";\n\timport * as inquirer from \"@inquirer/prompts\";\n\texport const createRunCommand = (project: Project, scripts: AutoReturnType[]) =>\n", "  command({ name: \"run\", alias: \"r\", parameters: [\"<script id>\"] }, async (argv) => {\n\t    const { scriptId } = argv._;\n\t    const script = scripts.find((t) => t.id === scriptId);\n\t    if (!script) {\n\t      console.error(chalk.red(`Error: script \"%s\" not found.`), scriptId);\n\t      process.exit(1);\n\t    }\n\t    if (script.isValid && !script.isValid(project)) {\n\t      console.error(chalk.red(`Error: script \"%s\" is not valid for this context.`), scriptId);\n\t      process.exit(1);\n", "    }\n\t    console.log(chalk.blue(\"Info:\"), \"Running\", chalk.magenta(tildify(script.path)));\n\t    // gather params\n\t    const scriptParams = script.bootstrapParams();\n\t    for (const [_, param] of Object.entries(scriptParams)) {\n\t      // dynamic default values\n\t      if (typeof param.defaultValue === \"function\") {\n\t        const value = param.defaultValue({\n\t          project,\n\t          params: Object.fromEntries(\n", "            Object.entries(scriptParams).map(([key, currentParam]) => {\n\t              return [key, currentParam.value];\n\t            })\n\t          ),\n\t        });\n\t        if (value !== undefined) param.value = value;\n\t      }\n\t      // eslint-disable-next-line default-case\n\t      switch (param.type) {\n\t        case \"boolean\": {\n", "          param.value = await inquirer.confirm({\n\t            message: param.title,\n\t            default: param.value as boolean,\n\t          });\n\t          break;\n\t        }\n\t        case \"number\": {\n\t          const stringValue = await inquirer.input({\n\t            message: param.title,\n\t            default: param.value.toString(),\n", "          });\n\t          param.value = Number(stringValue);\n\t          break;\n\t        }\n\t        case \"string\": {\n\t          param.value = await inquirer.input({\n\t            message: param.title,\n\t            default: param.value as string,\n\t          });\n\t          if (param.required && param.value === \"\") {\n", "            console.error(chalk.red(`Error: Parameter \"%s\" is required.`), param.title);\n\t            process.exit(1);\n\t          }\n\t          break;\n\t        }\n\t      }\n\t    }\n\t    const paramValues = Object.fromEntries(\n\t      Object.entries(scriptParams).map(([key, param]) => {\n\t        return [key, param.value];\n", "      })\n\t    );\n\t    const t = (text: string, params: Record<string, boolean | number | string> = paramValues) => {\n\t      let result = text;\n\t      for (const [key, value] of Object.entries(params)) {\n\t        result = result.replace(new RegExp(`__${key}__`, \"g\"), String(value));\n\t      }\n\t      return result;\n\t    };\n\t    // collect script files\n", "    const scriptDir = dirname(script.path);\n\t    const files = globSync(\"**/*\", { cwd: scriptDir, dot: true, nodir: true, ignore: script.path }).map((path) => {\n\t      return {\n\t        path,\n\t        get content() {\n\t          return fs.readFileSync(resolve(scriptDir, path), \"utf8\");\n\t        },\n\t      };\n\t    });\n\t    // run the script\n", "    script.run({\n\t      cwd: process.cwd(),\n\t      files,\n\t      params: paramValues as Parameters<typeof script.run>[0][\"params\"],\n\t      project: Project.resolveFromPath(process.cwd()),\n\t      self: script,\n\t      get fileMap() {\n\t        return new Proxy(\n\t          {},\n\t          {\n", "            get(_, path) {\n\t              if (typeof path !== \"string\") throw new Error(\"Invalid path.\");\n\t              if (!fs.existsSync(resolve(scriptDir, path))) throw new Error(`File \"${path}\" not found.`);\n\t              return fs.readFileSync(resolve(scriptDir, path as string), \"utf8\");\n\t            },\n\t          }\n\t        );\n\t      },\n\t      t,\n\t    });\n", "  });\n"]}
{"filename": "src/commands/list.ts", "chunked_list": ["import { command } from \"cleye\";\n\timport chalk from \"chalk\";\n\timport Project from \"../Project\";\n\timport { AutoReturnType } from \"../types\";\n\texport const createListCommand = (project: Project, scripts: AutoReturnType[]) =>\n\t  command({ name: \"list\", alias: \"ls\", flags: { all: Boolean } }, (argv) => {\n\t    const filteredScripts = argv.flags.all ? scripts : scripts.filter((t) => !t.isValid || t.isValid(project));\n\t    for (const script of filteredScripts) {\n\t      console.log(\n\t        chalk.grey(\"-\"),\n", "        chalk.magenta(`<${script.id}>`),\n\t        chalk.cyan(script.title ?? \"\"),\n\t        script.isLocal ? chalk.blue(\"(local)\") : chalk.yellow(\"(main)\")\n\t      );\n\t    }\n\t  });\n"]}
{"filename": "src/utils/path.ts", "chunked_list": ["import os from \"node:os\";\n\timport envPaths from \"env-paths\";\n\timport { findUpSync } from \"find-up\";\n\timport { resolve } from \"node:path\";\n\tconst rootMatchingConfigurations = [\n\t  { match: \"package.json\", type: \"file\" },\n\t  { match: \"go.mod\", type: \"file\" },\n\t  { match: \"Makefile\", type: \"file\" },\n\t  { match: \".git\", type: \"directory\" },\n\t] as const;\n", "export const tildify = (path: string) => path.replace(os.homedir(), \"~\");\n\texport const getGlobalRepositoryPath = () => {\n\t  return envPaths(\"auto\", { suffix: \"\" }).config;\n\t};\n\texport const resolveProjectRoot = (cwd: string) => {\n\t  let root = cwd;\n\t  for (const { match, type } of rootMatchingConfigurations) {\n\t    const foundPath = findUpSync(match, { cwd: root, type });\n\t    if (foundPath) {\n\t      root = resolve(foundPath, \"..\");\n", "      break;\n\t    }\n\t  }\n\t  return root;\n\t};\n"]}
{"filename": "src/utils/test.ts", "chunked_list": ["import sinon from \"sinon\";\n\texport const stub = <T extends {}>(target: T, key: keyof T) => {\n\t  try {\n\t    // @ts-ignore\n\t    target[key].restore();\n\t  } catch {}\n\t  return sinon.stub(target, key);\n\t};\n"]}
{"filename": "src/e2e/utils.ts", "chunked_list": ["import fs from \"fs-extra\";\n\timport { resolve as resolvePath } from \"path\";\n\timport { execa } from \"execa\";\n\texport const runCommandWithInputs = (\n\t  command: string,\n\t  inputs: { on: string; value: string }[],\n\t  opts?: { cwd: string }\n\t) => {\n\t  const [cmd, ...args] = command.split(\" \");\n\t  return new Promise<{ stdout: string }>((resolve, reject) => {\n", "    const proc = execa(cmd, args, { ...opts, stdin: \"pipe\" });\n\t    proc.stdin!.setDefaultEncoding(\"utf8\");\n\t    let stdout = \"\";\n\t    let stdoutChunk = \"\";\n\t    let currentInputIndex = 0;\n\t    const loop = () => {\n\t      if (currentInputIndex === inputs.length) {\n\t        proc.stdin!.end();\n\t      } else if (stdoutChunk.includes(inputs[currentInputIndex].on)) {\n\t        console.log(\" - Simulating input:\", inputs[currentInputIndex].value);\n", "        stdoutChunk = \"\";\n\t        proc.stdin!.write(inputs[currentInputIndex].value + \"\\n\");\n\t        currentInputIndex++;\n\t      }\n\t    };\n\t    proc.stdout!.on(\"data\", (chunk) => {\n\t      stdout += chunk;\n\t      stdoutChunk += chunk;\n\t      loop();\n\t    });\n", "    proc.stderr!.on(\"data\", (chunk) => {\n\t      console.error(chunk.toString());\n\t      reject(new Error(\"Error in stderr\"));\n\t    });\n\t    proc.on(\"exit\", () => resolve({ stdout }));\n\t  });\n\t};\n\texport const lazyRead = (filePath: string, modifier?: (value: string) => string) => () => {\n\t  const value = fs.readFileSync(filePath, \"utf8\").trim();\n\t  return modifier ? modifier(value) : value;\n", "};\n\texport const generateMockProject = async (files: Record<string, string>) => {\n\t  const projectPath = await fs.mkdtemp(\"/tmp/auto-e2e\");\n\t  for (const [path, content] of Object.entries(files)) {\n\t    // eslint-disable-next-line no-await-in-loop\n\t    await fs.outputFile(resolvePath(projectPath, path), content);\n\t  }\n\t  return projectPath;\n\t};\n"]}
{"filename": "src/e2e/index.ts", "chunked_list": ["/* eslint-disable no-await-in-loop */\n\t/* eslint-disable unicorn/no-await-expression-member */\n\timport { resolve } from \"node:path\";\n\timport fs from \"fs-extra\";\n\timport assert from \"node:assert\";\n\timport { setupTSConfig } from \"../setup\";\n\timport { getGlobalRepositoryPath } from \"../utils/path\";\n\timport commandTests from \"./commands\";\n\timport * as exampleTests from \"./examples\";\n\timport { generateMockProject } from \"./utils\";\n", "export type Test = {\n\t  name?: string;\n\t  run: (cwd: string) => Promise<{\n\t    stdout?: string;\n\t    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\t  } | void>;\n\t  project?: {\n\t    [path: string]: string;\n\t  };\n\t  prepare?: (cwd: string) => Promise<void>; // cwd is the mocked project cwd if present, or the current pwd\n", "  expected: {\n\t    stdout?: string | ((args: { cwd?: string }) => string);\n\t    files?: Record<string, string | ((v: string) => string)>;\n\t  };\n\t};\n\t// global setup\n\tconst globalRepositoryPath = getGlobalRepositoryPath();\n\tconsole.log(`Setting up global repository at: ${globalRepositoryPath}`);\n\tawait fs.mkdirp(globalRepositoryPath);\n\tawait fs.copy(\"./examples\", globalRepositoryPath);\n", "const tsConfigPath = resolve(globalRepositoryPath, \"tsconfig.json\");\n\tawait setupTSConfig(tsConfigPath);\n\t// generate tsconfig\n\tassert(await fs.exists(tsConfigPath));\n\tconst tsConfig = await fs.readJson(tsConfigPath);\n\tassert.deepEqual(\n\t  tsConfig,\n\t  {\n\t    compilerOptions: {\n\t      strict: true,\n", "      lib: [],\n\t      jsx: \"react-jsx\",\n\t      baseUrl: \".\",\n\t      typeRoots: [\"/root/source/dist/globals\"],\n\t      paths: {\n\t        auto: [\"/root/source/dist/globals\"],\n\t      },\n\t    },\n\t  },\n\t  \"Generated tsconfig.json is invalid.\"\n", ");\n\tconst tests = { ...commandTests, ...exampleTests };\n\tfor (const [name, test] of Object.entries(tests)) {\n\t  let cwd = process.cwd();\n\t  console.log(`Testing: ${test.name ?? name}`);\n\t  if (test.project) {\n\t    const projectPath = await generateMockProject(test.project);\n\t    cwd = projectPath;\n\t    console.log(`  - Generated mock project at: ${projectPath}`);\n\t  }\n", "  if (test.prepare) {\n\t    await test.prepare(cwd);\n\t  }\n\t  const result = await test.run(cwd);\n\t  if (test.expected.stdout) {\n\t    if (!result?.stdout) throw new Error(`Test \"${test.name ?? name}\" doesn't provide stdout.`);\n\t    const expectedStdout =\n\t      typeof test.expected.stdout === \"function\" ? test.expected.stdout({ cwd }) : test.expected.stdout;\n\t    assert.equal(result.stdout.trim(), expectedStdout.trim(), `Test \"${test.name ?? name}\" stdout is invalid.`);\n\t  }\n", "  if (test.expected.files) {\n\t    for (const [path, expectedContent] of Object.entries(test.expected.files)) {\n\t      const filePath = resolve(cwd, path);\n\t      const actualContent = await fs.readFile(filePath, \"utf-8\");\n\t      assert.equal(\n\t        actualContent.trim(),\n\t        (typeof expectedContent === \"function\" ? expectedContent(actualContent).trim() : expectedContent).trim(),\n\t        `Test \"${test.name ?? name}\" file ${path} is invalid.`\n\t      );\n\t    }\n", "  }\n\t}\n"]}
{"filename": "src/e2e/commands/list.ts", "chunked_list": ["import { execa } from \"execa\";\n\timport type { Test } from \"../index\";\n\texport const list: Test = {\n\t  name: \"list.global\",\n\t  run: async (cwd) => {\n\t    const { stdout } = await execa(\"auto\", [\"ls\"], { cwd });\n\t    return { stdout };\n\t  },\n\t  expected: {\n\t    stdout: `\n", "Info: Using main repository: ~/.config/auto\n\t- <shell> Shell-like usage (main)\n\t- <prompts> Auto prompts (main)\n\t- <fetch> Fetch (main)\n\t`,\n\t  },\n\t};\n\texport const listLocal: Test = {\n\t  name: \"list.local\",\n\t  project: {\n", "    \"package.json\": \"{}\",\n\t    \"auto/tsconfig.json\": \"{}\",\n\t    \"auto/fetch.ts\": `\n\timport \"auto\";\n\texport default auto({\n\t  id: \"fetch\",\n\t  title: \"Fetch\",\n\t  run: async () => {\n\t    console.log(\"fetch\");\n\t  },\n", "});\n\t`.trim(),\n\t  },\n\t  run: async (cwd) => {\n\t    const { stdout } = await execa(\"auto\", [\"ls\"], { cwd });\n\t    return { stdout };\n\t  },\n\t  expected: {\n\t    stdout: ({ cwd }) => `\n\tInfo: Using main repository: ~/.config/auto\n", "Info: Using local repository: ${cwd}/auto\n\t- <shell> Shell-like usage (main)\n\t- <prompts> Auto prompts (main)\n\t- <fetch> Fetch (local)\n\t`,\n\t  },\n\t};\n"]}
{"filename": "src/e2e/commands/index.ts", "chunked_list": ["import * as listCommands from \"./list\";\n\texport default {\n\t  ...listCommands,\n\t};\n"]}
{"filename": "src/e2e/examples/generate-react-component-inline.ts", "chunked_list": ["import type { Test } from \"../index\";\n\timport { runCommandWithInputs } from \"../utils\";\n\tconst expectedFiles = {\n\t  index: 'export * from \"./__name__\";',\n\t  component: `\n\timport React from \"react\";\n\texport interface __name__Props {\n\t}\n\texport const __name__ = (props: __name__Props) => {\n\t  return (\n", "    <div>__name__</div>\n\t  );\n\t};`.trim(),\n\t  storybook: `\n\timport { ComponentStory } from \"@storybook/react\";\n\timport { __name__, __name__Props } from \"./__name__\";\n\texport default {\n\t  title: \"__name__\",\n\t  component: __name__,\n\t};\n", "const Template: ComponentStory<typeof __name__> = (props: __name__Props) => {\n\t  return <__name__ {...props} />;\n\t};\n\texport const Default = Template.bind({});\n\tDefault.args = {};`.trim(),\n\t};\n\texport const generateReactComponentInline: Test = {\n\t  project: {\n\t    \"package.json\": JSON.stringify({\n\t      name: \"app\",\n", "      dependencies: {\n\t        react: \"*\",\n\t        \"@storybook/react\": \"*\",\n\t        \"@testing-library/react\": \"*\",\n\t        \"@testing-library/user-event\": \"*\",\n\t      },\n\t    }),\n\t  },\n\t  run: (cwd) => {\n\t    return runCommandWithInputs(\n", "      \"auto run react-component-inline\",\n\t      [\n\t        { on: \"Component Name\", value: \"MyComponent\" },\n\t        { on: \"Target path:\", value: \"src/components/MyComponent\" },\n\t      ],\n\t      { cwd }\n\t    );\n\t  },\n\t  expected: {\n\t    files: {\n", "      \"src/components/MyComponent/index.ts\": expectedFiles.index.replace(/__name__/g, \"MyComponent\"),\n\t      \"src/components/MyComponent/MyComponent.tsx\": expectedFiles.component.replace(/__name__/g, \"MyComponent\"),\n\t      \"src/components/MyComponent/MyComponent.stories.tsx\": expectedFiles.storybook.replace(/__name__/g, \"MyComponent\"),\n\t      \"src/components/MyComponent/MyComponent.test.tsx\": `\n\timport { render, screen } from \"@testing-library/react\";\n\timport userEvent from \"@testing-library/user-event\";\n\timport { __name__ } from \"./__name__\";\n\tdescribe(\"__name__\", () => {\n\t  beforeEach(() => {\n\t    jest.clearAllMocks();\n", "  });\n\t  it.todo(\"should render\");\n\t});`.replace(/__name__/g, \"MyComponent\"),\n\t    },\n\t  },\n\t};\n"]}
{"filename": "src/e2e/examples/shell.ts", "chunked_list": ["import { execa } from \"execa\";\n\timport type { Test } from \"../index\";\n\texport const shell: Test = {\n\t  run: async (cwd) => {\n\t    const { stdout } = await execa(\"auto\", [\"run\", \"shell\"], { cwd });\n\t    return { stdout };\n\t  },\n\t  expected: {\n\t    stdout: `\n\tInfo: Using main repository: ~/.config/auto\n", "Info: Running ~/.config/auto/shell.ts\n\t  \"license\": \"MIT\",\n\t\"Hello, root\"\n\t\"1\"\n\t\"2\"\n\t[ '\"1\"', '\"2\"' ]\n\t0`,\n\t  },\n\t};\n"]}
{"filename": "src/e2e/examples/index.ts", "chunked_list": ["export * from \"./fetch\";\n\texport * from \"./generate-react-component\";\n\texport * from \"./generate-react-component-inline\";\n\texport * from \"./shell\";\n"]}
{"filename": "src/e2e/examples/fetch.ts", "chunked_list": ["import * as http from \"http\";\n\timport { execa } from \"execa\";\n\timport type { Test } from \"../index\";\n\texport const fetch: Test = {\n\t  run: async (cwd) => {\n\t    const server = http.createServer((_, res) => {\n\t      res.writeHead(200, { \"Content-Type\": \"text/plain\" });\n\t      res.end(\"Hello\");\n\t    });\n\t    server.listen(9123);\n", "    const { stdout } = await execa(\"auto\", [\"run\", \"fetch\"], { cwd });\n\t    server.close();\n\t    return { stdout };\n\t  },\n\t  expected: {\n\t    stdout: `\n\tInfo: Using main repository: ~/.config/auto\n\tInfo: Running ~/.config/auto/fetch.ts\n\tHello`,\n\t  },\n", "};\n"]}
{"filename": "src/e2e/examples/generate-react-component.ts", "chunked_list": ["import path from \"node:path\";\n\timport os from \"node:os\";\n\timport type { Test } from \"../index\";\n\timport { lazyRead, runCommandWithInputs } from \"../utils\";\n\tconst exampleDir = path.join(os.homedir(), \".config/auto\", \"generate-react-component\");\n\tconst files = Object.entries({\n\t  index: \"index.ts\",\n\t  component: `__name__.tsx`,\n\t  stories: `__name__.stories.tsx`,\n\t  test: `__name__.test.tsx`,\n", "}).reduce<Record<string, string>>((acc, [k, v]) => {\n\t  acc[k] = path.join(exampleDir, v);\n\t  return acc;\n\t}, {});\n\texport const generateReactComponent: Test = {\n\t  project: {\n\t    \"package.json\": JSON.stringify({\n\t      name: \"app\",\n\t      dependencies: { react: \"*\", jest: \"*\", storybook: \"*\" },\n\t    }),\n", "  },\n\t  run: (cwd) => {\n\t    return runCommandWithInputs(\n\t      \"auto run react-component\",\n\t      [\n\t        { on: \"Component Name\", value: \"MyComponent\" },\n\t        { on: \"Component Path\", value: \"src/components/MyComponent\" },\n\t      ],\n\t      { cwd }\n\t    );\n", "  },\n\t  expected: {\n\t    files: {\n\t      \"src/components/MyComponent/index.ts\": lazyRead(files.index, (v) => v.replace(/__name__/g, \"MyComponent\")),\n\t      \"src/components/MyComponent/MyComponent.tsx\": lazyRead(files.component, (v) =>\n\t        v.replace(/__name__/g, \"MyComponent\")\n\t      ),\n\t      \"src/components/MyComponent/MyComponent.stories.tsx\": lazyRead(files.stories, (v) =>\n\t        v.replace(/__name__/g, \"MyComponent\")\n\t      ),\n", "      \"src/components/MyComponent/MyComponent.test.tsx\": lazyRead(files.test, (v) =>\n\t        v.replace(/__name__/g, \"MyComponent\")\n\t      ),\n\t    },\n\t  },\n\t};\n"]}
{"filename": "src/globals/sleep.ts", "chunked_list": ["export default (ms: number) =>\n\t  new Promise<void>((resolve) => {\n\t    setTimeout(resolve, ms);\n\t  });\n"]}
{"filename": "src/globals/shell.ts", "chunked_list": ["export default {\n\t  cwd() {\n\t    return process.cwd();\n\t  },\n\t  cd(path: TemplateStringsArray | string) {\n\t    process.chdir(typeof path === \"string\" ? path : path[0]);\n\t    return process.cwd();\n\t  },\n\t  get pwd() {\n\t    return process.cwd();\n", "  },\n\t  set pwd(path: string) {\n\t    process.chdir(path);\n\t  },\n\t};\n"]}
{"filename": "src/globals/index.ts", "chunked_list": ["/* eslint-disable @shopify/restrict-full-import */\n\timport * as _chalk from \"chalk\";\n\timport * as _execa from \"execa\";\n\timport * as _glob from \"glob\";\n\timport * as _fs_t from \"fs-extra\";\n\timport * as _lodash_t from \"lodash\";\n\timport * as _which_t from \"which\";\n\timport * as _inquirer from \"@inquirer/prompts\";\n\timport _fs from \"fs-extra\";\n\timport _lodash from \"lodash\";\n", "import _which from \"which\";\n\timport * as types from \"../types\";\n\timport _sleep from \"./sleep\";\n\timport shell from \"./shell\";\n\tObject.assign(global, {\n\t  // core\n\t  auto: types.auto,\n\t  // internal utils\n\t  ...shell,\n\t  sleep: _sleep,\n", "  // external utils\n\t  $$: _execa.$({ verbose: true }),\n\t  $: _execa.$,\n\t  chalk: _chalk,\n\t  prompt: _inquirer,\n\t  inquirer: _inquirer,\n\t  execa: _execa.execa,\n\t  execaSync: _execa.execaSync,\n\t  fs: _fs,\n\t  glob: _glob,\n", "  lodash: _lodash,\n\t  which: _which,\n\t});\n\t// accessors\n\tObject.defineProperty(globalThis, \"pwd\", {\n\t  get() {\n\t    return shell.cwd();\n\t  },\n\t  set(path: string) {\n\t    shell.cd(path);\n", "  },\n\t});\n\tdeclare global {\n\t  const auto: types.AutoType;\n\t  const cd: typeof shell.cd;\n\t  const pwd: string;\n\t  // @ts-ignore damn you tsserver\n\t  const sleep: typeof _sleep;\n\t  const $$: typeof _execa.$;\n\t  const $: typeof _execa.$;\n", "  const chalk: typeof _chalk;\n\t  const prompt: typeof _inquirer;\n\t  const inquirer: typeof _inquirer;\n\t  const execa: typeof _execa.execa;\n\t  const execaSync: typeof _execa.execaSync;\n\t  const glob: typeof _glob;\n\t  const fs: typeof _fs_t;\n\t  const lodash: typeof _lodash_t;\n\t  const which: typeof _which_t;\n\t}\n"]}
