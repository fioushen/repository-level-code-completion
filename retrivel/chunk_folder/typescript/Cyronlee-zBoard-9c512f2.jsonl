{"filename": "fake/build_status.fake.ts", "chunked_list": ["import { faker } from '@faker-js/faker';\n\tconst repos = Array.from({ length: 9 }).map(() => {\n\t  return {\n\t    projectName: faker.word.noun(),\n\t    branch: faker.helpers.arrayElement(['master', 'release']),\n\t  };\n\t});\n\texport const getBuildStatusFakeData = () => {\n\t  return repos.map((repo) => {\n\t    return {\n", "      projectName: repo.projectName,\n\t      branch: repo.branch,\n\t      status: faker.helpers.arrayElement([\n\t        'success',\n\t        'failed',\n\t        'on_hold',\n\t        'running',\n\t        'canceled',\n\t        'unauthorized',\n\t      ]),\n", "      stopTime: faker.date.recent(1).toISOString(),\n\t      username: faker.name.fullName(),\n\t      avatarUrl: faker.image.avatar(),\n\t      commitSubject: faker.git.commitMessage(),\n\t    };\n\t  });\n\t};\n"]}
{"filename": "fake/ticket_status.fake.ts", "chunked_list": ["import { faker } from '@faker-js/faker';\n\texport const getTicketStatusFakeData = () => {\n\t  return Array.from({ length: 20 }).map(() => {\n\t    return {\n\t      subject: faker.lorem.sentence(25),\n\t      status: faker.helpers.arrayElement(['new', 'open', 'pending']),\n\t      url: faker.internet.url(),\n\t      created_at: faker.date.recent(1).toISOString(),\n\t      updated_at: faker.date.recent(1).toISOString(),\n\t    };\n", "  });\n\t};\n"]}
{"filename": "fake/project_timeline.fake.ts", "chunked_list": ["import { faker } from '@faker-js/faker';\n\texport const getProjectTimelineFakeData = () => {\n\t  return Array.from({ length: 10 }).map(() => {\n\t    const startDate = faker.date.between(faker.date.recent(30), faker.date.soon(30));\n\t    const endDate = faker.date.soon(30, startDate);\n\t    return {\n\t      cardNo: faker.random.numeric(6),\n\t      cardName: faker.lorem.sentence(20),\n\t      startDate: startDate.toISOString().slice(0, 10),\n\t      endDate: endDate.toISOString().slice(0, 10),\n", "      color: faker.helpers.arrayElement(['4681c8', 'cf7035', '795fce']),\n\t      owner: {\n\t        name: faker.name.fullName(),\n\t        avatar: faker.image.avatar(),\n\t      },\n\t      coOwners: [\n\t        {\n\t          name: faker.name.fullName(),\n\t          avatar: faker.image.avatar(),\n\t        },\n", "      ],\n\t    };\n\t  });\n\t};\n"]}
{"filename": "fake/owner_rotation.fake.ts", "chunked_list": ["import { faker } from '@faker-js/faker';\n\timport moment from 'moment';\n\texport const getOwnerRotationFakeData = () => {\n\t  return Array.from(['STAND UP', 'USER SUPPORT', 'RETRO', 'ALERTS']).map((type) => {\n\t    return {\n\t      subject: type,\n\t      color: faker.helpers.arrayElement(['green', 'cyan', 'blue', 'teal', 'purple', 'pink']),\n\t      icon: faker.helpers.arrayElement(['email', 'repeat', 'calendar']),\n\t      members: [\n\t        {\n", "          name: faker.name.fullName(),\n\t          startDate: moment().subtract(14, 'days').format('YYYY-MM-DD'),\n\t          endDate: moment().subtract(8, 'days').format('YYYY-MM-DD'),\n\t        },\n\t        {\n\t          name: faker.name.fullName(),\n\t          startDate: moment().subtract(7, 'days').format('YYYY-MM-DD'),\n\t          endDate: moment().add(7, 'days').format('YYYY-MM-DD'),\n\t        },\n\t        {\n", "          name: faker.name.fullName(),\n\t          startDate: moment().add(8, 'days').format('YYYY-MM-DD'),\n\t          endDate: moment().add(14, 'days').format('YYYY-MM-DD'),\n\t        },\n\t      ],\n\t    };\n\t  });\n\t};\n"]}
{"filename": "src/middleware.ts", "chunked_list": ["import { NextResponse } from 'next/server';\n\timport type { NextRequest } from 'next/server';\n\timport { siteConfig } from '@/../config/site.config';\n\t// This function can be marked `async` if using `await` inside\n\texport function middleware(request: NextRequest) {\n\t  if (request.nextUrl.pathname.startsWith('/login')) {\n\t    if (!needSitePassword || isAuthenticated(request)) {\n\t      return toHomePage(request);\n\t    }\n\t    return NextResponse.next();\n", "  }\n\t  if (!needSitePassword) {\n\t    return NextResponse.next();\n\t  }\n\t  if (isAuthenticated(request)) {\n\t    return NextResponse.next();\n\t  }\n\t  if (request.nextUrl.pathname.startsWith('/api')) {\n\t    return unauthorizedResponse;\n\t  }\n", "  return toLoginPage(request);\n\t}\n\tconst needSitePassword = siteConfig.enableSitePassword && siteConfig.sitePassword;\n\tconst isAuthenticated = (request: NextRequest) => {\n\t  const sitePassword = request.cookies.get('site_password')?.value;\n\t  return sitePassword === siteConfig.sitePassword;\n\t};\n\tconst toHomePage = (request: NextRequest) => {\n\t  return NextResponse.redirect(new URL('/', request.url));\n\t};\n", "const toLoginPage = (request: NextRequest) => {\n\t  return NextResponse.redirect(new URL('/login', request.url));\n\t};\n\tconst unauthorizedResponse = new NextResponse(\n\t  JSON.stringify({ success: false, message: 'authentication failed' }),\n\t  {\n\t    status: 401,\n\t    headers: { 'content-type': 'application/json' },\n\t  }\n\t);\n", "export const config = {\n\t  matcher: [\n\t    /*\n\t     * Match all request paths except for the ones starting with:\n\t     * - _next/static (static files)\n\t     * - _next/image (image optimization files)\n\t     * - favicon.ico (favicon file)\n\t     */\n\t    '/((?!_next/static|_next/image|favicon.ico).*)',\n\t  ],\n", "};\n"]}
{"filename": "src/pages/api/github_build_status.ts", "chunked_list": ["import { NextApiHandler } from 'next';\n\timport { buildStatusConfig } from '@/../config/build_status.config';\n\tinterface workflowRunResponse {\n\t  total_count: number;\n\t  workflow_runs: WorkflowRun[];\n\t}\n\t/**\n\t * An invocation of a workflow\n\t */\n\tinterface WorkflowRun {\n", "  id: number;\n\t  name?: string | null;\n\t  head_branch: string | null;\n\t  head_sha: string;\n\t  path: string;\n\t  run_number: number;\n\t  status: string | null;\n\t  conclusion: string | null;\n\t  workflow_id: number;\n\t  created_at: string;\n", "  updated_at: string;\n\t  actor?: SimpleUser;\n\t  triggering_actor?: SimpleUser;\n\t  run_started_at?: string;\n\t  jobs_url: string;\n\t  head_commit: null | SimpleCommit;\n\t  display_title: string;\n\t}\n\tinterface SimpleUser {\n\t  login: string;\n", "  avatar_url: string;\n\t  gravatar_id: string | null;\n\t}\n\t/**\n\t * A commit.\n\t */\n\tinterface SimpleCommit {\n\t  id: string;\n\t  tree_id: string;\n\t  message: string;\n", "  timestamp: string;\n\t  author: {\n\t    name: string;\n\t    email: string;\n\t  } | null;\n\t  committer: {\n\t    name: string;\n\t    email: string;\n\t  } | null;\n\t}\n", "const githubActionsConfig = buildStatusConfig.datasource.github;\n\tconst handler: NextApiHandler = async (req, res) => {\n\t  getAllGitHubStatus()\n\t    .then((response) => res.status(200).json(response))\n\t    .catch((err) => res.status(500).send(err.message));\n\t};\n\texport const getAllGitHubStatus = async () => {\n\t  if (githubActionsConfig.enabled) {\n\t    return await Promise.all(githubActionsConfig.projects.map((project) => getStatus(project)));\n\t  }\n", "  return [];\n\t};\n\tconst getStatus = async ({\n\t  projectName,\n\t  owner,\n\t  repo,\n\t  branch,\n\t  workflowId,\n\t}: {\n\t  projectName: string;\n", "  owner: string;\n\t  repo: string;\n\t  branch: string;\n\t  workflowId: number;\n\t}) => {\n\t  const url = `${githubActionsConfig.baseUrl}/repos/${owner}/${repo}/actions/workflows/${workflowId}/runs?per_page=1&branch=${branch}`;\n\t  const response = await fetch(url, {\n\t    headers: {\n\t      Authorization: `Bearer ${githubActionsConfig.apiToken}`,\n\t    },\n", "  });\n\t  let json: workflowRunResponse = await response.json();\n\t  if (!response.ok) {\n\t    throw new Error(JSON.stringify(json));\n\t  }\n\t  const workflowRun = json.workflow_runs[0];\n\t  return {\n\t    platform: 'Github',\n\t    projectName: projectName,\n\t    branch: branch,\n", "    status: workflowRun.status === 'completed' ? workflowRun.conclusion : workflowRun.status,\n\t    stopTime: workflowRun.updated_at,\n\t    username: workflowRun.triggering_actor?.login,\n\t    avatarUrl: workflowRun.triggering_actor?.avatar_url,\n\t    commitSubject: workflowRun.head_commit?.message,\n\t  };\n\t};\n\texport default handler;\n"]}
{"filename": "src/pages/api/project_timeline.ts", "chunked_list": ["import { NextApiHandler } from 'next';\n\timport moment, { Moment } from 'moment';\n\timport { getProjectTimelineFakeData } from '../../../fake/project_timeline.fake';\n\timport { delay1s } from '@/lib/delay';\n\timport { projectTimelineConfig } from '../../../config/project_timeline.config';\n\tinterface CardTransition {\n\t  column_id: number;\n\t  start: string | Moment;\n\t}\n\tinterface TimelineCard {\n", "  startDate: string;\n\t  endDate: string;\n\t  card_id: string;\n\t  title: string;\n\t  color: string;\n\t  column_id: number;\n\t  owner_user_id: number;\n\t  co_owner_ids: number[];\n\t  deadline: string;\n\t  transitions: CardTransition[];\n", "}\n\tinterface User {\n\t  name: string;\n\t  avatar: string;\n\t}\n\tinterface KanbanUser {\n\t  user_id: number;\n\t  username: string;\n\t  avatar: string;\n\t  realname: string;\n", "  is_confirmed: number;\n\t  is_enabled: number;\n\t}\n\tconst handler: NextApiHandler = async (req, res) => {\n\t  const startDate = req.query.start_date as string;\n\t  const endDate = req.query.end_date as string;\n\t  getProjectTimeline(startDate, endDate)\n\t    .then((response) => res.status(200).json(response))\n\t    .catch((err) => {\n\t      console.error(err);\n", "      res.status(500).send(err.message);\n\t    });\n\t};\n\tconst kanbanConfig = projectTimelineConfig.datasource.kanbanize;\n\tconst getProjectTimeline = async (startDate: string, endDate: string) => {\n\t  if (kanbanConfig.enabled) {\n\t    return await fetchCards(startDate, endDate);\n\t  }\n\t  return delay1s(getProjectTimelineFakeData);\n\t};\n", "const fetchCards = async (startDate: string, endDate: string) => {\n\t  const columnIds = kanbanConfig.monitorColumns.map((item) => item.id).join(',');\n\t  const typeIds = kanbanConfig.monitorCardTypes.map((item) => item.id).join(',');\n\t  const fields = searchParams.fields.join(',');\n\t  const expand = searchParams.expand.join(',');\n\t  const cardsAPI = `${kanbanConfig.baseUrl}/api/v2/cards?board_ids=${kanbanConfig.boardId}&column_ids=${columnIds}&type_ids=${typeIds}&fields=${fields}&expand=${expand}&in_current_position_since_from_date=${startDate}`;\n\t  const response = await fetch(cardsAPI, {\n\t    headers: {\n\t      apikey: kanbanConfig.apikey || '',\n\t    },\n", "  });\n\t  if (!response.ok) {\n\t    throw new Error(await response.text());\n\t  }\n\t  const json = await response.json();\n\t  const userIds: number[] = json.data.data.flatMap(\n\t    ({ owner_user_id, co_owner_ids }: { owner_user_id: number; co_owner_ids: number[] }) => [\n\t      owner_user_id,\n\t      ...co_owner_ids,\n\t    ]\n", "  );\n\t  const buildUserInfo = await fetchUserInfo(userIds);\n\t  let cards = json.data.data.map((card: TimelineCard) => buildCardInfo(card, buildUserInfo));\n\t  return cards.filter(\n\t    (card: TimelineCard) => card.startDate >= startDate && card.endDate < endDate\n\t  );\n\t};\n\tconst buildCardInfo = (card: TimelineCard, buildUserInfo: (userId: number) => User | null) => {\n\t  const [startDate, endDate] = calculateStartEndDate(card);\n\t  const getColumnName = (columnId: number) => {\n", "    return kanbanConfig.monitorColumns.find((c) => c.id === columnId)?.name;\n\t  };\n\t  return {\n\t    cardNo: card.card_id,\n\t    cardName: card.title,\n\t    startDate: startDate,\n\t    endDate: endDate,\n\t    color: card.color,\n\t    status: getColumnName(card.column_id),\n\t    owner: buildUserInfo(card.owner_user_id),\n", "    coOwners: card.co_owner_ids?.map((id: number) => buildUserInfo(id)),\n\t  };\n\t};\n\tconst fetchUserInfo = async (userIds: number[]) => {\n\t  const uniqueUserIds = [...new Set(userIds)].filter((id) => id).join(',');\n\t  const userAPI = `${kanbanConfig.baseUrl}/api/v2/users?user_ids=${uniqueUserIds}&fields=user_id,username,realname,avatar`;\n\t  const response = await fetch(userAPI, {\n\t    headers: {\n\t      apikey: kanbanConfig.apikey || '',\n\t    },\n", "  });\n\t  const json = await response.json();\n\t  return (userId: number) => {\n\t    const user = json.data.find((user: KanbanUser) => user.user_id === userId);\n\t    return user\n\t      ? {\n\t          name: user.realname,\n\t          avatar: user.avatar,\n\t        }\n\t      : null;\n", "  };\n\t};\n\tconst calculateStartEndDate = (card: TimelineCard): [startDate: string, endDate: string] => {\n\t  // Find the first time a card was moved to configured columns\n\t  const startTime = card.transitions?.find((transition: CardTransition) =>\n\t    kanbanConfig.startColumns.map(({ id }) => id).includes(transition.column_id)\n\t  )?.start;\n\t  let endTime = card.transitions?.find((transition: CardTransition) =>\n\t    kanbanConfig.endColumns.map(({ id }) => id).includes(transition.column_id)\n\t  )?.start;\n", "  endTime =\n\t    endTime || card.deadline || moment(startTime).add(kanbanConfig.defaultIterationWeeks, 'weeks');\n\t  return [moment(startTime).format('YYYY-MM-DD'), moment(endTime).format('YYYY-MM-DD')];\n\t};\n\tconst searchParams = {\n\t  fields: [\n\t    'card_id',\n\t    'title',\n\t    'owner_user_id',\n\t    'type_id',\n", "    'size',\n\t    'priority',\n\t    'color',\n\t    'deadline',\n\t    'is_blocked',\n\t  ],\n\t  expand: ['co_owner_ids', 'transitions'],\n\t};\n\texport default handler;\n"]}
{"filename": "src/pages/api/build_status.ts", "chunked_list": ["import { NextApiHandler } from 'next';\n\timport { delay1s } from '@/lib/delay';\n\timport { getBuildStatusFakeData } from '../../../fake/build_status.fake';\n\timport { buildStatusConfig } from '../../../config/build_status.config';\n\timport { getAllCircleBuildStatus } from '@/pages/api/circle_build_status';\n\timport { getAllGitHubStatus } from '@/pages/api/github_build_status';\n\tconst handler: NextApiHandler = async (req, res) => {\n\t  getCIStatus()\n\t    .then((response) => res.status(200).json(response))\n\t    .catch((err) => res.status(500).send(err.message));\n", "};\n\tconst getCIStatus = async () => {\n\t  if (\n\t    !buildStatusConfig.datasource.github.enabled &&\n\t    !buildStatusConfig.datasource.circleCI.enabled\n\t  ) {\n\t    return delay1s(getBuildStatusFakeData);\n\t  }\n\t  const responses = await Promise.all([getAllCircleBuildStatus(), getAllGitHubStatus()]);\n\t  return responses.flat();\n", "};\n\texport default handler;\n"]}
{"filename": "src/pages/api/owner_rotation.ts", "chunked_list": ["import { NextApiHandler } from 'next';\n\timport { ownerRotationConfig } from '../../../config/owner_rotation.config';\n\timport { Member, Rotation } from '@/components/OwnerRotationOverview';\n\timport { delay1s } from '@/lib/delay';\n\timport { fetchFieldsFromApiTable } from '@/lib/apiTableFetcher';\n\timport { fetchFieldsFromGoogleSheet } from '@/lib/googleSheetFetcher';\n\timport { getOwnerRotationFakeData } from '../../../fake/owner_rotation.fake';\n\timport moment from 'moment';\n\tconst handler: NextApiHandler = async (req, res) => {\n\t  getAllOwners()\n", "    .then((response) => res.status(200).json(response))\n\t    .catch((err) => res.status(500).send(err.message));\n\t};\n\tconst getAllOwners = async () => {\n\t  if (ownerRotationConfig.datasource.localData.enabled) {\n\t    return ownerRotationConfig.datasource.localData.rotations;\n\t  }\n\t  if (ownerRotationConfig.datasource.apiTable.enabled) {\n\t    return await loadDataFromApiTable();\n\t  }\n", "  if (ownerRotationConfig.datasource.googleSheet.enabled) {\n\t    return await loadDataFromGoogleSheet();\n\t  }\n\t  return delay1s(getOwnerRotationFakeData);\n\t};\n\tconst loadDataFromApiTable = async () => {\n\t  const apiTableConfig = ownerRotationConfig.datasource.apiTable;\n\t  return await Promise.all(\n\t    apiTableConfig.rotations.map(async (rotation) => {\n\t      const tableViewUrl = `${apiTableConfig.baseUrl}${rotation.datasheetId}/records`;\n", "      let members = await fetchFieldsFromApiTable(tableViewUrl, apiTableConfig.apiKey as string);\n\t      return {\n\t        subject: rotation.subject,\n\t        color: rotation.color,\n\t        icon: rotation.icon,\n\t        members: sortMembers(members),\n\t      };\n\t    })\n\t  );\n\t};\n", "const loadDataFromGoogleSheet = async () => {\n\t  const googleSheetConfig = ownerRotationConfig.datasource.googleSheet;\n\t  return await Promise.all(\n\t    googleSheetConfig.rotations.map(async (rotation) => {\n\t      const docUrl = `${googleSheetConfig.baseUrl}${googleSheetConfig.docId}/gviz/tq?`;\n\t      let members = await fetchFieldsFromGoogleSheet(docUrl, rotation.sheetName);\n\t      return {\n\t        subject: rotation.subject,\n\t        color: rotation.color,\n\t        icon: rotation.icon,\n", "        members: sortMembers(members),\n\t      };\n\t    })\n\t  );\n\t};\n\tconst datePattern = /^\\d{4}-\\d{2}-\\d{2}$/;\n\tconst dateFormat = 'YYYY-MM-DD';\n\tconst isAfter = (date1: string, date2: string) =>\n\t  moment(date1, dateFormat).isAfter(moment(date2, dateFormat));\n\tconst sortMembers = (rows: { [key: string]: any }[]) => {\n", "  let members: Member[] = [];\n\t  if (rows?.every((it) => datePattern.test(it.startDate))) {\n\t    rows.sort((a, b) => (isAfter(a.startDate, b.startDate) ? 1 : -1));\n\t    members = rows.map((row) => ({\n\t      name: row.name,\n\t      startDate: row.startDate,\n\t      endDate: row.endDate,\n\t    }));\n\t  }\n\t  return members;\n", "};\n\texport default handler;\n"]}
{"filename": "src/pages/api/ticket_status.ts", "chunked_list": ["import { NextApiHandler } from 'next';\n\timport { ticketStatusConfig } from '../../../config/ticket_status.config';\n\timport { getTicketStatusFakeData } from '../../../fake/ticket_status.fake';\n\timport { delay1s } from '@/lib/delay';\n\timport { btoa } from 'buffer';\n\tinterface Ticket {\n\t  subject: string;\n\t  status: string;\n\t  url: string;\n\t  created_at: string;\n", "  updated_at: string;\n\t}\n\tconst zendeskConfig = ticketStatusConfig.datasource.zendesk;\n\tconst handler: NextApiHandler = async (req, res) => {\n\t  getAllBuildStatus()\n\t    .then((response) => res.status(200).json(response))\n\t    .catch((err) => res.status(500).send(err.message));\n\t};\n\tconst getAllBuildStatus = async () => {\n\t  if (zendeskConfig.enabled) {\n", "    return await fetchTickets();\n\t  }\n\t  return delay1s(getTicketStatusFakeData);\n\t};\n\tconst fetchTickets = async () => {\n\t  const emailAddress = zendeskConfig.userEmail;\n\t  const apiToken = zendeskConfig.apiToken;\n\t  const basicToken = btoa(`${emailAddress}/token:${apiToken}`);\n\t  let nextPageUrl = `${zendeskConfig.baseUrl}/api/v2/views/${zendeskConfig.viewId}/tickets?sort_by=updated_at&sort_order=desc`;\n\t  let allTickets: Ticket[] = [];\n", "  while (nextPageUrl) {\n\t    const response = await fetch(nextPageUrl, {\n\t      headers: {\n\t        Authorization: `Basic ${basicToken}`,\n\t      },\n\t    });\n\t    if (!response.ok) {\n\t      throw new Error('failed to fetch zendesk tickets');\n\t    }\n\t    const json = await response.json();\n", "    nextPageUrl = json.next_page;\n\t    allTickets = allTickets.concat(json.tickets);\n\t  }\n\t  return allTickets;\n\t};\n\texport default handler;\n"]}
{"filename": "src/pages/api/hello.ts", "chunked_list": ["// Next.js API route support: https://nextjs.org/docs/api-routes/introduction\n\timport type { NextApiRequest, NextApiResponse } from 'next';\n\ttype Data = {\n\t  name: string;\n\t};\n\texport default function handler(\n\t  req: NextApiRequest,\n\t  res: NextApiResponse<Data>\n\t) {\n\t  res.status(200).json({ name: 'John Doe' });\n", "}\n"]}
{"filename": "src/pages/api/circle_build_status.ts", "chunked_list": ["import { NextApiHandler } from 'next';\n\timport _ from 'lodash';\n\timport { buildStatusConfig } from '../../../config/build_status.config';\n\tinterface PipelineTriggerActor {\n\t  login: string;\n\t  avatar_url: string;\n\t}\n\tinterface PipelineTrigger {\n\t  actor: PipelineTriggerActor;\n\t}\n", "interface PipelineVcsCommit {\n\t  body: string;\n\t  subject: string;\n\t}\n\tinterface PipelineVcs {\n\t  commit: PipelineVcsCommit;\n\t}\n\tinterface Workflow {\n\t  id: string;\n\t  created_at: string;\n", "  status: string;\n\t}\n\tinterface Workflows {\n\t  items: Workflow[];\n\t}\n\tinterface Pipeline {\n\t  id: string;\n\t  updated_at: string;\n\t  trigger: PipelineTrigger;\n\t  vcs: PipelineVcs;\n", "}\n\tinterface Pipelines {\n\t  items: Pipeline[];\n\t}\n\tconst circleCIConfig = buildStatusConfig.datasource.circleCI;\n\tconst handler: NextApiHandler = async (req, res) => {\n\t  getAllCircleBuildStatus()\n\t    .then((response) => res.status(200).json(response))\n\t    .catch((err) => res.status(500).send(err.message));\n\t};\n", "export const getAllCircleBuildStatus = async () => {\n\t  if (circleCIConfig.enabled) {\n\t    return await Promise.all(\n\t      circleCIConfig.projects.map((project) => {\n\t        return getBuildStatus(project);\n\t      })\n\t    );\n\t  }\n\t  return [];\n\t};\n", "const getBuildStatus = async ({\n\t  projectName,\n\t  projectSlug,\n\t  branch,\n\t}: {\n\t  projectName: string;\n\t  projectSlug: string;\n\t  branch: string;\n\t}) => {\n\t  const latestPipeline: Pipeline = await getLatestPipeline(projectSlug, branch);\n", "  const { login, avatar_url } = latestPipeline.trigger.actor;\n\t  const latestWorkflow: Workflow = await getLatestWorkflow(latestPipeline.id);\n\t  return {\n\t    platform: 'CircleCI',\n\t    projectName: projectName,\n\t    branch,\n\t    username: login,\n\t    avatarUrl: avatar_url,\n\t    commitSubject: latestPipeline.vcs.commit?.subject || 'automatically triggered',\n\t    status: latestWorkflow.status,\n", "    stopTime: latestWorkflow.created_at,\n\t  };\n\t};\n\tconst getLatestPipeline = async (projectSlug: string, branch: string): Promise<Pipeline> => {\n\t  let pipelines: Pipelines = await fetchPipelines(projectSlug, branch);\n\t  return _.orderBy(pipelines.items, 'updated_at', 'desc')[0];\n\t};\n\tconst getLatestWorkflow = async (pipelineId: string): Promise<Workflow> => {\n\t  const workflows = await fetchWorkflows(pipelineId);\n\t  return _.orderBy(workflows.items, 'created_at', 'desc')[0];\n", "};\n\tconst fetchPipelines = async (projectSlug: string, branch: string): Promise<Pipelines> => {\n\t  const url = `https://circleci.com/api/v2/project/${projectSlug}/pipeline?branch=${branch}&circle-token=${circleCIConfig.apiToken}`;\n\t  const response = await fetch(url);\n\t  let json: Pipelines = await response.json();\n\t  if (!response.ok) {\n\t    throw new Error(JSON.stringify(json));\n\t  }\n\t  return json;\n\t};\n", "const fetchWorkflows = async (pipelineId: string): Promise<Workflows> => {\n\t  const url = `https://circleci.com/api/v2/pipeline/${pipelineId}/workflow?circle-token=${circleCIConfig.apiToken}`;\n\t  const response = await fetch(url);\n\t  let json: Workflows = await response.json();\n\t  if (!response.ok) {\n\t    throw new Error(JSON.stringify(json));\n\t  }\n\t  return json;\n\t};\n\texport default handler;\n"]}
{"filename": "src/lib/apiTableFetcher.ts", "chunked_list": ["interface RecordItem {\n\t  fields: Object;\n\t}\n\texport const fetchFieldsFromApiTable = async (url: string, token: string) => {\n\t  const response = await fetch(url, {\n\t    headers: {\n\t      Authorization: `Bearer ${token}`,\n\t    },\n\t  });\n\t  if (!response.ok) {\n", "    throw new Error(await response.text());\n\t  }\n\t  const json = await response.json();\n\t  return json.data?.records?.flatMap((item: RecordItem) => item.fields);\n\t};\n"]}
{"filename": "src/lib/delay.ts", "chunked_list": ["export const delay1s = <T>(func: () => T) =>\n\t  new Promise<T>((resolve) => setTimeout(() => resolve(func()), 1000));\n"]}
{"filename": "src/lib/customToast.ts", "chunked_list": ["import { useToast as useChakraToast } from '@chakra-ui/toast';\n\texport const useErrorToast = () => {\n\t  const toast = useChakraToast();\n\t  return (message: string) => {\n\t    toast({\n\t      title: 'Error occurred',\n\t      duration: 6000,\n\t      description: message,\n\t      status: 'error',\n\t      isClosable: true,\n", "      position: 'bottom-right',\n\t    });\n\t  };\n\t};\n\texport const useInfoToast = () => {\n\t  const toast = useChakraToast();\n\t  return (title: string, message: string) => {\n\t    toast({\n\t      title: title,\n\t      description: message,\n", "      status: 'info',\n\t      isClosable: true,\n\t      position: 'top-right',\n\t    });\n\t  };\n\t};\n"]}
{"filename": "src/lib/googleSheetFetcher.ts", "chunked_list": ["interface SheetCol {\n\t  id: string;\n\t  label: string;\n\t  type: string;\n\t}\n\tinterface SheetRowItem {\n\t  v: string | number;\n\t  f?: string;\n\t}\n\tinterface SheetRow {\n", "  c: SheetRowItem[];\n\t}\n\tinterface RowObject {\n\t  [key: string]: any;\n\t}\n\tconst formatSheetRow = (list: SheetRowItem[]) => {\n\t  for (let i = list.length - 1; i >= 0; i--) {\n\t    if (list[i] === null || list[i].v === null) {\n\t      list.splice(i, 1);\n\t    }\n", "  }\n\t};\n\texport const fetchFieldsFromGoogleSheet = async (docUrl: string, sheetName: string) => {\n\t  const query = encodeURIComponent('Select *');\n\t  const sheetUrl = `${docUrl}&sheet=${sheetName}&tq=${query}`;\n\t  const response = await fetch(sheetUrl);\n\t  if (!response.ok) {\n\t    throw new Error(await response.text());\n\t  }\n\t  const json = await response.text();\n", "  const res = JSON.parse(json.substring(47).slice(0, -2));\n\t  let fields = res.table.cols.flatMap((it: SheetCol) => it.label);\n\t  fields = fields.filter((it: string) => it !== '');\n\t  let values = res.table.rows.map((it: SheetRow) => it.c);\n\t  values.forEach((it: SheetRowItem[]) => formatSheetRow(it));\n\t  let rows: RowObject[] = [];\n\t  values.forEach((row: SheetRowItem[]) => {\n\t    let dataRow: RowObject = {};\n\t    fields.forEach((col: string, index: number) => {\n\t      dataRow[col] = row[index]?.f ?? row[index]?.v ?? '';\n", "    });\n\t    rows.push(dataRow);\n\t  });\n\t  return rows;\n\t};\n"]}
{"filename": "src/theme/theme.ts", "chunked_list": ["import { extendTheme } from '@chakra-ui/react';\n\tconst config = {\n\t  initialColorMode: 'light',\n\t  useSystemColorMode: false,\n\t};\n\tconst theme = extendTheme({\n\t  config,\n\t  styles: {\n\t    global: {\n\t      body: {\n", "        transition: 'background-color 200ms linear !important',\n\t      },\n\t    },\n\t  },\n\t});\n\texport default theme;\n"]}
