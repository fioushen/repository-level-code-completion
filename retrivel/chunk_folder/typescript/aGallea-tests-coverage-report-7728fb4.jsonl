{"filename": "jest.config.ts", "chunked_list": ["/*\n\t * For a detailed explanation regarding each configuration property and type check, visit:\n\t * https://jestjs.io/docs/configuration\n\t */\n\texport default {\n\t  // All imported modules in your tests should be mocked automatically\n\t  // automock: false,\n\t  // Stop running tests after `n` failures\n\t  // bail: 0,\n\t  // The directory where Jest should store its cached dependency information\n", "  // cacheDirectory: \"/private/var/folders/x0/z8cnrq89243fv317kptvwygh0000gp/T/jest_dy\",\n\t  // Automatically clear mock calls, instances, contexts and results before every test\n\t  clearMocks: true,\n\t  // Indicates whether the coverage information should be collected while executing the test\n\t  collectCoverage: true,\n\t  // An array of glob patterns indicating a set of files for which coverage information should be collected\n\t  // collectCoverageFrom: undefined,\n\t  // The directory where Jest should output its coverage files\n\t  coverageDirectory: 'coverage',\n\t  // An array of regexp pattern strings used to skip coverage collection\n", "  // coveragePathIgnorePatterns: [\n\t  //   \"/node_modules/\"\n\t  // ],\n\t  // Indicates which provider should be used to instrument code for coverage\n\t  coverageProvider: 'v8',\n\t  // A list of reporter names that Jest uses when writing coverage reports\n\t  coverageReporters: [\n\t    'json',\n\t    'json-summary',\n\t    'text',\n", "    'text-summary',\n\t    \"lcov\",\n\t    'clover',\n\t    'cobertura',\n\t  ],\n\t  reporters: ['default', ['jest-junit', { outputDirectory: 'coverage' }]],\n\t  preset: 'ts-jest',\n\t  testEnvironment: 'node',\n\t  // testMatch: [\n\t  //   '**/*.test.ts',\n", "  // ],\n\t  testPathIgnorePatterns: [\n\t      '/node_modules/',\n\t      '/dist/',\n\t  ],\n\t  // An object that configures minimum threshold enforcement for coverage results\n\t  // coverageThreshold: undefined,\n\t  // A path to a custom dependency extractor\n\t  // dependencyExtractor: undefined,\n\t  // Make calling deprecated APIs throw helpful error messages\n", "  // errorOnDeprecated: false,\n\t  // The default configuration for fake timers\n\t  // fakeTimers: {\n\t  //   \"enableGlobally\": false\n\t  // },\n\t  // Force coverage collection from ignored files using an array of glob patterns\n\t  // forceCoverageMatch: [],\n\t  // A path to a module which exports an async function that is triggered once before all test suites\n\t  // globalSetup: undefined,\n\t  // A path to a module which exports an async function that is triggered once after all test suites\n", "  // globalTeardown: undefined,\n\t  // A set of global variables that need to be available in all test environments\n\t  // globals: {},\n\t  // The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.\n\t  // maxWorkers: \"50%\",\n\t  // An array of directory names to be searched recursively up from the requiring module's location\n\t  // moduleDirectories: [\n\t  //   \"node_modules\"\n\t  // ],\n\t  // An array of file extensions your modules use\n", "  // moduleFileExtensions: [\n\t  //   \"js\",\n\t  //   \"mjs\",\n\t  //   \"cjs\",\n\t  //   \"jsx\",\n\t  //   \"ts\",\n\t  //   \"tsx\",\n\t  //   \"json\",\n\t  //   \"node\"\n\t  // ],\n", "  // A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module\n\t  // moduleNameMapper: {},\n\t  // An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader\n\t  // modulePathIgnorePatterns: [],\n\t  // Activates notifications for test results\n\t  // notify: false,\n\t  // An enum that specifies notification mode. Requires { notify: true }\n\t  // notifyMode: \"failure-change\",\n\t  // A preset that is used as a base for Jest's configuration\n\t  // preset: undefined,\n", "  // Run tests from one or more projects\n\t  // projects: undefined,\n\t  // Use this configuration option to add custom reporters to Jest\n\t  // reporters: undefined,\n\t  // Automatically reset mock state before every test\n\t  // resetMocks: false,\n\t  // Reset the module registry before running each individual test\n\t  // resetModules: false,\n\t  // A path to a custom resolver\n\t  // resolver: undefined,\n", "  // Automatically restore mock state and implementation before every test\n\t  // restoreMocks: false,\n\t  // The root directory that Jest should scan for tests and modules within\n\t  // rootDir: undefined,\n\t  // A list of paths to directories that Jest should use to search for files in\n\t  // roots: [\n\t  //   \"<rootDir>\"\n\t  // ],\n\t  // Allows you to use a custom runner instead of Jest's default test runner\n\t  // runner: \"jest-runner\",\n", "  // The paths to modules that run some code to configure or set up the testing environment before each test\n\t  // setupFiles: [],\n\t  // A list of paths to modules that run some code to configure or set up the testing framework before each test\n\t  // setupFilesAfterEnv: [],\n\t  // The number of seconds after which a test is considered as slow and reported as such in the results.\n\t  // slowTestThreshold: 5,\n\t  // A list of paths to snapshot serializer modules Jest should use for snapshot testing\n\t  // snapshotSerializers: [],\n\t  // The test environment that will be used for testing\n\t  // testEnvironment: \"jest-environment-node\",\n", "  // Options that will be passed to the testEnvironment\n\t  // testEnvironmentOptions: {},\n\t  // Adds a location field to test results\n\t  // testLocationInResults: false,\n\t  // The glob patterns Jest uses to detect test files\n\t  testMatch: [\n\t    \"**/__tests__/**/*.[jt]s?(x)\",\n\t    \"**/?(*.)+(spec|test).[tj]s?(x)\"\n\t  ],\n\t  // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped\n", "  // testPathIgnorePatterns: [\n\t  //   \"/node_modules/\"\n\t  // ],\n\t  // The regexp pattern or array of patterns that Jest uses to detect test files\n\t  // testRegex: [],\n\t  // This option allows the use of a custom results processor\n\t  // testResultsProcessor: undefined,\n\t  // This option allows use of a custom test runner\n\t  // testRunner: \"jest-circus/runner\",\n\t  // A map from regular expressions to paths to transformers\n", "  // transform: undefined,\n\t  // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation\n\t  // transformIgnorePatterns: [\n\t  //   \"/node_modules/\",\n\t  //   \"\\\\.pnp\\\\.[^\\\\/]+$\"\n\t  // ],\n\t  // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them\n\t  // unmockedModulePathPatterns: undefined,\n\t  // Indicates whether each individual test should be reported during the run\n\t  // verbose: undefined,\n", "  // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode\n\t  // watchPathIgnorePatterns: [],\n\t  // Whether to use watchman for file crawling\n\t  // watchman: true,\n\t};\n"]}
{"filename": "test/commentCoverage.test.ts", "chunked_list": ["import { spyActions } from './actions.spy';\n\timport * as github from '@actions/github';\n\timport { DiffInfo, EventInfo, Junit } from '../src/types';\n\timport { getEventInfo } from '../src/eventInfo';\n\timport { buildBody, commentCoverage } from '../src/commentCoverage';\n\timport * as core from '@actions/core';\n\tconst originalContext = { ...github.context };\n\tdescribe('commentCoverage tests', () => {\n\t  afterAll(() => {\n\t    github.context.ref = originalContext.ref;\n", "    github.context.sha = originalContext.sha;\n\t    jest.restoreAllMocks();\n\t    jest.resetAllMocks();\n\t  });\n\t  describe('commentCoverage tests', () => {\n\t    let eventInfo: EventInfo;\n\t    const spyCreateCommitComment = jest.fn();\n\t    const spyListComments = jest.fn().mockImplementation(() => ({\n\t      data: [],\n\t    }));\n", "    const spyUpdateComment = jest.fn();\n\t    const spyCreateComment = jest.fn();\n\t    beforeAll(() => {\n\t      spyActions();\n\t      jest.spyOn(github, 'getOctokit').mockImplementation(\n\t        () =>\n\t          ({\n\t            rest: {\n\t              repos: {\n\t                createCommitComment: spyCreateCommitComment,\n", "              },\n\t              issues: {\n\t                listComments: spyListComments,\n\t                updateComment: spyUpdateComment,\n\t                createComment: spyCreateComment,\n\t              },\n\t            },\n\t          } as any),\n\t      );\n\t    });\n", "    beforeEach(() => {\n\t      eventInfo = getEventInfo();\n\t    });\n\t    test('createCommitComment with push event', async () => {\n\t      github.context.eventName = 'push';\n\t      await commentCoverage(eventInfo, 'some-body-content-1');\n\t      expect(spyCreateCommitComment).toBeCalledWith({\n\t        body: 'some-body-content-1',\n\t        commit_sha: 'abcdefghijklmnopqrstuvwxyz',\n\t        owner: 'some-owner',\n", "        repo: 'some-repo',\n\t      });\n\t    });\n\t    test('createComment with pull_request event', async () => {\n\t      github.context.eventName = 'pull_request';\n\t      await commentCoverage(eventInfo, 'some-body-content-2');\n\t      expect(spyCreateComment).toBeCalledWith({\n\t        body: 'some-body-content-2',\n\t        issue_number: 1,\n\t        owner: 'some-owner',\n", "        repo: 'some-repo',\n\t      });\n\t    });\n\t    test('createComment with pull_request event and overrideComment', async () => {\n\t      github.context.eventName = 'pull_request';\n\t      eventInfo.overrideComment = true;\n\t      await commentCoverage(eventInfo, 'some-body-content-3');\n\t      expect(spyListComments).toBeCalledWith({\n\t        repo: 'some-repo',\n\t        owner: 'some-owner',\n", "        issue_number: 1,\n\t      });\n\t      expect(spyCreateComment).toBeCalledWith({\n\t        body: 'some-body-content-3',\n\t        issue_number: 1,\n\t        owner: 'some-owner',\n\t        repo: 'some-repo',\n\t      });\n\t    });\n\t    test('updateComment with pull_request event and overrideComment', async () => {\n", "      github.context.eventName = 'pull_request';\n\t      eventInfo.overrideComment = true;\n\t      const spyListCommentsWithContent = jest.fn().mockImplementation(() => ({\n\t        data: [\n\t          {\n\t            user: {\n\t              login: 'github-actions[bot]',\n\t            },\n\t            body: '',\n\t            id: 50,\n", "          },\n\t          {\n\t            user: {\n\t              login: 'github-actions[bot]',\n\t            },\n\t            body: '<!-- tests-coverage-report -->foobar',\n\t            id: 51,\n\t          },\n\t        ],\n\t      }));\n", "      jest.spyOn(github, 'getOctokit').mockImplementation(\n\t        () =>\n\t          ({\n\t            rest: {\n\t              issues: {\n\t                listComments: spyListCommentsWithContent,\n\t                updateComment: spyUpdateComment,\n\t                createComment: spyCreateComment,\n\t              },\n\t            },\n", "          } as any),\n\t      );\n\t      await commentCoverage(eventInfo, 'some-body-content-4');\n\t      expect(spyListCommentsWithContent).toBeCalledWith({\n\t        repo: 'some-repo',\n\t        owner: 'some-owner',\n\t        issue_number: 1,\n\t      });\n\t      expect(spyUpdateComment).toBeCalledWith({\n\t        body: 'some-body-content-4',\n", "        comment_id: 51,\n\t        owner: 'some-owner',\n\t        repo: 'some-repo',\n\t      });\n\t    });\n\t  });\n\t  describe('buildBody tests', () => {\n\t    let eventInfo: EventInfo;\n\t    let junitInfo: Junit;\n\t    let diffsInfo: DiffInfo[];\n", "    beforeAll(() => {\n\t      spyActions();\n\t    });\n\t    beforeEach(() => {\n\t      eventInfo = getEventInfo();\n\t      junitInfo = {\n\t        tests: 51,\n\t        failures: {\n\t          count: 0,\n\t          info: undefined,\n", "        },\n\t        errors: 0,\n\t        skipped: 0,\n\t        time: '12s',\n\t      };\n\t      diffsInfo = [\n\t        {\n\t          file: '1.file',\n\t          changedLines: ['1', '2', '3', '4', '5', '6'],\n\t          missedLines: ['2', '5'],\n", "        },\n\t      ];\n\t    });\n\t    test('dont show junit and diffCover content', async () => {\n\t      expect(buildBody(eventInfo, junitInfo, [])).toEqual(\n\t        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n',\n\t      );\n\t    });\n\t    test('show only junit content, without junit info', async () => {\n\t      eventInfo.showJunit = true;\n", "      expect(buildBody(eventInfo, undefined, [])).toEqual(\n\t        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\nNo JUnit details to present\\n',\n\t      );\n\t    });\n\t    test('show only junit content', async () => {\n\t      eventInfo.showJunit = true;\n\t      expect(buildBody(eventInfo, junitInfo, [])).toEqual(\n\t        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### JUnit Details\\n| Total Tests | Failures  | Errors  | Skipped  | Time :hourglass_flowing_sand: |\\n| ------------------ | --------------------- | ------------------- | -------------------- | ----------------- |\\n| 51 | 0 | 0 | 0 | 12s |\\n\\n',\n\t      );\n\t    });\n", "    test('show junit content, with failures info', async () => {\n\t      eventInfo.showJunit = true;\n\t      eventInfo.showFailuresInfo = true;\n\t      junitInfo.failures = {\n\t        count: 1,\n\t        info: [\n\t          {\n\t            classname: 'my-class-name',\n\t            name: 'test name',\n\t            time: '-1',\n", "            error: 'error message',\n\t          },\n\t        ],\n\t      };\n\t      expect(buildBody(eventInfo, junitInfo, [])).toEqual(\n\t        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Failure :x:\\n### JUnit Details\\n| Total Tests | Failures :x: | Errors  | Skipped  | Time :hourglass_flowing_sand: |\\n| ------------------ | --------------------- | ------------------- | -------------------- | ----------------- |\\n| 51 | 1 | 0 | 0 | 12s |\\n<details><table><summary><b>Failures Details</b>\\n\\n</summary><tr><th>File</th><th>Test Name</th><th>Error Message</th></tr><tr><td>TODO</td><td>test name</td><td>error message</td></tr></table></details>\\n\\n',\n\t      );\n\t    });\n\t    test('show only diffCover content, without diff info', async () => {\n\t      eventInfo.showDiffcover = true;\n", "      expect(buildBody(eventInfo, junitInfo, [])).toEqual(\n\t        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### Coverage Details :ballot_box_with_check:\\nNo coverage details to present',\n\t      );\n\t    });\n\t    test('show only diffCover content', async () => {\n\t      eventInfo.showDiffcover = true;\n\t      expect(buildBody(eventInfo, junitInfo, diffsInfo)).toEqual(\n\t        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### Coverage Details (67% < 80%) :x:\\n\\n<details><table><summary><b>Diff Cover Details</b>\\n\\n</summary><tr><th>File</th><th colspan=\"2\">Covered Lines</th><th>Missing Lines</th></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file\">1.file</a></td><td>4/6</td><td>67%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L2\">2</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L5\">5</a></td></tr><tr><td>Total</td><td>4/6</td><td>67%</td><td></td></tr></table></details>',\n\t      );\n\t    });\n", "    test('diffCover content with full coverage', async () => {\n\t      eventInfo.showDiffcover = true;\n\t      diffsInfo.pop();\n\t      diffsInfo.push({\n\t        file: '1.file',\n\t        changedLines: ['1', '2', '3', '4', '5', '6'],\n\t        missedLines: [],\n\t      });\n\t      expect(buildBody(eventInfo, junitInfo, diffsInfo)).toEqual(\n\t        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### Coverage Details (100% >= 80%) :white_check_mark:\\n\\n<details><table><summary><b>Diff Cover Details</b>\\n\\n</summary><tr><th>File</th><th colspan=\"2\">Covered Lines</th><th>Missing Lines</th></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file\">1.file</a></td><td>6/6</td><td>100%</td><td></td></tr><tr><td>Total</td><td>6/6</td><td>100%</td><td></td></tr></table></details>',\n", "      );\n\t    });\n\t    test('diffCover content with no changes', async () => {\n\t      eventInfo.showDiffcover = true;\n\t      diffsInfo.pop();\n\t      diffsInfo.push({\n\t        file: '1.file',\n\t        changedLines: [],\n\t        missedLines: [],\n\t      });\n", "      expect(buildBody(eventInfo, junitInfo, diffsInfo)).toEqual(\n\t        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n',\n\t      );\n\t    });\n\t    test('diffCover content with missed range', async () => {\n\t      eventInfo.showDiffcover = true;\n\t      diffsInfo.push({\n\t        file: '2.file',\n\t        changedLines: ['1', '2', '3', '4', '5', '6'],\n\t        missedLines: ['1', '2', '3', '5'],\n", "      });\n\t      expect(buildBody(eventInfo, junitInfo, diffsInfo)).toEqual(\n\t        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### Coverage Details (50% < 80%) :x:\\n\\n<details><table><summary><b>Diff Cover Details</b>\\n\\n</summary><tr><th>File</th><th colspan=\"2\">Covered Lines</th><th>Missing Lines</th></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file\">1.file</a></td><td>4/6</td><td>67%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L2\">2</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L5\">5</a></td></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file\">2.file</a></td><td>2/6</td><td>33%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file#L1-L3\">1-3</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file#L5\">5</a></td></tr><tr><td>Total</td><td>6/12</td><td>50%</td><td></td></tr></table></details>',\n\t      );\n\t    });\n\t    test('diffCover content with full coverage', async () => {\n\t      eventInfo.showDiffcover = true;\n\t      eventInfo.minCoveragePercentage = '100';\n\t      diffsInfo.pop();\n\t      diffsInfo.push({\n", "        file: '1.file',\n\t        changedLines: ['1', '2', '3', '4', '5', '6'],\n\t        missedLines: [],\n\t      });\n\t      expect(buildBody(eventInfo, junitInfo, diffsInfo)).toEqual(\n\t        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### Coverage Details (100% >= 100%) :white_check_mark:\\n\\n<details><table><summary><b>Diff Cover Details</b>\\n\\n</summary><tr><th>File</th><th colspan=\"2\">Covered Lines</th><th>Missing Lines</th></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file\">1.file</a></td><td>6/6</td><td>100%</td><td></td></tr><tr><td>Total</td><td>6/6</td><td>100%</td><td></td></tr></table></details>',\n\t      );\n\t    });\n\t    test('diffCover content with missed range and failUnder', async () => {\n\t      eventInfo.showDiffcover = true;\n", "      eventInfo.failUnderCoveragePercentage = false;\n\t      diffsInfo.push({\n\t        file: '2.file',\n\t        changedLines: ['1', '2', '3', '4', '5', '6'],\n\t        missedLines: ['1', '2', '3', '5'],\n\t      });\n\t      const coreSetFailedSpy = jest.spyOn(core, 'setFailed');\n\t      expect(buildBody(eventInfo, junitInfo, diffsInfo)).toEqual(\n\t        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### Coverage Details (50% < 80%) :x:\\n\\n<details><table><summary><b>Diff Cover Details</b>\\n\\n</summary><tr><th>File</th><th colspan=\"2\">Covered Lines</th><th>Missing Lines</th></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file\">1.file</a></td><td>4/6</td><td>67%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L2\">2</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L5\">5</a></td></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file\">2.file</a></td><td>2/6</td><td>33%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file#L1-L3\">1-3</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file#L5\">5</a></td></tr><tr><td>Total</td><td>6/12</td><td>50%</td><td></td></tr></table></details>',\n\t      );\n", "      expect(coreSetFailedSpy).not.toHaveBeenCalled();\n\t      eventInfo.failUnderCoveragePercentage = true;\n\t      expect(buildBody(eventInfo, junitInfo, diffsInfo)).toEqual(\n\t        '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n### Tests Succees :white_check_mark:\\n### Coverage Details (50% < 80%) :x:\\n\\n<details><table><summary><b>Diff Cover Details</b>\\n\\n</summary><tr><th>File</th><th colspan=\"2\">Covered Lines</th><th>Missing Lines</th></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file\">1.file</a></td><td>4/6</td><td>67%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L2\">2</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/1.file#L5\">5</a></td></tr><tr><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file\">2.file</a></td><td>2/6</td><td>33%</td><td><a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file#L1-L3\">1-3</a>,<a href=\"https://github.com/some-owner/some-repo/blob/abcdefghijklmnopqrstuvwxyz/2.file#L5\">5</a></td></tr><tr><td>Total</td><td>6/12</td><td>50%</td><td></td></tr></table></details>',\n\t      );\n\t      expect(coreSetFailedSpy).toHaveBeenCalledWith('low coverage');\n\t    });\n\t  });\n\t});\n"]}
{"filename": "test/changedFiles.test.ts", "chunked_list": ["import { defaultInputs, spyActions } from './actions.spy';\n\timport * as github from '@actions/github';\n\timport { getChangedFiles } from '../src/changedFiles';\n\timport { getEventInfo } from '../src/eventInfo';\n\timport { EventInfo, FilesStatus } from '../src/types';\n\timport * as core from '@actions/core';\n\tconst originalContext = { ...github.context };\n\tdescribe('eventInput tests', () => {\n\t  beforeAll(() => {\n\t    const data = {\n", "      inputs: defaultInputs,\n\t      compareCommitsWithBasehead: {\n\t        total_commits: 3,\n\t        files: [\n\t          {\n\t            status: 'added',\n\t            filename: '1.file',\n\t          },\n\t          {\n\t            status: 'modified',\n", "            filename: '2.file',\n\t          },\n\t          {\n\t            status: 'renamed',\n\t            filename: '3.file',\n\t          },\n\t          {\n\t            status: 'copied',\n\t            filename: '4.file',\n\t          },\n", "          {\n\t            status: 'changed',\n\t            filename: '5.file',\n\t          },\n\t          {\n\t            status: 'unchanged',\n\t            filename: '6.file',\n\t          },\n\t          {\n\t            status: 'removed',\n", "            filename: '7.file',\n\t          },\n\t        ],\n\t      },\n\t    };\n\t    spyActions(data);\n\t  });\n\t  afterAll(() => {\n\t    github.context.ref = originalContext.ref;\n\t    github.context.sha = originalContext.sha;\n", "    jest.restoreAllMocks();\n\t    jest.resetAllMocks();\n\t  });\n\t  test('getChangedFiles', async () => {\n\t    const eventInfo: EventInfo = getEventInfo();\n\t    const filesStatus: FilesStatus = await getChangedFiles(eventInfo);\n\t    expect(filesStatus.all).toHaveLength(7);\n\t    expect(filesStatus.added).toHaveLength(1);\n\t    expect(filesStatus.added[0]).toEqual('1.file');\n\t    expect(filesStatus.modified).toHaveLength(1);\n", "    expect(filesStatus.modified[0]).toEqual('2.file');\n\t    expect(filesStatus.renamed).toHaveLength(1);\n\t    expect(filesStatus.renamed[0]).toEqual('3.file');\n\t    expect(filesStatus.copied).toHaveLength(1);\n\t    expect(filesStatus.copied[0]).toEqual('4.file');\n\t    expect(filesStatus.changed).toHaveLength(1);\n\t    expect(filesStatus.changed[0]).toEqual('5.file');\n\t    expect(filesStatus.unchanged).toHaveLength(1);\n\t    expect(filesStatus.unchanged[0]).toEqual('6.file');\n\t    expect(filesStatus.removed).toHaveLength(1);\n", "    expect(filesStatus.removed[0]).toEqual('7.file');\n\t  });\n\t});\n"]}
{"filename": "test/diffCover.test.ts", "chunked_list": ["import { spyActions } from './actions.spy';\n\timport * as github from '@actions/github';\n\timport { CoverageTypeInfo, EventInfo, FilesStatus, DiffInfo } from '../src/types';\n\timport { getEventInfo } from '../src/eventInfo';\n\timport { diffCover } from '../src/diffCover';\n\timport { parseFile } from '../src/parsers/cobertura';\n\timport * as Utils from '../src/utils';\n\tconst originalContext = { ...github.context };\n\tdescribe('diffCover tests', () => {\n\t  beforeAll(() => {\n", "    spyActions();\n\t  });\n\t  afterAll(() => {\n\t    github.context.ref = originalContext.ref;\n\t    github.context.sha = originalContext.sha;\n\t    jest.restoreAllMocks();\n\t    jest.resetAllMocks();\n\t  });\n\t  const getFilesStatus = (): FilesStatus => {\n\t    return {\n", "      all: [],\n\t      added: [],\n\t      removed: [],\n\t      modified: [],\n\t      renamed: [],\n\t      copied: [],\n\t      changed: [],\n\t      unchanged: [],\n\t    };\n\t  };\n", "  describe('Empty responses', () => {\n\t    test('showDiffcover false', async () => {\n\t      const eventInfo: EventInfo = getEventInfo();\n\t      const cobertura = await parseFile(\n\t        './test/assets/cobertura-coverage.xml',\n\t        '/Users/user/workspace/private/tests-coverage-report/',\n\t      );\n\t      const coverageInfo: CoverageTypeInfo = {\n\t        cobertura,\n\t        clover: [],\n", "        lcov: [],\n\t        jacoco: [],\n\t        junit: undefined,\n\t      };\n\t      const DiffInfo: DiffInfo[] = await diffCover(\n\t        eventInfo,\n\t        getFilesStatus(),\n\t        coverageInfo,\n\t      );\n\t      expect(DiffInfo).toHaveLength(0);\n", "    });\n\t    test('empty added/modified/changed', async () => {\n\t      const eventInfo: EventInfo = getEventInfo();\n\t      eventInfo.showDiffcover = true;\n\t      eventInfo.diffcoverRef = 'cobertura';\n\t      const cobertura = await parseFile(\n\t        './test/assets/cobertura-coverage.xml',\n\t        '/Users/user/workspace/private/tests-coverage-report/',\n\t      );\n\t      const coverageInfo: CoverageTypeInfo = {\n", "        cobertura,\n\t        clover: [],\n\t        lcov: [],\n\t        jacoco: [],\n\t        junit: undefined,\n\t      };\n\t      const DiffInfo: DiffInfo[] = await diffCover(\n\t        eventInfo,\n\t        getFilesStatus(),\n\t        coverageInfo,\n", "      );\n\t      expect(DiffInfo).toHaveLength(0);\n\t    });\n\t  });\n\t  describe('Responses with content', () => {\n\t    test('diff info', async () => {\n\t      const eventInfo: EventInfo = getEventInfo();\n\t      eventInfo.showDiffcover = true;\n\t      eventInfo.diffcoverRef = 'cobertura';\n\t      const cobertura = await parseFile(\n", "        './test/assets/cobertura-coverage.xml',\n\t        '/Users/user/workspace/private/tests-coverage-report/',\n\t      );\n\t      const coverageInfo: CoverageTypeInfo = {\n\t        cobertura,\n\t        clover: [],\n\t        lcov: [],\n\t        jacoco: [],\n\t        junit: undefined,\n\t      };\n", "      const filesStatus = getFilesStatus();\n\t      filesStatus.all = ['1.file', '2.file', '3.file'];\n\t      filesStatus.changed = ['1.file'];\n\t      filesStatus.added = ['2.file'];\n\t      filesStatus.modified = ['3.file'];\n\t      const DiffInfo: DiffInfo[] = await diffCover(eventInfo, filesStatus, coverageInfo);\n\t      expect(DiffInfo).toHaveLength(0);\n\t    });\n\t    test('with changed lines', async () => {\n\t      jest\n", "        .spyOn(Utils, 'execCommand')\n\t        .mockImplementation(async (command: string): Promise<Utils.ExecInfo> => {\n\t          if (command.includes('src/main.ts')) {\n\t            return {\n\t              status: 'success',\n\t              stdout: '1\\n2\\n3\\n4\\n10\\n11\\n12\\n13\\n17\\n18\\n19\\n20\\n21\\n22\\n29\\n30\\n',\n\t            };\n\t          } else if (command.includes('src/diffCover.ts')) {\n\t            return {\n\t              status: 'success',\n", "              stdout:\n\t                '1\\n2\\n3\\n4\\n5\\n51\\n52\\n53\\n54\\n72\\n73\\n74\\n78\\n79\\n80\\n81\\n82\\n83\\n',\n\t            };\n\t          }\n\t          return {\n\t            status: 'success',\n\t            stdout: '',\n\t          };\n\t        });\n\t      const eventInfo: EventInfo = getEventInfo();\n", "      eventInfo.showDiffcover = true;\n\t      eventInfo.diffcoverRef = 'cobertura';\n\t      const cobertura = await parseFile(\n\t        './test/assets/cobertura-coverage.xml',\n\t        '/Users/user/workspace/private/tests-coverage-report/',\n\t      );\n\t      const coverageInfo: CoverageTypeInfo = {\n\t        cobertura,\n\t        clover: [],\n\t        lcov: [],\n", "        jacoco: [],\n\t        junit: undefined,\n\t      };\n\t      const filesStatus = getFilesStatus();\n\t      filesStatus.all = ['src/diffCover.ts', 'src/main.ts', 'src/utils.ts'];\n\t      filesStatus.changed = ['src/diffCover.ts'];\n\t      filesStatus.added = ['src/main.ts'];\n\t      filesStatus.modified = ['src/utils.ts'];\n\t      const DiffInfo: DiffInfo[] = await diffCover(eventInfo, filesStatus, coverageInfo);\n\t      expect(DiffInfo).toHaveLength(2);\n", "      expect(DiffInfo[0]).toEqual({\n\t        changedLines: [\n\t          '1',\n\t          '2',\n\t          '3',\n\t          '4',\n\t          '5',\n\t          '51',\n\t          '52',\n\t          '53',\n", "          '54',\n\t          '72',\n\t          '73',\n\t          '74',\n\t          '78',\n\t          '79',\n\t          '80',\n\t          '81',\n\t          '82',\n\t          '83',\n", "        ],\n\t        file: 'src/diffCover.ts',\n\t        missedLines: [\n\t          '51',\n\t          '52',\n\t          '53',\n\t          '54',\n\t          '72',\n\t          '73',\n\t          '74',\n", "          '78',\n\t          '79',\n\t          '80',\n\t          '81',\n\t          '82',\n\t          '83',\n\t        ],\n\t      });\n\t      expect(DiffInfo[1]).toEqual({\n\t        changedLines: [\n", "          '1',\n\t          '2',\n\t          '3',\n\t          '4',\n\t          '10',\n\t          '11',\n\t          '12',\n\t          '13',\n\t          '17',\n\t          '18',\n", "          '19',\n\t          '20',\n\t          '21',\n\t          '22',\n\t          '29',\n\t          '30',\n\t        ],\n\t        file: 'src/main.ts',\n\t        missedLines: ['18', '19', '20', '21', '22', '29', '30'],\n\t      });\n", "    });\n\t  });\n\t  describe('Exceptions', () => {\n\t    test('invalid git log', async () => {\n\t      const eventInfo: EventInfo = getEventInfo();\n\t      jest.spyOn(Utils, 'execCommand').mockImplementation(\n\t        async (): Promise<Utils.ExecInfo> => ({\n\t          status: 'error',\n\t          message: 'some error message',\n\t          errorCode: 1,\n", "        }),\n\t      );\n\t      eventInfo.showDiffcover = true;\n\t      eventInfo.diffcoverRef = 'cobertura';\n\t      const coverageInfo: CoverageTypeInfo = {\n\t        cobertura: [],\n\t        clover: [],\n\t        lcov: [],\n\t        jacoco: [],\n\t        junit: undefined,\n", "      };\n\t      const filesStatus = getFilesStatus();\n\t      await expect(diffCover(eventInfo, filesStatus, coverageInfo)).rejects.toThrow(\n\t        'failed to retrieve git log: master..some-head. error: some error message',\n\t      );\n\t    });\n\t    test('invalid git blame', async () => {\n\t      const eventInfo: EventInfo = getEventInfo();\n\t      jest\n\t        .spyOn(Utils, 'execCommand')\n", "        .mockImplementation(async (command: string): Promise<Utils.ExecInfo> => {\n\t          if (command.includes('blame')) {\n\t            return {\n\t              status: 'error',\n\t              message: 'git blame error message',\n\t              errorCode: 1,\n\t            };\n\t          }\n\t          return {\n\t            status: 'success',\n", "            stdout: '',\n\t          };\n\t        });\n\t      eventInfo.showDiffcover = true;\n\t      eventInfo.diffcoverRef = 'cobertura';\n\t      const cobertura = await parseFile(\n\t        './test/assets/cobertura-coverage.xml',\n\t        '/Users/user/workspace/private/tests-coverage-report/',\n\t      );\n\t      const coverageInfo: CoverageTypeInfo = {\n", "        cobertura,\n\t        clover: [],\n\t        lcov: [],\n\t        jacoco: [],\n\t        junit: undefined,\n\t      };\n\t      const filesStatus = getFilesStatus();\n\t      filesStatus.all = ['src/diffCover.ts'];\n\t      filesStatus.changed = ['src/diffCover.ts'];\n\t      await expect(diffCover(eventInfo, filesStatus, coverageInfo)).rejects.toThrow(\n", "        'failed to execute \"git blame\" on file: src/diffCover.ts. error: git blame error message',\n\t      );\n\t    });\n\t  });\n\t});\n"]}
{"filename": "test/eventInfo.test.ts", "chunked_list": ["import * as github from '@actions/github';\n\timport { getEventInfo } from '../src/eventInfo';\n\timport { EventInfo } from '../src/types';\n\timport { defaultCompareCommitsWithBasehead, spyActions } from './actions.spy';\n\tconst originalContext = { ...github.context };\n\tdescribe('eventInput tests', () => {\n\t  beforeAll(() => {\n\t    spyActions();\n\t  });\n\t  afterAll(() => {\n", "    github.context.ref = originalContext.ref;\n\t    github.context.sha = originalContext.sha;\n\t    jest.restoreAllMocks();\n\t    jest.resetAllMocks();\n\t  });\n\t  test('getEventInfo - pull_request', () => {\n\t    const data = {\n\t      inputs: {\n\t        'github-token': 'abcdefgh',\n\t        'cobertura-path': 'cobertura.xml',\n", "        'show-junit': 'true',\n\t      },\n\t      compareCommitsWithBasehead: defaultCompareCommitsWithBasehead,\n\t    };\n\t    spyActions(data);\n\t    const eventInfo: EventInfo = getEventInfo();\n\t    expect(eventInfo.token).toBe('abcdefgh');\n\t    expect(eventInfo.commitSha).toBe('abcdefghijklmnopqrstuvwxyz');\n\t    expect(eventInfo.jacocoPath).toBeUndefined();\n\t    expect(eventInfo.showJunit).toBeTruthy();\n", "  });\n\t  test('getEventInfo - push', () => {\n\t    const data = {\n\t      inputs: {\n\t        'github-token': 'abcdefgh',\n\t        'jacoco-path': 'jacoco.xml',\n\t        'show-junit': 'false',\n\t      },\n\t      compareCommitsWithBasehead: defaultCompareCommitsWithBasehead,\n\t    };\n", "    spyActions(data, 'push');\n\t    const eventInfo: EventInfo = getEventInfo();\n\t    expect(eventInfo.token).toBe('abcdefgh');\n\t    expect(eventInfo.commitSha).toBe('zyxwvutsrqponmlkjihgfedcba');\n\t    expect(eventInfo.jacocoPath).toBe('jacoco.xml');\n\t    expect(eventInfo.coberturaPath).toBeUndefined();\n\t    expect(eventInfo.showJunit).toBeTruthy();\n\t  });\n\t});\n"]}
{"filename": "test/main.test.ts", "chunked_list": ["import { spyActions } from './actions.spy';\n\timport * as github from '@actions/github';\n\timport { main } from '../src/main';\n\timport * as Comment from '../src/commentCoverage';\n\timport { EventInfo } from '../src/types';\n\timport { getEventInfo } from '../src/eventInfo';\n\timport * as core from '@actions/core';\n\tconst originalContext = { ...github.context };\n\tdescribe('main tests', () => {\n\t  beforeAll(() => {\n", "    spyActions();\n\t  });\n\t  afterAll(() => {\n\t    github.context.ref = originalContext.ref;\n\t    github.context.sha = originalContext.sha;\n\t    jest.restoreAllMocks();\n\t    jest.resetAllMocks();\n\t  });\n\t  test('empty content', async () => {\n\t    const commentCoverageSpy = jest\n", "      .spyOn(Comment, 'commentCoverage')\n\t      .mockImplementation(async (eventInfo: EventInfo, body: string): Promise<void> => {\n\t        return;\n\t      });\n\t    await main();\n\t    const eventInfo: EventInfo = getEventInfo();\n\t    expect(commentCoverageSpy).toHaveBeenCalledWith(\n\t      eventInfo,\n\t      '<!-- tests-coverage-report -->\\n## Tests Report Mock :page_facing_up:\\n',\n\t    );\n", "  });\n\t  test('exception', async () => {\n\t    jest\n\t      .spyOn(Comment, 'commentCoverage')\n\t      .mockImplementation(async (eventInfo: EventInfo, body: string): Promise<void> => {\n\t        throw new Error('some error');\n\t      });\n\t    const coreErrorSpy = jest.spyOn(core, 'setFailed');\n\t    await main();\n\t    expect(coreErrorSpy).toHaveBeenCalledWith('some error');\n", "  });\n\t});\n"]}
{"filename": "test/actions.spy.ts", "chunked_list": ["import * as core from '@actions/core';\n\timport * as github from '@actions/github';\n\texport const defaultInputs: { [key: string]: any } = {\n\t  title: 'Tests Report Mock',\n\t  'github-token': 'abcdefgh',\n\t  'cobertura-path': 'cobertura.xml',\n\t  'show-junit': false,\n\t  'min-coverage-percentage': '80',\n\t};\n\texport const defaultCompareCommitsWithBasehead: { [key: string]: any } = {\n", "  total_commits: 0,\n\t  files: [],\n\t};\n\texport const defaultData = {\n\t  inputs: defaultInputs,\n\t  compareCommitsWithBasehead: defaultCompareCommitsWithBasehead,\n\t};\n\texport function spyActions(data = defaultData, eventName = 'pull_request') {\n\t  github.context.eventName = eventName;\n\t  jest.spyOn(core, 'getInput').mockImplementation((name: string) => {\n", "    return data.inputs[name];\n\t  });\n\t  jest\n\t    .spyOn(core, 'getBooleanInput')\n\t    .mockImplementation((name: string) => data.inputs[name]);\n\t  jest.spyOn(core, 'error').mockImplementation(jest.fn());\n\t  jest.spyOn(core, 'warning').mockImplementation(jest.fn());\n\t  jest.spyOn(core, 'info').mockImplementation(jest.fn());\n\t  jest.spyOn(core, 'debug').mockImplementation(jest.fn());\n\t  // jest.spyOn(core, 'setFailed').mockImplementation(jest.fn());\n", "  jest.spyOn(github.context, 'repo', 'get').mockImplementation(() => {\n\t    return {\n\t      owner: 'some-owner',\n\t      repo: 'some-repo',\n\t    };\n\t  });\n\t  github.context.ref = 'refs/heads/some-ref';\n\t  github.context.sha = '1234567890123456789012345678901234567890';\n\t  github.context.payload = {\n\t    pull_request: {\n", "      head: {\n\t        sha: 'abcdefghijklmnopqrstuvwxyz',\n\t        ref: 'some-head',\n\t      },\n\t      base: {\n\t        ref: 'master',\n\t      },\n\t      number: 1,\n\t    },\n\t    after: 'zyxwvutsrqponmlkjihgfedcba',\n", "  };\n\t  jest.spyOn(github, 'getOctokit').mockImplementation(\n\t    () =>\n\t      ({\n\t        rest: {\n\t          repos: {\n\t            compareCommitsWithBasehead: jest.fn(async () => ({\n\t              data: data.compareCommitsWithBasehead,\n\t            })),\n\t          },\n", "        },\n\t      } as any),\n\t  );\n\t}\n"]}
{"filename": "test/utils.test.ts", "chunked_list": ["import { execCommand } from '../src/utils';\n\tdescribe('Utils tests', () => {\n\t  test('exec command success', async () => {\n\t    const commitsShaExec = await execCommand(`git log --oneline | cut -f1 -d' '`);\n\t    expect(commitsShaExec.status).toEqual('success');\n\t  });\n\t  test('exec command error', async () => {\n\t    const commitsShaExec = await execCommand('some bad command');\n\t    expect(commitsShaExec.status).toEqual('error');\n\t  });\n", "});\n"]}
{"filename": "test/parsers/lcov.test.ts", "chunked_list": ["import { parseFile } from '../../src/parsers/lcov';\n\tdescribe('lcov parser tests', () => {\n\t  test('No such file', async () => {\n\t    await expect(parseFile('invalid.file')).rejects.toThrow(\n\t      `ENOENT: no such file or directory, open 'invalid.file'`,\n\t    );\n\t  });\n\t  test('Filename empty string', async () => {\n\t    await expect(parseFile('')).resolves.toEqual([]);\n\t  });\n", "  test('Invalid content', async () => {\n\t    await expect(parseFile('./test/assets/invalid.xml')).resolves.toEqual([]);\n\t  });\n\t  test('Parse', async () => {\n\t    const parsed = await parseFile('./test/assets/lcov.info');\n\t    expect(parsed).toHaveLength(5);\n\t    expect(parsed[0].file).toEqual('src/changedFiles.ts');\n\t    expect(parsed[0].functions.found).toEqual(1);\n\t    expect(parsed[0].functions.hit).toEqual(0);\n\t    expect(parsed[0].functions.details).toHaveLength(1);\n", "    expect(parsed[0].functions.details[0].name).toEqual('getChangedFiles');\n\t    expect(parsed[0].functions.details[0].line).toEqual(5);\n\t    expect(parsed[0].functions.details[0].hit).toEqual(0);\n\t    expect(parsed[0].lines.found).toEqual(46);\n\t    expect(parsed[0].lines.hit).toEqual(5);\n\t    expect(parsed[0].lines.details).toHaveLength(10);\n\t    expect(parsed[0].lines.details[0].line).toEqual(1);\n\t    expect(parsed[0].lines.details[0].hit).toEqual(1);\n\t    expect(parsed[0].lines.details[5].line).toEqual(6);\n\t    expect(parsed[0].lines.details[5].hit).toEqual(0);\n", "    expect(parsed[2].file).toEqual('src/diffCover.ts');\n\t    expect(parsed[2].functions.found).toEqual(2);\n\t    expect(parsed[2].functions.hit).toEqual(1);\n\t    expect(parsed[2].branches.found).toEqual(1);\n\t    expect(parsed[2].branches.hit).toEqual(1);\n\t    expect(parsed[2].branches.details).toHaveLength(1);\n\t    expect(parsed[2].branches.details[0].block).toEqual(0);\n\t    expect(parsed[2].branches.details[0].line).toEqual(4);\n\t    expect(parsed[2].branches.details[0].branch).toEqual(0);\n\t    expect(parsed[2].branches.details[0].taken).toEqual(1);\n", "  });\n\t});\n"]}
{"filename": "test/parsers/cobertura.test.ts", "chunked_list": ["import { parseFile } from '../../src/parsers/cobertura';\n\tdescribe('cobertura parser tests', () => {\n\t  test('No such file', async () => {\n\t    await expect(parseFile('invalid.file', '')).rejects.toThrow(\n\t      `ENOENT: no such file or directory, open 'invalid.file'`,\n\t    );\n\t  });\n\t  test('Filename empty string', async () => {\n\t    await expect(parseFile('', '')).resolves.toEqual([]);\n\t  });\n", "  test('Invalid xml content', async () => {\n\t    await expect(parseFile('./test/assets/invalid.xml', '')).rejects.toThrow(\n\t      'invalid or missing xml content',\n\t    );\n\t  });\n\t  test('error xml content', async () => {\n\t    await expect(parseFile('./test/assets/invalidXmlContent.xml', '')).rejects.toThrow(\n\t      'Non-whitespace before first tag.\\nLine: 0\\nColumn: 1\\nChar: s',\n\t    );\n\t  });\n", "  test('Parse', async () => {\n\t    const parsed = await parseFile(\n\t      './test/assets/cobertura-coverage.xml',\n\t      '/Users/user/workspace/private/tests-coverage-report/',\n\t    );\n\t    expect(parsed).toHaveLength(12);\n\t    expect(parsed[0].file).toEqual('src/changedFiles.ts');\n\t    expect(parsed[0].functions.found).toEqual(1);\n\t    expect(parsed[0].functions.hit).toEqual(0);\n\t    expect(parsed[0].functions.details).toHaveLength(1);\n", "    expect(parsed[0].functions.details[0].name).toEqual('getChangedFiles');\n\t    expect(parsed[0].functions.details[0].line).toEqual(5);\n\t    expect(parsed[0].functions.details[0].hit).toEqual(0);\n\t    expect(parsed[0].lines.found).toEqual(46);\n\t    expect(parsed[0].lines.hit).toEqual(5);\n\t    expect(parsed[0].lines.details).toHaveLength(46);\n\t    expect(parsed[0].lines.details[0].line).toEqual(1);\n\t    expect(parsed[0].lines.details[0].hit).toEqual(1);\n\t    expect(parsed[0].lines.details[5].line).toEqual(6);\n\t    expect(parsed[0].lines.details[5].hit).toEqual(0);\n", "    expect(parsed[2].file).toEqual('src/diffCover.ts');\n\t    expect(parsed[2].functions.found).toEqual(3);\n\t    expect(parsed[2].functions.hit).toEqual(1);\n\t    expect(parsed[2].branches.found).toEqual(1);\n\t    expect(parsed[2].branches.hit).toEqual(1);\n\t    expect(parsed[2].branches.details).toHaveLength(1);\n\t    expect(parsed[2].branches.details[0].line).toEqual(11);\n\t    expect(parsed[2].branches.details[0].branch).toEqual(0);\n\t    expect(parsed[2].branches.details[0].taken).toEqual(1);\n\t  });\n", "});\n"]}
{"filename": "test/parsers/clover.test.ts", "chunked_list": ["import { parseFile } from '../../src/parsers/clover';\n\tdescribe('clover parser tests', () => {\n\t  test('No such file', async () => {\n\t    await expect(parseFile('invalid.file')).rejects.toThrow(\n\t      `ENOENT: no such file or directory, open 'invalid.file'`,\n\t    );\n\t  });\n\t  test('Filename empty string', async () => {\n\t    await expect(parseFile('')).resolves.toEqual([]);\n\t  });\n", "  test('Invalid xml content', async () => {\n\t    await expect(parseFile('./test/assets/invalid.xml')).rejects.toThrow(\n\t      'invalid or missing xml content',\n\t    );\n\t  });\n\t  test('error xml content', async () => {\n\t    await expect(parseFile('./test/assets/invalidXmlContent.xml')).rejects.toThrow(\n\t      'Non-whitespace before first tag.\\nLine: 0\\nColumn: 1\\nChar: s',\n\t    );\n\t  });\n", "  test('Parse', async () => {\n\t    const parsed = await parseFile('./test/assets/clover.xml');\n\t    expect(parsed).toHaveLength(12);\n\t    expect(parsed[0].file).toEqual('changedFiles.ts');\n\t    // expect(parsed[0].functions.found).toEqual(1);\n\t    // expect(parsed[0].functions.hit).toEqual(0);\n\t    // expect(parsed[0].functions.details).toHaveLength(1);\n\t    // expect(parsed[0].functions.details[0].name).toEqual('getChangedFiles');\n\t    // expect(parsed[0].functions.details[0].line).toEqual(5);\n\t    // expect(parsed[0].functions.details[0].hit).toEqual(0);\n", "    expect(parsed[0].lines.found).toEqual(46);\n\t    expect(parsed[0].lines.hit).toEqual(5);\n\t    expect(parsed[0].lines.details).toHaveLength(46);\n\t    expect(parsed[0].lines.details[0].line).toEqual(1);\n\t    expect(parsed[0].lines.details[0].hit).toEqual(1);\n\t    expect(parsed[0].lines.details[5].line).toEqual(6);\n\t    expect(parsed[0].lines.details[5].hit).toEqual(0);\n\t    expect(parsed[2].file).toEqual('diffCover.ts');\n\t    expect(parsed[2].lines.found).toEqual(92);\n\t    expect(parsed[2].lines.hit).toEqual(17);\n", "    expect(parsed[2].lines.details).toHaveLength(92);\n\t    // expect(parsed[2].functions.found).toEqual(3);\n\t    // expect(parsed[2].functions.hit).toEqual(1);\n\t    // expect(parsed[2].branches.found).toEqual(1);\n\t    // expect(parsed[2].branches.hit).toEqual(1);\n\t    // expect(parsed[2].branches.details).toHaveLength(1);\n\t    // expect(parsed[2].branches.details[0].line).toEqual(11);\n\t    // expect(parsed[2].branches.details[0].branch).toEqual(0);\n\t    // expect(parsed[2].branches.details[0].taken).toEqual(1);\n\t  });\n", "});\n"]}
{"filename": "test/parsers/junit.test.ts", "chunked_list": ["import { parse } from '../../src/parsers/junit';\n\tdescribe('junit parser tests', () => {\n\t  test('No such file', async () => {\n\t    await expect(parse('invalid.file')).rejects.toThrow(\n\t      `ENOENT: no such file or directory, lstat 'invalid.file'`,\n\t    );\n\t  });\n\t  test('Filename empty string', async () => {\n\t    await expect(parse('')).resolves.toBeUndefined();\n\t  });\n", "  test('Invalid xml content', async () => {\n\t    await expect(parse('./test/assets/invalid.xml')).rejects.toThrow(\n\t      'invalid or missing xml content',\n\t    );\n\t  });\n\t  test('error xml content', async () => {\n\t    await expect(parse('./test/assets/invalidXmlContent.xml')).rejects.toThrow(\n\t      'Non-whitespace before first tag.\\nLine: 0\\nColumn: 1\\nChar: s',\n\t    );\n\t  });\n", "  test('Parse', async () => {\n\t    const parsed = await parse('./test/assets/junit.xml');\n\t    expect(parsed).toBeDefined();\n\t    expect(parsed?.tests).toEqual(3);\n\t    expect(parsed?.time).toEqual('1.57s');\n\t    expect(parsed?.skipped).toEqual(0);\n\t    expect(parsed?.errors).toEqual(0);\n\t    expect(parsed?.failures).toBeDefined();\n\t    expect(parsed?.failures.count).toEqual(0);\n\t    expect(parsed?.failures.info).toHaveLength(0);\n", "  });\n\t  test('Parse V2', async () => {\n\t    const parsed = await parse('./test/assets/junitV2.xml');\n\t    expect(parsed).toBeDefined();\n\t    expect(parsed?.tests).toEqual(1);\n\t    expect(parsed?.time).toEqual('3.46s');\n\t    expect(parsed?.skipped).toEqual(0);\n\t    expect(parsed?.errors).toEqual(0);\n\t    expect(parsed?.failures).toBeDefined();\n\t    expect(parsed?.failures.count).toEqual(1);\n", "    expect(parsed?.failures.info).toHaveLength(3);\n\t    expect(parsed?.failures.info?.[0]?.classname).toEqual('tests.test_connector');\n\t    expect(parsed?.failures.info?.[0]?.error).toEqual(\n\t      `BadRequestError: BadRequestError(400, 'illegal_argument_exception', 'Wildcard expressions or all indices are not allowed')`,\n\t    );\n\t    expect(parsed?.failures.info?.[0]?.name).toEqual('test_deletion');\n\t    expect(parsed?.failures.info?.[0]?.time).toEqual('0.06s');\n\t    expect(parsed?.failures.info?.[1]?.error).toEqual(\n\t      `BadRequestError(400, 'illegal_argument_exception')`,\n\t    );\n", "    expect(parsed?.failures.info?.[1]?.time).toEqual('0.05s');\n\t    expect(parsed?.failures.info?.[2]?.error).toEqual('unknown failure');\n\t  });\n\t  test('Parse with failures', async () => {\n\t    const parsed = await parse('./test/assets/junitWithFailures.xml');\n\t    expect(parsed).toBeDefined();\n\t    expect(parsed?.tests).toEqual(50);\n\t    expect(parsed?.time).toEqual('6.18s');\n\t    expect(parsed?.skipped).toEqual(0);\n\t    expect(parsed?.errors).toEqual(0);\n", "    expect(parsed?.failures).toBeDefined();\n\t    expect(parsed?.failures.count).toEqual(2);\n\t    expect(parsed?.failures.info).toBeDefined();\n\t    expect(parsed?.failures.info).toHaveLength(2);\n\t    expect(parsed?.failures.info?.[0]?.classname).toEqual(\n\t      'junit parser tests error xml content',\n\t    );\n\t    expect(parsed?.failures.info?.[0]?.error).toEqual(\n\t      'Error: expect(received).rejects.toThrow(expected)',\n\t    );\n", "    expect(parsed?.failures.info?.[0]?.name).toEqual(\n\t      'junit parser tests error xml content',\n\t    );\n\t    expect(parsed?.failures.info?.[0]?.time).toEqual('0.04s');\n\t    expect(parsed?.failures.info?.[1]?.classname).toEqual('junit parser tests Parse');\n\t    expect(parsed?.failures.info?.[1]?.error).toEqual(\n\t      'Error: expect(received).toEqual(expected) // deep equality',\n\t    );\n\t    expect(parsed?.failures.info?.[1]?.name).toEqual('junit parser tests Parse');\n\t    expect(parsed?.failures.info?.[1]?.time).toEqual('0.01s');\n", "  });\n\t  test('Parse folder with multiple files', async () => {\n\t    const parsed = await parse('./test/assets/junit');\n\t    expect(parsed).toBeDefined();\n\t    expect(parsed?.tests).toEqual(55);\n\t    expect(parsed?.time).toEqual('8.25s');\n\t    expect(parsed?.skipped).toEqual(6);\n\t    expect(parsed?.errors).toEqual(0);\n\t    expect(parsed?.failures).toBeDefined();\n\t    expect(parsed?.failures.count).toEqual(3);\n", "    expect(parsed?.failures.info).toHaveLength(3);\n\t    expect(parsed?.failures.info?.[0]?.classname).toEqual(\n\t      'junit parser tests error xml content',\n\t    );\n\t    expect(parsed?.failures.info?.[0]?.error).toEqual(\n\t      'Error: expect(received).rejects.toThrow(expected)',\n\t    );\n\t    expect(parsed?.failures.info?.[0]?.name).toEqual(\n\t      'junit parser tests error xml content',\n\t    );\n", "    expect(parsed?.failures.info?.[0]?.time).toEqual('0.04s');\n\t    expect(parsed?.failures.info?.[1]?.classname).toEqual('junit parser tests Parse');\n\t    expect(parsed?.failures.info?.[1]?.error).toEqual(\n\t      'Error: expect(received).toEqual(expected) // deep equality',\n\t    );\n\t    expect(parsed?.failures.info?.[1]?.name).toEqual('junit parser tests Parse');\n\t    expect(parsed?.failures.info?.[1]?.time).toEqual('0.01s');\n\t    expect(parsed?.failures.info?.[2]?.classname).toEqual('com.server.ServletTest');\n\t    expect(parsed?.failures.info?.[2]?.error).toEqual(\n\t      'expected:<...2Response(isSuccess=[true]',\n", "    );\n\t    expect(parsed?.failures.info?.[2]?.name).toEqual('testListRequestWithConditions');\n\t    expect(parsed?.failures.info?.[2]?.time).toEqual('4.13s');\n\t  });\n\t});\n"]}
{"filename": "test/parsers/jacoco.test.ts", "chunked_list": ["import { parseFile } from '../../src/parsers/jacoco';\n\tdescribe('jacoco parser tests', () => {\n\t  test('No such file', async () => {\n\t    await expect(parseFile('invalid.file')).rejects.toThrow(\n\t      `ENOENT: no such file or directory, open 'invalid.file'`,\n\t    );\n\t  });\n\t  test('Filename empty string', async () => {\n\t    await expect(parseFile('')).resolves.toEqual([]);\n\t  });\n", "  test('Invalid xml content', async () => {\n\t    await expect(parseFile('./test/assets/invalid.xml')).rejects.toThrow(\n\t      'invalid or missing xml content',\n\t    );\n\t  });\n\t  test('error xml content', async () => {\n\t    await expect(parseFile('./test/assets/invalidXmlContent.xml')).rejects.toThrow(\n\t      'Non-whitespace before first tag.\\nLine: 0\\nColumn: 1\\nChar: s',\n\t    );\n\t  });\n", "  test('Parse', async () => {\n\t    const parsed = await parseFile('./test/assets/jacoco.xml');\n\t    expect(parsed).toHaveLength(4);\n\t    expect(parsed[0].file).toEqual('net/cover/report/a/ClassA1.java');\n\t    expect(parsed[0].functions.found).toEqual(2);\n\t    expect(parsed[0].functions.hit).toEqual(2);\n\t    expect(parsed[0].functions.details).toHaveLength(5);\n\t    expect(parsed[0].functions.details[0].name).toEqual('<init>');\n\t    expect(parsed[0].functions.details[0].line).toEqual(25);\n\t    expect(parsed[0].functions.details[0].hit).toEqual(1);\n", "    expect(parsed[0].lines.found).toEqual(4);\n\t    expect(parsed[0].lines.hit).toEqual(4);\n\t    expect(parsed[0].lines.details).toHaveLength(4);\n\t    expect(parsed[0].lines.details[0].line).toEqual(25);\n\t    expect(parsed[0].lines.details[0].hit).toEqual(3);\n\t    expect(parsed[0].lines.details[3].line).toEqual(32);\n\t    expect(parsed[0].lines.details[3].hit).toEqual(2);\n\t    expect(parsed[2].file).toEqual('net/cover/report/b/ClassB1.java');\n\t    expect(parsed[2].functions.found).toEqual(18);\n\t    expect(parsed[2].functions.hit).toEqual(17);\n", "    expect(parsed[2].branches.found).toEqual(20);\n\t    expect(parsed[2].branches.hit).toEqual(16);\n\t    expect(parsed[2].branches.details).toHaveLength(20);\n\t    expect(parsed[2].branches.details[0].block).toEqual(0);\n\t    expect(parsed[2].branches.details[0].line).toEqual(56);\n\t    expect(parsed[2].branches.details[0].branch).toEqual(0);\n\t    expect(parsed[2].branches.details[0].taken).toEqual(1);\n\t    expect(parsed[2].branches.details[10].block).toEqual(0);\n\t    expect(parsed[2].branches.details[10].line).toEqual(147);\n\t    expect(parsed[2].branches.details[10].branch).toEqual(2);\n", "    expect(parsed[2].branches.details[10].taken).toEqual(1);\n\t  });\n\t});\n"]}
{"filename": "src/types.d.ts", "chunked_list": ["export interface CoverageTypeInfo {\n\t  cobertura: CoverInfo[];\n\t  clover: CoverInfo[];\n\t  lcov: CoverInfo[];\n\t  jacoco: CoverInfo[];\n\t  junit: Junit | undefined;\n\t}\n\texport type DiffCoverRef = 'cobertura' | 'clover' | 'lcov' | 'jacoco';\n\texport interface EventInfo {\n\t  token: string;\n", "  commentTitle: string;\n\t  owner: string;\n\t  repo: string;\n\t  coberturaPath: string;\n\t  cloverPath: string;\n\t  lcovPath: string;\n\t  jacocoPath: string;\n\t  junitPath: string;\n\t  showJunit: boolean;\n\t  showDiffcover: boolean;\n", "  minCoveragePercentage: string;\n\t  failUnderCoveragePercentage: boolean;\n\t  showFailuresInfo: boolean;\n\t  overrideComment: boolean;\n\t  commentId: string;\n\t  diffcoverRef: DiffCoverRef;\n\t  commitSha: string;\n\t  headRef: string;\n\t  baseRef: string;\n\t  pwd: string;\n", "  filesStatus?: FilesStatus;\n\t}\n\texport interface FilesStatus {\n\t  all: string[];\n\t  added: string[];\n\t  removed: string[];\n\t  modified: string[];\n\t  renamed: string[];\n\t  copied: string[];\n\t  changed: string[];\n", "  unchanged: string[];\n\t}\n\texport interface DiffInfo {\n\t  file: string;\n\t  missedLines: string[];\n\t  changedLines: string[];\n\t}\n\texport interface CoverInfo {\n\t  file: string;\n\t  title: string;\n", "  lines: CoverInfoLines;\n\t  functions: CoverInfoFunctions;\n\t  branches: CoverInfoBranches;\n\t}\n\texport interface CoverInfoLines {\n\t  found: number;\n\t  hit: number;\n\t  details: CoverInfoLinesDetails[];\n\t}\n\texport interface CoverInfoLinesDetails {\n", "  line: number;\n\t  hit: number;\n\t}\n\texport interface CoverInfoFunctions {\n\t  found: number;\n\t  hit: number;\n\t  details: CoverInfoFunctionsDetails[];\n\t}\n\texport interface CoverInfoFunctionsDetails {\n\t  line: number;\n", "  hit: number;\n\t  name: string;\n\t}\n\texport interface CoverInfoBranches {\n\t  found: number;\n\t  hit: number;\n\t  details: CoverInfoBranchesDetails[];\n\t}\n\texport interface CoverInfoBranchesDetails {\n\t  line: number;\n", "  branch: number;\n\t  taken: number;\n\t  block?: number;\n\t}\n\texport interface JunitFailureInfo {\n\t  classname: string;\n\t  name: string;\n\t  time: string;\n\t  error: string;\n\t}\n", "export interface Junit {\n\t  tests: number;\n\t  failures: {\n\t    count: number;\n\t    info: JunitFailureInfo[] | undefined;\n\t  };\n\t  errors: number;\n\t  skipped: number;\n\t  time: string;\n\t}\n"]}
{"filename": "src/commentCoverage.ts", "chunked_list": ["import * as core from '@actions/core';\n\timport { context, getOctokit } from '@actions/github';\n\timport { DiffInfo, EventInfo, Junit } from './types';\n\texport const commentCoverage = async (\n\t  eventInfo: EventInfo,\n\t  body: string,\n\t): Promise<void> => {\n\t  const { eventName, payload } = context;\n\t  const octokit = getOctokit(eventInfo.token);\n\t  if (eventName === 'push') {\n", "    await octokit.rest.repos.createCommitComment({\n\t      repo: eventInfo.repo,\n\t      owner: eventInfo.owner,\n\t      commit_sha: eventInfo.commitSha,\n\t      body,\n\t    });\n\t  } else if (eventName === 'pull_request') {\n\t    if (eventInfo.overrideComment) {\n\t      const { data: comments } = await octokit.rest.issues.listComments({\n\t        repo: eventInfo.repo,\n", "        owner: eventInfo.owner,\n\t        issue_number: payload.pull_request ? payload.pull_request.number : 0,\n\t      });\n\t      const comment = comments.find(\n\t        (comment) =>\n\t          comment.user?.login === 'github-actions[bot]' &&\n\t          comment.body?.startsWith(eventInfo.commentId),\n\t      );\n\t      if (comment) {\n\t        await octokit.rest.issues.updateComment({\n", "          repo: eventInfo.repo,\n\t          owner: eventInfo.owner,\n\t          comment_id: comment.id,\n\t          body,\n\t        });\n\t      } else {\n\t        await octokit.rest.issues.createComment({\n\t          repo: eventInfo.repo,\n\t          owner: eventInfo.owner,\n\t          issue_number: payload.pull_request?.number || 0,\n", "          body,\n\t        });\n\t      }\n\t    } else {\n\t      await octokit.rest.issues.createComment({\n\t        repo: eventInfo.repo,\n\t        owner: eventInfo.owner,\n\t        issue_number: payload.pull_request?.number || 0,\n\t        body,\n\t      });\n", "    }\n\t  }\n\t};\n\texport const buildBody = (\n\t  eventInfo: EventInfo,\n\t  junitInfo: Junit | undefined,\n\t  diffsInfo: DiffInfo[],\n\t): string => {\n\t  let body = `${eventInfo.commentId}\\n`;\n\t  body += `## ${eventInfo.commentTitle} :page_facing_up:\\n`;\n", "  body += buildTestsStatusMarkdown(junitInfo);\n\t  body += buildJunitMarkdown(eventInfo, junitInfo);\n\t  body += buildDiffCoverHtml(eventInfo, diffsInfo);\n\t  return body;\n\t};\n\tconst buildTestsStatusMarkdown = (junitInfo: Junit | undefined) => {\n\t  if (junitInfo) {\n\t    const markdown =\n\t      junitInfo.failures?.count || junitInfo.errors\n\t        ? '### Tests Failure :x:'\n", "        : '### Tests Succees :white_check_mark:';\n\t    return `${markdown}\\n`;\n\t  }\n\t  return '';\n\t};\n\tconst buildJunitMarkdown = (eventInfo: EventInfo, junitInfo: Junit | undefined) => {\n\t  if (eventInfo.showJunit && junitInfo) {\n\t    let markdown = `| Total Tests | Failures ${\n\t      junitInfo.failures.count ? ':x:' : ''\n\t    } | Errors ${junitInfo.errors ? ':x:' : ''} | Skipped ${\n", "      junitInfo.skipped ? ':no_entry_sign:' : ''\n\t    } | Time :hourglass_flowing_sand: |\\n`;\n\t    markdown +=\n\t      '| ------------------ | --------------------- | ------------------- | -------------------- | ----------------- |\\n';\n\t    markdown += `| ${junitInfo.tests} | ${junitInfo.failures.count} | ${junitInfo.errors} | ${junitInfo.skipped} | ${junitInfo.time} |\\n`;\n\t    if (\n\t      eventInfo.showFailuresInfo &&\n\t      junitInfo.failures.count > 0 &&\n\t      junitInfo.failures.info\n\t    ) {\n", "      markdown += `<details><table><summary><b>Failures Details</b>\\n\\n</summary><tr><th>File</th><th>Test Name</th><th>Error Message</th></tr>`;\n\t      for (const failure of junitInfo.failures.info) {\n\t        markdown += `<tr><td>TODO</td><td>${failure.name}</td><td>${failure.error}</td></tr>`;\n\t      }\n\t      markdown += '</table></details>\\n';\n\t    }\n\t    // markdown += `\\nThis is a [hover text](## \"your hover text\") example.`;\n\t    return '### JUnit Details\\n' + markdown + '\\n';\n\t  }\n\t  if (eventInfo.showJunit && !junitInfo) {\n", "    return 'No JUnit details to present\\n';\n\t  }\n\t  return '';\n\t};\n\tconst buildDiffCoverHtml = (eventInfo: EventInfo, diffsInfo: DiffInfo[]) => {\n\t  if (!eventInfo.showDiffcover) {\n\t    return '';\n\t  } else {\n\t    if (diffsInfo.length === 0) {\n\t      return `### Coverage Details :ballot_box_with_check:\\nNo coverage details to present`;\n", "    } else {\n\t      let html = `<details><table><summary><b>Diff Cover Details</b>\\n\\n</summary><tr><th>File</th><th colspan=\"2\">Covered Lines</th><th>Missing Lines</th></tr>`;\n\t      let totalLines = 0;\n\t      let totalMissing = 0;\n\t      for (const diffInfo of diffsInfo) {\n\t        if (diffInfo.changedLines.length > 0) {\n\t          const href = `https://github.com/${eventInfo.owner}/${eventInfo.repo}/blob/${eventInfo.commitSha}/${diffInfo.file}`;\n\t          const fileWithHref = `<a href=\"${href}\">${diffInfo.file}</a>`;\n\t          const lines = diffInfo.changedLines.length;\n\t          totalLines += lines;\n", "          const missed = diffInfo.missedLines.length;\n\t          totalMissing += missed;\n\t          const covered = lines - missed;\n\t          const percentage = Math.round((covered / lines) * 100);\n\t          const missedRanges: string[] = getMissedWithRanges(diffInfo);\n\t          const missedRangesWithHref = missedRanges.map((missed) => {\n\t            const range = missed\n\t              .split('-')\n\t              .map((val) => `L${val}`)\n\t              .join('-');\n", "            return `<a href=\"${href}#${range}\">${missed}</a>`;\n\t          });\n\t          html += `<tr><td>${fileWithHref}</td><td>${covered}/${lines}</td><td>${percentage}%</td><td>${missedRangesWithHref}</td></tr>`;\n\t        }\n\t      }\n\t      const totalCovered = totalLines - totalMissing;\n\t      const totalPercentage = Math.round((totalCovered / totalLines) * 100);\n\t      if (isNaN(totalPercentage)) {\n\t        return '';\n\t      }\n", "      html += `<tr><td>Total</td><td>${totalCovered}/${totalLines}</td><td>${totalPercentage}%</td><td></td></tr>`;\n\t      html += '</table></details>';\n\t      if (\n\t        eventInfo.failUnderCoveragePercentage &&\n\t        totalPercentage < +eventInfo.minCoveragePercentage\n\t      ) {\n\t        core.setFailed('low coverage');\n\t      }\n\t      return (\n\t        `### Coverage Details ${\n", "          totalPercentage >= +eventInfo.minCoveragePercentage\n\t            ? `(${totalPercentage}% >= ${eventInfo.minCoveragePercentage}%) :white_check_mark:`\n\t            : `(${totalPercentage}% < ${eventInfo.minCoveragePercentage}%) :x:`\n\t        }\\n\\n` + html\n\t      );\n\t    }\n\t  }\n\t};\n\tconst getMissedWithRanges = (diffInfo: DiffInfo): string[] => {\n\t  const missedRanges: string[] = [];\n", "  let currIndex = 0;\n\t  for (let i = 0; i < diffInfo.missedLines.length; i++) {\n\t    if (+diffInfo.missedLines[i] + 1 === +diffInfo.missedLines[i + 1]) {\n\t      if (missedRanges.length === currIndex) {\n\t        missedRanges.push(`${diffInfo.missedLines[i]}-`);\n\t      }\n\t    } else {\n\t      if (missedRanges.length !== currIndex) {\n\t        missedRanges[currIndex] = missedRanges[currIndex] + diffInfo.missedLines[i];\n\t      } else {\n", "        missedRanges.push(diffInfo.missedLines[i]);\n\t      }\n\t      currIndex++;\n\t    }\n\t  }\n\t  return missedRanges;\n\t};\n"]}
{"filename": "src/main.ts", "chunked_list": ["import { getChangedFiles } from './changedFiles';\n\timport { CoverageTypeInfo, DiffInfo, EventInfo } from './types';\n\timport { getEventInfo } from './eventInfo';\n\timport { diffCover } from './diffCover';\n\timport { parseFile as parseLcovFile } from './parsers/lcov';\n\timport { parseFile as parseCoberturaFile } from './parsers/cobertura';\n\timport { parseFile as parseCloverFile } from './parsers/clover';\n\timport { parseFile as parseJacocoFile } from './parsers/jacoco';\n\timport { parse as parseJunit } from './parsers/junit';\n\timport { buildBody, commentCoverage } from './commentCoverage';\n", "import * as core from '@actions/core';\n\texport const main = async (): Promise<void> => {\n\t  try {\n\t    const eventInfo: EventInfo = getEventInfo();\n\t    const coverageInfo: CoverageTypeInfo = {\n\t      cobertura:\n\t        eventInfo.diffcoverRef === 'cobertura'\n\t          ? await parseCoberturaFile(eventInfo.coberturaPath, `${eventInfo.pwd}/`)\n\t          : [],\n\t      clover:\n", "        eventInfo.diffcoverRef === 'clover'\n\t          ? await parseCloverFile(eventInfo.cloverPath)\n\t          : [],\n\t      lcov:\n\t        eventInfo.diffcoverRef === 'lcov' ? await parseLcovFile(eventInfo.lcovPath) : [],\n\t      jacoco:\n\t        eventInfo.diffcoverRef === 'jacoco'\n\t          ? await parseJacocoFile(eventInfo.jacocoPath)\n\t          : [],\n\t      junit: eventInfo.showJunit ? await parseJunit(eventInfo.junitPath) : undefined,\n", "    };\n\t    const changedFile = await getChangedFiles(eventInfo);\n\t    const diffInfo: DiffInfo[] = await diffCover(eventInfo, changedFile, coverageInfo);\n\t    await commentCoverage(eventInfo, buildBody(eventInfo, coverageInfo.junit, diffInfo));\n\t  } catch (error) {\n\t    core.setFailed(error.message);\n\t  }\n\t};\n"]}
{"filename": "src/diffCover.ts", "chunked_list": ["import {\n\t  FilesStatus,\n\t  EventInfo,\n\t  CoverageTypeInfo,\n\t  DiffInfo,\n\t  DiffCoverRef,\n\t} from './types';\n\timport { execCommand } from './utils';\n\timport * as core from '@actions/core';\n\texport const diffCover = async (\n", "  eventInfo: EventInfo,\n\t  filesStatus: FilesStatus,\n\t  coverageInfo: CoverageTypeInfo,\n\t): Promise<DiffInfo[]> => {\n\t  if (eventInfo.showDiffcover) {\n\t    const gitLogCommand = `git log --oneline origin/${eventInfo.baseRef}..origin/${eventInfo.headRef} -- | cut -f1 -d' '`;\n\t    const gitLogExec = await execCommand(gitLogCommand);\n\t    if (gitLogExec.status !== 'success') {\n\t      throw new Error(\n\t        `failed to retrieve git log: ${eventInfo.baseRef}..${eventInfo.headRef}. error: ${gitLogExec.message}`,\n", "      );\n\t    }\n\t    const commitsSha = gitLogExec.stdout?.split('\\n').filter((sha) => sha) || [];\n\t    core.info(`commitsSha list:[${commitsSha}]`);\n\t    const changedFiles = [\n\t      ...filesStatus.added,\n\t      ...filesStatus.modified,\n\t      ...filesStatus.changed,\n\t    ];\n\t    return getDiff(coverageInfo, changedFiles, commitsSha, eventInfo.diffcoverRef);\n", "  }\n\t  return [];\n\t};\n\tconst getDiff = async (\n\t  coverageInfo: CoverageTypeInfo,\n\t  changedFiles: string[],\n\t  commitsSha: string[],\n\t  referral: DiffCoverRef,\n\t): Promise<DiffInfo[]> => {\n\t  const diffInfo: DiffInfo[] = [];\n", "  for (const fileCoverInfo of coverageInfo[referral]) {\n\t    for (const currFile of changedFiles) {\n\t      const changedLinesExec = await execCommand(\n\t        `git blame ${currFile} | grep -n '${commitsSha.join('\\\\|')}' | cut -f1 -d:`,\n\t      );\n\t      if (changedLinesExec.status === 'success') {\n\t        const changedLines =\n\t          changedLinesExec.stdout?.split('\\n').filter((line) => line) || [];\n\t        if (changedLines.length) {\n\t          if (fileCoverInfo.lines.details.length) {\n", "            if (\n\t              fileCoverInfo.file === currFile ||\n\t              currFile.includes(fileCoverInfo.file) ||\n\t              fileCoverInfo.file.includes(currFile)\n\t            ) {\n\t              const misses = changedLines.filter(\n\t                (changedLine: string) =>\n\t                  fileCoverInfo.lines.details.find(\n\t                    (details) => details.line === +changedLine,\n\t                  )?.hit === 0,\n", "              );\n\t              core.info(`diffCover on file=${currFile}`);\n\t              core.info(`misses: [${misses}]`);\n\t              core.info(\n\t                `coverage: ${Math.round(\n\t                  (1 - misses.length / changedLines.length) * 100,\n\t                )}%`,\n\t              );\n\t              diffInfo.push({\n\t                file: currFile,\n", "                missedLines: misses,\n\t                changedLines: changedLines,\n\t              });\n\t            }\n\t          }\n\t        }\n\t      } else {\n\t        throw new Error(\n\t          `failed to execute \"git blame\" on file: ${currFile}. error: ${changedLinesExec.message}`,\n\t        );\n", "      }\n\t      // core.info(changedLinesExec.stdout);\n\t    }\n\t  }\n\t  return diffInfo;\n\t};\n"]}
{"filename": "src/eventInfo.ts", "chunked_list": ["import * as core from '@actions/core';\n\timport { DiffCoverRef, EventInfo } from './types';\n\timport { context } from '@actions/github';\n\texport const getEventInfo = (): EventInfo => {\n\t  const eventInfo: EventInfo = {\n\t    token: core.getInput('github-token', { required: true }),\n\t    commentTitle: core.getInput('title', { required: false }),\n\t    owner: context.repo.owner,\n\t    repo: context.repo.repo,\n\t    coberturaPath: core.getInput('cobertura-path', { required: false }),\n", "    cloverPath: core.getInput('clover-path', { required: false }),\n\t    lcovPath: core.getInput('lcov-path', { required: false }),\n\t    jacocoPath: core.getInput('jacoco-path', { required: false }),\n\t    junitPath: core.getInput('junit-path', { required: false }),\n\t    showJunit: core.getBooleanInput('show-junit', { required: false }),\n\t    showDiffcover: core.getBooleanInput('show-diffcover', { required: false }),\n\t    minCoveragePercentage: core.getInput('min-coverage-percentage', { required: false }),\n\t    failUnderCoveragePercentage: core.getBooleanInput('fail-under-coverage-percentage', {\n\t      required: false,\n\t    }),\n", "    showFailuresInfo: core.getBooleanInput('show-failures-info', { required: false }),\n\t    overrideComment: core.getBooleanInput('override-comment', { required: false }),\n\t    commentId: '<!-- tests-coverage-report -->',\n\t    diffcoverRef: core.getInput('diffcover-ref', { required: false }) as DiffCoverRef,\n\t    commitSha: '',\n\t    headRef: '',\n\t    baseRef: '',\n\t    pwd: process.env.GITHUB_WORKSPACE || '',\n\t  };\n\t  if (context.eventName === 'pull_request' && context.payload) {\n", "    eventInfo.commitSha = context.payload.pull_request?.head.sha;\n\t    eventInfo.headRef = context.payload.pull_request?.head.ref;\n\t    eventInfo.baseRef = context.payload.pull_request?.base.ref;\n\t  } else if (context.eventName === 'push') {\n\t    eventInfo.commitSha = context.payload.after;\n\t    eventInfo.headRef = context.ref;\n\t  }\n\t  return eventInfo;\n\t};\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import { exec, ExecException } from 'node:child_process';\n\timport * as core from '@actions/core';\n\texport interface ExecInfo {\n\t  status: 'error' | 'success';\n\t  message?: string;\n\t  errorCode?: number;\n\t  stdout?: string;\n\t}\n\texport const execCommand = async (command: string): Promise<ExecInfo> => {\n\t  return new Promise((resolve) => {\n", "    exec(command, (error: ExecException | null, stdout: string) => {\n\t      if (error) {\n\t        core.error(`could not execute command: ${command}. error: ${error.message}`);\n\t        return resolve({\n\t          status: 'error',\n\t          message: error.message,\n\t          errorCode: error.code,\n\t        });\n\t      }\n\t      resolve({\n", "        status: 'success',\n\t        stdout,\n\t      });\n\t    });\n\t  });\n\t};\n"]}
{"filename": "src/index.ts", "chunked_list": ["import * as core from '@actions/core';\n\timport { main } from './main';\n\tmain()\n\t  .then(() => {\n\t    core.info('success');\n\t  })\n\t  .catch((err) => {\n\t    core.error(`exception. ${err.message}`);\n\t  });\n"]}
{"filename": "src/changedFiles.ts", "chunked_list": ["import { getOctokit } from '@actions/github';\n\timport { FilesStatus, EventInfo } from './types';\n\texport const getChangedFiles = async (eventInfo: EventInfo): Promise<FilesStatus> => {\n\t  const allFiles: FilesStatus = {\n\t    all: [],\n\t    added: [],\n\t    removed: [],\n\t    modified: [],\n\t    renamed: [],\n\t    copied: [],\n", "    changed: [],\n\t    unchanged: [],\n\t  };\n\t  const octokit = getOctokit(eventInfo.token);\n\t  let pages = 1;\n\t  const pagedFiles = [];\n\t  for (let currPage = 1; currPage <= pages; currPage++) {\n\t    const {\n\t      data: { total_commits, files },\n\t    } = await octokit.rest.repos.compareCommitsWithBasehead({\n", "      owner: eventInfo.owner,\n\t      repo: eventInfo.repo,\n\t      basehead: `${eventInfo.baseRef}...${eventInfo.headRef}`,\n\t      per_page: 50,\n\t      page: currPage,\n\t    });\n\t    if (files) {\n\t      pages = Math.ceil(total_commits / 50);\n\t      for (const file of files) {\n\t        allFiles.all.push(file.filename);\n", "        allFiles[`${file.status}`].push(file.filename);\n\t      }\n\t      pagedFiles.push(...files);\n\t    }\n\t  }\n\t  return allFiles;\n\t};\n"]}
{"filename": "src/parsers/cobertura.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-explicit-any */\n\timport fs from 'fs';\n\timport path from 'path';\n\timport { CoverInfo, CoverInfoBranchesDetails } from '../types';\n\timport parseString from 'xml2js';\n\timport * as core from '@actions/core';\n\tconst classesFromPackages = (packages: any) => {\n\t  const classes: any[] = [];\n\t  packages.forEach((packages: any) => {\n\t    packages.package.forEach((pack: any) => {\n", "      pack.classes.forEach((c: any) => {\n\t        classes.push(...c.class);\n\t      });\n\t    });\n\t  });\n\t  return classes;\n\t};\n\tconst extractLcovStyleBranches = (c: any) => {\n\t  const branches: CoverInfoBranchesDetails[] = [];\n\t  if (c.lines && c.lines[0].line) {\n", "    c.lines[0].line.forEach((l: any) => {\n\t      if (l.$.branch == 'true') {\n\t        const branchFraction = l.$['condition-coverage'].split(' ');\n\t        const branchStats = branchFraction[1].match(/\\d+/g);\n\t        const coveredBranches = Number(branchStats[0]);\n\t        const totalBranches = Number(branchStats[1]);\n\t        const leftBranches = totalBranches - coveredBranches;\n\t        let branchNumber = 0;\n\t        for (let i = 0; i < leftBranches; i++) {\n\t          branches.push({\n", "            line: Number(l.$.number),\n\t            branch: branchNumber,\n\t            taken: 0,\n\t          });\n\t          branchNumber++;\n\t        }\n\t        for (let i = 0; i < coveredBranches; i++) {\n\t          branches.push({\n\t            line: Number(l.$.number),\n\t            branch: branchNumber,\n", "            taken: 1,\n\t          });\n\t          branchNumber++;\n\t        }\n\t      }\n\t    });\n\t  }\n\t  return branches;\n\t};\n\tconst unpackage = (coverage: any, pwd: string): CoverInfo[] => {\n", "  const packages = coverage.packages;\n\t  const source = coverage.sources[0].source[0];\n\t  const classes = classesFromPackages(packages);\n\t  return classes.map((c) => {\n\t    const branches = extractLcovStyleBranches(c);\n\t    const classCov: CoverInfo = {\n\t      title: c.$.name,\n\t      // file: c.$.filename,\n\t      file: path.join(source, c.$.filename).replace(pwd, ''),\n\t      functions: {\n", "        found: c.methods && c.methods[0].method ? c.methods[0].method.length : 0,\n\t        hit: 0,\n\t        details:\n\t          !c.methods || !c.methods[0].method\n\t            ? []\n\t            : c.methods[0].method.map((m: any) => {\n\t                return {\n\t                  name: m.$.name,\n\t                  line: Number(m.lines[0].line[0].$.number),\n\t                  hit: Number(m.lines[0].line[0].$.hits),\n", "                };\n\t              }),\n\t      },\n\t      lines: {\n\t        found: c.lines && c.lines[0].line ? c.lines[0].line.length : 0,\n\t        hit: 0,\n\t        details:\n\t          !c.lines || !c.lines[0].line\n\t            ? []\n\t            : c.lines[0].line.map((l: any) => {\n", "                return {\n\t                  line: Number(l.$.number),\n\t                  hit: Number(l.$.hits),\n\t                };\n\t              }),\n\t      },\n\t      branches: {\n\t        found: branches.length,\n\t        hit: branches.filter((br) => {\n\t          return br.taken > 0;\n", "        }).length,\n\t        details: branches,\n\t      },\n\t    };\n\t    classCov.functions.hit = classCov.functions.details.reduce((acc: any, val: any) => {\n\t      return acc + (val.hit > 0 ? 1 : 0);\n\t    }, 0);\n\t    classCov.lines.hit = classCov.lines.details.reduce((acc: any, val: any) => {\n\t      return acc + (val.hit > 0 ? 1 : 0);\n\t    }, 0);\n", "    return classCov;\n\t  });\n\t};\n\tconst parseContent = (xml: string, pwd: string): Promise<CoverInfo[]> => {\n\t  return new Promise((resolve, reject) => {\n\t    parseString.parseString(xml, (err, parseResult) => {\n\t      if (err) {\n\t        return reject(err);\n\t      }\n\t      if (!parseResult?.coverage) {\n", "        return reject(new Error('invalid or missing xml content'));\n\t      }\n\t      const result = unpackage(parseResult.coverage, pwd);\n\t      resolve(result);\n\t    });\n\t  });\n\t};\n\texport const parseFile = async (file: string, pwd: string): Promise<CoverInfo[]> => {\n\t  return new Promise((resolve, reject) => {\n\t    if (!file || file === '') {\n", "      core.info('no cobertura file specified');\n\t      resolve([]);\n\t    } else {\n\t      fs.readFile(\n\t        file,\n\t        'utf8',\n\t        async (err: NodeJS.ErrnoException | null, data: string) => {\n\t          if (err) {\n\t            core.error(`failed to read file: ${file}. error: ${err.message}`);\n\t            reject(err);\n", "          } else {\n\t            try {\n\t              const info = await parseContent(data, pwd);\n\t              // console.log('====== cobertura ======');\n\t              // console.log(JSON.stringify(info, null, 2));\n\t              resolve(info);\n\t            } catch (error) {\n\t              core.error(`failed to parseContent. err: ${error.message}`);\n\t              reject(error);\n\t            }\n", "          }\n\t        },\n\t      );\n\t    }\n\t  });\n\t};\n"]}
{"filename": "src/parsers/clover.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-explicit-any */\n\timport fs from 'fs';\n\timport { CoverInfo, CoverInfoFunctionsDetails, CoverInfoLinesDetails } from '../types';\n\timport parseString from 'xml2js';\n\timport * as core from '@actions/core';\n\tconst classDetailsFromProjects = (projects: any) => {\n\t  let classDetails: any[] = [];\n\t  let packageName = null;\n\t  const parseFileObject = (fileObj: any, packageName: string) => {\n\t    if (fileObj.class) {\n", "      fileObj['class'].forEach((classObj: any) => {\n\t        classDetails = classDetails.concat({\n\t          name: classObj.$.name,\n\t          metrics: classObj.metrics[0],\n\t          fileName: fileObj.$.name,\n\t          fileMetrics: fileObj.metrics[0],\n\t          lines: fileObj.line,\n\t          packageName: packageName,\n\t        });\n\t      });\n", "    } else {\n\t      classDetails = classDetails.concat({\n\t        name: null,\n\t        metrics: null,\n\t        fileName: fileObj.$.name,\n\t        fileMetrics: fileObj.metrics[0],\n\t        lines: fileObj.line,\n\t        packageName: packageName,\n\t      });\n\t    }\n", "  };\n\t  projects.forEach((projectObj: any) => {\n\t    if (projectObj.package) {\n\t      projectObj.package.forEach((data: any) => {\n\t        if (data.$?.name) {\n\t          packageName = data.$.name;\n\t        } else {\n\t          packageName = null;\n\t        }\n\t        data.file.forEach(parseFileObject);\n", "      });\n\t    }\n\t    if (projectObj.file) {\n\t      packageName = null;\n\t      projectObj.file.forEach(parseFileObject);\n\t    }\n\t  });\n\t  return classDetails;\n\t};\n\tconst unpackage = (projects: any): CoverInfo[] => {\n", "  const classDetails = classDetailsFromProjects(projects);\n\t  return classDetails.map((c: any) => {\n\t    const methodStats: CoverInfoFunctionsDetails[] = [];\n\t    const lineStats: CoverInfoLinesDetails[] = [];\n\t    if (c.lines) {\n\t      c.lines.forEach((l: any) => {\n\t        if (l.$.type === 'method') {\n\t          methodStats.push({\n\t            name: l.$.name,\n\t            line: Number(l.$.num),\n", "            hit: Number(l.$.count),\n\t          });\n\t        } else {\n\t          lineStats.push({\n\t            line: Number(l.$.num),\n\t            hit: Number(l.$.count),\n\t          });\n\t        }\n\t      });\n\t    }\n", "    const classCov: CoverInfo = {\n\t      title: c.name,\n\t      file: c.fileName,\n\t      functions: {\n\t        found: methodStats.length,\n\t        hit: 0,\n\t        details: methodStats,\n\t      },\n\t      lines: {\n\t        found: lineStats.length,\n", "        hit: 0,\n\t        details: lineStats,\n\t      },\n\t      branches: {\n\t        found: 0,\n\t        hit: 0,\n\t        details: [],\n\t      },\n\t    };\n\t    classCov.functions.hit = classCov.functions.details.reduce((acc, val) => {\n", "      return acc + (val.hit > 0 ? 1 : 0);\n\t    }, 0);\n\t    classCov.lines.hit = classCov.lines.details.reduce((acc, val) => {\n\t      return acc + (val.hit > 0 ? 1 : 0);\n\t    }, 0);\n\t    return classCov;\n\t  });\n\t};\n\tconst parseContent = (xml: any): Promise<CoverInfo[]> => {\n\t  return new Promise((resolve, reject) => {\n", "    parseString.parseString(xml, (err, parseResult) => {\n\t      if (err) {\n\t        reject(err);\n\t      }\n\t      if (!parseResult?.coverage?.project) {\n\t        return reject(new Error('invalid or missing xml content'));\n\t      }\n\t      const result = unpackage(parseResult.coverage.project);\n\t      resolve(result);\n\t    });\n", "  });\n\t};\n\texport const parseFile = async (file: string): Promise<CoverInfo[]> => {\n\t  return new Promise((resolve, reject) => {\n\t    if (!file || file === '') {\n\t      core.info('no clover file specified');\n\t      resolve([]);\n\t    } else {\n\t      fs.readFile(\n\t        file,\n", "        'utf8',\n\t        async (err: NodeJS.ErrnoException | null, data: string) => {\n\t          if (err) {\n\t            core.error(`failed to read file: ${file}. error: ${err.message}`);\n\t            reject(err);\n\t          } else {\n\t            try {\n\t              const info = await parseContent(data);\n\t              // console.log('====== clover ======');\n\t              // console.log(JSON.stringify(info, null, 2));\n", "              resolve(info);\n\t            } catch (error) {\n\t              core.error(`failed to parseContent. err: ${error.message}`);\n\t              reject(error);\n\t            }\n\t          }\n\t        },\n\t      );\n\t    }\n\t  });\n", "};\n"]}
{"filename": "src/parsers/junit.ts", "chunked_list": ["/* eslint-disable  @typescript-eslint/no-explicit-any */\n\timport fs from 'fs';\n\timport { Junit, JunitFailureInfo } from '../types';\n\timport parseString from 'xml2js';\n\timport * as core from '@actions/core';\n\tconst unpackage = (testsuites: any): Junit => {\n\t  const main = testsuites['$'] || testsuites.testsuite[0]['$'];\n\t  const testsuite: any[] = testsuites.testsuite;\n\t  const errors =\n\t    testsuite\n", "      ?.map((test: any) => +test['$'].errors)\n\t      .reduce((acc: number, curr: number) => acc + curr, 0) || 0;\n\t  const skipped =\n\t    testsuite\n\t      ?.map((test: any) => +test['$'].skipped)\n\t      .reduce((acc: number, curr: number) => acc + curr, 0) || 0;\n\t  const testSuiteFailures = testsuite?.filter((test: any) => +test['$'].failures > 0);\n\t  const failureCase: JunitFailureInfo[] | undefined = testSuiteFailures\n\t    .map((testSuiteFailure: any) => {\n\t      const testCaseFailures: any[] = testSuiteFailure.testcase.filter(\n", "        (testCase: any) => testCase.failure,\n\t      );\n\t      return testCaseFailures.map((testCaseFailure: any) => ({\n\t        classname: testCaseFailure['$'].classname.trim(),\n\t        name: testCaseFailure['$'].name.trim(),\n\t        time: `${parseFloat(testCaseFailure['$'].time).toFixed(2)}s`,\n\t        error: getTestFailureMessage(testCaseFailure),\n\t      }));\n\t    })\n\t    .flat();\n", "  return {\n\t    tests: +main.tests,\n\t    failures: {\n\t      count: +main.failures,\n\t      info: failureCase,\n\t    },\n\t    errors: +main.errors || errors,\n\t    skipped,\n\t    time: `${parseFloat(main.time).toFixed(2)}s`,\n\t  };\n", "};\n\tconst getTestFailureMessage = (testCaseFailure: any): string => {\n\t  const failure = testCaseFailure?.failure?.[0];\n\t  if (failure) {\n\t    if (typeof failure === 'string') {\n\t      return failure.split('\\n')?.[0]?.trim() || 'unhandled string error';\n\t    } else if (typeof failure === 'object') {\n\t      return failure['$']?.message || failure.message || 'unhandled object error';\n\t    }\n\t  }\n", "  return 'unknown failure';\n\t};\n\tconst parseContent = (xml: string): Promise<Junit> => {\n\t  return new Promise((resolve, reject) => {\n\t    parseString.parseString(xml, (err, parseResult) => {\n\t      if (err) {\n\t        return reject(err);\n\t      }\n\t      if (!parseResult?.testsuites) {\n\t        return reject(new Error('invalid or missing xml content'));\n", "      }\n\t      const result = unpackage(parseResult.testsuites);\n\t      resolve(result);\n\t    });\n\t  });\n\t};\n\texport const parse = async (path: string): Promise<Junit | undefined> => {\n\t  if (!path || path === '') {\n\t    core.info('no junit file/folder specified');\n\t    return undefined;\n", "  }\n\t  if (fs.lstatSync(path).isFile()) {\n\t    return parseFile(path);\n\t  } else if (fs.lstatSync(path).isDirectory()) {\n\t    return parseFolder(path);\n\t  }\n\t};\n\tconst parseFile = async (file: string): Promise<Junit | undefined> => {\n\t  return new Promise((resolve, reject) => {\n\t    fs.readFile(file, 'utf8', async (err: NodeJS.ErrnoException | null, data: string) => {\n", "      if (err) {\n\t        core.error(`failed to read file: ${file}. error: ${err.message}`);\n\t        reject(err);\n\t      } else {\n\t        try {\n\t          const info = await parseContent(data);\n\t          // console.log('====== junit ======');\n\t          // console.log(JSON.stringify(info, null, 2));\n\t          resolve(info);\n\t        } catch (error) {\n", "          core.error(`failed to parseContent. err: ${error.message}`);\n\t          reject(error);\n\t        }\n\t      }\n\t    });\n\t  });\n\t};\n\tconst parseFolder = async (folder: string): Promise<Junit | undefined> => {\n\t  const mergedTestSuites: any = {\n\t    $: {},\n", "    testsuite: [],\n\t  };\n\t  const files = fs.readdirSync(folder);\n\t  for (const file of files) {\n\t    try {\n\t      if (file.endsWith('.xml')) {\n\t        const filePath = `${folder}/${file}`;\n\t        const testSuiteArray = await getTestsuiteList(filePath);\n\t        if (testSuiteArray.length === 0) {\n\t          core.warning(`No tests found in file: ${filePath}`);\n", "        } else {\n\t          mergedTestSuites.testsuite.push(...testSuiteArray);\n\t        }\n\t      }\n\t    } catch (error) {\n\t      core.error(\n\t        `failed to parse folder file: ${folder}/${file}. error: ${error.message}`,\n\t      );\n\t    }\n\t  }\n", "  mergedTestSuites.$ = buildMainContent(mergedTestSuites.testsuite);\n\t  return unpackage(mergedTestSuites);\n\t};\n\tconst getTestsuiteList = async (filename: string) => {\n\t  try {\n\t    const testsuiteList: any[] = [];\n\t    const xmlContent = fs.readFileSync(filename, 'utf8');\n\t    const parseResult = await parseString.parseStringPromise(xmlContent);\n\t    if (Object.keys(parseResult)?.[0] === 'testsuite') {\n\t      testsuiteList.push(parseResult.testsuite);\n", "    } else if (Object.keys(parseResult)?.[0] === 'testsuites') {\n\t      for (const testsuite of parseResult.testsuites.testsuite) {\n\t        testsuiteList.push(testsuite);\n\t      }\n\t    }\n\t    return testsuiteList;\n\t  } catch (error) {\n\t    core.error(`failed to read file: ${filename}. error: ${error.message}`);\n\t    return [];\n\t  }\n", "};\n\tconst buildMainContent = (testSuiteList: any[]) => {\n\t  const main = {\n\t    tests: 0,\n\t    failures: 0,\n\t    errors: 0,\n\t    skipped: 0,\n\t    name: '',\n\t    time: 0,\n\t  };\n", "  for (const testSuite of testSuiteList) {\n\t    main.tests += +testSuite.$.tests;\n\t    main.failures += +testSuite.$.failures;\n\t    main.errors += +testSuite.$.errors;\n\t    main.skipped += +testSuite.$.skipped;\n\t    if (main.time < +testSuite.$.time) {\n\t      main.time = +testSuite.$.time;\n\t    }\n\t  }\n\t  return {\n", "    tests: `${main.tests}`,\n\t    failures: `${main.failures}`,\n\t    errors: `${main.errors}`,\n\t    skipped: `${main.skipped}`,\n\t    name: '',\n\t    time: `${main.time}`,\n\t  };\n\t};\n"]}
{"filename": "src/parsers/jacoco.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-explicit-any */\n\timport fs from 'fs';\n\timport { CoverInfo } from '../types';\n\timport parseString from 'xml2js';\n\timport * as core from '@actions/core';\n\tconst getCounter = (source: any, type: string) => {\n\t  source.counter = source.counter || [];\n\t  return (\n\t    source.counter.filter((counter: any) => {\n\t      return counter.$.type === type;\n", "    })[0] || {\n\t      $: {\n\t        covered: 0,\n\t        missed: 0,\n\t      },\n\t    }\n\t  );\n\t};\n\tconst unpackage = (report: any): CoverInfo[] => {\n\t  const packages = report.package;\n", "  let output: CoverInfo[] = [];\n\t  packages.forEach((pack: any) => {\n\t    const cov = pack.sourcefile.map((source: any) => {\n\t      const fullPath = pack.$.name + '/' + source.$.name;\n\t      const methods = getCounter(source, 'METHOD');\n\t      const lines = getCounter(source, 'LINE');\n\t      const branches = getCounter(source, 'BRANCH');\n\t      const classCov: CoverInfo = {\n\t        title: source.$.name,\n\t        file: fullPath,\n", "        functions: {\n\t          found: Number(methods.$.covered) + Number(methods.$.missed),\n\t          hit: Number(methods.$.covered),\n\t          details: pack.class.reduce((result: any, currentClass: any) => {\n\t            return !currentClass.method\n\t              ? result\n\t              : result.concat(\n\t                  currentClass.method.map((method: any) => {\n\t                    const hit = method.counter.some((counter: any) => {\n\t                      return counter.$.type === 'METHOD' && counter.$.covered === '1';\n", "                    });\n\t                    return {\n\t                      name: method.$.name,\n\t                      line: Number(method.$.line),\n\t                      hit: hit ? 1 : 0,\n\t                    };\n\t                  }),\n\t                );\n\t          }, []),\n\t        },\n", "        lines: {\n\t          found: Number(lines.$.covered) + Number(lines.$.missed),\n\t          hit: Number(lines.$.covered),\n\t          details: !source.line\n\t            ? []\n\t            : source.line.map((l: any) => {\n\t                return {\n\t                  line: Number(l.$.nr),\n\t                  hit: Number(l.$.ci),\n\t                };\n", "              }),\n\t        },\n\t        branches: {\n\t          found: Number(branches.$.covered) + Number(branches.$.missed),\n\t          hit: Number(branches.$.covered),\n\t          details:\n\t            source.line\n\t              ?.filter((l: any) => {\n\t                return Number(l.$.mb) > 0 || Number(l.$.cb) > 0;\n\t              })\n", "              .map((l: any) => {\n\t                let branches: any[] = [];\n\t                const count = Number(l.$.mb) + Number(l.$.cb);\n\t                for (let i = 0; i < count; ++i) {\n\t                  branches = branches.concat({\n\t                    line: Number(l.$.nr),\n\t                    block: 0,\n\t                    branch: Number(i),\n\t                    taken: i < Number(l.$.cb) ? 1 : 0,\n\t                  });\n", "                }\n\t                return branches;\n\t              })\n\t              .flat() || [],\n\t        },\n\t      };\n\t      return classCov;\n\t    });\n\t    output = output.concat(cov);\n\t  });\n", "  return output;\n\t};\n\tconst parseContent = (xml: string): Promise<CoverInfo[]> => {\n\t  return new Promise((resolve, reject) => {\n\t    parseString.parseString(xml, (err, parseResult) => {\n\t      if (err) {\n\t        return reject(err);\n\t      }\n\t      if (!parseResult?.report) {\n\t        return reject(new Error('invalid or missing xml content'));\n", "      }\n\t      const result = unpackage(parseResult.report);\n\t      resolve(result);\n\t    });\n\t  });\n\t};\n\texport const parseFile = async (file: string): Promise<CoverInfo[]> => {\n\t  return new Promise((resolve, reject) => {\n\t    if (!file || file === '') {\n\t      core.info('no jacoco file specified');\n", "      resolve([]);\n\t    } else {\n\t      fs.readFile(\n\t        file,\n\t        'utf8',\n\t        async (err: NodeJS.ErrnoException | null, data: string) => {\n\t          if (err) {\n\t            core.error(`failed to read file: ${file}. error: ${err.message}`);\n\t            reject(err);\n\t          } else {\n", "            try {\n\t              const info = await parseContent(data);\n\t              // console.log('====== jacoco ======');\n\t              // console.log(JSON.stringify(info, null, 2));\n\t              resolve(info);\n\t            } catch (error) {\n\t              core.error(`failed to parseContent. err: ${error.message}`);\n\t              reject(error);\n\t            }\n\t          }\n", "        },\n\t      );\n\t    }\n\t  });\n\t};\n"]}
{"filename": "src/parsers/lcov.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-explicit-any */\n\timport fs from 'fs';\n\timport { CoverInfo } from '../types';\n\timport * as core from '@actions/core';\n\tconst parseContent = (str: string): CoverInfo[] => {\n\t  const data: any[] = [];\n\t  let item: CoverInfo;\n\t  ['end_of_record'].concat(str.split('\\n')).forEach((line: string) => {\n\t    line = line.trim();\n\t    const allparts: string[] = line.split(':') || [];\n", "    const parts: string[] = [allparts.shift() || '', allparts.join(':')];\n\t    let lines: any[];\n\t    let fn: any;\n\t    switch (parts[0].toUpperCase()) {\n\t      case 'TN':\n\t        item.title = parts[1].trim();\n\t        break;\n\t      case 'SF':\n\t        item.file = parts.slice(1).join(':').trim();\n\t        break;\n", "      case 'FNF':\n\t        item.functions.found = Number(parts[1].trim());\n\t        break;\n\t      case 'FNH':\n\t        item.functions.hit = Number(parts[1].trim());\n\t        break;\n\t      case 'LF':\n\t        item.lines.found = Number(parts[1].trim());\n\t        break;\n\t      case 'LH':\n", "        item.lines.hit = Number(parts[1].trim());\n\t        break;\n\t      case 'DA':\n\t        lines = parts[1].split(',');\n\t        item.lines.details.push({\n\t          line: Number(lines[0]),\n\t          hit: Number(lines[1]),\n\t        });\n\t        break;\n\t      case 'FN':\n", "        fn = parts[1].split(',');\n\t        item.functions.details.push({\n\t          name: fn[1],\n\t          line: Number(fn[0]),\n\t          hit: 0,\n\t        });\n\t        break;\n\t      case 'FNDA':\n\t        fn = parts[1].split(',');\n\t        item.functions.details.some((i: any, k: any) => {\n", "          if (i.name === fn[1] && i.hit === undefined) {\n\t            item.functions.details[k].hit = Number(fn[0]);\n\t            return true;\n\t          }\n\t        });\n\t        break;\n\t      case 'BRDA':\n\t        fn = parts[1].split(',');\n\t        item.branches.details.push({\n\t          line: Number(fn[0]),\n", "          block: Number(fn[1]),\n\t          branch: Number(fn[2]),\n\t          taken: fn[3] === '-' ? 0 : Number(fn[3]),\n\t        });\n\t        break;\n\t      case 'BRF':\n\t        item.branches.found = Number(parts[1]);\n\t        break;\n\t      case 'BRH':\n\t        item.branches.hit = Number(parts[1]);\n", "        break;\n\t    }\n\t    if (line === 'end_of_record') {\n\t      if (item) {\n\t        data.push(item);\n\t      }\n\t      item = {\n\t        title: '',\n\t        file: '',\n\t        lines: {\n", "          found: 0,\n\t          hit: 0,\n\t          details: [],\n\t        },\n\t        functions: {\n\t          hit: 0,\n\t          found: 0,\n\t          details: [],\n\t        },\n\t        branches: {\n", "          hit: 0,\n\t          found: 0,\n\t          details: [],\n\t        },\n\t      };\n\t    }\n\t  });\n\t  if (!data.length) {\n\t    core.info('No lcov file content');\n\t  }\n", "  return data;\n\t};\n\texport function parseFile(file: string): Promise<CoverInfo[]> {\n\t  return new Promise((resolve, reject) => {\n\t    if (!file || file === '') {\n\t      core.info('no lcov file specified');\n\t      resolve([]);\n\t    } else {\n\t      fs.readFile(\n\t        file,\n", "        'utf8',\n\t        async (err: NodeJS.ErrnoException | null, data: string) => {\n\t          if (err) {\n\t            core.error(`failed to read file: ${file}. error: ${err.message}`);\n\t            reject(err);\n\t          } else {\n\t            try {\n\t              const info = parseContent(data);\n\t              // console.log('====== lcov ======');\n\t              // console.log(JSON.stringify(info, null, 2));\n", "              resolve(info);\n\t            } catch (error) {\n\t              core.error(`failed to parseContent. err: ${error.message}`);\n\t              reject(error);\n\t            }\n\t          }\n\t        },\n\t      );\n\t    }\n\t  });\n", "}\n"]}
