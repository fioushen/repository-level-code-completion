{"filename": "cli/src/nftCollection.ts", "chunked_list": ["import { Sender, toNano } from 'ton-core'\n\timport {NftCollection, NftCollectionData} from '../../src/wrappers/getgems/NftCollection/NftCollection'\n\timport importKeyPair from './utils/importKeyPair';\n\timport { readFileSync, writeFileSync, existsSync } from 'fs';\n\timport { error } from 'console';\n\timport { env } from 'process';\n\timport { Address } from 'ton-core'\n\timport { TonClient4 } from 'ton';\n\timport createSender from './utils/createSender'\n\texport async function createNftCollection(\n", "    client: TonClient4,\n\t    config: NftCollectionData,\n\t    options?: {\n\t        secretKey?: string\n\t    }\n\t) {\n\t    let keypair = await importKeyPair(options?.secretKey);\n\t    let sender = await createSender(keypair, client)\n\t    const nftCollection = client.open(\n\t        await NftCollection.createFromConfig(\n", "            config\n\t        )\n\t    );\n\t    await nftCollection.sendDeploy(sender, toNano('0.05'));\n\t    console.log(\n\t        `NFT Single deployed at ${nftCollection.address}`\n\t    )\n\t    await writeFileSync(\n\t        './NftCollection.json',\n\t        JSON.stringify({\n", "            config: config,\n\t            address: nftCollection.address,\n\t            init: nftCollection.init\n\t        }\n\t    ))\n\t    console.log(\n\t        `Saved Config`\n\t    )\n\t    return nftCollection;\n\t}\n", "export async function importExistingNftCollection(\n\t    client: TonClient4,\n\t    options?: {\n\t        configPath?: string,\n\t        address?: Address\n\t    }\n\t) {\n\t    if (options?.configPath) {\n\t        const config = JSON.parse(\n\t            readFileSync(\n", "                options?.configPath,\n\t                'utf-8'\n\t            )\n\t        )\n\t        const nftCollection = client.open(\n\t            await NftCollection.createFromAddress(\n\t                config.address\n\t            )\n\t        );\n\t        return nftCollection\n", "    } else if (existsSync(String(env.PATH_TO_CONFIG))) {\n\t        const config = JSON.parse(readFileSync(String(env.PATH_TO_CONFIG), 'utf-8'));\n\t        const nftCollection = client.open(\n\t            await NftCollection.createFromAddress(\n\t                config.address\n\t            )\n\t        );\n\t        return nftCollection;\n\t    } else {\n\t        const nftCollection = client.open(\n", "            await NftCollection.createFromAddress(\n\t                options?.address ?? Address.parse(String(env.NFT_COLLECTION_ADDRESS))\n\t            )\n\t        );\n\t        return nftCollection;\n\t    }\n\t}\n\texport async function mint(\n\t    client: TonClient4,\n\t    itemOwner: Address,\n", "    collectionAddress: Address,\n\t    itemContent: string,\n\t    options?: {\n\t        configPath?: string,\n\t        secretKey?: string\n\t    }\n\t) {\n\t    const nftCollection = await importExistingNftCollection(\n\t        client,\n\t        {\n", "            configPath: options?.configPath,\n\t            address: collectionAddress\n\t        }\n\t    );\n\t    let keypair = await importKeyPair(\n\t        options?.secretKey\n\t    )\n\t    let sender = await createSender(keypair, client);\n\t    let collectionData = await nftCollection.getCollectionData();\n\t    let tx = await nftCollection.sendMint(\n", "        sender,\n\t        {\n\t            value: toNano(\"0.05\"),\n\t            passAmount: toNano(\"0\"),\n\t            itemIndex: Number(collectionData.nextItemIndex),\n\t            itemOwnerAddress: itemOwner,\n\t            itemContent: itemContent\n\t        }\n\t    );\n\t    console.log(\n", "        `Minted NFT to ${itemOwner.toString()}`\n\t    )\n\t}"]}
{"filename": "cli/src/nftSingle.ts", "chunked_list": ["import { Sender, toNano } from 'ton-core'\n\timport {NftSingle, NftSingleData} from '../../src/wrappers/getgems/NftSingle/NftSingle'\n\timport importKeyPair from './utils/importKeyPair';\n\timport { readFileSync, writeFileSync } from 'fs';\n\timport { error } from 'console';\n\timport { env } from 'process';\n\timport { Address } from 'ton-core'\n\timport { TonClient4 } from 'ton';\n\timport createSender from './utils/createSender'\n\texport async function createNftSingle(\n", "    client: TonClient4,\n\t    config: NftSingleData,\n\t    options?: {\n\t        secretKey?: string\n\t    }\n\t) {\n\t    let keypair = await importKeyPair(options?.secretKey);\n\t    let sender = await createSender(keypair, client)\n\t    const nftSingle = client.open(\n\t        await NftSingle.createFromConfig(\n", "            config\n\t        )\n\t    );\n\t    await nftSingle.sendDeploy(sender, toNano('0.05'));\n\t    console.log(\n\t        `NFT Single deployed at ${nftSingle.address}`\n\t    )\n\t    await writeFileSync(\n\t        './nftSingle.json',\n\t        JSON.stringify({\n", "            config: config,\n\t            address: nftSingle.address,\n\t            init: nftSingle.init\n\t        }\n\t    ))\n\t    console.log(\n\t        `Saved Config`\n\t    )\n\t    return nftSingle;\n\t}\n", "export async function importExistingNftSingle(\n\t    client: TonClient4,\n\t    options?: {\n\t        configPath?: string\n\t    }\n\t) {\n\t    if (options?.configPath) {\n\t        const config = JSON.parse(\n\t            readFileSync(\n\t                options?.configPath,\n", "                'utf-8'\n\t            )\n\t        )\n\t        const nftSingle = client.open(\n\t            await NftSingle.createFromAddress(\n\t                config.address\n\t            )\n\t        );\n\t        return nftSingle\n\t    } else {\n", "        const config = JSON.parse(readFileSync(String(env.PATH_TO_CONFIG), 'utf-8'));\n\t        const nftSingle = client.open(\n\t            await NftSingle.createFromAddress(\n\t                config.address\n\t            )\n\t        );\n\t        return nftSingle;\n\t    }\n\t}\n\texport async function transfer(\n", "    client: TonClient4,\n\t    destination: string,\n\t    options?: {\n\t        configPath?: string,\n\t        secretKey?: string\n\t    }\n\t) {\n\t    const nftSingle = await importExistingNftSingle(\n\t        client,\n\t        options\n", "    );\n\t    let keypair = await importKeyPair(\n\t        options?.secretKey\n\t    )\n\t    let sender = await createSender(keypair, client);\n\t    let tx = await nftSingle.sendTransfer(\n\t        sender,\n\t        {\n\t            value: toNano('0.05'),\n\t            queryId: toNano('0'),\n", "            newOwner: Address.parse(destination),\n\t            responseDestination: sender.address,\n\t            forwardAmount: toNano('0')\n\t        }\n\t    );\n\t    console.log(\n\t        `Transferred NFT from ${sender.address?.toString()} to ${destination}`\n\t    )\n\t}"]}
{"filename": "cli/src/index.ts", "chunked_list": ["#!/usr/bin/env node\n\timport yargs from 'yargs';\n\timport { hideBin } from 'yargs/helpers';\n\timport {Pinata} from \"../../src/storage/Pinata\"\n\timport {AmazonS3} from \"../../src/storage/AmazonS3\"\n\timport {TonNftClient} from '../../src/ton-api'\n\timport {TonAPI} from '../../src/ton-api/TonAPI'\n\timport { Address } from 'ton-core'\n\timport {createNftSingle, transfer} from \"./nftSingle\"\n\timport {createNftCollection} from \"./nftCollection\"\n", "import { TonClient4 } from 'ton';\n\timport createKeyPair from './utils/createKeyPair';\n\tyargs(hideBin(process.argv))\n\t  .command(\n\t    'upload pinata [path]',\n\t    'Upload an NFT via Pinata',\n\t    (yargs) => {\n\t      return yargs\n\t        .positional('path', {\n\t          describe: 'Path to the file to be uploaded',\n", "          type: 'string',\n\t          default: './assets',\n\t        })\n\t        .option('apiKey', {\n\t          alias: 'k',\n\t          describe: 'API key for authentication',\n\t          type: 'string',\n\t          demandOption: true,\n\t        })\n\t        .option('secretApiKey', {\n", "          alias: 's',\n\t          describe: 'Secret API key for authentication',\n\t          type: 'string',\n\t          demandOption: true,\n\t        });\n\t    },\n\t    async (argv) => {\n\t      if (typeof argv.path === 'string' \n\t          && typeof argv.apiKey === 'string' \n\t          && typeof argv.secretApiKey == 'string'\n", "      ) {\n\t        console.log(`Using API key: ${argv.apiKey}`);\n\t        console.log(`Using secret API key: ${argv.secretApiKey}`);\n\t        let pinata = new Pinata(argv.apiKey, argv.secretApiKey);\n\t        let imagesUrls = await pinata.uploadBulk(argv.path)\n\t        console.log(`URLs: ${imagesUrls}`)\n\t      }\n\t    }\n\t  )\n\t  .command(\n", "    'upload s3 [path]',\n\t    'Upload an NFT via Amazon S3',\n\t    (yargs) => {\n\t      return yargs\n\t        .positional('path', {\n\t          describe: 'Path to the file to be uploaded',\n\t          type: 'string',\n\t          default: './assets',\n\t        })\n\t        .option('accessKey', {\n", "          alias: 'k',\n\t          describe: 'Access key for authentication',\n\t          type: 'string',\n\t          demandOption: true,\n\t        })\n\t        .option('secretAccessKey', {\n\t          alias: 's',\n\t          describe: 'Secret access key for authentication',\n\t          type: 'string',\n\t          demandOption: true,\n", "        })\n\t        .option('bucketName', {\n\t          alias: 'b',\n\t          describe: 'Bucket Name',\n\t          type:'string',\n\t          demandOption: true,\n\t        })\n\t        .option('fileType', {\n\t          alias: 'f',\n\t          describe: 'File type of the image',\n", "          type: 'string',\n\t          demandOption: true,\n\t          default: \"image/jpeg\"\n\t        });\n\t    },\n\t    async (argv) => {\n\t      if (typeof argv.path === 'string' \n\t          && typeof argv.apiKey === 'string' \n\t          && typeof argv.secretApiKey == 'string'\n\t      ) {\n", "        console.log(`Using API key: ${argv.apiKey}`);\n\t        console.log(`Using secret API key: ${argv.secretApiKey}`);\n\t        console.log(`Using bucket name: ${argv.bucketName}`);\n\t        let s3 = new AmazonS3(argv.apiKey, argv.secretApiKey, argv.bucketName);\n\t        let imagesUrls = await s3.uploadBulk(argv.path)\n\t        console.log(`URLs: ${imagesUrls}`)\n\t      }\n\t    }\n\t  )\n\t  // New command for getNftCollections\n", "  .command(\n\t    'collections [limit] [offset]',\n\t    'Get NFT collections',\n\t    (yargs) => {\n\t      return yargs\n\t        .positional('limit', {\n\t          describe: 'Maximum number of collections to return',\n\t          type: 'number',\n\t          default: 10,\n\t        })\n", "        .positional('offset', {\n\t          describe: 'Number of collections to skip',\n\t          type: 'number',\n\t          default: 0,\n\t        });\n\t    },\n\t    async (argv) => {\n\t      const tonClient = new TonNftClient(new TonAPI());\n\t      const collections = await tonClient.getNftCollections(argv.limit, argv.offset);\n\t      console.log(collections);\n", "    }\n\t  )\n\t  // New command for getNftCollectionByAddress\n\t  .command(\n\t    'collection <address>',\n\t    'Get NFT collection by address',\n\t    (yargs) => {\n\t      return yargs.positional('address', {\n\t        describe: 'Collection address',\n\t        type: 'string',\n", "      });\n\t    },\n\t    async (argv) => {\n\t      if (typeof argv.address === 'string') {\n\t        const tonClient = new TonNftClient(new TonAPI());\n\t        const collection = await tonClient.getNftCollection(argv.address);\n\t        console.log(collection);\n\t      }\n\t    }\n\t  )\n", "  // New command for getNftItemsFromCollectionByAddress\n\t  .command(\n\t    'collection-items <address> [limit] [offset]',\n\t    'Get NFT items from collection by address',\n\t    (yargs) => {\n\t      return yargs\n\t        .positional('address', {\n\t          describe: 'Collection address',\n\t          type: 'string',\n\t        })\n", "        .positional('limit', {\n\t          describe: 'Maximum number of items to return',\n\t          type: 'number',\n\t          default: 10,\n\t        })\n\t        .positional('offset', {\n\t          describe: 'Number of items to skip',\n\t          type: 'number',\n\t          default: 0,\n\t        });\n", "    },\n\t    async (argv) => {\n\t      if (typeof argv.address === 'string') {\n\t        const tonClient = new TonNftClient(new TonAPI());\n\t        const items = await tonClient.getNftItems(argv.address, argv.limit, argv.offset);\n\t        console.log(items);\n\t      }\n\t    }\n\t  )\n\t  // New command for getNftItemByAddress\n", "  .command(\n\t    'item <address>',\n\t    'Get NFT item by its address',\n\t    (yargs) => {\n\t      return yargs.positional('address', {\n\t        describe: 'Item address',\n\t        type: 'string',\n\t      });\n\t    },\n\t    async (argv) => {\n", "      if (typeof argv.address === 'string') {\n\t        const tonClient = new TonNftClient(new TonAPI());\n\t        const item = await tonClient.getNftItem(argv.address);\n\t        console.log(item);\n\t      }\n\t    }\n\t  )\n\t  .command(\n\t    'keypair create',\n\t    'Creates Keypair',\n", "    (yargs) => {\n\t    },\n\t    async (argv) => {\n\t      await createKeyPair();\n\t  })\n\t  .command(\n\t    'nft-single create <configPath> [secretKey]',\n\t    'Create a single NFT',\n\t    (yargs) => {\n\t      return yargs\n", "        .positional('configPath', {\n\t          describe: 'Path to the NFT single data config JSON file',\n\t          type: 'string',\n\t        })\n\t        .positional('secretKey', {\n\t          describe: 'Secret key for creating the NFT',\n\t          type: 'string',\n\t          default: undefined,\n\t        });\n\t    },\n", "    async (argv) => {\n\t      if (typeof argv.configPath === 'string') {\n\t        const client = new TonClient4({\n\t          endpoint: \"https://toncenter.com/api/v2/jsonRPC\"\n\t        });\n\t        const config = require(argv.configPath);\n\t        const options = { secretKey: argv.secretKey };\n\t        await createNftSingle(client, config, options);\n\t      }\n\t    }\n", "  )\n\t  .command(\n\t    'nft-single transfer <destination> [configPath] [secretKey]',\n\t    'Transfer an NFT Single',\n\t    (yargs) => {\n\t      return yargs\n\t        .positional('destination', {\n\t          describe: 'Destination address',\n\t          type: 'string',\n\t        })\n", "        .positional('configPath', {\n\t          describe: 'Path to the transfer configuration JSON file',\n\t          type: 'string',\n\t          default: undefined,\n\t        })\n\t        .positional('secretKey', {\n\t          describe: 'Secret key of the Sender',\n\t          type: 'string',\n\t          default: undefined,\n\t        });\n", "    },\n\t    async (argv) => {\n\t      if (typeof argv.destination === 'string') {\n\t        const client = new TonClient4({\n\t          endpoint: \"https://toncenter.com/api/v2/jsonRPC\"\n\t        });\n\t        const options = { configPath: argv.configPath, secretKey: argv.secretKey };\n\t        await transfer(client, argv.destination, options);\n\t      }\n\t    }\n", "  )\n\t  .command(\n\t    'nft-collection create <configPath> [secretKey]',\n\t    'Create a NFT Collection',\n\t    (yargs) => {\n\t      return yargs\n\t       .positional('configPath', {\n\t          describe: 'Path to the NFT collection data config JSON file',\n\t          type:'string',\n\t        })\n", "       .positional('secretKey', {\n\t          describe: 'Secret key for creating the NFT',\n\t          type:'string',\n\t          default: undefined,\n\t        });\n\t        },\n\t    async (argv) => {\n\t      if (typeof argv.configPath ==='string') {\n\t        const client = new TonClient4({\n\t          endpoint: \"https://toncenter.com/api/v2/jsonRPC\"\n", "        });\n\t        const config = require(argv.configPath);\n\t        const options = { secretKey: argv.secretKey };\n\t        await createNftCollection(client, config, options);\n\t      }\n\t    }\n\t  )\n\t  .demandCommand(1, 'You need at least one command before moving on')\n\t  .help()\n\t  .alias('h', 'help')\n", "  .strict()\n\t  .parse();\n"]}
{"filename": "cli/src/utils/createSender.ts", "chunked_list": ["import { KeyPair } from \"ton-crypto\";\n\timport { TonClient4, WalletContractV4 } from \"ton\";\n\texport async function createSender(\n\t    keypair: KeyPair,\n\t    client: TonClient4\n\t) {\n\t    let wallet = WalletContractV4.create(\n\t        {\n\t            workchain: 0,\n\t            publicKey: keypair.publicKey\n", "        }\n\t    )\n\t    let contract = client.open(\n\t        wallet\n\t    );\n\t    return contract.sender(keypair.secretKey);\n\t}\n\texport default createSender;"]}
{"filename": "cli/src/utils/importKeyPair.ts", "chunked_list": ["import { env } from 'process'\n\timport { KeyPair, keyPairFromSecretKey } from \"ton-crypto\"\n\timport { readFileSync } from 'fs';\n\texport async function importKeyPair(\n\t    secretKey?: string\n\t) {\n\t    let keyPair: KeyPair;\n\t    if (secretKey) {\n\t        keyPair = keyPairFromSecretKey(Buffer.from(secretKey, 'hex'));\n\t    } else {\n", "        const content = readFileSync(String(env.SECRET_KEY), 'utf-8');\n\t        keyPair = keyPairFromSecretKey(Buffer.from(content, 'hex'));\n\t    }\n\t    return keyPair;\n\t}\n\texport default importKeyPair;"]}
{"filename": "cli/src/utils/createKeyPair.ts", "chunked_list": ["import { writeFileSync } from \"fs\";\n\timport {mnemonicNew, mnemonicToPrivateKey} from \"ton-crypto\"\n\texport async function createKeyPair() {\n\t    let mnemonic = await mnemonicNew()\n\t    let keypair = await mnemonicToPrivateKey(mnemonic)\n\t    writeFileSync(\n\t        \"./keypair.json\",\n\t        JSON.stringify(keypair)\n\t    );\n\t    writeFileSync(\n", "        \"./.env\",\n\t        `SECRET_KEY=${keypair.secretKey.toString()}`\n\t    )\n\t}\n\texport default createKeyPair;"]}
{"filename": "examples/TonAPI.ts", "chunked_list": ["import {TonNftClient} from '../src/ton-api'\n\timport {TonAPI} from '../src/ton-api/TonAPI'\n\tasync function main() {\n\t    const tonApi = new TonAPI()\n\t    const tonClient = new TonNftClient(\n\t        tonApi\n\t    )\n\t    // Telegram Number Collection\n\t    const collection = await tonClient.getNftCollection('EQAOQdwdw8kGftJCSFgOErM1mBjYPe4DBPq8-AhF6vr9si5N')\n\t    // Prints the Collection Data\n", "    console.log(collection)\n\t    // NFT Collections\n\t    const collections = await tonClient.getNftCollections(\n\t        10,\n\t        10\n\t    )\n\t    // Prints the Collection Data\n\t    console.log(collections)\n\t    // Get NFT items from collection by collection address\n\t    const items = await tonClient.getNftItems('EQAOQdwdw8kGftJCSFgOErM1mBjYPe4DBPq8-AhF6vr9si5N',10,10)\n", "    // Prints the Collection Data\n\t    console.log(items)\n\t    // Get NFT item by its address\n\t    const item = await tonClient.getNftItem('EQBn9d_1SaXIqogjb884eIDlbA3_4lgVv1rl8GyTpQpp_1Oi')\n\t    // Prints the Collection Data\n\t    console.log(item)\n\t}\n\tmain()\n"]}
{"filename": "examples/deployNftCollection.ts", "chunked_list": ["import {toNano} from 'ton-core'\n\timport {NftCollection} from '../src/wrappers/getgems/NftCollection/NftCollection'\n\timport {NftItem} from '../src/wrappers/getgems/NftItem/NftItem'\n\timport {randomAddress, importKeyPair, createSender} from '../src/utils'\n\timport {ENDPOINT} from '../src'\n\timport { TonClient4 } from 'ton'\n\timport { Storage } from '../src/storage'\n\timport { Pinata } from '../src/storage/Pinata'\n\tasync function main() {\n\t    // Config\n", "    const keypair = await importKeyPair('')\n\t    const client = new TonClient4({endpoint: ENDPOINT.TESTNET})\n\t    const wallet = await createSender(keypair, client)\n\t    const address = wallet.address ?? randomAddress()\n\t    // Addresses\n\t    const ownerAddress = address\n\t    // Deploying Assets\n\t    const pinata = new Pinata('<apiKey>', '<secretApiKey>')\n\t    const storage = new Storage(pinata)\n\t    // String [0] - Images\n", "    // String [1] - Json\n\t    const data: [string[], string[]] = await storage.uploadBulk('./assets')\n\t    // Creates NFT Collection\n\t    const nftCollection = client.open(\n\t        await NftCollection.createFromConfig({\n\t            ownerAddress: ownerAddress,\n\t            nextItemIndex: 1,\n\t            collectionContent: data[1][0],\n\t            commonContent: '',\n\t            nftItemCode: NftItem.code,\n", "            royaltyParams: {\n\t                royaltyFactor: 10,\n\t                royaltyBase: 100,\n\t                royaltyAddress: ownerAddress\n\t            }\n\t        })\n\t    )\n\t    // Deploys Nft Collection\n\t    const deployResult = await nftCollection.sendDeploy(wallet, toNano('0.05'))\n\t    // Prints Result\n", "    console.log(deployResult)\n\t    // Fetches Nft Collection Data\n\t    const collectionData = await nftCollection.getCollectionData()\n\t    // Prints Nft Collection Data\n\t    console.log(collectionData)    \n\t}\n\tmain()"]}
{"filename": "examples/transferNft.ts", "chunked_list": ["import {toNano} from 'ton-core'\n\timport {NftItem} from '../src/wrappers/getgems/NftItem/NftItem'\n\timport {randomAddress, importKeyPair, createSender} from '../src/utils'\n\timport {ENDPOINT} from '../src'\n\timport { TonClient4 } from 'ton'\n\tasync function main() {\n\t    // Config\n\t    const keypair = await importKeyPair('')\n\t    const client = new TonClient4({endpoint: ENDPOINT.TESTNET})\n\t    const wallet = await createSender(keypair, client)\n", "    const address = wallet.address ?? randomAddress()\n\t    // Addresses\n\t    const ownerAddress = address\n\t    const newOwner = randomAddress()\n\t    const nft = randomAddress()\n\t    // Creates NFT Item Instance\n\t    const nftItem = client.open(\n\t        await NftItem.createFromAddress(\n\t            nft\n\t        )\n", "    )\n\t    // Transfers Nft\n\t    const result = await nftItem.sendTransfer(\n\t        wallet,\n\t        {\n\t            value: toNano(1),\n\t            queryId: BigInt(1),\n\t            newOwner: newOwner,\n\t            responseDestination: ownerAddress,\n\t            forwardAmount: toNano(0)\n", "        }\n\t    )\n\t    // Prints Result\n\t    console.log(result)\n\t    // Fetches Nft Data\n\t    const nftData = await nftItem.getNftData()\n\t    // Prints Nft Data\n\t    console.log(nftData)    \n\t}\n\tmain()"]}
{"filename": "examples/transaction-parsing.ts", "chunked_list": ["import {Address} from 'ton-core'\n\timport {NftItem} from '../src/wrappers/standard/NftItem'\n\timport { TonClient } from 'ton'\n\timport { getHttpEndpoint } from '@orbs-network/ton-access'\n\tasync function main() {\n\t    // Config\n\t    const client = new TonClient({\n\t        endpoint: await getHttpEndpoint()\n\t    })\n\t    // Transfer TX\n", "    const txData = await client.getTransactions(Address.parse('EQCWbV3k8hlLGiFlxPE_RAJDLUpm_WnCCbCxaprvWxh1_AOI'), {\n\t        limit: 10,\n\t        hash: 'odtysMOr5JY0JQ+31TtmzGzldPBH2IMTIL21CAiJ9G8='\n\t    })\n\t    console.log(txData)\n\t    const data = NftItem.parseTransfer(txData[0])\n\t    // Prints Transaction Data\n\t    console.log(data)\n\t}\n\tmain()"]}
{"filename": "examples/mintNft.ts", "chunked_list": ["import {Address, toNano} from 'ton-core'\n\timport {NftCollection} from '../src/wrappers/getgems/NftCollection/NftCollection'\n\timport {randomAddress, importKeyPair, createSender} from '../src/utils'\n\timport {ENDPOINT} from '../src'\n\timport { TonClient4 } from 'ton'\n\timport { Storage } from '../src/storage'\n\timport { Pinata } from '../src/storage/Pinata'\n\tasync function main() {\n\t    // Config\n\t    const keypair = await importKeyPair('')\n", "    const client = new TonClient4({endpoint: ENDPOINT.TESTNET})\n\t    const wallet = await createSender(keypair, client)\n\t    const address = wallet.address ?? randomAddress()\n\t    // Addresses\n\t    const ownerAddress = address\n\t    const collectionAddress = Address.parse('')\n\t    // Deploying Assets\n\t    const pinata = new Pinata('<apiKey>', '<secretApiKey>')\n\t    const storage = new Storage(pinata)\n\t    const data: [string[], string[]] = await storage.uploadBulk('./assets')\n", "    // Creates NFT Item\n\t    const nftCollection = client.open(\n\t        await NftCollection.createFromAddress(\n\t            collectionAddress\n\t        )\n\t    )\n\t    // Mints NFT\n\t    const mintResult = await nftCollection.sendMint(\n\t        wallet,\n\t        {\n", "            queryId: 1,\n\t            value: toNano(1),\n\t            passAmount: toNano(1),\n\t            itemIndex: 0,\n\t            itemOwnerAddress: ownerAddress,\n\t            itemContent: data[1][0]\n\t        }\n\t    )\n\t    // Prints Result\n\t    console.log(mintResult)\n", "    // Fetches Nft Data\n\t    const collectionData = await nftCollection.getCollectionData()\n\t    // Prints Nft Data\n\t    console.log(collectionData)    \n\t}\n\tmain()"]}
{"filename": "src/index.ts", "chunked_list": ["// Storage\n\timport {AmazonS3} from './storage/AmazonS3'\n\timport {Pinata} from './storage/Pinata'\n\t// Wrappers\n\texport * from './wrappers/getgems/NftCollection/NftCollection'\n\texport * from './wrappers/getgems/NftItem/NftItem'\n\texport * from './wrappers/getgems/SbtSingle/SbtSingle'\n\texport * from './wrappers/standard/NftItemRoyalty'\n\texport * from './wrappers/getgems/NftAuction/NftAuction'\n\texport * from './wrappers/getgems/NftAuctionV2/NftAuctionV2'\n", "export * from './wrappers/getgems/NftFixedPrice/NftFixedPrice'\n\texport * from './wrappers/getgems/NftFixedPriceV2/NftFixedPriceV2'\n\texport * from './wrappers/getgems/NftFixedPriceV3/NftFixedPriceV3'\n\texport * from './wrappers/getgems/NftMarketplace/NftMarketplace'\n\texport * from './wrappers/getgems/NftOffer/NftOffer'\n\texport * from './wrappers/getgems/NftSwap/NftSwap'\n\t// Utils\n\texport * from './utils'\n\t// Data Encoders & Decoders\n\texport * from './types/Content'\n", "// Transaction Parsing\n\texport * as TransactionParsing from './transaction-parsing/'\n\texport {\n\t    AmazonS3, \n\t    Pinata\n\t}\n\texport {Storage} from './storage'\n\t// TON API\n\texport * from './ton-api'\n\t// Endpoints\n", "export enum ENDPOINT {\n\t    MAINNET = 'https://toncenter.com/api/v2/jsonRPC',\n\t    TESTNET = 'https://testnet.toncenter.com/api/v2/jsonRPC'\n\t}"]}
{"filename": "src/utils/createTempFile.ts", "chunked_list": ["import {uuid} from './uuid'\n\timport * as os from 'os'\n\timport path from 'path'\n\timport {writeFile, unlink} from 'fs/promises'\n\texport async function createTempFile(ext: string) {\n\t    const name = uuid()\n\t    const fullPath = path.resolve(os.tmpdir(), name + ext)\n\t    await writeFile(fullPath, Buffer.alloc(0))\n\t    return {\n\t        name: fullPath,\n", "        destroy: async  () => {\n\t            await unlink(fullPath)\n\t        }\n\t    }\n\t}\n"]}
{"filename": "src/utils/EligibleInternalTx.ts", "chunked_list": ["import { Transaction } from 'ton-core'\n\texport function isEligibleTransaction(tx: Transaction): boolean {\n\t    return (\n\t        tx.inMessage?.info.type == 'internal' &&\n\t        tx.description.type == 'generic' &&\n\t        tx.description.computePhase.type == 'vm' &&\n\t        tx.description.computePhase.exitCode == 0\n\t    )\n\t}"]}
{"filename": "src/utils/createSender.ts", "chunked_list": ["import { KeyPair } from \"ton-crypto\";\n\timport { TonClient4, WalletContractV4 } from \"ton\";\n\texport async function createSender(\n\t    keypair: KeyPair,\n\t    client: TonClient4\n\t) {\n\t    let wallet = WalletContractV4.create(\n\t        {\n\t            workchain: 0,\n\t            publicKey: keypair.publicKey\n", "        }\n\t    )\n\t    let contract = client.open(\n\t        wallet\n\t    );\n\t    return contract.sender(keypair.secretKey);\n\t}\n\texport default createSender;"]}
{"filename": "src/utils/randomKeyPair.ts", "chunked_list": ["import {mnemonicNew, mnemonicToPrivateKey} from \"ton-crypto\";\n\texport async function randomKeyPair() {\n\t    let mnemonics = await mnemonicNew()\n\t    return mnemonicToPrivateKey(mnemonics)\n\t}"]}
{"filename": "src/utils/importKeyPair.ts", "chunked_list": ["import { env } from 'process'\n\timport { KeyPair, keyPairFromSecretKey } from \"ton-crypto\"\n\timport { readFileSync } from 'fs';\n\texport async function importKeyPair(\n\t    secretKey?: string\n\t) {\n\t    let keyPair: KeyPair;\n\t    if (secretKey) {\n\t        keyPair = keyPairFromSecretKey(Buffer.from(secretKey, 'hex'));\n\t    } else {\n", "        const content = readFileSync(String(env.SECRET_KEY), 'utf-8');\n\t        keyPair = keyPairFromSecretKey(Buffer.from(content, 'hex'));\n\t    }\n\t    return keyPair;\n\t}\n\texport default importKeyPair;"]}
{"filename": "src/utils/uuid.ts", "chunked_list": ["import {v4} from 'uuid'\n\texport const uuid = () => v4()"]}
{"filename": "src/utils/createKeyPair.ts", "chunked_list": ["import { writeFileSync } from \"fs\";\n\timport {mnemonicNew, mnemonicToPrivateKey} from \"ton-crypto\"\n\texport async function createKeyPair() {\n\t    let mnemonic = await mnemonicNew()\n\t    let keypair = await mnemonicToPrivateKey(mnemonic)\n\t    writeFileSync(\n\t        \"./keypair.json\",\n\t        JSON.stringify(keypair)\n\t    );\n\t    writeFileSync(\n", "        \"./.env\",\n\t        `SECRET_KEY=${keypair.secretKey}`\n\t    )\n\t}\n\texport default createKeyPair;"]}
{"filename": "src/utils/randomAddress.ts", "chunked_list": ["import {Address} from \"ton-core\";\n\timport {pseudoRandomBytes} from \"crypto\";\n\texport function randomAddress() {\n\t    return new Address(0, pseudoRandomBytes(256/8))\n\t}"]}
{"filename": "src/utils/index.ts", "chunked_list": ["export * from './EligibleInternalTx'\n\texport * from './createTempFile'\n\texport * from './randomAddress'\n\texport * from './randomKeyPair'\n\texport * from './uuid'\n\texport * from './importKeyPair'\n\texport * from './createSender'"]}
{"filename": "src/storage/index.ts", "chunked_list": ["export class Storage {\n\t    constructor(\n\t        readonly provider: ProviderInterface\n\t    ) {}\n\t    // Function to upload images\n\t    async uploadImage(\n\t        imagePath: string\n\t    ): Promise<string> {\n\t        return await this.provider.uploadImage(imagePath)\n\t    }\n", "    // Function to upload multiple images\n\t    async uploadImages(\n\t        folderPath: string\n\t    ): Promise<string[]> {\n\t        return await this.provider.uploadImages(folderPath)\n\t    }\n\t    // Function to upload json file\n\t    async uploadJson(\n\t        jsonPath: string\n\t    ): Promise<string> {\n", "        return await this.provider.uploadJson(jsonPath)\n\t    }\n\t    // Function to upload multiple json files\n\t    async uploadJsonBulk(\n\t        folderPath: string\n\t    ): Promise<string[]> {\n\t        return await this.provider.uploadJsonBulk(folderPath)\n\t    }\n\t    // Function to upload multiple json files\n\t    async uploadBulk(\n", "        assetsFolderPath: string\n\t    ): Promise<[string[], string[]]> {\n\t        return await this.provider.uploadBulk(assetsFolderPath)\n\t    }\n\t}\n\texport interface ProviderInterface {\n\t    uploadImage: (imagePath: string) => Promise<string>\n\t    uploadImages: (folderPath: string) => Promise<string[]>\n\t    uploadJson: (jsonPath: string) => Promise<string>\n\t    uploadJsonBulk: (folderPath: string) => Promise<string[]>\n", "    uploadBulk: (assetsFolderPath: string) => Promise<[string[], string[]]>\n\t}"]}
{"filename": "src/storage/Pinata.ts", "chunked_list": ["import PinataClient from '@pinata/sdk'\n\timport { error } from 'console'\n\timport fs from 'fs'\n\timport path from 'path'\n\timport { ProviderInterface } from '.'\n\t/**\n\t * Pinata is a class that provides utility functions for interacting with Pinata for IPFS integration.\n\t */\n\texport class Pinata implements ProviderInterface {\n\t    private pinata: PinataClient\n", "    /**\n\t     * Creates an instance of the Pinata class.\n\t     * @param apiKey - The API key for Pinata.\n\t     * @param secretApiKey - The secret API key for Pinata.\n\t     */\n\t    constructor (\n\t        apiKey: string,\n\t        secretApiKey: string,\n\t    ) {\n\t        this.pinata = new PinataClient(apiKey, secretApiKey)\n", "    }\n\t    /**\n\t     * Uploads an image file to IPFS using Pinata SDK.\n\t     * @param imagePath - The path to the image file to be uploaded.\n\t     * @returns A Promise that resolves to the URL of the uploaded image on IPFS.\n\t     */\n\t    async uploadImage(imagePath: string): Promise<string> {\n\t        const fileContent = fs.createReadStream(imagePath)\n\t        const response = await this.pinata.pinFileToIPFS(fileContent)\n\t        return `https://gateway.pinata.cloud/ipfs/${response.IpfsHash}`\n", "    }\n\t    /**\n\t     * Uploads multiple image files from a folder to IPFS using Pinata SDK.\n\t     * @param folderPath - The path to the folder containing the image files.\n\t     * @returns A Promise that resolves to an array of URLs of the uploaded images on IPFS.\n\t     */\n\t    async uploadImages(folderPath: string): Promise<string[]> {\n\t        const files = fs.readdirSync(folderPath)\n\t        const uploadPromises = files.map(file => this.uploadImage(path.join(folderPath, file)))\n\t        return Promise.all(uploadPromises)\n", "    }\n\t    /**\n\t     * Uploads a JSON file to IPFS using Pinata SDK.\n\t     * @param jsonPath - The path to the JSON file to be uploaded.\n\t     * @returns A Promise that resolves to the URL of the uploaded JSON file on IPFS.\n\t     */\n\t    async uploadJson(jsonPath: string): Promise<string> {\n\t        const fileContent = fs.readFileSync(jsonPath)\n\t        const jsonData = JSON.parse(fileContent.toString())\n\t        const response = await this.pinata.pinJSONToIPFS(jsonData)\n", "        return `https://gateway.pinata.cloud/ipfs/${response.IpfsHash}`\n\t    }\n\t    /**\n\t     * Uploads multiple JSON files from a folder to IPFS using Pinata SDK.\n\t     * @param folderPath - The path to the folder containing the JSON files.\n\t     * @returns A Promise that resolves to an array of URLs of the uploaded JSON files on IPFS.\n\t     */\n\t    async uploadJsonBulk(folderPath: string): Promise<string[]> {\n\t        const files = fs.readdirSync(folderPath)\n\t        const uploadPromises = files.map(file => this.uploadJson(path.join(folderPath, file)))\n", "        return Promise.all(uploadPromises)\n\t    }\n\t    /**\n\t     * Uploads images in bulk to IPFS using Pinata SDK in ascending order of file names and returns their URLs.\n\t     * @param assetsFolderPath - The path to the folder containing the image and JSON files.\n\t     * @returns A Promise that resolves to an array of two arrays:\n\t     * - The first array contains the URLs of the uploaded images on IPFS.\n\t     * - The second array contains the URLs of the uploaded JSON files on IPFS.\n\t     */\n\t    async uploadBulk(\n", "        assetsFolderPath: string\n\t    ): Promise<[string[], string[]]> {\n\t        try {\n\t            // Read the directory\n\t            const files = fs.readdirSync(assetsFolderPath)\n\t            // Filter and sort image files\n\t            const imageFiles = files\n\t                .filter((file) => /\\.(jpg|jpeg|png|gif)$/i.test(file))\n\t                .sort((a, b) => parseInt(a) - parseInt(b))\n\t            // Process image uploads in ascending order and collect their URLs\n", "            const imageUrls: string[] = []\n\t            const jsonUrls: string[] = []\n\t            for (const imageFile of imageFiles) {\n\t                // Read image file\n\t                const imagePath = path.join(assetsFolderPath, imageFile)\n\t                const imageData = fs.createReadStream(imagePath)\n\t                // Upload the image to IPFS using Pinata SDK\n\t                const result = await this.pinata.pinFileToIPFS(imageData, {\n\t                    pinataMetadata: {\n\t                        name: imageFile,\n", "                    },\n\t                })\n\t                // Add the image URL to the array\n\t                const ipfsUrl = `https://gateway.pinata.cloud/ipfs/${result.IpfsHash}`\n\t                imageUrls.push(ipfsUrl)\n\t                // Read the JSON file with the same filename as the image\n\t                const jsonFilePath = path.join(\n\t                    assetsFolderPath,\n\t                    `${path.parse(imageFile).name}.json`\n\t                )\n", "                if (fs.existsSync(jsonFilePath)) {\n\t                    const jsonFile = fs.readFileSync(jsonFilePath, 'utf8')\n\t                    const jsonData = JSON.parse(jsonFile)\n\t                    // Add the IPFS URL to the JSON data\n\t                    jsonData.image = ipfsUrl\n\t                    // Write the updated JSON data to the file\n\t                    fs.writeFileSync(jsonFilePath, JSON.stringify(jsonData))\n\t                    // Upload the JSON file to IPFS using Pinata SDK\n\t                    const jsonFileData = fs.createReadStream(\n\t                        jsonFilePath\n", "                    )\n\t                    const jsonResult = await this.pinata.pinFileToIPFS(jsonFileData, {\n\t                        pinataMetadata: {\n\t                            name: `${path.parse(imageFile).name}.json`,\n\t                        },\n\t                    })\n\t                    const jsonUrl = `https://gateway.pinata.cloud/ipfs/${jsonResult.IpfsHash}`\n\t                    jsonUrls.push(jsonUrl)\n\t                    console.log(`JSON file uploaded to IPFS: ${jsonUrl}`)\n\t                } else {\n", "                    error('Metadata not found for', path.parse(imageFile).name)\n\t                }\n\t            }\n\t            console.log('All images uploaded successfully!')\n\t            return [imageUrls, jsonUrls]\n\t        } catch (error) {\n\t            console.error('Error uploading images to IPFS:', error)\n\t            throw error\n\t        }            \n\t    }\n", "}\n"]}
{"filename": "src/storage/AmazonS3.ts", "chunked_list": ["import { S3 } from 'aws-sdk'\n\timport { error } from 'console'\n\timport fs from 'fs'\n\timport path from 'path'\n\timport {ProviderInterface} from './'\n\t/**\n\t * AmazonS3 is a class that provides utility functions for interacting with Amazon S3.\n\t */\n\texport class AmazonS3 implements ProviderInterface {\n\t    public s3: S3\n", "    /**\n\t     * Creates an instance of the AmazonS3 class.\n\t     * @param accessKeyId - The access key ID for your AWS account.\n\t     * @param secretAccessKey - The secret access key for your AWS account.\n\t     */\n\t    constructor (\n\t        accessKeyId: string,\n\t        secretAccessKey: string,\n\t        readonly bucketName: string\n\t    ) {\n", "        this.s3 = new S3(\n\t            {\n\t                accessKeyId: accessKeyId,\n\t                secretAccessKey: secretAccessKey,\n\t            }\n\t        )\n\t    }\n\t    /**\n\t     * Uploads an image file to an S3 bucket.\n\t     * @param imagePath - The path to the image file to be uploaded.\n", "     * @returns A Promise that resolves to the URL of the uploaded image.\n\t     */\n\t    async uploadImage(\n\t        imagePath: string\n\t    ): Promise<string> {\n\t        const fileContent = fs.readFileSync(imagePath)\n\t        const params = {\n\t            Bucket: this.bucketName, // Set the bucket name passed as an option or use the default bucket name\n\t            Key: path.basename(imagePath), // File name you want to save as in S3\n\t            Body: fileContent,\n", "            ContentType: 'image/jpeg', // adjust as needed\n\t        }\n\t        await this.s3.upload(params).promise()\n\t        return `https://${this.bucketName}.s3.amazonaws.com/${params.Key}`\n\t    }\n\t    /**\n\t     * Uploads multiple image files from a folder to an S3 bucket.\n\t     * @param folderPath - The path to the folder containing the image files.\n\t     * @returns A Promise that resolves to an array of URLs of the uploaded images.\n\t     */\n", "    async uploadImages(\n\t        folderPath: string\n\t    ): Promise<string[]> {\n\t        const files = fs.readdirSync(folderPath)\n\t        const uploadPromises = files.map(file => this.uploadImage(path.join(folderPath, file)))\n\t        return Promise.all(uploadPromises)\n\t    }\n\t    /**\n\t     * Uploads a JSON file to an S3 bucket.\n\t     * @param jsonPath - The path to the JSON file to be uploaded.\n", "     * @returns A Promise that resolves to the URL of the uploaded JSON file.\n\t     */\n\t    async uploadJson(\n\t        jsonPath: string\n\t    ): Promise<string> {\n\t        const fileContent = fs.readFileSync(jsonPath)\n\t        const params = {\n\t            Bucket: this.bucketName,\n\t            Key: path.basename(jsonPath), // File name you want to save as in S3\n\t            Body: fileContent,\n", "            ContentType: 'application/json', // JSON file mimetype\n\t        }\n\t        await this.s3.upload(params).promise()\n\t        return `https://${this.bucketName}.s3.amazonaws.com/${params.Key}`\n\t    }\n\t    /**\n\t     * Uploads multiple JSON files from a folder to an S3 bucket.\n\t     * @param folderPath - The path to the folder containing the JSON files.\n\t     * @returns A Promise that resolves to an array of URLs of the uploaded JSON files.\n\t     */\n", "    async uploadJsonBulk(\n\t        folderPath: string\n\t    ): Promise<string[]> {\n\t        const files = fs.readdirSync(folderPath)\n\t        const uploadPromises = files.map(file => this.uploadJson(path.join(folderPath, file)))\n\t        return Promise.all(uploadPromises)\n\t    }\n\t    /**\n\t     * Uploads images in bulk to IPFS using Pinata SDK in ascending order of file names and returns their URLs.\n\t     * @param assetsFolderPath - The path to the folder containing the image and JSON files.\n", "     * @returns A Promise that resolves to an array of two arrays:\n\t     * - The first array contains the URLs of the uploaded images on IPFS.\n\t     * - The second array contains the URLs of the uploaded JSON files on IPFS.\n\t     */\n\t    async uploadBulk(\n\t        assetsFolderPath: string\n\t    ): Promise<[string[], string[]]> {\n\t        try {\n\t            // Read the directory\n\t            const files = fs.readdirSync(assetsFolderPath)\n", "            // Filter and sort image files\n\t            const imageFiles = files\n\t                .filter((file) => /\\.(jpg|jpeg|png|gif)$/i.test(file))\n\t                .sort((a, b) => parseInt(a) - parseInt(b))\n\t            // Process image uploads in ascending order and collect their URLs\n\t            const imageUrls: string[] = []\n\t            const jsonUrls: string[] = []\n\t            for (const imageFile of imageFiles) {\n\t                // Read image file\n\t                const imagePath = path.join(assetsFolderPath, imageFile)\n", "                // Upload the image to S3\n\t                const imageUrl = await this.uploadImage(imagePath)\n\t                imageUrls.push(imageUrl)\n\t                // Read the JSON file with the same filename as the image\n\t                const jsonFilePath = path.join(\n\t                    assetsFolderPath,\n\t                    `${path.parse(imageFile).name}.json`\n\t                )\n\t                if (fs.existsSync(jsonFilePath)) {\n\t                    // Upload the JSON file to S3\n", "                    const jsonUrl = await this.uploadJson(jsonFilePath)\n\t                    jsonUrls.push(jsonUrl)\n\t                    console.log(`JSON file uploaded to S3: ${jsonUrl}`)\n\t                } else {\n\t                    error('Metadata not found for', path.parse(imageFile).name)\n\t                }\n\t            }\n\t            console.log('All images uploaded successfully!')\n\t            return [imageUrls, jsonUrls]\n\t        } catch (error) {\n", "            console.error('Error uploading images to S3:', error)\n\t            throw error\n\t        }\n\t    }    \n\t}"]}
{"filename": "src/ton-api/TonAPI.ts", "chunked_list": ["import { Address, Transaction } from 'ton-core'\n\timport {ClientInterface} from './'\n\t/**\n\t * Class representing a TON API client.\n\t */\n\texport class TonAPI implements ClientInterface {\n\t    private url: string\n\t    /**\n\t     * Create a new TON API client.\n\t     * @param {string} [url] - The base URL for the TON API. Default is 'https://tonapi.io'.\n", "     */\n\t    constructor(url?: string) {\n\t        this.url = url ? url : 'https://tonapi.io'\n\t    }\n\t    /**\n\t     * Fetch NFT collections.\n\t     * @param {number} [limit] - The maximum number of collections to fetch.\n\t     * @param {number} [offset] - The offset to start fetching from.\n\t     */\n\t    async getNftCollections(\n", "        limit?: number,\n\t        offset?: number,\n\t    ) {\n\t        const response = await request(\n\t            `${this.url}/v2/nfts/collections?limit=${limit}&offset=${offset}`,\n\t            {\n\t                method: 'GET',\n\t                headers: {\n\t                    'Content-Type': 'application/json',\n\t                },\n", "            }\n\t        )\n\t        return response\n\t    }\n\t    /**\n\t     * Fetch an NFT collection by its address.\n\t     * @param {string} collectionAddress - The address of the collection to fetch.\n\t     */\n\t    async getNftCollection(\n\t        collectionAddress: string,\n", "    ) {\n\t        const response = await request(\n\t            `${this.url}/v2/nfts/collections/${collectionAddress}`,\n\t            {\n\t                method: 'GET',\n\t                headers: {\n\t                    'Content-Type': 'application/json',\n\t                },\n\t            }\n\t        )\n", "        return response\n\t    }\n\t    /**\n\t     * Fetch NFT items from a collection by the collection's address.\n\t     * @param {string} collectionAddress - The address of the collection to fetch items from.\n\t     * @param {number} [limit] - The maximum number of items to fetch.\n\t     * @param {number} [offset] - The offset to start fetching from.\n\t     */\n\t    async getNftItems(\n\t        collectionAddress: string,\n", "        limit?: number,\n\t        offset?: number,\n\t    ) {\n\t        const response = await request(\n\t            `${this.url}/v2/nfts/collections/${collectionAddress}/items?limit=${limit}&offset=${offset}`,\n\t            {\n\t                method: 'GET',\n\t                headers: {\n\t                    'Content-Type': 'application/json',\n\t                },\n", "            }\n\t        )\n\t        return response\n\t    }\n\t    /**\n\t     * Fetch an NFT item by its address.\n\t     * @param {string} itemAddress - The address of the item to fetch.\n\t     */\n\t    async getNftItem(\n\t        itemAddress: string,\n", "    ) {\n\t        const response = await request(\n\t            `${this.url}/v2/nfts/${itemAddress}`,\n\t            {\n\t                method: 'GET',\n\t                headers: {\n\t                    'Content-Type': 'application/json',\n\t                },\n\t            }\n\t        )\n", "        return response\n\t    }\n\t    /**\n\t     * Fetch transactions by address.\n\t     * @param {Address} address - The address to fetch transactions for.\n\t     * @param {number} limit - The maximum number of transactions to fetch.\n\t     * @returns {Promise<any>} A promise resolving with the fetched transactions.\n\t     */\n\t    async getTransactionsByAddress(\n\t        address: Address,\n", "        limit?: number\n\t    ) {\n\t        const response = await request(\n\t            `${this.url}/v1/blockchain/getTransactions?account=${address.toString()}&limit=${limit}`,\n\t            {\n\t                method: 'GET',\n\t                headers: {\n\t                    'Content-Type': 'application/json',\n\t                },\n\t            }\n", "        )\n\t        return response\n\t    }\n\t    /**\n\t     * Fetch transaction data.\n\t     * @param {string} transactionId - The ID of the transaction to fetch data for.\n\t     * @returns {Promise<Transaction>} A promise resolving with the fetched transaction data.\n\t     */\n\t    async getTransactionData(\n\t        transactionId: string\n", "    ): Promise<Transaction> {\n\t        const response: Transaction = await request(\n\t            `${this.url}/v2/blockchain/transactions/${transactionId}`,\n\t            {\n\t                method: 'GET',\n\t                headers: {\n\t                    'Content-Type': 'application/json',\n\t                },\n\t            }\n\t        )\n", "        return response\n\t    }\n\t}\n\t/**\n\t * Send a request to a URL and return the response as JSON.\n\t * @template TResponse The expected shape of the response body.\n\t * @param {string} url - The URL to send the request to.\n\t * @param {RequestInit} config - The configuration options for the request.\n\t * @returns {Promise<TResponse>} A promise resolving with the response body.\n\t */\n", "async function request<TResponse>(\n\t    url: string, \n\t    config: RequestInit\n\t): Promise<TResponse> {\n\t    const response = await fetch(url, config)\n\t    return (await response.json()) as TResponse\n\t}"]}
{"filename": "src/ton-api/index.ts", "chunked_list": ["import { Address } from 'ton-core'\n\texport class TonNftClient {\n\t    constructor(\n\t        readonly client: ClientInterface\n\t    ) {}\n\t    async getNftCollections(\n\t        limit?: number,\n\t        offset?: number,\n\t    ) {\n\t        return await this.client.getNftCollections(limit, offset)\n", "    }\n\t    async getNftCollection(\n\t        collectionAddress: string,\n\t    ) {\n\t        return await this.client.getNftCollection(collectionAddress)\n\t    }\n\t    async getNftItems(\n\t        collectionAddress: string,\n\t        limit?: number,\n\t        offset?: number,\n", "    ) {\n\t        return await this.client.getNftItems(collectionAddress, limit, offset)\n\t    }\n\t    async getNftItem(\n\t        itemAddress: string,\n\t    ) {\n\t        return await this.client.getNftItem(itemAddress)\n\t    }\n\t    async getTransactionsByAddress(\n\t        address: Address,\n", "        limit?: number\n\t    ) {\n\t        return await this.client.getTransactionsByAddress(address, limit)\n\t    }\n\t}\n\texport interface ClientInterface {\n\t    getNftCollections: (limit?: number, offset?: number) => Promise<unknown>\n\t    getNftCollection: (collectionAddress: string) => Promise<unknown>\n\t    getNftItems: (collectionAddress: string, limit?: number, offset?: number) => Promise<unknown>\n\t    getNftItem: (itemAddress: string) => Promise<unknown>\n", "    getTransactionsByAddress: (address: Address, limit?: number) => Promise<unknown>\n\t}"]}
{"filename": "src/wrappers/getgems/NftAuction/NftAuction.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\n\t/**\n\t * Class representing an NFT auction contract.\n\t */\n\texport class NftAuction implements Contract {\n\t    /**\n\t     * Creates an `NftAuction` instance from an address and initialization data.\n\t     * @param address - The address of the contract.\n\t     * @param init - The initialization data.\n\t     * @returns A new `NftAuction` instance.\n", "     */\n\t    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\t    static code = Cell.fromBoc(Buffer.from('te6cckECLgEABqIAART/APSkE/S88sgLAQIBIAIDAgFIBAUCKPIw2zyBA+74RMD/8vL4AH/4ZNs8LBkCAs4GBwIBIBwdAgEgCAkCASAaGwT1DPQ0wMBcbDyQPpAMNs8+ENSEMcF+EKwwP+Oz1vTHyHAAI0EnJlcGVhdF9lbmRfYXVjdGlvboFIgxwWwjoNb2zzgAcAAjQRZW1lcmdlbmN5X21lc3NhZ2WBSIMcFsJrUMNDTB9QwAfsA4DDg+FdSEMcFjoQxAds84PgjgLBEKCwATIIQO5rKAAGphIAFcMYED6fhW10nCAvLygQPqAdMfghAFE42REroS8vSAQNch+kAw+HZw+GJ/+GTbPBkESPhTvo8GbCHbPNs84PhCwP+OhGwh2zzg+FZSEMcF+ENSIMcFsRcRFwwEeI+4MYED6wLTHwHDABPy8otmNhbmNlbIUiDHBY6DIds83otHN0b3CBLHBfhWUiDHBbCPBNs82zyRMOLgMg0XEQ4B9oED7ItmNhbmNlbIEscFs/Ly+FHCAI5FcCCAGMjLBfhQzxb4UfoCy2rLH40KVlvdXIgYmlkIGhhcyBiZWVuIG91dGJpZCBieSBhbm90aGVyIHVzZXIugzxbJcvsA3nAg+CWCEF/MPRTIyx/LP/hWzxb4Vs8WywAh+gLLAA8BBNs8EAFMyXGAGMjLBfhXzxZw+gLLasyCCA9CQHD7AsmDBvsAf/hif/hm2zwZBPSBA+34QsD/8vL4U/gjuY8FMNs82zzg+E7CAPhOUiC+sI7V+FGORXAggBjIywX4UM8W+FH6Astqyx+NClZb3VyIGJpZCBoYXMgYmVlbiBvdXRiaWQgYnkgYW5vdGhlciB1c2VyLoM8WyXL7AN4B+HD4cfgj+HLbPOD4UxcRERICkvhRwACOPHAg+CWCEF/MPRTIyx/LP/hWzxb4Vs8WywAh+gLLAMlxgBjIywX4V88WcPoCy2rMgggPQkBw+wLJgwb7AOMOf/hi2zwTGQP8+FWh+CO5l/hT+FSg+HPe+FGOlIED6PhNUiC58vL4cfhw+CP4cts84fhR+E+gUhC5joMw2zzgcCCAGMjLBfhQzxb4UfoCy2rLH40KVlvdXIgYmlkIGhhcyBiZWVuIG91dGJpZCBieSBhbm90aGVyIHVzZXIugzxbJcvsAAfhwGRcYA/hwIPglghBfzD0UyMsfyz/4UM8W+FbPFssAggnJw4D6AssAyXGAGMjLBfhXzxaCEDuaygD6AstqzMly+wD4UfhI+EnwAyDCAJEw4w34UfhL+EzwAyDCAJEw4w2CCA9CQHD7AnAggBjIywX4Vs8WIfoCy2rLH4nPFsmDBvsAFBUWAHhwIIAYyMsF+EfPFlAD+gISy2rLH40H01hcmtldHBsYWNlIGNvbW1pc3Npb24gd2l0aGRyYXeDPFslz+wAAcHAggBjIywX4Ss8WUAP6AhLLassfjQbUm95YWx0eSBjb21taXNzaW9uIHdpdGhkcmF3gzxbJc/sAAC5QcmV2aW91cyBvd25lciB3aXRoZHJhdwCIcCCAGMjLBVADzxYh+gISy2rLH40J1lvdXIgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIGFjY2VwdGVkLoM8WyYBA+wABEPhx+CP4cts8GQDQ+Ez4S/hJ+EjI+EfPFssfyx/4Ss8Wyx/LH/hV+FT4U/hSyPhN+gL4TvoC+E/6AvhQzxb4UfoCyx/LH8sfyx/I+FbPFvhXzxbJAckCyfhG+EX4RPhCyMoA+EPPFsoAyh/KAMwSzMzJ7VQAESCEDuaygCphIAANFnwAgHwAYAIBIB4fAgEgJCUCAWYgIQElupFds8+FbXScEDknAg4PhW+kSCwBEa8u7Z58KH0iQCwCASAiIwEYqrLbPPhI+En4S/hMLAFeqCzbPIIIQVVD+EL4U/hD+Ff4VvhR+FD4T/hH+Ej4SfhK+Ev4TPhO+E34RfhS+EYsAgEgJicCAW4qKwEdt++7Z58JvwnfCf8KPwpwLAIBICgpARGwybbPPhK+kSAsARGxlvbPPhH+kSAsARGvK22efCH9IkAsASWsre2efCvrpOCByTgQcHwr/SJALAH2+EFu3e1E0NIAAfhi+kAB+GPSAAH4ZNIfAfhl0gAB+GbUAdD6QAH4Z9MfAfho0x8B+Gn6QAH4atMfAfhr0x8w+GzUAdD6AAH4bfoAAfhu+gAB+G/6QAH4cPoAAfhx0x8B+HLTHwH4c9MfAfh00x8w+HXUMND6QAH4dvpALQAMMPh3f/hhRQVNYw==', 'base64'))[0]\n\t    /**\n\t     * Builds the data cell for the auction contract.\n\t     * @param data - The data for building the data cell.\n\t     * @returns The built data cell.\n\t     */\n\t    static buildDataCell(data: NftAuctionData) {\n\t        const feesCell = beginCell()\n", "        feesCell.storeAddress(data.marketplaceFeeAddress)      // mp_fee_addr\n\t        feesCell.storeUint(data.marketplaceFeeFactor, 32)               // mp_fee_factor\n\t        feesCell.storeUint(data.marketplaceFeeBase, 32)   // mp_fee_base\n\t        feesCell.storeAddress(data.royaltyAddress)  // royalty_fee_addr\n\t        feesCell.storeUint(data.royaltyFactor, 32)              // royalty_fee_factor\n\t        feesCell.storeUint(data.royaltyBase, 32)   // royalty_fee_base\n\t        const bidsCell = beginCell()\n\t        bidsCell.storeCoins(data.minBid)       // min_bid\n\t        bidsCell.storeCoins(data.maxBid)       // max_bid\n\t        bidsCell.storeCoins(data.minStep)       // min_step\n", "        bidsCell.storeBuffer(Buffer.from([0,0]))        // last_member\n\t        bidsCell.storeCoins(0)       // last_bid\n\t        bidsCell.storeUint(0, 32) // last_bid_at\n\t        bidsCell.storeUint(data.endTimestamp, 32)    // end_time\n\t        bidsCell.storeUint(data.stepTimeSeconds, 32)               // step_time\n\t        bidsCell.storeUint(data.tryStepTimeSeconds, 32)               // try_step_time\n\t        const nftCell = beginCell()\n\t        if (data.nftOwnerAddress) {\n\t            nftCell.storeAddress(data.nftOwnerAddress)\n\t        } else {\n", "            nftCell.storeBuffer(Buffer.from([0, 0]))\n\t        }\n\t        nftCell.storeAddress(data.nftAddress)          // nft_addr\n\t        const storage = beginCell()\n\t        storage.storeBit(data.end)     // end?\n\t        storage.storeAddress(data.marketplaceAddress)   // mp_addr\n\t        storage.storeBit(data.activated)    // activated\n\t        storage.storeUint(data.createdAtTimestamp, 32)\n\t        storage.storeBit(false) // is_canceled\n\t        storage.storeRef(feesCell.endCell())\n", "        storage.storeRef(bidsCell.endCell())\n\t        storage.storeRef(nftCell.endCell())\n\t        return storage.endCell()\n\t    }\n\t    /**\n\t     * Creates an `NftAuction` instance from an address.\n\t     * @param address - The address to create from.\n\t     * @returns A new `NftAuction` instance.\n\t     */\n\t    static createFromAddress(\n", "        address: Address\n\t    ) {\n\t        return new NftAuction(\n\t            address\n\t        )\n\t    }\n\t    /**\n\t     * Creates an `NftAuction` instance from configuration data.\n\t     * @param config - The configuration data for creating the instance.\n\t     * @param workchain - The workchain ID (default: 0).\n", "     * @returns A new `NftAuction` instance.\n\t     */\n\t    static async createFromConfig(\n\t        config: NftAuctionData,\n\t        workchain = 0\n\t    ) {\n\t        const data = this.buildDataCell(config)\n\t        const address = contractAddress(\n\t            workchain,\n\t            {\n", "                code: this.code,\n\t                data: data\n\t            }\n\t        )\n\t        return new NftAuction(\n\t            address,\n\t            {\n\t                code: this.code,\n\t                data: data\n\t            }\n", "        )\n\t    }\n\t    /**\n\t     * Sends a deploy command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the deploy command.\n\t     * @param value - The value to send with the command.\n\t     */\n\t    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n\t        await provider.internal(via, {\n", "            value,\n\t            body: beginCell().endCell(),\n\t        })\n\t    }\n\t    /**\n\t     * Sends a cancel command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the cancel command.\n\t     * @param params - The parameters for the cancel command.\n\t     */\n", "    async sendCancel(provider: ContractProvider, via: Sender, params: { \n\t        value: bigint\n\t    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(0,32)\n\t                .storeBuffer(Buffer.from('cancel'))\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n", "        })\n\t    }\n\t    /**\n\t     * Sends a stop command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the stop command.\n\t     * @param params - The parameters for the stop command.\n\t     */\n\t    async sendStop(provider: ContractProvider, via: Sender, params: { \n\t        value: bigint\n", "    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(0,32)\n\t                .storeBuffer(Buffer.from('cancel'))\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n", "    /**\n\t     * Sends a repeat end auction command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the repeat end auction command.\n\t     * @param params - The parameters for the repeat end auction command.\n\t     */\n\t    async sendRepeatEndAuction(provider: ContractProvider, via: Sender, params: { \n\t        value: bigint\n\t    }) {\n\t        await provider.internal(via, {\n", "            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(0,32)\n\t                .storeBuffer(Buffer.from('repeat_end_auction'))\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t    /**\n\t     * Sends an emergency message to the contract.\n", "     * @param provider - The contract provider.\n\t     * @param via - The sender of the emergency message.\n\t     * @param params - The parameters for the emergency message.\n\t     */\n\t    async sendEmergencyMessage(provider: ContractProvider, via: Sender, params: { \n\t        value: bigint,\n\t        marketplaceAddress: Address,\n\t        coins: bigint\n\t    }) {\n\t        const transfer = beginCell()\n", "        transfer.storeUint(0x18, 6)\n\t        transfer.storeAddress(params.marketplaceAddress)\n\t        transfer.storeCoins(params.coins)\n\t        transfer.storeUint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)\n\t        transfer.storeRef(beginCell().storeUint(555,32).endCell())\n\t        const transferBox = beginCell()\n\t        transferBox.storeUint(2, 8)\n\t        transferBox.storeRef(transfer.endCell())\n\t        const msgResend = beginCell().storeUint(0, 32).storeBuffer(Buffer.from('emergency_message')).storeRef(transferBox.endCell()).endCell()\n\t        await provider.internal(via, {\n", "            value: params.value,\n\t            body: msgResend,\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t    /**\n\t     * Retrieves the sale data from the contract.\n\t     * @param provider - The contract provider.\n\t     * @returns The sale data.\n\t     */\n", "    async getSaleData(provider: ContractProvider) {\n\t        const { stack } = await provider.get('get_sale_data', [])\n\t        // pops out saleType\n\t        stack.pop()\n\t        return {\n\t            // saleType: stack.readBigNumber(),\n\t            end: stack.readBoolean(),\n\t            endTimestamp: stack.readBigNumber(),\n\t            marketplaceAddress: stack.readAddressOpt(),\n\t            nftAddress: stack.readAddressOpt(),\n", "            nftOwnerAddress: stack.readAddressOpt(),\n\t            lastBidAmount: stack.readBigNumber(),\n\t            lastBidAddress: stack.readAddressOpt(),\n\t            minStep: stack.readBigNumber(),\n\t            marketplaceFeeAddress: stack.readAddressOpt(),\n\t            marketplaceFeeFactor: stack.readBigNumber(), \n\t            marketplaceFeeBase: stack.readBigNumber(),\n\t            royaltyAddress: stack.readAddressOpt(),\n\t            royaltyFactor: stack.readBigNumber(), \n\t            royaltyBase: stack.readBigNumber(),\n", "            maxBid: stack.readBigNumber(),\n\t            minBid: stack.readBigNumber(),\n\t            createdAt: stack.readBigNumber(),\n\t            lastBidAt: stack.readBigNumber(),\n\t            isCanceled: stack.readBigNumber(),\n\t        }\n\t    }\n\t}\n\t/**\n\t * Type representing the data for an NFT auction contract version 2.\n", " */\n\texport type NftAuctionData = {\n\t    marketplaceFeeAddress: Address,\n\t    marketplaceFeeFactor: bigint,\n\t    marketplaceFeeBase: bigint,\n\t    royaltyAddress: Address,\n\t    royaltyFactor: bigint,\n\t    royaltyBase: bigint,\n\t    minBid: bigint,\n\t    maxBid: bigint,\n", "    minStep: bigint,\n\t    endTimestamp: number,\n\t    createdAtTimestamp: number,\n\t    stepTimeSeconds: number,\n\t    tryStepTimeSeconds: number,\n\t    nftOwnerAddress: Address | null,\n\t    nftAddress: Address,\n\t    end: boolean,\n\t    marketplaceAddress: Address,\n\t    activated: boolean,\n", "}"]}
{"filename": "src/wrappers/getgems/NftOffer/NftOffer.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\n\t/**\n\t * Class representing a Non-Fungible Token (NFT) Offer contract.\n\t */\n\texport class NftOffer implements Contract {\n\t    /**\n\t     * Constructs an instance of the NftOffer contract.\n\t     * @param address - The address of the contract.\n\t     * @param init - The initial code and data for the contract.\n\t     */\n", "    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\t    static code = Cell.fromBoc(Buffer.from('te6cckECFgEABEkAART/APSkE/S88sgLAQIBIAQCAVby7UTQ0wDTH9Mf+kD6QPpA+gDU0wAwMAfAAfLRlPgjJb7jAl8IggD//vLwAwDOB9MfgQ+jAsMAEvLygQ+kIddKwwDy8oEPpSHXSYEB9Lzy8vgAgggPQkBw+wJwIIAQyMsFJM8WIfoCy2rLHwHPFsmDBvsAcQdVBXAIyMsAF8sfFcsfUAPPFgHPFgHPFgH6AszLAMntVAIBSAYFAIOhRh/aiaGmAaY/pj/0gfSB9IH0AammAGBhofSBpj+mP/SBpj+mPmCo7CHgBqjuqeAGpQVCA0MEMJ6MjIqkHYACq4ECAswLBwP322ERFofSBpj+mP/SBpj+mPmBSs+AGqJCH4Aam4UJHQxbKDk3szS6QTrLgQQAhkZYKoAueLKAH9AQnltWWPgOeLZLj9gBFhABFrpOEBWEk2EPGGkGEASK3xhrgQQQgv5h6KZGWPieWfk2eLKAHni2UAQQRMS0B9AWUAZLjAoJCAB4gBjIywUmzxZw+gLLasyCCA9CQHD7AsmDBvsAcVVgcAjIywAXyx8Vyx9QA88WAc8WAc8WAfoCzMsAye1UAEyLlPZmZlciBmZWWHAggBDIywVQBc8WUAP6AhPLassfAc8WyXH7AABYi+T2ZmZXIgcm95YWxpZXOBNwIIAQyMsFUAXPFlAD+gITy2rLHwHPFslx+wACAUgPDAIBIA4NAB0IMAAk18DcOBZ8AIB8AGAAESCEDuaygCphIAIBIBEQABMghA7msoAAamEgAfcAdDTAwFxsJJfBOD6QDDtRNDTANMf0x/6QPpA+kD6ANTTADDAAY4lMTc3OFUzEnAIyMsAF8sfFcsfUAPPFgHPFgHPFgH6AszLAMntVOB/KscBwACOGjAJ0x8hwACLZjYW5jZWyFIgxwWwknMy3lCq3iCBAiu6KcABsFOmgEgLQxwWwnhCsXwzUMNDTB9QwAfsA4IIQBRONkVIQuuMCPCfAAfLRlCvAAFOTxwWwjis4ODlQdqAQN0ZQRAMCcAjIywAXyx8Vyx9QA88WAc8WAc8WAfoCzMsAye1U4Dc5CcAD4wJfCYQP8vAVEwGsU1jHBVNixwWx8uHKgggPQkBw+wJRUccFjhQ1cIAQyMsFKM8WIfoCy2rJgwb7AOMNcUcXUGYFBANwCMjLABfLHxXLH1ADzxYBzxYBzxYB+gLMywDJ7VQUALYF+gAhghAdzWUAvJeCEB3NZQAy3o0EE9mZmVyIGNhbmNlbCBmZWWBURzNwIIAQyMsFUAXPFlAD+gITy2rLHwHPFslx+wDUMHGAEMjLBSnPFnD6AstqzMmDBvsAAMYwCdM/+kAwU5THBQnAABmwK4IQO5rKAL6wnjgQWhBJEDhHFQNEZPAIjjg5XwYzM3AgghBfzD0UyMsfE8s/I88WUAPPFsoAIfoCygDJcYAYyMsFUAPPFnD6AhLLaszJgED7AOK1Lpfy', 'base64'))[0]\n\t    /**\n\t     * Builds the data cell for an NFT offer.\n\t     * @param data - The data for the NFT offer.\n\t     * @returns A cell containing the data for the NFT offer.\n\t     */\n\t    static buildDataCell(data: NftOfferData) {\n\t        const feesCell = beginCell()\n\t        feesCell.storeAddress(data.marketplaceFeeAddress)\n", "        feesCell.storeUint(data.marketplaceFactor, 32)\n\t        feesCell.storeUint(data.marketplaceBase, 32)\n\t        feesCell.storeAddress(data.royaltyAddress)\n\t        feesCell.storeUint(data.royaltyFactor, 32)\n\t        feesCell.storeUint(data.royaltyBase, 32)\n\t        const dataCell = beginCell()\n\t        dataCell.storeUint(data.isComplete ? 1 : 0, 1)\n\t        dataCell.storeUint(data.createdAt, 32)\n\t        dataCell.storeUint(data.finishAt, 32)\n\t        dataCell.storeAddress(data.marketplaceAddress)\n", "        dataCell.storeAddress(data.nftAddress)\n\t        dataCell.storeAddress(data.offerOwnerAddress)\n\t        dataCell.storeCoins(data.fullPrice) // fullPrice\n\t        dataCell.storeRef(feesCell)\n\t        dataCell.storeUint(1, 1) // can_deploy\n\t        return dataCell.endCell()\n\t    }\n\t    /**\n\t     * Creates an NftOffer instance from an address.\n\t     * @param address - The address to create from.\n", "     * @returns A new NftOffer instance.\n\t     */\n\t    static createFromAddress(\n\t        address: Address\n\t    ) {\n\t        return new NftOffer(\n\t            address\n\t        )\n\t    }\n\t    /**\n", "     * Creates an NftOffer instance from a configuration object.\n\t     * @param config - The configuration data for the NFT offer.\n\t     * @param workchain - The workchain ID (default is 0).\n\t     * @returns A new NftOffer instance.\n\t     */\n\t    static async createFromConfig(\n\t        config: NftOfferData,\n\t        workchain = 0\n\t    ) {\n\t        const data = this.buildDataCell(config)\n", "        const address = contractAddress(\n\t            workchain,\n\t            {\n\t                code: this.code,\n\t                data: data\n\t            }\n\t        )\n\t        return new NftOffer(\n\t            address,\n\t            {\n", "                code: this.code,\n\t                data: data\n\t            }\n\t        )\n\t    }\n\t    /**\n\t     * Sends a deploy command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the deploy command.\n\t     * @param value - The value to send with the command.\n", "     */\n\t    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n\t        await provider.internal(via, {\n\t            value,\n\t            body: beginCell().endCell(),\n\t        })\n\t    }\n\t    /**\n\t     * Sends a cancel offer command to the contract.\n\t     * @param provider - The contract provider.\n", "     * @param via - The sender of the cancel command.\n\t     * @param params - Parameters for the cancel command including optional message and value.\n\t     */\n\t    async sendCancelOffer(provider: ContractProvider, via: Sender, params: { \n\t        message?: string,\n\t        value: bigint\n\t    }) {\n\t        const nextPayload = beginCell()\n\t        if (params.message) {\n\t            nextPayload.storeUint(0, 32)\n", "            const m = Buffer.from(params.message.substring(0, 121), 'utf-8')\n\t            nextPayload.storeBuffer(m.slice(0, 121))\n\t        }\n\t        nextPayload.endCell()\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(0,32)\n\t                .storeBuffer(Buffer.from('cancel'))\n\t                .storeRef(nextPayload)\n", "                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t    /**\n\t     * Sends a cancel offer command to the contract by the marketplace.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the cancel command.\n\t     * @param params - Parameters for the cancel command including amount, optional message and value.\n\t     */\n", "    async sendCancelOfferByMarketplace(provider: ContractProvider, via: Sender, params: { \n\t        amount: bigint; \n\t        message?: string \n\t        value: bigint\n\t    }) {\n\t        const nextPayload = beginCell()\n\t        if (params.message) {\n\t            nextPayload.storeUint(0, 32)\n\t            const m = Buffer.from(params.message.substring(0, 121), 'utf-8')\n\t            nextPayload.storeBuffer(m.slice(0, 121))\n", "        }\n\t        nextPayload.endCell()\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(3,32)\n\t                .storeCoins(params.amount)\n\t                .storeRef(nextPayload)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n", "        })\n\t    }\n\t    /**\n\t     * Gets the data of the offer.\n\t     * @param provider - The contract provider.\n\t     * @returns The current data of the offer.\n\t     */\n\t    async getOfferData(provider: ContractProvider) {\n\t        const { stack } = await provider.get('get_offer_data', [])\n\t        return {\n", "            offerType: stack.readBigNumber(),\n\t            isComplete: stack.readBoolean(),\n\t            createdAt: stack.readBigNumber(),\n\t            finishAt: stack.readBigNumber(),\n\t            marketplaceAddress: stack.readAddress(),\n\t            nftAddress: stack.readAddress(),\n\t            offerOwnerAddress: stack.readAddress(),\n\t            fullPrice: stack.readBigNumber(),\n\t            marketplaceFeeAddress: stack.readAddress(),\n\t            marketplaceFactor: stack.readBigNumber(),\n", "            marketplaceBase: stack.readBigNumber(),\n\t            royaltyAddress: stack.readAddress(),\n\t            royaltyFactor: stack.readBigNumber(),\n\t            royaltyBase: stack.readBigNumber(),\n\t            profitPrice: stack.readBigNumber(),\n\t        }\n\t    }\n\t}\n\t/**\n\t * Type definition for the data of an NFT offer.\n", " */\n\texport type NftOfferData = {\n\t    isComplete: boolean\n\t    createdAt: number\n\t    finishAt: number\n\t    marketplaceAddress: Address\n\t    nftAddress: Address\n\t    offerOwnerAddress: Address\n\t    fullPrice: bigint\n\t    marketplaceFeeAddress: Address\n", "    royaltyAddress: Address\n\t    marketplaceFactor: number\n\t    marketplaceBase: number\n\t    royaltyFactor: number\n\t    royaltyBase: number\n\t}"]}
{"filename": "src/wrappers/getgems/SbtSingle/SbtSingle.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\n\timport { storeOffchainContent } from '../../../types/Content'\n\t/**\n\t * Represents a single item of the SBT (Soul Bound Token) NFT.\n\t * Implements the Contract interface.\n\t */\n\texport class SbtSingle implements Contract {\n\t    /**\n\t     * Constructs an instance of the SbtSingle contract.\n\t     * @param address - The address of the contract.\n", "     * @param init - Optional initialization data for the contract.\n\t     */\n\t    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\t    // Data\n\t    static code = Cell.fromBoc(Buffer.from('te6ccgECGQEABBgAART/APSkE/S88sgLAQIBYgIDAgLOBAUCASATFAIBIAYHAgEgERIB7QyIccAkl8D4NDTA/pA+kAx+gAxcdch+gAx+gAw8AID0x8DcbCOTBAkXwTTH4IQBSTHrhK6jjnTPzCAEPhCcIIQwY6G0lUDbYBAA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wCRMOLgAtM/gCAARPpEMHC68uFNgBPyCEC/LJqJSQLqOQDBsIjJwyMv/iwLPFoAQcIIQi3cXNUBVA4BAA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wDgghDQw7/qUkC64wKCEATe0UhSQLrjAoIQHARBKlJAuo6FM0AD2zzgNDSCEBoLnVFSILoJCgsMAMBsM/pA1NMAMPhFcMjL/1AGzxb4Qs8WEswUyz9SMMsAA8MAlvhDUAPMAt6AEHixcIIQDdYH40A1FIBAA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wAAyGwz+EJQA8cF8uGRAfpA1NMAMPhFcMjL//hCzxYTzBLLP1IQywABwwCU+EMBzN6AEHixcIIQBSTHrkBVA4BAA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wAB9PhBFMcF8uGR+kAh8AH6QNIAMfoAggr68IAXoSGUUxWgod4i1wsBwwAgkgahkTbiIML/8uGSIY49yPhBzxZQB88WgBCCEFEaRGMTcSZUSFADyMsfEss/IW6zkwHPF5Ex4slxBcjLBVAEzxZY+gITy2rMyQH7AJI2MOIDDQP+jhAxMvhBEscF8uGa1DD4Y/AD4DKCEB8EU3pSELqORzD4QiHHBfLhkYAQcIIQ1TJ220EEbYMGA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wCLAvhiiwL4ZPAD4IIQb4n141IQuuMCghDRNtOzUhC64wJsIQ4PEACAjjYi8AGAEIIQ1TJ22xRFA21xA8jLHxLLPyFus5MBzxeRMeLJcQXIywVQBM8WWPoCE8tqzMkB+wCSbDHi+GHwAwAuMDH4RAHHBfLhkfhFwADy4ZP4I/hl8AMAijD4QiHHBfLhkYIK+vCAcPsCgBBwghDVMnbbQQRtgwYDyMsfEss/IW6zkwHPF5Ex4slxBcjLBVAEzxZY+gITy2rMyQH7AAAgghBfzD0UupPywZ3ehA/y8AA3O1E0PpAAfhi+kAB+GHUAfhj+kAB+GTTPzD4ZYAAvPhF+EPI+ELPFvhBzxbM+ETPFss/ye1UgAgFYFRYAGbx+f4AT+4RYF8IXwhwADbVjHgBfCJACASAXGAANsB08AL4QYAANs2D8AL4RYA==', 'base64'))[0]\n\t    /**\n\t     * Builds a data cell for the SbtSingle contract.\n\t     * @param data - The data for the contract.\n\t     * @returns A data cell.\n\t     */\n", "    static buildDataCell(data: SbtSingleData) {\n\t        const dataCell= beginCell()\n\t        const contentCell = storeOffchainContent({\n\t            type: 'offchain',\n\t            uri: data.content\n\t        })\n\t        dataCell.storeAddress(data.ownerAddress)\n\t        dataCell.storeAddress(data.editorAddress)\n\t        dataCell.store(contentCell)\n\t        dataCell.storeAddress(data.authorityAddress)\n", "        dataCell.storeUint(data.revokedAt ? data.revokedAt : 0, 64)\n\t        return dataCell.endCell()\n\t    }\n\t    /**\n\t     * Constructs an instance of the SbtSingle contract from an address.\n\t     * @param address - The address of the contract.\n\t     * @returns An instance of SbtSingle.\n\t     */\n\t    static createFromAddress(\n\t        address: Address\n", "    ) {\n\t        return new SbtSingle(\n\t            address\n\t        )\n\t    }\n\t    /**\n\t     * Constructs an instance of the SbtSingle contract from a configuration object.\n\t     * @param config - The configuration object for the contract.\n\t     * @param workchain - The workchain ID (default is 0).\n\t     * @returns An instance of SbtSingle.\n", "     */\n\t    static async createFromConfig(\n\t        config: SbtSingleData,\n\t        workchain = 0\n\t    ) {\n\t        const data = this.buildDataCell(config)\n\t        const address = contractAddress(\n\t            workchain,\n\t            {\n\t                code: this.code,\n", "                data: data\n\t            }\n\t        )\n\t        return new SbtSingle(\n\t            address,\n\t            {\n\t                code: this.code,\n\t                data: data\n\t            }\n\t        )\n", "    }\n\t    /**\n\t     * Sends a deploy command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the deploy command.\n\t     * @param value - The value sent with the deploy command.\n\t     */\n\t    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n\t        await provider.internal(via, {\n\t            value,\n", "            body: beginCell().endCell(),\n\t        })\n\t    }\n\t    /**\n\t     * Sends a prove ownership command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the prove ownership command.\n\t     * @param params - The parameters for the prove ownership command, including value, queryId, dest, forwardPayload, and withContent.\n\t     */\n\t    async sendProveOwnership(provider: ContractProvider, via: Sender, params: {\n", "        value: bigint\n\t        queryId: bigint\n\t        dest: Address\n\t        forwardPayload?: Cell\n\t        withContent: boolean\n\t    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(0x04ded148, 32)\n", "                .storeUint(params.queryId, 64)\n\t                .storeAddress(params.dest)\n\t                .storeMaybeRef(params.forwardPayload)\n\t                .storeBit(params.withContent)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t    /**\n\t     * Sends a request owner command to the contract.\n", "     * @param provider - The contract provider.\n\t     * @param via - The sender of the request owner command.\n\t     * @param params - The parameters for the request owner command, including value, queryId, dest, forwardPayload, and withContent.\n\t     */\n\t    async sendRequestOwner(provider: ContractProvider, via: Sender, params: {\n\t        value: bigint\n\t        queryId: bigint\n\t        dest: Address\n\t        forwardPayload?: Cell\n\t        withContent: boolean\n", "    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(0xd0c3bfea, 32)\n\t                .storeUint(params.queryId, 64)\n\t                .storeAddress(params.dest)\n\t                .storeMaybeRef(params.forwardPayload)\n\t                .storeBit(params.withContent)\n\t                .endCell(),\n", "            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t    /**\n\t     * Sends a revoke command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the revoke command.\n\t     * @param params - The parameters for the revoke command, including value and queryId.\n\t     */\n\t    async sendRevoke(provider: ContractProvider, via: Sender, params: {\n", "        value: bigint\n\t        queryId: bigint\n\t    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(0x6f89f5e3, 32)\n\t                .storeUint(params.queryId, 64)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n", "        })\n\t    }\n\t    /**\n\t     * Retrieves the NFT data from the contract.\n\t     * @param provider - The contract provider.\n\t     * @returns An object containing the NFT data, including init, index, collectionAddress, ownerAddress, and individualContent.\n\t     */\n\t    async getNftData(provider: ContractProvider) {\n\t        const { stack } = await provider.get('get_nft_data', [])\n\t        return {\n", "            init: stack.readBoolean(),\n\t            index: stack.readBigNumber(),\n\t            collectionAddress: stack.readAddressOpt(),\n\t            ownerAddress: stack.readAddressOpt(),\n\t            individualContent: stack.readCellOpt(),\n\t        }\n\t    }\n\t    /**\n\t     * Retrieves the authority address from the contract.\n\t     * @param provider - The contract provider.\n", "     * @returns An object containing the authority address.\n\t     */\n\t    async getAuthorityAddress(provider: ContractProvider) {\n\t        const { stack } = await provider.get('get_authority_address', [])\n\t        return {\n\t            authorityAddress: stack.readAddressOpt(),\n\t        }\n\t    }\n\t    /**\n\t     * Retrieves the time when the contract was revoked.\n", "     * @param provider - The contract provider.\n\t     * @returns An object containing the revoked time.\n\t     */\n\t    async getRevokedTime(provider: ContractProvider) {\n\t        const { stack } = await provider.get('get_revoked_time', [])\n\t        return {\n\t            revoked_time: stack.readBigNumber(),\n\t        }\n\t    }\n\t}\n", "// Utils\n\t/**\n\t * Represents the data required to create a new SbtSingle contract.\n\t */\n\texport type SbtSingleData = {\n\t    ownerAddress: Address\n\t    editorAddress: Address\n\t    content: string\n\t    authorityAddress: Address\n\t    revokedAt?: number\n", "}"]}
{"filename": "src/wrappers/getgems/NftRaffle/NftRaffle.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, SendMode } from 'ton-core'\n\t/**\n\t * The object containing operation codes for different operations\n\t */\n\texport const OperationCodes = {\n\t    cancel: 2001,\n\t    addCoins: 2002\n\t}\n\t/**\n\t * Class representing a NFT Raffle\n", " */\n\texport class NftRaffle implements Contract {\n\t    /**\n\t     * @param address - The address of the NFT Raffle\n\t     * @param init - The initialization data for the NFT Raffle\n\t     */\n\t    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\t    /**\n\t     * The code for the NFT Raffle contract\n\t     */\n", "    static code = Cell.fromBoc(Buffer.from('te6ccsECGgEABKgAAA0AEgAXAD0AQwCdANwA+AEgAV4BwQHoAh8CcQJ/Ar4CwwMRAy8DYwObA7cD8QQGBEUEqAEU/wD0pBP0vPLICwECAWIFAgIBWAQDAUW6KJ2zz4QvhD+ET4RfhG+Ef4SPhJ+Er4S/hM+E34TvhP+FCBkBBbtguBUEqNAz0NMDAXGw8kDbPPpAMALTH/hHUkDHBfhIUlDHBfhJUmDHBYIQBRONkVJQuo6GEDRfBNs84IEH0VJQuo6ObDMzgQPqWbFYsfL02zzgMIEH0lJAuhkNCgYDdI6YM4ED6lMxsfL0cAGSMHHeApJyMt5DMNs84FuBB9RSILqOhhAjXwPbPOAygQfTuo6C2zzgW4QP8vAJCAcANIED6fhCcbry8oED6vhJE8cFEvL01NMHMPsAAUqBA+n4QnO98vL4RfhDoPhOqIED61IiufLy+EX4Q6CpBPhQAds8EwNyMDGBA+n4QnG68vQhwAGd+EyCCJiWgFIgoaD4bN4BwAKc+E2CCJiWgBKhoPhtkTDi2zyOgts83ts8FQ8RBLqBA+n4QnG98vKBA+nbPPLycvhi+E/4TvhH+EjbPIIID0JAcPsC+Ef4TI0E05GVCByYWZmbGUgY2FuY2VsZWSBy2zz4SPhNjQTTkZUIHJhZmZsZSBjYW5jZWxlZIHIVDBILA0TbPPhJcI0E05GVCByYWZmbGUgY2FuY2VsZWSCBAILbPNs8EhIRAmZ/jy0kgwf0fG+lII8eItcLA8ACjoZxVHZS2zzeAtcLA8ADjoZxVHUx2zzekTLiAbPmXwUYGASYggiYloASofhOoSDBAPhCcb2xjoMw2zzgIvpEMfhPAds8XLGzjoRfBNs84DQ0+G8Cm/hGpPhm+EwioPhs3pv4RKT4ZPhNAaD4bZEw4hcWFw4DEts8joLbPN7bPBUPEQRyc/hi+FD4T9s8+HD4UPhO2zyCCA9CQHD7AvhJcI0FU5GVCByYWZmbGUgY29tbWlzc2lvboIEAgts8FBMSEAEE2zwRAJj4UPhPyPQA9ADJyPhK+gL4S/oC+Ez6AvhN+gL4TvoCycj4R88W+EjPFvhJzxbJ+Eb4RfhE+EP4QsjLAcsDywPLA8sDycjMzMzMye1UADhwIIAYyMsFUAbPFlAE+gIUy2oSyx8BzxbJAfsAAmB/jyoigwf0fG+lII8bAtcLAMABjohw+EdUZDHbPI6IcPhIVGQx2zzikTLiAbPmXwMYGABsf44xIYMH9HxvpTIhjiNy+BHAAJ1xyMsAydBUIAWDB/QWnXDIywDJ0FQgBYMH9BbiA94Bs+ZbATLbPPhD+ES6+EX4Rrqw+Ez4Sr6w+E34S76wGQBwcFRwEoMH9A5vocAAlF8EcCDg0wMwwACeMXLIywPJ0EADgwf0Fn+fMHPIywPJ0EADgwf0Fn8C4lgBJIBA1yH6QDAB+kQxgEACcALbPBgAenAg+CWCEF/MPRTIyx/LPyTPFlAEzxYTygAi+gISygDJcXAgcoAYyMsFywHLAMsHE8v/UAP6AstqzMkB+wAAwvhBbt3tRNDUAdDTAQH4YtMDAfhj0wMB+GTTAwH4ZdMDMPhm1AHQ+kAB+Gf6QAH4aPpAMPhp1AHQ+gAB+Gr6AAH4a/oAAfhs+gAB+G36ADD4btQw0PQEAfhv9AQw+HB/+GEoOcFW', 'base64'))[0]\n\t    /**\n\t     * Creates an NftRaffle instance from an address.\n\t     * @param address - The address to create from.\n\t     * @returns A new NftRaffle instance.\n\t     */\n\t    static createFromAddress(\n\t        address: Address\n\t    ) {\n\t        return new NftRaffle(\n", "            address\n\t        )\n\t    }\n\t    /**\n\t     * Sends a deploy command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the deploy command.\n\t     * @param value - The value to send with the command.\n\t     */\n\t    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n", "        await provider.internal(via, {\n\t            value,\n\t            body: beginCell().endCell(),\n\t        })\n\t    }\n\t    /**\n\t     * Sends a cancel command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the cancel command.\n\t     * @param params - Parameters for the cancel command including value.\n", "     */\n\t    async sendCancel(provider: ContractProvider, via: Sender, params: { \n\t        value: bigint\n\t    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(OperationCodes.cancel, 32)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n", "        })\n\t    }\n\t    /**\n\t     * Sends an addCoins command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the addCoins command.\n\t     * @param params - Parameters for the addCoins command including value.\n\t     */\n\t    async sendAddCoins(provider: ContractProvider, via: Sender, params: { \n\t        value: bigint\n", "    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(OperationCodes.addCoins, 32)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t    /**\n", "     * Gets the state of the raffle.\n\t     * @param provider - The contract provider.\n\t     * @returns The current state of the raffle.\n\t     */\n\t    async getRaffleState(\n\t        provider: ContractProvider\n\t    ) {\n\t        const { stack } = await provider.get('raffle_state', [])\n\t        return {\n\t            state: stack.readBigNumber(), \n", "            rightNftsCount: stack.readBigNumber(), \n\t            rightNftsReceived: stack.readBigNumber(), \n\t            leftNftsCount: stack.readBigNumber(),\n\t            leftNftsReceived: stack.readBigNumber(), \n\t            leftUser: stack.readAddressOpt(), \n\t            rightUser: stack.readAddressOpt(), \n\t            superUser: stack.readAddressOpt(), \n\t            leftCommission: stack.readBigNumber(),\n\t            rightCommission: stack.readBigNumber(), \n\t            leftCoinsGot: stack.readBigNumber(), \n", "            rightCoinsGot: stack.readBigNumber(),\n\t            nftTransferFee: stack.readCell(), \n\t            nfts: stack.readCell(), \n\t            raffledNfts: stack.readCell()\n\t        }\n\t    }\n\t}"]}
{"filename": "src/wrappers/getgems/NftSwap/NftSwap.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Dictionary, Sender, SendMode, contractAddress } from 'ton-core'\n\t/**\n\t * OperationCodes are identifiers for various actions that can be performed by the contract.\n\t */\n\tconst OperationCodes = {\n\t    ownershipAssigned: 0x05138d91,\n\t    addCoins: 1,\n\t    cancel: 2,\n\t    maintain: 3,\n\t    topup: 4,\n", "    transferCommission: 0x82bd8f2a,\n\t    transferCancel: 0xb5188860,\n\t    transferComplete: 0xef03d009,\n\t}\n\t/**\n\t * SwapState represents the different states of a swap.\n\t */\n\texport const SwapState = {\n\t    Active: 1,\n\t    Cancelled: 2,\n", "    Completed: 3,\n\t}\n\t/**\n\t * Interface representing an NFT item, containing an address and whether it has been sent.\n\t */\n\tinterface NFTItem {\n\t    addr: Address\n\t    sent: boolean\n\t}\n\t/**\n", " * SwapData represents the information of a swap operation.\n\t */\n\texport type SwapData = {\n\t    state: number,\n\t    leftAddress: Address\n\t    rightAddress: Address\n\t    rightNft: NFTItem[]\n\t    leftNft: NFTItem[]\n\t    supervisorAddress: Address\n\t    commissionAddress: Address\n", "    leftCommission: bigint\n\t    leftAmount: bigint\n\t    leftCoinsGot: bigint\n\t    rightCommission: bigint\n\t    rightAmount: bigint\n\t    rightCoinsGot: bigint\n\t}\n\t/**\n\t * Class representing an NFT Swap, implementing the Contract interface.\n\t */\n", "export class NftSwap implements Contract {\n\t    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\t    static code = Cell.fromBoc(Buffer.from('te6cckECDAEAAqAAART/APSkE/S88sgLAQIBIAMCAH7yMO1E0NMA0x/6QPpA+kD6ANTTADDAAY4d+ABwB8jLABbLH1AEzxZYzxYBzxYB+gLMywDJ7VTgXweCAP/+8vACAUgFBABXoDhZ2omhpgGmP/SB9IH0gfQBqaYAYGGh9IH0AfSB9ABhBCCMkrCgFYACqwECAs0IBgH3ZghA7msoAUmCgUjC+8uHCJND6QPoA+kD6ADBTkqEhoVCHoRagUpBwgBDIywVQA88WAfoCy2rJcfsAJcIAJddJwgKwjhdQRXCAEMjLBVADzxYB+gLLaslx+wAQI5I0NOJacIAQyMsFUAPPFgH6AstqyXH7AHAgghBfzD0UgcAlsjLHxPLPyPPFlADzxbKAIIJycOA+gLKAMlxgBjIywUmzxZw+gLLaszJgwb7AHFVUHAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVAP10A6GmBgLjYSS+CcH0gGHaiaGmAaY/9IH0gfSB9AGppgBgYOCmE44BgAEwthGmP6Z+lVW8Q4AHxgRDAgRXdFOAA2CnT44LYTwhWL4ZqGGhpg+oYAP2AcBRgAPloyhJrpOEBWfGBHByUYABOGxuIHCOyiiGYOHgC8BRgAMCwoJAC6SXwvgCMACmFVEECQQI/AF4F8KhA/y8ACAMDM5OVNSxwWSXwngUVHHBfLh9IIQBRONkRW68uH1BPpAMEBmBXAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVADYMTc4OYIQO5rKABi+8uHJU0bHBVFSxwUVsfLhynAgghBfzD0UIYAQyMsFKM8WIfoCy2rLHxXLPyfPFifPFhTKACP6AhPKAMmAQPsAcVBmRRUEcAfIywAWyx9QBM8WWM8WAc8WAfoCzMsAye1UM/Vflw==', 'base64'))[0]\n\t    static buildDataCell(data: SwapData) {\n\t        const dataCell = beginCell()\n\t        dataCell.storeUint(data.state, 2)\n\t        dataCell.storeAddress(data.leftAddress)\n\t        dataCell.storeAddress(data.rightAddress)\n\t        dataCell.storeCoins(data.leftCommission)\n\t        dataCell.storeCoins(data.leftAmount)\n", "        dataCell.storeCoins(data.leftCoinsGot)\n\t        dataCell.storeBit(data.leftNft.length > 0)\n\t        if (data.leftNft.length > 0) {\n\t            const leftNft = Dictionary.empty(\n\t                Dictionary.Keys.BigUint(256)\n\t            )\n\t            for (const leftNftKey in data.leftNft) {\n\t                const bitCell = beginCell()\n\t                bitCell.storeBit(data.leftNft[leftNftKey].sent)\n\t                leftNft.store(bitCell)\n", "            }\n\t            dataCell.storeDict(leftNft)\n\t        }\n\t        dataCell.storeCoins(data.rightCommission)\n\t        dataCell.storeCoins(data.rightAmount)\n\t        dataCell.storeCoins(data.rightCoinsGot)\n\t        dataCell.storeBit(data.rightNft.length > 0)\n\t        if (data.rightNft.length > 0) {\n\t            const rightNft = Dictionary.empty(\n\t                Dictionary.Keys.BigUint(256)\n", "            )\n\t            for (const rightNftKey in data.rightNft) {\n\t                const bitCell = beginCell()\n\t                bitCell.storeBit(data.rightNft[rightNftKey].sent)\n\t                rightNft.store(bitCell)\n\t            }\n\t            dataCell.storeDict(rightNft)\n\t        }\n\t        const marketCell = beginCell()\n\t        marketCell.storeAddress(data.commissionAddress)\n", "        marketCell.storeAddress(data.supervisorAddress)\n\t        dataCell.storeRef(marketCell)\n\t        return dataCell.endCell()\n\t    }\n\t    /**\n\t     * Method to create a new NftSwap instance from an address.\n\t     * @param address - The address of the swap.\n\t     */\n\t    static createFromAddress(\n\t        address: Address\n", "    ) {\n\t        return new NftSwap(\n\t            address\n\t        )\n\t    }\n\t    /**\n\t     * Method to create a new NftSwap instance from a configuration.\n\t     * @param config - The configuration of the swap.\n\t     * @param workchain - The workchain of the swap.\n\t     */\n", "    static async createFromConfig(\n\t        config: SwapData,\n\t        workchain = 0\n\t    ) {\n\t        const data = this.buildDataCell(config)\n\t        const address = contractAddress(\n\t            workchain,\n\t            {\n\t                code: this.code,\n\t                data: data\n", "            }\n\t        )\n\t        return new NftSwap(\n\t            address,\n\t            {\n\t                code: this.code,\n\t                data: data\n\t            }\n\t        )\n\t    }\n", "    /**\n\t     * Method to send a deploy command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the deploy command.\n\t     * @param value - The value sent with the deploy command.\n\t     */\n\t    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n\t        await provider.internal(via, {\n\t            value,\n\t            body: beginCell().endCell(),\n", "        })\n\t    }\n\t    /**\n\t     * Sends a cancel command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the cancel command.\n\t     * @param params - Parameters for the cancel command including value and optional queryId.\n\t     */\n\t    async sendCancel(provider: ContractProvider, via: Sender, params: { \n\t        value: bigint,\n", "        queryId?: number\n\t    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(OperationCodes.cancel, 32)\n\t                .storeUint(params.queryId || 0, 64)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n", "    }\n\t    /**\n\t     * Sends an addCoins command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the addCoins command.\n\t     * @param params - Parameters for the addCoins command including value, optional queryId, and coins.\n\t     */\n\t    async sendAddCoins(provider: ContractProvider, via: Sender, params: { \n\t        value: bigint,\n\t        queryId?: number,\n", "        coins: bigint\n\t    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(OperationCodes.addCoins, 32)\n\t                .storeUint(params.queryId || 0, 64)\n\t                .storeCoins(params.coins)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n", "        })\n\t    }\n\t    /**\n\t     * Sends a maintain command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the maintain command.\n\t     * @param params - Parameters for the maintain command including value, optional queryId, mode, and msg.\n\t     */\n\t    async sendMaintain(\n\t        provider: ContractProvider,\n", "        via: Sender,\n\t        params: {\n\t            value: bigint,\n\t            queryId?: number,\n\t            mode: number,\n\t            msg: Cell\n\t        }\n\t    ) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n", "            body: beginCell()\n\t                .storeUint(OperationCodes.maintain, 32)\n\t                .storeUint(params.queryId || 0, 64)\n\t                .storeUint(params.mode, 8)\n\t                .storeRef(params.msg)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t    /**\n", "     * Sends a topup command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the topup command.\n\t     * @param params - Parameters for the topup command including value and optional queryId.\n\t     */\n\t    async sendTopup(provider: ContractProvider, via: Sender, params: { \n\t        value: bigint,\n\t        queryId?: number \n\t    }) {\n\t        await provider.internal(via, {\n", "            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(OperationCodes.topup, 32)\n\t                .storeUint(params.queryId || 0, 64)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t    /**\n\t     * Gets the current state of the trade from the contract.\n", "     * @param provider - The contract provider.\n\t     * @returns An object representing the current state of the trade.\n\t     */\n\t    async getTradeState(\n\t        provider: ContractProvider\n\t    ) {\n\t        const { stack } = await provider.get('get_trade_state', [])\n\t        return {\n\t            state: stack.readBigNumber() ?? 0, \n\t            left_ok: !(stack.readBigNumber().toString() == '0'), \n", "            right_ok: !(stack.readBigNumber().toString() == '0'), \n\t            leftAddress: stack.readAddressOpt(), \n\t            rightAddress: stack.readAddressOpt(), \n\t            leftNft: stack.readCell(), \n\t            rightNft: stack.readCell(),\n\t            leftComm: stack.readBigNumber(), \n\t            leftAmount: stack.readBigNumber(), \n\t            leftGot: stack.readBigNumber(), \n\t            rightComm: stack.readBigNumber(), \n\t            rightAmount: stack.readBigNumber(), \n", "            rightGot: stack.readBigNumber()\n\t        }\n\t    }\n\t    /**\n\t     * Gets the supervisor of the contract.\n\t     * @param provider - The contract provider.\n\t     * @returns An object representing the supervisor.\n\t     */\n\t    async getSupervisor(\n\t        provider: ContractProvider\n", "    ) {\n\t        const { stack } = await provider.get('get_supervisor', [])\n\t        return {\n\t            supervisor: stack.readAddressOpt()\n\t        }\n\t    }   \n\t}"]}
{"filename": "src/wrappers/getgems/NftFixedPriceV2/NftFixedPriceV2.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\n\t/**\n\t * Class representing a NFT fixed price sale contract (Version 2).\n\t */\n\texport class NftFixedPriceV2 implements Contract {\n\t    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\t    static code = Cell.fromBoc(Buffer.from('te6cckECDAEAAikAART/APSkE/S88sgLAQIBIAMCAATyMAIBSAUEAFGgOFnaiaGmAaY/9IH0gfSB9AGoYaH0gfQB9IH0AGEEIIySsKAVgAKrAQICzQgGAfdmCEDuaygBSYKBSML7y4cIk0PpA+gD6QPoAMFOSoSGhUIehFqBSkHCAEMjLBVADzxYB+gLLaslx+wAlwgAl10nCArCOF1BFcIAQyMsFUAPPFgH6AstqyXH7ABAjkjQ04lpwgBDIywVQA88WAfoCy2rJcfsAcCCCEF/MPRSBwCCIYAYyMsFKs8WIfoCy2rLHxPLPyPPFlADzxbKACH6AsoAyYMG+wBxVVAGyMsAFcsfUAPPFgHPFgHPFgH6AszJ7VQC99AOhpgYC42EkvgnB9IBh2omhpgGmP/SB9IH0gfQBqGBNgAPloyhFrpOEBWccgGRwcKaDjgskvhHAoomOC+XD6AmmPwQgCicbIiV15cPrpn5j9IBggKwNkZYAK5Y+oAeeLAOeLAOeLAP0BZmT2qnAbE+OAcYED6Y/pn5gQwLCQFKwAGSXwvgIcACnzEQSRA4R2AQJRAkECPwBeA6wAPjAl8JhA/y8AoAyoIQO5rKABi+8uHJU0bHBVFSxwUVsfLhynAgghBfzD0UIYAQyMsFKM8WIfoCy2rLHxnLPyfPFifPFhjKACf6AhfKAMmAQPsAcQZQREUVBsjLABXLH1ADzxYBzxYBzxYB+gLMye1UABY3EDhHZRRDMHDwBTThaBI=', 'base64'))[0]\n\t    /**\n\t     * Builds the data cell for an NFT fixed price sale.\n\t     * @param data - The data for the NFT sale.\n", "     * @returns A cell containing the data for the NFT sale.\n\t     */\n\t    static buildDataCell(data: NftFixPriceSaleV2Data) {\n\t        const feesCell = beginCell()\n\t        feesCell.storeAddress(data.marketplaceFeeAddress)\n\t        feesCell.storeCoins(data.marketplaceFee)\n\t        feesCell.storeAddress(data.royaltyAddress)\n\t        feesCell.storeCoins(data.royaltyAmount)\n\t        const dataCell = beginCell()\n\t        dataCell.storeUint(data.isComplete ? 1 : 0, 1)\n", "        dataCell.storeUint(data.createdAt, 32)\n\t        dataCell.storeAddress(data.marketplaceAddress)\n\t        dataCell.storeAddress(data.nftAddress)\n\t        dataCell.storeAddress(data.nftOwnerAddress)\n\t        dataCell.storeCoins(data.fullPrice)\n\t        dataCell.storeRef(feesCell)\n\t        return dataCell.endCell()\n\t    }\n\t    /**\n\t     * Creates an NftFixedPriceV2 instance from an address.\n", "     * @param address - The address to create from.\n\t     * @returns A new NftFixedPriceV2 instance.\n\t     */\n\t    static createFromAddress(\n\t        address: Address\n\t    ) {\n\t        return new NftFixedPriceV2(\n\t            address\n\t        )\n\t    }\n", "    /**\n\t     * Creates an NftFixedPriceV2 instance from a configuration object.\n\t     * @param config - The configuration data for the NFT sale.\n\t     * @param workchain - The workchain ID (default is 0).\n\t     * @returns A new NftFixedPriceV2 instance.\n\t     */\n\t    static async createFromConfig(\n\t        config: NftFixPriceSaleV2Data,\n\t        workchain = 0\n\t    ) {\n", "        const data = this.buildDataCell(config)\n\t        const address = contractAddress(\n\t            workchain,\n\t            {\n\t                code: this.code,\n\t                data: data\n\t            }\n\t        )\n\t        return new NftFixedPriceV2(\n\t            address,\n", "            {\n\t                code: this.code,\n\t                data: data\n\t            }\n\t        )\n\t    }\n\t    /**\n\t     * Sends a deploy command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the deploy command.\n", "     * @param value - The value to send with the command.\n\t     */\n\t    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n\t        await provider.internal(via, {\n\t            value,\n\t            body: beginCell().endCell(),\n\t        })\n\t    }\n\t    /**\n\t     * Sends coins to the contract.\n", "     * @param provider - The contract provider.\n\t     * @param via - The sender of the coins.\n\t     * @param params - Parameters for the operation, including the value and queryId.\n\t     */\n\t    async sendCoins(provider: ContractProvider, via: Sender, params: {\n\t        value: bigint\n\t        queryId: bigint\n\t    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n", "            body: beginCell()\n\t                .storeUint(1, 32)\n\t                .storeUint(params.queryId, 64)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t    /**\n\t     * Sends a command to cancel the sale.\n\t     * @param provider - The contract provider.\n", "     * @param via - The sender of the command.\n\t     * @param params - Parameters for the operation, including the value and queryId.\n\t     */\n\t    async sendCancelSale(provider: ContractProvider, via: Sender, params: {\n\t        value: bigint\n\t        queryId: bigint\n\t    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n", "                .storeUint(3, 32)\n\t                .storeUint(params.queryId, 64)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t    /**\n\t     * Sends a command to buy the NFT.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the command.\n", "     * @param params - Parameters for the operation, including the value and queryId.\n\t     */\n\t    async sendBuy(provider: ContractProvider, via: Sender, params: {\n\t        value: bigint\n\t        queryId: bigint\n\t    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell().\n\t                storeUint(params.queryId || 0, 32).\n", "                endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t    /**\n\t     * Retrieves the sale data from the contract.\n\t     * @param provider - The contract provider.\n\t     * @returns An object containing the sale data.\n\t     */\n\t    async getSaleData(provider: ContractProvider) {\n", "        const { stack } = await provider.get('get_sale_data', [])\n\t        // pops out saleType\n\t        stack.pop()\n\t        return {\n\t            isComplete: stack.readBigNumber(),\n\t            createdAt: stack.readBigNumber(),\n\t            marketplaceAddress: stack.readAddressOpt(),\n\t            nftAddress: stack.readAddressOpt(),\n\t            nftOwnerAddress: stack.readAddressOpt(),\n\t            fullPrice: stack.readBigNumber(),\n", "            marketplaceFeeAddress: stack.readAddressOpt(),\n\t            marketplaceFee: stack.readBigNumber(),\n\t            royaltyAddress: stack.readAddressOpt(),\n\t            royaltyAmount:  stack.readBigNumber()\n\t        }\n\t    }\n\t}\n\t/**\n\t * Type definition for the data of an NFT fixed price sale, version 2.\n\t */\n", "export type NftFixPriceSaleV2Data = {\n\t    isComplete: boolean\n\t    createdAt: number\n\t    marketplaceAddress: Address\n\t    nftAddress: Address\n\t    nftOwnerAddress: Address|null\n\t    fullPrice: bigint\n\t    marketplaceFeeAddress: Address\n\t    marketplaceFee: bigint\n\t    royaltyAddress: Address\n", "    royaltyAmount: bigint\n\t}"]}
{"filename": "src/wrappers/getgems/NftItem/NftItem.ts", "chunked_list": ["import { Address, beginCell, Cell, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\n\timport { NftItemRoyalty } from '../../standard/NftItemRoyalty'\n\t/**\n\t* Class representing a Non-Fungible Token (NFT) Item.\n\t* This class extends the NftItemRoyalty class.\n\t*/\n\texport class NftItem extends NftItemRoyalty {\n\t    static code = Cell.fromBoc(Buffer.from('te6cckECDQEAAdAAART/APSkE/S88sgLAQIBYgMCAAmhH5/gBQICzgcEAgEgBgUAHQDyMs/WM8WAc8WzMntVIAA7O1E0NM/+kAg10nCAJp/AfpA1DAQJBAj4DBwWW1tgAgEgCQgAET6RDBwuvLhTYALXDIhxwCSXwPg0NMDAXGwkl8D4PpA+kAx+gAxcdch+gAx+gAw8AIEs44UMGwiNFIyxwXy4ZUB+kDUMBAj8APgBtMf0z+CEF/MPRRSMLqOhzIQN14yQBPgMDQ0NTWCEC/LJqISuuMCXwSED/LwgCwoAcnCCEIt3FzUFyMv/UATPFhAkgEBwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7AAH2UTXHBfLhkfpAIfAB+kDSADH6AIIK+vCAG6EhlFMVoKHeItcLAcMAIJIGoZE24iDC//LhkiGOPoIQBRONkchQCc8WUAvPFnEkSRRURqBwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7ABBHlBAqN1viDACCAo41JvABghDVMnbbEDdEAG1xcIAQyMsFUAfPFlAF+gIVy2oSyx/LPyJus5RYzxcBkTLiAckB+wCTMDI04lUC8ANqhGIu', 'base64'))[0]\n\t    /**\n\t     * Builds the data cell for an NFT item.\n", "     * @param data - The data for the NFT item.\n\t     * @returns A cell containing the data for the NFT item.\n\t     */\n\t    static buildDataCell(data: NftItemData) {\n\t        const dataCell = beginCell()\n\t        const contentCell = beginCell()\n\t        // contentCell.bits.writeString(data.content)\n\t        contentCell.storeBuffer(Buffer.from(data.content))\n\t        dataCell.storeUint(data.index, 64)\n\t        dataCell.storeAddress(data.collectionAddress)\n", "        dataCell.storeAddress(data.ownerAddress)\n\t        dataCell.storeRef(contentCell)\n\t        return dataCell.endCell()\n\t    }\n\t    /**\n\t     * Creates an NftItem instance from an address.\n\t     * @param address - The address to create from.\n\t     * @returns A new NftItem instance.\n\t     */\n\t    static createFromAddress(\n", "        address: Address\n\t    ) {\n\t        return new NftItem(\n\t            address\n\t        )\n\t    }\n\t    /**\n\t     * Creates an NftItem instance from a configuration object.\n\t     * @param config - The configuration data for the NFT item.\n\t     * @param workchain - The workchain ID (default is 0).\n", "     * @returns A new NftItem instance.\n\t     */\n\t    static async createFromConfig(\n\t        config: NftItemData,\n\t        workchain = 0\n\t    ) {\n\t        const data = this.buildDataCell(config)\n\t        const address = contractAddress(\n\t            workchain,\n\t            {\n", "                code: this.code,\n\t                data: data\n\t            }\n\t        )\n\t        return new NftItem(\n\t            address,\n\t            {\n\t                code: this.code,\n\t                data: data\n\t            }\n", "        )\n\t    }\n\t    /**\n\t     * Sends a deploy command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the deploy command.\n\t     * @param value - The value to send with the command.\n\t     */\n\t    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n\t        await provider.internal(via, {\n", "            value,\n\t            body: beginCell().endCell(),\n\t        })\n\t    }\n\t    /**\n\t     * Sends a command to transfer editorship of the NFT item.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the command.\n\t     * @param params - Parameters for the operation, including the value, queryId, new editor address, response address, and forward amount.\n\t     */\n", "    async sendTransferEditorship(provider: ContractProvider, via: Sender, params: { \n\t        value: bigint, \n\t        queryId?: number,\n\t        newEditor: Address, \n\t        responseTo: Address|null,\n\t        forwardAmount?: bigint \n\t    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n", "                .storeUint(0x1c04412a, 32)\n\t                .storeUint(params.queryId || 0, 64)\n\t                .storeAddress(params.newEditor)\n\t                .storeAddress(params.responseTo)\n\t                .storeBit(false)\n\t                .storeCoins(params.forwardAmount || 0)\n\t                .storeBit(false)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n", "    }\n\t}\n\t/**\n\t * Type definition for the data of an NFT item.\n\t */\n\texport type NftItemData = {\n\t    index: number\n\t    collectionAddress: Address | null\n\t    ownerAddress: Address\n\t    content: string\n", "}"]}
{"filename": "src/wrappers/getgems/NftFixedPriceV3/NftFixedPriceV3.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\n\t/**\n\t * Class representing a NFT fixed price sale contract V3\n\t */\n\texport class NftFixedPriceV3 implements Contract {\n\t    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\t    static code = Cell.fromBoc(Buffer.from('te6cckECDAEAAqAAART/APSkE/S88sgLAQIBIAMCAH7yMO1E0NMA0x/6QPpA+kD6ANTTADDAAY4d+ABwB8jLABbLH1AEzxZYzxYBzxYB+gLMywDJ7VTgXweCAP/+8vACAUgFBABXoDhZ2omhpgGmP/SB9IH0gfQBqaYAYGGh9IH0AfSB9ABhBCCMkrCgFYACqwECAs0IBgH3ZghA7msoAUmCgUjC+8uHCJND6QPoA+kD6ADBTkqEhoVCHoRagUpBwgBDIywVQA88WAfoCy2rJcfsAJcIAJddJwgKwjhdQRXCAEMjLBVADzxYB+gLLaslx+wAQI5I0NOJacIAQyMsFUAPPFgH6AstqyXH7AHAgghBfzD0UgcAlsjLHxPLPyPPFlADzxbKAIIJycOA+gLKAMlxgBjIywUmzxZw+gLLaszJgwb7AHFVUHAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVAP10A6GmBgLjYSS+CcH0gGHaiaGmAaY/9IH0gfSB9AGppgBgYOCmE44BgAEwthGmP6Z+lVW8Q4AHxgRDAgRXdFOAA2CnT44LYTwhWL4ZqGGhpg+oYAP2AcBRgAPloyhJrpOEBWfGBHByUYABOGxuIHCOyiiGYOHgC8BRgAMCwoJAC6SXwvgCMACmFVEECQQI/AF4F8KhA/y8ACAMDM5OVNSxwWSXwngUVHHBfLh9IIQBRONkRW68uH1BPpAMEBmBXAHyMsAFssfUATPFljPFgHPFgH6AszLAMntVADYMTc4OYIQO5rKABi+8uHJU0bHBVFSxwUVsfLhynAgghBfzD0UIYAQyMsFKM8WIfoCy2rLHxXLPyfPFifPFhTKACP6AhPKAMmAQPsAcVBmRRUEcAfIywAWyx9QBM8WWM8WAc8WAfoCzMsAye1UM/Vflw==', 'base64'))[0]\n\t    /**\n\t     * Builds the data cell for an NFT fixed price sale.\n\t     * @param data - The data for the NFT sale.\n", "     * @returns A cell containing the data for the NFT sale.\n\t     */\n\t    static buildDataCell(data: NftFixPriceSaleV3Data) {\n\t        const feesCell = beginCell()\n\t        feesCell.storeAddress(data.marketplaceFeeAddress)\n\t        feesCell.storeCoins(data.marketplaceFee)\n\t        feesCell.storeAddress(data.royaltyAddress)\n\t        feesCell.storeCoins(data.royaltyAmount)\n\t        const dataCell = beginCell()\n\t        dataCell.storeUint(data.isComplete ? 1 : 0, 1)\n", "        dataCell.storeUint(data.createdAt, 32)\n\t        dataCell.storeAddress(data.marketplaceAddress)\n\t        dataCell.storeAddress(data.nftAddress)\n\t        dataCell.storeAddress(data.nftOwnerAddress)\n\t        dataCell.storeCoins(data.fullPrice)\n\t        dataCell.storeRef(feesCell)\n\t        dataCell.storeUint(data.canDeployByExternal ? 1 : 0, 1) // can_deploy_by_external\n\t        return dataCell.endCell()\n\t    }\n\t    /**\n", "     * Creates an NftFixedPriceV3 instance from an address.\n\t     * @param address - The address to create from.\n\t     * @returns A new NftFixedPriceV3 instance.\n\t     */\n\t    static createFromAddress(\n\t        address: Address\n\t    ) {\n\t        return new NftFixedPriceV3(\n\t            address\n\t        )\n", "    }\n\t    /**\n\t     * Creates an NftFixedPriceV3 instance from a configuration object.\n\t     * @param config - The configuration data for the NFT sale.\n\t     * @param workchain - The workchain ID (default is 0).\n\t     * @returns A new NftFixedPriceV3 instance.\n\t     */\n\t    static async createFromConfig(\n\t        config: NftFixPriceSaleV3Data,\n\t        workchain = 0\n", "    ) {\n\t        const data = this.buildDataCell(config)\n\t        const address = contractAddress(\n\t            workchain,\n\t            {\n\t                code: this.code,\n\t                data: data\n\t            }\n\t        )\n\t        return new NftFixedPriceV3(\n", "            address,\n\t            {\n\t                code: this.code,\n\t                data: data\n\t            }\n\t        )\n\t    }\n\t    /**\n\t     * Sends a deploy command to the contract.\n\t     * @param provider - The contract provider.\n", "     * @param via - The sender of the deploy command.\n\t     * @param value - The value to send with the command.\n\t     */\n\t    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n\t        await provider.internal(via, {\n\t            value,\n\t            body: beginCell().endCell(),\n\t        })\n\t    }\n\t    /**\n", "     * Sends coins to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the coins.\n\t     * @param params - Parameters for the operation, including the value and queryId.\n\t     */\n\t    async sendCoins(provider: ContractProvider, via: Sender, params: {\n\t        value: bigint\n\t        queryId: bigint\n\t    }) {\n\t        await provider.internal(via, {\n", "            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(1, 32)\n\t                .storeUint(params.queryId, 64)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t    /**\n\t     * Sends a command to cancel the sale.\n", "     * @param provider - The contract provider.\n\t     * @param via - The sender of the command.\n\t     * @param params - Parameters for the operation, including the value and queryId.\n\t     */\n\t    async sendCancelSale(provider: ContractProvider, via: Sender, params: {\n\t        value: bigint\n\t        queryId: bigint\n\t    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n", "            body: beginCell()\n\t                .storeUint(3, 32)\n\t                .storeUint(params.queryId, 64)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t    /**\n\t     * Sends a command to buy the NFT.\n\t     * @param provider - The contract provider.\n", "     * @param via - The sender of the command.\n\t     * @param params - Parameters for the operation, including the value and queryId.\n\t     */\n\t    async sendBuy(provider: ContractProvider, via: Sender, params: {\n\t        value: bigint\n\t        queryId: bigint\n\t    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell().endCell(),\n", "            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t    /**\n\t     * Retrieves the sale data from the contract.\n\t     * @param provider - The contract provider.\n\t     * @returns An object containing the sale data.\n\t     */\n\t    async getSaleData(provider: ContractProvider) {\n\t        const { stack } = await provider.get('get_sale_data', [])\n", "        // pops out saleType\n\t        stack.pop()\n\t        return {\n\t            // saleType: stack.readBigNumber(),\n\t            isComplete: stack.readBigNumber(),\n\t            createdAt: stack.readBigNumber(),\n\t            marketplaceAddress: stack.readAddressOpt(),\n\t            nftAddress: stack.readAddressOpt(),\n\t            nftOwnerAddress: stack.readAddressOpt(),\n\t            fullPrice: stack.readBigNumber(),\n", "            marketplaceFeeAddress: stack.readAddressOpt(),\n\t            marketplaceFee: stack.readBigNumber(),\n\t            royaltyAddress: stack.readAddressOpt(),\n\t            royaltyAmount:  stack.readBigNumber()\n\t        }\n\t    }\n\t}\n\t/**\n\t * Type definition for the data of an NFT fixed price sale.\n\t */\n", "export type NftFixPriceSaleV3Data = {\n\t    isComplete: boolean\n\t    createdAt: number\n\t    marketplaceAddress: Address\n\t    nftAddress: Address\n\t    nftOwnerAddress: Address | null\n\t    fullPrice: bigint\n\t    marketplaceFeeAddress: Address\n\t    marketplaceFee: bigint\n\t    royaltyAddress: Address\n", "    royaltyAmount: bigint\n\t    canDeployByExternal?: boolean\n\t  }\n"]}
{"filename": "src/wrappers/getgems/NftCollection/NftCollection.ts", "chunked_list": ["import { Address, beginCell, Cell, ContractProvider, Transaction, Sender, SendMode, contractAddress, ExternalAddress } from 'ton-core'\n\timport { storeOffchainContent } from '../../../types/Content'\n\timport { NftCollectionRoyalty } from '../../standard/NftCollectionRoyalty'\n\timport { isEligibleTransaction } from '../../../utils/EligibleInternalTx'\n\timport { Maybe } from 'ton-core/dist/utils/maybe'\n\texport type CollectionMintItemInput = {\n\t    passAmount: bigint\n\t    index: number\n\t    ownerAddress: Address\n\t    content: string\n", "}\n\texport type RoyaltyParams = {\n\t    royaltyFactor: number\n\t    royaltyBase: number\n\t    royaltyAddress: Address\n\t}\n\texport const OperationCodes = {\n\t    Mint: 1,\n\t    BatchMint: 2,\n\t    ChangeOwner: 3,\n", "    EditContent: 4,\n\t    GetRoyaltyParams: 0x693d3950,\n\t    GetRoyaltyParamsResponse: 0xa8cb00ad\n\t}\n\t/**\n\t * Class representing a Non-Fungible Token (NFT) collection contract.\n\t * This class extends from the `NftCollectionRoyalty` class.\n\t */\n\texport class NftCollection extends NftCollectionRoyalty {\n\t    static code = Cell.fromBoc(Buffer.from('te6cckECFAEAAh8AART/APSkE/S88sgLAQIBYgkCAgEgBAMAJbyC32omh9IGmf6mpqGC3oahgsQCASAIBQIBIAcGAC209H2omh9IGmf6mpqGAovgngCOAD4AsAAvtdr9qJofSBpn+pqahg2IOhph+mH/SAYQAEO4tdMe1E0PpA0z/U1NQwECRfBNDUMdQw0HHIywcBzxbMyYAgLNDwoCASAMCwA9Ra8ARwIfAFd4AYyMsFWM8WUAT6AhPLaxLMzMlx+wCAIBIA4NABs+QB0yMsCEsoHy//J0IAAtAHIyz/4KM8WyXAgyMsBE/QA9ADLAMmAE59EGOASK3wAOhpgYC42Eit8H0gGADpj+mf9qJofSBpn+pqahhBCDSenKgpQF1HFBuvgoDoQQhUZYBWuEAIZGWCqALnixJ9AQpltQnlj+WfgOeLZMAgfYBwGyi544L5cMiS4ADxgRLgAXGBEuAB8YEYGYHgAkExIREAA8jhXU1DAQNEEwyFAFzxYTyz/MzMzJ7VTgXwSED/LwACwyNAH6QDBBRMhQBc8WE8s/zMzMye1UAKY1cAPUMI43gED0lm+lII4pBqQggQD6vpPywY/egQGTIaBTJbvy9AL6ANQwIlRLMPAGI7qTAqQC3gSSbCHis+YwMlBEQxPIUAXPFhPLP8zMzMntVABgNQLTP1MTu/LhklMTugH6ANQwKBA0WfAGjhIBpENDyFAFzxYTyz/MzMzJ7VSSXwXiN0CayQ==', 'base64'))[0]\n", "    /**\n\t     * Builds the data cell for an NFT collection.\n\t     * @param data - The data for the NFT collection.\n\t     * @returns A cell containing the data for the NFT collection.\n\t     */\n\t    static buildDataCell(data: NftCollectionData) {\n\t        const dataCell = beginCell()\n\t        dataCell.storeAddress(data.ownerAddress)\n\t        dataCell.storeUint(data.nextItemIndex, 64)\n\t        const contentCell = beginCell()\n", "        const collectionContent = storeOffchainContent({\n\t            type: 'offchain',\n\t            uri: data.collectionContent\n\t        })\n\t        const commonContent = beginCell()\n\t        commonContent.storeBuffer(Buffer.from(data.commonContent))\n\t        contentCell.store(collectionContent)\n\t        contentCell.storeRef(commonContent)\n\t        dataCell.storeRef(contentCell)\n\t        dataCell.storeRef(data.nftItemCode)\n", "        const royaltyCell = beginCell()\n\t        royaltyCell.storeUint(data.royaltyParams.royaltyFactor, 16)\n\t        royaltyCell.storeUint(data.royaltyParams.royaltyBase, 16)\n\t        royaltyCell.storeAddress(data.royaltyParams.royaltyAddress)\n\t        dataCell.storeRef(royaltyCell)\n\t        return dataCell.endCell()\n\t    }\n\t    /**\n\t     * Creates an `NftCollection` instance from an address.\n\t     * @param address - The address to create from.\n", "     * @returns A new `NftCollection` instance.\n\t     */\n\t    static createFromAddress(\n\t        address: Address\n\t    ) {\n\t        return new NftCollection(\n\t            address\n\t        )\n\t    }\n\t    /**\n", "     * Creates an `NftCollection` instance from a configuration object.\n\t     * @param config - The configuration data for the NFT collection.\n\t     * @param workchain - The workchain ID (default is 0).\n\t     * @returns A new `NftCollection` instance.\n\t     */\n\t    static async createFromConfig(\n\t        config: NftCollectionData,\n\t        workchain = 0\n\t    ) {\n\t        const data = this.buildDataCell(config)\n", "        const address = contractAddress(\n\t            workchain,\n\t            {\n\t                code: this.code,\n\t                data: data\n\t            }\n\t        )\n\t        return new NftCollection(\n\t            address,\n\t            {\n", "                code: this.code,\n\t                data: data\n\t            }\n\t        )\n\t    }\n\t    /**\n\t     * Sends a deploy command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the deploy command.\n\t     * @param value - The value to send with the command.\n", "     */\n\t    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n\t        await provider.internal(via, {\n\t            value,\n\t            body: beginCell().endCell(),\n\t        })\n\t    }\n\t    /**\n\t     * Sends a mint command to the contract.\n\t     * @param provider - The contract provider.\n", "     * @param via - The sender of the mint command.\n\t     * @param params - The parameters for the mint command.\n\t     */\n\t    async sendMint(provider: ContractProvider, via: Sender, params: { \n\t        queryId?: number, \n\t        value: bigint,\n\t        passAmount: bigint, \n\t        itemIndex: number, \n\t        itemOwnerAddress: Address, \n\t        itemContent: string \n", "    }) {\n\t        const itemContent = beginCell()\n\t        // itemContent.bits.writeString(params.itemContent)\n\t        itemContent.storeBuffer(Buffer.from(params.itemContent)).endCell()\n\t        const nftItemMessage = beginCell()\n\t        nftItemMessage.storeAddress(params.itemOwnerAddress)\n\t        nftItemMessage.storeRef(itemContent).endCell()\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n", "                .storeUint(1, 32)\n\t                .storeUint(params.queryId || 0, 64)\n\t                .storeUint(params.itemIndex, 64)\n\t                .storeCoins(params.passAmount)\n\t                .storeRef(nftItemMessage)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t    /**\n", "     * Sends a change owner command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the change owner command.\n\t     * @param params - The parameters for the change owner command.\n\t     */\n\t    async sendChangeOwner(provider: ContractProvider, via: Sender, params: { \n\t        queryId?: number, \n\t        value: bigint,\n\t        newOwner: Address\n\t    }) {\n", "        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(OperationCodes.ChangeOwner, 32)\n\t                .storeUint(params.queryId || 0, 64)\n\t                .storeAddress(params.newOwner)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY\n\t        })\n\t    }\n", "    /**\n\t     * Parses a mint transaction.\n\t     * @param tx - The transaction to parse.\n\t     * @returns The parsed mint transaction, or undefined if parsing failed.\n\t     */\n\t    static parseMint(tx: Transaction): NftMint | undefined {\n\t        try {\n\t            const body = tx.inMessage?.body.beginParse()\n\t            if (body === undefined) return undefined \n\t            const op = body.loadUint(32)\n", "            if (op !== 1) return undefined \n\t            if (!isEligibleTransaction(tx)) {\n\t                return undefined\n\t            }\n\t            return {\n\t                queryId: body.loadUint(64),\n\t                from: tx.inMessage?.info.src ?? undefined,\n\t                to: tx.inMessage?.info.dest ?? undefined,\n\t                itemIndex: body.loadUint(64),\n\t                passAmount: body.loadCoins(),\n", "                nftItemMessage: body.loadRef()\n\t            }\n\t        } catch (e) { /* empty */ }\n\t        return undefined\n\t    }\n\t    /**\n\t     * Parses an ownership transfer transaction.\n\t     * @param tx - The transaction to parse.\n\t     * @returns The parsed ownership transfer transaction, or undefined if parsing failed.\n\t     */\n", "    static parseOwnershipTransfer(tx: Transaction): OwnershipTransfer | undefined {\n\t        try {\n\t            const body = tx.inMessage?.body.beginParse()\n\t            if (body === undefined) return undefined \n\t            const op = body.loadUint(32)\n\t            if (op !== 3) return undefined \n\t            if (!isEligibleTransaction(tx)) {\n\t                return undefined\n\t            }\n\t            return {\n", "                queryId: body.loadUint(64),\n\t                oldOwner: tx.inMessage?.info.src ?? undefined,\n\t                newOwner: body.loadAddress()\n\t            }\n\t        } catch (e) { /* empty */ }\n\t        return undefined\n\t    }\n\t}\n\t/**\n\t * Type definition for the data of an NFT collection.\n", " */\n\texport type NftCollectionData = {\n\t    ownerAddress: Address,\n\t    nextItemIndex: number | bigint\n\t    collectionContent: string\n\t    commonContent: string\n\t    nftItemCode: Cell\n\t    royaltyParams: RoyaltyParams\n\t}\n\t/**\n", " * Type definition for the data of an NFT mint transaction.\n\t */\n\texport type NftMint = {\n\t    queryId: number\n\t    from?: Address | Maybe<ExternalAddress>\n\t    to?: Address | Maybe<ExternalAddress>\n\t    itemIndex: number\n\t    passAmount: bigint\n\t    nftItemMessage: Cell\n\t}\n", "/**\n\t * Type definition for the data of an ownership transfer transaction.\n\t */\n\texport type OwnershipTransfer = {\n\t    queryId: number\n\t    oldOwner?: Address | Maybe<ExternalAddress>\n\t    newOwner: Address\n\t}"]}
{"filename": "src/wrappers/getgems/NftCollectionEditable/NftCollectionEditable.ts", "chunked_list": ["import { Address, beginCell, ContractProvider, Sender, SendMode } from 'ton-core'\n\timport { NftCollectionRoyalty } from '../../standard/NftCollectionRoyalty'\n\texport type CollectionMintItemInput = {\n\t    passAmount: bigint\n\t    index: number\n\t    ownerAddress: Address\n\t    content: string\n\t}\n\texport type RoyaltyParams = {\n\t    royaltyFactor: number\n", "    royaltyBase: number\n\t    royaltyAddress: Address\n\t}\n\tconst OperationCodes = {\n\t    Mint: 1,\n\t    BatchMint: 2,\n\t    ChangeOwner: 3,\n\t    EditContent: 4,\n\t    GetRoyaltyParams: 0x693d3950,\n\t    GetRoyaltyParamsResponse: 0xa8cb00ad\n", "}\n\t/**\n\t * Class representing an editable Non-Fungible Token (NFT) collection contract.\n\t * This class extends from the `NftCollectionRoyalty` class.\n\t */\n\texport class NftCollectionEditable extends NftCollectionRoyalty {\n\t    /**\n\t     * Creates an `NftCollectionEditable` instance from an address.\n\t     * @param address - The address to create from.\n\t     * @returns A new `NftCollectionEditable` instance.\n", "     */\n\t    static createFromAddress(\n\t        address: Address\n\t    ) {\n\t        return new NftCollectionEditable(\n\t            address\n\t        )\n\t    }\n\t    /**\n\t     * Sends a deploy command to the contract.\n", "     * @param provider - The contract provider.\n\t     * @param via - The sender of the deploy command.\n\t     * @param value - The value to send with the command.\n\t     */\n\t    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n\t        await provider.internal(via, {\n\t            value,\n\t            body: beginCell().endCell(),\n\t        })\n\t    }\n", "    /**\n\t     * Sends a mint command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the mint command.\n\t     * @param params - The parameters for the mint command.\n\t     */\n\t    async sendMint(provider: ContractProvider, via: Sender, params: { \n\t        queryId?: number, \n\t        value: bigint,\n\t        passAmount: bigint, \n", "        itemIndex: number, \n\t        itemOwnerAddress: Address, \n\t        itemContent: string \n\t    }) {\n\t        const itemContent = beginCell()\n\t        itemContent.storeBuffer(Buffer.from(params.itemContent)).endCell()\n\t        const nftItemMessage = beginCell()\n\t        nftItemMessage.storeAddress(params.itemOwnerAddress)\n\t        nftItemMessage.storeRef(itemContent).endCell()\n\t        await provider.internal(via, {\n", "            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(1, 32)\n\t                .storeUint(params.queryId || 0, 64)\n\t                .storeUint(params.itemIndex, 64)\n\t                .storeCoins(params.passAmount)\n\t                .storeRef(nftItemMessage)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n", "    }\n\t    /**\n\t     * Sends a change owner command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the change owner command.\n\t     * @param params - The parameters for the change owner command.\n\t     */\n\t    async sendChangeOwner(provider: ContractProvider, via: Sender, params: { \n\t        queryId?: number, \n\t        value: bigint,\n", "        newOwner: Address\n\t    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(OperationCodes.ChangeOwner, 32)\n\t                .storeUint(params.queryId || 0, 64)\n\t                .storeAddress(params.newOwner)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY\n", "        })\n\t    }\n\t}\n"]}
{"filename": "src/wrappers/getgems/NftAuctionV2/NftAuctionV2.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\n\t/**\n\t * Class representing an NFT auction contract version 2.\n\t */\n\texport class NftAuctionV2 implements Contract {\n\t    /**\n\t     * Creates an `NftAuctionV2` instance from an address and initialization data.\n\t     * @param address - The address of the contract.\n\t     * @param init - The initialization data.\n\t     * @returns A new `NftAuctionV2` instance.\n", "     */\n\t    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\t    static code = Cell.fromBoc(Buffer.from('te6cckECHQEABZMAART/APSkE/S88sgLAQIBIAIDAgFIBAUCKPIw2zyBA+74RMD/8vL4AH/4ZNs8GxwCAs4GBwKLoDhZtnm2eQQQgqqH8IXwofCH8KfwpfCd8JvwmfCX8JXwi/Cf8IwaIiYaGCIkGBYiIhYUIiAUIT4hHCD6INggtiD0INIgsRsaAgEgCAkCASAYGQT1AHQ0wMBcbDyQPpAMNs8+ELA//hDUiDHBbCO0DMx0x8hwACNBJyZXBlYXRfZW5kX2F1Y3Rpb26BSIMcFsI6DW9s84DLAAI0EWVtZXJnZW5jeV9tZXNzYWdlgUiDHBbCa1DDQ0wfUMAH7AOAw4PhTUhDHBY6EMzHbPOABgGxIKCwATIIQO5rKAAGphIAFcMYED6fhS10nCAvLygQPqAdMfghAFE42REroS8vSAQNch+kAw+HJw+GJ/+GTbPBwEhts8IMABjzgwgQPt+CP4UL7y8oED7fhCwP/y8oED8AKCEDuaygC5EvLy+FJSEMcF+ENSIMcFsfLhkwF/2zzbPOAgwAIMFQ0OAIwgxwDA/5IwcODTHzGLZjYW5jZWyCHHBZIwceCLRzdG9wghxwWSMHLgi2ZmluaXNoghxwWSMHLgi2ZGVwbG95gBxwWRc+BwAYpwIPglghBfzD0UyMsfyz/4Us8WUAPPFhLLACH6AssAyXGAGMjLBfhTzxZw+gLLasyCCA9CQHD7AsmDBvsAf/hif/hm2zwcBPyOwzAygQPt+ELA//LygQPwAYIQO5rKALny8vgj+FC+jhf4UlIQxwX4Q1IgxwWx+E1SIMcFsfLhk5n4UlIQxwXy4ZPi2zzgwAOSXwPg+ELA//gj+FC+sZdfA4ED7fLw4PhLghA7msoAoFIgvvhLwgCw4wL4UPhRofgjueMA+E4SDxARAiwCcNs8IfhtghA7msoAofhu+CP4b9s8FRIADvhQ+FGg+HADcI6VMoED6PhKUiC58vL4bvht+CP4b9s84fhO+EygUiC5l18DgQPo8vDgAnDbPAH4bfhu+CP4b9s8HBUcApT4TsAAjj1wIPglghBfzD0UyMsfyz/4Us8WUAPPFhLLACH6AssAyXGAGMjLBfhTzxZw+gLLasyCCA9CQHD7AsmDBvsA4w5/+GLbPBMcAvrbPPhOQFTwAyDCAI4rcCCAEMjLBVAHzxYi+gIWy2oVyx+L9NYXJrZXRwbGFjZSBmZWWM8WyXL7AJE04vhOQAPwAyDCAI4jcCCAEMjLBVAEzxYi+gITy2oSyx+LdSb3lhbHR5jPFsly+wCRMeKCCA9CQHD7AvhOWKEBoSDCABoUAMCOInAggBDIywX4Us8WUAP6AhLLassfi2UHJvZml0jPFsly+wCRMOJwIPglghBfzD0UyMsfyz/4Tc8WUAPPFhLLAIIImJaA+gLLAMlxgBjIywX4U88WcPoCy2rMyYMG+wAC8vhOwQGRW+D4TvhHoSKCCJiWgKFSELyZMAGCCJiWgKEBkTLijQpWW91ciBiaWQgaGFzIGJlZW4gb3V0YmlkIGJ5IGFub3RoZXIgdXNlci6ABwP+OHzCNBtBdWN0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZC6DeIcIA4w8WFwA4cCCAGMjLBfhNzxZQBPoCE8tqEssfAc8WyXL7AAACWwARIIQO5rKAKmEgAB0IMAAk18DcOBZ8AIB8AGAAIPhI0PpA0x/TH/pA0x/THzAAyvhBbt3tRNDSAAH4YtIAAfhk0gAB+Gb6QAH4bfoAAfhu0x8B+G/THwH4cPpAAfhy1AH4aNQw+Gn4SdDSHwH4Z/pAAfhj+gAB+Gr6AAH4a/oAAfhs0x8B+HH6QAH4c9MfMPhlf/hhAFT4SfhI+FD4T/hG+ET4QsjKAMoAygD4Tc8W+E76Assfyx/4Us8WzMzJ7VQBqlR8', 'base64'))[0]\n\t    /**\n\t     * Builds the data cell for the auction contract.\n\t     * @param data - The data for building the data cell.\n\t     * @returns The built data cell.\n\t     */\n\t    static buildDataCell(data: NftAuctionV2Data) {\n\t        const constantCell = beginCell()\n", "        const subGasPriceFromBid = 8449000\n\t        constantCell.storeUint(subGasPriceFromBid, 32)\n\t        constantCell.storeAddress(data.marketplaceAddress)\n\t        constantCell.storeCoins(data.minBid)\n\t        constantCell.storeCoins(data.maxBid)\n\t        constantCell.storeCoins(data.minStep)\n\t        constantCell.storeUint(data.stepTimeSeconds, 32) // step_time\n\t        constantCell.storeAddress(data.nftAddress)\n\t        constantCell.storeUint(data.createdAtTimestamp, 32)\n\t        const feesCell = beginCell()\n", "        feesCell.storeAddress(data.marketplaceFeeAddress)      // mp_fee_addr\n\t        feesCell.storeUint(data.marketplaceFeeFactor, 32)               // mp_fee_factor\n\t        feesCell.storeUint(data.marketplaceFeeBase, 32)   // mp_fee_base\n\t        feesCell.storeAddress(data.royaltyAddress)  // royalty_fee_addr\n\t        feesCell.storeUint(data.royaltyFactor, 32)              // royalty_fee_factor\n\t        feesCell.storeUint(data.royaltyBase, 32)   // royalty_fee_base\n\t        const storage = beginCell()\n\t        storage.storeBit(data.end) // end?\n\t        storage.storeBit(data.activated) // activated\n\t        storage.storeBit(false) // is_canceled\n", "        storage.storeBuffer(Buffer.from([0, 0]))        // last_member\n\t        storage.storeCoins(0)       // last_bid\n\t        storage.storeUint(0, 32) // last_bid_at\n\t        storage.storeUint(data.endTimestamp, 32)    // end_time\n\t        if (data.nftOwnerAddress) {\n\t            storage.storeAddress(data.nftOwnerAddress)\n\t        } else {\n\t            storage.storeBuffer(Buffer.from([0, 0]))\n\t        }\n\t        storage.storeRef(feesCell.endCell())\n", "        storage.storeRef(constantCell.endCell())\n\t        return storage.endCell()\n\t    }\n\t    /**\n\t     * Creates an `NftAuctionV2` instance from an address.\n\t     * @param address - The address to create from.\n\t     * @returns A new `NftAuctionV2` instance.\n\t     */\n\t    static createFromAddress(\n\t        address: Address,\n", "    ) {\n\t        return new NftAuctionV2(\n\t            address\n\t        )\n\t    }\n\t    /**\n\t     * Creates an `NftAuctionV2` instance from configuration data.\n\t     * @param config - The configuration data for creating the instance.\n\t     * @param workchain - The workchain ID (default: 0).\n\t     * @returns A new `NftAuctionV2` instance.\n", "     */\n\t    static createFromConfig(\n\t        config: NftAuctionV2Data,\n\t        workchain = 0\n\t    ) {\n\t        const data = this.buildDataCell(config)\n\t        const address = contractAddress(\n\t            workchain,\n\t            {\n\t                code: this.code,\n", "                data: data\n\t            }\n\t        )\n\t        return new NftAuctionV2(\n\t            address,\n\t            {\n\t                code: this.code,\n\t                data: data\n\t            }\n\t        )\n", "    }\n\t    /**\n\t     * Sends a deploy command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the deploy command.\n\t     * @param value - The value to send with the command.\n\t     */\n\t    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n\t        await provider.internal(via, {\n\t            value,\n", "            body: beginCell().endCell(),\n\t        })\n\t    }\n\t    /**\n\t     * Sends a cancel command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the cancel command.\n\t     * @param params - The parameters for the cancel command.\n\t     */\n\t    async sendCancel(provider: ContractProvider, via: Sender, params: { \n", "        value: bigint\n\t    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(0,32)\n\t                .storeBuffer(Buffer.from('cancel'))\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n", "    }\n\t    /**\n\t     * Sends a stop command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the stop command.\n\t     * @param params - The parameters for the stop command.\n\t     */\n\t    async sendStop(provider: ContractProvider, via: Sender, params: { \n\t        value: bigint\n\t    }) {\n", "        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(0,32)\n\t                .storeBuffer(Buffer.from('cancel'))\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t    /**\n", "     * Retrieves the sale data from the contract.\n\t     * @param provider - The contract provider.\n\t     * @returns The sale data.\n\t     */\n\t    async getSaleData(provider: ContractProvider) {\n\t        const { stack } = await provider.get('get_sale_data', [])\n\t        // pops out saleType\n\t        stack.pop()\n\t        return {\n\t            end: stack.readBigNumber(),\n", "            endTimestamp: stack.readBigNumber(),\n\t            marketplaceAddress: stack.readAddressOpt(),\n\t            nftAddress: stack.readAddressOpt(),\n\t            nftOwnerAddress: stack.readAddressOpt(),\n\t            lastBidAmount: stack.readBigNumber(),\n\t            lastBidAddress: stack.readAddressOpt(),\n\t            minStep: stack.readBigNumber(),\n\t            marketplaceFeeAddress: stack.readAddressOpt(),\n\t            marketplaceFeeFactor: stack.readBigNumber(), \n\t            marketplaceFeeBase: stack.readBigNumber(),\n", "            royaltyAddress: stack.readAddressOpt(),\n\t            royaltyFactor: stack.readBigNumber(), \n\t            royaltyBase: stack.readBigNumber(),\n\t            maxBid: stack.readBigNumber(),\n\t            minBid: stack.readBigNumber(),\n\t            createdAt: stack.readBigNumber(),\n\t            lastBidAt: stack.readBigNumber(),\n\t            isCanceled: stack.readBigNumber(),\n\t        }\n\t    }\n", "}\n\t/**\n\t * Type representing the data for an NFT auction contract version 2.\n\t */\n\texport type NftAuctionV2Data = {\n\t    marketplaceFeeAddress: Address,\n\t    marketplaceFeeFactor: bigint,\n\t    marketplaceFeeBase: bigint,\n\t    royaltyAddress: Address,\n\t    royaltyFactor: bigint,\n", "    royaltyBase: bigint,\n\t    minBid: bigint,\n\t    maxBid: bigint,\n\t    minStep: bigint,\n\t    endTimestamp: number,\n\t    createdAtTimestamp: number,\n\t    stepTimeSeconds: number,\n\t    tryStepTimeSeconds: number,\n\t    nftOwnerAddress: Address | null,\n\t    nftAddress: Address,\n", "    end: boolean,\n\t    marketplaceAddress: Address,\n\t    activated: boolean,\n\t}"]}
{"filename": "src/wrappers/getgems/NftSingle/NftSingle.ts", "chunked_list": ["import { Address, beginCell, Cell, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\n\timport { NftItemRoyalty } from '../../standard/NftItemRoyalty'\n\timport { storeOffchainContent } from '../../../types/Content'\n\t/**\n\t * Class representing a single Non-Fungible Token (NFT) with royalty.\n\t */\n\texport class NftSingle extends NftItemRoyalty {   \n\t    // Data\n\t    static code = Cell.fromBoc(Buffer.from('te6cckECFQEAAwoAART/APSkE/S88sgLAQIBYgcCAgEgBAMAI7x+f4ARgYuGRlgOS/uAFoICHAIBWAYFABG0Dp4AQgRr4HAAHbXa/gBNhjoaYfph/0gGEAICzgsIAgEgCgkAGzIUATPFljPFszMye1UgABU7UTQ+kD6QNTUMIAIBIA0MABE+kQwcLry4U2AEuQyIccAkl8D4NDTAwFxsJJfA+D6QPpAMfoAMXHXIfoAMfoAMPACBtMf0z+CEF/MPRRSMLqOhzIQRxA2QBXgghAvyyaiUjC64wKCEGk9OVBSMLrjAoIQHARBKlIwuoBMSEQ4BXI6HMhBHEDZAFeAxMjQ1NYIQGgudURK6n1ETxwXy4ZoB1NQwECPwA+BfBIQP8vAPAfZRNscF8uGR+kAh8AH6QNIAMfoAggr68IAboSGUUxWgod4i1wsBwwAgkgahkTbiIML/8uGSIY4+ghBRGkRjyFAKzxZQC88WcSRKFFRGsHCAEMjLBVAHzxZQBfoCFctqEssfyz8ibrOUWM8XAZEy4gHJAfsAEFeUECo4W+IQAIICjjUm8AGCENUydtsQN0UAbXFwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7AJMwMzTiVQLwAwBUFl8GMwHQEoIQqMsArXCAEMjLBVAFzxYk+gIUy2oTyx/LPwHPFsmAQPsAAIYWXwZsInDIywHJcIIQi3cXNSHIy/8D0BPPFhOAQHCAEMjLBVAHzxZQBfoCFctqEssfyz8ibrOUWM8XAZEy4gHJAfsAAfZRN8cF8uGR+kAh8AH6QNIAMfoAggr68IAboSGUUxWgod4i1wsBwwAgkgahkTbiIMIA8uGSIY4+ghAFE42RyFALzxZQC88WcSRLFFRGwHCAEMjLBVAHzxZQBfoCFctqEssfyz8ibrOUWM8XAZEy4gHJAfsAEGeUECo5W+IUAIICjjUm8AGCENUydtsQN0YAbXFwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7AJMwNDTiVQLwA+GNLv4=', 'base64'))[0]\n\t    /**\n", "     * Builds a data cell for the NFT.\n\t     * @param data - The data for the NFT.\n\t     * @returns The built data cell.\n\t     */\n\t    static buildDataCell(data: NftSingleData) {\n\t        const dataCell = beginCell()\n\t        const contentCell = storeOffchainContent({\n\t            type: 'offchain',\n\t            uri: data.content\n\t        })\n", "        const royaltyCell = beginCell()\n\t        royaltyCell.storeUint(data.royaltyParams.royaltyFactor, 16)\n\t        royaltyCell.storeUint(data.royaltyParams.royaltyBase, 16)\n\t        royaltyCell.storeAddress(data.royaltyParams.royaltyAddress)\n\t        dataCell.storeAddress(data.ownerAddress)\n\t        dataCell.storeAddress(data.editorAddress)\n\t        dataCell.store(contentCell)\n\t        dataCell.storeRef(royaltyCell)\n\t        return dataCell.endCell()\n\t    }\n", "    /**\n\t     * Creates an NftSingle instance from an address.\n\t     * @param address - The address to create from.\n\t     * @returns A new NftSingle instance.\n\t     */\n\t    static createFromAddress(\n\t        address: Address\n\t    ) {\n\t        return new NftSingle(\n\t            address\n", "        )\n\t    }\n\t    /**\n\t    * Creates an NftSingle instance from a config.\n\t    * @param config - The config to create from.\n\t    * @param workchain - The workchain to use (default is 0).\n\t    * @returns A new NftSingle instance.\n\t    */\n\t    static async createFromConfig(\n\t        config: NftSingleData,\n", "        workchain = 0\n\t    ) {\n\t        const data = this.buildDataCell(config)\n\t        const address = contractAddress(\n\t            workchain,\n\t            {\n\t                code: this.code,\n\t                data: data\n\t            }\n\t        )\n", "        return new NftSingle(\n\t            address,\n\t            {\n\t                code: this.code,\n\t                data: data\n\t            }\n\t        )\n\t    }\n\t    /**\n\t     * Sends a deploy command to the contract.\n", "     * @param provider - The contract provider.\n\t     * @param via - The sender of the deploy command.\n\t     * @param value - The value to send with the command.\n\t     */\n\t    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n\t        await provider.internal(via, {\n\t            value,\n\t            body: beginCell().endCell(),\n\t        })\n\t    }\n", "    /**\n\t     * Sends a transferEditorship command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the transferEditorship command.\n\t     * @param params - Parameters for the transferEditorship command including value, optional queryId, newEditor, responseTo, and optional forwardAmount.\n\t     */\n\t    async sendTransferEditorship(provider: ContractProvider, via: Sender, params: { \n\t        value: bigint, \n\t        queryId?: number,\n\t        newEditor: Address, \n", "        responseTo: Address|null,\n\t        forwardAmount?: bigint \n\t    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(0x1c04412a, 32)\n\t                .storeUint(params.queryId || 0, 64)\n\t                .storeAddress(params.newEditor)\n\t                .storeAddress(params.responseTo)\n", "                .storeBit(false)\n\t                .storeCoins(params.forwardAmount || 0)\n\t                .storeBit(false)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t}\n\t/**\n\t * Represents the parameters for royalty.\n", " */\n\texport type RoyaltyParams = {\n\t    // Numerator of the royalty factor.\n\t    royaltyFactor: number,\n\t    // Denominator of the royalty factor.\n\t    royaltyBase: number,\n\t    // Address to send the royalty to.\n\t    royaltyAddress: Address\n\t}\n\t/**\n", " * Represents the data for a single NFT.\n\t */\n\texport type NftSingleData = {\n\t    // Address of the owner of the NFT.\n\t    ownerAddress: Address,\n\t    // Address of the editor of the NFT.\n\t    editorAddress: Address,\n\t    // Content of the NFT.\n\t    content: string,\n\t    // Royalty parameters for the NFT.\n", "    royaltyParams: RoyaltyParams\n\t}"]}
{"filename": "src/wrappers/getgems/NftFixedPrice/NftFixedPrice.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, contractAddress } from 'ton-core'\n\t/**\n\t * Class representing a Non-Fungible Token (NFT) fixed price sale contract.\n\t */\n\texport class NftFixedPrice implements Contract {\n\t    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\t    static code = Cell.fromBoc(Buffer.from('te6cckECCgEAAbIAART/APSkE/S88sgLAQIBIAMCAATyMAIBSAUEADegOFnaiaH0gfSB9IH0AahhofQB9IH0gfQAYCBHAgLNCAYB99G8EIHc1lACkgUCkQX3lw4QFofQB9IH0gfQAYOEAIZGWCqATniyi6UJDQqFrQilAK/QEK5bVkuP2AOEAIZGWCrGeLKAP9AQtltWS4/YA4QAhkZYKsZ4ssfQFltWS4/YA4EEEIL+YeihDADGRlgqgC54sRfQEKZbUJ5Y+JwHAC7LPyPPFlADzxYSygAh+gLKAMmBAKD7AAH30A6GmBgLjYSS+CcH0gGHaiaH0gfSB9IH0AahgRa6ThAVnHHZkbGymQ44LJL4NwKJFjgvlw+gFpj8EIAonGyIldeXD66Z+Y/SAYIBpkKALniygB54sA54sA/QFmZPaqcBNjgEybCBsimYI4eAJwA2mP6Z+YEOAAyS+FcBDAkAtsACmjEQRxA2RUAS8ATgMjQ0NDXAA449ghA7msoAE77y4clwIIIQX8w9FCGAEMjLBVAHzxYi+gIWy2oVyx8Tyz8hzxYBzxYSygAh+gLKAMmBAKD7AOBfBIQP8vCVeDe4', 'base64'))[0]\n\t    /**\n\t     * Builds the data cell for an NFT fixed price sale.\n\t     * @param data - The data for the NFT sale.\n", "     * @returns A cell containing the data for the NFT sale.\n\t     */\n\t    static buildDataCell(data: NftFixPriceSaleData) {\n\t        const feesCell = beginCell()\n\t        feesCell.storeCoins(data.marketplaceFee)\n\t        feesCell.storeAddress(data.marketplaceFeeAddress)\n\t        feesCell.storeAddress(data.royaltyAddress)\n\t        feesCell.storeCoins(data.royaltyAmount)\n\t        const dataCell = beginCell()\n\t        dataCell.storeAddress(data.marketplaceAddress)\n", "        dataCell.storeAddress(data.nftAddress)\n\t        dataCell.storeAddress(data.nftOwnerAddress)\n\t        dataCell.storeCoins(data.fullPrice)\n\t        dataCell.storeRef(feesCell)\n\t        return dataCell.endCell()\n\t    }\n\t    /**\n\t     * Creates an NftFixedPrice instance from an address.\n\t     * @param address - The address to create from.\n\t     * @returns A new NftFixedPrice instance.\n", "     */\n\t    static createFromAddress(\n\t        address: Address\n\t    ) {\n\t        return new NftFixedPrice(\n\t            address\n\t        )\n\t    }\n\t    /**\n\t     * Creates an NftFixedPrice instance from a configuration object.\n", "     * @param config - The configuration data for the NFT sale.\n\t     * @param workchain - The workchain ID (default is 0).\n\t     * @returns A new NftFixedPrice instance.\n\t     */\n\t    static async createFromConfig(\n\t        config: NftFixPriceSaleData,\n\t        workchain = 0\n\t    ) {\n\t        const data = this.buildDataCell(config)\n\t        const address = contractAddress(\n", "            workchain,\n\t            {\n\t                code: this.code,\n\t                data: data\n\t            }\n\t        )\n\t        return new NftFixedPrice(\n\t            address,\n\t            {\n\t                code: this.code,\n", "                data: data\n\t            }\n\t        )\n\t    }\n\t    /**\n\t     * Sends a deploy command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the deploy command.\n\t     * @param value - The value to send with the command.\n\t     */\n", "    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n\t        await provider.internal(via, {\n\t            value,\n\t            body: beginCell().endCell(),\n\t        })\n\t    }\n\t    /**\n\t     * Retrieves the sale data from the contract.\n\t     * @param provider - The contract provider.\n\t     * @returns An object containing the sale data.\n", "     */\n\t    async getSaleData(provider: ContractProvider) {\n\t        const { stack } = await provider.get('get_sale_data', [])\n\t        return {\n\t            marketplaceAddress: stack.readAddressOpt(),\n\t            nftAddress: stack.readAddressOpt(),\n\t            nftOwnerAddress: stack.readAddressOpt(),\n\t            fullPrice: stack.readBigNumber(),\n\t            marketplaceFeeAddress: stack.readAddressOpt(),\n\t            marketplaceFee: stack.readBigNumber(),\n", "            royaltyAddress: stack.readAddressOpt(),\n\t            royaltyAmount:  stack.readBigNumber()\n\t        }\n\t    }\n\t}\n\t/**\n\t * Type definition for the data of an NFT fixed price sale.\n\t */\n\texport type NftFixPriceSaleData = {\n\t    marketplaceAddress: Address\n", "    nftAddress: Address\n\t    nftOwnerAddress: Address|null\n\t    fullPrice: bigint\n\t    marketplaceFee: bigint\n\t    marketplaceFeeAddress: Address\n\t    royaltyAmount: bigint\n\t    royaltyAddress: Address\n\t}"]}
{"filename": "src/wrappers/getgems/NftMarketplace/NftMarketplace.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, SendMode, contractAddress } from 'ton-core'\n\timport { KeyPair, sign } from 'ton-crypto'\n\t/**\n\t * Class representing a NFT Marketplace contract.\n\t */\n\texport class NftMarketplace implements Contract {\n\t    /**\n\t     * Constructs an instance of the NftMarketplace contract.\n\t     * @param address - The address of the contract.\n\t     * @param init - The initial code and data for the contract.\n", "     */\n\t    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\t    /**\n\t     * Creates an NftMarketplace instance from an address.\n\t     * @param address - The address to create from.\n\t     * @returns A new NftMarketplace instance.\n\t     */\n\t    static createFromAddress(\n\t        address: Address\n\t    ) {\n", "        return new NftMarketplace(\n\t            address\n\t        )\n\t    }\n\t    static code = Cell.fromBoc(Buffer.from('te6cckEBDAEA7wABFP8A9KQT9LzyyAsBAgEgAwIAePKDCNcYINMf0x/THwL4I7vyY/ABUTK68qFRRLryogT5AVQQVfkQ8qP4AJMg10qW0wfUAvsA6DABpALwAgIBSAcEAgFIBgUAEbjJftRNDXCx+AAXuznO1E0NM/MdcL/4AgLOCQgAF0AsjLH8sfy//J7VSAIBIAsKABU7UTQ0x/TH9P/MIACpGwiIMcAkVvgAdDTAzBxsJEw4PABbCEB0x8BwAGONIMI1xgg+QFAA/kQ8qPU1DAh+QBwyMoHy//J0Hd0gBjIywXLAljPFnD6AstrEszMyYBA+wDgW4NC26jQ=', 'base64'))[0]\n\t    /**\n\t     * Builds the data cell for an NFT marketplace.\n\t     * @param data - The data for the NFT marketplace.\n\t     * @returns A cell containing the data for the NFT marketplace.\n\t     */\n", "    static buildDataCell(data: NftMarketplaceData) {\n\t        const dataCell= beginCell()\n\t        dataCell.storeUint(data.seqno, 32)\n\t        dataCell.storeUint(data.subwallet, 32)\n\t        dataCell.storeBuffer(data.publicKey)\n\t        return dataCell.endCell()\n\t    }\n\t    /**\n\t     * Creates an NftMarketplace instance from a configuration object.\n\t     * @param config - The configuration data for the NFT marketplace.\n", "     * @param workchain - The workchain ID (default is 0).\n\t     * @returns A new NftMarketplace instance.\n\t     */\n\t    static async createFromConfig(\n\t        config: NftMarketplaceData,\n\t        workchain = 0\n\t    ) {\n\t        const data = this.buildDataCell(config)\n\t        const address = contractAddress(\n\t            workchain,\n", "            {\n\t                code: this.code,\n\t                data: data\n\t            }\n\t        )\n\t        return new NftMarketplace(\n\t            address,\n\t            {\n\t                code: this.code,\n\t                data: data\n", "            }\n\t        )\n\t    }\n\t    /**\n\t     * Sends a deploy command to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the deploy command.\n\t     * @param value - The value to send with the command.\n\t     */\n\t    async sendDeploy(provider: ContractProvider, via: Sender, value: bigint) {\n", "        await provider.internal(via, {\n\t            value,\n\t            body: beginCell().endCell(),\n\t        })\n\t    }\n\t    /**\n\t     * Sends coins to the contract.\n\t     * @param provider - The contract provider.\n\t     * @param via - The sender of the coins.\n\t     * @param params - Parameters for the operation, including the value and queryId.\n", "     */\n\t    async sendCoins(provider: ContractProvider, via: Sender, params: {\n\t        value: bigint\n\t        queryId: bigint\n\t    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(1, 32)\n\t                .storeUint(params.queryId, 64)\n", "                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t}\n\t/**\n\t * Type definition for the data of an NFT marketplace.\n\t */\n\texport type NftMarketplaceData = {\n\t    seqno: number\n", "    subwallet: number\n\t    publicKey: Buffer\n\t}\n\t/**\n\t * Builds a signature for an operation.\n\t * @param params - Parameters for the signature, including the key pair, sale state initialization, and sale message body.\n\t * @returns The generated signature.\n\t */\n\texport function buildSignature(params: { \n\t    keyPair: KeyPair, \n", "    saleStateInit: Cell, \n\t    saleMessageBody: Cell \n\t}) {\n\t    const bodyCell = beginCell()\n\t    bodyCell.storeRef(params.saleStateInit)\n\t    bodyCell.storeRef(params.saleMessageBody)\n\t    return sign(bodyCell.endCell().hash(), params.keyPair.secretKey)\n\t}"]}
{"filename": "src/wrappers/standard/NftCollection.ts", "chunked_list": ["import { Address, Cell, Contract, ContractProvider } from 'ton-core'\n\t/**\n\t * Represents a collection of NFT items.\n\t */\n\texport class NftCollection implements Contract {\n\t    /**\n\t     * Constructs an instance of the NftCollection contract.\n\t     * @param address - The address of the contract.\n\t     * @param init - Optional initialization data for the contract's code and data.\n\t     */\n", "    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\t    /**\n\t     * Constructs an instance of the NftCollection contract from an address.\n\t     * @param address - The address of the contract.\n\t     * @returns An instance of NftCollection.\n\t     */\n\t    static createFromAddress(\n\t        address: Address\n\t    ) {\n\t        return new NftCollection(\n", "            address\n\t        )\n\t    }\n\t    /**\n\t     * Retrieves the collection data from the contract.\n\t     * @param provider - The ContractProvider to facilitate the data retrieval.\n\t     * @returns An object with the collection data.\n\t     */\n\t    async getCollectionData(\n\t        provider: ContractProvider\n", "    ) {\n\t        const { stack } = await provider.get('get_collection_data', [])\n\t        return {\n\t            nextItemIndex: stack.readBigNumber(),\n\t            collectionContent: stack.readCellOpt(),\n\t            ownerAddress: stack.readAddressOpt(),\n\t        }\n\t    }\n\t    /**\n\t     * Retrieves the NFT address by index from the contract.\n", "     * @param provider - The ContractProvider to facilitate the data retrieval.\n\t     * @param index - The index of the NFT in the collection.\n\t     * @returns An object with the NFT address.\n\t     */\n\t    async getNftAddressByIndex(\n\t        provider: ContractProvider,\n\t        index: bigint\n\t    ) {\n\t        const { stack } = await provider.get('get_nft_address_by_index', [\n\t            { type: 'int', value: index }\n", "        ])\n\t        return {\n\t            nftAddress: stack.readAddressOpt(),\n\t        }\n\t    }\n\t    /**\n\t     * Retrieves the NFT content from the contract.\n\t     * @param provider - The ContractProvider to facilitate the data retrieval.\n\t     * @param index - The index of the NFT in the collection.\n\t     * @param individualContent - The individual content of the NFT.\n", "     * @returns An object with the full NFT content.\n\t     */\n\t    async getNftContent(\n\t        provider: ContractProvider,\n\t        index: bigint,\n\t        individualContent: Cell\n\t    ) {\n\t        const { stack } = await provider.get('get_nft_content', [\n\t            { type: 'int', value: index },\n\t            { type: 'cell', cell: individualContent }\n", "        ])\n\t        return {\n\t            fullContent: stack.readCellOpt(),\n\t        }\n\t    }\n\t}"]}
{"filename": "src/wrappers/standard/NftCollectionRoyalty.ts", "chunked_list": ["import { Address, ContractProvider, Sender, SendMode, beginCell } from 'ton-core'\n\timport { NftCollection } from './NftCollection'\n\t/**\n\t * Represents a collection of NFT items with royalty features.\n\t * Inherits from the NftCollection class.\n\t */\n\texport class NftCollectionRoyalty extends NftCollection {\n\t    /**\n\t     * Constructs an instance of the NftCollectionRoyalty contract from an address.\n\t     * @param address - The address of the contract.\n", "     * @returns An instance of NftCollectionRoyalty.\n\t     */\n\t    static createFromAddress(\n\t        address: Address\n\t    ) {\n\t        return new NftCollectionRoyalty(\n\t            address\n\t        )\n\t    }\n\t    /**\n", "     * Sends a request to get the royalty parameters from the contract.\n\t     * @param provider - The ContractProvider to facilitate the data retrieval.\n\t     * @param via - The Sender initiating the data retrieval.\n\t     * @param params - The parameters for the data retrieval.\n\t     */\n\t    async sendGetRoyaltyParams(\n\t        provider: ContractProvider,\n\t        via: Sender,\n\t        params: {\n\t            value: bigint\n", "            queryId: bigint\n\t        }\n\t    ) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(0x693d3950, 32)\n\t                .storeUint(params.queryId, 64)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n", "        })\n\t    }\n\t    /**\n\t     * Retrieves the royalty parameters of the NFT collection from the contract.\n\t     * @param provider - The ContractProvider to facilitate the data retrieval.\n\t     * @returns An object with the royalty parameters.\n\t     */\n\t    async getRoyaltyParams(\n\t        provider: ContractProvider\n\t    ) {\n", "        const { stack } = await provider.get('royalty_params', [])\n\t        return {\n\t            init: stack.readBoolean(),\n\t            numerator: stack.readBigNumber(),\n\t            denominator: stack.readBigNumber(),\n\t            destination: stack.readAddressOpt()\n\t        }\n\t    }\n\t}"]}
{"filename": "src/wrappers/standard/NftItem.ts", "chunked_list": ["import { Address, beginCell, Cell, Contract, ContractProvider, Sender, Transaction, SendMode, ExternalAddress } from 'ton-core'\n\timport { isEligibleTransaction } from '../../utils/EligibleInternalTx'\n\timport { Maybe } from 'ton-core/dist/utils/maybe'\n\t/**\n\t * Represents an NFT item contract. \n\t */\n\texport class NftItem implements Contract {\n\t    constructor(readonly address: Address, readonly init?: { code: Cell; data: Cell }) {}\n\t    /**\n\t     * Sends a transfer from the contract.\n", "     * @param provider - The ContractProvider to facilitate the transfer.\n\t     * @param via - The Sender initiating the transfer.\n\t     * @param params - The parameters for the transfer.\n\t     */\n\t    async sendTransfer(provider: ContractProvider, via: Sender, params: {\n\t        value: bigint\n\t        queryId: bigint\n\t        newOwner: Address\n\t        responseDestination?: Address\n\t        customPayload?: Cell\n", "        forwardAmount: bigint\n\t        forwardPayload?: Cell\n\t    }) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(0x5fcc3d14, 32)\n\t                .storeUint(params.queryId, 64)\n\t                .storeAddress(params.newOwner)\n\t                .storeAddress(params.responseDestination)\n", "                .storeMaybeRef(params.customPayload)\n\t                .storeCoins(params.forwardAmount)\n\t                .storeMaybeRef(params.forwardPayload)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n\t    /**\n\t     * Gets static data from the contract.\n\t     * @param provider - The ContractProvider to facilitate the data retrieval.\n", "     * @param via - The Sender initiating the data retrieval.\n\t     * @param params - The parameters for the data retrieval.\n\t     */\n\t    async sendGetStaticData(\n\t        provider: ContractProvider,\n\t        via: Sender,\n\t        params: {\n\t            value: bigint\n\t            queryId: bigint\n\t        }\n", "    ) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(0x2fcb26a2, 32)\n\t                .storeUint(params.queryId || 0, 64)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n\t        })\n\t    }\n", "    // Getter Functions\n\t    /**\n\t     * Retrieves the data of the NFT from the contract.\n\t     * @param provider - The ContractProvider to facilitate the data retrieval.\n\t     */\n\t    async getNftData(provider: ContractProvider) {\n\t        const { stack } = await provider.get('get_nft_data', [])\n\t        return {\n\t            init: stack.readBoolean(),\n\t            index: stack.readBigNumber(),\n", "            collectionAddress: stack.readAddressOpt(),\n\t            ownerAddress: stack.readAddressOpt(),\n\t            individualContent: stack.readCellOpt(),\n\t        }\n\t    }\n\t    // Transaction Parsing\n\t    /**\n\t     * Parses a transfer transaction.\n\t     * @param tx - The Transaction to be parsed.\n\t     * @returns A NftTransfer object if the transaction is valid, undefined otherwise.\n", "     */\n\t    static parseTransfer(tx: Transaction): NftTransfer | undefined {\n\t        try {\n\t            const body = tx.inMessage?.body.beginParse()\n\t            if (body === undefined) return undefined \n\t            const op = body.loadUint(32)\n\t            if (op !== 0x5fcc3d14) return undefined \n\t            if (!isEligibleTransaction(tx)) {\n\t                return undefined\n\t            } \n", "            return {\n\t                queryId: body.loadUint(64),\n\t                from: tx.inMessage?.info.src ?? undefined,\n\t                to: body.loadAddress(),\n\t                responseTo: body.loadAddress(),\n\t                customPayload: body.loadMaybeRef(),\n\t                forwardAmount: body.loadCoins(),\n\t                forwardPayload: body.loadMaybeRef(),\n\t            }\n\t        } catch (e) { console.log(e) }\n", "        return undefined\n\t    }\n\t}\n\t/**\n\t * Represents the data structure of an NFT transfer.\n\t */\n\texport type NftTransfer = {\n\t    queryId: number\n\t    from?: Address | Maybe<ExternalAddress>\n\t    to: Address\n", "    responseTo?: Address\n\t    customPayload: Cell | null\n\t    forwardAmount: bigint\n\t    forwardPayload: Cell | null\n\t}"]}
{"filename": "src/wrappers/standard/NftItemRoyalty.ts", "chunked_list": ["import { Address, beginCell, ContractProvider, Sender, SendMode } from 'ton-core'\n\timport { NftItem } from './NftItem'\n\t/**\n\t * Represents an NFT item contract with royalty features.\n\t * Inherits from the NftItem class.\n\t */\n\texport class NftItemRoyalty extends NftItem {\n\t    /**\n\t     * Constructs an instance of the NftItemRoyalty contract from an address.\n\t     * @param address - The address of the contract.\n", "     * @returns An instance of NftItemRoyalty.\n\t     */\n\t    static createFromAddress(\n\t        address: Address\n\t    ) {\n\t        return new NftItemRoyalty(\n\t            address\n\t        )\n\t    }\n\t    /**\n", "     * Sends a request to get the royalty parameters from the contract.\n\t     * @param provider - The ContractProvider to facilitate the data retrieval.\n\t     * @param via - The Sender initiating the data retrieval.\n\t     * @param params - The parameters for the data retrieval.\n\t     */\n\t    async sendGetRoyaltyParams(\n\t        provider: ContractProvider,\n\t        via: Sender,\n\t        params: {\n\t            value: bigint\n", "            queryId: bigint\n\t        }\n\t    ) {\n\t        await provider.internal(via, {\n\t            value: params.value,\n\t            body: beginCell()\n\t                .storeUint(0x693d3950, 32)\n\t                .storeUint(params.queryId, 64)\n\t                .endCell(),\n\t            sendMode: SendMode.PAY_GAS_SEPARATELY,\n", "        })\n\t    }\n\t    /**\n\t     * Retrieves the royalty parameters of the NFT from the contract.\n\t     * @param provider - The ContractProvider to facilitate the data retrieval.\n\t     * @returns An object with the royalty parameters.\n\t     */\n\t    async getRoyaltyParams(\n\t        provider: ContractProvider\n\t    ) {\n", "        const { stack } = await provider.get('royalty_params', [])\n\t        return {\n\t            init: stack.readBoolean(),\n\t            numerator: stack.readBigNumber(),\n\t            denominator: stack.readBigNumber(),\n\t            destination: stack.readAddressOpt()\n\t        }\n\t    }\n\t}\n"]}
{"filename": "src/types/Content.ts", "chunked_list": ["import { beginCell, Builder, Slice, Dictionary } from 'ton-core'\n\timport {sha256_sync} from 'ton-crypto'\n\t// offchain#01 uri:Text = FullContent\n\ttype OnchainContent = {\n\t    type: 'onchain'\n\t    knownKeys: Map<string, string>\n\t    unknownKeys: Map<bigint, string>\n\t};\n\ttype OffchainContent = {\n\t    type: 'offchain'\n", "    uri: string\n\t};\n\ttype FullContent = OnchainContent | OffchainContent;\n\tconst propertyNames = ['uri', 'name', 'description', 'image', 'image_data']\n\t// onchain#00 data:(HashMapE 256 ^ContentData) = FullContent;\n\t// offchain#01 uri:Text = FullContent;\n\t// preloads a uint8 then calls either the onchain or the offchain variant\n\texport function loadFullContent(slice: Slice): FullContent {\n\t    const data = slice.preloadUint(8)\n\t    switch (data) {\n", "    case 0x00:\n\t        return loadOnchainContent(slice)\n\t    case 0x01:\n\t        return loadOffchainContent(slice)\n\t    default:    \n\t        throw new Error(`Unknown content type: ${data.toString(16)}`)\n\t    }\n\t}\n\texport function storeFullContent(src: FullContent): (builder: Builder) => void {\n\t    switch (src.type) {\n", "    case 'onchain':\n\t        return storeOnchainContent(src)\n\t    case 'offchain':\n\t        return storeOffchainContent(src)\n\t    default:\n\t        throw new Error('Unknown content type')\n\t    }\n\t}\n\t// onchain#00 data:(HashMapE 256 ^ContentData) = FullContent;\n\t// loads a uint8, checks that it is 0x00, calls loadOnchainDict, inserts known keys into the respective fields\n", "export function loadOnchainContent(slice: Slice): OnchainContent {\n\t    const data = slice.loadUint(8)\n\t    if (data !== 0x00) {\n\t        throw new Error(`Unknown content type: ${data.toString(16)}`)\n\t    }\n\t    const onchainDict = loadOnchainDict(slice)\n\t    const knownKeys = new Map<string, string>()\n\t    for (const knownProperty of propertyNames) {\n\t        const hashedKey = BigInt('0x' + sha256_sync(knownProperty).toString('hex'))\n\t        const value = onchainDict.get(hashedKey)\n", "        if (onchainDict.has(hashedKey) && value !== undefined) {\n\t            knownKeys.set(knownProperty, value)\n\t        }\n\t    }\n\t    return {\n\t        type: 'onchain',\n\t        knownKeys,\n\t        unknownKeys: onchainDict\n\t    }\n\t}\n", "export function storeOnchainContent(src: OnchainContent): (builder: Builder) => void {\n\t    const map = new Map<bigint, string>()\n\t    for (const [key, value] of src.unknownKeys) map.set(key, value)\n\t    for (const [key] of src.knownKeys) {\n\t        const hashedKey = BigInt('0x' + sha256_sync(key).toString('hex'))\n\t        map.set(hashedKey, key)\n\t    }\n\t    return (builder: Builder) => {\n\t        builder.storeUint(8, 0x00)\n\t        builder.store(storeOnchainDict(map))\n", "    }\n\t}\n\t// offchain#01 uri:Text = FullContent;\n\t// loads a uint8, checks that it is 0x01, calls loadSnakeData\n\texport function loadOffchainContent(slice: Slice): OffchainContent {\n\t    const prefix = slice.loadUint(8)\n\t    if (prefix !== 0x01) {\n\t        throw new Error(`Unknown content prefix: ${prefix.toString(16)}`)\n\t    }\n\t    return {\n", "        type: 'offchain',\n\t        uri: slice.loadStringTail()\n\t    }\n\t}\n\texport function storeOffchainContent(src: OffchainContent): (builder: Builder) => void {\n\t    return (builder: Builder) => {\n\t        builder\n\t            .storeUint(0x01, 8)\n\t            .storeStringTail(src.uri)\n\t    }\n", "}\n\t// snake#00 data:(SnakeData ~n) = ContentData;\n\t// chunks#01 data:ChunkedData = ContentData;\n\t// preloads a uint8 then calls either loadSnakeData or loadChunkedData\n\texport function loadContentData(slice: Slice): string {\n\t    const data = slice.preloadUint(8)\n\t    switch (data) {\n\t    case 0x00:\n\t        return loadSnakeData(slice)\n\t    case 0x01:\n", "        return loadChunkedData(slice)\n\t    default:\n\t        throw new Error(`Unknown content type: ${data.toString(16)}`)\n\t    }\n\t}\n\t// notice that there is no storeContentData\n\t// snake#00 data:(SnakeData ~n) = ContentData;\n\t// loads a uint8, checks that it is 0x00, calls slice.loadStringTail\n\texport function loadSnakeData(slice: Slice): string {\n\t    const prefix = slice.loadUint(8)\n", "    if (prefix !== 0x00) {\n\t        throw new Error(`Unknown content prefix: ${prefix.toString(16)}`)\n\t    }\n\t    return slice.loadStringTail()\n\t}\n\texport function storeSnakeData(src: string): (builder: Builder) => void {\n\t    return (builder: Builder) => {\n\t        builder\n\t            .storeUint(0x00, 8)\n\t            .storeStringTail(src)\n", "    }\n\t}\n\t// chunks#01 data:ChunkedData = ContentData;\n\t// chunked_data#_ data:(HashMapE 32 ^(SnakeData ~0)) = ChunkedData;\n\t// notice that above it is `SnakeData ~0` which means `the last layer` so there must be no refs in it, and it should be an integer number of bytes\n\t// loads a uint8, checks that it is 0x01, calls loadChunkedRaw\n\texport function loadChunkedData(slice: Slice): string {\n\t    const prefix = slice.loadUint(8)\n\t    if (prefix !== 0x01) {\n\t        throw new Error(`Unknown content prefix: ${prefix.toString(16)}`)\n", "    }\n\t    return loadChunkedRaw(slice)\n\t}\n\texport function storeChunkedData(src: string): (builder: Builder) => void {\n\t    return (builder: Builder) => {\n\t        builder\n\t            .storeUint(0x01, 8)\n\t            .store(storeChunkedRaw(src))\n\t    }\n\t}\n", "// these two only work with the dict (HashMapE 32 ^(SnakeData ~0))\n\t// load must iterate over all parts and combine them, store must split the string as needed\n\texport function loadChunkedRaw(slice: Slice): string {\n\t    const dict = slice.loadDict(\n\t        Dictionary.Keys.Uint(32), \n\t        Dictionary.Values.Cell()\n\t    )\n\t    let data = ''\n\t    for (let i = 0; i < dict.size; i++) {\n\t        const value = dict.get(i)\n", "        if (!value) {\n\t            throw new Error(`Missing value for key: ${i.toString(16)}`)\n\t        }\n\t        data += (value.beginParse().loadStringRefTail())\n\t    }\n\t    return data\n\t}\n\texport function storeChunkedRaw(src: string): (builder: Builder) => void {\n\t    const dict = Dictionary.empty(\n\t        Dictionary.Keys.Uint(32),\n", "        Dictionary.Values.Cell()\n\t    )\n\t    const nChunks = Math.ceil(src.length / 127)\n\t    for (let i = 0; i < nChunks; i++) {\n\t        const chunk = src.slice(i * 127, (i + 1) * 127)\n\t        dict.set(i, beginCell().storeStringRefTail(chunk).endCell())\n\t    }\n\t    return (builder: Builder) => {\n\t        builder\n\t            .storeDict(\n", "                dict\n\t            )\n\t    }\n\t}\n\t// uses the Dictionary primitive with loadContentData to parse the dict\n\texport function loadOnchainDict(slice: Slice): Map<bigint, string> {\n\t    const dict = slice.loadDict(\n\t        Dictionary.Keys.BigUint(256), \n\t        Dictionary.Values.Cell()\n\t    )\n", "    const data = new Map<bigint, string>()\n\t    for (const [key, value] of dict) {\n\t        data.set(key, loadContentData(value.beginParse()))\n\t    }\n\t    return data\n\t}\n\t// uses the Dictionary primitive and either storeSnakeData or storeChunkedData (probably just choose the former one for now)\n\texport function storeOnchainDict(src: Map<bigint, string>): (builder: Builder) => void {\n\t    const dict = Dictionary.empty(\n\t        Dictionary.Keys.BigUint(256),\n", "        Dictionary.Values.Cell()\n\t    )\n\t    for (const [key, value] of src) {\n\t        dict.set(key, beginCell().store(storeSnakeData(value)).endCell())\n\t    }\n\t    return (builder: Builder) => {\n\t        builder.storeDict(dict)\n\t    }\n\t}"]}
{"filename": "src/transaction-parsing/index.ts", "chunked_list": ["import { Transaction } from \"ton-core\"\n\texport function parseTransaction<E extends ((input: Transaction) => any)>(tx: Transaction, parsers: E[]): (E extends ((input: Transaction) => infer RR) ? RR : never) | undefined {\n\t    for (const p of parsers) {\n\t        const parsed = p(tx);\n\t        if (parsed !== undefined) return parsed;\n\t    }\n\t    return undefined;\n\t}"]}
