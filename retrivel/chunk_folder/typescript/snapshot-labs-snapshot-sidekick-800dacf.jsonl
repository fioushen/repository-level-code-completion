{"filename": "jest.config.ts", "chunked_list": ["/*\n\t * For a detailed explanation regarding each configuration property and type check, visit:\n\t * https://jestjs.io/docs/configuration\n\t */\n\texport default {\n\t  clearMocks: true,\n\t  collectCoverage: true,\n\t  coverageThreshold: {\n\t    global: {\n\t      lines: 50\n", "    }\n\t  },\n\t  collectCoverageFrom: ['./src/**'],\n\t  coverageDirectory: 'coverage',\n\t  coverageProvider: 'v8',\n\t  // An array of regexp pattern strings used to skip coverage collection\n\t  coveragePathIgnorePatterns: ['/node_modules/', '<rootDir>/dist/', '<rootDir>/test/fixtures/'],\n\t  preset: 'ts-jest',\n\t  testEnvironment: 'jest-environment-node-single-context',\n\t  setupFiles: ['dotenv/config'],\n", "  //setupFilesAfterEnv: ['<rootDir>src/setupTests.ts'],\n\t  moduleFileExtensions: ['js', 'ts'],\n\t  testPathIgnorePatterns: ['dist/'],\n\t  verbose: true\n\t};\n"]}
{"filename": "test/fixtures/moderation.ts", "chunked_list": ["// Mock return results from SQL\n\texport const SqlFixtures: Record<string, any[]> = {\n\t  flaggedLinks: [\n\t    { action: 'flag', type: 'link', value: 'https://gogle.com', created: 100 },\n\t    { action: 'flag', type: 'link', value: 'https://facebook.com', created: 100 }\n\t  ],\n\t  flaggedProposals: [\n\t    { action: 'flag', type: 'proposal', value: '0x1', created: 100 },\n\t    { action: 'flag', type: 'proposal', value: '0x2', created: 100 }\n\t  ],\n", "  flaggedSpaces: [\n\t    { action: 'flag', type: 'space', value: 'space3.eth', created: 100 },\n\t    { action: 'flag', type: 'space', value: 'space4.eth', created: 100 }\n\t  ],\n\t  flaggedIps: [\n\t    {\n\t      action: 'flag',\n\t      type: 'ip',\n\t      value: '12ca17b49af2289436f303e0166030a21e525d266e209267433801a8fd4071a0',\n\t      created: 100\n", "    },\n\t    {\n\t      action: 'flag',\n\t      type: 'ip',\n\t      value: '19e36255972107d42b8cecb77ef5622e842e8a50778a6ed8dd1ce94732daca9e',\n\t      created: 100\n\t    }\n\t  ],\n\t  verifiedSpaces: [\n\t    { action: 'verify', type: 'space', value: 'space1.eth', created: 100 },\n", "    { action: 'verify', type: 'space', value: 'space2.eth', created: 100 }\n\t  ]\n\t};\n"]}
{"filename": "test/e2e/nftClaimer.test.ts", "chunked_list": ["import request from 'supertest';\n\tconst HOST = `http://localhost:${process.env.PORT || 3003}`;\n\tdescribe('nftClaimer', () => {\n\t  describe('GET /api/nft-claimer', () => {\n\t    it('returns an object with the snapshotFee', async () => {\n\t      const response = await request(HOST).get('/api/nft-claimer');\n\t      const fee = response.body.snapshotFee;\n\t      expect(response.statusCode).toBe(200);\n\t      expect(fee).toBeLessThan(100);\n\t      expect(fee).toBeGreaterThanOrEqual(1);\n", "    });\n\t  });\n\t});\n"]}
{"filename": "test/e2e/votesReport.test.ts", "chunked_list": ["import request from 'supertest';\n\timport VotesReport from '../../src/lib/votesReport';\n\timport { storageEngine } from '../../src/helpers/utils';\n\timport { rmSync } from 'fs';\n\tconst HOST = `http://localhost:${process.env.PORT || 3003}`;\n\tdescribe('GET /api/votes/:id', () => {\n\t  const id = '0x1e5fdb5c87867a94c1c7f27025d62851ea47f6072f2296ca53a48fce1b87cdef';\n\t  const storage = storageEngine(process.env.VOTE_REPORT_SUBDIR);\n\t  afterEach(() => {\n\t    rmSync(storage.path(), { recursive: true });\n", "  });\n\t  describe('when the cache exists', () => {\n\t    const votesReport = new VotesReport(id, storage);\n\t    beforeAll(async () => {\n\t      await votesReport.createCache();\n\t    });\n\t    it('returns the cached file', async () => {\n\t      const response = await request(HOST).post(`/api/votes/${id}`);\n\t      expect(response.statusCode).toBe(200);\n\t      expect(response.text).toEqual((await votesReport.getCache()).toString());\n", "    });\n\t  });\n\t  describe('when the cache does not exist', () => {\n\t    describe('when the proposal exists', () => {\n\t      it('returns a 202 status code, and creates the cache', async () => {\n\t        const response = await request(HOST).post(`/api/votes/${id}`);\n\t        expect(response.statusCode).toBe(202);\n\t        const votesReport = new VotesReport(id, storage);\n\t        expect(typeof (await votesReport.getCache())).not.toBe(false);\n\t      });\n", "    });\n\t    describe('when proposal does not exist', () => {\n\t      it('returns a 404 error', async () => {\n\t        const response = await request(HOST).post('/api/votes/0x000');\n\t        expect(response.statusCode).toBe(404);\n\t      });\n\t    });\n\t  });\n\t});\n"]}
{"filename": "test/e2e/moderation.test.ts", "chunked_list": ["import request from 'supertest';\n\timport db from '../../src/helpers/mysql';\n\timport { SqlFixtures as moderation } from '../fixtures/moderation';\n\tconst HOST = `http://localhost:${process.env.PORT || 3003}`;\n\tdescribe('GET /api/moderation', () => {\n\t  beforeAll(async () => {\n\t    const data = Object.values(moderation)\n\t      .flat()\n\t      .map(d => Object.values(d));\n\t    await db.queryAsync(`INSERT INTO moderation (action, type, value, created) VALUES ?`, [\n", "      data as any\n\t    ]);\n\t  });\n\t  afterAll(async () => {\n\t    await db.queryAsync('DELETE FROM sidekick_test.moderation;');\n\t    await db.endAsync();\n\t  });\n\t  describe('when list params is empty', () => {\n\t    it('returns all the list', async () => {\n\t      const response = await request(HOST).get('/api/moderation');\n", "      expect(response.statusCode).toBe(200);\n\t      expect(response.body).toMatchSnapshot();\n\t    });\n\t  });\n\t  describe('when list params is set', () => {\n\t    it.each(['flaggedLinks', 'verifiedSpaces', 'flaggedProposals', 'verifiedTokens'])(\n\t      'returns only the selected %s list',\n\t      async field => {\n\t        const response = await request(HOST).get(`/api/moderation?list=${field}`);\n\t        expect(response.statusCode).toBe(200);\n", "        expect(response.body).toMatchSnapshot();\n\t      }\n\t    );\n\t  });\n\t  it('returns multiple list: verifiedSpaces,flaggedProposals', async () => {\n\t    const response = await request(HOST).get(\n\t      `/api/moderation?list=verifiedSpaces,flaggedProposals`\n\t    );\n\t    expect(response.statusCode).toBe(200);\n\t    expect(response.body).toMatchSnapshot();\n", "  });\n\t  it('ignores invalid field, and returns only verifiedSpaces', async () => {\n\t    const response = await request(HOST).get(`/api/moderation?list=verifiedSpaces,testInvalid`);\n\t    expect(response.statusCode).toBe(200);\n\t    expect(response.body).toMatchSnapshot();\n\t  });\n\t});\n"]}
{"filename": "test/unit/lib/moderationList.test.ts", "chunked_list": ["import getModerationList from '../../../src/lib/moderationList';\n\timport { SqlFixtures } from '../../fixtures/moderation';\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst mockDbQueryAsync = jest.fn((query: string, args?: string[]): any[] => {\n\t  return [];\n\t});\n\tjest.mock('../../../src/helpers/mysql', () => ({\n\t  __esModule: true,\n\t  default: { queryAsync: (query: string, args?: string[]) => mockDbQueryAsync(query, args) }\n\t}));\n", "describe('moderationList', () => {\n\t  it.each(['flaggedLinks', 'verifiedSpaces', 'flaggedProposals'])(\n\t    'returns only the %s',\n\t    async field => {\n\t      mockDbQueryAsync.mockImplementationOnce(() => {\n\t        return SqlFixtures[field];\n\t      });\n\t      const list = await getModerationList([field]);\n\t      expect(list).toMatchSnapshot();\n\t    }\n", "  );\n\t  it('returns multiple list: flaggedLinks and verifiedSpaces', async () => {\n\t    mockDbQueryAsync.mockImplementationOnce(() => {\n\t      return SqlFixtures.flaggedLinks.concat(SqlFixtures.verifiedSpaces);\n\t    });\n\t    const list = await getModerationList(['flaggedLinks', 'verifiedSpaces']);\n\t    expect(list).toMatchSnapshot();\n\t  });\n\t  it('ignores invalid fields, and only returns verifiedSpaces', async () => {\n\t    mockDbQueryAsync.mockImplementationOnce(() => {\n", "      return SqlFixtures.verifiedSpaces;\n\t    });\n\t    const list = await getModerationList(['a', 'b', 'verifiedSpaces']);\n\t    expect(list).toMatchSnapshot();\n\t  });\n\t  it('returns all fields by default', async () => {\n\t    mockDbQueryAsync.mockImplementationOnce(() => {\n\t      return Object.values(SqlFixtures).flat();\n\t    });\n\t    const list = await getModerationList();\n", "    expect(list).toMatchSnapshot();\n\t  });\n\t});\n"]}
{"filename": "test/unit/lib/votesReport.test.ts", "chunked_list": ["import { readFileSync, rmSync } from 'fs';\n\timport VotesReport from '../../../src/lib/votesReport';\n\timport { storageEngine } from '../../../src/helpers/utils';\n\tconst TEST_CACHE_DIR = 'test-cache';\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst mockFetchProposal = jest.fn((id: string): any => {\n\t  return [];\n\t});\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst mockFetchVotes = jest.fn((id: string): any => {\n", "  return [];\n\t});\n\tjest.mock('../../../src/helpers/snapshot', () => {\n\t  const originalModule = jest.requireActual('../../../src/helpers/snapshot');\n\t  return {\n\t    __esModule: true,\n\t    ...originalModule,\n\t    fetchProposal: (id: string) => mockFetchProposal(id),\n\t    fetchVotes: (id: string) => mockFetchVotes(id)\n\t  };\n", "});\n\tdescribe('VotesReport', () => {\n\t  const id = '0x1e5fdb5c87867a94c1c7f27025d62851ea47f6072f2296ca53a48fce1b87cdef';\n\t  const weightedId = '0x79ae5f9eb3c710179cfbf706fa451459ddd18d4b0bce37c22aae601128efe927';\n\t  const testStorageEngine = storageEngine(TEST_CACHE_DIR);\n\t  const space = { id: '', name: '', network: '', settings: '' };\n\t  function fixtureFilePath(id: string) {\n\t    return `${__dirname}/../../fixtures/snapshot-votes-report-${id}.csv`;\n\t  }\n\t  afterAll(() => {\n", "    rmSync(testStorageEngine.path(), { recursive: true });\n\t  });\n\t  it.each([\n\t    ['single', id],\n\t    ['weighted', weightedId]\n\t  ])('generates a %s choices votes report', async (type: string, pid: string) => {\n\t    const report = new VotesReport(pid, testStorageEngine);\n\t    mockFetchProposal.mockResolvedValueOnce(\n\t      JSON.parse(readFileSync(`${__dirname}/../../fixtures/hub-proposal-${pid}.json`, 'utf8'))\n\t    );\n", "    mockFetchVotes.mockResolvedValueOnce(\n\t      JSON.parse(readFileSync(`${__dirname}/../../fixtures/hub-votes-${pid}.json`, 'utf8'))\n\t    );\n\t    const content = await report.getContent();\n\t    expect(content).toEqual(readFileSync(fixtureFilePath(pid), 'utf8'));\n\t    expect(mockFetchProposal).toHaveBeenCalled();\n\t    expect(mockFetchVotes).toHaveBeenCalled();\n\t  });\n\t  describe('isCacheable()', () => {\n\t    it('raises an error when the proposal does not exist', () => {\n", "      const report = new VotesReport('test', testStorageEngine);\n\t      mockFetchProposal.mockResolvedValueOnce(null);\n\t      expect(report.isCacheable()).rejects.toBe('RECORD_NOT_FOUND');\n\t      expect(mockFetchProposal).toHaveBeenCalled();\n\t    });\n\t    it('raises an error when the proposal is not closed', async () => {\n\t      const report = new VotesReport(id, testStorageEngine);\n\t      mockFetchProposal.mockResolvedValueOnce({\n\t        state: 'pending',\n\t        id: '',\n", "        title: '',\n\t        votes: 0,\n\t        author: '',\n\t        choices: [],\n\t        space\n\t      });\n\t      expect(report.isCacheable()).rejects.toBe('RECORD_NOT_FOUND');\n\t      expect(mockFetchProposal).toHaveBeenCalled();\n\t    });\n\t    it('returns true when the proposal can be cached', async () => {\n", "      const report = new VotesReport(id, testStorageEngine);\n\t      mockFetchProposal.mockResolvedValueOnce({\n\t        state: 'closed',\n\t        id: '',\n\t        title: '',\n\t        votes: 0,\n\t        author: '',\n\t        choices: [],\n\t        space\n\t      });\n", "      expect(await report.isCacheable()).toBe(true);\n\t      expect(mockFetchProposal).toHaveBeenCalled();\n\t    });\n\t  });\n\t});\n"]}
{"filename": "test/unit/lib/cache.test.ts", "chunked_list": ["import { readFileSync, rmSync, writeFileSync } from 'fs';\n\timport { storageEngine } from '../../../src/helpers/utils';\n\timport Cache from '../../../src/lib/cache';\n\tconst TEST_CACHE_DIR = 'cache-test';\n\tconst TEST_ID = 'test';\n\tconst TEST_STRING_CONTENT = 'test content';\n\tdescribe('Cache', () => {\n\t  const testStorageEngine = storageEngine(TEST_CACHE_DIR);\n\t  const cache = new Cache(TEST_ID, testStorageEngine);\n\t  afterAll(() => {\n", "    rmSync(testStorageEngine.path(), { recursive: true });\n\t  });\n\t  describe('getCache()', () => {\n\t    describe('when the cache exists', () => {\n\t      const file = testStorageEngine.path(cache.filename);\n\t      beforeEach(() => writeFileSync(file, TEST_STRING_CONTENT));\n\t      afterEach(() => rmSync(file));\n\t      it('returns the cached content', async () => {\n\t        expect((await cache.getCache()).toString()).toEqual(TEST_STRING_CONTENT);\n\t      });\n", "      it('returns a Buffer', async () => {\n\t        expect(await cache.getCache()).toBeInstanceOf(Buffer);\n\t      });\n\t    });\n\t    describe('when the cache does not exists', () => {\n\t      it('returns false', async () => {\n\t        expect(await cache.getCache()).toBe(false);\n\t      });\n\t    });\n\t  });\n", "  describe('createCache()', () => {\n\t    it('creates the cache file from a string', async () => {\n\t      const spy = jest.spyOn(cache, 'getContent').mockResolvedValueOnce(TEST_STRING_CONTENT);\n\t      await cache.createCache();\n\t      expect((await cache.getCache()).toString()).toEqual(TEST_STRING_CONTENT);\n\t      expect(spy).toHaveBeenCalledTimes(1);\n\t    });\n\t    it('creates the cache file from a Buffer', async () => {\n\t      const fixture = readFileSync(`${__dirname}/../../fixtures/icon.png`);\n\t      const spy = jest.spyOn(cache, 'getContent').mockResolvedValueOnce(fixture);\n", "      await cache.createCache();\n\t      expect(await cache.getCache()).toEqual(fixture);\n\t      expect(spy).toHaveBeenCalledTimes(1);\n\t    });\n\t  });\n\t});\n"]}
{"filename": "test/unit/lib/nftClaimer/mint.test.ts", "chunked_list": ["import { BigNumber } from '@ethersproject/bignumber';\n\timport { recoverAddress } from '@ethersproject/transactions';\n\timport { getAddress } from '@ethersproject/address';\n\timport payload from '../../../../src/lib/nftClaimer/mint';\n\tconst TEST_MINT_DOMAIN = 'TestDAO';\n\tconst proposer = '0x0000000000000000000000000000004242424242';\n\tconst NAN = ['', false, null, 'test'];\n\tconst mockFetchProposal = jest.fn((id: string): any => {\n\t  return {\n\t    id: id,\n", "    author: proposer,\n\t    space: { id: TEST_MINT_DOMAIN }\n\t  };\n\t});\n\tjest.mock('../../../../src/helpers/snapshot', () => ({\n\t  __esModule: true,\n\t  fetchProposal: (id: string) => mockFetchProposal(id)\n\t}));\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst mockGetProposalContract = jest.fn((id: string): any => {\n", "  return '0x2e234DAe75C793f67A35089C9d99245E1C58470b';\n\t});\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst mockValidateProposal = jest.fn((proposal: any): void => {\n\t  return;\n\t});\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst mockMintingAllowed = jest.fn((space: any): boolean => {\n\t  return true;\n\t});\n", "jest.mock('../../../../src/lib/nftClaimer/utils', () => {\n\t  // Require the original module to not be mocked...\n\t  const originalModule = jest.requireActual('../../../../src/lib/nftClaimer/utils');\n\t  return {\n\t    __esModule: true,\n\t    ...originalModule,\n\t    getProposalContract: (id: string) => mockGetProposalContract(id),\n\t    validateProposal: (id: any) => mockValidateProposal(id),\n\t    mintingAllowed: (space: any) => mockMintingAllowed(space)\n\t  };\n", "});\n\tdescribe('nftClaimer', () => {\n\t  describe('payload()', () => {\n\t    const signer = '0xD60349c24dB7F1053086eF0D6364b64B1e0313f0';\n\t    const recipient = getAddress('0x0000000000000000000000000000000000001234');\n\t    const proposalId = 42;\n\t    const hexProposalId = BigNumber.from(proposalId).toHexString();\n\t    const salt = '0';\n\t    // Signature expected by the smart contract\n\t    const expectedScSignature = {\n", "      r: '0xf27b32f51f5804eb53705e7c0e3c63169282f0ac83543f515970531650d42be4',\n\t      s: '0x54124669256e730bc60147fb00afcf1d5f028045f15e7d5bd77b2093cd2f9554',\n\t      v: 27\n\t    };\n\t    const expectedDigest = '0x65b2c526e8c21a68583765e51f03990a67a0a0cb46794ab7ec666e88808eb93a';\n\t    const input = {\n\t      proposalAuthor: proposer,\n\t      recipient,\n\t      id: hexProposalId,\n\t      salt\n", "    };\n\t    async function getPayload(customParams = {}) {\n\t      return payload({ ...input, ...customParams });\n\t    }\n\t    describe('when mintable', () => {\n\t      it('generates the same signature as the smart contract from the data', async () => {\n\t        const { signature } = await getPayload();\n\t        expect(mockFetchProposal).toHaveBeenCalledWith(hexProposalId);\n\t        expect(signature.r).toEqual(expectedScSignature.r);\n\t        expect(signature.s).toEqual(expectedScSignature.s);\n", "        expect(signature.v).toEqual(expectedScSignature.v);\n\t      });\n\t      it('can recover the signer from the digest', async () => {\n\t        const recoveredSigner = recoverAddress(expectedDigest, {\n\t          r: expectedScSignature.r,\n\t          s: expectedScSignature.s,\n\t          v: expectedScSignature.v\n\t        });\n\t        expect(recoveredSigner).toEqual(signer);\n\t      });\n", "    });\n\t    describe('when spaceCollection is not found', () => {\n\t      it('throws a SpaceCollection not found error', async () => {\n\t        mockGetProposalContract.mockImplementationOnce(() => {\n\t          throw new Error();\n\t        });\n\t        return expect(async () => await getPayload()).rejects.toThrow();\n\t      });\n\t    });\n\t    describe('when space has closed minting', () => {\n", "      it('throws an error', () => {\n\t        mockMintingAllowed.mockReturnValueOnce(false);\n\t        return expect(async () => await payload(input)).rejects.toThrow();\n\t      });\n\t    });\n\t    describe('when maxSupply has been reached', () => {\n\t      it.todo('throws an error');\n\t    });\n\t    describe('when passing invalid values', () => {\n\t      it('throws an error when the proposalAuthor address is not valid', () => {\n", "        expect(async () => getPayload({ proposalAuthor: 'test' })).rejects.toThrow();\n\t      });\n\t      it('throws an error when the recipient address is not valid', () => {\n\t        expect(\n\t          async () =>\n\t            await getPayload({\n\t              recipient: 'test'\n\t            })\n\t        ).rejects.toThrow();\n\t      });\n", "      it.each(NAN)('throws an error when the salt is not a number (%s)', val => {\n\t        return expect(\n\t          async () =>\n\t            await getPayload({\n\t              salt: val as any\n\t            })\n\t        ).rejects.toThrow();\n\t      });\n\t      it('throws an error when the proposal is not found', () => {\n\t        mockFetchProposal.mockReturnValueOnce(null);\n", "        return expect(getPayload()).rejects.toThrow();\n\t      });\n\t    });\n\t  });\n\t});\n"]}
{"filename": "test/unit/lib/nftClaimer/deploy.test.ts", "chunked_list": ["import { recoverAddress } from '@ethersproject/transactions';\n\timport payload from '../../../../src/lib/nftClaimer/deploy';\n\timport type { Space } from '../../../../src/helpers/snapshot';\n\timport { signer } from '../../../../src/lib/nftClaimer/utils';\n\tconst mockFetchSpace = jest.fn((id: string): any => {\n\t  return { id: id };\n\t});\n\tjest.mock('../../../../src/helpers/snapshot', () => ({\n\t  __esModule: true,\n\t  fetchSpace: (id: string) => mockFetchSpace(id)\n", "}));\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst mockValidateSpace = jest.fn((address: string, space: Space | null): any => {\n\t  return true;\n\t});\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tconst mockValidateDeployInput = jest.fn((input: any): any => {\n\t  return {};\n\t});\n\tjest.mock('../../../../src/lib/nftClaimer/utils', () => {\n", "  const originalModule = jest.requireActual('../../../../src/lib/nftClaimer/utils');\n\t  return {\n\t    __esModule: true,\n\t    ...originalModule,\n\t    validateSpace: (address: string, space: Space | null) => mockValidateSpace(address, space),\n\t    validateDeployInput: (input: any) => mockValidateDeployInput(input)\n\t  };\n\t});\n\tconst NAN = ['', false, null, 'test'];\n\tdescribe('nftClaimer', () => {\n", "  describe('payload()', () => {\n\t    const spaceOwner = '0x5EF29cf961cf3Fc02551B9BdaDAa4418c446c5dd';\n\t    const spaceTreasury = '0x5EF29cf961cf3Fc02551B9BdaDAa4418c446c5dd';\n\t    const spaceId = 'TestDAO';\n\t    const maxSupply = '10';\n\t    const mintPrice = '100000000000000000';\n\t    const proposerFee = '10';\n\t    const salt = '72536493147621360896130495100276306361343381736075662552878320684807833746288';\n\t    // Signature expected by the smart contract\n\t    const expectedScSignature = {\n", "      r: '0xd921452d76ea510debe0260f7eba6327e1cb7172e22fcc0179a734a3e7234ca2',\n\t      s: '0x0ee9397c6c803436aac0c8c496c50264b68f6664f4940f7addc5f9140b8b8237',\n\t      v: 27\n\t    };\n\t    const expectedDigest = '0xc3a4ff2bd44ee17fbc4f802953bd55392238b034c71ca4f5de2ad2f23fa31af7';\n\t    const expectedInitializer =\n\t      '0x977b0efb00000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000016345785d8a0000000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000005ef29cf961cf3fc02551b9bdadaa4418c446c5dd0000000000000000000000005ef29cf961cf3fc02551b9bdadaa4418c446c5dd00000000000000000000000000000000000000000000000000000000000000075465737444414f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003302e310000000000000000000000000000000000000000000000000000000000';\n\t    const input = {\n\t      spaceOwner,\n\t      id: spaceId,\n", "      maxSupply,\n\t      mintPrice,\n\t      proposerFee,\n\t      salt,\n\t      spaceTreasury\n\t    };\n\t    function getPayload(customParams = {}) {\n\t      return payload({ ...input, ...customParams });\n\t    }\n\t    describe('when deployable', () => {\n", "      it('generates the same signature as the smart contract from the data', async () => {\n\t        mockValidateDeployInput.mockReturnValueOnce(input);\n\t        const { signature } = await getPayload();\n\t        expect(mockValidateSpace).toHaveBeenCalled();\n\t        expect(mockValidateDeployInput).toHaveBeenCalled();\n\t        expect(signature.r).toEqual(expectedScSignature.r);\n\t        expect(signature.s).toEqual(expectedScSignature.s);\n\t        expect(signature.v).toEqual(expectedScSignature.v);\n\t      });\n\t      it('generates the same initializer as the smart contract from the data', async () => {\n", "        mockValidateDeployInput.mockReturnValueOnce(input);\n\t        const { initializer } = await getPayload();\n\t        expect(mockValidateSpace).toHaveBeenCalled();\n\t        expect(mockValidateDeployInput).toHaveBeenCalled();\n\t        expect(initializer).toEqual(expectedInitializer);\n\t      });\n\t      it('can recover the signer from the digest', async () => {\n\t        mockValidateDeployInput.mockReturnValueOnce(input);\n\t        const recoveredSigner = recoverAddress(expectedDigest, {\n\t          r: expectedScSignature.r,\n", "          s: expectedScSignature.s,\n\t          v: expectedScSignature.v\n\t        });\n\t        expect(recoveredSigner).toEqual(signer.address);\n\t      });\n\t    });\n\t    describe('when the space validation failed', () => {\n\t      it('throws an error', () => {\n\t        mockValidateSpace.mockImplementation(() => {\n\t          throw new Error();\n", "        });\n\t        expect(async () => await getPayload()).rejects.toThrow();\n\t      });\n\t    });\n\t    describe('when passing invalid values', () => {\n\t      it('throws an error when the spaceOwer address is not valid', () => {\n\t        expect(async () => await getPayload({ spaceOwner: 'test' })).rejects.toThrow();\n\t      });\n\t      it('throws an error when the spaceTreasury address is not valid', () => {\n\t        expect(async () => await getPayload({ spaceTreasury: 'test' })).rejects.toThrow();\n", "      });\n\t      it.each(NAN)('throws an error when the salt is not a number (%s)', val => {\n\t        expect(async () => await getPayload({ salt: val as any })).rejects.toThrow();\n\t      });\n\t      it.each(NAN)('throws an error when the maxSupply is not a number (%s', val => {\n\t        expect(async () => await getPayload({ maxSupply: val as any })).rejects.toThrow();\n\t      });\n\t      it.each(NAN)('throws an error when the mintPrice is not a number (%s)', val => {\n\t        expect(async () => await getPayload({ mintPrice: val as any })).rejects.toThrow();\n\t      });\n", "      it.each(NAN)('throws an error when the proposerFee is not a number (%s)', val => {\n\t        expect(async () => await getPayload({ proposerFee: val as any })).rejects.toThrow();\n\t      });\n\t      it('throws an error when the proposerFee is out of range', () => {\n\t        expect(async () => await getPayload({ proposerFee: '101' })).rejects.toThrow();\n\t        expect(async () => await getPayload({ proposerFee: '-5' })).rejects.toThrow();\n\t      });\n\t    });\n\t  });\n\t});\n"]}
{"filename": "test/unit/lib/nftClaimer/utils.test.ts", "chunked_list": ["import {\n\t  validateAddresses,\n\t  validateProposal,\n\t  validateProposerFee\n\t} from '../../../../src/lib/nftClaimer/utils';\n\tdescribe('NFTClaimer/utils', () => {\n\t  describe('validateAddresses()', () => {\n\t    it('returns true when all addresses are valid', () => {\n\t      expect(\n\t        validateAddresses({\n", "          contractA: '0x054a600d8B766c786270E25872236507D8459D8F',\n\t          contractB: '0x33505720a7921d23E6b02EB69623Ed6A008Ca511'\n\t        })\n\t      ).toBe(true);\n\t    });\n\t    it('throws an error when some of the addresses are invalid', () => {\n\t      expect(() => {\n\t        validateAddresses({\n\t          contractA: '0x054a600d8B766c786270E25872236507D8459D8F',\n\t          contractB: 'hello-world'\n", "        });\n\t      }).toThrowError();\n\t    });\n\t  });\n\t  describe('validateProposerFee()', () => {\n\t    it('throws an error when proposerFee + snapshotFee > 100', () => {\n\t      return expect(async () => {\n\t        await validateProposerFee(100);\n\t      }).rejects.toThrow();\n\t    });\n", "  });\n\t  describe('validateProposal()', () => {\n\t    it('throws an error when the proposalAuthor is not matching', () => {\n\t      const address = '0x054a600d8B766c786270E25872236507D8459D8F';\n\t      expect(async () => {\n\t        validateProposal({ author: address } as any, '');\n\t      }).rejects.toThrow();\n\t    });\n\t    it('throws an error when the proposal does not exist', () => {\n\t      expect(async () => {\n", "        validateProposal(null, '');\n\t      }).rejects.toThrowError('RECORD_NOT_FOUND');\n\t    });\n\t    it.todo('throws an error when the space has closed minting');\n\t  });\n\t});\n"]}
{"filename": "src/api.ts", "chunked_list": ["import express from 'express';\n\timport { capture } from './helpers/sentry';\n\timport { rpcError, rpcSuccess, storageEngine } from './helpers/utils';\n\timport getModerationList from './lib/moderationList';\n\timport VotesReport from './lib/votesReport';\n\timport mintPayload from './lib/nftClaimer/mint';\n\timport deployPayload from './lib/nftClaimer/deploy';\n\timport { queue, getProgress } from './lib/queue';\n\timport { snapshotFee } from './lib/nftClaimer/utils';\n\tconst router = express.Router();\n", "router.post('/votes/:id', async (req, res) => {\n\t  const { id } = req.params;\n\t  const votesReport = new VotesReport(id, storageEngine(process.env.VOTE_REPORT_SUBDIR));\n\t  try {\n\t    const file = await votesReport.getCache();\n\t    if (file) {\n\t      res.header('Content-Type', 'text/csv');\n\t      res.attachment(votesReport.filename);\n\t      return res.end(file);\n\t    }\n", "    try {\n\t      await votesReport.isCacheable();\n\t      queue(votesReport);\n\t      return rpcSuccess(res.status(202), getProgress(id).toString(), id);\n\t    } catch (e: any) {\n\t      capture(e);\n\t      rpcError(res, e, id);\n\t    }\n\t  } catch (e) {\n\t    capture(e);\n", "    return rpcError(res, 'INTERNAL_ERROR', id);\n\t  }\n\t});\n\trouter.get('/moderation', async (req, res) => {\n\t  const { list } = req.query;\n\t  try {\n\t    res.json(await getModerationList(list ? (list as string).split(',') : undefined));\n\t  } catch (e) {\n\t    capture(e);\n\t    return rpcError(res, 'INTERNAL_ERROR', '');\n", "  }\n\t});\n\trouter.get('/nft-claimer', async (req, res) => {\n\t  try {\n\t    return res.json({ snapshotFee: await snapshotFee() });\n\t  } catch (e: any) {\n\t    capture(e);\n\t    return rpcError(res, e, '');\n\t  }\n\t});\n", "router.post('/nft-claimer/deploy', async (req, res) => {\n\t  const { address, id, salt, maxSupply, mintPrice, spaceTreasury, proposerFee } = req.body;\n\t  try {\n\t    return res.json(\n\t      await deployPayload({\n\t        spaceOwner: address,\n\t        id,\n\t        maxSupply,\n\t        mintPrice,\n\t        proposerFee,\n", "        salt,\n\t        spaceTreasury\n\t      })\n\t    );\n\t  } catch (e: any) {\n\t    capture(e);\n\t    return rpcError(res, e, salt);\n\t  }\n\t});\n\trouter.post('/nft-claimer/mint', async (req, res) => {\n", "  const { proposalAuthor, address, id, salt } = req.body;\n\t  try {\n\t    return res.json(await mintPayload({ proposalAuthor, recipient: address, id, salt }));\n\t  } catch (e: any) {\n\t    capture(e);\n\t    return rpcError(res, e, salt);\n\t  }\n\t});\n\texport default router;\n"]}
{"filename": "src/sentryTunnel.ts", "chunked_list": ["import express from 'express';\n\timport fetch from 'cross-fetch';\n\timport bodyParser from 'body-parser';\n\timport { URL } from 'url';\n\timport { rpcError } from './helpers/utils';\n\timport { capture } from './helpers/sentry';\n\tconst router = express.Router();\n\trouter.post('/sentry', bodyParser.raw({ type: () => true, limit: '4mb' }), async (req, res) => {\n\t  try {\n\t    const { dsn, event_id } = JSON.parse(req.body.toString().split('\\n')[0]);\n", "    if (dsn !== process.env.TUNNEL_SENTRY_DSN) {\n\t      return rpcError(res, 'UNAUTHORIZED', event_id);\n\t    }\n\t    const dnsUri = new URL(dsn);\n\t    const sentryApiUrl = `https://${dnsUri.hostname}/api${dnsUri.pathname}/envelope/`;\n\t    const response = await fetch(sentryApiUrl, {\n\t      method: 'post',\n\t      body: req.body\n\t    });\n\t    const status = response.status;\n", "    if (status !== 200) {\n\t      console.debug(await response.text());\n\t    }\n\t    return res.sendStatus(status);\n\t  } catch (e: any) {\n\t    capture(e);\n\t    rpcError(res, e, '');\n\t  }\n\t});\n\texport default router;\n"]}
{"filename": "src/index.ts", "chunked_list": ["import 'dotenv/config';\n\timport path from 'path';\n\timport express from 'express';\n\timport compression from 'compression';\n\timport cors from 'cors';\n\timport morgan from 'morgan';\n\timport favicon from 'serve-favicon';\n\timport api from './api';\n\timport webhook from './webhook';\n\timport sentryTunnel from './sentryTunnel';\n", "import './lib/queue';\n\timport { name, version } from '../package.json';\n\timport { rpcError } from './helpers/utils';\n\timport { initLogger, fallbackLogger } from './helpers/sentry';\n\tconst app = express();\n\tconst PORT = process.env.PORT || 3005;\n\tinitLogger(app);\n\tapp.use(express.json({ limit: '4mb' }));\n\tapp.use(cors({ maxAge: 86400 }));\n\tapp.use(compression());\n", "app.use(\n\t  morgan(\n\t    '[http] [:date[clf]] ' +\n\t      '\":method :url HTTP/:http-version\" :status :res[content-length] ' +\n\t      '\":referrer\" \":user-agent\" - :response-time ms'\n\t  )\n\t);\n\tapp.use(favicon(path.join(__dirname, '../public', 'favicon.png')));\n\tapp.use('/api', api);\n\tapp.use('/', webhook);\n", "app.use('/', sentryTunnel);\n\tapp.get('/', (req, res) => {\n\t  const commit = process.env.COMMIT_HASH || '';\n\t  const v = commit ? `${version}#${commit.substring(0, 7)}` : version;\n\t  return res.json({\n\t    name,\n\t    version: v\n\t  });\n\t});\n\tfallbackLogger(app);\n", "app.use((_, res) => {\n\t  rpcError(res, 'RECORD_NOT_FOUND', '');\n\t});\n\tapp.listen(PORT, () => console.log(`[http] Start server at http://localhost:${PORT}`));\n"]}
{"filename": "src/webhook.ts", "chunked_list": ["import express from 'express';\n\timport { rpcError, rpcSuccess, storageEngine } from './helpers/utils';\n\timport { capture } from './helpers/sentry';\n\timport VotesReport from './lib/votesReport';\n\timport { queue } from './lib/queue';\n\tconst router = express.Router();\n\tfunction processVotesReport(id: string, event: string) {\n\t  if (event == 'proposal/end') {\n\t    queue(new VotesReport(id, storageEngine(process.env.VOTE_REPORT_SUBDIR)));\n\t  }\n", "}\n\trouter.post('/webhook', (req, res) => {\n\t  const body = req.body || {};\n\t  const event = body.event?.toString() ?? '';\n\t  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t  const { type, id } = body.id?.toString().split('/');\n\t  if (req.headers['authentication'] !== `${process.env.WEBHOOK_AUTH_TOKEN ?? ''}`) {\n\t    return rpcError(res, 'UNAUTHORIZED', id);\n\t  }\n\t  if (!event || !id) {\n", "    return rpcError(res, 'Invalid Request', id);\n\t  }\n\t  try {\n\t    processVotesReport(id, event);\n\t    return rpcSuccess(res, 'Webhook received', id);\n\t  } catch (e) {\n\t    capture(e);\n\t    return rpcError(res, 'INTERNAL_ERROR', id);\n\t  }\n\t});\n", "export default router;\n"]}
{"filename": "src/lib/queue.ts", "chunked_list": ["import { sleep } from '../helpers/utils';\n\timport { capture } from '../helpers/sentry';\n\timport Cache from './cache';\n\tconst queues = new Set<Cache>();\n\tconst processingItems = new Map<string, Cache>();\n\tasync function processItem(cacheable: Cache) {\n\t  console.log(`[queue] Processing queue item: ${cacheable}`);\n\t  try {\n\t    processingItems.set(cacheable.id, cacheable);\n\t    await cacheable.createCache();\n", "  } catch (e) {\n\t    capture(e);\n\t    console.error(`[queue] Error while processing item`, e);\n\t  } finally {\n\t    queues.delete(cacheable);\n\t    processingItems.delete(cacheable.id);\n\t  }\n\t}\n\texport function queue(cacheable: Cache) {\n\t  queues.add(cacheable);\n", "  return queues.size;\n\t}\n\texport function getProgress(id: string) {\n\t  if (processingItems.has(id)) {\n\t    return processingItems.get(id)?.generationProgress as number;\n\t  }\n\t  return 0;\n\t}\n\tasync function run() {\n\t  try {\n", "    console.log(`[queue] Poll queue (found ${queues.size} items)`);\n\t    queues.forEach(async cacheable => {\n\t      if (processingItems.has(cacheable.id)) {\n\t        console.log(\n\t          `[queue] Skip: ${cacheable} is currently being processed, progress: ${processingItems.get(\n\t            cacheable.id\n\t          )?.generationProgress}%`\n\t        );\n\t        return;\n\t      }\n", "      processItem(cacheable);\n\t    });\n\t  } catch (e) {\n\t    capture(e);\n\t  } finally {\n\t    await sleep(15e3);\n\t    await run();\n\t  }\n\t}\n\trun();\n"]}
{"filename": "src/lib/moderationList.ts", "chunked_list": ["import { readFileSync } from 'fs';\n\timport path from 'path';\n\timport db from '../helpers/mysql';\n\ttype MODERATION_LIST = Record<string, string[] | JSON>;\n\tconst CACHE_PATH = path.resolve(__dirname, `../../${process.env.MODERATION_LIST_PATH || 'data'}`);\n\tconst FIELDS = new Map<keyof MODERATION_LIST, Record<string, string>>([\n\t  ['flaggedLinks', { action: 'flag', type: 'link' }],\n\t  ['flaggedProposals', { action: 'flag', type: 'proposal' }],\n\t  ['flaggedSpaces', { action: 'flag', type: 'space' }],\n\t  ['flaggedIps', { action: 'flag', type: 'ip' }],\n", "  ['verifiedSpaces', { action: 'verify', type: 'space' }],\n\t  ['verifiedTokens', { file: 'verifiedTokens.json' }]\n\t]);\n\texport function readFile(filename: string) {\n\t  return parseFileContent(\n\t    readFileSync(path.join(CACHE_PATH, filename), { encoding: 'utf8' }),\n\t    filename.split('.')[1]\n\t  );\n\t}\n\tfunction parseFileContent(content: string, parser: string): MODERATION_LIST[keyof MODERATION_LIST] {\n", "  switch (parser) {\n\t    case 'txt':\n\t      return content.split('\\n').filter(value => value !== '');\n\t    case 'json':\n\t      return JSON.parse(content);\n\t    default:\n\t      throw new Error('Invalid file type');\n\t  }\n\t}\n\texport default async function getModerationList(fields = Array.from(FIELDS.keys())) {\n", "  const list: Partial<MODERATION_LIST> = {};\n\t  const reverseMapping: Record<string, keyof MODERATION_LIST> = {};\n\t  const queryWhereStatement: string[] = [];\n\t  let queryWhereArgs: string[] = [];\n\t  fields.forEach(field => {\n\t    if (FIELDS.has(field)) {\n\t      const args = FIELDS.get(field) as Record<string, string>;\n\t      if (!args.file) {\n\t        list[field] = [];\n\t        reverseMapping[`${args.action}-${args.type}`] = field;\n", "        queryWhereStatement.push(`(action = ? AND type = ?)`);\n\t        queryWhereArgs = queryWhereArgs.concat([args.action, args.type]);\n\t      } else {\n\t        list[field] = readFile(args.file);\n\t      }\n\t    }\n\t  });\n\t  if (queryWhereStatement.length > 0) {\n\t    const dbResults = await db.queryAsync(\n\t      `SELECT * FROM moderation WHERE ${queryWhereStatement.join(' OR ')}`,\n", "      queryWhereArgs\n\t    );\n\t    dbResults.forEach(row => {\n\t      (list[reverseMapping[`${row.action}-${row.type}`]] as string[]).push(row.value as string);\n\t    });\n\t  }\n\t  return list;\n\t}\n"]}
{"filename": "src/lib/votesReport.ts", "chunked_list": ["import { fetchProposal, fetchVotes, Proposal, Vote } from '../helpers/snapshot';\n\timport type { IStorage } from './storage/types';\n\timport Cache from './cache';\n\tclass VotesReport extends Cache {\n\t  proposal?: Proposal | null;\n\t  constructor(id: string, storage: IStorage) {\n\t    super(id, storage);\n\t    this.filename = `snapshot-votes-report-${this.id}.csv`;\n\t  }\n\t  async isCacheable() {\n", "    this.proposal = await fetchProposal(this.id);\n\t    if (!this.proposal || this.proposal.state !== 'closed') {\n\t      return Promise.reject('RECORD_NOT_FOUND');\n\t    }\n\t    return true;\n\t  }\n\t  getContent = async () => {\n\t    this.isCacheable();\n\t    const votes = await this.fetchAllVotes();\n\t    let content = '';\n", "    console.log(`[votes-report] Generating report for ${this.id}`);\n\t    const headers = [\n\t      'address',\n\t      votes.length === 0 || typeof votes[0].choice === 'number'\n\t        ? 'choice'\n\t        : this.proposal && this.proposal.choices.map((_choice, index) => `choice.${index + 1}`),\n\t      'voting_power',\n\t      'timestamp',\n\t      'author_ipfs_hash',\n\t      'reason'\n", "    ].flat();\n\t    content += headers.join(',');\n\t    content += `\\n${votes.map(vote => this.#formatCsvLine(vote)).join('\\n')}`;\n\t    console.log(`[votes-report] Report for ${this.id} ready with ${votes.length} items`);\n\t    return content;\n\t  };\n\t  fetchAllVotes = async () => {\n\t    let votes: Vote[] = [];\n\t    let page = 0;\n\t    let createdPivot = 0;\n", "    const pageSize = 1000;\n\t    let resultsSize = 0;\n\t    const maxPage = 5;\n\t    do {\n\t      let newVotes = await fetchVotes(this.id, {\n\t        first: pageSize,\n\t        skip: page * pageSize,\n\t        created_gte: createdPivot,\n\t        orderBy: 'created',\n\t        orderDirection: 'asc'\n", "      });\n\t      resultsSize = newVotes.length;\n\t      if (page === 0 && createdPivot > 0) {\n\t        // Loosely assuming that there will never be more than 1000 duplicates\n\t        const existingIpfs = votes.slice(-pageSize).map(vote => vote.ipfs);\n\t        newVotes = newVotes.filter(vote => {\n\t          return !existingIpfs.includes(vote.ipfs);\n\t        });\n\t      }\n\t      if (page === maxPage) {\n", "        page = 0;\n\t        createdPivot = newVotes[newVotes.length - 1].created;\n\t      } else {\n\t        page++;\n\t      }\n\t      votes = votes.concat(newVotes);\n\t      this.generationProgress = Number(\n\t        ((votes.length / (this.proposal?.votes as number)) * 100).toFixed(2)\n\t      );\n\t    } while (resultsSize === pageSize);\n", "    return votes;\n\t  };\n\t  toString() {\n\t    return `VotesReport#${this.id}`;\n\t  }\n\t  #formatCsvLine = (vote: Vote) => {\n\t    let choices: Vote['choice'][] = [];\n\t    if (typeof vote.choice !== 'number' && this.proposal) {\n\t      choices = Array.from({ length: this.proposal.choices.length });\n\t      for (const [key, value] of Object.entries(vote.choice)) {\n", "        choices[parseInt(key) - 1] = value;\n\t      }\n\t    } else {\n\t      choices.push(vote.choice);\n\t    }\n\t    return [\n\t      vote.voter,\n\t      ...choices,\n\t      vote.vp,\n\t      vote.created,\n", "      vote.ipfs,\n\t      `\"${vote.reason.replace(/(\\r\\n|\\n|\\r)/gm, '')}\"`\n\t    ]\n\t      .flat()\n\t      .join(',');\n\t  };\n\t}\n\texport default VotesReport;\n"]}
{"filename": "src/lib/cache.ts", "chunked_list": ["import { IStorage } from './storage/types';\n\texport default class Cache {\n\t  id: string;\n\t  filename: string;\n\t  storage: IStorage;\n\t  generationProgress: number;\n\t  constructor(id: string, storage: IStorage) {\n\t    this.id = id;\n\t    this.filename = `${id}.cache`;\n\t    this.storage = storage;\n", "    this.generationProgress = 0;\n\t  }\n\t  async getContent(): Promise<string | Buffer> {\n\t    return '';\n\t  }\n\t  getCache() {\n\t    return this.storage.get(this.filename);\n\t  }\n\t  async isCacheable() {\n\t    return true;\n", "  }\n\t  async createCache() {\n\t    await this.isCacheable();\n\t    const content = await this.getContent();\n\t    console.log(`[votes-report] File cache ready to be saved`);\n\t    this.storage.set(this.filename, content);\n\t    return content;\n\t  }\n\t}\n"]}
{"filename": "src/lib/storage/types.ts", "chunked_list": ["export interface IStorage {\n\t  subDir?: string;\n\t  set(key: string, value: string | Buffer): Promise<boolean>;\n\t  get(key: string): Promise<Buffer | boolean>;\n\t}\n\texport interface IStorageConstructor {\n\t  new (subDir?: string): IStorage;\n\t}\n"]}
{"filename": "src/lib/storage/aws.ts", "chunked_list": ["import { S3Client, GetObjectCommand, PutObjectCommand } from '@aws-sdk/client-s3';\n\timport { capture } from '../../helpers/sentry';\n\timport type { IStorage } from './types';\n\timport type { Readable } from 'stream';\n\tconst CACHE_PATH = 'public';\n\tclass Aws implements IStorage {\n\t  client: S3Client;\n\t  subDir?: string;\n\t  constructor(subDir?: string) {\n\t    const region = process.env.AWS_REGION;\n", "    const accessKeyId = process.env.AWS_ACCESS_KEY_ID;\n\t    const secretAccessKey = process.env.AWS_SECRET_ACCESS_KEY;\n\t    if (!region || !accessKeyId || !secretAccessKey) {\n\t      throw new Error('[storage:aws] AWS credentials missing');\n\t    }\n\t    this.client = new S3Client({ endpoint: process.env.AWS_ENDPOINT });\n\t    this.subDir = subDir;\n\t  }\n\t  async set(key: string, value: string | Buffer) {\n\t    try {\n", "      const command = new PutObjectCommand({\n\t        Bucket: process.env.AWS_BUCKET_NAME,\n\t        Key: this.path(key),\n\t        Body: value,\n\t        ContentType: 'text/csv; charset=utf-8'\n\t      });\n\t      await this.client.send(command);\n\t      console.log(`[storage:aws] File saved to ${this.path(key)}`);\n\t      return true;\n\t    } catch (e) {\n", "      capture(e);\n\t      console.error('[storage:aws] File storage failed', e);\n\t      throw new Error('Unable to access storage');\n\t    }\n\t  }\n\t  async get(key: string) {\n\t    try {\n\t      const command = new GetObjectCommand({\n\t        Bucket: process.env.AWS_BUCKET_NAME,\n\t        Key: this.path(key)\n", "      });\n\t      const response = await this.client.send(command);\n\t      if (!response.Body) {\n\t        return false;\n\t      }\n\t      const stream = response.Body as Readable;\n\t      return new Promise<Buffer>((resolve, reject) => {\n\t        const chunks: Buffer[] = [];\n\t        stream.on('data', chunk => chunks.push(chunk));\n\t        stream.once('end', () => resolve(Buffer.concat(chunks)));\n", "        stream.once('error', reject);\n\t      });\n\t    } catch (e: any) {\n\t      if (e['$metadata']?.httpStatusCode !== 404) {\n\t        capture(e);\n\t        console.error('[storage:aws] File fetch failed', e);\n\t      }\n\t      return false;\n\t    }\n\t  }\n", "  path(key?: string) {\n\t    return [CACHE_PATH, this.subDir?.replace(/^\\/+|\\/+$/, ''), key].filter(p => p).join('/');\n\t  }\n\t}\n\texport default Aws;\n"]}
{"filename": "src/lib/storage/file.ts", "chunked_list": ["import { writeFileSync, existsSync, mkdirSync, readFileSync } from 'fs';\n\timport { capture } from '../../helpers/sentry';\n\timport type { IStorage } from './types';\n\tconst CACHE_PATH = `${__dirname}/../../../tmp`;\n\tclass File implements IStorage {\n\t  subDir?: string;\n\t  constructor(subDir?: string) {\n\t    this.subDir = subDir;\n\t    if (!existsSync(this.path())) {\n\t      mkdirSync(this.path(), { recursive: true });\n", "    }\n\t  }\n\t  async set(key: string, value: string | Buffer) {\n\t    try {\n\t      writeFileSync(this.path(key), value);\n\t      console.log(`[storage:file] File saved to ${this.path(key)}`);\n\t      return true;\n\t    } catch (e) {\n\t      capture(e);\n\t      console.error('[storage:file] File storage failed', e);\n", "      throw e;\n\t    }\n\t  }\n\t  async get(key: string) {\n\t    try {\n\t      if (!existsSync(this.path(key))) {\n\t        return false;\n\t      }\n\t      console.log(`[storage:file] File fetched from ${this.path(key)}`);\n\t      return readFileSync(this.path(key));\n", "    } catch (e) {\n\t      capture(e);\n\t      console.error('[storage:file] Fetch file failed', e);\n\t      return false;\n\t    }\n\t  }\n\t  path(key?: string) {\n\t    return [CACHE_PATH, this.subDir?.replace(/^\\/+|\\/+$/, ''), key].filter(p => p).join('/');\n\t  }\n\t}\n", "export default File;\n"]}
{"filename": "src/lib/nftClaimer/mint.ts", "chunked_list": ["import { splitSignature } from '@ethersproject/bytes';\n\timport { fetchProposal, Space } from '../../helpers/snapshot';\n\timport {\n\t  validateProposal,\n\t  getProposalContract,\n\t  signer,\n\t  numberizeProposalId,\n\t  validateMintInput,\n\t  mintingAllowed\n\t} from './utils';\n", "import abi from './spaceCollectionImplementationAbi.json';\n\timport { FormatTypes, Interface } from '@ethersproject/abi';\n\tconst MintType = {\n\t  Mint: [\n\t    { name: 'proposer', type: 'address' },\n\t    { name: 'recipient', type: 'address' },\n\t    { name: 'proposalId', type: 'uint256' },\n\t    { name: 'salt', type: 'uint256' }\n\t  ]\n\t};\n", "const NFT_CLAIMER_NETWORK = process.env.NFT_CLAIMER_NETWORK;\n\texport default async function payload(input: {\n\t  proposalAuthor: string;\n\t  recipient: string;\n\t  id: string;\n\t  salt: string;\n\t}) {\n\t  const params = await validateMintInput(input);\n\t  const proposal = await fetchProposal(params.id);\n\t  validateProposal(proposal, params.proposalAuthor);\n", "  const spaceId = proposal?.space.id as string;\n\t  const verifyingContract = await getProposalContract(spaceId);\n\t  if (!mintingAllowed(proposal?.space as Space)) {\n\t    throw new Error('Space has closed minting');\n\t  }\n\t  const message = {\n\t    proposer: params.proposalAuthor,\n\t    recipient: params.recipient,\n\t    proposalId: numberizeProposalId(params.id),\n\t    salt: BigInt(params.salt)\n", "  };\n\t  return {\n\t    signature: await generateSignature(verifyingContract, spaceId, message),\n\t    contractAddress: verifyingContract,\n\t    spaceId: proposal?.space.id,\n\t    ...message,\n\t    salt: params.salt,\n\t    abi: new Interface(abi).getFunction('mint').format(FormatTypes.full)\n\t  };\n\t}\n", "async function generateSignature(\n\t  verifyingContract: string,\n\t  domain: string,\n\t  message: Record<string, string | bigint>\n\t) {\n\t  return splitSignature(\n\t    await signer._signTypedData(\n\t      {\n\t        name: domain,\n\t        version: '0.1',\n", "        chainId: NFT_CLAIMER_NETWORK,\n\t        verifyingContract\n\t      },\n\t      MintType,\n\t      message\n\t    )\n\t  );\n\t}\n"]}
{"filename": "src/lib/nftClaimer/deploy.ts", "chunked_list": ["import { getAddress } from '@ethersproject/address';\n\timport { splitSignature } from '@ethersproject/bytes';\n\timport { FormatTypes, Interface } from '@ethersproject/abi';\n\timport { fetchSpace } from '../../helpers/snapshot';\n\timport { signer, validateDeployInput, validateSpace } from './utils';\n\timport spaceCollectionAbi from './spaceCollectionImplementationAbi.json';\n\timport spaceFactoryAbi from './spaceFactoryAbi.json';\n\tconst DeployType = {\n\t  Deploy: [\n\t    { name: 'implementation', type: 'address' },\n", "    { name: 'initializer', type: 'bytes' },\n\t    { name: 'salt', type: 'uint256' }\n\t  ]\n\t};\n\tconst VERIFYING_CONTRACT = getAddress(process.env.NFT_CLAIMER_DEPLOY_VERIFYING_CONTRACT as string);\n\tconst IMPLEMENTATION_ADDRESS = getAddress(\n\t  process.env.NFT_CLAIMER_DEPLOY_IMPLEMENTATION_ADDRESS as string\n\t);\n\tconst NFT_CLAIMER_NETWORK = process.env.NFT_CLAIMER_NETWORK;\n\tconst INITIALIZE_SELECTOR = process.env.NFT_CLAIMER_DEPLOY_INITIALIZE_SELECTOR;\n", "export default async function payload(input: {\n\t  spaceOwner: string;\n\t  id: string;\n\t  maxSupply: string;\n\t  mintPrice: string;\n\t  proposerFee: string;\n\t  salt: string;\n\t  spaceTreasury: string;\n\t}) {\n\t  const params = await validateDeployInput(input);\n", "  const space = await fetchSpace(params.id);\n\t  await validateSpace(params.spaceOwner, space);\n\t  const initializer = getInitializer({\n\t    spaceOwner: params.spaceOwner,\n\t    spaceId: space?.id as string,\n\t    maxSupply: params.maxSupply,\n\t    mintPrice: params.mintPrice,\n\t    proposerFee: params.proposerFee,\n\t    spaceTreasury: params.spaceTreasury\n\t  });\n", "  const result = {\n\t    initializer,\n\t    salt: params.salt,\n\t    abi: new Interface(spaceFactoryAbi).getFunction('deployProxy').format(FormatTypes.full),\n\t    verifyingContract: VERIFYING_CONTRACT,\n\t    implementation: IMPLEMENTATION_ADDRESS,\n\t    signature: await generateSignature(IMPLEMENTATION_ADDRESS, initializer, params.salt)\n\t  };\n\t  console.debug('Signer', signer.address);\n\t  console.debug('Payload', result);\n", "  return result;\n\t}\n\tfunction getInitializer(args: {\n\t  spaceId: string;\n\t  maxSupply: number;\n\t  mintPrice: string;\n\t  proposerFee: number;\n\t  spaceTreasury: string;\n\t  spaceOwner: string;\n\t}) {\n", "  const params = [\n\t    args.spaceId,\n\t    '0.1',\n\t    args.maxSupply,\n\t    BigInt(args.mintPrice),\n\t    args.proposerFee,\n\t    getAddress(args.spaceTreasury),\n\t    getAddress(args.spaceOwner)\n\t  ];\n\t  // This encodeFunctionData should ignore the last 4 params compared to\n", "  // the smart contract version\n\t  // NOTE Do not forget to remove the last 4 params in the ABI when copy/pasting\n\t  // from the smart contract\n\t  const initializer = new Interface(spaceCollectionAbi).encodeFunctionData('initialize', params);\n\t  const result = `${INITIALIZE_SELECTOR}${initializer.slice(10)}`;\n\t  console.debug('Initializer params', params);\n\t  return result;\n\t}\n\tasync function generateSignature(implementation: string, initializer: string, salt: string) {\n\t  const params = {\n", "    domain: {\n\t      name: 'SpaceCollectionFactory',\n\t      version: '0.1',\n\t      chainId: NFT_CLAIMER_NETWORK,\n\t      verifyingContract: VERIFYING_CONTRACT\n\t    },\n\t    types: DeployType,\n\t    value: {\n\t      implementation,\n\t      initializer,\n", "      salt: BigInt(salt)\n\t    }\n\t  };\n\t  return splitSignature(await signer._signTypedData(params.domain, params.types, params.value));\n\t}\n"]}
{"filename": "src/lib/nftClaimer/utils.ts", "chunked_list": ["import { gql, ApolloClient, InMemoryCache, HttpLink } from '@apollo/client/core';\n\timport fetch from 'cross-fetch';\n\timport snapshot from '@snapshot-labs/snapshot.js';\n\timport { CID } from 'multiformats/cid';\n\timport { Wallet } from '@ethersproject/wallet';\n\timport { Contract } from '@ethersproject/contracts';\n\timport { getAddress, isAddress } from '@ethersproject/address';\n\timport { BigNumber } from '@ethersproject/bignumber';\n\timport { capture } from '../../helpers/sentry';\n\timport type { Proposal, Space } from '../../helpers/snapshot';\n", "const requiredEnvKeys = [\n\t  'NFT_CLAIMER_PRIVATE_KEY',\n\t  'NFT_CLAIMER_NETWORK',\n\t  'NFT_CLAIMER_DEPLOY_VERIFYING_CONTRACT',\n\t  'NFT_CLAIMER_DEPLOY_IMPLEMENTATION_ADDRESS',\n\t  'NFT_CLAIMER_DEPLOY_INITIALIZE_SELECTOR',\n\t  'NFT_CLAIMER_SUBGRAPH_URL'\n\t];\n\tconst HUB_NETWORK = process.env.HUB_URL === 'https://hub.snapshot.org' ? '1' : '5';\n\tconst DEPLOY_CONTRACT = getAddress(process.env.NFT_CLAIMER_DEPLOY_VERIFYING_CONTRACT as string);\n", "const NFT_CLAIMER_NETWORK = parseInt(process.env.NFT_CLAIMER_NETWORK as string);\n\tconst missingEnvKeys: string[] = [];\n\trequiredEnvKeys.forEach(key => {\n\t  if (!process.env[key]) {\n\t    missingEnvKeys.push(key);\n\t  }\n\t});\n\tif (missingEnvKeys.length > 0) {\n\t  throw new Error(\n\t    `NFT Claimer not configured properly, missing env keys: ${missingEnvKeys.join(', ')}`\n", "  );\n\t}\n\texport const signer = new Wallet(process.env.NFT_CLAIMER_PRIVATE_KEY as string);\n\texport async function mintingAllowed(space: Space) {\n\t  return (await getSpaceCollection(space.id)).enabled;\n\t}\n\texport async function validateSpace(address: string, space: Space | null) {\n\t  if (!space) {\n\t    throw new Error('RECORD_NOT_FOUND');\n\t  }\n", "  if (NFT_CLAIMER_NETWORK !== 5 && !(await isSpaceOwner(space.id, address))) {\n\t    throw new Error('Address is not the space owner');\n\t  }\n\t  const contract = await getSpaceCollection(space.id);\n\t  if (contract) {\n\t    throw new Error(`SpaceCollection contract already exist (${contract.id})`);\n\t  }\n\t}\n\tasync function isSpaceOwner(spaceId: string, address: string) {\n\t  return (await snapshot.utils.getSpaceController(spaceId, HUB_NETWORK)) === getAddress(address);\n", "}\n\texport function validateProposal(proposal: Proposal | null, proposer: string) {\n\t  if (!proposal) {\n\t    throw new Error('RECORD_NOT_FOUND');\n\t  }\n\t  if (getAddress(proposer) !== getAddress(proposal.author)) {\n\t    throw new Error('Proposal author is not matching');\n\t  }\n\t  if (!mintingAllowed(proposal.space)) {\n\t    throw new Error('Space has not allowed minting');\n", "  }\n\t}\n\texport async function getProposalContract(spaceId: string) {\n\t  const contract = await getSpaceCollection(spaceId);\n\t  if (!contract) {\n\t    throw new Error(`SpaceCollection contract is not found for space ${spaceId}`);\n\t  }\n\t  return contract.id;\n\t}\n\tconst client = new ApolloClient({\n", "  link: new HttpLink({ uri: process.env.NFT_CLAIMER_SUBGRAPH_URL, fetch }),\n\t  cache: new InMemoryCache({\n\t    addTypename: false\n\t  }),\n\t  defaultOptions: {\n\t    query: {\n\t      fetchPolicy: 'no-cache'\n\t    }\n\t  }\n\t});\n", "const SPACE_COLLECTION_QUERY = gql`\n\t  query SpaceCollections($spaceId: String) {\n\t    spaceCollections(where: { spaceId: $spaceId }, first: 1) {\n\t      id\n\t      enabled\n\t    }\n\t  }\n\t`;\n\ttype SpaceCollection = {\n\t  id: string;\n", "  enabled: boolean;\n\t};\n\texport async function getSpaceCollection(spaceId: string) {\n\t  const {\n\t    data: { spaceCollections }\n\t  }: { data: { spaceCollections: SpaceCollection[] } } = await client.query({\n\t    query: SPACE_COLLECTION_QUERY,\n\t    variables: {\n\t      spaceId\n\t    }\n", "  });\n\t  return spaceCollections[0];\n\t}\n\texport function numberizeProposalId(id: string) {\n\t  return BigNumber.from(id.startsWith('0x') ? id : CID.parse(id).bytes).toString();\n\t}\n\texport function validateAddresses(addresses: Record<string, string>) {\n\t  Object.entries(addresses).forEach(([key, value]) => {\n\t    if (!isAddress(value)) {\n\t      throw new Error(`Value for ${key} is not a valid address (${value})`);\n", "    }\n\t  });\n\t  return true;\n\t}\n\tfunction validateNumbers(numbers: Record<string, string>) {\n\t  Object.entries(numbers).forEach(([key, value]) => {\n\t    try {\n\t      BigNumber.from(value).toString();\n\t    } catch (e: any) {\n\t      throw new Error(`Value for ${key} is not a valid number (${value})`);\n", "    }\n\t  });\n\t  return true;\n\t}\n\texport async function validateProposerFee(fee: number) {\n\t  if (fee < 0 || fee > 100) {\n\t    throw new Error('proposerFee should be between 0 and 100');\n\t  }\n\t  const sFee = await snapshotFee();\n\t  if (sFee + fee > 100) {\n", "    throw new Error(`proposerFee should not be greater than ${100 - sFee}`);\n\t  }\n\t  return true;\n\t}\n\texport async function validateDeployInput(params: any) {\n\t  validateAddresses({ spaceOwner: params.spaceOwner, spaceTreasury: params.spaceTreasury });\n\t  validateNumbers({\n\t    maxSupply: params.maxSupply,\n\t    proposerFee: params.proposerFee,\n\t    mintPrice: params.mintPrice,\n", "    salt: params.salt\n\t  });\n\t  await validateProposerFee(parseInt(params.proposerFee));\n\t  return {\n\t    spaceOwner: getAddress(params.spaceOwner),\n\t    spaceTreasury: getAddress(params.spaceTreasury),\n\t    proposerFee: parseInt(params.proposerFee),\n\t    maxSupply: parseInt(params.maxSupply),\n\t    mintPrice: parseInt(params.mintPrice),\n\t    ...params\n", "  };\n\t}\n\texport async function validateMintInput(params: any) {\n\t  validateAddresses({ proposalAuthor: params.proposalAuthor, recipient: params.recipient });\n\t  validateNumbers({\n\t    salt: params.salt\n\t  });\n\t  return {\n\t    proposalAuthor: getAddress(params.proposalAuthor),\n\t    recipient: getAddress(params.recipient),\n", "    ...params\n\t  };\n\t}\n\texport async function snapshotFee(): Promise<number> {\n\t  try {\n\t    const provider = snapshot.utils.getProvider(NFT_CLAIMER_NETWORK);\n\t    const contract = new Contract(\n\t      DEPLOY_CONTRACT,\n\t      ['function snapshotFee() public view returns (uint8)'],\n\t      provider\n", "    );\n\t    return contract.snapshotFee();\n\t  } catch (e: any) {\n\t    capture(e);\n\t    throw 'Unable to retrieve the snapshotFee';\n\t  }\n\t}\n"]}
{"filename": "src/helpers/mysql.ts", "chunked_list": ["import mysql from 'mysql';\n\t// @ts-ignore\n\timport Pool from 'mysql/lib/Pool';\n\t// @ts-ignore\n\timport Connection from 'mysql/lib/Connection';\n\timport bluebird from 'bluebird';\n\timport { ConnectionString } from 'connection-string';\n\ttype values = string | number | boolean | null;\n\texport type SqlRow = Record<string, values>;\n\ttype SqlQueryArgs = values | Record<string, values>;\n", "interface PromisedPool {\n\t  queryAsync: (query: string, args?: SqlQueryArgs | SqlQueryArgs[]) => Promise<SqlRow[]>;\n\t  endAsync: () => Promise<any>;\n\t}\n\tconst config = new ConnectionString(process.env.DATABASE_URL || '');\n\tbluebird.promisifyAll([Pool, Connection]);\n\tconst db: PromisedPool = mysql.createPool({\n\t  ...config,\n\t  host: config.hosts?.[0].name,\n\t  port: config.hosts?.[0].port,\n", "  connectionLimit: parseInt(process.env.CONNECTION_LIMIT || '10'),\n\t  multipleStatements: true,\n\t  connectTimeout: 60e3,\n\t  acquireTimeout: 60e3,\n\t  timeout: 60e3,\n\t  charset: 'utf8mb4',\n\t  database: config.path?.[0]\n\t}) as mysql.Pool & PromisedPool;\n\texport default db;\n"]}
{"filename": "src/helpers/snapshot.ts", "chunked_list": ["import { gql, ApolloClient, InMemoryCache, createHttpLink } from '@apollo/client/core';\n\timport { setContext } from '@apollo/client/link/context';\n\timport fetch from 'cross-fetch';\n\texport type Proposal = {\n\t  id: string;\n\t  state: string;\n\t  choices: string[];\n\t  space: Space;\n\t  votes: number;\n\t  author: string;\n", "};\n\texport type Vote = {\n\t  ipfs: string;\n\t  voter: string;\n\t  choice: Record<string, number> | number;\n\t  vp: number;\n\t  reason: string;\n\t  created: number;\n\t};\n\texport type Space = {\n", "  id: string;\n\t  network: string;\n\t};\n\tconst httpLink = createHttpLink({\n\t  uri: `${process.env.HUB_URL || 'https://hub.snapshot.org'}/graphql`,\n\t  fetch\n\t});\n\tconst authLink = setContext((_, { headers }) => {\n\t  const apiHeaders: Record<string, string> = {};\n\t  const apiKey = process.env.KEYCARD_API_KEY;\n", "  if (apiKey && apiKey.length > 0) {\n\t    apiHeaders['x-api-key'] = apiKey;\n\t  }\n\t  return {\n\t    headers: {\n\t      ...headers,\n\t      ...apiHeaders\n\t    }\n\t  };\n\t});\n", "const client = new ApolloClient({\n\t  link: authLink.concat(httpLink),\n\t  cache: new InMemoryCache({\n\t    addTypename: false\n\t  }),\n\t  defaultOptions: {\n\t    query: {\n\t      fetchPolicy: 'no-cache'\n\t    }\n\t  }\n", "});\n\tconst PROPOSAL_QUERY = gql`\n\t  query Proposal($id: String) {\n\t    proposal(id: $id) {\n\t      id\n\t      state\n\t      choices\n\t      votes\n\t      author\n\t      space {\n", "        id\n\t        network\n\t      }\n\t    }\n\t  }\n\t`;\n\tconst VOTES_QUERY = gql`\n\t  query Votes(\n\t    $id: String!\n\t    $first: Int\n", "    $skip: Int\n\t    $orderBy: String\n\t    $orderDirection: OrderDirection\n\t    $created_gte: Int\n\t  ) {\n\t    votes(\n\t      first: $first\n\t      skip: $skip\n\t      where: { proposal: $id, created_gte: $created_gte }\n\t      orderBy: $orderBy\n", "      orderDirection: $orderDirection\n\t    ) {\n\t      ipfs\n\t      voter\n\t      choice\n\t      vp\n\t      reason\n\t      created\n\t    }\n\t  }\n", "`;\n\tconst SPACE_QUERY = gql`\n\t  query Space($id: String) {\n\t    space(id: $id) {\n\t      id\n\t      network\n\t    }\n\t  }\n\t`;\n\texport async function fetchProposal(id: string) {\n", "  const {\n\t    data: { proposal }\n\t  }: { data: { proposal: Proposal | null } } = await client.query({\n\t    query: PROPOSAL_QUERY,\n\t    variables: {\n\t      id\n\t    }\n\t  });\n\t  return proposal;\n\t}\n", "export async function fetchVotes(\n\t  id: string,\n\t  { first = 1000, skip = 0, orderBy = 'created_gte', orderDirection = 'asc', created_gte = 0 } = {}\n\t) {\n\t  const {\n\t    data: { votes }\n\t  }: { data: { votes: Vote[] } } = await client.query({\n\t    query: VOTES_QUERY,\n\t    variables: {\n\t      id,\n", "      orderBy,\n\t      orderDirection,\n\t      first,\n\t      skip,\n\t      created_gte\n\t    }\n\t  });\n\t  return votes;\n\t}\n\texport async function fetchSpace(id: string) {\n", "  const {\n\t    data: { space }\n\t  }: { data: { space: Space | null } } = await client.query({\n\t    query: SPACE_QUERY,\n\t    variables: {\n\t      id\n\t    }\n\t  });\n\t  return space;\n\t}\n"]}
{"filename": "src/helpers/sentry.ts", "chunked_list": ["import * as Sentry from '@sentry/node';\n\timport type { Express } from 'express';\n\texport function initLogger(app: Express) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    return;\n\t  }\n\t  Sentry.init({\n\t    dsn: process.env.SENTRY_DSN,\n\t    integrations: [\n\t      new Sentry.Integrations.Http({ tracing: true }),\n", "      new Sentry.Integrations.Express({ app }),\n\t      ...Sentry.autoDiscoverNodePerformanceMonitoringIntegrations()\n\t    ],\n\t    tracesSampleRate: parseFloat(process.env.SENTRY_TRACE_SAMPLE_RATE as string)\n\t  });\n\t  app.use(Sentry.Handlers.requestHandler());\n\t  app.use(Sentry.Handlers.tracingHandler());\n\t}\n\texport function fallbackLogger(app: Express) {\n\t  if (process.env.NODE_ENV !== 'production') {\n", "    return;\n\t  }\n\t  app.use(Sentry.Handlers.errorHandler());\n\t  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t  app.use(function onError(err: any, req: any, res: any, _: any) {\n\t    res.statusCode = 500;\n\t    res.end(`${res.sentry}\\n`);\n\t  });\n\t}\n\texport function capture(e: any) {\n", "  if (process.env.NODE_ENV !== 'production') {\n\t    return console.error(e);\n\t  }\n\t  Sentry.captureException(e);\n\t}\n"]}
{"filename": "src/helpers/utils.ts", "chunked_list": ["import FileStorageEngine from '../lib/storage/file';\n\timport AwsStorageEngine from '../lib/storage/aws';\n\timport type { Response } from 'express';\n\tconst ERROR_CODES: Record<string, number> = {\n\t  'Invalid Request': -32600,\n\t  RECORD_NOT_FOUND: 404,\n\t  UNAUTHORIZED: 401\n\t};\n\texport function rpcSuccess(res: Response, result: string, id: string | number) {\n\t  res.json({\n", "    jsonrpc: '2.0',\n\t    result,\n\t    id\n\t  });\n\t}\n\texport function rpcError(res: Response, e: Error | string, id: string | number) {\n\t  const errorMessage = e instanceof Error ? e.message : e;\n\t  const errorCode = ERROR_CODES[errorMessage] ? ERROR_CODES[errorMessage] : -32603;\n\t  res.status(errorCode > 0 ? errorCode : 500).json({\n\t    jsonrpc: '2.0',\n", "    error: {\n\t      code: errorCode,\n\t      message: errorMessage\n\t    },\n\t    id\n\t  });\n\t}\n\texport async function sleep(time: number) {\n\t  return new Promise(resolve => {\n\t    setTimeout(resolve, time);\n", "  });\n\t}\n\texport function storageEngine(subDir?: string) {\n\t  if (process.env.STORAGE_ENGINE === 'aws') {\n\t    return new AwsStorageEngine(subDir);\n\t  } else {\n\t    return new FileStorageEngine(subDir);\n\t  }\n\t}\n"]}
