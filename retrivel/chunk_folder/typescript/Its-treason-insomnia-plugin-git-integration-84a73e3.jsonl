{"filename": "src/insomniaDbTypes.ts", "chunked_list": ["/* eslint @typescript-eslint/no-explicit-any: 0 */\n\t// These are all types from the Insomnia source code\n\t// All type declarations are located in \"packages/insomnia/src/models/*\"\n\t// Most types are declared in files inside this folder with the same name\n\t// index.ts\n\texport interface BaseModel {\n\t  _id: string;\n\t  type: string;\n\t  // TSCONVERSION -- parentId is always required for all models, except 4:\n\t  //   - Stats, Settings, and Project, which never have a parentId\n", "  //   - Workspace optionally has a parentId (which will be the id of a Project)\n\t  parentId: string; // or null\n\t  modified: number;\n\t  created: number;\n\t  isPrivate: boolean;\n\t  name: string;\n\t}\n\t// Environment\n\texport type Environment = {\n\t  name: string;\n", "  data: Record<string, any>;\n\t  dataPropertyOrder: Record<string, any> | null;\n\t  color: string | null;\n\t  metaSortKey: number;\n\t  // For sync control\n\t  isPrivate: boolean;\n\t} & BaseModel;\n\t// Project\n\texport type Project = {\n\t  name: string,\n", "  remoteId?: string, // Only remote projects have a remote id\n\t} & BaseModel;\n\t// Workspace\n\texport type Workspace = {\n\t  name: string;\n\t  description: string;\n\t  certificates?: any; // deprecate\n\t  scope: 'design' | 'collection',\n\t} & BaseModel;\n\t// WorkspaceMeta\n", "export type WorkspaceMeta = {\n\t  activeActivity: string | null;\n\t  activeEnvironmentId: string | null;\n\t  activeRequestId: string | null;\n\t  activeUnitTestSuiteId: string | null;\n\t  cachedGitLastAuthor: string | null;\n\t  cachedGitLastCommitTime: number | null;\n\t  cachedGitRepositoryBranch: string | null;\n\t  gitRepositoryId: string | null;\n\t  hasSeen: boolean;\n", "  paneHeight: number;\n\t  paneWidth: number;\n\t  parentId: string | null;\n\t  sidebarFilter: string;\n\t  sidebarHidden: boolean;\n\t  sidebarWidth: number;\n\t  pushSnapshotOnInitialize: boolean;\n\t} & BaseModel;\n\t// Request\n\texport type BaseRequest = {\n", "    url: string;\n\t  name: string;\n\t  description: string;\n\t  method: string;\n\t  body: RequestBody;\n\t  parameters: RequestParameter[];\n\t  headers: RequestHeader[];\n\t  authentication: Record<string, string>; // This should be RequestAuthentication but is not used in the project\n\t  metaSortKey: number;\n\t  isPrivate: boolean;\n", "  // Settings\n\t  settingStoreCookies: boolean;\n\t  settingSendCookies: boolean;\n\t  settingDisableRenderRequestBody: boolean;\n\t  settingEncodeUrl: boolean;\n\t  settingRebuildPath: boolean;\n\t  settingFollowRedirects: 'global' | 'on' | 'off';\n\t} & BaseModel;\n\texport interface RequestHeader {\n\t  name: string;\n", "  value: string;\n\t  description?: string;\n\t  disabled?: boolean;\n\t}\n\texport interface RequestParameter {\n\t  name: string;\n\t  value: string;\n\t  disabled?: boolean;\n\t  id?: string;\n\t  fileName?: string;\n", "}\n\texport interface RequestBodyParameter {\n\t  name: string;\n\t  value: string;\n\t  description?: string;\n\t  disabled?: boolean;\n\t  multiline?: string;\n\t  id?: string;\n\t  fileName?: string;\n\t  type?: string;\n", "}\n\texport interface RequestBody {\n\t  mimeType?: string | null;\n\t  text?: string;\n\t  fileName?: string;\n\t  params?: RequestBodyParameter[];\n\t}\n\t// RequestMeta\n\texport type RequestMeta = {\n\t  parentId: string;\n", "  previewMode: 'friendly' | 'source' | 'raw'; // This is PreviewMode from ../common/constants\n\t  responseFilter: string;\n\t  responseFilterHistory: string[];\n\t  activeResponseId: string | null;\n\t  savedRequestBody: Record<string, any>;\n\t  pinned: boolean;\n\t  lastActive: number;\n\t  downloadPath: string | null;\n\t  expandedAccordionKeys: Partial<Record<'OAuth2AdvancedOptions', boolean>>;\n\t} & BaseModel;\n", "// RequestGroup\n\texport type RequestGroup = {\n\t  name: string;\n\t  description: string;\n\t  environment: Record<string, any>;\n\t  environmentPropertyOrder: Record<string, any> | null;\n\t  metaSortKey: number;\n\t} & BaseModel;\n\t// RequestGroupMeta\n\texport type RequestGroupMeta = {\n", "  collapsed: boolean,\n\t} & BaseModel;\n\t// ApiSpec\n\texport type ApiSpec = {\n\t  fileName: string;\n\t  contentType: 'json' | 'yaml';\n\t  contents: string;\n\t} & BaseModel\n\t// Unittest Suite\n\texport type UnittestSuite = {\n", "  name: string,\n\t} & BaseModel\n\t// Unittest\n\texport type UnitTest = {\n\t  name: string;\n\t  code: string;\n\t  requestId: string | null;\n\t} & BaseModel;\n"]}
{"filename": "src/autoExport.ts", "chunked_list": ["import fs from 'node:fs';\n\timport { join } from 'path';\n\timport InternalDb from './db/InternalDb';\n\timport { getActiveProjectId } from './db/localStorageUtils';\n\timport { exportProject } from './exportData';\n\timport { importProject, readProjectData } from './importData';\n\timport renderModal from './ui/react/renderModal';\n\timport confirmModal from './ui/react/confirmModal';\n\tlet prevExport = '';\n\texport default async function autoExport() {\n", "  const projectId = getActiveProjectId();\n\t  if (!projectId) {\n\t    return;\n\t  }\n\t  const config = InternalDb.create();\n\t  const { repositoryPath: path, autoExport } = config.getProject(projectId);\n\t  if (!path || !autoExport || projectId === 'proj_default-project') {\n\t    return;\n\t  }\n\t  const [projectData, workspaces] = await exportProject(projectId);\n", "  const newExportJson = JSON.stringify([projectData, workspaces]);\n\t  if (newExportJson === prevExport) {\n\t    // Nothing to export, so lets try to Import\n\t    await autoImportProject(path);\n\t    return;\n\t  }\n\t  prevExport = newExportJson;\n\t  const targetFile = join(path, 'project.json');\n\t  fs.writeFileSync(targetFile, JSON.stringify(projectData, null, 2));\n\t  for (const workspace of workspaces) {\n", "    const targetFile = join(path, workspace.id + '.json');\n\t    fs.writeFileSync(targetFile, JSON.stringify(workspace, null, 2));\n\t  }\n\t}\n\tlet prevImport = '';\n\tasync function autoImportProject(path: string) {\n\t  let project, workspaceData;\n\t  try {\n\t    [project, workspaceData] = readProjectData(path);\n\t  } catch (e) {\n", "    console.error('[IPGI] Error while gathering import data during auto import. This might not be a bug', e);\n\t    return;\n\t  }\n\t  const newImportJson = JSON.stringify([project, workspaceData]);\n\t  // Do not import the first time\n\t  if (prevImport === '') {\n\t    prevImport = newImportJson;\n\t    return;\n\t  }\n\t  if (prevImport === newImportJson) {\n", "    // Nothing to import\n\t    return;\n\t  }\n\t  const doImport = await renderModal<boolean>(confirmModal(\n\t    'Import project',\n\t    'Import chhanged project data? Insomnia will restart.',\n\t  ));\n\t  if (!doImport) {\n\t    return;\n\t  }\n", "  await importProject(project, workspaceData);\n\t  // Force Insomnia to read all data\n\t  // @ts-ignore\n\t  window.main.restart();\n\t}\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { BaseRequest, WorkspaceMeta, RequestGroup, RequestGroupMeta, RequestMeta, Workspace, Environment, BaseModel, UnittestSuite, UnitTest, ApiSpec } from './insomniaDbTypes';\n\texport type GitSavedProject = {\n\t  name: string,\n\t  id: string,\n\t  remoteId: string | null,\n\t  workspaceIds: string[],\n\t}\n\texport type GitSavedWorkspace = {\n\t  name: string,\n\t  id: string,\n", "  workspace: Workspace,\n\t  meta: GitSavedWorkspaceMeta,\n\t  requests: GitSavedRequest[],\n\t  environments: Environment[],\n\t  apiSpec?: ApiSpec,\n\t  unitTestSuites: GitSavedUnitTestSuite[],\n\t}\n\texport type GitSavedUnitTestSuite = {\n\t  testSuite: UnittestSuite,\n\t  tests: UnitTest[],\n", "}\n\texport type GitSavedRequest = {\n\t  type: 'request',\n\t  id: string,\n\t  request: BaseRequest,\n\t  meta: RequestMeta,\n\t} | {\n\t  type: 'group',\n\t  id: string,\n\t  group: RequestGroup,\n", "  meta: RequestGroupMeta,\n\t  children: GitSavedRequest[],\n\t}\n\texport type GitSavedWorkspaceMeta = Pick<WorkspaceMeta, 'activeActivity' | 'activeEnvironmentId' | 'activeRequestId' | keyof BaseModel>\n"]}
{"filename": "src/OldIds.ts", "chunked_list": ["import { GitSavedRequest, GitSavedWorkspace } from './types';\n\texport default class OldIds {\n\t  private constructor(\n\t    private environmentIds: string[],\n\t    private requestIds: string[],\n\t    private requestGroupIds: string[],\n\t    private testSuites: string[],\n\t    private tests: string[],\n\t  ) {}\n\t  public static createEmpty(): OldIds {\n", "    return new OldIds([], [], [], [], []);\n\t  }\n\t  public static fromOldData(data: GitSavedWorkspace): OldIds {\n\t    const environmentIds = data.environments.map((env) => env._id);\n\t    const requestIds = [];\n\t    const requestGroupIds = [];\n\t    OldIds.getIdsRecursive(data.requests, requestIds, requestGroupIds);\n\t    const tests = [];\n\t    const testSuites = data.unitTestSuites.map((testSuite) => {\n\t      for (const test of testSuite.tests) {\n", "        tests.push(test._id);\n\t      }\n\t      return testSuite.testSuite._id;\n\t    });\n\t    return new OldIds(environmentIds, requestIds, requestGroupIds, testSuites, tests);\n\t  }\n\t  private static getIdsRecursive(requests: GitSavedRequest[], requestIds: string[], requestGroupIds: string[]) {\n\t    for (const request of requests) {\n\t      if (request.type === 'group') {\n\t        requestGroupIds.push(request.id);\n", "        OldIds.getIdsRecursive(request.children, requestIds, requestGroupIds);\n\t        continue;\n\t      }\n\t      requestIds.push(request.id);\n\t    }\n\t  }\n\t  public getEnvironmentIds(): string[] {\n\t    return this.environmentIds;\n\t  }\n\t  public removeEnvironmentId(id: string): void {\n", "    const index = this.environmentIds.indexOf(id);\n\t    if (index !== -1) {\n\t      this.environmentIds.splice(index, 1);\n\t    }\n\t  }\n\t  public getRequestIds(): string[] {\n\t    return this.requestIds;\n\t  }\n\t  public removeRequestId(id: string): void {\n\t    const index = this.requestIds.indexOf(id);\n", "    if (index !== -1) {\n\t      this.requestIds.splice(index, 1);\n\t    }\n\t  }\n\t  public getRequestGroupId(): string[] {\n\t    return this.requestGroupIds;\n\t  }\n\t  public removeRequestGroupId(id: string): void {\n\t    const index = this.requestGroupIds.indexOf(id);\n\t    if (index !== -1) {\n", "      this.requestGroupIds.splice(index, 1);\n\t    }\n\t  }\n\t  public getTestSuites(): string[] {\n\t    return this.testSuites;\n\t  }\n\t  public removeTestSuites(id: string): void {\n\t    const index = this.testSuites.indexOf(id);\n\t    if (index !== -1) {\n\t      this.testSuites.splice(index, 1);\n", "    }\n\t  }\n\t  public getTests(): string[] {\n\t    return this.tests;\n\t  }\n\t  public removeTest(id: string): void {\n\t    const index = this.tests.indexOf(id);\n\t    if (index !== -1) {\n\t      this.tests.splice(index, 1);\n\t    }\n", "  }\n\t}\n"]}
{"filename": "src/exportData.ts", "chunked_list": ["import BaseDb from './db/BaseDb';\n\timport { BaseRequest, RequestMeta, RequestGroup, RequestGroupMeta, Workspace, WorkspaceMeta, Environment, Project, ApiSpec, UnittestSuite, UnitTest } from './insomniaDbTypes';\n\timport { GitSavedProject, GitSavedRequest, GitSavedUnitTestSuite, GitSavedWorkspace, GitSavedWorkspaceMeta } from './types';\n\timport { randomBytes } from 'crypto';\n\tfunction createDefaultFolderMeta(parentId: string): RequestGroupMeta {\n\t  return {\n\t    collapsed: true,\n\t    parentId,\n\t    created: Date.now(),\n\t    isPrivate: false,\n", "    modified: Date.now(),\n\t    type: 'RequestGroupMeta',\n\t    _id: 'fldm_' + randomBytes(16).toString('hex'),\n\t    name: '', // This is not used by insomnia.\n\t  };\n\t}\n\tfunction createDefaultRequestMeta(parentId: string): RequestMeta {\n\t  return {\n\t    parentId,\n\t    previewMode: \"friendly\", // PREVIEW_MODE_FRIENDLY\n", "    responseFilter: '',\n\t    responseFilterHistory: [],\n\t    activeResponseId: null,\n\t    savedRequestBody: {},\n\t    pinned: false,\n\t    lastActive: 0,\n\t    downloadPath: null,\n\t    expandedAccordionKeys: {},\n\t    created: Date.now(),\n\t    isPrivate: false,\n", "    modified: Date.now(),\n\t    type: 'RequestMeta',\n\t    _id: 'reqm_' + randomBytes(16).toString('hex'),\n\t    name: '', // This is not used by insomnia.\n\t  }\n\t}\n\texport async function exportProject(projectId: string): Promise<[GitSavedProject, GitSavedWorkspace[]]> {\n\t  // Load the Project\n\t  const projectDb = new BaseDb<Project>('Project');\n\t  const fullProject = await projectDb.findById(projectId);\n", "  if (!fullProject) {\n\t    throw new Error('Project not found with id ' + projectId);\n\t  }\n\t  const project: GitSavedProject = {\n\t    id: fullProject._id,\n\t    name: fullProject.name,\n\t    remoteId: fullProject.remoteId,\n\t    workspaceIds: [],\n\t  };\n\t  // Load all workspaces\n", "  const workspaceDb = new BaseDb<Workspace>('Workspace');\n\t  const workspaces = await workspaceDb.findBy('parentId', fullProject._id);\n\t  const savedWorkspaces: GitSavedWorkspace[] = [];\n\t  for (const workspace of workspaces) {\n\t    savedWorkspaces.push(await exportWorkspaceData(workspace._id));\n\t    project.workspaceIds.push(workspace._id);\n\t  }\n\t  return [project, savedWorkspaces];\n\t}\n\t// ParentId is either the WorkspaceId for TopLevel requests or an FolderId for nested requests\n", "async function getRequestsForParentId(\n\t  parentId: string,\n\t  requestDb: BaseDb<BaseRequest>,\n\t  requestMetaDb: BaseDb<RequestMeta>,\n\t  requestGroupDb: BaseDb<RequestGroup>,\n\t  requestGroupMetaDb: BaseDb<RequestGroupMeta>,\n\t): Promise<GitSavedRequest[]> {\n\t  const gitSavedRequests: GitSavedRequest[] = [];\n\t  const requests = await requestDb.findBy('parentId', parentId);\n\t  for (const request of requests) {\n", "    const metas = await requestMetaDb.findBy('parentId', request._id);\n\t    // When duplicating a Workspace the Request meta is not automaticly created\n\t    // As a workaround we use the default object.\n\t    // See: https://github.com/Kong/insomnia/blob/develop/packages/insomnia/src/models/request-meta.ts#L32\n\t    const meta = metas[0] || createDefaultRequestMeta(request._id);\n\t    gitSavedRequests.push({\n\t      type: 'request',\n\t      id: request._id,\n\t      meta,\n\t      request,\n", "    });\n\t  }\n\t  const groups = await requestGroupDb.findBy('parentId', parentId);\n\t  for (const group of groups) {\n\t    const metas = await requestGroupMetaDb.findBy('parentId', group._id);\n\t    // Create default GroupMetadata when nothing was found. Not sure when this happens but should fix #3\n\t    const meta = metas[0] || createDefaultFolderMeta(group._id);\n\t    gitSavedRequests.push({\n\t      type: 'group',\n\t      id: group._id,\n", "      group,\n\t      children: await getRequestsForParentId(group._id, requestDb, requestMetaDb, requestGroupDb, requestGroupMetaDb),\n\t      meta,\n\t    });\n\t  }\n\t  return gitSavedRequests;\n\t}\n\tasync function getTestSuites(workspaceId: string): Promise<GitSavedUnitTestSuite[]> {\n\t  const savedUnittestSuites: GitSavedUnitTestSuite[] = [];\n\t  const unitTestSuitesDb = new BaseDb<UnittestSuite>('UnitTestSuite');\n", "  const unittestDb = new BaseDb<UnitTest>('UnitTest');\n\t  const unitTestSuites = await unitTestSuitesDb.findBy('parentId', workspaceId);\n\t  for (const testSuite of unitTestSuites) {\n\t    const tests = await unittestDb.findBy('parentId', testSuite._id);\n\t    savedUnittestSuites.push({\n\t      tests,\n\t      testSuite,\n\t    });\n\t  }\n\t  return savedUnittestSuites;\n", "}\n\tasync function getApiSpec(workspaceId: string): Promise<ApiSpec | null> {\n\t  const apiSpecDb = new BaseDb<ApiSpec>('ApiSpec');\n\t  const apiSpecs = await apiSpecDb.findBy('parentId', workspaceId);\n\t  return apiSpecs[0] ?? null;\n\t}\n\texport async function exportWorkspaceData(workspaceId: string): Promise<GitSavedWorkspace> {\n\t  // Find workspace\n\t  const workspaceDb = new BaseDb<Workspace>('Workspace');\n\t  const workspace = await workspaceDb.findById(workspaceId);\n", "  if (!workspace) {\n\t    throw new Error('No Workspace found for id: ' + workspaceId);\n\t  }\n\t  const name = workspace.name;\n\t  // Find WorkspaceMeta\n\t  const workspaceMetaDb = new BaseDb<WorkspaceMeta>('WorkspaceMeta');\n\t  const fullMetas = await workspaceMetaDb.findBy('parentId', workspaceId);\n\t  const fullMeta = fullMetas[0];\n\t  const meta: GitSavedWorkspaceMeta = {\n\t    _id: fullMeta._id,\n", "    created: fullMeta.created,\n\t    isPrivate: fullMeta.isPrivate,\n\t    modified: fullMeta.modified,\n\t    name: fullMeta.name,\n\t    parentId: fullMeta.parentId,\n\t    type: fullMeta.type,\n\t    activeActivity: fullMeta.activeActivity,\n\t    activeEnvironmentId: fullMeta.activeEnvironmentId,\n\t    activeRequestId: fullMeta.activeRequestId,\n\t  };\n", "  const requestDb = new BaseDb<BaseRequest>('Request');\n\t  const requestMetaDb = new BaseDb<RequestMeta>('RequestMeta');\n\t  const requestGroupDb = new BaseDb<RequestGroup>('RequestGroup');\n\t  const requestGroupMetaDb = new BaseDb<RequestGroupMeta>('RequestGroupMeta');\n\t  const requests = await getRequestsForParentId(workspaceId, requestDb, requestMetaDb, requestGroupDb, requestGroupMetaDb);\n\t  // Find environments\n\t  const environmentDb = new BaseDb<Environment>('Environment');\n\t  const baseEnvironments = await environmentDb.findBy('parentId', workspaceId);\n\t  if (baseEnvironments.length === 0) {\n\t    throw new Error('No BaseEnvironment found for parentId: ' + workspaceId);\n", "  }\n\t  const baseEnvironment = baseEnvironments[0];\n\t  // Get all SubEnv -> Filter out private ones -> Add the BaseEnv to the Top\n\t  const environments = (await environmentDb.findBy('parentId', baseEnvironment._id))\n\t    .filter((env) => env.isPrivate === false);\n\t  environments.unshift(baseEnvironment);\n\t  const apiSpec = await getApiSpec(workspaceId);\n\t  const unitTestSuites = await getTestSuites(workspaceId);\n\t  return {\n\t    id: workspaceId,\n", "    name,\n\t    workspace,\n\t    meta,\n\t    requests,\n\t    environments,\n\t    apiSpec,\n\t    unitTestSuites,\n\t  };\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { exportProject, exportWorkspaceData } from './exportData';\n\timport fs from 'node:fs';\n\timport { importWorkspaceData } from './importData';\n\timport InternalDb from './db/InternalDb';\n\timport { getActiveProjectId, getActiveWorkspace } from './db/localStorageUtils';\n\timport { join } from 'node:path';\n\timport importNewProjectButton from './ui/importNewProjectButton';\n\timport projectDropdown from './ui/projectDropdown';\n\timport alertModal from './ui/react/alertModal';\n\timport renderModal from './ui/react/renderModal';\n", "import injectStyles from './ui/injectStyles';\n\timport autoExport from './autoExport';\n\t// Inject UI elements.\n\t// @ts-ignore\n\tconst currentVersion = (window.gitIntegrationInjectCounter || 0) + 1;\n\t// @ts-ignore\n\twindow.gitIntegrationInjectCounter = currentVersion;\n\tfunction doInject() {\n\t  // @ts-ignore\n\t  // Check if the window was reloaded. When it was reloaded the Global counter changed\n", "  if (window.gitIntegrationInjectCounter !== currentVersion) {\n\t    return;\n\t  }\n\t  injectStyles();\n\t  projectDropdown();\n\t  importNewProjectButton();\n\t  window.requestAnimationFrame(doInject);\n\t}\n\twindow.requestAnimationFrame(doInject);\n\tsetInterval(autoExport, 5000);\n", "module.exports.workspaceActions = [\n\t  {\n\t    label: 'Export workspace to Git',\n\t    icon: 'download',\n\t    action: async () => {\n\t      const projectId = getActiveProjectId();\n\t      const workspaceId = getActiveWorkspace();\n\t      const config = InternalDb.create();\n\t      const path = config.getProjectPath(projectId);\n\t      if (!path || projectId === 'proj_default-project') {\n", "        await renderModal(alertModal(\n\t          'Cannot export workspace',\n\t          'You must first configure the project folder before exporting',\n\t        ));\n\t        return;\n\t      }\n\t      const data = await exportWorkspaceData(workspaceId);\n\t      const targetFile = join(path, workspaceId + '.json');\n\t      fs.writeFileSync(targetFile, JSON.stringify(data, null, 2));\n\t    },\n", "  },\n\t  {\n\t    label: 'Import workspace from Git',\n\t    icon: 'upload',\n\t    action: async () => {\n\t      const projectId = getActiveProjectId();\n\t      const workspaceId = getActiveWorkspace();\n\t      const config = InternalDb.create();\n\t      const path = config.getProjectPath(projectId);\n\t      if (!path || projectId === 'proj_default-project') {\n", "        await renderModal(alertModal(\n\t          'Cannot import workspace',\n\t          'You must first configure the project folder before importing',\n\t        ));\n\t        return;\n\t      }\n\t      const targetFile = join(path, workspaceId + '.json');\n\t      const dataRaw = JSON.parse(fs.readFileSync(targetFile).toString());\n\t      await importWorkspaceData(dataRaw);\n\t      // Force Insomnia to read all data\n", "      // @ts-ignore\n\t      window.main.restart();\n\t    },\n\t  },\n\t];\n"]}
{"filename": "src/insomniaTypes.ts", "chunked_list": ["/* eslint @typescript-eslint/no-unused-vars: 0 */\n\timport { Readable } from 'node:stream';\n\t/** context.request: https://docs.insomnia.rest/insomnia/context-object-reference#contextrequest */\n\tinterface RequestContext {\n\t  getId(): string;\n\t  getName(): string;\n\t  getUrl(): string;\n\t  setUrl(url: string): void;\n\t  getMethod(): string;\n\t  setMethod(method: string): void;\n", "  getHeaders(): Array<{ name: string, value: string }>;\n\t  getHeader(name: string): string | null;\n\t  hasHeader(name: string): boolean;\n\t  removeHeader(name: string): void;\n\t  setHeader(name: string, value: string): void;\n\t  addHeader(name: string, value: string): void;\n\t  getParameter(name: string): string | null;\n\t  getParameters(): Array<{ name: string, value: string }>;\n\t  setParameter(name: string, value: string): void;\n\t  hasParameter(name: string): boolean;\n", "  addParameter(name: string, value: string): void;\n\t  removeParameter(name: string): void;\n\t  getBody(): RequestBody;\n\t  setBody(body: RequestBody): void;\n\t  getEnvironmentVariable(name: string): unknown;\n\t  getEnvironment(): object;\n\t  setAuthenticationParameter(name: string, value: string): void;\n\t  getAuthentication(): object;\n\t  setCookie(name: string, value: string): void;\n\t  settingSendCookies(enabled: boolean): void;\n", "  settingStoreCookies(enabled: boolean): void;\n\t  settingEncodeUrl(enabled: boolean): void;\n\t  settingDisableRenderRequestBody(enabled: boolean): void;\n\t  settingFollowRedirects(enabled: boolean): void;\n\t}\n\tinterface RequestBody {\n\t  mimeType?: string;\n\t  text?: string;\n\t  fileName?: string;\n\t  params?: RequestBodyParameter[];\n", "}\n\tinterface RequestBodyParameter {\n\t  name: string;\n\t  value: string;\n\t  description?: string;\n\t  disabled?: boolean;\n\t  multiline?: string;\n\t  id?: string;\n\t  fileName?: string;\n\t  type?: string;\n", "}\n\t/** context.response: https://docs.insomnia.rest/insomnia/context-object-reference#contextresponse */\n\tinterface ResponseContext {\n\t  getRequestId(): string;\n\t  getStatusCode(): number;\n\t  getStatusMessage(): string;\n\t  getBytesRead(): number;\n\t  getTime(): number;\n\t  getBody(): Buffer | null;\n\t  getBodyStream(): Readable;\n", "  setBody(body: Buffer);\n\t  getHeader(name: string): string | Array<string> | null;\n\t  getHeaders(): Array<{ name: string, value: string }> | undefined;\n\t  hasHeader(name: string): boolean,\n\t}\n\t/** context.store: https://docs.insomnia.rest/insomnia/context-object-reference#contextstore */\n\tinterface StoreContext {\n\t  hasItem(key: string): Promise<boolean>;\n\t  setItem(key: string, value: string): Promise<void>;\n\t  getItem(key: string): Promise<string | null>;\n", "  removeItem(key: string): Promise<void>;\n\t  clear(): Promise<void>;\n\t  all(): Promise<Array<{ key: string, value: string }>>;\n\t}\n\t/** context.app: https://docs.insomnia.rest/insomnia/context-object-reference#contextapp */\n\tinterface AppContext {\n\t  getInfo(): { version: string, platform: string };\n\t  alert(title: string, message?: string): Promise<void>;\n\t  dialog(title: string, body: HTMLElement, options?: {\n\t    onHide?: () => void;\n", "    tall?: boolean;\n\t    skinny?: boolean;\n\t    wide?: boolean;\n\t  }): void;\n\t  prompt(title: string, options?: {\n\t    label?: string;\n\t    defaultValue?: string;\n\t    submitName?: string;\n\t    cancelable?: boolean;\n\t  }): Promise<string>;\n", "  getPath(name: string): string;\n\t  showSaveDialog(options?: {\n\t    defaultPath?: string;\n\t  }): Promise<string | null>;\n\t  clipboard: {\n\t    readText(): string;\n\t    writeText(text: string): void;\n\t    clear(): void;\n\t  };\n\t}\n", "/** context.data https://docs.insomnia.rest/insomnia/context-object-reference#contextdata */\n\tinterface ImportOptions {\n\t    workspaceId?: string;\n\t    workspaceScope?: 'design' | 'collection';\n\t}\n\tinterface DataContext {\n\t    import: {\n\t        uri(uri: string, options?: ImportOptions): Promise<void>;\n\t        raw(text: string, options?: ImportOptions): Promise<void>;\n\t    },\n", "    export: {\n\t        insomnia(options?: { \n\t            includePrivate?: boolean,\n\t            format?: 'json' | 'yaml',\n\t        }): Promise<string>;\n\t        har(options?: { includePrivate?: boolean }): Promise<string>;\n\t    }\n\t}\n\t/** context.network https://docs.insomnia.rest/insomnia/context-object-reference#contextnetwork */\n\tinterface NetworkContext {\n", "    sendRequest(request: Request): Promise<Response>;\n\t}\n"]}
{"filename": "src/importData.ts", "chunked_list": ["import { join } from 'node:path';\n\timport fs from 'node:fs';\n\timport BaseDb from './db/BaseDb';\n\timport { exportWorkspaceData } from './exportData';\n\timport { Workspace, WorkspaceMeta, BaseRequest, RequestMeta, RequestGroup, RequestGroupMeta, Environment, Project, ApiSpec, UnittestSuite, UnitTest } from './insomniaDbTypes';\n\timport OldIds from './OldIds';\n\timport { GitSavedRequest, GitSavedWorkspace, GitSavedProject } from './types';\n\texport function readProjectData(path: string): [GitSavedProject, GitSavedWorkspace[]] {\n\t  // Read the Project file\n\t  const projectFile = join(path, 'project.json');\n", "  // TODO: Validate this using Zod\n\t  const project: GitSavedProject = JSON.parse(fs.readFileSync(projectFile).toString());\n\t  // Read all the workspace data\n\t  const workspaceData: GitSavedWorkspace[] = [];\n\t  for (const workspaceId of project.workspaceIds) {\n\t    const workspaceFile = join(path, workspaceId + '.json');\n\t    // TODO: Validate this using Zod\n\t    const workspace: GitSavedWorkspace = JSON.parse(fs.readFileSync(workspaceFile).toString());\n\t    workspaceData.push(workspace);\n\t  }\n", "  return [project, workspaceData];\n\t}\n\texport async function importProject(project: GitSavedProject, workspaces: GitSavedWorkspace[]) {\n\t  // Upsert the Project\n\t  const projectDb = new BaseDb<Project>('Project');\n\t  await projectDb.upsert({\n\t    _id: project.id,\n\t    name: project.name,\n\t    remoteId: project.remoteId,\n\t    created: Date.now(),\n", "    isPrivate: false,\n\t    modified: Date.now(),\n\t    parentId: null,\n\t    type: 'Project',\n\t  });\n\t  const workspaceDb = new BaseDb<Workspace>('Workspace');\n\t  const workspaceMetaDb = new BaseDb<Workspace>('WorkspaceMeta');\n\t  let oldWorkspaces = (await workspaceDb.findBy('parentId', project.id)).map((ws) => ws._id);\n\t  // Update all Workspaces\n\t  for (const workspace of workspaces) {\n", "    oldWorkspaces = oldWorkspaces.filter((oldWs) => oldWs !== workspace.id);\n\t    await importWorkspaceData(workspace);\n\t  }\n\t  // Delete old workspaces\n\t  for (const oldWorkspace of oldWorkspaces) {\n\t    await workspaceDb.deleteBy('_id', oldWorkspace);\n\t    await workspaceMetaDb.deleteBy('parentId', oldWorkspace);\n\t  }\n\t}\n\tasync function upsertRequestsRecursive(\n", "  requests: GitSavedRequest[],\n\t  oldIds: OldIds,\n\t  requestDb: BaseDb<BaseRequest>,\n\t  requestMetaDb: BaseDb<RequestMeta>,\n\t  requestGroupDb: BaseDb<RequestGroup>,\n\t  requestGroupMetaDb: BaseDb<RequestGroupMeta>,\n\t) {\n\t  for (const request of requests) {\n\t    if (request.type === 'group') {\n\t      await requestGroupDb.upsert(request.group);\n", "      await requestGroupMetaDb.upsert(request.meta);\n\t      oldIds.removeRequestGroupId(request.id);\n\t      await upsertRequestsRecursive(request.children, oldIds, requestDb, requestMetaDb, requestGroupDb, requestGroupMetaDb);\n\t      continue;\n\t    }\n\t    await requestDb.upsert(request.request);\n\t    await requestMetaDb.upsert(request.meta);\n\t    oldIds.removeRequestId(request.id);\n\t  }\n\t}\n", "async function removeOldData(\n\t  oldIds: OldIds,\n\t  requestDb: BaseDb<BaseRequest>,\n\t  requestMetaDb: BaseDb<RequestMeta>,\n\t  requestGroupDb: BaseDb<RequestGroup>,\n\t  requestGroupMetaDb: BaseDb<RequestGroupMeta>,\n\t  environmentDb: BaseDb<Environment>,\n\t  testSuitesDb: BaseDb<UnittestSuite>,\n\t  testDb: BaseDb<UnitTest>,\n\t) {\n", "  for (const envId of oldIds.getEnvironmentIds()) {\n\t    await environmentDb.deleteBy('_id', envId);\n\t  }\n\t  for (const requestId of oldIds.getRequestIds()) {\n\t    await requestDb.deleteBy('_id', requestId);\n\t    await requestMetaDb.deleteBy('parentId', requestId);\n\t  }\n\t  for (const requestGroupId of oldIds.getRequestGroupId()) {\n\t    await requestGroupDb.deleteBy('_id', requestGroupId);\n\t    await requestGroupMetaDb.deleteBy('parentId', requestGroupId);\n", "  }\n\t  for (const testSuites of oldIds.getTestSuites()) {\n\t    await testSuitesDb.deleteBy('_id', testSuites);\n\t  }\n\t  for (const test of oldIds.getTests()) {\n\t    await testDb.deleteBy('_id', test);\n\t  }\n\t}\n\texport async function importWorkspaceData(data: GitSavedWorkspace): Promise<void> {\n\t  const workspaceDb = new BaseDb<Workspace>('Workspace');\n", "  // Collect OldIds of Requests / Folders so we can delete deleted Docs at the end\n\t  const oldIds = await workspaceDb.findById(data.id)\n\t    ? OldIds.fromOldData(await exportWorkspaceData(data.id))\n\t    : OldIds.createEmpty();\n\t  // Update Workspace metadata\n\t  await workspaceDb.upsert(data.workspace);\n\t  const workspaceMetaDb = new BaseDb<WorkspaceMeta>('WorkspaceMeta');\n\t  const fullMeta: WorkspaceMeta = {\n\t    ...data.meta,\n\t    // These are the Default value from 'models/workspace-meta::init()'. TODO: Load the old WorkspaceMetadata here\n", "    activeUnitTestSuiteId: null,\n\t    cachedGitLastAuthor: null,\n\t    cachedGitLastCommitTime: null,\n\t    cachedGitRepositoryBranch: null,\n\t    gitRepositoryId: null,\n\t    hasSeen: true,\n\t    paneHeight: 0.5,\n\t    paneWidth: 0.5,\n\t    parentId: data.id,\n\t    sidebarFilter: '',\n", "    sidebarHidden: false,\n\t    sidebarWidth: 19,\n\t    pushSnapshotOnInitialize: false,\n\t  };\n\t  await workspaceMetaDb.upsert(fullMeta);\n\t  const requestDb = new BaseDb<BaseRequest>('Request');\n\t  const requestMetaDb = new BaseDb<RequestMeta>('RequestMeta');\n\t  const requestGroupDb = new BaseDb<RequestGroup>('RequestGroup');\n\t  const requestGroupMetaDb = new BaseDb<RequestGroupMeta>('RequestGroupMeta');\n\t  await upsertRequestsRecursive(data.requests, oldIds, requestDb, requestMetaDb, requestGroupDb, requestGroupMetaDb);\n", "  const environmentDb = new BaseDb<Environment>('Environment');\n\t  for (const environment of data.environments) {\n\t    await environmentDb.upsert(environment);\n\t    oldIds.removeEnvironmentId(environment._id);\n\t  }\n\t  if (data.apiSpec) {\n\t    const apiSpecDb = new BaseDb<ApiSpec>('ApiSpec');\n\t    await apiSpecDb.upsert(data.apiSpec);\n\t  }\n\t  const unitTestSuitesDb = new BaseDb<UnittestSuite>('UnitTestSuite');\n", "  const unitTestDb = new BaseDb<UnitTest>('UnitTest');\n\t  for (const testSuite of data.unitTestSuites) {\n\t    await unitTestSuitesDb.upsert(testSuite.testSuite);\n\t    oldIds.removeTestSuites(testSuite.testSuite._id);\n\t    for (const test of testSuite.tests) {\n\t      await unitTestDb.upsert(test);\n\t      oldIds.removeTest(test._id);\n\t    }\n\t  }\n\t  await removeOldData(\n", "    oldIds, requestDb, requestMetaDb, requestGroupDb, requestGroupMetaDb, environmentDb, unitTestSuitesDb, unitTestDb,\n\t  );\n\t}\n"]}
{"filename": "src/db/localStorageUtils.ts", "chunked_list": ["export function getActiveProjectId(): string | null {\n\t  const projectId = localStorage.getItem('locationHistoryEntry').split('/')[4];\n\t  return projectId || null;\n\t}\n\texport function getActiveWorkspace(): string | null {\n\t  const projectId = localStorage.getItem('locationHistoryEntry').split('/')[6];\n\t  return projectId || null;\n\t}\n"]}
{"filename": "src/db/BaseDb.ts", "chunked_list": ["import Nedb from 'nedb';\n\timport fsPath from 'node:path';\n\timport { BaseModel } from '../insomniaDbTypes';\n\ttype DbTargets = 'Request' | 'RequestMeta' | 'RequestGroup' | 'RequestGroupMeta' | 'Workspace' | 'WorkspaceMeta' | 'Project' | 'Environment' | 'ApiSpec' | 'UnitTest' | 'UnitTestSuite';\n\texport default class BaseDb<T extends BaseModel> {\n\t  private neDb: Nedb;\n\t  constructor(target: DbTargets) {\n\t    // @ts-ignore\n\t    const filename = fsPath.join(window.app.getPath('userData'), `insomnia.${target}.db`);\n\t    this.neDb = new Nedb({\n", "      autoload: true,\n\t      filename,\n\t      corruptAlertThreshold: 0.9,\n\t      inMemoryOnly: false,\n\t    });\n\t  }\n\t  public create(doc: T) {\n\t    this.neDb.insert(doc);\n\t  }\n\t  public update(doc: T) {\n", "    this.neDb.update(\n\t      { _id: doc._id },\n\t      doc,\n\t    );\n\t  }\n\t  public async upsert(doc: T) {\n\t    if (!await this.findById(doc._id)) {\n\t      this.create(doc);\n\t      return;\n\t    }\n", "    this.update(doc);\n\t  }\n\t  public async findById(id: string): Promise<T | null> {\n\t    return new Promise((resolve, reject) => {\n\t      this.neDb.findOne({ _id: id }, (err, doc) => {\n\t        if (err) {\n\t          reject(err);\n\t        }\n\t        resolve(doc);\n\t      });\n", "    });\n\t  }\n\t  public async findBy(field: keyof T, query: string): Promise<T[]> {\n\t    return new Promise((resolve, reject) => {\n\t      this.neDb.find({ [field]: query }, (err, docs) => {\n\t        if (err) {\n\t          reject(err);\n\t        }\n\t        resolve(docs);\n\t      });\n", "    });\n\t  }\n\t  public async findAll(): Promise<T[]> {\n\t    return new Promise((resolve, reject) => {\n\t      this.neDb.find({}, (err, docs) => {\n\t        if (err) {\n\t          reject(err);\n\t        }\n\t        resolve(docs);\n\t      });\n", "    });\n\t  }\n\t  public deleteBy(field: keyof T, query: string): void {\n\t    this.neDb.remove({ [field]: query });\n\t  }\n\t}\n"]}
{"filename": "src/db/InternalDb.ts", "chunked_list": ["import fsPath from 'node:path';\n\timport fs from 'node:fs';\n\texport type ProjectConfig = {\n\t  id: string,\n\t  repositoryPath: string | null,\n\t  remote: string | null,\n\t  autoExport?: boolean\n\t  // TODO: For later, enable Sync using GitHub / GitLab OAuth-Apis (#1)\n\t}\n\ttype InternalConfig = {\n", "  projects: ProjectConfig[],\n\t};\n\texport default class InternalDb {\n\t  private config: InternalConfig;\n\t  private constructor() {\n\t    // @ts-ignore\n\t    const filename = fsPath.join(window.app.getPath('userData'), 'insomnia.plugin.git-integration.json');\n\t    if (!fs.existsSync(filename)) {\n\t      fs.writeFileSync(filename, '');\n\t    }\n", "    // TODO: Validate this with ZOD\n\t    const rawConfig = fs.readFileSync(filename).toString();\n\t    if (!rawConfig || rawConfig.trim().length === 0) {\n\t      this.config = { projects: [] };\n\t      return;\n\t    }\n\t    this.config = JSON.parse(rawConfig.toString());\n\t  }\n\t  private save() {\n\t    // @ts-ignore\n", "    const filename = fsPath.join(window.app.getPath('userData'), 'insomnia.plugin.git-integration.json');\n\t    fs.writeFileSync(filename, JSON.stringify(this.config, null, 2));\n\t  }\n\t  private static db: InternalDb;\n\t  // This class is a singleton\n\t  public static create(): InternalDb {\n\t    if (!InternalDb.db) {\n\t      InternalDb.db = new InternalDb();\n\t    }\n\t    return InternalDb.db;\n", "  }\n\t  public isProjectConfigured(projectId: string): boolean {\n\t    return this.config.projects.find((project) => project.id === projectId) !== undefined;\n\t  }\n\t  public getProjectPath(projectId: string): string | null {\n\t    return this.getProject(projectId).repositoryPath;\n\t  }\n\t  public getProject(projectId: string): ProjectConfig {\n\t    const index = this.config.projects.findIndex((p) => p.id === projectId);\n\t    if (index === -1) {\n", "      return {\n\t        id: projectId,\n\t        remote: null,\n\t        repositoryPath: null,\n\t        autoExport: false,\n\t      };\n\t    }\n\t    return this.config.projects[index];\n\t  }\n\t  public upsertProject(project: ProjectConfig) {\n", "    const existingIndex = this.config.projects.findIndex((p) => p.id === project.id);\n\t    if (existingIndex !== -1) {\n\t      this.config.projects[existingIndex] = project;\n\t      this.save();\n\t      return;\n\t    }\n\t    this.config.projects.push(project);\n\t    this.save();\n\t  }\n\t}\n"]}
{"filename": "src/ui/injectStyles.ts", "chunked_list": ["import fs from 'node:fs';\n\timport path from 'node:path';\n\texport default function injectStyles() {\n\t  const head = document.querySelector('head');\n\t  const existing = document.querySelector('#git-integration-styles');\n\t  if (!head || existing) {\n\t    return;\n\t  }\n\t  const styleTag = document.createElement('style');\n\t  styleTag.id = 'git-integration-styles';\n", "  styleTag.innerHTML = fs.readFileSync(path.join(__dirname, 'style.css')).toString();\n\t  head.appendChild(styleTag);\n\t}\n"]}
{"filename": "src/ui/importNewProjectButton.ts", "chunked_list": ["import { join } from 'node:path';\n\timport InternalDb from '../db/InternalDb';\n\timport { importProject } from '../importData';\n\timport { GitSavedProject, GitSavedWorkspace } from '../types';\n\timport fs from 'node:fs';\n\timport alertModal from './react/alertModal';\n\timport renderModal from './react/renderModal';\n\texport default function importNewProjectButton() {\n\t  const createProjectBtn = document.querySelector('i[data-testid=\"CreateProjectButton\"]');\n\t  if (!createProjectBtn) {\n", "    return;\n\t  }\n\t  const existing = document.getElementById('git-integration-import-project');\n\t  if (existing) {\n\t    return;\n\t  }\n\t  const wrapper = createProjectBtn.parentElement?.parentElement;\n\t  if (!wrapper) {\n\t    return;\n\t  }\n", "  const importProjectBtn = document.createElement('button');\n\t  importProjectBtn.id = 'git-integration-import-project';\n\t  importProjectBtn.role = 'button';\n\t  importProjectBtn.className = 'ipgi-import-btn';\n\t  importProjectBtn.innerHTML = '<i class=\"fa fa-git\"></i>';\n\t  importProjectBtn.addEventListener('click', async () => {\n\t    // @ts-ignore\n\t    const openResult = await window.dialog.showOpenDialog({ properties: ['openDirectory'] });\n\t    if (openResult.canceled || openResult.filePaths.lenght === 0) {\n\t      return;\n", "    }\n\t    const targetDir = openResult.filePaths[0];\n\t    const projectFile = join(targetDir, 'project.json');\n\t    if (!fs.existsSync(projectFile)) {\n\t      await renderModal(alertModal(\n\t        'Invalid folder',\n\t        'This folder does not contain files to import (e.g. \"project.json\", \"wrk_*.json\")',\n\t      ));\n\t      return;\n\t    }\n", "    // TODO: Validate this using Zod\n\t    const project: GitSavedProject = JSON.parse(fs.readFileSync(projectFile).toString());\n\t    const configDb = InternalDb.create();\n\t    const projectConfig = configDb.getProject(project.id);\n\t    projectConfig.repositoryPath = openResult.filePaths[0];\n\t    configDb.upsertProject(projectConfig);\n\t    // Read all the workspace data\n\t    const workspaceData: GitSavedWorkspace[] = [];\n\t    for (const workspaceId of project.workspaceIds) {\n\t      const workspaceFile = join(targetDir, workspaceId + '.json');\n", "      // TODO: Validate this using Zod\n\t      const workspace: GitSavedWorkspace = JSON.parse(fs.readFileSync(workspaceFile).toString());\n\t      workspaceData.push(workspace);\n\t    }\n\t    await importProject(project, workspaceData);\n\t    // Force Insomnia to read all data again.\n\t    // Wrapped with requestIdleCallback to make sure NeDB had enough time to save everything\n\t    // @ts-ignore\n\t    window.requestIdleCallback(window.main.restart);\n\t  });\n", "  wrapper.appendChild(importProjectBtn);\n\t}\n"]}
{"filename": "src/ui/projectDropdown/gitPushButton.ts", "chunked_list": ["import { SimpleGit } from 'simple-git';\n\timport alertModal from '../react/alertModal';\n\timport renderModal from '../react/renderModal';\n\timport { getActiveProjectId } from '../../db/localStorageUtils';\n\timport InternalDb from '../../db/InternalDb';\n\texport default function gitPushButton(projectDropdown: Element, gitClient: SimpleGit): HTMLElement {\n\t  const gitPushButton = document.createElement('li');\n\t  gitPushButton.className = 'ipgi-dropdown-btn-wrapper';\n\t  gitPushButton.innerHTML = `\n\t    <div role=\"button\" class=\"ipgi-dropdown-btn\">\n", "      <div class=\"ipgi-dropdown-btn-text\">\n\t        <i class=\"ipgi-dropdown-btn-icon fa fa-code-pull-request\">\n\t        </i>\n\t        Push\n\t      </div>\n\t    </div>\n\t  `;\n\t  gitPushButton.addEventListener('click', async () => {\n\t    // \"Close\" the dropdown\n\t    projectDropdown.remove();\n", "    try {\n\t      const branch = await gitClient.branchLocal();\n\t      const remotes = await gitClient.getRemotes();\n\t      if (!remotes[0]) {\n\t        await renderModal(alertModal('Unable to push', 'No remotes defined for git repository'));\n\t        return;\n\t      }\n\t      const projectId = getActiveProjectId();\n\t      if (!projectId) {\n\t        await renderModal(alertModal('Internal error', 'No ProjectId found in LocalStorage'));\n", "        return;\n\t      }\n\t      const projectConfigDb = InternalDb.create();\n\t      const projectConfig = projectConfigDb.getProject(projectId);\n\t      const remote = projectConfig.remote ?? remotes[0].name;\n\t      const pushResult = await gitClient.push(remote, branch.current);\n\t      let message = `Pushed to ${remote}/${branch.current}.`;\n\t      if (pushResult.update) {\n\t        message += ` Remote is now at \"${pushResult.update.hash.to}\" (was at \"${pushResult.update.hash.from}\" before)`\n\t      }\n", "      await renderModal(alertModal('Pushed commits', message));\n\t    } catch (error) {\n\t      await renderModal(alertModal('Push failed', 'An error occurred while pushing commits', error));\n\t    }\n\t  });\n\t  // This makes the hover effect work\n\t  gitPushButton.addEventListener('mouseover', () => {\n\t    gitPushButton.className = 'sc-crXcEl UvQbr';\n\t  });\n\t  gitPushButton.addEventListener('mouseout', () => {\n", "    gitPushButton.className = 'sc-crXcEl dTKZde';\n\t  });\n\t  return gitPushButton;\n\t}\n"]}
{"filename": "src/ui/projectDropdown/gitCommitButton.ts", "chunked_list": ["import { getActiveProjectId } from '../../db/localStorageUtils';\n\timport InternalDb from '../../db/InternalDb';\n\timport fs from 'node:fs';\n\timport { exportProject } from '../../exportData';\n\timport { join } from 'node:path';\n\timport { SimpleGit } from 'simple-git';\n\timport renderModal from '../react/renderModal';\n\timport alertModal from '../react/alertModal';\n\timport gitCommitMessage from '../react/gitCommitMessage';\n\texport default function gitCommitButton(projectDropdown: Element, gitClient: SimpleGit): HTMLElement {\n", "  const gitCommitButton = document.createElement('li');\n\t  gitCommitButton.className = 'ipgi-dropdown-btn-wrapper';\n\t  gitCommitButton.innerHTML = `\n\t    <div role=\"button\" class=\"ipgi-dropdown-btn\">\n\t      <div class=\"ipgi-dropdown-btn-text\">\n\t        <i class=\"ipgi-dropdown-btn-icon fa fa-check\">\n\t        </i>\n\t        Commit changes\n\t      </div>\n\t    </div>\n", "  `;\n\t  gitCommitButton.addEventListener('click', async () => {\n\t    // \"Close\" the dropdown\n\t    projectDropdown.remove();\n\t    const projectId = getActiveProjectId();\n\t    if (!projectId) {\n\t      await renderModal(alertModal('Internal error', 'No ProjectId found in LocalStorage'));\n\t      return;\n\t    }\n\t    const config = InternalDb.create();\n", "    const path = config.getProjectPath(projectId);\n\t    if (!path || projectId === 'proj_default-project') {\n\t      await renderModal(alertModal(\n\t        'Cannot export Project',\n\t        'You must first configure the project folder before exporting the project',\n\t      ));\n\t      return;\n\t    }\n\t    const [projectData, workspaces] = await exportProject(projectId);\n\t    const targetFile = join(path, 'project.json');\n", "    fs.writeFileSync(targetFile, JSON.stringify(projectData, null, 2));\n\t    await gitClient.add(targetFile);\n\t    for (const workspace of workspaces) {\n\t      const targetFile = join(path, workspace.id + '.json');\n\t      fs.writeFileSync(targetFile, JSON.stringify(workspace, null, 2));\n\t      await gitClient.add(targetFile);\n\t    }\n\t    const status = await gitClient.status();\n\t    if (status.staged.length === 0) {\n\t      await renderModal(alertModal('No changes', 'There are no changes to commited'));\n", "      return;\n\t    }\n\t    const commitMessage = await renderModal<string>(gitCommitMessage(path));\n\t    if (!commitMessage) {\n\t      return;\n\t    }\n\t    try {\n\t      await gitClient.commit(commitMessage);\n\t    } catch (error) {\n\t      await renderModal(alertModal('commit failed', 'An error occurred while fetching', error));\n", "    }\n\t  });\n\t  // This makes the hover effect work\n\t  gitCommitButton.addEventListener('mouseover', () => {\n\t    gitCommitButton.className = 'sc-crXcEl UvQbr';\n\t  });\n\t  gitCommitButton.addEventListener('mouseout', () => {\n\t    gitCommitButton.className = 'sc-crXcEl dTKZde';\n\t  });\n\t  return gitCommitButton;\n", "}\n"]}
{"filename": "src/ui/projectDropdown/gitFetchButton.ts", "chunked_list": ["import { SimpleGit } from 'simple-git';\n\timport alertModal from '../react/alertModal';\n\timport renderModal from '../react/renderModal';\n\texport default function gitFetchButton(projectDropdown: Element, gitClient: SimpleGit): HTMLElement {\n\t  const gitFetchButton = document.createElement('li');\n\t  gitFetchButton.className = 'ipgi-dropdown-btn-wrapper';\n\t  gitFetchButton.innerHTML = `\n\t    <div role=\"button\" class=\"ipgi-dropdown-btn\">\n\t      <div class=\"ipgi-dropdown-btn-text\">\n\t        <i class=\"ipgi-dropdown-btn-icon fa fa-cloud-arrow-down\">\n", "        </i>\n\t        Fetch\n\t      </div>\n\t    </div>\n\t  `;\n\t  gitFetchButton.addEventListener('click', async () => {\n\t    // \"Close\" the dropdown\n\t    projectDropdown.remove();\n\t    try {\n\t      await gitClient.fetch();\n", "    } catch (error) {\n\t      await renderModal(alertModal('Fetch failed', 'An error occurred while fetching', error));\n\t    }\n\t  });\n\t  // This makes the hover effect work\n\t  gitFetchButton.addEventListener('mouseover', () => {\n\t    gitFetchButton.className = 'sc-crXcEl UvQbr';\n\t  });\n\t  gitFetchButton.addEventListener('mouseout', () => {\n\t    gitFetchButton.className = 'sc-crXcEl dTKZde';\n", "  });\n\t  return gitFetchButton;\n\t}\n"]}
{"filename": "src/ui/projectDropdown/defaultProjectInfo.ts", "chunked_list": ["export default function defaultProjectInfo(): HTMLElement {\n\t  const defaultProjectInfo = document.createElement('li');\n\t  defaultProjectInfo.className = 'ipgi-dropdown-btn-wrapper';\n\t  // Remove the Curser Pointer\n\t  defaultProjectInfo.style.cursor = 'unset';\n\t  defaultProjectInfo.innerHTML = `\n\t    <div class=\"ipgi-dropdown-btn\">\n\t      <div class=\"ipgi-dropdown-btn-text\">\n\t        Git integration does not work<br /> with the default project\n\t      </div>\n", "    </div>\n\t  `;\n\t  return defaultProjectInfo;\n\t}\n"]}
{"filename": "src/ui/projectDropdown/gitPullButton.ts", "chunked_list": ["import { SimpleGit } from 'simple-git';\n\timport renderModal from '../react/renderModal';\n\timport alertModal from '../react/alertModal';\n\timport InternalDb from '../../db/InternalDb';\n\timport { getActiveProjectId } from '../../db/localStorageUtils';\n\texport default function gitPullButton(projectDropdown: Element, gitClient: SimpleGit): HTMLElement {\n\t  const gitPullButton = document.createElement('li');\n\t  gitPullButton.className = 'ipgi-dropdown-btn-wrapper';\n\t  gitPullButton.innerHTML = `\n\t    <div role=\"button\" class=\"ipgi-dropdown-btn\">\n", "      <div class=\"ipgi-dropdown-btn-text\">\n\t        <i class=\"ipgi-dropdown-btn-icon fa fa-code-merge\">\n\t        </i>\n\t        Pull\n\t      </div>\n\t    </div>\n\t  `;\n\t  gitPullButton.addEventListener('click', async () => {\n\t    // \"Close\" the dropdown\n\t    projectDropdown.remove();\n", "    try {\n\t      const branch = await gitClient.branchLocal();\n\t      const remotes = await gitClient.getRemotes();\n\t      if (!remotes[0]) {\n\t        await renderModal(alertModal('Unable to pull', 'No remotes defined for git repository'));\n\t        return;\n\t      }\n\t      const projectId = getActiveProjectId();\n\t      if (!projectId) {\n\t        await renderModal(alertModal('Internal error', 'No ProjectId found in LocalStorage'));\n", "        return;\n\t      }\n\t      const projectConfigDb = InternalDb.create();\n\t      const projectConfig = projectConfigDb.getProject(projectId);\n\t      const remote = projectConfig.remote ?? remotes[0].name;\n\t      const pullResult = await gitClient.pull(remote, branch.current);\n\t      await renderModal(alertModal(\n\t        'Pull succeded',\n\t        `Pulled ${pullResult.files.length} changed files from ${remotes[0].name}/${branch.current}. Use \"Import Project\" to update the insomnia project`,\n\t      ));\n", "    } catch (error) {\n\t      await renderModal(alertModal('Pull failed', 'An error occurred while pulling new commits', error));\n\t    }\n\t  });\n\t  // This makes the hover effect work\n\t  gitPullButton.addEventListener('mouseover', () => {\n\t    gitPullButton.className = 'sc-crXcEl UvQbr';\n\t  });\n\t  gitPullButton.addEventListener('mouseout', () => {\n\t    gitPullButton.className = 'sc-crXcEl dTKZde';\n", "  });\n\t  return gitPullButton;\n\t}\n"]}
{"filename": "src/ui/projectDropdown/importProjectButton.ts", "chunked_list": ["import { getActiveProjectId } from '../../db/localStorageUtils';\n\timport InternalDb from '../../db/InternalDb';\n\timport { importProject, readProjectData } from '../../importData';\n\timport alertModal from '../react/alertModal';\n\timport renderModal from '../react/renderModal';\n\texport default function importProjectButton(projectDropdown: Element): HTMLElement {\n\t  const importProjectButton = document.createElement('li');\n\t  importProjectButton.className = 'ipgi-dropdown-btn-wrapper';\n\t  importProjectButton.innerHTML = `\n\t    <div role=\"button\" class=\"ipgi-dropdown-btn\">\n", "      <div class=\"ipgi-dropdown-btn-text\">\n\t        <i class=\"ipgi-dropdown-btn-icon fa fa-download\">\n\t        </i>\n\t        Import Project\n\t      </div>\n\t    </div>\n\t  `;\n\t  importProjectButton.addEventListener('click', async () => {\n\t    // \"Close\" the dropdown\n\t    projectDropdown.remove();\n", "    const projectId = getActiveProjectId();\n\t    if (!projectId) {\n\t      await renderModal(alertModal('Internal error', 'No ProjectId found in LocalStorage'));\n\t      return;\n\t    }\n\t    const config = InternalDb.create();\n\t    const path = config.getProjectPath(projectId);\n\t    if (!path || projectId === 'proj_default-project') {\n\t      await renderModal(alertModal(\n\t        'Cannot import Project',\n", "        'You must first configure the project folder before exporting the project',\n\t      ));\n\t      return;\n\t    }\n\t    const [project, workspaceData] = readProjectData(path);\n\t    await importProject(project, workspaceData);\n\t    // Force Insomnia to read all data again.\n\t    // Wrapped with requestIdleCallback to make sure NeDB had enough time to save everything\n\t    // @ts-ignore\n\t    window.requestIdleCallback(window.main.restart);\n", "  });\n\t  return importProjectButton;\n\t}\n"]}
{"filename": "src/ui/projectDropdown/exportProjectButton.ts", "chunked_list": ["import { getActiveProjectId } from '../../db/localStorageUtils';\n\timport InternalDb from '../../db/InternalDb';\n\timport fs from 'node:fs';\n\timport { exportProject } from '../../exportData';\n\timport { join } from 'node:path';\n\timport renderModal from '../react/renderModal';\n\timport alertModal from '../react/alertModal';\n\texport default function exportProjectButton(projectDropdown: Element): HTMLElement {\n\t  const exportProjectButton = document.createElement('li');\n\t  exportProjectButton.className = 'ipgi-dropdown-btn-wrapper';\n", "  exportProjectButton.innerHTML = `\n\t    <div role=\"button\" class=\"ipgi-dropdown-btn\">\n\t      <div class=\"ipgi-dropdown-btn-text\">\n\t        <i class=\"ipgi-dropdown-btn-icon fa fa-upload\">\n\t        </i>\n\t        Export Project\n\t      </div>\n\t    </div>\n\t  `;\n\t  exportProjectButton.addEventListener('click', async () => {\n", "    // \"Close\" the dropdown\n\t    projectDropdown.remove();\n\t    const projectId = getActiveProjectId();\n\t    if (!projectId) {\n\t      return;\n\t    }\n\t    const config = InternalDb.create();\n\t    const path = config.getProjectPath(projectId);\n\t    if (!path || projectId === 'proj_default-project') {\n\t      await renderModal(alertModal(\n", "        'Cannot export Project',\n\t        'You must first configure the project folder before exporting the project',\n\t      ));\n\t      return;\n\t    }\n\t    const [projectData, workspaces] = await exportProject(projectId);\n\t    const targetFile = join(path, 'project.json');\n\t    fs.writeFileSync(targetFile, JSON.stringify(projectData, null, 2));\n\t    for (const workspace of workspaces) {\n\t      const targetFile = join(path, workspace.id + '.json');\n", "      fs.writeFileSync(targetFile, JSON.stringify(workspace, null, 2));\n\t    }\n\t  });\n\t  // This makes the hover effect work\n\t  exportProjectButton.addEventListener('mouseover', () => {\n\t    exportProjectButton.className = 'sc-crXcEl UvQbr';\n\t  });\n\t  exportProjectButton.addEventListener('mouseout', () => {\n\t    exportProjectButton.className = 'sc-crXcEl dTKZde';\n\t  });\n", "  return exportProjectButton;\n\t}\n"]}
{"filename": "src/ui/projectDropdown/index.ts", "chunked_list": ["import { simpleGit } from 'simple-git';\n\timport InternalDb from '../../db/InternalDb';\n\timport { getActiveProjectId } from '../../db/localStorageUtils';\n\timport configureGitRepoButton from './configureGitRepoButton';\n\timport exportProjectButton from './exportProjectButton';\n\timport importProjectButton from './importProjectButton';\n\timport gitCommitButton from './gitCommitButton';\n\timport gitPushButton from './gitPushButton';\n\timport gitPullButton from './gitPullButton';\n\timport gitFetchButton from './gitFetchButton';\n", "import defaultProjectInfo from './defaultProjectInfo';\n\texport default function projectDropdown() {\n\t  // Check if the dropdown is opened\n\t  const projectDropdown = document.querySelector('ul[aria-label=\"Create New Dropdown\"]');\n\t  if (projectDropdown === null) {\n\t    return;\n\t  }\n\t  // Check if we are already added the new options\n\t  const exising = document.getElementById('git-integration-project-dropdown');\n\t  if (exising) {\n", "    return;\n\t  }\n\t  // Create a wrapper element\n\t  const li = document.createElement('li');\n\t  li.id = 'git-integration-project-dropdown';\n\t  li.role = 'presentation';\n\t  projectDropdown.appendChild(li);\n\t  // Create a seperator for the buttoons\n\t  const seperatetor = document.createElement('div');\n\t  seperatetor.innerHTML = `\n", "    <span id=\"react-aria6002839293-469\" aria-hidden=\"true\" class=\"ipgi-dropdown-heading-text\">Git integration</span>\n\t    <hr role=\"separator\" class=\"ipgi-dropdown-heading-divider\">\n\t  `;\n\t  seperatetor.className = 'ipgi-dropdown-heading';\n\t  li.appendChild(seperatetor);\n\t  // Create a Button group\n\t  const buttonGroup = document.createElement('ul');\n\t  buttonGroup.role = 'group';\n\t  buttonGroup.ariaLabel = 'Git integration import';\n\t  buttonGroup.className = 'ipgi-dropdown-btn-group';\n", "  li.appendChild(buttonGroup);\n\t  const projectId = getActiveProjectId();\n\t  const config = InternalDb.create();\n\t  const path = config.getProjectPath(projectId);\n\t  // proj_default-project is the default 'Insomnia' project. We cant import / export that\n\t  if (projectId === 'proj_default-project') {\n\t    buttonGroup.appendChild(defaultProjectInfo());\n\t    return;\n\t  }\n\t  buttonGroup.appendChild(configureGitRepoButton(projectDropdown));\n", "  // Don't show export / import btns when path is not configured\n\t  if (!path) {\n\t    return;\n\t  }\n\t  buttonGroup.appendChild(exportProjectButton(projectDropdown));\n\t  buttonGroup.appendChild(importProjectButton(projectDropdown));\n\t  // Git buttons. Will only be added when \"git status\" succeeds\n\t  const gitClient = simpleGit(path);\n\t  gitClient.status().then(() => {\n\t    buttonGroup.appendChild(gitCommitButton(projectDropdown, gitClient));\n", "    buttonGroup.appendChild(gitPushButton(projectDropdown, gitClient));\n\t    buttonGroup.appendChild(gitFetchButton(projectDropdown, gitClient));\n\t    buttonGroup.appendChild(gitPullButton(projectDropdown, gitClient));\n\t  }).catch(() => {\n\t    // Error occurres when git is not inited. No need to handle that\n\t    return;\n\t  });\n\t}\n"]}
{"filename": "src/ui/projectDropdown/configureGitRepoButton.ts", "chunked_list": ["import { getActiveProjectId } from '../../db/localStorageUtils';\n\timport alertModal from '../react/alertModal';\n\timport renderModal from '../react/renderModal';\n\timport configureProject from '../react/configureProject';\n\texport default function configureGitRepoButton(projectDropdown: Element): HTMLElement {\n\t  const configureProjectButton = document.createElement('li');\n\t  configureProjectButton.className = 'ipgi-dropdown-btn-wrapper';\n\t  configureProjectButton.innerHTML = `\n\t    <div role=\"button\" class=\"ipgi-dropdown-btn\">\n\t      <div class=\"ipgi-dropdown-btn-text\">\n", "        <i class=\"ipgi-dropdown-btn-icon fa fa-cog\"></i>\n\t        Configure project\n\t      </div>\n\t    </div>\n\t  `;\n\t  configureProjectButton.addEventListener('click', async () => {\n\t    // \"Close\" the dropdown\n\t    projectDropdown.remove();\n\t    const projectId = getActiveProjectId();\n\t    if (projectId === 'proj_default-project' || !projectId) {\n", "      await renderModal(alertModal(\n\t        'Cannnot configure Folder',\n\t        'Cannot configure folder for default repository. Please create a now Project',\n\t      ));\n\t      return;\n\t    }\n\t    await renderModal(configureProject(projectId));\n\t  });\n\t  // Hover effect\n\t  configureProjectButton.addEventListener('mouseover', () => {\n", "    configureProjectButton.className = 'sc-crXcEl UvQbr';\n\t  });\n\t  configureProjectButton.addEventListener('mouseout', () => {\n\t    configureProjectButton.className = 'sc-crXcEl dTKZde';\n\t  });\n\t  return configureProjectButton;\n\t}\n"]}
{"filename": "src/ui/react/UnmountContext.ts", "chunked_list": ["import { createContext } from 'react';\n\texport default createContext<(value?: unknown) => void>(() => { throw new Error('Unmount function not set'); });\n"]}
{"filename": "src/ui/react/configureProject/useGitRepoInfo.ts", "chunked_list": ["import { useCallback, useEffect, useState } from 'react';\n\timport simpleGit from 'simple-git';\n\ttype GitRepoInfo = {\n\t  commitsAhead: number,\n\t  commitsBehind: number,\n\t  currentBranch: string | null,\n\t  stagedFiles: string[],\n\t  unstagedFiles: string[],\n\t  remotes: string[],\n\t  inited: boolean,\n", "}\n\tconst defaultInfo: GitRepoInfo = {\n\t  commitsAhead: 0,\n\t  commitsBehind: 0,\n\t  currentBranch: null,\n\t  inited: false,\n\t  remotes: [],\n\t  unstagedFiles: [],\n\t  stagedFiles: [],\n\t};\n", "export default function useGitRepoInfo(path: string): [ GitRepoInfo, () => void ] {\n\t  const [gitRepoInfo, setGitRepoInfo] = useState(defaultInfo);\n\t  const updateInfo = useCallback(() => {\n\t    (async () => {\n\t      // Spread here to create a new Object. React will not see changes if the object reference is the same\n\t      const info: GitRepoInfo = {...defaultInfo};\n\t      const gitClient = simpleGit(path);\n\t      try {\n\t        const status = await gitClient.status();\n\t        info.inited = true;\n", "        info.stagedFiles = status.staged;\n\t        info.unstagedFiles = status.not_added;\n\t        info.currentBranch = status.current;\n\t        info.commitsAhead = status.ahead;\n\t        info.commitsBehind = status.behind;\n\t      } catch (error) {\n\t        setGitRepoInfo(info);\n\t        return;\n\t      }\n\t      const remotes = await gitClient.getRemotes();\n", "      info.remotes = remotes.map((remote) => remote.name);\n\t      setGitRepoInfo(info);\n\t    })().catch((error) => {\n\t      console.error('Error while fetching git repo info', error);\n\t    });\n\t  }, [path]);\n\t  useEffect(() => {\n\t    updateInfo();\n\t  }, [path]);\n\t  return [gitRepoInfo, updateInfo];\n", "}\n"]}
{"filename": "src/ui/react/configureProject/useConfigureProject.ts", "chunked_list": ["import { useMemo, useState } from 'react';\n\timport useGitRepoInfo from './useGitRepoInfo';\n\timport { ProjectConfig } from '../../../db/InternalDb';\n\texport default function useConfigureProject(initalState: ProjectConfig) {\n\t  const [project, setProject] = useState(initalState);\n\t  const [repoInfo, updateRepoInfo] = useGitRepoInfo(project.repositoryPath || '/');\n\t  const visible = useMemo(() => {\n\t    const visible = {\n\t      init: false,\n\t      remotes: false,\n", "    };\n\t    if (!repoInfo.inited && project.repositoryPath) {\n\t      visible.init = true;\n\t    }\n\t    if (repoInfo.inited) {\n\t      visible.remotes = true;\n\t    }\n\t    return visible;\n\t  }, [repoInfo, project]);\n\t  return {\n", "    project,\n\t    setProject,\n\t    repoInfo,\n\t    updateRepoInfo,\n\t    visible,\n\t  };\n\t}\n"]}
