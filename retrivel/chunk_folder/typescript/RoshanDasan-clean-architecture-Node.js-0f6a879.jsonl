{"filename": "src/app.ts", "chunked_list": ["import express,{ Request, Response, Application, NextFunction } from 'express';\n\timport http from 'http';\n\timport connectDB from './framework/database/Mongodb/connection/connection';\n\timport serverConfig from './framework/webserver/server';\n\timport expressConfig from './framework/webserver/express';\n\timport router from './framework/webserver/routes'\n\timport errorHandler from './framework/webserver/middlewares/errorHandler';\n\timport AppError from './utilities/appError';\n\timport { HttpStatus } from './types/httpstatuscodes'\n\timport path from 'path';\n", "import { Server } from 'socket.io';\n\timport socketConfig from './framework/websocket/websocket';\n\timport configKeys from './config';\n\tconst app: Application = express();\n\tconst server = http.createServer(app);\n\tconst io = new Server(server, {\n\t    cors: {\n\t        origin: configKeys.CLIENT_URL,\n\t        methods: [\"GET\", \"POST\"]\n\t    }\n", "})\n\t// connect socket.io\n\tsocketConfig(io);\n\t// mongoDB connection\n\tconnectDB();\n\t// middleware configuration\n\texpressConfig(app);\n\trouter(app);\n\t// adding public folder as static file\n\tapp.use('/uploads', express.static(path.join(__dirname, '../public/uploads')));\n", "app.use(errorHandler);\n\t// catch error\n\tapp.all(\"*\", (req: Request, res: Response, next: NextFunction) => {\n\t    next(new AppError('Not found', HttpStatus.UNAUTHORIZED));\n\t});\n\tserverConfig(server).startServer()"]}
{"filename": "src/config.ts", "chunked_list": ["import dotenv from 'dotenv';\n\tdotenv.config();\n\tconst configKeys = {\n\t    MONGO_URL : process.env.MONGODB_URL as string,\n\t    PORT : process.env.PORT as any,\n\t    JWT_SECRET: process.env.JWT_TOKEN_KEY as string,\n\t    CLIENT_URL: process.env.CLIENT_URL as string\n\t}\n\texport default configKeys;"]}
{"filename": "src/application/useCases/chat/chat.ts", "chunked_list": ["import { HttpStatus } from \"../../../types/httpstatuscodes\";\n\timport AppError from \"../../../utilities/appError\";\n\timport { chatRepositoriesInterfaceType } from \"../../repositories/chatRepositeries\";\n\texport const createChat = async (senderId: string, recieverId: string, repository: ReturnType<chatRepositoriesInterfaceType>) => {\n\t    const chat = await repository.createChat(senderId, recieverId);\n\t    if(!chat){\n\t        throw new AppError('User not found', HttpStatus.UNAUTHORIZED);\n\t    }\n\t    return chat;\n\t}\n", "export const getAllchats = async (userId: string, repository: ReturnType<chatRepositoriesInterfaceType>) => {\n\t    const getChats = await repository.getAllchat(userId);\n\t    return getChats;\n\t}\n\texport const getChat = async(firstId: string, secondId: string,  repository: ReturnType<chatRepositoriesInterfaceType>) => {\n\t    const chat = await repository.getChat(firstId, secondId);\n\t    return chat;\n\t}"]}
{"filename": "src/application/useCases/message/message.ts", "chunked_list": ["import { HttpStatus } from \"../../../types/httpstatuscodes\";\n\timport AppError from \"../../../utilities/appError\";\n\timport { messageRepositoryInterfaceType } from \"../../repositories/messageRepository\";\n\t// logics for creating a new message\n\texport const createMessage = async (chatId: string, messageId: string, message: string, repository: ReturnType<messageRepositoryInterfaceType>) => {\n\t    const createResponse = await repository.createMessage(chatId, messageId, message);\n\t    if (!createResponse) return new AppError('User not created', HttpStatus.NOT_FOUND);\n\t    return createResponse;\n\t};\n\texport const getMessages = async(chatId: string, repository: ReturnType<messageRepositoryInterfaceType>) => {\n", "    const messages = await repository.getMessages(chatId);\n\t    return messages;\n\t}"]}
{"filename": "src/application/useCases/auth/adminAuth.ts", "chunked_list": ["import { HttpStatus } from '../../../types/httpstatuscodes';\n\timport AppError from '../../../utilities/appError';\n\timport { AdminDbInterface } from '../../repositories/adminDbRepositories';\n\timport { AuthServiceInterface } from '../../services/authServiceInterface';\n\texport const adminLogin =async (\n\t    email: string,\n\t    password: string,\n\t    adminRepository: ReturnType<AdminDbInterface>,\n\t    authService: ReturnType<AuthServiceInterface>\n\t) => {\n", "    const admin: any = await adminRepository.getAdminByEmail(email);\n\t    if(!admin){\n\t        throw new AppError(\"Admin not exist\", HttpStatus.UNAUTHORIZED);\n\t    }\n\t    const checkPassword: any = await authService.comparePassword(password, admin.password);\n\t    if(!checkPassword){\n\t        throw new AppError(\"Password you entered was incorrect\", HttpStatus.UNAUTHORIZED);\n\t    }\n\t    const token: string = await authService.generateToken(admin._id.toString());\n\t    console.log(token,'lllllll');\n", "    return {\n\t        token,\n\t        admin\n\t    };\n\t}; \n"]}
{"filename": "src/application/useCases/auth/userAuth.ts", "chunked_list": ["import { HttpStatus } from '../../../types/httpstatuscodes';\n\timport AppError from '../../../utilities/appError';\n\timport { UserDbInterface } from '../../repositories/userDbRepositories';\n\timport { AuthServiceInterface } from '../../services/authServiceInterface';\n\texport const userRegister = async (user: { name: string, userName: string, email: string, number: number, password: any }, userRepository: ReturnType<UserDbInterface>, authService: ReturnType<AuthServiceInterface>) => {\n\t    // bussiness logic\n\t    user.email = user.email.toLowerCase();\n\t    const isEmailExist: any = await userRepository.getUserByEmail(user.email);\n\t    if (isEmailExist) {\n\t        throw new AppError('Email already exist : ', HttpStatus.UNAUTHORIZED)\n", "    }\n\t    let encryptedPassword = await authService.encryptPassword(user.password);\n\t    user.password = encryptedPassword\n\t    const { _id: userId } = await userRepository.addUser(user);\n\t    const token = authService.generateToken(userId.toString());\n\t    return token;\n\t};\n\texport const userLogin = async (\n\t    userName: string,\n\t    password: string,\n", "    userRepository: ReturnType<UserDbInterface>,\n\t    authService: ReturnType<AuthServiceInterface>\n\t) => {\n\t    const user: any = await userRepository.getUserByUserName(userName);\n\t    if (!user) {\n\t        throw new AppError(\"User not exist\", HttpStatus.UNAUTHORIZED);\n\t    }\n\t    const checkPassword: any = await authService.comparePassword(password, user.password);\n\t    if (user.isBlock) {\n\t        throw new AppError(\"User was blocked\", HttpStatus.UNAUTHORIZED)\n", "    }\n\t    if (!checkPassword) {\n\t        throw new AppError(\"Password you entered was incorrect\", HttpStatus.UNAUTHORIZED);\n\t    }\n\t    const token: string = await authService.generateToken(user._id.toString());\n\t    return {\n\t        token,\n\t        user\n\t    };\n\t};\n", "export const googleAuthLogin = async (\n\t    user: {\n\t        name: any;\n\t        userName: any;\n\t        email: any;\n\t        number?: any;\n\t        password?: any;\n\t    },\n\t    userRepository: ReturnType<UserDbInterface>,\n\t    authService: ReturnType<AuthServiceInterface>\n", ") => {\n\t    const isEmailExist: any = await userRepository.getUserByEmail(user.email);\n\t    if (isEmailExist) {\n\t        if (isEmailExist.isBlock) {\n\t            throw new AppError(\"User was blocked\", HttpStatus.UNAUTHORIZED)\n\t        }\n\t        const token: any = await authService.generateToken(isEmailExist._id.toString())\n\t        return {\n\t            user: isEmailExist,\n\t            token\n", "        }\n\t    } else {\n\t        const userDetails: any = await userRepository.addUser(user)\n\t        const token: string = await authService.generateToken(userDetails._id.toString())\n\t        return {\n\t            user: userDetails,\n\t            token\n\t        }\n\t    }\n\t}\n", "export const userBlock = async (id: any, userRepository: ReturnType<UserDbInterface>) => {\n\t    const { isBlock }: any = await userRepository.getUserById(id)\n\t    if (!isBlock) {\n\t        const blockResponse: any = await userRepository.blockUser(id);\n\t        return blockResponse;\n\t    } else {\n\t        const unBlockResponse: any = await userRepository.unBlockUser(id);\n\t        return unBlockResponse;\n\t    }\n\t}\n"]}
{"filename": "src/application/useCases/user/user.ts", "chunked_list": ["import { HttpStatus } from '../../../types/httpstatuscodes';\n\timport AppError from '../../../utilities/appError';\n\timport { UserDbInterface } from '../../repositories/userDbRepositories';\n\texport const getUserDetails = async (id: string, repository: ReturnType<UserDbInterface>) => {\n\t    // Get all users\n\t    const users: any[] = await repository.getAllUsers();\n\t    if (id !== 'undefined') {\n\t        // Get blocked users\n\t        const { blockedUsers } = await repository.getUserById(id);\n\t        // Filter out blocked users\n", "        const filtered = users.filter((user: any) => !blockedUsers.includes(user._id));\n\t        return filtered;\n\t    } else {\n\t        return users\n\t    }\n\t};\n\texport const userById = async (id: string, repository: ReturnType<UserDbInterface>) => {\n\t    const user: any = await repository.getUserById(id)\n\t    if (!user) {\n\t        throw new AppError(\"user not exist\", HttpStatus.UNAUTHORIZED);\n", "    }\n\t    return user;\n\t}\n\texport const followers = async (id: string, repository: ReturnType<UserDbInterface>) => {\n\t    const followers: any = await repository.getFollowers(id);\n\t    return followers;\n\t}\n\texport const followings = async (id: string, repository: ReturnType<UserDbInterface>) => {\n\t    const followings: any = await repository.getFollowings(id);\n\t    return followings\n", "}\n\texport const requestFriend = async (id: string, friendId: string, repository: ReturnType<UserDbInterface>) => {\n\t    const { userName, dp } = await repository.getUserById(id);\n\t    const { requests, userName: friendName, dp: friendDp } = await repository.getUserById(friendId);\n\t    // check user is already in request list\n\t    const isRequested = requests.find((request: any) => request.id === id);\n\t    if (isRequested) {\n\t        await repository.cancelRequest(id, friendId);\n\t        return 'Request canceled';\n\t    } else {\n", "        await repository.sendRequest(id, userName, friendName, dp, friendDp, friendId);\n\t        return 'Request sended';\n\t    }\n\t}\n\texport const requestFriendResponse = async (id: string, friendId: string, { response }: any, repository: ReturnType<UserDbInterface>) => {\n\t    if (response === 'accept') {\n\t        await repository.followFriend(friendId, id);\n\t        await repository.cancelRequest(friendId, id);\n\t        return 'Request accepted'\n\t    } else {\n", "        await repository.cancelRequest(friendId, id);\n\t        return 'Request rejected'\n\t    }\n\t}\n\texport const unfollow = async (id: any, friendId: any, repository: ReturnType<UserDbInterface>) => {\n\t    // this friend is already a follower\n\t    const friend: any = await repository.unfollowFriend(id, friendId);\n\t    return {\n\t        status: 'unfollow',\n\t        friend\n", "    }\n\t}\n\texport const searchUserByPrefix = async (prefix: any, type: any, repository: ReturnType<UserDbInterface>) => {\n\t    if (!prefix) return HttpStatus.NOT_FOUND\n\t    const searchedUsers: any = await repository.searchUser(prefix, type)\n\t    return searchedUsers\n\t}\n\texport const updateProfileInfo = async (id: string, body: any, repository: ReturnType<UserDbInterface>) => {\n\t    if (!body || !id) return HttpStatus.NOT_FOUND\n\t    const updateProfile: any = await repository.updateProfile(id, body);\n", "    return updateProfile\n\t}\n\texport const userBlock = async (userId: string, blockId: string, repository: ReturnType<UserDbInterface>) => {\n\t    const { blockingUsers } = await repository.getUserById(userId);\n\t    // check user is already blocked\n\t    const isBlocked = blockingUsers.some((user: any) => user === blockId);\n\t    if (isBlocked) {\n\t        // user already blocked\n\t        const updateResult: any = await repository.unBlockUserByUser(userId, blockId);\n\t        return updateResult;\n", "    } else {\n\t        // user not blocked\n\t        const updateResult: any = await repository.blockUserByUser(userId, blockId);\n\t        return updateResult;\n\t    }\n\t}"]}
{"filename": "src/application/useCases/post/post.ts", "chunked_list": ["import { HttpStatus } from \"../../../types/httpstatuscodes\";\n\timport AppError from \"../../../utilities/appError\";\n\timport { postDbInterfaceType } from \"../../repositories/postDbRepositories\";\n\t// bussiness logics...\n\t// find all posts from the database\n\texport const getAllPost = async (repositories: ReturnType<postDbInterfaceType>) => {\n\t  const posts = await repositories.getAllPost()\n\t  if (!posts) {\n\t    throw new AppError('Post not available', HttpStatus.BAD_REQUEST)\n\t  }\n", "  return posts;\n\t};\n\t// create a post\n\texport const postCreate = async (\n\t  postDetails: {\n\t    userId: string;\n\t    description: string;\n\t    image: string;\n\t    userName: string;\n\t  },\n", "  respositories: ReturnType<postDbInterfaceType>\n\t) => {\n\t  const newpost = await respositories.uploadPost(postDetails)\n\t  if (!newpost) {\n\t    throw new AppError('Uploading failed', HttpStatus.BAD_REQUEST)\n\t  }\n\t  return newpost\n\t};\n\t// get all post by a user\n\texport const getPostsByUser = async (userId: any, repositories: ReturnType<postDbInterfaceType>) => {\n", "  const posts = await repositories.getPostsByUser(userId)\n\t  return posts;\n\t};\n\t// get a single post by postId\n\texport const getPostById = async (id: any, repositories: ReturnType<postDbInterfaceType>) => {\n\t  const post = await repositories.getPostById(id)\n\t  return post;\n\t}\n\t//delete a particular post by postId\n\texport const deletePostById = async (id: any, repositories: ReturnType<postDbInterfaceType>) => {\n", "  const deletedData = await repositories.deletePost(id)\n\t  if (!deletedData) {\n\t    throw new AppError('No data found for delete', HttpStatus.BAD_REQUEST)\n\t  }\n\t  return deletedData\n\t}\n\t// like or dislike post \n\texport const updateLike = async (id: any, userId: any, repositories: ReturnType<postDbInterfaceType>) => {\n\t  // find the post by id\n\t  const post = await repositories.getPostById(id);\n", "  // check weather user is already liked this post of not\n\t  if (post.likes.includes(userId)) {\n\t    // if user already liked the post\n\t    await repositories.dislikePost(id, userId);\n\t  }\n\t  else {\n\t    // else user not liked the post\n\t    await repositories.likePost(id, userId);\n\t  }\n\t};\n", "// add comment to a particular post by postId\n\texport const insertComment = async (postId: string, userId: string, comment: string, repositories: ReturnType<postDbInterfaceType>) => {\n\t  const commentResult = await repositories.insertComment(postId, userId, comment);\n\t  return commentResult;\n\t}\n\t// reply a comment\n\texport const replyComment = async (postId: string, userId: string, comment: string, reply: string, repositories: ReturnType<postDbInterfaceType>) => {\n\t  const commentResult = await repositories.replyComment(postId,userId, comment, reply);\n\t  if (!commentResult) {\n\t    throw new AppError('Reply failed', HttpStatus.BAD_REQUEST)\n", "  }\n\t  return 'Reply succcess';\n\t}\n\t// delete a particulat comment using index number\n\texport const deleteComment = async (postId: string, index: string, repositories: ReturnType<postDbInterfaceType>) => {\n\t  const { comments } = await repositories.getPostById(postId);\n\t  comments.splice(index, 1);\n\t  const updateResult = await repositories.pushComment(postId, comments);\n\t  return updateResult;\n\t}\n", "// edit post \n\texport const postEdit = async (postId: string, body: any, repositories: ReturnType<postDbInterfaceType>) => {\n\t  const commentResult = await repositories.editPost(postId, body);\n\t  return commentResult;\n\t}\n\t// report post \n\texport const postReport = async (userId: string, postId: string, reason: any, repositories: ReturnType<postDbInterfaceType>) => {\n\t  const response = await repositories.reportPost(userId, postId, reason)\n\t  return response;\n\t}\n", "export const getReportedUsers = async (postId: string, repositories: ReturnType<postDbInterfaceType>) => {\n\t  const users = await repositories.getReportedUsers(postId)\n\t  return users;\n\t}\n"]}
{"filename": "src/application/repositories/postDbRepositories.ts", "chunked_list": ["import { postRepositoryType } from \"../../framework/database/Mongodb/repositories/postRepositeries\";\n\t// post database operation interface\n\texport const postDbInterface: any = (repositories: ReturnType<postRepositoryType>) => {\n\t    const getAllPost = async () => await repositories.getAllPost()\n\t    const uploadPost = async (post:{\n\t        userId: string;\n\t        description: string;\n\t        image: string;\n\t        video: string;\n\t        userName: string;\n", "    }) => { return repositories.uploadPost(post)}\n\t    const getPostsByUser = async (userId: string) => {\n\t        return await repositories.getPostsByUser(userId)\n\t    };\n\t    const getPostById =async (id:string) => {\n\t        return await repositories.getPostById(id)\n\t    }\n\t    const deletePost = async (id: string) => {\n\t        const deletedData = await repositories.deletePost(id)\n\t        return deletedData;\n", "    }\n\t    const dislikePost = async (id: string, userId: string) => {\n\t        await repositories.dislikePost(id, userId)\n\t    }\n\t    const likePost = async (id: string, userId: string) => {\n\t        await repositories.likePost(id, userId)\n\t    }\n\t    const insertComment = async(postId: string, userId: string, comment: string) => {\n\t        const insertResult = await repositories.insertComment(postId, userId, comment);\n\t        return insertResult\n", "    }\n\t    const replyComment = async(postId: string,userId: string, comment: string, reply: string) => {\n\t        const response = await repositories.replyComment(postId,userId, comment, reply);\n\t        return response\n\t    }\n\t    const editPost = async(postId: string, body: any) => {\n\t        const editPost = await repositories.editPost(postId, body)\n\t        return editPost\n\t    }\n\t    const reportPost = async(userId: string, postId: string, reason: any) => {\n", "        const repostResponse = await repositories.reportPost(userId, postId, reason);\n\t        return repostResponse;\n\t    }\n\t    const getReportedUsers = async (postId: string) => {\n\t        const users = await repositories.getReportedUsers(postId);\n\t        return users;\n\t    }\n\t    return {\n\t        getAllPost,\n\t        uploadPost,\n", "        getPostsByUser,\n\t        getPostById,\n\t        deletePost,\n\t        dislikePost,\n\t        likePost,\n\t        insertComment,\n\t        replyComment,\n\t        editPost,\n\t        reportPost,\n\t        getReportedUsers\n", "    }\n\t}\n\texport type postDbInterfaceType = typeof postDbInterface;"]}
{"filename": "src/application/repositories/adminDbRepositories.ts", "chunked_list": ["// correct\n\timport { adminRepositoryMongoDB } from \"../../framework/database/Mongodb/repositories/adminRepositories\";\n\texport const adminDbRepository = (repository: ReturnType<adminRepositoryMongoDB>) => {\n\t    const getAdminByEmail = async (email: string) => {\n\t        return await repository.getAdminByEmail(email)\n\t    };\n\t    return {\n\t        getAdminByEmail,\n\t    }\n\t};\n", "export type AdminDbInterface = typeof adminDbRepository;"]}
{"filename": "src/application/repositories/userDbRepositories.ts", "chunked_list": ["import { userRepositoryMongoDB } from \"../../framework/database/Mongodb/repositories/userRepositories\";\n\texport const userDbRepository = (repository: ReturnType<userRepositoryMongoDB>) => {\n\t    const addUser = async (user: {\n\t        name: string;\n\t        userName: string;\n\t        email: string;\n\t        number?: number;\n\t        password?: string;\n\t    }) => {\n\t        return await repository.addUser(user);\n", "    };\n\t    const getAllUsers = async () => {\n\t        return await repository.getAllUsers()\n\t    }\n\t    const getUserByEmail = async (email: string) => {\n\t        return await repository.getUserByEmail(email);\n\t    };\n\t    const getUserByUserName = async (userName: string) => {\n\t        return await repository.getUserByUserName(userName);\n\t    };\n", "    const getUserById = async (id: string) => {\n\t        return await repository.getUserById(id);\n\t    };\n\t    const getFollowers = async (id: string) => {\n\t        return await repository.getFollowers(id);\n\t    };\n\t    const getFollowings = async (id: string) => {\n\t        return await repository.getFollowings(id);\n\t    };\n\t    const findFriend = async (id: string, friendId: string) => {\n", "        return await repository.findFriend(id, friendId);\n\t    }\n\t    const sendRequest = async (id: string, userName: string, friendName: string, dp: any, friendDp: string,  friendId: string) => {\n\t        return await repository.sendRequest(id, userName, friendName,dp, friendDp,  friendId);\n\t    }\n\t    const cancelRequest = async (id: string, friendId: string) => {\n\t        return await repository.cancelRequest(id, friendId);\n\t    }\n\t    const unfollowFriend = async (id: string, friendId: string) => {\n\t        return await repository.unfollowFriend(id, friendId)\n", "    }\n\t    const followFriend = async (id: string, friendId: string) => {\n\t        return await repository.followFriend(id, friendId)\n\t    }\n\t    const searchUser = async (prefix: string, type: string) => {\n\t        return await repository.searchUser(prefix, type);\n\t    }\n\t    const updateProfile = async (id: string, body: any) => {\n\t        return await repository.updateProfile(id, body)\n\t    }\n", "    const blockUser = async (id: string) => {\n\t        return await repository.blockUser(id);\n\t    }\n\t    const unBlockUser = async (id: string) => {\n\t        return await repository.unBlockUser(id);\n\t    }\n\t    const blockUserByUser = async (userId: string, blockId: string) => {\n\t        return await repository.blockUserByUser(userId, blockId);\n\t    }\n\t    const unBlockUserByUser = async (userId: string, blockId: string) => {\n", "        return await repository.unBlockUserByUser(userId, blockId);\n\t    }\n\t    return {\n\t        addUser,\n\t        getUserByEmail,\n\t        getUserByUserName,\n\t        getUserById,\n\t        getFollowers,\n\t        getFollowings,\n\t        sendRequest,\n", "        cancelRequest,\n\t        findFriend,\n\t        unfollowFriend,\n\t        followFriend,\n\t        getAllUsers,\n\t        searchUser,\n\t        updateProfile,\n\t        blockUser,\n\t        unBlockUser,\n\t        blockUserByUser,\n", "        unBlockUserByUser\n\t    };\n\t};\n\texport type UserDbInterface = typeof userDbRepository;"]}
{"filename": "src/application/repositories/messageRepository.ts", "chunked_list": ["import { messageRepositoryMongoDBType } from \"../../framework/database/Mongodb/repositories/messageRepository\";\n\texport const messageRepositoryInterface = (repository: ReturnType<messageRepositoryMongoDBType>) => {\n\t    const createMessage = async (chatId: string, senderId: string, message: any) => {\n\t        const createResponse = await repository.createMessage(chatId, senderId, message);\n\t        return createResponse;\n\t    }\n\t    const getMessages = async(chatId: string) => {\n\t        return repository.getMessages(chatId);\n\t    }\n\t    return {\n", "        createMessage,\n\t        getMessages\n\t    }\n\t}\n\texport type messageRepositoryInterfaceType = typeof messageRepositoryInterface;"]}
{"filename": "src/application/repositories/chatRepositeries.ts", "chunked_list": ["import { chatRepositoryType } from \"../../framework/database/Mongodb/repositories/chatRepositories\";\n\texport const chatRepositoriesInterface = (repository: ReturnType<chatRepositoryType>) => {\n\t    // interface for create chat\n\t    const createChat = async (senderId: string, recieverId: string) => {\n\t        const createChat = await repository.createChat(senderId, recieverId);\n\t        return createChat;\n\t    };\n\t    const getAllchat = async (userId: string) => {\n\t        const chats = await repository.getAllchat(userId);\n\t        return chats\n", "    }\n\t    const getChat = async (firstId: string, secondId: string) => {\n\t        const chat = await repository.getChat(firstId, secondId);\n\t        return chat;\n\t    }\n\t    return {\n\t        createChat,\n\t        getAllchat,\n\t        getChat\n\t    }\n", "};\n\texport type chatRepositoriesInterfaceType = typeof chatRepositoriesInterface;"]}
{"filename": "src/application/services/authServiceInterface.ts", "chunked_list": ["import { AuthServiceReturn } from \"../../framework/services/authServices\";\n\texport const authServiceInterface = (service: AuthServiceReturn) => {\n\t    const encryptPassword = async (password: string) => {\n\t        return await service.encryptPassword(password);\n\t    };\n\t    const comparePassword = async (password: string, hashedPassword: string) => {\n\t        return await service.comparePassword(password, hashedPassword);\n\t    };\n\t    const verifyPassword = async (token: string) => {\n\t        return service.verifyToken(token);\n", "    };\n\t    const generateToken = async (payload: string) => {\n\t        return service.generateToken(payload);\n\t    };\n\t    return {\n\t        encryptPassword,\n\t        comparePassword,\n\t        verifyPassword,\n\t        generateToken\n\t    }\n", "}\n\texport type AuthServiceInterface = typeof authServiceInterface;\n"]}
{"filename": "src/adapters/controllers/messageController.ts", "chunked_list": ["import { Request, Response } from \"express\";\n\timport expressAsyncHandler from \"express-async-handler\";\n\timport { messageRepositoryInterfaceType } from \"../../application/repositories/messageRepository\";\n\timport { messageRepositoryMongoDBType } from \"../../framework/database/Mongodb/repositories/messageRepository\";\n\timport { createMessage, getMessages } from \"../../application/useCases/message/message\";\n\tconst messageController = (messageRepositoryInterface: messageRepositoryInterfaceType, messageRepositoryMongoDB: messageRepositoryMongoDBType) => {\n\t    const messageRepository = messageRepositoryInterface(messageRepositoryMongoDB());\n\t    const createNewMessage = expressAsyncHandler(async(req: Request, res: Response) => {\n\t        const {chatId, senderId, message} = req.body;\n\t        const createResponse = await createMessage(chatId, senderId, message, messageRepository);\n", "        res.json({\n\t            status: 'success',\n\t            response: createResponse\n\t        })\n\t    })\n\t    const getUserMessages = expressAsyncHandler(async(req: Request, res: Response) => {\n\t        const { chatId } = req.params;\n\t        const messages = await getMessages(chatId, messageRepository);\n\t        res.json({\n\t            status: 'Message fetch success',\n", "            messages\n\t        })\n\t    })\n\t    return {\n\t        createNewMessage,\n\t        getUserMessages\n\t    }\n\t}\n\texport default messageController;"]}
{"filename": "src/adapters/controllers/chatController.ts", "chunked_list": ["import { Request, Response } from \"express\";\n\timport expressAsyncHandler from \"express-async-handler\";\n\timport { chatRepositoriesInterfaceType } from \"../../application/repositories/chatRepositeries\";\n\timport { chatRepositoryType } from \"../../framework/database/Mongodb/repositories/chatRepositories\";\n\timport { createChat, getAllchats, getChat } from \"../../application/useCases/chat/chat\";\n\tconst chatController = (chatRepositoriesInterfaceType: chatRepositoriesInterfaceType, chatRepositoryType: chatRepositoryType) => {\n\t    const chatRepositeries = chatRepositoriesInterfaceType(chatRepositoryType());\n\t    const chatCreate = expressAsyncHandler(async (req: Request, res: Response) => {\n\t        const { senderId, recieverId } = req.params;\n\t        const newChat = await createChat(senderId, recieverId, chatRepositeries);\n", "        res.json({\n\t            status: 'success',\n\t            chats: newChat\n\t        })\n\t    })\n\t    const getChats = expressAsyncHandler(async (req: Request, res: Response) => {\n\t        const { userId} = req.params;\n\t        const chats = await getAllchats(userId, chatRepositeries);\n\t        res.json({\n\t            status: 'success',\n", "            chats\n\t        })\n\t    })\n\t    const getSingleChat = expressAsyncHandler(async(req: Request, res:Response) => {\n\t        const { firstId, secondId } = req.params;\n\t        const chat = await getChat(firstId, secondId, chatRepositeries);\n\t        res.json({\n\t            status: 'success',\n\t            chat\n\t        })\n", "    })\n\t    return {\n\t        chatCreate,\n\t        getChats,\n\t        getSingleChat\n\t    }\n\t}\n\texport default chatController;"]}
{"filename": "src/adapters/controllers/adminAuthController.ts", "chunked_list": ["import { Request, Response } from 'express';\n\timport asyncHandler from 'express-async-handler';\n\timport { AuthServices } from '../../framework/services/authServices';\n\timport { AuthServiceInterface } from '../../application/services/authServiceInterface';\n\timport { AdminDbInterface } from '../../application/repositories/adminDbRepositories';\n\timport { adminRepositoryMongoDB } from '../../framework/database/Mongodb/repositories/adminRepositories';\n\timport { adminLogin } from '../../application/useCases/auth/adminAuth';\n\t// authentication controllers\n\tconst authControllers = (\n\t    authServiceInterface: AuthServiceInterface,\n", "    authService: AuthServices,\n\t    adminDbInterface: AdminDbInterface,\n\t    adminDbservice: adminRepositoryMongoDB\n\t) => {\n\t    const dbAdminRepository = adminDbInterface(adminDbservice());\n\t    const authServices = authServiceInterface(authService());\n\t    const loginAdmin = asyncHandler(async(req: Request, res: Response) => {\n\t        console.log('-------------------------------------------------------');       \n\t        const { email, password }  = req.body;\n\t        const token = await adminLogin(email, password, dbAdminRepository, authServices)\n", "        // res.setHeader('authorization', token.token);\n\t        res.json({\n\t            status: \"success\",\n\t            message: \"admin verified\",\n\t            token\n\t        });\n\t    });\n\t    return {\n\t        loginAdmin,\n\t    };\n", "};\n\texport default authControllers;"]}
{"filename": "src/adapters/controllers/postControllers.ts", "chunked_list": ["import { Request, Response } from \"express\";\n\timport expressAsyncHandler from \"express-async-handler\";\n\timport { postRepositoryType } from \"../../framework/database/Mongodb/repositories/postRepositeries\";\n\timport { postDbInterfaceType } from \"../../application/repositories/postDbRepositories\";\n\timport { getAllPost, postCreate, getPostsByUser, getPostById, deletePostById, updateLike, insertComment, deleteComment, postEdit, postReport, getReportedUsers, replyComment } from '../../application/useCases/post/post'\n\tconst postControllers = (postDbInterface: postDbInterfaceType, postRepositoryType: postRepositoryType) => {\n\t    const dbRepositoriesPost = postDbInterface(postRepositoryType())\n\t    const getPosts = expressAsyncHandler(async (req: Request, res: Response) => {\n\t        const posts = await getAllPost(dbRepositoriesPost)\n\t        res.json({\n", "            status: \"success\",\n\t            posts\n\t        })\n\t    })\n\t    const uploadPost = expressAsyncHandler(async (req: Request, res: Response) => {\n\t        const { userId, description, userName, image, video } = req.body;\n\t        const body = { userId, description, userName, image, video };\n\t        const newPost = await postCreate(body, dbRepositoriesPost);\n\t        res.json({\n\t            status: 'upload-success',\n", "            newPost\n\t        })\n\t    })\n\t    const getUserPosts = expressAsyncHandler(async (req: Request, res: Response) => {\n\t        const { userId } = req.params;\n\t        const posts: any = await getPostsByUser(userId, dbRepositoriesPost);\n\t        res.json({\n\t            status: 'posts find success',\n\t            posts\n\t        })\n", "    })\n\t    const getPost = expressAsyncHandler(async (req: Request, res: Response) => {\n\t        const { id } = req.params;\n\t        const post: any = await getPostById(id, dbRepositoriesPost);\n\t        res.json({\n\t            status: 'post find success',\n\t            post\n\t        })\n\t    })\n\t    const deletePost = expressAsyncHandler(async (req: Request, res: Response) => {\n", "        const { id } = req.params;\n\t        const deletedData = await deletePostById(id, dbRepositoriesPost)\n\t        res.json({\n\t            status: 'Deleted success',\n\t            deletedData\n\t        })\n\t    })\n\t    const postLikeUpdate = expressAsyncHandler(async (req: Request, res: Response) => {\n\t        const { id, userId } = req.query;\n\t        await updateLike(id, userId, dbRepositoriesPost)\n", "        res.json({\n\t            status: 'like update success'\n\t        })\n\t    })\n\t    const commentPost = expressAsyncHandler(async (req: Request, res: Response) => {\n\t        const { postId, userId } = req.params;\n\t        const { comment } = req.body\n\t        const updateResult = await insertComment(postId, userId, comment, dbRepositoriesPost)\n\t        res.json({\n\t            status: 'comment success',\n", "            comment: updateResult\n\t        })\n\t    })\n\t    const commentReply = expressAsyncHandler(async (req: Request, res: Response) => {\n\t        const { userId, postId } = req.params;\n\t        const { comment, reply } = req.body;\n\t        const updateResult = await replyComment(postId, userId, comment, reply, dbRepositoriesPost)\n\t        res.json({\n\t            status: updateResult\n\t        })\n", "    })\n\t    const commentDelete = expressAsyncHandler(async (req: Request, res: Response) => {\n\t        const { postId, index } = req.params;\n\t        const deleteResult = await deleteComment(postId, index, dbRepositoriesPost)\n\t        res.json({\n\t            status: 'comment deleted',\n\t            deletedComment: deleteResult\n\t        })\n\t    })\n\t    const editPost = expressAsyncHandler(async (req: Request, res: Response) => {\n", "        const { postId } = req.params;\n\t        const { description } = req.body;\n\t        const postEditResult: any = await postEdit(postId, description, dbRepositoriesPost)\n\t        res.json({\n\t            status: 'post update success',\n\t            response: postEditResult\n\t        })\n\t    })\n\t    const reportPost = expressAsyncHandler(async (req: Request, res: Response) => {\n\t        const { userId, postId } = req.params;\n", "        const { reason } = req.body;\n\t        const repostResponse = await postReport(userId, postId, reason, dbRepositoriesPost)\n\t        res.json({\n\t            status: 'posted success',\n\t            response: repostResponse\n\t        })\n\t    })\n\t    const getReporters = expressAsyncHandler(async (req: Request, res: Response) => {\n\t        const { postId } = req.params;\n\t        const users = await getReportedUsers(postId, dbRepositoriesPost);\n", "        res.json({\n\t            status: 'reposted users fetched',\n\t            users\n\t        })\n\t    })\n\t    return {\n\t        getPosts,\n\t        uploadPost,\n\t        getUserPosts,\n\t        getPost,\n", "        deletePost,\n\t        postLikeUpdate,\n\t        commentPost,\n\t        commentReply,\n\t        commentDelete,\n\t        editPost,\n\t        reportPost,\n\t        getReporters\n\t    }\n\t}\n", "export default postControllers;"]}
{"filename": "src/adapters/controllers/userControllers.ts", "chunked_list": ["import { Request, Response } from 'express';\n\timport asyncHandler from 'express-async-handler';\n\timport { UserDbInterface } from '../../application/repositories/userDbRepositories';\n\timport { userById, followers, followings, unfollow, getUserDetails, searchUserByPrefix, updateProfileInfo, userBlock, requestFriend, requestFriendResponse } from '../../application/useCases/user/user';\n\timport { userRepositoryMongoDB } from '../../framework/database/Mongodb/repositories/userRepositories';\n\tconst userControllers = (\n\t    userDbRepository: UserDbInterface,\n\t    userDbRepositoryService: userRepositoryMongoDB\n\t) => {\n\t    const dbRepositoryUser = userDbRepository(userDbRepositoryService());\n", "    // get all users list\n\t    const getAllUsers = asyncHandler(async (req: Request, res: Response) => {\n\t        const { id } = req.params;\n\t        const users = await getUserDetails(id, dbRepositoryUser);\n\t        res.json({\n\t            status: 'Get users success',\n\t            users\n\t        })\n\t    })\n\t    // get a user details by id\n", "    const getUserById = asyncHandler(async (req: Request, res: Response) => {\n\t        const { id } = req.params;\n\t        const user = await userById(id, dbRepositoryUser)\n\t        res.json({\n\t            status: \"success\",\n\t            user\n\t        });\n\t    });\n\t    // get followers list of the user\n\t    const getFollowersList = asyncHandler(async (req: Request, res: Response) => {\n", "        const { id } = req.params;\n\t        const followersList: any = await followers(id, dbRepositoryUser);\n\t        res.json({\n\t            status: 'get followers success',\n\t            followers: followersList\n\t        })\n\t    })\n\t    // get following list of the user\n\t    const getFollowingsList = asyncHandler(async (req: Request, res: Response) => {\n\t        const { id } = req.params;\n", "        const followingList: any = await followings(id, dbRepositoryUser);\n\t        res.json({\n\t            status: 'get following success',\n\t            followings: followingList\n\t        })\n\t    })\n\t    // send friend request to user\n\t    const sendRequest = asyncHandler(async (req: Request, res: Response) => {\n\t        const { id, friendId } = req.params;\n\t        const response = await requestFriend(id, friendId, dbRepositoryUser);\n", "        res.json({\n\t            status: response\n\t        })\n\t    })\n\t    // accept or reject request\n\t    const responseFriendRequest = asyncHandler(async (req: Request, res: Response) => {\n\t        const { id, friendId } = req.params;\n\t        const { response } = req.body;\n\t        const status = await requestFriendResponse(id, friendId, response, dbRepositoryUser)\n\t        res.json({\n", "            status\n\t        })\n\t    })\n\t    // insert followers to user\n\t    const unfollowUser = asyncHandler(async (req: Request, res: Response) => {\n\t        const { id, friendId } = req.query;\n\t        const { status, friend }: any = await unfollow(id, friendId, dbRepositoryUser);\n\t        res.json({\n\t            status,\n\t            friend\n", "        })\n\t    })\n\t    // search user \n\t    const searchUser = asyncHandler(async (req: Request, res: Response) => {\n\t        const { prefix } = req.params;\n\t        const { type } = req.query;\n\t        console.log(type, 'par');\n\t        const users: any = await searchUserByPrefix(prefix, type, dbRepositoryUser);\n\t        res.json({\n\t            status: 'searched success',\n", "            users\n\t        })\n\t    })\n\t    // update profile informations\n\t    const updateProfile = asyncHandler(async (req: Request, res: Response) => {\n\t        const { id } = req.params;\n\t        const { userName, bio, gender, city, file } = req.body;\n\t        const updateResult = await updateProfileInfo(id, { userName, file, bio, gender, city }, dbRepositoryUser);\n\t        res.json({\n\t            status: 'Update success',\n", "            data: updateResult\n\t        })\n\t    })\n\t    // block user by user\n\t    const blockUser = asyncHandler(async (req: Request, res: Response) => {\n\t        const { userId, blockId } = req.params;\n\t        const blockResult = await userBlock(userId, blockId, dbRepositoryUser);\n\t        res.json({\n\t            status: blockResult\n\t        });\n", "    })\n\t    return {\n\t        getUserById,\n\t        sendRequest,\n\t        responseFriendRequest,\n\t        getFollowersList,\n\t        getFollowingsList,\n\t        unfollowUser,\n\t        getAllUsers,\n\t        searchUser,\n", "        updateProfile,\n\t        blockUser\n\t    };\n\t};\n\texport default userControllers;"]}
{"filename": "src/adapters/controllers/authControllers.ts", "chunked_list": ["import { Request, Response } from 'express';\n\timport asyncHandler from 'express-async-handler';\n\timport { AuthServices } from '../../framework/services/authServices';\n\timport { AuthServiceInterface } from '../../application/services/authServiceInterface';\n\timport { UserDbInterface } from '../../application/repositories/userDbRepositories';\n\timport { userRepositoryMongoDB } from '../../framework/database/Mongodb/repositories/userRepositories';\n\timport { userRegister, userLogin, googleAuthLogin, userBlock} from '../../application/useCases/auth/userAuth';\n\t// authentication controllers\n\tconst authControllers = (\n\t    authServiceInterface: AuthServiceInterface,\n", "    authService: AuthServices,\n\t    userDbInterface: UserDbInterface,\n\t    userDbservice: userRepositoryMongoDB\n\t) => {\n\t    const dbUserRepository = userDbInterface(userDbservice());\n\t    const authServices = authServiceInterface(authService());\n\t    const registerUser = asyncHandler(async(req: Request, res: Response) => {\n\t        const { name, userName, number,email, password } = req.body;\n\t        const user = {\n\t            name,\n", "            userName,\n\t            number,\n\t            email,\n\t            password,\n\t            };\n\t    const token = await userRegister(user, dbUserRepository, authServices);\n\t    res.json({\n\t        status:\"success\",\n\t        message: \"User registered\",\n\t        token\n", "    });\n\t    });\n\t    const loginUser = asyncHandler(async(req: Request, res: Response) => {\n\t        const { userName, password } : { userName: string; password: string} = req.body;\n\t        const token = await userLogin(userName, password, dbUserRepository, authServices);\n\t        // res.setHeader('authorization', token.token);\n\t        res.json({\n\t            status: \"success\",\n\t            message: \"user verified\",\n\t            token\n", "        });\n\t    });\n\t    const googleAuth = asyncHandler(async(req: Request, res: Response) => {\n\t        console.log('-----------------------');\n\t        const { fullName, firstName, email } = req.body;\n\t        const userData: any = { name:fullName, userName:firstName, number: 7594837203, email }\n\t        console.log(userData);\n\t        const {user, token} = await googleAuthLogin(userData, dbUserRepository, authServices)\n\t        res.json({\n\t            status:'Google login success',\n", "            user,\n\t            token\n\t        })\n\t    })\n\t    const blockUser = asyncHandler(async(req: Request, res: Response) => {\n\t        const { id } = req.params;\n\t        const blockResult = await userBlock(id, dbUserRepository);\n\t        res.json({\n\t            status: `${blockResult} success`\n\t        })\n", "    })\n\t    return {\n\t        registerUser,\n\t        loginUser,\n\t        googleAuth,\n\t        blockUser\n\t    };\n\t};\n\texport default authControllers;"]}
{"filename": "src/types/httpstatuscodes.ts", "chunked_list": ["export enum HttpStatus {\n\t    CONTINUE = 100,\n\t    SWITCHING_PROTOCOLS = 101,\n\t    PROCESSING = 102,\n\t    EARLYHINTS = 103,\n\t    OK = 200,\n\t    CREATED = 201,\n\t    ACCEPTED = 202,\n\t    NON_AUTHORITATIVE_INFORMATION = 203,\n\t    NO_CONTENT = 204,\n", "    RESET_CONTENT = 205,\n\t    PARTIAL_CONTENT = 206,\n\t    AMBIGUOUS = 300,\n\t    MOVED_PERMANENTLY = 301,\n\t    FOUND = 302,\n\t    SEE_OTHER = 303,\n\t    NOT_MODIFIED = 304,\n\t    TEMPORARY_REDIRECT = 307,\n\t    PERMANENT_REDIRECT = 308,\n\t    BAD_REQUEST = 400,\n", "    UNAUTHORIZED = 401,\n\t    PAYMENT_REQUIRED = 402,\n\t    FORBIDDEN = 403,\n\t    NOT_FOUND = 404,\n\t    METHOD_NOT_ALLOWED = 405,\n\t    NOT_ACCEPTABLE = 406,\n\t    PROXY_AUTHENTICATION_REQUIRED = 407,\n\t    REQUEST_TIMEOUT = 408,\n\t    CONFLICT = 409,\n\t    GONE = 410,\n", "    LENGTH_REQUIRED = 411,\n\t    PRECONDITION_FAILED = 412,\n\t    PAYLOAD_TOO_LARGE = 413,\n\t    URI_TOO_LONG = 414,\n\t    UNSUPPORTED_MEDIA_TYPE = 415,\n\t    REQUESTED_RANGE_NOT_SATISFIABLE = 416,\n\t    EXPECTATION_FAILED = 417,\n\t    I_AM_A_TEAPOT = 418,\n\t    MISDIRECTED = 421,\n\t    UNPROCESSABLE_ENTITY = 422,\n", "    FAILED_DEPENDENCY = 424,\n\t    PRECONDITION_REQUIRED = 428,\n\t    TOO_MANY_REQUESTS = 429,\n\t    INTERNAL_SERVER_ERROR = 500,\n\t    NOT_IMPLEMENTED = 501,\n\t    BAD_GATEWAY = 502,\n\t    SERVICE_UNAVAILABLE = 503,\n\t    GATEWAY_TIMEOUT = 504,\n\t    HTTP_VERSION_NOT_SUPPORTED = 505\n\t}\n"]}
{"filename": "src/utilities/appError.ts", "chunked_list": ["import { HttpStatus } from \"../types/httpstatuscodes\";\n\tclass AppError extends Error {\n\t    statusCode: number;\n\t    status: string;\n\t    isOperational: boolean;\n\t    constructor(message: string, statusCode: HttpStatus) {\n\t      super(message);\n\t      this.statusCode = statusCode;\n\t      this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';\n\t      this.isOperational = true;\n", "      Error.captureStackTrace(this, this.constructor);\n\t    }\n\t  }\n\texport default AppError;"]}
{"filename": "src/framework/database/Mongodb/repositories/postRepositeries.ts", "chunked_list": ["import Post from \"../models/postModel\";\n\timport User from \"../models/userModel\";\n\timport { ObjectId } from 'mongodb'\n\timport cloudinary from 'cloudinary'\n\t// post database operations\n\texport const postRepositoryMongoDb = () => {\n\t    const getAllPost = async () => {\n\t        return await Post.find().sort({ createdAt: -1 });\n\t    }\n\t    const uploadPost = (async (post: {\n", "        userId: string;\n\t        description: string;\n\t        image: string;\n\t        video: string;\n\t        userName: string;\n\t    }) => {\n\t        const newpost = new Post(post);\n\t        return await newpost.save();\n\t    })\n\t    const getPostsByUser = async (userId: any) => {\n", "        return await Post.find({ userId })\n\t    }\n\t    const getPostById = async (_id: string) => {\n\t        const posts = await Post.findById({ _id: new ObjectId(_id) })\n\t        return posts;\n\t    }\n\t    const deletePost = async (_id: string) => {\n\t        const deletedData = await Post.findByIdAndDelete({ _id: new ObjectId(_id) })\n\t        return deletedData\n\t    }\n", "    const dislikePost = async (_id: string, userId: string) => {\n\t        await Post.findByIdAndUpdate({ _id },\n\t            { $pull: { likes: userId } })\n\t    }\n\t    const likePost = async (_id: string, userId: string) => {\n\t        await Post.findByIdAndUpdate({ _id },\n\t            { $push: { likes: userId } })\n\t    }\n\t    const insertComment = async (postId: string, userId: string, comment: string) => {\n\t        const updateResult = await Post.findByIdAndUpdate({ _id: postId }, {\n", "            $push: { comments: { userId, comment, reply: [] } }\n\t        });\n\t        return updateResult;\n\t    }\n\t    const replyComment = async (_id: string, userId: string, comment: string, reply: string) => {\n\t        const updateResult = await Post.updateOne(\n\t            { _id, \"comments.comment\": comment },\n\t            {\n\t                $push: {\n\t                    \"comments.$.reply\": { userId, reply }\n", "                }\n\t            }\n\t        );\n\t        return updateResult;\n\t    };\n\t    const editPost = async (_id: string, description: any) => {\n\t        const updateResult = await Post.findByIdAndUpdate({ _id }, {\n\t            $set: { description }\n\t        })\n\t        return updateResult\n", "    }\n\t    const reportPost = async (userId: string, postId: string, reason: any) => {\n\t        const repostResponse = await Post.findByIdAndUpdate({ _id: postId }, {\n\t            $push: { reports: { userId, reason } }\n\t        })\n\t        return repostResponse;\n\t    }\n\t    const getReportedUsers = async (postId: string) => {\n\t        const postDetails: any = await Post.findOne({ _id: postId });\n\t        const users: any = await Promise.all(\n", "            postDetails.reports.map(async ({ userId }: any) => {\n\t                return await User.findOne({ _id: userId })\n\t            })\n\t        )\n\t        return users;\n\t    }\n\t    return {\n\t        getAllPost,\n\t        uploadPost,\n\t        getPostsByUser,\n", "        getPostById,\n\t        deletePost,\n\t        dislikePost,\n\t        likePost,\n\t        insertComment,\n\t        replyComment,\n\t        editPost,\n\t        reportPost,\n\t        getReportedUsers\n\t    }\n", "}\n\texport type postRepositoryType = typeof postRepositoryMongoDb;"]}
{"filename": "src/framework/database/Mongodb/repositories/userRepositories.ts", "chunked_list": ["import User from \"../models/userModel\";\n\texport const userRepositoryMongoDB = () => {\n\t  const addUser = async (user: {\n\t    name: string;\n\t    userName: string;\n\t    email: string;\n\t    number?: number;\n\t    password?: string;\n\t  }) => {\n\t    const newUser = new User(user);\n", "    return await newUser.save();\n\t  };\n\t  const getAllUsers = async () => {\n\t    const users: any = await User.find();\n\t    // const users: any = await User.find({ _id: { $ne: '646fa8515333e77cdec159c2' }, followers: { $nin: ['6471800e2ed680381cbae276', '6477705ef858f715f868093a'] } });\n\t    return users;\n\t  }\n\t  const getUserByEmail = async (email: string) => {\n\t    const user: any = await User.findOne({ email }).select('-password');\n\t    return user\n", "  };\n\t  const getUserByUserName = async (userName: string) => {\n\t    const user: any = await User.findOne({ userName })\n\t    return user;\n\t  };\n\t  const getUserById = async (id: string) => {\n\t    try {\n\t      const user: any = await User.findOne({ _id: id }).select('-password');\n\t      return user;\n\t    } catch (error) {\n", "      throw error;\n\t    }\n\t  };\n\t  const getFollowers = async (_id: string) => {\n\t    const user: any = await User.findOne({ _id });\n\t    const followers: any[] = await Promise.all(\n\t      user.followers.map(async (follower: any) => {\n\t        return await User.findOne({ _id: follower });\n\t      })\n\t    );\n", "    return followers;\n\t  };\n\t  const getFollowings = async (_id: string) => {\n\t    const user: any = await User.findOne({ _id });\n\t    const followings: any[] = await Promise.all(\n\t      user.following.map(async (following: any) => {\n\t        return await User.findOne({ _id: following });\n\t      })\n\t    );\n\t    return followings;\n", "  };\n\t  const findFriend = async (_id: string, friendId: any) => {\n\t    const user: any = await User.findOne({ _id })\n\t    const isUserExist: any = await user.followers.find((user: any) => user === friendId)\n\t    return isUserExist;\n\t  }\n\t  const sendRequest = async (id: string, userName: string, friendName: string, dp: any, friendDp: string, friendId: string) => {\n\t    await User.updateOne({ _id: friendId }, {\n\t      $push: { requests: { id, userName, dp } }\n\t    })\n", "    await User.updateOne({ _id: id }, {\n\t      $push: { requested: { id: friendId, userName: friendName, dp: friendDp } }\n\t    })\n\t    return;\n\t  }\n\t  const cancelRequest = async (id: string, friendId: string) => {\n\t    await User.updateOne({ _id: friendId }, {\n\t      $pull: { requests: { id } }\n\t    })\n\t    await User.updateOne({ _id: id }, {\n", "      $pull: { requested: { id: friendId } }\n\t    })\n\t    return;\n\t  }\n\t  const unfollowFriend = async (_id: string, friendId: string) => {\n\t    // remove friend from user follower list\n\t    await User.findByIdAndUpdate({ _id },\n\t      { $pull: { followers: friendId } });\n\t    await User.findByIdAndUpdate({ _id: friendId },\n\t      { $pull: { following: _id } })\n", "    const friendDetails: any = await User.findOne({ _id: friendId });\n\t    return friendDetails\n\t  }\n\t  const followFriend = async (_id: string, friendId: string) => {\n\t    // add friend to user follower list\n\t    await User.findByIdAndUpdate({ _id },\n\t      { $push: { followers: friendId } });\n\t    await User.findByIdAndUpdate({ _id: friendId },\n\t      { $push: { following: _id } })\n\t    const friendDetails: any = await User.findOne({ _id: friendId });\n", "    return friendDetails\n\t  }\n\t  const searchUser = async (prefix: any, type: any) => {\n\t    if (type === 'userName') {\n\t      const regex = new RegExp(`^${prefix}`, 'i');\n\t      const users = await User.find({ userName: regex });\n\t      return users\n\t    } else if (type === 'gender') {\n\t      const regex = new RegExp(`^${prefix}`, 'i');\n\t      const users = await User.find({ gender: regex });\n", "      return users\n\t    } else {\n\t      const regex = new RegExp(`^${prefix}`, 'i');\n\t      const users = await User.find({ city: regex });\n\t      return users\n\t    }\n\t  }\n\t  const updateProfile = async (_id: string, data: {\n\t    userName: string,\n\t    file: string,\n", "    bio: string,\n\t    gender: string,\n\t    city: string\n\t  }) => {\n\t    const { userName, file, bio, gender, city } = data;\n\t    const updateResult = await User.findByIdAndUpdate(_id, {\n\t      $set: {\n\t        userName,\n\t        dp: file,\n\t        bio,\n", "        gender,\n\t        city,\n\t      }\n\t    }, { new: true });\n\t    return updateResult;\n\t  };\n\t  const blockUser = async (_id: string) => {\n\t    await User.findByIdAndUpdate({ _id }, {\n\t      $set: { isBlock: true }\n\t    })\n", "    return 'Blocked'\n\t  }\n\t  const unBlockUser = async (_id: string) => {\n\t    await User.findByIdAndUpdate({ _id }, {\n\t      $set: { isBlock: false }\n\t    })\n\t    return 'UnBlocked'\n\t  }\n\t  const blockUserByUser = async (blockingUser: string, blockedUser: string) => {\n\t    await User.findByIdAndUpdate({ _id: blockedUser }, {\n", "      $push: { blockedUsers: blockingUser }\n\t    });\n\t    await User.findByIdAndUpdate({ _id: blockingUser }, {\n\t      $push: { blockingUsers: blockedUser }\n\t    });\n\t    return 'Blocked';\n\t  }\n\t  const unBlockUserByUser = async (blockingUser: string, blockedUser: string) => {\n\t    await User.findByIdAndUpdate({ _id: blockedUser }, {\n\t      $pull: { blockedUsers: blockingUser }\n", "    });\n\t    await User.findByIdAndUpdate({ _id: blockingUser }, {\n\t      $pull: { blockingUsers: blockedUser }\n\t    });\n\t    return 'Unblocked';\n\t  }\n\t  return {\n\t    addUser,\n\t    getUserByEmail,\n\t    getUserByUserName,\n", "    getUserById,\n\t    getFollowers,\n\t    getFollowings,\n\t    findFriend,\n\t    sendRequest,\n\t    cancelRequest,\n\t    unfollowFriend,\n\t    followFriend,\n\t    getAllUsers,\n\t    searchUser,\n", "    updateProfile,\n\t    blockUser,\n\t    unBlockUser,\n\t    blockUserByUser,\n\t    unBlockUserByUser\n\t  };\n\t}\n\texport type userRepositoryMongoDB = typeof userRepositoryMongoDB;"]}
{"filename": "src/framework/database/Mongodb/repositories/messageRepository.ts", "chunked_list": ["import Message from \"../models/MessageModal\";\n\texport const messageRepositoryMongoDB = () => {\n\t    // create a message with a person based on their chatId\n\t    const createMessage = async (chatId: string, senderId: string, message: any) => {\n\t        const newMessage =  new Message({\n\t            chatId,\n\t            senderId,\n\t            message\n\t        });\n\t        return await newMessage.save();\n", "    }\n\t    // get single person messages\n\t    const getMessages = async (chatId: string) => {\n\t        return await Message.find({chatId});\n\t    }\n\t    return {\n\t        createMessage,\n\t        getMessages\n\t    }\n\t}\n", "export type messageRepositoryMongoDBType = typeof messageRepositoryMongoDB;\n"]}
{"filename": "src/framework/database/Mongodb/repositories/chatRepositories.ts", "chunked_list": ["import Chat from \"../models/Chatmodel\";\n\texport const chatRepositoryMongoDB = () => {\n\t    // create chat collection in db\n\t    const createChat = async (senderId: string, recieverId: string) => {\n\t        try {\n\t            // find the chat is already in the database\n\t            const isChatExist = await Chat.findOne({\n\t                members: { $all: [senderId, recieverId] }\n\t            });\n\t            if(isChatExist) {\n", "                // if the chat is already in the database nothing to do\n\t                return isChatExist;\n\t            } else {\n\t                // create a new chat with the sender and reciever\n\t                const newChat = new Chat({\n\t                    members: [senderId, recieverId]\n\t                });\n\t                const saveResponse = await newChat.save();\n\t                return saveResponse;\n\t            }\n", "        } catch (error) {\n\t            throw error\n\t        }\n\t}\n\t   const getAllchat = async (userId: string) => {\n\t    try {\n\t        return await Chat.find({\n\t            members: { $in: [userId]}\n\t        })\n\t    } catch (error) {\n", "        throw error;\n\t    }\n\t   }\n\t   const getChat = async (firstId: string, secondId: string) => {\n\t    return await Chat.find({\n\t        members: { $all: [firstId, secondId]}\n\t    });\n\t   };\n\t    return {\n\t        createChat,\n", "        getAllchat,\n\t        getChat\n\t    }\n\t};\n\texport type chatRepositoryType = typeof chatRepositoryMongoDB;"]}
{"filename": "src/framework/database/Mongodb/repositories/adminRepositories.ts", "chunked_list": ["//correct\n\timport Admin from \"../models/adminModel\";\n\texport const adminRepositoryMongoDB = () => {\n\t    const getAdminByEmail = async (email: string) => {\n\t        const user: any = await Admin.findOne({ email });\n\t        return user\n\t    };\n\t    return {\n\t        getAdminByEmail,\n\t    };\n", "}\n\texport type adminRepositoryMongoDB = typeof adminRepositoryMongoDB;"]}
{"filename": "src/framework/database/Mongodb/models/Chatmodel.ts", "chunked_list": ["import mongoose, { Schema, model } from \"mongoose\";\n\tconst ChatSchema = new mongoose.Schema(\n\t    {\n\t        members: {\n\t            type: Array,\n\t        }\n\t    },\n\t    {\n\t        timestamps: true\n\t    }\n", ");\n\tconst ChatModel = model(\"Chat\", ChatSchema);\n\texport default ChatModel;"]}
{"filename": "src/framework/database/Mongodb/models/postModel.ts", "chunked_list": ["import { Document, Schema, model } from \"mongoose\";\n\tinterface IPost extends Document {\n\t  userId: string;\n\t  description: string;\n\t  userName?: string;\n\t  likes: any[];\n\t  comments: any[];\n\t  reports: any[];\n\t  createdAt: Date;\n\t  image?: string;\n", "  video?: string;\n\t  location: {\n\t    type: string;\n\t    coordinates: number[];\n\t  };\n\t}\n\tconst postSchema = new Schema<IPost>(\n\t  {\n\t    userId: {\n\t      type: String,\n", "      required: true,\n\t    },\n\t    description: {\n\t      type: String,\n\t      required: true,\n\t    },\n\t    userName: {\n\t      type: String,\n\t    },\n\t    likes: [],\n", "    comments: [],\n\t    reports: [],\n\t    createdAt: {\n\t      type: Date,\n\t      default: new Date(),\n\t    },\n\t    image: String,\n\t    video: String,\n\t    location: {\n\t      type: {\n", "        type: String,\n\t        enum: [\"Point\"],\n\t        default: \"Point\",\n\t      },\n\t      coordinates: {\n\t        type: [Number],\n\t        default: [Math.random() * 180 - 90, Math.random() * 360 - 180],\n\t      },\n\t    },\n\t  },\n", "  {\n\t    timestamps: true,\n\t  }\n\t);\n\tconst Post = model<IPost>(\"Post\", postSchema);\n\texport default Post;\n"]}
{"filename": "src/framework/database/Mongodb/models/userModel.ts", "chunked_list": ["import mongoose, { Schema, model } from \"mongoose\";\n\t// schema for users\n\tconst userSchema = new Schema(\n\t  {\n\t    name: {\n\t      type: String,\n\t      required: true,\n\t    },\n\t    userName: {\n\t      type: String,\n", "      required: true,\n\t      unique: true,\n\t    },\n\t    email: {\n\t      type: String,\n\t      required: true,\n\t    },\n\t    number: {\n\t        type: Number,\n\t    },\n", "    password: {\n\t      type: String,\n\t      minlength:3\n\t    },\n\t    dp: {\n\t      type: String,\n\t    },\n\t    bio: {\n\t      type: String,\n\t    },\n", "    gender: {\n\t      type: String\n\t    },\n\t    city:{\n\t      type: String\n\t    },\n\t    isBlock: {\n\t      type: Boolean,\n\t      default: false,\n\t    },\n", "    blockedUsers:[],\n\t    blockingUsers:[],\n\t    followers: [],\n\t    following: [],\n\t    requests:[],\n\t    requested:[]\n\t  },\n\t  { timestamps: true }\n\t);\n\tconst User = model(\"User\", userSchema);\n", "export default User;\n"]}
{"filename": "src/framework/database/Mongodb/models/adminModel.ts", "chunked_list": ["import mongoose, { Schema, model } from \"mongoose\";\n\tconst adminSchema = new Schema(\n\t    {\n\t        name:{\n\t            type:String,\n\t            default: 'CONNECTIFY-ADMIN'\n\t        },\n\t        email: {\n\t            require: true,\n\t            type: String\n", "        },\n\t        password: {\n\t            require:true,\n\t            type: String\n\t        }\n\t    }\n\t)\n\t const Admin = model('admin', adminSchema);\n\t export default Admin"]}
{"filename": "src/framework/database/Mongodb/models/MessageModal.ts", "chunked_list": ["import mongoose, { Mongoose, model } from \"mongoose\";\n\tconst MessageSchema = new mongoose.Schema(\n\t    {\n\t        chatId: {\n\t            type: String,\n\t        },\n\t        senderId: {\n\t            type: String\n\t        },\n\t        message: {\n", "            type: String\n\t        }\n\t    },\n\t    {\n\t        timestamps: true\n\t    }\n\t);\n\tconst MessageModel = mongoose.model(\"message\", MessageSchema);\n\texport default MessageModel;\n"]}
{"filename": "src/framework/database/Mongodb/connection/connection.ts", "chunked_list": ["import mongoose  from \"mongoose\";\n\timport configKeys from '../../../../config';\n\tmongoose.set(\"strictQuery\", true);\n\tconst connectDB = async () => {\n\t    try {\n\t        await mongoose.connect(configKeys.MONGO_URL).then(()=>{\n\t            console.log(`Database connected successfully`);\n\t        })\n\t    } catch (error) {\n\t        console.log(`Database connection error : ${error}`);\n", "        process.exit(1) \n\t    }\n\t}\n\texport default connectDB"]}
{"filename": "src/framework/services/cloudinaryServices.ts", "chunked_list": ["import cloudinary from \"../../config\";\n"]}
{"filename": "src/framework/services/authServices.ts", "chunked_list": ["import bcrypt from 'bcryptjs';\n\timport jwt from 'jsonwebtoken';\n\timport configKeys from '../../config';\n\texport const authServices = () => {\n\t    const encryptPassword = async (password:string) => {\n\t        const salt = await bcrypt.genSalt(10);\n\t        password = await bcrypt.hash(password, salt);\n\t        return password;\n\t    };\n\t    const comparePassword = (password:string, hasedPassword:string) => {\n", "        return bcrypt.compare(password, hasedPassword);\n\t    };\n\t    const generateToken = (payload: string) => {\n\t        if (configKeys.JWT_SECRET) {\n\t          const token = jwt.sign({ payload }, configKeys.JWT_SECRET, {\n\t            expiresIn: \"5d\",\n\t          });\n\t          return token;\n\t        } else {\n\t          throw new Error(\"JWT_TOKEN_KEY is undefined\");\n", "        }\n\t      };\n\t    const verifyToken = (token:string) => {\n\t        if (configKeys.JWT_SECRET) {\n\t            const isVerify =  jwt.verify(token, configKeys.JWT_SECRET)\n\t            return isVerify;\n\t        }\n\t    };\n\t    return {\n\t        encryptPassword, \n", "        comparePassword,\n\t        generateToken,\n\t        verifyToken\n\t    }\n\t}\n\texport type AuthServices = typeof authServices;\n\texport type AuthServiceReturn = ReturnType<AuthServices>"]}
{"filename": "src/framework/services/multerServices.ts", "chunked_list": ["import multer, { StorageEngine } from 'multer'\n\timport { v4 as uuidv4 } from 'uuid';\n\tconst storage: StorageEngine = multer.diskStorage({\n\t    destination: (req, file, cb) => {\n\t        cb(null, 'public/uploads')\n\t    },\n\t    filename: (req, file, cb) => {\n\t        const uniqueFilename = `${uuidv4()}-${file.originalname}`;\n\t        cb(null, uniqueFilename);\n\t    }\n", "});\n\texport const upload = multer({ storage })\n"]}
{"filename": "src/framework/websocket/websocket.ts", "chunked_list": ["import { Server, Socket } from \"socket.io\";\n\timport { DefaultEventsMap } from \"socket.io/dist/typed-events\";\n\tinterface User {\n\t  userId: string;\n\t  socketId: string;\n\t}\n\tlet activeUsers: User[] = [];\n\tlet activeVideoCall: User[] = [];\n\tconst socketConfig = (io: Server<DefaultEventsMap, any>) => {\n\t  io.on(\"connection\", (socket: Socket<DefaultEventsMap, any>) => {\n", "    socket.on(\"new-user-add\", (newUserId: string) => {\n\t      if (!activeUsers.some((user) => user.userId === newUserId)) {\n\t        activeUsers.push({ userId: newUserId, socketId: socket.id });\n\t        console.log(`new user connected: ${newUserId}, ${socket.id}`);\n\t      }\n\t      io.emit(\"get-users\", activeUsers);\n\t    });\n\t    socket.on(\"send-message\", (data: any) => {\n\t      const { receiverId } = data;\n\t      const user = activeUsers.find((user) => user.userId === receiverId);\n", "      console.log(`sending message to ${receiverId}`);\n\t      if (user) {\n\t        io.to(user.socketId).emit(\"notification\", data)\n\t        io.to(user.socketId).emit(\"receive-message\", data)\n\t      }\n\t    });\n\t    socket.on(\"me\", (userId) => {\n\t      if (!activeVideoCall.some((user: User) => user.userId === userId)) {\n\t        activeVideoCall.push({ userId, socketId: socket.id });\n\t      }\n", "      socket.emit(\"activeforcall\", activeVideoCall);\n\t    });\n\t    socket.on(\"calluser\", ({ userToCall, signalData, from, name }) => {\n\t      io.to(userToCall).emit(\"calluser\", { signal: signalData, from, name });\n\t    });\n\t    socket.on(\"answercall\", (data) => {\n\t      io.to(data.to).emit(\"callaccepted\", data.signal);\n\t    });\n\t    socket.on(\"callend\", (userToCall) => {\n\t      io.to(userToCall).emit(\"callingcut\", \"call ended\");\n", "    });\n\t    socket.on(\"disconnect\", () => {\n\t      activeUsers = activeUsers.filter((user) => user.socketId !== socket.id);\n\t      console.log(`user disconnected: ${socket.id}`);\n\t      io.emit(\"get-users\", activeUsers);\n\t      activeVideoCall = activeVideoCall.filter(\n\t        (user) => user.socketId !== socket.id\n\t      );\n\t      io.emit(\"activeforcall\", activeVideoCall);\n\t    });\n", "  });\n\t};\n\texport default socketConfig;\n"]}
{"filename": "src/framework/webserver/express.ts", "chunked_list": ["import express, { Application, NextFunction } from \"express\";\n\timport morgan from \"morgan\";\n\timport CORS from 'cors';\n\timport cookieParser from \"cookie-parser\";\n\timport bodyParser from \"body-parser\";\n\timport configKeys from \"../../config\";\n\tconst expressConfig = (app: Application) => {\n\t    const corsEnable = {\n\t        origin: configKeys.CLIENT_URL,\n\t        exposeHeaders: ['Cross-Origin-Opener-Policy', 'Cross-Origin-Resourse-Policy']\n", "    };\n\t    // express middlewares configuration \n\t    app.use(CORS(corsEnable));\n\t    app.use(morgan('dev'));\n\t    app.use(express.json());\n\t    app.use(cookieParser());\n\t    app.use(bodyParser.json());\n\t    app.use(bodyParser.urlencoded({ extended: true }))\n\t    app.use(express.urlencoded({ extended: true }))\n\t}\n", "export default expressConfig;"]}
{"filename": "src/framework/webserver/server.ts", "chunked_list": ["import { Server } from 'http';\n\timport configKeys from '../../config';\n\tconst serverConfig = (server: Server) => {\n\t  const startServer = () => {\n\t    server.listen(configKeys.PORT, '0.0.0.0', () => {\n\t      console.log(`Server started on http://localhost:${configKeys.PORT}`);\n\t    });\n\t  };\n\t  return {\n\t    startServer,\n", "  };\n\t};\n\texport default serverConfig;\n"]}
{"filename": "src/framework/webserver/middlewares/authMiddleware.ts", "chunked_list": ["import { Request, Response, NextFunction } from \"express\";\n\timport { HttpStatus } from \"../../../types/httpstatuscodes\";\n\timport AppError from \"../../../utilities/appError\";\n\timport { authServices } from \"../../services/authServices\";\n\tconst userAuthMiddleware = (req: Request, res: Response, next: NextFunction) => {\n\t  let token: string | null = null;\n\t  console.log(\"Entered to middleware\");\n\t  if (req.headers.authorization && req.headers.authorization.startsWith(\"Bearer \")) {\n\t    token = req.headers.authorization.split(\" \")[1];\n\t    token = token.replace(/\"/g, \"\"); // Remove double quotes from the token\n", "  }\n\t  if (!token) {\n\t    throw new AppError(\"Token not found\", HttpStatus.UNAUTHORIZED);\n\t  }\n\t  try {\n\t    const { payload }: any = authServices().verifyToken(token);\n\t    if(payload) next(); // Call next to proceed to the next middleware or route handler\n\t  } catch (error) {\n\t    console.log(error);\n\t    throw new AppError(\"Unauthorized user\", HttpStatus.UNAUTHORIZED);\n", "  }\n\t};\n\texport default userAuthMiddleware;\n"]}
{"filename": "src/framework/webserver/middlewares/errorHandler.ts", "chunked_list": ["import { NextFunction, Request, Response } from 'express';\n\timport AppError from '../../../utilities/appError';\n\tconst errorHandler = (err: AppError, req:Request, res:Response, next: NextFunction) => {\n\t    err.statusCode = err.statusCode || 500;\n\t    err.status = err.status || 'error';\n\t    if(err.statusCode === 404){\n\t        res.status(err.statusCode).json({ \n\t            errors: err.status,\n\t            errorMessage: err.message\n\t         })\n", "    } else{\n\t        res.status(err.statusCode).json({\n\t            status: err.status,\n\t            message: err.message\n\t        })\n\t    }\n\t}\n\texport default errorHandler;"]}
{"filename": "src/framework/webserver/routes/adminAuth.ts", "chunked_list": ["import express from 'express';\n\timport authControllers from '../../../adapters/controllers/adminAuthController';\n\timport { adminDbRepository } from '../../../application/repositories/adminDbRepositories';\n\timport { adminRepositoryMongoDB } from '../../database/Mongodb/repositories/adminRepositories';\n\timport { authServiceInterface } from '../../../application/services/authServiceInterface';\n\timport { authServices } from '../../services/authServices';\n\tconst adminauthRouter = () => {\n\t    const router = express.Router();\n\t    const controllers = authControllers(\n\t        authServiceInterface,\n", "        authServices,\n\t        adminDbRepository,\n\t        adminRepositoryMongoDB  \n\t    );\n\t    router.post('/login', controllers.loginAdmin);\n\t    return router\n\t}\n\texport default adminauthRouter;"]}
{"filename": "src/framework/webserver/routes/auth.ts", "chunked_list": ["import express from 'express';\n\timport authControllers from '../../../adapters/controllers/authControllers';\n\timport { userDbRepository } from '../../../application/repositories/userDbRepositories';\n\timport { userRepositoryMongoDB } from '../../database/Mongodb/repositories/userRepositories';\n\timport { authServiceInterface } from '../../../application/services/authServiceInterface';\n\timport { authServices } from '../../services/authServices';\n\tconst authRouter = () => {\n\t    const router = express.Router();\n\t    const controllers = authControllers(\n\t        authServiceInterface,\n", "        authServices,\n\t        userDbRepository,\n\t        userRepositoryMongoDB\n\t    );\n\t    router.post('/register', controllers.registerUser);\n\t    router.post('/login', controllers.loginUser);\n\t    router.post('/google_auth', controllers.googleAuth)\n\t    router.patch('/user/block/:id', controllers.blockUser)\n\t    return router\n\t}\n", "export default authRouter;"]}
{"filename": "src/framework/webserver/routes/chat.ts", "chunked_list": ["import express from 'express';\n\timport chatController from '../../../adapters/controllers/chatController';\n\timport { chatRepositoriesInterface } from '../../../application/repositories/chatRepositeries';\n\timport { chatRepositoryMongoDB } from '../../database/Mongodb/repositories/chatRepositories';\n\tconst chatRouter = () => {\n\t    const router = express.Router();\n\t    const controllers = chatController(chatRepositoriesInterface, chatRepositoryMongoDB);\n\t    // create new chat box between two users\n\t    router.post('/:senderId/:recieverId', controllers.chatCreate);\n\t    // get all chats by user\n", "    router.get('/:userId', controllers.getChats);\n\t    // get single chat\n\t    router.get('/:firstId/:secondId', controllers.getSingleChat);\n\t    return router;\n\t}\n\texport default chatRouter;"]}
{"filename": "src/framework/webserver/routes/message.ts", "chunked_list": ["import express from 'express';\n\timport messageController from '../../../adapters/controllers/messageController';\n\timport { messageRepositoryInterface } from '../../../application/repositories/messageRepository';\n\timport { messageRepositoryMongoDB } from '../../database/Mongodb/repositories/messageRepository';\n\tconst messageRouter = () => {\n\t    const router = express.Router();\n\t    const controller = messageController(messageRepositoryInterface, messageRepositoryMongoDB);\n\t    router.post('/', controller.createNewMessage);\n\t    router.get('/:chatId', controller.getUserMessages);\n\t    return router;\n", "};\n\texport default messageRouter;"]}
{"filename": "src/framework/webserver/routes/post.ts", "chunked_list": ["import express from \"express\";\n\timport postControllers from \"../../../adapters/controllers/postControllers\";\n\timport { postDbInterface } from \"../../../application/repositories/postDbRepositories\";\n\timport { postRepositoryMongoDb } from \"../../database/Mongodb/repositories/postRepositeries\";\n\timport { upload } from \"../../services/multerServices\";\n\tconst  postRouter = () => {\n\t    const router = express.Router();\n\t    const controller = postControllers(postDbInterface, postRepositoryMongoDb);\n\t    // get all posts from db\n\t    router.get('/', controller.getPosts);\n", "    // upload post\n\t    router.post('/', upload.single('image'), controller.uploadPost);\n\t    // edit post\n\t    router.put('/edit_post/:postId', controller.editPost)\n\t    // get posts by a user\n\t    router.get('/userposts/:userId', controller.getUserPosts)\n\t    // get individual post by id\n\t    router.get('/post/:id', controller.getPost)\n\t    // delete particular post by id\n\t    router.delete('/:id', controller.deletePost)\n", "    // like and dilike post by user\n\t    router.patch('/like', controller.postLikeUpdate)\n\t    // push comment in post\n\t    router.patch('/comment/:postId/:userId', controller.commentPost)\n\t    // reply comment\n\t    router.patch('/comment/reply/:postId/:userId', controller.commentReply)\n\t    // delete comment in post\n\t    router.delete('/delete_comment/:postId/:index', controller.commentDelete)\n\t    // report post\n\t    router.post('/report/:userId/:postId', controller.reportPost)\n", "    // get reported users\n\t    router.get('/reported/:postId', controller.getReporters)\n\t    return router;\n\t};\n\texport default postRouter;\n"]}
{"filename": "src/framework/webserver/routes/index.ts", "chunked_list": ["import {Application} from 'express';\n\timport authRouter from './auth';\n\timport userRouter from './user';\n\timport postRouter from './post';\n\timport adminauthRouter from './adminAuth';\n\timport chatRouter from './chat';\n\timport messageRouter from './message';\n\timport userAuthMiddleware from '../middlewares/authMiddleware'\n\tconst routes = (app: Application) => {\n\t    app.use('/api/auth', authRouter());\n", "    app.use('/api/admin',  adminauthRouter())\n\t    app.use('/api/user',  userRouter());\n\t    app.use('/api/post',  postRouter());\n\t    app.use('/api/chat',  chatRouter());\n\t    app.use('/api/message',  messageRouter());\n\t}\n\texport default routes;"]}
{"filename": "src/framework/webserver/routes/user.ts", "chunked_list": ["import express from 'express';\n\timport userControllers from '../../../adapters/controllers/userControllers';\n\timport { userDbRepository } from '../../../application/repositories/userDbRepositories';\n\timport { userRepositoryMongoDB } from '../../database/Mongodb/repositories/userRepositories';\n\timport { upload } from '../../services/multerServices';\n\tconst userRouter = () => {\n\t    const router = express.Router();\n\t    const controllers: any = userControllers(userDbRepository,userRepositoryMongoDB);\n\t    router.get('/all/:id', controllers.getAllUsers)\n\t    router.get('/:id', controllers.getUserById);\n", "    router.patch('/request/:id/:friendId', controllers.sendRequest)\n\t    router.get('/followers/:id', controllers.getFollowersList);\n\t    router.get('/followings/:id', controllers.getFollowingsList);\n\t    router.patch('/', controllers.unfollowUser)\n\t    router.patch('/request/friend/:id/:friendId', controllers.responseFriendRequest)\n\t    router.get('/search/:prefix', controllers.searchUser)\n\t    router.put('/:id',upload.single('file'), controllers.updateProfile)\n\t    router.patch('/:userId/:blockId', controllers.blockUser);\n\t    return router;\n\t}\n", "export default userRouter;"]}
