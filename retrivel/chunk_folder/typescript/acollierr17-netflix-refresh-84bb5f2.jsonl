{"filename": "types.d.ts", "chunked_list": ["declare module \"tailwindcss-animate\";\n"]}
{"filename": "src/pages/api/add-new-titles.ts", "chunked_list": ["import { type NextApiRequest, type NextApiResponse } from \"next\";\n\timport { verifySignature } from \"@upstash/qstash/nextjs\";\n\timport { ulid } from \"ulid\";\n\timport authenticateRequest from \"@/server/authenticateRequest\";\n\timport { fetchNewTitles } from \"@/lib/netflix\";\n\timport { prisma } from \"@/server/db\";\n\timport { parseTitles } from \"@/lib/parsers\";\n\tasync function handler(req: NextApiRequest, res: NextApiResponse) {\n\t  try {\n\t    const date = new Date();\n", "    const titles = await fetchNewTitles({\n\t      date,\n\t      force: true,\n\t      fetchAllCountries: true,\n\t    });\n\t    if (titles.length < 1) {\n\t      res.statusCode = 204;\n\t      res.statusMessage = \"No newly added content.\";\n\t      return res.end();\n\t    }\n", "    const data = parseTitles(titles).map((title) => ({ ...title, id: ulid() }));\n\t    const created = await prisma.title.createMany({\n\t      data: data,\n\t      skipDuplicates: true,\n\t    });\n\t    if (created.count < 1) {\n\t      res.statusCode = 204;\n\t      res.statusMessage = \"There are no new titles to update in the database.\";\n\t      return res.end();\n\t    }\n", "    return res.json({\n\t      metadata: {\n\t        nonce: date.getTime(),\n\t        size: titles.length,\n\t        added: created.count,\n\t      },\n\t      data: titles,\n\t    });\n\t  } catch (e: any) {\n\t    return res.status(500).json({\n", "      code: res.statusCode,\n\t      name: e.name,\n\t      message: e.message,\n\t    });\n\t  }\n\t}\n\texport default verifySignature(authenticateRequest(handler));\n\texport const config = {\n\t  api: {\n\t    bodyParser: false,\n", "  },\n\t};\n"]}
{"filename": "src/pages/api/post-to-twitter.ts", "chunked_list": ["import { type NextApiRequest, type NextApiResponse } from \"next\";\n\timport { verifySignature } from \"@upstash/qstash/nextjs\";\n\timport authenticateRequest from \"@/server/authenticateRequest\";\n\timport { fetchDailyTitles } from \"@/lib/netflix\";\n\timport { buildThread, createTweetThread } from \"@/server/twitter\";\n\tasync function handler(req: NextApiRequest, res: NextApiResponse) {\n\t  try {\n\t    const date = new Date();\n\t    const titles = await fetchDailyTitles({ date, force: true });\n\t    if (!titles.size) {\n", "      res.statusCode = 204;\n\t      res.statusMessage = \"No newly added or deleted content.\";\n\t      return res.end();\n\t    }\n\t    const tweetContent = buildThread({ date, titles });\n\t    const thread = await createTweetThread(tweetContent);\n\t    return res.json({\n\t      metadata: {\n\t        nonce: date.getTime(),\n\t        size: titles.size,\n", "      },\n\t      data: {\n\t        tweet_id: thread[0]?.data.id,\n\t        added: titles.added,\n\t        deleted: titles.deleted,\n\t      },\n\t    });\n\t  } catch (e: any) {\n\t    return res.status(500).json({\n\t      code: res.statusCode,\n", "      name: e.name,\n\t      message: e.message,\n\t    });\n\t  }\n\t}\n\texport default verifySignature(authenticateRequest(handler));\n\texport const config = {\n\t  api: {\n\t    bodyParser: false,\n\t  },\n", "};\n"]}
{"filename": "src/pages/api/netflix/added-titles.ts", "chunked_list": ["import { type NextApiRequest, type NextApiResponse } from \"next\";\n\timport { fetchNewTitles } from \"@/lib/netflix\";\n\timport { convertDateQueryParam, getFormattedDate } from \"@/lib/date\";\n\timport authenticateRequest from \"@/server/authenticateRequest\";\n\tasync function handler(req: NextApiRequest, res: NextApiResponse) {\n\t  try {\n\t    const date = new Date();\n\t    const queryDate = convertDateQueryParam(req.query.date, date);\n\t    if (!queryDate)\n\t      return res.status(400).json({\n", "        metadata: {\n\t          nonce: date.getTime(),\n\t        },\n\t        message: `The 'date' query parameter is not in the proper format! (ex. ${getFormattedDate(\n\t          date\n\t        )})`,\n\t      });\n\t    const formattedQueryDate = getFormattedDate(queryDate);\n\t    const titles = await fetchNewTitles({ date: queryDate });\n\t    if (titles.length < 1) {\n", "      res.statusCode = 204;\n\t      res.statusMessage =\n\t        \"There are no new added titles for the provided date.\";\n\t      return res.end();\n\t    }\n\t    return res.json({\n\t      metadata: {\n\t        nonce: date.getTime(),\n\t        query_date: formattedQueryDate,\n\t        size: titles.length,\n", "      },\n\t      data: titles,\n\t    });\n\t  } catch (e: any) {\n\t    return res.status(500).json({\n\t      code: res.statusCode,\n\t      name: e.name,\n\t      message: e.message,\n\t    });\n\t  }\n", "}\n\texport default authenticateRequest(handler);\n"]}
{"filename": "src/pages/api/netflix/get-daily-titles.ts", "chunked_list": ["import { type NextApiRequest, type NextApiResponse } from \"next\";\n\timport { fetchDailyTitles } from \"@/lib/netflix\";\n\timport { convertDateQueryParam, getFormattedDate } from \"@/lib/date\";\n\timport authenticateRequest from \"@/server/authenticateRequest\";\n\tasync function handler(req: NextApiRequest, res: NextApiResponse) {\n\t  try {\n\t    const date = new Date();\n\t    const queryDate = convertDateQueryParam(req.query.date, date);\n\t    if (!queryDate)\n\t      return res.status(400).json({\n", "        metadata: {\n\t          nonce: date.getTime(),\n\t        },\n\t        message: `The 'date' query parameter is not in the proper format! (ex. ${getFormattedDate(\n\t          date\n\t        )})`,\n\t      });\n\t    const formattedQueryDate = getFormattedDate(queryDate);\n\t    const titles = await fetchDailyTitles({ date: queryDate });\n\t    if (!titles.size) {\n", "      res.statusCode = 204;\n\t      res.statusMessage = \"No newly added or deleted content.\";\n\t      return res.end();\n\t    }\n\t    return res.json({\n\t      metadata: {\n\t        nonce: date.getTime(),\n\t        query_date: formattedQueryDate,\n\t        size: titles.size,\n\t      },\n", "      data: {\n\t        added: titles.added,\n\t        deleted: titles.deleted,\n\t      },\n\t    });\n\t  } catch (e: any) {\n\t    return res.status(500).json({\n\t      code: res.statusCode,\n\t      name: e.name,\n\t      message: e.message,\n", "    });\n\t  }\n\t}\n\texport default authenticateRequest(handler);\n"]}
{"filename": "src/pages/api/netflix/deleted-titles.ts", "chunked_list": ["import { type NextApiRequest, type NextApiResponse } from \"next\";\n\timport { fetchDeletedTitles } from \"@/lib/netflix\";\n\timport { convertDateQueryParam, getFormattedDate } from \"@/lib/date\";\n\timport authenticateRequest from \"@/server/authenticateRequest\";\n\tasync function handler(req: NextApiRequest, res: NextApiResponse) {\n\t  try {\n\t    const date = new Date();\n\t    const queryDate = convertDateQueryParam(req.query.date, date);\n\t    if (!queryDate)\n\t      return res.status(400).json({\n", "        metadata: {\n\t          nonce: date.getTime(),\n\t        },\n\t        message: `The 'date' query parameter is not in the proper format! (ex. ${getFormattedDate(\n\t          date\n\t        )})`,\n\t      });\n\t    const formattedQueryDate = getFormattedDate(queryDate);\n\t    const titles = await fetchDeletedTitles({ date: queryDate });\n\t    if (titles.length < 1) {\n", "      res.statusCode = 204;\n\t      res.statusMessage =\n\t        \"There are no new deleted titles for the provided date.\";\n\t      return res.end();\n\t    }\n\t    return res.json({\n\t      metadata: {\n\t        nonce: date.getTime(),\n\t        query_date: formattedQueryDate,\n\t        size: titles.length,\n", "      },\n\t      data: titles,\n\t    });\n\t  } catch (e: any) {\n\t    return res.status(500).json({\n\t      code: res.statusCode,\n\t      name: e.name,\n\t      message: e.message,\n\t    });\n\t  }\n", "}\n\texport default authenticateRequest(handler);\n"]}
{"filename": "src/config/site.ts", "chunked_list": ["export type SiteConfig = typeof siteConfig;\n\texport const siteConfig = {\n\t  name: \"Netflix Refresh\",\n\t  description:\n\t    \"Get notified on added/removed content on Netflix in your Twitter feed daily!\",\n\t  mainNav: [\n\t    {\n\t      title: \"Home\",\n\t      href: \"/\",\n\t    },\n", "  ],\n\t  links: {\n\t    twitter: \"https://twitter.com/NetflixRefresh\",\n\t    github: \"https://github.com/acollierr17/netflix-refresh\",\n\t  },\n\t};\n"]}
{"filename": "src/lib/api.ts", "chunked_list": ["/**\n\t * This is the client-side entrypoint for your tRPC API. It is used to create the `api` object which\n\t * contains the Next.js App-wrapper, as well as your type-safe React Query hooks.\n\t *\n\t * We also create a few inference helpers for input and output types.\n\t */\n\timport { httpBatchLink, loggerLink } from \"@trpc/client\";\n\timport { createTRPCNext } from \"@trpc/next\";\n\timport { type inferRouterInputs, type inferRouterOutputs } from \"@trpc/server\";\n\timport superjson from \"superjson\";\n", "import { type AppRouter } from \"@/server/api/root\";\n\tconst getBaseUrl = () => {\n\t  if (typeof window !== \"undefined\") return \"\"; // browser should use relative url\n\t  if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`; // SSR should use vercel url\n\t  return `http://localhost:${process.env.PORT ?? 3000}`; // dev SSR should use localhost\n\t};\n\t/** A set of type-safe react-query hooks for your tRPC API. */\n\texport const api = createTRPCNext<AppRouter>({\n\t  config() {\n\t    return {\n", "      /**\n\t       * Transformer used for data de-serialization from the server.\n\t       *\n\t       * @see https://trpc.io/docs/data-transformers\n\t       */\n\t      transformer: superjson,\n\t      /**\n\t       * Links used to determine request flow from client to server.\n\t       *\n\t       * @see https://trpc.io/docs/links\n", "       */\n\t      links: [\n\t        loggerLink({\n\t          enabled: (opts) =>\n\t            process.env.NODE_ENV === \"development\" ||\n\t            (opts.direction === \"down\" && opts.result instanceof Error),\n\t        }),\n\t        httpBatchLink({\n\t          url: `${getBaseUrl()}/api/trpc`,\n\t        }),\n", "      ],\n\t    };\n\t  },\n\t  /**\n\t   * Whether tRPC should await queries when server rendering pages.\n\t   *\n\t   * @see https://trpc.io/docs/nextjs#ssr-boolean-default-false\n\t   */\n\t  ssr: false,\n\t});\n", "/**\n\t * Inference helper for inputs.\n\t *\n\t * @example type HelloInput = RouterInputs['example']['hello']\n\t */\n\texport type RouterInputs = inferRouterInputs<AppRouter>;\n\t/**\n\t * Inference helper for outputs.\n\t *\n\t * @example type HelloOutput = RouterOutputs['example']['hello']\n", " */\n\texport type RouterOutputs = inferRouterOutputs<AppRouter>;\n"]}
{"filename": "src/lib/trpc.ts", "chunked_list": ["import { createTRPCReact } from \"@trpc/react-query\";\n\timport { type inferRouterInputs, type inferRouterOutputs } from \"@trpc/server\";\n\t// import type { AppRouter } from \"@/app/api/trpc/trpc-router\";\n\timport type { AppRouter } from \"@/server/api/root\";\n\texport const api = createTRPCReact<AppRouter>();\n\t/**\n\t * Inference helper for inputs.\n\t *\n\t * @example type HelloInput = RouterInputs['example']['hello']\n\t */\n", "export type RouterInputs = inferRouterInputs<AppRouter>;\n\t/**\n\t * Inference helper for outputs.\n\t *\n\t * @example type HelloOutput = RouterOutputs['example']['hello']\n\t */\n\texport type RouterOutputs = inferRouterOutputs<AppRouter>;\n"]}
{"filename": "src/lib/fonts.ts", "chunked_list": ["import {\n\t  JetBrains_Mono as FontMono,\n\t  Inter as FontSans,\n\t} from \"next/font/google\";\n\texport const fontSans = FontSans({\n\t  subsets: [\"latin\"],\n\t  variable: \"--font-sans\",\n\t});\n\texport const fontMono = FontMono({\n\t  subsets: [\"latin\"],\n", "  variable: \"--font-mono\",\n\t});\n"]}
{"filename": "src/lib/parsers.ts", "chunked_list": ["import { z } from \"zod\";\n\timport type { NetflixJSONData } from \"./netflix\";\n\texport const TitleSchema = z.object({\n\t  imdbId: z.string().max(16),\n\t  img: z.string().max(1024),\n\t  netflixId: z.number(),\n\t  poster: z.string().max(1024),\n\t  rating: z.string().max(255),\n\t  runtime: z.string().max(255),\n\t  synopsis: z.string().max(1024),\n", "  title: z.string().max(255),\n\t  titleDate: z.string().max(255),\n\t  titleType: z.string().max(6),\n\t  top250: z.number(),\n\t  top250tv: z.number(),\n\t  year: z.string().max(4),\n\t});\n\texport const TitlesSchema = z.array(TitleSchema);\n\texport const parseTitles = (data: NetflixJSONData[]) => {\n\t  const formatted = data.map(formatJSONData);\n", "  return TitlesSchema.parse(formatted);\n\t};\n\texport const formatJSONData = (data: NetflixJSONData) => ({\n\t  imdbId: data[\"imdb_id\"],\n\t  img: data[\"img\"],\n\t  netflixId: data[\"netflix_id\"],\n\t  poster: data[\"poster\"],\n\t  rating: data[\"rating\"],\n\t  runtime: data[\"runtime\"],\n\t  synopsis: data[\"synopsis\"],\n", "  title: data[\"title\"],\n\t  titleDate: data[\"title_date\"],\n\t  titleType: data[\"title_type\"],\n\t  top250: data[\"top250\"],\n\t  top250tv: data[\"top250tv\"],\n\t  year: data[\"year\"],\n\t});\n"]}
{"filename": "src/lib/utils.ts", "chunked_list": ["import { clsx, type ClassValue } from \"clsx\";\n\timport { twMerge } from \"tailwind-merge\";\n\texport function cn(...inputs: ClassValue[]) {\n\t  return twMerge(clsx(inputs));\n\t}\n"]}
{"filename": "src/lib/date.ts", "chunked_list": ["/**\n\t * For dates:\n\t * - CONTEXT: Date is 2023-05-16\n\t * - Note: When doing a date range to the current date, it will exclude the current date.\n\t * To resolve this, +1 the date to add those results.\n\t * Ex. 2023-05-01-2023-05-16 would be changed to 2023-05-01,2023-05-17\n\t *\n\t * - Get all titles on a SPECIFIC date, ex. 2023-05-15,2023-05-16\n\t * - Get all titles FROM a SPECIFIC date, ex. 2023-05-09\n\t * - Get all titles between a specific date range, ex. 2023-03-01,2023-03-08\n", " * - Get all titles FROM a SPECIFIC date to the CURRENT date, ex. 2023-05-01,2023-05-17\n\t * - Get all titles on the CURRENT date, ex. 2023-05-16\n\t */\n\texport const formatDateQueryString = (date: Date): string => {\n\t  const currentDate = new Date();\n\t  if (areDatesEqual(date, currentDate)) return getFormattedDate(date);\n\t  const endDate = new Date(date);\n\t  endDate.setDate(endDate.getDate() + 1);\n\t  return `${getFormattedDate(date)},${getFormattedDate(endDate)}`;\n\t};\n", "export const convertUTCStringToDate = (utc: string): Date => {\n\t  const parts = utc.split(\"-\");\n\t  const year = Number(parts[0]);\n\t  const month = Number(parts[1]) - 1;\n\t  const day = Number(parts[2]);\n\t  return new Date(year, month, day);\n\t};\n\tconst areDatesEqual = (date1: Date, date2: Date) => {\n\t  return (\n\t    date1.getFullYear() === date2.getFullYear() &&\n", "    date1.getMonth() === date2.getMonth() &&\n\t    date1.getDate() === date2.getDate()\n\t  );\n\t};\n\texport const getFriendlyFormattedDate = (date: Date): string => {\n\t  return new Intl.DateTimeFormat(\"en-US\", {\n\t    year: \"numeric\",\n\t    month: \"long\",\n\t    day: \"numeric\",\n\t  }).format(date);\n", "};\n\texport const getFormattedDate = (date: Date): string => {\n\t  const year = date.getFullYear().toString();\n\t  const month = (date.getMonth() + 1).toString().padStart(2, \"0\");\n\t  const day = date.getDate().toString().padStart(2, \"0\");\n\t  return [year, month, day].join(\"-\");\n\t};\n\texport const convertDateQueryParam = (\n\t  param: string | string[] | undefined,\n\t  date: Date\n", ") => {\n\t  return param\n\t    ? convertUTCStringToDate(\n\t        Array.isArray(param) ? (param[0] as string) : param\n\t      )\n\t    : date;\n\t};\n"]}
{"filename": "src/lib/netflix.ts", "chunked_list": ["import { env } from \"@/env.mjs\";\n\timport redis from \"@/server/redis\";\n\timport { formatDateQueryString, getFormattedDate } from \"./date\";\n\tconst { RAPIDAPI_KEY, RAPIDAPI_HOST } = env;\n\texport type NetflixJSONData = {\n\t  imdb_id: string;\n\t  img: string;\n\t  netflix_id: number;\n\t  poster: string;\n\t  rating: string;\n", "  runtime: string;\n\t  synopsis: string;\n\t  title: string;\n\t  title_date: string;\n\t  title_type: \"series\" | \"movie\";\n\t  top250: number;\n\t  top250tv: number;\n\t  year: string;\n\t};\n\texport type DailyNetflixJSON = {\n", "  size: number;\n\t  added: NetflixJSONData[];\n\t  deleted: NetflixDeleteJSONData[];\n\t};\n\texport type NetflixDeleteJSONData = {\n\t  netflix_id: number;\n\t  country_id: number;\n\t  title: string;\n\t  delete_date: string;\n\t  country_code: string;\n", "};\n\texport type BaseNetflixData<T> = {\n\t  Object: {\n\t    total: number;\n\t    limit: number;\n\t    offset: number;\n\t  };\n\t  results: T[] | null;\n\t};\n\ttype RequestOptions = {\n", "  route: string;\n\t  method?: \"GET\" | \"POST\" | \"PATCH\" | \"PUT\" | \"DELETE\";\n\t  body?: BodyInit | null;\n\t  headers?: HeadersInit | null;\n\t  queries?: URLSearchParams | null;\n\t  fetchAllCountries?: boolean | null;\n\t};\n\ttype FetchTitleOptions = {\n\t  date: Date;\n\t  force?: boolean;\n", "  fetchAllCountries?: boolean;\n\t};\n\tconst BASE_URL = `https://${RAPIDAPI_HOST}`;\n\tconst makeNetflixRequest = async <T>(\n\t  options: RequestOptions\n\t): Promise<BaseNetflixData<T>> => {\n\t  const url = new URL(`${BASE_URL + options.route}`);\n\t  if (!options.queries) {\n\t    const params = new URLSearchParams();\n\t    if (!options.fetchAllCountries) params.set(\"country_list\", \"78\");\n", "    options.queries = params;\n\t  }\n\t  if (!options.fetchAllCountries) options.queries.set(\"country_list\", \"78\");\n\t  url.search = options.queries.toString();\n\t  return fetch(url, {\n\t    headers: {\n\t      ...options.headers,\n\t      \"X-RapidAPI-Key\": RAPIDAPI_KEY,\n\t      \"X-RapidAPI-Host\": RAPIDAPI_HOST,\n\t    },\n", "    body: options.body,\n\t  }).then((res: Response) => res.json() as Promise<BaseNetflixData<T>>);\n\t};\n\texport const fetchDailyTitles = async ({ date }: FetchTitleOptions) => {\n\t  const queryDate = formatDateQueryString(date);\n\t  const data: DailyNetflixJSON = {\n\t    size: 0,\n\t    added: [],\n\t    deleted: [],\n\t  };\n", "  const promises = [fetchNewTitles({ date }), fetchDeletedTitles({ date })];\n\t  const results = await Promise.allSettled(promises);\n\t  const addedContent =\n\t    results[0]?.status === \"fulfilled\" ? results[0].value : [];\n\t  const deletedContent =\n\t    results[1]?.status === \"fulfilled\" ? results[1].value : [];\n\t  if (addedContent) {\n\t    data.added = [...data.added, ...addedContent] as NetflixJSONData[];\n\t    data.size += data.added.length;\n\t  }\n", "  if (deletedContent) {\n\t    data.deleted = [\n\t      ...data.deleted,\n\t      ...deletedContent,\n\t    ] as NetflixDeleteJSONData[];\n\t    data.size += data.deleted.length;\n\t  }\n\t  const dateFormatted = getFormattedDate(date);\n\t  const cachedDateExists = await redis.sismember(\"dates\", queryDate);\n\t  if (!cachedDateExists) {\n", "    await redis.sadd(\"dates\", dateFormatted);\n\t    await redis.hset<DailyNetflixJSON>(\"daily-titles\", {\n\t      [dateFormatted]: data,\n\t    });\n\t  }\n\t  return data;\n\t};\n\texport const fetchDeletedTitles = async ({\n\t  date,\n\t  force,\n", "  fetchAllCountries,\n\t}: FetchTitleOptions) => {\n\t  const queryDate = formatDateQueryString(date);\n\t  const queries = new URLSearchParams({\n\t    delete_date: queryDate,\n\t  });\n\t  const cached = force\n\t    ? null\n\t    : await redis.hget<NetflixDeleteJSONData[]>(\"deleted-titles\", queryDate);\n\t  if (cached) return cached;\n", "  const { results } = await makeNetflixRequest<NetflixDeleteJSONData>({\n\t    route: \"/search/deleted\",\n\t    queries,\n\t    fetchAllCountries,\n\t  });\n\t  if (!results) return [] as NetflixJSONData[];\n\t  if (!force)\n\t    await redis.hset<NetflixDeleteJSONData[]>(\"deleted-titles\", {\n\t      [getFormattedDate(date)]: results,\n\t    });\n", "  return results;\n\t};\n\texport const fetchNewTitles = async ({\n\t  date,\n\t  force,\n\t  fetchAllCountries,\n\t}: FetchTitleOptions) => {\n\t  const queryDate = formatDateQueryString(date);\n\t  const queries = new URLSearchParams({\n\t    order_by: \"date\",\n", "    new_date: queryDate,\n\t  });\n\t  const cached = force\n\t    ? null\n\t    : await redis.hget<NetflixJSONData[]>(\"added-titles\", queryDate);\n\t  if (cached) return cached;\n\t  const { results } = await makeNetflixRequest<NetflixJSONData>({\n\t    route: \"/search/titles\",\n\t    queries,\n\t    fetchAllCountries,\n", "  });\n\t  if (!results) return [] as NetflixJSONData[];\n\t  if (!force)\n\t    await redis.hset<NetflixJSONData[]>(\"added-titles\", {\n\t      [getFormattedDate(date)]: results,\n\t    });\n\t  return results;\n\t};\n"]}
{"filename": "src/server/authenticateRequest.ts", "chunked_list": ["import type { NextApiHandler, NextApiRequest, NextApiResponse } from \"next\";\n\timport { env } from \"@/env.mjs\";\n\texport default function authenticateRequest(\n\t  handler: NextApiHandler\n\t): NextApiHandler {\n\t  const date = new Date();\n\t  return (req: NextApiRequest, res: NextApiResponse) => {\n\t    if (\n\t      !req.headers[\"x-api-key\"] ||\n\t      req.headers[\"x-api-key\"] !== env.API_TOKEN\n", "    ) {\n\t      return res.status(401).json({\n\t        metadata: { nonce: date.getTime() },\n\t        error: \"The API key is invalid or not found.\",\n\t      });\n\t    }\n\t    return handler(req, res);\n\t  };\n\t}\n"]}
{"filename": "src/server/redis.ts", "chunked_list": ["import { Redis } from \"@upstash/redis\";\n\timport { env } from \"@/env.mjs\";\n\tconst redis = new Redis({\n\t  url: env.UPSTASH_REDIS_REST_URL,\n\t  token: env.UPSTASH_REDIS_REST_TOKEN,\n\t});\n\texport default redis;\n"]}
{"filename": "src/server/twitter.ts", "chunked_list": ["import { TwitterApi } from \"twitter-api-v2\";\n\timport he from \"he\";\n\timport { stripIndents } from \"common-tags\";\n\timport { env } from \"@/env.mjs\";\n\timport type {\n\t  DailyNetflixJSON,\n\t  NetflixDeleteJSONData,\n\t  NetflixJSONData,\n\t} from \"@/lib/netflix\";\n\timport { getFriendlyFormattedDate } from \"@/lib/date\";\n", "const client = new TwitterApi({\n\t  appKey: env.TWITTER_CONSUMER_KEY,\n\t  appSecret: env.TWITTER_CONSUMER_SECRET,\n\t  accessToken: env.TWITTER_ACCESS_TOKEN,\n\t  accessSecret: env.TWITTER_ACCESS_TOKEN_SECRET,\n\t});\n\texport const createTweetThread = async (tweets: string[]) => {\n\t  return client.v2.tweetThread(tweets);\n\t};\n\texport const buildThread = ({\n", "  date,\n\t  titles,\n\t}: {\n\t  date: Date;\n\t  titles: DailyNetflixJSON;\n\t}): string[] => {\n\t  const displayTitle = (title: NetflixJSONData | NetflixDeleteJSONData) => {\n\t    const titleType = {\n\t      series: \"Series\",\n\t      movie: \"Movie\",\n", "    };\n\t    let str = \"• \";\n\t    if (\"year\" in title)\n\t      str += `${he.decode(title.title)} (${title.year}) [${\n\t        titleType[title.title_type]\n\t      }]`;\n\t    else str += he.decode(title.title);\n\t    return str;\n\t  };\n\t  const tweetContent: string[] = [\n", "    stripIndents`\n\t      Netflix Refresh (US) • ${getFriendlyFormattedDate(date)}\n\t      Added: ${titles.added.length}\n\t      Deleted: ${titles.deleted.length}\n\t    `,\n\t  ];\n\t  if (titles.added.length > 0)\n\t    tweetContent.push(stripIndents`\n\t      Added Content:\n\t      ${titles.added.map(displayTitle).join(\"\\n\")}\n", "    `);\n\t  if (titles.deleted.length > 0)\n\t    tweetContent.push(stripIndents`\n\t      Deleted Content:\n\t      ${titles.deleted.map(displayTitle).join(\"\\n\")}\n\t    `);\n\t  return tweetContent;\n\t};\n"]}
{"filename": "src/server/db.ts", "chunked_list": ["import { PrismaClient } from \"@prisma/client\";\n\timport { env } from \"@/env.mjs\";\n\tconst globalForPrisma = globalThis as unknown as {\n\t  prisma: PrismaClient | undefined;\n\t};\n\texport const prisma =\n\t  globalForPrisma.prisma ??\n\t  new PrismaClient({\n\t    log:\n\t      env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n", "  });\n\tif (env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n"]}
{"filename": "src/server/api/trpc.ts", "chunked_list": ["/**\n\t * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:\n\t * 1. You want to modify request context (see Part 1).\n\t * 2. You want to create a new middleware or type of procedure (see Part 3).\n\t *\n\t * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will\n\t * need to use are documented accordingly near the end.\n\t */\n\timport { initTRPC } from \"@trpc/server\";\n\timport { type CreateNextContextOptions } from \"@trpc/server/adapters/next\";\n", "import superjson from \"superjson\";\n\timport { ZodError } from \"zod\";\n\timport { prisma } from \"@/server/db\";\n\t/**\n\t * 1. CONTEXT\n\t *\n\t * This section defines the \"contexts\" that are available in the backend API.\n\t *\n\t * These allow you to access things when processing a request, like the database, the session, etc.\n\t */\n", "type CreateContextOptions = Record<string, never>;\n\t/**\n\t * This helper generates the \"internals\" for a tRPC context. If you need to use it, you can export\n\t * it from here.\n\t *\n\t * Examples of things you may need it for:\n\t * - testing, so we don't have to mock Next.js' req/res\n\t * - tRPC's `createSSGHelpers`, where we don't have req/res\n\t *\n\t * @see https://create.t3.gg/en/usage/trpc#-serverapitrpcts\n", " */\n\tconst createInnerTRPCContext = (_opts: CreateContextOptions) => {\n\t  return {\n\t    prisma,\n\t  };\n\t};\n\t/**\n\t * This is the actual context you will use in your router. It will be used to process every request\n\t * that goes through your tRPC endpoint.\n\t *\n", " * @see https://trpc.io/docs/context\n\t */\n\texport const createTRPCContext = (_opts: CreateNextContextOptions) => {\n\t  return createInnerTRPCContext({});\n\t};\n\t/**\n\t * 2. INITIALIZATION\n\t *\n\t * This is where the tRPC API is initialized, connecting the context and transformer. We also parse\n\t * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation\n", " * errors on the backend.\n\t */\n\tconst t = initTRPC.context<typeof createTRPCContext>().create({\n\t  transformer: superjson,\n\t  errorFormatter({ shape, error }) {\n\t    return {\n\t      ...shape,\n\t      data: {\n\t        ...shape.data,\n\t        zodError:\n", "          error.cause instanceof ZodError ? error.cause.flatten() : null,\n\t      },\n\t    };\n\t  },\n\t});\n\t/**\n\t * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)\n\t *\n\t * These are the pieces you use to build your tRPC API. You should import these a lot in the\n\t * \"/src/server/api/routers\" directory.\n", " */\n\t/**\n\t * This is how you create new routers and sub-routers in your tRPC API.\n\t *\n\t * @see https://trpc.io/docs/router\n\t */\n\texport const createTRPCRouter = t.router;\n\t/**\n\t * Public (unauthenticated) procedure\n\t *\n", " * This is the base piece you use to build new queries and mutations on your tRPC API. It does not\n\t * guarantee that a user querying is authorized, but you can still access user session data if they\n\t * are logged in.\n\t */\n\texport const publicProcedure = t.procedure;\n"]}
{"filename": "src/server/api/root.ts", "chunked_list": ["import { exampleRouter } from \"@/server/api/router/example\";\n\timport { createTRPCRouter } from \"@/server/api/trpc\";\n\t/**\n\t * This is the primary router for your server.\n\t *\n\t * All routers added in /api/routers should be manually added here.\n\t */\n\texport const appRouter = createTRPCRouter({\n\t  example: exampleRouter,\n\t});\n", "// export type definition of API\n\texport type AppRouter = typeof appRouter;\n"]}
{"filename": "src/server/api/router/example.ts", "chunked_list": ["import { z } from \"zod\";\n\timport { createTRPCRouter, publicProcedure } from \"@/server/api/trpc\";\n\texport const exampleRouter = createTRPCRouter({\n\t  hello: publicProcedure\n\t    .input(z.object({ text: z.string() }))\n\t    .query(({ input }) => {\n\t      return {\n\t        greeting: `Hello ${input.text}`,\n\t      };\n\t    }),\n", "  getUsers: publicProcedure.query(({ ctx }) => {\n\t    return userList;\n\t  }),\n\t  getNetflixTitle: publicProcedure\n\t    .input(z.object({ id: z.number() }))\n\t    .query(async ({ input, ctx }) => {\n\t      return await ctx.prisma.title.findUnique({\n\t        where: {\n\t          netflixId: input.id,\n\t        },\n", "      });\n\t    }),\n\t});\n\t// The code below is kept here to keep things simple\n\tinterface User {\n\t  id: string;\n\t  name: string;\n\t  email: string;\n\t}\n\tconst userList: User[] = [\n", "  {\n\t    id: \"1\",\n\t    name: \"John Doe\",\n\t    email: \"johndoe@gmail.com\",\n\t  },\n\t  {\n\t    id: \"2\",\n\t    name: \"Abraham Smith\",\n\t    email: \"abrahamsmith@gmail.com\",\n\t  },\n", "  {\n\t    id: \"3\",\n\t    name: \"Barbie Tracy\",\n\t    email: \"barbietracy@gmail.com\",\n\t  },\n\t  {\n\t    id: \"4\",\n\t    name: \"John Payday\",\n\t    email: \"johnpayday@gmail.com\",\n\t  },\n", "  {\n\t    id: \"5\",\n\t    name: \"Remember My Name\",\n\t    email: \"remembermyname@gmail.com\",\n\t  },\n\t  {\n\t    id: \"6\",\n\t    name: \"Go to School\",\n\t    email: \"gotoschool@gmail.com\",\n\t  },\n", "  {\n\t    id: \"7\",\n\t    name: \"Fish Fruit\",\n\t    email: \"fishfruit@gmail.com\",\n\t  },\n\t  {\n\t    id: \"8\",\n\t    name: \"Don't try\",\n\t    email: \"donttry@gmail.com\",\n\t  },\n", "  {\n\t    id: \"9\",\n\t    name: \"Producer Feed\",\n\t    email: \"producerfeed@gmail.com\",\n\t  },\n\t  {\n\t    id: \"10\",\n\t    name: \"Panic So\",\n\t    email: \"panicso@gmail.com\",\n\t  },\n", "];\n"]}
{"filename": "src/types/nav.ts", "chunked_list": ["export interface NavItem {\n\t  title: string;\n\t  href?: string;\n\t  disabled?: boolean;\n\t  external?: boolean;\n\t}\n"]}
{"filename": "src/app/api/trpc/[trpc]/route.ts", "chunked_list": ["import {\n\t  type FetchCreateContextFnOptions,\n\t  fetchRequestHandler,\n\t} from \"@trpc/server/adapters/fetch\";\n\timport { appRouter } from \"@/server/api/root\";\n\timport { env } from \"@/env.mjs\";\n\timport { prisma } from \"@/server/db\";\n\ttype CreateContextOptions = {\n\t  prisma: typeof prisma;\n\t};\n", "const handler = (request: Request) => {\n\t  console.log(`incoming request ${request.url}`);\n\t  return fetchRequestHandler({\n\t    endpoint: \"/api/trpc\",\n\t    req: request,\n\t    router: appRouter,\n\t    createContext: function (\n\t      opts: FetchCreateContextFnOptions\n\t    ): CreateContextOptions {\n\t      return {\n", "        prisma,\n\t      };\n\t    },\n\t    onError:\n\t      env.NODE_ENV === \"development\"\n\t        ? ({ path, error }) => {\n\t            console.error(\n\t              `❌ tRPC failed on ${path ?? \"<no-path>\"}: ${error.message}`\n\t            );\n\t          }\n", "        : undefined,\n\t  });\n\t};\n\texport { handler as GET, handler as POST };\n"]}
