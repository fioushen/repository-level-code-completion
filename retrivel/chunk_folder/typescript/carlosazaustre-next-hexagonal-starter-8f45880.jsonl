{"filename": "jest.config.ts", "chunked_list": ["import nextJest from 'next/jest';\n\timport { pathsToModuleNameMapper } from 'ts-jest';\n\timport { compilerOptions } from './tsconfig.json';\n\tconst createJestConfig = nextJest({\n\t\tdir: './',\n\t});\n\tconst customJestConfig = {\n\t\tsetupFilesAfterEnv: ['<rootDir>/jest.setup.js'],\n\t\tmodulePaths: ['<rootDir>/src', '<rootDir>/tests'],\n\t\tmoduleNameMapper: pathsToModuleNameMapper(compilerOptions.paths),\n", "\ttestEnvironment: 'jest-environment-jsdom'\n\t};\n\tmodule.exports = createJestConfig(customJestConfig);\n"]}
{"filename": "cypress.config.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-unused-vars */\n\timport { defineConfig } from \"cypress\";\n\texport default defineConfig({\n\t\tvideo: false,\n\t  e2e: {\n\t    setupNodeEvents(on, config) {\n\t      // implement node event listeners here\n\t    },\n\t  },\n\t});\n"]}
{"filename": "cypress/support/e2e.ts", "chunked_list": ["// ***********************************************************\n\t// This example support/e2e.ts is processed and\n\t// loaded automatically before your test files.\n\t//\n\t// This is a great place to put global configuration and\n\t// behavior that modifies Cypress.\n\t//\n\t// You can change the location of this file or turn off\n\t// automatically serving support files with the\n\t// 'supportFile' configuration option.\n", "//\n\t// You can read more here:\n\t// https://on.cypress.io/configuration\n\t// ***********************************************************\n\t// Import commands.js using ES2015 syntax:\n\timport './commands'\n\t// Alternatively you can use CommonJS syntax:\n\t// require('./commands')"]}
{"filename": "cypress/support/commands.ts", "chunked_list": ["/// <reference types=\"cypress\" />\n\t// ***********************************************\n\t// This example commands.ts shows you how to\n\t// create various custom commands and overwrite\n\t// existing commands.\n\t//\n\t// For more comprehensive examples of custom\n\t// commands please read more here:\n\t// https://on.cypress.io/custom-commands\n\t// ***********************************************\n", "//\n\t//\n\t// -- This is a parent command --\n\t// Cypress.Commands.add('login', (email, password) => { ... })\n\t//\n\t//\n\t// -- This is a child command --\n\t// Cypress.Commands.add('drag', { prevSubject: 'element'}, (subject, options) => { ... })\n\t//\n\t//\n", "// -- This is a dual command --\n\t// Cypress.Commands.add('dismiss', { prevSubject: 'optional'}, (subject, options) => { ... })\n\t//\n\t//\n\t// -- This will overwrite an existing command --\n\t// Cypress.Commands.overwrite('visit', (originalFn, url, options) => { ... })\n\t//\n\t// declare global {\n\t//   namespace Cypress {\n\t//     interface Chainable {\n", "//       login(email: string, password: string): Chainable<void>\n\t//       drag(subject: string, options?: Partial<TypeOptions>): Chainable<Element>\n\t//       dismiss(subject: string, options?: Partial<TypeOptions>): Chainable<Element>\n\t//       visit(originalFn: CommandOriginalFn, url: string, options: Partial<VisitOptions>): Chainable<Element>\n\t//     }\n\t//   }\n\t// }"]}
{"filename": "__tests__/modules/posts/application/get/getPostById.spec.ts", "chunked_list": ["import { getPostById } from '@/src/modules/posts/application/get/getPostById';\n\timport { createApiPostRepository } from '@/src/modules/posts/infra/ApiPostRepository';\n\timport { createApiUserRepository } from '@/src/modules/users/infra/ApiUserRepository';\n\timport { createApiCommentRepository } from '@/src/modules/comments/infra/ApiCommentRepository';\n\timport { posts, users, comments } from '@/tests/fixtures/mockData.json';\n\tconst postRepository = createApiPostRepository();\n\tconst userRepository = createApiUserRepository();\n\tconst commentRepository = createApiCommentRepository();\n\tdescribe('[useCase] getPostById', () => {\n\t\tafterEach(() => {\n", "\t\tjest.restoreAllMocks();\n\t\t});\n\t\ttest('should throw an error if post not found', async () => {\n\t\t\tjest\n\t\t\t\t.spyOn(postRepository, 'get')\n\t\t\t\t.mockImplementation(() => Promise.resolve(undefined));\n\t\t\tjest\n\t\t\t\t.spyOn(userRepository, 'get')\n\t\t\t\t.mockImplementation(() => Promise.resolve(undefined));\n\t\t\tjest\n", "\t\t\t.spyOn(commentRepository, 'getAllByPost')\n\t\t\t\t.mockImplementation(() => Promise.resolve([]));\n\t\t\tconst postId = 999;\n\t\t\tconst getPost = getPostById(\n\t\t\t\tpostRepository,\n\t\t\t\tuserRepository,\n\t\t\t\tcommentRepository,\n\t\t\t);\n\t\t\tawait expect(getPost(postId)).rejects.toThrow(\n\t\t\t\t`Post with id ${postId} not found`,\n", "\t\t);\n\t\t});\n\t\ttest('should return a post with author and comment count when post and author exist', async () => {\n\t\t\tjest\n\t\t\t\t.spyOn(postRepository, 'get')\n\t\t\t\t.mockImplementation(() => Promise.resolve(posts[0]));\n\t\t\tjest\n\t\t\t\t.spyOn(userRepository, 'get')\n\t\t\t\t.mockImplementation(() => Promise.resolve(users[0]));\n\t\t\tjest\n", "\t\t\t.spyOn(commentRepository, 'getAllByPost')\n\t\t\t\t.mockImplementation(() =>\n\t\t\t\t\tPromise.resolve(\n\t\t\t\t\t\tcomments.filter(comment => comment.postId === posts[0].id),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\tconst postId = 1;\n\t\t\tconst getPost = getPostById(\n\t\t\t\tpostRepository,\n\t\t\t\tuserRepository,\n", "\t\t\tcommentRepository,\n\t\t\t);\n\t\t\tconst result = await getPost(postId);\n\t\t\texpect(result).toEqual({\n\t\t\t\t...posts[0],\n\t\t\t\tauthor: {\n\t\t\t\t\tid: users[0].id,\n\t\t\t\t\tname: users[0].name,\n\t\t\t\t},\n\t\t\t\tcommentCount: comments.filter(comment => comment.postId === postId)\n", "\t\t\t\t.length,\n\t\t\t});\n\t\t});\n\t\ttest('should return a post with undefined author and comment count when post exists but author does not', async () => {\n\t\t\tjest\n\t\t\t\t.spyOn(postRepository, 'get')\n\t\t\t\t.mockImplementation(() => Promise.resolve(posts[0]));\n\t\t\tjest\n\t\t\t\t.spyOn(userRepository, 'get')\n\t\t\t\t.mockImplementation(() => Promise.resolve(undefined));\n", "\t\tjest\n\t\t\t\t.spyOn(commentRepository, 'getAllByPost')\n\t\t\t\t.mockImplementation(() =>\n\t\t\t\t\tPromise.resolve(\n\t\t\t\t\t\tcomments.filter(comment => comment.postId === posts[0].id),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\tconst postId = 1;\n\t\t\tconst getPost = getPostById(\n\t\t\t\tpostRepository,\n", "\t\t\tuserRepository,\n\t\t\t\tcommentRepository,\n\t\t\t);\n\t\t\tconst result = await getPost(postId);\n\t\t\texpect(result).toEqual({\n\t\t\t\t...posts[0],\n\t\t\t\tauthor: {\n\t\t\t\t\tid: undefined,\n\t\t\t\t\tname: undefined,\n\t\t\t\t},\n", "\t\t\tcommentCount: comments.filter(comment => comment.postId === postId)\n\t\t\t\t\t.length,\n\t\t\t});\n\t\t});\n\t});\n"]}
{"filename": "__tests__/modules/posts/application/create/createPost.spec.ts", "chunked_list": ["import { Post } from \"@/src/modules/posts/domain/Post\";\n\timport { PostDataResponse } from \"@/src/modules/posts/domain/PostDataResponse\";\n\timport { PostDataCreate } from \"@/src/modules/posts/domain/PostDataCreate\";\n\timport { createPost } from \"@/src/modules/posts/application/create/createPost\";\n\timport { createApiPostRepository } from \"@/src/modules/posts/infra/ApiPostRepository\";\n\timport { createApiUserRepository } from \"@/src/modules/users/infra/ApiUserRepository\";\n\timport { posts, users } from \"@/tests/fixtures/mockData.json\";\n\tconst postRepository = createApiPostRepository();\n\tconst userRepository = createApiUserRepository();\n\tdescribe('[useCase] createPost', () => {\n", "\ttest('should create a post and return it with author and comment count', async () => {\n\t\t\tconst postData: PostDataCreate = {\n\t\t\t\ttitle: 'title',\n\t\t\t\tbody: 'body',\n\t\t\t\tuserId: 1,\n\t\t\t};\n\t\t\tconst createdPost: PostDataResponse = {\n\t\t\t\tid: posts.length + 1,\n\t\t\t\t...postData,\n\t\t\t};\n", "\t\tjest.spyOn(postRepository, 'create').mockImplementation(() => Promise.resolve(createdPost));\n\t\t\tjest.spyOn(userRepository, 'get').mockImplementation(() => Promise.resolve(users[0]));\n\t\t\tconst createNewPost = createPost(postRepository, userRepository);\n\t\t\tconst result: Post = await createNewPost(postData);\n\t\t\texpect(result).toEqual({\n\t\t\t\t...createdPost,\n\t\t\t\tcommentCount: 0,\n\t\t\t\tauthor: users[0],\n\t\t\t});\n\t\t});\n", "});\n"]}
{"filename": "__tests__/modules/posts/application/get-all/getAllPosts.spec.ts", "chunked_list": ["import { getAllPosts } from '@/src/modules/posts/application/get-all/getAllPosts';\n\timport { createApiPostRepository } from '@/src/modules/posts/infra/ApiPostRepository';\n\timport { createApiUserRepository } from '@/src/modules/users/infra/ApiUserRepository';\n\timport { createApiCommentRepository } from '@/src/modules/comments/infra/ApiCommentRepository';\n\timport { PostMapper } from '@/src/modules/posts/application/mappers/PostMapper';\n\timport { posts, users, comments } from '@/tests/fixtures/mockData.json';\n\tconst postRepository = createApiPostRepository();\n\tconst userRepository = createApiUserRepository();\n\tconst commentRepository = createApiCommentRepository();\n\tdescribe('[useCase] getAllPosts', () => {\n", "\tafterEach(() => {\n\t\t\tjest.restoreAllMocks();\n\t\t});\n\t\ttest('should return all posts with author and comment count', async () => {\n\t\t\tjest\n\t\t\t\t.spyOn(postRepository, 'getAll')\n\t\t\t\t.mockImplementation(() => Promise.resolve(posts));\n\t\t\tjest\n\t\t\t\t.spyOn(userRepository, 'getAll')\n\t\t\t\t.mockImplementation(() => Promise.resolve(users));\n", "\t\tjest\n\t\t\t\t.spyOn(commentRepository, 'getAll')\n\t\t\t\t.mockImplementation(() => Promise.resolve(comments));\n\t\t\tconst getPosts = getAllPosts(\n\t\t\t\tpostRepository,\n\t\t\t\tuserRepository,\n\t\t\t\tcommentRepository,\n\t\t\t\tPostMapper,\n\t\t\t);\n\t\t\tconst result = await getPosts();\n", "\t\texpect(result.length).toEqual(posts.length);\n\t\t});\n\t\ttest('should return all posts with undefined authors and zero comment count if users and comments are empty', async () => {\n\t\t\tjest\n\t\t\t\t.spyOn(postRepository, 'getAll')\n\t\t\t\t.mockImplementation(() => Promise.resolve(posts));\n\t\t\tjest\n\t\t\t\t.spyOn(userRepository, 'getAll')\n\t\t\t\t.mockImplementation(() => Promise.resolve([]));\n\t\t\tjest\n", "\t\t\t.spyOn(commentRepository, 'getAll')\n\t\t\t\t.mockImplementation(() => Promise.resolve([]));\n\t\t\tconst getPosts = getAllPosts(\n\t\t\t\tpostRepository,\n\t\t\t\tuserRepository,\n\t\t\t\tcommentRepository,\n\t\t\t\tPostMapper,\n\t\t\t);\n\t\t\tconst result = await getPosts();\n\t\t\texpect(result.length).toEqual(posts.length);\n", "\t\tresult.forEach((postWithDetails, index) => {\n\t\t\t\tconst originalPost = posts[index];\n\t\t\t\texpect(postWithDetails).toEqual({\n\t\t\t\t\t...originalPost,\n\t\t\t\t\tauthor: undefined,\n\t\t\t\t\tcommentCount: 0,\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t\ttest('should return an empty array if there are no posts', async () => {\n", "\t\tjest\n\t\t\t\t.spyOn(postRepository, 'getAll')\n\t\t\t\t.mockImplementation(() => Promise.resolve([]));\n\t\t\tjest\n\t\t\t\t.spyOn(userRepository, 'getAll')\n\t\t\t\t.mockImplementation(() => Promise.resolve(users));\n\t\t\tjest\n\t\t\t\t.spyOn(commentRepository, 'getAll')\n\t\t\t\t.mockImplementation(() => Promise.resolve(comments));\n\t\t\tconst getPosts = getAllPosts(\n", "\t\t\tpostRepository,\n\t\t\t\tuserRepository,\n\t\t\t\tcommentRepository,\n\t\t\t\tPostMapper,\n\t\t\t);\n\t\t\tconst result = await getPosts();\n\t\t\texpect(result.length).toEqual(0);\n\t\t});\n\t});\n"]}
{"filename": "__tests__/modules/posts/application/mappers/PostMapper.spec.ts", "chunked_list": ["import { PostMapper } from '@/src/modules/posts/application/mappers/PostMapper';\n\timport { users, posts, comments } from '@/tests/fixtures/mockData.json';\n\tdescribe('[mapper] PostMapper', () => {\n\t\tdescribe('createUserMap', () => {\n\t\t\ttest('should create a user map from users', () => {\n\t\t\t\tconst userMap = PostMapper.createUserMap(users);\n\t\t\t\texpect(userMap.size).toEqual(users.length);\n\t\t\t\texpect(userMap.get(1)).toEqual(users[0]);\n\t\t\t\texpect(userMap.get(2)).toEqual(users[1]);\n\t\t\t});\n", "\t\ttest('should handle an empty user list', () => {\n\t\t\t\tconst userMap = PostMapper.createUserMap([]);\n\t\t\t\texpect(userMap.size).toEqual(0);\n\t\t\t});\n\t\t});\n\t\tdescribe('createCommentCountMap', () => {\n\t\t\ttest('should create a comment count map from comments', () => {\n\t\t\t\tconst commentCountMap = PostMapper.createCommentCountMap(comments);\n\t\t\t\texpect(commentCountMap.size).toEqual(2);\n\t\t\t\texpect(commentCountMap.get(1)).toEqual(2);\n", "\t\t\texpect(commentCountMap.get(2)).toEqual(1);\n\t\t\t});\n\t\t\ttest('should handle an empty comment list', () => {\n\t\t\t\tconst commentCountMap = PostMapper.createCommentCountMap([]);\n\t\t\t\texpect(commentCountMap.size).toEqual(0);\n\t\t\t});\n\t\t});\n\t\tdescribe('addAuthorAndCommentCountToPosts', () => {\n\t\t\ttest('should add author and comment count to posts', async () => {\n\t\t\t\tconst userMap = PostMapper.createUserMap(users);\n", "\t\t\tconst commentCountMap = PostMapper.createCommentCountMap(comments);\n\t\t\t\tconst postsWithDetails = await PostMapper.addAuthorAndCommentCountToPosts(\n\t\t\t\t\tposts,\n\t\t\t\t\tuserMap,\n\t\t\t\t\tcommentCountMap,\n\t\t\t\t);\n\t\t\t\texpect(postsWithDetails.length).toEqual(posts.length);\n\t\t\t\texpect(postsWithDetails[0]).toEqual({\n\t\t\t\t\t...posts[0],\n\t\t\t\t\tauthor: users[0],\n", "\t\t\t\tcommentCount: 2,\n\t\t\t\t});\n\t\t\t\texpect(postsWithDetails[1]).toEqual({\n\t\t\t\t\t...posts[1],\n\t\t\t\t\tauthor: users[1],\n\t\t\t\t\tcommentCount: 1,\n\t\t\t\t});\n\t\t\t});\n\t\t\ttest('should handle an empty post list', async () => {\n\t\t\t\tconst userMap = PostMapper.createUserMap(users);\n", "\t\t\tconst commentCountMap = PostMapper.createCommentCountMap(comments);\n\t\t\t\tconst postsWithDetails = await PostMapper.addAuthorAndCommentCountToPosts(\n\t\t\t\t\t[],\n\t\t\t\t\tuserMap,\n\t\t\t\t\tcommentCountMap,\n\t\t\t\t);\n\t\t\t\texpect(postsWithDetails.length).toEqual(0);\n\t\t\t});\n\t\t\ttest('should handle posts with missing authors', async () => {\n\t\t\t\tconst userMap = PostMapper.createUserMap(users.slice(1)); // Excluye al primer usuario\n", "\t\t\tconst commentCountMap = PostMapper.createCommentCountMap(comments);\n\t\t\t\tconst postsWithDetails = await PostMapper.addAuthorAndCommentCountToPosts(\n\t\t\t\t\tposts,\n\t\t\t\t\tuserMap,\n\t\t\t\t\tcommentCountMap,\n\t\t\t\t);\n\t\t\t\texpect(postsWithDetails.length).toEqual(posts.length);\n\t\t\t\texpect(postsWithDetails[0]).toEqual({\n\t\t\t\t\t...posts[0],\n\t\t\t\t\tauthor: undefined,\n", "\t\t\t\tcommentCount: 2,\n\t\t\t\t});\n\t\t\t\texpect(postsWithDetails[1]).toEqual({\n\t\t\t\t\t...posts[1],\n\t\t\t\t\tauthor: users[1],\n\t\t\t\t\tcommentCount: 1,\n\t\t\t\t});\n\t\t\t});\n\t\t\ttest('should handle posts with no associated comments', async () => {\n\t\t\t\tconst userMap = PostMapper.createUserMap(users);\n", "\t\t\tconst commentCountMap = PostMapper.createCommentCountMap([]);\n\t\t\t\tconst postsWithDetails = await PostMapper.addAuthorAndCommentCountToPosts(\n\t\t\t\t\tposts,\n\t\t\t\t\tuserMap,\n\t\t\t\t\tcommentCountMap,\n\t\t\t\t);\n\t\t\t\texpect(postsWithDetails.length).toEqual(posts.length);\n\t\t\t\texpect(postsWithDetails[0]).toEqual({\n\t\t\t\t\t...posts[0],\n\t\t\t\t\tauthor: users[0],\n", "\t\t\t\tcommentCount: 0,\n\t\t\t\t});\n\t\t\t\texpect(postsWithDetails[1]).toEqual({\n\t\t\t\t\t...posts[1],\n\t\t\t\t\tauthor: users[1],\n\t\t\t\t\tcommentCount: 0,\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n"]}
{"filename": "src/pages/api/hello.ts", "chunked_list": ["// Next.js API route support: https://nextjs.org/docs/api-routes/introduction\n\timport type { NextApiRequest, NextApiResponse } from 'next';\n\ttype Data = {\n\t\tname: string;\n\t};\n\texport default function handler(\n\t\treq: NextApiRequest,\n\t\tres: NextApiResponse<Data>,\n\t) {\n\t\tres.status(200).json({ name: 'John Doe' });\n", "}\n"]}
{"filename": "src/sections/posts/usePostForm.ts", "chunked_list": ["import { useState } from 'react';\n\timport { UserRepository } from '@/src/modules/users/domain/UserRepository';\n\timport { PostRepository } from '@/src/modules/posts/domain/PostRepository';\n\timport { PostDataCreate } from '@/src/modules/posts/domain/PostDataCreate';\n\timport { Post } from '@/src/modules/posts/domain/Post';\n\timport { createPost } from '@/src/modules/posts/application/create/createPost';\n\timport { FormStatus } from '@/src/hooks/useFormData';\n\texport function usePostForm(\n\t\tuserRepository: UserRepository,\n\t\tpostRepository: PostRepository,\n", "): {\n\t\tformStatus: FormStatus;\n\t\tsubmitForm: (formData: PostDataCreate) => void;\n\t\tresetFormStatus: () => void;\n\t\tpostCreated: Post | null;\n\t} {\n\t\tconst [formStatus, setFormStatus] = useState(FormStatus.INITIAL);\n\t\tconst [postCreated, setPostCreated] = useState<Post | null>(null);\n\t\tconst submitForm = async ({ title, body, userId }: PostDataCreate) => {\n\t\t\tsetFormStatus(FormStatus.LOADING);\n", "\t\ttry {\n\t\t\t\tconst postCreated = await createPost(\n\t\t\t\t\tpostRepository,\n\t\t\t\t\tuserRepository,\n\t\t\t\t)({ title, body, userId }).catch(() => {\n\t\t\t\t\tthrow new Error('Error creating post');\n\t\t\t\t});\n\t\t\t\tsetPostCreated(postCreated);\n\t\t\t\tsetFormStatus(FormStatus.SUCCESS);\n\t\t\t} catch (error) {\n", "\t\t\tsetFormStatus(FormStatus.ERROR);\n\t\t\t}\n\t\t};\n\t\tconst resetFormStatus = () => setFormStatus(FormStatus.INITIAL);\n\t\treturn {\n\t\t\tformStatus,\n\t\t\tsubmitForm,\n\t\t\tresetFormStatus,\n\t\t\tpostCreated,\n\t\t};\n", "}\n"]}
{"filename": "src/hooks/usePagination.ts", "chunked_list": ["import { useState, useEffect } from 'react';\n\timport { Post } from '@/src/modules/posts/domain/Post';\n\timport { PostRepository } from '@/src/modules/posts/domain/PostRepository';\n\timport { UserRepository } from '@/src/modules/users/domain/UserRepository';\n\timport { CommentRepository } from '@/src/modules/comments/domain/CommentRepository';\n\timport { getPaginatedPosts } from '@/src/modules/posts/application/get-all/getPaginatedPosts';\n\timport { PostMapper } from '@/src/modules/posts/application/mappers/PostMapper';\n\timport { useLocalStorage } from '@/src/hooks/useLocalStorage';\n\texport function usePagination(\n\t\tpostRepository: PostRepository,\n", "\tuserRepository: UserRepository,\n\t\tcommentRepository: CommentRepository,\n\t\tinitialPosts: Post[],\n\t\tinitialPage: number,\n\t\titemsPerPage: number,\n\t): [Post[], number, (page: number) => void] {\n\t\tconst [currentPosts, setCurrentPosts] = useState<Post[]>(initialPosts);\n\t\tconst [currentPage, setCurrentPage] = useLocalStorage<number>(\n\t\t\t'currentPage',\n\t\t\tinitialPage,\n", "\t);\n\t\tconst fetchMorePosts = async () => {\n\t\t\tconst fetchedPosts: Post[] = await getPaginatedPosts(\n\t\t\t\tpostRepository,\n\t\t\t\tuserRepository,\n\t\t\t\tcommentRepository,\n\t\t\t\tPostMapper,\n\t\t\t\titemsPerPage,\n\t\t\t\tcurrentPage,\n\t\t\t)();\n", "\t\tsetCurrentPosts(fetchedPosts);\n\t\t};\n\t\tuseEffect(() => {\n\t\t\tfetchMorePosts();\n\t\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t}, [currentPage]);\n\t\treturn [currentPosts, currentPage, setCurrentPage];\n\t}\n\texport default usePagination;\n"]}
{"filename": "src/hooks/useFormData.ts", "chunked_list": ["import { useState } from 'react';\n\texport const enum FormStatus {\n\t\tLOADING,\n\t\tSUCCESS,\n\t\tERROR,\n\t\tINITIAL,\n\t}\n\texport function useFormData<T>(initialState: T): {\n\t\tformData: T;\n\t\tupdateForm: (value: Partial<T>) => void;\n", "\tresetForm: () => void;\n\t} {\n\t\tconst [formData, setFormData] = useState(initialState);\n\t\tconst updateForm = (value: Partial<typeof initialState>) => {\n\t\t\tsetFormData(oldState => ({ ...oldState, ...value }));\n\t\t};\n\t\tconst resetForm = () => setFormData(initialState);\n\t\treturn {\n\t\t\tformData,\n\t\t\tupdateForm,\n", "\t\tresetForm,\n\t\t};\n\t}\n"]}
{"filename": "src/hooks/useLocalStorage.ts", "chunked_list": ["import { useState, useEffect } from 'react';\n\texport function useLocalStorage<T>(\n\t\tkey: string,\n\t\tinitialValue: T,\n\t): [T, (value: T) => void] {\n\t\tconst [storedValue, setStoredValue] = useState<T>(() => {\n\t\t\tif (typeof window === 'undefined') {\n\t\t\t\treturn initialValue;\n\t\t\t}\n\t\t\tconst item = window.localStorage.getItem(key);\n", "\t\treturn item ? JSON.parse(item) : initialValue;\n\t\t});\n\t\tconst setValue = (value: T) => {\n\t\t\tsetStoredValue(value);\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\twindow.localStorage.setItem(key, JSON.stringify(value));\n\t\t\t}\n\t\t};\n\t\tuseEffect(() => {\n\t\t\tif (typeof window !== 'undefined') {\n", "\t\t\tconst handleStorageChange = (e: StorageEvent) => {\n\t\t\t\t\tif (e.key === key && e.newValue !== e.oldValue) {\n\t\t\t\t\t\tsetStoredValue(JSON.parse(e.newValue as string));\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\twindow.addEventListener('storage', handleStorageChange);\n\t\t\t\treturn () => {\n\t\t\t\t\twindow.removeEventListener('storage', handleStorageChange);\n\t\t\t\t};\n\t\t\t}\n", "\t}, [key]);\n\t\treturn [storedValue, setValue];\n\t}\n\texport default useLocalStorage;\n"]}
{"filename": "src/modules/users/application/get/getUser.ts", "chunked_list": ["import { User } from '../../domain/User';\n\timport { UserRepository } from '../../domain/UserRepository';\n\texport function getUser(userRepository: UserRepository) {\n\t\treturn async (userId: number): Promise<User | undefined> => {\n\t\t\treturn await userRepository.get(userId);\n\t\t};\n\t}\n"]}
{"filename": "src/modules/users/application/get-all/getAllUsers.ts", "chunked_list": ["import { User } from '../../domain/User';\n\timport { UserRepository } from '../../domain/UserRepository';\n\texport function getAllUsers(userRepository: UserRepository) {\n\t\treturn async (): Promise<User[]> => {\n\t\t\treturn await userRepository.getAll();\n\t\t};\n\t}\n"]}
{"filename": "src/modules/users/domain/UserRepository.ts", "chunked_list": ["import { User } from './User';\n\texport interface UserRepository {\n\t\tget: (id: number) => Promise<User | undefined>;\n\t\tgetAll: () => Promise<User[]>;\n\t}\n"]}
{"filename": "src/modules/users/domain/UserAddressGeolocation.ts", "chunked_list": ["export interface UserAddressGeolocation {\n\t\tlat: string;\n\t\tlng: string;\n\t}\n"]}
{"filename": "src/modules/users/domain/UserCompany.ts", "chunked_list": ["export interface UserCompany {\n\t\tname: string;\n\t\tcatchPhrase: string;\n\t\tbs: string;\n\t}\n"]}
{"filename": "src/modules/users/domain/UserAddress.ts", "chunked_list": ["import { UserAddressGeolocation } from './UserAddressGeolocation';\n\texport interface UserAddress {\n\t\tstreet: string;\n\t\tsuite: string;\n\t\tcity: string;\n\t\tzipcode: string;\n\t\tgeo: UserAddressGeolocation;\n\t}\n"]}
{"filename": "src/modules/users/domain/User.ts", "chunked_list": ["import { UserAddress } from './UserAddress';\n\timport { UserCompany } from './UserCompany';\n\texport interface User {\n\t\tid: number;\n\t\tname: string;\n\t\temail: string;\n\t\taddress: UserAddress;\n\t\tphone: string;\n\t\twebsite: string;\n\t\tcompany: UserCompany;\n", "}\n"]}
{"filename": "src/modules/users/domain/Author.ts", "chunked_list": ["export interface Author {\n\t\tid: number | undefined;\n\t\tname: string | undefined;\n\t}\n"]}
{"filename": "src/modules/users/infra/ApiUserRepository.ts", "chunked_list": ["import { User } from '../domain/User';\n\timport { UserRepository } from '../domain/UserRepository';\n\tconst JSONPLACEHOLDER_URL = 'https://jsonplaceholder.typicode.com';\n\texport function createApiUserRepository(): UserRepository {\n\t\tconst cache: Map<number, User> = new Map();\n\t\tasync function get(id: number): Promise<User | undefined> {\n\t\t\tif (cache.has(id)) {\n\t\t\t\treturn cache.get(id) as User;\n\t\t\t}\n\t\t\tconst response = await fetch(`${JSONPLACEHOLDER_URL}/users/${id}`);\n", "\t\tconst user = await response.json();\n\t\t\tcache.set(id, user);\n\t\t\treturn user;\n\t\t}\n\t\tasync function getAll(): Promise<User[]> {\n\t\t\tif (cache.size > 0) {\n\t\t\t\treturn Array.from(cache.values());\n\t\t\t}\n\t\t\tconst response = await fetch(`${JSONPLACEHOLDER_URL}/users`);\n\t\t\tconst users = await response.json();\n", "\t\tusers.forEach((user: User) => cache.set(user.id, user));\n\t\t\treturn users;\n\t\t}\n\t\treturn {\n\t\t\tget,\n\t\t\tgetAll,\n\t\t};\n\t}\n"]}
{"filename": "src/modules/posts/application/get/getPostById.ts", "chunked_list": ["import { UserRepository } from '@/src/modules/users/domain/UserRepository';\n\timport { CommentRepository } from '@/src/modules/comments/domain/CommentRepository';\n\timport { PostRepository } from '../../domain/PostRepository';\n\timport { Post } from '../../domain/Post';\n\texport function getPostById(\n\t\tpostRepository: PostRepository,\n\t\tuserRepository: UserRepository,\n\t\tcommentRepository: CommentRepository,\n\t): (postId: number) => Promise<Post | undefined> {\n\t\treturn async (postId: number): Promise<Post | undefined> => {\n", "\t\tconst post = await postRepository.get(postId);\n\t\t\tif (!post) {\n\t\t\t\tthrow new Error(`Post with id ${postId} not found`);\n\t\t\t}\n\t\t\tconst [author, comments] = await Promise.all([\n\t\t\t\tuserRepository.get(post.userId),\n\t\t\t\tcommentRepository.getAllByPost(postId),\n\t\t\t]);\n\t\t\tconst postWithAuthorAndCommentCount = {\n\t\t\t\t...post,\n", "\t\t\tauthor: {\n\t\t\t\t\tid: author?.id,\n\t\t\t\t\tname: author?.name,\n\t\t\t\t},\n\t\t\t\tcommentCount: comments.length,\n\t\t\t};\n\t\t\treturn postWithAuthorAndCommentCount;\n\t\t};\n\t}\n"]}
{"filename": "src/modules/posts/application/create/createPost.ts", "chunked_list": ["import { UserRepository } from \"@/src/modules/users/domain/UserRepository\";\n\timport { PostRepository } from \"../../domain/PostRepository\";\n\timport { Post } from \"../../domain/Post\";\n\timport { PostDataCreate } from \"../../domain/PostDataCreate\";\n\timport { PostDataResponse } from \"../../domain/PostDataResponse\";\n\texport function createPost(\n\t\tpostRepository: PostRepository,\n\t\tuserRepository: UserRepository,\n\t): (post: PostDataCreate) => Promise<Post> {\n\t\treturn async (post: PostDataCreate): Promise<Post> => {\n", "\t\tconst createdPost = await postRepository.create(post) as PostDataResponse;\n\t\t\tconst commentCount = 0;\n\t\t\tconst author = await userRepository.get(post.userId);\n\t\t\t//TODO: ensurePostIsValid\n\t\t\treturn {\n\t\t\t\t...createdPost,\n\t\t\t\tauthor,\n\t\t\t\tcommentCount,\n\t\t\t};\n\t\t};\n", "}\n"]}
{"filename": "src/modules/posts/application/get-all/getAllPosts.ts", "chunked_list": ["import { UserRepository } from '@/src/modules/users/domain/UserRepository';\n\timport { CommentRepository } from '@/src/modules/comments/domain/CommentRepository';\n\timport { PostRepository } from '../../domain/PostRepository';\n\timport { Post } from '../../domain/Post';\n\timport { PostMapper } from '../mappers/PostMapper';\n\texport function getAllPosts(\n\t\tpostRepository: PostRepository,\n\t\tuserRepository: UserRepository,\n\t\tcommentRepository: CommentRepository,\n\t\tpostMapper: typeof PostMapper,\n", "): () => Promise<Post[]> {\n\t\treturn async (): Promise<Post[]> => {\n\t\t\tconst [posts, users, comments] = await Promise.all([\n\t\t\t\tpostRepository.getAll(),\n\t\t\t\tuserRepository.getAll(),\n\t\t\t\tcommentRepository.getAll(),\n\t\t\t]);\n\t\t\tconst userMap = postMapper.createUserMap(users);\n\t\t\tconst commentCountByPostId = postMapper.createCommentCountMap(comments);\n\t\t\treturn await postMapper.addAuthorAndCommentCountToPosts(\n", "\t\t\tposts,\n\t\t\t\tuserMap,\n\t\t\t\tcommentCountByPostId,\n\t\t\t);\n\t\t};\n\t}\n"]}
{"filename": "src/modules/posts/application/get-all/getPaginatedPosts.ts", "chunked_list": ["import { UserRepository } from '@/src/modules/users/domain/UserRepository';\n\timport { CommentRepository } from '@/src/modules/comments/domain/CommentRepository';\n\timport { PostRepository } from '../../domain/PostRepository';\n\timport { Post } from '../../domain/Post';\n\timport { PostMapper } from '../mappers/PostMapper';\n\texport function getPaginatedPosts(\n\t\tpostRepository: PostRepository,\n\t\tuserRepository: UserRepository,\n\t\tcommentRepository: CommentRepository,\n\t\tpostMapper: typeof PostMapper,\n", "\tlimit: number,\n\t\tpage: number,\n\t): () => Promise<Post[]> {\n\t\treturn async (): Promise<Post[]> => {\n\t\t\tconst [posts, users, comments] = await Promise.all([\n\t\t\t\tpostRepository.getAllWithPagination(limit, page),\n\t\t\t\tuserRepository.getAll(),\n\t\t\t\tcommentRepository.getAll(),\n\t\t\t]);\n\t\t\tconst userMap = postMapper.createUserMap(users);\n", "\t\tconst commentCountByPostId = postMapper.createCommentCountMap(comments);\n\t\t\treturn await postMapper.addAuthorAndCommentCountToPosts(\n\t\t\t\tposts,\n\t\t\t\tuserMap,\n\t\t\t\tcommentCountByPostId,\n\t\t\t);\n\t\t};\n\t}\n"]}
{"filename": "src/modules/posts/application/get-all/getAllPostsByUser.ts", "chunked_list": ["import { Post } from '../../domain/Post';\n\timport { PostRepository } from '../../domain/PostRepository';\n\texport function getAllPostsByUser(\n\t\tpostRepository: PostRepository,\n\t): (userId: number) => Promise<Post[]> {\n\t\treturn async (userId: number): Promise<Post[]> => {\n\t\t\treturn await postRepository.getByUser(userId);\n\t\t};\n\t}\n"]}
{"filename": "src/modules/posts/application/mappers/PostMapper.ts", "chunked_list": ["import { Post } from '@/src/modules/posts/domain/Post';\n\timport { User } from '@/src/modules/users/domain/User';\n\timport { Comment } from '@/src/modules/comments/domain/Comment';\n\texport const PostMapper = {\n\t\tcreateUserMap,\n\t\tcreateCommentCountMap,\n\t\taddAuthorAndCommentCountToPosts,\n\t};\n\tfunction createUserMap(users: User[]): Map<number, User> {\n\t\tconst userMap = new Map<number, User>();\n", "\tusers.forEach(user => userMap.set(user.id, user));\n\t\treturn userMap;\n\t}\n\tfunction createCommentCountMap(comments: Comment[]): Map<number, number> {\n\t\tconst commentCountMap = new Map<number, number>();\n\t\tcomments.forEach(comment => {\n\t\t\tconst count = commentCountMap.get(comment.postId) ?? 0;\n\t\t\tcommentCountMap.set(comment.postId, count + 1);\n\t\t});\n\t\treturn commentCountMap;\n", "}\n\tasync function addAuthorAndCommentCountToPosts(\n\t\tposts: Post[],\n\t\tuserMap = new Map<number, User>(),\n\t\tcommentCountByPostId: Map<number, number>,\n\t): Promise<Post[]> {\n\t\tconst postsWithDetails = posts.map(post => {\n\t\t\tconst author = userMap.get(post.userId);\n\t\t\treturn {\n\t\t\t\t...post,\n", "\t\t\tauthor,\n\t\t\t\tcommentCount: commentCountByPostId.get(post.id) || 0,\n\t\t\t};\n\t\t});\n\t\treturn postsWithDetails;\n\t}\n"]}
{"filename": "src/modules/posts/domain/PostRepository.ts", "chunked_list": ["import { Post } from './Post';\n\timport { PostDataCreate } from './PostDataCreate';\n\timport { PostDataResponse } from './PostDataResponse';\n\texport interface PostRepository {\n\t\tcreate: (post: PostDataCreate) => Promise<PostDataResponse>;\n\t\tget: (postId: number) => Promise<Post | undefined>;\n\t\tgetAllWithPagination: (limit: number, page: number) => Promise<Post[]>;\n\t\tgetAll: () => Promise<Post[]>;\n\t\tgetByUser: (userId: number) => Promise<Post[]>;\n\t}\n"]}
{"filename": "src/modules/posts/domain/PostDataCreate.ts", "chunked_list": ["export interface PostDataCreate {\n\t\ttitle: string;\n\t\tbody: string;\n\t\tuserId: number;\n\t};\n\t// TODO: add validation function\n\t// ensurePostIsValid\n"]}
{"filename": "src/modules/posts/domain/Post.ts", "chunked_list": ["import { Author } from '../../users/domain/Author';\n\texport interface Post {\n\t\tuserId: number;\n\t\tid: number;\n\t\ttitle: string;\n\t\tbody: string;\n\t\tauthor?: Author;\n\t\tcommentCount?: number;\n\t}\n"]}
{"filename": "src/modules/posts/domain/PostDataResponse.ts", "chunked_list": ["export interface PostDataResponse {\n\t\tid: number;\n\t\ttitle: string;\n\t\tbody: string;\n\t\tuserId: number;\n\t};\n"]}
{"filename": "src/modules/posts/infra/ApiPostRepository.ts", "chunked_list": ["import { Post } from '../domain/Post';\n\timport { PostDataCreate } from '../domain/PostDataCreate';\n\timport { PostDataResponse } from '../domain/PostDataResponse'; \n\timport { PostRepository } from '../domain/PostRepository';\n\tconst JSONPLACEHOLDER_URL = 'https://jsonplaceholder.typicode.com';\n\texport function createApiPostRepository(): PostRepository {\n\t\tconst cache = new Map<number, Post>();\n\t\tasync function get(postId: number): Promise<Post> {\n\t\t\tif (cache.has(postId)) {\n\t\t\t\treturn cache.get(postId) as Post;\n", "\t\t}\n\t\t\tconst response = await fetch(`${JSONPLACEHOLDER_URL}/posts/${postId}`);\n\t\t\tconst post = await response.json();\n\t\t\tcache.set(postId, post);\n\t\t\treturn post;\n\t\t}\n\t\tasync function getAllWithPagination(\n\t\t\tlimit: number,\n\t\t\tpage: number,\n\t\t): Promise<Post[]> {\n", "\t\tconst offset = (page - 1) * limit;\n\t\t\tconst response = await fetch(\n\t\t\t\t`${JSONPLACEHOLDER_URL}/posts?_start=${offset}&_limit=${limit}`,\n\t\t\t);\n\t\t\tconst posts = await response.json();\n\t\t\treturn posts;\n\t\t}\n\t\tasync function getAll(): Promise<Post[]> {\n\t\t\tif (cache.size > 0) {\n\t\t\t\treturn Array.from(cache.values());\n", "\t\t}\n\t\t\tconst response = await fetch(`${JSONPLACEHOLDER_URL}/posts`);\n\t\t\tconst posts = await response.json();\n\t\t\tposts.forEach((post: Post) => cache.set(post.id, post));\n\t\t\treturn posts;\n\t\t}\n\t\tasync function getByUser(userId: number): Promise<Post[]> {\n\t\t\tif (cache.size > 0) {\n\t\t\t\treturn Array.from(cache.values()).filter(post => post.userId === userId);\n\t\t\t}\n", "\t\tconst response = await fetch(\n\t\t\t\t`${JSONPLACEHOLDER_URL}/users/${userId}/posts`,\n\t\t\t);\n\t\t\tconst posts = await response.json();\n\t\t\tposts.forEach((post: Post) => cache.set(post.id, post));\n\t\t\treturn posts;\n\t\t}\n\t\tasync function create(post: PostDataCreate): Promise<PostDataResponse> {\n\t\t\tconst { title, body, userId } = post;\n\t\t\tconst response = await fetch(`${JSONPLACEHOLDER_URL}/posts`, {\n", "\t\t\tmethod: 'POST',\n\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\ttitle,\n\t\t\t\t\tbody,\n\t\t\t\t\tuserId,\n\t\t\t\t}),\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-type': 'application/json; charset=UTF-8',\n\t\t\t\t},\n\t\t\t});\n", "\t\tconst createdPost = await response.json();\n\t\t\treturn createdPost;\n\t\t}\n\t\treturn {\n\t\t\tcreate,\n\t\t\tget,\n\t\t\tgetAllWithPagination,\n\t\t\tgetAll,\n\t\t\tgetByUser,\n\t\t};\n", "}\n"]}
{"filename": "src/modules/comments/application/get/getCommentById.ts", "chunked_list": ["import { Comment } from '../../domain/Comment';\n\timport { CommentRepository } from '../../domain/CommentRepository';\n\texport function getCommentById(commentRepository: CommentRepository) {\n\t\treturn async (id: number): Promise<Comment | undefined> => {\n\t\t\treturn await commentRepository.get(id);\n\t\t};\n\t}\n"]}
{"filename": "src/modules/comments/application/get-all/getAllCommentsByPost.ts", "chunked_list": ["import { Comment } from '../../domain/Comment';\n\timport { CommentRepository } from '../../domain/CommentRepository';\n\texport function getAllCommentsByPost(commentRepository: CommentRepository) {\n\t\treturn async (postId: number): Promise<Comment[]> => {\n\t\t\treturn await commentRepository.getAllByPost(postId);\n\t\t};\n\t}\n"]}
{"filename": "src/modules/comments/application/get-all/getAllComments.ts", "chunked_list": ["import { Comment } from '../../domain/Comment';\n\timport { CommentRepository } from '../../domain/CommentRepository';\n\texport function getAllComments(commentRepository: CommentRepository) {\n\t\treturn async (): Promise<Comment[]> => {\n\t\t\treturn await commentRepository.getAll();\n\t\t};\n\t}\n"]}
{"filename": "src/modules/comments/application/get-all/getAllCommentsByUser.ts", "chunked_list": ["import { Comment } from '../../domain/Comment';\n\timport { CommentRepository } from '../../domain/CommentRepository';\n\texport function getAllCommentsByUser(commentRepository: CommentRepository) {\n\t\treturn async (userId: number): Promise<Comment[]> => {\n\t\t\treturn await commentRepository.getAllByUser(userId);\n\t\t};\n\t}\n"]}
{"filename": "src/modules/comments/domain/Comment.ts", "chunked_list": ["export interface Comment {\n\t\tpostId: number;\n\t\tid: number;\n\t\tname: string;\n\t\temail: string;\n\t\tbody: string;\n\t}\n"]}
{"filename": "src/modules/comments/domain/CommentRepository.ts", "chunked_list": ["import { Comment } from './Comment';\n\texport interface CommentRepository {\n\t\tgetAllByPost: (postId: number) => Promise<Comment[]>;\n\t\tgetAllByUser: (userId: number) => Promise<Comment[]>;\n\t\tgetAll: () => Promise<Comment[]>;\n\t\tget: (commentId: number) => Promise<Comment | undefined>;\n\t}\n"]}
{"filename": "src/modules/comments/infra/ApiCommentRepository.ts", "chunked_list": ["import { Comment } from '../domain/Comment';\n\timport { CommentRepository } from '../domain/CommentRepository';\n\tconst JSONPLACEHOLDER_URL = 'https://jsonplaceholder.typicode.com';\n\texport function createApiCommentRepository(): CommentRepository {\n\t\treturn {\n\t\t\tget,\n\t\t\tgetAll,\n\t\t\tgetAllByPost,\n\t\t\tgetAllByUser,\n\t\t};\n", "}\n\tasync function get(commentId: number): Promise<Comment> {\n\t\tconst response = await fetch(`${JSONPLACEHOLDER_URL}/comments/${commentId}`);\n\t\tconst comment = (await response.json()) as Promise<Comment>;\n\t\treturn comment;\n\t}\n\tasync function getAll(): Promise<Comment[]> {\n\t\tconst response = await fetch(`${JSONPLACEHOLDER_URL}/comments`);\n\t\tconst comments = await response.json();\n\t\treturn comments;\n", "}\n\tasync function getAllByPost(postId: number) {\n\t\tconst response = await fetch(\n\t\t\t`${JSONPLACEHOLDER_URL}/posts/${postId}/comments`,\n\t\t);\n\t\tconst comments = await response.json();\n\t\treturn comments;\n\t}\n\tasync function getAllByUser(userId: number) {\n\t\tconst response = await fetch(\n", "\t\t`${JSONPLACEHOLDER_URL}/users/${userId}/comments`,\n\t\t);\n\t\tconst comments = await response.json();\n\t\treturn comments;\n\t}\n"]}
