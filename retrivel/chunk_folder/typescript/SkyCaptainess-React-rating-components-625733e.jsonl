{"filename": "playwright-ct.config.ts", "chunked_list": ["import { devices, PlaywrightTestConfig } from '@playwright/experimental-ct-react'\n\timport react from '@vitejs/plugin-react'\n\tconst reporterOutputDir = process.env.IS_RTL ? 'playwright-rtl-report' : 'playwright-report'\n\tconst config: PlaywrightTestConfig = {\n\t   testDir: './tests/ct',\n\t   timeout: 30 * 1000,\n\t   fullyParallel: false,\n\t   reporter: [['html', { outputFolder: reporterOutputDir }]],\n\t   use: {\n\t      trace: 'on-first-retry',\n", "      ctViteConfig: {\n\t         define: {\n\t            __DEV__: true,\n\t         },\n\t         // @ts-ignore - \"\"\n\t         plugins: [react()],\n\t      },\n\t   },\n\t   projects: [\n\t      {\n", "         name: 'chromium',\n\t         use: {\n\t            ...devices['Desktop Chrome'],\n\t         },\n\t      },\n\t      {\n\t         name: 'firefox',\n\t         use: {\n\t            ...devices['Desktop Firefox'],\n\t         },\n", "      },\n\t      {\n\t         name: 'webkit',\n\t         use: {\n\t            ...devices['Desktop Safari'],\n\t         },\n\t      },\n\t      {\n\t         name: 'Mobile Chrome',\n\t         use: {\n", "            ...devices['Pixel 4a (5G)'],\n\t            ...devices['Pixel 4a (5G) landscape'],\n\t         },\n\t      },\n\t      {\n\t         name: 'Mobile Safari',\n\t         use: {\n\t            ...devices['iPhone 11'],\n\t            ...devices['iPhone 11 landscape'],\n\t         },\n", "      },\n\t   ],\n\t}\n\texport default config\n"]}
{"filename": "vite.config.ts", "chunked_list": ["import { defineConfig } from 'vite'\n\timport react from '@vitejs/plugin-react'\n\timport terser from '@rollup/plugin-terser'\n\timport Package from './package.json'\n\tconst vitestOptions = {\n\t   test: {\n\t      globals: true,\n\t      environment: 'jsdom',\n\t      setupFiles: './tests/dom/setupTests.ts',\n\t      exclude: ['**/vite/**', '**/node_modules/**', '**/dist/**', '**/ct/**'],\n", "   },\n\t}\n\texport default defineConfig(({ command }) => ({\n\t   ...vitestOptions,\n\t   define: {\n\t      __DEV__: command !== 'build',\n\t   },\n\t   build: {\n\t      minify: 'terser',\n\t      lib: {\n", "         name: Package.name,\n\t         entry: 'src/index.ts',\n\t         formats: ['es', 'cjs'],\n\t         fileName: 'index',\n\t      },\n\t      rollupOptions: {\n\t         external: ['react', 'react/jsx-runtime'],\n\t         output: {\n\t            globals: {\n\t               react: 'React',\n", "               'react/jsx-runtime': 'React',\n\t            },\n\t         },\n\t         plugins: [\n\t            terser({\n\t               compress: {\n\t                  defaults: true,\n\t                  drop_console: false,\n\t               },\n\t            }),\n", "         ],\n\t      },\n\t   },\n\t   plugins: [react()],\n\t}))\n"]}
{"filename": "vite/vite-env.d.ts", "chunked_list": ["/// <reference types=\"vite/client\" />\n\tdeclare const __DEV__: boolean\n"]}
{"filename": "tests/dom/testUtils.ts", "chunked_list": ["import { ThinStar } from '../../src/Shapes'\n\timport { useState } from 'react'\n\timport { ItemStyles } from '../../src/exportedTypes'\n\texport { render, screen } from '@testing-library/react'\n\timport { StickerStar } from '../../src/Shapes'\n\texport const GROUP_ID = 'rating'\n\texport const CHILD_RESET_ID = 'rating-reset'\n\texport const CHILD_ID_1 = 'rating-child-1'\n\texport const CHILD_ID_2 = 'rating-child-2'\n\texport const CHILD_ID_3 = 'rating-child-3'\n", "export const CHILD_ID_4 = 'rating-child-4'\n\texport const CHILD_ID_5 = 'rating-child-5'\n\texport const SVGCHILD_ID_1 = 'rating-child-svg-1'\n\texport const SVGCHILD_ID_2 = 'rating-child-svg-2'\n\texport const SVGCHILD_ID_3 = 'rating-child-svg-3'\n\texport const SVGCHILD_ID_4 = 'rating-child-svg-4'\n\texport const SVGCHILD_ID_5 = 'rating-child-svg-5'\n\texport const childArr = [CHILD_ID_1, CHILD_ID_2, CHILD_ID_3, CHILD_ID_4, CHILD_ID_5]\n\texport const itemStyles: ItemStyles = {\n\t   itemShapes: ThinStar,\n", "}\n\texport const useOnChange = (initialValue: number) => {\n\t   const [ratingValue, setRatingValue] = useState(initialValue)\n\t   return { ratingValue, setRatingValue }\n\t}\n\texport const arrayColorStyles: ItemStyles = {\n\t   itemShapes: StickerStar,\n\t   activeFillColor: ['#FEE2E2', '#FFEDD5', '#FEF9C3', '#ECFCCB', '#D1FAE5'],\n\t   activeBoxColor: ['#DA1600', '#DB711A', '#DCB000', '#61BB00', '#009664'],\n\t   activeBoxBorderColor: ['#C41400', '#D05E00', '#CCA300', '#498D00', '#00724C'],\n", "   activeStrokeColor: ['#C41400', '#D05E00', '#CCA300', '#498D00', '#00724C'],\n\t}\n"]}
{"filename": "tests/dom/setupTests.ts", "chunked_list": ["import { vi } from 'vitest'\n\timport { cleanup } from '@testing-library/react'\n\timport matchers from '@testing-library/jest-dom/matchers'\n\timport '@testing-library/jest-dom'\n\texpect.extend(matchers)\n\tbeforeEach(() => {\n\t   vi.spyOn(console, 'error').mockImplementation(() => undefined)\n\t   // @ts-expect-error - getBBox\n\t   window.SVGElement.prototype.getBBox = () => ({\n\t      x: 0,\n", "      y: 0,\n\t      width: 0,\n\t      height: 0,\n\t   })\n\t})\n\tafterEach(() => {\n\t   // @ts-expect-error - getBBox\n\t   delete window.SVGElement.prototype.getBBox\n\t   cleanup()\n\t})\n"]}
{"filename": "tests/dom/setupTests.d.ts", "chunked_list": ["import type { TestingLibraryMatchers } from '@testing-library/jest-dom/matchers'\n\tinterface SVGElement {\n\t   getBBox?: () => void\n\t}\n\tdeclare global {\n\t   // eslint-disable-next-line @typescript-eslint/no-namespace\n\t   namespace Vi {\n\t      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t      type Assertion<T = any> = TestingLibraryMatchers<T, void>\n\t   }\n", "}\n"]}
{"filename": "tests/ct/testUtils.ts", "chunked_list": ["import { expect } from '@playwright/experimental-ct-react'\n\timport { Locator, Page } from '@playwright/test'\n\t/** Copy-pasting it as it is not exported by playwright */\n\texport interface MountResult extends Locator {\n\t   unmount: () => Promise<void>\n\t   rerender?: (component: JSX.Element) => Promise<void>\n\t}\n\texport const groupTestId = 'rating'\n\texport const firstButtonId = 'id=first_button'\n\texport const secondButtonId = 'id=second_button'\n", "export const resetTestId = 'data-testid=rating-reset'\n\texport const nextArrow = process.env.IS_RTL ? 'ArrowLeft' : 'ArrowRight'\n\texport const childTestIds = [\n\t   'data-testid=rating-child-1',\n\t   'data-testid=rating-child-2',\n\t   'data-testid=rating-child-3',\n\t   'data-testid=rating-child-4',\n\t   'data-testid=rating-child-5',\n\t]\n\texport function getRandomInt(min: number, max: number) {\n", "   min = Math.ceil(min)\n\t   max = Math.floor(max)\n\t   return Math.floor(Math.random() * (max - min) + min)\n\t}\n\texport async function setRTL(page: Page) {\n\t   if (process.env.IS_RTL) {\n\t      await page.addScriptTag({\n\t         content: \"document.body.setAttribute('dir', 'rtl')\",\n\t      })\n\t   }\n", "}\n\texport async function pressTab(page: Page, browserName: string) {\n\t   if (browserName === 'webkit') {\n\t      await page.keyboard.press('Alt+Tab')\n\t   } else {\n\t      await page.keyboard.press('Tab')\n\t   }\n\t}\n\texport async function pressShiftTab(page: Page, browserName: string) {\n\t   if (browserName === 'webkit') {\n", "      await page.keyboard.press('Alt+Shift+Tab')\n\t   } else {\n\t      await page.keyboard.press('Shift+Tab')\n\t   }\n\t}\n\texport async function expectToBeTheOnlyFocusable(result: MountResult, locatorId: string) {\n\t   await expect(result.locator(locatorId)).toHaveAttribute('tabindex', '0')\n\t   const notFocusedChild = childTestIds.filter((childName) => childName !== locatorId)\n\t   for await (const childName of notFocusedChild) {\n\t      await expect(result.locator(childName)).toHaveAttribute('tabindex', '-1')\n", "   }\n\t}\n\texport async function expectToBeTheOnlyChecked(result: MountResult, locatorId: string) {\n\t   await expect(result.locator(locatorId)).toBeChecked()\n\t   const notFocusedChild = childTestIds.filter((childName) => childName !== locatorId)\n\t   for await (const childName of notFocusedChild) {\n\t      await expect(result.locator(childName)).not.toBeChecked()\n\t   }\n\t}\n\texport async function expectNoneToBeChecked(result: MountResult) {\n", "   for await (const childName of childTestIds) {\n\t      await expect(result.locator(childName)).not.toBeChecked()\n\t   }\n\t}\n\texport async function tabNavigateToRating(page: Page, browserName: string) {\n\t   await pressTab(page, browserName)\n\t   await pressTab(page, browserName)\n\t}\n"]}
{"filename": "tests/unit/getActiveClassNames.test.ts", "chunked_list": ["import { getActiveClassNames } from '../../src/getActiveClassNames'\n\timport { CSSClassName } from '../../src/internalTypes'\n\tdescribe('getActiveClassNames returns proper array of active classes', () => {\n\t   const items = 5\n\t   const X: CSSClassName = 'rr--on'\n\t   const _: CSSClassName = 'rr--off'\n\t   const Test1 = `If highlightOnlySelected is true, it should return an array\n\twith the length equal to the rating items, containing the active class only\n\tat the current selected index`\n\t   test(Test1, () => {\n", "      expect(getActiveClassNames(true, items, 0)).toStrictEqual([X, _, _, _, _])\n\t      expect(getActiveClassNames(true, items, 1)).toStrictEqual([_, X, _, _, _])\n\t      expect(getActiveClassNames(true, items, 2)).toStrictEqual([_, _, X, _, _])\n\t      expect(getActiveClassNames(true, items, 3)).toStrictEqual([_, _, _, X, _])\n\t      expect(getActiveClassNames(true, items, 4)).toStrictEqual([_, _, _, _, X])\n\t   })\n\t   const Test2 = `If highlightOnlySelected is false, it should return an array\n\twith the length equal to the rating items, containing the active class\n\tat the current selected index and any previous index`\n\t   test(Test2, () => {\n", "      expect(getActiveClassNames(false, items, 0)).toStrictEqual([X, _, _, _, _])\n\t      expect(getActiveClassNames(false, items, 1)).toStrictEqual([X, X, _, _, _])\n\t      expect(getActiveClassNames(false, items, 2)).toStrictEqual([X, X, X, _, _])\n\t      expect(getActiveClassNames(false, items, 3)).toStrictEqual([X, X, X, X, _])\n\t      expect(getActiveClassNames(false, items, 4)).toStrictEqual([X, X, X, X, X])\n\t   })\n\t})\n"]}
{"filename": "tests/unit/getTabIndex.test.ts", "chunked_list": ["import { getTabIndex } from '../../src/getTabIndex'\n\tdescribe('getTabIndex returns the updated tabIndex array based on currentRatingIndex', () => {\n\t   const items = 5\n\t   test('Should return [0, -1, -1, -1, -1 if currentRatingIndex is 0 or -1', () => {\n\t      expect(getTabIndex(items, -1)).toStrictEqual([0, -1, -1, -1, -1])\n\t      expect(getTabIndex(items, 0)).toStrictEqual([0, -1, -1, -1, -1])\n\t   })\n\t   test('Should return [-1, 0, -1, -1, -1 if currentRatingIndex is 1 and so on...', () => {\n\t      expect(getTabIndex(items, 1)).toStrictEqual([-1, 0, -1, -1, -1])\n\t      expect(getTabIndex(items, 2)).toStrictEqual([-1, -1, 0, -1, -1])\n", "      expect(getTabIndex(items, 3)).toStrictEqual([-1, -1, -1, 0, -1])\n\t      expect(getTabIndex(items, 4)).toStrictEqual([-1, -1, -1, -1, 0])\n\t   })\n\t})\n"]}
{"filename": "tests/unit/getIntersectionIndex.test.ts", "chunked_list": ["import { getIntersectionIndex } from '../../src/utils'\n\tconst ratingValues = [1, 2, 3, 4, 5]\n\tconst Test = `We try to round the value to the nearest half-integer.\n\tIf the result is an integer (not enough for half-fill),\n\tit should return the index of the (rounded) rating value. If the final\n\tresult is an half-integer, it should return the next integer index.`\n\ttest(Test, () => {\n\t   expect(getIntersectionIndex(ratingValues, 1.23)).toBe(0)\n\t   expect(getIntersectionIndex(ratingValues, 1.5)).toBe(1)\n\t   expect(getIntersectionIndex(ratingValues, 2.23)).toBe(1)\n", "   expect(getIntersectionIndex(ratingValues, 2.55)).toBe(2)\n\t   expect(getIntersectionIndex(ratingValues, 3)).toBe(2)\n\t   expect(getIntersectionIndex(ratingValues, 3.5)).toBe(3)\n\t})\n"]}
{"filename": "tests/unit/getHFClassNames.test.ts", "chunked_list": ["import { getHFClassNames } from '../../src/getHFClassNames'\n\timport { CSSClassName } from '../../src/internalTypes'\n\tdescribe('getHFClassNames returns classNames for box and svg', () => {\n\t   const items = 5\n\t   const Test1 = `It should return an array, whose value at the intersectionIndex\n\thas a special className if halfFillMode equals to \"box\"`\n\t   const X: CSSClassName = 'rr--hf-box-int'\n\t   const I: CSSClassName = 'rr--hf-box-on'\n\t   const O: CSSClassName = 'rr--hf-box-off'\n\t   test(Test1, () => {\n", "      expect(getHFClassNames(0.4, items, 'box')).toStrictEqual([X, O, O, O, O])\n\t      expect(getHFClassNames(1.5, items, 'box')).toStrictEqual([I, X, O, O, O])\n\t      expect(getHFClassNames(2.33, items, 'box')).toStrictEqual([I, I, X, O, O])\n\t      expect(getHFClassNames(3.33, items, 'box')).toStrictEqual([I, I, I, X, O])\n\t      expect(getHFClassNames(4.33, items, 'box')).toStrictEqual([I, I, I, I, X])\n\t   })\n\t   const Test2 = `It should return an array, whose value at the intersectionIndex and\n\tall values before have an active className if halfFillMode equals to \"svg\"`\n\t   const ON: CSSClassName = 'rr--hf-svg-on'\n\t   const _: CSSClassName = 'rr--hf-svg-off'\n", "   test(Test2, () => {\n\t      expect(getHFClassNames(0.41, items, 'svg')).toStrictEqual([ON, _, _, _, _])\n\t      expect(getHFClassNames(1.51, items, 'svg')).toStrictEqual([ON, ON, _, _, _])\n\t      expect(getHFClassNames(2.33, items, 'svg')).toStrictEqual([ON, ON, ON, _, _])\n\t      expect(getHFClassNames(3.33, items, 'svg')).toStrictEqual([ON, ON, ON, ON, _])\n\t      expect(getHFClassNames(4.33, items, 'svg')).toStrictEqual([ON, ON, ON, ON, ON])\n\t   })\n\t})\n"]}
{"filename": "tests/unit/getColors.test.ts", "chunked_list": ["import { getColors } from '../../src/getColors'\n\tdescribe('getColors returns proper arrayColors and staticColors objects', () => {\n\t   const Test1 = 'Should return an object including only properties with string values'\n\t   const sourceObject = {\n\t      activeFillColor: 'transparent',\n\t      activeStrokeColor: undefined,\n\t      activeBoxColor: ['x', 'a', 'f', undefined, 0],\n\t      activeBoxBorderColor: 3,\n\t      inactiveFillColor: 'green',\n\t      inactiveStrokeColor: '#FFFFFF',\n", "      inactiveBoxColor: 'red',\n\t      inactiveBoxBorderColor: undefined,\n\t   }\n\t   const expectedObject = {\n\t      arrayColors: {\n\t         activeBoxColor: ['x', 'a', 'f'],\n\t      },\n\t      staticColors: {\n\t         activeFillColor: 'transparent',\n\t         inactiveBoxColor: 'red',\n", "         inactiveFillColor: 'green',\n\t         inactiveStrokeColor: '#FFFFFF',\n\t      },\n\t   }\n\t   test(Test1, () => {\n\t      expect(getColors(sourceObject)).toStrictEqual(expectedObject)\n\t   })\n\t   const Test2 = 'Should never include non-array properties in arrayColors'\n\t   const sourceObject2 = {\n\t      activeBoxColor: ['x', 'a', 'f', undefined, 0],\n", "      inactiveFillColor: ['green', 'red', 'blue'],\n\t      inactiveStrokeColor: '#FFFFFF',\n\t   }\n\t   const expectedObject2 = {\n\t      arrayColors: {\n\t         activeBoxColor: ['x', 'a', 'f'],\n\t      },\n\t      staticColors: {\n\t         inactiveStrokeColor: '#FFFFFF',\n\t      },\n", "   }\n\t   test(Test2, () => {\n\t      expect(getColors(sourceObject2)).toStrictEqual(expectedObject2)\n\t   })\n\t   const Test3 = 'Should return an empty object for arrayColors if no colors are provided as array'\n\t   const sourceObject3 = {\n\t      activeFillColor: '#ffb23f',\n\t      activeBoxColor: 'red',\n\t      activeBoxBorderColor: 'blue',\n\t      activeStrokeColor: '#e17b21',\n", "      inactiveFillColor: '#FFF7ED',\n\t      inactiveStrokeColor: '#eda76a',\n\t      inactiveBoxColor: 'green',\n\t      inactiveBoxBorderColor: 'aliceblue',\n\t   }\n\t   const expectedObject3 = {\n\t      arrayColors: {},\n\t      staticColors: {\n\t         ...sourceObject3,\n\t      },\n", "   }\n\t   test(Test3, () => {\n\t      expect(getColors(sourceObject3)).toStrictEqual(expectedObject3)\n\t   })\n\t})\n"]}
{"filename": "tests/unit/getDynamicCssVars.test.ts", "chunked_list": ["import { getDynamicCssVars } from '../../src/getDynamicCssVars'\n\timport { CSSVariables, RequireAtLeastOne, ValidArrayColors } from '../../src/internalTypes'\n\tdescribe('getDynamicCssVars returns only CSS vars that user actually needs', () => {\n\t   const Test1 = `If highlightOnlySelected is true and the current rating is 3,\n\tit should return an array of the same length containing active colors only at\n\tthe current rating index`\n\t   const activeColors1 = ['#c41400', '#d05e00', '#cca300', '#498d00', '#00724c']\n\t   const activeColors2 = ['#da1600', '#db711a', '#dcb000', '#61bb00', '#009664']\n\t   const sourceObject: RequireAtLeastOne<ValidArrayColors> = {\n\t      activeFillColor: activeColors1,\n", "      activeStrokeColor: activeColors2,\n\t      activeBoxColor: activeColors1,\n\t      activeBoxBorderColor: activeColors2,\n\t   }\n\t   const expectedColors: CSSVariables = {\n\t      '--rr--fill-on-color': '#cca300',\n\t      '--rr--stroke-on-color': '#dcb000',\n\t      '--rr--box-on-color': '#cca300',\n\t      '--rr--border-on-color': '#dcb000',\n\t   }\n", "   const expectedArray1: CSSVariables[] = [\n\t      {},\n\t      {},\n\t      {\n\t         ...expectedColors,\n\t      },\n\t   ]\n\t   test(Test1, () => {\n\t      expect(getDynamicCssVars(sourceObject, 2, true)).toStrictEqual(expectedArray1)\n\t   })\n", "   const Test2 = `If highlightOnlySelected is false, it should always return an array of\n\tthe same length filled with the colors of the current selected rating index`\n\t   const expectedArray2: CSSVariables[] = [\n\t      {\n\t         ...expectedColors,\n\t      },\n\t      {\n\t         ...expectedColors,\n\t      },\n\t      {\n", "         ...expectedColors,\n\t      },\n\t   ]\n\t   test(Test2, () => {\n\t      expect(getDynamicCssVars(sourceObject, 2, false)).toStrictEqual(expectedArray2)\n\t   })\n\t})\n"]}
{"filename": "playwright/index.ts", "chunked_list": ["import '../src/styles/utils.css';\n\timport '../src/styles/core.css';\n\timport '../src/styles/colors.css';\n\timport '../src/styles/transitions.css';\n\timport '../src/styles/half-fill.css';\n"]}
{"filename": "src/getStaticClassNames.ts", "chunked_list": ["import { CSSClassName, MaybeEmptyClassName } from './internalTypes'\n\timport {\n\t   Sizes,\n\t   TransitionProps,\n\t   TransitionClasses,\n\t   RadiusClasses,\n\t   GapClasses,\n\t   PaddingClasses,\n\t} from './constants'\n\tconst colorsWith = (transition: CSSClassName): CSSClassName =>\n", "   `${transition} ${TransitionClasses.COLORS}`\n\t/* c8 ignore start */\n\texport function getTransitionClassNames(transitionProp: unknown): MaybeEmptyClassName {\n\t   switch (transitionProp) {\n\t      case TransitionProps.ZOOM:\n\t         return colorsWith(TransitionClasses.ZOOM)\n\t      case TransitionProps.POSITION:\n\t         return colorsWith(TransitionClasses.POSITION)\n\t      case TransitionProps.OPACITY:\n\t         return colorsWith(TransitionClasses.OPACITY)\n", "      case TransitionProps.COLORS:\n\t         return TransitionClasses.COLORS\n\t      default:\n\t         return ''\n\t   }\n\t}\n\t/* c8 ignore stop */\n\t/* c8 ignore start */\n\texport function getRadiusClassName(radiusProp: unknown): MaybeEmptyClassName {\n\t   switch (radiusProp) {\n", "      case Sizes.SMALL:\n\t         return RadiusClasses.SMALL\n\t      case Sizes.MEDIUM:\n\t         return RadiusClasses.MEDIUM\n\t      case Sizes.LARGE:\n\t         return RadiusClasses.LARGE\n\t      case Sizes.FULL:\n\t         return RadiusClasses.FULL\n\t      default:\n\t         return ''\n", "   }\n\t}\n\t/* c8 ignore stop */\n\t/* c8 ignore start */\n\texport function getGapClassName(gapProp: unknown): MaybeEmptyClassName {\n\t   switch (gapProp) {\n\t      case Sizes.SMALL:\n\t         return GapClasses.SMALL\n\t      case Sizes.MEDIUM:\n\t         return GapClasses.MEDIUM\n", "      case Sizes.LARGE:\n\t         return GapClasses.LARGE\n\t      default:\n\t         return ''\n\t   }\n\t}\n\t/* c8 ignore stop */\n\t/* c8 ignore start */\n\texport function getPaddingClassName(paddingProp: unknown): MaybeEmptyClassName {\n\t   switch (paddingProp) {\n", "      case Sizes.SMALL:\n\t         return PaddingClasses.SMALL\n\t      case Sizes.MEDIUM:\n\t         return PaddingClasses.MEDIUM\n\t      case Sizes.LARGE:\n\t         return PaddingClasses.LARGE\n\t      default:\n\t         return ''\n\t   }\n\t}\n", "/* c8 ignore stop */\n"]}
{"filename": "src/exportedTypes.ts", "chunked_list": ["import {\n\t   CSSProperties,\n\t   ForwardRefExoticComponent,\n\t   RefAttributes,\n\t   Dispatch,\n\t   SetStateAction,\n\t} from 'react'\n\texport type MaybeArrayColors = {\n\t   /** Active fill color of the SVG, it can be an array of colors in ascending order. */\n\t   activeFillColor?: string | string[]\n", "   /** Active stroke color of the SVG, it can be an array of colors in ascending order. */\n\t   activeStrokeColor?: string | string[]\n\t   /** Active background color of the SVG bounding box, it can be an array of colors in ascending order. */\n\t   activeBoxColor?: string | string[]\n\t   /** Active border color of the SVG bounding box, it can be an array of colors in ascending order. */\n\t   activeBoxBorderColor?: string | string[]\n\t}\n\texport type NonArrayColors = {\n\t   /** Inactive fill color of the SVG. */\n\t   inactiveFillColor?: string\n", "   /** Inactive stroke color of the SVG. */\n\t   inactiveStrokeColor?: string\n\t   /** Inactive background color of the SVG bounding box. */\n\t   inactiveBoxColor?: string\n\t   /** Inactive border color of the SVG bounding box. */\n\t   inactiveBoxBorderColor?: string\n\t}\n\texport type Colors = MaybeArrayColors & NonArrayColors\n\t/** Custom shapes and colors, visit https://github.com/smastrom/react-rating for more info. */\n\texport type ItemStyles = Colors & {\n", "   /** JSX element to render the inner shapes of the SVG.\n\t    * Visit https://github.com/smastrom/react-rating#how-to-create-itemshapes-elements for more info. */\n\t   itemShapes: JSX.Element | JSX.Element[]\n\t   /** Stroke width of the SVG, expressed in viewBox user coordinate's unit size. */\n\t   itemStrokeWidth?: number\n\t   /** Border width of the SVG bounding box, expressed with an integer representing the pixels. */\n\t   boxBorderWidth?: number\n\t}\n\texport type Orientation = 'horizontal' | 'vertical'\n\texport type Sizes = 'none' | 'small' | 'medium' | 'large' | 'full'\n", "export type Spacings = Omit<Sizes, 'full'>\n\texport type HF = 'svg' | 'box'\n\texport type Transitions = 'none' | 'zoom' | 'position' | 'opacity' | 'colors'\n\texport type SharedProps = {\n\t   /** An integer from 0 to items. It can be a float if readOnly is true. */\n\t   value: number\n\t   /** Number of rating items to display. */\n\t   items?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10\n\t   /** Whether or not to render an accessible image element. */\n\t   readOnly?: boolean\n", "   /** Whether or not to highlight only the selected rating item. */\n\t   highlightOnlySelected?: boolean\n\t   /** Orientation of the rating items. */\n\t   orientation?: Orientation\n\t   /** Responsive padding of each rating item. */\n\t   spaceInside?: Spacings\n\t   /** Responsive gap between rating items. */\n\t   spaceBetween?: Spacings\n\t   /** Radius of each rating item */\n\t   radius?: Sizes\n", "   /** Custom shapes and colors, visit https://github.com/smastrom/react-rating for more info. */\n\t   itemStyles?: ItemStyles\n\t   id?: string\n\t   className?: string\n\t   style?: CSSProperties\n\t}\n\texport type ReadOnlyProps = {\n\t   /** Whether to half-fill the SVG or the box. */\n\t   halfFillMode?: HF\n\t}\n", "export type RatingChange =\n\t   | Dispatch<SetStateAction<number>>\n\t   | ((selectedValue: number) => void | Promise<void>)\n\texport type HoverChange = (hoveredValue: number) => void | (() => void)\n\ttype FocusEvent = (event?: FocusEvent) => void\n\texport type InputProps = {\n\t   /** Setter or custom callback to update the rating. */\n\t   onChange?: RatingChange\n\t   /** Callback to execute when entering/leaving the rating items. */\n\t   onHoverChange?: HoverChange\n", "   onBlur?: FocusEvent\n\t   onFocus?: FocusEvent\n\t   /** Whether or not to disable the radio group. */\n\t   isDisabled?: boolean\n\t   /**\n\t    * @deprecated Since version 1.2.0. Please use isRequired prop instead.\n\t    */\n\t   resetOnSecondClick?: boolean\n\t   /** Transition to apply when hovering/selecting. */\n\t   transition?: Transitions\n", "   /** Whether or not to tell assistive technologies that rating is required. */\n\t   isRequired?: boolean\n\t   /** Accessible label of the rating group / image. */\n\t   invisibleLabel?: string\n\t   /** Accessible labels of each each rating item. */\n\t   invisibleItemLabels?: string[]\n\t   /** Id of the element used as rating group label. Takes precedence over invisibleLabel. */\n\t   visibleLabelId?: string\n\t   /** Ids of the elements used as labels for each rating item. Takes precedence over invisibleItemLabels. */\n\t   visibleItemLabelIds?: string[]\n", "   /** Accessible label for the invisible reset radio. Effective if `isRequired` is set to **false**. */\n\t   resetLabel?: string\n\t}\n\texport type RatingProps = SharedProps & ReadOnlyProps & InputProps\n\texport declare const Rating: ForwardRefExoticComponent<RatingProps & RefAttributes<HTMLDivElement>>\n\texport declare const Star: JSX.Element\n\texport declare const ThinStar: JSX.Element\n\texport declare const RoundedStar: JSX.Element\n\texport declare const ThinRoundedStar: JSX.Element\n\texport declare const StickerStar: JSX.Element\n", "export declare const Heart: JSX.Element\n"]}
{"filename": "src/setColorCssVars.ts", "chunked_list": ["import { CSSVariables } from './internalTypes'\n\timport { ActiveColorProps, InactiveColorProps, ActiveVars, InactiveVars } from './constants'\n\t/* c8 ignore next */\n\texport function setDyamicCssVars(targetObj: CSSVariables, key: string, value: string) {\n\t   switch (key) {\n\t      case ActiveColorProps.FILL:\n\t         targetObj[ActiveVars.FILL] = value\n\t         return true\n\t      case ActiveColorProps.BOX:\n\t         targetObj[ActiveVars.BOX] = value\n", "         return true\n\t      case ActiveColorProps.BORDER:\n\t         targetObj[ActiveVars.BORDER] = value\n\t         return true\n\t      case ActiveColorProps.STROKE:\n\t         targetObj[ActiveVars.STROKE] = value\n\t         return true\n\t   }\n\t   return false\n\t}\n", "/* c8 ignore next */\n\texport function setColorCssVars(targetObj: CSSVariables, key: string, value: string) {\n\t   const isActive = setDyamicCssVars(targetObj, key, value)\n\t   if (!isActive) {\n\t      switch (key) {\n\t         case InactiveColorProps.FILL:\n\t            targetObj[InactiveVars.FILL] = value\n\t            break\n\t         case InactiveColorProps.BOX:\n\t            targetObj[InactiveVars.BOX] = value\n", "            break\n\t         case InactiveColorProps.BORDER:\n\t            targetObj[InactiveVars.BORDER] = value\n\t            break\n\t         case InactiveColorProps.STROKE:\n\t            targetObj[InactiveVars.STROKE] = value\n\t            break\n\t      }\n\t   }\n\t}\n"]}
{"filename": "src/getStaticCssVars.ts", "chunked_list": ["import { setColorCssVars } from './setColorCssVars'\n\timport { ItemStyles } from './exportedTypes'\n\timport { CSSVariables, StaticColors } from './internalTypes'\n\timport { ItemVars } from './constants'\n\timport { isPositiveNum } from './utils'\n\texport function getStaticCssVars(\n\t   staticColors: StaticColors,\n\t   boxBorderWidth: NonNullable<ItemStyles['boxBorderWidth']>\n\t): CSSVariables {\n\t   const cssVars: CSSVariables = {}\n", "   if (isPositiveNum(boxBorderWidth)) {\n\t      cssVars[ItemVars.BORDER_WIDTH] = `${boxBorderWidth}px`\n\t   }\n\t   const colorsEntries = Object.entries(staticColors)\n\t   if (colorsEntries.length > 0) {\n\t      for (const [key, value] of colorsEntries) {\n\t         setColorCssVars(cssVars, key, value)\n\t      }\n\t   }\n\t   return cssVars\n", "}\n"]}
{"filename": "src/getDynamicCssVars.ts", "chunked_list": ["import { setDyamicCssVars } from './setColorCssVars'\n\timport { NonNullProp, CSSVariables, RequireAtLeastOne, ValidArrayColors } from './internalTypes'\n\texport function getDynamicCssVars(\n\t   arrayColors: RequireAtLeastOne<ValidArrayColors>,\n\t   starIndex: number,\n\t   highlightOnlySelected: NonNullProp<'highlightOnlySelected'>\n\t): CSSVariables[] {\n\t   const arrayStylesVars: CSSVariables = {}\n\t   let cssVars: CSSVariables[]\n\t   for (const [key, color] of Object.entries(arrayColors)) {\n", "      setDyamicCssVars(arrayStylesVars, key, color[starIndex])\n\t   }\n\t   if (highlightOnlySelected) {\n\t      cssVars = Array(starIndex).fill({})\n\t      cssVars.push(arrayStylesVars)\n\t   } else {\n\t      cssVars = Array(starIndex + 1).fill(arrayStylesVars)\n\t   }\n\t   return cssVars\n\t}\n"]}
{"filename": "src/getColors.ts", "chunked_list": ["import { Colors } from './exportedTypes'\n\timport { StaticColors, ValidArrayColors } from './internalTypes'\n\timport { ActiveColorProps } from './constants'\n\tconst validArrayColorKeys: (keyof ValidArrayColors)[] = [\n\t   ActiveColorProps.FILL,\n\t   ActiveColorProps.BOX,\n\t   ActiveColorProps.STROKE,\n\t   ActiveColorProps.BORDER,\n\t]\n\texport function getColors(colorsObj: Colors | object) {\n", "   const allColors = { ...colorsObj }\n\t   const arrayColors: ValidArrayColors = {}\n\t   const colorsEntries = Object.entries(allColors)\n\t   if (colorsEntries.length > 0) {\n\t      for (const [key, value] of colorsEntries) {\n\t         if (!Array.isArray(value) && typeof value !== 'string') {\n\t            delete allColors[key as keyof typeof allColors]\n\t         } else if (Array.isArray(value)) {\n\t            for (const validKey of validArrayColorKeys) {\n\t               if (validKey === key) {\n", "                  const cleanedArrayColors = value.filter((color) => typeof color === 'string')\n\t                  if (cleanedArrayColors.length > 0) {\n\t                     arrayColors[key] = cleanedArrayColors\n\t                     delete allColors[key]\n\t                  }\n\t               } else {\n\t                  delete allColors[key as keyof typeof allColors]\n\t               }\n\t            }\n\t         }\n", "      }\n\t   }\n\t   return { arrayColors, staticColors: allColors as StaticColors }\n\t}\n"]}
{"filename": "src/internalTypes.ts", "chunked_list": ["import { ItemStyles, MaybeArrayColors, NonArrayColors, RatingProps } from './exportedTypes'\n\ttype CSSPrefix = 'rr'\n\texport type CSSVariable = `--${CSSPrefix}--${string}`\n\texport type CSSVariables = {\n\t   [key: CSSVariable]: string\n\t}\n\texport type CSSClassName = `${CSSPrefix}--${string}`\n\texport type TagID = `${CSSPrefix}_${string}`\n\texport type MaybeEmptyClassName = CSSClassName | ''\n\ttype Colors<T> = {\n", "   [key in keyof MaybeArrayColors]: T\n\t}\n\texport type ActiveColorsStrings = Colors<string>\n\texport type ValidArrayColors = Colors<string[]>\n\texport type StaticColors = NonArrayColors & ActiveColorsStrings\n\texport type RequireAtLeastOne<T> = {\n\t   [K in keyof T]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<keyof T, K>>>\n\t}[keyof T]\n\texport type TabIndex = -1 | 0\n\texport type RatingItemProps = NonNullable<Pick<ItemStyles, 'itemShapes'>> & {\n", "   itemStrokeWidth: NonNullable<ItemStyles['itemStrokeWidth']>\n\t   orientation: NonNullProp<'orientation'>\n\t   hasHF: boolean\n\t   testId?: object\n\t}\n\texport type StylesState = {\n\t   staticCssVars: CSSVariables\n\t   dynamicCssVars: CSSVariables[]\n\t   dynamicClassNames: CSSClassName[]\n\t}\n", "export type SvgData = {\n\t   viewBox: string\n\t   translateData: string\n\t}\n\texport type NonNullProp<K extends keyof RatingProps> = NonNullable<RatingProps[`${K}`]>\n\texport type HTMLProps = React.HTMLProps<HTMLDivElement>\n\texport type MouseEvent = React.MouseEvent<HTMLDivElement>\n\texport type FocusEvent = React.FocusEvent<HTMLDivElement>\n\texport type MutableRef = React.MutableRefObject<HTMLDivElement | null>\n"]}
{"filename": "src/defaultItemStyles.ts", "chunked_list": ["import { Star } from './Shapes'\n\timport { ItemStyles } from './exportedTypes'\n\texport const defaultItemStyles: ItemStyles = {\n\t   itemShapes: Star,\n\t   itemStrokeWidth: 2,\n\t   activeFillColor: '#ffb23f',\n\t   inactiveFillColor: '#fff7ed',\n\t   activeStrokeColor: '#e17b21',\n\t   inactiveStrokeColor: '#eda76a',\n\t}\n"]}
{"filename": "src/getErrors.ts", "chunked_list": ["import { isValidElement } from 'react'\n\timport { ItemStyles, RatingProps } from './exportedTypes'\n\timport Package from '../package.json'\n\ttype ErrorObj = {\n\t   shouldRender: boolean\n\t   reason: string\n\t}\n\tconst getErrorReason = (reason: string) =>\n\t   `[${Package.name}] - Nothing's returned from rendering. Reason: ${reason}.`\n\tfunction setErrors(targetObj: ErrorObj, reason: string) {\n", "   targetObj.shouldRender = false\n\t   targetObj.reason = getErrorReason(reason)\n\t   return targetObj\n\t}\n\tconst invalidJSXMsg = 'itemShapes is not a valid JSX element'\n\ttype Props = Pick<RatingProps, 'items'> & Pick<ItemStyles, 'itemShapes'>\n\ttype ParamObj = Required<{\n\t   [Prop in keyof Props]: unknown\n\t}>\n\texport function getErrors({ items, itemShapes }: ParamObj) {\n", "   const errorsObj: ErrorObj = { shouldRender: true, reason: '' }\n\t   if (typeof items !== 'number' || items < 1 || items > 10) {\n\t      return setErrors(errorsObj, 'items is invalid')\n\t   }\n\t   if (!itemShapes) {\n\t      return setErrors(errorsObj, 'itemStyles needs at least the property itemShapes set')\n\t   }\n\t   if (!Array.isArray(itemShapes) && !isValidElement(itemShapes as object | null | undefined)) {\n\t      return setErrors(errorsObj, invalidJSXMsg)\n\t   }\n", "   if (Array.isArray(itemShapes)) {\n\t      if (itemShapes.length !== items) {\n\t         return setErrors(errorsObj, 'itemShapes length mismatch')\n\t      }\n\t      const areValid = (itemShapes as (object | null | undefined)[]).every((svgChildNode) =>\n\t         isValidElement(svgChildNode)\n\t      )\n\t      if (!areValid) {\n\t         return setErrors(errorsObj, invalidJSXMsg)\n\t      }\n", "   }\n\t   return errorsObj\n\t}\n"]}
{"filename": "src/constants.ts", "chunked_list": ["import { CSSClassName, CSSVariable } from './internalTypes'\n\timport {\n\t   Orientation,\n\t   HF,\n\t   Sizes as SizesT,\n\t   Transitions,\n\t   MaybeArrayColors,\n\t   NonArrayColors,\n\t} from './exportedTypes'\n\t/* ClassNames */\n", "type Classes = {\n\t   [key: string]: CSSClassName\n\t}\n\texport const RatingClasses: Classes = {\n\t   GROUP: 'rr--group',\n\t   BOX: 'rr--box',\n\t   SVG: 'rr--svg',\n\t   RESET: 'rr--reset',\n\t   GROUP_RESET: 'rr--focus-reset',\n\t   DEF_50: 'rr--svg-stop-1',\n", "   DEF_100: 'rr--svg-stop-2',\n\t}\n\texport const ActiveClassNames: Classes = {\n\t   ON: 'rr--on',\n\t   OFF: 'rr--off',\n\t}\n\texport const TransitionClasses: Classes = {\n\t   ZOOM: 'rr--fx-zoom',\n\t   POSITION: 'rr--fx-position',\n\t   OPACITY: 'rr--fx-opacity',\n", "   COLORS: 'rr--fx-colors',\n\t}\n\texport const RadiusClasses: Classes = {\n\t   SMALL: 'rr--rx-sm',\n\t   MEDIUM: 'rr--rx-md',\n\t   LARGE: 'rr--rx-lg',\n\t   FULL: 'rr--rx-full',\n\t}\n\texport const GapClasses: Classes = {\n\t   SMALL: 'rr--gap-sm',\n", "   MEDIUM: 'rr--gap-md',\n\t   LARGE: 'rr--gap-lg',\n\t}\n\texport const PaddingClasses: Classes = {\n\t   SMALL: 'rr--space-sm',\n\t   MEDIUM: 'rr--space-md',\n\t   LARGE: 'rr--space-lg',\n\t}\n\texport const CursorClasses: Classes = {\n\t   POINTER: 'rr--pointer',\n", "   DISABLED: 'rr--disabled',\n\t}\n\texport const OrientationClasses: Classes = {\n\t   VERTICAL: 'rr--dir-y',\n\t   HORIZONTAL: 'rr--dir-x',\n\t}\n\texport const HasClasses: Classes = {\n\t   STROKE: 'rr--has-stroke',\n\t   BORDER: 'rr--has-border',\n\t}\n", "export const HFClasses: Classes = {\n\t   BOX_ON: 'rr--hf-box-on',\n\t   BOX_INT: 'rr--hf-box-int',\n\t   BOX_OFF: 'rr--hf-box-off',\n\t   SVG_ON: 'rr--hf-svg-on',\n\t   SVG_OFF: 'rr--hf-svg-off',\n\t}\n\t/* Variables */\n\ttype Variables = {\n\t   [key: string]: CSSVariable\n", "}\n\texport const ActiveVars: Variables = {\n\t   FILL: '--rr--fill-on-color',\n\t   BOX: '--rr--box-on-color',\n\t   BORDER: '--rr--border-on-color',\n\t   STROKE: '--rr--stroke-on-color',\n\t}\n\texport const InactiveVars: Variables = {\n\t   FILL: '--rr--fill-off-color',\n\t   BOX: '--rr--box-off-color',\n", "   BORDER: '--rr--border-off-color',\n\t   STROKE: '--rr--stroke-off-color',\n\t}\n\texport const ItemVars: Variables = {\n\t   BORDER_WIDTH: '--rr--border-width',\n\t}\n\t/* Props */\n\ttype ValuesFromUnion<T> = {\n\t   [key: string]: T\n\t}\n", "export const OrientationProps: ValuesFromUnion<Orientation> = {\n\t   HORIZONTAL: 'horizontal',\n\t   VERTICAL: 'vertical',\n\t}\n\texport const HFProps: ValuesFromUnion<HF> = {\n\t   SVG: 'svg',\n\t   BOX: 'box',\n\t}\n\texport const Sizes: ValuesFromUnion<SizesT> = {\n\t   NONE: 'none',\n", "   SMALL: 'small',\n\t   MEDIUM: 'medium',\n\t   LARGE: 'large',\n\t   FULL: 'full',\n\t}\n\texport const TransitionProps: ValuesFromUnion<Transitions> = {\n\t   NONE: 'none',\n\t   ZOOM: 'zoom',\n\t   POSITION: 'position',\n\t   OPACITY: 'opacity',\n", "   COLORS: 'colors',\n\t}\n\t/* Color Props */\n\ttype ValuesFromKeys<T> = {\n\t   [key: string]: keyof T\n\t}\n\texport const ActiveColorProps: ValuesFromKeys<MaybeArrayColors> = {\n\t   FILL: 'activeFillColor',\n\t   BOX: 'activeBoxColor',\n\t   BORDER: 'activeBoxBorderColor',\n", "   STROKE: 'activeStrokeColor',\n\t}\n\texport const InactiveColorProps: ValuesFromKeys<NonArrayColors> = {\n\t   FILL: 'inactiveFillColor',\n\t   BOX: 'inactiveBoxColor',\n\t   BORDER: 'inactiveBoxBorderColor',\n\t   STROKE: 'inactiveStrokeColor',\n\t}\n"]}
{"filename": "src/getTabIndex.ts", "chunked_list": ["import { TabIndex } from './internalTypes'\n\texport function getTabIndex(items: number, selectedIndex: number, hasReset = false): TabIndex[] {\n\t   return Array.from({ length: items }, (_, index) => {\n\t      if (hasReset && selectedIndex < 0) {\n\t         if (index === items - 1) {\n\t            return 0\n\t         }\n\t         return -1\n\t      }\n\t      if (selectedIndex <= 0) {\n", "         if (index === 0) {\n\t            return 0\n\t         }\n\t         return -1\n\t      }\n\t      if (selectedIndex > 0) {\n\t         if (index === selectedIndex) {\n\t            return 0\n\t         }\n\t         return -1\n", "      }\n\t   }) as TabIndex[]\n\t}\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import { useEffect, useLayoutEffect } from 'react'\n\t// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars\n\texport const noop = (number?: number) => {}\n\texport const isSSR = typeof window === 'undefined'\n\t/* c8 ignore next */\n\texport const useIsomorphicLayoutEffect = isSSR ? useEffect : useLayoutEffect\n\texport const isPositiveNum = (value: unknown) => typeof value === 'number' && value > 0\n\texport const getNumber = (value: unknown) => (isPositiveNum(value) ? (value as number) : 0)\n\texport const toSecondDecimal = (number: number) => Math.round(number * 100) / 100\n\texport const roundToHalf = (number: number) => Math.round(number * 2) / 2\n", "export const getUniqueId = () => (Math.random() + 1).toString(36).substring(7)\n\texport const areNum = (...values: unknown[]) => values.every((value) => typeof value === 'number')\n\texport const getNewPosition = (originalPos: number) =>\n\t   originalPos === 0 ? 0 : toSecondDecimal(originalPos) * -1\n\texport const isGraphicalValueInteger = (ratingValue: number) =>\n\t   Number.isInteger(roundToHalf(ratingValue))\n\texport function getIntersectionIndex(ratingValues: number[], ratingValue: number) {\n\t   const roundedHalf = roundToHalf(ratingValue)\n\t   if (Number.isInteger(roundedHalf)) {\n\t      return ratingValues.indexOf(roundedHalf)\n", "   }\n\t   return Math.floor(roundedHalf)\n\t}\n\texport function isRTLDir(rootElem: HTMLElement) {\n\t   if (rootElem) {\n\t      const userDir = getComputedStyle(rootElem).getPropertyValue('direction')\n\t      return userDir === 'rtl'\n\t   }\n\t   return false\n\t}\n", "/* c8 ignore next */\n\texport const devTestId = __DEV__ ? { 'data-testid': 'rating' } : {}\n\t/* c8 ignore next */\n\texport function getResetTestId() {\n\t   if (__DEV__) {\n\t      return { 'data-testid': `rating-reset` }\n\t   } /* c8 ignore next */\n\t   return {}\n\t}\n\t/* c8 ignore next */\n", "export function getRadioTestIds(childIndex: number) {\n\t   if (__DEV__) {\n\t      return { 'data-testid': `rating-child-${childIndex + 1}` }\n\t   } /* c8 ignore next */\n\t   return {}\n\t}\n\t/* c8 ignore next */\n\texport function getSvgTestIds(childIndex: number) {\n\t   if (__DEV__) {\n\t      return {\n", "         'data-testid': `rating-child-svg-${childIndex + 1}`,\n\t      }\n\t   } /* c8 ignore next */\n\t   return {}\n\t}\n\t/* c8 ignore next */\n\texport function getDefsTestId() {\n\t   if (__DEV__) {\n\t      return {\n\t         'data-testid': 'svg-defs-testid',\n", "      }\n\t   } /* c8 ignore next */\n\t   return {}\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import './styles/core.css'\n\timport './styles/utils.css'\n\timport './styles/colors.css'\n\timport './styles/transitions.css'\n\timport './styles/half-fill.css'\n\texport { Rating } from './Rating'\n\texport { Star, ThinStar, RoundedStar, ThinRoundedStar, StickerStar, Heart } from './Shapes'\n"]}
{"filename": "src/getGroupClassNames.ts", "chunked_list": ["import { RatingProps } from './exportedTypes'\n\timport {\n\t   getGapClassName,\n\t   getPaddingClassName,\n\t   getRadiusClassName,\n\t   getTransitionClassNames,\n\t} from './getStaticClassNames'\n\timport { CSSClassName, MaybeEmptyClassName } from './internalTypes'\n\timport {\n\t   CursorClasses,\n", "   OrientationClasses,\n\t   HasClasses,\n\t   RatingClasses,\n\t   OrientationProps,\n\t   TransitionProps,\n\t} from './constants'\n\ttype ParamObj = Required<\n\t   Pick<\n\t      RatingProps,\n\t      | 'className'\n", "      | 'radius'\n\t      | 'readOnly'\n\t      | 'isDisabled'\n\t      | 'transition'\n\t      | 'orientation'\n\t      | 'spaceBetween'\n\t      | 'spaceInside'\n\t   >\n\t> & {\n\t   isDynamic: boolean\n", "   absoluteBoxBorderWidth: number\n\t   absoluteStrokeWidth: number\n\t}\n\texport function getGroupClassNames({\n\t   className,\n\t   radius,\n\t   readOnly,\n\t   isDisabled,\n\t   isDynamic,\n\t   transition,\n", "   orientation,\n\t   absoluteBoxBorderWidth,\n\t   absoluteStrokeWidth,\n\t   spaceBetween,\n\t   spaceInside,\n\t}: ParamObj) {\n\t   const cursorClassName: MaybeEmptyClassName = isDynamic ? CursorClasses.POINTER : ''\n\t   const gapClassName = getGapClassName(spaceBetween)\n\t   const paddingClassName = getPaddingClassName(spaceInside)\n\t   const disabledClassName: MaybeEmptyClassName =\n", "      !readOnly && isDisabled ? CursorClasses.DISABLED : ''\n\t   const transitionClassName =\n\t      isDynamic && transition !== TransitionProps.NONE ? getTransitionClassNames(transition) : ''\n\t   const orientationClassName: CSSClassName =\n\t      orientation === OrientationProps.VERTICAL\n\t         ? OrientationClasses.VERTICAL\n\t         : OrientationClasses.HORIZONTAL\n\t   const radiusClassName = getRadiusClassName(radius)\n\t   const borderClassName: MaybeEmptyClassName = absoluteBoxBorderWidth > 0 ? HasClasses.BORDER : ''\n\t   const strokeClassName: MaybeEmptyClassName = absoluteStrokeWidth > 0 ? HasClasses.STROKE : ''\n", "   return `${RatingClasses.GROUP} ${orientationClassName} ${strokeClassName} ${borderClassName}\n\t${transitionClassName} ${radiusClassName} ${cursorClassName} ${disabledClassName} ${gapClassName}\n\t${paddingClassName} ${className}`\n\t      .replace(/  +/g, ' ')\n\t      .trimEnd()\n\t}\n"]}
{"filename": "src/getActiveClassNames.ts", "chunked_list": ["import { NonNullProp, CSSClassName } from './internalTypes'\n\timport { ActiveClassNames } from './constants'\n\texport function getActiveClassNames(\n\t   highlightOnlySelectedProp: NonNullProp<'highlightOnlySelected'>,\n\t   items: NonNullProp<'items'>,\n\t   selectedIndex: number\n\t): CSSClassName[] {\n\t   return Array.from({ length: items }, (_, index) => {\n\t      if (!highlightOnlySelectedProp) {\n\t         if (index <= selectedIndex) {\n", "            return ActiveClassNames.ON\n\t         }\n\t         return ActiveClassNames.OFF\n\t      }\n\t      if (index === selectedIndex) {\n\t         return ActiveClassNames.ON\n\t      }\n\t      return ActiveClassNames.OFF\n\t   })\n\t}\n"]}
{"filename": "src/getHFClassNames.ts", "chunked_list": ["import { roundToHalf } from './utils'\n\timport { NonNullProp, CSSClassName } from './internalTypes'\n\timport { HFClasses } from './constants'\n\texport function getHFClassNames(\n\t   ratingValue: NonNullProp<'value'>,\n\t   items: NonNullProp<'items'>,\n\t   absoluteHFMode: NonNullProp<'halfFillMode'>\n\t): CSSClassName[] {\n\t   const intersectionIndex = Math.floor(roundToHalf(ratingValue))\n\t   return Array.from({ length: items }, (_, index) => {\n", "      if (absoluteHFMode === 'box') {\n\t         if (index > intersectionIndex) {\n\t            return HFClasses.BOX_OFF\n\t         }\n\t         if (index === intersectionIndex) {\n\t            return HFClasses.BOX_INT\n\t         }\n\t         return HFClasses.BOX_ON\n\t      }\n\t      if (index > intersectionIndex) {\n", "         return HFClasses.SVG_OFF\n\t      }\n\t      return HFClasses.SVG_ON\n\t   })\n\t}\n"]}
