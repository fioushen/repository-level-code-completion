{"filename": "release.ts", "chunked_list": ["import * as pjson from './package.json'\n\timport * as fsPromise from 'fs/promises'\n\tconsole.log(`updated version to ${pjson.version}`)\n\tconst versionString = `export const VERSION = '${pjson.version}'`\n\tconst fileWrite = async () => {\n\t  await fsPromise.writeFile('./src/lib/version.ts', versionString, {\n\t    flag: 'w',\n\t  })\n\t}\n\tfileWrite()\n"]}
{"filename": "tests/check.test.ts", "chunked_list": ["import { skeetTest } from './jest.setup'\n\ttest('check', () => {\n\t  console.log(skeetTest)\n\t  console.log('OK')\n\t})\n"]}
{"filename": "tests/jest.setup.ts", "chunked_list": ["export const skeetTest = 'test'\n"]}
{"filename": "dist/esm/index.d.ts", "chunked_list": ["export { createDataRef, createFirestoreDataConverter, getCollectionItem as get, addCollectionItem as add, serverTimestamp, createCollectionRef, addMultipleCollectionItems as adds, queryCollectionItems as query, updateCollectionItem as update, deleteCollectionItem as delete, } from './lib';\n\texport { Timestamp, FieldValue } from 'firebase/firestore';\n"]}
{"filename": "dist/esm/utils/time.d.ts", "chunked_list": ["export declare function sleep(ms: number): Promise<unknown>;\n\texport declare const utcNow: (formatType?: number) => string;\n\texport declare const formatTime: (ms: number) => string;\n\texport declare const getTimestamp: () => string;\n"]}
{"filename": "dist/esm/lib/getCollectionItem.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\t/**\n\t * Retrieves a document from Firestore based on the provided document reference.\n\t *\n\t * @param dataRef - The document reference pointing to the desired Firestore document.\n\t *\n\t * @returns The data of the document as an object of type T.\n\t *\n\t * @throws Throws an exception if the document doesn't exist or if there is no data in the document.\n\t *\n", " * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import * as admin from 'firebase-admin'\n\t * import { get } from '@skeet-framework/firestore'\n\t *\n\t * const db = admin.firestore();\n\t *\n\t * async function run() {\n\t *   try {\n", " *     const db = admin.firestore();\n\t *     const path = 'Users'\n\t *     const id = 'user123'\n\t *     const user = await get<User>(db, path, id)\n\t *     console.log(`Retrieved user: ${user.name}, age: ${user.age}`)\n\t *   } catch (error) {\n\t *     console.error(`Error retrieving document: ${error}`)\n\t *   }\n\t * }\n\t *\n", " * run();\n\t * ```\n\t */\n\texport declare const getCollectionItem: <T>(db: firestore.Firestore, collectionPath: string, docId: string) => Promise<T>;\n"]}
{"filename": "dist/esm/lib/deleteCollectionItem.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\t/**\n\t * Deletes a document from the specified collection in Firestore.\n\t *\n\t * @param db - The instance of the Firestore database to use.\n\t * @param collectionPath - The path of the collection containing the document to be deleted.\n\t * @param docId - The ID of the document to be deleted.\n\t *\n\t * @returns A boolean indicating the success of the delete operation.\n\t *\n", " * @throws Throws an exception with an error message if an error occurs.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import * as admin from 'firebase-admin'\n\t * import { delete } from '@skeet-framework/firestore'\n\t *\n\t * const db = admin.firestore();\n\t *\n", " * async function run() {\n\t *   try {\n\t *     const path = 'Users'\n\t *     const docId = '123456'; // Assuming this ID exists in the Users collection.\n\t *     const success = await delete(db, path, docId);\n\t *     if (success) {\n\t *       console.log(`Document with ID ${docId} deleted successfully.`);\n\t *     }\n\t *   } catch (error) {\n\t *     console.error(`Error deleting document: ${error}`);\n", " *   }\n\t * }\n\t *\n\t * run();\n\t * ```\n\t */\n\texport declare const deleteCollectionItem: (db: firestore.Firestore, collectionPath: string, docId: string) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/getFirestoreData.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\texport declare const getFirestoreData: <T>(dataRef: firestore.DocumentReference<T>) => Promise<T>;\n"]}
{"filename": "dist/esm/lib/version.d.ts", "chunked_list": ["export declare const VERSION = \"2.1.1\";\n"]}
{"filename": "dist/esm/lib/createDataRef.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\texport declare const createDataRef: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string) => firestore.DocumentReference<T>;\n"]}
{"filename": "dist/esm/lib/updateCollectionItem.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\t/**\n\t * Updates the specified document in the provided Firestore collection with the given data.\n\t *\n\t * @param db - The instance of the Firestore database to use.\n\t * @param collectionPath - The path of the collection containing the document to be updated.\n\t * @param docId - The ID of the document to be updated.\n\t * @param params - The data to update the document with.\n\t *\n\t * @returns A boolean indicating the success of the update operation.\n", " *\n\t * @throws Throws an exception with an error message if an error occurs.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import { update } from '@skeet-framework/firestore'\n\t *\n\t * const db = firestore();\n\t * const updatedData: firestore.UpdateData<User> = {\n", " *   age: 31\n\t * };\n\t *\n\t * async function run() {\n\t *   try {\n\t *     const path = 'Users'\n\t *     const docId = '123456'; // Assuming this ID exists in the Users collection.\n\t *     const success = await update<User>(db, path, docId, updatedData);\n\t *     if (success) {\n\t *       console.log(`Document with ID ${docId} updated successfully.`);\n", " *     }\n\t *   } catch (error) {\n\t *     console.error(`Error updating document: ${error}`);\n\t *   }\n\t * }\n\t *\n\t * run();\n\t * ```\n\t */\n\texport declare const updateCollectionItem: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string, docId: string, params: firestore.UpdateData<T>) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/createFirestoreDataConverter.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\texport declare const createFirestoreDataConverter: <T extends firestore.DocumentData>() => firestore.FirestoreDataConverter<T>;\n"]}
{"filename": "dist/esm/lib/createCollectionRef.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\timport { DocumentData } from 'firebase/firestore';\n\texport declare const createCollectionRef: <T extends DocumentData>(db: firestore.Firestore, collectionPath: string) => firestore.CollectionReference<T>;\n"]}
{"filename": "dist/esm/lib/addMultipleCollectionItems.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\t/**\n\t * Adds multiple documents to the specified collection in Firestore.\n\t * This function supports batched writes, and if the number of items exceeds the maximum batch size (500),\n\t * it will split the items into multiple batches and write them sequentially.\n\t *\n\t * @param db - The instance of the Firestore database to use.\n\t * @param collectionPath - The path of the collection to which the documents will be added.\n\t * @param items - An array of document data to be added.\n\t *\n", " * @returns An array of WriteResult arrays corresponding to each batch.\n\t *\n\t * @throws Throws an exception with an error message if an error occurs.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import { adds } from '@skeet-framework/firestore'\n\t *\n\t * const db = firestore();\n", " * const users: User[] = [\n\t *   { name: \"John Doe\", age: 30 },\n\t *   { name: \"Jane Smith\", age: 25 },\n\t *   // ... more users ...\n\t * ];\n\t *\n\t * async function run() {\n\t *   try {\n\t *     const path = 'Users'\n\t *     const results = await adds<User>(db, path, users);\n", " *     console.log(`Added ${users.length} users in ${results.length} batches.`);\n\t *   } catch (error) {\n\t *     console.error(`Error adding documents: ${error}`);\n\t *   }\n\t * }\n\t *\n\t * run();\n\t * ```\n\t */\n\texport declare const addMultipleCollectionItems: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string, items: T[]) => Promise<firestore.WriteResult[][]>;\n"]}
{"filename": "dist/esm/lib/index.d.ts", "chunked_list": ["export * from './addCollectionItem';\n\texport * from './createDataRef';\n\texport * from './createFirestoreDataConverter';\n\texport * from './serverTimestamp';\n\texport * from './getCollectionItem';\n\texport * from './createCollectionRef';\n\texport * from './addMultipleCollectionItems';\n\texport * from './queryCollectionItems';\n\texport * from './updateCollectionItem';\n\texport * from './deleteCollectionItem';\n"]}
{"filename": "dist/esm/lib/queryCollectionItems.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\t/**\n\t * Represents a condition for querying Firestore collections.\n\t */\n\ttype QueryCondition = {\n\t    field?: string;\n\t    operator?: firestore.WhereFilterOp;\n\t    value?: any;\n\t    orderDirection?: firestore.OrderByDirection;\n\t    limit?: number;\n", "};\n\t/**\n\t * Queries the specified collection in Firestore based on the provided conditions\n\t * and returns an array of documents that match the conditions.\n\t *\n\t * @param db - The instance of the Firestore database to use.\n\t * @param collectionPath - The path of the collection to be queried.\n\t * @param conditions - An array of conditions to apply to the query.\n\t *\n\t * @returns An array of documents from the collection that match the conditions.\n", " *\n\t * @throws Throws an exception with an error message if an error occurs.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import { query } from '@skeet-framework/firestore'\n\t * const db = firestore();\n\t *\n\t * // Simple query to get users over 25 years old\n", " * const simpleConditions: QueryCondition[] = [\n\t *   { field: \"age\", operator: \">\", value: 25 }\n\t * ];\n\t *\n\t * // Advanced query to get users over 25 years old, ordered by their names\n\t * const advancedConditions: QueryCondition[] = [\n\t *   { field: \"age\", operator: \">\", value: 25 },\n\t *   { field: \"name\", orderDirection: \"asc\" }\n\t * ];\n\t *\n", " * // Query to get users over 25 years old and limit the results to 5\n\t * const limitedConditions: QueryCondition[] = [\n\t *   { field: \"age\", operator: \">\", value: 25 },\n\t *   { limit: 5 }\n\t * ];\n\t *\n\t * async function run() {\n\t *   try {\n\t *     const path = 'Users';\n\t *\n", " *     // Using the simple conditions\n\t *     const usersByAge = await query<User>(db, path, simpleConditions);\n\t *     console.log(`Found ${usersByAge.length} users over 25 years old.`);\n\t *\n\t *     // Using the advanced conditions\n\t *     const orderedUsers = await query<User>(db, path, advancedConditions);\n\t *     console.log(`Found ${orderedUsers.length} users over 25 years old, ordered by name.`);\n\t *\n\t *     // Using the limited conditions\n\t *     const limitedUsers = await query<User>(db, path, limitedConditions);\n", " *     console.log(`Found ${limitedUsers.length} users over 25 years old, limited to 5.`);\n\t *\n\t *   } catch (error) {\n\t *     console.error(`Error querying collection: ${error}`);\n\t *   }\n\t * }\n\t *\n\t * run();\n\t * ```\n\t */\n", "export declare const queryCollectionItems: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string, conditions: QueryCondition[]) => Promise<T[]>;\n\texport {};\n"]}
{"filename": "dist/esm/lib/serverTimestamp.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\texport declare const serverTimestamp: () => firestore.FieldValue;\n"]}
{"filename": "dist/esm/lib/getCollectionItemData.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\timport * as admin from 'firebase-admin';\n\texport declare const getCollectionItemData: <T extends firestore.DocumentData>(db: admin.firestore.Firestore, path: string) => Promise<T>;\n"]}
{"filename": "dist/esm/lib/addCollectionItem.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\t/**\n\t * Adds a new document to the specified collection in Firestore. If an ID is provided, the document will be set with that ID; otherwise, an ID will be automatically generated.\n\t *\n\t * @param db - The instance of the Firestore database to interact with.\n\t * @param collectionPath - The path of the collection where the document will be added or set.\n\t * @param params - The data of the document to be added or set.\n\t * @param id - Optional. If provided, the document will be set with this ID. If not, an ID will be automatically generated by Firestore.\n\t *\n\t * @returns A reference to the added or set document.\n", " *\n\t * @throws Throws an exception if any error occurs during the document addition or setting process.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import { add } from '@skeet-framework/firestore'\n\t *\n\t * const db = firestore();\n\t * const data: User = {\n", " *   name: \"John Doe\",\n\t *   age: 30\n\t * };\n\t *\n\t * async function run() {\n\t *   try {\n\t *     const path = 'Users';\n\t *     // Example without providing an ID:\n\t *     const docRef1 = await add<User>(db, path, data);\n\t *     console.log(`Document added with ID: ${docRef1.id}`);\n", " *\n\t *     // Example with providing an ID:\n\t *     const customID = 'custom_user_id';\n\t *     const docRef2 = await add<User>(db, path, data, customID);\n\t *     console.log(`Document set with ID: ${docRef2.id}`);\n\t *   } catch (error) {\n\t *     console.error(`Error processing document: ${error}`);\n\t *   }\n\t * }\n\t *\n", " * run();\n\t * ```\n\t */\n\texport declare const addCollectionItem: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string, params: T, id?: string) => Promise<firestore.DocumentReference<T>>;\n"]}
{"filename": "dist/esm/lib/getFirestoreModelData.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\timport * as admin from 'firebase-admin';\n\texport declare const getFirestoreModelData: <T extends firestore.DocumentData>(db: admin.firestore.Firestore, path: string) => Promise<T>;\n"]}
{"filename": "dist/esm/lib/crypt/encrypt.d.ts", "chunked_list": ["export declare const encrypt: (data: string, iv: string, password: string, salt: string) => string;\n\texport declare const decrypt: (data: string, iv: string, password: string, salt: string) => string;\n\texport declare const generateIv: () => string;\n"]}
{"filename": "dist/esm/lib/crypt/index.d.ts", "chunked_list": ["export * from './encrypt';\n"]}
{"filename": "dist/esm/lib/add/addChildCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n\t/**\n\t * `addChildCollectionItem` is a function to add an item to a specified child Firestore collection.\n\t *\n\t * @template Child - Type of the object to be saved in the child Firestore collection.\n\t * @template Parent - Type of the object in the parent Firestore collection.\n\t *\n\t * @param {string} parentCollectionName - Name of the parent Firestore collection.\n\t * @param {string} childCollectionName - Name of the child Firestore collection.\n\t * @param {string} parentId - Document ID of the parent collection item.\n", " * @param {Child} params - Data to be saved in the child Firestore collection.\n\t * @param {string} [id] - Document ID for the child collection. If not specified, a random ID is generated.\n\t *\n\t * @returns {Promise<Ref<Child>>} - Reference to the added item in the child collection.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { addChildCollectionItem } from '@skeet-framework/firestore'\n\t *\n\t * const parentCollectionName = 'User';\n", " * const childCollectionName = 'Orders';\n\t * const parentId = 'XXX';\n\t *\n\t * // Retrieve the parent document reference\n\t * const parentDoc = await getCollectionItem<User>(parentCollectionName, parentId)\n\t *\n\t * // Prepare child collection data\n\t * const orderParams = {\n\t *   parent: parentDoc.ref,\n\t *   orderId: '123',\n", " *   product: 'Some Product',\n\t *   quantity: 2,\n\t * }\n\t *\n\t * // Add item to the child collection\n\t * const orderRef = await addChildCollectionItem<Order, User>(\n\t *   parentCollectionName,\n\t *   childCollectionName,\n\t *   parentId,\n\t *   orderParams,\n", " *   orderParams.orderId\n\t * );\n\t * ```\n\t *\n\t * @throws {Error} - If an error occurs during Firestore operations.\n\t */\n\texport declare const addChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, params: Child, id?: string) => Promise<Ref<Child>>;\n"]}
{"filename": "dist/esm/lib/add/addGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n\t/**\n\t * `addGrandGrandGrandChildCollectionItem` is a function to add an item to a specified grand-grand-grandchild Firestore collection.\n\t *\n\t * @template GrandGrandGrandChild - Type of the object to be saved in the grand-grand-grandchild Firestore collection.\n\t * @template GrandGrandChild - Type of the object in the grand-grandchild Firestore collection.\n\t * @template GrandChild - Type of the object in the grandchild Firestore collection.\n\t * @template Child - Type of the object in the child Firestore collection.\n\t * @template Parent - Type of the object in the parent Firestore collection.\n\t *\n", " * @param {string} parentCollectionName - Name of the parent Firestore collection.\n\t * ... [other parameters]\n\t * @param {GrandGrandGrandChild} params - Data to be saved in the grand-grand-grandchild Firestore collection.\n\t * @param {string} [id] - Document ID for the grand-grand-grandchild collection. If not specified, a random ID is generated.\n\t *\n\t * @returns {Promise<Ref<GrandGrandGrandChild>>} - Reference to the added item in the grand-grand-grandchild collection.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { addGrandGrandGrandChildCollectionItem } from '@skeet-framework/firestore'\n", " *\n\t * const parentCollectionName = 'Planet';\n\t * ... [other collection names]\n\t * const grandGrandGrandChildCollectionName = 'House';\n\t * const parentId = 'Earth';\n\t * ... [other IDs]\n\t * const grandGrandChildId = 'MainStreet';\n\t *\n\t * const grandGrandChildDoc = await getGrandGrandChildCollectionItem<Street, City, State, Country>(\n\t *  parentCollectionName,\n", " *  childCollectionName,\n\t *  grandChildCollectionName,\n\t *  grandGrandChildCollectionName,\n\t *  parentId,\n\t *  childId,\n\t *  grandChildId\n\t * )\n\t *\n\t * const houseParams = {\n\t *   grandGrandChild: grandGrandChildDoc.ref,\n", " *   houseNumber: '123',\n\t *   color: 'Blue',\n\t *   residents: 4,\n\t * }\n\t *\n\t * const houseRef = await addGrandGrandGrandChildCollectionItem<House, Street, City, State, Country>(\n\t *   parentCollectionName,\n\t *   childCollectionName,\n\t *   ... [other collection names and IDs],\n\t *   houseParams,\n", " *   houseParams.houseNumber\n\t * );\n\t * ```\n\t *\n\t * @throws {Error} - If an error occurs during Firestore operations.\n\t */\n\texport declare const addGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, params: GrandGrandGrandChild, id?: string) => Promise<Ref<GrandGrandGrandChild>>;\n"]}
{"filename": "dist/esm/lib/add/addGrandChildCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n\t/**\n\t * `addGrandChildCollectionItem` is a function to add an item to a specified grandchild Firestore collection.\n\t *\n\t * @template GrandChild - Type of the object to be saved in the grandchild Firestore collection.\n\t * @template Child - Type of the object in the child Firestore collection.\n\t * @template Parent - Type of the object in the parent Firestore collection.\n\t *\n\t * @param {string} parentCollectionName - Name of the parent Firestore collection.\n\t * @param {string} childCollectionName - Name of the child Firestore collection.\n", " * @param {string} grandChildCollectionName - Name of the grandchild Firestore collection.\n\t * @param {string} parentId - Document ID of the parent collection item.\n\t * @param {string} childId - Document ID of the child collection item.\n\t * @param {GrandChild} params - Data to be saved in the grandchild Firestore collection.\n\t * @param {string} [id] - Document ID for the grandchild collection. If not specified, a random ID is generated.\n\t *\n\t * @returns {Promise<Ref<GrandChild>>} - Reference to the added item in the grandchild collection.\n\t *\n\t * @example\n\t * ```typescript\n", " * import { addGrandChildCollectionItem } from '@skeet-framework/firestore'\n\t *\n\t * const parentCollectionName = 'User';\n\t * const childCollectionName = 'Orders';\n\t * const grandChildCollectionName = 'Items';\n\t * const parentId = 'XXX';\n\t * const childId = 'YYY';\n\t * const userDoc = await getCollectionItem<User>(parentCollectionName, parentId)\n\t * const orderDoc = await getChildCollectionItem<Order, User>(\n\t *  parentCollectionName,\n", " *  childCollectionName,\n\t *  parentId,\n\t *  childId\n\t * )\n\t *\n\t * const itemParams = {\n\t *   child: orderDoc.ref,\n\t *   itemId: '123',\n\t *   productName: 'Some Product',\n\t *   quantity: 2,\n", " * }\n\t *\n\t * const itemRef = await addGrandChildCollectionItem<Item, Order, User>(\n\t *   parentCollectionName,\n\t *   childCollectionName,\n\t *   grandChildCollectionName,\n\t *   parentId,\n\t *   childId,\n\t *   itemParams,\n\t *   itemParams.itemId\n", " * );\n\t * ```\n\t *\n\t * @throws {Error} - If an error occurs during Firestore operations.\n\t */\n\texport declare const addGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childId: string, params: GrandChild, id?: string) => Promise<Ref<GrandChild>>;\n"]}
{"filename": "dist/esm/lib/add/addGrandGrandChildCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n\t/**\n\t * `addGrandGrandChildCollectionItem` is a function to add an item to a specified grand-grandchild Firestore collection.\n\t *\n\t * @template GrandGrandChild - Type of the object to be saved in the grand-grandchild Firestore collection.\n\t * @template GrandChild - Type of the object in the grandchild Firestore collection.\n\t * @template Child - Type of the object in the child Firestore collection.\n\t * @template Parent - Type of the object in the parent Firestore collection.\n\t *\n\t * @param {string} parentCollectionName - Name of the parent Firestore collection.\n", " * @param {string} childCollectionName - Name of the child Firestore collection.\n\t * @param {string} grandChildCollectionName - Name of the grandchild Firestore collection.\n\t * @param {string} grandGrandChildCollectionName - Name of the grand-grandchild Firestore collection.\n\t * @param {string} parentId - Document ID of the parent collection item.\n\t * @param {string} childId - Document ID of the child collection item.\n\t * @param {string} grandChildId - Document ID of the grandchild collection item.\n\t * @param {GrandGrandChild} params - Data to be saved in the grand-grandchild Firestore collection.\n\t * @param {string} [id] - Document ID for the grand-grandchild collection. If not specified, a random ID is generated.\n\t *\n\t * @returns {Promise<Ref<GrandGrandChild>>} - Reference to the added item in the grand-grandchild collection.\n", " *\n\t * @example\n\t * ```typescript\n\t * import { addGrandGrandChildCollectionItem } from '@skeet-framework/firestore'\n\t *\n\t * const parentCollectionName = 'Country';\n\t * const childCollectionName = 'State';\n\t * const grandChildCollectionName = 'City';\n\t * const grandGrandChildCollectionName = 'Street';\n\t * const parentId = 'US';\n", " * const childId = 'CA';\n\t * const grandChildId = 'LA';\n\t * const parentDoc = await getCollectionItem<Country>(parentCollectionName, parentId)\n\t * const childDoc = await getChildCollectionItem<State, Country>(\n\t *  parentCollectionName,\n\t *  childCollectionName,\n\t *  parentId,\n\t *  childId\n\t * )\n\t * const grandChildDoc = await getGrandChildCollectionItem<City, State, Country>(\n", " *  parentCollectionName,\n\t *  childCollectionName,\n\t *  grandChildCollectionName,\n\t *  parentId,\n\t *  childId,\n\t *  grandChildId\n\t * )\n\t *\n\t * const streetParams = {\n\t *   grandChild: grandChildDoc.ref,\n", " *   streetName: 'Sunset Blvd',\n\t *   zipCode: '90028',\n\t * }\n\t *\n\t * const streetRef = await addGrandGrandChildCollectionItem<Street, City, State, Country>(\n\t *   parentCollectionName,\n\t *   childCollectionName,\n\t *   grandChildCollectionName,\n\t *   grandGrandChildCollectionName,\n\t *   parentId,\n", " *   childId,\n\t *   grandChildId,\n\t *   streetParams,\n\t *   streetParams.streetName\n\t * );\n\t * ```\n\t *\n\t * @throws {Error} - If an error occurs during Firestore operations.\n\t */\n\texport declare const addGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, params: GrandGrandChild, id?: string) => Promise<Ref<GrandGrandChild>>;\n"]}
{"filename": "dist/esm/lib/add/index.d.ts", "chunked_list": ["export * from './addCollectionItem';\n\texport * from './addChildCollectionItem';\n\texport * from './addGrandChildCollectionItem';\n\texport * from './addGrandGrandChildCollectionItem';\n\texport * from './addGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/esm/lib/add/addCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n\t/**\n\t * `addCollectionItem` is a function to add an item to a specified Firestore collection.\n\t *\n\t * @template T - Type of the object to be saved in Firestore.\n\t *\n\t * @param {string} collectionName - Name of the Firestore collection.\n\t * @param {T} params - Data to be saved in Firestore.\n\t * @param {string} [id] - Document ID. If not specified, a random ID is generated.\n\t *\n", " * @returns {Promise<Ref<T>>} - Reference to the added item.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { addCollectionItem } from '@skeet-framework/firestore'\n\t * import { User } from '@/models'\n\t *\n\t * const userParams = {\n\t *   uid: 'XXX',\n\t *   email: 'info@epics.dev',\n", " *   username: 'EpicsDAO',\n\t * }\n\t *\n\t * const userRef = await addCollectionItem<User>('User', userParams, userParams.uid)\n\t * ```\n\t *\n\t * @throws {Error} - If an error occurs during Firestore operations.\n\t */\n\texport declare const addCollectionItem: <T>(collectionName: string, params: T, id?: string) => Promise<Ref<T>>;\n"]}
{"filename": "dist/esm/lib/typesaurus/index.d.ts", "chunked_list": ["export * from './ref';\n"]}
{"filename": "dist/esm/lib/typesaurus/ref.d.ts", "chunked_list": ["import { Collection } from 'typesaurus';\n\texport interface Ref<Model> {\n\t    __type__: 'ref';\n\t    collection: Collection<Model>;\n\t    id: string;\n\t}\n"]}
{"filename": "dist/esm/lib/query/queryCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\n\texport declare const queryCollectionItem: <Parent>(collectionName: string, queries: Query<Parent, keyof Parent>[]) => Promise<import(\"typesaurus\").Doc<Parent>[]>;\n"]}
{"filename": "dist/esm/lib/query/queryGrandChildCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\n\texport declare const queryGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childCollectionId: string, queries: Query<GrandChild, keyof GrandChild>[]) => Promise<import(\"typesaurus\").Doc<GrandChild>[]>;\n"]}
{"filename": "dist/esm/lib/query/queryGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\n\texport declare const queryGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string, grandGrandChildCollectionId: string, queries: Query<GrandGrandGrandChild, keyof GrandGrandGrandChild>[]) => Promise<import(\"typesaurus\").Doc<GrandGrandGrandChild>[]>;\n"]}
{"filename": "dist/esm/lib/query/queryGrandGrandChildCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\n\texport declare const queryGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string, queries: Query<GrandGrandChild, keyof GrandGrandChild>[]) => Promise<import(\"typesaurus\").Doc<GrandGrandChild>[]>;\n"]}
{"filename": "dist/esm/lib/query/queryChildCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\n\texport declare const queryChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, queries: Query<Child, keyof Child>[]) => Promise<import(\"typesaurus\").Doc<Child>[]>;\n"]}
{"filename": "dist/esm/lib/query/index.d.ts", "chunked_list": ["export * from './queryCollectionItem';\n\texport * from './queryChildCollectionItem';\n\texport * from './queryGrandChildCollectionItem';\n\texport * from './queryGrandGrandChildCollectionItem';\n\texport * from './queryGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/esm/lib/get/getChildCollectionItem.d.ts", "chunked_list": ["export declare const getChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, childCollectionId: string) => Promise<import(\"typesaurus\").Doc<Child> | null>;\n"]}
{"filename": "dist/esm/lib/get/getCollectionItem.d.ts", "chunked_list": ["export declare const getCollectionItem: <Parent>(parentCollectionName: string, parentId: string) => Promise<import(\"typesaurus\").Doc<Parent> | null>;\n"]}
{"filename": "dist/esm/lib/get/getGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const getGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string, grandGrandChildCollectionId: string) => Promise<import(\"typesaurus\").Doc<GrandGrandChild> | null>;\n"]}
{"filename": "dist/esm/lib/get/getGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const getGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, grandGrandGrandChildId: string) => Promise<import(\"typesaurus\").Doc<GrandGrandGrandChild> | null>;\n"]}
{"filename": "dist/esm/lib/get/index.d.ts", "chunked_list": ["export * from './getCollectionItem';\n\texport * from './getChildCollectionItem';\n\texport * from './getGrandChildCollectionItem';\n\texport * from './getGrandGrandChildCollectionItem';\n\texport * from './getGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/esm/lib/get/getGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const getGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string) => Promise<import(\"typesaurus\").Doc<GrandChild> | null>;\n"]}
{"filename": "dist/esm/lib/firestore/index.d.ts", "chunked_list": ["export * from './timestamp';\n"]}
{"filename": "dist/esm/lib/firestore/timestamp.d.ts", "chunked_list": ["import { Timestamp as firestoreTimestamp } from '@google-cloud/firestore';\n\texport declare class Timestamp extends firestoreTimestamp {\n\t    constructor(seconds: number, nanoseconds: number);\n\t}\n"]}
{"filename": "dist/esm/lib/remove/removeGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const removeGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/remove/removeCollectionItem.d.ts", "chunked_list": ["export declare const removeCollectionItem: <Parent>(parentCollectionName: string, parentId: string) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/remove/removeChildCollectionItem.d.ts", "chunked_list": ["export declare const removeChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, childCollectionId: string) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/remove/removeGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const removeGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, grandGrandGrandChildId: string) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/remove/index.d.ts", "chunked_list": ["export * from './removeCollectionItem';\n\texport * from './removeChildCollectionItem';\n\texport * from './removeGrandChildCollectionItem';\n\texport * from './removeGrandGrandChildCollectionItem';\n\texport * from './removeGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/esm/lib/remove/removeGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const removeGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string, grandGrandChildCollectionId: string) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/update/updateChildCollectionItem.d.ts", "chunked_list": ["export declare const updateChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, childId: string, params: Partial<Child>) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/update/updateGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const updateGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, grandGrandGrandChildId: string, params: Partial<GrandGrandGrandChild>) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/update/updateGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const updateGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, params: Partial<GrandChild>) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/update/updateGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const updateGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, params: Partial<GrandGrandChild>) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/update/updateCollectionItem.d.ts", "chunked_list": ["export declare const updateCollectionItem: <T>(collectionName: string, collectionId: string, params: Partial<T>) => Promise<boolean>;\n"]}
{"filename": "dist/esm/lib/update/index.d.ts", "chunked_list": ["export * from './updateCollectionItem';\n\texport * from './updateChildCollectionItem';\n\texport * from './updateGrandChildCollectionItem';\n\texport * from './updateGrandGrandChildCollectionItem';\n\texport * from './updateGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/cjs/index.d.ts", "chunked_list": ["export { createDataRef, createFirestoreDataConverter, getCollectionItem as get, addCollectionItem as add, serverTimestamp, createCollectionRef, addMultipleCollectionItems as adds, queryCollectionItems as query, updateCollectionItem as update, deleteCollectionItem as delete, } from './lib';\n\texport { Timestamp, FieldValue } from 'firebase/firestore';\n"]}
{"filename": "dist/cjs/utils/time.d.ts", "chunked_list": ["export declare function sleep(ms: number): Promise<unknown>;\n\texport declare const utcNow: (formatType?: number) => string;\n\texport declare const formatTime: (ms: number) => string;\n\texport declare const getTimestamp: () => string;\n"]}
{"filename": "dist/cjs/lib/getCollectionItem.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\t/**\n\t * Retrieves a document from Firestore based on the provided document reference.\n\t *\n\t * @param dataRef - The document reference pointing to the desired Firestore document.\n\t *\n\t * @returns The data of the document as an object of type T.\n\t *\n\t * @throws Throws an exception if the document doesn't exist or if there is no data in the document.\n\t *\n", " * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import * as admin from 'firebase-admin'\n\t * import { get } from '@skeet-framework/firestore'\n\t *\n\t * const db = admin.firestore();\n\t *\n\t * async function run() {\n\t *   try {\n", " *     const db = admin.firestore();\n\t *     const path = 'Users'\n\t *     const id = 'user123'\n\t *     const user = await get<User>(db, path, id)\n\t *     console.log(`Retrieved user: ${user.name}, age: ${user.age}`)\n\t *   } catch (error) {\n\t *     console.error(`Error retrieving document: ${error}`)\n\t *   }\n\t * }\n\t *\n", " * run();\n\t * ```\n\t */\n\texport declare const getCollectionItem: <T>(db: firestore.Firestore, collectionPath: string, docId: string) => Promise<T>;\n"]}
{"filename": "dist/cjs/lib/deleteCollectionItem.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\t/**\n\t * Deletes a document from the specified collection in Firestore.\n\t *\n\t * @param db - The instance of the Firestore database to use.\n\t * @param collectionPath - The path of the collection containing the document to be deleted.\n\t * @param docId - The ID of the document to be deleted.\n\t *\n\t * @returns A boolean indicating the success of the delete operation.\n\t *\n", " * @throws Throws an exception with an error message if an error occurs.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import * as admin from 'firebase-admin'\n\t * import { delete } from '@skeet-framework/firestore'\n\t *\n\t * const db = admin.firestore();\n\t *\n", " * async function run() {\n\t *   try {\n\t *     const path = 'Users'\n\t *     const docId = '123456'; // Assuming this ID exists in the Users collection.\n\t *     const success = await delete(db, path, docId);\n\t *     if (success) {\n\t *       console.log(`Document with ID ${docId} deleted successfully.`);\n\t *     }\n\t *   } catch (error) {\n\t *     console.error(`Error deleting document: ${error}`);\n", " *   }\n\t * }\n\t *\n\t * run();\n\t * ```\n\t */\n\texport declare const deleteCollectionItem: (db: firestore.Firestore, collectionPath: string, docId: string) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/getFirestoreData.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\texport declare const getFirestoreData: <T>(dataRef: firestore.DocumentReference<T>) => Promise<T>;\n"]}
{"filename": "dist/cjs/lib/version.d.ts", "chunked_list": ["export declare const VERSION = \"2.1.1\";\n"]}
{"filename": "dist/cjs/lib/createDataRef.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\texport declare const createDataRef: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string) => firestore.DocumentReference<T>;\n"]}
{"filename": "dist/cjs/lib/updateCollectionItem.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\t/**\n\t * Updates the specified document in the provided Firestore collection with the given data.\n\t *\n\t * @param db - The instance of the Firestore database to use.\n\t * @param collectionPath - The path of the collection containing the document to be updated.\n\t * @param docId - The ID of the document to be updated.\n\t * @param params - The data to update the document with.\n\t *\n\t * @returns A boolean indicating the success of the update operation.\n", " *\n\t * @throws Throws an exception with an error message if an error occurs.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import { update } from '@skeet-framework/firestore'\n\t *\n\t * const db = firestore();\n\t * const updatedData: firestore.UpdateData<User> = {\n", " *   age: 31\n\t * };\n\t *\n\t * async function run() {\n\t *   try {\n\t *     const path = 'Users'\n\t *     const docId = '123456'; // Assuming this ID exists in the Users collection.\n\t *     const success = await update<User>(db, path, docId, updatedData);\n\t *     if (success) {\n\t *       console.log(`Document with ID ${docId} updated successfully.`);\n", " *     }\n\t *   } catch (error) {\n\t *     console.error(`Error updating document: ${error}`);\n\t *   }\n\t * }\n\t *\n\t * run();\n\t * ```\n\t */\n\texport declare const updateCollectionItem: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string, docId: string, params: firestore.UpdateData<T>) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/createFirestoreDataConverter.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\texport declare const createFirestoreDataConverter: <T extends firestore.DocumentData>() => firestore.FirestoreDataConverter<T>;\n"]}
{"filename": "dist/cjs/lib/createCollectionRef.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\timport { DocumentData } from 'firebase/firestore';\n\texport declare const createCollectionRef: <T extends DocumentData>(db: firestore.Firestore, collectionPath: string) => firestore.CollectionReference<T>;\n"]}
{"filename": "dist/cjs/lib/addMultipleCollectionItems.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\t/**\n\t * Adds multiple documents to the specified collection in Firestore.\n\t * This function supports batched writes, and if the number of items exceeds the maximum batch size (500),\n\t * it will split the items into multiple batches and write them sequentially.\n\t *\n\t * @param db - The instance of the Firestore database to use.\n\t * @param collectionPath - The path of the collection to which the documents will be added.\n\t * @param items - An array of document data to be added.\n\t *\n", " * @returns An array of WriteResult arrays corresponding to each batch.\n\t *\n\t * @throws Throws an exception with an error message if an error occurs.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import { adds } from '@skeet-framework/firestore'\n\t *\n\t * const db = firestore();\n", " * const users: User[] = [\n\t *   { name: \"John Doe\", age: 30 },\n\t *   { name: \"Jane Smith\", age: 25 },\n\t *   // ... more users ...\n\t * ];\n\t *\n\t * async function run() {\n\t *   try {\n\t *     const path = 'Users'\n\t *     const results = await adds<User>(db, path, users);\n", " *     console.log(`Added ${users.length} users in ${results.length} batches.`);\n\t *   } catch (error) {\n\t *     console.error(`Error adding documents: ${error}`);\n\t *   }\n\t * }\n\t *\n\t * run();\n\t * ```\n\t */\n\texport declare const addMultipleCollectionItems: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string, items: T[]) => Promise<firestore.WriteResult[][]>;\n"]}
{"filename": "dist/cjs/lib/index.d.ts", "chunked_list": ["export * from './addCollectionItem';\n\texport * from './createDataRef';\n\texport * from './createFirestoreDataConverter';\n\texport * from './serverTimestamp';\n\texport * from './getCollectionItem';\n\texport * from './createCollectionRef';\n\texport * from './addMultipleCollectionItems';\n\texport * from './queryCollectionItems';\n\texport * from './updateCollectionItem';\n\texport * from './deleteCollectionItem';\n"]}
{"filename": "dist/cjs/lib/queryCollectionItems.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\t/**\n\t * Represents a condition for querying Firestore collections.\n\t */\n\ttype QueryCondition = {\n\t    field?: string;\n\t    operator?: firestore.WhereFilterOp;\n\t    value?: any;\n\t    orderDirection?: firestore.OrderByDirection;\n\t    limit?: number;\n", "};\n\t/**\n\t * Queries the specified collection in Firestore based on the provided conditions\n\t * and returns an array of documents that match the conditions.\n\t *\n\t * @param db - The instance of the Firestore database to use.\n\t * @param collectionPath - The path of the collection to be queried.\n\t * @param conditions - An array of conditions to apply to the query.\n\t *\n\t * @returns An array of documents from the collection that match the conditions.\n", " *\n\t * @throws Throws an exception with an error message if an error occurs.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import { query } from '@skeet-framework/firestore'\n\t * const db = firestore();\n\t *\n\t * // Simple query to get users over 25 years old\n", " * const simpleConditions: QueryCondition[] = [\n\t *   { field: \"age\", operator: \">\", value: 25 }\n\t * ];\n\t *\n\t * // Advanced query to get users over 25 years old, ordered by their names\n\t * const advancedConditions: QueryCondition[] = [\n\t *   { field: \"age\", operator: \">\", value: 25 },\n\t *   { field: \"name\", orderDirection: \"asc\" }\n\t * ];\n\t *\n", " * // Query to get users over 25 years old and limit the results to 5\n\t * const limitedConditions: QueryCondition[] = [\n\t *   { field: \"age\", operator: \">\", value: 25 },\n\t *   { limit: 5 }\n\t * ];\n\t *\n\t * async function run() {\n\t *   try {\n\t *     const path = 'Users';\n\t *\n", " *     // Using the simple conditions\n\t *     const usersByAge = await query<User>(db, path, simpleConditions);\n\t *     console.log(`Found ${usersByAge.length} users over 25 years old.`);\n\t *\n\t *     // Using the advanced conditions\n\t *     const orderedUsers = await query<User>(db, path, advancedConditions);\n\t *     console.log(`Found ${orderedUsers.length} users over 25 years old, ordered by name.`);\n\t *\n\t *     // Using the limited conditions\n\t *     const limitedUsers = await query<User>(db, path, limitedConditions);\n", " *     console.log(`Found ${limitedUsers.length} users over 25 years old, limited to 5.`);\n\t *\n\t *   } catch (error) {\n\t *     console.error(`Error querying collection: ${error}`);\n\t *   }\n\t * }\n\t *\n\t * run();\n\t * ```\n\t */\n", "export declare const queryCollectionItems: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string, conditions: QueryCondition[]) => Promise<T[]>;\n\texport {};\n"]}
{"filename": "dist/cjs/lib/serverTimestamp.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\texport declare const serverTimestamp: () => firestore.FieldValue;\n"]}
{"filename": "dist/cjs/lib/getCollectionItemData.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\timport * as admin from 'firebase-admin';\n\texport declare const getCollectionItemData: <T extends firestore.DocumentData>(db: admin.firestore.Firestore, path: string) => Promise<T>;\n"]}
{"filename": "dist/cjs/lib/addCollectionItem.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\t/**\n\t * Adds a new document to the specified collection in Firestore. If an ID is provided, the document will be set with that ID; otherwise, an ID will be automatically generated.\n\t *\n\t * @param db - The instance of the Firestore database to interact with.\n\t * @param collectionPath - The path of the collection where the document will be added or set.\n\t * @param params - The data of the document to be added or set.\n\t * @param id - Optional. If provided, the document will be set with this ID. If not, an ID will be automatically generated by Firestore.\n\t *\n\t * @returns A reference to the added or set document.\n", " *\n\t * @throws Throws an exception if any error occurs during the document addition or setting process.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import { add } from '@skeet-framework/firestore'\n\t *\n\t * const db = firestore();\n\t * const data: User = {\n", " *   name: \"John Doe\",\n\t *   age: 30\n\t * };\n\t *\n\t * async function run() {\n\t *   try {\n\t *     const path = 'Users';\n\t *     // Example without providing an ID:\n\t *     const docRef1 = await add<User>(db, path, data);\n\t *     console.log(`Document added with ID: ${docRef1.id}`);\n", " *\n\t *     // Example with providing an ID:\n\t *     const customID = 'custom_user_id';\n\t *     const docRef2 = await add<User>(db, path, data, customID);\n\t *     console.log(`Document set with ID: ${docRef2.id}`);\n\t *   } catch (error) {\n\t *     console.error(`Error processing document: ${error}`);\n\t *   }\n\t * }\n\t *\n", " * run();\n\t * ```\n\t */\n\texport declare const addCollectionItem: <T extends firestore.DocumentData>(db: firestore.Firestore, collectionPath: string, params: T, id?: string) => Promise<firestore.DocumentReference<T>>;\n"]}
{"filename": "dist/cjs/lib/getFirestoreModelData.d.ts", "chunked_list": ["import { firestore } from 'firebase-admin';\n\timport * as admin from 'firebase-admin';\n\texport declare const getFirestoreModelData: <T extends firestore.DocumentData>(db: admin.firestore.Firestore, path: string) => Promise<T>;\n"]}
{"filename": "dist/cjs/lib/crypt/encrypt.d.ts", "chunked_list": ["export declare const encrypt: (data: string, iv: string, password: string, salt: string) => string;\n\texport declare const decrypt: (data: string, iv: string, password: string, salt: string) => string;\n\texport declare const generateIv: () => string;\n"]}
{"filename": "dist/cjs/lib/crypt/index.d.ts", "chunked_list": ["export * from './encrypt';\n"]}
{"filename": "dist/cjs/lib/add/addChildCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n\t/**\n\t * `addChildCollectionItem` is a function to add an item to a specified child Firestore collection.\n\t *\n\t * @template Child - Type of the object to be saved in the child Firestore collection.\n\t * @template Parent - Type of the object in the parent Firestore collection.\n\t *\n\t * @param {string} parentCollectionName - Name of the parent Firestore collection.\n\t * @param {string} childCollectionName - Name of the child Firestore collection.\n\t * @param {string} parentId - Document ID of the parent collection item.\n", " * @param {Child} params - Data to be saved in the child Firestore collection.\n\t * @param {string} [id] - Document ID for the child collection. If not specified, a random ID is generated.\n\t *\n\t * @returns {Promise<Ref<Child>>} - Reference to the added item in the child collection.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { addChildCollectionItem } from '@skeet-framework/firestore'\n\t *\n\t * const parentCollectionName = 'User';\n", " * const childCollectionName = 'Orders';\n\t * const parentId = 'XXX';\n\t *\n\t * // Retrieve the parent document reference\n\t * const parentDoc = await getCollectionItem<User>(parentCollectionName, parentId)\n\t *\n\t * // Prepare child collection data\n\t * const orderParams = {\n\t *   parent: parentDoc.ref,\n\t *   orderId: '123',\n", " *   product: 'Some Product',\n\t *   quantity: 2,\n\t * }\n\t *\n\t * // Add item to the child collection\n\t * const orderRef = await addChildCollectionItem<Order, User>(\n\t *   parentCollectionName,\n\t *   childCollectionName,\n\t *   parentId,\n\t *   orderParams,\n", " *   orderParams.orderId\n\t * );\n\t * ```\n\t *\n\t * @throws {Error} - If an error occurs during Firestore operations.\n\t */\n\texport declare const addChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, params: Child, id?: string) => Promise<Ref<Child>>;\n"]}
{"filename": "dist/cjs/lib/add/addGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n\t/**\n\t * `addGrandGrandGrandChildCollectionItem` is a function to add an item to a specified grand-grand-grandchild Firestore collection.\n\t *\n\t * @template GrandGrandGrandChild - Type of the object to be saved in the grand-grand-grandchild Firestore collection.\n\t * @template GrandGrandChild - Type of the object in the grand-grandchild Firestore collection.\n\t * @template GrandChild - Type of the object in the grandchild Firestore collection.\n\t * @template Child - Type of the object in the child Firestore collection.\n\t * @template Parent - Type of the object in the parent Firestore collection.\n\t *\n", " * @param {string} parentCollectionName - Name of the parent Firestore collection.\n\t * ... [other parameters]\n\t * @param {GrandGrandGrandChild} params - Data to be saved in the grand-grand-grandchild Firestore collection.\n\t * @param {string} [id] - Document ID for the grand-grand-grandchild collection. If not specified, a random ID is generated.\n\t *\n\t * @returns {Promise<Ref<GrandGrandGrandChild>>} - Reference to the added item in the grand-grand-grandchild collection.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { addGrandGrandGrandChildCollectionItem } from '@skeet-framework/firestore'\n", " *\n\t * const parentCollectionName = 'Planet';\n\t * ... [other collection names]\n\t * const grandGrandGrandChildCollectionName = 'House';\n\t * const parentId = 'Earth';\n\t * ... [other IDs]\n\t * const grandGrandChildId = 'MainStreet';\n\t *\n\t * const grandGrandChildDoc = await getGrandGrandChildCollectionItem<Street, City, State, Country>(\n\t *  parentCollectionName,\n", " *  childCollectionName,\n\t *  grandChildCollectionName,\n\t *  grandGrandChildCollectionName,\n\t *  parentId,\n\t *  childId,\n\t *  grandChildId\n\t * )\n\t *\n\t * const houseParams = {\n\t *   grandGrandChild: grandGrandChildDoc.ref,\n", " *   houseNumber: '123',\n\t *   color: 'Blue',\n\t *   residents: 4,\n\t * }\n\t *\n\t * const houseRef = await addGrandGrandGrandChildCollectionItem<House, Street, City, State, Country>(\n\t *   parentCollectionName,\n\t *   childCollectionName,\n\t *   ... [other collection names and IDs],\n\t *   houseParams,\n", " *   houseParams.houseNumber\n\t * );\n\t * ```\n\t *\n\t * @throws {Error} - If an error occurs during Firestore operations.\n\t */\n\texport declare const addGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, params: GrandGrandGrandChild, id?: string) => Promise<Ref<GrandGrandGrandChild>>;\n"]}
{"filename": "dist/cjs/lib/add/addGrandChildCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n\t/**\n\t * `addGrandChildCollectionItem` is a function to add an item to a specified grandchild Firestore collection.\n\t *\n\t * @template GrandChild - Type of the object to be saved in the grandchild Firestore collection.\n\t * @template Child - Type of the object in the child Firestore collection.\n\t * @template Parent - Type of the object in the parent Firestore collection.\n\t *\n\t * @param {string} parentCollectionName - Name of the parent Firestore collection.\n\t * @param {string} childCollectionName - Name of the child Firestore collection.\n", " * @param {string} grandChildCollectionName - Name of the grandchild Firestore collection.\n\t * @param {string} parentId - Document ID of the parent collection item.\n\t * @param {string} childId - Document ID of the child collection item.\n\t * @param {GrandChild} params - Data to be saved in the grandchild Firestore collection.\n\t * @param {string} [id] - Document ID for the grandchild collection. If not specified, a random ID is generated.\n\t *\n\t * @returns {Promise<Ref<GrandChild>>} - Reference to the added item in the grandchild collection.\n\t *\n\t * @example\n\t * ```typescript\n", " * import { addGrandChildCollectionItem } from '@skeet-framework/firestore'\n\t *\n\t * const parentCollectionName = 'User';\n\t * const childCollectionName = 'Orders';\n\t * const grandChildCollectionName = 'Items';\n\t * const parentId = 'XXX';\n\t * const childId = 'YYY';\n\t * const userDoc = await getCollectionItem<User>(parentCollectionName, parentId)\n\t * const orderDoc = await getChildCollectionItem<Order, User>(\n\t *  parentCollectionName,\n", " *  childCollectionName,\n\t *  parentId,\n\t *  childId\n\t * )\n\t *\n\t * const itemParams = {\n\t *   child: orderDoc.ref,\n\t *   itemId: '123',\n\t *   productName: 'Some Product',\n\t *   quantity: 2,\n", " * }\n\t *\n\t * const itemRef = await addGrandChildCollectionItem<Item, Order, User>(\n\t *   parentCollectionName,\n\t *   childCollectionName,\n\t *   grandChildCollectionName,\n\t *   parentId,\n\t *   childId,\n\t *   itemParams,\n\t *   itemParams.itemId\n", " * );\n\t * ```\n\t *\n\t * @throws {Error} - If an error occurs during Firestore operations.\n\t */\n\texport declare const addGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childId: string, params: GrandChild, id?: string) => Promise<Ref<GrandChild>>;\n"]}
{"filename": "dist/cjs/lib/add/addGrandGrandChildCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n\t/**\n\t * `addGrandGrandChildCollectionItem` is a function to add an item to a specified grand-grandchild Firestore collection.\n\t *\n\t * @template GrandGrandChild - Type of the object to be saved in the grand-grandchild Firestore collection.\n\t * @template GrandChild - Type of the object in the grandchild Firestore collection.\n\t * @template Child - Type of the object in the child Firestore collection.\n\t * @template Parent - Type of the object in the parent Firestore collection.\n\t *\n\t * @param {string} parentCollectionName - Name of the parent Firestore collection.\n", " * @param {string} childCollectionName - Name of the child Firestore collection.\n\t * @param {string} grandChildCollectionName - Name of the grandchild Firestore collection.\n\t * @param {string} grandGrandChildCollectionName - Name of the grand-grandchild Firestore collection.\n\t * @param {string} parentId - Document ID of the parent collection item.\n\t * @param {string} childId - Document ID of the child collection item.\n\t * @param {string} grandChildId - Document ID of the grandchild collection item.\n\t * @param {GrandGrandChild} params - Data to be saved in the grand-grandchild Firestore collection.\n\t * @param {string} [id] - Document ID for the grand-grandchild collection. If not specified, a random ID is generated.\n\t *\n\t * @returns {Promise<Ref<GrandGrandChild>>} - Reference to the added item in the grand-grandchild collection.\n", " *\n\t * @example\n\t * ```typescript\n\t * import { addGrandGrandChildCollectionItem } from '@skeet-framework/firestore'\n\t *\n\t * const parentCollectionName = 'Country';\n\t * const childCollectionName = 'State';\n\t * const grandChildCollectionName = 'City';\n\t * const grandGrandChildCollectionName = 'Street';\n\t * const parentId = 'US';\n", " * const childId = 'CA';\n\t * const grandChildId = 'LA';\n\t * const parentDoc = await getCollectionItem<Country>(parentCollectionName, parentId)\n\t * const childDoc = await getChildCollectionItem<State, Country>(\n\t *  parentCollectionName,\n\t *  childCollectionName,\n\t *  parentId,\n\t *  childId\n\t * )\n\t * const grandChildDoc = await getGrandChildCollectionItem<City, State, Country>(\n", " *  parentCollectionName,\n\t *  childCollectionName,\n\t *  grandChildCollectionName,\n\t *  parentId,\n\t *  childId,\n\t *  grandChildId\n\t * )\n\t *\n\t * const streetParams = {\n\t *   grandChild: grandChildDoc.ref,\n", " *   streetName: 'Sunset Blvd',\n\t *   zipCode: '90028',\n\t * }\n\t *\n\t * const streetRef = await addGrandGrandChildCollectionItem<Street, City, State, Country>(\n\t *   parentCollectionName,\n\t *   childCollectionName,\n\t *   grandChildCollectionName,\n\t *   grandGrandChildCollectionName,\n\t *   parentId,\n", " *   childId,\n\t *   grandChildId,\n\t *   streetParams,\n\t *   streetParams.streetName\n\t * );\n\t * ```\n\t *\n\t * @throws {Error} - If an error occurs during Firestore operations.\n\t */\n\texport declare const addGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, params: GrandGrandChild, id?: string) => Promise<Ref<GrandGrandChild>>;\n"]}
{"filename": "dist/cjs/lib/add/index.d.ts", "chunked_list": ["export * from './addCollectionItem';\n\texport * from './addChildCollectionItem';\n\texport * from './addGrandChildCollectionItem';\n\texport * from './addGrandGrandChildCollectionItem';\n\texport * from './addGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/cjs/lib/add/addCollectionItem.d.ts", "chunked_list": ["import { Ref } from 'typesaurus';\n\t/**\n\t * `addCollectionItem` is a function to add an item to a specified Firestore collection.\n\t *\n\t * @template T - Type of the object to be saved in Firestore.\n\t *\n\t * @param {string} collectionName - Name of the Firestore collection.\n\t * @param {T} params - Data to be saved in Firestore.\n\t * @param {string} [id] - Document ID. If not specified, a random ID is generated.\n\t *\n", " * @returns {Promise<Ref<T>>} - Reference to the added item.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { addCollectionItem } from '@skeet-framework/firestore'\n\t * import { User } from '@/models'\n\t *\n\t * const userParams = {\n\t *   uid: 'XXX',\n\t *   email: 'info@epics.dev',\n", " *   username: 'EpicsDAO',\n\t * }\n\t *\n\t * const userRef = await addCollectionItem<User>('User', userParams, userParams.uid)\n\t * ```\n\t *\n\t * @throws {Error} - If an error occurs during Firestore operations.\n\t */\n\texport declare const addCollectionItem: <T>(collectionName: string, params: T, id?: string) => Promise<Ref<T>>;\n"]}
{"filename": "dist/cjs/lib/typesaurus/index.d.ts", "chunked_list": ["export * from './ref';\n"]}
{"filename": "dist/cjs/lib/typesaurus/ref.d.ts", "chunked_list": ["import { Collection } from 'typesaurus';\n\texport interface Ref<Model> {\n\t    __type__: 'ref';\n\t    collection: Collection<Model>;\n\t    id: string;\n\t}\n"]}
{"filename": "dist/cjs/lib/query/queryCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\n\texport declare const queryCollectionItem: <Parent>(collectionName: string, queries: Query<Parent, keyof Parent>[]) => Promise<import(\"typesaurus\").Doc<Parent>[]>;\n"]}
{"filename": "dist/cjs/lib/query/queryGrandChildCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\n\texport declare const queryGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childCollectionId: string, queries: Query<GrandChild, keyof GrandChild>[]) => Promise<import(\"typesaurus\").Doc<GrandChild>[]>;\n"]}
{"filename": "dist/cjs/lib/query/queryGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\n\texport declare const queryGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string, grandGrandChildCollectionId: string, queries: Query<GrandGrandGrandChild, keyof GrandGrandGrandChild>[]) => Promise<import(\"typesaurus\").Doc<GrandGrandGrandChild>[]>;\n"]}
{"filename": "dist/cjs/lib/query/queryGrandGrandChildCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\n\texport declare const queryGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string, queries: Query<GrandGrandChild, keyof GrandGrandChild>[]) => Promise<import(\"typesaurus\").Doc<GrandGrandChild>[]>;\n"]}
{"filename": "dist/cjs/lib/query/queryChildCollectionItem.d.ts", "chunked_list": ["import { Query } from 'typesaurus';\n\texport declare const queryChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, queries: Query<Child, keyof Child>[]) => Promise<import(\"typesaurus\").Doc<Child>[]>;\n"]}
{"filename": "dist/cjs/lib/query/index.d.ts", "chunked_list": ["export * from './queryCollectionItem';\n\texport * from './queryChildCollectionItem';\n\texport * from './queryGrandChildCollectionItem';\n\texport * from './queryGrandGrandChildCollectionItem';\n\texport * from './queryGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/cjs/lib/get/getChildCollectionItem.d.ts", "chunked_list": ["export declare const getChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, childCollectionId: string) => Promise<import(\"typesaurus\").Doc<Child> | null>;\n"]}
{"filename": "dist/cjs/lib/get/getCollectionItem.d.ts", "chunked_list": ["export declare const getCollectionItem: <Parent>(parentCollectionName: string, parentId: string) => Promise<import(\"typesaurus\").Doc<Parent> | null>;\n"]}
{"filename": "dist/cjs/lib/get/getGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const getGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string, grandGrandChildCollectionId: string) => Promise<import(\"typesaurus\").Doc<GrandGrandChild> | null>;\n"]}
{"filename": "dist/cjs/lib/get/getGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const getGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, grandGrandGrandChildId: string) => Promise<import(\"typesaurus\").Doc<GrandGrandGrandChild> | null>;\n"]}
{"filename": "dist/cjs/lib/get/index.d.ts", "chunked_list": ["export * from './getCollectionItem';\n\texport * from './getChildCollectionItem';\n\texport * from './getGrandChildCollectionItem';\n\texport * from './getGrandGrandChildCollectionItem';\n\texport * from './getGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/cjs/lib/get/getGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const getGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string) => Promise<import(\"typesaurus\").Doc<GrandChild> | null>;\n"]}
{"filename": "dist/cjs/lib/firestore/index.d.ts", "chunked_list": ["export * from './timestamp';\n"]}
{"filename": "dist/cjs/lib/firestore/timestamp.d.ts", "chunked_list": ["import { Timestamp as firestoreTimestamp } from '@google-cloud/firestore';\n\texport declare class Timestamp extends firestoreTimestamp {\n\t    constructor(seconds: number, nanoseconds: number);\n\t}\n"]}
{"filename": "dist/cjs/lib/remove/removeGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const removeGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/remove/removeCollectionItem.d.ts", "chunked_list": ["export declare const removeCollectionItem: <Parent>(parentCollectionName: string, parentId: string) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/remove/removeChildCollectionItem.d.ts", "chunked_list": ["export declare const removeChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, childCollectionId: string) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/remove/removeGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const removeGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, grandGrandGrandChildId: string) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/remove/index.d.ts", "chunked_list": ["export * from './removeCollectionItem';\n\texport * from './removeChildCollectionItem';\n\texport * from './removeGrandChildCollectionItem';\n\texport * from './removeGrandGrandChildCollectionItem';\n\texport * from './removeGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "dist/cjs/lib/remove/removeGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const removeGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childCollectionId: string, grandChildCollectionId: string, grandGrandChildCollectionId: string) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/update/updateChildCollectionItem.d.ts", "chunked_list": ["export declare const updateChildCollectionItem: <Child, Parent>(parentCollectionName: string, childCollectionName: string, parentId: string, childId: string, params: Partial<Child>) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/update/updateGrandGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const updateGrandGrandGrandChildCollectionItem: <GrandGrandGrandChild, GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, grandGrandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, grandGrandGrandChildId: string, params: Partial<GrandGrandGrandChild>) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/update/updateGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const updateGrandChildCollectionItem: <GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, params: Partial<GrandChild>) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/update/updateGrandGrandChildCollectionItem.d.ts", "chunked_list": ["export declare const updateGrandGrandChildCollectionItem: <GrandGrandChild, GrandChild, Child, Parent>(parentCollectionName: string, childCollectionName: string, grandChildCollectionName: string, grandGrandChildCollectionName: string, parentId: string, childId: string, grandChildId: string, grandGrandChildId: string, params: Partial<GrandGrandChild>) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/update/updateCollectionItem.d.ts", "chunked_list": ["export declare const updateCollectionItem: <T>(collectionName: string, collectionId: string, params: Partial<T>) => Promise<boolean>;\n"]}
{"filename": "dist/cjs/lib/update/index.d.ts", "chunked_list": ["export * from './updateCollectionItem';\n\texport * from './updateChildCollectionItem';\n\texport * from './updateGrandChildCollectionItem';\n\texport * from './updateGrandGrandChildCollectionItem';\n\texport * from './updateGrandGrandGrandChildCollectionItem';\n"]}
{"filename": "src/index.ts", "chunked_list": ["export {\n\t  createDataRef,\n\t  createFirestoreDataConverter,\n\t  getCollectionItem as get,\n\t  addCollectionItem as add,\n\t  serverTimestamp,\n\t  createCollectionRef,\n\t  addMultipleCollectionItems as adds,\n\t  queryCollectionItems as query,\n\t  updateCollectionItem as update,\n", "  deleteCollectionItem as delete,\n\t} from './lib'\n\texport { Timestamp, FieldValue } from 'firebase/firestore'\n"]}
{"filename": "src/lib/addCollectionItem.ts", "chunked_list": ["import { createCollectionRef } from './createCollectionRef'\n\timport { firestore } from 'firebase-admin'\n\timport { serverTimestamp } from './serverTimestamp'\n\t/**\n\t * Adds a new document to the specified collection in Firestore. If an ID is provided, the document will be set with that ID; otherwise, an ID will be automatically generated.\n\t *\n\t * @param db - The instance of the Firestore database to interact with.\n\t * @param collectionPath - The path of the collection where the document will be added or set.\n\t * @param params - The data of the document to be added or set.\n\t * @param id - Optional. If provided, the document will be set with this ID. If not, an ID will be automatically generated by Firestore.\n", " *\n\t * @returns A reference to the added or set document.\n\t *\n\t * @throws Throws an exception if any error occurs during the document addition or setting process.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import { add } from '@skeet-framework/firestore'\n\t *\n", " * const db = firestore();\n\t * const data: User = {\n\t *   name: \"John Doe\",\n\t *   age: 30\n\t * };\n\t *\n\t * async function run() {\n\t *   try {\n\t *     const path = 'Users';\n\t *     // Example without providing an ID:\n", " *     const docRef1 = await add<User>(db, path, data);\n\t *     console.log(`Document added with ID: ${docRef1.id}`);\n\t *\n\t *     // Example with providing an ID:\n\t *     const customID = 'custom_user_id';\n\t *     const docRef2 = await add<User>(db, path, data, customID);\n\t *     console.log(`Document set with ID: ${docRef2.id}`);\n\t *   } catch (error) {\n\t *     console.error(`Error processing document: ${error}`);\n\t *   }\n", " * }\n\t *\n\t * run();\n\t * ```\n\t */\n\texport const addCollectionItem = async <T extends firestore.DocumentData>(\n\t  db: firestore.Firestore,\n\t  collectionPath: string,\n\t  params: T,\n\t  id?: string\n", ") => {\n\t  try {\n\t    const collectionRef = createCollectionRef<T>(db, collectionPath)\n\t    if (id) {\n\t      const docRef = collectionRef.doc(id)\n\t      await docRef.set({\n\t        ...params,\n\t        createdAt: serverTimestamp(),\n\t        updatedAt: serverTimestamp(),\n\t      })\n", "      return docRef\n\t    } else {\n\t      const data = await collectionRef.add({\n\t        ...params,\n\t        createdAt: serverTimestamp(),\n\t        updatedAt: serverTimestamp(),\n\t      })\n\t      if (!data) {\n\t        throw new Error('no data')\n\t      }\n", "      return data\n\t    }\n\t  } catch (error) {\n\t    throw new Error(`Error adding document: ${error}`)\n\t  }\n\t}\n"]}
{"filename": "src/lib/deleteCollectionItem.ts", "chunked_list": ["import { firestore } from 'firebase-admin'\n\t/**\n\t * Deletes a document from the specified collection in Firestore.\n\t *\n\t * @param db - The instance of the Firestore database to use.\n\t * @param collectionPath - The path of the collection containing the document to be deleted.\n\t * @param docId - The ID of the document to be deleted.\n\t *\n\t * @returns A boolean indicating the success of the delete operation.\n\t *\n", " * @throws Throws an exception with an error message if an error occurs.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import * as admin from 'firebase-admin'\n\t * import { delete } from '@skeet-framework/firestore'\n\t *\n\t * const db = admin.firestore();\n\t *\n", " * async function run() {\n\t *   try {\n\t *     const path = 'Users'\n\t *     const docId = '123456'; // Assuming this ID exists in the Users collection.\n\t *     const success = await delete(db, path, docId);\n\t *     if (success) {\n\t *       console.log(`Document with ID ${docId} deleted successfully.`);\n\t *     }\n\t *   } catch (error) {\n\t *     console.error(`Error deleting document: ${error}`);\n", " *   }\n\t * }\n\t *\n\t * run();\n\t * ```\n\t */\n\texport const deleteCollectionItem = async (\n\t  db: firestore.Firestore,\n\t  collectionPath: string,\n\t  docId: string\n", "): Promise<boolean> => {\n\t  try {\n\t    const docRef = db.collection(collectionPath).doc(docId)\n\t    await docRef.delete()\n\t    return true\n\t  } catch (error) {\n\t    throw new Error(`Error deleting document with ID ${docId}: ${error}`)\n\t  }\n\t}\n"]}
{"filename": "src/lib/updateCollectionItem.ts", "chunked_list": ["import { firestore } from 'firebase-admin'\n\timport { createFirestoreDataConverter } from './createFirestoreDataConverter'\n\timport { serverTimestamp } from './serverTimestamp'\n\t/**\n\t * Updates the specified document in the provided Firestore collection with the given data.\n\t *\n\t * @param db - The instance of the Firestore database to use.\n\t * @param collectionPath - The path of the collection containing the document to be updated.\n\t * @param docId - The ID of the document to be updated.\n\t * @param params - The data to update the document with.\n", " *\n\t * @returns A boolean indicating the success of the update operation.\n\t *\n\t * @throws Throws an exception with an error message if an error occurs.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import { update } from '@skeet-framework/firestore'\n\t *\n", " * const db = firestore();\n\t * const updatedData: firestore.UpdateData<User> = {\n\t *   age: 31\n\t * };\n\t *\n\t * async function run() {\n\t *   try {\n\t *     const path = 'Users'\n\t *     const docId = '123456'; // Assuming this ID exists in the Users collection.\n\t *     const success = await update<User>(db, path, docId, updatedData);\n", " *     if (success) {\n\t *       console.log(`Document with ID ${docId} updated successfully.`);\n\t *     }\n\t *   } catch (error) {\n\t *     console.error(`Error updating document: ${error}`);\n\t *   }\n\t * }\n\t *\n\t * run();\n\t * ```\n", " */\n\texport const updateCollectionItem = async <T extends firestore.DocumentData>(\n\t  db: firestore.Firestore,\n\t  collectionPath: string,\n\t  docId: string,\n\t  params: firestore.UpdateData<T>\n\t): Promise<boolean> => {\n\t  try {\n\t    const docRef = db\n\t      .collection(collectionPath)\n", "      .doc(docId)\n\t      .withConverter(createFirestoreDataConverter<T>())\n\t    await docRef.update({ ...params, updatedAt: serverTimestamp() })\n\t    return true\n\t  } catch (error) {\n\t    throw new Error(`Error updating document with ID ${docId}: ${error}`)\n\t  }\n\t}\n"]}
{"filename": "src/lib/queryCollectionItems.ts", "chunked_list": ["import { firestore } from 'firebase-admin'\n\timport { createFirestoreDataConverter } from './createFirestoreDataConverter'\n\t/**\n\t * Represents a condition for querying Firestore collections.\n\t */\n\ttype QueryCondition = {\n\t  field?: string\n\t  operator?: firestore.WhereFilterOp\n\t  value?: any\n\t  orderDirection?: firestore.OrderByDirection // \"asc\" or \"desc\"\n", "  limit?: number\n\t}\n\t/**\n\t * Queries the specified collection in Firestore based on the provided conditions\n\t * and returns an array of documents that match the conditions.\n\t *\n\t * @param db - The instance of the Firestore database to use.\n\t * @param collectionPath - The path of the collection to be queried.\n\t * @param conditions - An array of conditions to apply to the query.\n\t *\n", " * @returns An array of documents from the collection that match the conditions.\n\t *\n\t * @throws Throws an exception with an error message if an error occurs.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import { query } from '@skeet-framework/firestore'\n\t * const db = firestore();\n\t *\n", " * // Simple query to get users over 25 years old\n\t * const simpleConditions: QueryCondition[] = [\n\t *   { field: \"age\", operator: \">\", value: 25 }\n\t * ];\n\t *\n\t * // Advanced query to get users over 25 years old, ordered by their names\n\t * const advancedConditions: QueryCondition[] = [\n\t *   { field: \"age\", operator: \">\", value: 25 },\n\t *   { field: \"name\", orderDirection: \"asc\" }\n\t * ];\n", " *\n\t * // Query to get users over 25 years old and limit the results to 5\n\t * const limitedConditions: QueryCondition[] = [\n\t *   { field: \"age\", operator: \">\", value: 25 },\n\t *   { limit: 5 }\n\t * ];\n\t *\n\t * async function run() {\n\t *   try {\n\t *     const path = 'Users';\n", " *\n\t *     // Using the simple conditions\n\t *     const usersByAge = await query<User>(db, path, simpleConditions);\n\t *     console.log(`Found ${usersByAge.length} users over 25 years old.`);\n\t *\n\t *     // Using the advanced conditions\n\t *     const orderedUsers = await query<User>(db, path, advancedConditions);\n\t *     console.log(`Found ${orderedUsers.length} users over 25 years old, ordered by name.`);\n\t *\n\t *     // Using the limited conditions\n", " *     const limitedUsers = await query<User>(db, path, limitedConditions);\n\t *     console.log(`Found ${limitedUsers.length} users over 25 years old, limited to 5.`);\n\t *\n\t *   } catch (error) {\n\t *     console.error(`Error querying collection: ${error}`);\n\t *   }\n\t * }\n\t *\n\t * run();\n\t * ```\n", " */\n\texport const queryCollectionItems = async <T extends firestore.DocumentData>(\n\t  db: firestore.Firestore,\n\t  collectionPath: string,\n\t  conditions: QueryCondition[]\n\t): Promise<T[]> => {\n\t  try {\n\t    let query: firestore.Query = db\n\t      .collection(collectionPath)\n\t      .withConverter(createFirestoreDataConverter<T>())\n", "    for (const condition of conditions) {\n\t      if (\n\t        condition.field &&\n\t        condition.operator &&\n\t        condition.value !== undefined\n\t      ) {\n\t        query = query.where(\n\t          condition.field,\n\t          condition.operator,\n\t          condition.value\n", "        )\n\t      }\n\t      if (condition.field && condition.orderDirection) {\n\t        query = query.orderBy(condition.field, condition.orderDirection)\n\t      }\n\t      if (condition.limit !== undefined) {\n\t        query = query.limit(condition.limit)\n\t      }\n\t    }\n\t    const snapshot = await query.get()\n", "    return snapshot.docs.map((doc) => ({\n\t      id: doc.id,\n\t      ...(doc.data() as T),\n\t    }))\n\t  } catch (error) {\n\t    throw new Error(`Error querying collection: ${error}`)\n\t  }\n\t}\n"]}
{"filename": "src/lib/version.ts", "chunked_list": ["export const VERSION = '2.1.1'"]}
{"filename": "src/lib/addMultipleCollectionItems.ts", "chunked_list": ["import { createCollectionRef } from './createCollectionRef'\n\timport { firestore } from 'firebase-admin'\n\timport { serverTimestamp } from './serverTimestamp'\n\t/**\n\t * Adds multiple documents to the specified collection in Firestore.\n\t * This function supports batched writes, and if the number of items exceeds the maximum batch size (500),\n\t * it will split the items into multiple batches and write them sequentially.\n\t *\n\t * @param db - The instance of the Firestore database to use.\n\t * @param collectionPath - The path of the collection to which the documents will be added.\n", " * @param items - An array of document data to be added.\n\t *\n\t * @returns An array of WriteResult arrays corresponding to each batch.\n\t *\n\t * @throws Throws an exception with an error message if an error occurs.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import { adds } from '@skeet-framework/firestore'\n", " *\n\t * const db = firestore();\n\t * const users: User[] = [\n\t *   { name: \"John Doe\", age: 30 },\n\t *   { name: \"Jane Smith\", age: 25 },\n\t *   // ... more users ...\n\t * ];\n\t *\n\t * async function run() {\n\t *   try {\n", " *     const path = 'Users'\n\t *     const results = await adds<User>(db, path, users);\n\t *     console.log(`Added ${users.length} users in ${results.length} batches.`);\n\t *   } catch (error) {\n\t *     console.error(`Error adding documents: ${error}`);\n\t *   }\n\t * }\n\t *\n\t * run();\n\t * ```\n", " */\n\texport const addMultipleCollectionItems = async <\n\t  T extends firestore.DocumentData\n\t>(\n\t  db: firestore.Firestore,\n\t  collectionPath: string,\n\t  items: T[]\n\t): Promise<firestore.WriteResult[][]> => {\n\t  const MAX_BATCH_SIZE = 500\n\t  const chunkedItems =\n", "    items.length > 500 ? chunkArray(items, MAX_BATCH_SIZE) : [items]\n\t  const batchResults: firestore.WriteResult[][] = []\n\t  for (const chunk of chunkedItems) {\n\t    try {\n\t      const batch = db.batch()\n\t      const collectionRef = createCollectionRef<T>(db, collectionPath)\n\t      chunk.forEach((item) => {\n\t        const docRef = collectionRef.doc()\n\t        batch.set(docRef, {\n\t          ...item,\n", "          createdAt: serverTimestamp(),\n\t          updatedAt: serverTimestamp(),\n\t        })\n\t      })\n\t      const writeResults = await batch.commit()\n\t      batchResults.push(writeResults)\n\t    } catch (error) {\n\t      throw new Error(`Error adding a batch of documents: ${error}`)\n\t    }\n\t  }\n", "  return batchResults\n\t}\n\t/**\n\t * Helper function to divide an array into chunks of a specified size.\n\t *\n\t * @param array - The array to be divided.\n\t * @param size - The size of each chunk.\n\t *\n\t * @returns An array of chunked arrays.\n\t */\n", "function chunkArray<T>(array: T[], size: number): T[][] {\n\t  const chunked = []\n\t  let index = 0\n\t  while (index < array.length) {\n\t    chunked.push(array.slice(index, size + index))\n\t    index += size\n\t  }\n\t  return chunked\n\t}\n"]}
{"filename": "src/lib/serverTimestamp.ts", "chunked_list": ["import { firestore } from 'firebase-admin'\n\texport const serverTimestamp = () => {\n\t  return firestore.FieldValue.serverTimestamp()\n\t}\n"]}
{"filename": "src/lib/index.ts", "chunked_list": ["export * from './addCollectionItem'\n\texport * from './createDataRef'\n\texport * from './createFirestoreDataConverter'\n\texport * from './serverTimestamp'\n\texport * from './getCollectionItem'\n\texport * from './createCollectionRef'\n\texport * from './addMultipleCollectionItems'\n\texport * from './queryCollectionItems'\n\texport * from './updateCollectionItem'\n\texport * from './deleteCollectionItem'\n"]}
{"filename": "src/lib/getCollectionItem.ts", "chunked_list": ["import { firestore } from 'firebase-admin'\n\t/**\n\t * Retrieves a document from Firestore based on the provided document reference.\n\t *\n\t * @param dataRef - The document reference pointing to the desired Firestore document.\n\t *\n\t * @returns The data of the document as an object of type T.\n\t *\n\t * @throws Throws an exception if the document doesn't exist or if there is no data in the document.\n\t *\n", " * @example\n\t * ```typescript\n\t * import { firestore } from 'firebase-admin'\n\t * import * as admin from 'firebase-admin'\n\t * import { get } from '@skeet-framework/firestore'\n\t *\n\t * const db = admin.firestore();\n\t *\n\t * async function run() {\n\t *   try {\n", " *     const db = admin.firestore();\n\t *     const path = 'Users'\n\t *     const id = 'user123'\n\t *     const user = await get<User>(db, path, id)\n\t *     console.log(`Retrieved user: ${user.name}, age: ${user.age}`)\n\t *   } catch (error) {\n\t *     console.error(`Error retrieving document: ${error}`)\n\t *   }\n\t * }\n\t *\n", " * run();\n\t * ```\n\t */\n\texport const getCollectionItem = async <T>(\n\t  db: firestore.Firestore,\n\t  collectionPath: string,\n\t  docId: string\n\t): Promise<T> => {\n\t  const dataRef = db\n\t    .collection(collectionPath)\n", "    .doc(docId) as FirebaseFirestore.DocumentReference<T>\n\t  const doc = await dataRef.get()\n\t  if (!doc.exists) {\n\t    throw new Error('Document not found at path: ' + dataRef.path)\n\t  }\n\t  const data = doc.data()\n\t  if (!data) throw new Error('Document data not found at path: ' + dataRef.path)\n\t  return data\n\t}\n"]}
{"filename": "src/lib/createDataRef.ts", "chunked_list": ["import { firestore } from 'firebase-admin'\n\timport { createFirestoreDataConverter } from './createFirestoreDataConverter'\n\texport const createDataRef = <T extends firestore.DocumentData>(\n\t  db: firestore.Firestore,\n\t  collectionPath: string\n\t) => {\n\t  return db.doc(collectionPath).withConverter(createFirestoreDataConverter<T>())\n\t}\n"]}
{"filename": "src/lib/createFirestoreDataConverter.ts", "chunked_list": ["import { firestore } from 'firebase-admin'\n\texport const createFirestoreDataConverter = <\n\t  T extends firestore.DocumentData\n\t>(): firestore.FirestoreDataConverter<T> => {\n\t  return {\n\t    toFirestore(data: T): firestore.DocumentData {\n\t      return data\n\t    },\n\t    fromFirestore(snapshot: firestore.QueryDocumentSnapshot): T {\n\t      return snapshot.data() as T\n", "    },\n\t  }\n\t}\n"]}
{"filename": "src/lib/createCollectionRef.ts", "chunked_list": ["import { firestore } from 'firebase-admin'\n\timport { createFirestoreDataConverter } from './createFirestoreDataConverter'\n\timport { DocumentData } from 'firebase/firestore'\n\texport const createCollectionRef = <T extends DocumentData>(\n\t  db: firestore.Firestore,\n\t  collectionPath: string\n\t) => {\n\t  return db\n\t    .collection(collectionPath)\n\t    .withConverter(createFirestoreDataConverter<T>())\n", "}\n"]}
