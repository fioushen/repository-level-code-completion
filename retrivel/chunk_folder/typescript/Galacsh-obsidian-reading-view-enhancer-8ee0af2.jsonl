{"filename": "src/styles.ts", "chunked_list": ["import { SELECTED_BLOCK } from \"./constants\";\n\t/**\n\t * Style rule that holds the template\n\t * and the function to inject variables\n\t */\n\tclass StyleRule {\n\t\tprivate template: string;\n\t\tprivate injectVariables: (template: string) => string;\n\t\tisActive: boolean;\n\t\tconstructor(template: string, injectVariables: (template: string) => string) {\n", "\t\tthis.template = template;\n\t\t\tthis.isActive = false;\n\t\t\tthis.injectVariables = injectVariables;\n\t\t}\n\t\t/**\n\t\t * Get the rule after injecting variables\n\t\t *\n\t\t * @returns {string} The rule\n\t\t */\n\t\tgetRule() {\n", "\t\treturn this.injectVariables(this.template);\n\t\t}\n\t}\n\t/**\n\t * Block color rule.\n\t *\n\t * Accepts a block color and injects it into the template.\n\t */\n\texport class BlockColorRule extends StyleRule {\n\t\tprivate blockColor: string;\n", "\tconstructor() {\n\t\t\tconst template = `\n\t\t\t\t.${SELECTED_BLOCK} {\n\t\t\t\t\tposition: relative;\n\t\t\t\t}\n\t\t\t\t.${SELECTED_BLOCK}::before {\n\t\t\t\t\tcontent: \"\";\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\ttop: 0;\n\t\t\t\t\tleft: 0;\n", "\t\t\t\twidth: 100%;\n\t\t\t\t\theight: 100%;\n\t\t\t\t\tpointer-events: none;\n\t\t\t\t\tbackground-color: {{BLOCK_COLOR}}1a;\n\t\t\t\t}\n\t\t\t`;\n\t\t\tsuper(template, (template: string) => {\n\t\t\t\treturn template.replace(\"{{BLOCK_COLOR}}\", this.blockColor);\n\t\t\t});\n\t\t\tthis.isActive = true;\n", "\t}\n\t\t/**\n\t\t * Set the block color\n\t\t *\n\t\t * @param blockColor {string} The block color\n\t\t */\n\t\tset(blockColor: string) {\n\t\t\tthis.blockColor = blockColor;\n\t\t}\n\t}\n", "/**\n\t * Collapse indicator rule.\n\t *\n\t * No variables to inject.\n\t */\n\texport class CollapseIndicatorRule extends StyleRule {\n\t\tconstructor() {\n\t\t\tconst template = `\n\t\t\t\t.markdown-preview-section .collapse-indicator {\n\t\t\t\t\topacity: 1;\n", "\t\t\t}\n\t\t\t`;\n\t\t\tsuper(template, (template: string) => template);\n\t\t}\n\t}\n\t/**\n\t * Prevent table overflowing rule.\n\t *\n\t * No variables to inject.\n\t */\n", "export class PreventTableOverflowingRule extends StyleRule {\n\t\tconstructor() {\n\t\t\tconst template = `\n\t\t\t\t.markdown-preview-section > div:has(table) {\n\t\t\t\t\toverflow: auto;\n\t\t\t\t}\n\t\t\t\t.markdown-preview-section thead > tr > th,\n\t\t\t\t.markdown-preview-section tbody > tr > td {\n\t\t\t\t\twhite-space: nowrap;\n\t\t\t\t}\n", "\t\t`;\n\t\t\tsuper(template, (template: string) => template);\n\t\t}\n\t}\n\t/**\n\t * Scrollable code rule.\n\t *\n\t * No variables to inject.\n\t */\n\texport class ScrollableCodeRule extends StyleRule {\n", "\tconstructor() {\n\t\t\tconst template = `\n\t\t\t\t.markdown-preview-section div > pre {\n\t\t\t\t\toverflow: hidden;\n\t\t\t\t\twhite-space: pre-wrap;\n\t\t\t\t}\n\t\t\t\t.markdown-preview-section div > pre > code {\n\t\t\t\t\tdisplay: block;\n\t\t\t\t\toverflow: auto;\n\t\t\t\t\twhite-space: pre;\n", "\t\t\t}\n\t\t\t`;\n\t\t\tsuper(template, (template: string) => template);\n\t\t}\n\t}\n\ttype RuleKey =\n\t\t| \"block-color\"\n\t\t| \"collapse-indicator\"\n\t\t| \"prevent-table-overflowing\"\n\t\t| \"scrollable-code\";\n", "/**\n\t * The class that manages all style rules.\n\t */\n\texport default class RveStyles {\n\t\tstyleTag: HTMLStyleElement;\n\t\trules: Record<RuleKey, StyleRule>;\n\t\tconstructor() {\n\t\t\tthis.styleTag = document.createElement(\"style\");\n\t\t\tthis.styleTag.id = \"rve-styles\";\n\t\t\tdocument.getElementsByTagName(\"head\")[0].appendChild(this.styleTag);\n", "\t\tthis.rules = {\n\t\t\t\t\"block-color\": new BlockColorRule(),\n\t\t\t\t\"collapse-indicator\": new CollapseIndicatorRule(),\n\t\t\t\t\"prevent-table-overflowing\": new PreventTableOverflowingRule(),\n\t\t\t\t\"scrollable-code\": new ScrollableCodeRule(),\n\t\t\t};\n\t\t}\n\t\t/**\n\t\t * Clean up the style tag\n\t\t */\n", "\tcleanup() {\n\t\t\tthis.styleTag.remove();\n\t\t}\n\t\t/**\n\t\t * Get a rule by key\n\t\t *\n\t\t * @param rule {RuleKey} rule's key\n\t\t * @returns {StyleRule} One of the rules\n\t\t */\n\t\tof(rule: RuleKey) {\n", "\t\treturn this.rules[rule];\n\t\t}\n\t\t/**\n\t\t * Apply all active rules\n\t\t */\n\t\tapply() {\n\t\t\tconst style = Object.values(this.rules)\n\t\t\t\t.filter((rule) => rule.isActive)\n\t\t\t\t.map((rule) => rule.getRule())\n\t\t\t\t.join(\"\\n\");\n", "\t\tthis.styleTag.innerHTML = style;\n\t\t}\n\t}\n"]}
{"filename": "src/main.ts", "chunked_list": ["import { Plugin } from \"obsidian\";\n\timport RveStyles, { BlockColorRule } from \"./styles\";\n\timport { RveSettingTab, RveSettings, DEFAULT_SETTINGS } from \"./settings\";\n\timport Commands from \"./commands\";\n\timport BlockSelector from \"./block-selector\";\n\texport default class ReadingViewEnhancer extends Plugin {\n\t\tsettings: RveSettings;\n\t\tstyles: RveStyles;\n\t\tblockSelector: BlockSelector;\n\t\t/**\n", "\t * On load,\n\t\t *\n\t\t * - Load settings & styles\n\t\t * - Activate block selector\n\t\t *     - It actually do its work if settings.enableBlockSelector is true\n\t\t * - Register all commands\n\t\t * - Add settings tab\n\t\t */\n\t\tasync onload() {\n\t\t\t// Settings & Styles\n", "\t\tawait this.loadSettings();\n\t\t\tthis.styles = new RveStyles();\n\t\t\tthis.app.workspace.onLayoutReady(() => this.applySettingsToStyles());\n\t\t\t// Activate block selector.\n\t\t\tthis.blockSelector = new BlockSelector(this);\n\t\t\tthis.blockSelector.activate();\n\t\t\t// Register commands\n\t\t\tnew Commands(this).register();\n\t\t\t// Add settings tab at last\n\t\t\tthis.addSettingTab(new RveSettingTab(this));\n", "\t\t// Leave a message in the console\n\t\t\tconsole.log(\"Loaded 'Reading View Enhancer'\");\n\t\t}\n\t\t/**\n\t\t * On unload,\n\t\t *\n\t\t * - Remove all styles\n\t\t */\n\t\tasync onunload() {\n\t\t\tthis.styles.cleanup();\n", "\t\t// Leave a message in the console\n\t\t\tconsole.log(\"Unloaded 'Reading View Enhancer'\");\n\t\t}\n\t\t// ===================================================================\n\t\t/**\n\t\t * Load settings\n\t\t */\n\t\tasync loadSettings() {\n\t\t\tthis.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());\n\t\t}\n", "\t/**\n\t\t * Save settings\n\t\t */\n\t\tasync saveSettings() {\n\t\t\tawait this.saveData(this.settings);\n\t\t}\n\t\t/**\n\t\t * Apply settings to styles\n\t\t *\n\t\t * - Apply block color\n", "\t * - Apply always on collapse indicator\n\t\t * - Apply prevent table overflowing\n\t\t * - Apply scrollable code\n\t\t */\n\t\tprivate applySettingsToStyles() {\n\t\t\tthis.applyBlockColor();\n\t\t\tthis.applyAlwaysOnCollapse();\n\t\t\tthis.applyPreventTableOverflowing();\n\t\t\tthis.applyScrollableCode();\n\t\t\tthis.styles.apply();\n", "\t}\n\t\t/**\n\t\t * Apply block color\n\t\t *\n\t\t * @param isImmediate {boolean} Whether to apply styles immediately\n\t\t */\n\t\tapplyBlockColor(isImmediate = false) {\n\t\t\tconst blockColor = this.styles.of(\"block-color\") as BlockColorRule;\n\t\t\tblockColor.set(this.settings.blockColor);\n\t\t\tif (isImmediate) this.styles.apply();\n", "\t}\n\t\t/**\n\t\t * Apply always on collapse indicator\n\t\t *\n\t\t * @param isImmediate {boolean} Whether to apply styles immediately\n\t\t */\n\t\tapplyAlwaysOnCollapse(isImmediate = false) {\n\t\t\tthis.styles.of(\"collapse-indicator\").isActive =\n\t\t\t\tthis.settings.alwaysOnCollapseIndicator;\n\t\t\tif (isImmediate) this.styles.apply();\n", "\t}\n\t\t/**\n\t\t * Apply prevent table overflowing\n\t\t *\n\t\t * @param isImmediate {boolean} Whether to apply styles immediately\n\t\t */\n\t\tapplyPreventTableOverflowing(isImmediate = false) {\n\t\t\tthis.styles.of(\"prevent-table-overflowing\").isActive =\n\t\t\t\tthis.settings.preventTableOverflowing;\n\t\t\tif (isImmediate) this.styles.apply();\n", "\t}\n\t\t/**\n\t\t * Apply scrollable code\n\t\t *\n\t\t * @param isImmediate {boolean} Whether to apply styles immediately\n\t\t */\n\t\tapplyScrollableCode(isImmediate = false) {\n\t\t\tthis.styles.of(\"scrollable-code\").isActive = this.settings.scrollableCode;\n\t\t\tif (isImmediate) this.styles.apply();\n\t\t}\n", "}\n"]}
{"filename": "src/constants.ts", "chunked_list": ["/**\n\t * Class name for the preview view\n\t */\n\texport const MARKDOWN_PREVIEW_VIEW = \"markdown-preview-view\";\n\t/**\n\t * Class name for the frontmatter element\n\t */\n\texport const FRONTMATTER = \"frontmatter\";\n\t/**\n\t * List of selectors for block elements\n", " */\n\texport const BLOCKS = [\n\t\t\"p\",\n\t\t\"li\",\n\t\t\"table\",\n\t\t\"h1\",\n\t\t\"h2\",\n\t\t\"h3\",\n\t\t\"h4\",\n\t\t\"h5\",\n", "\t\"h6\",\n\t\t\"pre\",\n\t\t\"blockquote\",\n\t\t\"img\",\n\t\t\"video\",\n\t\t\"audio\",\n\t\t\"iframe\",\n\t\t\"[data-callout]\",\n\t];\n\t/**\n", " * Class name for block selector\n\t */\n\texport const BLOCK_SELECTOR = \"rve-block-selector\";\n\t/**\n\t * Attribute name for block elements\n\t */\n\texport const BLOCK_ATTR = \"data-rve-block\";\n\t/**\n\t * Class name for selected block\n\t */\n", "export const SELECTED_BLOCK = \"rve-selected-block\";\n\t/**\n\t * Selector for collapse indicators\n\t */\n\texport const COLLAPSE_INDICATORS = [\".collapse-indicator\", \".callout-fold\"];\n\t/**\n\t * Class name for collapsed block\n\t */\n\texport const IS_COLLAPSED = \"is-collapsed\";\n"]}
{"filename": "src/commands/commands.ts", "chunked_list": ["import { RveCommand } from \".\";\n\timport ReadingViewEnhancer from \"src/main\";\n\timport { MarkdownView, Platform } from \"obsidian\";\n\t/**\n\t * Rerender all reading views\n\t *\n\t * @param plugin {ReadingViewEnhancer} Plugin instance\n\t * @returns {RveCommand} Rerender all reading views command\n\t */\n\texport const rerenderAllReadingViews: RveCommand = (\n", "\tplugin: ReadingViewEnhancer\n\t) => ({\n\t\tid: \"rerender-all-reading-views\",\n\t\tname: \"Rerender all reading views\",\n\t\tcallback: () => {\n\t\t\tconst { workspace } = plugin.app;\n\t\t\tworkspace.getLeavesOfType(\"markdown\").forEach((leaf) => {\n\t\t\t\tif (leaf.view.getState().mode === \"preview\") {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tleaf.view.previewMode?.rerender(true);\n", "\t\t\t}\n\t\t\t});\n\t\t},\n\t});\n\t/**\n\t * Select top block in the view\n\t *\n\t * @param plugin {ReadingViewEnhancer} Plugin instance\n\t * @returns {RveCommand} Select top block in the view command\n\t */\n", "export const selectTopBlockInTheView: RveCommand = (\n\t\tplugin: ReadingViewEnhancer\n\t) => ({\n\t\tid: \"select-top-block-in-the-view\",\n\t\tname: \"Select Top Block in the View\",\n\t\tcheckCallback: (checking: boolean): boolean => {\n\t\t\t// If checking is set to true, perform a preliminary check.\n\t\t\tif (checking) {\n\t\t\t\tif (isNotReadingView(plugin)) return false;\n\t\t\t\telse if (isNotEnabled(plugin)) return false;\n", "\t\t\telse if (isMobileAndDisabled(plugin)) return false;\n\t\t\t\telse return true;\n\t\t\t}\n\t\t\t// If checking is set to false, perform an action.\n\t\t\telse {\n\t\t\t\tconst container = getReadingViewContainer(plugin);\n\t\t\t\tif (container) {\n\t\t\t\t\tplugin.blockSelector.selectTopBlockInTheView(container);\n\t\t\t\t}\n\t\t\t\treturn true;\n", "\t\t}\n\t\t},\n\t});\n\tconst isNotReadingView = (plugin: ReadingViewEnhancer) => {\n\t\tconst activeView = getActiveView(plugin);\n\t\treturn activeView?.getState().mode !== \"preview\";\n\t};\n\tconst isNotEnabled = (plugin: ReadingViewEnhancer) => {\n\t\treturn !plugin.settings.enableBlockSelector;\n\t};\n", "const isMobileAndDisabled = (plugin: ReadingViewEnhancer) => {\n\t\treturn (\n\t\t\t(Platform.isMobile || Platform.isMobileApp) &&\n\t\t\tplugin.settings.disableBlockSelectorOnMobile\n\t\t);\n\t};\n\tconst getReadingViewContainer = (plugin: ReadingViewEnhancer) => {\n\t\tconst activeView = getActiveView(plugin);\n\t\treturn activeView?.previewMode.containerEl;\n\t};\n", "const getActiveView = (plugin: ReadingViewEnhancer) => {\n\t\tconst { workspace } = plugin.app;\n\t\treturn workspace.getActiveViewOfType(MarkdownView);\n\t};\n"]}
{"filename": "src/commands/index.ts", "chunked_list": ["import { Command } from \"obsidian\";\n\timport ReadingViewEnhancer from \"src/main\";\n\timport * as commands from \"./commands\";\n\texport interface RveCommand {\n\t\t(plugin: ReadingViewEnhancer): Command;\n\t}\n\t/**\n\t * Set commands for plugin.\n\t * Loads all commands from `commands` directory and add them to plugin.\n\t */\n", "export default class Commands {\n\t\tplugin: ReadingViewEnhancer;\n\t\tconstructor(plugin: ReadingViewEnhancer) {\n\t\t\tthis.plugin = plugin;\n\t\t}\n\t\tregister() {\n\t\t\tObject.values(commands)\n\t\t\t\t.map((revCommand: RveCommand) => revCommand(this.plugin))\n\t\t\t\t.forEach((command) => this.plugin.addCommand(command));\n\t\t}\n", "}\n"]}
{"filename": "src/settings/index.ts", "chunked_list": ["import { PluginSettingTab } from \"obsidian\";\n\timport ReadingViewEnhancer from \"../main\";\n\timport BlockSelectorSettings from \"./block\";\n\timport MiscellaneousSettings from \"./miscellaneous\";\n\texport interface RveSettings {\n\t\tblockColor: string;\n\t\tenableBlockSelector: boolean;\n\t\tdisableBlockSelectorOnMobile: boolean;\n\t\talwaysOnCollapseIndicator: boolean;\n\t\tpreventTableOverflowing: boolean;\n", "\tscrollableCode: boolean;\n\t}\n\texport const DEFAULT_SETTINGS: RveSettings = {\n\t\tblockColor: \"#8b6cef\", // Obsidian default color\n\t\tenableBlockSelector: false,\n\t\tdisableBlockSelectorOnMobile: false,\n\t\talwaysOnCollapseIndicator: false,\n\t\tpreventTableOverflowing: false,\n\t\tscrollableCode: false,\n\t};\n", "// ===================================================================\n\t/**\n\t * Settings tab.\n\t * In this tab, you can change settings.\n\t *\n\t * - Block color\n\t * - Enable/Disable Block Selector\n\t */\n\texport class RveSettingTab extends PluginSettingTab {\n\t\tplugin: ReadingViewEnhancer;\n", "\tconstructor(plugin: ReadingViewEnhancer) {\n\t\t\tsuper(app, plugin);\n\t\t\tthis.plugin = plugin;\n\t\t}\n\t\t/**\n\t\t * Displays settings tab.\n\t\t */\n\t\tdisplay() {\n\t\t\tconst { containerEl } = this;\n\t\t\t// Clear all first\n", "\t\tcontainerEl.empty();\n\t\t\t// Add header\n\t\t\tcontainerEl.createEl(\"h1\", { text: \"Reading View Enhancer\" });\n\t\t\t// Add block selector settings\n\t\t\tnew BlockSelectorSettings(containerEl, this.plugin);\n\t\t\t// Add miscellaneous settings\n\t\t\tnew MiscellaneousSettings(containerEl, this.plugin);\n\t\t}\n\t}\n"]}
{"filename": "src/settings/miscellaneous/always-on-collapse-indicator.ts", "chunked_list": ["import { Setting, ToggleComponent } from \"obsidian\";\n\timport ReadingViewEnhancer from \"src/main\";\n\t/**\n\t * Always on collapse indicator setting component\n\t */\n\texport default class AlwaysOnCollapseIndicatorSetting extends Setting {\n\t\tplugin: ReadingViewEnhancer;\n\t\tworkspaceEl: HTMLElement;\n\t\tconstructor(settingsTabEl: HTMLElement, plugin: ReadingViewEnhancer) {\n\t\t\tsuper(settingsTabEl);\n", "\t\tthis.plugin = plugin;\n\t\t\tthis.setName(\"Always on collapse indicator\")\n\t\t\t\t.setDesc(\"Set collapse indicators always visible in reading view.\")\n\t\t\t\t.addToggle((toggle) => this.alwaysOnCollapseIndicator(toggle));\n\t\t}\n\t\t/**\n\t\t * Creates toggle component\n\t\t *\n\t\t * @param toggle {ToggleComponent} Toggle component\n\t\t */\n", "\talwaysOnCollapseIndicator(toggle: ToggleComponent) {\n\t\t\tconst { settings } = this.plugin;\n\t\t\ttoggle.setValue(settings.alwaysOnCollapseIndicator).onChange((changed) => {\n\t\t\t\tsettings.alwaysOnCollapseIndicator = changed;\n\t\t\t\tthis.plugin.saveSettings();\n\t\t\t\tthis.plugin.applyAlwaysOnCollapse(true);\n\t\t\t});\n\t\t}\n\t}\n"]}
{"filename": "src/settings/miscellaneous/scrollable-code.ts", "chunked_list": ["import { Setting, ToggleComponent } from \"obsidian\";\n\timport ReadingViewEnhancer from \"src/main\";\n\t/**\n\t * Scrollable code setting component\n\t */\n\texport default class ScrollableCodeSetting extends Setting {\n\t\tplugin: ReadingViewEnhancer;\n\t\tconstructor(containerEl: HTMLElement, plugin: ReadingViewEnhancer) {\n\t\t\tsuper(containerEl);\n\t\t\tthis.plugin = plugin;\n", "\t\tthis.setName(\"Scrollable Code\")\n\t\t\t\t.setDesc(\"Make code blocks scrollable instead of line break.\")\n\t\t\t\t.addToggle((toggle) => this.setCodeScrollable(toggle));\n\t\t}\n\t\tsetCodeScrollable(toggle: ToggleComponent) {\n\t\t\ttoggle.setValue(this.plugin.settings.scrollableCode);\n\t\t\t// save on change\n\t\t\ttoggle.onChange((changed) => {\n\t\t\t\tthis.plugin.settings.scrollableCode = changed;\n\t\t\t\tthis.plugin.saveSettings();\n", "\t\t\tthis.plugin.applyScrollableCode(true);\n\t\t\t});\n\t\t}\n\t}\n"]}
{"filename": "src/settings/miscellaneous/prevent-table-overflow.ts", "chunked_list": ["import { Setting, ToggleComponent } from \"obsidian\";\n\timport ReadingViewEnhancer from \"src/main\";\n\t/**\n\t * Prevent table overflow setting component\n\t */\n\texport default class PreventTableOverflowingSetting extends Setting {\n\t\tplugin: ReadingViewEnhancer;\n\t\tconstructor(containerEl: HTMLElement, plugin: ReadingViewEnhancer) {\n\t\t\tsuper(containerEl);\n\t\t\tthis.plugin = plugin;\n", "\t\tthis.setName(\"Prevent Table Overflowing\")\n\t\t\t\t.setDesc(\n\t\t\t\t\t\"Make tables scrollable to prevent table overflowing. \" +\n\t\t\t\t\t\t\"In Obsidian v1.1.16, table with a long text makes a horizontal scroll bar on the whole view. \" +\n\t\t\t\t\t\t\"This setting prevents that.\"\n\t\t\t\t)\n\t\t\t\t.addToggle((toggle) => this.preventTableOverflowing(toggle));\n\t\t}\n\t\tpreventTableOverflowing(toggle: ToggleComponent) {\n\t\t\ttoggle.setValue(this.plugin.settings.preventTableOverflowing);\n", "\t\t// save on change\n\t\t\ttoggle.onChange((changed) => {\n\t\t\t\tthis.plugin.settings.preventTableOverflowing = changed;\n\t\t\t\tthis.plugin.saveSettings();\n\t\t\t\tthis.plugin.applyPreventTableOverflowing(true);\n\t\t\t});\n\t\t}\n\t}\n"]}
{"filename": "src/settings/miscellaneous/index.ts", "chunked_list": ["import ReadingViewEnhancer from \"src/main\";\n\timport AlwaysOnCollapseIndicatorSetting from \"./always-on-collapse-indicator\";\n\timport PreventTableOverflowingSetting from \"./prevent-table-overflow\";\n\timport ScrollableCodeSetting from \"./scrollable-code\";\n\t/**\n\t * Registers settings components not related to block.\n\t */\n\texport default class MiscellaneousSettings {\n\t\tconstructor(containerEl: HTMLElement, plugin: ReadingViewEnhancer) {\n\t\t\tcontainerEl.createEl(\"h2\", { text: \"Miscellaneous\" });\n", "\t\tnew AlwaysOnCollapseIndicatorSetting(containerEl, plugin);\n\t\t\tnew PreventTableOverflowingSetting(containerEl, plugin);\n\t\t\tnew ScrollableCodeSetting(containerEl, plugin);\n\t\t}\n\t}\n"]}
{"filename": "src/settings/block/block-selector.ts", "chunked_list": ["import { Setting, ToggleComponent } from \"obsidian\";\n\timport ReadingViewEnhancer from \"src/main\";\n\t/**\n\t * Enable block selector setting component\n\t */\n\texport default class EnableBlockSelectorSetting extends Setting {\n\t\tplugin: ReadingViewEnhancer;\n\t\tconstructor(containerEl: HTMLElement, plugin: ReadingViewEnhancer) {\n\t\t\tsuper(containerEl);\n\t\t\tthis.plugin = plugin;\n", "\t\tthis.setName(\"Enable Block Selector\")\n\t\t\t\t.setDesc(\n\t\t\t\t\t\"To take effect of changing this setting, \" +\n\t\t\t\t\t\t\"you can either reopen (close & open) reading views or restart Obsidian. \" +\n\t\t\t\t\t\t\"Alternatively, you can run the ‘Rerender all reading views’ command. \" +\n\t\t\t\t\t\t\"Please note that when you rerender reading views, the file title will disappear.\"\n\t\t\t\t)\n\t\t\t\t.addToggle((toggle) => this.setEnableSelector(toggle));\n\t\t}\n\t\t/**\n", "\t * Creates toggle component that enables/disables block selector.\n\t\t *\n\t\t * @param toggle {ToggleComponent} Toggle component\n\t\t */\n\t\tsetEnableSelector(toggle: ToggleComponent) {\n\t\t\ttoggle.setValue(this.plugin.settings.enableBlockSelector);\n\t\t\t// save on change\n\t\t\ttoggle.onChange((changed) => {\n\t\t\t\tthis.plugin.settings.enableBlockSelector = changed;\n\t\t\t\tthis.plugin.saveSettings();\n", "\t\t});\n\t\t}\n\t}\n"]}
{"filename": "src/settings/block/block-color.ts", "chunked_list": ["import { toHex } from \"color2k\";\n\timport { ButtonComponent, ColorComponent, Setting } from \"obsidian\";\n\timport ReadingViewEnhancer from \"src/main\";\n\t/**\n\t * Block color setting component\n\t */\n\texport default class BlockColorSetting extends Setting {\n\t\tplugin: ReadingViewEnhancer;\n\t\tworkspaceEl: HTMLElement;\n\t\tconstructor(settingsTabEl: HTMLElement, plugin: ReadingViewEnhancer) {\n", "\t\tsuper(settingsTabEl);\n\t\t\tthis.plugin = plugin;\n\t\t\tthis.setName(\"Block Color\")\n\t\t\t\t.setDesc(\n\t\t\t\t\t\"Set background color of the block in reading view. Transparency will be set automatically\"\n\t\t\t\t)\n\t\t\t\t.addColorPicker((color) => this.colorPicker(color));\n\t\t}\n\t\t/**\n\t\t * Creates color picker component.\n", "\t * Also, creates a button to set color to the current accent color.\n\t\t *\n\t\t * @param color {ColorComponent} Color component\n\t\t */\n\t\tcolorPicker(color: ColorComponent) {\n\t\t\tconst { settings } = this.plugin;\n\t\t\tcolor.setValue(settings.blockColor).onChange((changed) => {\n\t\t\t\t// save on change\n\t\t\t\tsettings.blockColor = toHex(changed);\n\t\t\t\tthis.plugin.saveSettings();\n", "\t\t\tthis.plugin.applyBlockColor(true);\n\t\t\t});\n\t\t\tthis.addButton((button) => this.accentColorButton(button, color));\n\t\t}\n\t\t/**\n\t\t * Creates a button to use current accent color.\n\t\t * Used in {@link colorPicker}.\n\t\t *\n\t\t * @param button {ButtonComponent} Button component\n\t\t * @param color {ColorComponent} Color component\n", "\t */\n\t\taccentColorButton(button: ButtonComponent, color: ColorComponent) {\n\t\t\tbutton.setButtonText(\"Use current accent color\").onClick(() => {\n\t\t\t\tconst accentColor = this.getAccentColor();\n\t\t\t\tcolor.setValue(accentColor);\n\t\t\t\tthis.plugin.settings.blockColor = accentColor;\n\t\t\t\tthis.plugin.saveSettings();\n\t\t\t\tthis.plugin.applyBlockColor(true);\n\t\t\t});\n\t\t}\n", "\t/**\n\t\t * Gets current accent color from Obsidian.\n\t\t *\n\t\t * @returns Current accent color in hex format\n\t\t */\n\t\tprivate getAccentColor(): string {\n\t\t\tconst workspaceEl = this.plugin.app.workspace.containerEl;\n\t\t\tconst accentColor = toHex(\n\t\t\t\tgetComputedStyle(workspaceEl).getPropertyValue(\"--color-accent\").trim()\n\t\t\t);\n", "\t\treturn accentColor;\n\t\t}\n\t}\n"]}
{"filename": "src/settings/block/block-selector-mobile.ts", "chunked_list": ["import { Setting, ToggleComponent } from \"obsidian\";\n\timport ReadingViewEnhancer from \"src/main\";\n\t/**\n\t * Disable block selector on mobile setting component\n\t */\n\texport default class DisableBlockSelectorOnMobileSetting extends Setting {\n\t\tplugin: ReadingViewEnhancer;\n\t\tconstructor(containerEl: HTMLElement, plugin: ReadingViewEnhancer) {\n\t\t\tsuper(containerEl);\n\t\t\tthis.plugin = plugin;\n", "\t\tthis.setName(\"Disable Block Selector on Mobile\")\n\t\t\t\t.setDesc(\n\t\t\t\t\t\"To take effect of changing this setting, \" +\n\t\t\t\t\t\t\"you can either reopen (close & open) reading views or restart Obsidian. \" +\n\t\t\t\t\t\t\"Alternatively, you can run the ‘Rerender all reading views’ command. \" +\n\t\t\t\t\t\t\"Please note that when you rerender reading views, the file title will disappear.\"\n\t\t\t\t)\n\t\t\t\t.addToggle((toggle) => this.setDisableSelectorOnMobile(toggle));\n\t\t}\n\t\t/**\n", "\t * Creates toggle component that enables/disables block selector on mobile.\n\t\t *\n\t\t * @param toggle {ToggleComponent} Toggle component\n\t\t */\n\t\tsetDisableSelectorOnMobile(toggle: ToggleComponent) {\n\t\t\ttoggle.setValue(this.plugin.settings.disableBlockSelectorOnMobile);\n\t\t\t// save on change\n\t\t\ttoggle.onChange((changed) => {\n\t\t\t\tthis.plugin.settings.disableBlockSelectorOnMobile = changed;\n\t\t\t\tthis.plugin.saveSettings();\n", "\t\t});\n\t\t}\n\t}\n"]}
{"filename": "src/settings/block/index.ts", "chunked_list": ["import ReadingViewEnhancer from \"src/main\";\n\timport BlockColorSetting from \"./block-color\";\n\timport EnableBlockSelectorSetting from \"./block-selector\";\n\timport DisableBlockSelectorOnMobileSetting from \"./block-selector-mobile\";\n\t/**\n\t * Registers settings components related to block selector.\n\t */\n\texport default class BlockSelectorSettings {\n\t\tconstructor(containerEl: HTMLElement, plugin: ReadingViewEnhancer) {\n\t\t\tcontainerEl.createEl(\"h2\", { text: \"Block Selector\" });\n", "\t\tnew BlockColorSetting(containerEl, plugin);\n\t\t\tnew EnableBlockSelectorSetting(containerEl, plugin);\n\t\t\tnew DisableBlockSelectorOnMobileSetting(containerEl, plugin);\n\t\t}\n\t}\n"]}
{"filename": "src/block-selector/selection-handler.ts", "chunked_list": ["import { BLOCK_ATTR, COLLAPSE_INDICATORS, SELECTED_BLOCK } from \"../constants\";\n\timport {\n\t\tfindNextBlock,\n\t\tfindPreviousBlock,\n\t\tisBottomInView,\n\t\tisTopInView,\n\t\tscrollBottomIntoView,\n\t\tscrollTopIntoView,\n\t} from \"./selection-util\";\n\t/**\n", " * Handle block selection.\n\t * This class is used by BlockSelector.\n\t */\n\texport default class SelectionHandler {\n\t\tselectedBlock: HTMLElement | null;\n\t\tconstructor() {\n\t\t\tthis.selectedBlock = null;\n\t\t}\n\t\t/**\n\t\t * Select block element\n", "\t *\n\t\t * @param block {HTMLElement} Block element\n\t\t */\n\t\tselect(block: HTMLElement) {\n\t\t\tblock.focus();\n\t\t\tblock.addClass(SELECTED_BLOCK);\n\t\t\tthis.selectedBlock = block;\n\t\t}\n\t\t/**\n\t\t * Unselect block element.\n", "\t * If there is no selected block, do nothing.\n\t\t *\n\t\t * @param block {HTMLElement} Block element\n\t\t */\n\t\tunselect() {\n\t\t\tif (this.selectedBlock) {\n\t\t\t\tthis.selectedBlock.removeClass(SELECTED_BLOCK);\n\t\t\t\tthis.selectedBlock.blur();\n\t\t\t\tthis.selectedBlock = null;\n\t\t\t}\n", "\t}\n\t\t/**\n\t\t * Trigger 'select' on clicked block element.\n\t\t *\n\t\t * @param e {MouseEvent} Mouse event\n\t\t */\n\t\tonBlockClick(e: MouseEvent) {\n\t\t\tconst target = e.target as HTMLElement;\n\t\t\tconst block = target.closest(`[${BLOCK_ATTR}=true]`);\n\t\t\tif (block instanceof HTMLElement) {\n", "\t\t\tthis.select(block);\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * On keydown, navigate between blocks or fold/unfold blocks.\n\t\t *\n\t\t * - `ArrowDown`: Select next block\n\t\t * - `ArrowUp`: Select previous block\n\t\t * - `ArrowLeft` & `ArrowRight`: Fold/Unfold block\n\t\t *\n", "\t * If selected block is too long,\n\t\t * `ArrowDown` and `ArrowUp` scrolls to see the element's bottom or top.\n\t\t * This is for loading adjacent blocks which are not in the DOM tree.\n\t\t *\n\t\t * @param e {KeyboardEvent} Keyboard event\n\t\t * @param scrollable {HTMLElement} Scrollable parent element\n\t\t */\n\t\tonKeyDown(e: KeyboardEvent) {\n\t\t\tconst block = e.target as HTMLElement;\n\t\t\tif (e.key === \"ArrowDown\") {\n", "\t\t\te.preventDefault();\n\t\t\t\tthis.selectNextBlockOrScroll(block);\n\t\t\t} else if (e.key === \"ArrowUp\") {\n\t\t\t\te.preventDefault();\n\t\t\t\tthis.selectPreviousBlockOrScroll(block);\n\t\t\t} else if (e.key === \"ArrowRight\" || e.key === \"ArrowLeft\") {\n\t\t\t\te.preventDefault();\n\t\t\t\tthis.toggleFold(block);\n\t\t\t} else if (e.key === \"Escape\") {\n\t\t\t\tthis.unselect();\n", "\t\t}\n\t\t}\n\t\t/**\n\t\t * Select next block or scroll to see the block's bottom.\n\t\t *\n\t\t * @param block {HTMLElement} Block element\n\t\t */\n\t\tprivate selectNextBlockOrScroll(block: HTMLElement) {\n\t\t\tif (!isBottomInView(block)) {\n\t\t\t\tscrollBottomIntoView(block);\n", "\t\t} else {\n\t\t\t\tconst next = findNextBlock(block);\n\t\t\t\tif (next) this.select(next as HTMLElement);\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Select previous block or scroll to see the block's top.\n\t\t *\n\t\t * @param block {HTMLElement} Block element\n\t\t */\n", "\tprivate selectPreviousBlockOrScroll(block: HTMLElement) {\n\t\t\tif (!isTopInView(block)) {\n\t\t\t\tscrollTopIntoView(block);\n\t\t\t} else {\n\t\t\t\tconst prev = findPreviousBlock(block);\n\t\t\t\tif (prev) this.select(prev as HTMLElement);\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Select top block in the view\n", "\t *\n\t\t * @param viewContainer {HTMLElement} View container element\n\t\t */\n\t\tselectTopBlockInTheView(viewContainer: HTMLElement) {\n\t\t\tconst blocks = viewContainer.querySelectorAll(`[${BLOCK_ATTR}=true]`);\n\t\t\t// If there is no block, do nothing\n\t\t\tif (blocks.length === 0) return;\n\t\t\t// Get the index of the topmost block in the view\n\t\t\tlet topIndex = -1;\n\t\t\tfor (let i = 0; i < blocks.length; i++) {\n", "\t\t\ttopIndex = i;\n\t\t\t\tconst rect = blocks[i].getBoundingClientRect();\n\t\t\t\tif (rect.bottom > 120) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst topBlock = blocks[topIndex];\n\t\t\tthis.select(topBlock as HTMLElement);\n\t\t}\n\t\t/**\n", "\t * Fold/Unfold block.\n\t\t *\n\t\t * @param block {HTMLElement} Block element\n\t\t */\n\t\tprivate toggleFold(block: HTMLElement) {\n\t\t\tconst collapseIndicator = block.querySelector(\n\t\t\t\tCOLLAPSE_INDICATORS.join(\",\")\n\t\t\t) as HTMLElement;\n\t\t\tif (collapseIndicator) {\n\t\t\t\tcollapseIndicator.click();\n", "\t\t}\n\t\t}\n\t}\n"]}
{"filename": "src/block-selector/index.ts", "chunked_list": ["import { MarkdownPostProcessorContext, Platform } from \"obsidian\";\n\timport ReadingViewEnhancer from \"src/main\";\n\timport SelectionHandler from \"./selection-handler\";\n\timport { BLOCKS, BLOCK_ATTR, BLOCK_SELECTOR, FRONTMATTER } from \"../constants\";\n\t/**\n\t * BlockSelector enables to navigate between blocks and fold/unfold blocks.\n\t *\n\t * Block elements are elements that are having block level elements.\n\t * For example, a paragraph is a block element.\n\t *\n", " * You can select a block by clicking on it and then use arrow keys to navigate between blocks.\n\t * For selected block, the background color will be changed.\n\t * You can also use `ArrowLeft` and `ArrowRight` to fold/unfold blocks.\n\t * Foldable blocks are having `collapse-indicator` or `callout-fold` class.\n\t */\n\texport default class BlockSelector {\n\t\tplugin: ReadingViewEnhancer;\n\t\tselectionHandler: SelectionHandler;\n\t\tselectedBlock: HTMLElement | null;\n\t\t/**\n", "\t * Initialize BlockSelector.\n\t\t * Register markdown post processor to blockify some elements.\n\t\t *\n\t\t * @param plugin {ReadingViewEnhancer} Plugin instance\n\t\t */\n\t\tconstructor(plugin: ReadingViewEnhancer) {\n\t\t\tthis.plugin = plugin;\n\t\t\tthis.selectionHandler = new SelectionHandler();\n\t\t}\n\t\t/**\n", "\t * Activate BlockSelector\n\t\t */\n\t\tactivate() {\n\t\t\tthis.plugin.registerMarkdownPostProcessor(this.blockify.bind(this));\n\t\t}\n\t\t/**\n\t\t * Select top block in the view\n\t\t *\n\t\t * @param viewContainer {HTMLElement} View container element\n\t\t */\n", "\tselectTopBlockInTheView(viewContainer: HTMLElement) {\n\t\t\tthis.selectionHandler.selectTopBlockInTheView(viewContainer);\n\t\t}\n\t\t/**\n\t\t * Blockify some elements.\n\t\t * If container is not initialized, initialize it.\n\t\t * Transform some elements to block elements.\n\t\t */\n\t\tprivate blockify(\n\t\t\telement: HTMLElement,\n", "\t\tcontext: MarkdownPostProcessorContext\n\t\t) {\n\t\t\t// If block selector is disabled, do nothing\n\t\t\tif (!this.plugin.settings.enableBlockSelector) return;\n\t\t\t// If it's mobile but block selector is disabled on mobile, do nothing\n\t\t\tif (\n\t\t\t\t(Platform.isMobile || Platform.isMobileApp) &&\n\t\t\t\tthis.plugin.settings.disableBlockSelectorOnMobile\n\t\t\t) {\n\t\t\t\treturn;\n", "\t\t}\n\t\t\t// @ts-ignore\n\t\t\tconst container = context?.containerEl;\n\t\t\tif (this.isContainerNotInitialized(container)) {\n\t\t\t\tthis.initializeContainer(container);\n\t\t\t}\n\t\t\tthis.elementsToBlocks(element);\n\t\t}\n\t\t/**\n\t\t * Check if container is initialized.\n", "\t *\n\t\t * @param container {MarkdownPostProcessorContext.containerEl} Container element\n\t\t * @returns {boolean} True if container is initialized\n\t\t */\n\t\tprivate isContainerNotInitialized(container: HTMLElement) {\n\t\t\treturn (\n\t\t\t\tcontainer instanceof HTMLElement && !container.hasClass(BLOCK_SELECTOR)\n\t\t\t);\n\t\t}\n\t\t/**\n", "\t * Initialize container.\n\t\t * Add some event listeners to container.\n\t\t *\n\t\t * @param container {MarkdownPostProcessorContext.containerEl} Container element\n\t\t */\n\t\tprivate initializeContainer(container: HTMLElement) {\n\t\t\t// Mark container as initialized\n\t\t\tcontainer.addClass(BLOCK_SELECTOR);\n\t\t\t// On click, select block element\n\t\t\tcontainer.addEventListener(\"click\", (e) =>\n", "\t\t\tthis.selectionHandler.onBlockClick(e)\n\t\t\t);\n\t\t\t// On focusout, unselect block element\n\t\t\tcontainer.addEventListener(\"focusout\", () =>\n\t\t\t\tthis.selectionHandler.unselect()\n\t\t\t);\n\t\t\t// On keydown, navigate between blocks or fold/unfold blocks\n\t\t\tcontainer.addEventListener(\"keydown\", (e) =>\n\t\t\t\tthis.selectionHandler.onKeyDown(e)\n\t\t\t);\n", "\t}\n\t\t/**\n\t\t * Set `data-rve-block` attribute to block elements.\n\t\t *\n\t\t * @param element {HTMLElement} Element to start searching\n\t\t */\n\t\tprivate elementsToBlocks(element: HTMLElement) {\n\t\t\tconst elements = element.querySelectorAll(BLOCKS.join(\", \"));\n\t\t\telements.forEach((el) => {\n\t\t\t\tif (el.hasClass(FRONTMATTER)) return;\n", "\t\t\tel.setAttribute(BLOCK_ATTR, \"true\");\n\t\t\t\tel.setAttribute(\"tabindex\", \"-1\");\n\t\t\t});\n\t\t}\n\t}\n"]}
{"filename": "src/block-selector/selection-util.ts", "chunked_list": ["import { BLOCK_ATTR, IS_COLLAPSED, MARKDOWN_PREVIEW_VIEW } from \"../constants\";\n\texport const isBottomInView = (block: HTMLElement) => {\n\t\tconst rect = block.getBoundingClientRect();\n\t\treturn rect.bottom <= window.innerHeight;\n\t};\n\texport const scrollBottomIntoView = (block: HTMLElement) => {\n\t\tconst rect = block.getBoundingClientRect();\n\t\tconst scrollable = getScrollParent(block);\n\t\tscrollable?.scrollBy({\n\t\t\tbehavior: \"auto\",\n", "\t\ttop: rect.bottom - scrollable.clientHeight + 200,\n\t\t});\n\t};\n\texport const isTopInView = (block: HTMLElement) => {\n\t\tconst rect = block.getBoundingClientRect();\n\t\treturn rect.top >= 0;\n\t};\n\texport const scrollTopIntoView = (block: HTMLElement) => {\n\t\tconst rect = block.getBoundingClientRect();\n\t\tconst scrollable = getScrollParent(block);\n", "\tscrollable?.scrollBy({\n\t\t\tbehavior: \"auto\",\n\t\t\ttop: rect.top - 200,\n\t\t});\n\t};\n\t/**\n\t * Find next block element to select.\n\t * Return null if there is no next block element.\n\t *\n\t * @param currentElement {HTMLElement} Current element to start searching\n", " * @returns {HTMLElement | null} Next block element\n\t */\n\texport const findNextBlock = (\n\t\tcurrentElement: HTMLElement\n\t): HTMLElement | null => {\n\t\tlet nextBlock = null;\n\t\t// Start by checking if there's a block element inside the current element\n\t\tif (!isCollapsed(currentElement)) {\n\t\t\tconst children = currentElement.children;\n\t\t\tfor (let i = 0; i < children.length; i++) {\n", "\t\t\tnextBlock = findBlock(children[i] as HTMLElement);\n\t\t\t\tif (nextBlock) return nextBlock;\n\t\t\t}\n\t\t}\n\t\t// Check next siblings of current element\n\t\tlet nextSibling = currentElement.nextElementSibling;\n\t\twhile (nextSibling) {\n\t\t\tnextBlock = findBlock(nextSibling as HTMLElement);\n\t\t\tif (nextBlock) return nextBlock;\n\t\t\tnextSibling = nextSibling.nextElementSibling;\n", "\t}\n\t\t// Check next siblings of parent block element\n\t\tlet parent = currentElement.parentElement;\n\t\twhile (parent && !parent.hasClass(MARKDOWN_PREVIEW_VIEW)) {\n\t\t\tlet parentSibling = parent.nextElementSibling;\n\t\t\twhile (parentSibling) {\n\t\t\t\tnextBlock = findBlock(parentSibling as HTMLElement);\n\t\t\t\tif (nextBlock) return nextBlock;\n\t\t\t\tparentSibling = parentSibling.nextElementSibling;\n\t\t\t}\n", "\t\tparent = parent.parentElement;\n\t\t}\n\t\t// If no block element found, return null\n\t\treturn null;\n\t};\n\t/**\n\t * Find previous block element to select.\n\t * Return null if there is no previous block element.\n\t *\n\t * @param currentElement {HTMLElement} Current element to start searching\n", " * @returns {HTMLElement | null} Previous block element\n\t */\n\texport const findPreviousBlock = (\n\t\tcurrentElement: HTMLElement\n\t): HTMLElement | null => {\n\t\t// Check previous siblings of current element\n\t\tlet prevSibling = currentElement.previousElementSibling;\n\t\twhile (prevSibling) {\n\t\t\tconst prevBlock = findLastBlock(prevSibling as HTMLElement);\n\t\t\tif (prevBlock) return prevBlock;\n", "\t\tprevSibling = prevSibling.previousElementSibling;\n\t\t}\n\t\t// Check previous siblings of parent block element\n\t\tlet parent = currentElement.parentElement;\n\t\twhile (parent && !parent.classList.contains(MARKDOWN_PREVIEW_VIEW)) {\n\t\t\t// Check ancestors of current element first\n\t\t\tif (isBlock(parent)) return parent;\n\t\t\tlet parentSibling = parent.previousElementSibling;\n\t\t\twhile (parentSibling) {\n\t\t\t\tconst prevBlock = findLastBlock(parentSibling as HTMLElement);\n", "\t\t\tif (prevBlock) return prevBlock;\n\t\t\t\tparentSibling = parentSibling.previousElementSibling;\n\t\t\t}\n\t\t\tparent = parent.parentElement;\n\t\t}\n\t\t// If no block element found, return null\n\t\treturn null;\n\t};\n\t/**\n\t * Check if the given element is collapsed\n", " *\n\t * @param element {HTMLElement} Element to check\n\t * @returns {boolean} True if the element is collapsed\n\t */\n\tconst isCollapsed = (element: HTMLElement) => {\n\t\treturn element.hasClass(IS_COLLAPSED);\n\t};\n\t/**\n\t * Find first block element inside the given element\n\t *\n", " * @param element {HTMLElement} Element to search\n\t * @returns {HTMLElement | null} First block element\n\t */\n\tconst findBlock = (element: HTMLElement): HTMLElement | null => {\n\t\tif (isBlock(element)) {\n\t\t\treturn element;\n\t\t}\n\t\tlet block = null;\n\t\tconst childElements = element.children;\n\t\tfor (let i = 0; i < childElements.length; i++) {\n", "\t\tblock = findBlock(childElements[i] as HTMLElement);\n\t\t\tif (block) return block;\n\t\t}\n\t\treturn null;\n\t};\n\t/**\n\t * Find last block element inside the given element\n\t *\n\t * @param element {HTMLElement} Element to search\n\t * @returns {HTMLElement | null} Last block element\n", " */\n\tconst findLastBlock = (element: HTMLElement): HTMLElement | null => {\n\t\tif (isCollapsed(element) && isBlock(element)) return element;\n\t\tlet block = null;\n\t\tconst childElements = element.children;\n\t\tfor (let i = childElements.length - 1; i >= 0; i--) {\n\t\t\tblock = findLastBlock(childElements[i] as HTMLElement);\n\t\t\tif (block) return block;\n\t\t}\n\t\tif (isBlock(element)) return element;\n", "\telse return null;\n\t};\n\t/**\n\t * Check if the given element is a block element\n\t *\n\t * @param element {HTMLElement} Element to check\n\t * @returns {boolean} True if the element is a block element\n\t */\n\tconst isBlock = (element: HTMLElement) => {\n\t\treturn element.getAttribute(BLOCK_ATTR) === \"true\";\n", "};\n\t/**\n\t * Return the scrollable parent element of the given element\n\t *\n\t * @param node {HTMLElement} Element to start searching\n\t * @returns {HTMLElement | null} Scrollable parent element\n\t */\n\tconst getScrollParent = (node: HTMLElement): HTMLElement | null => {\n\t\tif (node == null) return null;\n\t\tif (node.scrollHeight > node.clientHeight) {\n", "\t\treturn node;\n\t\t} else {\n\t\t\treturn getScrollParent(node.parentNode as HTMLElement);\n\t\t}\n\t};\n"]}
