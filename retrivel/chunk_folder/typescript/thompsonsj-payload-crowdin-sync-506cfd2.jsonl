{"filename": "jest.config.ts", "chunked_list": ["import type { Config } from \"jest\";\n\tconst config: Config = {\n\t  verbose: true,\n\t  modulePathIgnorePatterns: [\"dist\"],\n\t  testEnvironment: \"node\",\n\t  // globalSetup: '<rootDir>/dev/src/tests/globalSetup.ts',\n\t  roots: [\"<rootDir>/src/\", \"<rootDir>/dev/\"],\n\t};\n\texport default config;\n"]}
{"filename": "dev/src/payload-types.ts", "chunked_list": ["/* tslint:disable */\n\t/* eslint-disable */\n\t/**\n\t * This file was automatically generated by Payload.\n\t * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,\n\t * and re-run `payload generate:types` to regenerate this file.\n\t */\n\texport interface Config {\n\t  collections: {\n\t    categories: Category;\n", "    \"localized-posts\": LocalizedPost;\n\t    \"nested-field-collection\": NestedFieldCollection;\n\t    posts: Post;\n\t    tags: Tag;\n\t    users: User;\n\t    \"crowdin-files\": CrowdinFile;\n\t    \"crowdin-collection-directories\": CrowdinCollectionDirectory;\n\t    \"crowdin-article-directories\": CrowdinArticleDirectory;\n\t  };\n\t  globals: {\n", "    nav: Nav;\n\t  };\n\t}\n\texport interface Category {\n\t  id: string;\n\t  name?: string;\n\t}\n\texport interface LocalizedPost {\n\t  id: string;\n\t  title?: string;\n", "  author?: string | User;\n\t  publishedDate?: string;\n\t  category?: string | Category;\n\t  tags?: string[] | Tag[];\n\t  content?: {\n\t    [k: string]: unknown;\n\t  }[];\n\t  status?: \"draft\" | \"published\";\n\t  crowdinArticleDirectory?: string | CrowdinArticleDirectory;\n\t  updatedAt: string;\n", "  createdAt: string;\n\t}\n\texport interface User {\n\t  id: string;\n\t  name?: string;\n\t  updatedAt: string;\n\t  createdAt: string;\n\t  email: string;\n\t  resetPasswordToken?: string;\n\t  resetPasswordExpiration?: string;\n", "  salt?: string;\n\t  hash?: string;\n\t  loginAttempts?: number;\n\t  lockUntil?: string;\n\t  password?: string;\n\t}\n\texport interface Tag {\n\t  id: string;\n\t  name?: string;\n\t}\n", "export interface CrowdinArticleDirectory {\n\t  id: string;\n\t  name?: string;\n\t  crowdinCollectionDirectory?: string | CrowdinCollectionDirectory;\n\t  crowdinFiles?: string[] | CrowdinFile[];\n\t  createdAt: string;\n\t  updatedAt: string;\n\t  originalId?: number;\n\t  projectId?: number;\n\t  directoryId?: number;\n", "  excludeLocales?: (\"de_DE\" | \"fr_FR\")[];\n\t}\n\texport interface CrowdinCollectionDirectory {\n\t  id: string;\n\t  name?: string;\n\t  title?: string;\n\t  collectionSlug?: string;\n\t  createdAt: string;\n\t  updatedAt: string;\n\t  originalId?: number;\n", "  projectId?: number;\n\t  directoryId?: number;\n\t}\n\texport interface CrowdinFile {\n\t  id: string;\n\t  title?: string;\n\t  field?: string;\n\t  crowdinArticleDirectory?: string | CrowdinArticleDirectory;\n\t  createdAt: string;\n\t  updatedAt: string;\n", "  originalId?: number;\n\t  projectId?: number;\n\t  directoryId?: number;\n\t  revisionId?: number;\n\t  name?: string;\n\t  type?: string;\n\t  path?: string;\n\t  fileData?: {\n\t    json?:\n\t      | {\n", "          [k: string]: unknown;\n\t        }\n\t      | unknown[]\n\t      | string\n\t      | number\n\t      | boolean\n\t      | null;\n\t    html?: string;\n\t  };\n\t}\n", "export interface NestedFieldCollection {\n\t  id: string;\n\t  textField?: string;\n\t  richTextField?: {\n\t    [k: string]: unknown;\n\t  }[];\n\t  textareaField?: string;\n\t  arrayField?: {\n\t    textField?: string;\n\t    richTextField?: {\n", "      [k: string]: unknown;\n\t    }[];\n\t    textareaField?: string;\n\t    id?: string;\n\t  }[];\n\t  layout?: (\n\t    | {\n\t        textField?: string;\n\t        richTextField?: {\n\t          [k: string]: unknown;\n", "        }[];\n\t        textareaField?: string;\n\t        id?: string;\n\t        blockName?: string;\n\t        blockType: \"basicBlock\";\n\t      }\n\t    | {\n\t        richTextField?: {\n\t          [k: string]: unknown;\n\t        }[];\n", "        id?: string;\n\t        blockName?: string;\n\t        blockType: \"basicBlockRichText\";\n\t      }\n\t    | {\n\t        textField?: string;\n\t        richTextField?: {\n\t          [k: string]: unknown;\n\t        }[];\n\t        textareaField?: string;\n", "        id?: string;\n\t        blockName?: string;\n\t        blockType: \"basicBlockMixed\";\n\t      }\n\t    | {\n\t        title?: string;\n\t        messages?: {\n\t          title?: string;\n\t          message?: {\n\t            [k: string]: unknown;\n", "          }[];\n\t          id?: string;\n\t        }[];\n\t        id?: string;\n\t        blockName?: string;\n\t        blockType: \"testBlockArrayOfRichText\";\n\t      }\n\t  )[];\n\t  group?: {\n\t    textField?: string;\n", "    richTextField?: {\n\t      [k: string]: unknown;\n\t    }[];\n\t    textareaField?: string;\n\t  };\n\t  tabOneTitle?: string;\n\t  tabOneContent?: {\n\t    [k: string]: unknown;\n\t  }[];\n\t  tabTwo: {\n", "    tabTwoTitle?: string;\n\t    tabTwoContent?: {\n\t      [k: string]: unknown;\n\t    }[];\n\t  };\n\t  crowdinArticleDirectory?: string | CrowdinArticleDirectory;\n\t  updatedAt: string;\n\t  createdAt: string;\n\t}\n\texport interface Post {\n", "  id: string;\n\t  title?: string;\n\t  author?: string | User;\n\t  publishedDate?: string;\n\t  category?: string | Category;\n\t  tags?: string[] | Tag[];\n\t  content?: {\n\t    [k: string]: unknown;\n\t  }[];\n\t  status?: \"draft\" | \"published\";\n", "  updatedAt: string;\n\t  createdAt: string;\n\t}\n\texport interface Nav {\n\t  id: string;\n\t  items: {\n\t    label?: string;\n\t    id?: string;\n\t  }[];\n\t  crowdinArticleDirectory?: string | CrowdinArticleDirectory;\n", "  updatedAt?: string;\n\t  createdAt?: string;\n\t}\n"]}
{"filename": "dev/src/payload.config.ts", "chunked_list": ["import { buildConfig } from \"payload/config\";\n\timport path from \"path\";\n\timport Nav from \"./globals/Nav\";\n\timport Categories from \"./collections/Categories\";\n\timport LocalizedPosts from \"./collections/LocalizedPosts\";\n\timport Posts from \"./collections/Posts\";\n\timport NestedFieldCollection from \"./collections/NestedFieldCollection\";\n\timport Tags from \"./collections/Tags\";\n\timport Users from \"./collections/Users\";\n\timport { resolve } from \"path\";\n", "import { crowdinSync } from \"../../dist\";\n\timport dotenv from \"dotenv\";\n\tdotenv.config({\n\t  path: resolve(__dirname, \"../.env\"),\n\t});\n\texport const localeMap = {\n\t  de_DE: {\n\t    crowdinId: \"de\",\n\t  },\n\t  fr_FR: {\n", "    crowdinId: \"fr\",\n\t  },\n\t};\n\texport default buildConfig({\n\t  serverURL: process.env.PAYLOAD_PUBLIC_SERVER_URL || \"http://localhost:3000\",\n\t  admin: {\n\t    user: Users.slug,\n\t  },\n\t  plugins: [\n\t    crowdinSync({\n", "      projectId: 323731,\n\t      directoryId: 1169,\n\t      token: `fake-token`, // CrowdIn API is mocked but we need a token to pass schema validation\n\t      localeMap,\n\t      sourceLocale: \"en\",\n\t    }),\n\t  ],\n\t  collections: [\n\t    Categories,\n\t    LocalizedPosts,\n", "    NestedFieldCollection,\n\t    Posts,\n\t    Tags,\n\t    Users,\n\t  ],\n\t  globals: [Nav],\n\t  localization: {\n\t    locales: [\"en\", ...Object.keys(localeMap)],\n\t    defaultLocale: \"en\",\n\t    fallback: true,\n", "  },\n\t  typescript: {\n\t    outputFile: path.resolve(__dirname, \"payload-types.ts\"),\n\t  },\n\t  graphQL: {\n\t    schemaOutputFile: path.resolve(__dirname, \"generated-schema.graphql\"),\n\t  },\n\t});\n"]}
{"filename": "dev/src/server.ts", "chunked_list": ["import express from \"express\";\n\timport payload from \"payload\";\n\timport { resolve } from \"path\";\n\trequire(\"dotenv\").config({\n\t  path: resolve(__dirname, \"../.env\"),\n\t});\n\tconst app = express();\n\t// Redirect root to Admin panel\n\tapp.get(\"/\", (_, res) => {\n\t  res.redirect(\"/admin\");\n", "});\n\t// Initialize Payload\n\tpayload.init({\n\t  secret: process.env.PAYLOAD_SECRET,\n\t  mongoURL: process.env.MONGODB_URI,\n\t  express: app,\n\t  onInit: () => {\n\t    payload.logger.info(`Payload Admin URL: ${payload.getAdminURL()}`);\n\t  },\n\t});\n", "// Add your own express routes here\n\tapp.listen(3000);\n"]}
{"filename": "dev/src/collections/Categories.ts", "chunked_list": ["import { CollectionConfig } from \"payload/types\";\n\tconst Categories: CollectionConfig = {\n\t  slug: \"categories\",\n\t  admin: {\n\t    useAsTitle: \"name\",\n\t  },\n\t  access: {\n\t    read: () => true,\n\t  },\n\t  fields: [\n", "    {\n\t      name: \"name\",\n\t      type: \"text\",\n\t    },\n\t  ],\n\t  timestamps: false,\n\t};\n\texport default Categories;\n"]}
{"filename": "dev/src/collections/NestedFieldCollection.ts", "chunked_list": ["import { Block, CollectionConfig } from \"payload/types\";\n\timport { basicLocalizedFields } from \"./fields/basicLocalizedFields\";\n\tconst BasicBlockTextFields: Block = {\n\t  slug: \"basicBlock\", // required\n\t  fields: basicLocalizedFields,\n\t};\n\tconst BasicBlockRichTextField: Block = {\n\t  slug: \"basicBlockRichText\", // required\n\t  fields: [\n\t    {\n", "      name: \"richTextField\",\n\t      type: \"richText\",\n\t      localized: true,\n\t    },\n\t  ],\n\t};\n\tconst BasicBlockMixedFields: Block = {\n\t  slug: \"basicBlockMixed\", // required\n\t  fields: [\n\t    ...basicLocalizedFields,\n", "    {\n\t      name: \"richTextField\",\n\t      type: \"richText\",\n\t      localized: true,\n\t    },\n\t  ],\n\t};\n\tconst TestBlockArrayOfRichText: Block = {\n\t  slug: \"testBlockArrayOfRichText\",\n\t  fields: [\n", "    {\n\t      name: \"title\",\n\t      type: \"text\",\n\t      localized: true,\n\t    },\n\t    {\n\t      name: \"messages\",\n\t      type: \"array\",\n\t      localized: true,\n\t      maxRows: 3,\n", "      fields: [\n\t        {\n\t          name: \"title\",\n\t          type: \"text\",\n\t          localized: true,\n\t        },\n\t        {\n\t          name: \"message\",\n\t          type: \"richText\",\n\t        },\n", "      ],\n\t    },\n\t  ],\n\t};\n\tconst NestedFieldCollection: CollectionConfig = {\n\t  slug: \"nested-field-collection\",\n\t  access: {\n\t    read: () => true,\n\t  },\n\t  fields: [\n", "    ...basicLocalizedFields,\n\t    // array\n\t    {\n\t      name: \"arrayField\",\n\t      type: \"array\",\n\t      fields: [...basicLocalizedFields],\n\t    },\n\t    // blocks\n\t    {\n\t      name: \"layout\", // required\n", "      type: \"blocks\", // required\n\t      blocks: [\n\t        BasicBlockTextFields,\n\t        BasicBlockRichTextField,\n\t        BasicBlockMixedFields,\n\t        TestBlockArrayOfRichText,\n\t      ],\n\t    },\n\t    // collapsible\n\t    /*{\n", "      label: 'Collapsible',\n\t      type: 'collapsible',\n\t      fields: basicLocalizedFields,\n\t    },*/\n\t    // group\n\t    {\n\t      name: \"group\", // required\n\t      type: \"group\", // required\n\t      fields: basicLocalizedFields,\n\t    },\n", "    // tabs\n\t    {\n\t      type: \"tabs\", // required\n\t      tabs: [\n\t        {\n\t          label: \"Tab One Label\", // required\n\t          fields: [\n\t            {\n\t              name: \"tabOneTitle\",\n\t              type: \"text\",\n", "              localized: true,\n\t            },\n\t            {\n\t              name: \"tabOneContent\",\n\t              type: \"richText\",\n\t              localized: true,\n\t            },\n\t          ],\n\t        },\n\t        {\n", "          name: \"tabTwo\",\n\t          label: \"Tab Two Label\",\n\t          fields: [\n\t            {\n\t              name: \"tabTwoTitle\",\n\t              type: \"text\",\n\t              localized: true,\n\t            },\n\t            {\n\t              name: \"tabTwoContent\",\n", "              type: \"richText\",\n\t              localized: true,\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    },\n\t  ],\n\t};\n\texport default NestedFieldCollection;\n"]}
{"filename": "dev/src/collections/Users.ts", "chunked_list": ["import { CollectionConfig } from \"payload/types\";\n\tconst Users: CollectionConfig = {\n\t  slug: \"users\",\n\t  auth: true,\n\t  admin: {\n\t    useAsTitle: \"email\",\n\t  },\n\t  access: {\n\t    read: () => true,\n\t  },\n", "  fields: [\n\t    // Email added by default\n\t    {\n\t      name: \"name\",\n\t      type: \"text\",\n\t    },\n\t  ],\n\t};\n\texport default Users;\n"]}
{"filename": "dev/src/collections/Tags.ts", "chunked_list": ["import { CollectionConfig } from \"payload/types\";\n\tconst Tags: CollectionConfig = {\n\t  slug: \"tags\",\n\t  admin: {\n\t    useAsTitle: \"name\",\n\t  },\n\t  access: {\n\t    read: () => true,\n\t  },\n\t  fields: [\n", "    {\n\t      name: \"name\",\n\t      type: \"text\",\n\t    },\n\t  ],\n\t  timestamps: false,\n\t};\n\texport default Tags;\n"]}
{"filename": "dev/src/collections/LocalizedPosts.ts", "chunked_list": ["import { CollectionConfig } from \"payload/types\";\n\tconst Posts: CollectionConfig = {\n\t  slug: \"localized-posts\",\n\t  admin: {\n\t    defaultColumns: [\"title\", \"author\", \"category\", \"tags\", \"status\"],\n\t    useAsTitle: \"title\",\n\t  },\n\t  access: {\n\t    read: () => true,\n\t  },\n", "  fields: [\n\t    {\n\t      name: \"title\",\n\t      type: \"text\",\n\t      localized: true,\n\t    },\n\t    {\n\t      name: \"author\",\n\t      type: \"relationship\",\n\t      relationTo: \"users\",\n", "    },\n\t    {\n\t      name: \"publishedDate\",\n\t      type: \"date\",\n\t    },\n\t    {\n\t      name: \"category\",\n\t      type: \"relationship\",\n\t      relationTo: \"categories\",\n\t    },\n", "    {\n\t      name: \"tags\",\n\t      type: \"relationship\",\n\t      relationTo: \"tags\",\n\t      hasMany: true,\n\t    },\n\t    {\n\t      name: \"content\",\n\t      type: \"richText\",\n\t      localized: true,\n", "    },\n\t    {\n\t      name: \"status\",\n\t      type: \"select\",\n\t      options: [\n\t        {\n\t          value: \"draft\",\n\t          label: \"Draft\",\n\t        },\n\t        {\n", "          value: \"published\",\n\t          label: \"Published\",\n\t        },\n\t      ],\n\t      defaultValue: \"draft\",\n\t      admin: {\n\t        position: \"sidebar\",\n\t      },\n\t    },\n\t  ],\n", "};\n\texport default Posts;\n"]}
{"filename": "dev/src/collections/Posts.ts", "chunked_list": ["import { CollectionConfig } from \"payload/types\";\n\tconst Posts: CollectionConfig = {\n\t  slug: \"posts\",\n\t  admin: {\n\t    defaultColumns: [\"title\", \"author\", \"category\", \"tags\", \"status\"],\n\t    useAsTitle: \"title\",\n\t  },\n\t  access: {\n\t    read: () => true,\n\t  },\n", "  fields: [\n\t    {\n\t      name: \"title\",\n\t      type: \"text\",\n\t    },\n\t    {\n\t      name: \"author\",\n\t      type: \"relationship\",\n\t      relationTo: \"users\",\n\t    },\n", "    {\n\t      name: \"publishedDate\",\n\t      type: \"date\",\n\t    },\n\t    {\n\t      name: \"category\",\n\t      type: \"relationship\",\n\t      relationTo: \"categories\",\n\t    },\n\t    {\n", "      name: \"tags\",\n\t      type: \"relationship\",\n\t      relationTo: \"tags\",\n\t      hasMany: true,\n\t    },\n\t    {\n\t      name: \"content\",\n\t      type: \"richText\",\n\t    },\n\t    {\n", "      name: \"status\",\n\t      type: \"select\",\n\t      options: [\n\t        {\n\t          value: \"draft\",\n\t          label: \"Draft\",\n\t        },\n\t        {\n\t          value: \"published\",\n\t          label: \"Published\",\n", "        },\n\t      ],\n\t      defaultValue: \"draft\",\n\t      admin: {\n\t        position: \"sidebar\",\n\t      },\n\t    },\n\t  ],\n\t};\n\texport default Posts;\n"]}
{"filename": "dev/src/collections/fields/basicLocalizedFields.ts", "chunked_list": ["import { Field } from \"payload/types\";\n\texport const basicLocalizedFields: Field[] = [\n\t  {\n\t    name: \"textField\",\n\t    type: \"text\",\n\t    localized: true,\n\t  },\n\t  {\n\t    name: \"richTextField\",\n\t    type: \"richText\",\n", "    localized: true,\n\t  },\n\t  {\n\t    name: \"textareaField\",\n\t    type: \"textarea\",\n\t    localized: true,\n\t  },\n\t];\n"]}
{"filename": "dev/src/tests/files.test.ts", "chunked_list": ["import mongoose from \"mongoose\";\n\timport payload from \"payload\";\n\timport { initPayloadTest } from \"./helpers/config\";\n\timport {\n\t  getFileByDocumentID,\n\t  getFilesByDocumentID,\n\t  getArticleDirectory,\n\t} from \"../../../dist/api/helpers\";\n\t/**\n\t * Test files\n", " *\n\t * Ensure that files are created for Crowdin as expected.\n\t *\n\t * Note: This test suite is not intended to test file contents.\n\t * This is the responsibility of buildCrowdinHtmlObject and\n\t * buildCrowdinJsonObject which are unit tested in `src/utilities`.\n\t */\n\tconst collections = {\n\t  nonLocalized: \"posts\",\n\t  localized: \"localized-posts\",\n", "  nestedFields: \"nested-field-collection\",\n\t};\n\tdescribe(`Crowdin file create, update and delete`, () => {\n\t  beforeAll(async () => {\n\t    await initPayloadTest({ __dirname });\n\t  });\n\t  afterAll(async () => {\n\t    await mongoose.connection.dropDatabase();\n\t    await mongoose.connection.close();\n\t    await payload.mongoMemoryServer.stop();\n", "  });\n\t  describe(`Collection: ${collections.localized}`, () => {\n\t    it(\"updates the `fields` file for a new article\", async () => {\n\t      const post = await payload.create({\n\t        collection: collections.localized,\n\t        data: { title: \"Test post\" },\n\t      });\n\t      const file = await getFileByDocumentID(\"fields\", post.id, payload);\n\t      expect(file.fileData.json).toEqual({ title: \"Test post\" });\n\t    });\n", "    it(\"updates the `fields` file if a text field has changed\", async () => {\n\t      const post = await payload.create({\n\t        collection: collections.localized,\n\t        data: { title: \"Test post\" },\n\t      });\n\t      const file = await getFileByDocumentID(\"fields\", post.id, payload);\n\t      const updatedPost = await payload.update({\n\t        id: post.id,\n\t        collection: collections.localized,\n\t        data: { title: \"Test post updated\" },\n", "      });\n\t      const updatedFile = await getFileByDocumentID(\"fields\", post.id, payload);\n\t      expect(file.updatedAt).not.toEqual(updatedFile.updatedAt);\n\t      expect(updatedFile.fileData.json).toEqual({ title: \"Test post updated\" });\n\t    });\n\t  });\n\t  describe(`Collection: ${collections.nestedFields}`, () => {\n\t    it(\"does not create files for empty localized fields\", async () => {\n\t      const article = await payload.create({\n\t        collection: collections.nestedFields,\n", "        data: {},\n\t      });\n\t      const crowdinFiles = await getFilesByDocumentID(article.id, payload);\n\t      expect(crowdinFiles.length).toEqual(0);\n\t    });\n\t    it(\"creates files containing fieldType content\", async () => {\n\t      const article = await payload.create({\n\t        collection: collections.nestedFields,\n\t        locale: \"en\",\n\t        data: {\n", "          textField: \"Test title\",\n\t          richTextField: [\n\t            {\n\t              children: [\n\t                {\n\t                  text: \"Test content\",\n\t                },\n\t              ],\n\t            },\n\t          ],\n", "          textareaField: \"Test meta description\",\n\t        },\n\t      });\n\t      const crowdinFiles = await getFilesByDocumentID(article.id, payload);\n\t      expect(crowdinFiles.length).toEqual(2);\n\t      expect(\n\t        crowdinFiles.find((file) => file.name === \"richTextField.html\")\n\t      ).toBeDefined();\n\t      expect(\n\t        crowdinFiles.find((file) => file.name === \"fields.json\")\n", "      ).toBeDefined();\n\t    });\n\t    it(\"creates files containing `array` fieldType content\", async () => {\n\t      const article = await payload.create({\n\t        collection: collections.nestedFields,\n\t        data: {\n\t          arrayField: [\n\t            {\n\t              textField: \"Test title 1\",\n\t              richTextField: [\n", "                {\n\t                  children: [\n\t                    {\n\t                      text: \"Test content 1\",\n\t                    },\n\t                  ],\n\t                },\n\t              ],\n\t              textareaField: \"Test meta description 1\",\n\t            },\n", "            {\n\t              textField: \"Test title 2\",\n\t              richTextField: [\n\t                {\n\t                  children: [\n\t                    {\n\t                      text: \"Test content 2\",\n\t                    },\n\t                  ],\n\t                },\n", "              ],\n\t              textareaField: \"Test meta description 2\",\n\t            },\n\t          ],\n\t        },\n\t      });\n\t      const ids = article.arrayField.map((item) => item.id);\n\t      const crowdinFiles = await getFilesByDocumentID(article.id, payload);\n\t      expect(crowdinFiles.length).toEqual(3);\n\t      expect(\n", "        crowdinFiles.find(\n\t          (file) => file.name === `arrayField.${ids[0]}.richTextField.html`\n\t        )\n\t      ).toBeDefined();\n\t      expect(\n\t        crowdinFiles.find(\n\t          (file) => file.name === `arrayField.${ids[1]}.richTextField.html`\n\t        )\n\t      ).toBeDefined();\n\t      expect(\n", "        crowdinFiles.find((file) => file.name === \"fields.json\")\n\t      ).toBeDefined();\n\t    });\n\t    it(\"creates files containing `blocks` fieldType content\", async () => {\n\t      const article = await payload.create({\n\t        collection: collections.nestedFields,\n\t        data: {\n\t          layout: [\n\t            {\n\t              textField: \"Test title 1\",\n", "              richTextField: [\n\t                {\n\t                  children: [\n\t                    {\n\t                      text: \"Test content 1\",\n\t                    },\n\t                  ],\n\t                },\n\t              ],\n\t              textareaField: \"Test meta description 1\",\n", "              blockType: \"basicBlock\",\n\t            },\n\t            {\n\t              messages: [\n\t                {\n\t                  message: [\n\t                    {\n\t                      children: [\n\t                        {\n\t                          text: \"Test content 1\",\n", "                        },\n\t                      ],\n\t                    },\n\t                  ],\n\t                  id: \"64735620230d57bce946d370\",\n\t                },\n\t                {\n\t                  message: [\n\t                    {\n\t                      children: [\n", "                        {\n\t                          text: \"Test content 1\",\n\t                        },\n\t                      ],\n\t                    },\n\t                  ],\n\t                  id: \"64735621230d57bce946d371\",\n\t                },\n\t              ],\n\t              blockType: \"testBlockArrayOfRichText\",\n", "            },\n\t          ],\n\t        },\n\t      });\n\t      const blockIds = article.layout.map((item) => item.id);\n\t      const blockTypes = article.layout.map((item) => item.blockType);\n\t      const arrayIds = article.layout[1].messages.map((item) => item.id);\n\t      const crowdinFiles = await getFilesByDocumentID(article.id, payload);\n\t      expect(crowdinFiles.length).toEqual(4);\n\t      const jsonFile = crowdinFiles.find((file) => file.name === \"fields.json\");\n", "      expect(\n\t        crowdinFiles.find(\n\t          (file) =>\n\t            file.name ===\n\t            `layout.${blockIds[0]}.${blockTypes[0]}.richTextField.html`\n\t        )\n\t      ).toBeDefined();\n\t      expect(\n\t        crowdinFiles.find(\n\t          (file) =>\n", "            file.name ===\n\t            `layout.${blockIds[1]}.${blockTypes[1]}.messages.${arrayIds[0]}.message.html`\n\t        )\n\t      ).toBeDefined();\n\t      expect(\n\t        crowdinFiles.find(\n\t          (file) =>\n\t            file.name ===\n\t            `layout.${blockIds[1]}.${blockTypes[1]}.messages.${arrayIds[1]}.message.html`\n\t        )\n", "      ).toBeDefined();\n\t      expect(jsonFile).toBeDefined();\n\t      expect(jsonFile.fileData.json).toEqual({\n\t        layout: {\n\t          [blockIds[0]]: {\n\t            basicBlock: {\n\t              textareaField: \"Test meta description 1\",\n\t              textField: \"Test title 1\",\n\t            },\n\t          },\n", "        },\n\t      });\n\t    });\n\t    it(\"deletes the `fields` file when an existing article is deleted\", async () => {\n\t      const post = await payload.create({\n\t        collection: collections.localized,\n\t        data: { title: \"Test post\" },\n\t      });\n\t      const file = await getFileByDocumentID(\"fields\", post.id, payload);\n\t      expect(file.fileData.json).toEqual({ title: \"Test post\" });\n", "      const deletedPost = await payload.delete({\n\t        collection: collections.localized,\n\t        id: post.id,\n\t      });\n\t      const crowdinFiles = await getFilesByDocumentID(post.id, payload);\n\t      expect(crowdinFiles.length).toEqual(0);\n\t    });\n\t    it(\"deletes the collection Crowdin article directory when an existing article is deleted\", async () => {\n\t      const post = await payload.create({\n\t        collection: collections.localized,\n", "        data: { title: \"Test post\" },\n\t      });\n\t      const file = await getFileByDocumentID(\"fields\", post.id, payload);\n\t      expect(file.fileData.json).toEqual({ title: \"Test post\" });\n\t      const deletedPost = await payload.delete({\n\t        collection: collections.localized,\n\t        id: post.id,\n\t      });\n\t      const crowdinPayloadArticleDirectory = await getArticleDirectory(\n\t        post.id,\n", "        payload\n\t      );\n\t      expect(crowdinPayloadArticleDirectory).toBeUndefined();\n\t    });\n\t  });\n\t});\n"]}
{"filename": "dev/src/tests/translations.test.ts", "chunked_list": ["import mongoose from \"mongoose\";\n\timport payload from \"payload\";\n\timport { initPayloadTest } from \"./helpers/config\";\n\timport { payloadCrowdinSyncTranslationsApi } from \"../../../dist/api/payload-crowdin-sync/translations\";\n\timport nock from \"nock\";\n\timport { payloadCreateData } from \"./fixtures/nested-field-collection/simple-blocks.fixture\";\n\timport { payloadCreateBlocksRichTextData } from \"./fixtures/nested-field-collection/rich-text-blocks.fixture\";\n\t/**\n\t * Test translations\n\t *\n", " * Ensure translations are retrieved, compared, and\n\t * stored as expected.\n\t */\n\tconst collections = {\n\t  nonLocalized: \"posts\",\n\t  localized: \"localized-posts\",\n\t  nestedFields: \"nested-field-collection\",\n\t};\n\tconst pluginOptions = {\n\t  projectId: 323731,\n", "  directoryId: 1169,\n\t  token: process.env.CROWDIN_TOKEN,\n\t  localeMap: {\n\t    de_DE: {\n\t      crowdinId: \"de\",\n\t    },\n\t    fr_FR: {\n\t      crowdinId: \"fr\",\n\t    },\n\t  },\n", "  sourceLocale: \"en\",\n\t};\n\tdescribe(\"Translations\", () => {\n\t  beforeAll(async () => {\n\t    await initPayloadTest({ __dirname });\n\t  });\n\t  afterEach(async () => {\n\t    nock.cleanAll();\n\t  });\n\t  afterAll(async () => {\n", "    await mongoose.connection.dropDatabase();\n\t    await mongoose.connection.close();\n\t    await payload.mongoMemoryServer.stop();\n\t  });\n\t  describe(\"fn: getTranslation\", () => {\n\t    it(\"retrieves a translation from Crowdin\", async () => {\n\t      const post = await payload.create({\n\t        collection: collections.localized,\n\t        data: { title: \"Test post\" },\n\t      });\n", "      const translationsApi = new payloadCrowdinSyncTranslationsApi(\n\t        pluginOptions,\n\t        payload\n\t      );\n\t      const scope = nock(\"https://api.crowdin.com\")\n\t        .get(\n\t          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de\"\n\t        )\n\t        .reply(200, {\n\t          title: \"Testbeitrag\",\n", "        })\n\t        .get(\n\t          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"\n\t        )\n\t        .reply(200, {\n\t          title: \"Poste d'essai\",\n\t        });\n\t      const translation = await translationsApi.getTranslation({\n\t        documentId: post.id,\n\t        fieldName: \"fields\",\n", "        locale: \"de_DE\",\n\t      });\n\t      expect(translation).toEqual({\n\t        title: \"Testbeitrag\",\n\t      });\n\t    });\n\t  });\n\t  describe(\"fn: updateTranslation\", () => {\n\t    it(\"updates a Payload article with a `text` field translation retrieved from Crowdin\", async () => {\n\t      const post = await payload.create({\n", "        collection: collections.localized,\n\t        data: { title: \"Test post\" },\n\t      });\n\t      const translationsApi = new payloadCrowdinSyncTranslationsApi(\n\t        pluginOptions,\n\t        payload\n\t      );\n\t      const scope = nock(\"https://api.crowdin.com\")\n\t        .get(\n\t          `/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de`\n", "        )\n\t        .reply(200, {\n\t          title: \"Testbeitrag\",\n\t        })\n\t        .get(\n\t          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"\n\t        )\n\t        .reply(200, {\n\t          title: \"Poste d'essai\",\n\t        });\n", "      const translation = await translationsApi.updateTranslation({\n\t        documentId: post.id,\n\t        collection: collections.localized,\n\t        dryRun: false,\n\t      });\n\t      // retrieve translated post from Payload\n\t      const result = await payload.findByID({\n\t        collection: collections.localized,\n\t        id: post.id,\n\t        locale: \"de_DE\",\n", "      });\n\t      expect(result.title).toEqual(\"Testbeitrag\");\n\t    });\n\t    it(\"updates a Payload article with a `richText` field translation retrieved from Crowdin\", async () => {\n\t      const post = await payload.create({\n\t        collection: collections.localized,\n\t        data: {\n\t          content: [\n\t            {\n\t              children: [\n", "                {\n\t                  text: \"Test content\",\n\t                },\n\t              ],\n\t            },\n\t          ],\n\t        },\n\t      });\n\t      const translationsApi = new payloadCrowdinSyncTranslationsApi(\n\t        pluginOptions,\n", "        payload\n\t      );\n\t      const scope = nock(\"https://api.crowdin.com\")\n\t        .get(\n\t          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de\"\n\t        )\n\t        .reply(200, \"<p>Testbeitrag</p>\")\n\t        .get(\n\t          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"\n\t        )\n", "        .reply(200, {\n\t          title: \"Poste d'essai\",\n\t        });\n\t      const translation = await translationsApi.updateTranslation({\n\t        documentId: post.id,\n\t        collection: collections.localized,\n\t        dryRun: false,\n\t      });\n\t      // retrieve translated post from Payload\n\t      const result = await payload.findByID({\n", "        collection: collections.localized,\n\t        id: post.id,\n\t        locale: \"de_DE\",\n\t      });\n\t      expect(result.content).toEqual([\n\t        {\n\t          children: [{ text: \"Testbeitrag\" }],\n\t          type: \"p\",\n\t        },\n\t      ]);\n", "    });\n\t    it(\"updates a Payload article with a *blocks* field translation retrieved from Crowdin\", async () => {\n\t      const post = await payload.create({\n\t        collection: collections.nestedFields,\n\t        data: payloadCreateData,\n\t      });\n\t      // we need the ids created by Payload to update the blocks\n\t      const blockIds = post.layout.map((block) => block.id);\n\t      const blockTypes = post.layout.map((block) => block.blockType);\n\t      const responseDe = {\n", "        layout: {\n\t          [blockIds[0]]: {\n\t            [blockTypes[0]]: {\n\t              textField: \"Textfeldinhalt im Block bei Layoutindex 0\",\n\t              textareaField:\n\t                \"Textbereichsfeldinhalt im Block bei Layoutindex 0\",\n\t            },\n\t          },\n\t          [blockIds[1]]: {\n\t            [blockTypes[1]]: {\n", "              textField: \"Textfeldinhalt im Block bei Layoutindex 1\",\n\t              textareaField:\n\t                \"Textbereichsfeldinhalt im Block bei Layoutindex 1\",\n\t            },\n\t          },\n\t        },\n\t      };\n\t      const responseFr = {\n\t        layout: {\n\t          [blockIds[0]]: {\n", "            [blockTypes[0]]: {\n\t              textField:\n\t                \"Contenu du champ de texte dans le bloc à l'index de mise en page 0\",\n\t              textareaField:\n\t                \"Contenu du champ Textarea dans le bloc à l'index de mise en page 0\",\n\t            },\n\t          },\n\t          [blockIds[1]]: {\n\t            [blockTypes[1]]: {\n\t              textField:\n", "                \"Contenu du champ de texte dans le bloc à l'index de mise en page 1\",\n\t              textareaField:\n\t                \"Contenu du champ Textarea dans le bloc à l'index de mise en page 1\",\n\t            },\n\t          },\n\t        },\n\t      };\n\t      const translationsApi = new payloadCrowdinSyncTranslationsApi(\n\t        pluginOptions,\n\t        payload\n", "      );\n\t      const scope = nock(\"https://api.crowdin.com\")\n\t        .get(\n\t          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de\"\n\t        )\n\t        .reply(200, responseDe)\n\t        .get(\n\t          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"\n\t        )\n\t        .reply(200, responseFr);\n", "      const translation = await translationsApi.updateTranslation({\n\t        documentId: post.id,\n\t        collection: collections.nestedFields,\n\t        dryRun: false,\n\t      });\n\t      // retrieve translated post from Payload\n\t      const resultDe = await payload.findByID({\n\t        collection: collections.nestedFields,\n\t        id: post.id,\n\t        locale: \"de_DE\",\n", "      });\n\t      expect(resultDe.layout).toEqual([\n\t        {\n\t          textField: \"Textfeldinhalt im Block bei Layoutindex 0\",\n\t          textareaField: \"Textbereichsfeldinhalt im Block bei Layoutindex 0\",\n\t          id: blockIds[0],\n\t          blockType: \"basicBlock\",\n\t        },\n\t        {\n\t          textField: \"Textfeldinhalt im Block bei Layoutindex 1\",\n", "          textareaField: \"Textbereichsfeldinhalt im Block bei Layoutindex 1\",\n\t          id: blockIds[1],\n\t          blockType: \"basicBlock\",\n\t        },\n\t      ]);\n\t      // retrieve translated post from Payload\n\t      const resultFr = await payload.findByID({\n\t        collection: collections.nestedFields,\n\t        id: post.id,\n\t        locale: \"fr_FR\",\n", "      });\n\t      expect(resultFr.layout).toEqual([\n\t        {\n\t          textField:\n\t            \"Contenu du champ de texte dans le bloc à l'index de mise en page 0\",\n\t          textareaField:\n\t            \"Contenu du champ Textarea dans le bloc à l'index de mise en page 0\",\n\t          id: blockIds[0],\n\t          blockType: \"basicBlock\",\n\t        },\n", "        {\n\t          textField:\n\t            \"Contenu du champ de texte dans le bloc à l'index de mise en page 1\",\n\t          textareaField:\n\t            \"Contenu du champ Textarea dans le bloc à l'index de mise en page 1\",\n\t          id: blockIds[1],\n\t          blockType: \"basicBlock\",\n\t        },\n\t      ]);\n\t    });\n", "    it(\"updates a Payload article with a *blocks* field translation retrieved from Crowdin and detects no change on the next update attempt\", async () => {\n\t      const post = await payload.create({\n\t        collection: collections.nestedFields,\n\t        data: payloadCreateData,\n\t      });\n\t      // we need the ids created by Payload to update the blocks\n\t      const blockIds = post.layout.map((block) => block.id);\n\t      const blockTypes = post.layout.map((block) => block.blockType);\n\t      const responseDe = {\n\t        layout: {\n", "          [blockIds[0]]: {\n\t            [blockTypes[0]]: {\n\t              textField: \"Textfeldinhalt im Block bei Layoutindex 0\",\n\t              textareaField:\n\t                \"Textbereichsfeldinhalt im Block bei Layoutindex 0\",\n\t            },\n\t          },\n\t          [blockIds[1]]: {\n\t            [blockTypes[1]]: {\n\t              textField: \"Textfeldinhalt im Block bei Layoutindex 1\",\n", "              textareaField:\n\t                \"Textbereichsfeldinhalt im Block bei Layoutindex 1\",\n\t            },\n\t          },\n\t        },\n\t      };\n\t      const responseFr = {\n\t        layout: {\n\t          [blockIds[0]]: {\n\t            [blockTypes[0]]: {\n", "              textField:\n\t                \"Contenu du champ de texte dans le bloc à l'index de mise en page 0\",\n\t              textareaField:\n\t                \"Contenu du champ Textarea dans le bloc à l'index de mise en page 0\",\n\t            },\n\t          },\n\t          [blockIds[1]]: {\n\t            [blockTypes[1]]: {\n\t              textField:\n\t                \"Contenu du champ de texte dans le bloc à l'index de mise en page 1\",\n", "              textareaField:\n\t                \"Contenu du champ Textarea dans le bloc à l'index de mise en page 1\",\n\t            },\n\t          },\n\t        },\n\t      };\n\t      const translationsApi = new payloadCrowdinSyncTranslationsApi(\n\t        pluginOptions,\n\t        payload\n\t      );\n", "      const scope = nock(\"https://api.crowdin.com\")\n\t        .get(\n\t          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de\"\n\t        )\n\t        .reply(200, responseDe)\n\t        .get(\n\t          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"\n\t        )\n\t        .reply(200, responseFr);\n\t      const translation = await translationsApi.updateTranslation({\n", "        documentId: post.id,\n\t        collection: collections.nestedFields,\n\t        dryRun: false,\n\t      });\n\t      // retrieve translated post from Payload\n\t      const resultDe = await payload.findByID({\n\t        collection: collections.nestedFields,\n\t        id: post.id,\n\t        locale: \"de_DE\",\n\t      });\n", "      expect(resultDe.layout).toEqual([\n\t        {\n\t          textField: \"Textfeldinhalt im Block bei Layoutindex 0\",\n\t          textareaField: \"Textbereichsfeldinhalt im Block bei Layoutindex 0\",\n\t          id: blockIds[0],\n\t          blockType: \"basicBlock\",\n\t        },\n\t        {\n\t          textField: \"Textfeldinhalt im Block bei Layoutindex 1\",\n\t          textareaField: \"Textbereichsfeldinhalt im Block bei Layoutindex 1\",\n", "          id: blockIds[1],\n\t          blockType: \"basicBlock\",\n\t        },\n\t      ]);\n\t      // retrieve translated post from Payload\n\t      const resultFr = await payload.findByID({\n\t        collection: collections.nestedFields,\n\t        id: post.id,\n\t        locale: \"fr_FR\",\n\t      });\n", "      expect(resultFr.layout).toEqual([\n\t        {\n\t          textField:\n\t            \"Contenu du champ de texte dans le bloc à l'index de mise en page 0\",\n\t          textareaField:\n\t            \"Contenu du champ Textarea dans le bloc à l'index de mise en page 0\",\n\t          id: blockIds[0],\n\t          blockType: \"basicBlock\",\n\t        },\n\t        {\n", "          textField:\n\t            \"Contenu du champ de texte dans le bloc à l'index de mise en page 1\",\n\t          textareaField:\n\t            \"Contenu du champ Textarea dans le bloc à l'index de mise en page 1\",\n\t          id: blockIds[1],\n\t          blockType: \"basicBlock\",\n\t        },\n\t      ]);\n\t      const nextScope = nock(\"https://api.crowdin.com\")\n\t        .get(\n", "          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de\"\n\t        )\n\t        .reply(200, responseDe)\n\t        .get(\n\t          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"\n\t        )\n\t        .reply(200, responseFr);\n\t      const nextTranslation = await translationsApi.updateTranslation({\n\t        documentId: post.id,\n\t        collection: collections.nestedFields,\n", "        dryRun: false,\n\t      });\n\t      expect(nextTranslation.translations[\"de_DE\"].changed).toBe(false);\n\t      expect(nextTranslation.translations[\"fr_FR\"].changed).toBe(false);\n\t    });\n\t    it(\"updates a Payload article with *blocks* rich text translations retrieved from Crowdin\", async () => {\n\t      const post = await payload.create({\n\t        collection: collections.nestedFields,\n\t        data: payloadCreateBlocksRichTextData,\n\t      });\n", "      // we need the ids created by Payload to update the blocks\n\t      const blockIds = post.layout.map((block) => block.id);\n\t      const blockTypes = post.layout.map((block) => block.blockType);\n\t      const responseDeOne =\n\t        \"<p>Rich-Text-Inhalt im Blocklayout bei Index 0.</p>\";\n\t      const responseDeTwo =\n\t        \"<p>Rich-Text-Inhalt im Blocklayout bei Index 1.</p>\";\n\t      const responseFrOne =\n\t        \"<p>Contenu de texte enrichi dans la disposition des blocs à l'index 0.</p>\";\n\t      const responseFrTwo =\n", "        \"<p>Contenu de texte enrichi dans la disposition des blocs à l'index 1.</p>\";\n\t      const translationsApi = new payloadCrowdinSyncTranslationsApi(\n\t        pluginOptions,\n\t        payload\n\t      );\n\t      const scope = nock(\"https://api.crowdin.com\")\n\t        .get(\n\t          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de\"\n\t        )\n\t        .reply(200, responseDeTwo)\n", "        .get(\n\t          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=de\"\n\t        )\n\t        .reply(200, responseDeOne)\n\t        .get(\n\t          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"\n\t        )\n\t        .reply(200, responseFrTwo)\n\t        .get(\n\t          \"/api/v2/projects/1/translations/builds/1/download?targetLanguageId=fr\"\n", "        )\n\t        .reply(200, responseFrOne);\n\t      const translation = await translationsApi.updateTranslation({\n\t        documentId: post.id,\n\t        collection: collections.nestedFields,\n\t        dryRun: false,\n\t      });\n\t      // retrieve translated post from Payload\n\t      const resultDe = await payload.findByID({\n\t        collection: collections.nestedFields,\n", "        id: post.id,\n\t        locale: \"de_DE\",\n\t      });\n\t      expect(resultDe.layout).toEqual([\n\t        {\n\t          richTextField: [\n\t            {\n\t              children: [\n\t                {\n\t                  text: \"Rich-Text-Inhalt im Blocklayout bei Index 0.\",\n", "                },\n\t              ],\n\t              type: \"p\",\n\t            },\n\t          ],\n\t          id: blockIds[0],\n\t          blockType: \"basicBlockRichText\",\n\t        },\n\t        {\n\t          richTextField: [\n", "            {\n\t              children: [\n\t                {\n\t                  text: \"Rich-Text-Inhalt im Blocklayout bei Index 1.\",\n\t                },\n\t              ],\n\t              type: \"p\",\n\t            },\n\t          ],\n\t          id: blockIds[1],\n", "          blockType: \"basicBlockRichText\",\n\t        },\n\t      ]);\n\t      // retrieve translated post from Payload\n\t      const resultFr = await payload.findByID({\n\t        collection: collections.nestedFields,\n\t        id: post.id,\n\t        locale: \"fr_FR\",\n\t      });\n\t      expect(resultFr.layout).toEqual([\n", "        {\n\t          richTextField: [\n\t            {\n\t              children: [\n\t                {\n\t                  text: \"Contenu de texte enrichi dans la disposition des blocs à l'index 0.\",\n\t                },\n\t              ],\n\t              type: \"p\",\n\t            },\n", "          ],\n\t          id: blockIds[0],\n\t          blockType: \"basicBlockRichText\",\n\t        },\n\t        {\n\t          richTextField: [\n\t            {\n\t              children: [\n\t                {\n\t                  text: \"Contenu de texte enrichi dans la disposition des blocs à l'index 1.\",\n", "                },\n\t              ],\n\t              type: \"p\",\n\t            },\n\t          ],\n\t          id: blockIds[1],\n\t          blockType: \"basicBlockRichText\",\n\t        },\n\t      ]);\n\t    });\n", "  });\n\t});\n"]}
{"filename": "dev/src/tests/collections.test.ts", "chunked_list": ["import mongoose from \"mongoose\";\n\timport payload from \"payload\";\n\timport { initPayloadTest } from \"./helpers/config\";\n\timport {\n\t  getFilesByDocumentID,\n\t  getFileByDocumentID,\n\t} from \"../../../dist/api/helpers\";\n\t/**\n\t * Test the collections\n\t *\n", " * Ensure plugin collections are created and\n\t * behave as expected.\n\t *\n\t * Collections to test:\n\t *\n\t * - crowdin-article-directories\n\t * - crowdin-files\n\t * - crowdin-collection-directories\n\t *\n\t * Terminology:\n", " *\n\t * - article directory: Crowdin Article Directory\n\t * - collection directory: Crowdin Collection Directory\n\t * - file: Crowdin File\n\t */\n\tconst collections = {\n\t  nonLocalized: \"posts\",\n\t  localized: \"localized-posts\",\n\t};\n\tdescribe(\"Collections\", () => {\n", "  beforeAll(async () => {\n\t    await initPayloadTest({ __dirname });\n\t  });\n\t  afterAll(async () => {\n\t    await mongoose.connection.dropDatabase();\n\t    await mongoose.connection.close();\n\t    await payload.mongoMemoryServer.stop();\n\t  });\n\t  describe(\"Non-localized collections\", () => {\n\t    it(\"does not create an article directory\", async () => {\n", "      const post = await payload.create({\n\t        collection: collections.nonLocalized,\n\t        data: { title: \"Test post\" },\n\t      });\n\t      const result = await payload.findByID({\n\t        collection: collections.nonLocalized,\n\t        id: post.id,\n\t      });\n\t      const crowdinArticleDirectoryId = result.crowdinArticleDirectory?.id;\n\t      expect(crowdinArticleDirectoryId).toBeUndefined();\n", "    });\n\t  });\n\t  describe(\"crowdin-article-directories\", () => {\n\t    it(\"creates an article directory\", async () => {\n\t      const post = await payload.create({\n\t        collection: collections.localized,\n\t        data: { title: \"Test post\" },\n\t      });\n\t      // retrieve post to get populated fields\n\t      const result = await payload.findByID({\n", "        collection: collections.localized,\n\t        id: post.id,\n\t      });\n\t      const crowdinArticleDirectoryId = result.crowdinArticleDirectory?.id;\n\t      expect(crowdinArticleDirectoryId).toBeDefined();\n\t    });\n\t    it(\"creates only one article directory\", async () => {\n\t      const post = await payload.create({\n\t        collection: collections.localized,\n\t        data: { title: \"Test post\" },\n", "      });\n\t      // retrieve post to get populated fields\n\t      const postRefreshed = await payload.findByID({\n\t        collection: collections.localized,\n\t        id: post.id,\n\t      });\n\t      const crowdinArticleDirectoryId =\n\t        postRefreshed.crowdinArticleDirectory?.id;\n\t      const updatedPost = await payload.update({\n\t        id: post.id,\n", "        collection: collections.localized,\n\t        data: { title: \"Updated test post\" },\n\t      });\n\t      // retrieve post to get populated fields\n\t      const updatedPostRefreshed = await payload.findByID({\n\t        collection: collections.localized,\n\t        id: updatedPost.id,\n\t      });\n\t      expect(updatedPostRefreshed.crowdinArticleDirectory?.id).toEqual(\n\t        crowdinArticleDirectoryId\n", "      );\n\t    });\n\t    it(\"creates unique article directories for two articles created in the same collection\", async () => {\n\t      const postOne = await payload.create({\n\t        collection: collections.localized,\n\t        data: { title: \"Test post 1\" },\n\t      });\n\t      // retrieve post to get populated fields\n\t      const postOneRefreshed = await payload.findByID({\n\t        collection: collections.localized,\n", "        id: postOne.id,\n\t      });\n\t      const postTwo = await payload.create({\n\t        collection: collections.localized,\n\t        data: { title: \"Test post 2\" },\n\t      });\n\t      // retrieve post to get populated fields\n\t      const postTwoRefreshed = await payload.findByID({\n\t        collection: collections.localized,\n\t        id: postTwo.id,\n", "      });\n\t      expect(postOneRefreshed.crowdinArticleDirectory.id).not.toEqual(\n\t        postTwoRefreshed.crowdinArticleDirectory.id\n\t      );\n\t    });\n\t  });\n\t  describe(\"crowdin-files\", () => {\n\t    it('creates a \"fields\" Crowdin file to include the title field', async () => {\n\t      const post = await payload.create({\n\t        collection: collections.localized,\n", "        data: { title: \"Test post\" },\n\t      });\n\t      const crowdinFiles = await getFilesByDocumentID(post.id, payload);\n\t      expect(crowdinFiles.length).toEqual(1);\n\t      const file = crowdinFiles.find((doc) => doc.field === \"fields\");\n\t      expect(file).not.toEqual(undefined);\n\t      expect(file.type).toEqual(\"json\");\n\t    });\n\t    it('does not create a \"fields\" Crowdin file if all fields are empty strings', async () => {\n\t      const post = await payload.create({\n", "        collection: collections.localized,\n\t        data: { title: \"\" },\n\t      });\n\t      const crowdinFiles = await getFilesByDocumentID(post.id, payload);\n\t      expect(crowdinFiles.length).toEqual(0);\n\t    });\n\t    const fieldsAndContentTestName =\n\t      \"creates a `fields` file to include the title field and a `content` file for the content richText field\";\n\t    it(`${fieldsAndContentTestName}`, async () => {\n\t      const post = await payload.create({\n", "        collection: collections.localized,\n\t        data: {\n\t          title: `${fieldsAndContentTestName}`,\n\t          content: [\n\t            {\n\t              children: [\n\t                {\n\t                  text: `${fieldsAndContentTestName}`,\n\t                },\n\t              ],\n", "            },\n\t          ],\n\t        },\n\t      });\n\t      const crowdinFiles = await getFilesByDocumentID(post.id, payload);\n\t      expect(crowdinFiles.length).toEqual(2);\n\t      const fields = crowdinFiles.find((doc) => doc.field === \"fields\");\n\t      const content = crowdinFiles.find((doc) => doc.field === \"content\");\n\t      expect(fields).not.toEqual(undefined);\n\t      expect(fields.type).toEqual(\"json\");\n", "      expect(content).not.toEqual(undefined);\n\t      expect(content.type).toEqual(\"html\");\n\t    });\n\t  });\n\t  describe(\"crowdin-collection-directories\", () => {\n\t    it(\"associates an article Directory with a collection directory\", async () => {\n\t      const post = await payload.create({\n\t        collection: collections.localized,\n\t        data: { title: \"Test post\" },\n\t      });\n", "      // retrieve post to get populated fields\n\t      const result = await payload.findByID({\n\t        collection: collections.localized,\n\t        id: post.id,\n\t      });\n\t      const crowdinArticleDirectoryId = result.crowdinArticleDirectory?.id;\n\t      expect(crowdinArticleDirectoryId).toBeDefined();\n\t      expect(\n\t        result.crowdinArticleDirectory.crowdinCollectionDirectory.name\n\t      ).toEqual(collections.localized);\n", "    });\n\t    it(\"uses the same collection directory for two articles created in the same collection\", async () => {\n\t      const postOne = await payload.create({\n\t        collection: collections.localized,\n\t        data: { title: \"Test post 1\" },\n\t      });\n\t      // retrieve post to get populated fields\n\t      const postOneRefreshed = await payload.findByID({\n\t        collection: collections.localized,\n\t        id: postOne.id,\n", "      });\n\t      const postTwo = await payload.create({\n\t        collection: collections.localized,\n\t        data: { title: \"Test post 2\" },\n\t      });\n\t      // retrieve post to get populated fields\n\t      const postTwoRefreshed = await payload.findByID({\n\t        collection: collections.localized,\n\t        id: postTwo.id,\n\t      });\n", "      expect(\n\t        postOneRefreshed.crowdinArticleDirectory.crowdinCollectionDirectory\n\t      ).toEqual(\n\t        postTwoRefreshed.crowdinArticleDirectory.crowdinCollectionDirectory\n\t      );\n\t    });\n\t  });\n\t});\n"]}
{"filename": "dev/src/tests/fixtures/nested-field-collection/simple-blocks.fixture.ts", "chunked_list": ["export const payloadCreateData = {\n\t  layout: [\n\t    {\n\t      textField: \"Text field content in block at layout index 0\",\n\t      textareaField: \"Textarea field content in block at layout index 0\",\n\t      blockType: \"basicBlock\",\n\t    },\n\t    {\n\t      textField: \"Text field content in block at layout index 1\",\n\t      textareaField: \"Textarea field content in block at layout index 1\",\n", "      blockType: \"basicBlock\",\n\t    },\n\t  ],\n\t};\n"]}
{"filename": "dev/src/tests/fixtures/nested-field-collection/rich-text-blocks.fixture.ts", "chunked_list": ["export const payloadCreateBlocksRichTextData = {\n\t  layout: [\n\t    {\n\t      richTextField: [\n\t        {\n\t          children: [\n\t            {\n\t              text: \"Rich text content in block layout at index 0.\",\n\t            },\n\t          ],\n", "        },\n\t      ],\n\t      blockType: \"basicBlockRichText\",\n\t    },\n\t    {\n\t      richTextField: [\n\t        {\n\t          children: [\n\t            {\n\t              text: \"Rich text content in block layout at index 1.\",\n", "            },\n\t          ],\n\t        },\n\t      ],\n\t      blockType: \"basicBlockRichText\",\n\t    },\n\t  ],\n\t};\n"]}
{"filename": "dev/src/tests/helpers/config.ts", "chunked_list": ["import payload from \"payload\";\n\timport swcRegister from \"@swc/register\";\n\timport { v4 as uuid } from \"uuid\";\n\timport type { InitOptions } from \"payload/dist/config/types\";\n\timport path from \"path\";\n\timport express from \"express\";\n\ttype Options = {\n\t  __dirname: string;\n\t  init?: Partial<InitOptions>;\n\t};\n", "export async function initPayloadTest(\n\t  options: Options\n\t): Promise<{ serverURL: string }> {\n\t  const initOptions = {\n\t    local: true,\n\t    secret: uuid(),\n\t    mongoURL: `mongodb://localhost/${uuid()}`,\n\t    ...(options.init || {}),\n\t  };\n\t  process.env.NODE_ENV = \"test\";\n", "  process.env.PAYLOAD_CONFIG_PATH = path.resolve(\n\t    options.__dirname,\n\t    \"./../payload.config.ts\"\n\t  );\n\t  const port = process.env.PORT || 3000;\n\t  if (!initOptions?.local) {\n\t    initOptions.express = express();\n\t  }\n\t  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t  // @ts-ignore - bad @swc/register types\n", "  swcRegister({\n\t    sourceMaps: \"inline\",\n\t    jsc: {\n\t      parser: {\n\t        syntax: \"typescript\",\n\t        tsx: true,\n\t      },\n\t    },\n\t    module: {\n\t      type: \"commonjs\",\n", "    },\n\t  });\n\t  await payload.init(initOptions);\n\t  if (initOptions.express) {\n\t    initOptions.express.listen(port);\n\t  }\n\t  return { serverURL: `http://localhost:${port}` };\n\t}\n"]}
{"filename": "dev/src/globals/Nav.ts", "chunked_list": ["import { GlobalConfig } from \"payload/types\";\n\tconst Nav: GlobalConfig = {\n\t  slug: \"nav\",\n\t  fields: [\n\t    {\n\t      name: \"items\",\n\t      type: \"array\",\n\t      required: true,\n\t      maxRows: 8,\n\t      fields: [\n", "        {\n\t          name: \"label\",\n\t          type: \"text\",\n\t          localized: true,\n\t        },\n\t      ],\n\t    },\n\t  ],\n\t};\n\texport default Nav;\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { Field } from \"payload/types\";\n\texport interface CollectionOptions {\n\t  directory?: string;\n\t}\n\texport interface PluginOptions {\n\t  projectId: number;\n\t  /** This should be optional? */\n\t  directoryId?: number;\n\t  token: string;\n\t  //client: crowdinAPIService,\n", "  localeMap: {\n\t    [key: string]: {\n\t      crowdinId: string;\n\t    };\n\t  };\n\t  sourceLocale: string;\n\t  collections?: Record<string, CollectionOptions>;\n\t}\n\texport type FieldWithName = Field & { name: string };\n"]}
{"filename": "src/plugin.ts", "chunked_list": ["import type { Config } from \"payload/config\";\n\timport type { PluginOptions } from \"./types\";\n\timport {\n\t  getAfterChangeHook,\n\t  getGlobalAfterChangeHook,\n\t} from \"./hooks/collections/afterChange\";\n\timport { getAfterDeleteHook } from \"./hooks/collections/afterDelete\";\n\timport { getFields } from \"./fields/getFields\";\n\timport CrowdinFiles from \"./collections/CrowdinFiles\";\n\timport CrowdinCollectionDirectories from \"./collections/CrowdinCollectionDirectories\";\n", "import CrowdinArticleDirectories from \"./collections/CrowdinArticleDirectories\";\n\timport { containsLocalizedFields } from \"./utilities\";\n\timport { getReviewTranslationEndpoint } from \"./endpoints/globals/reviewTranslation\";\n\timport { getReviewFieldsEndpoint } from \"./endpoints/globals/reviewFields\";\n\timport Joi from \"joi\";\n\t/**\n\t * This plugin extends all collections that contain localized fields\n\t * by uploading all translation-enabled field content in the default\n\t * language to Crowdin for translation. Crowdin translations are\n\t * are synced to fields in all other locales (except the default language).\n", " *\n\t **/\n\texport const crowdinSync =\n\t  (pluginOptions: PluginOptions) =>\n\t  (config: Config): Config => {\n\t    const initFunctions: (() => void)[] = [];\n\t    // schema validation\n\t    const schema = Joi.object({\n\t      projectId: Joi.number().required(),\n\t      directoryId: Joi.number(),\n", "      // optional - if not provided, the plugin will not do anything in the afterChange hook.\n\t      token: Joi.string().required(),\n\t      localeMap: Joi.object().pattern(\n\t        /./,\n\t        Joi.object({\n\t          crowdinId: Joi.string().required(),\n\t        }).pattern(/./, Joi.any())\n\t      ),\n\t      sourceLocale: Joi.string().required(),\n\t    });\n", "    const validate = schema.validate(pluginOptions);\n\t    if (validate.error) {\n\t      console.log(\n\t        \"Payload Crowdin Sync option validation errors:\",\n\t        validate.error\n\t      );\n\t    }\n\t    return {\n\t      ...config,\n\t      admin: {\n", "        ...(config.admin || {}),\n\t      },\n\t      collections: [\n\t        ...(config.collections || []).map((existingCollection) => {\n\t          if (containsLocalizedFields({ fields: existingCollection.fields })) {\n\t            const fields = getFields({\n\t              collection: existingCollection,\n\t            });\n\t            return {\n\t              ...existingCollection,\n", "              hooks: {\n\t                ...(existingCollection.hooks || {}),\n\t                afterChange: [\n\t                  ...(existingCollection.hooks?.afterChange || []),\n\t                  getAfterChangeHook({\n\t                    collection: existingCollection,\n\t                    pluginOptions,\n\t                  }),\n\t                ],\n\t                afterDelete: [\n", "                  ...(existingCollection.hooks?.afterDelete || []),\n\t                  getAfterDeleteHook({\n\t                    pluginOptions,\n\t                  }),\n\t                ],\n\t              },\n\t              fields,\n\t            };\n\t          }\n\t          return existingCollection;\n", "        }),\n\t        CrowdinFiles,\n\t        CrowdinCollectionDirectories,\n\t        {\n\t          ...CrowdinArticleDirectories,\n\t          fields: [\n\t            ...(CrowdinArticleDirectories.fields || []),\n\t            {\n\t              name: \"excludeLocales\",\n\t              type: \"select\",\n", "              options: Object.keys(pluginOptions.localeMap),\n\t              hasMany: true,\n\t              admin: {\n\t                description:\n\t                  \"Select locales to exclude from translation synchronization.\",\n\t              },\n\t            },\n\t          ],\n\t          endpoints: [\n\t            ...(CrowdinArticleDirectories.endpoints || []),\n", "            getReviewTranslationEndpoint({\n\t              pluginOptions,\n\t            }),\n\t            getReviewTranslationEndpoint({\n\t              pluginOptions,\n\t              type: \"update\",\n\t            }),\n\t            getReviewFieldsEndpoint({\n\t              pluginOptions\n\t            })\n", "          ],\n\t        },\n\t      ],\n\t      globals: [\n\t        ...(config.globals || []).map((existingGlobal) => {\n\t          if (containsLocalizedFields({ fields: existingGlobal.fields })) {\n\t            const fields = getFields({\n\t              collection: existingGlobal,\n\t            });\n\t            return {\n", "              ...existingGlobal,\n\t              hooks: {\n\t                ...(existingGlobal.hooks || {}),\n\t                afterChange: [\n\t                  ...(existingGlobal.hooks?.afterChange || []),\n\t                  getGlobalAfterChangeHook({\n\t                    global: existingGlobal,\n\t                    pluginOptions,\n\t                  }),\n\t                ],\n", "              },\n\t              fields,\n\t            };\n\t          }\n\t          return existingGlobal;\n\t        }),\n\t      ],\n\t      onInit: async (payload) => {\n\t        initFunctions.forEach((fn) => fn());\n\t        if (config.onInit) await config.onInit(payload);\n", "      },\n\t    };\n\t  };\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { crowdinSync } from \"./plugin\";\n\texport { crowdinSync };\n"]}
{"filename": "src/collections/CrowdinCollectionDirectories.ts", "chunked_list": ["import { CollectionConfig } from \"payload/types\";\n\tconst CrowdinCollectionDirectories: CollectionConfig = {\n\t  slug: \"crowdin-collection-directories\",\n\t  admin: {\n\t    defaultColumns: [\"name\", \"title\", \"collectionSlug\", \"updatedAt\"],\n\t    useAsTitle: \"name\",\n\t    group: \"Crowdin Admin\",\n\t  },\n\t  access: {\n\t    read: () => true,\n", "  },\n\t  fields: [\n\t    /* Crowdin field */\n\t    {\n\t      name: \"name\",\n\t      type: \"text\",\n\t    },\n\t    {\n\t      name: \"title\",\n\t      type: \"text\",\n", "    },\n\t    /* Internal fields  */\n\t    {\n\t      name: \"collectionSlug\",\n\t      type: \"text\",\n\t    },\n\t    /* Crowdin fields */\n\t    {\n\t      name: \"createdAt\",\n\t      type: \"date\",\n", "    },\n\t    {\n\t      name: \"updatedAt\",\n\t      type: \"date\",\n\t    },\n\t    {\n\t      name: \"originalId\",\n\t      type: \"number\",\n\t    },\n\t    {\n", "      name: \"projectId\",\n\t      type: \"number\",\n\t    },\n\t    {\n\t      name: \"directoryId\",\n\t      type: \"number\",\n\t    },\n\t  ],\n\t};\n\texport default CrowdinCollectionDirectories;\n"]}
{"filename": "src/collections/CrowdinFiles.ts", "chunked_list": ["import { CollectionConfig } from \"payload/types\";\n\timport {\n\t  buildCrowdinHtmlObject,\n\t  buildCrowdinJsonObject,\n\t  getLocalizedFields,\n\t} from \"../utilities\";\n\t/*\n\t  Sample data returned from Crowdin API\n\t*/\n\t/*\n", "{\n\t  data: {\n\t    revisionId: 5,\n\t    status: 'active',\n\t    priority: 'normal',\n\t    importOptions: { contentSegmentation: true, customSegmentation: false },\n\t    exportOptions: null,\n\t    excludedTargetLanguages: null,\n\t    createdAt: '2022-10-31T18:14:55+00:00',\n\t    updatedAt: '2022-11-04T16:36:05+00:00',\n", "    id: 1079,\n\t    projectId: 323731,\n\t    branchId: null,\n\t    directoryId: 1077,\n\t    name: 'en.html',\n\t    title: null,\n\t    type: 'html',\n\t    path: '/policies/security-and-privacy/en.html'\n\t  }\n\t}\n", "*/\n\tconst CrowdinFiles: CollectionConfig = {\n\t  slug: \"crowdin-files\",\n\t  admin: {\n\t    defaultColumns: [\"path\", \"title\", \"field\", \"revisionId\", \"updatedAt\"],\n\t    useAsTitle: \"path\",\n\t    group: \"Crowdin Admin\",\n\t  },\n\t  access: {\n\t    read: () => true,\n", "  },\n\t  fields: [\n\t    /* Crowdin field */\n\t    {\n\t      name: \"title\",\n\t      type: \"text\",\n\t    },\n\t    /* Internal fields  */\n\t    {\n\t      name: \"field\",\n", "      type: \"text\",\n\t    },\n\t    {\n\t      name: \"crowdinArticleDirectory\",\n\t      type: \"relationship\",\n\t      relationTo: \"crowdin-article-directories\",\n\t      hasMany: false,\n\t    },\n\t    /* Crowdin fields */\n\t    {\n", "      name: \"createdAt\",\n\t      type: \"date\",\n\t    },\n\t    {\n\t      name: \"updatedAt\",\n\t      type: \"date\",\n\t    },\n\t    {\n\t      name: \"originalId\",\n\t      type: \"number\",\n", "    },\n\t    {\n\t      name: \"projectId\",\n\t      type: \"number\",\n\t    },\n\t    {\n\t      name: \"directoryId\",\n\t      type: \"number\",\n\t    },\n\t    {\n", "      name: \"revisionId\",\n\t      type: \"number\",\n\t    },\n\t    {\n\t      name: \"name\",\n\t      type: \"text\",\n\t    },\n\t    {\n\t      name: \"type\",\n\t      type: \"text\",\n", "    },\n\t    {\n\t      name: \"path\",\n\t      type: \"text\",\n\t    },\n\t    {\n\t      name: \"fileData\",\n\t      type: \"group\",\n\t      admin: {\n\t        description: \"The file data submitted to the Crowdin API\",\n", "      },\n\t      fields: [\n\t        {\n\t          name: \"json\",\n\t          type: \"json\",\n\t        },\n\t        {\n\t          name: \"html\",\n\t          type: \"textarea\",\n\t        },\n", "      ],\n\t    },\n\t  ],\n\t};\n\texport default CrowdinFiles;\n"]}
{"filename": "src/collections/CrowdinArticleDirectories.ts", "chunked_list": ["import { CollectionConfig } from \"payload/types\";\n\tconst CrowdinArticleDirectories: CollectionConfig = {\n\t  slug: \"crowdin-article-directories\",\n\t  admin: {\n\t    defaultColumns: [\n\t      \"name\",\n\t      \"title\",\n\t      \"crowdinCollectionDirectory\",\n\t      \"createdAt\",\n\t    ],\n", "    useAsTitle: \"name\",\n\t    group: \"Crowdin Admin\",\n\t  },\n\t  access: {\n\t    read: () => true,\n\t  },\n\t  fields: [\n\t    /* Crowdin field */\n\t    {\n\t      name: \"name\",\n", "      type: \"text\",\n\t    },\n\t    /* Internal fields  */\n\t    {\n\t      name: \"crowdinCollectionDirectory\",\n\t      type: \"relationship\",\n\t      relationTo: \"crowdin-collection-directories\",\n\t      hasMany: false,\n\t    },\n\t    {\n", "      name: \"crowdinFiles\",\n\t      type: \"relationship\",\n\t      relationTo: \"crowdin-files\",\n\t      hasMany: true,\n\t    },\n\t    /* Crowdin fields */\n\t    {\n\t      name: \"createdAt\",\n\t      type: \"date\",\n\t    },\n", "    {\n\t      name: \"updatedAt\",\n\t      type: \"date\",\n\t    },\n\t    {\n\t      name: \"originalId\",\n\t      type: \"number\",\n\t    },\n\t    {\n\t      name: \"projectId\",\n", "      type: \"number\",\n\t    },\n\t    {\n\t      name: \"directoryId\",\n\t      type: \"number\",\n\t    },\n\t  ],\n\t};\n\texport default CrowdinArticleDirectories;\n"]}
{"filename": "src/endpoints/globals/reviewTranslation.ts", "chunked_list": ["import { Endpoint } from \"payload/config\";\n\timport { PluginOptions } from \"../../types\";\n\timport { payloadCrowdinSyncTranslationsApi } from \"../../api/payload-crowdin-sync/translations\";\n\texport const getReviewTranslationEndpoint = ({\n\t  pluginOptions,\n\t  type = \"review\",\n\t}: {\n\t  pluginOptions: PluginOptions;\n\t  type?: \"review\" | \"update\";\n\t}): Endpoint => ({\n", "  path: `/:id/${type}`,\n\t  method: \"get\",\n\t  handler: async (req, res, next) => {\n\t    const articleDirectory = await req.payload.findByID({\n\t      id: req.params.id,\n\t      collection: req.collection?.config.slug as string,\n\t    });\n\t    const global =\n\t      articleDirectory.crowdinCollectionDirectory.collectionSlug === \"globals\";\n\t    const translationsApi = new payloadCrowdinSyncTranslationsApi(\n", "      pluginOptions,\n\t      req.payload\n\t    );\n\t    try {\n\t      const translations = await translationsApi.updateTranslation({\n\t        documentId: !global && articleDirectory.name,\n\t        collection: global\n\t          ? articleDirectory.name\n\t          : articleDirectory.crowdinCollectionDirectory.collectionSlug,\n\t        global,\n", "        dryRun: type === \"update\" ? false : true,\n\t        excludeLocales: articleDirectory.excludeLocales || [],\n\t      });\n\t      res.status(200).send(translations);\n\t    } catch (error) {\n\t      res.status(400).send(error);\n\t    }\n\t  },\n\t});\n"]}
{"filename": "src/endpoints/globals/reviewFields.ts", "chunked_list": ["import { Endpoint } from \"payload/config\";\n\timport { PluginOptions } from \"../../types\";\n\timport { payloadCrowdinSyncTranslationsApi } from \"../../api/payload-crowdin-sync/translations\";\n\timport { getLocalizedFields } from \"../../utilities\";\n\texport const getReviewFieldsEndpoint = ({\n\t  pluginOptions,\n\t}: {\n\t  pluginOptions: PluginOptions;\n\t}): Endpoint => ({\n\t  path: `/:id/fields`,\n", "  method: \"get\",\n\t  handler: async (req, res, next) => {\n\t    const articleDirectory = await req.payload.findByID({\n\t      id: req.params.id,\n\t      collection: req.collection?.config.slug as string,\n\t    });\n\t    const global =\n\t      articleDirectory.crowdinCollectionDirectory.collectionSlug === \"globals\";\n\t    const translationsApi = new payloadCrowdinSyncTranslationsApi(\n\t      pluginOptions,\n", "      req.payload\n\t    );\n\t    try {\n\t      const collectionConfig = await translationsApi.getCollectionConfig(global ? articleDirectory.name : articleDirectory.crowdinCollectionDirectory.collectionSlug, global)\n\t      const response = {\n\t        fields: collectionConfig.fields,\n\t        localizedFields: getLocalizedFields({ fields: collectionConfig.fields })\n\t      }\n\t      res.status(200).send(response);\n\t    } catch (error) {\n", "      res.status(400).send(error);\n\t    }\n\t  },\n\t});\n"]}
{"filename": "src/fields/getFields.ts", "chunked_list": ["import type { CollectionConfig, Field, GlobalConfig } from \"payload/types\";\n\tinterface Args {\n\t  collection: CollectionConfig | GlobalConfig;\n\t}\n\texport const getFields = ({ collection }: Args): Field[] => {\n\t  const fields = [...collection.fields];\n\t  const crowdinArticleDirectoryField: Field = {\n\t    name: \"crowdinArticleDirectory\",\n\t    type: \"relationship\",\n\t    relationTo: \"crowdin-article-directories\",\n", "    hasMany: false,\n\t    /*admin: {\n\t      readOnly: true,\n\t      disabled: true,\n\t    },*/\n\t  };\n\t  fields.push(crowdinArticleDirectoryField);\n\t  return fields;\n\t};\n"]}
{"filename": "src/hooks/collections/afterDelete.ts", "chunked_list": ["import { CollectionAfterDeleteHook } from \"payload/types\";\n\timport { payloadCrowdinSyncFilesApi } from \"../../api/payload-crowdin-sync/files\";\n\timport { PluginOptions } from \"../../types\";\n\tinterface CommonArgs {\n\t  pluginOptions: PluginOptions;\n\t}\n\tinterface Args extends CommonArgs {}\n\texport const getAfterDeleteHook =\n\t  ({ pluginOptions }: Args): CollectionAfterDeleteHook =>\n\t  async ({\n", "    req, // full express request\n\t    id, // id of document to delete\n\t    doc, // deleted document\n\t  }) => {\n\t    /**\n\t     * Abort if token not set and not in test mode\n\t     */\n\t    if (!pluginOptions.token && process.env.NODE_ENV !== \"test\") {\n\t      return doc;\n\t    }\n", "    /**\n\t     * Initialize Crowdin client sourceFilesApi\n\t     */\n\t    const filesApi = new payloadCrowdinSyncFilesApi(pluginOptions, req.payload);\n\t    await filesApi.deleteFilesAndDirectory(`${id}`);\n\t  };\n"]}
{"filename": "src/hooks/collections/afterChange.ts", "chunked_list": ["import {\n\t  CollectionAfterChangeHook,\n\t  CollectionConfig,\n\t  Field,\n\t  GlobalConfig,\n\t  GlobalAfterChangeHook,\n\t  PayloadRequest,\n\t} from \"payload/types\";\n\timport { Descendant } from \"slate\";\n\timport { PluginOptions } from \"../../types\";\n", "import {\n\t  buildCrowdinHtmlObject,\n\t  buildCrowdinJsonObject,\n\t  convertSlateToHtml,\n\t  fieldChanged,\n\t} from \"../../utilities\";\n\timport deepEqual from \"deep-equal\";\n\timport { getLocalizedFields } from \"../../utilities\";\n\timport { payloadCrowdinSyncFilesApi } from \"../../api/payload-crowdin-sync/files\";\n\t/**\n", " * Update Crowdin collections and make updates in Crowdin\n\t *\n\t * This functionality used to be split into field hooks.\n\t * However, it is more reliable to loop through localized\n\t * fields and perform opeerations in one place. The\n\t * asynchronous nature of operations means that\n\t * we need to be careful updates are not made sooner than\n\t * expected.\n\t */\n\tinterface CommonArgs {\n", "  pluginOptions: PluginOptions;\n\t}\n\tinterface Args extends CommonArgs {\n\t  collection: CollectionConfig;\n\t}\n\tinterface GlobalArgs extends CommonArgs {\n\t  global: GlobalConfig;\n\t}\n\texport const getGlobalAfterChangeHook =\n\t  ({ global, pluginOptions }: GlobalArgs): GlobalAfterChangeHook =>\n", "  async ({\n\t    doc, // full document data\n\t    previousDoc, // document data before updating the collection\n\t    req, // full express request\n\t  }) => {\n\t    const operation = previousDoc ? \"update\" : \"create\";\n\t    return performAfterChange({\n\t      doc,\n\t      req,\n\t      previousDoc,\n", "      operation,\n\t      collection: global,\n\t      global: true,\n\t      pluginOptions,\n\t    });\n\t  };\n\texport const getAfterChangeHook =\n\t  ({ collection, pluginOptions }: Args): CollectionAfterChangeHook =>\n\t  async ({\n\t    doc, // full document data\n", "    req, // full express request\n\t    previousDoc, // document data before updating the collection\n\t    operation, // name of the operation ie. 'create', 'update'\n\t  }) => {\n\t    return performAfterChange({\n\t      doc,\n\t      req,\n\t      previousDoc,\n\t      operation,\n\t      collection,\n", "      pluginOptions,\n\t    });\n\t  };\n\tinterface IPerformChange {\n\t  doc: any;\n\t  req: PayloadRequest;\n\t  previousDoc: any;\n\t  operation: string;\n\t  collection: CollectionConfig | GlobalConfig;\n\t  global?: boolean;\n", "  pluginOptions: PluginOptions;\n\t}\n\tconst performAfterChange = async ({\n\t  doc, // full document data\n\t  req, // full express request\n\t  previousDoc,\n\t  operation,\n\t  collection,\n\t  global = false,\n\t  pluginOptions,\n", "}: IPerformChange) => {\n\t  /**\n\t   * Abort if token not set and not in test mode\n\t   */\n\t  if (!pluginOptions.token && process.env.NODE_ENV !== \"test\") {\n\t    return doc;\n\t  }\n\t  const localizedFields: Field[] = getLocalizedFields({\n\t    fields: collection.fields,\n\t  });\n", "  /**\n\t   * Abort if there are no fields to localize\n\t   */\n\t  if (localizedFields.length === 0) {\n\t    return doc;\n\t  }\n\t  /**\n\t   * Abort if locale is unavailable or this\n\t   * is an update from the API to the source\n\t   * locale.\n", "   */\n\t  if (!req.locale || req.locale !== pluginOptions.sourceLocale) {\n\t    return doc;\n\t  }\n\t  /**\n\t   * Prepare JSON objects\n\t   *\n\t   * `text` fields are compiled into a single JSON file\n\t   * on Crowdin. Prepare previous and current objects.\n\t   */\n", "  const currentCrowdinJsonData = buildCrowdinJsonObject({\n\t    doc,\n\t    fields: localizedFields,\n\t  });\n\t  const prevCrowdinJsonData = buildCrowdinJsonObject({\n\t    doc: previousDoc,\n\t    fields: localizedFields,\n\t  });\n\t  /**\n\t   * Initialize Crowdin client sourceFilesApi\n", "   */\n\t  const filesApi = new payloadCrowdinSyncFilesApi(pluginOptions, req.payload);\n\t  /**\n\t   * Retrieve the Crowdin Article Directory article\n\t   *\n\t   * Records of Crowdin directories are stored in Payload.\n\t   */\n\t  const articleDirectory = await filesApi.findOrCreateArticleDirectory({\n\t    document: doc,\n\t    collectionSlug: collection.slug,\n", "    global,\n\t  });\n\t  // START: function definitions\n\t  const createOrUpdateJsonFile = async () => {\n\t    await filesApi.createOrUpdateFile({\n\t      name: \"fields\",\n\t      value: currentCrowdinJsonData,\n\t      fileType: \"json\",\n\t      articleDirectory,\n\t    });\n", "  };\n\t  const createOrUpdateHtmlFile = async ({\n\t    name,\n\t    value,\n\t  }: {\n\t    name: string;\n\t    value: Descendant[];\n\t  }) => {\n\t    await filesApi.createOrUpdateFile({\n\t      name: name,\n", "      value: convertSlateToHtml(value),\n\t      fileType: \"html\",\n\t      articleDirectory,\n\t    });\n\t  };\n\t  const createOrUpdateJsonSource = async () => {\n\t    if (\n\t      (!deepEqual(currentCrowdinJsonData, prevCrowdinJsonData) &&\n\t        Object.keys(currentCrowdinJsonData).length !== 0) ||\n\t      process.env.PAYLOAD_CROWDIN_SYNC_ALWAYS_UPDATE === \"true\"\n", "    ) {\n\t      await createOrUpdateJsonFile();\n\t    }\n\t  };\n\t  /**\n\t   * Recursively send rich text fields to Crowdin as HTML\n\t   *\n\t   * Name these HTML files with dot notation. Examples:\n\t   *\n\t   * * `localizedRichTextField`\n", "   * * `groupField.localizedRichTextField`\n\t   * * `arrayField[0].localizedRichTextField`\n\t   * * `arrayField[1].localizedRichTextField`\n\t   */\n\t  const createOrUpdateHtmlSource = async () => {\n\t    const currentCrowdinHtmlData = buildCrowdinHtmlObject({\n\t      doc,\n\t      fields: localizedFields,\n\t    });\n\t    const prevCrowdinHtmlData = buildCrowdinHtmlObject({\n", "      doc: previousDoc,\n\t      fields: localizedFields,\n\t    });\n\t    Object.keys(currentCrowdinHtmlData).forEach(async (name) => {\n\t      const currentValue = currentCrowdinHtmlData[name];\n\t      const prevValue = prevCrowdinHtmlData[name];\n\t      if (\n\t        !fieldChanged(prevValue, currentValue, \"richText\") &&\n\t        process.env.PAYLOAD_CROWDIN_SYNC_ALWAYS_UPDATE !== \"true\"\n\t      ) {\n", "        return;\n\t      }\n\t      const file = await createOrUpdateHtmlFile({\n\t        name,\n\t        value: currentValue as Descendant[],\n\t      });\n\t    });\n\t  };\n\t  // END: function definitions\n\t  await createOrUpdateJsonSource();\n", "  await createOrUpdateHtmlSource();\n\t  return doc;\n\t};\n"]}
{"filename": "src/api/connection.ts", "chunked_list": ["import crowdin from \"@crowdin/crowdin-api-client\";\n\texport const { uploadStorageApi, sourceFilesApi } = new crowdin({\n\t  token: process.env.CROWDIN_API_TOKEN as string,\n\t});\n"]}
{"filename": "src/api/helpers.ts", "chunked_list": ["import { Payload } from \"payload\";\n\timport { IcrowdinFile } from \"./payload-crowdin-sync/files\";\n\t/**\n\t * get Crowdin Article Directory for a given documentId\n\t *\n\t * The Crowdin Article Directory is associated with a document,\n\t * so is easy to retrieve. Use this function when you only have\n\t * a document id.\n\t */\n\texport async function getArticleDirectory(\n", "  documentId: string,\n\t  payload: Payload,\n\t  allowEmpty?: boolean\n\t) {\n\t  // Get directory\n\t  const crowdinPayloadArticleDirectory = await payload.find({\n\t    collection: \"crowdin-article-directories\",\n\t    where: {\n\t      name: {\n\t        equals: documentId,\n", "      },\n\t    },\n\t  });\n\t  if (crowdinPayloadArticleDirectory.totalDocs === 0 && allowEmpty) {\n\t    // a thrown error won't be reported in an api call, so console.log it as well.\n\t    console.log(`No article directory found for document ${documentId}`);\n\t    throw new Error(\n\t      \"This article does not have a corresponding entry in the  crowdin-article-directories collection.\"\n\t    );\n\t  }\n", "  return crowdinPayloadArticleDirectory\n\t    ? crowdinPayloadArticleDirectory.docs[0]\n\t    : undefined;\n\t}\n\texport async function getFile(\n\t  name: string,\n\t  crowdinArticleDirectoryId: string,\n\t  payload: Payload\n\t): Promise<any> {\n\t  const result = await payload.find({\n", "    collection: \"crowdin-files\",\n\t    where: {\n\t      field: { equals: name },\n\t      crowdinArticleDirectory: {\n\t        equals: crowdinArticleDirectoryId,\n\t      },\n\t    },\n\t  });\n\t  return result.docs[0];\n\t}\n", "export async function getFiles(\n\t  crowdinArticleDirectoryId: string,\n\t  payload: Payload\n\t): Promise<any> {\n\t  const result = await payload.find({\n\t    collection: \"crowdin-files\",\n\t    where: {\n\t      crowdinArticleDirectory: {\n\t        equals: crowdinArticleDirectoryId,\n\t      },\n", "    },\n\t  });\n\t  return result.docs;\n\t}\n\texport async function getFileByDocumentID(\n\t  name: string,\n\t  documentId: string,\n\t  payload: Payload\n\t): Promise<IcrowdinFile> {\n\t  const articleDirectory = await getArticleDirectory(documentId, payload);\n", "  return getFile(name, articleDirectory.id, payload);\n\t}\n\texport async function getFilesByDocumentID(\n\t  documentId: string,\n\t  payload: Payload\n\t): Promise<IcrowdinFile[]> {\n\t  const articleDirectory = await getArticleDirectory(documentId, payload);\n\t  if (!articleDirectory) {\n\t    // tests call this function to make sure files are deleted\n\t    return [];\n", "  }\n\t  const files = await getFiles(articleDirectory.id, payload);\n\t  return files;\n\t}\n"]}
{"filename": "src/api/payload-crowdin-sync/files.ts", "chunked_list": ["import crowdin, {\n\t  Credentials,\n\t  SourceFiles,\n\t  UploadStorage,\n\t} from \"@crowdin/crowdin-api-client\";\n\timport { mockCrowdinClient } from \"../mock/crowdin-client\";\n\timport { Payload } from \"payload\";\n\timport { PluginOptions } from \"../../types\";\n\timport { toWords } from \"payload/dist/utilities/formatLabels\";\n\timport {\n", "  getArticleDirectory,\n\t  getFile,\n\t  getFiles,\n\t  getFileByDocumentID,\n\t  getFilesByDocumentID,\n\t} from \"../helpers\";\n\timport { isEmpty } from \"lodash\";\n\texport interface IcrowdinFile {\n\t  id: string;\n\t  originalId: number;\n", "  fileData: {\n\t    json?: Object;\n\t    html?: string;\n\t  };\n\t}\n\tinterface IfindOrCreateCollectionDirectory {\n\t  collectionSlug: string;\n\t}\n\tinterface IfindOrCreateArticleDirectory\n\t  extends IfindOrCreateCollectionDirectory {\n", "  document: any;\n\t  global?: boolean;\n\t}\n\tinterface IupdateOrCreateFile {\n\t  name: string;\n\t  value: string | object;\n\t  fileType: \"html\" | \"json\";\n\t  articleDirectory: any;\n\t}\n\tinterface IcreateOrUpdateFile {\n", "  name: string;\n\t  fileData: string | object;\n\t  fileType: \"html\" | \"json\";\n\t}\n\tinterface IcreateFile extends IcreateOrUpdateFile {\n\t  directoryId: number;\n\t}\n\tinterface IupdateFile extends IcreateOrUpdateFile {\n\t  crowdinFile: IcrowdinFile;\n\t}\n", "interface IupdateCrowdinFile extends IcreateOrUpdateFile {\n\t  fileId: number;\n\t}\n\tinterface IgetTranslation {\n\t  documentId: string;\n\t  fieldName: string;\n\t  locale: string;\n\t  global?: boolean;\n\t}\n\texport class payloadCrowdinSyncFilesApi {\n", "  sourceFilesApi: SourceFiles;\n\t  uploadStorageApi: UploadStorage;\n\t  projectId: number;\n\t  directoryId?: number;\n\t  payload: Payload;\n\t  constructor(pluginOptions: PluginOptions, payload: Payload) {\n\t    // credentials\n\t    const credentials: Credentials = {\n\t      token: pluginOptions.token,\n\t    };\n", "    const { sourceFilesApi, uploadStorageApi } = new crowdin(credentials);\n\t    this.projectId = pluginOptions.projectId;\n\t    this.directoryId = pluginOptions.directoryId;\n\t    this.sourceFilesApi =\n\t      process.env.NODE_ENV === \"test\"\n\t        ? (mockCrowdinClient(pluginOptions) as any)\n\t        : sourceFilesApi;\n\t    this.uploadStorageApi =\n\t      process.env.NODE_ENV === \"test\"\n\t        ? (mockCrowdinClient(pluginOptions) as any)\n", "        : uploadStorageApi;\n\t    this.payload = payload;\n\t  }\n\t  async findOrCreateArticleDirectory({\n\t    document,\n\t    collectionSlug,\n\t    global = false,\n\t  }: IfindOrCreateArticleDirectory) {\n\t    let crowdinPayloadArticleDirectory;\n\t    if (document.crowdinArticleDirectory) {\n", "      // Update not possible. Article name needs to be updated manually on Crowdin.\n\t      // The name of the directory is Crowdin specific helper text to give\n\t      // context to translators.\n\t      // See https://developer.crowdin.com/api/v2/#operation/api.projects.directories.getMany\n\t      crowdinPayloadArticleDirectory = await this.payload.findByID({\n\t        collection: \"crowdin-article-directories\",\n\t        id:\n\t          document.crowdinArticleDirectory.id ||\n\t          document.crowdinArticleDirectory,\n\t      });\n", "    } else {\n\t      const crowdinPayloadCollectionDirectory =\n\t        await this.findOrCreateCollectionDirectory({\n\t          collectionSlug: global ? \"globals\" : collectionSlug,\n\t        });\n\t      // Create article directory on Crowdin\n\t      const crowdinDirectory = await this.sourceFilesApi.createDirectory(\n\t        this.projectId,\n\t        {\n\t          directoryId: crowdinPayloadCollectionDirectory.originalId,\n", "          name: global ? collectionSlug : document.id,\n\t          title: global\n\t            ? toWords(collectionSlug)\n\t            : document.title || document.name, // no tests for this Crowdin metadata, but makes it easier for translators\n\t        }\n\t      );\n\t      // Store result in Payload CMS\n\t      crowdinPayloadArticleDirectory = await this.payload.create({\n\t        collection: \"crowdin-article-directories\",\n\t        data: {\n", "          crowdinCollectionDirectory: crowdinPayloadCollectionDirectory.id,\n\t          originalId: crowdinDirectory.data.id,\n\t          projectId: this.projectId,\n\t          directoryId: crowdinDirectory.data.directoryId,\n\t          name: crowdinDirectory.data.name,\n\t          createdAt: crowdinDirectory.data.createdAt,\n\t          updatedAt: crowdinDirectory.data.updatedAt,\n\t        },\n\t      });\n\t      // Associate result with document\n", "      if (global) {\n\t        const update = await this.payload.updateGlobal({\n\t          slug: collectionSlug,\n\t          data: {\n\t            crowdinArticleDirectory: crowdinPayloadArticleDirectory.id,\n\t          },\n\t        });\n\t      } else {\n\t        const update = await this.payload.update({\n\t          collection: collectionSlug,\n", "          id: document.id,\n\t          data: {\n\t            crowdinArticleDirectory: crowdinPayloadArticleDirectory.id,\n\t          },\n\t        });\n\t      }\n\t    }\n\t    return crowdinPayloadArticleDirectory;\n\t  }\n\t  private async findOrCreateCollectionDirectory({\n", "    collectionSlug,\n\t  }: IfindOrCreateCollectionDirectory) {\n\t    let crowdinPayloadCollectionDirectory;\n\t    // Check whether collection directory exists on Crowdin\n\t    const query = await this.payload.find({\n\t      collection: \"crowdin-collection-directories\",\n\t      where: {\n\t        collectionSlug: {\n\t          equals: collectionSlug,\n\t        },\n", "      },\n\t    });\n\t    if (query.totalDocs === 0) {\n\t      // Create collection directory on Crowdin\n\t      const crowdinDirectory = await this.sourceFilesApi.createDirectory(\n\t        this.projectId,\n\t        {\n\t          directoryId: this.directoryId,\n\t          name: collectionSlug,\n\t          title: toWords(collectionSlug), // is this transformed value available on the collection object?\n", "        }\n\t      );\n\t      // Store result in Payload CMS\n\t      crowdinPayloadCollectionDirectory = await this.payload.create({\n\t        collection: \"crowdin-collection-directories\",\n\t        data: {\n\t          collectionSlug: collectionSlug,\n\t          originalId: crowdinDirectory.data.id,\n\t          projectId: this.projectId,\n\t          directoryId: crowdinDirectory.data.directoryId,\n", "          name: crowdinDirectory.data.name,\n\t          title: crowdinDirectory.data.title,\n\t          createdAt: crowdinDirectory.data.createdAt,\n\t          updatedAt: crowdinDirectory.data.updatedAt,\n\t        },\n\t      });\n\t    } else {\n\t      crowdinPayloadCollectionDirectory = query.docs[0];\n\t    }\n\t    return crowdinPayloadCollectionDirectory;\n", "  }\n\t  async getFile(name: string, crowdinArticleDirectoryId: string): Promise<any> {\n\t    return getFile(name, crowdinArticleDirectoryId, this.payload);\n\t  }\n\t  async getFiles(crowdinArticleDirectoryId: string): Promise<any> {\n\t    return getFiles(crowdinArticleDirectoryId, this.payload);\n\t  }\n\t  /**\n\t   * Create/Update/Delete a file on Crowdin\n\t   *\n", "   * Records the file in Payload CMS under the `crowdin-files` collection.\n\t   *\n\t   * - Create a file if it doesn't exist on Crowdin and the supplied content is not empty\n\t   * - Update a file if it exists on Crowdin and the supplied content is not empty\n\t   * - Delete a file if it exists on Crowdin and the supplied file content is empty\n\t   */\n\t  async createOrUpdateFile({\n\t    name,\n\t    value,\n\t    fileType,\n", "    articleDirectory,\n\t  }: IupdateOrCreateFile) {\n\t    const empty = isEmpty(value);\n\t    // Check whether file exists on Crowdin\n\t    let crowdinFile = await this.getFile(name, articleDirectory.id);\n\t    let updatedCrowdinFile;\n\t    if (!empty) {\n\t      if (!crowdinFile) {\n\t        updatedCrowdinFile = await this.createFile({\n\t          name,\n", "          value,\n\t          fileType,\n\t          articleDirectory,\n\t        });\n\t      } else {\n\t        updatedCrowdinFile = await this.updateFile({\n\t          crowdinFile,\n\t          name: name,\n\t          fileData: value,\n\t          fileType: fileType,\n", "        });\n\t      }\n\t    } else {\n\t      if (crowdinFile) {\n\t        updatedCrowdinFile = await this.deleteFile(crowdinFile);\n\t      }\n\t    }\n\t    return updatedCrowdinFile;\n\t  }\n\t  private async updateFile({\n", "    crowdinFile,\n\t    name,\n\t    fileData,\n\t    fileType,\n\t  }: IupdateFile) {\n\t    // Update file on Crowdin\n\t    const updatedCrowdinFile = await this.crowdinUpdateFile({\n\t      fileId: crowdinFile.originalId,\n\t      name,\n\t      fileData,\n", "      fileType,\n\t    });\n\t    const payloadCrowdinFile = await this.payload.update({\n\t      collection: \"crowdin-files\", // required\n\t      id: crowdinFile.id,\n\t      data: {\n\t        // required\n\t        updatedAt: updatedCrowdinFile.data.updatedAt,\n\t        revisionId: updatedCrowdinFile.data.revisionId,\n\t        ...(fileType === \"json\" && { fileData: { json: fileData } }),\n", "        ...(fileType === \"html\" && { fileData: { html: fileData } }),\n\t      },\n\t    });\n\t  }\n\t  private async createFile({\n\t    name,\n\t    value,\n\t    fileType,\n\t    articleDirectory,\n\t  }: IupdateOrCreateFile) {\n", "    // Create file on Crowdin\n\t    const crowdinFile = await this.crowdinCreateFile({\n\t      directoryId: articleDirectory.originalId,\n\t      name: name,\n\t      fileData: value,\n\t      fileType: fileType,\n\t    });\n\t    // createFile has been intermittent in not being available\n\t    // perhaps logic goes wrong somewhere and express middleware\n\t    // is hard to debug?\n", "    /*const crowdinFile =  {data: {\n\t      revisionId: 5,\n\t      status: 'active',\n\t      priority: 'normal',\n\t      importOptions: { contentSegmentation: true, customSegmentation: false },\n\t      exportOptions: null,\n\t      excludedTargetLanguages: null,\n\t      createdAt: new Date().toISOString(),\n\t      updatedAt: new Date().toISOString(),\n\t      id: 1079,\n", "      projectId: 323731,\n\t      branchId: null,\n\t      directoryId: 1077,\n\t      name: name,\n\t      title: null,\n\t      type: fileType,\n\t      path: `/policies/security-and-privacy/${name}.${fileType}`\n\t    }}*/\n\t    // Store result on Payload CMS\n\t    if (crowdinFile) {\n", "      const payloadCrowdinFile = await this.payload.create({\n\t        collection: \"crowdin-files\", // required\n\t        data: {\n\t          // required\n\t          title: crowdinFile.data.name,\n\t          field: name,\n\t          crowdinArticleDirectory: articleDirectory.id,\n\t          createdAt: crowdinFile.data.createdAt,\n\t          updatedAt: crowdinFile.data.updatedAt,\n\t          originalId: crowdinFile.data.id,\n", "          projectId: crowdinFile.data.projectId,\n\t          directoryId: crowdinFile.data.directoryId,\n\t          revisionId: crowdinFile.data.revisionId,\n\t          name: crowdinFile.data.name,\n\t          type: crowdinFile.data.type,\n\t          path: crowdinFile.data.path,\n\t          ...(fileType === \"json\" && { fileData: { json: value } }),\n\t          ...(fileType === \"html\" && { fileData: { html: value } }),\n\t        },\n\t      });\n", "      return payloadCrowdinFile;\n\t    }\n\t  }\n\t  async deleteFile(crowdinFile: IcrowdinFile) {\n\t    const file = await this.sourceFilesApi.deleteFile(\n\t      this.projectId,\n\t      crowdinFile.originalId\n\t    );\n\t    const payloadFile = await this.payload.delete({\n\t      collection: \"crowdin-files\", // required\n", "      id: crowdinFile.id, // required\n\t    });\n\t    return payloadFile;\n\t  }\n\t  private async crowdinUpdateFile({\n\t    fileId,\n\t    name,\n\t    fileData,\n\t    fileType,\n\t  }: IupdateCrowdinFile) {\n", "    const storage = await this.uploadStorageApi.addStorage(\n\t      name,\n\t      fileData,\n\t      fileType\n\t    );\n\t    //const file = await sourceFilesApi.deleteFile(projectId, 1161)\n\t    const file = await this.sourceFilesApi.updateOrRestoreFile(\n\t      this.projectId,\n\t      fileId,\n\t      {\n", "        storageId: storage.data.id,\n\t      }\n\t    );\n\t    return file;\n\t  }\n\t  private async crowdinCreateFile({\n\t    name,\n\t    fileData,\n\t    fileType,\n\t    directoryId,\n", "  }: IcreateFile) {\n\t    const storage = await this.uploadStorageApi.addStorage(\n\t      name,\n\t      fileData,\n\t      fileType\n\t    );\n\t    const options = {\n\t      name: `${name}.${fileType}`,\n\t      title: name,\n\t      storageId: storage.data.id,\n", "      directoryId,\n\t      type: fileType,\n\t    };\n\t    try {\n\t      const file = await this.sourceFilesApi.createFile(\n\t        this.projectId,\n\t        options\n\t      );\n\t      return file;\n\t    } catch (error) {\n", "      console.error(error, options);\n\t    }\n\t  }\n\t  async getArticleDirectory(documentId: string) {\n\t    const result = await getArticleDirectory(documentId, this.payload);\n\t    return result;\n\t  }\n\t  async deleteFilesAndDirectory(documentId: string) {\n\t    const files = await this.getFilesByDocumentID(documentId);\n\t    for (const file of files) {\n", "      await this.deleteFile(file);\n\t    }\n\t    await this.deleteArticleDirectory(documentId);\n\t  }\n\t  async deleteArticleDirectory(documentId: string) {\n\t    const crowdinPayloadArticleDirectory = await this.getArticleDirectory(\n\t      documentId\n\t    );\n\t    await this.sourceFilesApi.deleteDirectory(\n\t      this.projectId,\n", "      crowdinPayloadArticleDirectory.originalId\n\t    );\n\t    await this.payload.delete({\n\t      collection: \"crowdin-article-directories\",\n\t      id: crowdinPayloadArticleDirectory.id,\n\t    });\n\t  }\n\t  async getFileByDocumentID(name: string, documentId: string) {\n\t    const result = await getFileByDocumentID(name, documentId, this.payload);\n\t    return result;\n", "  }\n\t  async getFilesByDocumentID(documentId: string) {\n\t    const result = await getFilesByDocumentID(documentId, this.payload);\n\t    return result;\n\t  }\n\t}\n"]}
{"filename": "src/api/payload-crowdin-sync/translations.ts", "chunked_list": ["import crowdin, {\n\t  Credentials,\n\t  Translations,\n\t} from \"@crowdin/crowdin-api-client\";\n\timport { payloadCrowdinSyncFilesApi } from \"./files\";\n\timport { mockCrowdinClient } from \"../mock/crowdin-client\";\n\timport { Payload } from \"payload\";\n\timport { PluginOptions } from \"../../types\";\n\timport deepEqual from \"deep-equal\";\n\timport {\n", "  CollectionConfig,\n\t  GlobalConfig,\n\t  SanitizedCollectionConfig,\n\t  SanitizedGlobalConfig,\n\t} from \"payload/types\";\n\timport { htmlToSlate, payloadHtmlToSlateConfig } from \"slate-serializers\";\n\timport {\n\t  getLocalizedFields,\n\t  getFieldSlugs,\n\t  buildCrowdinJsonObject,\n", "  buildCrowdinHtmlObject,\n\t  buildPayloadUpdateObject,\n\t  getLocalizedRequiredFields,\n\t} from \"../../utilities\";\n\tinterface IgetLatestDocumentTranslation {\n\t  collection: string;\n\t  doc: any;\n\t  locale: string;\n\t  global?: boolean;\n\t}\n", "interface IgetCurrentDocumentTranslation {\n\t  doc: any;\n\t  collection: string;\n\t  locale: string;\n\t  global?: boolean;\n\t}\n\tinterface IgetTranslation {\n\t  documentId: string;\n\t  fieldName: string;\n\t  locale: string;\n", "  global?: boolean;\n\t}\n\tinterface IupdateTranslation {\n\t  documentId: string;\n\t  collection: string;\n\t  dryRun?: boolean;\n\t  global?: boolean;\n\t  excludeLocales?: string[];\n\t}\n\texport class payloadCrowdinSyncTranslationsApi {\n", "  translationsApi: Translations;\n\t  filesApi: payloadCrowdinSyncFilesApi; // our wrapper for file operations\n\t  projectId: number;\n\t  directoryId?: number;\n\t  payload: Payload;\n\t  localeMap: PluginOptions[\"localeMap\"];\n\t  sourceLocale: PluginOptions[\"sourceLocale\"];\n\t  constructor(pluginOptions: PluginOptions, payload: Payload) {\n\t    // credentials\n\t    const credentials: Credentials = {\n", "      token: pluginOptions.token,\n\t    };\n\t    const { translationsApi } = new crowdin(credentials);\n\t    this.projectId = pluginOptions.projectId;\n\t    this.directoryId = pluginOptions.directoryId;\n\t    this.translationsApi =\n\t      process.env.NODE_ENV === \"test\"\n\t        ? (mockCrowdinClient(pluginOptions) as any)\n\t        : translationsApi;\n\t    this.filesApi = new payloadCrowdinSyncFilesApi(pluginOptions, payload);\n", "    this.payload = payload;\n\t    this.localeMap = pluginOptions.localeMap;\n\t    this.sourceLocale = pluginOptions.sourceLocale;\n\t  }\n\t  async updateTranslation({\n\t    documentId,\n\t    collection,\n\t    dryRun = true,\n\t    global = false,\n\t    excludeLocales = [],\n", "  }: IupdateTranslation) {\n\t    /**\n\t     * Get existing document\n\t     *\n\t     * * check document exists\n\t     * * check for `meta` field (which can be added by @payloadcms/seo)\n\t     *\n\t     */\n\t    let doc: { crowdinArticleDirectory: { id: any } };\n\t    if (global) {\n", "      doc = await this.payload.findGlobal({\n\t        slug: collection,\n\t        locale: this.sourceLocale,\n\t      });\n\t    } else {\n\t      doc = await this.payload.findByID({\n\t        collection: collection,\n\t        id: documentId,\n\t        locale: this.sourceLocale,\n\t      });\n", "    }\n\t    const report: { [key: string]: any } = {};\n\t    for (const locale of Object.keys(this.localeMap)) {\n\t      if (excludeLocales.includes(locale)) {\n\t        continue;\n\t      }\n\t      report[locale] = {};\n\t      report[locale].currentTranslations =\n\t        await this.getCurrentDocumentTranslation({\n\t          doc: doc,\n", "          collection: collection,\n\t          locale: locale,\n\t          global,\n\t        });\n\t      report[locale].latestTranslations =\n\t        await this.getLatestDocumentTranslation({\n\t          collection: collection,\n\t          doc: doc,\n\t          locale: locale,\n\t          global,\n", "        });\n\t      report[locale].changed = !deepEqual(\n\t        report[locale].currentTranslations,\n\t        report[locale].latestTranslations\n\t      );\n\t      if (report[locale].changed && !dryRun) {\n\t        if (global) {\n\t          try {\n\t            await this.payload.updateGlobal({\n\t              slug: collection,\n", "              locale: locale,\n\t              data: {\n\t                ...report[locale].latestTranslations,\n\t                // error on update without the following line.\n\t                // see https://github.com/thompsonsj/payload-crowdin-sync/pull/13/files#r1209271660\n\t                crowdinArticleDirectory: doc.crowdinArticleDirectory.id,\n\t              },\n\t            });\n\t          } catch (error) {\n\t            console.log(error);\n", "          }\n\t        } else {\n\t          try {\n\t            await this.payload.update({\n\t              collection: collection,\n\t              locale: locale,\n\t              id: documentId,\n\t              data: report[locale].latestTranslations,\n\t            });\n\t          } catch (error) {\n", "            console.log(error);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return {\n\t      source: doc,\n\t      translations: { ...report },\n\t    };\n\t  }\n", "  getCollectionConfig(\n\t    collection: string,\n\t    global: boolean\n\t  ): CollectionConfig | GlobalConfig {\n\t    let collectionConfig:\n\t      | SanitizedGlobalConfig\n\t      | SanitizedCollectionConfig\n\t      | undefined;\n\t    if (global) {\n\t      collectionConfig = this.payload.config.globals.find(\n", "        (col: GlobalConfig) => col.slug === collection\n\t      );\n\t    } else {\n\t      collectionConfig = this.payload.config.collections.find(\n\t        (col: CollectionConfig) => col.slug === collection\n\t      );\n\t    }\n\t    if (!collectionConfig)\n\t      throw new Error(`Collection ${collection} not found in payload config`);\n\t    return collectionConfig;\n", "  }\n\t  async getCurrentDocumentTranslation({\n\t    doc,\n\t    collection,\n\t    locale,\n\t    global = false,\n\t  }: IgetCurrentDocumentTranslation) {\n\t    // get document\n\t    let document: any;\n\t    if (global) {\n", "      document = await this.payload.findGlobal({\n\t        slug: collection,\n\t        locale: locale,\n\t      });\n\t    } else {\n\t      document = await this.payload.findByID({\n\t        collection: collection,\n\t        id: doc.id,\n\t        locale: locale,\n\t      });\n", "    }\n\t    const collectionConfig = this.getCollectionConfig(collection, global);\n\t    const localizedFields = getLocalizedFields({\n\t      fields: collectionConfig.fields,\n\t    });\n\t    // build crowdin json object\n\t    const crowdinJsonObject = buildCrowdinJsonObject({\n\t      doc: document,\n\t      fields: localizedFields,\n\t    });\n", "    const crowdinHtmlObject = buildCrowdinHtmlObject({\n\t      doc: document,\n\t      fields: localizedFields,\n\t    });\n\t    try {\n\t      const docTranslations = buildPayloadUpdateObject({\n\t        crowdinJsonObject,\n\t        crowdinHtmlObject,\n\t        fields: localizedFields,\n\t        document,\n", "      });\n\t      return docTranslations;\n\t    } catch (error) {\n\t      console.log(error);\n\t      throw new Error(`${error}`);\n\t    }\n\t  }\n\t  /**\n\t   * Retrieve translations from Crowdin for a document in a given locale\n\t   */\n", "  async getLatestDocumentTranslation({\n\t    collection,\n\t    doc,\n\t    locale,\n\t    global = false,\n\t  }: IgetLatestDocumentTranslation) {\n\t    const collectionConfig = this.getCollectionConfig(collection, global);\n\t    const localizedFields = getLocalizedFields({\n\t      fields: collectionConfig.fields,\n\t    });\n", "    if (!localizedFields) {\n\t      return { message: \"no localized fields\" };\n\t    }\n\t    let docTranslations: { [key: string]: any } = {};\n\t    // add json fields\n\t    const crowdinJsonObject =\n\t      (await this.getTranslation({\n\t        documentId: global ? collectionConfig.slug : doc.id,\n\t        fieldName: \"fields\",\n\t        locale: locale,\n", "      })) || {};\n\t    // add html fields\n\t    const localizedHtmlFields = await this.getHtmlFieldSlugs(\n\t      global ? collectionConfig.slug : doc.id\n\t    );\n\t    let crowdinHtmlObject: { [key: string]: any } = {};\n\t    for (const field of localizedHtmlFields) {\n\t      crowdinHtmlObject[field] = await this.getTranslation({\n\t        documentId: global ? collectionConfig.slug : doc.id,\n\t        fieldName: field,\n", "        locale: locale,\n\t      });\n\t    }\n\t    docTranslations = buildPayloadUpdateObject({\n\t      crowdinJsonObject,\n\t      crowdinHtmlObject,\n\t      fields: localizedFields,\n\t      document: doc,\n\t    });\n\t    // Add required fields if not present\n", "    const requiredFieldSlugs = getFieldSlugs(\n\t      getLocalizedRequiredFields(collectionConfig)\n\t    );\n\t    if (requiredFieldSlugs.length > 0) {\n\t      const currentTranslations = await this.getCurrentDocumentTranslation({\n\t        doc: doc,\n\t        collection: collection,\n\t        locale: locale,\n\t        global,\n\t      });\n", "      requiredFieldSlugs.forEach((slug) => {\n\t        if (!docTranslations.hasOwnProperty(slug)) {\n\t          docTranslations[slug] = currentTranslations[slug];\n\t        }\n\t      });\n\t    }\n\t    return docTranslations;\n\t  }\n\t  async getHtmlFieldSlugs(documentId: string) {\n\t    const files = await this.filesApi.getFilesByDocumentID(documentId);\n", "    return files\n\t      .filter((file: any) => file.type === \"html\")\n\t      .map((file: any) => file.field);\n\t  }\n\t  /**\n\t   * Retrieve translations for a document field name\n\t   *\n\t   * * returns Slate object for html fields\n\t   * * returns all json fields if fieldName is 'fields'\n\t   */\n", "  async getTranslation({ documentId, fieldName, locale }: IgetTranslation) {\n\t    const articleDirectory = await this.filesApi.getArticleDirectory(\n\t      documentId\n\t    );\n\t    const file = await this.filesApi.getFile(fieldName, articleDirectory.id);\n\t    // it is possible a file doesn't exist yet - e.g. an article with localized text fields that contains an empty html field.\n\t    if (!file) {\n\t      return;\n\t    }\n\t    try {\n", "      const response = await this.translationsApi.buildProjectFileTranslation(\n\t        this.projectId,\n\t        file.originalId,\n\t        {\n\t          targetLanguageId: this.localeMap[locale].crowdinId,\n\t        }\n\t      );\n\t      const data = await this.getFileDataFromUrl(response.data.url);\n\t      return file.type === \"html\"\n\t        ? htmlToSlate(data, payloadHtmlToSlateConfig)\n", "        : JSON.parse(data);\n\t    } catch (error) {\n\t      console.log(error);\n\t    }\n\t  }\n\t  private async getFileDataFromUrl(url: string) {\n\t    const response = await fetch(url);\n\t    const body = await response.text();\n\t    return body;\n\t  }\n", "  /**\n\t   * Restore id and blockType to translations\n\t   *\n\t   * In order to update a document, we need to know the id and blockType of each block.\n\t   *\n\t   * Ideally, id and blockType are not sent to Crowdin - hence\n\t   * we need to restore them from the original document.\n\t   *\n\t   * This currently only works for a top-level `layout` blocks field.\n\t   *\n", "   * TODO: make this work for nested blocks.\n\t   */\n\t  restoreIdAndBlockType = (\n\t    document: any,\n\t    translations: any,\n\t    key: string = \"layout\"\n\t  ) => {\n\t    if (translations.hasOwnProperty(key)) {\n\t      translations[key] = translations[key].map(\n\t        (block: any, index: number) => ({\n", "          ...block,\n\t          id: document[key][index].id,\n\t          blockType: document[key][index].blockType,\n\t        })\n\t      );\n\t    }\n\t    return translations;\n\t  };\n\t}\n"]}
{"filename": "src/api/mock/crowdin-client.ts", "chunked_list": ["import { PluginOptions } from \"../../types\";\n\timport {\n\t  ResponseObject,\n\t  SourceFilesModel,\n\t  UploadStorageModel,\n\t  TranslationsModel,\n\t} from \"@crowdin/crowdin-api-client\";\n\t/*\n\t  Crowdin Service mock\n\t  Although it is against best practice to mock an API\n", "  response, Crowdin and Payload CMS need to perform\n\t  multiple interdependent operations.\n\t  As a result, for effective testing, mocks are required\n\t  to provide Payload with expected data for subsequent\n\t  operations.\n\t  Importing types from the Crowdin API client provides\n\t  assurance that the mock returns expected data structures.\n\t*/\n\tclass crowdinAPIWrapper {\n\t  projectId: number;\n", "  directoryId?: number;\n\t  branchId: number;\n\t  constructor(pluginOptions: PluginOptions) {\n\t    this.projectId = pluginOptions.projectId;\n\t    this.directoryId = pluginOptions.directoryId;\n\t    this.branchId = 4;\n\t  }\n\t  async listFileRevisions(projectId: number, fileId: number) {\n\t    return await Promise.resolve(1).then(() => undefined);\n\t  }\n", "  async createDirectory(\n\t    projectId: number,\n\t    {\n\t      directoryId = 1179,\n\t      name,\n\t      title = \"undefined\",\n\t    }: SourceFilesModel.CreateDirectoryRequest\n\t  ): Promise<ResponseObject<SourceFilesModel.Directory>> {\n\t    return await Promise.resolve(1).then(() => {\n\t      const date = new Date().toISOString();\n", "      return {\n\t        data: {\n\t          id: 1169,\n\t          projectId: this.projectId,\n\t          branchId: this.branchId,\n\t          directoryId,\n\t          name: name,\n\t          title: title,\n\t          exportPattern: \"**\",\n\t          priority: \"normal\",\n", "          createdAt: date,\n\t          updatedAt: date,\n\t        },\n\t      };\n\t    });\n\t  }\n\t  async addStorage(\n\t    fileName: string,\n\t    request: any,\n\t    contentType?: string\n", "  ): Promise<ResponseObject<UploadStorageModel.Storage>> {\n\t    const storage = await Promise.resolve(1).then(() => {\n\t      return {\n\t        data: {\n\t          id: 1788135621,\n\t          fileName,\n\t        },\n\t      };\n\t    });\n\t    return storage;\n", "  }\n\t  async deleteFile(projectId: number, fileId: number): Promise<void> {\n\t    await Promise.resolve(1).then(() => undefined);\n\t  }\n\t  async deleteDirectory(projectId: number, directoryId: number): Promise<void> {\n\t    await Promise.resolve(1).then(() => undefined);\n\t  }\n\t  async createFile(\n\t    projectId: number,\n\t    {\n", "      directoryId = 1172,\n\t      name,\n\t      storageId,\n\t      type = \"html\",\n\t    }: SourceFilesModel.CreateFileRequest\n\t  ): Promise<ResponseObject<SourceFilesModel.File>> {\n\t    /*const storageId = await this.addStorage({\n\t      name,\n\t      fileData,\n\t      fileType,\n", "    })*/\n\t    const file = await Promise.resolve(1).then(() => {\n\t      const date = new Date().toISOString();\n\t      return {\n\t        data: {\n\t          revisionId: 5,\n\t          status: \"active\",\n\t          priority: \"normal\" as SourceFilesModel.Priority,\n\t          importOptions: {} as any,\n\t          exportOptions: {} as any,\n", "          excludedTargetLanguages: [],\n\t          createdAt: date,\n\t          updatedAt: date,\n\t          id: 1079,\n\t          projectId,\n\t          branchId: this.branchId,\n\t          directoryId,\n\t          name: name,\n\t          title: name,\n\t          type,\n", "          path: `/policies/security-and-privacy/${name}`,\n\t          parserVersion: 3,\n\t        },\n\t      };\n\t    });\n\t    return file;\n\t  }\n\t  async updateOrRestoreFile(\n\t    projectId: number,\n\t    fileId: number,\n", "    { storageId }: SourceFilesModel.ReplaceFileFromStorageRequest\n\t  ): Promise<ResponseObject<SourceFilesModel.File>> {\n\t    /*const storageId = await this.addStorage({\n\t      name,\n\t      fileData,\n\t      fileType,\n\t    })*/\n\t    const file = await Promise.resolve(1).then(() => {\n\t      const date = new Date().toISOString();\n\t      return {\n", "        data: {\n\t          revisionId: 5,\n\t          status: \"active\",\n\t          priority: \"normal\" as SourceFilesModel.Priority,\n\t          importOptions: {} as any,\n\t          exportOptions: {} as any,\n\t          excludedTargetLanguages: [],\n\t          createdAt: date,\n\t          updatedAt: date,\n\t          id: 1079,\n", "          projectId,\n\t          branchId: this.branchId,\n\t          directoryId: this.directoryId as number,\n\t          name: \"file\",\n\t          title: \"file\",\n\t          type: \"html\",\n\t          path: `/policies/security-and-privacy/file.filetype`,\n\t          parserVersion: 3,\n\t        },\n\t      };\n", "    });\n\t    return file;\n\t  }\n\t  async buildProjectFileTranslation(\n\t    projectId: number,\n\t    fileId: number,\n\t    { targetLanguageId }: TranslationsModel.BuildProjectFileTranslationRequest\n\t  ): Promise<\n\t    ResponseObject<TranslationsModel.BuildProjectFileTranslationResponse>\n\t  > {\n", "    const build = await Promise.resolve(1).then(() => {\n\t      const date = new Date().toISOString();\n\t      return {\n\t        data: {\n\t          id: 1,\n\t          projectId,\n\t          branchId: this.branchId,\n\t          fileId,\n\t          languageId: \"en\",\n\t          status: \"inProgress\",\n", "          progress: 0,\n\t          createdAt: date,\n\t          updatedAt: date,\n\t          etag: \"string\",\n\t          url: `https://api.crowdin.com/api/v2/projects/1/translations/builds/1/download?targetLanguageId=${targetLanguageId}`,\n\t          expireIn: \"string\",\n\t        },\n\t      };\n\t    });\n\t    return build;\n", "  }\n\t}\n\texport function mockCrowdinClient(pluginOptions: PluginOptions) {\n\t  return new crowdinAPIWrapper(pluginOptions);\n\t}\n"]}
{"filename": "src/utilities/index.spec.ts", "chunked_list": ["import { Block, CollectionConfig, GlobalConfig } from \"payload/types\";\n\timport {\n\t  getLocalizedFields,\n\t  fieldChanged,\n\t  containsLocalizedFields,\n\t  getFieldSlugs,\n\t} from \".\";\n\timport deepEqual from \"deep-equal\";\n\tdescribe(\"Function: containsLocalizedFields\", () => {\n\t  it(\"detects localized fields on the top-level\", () => {\n", "    const global: GlobalConfig = {\n\t      slug: \"global\",\n\t      fields: [\n\t        {\n\t          name: \"simpleLocalizedField\",\n\t          type: \"richText\",\n\t          localized: true,\n\t        },\n\t        {\n\t          name: \"simpleNonLocalizedField\",\n", "          type: \"text\",\n\t        },\n\t      ],\n\t    };\n\t    expect(containsLocalizedFields({ fields: global.fields })).toBe(true);\n\t  });\n\t  it(\"detects localized fields in a group field\", () => {\n\t    const global: GlobalConfig = {\n\t      slug: \"global\",\n\t      fields: [\n", "        {\n\t          name: \"simpleNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"groupField\",\n\t          type: \"group\",\n\t          fields: [\n\t            {\n\t              name: \"simpleLocalizedField\",\n", "              type: \"richText\",\n\t              localized: true,\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    };\n\t    expect(containsLocalizedFields({ fields: global.fields })).toBe(true);\n\t  });\n\t  it(\"detects localized fields in an array field\", () => {\n", "    const global: GlobalConfig = {\n\t      slug: \"global\",\n\t      fields: [\n\t        {\n\t          name: \"simpleNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"arrayField\",\n\t          type: \"array\",\n", "          fields: [\n\t            {\n\t              name: \"richText\",\n\t              type: \"richText\",\n\t              localized: true,\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    };\n", "    expect(containsLocalizedFields({ fields: global.fields })).toBe(true);\n\t  });\n\t  it(\"returns false if no localized fields in a blocks field\", () => {\n\t    const TestBlock: Block = {\n\t      slug: \"text\",\n\t      imageAltText: \"Text\",\n\t      fields: [\n\t        {\n\t          name: \"title\",\n\t          type: \"text\",\n", "        },\n\t        {\n\t          name: \"text\",\n\t          type: \"richText\",\n\t        },\n\t        {\n\t          name: \"select\",\n\t          type: \"select\",\n\t          options: [\"one\", \"two\"],\n\t        },\n", "      ],\n\t    };\n\t    const global: GlobalConfig = {\n\t      slug: \"global\",\n\t      fields: [\n\t        {\n\t          name: \"simpleNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n", "          name: \"blocksField\",\n\t          type: \"blocks\",\n\t          blocks: [TestBlock],\n\t        },\n\t      ],\n\t    };\n\t    expect(containsLocalizedFields({ fields: global.fields })).toBe(false);\n\t  });\n\t});\n\tdescribe(\"Function: fieldChanged\", () => {\n", "  it(\"detects a richText field change on create\", () => {\n\t    const before = undefined;\n\t    const after = {\n\t      children: [\n\t        {\n\t          text: \"Test content\",\n\t        },\n\t      ],\n\t    };\n\t    const type = \"richText\";\n", "    expect(fieldChanged(before, after, type)).toEqual(true);\n\t  });\n\t  it(\"detects a richText field change on update\", () => {\n\t    const before = {\n\t      children: [\n\t        {\n\t          text: \"Test content before\",\n\t        },\n\t      ],\n\t    };\n", "    const after = {\n\t      children: [\n\t        {\n\t          text: \"Test content\",\n\t        },\n\t      ],\n\t    };\n\t    const type = \"richText\";\n\t    expect(fieldChanged(before, after, type)).toEqual(true);\n\t  });\n", "  it(\"returns false for equal richText objects\", () => {\n\t    const before = {\n\t      children: [\n\t        {\n\t          text: \"Test content\",\n\t        },\n\t      ],\n\t    };\n\t    const after = before;\n\t    const type = \"richText\";\n", "    expect(fieldChanged(before, after, type)).toEqual(false);\n\t  });\n\t});\n\t/**\n\t * Test the deep-equal dependency\n\t *\n\t * Usually, tests should not be done on third\n\t * party libraries but in this case, we need to\n\t * be sure key order does not matter.\n\t */\n", "describe(\"deep-equal\", () => {\n\t  it(\"returns equal if keys are in a different order\", () => {\n\t    const obj1 = {\n\t      title: \"Sample article\",\n\t      content: [\n\t        {\n\t          children: [\n\t            {\n\t              text: \"Heading 2\",\n\t            },\n", "          ],\n\t          type: \"h2\",\n\t        },\n\t        {\n\t          children: [\n\t            {\n\t              text: \"A regular paragraph.\",\n\t            },\n\t          ],\n\t        },\n", "      ],\n\t      meta: {\n\t        title: \"Sample article | Company\",\n\t        description: \"\",\n\t      },\n\t    };\n\t    const obj2 = {\n\t      title: \"Sample article\",\n\t      meta: {\n\t        description: \"\",\n", "        title: \"Sample article | Company\",\n\t      },\n\t      content: [\n\t        {\n\t          children: [\n\t            {\n\t              text: \"Heading 2\",\n\t            },\n\t          ],\n\t          type: \"h2\",\n", "        },\n\t        {\n\t          children: [\n\t            {\n\t              text: \"A regular paragraph.\",\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    };\n", "    expect(deepEqual(obj1, obj2)).toBe(true);\n\t  });\n\t});\n"]}
{"filename": "src/utilities/isLocalizedField.spec.ts", "chunked_list": ["import { Field } from \"payload/types\";\n\timport { isLocalizedField } from \".\";\n\tdescribe(\"fn: isLocalizedField\", () => {\n\t  it(\"excludes a select localized field\", () => {\n\t    const field: Field = {\n\t      name: \"select\",\n\t      type: \"select\",\n\t      localized: true,\n\t      options: [\"one\", \"two\"],\n\t    };\n", "    expect(isLocalizedField(field)).toBe(false);\n\t  });\n\t});\n"]}
{"filename": "src/utilities/getFieldSlugs.spec.ts", "chunked_list": ["import { CollectionConfig, GlobalConfig } from \"payload/types\";\n\timport { getLocalizedFields, getFieldSlugs } from \".\";\n\tdescribe(\"Function: getFieldSlugs\", () => {\n\t  it(\"detects top-level richText fields\", () => {\n\t    const Policies: CollectionConfig = {\n\t      slug: \"policies\",\n\t      admin: {\n\t        defaultColumns: [\"title\", \"updatedDate\"],\n\t        useAsTitle: \"title\",\n\t        group: \"Pages\",\n", "      },\n\t      access: {\n\t        read: () => true,\n\t      },\n\t      versions: {\n\t        drafts: true,\n\t      },\n\t      fields: [\n\t        {\n\t          name: \"title\",\n", "          type: \"text\",\n\t          localized: true,\n\t        },\n\t        {\n\t          name: \"updatedDate\",\n\t          type: \"date\",\n\t          admin: {\n\t            description:\n\t              \"If set, this updated date/time will be displayed on the policy page.\",\n\t          },\n", "        },\n\t        {\n\t          name: \"content\",\n\t          type: \"richText\",\n\t          localized: true,\n\t        },\n\t      ],\n\t    };\n\t    const htmlFields = getLocalizedFields({\n\t      fields: Policies.fields,\n", "      type: \"html\",\n\t    });\n\t    expect(getFieldSlugs(htmlFields)).toEqual([\"content\"]);\n\t  });\n\t  it(\"returns an empty array if no rich text fields\", () => {\n\t    const Statistics: GlobalConfig = {\n\t      slug: \"statistics\",\n\t      access: {\n\t        read: () => true,\n\t      },\n", "      fields: [\n\t        {\n\t          name: \"users\",\n\t          type: \"group\",\n\t          fields: [\n\t            {\n\t              name: \"text\",\n\t              type: \"text\",\n\t              localized: true,\n\t            },\n", "            {\n\t              name: \"number\",\n\t              type: \"number\",\n\t              min: 0,\n\t              admin: {\n\t                step: 100,\n\t                description:\n\t                  \"Restricted to multiples of 100 in order to simplify localization.\",\n\t              },\n\t            },\n", "          ],\n\t        },\n\t        {\n\t          name: \"companies\",\n\t          type: \"group\",\n\t          fields: [\n\t            {\n\t              name: \"text\",\n\t              type: \"text\",\n\t              localized: true,\n", "            },\n\t            {\n\t              name: \"number\",\n\t              type: \"number\",\n\t              min: 0,\n\t              admin: {\n\t                step: 100,\n\t                description:\n\t                  \"Restricted to multiples of 100 in order to simplify localization.\",\n\t              },\n", "            },\n\t          ],\n\t        },\n\t        {\n\t          name: \"countries\",\n\t          type: \"group\",\n\t          fields: [\n\t            {\n\t              name: \"text\",\n\t              type: \"text\",\n", "              localized: true,\n\t            },\n\t            {\n\t              name: \"number\",\n\t              type: \"number\",\n\t              min: 0,\n\t              admin: {\n\t                step: 1,\n\t              },\n\t            },\n", "          ],\n\t        },\n\t        {\n\t          name: \"successfulHires\",\n\t          type: \"group\",\n\t          fields: [\n\t            {\n\t              name: \"text\",\n\t              type: \"text\",\n\t              localized: true,\n", "            },\n\t            {\n\t              name: \"number\",\n\t              type: \"number\",\n\t              min: 0,\n\t              admin: {\n\t                step: 100,\n\t                description:\n\t                  \"Restricted to multiples of 100 in order to simplify localization.\",\n\t              },\n", "            },\n\t          ],\n\t        },\n\t      ],\n\t    };\n\t    const htmlFields = getLocalizedFields({\n\t      fields: Statistics.fields,\n\t      type: \"html\",\n\t    });\n\t    expect(getFieldSlugs(htmlFields)).toEqual([]);\n", "  });\n\t});\n"]}
{"filename": "src/utilities/containsLocalizedFields.spec.ts", "chunked_list": ["import { CollectionConfig, Field, GlobalConfig } from \"payload/types\";\n\timport { containsLocalizedFields, getLocalizedFields } from \".\";\n\tdescribe(\"fn: containsLocalizedFields: true tests\", () => {\n\t  describe(\"basic field type tests\", () => {\n\t    it(\"includes localized fields from a group field\", () => {\n\t      const fields: Field[] = [\n\t        {\n\t          name: \"simpleLocalizedField\",\n\t          type: \"text\",\n\t          localized: true,\n", "        },\n\t        {\n\t          name: \"simpleNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"groupField\",\n\t          type: \"group\",\n\t          fields: [\n\t            {\n", "              name: \"simpleLocalizedField\",\n\t              type: \"text\",\n\t              localized: true,\n\t            },\n\t            {\n\t              name: \"simpleNonLocalizedField\",\n\t              type: \"text\",\n\t            },\n\t            // select fields not supported yet\n\t            {\n", "              name: \"text\",\n\t              type: \"select\",\n\t              localized: true,\n\t              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n\t        },\n\t      ];\n\t      expect(containsLocalizedFields({ fields })).toEqual(true);\n\t    });\n", "    it(\"includes localized fields from an array field\", () => {\n\t      const fields: Field[] = [\n\t        {\n\t          name: \"simpleLocalizedField\",\n\t          type: \"text\",\n\t          localized: true,\n\t        },\n\t        {\n\t          name: \"simpleNonLocalizedField\",\n\t          type: \"text\",\n", "        },\n\t        {\n\t          name: \"arrayField\",\n\t          type: \"array\",\n\t          fields: [\n\t            {\n\t              name: \"title\",\n\t              type: \"text\",\n\t              localized: true,\n\t            },\n", "            {\n\t              name: \"text\",\n\t              type: \"text\",\n\t              localized: true,\n\t            },\n\t            {\n\t              name: \"select\",\n\t              type: \"select\",\n\t              localized: true,\n\t              options: [\"one\", \"two\"],\n", "            },\n\t          ],\n\t        },\n\t      ];\n\t      expect(containsLocalizedFields({ fields })).toEqual(true);\n\t    });\n\t    it(\"includes localized fields from an array with a localization setting on the array field\", () => {\n\t      const fields: Field[] = [\n\t        {\n\t          name: \"simpleLocalizedField\",\n", "          type: \"text\",\n\t          localized: true,\n\t        },\n\t        {\n\t          name: \"simpleNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"arrayField\",\n\t          type: \"array\",\n", "          localized: true,\n\t          fields: [\n\t            {\n\t              name: \"title\",\n\t              type: \"text\",\n\t            },\n\t            {\n\t              name: \"text\",\n\t              type: \"text\",\n\t            },\n", "            {\n\t              name: \"select\",\n\t              type: \"select\",\n\t              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n\t        },\n\t      ];\n\t      expect(containsLocalizedFields({ fields })).toEqual(true);\n\t    });\n", "    it(\"includes localized fields from an array inside a collapsible field where the top-level field group only contains collapsible fields\", () => {\n\t      const fields: Field[] = [\n\t        {\n\t          label: \"Array fields\",\n\t          type: \"collapsible\",\n\t          fields: [\n\t            {\n\t              name: \"arrayField\",\n\t              type: \"array\",\n\t              fields: [\n", "                {\n\t                  name: \"title\",\n\t                  type: \"richText\",\n\t                  localized: true,\n\t                },\n\t                {\n\t                  name: \"content\",\n\t                  type: \"richText\",\n\t                  localized: true,\n\t                },\n", "                {\n\t                  name: \"select\",\n\t                  type: \"select\",\n\t                  localized: true,\n\t                  options: [\"one\", \"two\"],\n\t                },\n\t              ],\n\t            },\n\t          ],\n\t        },\n", "      ];\n\t      expect(containsLocalizedFields({ fields })).toEqual(true);\n\t    });\n\t    /**\n\t     * * help ensure no errors during version 0 development\n\t     * * mitigate against errors if a new field type is introduced by Payload CMS\n\t     */\n\t    it(\"does not include unrecognized field types\", () => {\n\t      const fields: any[] = [\n\t        {\n", "          name: \"textLocalizedField\",\n\t          type: \"text\",\n\t          localized: true,\n\t        },\n\t        {\n\t          name: \"textNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"unknownLocalizedField\",\n", "          type: \"weird\",\n\t          localized: true,\n\t        },\n\t        {\n\t          name: \"Unknown Field type\",\n\t          type: \"strange\",\n\t          fields: [\n\t            {\n\t              name: \"textLocalizedFieldInCollapsibleField\",\n\t              type: \"text\",\n", "              localized: true,\n\t            },\n\t            {\n\t              name: \"textNonLocalizedFieldInCollapsibleField\",\n\t              type: \"text\",\n\t            },\n\t            // select fields not supported yet\n\t            {\n\t              name: \"selectLocalizedFieldInCollapsibleField\",\n\t              type: \"select\",\n", "              localized: true,\n\t              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n\t        },\n\t      ];\n\t      expect(containsLocalizedFields({ fields })).toEqual(true);\n\t    });\n\t    it(\"includes localized fields from a group field\", () => {\n\t      const fields: Field[] = [\n", "        {\n\t          name: \"simpleLocalizedField\",\n\t          type: \"text\",\n\t          localized: true,\n\t        },\n\t        {\n\t          name: \"simpleNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n", "          name: \"groupField\",\n\t          type: \"group\",\n\t          fields: [\n\t            {\n\t              name: \"simpleLocalizedField\",\n\t              type: \"text\",\n\t              localized: true,\n\t            },\n\t            {\n\t              name: \"simpleNonLocalizedField\",\n", "              type: \"text\",\n\t            },\n\t            // select fields not supported yet\n\t            {\n\t              name: \"text\",\n\t              type: \"select\",\n\t              localized: true,\n\t              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n", "        },\n\t      ];\n\t      expect(containsLocalizedFields({ fields })).toEqual(true);\n\t    });\n\t    it(\"includes localized fields from a group field with a localization setting on the group field\", () => {\n\t      const fields: Field[] = [\n\t        {\n\t          name: \"simpleLocalizedField\",\n\t          type: \"text\",\n\t          localized: true,\n", "        },\n\t        {\n\t          name: \"simpleNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"groupField\",\n\t          type: \"group\",\n\t          localized: true,\n\t          fields: [\n", "            {\n\t              name: \"textLocalizedField\",\n\t              type: \"text\",\n\t            },\n\t            {\n\t              name: \"richTextLocalizedField\",\n\t              type: \"richText\",\n\t            },\n\t            // select fields not supported yet\n\t            {\n", "              name: \"text\",\n\t              type: \"select\",\n\t              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n\t        },\n\t      ];\n\t      expect(containsLocalizedFields({ fields })).toEqual(true);\n\t    });\n\t  });\n", "  it(\"includes localized fields from a group field with a localization setting on the group field: localized parent only\", () => {\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"groupField\",\n\t        type: \"group\",\n\t        localized: true,\n\t        fields: [\n\t          {\n\t            name: \"textLocalizedField\",\n\t            type: \"text\",\n", "          },\n\t          {\n\t            name: \"richTextLocalizedField\",\n\t            type: \"richText\",\n\t          },\n\t          // select fields not supported yet\n\t          {\n\t            name: \"text\",\n\t            type: \"select\",\n\t            options: [\"one\", \"two\"],\n", "          },\n\t        ],\n\t      },\n\t    ];\n\t    expect(containsLocalizedFields({ fields })).toEqual(true);\n\t  });\n\t  describe(\"extract rich text localized fields\", () => {\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"simpleLocalizedField\",\n", "        type: \"richText\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"simpleNonLocalizedField\",\n\t        type: \"text\",\n\t      },\n\t      {\n\t        name: \"arrayField\",\n\t        type: \"array\",\n", "        fields: [\n\t          {\n\t            name: \"title\",\n\t            type: \"text\",\n\t            localized: true,\n\t          },\n\t          {\n\t            name: \"richText\",\n\t            type: \"richText\",\n\t            localized: true,\n", "          },\n\t          {\n\t            name: \"select\",\n\t            type: \"select\",\n\t            localized: true,\n\t            options: [\"one\", \"two\"],\n\t          },\n\t        ],\n\t      },\n\t      {\n", "        name: \"groupField\",\n\t        type: \"group\",\n\t        fields: [\n\t          {\n\t            name: \"simpleLocalizedField\",\n\t            type: \"richText\",\n\t            localized: true,\n\t          },\n\t          {\n\t            name: \"simpleNonLocalizedField\",\n", "            type: \"text\",\n\t          },\n\t          // select fields not supported yet\n\t          {\n\t            name: \"text\",\n\t            type: \"select\",\n\t            localized: true,\n\t            options: [\"one\", \"two\"],\n\t          },\n\t        ],\n", "      },\n\t    ];\n\t    expect(containsLocalizedFields({ fields })).toEqual(true);\n\t  });\n\t  it(\"returns nested json fields in a group inside an array\", () => {\n\t    const linkField: Field = {\n\t      name: \"link\",\n\t      type: \"group\",\n\t      fields: [\n\t        {\n", "          name: \"text\",\n\t          type: \"text\",\n\t          localized: true,\n\t        },\n\t        {\n\t          name: \"href\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"type\",\n", "          type: \"select\",\n\t          options: [\"ctaPrimary\", \"ctaSecondary\"],\n\t        },\n\t      ],\n\t    };\n\t    const Promos: CollectionConfig = {\n\t      slug: \"promos\",\n\t      admin: {\n\t        defaultColumns: [\"title\", \"updatedAt\"],\n\t        useAsTitle: \"title\",\n", "        group: \"Shared\",\n\t      },\n\t      access: {\n\t        read: () => true,\n\t      },\n\t      fields: [\n\t        {\n\t          name: \"title\",\n\t          type: \"text\",\n\t          localized: true,\n", "        },\n\t        {\n\t          name: \"text\",\n\t          type: \"text\",\n\t          localized: true,\n\t        },\n\t        {\n\t          name: \"ctas\",\n\t          type: \"array\",\n\t          minRows: 1,\n", "          maxRows: 2,\n\t          fields: [linkField],\n\t        },\n\t      ],\n\t    };\n\t    expect(containsLocalizedFields({ fields: Promos.fields })).toEqual(true);\n\t  });\n\t});\n\tdescribe(\"fn: containsLocalizedFields: false tests\", () => {\n\t  describe(\"basic field type tests\", () => {\n", "    it(\"includes localized fields from a group field\", () => {\n\t      const fields: Field[] = [\n\t        {\n\t          name: \"simpleLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"simpleNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n", "        {\n\t          name: \"groupField\",\n\t          type: \"group\",\n\t          fields: [\n\t            {\n\t              name: \"simpleLocalizedField\",\n\t              type: \"text\",\n\t            },\n\t            {\n\t              name: \"simpleNonLocalizedField\",\n", "              type: \"text\",\n\t            },\n\t            // select fields not supported yet\n\t            {\n\t              name: \"text\",\n\t              type: \"select\",\n\t              localized: true,\n\t              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n", "        },\n\t      ];\n\t      expect(containsLocalizedFields({ fields })).toEqual(false);\n\t    });\n\t    it(\"includes localized fields from an array field\", () => {\n\t      const fields: Field[] = [\n\t        {\n\t          name: \"simpleLocalizedField\",\n\t          type: \"text\",\n\t        },\n", "        {\n\t          name: \"simpleNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"arrayField\",\n\t          type: \"array\",\n\t          fields: [\n\t            {\n\t              name: \"title\",\n", "              type: \"text\",\n\t            },\n\t            {\n\t              name: \"text\",\n\t              type: \"text\",\n\t            },\n\t            {\n\t              name: \"select\",\n\t              type: \"select\",\n\t              localized: true,\n", "              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n\t        },\n\t      ];\n\t      expect(containsLocalizedFields({ fields })).toEqual(false);\n\t    });\n\t    it(\"includes localized fields from an array with a localization setting on the array field\", () => {\n\t      const fields: Field[] = [\n\t        {\n", "          name: \"simpleLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"simpleNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"arrayField\",\n\t          type: \"array\",\n", "          fields: [\n\t            {\n\t              name: \"title\",\n\t              type: \"text\",\n\t            },\n\t            {\n\t              name: \"text\",\n\t              type: \"text\",\n\t            },\n\t            {\n", "              name: \"select\",\n\t              type: \"select\",\n\t              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n\t        },\n\t      ];\n\t      expect(containsLocalizedFields({ fields })).toEqual(false);\n\t    });\n\t    it(\"includes localized fields from an array inside a collapsible field where the top-level field group only contains collapsible fields\", () => {\n", "      const fields: Field[] = [\n\t        {\n\t          label: \"Array fields\",\n\t          type: \"collapsible\",\n\t          fields: [\n\t            {\n\t              name: \"arrayField\",\n\t              type: \"array\",\n\t              fields: [\n\t                {\n", "                  name: \"title\",\n\t                  type: \"richText\",\n\t                },\n\t                {\n\t                  name: \"content\",\n\t                  type: \"richText\",\n\t                },\n\t                {\n\t                  name: \"select\",\n\t                  type: \"select\",\n", "                  options: [\"one\", \"two\"],\n\t                },\n\t              ],\n\t            },\n\t          ],\n\t        },\n\t      ];\n\t      expect(containsLocalizedFields({ fields })).toEqual(false);\n\t    });\n\t    /**\n", "     * * help ensure no errors during version 0 development\n\t     * * mitigate against errors if a new field type is introduced by Payload CMS\n\t     */\n\t    it(\"does not include unrecognized field types\", () => {\n\t      const fields: any[] = [\n\t        {\n\t          name: \"textLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n", "          name: \"textNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"unknownLocalizedField\",\n\t          type: \"weird\",\n\t          localized: true,\n\t        },\n\t        {\n\t          name: \"Unknown Field type\",\n", "          type: \"strange\",\n\t          fields: [\n\t            {\n\t              name: \"textLocalizedFieldInCollapsibleField\",\n\t              type: \"text\",\n\t              localized: true,\n\t            },\n\t            {\n\t              name: \"textNonLocalizedFieldInCollapsibleField\",\n\t              type: \"text\",\n", "            },\n\t            // select fields not supported yet\n\t            {\n\t              name: \"selectLocalizedFieldInCollapsibleField\",\n\t              type: \"select\",\n\t              localized: true,\n\t              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n\t        },\n", "      ];\n\t      expect(containsLocalizedFields({ fields })).toEqual(false);\n\t    });\n\t    it(\"includes localized fields from a group field\", () => {\n\t      const fields: Field[] = [\n\t        {\n\t          name: \"simpleLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n", "          name: \"simpleNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"groupField\",\n\t          type: \"group\",\n\t          fields: [\n\t            {\n\t              name: \"simpleLocalizedField\",\n\t              type: \"text\",\n", "            },\n\t            {\n\t              name: \"simpleNonLocalizedField\",\n\t              type: \"text\",\n\t            },\n\t            // select fields not supported yet\n\t            {\n\t              name: \"text\",\n\t              type: \"select\",\n\t              localized: true,\n", "              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n\t        },\n\t      ];\n\t      expect(containsLocalizedFields({ fields })).toEqual(false);\n\t    });\n\t    it(\"includes localized fields from a group field with a localization setting on the group field\", () => {\n\t      const fields: Field[] = [\n\t        {\n", "          name: \"simpleLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"simpleNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"groupField\",\n\t          type: \"group\",\n", "          fields: [\n\t            {\n\t              name: \"textLocalizedField\",\n\t              type: \"text\",\n\t            },\n\t            {\n\t              name: \"richTextLocalizedField\",\n\t              type: \"richText\",\n\t            },\n\t            // select fields not supported yet\n", "            {\n\t              name: \"text\",\n\t              type: \"select\",\n\t              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n\t        },\n\t      ];\n\t      expect(containsLocalizedFields({ fields })).toEqual(false);\n\t    });\n", "  });\n\t  describe(\"extract rich text localized fields\", () => {\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"simpleLocalizedField\",\n\t        type: \"richText\",\n\t      },\n\t      {\n\t        name: \"simpleNonLocalizedField\",\n\t        type: \"text\",\n", "      },\n\t      {\n\t        name: \"arrayField\",\n\t        type: \"array\",\n\t        fields: [\n\t          {\n\t            name: \"title\",\n\t            type: \"text\",\n\t          },\n\t          {\n", "            name: \"richText\",\n\t            type: \"richText\",\n\t          },\n\t          {\n\t            name: \"select\",\n\t            type: \"select\",\n\t            options: [\"one\", \"two\"],\n\t          },\n\t        ],\n\t      },\n", "      {\n\t        name: \"groupField\",\n\t        type: \"group\",\n\t        fields: [\n\t          {\n\t            name: \"simpleLocalizedField\",\n\t            type: \"richText\",\n\t          },\n\t          {\n\t            name: \"simpleNonLocalizedField\",\n", "            type: \"text\",\n\t          },\n\t          // select fields not supported yet\n\t          {\n\t            name: \"text\",\n\t            type: \"select\",\n\t            localized: true,\n\t            options: [\"one\", \"two\"],\n\t          },\n\t        ],\n", "      },\n\t    ];\n\t    expect(containsLocalizedFields({ fields })).toEqual(false);\n\t  });\n\t  it(\"returns nested json fields in a group inside an array\", () => {\n\t    const linkField: Field = {\n\t      name: \"link\",\n\t      type: \"group\",\n\t      fields: [\n\t        {\n", "          name: \"text\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"href\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"type\",\n\t          type: \"select\",\n", "          options: [\"ctaPrimary\", \"ctaSecondary\"],\n\t        },\n\t      ],\n\t    };\n\t    const Promos: CollectionConfig = {\n\t      slug: \"promos\",\n\t      admin: {\n\t        defaultColumns: [\"title\", \"updatedAt\"],\n\t        useAsTitle: \"title\",\n\t        group: \"Shared\",\n", "      },\n\t      access: {\n\t        read: () => true,\n\t      },\n\t      fields: [\n\t        {\n\t          name: \"title\",\n\t          type: \"text\",\n\t        },\n\t        {\n", "          name: \"text\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"ctas\",\n\t          type: \"array\",\n\t          minRows: 1,\n\t          maxRows: 2,\n\t          fields: [linkField],\n\t        },\n", "      ],\n\t    };\n\t    expect(containsLocalizedFields({ fields: Promos.fields })).toEqual(false);\n\t  });\n\t});\n"]}
{"filename": "src/utilities/index.ts", "chunked_list": ["import {\n\t  Block,\n\t  CollapsibleField,\n\t  CollectionConfig,\n\t  Field,\n\t  GlobalConfig,\n\t} from \"payload/types\";\n\timport deepEqual from \"deep-equal\";\n\timport { FieldWithName } from \"../types\";\n\timport { slateToHtml, payloadSlateToDomConfig } from \"slate-serializers\";\n", "import type { Descendant } from \"slate\";\n\timport { get, isEmpty, map, merge, omitBy } from \"lodash\";\n\timport dot from \"dot-object\";\n\tconst localizedFieldTypes = [\"richText\", \"text\", \"textarea\"];\n\tconst nestedFieldTypes = [\"array\", \"group\", \"blocks\"];\n\texport const containsNestedFields = (field: Field) =>\n\t  nestedFieldTypes.includes(field.type);\n\texport const getLocalizedFields = ({\n\t  fields,\n\t  type,\n", "  localizedParent = false,\n\t}: {\n\t  fields: Field[];\n\t  type?: \"json\" | \"html\";\n\t  localizedParent?: boolean;\n\t}): any[] => {\n\t  const localizedFields = getLocalizedFieldsRecursive({\n\t    fields,\n\t    type,\n\t    localizedParent,\n", "  });\n\t  return localizedFields;\n\t};\n\texport const getLocalizedFieldsRecursive = ({\n\t  fields,\n\t  type,\n\t  localizedParent = false,\n\t}: {\n\t  fields: Field[];\n\t  type?: \"json\" | \"html\";\n", "  localizedParent?: boolean;\n\t}): any[] => [\n\t  ...fields\n\t    // localized or group fields only.\n\t    .filter(\n\t      (field) =>\n\t        isLocalizedField(field, localizedParent) || containsNestedFields(field)\n\t    )\n\t    // further filter on Crowdin field type\n\t    .filter((field) => {\n", "      if (containsNestedFields(field)) {\n\t        return true;\n\t      }\n\t      return type\n\t        ? fieldCrowdinFileType(field as FieldWithName) === type\n\t        : true;\n\t    })\n\t    // exclude group, array and block fields with no localized fields\n\t    // TODO: find a better way to do this - block, array and group logic is duplicated, and this filter needs to be compatible with field extraction logic later in this function\n\t    .filter((field) => {\n", "      const localizedParent = hasLocalizedProp(field);\n\t      if (field.type === \"group\" || field.type === \"array\") {\n\t        return containsLocalizedFields({\n\t          fields: field.fields,\n\t          type,\n\t          localizedParent,\n\t        });\n\t      }\n\t      if (field.type === \"blocks\") {\n\t        return field.blocks.find((block) =>\n", "          containsLocalizedFields({\n\t            fields: block.fields,\n\t            type,\n\t            localizedParent,\n\t          })\n\t        );\n\t      }\n\t      return true;\n\t    })\n\t    // recursion for group, array and blocks field\n", "    .map((field) => {\n\t      const localizedParent = hasLocalizedProp(field);\n\t      if (field.type === \"group\" || field.type === \"array\") {\n\t        return {\n\t          ...field,\n\t          fields: getLocalizedFields({\n\t            fields: field.fields,\n\t            type,\n\t            localizedParent,\n\t          }),\n", "        };\n\t      }\n\t      if (field.type === \"blocks\") {\n\t        const blocks = field.blocks\n\t          .map((block: Block) => {\n\t            if (\n\t              containsLocalizedFields({\n\t                fields: block.fields,\n\t                type,\n\t                localizedParent,\n", "              })\n\t            ) {\n\t              return {\n\t                slug: block.slug,\n\t                fields: getLocalizedFields({\n\t                  fields: block.fields,\n\t                  type,\n\t                  localizedParent,\n\t                }),\n\t              };\n", "            }\n\t          })\n\t          .filter((block) => block);\n\t        return {\n\t          ...field,\n\t          blocks,\n\t        };\n\t      }\n\t      return field;\n\t    })\n", "    .filter(\n\t      (field) =>\n\t        (field as any).type !== \"collapsible\" && (field as any).type !== \"tabs\"\n\t    ),\n\t  ...convertTabs({ fields }),\n\t  // recursion for collapsible field - flatten results into the returned array\n\t  ...getCollapsibleLocalizedFields({ fields, type }),\n\t];\n\texport const getCollapsibleLocalizedFields = ({\n\t  fields,\n", "  type,\n\t}: {\n\t  fields: Field[];\n\t  type?: \"json\" | \"html\";\n\t}): any[] =>\n\t  fields\n\t    .filter((field) => field.type === \"collapsible\")\n\t    .flatMap((field) =>\n\t      getLocalizedFields({\n\t        fields: (field as CollapsibleField).fields,\n", "        type,\n\t      })\n\t    );\n\texport const convertTabs = ({\n\t  fields,\n\t  type,\n\t}: {\n\t  fields: Field[];\n\t  type?: \"json\" | \"html\";\n\t}): any[] =>\n", "  fields\n\t    .filter((field) => field.type === \"tabs\")\n\t    .flatMap((field) => {\n\t      if (field.type === \"tabs\") {\n\t        const flattenedFields = field.tabs.reduce((tabFields, tab) => {\n\t          return [\n\t            ...tabFields,\n\t            \"name\" in tab\n\t              ? ({\n\t                  type: \"group\",\n", "                  name: tab.name,\n\t                  fields: tab.fields,\n\t                } as Field)\n\t              : ({\n\t                  label: \"fromTab\",\n\t                  type: \"collapsible\",\n\t                  fields: tab.fields,\n\t                } as Field),\n\t          ];\n\t        }, [] as Field[]);\n", "        return getLocalizedFields({\n\t          fields: flattenedFields,\n\t          type,\n\t        });\n\t      }\n\t      return field;\n\t    });\n\texport const getLocalizedRequiredFields = (\n\t  collection: CollectionConfig | GlobalConfig,\n\t  type?: \"json\" | \"html\"\n", "): any[] => {\n\t  const fields = getLocalizedFields({ fields: collection.fields, type });\n\t  return fields.filter((field) => field.required);\n\t};\n\t/**\n\t * Not yet compatible with nested fields - this means nested HTML\n\t * field translations cannot be synced from Crowdin.\n\t */\n\texport const getFieldSlugs = (fields: FieldWithName[]): string[] =>\n\t  fields\n", "    .filter(\n\t      (field: Field) => field.type === \"text\" || field.type === \"richText\"\n\t    )\n\t    .map((field: FieldWithName) => field.name);\n\tconst hasLocalizedProp = (field: Field) =>\n\t  \"localized\" in field && field.localized;\n\t/**\n\t * Is Localized Field\n\t *\n\t * Note that `id` should be excluded - it is a `text` field that is added by Payload CMS.\n", " */\n\texport const isLocalizedField = (\n\t  field: Field,\n\t  addLocalizedProp: boolean = false\n\t) =>\n\t  (hasLocalizedProp(field) || addLocalizedProp) &&\n\t  localizedFieldTypes.includes(field.type) &&\n\t  !excludeBasedOnDescription(field) &&\n\t  (field as any).name !== \"id\";\n\tconst excludeBasedOnDescription = (field: Field) => {\n", "  const description = get(field, \"admin.description\", \"\");\n\t  if (description.includes(\"Not sent to Crowdin. Localize in the CMS.\")) {\n\t    return true;\n\t  }\n\t  return false;\n\t};\n\texport const containsLocalizedFields = ({\n\t  fields,\n\t  type,\n\t  localizedParent,\n", "}: {\n\t  fields: Field[];\n\t  type?: \"json\" | \"html\";\n\t  localizedParent?: boolean;\n\t}): boolean => {\n\t  return !isEmpty(getLocalizedFields({ fields, type, localizedParent }));\n\t};\n\texport const fieldChanged = (\n\t  previousValue: string | object | undefined,\n\t  value: string | object | undefined,\n", "  type: string\n\t) => {\n\t  if (type === \"richText\") {\n\t    return !deepEqual(previousValue || {}, value || {});\n\t  }\n\t  return previousValue !== value;\n\t};\n\texport const removeLineBreaks = (string: string) =>\n\t  string.replace(/(\\r\\n|\\n|\\r)/gm, \"\");\n\texport const fieldCrowdinFileType = (field: FieldWithName): \"json\" | \"html\" =>\n", "  field.type === \"richText\" ? \"html\" : \"json\";\n\t/**\n\t * Reorder blocks and array values based on the order of the original document.\n\t */\n\texport const restoreOrder = ({\n\t  updateDocument,\n\t  document,\n\t  fields,\n\t}: {\n\t  updateDocument: { [key: string]: any };\n", "  document: { [key: string]: any };\n\t  fields: Field[];\n\t}) => {\n\t  let response: { [key: string]: any } = {};\n\t  // it is possible the original document is empty (e.g. new document)\n\t  if (!document) {\n\t    return updateDocument;\n\t  }\n\t  fields.forEach((field: any) => {\n\t    if (!updateDocument || !updateDocument[field.name]) {\n", "      return;\n\t    }\n\t    if (field.type === \"group\") {\n\t      response[field.name] = restoreOrder({\n\t        updateDocument: updateDocument[field.name],\n\t        document: document[field.name],\n\t        fields: field.fields,\n\t      });\n\t    } else if (field.type === \"array\" || field.type === \"blocks\") {\n\t      response[field.name] = document[field.name]\n", "        .map((item: any) => {\n\t          const arrayItem = updateDocument[field.name].find(\n\t            (updateItem: any) => {\n\t              return updateItem.id === item.id;\n\t            }\n\t          );\n\t          if (!arrayItem) {\n\t            return;\n\t          }\n\t          const subFields =\n", "            field.type === \"blocks\"\n\t              ? field.blocks.find(\n\t                  (block: Block) => block.slug === item.blockType\n\t                )?.fields || []\n\t              : field.fields;\n\t          return {\n\t            ...restoreOrder({\n\t              updateDocument: arrayItem,\n\t              document: item,\n\t              fields: subFields,\n", "            }),\n\t            id: arrayItem.id,\n\t            ...(field.type === \"blocks\" && { blockType: arrayItem.blockType }),\n\t          };\n\t        })\n\t        .filter((item: any) => !isEmpty(item));\n\t    } else {\n\t      response[field.name] = updateDocument[field.name];\n\t    }\n\t  });\n", "  return response;\n\t};\n\t/**\n\t * Convert Crowdin objects to Payload CMS data objects.\n\t *\n\t * * `crowdinJsonObject` is the JSON object returned from Crowdin.\n\t * * `crowdinHtmlObject` is the HTML object returned from Crowdin. Optional. Merged into resulting object if provided.\n\t * * `fields` is the collection or global fields array.\n\t * * `topLevel` is a flag used internally to filter json fields before recursion.\n\t * * `document` is the document object. Optional. Used to restore the order of `array` and `blocks` field values.\n", " */\n\texport const buildPayloadUpdateObject = ({\n\t  crowdinJsonObject,\n\t  crowdinHtmlObject,\n\t  fields,\n\t  topLevel = true,\n\t  document,\n\t}: {\n\t  crowdinJsonObject: { [key: string]: any };\n\t  crowdinHtmlObject?: { [key: string]: any };\n", "  /** Use getLocalizedFields to pass localized fields only */\n\t  fields: Field[];\n\t  /** Flag used internally to filter json fields before recursion. */\n\t  topLevel?: boolean;\n\t  document?: { [key: string]: any };\n\t}) => {\n\t  let response: { [key: string]: any } = {};\n\t  if (crowdinHtmlObject) {\n\t    const destructured = dot.object(crowdinHtmlObject);\n\t    merge(crowdinJsonObject, destructured);\n", "  }\n\t  const filteredFields = topLevel\n\t    ? getLocalizedFields({\n\t        fields,\n\t        type: !crowdinHtmlObject ? \"json\" : undefined,\n\t      })\n\t    : fields;\n\t  filteredFields.forEach((field) => {\n\t    if (!crowdinJsonObject[field.name]) {\n\t      return;\n", "    }\n\t    if (field.type === \"group\") {\n\t      response[field.name] = buildPayloadUpdateObject({\n\t        crowdinJsonObject: crowdinJsonObject[field.name],\n\t        fields: field.fields,\n\t        topLevel: false,\n\t      });\n\t    } else if (field.type === \"array\") {\n\t      response[field.name] = map(crowdinJsonObject[field.name], (item, id) => {\n\t        const payloadUpdateObject = buildPayloadUpdateObject({\n", "          crowdinJsonObject: item,\n\t          fields: field.fields,\n\t          topLevel: false,\n\t        });\n\t        return {\n\t          ...payloadUpdateObject,\n\t          id,\n\t        };\n\t      }).filter((item: any) => !isEmpty(item));\n\t    } else if (field.type === \"blocks\") {\n", "      response[field.name] = map(crowdinJsonObject[field.name], (item, id) => {\n\t        // get first and only object key\n\t        const blockType = Object.keys(item)[0];\n\t        const payloadUpdateObject = buildPayloadUpdateObject({\n\t          crowdinJsonObject: item[blockType],\n\t          fields:\n\t            field.blocks.find((block: Block) => block.slug === blockType)\n\t              ?.fields || [],\n\t          topLevel: false,\n\t        });\n", "        return {\n\t          ...payloadUpdateObject,\n\t          id,\n\t          blockType,\n\t        };\n\t      }).filter((item: any) => !isEmpty(item));\n\t    } else {\n\t      response[field.name] = crowdinJsonObject[field.name];\n\t    }\n\t  });\n", "  if (document) {\n\t    response = restoreOrder({\n\t      updateDocument: response,\n\t      document,\n\t      fields,\n\t    });\n\t  }\n\t  return omitBy(response, isEmpty);\n\t};\n\texport const buildCrowdinJsonObject = ({\n", "  doc,\n\t  fields,\n\t  topLevel = true,\n\t}: {\n\t  doc: { [key: string]: any };\n\t  /** Use getLocalizedFields to pass localized fields only */\n\t  fields: Field[];\n\t  /** Flag used internally to filter json fields before recursion. */\n\t  topLevel?: boolean;\n\t}) => {\n", "  let response: { [key: string]: any } = {};\n\t  const filteredFields = topLevel\n\t    ? getLocalizedFields({ fields, type: \"json\" })\n\t    : fields;\n\t  filteredFields.forEach((field) => {\n\t    if (!doc[field.name]) {\n\t      return;\n\t    }\n\t    if (field.type === \"group\") {\n\t      response[field.name] = buildCrowdinJsonObject({\n", "        doc: doc[field.name],\n\t        fields: field.fields,\n\t        topLevel: false,\n\t      });\n\t    } else if (field.type === \"array\") {\n\t      response[field.name] = doc[field.name]\n\t        .map((item: any) => {\n\t          const crowdinJsonObject = buildCrowdinJsonObject({\n\t            doc: item,\n\t            fields: field.fields,\n", "            topLevel: false,\n\t          });\n\t          if (!isEmpty(crowdinJsonObject)) {\n\t            return {\n\t              [item.id]: crowdinJsonObject,\n\t            };\n\t          }\n\t        })\n\t        .filter((item: any) => !isEmpty(item))\n\t        .reduce((acc: object, item: any) => ({ ...acc, ...item }), {});\n", "    } else if (field.type === \"blocks\") {\n\t      response[field.name] = doc[field.name]\n\t        .map((item: any) => {\n\t          const crowdinJsonObject = buildCrowdinJsonObject({\n\t            doc: item,\n\t            fields:\n\t              field.blocks.find((block: Block) => block.slug === item.blockType)\n\t                ?.fields || [],\n\t            topLevel: false,\n\t          });\n", "          if (!isEmpty(crowdinJsonObject)) {\n\t            return {\n\t              [item.id]: {\n\t                [item.blockType]: crowdinJsonObject,\n\t              },\n\t            };\n\t          }\n\t        })\n\t        .filter((item: any) => !isEmpty(item))\n\t        .reduce((acc: object, item: any) => ({ ...acc, ...item }), {});\n", "    } else {\n\t      response[field.name] = doc[field.name];\n\t    }\n\t  });\n\t  return omitBy(response, isEmpty);\n\t};\n\texport const buildCrowdinHtmlObject = ({\n\t  doc,\n\t  fields,\n\t  prefix = \"\",\n", "  topLevel = true,\n\t}: {\n\t  doc: { [key: string]: any };\n\t  /** Use getLocalizedFields to pass localized fields only */\n\t  fields: Field[];\n\t  /** Use to build dot notation field during recursion. */\n\t  prefix?: string;\n\t  /** Flag used internally to filter html fields before recursion. */\n\t  topLevel?: boolean;\n\t}) => {\n", "  let response: { [key: string]: any } = {};\n\t  // it is convenient to be able to pass all fields - filter in this case\n\t  const filteredFields = topLevel\n\t    ? getLocalizedFields({ fields, type: \"html\" })\n\t    : fields;\n\t  filteredFields.forEach((field) => {\n\t    const name = [prefix, (field as FieldWithName).name]\n\t      .filter((string) => string)\n\t      .join(\".\");\n\t    if (!doc[field.name]) {\n", "      return;\n\t    }\n\t    if (field.type === \"group\") {\n\t      const subPrefix = `${[prefix, field.name]\n\t        .filter((string) => string)\n\t        .join(\".\")}`;\n\t      response = {\n\t        ...response,\n\t        ...buildCrowdinHtmlObject({\n\t          doc: doc[field.name],\n", "          fields: field.fields,\n\t          prefix: subPrefix,\n\t          topLevel: false,\n\t        }),\n\t      };\n\t    } else if (field.type === \"array\") {\n\t      const arrayValues = doc[field.name].map((item: any, index: number) => {\n\t        const subPrefix = `${[prefix, `${field.name}`, `${item.id}`]\n\t          .filter((string) => string)\n\t          .join(\".\")}`;\n", "        return buildCrowdinHtmlObject({\n\t          doc: item,\n\t          fields: field.fields,\n\t          prefix: subPrefix,\n\t          topLevel: false,\n\t        });\n\t      });\n\t      response = {\n\t        ...response,\n\t        ...merge({}, ...arrayValues),\n", "      };\n\t    } else if (field.type === \"blocks\") {\n\t      const arrayValues = doc[field.name].map((item: any, index: number) => {\n\t        const subPrefix = `${[\n\t          prefix,\n\t          `${field.name}`,\n\t          `${item.id}`,\n\t          `${item.blockType}`,\n\t        ]\n\t          .filter((string) => string)\n", "          .join(\".\")}`;\n\t        return buildCrowdinHtmlObject({\n\t          doc: item,\n\t          fields:\n\t            field.blocks.find((block: Block) => block.slug === item.blockType)\n\t              ?.fields || [],\n\t          prefix: subPrefix,\n\t          topLevel: false,\n\t        });\n\t      });\n", "      response = {\n\t        ...response,\n\t        ...merge({}, ...arrayValues),\n\t      };\n\t    } else {\n\t      if (doc[field.name]?.en) {\n\t        response[name] = doc[field.name].en;\n\t      } else {\n\t        response[name] = doc[field.name];\n\t      }\n", "    }\n\t  });\n\t  return response;\n\t};\n\texport const convertSlateToHtml = (slate: Descendant[]): string => {\n\t  return slateToHtml(slate, {\n\t    ...payloadSlateToDomConfig,\n\t    encodeEntities: false,\n\t    alwaysEncodeBreakingEntities: true,\n\t  });\n", "};\n"]}
{"filename": "src/utilities/getCollapsibleLocalizedFields.spec.ts", "chunked_list": ["import { GlobalConfig } from \"payload/types\";\n\timport { getCollapsibleLocalizedFields } from \".\";\n\tdescribe(\"fn: getCollapsibleLocalizedFields\", () => {\n\t  it(\"includes only localized fields from a collapsible field\", () => {\n\t    const global: GlobalConfig = {\n\t      slug: \"global\",\n\t      fields: [\n\t        {\n\t          name: \"textLocalizedField\",\n\t          type: \"text\",\n", "          localized: true,\n\t        },\n\t        {\n\t          name: \"textNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          label: \"Collapsible Field\",\n\t          type: \"collapsible\",\n\t          fields: [\n", "            {\n\t              name: \"textLocalizedFieldInCollapsibleField\",\n\t              type: \"text\",\n\t              localized: true,\n\t            },\n\t            {\n\t              name: \"textNonLocalizedFieldInCollapsibleField\",\n\t              type: \"text\",\n\t            },\n\t            // select fields not supported yet\n", "            {\n\t              name: \"selectLocalizedFieldInCollapsibleField\",\n\t              type: \"select\",\n\t              localized: true,\n\t              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    };\n", "    const expected = [\n\t      {\n\t        name: \"textLocalizedFieldInCollapsibleField\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t    ];\n\t    expect(getCollapsibleLocalizedFields({ fields: global.fields })).toEqual(\n\t      expected\n\t    );\n", "  });\n\t});\n"]}
{"filename": "src/utilities/getLocalizedFields.spec.ts", "chunked_list": ["import { Block, CollectionConfig, Field, GlobalConfig } from \"payload/types\";\n\timport { getLocalizedFields } from \".\";\n\tdescribe(\"fn: getLocalizedFields\", () => {\n\t  describe(\"basic field types\", () => {\n\t    it(\"includes a text field\", () => {\n\t      const fields: Field[] = [\n\t        {\n\t          name: \"textLocalizedField\",\n\t          type: \"text\",\n\t          localized: true,\n", "        },\n\t      ];\n\t      expect(getLocalizedFields({ fields })).toEqual(fields);\n\t    });\n\t    it(\"excludes a localized text field based on the admin description\", () => {\n\t      const fields: Field[] = [\n\t        {\n\t          name: \"textLocalizedField\",\n\t          type: \"text\",\n\t          localized: true,\n", "        },\n\t        {\n\t          name: \"textLocalizedFieldWithExcludeDescription\",\n\t          type: \"text\",\n\t          localized: true,\n\t          admin: {\n\t            description: \"Not sent to Crowdin. Localize in the CMS.\",\n\t          },\n\t        },\n\t      ];\n", "      expect(getLocalizedFields({ fields })).toEqual([\n\t        {\n\t          name: \"textLocalizedField\",\n\t          type: \"text\",\n\t          localized: true,\n\t        },\n\t      ]);\n\t    });\n\t    it(\"includes a richText field\", () => {\n\t      const fields: Field[] = [\n", "        {\n\t          name: \"richTextLocalizedField\",\n\t          type: \"richText\",\n\t          localized: true,\n\t        },\n\t      ];\n\t      expect(getLocalizedFields({ fields })).toEqual(fields);\n\t    });\n\t    it(\"includes a textarea field\", () => {\n\t      const fields: Field[] = [\n", "        {\n\t          name: \"textareaLocalizedField\",\n\t          type: \"textarea\",\n\t          localized: true,\n\t        },\n\t      ];\n\t      expect(getLocalizedFields({ fields })).toEqual(fields);\n\t    });\n\t  });\n\t  describe(\"include fields from groups and arrays\", () => {\n", "    const mixedFieldCollection: Field[] = [\n\t      {\n\t        name: \"textLocalizedField\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"textNonLocalizedField\",\n\t        type: \"text\",\n\t      },\n", "      {\n\t        name: \"richTextLocalizedField\",\n\t        type: \"richText\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"richTextNonLocalizedField\",\n\t        type: \"richText\",\n\t      },\n\t      {\n", "        name: \"textareaLocalizedField\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"textareaNonLocalizedField\",\n\t        type: \"text\",\n\t      },\n\t      // select fields not supported yet\n\t      {\n", "        name: \"text\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t    ];\n\t    const localizedFieldCollection: Field[] = [\n\t      {\n\t        name: \"textLocalizedField\",\n\t        type: \"text\",\n", "        localized: true,\n\t      },\n\t      {\n\t        name: \"richTextLocalizedField\",\n\t        type: \"richText\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"textareaLocalizedField\",\n\t        type: \"text\",\n", "        localized: true,\n\t      },\n\t    ];\n\t    it(\"includes localized fields from a group field\", () => {\n\t      const fields: Field[] = [\n\t        ...mixedFieldCollection,\n\t        {\n\t          name: \"groupField\",\n\t          type: \"group\",\n\t          fields: [...mixedFieldCollection],\n", "        },\n\t      ];\n\t      const expected = [\n\t        ...localizedFieldCollection,\n\t        {\n\t          name: \"groupField\",\n\t          type: \"group\",\n\t          fields: [...localizedFieldCollection],\n\t        },\n\t      ];\n", "      expect(getLocalizedFields({ fields })).toEqual(expected);\n\t    });\n\t    it(\"includes localized fields from an array field\", () => {\n\t      const fields: Field[] = [\n\t        ...mixedFieldCollection,\n\t        {\n\t          name: \"arrayField\",\n\t          type: \"array\",\n\t          fields: [...mixedFieldCollection],\n\t        },\n", "      ];\n\t      const expected = [\n\t        ...localizedFieldCollection,\n\t        {\n\t          name: \"arrayField\",\n\t          type: \"array\",\n\t          fields: [...localizedFieldCollection],\n\t        },\n\t      ];\n\t      expect(getLocalizedFields({ fields })).toEqual(expected);\n", "    });\n\t    it(\"includes localized fields from an array with a localization setting on the array field\", () => {\n\t      const fields: Field[] = [\n\t        ...mixedFieldCollection,\n\t        {\n\t          name: \"arrayField\",\n\t          type: \"array\",\n\t          localized: true,\n\t          fields: [\n\t            {\n", "              name: \"title\",\n\t              type: \"text\",\n\t            },\n\t            {\n\t              name: \"text\",\n\t              type: \"text\",\n\t            },\n\t            {\n\t              name: \"textarea\",\n\t              type: \"textarea\",\n", "            },\n\t            {\n\t              name: \"select\",\n\t              type: \"select\",\n\t              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n\t        },\n\t      ];\n\t      const expected = [\n", "        ...localizedFieldCollection,\n\t        {\n\t          name: \"arrayField\",\n\t          type: \"array\",\n\t          localized: true,\n\t          fields: [\n\t            {\n\t              name: \"title\",\n\t              type: \"text\",\n\t            },\n", "            {\n\t              name: \"text\",\n\t              type: \"text\",\n\t            },\n\t            {\n\t              name: \"textarea\",\n\t              type: \"textarea\",\n\t            },\n\t          ],\n\t        },\n", "      ];\n\t      expect(getLocalizedFields({ fields })).toEqual(expected);\n\t    });\n\t    it(\"includes localized fields from an array inside a collapsible field where the top-level field group only contains collapsible fields\", () => {\n\t      const fields: Field[] = [\n\t        {\n\t          label: \"Array fields\",\n\t          type: \"collapsible\",\n\t          fields: [\n\t            {\n", "              name: \"arrayField\",\n\t              type: \"array\",\n\t              fields: [...mixedFieldCollection],\n\t            },\n\t          ],\n\t        },\n\t      ];\n\t      const expected = [\n\t        {\n\t          name: \"arrayField\",\n", "          type: \"array\",\n\t          fields: [...localizedFieldCollection],\n\t        },\n\t      ];\n\t      expect(getLocalizedFields({ fields })).toEqual(expected);\n\t    });\n\t    /**\n\t     * * help ensure no errors during version 0 development\n\t     * * mitigate against errors if a new field type is introduced by Payload CMS\n\t     */\n", "    it(\"does not include unrecognized field types\", () => {\n\t      const global: any = {\n\t        slug: \"global\",\n\t        fields: [\n\t          {\n\t            name: \"textLocalizedField\",\n\t            type: \"text\",\n\t            localized: true,\n\t          },\n\t          {\n", "            name: \"textNonLocalizedField\",\n\t            type: \"text\",\n\t          },\n\t          {\n\t            name: \"unknownLocalizedField\",\n\t            type: \"weird\",\n\t            localized: true,\n\t          },\n\t          {\n\t            name: \"Unknown Field type\",\n", "            type: \"strange\",\n\t            fields: [\n\t              {\n\t                name: \"textLocalizedFieldInCollapsibleField\",\n\t                type: \"text\",\n\t                localized: true,\n\t              },\n\t              {\n\t                name: \"textNonLocalizedFieldInCollapsibleField\",\n\t                type: \"text\",\n", "              },\n\t              // select fields not supported yet\n\t              {\n\t                name: \"selectLocalizedFieldInCollapsibleField\",\n\t                type: \"select\",\n\t                localized: true,\n\t                options: [\"one\", \"two\"],\n\t              },\n\t            ],\n\t          },\n", "        ],\n\t      };\n\t      const expected = [\n\t        {\n\t          name: \"textLocalizedField\",\n\t          type: \"text\",\n\t          localized: true,\n\t        },\n\t      ];\n\t      expect(getLocalizedFields({ fields: global.fields })).toEqual(expected);\n", "    });\n\t    it(\"includes localized fields from a group field with a localization setting on the group field\", () => {\n\t      const fields: Field[] = [\n\t        ...mixedFieldCollection,\n\t        {\n\t          name: \"groupField\",\n\t          type: \"group\",\n\t          localized: true,\n\t          fields: [\n\t            {\n", "              name: \"text\",\n\t              type: \"text\",\n\t            },\n\t            {\n\t              name: \"richText\",\n\t              type: \"richText\",\n\t            },\n\t            {\n\t              name: \"textarea\",\n\t              type: \"textarea\",\n", "            },\n\t            // select fields not supported yet\n\t            {\n\t              name: \"text\",\n\t              type: \"select\",\n\t              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n\t        },\n\t      ];\n", "      const expected = [\n\t        ...localizedFieldCollection,\n\t        {\n\t          name: \"groupField\",\n\t          type: \"group\",\n\t          localized: true,\n\t          fields: [\n\t            {\n\t              name: \"text\",\n\t              type: \"text\",\n", "            },\n\t            {\n\t              name: \"richText\",\n\t              type: \"richText\",\n\t            },\n\t            {\n\t              name: \"textarea\",\n\t              type: \"textarea\",\n\t            },\n\t          ],\n", "        },\n\t      ];\n\t      expect(getLocalizedFields({ fields })).toEqual(expected);\n\t    });\n\t    it(\"includes localized fields from a blocks field\", () => {\n\t      const TestBlock: Block = {\n\t        slug: \"text\",\n\t        imageAltText: \"Text\",\n\t        fields: [\n\t          {\n", "            name: \"title\",\n\t            type: \"text\",\n\t            localized: true,\n\t          },\n\t          {\n\t            name: \"text\",\n\t            type: \"richText\",\n\t            localized: true,\n\t          },\n\t          {\n", "            name: \"select\",\n\t            type: \"select\",\n\t            localized: true,\n\t            options: [\"one\", \"two\"],\n\t          },\n\t        ],\n\t      };\n\t      const TestBlockLocalizedFieldsOnly: Block = {\n\t        slug: \"text\",\n\t        imageAltText: \"Text\",\n", "        fields: [\n\t          {\n\t            name: \"title\",\n\t            type: \"text\",\n\t            localized: true,\n\t          },\n\t          {\n\t            name: \"text\",\n\t            type: \"richText\",\n\t            localized: true,\n", "          },\n\t        ],\n\t      };\n\t      const global: GlobalConfig = {\n\t        slug: \"global\",\n\t        fields: [\n\t          {\n\t            name: \"simpleLocalizedField\",\n\t            type: \"text\",\n\t            localized: true,\n", "          },\n\t          {\n\t            name: \"simpleNonLocalizedField\",\n\t            type: \"text\",\n\t          },\n\t          {\n\t            name: \"blocksField\",\n\t            type: \"blocks\",\n\t            blocks: [TestBlock],\n\t          },\n", "        ],\n\t      };\n\t      const expected = [\n\t        {\n\t          name: \"simpleLocalizedField\",\n\t          type: \"text\",\n\t          localized: true,\n\t        },\n\t        {\n\t          name: \"blocksField\",\n", "          type: \"blocks\",\n\t          blocks: [\n\t            {\n\t              fields: [\n\t                {\n\t                  name: \"title\",\n\t                  type: \"text\",\n\t                  localized: true,\n\t                },\n\t                {\n", "                  name: \"text\",\n\t                  type: \"richText\",\n\t                  localized: true,\n\t                },\n\t              ],\n\t              slug: \"text\",\n\t            },\n\t          ],\n\t        },\n\t      ];\n", "      expect(getLocalizedFields({ fields: global.fields })).toEqual(expected);\n\t    });\n\t  });\n\t  it(\"extract rich text localized fields\", () => {\n\t    const global: GlobalConfig = {\n\t      slug: \"global\",\n\t      fields: [\n\t        {\n\t          name: \"simpleLocalizedField\",\n\t          type: \"richText\",\n", "          localized: true,\n\t        },\n\t        {\n\t          name: \"simpleNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"arrayField\",\n\t          type: \"array\",\n\t          fields: [\n", "            {\n\t              name: \"title\",\n\t              type: \"text\",\n\t              localized: true,\n\t            },\n\t            {\n\t              name: \"richText\",\n\t              type: \"richText\",\n\t              localized: true,\n\t            },\n", "            {\n\t              name: \"select\",\n\t              type: \"select\",\n\t              localized: true,\n\t              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n\t        },\n\t        {\n\t          name: \"groupField\",\n", "          type: \"group\",\n\t          fields: [\n\t            {\n\t              name: \"simpleLocalizedField\",\n\t              type: \"richText\",\n\t              localized: true,\n\t            },\n\t            {\n\t              name: \"simpleNonLocalizedField\",\n\t              type: \"text\",\n", "            },\n\t            // select fields not supported yet\n\t            {\n\t              name: \"text\",\n\t              type: \"select\",\n\t              localized: true,\n\t              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n\t        },\n", "      ],\n\t    };\n\t    const expected = [\n\t      {\n\t        name: \"simpleLocalizedField\",\n\t        type: \"richText\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"arrayField\",\n", "        type: \"array\",\n\t        fields: [\n\t          {\n\t            name: \"richText\",\n\t            type: \"richText\",\n\t            localized: true,\n\t          },\n\t        ],\n\t      },\n\t      {\n", "        name: \"groupField\",\n\t        type: \"group\",\n\t        fields: [\n\t          {\n\t            name: \"simpleLocalizedField\",\n\t            type: \"richText\",\n\t            localized: true,\n\t          },\n\t        ],\n\t      },\n", "    ];\n\t    expect(getLocalizedFields({ fields: global.fields, type: \"html\" })).toEqual(\n\t      expected\n\t    );\n\t  });\n\t  it(\"returns nested json fields in a group inside an array\", () => {\n\t    const linkField: Field = {\n\t      name: \"link\",\n\t      type: \"group\",\n\t      fields: [\n", "        {\n\t          name: \"text\",\n\t          type: \"text\",\n\t          localized: true,\n\t        },\n\t        {\n\t          name: \"href\",\n\t          type: \"text\",\n\t        },\n\t        {\n", "          name: \"type\",\n\t          type: \"select\",\n\t          options: [\"ctaPrimary\", \"ctaSecondary\"],\n\t        },\n\t      ],\n\t    };\n\t    const Promos: CollectionConfig = {\n\t      slug: \"promos\",\n\t      admin: {\n\t        defaultColumns: [\"title\", \"updatedAt\"],\n", "        useAsTitle: \"title\",\n\t        group: \"Shared\",\n\t      },\n\t      access: {\n\t        read: () => true,\n\t      },\n\t      fields: [\n\t        {\n\t          name: \"title\",\n\t          type: \"text\",\n", "          localized: true,\n\t        },\n\t        {\n\t          name: \"text\",\n\t          type: \"text\",\n\t          localized: true,\n\t        },\n\t        {\n\t          name: \"ctas\",\n\t          type: \"array\",\n", "          minRows: 1,\n\t          maxRows: 2,\n\t          fields: [linkField],\n\t        },\n\t      ],\n\t    };\n\t    const expected = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n", "        localized: true,\n\t      },\n\t      {\n\t        name: \"text\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"ctas\",\n\t        type: \"array\",\n", "        minRows: 1,\n\t        maxRows: 2,\n\t        fields: [\n\t          {\n\t            name: \"link\",\n\t            type: \"group\",\n\t            fields: [\n\t              {\n\t                name: \"text\",\n\t                type: \"text\",\n", "                localized: true,\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    ];\n\t    const jsonFields = getLocalizedFields({\n\t      fields: Promos.fields,\n\t      type: \"json\",\n", "    });\n\t    expect(jsonFields).toEqual(expected);\n\t  });\n\t  describe(\"empty tests\", () => {\n\t    it(\"ignore non-localized group field\", () => {\n\t      const fields: Field[] = [\n\t        {\n\t          name: \"simpleLocalizedField\",\n\t          type: \"text\",\n\t        },\n", "        {\n\t          name: \"simpleNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"groupField\",\n\t          type: \"group\",\n\t          fields: [\n\t            {\n\t              name: \"simpleLocalizedField\",\n", "              type: \"text\",\n\t            },\n\t            {\n\t              name: \"simpleNonLocalizedField\",\n\t              type: \"text\",\n\t            },\n\t            // select fields not supported yet\n\t            {\n\t              name: \"text\",\n\t              type: \"select\",\n", "              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n\t        },\n\t      ];\n\t      expect(getLocalizedFields({ fields })).toEqual([]);\n\t    });\n\t    it(\"ignore non-localized array field\", () => {\n\t      const fields: Field[] = [\n\t        {\n", "          name: \"simpleLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"simpleNonLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"arrayField\",\n\t          type: \"array\",\n", "          fields: [\n\t            {\n\t              name: \"title\",\n\t              type: \"text\",\n\t            },\n\t            {\n\t              name: \"text\",\n\t              type: \"text\",\n\t            },\n\t            {\n", "              name: \"select\",\n\t              type: \"select\",\n\t              localized: true,\n\t              options: [\"one\", \"two\"],\n\t            },\n\t          ],\n\t        },\n\t      ];\n\t      expect(getLocalizedFields({ fields })).toEqual([]);\n\t    });\n", "    it(\"ignore non-localized fields from an array inside a collapsible field where the top-level field group only contains collapsible fields\", () => {\n\t      const fields: Field[] = [\n\t        {\n\t          label: \"Array fields\",\n\t          type: \"collapsible\",\n\t          fields: [\n\t            {\n\t              name: \"arrayField\",\n\t              type: \"array\",\n\t              fields: [\n", "                {\n\t                  name: \"title\",\n\t                  type: \"richText\",\n\t                },\n\t                {\n\t                  name: \"content\",\n\t                  type: \"richText\",\n\t                },\n\t                {\n\t                  name: \"select\",\n", "                  type: \"select\",\n\t                  options: [\"one\", \"two\"],\n\t                },\n\t              ],\n\t            },\n\t          ],\n\t        },\n\t      ];\n\t      expect(getLocalizedFields({ fields })).toEqual([]);\n\t    });\n", "    /**\n\t     * * help ensure no errors during version 0 development\n\t     * * mitigate against errors if a new field type is introduced by Payload CMS\n\t     */\n\t    it(\"does not include unrecognized field types\", () => {\n\t      const global: any = {\n\t        slug: \"global\",\n\t        fields: [\n\t          {\n\t            name: \"textLocalizedField\",\n", "            type: \"text\",\n\t          },\n\t          {\n\t            name: \"textNonLocalizedField\",\n\t            type: \"text\",\n\t          },\n\t          {\n\t            name: \"unknownLocalizedField\",\n\t            type: \"weird\",\n\t            localized: true,\n", "          },\n\t          {\n\t            name: \"Unknown Field type\",\n\t            type: \"strange\",\n\t            fields: [\n\t              {\n\t                name: \"textLocalizedFieldInCollapsibleField\",\n\t                type: \"text\",\n\t                localized: true,\n\t              },\n", "              {\n\t                name: \"textNonLocalizedFieldInCollapsibleField\",\n\t                type: \"text\",\n\t              },\n\t              // select fields not supported yet\n\t              {\n\t                name: \"selectLocalizedFieldInCollapsibleField\",\n\t                type: \"select\",\n\t                localized: true,\n\t                options: [\"one\", \"two\"],\n", "              },\n\t            ],\n\t          },\n\t        ],\n\t      };\n\t      expect(getLocalizedFields({ fields: global.fields })).toEqual([]);\n\t    });\n\t    /**\n\t     * blocks not supported yet\n\t    it (\"includes localized fields from a blocks field\", () => {\n", "      const TestBlock: Block = {\n\t        slug: 'text',\n\t        imageAltText: 'Text',\n\t        fields: [\n\t          {\n\t            name: 'title',\n\t            type: 'text',\n\t            localized: true,\n\t          },\n\t          {\n", "            name: 'text',\n\t            type: 'richText',\n\t            localized: true,\n\t          },\n\t          {\n\t            name: 'select',\n\t            type: 'select',\n\t            localized: true,\n\t            options: [\n\t              'one',\n", "              'two'\n\t            ]\n\t          },\n\t        ]\n\t      }\n\t      const TestBlockLocalizedFieldsOnly: Block = {\n\t        slug: 'text',\n\t        imageAltText: 'Text',\n\t        fields: [\n\t          {\n", "            name: 'title',\n\t            type: 'text',\n\t            localized: true,\n\t          },\n\t          {\n\t            name: 'text',\n\t            type: 'richText',\n\t            localized: true,\n\t          },\n\t        ]\n", "      }\n\t      const global: GlobalConfig = {\n\t        slug: \"global\",\n\t        fields: [\n\t          {\n\t            name: 'simpleLocalizedField',\n\t            type: 'text',\n\t            localized: true,\n\t          },\n\t          {\n", "            name: 'simpleNonLocalizedField',\n\t            type: 'text',\n\t          },\n\t          {\n\t            name: 'blocksField',\n\t            type: 'blocks',\n\t            blocks: [\n\t              TestBlock\n\t            ]\n\t          },\n", "        ]\n\t      }\n\t      const expected = [\n\t        {\n\t          name: 'simpleLocalizedField',\n\t          type: 'text',\n\t          localized: true,\n\t        },\n\t        {\n\t          name: 'blocksField',\n", "          type: 'blocks',\n\t          blocks: [\n\t            {\n\t              fields: [\n\t                {\n\t                  name: 'title',\n\t                  type: 'text',\n\t                  localized: true,\n\t                },\n\t                {\n", "                  name: 'text',\n\t                  type: 'richText',\n\t                  localized: true,\n\t                },\n\t              ]\n\t            }\n\t          ]\n\t        },\n\t      ]\n\t      expect(getLocalizedFields(global.fields)).toEqual(expected)\n", "    })\n\t    */\n\t  });\n\t  /**\n\t   * @see https://github.com/payloadcms/plugin-seo\n\t   *\n\t   * payloadcms/plugin-seo adds localized fields.\n\t   * If there are no other localized fields, we don't\n\t   * want to submit to Crowdin.\n\t   */\n", "  describe(\"payloadcms/plugin-seo tests\", () => {\n\t    const seoFields: Field[] = [\n\t      {\n\t        name: \"meta\",\n\t        label: \"SEO\",\n\t        type: \"group\",\n\t        fields: [\n\t          /**{\n\t            \"name\": \"overview\",\n\t            \"label\": \"Overview\",\n", "            \"type\": \"ui\",\n\t            \"admin\": {\n\t              \"components\": {}\n\t            }\n\t          },*/\n\t          {\n\t            name: \"title\",\n\t            type: \"text\",\n\t            localized: true,\n\t            admin: {\n", "              components: {},\n\t            },\n\t          },\n\t          {\n\t            name: \"description\",\n\t            type: \"textarea\",\n\t            localized: true,\n\t            admin: {\n\t              components: {},\n\t            },\n", "          },\n\t          /**{\n\t            \"name\": \"preview\",\n\t            \"label\": \"Preview\",\n\t            \"type\": \"ui\",\n\t            \"admin\": {\n\t              \"components\": {}\n\t            }\n\t          }**/\n\t        ],\n", "      },\n\t    ];\n\t    it(\"includes payloadcms/plugin-seo localized fields if there are no localized fields on the collection/global\", () => {\n\t      const nonLocalizedFieldCollection: Field[] = [\n\t        {\n\t          name: \"textLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t        {\n\t          name: \"richTextLocalizedField\",\n", "          type: \"richText\",\n\t        },\n\t        {\n\t          name: \"textareaLocalizedField\",\n\t          type: \"text\",\n\t        },\n\t      ];\n\t      const fields: Field[] = [...nonLocalizedFieldCollection, ...seoFields];\n\t      expect(getLocalizedFields({ fields })).toEqual([{\n\t        \"fields\": [\n", "          {\n\t            \"admin\": {\n\t              \"components\": {},\n\t            },\n\t            \"localized\": true,\n\t            \"name\": \"title\",\n\t            \"type\": \"text\",\n\t          },\n\t          {\n\t            \"admin\": {\n", "              \"components\": {},\n\t            },\n\t            \"localized\": true,\n\t            \"name\": \"description\",\n\t            \"type\": \"textarea\",\n\t          },\n\t        ],\n\t        \"label\": \"SEO\",\n\t        \"name\": \"meta\",\n\t        \"type\": \"group\",\n", "      },]);\n\t    });\n\t    it(\"includes payloadcms/plugin-seo localized fields if there are localized fields on the collection/global\", () => {\n\t      const localizedFieldCollection: Field[] = [\n\t        {\n\t          name: \"textLocalizedField\",\n\t          type: \"text\",\n\t          localized: true,\n\t        },\n\t        {\n", "          name: \"richTextLocalizedField\",\n\t          type: \"richText\",\n\t          localized: true,\n\t        },\n\t        {\n\t          name: \"textareaLocalizedField\",\n\t          type: \"text\",\n\t          localized: true,\n\t        },\n\t      ];\n", "      const fields: Field[] = [...localizedFieldCollection, ...seoFields];\n\t      expect(getLocalizedFields({ fields })).toMatchInlineSnapshot(`\n\t        [\n\t          {\n\t            \"localized\": true,\n\t            \"name\": \"textLocalizedField\",\n\t            \"type\": \"text\",\n\t          },\n\t          {\n\t            \"localized\": true,\n", "            \"name\": \"richTextLocalizedField\",\n\t            \"type\": \"richText\",\n\t          },\n\t          {\n\t            \"localized\": true,\n\t            \"name\": \"textareaLocalizedField\",\n\t            \"type\": \"text\",\n\t          },\n\t          {\n\t            \"fields\": [\n", "              {\n\t                \"admin\": {\n\t                  \"components\": {},\n\t                },\n\t                \"localized\": true,\n\t                \"name\": \"title\",\n\t                \"type\": \"text\",\n\t              },\n\t              {\n\t                \"admin\": {\n", "                  \"components\": {},\n\t                },\n\t                \"localized\": true,\n\t                \"name\": \"description\",\n\t                \"type\": \"textarea\",\n\t              },\n\t            ],\n\t            \"label\": \"SEO\",\n\t            \"name\": \"meta\",\n\t            \"type\": \"group\",\n", "          },\n\t        ]\n\t      `);\n\t    });\n\t    it(\"includes payloadcms/plugin-seo localized fields if there are localized fields within tabs on the collection/global\", () => {\n\t      const localizedFieldCollection: Field[] = [\n\t        {\n\t          type: \"tabs\",\n\t          tabs: [\n\t            {\n", "              label: \"Content\",\n\t              fields: [\n\t                {\n\t                  name: \"unusedField\",\n\t                  type: \"text\",\n\t                  localized: true,\n\t                  admin: {\n\t                    description:\n\t                      \"This field is not used, it has been added to activate CrowdIn localization for SEO fields. It will be removed in a future release.\",\n\t                  },\n", "                  label: \"Unused Field\",\n\t                  hooks: {},\n\t                  access: {},\n\t                },\n\t                {\n\t                  type: \"collapsible\",\n\t                  label: \"Hero\",\n\t                  admin: {\n\t                    initCollapsed: true,\n\t                  },\n", "                  fields: [\n\t                    {\n\t                      name: \"hero\",\n\t                      type: \"group\",\n\t                      localized: true,\n\t                      fields: [\n\t                        {\n\t                          name: \"title\",\n\t                          type: \"richText\",\n\t                          admin: {\n", "                            elements: [],\n\t                            leaves: [\"bold\"],\n\t                          },\n\t                          label: \"Title\",\n\t                          hooks: {},\n\t                          access: {},\n\t                        },\n\t                        {\n\t                          name: \"text\",\n\t                          type: \"richText\",\n", "                          admin: {\n\t                            elements: [],\n\t                            leaves: [\"bold\"],\n\t                          },\n\t                          label: \"Text\",\n\t                          hooks: {},\n\t                          access: {},\n\t                        },\n\t                      ],\n\t                      label: \"Hero\",\n", "                      hooks: {},\n\t                      access: {},\n\t                      admin: {},\n\t                    },\n\t                  ],\n\t                },\n\t                {\n\t                  type: \"collapsible\",\n\t                  label: \"Promo\",\n\t                  admin: {\n", "                    initCollapsed: true,\n\t                  },\n\t                  fields: [\n\t                    {\n\t                      name: \"promo\",\n\t                      type: \"relationship\",\n\t                      relationTo: \"promos\",\n\t                      hasMany: false,\n\t                      label: \"Promo\",\n\t                      hooks: {},\n", "                      access: {},\n\t                      admin: {},\n\t                    },\n\t                  ],\n\t                },\n\t              ],\n\t            },\n\t            {\n\t              label: \"SEO\",\n\t              fields: [\n", "                {\n\t                  name: \"meta\",\n\t                  label: \"SEO\",\n\t                  type: \"group\",\n\t                  fields: [\n\t                    {\n\t                      name: \"title\",\n\t                      type: \"text\",\n\t                      localized: true,\n\t                      admin: {\n", "                        components: {},\n\t                      },\n\t                      label: \"Title\",\n\t                      hooks: {},\n\t                      access: {},\n\t                    },\n\t                    {\n\t                      name: \"description\",\n\t                      type: \"textarea\",\n\t                      localized: true,\n", "                      admin: {\n\t                        components: {},\n\t                      },\n\t                      label: \"Description\",\n\t                      hooks: {},\n\t                      access: {},\n\t                    },\n\t                    {\n\t                      name: \"image\",\n\t                      label: \"Meta Image\",\n", "                      type: \"upload\",\n\t                      localized: true,\n\t                      relationTo: \"share-images\",\n\t                      admin: {\n\t                        description:\n\t                          \"Maximum upload file size: 12MB. Recommended file size for images is <500KB.\",\n\t                        components: {},\n\t                      },\n\t                      hooks: {},\n\t                      access: {},\n", "                    },\n\t                  ],\n\t                  hooks: {},\n\t                  access: {},\n\t                  admin: {},\n\t                },\n\t              ],\n\t            },\n\t          ],\n\t          admin: {},\n", "        },\n\t        {\n\t          name: \"crowdinArticleDirectory\",\n\t          type: \"relationship\",\n\t          relationTo: \"crowdin-article-directories\",\n\t          hasMany: false,\n\t          label: \"Crowdin Article Directory\",\n\t          hooks: {},\n\t          access: {},\n\t          admin: {},\n", "        },\n\t        {\n\t          name: \"_status\",\n\t          label: {\n\t            ar: \"الحالة\",\n\t            az: \"Status\",\n\t            bg: \"Статус\",\n\t            cs: \"Stav\",\n\t            de: \"Status\",\n\t            en: \"Status\",\n", "            es: \"Estado\",\n\t            fa: \"وضعیت\",\n\t            fr: \"Statut\",\n\t            hr: \"Status\",\n\t            hu: \"Állapot\",\n\t            it: \"Stato\",\n\t            ja: \"ステータス\",\n\t            my: \"အခြေအနေ\",\n\t            nb: \"Status\",\n\t            nl: \"Status\",\n", "            pl: \"Status\",\n\t            pt: \"Status\",\n\t            ro: \"Status\",\n\t            ru: \"Статус\",\n\t            sv: \"Status\",\n\t            th: \"สถานะ\",\n\t            tr: \"Durum\",\n\t            ua: \"Статус\",\n\t            vi: \"Trạng thái\",\n\t            zh: \"状态\",\n", "          },\n\t          type: \"select\",\n\t          options: [\n\t            {\n\t              label: {\n\t                ar: \"مسودة\",\n\t                az: \"Qaralama\",\n\t                bg: \"Чернова\",\n\t                cs: \"Koncept\",\n\t                de: \"Entwurf\",\n", "                en: \"Draft\",\n\t                es: \"Borrador\",\n\t                fa: \"پیش‌نویس\",\n\t                fr: \"Brouillon\",\n\t                hr: \"Nacrt\",\n\t                hu: \"Piszkozat\",\n\t                it: \"Bozza\",\n\t                ja: \"ドラフト\",\n\t                my: \"မူကြမ်း\",\n\t                nb: \"Utkast\",\n", "                nl: \"Concept\",\n\t                pl: \"Szkic\",\n\t                pt: \"Rascunho\",\n\t                ro: \"Proiect\",\n\t                ru: \"Черновик\",\n\t                sv: \"Utkast\",\n\t                th: \"ฉบับร่าง\",\n\t                tr: \"Taslak\",\n\t                ua: \"Чернетка\",\n\t                vi: \"Bản nháp\",\n", "                zh: \"草稿\",\n\t              },\n\t              value: \"draft\",\n\t            },\n\t            {\n\t              label: {\n\t                ar: \"تم النشر\",\n\t                az: \"Dərc edilmiş\",\n\t                bg: \"Публикувано\",\n\t                cs: \"Publikováno\",\n", "                de: \"Veröffentlicht\",\n\t                en: \"Published\",\n\t                es: \"Publicado\",\n\t                fa: \"انتشار یافته\",\n\t                fr: \"Publié\",\n\t                hr: \"Objavljeno\",\n\t                hu: \"Közzétett\",\n\t                it: \"Pubblicato\",\n\t                ja: \"公開済み\",\n\t                my: \"တင်ပြီးပြီ။\",\n", "                nb: \"Publisert\",\n\t                nl: \"Gepubliceerd\",\n\t                pl: \"Opublikowano\",\n\t                pt: \"Publicado\",\n\t                ro: \"Publicat\",\n\t                ru: \"Опубликовано\",\n\t                sv: \"Publicerad\",\n\t                th: \"เผยแพร่แล้ว\",\n\t                tr: \"Yayınlandı\",\n\t                ua: \"Опубліковано\",\n", "                vi: \"Đã xuất bản\",\n\t                zh: \"已发布\",\n\t              },\n\t              value: \"published\",\n\t            },\n\t          ],\n\t          defaultValue: \"draft\",\n\t          admin: {\n\t            disableBulkEdit: true,\n\t            components: {},\n", "          },\n\t          hooks: {},\n\t          access: {},\n\t        },\n\t        {\n\t          name: \"updatedAt\",\n\t          label: \"Updated At\",\n\t          type: \"date\",\n\t          admin: {\n\t            hidden: true,\n", "            disableBulkEdit: true,\n\t          },\n\t          hooks: {},\n\t          access: {},\n\t        },\n\t        {\n\t          name: \"createdAt\",\n\t          label: \"Created At\",\n\t          type: \"date\",\n\t          admin: {\n", "            hidden: true,\n\t            disableBulkEdit: true,\n\t          },\n\t          hooks: {},\n\t          access: {},\n\t        },\n\t      ];\n\t      const fields: Field[] = localizedFieldCollection;\n\t      expect(getLocalizedFields({ fields })).toMatchInlineSnapshot(`\n\t        [\n", "          {\n\t            \"access\": {},\n\t            \"admin\": {\n\t              \"description\": \"This field is not used, it has been added to activate CrowdIn localization for SEO fields. It will be removed in a future release.\",\n\t            },\n\t            \"hooks\": {},\n\t            \"label\": \"Unused Field\",\n\t            \"localized\": true,\n\t            \"name\": \"unusedField\",\n\t            \"type\": \"text\",\n", "          },\n\t          {\n\t            \"access\": {},\n\t            \"admin\": {},\n\t            \"fields\": [\n\t              {\n\t                \"access\": {},\n\t                \"admin\": {\n\t                  \"elements\": [],\n\t                  \"leaves\": [\n", "                    \"bold\",\n\t                  ],\n\t                },\n\t                \"hooks\": {},\n\t                \"label\": \"Title\",\n\t                \"name\": \"title\",\n\t                \"type\": \"richText\",\n\t              },\n\t              {\n\t                \"access\": {},\n", "                \"admin\": {\n\t                  \"elements\": [],\n\t                  \"leaves\": [\n\t                    \"bold\",\n\t                  ],\n\t                },\n\t                \"hooks\": {},\n\t                \"label\": \"Text\",\n\t                \"name\": \"text\",\n\t                \"type\": \"richText\",\n", "              },\n\t            ],\n\t            \"hooks\": {},\n\t            \"label\": \"Hero\",\n\t            \"localized\": true,\n\t            \"name\": \"hero\",\n\t            \"type\": \"group\",\n\t          },\n\t          {\n\t            \"access\": {},\n", "            \"admin\": {},\n\t            \"fields\": [\n\t              {\n\t                \"access\": {},\n\t                \"admin\": {\n\t                  \"components\": {},\n\t                },\n\t                \"hooks\": {},\n\t                \"label\": \"Title\",\n\t                \"localized\": true,\n", "                \"name\": \"title\",\n\t                \"type\": \"text\",\n\t              },\n\t              {\n\t                \"access\": {},\n\t                \"admin\": {\n\t                  \"components\": {},\n\t                },\n\t                \"hooks\": {},\n\t                \"label\": \"Description\",\n", "                \"localized\": true,\n\t                \"name\": \"description\",\n\t                \"type\": \"textarea\",\n\t              },\n\t            ],\n\t            \"hooks\": {},\n\t            \"label\": \"SEO\",\n\t            \"name\": \"meta\",\n\t            \"type\": \"group\",\n\t          },\n", "        ]\n\t      `);\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/utilities/tests/fixtures/basic-localized-fields.fixture.ts", "chunked_list": ["import { Field } from \"payload/types\";\n\texport const basicNonLocalizedFields: Field[] = [\n\t  {\n\t    name: \"textField\",\n\t    type: \"text\",\n\t  },\n\t  {\n\t    name: \"textareaField\",\n\t    type: \"textarea\",\n\t  },\n", "  // select not supported: included to ensure it does not send to Crowdin\n\t  {\n\t    name: \"select\",\n\t    type: \"select\",\n\t    options: [\"one\", \"two\"],\n\t  },\n\t  // image not supported: included to ensure it does send to Crowdin\n\t  {\n\t    name: \"image\",\n\t    type: \"upload\",\n", "    relationTo: \"media\",\n\t  },\n\t];\n\texport const basicLocalizedFields: Field[] = [\n\t  {\n\t    name: \"textField\",\n\t    type: \"text\",\n\t    localized: true,\n\t  },\n\t  {\n", "    name: \"textareaField\",\n\t    type: \"textarea\",\n\t    localized: true,\n\t  },\n\t  // select not supported: included to ensure it does not send to Crowdin\n\t  {\n\t    name: \"select\",\n\t    type: \"select\",\n\t    localized: true,\n\t    options: [\"one\", \"two\"],\n", "  },\n\t  // image not supported: included to ensure it does send to Crowdin\n\t  {\n\t    name: \"image\",\n\t    type: \"upload\",\n\t    relationTo: \"media\",\n\t    localized: true,\n\t  },\n\t];\n\texport const emptyFieldDocValue = {\n", "  textField: \"\",\n\t  textareaField: \"\",\n\t  select: \"one\",\n\t  image: \"63ea51826ff825cddad3c296\",\n\t};\n\texport const fieldDocValue = {\n\t  textField: \"Text field content\",\n\t  textareaField: \"A textarea field value.\\nWith a new line.\",\n\t  select: \"one\",\n\t  image: \"63ea51826ff825cddad3c296\",\n", "};\n\texport const fieldJsonCrowdinObject = (prefix?: string) => {\n\t  const value = {\n\t    textField: \"Text field content\",\n\t    textareaField: \"A textarea field value.\\nWith a new line.\",\n\t  };\n\t  if (prefix) {\n\t    var tgt = {};\n\t    dot.str(prefix, value, tgt);\n\t    return tgt;\n", "  }\n\t  return value;\n\t};\n"]}
{"filename": "src/utilities/tests/fixtures/blocks-field-type.fixture.ts", "chunked_list": ["import { Block, Field } from \"payload/types\";\n\timport { basicLocalizedFields } from \"./basic-localized-fields.fixture\";\n\timport dot from \"dot-object\";\n\tconst BasicBlockTextFields: Block = {\n\t  slug: \"basicBlock\", // required\n\t  fields: basicLocalizedFields,\n\t};\n\tconst BasicBlockRichTextField: Block = {\n\t  slug: \"basicBlockRichText\", // required\n\t  fields: [\n", "    {\n\t      name: \"richTextField\",\n\t      type: \"richText\",\n\t      localized: true,\n\t    },\n\t  ],\n\t};\n\tconst BasicBlockMixedFields: Block = {\n\t  slug: \"basicBlockMixed\", // required\n\t  fields: [\n", "    ...basicLocalizedFields,\n\t    {\n\t      name: \"richTextField\",\n\t      type: \"richText\",\n\t      localized: true,\n\t    },\n\t  ],\n\t};\n\texport const field: Field = {\n\t  name: \"blocksField\",\n", "  type: \"blocks\",\n\t  blocks: [\n\t    BasicBlockTextFields,\n\t    BasicBlockRichTextField,\n\t    BasicBlockMixedFields,\n\t  ],\n\t};\n\texport const fieldDocValue = [\n\t  {\n\t    textField: \"Text field content in basicBlock at layout index 0\",\n", "    textareaField: \"Textarea field content in basicBlock at layout index 0\",\n\t    id: \"63ea42b06ff825cddad3c133\",\n\t    blockType: \"basicBlock\",\n\t  },\n\t  {\n\t    richTextField: [\n\t      {\n\t        type: \"h1\",\n\t        children: [\n\t          {\n", "            text: \"Rich text content in \",\n\t          },\n\t          {\n\t            text: \"basicBlockRichText\",\n\t            bold: true,\n\t          },\n\t          {\n\t            text: \" layout at index 1.\",\n\t          },\n\t        ],\n", "      },\n\t      {\n\t        children: [\n\t          {\n\t            text: \"An extra paragraph for good measure.\",\n\t          },\n\t        ],\n\t      },\n\t    ],\n\t    id: \"63d169d3d9dfd46d37c649e4\",\n", "    blockType: \"basicBlockRichText\",\n\t  },\n\t  {\n\t    textField: \"Text field content in basicBlock at layout index 2\",\n\t    textareaField: \"Textarea field content in basicBlock at layout index 2\",\n\t    id: \"63ea373fb725d8a50646952e\",\n\t    blockType: \"basicBlock\",\n\t  },\n\t  {\n\t    richTextField: [\n", "      {\n\t        children: [\n\t          {\n\t            text: \"Rich text content in basicBlockRichText layout at index 3.\",\n\t          },\n\t        ],\n\t      },\n\t    ],\n\t    id: \"63ea3e7fb725d8a50646956a\",\n\t    blockType: \"basicBlockRichText\",\n", "  },\n\t  {\n\t    textField: \"Text field content in basicBlockMixed at layout index 4\",\n\t    textareaField:\n\t      \"Textarea field content in basicBlockMixed at layout index 4\",\n\t    richTextField: [\n\t      {\n\t        children: [\n\t          {\n\t            text: \"Rich text content in basicBlockMixed layout at index 4.\",\n", "          },\n\t        ],\n\t      },\n\t    ],\n\t    id: \"63ea40106ff825cddad3c10b\",\n\t    blockType: \"basicBlockMixed\",\n\t  },\n\t];\n\texport const fieldJsonCrowdinObject = (prefix?: string) => {\n\t  const value = {\n", "    blocksField: {\n\t      \"63ea42b06ff825cddad3c133\": {\n\t        basicBlock: {\n\t          textField: \"Text field content in basicBlock at layout index 0\",\n\t          textareaField:\n\t            \"Textarea field content in basicBlock at layout index 0\",\n\t        },\n\t      },\n\t      \"63ea373fb725d8a50646952e\": {\n\t        basicBlock: {\n", "          textField: \"Text field content in basicBlock at layout index 2\",\n\t          textareaField:\n\t            \"Textarea field content in basicBlock at layout index 2\",\n\t        },\n\t      },\n\t      \"63ea40106ff825cddad3c10b\": {\n\t        basicBlockMixed: {\n\t          textField: \"Text field content in basicBlockMixed at layout index 4\",\n\t          textareaField:\n\t            \"Textarea field content in basicBlockMixed at layout index 4\",\n", "        },\n\t      },\n\t    },\n\t  };\n\t  if (prefix) {\n\t    var tgt = {};\n\t    dot.str(prefix, value, tgt);\n\t    return tgt;\n\t  }\n\t  return value;\n", "};\n\texport const fieldHtmlCrowdinObject = (prefix?: string) => ({\n\t  [`${\n\t    prefix || \"\"\n\t  }blocksField.63d169d3d9dfd46d37c649e4.basicBlockRichText.richTextField`]: [\n\t    {\n\t      type: \"h1\",\n\t      children: [\n\t        {\n\t          text: \"Rich text content in \",\n", "        },\n\t        {\n\t          text: \"basicBlockRichText\",\n\t          bold: true,\n\t        },\n\t        {\n\t          text: \" layout at index 1.\",\n\t        },\n\t      ],\n\t    },\n", "    {\n\t      children: [\n\t        {\n\t          text: \"An extra paragraph for good measure.\",\n\t        },\n\t      ],\n\t    },\n\t  ],\n\t  [`${\n\t    prefix || \"\"\n", "  }blocksField.63ea3e7fb725d8a50646956a.basicBlockRichText.richTextField`]: [\n\t    {\n\t      children: [\n\t        {\n\t          text: \"Rich text content in basicBlockRichText layout at index 3.\",\n\t        },\n\t      ],\n\t    },\n\t  ],\n\t  [`${\n", "    prefix || \"\"\n\t  }blocksField.63ea40106ff825cddad3c10b.basicBlockMixed.richTextField`]: [\n\t    {\n\t      children: [\n\t        {\n\t          text: \"Rich text content in basicBlockMixed layout at index 4.\",\n\t        },\n\t      ],\n\t    },\n\t  ],\n", "});\n"]}
{"filename": "src/utilities/tests/buildPayloadUpdateObject/blocks-field-type.spec.ts", "chunked_list": ["import { Block, Field } from \"payload/types\";\n\timport {\n\t  buildCrowdinJsonObject,\n\t  buildPayloadUpdateObject,\n\t  getLocalizedFields,\n\t} from \"../..\";\n\timport { FieldWithName } from \"../../../types\";\n\tconst TestBlockOne: Block = {\n\t  slug: \"testBlockOne\",\n\t  fields: [\n", "    {\n\t      name: \"title\",\n\t      type: \"text\",\n\t      localized: true,\n\t    },\n\t    {\n\t      name: \"text\",\n\t      type: \"text\",\n\t      localized: true,\n\t    },\n", "    {\n\t      name: \"select\",\n\t      type: \"select\",\n\t      localized: true,\n\t      options: [\"one\", \"two\"],\n\t    },\n\t  ],\n\t};\n\tconst TestBlockTwo: Block = {\n\t  slug: \"testBlockTwo\",\n", "  fields: [\n\t    {\n\t      name: \"url\",\n\t      type: \"text\",\n\t      localized: true,\n\t    },\n\t  ],\n\t};\n\tconst TestBlockTwoNonLocalized: Block = {\n\t  slug: \"testBlockTwo\",\n", "  fields: [\n\t    {\n\t      name: \"url\",\n\t      type: \"text\",\n\t    },\n\t  ],\n\t};\n\tdescribe(\"fn: buildPayloadUpdateObject: blocks field type\", () => {\n\t  it(\"includes localized fields nested in blocks\", () => {\n\t    const crowdinJsonObject = {\n", "      title: \"Test Policy created with title\",\n\t      blocksField: {\n\t        \"64735620230d57bce946d370\": {\n\t          testBlockOne: {\n\t            title: \"Block field title content one\",\n\t            text: \"Block field text content one\",\n\t          },\n\t        },\n\t        \"64735621230d57bce946d371\": {\n\t          testBlockTwo: {\n", "            url: \"https://github.com/thompsonsj/payload-crowdin-sync\",\n\t          },\n\t        },\n\t      },\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n", "      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n\t        name: \"blocksField\",\n", "        type: \"blocks\",\n\t        blocks: [TestBlockOne, TestBlockTwo],\n\t      },\n\t    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      blocksField: [\n\t        {\n\t          title: \"Block field title content one\",\n", "          text: \"Block field text content one\",\n\t          id: \"64735620230d57bce946d370\",\n\t          blockType: \"testBlockOne\",\n\t        },\n\t        {\n\t          url: \"https://github.com/thompsonsj/payload-crowdin-sync\",\n\t          id: \"64735621230d57bce946d371\",\n\t          blockType: \"testBlockTwo\",\n\t        },\n\t      ],\n", "    };\n\t    expect(\n\t      buildPayloadUpdateObject({ crowdinJsonObject, fields: localizedFields })\n\t    ).toEqual(expected);\n\t  });\n\t  it(\"excludes block with no localized fields\", () => {\n\t    const crowdinJsonObject = {\n\t      title: \"Test Policy created with title\",\n\t      blocksField: {\n\t        \"64735620230d57bce946d370\": {\n", "          testBlockOne: {\n\t            title: \"Block field title content one\",\n\t            text: \"Block field text content one\",\n\t          },\n\t        },\n\t      },\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n", "        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n", "      {\n\t        name: \"blocksField\",\n\t        type: \"blocks\",\n\t        blocks: [TestBlockOne, TestBlockTwoNonLocalized],\n\t      },\n\t    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      blocksField: [\n", "        {\n\t          title: \"Block field title content one\",\n\t          text: \"Block field text content one\",\n\t          id: \"64735620230d57bce946d370\",\n\t          blockType: \"testBlockOne\",\n\t        },\n\t      ],\n\t    };\n\t    expect(\n\t      buildPayloadUpdateObject({ crowdinJsonObject, fields: localizedFields })\n", "    ).toEqual(expected);\n\t  });\n\t  it(\"excludes block with no localized fields - more blocks\", () => {\n\t    const crowdinJsonObject = {\n\t      title: \"Test Policy created with title\",\n\t      blocksField: {\n\t        \"64735620230d57bce946d370\": {\n\t          testBlockOne: {\n\t            title: \"Block field title content one\",\n\t            text: \"Block field text content one\",\n", "          },\n\t        },\n\t        \"64a535cdf1eaa5498709c906\": {\n\t          testBlockOne: {\n\t            title: \"Block field title content two\",\n\t            text: \"Block field text content two\",\n\t          },\n\t        },\n\t      },\n\t    };\n", "    const fields: FieldWithName[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n", "        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n\t        name: \"blocksField\",\n\t        type: \"blocks\",\n\t        blocks: [TestBlockOne, TestBlockTwoNonLocalized],\n\t      },\n\t    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n", "    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      blocksField: [\n\t        {\n\t          title: \"Block field title content one\",\n\t          text: \"Block field text content one\",\n\t          id: \"64735620230d57bce946d370\",\n\t          blockType: \"testBlockOne\",\n\t        },\n\t        {\n", "          title: \"Block field title content two\",\n\t          text: \"Block field text content two\",\n\t          id: \"64a535cdf1eaa5498709c906\",\n\t          blockType: \"testBlockOne\",\n\t        },\n\t      ],\n\t    };\n\t    expect(\n\t      buildPayloadUpdateObject({ crowdinJsonObject, fields: localizedFields })\n\t    ).toEqual(expected);\n", "  });\n\t  it(\"does not include localized fields richText fields nested in an array field within a block in the `fields.json` file\", () => {\n\t    const TestBlockArrayOfRichText: Block = {\n\t      slug: \"testBlockArrayOfRichText\",\n\t      fields: [\n\t        {\n\t          name: \"arrayField\",\n\t          type: \"array\",\n\t          fields: [\n\t            {\n", "              name: \"richText\",\n\t              type: \"richText\",\n\t              localized: true,\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    };\n\t    const crowdinJsonObject = {\n\t      title: \"Test Policy created with title\",\n", "    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n", "        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n\t        name: \"blocksField\",\n\t        type: \"blocks\",\n\t        blocks: [TestBlockArrayOfRichText],\n\t      },\n\t    ];\n", "    const localizedFields = getLocalizedFields({ fields, type: \"json\" });\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t    };\n\t    expect(\n\t      buildPayloadUpdateObject({ crowdinJsonObject, fields: localizedFields })\n\t    ).toEqual(expected);\n\t  });\n\t  it(\"does not include localized fields richText fields nested in an array field within a block in the `fields.json` file 2\", () => {\n\t    const TestBlockArrayOfRichText: Block = {\n", "      slug: \"testBlockArrayOfRichText\",\n\t      fields: [\n\t        {\n\t          name: \"title\",\n\t          type: \"text\",\n\t          localized: true,\n\t        },\n\t        {\n\t          name: \"messages\",\n\t          type: \"array\",\n", "          localized: true,\n\t          maxRows: 3,\n\t          fields: [\n\t            {\n\t              name: \"title\",\n\t              type: \"text\",\n\t              localized: true,\n\t            },\n\t            {\n\t              name: \"message\",\n", "              type: \"richText\",\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    };\n\t    const crowdinJsonObject = {\n\t      title: \"Test Policy created with title\",\n\t      blocksField: {\n\t        \"649cd1ecbac7445191be36af\": {\n", "          testBlockArrayOfRichText: {\n\t            messages: {\n\t              \"64735620230d57bce946d370\": {\n\t                title: \"Test title 1\",\n\t              },\n\t              \"64735621230d57bce946d371\": {\n\t                title: \"Test title 2\",\n\t              },\n\t            },\n\t          },\n", "        },\n\t      },\n\t    };\n\t    const fields: FieldWithName[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n", "      {\n\t        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n\t        name: \"blocksField\",\n\t        type: \"blocks\",\n\t        blocks: [TestBlockArrayOfRichText],\n", "      },\n\t    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      blocksField: [\n\t        {\n\t          messages: [\n\t            {\n\t              title: \"Test title 1\",\n", "              id: \"64735620230d57bce946d370\",\n\t            },\n\t            {\n\t              title: \"Test title 2\",\n\t              id: \"64735621230d57bce946d371\",\n\t            },\n\t          ],\n\t          id: \"649cd1ecbac7445191be36af\",\n\t          blockType: \"testBlockArrayOfRichText\",\n\t        },\n", "      ],\n\t    };\n\t    expect(\n\t      buildPayloadUpdateObject({ crowdinJsonObject, fields: localizedFields })\n\t    ).toEqual(expected);\n\t  });\n\t});\n"]}
{"filename": "src/utilities/tests/buildPayloadUpdateObject/add-rich-text-fields.spec.ts", "chunked_list": ["import { Block, Field } from \"payload/types\";\n\timport {\n\t  buildCrowdinJsonObject,\n\t  buildPayloadUpdateObject,\n\t  getLocalizedFields,\n\t  restoreOrder,\n\t} from \"../..\";\n\timport { FieldWithName } from \"../../../types\";\n\timport {\n\t  field,\n", "  fieldHtmlCrowdinObject,\n\t  fieldJsonCrowdinObject,\n\t  fieldDocValue,\n\t} from \"../fixtures/blocks-field-type.fixture\";\n\timport dot from \"dot-object\";\n\tdescribe(\"fn: buildPayloadUpdateObject: blocks field type\", () => {\n\t  it(\"includes localized fields\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n", "      blocksField: fieldDocValue,\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n", "      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      field,\n\t    ];\n", "    const crowdinJsonObject = {\n\t      title: \"Test Policy created with title\",\n\t      ...fieldJsonCrowdinObject(),\n\t    };\n\t    const crowdinHtmlObject = fieldHtmlCrowdinObject();\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      blocksField: fieldDocValue,\n\t    };\n\t    expect(\n", "      buildPayloadUpdateObject({\n\t        crowdinJsonObject,\n\t        crowdinHtmlObject,\n\t        fields,\n\t        document: doc,\n\t      })\n\t    ).toEqual(expected);\n\t  });\n\t});\n"]}
{"filename": "src/utilities/tests/getLocalizedFields/tabs-field-type.spec.ts", "chunked_list": ["import { Field } from \"payload/types\";\n\timport { getLocalizedFields } from \"./../../\";\n\timport { basicLocalizedFields } from \"../fixtures/basic-localized-fields.fixture\";\n\tdescribe(\"presentation only tab fields\", () => {\n\t  it(\"returns an empty array if no localized fields in tabs\", () => {\n\t    // fixture from https://payloadcms.com/docs/fields/tabs\n\t    const fields: Field[] = [\n\t      {\n\t        type: \"tabs\", // required\n\t        tabs: [\n", "          // required\n\t          {\n\t            label: \"Tab One Label\", // required\n\t            description: \"This will appear within the tab above the fields.\",\n\t            fields: [\n\t              // required\n\t              {\n\t                name: \"someTextField\",\n\t                type: \"text\",\n\t                required: true,\n", "              },\n\t            ],\n\t          },\n\t          {\n\t            name: \"tabTwo\",\n\t            label: \"Tab Two Label\", // required\n\t            interfaceName: \"TabTwo\", // optional (`name` must be present)\n\t            fields: [\n\t              // required\n\t              {\n", "                name: \"numberField\", // accessible via tabTwo.numberField\n\t                type: \"number\",\n\t                required: true,\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    ];\n\t    expect(getLocalizedFields({ fields })).toEqual([]);\n", "  });\n\t  it(\"returns localized fields in tabs\", () => {\n\t    // fixture from https://payloadcms.com/docs/fields/tabs\n\t    const fields: Field[] = [\n\t      {\n\t        type: \"tabs\", // required\n\t        tabs: [\n\t          // required\n\t          {\n\t            label: \"Tab One Label\", // required\n", "            description: \"This will appear within the tab above the fields.\",\n\t            fields: [\n\t              // required\n\t              {\n\t                name: \"someTextField\",\n\t                type: \"text\",\n\t                required: true,\n\t                localized: true,\n\t              },\n\t            ],\n", "          },\n\t          {\n\t            name: \"tabTwo\",\n\t            label: \"Tab Two Label\", // required\n\t            interfaceName: \"TabTwo\", // optional (`name` must be present)\n\t            fields: [\n\t              // required\n\t              {\n\t                name: \"numberField\", // accessible via tabTwo.numberField\n\t                type: \"number\",\n", "                required: true,\n\t                localized: true,\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    ];\n\t    expect(getLocalizedFields({ fields })).toEqual([\n\t      {\n", "        localized: true,\n\t        name: \"someTextField\",\n\t        required: true,\n\t        type: \"text\",\n\t      },\n\t    ]);\n\t  });\n\t  it(\"returns localized fields in tab respecting tab names\", () => {\n\t    // fixture from https://payloadcms.com/docs/fields/tabs\n\t    const fields: Field[] = [\n", "      {\n\t        type: \"tabs\", // required\n\t        tabs: [\n\t          // required\n\t          {\n\t            label: \"Tab One Label\", // required\n\t            description: \"This will appear within the tab above the fields.\",\n\t            fields: basicLocalizedFields,\n\t          },\n\t          {\n", "            name: \"tabTwo\",\n\t            label: \"Tab Two Label\", // required\n\t            interfaceName: \"TabTwo\", // optional (`name` must be present)\n\t            fields: basicLocalizedFields,\n\t          },\n\t        ],\n\t      },\n\t    ];\n\t    expect(getLocalizedFields({ fields })).toEqual([\n\t      {\n", "        fields: [\n\t          {\n\t            name: \"textField\",\n\t            type: \"text\",\n\t            localized: true,\n\t          },\n\t          {\n\t            name: \"textareaField\",\n\t            type: \"textarea\",\n\t            localized: true,\n", "          },\n\t        ],\n\t        name: \"tabTwo\",\n\t        type: \"group\",\n\t      },\n\t      {\n\t        name: \"textField\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n", "      {\n\t        name: \"textareaField\",\n\t        type: \"textarea\",\n\t        localized: true,\n\t      },\n\t    ]);\n\t  });\n\t  it(\"returns localized fields in tab respecting tab names with other fields\", () => {\n\t    // fixture from https://payloadcms.com/docs/fields/tabs\n\t    const fields: Field[] = [\n", "      {\n\t        name: \"textFieldExtra\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"textareaFieldExtra\",\n\t        type: \"textarea\",\n\t        localized: true,\n\t      },\n", "      {\n\t        type: \"tabs\", // required\n\t        tabs: [\n\t          // required\n\t          {\n\t            label: \"Tab One Label\", // required\n\t            description: \"This will appear within the tab above the fields.\",\n\t            fields: basicLocalizedFields,\n\t          },\n\t          {\n", "            name: \"tabTwo\",\n\t            label: \"Tab Two Label\", // required\n\t            interfaceName: \"TabTwo\", // optional (`name` must be present)\n\t            fields: basicLocalizedFields,\n\t          },\n\t        ],\n\t      },\n\t    ];\n\t    expect(getLocalizedFields({ fields })).toEqual([\n\t      {\n", "        name: \"textFieldExtra\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"textareaFieldExtra\",\n\t        type: \"textarea\",\n\t        localized: true,\n\t      },\n\t      {\n", "        fields: [\n\t          {\n\t            name: \"textField\",\n\t            type: \"text\",\n\t            localized: true,\n\t          },\n\t          {\n\t            name: \"textareaField\",\n\t            type: \"textarea\",\n\t            localized: true,\n", "          },\n\t        ],\n\t        name: \"tabTwo\",\n\t        type: \"group\",\n\t      },\n\t      {\n\t        name: \"textField\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n", "      {\n\t        name: \"textareaField\",\n\t        type: \"textarea\",\n\t        localized: true,\n\t      },\n\t    ]);\n\t  });\n\t});\n"]}
{"filename": "src/utilities/tests/inline-snapshots/book-demo.test.ts", "chunked_list": ["import BookDemo from \"./collections/BookDemo\";\n\timport {\n\t  buildCrowdinJsonObject,\n\t  buildCrowdinHtmlObject,\n\t  buildPayloadUpdateObject,\n\t  getLocalizedFields,\n\t} from \"../..\";\n\tdescribe(\"book demo collection snapshots\", () => {\n\t  const doc = {\n\t    hero: {\n", "      title: [\n\t        {\n\t          type: \"p\",\n\t          children: [\n\t            {\n\t              text: \"Réservez une démo\",\n\t            },\n\t          ],\n\t        },\n\t      ],\n", "      text: [\n\t        {\n\t          type: \"p\",\n\t          children: [\n\t            {\n\t              text: \"Apprenez comment Acme Corp peut vous aider à \",\n\t            },\n\t            {\n\t              text: \"atteindre vos objectifs\",\n\t              bold: true,\n", "            },\n\t            {\n\t              text: \". Nous sommes prêts à parier que vous apprendrez quelque chose de nouveau lors de notre rencontre. Et si ce n’est pas le cas, on vous offre un cupcake ! 😉\",\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    },\n\t    form: {\n\t      title: \"Réservez une démo\",\n", "      subTitle:\n\t        \"Nous vous contacterons dès que possible pour fixer une heure qui vous convienne.\",\n\t      content: {\n\t        title: \"\",\n\t        items: [\n\t          {\n\t            text: \"\",\n\t            id: \"64a8af5656f68b0022bfd267\",\n\t          },\n\t          {\n", "            text: \"Offres d'emploi et utilisateurs illimités\",\n\t            id: \"64a8af5656f68b0022bfd268\",\n\t          },\n\t          {\n\t            text: \"\",\n\t            id: \"64a8af5656f68b0022bfd269\",\n\t          },\n\t          {\n\t            text: \"\",\n\t            id: \"64a8af5656f68b0022bfd26a\",\n", "          },\n\t          {\n\t            text: \"\",\n\t            id: \"64a8af5656f68b0022bfd26b\",\n\t          },\n\t          {\n\t            text: \"Des présentations produits et des webinaires gratuits\",\n\t            id: \"64a8af5656f68b0022bfd26c\",\n\t          },\n\t          {\n", "            text: \"Un accès complet à l'Académie Acme Corp\",\n\t            id: \"64a8af5656f68b0022bfd26d\",\n\t          },\n\t        ],\n\t      },\n\t    },\n\t    logoTitle: \"Adoré par les meilleurs recruteurs internationaux\",\n\t    promo: \"6474f51370b180880beb4bcb\",\n\t    meta: {\n\t      title: \"Réservez une démo | Acme Corp\",\n", "      description:\n\t        \"Book a demo of Acme Corp Widget and let our team show you the magic of our product! Schedule a call with one of team members here.\",\n\t    },\n\t    crowdinArticleDirectory: \"6486e2a7715834a0e4b7cea4\",\n\t    _status: \"published\",\n\t    globalType: \"book-demo\",\n\t    createdAt: \"2023-06-12T07:43:55.361Z\",\n\t    updatedAt: \"2023-07-25T09:43:57.619Z\",\n\t    id: \"6486ccbb27a4f59700b066ec\",\n\t  };\n", "  const fields = BookDemo.fields;\n\t  const localizedFields = getLocalizedFields({ fields });\n\t  const crowdinJsonObject = buildCrowdinJsonObject({\n\t    doc,\n\t    fields: localizedFields,\n\t  });\n\t  const crowdinHtmlObject = buildCrowdinHtmlObject({\n\t    doc,\n\t    fields: localizedFields,\n\t  });\n", "  it(\"getLocalizedFields\", () => {\n\t    expect(getLocalizedFields({ fields })).toMatchInlineSnapshot(`\n\t      [\n\t        {\n\t          \"localized\": true,\n\t          \"name\": \"logoTitle\",\n\t          \"required\": true,\n\t          \"type\": \"text\",\n\t        },\n\t        {\n", "          \"fields\": [\n\t            {\n\t              \"admin\": {\n\t                \"elements\": [],\n\t                \"leaves\": [\n\t                  \"bold\",\n\t                ],\n\t              },\n\t              \"name\": \"title\",\n\t              \"type\": \"richText\",\n", "            },\n\t            {\n\t              \"admin\": {\n\t                \"elements\": [],\n\t                \"leaves\": [\n\t                  \"bold\",\n\t                ],\n\t              },\n\t              \"name\": \"text\",\n\t              \"type\": \"richText\",\n", "            },\n\t          ],\n\t          \"localized\": true,\n\t          \"name\": \"hero\",\n\t          \"type\": \"group\",\n\t        },\n\t        {\n\t          \"fields\": [\n\t            {\n\t              \"name\": \"title\",\n", "              \"type\": \"text\",\n\t            },\n\t            {\n\t              \"name\": \"subTitle\",\n\t              \"type\": \"text\",\n\t            },\n\t            {\n\t              \"fields\": [\n\t                {\n\t                  \"name\": \"title\",\n", "                  \"type\": \"text\",\n\t                },\n\t                {\n\t                  \"fields\": [\n\t                    {\n\t                      \"name\": \"text\",\n\t                      \"type\": \"text\",\n\t                    },\n\t                  ],\n\t                  \"localized\": true,\n", "                  \"name\": \"items\",\n\t                  \"type\": \"array\",\n\t                },\n\t              ],\n\t              \"localized\": true,\n\t              \"name\": \"content\",\n\t              \"type\": \"group\",\n\t            },\n\t          ],\n\t          \"localized\": true,\n", "          \"name\": \"form\",\n\t          \"type\": \"group\",\n\t        },\n\t      ]\n\t    `);\n\t  });\n\t  it(\"buildCrowdinJsonObject\", () => {\n\t    expect(crowdinJsonObject).toMatchInlineSnapshot(`\n\t      {\n\t        \"form\": {\n", "          \"content\": {\n\t            \"items\": {\n\t              \"64a8af5656f68b0022bfd268\": {\n\t                \"text\": \"Offres d'emploi et utilisateurs illimités\",\n\t              },\n\t              \"64a8af5656f68b0022bfd26c\": {\n\t                \"text\": \"Des présentations produits et des webinaires gratuits\",\n\t              },\n\t              \"64a8af5656f68b0022bfd26d\": {\n\t                \"text\": \"Un accès complet à l'Académie Acme Corp\",\n", "              },\n\t            },\n\t          },\n\t          \"subTitle\": \"Nous vous contacterons dès que possible pour fixer une heure qui vous convienne.\",\n\t          \"title\": \"Réservez une démo\",\n\t        },\n\t        \"logoTitle\": \"Adoré par les meilleurs recruteurs internationaux\",\n\t      }\n\t    `);\n\t  });\n", "  it(\"buildCrowdinHtmlObject\", () => {\n\t    expect(crowdinHtmlObject).toMatchInlineSnapshot(`\n\t      {\n\t        \"hero.text\": [\n\t          {\n\t            \"children\": [\n\t              {\n\t                \"text\": \"Apprenez comment Acme Corp peut vous aider à \",\n\t              },\n\t              {\n", "                \"bold\": true,\n\t                \"text\": \"atteindre vos objectifs\",\n\t              },\n\t              {\n\t                \"text\": \". Nous sommes prêts à parier que vous apprendrez quelque chose de nouveau lors de notre rencontre. Et si ce n’est pas le cas, on vous offre un cupcake ! 😉\",\n\t              },\n\t            ],\n\t            \"type\": \"p\",\n\t          },\n\t        ],\n", "        \"hero.title\": [\n\t          {\n\t            \"children\": [\n\t              {\n\t                \"text\": \"Réservez une démo\",\n\t              },\n\t            ],\n\t            \"type\": \"p\",\n\t          },\n\t        ],\n", "      }\n\t    `);\n\t  });\n\t  it(\"buildPayloadUpdateObject\", () => {\n\t    const docTranslations = buildPayloadUpdateObject({\n\t      crowdinJsonObject,\n\t      crowdinHtmlObject,\n\t      fields: localizedFields,\n\t      document: doc,\n\t    });\n", "    expect(docTranslations).toMatchInlineSnapshot(`\n\t      {\n\t        \"form\": {\n\t          \"content\": {\n\t            \"items\": [\n\t              {\n\t                \"id\": \"64a8af5656f68b0022bfd268\",\n\t                \"text\": \"Offres d'emploi et utilisateurs illimités\",\n\t              },\n\t              {\n", "                \"id\": \"64a8af5656f68b0022bfd26c\",\n\t                \"text\": \"Des présentations produits et des webinaires gratuits\",\n\t              },\n\t              {\n\t                \"id\": \"64a8af5656f68b0022bfd26d\",\n\t                \"text\": \"Un accès complet à l'Académie Acme Corp\",\n\t              },\n\t            ],\n\t          },\n\t          \"subTitle\": \"Nous vous contacterons dès que possible pour fixer une heure qui vous convienne.\",\n", "          \"title\": \"Réservez une démo\",\n\t        },\n\t        \"hero\": {\n\t          \"text\": [\n\t            {\n\t              \"children\": [\n\t                {\n\t                  \"text\": \"Apprenez comment Acme Corp peut vous aider à \",\n\t                },\n\t                {\n", "                  \"bold\": true,\n\t                  \"text\": \"atteindre vos objectifs\",\n\t                },\n\t                {\n\t                  \"text\": \". Nous sommes prêts à parier que vous apprendrez quelque chose de nouveau lors de notre rencontre. Et si ce n’est pas le cas, on vous offre un cupcake ! 😉\",\n\t                },\n\t              ],\n\t              \"type\": \"p\",\n\t            },\n\t          ],\n", "          \"title\": [\n\t            {\n\t              \"children\": [\n\t                {\n\t                  \"text\": \"Réservez une démo\",\n\t                },\n\t              ],\n\t              \"type\": \"p\",\n\t            },\n\t          ],\n", "        },\n\t        \"logoTitle\": \"Adoré par les meilleurs recruteurs internationaux\",\n\t      }\n\t    `);\n\t  });\n\t});\n"]}
{"filename": "src/utilities/tests/inline-snapshots/collections/BookDemo.ts", "chunked_list": ["import { GlobalConfig } from \"payload/types\";\n\timport { heroField } from \"./shared/heroField\";\n\timport { collapsibleFields as cf } from \"./shared/collapsibleFields\";\n\tconst BookDemo: GlobalConfig = {\n\t  slug: \"book-demo\",\n\t  access: {\n\t    read: () => true,\n\t  },\n\t  versions: {\n\t    drafts: true,\n", "  },\n\t  admin: {\n\t    group: \"Static Pages\",\n\t  },\n\t  fields: [\n\t    cf(\"Hero\", [heroField({ image: true })]),\n\t    cf(\"Form\", [\n\t      {\n\t        type: \"group\",\n\t        name: \"form\",\n", "        localized: true,\n\t        fields: [\n\t          {\n\t            type: \"text\",\n\t            name: \"title\",\n\t          },\n\t          {\n\t            type: \"text\",\n\t            name: \"subTitle\",\n\t          },\n", "          {\n\t            type: \"group\",\n\t            name: \"content\",\n\t            localized: true,\n\t            fields: [\n\t              {\n\t                name: \"title\",\n\t                type: \"text\",\n\t              },\n\t              {\n", "                name: \"items\",\n\t                type: \"array\",\n\t                localized: true,\n\t                fields: [{ type: \"text\", name: \"text\" }],\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    ]),\n", "    {\n\t      name: \"logoTitle\",\n\t      type: \"text\",\n\t      required: true,\n\t      localized: true,\n\t    },\n\t    cf(\"Promo\", [\n\t      {\n\t        name: \"promo\",\n\t        type: \"relationship\",\n", "        relationTo: \"promos\",\n\t        hasMany: false,\n\t      },\n\t    ]),\n\t  ],\n\t};\n\texport default BookDemo;\n"]}
{"filename": "src/utilities/tests/inline-snapshots/collections/shared/heroField.ts", "chunked_list": ["interface IHeroFieldOptions {\n\t  image?: boolean;\n\t  badge?: boolean;\n\t}\n\tconst defaultOptions = { image: false, badge: false };\n\texport const heroField = (options: IHeroFieldOptions = {}): any => {\n\t  options = { ...defaultOptions, ...options };\n\t  const config = {\n\t    name: \"hero\",\n\t    type: \"group\",\n", "    localized: true,\n\t    fields: [\n\t      {\n\t        name: \"title\",\n\t        type: \"richText\",\n\t        admin: {\n\t          elements: [],\n\t          leaves: [\"bold\"],\n\t        },\n\t      },\n", "      {\n\t        name: \"text\",\n\t        type: \"richText\",\n\t        admin: {\n\t          elements: [],\n\t          leaves: [\"bold\"],\n\t        },\n\t      },\n\t      options.badge && {\n\t        name: \"badge\",\n", "        type: \"group\",\n\t        localized: true,\n\t        fields: [\n\t          {\n\t            name: \"badgeText\",\n\t            type: \"text\",\n\t          },\n\t          {\n\t            name: \"text\",\n\t            type: \"text\",\n", "          },\n\t          {\n\t            name: \"link\",\n\t            type: \"text\",\n\t            admin: {\n\t              description: \"Not sent to CrowdIn. Localize in the CMS.\",\n\t            },\n\t          },\n\t        ],\n\t      },\n", "      options.image && {\n\t        name: \"image\",\n\t        type: \"upload\",\n\t        relationTo: \"media\",\n\t      },\n\t    ].filter(Boolean),\n\t  };\n\t  return config;\n\t};\n"]}
{"filename": "src/utilities/tests/inline-snapshots/collections/shared/collapsibleFields.ts", "chunked_list": ["import { Field } from \"payload/types\";\n\texport const collapsibleFields = (label: string, fields: any): Field => ({\n\t  type: \"collapsible\",\n\t  label,\n\t  admin: {\n\t    initCollapsed: true,\n\t  },\n\t  fields,\n\t});\n"]}
{"filename": "src/utilities/tests/buildHtmlCrowdinObject/basic-field-types.spec.ts", "chunked_list": ["import { CollectionConfig, Field, GlobalConfig } from \"payload/types\";\n\timport { buildCrowdinHtmlObject, getLocalizedFields } from \"../..\";\n\tdescribe(\"fn: buildCrowdinHtmlObject\", () => {\n\t  it(\"does not include undefined localized fields\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: [\n\t        {\n\t          type: \"h1\",\n\t          children: [\n", "            {\n\t              text: \"A \",\n\t            },\n\t            {\n\t              text: \"test\",\n\t              bold: true,\n\t            },\n\t            {\n\t              text: \" rich text value\",\n\t            },\n", "          ],\n\t        },\n\t      ],\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n", "        type: \"richText\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"anotherString\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t    ];\n\t    const expected = {\n", "      title: [\n\t        {\n\t          type: \"h1\",\n\t          children: [\n\t            {\n\t              text: \"A \",\n\t            },\n\t            {\n\t              text: \"test\",\n\t              bold: true,\n", "            },\n\t            {\n\t              text: \" rich text value\",\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    };\n\t    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n\t  });\n", "  it(\"includes localized fields\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: [\n\t        {\n\t          type: \"h1\",\n\t          children: [\n\t            {\n\t              text: \"A \",\n\t            },\n", "            {\n\t              text: \"test\",\n\t              bold: true,\n\t            },\n\t            {\n\t              text: \" rich text value\",\n\t            },\n\t          ],\n\t        },\n\t      ],\n", "      content: [\n\t        {\n\t          type: \"p\",\n\t          children: [\n\t            {\n\t              text: \"A simple paragraph.\",\n\t            },\n\t          ],\n\t        },\n\t      ],\n", "      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"richText\",\n\t        localized: true,\n\t      },\n", "      {\n\t        name: \"content\",\n\t        type: \"richText\",\n\t        localized: true,\n\t      },\n\t    ];\n\t    const expected = {\n\t      title: [\n\t        {\n\t          type: \"h1\",\n", "          children: [\n\t            {\n\t              text: \"A \",\n\t            },\n\t            {\n\t              text: \"test\",\n\t              bold: true,\n\t            },\n\t            {\n\t              text: \" rich text value\",\n", "            },\n\t          ],\n\t        },\n\t      ],\n\t      content: [\n\t        {\n\t          type: \"p\",\n\t          children: [\n\t            {\n\t              text: \"A simple paragraph.\",\n", "            },\n\t          ],\n\t        },\n\t      ],\n\t    };\n\t    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n\t  });\n\t  it(\"includes localized fields nested in a group\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n", "      title: \"Test Policy created with title\",\n\t      groupField: {\n\t        title: [\n\t          {\n\t            type: \"h1\",\n\t            children: [\n\t              {\n\t                text: \"A \",\n\t              },\n\t              {\n", "                text: \"test\",\n\t                bold: true,\n\t              },\n\t              {\n\t                text: \" rich text value\",\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t        content: [\n", "          {\n\t            type: \"p\",\n\t            children: [\n\t              {\n\t                text: \"A simple paragraph.\",\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t        select: \"one\",\n", "      },\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n", "      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n\t        name: \"groupField\",\n", "        type: \"group\",\n\t        fields: [\n\t          {\n\t            admin: {\n\t              elements: [\"link\"],\n\t              leaves: [\"bold\", \"italic\", \"underline\"],\n\t            },\n\t            name: \"title\",\n\t            type: \"richText\",\n\t            localized: true,\n", "          },\n\t          {\n\t            name: \"content\",\n\t            type: \"richText\",\n\t            localized: true,\n\t          },\n\t          // select not supported yet\n\t          {\n\t            name: \"select\",\n\t            type: \"select\",\n", "            localized: true,\n\t            options: [\"one\", \"two\"],\n\t          },\n\t        ],\n\t      },\n\t    ];\n\t    const expected = {\n\t      [\"groupField.title\"]: [\n\t        {\n\t          type: \"h1\",\n", "          children: [\n\t            {\n\t              text: \"A \",\n\t            },\n\t            {\n\t              text: \"test\",\n\t              bold: true,\n\t            },\n\t            {\n\t              text: \" rich text value\",\n", "            },\n\t          ],\n\t        },\n\t      ],\n\t      [\"groupField.content\"]: [\n\t        {\n\t          type: \"p\",\n\t          children: [\n\t            {\n\t              text: \"A simple paragraph.\",\n", "            },\n\t          ],\n\t        },\n\t      ],\n\t    };\n\t    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n\t  });\n\t  it(\"includes localized fields nested in a group with a localization setting on the group field\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n", "      title: \"Test Policy created with title\",\n\t      groupField: {\n\t        title: [\n\t          {\n\t            type: \"h1\",\n\t            children: [\n\t              {\n\t                text: \"A \",\n\t              },\n\t              {\n", "                text: \"test\",\n\t                bold: true,\n\t              },\n\t              {\n\t                text: \" rich text value\",\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t        content: [\n", "          {\n\t            type: \"p\",\n\t            children: [\n\t              {\n\t                text: \"A simple paragraph.\",\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t        select: \"one\",\n", "      },\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n", "      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n\t        name: \"groupField\",\n", "        type: \"group\",\n\t        localized: true,\n\t        fields: [\n\t          {\n\t            admin: {\n\t              elements: [\"link\"],\n\t              leaves: [\"bold\", \"italic\", \"underline\"],\n\t            },\n\t            name: \"title\",\n\t            type: \"richText\",\n", "          },\n\t          {\n\t            name: \"content\",\n\t            type: \"richText\",\n\t          },\n\t          // select not supported yet\n\t          {\n\t            name: \"select\",\n\t            type: \"select\",\n\t            options: [\"one\", \"two\"],\n", "          },\n\t        ],\n\t      },\n\t    ];\n\t    const expected = {\n\t      [\"groupField.title\"]: [\n\t        {\n\t          type: \"h1\",\n\t          children: [\n\t            {\n", "              text: \"A \",\n\t            },\n\t            {\n\t              text: \"test\",\n\t              bold: true,\n\t            },\n\t            {\n\t              text: \" rich text value\",\n\t            },\n\t          ],\n", "        },\n\t      ],\n\t      [\"groupField.content\"]: [\n\t        {\n\t          type: \"p\",\n\t          children: [\n\t            {\n\t              text: \"A simple paragraph.\",\n\t            },\n\t          ],\n", "        },\n\t      ],\n\t    };\n\t    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n\t  });\n\t});\n"]}
{"filename": "src/utilities/tests/buildHtmlCrowdinObject/array-field-type.spec.ts", "chunked_list": ["import { CollectionConfig, Field } from \"payload/types\";\n\timport { buildCrowdinHtmlObject } from \"../..\";\n\timport {\n\t  field,\n\t  fieldCrowdinObject,\n\t  fieldDocValue,\n\t  fieldLocalizedTopLevel,\n\t} from \"./fixtures/array-field-type.fixture\";\n\tdescribe(\"fn: buildCrowdinHtmlObject: array field type\", () => {\n\t  it(\"includes localized fields\", () => {\n", "    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      arrayField: fieldDocValue,\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n", "        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n", "      },\n\t      field,\n\t    ];\n\t    const expected = fieldCrowdinObject;\n\t    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n\t  });\n\t  it(\"includes localized fields with a top-level localization setting\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n", "      arrayField: fieldDocValue,\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n", "      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      fieldLocalizedTopLevel,\n\t    ];\n", "    const expected = fieldCrowdinObject;\n\t    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n\t  });\n\t  it(\"includes localized fields within a collapsible field\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      arrayField: fieldDocValue,\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n", "      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n", "        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n\t        label: \"Array fields\",\n\t        type: \"collapsible\",\n\t        fields: [field],\n\t      },\n", "    ];\n\t    const expected = fieldCrowdinObject;\n\t    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n\t  });\n\t  it(\"includes localized fields with a top-level localization setting within a collapsible field\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      arrayField: fieldDocValue,\n\t      status: \"draft\",\n", "      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n", "      {\n\t        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n\t        label: \"Array fields\",\n\t        type: \"collapsible\",\n\t        fields: [fieldLocalizedTopLevel],\n", "      },\n\t    ];\n\t    const expected = fieldCrowdinObject;\n\t    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n\t  });\n\t});\n\tdescribe(\"fn: buildCrowdinHtmlObject - group nested in array\", () => {\n\t  const doc = {\n\t    id: \"6474a81bef389b66642035ff\",\n\t    title: [\n", "      {\n\t        type: \"h1\",\n\t        children: [\n\t          {\n\t            text: \"A \",\n\t          },\n\t          {\n\t            text: \"test\",\n\t            bold: true,\n\t          },\n", "          {\n\t            text: \" rich text value\",\n\t          },\n\t        ],\n\t      },\n\t    ],\n\t    ctas: [\n\t      {\n\t        link: {\n\t          text: [\n", "            {\n\t              type: \"p\",\n\t              children: [\n\t                {\n\t                  text: \"Link rich text.\",\n\t                },\n\t              ],\n\t            },\n\t          ],\n\t          href: \"#\",\n", "          type: \"ctaPrimary\",\n\t        },\n\t        id: \"6474a80221baea4f5f169757\",\n\t      },\n\t      {\n\t        link: {\n\t          text: [\n\t            {\n\t              type: \"p\",\n\t              children: [\n", "                {\n\t                  text: \"Second link rich text.\",\n\t                },\n\t              ],\n\t            },\n\t          ],\n\t          href: \"#\",\n\t          type: \"ctaSecondary\",\n\t        },\n\t        id: \"6474a81021baea4f5f169758\",\n", "      },\n\t    ],\n\t    createdAt: \"2023-05-29T13:26:51.734Z\",\n\t    updatedAt: \"2023-05-29T14:47:45.957Z\",\n\t    crowdinArticleDirectory: {\n\t      id: \"6474baaf73b854f4d464e38f\",\n\t      updatedAt: \"2023-05-29T14:46:07.000Z\",\n\t      createdAt: \"2023-05-29T14:46:07.000Z\",\n\t      name: \"6474a81bef389b66642035ff\",\n\t      crowdinCollectionDirectory: {\n", "        id: \"6474baaf73b854f4d464e38d\",\n\t        updatedAt: \"2023-05-29T14:46:07.000Z\",\n\t        createdAt: \"2023-05-29T14:46:07.000Z\",\n\t        name: \"promos\",\n\t        title: \"Promos\",\n\t        collectionSlug: \"promos\",\n\t        originalId: 1633,\n\t        projectId: 323731,\n\t        directoryId: 1169,\n\t      },\n", "      originalId: 1635,\n\t      projectId: 323731,\n\t      directoryId: 1633,\n\t    },\n\t  };\n\t  const linkField: Field = {\n\t    name: \"link\",\n\t    type: \"group\",\n\t    fields: [\n\t      {\n", "        name: \"text\",\n\t        type: \"richText\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"href\",\n\t        type: \"text\",\n\t      },\n\t      {\n\t        name: \"type\",\n", "        type: \"select\",\n\t        options: [\"ctaPrimary\", \"ctaSecondary\"],\n\t      },\n\t    ],\n\t  };\n\t  const Promos: CollectionConfig = {\n\t    slug: \"promos\",\n\t    admin: {\n\t      defaultColumns: [\"title\", \"updatedAt\"],\n\t      useAsTitle: \"title\",\n", "      group: \"Shared\",\n\t    },\n\t    access: {\n\t      read: () => true,\n\t    },\n\t    fields: [\n\t      {\n\t        name: \"title\",\n\t        type: \"richText\",\n\t        localized: true,\n", "      },\n\t      {\n\t        name: \"text\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"ctas\",\n\t        type: \"array\",\n\t        minRows: 1,\n", "        maxRows: 2,\n\t        fields: [linkField],\n\t      },\n\t    ],\n\t  };\n\t  const expected: any = {\n\t    [\"ctas.6474a80221baea4f5f169757.link.text\"]: [\n\t      {\n\t        type: \"p\",\n\t        children: [\n", "          {\n\t            text: \"Link rich text.\",\n\t          },\n\t        ],\n\t      },\n\t    ],\n\t    [\"ctas.6474a81021baea4f5f169758.link.text\"]: [\n\t      {\n\t        type: \"p\",\n\t        children: [\n", "          {\n\t            text: \"Second link rich text.\",\n\t          },\n\t        ],\n\t      },\n\t    ],\n\t    title: [\n\t      {\n\t        type: \"h1\",\n\t        children: [\n", "          {\n\t            text: \"A \",\n\t          },\n\t          {\n\t            text: \"test\",\n\t            bold: true,\n\t          },\n\t          {\n\t            text: \" rich text value\",\n\t          },\n", "        ],\n\t      },\n\t    ],\n\t  };\n\t  it(\"includes group json fields nested inside of array field items\", () => {\n\t    expect(buildCrowdinHtmlObject({ doc, fields: Promos.fields })).toEqual(\n\t      expected\n\t    );\n\t  });\n\t  it(\"can work with an empty group field in an array\", () => {\n", "    expect(\n\t      buildCrowdinHtmlObject({\n\t        doc: {\n\t          ...doc,\n\t          ctas: [{}, {}],\n\t        },\n\t        fields: Promos.fields,\n\t      })\n\t    ).toEqual({\n\t      title: [\n", "        {\n\t          type: \"h1\",\n\t          children: [\n\t            {\n\t              text: \"A \",\n\t            },\n\t            {\n\t              text: \"test\",\n\t              bold: true,\n\t            },\n", "            {\n\t              text: \" rich text value\",\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/utilities/tests/buildHtmlCrowdinObject/blocks-field-type.spec.ts", "chunked_list": ["import { CollectionConfig, Field } from \"payload/types\";\n\timport { buildCrowdinHtmlObject } from \"../..\";\n\timport {\n\t  field,\n\t  fieldHtmlCrowdinObject,\n\t  fieldDocValue,\n\t} from \"../fixtures/blocks-field-type.fixture\";\n\tdescribe(\"fn: buildCrowdinHtmlObject: blocks field type\", () => {\n\t  it(\"includes localized fields\", () => {\n\t    const doc = {\n", "      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      blocksField: fieldDocValue,\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n", "        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n", "      field,\n\t    ];\n\t    const expected = fieldHtmlCrowdinObject();\n\t    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n\t  });\n\t  it(\"includes localized fields within a collapsible field\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      blocksField: fieldDocValue,\n", "      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n", "      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n\t        label: \"Array fields\",\n\t        type: \"collapsible\",\n", "        fields: [field],\n\t      },\n\t    ];\n\t    const expected = fieldHtmlCrowdinObject();\n\t    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n\t  });\n\t  it(\"includes localized fields within an array field\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n", "      arrayField: [\n\t        {\n\t          blocksField: fieldDocValue,\n\t          id: \"63ea4adb6ff825cddad3c1f2\",\n\t        },\n\t      ],\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n", "    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n", "        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n\t        name: \"arrayField\",\n\t        type: \"array\",\n\t        fields: [field],\n\t      },\n\t    ];\n\t    const expected = fieldHtmlCrowdinObject(\n", "      \"arrayField.63ea4adb6ff825cddad3c1f2.\"\n\t    );\n\t    expect(buildCrowdinHtmlObject({ doc, fields })).toEqual(expected);\n\t  });\n\t});\n"]}
{"filename": "src/utilities/tests/buildHtmlCrowdinObject/fixtures/array-field-type.fixture.ts", "chunked_list": ["import { Field } from \"payload/types\";\n\texport const field: Field = {\n\t  name: \"arrayField\",\n\t  type: \"array\",\n\t  fields: [\n\t    {\n\t      name: \"title\",\n\t      type: \"richText\",\n\t      localized: true,\n\t    },\n", "    {\n\t      name: \"content\",\n\t      type: \"richText\",\n\t      localized: true,\n\t    },\n\t    {\n\t      name: \"select\",\n\t      type: \"select\",\n\t      localized: true,\n\t      options: [\"one\", \"two\"],\n", "    },\n\t  ],\n\t};\n\texport const fieldLocalizedTopLevel: Field = {\n\t  name: \"arrayField\",\n\t  type: \"array\",\n\t  localized: true,\n\t  fields: [\n\t    {\n\t      name: \"title\",\n", "      type: \"richText\",\n\t    },\n\t    {\n\t      name: \"content\",\n\t      type: \"richText\",\n\t    },\n\t    {\n\t      name: \"select\",\n\t      type: \"select\",\n\t      options: [\"one\", \"two\"],\n", "    },\n\t  ],\n\t};\n\texport const fieldDocValue = [\n\t  {\n\t    title: [\n\t      {\n\t        type: \"h1\",\n\t        children: [\n\t          {\n", "            text: \"A \",\n\t          },\n\t          {\n\t            text: \"test\",\n\t            bold: true,\n\t          },\n\t          {\n\t            text: \" rich text value\",\n\t          },\n\t        ],\n", "      },\n\t    ],\n\t    content: [\n\t      {\n\t        type: \"p\",\n\t        children: [\n\t          {\n\t            text: \"A simple paragraph in the first array item.\",\n\t          },\n\t        ],\n", "      },\n\t    ],\n\t    select: \"two\",\n\t    id: \"64735620230d57bce946d370\",\n\t  },\n\t  {\n\t    title: [\n\t      {\n\t        type: \"h1\",\n\t        children: [\n", "          {\n\t            text: \"A \",\n\t          },\n\t          {\n\t            text: \"test\",\n\t            bold: true,\n\t          },\n\t          {\n\t            text: \" rich text value\",\n\t          },\n", "        ],\n\t      },\n\t    ],\n\t    content: [\n\t      {\n\t        type: \"p\",\n\t        children: [\n\t          {\n\t            text: \"A simple paragraph in the second array item.\",\n\t          },\n", "        ],\n\t      },\n\t    ],\n\t    select: \"two\",\n\t    id: \"64735621230d57bce946d371\",\n\t  },\n\t];\n\texport const fieldCrowdinObject = {\n\t  [\"arrayField.64735620230d57bce946d370.title\"]: [\n\t    {\n", "      type: \"h1\",\n\t      children: [\n\t        {\n\t          text: \"A \",\n\t        },\n\t        {\n\t          text: \"test\",\n\t          bold: true,\n\t        },\n\t        {\n", "          text: \" rich text value\",\n\t        },\n\t      ],\n\t    },\n\t  ],\n\t  [\"arrayField.64735620230d57bce946d370.content\"]: [\n\t    {\n\t      type: \"p\",\n\t      children: [\n\t        {\n", "          text: \"A simple paragraph in the first array item.\",\n\t        },\n\t      ],\n\t    },\n\t  ],\n\t  [\"arrayField.64735621230d57bce946d371.title\"]: [\n\t    {\n\t      type: \"h1\",\n\t      children: [\n\t        {\n", "          text: \"A \",\n\t        },\n\t        {\n\t          text: \"test\",\n\t          bold: true,\n\t        },\n\t        {\n\t          text: \" rich text value\",\n\t        },\n\t      ],\n", "    },\n\t  ],\n\t  [\"arrayField.64735621230d57bce946d371.content\"]: [\n\t    {\n\t      type: \"p\",\n\t      children: [\n\t        {\n\t          text: \"A simple paragraph in the second array item.\",\n\t        },\n\t      ],\n", "    },\n\t  ],\n\t};\n"]}
{"filename": "src/utilities/tests/buildJsonCrowdinObject/group-field-type.spec.ts", "chunked_list": ["import { Field } from \"payload/types\";\n\timport { buildCrowdinJsonObject, getLocalizedFields } from \"../..\";\n\timport {\n\t  basicNonLocalizedFields,\n\t  basicLocalizedFields,\n\t  emptyFieldDocValue,\n\t  fieldJsonCrowdinObject,\n\t  fieldDocValue,\n\t} from \"../../tests/fixtures/basic-localized-fields.fixture\";\n\tdescribe(\"fn: buildCrowdinJsonObject: group field type\", () => {\n", "  it(\"creates an empty JSON object if fields are empty\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: \"\",\n\t      groupField: emptyFieldDocValue,\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n", "      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"groupField\",\n\t        type: \"group\",\n\t        fields: basicLocalizedFields,\n\t      },\n", "    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n\t    const expected = {};\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n\t    );\n\t  });\n\t  it(\"includes localized fields nested in a group\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n", "      title: \"Test Policy created with title\",\n\t      groupField: fieldDocValue,\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n", "        localized: true,\n\t      },\n\t      {\n\t        name: \"groupField\",\n\t        type: \"group\",\n\t        fields: basicLocalizedFields,\n\t      },\n\t    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n\t    const expected = {\n", "      title: \"Test Policy created with title\",\n\t      groupField: fieldJsonCrowdinObject(),\n\t    };\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n\t    );\n\t  });\n\t  it(\"includes localized fields nested in a group with a localization setting on the group field\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n", "      title: \"Test Policy created with title\",\n\t      groupField: fieldDocValue,\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n", "        localized: true,\n\t      },\n\t      {\n\t        name: \"groupField\",\n\t        type: \"group\",\n\t        localized: true,\n\t        fields: basicNonLocalizedFields,\n\t      },\n\t    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n", "    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      groupField: fieldJsonCrowdinObject(),\n\t    };\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n\t    );\n\t  });\n\t  it(\"includes localized fields and meta @payloadcms/plugin-seo \", () => {\n\t    const doc = {\n", "      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      status: \"draft\",\n\t      meta: {\n\t        title: \"Meta title value\",\n\t        description: \"Meta description value.\\nCan contain new lines.\",\n\t      },\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n", "    const localizedFields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"meta\",\n\t        label: \"SEO\",\n\t        type: \"group\",\n", "        fields: [\n\t          {\n\t            name: \"title\",\n\t            type: \"text\",\n\t            localized: true,\n\t            admin: {\n\t              components: {},\n\t            },\n\t          },\n\t          {\n", "            name: \"description\",\n\t            type: \"textarea\",\n\t            localized: true,\n\t            admin: {\n\t              components: {},\n\t            },\n\t          },\n\t        ],\n\t      },\n\t    ];\n", "    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      meta: {\n\t        title: \"Meta title value\",\n\t        description: \"Meta description value.\\nCan contain new lines.\",\n\t      },\n\t    };\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n\t    );\n", "  });\n\t  it(\"includes localized fields nested in groups nested in a group\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      groupField: {\n\t        nestedGroupField: fieldDocValue,\n\t        secondNestedGroupField: fieldDocValue,\n\t      },\n\t      status: \"draft\",\n", "      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      {\n", "        name: \"groupField\",\n\t        type: \"group\",\n\t        fields: [\n\t          {\n\t            name: \"nestedGroupField\",\n\t            type: \"group\",\n\t            fields: basicLocalizedFields,\n\t          },\n\t          {\n\t            name: \"secondNestedGroupField\",\n", "            type: \"group\",\n\t            fields: basicLocalizedFields,\n\t          },\n\t        ],\n\t      },\n\t    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      groupField: {\n", "        nestedGroupField: fieldJsonCrowdinObject(),\n\t        secondNestedGroupField: fieldJsonCrowdinObject(),\n\t      },\n\t    };\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n\t    );\n\t  });\n\t  it(\"includes localized fields nested in groups nested in a group nested in a collapsible field\", () => {\n\t    const doc = {\n", "      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      groupField: {\n\t        nestedGroupField: fieldDocValue,\n\t        secondNestedGroupField: fieldDocValue,\n\t      },\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n", "    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      {\n\t        label: \"collapsibleField\",\n\t        type: \"collapsible\",\n\t        fields: [\n", "          {\n\t            name: \"groupField\",\n\t            type: \"group\",\n\t            fields: [\n\t              {\n\t                name: \"nestedGroupField\",\n\t                type: \"group\",\n\t                fields: basicLocalizedFields,\n\t              },\n\t              {\n", "                name: \"secondNestedGroupField\",\n\t                type: \"group\",\n\t                fields: basicLocalizedFields,\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n", "    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      groupField: {\n\t        nestedGroupField: fieldJsonCrowdinObject(),\n\t        secondNestedGroupField: fieldJsonCrowdinObject(),\n\t      },\n\t    };\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n\t    );\n", "  });\n\t  it(\"includes localized fields nested in groups nested in a group nested in a collapsible field with top-level localization settings\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      groupField: {\n\t        nestedGroupField: fieldDocValue,\n\t        secondNestedGroupField: fieldDocValue,\n\t      },\n\t      status: \"draft\",\n", "      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      {\n", "        label: \"collapsibleField\",\n\t        type: \"collapsible\",\n\t        fields: [\n\t          {\n\t            name: \"groupField\",\n\t            type: \"group\",\n\t            fields: [\n\t              {\n\t                name: \"nestedGroupField\",\n\t                type: \"group\",\n", "                localized: true,\n\t                fields: basicNonLocalizedFields,\n\t              },\n\t              {\n\t                name: \"secondNestedGroupField\",\n\t                type: \"group\",\n\t                localized: true,\n\t                fields: basicNonLocalizedFields,\n\t              },\n\t            ],\n", "          },\n\t        ],\n\t      },\n\t    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      groupField: {\n\t        nestedGroupField: fieldJsonCrowdinObject(),\n\t        secondNestedGroupField: fieldJsonCrowdinObject(),\n", "      },\n\t    };\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n\t    );\n\t  });\n\t});\n"]}
{"filename": "src/utilities/tests/buildJsonCrowdinObject/index.spec.ts", "chunked_list": ["import { CollectionConfig, Field } from \"payload/types\";\n\timport { buildCrowdinJsonObject, getLocalizedFields } from \"../..\";\n\timport { FieldWithName } from \"../../../types\";\n\tdescribe(\"fn: buildCrowdinJsonObject\", () => {\n\t  it(\"creates an empty object if no content exists\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n", "    const localizedFields: FieldWithName[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"anotherString\",\n\t        type: \"text\",\n\t        localized: true,\n", "      },\n\t    ];\n\t    const expected = {};\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n\t    );\n\t  });\n\t  it(\"does not include undefined localized fields\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n", "      title: \"Test Policy created with title\",\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const localizedFields: FieldWithName[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n", "      },\n\t      {\n\t        name: \"anotherString\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t    ];\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t    };\n", "    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n\t    );\n\t  });\n\t  it(\"includes localized fields\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: \"Text value\",\n\t      anotherString: \"Another text value\",\n\t      description: \"A textarea value.\\nWith a new line.\",\n", "      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const localizedFields: FieldWithName[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n", "      {\n\t        name: \"anotherString\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"description\",\n\t        type: \"textarea\",\n\t        localized: true,\n\t      },\n", "    ];\n\t    const expected = {\n\t      title: \"Text value\",\n\t      anotherString: \"Another text value\",\n\t      description: \"A textarea value.\\nWith a new line.\",\n\t    };\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n\t    );\n\t  });\n", "  it(\"includes localized fields within a collapsible field\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      arrayField: [\n\t        {\n\t          title: \"Array field title content one\",\n\t          text: \"Array field text content one\",\n\t          select: \"two\",\n\t          id: \"64735620230d57bce946d370\",\n", "        },\n\t        {\n\t          title: \"Array field title content two\",\n\t          text: \"Array field text content two\",\n\t          select: \"two\",\n\t          id: \"64735621230d57bce946d371\",\n\t        },\n\t      ],\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n", "      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n", "        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n\t        label: \"Array fields\",\n\t        type: \"collapsible\",\n\t        fields: [\n\t          {\n", "            name: \"arrayField\",\n\t            type: \"array\",\n\t            fields: [\n\t              {\n\t                name: \"title\",\n\t                type: \"text\",\n\t                localized: true,\n\t              },\n\t              {\n\t                name: \"text\",\n", "                type: \"text\",\n\t                localized: true,\n\t              },\n\t              {\n\t                name: \"select\",\n\t                type: \"select\",\n\t                localized: true,\n\t                options: [\"one\", \"two\"],\n\t              },\n\t            ],\n", "          },\n\t        ],\n\t      },\n\t    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      arrayField: {\n\t        \"64735620230d57bce946d370\": {\n\t          title: \"Array field title content one\",\n", "          text: \"Array field text content one\",\n\t        },\n\t        \"64735621230d57bce946d371\": {\n\t          title: \"Array field title content two\",\n\t          text: \"Array field text content two\",\n\t        },\n\t      },\n\t    };\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n", "    );\n\t  });\n\t});\n"]}
{"filename": "src/utilities/tests/buildJsonCrowdinObject/array-field-type.spec.ts", "chunked_list": ["import { CollectionConfig, Field } from \"payload/types\";\n\timport { buildCrowdinJsonObject, getLocalizedFields } from \"../..\";\n\timport { FieldWithName } from \"../../../types\";\n\tdescribe(\"fn: buildCrowdinJsonObject: array field type\", () => {\n\t  it(\"do not include non-localized fields nested in an array\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      arrayField: [\n\t        {\n", "          title: \"Array field title content one\",\n\t          text: \"Array field text content one\",\n\t          select: \"two\",\n\t          id: \"64735620230d57bce946d370\",\n\t        },\n\t        {\n\t          title: \"Array field title content two\",\n\t          text: \"Array field text content two\",\n\t          select: \"two\",\n\t          id: \"64735621230d57bce946d371\",\n", "        },\n\t      ],\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: FieldWithName[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n", "        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n", "        name: \"arrayField\",\n\t        type: \"array\",\n\t        fields: [\n\t          {\n\t            name: \"title\",\n\t            type: \"text\",\n\t          },\n\t          {\n\t            name: \"text\",\n\t            type: \"text\",\n", "          },\n\t          {\n\t            name: \"select\",\n\t            type: \"select\",\n\t            localized: true,\n\t            options: [\"one\", \"two\"],\n\t          },\n\t        ],\n\t      },\n\t    ];\n", "    const localizedFields = getLocalizedFields({ fields });\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t    };\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n\t    );\n\t  });\n\t  it(\"includes localized fields nested in an array\", () => {\n\t    const doc = {\n", "      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      arrayField: [\n\t        {\n\t          title: \"Array field title content one\",\n\t          text: \"Array field text content one\",\n\t          select: \"two\",\n\t          id: \"64735620230d57bce946d370\",\n\t        },\n\t        {\n", "          title: \"Array field title content two\",\n\t          text: \"Array field text content two\",\n\t          select: \"two\",\n\t          id: \"64735621230d57bce946d371\",\n\t        },\n\t      ],\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n", "    const fields: FieldWithName[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n", "        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n\t        name: \"arrayField\",\n\t        type: \"array\",\n\t        fields: [\n\t          {\n\t            name: \"title\",\n\t            type: \"text\",\n", "            localized: true,\n\t          },\n\t          {\n\t            name: \"text\",\n\t            type: \"text\",\n\t            localized: true,\n\t          },\n\t          {\n\t            name: \"select\",\n\t            type: \"select\",\n", "            localized: true,\n\t            options: [\"one\", \"two\"],\n\t          },\n\t        ],\n\t      },\n\t    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      arrayField: {\n", "        \"64735620230d57bce946d370\": {\n\t          title: \"Array field title content one\",\n\t          text: \"Array field text content one\",\n\t        },\n\t        \"64735621230d57bce946d371\": {\n\t          title: \"Array field title content two\",\n\t          text: \"Array field text content two\",\n\t        },\n\t      },\n\t    };\n", "    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n\t    );\n\t  });\n\t  it(\"includes localized fields nested in an array with a localization setting on the array field\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      arrayField: [\n\t        {\n", "          title: \"Array field title content one\",\n\t          text: \"Array field text content one\",\n\t          select: \"two\",\n\t          id: \"64735620230d57bce946d370\",\n\t        },\n\t        {\n\t          title: \"Array field title content two\",\n\t          text: \"Array field text content two\",\n\t          select: \"two\",\n\t          id: \"64735621230d57bce946d371\",\n", "        },\n\t      ],\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: FieldWithName[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n", "        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n", "        name: \"arrayField\",\n\t        type: \"array\",\n\t        localized: true,\n\t        fields: [\n\t          {\n\t            name: \"title\",\n\t            type: \"text\",\n\t          },\n\t          {\n\t            name: \"text\",\n", "            type: \"text\",\n\t          },\n\t          {\n\t            name: \"select\",\n\t            type: \"select\",\n\t            options: [\"one\", \"two\"],\n\t          },\n\t        ],\n\t      },\n\t    ];\n", "    const localizedFields = getLocalizedFields({ fields });\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      arrayField: {\n\t        \"64735620230d57bce946d370\": {\n\t          title: \"Array field title content one\",\n\t          text: \"Array field text content one\",\n\t        },\n\t        \"64735621230d57bce946d371\": {\n\t          title: \"Array field title content two\",\n", "          text: \"Array field text content two\",\n\t        },\n\t      },\n\t    };\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n\t    );\n\t  });\n\t  it(\"does not include localized fields richText fields nested in an array field in the `fields.json` file\", () => {\n\t    const doc = {\n", "      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      arrayField: [\n\t        {\n\t          content: [\n\t            {\n\t              children: [\n\t                {\n\t                  text: \"Test content 1\",\n\t                },\n", "              ],\n\t            },\n\t          ],\n\t          id: \"64735620230d57bce946d370\",\n\t        },\n\t        {\n\t          content: [\n\t            {\n\t              children: [\n\t                {\n", "                  text: \"Test content 1\",\n\t                },\n\t              ],\n\t            },\n\t          ],\n\t          id: \"64735621230d57bce946d371\",\n\t        },\n\t      ],\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n", "      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: FieldWithName[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n", "        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n\t        name: \"arrayField\",\n\t        type: \"array\",\n\t        localized: true,\n\t        fields: [\n", "          {\n\t            name: \"content\",\n\t            type: \"richText\",\n\t          },\n\t        ],\n\t      },\n\t    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n", "    };\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n\t    );\n\t  });\n\t});\n"]}
{"filename": "src/utilities/tests/buildJsonCrowdinObject/combined-field-types.spec.ts", "chunked_list": ["import { CollectionConfig, Field } from \"payload/types\";\n\timport { buildCrowdinJsonObject, getLocalizedFields } from \"../..\";\n\timport { FieldWithName } from \"../../../types\";\n\tdescribe(\"fn: buildCrowdinJsonObject: group nested in array\", () => {\n\t  const doc = {\n\t    id: \"6474a81bef389b66642035ff\",\n\t    title: \"Experience the magic of our product!\",\n\t    text: \"Get in touch with us or try it out yourself\",\n\t    ctas: [\n\t      {\n", "        link: {\n\t          text: \"Talk to us\",\n\t          href: \"#\",\n\t          type: \"ctaPrimary\",\n\t        },\n\t        id: \"6474a80221baea4f5f169757\",\n\t      },\n\t      {\n\t        link: {\n\t          text: \"Try for free\",\n", "          href: \"#\",\n\t          type: \"ctaSecondary\",\n\t        },\n\t        id: \"6474a81021baea4f5f169758\",\n\t      },\n\t    ],\n\t    createdAt: \"2023-05-29T13:26:51.734Z\",\n\t    updatedAt: \"2023-05-29T14:47:45.957Z\",\n\t    crowdinArticleDirectory: {\n\t      id: \"6474baaf73b854f4d464e38f\",\n", "      updatedAt: \"2023-05-29T14:46:07.000Z\",\n\t      createdAt: \"2023-05-29T14:46:07.000Z\",\n\t      name: \"6474a81bef389b66642035ff\",\n\t      crowdinCollectionDirectory: {\n\t        id: \"6474baaf73b854f4d464e38d\",\n\t        updatedAt: \"2023-05-29T14:46:07.000Z\",\n\t        createdAt: \"2023-05-29T14:46:07.000Z\",\n\t        name: \"promos\",\n\t        title: \"Promos\",\n\t        collectionSlug: \"promos\",\n", "        originalId: 1633,\n\t        projectId: 323731,\n\t        directoryId: 1169,\n\t      },\n\t      originalId: 1635,\n\t      projectId: 323731,\n\t      directoryId: 1633,\n\t    },\n\t  };\n\t  const linkField: Field = {\n", "    name: \"link\",\n\t    type: \"group\",\n\t    fields: [\n\t      {\n\t        name: \"text\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"href\",\n", "        type: \"text\",\n\t      },\n\t      {\n\t        name: \"type\",\n\t        type: \"select\",\n\t        options: [\"ctaPrimary\", \"ctaSecondary\"],\n\t      },\n\t    ],\n\t  };\n\t  const Promos: CollectionConfig = {\n", "    slug: \"promos\",\n\t    admin: {\n\t      defaultColumns: [\"title\", \"updatedAt\"],\n\t      useAsTitle: \"title\",\n\t      group: \"Shared\",\n\t    },\n\t    access: {\n\t      read: () => true,\n\t    },\n\t    fields: [\n", "      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      {\n\t        name: \"text\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n", "      {\n\t        name: \"ctas\",\n\t        type: \"array\",\n\t        minRows: 1,\n\t        maxRows: 2,\n\t        fields: [linkField],\n\t      },\n\t    ],\n\t  };\n\t  const expected: any = {\n", "    ctas: {\n\t      \"6474a80221baea4f5f169757\": {\n\t        link: {\n\t          text: \"Talk to us\",\n\t        },\n\t      },\n\t      \"6474a81021baea4f5f169758\": {\n\t        link: {\n\t          text: \"Try for free\",\n\t        },\n", "      },\n\t    },\n\t    text: \"Get in touch with us or try it out yourself\",\n\t    title: \"Experience the magic of our product!\",\n\t  };\n\t  it(\"includes group json fields nested inside of array field items\", () => {\n\t    expect(\n\t      buildCrowdinJsonObject({\n\t        doc,\n\t        fields: getLocalizedFields({ fields: Promos.fields, type: \"json\" }),\n", "      })\n\t    ).toEqual(expected);\n\t  });\n\t  it(\"includes group json fields nested inside of array field items even when getLocalizedFields is run twice\", () => {\n\t    expect(\n\t      buildCrowdinJsonObject({\n\t        doc,\n\t        fields: getLocalizedFields({\n\t          fields: getLocalizedFields({ fields: Promos.fields }),\n\t          type: \"json\",\n", "        }),\n\t      })\n\t    ).toEqual(expected);\n\t  });\n\t  /**\n\t   * afterChange builds a JSON object for the previous version of\n\t   * a document to compare with the current version. Ensure this\n\t   * function works in that scenario. Also important for dealing\n\t   * with non-required empty fields.\n\t   */\n", "  it(\"can work with an empty document\", () => {\n\t    expect(\n\t      buildCrowdinJsonObject({\n\t        doc: {},\n\t        fields: getLocalizedFields({ fields: Promos.fields }),\n\t      })\n\t    ).toEqual({});\n\t  });\n\t  it(\"can work with an empty array field\", () => {\n\t    expect(\n", "      buildCrowdinJsonObject({\n\t        doc: {\n\t          ...doc,\n\t          ctas: undefined,\n\t        },\n\t        fields: getLocalizedFields({ fields: Promos.fields }),\n\t      })\n\t    ).toEqual({\n\t      text: \"Get in touch with us or try it out yourself\",\n\t      title: \"Experience the magic of our product!\",\n", "    });\n\t  });\n\t  it(\"can work with an empty group field in an array\", () => {\n\t    expect(\n\t      buildCrowdinJsonObject({\n\t        doc: {\n\t          ...doc,\n\t          ctas: [{}, {}],\n\t        },\n\t        fields: getLocalizedFields({ fields: Promos.fields }),\n", "      })\n\t    ).toEqual({\n\t      text: \"Get in touch with us or try it out yourself\",\n\t      title: \"Experience the magic of our product!\",\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/utilities/tests/buildJsonCrowdinObject/blocks-field-type-fixture.spec.ts", "chunked_list": ["import { CollectionConfig, Field } from \"payload/types\";\n\timport { buildCrowdinJsonObject } from \"../..\";\n\timport {\n\t  field,\n\t  fieldJsonCrowdinObject,\n\t  fieldDocValue,\n\t} from \"../fixtures/blocks-field-type.fixture\";\n\tdescribe(\"fn: buildCrowdinHtmlObject: blocks field type\", () => {\n\t  it(\"includes localized fields\", () => {\n\t    const doc = {\n", "      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      blocksField: fieldDocValue,\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n", "        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n", "      field,\n\t    ];\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      ...fieldJsonCrowdinObject(),\n\t    };\n\t    expect(buildCrowdinJsonObject({ doc, fields })).toEqual(expected);\n\t  });\n\t  it(\"includes localized fields within a collapsible field\", () => {\n\t    const doc = {\n", "      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      blocksField: fieldDocValue,\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n", "        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n", "      {\n\t        label: \"Array fields\",\n\t        type: \"collapsible\",\n\t        fields: [field],\n\t      },\n\t    ];\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      ...fieldJsonCrowdinObject(),\n\t    };\n", "    expect(buildCrowdinJsonObject({ doc, fields })).toEqual(expected);\n\t  });\n\t  it(\"includes localized fields within an array field\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      arrayField: [\n\t        {\n\t          blocksField: fieldDocValue,\n\t          id: \"63ea4adb6ff825cddad3c1f2\",\n", "        },\n\t      ],\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: Field[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n", "        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n", "        name: \"arrayField\",\n\t        type: \"array\",\n\t        fields: [field],\n\t      },\n\t    ];\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      ...fieldJsonCrowdinObject(\"arrayField.63ea4adb6ff825cddad3c1f2\"),\n\t    };\n\t    expect(buildCrowdinJsonObject({ doc, fields })).toEqual(expected);\n", "  });\n\t});\n"]}
{"filename": "src/utilities/tests/buildJsonCrowdinObject/tabs-field-type.spec.ts", "chunked_list": ["import { CollectionConfig, Field } from \"payload/types\";\n\timport { buildCrowdinJsonObject, getLocalizedFields } from \"../..\";\n\timport { FieldWithName } from \"../../../types\";\n\timport {\n\t  basicNonLocalizedFields,\n\t  basicLocalizedFields,\n\t  emptyFieldDocValue,\n\t  fieldJsonCrowdinObject,\n\t  fieldDocValue,\n\t} from \"../../tests/fixtures/basic-localized-fields.fixture\";\n", "describe(\"fn: buildCrowdinJsonObject: group field type\", () => {\n\t  it(\"creates an empty JSON object if fields are empty\", () => {\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: \"\",\n\t      groupField: emptyFieldDocValue,\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n", "    const fields: Field[] = [\n\t      {\n\t        type: \"tabs\",\n\t        tabs: [\n\t          {\n\t            label: \"Tab 1\",\n\t            fields: [\n\t              {\n\t                name: \"title\",\n\t                type: \"text\",\n", "                localized: true,\n\t              },\n\t              // select not supported yet\n\t              {\n\t                name: \"select\",\n\t                type: \"select\",\n\t                localized: true,\n\t                options: [\"one\", \"two\"],\n\t              },\n\t            ],\n", "          },\n\t          {\n\t            label: \"Tab 2\",\n\t            fields: [\n\t              {\n\t                name: \"groupField\",\n\t                type: \"group\",\n\t                fields: [\n\t                  {\n\t                    name: \"title\",\n", "                    type: \"text\",\n\t                    localized: true,\n\t                  },\n\t                  {\n\t                    name: \"text\",\n\t                    type: \"text\",\n\t                    localized: true,\n\t                  },\n\t                  {\n\t                    name: \"description\",\n", "                    type: \"textarea\",\n\t                    localized: true,\n\t                  },\n\t                  // select not supported yet\n\t                  {\n\t                    name: \"select\",\n\t                    type: \"select\",\n\t                    localized: true,\n\t                    options: [\"one\", \"two\"],\n\t                  },\n", "                ],\n\t              },\n\t            ],\n\t          },\n\t        ],\n\t      },\n\t    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n\t    const expected = {};\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n", "      expected\n\t    );\n\t  });\n\t});\n"]}
{"filename": "src/utilities/tests/buildJsonCrowdinObject/blocks-field-type.spec.ts", "chunked_list": ["import { Block } from \"payload/types\";\n\timport { buildCrowdinJsonObject, getLocalizedFields } from \"../..\";\n\timport { FieldWithName } from \"../../../types\";\n\tconst TestBlockOne: Block = {\n\t  slug: \"testBlockOne\",\n\t  fields: [\n\t    {\n\t      name: \"title\",\n\t      type: \"text\",\n\t      localized: true,\n", "    },\n\t    {\n\t      name: \"text\",\n\t      type: \"text\",\n\t      localized: true,\n\t    },\n\t    {\n\t      name: \"select\",\n\t      type: \"select\",\n\t      localized: true,\n", "      options: [\"one\", \"two\"],\n\t    },\n\t  ],\n\t};\n\tconst TestBlockTwo: Block = {\n\t  slug: \"testBlockTwo\",\n\t  fields: [\n\t    {\n\t      name: \"url\",\n\t      type: \"text\",\n", "      localized: true,\n\t    },\n\t  ],\n\t};\n\tconst TestBlockTwoNonLocalized: Block = {\n\t  slug: \"testBlockTwo\",\n\t  fields: [\n\t    {\n\t      name: \"url\",\n\t      type: \"text\",\n", "    },\n\t  ],\n\t};\n\tdescribe(\"fn: buildCrowdinJsonObject: blocks field type\", () => {\n\t  it(\"includes localized fields nested in blocks\", () => {\n\t    const doc = {\n\t      title: \"Test Policy created with title\",\n\t      blocksField: [\n\t        {\n\t          title: \"Block field title content one\",\n", "          text: \"Block field text content one\",\n\t          select: \"two\",\n\t          id: \"64735620230d57bce946d370\",\n\t          blockType: \"testBlockOne\",\n\t        },\n\t        {\n\t          url: \"https://github.com/thompsonsj/payload-crowdin-sync\",\n\t          id: \"64735621230d57bce946d371\",\n\t          blockType: \"testBlockTwo\",\n\t        },\n", "      ],\n\t    };\n\t    const fields: FieldWithName[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n", "        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n\t        name: \"blocksField\",\n\t        type: \"blocks\",\n\t        blocks: [TestBlockOne, TestBlockTwo],\n\t      },\n", "    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      blocksField: {\n\t        \"64735620230d57bce946d370\": {\n\t          testBlockOne: {\n\t            title: \"Block field title content one\",\n\t            text: \"Block field text content one\",\n\t          },\n", "        },\n\t        \"64735621230d57bce946d371\": {\n\t          testBlockTwo: {\n\t            url: \"https://github.com/thompsonsj/payload-crowdin-sync\",\n\t          },\n\t        },\n\t      },\n\t    };\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n", "    );\n\t  });\n\t  it(\"excludes block with no localized fields\", () => {\n\t    const doc = {\n\t      title: \"Test Policy created with title\",\n\t      blocksField: [\n\t        {\n\t          title: \"Block field title content one\",\n\t          text: \"Block field text content one\",\n\t          select: \"two\",\n", "          id: \"64735620230d57bce946d370\",\n\t          blockType: \"testBlockOne\",\n\t        },\n\t        {\n\t          url: \"https://github.com/thompsonsj/payload-crowdin-sync\",\n\t          id: \"64735621230d57bce946d371\",\n\t          blockType: \"testBlockTwo\",\n\t        },\n\t      ],\n\t    };\n", "    const fields: FieldWithName[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n", "        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n\t        name: \"blocksField\",\n\t        type: \"blocks\",\n\t        blocks: [TestBlockOne, TestBlockTwoNonLocalized],\n\t      },\n\t    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n", "    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      blocksField: {\n\t        \"64735620230d57bce946d370\": {\n\t          testBlockOne: {\n\t            title: \"Block field title content one\",\n\t            text: \"Block field text content one\",\n\t          },\n\t        },\n\t      },\n", "    };\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n\t    );\n\t  });\n\t  it(\"excludes block with no localized fields - more blocks\", () => {\n\t    const doc = {\n\t      title: \"Test Policy created with title\",\n\t      blocksField: [\n\t        {\n", "          title: \"Block field title content one\",\n\t          text: \"Block field text content one\",\n\t          select: \"two\",\n\t          id: \"64735620230d57bce946d370\",\n\t          blockType: \"testBlockOne\",\n\t        },\n\t        {\n\t          url: \"https://github.com/thompsonsj/payload-crowdin-sync\",\n\t          id: \"64735621230d57bce946d371\",\n\t          blockType: \"testBlockTwo\",\n", "        },\n\t        {\n\t          title: \"Block field title content two\",\n\t          text: \"Block field text content two\",\n\t          select: \"two\",\n\t          id: \"64a535cdf1eaa5498709c906\",\n\t          blockType: \"testBlockOne\",\n\t        },\n\t      ],\n\t    };\n", "    const fields: FieldWithName[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n", "        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n\t        name: \"blocksField\",\n\t        type: \"blocks\",\n\t        blocks: [TestBlockOne, TestBlockTwoNonLocalized],\n\t      },\n\t    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n", "    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      blocksField: {\n\t        \"64735620230d57bce946d370\": {\n\t          testBlockOne: {\n\t            title: \"Block field title content one\",\n\t            text: \"Block field text content one\",\n\t          },\n\t        },\n\t        \"64a535cdf1eaa5498709c906\": {\n", "          testBlockOne: {\n\t            title: \"Block field title content two\",\n\t            text: \"Block field text content two\",\n\t          },\n\t        },\n\t      },\n\t    };\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n\t      expected\n\t    );\n", "  });\n\t  it(\"does not include localized fields richText fields nested in an array field within a block in the `fields.json` file\", () => {\n\t    const TestBlockArrayOfRichText: Block = {\n\t      slug: \"testBlockArrayOfRichText\",\n\t      fields: [\n\t        {\n\t          name: \"arrayField\",\n\t          type: \"array\",\n\t          fields: [\n\t            {\n", "              name: \"richText\",\n\t              type: \"richText\",\n\t              localized: true,\n\t            },\n\t          ],\n\t        },\n\t      ],\n\t    };\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n", "      title: \"Test Policy created with title\",\n\t      blocksField: [\n\t        {\n\t          arrayField: [\n\t            {\n\t              content: [\n\t                {\n\t                  children: [\n\t                    {\n\t                      text: \"Test content 1\",\n", "                    },\n\t                  ],\n\t                },\n\t              ],\n\t              id: \"64735620230d57bce946d370\",\n\t            },\n\t            {\n\t              content: [\n\t                {\n\t                  children: [\n", "                    {\n\t                      text: \"Test content 1\",\n\t                    },\n\t                  ],\n\t                },\n\t              ],\n\t              id: \"64735621230d57bce946d371\",\n\t            },\n\t          ],\n\t          blockType: \"testBlockArrayOfRichText\",\n", "        },\n\t      ],\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n\t      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: FieldWithName[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n", "        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n\t        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n", "        name: \"blocksField\",\n\t        type: \"blocks\",\n\t        blocks: [TestBlockArrayOfRichText],\n\t      },\n\t    ];\n\t    const localizedFields = getLocalizedFields({ fields, type: \"json\" });\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t    };\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n", "      expected\n\t    );\n\t  });\n\t  it(\"does not include localized fields richText fields nested in an array field within a block in the `fields.json` file 2\", () => {\n\t    const TestBlockArrayOfRichText: Block = {\n\t      slug: \"testBlockArrayOfRichText\",\n\t      fields: [\n\t        {\n\t          name: \"title\",\n\t          type: \"text\",\n", "          localized: true,\n\t        },\n\t        {\n\t          name: \"messages\",\n\t          type: \"array\",\n\t          localized: true,\n\t          maxRows: 3,\n\t          fields: [\n\t            {\n\t              name: \"title\",\n", "              type: \"text\",\n\t              localized: true,\n\t            },\n\t            {\n\t              name: \"message\",\n\t              type: \"richText\",\n\t            },\n\t          ],\n\t        },\n\t      ],\n", "    };\n\t    const doc = {\n\t      id: \"638641358b1a140462752076\",\n\t      title: \"Test Policy created with title\",\n\t      blocksField: [\n\t        {\n\t          messages: [\n\t            {\n\t              title: \"Test title 1\",\n\t              message: [\n", "                {\n\t                  children: [\n\t                    {\n\t                      text: \"Test content 1\",\n\t                    },\n\t                  ],\n\t                },\n\t              ],\n\t              id: \"64735620230d57bce946d370\",\n\t            },\n", "            {\n\t              title: \"Test title 2\",\n\t              message: [\n\t                {\n\t                  children: [\n\t                    {\n\t                      text: \"Test content 1\",\n\t                    },\n\t                  ],\n\t                },\n", "              ],\n\t              id: \"64735621230d57bce946d371\",\n\t            },\n\t          ],\n\t          id: \"649cd1ecbac7445191be36af\",\n\t          blockType: \"testBlockArrayOfRichText\",\n\t        },\n\t      ],\n\t      status: \"draft\",\n\t      createdAt: \"2022-11-29T17:28:21.644Z\",\n", "      updatedAt: \"2022-11-29T17:28:21.644Z\",\n\t    };\n\t    const fields: FieldWithName[] = [\n\t      {\n\t        name: \"title\",\n\t        type: \"text\",\n\t        localized: true,\n\t      },\n\t      // select not supported yet\n\t      {\n", "        name: \"select\",\n\t        type: \"select\",\n\t        localized: true,\n\t        options: [\"one\", \"two\"],\n\t      },\n\t      {\n\t        name: \"blocksField\",\n\t        type: \"blocks\",\n\t        blocks: [TestBlockArrayOfRichText],\n\t      },\n", "    ];\n\t    const localizedFields = getLocalizedFields({ fields });\n\t    const expected = {\n\t      title: \"Test Policy created with title\",\n\t      blocksField: {\n\t        \"649cd1ecbac7445191be36af\": {\n\t          testBlockArrayOfRichText: {\n\t            messages: {\n\t              \"64735620230d57bce946d370\": {\n\t                title: \"Test title 1\",\n", "              },\n\t              \"64735621230d57bce946d371\": {\n\t                title: \"Test title 2\",\n\t              },\n\t            },\n\t          },\n\t        },\n\t      },\n\t    };\n\t    expect(buildCrowdinJsonObject({ doc, fields: localizedFields })).toEqual(\n", "      expected\n\t    );\n\t  });\n\t});\n"]}
