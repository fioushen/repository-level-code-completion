{"filename": "src/index.ts", "chunked_list": ["export * from './lib/parameterizer.js';\n\texport * from './lib/parameterized-query.js';\n\texport * from './lib/parameterized-value.js';\n"]}
{"filename": "src/utils/test-setup.ts", "chunked_list": ["import Sqlite3 from 'better-sqlite3';\n\timport { Kysely, SqliteDialect } from 'kysely';\n\timport { Database, createTables, dropTables } from './test-tables.js';\n\texport async function createDB() {\n\t  return new Kysely<Database>({\n\t    dialect: new SqliteDialect({\n\t      database: new Sqlite3(':memory:'),\n\t    }),\n\t  });\n\t}\n", "export async function resetDB(db: Kysely<Database>) {\n\t  await dropTables(db);\n\t  await createTables(db);\n\t}\n\texport async function destroyDB<DB>(db: Kysely<DB>) {\n\t  return db.destroy();\n\t}\n"]}
{"filename": "src/utils/test-utils.ts", "chunked_list": ["/**\n\t * Embeds code that will never run within a callback. Useful for\n\t * testing expected type errors.\n\t * @param description Description of the code that will never run\n\t * @param callback Callback that will never run\n\t */\n\texport function ignore(_description: string, _: () => void) {}\n"]}
{"filename": "src/utils/test-tables.ts", "chunked_list": ["import { Kysely, Generated } from 'kysely';\n\t// list tables after those they depend on\n\tconst TABLE_NAMES = ['users'];\n\texport interface Database {\n\t  users: Users;\n\t}\n\texport interface Users {\n\t  id: Generated<number>;\n\t  handle: string;\n\t  name: string;\n", "  nickname: string | null;\n\t  birthYear: number | null;\n\t}\n\texport async function createTables(db: Kysely<Database>) {\n\t  await db.schema\n\t    .createTable('users')\n\t    .addColumn('id', 'integer', (col) => col.autoIncrement().primaryKey())\n\t    .addColumn('handle', 'varchar(255)', (col) => col.notNull())\n\t    .addColumn('name', 'varchar(255)', (col) => col.notNull())\n\t    .addColumn('nickname', 'varchar(255)')\n", "    .addColumn('birthYear', 'integer')\n\t    .execute();\n\t  return db;\n\t}\n\texport async function dropTables(db: Kysely<Database>): Promise<void> {\n\t  for (const table of TABLE_NAMES) {\n\t    await db.schema.dropTable(table).ifExists().execute();\n\t  }\n\t}\n"]}
{"filename": "src/tests/delete-params.test.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\timport { createDB, resetDB, destroyDB } from '../utils/test-setup';\n\timport { Database } from '../utils/test-tables';\n\timport { ignore } from '../utils/test-utils';\n\timport { parameterizeQuery } from '../lib/parameterizer';\n\tlet db: Kysely<Database>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n\t});\n\tbeforeEach(() => resetDB(db));\n", "afterAll(() => destroyDB(db));\n\tconst user1 = {\n\t  name: 'John Smith',\n\t  nickname: 'Johnny',\n\t  handle: 'jsmith',\n\t  birthYear: 1980,\n\t};\n\tconst user2 = {\n\t  name: 'John McSmith',\n\t  nickname: 'Johnny',\n", "  handle: 'jmsmith',\n\t  birthYear: 1990,\n\t};\n\tconst user3 = {\n\t  name: 'Jane Doe',\n\t  nickname: 'Jane',\n\t  handle: 'jdoe',\n\t  birthYear: 1990,\n\t};\n\tit('instantiates deletions, with multiple executions', async () => {\n", "  interface Params {\n\t    targetNickname: string;\n\t    targetBirthYear: number;\n\t  }\n\t  await db.insertInto('users').values([user1, user2, user3]).execute();\n\t  const parameterization = parameterizeQuery(\n\t    db.deleteFrom('users')\n\t  ).asFollows<Params>(({ qb, param }) =>\n\t    qb\n\t      .where('nickname', '=', param('targetNickname'))\n", "      .where('birthYear', '=', param('targetBirthYear'))\n\t  );\n\t  // First execution\n\t  const compiledQuery1 = parameterization.instantiate({\n\t    targetNickname: user2.nickname,\n\t    targetBirthYear: user2.birthYear,\n\t  });\n\t  const result1 = await db.executeQuery(compiledQuery1);\n\t  expect(Number(result1?.numAffectedRows)).toEqual(1);\n\t  // Second execution\n", "  const compiledQuery2 = parameterization.instantiate({\n\t    targetNickname: user3.nickname,\n\t    targetBirthYear: user3.birthYear,\n\t  });\n\t  const result2 = await db.executeQuery(compiledQuery2);\n\t  expect(Number(result2?.numAffectedRows)).toEqual(1);\n\t  // Verify that the correct rows were deleted\n\t  const results = await db.selectFrom('users').selectAll().execute();\n\t  expect(results).toEqual([{ ...user1, id: 1 }]);\n\t});\n", "it('parameterizes deletions, with multiple executions', async () => {\n\t  interface Params {\n\t    targetNickname: string;\n\t    targetBirthYear: number;\n\t  }\n\t  await db.insertInto('users').values([user1, user2, user3]).execute();\n\t  // First execution\n\t  const parameterization = parameterizeQuery(\n\t    db.deleteFrom('users')\n\t  ).asFollows<Params>(({ qb, param }) =>\n", "    qb\n\t      .where('nickname', '=', param('targetNickname'))\n\t      .where('birthYear', '=', param('targetBirthYear'))\n\t  );\n\t  const result1 = await parameterization.execute(db, {\n\t    targetNickname: user2.nickname,\n\t    targetBirthYear: user2.birthYear,\n\t  });\n\t  expect(Number(result1?.numAffectedRows)).toEqual(1);\n\t  // Second execution\n", "  const result2 = await parameterization.execute(db, {\n\t    targetNickname: user3.nickname,\n\t    targetBirthYear: user3.birthYear,\n\t  });\n\t  expect(Number(result2?.numAffectedRows)).toEqual(1);\n\t  // Verify that the correct rows were deleted\n\t  const results = await db.selectFrom('users').selectAll().execute();\n\t  expect(results).toEqual([{ ...user1, id: 1 }]);\n\t});\n\tit('parameterizes deletions using \"in\" operator', async () => {\n", "  interface Params {\n\t    targetNickname: string;\n\t    targetBirthYear1: number;\n\t    targetBirthYear2: number;\n\t  }\n\t  await db.insertInto('users').values([user1, user2, user3]).execute();\n\t  const parameterization = parameterizeQuery(\n\t    db.deleteFrom('users')\n\t  ).asFollows<Params>(({ qb, param }) =>\n\t    qb\n", "      .where('nickname', '=', param('targetNickname'))\n\t      .where('birthYear', 'in', [\n\t        param('targetBirthYear1'),\n\t        param('targetBirthYear2'),\n\t      ])\n\t  );\n\t  const results = await parameterization.execute(db, {\n\t    targetNickname: user2.nickname,\n\t    targetBirthYear1: 1980,\n\t    targetBirthYear2: 1990,\n", "  });\n\t  expect(Number(results?.numAffectedRows)).toEqual(2);\n\t  const users = await db.selectFrom('users').selectAll().execute();\n\t  expect(users).toEqual([{ ...user3, id: 3 }]);\n\t});\n\tit('parameterizes without defined parameters', async () => {\n\t  await db.insertInto('users').values([user1, user2, user3]).execute();\n\t  const parameterization = parameterizeQuery(db.deleteFrom('users')).asFollows(\n\t    ({ qb }) => qb.where('birthYear', '=', 1990)\n\t  );\n", "  const results = await parameterization.execute(db, {});\n\t  expect(Number(results?.numAffectedRows)).toEqual(2);\n\t  const users = await db.selectFrom('users').selectAll().execute();\n\t  expect(users).toEqual([{ ...user1, id: 1 }]);\n\t});\n\tignore('array parameters are not allowed', () => {\n\t  interface InvalidParams {\n\t    targetBirthYears: number[];\n\t  }\n\t  // @ts-expect-error - invalid parameter type\n", "  parameterizeQuery(db.deleteFrom('users')).asFollows<InvalidParams>(\n\t    ({ qb, param }) => qb.where('birthYear', 'in', param('targetBirthYears'))\n\t  );\n\t});\n\tignore('disallows incompatible parameter types', () => {\n\t  interface InvalidParams {\n\t    targetHandle: number;\n\t  }\n\t  parameterizeQuery(db.deleteFrom('users')).asFollows<InvalidParams>(\n\t    // @ts-expect-error - invalid parameter type\n", "    ({ qb, param }) => qb.where('handle', '=', param('targetHandle'))\n\t  );\n\t});\n\tignore('restricts provided parameters', async () => {\n\t  interface ValidParams {\n\t    targetHandle: string;\n\t    targetBirthYear: number;\n\t  }\n\t  const parameterization = parameterizeQuery(\n\t    db.deleteFrom('users')\n", "  ).asFollows<ValidParams>(({ qb, param }) =>\n\t    qb\n\t      .where('handle', '=', param('targetHandle'))\n\t      .where('name', '=', 'John Smith')\n\t      .where('birthYear', '=', param('targetBirthYear'))\n\t  );\n\t  await parameterization.execute(db, {\n\t    //@ts-expect-error - invalid parameter name\n\t    invalidParam: 'invalid',\n\t  });\n", "  await parameterization.executeTakeFirst(db, {\n\t    //@ts-expect-error - invalid parameter name\n\t    invalidParam: 'invalid',\n\t  });\n\t  await parameterization.execute(db, {\n\t    //@ts-expect-error - invalid parameter type\n\t    targetBirthYear: '2020',\n\t    targetHandle: 'jsmith',\n\t  });\n\t  await parameterization.executeTakeFirst(db, {\n", "    //@ts-expect-error - invalid parameter type\n\t    targetBirthYear: '2020',\n\t    targetHandle: 'jsmith',\n\t  });\n\t  await parameterization.execute(db, {\n\t    //@ts-expect-error - invalid parameter type\n\t    targetHandle: null,\n\t  });\n\t  await parameterization.executeTakeFirst(db, {\n\t    //@ts-expect-error - invalid parameter type\n", "    targetHandle: null,\n\t  });\n\t  //@ts-expect-error - missing parameter name\n\t  await parameterization.execute(db, {\n\t    targetBirthYear: 2020,\n\t  });\n\t  //@ts-expect-error - missing parameter name\n\t  await parameterization.executeTakeFirst(db, {\n\t    targetBirthYear: 2020,\n\t  });\n", "  //@ts-expect-error - missing parameter name\n\t  await parameterization.execute(db, {});\n\t  //@ts-expect-error - missing parameter name\n\t  await parameterization.executeTakeFirst(db, {});\n\t});\n"]}
{"filename": "src/tests/update-params.test.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\timport { createDB, resetDB, destroyDB } from '../utils/test-setup';\n\timport { Database } from '../utils/test-tables';\n\timport { ignore } from '../utils/test-utils';\n\timport { parameterizeQuery } from '../lib/parameterizer';\n\tlet db: Kysely<Database>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n\t});\n\tbeforeEach(() => resetDB(db));\n", "afterAll(() => destroyDB(db));\n\tconst user1 = {\n\t  name: 'John Smith',\n\t  nickname: 'Johnny',\n\t  handle: 'jsmith',\n\t  birthYear: 1980,\n\t};\n\tconst user2 = {\n\t  name: 'John McSmith',\n\t  nickname: 'Johnny',\n", "  handle: 'jmsmith',\n\t  birthYear: 1990,\n\t};\n\tconst user3 = {\n\t  name: 'Jane Doe',\n\t  nickname: 'Jane',\n\t  handle: 'jdoe',\n\t  birthYear: 1990,\n\t};\n\tit(\"instantiates update values and 'where' selections, with multiple executions\", async () => {\n", "  interface Params {\n\t    toBirthYear: number;\n\t    whereNickname: string;\n\t  }\n\t  await db.insertInto('users').values([user1, user2, user3]).execute();\n\t  const parameterization = parameterizeQuery(\n\t    db.updateTable('users')\n\t  ).asFollows<Params>(({ qb, param }) =>\n\t    qb\n\t      .set({\n", "        birthYear: param('toBirthYear'),\n\t        handle: 'newHandle',\n\t      })\n\t      .where('nickname', '=', param('whereNickname'))\n\t  );\n\t  // First execution\n\t  const compiledQuery1 = parameterization.instantiate({\n\t    toBirthYear: 2000,\n\t    whereNickname: user2.nickname,\n\t  });\n", "  const result1 = await db.executeQuery(compiledQuery1);\n\t  expect(Number(result1?.numAffectedRows)).toEqual(2);\n\t  // Second execution\n\t  const compiledQuery2 = parameterization.instantiate({\n\t    toBirthYear: 2010,\n\t    whereNickname: user3.nickname,\n\t  });\n\t  const result2 = await db.executeQuery(compiledQuery2);\n\t  expect(Number(result2?.numAffectedRows)).toEqual(1);\n\t  const users = await db.selectFrom('users').selectAll().execute();\n", "  expect(users).toEqual([\n\t    { ...user1, id: 1, handle: 'newHandle', birthYear: 2000 },\n\t    { ...user2, id: 2, handle: 'newHandle', birthYear: 2000 },\n\t    { ...user3, id: 3, handle: 'newHandle', birthYear: 2010 },\n\t  ]);\n\t});\n\tit(\"parameterizes update values and 'where' selections, with multiple executions\", async () => {\n\t  interface Params {\n\t    toBirthYear: number;\n\t    whereNickname: string;\n", "  }\n\t  await db.insertInto('users').values([user1, user2, user3]).execute();\n\t  // First execution\n\t  const parameterization = parameterizeQuery(\n\t    db.updateTable('users')\n\t  ).asFollows<Params>(({ qb, param }) =>\n\t    qb\n\t      .set({\n\t        birthYear: param('toBirthYear'),\n\t        handle: 'newHandle',\n", "      })\n\t      .where('nickname', '=', param('whereNickname'))\n\t  );\n\t  const result1 = await parameterization.execute(db, {\n\t    toBirthYear: 2000,\n\t    whereNickname: user2.nickname,\n\t  });\n\t  expect(Number(result1.numAffectedRows)).toEqual(2);\n\t  // Second execution\n\t  const result2 = await parameterization.executeTakeFirst(db, {\n", "    toBirthYear: 2010,\n\t    whereNickname: user3.nickname,\n\t  });\n\t  expect(result2).toBeUndefined();\n\t  const users = await db.selectFrom('users').selectAll().execute();\n\t  expect(users).toEqual([\n\t    { ...user1, id: 1, handle: 'newHandle', birthYear: 2000 },\n\t    { ...user2, id: 2, handle: 'newHandle', birthYear: 2000 },\n\t    { ...user3, id: 3, handle: 'newHandle', birthYear: 2010 },\n\t  ]);\n", "});\n\tit('parameterizes update values accepting nulls', async () => {\n\t  interface Params {\n\t    toBirthYear: number | null;\n\t    whereNickname: string;\n\t  }\n\t  await db.insertInto('users').values([user1, user2, user3]).execute();\n\t  const parameterization = parameterizeQuery(\n\t    db.updateTable('users')\n\t  ).asFollows<Params>(({ qb, param }) =>\n", "    qb\n\t      .set({\n\t        birthYear: param('toBirthYear'),\n\t      })\n\t      .where('nickname', '=', param('whereNickname'))\n\t  );\n\t  const result1 = await parameterization.execute(db, {\n\t    toBirthYear: null,\n\t    whereNickname: user2.nickname,\n\t  });\n", "  expect(Number(result1.numAffectedRows)).toEqual(2);\n\t  const result2 = await parameterization.executeTakeFirst(db, {\n\t    toBirthYear: 2010,\n\t    whereNickname: user3.nickname,\n\t  });\n\t  expect(result2).toBeUndefined();\n\t  const users = await db.selectFrom('users').selectAll().execute();\n\t  expect(users).toEqual([\n\t    { ...user1, id: 1, birthYear: null },\n\t    { ...user2, id: 2, birthYear: null },\n", "    { ...user3, id: 3, birthYear: 2010 },\n\t  ]);\n\t});\n\tit('parameterizes without defined parameters', async () => {\n\t  await db.insertInto('users').values([user1, user2, user3]).execute();\n\t  const parameterization = parameterizeQuery(db.updateTable('users')).asFollows(\n\t    ({ qb }) =>\n\t      qb\n\t        .set({\n\t          birthYear: 2000,\n", "          handle: 'newHandle',\n\t        })\n\t        .where('nickname', '=', 'Johnny')\n\t  );\n\t  const result1 = await parameterization.execute(db, {});\n\t  expect(Number(result1.numAffectedRows)).toEqual(2);\n\t  const users = await db.selectFrom('users').selectAll().execute();\n\t  expect(users).toEqual([\n\t    { ...user1, id: 1, handle: 'newHandle', birthYear: 2000 },\n\t    { ...user2, id: 2, handle: 'newHandle', birthYear: 2000 },\n", "    { ...user3, id: 3, handle: 'jdoe', birthYear: 1990 },\n\t  ]);\n\t});\n\tignore('disallows incompatible set parameter types', () => {\n\t  interface InvalidParams {\n\t    sourceHandle: number;\n\t    sourceName: string | null;\n\t  }\n\t  parameterizeQuery(db.updateTable('users')).asFollows<InvalidParams>(\n\t    ({ qb, param }) =>\n", "      qb.set({\n\t        //@ts-expect-error - invalid parameter type\n\t        handle: param('sourceHandle'),\n\t        name: 'John Smith',\n\t      })\n\t  );\n\t  parameterizeQuery(db.updateTable('users')).asFollows<InvalidParams>(\n\t    ({ qb, param }) =>\n\t      qb.set({\n\t        handle: 'jsmith',\n", "        //@ts-expect-error - invalid parameter type\n\t        name: param('sourceName'),\n\t      })\n\t  );\n\t});\n\tignore('restricts a set generated column parameter', async () => {\n\t  interface InvalidParams {\n\t    sourceId?: string;\n\t  }\n\t  parameterizeQuery(db.insertInto('users')).asFollows<InvalidParams>(\n", "    ({ qb, param }) =>\n\t      qb.values({\n\t        //@ts-expect-error - invalid parameter type\n\t        id: param('sourceId'),\n\t        name: 'John Smith',\n\t        handle: 'jsmith',\n\t      })\n\t  );\n\t});\n\tignore('array parameters are not allowed', () => {\n", "  interface InvalidParams {\n\t    targetBirthYears: number[];\n\t  }\n\t  parameterizeQuery(db.updateTable('users'))\n\t    // @ts-expect-error - invalid parameter type\n\t    .asFollows<InvalidParams>(({ qb, param }) =>\n\t      qb\n\t        .set({ nickname: 'newNickname' })\n\t        .where('birthYear', 'in', param('targetBirthYears'))\n\t    );\n", "});\n\tignore('disallows incompatible parameter types', () => {\n\t  interface InvalidParams {\n\t    targetHandle: number;\n\t  }\n\t  parameterizeQuery(db.updateTable('users')).asFollows<InvalidParams>(\n\t    ({ qb, param }) =>\n\t      qb\n\t        .set({ nickname: 'newNickname' })\n\t        //@ts-expect-error - invalid parameter type\n", "        .where('handle', '=', param('targetHandle'))\n\t  );\n\t});\n\tignore('restricts provided parameters', async () => {\n\t  interface ValidParams {\n\t    targetHandle: string;\n\t    targetBirthYear: number;\n\t  }\n\t  const parameterization = parameterizeQuery(\n\t    db.updateTable('users')\n", "  ).asFollows<ValidParams>(({ qb, param }) =>\n\t    qb\n\t      .set({ nickname: 'newNickname' })\n\t      .where('handle', '=', param('targetHandle'))\n\t      .where('name', '=', 'John Smith')\n\t      .where('birthYear', '=', param('targetBirthYear'))\n\t  );\n\t  await parameterization.execute(db, {\n\t    //@ts-expect-error - invalid parameter name\n\t    invalidParam: 'invalid',\n", "  });\n\t  await parameterization.executeTakeFirst(db, {\n\t    //@ts-expect-error - invalid parameter name\n\t    invalidParam: 'invalid',\n\t  });\n\t  await parameterization.execute(db, {\n\t    //@ts-expect-error - invalid parameter type\n\t    targetBirthYear: '2020',\n\t    targetHandle: 'jsmith',\n\t  });\n", "  await parameterization.executeTakeFirst(db, {\n\t    //@ts-expect-error - invalid parameter type\n\t    targetBirthYear: '2020',\n\t    targetHandle: 'jsmith',\n\t  });\n\t  await parameterization.execute(db, {\n\t    //@ts-expect-error - invalid parameter type\n\t    targetHandle: null,\n\t  });\n\t  await parameterization.executeTakeFirst(db, {\n", "    //@ts-expect-error - invalid parameter type\n\t    targetHandle: null,\n\t  });\n\t  //@ts-expect-error - missing parameter name\n\t  await parameterization.execute(db, {\n\t    targetBirthYear: 2020,\n\t  });\n\t  //@ts-expect-error - missing parameter name\n\t  await parameterization.executeTakeFirst(db, {\n\t    targetBirthYear: 2020,\n", "  });\n\t  //@ts-expect-error - missing parameter name\n\t  await parameterization.execute(db, {});\n\t  //@ts-expect-error - missing parameter name\n\t  await parameterization.executeTakeFirst(db, {});\n\t});\n"]}
{"filename": "src/tests/select-params.test.ts", "chunked_list": ["import { Kysely, sql } from 'kysely';\n\timport { createDB, resetDB, destroyDB } from '../utils/test-setup';\n\timport { Database } from '../utils/test-tables';\n\timport { ignore } from '../utils/test-utils';\n\timport { parameterizeQuery } from '../lib/parameterizer';\n\tlet db: Kysely<Database>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n\t});\n\tbeforeEach(() => resetDB(db));\n", "afterAll(() => destroyDB(db));\n\tconst user1 = {\n\t  name: 'John Smith',\n\t  nickname: 'Johnny',\n\t  handle: 'jsmith',\n\t  birthYear: 1980,\n\t};\n\tconst user2 = {\n\t  name: 'John McSmith',\n\t  nickname: 'Johnny',\n", "  handle: 'jmsmith',\n\t  birthYear: 1990,\n\t};\n\tconst user3 = {\n\t  name: 'Jane Doe',\n\t  // leave out nickname\n\t  handle: 'jdoe',\n\t  birthYear: 1990,\n\t};\n\tit('instantiates \"where\" selections, with multiple executions', async () => {\n", "  interface Params {\n\t    targetNickname: string;\n\t    targetBirthYear: number;\n\t  }\n\t  await db.insertInto('users').values([user1, user2, user3]).execute();\n\t  const parameterization = parameterizeQuery(\n\t    db.selectFrom('users').selectAll()\n\t  ).asFollows<Params>(({ qb, param }) =>\n\t    qb\n\t      .where('nickname', '=', param('targetNickname'))\n", "      .where('birthYear', '=', param('targetBirthYear'))\n\t  );\n\t  // First execution\n\t  const compiledQuery1 = parameterization.instantiate({\n\t    targetNickname: user2.nickname,\n\t    targetBirthYear: user2.birthYear,\n\t  });\n\t  const result1 = await db.executeQuery(compiledQuery1);\n\t  expect(result1?.rows).toEqual([{ ...user2, id: 2 }]);\n\t  // Second execution\n", "  const compiledQuery2 = parameterization.instantiate({\n\t    targetNickname: user2.nickname,\n\t    targetBirthYear: 1980,\n\t  });\n\t  const result2 = await db.executeQuery(compiledQuery2);\n\t  expect(result2?.rows).toEqual([{ ...user1, id: 1 }]);\n\t  // Allows constant parameters\n\t  const params = {\n\t    targetNickname: 'Jane' as const,\n\t    targetBirthYear: 1990 as const,\n", "  } as const;\n\t  parameterization.instantiate(params);\n\t});\n\tit('parameterizes \"where\" selections, with multiple executions', async () => {\n\t  interface Params {\n\t    targetNickname: string;\n\t    targetBirthYear: number;\n\t  }\n\t  await db.insertInto('users').values([user1, user2, user3]).execute();\n\t  // First execution\n", "  const parameterization = parameterizeQuery(\n\t    db.selectFrom('users').selectAll()\n\t  ).asFollows<Params>(({ qb, param }) =>\n\t    qb\n\t      .where('nickname', '=', param('targetNickname'))\n\t      .where('birthYear', '=', param('targetBirthYear'))\n\t  );\n\t  const result1 = await parameterization.executeTakeFirst(db, {\n\t    targetNickname: user2.nickname,\n\t    targetBirthYear: user2.birthYear,\n", "  });\n\t  expect(result1).toEqual({ ...user2, id: 2 });\n\t  // Make sure we can address properties by name.\n\t  expect(result1?.name).toEqual(user2.name);\n\t  // Second execution\n\t  const result2 = await parameterization.executeTakeFirst(db, {\n\t    targetNickname: user2.nickname,\n\t    targetBirthYear: 1980,\n\t  });\n\t  expect(result2).toEqual({ ...user1, id: 1 });\n", "  // Allows constant parameters\n\t  const params = {\n\t    targetNickname: 'Jane' as const,\n\t    targetBirthYear: 1990 as const,\n\t  } as const;\n\t  parameterization.execute(db, params);\n\t  parameterization.executeTakeFirst(db, params);\n\t});\n\tit('parameterizes \"where\" selections for specific columns', async () => {\n\t  interface Params {\n", "    targetHandle: string;\n\t  }\n\t  await db.insertInto('users').values([user1, user2, user3]).execute();\n\t  const parameterization = parameterizeQuery(\n\t    db.selectFrom('users').select('name')\n\t  ).asFollows<Params>(({ qb, param }) =>\n\t    qb.where('handle', '=', param('targetHandle'))\n\t  );\n\t  const result1 = await parameterization.executeTakeFirst(db, {\n\t    targetHandle: user3.handle,\n", "  });\n\t  expect(result1).toEqual({ name: user3.name });\n\t});\n\tit('parameterizes \"where\" selections using \"in\" operator', async () => {\n\t  interface Params {\n\t    targetNickname: string;\n\t    targetBirthYear1: number;\n\t    targetBirthYear2: number;\n\t  }\n\t  await db.insertInto('users').values([user1, user2, user3]).execute();\n", "  const parameterization = parameterizeQuery(\n\t    db.selectFrom('users').selectAll()\n\t  ).asFollows<Params>(({ qb, param }) =>\n\t    qb\n\t      .where('nickname', '=', param('targetNickname'))\n\t      .where('birthYear', 'in', [\n\t        param('targetBirthYear1'),\n\t        param('targetBirthYear2'),\n\t      ])\n\t  );\n", "  const results = await parameterization.execute(db, {\n\t    targetNickname: user2.nickname,\n\t    targetBirthYear1: 1980,\n\t    targetBirthYear2: 1990,\n\t  });\n\t  expect(results.rows).toEqual([\n\t    { ...user1, id: 1 },\n\t    { ...user2, id: 2 },\n\t  ]);\n\t  // Make sure we can address properties by name.\n", "  expect(results.rows[0].name).toEqual(user1.name);\n\t});\n\tit('parameterizes values within a where expression', async () => {\n\t  interface Params {\n\t    targetNickname: string;\n\t    targetBirthYear1: number;\n\t    targetBirthYear2: number;\n\t  }\n\t  await db.insertInto('users').values([user1, user2, user3]).execute();\n\t  const parameterization = parameterizeQuery(\n", "    db.selectFrom('users').selectAll()\n\t  ).asFollows<Params>(({ qb, param }) =>\n\t    qb.where(({ and, cmpr }) =>\n\t      and([\n\t        cmpr('nickname', '=', param('targetNickname')),\n\t        cmpr('birthYear', 'in', [\n\t          param('targetBirthYear1'),\n\t          param('targetBirthYear2'),\n\t        ]),\n\t      ])\n", "    )\n\t  );\n\t  const results = await parameterization.execute(db, {\n\t    targetNickname: user2.nickname,\n\t    targetBirthYear1: 1980,\n\t    targetBirthYear2: 1990,\n\t  });\n\t  expect(results.rows).toEqual([\n\t    { ...user1, id: 1 },\n\t    { ...user2, id: 2 },\n", "  ]);\n\t});\n\tit('parameterizes values within a SQL expression', async () => {\n\t  interface Params {\n\t    targetName: string;\n\t  }\n\t  await db.insertInto('users').values([user1, user2, user3]).execute();\n\t  const parameterization = parameterizeQuery(\n\t    db.selectFrom('users').selectAll()\n\t  ).asFollows<Params>(({ qb, param }) =>\n", "    qb.where(sql`name = ${param('targetName')}`)\n\t  );\n\t  // First execution\n\t  const results1 = await parameterization.execute(db, {\n\t    targetName: user1.name,\n\t  });\n\t  expect(results1.rows).toEqual([{ ...user1, id: 1 }]);\n\t  // Second execution\n\t  const results2 = await parameterization.execute(db, {\n\t    targetName: user2.name,\n", "  });\n\t  expect(results2.rows).toEqual([{ ...user2, id: 2 }]);\n\t});\n\tit('parameterizes without defined parameters', async () => {\n\t  await db.insertInto('users').values([user1, user2, user3]).execute();\n\t  const parameterization = parameterizeQuery(\n\t    db.selectFrom('users').selectAll()\n\t  ).asFollows(({ qb }) =>\n\t    qb\n\t      .where('nickname', '=', user2.nickname)\n", "      .where('birthYear', '=', user1.birthYear)\n\t  );\n\t  const result2 = await parameterization.executeTakeFirst(db, {});\n\t  expect(result2).toEqual({ ...user1, id: 1 });\n\t});\n\tignore('array parameters are not allowed', () => {\n\t  interface InvalidParams {\n\t    targetBirthYears: number[];\n\t  }\n\t  parameterizeQuery(\n", "    db.selectFrom('users').selectAll()\n\t    // @ts-expect-error - invalid parameter type\n\t  ).asFollows<InvalidParams>(({ qb, param }) =>\n\t    qb.where('birthYear', 'in', param('targetBirthYears'))\n\t  );\n\t});\n\tignore('disallows incompatible parameter types', () => {\n\t  interface InvalidParams {\n\t    targetHandle: number;\n\t  }\n", "  parameterizeQuery(db.selectFrom('users')).asFollows<InvalidParams>(\n\t    ({ qb, param }) =>\n\t      //@ts-expect-error - invalid parameter type\n\t      qb.where('handle', '=', param('targetHandle'))\n\t  );\n\t  parameterizeQuery(db.selectFrom('users')).asFollows<InvalidParams>(\n\t    ({ qb, param }) =>\n\t      qb.where(({ or, cmpr }) =>\n\t        //@ts-expect-error - invalid parameter type\n\t        or([cmpr('handle', '=', param('targetHandle'))])\n", "      )\n\t  );\n\t});\n\tignore('disallows parameters in column positions', () => {\n\t  interface ValidParams {\n\t    targetHandle: string;\n\t  }\n\t  parameterizeQuery(db.selectFrom('users')).asFollows<ValidParams>(\n\t    ({ qb, param }) =>\n\t      // @ts-expect-error - invalid parameter position\n", "      qb.where(param('targetHandle'), '=', 'jsmith')\n\t  );\n\t  parameterizeQuery(db.selectFrom('users')).asFollows<ValidParams>(\n\t    ({ qb, param }) =>\n\t      qb.where(({ or, cmpr }) =>\n\t        or([\n\t          // @ts-expect-error - invalid parameter position\n\t          cmpr(param('targetHandle'), '=', 'jsmith'),\n\t          // @ts-expect-error - invalid parameter position\n\t          cmpr('birthYear', param('targetHandle'), 1980),\n", "        ])\n\t      )\n\t  );\n\t});\n\tignore('restricts provided parameters', async () => {\n\t  interface ValidParams {\n\t    targetHandle: string;\n\t    targetBirthYear: number;\n\t  }\n\t  const parameterization = parameterizeQuery(\n", "    db.selectFrom('users')\n\t  ).asFollows<ValidParams>(({ qb, param }) =>\n\t    qb\n\t      .where('handle', '=', param('targetHandle'))\n\t      .where('name', '=', 'John Smith')\n\t      .where('birthYear', '=', param('targetBirthYear'))\n\t  );\n\t  await parameterization.execute(db, {\n\t    //@ts-expect-error - invalid parameter name\n\t    invalidParam: 'invalid',\n", "  });\n\t  await parameterization.executeTakeFirst(db, {\n\t    //@ts-expect-error - invalid parameter name\n\t    invalidParam: 'invalid',\n\t  });\n\t  await parameterization.execute(db, {\n\t    //@ts-expect-error - invalid parameter type\n\t    targetBirthYear: '2020',\n\t    targetHandle: 'jsmith',\n\t  });\n", "  await parameterization.executeTakeFirst(db, {\n\t    //@ts-expect-error - invalid parameter type\n\t    targetBirthYear: '2020',\n\t    targetHandle: 'jsmith',\n\t  });\n\t  await parameterization.execute(db, {\n\t    //@ts-expect-error - invalid parameter type\n\t    targetHandle: null,\n\t  });\n\t  await parameterization.executeTakeFirst(db, {\n", "    //@ts-expect-error - invalid parameter type\n\t    targetHandle: null,\n\t  });\n\t  //@ts-expect-error - missing parameter name\n\t  await parameterization.execute(db, {\n\t    targetBirthYear: 2020,\n\t  });\n\t  //@ts-expect-error - missing parameter name\n\t  await parameterization.executeTakeFirst(db, {\n\t    targetBirthYear: 2020,\n", "  });\n\t  //@ts-expect-error - missing parameter name\n\t  await parameterization.execute(db, {});\n\t  //@ts-expect-error - missing parameter name\n\t  await parameterization.executeTakeFirst(db, {});\n\t});\n\tignore('restrict selected column names', async () => {\n\t  interface ValidParams {\n\t    targetHandle: string;\n\t  }\n", "  const parameterization = parameterizeQuery(\n\t    db.selectFrom('users').selectAll()\n\t  ).asFollows<ValidParams>(({ qb, param }) =>\n\t    qb.where('handle', '=', param('targetHandle'))\n\t  );\n\t  const result1 = await parameterization.executeTakeFirst(db, {\n\t    targetHandle: 'jsmith',\n\t  });\n\t  // @ts-expect-error - invalid returned column\n\t  expect(result1?.notThere).toEqual('John Smith');\n", "  const result2 = await parameterization.execute(db, {\n\t    targetHandle: 'jsmith',\n\t  });\n\t  const firstRow = result2.rows[0];\n\t  // @ts-expect-error - invalid returned column\n\t  expect(firstRow.notThere).toEqual('John Smith');\n\t});\n"]}
{"filename": "src/tests/insert-params.test.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\timport { createDB, resetDB, destroyDB } from '../utils/test-setup';\n\timport { Database } from '../utils/test-tables';\n\timport { ignore } from '../utils/test-utils';\n\timport { parameterizeQuery } from '../lib/parameterizer';\n\tlet db: Kysely<Database>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n\t});\n\tbeforeEach(() => resetDB(db));\n", "afterAll(() => destroyDB(db));\n\tit('instantiates inserted strings and numbers', async () => {\n\t  interface Params {\n\t    sourceHandle: string;\n\t    sourceBirthYear: number | null;\n\t  }\n\t  const user = {\n\t    name: 'John Smith',\n\t    // leave out nickname\n\t    handle: 'jsmith',\n", "    birthYear: 1990,\n\t  };\n\t  const parameterization = parameterizeQuery(\n\t    db.insertInto('users').returning('id')\n\t  ).asFollows<Params>(({ qb, param }) =>\n\t    qb.values({\n\t      handle: param('sourceHandle'),\n\t      name: user.name,\n\t      birthYear: param('sourceBirthYear'),\n\t    })\n", "  );\n\t  const compiledQuery = parameterization.instantiate({\n\t    sourceHandle: user.handle,\n\t    sourceBirthYear: user.birthYear,\n\t  });\n\t  const result = await db.executeQuery(compiledQuery);\n\t  expect(result?.rows).toEqual([{ id: 1 }]);\n\t  const readUser = await db\n\t    .selectFrom('users')\n\t    .selectAll()\n", "    .where('handle', '=', user.handle)\n\t    .executeTakeFirst();\n\t  expect(readUser).toEqual({ ...user, id: 1, nickname: null });\n\t});\n\tit('parameterizes inserted strings and numbers with non-null values', async () => {\n\t  interface Params {\n\t    sourceHandle: string;\n\t    sourceBirthYear: number | null;\n\t  }\n\t  const user = {\n", "    name: 'John Smith',\n\t    // leave out nickname\n\t    handle: 'jsmith',\n\t    birthYear: 1990,\n\t  };\n\t  const parameterization = parameterizeQuery(\n\t    db.insertInto('users').returning('id')\n\t  ).asFollows<Params>(({ qb, param }) =>\n\t    qb.values({\n\t      handle: param('sourceHandle'),\n", "      name: user.name,\n\t      birthYear: param('sourceBirthYear'),\n\t    })\n\t  );\n\t  const result = await parameterization.executeTakeFirst(db, {\n\t    sourceHandle: user.handle,\n\t    sourceBirthYear: user.birthYear,\n\t  });\n\t  expect(result).toEqual({ id: 1 });\n\t  // Make sure we can address properties by name.\n", "  expect(result?.id).toBe(1);\n\t  const readUser = await db\n\t    .selectFrom('users')\n\t    .selectAll()\n\t    .where('handle', '=', user.handle)\n\t    .executeTakeFirst();\n\t  expect(readUser).toEqual({ ...user, id: 1, nickname: null });\n\t});\n\tit('parameterizes inserted strings and numbers with null values', async () => {\n\t  interface Params {\n", "    sourceNickname: string | null;\n\t    sourceBirthYear: number | null;\n\t  }\n\t  const user = {\n\t    name: 'John Smith',\n\t    nickname: null,\n\t    handle: 'jsmith',\n\t    birthYear: null,\n\t  };\n\t  const parameterization = parameterizeQuery(\n", "    db.insertInto('users').returning('id')\n\t  ).asFollows<Params>(({ qb, param }) =>\n\t    qb.values({\n\t      handle: user.handle,\n\t      name: user.name,\n\t      nickname: param('sourceNickname'),\n\t      birthYear: param('sourceBirthYear'),\n\t    })\n\t  );\n\t  const result = await parameterization.executeTakeFirst(db, {\n", "    sourceNickname: user.nickname,\n\t    sourceBirthYear: user.birthYear,\n\t  });\n\t  expect(result).toEqual({ id: 1 });\n\t  const readUser = await db\n\t    .selectFrom('users')\n\t    .selectAll()\n\t    .where('handle', '=', user.handle)\n\t    .executeTakeFirst();\n\t  expect(readUser).toEqual({ ...user, id: 1 });\n", "});\n\tit('parameterizes a generated column, with multiple executions', async () => {\n\t  interface Params {\n\t    sourceId?: number;\n\t  }\n\t  const user = {\n\t    handle: 'jsmith',\n\t    name: 'John Smith',\n\t    nickname: null,\n\t    birthYear: null,\n", "  };\n\t  const parameterization = parameterizeQuery(\n\t    db.insertInto('users')\n\t  ).asFollows<Params>(({ qb, param }) =>\n\t    qb.values({\n\t      id: param('sourceId'),\n\t      name: user.name,\n\t      handle: user.handle,\n\t    })\n\t  );\n", "  // First execution not assigning generated column.\n\t  const result1 = await parameterization.executeTakeFirst(db, {});\n\t  expect(result1).toBeUndefined();\n\t  const readUser = await db\n\t    .selectFrom('users')\n\t    .selectAll()\n\t    .where('handle', '=', user.handle)\n\t    .executeTakeFirst();\n\t  expect(readUser).toEqual({ ...user, id: 1 });\n\t  // Second execution assigning generated column.\n", "  const result = await parameterization.executeTakeFirst(db, { sourceId: 100 });\n\t  expect(result).toBeUndefined();\n\t  const readUsers = await db\n\t    .selectFrom('users')\n\t    .selectAll()\n\t    .where('handle', '=', user.handle)\n\t    .execute();\n\t  expect(readUsers).toEqual([\n\t    { ...user, id: 1 },\n\t    { ...user, id: 100 },\n", "  ]);\n\t});\n\tit('parameterizes single query performing multiple insertions', async () => {\n\t  interface Params {\n\t    sourceName1and2: string;\n\t    sourceNickname1: string;\n\t    sourceBirthYear1: number;\n\t    sourceBirthYear2: number;\n\t  }\n\t  const user1 = {\n", "    name: 'John Smith',\n\t    nickname: 'Johny',\n\t    handle: 'jsmith1',\n\t    birthYear: 1990,\n\t  };\n\t  const user2 = {\n\t    name: 'John Smith',\n\t    nickname: null,\n\t    handle: 'jsmith2',\n\t    birthYear: 2000,\n", "  };\n\t  const parameterization = parameterizeQuery(\n\t    db.insertInto('users').returning('id')\n\t  ).asFollows<Params>(({ qb, param }) =>\n\t    qb.values([\n\t      {\n\t        handle: user1.handle,\n\t        name: param('sourceName1and2'),\n\t        nickname: param('sourceNickname1'),\n\t        birthYear: param('sourceBirthYear1'),\n", "      },\n\t      {\n\t        handle: user2.handle,\n\t        name: param('sourceName1and2'),\n\t        nickname: user2.nickname,\n\t        birthYear: user2.birthYear,\n\t      },\n\t    ])\n\t  );\n\t  const result = await parameterization.execute(db, {\n", "    sourceName1and2: user1.name,\n\t    sourceNickname1: user1.nickname,\n\t    sourceBirthYear1: user1.birthYear,\n\t    sourceBirthYear2: user2.birthYear,\n\t  });\n\t  expect(result.rows).toEqual([{ id: 1 }, { id: 2 }]);\n\t  // Make sure we can address properties by name.\n\t  expect(result?.rows[0].id).toBe(1);\n\t  const readUsers = await db\n\t    .selectFrom('users')\n", "    .selectAll()\n\t    .where('name', '=', user1.name)\n\t    .execute();\n\t  expect(readUsers).toEqual([\n\t    { ...user1, id: 1 },\n\t    { ...user2, id: 2 },\n\t  ]);\n\t});\n\tit('parameterizes without defined parameters', async () => {\n\t  const user = {\n", "    name: 'John Smith',\n\t    nickname: null,\n\t    handle: 'jsmith',\n\t    birthYear: null,\n\t  };\n\t  const parameterization = parameterizeQuery(\n\t    db.insertInto('users').returning('id')\n\t  ).asFollows(({ qb }) => qb.values(user));\n\t  const result = await parameterization.executeTakeFirst(db, {});\n\t  expect(result).toEqual({ id: 1 });\n", "  const readUser = await db\n\t    .selectFrom('users')\n\t    .selectAll()\n\t    .where('handle', '=', user.handle)\n\t    .executeTakeFirst();\n\t  expect(readUser).toEqual({ ...user, id: 1 });\n\t});\n\tignore('disallows incompatible parameter types', () => {\n\t  interface InvalidParams {\n\t    sourceHandle: number;\n", "    sourceName: string | null;\n\t  }\n\t  parameterizeQuery(db.insertInto('users')).asFollows<InvalidParams>(\n\t    ({ qb, param }) =>\n\t      qb.values({\n\t        //@ts-expect-error - invalid parameter type\n\t        handle: param('sourceHandle'),\n\t        name: 'John Smith',\n\t      })\n\t  );\n", "  parameterizeQuery(db.insertInto('users')).asFollows<InvalidParams>(\n\t    ({ qb, param }) =>\n\t      qb.values({\n\t        handle: 'jsmith',\n\t        //@ts-expect-error - invalid parameter type\n\t        name: param('sourceName'),\n\t      })\n\t  );\n\t});\n\tignore('restricts a generated column parameter', async () => {\n", "  interface InvalidParams {\n\t    sourceId?: string;\n\t  }\n\t  parameterizeQuery(db.insertInto('users')).asFollows<InvalidParams>(\n\t    ({ qb, param }) =>\n\t      qb.values({\n\t        //@ts-expect-error - invalid parameter type\n\t        id: param('sourceId'),\n\t        name: 'John Smith',\n\t        handle: 'jsmith',\n", "      })\n\t  );\n\t});\n\tignore('restricts provided parameters', async () => {\n\t  interface ValidParams {\n\t    sourceHandle: string;\n\t    sourceBirthYear: number | null;\n\t  }\n\t  const parameterization = parameterizeQuery(\n\t    db.insertInto('users')\n", "  ).asFollows<ValidParams>(({ qb, param }) =>\n\t    qb.values({\n\t      handle: param('sourceHandle'),\n\t      name: 'John Smith',\n\t      birthYear: param('sourceBirthYear'),\n\t    })\n\t  );\n\t  await parameterization.execute(db, {\n\t    //@ts-expect-error - invalid parameter name\n\t    invalidParam: 'invalid',\n", "  });\n\t  await parameterization.executeTakeFirst(db, {\n\t    //@ts-expect-error - invalid parameter name\n\t    invalidParam: 'invalid',\n\t  });\n\t  await parameterization.execute(db, {\n\t    //@ts-expect-error - invalid parameter type\n\t    sourceBirthYear: '2020',\n\t    sourceHandle: 'jsmith',\n\t  });\n", "  await parameterization.executeTakeFirst(db, {\n\t    //@ts-expect-error - invalid parameter type\n\t    sourceBirthYear: '2020',\n\t    sourceHandle: 'jsmith',\n\t  });\n\t  await parameterization.execute(db, {\n\t    //@ts-expect-error - invalid parameter type\n\t    sourceHandle: null,\n\t    sourceBirthYear: null,\n\t  });\n", "  await parameterization.executeTakeFirst(db, {\n\t    //@ts-expect-error - invalid parameter type\n\t    sourceHandle: null,\n\t    sourceBirthYear: null,\n\t  });\n\t  //@ts-expect-error - missing parameter name\n\t  await parameterization.execute(db, {\n\t    sourceBirthYear: 2020,\n\t  });\n\t  //@ts-expect-error - missing parameter name\n", "  await parameterization.executeTakeFirst(db, {\n\t    sourceBirthYear: 2020,\n\t  });\n\t  //@ts-expect-error - missing parameter name\n\t  await parameterization.execute(db, {});\n\t  //@ts-expect-error - missing parameter name\n\t  await parameterization.executeTakeFirst(db, {});\n\t});\n\tignore('restrict returned column names', async () => {\n\t  interface ValidParams {\n", "    sourceHandle: string;\n\t    sourceBirthYear: number | null;\n\t  }\n\t  const parameterization = parameterizeQuery(\n\t    db.insertInto('users').returning('id')\n\t  ).asFollows<ValidParams>(({ qb, param }) =>\n\t    qb.values({\n\t      handle: param('sourceHandle'),\n\t      name: 'John Smith',\n\t      birthYear: param('sourceBirthYear'),\n", "    })\n\t  );\n\t  const result1 = await parameterization.executeTakeFirst(db, {\n\t    sourceHandle: 'jsmith',\n\t    sourceBirthYear: 2020,\n\t  });\n\t  // @ts-expect-error - invalid column name\n\t  result1?.notThere;\n\t  const result2 = await parameterization.execute(db, {\n\t    sourceHandle: 'jsmith',\n", "    sourceBirthYear: 2020,\n\t  });\n\t  // @ts-expect-error - invalid column name\n\t  result2.rows[0]?.notThere;\n\t});\n"]}
{"filename": "src/lib/parameterized-value.ts", "chunked_list": ["/**\n\t * Class representing a parameter-specified value.\n\t * @paramtype P Record characterizing the parameter names and types.\n\t */\n\texport class ParameterizedValue<P extends Record<string, any>> {\n\t  /**\n\t   * Creates a new parameter-specified value.\n\t   * @param parameterName Name of the parameter.\n\t   */\n\t  constructor(readonly parameterName: keyof P & string) {}\n", "}\n"]}
{"filename": "src/lib/parameterizer.ts", "chunked_list": ["import { Compilable } from 'kysely';\n\timport { ParameterizedValue } from './parameterized-value.js';\n\timport { ParameterizedQuery, ParametersObject } from './parameterized-query.js';\n\ttype QueryBuilderOutput<QB> = QB extends Compilable<infer O> ? O : never;\n\t/**\n\t * Creates and returns a parameterizer for the given query builder. The\n\t * provided query builder must designate any selected or returned columns\n\t * that you wish to be able to reference by name, as TypeScript will not\n\t * otherwise be aware of the columns being returned.\n\t * @paramtype O Type of the query result.\n", " * @paramtype QB Type of the source query builder.\n\t * @param qb The source query builder, which should establish any selected\n\t *  or returned columns you wish to be able to reference by name.\n\t * @returns Parameterizer for the given query builder, which can be used\n\t *  to create parameterized queries.\n\t */\n\texport function parameterizeQuery<\n\t  QB extends Compilable<O>,\n\t  O = QueryBuilderOutput<QB>\n\t>(qb: QB): QueryParameterizer<QB, O> {\n", "  return new QueryParameterizer(qb);\n\t}\n\t/**\n\t * Class for parameterizing queries.\n\t * @paramtype O Type of the query result.\n\t * @paramtype QB Type of the source query builder.\n\t */\n\texport class QueryParameterizer<\n\t  QB extends Compilable<O>,\n\t  O = QueryBuilderOutput<QB>\n", "> {\n\t  /**\n\t   * Creates a new parameterizer for the given query builder.\n\t   */\n\t  constructor(readonly qb: QB) {}\n\t  /**\n\t   * Creates and returns a parameterized query.\n\t   * @paramtype P Record characterizing the available parameter names and types.\n\t   * @param factory Function that receives an object of the form { qb, param }\n\t   *  and returns a query builder that may contain parameterized values.\n", "   * @returns Parameterized query.\n\t   */\n\t  asFollows<P extends ParametersObject<P>>(\n\t    factory: ParameterizedQueryFactory<P, QB, O>\n\t  ): ParameterizedQuery<P, O> {\n\t    const parameterMaker = new QueryParameterMaker<P>();\n\t    return new ParameterizedQuery(\n\t      factory({ qb: this.qb, param: parameterMaker.param.bind(parameterMaker) })\n\t    );\n\t  }\n", "}\n\t/**\n\t * Factory function for creating a parameterized query.\n\t * @paramtype O Type of the query result.\n\t * @paramtype P Record characterizing the available parameter names and types.\n\t * @paramtype QB Type of the source query builder.\n\t * @param args Object of the form { qb, param }, returning a query builder\n\t *  that may contain parameterized values.\n\t */\n\texport interface ParameterizedQueryFactory<\n", "  P extends ParametersObject<P>,\n\t  QB extends Compilable<O>,\n\t  O = QueryBuilderOutput<QB>\n\t> {\n\t  (args: { qb: QB; param: QueryParameterMaker<P>['param'] }): Compilable<O>;\n\t}\n\t/**\n\t * Class for making occurrences of parameters within a query.\n\t * @paramtype P Record characterizing the available parameter names and types.\n\t */\n", "export class QueryParameterMaker<P> {\n\t  /**\n\t   * Returns a parameterized value.\n\t   * @param name Parameter name.\n\t   * @returns Parameter having the given name and the type assigned to that\n\t   *  name in P.\n\t   */\n\t  param<N extends keyof P & string>(name: N): P[N] {\n\t    return new ParameterizedValue(name) as unknown as P[N];\n\t  }\n", "}\n"]}
{"filename": "src/lib/parameterized-query.ts", "chunked_list": ["import { CompiledQuery, Compilable, Kysely, QueryResult } from 'kysely';\n\timport { ParameterizedValue } from './parameterized-value.js';\n\t/**\n\t * Type for an object that defines the query parameters. It disallows the\n\t * object from having array properties.\n\t * @typeparam T Type that is to define the query parameters.\n\t */\n\texport type ParametersObject<P> = {\n\t  [K in keyof P]: P[K] extends Array<any> ? never : P[K];\n\t};\n", "/**\n\t * Class representing a parameterized compiled query that can be repeatedly\n\t * executed or instantiated with different values for its parameters.\n\t * @paramtype P Record characterizing the parameter names and types.\n\t */\n\texport class ParameterizedQuery<P extends ParametersObject<P>, O> {\n\t  #qb: Compilable<O> | null;\n\t  #compiledQuery?: CompiledQuery<O>;\n\t  /**\n\t   * Creates a new parameterized query from a query builder whose query\n", "   * arguments may contained parameterized values.\n\t   */\n\t  constructor(qb: Compilable<O>) {\n\t    this.#qb = qb;\n\t  }\n\t  /**\n\t   * Executes the query with all parameters replaced, returning all results.\n\t   * Compiles the query on the first call, caching the compiled query and\n\t   * discarding the underlying query builder to reduce memory used.\n\t   * @param db The Kysely database instance.\n", "   * @param params Object providing values for all parameters.\n\t   * @returns Query result.\n\t   */\n\t  execute<DB>(db: Kysely<DB>, params: Readonly<P>): Promise<QueryResult<O>> {\n\t    return db.executeQuery(this.instantiate(params));\n\t  }\n\t  /**\n\t   * Executes the query with all parameters replaced, returning the first\n\t   * result. Compiles the query on the first call, caching the compiled query\n\t   * and discarding the underlying query builder to reduce memory used.\n", "   * @param db The Kysely database instance.\n\t   * @param params Object providing values for all parameters.\n\t   * @returns First query result, or undefined if there are no results.\n\t   */\n\t  async executeTakeFirst<DB>(\n\t    db: Kysely<DB>,\n\t    params: Readonly<P>\n\t  ): Promise<O | undefined> {\n\t    const result = await db.executeQuery(this.instantiate(params));\n\t    return result.rows.length > 0 ? result.rows[0] : undefined;\n", "  }\n\t  /**\n\t   * Instantiates the query as a compiled query with all parameters replaced,\n\t   * returning the compiled query. Compiles the query on the first call,\n\t   * caching the uninstantiated compiled query and discarding the underlying\n\t   * query builder to reduce memory used.\n\t   * @param params Object providing values for all parameters.\n\t   * @returns Compiled query with values replacing all parameters.\n\t   */\n\t  instantiate(params: Readonly<P>): CompiledQuery<O> {\n", "    if (this.#compiledQuery === undefined) {\n\t      this.#compiledQuery = this.#qb!.compile();\n\t      // Allow the query builder to be garbage collected.\n\t      this.#qb = null;\n\t    }\n\t    return {\n\t      query: this.#compiledQuery.query,\n\t      sql: this.#compiledQuery.sql,\n\t      parameters: this.#compiledQuery.parameters.map((value) =>\n\t        value instanceof ParameterizedValue\n", "          ? params[value.parameterName as keyof P]\n\t          : value\n\t      ),\n\t    };\n\t  }\n\t}\n"]}
