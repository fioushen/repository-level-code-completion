{"filename": "jest.config.ts", "chunked_list": ["import { JestConfigWithTsJest } from 'ts-jest';\n\tconst config: JestConfigWithTsJest = {\n\t  preset: 'ts-jest',\n\t  testEnvironment: 'node',\n\t  moduleNameMapper: {\n\t    '^@/(.*)': '<rootDir>/src/$1',\n\t  },\n\t  testMatch: [`<rootDir>/src/**/__tests__/index.ts`],\n\t};\n\texport default config;\n"]}
{"filename": "tsup.config.ts", "chunked_list": ["import type { Options } from 'tsup';\n\tconst tsupConfig: Options = {\n\t  entryPoints: ['src/*.ts'],\n\t  clean: true,\n\t  format: ['cjs', 'esm'],\n\t  dts: true,\n\t  onSuccess: 'npm run build:grammar',\n\t};\n\texport default tsupConfig;\n"]}
{"filename": "scripts/build-grammar.ts", "chunked_list": ["import fs from 'fs';\n\timport path from 'path';\n\tasync function run() {\n\t  const source = path.resolve(process.cwd(), 'src/parser/grammar/liquidx.ohm');\n\t  const target = path.resolve(process.cwd(), 'dist/liquidx.ohm');\n\t  fs.copyFileSync(source, target);\n\t}\n\trun();\n"]}
{"filename": "src/index.ts", "chunked_list": ["import render from './renderer';\n\texport { render };\n"]}
{"filename": "src/utils/tests/get-suite-name.ts", "chunked_list": ["import getRelativeDirnameFromAbsoluteDirname from './get-relative-dirname-from-absolute-dirname';\n\texport default function getSuiteName(dirname: string, { isDir = false } = {}) {\n\t  const relativeDirname = getRelativeDirnameFromAbsoluteDirname(dirname);\n\t  if (isDir) {\n\t    return relativeDirname.split('__tests__/')[1];\n\t  }\n\t  const filename = dirname.split('/').at(-1);\n\t  const filenameWithoutExtension = filename!.split('.')[0];\n\t  return filenameWithoutExtension;\n\t}\n"]}
{"filename": "src/utils/tests/require-all.ts", "chunked_list": ["import * as fs from 'fs';\n\timport * as path from 'path';\n\timport getSuiteName from './get-suite-name';\n\tconst TEST_ONLY: string | undefined = process.env.TEST_ONLY;\n\texport default function requireAll(directory: string) {\n\t  const files = fs.readdirSync(directory);\n\t  files.forEach((file) => {\n\t    const filePath = path.join(directory, file);\n\t    if (filePath.endsWith('__snapshots__')) return;\n\t    const filePathWithoutTestsPrefix = filePath.replace('__tests__/', '');\n", "    if (TEST_ONLY && !filePathWithoutTestsPrefix.match(new RegExp(TEST_ONLY, 'i'))) {\n\t      test.skip('', () => {\n\t        expect(true).toBe(true);\n\t      });\n\t      return;\n\t    }\n\t    if (fs.statSync(filePath).isDirectory()) {\n\t      describe(getSuiteName(filePath, { isDir: true }), () => {\n\t        require(path.join(filePath, 'index.ts'));\n\t      });\n", "    } else if (filePath.match(/.+\\.test\\.ts/)) {\n\t      describe(getSuiteName(filePath), () => {\n\t        require(filePath);\n\t      });\n\t    }\n\t  });\n\t}\n"]}
{"filename": "src/utils/tests/get-root-suite-name.ts", "chunked_list": ["import * as path from 'path';\n\timport getRelativeDirnameFromAbsoluteDirname from './get-relative-dirname-from-absolute-dirname';\n\texport default function getRootSuiteName(dirname: string) {\n\t  const relativeDirname = getRelativeDirnameFromAbsoluteDirname(dirname);\n\t  // Get rid of trailing slash, 'src', and '__tests__'\n\t  const dirnameParts = relativeDirname.split(path.sep).slice(2, -1);\n\t  return path.join(...dirnameParts);\n\t}\n"]}
{"filename": "src/utils/tests/get-relative-dirname-from-absolute-dirname.ts", "chunked_list": ["export default function getRelativeDirnameFromAbsoluteDirname(dirname: string) {\n\t  return dirname.replace(process.cwd(), '');\n\t}\n"]}
{"filename": "src/utils/tests/index.ts", "chunked_list": ["export { default as getRelativeDirnameFromAbsoluteDirname } from './get-relative-dirname-from-absolute-dirname';\n\texport { default as getRootSuiteName } from './get-root-suite-name';\n\texport { default as getSuiteName } from './get-suite-name';\n\texport { default as requireAll } from './require-all';\n"]}
{"filename": "src/renderer/index.ts", "chunked_list": ["import sourceToAST, {\n\t  AttributeNode,\n\t  ElementNode,\n\t  LiquidDropNode,\n\t  LiquidXNode,\n\t  NodeTypes,\n\t  TextNode,\n\t} from '../parser/2-cst-to-ast';\n\tfunction renderStartMarker() {\n\t  return '{% # LIQUIDX:START - EDITS MADE TO THE CODE BETWEEN \"LIQUIDX:START\" and \"LIQUIDX:END\" WILL BE OVERWRITTEN %}';\n", "}\n\tfunction renderEndMarker(node: ElementNode) {\n\t  return `{% # LIQUIDX:END - SOURCE ${JSON.stringify(\n\t    node.source.slice(node.locStart, node.locEnd),\n\t  )} %}`;\n\t}\n\tfunction renderElement(\n\t  node: ElementNode,\n\t  { withSource = false, isChildOfElementNode = false } = {},\n\t) {\n", "  let output = '';\n\t  const attributes = node.attributes;\n\t  if (withSource && !isChildOfElementNode) {\n\t    output += renderStartMarker();\n\t  }\n\t  if (node.children.length > 0) {\n\t    const captureName = `${node.name}Children`;\n\t    output += `{% capture ${captureName} %}`;\n\t    output += renderAST(node.children, { withSource, isChildOfElementNode: true });\n\t    output += '{% endcapture %}';\n", "    const childrenAttribute: AttributeNode = {\n\t      type: NodeTypes.AttributeDoubleQuoted,\n\t      locStart: 0,\n\t      locEnd: 0,\n\t      source: '',\n\t      name: {\n\t        type: NodeTypes.TextNode,\n\t        locStart: 0,\n\t        locEnd: 0,\n\t        source: '',\n", "        value: 'children',\n\t      },\n\t      value: {\n\t        type: NodeTypes.LiquidDropNode,\n\t        locStart: 0,\n\t        locEnd: 0,\n\t        source: '',\n\t        value: captureName,\n\t      },\n\t    };\n", "    attributes.push(childrenAttribute);\n\t  }\n\t  const renderedAttributes = node.attributes.map((attribute) => renderAST([attribute]));\n\t  const separator = ', ';\n\t  const attributesString =\n\t    renderedAttributes.length > 0 ? `${separator}${renderedAttributes.join(separator)}` : '';\n\t  output += `{% render '${node.name}'${attributesString} %}`;\n\t  if (withSource && !isChildOfElementNode) {\n\t    output += renderEndMarker(node);\n\t  }\n", "  return output;\n\t}\n\tfunction renderText(node: TextNode) {\n\t  return node.value;\n\t}\n\tfunction renderLiquidDrop(node: LiquidDropNode) {\n\t  return node.value;\n\t}\n\tfunction renderAST(\n\t  ast: LiquidXNode[],\n", "  { withSource = false, isChildOfElementNode = false } = {},\n\t): string {\n\t  let output = '';\n\t  for (let i = 0; i < ast.length; i += 1) {\n\t    const node = ast[i];\n\t    switch (node.type) {\n\t      case NodeTypes.TextNode: {\n\t        output += renderText(node);\n\t        break;\n\t      }\n", "      case NodeTypes.ElementNode: {\n\t        output += renderElement(node, { withSource, isChildOfElementNode });\n\t        break;\n\t      }\n\t      case NodeTypes.AttributeDoubleQuoted:\n\t      case NodeTypes.AttributeSingleQuoted:\n\t      case NodeTypes.AttributeUnquoted: {\n\t        const name = renderText(node.name);\n\t        let value = null;\n\t        if (node.value.type === NodeTypes.TextNode) {\n", "          value = JSON.stringify(renderText(node.value));\n\t        } else {\n\t          value = renderLiquidDrop(node.value);\n\t        }\n\t        output += `${name}: ${value}`;\n\t        break;\n\t      }\n\t      case NodeTypes.AttributeEmpty: {\n\t        const name = renderText(node.name);\n\t        const value = true;\n", "        output += `${name}: ${value}`;\n\t        break;\n\t      }\n\t      default: {\n\t        console.log(node);\n\t        // TODO\n\t        throw new Error('');\n\t      }\n\t    }\n\t  }\n", "  return output;\n\t}\n\texport default function render(source: string, { withSource = false } = {}) {\n\t  const ast = sourceToAST(source);\n\t  const ouput = renderAST(ast, { withSource });\n\t  return ouput;\n\t}\n"]}
{"filename": "src/renderer/__tests__/self-closing.test.ts", "chunked_list": ["import dedent from 'dedent-js';\n\timport { testRender } from './utils';\n\tit('should render', () => {\n\t  const input = dedent`\n\t  <Icon/>\n\t  <Icon />\n\t  `;\n\t  const expected = dedent`\n\t  {% render 'Icon' %}\n\t  {% render 'Icon' %}\n", "  `;\n\t  testRender(input, expected);\n\t});\n"]}
{"filename": "src/renderer/__tests__/formatting.test.ts", "chunked_list": ["import dedent from 'dedent-js';\n\timport { testRender } from './utils';\n\tit('should preserve formatting (single-line)', () => {\n\t  const input = '<Button>Hello, World!</Button>';\n\t  const expected = dedent`\n\t  {% capture ButtonChildren %}Hello, World!{% endcapture %}{% render 'Button', children: ButtonChildren %}\n\t  `;\n\t  testRender(input, expected);\n\t});\n\tit('should preserve formatting (multi-line #1)', () => {\n", "  const input = dedent`\n\t  <Button>Hello, World!\n\t  </Button>\n\t  `;\n\t  const expected = dedent`\n\t  {% capture ButtonChildren %}Hello, World!\n\t  {% endcapture %}{% render 'Button', children: ButtonChildren %}\n\t  `;\n\t  testRender(input, expected);\n\t});\n", "it('should preserve formatting (multi-line #2)', () => {\n\t  const input = dedent`\n\t  <Button>\n\t    Hello, World!</Button>\n\t  `;\n\t  const expected = dedent`\n\t  {% capture ButtonChildren %}\n\t    Hello, World!{% endcapture %}{% render 'Button', children: ButtonChildren %}\n\t  `;\n\t  testRender(input, expected);\n", "});\n\tit('should preserve formatting (multi-line #3)', () => {\n\t  const input = dedent`\n\t  <Button>\n\t    Hello, World!\n\t  </Button>\n\t  `;\n\t  const expected = dedent`\n\t  {% capture ButtonChildren %}\n\t    Hello, World!\n", "  {% endcapture %}{% render 'Button', children: ButtonChildren %}\n\t  `;\n\t  testRender(input, expected);\n\t});\n\tit('should preserve formatting (deeply nested)', () => {\n\t  const input = dedent`\n\t  <div>\n\t    <div>\n\t      <Button>\n\t        <Text>\n", "          <span>Hello, World!</span>\n\t        </Text>\n\t      </Button>\n\t    </div>\n\t  </div>\n\t  `;\n\t  const expected = dedent`\n\t  <div>\n\t    <div>\n\t      {% capture ButtonChildren %}\n", "        {% capture TextChildren %}\n\t          <span>Hello, World!</span>\n\t        {% endcapture %}{% render 'Text', children: TextChildren %}\n\t      {% endcapture %}{% render 'Button', children: ButtonChildren %}\n\t    </div>\n\t  </div>\n\t  `;\n\t  testRender(input, expected);\n\t});\n"]}
{"filename": "src/renderer/__tests__/simple.test.ts", "chunked_list": ["import { testRender } from './utils';\n\tit('should render text', () => {\n\t  const input = '<button>Hello, World</button>';\n\t  const expected = '<button>Hello, World</button>';\n\t  testRender(input, expected);\n\t});\n\tit('should render element without children', () => {\n\t  const input = '<Button></Button>';\n\t  const expected = \"{% render 'Button' %}\";\n\t  testRender(input, expected);\n", "});\n"]}
{"filename": "src/renderer/__tests__/source.test.ts", "chunked_list": ["import dedent from 'dedent-js';\n\timport { testRender } from './utils';\n\tit('should render source', () => {\n\t  const input = dedent`<Icon />`;\n\t  const expected = dedent`\n\t  {% # LIQUIDX:START - EDITS MADE TO THE CODE BETWEEN \\\"LIQUIDX:START\\\" and \\\"LIQUIDX:END\\\" WILL BE OVERWRITTEN %}{% render 'Icon' %}{% # LIQUIDX:END - SOURCE \\\"<Icon />\\\" %}\n\t  `;\n\t  testRender(input, expected, { withSource: true });\n\t});\n"]}
{"filename": "src/renderer/__tests__/nested.test.ts", "chunked_list": ["import dedent from 'dedent-js';\n\timport { testRender } from './utils';\n\tit('should render text in element', () => {\n\t  const input = dedent`\n\t  <Button>Hello, World!</Button>\n\t  `;\n\t  const expected = dedent`\n\t  {% capture ButtonChildren %}Hello, World!{% endcapture %}{% render 'Button', children: ButtonChildren %}\n\t  `;\n\t  testRender(input, expected);\n", "});\n\tit('should render element in element', () => {\n\t  const input = dedent`\n\t  <Button>\n\t    <Text>Hello, World!</Text>\n\t  </Button>\n\t  `;\n\t  const expected = dedent`\n\t  {% capture ButtonChildren %}\n\t    {% capture TextChildren %}Hello, World!{% endcapture %}{% render 'Text', children: TextChildren %}\n", "  {% endcapture %}{% render 'Button', children: ButtonChildren %}\n\t  `;\n\t  testRender(input, expected);\n\t});\n\tit('should render element in text', () => {\n\t  const input = dedent`\n\t  <button>\n\t    <Text>Hello, World!</Text>\n\t  </button>\n\t  `;\n", "  const expected = dedent`\n\t  <button>\n\t    {% capture TextChildren %}Hello, World!{% endcapture %}{% render 'Text', children: TextChildren %}\n\t  </button>\n\t  `;\n\t  testRender(input, expected);\n\t});\n"]}
{"filename": "src/renderer/__tests__/utils.ts", "chunked_list": ["import render from '..';\n\texport function testRender(input: string, expected: string, { withSource = false } = {}) {\n\t  const output = render(input, { withSource });\n\t  expect(output).toBe(expected);\n\t}\n"]}
{"filename": "src/renderer/__tests__/index.ts", "chunked_list": ["import { getRootSuiteName, requireAll } from '@/utils/tests';\n\tdescribe(getRootSuiteName(__dirname), () => {\n\t  requireAll(__dirname);\n\t});\n"]}
{"filename": "src/renderer/__tests__/attributes.test.ts", "chunked_list": ["import dedent from 'dedent-js';\n\timport { testRender } from './utils';\n\tit('should render string', () => {\n\t  const input = dedent`\n\t  <Icon str=\"STRING\" />\n\t  `;\n\t  const expected = dedent`\n\t  {% render 'Icon', str: \"STRING\" %}\n\t  `;\n\t  testRender(input, expected);\n", "});\n\tit('should render number', () => {\n\t  const input = dedent`\n\t  <Icon num=\"{{ 0 }}\" />\n\t  `;\n\t  const expected = dedent`\n\t  {% render 'Icon', num: 0 %}\n\t  `;\n\t  testRender(input, expected);\n\t});\n", "it('should render float', () => {\n\t  const input = dedent`\n\t  <Icon num=\"{{ 1.1 }}\" />\n\t  `;\n\t  const expected = dedent`\n\t  {% render 'Icon', num: 1.1 %}\n\t  `;\n\t  testRender(input, expected);\n\t});\n\tit('should render boolean (explicit)', () => {\n", "  const input = dedent`\n\t  <Icon bool1=\"{{ true }}\" bool2=\"{{ false }}\" />\n\t  `;\n\t  const expected = dedent`\n\t  {% render 'Icon', bool1: true, bool2: false %}\n\t  `;\n\t  testRender(input, expected);\n\t});\n\tit('should render boolean (implicit)', () => {\n\t  const input = dedent`\n", "  <Icon bool />\n\t  `;\n\t  const expected = dedent`\n\t  {% render 'Icon', bool: true %}\n\t  `;\n\t  testRender(input, expected);\n\t});\n\tit('should render null', () => {\n\t  const input = dedent`\n\t  <Icon a=\"{{ null }}\" />\n", "  `;\n\t  const expected = dedent`\n\t  {% render 'Icon', a: null %}\n\t  `;\n\t  testRender(input, expected);\n\t});\n\tit('should render computed', () => {\n\t  const input = dedent`\n\t  <Icon attr=\"{{ foo }}\" />\n\t  `;\n", "  const expected = dedent`\n\t  {% render 'Icon', attr: foo %}\n\t  `;\n\t  testRender(input, expected);\n\t});\n"]}
{"filename": "src/parser/errors.ts", "chunked_list": ["import { SourceLocation, codeFrameColumns } from '@babel/code-frame';\n\timport lineColumn from 'line-column';\n\timport * as ohm from 'ohm-js';\n\ttype ErrorResult = {\n\t  result: string;\n\t};\n\ttype ErrorSource = {\n\t  result: undefined;\n\t  message: string;\n\t  source: string;\n", "  locStart: number;\n\t  locEnd: number;\n\t};\n\tclass LoggableError extends Error {\n\t  constructor(info: ErrorResult | ErrorSource) {\n\t    let result = '';\n\t    if (typeof info.result === 'undefined') {\n\t      const { message, source, locStart, locEnd } = info;\n\t      const lc = lineColumn(source);\n\t      const start = lc.fromIndex(locStart);\n", "      const end = lc.fromIndex(Math.min(locEnd, source.length - 1));\n\t      const location: SourceLocation = {\n\t        start: {\n\t          line: start?.line ?? source.length - 1,\n\t          column: start?.col,\n\t        },\n\t        end: {\n\t          line: end?.line ?? source.length,\n\t          column: end?.col,\n\t        },\n", "      };\n\t      result = codeFrameColumns(source, location, {\n\t        message: message,\n\t      });\n\t    } else {\n\t      result = info.result;\n\t    }\n\t    super(result);\n\t    this.name = 'BaseError';\n\t  }\n", "}\n\texport class CSTParsingError extends LoggableError {\n\t  constructor(matchResult: ohm.MatchResult) {\n\t    super({ result: matchResult.message ?? '' });\n\t    this.name = 'CSTParsingError';\n\t  }\n\t}\n\texport class UnknownConcreteNodeTypeError extends LoggableError {\n\t  constructor(message: string, source: string, locStart: number, locEnd: number) {\n\t    super({ result: undefined, message, source, locStart, locEnd });\n", "    this.name = 'UnknownConcreteNodeTypeError';\n\t  }\n\t}\n\texport class ASTParsingError extends LoggableError {\n\t  constructor(message: string, source: string, locStart: number, locEnd: number) {\n\t    super({ result: undefined, message, source, locStart, locEnd });\n\t    this.name = 'ASTParsingError';\n\t  }\n\t}\n"]}
{"filename": "src/parser/1-source-to-cst/index.ts", "chunked_list": ["import { Node } from 'ohm-js';\n\timport { toAST } from 'ohm-js/extras';\n\timport { CSTParsingError } from '../errors';\n\timport grammar from '../grammar';\n\texport enum ConcreteNodeTypes {\n\t  TextNode = 'TextNode',\n\t  LiquidDropNode = 'LiquidDropNode',\n\t  ElementOpeningTag = 'ElementOpeningTag',\n\t  ElementClosingTag = 'ElementClosingTag',\n\t  ElementSelfClosingTag = 'ElementSelfClosingTag',\n", "  AttributeDoubleQuoted = 'AttributeDoubleQuoted',\n\t  AttributeSingleQuoted = 'AttributeSingleQuoted',\n\t  AttributeUnquoted = 'AttributeUnquoted',\n\t  AttributeEmpty = 'AttributeEmpty',\n\t}\n\texport type ConcreteNode =\n\t  | ConcreteTextNode\n\t  | ConcreteLiquidDropNode\n\t  | ConcreteElementOpeningTagNode\n\t  | ConcreteElementClosingTagNode\n", "  | ConcreteElementSelfClosingTagNode;\n\texport type ConcreteBasicNode<T> = {\n\t  type: T;\n\t  locStart: number;\n\t  locEnd: number;\n\t  source: string;\n\t};\n\texport type ConcreteTextNode = {\n\t  value: string;\n\t} & ConcreteBasicNode<ConcreteNodeTypes.TextNode>;\n", "export type ConcreteLiquidDropNode = {\n\t  value: string;\n\t} & ConcreteBasicNode<ConcreteNodeTypes.LiquidDropNode>;\n\texport type ConcreteElementOpeningTagNode = {\n\t  name: string;\n\t  attributes: ConcreteAttributeNode[];\n\t} & ConcreteBasicNode<ConcreteNodeTypes.ElementOpeningTag>;\n\texport type ConcreteElementClosingTagNode = {\n\t  name: string;\n\t} & ConcreteBasicNode<ConcreteNodeTypes.ElementClosingTag>;\n", "export type ConcreteElementSelfClosingTagNode = {\n\t  name: string;\n\t  attributes: ConcreteAttributeNode[];\n\t} & ConcreteBasicNode<ConcreteNodeTypes.ElementSelfClosingTag>;\n\texport type ConcreteAttributeNodeBase<T> = {\n\t  name: ConcreteTextNode;\n\t  value: ConcreteTextNode;\n\t} & ConcreteBasicNode<T>;\n\texport type ConcreteAttributeNode =\n\t  | ConcreteAttributeDoubleQuoted\n", "  | ConcreteAttributeSingleQuoted\n\t  | ConcreteAttributeUnquoted\n\t  | ConcreteAttributeEmpty;\n\texport type ConcreteAttributeDoubleQuoted =\n\t  {} & ConcreteAttributeNodeBase<ConcreteNodeTypes.AttributeDoubleQuoted>;\n\texport type ConcreteAttributeSingleQuoted =\n\t  {} & ConcreteAttributeNodeBase<ConcreteNodeTypes.AttributeSingleQuoted>;\n\texport type ConcreteAttributeUnquoted =\n\t  {} & ConcreteAttributeNodeBase<ConcreteNodeTypes.AttributeUnquoted>;\n\texport type ConcreteAttributeEmpty = {\n", "  name: ConcreteTextNode;\n\t} & ConcreteBasicNode<ConcreteNodeTypes.AttributeEmpty>;\n\texport type CST = ConcreteNode[];\n\texport type TemplateMapping = {\n\t  type: ConcreteNodeTypes;\n\t  locStart: (node: Node[]) => number;\n\t  locEnd: (node: Node[]) => number;\n\t  source: string;\n\t  [k: string]: string | number | boolean | object | null;\n\t};\n", "export type TopLevelFunctionMapping = (...nodes: Node[]) => any;\n\texport type Mapping = {\n\t  [k: string]: number | TemplateMapping | TopLevelFunctionMapping;\n\t};\n\tfunction locStart(nodes: Node[]) {\n\t  return nodes[0].source.startIdx;\n\t}\n\tfunction locEnd(nodes: Node[]) {\n\t  return nodes[nodes.length - 1].source.endIdx;\n\t}\n", "export default function sourceToCST(source: string): ConcreteNode[] {\n\t  const matchResult = grammar.match(source);\n\t  if (matchResult.failed()) {\n\t    throw new CSTParsingError(matchResult);\n\t  }\n\t  const textNode = {\n\t    type: ConcreteNodeTypes.TextNode,\n\t    locStart,\n\t    locEnd,\n\t    value: function (this: Node) {\n", "      return this.sourceString;\n\t    },\n\t    source,\n\t  };\n\t  const mapping: Mapping = {\n\t    Node: 0,\n\t    TextNode: textNode,\n\t    liquidDropNode: {\n\t      type: ConcreteNodeTypes.LiquidDropNode,\n\t      locStart,\n", "      locEnd,\n\t      source,\n\t      value: 2,\n\t    },\n\t    liquidDropValue: (node: Node) => node.sourceString.trimEnd(),\n\t    ElementNode: 0,\n\t    ElementOpeningTag: {\n\t      type: ConcreteNodeTypes.ElementOpeningTag,\n\t      locStart,\n\t      locEnd,\n", "      name: 1,\n\t      attributes: 2,\n\t      source,\n\t    },\n\t    ElementClosingTag: {\n\t      type: ConcreteNodeTypes.ElementClosingTag,\n\t      locStart,\n\t      locEnd,\n\t      name: 1,\n\t      source,\n", "    },\n\t    ElementSelfClosingTag: {\n\t      type: ConcreteNodeTypes.ElementSelfClosingTag,\n\t      locStart,\n\t      locEnd,\n\t      name: 1,\n\t      attributes: 2,\n\t      source,\n\t    },\n\t    AttributeDoubleQuoted: {\n", "      type: ConcreteNodeTypes.AttributeDoubleQuoted,\n\t      locStart,\n\t      locEnd,\n\t      source,\n\t      name: 0,\n\t      value: 3,\n\t    },\n\t    AttributeSingleQuoted: {\n\t      type: ConcreteNodeTypes.AttributeSingleQuoted,\n\t      locStart,\n", "      locEnd,\n\t      source,\n\t      name: 0,\n\t      value: 3,\n\t    },\n\t    AttributeUnquoted: {\n\t      type: ConcreteNodeTypes.AttributeUnquoted,\n\t      locStart,\n\t      locEnd,\n\t      source,\n", "      name: 0,\n\t      value: 2,\n\t    },\n\t    AttributeEmpty: {\n\t      type: ConcreteNodeTypes.AttributeEmpty,\n\t      locStart,\n\t      locEnd,\n\t      source,\n\t      name: 0,\n\t    },\n", "    attributeName: textNode,\n\t    attributeDoubleQuotedValue: 0,\n\t    attributeSingleQuotedValue: 0,\n\t    attributeUnquotedValue: 0,\n\t    attributeDoubleQuotedTextNode: textNode,\n\t    attributeSingleQuotedTextNode: textNode,\n\t    attributeUnquotedTextNode: textNode,\n\t  };\n\t  const cst = toAST(matchResult, mapping) as ConcreteNode[];\n\t  return cst;\n", "}\n"]}
{"filename": "src/parser/1-source-to-cst/__tests__/text-node.test.ts", "chunked_list": ["import { expectOutput } from './utils';\n\tit('should parse plain text', () => {\n\t  const input = 'Plain text';\n\t  expectOutput(input).toHaveProperty('0.type', 'TextNode');\n\t  expectOutput(input).toHaveProperty('0.value', 'Plain text');\n\t});\n\tit('should parse native HTML elements', () => {\n\t  const input = '<button></button>';\n\t  expectOutput(input).toHaveProperty('0.type', 'TextNode');\n\t  expectOutput(input).toHaveProperty('0.value', '<button></button>');\n", "});\n\tit('should parse custom HTML elements', () => {\n\t  const input = '<custom-button></custom-button>';\n\t  expectOutput(input).toHaveProperty('0.type', 'TextNode');\n\t  expectOutput(input).toHaveProperty('0.value', '<custom-button></custom-button>');\n\t});\n"]}
{"filename": "src/parser/1-source-to-cst/__tests__/utils.ts", "chunked_list": ["import sourceToCST from '../';\n\texport function expectOutput(input: string) {\n\t  const output = sourceToCST(input);\n\t  return expect(output);\n\t}\n"]}
{"filename": "src/parser/1-source-to-cst/__tests__/index.ts", "chunked_list": ["import { getRootSuiteName, requireAll } from '@/utils/tests';\n\tdescribe(getRootSuiteName(__dirname), () => {\n\t  requireAll(__dirname);\n\t});\n"]}
{"filename": "src/parser/1-source-to-cst/__tests__/element-node.test.ts", "chunked_list": ["import { expectOutput } from './utils';\n\tdescribe('opening tag', () => {\n\t  it('should parse without attributes', () => {\n\t    const input = '<Button>';\n\t    expectOutput(input).toHaveProperty('0.type', 'ElementOpeningTag');\n\t    expectOutput(input).toHaveProperty('0.name', 'Button');\n\t    expectOutput(input).toHaveProperty('0.attributes.length', 0);\n\t  });\n\t  it('should parse with single attribute', () => {\n\t    const input = '<Button secondary>';\n", "    expectOutput(input).toHaveProperty('0.type', 'ElementOpeningTag');\n\t    expectOutput(input).toHaveProperty('0.name', 'Button');\n\t    expectOutput(input).toHaveProperty('0.attributes.0.name.value', 'secondary');\n\t    expectOutput(input).toHaveProperty('0.attributes.length', 1);\n\t  });\n\t  it('should parse with multiple attributes', () => {\n\t    const input = '<Button secondary icon=\"IconShoppingBag\">';\n\t    expectOutput(input).toHaveProperty('0.type', 'ElementOpeningTag');\n\t    expectOutput(input).toHaveProperty('0.name', 'Button');\n\t    expectOutput(input).toHaveProperty('0.attributes.0.name.value', 'secondary');\n", "    expectOutput(input).toHaveProperty('0.attributes.1.name.value', 'icon');\n\t    expectOutput(input).toHaveProperty('0.attributes.length', 2);\n\t  });\n\t});\n\tdescribe('closing tag', () => {\n\t  it('should parse', () => {\n\t    const input = '</Button>';\n\t    expectOutput(input).toHaveProperty('0.type', 'ElementClosingTag');\n\t    expectOutput(input).toHaveProperty('0.name', 'Button');\n\t  });\n", "});\n\tdescribe('self-closing tag', () => {\n\t  it('should parse without attributes', () => {\n\t    const input = '<Icon/>';\n\t    expectOutput(input).toHaveProperty('0.type', 'ElementSelfClosingTag');\n\t    expectOutput(input).toHaveProperty('0.name', 'Icon');\n\t    expectOutput(input).toHaveProperty('0.attributes.length', 0);\n\t  });\n\t  it('should parse with single attribute', () => {\n\t    const input = '<Icon icon=\"IconShoppingBag\" />';\n", "    expectOutput(input).toHaveProperty('0.type', 'ElementSelfClosingTag');\n\t    expectOutput(input).toHaveProperty('0.name', 'Icon');\n\t    expectOutput(input).toHaveProperty('0.attributes.0.name.value', 'icon');\n\t    expectOutput(input).toHaveProperty('0.attributes.length', 1);\n\t  });\n\t  it('should parse with multiple attributes', () => {\n\t    const input = '<Icon icon=\"IconShoppingBag\" size=\"sm\" />';\n\t    expectOutput(input).toHaveProperty('0.type', 'ElementSelfClosingTag');\n\t    expectOutput(input).toHaveProperty('0.name', 'Icon');\n\t    expectOutput(input).toHaveProperty('0.attributes.0.name.value', 'icon');\n", "    expectOutput(input).toHaveProperty('0.attributes.1.name.value', 'size');\n\t    expectOutput(input).toHaveProperty('0.attributes.length', 2);\n\t  });\n\t});\n\tdescribe('attributes', () => {\n\t  it('should parse double quoted attribute', () => {\n\t    const input = '<Button attr=\"test\">';\n\t    expectOutput(input).toHaveProperty('0.attributes.0.type', 'AttributeDoubleQuoted');\n\t  });\n\t  it('should parse single quoted attribute', () => {\n", "    const input = \"<Button attr='test'>\";\n\t    expectOutput(input).toHaveProperty('0.attributes.0.type', 'AttributeSingleQuoted');\n\t  });\n\t  it('should parse unquoted attribute', () => {\n\t    const input = '<Button attr=test>';\n\t    expectOutput(input).toHaveProperty('0.attributes.0.type', 'AttributeUnquoted');\n\t  });\n\t  it('should parse empty attribute', () => {\n\t    const input = '<Button attr>';\n\t    expectOutput(input).toHaveProperty('0.attributes.0.type', 'AttributeEmpty');\n", "  });\n\t  describe('values', () => {\n\t    it('should parse text attribute value', () => {\n\t      const input = '<Button attr1=\"test\" attr2=\"0\" attr3=\"true\">';\n\t      expectOutput(input).toHaveProperty('0.attributes.0.name.value', 'attr1');\n\t      expectOutput(input).toHaveProperty('0.attributes.0.value.type', 'TextNode');\n\t      expectOutput(input).toHaveProperty('0.attributes.0.value.value', 'test');\n\t      expectOutput(input).toHaveProperty('0.attributes.1.name.value', 'attr2');\n\t      expectOutput(input).toHaveProperty('0.attributes.1.value.type', 'TextNode');\n\t      expectOutput(input).toHaveProperty('0.attributes.1.value.value', '0');\n", "      expectOutput(input).toHaveProperty('0.attributes.2.name.value', 'attr3');\n\t      expectOutput(input).toHaveProperty('0.attributes.2.value.type', 'TextNode');\n\t      expectOutput(input).toHaveProperty('0.attributes.2.value.value', 'true');\n\t    });\n\t    it('should parse liquid drop attribute value', () => {\n\t      const input = '<Button attr1=\"{{ \\'test\\' }}\" attr2=\"{{ 0 }}\" attr3=\"{{ true }}\">';\n\t      expectOutput(input).toHaveProperty('0.attributes.0.name.value', 'attr1');\n\t      expectOutput(input).toHaveProperty('0.attributes.0.value.type', 'LiquidDropNode');\n\t      expectOutput(input).toHaveProperty('0.attributes.0.value.value', \"'test'\");\n\t      expectOutput(input).toHaveProperty('0.attributes.1.name.value', 'attr2');\n", "      expectOutput(input).toHaveProperty('0.attributes.1.value.type', 'LiquidDropNode');\n\t      expectOutput(input).toHaveProperty('0.attributes.1.value.value', '0');\n\t      expectOutput(input).toHaveProperty('0.attributes.2.name.value', 'attr3');\n\t      expectOutput(input).toHaveProperty('0.attributes.2.value.type', 'LiquidDropNode');\n\t      expectOutput(input).toHaveProperty('0.attributes.2.value.value', 'true');\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/parser/2-cst-to-ast/ast-builder.ts", "chunked_list": ["import { ElementNode, LiquidXNode, NodeTypes } from '.';\n\timport {\n\t  ConcreteElementClosingTagNode,\n\t  ConcreteElementSelfClosingTagNode,\n\t} from '../1-source-to-cst';\n\timport { ASTParsingError } from '../errors';\n\timport { deepGet, dropLast } from './utils';\n\texport default class ASTBuilder {\n\t  ast: LiquidXNode[];\n\t  cursor: (string | number)[];\n", "  source: string;\n\t  constructor(source: string) {\n\t    this.ast = [];\n\t    this.cursor = [];\n\t    this.source = source;\n\t  }\n\t  get current(): LiquidXNode[] {\n\t    return deepGet<LiquidXNode[]>(this.cursor, this.ast);\n\t  }\n\t  get currentPosition(): number {\n", "    return (this.current || []).length - 1;\n\t  }\n\t  get parent(): ElementNode | undefined {\n\t    if (this.cursor.length == 0) return undefined;\n\t    return deepGet<ElementNode>(dropLast(1, this.cursor), this.ast);\n\t  }\n\t  open(node: ElementNode) {\n\t    this.push(node);\n\t    this.cursor.push(this.currentPosition);\n\t    this.cursor.push('children');\n", "  }\n\t  close(\n\t    node: ConcreteElementClosingTagNode | ConcreteElementSelfClosingTagNode,\n\t    nodeType: NodeTypes.ElementNode,\n\t  ) {\n\t    if (!this.parent || this.parent.name !== node.name || this.parent.type !== nodeType) {\n\t      throw new ASTParsingError(\n\t        `LiquidX element '${node.name}' has no corresponding opening tag`,\n\t        this.source,\n\t        node.locStart,\n", "        node.locEnd,\n\t      );\n\t    }\n\t    this.parent.locEnd = node.locEnd;\n\t    this.cursor.pop();\n\t    this.cursor.pop();\n\t  }\n\t  push(node: LiquidXNode) {\n\t    this.current.push(node);\n\t  }\n", "  finish() {\n\t    if (this.cursor.length > 0) {\n\t      throw new ASTParsingError(\n\t        `LiquidX element '${this.parent?.name}' has no corresponding closing tag.`,\n\t        this.source,\n\t        this.parent?.locStart ?? this.source.length - 1,\n\t        this.parent?.locEnd ?? this.source.length,\n\t      );\n\t    }\n\t    return this.ast;\n", "  }\n\t}\n"]}
{"filename": "src/parser/2-cst-to-ast/utils.ts", "chunked_list": ["export function deepGet<T = any>(path: (string | number)[], obj: any): T {\n\t  return path.reduce((curr: any, k: string | number) => {\n\t    if (curr && curr[k] !== undefined) return curr[k];\n\t    return undefined;\n\t  }, obj);\n\t}\n\texport function dropLast<T>(num: number, xs: readonly T[]) {\n\t  const result = [...xs];\n\t  for (let i = 0; i < num; i += 1) {\n\t    result.pop();\n", "  }\n\t  return result;\n\t}\n"]}
{"filename": "src/parser/2-cst-to-ast/index.ts", "chunked_list": ["import sourceToCST, {\n\t  ConcreteAttributeNode,\n\t  ConcreteElementOpeningTagNode,\n\t  ConcreteElementSelfClosingTagNode,\n\t  ConcreteLiquidDropNode,\n\t  ConcreteNode,\n\t  ConcreteNodeTypes,\n\t  ConcreteTextNode,\n\t} from '../1-source-to-cst';\n\timport { UnknownConcreteNodeTypeError } from '../errors';\n", "import ASTBuilder from './ast-builder';\n\texport type BasicNode<T> = {\n\t  type: T;\n\t  locStart: number;\n\t  locEnd: number;\n\t  source: string;\n\t};\n\texport enum NodeTypes {\n\t  TextNode = 'TextNode',\n\t  LiquidDropNode = 'LiquidDropNode',\n", "  ElementNode = 'ElementNode',\n\t  AttributeDoubleQuoted = 'AttributeDoubleQuoted',\n\t  AttributeSingleQuoted = 'AttributeSingleQuoted',\n\t  AttributeUnquoted = 'AttributeUnquoted',\n\t  AttributeEmpty = 'AttributeEmpty',\n\t}\n\texport type TextNode = {\n\t  value: string;\n\t} & BasicNode<NodeTypes.TextNode>;\n\texport type LiquidDropNode = {\n", "  value: string;\n\t} & BasicNode<NodeTypes.LiquidDropNode>;\n\texport type LiquidXNode = TextNode | LiquidDropNode | ElementNode | AttributeNode;\n\texport type ElementNode = {\n\t  name: string;\n\t  source: string;\n\t  attributes: AttributeNode[];\n\t  children: LiquidXNode[];\n\t} & BasicNode<NodeTypes.ElementNode>;\n\texport type AttributeNode =\n", "  | AttributeDoubleQuoted\n\t  | AttributeSingleQuoted\n\t  | AttributeUnquoted\n\t  | AttributeEmpty;\n\texport type AttributeNodeBase<T> = {\n\t  name: TextNode;\n\t  value: TextNode | LiquidDropNode;\n\t} & BasicNode<T>;\n\texport type AttributeDoubleQuoted = {} & AttributeNodeBase<NodeTypes.AttributeDoubleQuoted>;\n\texport type AttributeSingleQuoted = {} & AttributeNodeBase<NodeTypes.AttributeSingleQuoted>;\n", "export type AttributeUnquoted = {} & AttributeNodeBase<NodeTypes.AttributeUnquoted>;\n\texport type AttributeEmpty = { name: TextNode } & BasicNode<NodeTypes.AttributeEmpty>;\n\tfunction toTextNode(node: ConcreteTextNode): TextNode {\n\t  return {\n\t    type: NodeTypes.TextNode,\n\t    locStart: node.locStart,\n\t    locEnd: node.locEnd,\n\t    source: node.source,\n\t    value: node.value,\n\t  };\n", "}\n\tfunction toLiquidDropNode(node: ConcreteLiquidDropNode): LiquidDropNode {\n\t  return {\n\t    type: NodeTypes.LiquidDropNode,\n\t    locStart: node.locStart,\n\t    locEnd: node.locEnd,\n\t    source: node.source,\n\t    value: node.value,\n\t  };\n\t}\n", "function toElementNode(\n\t  node: ConcreteElementOpeningTagNode | ConcreteElementSelfClosingTagNode,\n\t): ElementNode {\n\t  return {\n\t    type: NodeTypes.ElementNode,\n\t    locStart: node.locStart,\n\t    locEnd: node.locEnd,\n\t    name: node.name,\n\t    source: node.source,\n\t    attributes: toAttributes(node.attributes),\n", "    children: [],\n\t  };\n\t}\n\tfunction toAttributes(attributes: ConcreteAttributeNode[]) {\n\t  return cstToAST(attributes) as AttributeNode[];\n\t}\n\tfunction toAttributeValue(value: ConcreteTextNode | ConcreteLiquidDropNode) {\n\t  return cstToAST([value])[0] as TextNode | LiquidDropNode;\n\t}\n\tfunction isAttributeNode(node: any): boolean {\n", "  return (\n\t    node.type === ConcreteNodeTypes.AttributeDoubleQuoted ||\n\t    node.type === ConcreteNodeTypes.AttributeSingleQuoted ||\n\t    node.type === ConcreteNodeTypes.AttributeUnquoted ||\n\t    node.type === ConcreteNodeTypes.AttributeEmpty\n\t  );\n\t}\n\tfunction cstToAST(cst: ConcreteNode[] | ConcreteAttributeNode[]) {\n\t  if (cst.length === 0) return [];\n\t  const astBuilder = new ASTBuilder(cst[0].source);\n", "  for (let i = 0; i < cst.length; i += 1) {\n\t    const node = cst[i];\n\t    const prevNode = cst[i - 1];\n\t    // Add whitespaces and linebreaks that went missing after parsing. We don't need to do this\n\t    // if the node is an attribute since whitespaces between attributes is not important to preserve.\n\t    // In fact it would probably break the rendered output due to unexpected text nodes.\n\t    // TODO: This should be handled in the grammar/source-to-cst part instead (if possible).\n\t    if (prevNode?.source && !isAttributeNode(node)) {\n\t      const diff = node.locStart - prevNode.locEnd;\n\t      if (diff > 0) {\n", "        astBuilder.push(\n\t          toTextNode({\n\t            type: ConcreteNodeTypes.TextNode,\n\t            locStart: prevNode.locEnd,\n\t            locEnd: node.locStart,\n\t            source: node.source,\n\t            value: prevNode.source.slice(prevNode.locEnd, node.locStart),\n\t          }),\n\t        );\n\t      }\n", "    }\n\t    switch (node.type) {\n\t      case ConcreteNodeTypes.TextNode: {\n\t        astBuilder.push(toTextNode(node));\n\t        break;\n\t      }\n\t      case ConcreteNodeTypes.LiquidDropNode: {\n\t        astBuilder.push(toLiquidDropNode(node));\n\t        break;\n\t      }\n", "      case ConcreteNodeTypes.ElementOpeningTag: {\n\t        astBuilder.open(toElementNode(node));\n\t        break;\n\t      }\n\t      case ConcreteNodeTypes.ElementClosingTag: {\n\t        astBuilder.close(node, NodeTypes.ElementNode);\n\t        break;\n\t      }\n\t      case ConcreteNodeTypes.ElementSelfClosingTag: {\n\t        astBuilder.open(toElementNode(node));\n", "        astBuilder.close(node, NodeTypes.ElementNode);\n\t        break;\n\t      }\n\t      case ConcreteNodeTypes.AttributeDoubleQuoted:\n\t      case ConcreteNodeTypes.AttributeSingleQuoted:\n\t      case ConcreteNodeTypes.AttributeUnquoted: {\n\t        const attributeNode: AttributeDoubleQuoted | AttributeSingleQuoted | AttributeUnquoted = {\n\t          type: node.type as unknown as\n\t            | NodeTypes.AttributeDoubleQuoted\n\t            | NodeTypes.AttributeSingleQuoted\n", "            | NodeTypes.AttributeUnquoted,\n\t          locStart: node.locStart,\n\t          locEnd: node.locEnd,\n\t          source: node.source,\n\t          name: cstToAST([node.name])[0] as TextNode,\n\t          value: toAttributeValue(node.value),\n\t        };\n\t        astBuilder.push(attributeNode);\n\t        break;\n\t      }\n", "      case ConcreteNodeTypes.AttributeEmpty: {\n\t        const attributeNode: AttributeEmpty = {\n\t          type: NodeTypes.AttributeEmpty,\n\t          locStart: node.locStart,\n\t          locEnd: node.locEnd,\n\t          source: node.source,\n\t          name: cstToAST([node.name])[0] as TextNode,\n\t        };\n\t        astBuilder.push(attributeNode);\n\t        break;\n", "      }\n\t      default: {\n\t        throw new UnknownConcreteNodeTypeError(\n\t          '',\n\t          (node as any)?.source,\n\t          (node as any)?.locStart,\n\t          (node as any)?.locEnd,\n\t        );\n\t      }\n\t    }\n", "  }\n\t  return astBuilder.finish();\n\t}\n\texport default function sourceToAST(source: string): LiquidXNode[] {\n\t  const cst = sourceToCST(source);\n\t  const ast = cstToAST(cst);\n\t  return ast;\n\t}\n"]}
{"filename": "src/parser/2-cst-to-ast/__tests__/text-node.test.ts", "chunked_list": ["import { NodeTypes } from '..';\n\timport { expectOutput } from './utils';\n\tit('should parse plain text', () => {\n\t  const input = 'Plain text';\n\t  expectOutput(input).toHaveProperty('0.type', NodeTypes.TextNode);\n\t  expectOutput(input).toHaveProperty('0.value', 'Plain text');\n\t});\n\tit('should parse native HTML elements', () => {\n\t  const input = '<button></button>';\n\t  expectOutput(input).toHaveProperty('0.type', NodeTypes.TextNode);\n", "  expectOutput(input).toHaveProperty('0.value', '<button></button>');\n\t});\n\tit('should parse custom HTML elements', () => {\n\t  const input = '<custom-button></custom-button>';\n\t  expectOutput(input).toHaveProperty('0.type', NodeTypes.TextNode);\n\t  expectOutput(input).toHaveProperty('0.value', '<custom-button></custom-button>');\n\t});\n"]}
{"filename": "src/parser/2-cst-to-ast/__tests__/utils.ts", "chunked_list": ["import sourceToAST from '../';\n\texport function expectOutput(input: string) {\n\t  const output = sourceToAST(input);\n\t  return expect(output);\n\t}\n\texport function expectErrorMessage(input: string) {\n\t  let errorMessage = '';\n\t  try {\n\t    sourceToAST(input);\n\t  } catch (error: any) {\n", "    errorMessage = error.message;\n\t  }\n\t  return expect(errorMessage);\n\t}\n"]}
{"filename": "src/parser/2-cst-to-ast/__tests__/index.ts", "chunked_list": ["import { getRootSuiteName, requireAll } from '@/utils/tests';\n\tdescribe(getRootSuiteName(__dirname), () => {\n\t  requireAll(__dirname);\n\t});\n"]}
{"filename": "src/parser/2-cst-to-ast/__tests__/element-node.test.ts", "chunked_list": ["import { NodeTypes } from '..';\n\timport { expectErrorMessage, expectOutput } from './utils';\n\tit('should parse without children', () => {\n\t  const input = '<Button></Button>';\n\t  expectOutput(input).toHaveProperty('0.type', NodeTypes.ElementNode);\n\t  expectOutput(input).toHaveProperty('0.name', 'Button');\n\t  expectOutput(input).toHaveProperty('0.children', []);\n\t});\n\tit('should parse with text children', () => {\n\t  const input = '<Button>Plain text</Button>';\n", "  expectOutput(input).toHaveProperty('0.type', NodeTypes.ElementNode);\n\t  expectOutput(input).toHaveProperty('0.name', 'Button');\n\t  expectOutput(input).toHaveProperty('0.children.0.type', NodeTypes.TextNode);\n\t});\n\tit('should parse with element children', () => {\n\t  const input = '<Box><Button>Plain text</Button></Box>';\n\t  expectOutput(input).toHaveProperty('0.type', NodeTypes.ElementNode);\n\t  expectOutput(input).toHaveProperty('0.name', 'Box');\n\t  expectOutput(input).toHaveProperty('0.children.0.type', NodeTypes.ElementNode);\n\t  expectOutput(input).toHaveProperty('0.children.0.name', 'Button');\n", "  expectOutput(input).toHaveProperty('0.children.0.children.0.type', NodeTypes.TextNode);\n\t});\n\tit('should throw an error if corresponding closing tag is missing', () => {\n\t  const input = '<Box>';\n\t  expectErrorMessage(input).toMatchSnapshot();\n\t});\n\tit('should throw an error if corresponding opening tag is missing', () => {\n\t  const input = '</Box>';\n\t  expectErrorMessage(input).toMatchSnapshot();\n\t});\n"]}
{"filename": "src/parser/grammar/index.ts", "chunked_list": ["import * as fs from 'fs';\n\timport * as ohm from 'ohm-js';\n\timport * as path from 'path';\n\texport const grammars = ohm.grammars(fs.readFileSync(path.join(__dirname, 'liquidx.ohm'), 'utf8'));\n\texport default grammars['LiquidX'];\n"]}
{"filename": "src/parser/grammar/__tests__/grammar.test.ts", "chunked_list": ["import grammar from '..';\n\tit('should parse plain text', () => {\n\t  expectMatchSucceeded('Hello, World!').toBe(true);\n\t  expectMatchSucceeded('<a').toBe(true);\n\t  expectMatchSucceeded('<1').toBe(true);\n\t  expectMatchSucceeded('2 < 3').toBe(true);\n\t});\n\tit('should parse valid HTML tags', () => {\n\t  expectMatchSucceeded('<button></button>').toBe(true);\n\t  expectMatchSucceeded('<button type=\"submit\"></button>').toBe(true);\n", "  expectMatchSucceeded('<button>').toBe(true);\n\t  expectMatchSucceeded('</button>').toBe(true);\n\t  expectMatchSucceeded('<a>').toBe(true);\n\t  expectMatchSucceeded('<img />').toBe(true);\n\t});\n\tit('should parse invalid HTML tags', () => {\n\t  expectMatchSucceeded('< button>').toBe(true);\n\t  expectMatchSucceeded('<button').toBe(true);\n\t  expectMatchSucceeded('<button attr').toBe(true);\n\t  expectMatchSucceeded('button>').toBe(true);\n", "  expectMatchSucceeded('button attr>').toBe(true);\n\t  expectMatchSucceeded('</button').toBe(true);\n\t  expectMatchSucceeded('img />').toBe(true);\n\t  expectMatchSucceeded('img attr />').toBe(true);\n\t});\n\tit('should parse valid LiquidX tags', () => {\n\t  expectMatchSucceeded('<Button></Button>').toBe(true);\n\t  expectMatchSucceeded('<Button type=\"submit\"></Button>').toBe(true);\n\t  expectMatchSucceeded('<Button>').toBe(true);\n\t  expectMatchSucceeded('</Button>').toBe(true);\n", "  expectMatchSucceeded('<A>').toBe(true);\n\t  expectMatchSucceeded('<Image />').toBe(true);\n\t});\n\tit('should not parse invalid LiquidX tags', () => {\n\t  expectMatchSucceeded('< Button>').toBe(false);\n\t  expectMatchSucceeded('<Button').toBe(false);\n\t  expectMatchSucceeded('<Button attr').toBe(false);\n\t  expectMatchSucceeded('Button>').toBe(false);\n\t  expectMatchSucceeded('Button attr>').toBe(false);\n\t  expectMatchSucceeded('</Button').toBe(false);\n", "  expectMatchSucceeded('Image />').toBe(false);\n\t  expectMatchSucceeded('Image attr />').toBe(false);\n\t});\n\tfunction expectMatchSucceeded(source: string) {\n\t  const match = grammar.match(source);\n\t  return expect(match.succeeded());\n\t}\n"]}
{"filename": "src/parser/grammar/__tests__/index.ts", "chunked_list": ["import { getRootSuiteName, requireAll } from '@/utils/tests';\n\tdescribe(getRootSuiteName(__dirname), () => {\n\t  requireAll(__dirname);\n\t});\n"]}
