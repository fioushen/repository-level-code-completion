{"filename": "src/middleware.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-explicit-any */\n\t// middleware.ts\n\timport { NextResponse } from \"next/server\";\n\timport type { NextRequest } from \"next/server\";\n\texport default async function middleware(req: NextRequest) {\n\t  const url = req.nextUrl.clone();\n\t  const {\n\t    data: { auth },\n\t  } = await fetch(`${url.origin}/api/authSSR`, {\n\t    headers: req.headers,\n", "  }).then((res) => res.json());\n\t  url.search = new URLSearchParams(`callbackUrl=${url}`).toString();\n\t  url.pathname = `/api/auth/signin`;\n\t  return !auth ? NextResponse.redirect(url) : NextResponse.next();\n\t}\n\texport const config = {\n\t  matcher: [\"/dashboard\", \"/dashboard/courses\"],\n\t};\n"]}
{"filename": "src/pages/api/authSSR.ts", "chunked_list": ["import { NextApiRequest, NextApiResponse } from \"next\";\n\timport { getSession } from \"next-auth/react\";\n\texport default async function handle(\n\t  req: NextApiRequest,\n\t  res: NextApiResponse\n\t) {\n\t  const session = await getSession({ req });\n\t  res.json({ data: { auth: !!session } });\n\t}\n"]}
{"filename": "src/pages/api/trpc/[trpc].ts", "chunked_list": ["import { createNextApiHandler } from \"@trpc/server/adapters/next\";\n\timport { env } from \"~/env.mjs\";\n\timport { createTRPCContext } from \"~/server/api/trpc\";\n\timport { appRouter } from \"~/server/api/root\";\n\t// export API handler\n\texport default createNextApiHandler({\n\t  router: appRouter,\n\t  createContext: createTRPCContext,\n\t  onError:\n\t    env.NODE_ENV === \"development\"\n", "      ? ({ path, error }) => {\n\t          console.error(\n\t            `‚ùå tRPC failed on ${path ?? \"<no-path>\"}: ${error.message}`,\n\t          );\n\t        }\n\t      : undefined,\n\t});\n"]}
{"filename": "src/pages/api/auth/[...nextauth].ts", "chunked_list": ["import NextAuth from \"next-auth\";\n\timport { authOptions } from \"~/server/auth\";\n\texport default NextAuth(authOptions);\n"]}
{"filename": "src/utils/api.ts", "chunked_list": ["/**\n\t * This is the client-side entrypoint for your tRPC API. It is used to create the `api` object which\n\t * contains the Next.js App-wrapper, as well as your type-safe React Query hooks.\n\t *\n\t * We also create a few inference helpers for input and output types.\n\t */\n\timport { httpBatchLink, loggerLink } from \"@trpc/client\";\n\timport { createTRPCNext } from \"@trpc/next\";\n\timport { type inferRouterInputs, type inferRouterOutputs } from \"@trpc/server\";\n\timport superjson from \"superjson\";\n", "import { type AppRouter } from \"~/server/api/root\";\n\tconst getBaseUrl = () => {\n\t  if (typeof window !== \"undefined\") return \"\"; // browser should use relative url\n\t  if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`; // SSR should use vercel url\n\t  return `http://localhost:${process.env.PORT ?? 3000}`; // dev SSR should use localhost\n\t};\n\t/** A set of type-safe react-query hooks for your tRPC API. */\n\texport const api = createTRPCNext<AppRouter>({\n\t  config() {\n\t    return {\n", "      /**\n\t       * Transformer used for data de-serialization from the server.\n\t       *\n\t       * @see https://trpc.io/docs/data-transformers\n\t       */\n\t      transformer: superjson,\n\t      /**\n\t       * Links used to determine request flow from client to server.\n\t       *\n\t       * @see https://trpc.io/docs/links\n", "       */\n\t      links: [\n\t        loggerLink({\n\t          enabled: (opts) =>\n\t            process.env.NODE_ENV === \"development\" ||\n\t            (opts.direction === \"down\" && opts.result instanceof Error),\n\t        }),\n\t        httpBatchLink({\n\t          url: `${getBaseUrl()}/api/trpc`,\n\t        }),\n", "      ],\n\t    };\n\t  },\n\t  /**\n\t   * Whether tRPC should await queries when server rendering pages.\n\t   *\n\t   * @see https://trpc.io/docs/nextjs#ssr-boolean-default-false\n\t   */\n\t  ssr: false,\n\t});\n", "/**\n\t * Inference helper for inputs.\n\t *\n\t * @example type HelloInput = RouterInputs['example']['hello']\n\t */\n\texport type RouterInputs = inferRouterInputs<AppRouter>;\n\t/**\n\t * Inference helper for outputs.\n\t *\n\t * @example type HelloOutput = RouterOutputs['example']['hello']\n", " */\n\texport type RouterOutputs = inferRouterOutputs<AppRouter>;\n"]}
{"filename": "src/utils/getImageUrl.ts", "chunked_list": ["import { env } from \"~/env.mjs\";\n\texport function getImageUrl(id: string) {\n\t  return `http://localhost:9000/${env.NEXT_PUBLIC_S3_BUCKET_NAME}/${id}`;\n\t}\n"]}
{"filename": "src/server/auth.ts", "chunked_list": ["import { type GetServerSidePropsContext } from \"next\";\n\timport {\n\t  getServerSession,\n\t  type NextAuthOptions,\n\t  type DefaultSession,\n\t} from \"next-auth\";\n\timport GoogleProvider from \"next-auth/providers/google\";\n\timport { PrismaAdapter } from \"@next-auth/prisma-adapter\";\n\timport { env } from \"~/env.mjs\";\n\timport { prisma } from \"~/server/db\";\n", "/**\n\t * Module augmentation for `next-auth` types. Allows us to add custom properties to the `session`\n\t * object and keep type safety.\n\t *\n\t * @see https://next-auth.js.org/getting-started/typescript#module-augmentation\n\t */\n\tdeclare module \"next-auth\" {\n\t  interface Session extends DefaultSession {\n\t    user: {\n\t      id: string;\n", "      // ...other properties\n\t      // role: UserRole;\n\t    } & DefaultSession[\"user\"];\n\t  }\n\t  // interface User {\n\t  //   // ...other properties\n\t  //   // role: UserRole;\n\t  // }\n\t}\n\t/**\n", " * Options for NextAuth.js used to configure adapters, providers, callbacks, etc.\n\t *\n\t * @see https://next-auth.js.org/configuration/options\n\t */\n\texport const authOptions: NextAuthOptions = {\n\t  callbacks: {\n\t    session: ({ session, user }) => ({\n\t      ...session,\n\t      user: {\n\t        ...session.user,\n", "        id: user.id,\n\t      },\n\t    }),\n\t  },\n\t  adapter: PrismaAdapter(prisma),\n\t  providers: [\n\t    GoogleProvider({\n\t      clientId: env.GOOGLE_CLIENT_ID,\n\t      clientSecret: env.GOOGLE_CLIENT_SECRET,\n\t    }),\n", "    /**\n\t     * ...add more providers here.\n\t     *\n\t     * Most other providers require a bit more work than the Discord provider. For example, the\n\t     * GitHub provider requires you to add the `refresh_token_expires_in` field to the Account\n\t     * model. Refer to the NextAuth.js docs for the provider you want to use. Example:\n\t     *\n\t     * @see https://next-auth.js.org/providers/github\n\t     */\n\t  ],\n", "};\n\t/**\n\t * Wrapper for `getServerSession` so that you don't need to import the `authOptions` in every file.\n\t *\n\t * @see https://next-auth.js.org/configuration/nextjs\n\t */\n\texport const getServerAuthSession = (ctx: {\n\t  req: GetServerSidePropsContext[\"req\"];\n\t  res: GetServerSidePropsContext[\"res\"];\n\t}) => {\n", "  return getServerSession(ctx.req, ctx.res, authOptions);\n\t};\n"]}
{"filename": "src/server/db.ts", "chunked_list": ["import { PrismaClient } from \"@prisma/client\";\n\timport { env } from \"~/env.mjs\";\n\tconst globalForPrisma = globalThis as unknown as {\n\t  prisma: PrismaClient | undefined;\n\t};\n\texport const prisma =\n\t  globalForPrisma.prisma ??\n\t  new PrismaClient({\n\t    log:\n\t      env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n", "  });\n\tif (env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n"]}
{"filename": "src/server/api/trpc.ts", "chunked_list": ["/**\n\t * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:\n\t * 1. You want to modify request context (see Part 1).\n\t * 2. You want to create a new middleware or type of procedure (see Part 3).\n\t *\n\t * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will\n\t * need to use are documented accordingly near the end.\n\t */\n\t/**\n\t * 1. CONTEXT\n", " *\n\t * This section defines the \"contexts\" that are available in the backend API.\n\t *\n\t * These allow you to access things when processing a request, like the database, the session, etc.\n\t */\n\timport { type CreateNextContextOptions } from \"@trpc/server/adapters/next\";\n\timport { type Session } from \"next-auth\";\n\timport { getServerAuthSession } from \"~/server/auth\";\n\timport { prisma } from \"~/server/db\";\n\ttype CreateContextOptions = {\n", "  session: Session | null;\n\t};\n\t/**\n\t * This helper generates the \"internals\" for a tRPC context. If you need to use it, you can export\n\t * it from here.\n\t *\n\t * Examples of things you may need it for:\n\t * - testing, so we don't have to mock Next.js' req/res\n\t * - tRPC's `createSSGHelpers`, where we don't have req/res\n\t *\n", " * @see https://create.t3.gg/en/usage/trpc#-serverapitrpcts\n\t */\n\tconst createInnerTRPCContext = (opts: CreateContextOptions) => {\n\t  return {\n\t    session: opts.session,\n\t    prisma,\n\t  };\n\t};\n\t/**\n\t * This is the actual context you will use in your router. It will be used to process every request\n", " * that goes through your tRPC endpoint.\n\t *\n\t * @see https://trpc.io/docs/context\n\t */\n\texport const createTRPCContext = async (opts: CreateNextContextOptions) => {\n\t  const { req, res } = opts;\n\t  // Get the session from the server using the getServerSession wrapper function\n\t  const session = await getServerAuthSession({ req, res });\n\t  return createInnerTRPCContext({\n\t    session,\n", "  });\n\t};\n\t/**\n\t * 2. INITIALIZATION\n\t *\n\t * This is where the tRPC API is initialized, connecting the context and transformer. We also parse\n\t * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation\n\t * errors on the backend.\n\t */\n\timport { initTRPC, TRPCError } from \"@trpc/server\";\n", "import superjson from \"superjson\";\n\timport { ZodError } from \"zod\";\n\tconst t = initTRPC.context<typeof createTRPCContext>().create({\n\t  transformer: superjson,\n\t  errorFormatter({ shape, error }) {\n\t    return {\n\t      ...shape,\n\t      data: {\n\t        ...shape.data,\n\t        zodError:\n", "          error.cause instanceof ZodError ? error.cause.flatten() : null,\n\t      },\n\t    };\n\t  },\n\t});\n\t/**\n\t * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)\n\t *\n\t * These are the pieces you use to build your tRPC API. You should import these a lot in the\n\t * \"/src/server/api/routers\" directory.\n", " */\n\t/**\n\t * This is how you create new routers and sub-routers in your tRPC API.\n\t *\n\t * @see https://trpc.io/docs/router\n\t */\n\texport const createTRPCRouter = t.router;\n\t/**\n\t * Public (unauthenticated) procedure\n\t *\n", " * This is the base piece you use to build new queries and mutations on your tRPC API. It does not\n\t * guarantee that a user querying is authorized, but you can still access user session data if they\n\t * are logged in.\n\t */\n\texport const publicProcedure = t.procedure;\n\t/** Reusable middleware that enforces users are logged in before running the procedure. */\n\tconst enforceUserIsAuthed = t.middleware(({ ctx, next }) => {\n\t  if (!ctx.session || !ctx.session.user) {\n\t    throw new TRPCError({ code: \"UNAUTHORIZED\" });\n\t  }\n", "  return next({\n\t    ctx: {\n\t      // infers the `session` as non-nullable\n\t      session: { ...ctx.session, user: ctx.session.user },\n\t    },\n\t  });\n\t});\n\t/**\n\t * Protected (authenticated) procedure\n\t *\n", " * If you want a query or mutation to ONLY be accessible to logged in users, use this. It verifies\n\t * the session is valid and guarantees `ctx.session.user` is not null.\n\t *\n\t * @see https://trpc.io/docs/procedures\n\t */\n\texport const protectedProcedure = t.procedure.use(enforceUserIsAuthed);\n"]}
{"filename": "src/server/api/root.ts", "chunked_list": ["import { createTRPCRouter } from \"~/server/api/trpc\";\n\timport { exampleRouter } from \"~/server/api/routers/example\";\n\timport { courseRouter } from \"./routers/course\";\n\t/**\n\t * This is the primary router for your server.\n\t *\n\t * All routers added in /api/routers should be manually added here.\n\t */\n\texport const appRouter = createTRPCRouter({\n\t  example: exampleRouter,\n", "  course: courseRouter,\n\t});\n\t// export type definition of API\n\texport type AppRouter = typeof appRouter;\n"]}
{"filename": "src/server/api/routers/example.ts", "chunked_list": ["import { z } from \"zod\";\n\timport {\n\t  createTRPCRouter,\n\t  publicProcedure,\n\t  protectedProcedure,\n\t} from \"~/server/api/trpc\";\n\texport const exampleRouter = createTRPCRouter({\n\t  hello: publicProcedure\n\t    .input(z.object({ text: z.string() }))\n\t    .query(({ input }) => {\n", "      return {\n\t        greeting: `Hello ${input.text}`,\n\t      };\n\t    }),\n\t  getAll: publicProcedure.query(({ ctx }) => {\n\t    return ctx.prisma.example.findMany();\n\t  }),\n\t  getSecretMessage: protectedProcedure.query(() => {\n\t    return \"you can now see this secret message!\";\n\t  }),\n", "});\n"]}
{"filename": "src/server/api/routers/course.ts", "chunked_list": ["import { z } from \"zod\";\n\timport { createTRPCRouter, protectedProcedure } from \"~/server/api/trpc\";\n\timport { S3Client } from \"@aws-sdk/client-s3\";\n\timport { createPresignedPost } from \"@aws-sdk/s3-presigned-post\";\n\timport { env } from \"~/env.mjs\";\n\timport { TRPCError } from \"@trpc/server\";\n\timport { v4 as uuidv4 } from \"uuid\";\n\tconst UPLOAD_MAX_FILE_SIZE = 1000000;\n\tconst s3Client = new S3Client({\n\t  region: \"us-east-1\",\n", "  endpoint: \"http://localhost:9000\",\n\t  forcePathStyle: true,\n\t  credentials: {\n\t    accessKeyId: \"S3RVER\",\n\t    secretAccessKey: \"S3RVER\",\n\t  },\n\t});\n\texport const courseRouter = createTRPCRouter({\n\t  getCourseById: protectedProcedure\n\t    .input(\n", "      z.object({\n\t        courseId: z.string(),\n\t      })\n\t    )\n\t    .query(({ ctx, input }) => {\n\t      return ctx.prisma.course.findUnique({\n\t        where: {\n\t          id: input.courseId,\n\t        },\n\t        include: {\n", "          sections: true,\n\t        },\n\t      });\n\t    }),\n\t  getCourses: protectedProcedure.query(({ ctx }) => {\n\t    return ctx.prisma.course.findMany({\n\t      where: {\n\t        userId: ctx.session.user.id,\n\t      },\n\t    });\n", "  }),\n\t  createCourse: protectedProcedure\n\t    .input(z.object({ title: z.string(), description: z.string() }))\n\t    .mutation(async ({ ctx, input }) => {\n\t      const userId = ctx.session.user.id;\n\t      const newCourse = await ctx.prisma.course.create({\n\t        data: {\n\t          title: input.title,\n\t          description: input.description,\n\t          userId: userId,\n", "        },\n\t      });\n\t      return newCourse;\n\t    }),\n\t  updateCourse: protectedProcedure\n\t    .input(z.object({ title: z.string(), courseId: z.string() }))\n\t    .mutation(async ({ ctx, input }) => {\n\t      const userId = ctx.session.user.id;\n\t      await ctx.prisma.course.updateMany({\n\t        where: {\n", "          id: input.courseId,\n\t          userId,\n\t        },\n\t        data: {\n\t          title: input.title,\n\t        },\n\t      });\n\t      return { status: \"updated\" };\n\t    }),\n\t  createPresignedUrl: protectedProcedure\n", "    .input(z.object({ courseId: z.string() }))\n\t    .mutation(async ({ ctx, input }) => {\n\t      // const userId = ctx.session.user.id;\n\t      const course = await ctx.prisma.course.findUnique({\n\t        where: {\n\t          id: input.courseId,\n\t        },\n\t      });\n\t      if (!course) {\n\t        throw new TRPCError({\n", "          code: \"NOT_FOUND\",\n\t          message: \"the course does not exist\",\n\t        });\n\t      }\n\t      const imageId = uuidv4();\n\t      await ctx.prisma.course.update({\n\t        where: {\n\t          id: course.id,\n\t        },\n\t        data: {\n", "          imageId,\n\t        },\n\t      });\n\t      return createPresignedPost(s3Client, {\n\t        Bucket: env.NEXT_PUBLIC_S3_BUCKET_NAME,\n\t        Key: imageId,\n\t        Fields: {\n\t          key: imageId,\n\t        },\n\t        Conditions: [\n", "          [\"starts-with\", \"$Content-Type\", \"image/\"],\n\t          [\"content-length-range\", 0, UPLOAD_MAX_FILE_SIZE],\n\t        ],\n\t      });\n\t    }),\n\t  createSection: protectedProcedure\n\t    .input(z.object({ courseId: z.string(), title: z.string() }))\n\t    .mutation(async ({ ctx, input }) => {\n\t      const videoId = uuidv4();\n\t      return await ctx.prisma.section.create({\n", "        data: {\n\t          videoId,\n\t          title: input.title,\n\t          courseId: input.courseId,\n\t        },\n\t      });\n\t    }),\n\t  deleteSection: protectedProcedure\n\t    .input(z.object({ sectionId: z.string() }))\n\t    .mutation(async ({ ctx, input }) => {\n", "      const section = await ctx.prisma.section.delete({\n\t        where: {\n\t          id: input.sectionId,\n\t        },\n\t      });\n\t      if (!section) {\n\t        throw new TRPCError({\n\t          code: \"NOT_FOUND\",\n\t          message: \"section not found\",\n\t        });\n", "      }\n\t      if (!section.courseId) {\n\t        throw new TRPCError({\n\t          code: \"NOT_FOUND\",\n\t          message: \"section has no course\",\n\t        });\n\t      }\n\t      const course = await ctx.prisma.course.findUnique({\n\t        where: {\n\t          id: section.courseId,\n", "        },\n\t      });\n\t      if (course?.userId !== ctx.session.user.id) {\n\t        throw new TRPCError({\n\t          code: \"FORBIDDEN\",\n\t          message: \"you do not have access to this course\",\n\t        });\n\t      }\n\t      return section;\n\t    }),\n", "  swapSections: protectedProcedure\n\t    .input(\n\t      z.object({ sectionIdSource: z.string(), sectionIdTarget: z.string() })\n\t    )\n\t    .mutation(async ({ ctx, input }) => {\n\t      const sectionSource = await ctx.prisma.section.findUnique({\n\t        where: {\n\t          id: input.sectionIdSource,\n\t        },\n\t      });\n", "      if (!sectionSource) {\n\t        throw new TRPCError({\n\t          code: \"NOT_FOUND\",\n\t          message: \"the source section does not exist\",\n\t        });\n\t      }\n\t      const sectionTarget = await ctx.prisma.section.findUnique({\n\t        where: {\n\t          id: input.sectionIdTarget,\n\t        },\n", "      });\n\t      if (!sectionTarget) {\n\t        throw new TRPCError({\n\t          code: \"NOT_FOUND\",\n\t          message: \"the target section does not exist\",\n\t        });\n\t      }\n\t      await ctx.prisma.section.update({\n\t        where: {\n\t          id: input.sectionIdSource,\n", "        },\n\t        data: {\n\t          order: sectionTarget.order,\n\t        },\n\t      });\n\t      await ctx.prisma.section.update({\n\t        where: {\n\t          id: input.sectionIdTarget,\n\t        },\n\t        data: {\n", "          order: sectionSource.order,\n\t        },\n\t      });\n\t    }),\n\t  createPresignedUrlForVideo: protectedProcedure\n\t    .input(z.object({ sectionId: z.string() }))\n\t    .mutation(async ({ ctx, input }) => {\n\t      const section = await ctx.prisma.section.findUnique({\n\t        where: {\n\t          id: input.sectionId,\n", "        },\n\t      });\n\t      if (!section) {\n\t        throw new TRPCError({\n\t          code: \"NOT_FOUND\",\n\t          message: \"the section does not exist\",\n\t        });\n\t      }\n\t      if (!section.courseId) {\n\t        throw new TRPCError({\n", "          code: \"NOT_FOUND\",\n\t          message: \"the section has no course\",\n\t        });\n\t      }\n\t      const course = await ctx.prisma.course.findUnique({\n\t        where: {\n\t          id: section.courseId,\n\t        },\n\t      });\n\t      if (course?.userId !== ctx.session.user.id) {\n", "        throw new TRPCError({\n\t          code: \"FORBIDDEN\",\n\t          message: \"you do not have access to this course\",\n\t        });\n\t      }\n\t      return createPresignedPost(s3Client, {\n\t        Bucket: env.NEXT_PUBLIC_S3_BUCKET_NAME,\n\t        Key: section.videoId,\n\t        Fields: {\n\t          key: section.videoId,\n", "        },\n\t        Conditions: [\n\t          [\"starts-with\", \"$Content-Type\", \"image/\"],\n\t          [\"content-length-range\", 0, UPLOAD_MAX_FILE_SIZE],\n\t        ],\n\t      });\n\t    }),\n\t});\n"]}
