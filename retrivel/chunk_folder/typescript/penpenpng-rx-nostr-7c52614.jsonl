{"filename": "vite.config.ts", "chunked_list": ["import path from \"path\";\n\timport { defineConfig } from \"vitest/config\";\n\texport default defineConfig({\n\t  define: {\n\t    \"import.meta.vitest\": \"undefined\",\n\t  },\n\t  build: {\n\t    lib: {\n\t      name: \"rx-nostr\",\n\t      fileName: (format) => `index.${format}.js`,\n", "      entry: path.resolve(__dirname, \"src/index.ts\"),\n\t      formats: [\"es\", \"cjs\", \"umd\"],\n\t    },\n\t    sourcemap: true,\n\t  },\n\t});\n"]}
{"filename": "docs/.vuepress/config.ts", "chunked_list": ["import { defineUserConfig, defaultTheme } from \"vuepress\";\n\timport attrs from \"markdown-it-attrs\";\n\texport default defineUserConfig({\n\t  // To host on GitHub Pages.\n\t  base: \"/rx-nostr/\",\n\t  lang: \"ja_JP\",\n\t  title: \"rx-nostr\",\n\t  description:\n\t    \"A library based on RxJS, which allows Nostr applications to easily communicate with relays.\",\n\t  // Ban README.md. Use index.md instead.\n", "  pagePatterns: [\"**/*.md\", \"!**/README.md\", \"!.vuepress\", \"!node_modules\"],\n\t  markdown: {\n\t    code: {\n\t      lineNumbers: false,\n\t    },\n\t  },\n\t  extendsMarkdown: (md) => {\n\t    // Allow `# Header Text [#custom-id-attr]` syntax.\n\t    // Default delimiters `{}` conflict with [line highlighting](https://v2.vuepress.vuejs.org/guide/markdown.html#code-blocks) feature.\n\t    md.use(attrs, {\n", "      leftDelimiter: \"[\",\n\t      rightDelimiter: \"]\",\n\t    });\n\t  },\n\t  theme: defaultTheme({\n\t    navbar: [\n\t      {\n\t        text: \"Docs\",\n\t        link: \"/docs/\",\n\t      },\n", "      {\n\t        text: \"GitHub\",\n\t        link: \"https://github.com/penpenpng/rx-nostr\",\n\t      },\n\t    ],\n\t    sidebar: {\n\t      \"/docs/\": [\n\t        {\n\t          text: \"Introduction\",\n\t          children: [\n", "            \"/docs/index.md\",\n\t            \"/docs/getting-started.md\",\n\t            \"/docs/first-step.md\",\n\t          ],\n\t        },\n\t        {\n\t          text: \"Guide\",\n\t          children: [\n\t            \"/docs/req-strategy.md\",\n\t            \"/docs/relay-configuration.md\",\n", "            \"/docs/lazy-since-until.md\",\n\t            \"/docs/sending-event.md\",\n\t            \"/docs/monitoring-connections.md\",\n\t            \"/docs/error-handling.md\",\n\t            \"/docs/operators.md\",\n\t          ],\n\t        },\n\t        {\n\t          text: \"Examples\",\n\t          link: \"/docs/examples.md\",\n", "        },\n\t      ],\n\t    },\n\t    editLinkText: \"このページを編集\",\n\t    docsRepo: \"https://github.com/penpenpng/rx-nostr\",\n\t    docsBranch: \"main\",\n\t    docsDir: \"docs\",\n\t  }),\n\t});\n"]}
{"filename": "app/main.ts", "chunked_list": ["// # Playground\n\t// Edit here and try `yarn dev`\n\timport {\n\t  createRxBackwardReq,\n\t  createRxForwardReq,\n\t  createRxNostr,\n\t} from \"../src/index.js\";\n\tdocument.getElementById(\"send\")?.addEventListener(\"click\", async () => {\n\t  const input = document.getElementById(\"input\") as HTMLInputElement;\n\t  rxNostr\n", "    .send({\n\t      kind: 1,\n\t      content: input.value,\n\t      pubkey: (await window.nostr?.getPublicKey()) ?? \"\",\n\t    })\n\t    .subscribe({\n\t      next: ({ from }) => {\n\t        console.log(\"OK\", from);\n\t      },\n\t      complete: () => {\n", "        console.log(\"Send completed\");\n\t      },\n\t    });\n\t  input.value = \"\";\n\t});\n\tconst rxNostr = createRxNostr();\n\trxNostr.createConnectionStateObservable().subscribe((ev) => {\n\t  console.log(ev.state, ev.from);\n\t});\n\trxNostr.switchRelays([\n", "  \"wss://relay-jp.nostr.wirednet.jp\",\n\t  \"wss://nostr-relay.nokotaro.com\",\n\t]);\n\tconst req0 = createRxBackwardReq();\n\trxNostr\n\t  .use(req0)\n\t  .subscribe((e) => console.log(0, e.event.id.slice(0, 5), e.subId, e.from));\n\tconst req1 = createRxForwardReq();\n\trxNostr\n\t  .use(req1)\n", "  .subscribe((e) => console.log(1, e.event.id.slice(0, 5), e.subId, e.from));\n\treq0.emit([{ kinds: [0], limit: 3 }]);\n\treq1.emit([{ kinds: [1], limit: 3 }]);\n\tsetTimeout(() => {\n\t  console.log(\"---\");\n\t  rxNostr.switchRelays([\n\t    \"wss://relay-jp.nostr.wirednet.jp\",\n\t    \"wss://nostr.h3z.jp\",\n\t  ]);\n\t}, 3000);\n"]}
{"filename": "app/vite-env.d.ts", "chunked_list": ["/// <reference types=\"vite/client\" />\n"]}
{"filename": "src/req.ts", "chunked_list": ["import Nostr from \"nostr-typedef\";\n\timport { BehaviorSubject, Observable, type OperatorFunction } from \"rxjs\";\n\timport { LazyFilter, ReqPacket } from \"./packet.js\";\n\timport type { Override } from \"./util.js\";\n\t/**\n\t * The RxReq interface that is provided for RxNostr (**not for users**).\n\t */\n\texport interface RxReq<S extends RxReqStrategy = RxReqStrategy> {\n\t  /** @internal User should not use this directly.The RxReq strategy. It is read-only and must not change. */\n\t  get strategy(): S;\n", "  /** @internal User should not use this directly. Used to construct subId. */\n\t  get rxReqId(): string;\n\t  /** @internal User should not use this directly. Get an Observable of ReqPacket. */\n\t  getReqObservable(): Observable<ReqPacket>;\n\t}\n\t/**\n\t * REQ strategy.\n\t *\n\t * See comments on `createRxForwardReq()`, `createRxBackwardReq()` and `createRxOneshotReq()\n\t */\n", "export type RxReqStrategy = \"forward\" | \"backward\" | \"oneshot\";\n\t/**\n\t * The RxReq interface that is provided for users (not for RxNostr).\n\t */\n\texport interface RxReqController {\n\t  /** Start new REQ or stop REQ on the RxNostr with witch the RxReq is associated. */\n\t  emit(filters: LazyFilter | LazyFilter[] | null): void;\n\t  /**\n\t   * Returns itself overriding only `getReqObservable()`.\n\t   * It is useful for throttling and other control purposes.\n", "   */\n\t  pipe(): RxReq;\n\t  pipe(op1: OperatorFunction<ReqPacket, ReqPacket>): RxReq;\n\t  pipe<A>(\n\t    op1: OperatorFunction<ReqPacket, A>,\n\t    op2: OperatorFunction<A, ReqPacket>\n\t  ): RxReq;\n\t  pipe<A, B>(\n\t    op1: OperatorFunction<ReqPacket, A>,\n\t    op2: OperatorFunction<A, B>,\n", "    op3: OperatorFunction<B, ReqPacket>\n\t  ): RxReq;\n\t  pipe<A, B, C>(\n\t    op1: OperatorFunction<ReqPacket, A>,\n\t    op2: OperatorFunction<A, B>,\n\t    op3: OperatorFunction<B, C>,\n\t    op4: OperatorFunction<C, ReqPacket>\n\t  ): RxReq;\n\t  pipe<A, B, C, D>(\n\t    op1: OperatorFunction<ReqPacket, A>,\n", "    op2: OperatorFunction<A, B>,\n\t    op3: OperatorFunction<B, C>,\n\t    op4: OperatorFunction<C, D>,\n\t    op5: OperatorFunction<D, ReqPacket>\n\t  ): RxReq;\n\t}\n\tabstract class RxReqBase implements RxReq {\n\t  protected filters$ = new BehaviorSubject<ReqPacket>(null);\n\t  private _rxReqId: string;\n\t  abstract get strategy(): RxReqStrategy;\n", "  get rxReqId() {\n\t    return this._rxReqId;\n\t  }\n\t  constructor(rxReqId?: string) {\n\t    this._rxReqId = rxReqId ?? getRandomDigitsString();\n\t  }\n\t  getReqObservable(): Observable<ReqPacket> {\n\t    return this.filters$.asObservable();\n\t  }\n\t  emit(filters: LazyFilter | LazyFilter[] | null) {\n", "    const normalized = normalizeFilters(filters);\n\t    if (normalized) {\n\t      this.filters$.next(normalized);\n\t    } else {\n\t      this.filters$.next(null);\n\t    }\n\t  }\n\t  pipe(): RxReq;\n\t  pipe(op1: OperatorFunction<ReqPacket, ReqPacket>): RxReq;\n\t  pipe<A>(\n", "    op1: OperatorFunction<ReqPacket, A>,\n\t    op2: OperatorFunction<A, ReqPacket>\n\t  ): RxReq;\n\t  pipe<A, B>(\n\t    op1: OperatorFunction<ReqPacket, A>,\n\t    op2: OperatorFunction<A, B>,\n\t    op3: OperatorFunction<B, ReqPacket>\n\t  ): RxReq;\n\t  pipe<A, B, C>(\n\t    op1: OperatorFunction<ReqPacket, A>,\n", "    op2: OperatorFunction<A, B>,\n\t    op3: OperatorFunction<B, C>,\n\t    op4: OperatorFunction<C, ReqPacket>\n\t  ): RxReq;\n\t  pipe<A, B, C, D>(\n\t    op1: OperatorFunction<ReqPacket, A>,\n\t    op2: OperatorFunction<A, B>,\n\t    op3: OperatorFunction<B, C>,\n\t    op4: OperatorFunction<C, D>,\n\t    op5: OperatorFunction<D, ReqPacket>\n", "  ): RxReq;\n\t  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t  pipe(...operators: OperatorFunction<any, any>[]): RxReq {\n\t    const rxReqId = this.rxReqId;\n\t    const strategy = this.strategy;\n\t    return {\n\t      ...this,\n\t      get rxReqId() {\n\t        return rxReqId;\n\t      },\n", "      get strategy() {\n\t        return strategy;\n\t      },\n\t      getReqObservable: () =>\n\t        this.getReqObservable().pipe(...(operators as [])),\n\t    };\n\t  }\n\t}\n\t/**\n\t * Create a RxReq instance based on the backward strategy.\n", " * It is useful if you want to retrieve past events that have already been published.\n\t *\n\t * In backward strategy:\n\t * - All REQs have different subIds.\n\t * - All REQ-subscriptions keep alive until timeout or getting EOSE.\n\t * - In most cases, you should specify `until` or `limit` for filters.\n\t *\n\t * For more information, see [document](https://penpenpng.github.io/rx-nostr/docs/req-strategy.html#backward-strategy).\n\t */\n\texport function createRxBackwardReq(\n", "  subIdBase?: string\n\t): RxReq<\"backward\"> & RxReqController {\n\t  return new RxBackwardReq(subIdBase);\n\t}\n\tclass RxBackwardReq extends RxReqBase implements RxReqController {\n\t  constructor(rxReqId?: string) {\n\t    super(rxReqId);\n\t  }\n\t  override get strategy(): \"backward\" {\n\t    return \"backward\";\n", "  }\n\t}\n\t/**\n\t * Create a RxReq instance based on the forward strategy.\n\t * It is useful if you want to listen future events.\n\t *\n\t * In forward strategy:\n\t * - All REQs have the same subId.\n\t * - When a new REQ is issued, the old REQ is overwritten and terminated immediately.\n\t *   The latest REQ keeps alive until it is overwritten or explicitly terminated.\n", " * - In most cases, you should not specify `limit` for filters.\n\t *\n\t * For more information, see [document](https://penpenpng.github.io/rx-nostr/docs/req-strategy.html#forward-strategy).\n\t */\n\texport function createRxForwardReq(\n\t  subId?: string\n\t): RxReq<\"forward\"> & RxReqController {\n\t  return new RxForwardReq(subId);\n\t}\n\tclass RxForwardReq extends RxReqBase implements RxReqController {\n", "  constructor(rxReqId?: string) {\n\t    super(rxReqId);\n\t  }\n\t  override get strategy(): \"forward\" {\n\t    return \"forward\";\n\t  }\n\t}\n\t/**\n\t * Create a RxReq instance based on the oneshot strategy.\n\t * It is almost the same as backward strategy, however can publish only one REQ\n", " * and the Observable completes on EOSE.\n\t *\n\t * For more information, see [document](https://penpenpng.github.io/rx-nostr/docs/req-strategy.html#oneshot-strategy).\n\t */\n\texport function createRxOneshotReq(req: {\n\t  filters: LazyFilter | LazyFilter[];\n\t  subId?: string;\n\t}): RxReq<\"oneshot\"> {\n\t  return new RxOneshotReq(req);\n\t}\n", "class RxOneshotReq extends RxReqBase {\n\t  constructor(req: { filters: LazyFilter | LazyFilter[]; subId?: string }) {\n\t    super(req?.subId);\n\t    this.emit(req.filters);\n\t  }\n\t  override get strategy(): \"oneshot\" {\n\t    return \"oneshot\";\n\t  }\n\t}\n\texport interface Mixin<R, T> {\n", "  (): ThisType<R> & T;\n\t}\n\t/** NOTE: unstable feature */\n\texport function mixin<R extends object, T extends object>(\n\t  def: () => ThisType<R> & T\n\t): Mixin<R, T> {\n\t  return def;\n\t}\n\t/** NOTE: unstable feature */\n\texport function extend<B extends R, R extends object, T extends object>(\n", "  base: B,\n\t  mixin: Mixin<R, T>\n\t): Override<B, T> {\n\t  return Object.assign(base, mixin()) as Override<B, T>;\n\t}\n\tfunction getRandomDigitsString() {\n\t  return `${Math.floor(Math.random() * 1000000)}`;\n\t}\n\tfunction normalizeFilter(filter: LazyFilter): LazyFilter | null {\n\t  const res: LazyFilter = {};\n", "  const isTagName = (s: string): s is Nostr.TagName => /^#[a-zA-Z]$/.test(s);\n\t  for (const key of Object.keys(filter)) {\n\t    if (key === \"limit\" && (filter[key] ?? -1) >= 0) {\n\t      res[key] = filter[key];\n\t      continue;\n\t    }\n\t    if (key === \"since\" || key === \"until\") {\n\t      const f = filter[key];\n\t      if (typeof f !== \"number\" || (f ?? -1) >= 0) {\n\t        res[key] = f;\n", "        continue;\n\t      }\n\t    }\n\t    if (\n\t      (isTagName(key) || key === \"ids\" || key === \"authors\") &&\n\t      filter[key] !== undefined &&\n\t      (filter[key]?.length ?? -1) > 0\n\t    ) {\n\t      res[key] = filter[key];\n\t      continue;\n", "    }\n\t    if (\n\t      key === \"kinds\" &&\n\t      filter[key] !== undefined &&\n\t      (filter[key]?.length ?? -1) > 0\n\t    ) {\n\t      res[key] = filter[key];\n\t      continue;\n\t    }\n\t    if (key === \"search\" && filter[key] !== undefined) {\n", "      res[key] = filter[key];\n\t      continue;\n\t    }\n\t  }\n\t  const timeRangeIsValid =\n\t    typeof res.since !== \"number\" ||\n\t    typeof res.until !== \"number\" ||\n\t    res.since <= res.until;\n\t  if (!timeRangeIsValid) {\n\t    return null;\n", "  }\n\t  if (Object.keys(res).length <= 0) {\n\t    return null;\n\t  }\n\t  return res;\n\t}\n\tfunction normalizeFilters(\n\t  filters: LazyFilter | LazyFilter[] | null\n\t): LazyFilter[] | null {\n\t  if (!filters) {\n", "    return null;\n\t  }\n\t  const normalized = (Array.isArray(filters) ? filters : [filters]).flatMap(\n\t    (e) => normalizeFilter(e) ?? []\n\t  );\n\t  return normalized.length > 0 ? normalized : null;\n\t}\n"]}
{"filename": "src/helper.ts", "chunked_list": ["/** Return a function that is lazily evaluated for since/until parameters of `LazyFilter`. */\n\timport Nostr from \"nostr-typedef\";\n\timport { LazyFilter } from \"./packet.js\";\n\texport function now(): number {\n\t  return Math.floor(new Date().getTime() / 1000);\n\t}\n\texport function evalFilters(\n\t  filters: LazyFilter | LazyFilter[]\n\t): Nostr.Filter[] {\n\t  if (\"length\" in filters) {\n", "    return filters.map(evalFilter);\n\t  } else {\n\t    return [evalFilter(filters)];\n\t  }\n\t}\n\tfunction evalFilter(filter: LazyFilter): Nostr.Filter {\n\t  return {\n\t    ...filter,\n\t    since: filter.since ? evalLazyNumber(filter.since) : undefined,\n\t    until: filter.until ? evalLazyNumber(filter.until) : undefined,\n", "  };\n\t}\n\tfunction evalLazyNumber(lazyNumber: number | (() => number)): number {\n\t  return typeof lazyNumber === \"number\" ? lazyNumber : lazyNumber();\n\t}\n"]}
{"filename": "src/connection.ts", "chunked_list": ["import Nostr from \"nostr-typedef\";\n\timport {\n\t  EMPTY,\n\t  filter,\n\t  identity,\n\t  mergeMap,\n\t  type MonoTypeOperatorFunction,\n\t  Observable,\n\t  type ObservableInput,\n\t  of,\n", "  retry,\n\t  Subject,\n\t  tap,\n\t  timer,\n\t} from \"rxjs\";\n\timport { evalFilters } from \"./helper.js\";\n\timport { fetchRelayInfo } from \"./index.js\";\n\timport { isFiltered } from \"./nostr/filter.js\";\n\timport { ConnectionState, LazyREQ, MessagePacket } from \"./packet.js\";\n\texport class Connection {\n", "  private socket: WebSocket | null = null;\n\t  private message$ = new Subject<MessagePacket | WebSocketError>();\n\t  private error$ = new Subject<unknown>();\n\t  private connectionState$ = new Subject<ConnectionState>();\n\t  private connectionState: ConnectionState = \"not-started\";\n\t  private queuedEvents: Nostr.ToRelayMessage.EVENT[] = [];\n\t  private reqs: Map<string /* subId */, ReqState> = new Map();\n\t  private serverLimitations: Nostr.Nip11.ServerLimitations | null = null;\n\t  private canRetry = false;\n\t  get read() {\n", "    return this.config.read;\n\t  }\n\t  set read(v) {\n\t    this.config.read = v;\n\t  }\n\t  get write() {\n\t    return this.config.write;\n\t  }\n\t  set write(v) {\n\t    this.config.write = v;\n", "  }\n\t  get maxConcurrentReqs(): number | null {\n\t    return (\n\t      this.serverLimitations?.max_subscriptions ??\n\t      this.config.maxConcurrentReqsFallback ??\n\t      null\n\t    );\n\t  }\n\t  constructor(public url: string, private config: ConnectionConfig) {\n\t    this.connectionState$.next(\"not-started\");\n", "  }\n\t  private setConnectionState(state: ConnectionState) {\n\t    if (this.connectionState === \"terminated\") {\n\t      return;\n\t    }\n\t    this.connectionState = state;\n\t    this.connectionState$.next(state);\n\t  }\n\t  private async fetchServerLimitationsIfNeeded() {\n\t    if (\n", "      this.config.disableAutoFetchNip11Limitations ||\n\t      this.serverLimitations\n\t    ) {\n\t      return;\n\t    }\n\t    try {\n\t      const info = await fetchRelayInfo(this.url);\n\t      this.serverLimitations = info.limitation ?? null;\n\t    } catch {\n\t      // do nothing\n", "    }\n\t  }\n\t  async start() {\n\t    if (\n\t      !this.canRetry &&\n\t      (this.connectionState === \"reconnecting\" ||\n\t        this.connectionState === \"starting\" ||\n\t        this.connectionState === \"ongoing\")\n\t    ) {\n\t      return Promise.resolve();\n", "    }\n\t    this.canRetry = false;\n\t    if (this.connectionState === \"not-started\") {\n\t      this.setConnectionState(\"starting\");\n\t    } else {\n\t      this.setConnectionState(\"reconnecting\");\n\t    }\n\t    await this.fetchServerLimitationsIfNeeded();\n\t    let completeStartingProcess: () => void;\n\t    const succeededOrFailed = new Promise<void>((_resolve) => {\n", "      completeStartingProcess = _resolve;\n\t    });\n\t    const onopen = () => {\n\t      this.setConnectionState(\"ongoing\");\n\t      completeStartingProcess();\n\t      for (const event of this.queuedEvents) {\n\t        this.sendEVENT(event);\n\t      }\n\t      this.queuedEvents = [];\n\t      this.ensureReqs();\n", "    };\n\t    const onmessage = ({ data }: MessageEvent) => {\n\t      if (this.connectionState === \"terminated\") {\n\t        return;\n\t      }\n\t      try {\n\t        this.message$.next({ from: this.url, message: JSON.parse(data) });\n\t      } catch (err) {\n\t        this.error$.next(err);\n\t      }\n", "    };\n\t    const onerror = () => {\n\t      completeStartingProcess();\n\t    };\n\t    const onclose = ({ code }: CloseEvent) => {\n\t      if (\n\t        code === WebSocketCloseCode.DISPOSED_BY_RX_NOSTR ||\n\t        this.connectionState === \"terminated\"\n\t      ) {\n\t        return;\n", "      }\n\t      websocket.removeEventListener(\"open\", onopen);\n\t      websocket.removeEventListener(\"message\", onmessage);\n\t      websocket.removeEventListener(\"error\", onerror);\n\t      websocket.removeEventListener(\"close\", onclose);\n\t      websocket.close();\n\t      this.socket = null;\n\t      for (const req of this.reqs.values()) {\n\t        req.isOngoing = false;\n\t      }\n", "      if (code === WebSocketCloseCode.DESIRED_BY_RX_NOSTR) {\n\t        this.setConnectionState(\"not-started\");\n\t      } else if (code === WebSocketCloseCode.DONT_RETRY) {\n\t        this.setConnectionState(\"rejected\");\n\t        this.message$.next(new WebSocketError(code));\n\t        completeStartingProcess();\n\t      } else {\n\t        this.canRetry = true;\n\t        this.message$.next(new WebSocketError(code));\n\t        completeStartingProcess();\n", "      }\n\t    };\n\t    if (this.connectionState === \"terminated\") {\n\t      return Promise.resolve();\n\t    }\n\t    const websocket = new WebSocket(this.url);\n\t    websocket.addEventListener(\"open\", onopen);\n\t    websocket.addEventListener(\"message\", onmessage);\n\t    websocket.addEventListener(\"error\", onerror);\n\t    websocket.addEventListener(\"close\", onclose);\n", "    this.socket = websocket;\n\t    return succeededOrFailed;\n\t  }\n\t  stop() {\n\t    this.finalizeAllReqs();\n\t    this.socket?.close(WebSocketCloseCode.DESIRED_BY_RX_NOSTR);\n\t  }\n\t  getConnectionState() {\n\t    return this.connectionState;\n\t  }\n", "  getMessageObservable(): Observable<MessagePacket> {\n\t    const reqs = this.reqs;\n\t    return this.message$.asObservable().pipe(\n\t      mergeMap((data) => {\n\t        if (data instanceof WebSocketError) {\n\t          if (data.code === WebSocketCloseCode.DONT_RETRY) {\n\t            return EMPTY;\n\t          } else {\n\t            throw data;\n\t          }\n", "        } else {\n\t          return of(data);\n\t        }\n\t      }),\n\t      tap({\n\t        subscribe: () => {\n\t          this.start();\n\t        },\n\t      }),\n\t      this.config.backoff.strategy === \"off\"\n", "        ? identity\n\t        : retry({\n\t            delay: (_, retryCount) =>\n\t              backoffSignal(this.config.backoff, retryCount),\n\t            count: this.config.backoff.maxCount,\n\t          }),\n\t      tap({\n\t        error: () => {\n\t          this.setConnectionState(\"error\");\n\t        },\n", "      }),\n\t      rejectFilterUnmatchEvents()\n\t    );\n\t    function rejectFilterUnmatchEvents(): MonoTypeOperatorFunction<MessagePacket> {\n\t      return filter((packet) => {\n\t        const [type, subId, event] = packet.message;\n\t        if (type !== \"EVENT\") {\n\t          return true;\n\t        }\n\t        const req = reqs.get(subId);\n", "        if (!req) {\n\t          return true;\n\t        }\n\t        const [, , ...filters] = req.actual;\n\t        return isFiltered(event, filters);\n\t      });\n\t    }\n\t  }\n\t  getConnectionStateObservable() {\n\t    return this.connectionState$.asObservable();\n", "  }\n\t  getErrorObservable() {\n\t    return this.error$.asObservable();\n\t  }\n\t  ensureReq(req: LazyREQ, options?: { overwrite?: boolean }) {\n\t    const subId = req[1];\n\t    if (this.connectionState === \"terminated\") {\n\t      return;\n\t    }\n\t    if (!this.read) {\n", "      // REQ is not allowed.\n\t      return;\n\t    }\n\t    if (!options?.overwrite) {\n\t      if (this.reqs.get(subId)?.isOngoing) {\n\t        // REQ is already ongoing\n\t        return;\n\t      }\n\t      if (\n\t        this.reqs.has(subId) &&\n", "        !isConcurrentAllowed(subId, this.reqs, this.maxConcurrentReqs)\n\t      ) {\n\t        // REQ is already queued\n\t        return;\n\t      }\n\t    }\n\t    const message = evalREQ(req);\n\t    // enqueue or overwrite\n\t    this.reqs.set(subId, {\n\t      original: req,\n", "      actual: message,\n\t      isOngoing: false,\n\t    });\n\t    if (isConcurrentAllowed(subId, this.reqs, this.maxConcurrentReqs)) {\n\t      const req = this.reqs.get(subId);\n\t      if (req && this.socket?.readyState === WebSocket.OPEN) {\n\t        req.isOngoing = true;\n\t        this.socket.send(JSON.stringify(message));\n\t      }\n\t    }\n", "  }\n\t  private ensureReqs() {\n\t    const reqs = Array.from(this.reqs.values()).slice(\n\t      0,\n\t      this.maxConcurrentReqs ?? undefined\n\t    );\n\t    for (const req of reqs) {\n\t      this.ensureReq(req.original);\n\t    }\n\t  }\n", "  finalizeReq(subId: string) {\n\t    if (this.connectionState === \"terminated\") {\n\t      return;\n\t    }\n\t    const req = this.reqs.get(subId);\n\t    if (!req) {\n\t      return;\n\t    }\n\t    this.reqs.delete(subId);\n\t    if (req.isOngoing) {\n", "      if (this.socket?.readyState === WebSocket.OPEN) {\n\t        const message: Nostr.ToRelayMessage.CLOSE = [\"CLOSE\", subId];\n\t        this.socket.send(JSON.stringify(message));\n\t      }\n\t      this.ensureReqs();\n\t    }\n\t  }\n\t  private finalizeAllReqs() {\n\t    if (this.connectionState === \"terminated\") {\n\t      return;\n", "    }\n\t    for (const subId of this.reqs.keys()) {\n\t      if (this.socket?.readyState === WebSocket.OPEN) {\n\t        const message: Nostr.ToRelayMessage.CLOSE = [\"CLOSE\", subId];\n\t        this.socket.send(JSON.stringify(message));\n\t      }\n\t    }\n\t    this.reqs.clear();\n\t  }\n\t  sendEVENT(message: Nostr.ToRelayMessage.EVENT) {\n", "    if (this.connectionState === \"terminated\") {\n\t      return;\n\t    }\n\t    if (!this.write) {\n\t      return;\n\t    }\n\t    if (this.socket?.readyState === WebSocket.OPEN) {\n\t      this.socket.send(JSON.stringify(message));\n\t    } else {\n\t      if (this.socket?.readyState === WebSocket.CONNECTING) {\n", "        // Enqueue\n\t        this.queuedEvents.push(message);\n\t      } else {\n\t        // Create a temporary socket to send message.\n\t        const socket = new WebSocket(this.url);\n\t        socket.addEventListener(\"open\", () => {\n\t          socket.send(JSON.stringify(message));\n\t        });\n\t        // Close the temporary socket after receiveing OK or timed out.\n\t        socket.addEventListener(\"message\", ({ data }) => {\n", "          try {\n\t            const response: Nostr.ToClientMessage.Any = JSON.parse(data);\n\t            if (response[0] === \"OK\") {\n\t              socket.close();\n\t            }\n\t            this.message$.next({ from: this.url, message: response });\n\t          } catch (err) {\n\t            this.message$.error(err);\n\t          }\n\t        });\n", "        setTimeout(() => {\n\t          if (\n\t            socket.readyState === WebSocket.OPEN ||\n\t            socket.readyState === WebSocket.CONNECTING\n\t          ) {\n\t            socket.close();\n\t          }\n\t        }, 10 * 1000);\n\t      }\n\t    }\n", "  }\n\t  dispose() {\n\t    this.finalizeAllReqs();\n\t    this.setConnectionState(\"terminated\");\n\t    this.socket?.close(WebSocketCloseCode.DISPOSED_BY_RX_NOSTR);\n\t    this.socket = null;\n\t    this.reqs.clear();\n\t    this.message$.complete();\n\t    this.message$.unsubscribe();\n\t    this.connectionState$.complete();\n", "    this.connectionState$.unsubscribe();\n\t    this.error$.complete();\n\t    this.error$.unsubscribe();\n\t  }\n\t}\n\texport const WebSocketCloseCode = {\n\t  /**\n\t   * 1006 is a reserved value and MUST NOT be set as a status code in a\n\t   * Close control frame by an endpoint.  It is designated for use in\n\t   * applications expecting a status code to indicate that the\n", "   * connection was closed abnormally, e.g., without sending or\n\t   * receiving a Close control frame.\n\t   *\n\t   * See also: https://www.rfc-editor.org/rfc/rfc6455.html#section-7.4.1\n\t   */\n\t  ABNORMAL_CLOSURE: 1006,\n\t  /**\n\t   * When a websocket is closed by the relay with a status code 4000\n\t   * that means the client shouldn't try to connect again.\n\t   *\n", "   * See also: https://github.com/nostr-protocol/nips/blob/fab6a21a779460f696f11169ddf343b437327592/01.md?plain=1#L113\n\t   */\n\t  DONT_RETRY: 4000,\n\t  /** @internal rx-nostr uses it internally. */\n\t  DESIRED_BY_RX_NOSTR: 4537,\n\t  /** @internal rx-nostr uses it internally. */\n\t  DISPOSED_BY_RX_NOSTR: 4538,\n\t} as const;\n\texport interface ConnectionConfig {\n\t  backoff: BackoffConfig;\n", "  read: boolean;\n\t  write: boolean;\n\t  disableAutoFetchNip11Limitations?: boolean;\n\t  maxConcurrentReqsFallback?: number;\n\t}\n\texport type BackoffConfig =\n\t  | {\n\t      // Exponential backoff and jitter strategy\n\t      strategy: \"exponential\";\n\t      maxCount: number;\n", "      initialDelay: number;\n\t    }\n\t  | {\n\t      // Retry at regular intervals\n\t      strategy: \"linear\";\n\t      maxCount: number;\n\t      interval: number;\n\t    }\n\t  | {\n\t      // Retry immediately\n", "      strategy: \"immediately\";\n\t      maxCount: number;\n\t    }\n\t  | {\n\t      // Won't retry\n\t      strategy: \"off\";\n\t    };\n\tinterface ReqState {\n\t  original: LazyREQ;\n\t  actual: Nostr.ToRelayMessage.REQ;\n", "  isOngoing: boolean;\n\t}\n\tfunction backoffSignal(\n\t  config: BackoffConfig,\n\t  count: number\n\t): ObservableInput<unknown> {\n\t  if (config.strategy === \"exponential\") {\n\t    const time = Math.max(\n\t      config.initialDelay * 2 ** (count - 1) + (Math.random() - 0.5) * 1000,\n\t      1000\n", "    );\n\t    return timer(time);\n\t  } else if (config.strategy === \"linear\") {\n\t    return timer(config.interval);\n\t  } else if (config.strategy === \"immediately\") {\n\t    return of(0);\n\t  } else {\n\t    return EMPTY;\n\t  }\n\t}\n", "function evalREQ([type, subId, ...filters]: LazyREQ): Nostr.ToRelayMessage.REQ {\n\t  return [type, subId, ...evalFilters(filters)];\n\t}\n\tfunction isConcurrentAllowed(\n\t  subId: string,\n\t  reqs: Map<string, ReqState>,\n\t  concurrent: number | null\n\t): boolean {\n\t  if (concurrent === null) {\n\t    return true;\n", "  }\n\t  const reqOrdinal = Array.from(reqs.keys()).findIndex((e) => e === subId);\n\t  if (reqOrdinal === undefined) {\n\t    return false;\n\t  }\n\t  return reqOrdinal < concurrent;\n\t}\n\tclass WebSocketError extends Error {\n\t  constructor(public code?: number) {\n\t    super(`WebSocket Error: Socket was closed with code ${code}`);\n", "  }\n\t}\n"]}
{"filename": "src/packet.ts", "chunked_list": ["import Nostr from \"nostr-typedef\";\n\t// Packet is data treated by rx-nostr Observables.\n\t/**\n\t * Packets flowing through the Observable stream sent from RxReq towards RxNostr.\n\t * When null is sent, the subscription is suspended.\n\t */\n\texport type ReqPacket = LazyFilter[] | null;\n\t/**\n\t * Filter object, but allows parameters since/until to be function.\n\t * If so, values will be evaluated just before submission.\n", " */\n\texport type LazyFilter = Omit<Nostr.Filter, \"since\" | \"until\"> & {\n\t  since?: number | (() => number);\n\t  until?: number | (() => number);\n\t};\n\texport type LazyREQ = [\"REQ\", string, ...LazyFilter[]];\n\t/**\n\t * Packets from websocket that represents an EVENT.\n\t */\n\texport interface EventPacket {\n", "  from: string;\n\t  subId: string;\n\t  event: Nostr.Event;\n\t}\n\t/**\n\t * Packets from websocket that represents an error.\n\t */\n\texport interface ErrorPacket {\n\t  from: string;\n\t  reason: unknown;\n", "}\n\t/**\n\t * Packets from websocket that represents all raw incoming messages.\n\t */\n\texport interface MessagePacket<\n\t  M extends Nostr.ToClientMessage.Any = Nostr.ToClientMessage.Any\n\t> {\n\t  from: string;\n\t  message: M;\n\t}\n", "/**\n\t * Packets emitted when WebSocket connection state is changed.\n\t */\n\texport interface ConnectionStatePacket {\n\t  from: string;\n\t  state: ConnectionState;\n\t}\n\t/**\n\t * WebSocket connection state.\n\t *\n", " * - `not-started`: Not started yet, or closed by expected ways.\n\t * - `starting`: Attempting to connect (for reasons other than error recovery).\n\t * - `ongoing`: Active, but may be temporarily closed as idling.\n\t * - `reconnecting`: Trying to reconnect for error recovery.\n\t * - `error`: Inactive because of an unexpected error. You can try to recover by reconnect()\n\t * - `rejected`: Inactive because of closing code 4000. You can try to reconnect, but should not do.\n\t * - `terminated`: No longer available because of dispose()\n\t */\n\texport type ConnectionState =\n\t  | \"not-started\"\n", "  | \"starting\"\n\t  | \"ongoing\"\n\t  | \"reconnecting\"\n\t  | \"error\"\n\t  | \"rejected\"\n\t  | \"terminated\";\n\t/**\n\t * Packets represents OK messages associated with an EVENT submission.\n\t */\n\texport interface OkPacket {\n", "  from: string;\n\t  id: string;\n\t  ok: boolean;\n\t}\n"]}
{"filename": "src/rx-nostr.ts", "chunked_list": ["import Nostr from \"nostr-typedef\";\n\timport {\n\t  catchError,\n\t  EMPTY,\n\t  filter,\n\t  finalize,\n\t  first,\n\t  identity,\n\t  map,\n\t  merge,\n", "  mergeAll,\n\t  mergeMap,\n\t  type MonoTypeOperatorFunction,\n\t  Observable,\n\t  of,\n\t  type OperatorFunction,\n\t  ReplaySubject,\n\t  Subject,\n\t  Subscription,\n\t  take,\n", "  takeUntil,\n\t  tap,\n\t  timeout,\n\t  type Unsubscribable,\n\t} from \"rxjs\";\n\timport { BackoffConfig, Connection } from \"./connection.js\";\n\timport { getSignedEvent } from \"./nostr/event.js\";\n\timport { fetchRelayInfo } from \"./nostr/nip11.js\";\n\timport { completeOnTimeout } from \"./operator.js\";\n\timport type {\n", "  ConnectionState,\n\t  ConnectionStatePacket,\n\t  ErrorPacket,\n\t  EventPacket,\n\t  LazyFilter,\n\t  LazyREQ,\n\t  MessagePacket,\n\t  OkPacket,\n\t} from \"./packet.js\";\n\timport type { RxReq } from \"./req.js\";\n", "import { defineDefaultOptions, normalizeRelayUrl } from \"./util.js\";\n\t/**\n\t * The core object of rx-nostr, which holds a connection to relays\n\t * and manages subscriptions as directed by the RxReq object connected by `use()`.\n\t * Use `createRxNostr()` to get the object.\n\t */\n\texport interface RxNostr {\n\t  /**\n\t   * Return a list of relays used by this object.\n\t   * The relay URLs are normalised so may not match the URLs set.\n", "   */\n\t  getRelays(): RelayConfig[];\n\t  /**\n\t   * Set the list of relays.\n\t   * If a REQ subscription already exists, the same REQ is issued for the newly added relay\n\t   * and CLOSE is sent for the removed relay.\n\t   */\n\t  switchRelays(config: AcceptableRelaysConfig): Promise<void>;\n\t  /** Utility wrapper for `switchRelays()`. */\n\t  addRelay(relay: string | RelayConfig): Promise<void>;\n", "  /** Utility wrapper for `switchRelays()`. */\n\t  removeRelay(url: string): Promise<void>;\n\t  /** Return true if the given relay is set to rxNostr. */\n\t  hasRelay(url: string): boolean;\n\t  /** Return true if the given relay allows to be written. */\n\t  canWriteRelay(url: string): boolean;\n\t  /** Return true if the given relay allows to be read. */\n\t  canReadRelay(url: string): boolean;\n\t  /** Fetch all relays' info based on [NIP-11](https://github.com/nostr-protocol/nips/blob/master/11.md) */\n\t  fetchAllRelaysInfo(): Promise<Record<string, Nostr.Nip11.RelayInfo | null>>;\n", "  /**\n\t   * Return a dictionary in which you can look up connection state.\n\t   *\n\t   * **NOTE**: Keys are **normalized** URL, so may be different from one you set.\n\t   */\n\t  getAllRelayState(): Record<string, ConnectionState>;\n\t  /**\n\t   * Return connection state of the given relay.\n\t   * Throw if unknown URL is given.\n\t   */\n", "  getRelayState(url: string): ConnectionState;\n\t  /**\n\t   * Attempt to reconnect the WebSocket if its state is `error` or `rejected`.\n\t   * If not, do nothing.\n\t   */\n\t  reconnect(url: string): void;\n\t  // TODO: document\n\t  /**\n\t   * Set or unset a pipe to be applied to all EventPackets.\n\t   */\n", "  setGlobalEventPacketPipe(\n\t    pipe: MonoTypeOperatorFunction<EventPacket> | null\n\t  ): void;\n\t  /**\n\t   * Associate RxReq with RxNostr.\n\t   * When the associated RxReq is manipulated,\n\t   * the RxNostr issues a new REQ to all relays allowed to be read.\n\t   * The method returns an Observable that issues EventPackets\n\t   * when an EVENT is received that is subscribed by RxReq.\n\t   * You can unsubscribe the Observable to CLOSE.\n", "   */\n\t  use(\n\t    rxReq: RxReq,\n\t    options?: Partial<RxNostrUseOptions>\n\t  ): Observable<EventPacket>;\n\t  /**\n\t   * Create an Observable that receives all events (EVENT) from all websocket connections.\n\t   *\n\t   * Nothing happens when this Observable is unsubscribed.\n\t   * */\n", "  createAllEventObservable(): Observable<EventPacket>;\n\t  /**\n\t   * Create an Observable that receives all errors from all websocket connections.\n\t   * Note that an Observable is terminated when it receives any error,\n\t   * so this method is the only way to receive errors arising from multiplexed websocket connections\n\t   * (It means that Observables returned by `use()` never throw error).\n\t   *\n\t   * Nothing happens when this Observable is unsubscribed.\n\t   * */\n\t  createAllErrorObservable(): Observable<ErrorPacket>;\n", "  /**\n\t   * Create an Observable that receives all messages from all websocket connections.\n\t   *\n\t   * Nothing happens when this Observable is unsubscribed.\n\t   * */\n\t  createAllMessageObservable(): Observable<MessagePacket>;\n\t  /**\n\t   * Create an Observable that receives changing of WebSocket connection state.\n\t   *\n\t   * Nothing happens when this Observable is unsubscribed.\n", "   */\n\t  createConnectionStateObservable(): Observable<ConnectionStatePacket>;\n\t  /**\n\t   * Attempt to send events to all relays that are allowed to write.\n\t   * The `seckey` option accepts both nsec format and hex format,\n\t   * and if omitted NIP-07 will be automatically used.\n\t   */\n\t  send(\n\t    params: Nostr.EventParameters,\n\t    options?: RxNostrSendOptions\n", "  ): Observable<OkPacket>;\n\t  /**\n\t   * Release all resources held by the RxNostr object.\n\t   * Any Observable resulting from this RxNostr will be in the completed state\n\t   * and will never receive messages again.\n\t   * RxReq used by this object is not affected; in other words, if the RxReq is used\n\t   * by another RxNostr, its use is not prevented.\n\t   */\n\t  dispose(): void;\n\t}\n", "/** Create a RxNostr object. This is the only way to create that. */\n\texport function createRxNostr(options?: Partial<RxNostrOptions>): RxNostr {\n\t  return new RxNostrImpl(options);\n\t}\n\texport interface RxNostrOptions {\n\t  /** Auto reconnection strategy. */\n\t  retry: BackoffConfig;\n\t  /**\n\t   * The time in milliseconds to timeout when following the backward strategy.\n\t   * The observable is terminated when the specified amount of time has elapsed\n", "   * during which no new events are available.\n\t   */\n\t  timeout: number;\n\t  globalRelayConfig?: {\n\t    disableAutoFetchNip11Limitations?: boolean;\n\t    maxConcurrentReqsFallback?: number;\n\t  };\n\t}\n\tconst makeRxNostrOptions = defineDefaultOptions<RxNostrOptions>({\n\t  retry: {\n", "    strategy: \"exponential\",\n\t    maxCount: 5,\n\t    initialDelay: 1000,\n\t  },\n\t  timeout: 10000,\n\t  globalRelayConfig: undefined,\n\t});\n\texport interface RxNostrUseOptions {\n\t  scope?: string[];\n\t}\n", "const makeRxNostrUseOptions = defineDefaultOptions<RxNostrUseOptions>({\n\t  scope: undefined,\n\t});\n\texport interface RxNostrSendOptions {\n\t  scope?: string[];\n\t  seckey?: string;\n\t}\n\tconst makeRxNostrSendOptions = defineDefaultOptions<RxNostrSendOptions>({\n\t  scope: undefined,\n\t  seckey: undefined,\n", "});\n\t/** Config object specifying WebSocket behavior. */\n\texport interface RelayConfig {\n\t  /** WebSocket endpoint URL. */\n\t  url: string;\n\t  /** If true, rxNostr can publish REQ and subscribe EVENTs. */\n\t  read: boolean;\n\t  /** If true, rxNostr can send EVENTs. */\n\t  write: boolean;\n\t  disableAutoFetchNip11Limitations?: boolean;\n", "}\n\t/** Parameter of `rxNostr.switchRelays()` */\n\texport type AcceptableRelaysConfig =\n\t  | (string | RelayConfig)[]\n\t  | Nostr.Nip07.GetRelayResult;\n\tclass RxNostrImpl implements RxNostr {\n\t  private options: RxNostrOptions;\n\t  private connections: Map<string, Connection> = new Map();\n\t  private ongoings: Map<string, OngoingReq> = new Map();\n\t  private messageIn$: Subject<MessagePacket> = new Subject();\n", "  private error$: Subject<ErrorPacket> = new Subject();\n\t  private status$: Subject<ConnectionStatePacket> = new Subject();\n\t  private globalEventPacketPipe: MonoTypeOperatorFunction<EventPacket> | null =\n\t    null;\n\t  private disposed = false;\n\t  private get messageOut$() {\n\t    return this.messageIn$.pipe(\n\t      mergeMap((packet) => {\n\t        const pipe = this.globalEventPacketPipe;\n\t        if (!pipe) {\n", "          return of(packet);\n\t        }\n\t        const message = packet.message;\n\t        if (message[0] !== \"EVENT\") {\n\t          return of(packet);\n\t        }\n\t        return of({\n\t          from: packet.from,\n\t          subId: message[1],\n\t          event: message[2],\n", "        }).pipe(\n\t          pipe,\n\t          map(\n\t            ({ from, subId, event }): MessagePacket => ({\n\t              from,\n\t              message: [\"EVENT\", subId, event],\n\t            })\n\t          )\n\t        );\n\t      })\n", "    );\n\t  }\n\t  constructor(options?: Partial<RxNostrOptions>) {\n\t    const opt = makeRxNostrOptions(options);\n\t    this.options = {\n\t      ...opt,\n\t    };\n\t  }\n\t  getRelays(): RelayConfig[] {\n\t    return Array.from(this.connections.values()).map(\n", "      ({ url, read, write }) => ({\n\t        url,\n\t        read,\n\t        write,\n\t      })\n\t    );\n\t  }\n\t  private createConnection({\n\t    url,\n\t    read,\n", "    write,\n\t    disableAutoFetchNip11Limitations,\n\t  }: RelayConfig): Connection {\n\t    const connection = new Connection(url, {\n\t      backoff: this.options.retry,\n\t      read,\n\t      write,\n\t      disableAutoFetchNip11Limitations:\n\t        disableAutoFetchNip11Limitations ??\n\t        this.options.globalRelayConfig?.disableAutoFetchNip11Limitations,\n", "      maxConcurrentReqsFallback:\n\t        this.options.globalRelayConfig?.maxConcurrentReqsFallback,\n\t    });\n\t    connection.getConnectionStateObservable().subscribe((state) => {\n\t      this.status$.next({\n\t        from: url,\n\t        state,\n\t      });\n\t    });\n\t    connection.getErrorObservable().subscribe((reason) => {\n", "      this.error$.next({ from: url, reason });\n\t    });\n\t    connection\n\t      .getMessageObservable()\n\t      .pipe(\n\t        catchError((reason: unknown) => {\n\t          this.error$.next({ from: url, reason });\n\t          return EMPTY;\n\t        })\n\t      )\n", "      .subscribe((v) => {\n\t        this.messageIn$.next(v);\n\t      });\n\t    return connection;\n\t  }\n\t  async switchRelays(config: AcceptableRelaysConfig): Promise<void> {\n\t    const nextConns: Map<string, Connection> = new Map();\n\t    for (const { url, read, write } of normalizeRelaysConfig(config)) {\n\t      // pop a connection if exists\n\t      const prevConn = this.connections.get(url);\n", "      this.connections.delete(url);\n\t      if (prevConn) {\n\t        prevConn.read = read;\n\t        prevConn.write = write;\n\t        nextConns.set(url, prevConn);\n\t      } else {\n\t        nextConns.set(url, this.createConnection({ url, read, write }));\n\t      }\n\t    }\n\t    // connections that are no longer used\n", "    for (const conn of this.connections.values()) {\n\t      conn.dispose();\n\t    }\n\t    const ensureConns: Promise<unknown>[] = [];\n\t    for (const conn of nextConns.values()) {\n\t      if (conn.read) {\n\t        ensureConns.push(conn.start());\n\t      } else {\n\t        conn.stop();\n\t      }\n", "    }\n\t    await Promise.all(ensureConns);\n\t    this.connections = nextConns;\n\t    // If disposed during switchRelay processing\n\t    if (this.disposed) {\n\t      for (const conn of this.connections.values()) {\n\t        conn.dispose();\n\t      }\n\t      return;\n\t    }\n", "    for (const { req, scope } of this.ongoings.values()) {\n\t      this.ensureReq(req, { scope });\n\t    }\n\t    // --- scoped untility pure functions ---\n\t    function normalizeRelaysConfig(\n\t      config: AcceptableRelaysConfig\n\t    ): RelayConfig[] {\n\t      if (Array.isArray(config)) {\n\t        return config.map((urlOrConfig) => {\n\t          const relay: RelayConfig =\n", "            typeof urlOrConfig === \"string\"\n\t              ? {\n\t                  url: urlOrConfig,\n\t                  read: true,\n\t                  write: true,\n\t                }\n\t              : urlOrConfig;\n\t          relay.url = normalizeRelayUrl(relay.url);\n\t          return relay;\n\t        });\n", "      } else {\n\t        return Object.entries(config).map(([url, flags]) => ({\n\t          url: normalizeRelayUrl(url),\n\t          ...flags,\n\t        }));\n\t      }\n\t    }\n\t  }\n\t  async addRelay(relay: string | RelayConfig): Promise<void> {\n\t    await this.switchRelays([...this.getRelays(), relay]);\n", "  }\n\t  async removeRelay(url: string): Promise<void> {\n\t    const u = normalizeRelayUrl(url);\n\t    const currentRelays = this.getRelays();\n\t    const nextRelays = currentRelays.filter((relay) => relay.url !== u);\n\t    if (currentRelays.length !== nextRelays.length) {\n\t      await this.switchRelays(nextRelays);\n\t    }\n\t  }\n\t  hasRelay(url: string): boolean {\n", "    const u = normalizeRelayUrl(url);\n\t    return this.getRelays().some((relay) => relay.url === u);\n\t  }\n\t  canWriteRelay(url: string): boolean {\n\t    const u = normalizeRelayUrl(url);\n\t    return this.getRelays().some((relay) => relay.url === u && relay.write);\n\t  }\n\t  canReadRelay(url: string): boolean {\n\t    const u = normalizeRelayUrl(url);\n\t    return this.getRelays().some((relay) => relay.url === u && relay.read);\n", "  }\n\t  async fetchAllRelaysInfo(): Promise<\n\t    Record<string, Nostr.Nip11.RelayInfo | null>\n\t  > {\n\t    const entries = await Promise.all(\n\t      Array.from(this.connections.keys()).map(\n\t        async (url): Promise<[string, Nostr.Nip11.RelayInfo | null]> => [\n\t          url,\n\t          await fetchRelayInfo(url).catch(() => null),\n\t        ]\n", "      )\n\t    );\n\t    return Object.fromEntries(entries);\n\t  }\n\t  getAllRelayState(): Record<string, ConnectionState> {\n\t    return Object.fromEntries(\n\t      Array.from(this.connections.values()).map((e) => [\n\t        e.url,\n\t        this.getRelayState(e.url),\n\t      ])\n", "    );\n\t  }\n\t  getRelayState(url: string): ConnectionState {\n\t    const conn = this.connections.get(normalizeRelayUrl(url));\n\t    if (!conn) {\n\t      throw new Error(\"RelayConfig not found\");\n\t    }\n\t    // this.relays[url] may be set before this.relays[url].websocket is initialized\n\t    return conn?.getConnectionState() ?? \"not-started\";\n\t  }\n", "  reconnect(url: string): void {\n\t    if (this.canReadRelay(url)) {\n\t      this.connections.get(normalizeRelayUrl(url))?.start();\n\t    }\n\t  }\n\t  setGlobalEventPacketPipe(pipe: MonoTypeOperatorFunction<EventPacket> | null) {\n\t    this.globalEventPacketPipe = pipe;\n\t  }\n\t  use(\n\t    rxReq: RxReq,\n", "    options?: Partial<RxNostrUseOptions>\n\t  ): Observable<EventPacket> {\n\t    const { scope: _scope } = makeRxNostrUseOptions(options);\n\t    const scope = _scope?.map(normalizeRelayUrl);\n\t    const TIMEOUT = this.options.timeout;\n\t    const strategy = rxReq.strategy;\n\t    const rxReqId = rxReq.rxReqId;\n\t    const message$ = this.messageOut$;\n\t    const ongoings = this.ongoings;\n\t    const getAllRelayState = this.getAllRelayState.bind(this);\n", "    const createConnectionStateObservable =\n\t      this.createConnectionStateObservable.bind(this);\n\t    const ensureReq = this.ensureReq.bind(this);\n\t    const finalizeReq = this.finalizeReq.bind(this);\n\t    const subId$ = rxReq.getReqObservable().pipe(\n\t      filter((filters): filters is LazyFilter[] => filters !== null),\n\t      strategy === \"oneshot\" ? first() : identity,\n\t      attachSubId(),\n\t      strategy === \"forward\" ? manageActiveForwardReq() : identity,\n\t      tap((req) => {\n", "        ensureReq(req, { overwrite: strategy === \"forward\", scope });\n\t      }),\n\t      map(([, subId]) => subId)\n\t    );\n\t    if (strategy === \"forward\") {\n\t      const subId = makeSubId({\n\t        rxReqId,\n\t      });\n\t      const resource: Unsubscribable[] = [];\n\t      const subject = new Subject<EventPacket>();\n", "      resource.push(subject);\n\t      return subject.pipe(\n\t        tap({\n\t          subscribe: () => {\n\t            resource.push(subId$.subscribe());\n\t            resource.push(\n\t              message$\n\t                .pipe(filterBySubId(subId), pickEvents())\n\t                .subscribe((v) => {\n\t                  subject.next(v);\n", "                })\n\t            );\n\t          },\n\t          finalize: () => {\n\t            for (const r of resource) {\n\t              r.unsubscribe();\n\t            }\n\t            finalizeReq({ subId });\n\t          },\n\t        })\n", "      );\n\t    } else {\n\t      return subId$.pipe(map(createEoseManagedEventObservable), mergeAll());\n\t    }\n\t    function attachSubId(): OperatorFunction<LazyFilter[], LazyREQ> {\n\t      const makeId = (index?: number) => makeSubId({ rxReqId, index });\n\t      switch (strategy) {\n\t        case \"backward\":\n\t          return map((filters, index) => [\"REQ\", makeId(index), ...filters]);\n\t        case \"forward\":\n", "        case \"oneshot\":\n\t          return map((filters) => [\"REQ\", makeId(), ...filters]);\n\t      }\n\t    }\n\t    function manageActiveForwardReq(): MonoTypeOperatorFunction<LazyREQ> {\n\t      const recordActiveReq = (req: LazyREQ) => {\n\t        const subId = req[1];\n\t        ongoings.set(subId, {\n\t          req,\n\t          scope,\n", "        });\n\t      };\n\t      const forgetActiveReq = (subId: string) => {\n\t        ongoings.delete(subId);\n\t      };\n\t      return tap({\n\t        next: (req: LazyREQ) => {\n\t          recordActiveReq(req);\n\t        },\n\t        finalize: () => {\n", "          forgetActiveReq(\n\t            makeSubId({\n\t              rxReqId,\n\t            })\n\t          );\n\t        },\n\t      });\n\t    }\n\t    function createEoseManagedEventObservable(\n\t      subId: string\n", "    ): Observable<EventPacket> {\n\t      const eose$ = new Subject<void>();\n\t      const complete$ = new Subject<void>();\n\t      const eoseRelays = new Set<string>();\n\t      const manageCompletion = merge(\n\t        eose$,\n\t        createConnectionStateObservable()\n\t      ).subscribe(() => {\n\t        const status = getAllRelayState();\n\t        const shouldComplete = Object.entries(status).every(\n", "          ([url, state]) =>\n\t            (scope && !scope.includes(url)) ||\n\t            state === \"error\" ||\n\t            state === \"terminated\" ||\n\t            (state === \"ongoing\" && eoseRelays.has(url))\n\t        );\n\t        if (shouldComplete) {\n\t          complete$.next();\n\t        }\n\t      });\n", "      return message$.pipe(\n\t        takeUntil(complete$),\n\t        completeOnTimeout(TIMEOUT),\n\t        filterBySubId(subId),\n\t        filter((e) => !eoseRelays.has(e.from)),\n\t        tap((e) => {\n\t          if (e.message[0] === \"EOSE\") {\n\t            eoseRelays.add(e.from);\n\t            finalizeReq({ subId, url: e.from });\n\t            eose$.next();\n", "          }\n\t        }),\n\t        pickEvents(),\n\t        finalize(() => {\n\t          finalizeReq({ subId });\n\t          complete$.unsubscribe();\n\t          eose$.unsubscribe();\n\t          manageCompletion.unsubscribe();\n\t        })\n\t      );\n", "    }\n\t    function filterBySubId(\n\t      subId: string\n\t    ): MonoTypeOperatorFunction<MessagePacket> {\n\t      return filter(\n\t        (packet) =>\n\t          (packet.message[0] === \"EVENT\" || packet.message[0] === \"EOSE\") &&\n\t          packet.message[1] === subId\n\t      );\n\t    }\n", "    function pickEvents(): OperatorFunction<MessagePacket, EventPacket> {\n\t      return mergeMap(({ from, message }) =>\n\t        message[0] === \"EVENT\"\n\t          ? of({ from, subId: message[1], event: message[2] })\n\t          : EMPTY\n\t      );\n\t    }\n\t  }\n\t  createAllEventObservable(): Observable<EventPacket> {\n\t    return this.messageOut$.pipe(\n", "      mergeMap(({ from, message }) =>\n\t        message[0] === \"EVENT\"\n\t          ? of({ from, subId: message[1], event: message[2] })\n\t          : EMPTY\n\t      )\n\t    );\n\t  }\n\t  createAllErrorObservable(): Observable<ErrorPacket> {\n\t    return this.error$.asObservable();\n\t  }\n", "  createAllMessageObservable(): Observable<MessagePacket> {\n\t    return this.messageOut$;\n\t  }\n\t  createConnectionStateObservable(): Observable<ConnectionStatePacket> {\n\t    return this.status$.asObservable();\n\t  }\n\t  send(\n\t    params: Nostr.EventParameters,\n\t    options?: RxNostrSendOptions\n\t  ): Observable<OkPacket> {\n", "    const { seckey, scope: _scope } = makeRxNostrSendOptions(options);\n\t    const scope = _scope?.map(normalizeRelayUrl);\n\t    const writableConns = Array.from(this.connections.values()).filter(\n\t      (conn) => (!scope || scope.includes(conn.url)) && conn.write\n\t    );\n\t    const subject = new ReplaySubject<OkPacket>(writableConns.length);\n\t    let subscription: Subscription | null = null;\n\t    getSignedEvent(params, seckey).then((event) => {\n\t      if (!subject.closed) {\n\t        subscription = this.createAllMessageObservable().subscribe(\n", "          ({ from, message }) => {\n\t            if (message[0] !== \"OK\") {\n\t              return;\n\t            }\n\t            subject.next({\n\t              from,\n\t              id: event.id,\n\t              ok: message[2],\n\t            });\n\t          }\n", "        );\n\t      }\n\t      for (const conn of writableConns) {\n\t        conn.sendEVENT([\"EVENT\", event]);\n\t      }\n\t    });\n\t    return subject.pipe(\n\t      take(writableConns.length),\n\t      timeout(30 * 1000),\n\t      finalize(() => {\n", "        subject.complete();\n\t        subject.unsubscribe();\n\t        subscription?.unsubscribe();\n\t      })\n\t    );\n\t  }\n\t  dispose(): void {\n\t    this.disposed = true;\n\t    this.messageIn$.complete();\n\t    this.error$.complete();\n", "    for (const conn of this.connections.values()) {\n\t      conn.dispose();\n\t    }\n\t  }\n\t  private ensureReq(\n\t    req: LazyREQ,\n\t    options?: { scope?: string[] | null; overwrite?: boolean }\n\t  ) {\n\t    const scope = options?.scope;\n\t    for (const url of this.connections.keys()) {\n", "      const conn = this.connections.get(url);\n\t      if (!conn || !conn.read || (scope && !scope.includes(url))) {\n\t        continue;\n\t      }\n\t      conn.ensureReq(req, { overwrite: options?.overwrite });\n\t    }\n\t  }\n\t  private finalizeReq(params: { subId: string; url?: string }) {\n\t    const { subId, url } = params;\n\t    if (subId === undefined && url === undefined) {\n", "      throw new Error();\n\t    }\n\t    if (url) {\n\t      const conn = this.connections.get(url);\n\t      conn?.finalizeReq(subId);\n\t    } else {\n\t      for (const conn of this.connections.values()) {\n\t        conn?.finalizeReq(subId);\n\t      }\n\t    }\n", "  }\n\t}\n\tinterface OngoingReq {\n\t  req: LazyREQ;\n\t  scope?: string[];\n\t}\n\tfunction makeSubId(params: { rxReqId: string; index?: number }): string {\n\t  return `${params.rxReqId}:${params.index ?? 0}`;\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from \"./helper.js\";\n\texport { toHex } from \"./nostr/bech32.js\";\n\texport {\n\t  compareEvents,\n\t  earlierEvent,\n\t  getEventHash,\n\t  getPublicKey,\n\t  getSignature,\n\t  getSignedEvent,\n\t  laterEvent,\n", "} from \"./nostr/event.js\";\n\texport { isFiltered } from \"./nostr/filter.js\";\n\texport { fetchRelayInfo } from \"./nostr/nip11.js\";\n\texport * from \"./operator.js\";\n\texport * from \"./packet.js\";\n\texport * from \"./req.js\";\n\texport * from \"./rx-nostr.js\";\n"]}
{"filename": "src/operator.ts", "chunked_list": ["import Nostr from \"nostr-typedef\";\n\timport {\n\t  catchError,\n\t  delay,\n\t  distinct,\n\t  distinctUntilChanged,\n\t  EMPTY,\n\t  filter,\n\t  groupBy,\n\t  map,\n", "  mergeAll,\n\t  mergeMap,\n\t  type MonoTypeOperatorFunction,\n\t  type ObservableInput,\n\t  of,\n\t  type OperatorFunction,\n\t  pipe,\n\t  scan,\n\t  tap,\n\t  timeout,\n", "  TimeoutError,\n\t} from \"rxjs\";\n\timport { evalFilters } from \"./helper.js\";\n\timport { compareEvents, verify as _verify } from \"./nostr/event.js\";\n\timport { isFiltered, MatchFilterOptions } from \"./nostr/filter.js\";\n\timport { EventPacket, LazyFilter, MessagePacket, ReqPacket } from \"./packet.js\";\n\timport { defineDefaultOptions } from \"./util.js\";\n\t// --------------------- //\n\t// EventPacket operators //\n\t// --------------------- //\n", "/**\n\t * Remove the events once seen.\n\t */\n\texport function uniq(\n\t  flushes?: ObservableInput<unknown>\n\t): MonoTypeOperatorFunction<EventPacket> {\n\t  return distinct<EventPacket, string>(({ event }) => event.id, flushes);\n\t}\n\t/**\n\t * Create a customizable uniq operator.\n", " *\n\t * If `keyFn()` returns a non-null key, the key is stored in `Set`.\n\t * The operator filters packets with keys already stored.\n\t *\n\t * The `Set` returned in the second value of the tuple\n\t * can be manipulated externally or in optional event handlers.\n\t * For example, you can call `Set#clear()` to forget all keys.\n\t */\n\texport function createUniq<T>(\n\t  keyFn: (packet: EventPacket) => T | null,\n", "  options?: CreateUniqOptions<T>\n\t): [MonoTypeOperatorFunction<EventPacket>, Set<T>] {\n\t  const cache = new Set<T>();\n\t  return [\n\t    filter((packet) => {\n\t      const key = keyFn(packet);\n\t      if (key === null) {\n\t        return true;\n\t      }\n\t      if (cache.has(key)) {\n", "        options?.onHit?.(packet, cache);\n\t        return false;\n\t      } else {\n\t        cache.add(key);\n\t        options?.onCache?.(packet, cache);\n\t        return true;\n\t      }\n\t    }),\n\t    cache,\n\t  ];\n", "}\n\t/**\n\t * Only the latest events are allowed to pass.\n\t */\n\texport function latest(): MonoTypeOperatorFunction<EventPacket> {\n\t  return pipe(\n\t    scan<EventPacket>((acc, packet) =>\n\t      compareEvents(acc.event, packet.event) < 0 ? packet : acc\n\t    ),\n\t    distinctUntilChanged(\n", "      (a, b) => a === b,\n\t      ({ event }) => event.id\n\t    )\n\t  );\n\t}\n\t/**\n\t * For each key, only the latest events are allowed to pass.\n\t */\n\texport function latestEach<K>(\n\t  key: (packet: EventPacket) => K\n", "): MonoTypeOperatorFunction<EventPacket> {\n\t  return pipe(groupBy(key), map(pipe(latest())), mergeAll());\n\t}\n\t/**\n\t * Only events with a valid signature are allowed to pass.\n\t */\n\texport function verify(): MonoTypeOperatorFunction<EventPacket> {\n\t  return filter<EventPacket>(({ event }) => _verify(event));\n\t}\n\t/**\n", " * Only events with given kind are allowed to pass.\n\t */\n\texport function filterKind<K extends number>(\n\t  kind: K\n\t): MonoTypeOperatorFunction<EventPacket> {\n\t  return filter<EventPacket>(({ event }) => event.kind === kind);\n\t}\n\t/**\n\t * Filter events based on a REQ filter object.\n\t */\n", "export function filterBy(\n\t  filters: LazyFilter | LazyFilter[],\n\t  options?: MatchFilterOptions & FilterByOptions\n\t): MonoTypeOperatorFunction<EventPacket> {\n\t  const { not } = makeFilterByOptions(options);\n\t  const evaledFilter = evalFilters(filters);\n\t  return filter(({ event }) => {\n\t    const match = isFiltered(event, evaledFilter, options);\n\t    return not ? !match : match;\n\t  });\n", "}\n\t/**\n\t * Accumulate latest events in order of new arrival (based on `created_at`).\n\t */\n\texport function timeline(\n\t  limit?: number\n\t): OperatorFunction<EventPacket, EventPacket[]> {\n\t  return scan<EventPacket, EventPacket[]>((acc, packet) => {\n\t    const next = [...acc, packet].sort(\n\t      (a, b) => -1 * compareEvents(a.event, b.event)\n", "    );\n\t    if (limit !== undefined) {\n\t      next.splice(limit);\n\t    }\n\t    return next;\n\t  }, []);\n\t}\n\texport function sortEvents(\n\t  bufferTime: number,\n\t  compareFn?: (a: EventPacket, b: EventPacket) => number\n", "): MonoTypeOperatorFunction<EventPacket> {\n\t  return sort(\n\t    bufferTime,\n\t    compareFn ?? ((a, b) => compareEvents(a.event, b.event))\n\t  );\n\t}\n\t// ----------------------- //\n\t// MessagePacket operators //\n\t// ----------------------- //\n\texport function filterType<T extends Nostr.ToClientMessage.Type>(\n", "  type: T\n\t): OperatorFunction<\n\t  MessagePacket,\n\t  MessagePacket<Nostr.ToClientMessage.Message<T>>\n\t> {\n\t  return filter(\n\t    (packet): packet is MessagePacket<Nostr.ToClientMessage.Message<T>> =>\n\t      packet.message[0] === type\n\t  );\n\t}\n", "// ------------------- //\n\t// ReqPacket operators //\n\t// ------------------- //\n\t/**\n\t * Map REQ packets into a single REQ packet.\n\t *\n\t * It is useful to reduce REQ requests in a time interval.\n\t */\n\texport function batch(\n\t  /** Function used for merge REQ filters. Default behavior is simple concatenation. */\n", "  mergeFilter?: MergeFilter\n\t): OperatorFunction<ReqPacket[], ReqPacket> {\n\t  return map((f) =>\n\t    f.reduce((acc, v) => {\n\t      if (acc === null) {\n\t        return v;\n\t      }\n\t      if (v === null) {\n\t        return acc;\n\t      }\n", "      return (mergeFilter ?? defaultMergeFilter)(acc, v);\n\t    }, null)\n\t  );\n\t}\n\t/**\n\t * Chunk a REQ packet into multiple REQ packets.\n\t *\n\t * It is useful to avoid to send large REQ filter.\n\t */\n\texport function chunk(\n", "  predicate: (f: LazyFilter[]) => boolean,\n\t  toChunk: (f: LazyFilter[]) => LazyFilter[][]\n\t): MonoTypeOperatorFunction<ReqPacket> {\n\t  return mergeMap((f) =>\n\t    f !== null && predicate(f) ? of(...toChunk(f)) : of(f)\n\t  );\n\t}\n\t// ----------------- //\n\t// General operators //\n\t// ----------------- //\n", "/**\n\t * Almost RxJS's `timeout`, but won't throw.\n\t */\n\texport function completeOnTimeout<T>(\n\t  time: number\n\t): MonoTypeOperatorFunction<T> {\n\t  return pipe(\n\t    timeout(time),\n\t    catchError((error: unknown) => {\n\t      if (error instanceof TimeoutError) {\n", "        return EMPTY;\n\t      } else {\n\t        throw error;\n\t      }\n\t    })\n\t  );\n\t}\n\t/**\n\t * Buffer the received values for a specified time\n\t * and return the values in sorted order as possible.\n", " */\n\texport function sort<T>(\n\t  bufferTime: number,\n\t  compareFn: (a: T, b: T) => number\n\t): MonoTypeOperatorFunction<T> {\n\t  const buffer: T[] = [];\n\t  return pipe(\n\t    tap((v) => {\n\t      buffer.push(v);\n\t      buffer.sort(compareFn);\n", "    }),\n\t    delay(bufferTime),\n\t    map(() => {\n\t      if (buffer.length <= 0) {\n\t        throw new Error(\"Logic Error: This is rx-nostr's internal bug.\");\n\t      }\n\t      // Non-null is valid because the lenght has been checked.\n\t      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t      return buffer.shift()!;\n\t    })\n", "  );\n\t}\n\t// ----------- //\n\t// Other stuff //\n\t// ----------- //\n\texport type MergeFilter = (a: LazyFilter[], b: LazyFilter[]) => LazyFilter[];\n\tfunction defaultMergeFilter(a: LazyFilter[], b: LazyFilter[]): LazyFilter[] {\n\t  return [...a, ...b];\n\t}\n\texport interface CreateUniqOptions<T> {\n", "  onCache?: (packet: EventPacket, cache: Set<T>) => void;\n\t  onHit?: (packet: EventPacket, cache: Set<T>) => void;\n\t}\n\texport interface FilterByOptions {\n\t  not: boolean;\n\t}\n\tconst makeFilterByOptions = defineDefaultOptions<FilterByOptions>({\n\t  not: false,\n\t});\n"]}
{"filename": "src/util.ts", "chunked_list": ["import normalizeUrl from \"normalize-url\";\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\texport function defineDefaultOptions<T extends Record<string, any>>(\n\t  defaultParams: T\n\t): (givenParams?: Partial<T>) => T {\n\t  return (givenParams) =>\n\t    Object.fromEntries(\n\t      Object.keys(defaultParams).map((key) => [\n\t        key,\n\t        givenParams?.[key] ?? defaultParams[key],\n", "      ])\n\t    ) as T;\n\t}\n\texport type Override<T extends object, U extends object> = {\n\t  [K in keyof T | keyof U]: K extends keyof U\n\t    ? U[K]\n\t    : K extends keyof T\n\t    ? T[K]\n\t    : never;\n\t};\n", "export function normalizeRelayUrl(url: string) {\n\t  return normalizeUrl(url, {\n\t    normalizeProtocol: false,\n\t    removeTrailingSlash: true,\n\t  });\n\t}\n"]}
{"filename": "src/__test__/operator.test.ts", "chunked_list": ["import { map, of } from \"rxjs\";\n\timport { test } from \"vitest\";\n\timport { filterType, latestEach } from \"../operator.js\";\n\timport { EventPacket, MessagePacket } from \"../packet.js\";\n\timport { faker, testScheduler } from \"./helper.js\";\n\ttest(\"latestEach()\", async () => {\n\t  testScheduler().run((helpers) => {\n\t    const { expectObservable } = helpers;\n\t    const packet$ = of<EventPacket[]>(\n\t      faker.eventPacket({ id: \"1\", pubkey: \"a\", created_at: 3 }),\n", "      faker.eventPacket({ id: \"2\", pubkey: \"b\", created_at: 1 }),\n\t      faker.eventPacket({ id: \"3\", pubkey: \"a\", created_at: 2 }),\n\t      faker.eventPacket({ id: \"4\", pubkey: \"a\", created_at: 1 }),\n\t      faker.eventPacket({ id: \"5\", pubkey: \"b\", created_at: 3 }),\n\t      faker.eventPacket({ id: \"6\", pubkey: \"b\", created_at: 2 })\n\t    ).pipe(latestEach((packet) => packet.event.pubkey));\n\t    expectObservable(packet$.pipe(map((e) => e.event.id))).toEqual(\n\t      of(\"1\", \"2\", \"5\")\n\t    );\n\t  });\n", "});\n\ttest(\"filterType()\", async () => {\n\t  testScheduler().run((helpers) => {\n\t    const { expectObservable } = helpers;\n\t    const packets: MessagePacket[] = [\n\t      faker.messagePacket(faker.toClientMessage.NOTICE(\"Hello\")),\n\t      faker.messagePacket(faker.toClientMessage.EVENT(\"*\")),\n\t      faker.messagePacket(faker.toClientMessage.AUTH()),\n\t      faker.messagePacket(faker.toClientMessage.NOTICE(\"Nostr\")),\n\t      faker.messagePacket(faker.toClientMessage.COUNT(\"*\")),\n", "      faker.messagePacket(faker.toClientMessage.EVENT(\"*\")),\n\t    ];\n\t    const packet$ = of(...packets).pipe(filterType(\"NOTICE\"));\n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t    expectObservable(packet$).toEqual(of<any[]>(packets[0], packets[3]));\n\t  });\n\t});\n"]}
{"filename": "src/__test__/subscription.test.ts", "chunked_list": ["import { afterEach, assert, beforeEach, describe, expect, test } from \"vitest\";\n\timport { createMockRelay, type MockRelay } from \"vitest-nostr\";\n\timport { WebSocketCloseCode } from \"../connection.js\";\n\timport {\n\t  createRxBackwardReq,\n\t  createRxForwardReq,\n\t  createRxNostr,\n\t  createRxOneshotReq,\n\t  RxNostr,\n\t} from \"../index.js\";\n", "import { faker, spyEvent, spySub } from \"./helper.js\";\n\tdescribe(\"Basic subscription behavior (single relay)\", () => {\n\t  const RELAY_URL = \"ws://localhost:1234\";\n\t  let rxNostr: RxNostr;\n\t  let relay: MockRelay;\n\t  beforeEach(async () => {\n\t    relay = createMockRelay(RELAY_URL);\n\t    rxNostr = createRxNostr({\n\t      retry: { strategy: \"immediately\", maxCount: 1 },\n\t      globalRelayConfig: {\n", "        disableAutoFetchNip11Limitations: true,\n\t      },\n\t    });\n\t    await rxNostr.switchRelays([RELAY_URL]);\n\t    await relay.connected;\n\t  });\n\t  afterEach(() => {\n\t    rxNostr.dispose();\n\t    relay.close({\n\t      code: WebSocketCloseCode.DISPOSED_BY_RX_NOSTR,\n", "      reason: \"Clean up on afterEach()\",\n\t      wasClean: true,\n\t    });\n\t  });\n\t  test(\"[forward] Each REQ is published with the same subId.\", async () => {\n\t    const req = createRxForwardReq(\"sub\");\n\t    rxNostr.use(req).subscribe();\n\t    req.emit(faker.filter());\n\t    await expect(relay).toReceiveREQ(\"sub:0\");\n\t    req.emit(faker.filters());\n", "    await expect(relay).toReceiveREQ(\"sub:0\");\n\t    req.emit(faker.filters());\n\t    await expect(relay).toReceiveREQ(\"sub:0\");\n\t  });\n\t  test(\"[forward] If connection is abnormally closed, REQ will be retried.\", async () => {\n\t    const req = createRxForwardReq(\"sub\");\n\t    const spy = spyEvent();\n\t    rxNostr.use(req).pipe(spy.tap()).subscribe();\n\t    req.emit(faker.filters());\n\t    await expect(relay).toReceiveREQ(\"sub:0\");\n", "    // Emulate an abnormal disconnection of a relay.\n\t    const socket = await relay.getSocket(0);\n\t    socket.close({\n\t      code: WebSocketCloseCode.ABNORMAL_CLOSURE,\n\t      reason: \"Relay's internal error\",\n\t      wasClean: true,\n\t    });\n\t    await expect(relay).toReceiveREQ(\"sub:0\");\n\t    relay.emitEVENT(\"sub:0\");\n\t    await expect(spy).toSeeEVENT();\n", "  });\n\t  test(\"[forward] Backoff option `maxCount` works.\", async () => {\n\t    const req = createRxForwardReq(\"sub\");\n\t    const spy = spyEvent();\n\t    rxNostr.use(req).pipe(spy.tap()).subscribe();\n\t    req.emit(faker.filters());\n\t    await expect(relay).toReceiveREQ(\"sub:0\");\n\t    (await relay.getSocket(0)).close({\n\t      code: WebSocketCloseCode.ABNORMAL_CLOSURE,\n\t      reason: \"Relay's internal error\",\n", "      wasClean: true,\n\t    });\n\t    await expect(relay).toReceiveREQ(\"sub:0\");\n\t    (await relay.getSocket(1)).close({\n\t      code: WebSocketCloseCode.ABNORMAL_CLOSURE,\n\t      reason: \"Relay's internal error\",\n\t      wasClean: true,\n\t    });\n\t    // FIXME: dirty\n\t    return new Promise((resolve) => {\n", "      setTimeout(resolve, 100);\n\t    }).then(async () => {\n\t      await expect(rxNostr.getRelayState(RELAY_URL)).toBe(\"error\");\n\t    });\n\t  });\n\t  test(\"[forward] If connection is closed with 4000, REQ will not be retried.\", async () => {\n\t    const req = createRxForwardReq(\"sub\");\n\t    const spy = spyEvent();\n\t    rxNostr.use(req).pipe(spy.tap()).subscribe();\n\t    req.emit(faker.filters());\n", "    await expect(relay).toReceiveREQ(\"sub:0\");\n\t    // Emulate an abnormal disconnection of a relay.\n\t    const socket = await relay.getSocket(0);\n\t    socket.close({\n\t      code: WebSocketCloseCode.DONT_RETRY,\n\t      reason: \"Relay's internal error, but should not retry.\",\n\t      wasClean: true,\n\t    });\n\t    rxNostr.send(faker.event());\n\t    // REQ will not be retried, so next message is EVENT\n", "    await expect(relay).toReceiveEVENT();\n\t  });\n\t  test(\"[forward] since/until is reevaluated when a lazy REQ is resubmitted.\", async () => {\n\t    const req = createRxForwardReq(\"sub\");\n\t    rxNostr.use(req).subscribe();\n\t    let since = 0;\n\t    req.emit({ ...faker.filter(), since: () => since++ });\n\t    await expect(relay).toReceiveREQ([\n\t      \"sub:0\",\n\t      { ...faker.filter(), since: 0 },\n", "    ]);\n\t    // Emulate an abnormal disconnection of a relay.\n\t    const socket = await relay.getSocket(0);\n\t    socket.close({\n\t      code: WebSocketCloseCode.ABNORMAL_CLOSURE,\n\t      reason: \"Relay's internal error\",\n\t      wasClean: true,\n\t    });\n\t    await expect(relay).toReceiveREQ([\n\t      \"sub:0\",\n", "      { ...faker.filter(), since: 1 },\n\t    ]);\n\t  });\n\t  test(\"[forward] Reject EVENTs that do not match the given filters.\", async () => {\n\t    const req = createRxForwardReq(\"sub\");\n\t    const spy = spyEvent();\n\t    rxNostr.use(req).pipe(spy.tap()).subscribe();\n\t    req.emit({ kinds: [1] });\n\t    await expect(relay).toReceiveREQ(\"sub:0\");\n\t    relay.emitEVENT(\"sub:0\", faker.event({ kind: 1, content: \"pass\" }));\n", "    await expect(spy).toSeeEVENT([\n\t      \"sub:0\",\n\t      faker.event({ kind: 1, content: \"pass\" }),\n\t    ]);\n\t    relay.emitEVENT(\"sub:0\", faker.event({ kind: 0, content: \"rejected\" }));\n\t    relay.emitEVENT(\"sub:0\", faker.event({ kind: 1, content: \"pass\" }));\n\t    await expect(spy).toSeeEVENT([\n\t      \"sub:0\",\n\t      faker.event({ kind: 1, content: \"pass\" }),\n\t    ]);\n", "  });\n\t  test(\"[backward] After receiving EOSE, CLOSE is sent out.\", async () => {\n\t    const req = createRxBackwardReq(\"sub\");\n\t    rxNostr.use(req).pipe().subscribe();\n\t    req.emit(faker.filters());\n\t    await expect(relay).toReceiveREQ(\"sub:0\");\n\t    relay.emitEOSE(\"sub:0\");\n\t    await expect(relay).toReceiveCLOSE(\"sub:0\");\n\t  });\n\t  test(\"[backward] Receipt of EOSE does not terminate the Observable.\", async () => {\n", "    const req = createRxBackwardReq(\"sub\");\n\t    const spy = spySub();\n\t    rxNostr.use(req).pipe(spy.tap()).subscribe();\n\t    req.emit(faker.filters());\n\t    await expect(relay).toReceiveREQ();\n\t    relay.emitEOSE(\"sub:0\");\n\t    assert(!spy.completed());\n\t  });\n\t  test(\"[backward] Each EOSE CLOSEs the REQ in the order of arrival.\", async () => {\n\t    const req = createRxBackwardReq(\"sub\");\n", "    rxNostr.use(req).subscribe();\n\t    req.emit(faker.filters());\n\t    await expect(relay).toReceiveREQ(\"sub:0\");\n\t    req.emit(faker.filters());\n\t    await expect(relay).toReceiveREQ(\"sub:1\");\n\t    req.emit(faker.filters());\n\t    await expect(relay).toReceiveREQ(\"sub:2\");\n\t    relay.emitEOSE(\"sub:2\");\n\t    await expect(relay).toReceiveCLOSE(\"sub:2\");\n\t    relay.emitEOSE(\"sub:1\");\n", "    await expect(relay).toReceiveCLOSE(\"sub:1\");\n\t    relay.emitEOSE(\"sub:0\");\n\t    await expect(relay).toReceiveCLOSE(\"sub:0\");\n\t  });\n\t  test(\"[backward] Even if a newer REQ emits EOSE, EVENTs from older but still active REQ can be received.\", async () => {\n\t    const req = createRxBackwardReq(\"sub\");\n\t    const spy = spyEvent();\n\t    rxNostr.use(req).pipe(spy.tap()).subscribe();\n\t    req.emit(faker.filters());\n\t    await expect(relay).toReceiveREQ(\"sub:0\");\n", "    req.emit(faker.filters());\n\t    await expect(relay).toReceiveREQ(\"sub:1\");\n\t    relay.emitEOSE(\"sub:1\");\n\t    await expect(relay).toReceiveCLOSE(\"sub:1\");\n\t    relay.emitEVENT(\"sub:0\");\n\t    await expect(spy).toSeeEVENT(\"sub:0\");\n\t    relay.emitEOSE(\"sub:0\");\n\t    await expect(relay).toReceiveCLOSE(\"sub:0\");\n\t  });\n\t  test(\"[backward] If connection is abnormally closed before receiving EOSE, REQ will be retried.\", async () => {\n", "    const req = createRxBackwardReq(\"sub\");\n\t    const spy = spyEvent();\n\t    rxNostr.use(req).pipe(spy.tap()).subscribe();\n\t    req.emit(faker.filters());\n\t    await expect(relay).toReceiveREQ(\"sub:0\");\n\t    // Emulate an abnormal disconnection of a relay.\n\t    const socket = await relay.getSocket(0);\n\t    socket.close({\n\t      code: WebSocketCloseCode.ABNORMAL_CLOSURE,\n\t      reason: \"Relay's internal error\",\n", "      wasClean: true,\n\t    });\n\t    await expect(relay).toReceiveREQ(\"sub:0\");\n\t    relay.emitEVENT(\"sub:0\");\n\t    await expect(spy).toSeeEVENT();\n\t    relay.emitEOSE(\"sub:0\");\n\t    await expect(relay).toReceiveCLOSE(\"sub:0\");\n\t  });\n\t  test(\"[backward] If connection is abnormally closed after receiving EOSE, REQ will not be retried.\", async () => {\n\t    const req = createRxBackwardReq(\"sub\");\n", "    rxNostr.use(req).subscribe();\n\t    req.emit(faker.filters());\n\t    await expect(relay).toReceiveREQ(\"sub:0\");\n\t    relay.emitEOSE(\"sub:0\");\n\t    await expect(relay).toReceiveCLOSE(\"sub:0\");\n\t    // Emulate an abnormal disconnection of a relay.\n\t    const socket = await relay.getSocket(0);\n\t    socket.close({\n\t      code: WebSocketCloseCode.ABNORMAL_CLOSURE,\n\t      reason: \"Relay's internal error\",\n", "      wasClean: true,\n\t    });\n\t    rxNostr.send(faker.event());\n\t    await expect(relay).toReceiveEVENT();\n\t  });\n\t  test(\"[oneshot] Receipt of EOSE terminates the Observable.\", async () => {\n\t    const req = createRxOneshotReq({\n\t      subId: \"sub\",\n\t      filters: faker.filter(),\n\t    });\n", "    const spy = spySub();\n\t    rxNostr.use(req).pipe(spy.tap()).subscribe();\n\t    await expect(relay).toReceiveREQ(\"sub:0\");\n\t    assert(!spy.completed());\n\t    relay.emitEOSE(\"sub:0\");\n\t    assert(spy.completed());\n\t  });\n\t});\n\tdescribe(\"Basic subscription behavior (multiple relays)\", () => {\n\t  const RELAY_URL1 = \"ws://localhost:1234\";\n", "  const RELAY_URL2 = \"ws://localhost:1235\";\n\t  const RELAY_URL3 = \"ws://localhost:1236\";\n\t  let rxNostr: RxNostr;\n\t  let relay1: MockRelay;\n\t  let relay2: MockRelay;\n\t  let relay3: MockRelay;\n\t  beforeEach(async () => {\n\t    relay1 = createMockRelay(RELAY_URL1);\n\t    relay2 = createMockRelay(RELAY_URL2);\n\t    relay3 = createMockRelay(RELAY_URL3);\n", "    rxNostr = createRxNostr({\n\t      globalRelayConfig: {\n\t        disableAutoFetchNip11Limitations: true,\n\t      },\n\t    });\n\t    await rxNostr.switchRelays([RELAY_URL1, RELAY_URL2]);\n\t    await relay1.connected;\n\t    await relay2.connected;\n\t  });\n\t  afterEach(() => {\n", "    rxNostr.dispose();\n\t    relay1.close({\n\t      code: WebSocketCloseCode.DISPOSED_BY_RX_NOSTR,\n\t      reason: \"Clean up on afterEach()\",\n\t      wasClean: true,\n\t    });\n\t    relay2.close({\n\t      code: WebSocketCloseCode.DISPOSED_BY_RX_NOSTR,\n\t      reason: \"Clean up on afterEach()\",\n\t      wasClean: true,\n", "    });\n\t    relay3.close({\n\t      code: WebSocketCloseCode.DISPOSED_BY_RX_NOSTR,\n\t      reason: \"Clean up on afterEach()\",\n\t      wasClean: true,\n\t    });\n\t  });\n\t  test(\"[forward] Adding new relay affects existing REQ.\", async () => {\n\t    const req = createRxForwardReq(\"sub\");\n\t    rxNostr.use(req).subscribe();\n", "    req.emit(faker.filters());\n\t    await expect(relay1).toReceiveREQ(\"sub:0\");\n\t    await expect(relay2).toReceiveREQ(\"sub:0\");\n\t    await rxNostr.addRelay(RELAY_URL3);\n\t    await expect(relay3).toReceiveREQ(\"sub:0\");\n\t  });\n\t  test(\"[forward] Removing a relay affects existing REQ.\", async () => {\n\t    const req = createRxForwardReq(\"sub\");\n\t    rxNostr.use(req).subscribe();\n\t    req.emit(faker.filters());\n", "    await expect(relay1).toReceiveREQ(\"sub:0\");\n\t    await expect(relay2).toReceiveREQ(\"sub:0\");\n\t    await rxNostr.removeRelay(RELAY_URL2);\n\t    await expect(relay2).toReceiveCLOSE(\"sub:0\");\n\t  });\n\t  test(\"[forward] Adding new relay doesn't affect existing subset-REQ when the relay is not in subset.\", async () => {\n\t    const req = createRxForwardReq(\"sub\");\n\t    rxNostr.use(req, { scope: [RELAY_URL1] }).subscribe();\n\t    req.emit(faker.filters());\n\t    await expect(relay1).toReceiveREQ(\"sub:0\");\n", "    await rxNostr.addRelay(RELAY_URL3);\n\t    rxNostr.send(faker.event());\n\t    await expect(relay1).toReceiveEVENT();\n\t    await expect(relay2).toReceiveEVENT();\n\t    await expect(relay3).toReceiveEVENT();\n\t    expect(relay2.messagesToConsume.pendingItems.length).toBe(0);\n\t    expect(relay3.messagesToConsume.pendingItems.length).toBe(0);\n\t  });\n\t  test(\"[forward] Adding new relay affects existing subset-REQ when the relay is in subset.\", async () => {\n\t    const req = createRxForwardReq(\"sub\");\n", "    rxNostr.use(req, { scope: [RELAY_URL1, RELAY_URL3] }).subscribe();\n\t    req.emit(faker.filters());\n\t    await expect(relay1).toReceiveREQ(\"sub:0\");\n\t    await rxNostr.addRelay(RELAY_URL3);\n\t    await expect(relay3).toReceiveREQ(\"sub:0\");\n\t    expect(relay2.messagesToConsume.pendingItems.length).toBe(0);\n\t  });\n\t  test(\"[backward] EOSE on all subset relays triggers CLOSE.\", async () => {\n\t    const req = createRxBackwardReq(\"sub\");\n\t    rxNostr.use(req, { scope: [RELAY_URL1] }).subscribe();\n", "    req.emit(faker.filters());\n\t    await expect(relay1).toReceiveREQ(\"sub:0\");\n\t    relay1.emitEOSE(\"sub:0\");\n\t    await expect(relay1).toReceiveCLOSE(\"sub:0\");\n\t    expect(relay2.messagesToConsume.pendingItems.length).toBe(0);\n\t    expect(relay3.messagesToConsume.pendingItems.length).toBe(0);\n\t  });\n\t  test(\"[backward] EOSE on all subset and active relays triggers CLOSE.\", async () => {\n\t    const req = createRxBackwardReq(\"sub\");\n\t    rxNostr.use(req, { scope: [RELAY_URL1, RELAY_URL3] }).subscribe();\n", "    req.emit(faker.filters());\n\t    await expect(relay1).toReceiveREQ(\"sub:0\");\n\t    relay1.emitEOSE(\"sub:0\");\n\t    await expect(relay1).toReceiveCLOSE(\"sub:0\");\n\t    expect(relay2.messagesToConsume.pendingItems.length).toBe(0);\n\t  });\n\t  test(\"[oneshot] EOSE on all subset and active relays triggers completion.\", async () => {\n\t    const req = createRxOneshotReq({\n\t      subId: \"sub\",\n\t      filters: faker.filters(),\n", "    });\n\t    const spy = spySub();\n\t    rxNostr\n\t      .use(req, { scope: [RELAY_URL1, RELAY_URL3] })\n\t      .pipe(spy.tap())\n\t      .subscribe();\n\t    await expect(relay1).toReceiveREQ(\"sub:0\");\n\t    relay1.emitEOSE(\"sub:0\");\n\t    await expect(relay1).toReceiveCLOSE(\"sub:0\");\n\t    assert(spy.completed());\n", "  });\n\t  test(\"[oneshot] Collect all events under different timing EOSE.\", async () => {\n\t    const req = createRxOneshotReq({\n\t      subId: \"sub\",\n\t      filters: faker.filters(),\n\t    });\n\t    const spy = spyEvent();\n\t    rxNostr.use(req).pipe(spy.tap()).subscribe();\n\t    await expect(relay1).toReceiveREQ(\"sub:0\");\n\t    await expect(relay2).toReceiveREQ(\"sub:0\");\n", "    relay1.emitEVENT(\"sub:0\");\n\t    await expect(spy).toSeeEVENT(\"sub:0\");\n\t    relay2.emitEVENT(\"sub:0\");\n\t    await expect(spy).toSeeEVENT(\"sub:0\");\n\t    relay1.emitEOSE(\"sub:0\");\n\t    await expect(relay1).toReceiveCLOSE(\"sub:0\");\n\t    relay2.emitEVENT(\"sub:0\");\n\t    await expect(spy).toSeeEVENT(\"sub:0\");\n\t    relay2.emitEOSE(\"sub:0\");\n\t    await expect(relay2).toReceiveCLOSE(\"sub:0\");\n", "  });\n\t});\n\tdescribe(\"Under limited REQ concurency (single relay)\", () => {\n\t  const RELAY_URL = \"ws://localhost:1234\";\n\t  let rxNostr: RxNostr;\n\t  let relay: MockRelay;\n\t  beforeEach(async () => {\n\t    relay = createMockRelay(RELAY_URL);\n\t    rxNostr = createRxNostr({\n\t      retry: { strategy: \"immediately\", maxCount: 1 },\n", "      globalRelayConfig: {\n\t        disableAutoFetchNip11Limitations: true,\n\t        maxConcurrentReqsFallback: 1,\n\t      },\n\t    });\n\t    await rxNostr.switchRelays([RELAY_URL]);\n\t    await relay.connected;\n\t  });\n\t  afterEach(() => {\n\t    rxNostr.dispose();\n", "    relay.close({\n\t      code: WebSocketCloseCode.DISPOSED_BY_RX_NOSTR,\n\t      reason: \"Clean up on afterEach()\",\n\t      wasClean: true,\n\t    });\n\t  });\n\t  test(\"[backward] Overflowed REQs will be enqueued.\", async () => {\n\t    const req = createRxBackwardReq(\"sub\");\n\t    rxNostr.use(req).pipe().subscribe();\n\t    req.emit(faker.filters());\n", "    req.emit(faker.filters());\n\t    req.emit(faker.filters());\n\t    await expect(relay).toReceiveREQ(\"sub:0\");\n\t    relay.emitEOSE(\"sub:0\");\n\t    await expect(relay).toReceiveCLOSE(\"sub:0\");\n\t    await expect(relay).toReceiveREQ(\"sub:1\");\n\t    relay.emitEOSE(\"sub:1\");\n\t    await expect(relay).toReceiveCLOSE(\"sub:1\");\n\t    await expect(relay).toReceiveREQ(\"sub:2\");\n\t    relay.emitEOSE(\"sub:2\");\n", "    await expect(relay).toReceiveCLOSE(\"sub:2\");\n\t  });\n\t});\n"]}
{"filename": "src/__test__/extend.test.ts", "chunked_list": ["import { expect, test } from \"vitest\";\n\timport { createRxBackwardReq, extend, mixin } from \"../index.js\";\n\ttest(\"Extend req.\", async () => {\n\t  const addFoo = mixin<{ strategy: \"backward\" }, { foo: () => string }>(() => ({\n\t    foo() {\n\t      return this.strategy;\n\t    },\n\t  }));\n\t  const req = extend(createRxBackwardReq(), addFoo);\n\t  expect(req.strategy).toBe(\"backward\");\n", "  expect(req.foo()).toBe(\"backward\");\n\t});\n\ttest(\"Override req.\", async () => {\n\t  const original = extend(\n\t    createRxBackwardReq(),\n\t    mixin<object, { foo: () => string }>(() => ({\n\t      foo() {\n\t        return \"foo\";\n\t      },\n\t    }))\n", "  );\n\t  const override = mixin<{ foo: () => string }, { foo: () => number }>(() => ({\n\t    foo() {\n\t      return 100;\n\t    },\n\t  }));\n\t  const req = extend(original, override);\n\t  expect(req.foo()).toBe(100);\n\t});\n"]}
{"filename": "src/__test__/helper.ts", "chunked_list": ["import Nostr from \"nostr-typedef\";\n\timport { type MonoTypeOperatorFunction, tap } from \"rxjs\";\n\timport { TestScheduler } from \"rxjs/testing\";\n\timport { expect } from \"vitest\";\n\timport { createClientSpy, faker as _faker } from \"vitest-nostr\";\n\timport { EventPacket, MessagePacket } from \"../packet.js\";\n\texport function testScheduler() {\n\t  return new TestScheduler((a, b) => expect(a).toEqual(b));\n\t}\n\texport const faker = {\n", "  ..._faker,\n\t  eventPacket(\n\t    packetOrEvent?: Partial<\n\t      EventPacket[\"event\"] &\n\t        Omit<EventPacket, \"event\"> & {\n\t          event?: Partial<EventPacket[\"event\"]>;\n\t        }\n\t    >\n\t  ): EventPacket {\n\t    return {\n", "      from: packetOrEvent?.from ?? \"*\",\n\t      subId: packetOrEvent?.subId ?? \"*\",\n\t      event: faker.event(packetOrEvent?.event ?? packetOrEvent),\n\t    };\n\t  },\n\t  messagePacket(message: Nostr.ToClientMessage.Any): MessagePacket {\n\t    return {\n\t      from: \"*\",\n\t      message,\n\t    };\n", "  },\n\t};\n\texport function spySub(): {\n\t  completed: () => boolean;\n\t  error: () => boolean;\n\t  count: () => number;\n\t  subscribed: () => boolean;\n\t  unsubscribed: () => boolean;\n\t  tap: <T>() => MonoTypeOperatorFunction<T>;\n\t} {\n", "  let completed = false;\n\t  let error = false;\n\t  let count = 0;\n\t  let subscribed = false;\n\t  let unsubscribed = false;\n\t  return {\n\t    completed: () => completed,\n\t    error: () => error,\n\t    count: () => count,\n\t    subscribed: () => subscribed,\n", "    unsubscribed: () => unsubscribed,\n\t    tap: () =>\n\t      tap({\n\t        complete: () => void (completed = true),\n\t        error: () => void (error = true),\n\t        next: () => void count++,\n\t        subscribe: () => void (subscribed = true),\n\t        unsubscribe: () => void (unsubscribed = true),\n\t      }),\n\t  };\n", "}\n\texport function spyMessage(): {\n\t  tap: () => MonoTypeOperatorFunction<MessagePacket>;\n\t} {\n\t  let tapNext: (message: Nostr.ToClientMessage.Any) => void;\n\t  const spy = createClientSpy((listener) => {\n\t    tapNext = listener;\n\t  });\n\t  return {\n\t    tap: () =>\n", "      tap((packet) => {\n\t        tapNext(packet.message);\n\t      }),\n\t    ...spy,\n\t  };\n\t}\n\texport function spyEvent(): {\n\t  tap: () => MonoTypeOperatorFunction<EventPacket>;\n\t} {\n\t  let tapNext: (message: Nostr.ToClientMessage.Any) => void;\n", "  const spy = createClientSpy((listener) => {\n\t    tapNext = listener;\n\t  });\n\t  return {\n\t    tap: () =>\n\t      tap((packet) => {\n\t        tapNext([\"EVENT\", packet.subId, packet.event]);\n\t      }),\n\t    ...spy,\n\t  };\n", "}\n"]}
{"filename": "src/__test__/sending.test.ts", "chunked_list": ["import { afterEach, beforeEach, describe, expect, test } from \"vitest\";\n\timport { createMockRelay, type MockRelay } from \"vitest-nostr\";\n\timport { WebSocketCloseCode } from \"../connection.js\";\n\timport { createRxNostr, RxNostr } from \"../index.js\";\n\timport { faker, spySub } from \"./helper.js\";\n\tdescribe(\"Basic sending behavior\", () => {\n\t  const RELAY_URL1 = \"ws://localhost:1234\";\n\t  const RELAY_URL2 = \"ws://localhost:1235\";\n\t  const RELAY_URL3 = \"ws://localhost:1236\";\n\t  let rxNostr: RxNostr;\n", "  let relay1: MockRelay;\n\t  let relay2: MockRelay;\n\t  let relay3: MockRelay;\n\t  beforeEach(async () => {\n\t    relay1 = createMockRelay(RELAY_URL1);\n\t    relay2 = createMockRelay(RELAY_URL2);\n\t    relay3 = createMockRelay(RELAY_URL3);\n\t    rxNostr = createRxNostr();\n\t    await rxNostr.switchRelays([\n\t      { url: RELAY_URL1, write: true, read: false },\n", "      { url: RELAY_URL2, write: false, read: true },\n\t    ]);\n\t    await relay1.connected;\n\t    await relay2.connected;\n\t  });\n\t  afterEach(() => {\n\t    rxNostr.dispose();\n\t    relay1.close({\n\t      code: WebSocketCloseCode.DISPOSED_BY_RX_NOSTR,\n\t      reason: \"Clean up on afterEach()\",\n", "      wasClean: true,\n\t    });\n\t    relay2.close({\n\t      code: WebSocketCloseCode.DISPOSED_BY_RX_NOSTR,\n\t      reason: \"Clean up on afterEach()\",\n\t      wasClean: true,\n\t    });\n\t    relay3.close({\n\t      code: WebSocketCloseCode.DISPOSED_BY_RX_NOSTR,\n\t      reason: \"Clean up on afterEach()\",\n", "      wasClean: true,\n\t    });\n\t  });\n\t  test(\"send() sends only to writable relays.\", async () => {\n\t    rxNostr.send(faker.event());\n\t    await expect(relay1).toReceiveEVENT();\n\t    expect(relay2.messagesToConsume.pendingItems.length).toBe(0);\n\t  });\n\t  test(\"send() doesn't wait for OK from relays added later.\", async () => {\n\t    const spy = spySub();\n", "    rxNostr.send(faker.event()).pipe(spy.tap()).subscribe();\n\t    rxNostr.addRelay(RELAY_URL3);\n\t    await expect(relay1).toReceiveEVENT();\n\t    expect(relay2.messagesToConsume.pendingItems.length).toBe(0);\n\t    expect(relay3.messagesToConsume.pendingItems.length).toBe(0);\n\t    relay1.emitOK(\"*\", true);\n\t    expect(spy.completed()).toBe(true);\n\t  });\n\t  test(\"send() doesn't wait for OK from out of scope.\", async () => {\n\t    const spy = spySub();\n", "    await rxNostr.switchRelays([RELAY_URL1, RELAY_URL2]);\n\t    rxNostr\n\t      .send(faker.event(), { scope: [RELAY_URL2] })\n\t      .pipe(spy.tap())\n\t      .subscribe();\n\t    await expect(relay2).toReceiveEVENT();\n\t    expect(relay1.messagesToConsume.pendingItems.length).toBe(0);\n\t    relay2.emitOK(\"*\", true);\n\t    expect(spy.completed()).toBe(true);\n\t  });\n", "});\n"]}
{"filename": "src/nostr/filter.ts", "chunked_list": ["import * as Nostr from \"nostr-typedef\";\n\timport { defineDefaultOptions } from \"../util.js\";\n\texport interface MatchFilterOptions {\n\t  sinceInclusive: boolean;\n\t  untilInclusive: boolean;\n\t}\n\tconst makeMatchFilterOptions = defineDefaultOptions<MatchFilterOptions>({\n\t  sinceInclusive: true,\n\t  untilInclusive: true,\n\t});\n", "/**\n\t * Return true if the given filter matches the given filters.\n\t */\n\texport function isFiltered(\n\t  event: Nostr.Event,\n\t  filters: Nostr.Filter | Nostr.Filter[],\n\t  options?: Partial<MatchFilterOptions>\n\t): boolean {\n\t  if (Array.isArray(filters)) {\n\t    return filters.some((filter) => _isFiltered(event, filter, options));\n", "  } else {\n\t    return _isFiltered(event, filters, options);\n\t  }\n\t}\n\tfunction _isFiltered(\n\t  event: Nostr.Event,\n\t  filter: Nostr.Filter,\n\t  options?: Partial<MatchFilterOptions>\n\t): boolean {\n\t  const { sinceInclusive, untilInclusive } = makeMatchFilterOptions(options);\n", "  if (\n\t    filter.ids &&\n\t    filter.ids.every((prefix) => !event.id.startsWith(prefix))\n\t  ) {\n\t    return false;\n\t  }\n\t  if (filter.kinds && !filter.kinds.includes(event.kind)) {\n\t    return false;\n\t  }\n\t  if (\n", "    filter.authors &&\n\t    filter.authors.every((prefix) => !event.pubkey.startsWith(prefix))\n\t  ) {\n\t    return false;\n\t  }\n\t  if (\n\t    filter.since &&\n\t    ((sinceInclusive && !(filter.since <= event.created_at)) ||\n\t      (!sinceInclusive && !(filter.since < event.created_at)))\n\t  ) {\n", "    return false;\n\t  }\n\t  if (\n\t    filter.until &&\n\t    ((untilInclusive && !(event.created_at <= filter.until)) ||\n\t      (!untilInclusive && !(event.created_at < filter.until)))\n\t  ) {\n\t    return false;\n\t  }\n\t  for (const [key, needleValues] of Object.entries(filter)) {\n", "    if (!key.startsWith(\"#\") || !Array.isArray(needleValues)) {\n\t      continue;\n\t    }\n\t    const needleTagName = key.slice(1);\n\t    if (\n\t      !event.tags.find(\n\t        ([tagName, tagValue]) =>\n\t          needleTagName === tagName &&\n\t          (needleValues as string[]).includes(tagValue)\n\t      )\n", "    ) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t}\n"]}
{"filename": "src/nostr/nip11.ts", "chunked_list": ["import * as Nostr from \"nostr-typedef\";\n\t/**\n\t * Fetch relay's information based on [NIP-11](https://github.com/nostr-protocol/nips/blob/master/11.md).\n\t */\n\texport async function fetchRelayInfo(\n\t  url: string\n\t): Promise<Nostr.Nip11.RelayInfo> {\n\t  const u = new URL(url);\n\t  u.protocol = u.protocol.replace(/^ws(s?):/, \"http$1:\");\n\t  const res = await fetch(u.toString(), {\n", "    headers: { Accept: \"application/nostr+json\" },\n\t  });\n\t  return res.json();\n\t}\n"]}
{"filename": "src/nostr/bech32.ts", "chunked_list": ["import { bytesToHex } from \"@noble/hashes/utils\";\n\timport { bech32 } from \"@scure/base\";\n\t/** Convert bech32 format string to HEX format string. */\n\texport function toHex(str: string): string {\n\t  const { words } = bech32.decode(str);\n\t  const data = new Uint8Array(bech32.fromWords(words));\n\t  return bytesToHex(data);\n\t}\n"]}
{"filename": "src/nostr/nip07.ts", "chunked_list": ["import Nostr from \"nostr-typedef\";\n\tdeclare global {\n\t  interface Window {\n\t    nostr?: Nostr.Nip07.Nostr;\n\t  }\n\t}\n"]}
{"filename": "src/nostr/event.ts", "chunked_list": ["import { schnorr } from \"@noble/curves/secp256k1\";\n\timport { sha256 } from \"@noble/hashes/sha256\";\n\timport { bytesToHex } from \"@noble/hashes/utils\";\n\timport Nostr from \"nostr-typedef\";\n\timport { toHex } from \"./bech32.js\";\n\tconst utf8Encoder = new TextEncoder();\n\t/**\n\t * Return a signed event that is ready for sending.\n\t */\n\texport async function getSignedEvent(\n", "  params: Nostr.EventParameters,\n\t  /** Private key in bech32 format of HEX format. If omitted, attempt to use NIP-07 interface. */\n\t  seckey?: string\n\t): Promise<Nostr.Event> {\n\t  const event = {\n\t    ...params,\n\t    pubkey: params.pubkey ?? (await getPubkey()),\n\t    tags: params.tags ?? [],\n\t    created_at: params.created_at ?? Math.floor(new Date().getTime() / 1000),\n\t  };\n", "  if (ensureRequiredFields(params)) {\n\t    return params;\n\t  } else if (seckey) {\n\t    const id = event.id ?? getEventHash(event);\n\t    const sechex = seckey.startsWith(\"nsec1\") ? toHex(seckey) : seckey;\n\t    return {\n\t      ...event,\n\t      id,\n\t      sig: event.sig ?? getSignature(id, sechex),\n\t    };\n", "  } else {\n\t    const nostr = (window ?? {})?.nostr;\n\t    if (!nostr) {\n\t      throw new Error(\n\t        \"Couldn't get sig. To automatically calculate signature, a seckey argument or NIP-07 environment is required.\"\n\t      );\n\t    }\n\t    return nostr.signEvent({\n\t      kind: event.kind,\n\t      tags: event.tags,\n", "      content: event.content,\n\t      created_at: event.created_at,\n\t    });\n\t  }\n\t  async function getPubkey() {\n\t    if (params.pubkey) {\n\t      if (params.pubkey.startsWith(\"npub1\")) {\n\t        return toHex(params.pubkey);\n\t      } else {\n\t        return params.pubkey;\n", "      }\n\t    } else {\n\t      if (seckey) {\n\t        if (seckey.startsWith(\"nsec1\")) {\n\t          return getPublicKey(toHex(seckey));\n\t        } else {\n\t          return getPublicKey(seckey);\n\t        }\n\t      } else {\n\t        const pubkey = await window?.nostr?.getPublicKey();\n", "        if (!pubkey) {\n\t          throw new Error(\n\t            \"Couldn't get pubkey. To automatically calculate pubkey, a seckey argument or NIP-07 environment is required.\"\n\t          );\n\t        }\n\t        return pubkey;\n\t      }\n\t    }\n\t  }\n\t}\n", "/** Calculate and return public key in HEX format. */\n\texport function getPublicKey(seckey: string): string {\n\t  return bytesToHex(schnorr.getPublicKey(seckey));\n\t}\n\t/** Calculate and return event's hash (ID). */\n\texport function getEventHash(event: Nostr.UnsignedEvent): string {\n\t  const serialized = JSON.stringify([\n\t    0,\n\t    event.pubkey,\n\t    event.created_at,\n", "    event.kind,\n\t    event.tags,\n\t    event.content,\n\t  ]);\n\t  return bytesToHex(sha256(utf8Encoder.encode(serialized)));\n\t}\n\t/** Calculate and return schnorr signature. */\n\texport function getSignature(eventHash: string, seckey: string): string {\n\t  return bytesToHex(schnorr.sign(eventHash, seckey));\n\t}\n", "/** Verify the given event and return true if it is valid. */\n\texport function verify(event: Nostr.Event): boolean {\n\t  try {\n\t    return schnorr.verify(event.sig, getEventHash(event), event.pubkey);\n\t  } catch (err) {\n\t    console.warn(\"The following error occurred during verify():\", err);\n\t    return false;\n\t  }\n\t}\n\tfunction ensureRequiredFields(\n", "  event: Partial<Nostr.Event>\n\t): event is Nostr.Event {\n\t  if (typeof event.id !== \"string\") return false;\n\t  if (typeof event.sig !== \"string\") return false;\n\t  if (typeof event.kind !== \"number\") return false;\n\t  if (typeof event.pubkey !== \"string\") return false;\n\t  if (typeof event.content !== \"string\") return false;\n\t  if (typeof event.created_at !== \"number\") return false;\n\t  if (!Array.isArray(event.tags)) return false;\n\t  for (let i = 0; i < event.tags.length; i++) {\n", "    const tag = event.tags[i];\n\t    if (!Array.isArray(tag)) return false;\n\t    for (let j = 0; j < tag.length; j++) {\n\t      if (typeof tag[j] === \"object\") return false;\n\t    }\n\t  }\n\t  return true;\n\t}\n\t/** Return an event that has earlier `created_at`. */\n\texport function earlierEvent(a: Nostr.Event, b: Nostr.Event): Nostr.Event {\n", "  return compareEvents(a, b) < 0 ? a : b;\n\t}\n\t/** Return an event that has later `created_at`. */\n\texport function laterEvent(a: Nostr.Event, b: Nostr.Event): Nostr.Event {\n\t  return compareEvents(a, b) < 0 ? b : a;\n\t}\n\t/** Sort key function to sort events based on `created_at`. */\n\texport function compareEvents(a: Nostr.Event, b: Nostr.Event): number {\n\t  if (a.id === b.id) {\n\t    return 0;\n", "  }\n\t  return a.created_at < b.created_at ||\n\t    // https://github.com/nostr-protocol/nips/blob/master/16.md#replaceable-events\n\t    (a.created_at === b.created_at && a.id < b.id)\n\t    ? -1\n\t    : 1;\n\t}\n"]}
