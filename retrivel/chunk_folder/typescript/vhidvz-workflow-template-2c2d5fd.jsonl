{"filename": "test/app.e2e-spec.ts", "chunked_list": ["import { Test, TestingModule } from '@nestjs/testing';\n\timport { INestApplication } from '@nestjs/common';\n\timport * as request from 'supertest';\n\timport { AppModule } from './../src/app.module';\n\tdescribe('AppController (e2e)', () => {\n\t  let app: INestApplication;\n\t  beforeEach(async () => {\n\t    const moduleFixture: TestingModule = await Test.createTestingModule({\n\t      imports: [AppModule],\n\t    }).compile();\n", "    app = moduleFixture.createNestApplication();\n\t    await app.init();\n\t  });\n\t  it('/ (GET)', () => {\n\t    return request(app.getHttpServer())\n\t      .get('/')\n\t      .expect(200)\n\t      .expect('Hello World!');\n\t  });\n\t});\n"]}
{"filename": "src/main.ts", "chunked_list": ["import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';\n\timport { ValidationPipe } from '@nestjs/common';\n\timport { NestFactory } from '@nestjs/core';\n\timport { AppModule } from './app.module';\n\tasync function bootstrap() {\n\t  const app = await NestFactory.create(AppModule);\n\t  app.useGlobalPipes(new ValidationPipe());\n\t  const config = new DocumentBuilder()\n\t    .setTitle(process.env.npm_package_name)\n\t    .setVersion(process.env.npm_package_version)\n", "    .setDescription(process.env.npm_package_description)\n\t    .build();\n\t  const document = SwaggerModule.createDocument(app, config);\n\t  SwaggerModule.setup('api', app, document);\n\t  await app.listen(3000);\n\t  console.log(`Swagger UI is running on: ${await app.getUrl()}/api`);\n\t}\n\tbootstrap();\n"]}
{"filename": "src/app.workflow.ts", "chunked_list": ["import { Act, Data, Node, Process, Value } from '@vhidvz/wfjs/common';\n\timport {\n\t  EventActivity,\n\t  GatewayActivity,\n\t  TaskActivity,\n\t} from '@vhidvz/wfjs/core';\n\timport { Data as DataFlow, Value as ValueFlow } from './schemas';\n\timport { AppProvider } from './app.provider';\n\timport { Injectable } from '@nestjs/common';\n\timport { WorkflowJS } from '@vhidvz/wfjs';\n", "import { join } from 'path';\n\t@Injectable()\n\t@Process({ name: 'Simple Workflow', path: join(__dirname, 'app.flow.bpmn') })\n\texport class AppWorkflow extends WorkflowJS {\n\t  constructor(private readonly appProvider: AppProvider) {\n\t    super();\n\t  }\n\t  @Node({ name: 'start' })\n\t  async start(@Act() activity: EventActivity) {\n\t    activity.takeOutgoing();\n", "  }\n\t  @Node({ name: 'approval_gateway', pause: true })\n\t  async approvalGateway(\n\t    @Data() data: DataFlow,\n\t    @Value() value: ValueFlow,\n\t    @Act() activity: GatewayActivity,\n\t  ) {\n\t    data.global = `${data.global}, ${await this.appProvider.getHello(\n\t      value.local,\n\t    )}`;\n", "    if (value.local !== 'no')\n\t      activity.takeOutgoing({ name: 'parallel_gateway' });\n\t    else activity.takeOutgoing({ name: 'some_task' }, { pause: true });\n\t  }\n\t  @Node({ name: 'some_task' })\n\t  async someTask(@Value() value: ValueFlow, @Act() activity: TaskActivity) {\n\t    activity.takeOutgoing();\n\t    return { local: `some value(${value.local}) to end event.` };\n\t  }\n\t  @Node({ name: 'parallel_gateway' })\n", "  async parallelGateway(@Act() activity: GatewayActivity) {\n\t    activity.takeOutgoing(null, { pause: 'another_task' });\n\t  }\n\t  @Node({ name: 'another_task' })\n\t  async anotherTask(@Act() activity: TaskActivity) {\n\t    activity.takeOutgoing();\n\t  }\n\t  @Node({ name: 'review', pause: true })\n\t  async review(@Value() value: ValueFlow, @Act() activity: TaskActivity) {\n\t    activity.takeOutgoing();\n", "    return { local: `${value.local} to end event.` };\n\t  }\n\t  @Node({ name: 'end' })\n\t  async end(@Data() data: DataFlow, @Value() value: ValueFlow) {\n\t    data.global = `${data.global}, received a value from previous task(${value.local})`;\n\t  }\n\t}\n"]}
{"filename": "src/app.service.ts", "chunked_list": ["import { HttpException, HttpStatus, Injectable } from '@nestjs/common';\n\timport { AppRepository } from './app.repository';\n\timport { AppWorkflow } from './app.workflow';\n\timport { Data, Value } from './schemas';\n\timport { Context } from '@vhidvz/wfjs';\n\t@Injectable()\n\texport class AppService {\n\t  constructor(\n\t    private readonly appWorkflow: AppWorkflow,\n\t    private readonly appRepository: AppRepository,\n", "  ) {}\n\t  /**\n\t   * This is an asynchronous function that returns the result of finding an item with a specific ID in\n\t   * the app repository.\n\t   *\n\t   * @param {string} id - The `id` parameter is a string that represents the unique identifier of an\n\t   * entity that we want to find in the database. The `find` method is used to retrieve an entity from\n\t   * the database based on its `id`. The `async` keyword indicates that the method returns a promise\n\t   * that resolves to\n\t   *\n", "   * @returns The `find` method is being called on the `appRepository` object with the `id` parameter,\n\t   * and the result of that method call is being returned. The `await` keyword is used to wait for the\n\t   * `find` method to complete before returning its result. The specific data type of the returned\n\t   * value is not specified in the code snippet.\n\t   */\n\t  async find(id: string) {\n\t    return await this.appRepository.find(id);\n\t  }\n\t  /**\n\t   * This function creates a new item in the app repository using data passed in and the context\n", "   * returned from executing the app workflow.\n\t   *\n\t   * @param {string} data - The `data` parameter is a string that is passed as an argument to the\n\t   * `create` method. It is then used as input to the `execute` method of the `appWorkflow` object. The\n\t   * `context` object returned from the `execute` method is then used as input to the\n\t   *\n\t   * @returns The `create` method is returning the result of calling the `create` method of the\n\t   * `appRepository` with the `context` object obtained from executing the `appWorkflow` with the\n\t   * provided `data` parameter.\n\t   */\n", "  async create(data: Data) {\n\t    // if you have only one start point this is OK\n\t    const { context } = await this.appWorkflow.execute({ data });\n\t    return this.appRepository.create(context.serialize());\n\t  }\n\t  /**\n\t   * This is an async function that updates an app's context based on a given activity and value.\n\t   *\n\t   * @param {string} id - The ID of the app that needs to be updated.\n\t   * @param {string} activity - The `activity` parameter is a string that represents the name of the\n", "   * activity that needs to be executed in the workflow.\n\t   * @param {string} value - The value parameter is a string that represents the input value to be\n\t   * passed to the appWorkflow.execute() method. It is used to update the context of the app with the\n\t   * result of the workflow execution.\n\t   *\n\t   * @returns The `update` method is returning the updated context after executing the specified\n\t   * activity on the given id.\n\t   */\n\t  async update(id: string, activity: string, value: Value) {\n\t    try {\n", "      const ctx = await this.appRepository.find(id);\n\t      if (!ctx)\n\t        throw new HttpException(\n\t          'flow with given id dose not exist',\n\t          HttpStatus.BAD_REQUEST,\n\t        );\n\t      const { context } = await this.appWorkflow.execute({\n\t        value,\n\t        node: { name: activity },\n\t        context: Context.deserialize(ctx.toJSON()),\n", "      });\n\t      return this.appRepository.update(id, context.serialize());\n\t    } catch (error) {\n\t      throw new HttpException(error.message, HttpStatus.BAD_REQUEST);\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/app.module.ts", "chunked_list": ["import { MongooseModule } from '@nestjs/mongoose';\n\timport { AppController } from './app.controller';\n\timport { AppRepository } from './app.repository';\n\timport { AppWorkflow } from './app.workflow';\n\timport { AppProvider } from './app.provider';\n\timport { App, AppSchema } from './schemas';\n\timport { AppService } from './app.service';\n\timport { Module } from '@nestjs/common';\n\t@Module({\n\t  imports: [\n", "    MongooseModule.forRoot('mongodb://localhost/nest'),\n\t    MongooseModule.forFeature([{ name: App.name, schema: AppSchema }]),\n\t  ],\n\t  controllers: [AppController],\n\t  providers: [AppService, AppWorkflow, AppRepository, AppProvider],\n\t})\n\texport class AppModule {}\n"]}
{"filename": "src/app.provider.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\n\t@Injectable()\n\texport class AppProvider {\n\t  async getHello(value: string): Promise<string> {\n\t    return `Hello ${value}!`;\n\t  }\n\t}\n"]}
{"filename": "src/app.constants.ts", "chunked_list": ["export const ACTIVITY_LIST = [\n\t  'another_task',\n\t  'approval_gateway',\n\t  'parallel_gateway',\n\t  'review',\n\t  'some_task',\n\t];\n"]}
{"filename": "src/app.repository.ts", "chunked_list": ["import { ContextInterface } from '@vhidvz/wfjs';\n\timport { InjectModel } from '@nestjs/mongoose';\n\timport { Injectable } from '@nestjs/common';\n\timport { Model } from 'mongoose';\n\timport { App } from './schemas';\n\t@Injectable()\n\texport class AppRepository {\n\t  constructor(@InjectModel(App.name) private appModel: Model<App>) {}\n\t  async find(id: string) {\n\t    return this.appModel.findById(id);\n", "  }\n\t  async create(context: ContextInterface) {\n\t    return this.appModel.create(context);\n\t  }\n\t  async update(id: string, context: ContextInterface) {\n\t    return this.appModel.findByIdAndUpdate(id, context, { new: true });\n\t  }\n\t}\n"]}
{"filename": "src/app.controller.ts", "chunked_list": ["import { Body, Controller, Get, Param, Patch, Post } from '@nestjs/common';\n\timport { AppService } from './app.service';\n\timport { DataDto, ValueDto } from './dto';\n\timport { ActivityPipe } from './pipes';\n\timport { App } from './schemas';\n\timport { ApiTags } from '@nestjs/swagger';\n\t@ApiTags('workflows')\n\t@Controller('flow')\n\texport class AppController {\n\t  constructor(private readonly appService: AppService) {}\n", "  @Get(':id')\n\t  async find(@Param('id') id: string): Promise<App> {\n\t    return this.appService.find(id);\n\t  }\n\t  @Post()\n\t  async create(@Body() data: DataDto): Promise<App> {\n\t    return this.appService.create(data);\n\t  }\n\t  @Patch(':id/:activity')\n\t  async update(\n", "    @Body() value: ValueDto,\n\t    @Param('id') id: string,\n\t    @Param('activity', ActivityPipe) activity: string,\n\t  ): Promise<App> {\n\t    return this.appService.update(id, activity, value);\n\t  }\n\t}\n"]}
{"filename": "src/schemas/token.schema.ts", "chunked_list": ["import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\n\timport { State, StateSchema } from './state.schema';\n\timport { ApiProperty } from '@nestjs/swagger';\n\timport { TokenInterface } from '@vhidvz/wfjs';\n\t@Schema({ _id: false })\n\texport class Token implements TokenInterface {\n\t  @ApiProperty()\n\t  @Prop({ type: String })\n\t  id: string;\n\t  @ApiProperty()\n", "  @Prop({ type: String })\n\t  parent?: string;\n\t  @ApiProperty()\n\t  @Prop({ type: Boolean })\n\t  locked?: boolean;\n\t  @ApiProperty({ type: [State] })\n\t  @Prop({ type: [StateSchema] })\n\t  history: State[];\n\t}\n\texport const TokenSchema = SchemaFactory.createForClass(Token);\n"]}
{"filename": "src/schemas/app.schema.ts", "chunked_list": ["import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\n\timport { Token, TokenSchema } from './token.schema';\n\timport { ContextInterface } from '@vhidvz/wfjs';\n\timport { ApiProperty } from '@nestjs/swagger';\n\timport { HydratedDocument } from 'mongoose';\n\timport { Data } from './data.schema';\n\timport { Status } from 'src/enums';\n\t@Schema()\n\texport class App implements ContextInterface {\n\t  @ApiProperty()\n", "  @Prop({ type: Data, required: true, index: true })\n\t  data: Data;\n\t  @ApiProperty({ enum: Status })\n\t  @Prop({ type: String, enum: Status, required: true })\n\t  status: Status;\n\t  @ApiProperty({ type: [Token] })\n\t  @Prop({ type: [TokenSchema], required: true })\n\t  tokens: Token[];\n\t}\n\texport type AppDocument = HydratedDocument<App>;\n", "export const AppSchema = SchemaFactory.createForClass(App);\n"]}
{"filename": "src/schemas/state.schema.ts", "chunked_list": ["import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\n\timport { ApiProperty } from '@nestjs/swagger';\n\timport { StateInterface } from '@vhidvz/wfjs';\n\timport { Value } from './value.schema';\n\timport { Status } from 'src/enums';\n\t@Schema({ _id: false })\n\texport class State implements StateInterface {\n\t  @ApiProperty()\n\t  @Prop({ type: String })\n\t  ref: string;\n", "  @ApiProperty()\n\t  @Prop({ type: String, required: false })\n\t  name?: string;\n\t  @ApiProperty({ enum: Status })\n\t  @Prop({ type: String, enum: Status })\n\t  status: Status;\n\t  @ApiProperty()\n\t  @Prop({ type: Value, required: false })\n\t  value?: Value;\n\t}\n", "export const StateSchema = SchemaFactory.createForClass(State);\n"]}
{"filename": "src/schemas/data.schema.ts", "chunked_list": ["import { Prop, Schema } from '@nestjs/mongoose';\n\timport { ApiProperty } from '@nestjs/swagger';\n\t@Schema({ _id: false })\n\texport class Data {\n\t  @ApiProperty()\n\t  @Prop({ type: String, required: true, trim: true, minlength: 1 })\n\t  global: string;\n\t}\n"]}
{"filename": "src/schemas/index.ts", "chunked_list": ["export * from './app.schema';\n\texport * from './data.schema';\n\texport * from './value.schema';\n"]}
{"filename": "src/schemas/value.schema.ts", "chunked_list": ["import { Prop, Schema } from '@nestjs/mongoose';\n\timport { ApiProperty } from '@nestjs/swagger';\n\t@Schema({ _id: false })\n\texport class Value {\n\t  @ApiProperty()\n\t  @Prop({ type: String, required: true, trim: true, minlength: 1 })\n\t  local: string;\n\t}\n"]}
{"filename": "src/pipes/activity.pipe.ts", "chunked_list": ["import { BadRequestException, Injectable, PipeTransform } from '@nestjs/common';\n\timport { ACTIVITY_LIST } from 'src/app.constants';\n\t@Injectable()\n\texport class ActivityPipe implements PipeTransform {\n\t  transform(value: string): string {\n\t    if (!ACTIVITY_LIST.includes(value)) {\n\t      throw new BadRequestException('Invalid Activity');\n\t    }\n\t    return value;\n\t  }\n", "}\n"]}
{"filename": "src/pipes/index.ts", "chunked_list": ["export * from './activity.pipe';\n"]}
{"filename": "src/enums/index.ts", "chunked_list": ["export * from './status.enum';\n"]}
{"filename": "src/enums/status.enum.ts", "chunked_list": ["export enum Status {\n\t  Completed = 'completed',\n\t  Failed = 'failed',\n\t  Paused = 'paused',\n\t  Ready = 'ready',\n\t  Running = 'running',\n\t  Terminated = 'terminated',\n\t}\n"]}
{"filename": "src/dto/data.dto.ts", "chunked_list": ["import { IsNotEmpty, IsString } from 'class-validator';\n\texport class DataDto {\n\t  @IsString()\n\t  @IsNotEmpty()\n\t  global: string;\n\t}\n"]}
{"filename": "src/dto/value.dto.ts", "chunked_list": ["import { IsNotEmpty, IsString } from 'class-validator';\n\texport class ValueDto {\n\t  @IsString()\n\t  @IsNotEmpty()\n\t  local: string;\n\t}\n"]}
{"filename": "src/dto/index.ts", "chunked_list": ["export * from './data.dto';\n\texport * from './value.dto';\n"]}
