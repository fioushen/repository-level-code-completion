{"filename": "src/dem-manager.ts", "chunked_list": ["import AsyncCache from \"./cache\";\n\timport decodeImage from \"./decode-image\";\n\timport { HeightTile } from \"./height-tile\";\n\timport generateIsolines from \"./isolines\";\n\timport { encodeIndividualOptions, withTimeout } from \"./utils\";\n\timport {\n\t  CancelablePromise,\n\t  ContourTile,\n\t  DemTile,\n\t  Encoding,\n", "  FetchResponse,\n\t  IndividualContourTileOptions,\n\t} from \"./types\";\n\timport encodeVectorTile, { GeomType } from \"./vtpbf\";\n\timport { Timer } from \"./performance\";\n\t/**\n\t * Holds cached tile state, and exposes `fetchContourTile` which fetches the necessary\n\t * tiles and returns an encoded contour vector tiles.\n\t */\n\texport interface DemManager {\n", "  loaded: Promise<any>;\n\t  fetchTile(\n\t    z: number,\n\t    x: number,\n\t    y: number,\n\t    timer?: Timer,\n\t  ): CancelablePromise<FetchResponse>;\n\t  fetchAndParseTile(\n\t    z: number,\n\t    x: number,\n", "    y: number,\n\t    timer?: Timer,\n\t  ): CancelablePromise<DemTile>;\n\t  fetchContourTile(\n\t    z: number,\n\t    x: number,\n\t    y: number,\n\t    options: IndividualContourTileOptions,\n\t    timer?: Timer,\n\t  ): CancelablePromise<ContourTile>;\n", "}\n\t/**\n\t * Caches, decodes, and processes raster tiles in the current thread.\n\t */\n\texport class LocalDemManager implements DemManager {\n\t  tileCache: AsyncCache<string, FetchResponse>;\n\t  parsedCache: AsyncCache<string, DemTile>;\n\t  contourCache: AsyncCache<string, ContourTile>;\n\t  demUrlPattern: string;\n\t  encoding: Encoding;\n", "  maxzoom: number;\n\t  timeoutMs: number;\n\t  loaded = Promise.resolve();\n\t  decodeImage: (blob: Blob, encoding: Encoding) => CancelablePromise<DemTile> =\n\t    decodeImage;\n\t  constructor(\n\t    demUrlPattern: string,\n\t    cacheSize: number,\n\t    encoding: Encoding,\n\t    maxzoom: number,\n", "    timeoutMs: number,\n\t  ) {\n\t    this.tileCache = new AsyncCache(cacheSize);\n\t    this.parsedCache = new AsyncCache(cacheSize);\n\t    this.contourCache = new AsyncCache(cacheSize);\n\t    this.timeoutMs = timeoutMs;\n\t    this.demUrlPattern = demUrlPattern;\n\t    this.encoding = encoding;\n\t    this.maxzoom = maxzoom;\n\t  }\n", "  fetchTile(\n\t    z: number,\n\t    x: number,\n\t    y: number,\n\t    timer?: Timer,\n\t  ): CancelablePromise<FetchResponse> {\n\t    const url = this.demUrlPattern\n\t      .replace(\"{z}\", z.toString())\n\t      .replace(\"{x}\", x.toString())\n\t      .replace(\"{y}\", y.toString());\n", "    timer?.useTile(url);\n\t    return this.tileCache.getCancelable(url, () => {\n\t      let cancel = () => {};\n\t      const options: RequestInit = {};\n\t      try {\n\t        const controller = new AbortController();\n\t        options.signal = controller.signal;\n\t        cancel = () => controller.abort();\n\t      } catch (e) {\n\t        // ignore\n", "      }\n\t      timer?.fetchTile(url);\n\t      const mark = timer?.marker(\"fetch\");\n\t      return withTimeout(this.timeoutMs, {\n\t        value: fetch(url, options).then(async (response) => {\n\t          mark?.();\n\t          if (!response.ok) {\n\t            throw new Error(`Bad response: ${response.status} for ${url}`);\n\t          }\n\t          return {\n", "            data: await response.blob(),\n\t            expires: response.headers.get(\"expires\") || undefined,\n\t            cacheControl: response.headers.get(\"cache-control\") || undefined,\n\t          };\n\t        }),\n\t        cancel,\n\t      });\n\t    });\n\t  }\n\t  fetchAndParseTile = (\n", "    z: number,\n\t    x: number,\n\t    y: number,\n\t    timer?: Timer,\n\t  ): CancelablePromise<DemTile> => {\n\t    const self = this;\n\t    const url = this.demUrlPattern\n\t      .replace(\"{z}\", z.toString())\n\t      .replace(\"{x}\", x.toString())\n\t      .replace(\"{y}\", y.toString());\n", "    timer?.useTile(url);\n\t    return this.parsedCache.getCancelable(url, () => {\n\t      const tile = self.fetchTile(z, x, y, timer);\n\t      let canceled = false;\n\t      let alsoCancel = () => {};\n\t      return {\n\t        value: tile.value.then(async (response) => {\n\t          if (canceled) throw new Error(\"canceled\");\n\t          const result = self.decodeImage(response.data, self.encoding);\n\t          alsoCancel = result.cancel;\n", "          const mark = timer?.marker(\"decode\");\n\t          const value = await result.value;\n\t          mark?.();\n\t          return value;\n\t        }),\n\t        cancel: () => {\n\t          canceled = true;\n\t          alsoCancel();\n\t          tile.cancel();\n\t        },\n", "      };\n\t    });\n\t  };\n\t  fetchDem(\n\t    z: number,\n\t    x: number,\n\t    y: number,\n\t    options: IndividualContourTileOptions,\n\t    timer?: Timer,\n\t  ): CancelablePromise<HeightTile> {\n", "    const zoom = Math.min(z - (options.overzoom || 0), this.maxzoom);\n\t    const subZ = z - zoom;\n\t    const div = 1 << subZ;\n\t    const newX = Math.floor(x / div);\n\t    const newY = Math.floor(y / div);\n\t    const { value, cancel } = this.fetchAndParseTile(zoom, newX, newY, timer);\n\t    const subX = x % div;\n\t    const subY = y % div;\n\t    return {\n\t      value: value.then((tile) =>\n", "        HeightTile.fromRawDem(tile).split(subZ, subX, subY),\n\t      ),\n\t      cancel,\n\t    };\n\t  }\n\t  fetchContourTile(\n\t    z: number,\n\t    x: number,\n\t    y: number,\n\t    options: IndividualContourTileOptions,\n", "    timer?: Timer,\n\t  ): CancelablePromise<ContourTile> {\n\t    const {\n\t      levels,\n\t      multiplier = 1,\n\t      buffer = 1,\n\t      extent = 4096,\n\t      contourLayer = \"contours\",\n\t      elevationKey = \"ele\",\n\t      levelKey = \"level\",\n", "      subsampleBelow = 100,\n\t    } = options;\n\t    // no levels means less than min zoom with levels specified\n\t    if (!levels || levels.length === 0) {\n\t      return {\n\t        cancel() {},\n\t        value: Promise.resolve({ arrayBuffer: new ArrayBuffer(0) }),\n\t      };\n\t    }\n\t    const key = [z, x, y, encodeIndividualOptions(options)].join(\"/\");\n", "    return this.contourCache.getCancelable(key, () => {\n\t      const max = 1 << z;\n\t      let canceled = false;\n\t      const neighborPromises: (CancelablePromise<HeightTile> | null)[] = [];\n\t      for (let iy = y - 1; iy <= y + 1; iy++) {\n\t        for (let ix = x - 1; ix <= x + 1; ix++) {\n\t          neighborPromises.push(\n\t            iy < 0 || iy >= max\n\t              ? null\n\t              : this.fetchDem(z, (ix + max) % max, iy, options, timer),\n", "          );\n\t        }\n\t      }\n\t      const value = Promise.all(neighborPromises.map((n) => n?.value)).then(\n\t        async (neighbors) => {\n\t          let virtualTile = HeightTile.combineNeighbors(neighbors);\n\t          if (!virtualTile || canceled) {\n\t            return { arrayBuffer: new Uint8Array().buffer };\n\t          }\n\t          const mark = timer?.marker(\"isoline\");\n", "          if (virtualTile.width >= subsampleBelow) {\n\t            virtualTile = virtualTile.materialize(2);\n\t          } else {\n\t            while (virtualTile.width < subsampleBelow) {\n\t              virtualTile = virtualTile.subsamplePixelCenters(2).materialize(2);\n\t            }\n\t          }\n\t          virtualTile = virtualTile\n\t            .averagePixelCentersToGrid()\n\t            .scaleElevation(multiplier)\n", "            .materialize(1);\n\t          const isolines = generateIsolines(\n\t            levels[0],\n\t            virtualTile,\n\t            extent,\n\t            buffer,\n\t          );\n\t          mark?.();\n\t          const result = encodeVectorTile({\n\t            extent,\n", "            layers: {\n\t              [contourLayer]: {\n\t                features: Object.entries(isolines).map(([eleString, geom]) => {\n\t                  const ele = Number(eleString);\n\t                  return {\n\t                    type: GeomType.LINESTRING,\n\t                    geometry: geom,\n\t                    properties: {\n\t                      [elevationKey]: ele,\n\t                      [levelKey]: Math.max(\n", "                        ...levels.map((l, i) => (ele % l === 0 ? i : 0)),\n\t                      ),\n\t                    },\n\t                  };\n\t                }),\n\t              },\n\t            },\n\t          });\n\t          mark?.();\n\t          return { arrayBuffer: result.buffer };\n", "        },\n\t      );\n\t      return {\n\t        value,\n\t        cancel() {\n\t          canceled = true;\n\t          neighborPromises.forEach((n) => n && n.cancel());\n\t        },\n\t      };\n\t    });\n", "  }\n\t}\n"]}
{"filename": "src/vtpbf.ts", "chunked_list": ["/*\n\tAdapted from vt-pbf https://github.com/mapbox/vt-pbf\n\tThe MIT License (MIT)\n\tCopyright (c) 2015 Anand Thakker\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n", "The above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n\t*/\n", "import Pbf from \"pbf\";\n\texport const enum GeomType {\n\t  UNKNOWN = 0,\n\t  POINT = 1,\n\t  LINESTRING = 2,\n\t  POLYGON = 3,\n\t}\n\texport type PropertyValue = string | boolean | number;\n\texport interface Feature {\n\t  type: GeomType;\n", "  properties: { [key: string]: PropertyValue };\n\t  geometry: number[][];\n\t}\n\texport interface Layer {\n\t  features: Feature[];\n\t  extent?: number;\n\t}\n\texport interface Tile {\n\t  extent?: number;\n\t  layers: { [id: string]: Layer };\n", "}\n\tinterface Context {\n\t  keys: string[];\n\t  values: PropertyValue[];\n\t  keycache: { [any: string]: number };\n\t  valuecache: { [any: string]: number };\n\t  feature?: Feature;\n\t}\n\t/**\n\t * Enodes and serializes a mapbox vector tile as an array of bytes.\n", " */\n\texport default function encodeVectorTile(tile: Tile): Uint8Array {\n\t  const pbf = new Pbf();\n\t  for (const id in tile.layers) {\n\t    const layer = tile.layers[id];\n\t    if (!layer.extent) {\n\t      layer.extent = tile.extent;\n\t    }\n\t    pbf.writeMessage(3, writeLayer, { ...layer, id });\n\t  }\n", "  return pbf.finish();\n\t}\n\tfunction writeLayer(layer: Layer & { id: string }, pbf?: Pbf) {\n\t  if (!pbf) throw new Error(\"pbf undefined\");\n\t  pbf.writeVarintField(15, 2);\n\t  pbf.writeStringField(1, layer.id || \"\");\n\t  pbf.writeVarintField(5, layer.extent || 4096);\n\t  const context: Context = {\n\t    keys: [],\n\t    values: [],\n", "    keycache: {},\n\t    valuecache: {},\n\t  };\n\t  for (const feature of layer.features) {\n\t    context.feature = feature;\n\t    pbf.writeMessage(2, writeFeature, context);\n\t  }\n\t  for (const key of context.keys) {\n\t    pbf.writeStringField(3, key);\n\t  }\n", "  for (const value of context.values) {\n\t    pbf.writeMessage(4, writeValue, value);\n\t  }\n\t}\n\tfunction writeFeature(context: Context, pbf?: Pbf) {\n\t  const feature = context.feature;\n\t  if (!feature || !pbf) throw new Error();\n\t  pbf.writeMessage(2, writeProperties, context);\n\t  pbf.writeVarintField(3, feature.type);\n\t  pbf.writeMessage(4, writeGeometry, feature);\n", "}\n\tfunction writeProperties(context: Context, pbf?: Pbf) {\n\t  const feature = context.feature;\n\t  if (!feature || !pbf) throw new Error();\n\t  const keys = context.keys;\n\t  const values = context.values;\n\t  const keycache = context.keycache;\n\t  const valuecache = context.valuecache;\n\t  for (const key in feature.properties) {\n\t    let value = feature.properties[key];\n", "    let keyIndex = keycache[key];\n\t    if (value === null) continue; // don't encode null value properties\n\t    if (typeof keyIndex === \"undefined\") {\n\t      keys.push(key);\n\t      keyIndex = keys.length - 1;\n\t      keycache[key] = keyIndex;\n\t    }\n\t    pbf.writeVarint(keyIndex);\n\t    const type = typeof value;\n\t    if (type !== \"string\" && type !== \"boolean\" && type !== \"number\") {\n", "      value = JSON.stringify(value);\n\t    }\n\t    const valueKey = `${type}:${value}`;\n\t    let valueIndex = valuecache[valueKey];\n\t    if (typeof valueIndex === \"undefined\") {\n\t      values.push(value);\n\t      valueIndex = values.length - 1;\n\t      valuecache[valueKey] = valueIndex;\n\t    }\n\t    pbf.writeVarint(valueIndex);\n", "  }\n\t}\n\tfunction command(cmd: number, length: number) {\n\t  return (length << 3) + (cmd & 0x7);\n\t}\n\tfunction zigzag(num: number) {\n\t  return (num << 1) ^ (num >> 31);\n\t}\n\tfunction writeGeometry(feature: Feature, pbf?: Pbf) {\n\t  if (!pbf) throw new Error();\n", "  const geometry = feature.geometry;\n\t  const type = feature.type;\n\t  let x = 0;\n\t  let y = 0;\n\t  for (const ring of geometry) {\n\t    let count = 1;\n\t    if (type === GeomType.POINT) {\n\t      count = ring.length / 2;\n\t    }\n\t    pbf.writeVarint(command(1, count)); // moveto\n", "    // do not write polygon closing path as lineto\n\t    const length = ring.length / 2;\n\t    const lineCount = type === GeomType.POLYGON ? length - 1 : length;\n\t    for (let i = 0; i < lineCount; i++) {\n\t      if (i === 1 && type !== 1) {\n\t        pbf.writeVarint(command(2, lineCount - 1)); // lineto\n\t      }\n\t      const dx = ring[i * 2] - x;\n\t      const dy = ring[i * 2 + 1] - y;\n\t      pbf.writeVarint(zigzag(dx));\n", "      pbf.writeVarint(zigzag(dy));\n\t      x += dx;\n\t      y += dy;\n\t    }\n\t    if (type === GeomType.POLYGON) {\n\t      pbf.writeVarint(command(7, 1)); // closepath\n\t    }\n\t  }\n\t}\n\tfunction writeValue(value: PropertyValue, pbf?: Pbf) {\n", "  if (!pbf) throw new Error();\n\t  if (typeof value === \"string\") {\n\t    pbf.writeStringField(1, value);\n\t  } else if (typeof value === \"boolean\") {\n\t    pbf.writeBooleanField(7, value);\n\t  } else if (typeof value === \"number\") {\n\t    if (value % 1 !== 0) {\n\t      pbf.writeDoubleField(3, value);\n\t    } else if (value < 0) {\n\t      pbf.writeSVarintField(6, value);\n", "    } else {\n\t      pbf.writeVarintField(5, value);\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/config.ts", "chunked_list": ["const CONFIG = { workerUrl: \"\" };\n\texport default CONFIG;\n"]}
{"filename": "src/decode-image.ts", "chunked_list": ["/* eslint-disable no-restricted-globals */\n\timport type Actor from \"./actor\";\n\timport { offscreenCanvasSupported } from \"./utils\";\n\timport type { MainThreadDispatch } from \"./remote-dem-manager\";\n\timport { CancelablePromise, DemTile, Encoding } from \"./types\";\n\tlet offscreenCanvas: OffscreenCanvas;\n\tlet offscreenContext: OffscreenCanvasRenderingContext2D | null;\n\tlet canvas: HTMLCanvasElement;\n\tlet canvasContext: CanvasRenderingContext2D | null;\n\t/**\n", " * Parses a `raster-dem` image into a DemTile using OffscreenCanvas and createImageBitmap\n\t * only supported on newer browsers.\n\t */\n\tfunction decodeImageModern(\n\t  blob: Blob,\n\t  encoding: Encoding,\n\t): CancelablePromise<DemTile> {\n\t  let canceled = false;\n\t  const promise = createImageBitmap(blob).then((img) => {\n\t    if (canceled) return null as any as DemTile;\n", "    if (!offscreenCanvas) {\n\t      offscreenCanvas = new OffscreenCanvas(img.width, img.height);\n\t      offscreenContext = offscreenCanvas.getContext(\"2d\", {\n\t        willReadFrequently: true,\n\t      }) as OffscreenCanvasRenderingContext2D;\n\t    }\n\t    return getElevations(img, encoding, offscreenCanvas, offscreenContext);\n\t  });\n\t  return {\n\t    value: promise,\n", "    cancel: () => {\n\t      canceled = true;\n\t    },\n\t  };\n\t}\n\t/**\n\t * Parses a `raster-dem` image into a DemTile using `<img>` element drawn to a `<canvas>`.\n\t * Only works on the main thread, but works across all browsers.\n\t */\n\tfunction decodeImageOld(\n", "  blob: Blob,\n\t  encoding: Encoding,\n\t): CancelablePromise<DemTile> {\n\t  if (!canvas) {\n\t    canvas = document.createElement(\"canvas\");\n\t    canvasContext = canvas.getContext(\"2d\", {\n\t      willReadFrequently: true,\n\t    }) as CanvasRenderingContext2D;\n\t  }\n\t  let canceled = false;\n", "  const img: HTMLImageElement = new Image();\n\t  const value = new Promise<HTMLImageElement>((resolve, reject) => {\n\t    img.onload = () => {\n\t      if (!canceled) resolve(img);\n\t      URL.revokeObjectURL(img.src);\n\t      img.onload = null;\n\t    };\n\t    img.onerror = () => reject(new Error(\"Could not load image.\"));\n\t    img.src = blob.size ? URL.createObjectURL(blob) : \"\";\n\t  }).then((img: HTMLImageElement) =>\n", "    getElevations(img, encoding, canvas, canvasContext),\n\t  );\n\t  return {\n\t    value,\n\t    cancel: () => {\n\t      canceled = true;\n\t      img.src = \"\";\n\t    },\n\t  };\n\t}\n", "/**\n\t * Parses a `raster-dem` image in a worker that doesn't support OffscreenCanvas and createImageBitmap\n\t * by running decodeImageOld on the main thread and returning the result.\n\t */\n\tfunction decodeImageOnMainThread(\n\t  blob: Blob,\n\t  encoding: Encoding,\n\t): CancelablePromise<DemTile> {\n\t  return ((self as any).actor as Actor<MainThreadDispatch>).send(\n\t    \"decodeImage\",\n", "    [],\n\t    undefined,\n\t    blob,\n\t    encoding,\n\t  );\n\t}\n\tfunction isWorker(): boolean {\n\t  return (\n\t    // @ts-ignore\n\t    typeof WorkerGlobalScope !== \"undefined\" &&\n", "    typeof self !== \"undefined\" &&\n\t    // @ts-ignore\n\t    self instanceof WorkerGlobalScope\n\t  );\n\t}\n\tconst defaultDecoder: (\n\t  blob: Blob,\n\t  encoding: Encoding,\n\t) => CancelablePromise<DemTile> = offscreenCanvasSupported()\n\t  ? decodeImageModern\n", "  : isWorker()\n\t  ? decodeImageOnMainThread\n\t  : decodeImageOld;\n\texport default defaultDecoder;\n\tfunction getElevations(\n\t  img: ImageBitmap | HTMLImageElement,\n\t  encoding: Encoding,\n\t  canvas: HTMLCanvasElement | OffscreenCanvas,\n\t  canvasContext:\n\t    | CanvasRenderingContext2D\n", "    | OffscreenCanvasRenderingContext2D\n\t    | null,\n\t): DemTile {\n\t  canvas.width = img.width;\n\t  canvas.height = img.height;\n\t  if (!canvasContext) throw new Error(\"failed to get context\");\n\t  canvasContext.drawImage(img, 0, 0, img.width, img.height);\n\t  const rgba = canvasContext.getImageData(0, 0, img.width, img.height).data;\n\t  return decodeParsedImage(img.width, img.height, encoding, rgba);\n\t}\n", "export function decodeParsedImage(\n\t  width: number,\n\t  height: number,\n\t  encoding: Encoding,\n\t  input: Uint8ClampedArray,\n\t): DemTile {\n\t  const decoder: (r: number, g: number, b: number) => number =\n\t    encoding === \"mapbox\"\n\t      ? (r, g, b) => -10000 + (r * 256 * 256 + g * 256 + b) * 0.1\n\t      : (r, g, b) => r * 256 + g + b / 256 - 32768;\n", "  const data = new Float32Array(width * height);\n\t  for (let i = 0; i < input.length; i += 4) {\n\t    data[i / 4] = decoder(input[i], input[i + 1], input[i + 2]);\n\t  }\n\t  return { width, height, data };\n\t}\n"]}
{"filename": "src/types.ts", "chunked_list": ["/** Scheme used to map pixel rgb values elevations. */\n\texport type Encoding = \"terrarium\" | \"mapbox\";\n\texport interface IsTransferrable {\n\t  transferrables: Transferable[];\n\t}\n\t/** A decoded `raster-rgb` image. */\n\texport interface DemTile {\n\t  width: number;\n\t  height: number;\n\t  /** elevation values in row-major order */\n", "  data: Float32Array;\n\t}\n\texport interface TransferrableDemTile extends DemTile, IsTransferrable {}\n\t/** A rendered contour tile */\n\texport interface ContourTile {\n\t  /** Encoded mapbox vector tile bytes */\n\t  arrayBuffer: ArrayBuffer;\n\t}\n\texport interface TransferrableContourTile\n\t  extends ContourTile,\n", "    IsTransferrable {}\n\texport interface Cancelable {\n\t  cancel: () => void;\n\t}\n\texport interface CancelablePromise<T> extends Cancelable {\n\t  value: Promise<T>;\n\t}\n\texport interface FetchResponse {\n\t  data: Blob;\n\t  expires?: string;\n", "  cacheControl?: string;\n\t}\n\t/** Parameters to use when creating a contour vector tile from raw elevation data */\n\texport interface ContourTileOptions {\n\t  /** Factor to scale the elevation meters by to support different units (default 1 for meters) */\n\t  multiplier?: number;\n\t  /**\n\t   * Request `raster-dem` tiles from lower zoom levels to generate the contour vector tile.\n\t   *\n\t   * The default value is 0, which means to generate a contour vector tile at z10, it gets\n", "   * the z10 `raster-dem` tile plus its 8 neighbors\n\t   *\n\t   * Setting to 1 requests a z9 tile and uses one quadrant of it so that it only needs up to 3\n\t   * neighboring tiles to get the neighboring elevation data. It also improves performance with\n\t   * 512x512 or larger `raster-dem` tiles.\n\t   */\n\t  overzoom?: number;\n\t  /** Key for the elevation property to set on each contour line. */\n\t  elevationKey?: string;\n\t  /** Key for the \"level\" property to set on each contour line. Minor lines have level=0, major have level=1 */\n", "  levelKey?: string;\n\t  /** Name of the vector tile layer to put contour lines in */\n\t  contourLayer?: string;\n\t  /** Grid size of the vector tile (default 4096) */\n\t  extent?: number;\n\t  /** How many pixels to generate on each tile into the neighboring tile to reduce rendering artifacts */\n\t  buffer?: number;\n\t  /** When overzooming tiles, subsample to scale up to at least this size to make the contour lines smoother at higher zooms. */\n\t  subsampleBelow?: number;\n\t}\n", "export interface GlobalContourTileOptions extends ContourTileOptions {\n\t  /**\n\t   * Map from zoom level to the `[minor, major]` elevation distance between contour lines.\n\t   *\n\t   * Contour lines without an entry will use the threshold for the next lower zoom.\n\t   *\n\t   * The `level` tag on each contour line will have an integer that corresponds to the largest index in\n\t   * this array that the elevation is a multiple of.\n\t   */\n\t  thresholds: { [n: number]: number | number[] };\n", "}\n\texport interface IndividualContourTileOptions extends ContourTileOptions {\n\t  levels: number[];\n\t}\n\texport interface Image {\n\t  width: number;\n\t  height: number;\n\t  data: Uint8Array;\n\t}\n\texport interface InitMessage {\n", "  managerId: number;\n\t  demUrlPattern: string;\n\t  cacheSize: number;\n\t  encoding: Encoding;\n\t  maxzoom: number;\n\t  timeoutMs: number;\n\t}\n\texport type TimingCategory = \"main\" | \"worker\" | \"fetch\" | \"decode\" | \"isoline\";\n\t/** Performance profile for a tile request */\n\texport interface Timing {\n", "  /** The \"virtual\" tile url using the protocol ID registered with maplibre */\n\t  url: String;\n\t  /** Timing origin that all marks are relative to. */\n\t  origin: number;\n\t  /** Overall duration of the request */\n\t  duration: number;\n\t  /** Time spent fetching all resources, or `undefined` if they were cached */\n\t  fetch?: number;\n\t  /** Time spent decoding all raster-rgb images, or `undefined` if it was cached */\n\t  decode?: number;\n", "  /** Time spent generating isolines and rendering the vector tile, or `undefined` if it was cached */\n\t  process?: number;\n\t  wait: number;\n\t  /** Number of tiles used for generation, even if they were cached */\n\t  tilesUsed: number;\n\t  /** Map from category (fetch, main, isoline) to list of start/end timestamps */\n\t  marks: {\n\t    [key in TimingCategory]?: number[][];\n\t  };\n\t  /** Detailed timing for all resources actually fetched (not cached) to generate this tile */\n", "  resources: PerformanceResourceTiming[];\n\t  /** If the tile failed with an error */\n\t  error?: boolean;\n\t}\n"]}
{"filename": "src/performance.ts", "chunked_list": ["import { Timing, TimingCategory } from \"./types\";\n\texport const perf =\n\t  typeof performance !== \"undefined\" ? performance : undefined;\n\texport const timeOrigin = perf\n\t  ? perf.timeOrigin || new Date().getTime() - perf.now()\n\t  : new Date().getTime();\n\texport function getResourceTiming(url: string): PerformanceResourceTiming[] {\n\t  return JSON.parse(\n\t    JSON.stringify(\n\t      (perf?.getEntriesByName?.(url) as\n", "        | PerformanceResourceTiming[]\n\t        | undefined) || [],\n\t    ),\n\t  );\n\t}\n\texport function now(): number {\n\t  return perf ? perf.now() : new Date().getTime();\n\t}\n\tfunction flatten<T>(input: T[][]): T[] {\n\t  const result: T[] = [];\n", "  for (const list of input) {\n\t    result.push(...list);\n\t  }\n\t  return result;\n\t}\n\t/** Utility for tracking how long tiles take to generate, and where the time is going. */\n\texport class Timer {\n\t  marks: { [key in TimingCategory]?: number[][] } = {};\n\t  urls: string[] = [];\n\t  fetched: string[] = [];\n", "  resources: PerformanceResourceTiming[] = [];\n\t  markFinish: () => void;\n\t  tilesFetched: number = 0;\n\t  timeOrigin: number = timeOrigin;\n\t  constructor(name: TimingCategory) {\n\t    this.markFinish = this.marker(name);\n\t  }\n\t  finish = (url: string): Timing => {\n\t    this.markFinish();\n\t    const get = (type: TimingCategory): number | undefined => {\n", "      const all = this.marks[type] || [];\n\t      const max = Math.max(...all.map((ns) => Math.max(...ns)));\n\t      const min = Math.min(...all.map((ns) => Math.min(...ns)));\n\t      return Number.isFinite(max) ? max - min : undefined;\n\t    };\n\t    const duration = get(\"main\") || 0;\n\t    const fetch = get(\"fetch\");\n\t    const decode = get(\"decode\");\n\t    const process = get(\"isoline\");\n\t    return {\n", "      url,\n\t      tilesUsed: this.tilesFetched,\n\t      origin: this.timeOrigin,\n\t      marks: this.marks,\n\t      resources: [\n\t        ...this.resources,\n\t        ...flatten(this.fetched.map(getResourceTiming)),\n\t      ],\n\t      duration,\n\t      fetch,\n", "      decode,\n\t      process,\n\t      wait: duration - (fetch || 0) - (decode || 0) - (process || 0),\n\t    };\n\t  };\n\t  error = (url: string): Timing => ({ ...this.finish(url), error: true });\n\t  marker = (category: TimingCategory): (() => void) => {\n\t    if (!this.marks[category]) {\n\t      this.marks[category] = [];\n\t    }\n", "    const marks = [now()];\n\t    this.marks[category]?.push(marks);\n\t    return () => marks.push(now());\n\t  };\n\t  useTile = (url: string): void => {\n\t    if (this.urls.indexOf(url) < 0) {\n\t      this.urls.push(url);\n\t      this.tilesFetched++;\n\t    }\n\t  };\n", "  fetchTile = (url: string): void => {\n\t    if (this.fetched.indexOf(url) < 0) {\n\t      this.fetched.push(url);\n\t    }\n\t  };\n\t  addAll = (timings: Timing) => {\n\t    this.tilesFetched += timings.tilesUsed;\n\t    const offset = timings.origin - this.timeOrigin;\n\t    for (const category in timings.marks) {\n\t      const key = category as TimingCategory;\n", "      const ourList = this.marks[key] || (this.marks[key] = []);\n\t      ourList.push(\n\t        ...(timings.marks[key]?.map((ns) => ns.map((n) => n + offset)) || []),\n\t      );\n\t    }\n\t    this.resources.push(\n\t      ...timings.resources.map((rt) => applyOffset(rt, offset)),\n\t    );\n\t  };\n\t}\n", "const startOrEnd = /(Start$|End$|^start|^end)/;\n\tfunction applyOffset(obj: any, offset: number): PerformanceResourceTiming {\n\t  const result: { [_: string]: number } = {};\n\t  for (const key in obj) {\n\t    if (obj[key] !== 0 && startOrEnd.test(key)) {\n\t      result[key] = Number(obj[key]) + offset;\n\t    } else {\n\t      result[key] = obj[key];\n\t    }\n\t  }\n", "  return result as any as PerformanceResourceTiming;\n\t}\n"]}
{"filename": "src/worker.ts", "chunked_list": ["import Actor from \"./actor\";\n\timport { MainThreadDispatch } from \"./remote-dem-manager\";\n\timport WorkerDispatch from \"./worker-dispatch\";\n\tconst g: any =\n\t  typeof self !== \"undefined\"\n\t    ? self\n\t    : typeof window !== \"undefined\"\n\t    ? window\n\t    : global;\n\tg.actor = new Actor<MainThreadDispatch>(g, new WorkerDispatch());\n"]}
{"filename": "src/worker-dispatch.ts", "chunked_list": ["import { LocalDemManager } from \"./dem-manager\";\n\timport { Timer } from \"./performance\";\n\timport {\n\t  CancelablePromise,\n\t  ContourTile,\n\t  FetchResponse,\n\t  IndividualContourTileOptions,\n\t  InitMessage,\n\t  TransferrableDemTile,\n\t} from \"./types\";\n", "import { prepareContourTile, prepareDemTile } from \"./utils\";\n\tconst noManager = (managerId: number): CancelablePromise<any> => ({\n\t  cancel() {},\n\t  value: Promise.reject(new Error(`No manager registered for ${managerId}`)),\n\t});\n\t/**\n\t * Receives messages from an actor in the web worker.\n\t */\n\texport default class WorkerDispatch {\n\t  /** There is one worker shared between all managers in the main thread using the plugin, so need to store each of their configurations. */\n", "  managers: { [id: number]: LocalDemManager } = {};\n\t  init = (message: InitMessage): CancelablePromise<void> => {\n\t    this.managers[message.managerId] = new LocalDemManager(\n\t      message.demUrlPattern,\n\t      message.cacheSize,\n\t      message.encoding,\n\t      message.maxzoom,\n\t      message.timeoutMs,\n\t    );\n\t    return { cancel() {}, value: Promise.resolve() };\n", "  };\n\t  fetchTile = (\n\t    managerId: number,\n\t    z: number,\n\t    x: number,\n\t    y: number,\n\t    timer?: Timer,\n\t  ): CancelablePromise<FetchResponse> =>\n\t    this.managers[managerId]?.fetchTile(z, x, y, timer) || noManager(managerId);\n\t  fetchAndParseTile = (\n", "    managerId: number,\n\t    z: number,\n\t    x: number,\n\t    y: number,\n\t    timer?: Timer,\n\t  ): CancelablePromise<TransferrableDemTile> =>\n\t    prepareDemTile(\n\t      this.managers[managerId]?.fetchAndParseTile(z, x, y, timer) ||\n\t        noManager(managerId),\n\t      true,\n", "    );\n\t  fetchContourTile = (\n\t    managerId: number,\n\t    z: number,\n\t    x: number,\n\t    y: number,\n\t    options: IndividualContourTileOptions,\n\t    timer?: Timer,\n\t  ): CancelablePromise<ContourTile> =>\n\t    prepareContourTile(\n", "      this.managers[managerId]?.fetchContourTile(z, x, y, options, timer) ||\n\t        noManager(managerId),\n\t    );\n\t}\n"]}
{"filename": "src/vtpbf.test.ts", "chunked_list": ["import Pbf from \"pbf\";\n\timport encodeVectorTile, { GeomType } from \"./vtpbf\";\n\timport { VectorTile } from \"@mapbox/vector-tile\";\n\ttest(\"empty tile\", () => {\n\t  expect(\n\t    encodeVectorTile({\n\t      layers: {},\n\t    }).length,\n\t  ).toBe(0);\n\t});\n", "test(\"simple line\", () => {\n\t  const encoded = encodeVectorTile({\n\t    layers: {\n\t      contours: {\n\t        features: [\n\t          {\n\t            geometry: [[0, 1, 2, 3]],\n\t            type: GeomType.LINESTRING,\n\t            properties: {\n\t              key: \"value\",\n", "            },\n\t          },\n\t        ],\n\t      },\n\t    },\n\t  });\n\t  const result = new VectorTile(new Pbf(encoded));\n\t  expect(result.layers).toHaveProperty(\"contours\");\n\t  expect(result.layers.contours.extent).toBe(4096);\n\t  expect(result.layers.contours.version).toBe(2);\n", "  expect(result.layers.contours.length).toBe(1);\n\t  expect(result.layers.contours.feature(0).properties).toEqual({\n\t    key: \"value\",\n\t  });\n\t  expect(result.layers.contours.feature(0).loadGeometry()).toEqual([\n\t    [\n\t      { x: 0, y: 1 },\n\t      { x: 2, y: 3 },\n\t    ],\n\t  ]);\n", "});\n\ttest(\"multi line\", () => {\n\t  const encoded = encodeVectorTile({\n\t    layers: {\n\t      contours: {\n\t        features: [\n\t          {\n\t            geometry: [\n\t              [0, 1, 2, 3],\n\t              [9, 8, 7, 6],\n", "            ],\n\t            type: GeomType.LINESTRING,\n\t            properties: {\n\t              key: 1,\n\t              key2: true,\n\t            },\n\t          },\n\t        ],\n\t      },\n\t    },\n", "  });\n\t  const result = new VectorTile(new Pbf(encoded));\n\t  expect(result.layers.contours.feature(0).properties).toEqual({\n\t    key: 1,\n\t    key2: true,\n\t  });\n\t  expect(result.layers.contours.feature(0).loadGeometry()).toEqual([\n\t    [\n\t      { x: 0, y: 1 },\n\t      { x: 2, y: 3 },\n", "    ],\n\t    [\n\t      { x: 9, y: 8 },\n\t      { x: 7, y: 6 },\n\t    ],\n\t  ]);\n\t});\n"]}
{"filename": "src/height-tile.test.ts", "chunked_list": ["import { HeightTile } from \"./height-tile\";\n\tconst initialTile = HeightTile.fromRawDem({\n\t  width: 2,\n\t  height: 2,\n\t  data: Float32Array.from([0, 1, 2, 3]),\n\t});\n\ttest(\"raw tile\", () => {\n\t  expect(initialTile.get(0, 0)).toBe(0);\n\t  expect(initialTile.get(1, 0)).toBe(1);\n\t  expect(initialTile.get(1, 1)).toBe(3);\n", "});\n\ttest(\"split height tile\", () => {\n\t  const split = initialTile.split(1, 0, 0);\n\t  expect(split.get(0, 0)).toBe(0);\n\t  expect(split.width).toBe(1);\n\t  const split2 = initialTile.split(1, 1, 1);\n\t  expect(split2.get(0, 0)).toBe(3);\n\t  expect(split2.width).toBe(1);\n\t});\n\tconst neighbors: HeightTile[] = [];\n", "for (let i = 0; i < 9; i++) {\n\t  const row = Math.floor(i / 3);\n\t  const start = i * 2 + row * 6;\n\t  neighbors.push(\n\t    HeightTile.fromRawDem({\n\t      width: 2,\n\t      height: 2,\n\t      data: Float32Array.from([start, start + 1, start + 6, start + 7]),\n\t    }),\n\t  );\n", "}\n\t// 0  1  | 2  3  | 4  5\n\t// 6  7  | 8  9  | 10 11\n\t// ------ ------- ------\n\t// 12 13 | 14 15 | 16 17\n\t// 18 19 | 20 21 | 22 23\n\t// ------ ------- ------\n\t// 24 25 | 26 27 | 28 29\n\t// 30 31 | 32 33 | 34 35\n\ttest(\"neighboring tiles\", () => {\n", "  const virtualTile = HeightTile.combineNeighbors(neighbors);\n\t  expect(virtualTile?.get(-1, -1)).toBe(7);\n\t  expect(virtualTile?.get(0, -1)).toBe(8);\n\t  expect(virtualTile?.get(1, -1)).toBe(9);\n\t  expect(virtualTile?.get(2, -1)).toBe(10);\n\t  expect(virtualTile?.get(-1, 0)).toBe(13);\n\t  expect(virtualTile?.get(0, 0)).toBe(14);\n\t  expect(virtualTile?.get(1, 0)).toBe(15);\n\t  expect(virtualTile?.get(2, 0)).toBe(16);\n\t  expect(virtualTile?.get(-1, 2)).toBe(25);\n", "  expect(virtualTile?.get(0, 2)).toBe(26);\n\t  expect(virtualTile?.get(1, 2)).toBe(27);\n\t  expect(virtualTile?.get(2, 2)).toBe(28);\n\t});\n\t// 0  1  | 2  3  | 4  5\n\t// 6  7  | 8  9  | 10 11\n\t// ------ ------- ------\n\t// 12 13 | 14 15 | 16 17\n\t// 18 19 | 20 21 | 22 23\n\t// ------ ------- ------\n", "// 24 25 | 26 27 | 28 29\n\t// 30 31 | 32 33 | 34 35\n\ttest(\"average pixel centers to grid\", () => {\n\t  const virtualTile =\n\t    HeightTile.combineNeighbors(neighbors)?.averagePixelCentersToGrid();\n\t  // 7,8,13,14\n\t  expect(virtualTile?.get(0, 0)).toBe((7 + 8 + 13 + 14) / 4);\n\t  expect(virtualTile?.get(1, 0)).toBe((8 + 9 + 14 + 15) / 4);\n\t  expect(virtualTile?.get(2, 0)).toBe((9 + 10 + 15 + 16) / 4);\n\t  expect(virtualTile?.get(0, 2)).toBe((19 + 20 + 25 + 26) / 4);\n", "  expect(virtualTile?.get(2, 2)).toBe((21 + 22 + 27 + 28) / 4);\n\t  expect(virtualTile).toMatchObject({\n\t    width: 3,\n\t    height: 3,\n\t  });\n\t});\n\ttest(\"subsample pixel centers\", () => {\n\t  /*  ___________ ____________\n\t     |             |            |\n\t     | old -1,-1   |  old 0,-1  |\n", "     |      7      |     8      |\n\t     |new -1,-1>x  |  x<new 0,-1|\n\t     |_____________|____________|\n\t     |             |            |\n\t     | new -1,0>x  |  x<new 0,0 |\n\t     |       13    |     14     |\n\t     |   old -1,0  |  old 0,0   |\n\t     |_____________|____________|\n\t  */\n\t  const virtualTile =\n", "    HeightTile.combineNeighbors(neighbors)?.subsamplePixelCenters(2);\n\t  expect(virtualTile?.get(0, 0)).toBe((7.75 + 3 * 13.75) / 4);\n\t  expect(virtualTile?.get(-1, -1)).toBe((7.25 * 3 + 13.25) / 4);\n\t  expect(virtualTile).toMatchObject({\n\t    width: 4,\n\t    height: 4,\n\t  });\n\t});\n\ttest(\"subsample and average centers alignment between tiles\", () => {\n\t  /*  ___________ ____________\n", "     |             |            |\n\t     | old -1,-1   |  old 0,-1  |\n\t     |      7      |     8      |\n\t     |new -1,-1>x  |  x<new 0,-1|\n\t     |_____________|____________|\n\t     |             |            |\n\t     | new -1,0>x  |  x<new 0,0 |\n\t     |       13    |     14     |\n\t     |   old -1,0  |  old 0,0   |\n\t     |_____________|____________|\n", "  */\n\t  const subsampled = HeightTile.combineNeighbors(neighbors)\n\t    ?.subsamplePixelCenters(2)\n\t    .averagePixelCentersToGrid();\n\t  const notSubsampled =\n\t    HeightTile.combineNeighbors(neighbors)?.averagePixelCentersToGrid();\n\t  expect(subsampled).toMatchObject({\n\t    width: 5,\n\t    height: 5,\n\t  });\n", "  expect(notSubsampled).toMatchObject({\n\t    width: 3,\n\t    height: 3,\n\t  });\n\t  expect(subsampled?.get(0, 0)).toBe(notSubsampled?.get(0, 0));\n\t  expect(subsampled?.get(2, 2)).toBe(notSubsampled?.get(1, 1));\n\t  expect(subsampled?.get(-2, -2)).toBe(notSubsampled?.get(-1, -1));\n\t});\n"]}
{"filename": "src/actor.test.ts", "chunked_list": ["import Actor from \"./actor\";\n\timport { Timer } from \"./performance\";\n\timport { CancelablePromise } from \"./types\";\n\tclass Local {\n\t  received: any[][] = [];\n\t  localAction = (x: number, y: number, z: number): CancelablePromise<void> => {\n\t    this.received.push([x, y, z]);\n\t    return { cancel() {}, value: Promise.resolve() };\n\t  };\n\t}\n", "class Remote {\n\t  received: any[][] = [];\n\t  canceled = false;\n\t  remoteAction = (x: number, y: number, z: number): CancelablePromise<void> => {\n\t    this.received.push([x, y, z]);\n\t    return { cancel() {}, value: Promise.resolve() };\n\t  };\n\t  remotePromise = (x: number, timer?: Timer): CancelablePromise<number> => {\n\t    const oldNow = performance.now;\n\t    if (timer) timer.timeOrigin = 100;\n", "    performance.now = () => oldNow() - 100;\n\t    const finish = timer?.marker(\"fetch\");\n\t    performance.now = () => oldNow() - 99;\n\t    finish?.();\n\t    performance.now = () => oldNow() + 2;\n\t    return {\n\t      cancel() {\n\t        throw new Error(\"not expected\");\n\t      },\n\t      value: Promise.resolve(x),\n", "    };\n\t  };\n\t  remoteFail = (): CancelablePromise<number> => ({\n\t    cancel() {},\n\t    value: Promise.reject(new Error(\"error\")),\n\t  });\n\t  remoteNever = (): CancelablePromise<number> => ({\n\t    cancel: () => {\n\t      this.canceled = true;\n\t    },\n", "    value: new Promise(() => {}),\n\t  });\n\t}\n\ttest(\"send and cancel messages\", async () => {\n\t  performance.now = () => 1;\n\t  const remote = new Remote();\n\t  const local = new Local();\n\t  const workerFromMainThread: Worker = {} as any as Worker;\n\t  const mainThreadFromWorker: Worker = {} as any as Worker;\n\t  workerFromMainThread.postMessage = (data) =>\n", "    //@ts-ignore\n\t    mainThreadFromWorker?.onmessage?.({ data });\n\t  mainThreadFromWorker.postMessage = (data) =>\n\t    //@ts-ignore\n\t    workerFromMainThread?.onmessage?.({ data });\n\t  const mainActor = new Actor<Remote>(workerFromMainThread, local);\n\t  const workerActor = new Actor<Local>(mainThreadFromWorker, remote);\n\t  mainActor.send(\"remoteAction\", [], undefined, 1, 2, 3);\n\t  expect(remote.received).toEqual([[1, 2, 3]]);\n\t  workerActor.send(\"localAction\", [], undefined, 4, 3, 2);\n", "  expect(local.received).toEqual([[4, 3, 2]]);\n\t  const timer = new Timer(\"main\");\n\t  timer.timeOrigin = 0;\n\t  expect(await mainActor.send(\"remotePromise\", [], timer, 9).value).toBe(9);\n\t  expect(timer.finish(\"url\")).toMatchObject({\n\t    duration: 2,\n\t    fetch: 1,\n\t    marks: {\n\t      fetch: [[1, 2]],\n\t      main: [[1, 3]],\n", "    },\n\t  });\n\t  const { cancel } = mainActor.send(\"remoteNever\", []);\n\t  expect(remote.canceled).toBeFalsy();\n\t  cancel();\n\t  expect(remote.canceled).toBeTruthy();\n\t  await expect(mainActor.send(\"remoteFail\", []).value).rejects.toThrowError(\n\t    \"Error: error\",\n\t  );\n\t});\n"]}
{"filename": "src/remote-dem-manager.ts", "chunked_list": ["import Actor from \"./actor\";\n\timport CONFIG from \"./config\";\n\timport type WorkerDispatch from \"./worker-dispatch\";\n\timport decodeImage from \"./decode-image\";\n\timport type { DemManager } from \"./dem-manager\";\n\timport { Timer } from \"./performance\";\n\timport {\n\t  CancelablePromise,\n\t  ContourTile,\n\t  DemTile,\n", "  Encoding,\n\t  FetchResponse,\n\t  IndividualContourTileOptions,\n\t} from \"./types\";\n\timport { prepareDemTile } from \"./utils\";\n\tlet _actor: Actor<WorkerDispatch> | undefined;\n\tlet id = 0;\n\texport class MainThreadDispatch {\n\t  decodeImage = (blob: Blob, encoding: Encoding) =>\n\t    prepareDemTile(decodeImage(blob, encoding), false);\n", "}\n\tfunction defaultActor(): Actor<WorkerDispatch> {\n\t  if (!_actor) {\n\t    const worker = new Worker(CONFIG.workerUrl);\n\t    const dispatch = new MainThreadDispatch();\n\t    _actor = new Actor(worker, dispatch);\n\t  }\n\t  return _actor;\n\t}\n\t/**\n", " * Caches, decodes, and processes raster tiles in a shared web worker.\n\t */\n\texport default class RemoteDemManager implements DemManager {\n\t  managerId: number;\n\t  actor: Actor<WorkerDispatch>;\n\t  loaded: Promise<any>;\n\t  constructor(\n\t    demUrlPattern: string,\n\t    cacheSize: number,\n\t    encoding: Encoding,\n", "    maxzoom: number,\n\t    timeoutMs: number,\n\t    actor?: Actor<WorkerDispatch>,\n\t  ) {\n\t    const managerId = (this.managerId = ++id);\n\t    this.actor = actor || defaultActor();\n\t    this.loaded = this.actor.send(\"init\", [], undefined, {\n\t      cacheSize,\n\t      demUrlPattern,\n\t      encoding,\n", "      maxzoom,\n\t      managerId,\n\t      timeoutMs,\n\t    }).value;\n\t  }\n\t  fetchTile = (\n\t    z: number,\n\t    x: number,\n\t    y: number,\n\t    timer?: Timer,\n", "  ): CancelablePromise<FetchResponse> =>\n\t    this.actor.send(\"fetchTile\", [], timer, this.managerId, z, x, y);\n\t  fetchAndParseTile = (\n\t    z: number,\n\t    x: number,\n\t    y: number,\n\t    timer?: Timer,\n\t  ): CancelablePromise<DemTile> =>\n\t    this.actor.send(\"fetchAndParseTile\", [], timer, this.managerId, z, x, y);\n\t  fetchContourTile = (\n", "    z: number,\n\t    x: number,\n\t    y: number,\n\t    options: IndividualContourTileOptions,\n\t    timer?: Timer,\n\t  ): CancelablePromise<ContourTile> =>\n\t    this.actor.send(\n\t      \"fetchContourTile\",\n\t      [],\n\t      timer,\n", "      this.managerId,\n\t      z,\n\t      x,\n\t      y,\n\t      options,\n\t    );\n\t}\n"]}
{"filename": "src/isolines.ts", "chunked_list": ["/*\n\tAdapted from d3-contour https://github.com/d3/d3-contour\n\tCopyright 2012-2023 Mike Bostock\n\tPermission to use, copy, modify, and/or distribute this software for any purpose\n\twith or without fee is hereby granted, provided that the above copyright notice\n\tand this permission notice appear in all copies.\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n\tREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n\tFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n\tINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n", "OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n\tTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n\tTHIS SOFTWARE.\n\t*/\n\timport type { HeightTile } from \"./height-tile\";\n\tclass Fragment {\n\t  start: number;\n\t  end: number;\n\t  points: number[];\n\t  constructor(start: number, end: number) {\n", "    this.start = start;\n\t    this.end = end;\n\t    this.points = [];\n\t    this.append = this.append.bind(this);\n\t    this.prepend = this.prepend.bind(this);\n\t  }\n\t  append(x: number, y: number) {\n\t    this.points.push(Math.round(x), Math.round(y));\n\t  }\n\t  prepend(x: number, y: number) {\n", "    this.points.splice(0, 0, Math.round(x), Math.round(y));\n\t  }\n\t  lineString() {\n\t    return this.toArray();\n\t  }\n\t  isEmpty() {\n\t    return this.points.length < 2;\n\t  }\n\t  appendFragment(other: Fragment) {\n\t    this.points.push(...other.points);\n", "    this.end = other.end;\n\t  }\n\t  toArray() {\n\t    return this.points;\n\t  }\n\t}\n\tconst CASES: [number, number][][][] = [\n\t  [],\n\t  [\n\t    [\n", "      [1, 2],\n\t      [0, 1],\n\t    ],\n\t  ],\n\t  [\n\t    [\n\t      [2, 1],\n\t      [1, 2],\n\t    ],\n\t  ],\n", "  [\n\t    [\n\t      [2, 1],\n\t      [0, 1],\n\t    ],\n\t  ],\n\t  [\n\t    [\n\t      [1, 0],\n\t      [2, 1],\n", "    ],\n\t  ],\n\t  [\n\t    [\n\t      [1, 2],\n\t      [0, 1],\n\t    ],\n\t    [\n\t      [1, 0],\n\t      [2, 1],\n", "    ],\n\t  ],\n\t  [\n\t    [\n\t      [1, 0],\n\t      [1, 2],\n\t    ],\n\t  ],\n\t  [\n\t    [\n", "      [1, 0],\n\t      [0, 1],\n\t    ],\n\t  ],\n\t  [\n\t    [\n\t      [0, 1],\n\t      [1, 0],\n\t    ],\n\t  ],\n", "  [\n\t    [\n\t      [1, 2],\n\t      [1, 0],\n\t    ],\n\t  ],\n\t  [\n\t    [\n\t      [0, 1],\n\t      [1, 0],\n", "    ],\n\t    [\n\t      [2, 1],\n\t      [1, 2],\n\t    ],\n\t  ],\n\t  [\n\t    [\n\t      [2, 1],\n\t      [1, 0],\n", "    ],\n\t  ],\n\t  [\n\t    [\n\t      [0, 1],\n\t      [2, 1],\n\t    ],\n\t  ],\n\t  [\n\t    [\n", "      [1, 2],\n\t      [2, 1],\n\t    ],\n\t  ],\n\t  [\n\t    [\n\t      [0, 1],\n\t      [1, 2],\n\t    ],\n\t  ],\n", "  [],\n\t];\n\tfunction index(width: number, x: number, y: number, point: [number, number]) {\n\t  x = x * 2 + point[0];\n\t  y = y * 2 + point[1];\n\t  return x + y * (width + 1) * 2;\n\t}\n\tfunction ratio(a: number, b: number, c: number) {\n\t  return (b - a) / (c - a);\n\t}\n", "/**\n\t * Generates contour lines from a HeightTile\n\t *\n\t * @param interval Vertical distance between contours\n\t * @param tile The input height tile, where values represent the height at the top-left of each pixel\n\t * @param extent Vector tile extent (default 4096)\n\t * @param buffer How many pixels into each neighboring tile to include in a tile\n\t * @returns an object where keys are the elevation, and values are a list of `[x1, y1, x2, y2, ...]`\n\t * contour lines in tile coordinates\n\t */\n", "export default function generateIsolines(\n\t  interval: number,\n\t  tile: HeightTile,\n\t  extent: number = 4096,\n\t  buffer: number = 1,\n\t): { [ele: number]: number[][] } {\n\t  if (!interval) {\n\t    return {};\n\t  }\n\t  const multiplier = extent / (tile.width - 1);\n", "  let tld: number, trd: number, bld: number, brd: number;\n\t  let r: number, c: number;\n\t  const segments: { [ele: string]: number[][] } = {};\n\t  const fragmentByStartByLevel: Map<number, Map<number, Fragment>> = new Map();\n\t  const fragmentByEndByLevel: Map<number, Map<number, Fragment>> = new Map();\n\t  function interpolate(\n\t    point: [number, number],\n\t    threshold: number,\n\t    accept: (x: number, y: number) => void,\n\t  ) {\n", "    if (point[0] === 0) {\n\t      // left\n\t      accept(\n\t        multiplier * (c - 1),\n\t        multiplier * (r - ratio(bld, threshold, tld)),\n\t      );\n\t    } else if (point[0] === 2) {\n\t      // right\n\t      accept(multiplier * c, multiplier * (r - ratio(brd, threshold, trd)));\n\t    } else if (point[1] === 0) {\n", "      // top\n\t      accept(\n\t        multiplier * (c - ratio(trd, threshold, tld)),\n\t        multiplier * (r - 1),\n\t      );\n\t    } else {\n\t      // bottom\n\t      accept(multiplier * (c - ratio(brd, threshold, bld)), multiplier * r);\n\t    }\n\t  }\n", "  // Most marching-squares implementations (d3-contour, gdal-contour) make one pass through the matrix per threshold.\n\t  // This implementation makes a single pass through the matrix, building up all of the contour lines at the\n\t  // same time to improve performance.\n\t  for (r = 1 - buffer; r < tile.height + buffer; r++) {\n\t    trd = tile.get(0, r - 1);\n\t    brd = tile.get(0, r);\n\t    let minR = Math.min(trd, brd);\n\t    let maxR = Math.max(trd, brd);\n\t    for (c = 1 - buffer; c < tile.width + buffer; c++) {\n\t      tld = trd;\n", "      bld = brd;\n\t      trd = tile.get(c, r - 1);\n\t      brd = tile.get(c, r);\n\t      const minL = minR;\n\t      const maxL = maxR;\n\t      minR = Math.min(trd, brd);\n\t      maxR = Math.max(trd, brd);\n\t      if (isNaN(tld) || isNaN(trd) || isNaN(brd) || isNaN(bld)) {\n\t        continue;\n\t      }\n", "      const min = Math.min(minL, minR);\n\t      const max = Math.max(maxL, maxR);\n\t      const start = Math.ceil(min / interval) * interval;\n\t      const end = Math.floor(max / interval) * interval;\n\t      for (let threshold = start; threshold <= end; threshold += interval) {\n\t        const tl = tld > threshold;\n\t        const tr = trd > threshold;\n\t        const bl = bld > threshold;\n\t        const br = brd > threshold;\n\t        for (const segment of CASES[\n", "          (tl ? 8 : 0) | (tr ? 4 : 0) | (br ? 2 : 0) | (bl ? 1 : 0)\n\t        ]) {\n\t          let fragmentByStart = fragmentByStartByLevel.get(threshold);\n\t          if (!fragmentByStart)\n\t            fragmentByStartByLevel.set(\n\t              threshold,\n\t              (fragmentByStart = new Map()),\n\t            );\n\t          let fragmentByEnd = fragmentByEndByLevel.get(threshold);\n\t          if (!fragmentByEnd)\n", "            fragmentByEndByLevel.set(threshold, (fragmentByEnd = new Map()));\n\t          const start = segment[0];\n\t          const end = segment[1];\n\t          const startIndex = index(tile.width, c, r, start);\n\t          const endIndex = index(tile.width, c, r, end);\n\t          let f, g;\n\t          if ((f = fragmentByEnd.get(startIndex))) {\n\t            fragmentByEnd.delete(startIndex);\n\t            if ((g = fragmentByStart.get(endIndex))) {\n\t              fragmentByStart.delete(endIndex);\n", "              if (f === g) {\n\t                // closing a ring\n\t                interpolate(end, threshold, f.append);\n\t                if (!f.isEmpty()) {\n\t                  let list = segments[threshold];\n\t                  if (!list) {\n\t                    segments[threshold] = list = [];\n\t                  }\n\t                  list.push(f.lineString());\n\t                }\n", "              } else {\n\t                // connecting 2 segments\n\t                f.appendFragment(g);\n\t                fragmentByEnd.set((f.end = g.end), f);\n\t              }\n\t            } else {\n\t              // adding to the end of f\n\t              interpolate(end, threshold, f.append);\n\t              fragmentByEnd.set((f.end = endIndex), f);\n\t            }\n", "          } else if ((f = fragmentByStart.get(endIndex))) {\n\t            fragmentByStart.delete(endIndex);\n\t            // extending the start of f\n\t            interpolate(start, threshold, f.prepend);\n\t            fragmentByStart.set((f.start = startIndex), f);\n\t          } else {\n\t            // starting a new fragment\n\t            const newFrag = new Fragment(startIndex, endIndex);\n\t            interpolate(start, threshold, newFrag.append);\n\t            interpolate(end, threshold, newFrag.append);\n", "            fragmentByStart.set(startIndex, newFrag);\n\t            fragmentByEnd.set(endIndex, newFrag);\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t  for (const [level, fragmentByStart] of fragmentByStartByLevel.entries()) {\n\t    let list: number[][] | null = null;\n\t    for (const value of fragmentByStart.values()) {\n", "      if (!value.isEmpty()) {\n\t        if (list == null) {\n\t          list = segments[level] || (segments[level] = []);\n\t        }\n\t        list.push(value.lineString());\n\t      }\n\t    }\n\t  }\n\t  return segments;\n\t}\n"]}
{"filename": "src/isolines.test.ts", "chunked_list": ["import { flattenDeep } from \"lodash\";\n\timport { HeightTile } from \"./height-tile\";\n\timport generateIsolines from \"./isolines\";\n\trunTestWithRotations(\"corner halfway\", 2, heightTile(1, 1, 1, 3), {\n\t  2: [[1, 0.5, 0.5, 1]],\n\t});\n\trunTestWithRotations(\n\t  \"corner above most of the way\",\n\t  2,\n\t  heightTile(1, 1, 1, 2.33333),\n", "  {\n\t    2: [[1, 0.75, 0.75, 1]],\n\t  },\n\t);\n\trunTestWithRotations(\"two contours\", 2, heightTile(1, 1, 1, 5), {\n\t  2: [[1, 0.25, 0.25, 1]],\n\t  4: [[1, 0.75, 0.75, 1]],\n\t});\n\trunTestWithRotations(\n\t  \"edge above threshold\",\n", "  2,\n\t  heightTile(1, 1, 2.33333, 2.33333),\n\t  {\n\t    2: [[1, 0.75, 0, 0.75]],\n\t  },\n\t);\n\trunTestWithRotations(\n\t  \"edge above threshold\",\n\t  2,\n\t  heightTile(1, 1, 2.33333, 2.33333),\n", "  {\n\t    2: [[1, 0.75, 0, 0.75]],\n\t  },\n\t);\n\trunTestWithRotations(\"corner up to threshold\", 2, heightTile(1, 1, 1, 2), {});\n\trunTestWithRotations(\"omit empty point??\", 2, heightTile(2, 3, 3, 3), {\n\t  2: [[0, 0, 0, 0]],\n\t});\n\trunTestWithRotations(\"side up to threshold\", 2, heightTile(1, 2, 1, 2), {});\n\trunTestWithRotations(\"side down to threshold\", 2, heightTile(2, 3, 2, 3), {\n", "  2: [[0, 0, 0, 1]],\n\t});\n\trunTestWithRotations(\n\t  \"threshold middle\",\n\t  2,\n\t  heightTile([\n\t    [1, 1, 1, 1],\n\t    [1, 2, 1, 1],\n\t    [1, 2, 1, 1],\n\t    [1, 1, 1, 1],\n", "  ]),\n\t  {},\n\t);\n\trunTestWithRotations(\n\t  \"corner below threshold\",\n\t  2,\n\t  heightTile([\n\t    [1, 2.3333333],\n\t    [2.3333333, 2.3333333],\n\t  ]),\n", "  {\n\t    2: [[0.75, 0, 0, 0.75]],\n\t  },\n\t);\n\trunTest(\n\t  \"saddle\",\n\t  0,\n\t  2,\n\t  heightTile([\n\t    [1, 2.3333333],\n", "    [2.3333333, 1],\n\t  ]),\n\t  {\n\t    2: [\n\t      [0.25, 1, 0, 0.75],\n\t      [0.75, 0, 1, 0.25],\n\t    ],\n\t  },\n\t);\n\trunTestWithRotations(\"no contours\", 2, heightTile(1, 1, 1, 1), {});\n", "runTestWithRotations(\n\t  \"connect segments\",\n\t  2,\n\t  heightTile([\n\t    [1, 3, 3],\n\t    [1, 1, 3],\n\t    [1, 1, 1],\n\t  ]),\n\t  {\n\t    2: [[0.5, 0, 1, 0.5, 1.5, 1, 2, 1.5]],\n", "  },\n\t);\n\trunTest(\n\t  \"center point above\",\n\t  0,\n\t  2,\n\t  heightTile([\n\t    [1, 1, 1],\n\t    [1, 3, 1],\n\t    [1, 1, 1],\n", "  ]),\n\t  {\n\t    2: [[1.5, 1, 1, 0.5, 0.5, 1, 1, 1.5, 1.5, 1]],\n\t  },\n\t);\n\trunTest(\n\t  \"center point below\",\n\t  0,\n\t  2,\n\t  heightTile([\n", "    [3, 3, 3],\n\t    [3, 1, 3],\n\t    [3, 3, 3],\n\t  ]),\n\t  {\n\t    2: [[1, 1.5, 0.5, 1, 1, 0.5, 1.5, 1, 1, 1.5]],\n\t  },\n\t);\n\tfunction heightTile(...values: number[] | number[][][]): HeightTile {\n\t  const flattened = flattenDeep(values);\n", "  const size = Math.sqrt(flattened.length);\n\t  return HeightTile.fromRawDem({\n\t    width: size,\n\t    height: size,\n\t    data: Float32Array.from(flattened),\n\t  });\n\t}\n\tfunction runTestWithRotations(\n\t  name: string,\n\t  interval: number,\n", "  heightTile: HeightTile,\n\t  expected: { [ele: number]: number[][] },\n\t) {\n\t  for (const rotation of [0, 90, 180, 270]) {\n\t    runTest(\n\t      `${name} (rotation=${rotation})`,\n\t      rotation,\n\t      interval,\n\t      heightTile,\n\t      expected,\n", "    );\n\t  }\n\t}\n\tfunction rotate(\n\t  [x, y]: [number, number],\n\t  [ax, ay]: [number, number],\n\t  angle: number,\n\t): [number, number] {\n\t  const theta = (angle * Math.PI) / 180;\n\t  const sin = Math.sin(theta);\n", "  const cos = Math.cos(theta);\n\t  const rx = x - ax;\n\t  const ry = y - ay;\n\t  return [round(ax + rx * cos - ry * sin), round(ay + ry * cos + rx * sin)];\n\t}\n\tfunction round(n: number): number {\n\t  return Math.round(n * 1000 + 0.001) / 1000;\n\t}\n\tfunction runTest(\n\t  name: string,\n", "  rotation: number,\n\t  interval: number,\n\t  heightTile: HeightTile,\n\t  expected: { [ele: number]: number[][] },\n\t) {\n\t  test(name, () => {\n\t    const size = heightTile.width;\n\t    const center = (size - 1) / 2;\n\t    const rotatedHeightTile = new HeightTile(\n\t      heightTile.width,\n", "      heightTile.height,\n\t      (x, y) => {\n\t        if (x < 0 || x >= size) {\n\t          throw new Error(`x=${x}`);\n\t        } else if (y < 0 || y >= size) {\n\t          throw new Error(`y=${y}`);\n\t        }\n\t        const [nx, ny] = rotate([x, y], [center, center], rotation).map(\n\t          round,\n\t        ) as [number, number];\n", "        return heightTile.get(nx, ny);\n\t      },\n\t    );\n\t    const isolines = generateIsolines(interval, rotatedHeightTile, 4096, 0);\n\t    const rotatedResult: { [ele: number]: number[][] } = {};\n\t    for (const ele in isolines) {\n\t      rotatedResult[ele] = isolines[ele].map((eles) => {\n\t        const rotatedLine: number[] = [...eles];\n\t        for (let i = 0; i < rotatedLine.length; i += 2) {\n\t          const [x, y] = rotate(\n", "            [\n\t              (rotatedLine[i] * (size - 1)) / 4096,\n\t              (rotatedLine[i + 1] * (size - 1)) / 4096,\n\t            ],\n\t            [center, center],\n\t            rotation,\n\t          );\n\t          rotatedLine[i] = x;\n\t          rotatedLine[i + 1] = y;\n\t        }\n", "        return rotatedLine;\n\t      });\n\t    }\n\t    expect(rotatedResult).toEqual(expected);\n\t  });\n\t}\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import {\n\t  CancelablePromise,\n\t  ContourTile,\n\t  DemTile,\n\t  GlobalContourTileOptions,\n\t  IndividualContourTileOptions,\n\t  TransferrableContourTile,\n\t  TransferrableDemTile,\n\t} from \"./types\";\n\tfunction sortedEntries(object: any): [string, any][] {\n", "  const entries = Object.entries(object);\n\t  entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0));\n\t  return entries;\n\t}\n\tfunction encodeThresholds(thresholds: {\n\t  [n: number]: number | number[];\n\t}): string {\n\t  return sortedEntries(thresholds)\n\t    .map(([key, value]) =>\n\t      [key, ...(typeof value === \"number\" ? [value] : value)].join(\"*\"),\n", "    )\n\t    .join(\"~\");\n\t}\n\tfunction decodeThresholds(thresholds: string): {\n\t  [n: number]: number | number[];\n\t} {\n\t  return Object.fromEntries(\n\t    thresholds\n\t      .split(\"~\")\n\t      .map((part) => part.split(\"*\").map(Number))\n", "      .map(([key, ...values]) => [key, values]),\n\t  );\n\t}\n\texport function encodeOptions({\n\t  thresholds,\n\t  ...rest\n\t}: GlobalContourTileOptions): string {\n\t  return sortedEntries({ thresholds: encodeThresholds(thresholds), ...rest })\n\t    .map(\n\t      ([key, value]) =>\n", "        `${encodeURIComponent(key)}=${encodeURIComponent(value)}`,\n\t    )\n\t    .join(\"&\");\n\t}\n\texport function decodeOptions(options: string): GlobalContourTileOptions {\n\t  return Object.fromEntries(\n\t    options\n\t      .replace(/^.*\\?/, \"\")\n\t      .split(\"&\")\n\t      .map((part) => {\n", "        const parts = part.split(\"=\").map(decodeURIComponent);\n\t        const k = parts[0] as keyof GlobalContourTileOptions;\n\t        let v: any = parts[1];\n\t        switch (k) {\n\t          case \"thresholds\":\n\t            v = decodeThresholds(v);\n\t            break;\n\t          case \"extent\":\n\t          case \"multiplier\":\n\t          case \"overzoom\":\n", "          case \"buffer\":\n\t            v = Number(v);\n\t        }\n\t        return [k, v];\n\t      }),\n\t  ) as any as GlobalContourTileOptions;\n\t}\n\texport function encodeIndividualOptions(\n\t  options: IndividualContourTileOptions,\n\t): string {\n", "  return sortedEntries(options)\n\t    .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n\t    .join(\",\");\n\t}\n\texport function getOptionsForZoom(\n\t  options: GlobalContourTileOptions,\n\t  zoom: number,\n\t): IndividualContourTileOptions {\n\t  const { thresholds, ...rest } = options;\n\t  let levels: number[] = [];\n", "  let maxLessThanOrEqualTo: number = -Infinity;\n\t  Object.entries(thresholds).forEach(([zString, value]) => {\n\t    const z = Number(zString);\n\t    if (z <= zoom && z > maxLessThanOrEqualTo) {\n\t      maxLessThanOrEqualTo = z;\n\t      levels = typeof value === \"number\" ? [value] : value;\n\t    }\n\t  });\n\t  return {\n\t    levels,\n", "    ...rest,\n\t  };\n\t}\n\texport function map<T, U>(\n\t  { cancel, value }: CancelablePromise<T>,\n\t  mapper: (t: T) => U,\n\t) {\n\t  return { cancel, value: value.then(mapper) };\n\t}\n\texport function copy(src: ArrayBuffer): ArrayBuffer {\n", "  const dst = new ArrayBuffer(src.byteLength);\n\t  new Uint8Array(dst).set(new Uint8Array(src));\n\t  return dst;\n\t}\n\texport function prepareDemTile(\n\t  promise: CancelablePromise<DemTile>,\n\t  copy: boolean,\n\t): CancelablePromise<TransferrableDemTile> {\n\t  return map(promise, ({ data, ...rest }) => {\n\t    let newData = data;\n", "    if (copy) {\n\t      newData = new Float32Array(data.length);\n\t      newData.set(data);\n\t    }\n\t    return { ...rest, data: newData, transferrables: [newData.buffer] };\n\t  });\n\t}\n\texport function prepareContourTile(\n\t  promise: CancelablePromise<ContourTile>,\n\t): CancelablePromise<TransferrableContourTile> {\n", "  return map(promise, ({ arrayBuffer }) => {\n\t    const clone = copy(arrayBuffer);\n\t    return {\n\t      arrayBuffer: clone,\n\t      transferrables: [clone],\n\t    };\n\t  });\n\t}\n\tlet supportsOffscreenCanvas: boolean | null = null;\n\texport function offscreenCanvasSupported(): boolean {\n", "  if (supportsOffscreenCanvas == null) {\n\t    supportsOffscreenCanvas =\n\t      typeof OffscreenCanvas !== \"undefined\" &&\n\t      new OffscreenCanvas(1, 1).getContext(\"2d\") &&\n\t      typeof createImageBitmap === \"function\";\n\t  }\n\t  return supportsOffscreenCanvas || false;\n\t}\n\texport function withTimeout<T>(\n\t  timeoutMs: number,\n", "  { value, cancel }: CancelablePromise<T>,\n\t): CancelablePromise<T> {\n\t  let reject: (error: Error) => void = () => {};\n\t  const timeout = setTimeout(() => {\n\t    cancel();\n\t    reject(new Error(\"timed out\"));\n\t  }, timeoutMs);\n\t  const cancelPromise: Promise<any> = new Promise((_, rej) => {\n\t    reject = rej;\n\t  });\n", "  return {\n\t    value: Promise.race([\n\t      cancelPromise,\n\t      (async () => {\n\t        try {\n\t          return await value;\n\t        } finally {\n\t          clearTimeout(timeout);\n\t        }\n\t      })(),\n", "    ]),\n\t    cancel: () => {\n\t      clearTimeout(timeout);\n\t      cancel();\n\t    },\n\t  };\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import generateIsolines from \"./isolines\";\n\timport { DemSource } from \"./dem-source\";\n\timport { decodeParsedImage } from \"./decode-image\";\n\timport { LocalDemManager } from \"./dem-manager\";\n\timport CONFIG from \"./config\";\n\timport { HeightTile } from \"./height-tile\";\n\tconst exported = {\n\t  generateIsolines,\n\t  DemSource,\n\t  HeightTile,\n", "  LocalDemManager,\n\t  decodeParsedImage,\n\t  set workerUrl(url: string) {\n\t    CONFIG.workerUrl = url;\n\t  },\n\t  get workerUrl() {\n\t    return CONFIG.workerUrl;\n\t  },\n\t};\n\texport default exported;\n"]}
{"filename": "src/actor.ts", "chunked_list": ["import { Timer } from \"./performance\";\n\timport { CancelablePromise, IsTransferrable, Timing } from \"./types\";\n\timport { withTimeout } from \"./utils\";\n\tlet id = 0;\n\tinterface Cancel {\n\t  type: \"cancel\";\n\t  id: number;\n\t}\n\tinterface Response {\n\t  type: \"response\";\n", "  id: number;\n\t  error?: string;\n\t  response?: any;\n\t  timings: Timing;\n\t}\n\tinterface Request {\n\t  type: \"request\";\n\t  id?: number;\n\t  name: string;\n\t  args: any[];\n", "}\n\ttype Message = Cancel | Response | Request;\n\ttype MethodsReturning<T, R> = {\n\t  [K in keyof T]: T[K] extends (...args: any) => R ? T[K] : never;\n\t};\n\t/**\n\t * Utility for sending messages to a remote instance of `<T>` running in a web worker\n\t * from the main thread, or in the main thread running from a web worker.\n\t */\n\texport default class Actor<T> {\n", "  callbacks: {\n\t    [id: number]: (\n\t      error: Error | undefined,\n\t      message: any,\n\t      timings: Timing,\n\t    ) => void;\n\t  };\n\t  cancels: { [id: number]: () => void };\n\t  dest: Worker;\n\t  timeoutMs: number;\n", "  constructor(dest: Worker, dispatcher: any, timeoutMs: number = 20_000) {\n\t    this.callbacks = {};\n\t    this.cancels = {};\n\t    this.dest = dest;\n\t    this.timeoutMs = timeoutMs;\n\t    this.dest.onmessage = async ({ data }) => {\n\t      const message: Message = data;\n\t      if (message.type === \"cancel\") {\n\t        const cancel = this.cancels[message.id];\n\t        delete this.cancels[message.id];\n", "        if (cancel) {\n\t          cancel();\n\t        }\n\t      } else if (message.type === \"response\") {\n\t        const callback = this.callbacks[message.id];\n\t        delete this.callbacks[message.id];\n\t        if (callback) {\n\t          callback(\n\t            message.error ? new Error(message.error) : undefined,\n\t            message.response,\n", "            message.timings,\n\t          );\n\t        }\n\t      } else if (message.type === \"request\") {\n\t        const timer = new Timer(\"worker\");\n\t        const handler: Function = (dispatcher as any)[message.name];\n\t        const request = handler.apply(handler, [...message.args, timer]);\n\t        const url = `${message.name}_${message.id}`;\n\t        if (message.id && request) {\n\t          this.cancels[message.id] = request.cancel;\n", "          try {\n\t            const response = await request.value;\n\t            const transferrables = (response as IsTransferrable)\n\t              ?.transferrables;\n\t            this.postMessage(\n\t              {\n\t                id: message.id,\n\t                type: \"response\",\n\t                response,\n\t                timings: timer.finish(url),\n", "              },\n\t              transferrables,\n\t            );\n\t          } catch (e: any) {\n\t            this.postMessage({\n\t              id: message.id,\n\t              type: \"response\",\n\t              error: e?.toString() || \"error\",\n\t              timings: timer.finish(url),\n\t            });\n", "          }\n\t          delete this.cancels[message.id];\n\t        }\n\t      }\n\t    };\n\t  }\n\t  postMessage(message: Message, transferrables?: Transferable[]) {\n\t    this.dest.postMessage(message, transferrables || []);\n\t  }\n\t  /** Invokes a method by name with a set of arguments in the remote context. */\n", "  send<\n\t    R,\n\t    M extends MethodsReturning<T, CancelablePromise<R>>,\n\t    K extends keyof M & string,\n\t    P extends Parameters<M[K]>,\n\t  >(\n\t    name: K,\n\t    transferrables: Transferable[],\n\t    timer?: Timer,\n\t    ...args: P\n", "  ): CancelablePromise<R> {\n\t    const thisId = ++id;\n\t    const value: Promise<R> = new Promise((resolve, reject) => {\n\t      this.postMessage(\n\t        { id: thisId, type: \"request\", name, args },\n\t        transferrables,\n\t      );\n\t      this.callbacks[thisId] = (error, result, timings) => {\n\t        timer?.addAll(timings);\n\t        if (error) reject(error);\n", "        else resolve(result);\n\t      };\n\t    });\n\t    return withTimeout(this.timeoutMs, {\n\t      value,\n\t      cancel: () => {\n\t        delete this.callbacks[thisId];\n\t        this.postMessage({ id: thisId, type: \"cancel\" });\n\t      },\n\t    });\n", "  }\n\t}\n"]}
{"filename": "src/height-tile.ts", "chunked_list": ["import { DemTile } from \"./types\";\n\tconst MIN_VALID_M = -12000;\n\tconst MAX_VALID_M = 9000;\n\tfunction defaultIsValid(number: number): boolean {\n\t  return !isNaN(number) && number >= MIN_VALID_M && number <= MAX_VALID_M;\n\t}\n\t/** A tile containing elevation values aligned to a grid. */\n\texport class HeightTile {\n\t  get: (x: number, y: number) => number;\n\t  width: number;\n", "  height: number;\n\t  constructor(\n\t    width: number,\n\t    height: number,\n\t    get: (x: number, y: number) => number,\n\t  ) {\n\t    this.get = get;\n\t    this.width = width;\n\t    this.height = height;\n\t  }\n", "  /** Construct a height tile from raw DEM pixel values */\n\t  static fromRawDem(demTile: DemTile): HeightTile {\n\t    return new HeightTile(demTile.width, demTile.height, (x, y) => {\n\t      const value = demTile.data[y * demTile.width + x];\n\t      return defaultIsValid(value) ? value : NaN;\n\t    });\n\t  }\n\t  /**\n\t   * Construct a height tile from a DEM tile plus it's 8 neighbors, so that\n\t   * you can request `x` or `y` outside the bounds of the original tile.\n", "   *\n\t   * @param neighbors An array containing tiles: `[nw, n, ne, w, c, e, sw, s, se]`\n\t   */\n\t  static combineNeighbors(\n\t    neighbors: (HeightTile | undefined)[],\n\t  ): HeightTile | undefined {\n\t    if (neighbors.length !== 9) {\n\t      throw new Error(\"Must include a tile plus 8 neighbors\");\n\t    }\n\t    const mainTile = neighbors[4];\n", "    if (!mainTile) {\n\t      return undefined;\n\t    }\n\t    const width = mainTile.width;\n\t    const height = mainTile.height;\n\t    return new HeightTile(width, height, (x, y) => {\n\t      let gridIdx = 0;\n\t      if (y < 0) {\n\t        y += height;\n\t      } else if (y < height) {\n", "        gridIdx += 3;\n\t      } else {\n\t        y -= height;\n\t        gridIdx += 6;\n\t      }\n\t      if (x < 0) {\n\t        x += width;\n\t      } else if (x < width) {\n\t        gridIdx += 1;\n\t      } else {\n", "        x -= width;\n\t        gridIdx += 2;\n\t      }\n\t      const grid = neighbors[gridIdx];\n\t      return grid ? grid.get(x, y) : NaN;\n\t    });\n\t  }\n\t  /**\n\t   * Splits this tile into a `1<<subz` x `1<<subz` grid and returns the tile at coordinates `subx, suby`.\n\t   */\n", "  split = (subz: number, subx: number, suby: number): HeightTile => {\n\t    if (subz === 0) return this;\n\t    const by = 1 << subz;\n\t    const dx = (subx * this.width) / by;\n\t    const dy = (suby * this.height) / by;\n\t    return new HeightTile(this.width / by, this.height / by, (x, y) =>\n\t      this.get(x + dx, y + dy),\n\t    );\n\t  };\n\t  /**\n", "   * Returns a new tile scaled up by `factor` with pixel values that are subsampled using\n\t   * bilinear interpolation between the original height tile values.\n\t   *\n\t   * The original and result tile are assumed to represent values taken at the center of each pixel.\n\t   */\n\t  subsamplePixelCenters = (factor: number): HeightTile => {\n\t    const lerp = (a: number, b: number, f: number) =>\n\t      isNaN(a) ? b : isNaN(b) ? a : a + (b - a) * f;\n\t    if (factor <= 1) return this;\n\t    const sub = 0.5 - 1 / (2 * factor);\n", "    const blerper = (x: number, y: number) => {\n\t      const dx = x / factor - sub;\n\t      const dy = y / factor - sub;\n\t      const ox = Math.floor(dx);\n\t      const oy = Math.floor(dy);\n\t      const a = this.get(ox, oy);\n\t      const b = this.get(ox + 1, oy);\n\t      const c = this.get(ox, oy + 1);\n\t      const d = this.get(ox + 1, oy + 1);\n\t      const fx = dx - ox;\n", "      const fy = dy - oy;\n\t      const top = lerp(a, b, fx);\n\t      const bottom = lerp(c, d, fx);\n\t      return lerp(top, bottom, fy);\n\t    };\n\t    return new HeightTile(this.width * factor, this.height * factor, blerper);\n\t  };\n\t  /**\n\t   * Assumes the input tile represented measurements taken at the center of each pixel, and\n\t   * returns a new tile where values are the height at the top-left of each pixel by averaging\n", "   * the 4 adjacent pixel values.\n\t   */\n\t  averagePixelCentersToGrid = (radius: number = 1): HeightTile =>\n\t    new HeightTile(this.width + 1, this.height + 1, (x, y) => {\n\t      let sum = 0,\n\t        count = 0,\n\t        v = 0;\n\t      for (let newX = x - radius; newX < x + radius; newX++) {\n\t        for (let newY = y - radius; newY < y + radius; newY++) {\n\t          if (!isNaN((v = this.get(newX, newY)))) {\n", "            count++;\n\t            sum += v;\n\t          }\n\t        }\n\t      }\n\t      return count === 0 ? NaN : sum / count;\n\t    });\n\t  /** Returns a new tile with elevation values scaled by `multiplier`. */\n\t  scaleElevation = (multiplier: number): HeightTile =>\n\t    multiplier === 1\n", "      ? this\n\t      : new HeightTile(\n\t          this.width,\n\t          this.height,\n\t          (x, y) => this.get(x, y) * multiplier,\n\t        );\n\t  /**\n\t   * Precompute every value from `-bufer, -buffer` to `width + buffer, height + buffer` and serve them\n\t   * out of a `Float32Array`. Until this method is called, all `get` requests are lazy and call all previous\n\t   * methods in the chain up to the root DEM tile.\n", "   */\n\t  materialize = (buffer: number = 2): HeightTile => {\n\t    const stride = this.width + 2 * buffer;\n\t    const data = new Float32Array(stride * (this.height + 2 * buffer));\n\t    let idx = 0;\n\t    for (let y = -buffer; y < this.height + buffer; y++) {\n\t      for (let x = -buffer; x < this.width + buffer; x++) {\n\t        data[idx++] = this.get(x, y);\n\t      }\n\t    }\n", "    return new HeightTile(\n\t      this.width,\n\t      this.height,\n\t      (x, y) => data[(y + buffer) * stride + x + buffer],\n\t    );\n\t  };\n\t}\n"]}
{"filename": "src/setup-jest.ts", "chunked_list": ["import \"whatwg-fetch\";\n\tglobal.fetch = jest.fn();\n\tperformance.now = () => Date.now();\n"]}
{"filename": "src/dem-source.ts", "chunked_list": ["import { DemManager, LocalDemManager } from \"./dem-manager\";\n\timport { decodeOptions, encodeOptions, getOptionsForZoom } from \"./utils\";\n\timport RemoteDemManager from \"./remote-dem-manager\";\n\timport { DemTile, Cancelable, GlobalContourTileOptions, Timing } from \"./types\";\n\timport type WorkerDispatch from \"./worker-dispatch\";\n\timport Actor from \"./actor\";\n\timport { Timer } from \"./performance\";\n\tif (!Blob.prototype.arrayBuffer) {\n\t  Blob.prototype.arrayBuffer = function arrayBuffer() {\n\t    return new Promise<ArrayBuffer>((resolve, reject) => {\n", "      const fileReader = new FileReader();\n\t      fileReader.onload = (event) =>\n\t        resolve(event.target?.result as ArrayBuffer);\n\t      fileReader.onerror = reject;\n\t      fileReader.readAsArrayBuffer(this);\n\t    });\n\t  };\n\t}\n\t// for maplibre interop\n\ttype RequestParameters = {\n", "  url: string;\n\t  headers?: any;\n\t  method?: \"GET\" | \"POST\" | \"PUT\";\n\t  body?: string;\n\t  type?: \"string\" | \"json\" | \"arrayBuffer\";\n\t  credentials?: \"same-origin\" | \"include\";\n\t  collectResourceTiming?: boolean;\n\t};\n\ttype ResponseCallback = (\n\t  error?: Error | undefined,\n", "  data?: any | undefined,\n\t  cacheControl?: string | undefined,\n\t  expires?: string | undefined,\n\t) => void;\n\ttype Protocol = (\n\t  request: RequestParameters,\n\t  response: ResponseCallback,\n\t) => Cancelable;\n\tconst used = new Set<string>();\n\t/**\n", " * A remote source of DEM tiles that can be connected to maplibre.\n\t */\n\texport class DemSource {\n\t  sharedDemProtocolId: string;\n\t  contourProtocolId: string;\n\t  contourProtocolUrlBase: string;\n\t  manager: DemManager;\n\t  sharedDemProtocolUrl: string;\n\t  timingCallbacks: Array<(timing: Timing) => void> = [];\n\t  constructor({\n", "    url,\n\t    cacheSize = 100,\n\t    id = \"dem\",\n\t    encoding = \"terrarium\",\n\t    maxzoom = 12,\n\t    worker = true,\n\t    timeoutMs = 10_000,\n\t    actor,\n\t  }: {\n\t    /** Remote DEM tile url using `{z}` `{x}` and `{y}` placeholders */\n", "    url: string;\n\t    /** Number of most-recently-used tiles to cache */\n\t    cacheSize?: number;\n\t    /** Prefix for the maplibre protocol */\n\t    id?: string;\n\t    encoding?: \"terrarium\" | \"mapbox\";\n\t    /** Maximum zoom of tiles contained in the source */\n\t    maxzoom: number;\n\t    timeoutMs?: number;\n\t    /** Handle requests in a shared web worker to reduce UI-thread jank */\n", "    worker?: boolean;\n\t    actor?: Actor<WorkerDispatch>;\n\t  }) {\n\t    let protocolPrefix = id;\n\t    let i = 1;\n\t    while (used.has(protocolPrefix)) {\n\t      protocolPrefix = id + i++;\n\t    }\n\t    used.add(protocolPrefix);\n\t    this.sharedDemProtocolId = `${protocolPrefix}-shared`;\n", "    this.contourProtocolId = `${protocolPrefix}-contour`;\n\t    this.sharedDemProtocolUrl = `${this.sharedDemProtocolId}://{z}/{x}/{y}`;\n\t    this.contourProtocolUrlBase = `${this.contourProtocolId}://{z}/{x}/{y}`;\n\t    const ManagerClass = worker ? RemoteDemManager : LocalDemManager;\n\t    this.manager = new ManagerClass(\n\t      url,\n\t      cacheSize,\n\t      encoding,\n\t      maxzoom,\n\t      timeoutMs,\n", "      actor,\n\t    );\n\t  }\n\t  /** Registers a callback to be invoked with a performance report after each tile is requested. */\n\t  onTiming = (callback: (timing: Timing) => void) => {\n\t    this.timingCallbacks.push(callback);\n\t  };\n\t  getDemTile(z: number, x: number, y: number): Promise<DemTile> {\n\t    return this.manager.fetchAndParseTile(z, x, y).value;\n\t  }\n", "  /**\n\t   * Adds contour and shared DEM protocol handlers to maplibre.\n\t   *\n\t   * @param maplibre maplibre global object\n\t   */\n\t  setupMaplibre = (maplibre: {\n\t    addProtocol: (id: string, protcol: Protocol) => void;\n\t  }) => {\n\t    maplibre.addProtocol(this.sharedDemProtocolId, this.sharedDemProtocol);\n\t    maplibre.addProtocol(this.contourProtocolId, this.contourProtocol);\n", "  };\n\t  parseUrl(url: string): [number, number, number] {\n\t    const [, z, x, y] = /\\/\\/(\\d+)\\/(\\d+)\\/(\\d+)/.exec(url) || [];\n\t    return [Number(z), Number(x), Number(y)];\n\t  }\n\t  /**\n\t   * Callback to be used with maplibre addProtocol to re-use cached DEM tiles across sources.\n\t   */\n\t  sharedDemProtocol = (\n\t    request: RequestParameters,\n", "    response: ResponseCallback,\n\t  ): Cancelable => {\n\t    const [z, x, y] = this.parseUrl(request.url);\n\t    const timer = new Timer(\"main\");\n\t    const result = this.manager.fetchTile(z, x, y, timer);\n\t    let canceled = false;\n\t    (async () => {\n\t      let timing: Timing;\n\t      try {\n\t        const data = await result.value;\n", "        timing = timer.finish(request.url);\n\t        if (canceled) return;\n\t        const arrayBuffer: ArrayBuffer = await data.data.arrayBuffer();\n\t        if (canceled) return;\n\t        response(undefined, arrayBuffer, data.cacheControl, data.expires);\n\t      } catch (error) {\n\t        timing = timer.error(request.url);\n\t        if (canceled) return;\n\t        response(error as Error);\n\t      }\n", "      this.timingCallbacks.forEach((cb) => cb(timing));\n\t    })();\n\t    return {\n\t      cancel: () => {\n\t        canceled = false;\n\t        result.cancel();\n\t      },\n\t    };\n\t  };\n\t  /**\n", "   * Callback to be used with maplibre addProtocol to generate contour vector tiles according\n\t   * to options encoded in the tile URL pattern generated by `contourProtocolUrl`.\n\t   */\n\t  contourProtocol = (\n\t    request: RequestParameters,\n\t    response: ResponseCallback,\n\t  ): Cancelable => {\n\t    const timer = new Timer(\"main\");\n\t    const [z, x, y] = this.parseUrl(request.url);\n\t    const options = decodeOptions(request.url);\n", "    const result = this.manager.fetchContourTile(\n\t      z,\n\t      x,\n\t      y,\n\t      getOptionsForZoom(options, z),\n\t      timer,\n\t    );\n\t    let canceled = false;\n\t    (async () => {\n\t      let timing: Timing;\n", "      try {\n\t        const data = await result.value;\n\t        timing = timer.finish(request.url);\n\t        if (canceled) return;\n\t        response(undefined, data.arrayBuffer);\n\t      } catch (error) {\n\t        if (canceled) return;\n\t        timing = timer.error(request.url);\n\t        response(error as Error);\n\t      }\n", "      this.timingCallbacks.forEach((cb) => cb(timing));\n\t    })();\n\t    return {\n\t      cancel: () => {\n\t        canceled = true;\n\t        result.cancel();\n\t      },\n\t    };\n\t  };\n\t  /**\n", "   * Returns a URL with the correct maplibre protocol prefix and all `option` encoded in request parameters.\n\t   */\n\t  contourProtocolUrl = (options: GlobalContourTileOptions) =>\n\t    `${this.contourProtocolUrlBase}?${encodeOptions(options)}`;\n\t}\n"]}
{"filename": "src/e2e.test.ts", "chunked_list": ["import { flattenDeep } from \"lodash\";\n\timport Actor from \"./actor\";\n\timport WorkerDispatch from \"./worker-dispatch\";\n\timport { DemSource } from \"./dem-source\";\n\timport { MainThreadDispatch } from \"./remote-dem-manager\";\n\timport { CancelablePromise, DemTile, Timing } from \"./types\";\n\timport { VectorTile } from \"@mapbox/vector-tile\";\n\timport Pbf from \"pbf\";\n\tbeforeEach(() => {\n\t  jest.useFakeTimers({ now: 0, doNotFake: [\"performance\"] });\n", "});\n\tafterEach(() => {\n\t  jest.useRealTimers();\n\t});\n\tjest.mock(\"./decode-image\", () => (): CancelablePromise<DemTile> => {\n\t  jest.advanceTimersByTime(1);\n\t  // eslint-disable-next-line global-require\n\t  const flattenDeep = require(\"lodash/flattenDeep\");\n\t  const value: DemTile = {\n\t    data: Float32Array.from(\n", "      flattenDeep([\n\t        [5, 5, 5, 5],\n\t        [5, 15, 15, 5],\n\t        [5, 15, 15, 5],\n\t        [5, 5, 5, 5],\n\t      ]),\n\t    ),\n\t    width: 4,\n\t    height: 4,\n\t  };\n", "  return { value: Promise.resolve(value), cancel() {} };\n\t});\n\tconst remote = new WorkerDispatch();\n\tconst local = new MainThreadDispatch();\n\tconst workerFromMainThread: Worker = {} as any as Worker;\n\tconst mainThreadFromWorker: Worker = {} as any as Worker;\n\tworkerFromMainThread.postMessage = (data) =>\n\t  mainThreadFromWorker?.onmessage?.({ data } as any);\n\tmainThreadFromWorker.postMessage = (data) =>\n\t  workerFromMainThread?.onmessage?.({ data } as any);\n", "const mainActor = new Actor<WorkerDispatch>(workerFromMainThread, local);\n\tconst workerActor = new Actor<MainThreadDispatch>(mainThreadFromWorker, remote);\n\tconst source = new DemSource({\n\t  url: \"https://example/{z}/{x}/{y}.png\",\n\t  cacheSize: 100,\n\t  encoding: \"terrarium\",\n\t  maxzoom: 11,\n\t  worker: true,\n\t  actor: mainActor,\n\t});\n", "const expectedElevations = Float32Array.from(\n\t  flattenDeep([\n\t    [5, 5, 5, 5],\n\t    [5, 15, 15, 5],\n\t    [5, 15, 15, 5],\n\t    [5, 5, 5, 5],\n\t  ]),\n\t);\n\ttest(\"e2e fetch tile and shared DEM protocol share cache\", async () => {\n\t  global.fetch = jest.fn().mockImplementation(async () => {\n", "    jest.advanceTimersByTime(1);\n\t    return new Response(\n\t      new Blob([Uint8Array.from([1, 2])], { type: \"image/png\" }),\n\t      {\n\t        status: 200,\n\t      },\n\t    );\n\t  });\n\t  const tile = await source.getDemTile(1, 2, 3);\n\t  expect(tile.data).toEqual(expectedElevations);\n", "  expect(tile.width).toBe(4);\n\t  expect(tile.height).toBe(4);\n\t  const tile2 = await source.getDemTile(1, 2, 3);\n\t  expect(tile2.data).toEqual(expectedElevations);\n\t  const timings: Timing[] = [];\n\t  source.onTiming((timing) => timings.push(timing));\n\t  const fetched = await new Promise((resolve, reject) => {\n\t    source.sharedDemProtocol(\n\t      {\n\t        url: source.sharedDemProtocolUrl\n", "          .replace(\"{z}\", \"1\")\n\t          .replace(\"{x}\", \"2\")\n\t          .replace(\"{y}\", \"3\"),\n\t      },\n\t      (err, data) => {\n\t        if (err) reject(err);\n\t        else resolve(data);\n\t      },\n\t    );\n\t  });\n", "  expect(fetched).toEqual(Uint8Array.from([1, 2]).buffer);\n\t  expect(global.fetch).toBeCalledTimes(1);\n\t  expect(global.fetch).toBeCalledWith(\n\t    \"https://example/1/2/3.png\",\n\t    expect.anything(),\n\t  );\n\t  expect(timings).toMatchObject([\n\t    {\n\t      duration: 0,\n\t      marks: {\n", "        main: [[2, 2]],\n\t        worker: [[2, 2]],\n\t      },\n\t      resources: [],\n\t      url: \"dem-shared://1/2/3\",\n\t      wait: 0,\n\t    },\n\t  ]);\n\t});\n\ttest(\"e2e contour tile\", async () => {\n", "  global.fetch = jest.fn().mockImplementation(async () => {\n\t    jest.advanceTimersByTime(1);\n\t    return new Response(\n\t      new Blob([Uint8Array.from([1, 2])], { type: \"image/png\" }),\n\t      {\n\t        status: 200,\n\t      },\n\t    );\n\t  });\n\t  const timings: Timing[] = [];\n", "  source.onTiming((timing) => timings.push(timing));\n\t  const contourTile: ArrayBuffer = await new Promise((resolve, reject) => {\n\t    source.contourProtocol(\n\t      {\n\t        url: source\n\t          .contourProtocolUrl({\n\t            thresholds: {\n\t              10: 10,\n\t            },\n\t            buffer: 0,\n", "            contourLayer: \"c\",\n\t            elevationKey: \"e\",\n\t            levelKey: \"l\",\n\t            overzoom: 0,\n\t          })\n\t          .replace(\"{z}\", \"10\")\n\t          .replace(\"{x}\", \"20\")\n\t          .replace(\"{y}\", \"30\"),\n\t      },\n\t      (err, data) => {\n", "        if (err) reject(err);\n\t        else resolve(data);\n\t      },\n\t    );\n\t  });\n\t  const tile = new VectorTile(new Pbf(contourTile));\n\t  expect(tile.layers.c.name).toBe(\"c\");\n\t  expect(tile.layers.c.extent).toBe(4096);\n\t  expect(tile.layers.c.length).toBe(1);\n\t  expect(tile.layers.c.feature(0).properties).toEqual({\n", "    e: 10,\n\t    l: 0,\n\t  });\n\t  const geom = tile.layers.c.feature(0).loadGeometry()[0];\n\t  expect(geom.length).toEqual(253);\n\t  let xSum = 0,\n\t    ySum = 0;\n\t  for (const { x, y } of geom) {\n\t    xSum += x;\n\t    ySum += y;\n", "  }\n\t  const center = { x: Math.round(xSum / 253), y: Math.round(ySum / 253) };\n\t  expect(center).toMatchObject({\n\t    x: 2049,\n\t    y: 2052,\n\t  });\n\t  expect(timings).toMatchObject([\n\t    {\n\t      tilesUsed: 9,\n\t      process: 0,\n", "      duration: 18,\n\t      marks: {\n\t        main: [[0, 18]],\n\t        worker: [[0, 18]],\n\t        fetch: [\n\t          [0, 9],\n\t          [1, 9],\n\t          [2, 9],\n\t          [3, 9],\n\t          [4, 9],\n", "          [5, 9],\n\t          [6, 9],\n\t          [7, 9],\n\t          [8, 9],\n\t        ],\n\t        decode: [\n\t          [10, 18],\n\t          [11, 18],\n\t          [12, 18],\n\t          [13, 18],\n", "          [14, 18],\n\t          [15, 18],\n\t          [16, 18],\n\t          [17, 18],\n\t          [18, 18],\n\t        ],\n\t        isoline: [[18, 18, 18]],\n\t      },\n\t      decode: 8,\n\t      fetch: 9,\n", "      resources: [],\n\t      url: \"dem-contour://10/20/30?buffer=0&contourLayer=c&elevationKey=e&levelKey=l&overzoom=0&thresholds=10*10\",\n\t      wait: 1,\n\t    },\n\t  ]);\n\t  // fetch adjacent tile where 6/9 neighbors are already cached\n\t  jest.setSystemTime(1);\n\t  performance.getEntriesByName = (name) => [\n\t    {\n\t      duration: 1,\n", "      name,\n\t      entryType: \"resource\",\n\t      startTime: performance.now(),\n\t    } as PerformanceResourceTiming,\n\t  ];\n\t  await new Promise((resolve, reject) => {\n\t    source.contourProtocol(\n\t      {\n\t        url: source\n\t          .contourProtocolUrl({\n", "            thresholds: {\n\t              10: 10,\n\t            },\n\t            overzoom: 0,\n\t          })\n\t          .replace(\"{z}\", \"10\")\n\t          .replace(\"{x}\", \"21\")\n\t          .replace(\"{y}\", \"30\"),\n\t      },\n\t      (err, data) => {\n", "        if (err) reject(err);\n\t        else resolve(data);\n\t      },\n\t    );\n\t  });\n\t  expect(timings[1]).toMatchObject({\n\t    tilesUsed: 9,\n\t    process: 0,\n\t    duration: 6,\n\t    decode: 2,\n", "    fetch: 3,\n\t    wait: 1,\n\t    marks: {\n\t      main: [[1, 7]],\n\t      worker: [[1, 7]],\n\t      fetch: [\n\t        [1, 4],\n\t        [2, 4],\n\t        [3, 4],\n\t      ],\n", "      decode: [\n\t        [5, 7],\n\t        [6, 7],\n\t        [7, 7],\n\t      ],\n\t      isoline: [[7, 7, 7]],\n\t    },\n\t    resources: [\n\t      { duration: 1, startTime: 7, name: \"https://example/10/22/29.png\" },\n\t      { duration: 1, startTime: 7, name: \"https://example/10/22/30.png\" },\n", "      { duration: 1, startTime: 7, name: \"https://example/10/22/31.png\" },\n\t    ],\n\t    url: \"dem-contour://10/21/30?overzoom=0&thresholds=10*10\",\n\t  });\n\t});\n\ttest(\"decode image from worker\", async () => {\n\t  const result = await workerActor.send(\n\t    \"decodeImage\",\n\t    [],\n\t    undefined,\n", "    new Blob([], { type: \"image/png\" }),\n\t    \"terrarium\",\n\t  ).value;\n\t  expect(result).toMatchObject({\n\t    width: 4,\n\t    height: 4,\n\t    data: expectedElevations,\n\t  });\n\t});\n"]}
{"filename": "src/utils.test.ts", "chunked_list": ["import {\n\t  GlobalContourTileOptions,\n\t  IndividualContourTileOptions,\n\t} from \"./types\";\n\timport {\n\t  decodeOptions,\n\t  encodeIndividualOptions,\n\t  encodeOptions,\n\t  getOptionsForZoom,\n\t  withTimeout,\n", "} from \"./utils\";\n\tconst fullGlobalOptions: GlobalContourTileOptions = {\n\t  thresholds: {\n\t    10: 500,\n\t    11: [100, 1000],\n\t  },\n\t  contourLayer: \"contour layer\",\n\t  elevationKey: \"elevation key\",\n\t  extent: 123,\n\t  buffer: 1,\n", "  levelKey: \"level key\",\n\t  multiplier: 123,\n\t  overzoom: 3,\n\t};\n\tconst fullGlobalOptionsOut: GlobalContourTileOptions = {\n\t  ...fullGlobalOptions,\n\t  thresholds: {\n\t    10: [500],\n\t    11: [100, 1000],\n\t  },\n", "};\n\tbeforeEach(() => {\n\t  jest.useFakeTimers();\n\t});\n\tafterEach(() => {\n\t  jest.clearAllTimers();\n\t});\n\ttest(\"parse known ContourTileOptions\", () => {\n\t  expect(\n\t    decodeOptions(\n", "      \"buffer=1&contourLayer=contour%20layer&elevationKey=elevation%20key&extent=123&levelKey=level%20key&multiplier=123&overzoom=3&thresholds=10*500~11*100*1000\",\n\t    ),\n\t  ).toEqual(fullGlobalOptionsOut);\n\t});\n\ttest(\"round-trip ContourTileOptions\", () => {\n\t  expect(\n\t    decodeOptions(`example.com?${encodeOptions(fullGlobalOptions)}`),\n\t  ).toEqual(fullGlobalOptionsOut);\n\t});\n\ttest(\"round-trip minimal ContourTileOptions\", () => {\n", "  const options: GlobalContourTileOptions = {\n\t    thresholds: {\n\t      10: [500],\n\t      11: [100, 1000],\n\t    },\n\t  };\n\t  expect(decodeOptions(encodeOptions(options))).toEqual(options);\n\t});\n\ttest(\"extract levels from global contour options\", () => {\n\t  // eslint-disable-next-line\n", "  const { thresholds, ...rest } = fullGlobalOptions;\n\t  expect(getOptionsForZoom(fullGlobalOptions, 9)).toEqual({\n\t    ...rest,\n\t    levels: [],\n\t  });\n\t  expect(getOptionsForZoom(fullGlobalOptions, 10)).toEqual({\n\t    ...rest,\n\t    levels: [500],\n\t  });\n\t  expect(getOptionsForZoom(fullGlobalOptions, 11)).toEqual({\n", "    ...rest,\n\t    levels: [100, 1000],\n\t  });\n\t  expect(getOptionsForZoom(fullGlobalOptions, 12)).toEqual({\n\t    ...rest,\n\t    levels: [100, 1000],\n\t  });\n\t});\n\ttest(\"encode individual options\", () => {\n\t  const options: IndividualContourTileOptions = {\n", "    levels: [1, 2],\n\t    contourLayer: \"contour layer\",\n\t    elevationKey: \"elevation key\",\n\t    extent: 123,\n\t    levelKey: \"level key\",\n\t    multiplier: 123,\n\t    overzoom: 3,\n\t  };\n\t  const origEncoded = encodeIndividualOptions(options);\n\t  expect(encodeIndividualOptions(options)).toBe(origEncoded);\n", "  for (const key in options) {\n\t    const updated: any = { ...options };\n\t    delete updated[key];\n\t    const newEncode = encodeIndividualOptions(updated);\n\t    expect(encodeIndividualOptions(updated)).toBe(newEncode);\n\t    expect(encodeIndividualOptions(updated)).not.toBe(origEncoded);\n\t  }\n\t});\n\ttest(\"withTimeout - times out\", async () => {\n\t  const cancel = jest.fn();\n", "  const result = withTimeout(1000, {\n\t    value: new Promise(() => {}),\n\t    cancel,\n\t  });\n\t  jest.advanceTimersByTime(999);\n\t  expect(cancel).not.toBeCalled();\n\t  jest.advanceTimersByTime(2);\n\t  expect(cancel).toBeCalledTimes(1);\n\t  await expect(result.value).rejects.toThrow(new Error(\"timed out\"));\n\t});\n", "test(\"withTimeout - resolve cancels timer\", async () => {\n\t  const cancel = jest.fn();\n\t  const result = withTimeout(1000, {\n\t    value: Promise.resolve(true),\n\t    cancel,\n\t  });\n\t  await expect(result.value).resolves.toBe(true);\n\t  jest.advanceTimersByTime(10_000);\n\t  expect(cancel).not.toBeCalled();\n\t  await expect(result.value).resolves.toBe(true);\n", "});\n\ttest(\"withTimeout - reject cancels timer\", async () => {\n\t  const cancel = jest.fn();\n\t  const error = new Error(\"rejected\");\n\t  const result = withTimeout(1000, {\n\t    value: Promise.reject(error),\n\t    cancel,\n\t  });\n\t  await expect(result.value).rejects.toBe(error);\n\t  jest.advanceTimersByTime(10_000);\n", "  expect(cancel).not.toBeCalled();\n\t  await expect(result.value).rejects.toBe(error);\n\t});\n\ttest(\"withTimeout - cancel cancels timer\", async () => {\n\t  const cancel = jest.fn();\n\t  const result = withTimeout(1000, {\n\t    value: new Promise(() => {}),\n\t    cancel,\n\t  });\n\t  result.cancel();\n", "  expect(cancel).toBeCalledTimes(1);\n\t  jest.advanceTimersByTime(10_000);\n\t  expect(cancel).toBeCalledTimes(1);\n\t});\n"]}
{"filename": "src/cache.ts", "chunked_list": ["import { CancelablePromise } from \"./types\";\n\tinterface CacheItem<V> {\n\t  lastUsed: number;\n\t  waiting: number;\n\t  cancel?: () => void;\n\t  item: Promise<V>;\n\t}\n\tlet num = 0;\n\t/**\n\t * LRU Cache for CancelablePromises.\n", " * The underlying request is only canceled when all callers have canceled their usage of it.\n\t */\n\texport default class AsyncCache<K, V> {\n\t  maxSize: number;\n\t  items: Map<K, CacheItem<V>>;\n\t  constructor(maxSize: number = 100) {\n\t    this.maxSize = maxSize;\n\t    this.items = new Map<K, CacheItem<V>>();\n\t  }\n\t  size = () => this.items.size;\n", "  get = (key: K, supplier: (key: K) => Promise<V>): Promise<V> =>\n\t    this.getCancelable(key, (key) => ({\n\t      value: supplier(key),\n\t      cancel: () => {},\n\t    })).value;\n\t  getCancelable = (\n\t    key: K,\n\t    supplier: (key: K) => CancelablePromise<V>,\n\t  ): { value: Promise<V>; cancel: () => void } => {\n\t    let result: CacheItem<V> | undefined = this.items.get(key);\n", "    if (!result) {\n\t      const value = supplier(key);\n\t      result = {\n\t        cancel: value.cancel,\n\t        item: value.value,\n\t        lastUsed: ++num,\n\t        waiting: 1,\n\t      };\n\t      this.items.set(key, result);\n\t      this.prune();\n", "    } else {\n\t      result.lastUsed = ++num;\n\t      result.waiting++;\n\t    }\n\t    const items = this.items;\n\t    const value = result.item.then(\n\t      (r) => r,\n\t      (e) => {\n\t        items.delete(key);\n\t        return Promise.reject(e);\n", "      },\n\t    );\n\t    let canceled = false;\n\t    return {\n\t      value,\n\t      cancel: () => {\n\t        if (result && result.cancel && !canceled) {\n\t          canceled = true;\n\t          if (--result.waiting <= 0) {\n\t            result.cancel();\n", "            items.delete(key);\n\t          }\n\t        }\n\t      },\n\t    };\n\t  };\n\t  prune() {\n\t    if (this.items.size > this.maxSize) {\n\t      let minKey: K | undefined;\n\t      let minUse = Infinity;\n", "      this.items.forEach((value, key) => {\n\t        if (value.lastUsed < minUse) {\n\t          minUse = value.lastUsed;\n\t          minKey = key;\n\t        }\n\t      });\n\t      if (typeof minKey !== \"undefined\") {\n\t        this.items.delete(minKey);\n\t      }\n\t    }\n", "  }\n\t  clear = () => this.items.clear();\n\t}\n"]}
{"filename": "src/cache.test.ts", "chunked_list": ["import AsyncCache from \"./cache\";\n\ttest(\"get()\", async () => {\n\t  const requests: { [_: string]: any } = {};\n\t  const cache = new AsyncCache<number, number>(2);\n\t  const getter = async (k: number) => {\n\t    requests[k] = (requests[k] || 0) + 1;\n\t    return k + 1;\n\t  };\n\t  expect(await cache.get(1, getter)).toBe(2);\n\t  expect(await cache.get(1, getter)).toBe(2);\n", "  expect(requests).toEqual({ 1: 1 });\n\t  expect(await cache.get(2, getter)).toBe(3);\n\t  expect(await cache.get(2, getter)).toBe(3);\n\t  expect(await cache.get(1, getter)).toBe(2);\n\t  expect(requests).toEqual({ 1: 1, 2: 1 });\n\t  // prunes 2 (not 1) because 2 was most recently accessed\n\t  expect(await cache.get(3, getter)).toBe(4);\n\t  expect(await cache.get(3, getter)).toBe(4);\n\t  expect(await cache.get(1, getter)).toBe(2);\n\t  expect(await cache.get(2, getter)).toBe(3);\n", "  expect(requests).toEqual({ 1: 1, 2: 2, 3: 1 });\n\t});\n\ttest(\"getCancelable()\", () => {\n\t  let canceledFirst = false;\n\t  let canceledOthers = false;\n\t  const cache = new AsyncCache(2);\n\t  const result1 = cache.getCancelable(1, () => ({\n\t    value: new Promise(() => {}),\n\t    cancel: () => {\n\t      canceledFirst = true;\n", "    },\n\t  }));\n\t  const result2 = cache.getCancelable(1, () => ({\n\t    value: new Promise(() => {}),\n\t    cancel: () => {\n\t      canceledOthers = true;\n\t    },\n\t  }));\n\t  const result3 = cache.getCancelable(1, () => ({\n\t    value: new Promise(() => {}),\n", "    cancel: () => {\n\t      canceledOthers = true;\n\t    },\n\t  }));\n\t  expect(canceledFirst).toBeFalsy();\n\t  expect(cache.size()).toBe(1);\n\t  result1.cancel();\n\t  expect(canceledFirst).toBeFalsy();\n\t  expect(cache.size()).toBe(1);\n\t  result2.cancel();\n", "  expect(canceledFirst).toBeFalsy();\n\t  expect(cache.size()).toBe(1);\n\t  result3.cancel();\n\t  expect(canceledFirst).toBeTruthy();\n\t  expect(canceledOthers).toBeFalsy();\n\t  expect(cache.size()).toBe(0);\n\t});\n\ttest(\"dont cache failures\", async () => {\n\t  const cache = new AsyncCache(2);\n\t  let reject: (e: Error) => void = () => {};\n", "  const result = cache.getCancelable(1, () => ({\n\t    value: new Promise((_, rej) => {\n\t      reject = rej;\n\t    }),\n\t    cancel: () => {\n\t      throw new Error();\n\t    },\n\t  }));\n\t  const error = new Error();\n\t  reject(error);\n", "  await expect(result.value).rejects.toThrow(error);\n\t  let resolve: (any: any) => void = () => {};\n\t  const result2 = cache.getCancelable(1, () => ({\n\t    value: new Promise((res) => {\n\t      resolve = res;\n\t    }),\n\t    cancel: () => {\n\t      throw new Error();\n\t    },\n\t  }));\n", "  resolve(\"ok!\");\n\t  await expect(result2.value).resolves.toBe(\"ok!\");\n\t});\n"]}
