{"filename": "src/useSelector.ts", "chunked_list": ["import { useContext, useLayoutEffect, useReducer, useRef } from 'react';\n\timport Context from './context';\n\timport { IContext } from './context/types';\n\timport defaultStore from './store/Store';\n\t//TODO\n\texport const createSelectorHook = <T>(context = Context) => {\n\t  return function useSelector<S extends T>(selector: (state: S) => unknown) {\n\t    const { store = defaultStore } = useContext<IContext>(context); //as { store: IStore<S> }\n\t    const [, forceRender] = useReducer((s) => s + 1, 0);\n\t    const latestState = useRef<unknown>();\n", "    useLayoutEffect(() => {\n\t      const subscribe = store.subscribe(() => {\n\t        const newState = selector(store.getState() as unknown as S);\n\t        if (latestState.current === newState) {\n\t          return;\n\t        }\n\t        latestState.current = newState;\n\t        forceRender();\n\t      });\n\t      return () => {\n", "        subscribe();\n\t      };\n\t    });\n\t    return selector(store.getState() as unknown as S);\n\t  };\n\t};\n\texport default createSelectorHook();\n"]}
{"filename": "src/useStore.ts", "chunked_list": ["import { useContext } from 'react';\n\timport Context from './context';\n\texport function createStoreHook(context = Context) {\n\t  return function useStore() {\n\t    const { store } = useContext(context);\n\t    return store;\n\t  };\n\t}\n\texport default createStoreHook();\n"]}
{"filename": "src/index.ts", "chunked_list": ["import Context from './context';\n\timport Provider from './Provider';\n\timport useStore from './useStore';\n\timport defineStore, { createDefineStore } from './store/defineStore';\n\timport createStore from './store/createStore';\n\timport useSelector, { createSelectorHook } from './useSelector';\n\timport { StoreBase } from './store/StoreBase';\n\texport {\n\t  Context,\n\t  Provider,\n", "  useStore,\n\t  createStore,\n\t  defineStore,\n\t  createDefineStore,\n\t  useSelector,\n\t  createSelectorHook,\n\t  StoreBase,\n\t};\n"]}
{"filename": "src/context/types.ts", "chunked_list": ["import { IStore } from '../store/types';\n\texport interface IContext {\n\t  store?: IStore;\n\t}\n"]}
{"filename": "src/context/index.ts", "chunked_list": ["import React from 'react';\n\timport { IContext } from './types';\n\texport const Context = React.createContext<IContext>({});\n\texport default Context;\n"]}
{"filename": "src/store/Store.ts", "chunked_list": ["import createStore from './createStore';\n\texport default createStore({});\n"]}
{"filename": "src/store/createStore.ts", "chunked_list": ["import { IStore } from './types';\n\timport merge from '../utils/merge';\n\texport default function createStore(initState = {}): IStore {\n\t  let currentState = initState;\n\t  const listeners: (() => void)[] = [];\n\t  function setState(nextState) {\n\t    currentState = merge(currentState, nextState);\n\t    for (let i = 0; i < listeners.length; i++) {\n\t      const listener = listeners[i];\n\t      listener();\n", "    }\n\t  }\n\t  function getState() {\n\t    return currentState || {};\n\t  }\n\t  function subscribe(listener: () => void) {\n\t    let isSubscribed = true;\n\t    listeners.push(listener);\n\t    return function unsubscribe() {\n\t      if (!isSubscribed) {\n", "        return;\n\t      }\n\t      isSubscribed = false;\n\t      const index = listeners.indexOf(listener);\n\t      listeners.splice(index, 1);\n\t    };\n\t  }\n\t  return {\n\t    setState,\n\t    getState,\n", "    subscribe,\n\t  };\n\t}\n"]}
{"filename": "src/store/StoreBase.ts", "chunked_list": ["import produce from \"immer\";\n\timport merge from \"../utils/merge\";\n\timport defaultStore from \"./Store\";\n\timport { logByFunc } from \"../log\";\n\timport { IStore } from \"./types\";\n\texport function createStoreBase(store = defaultStore) {\n\t  return class StoreBase<S> {\n\t    name: string = \"\";\n\t    state?: S;\n\t    store: IStore = store;\n", "    constructor() {\n\t      this.init(this.state);\n\t      this.regist();\n\t    }\n\t    regist = () => {\n\t      this.store[this.name] = this;\n\t    };\n\t    getState(): S {\n\t      return this.store.getState()[this.name];\n\t    }\n", "    init = (initState) => {\n\t      const currentState = this.getState();\n\t      if (!currentState) {\n\t        if (typeof initState === \"function\") {\n\t          this.setState(initState());\n\t        } else {\n\t          this.setState(initState);\n\t        }\n\t      }\n\t    };\n", "    setState = (state: S | ((pre: S) => void)) => {\n\t      const lastState = this.getState();\n\t      let nextState;\n\t      if (typeof state === \"function\") {\n\t        nextState = produce(lastState, state as (pre: S) => void);\n\t      } else {\n\t        nextState = merge(lastState, state);\n\t      }\n\t      if (process.env.NODE_ENV === \"development\") {\n\t        logByFunc(this.setState, this.name, lastState, nextState);\n", "      }\n\t      this.store.setState({\n\t        [this.name]: nextState,\n\t      } as any);\n\t    };\n\t  };\n\t}\n\texport default createStoreBase();\n\texport class StoreBase<S> {\n\t  name: string = \"\";\n", "  state?: S | (() => S);\n\t  store: IStore;\n\t  constructor(store = defaultStore) {\n\t    this.store = store;\n\t    this.init(this.state);\n\t  }\n\t  getState(): S {\n\t    return this.store.getState()[this.name];\n\t  }\n\t  init = (initState) => {\n", "    const currentState = this.getState();\n\t    if (!currentState) {\n\t      if (typeof initState === \"function\") {\n\t        this.setState(initState());\n\t      } else {\n\t        this.setState(initState);\n\t      }\n\t    }\n\t  };\n\t  setState = (state: S | ((pre: S) => void)) => {\n", "    const lastState = this.getState();\n\t    let nextState;\n\t    if (typeof state === \"function\") {\n\t      nextState = produce(lastState, state as (pre: S) => void);\n\t    } else {\n\t      nextState = merge(lastState, state);\n\t    }\n\t    if (process.env.NODE_ENV === \"development\") {\n\t      logByFunc(this.setState, this.name, lastState, nextState);\n\t    }\n", "    this.store.setState({\n\t      [this.name]: nextState,\n\t    } as any);\n\t  };\n\t}\n"]}
{"filename": "src/store/types.ts", "chunked_list": ["export interface IStore {\n\t  setState: (state) => void;\n\t  getState: () => any;\n\t  subscribe: (listener: () => void) => () => void;\n\t}\n\t// export type TSetStateFunc = (state:) => void\n"]}
{"filename": "src/store/defineStore.ts", "chunked_list": ["import defaultStore from './Store';\n\timport produce from 'immer';\n\timport merge from '../utils/merge';\n\timport { logByFunc } from '../log';\n\timport { IStore } from './types';\n\t// TODO add enhancer\n\texport function createDefineStore(\n\t  _store: IStore = defaultStore,\n\t  enhancer?: (createDefineStore: any) => <S>(\n\t    name: any,\n", "    initState: S\n\t  ) => {\n\t    getState: () => S;\n\t    setState: (state: Partial<S> | ((pre: S) => void), currName?: any) => void;\n\t    regist: (funcs?: {}) => void;\n\t    store: IStore;\n\t    setAsyncState: (state: (pre: S) => void) => Promise<S>;\n\t    name: any;\n\t    subscribe: any;\n\t  }\n", ") {\n\t  console.log('test enhancer.............');\n\t  console.log(enhancer);\n\t  if (typeof enhancer !== 'undefined') {\n\t    if (typeof enhancer !== 'function') {\n\t      throw new Error(`Expected the enhancer to be a function`);\n\t    }\n\t    return enhancer(createDefineStore);\n\t  }\n\t  const store: IStore = _store || defaultStore;\n", "  return function defineStore<S>(name, initState: S) {\n\t    function getState(): S {\n\t      const state = store.getState();\n\t      if (typeof state === 'object' && state) {\n\t        return state[name] as S;\n\t      }\n\t      return void 0 as unknown as S;\n\t    }\n\t    function setState(state: Partial<S> | ((pre: S) => void)) {\n\t      const lastState = getState();\n", "      //TODO\n\t      let nextState;\n\t      if (typeof state === 'function') {\n\t        nextState = produce(lastState, state as (pre: S) => void);\n\t      } else {\n\t        nextState = merge(lastState, state);\n\t      }\n\t      if (process.env.NODE_ENV === 'development') {\n\t        logByFunc(setState, name, lastState, nextState);\n\t      }\n", "      store.setState({\n\t        [name]: nextState,\n\t      });\n\t      //TODO\n\t    }\n\t    async function setAsyncState(state: (pre: S) => void) {\n\t      const startStack = new Error().stack;\n\t      const lastState = getState();\n\t      let nextState;\n\t      nextState = await produce(lastState, state as (pre: S) => void);\n", "      if (process.env.NODE_ENV === 'development') {\n\t        logByFunc(startStack, name, lastState, nextState, true);\n\t      }\n\t      store.setState({\n\t        [name]: nextState,\n\t      });\n\t    }\n\t    function regist(funcs = {}) {\n\t      store[name] = merge(store[name], funcs);\n\t    }\n", "    function init() {\n\t      const currentState = getState();\n\t      if (!currentState) {\n\t        setState(initState);\n\t      }\n\t    }\n\t    init();\n\t    return {\n\t      getState,\n\t      setState,\n", "      regist,\n\t      store,\n\t      setAsyncState,\n\t      subscribe: store.subscribe,\n\t    };\n\t  };\n\t}\n\texport default createDefineStore();\n"]}
{"filename": "src/utils/merge.ts", "chunked_list": ["export default function merge(to, from) {\n\t  let target;\n\t  if (typeof from === 'object' && typeof to === 'object') {\n\t    target = Object.assign({}, to, from);\n\t  } else {\n\t    target = from;\n\t  }\n\t  return target;\n\t}\n"]}
{"filename": "src/log/defaults.ts", "chunked_list": ["export default {\n\t  level: 'log',\n\t  logger: console,\n\t  logErrors: true,\n\t  collapsed: undefined,\n\t  predicate: undefined,\n\t  duration: false,\n\t  timestamp: true,\n\t  stateTransformer: state => state,\n\t  actionTransformer: action => action,\n", "  errorTransformer: error => error,\n\t  colors: {\n\t    title: () => 'inherit',\n\t    prevState: () => '#9E9E9E',\n\t    action: () => '#03A9F4',\n\t    nextState: () => '#4CAF50',\n\t    error: () => '#F20404'\n\t  },\n\t  diff: false,\n\t  diffPredicate: undefined,\n", "  // Deprecated options\n\t  transformer: undefined\n\t};\n"]}
{"filename": "src/log/index.ts", "chunked_list": ["export function extract(log: string = '', isAsync = false) {\n\t  const regx = /at\\s(.*)\\s\\(/g;\n\t  const matches = log.match(regx);\n\t  if (matches) {\n\t    const target =\n\t      matches.length > 0 ? (isAsync ? matches[1] : matches[0]) : '';\n\t    return target.split(' ')[1];\n\t  }\n\t  return '';\n\t}\n", "export function logByFunc(stack, name, lastState, nextState, isAsync = false) {\n\t  let obj: any = {};\n\t  // console.trace()\n\t  if (!isAsync) {\n\t    Error.captureStackTrace(obj, stack);\n\t  } else {\n\t    obj.stack = stack;\n\t  }\n\t  const action = extract(obj.stack, isAsync);\n\t  console.group(`%c @${name}/${action}`, 'color:#03A9F4');\n", "  console.log('%c preState', 'color:#9E9E9E', lastState);\n\t  // console.log('%c action', 'color:#03A9F4', action);\n\t  console.log('%c nextState', 'color:#4CAF50', nextState);\n\t  console.groupEnd();\n\t}\n"]}
