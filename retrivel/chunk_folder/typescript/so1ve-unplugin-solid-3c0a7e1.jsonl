{"filename": "build.config.ts", "chunked_list": ["import { defineBuildConfig } from \"unbuild\";\n\texport default defineBuildConfig({\n\t  clean: true,\n\t  externals: [\n\t    \"@nuxt/schema\",\n\t    \"@nuxt/kit\",\n\t    \"webpack\",\n\t    \"rollup\",\n\t    \"vite\",\n\t    \"esbuild\",\n", "    \"rspack\",\n\t  ],\n\t});\n"]}
{"filename": "vite.config.ts", "chunked_list": ["import { defineConfig } from \"vitest/config\";\n\texport default defineConfig({\n\t  test: {},\n\t});\n"]}
{"filename": "test/index.test.ts", "chunked_list": ["import { describe, expect, it } from \"vitest\";\n\tdescribe(\"should\", () => {\n\t  it(\"exported\", () => {\n\t    expect(1).toBe(1);\n\t  });\n\t});\n"]}
{"filename": "src/vite.ts", "chunked_list": ["import unplugin from \"./core\";\n\texport default unplugin.vite;\n"]}
{"filename": "src/types.ts", "chunked_list": ["export * from \"./core/types\";\n"]}
{"filename": "src/rollup.ts", "chunked_list": ["import unplugin from \"./core\";\n\texport default unplugin.rollup;\n"]}
{"filename": "src/esbuild.ts", "chunked_list": ["import unplugin from \"./core\";\n\texport default unplugin.esbuild;\n"]}
{"filename": "src/webpack.ts", "chunked_list": ["import unplugin from \"./core\";\n\texport default unplugin.webpack;\n"]}
{"filename": "src/astro.ts", "chunked_list": ["import type { Options } from \"./types\";\n\timport unplugin from \".\";\n\texport default (options: Options) => ({\n\t  name: \"unplugin-solid\",\n\t  hooks: {\n\t    \"astro:config:setup\": async (astro: any) => {\n\t      astro.config.vite.plugins ||= [];\n\t      astro.config.vite.plugins.push(unplugin.vite(options));\n\t    },\n\t  },\n", "});\n"]}
{"filename": "src/index.ts", "chunked_list": ["export { default } from \"./core\";\n"]}
{"filename": "src/rspack.ts", "chunked_list": ["import unplugin from \"./core\";\n\texport default unplugin.rspack;\n"]}
{"filename": "src/core/types.ts", "chunked_list": ["import type { TransformOptions } from \"@babel/core\";\n\timport type { FilterPattern } from \"@rollup/pluginutils\";\n\tinterface ExtensionOptions {\n\t  typescript?: boolean;\n\t}\n\texport interface Options {\n\t  /**\n\t   * A [picomatch](https://github.com/micromatch/picomatch) pattern, or array of\n\t   * patterns, which specifies the files the plugin should operate on.\n\t   */\n", "  include?: FilterPattern;\n\t  /**\n\t   * A [picomatch](https://github.com/micromatch/picomatch) pattern, or array of\n\t   * patterns, which specifies the files to be ignored by the plugin.\n\t   */\n\t  exclude?: FilterPattern;\n\t  /**\n\t   * This will inject solid-js/dev in place of solid-js in dev mode. Has no\n\t   * effect in prod. If set to `false`, it won't inject it in dev. This is\n\t   * useful for extra logs and debugging.\n", "   *\n\t   * @default true\n\t   */\n\t  dev: boolean;\n\t  /**\n\t   * This will force SSR code in the produced files. This is experiemental and\n\t   * mostly not working yet.\n\t   *\n\t   * @default false\n\t   */\n", "  ssr: boolean;\n\t  /**\n\t   * This will inject HMR runtime in dev mode. Has no effect in prod. If set to\n\t   * `false`, it won't inject the runtime in dev.\n\t   *\n\t   * @default true\n\t   */\n\t  hot: boolean;\n\t  /**\n\t   * This registers additional extensions that should be processed by\n", "   * vite-plugin-solid.\n\t   *\n\t   * @default undefined\n\t   */\n\t  extensions?: (string | [string, ExtensionOptions])[];\n\t  /**\n\t   * Pass any additional babel transform options. They will be merged with the\n\t   * transformations required by Solid.\n\t   *\n\t   * @default { }\n", "   */\n\t  babel:\n\t    | TransformOptions\n\t    | ((source: string, id: string, ssr: boolean) => TransformOptions)\n\t    | ((source: string, id: string, ssr: boolean) => Promise<TransformOptions>);\n\t  typescript: {\n\t    /**\n\t     * Forcibly enables jsx parsing. Otherwise angle brackets will be treated as\n\t     * typescript's legacy type assertion var foo = <string>bar;. Also, isTSX:\n\t     * true requires allExtensions: true.\n", "     *\n\t     * @default false\n\t     */\n\t    isTSX?: boolean;\n\t    /**\n\t     * Replace the function used when compiling JSX expressions. This is so that\n\t     * we know that the import is not a type import, and should not be removed.\n\t     *\n\t     * @default React\n\t     */\n", "    jsxPragma?: string;\n\t    /**\n\t     * Replace the function used when compiling JSX fragment expressions. This\n\t     * is so that we know that the import is not a type import, and should not\n\t     * be removed.\n\t     *\n\t     * @default React\n\t     */\n\t    jsxPragmaFrag?: string;\n\t    /**\n", "     * Indicates that every file should be parsed as TS or TSX (depending on the\n\t     * isTSX option).\n\t     *\n\t     * @default false\n\t     */\n\t    allExtensions?: boolean;\n\t    /**\n\t     * Enables compilation of TypeScript namespaces.\n\t     *\n\t     * @default uses the default set by @babel/plugin-transform-typescript.\n", "     */\n\t    allowNamespaces?: boolean;\n\t    /**\n\t     * When enabled, type-only class fields are only removed if they are\n\t     * prefixed with the declare modifier:> NOTE: This will be enabled by\n\t     * default in Babel 8\n\t     *\n\t     * @example\n\t     *\n\t     * ```ts\n", "     * class A {\n\t     *   declare foo: string; // Removed\n\t     *   bar: string; // Initialized to undefined\n\t     *   prop?: string; // Initialized to undefined\n\t     *   prop1!: string; // Initialized to undefined\n\t     * }\n\t     * ```\n\t     *\n\t     * @default false\n\t     */\n", "    allowDeclareFields?: boolean;\n\t    /**\n\t     * When set to true, the transform will only remove type-only imports\n\t     * (introduced in TypeScript 3.8). This should only be used if you are using\n\t     * TypeScript >= 3.8.\n\t     *\n\t     * @default false\n\t     */\n\t    onlyRemoveTypeImports?: boolean;\n\t    /**\n", "     * When set to true, Babel will inline enum values rather than using the\n\t     * usual enum output:\n\t     *\n\t     * This option differs from TypeScript's --isolatedModules behavior, which\n\t     * ignores the const modifier and compiles them as normal enums, and aligns\n\t     * Babel's behavior with TypeScript's default behavior.\n\t     *\n\t     * ```ts\n\t     * // Input\n\t     * const enum Animals {\n", "     *   Fish,\n\t     * }\n\t     * console.log(Animals.Fish);\n\t     *\n\t     * // Default output\n\t     * var Animals;\n\t     *\n\t     * (function (Animals) {\n\t     *   Animals[(Animals[\"Fish\"] = 0)] = \"Fish\";\n\t     * })(Animals || (Animals = {}));\n", "     *\n\t     * console.log(Animals.Fish);\n\t     *\n\t     * // `optimizeConstEnums` output\n\t     * console.log(0);\n\t     * ```\n\t     *\n\t     * However, when exporting a const enum Babel will compile it to a plain\n\t     * object literal so that it doesn't need to rely on cross-file analysis\n\t     * when compiling it:\n", "     *\n\t     * ```ts\n\t     * // Input\n\t     * export const enum Animals {\n\t     *   Fish,\n\t     * }\n\t     *\n\t     * // `optimizeConstEnums` output\n\t     * export var Animals = {\n\t     *   Fish: 0,\n", "     * };\n\t     * ```\n\t     *\n\t     * @default false\n\t     */\n\t    optimizeConstEnums?: boolean;\n\t  };\n\t  /**\n\t   * Pass any additional\n\t   * [babel-plugin-jsx-dom-expressions](https://github.com/ryansolid/dom-expressions/tree/main/packages/babel-plugin-jsx-dom-expressions#plugin-options).\n", "   * They will be merged with the defaults sets by\n\t   * [babel-preset-solid](https://github.com/solidjs/solid/blob/main/packages/babel-preset-solid/index.js#L8-L25).\n\t   */\n\t  solid: {\n\t    /**\n\t     * The name of the runtime module to import the methods from.\n\t     *\n\t     * @default \"solid-js/web\"\n\t     */\n\t    moduleName?: string;\n", "    /**\n\t     * The output mode of the compiler. Can be:\n\t     *\n\t     * - \"dom\" is standard output\n\t     * - \"ssr\" is for server side rendering of strings.\n\t     * - \"universal\" is for using custom renderers from solid-js/universal\n\t     *\n\t     * @default \"dom\"\n\t     */\n\t    generate?: \"ssr\" | \"dom\" | \"universal\";\n", "    /**\n\t     * Indicate whether the output should contain hydratable markers.\n\t     *\n\t     * @default false\n\t     */\n\t    hydratable?: boolean;\n\t    /**\n\t     * Boolean to indicate whether to enable automatic event delegation on\n\t     * camelCase.\n\t     *\n", "     * @default true\n\t     */\n\t    delegateEvents?: boolean;\n\t    /**\n\t     * Boolean indicates whether smart conditional detection should be used.\n\t     * This optimizes simple boolean expressions and ternaries in JSX.\n\t     *\n\t     * @default true\n\t     */\n\t    wrapConditionals?: boolean;\n", "    /**\n\t     * Boolean indicates whether to set current render context on Custom\n\t     * Elements and slots. Useful for seemless Context API with Web Components.\n\t     *\n\t     * @default true\n\t     */\n\t    contextToCustomElements?: boolean;\n\t    /**\n\t     * Array of Component exports from module, that aren't included by default\n\t     * with the library. This plugin will automatically import them if it comes\n", "     * across them in the JSX.\n\t     */\n\t    builtIns?: string[];\n\t  };\n\t}\n"]}
{"filename": "src/core/utils.ts", "chunked_list": ["import { createRequire } from \"node:module\";\n\timport type { Alias, AliasOptions } from \"vite\";\n\tconst require = createRequire(import.meta.url);\n\texport function getExtension(filename: string): string {\n\t  const index = filename.lastIndexOf(\".\");\n\t  return index < 0\n\t    ? \"\"\n\t    : filename.slice(Math.max(0, index)).replace(/\\?.+$/, \"\");\n\t}\n\texport function containsSolidField(fields: any) {\n", "  const keys = Object.keys(fields);\n\t  for (const key of keys) {\n\t    if (key === \"solid\") {\n\t      return true;\n\t    }\n\t    if (\n\t      typeof fields[key] === \"object\" &&\n\t      fields[key] != null &&\n\t      containsSolidField(fields[key])\n\t    ) {\n", "      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\texport function isJestDomInstalled() {\n\t  try {\n\t    // attempt to reference a file that will not throw error because expect is missing\n\t    require(\"@testing-library/jest-dom/dist/utils\");\n\t    return true;\n", "  } catch (e) {\n\t    return false;\n\t  }\n\t}\n\t/**\n\t * This basically normalize all aliases of the config into the array format of\n\t * the alias.\n\t *\n\t * Eg: alias: { '@': 'src/' } => [{ find: '@', replacement: 'src/' }]\n\t */\n", "export const normalizeAliases = (alias: AliasOptions = []): Alias[] =>\n\t  Array.isArray(alias)\n\t    ? alias\n\t    : Object.entries(alias).map(([find, replacement]) => ({\n\t        find,\n\t        replacement,\n\t      }));\n"]}
{"filename": "src/core/index.ts", "chunked_list": ["// Adapted from https://github.com/solidjs/vite-plugin-solid/blob/master/src/index.ts\n\timport { readFileSync } from \"node:fs\";\n\timport type { TransformOptions } from \"@babel/core\";\n\timport { transformAsync } from \"@babel/core\";\n\t// @ts-expect-error\n\timport ts from \"@babel/preset-typescript\";\n\timport { createFilter } from \"@rollup/pluginutils\";\n\t// @ts-expect-error\n\timport solid from \"babel-preset-solid\";\n\timport { mergeAndConcat } from \"merge-anything\";\n", "import solidRefresh from \"solid-refresh/babel\";\n\timport { createUnplugin } from \"unplugin\";\n\timport type { UserConfig } from \"vite\";\n\timport { crawlFrameworkPkgs } from \"vitefu\";\n\timport type { Options } from \"./types\";\n\timport {\n\t  containsSolidField,\n\t  getExtension,\n\t  isJestDomInstalled,\n\t  normalizeAliases,\n", "} from \"./utils\";\n\tconst runtimePublicPath = \"/@solid-refresh\";\n\tconst runtimeFilePath = require.resolve(\"solid-refresh/dist/solid-refresh.mjs\");\n\tconst runtimeCode = readFileSync(runtimeFilePath, \"utf-8\");\n\texport default createUnplugin<Partial<Options> | undefined>(\n\t  (options = {}, meta) => {\n\t    const filter = createFilter(options.include, options.exclude);\n\t    const isVite = meta.framework === \"vite\";\n\t    let needHmr = false;\n\t    let replaceDev = false;\n", "    let projectRoot = process.cwd();\n\t    return {\n\t      name: \"unplugin-solid\",\n\t      enforce: \"pre\",\n\t      vite: {\n\t        async config(userConfig, { command }) {\n\t          // We inject the dev mode only if the user explicitely wants it or if we are in dev (serve) mode\n\t          replaceDev =\n\t            options.dev === true ||\n\t            (options.dev !== false && command === \"serve\");\n", "          projectRoot = userConfig.root ?? projectRoot;\n\t          if (!userConfig.resolve) {\n\t            userConfig.resolve = {};\n\t          }\n\t          userConfig.resolve.alias = normalizeAliases(userConfig.resolve.alias);\n\t          const solidPkgsConfig = await crawlFrameworkPkgs({\n\t            viteUserConfig: userConfig,\n\t            root: projectRoot || process.cwd(),\n\t            isBuild: command === \"build\",\n\t            isFrameworkPkgByJson(pkgJson) {\n", "              return containsSolidField(pkgJson.exports || {});\n\t            },\n\t          });\n\t          // fix for bundling dev in production\n\t          const nestedDeps = replaceDev\n\t            ? [\n\t                \"solid-js\",\n\t                \"solid-js/web\",\n\t                \"solid-js/store\",\n\t                \"solid-js/html\",\n", "                \"solid-js/h\",\n\t              ]\n\t            : [];\n\t          const test =\n\t            userConfig.mode === \"test\"\n\t              ? {\n\t                  test: {\n\t                    globals: true,\n\t                    ...(options.ssr ? {} : { environment: \"jsdom\" }),\n\t                    transformMode: {\n", "                      [options.ssr ? \"ssr\" : \"web\"]: [/\\.[jt]sx?$/],\n\t                    },\n\t                    ...(isJestDomInstalled()\n\t                      ? {\n\t                          setupFiles: [\n\t                            \"node_modules/@testing-library/jest-dom/extend-expect.js\",\n\t                          ],\n\t                        }\n\t                      : {}),\n\t                    deps: { registerNodeLoader: true },\n", "                    ...(\n\t                      userConfig as UserConfig & { test: Record<string, any> }\n\t                    ).test,\n\t                  },\n\t                }\n\t              : {};\n\t          return {\n\t            /**\n\t             * We only need esbuild on .ts or .js files. .tsx & .jsx files are\n\t             * handled by us\n", "             */\n\t            esbuild: { include: /\\.ts$/ },\n\t            resolve: {\n\t              conditions: [\n\t                \"solid\",\n\t                ...(isVite && replaceDev ? [\"development\"] : []),\n\t                ...(userConfig.mode === \"test\" && !options.ssr\n\t                  ? [\"browser\"]\n\t                  : []),\n\t              ],\n", "              dedupe: nestedDeps,\n\t              alias: [\n\t                { find: /^solid-refresh$/, replacement: runtimePublicPath },\n\t              ],\n\t            },\n\t            optimizeDeps: {\n\t              include: [...nestedDeps, ...solidPkgsConfig.optimizeDeps.include],\n\t              exclude: solidPkgsConfig.optimizeDeps.exclude,\n\t            },\n\t            ssr: solidPkgsConfig.ssr,\n", "            ...test,\n\t          };\n\t        },\n\t        configResolved(config) {\n\t          needHmr =\n\t            config.command === \"serve\" &&\n\t            config.mode !== \"production\" &&\n\t            options.hot !== false;\n\t        },\n\t        resolveId(id) {\n", "          if (id === runtimePublicPath) {\n\t            return id;\n\t          }\n\t        },\n\t        load(id) {\n\t          if (id === runtimePublicPath) {\n\t            return runtimeCode;\n\t          }\n\t        },\n\t      },\n", "      async transform(source, id) {\n\t        const isSsr = !!options.ssr;\n\t        const currentFileExtension = getExtension(id);\n\t        const extensionsToWatch = [\n\t          ...(options.extensions ?? []),\n\t          \".tsx\",\n\t          \".jsx\",\n\t        ];\n\t        const allExtensions = extensionsToWatch.map((extension) =>\n\t          // An extension can be a string or a tuple [extension, options]\n", "          typeof extension === \"string\" ? extension : extension[0],\n\t        );\n\t        if (!filter(id) || !allExtensions.includes(currentFileExtension)) {\n\t          return null;\n\t        }\n\t        const inNodeModules = /node_modules/.test(id);\n\t        let solidOptions: { generate: \"ssr\" | \"dom\"; hydratable: boolean };\n\t        if (options.ssr) {\n\t          solidOptions = isSsr\n\t            ? { generate: \"ssr\", hydratable: true }\n", "            : { generate: \"dom\", hydratable: true };\n\t        } else {\n\t          solidOptions = { generate: \"dom\", hydratable: false };\n\t        }\n\t        id = id.replace(/\\?.+$/, \"\");\n\t        const opts: TransformOptions = {\n\t          babelrc: false,\n\t          configFile: false,\n\t          root: projectRoot,\n\t          filename: id,\n", "          sourceFileName: id,\n\t          presets: [[solid, { ...solidOptions, ...(options.solid ?? {}) }]],\n\t          plugins:\n\t            isVite && needHmr && !isSsr && !inNodeModules\n\t              ? [[solidRefresh, { bundler: \"vite\" }]]\n\t              : [],\n\t          sourceMaps: true,\n\t          // Vite handles sourcemap flattening\n\t          inputSourceMap: false as any,\n\t        };\n", "        // We need to know if the current file extension has a typescript options tied to it\n\t        const shouldBeProcessedWithTypescript = extensionsToWatch.some(\n\t          (extension) => {\n\t            if (typeof extension === \"string\") {\n\t              return extension.includes(\"tsx\");\n\t            }\n\t            const [extensionName, extensionOptions] = extension;\n\t            if (extensionName !== currentFileExtension) {\n\t              return false;\n\t            }\n", "            return extensionOptions.typescript;\n\t          },\n\t        );\n\t        if (shouldBeProcessedWithTypescript) {\n\t          (opts.presets ??= []).push([ts, options.typescript ?? {}]);\n\t        }\n\t        // Default value for babel user options\n\t        let babelUserOptions: TransformOptions = {};\n\t        if (options.babel) {\n\t          if (typeof options.babel === \"function\") {\n", "            const babelOptions = options.babel(source, id, isSsr);\n\t            babelUserOptions =\n\t              babelOptions instanceof Promise\n\t                ? await babelOptions\n\t                : babelOptions;\n\t          } else {\n\t            babelUserOptions = options.babel;\n\t          }\n\t        }\n\t        const babelOptions = mergeAndConcat(babelUserOptions, opts);\n", "        const { code, map } = (await transformAsync(source, babelOptions))!;\n\t        return { code: code!, map };\n\t      },\n\t    };\n\t  },\n\t);\n"]}
