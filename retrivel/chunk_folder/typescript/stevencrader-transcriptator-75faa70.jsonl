{"filename": "test/timestamp.test.ts", "chunked_list": ["import { describe, expect, test } from \"@jest/globals\"\n\timport { parseTimestamp, TimestampFormatter, TimestampFormatterManager } from \"../src/timestamp\"\n\tdescribe(\"Timestamp\", () => {\n\t    test.each<{\n\t        data: string | number\n\t        expected: number\n\t        id: string\n\t    }>([\n\t        {\n\t            data: \"00:00:00,780\",\n", "            expected: 0.78,\n\t            id: \"comma, HH:MM:SS,fff\",\n\t        },\n\t        {\n\t            data: \"00:00:00.780\",\n\t            expected: 0.78,\n\t            id: \"decimal, HH:MM:SS.fff\",\n\t        },\n\t        {\n\t            data: \"00:00,780\",\n", "            expected: 0.78,\n\t            id: \"comma, MM:SS,fff\",\n\t        },\n\t        {\n\t            data: \"00:00.780\",\n\t            expected: 0.78,\n\t            id: \"decimal, MM:SS.fff\",\n\t        },\n\t        {\n\t            data: \"00,780\",\n", "            expected: 0.78,\n\t            id: \"comma, SS,fff\",\n\t        },\n\t        {\n\t            data: \"00.780\",\n\t            expected: 0.78,\n\t            id: \"decimal, SS.fff\",\n\t        },\n\t        {\n\t            data: \"0,780\",\n", "            expected: 0.78,\n\t            id: \"comma, S,fff\",\n\t        },\n\t        {\n\t            data: \"0.780\",\n\t            expected: 0.78,\n\t            id: \"decimal, S.fff\",\n\t        },\n\t        {\n\t            data: \"01:02:03\",\n", "            expected: 3723,\n\t            id: \"HH:MM:SS\",\n\t        },\n\t        {\n\t            data: \"02:03\",\n\t            expected: 123,\n\t            id: \"MM:SS\",\n\t        },\n\t        {\n\t            data: \"03\",\n", "            expected: 3,\n\t            id: \"SS\",\n\t        },\n\t        {\n\t            data: \"01:02:03,456\",\n\t            expected: 3723.456,\n\t            id: \"all fields\",\n\t        },\n\t        {\n\t            data: 12.493,\n", "            expected: 12.493,\n\t            id: \"number\",\n\t        },\n\t    ])(\"Timestamp ($id)\", ({ data, expected }) => {\n\t        expect(parseTimestamp(data)).toEqual(expected)\n\t    })\n\t})\n\tdescribe(\"Undefined timestamp\", () => {\n\t    test.each<{\n\t        data: unknown\n", "        id: string\n\t    }>([\n\t        { data: [], id: \"Array\" },\n\t        { data: \"01;02:03,456\", id: \"Wrong separator\" },\n\t        { data: \"01:02:03/956\", id: \"Wrong decimal separator\" },\n\t        { data: \"03:01:02:03,456\", id: \"Too many fields\" },\n\t        { data: \"01: :03,456\", id: \"Space field\" },\n\t    ])(\"Undefined timestamp ($id)\", ({ data }) => {\n\t        expect(() => parseTimestamp(data as string)).toThrow(TypeError)\n\t    })\n", "})\n\t/**\n\t * Custom formatter\n\t *\n\t * @param timestamp Time in seconds to format\n\t * @returns formatted timestamp string\n\t */\n\tconst customFormatter = (timestamp: number): string => {\n\t    return timestamp.toString()\n\t}\n", "test(\"Timestamp Formatter instances\", () => {\n\t    TimestampFormatter.registerCustomFormatter(customFormatter)\n\t    const second = new TimestampFormatterManager()\n\t    expect(TimestampFormatter === second).toBe(true)\n\t    TimestampFormatter.unregisterCustomFormatter()\n\t})\n\tdescribe(\"Format timestamp\", () => {\n\t    test.each<{\n\t        data: number\n\t        expected: string\n", "    }>([\n\t        {\n\t            data: 0.78,\n\t            expected: \"00:00:00.780\",\n\t        },\n\t        {\n\t            data: 0.7248,\n\t            expected: \"00:00:00.725\",\n\t        },\n\t        {\n", "            data: 3723.456,\n\t            expected: \"01:02:03.456\",\n\t        },\n\t        {\n\t            data: 365567.12,\n\t            expected: \"101:32:47.120\",\n\t        },\n\t    ])(\"Format timestamp ($data)\", ({ data, expected }) => {\n\t        expect(TimestampFormatter.format(data)).toEqual(expected)\n\t    })\n", "})\n\tdescribe(\"Custom formatter\", () => {\n\t    test.each<{\n\t        data: number\n\t        expected: string\n\t    }>([\n\t        {\n\t            data: 0.78,\n\t            expected: \"0.78\",\n\t        },\n", "        {\n\t            data: 0.7248,\n\t            expected: \"0.7248\",\n\t        },\n\t        {\n\t            data: 3723.456,\n\t            expected: \"3723.456\",\n\t        },\n\t        {\n\t            data: 365567.12,\n", "            expected: \"365567.12\",\n\t        },\n\t    ])(\"Custom timestamp formatter ($data)\", ({ data, expected }) => {\n\t        TimestampFormatter.registerCustomFormatter(customFormatter)\n\t        expect(TimestampFormatter.format(data)).toEqual(expected)\n\t        TimestampFormatter.unregisterCustomFormatter()\n\t    })\n\t})\n"]}
{"filename": "test/json.test.ts", "chunked_list": ["import { describe, expect, test } from \"@jest/globals\"\n\timport { IOptions, Options, Segment } from \"../src\"\n\timport { parseJSON } from \"../src/formats/json\"\n\timport { readFile, saveSegmentsToFile, TestFiles } from \"./test_utils\"\n\tdescribe(\"JSON formats test\", () => {\n\t    test.each<{\n\t        data: string\n\t        expected: Array<Segment>\n\t        id: string\n\t    }>([\n", "        { data: \"[]\", expected: [], id: \"Empty List\" },\n\t        { data: \"{}\", expected: [], id: \"Empty Dict\" },\n\t        {\n\t            // language=JSON\n\t            data: '{\"version\": \"1.0.0\",\"segments\": [{\"speaker\": \"Alban\",\"startTime\": 0.0,\"endTime\": 4.8,\"body\": \"It is so stinking nice to\"}]}',\n\t            expected: [\n\t                {\n\t                    startTime: 0.0,\n\t                    startTimeFormatted: \"00:00:00.000\",\n\t                    endTime: 4.8,\n", "                    endTimeFormatted: \"00:00:04.800\",\n\t                    speaker: \"Alban\",\n\t                    body: \"It is so stinking nice to\",\n\t                },\n\t            ],\n\t            id: \"Dict segments\",\n\t        },\n\t        {\n\t            // language=JSON\n\t            data: '[{\"start\": 1,\"end\": 5000,\"text\": \"Subtitles: @marlonrock1986 (^^V^^)\"}]',\n", "            expected: [\n\t                {\n\t                    startTime: 0.001,\n\t                    startTimeFormatted: \"00:00:00.001\",\n\t                    endTime: 5,\n\t                    endTimeFormatted: \"00:00:05.000\",\n\t                    speaker: \"Subtitles\",\n\t                    body: \"@marlonrock1986 (^^V^^)\",\n\t                },\n\t            ],\n", "            id: \"List\",\n\t        },\n\t    ])(\"JSON Format ($id)\", ({ data, expected }) => {\n\t        expect(parseJSON(data)).toStrictEqual(expected)\n\t    })\n\t})\n\tdescribe(\"JSON invalid formats\", () => {\n\t    test.each<{\n\t        data: string\n\t        id: string\n", "    }>([\n\t        {\n\t            data: \"\",\n\t            id: \"Empty\",\n\t        },\n\t        {\n\t            // language=JSON\n\t            data: '{\"version\": \"1.0.0\"}',\n\t            id: \"invalid format\",\n\t        },\n", "        {\n\t            // language=JSON\n\t            data: '[{\"startTime\": 1,\"endTime\": 5000,\"body\": \"Subtitles: @marlonrock1986 (^^V^^)\"}]',\n\t            id: \"Wrong list format\",\n\t        },\n\t        {\n\t            data: '{\"segments\": [],}',\n\t            id: \"Invalid JSON\",\n\t        },\n\t        {\n", "            // language=JSON\n\t            data: '[{\"start\": \"A\",\"end\": 5000,\"text\": \"Subtitles: @marlonrock1986 (^^V^^)\"}]',\n\t            id: \"start is NaN\",\n\t        },\n\t        {\n\t            // language=JSON\n\t            data: '[{\"start\": 0,\"end\": \"Z\",\"text\": \"Subtitles: @marlonrock1986 (^^V^^)\"}]',\n\t            id: \"end is NaN\",\n\t        },\n\t        {\n", "            data: '[{\"end\":5000,\"start\":1,\"text\":\"Subtitles: @marlonrock1986 (^^V^^)\"},{\"end\":\"A\",\"start\":25801,\"text\":\"It\\'s another hot, sunny day today\\\\nhere in Southern California.\"}]',\n\t            id: \"Error in later segment\",\n\t        },\n\t    ])(\"JSON invalid formats ($id)\", ({ data }) => {\n\t        expect(() => parseJSON(data)).toThrow(Error)\n\t    })\n\t})\n\tdescribe(\"Parse JSON file data\", () => {\n\t    test.each<{\n\t        filePath: string\n", "        expectedFilePath: string\n\t        options: IOptions\n\t        id: string\n\t    }>([\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_JSON_BUZZCAST,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_JSON_BUZZCAST_OUTPUT,\n\t            options: undefined,\n\t            id: \"Buzzcast\",\n\t        },\n", "        {\n\t            filePath: TestFiles.TRANSCRIPT_JSON_BUZZCAST,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_JSON_BUZZCAST_COMBINE_EQUAL_TIME_OUTPUT,\n\t            options: {\n\t                combineEqualTimes: true,\n\t            },\n\t            id: \"Buzzcast, combine equal times\",\n\t        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_JSON_BUZZCAST,\n", "            expectedFilePath: TestFiles.TRANSCRIPT_JSON_BUZZCAST_COMBINE_EQUAL_TIME_SPACE_OUTPUT,\n\t            options: {\n\t                combineEqualTimes: true,\n\t                combineEqualTimesSeparator: \" \",\n\t            },\n\t            id: \"Buzzcast, combine equal times, space\",\n\t        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_JSON_LALALAND,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_JSON_LALALAND_OUTPUT,\n", "            options: undefined,\n\t            id: \"LaLaLand\",\n\t        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_JSON_HOW_TO_START_A_PODCAST,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_JSON_HOW_TO_START_A_PODCAST_OUTPUT,\n\t            options: undefined,\n\t            id: \"How to Start a Podcast\",\n\t        },\n\t        {\n", "            filePath: TestFiles.TRANSCRIPT_JSON_HOW_TO_START_A_PODCAST,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_JSON_HOW_TO_START_A_PODCAST_COMBINE_SEGMENTS_32_OUTPUT,\n\t            options: {\n\t                combineSegments: true,\n\t                combineSegmentsLength: 32,\n\t            },\n\t            id: \"How to Start a Podcast, combine segments, 32\",\n\t        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_JSON_HOW_TO_START_A_PODCAST,\n", "            expectedFilePath: TestFiles.TRANSCRIPT_JSON_HOW_TO_START_A_PODCAST_COMBINE_SPEAKER_OUTPUT,\n\t            options: {\n\t                combineSpeaker: true,\n\t                combineSegments: true,\n\t                combineSegmentsLength: 32,\n\t            },\n\t            id: \"How to Start a Podcast, combine speaker\",\n\t        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_JSON_BUZZCAST,\n", "            expectedFilePath: TestFiles.TRANSCRIPT_JSON_BUZZCAST_SPEAKER_CHANGE_COMBINE_EQUAL_TIME_SPACE_OUTPUT,\n\t            options: {\n\t                speakerChange: true,\n\t                combineEqualTimes: true,\n\t                combineEqualTimesSeparator: \" \",\n\t            },\n\t            id: \"Buzzcast, speaker change\",\n\t        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_JSON_HOW_TO_START_A_PODCAST,\n", "            expectedFilePath: TestFiles.TRANSCRIPT_JSON_HOW_TO_START_A_PODCAST_SPEAKER_CHANGE_OUTPUT,\n\t            options: {\n\t                speakerChange: true,\n\t                combineSegments: true,\n\t                combineSegmentsLength: 32,\n\t            },\n\t            id: \"How to Start a Podcast, speaker change\",\n\t        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_JSON_PODNEWS_WEEKLY_REVIEW_2023_05_05,\n", "            expectedFilePath: TestFiles.TRANSCRIPT_JSON_PODNEWS_WEEKLY_REVIEW_2023_05_05_OUTPUT,\n\t            options: {\n\t                combineEqualTimes: true,\n\t                combineEqualTimesSeparator: \" \",\n\t                combineSegments: true,\n\t                combineSegmentsLength: 50,\n\t            },\n\t            id: \"Podnews Weekly Review 2023-05-05, equal times and segments\",\n\t        },\n\t        {\n", "            filePath: TestFiles.TRANSCRIPT_JSON_PODNEWS_WEEKLY_REVIEW_2023_05_05,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_JSON_PODNEWS_WEEKLY_REVIEW_2023_05_05_COMBINE_SPEAKER_OUTPUT,\n\t            options: {\n\t                combineSpeaker: true,\n\t            },\n\t            id: \"Podnews Weekly Review 2023-05-05, combine speaker\",\n\t        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_JSON_PODNEWS_WEEKLY_REVIEW_2023_06_02,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_JSON_PODNEWS_WEEKLY_REVIEW_2023_06_02_OUTPUT,\n", "            options: {\n\t                combineSpeaker: true,\n\t            },\n\t            id: \"Podnews Weekly Review 2023-06-02, extra space\",\n\t        },\n\t    ])(\"Parse JSON File ($id)\", ({ filePath, expectedFilePath, options, id }) => {\n\t        const data = readFile(filePath)\n\t        const expectedJSONData = JSON.parse(readFile(expectedFilePath))\n\t        Options.setOptions(options)\n\t        const segments = parseJSON(data)\n", "        saveSegmentsToFile(segments, `out_json_${id}.json`)\n\t        expect(segments).toEqual(expectedJSONData.segments)\n\t    })\n\t})\n"]}
{"filename": "test/test.ts", "chunked_list": ["// noinspection HtmlRequiredLangAttribute\n\timport { describe, expect, test } from \"@jest/globals\"\n\timport { convertFile, determineFormat, Options, TranscriptFormat } from \"../src\"\n\timport { readFile, TestFiles } from \"./test_utils\"\n\tdescribe(\"Determine Transcript Type\", () => {\n\t    // noinspection HtmlRequiredLangAttribute\n\t    test.each<{\n\t        data: string\n\t        expected: TranscriptFormat\n\t    }>([\n", "        {\n\t            data: \" <!-- html comment --><html></html>\",\n\t            expected: TranscriptFormat.HTML,\n\t        },\n\t        { data: \"<html></html>\", expected: TranscriptFormat.HTML },\n\t        {\n\t            data: `  <time>0:00</time>\n\t  <p>Paragraph content</p>\n\t  <cite>John</cite>`,\n\t            expected: TranscriptFormat.HTML,\n", "        },\n\t        {\n\t            data: `  <time>0:00</time>\n\t  <p>Paragraph content</p>`,\n\t            expected: TranscriptFormat.HTML,\n\t        },\n\t        { data: \"\\nWEBVTT\", expected: TranscriptFormat.VTT },\n\t        { data: \"WEBVTT\", expected: TranscriptFormat.VTT },\n\t        {\n\t            // language=JSON\n", "            data: '{\"version\":\"1.0.0\",\"segments\":[{\"speaker\":\"Alban\",\"startTime\":0.0,\"endTime\":4.8,\"body\":\"It is so stinking nice to\"}]}',\n\t            expected: TranscriptFormat.JSON,\n\t        },\n\t        {\n\t            data: `1\n\t00:00:00,780 --> 00:00:06,210\n\tAdam Curry: podcasting 2.0 March\n\t4 2023 Episode 124 on D flat`,\n\t            expected: TranscriptFormat.SRT,\n\t        },\n", "        {\n\t            data: `2\n\t00:00:00,780 --> 00:00:06.210\n\tAdam Curry: podcasting 2.0 March\n\t`,\n\t            expected: TranscriptFormat.SRT,\n\t        },\n\t        {\n\t            // language=JSON\n\t            data: '[{\"startTime\": 1,\"endTime\": 5000,\"body\": \"Subtitles: @marlonrock1986 (^^V^^)\"}]',\n", "            expected: TranscriptFormat.JSON,\n\t        },\n\t        {\n\t            // language=JSON\n\t            data: '{\"version\": \"1.0.0\",\"segments\": [{\"speaker\": \"Alban\",\"startTime\": 0.0,\"endTime\": 4.8,\"body\": \"It is so stinking nice to\"}]}',\n\t            expected: TranscriptFormat.JSON,\n\t        },\n\t    ])(\"Transcript Type ($expected)\", ({ data, expected }) => {\n\t        expect(determineFormat(data)).toEqual(expected)\n\t    })\n", "})\n\tdescribe(\"Unknown transcript format data\", () => {\n\t    test.each<{\n\t        data: string\n\t        id: string\n\t    }>([{ data: \"\", id: \"Empty\" }])(\"Transcript Type Unknown ($id)\", ({ data }) => {\n\t        expect(() => determineFormat(data)).toThrow(Error)\n\t    })\n\t})\n\tdescribe(\"Convert File\", () => {\n", "    test.each<{\n\t        filePath: string\n\t        expectedFilePath: string\n\t        transcriptFormat: TranscriptFormat | undefined\n\t        id: string\n\t    }>([\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_SRT_BUZZCAST,\n\t            transcriptFormat: undefined,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_SRT_BUZZCAST_OUTPUT,\n", "            id: \"SRT Detect\",\n\t        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_SRT_PODCASTING_20_EPISODE_124,\n\t            transcriptFormat: TranscriptFormat.SRT,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_SRT_PODCASTING_20_EPISODE_124_OUTPUT,\n\t            id: \"SRT\",\n\t        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_JSON_BUZZCAST,\n", "            transcriptFormat: undefined,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_JSON_BUZZCAST_OUTPUT,\n\t            id: \"JSON Detect\",\n\t        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_JSON_LALALAND,\n\t            transcriptFormat: TranscriptFormat.JSON,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_JSON_LALALAND_OUTPUT,\n\t            id: \"JSON\",\n\t        },\n", "        {\n\t            filePath: TestFiles.TRANSCRIPT_HTML_BUZZCAST,\n\t            transcriptFormat: undefined,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_HTML_BUZZCAST_OUTPUT,\n\t            id: \"HTML Detect\",\n\t        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_HTML_BUZZCAST,\n\t            transcriptFormat: TranscriptFormat.HTML,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_HTML_BUZZCAST_OUTPUT,\n", "            id: \"HTML\",\n\t        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_VTT_LALALAND,\n\t            transcriptFormat: undefined,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_VTT_LALALAND_OUTPUT,\n\t            id: \"VTT Detect\",\n\t        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_VTT_LALALAND,\n", "            transcriptFormat: TranscriptFormat.VTT,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_VTT_LALALAND_OUTPUT,\n\t            id: \"VTT\",\n\t        },\n\t    ])(\"Convert File ($id)\", ({ filePath, transcriptFormat, expectedFilePath }) => {\n\t        const data = readFile(filePath)\n\t        const expectedJSONData = JSON.parse(readFile(expectedFilePath))\n\t        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t        // @ts-ignore\n\t        const segments = convertFile(data, transcriptFormat)\n", "        expect(segments).toEqual(expectedJSONData.segments)\n\t    })\n\t})\n\tdescribe(\"Convert File Error\", () => {\n\t    test.each<{\n\t        data: string\n\t        transcriptFormat: TranscriptFormat | string\n\t        id: string\n\t    }>([\n\t        {\n", "            data: \"\",\n\t            transcriptFormat: \"txt\",\n\t            id: \"Unknown format\",\n\t        },\n\t        {\n\t            data: `1\n\t00:00:00,780 --> 00:00:06,210\n\tAdam Curry: podcasting 2.0 March\n\t4 2023 Episode 124 on D flat`,\n\t            transcriptFormat: TranscriptFormat.VTT,\n", "            id: \"SRT, wrong format\",\n\t        },\n\t        {\n\t            // language=JSON\n\t            data: `[{\"startTime\": 1,\"endTime\": 5000,\"body\": \"Subtitles: @marlonrock1986 (^^V^^)\"}]`,\n\t            transcriptFormat: TranscriptFormat.SRT,\n\t            id: \"JSON, wrong format\",\n\t        },\n\t        {\n\t            data: `<!-- a comment -->\n", "<html><body><cite>Alban:</cite>\n\t  <time>0:00</time>\n\t  <p>It is so stinking nice to like, show up and record this show. And Travis has already put together an outline. Kevin's got suggestions, I throw my thoughts into the mix. And then Travis goes and does all the work from there, too. It's out into the wild. And I don't see anything. That's an absolute joy for at least two thirds of the team. Yeah, I mean, exactly.</p>\n\t  <cite>Kevin:</cite>\n\t  <time>0:30</time>\n\t  <p>You guys remember, like two months ago, when you were like, We're going all in on video Buzzcast. I was like, that's, I mean, I will agree and commit and disagree, disagree and commit, I'll do something. But I don't want to do this.</p>\n\t</body></html>`,\n\t            transcriptFormat: TranscriptFormat.JSON,\n\t            id: \"HTML, wrong format\",\n\t        },\n", "        {\n\t            data: `WEBVTT\n\t1\n\t00:00:00.001 --> 00:00:05.000\n\tSubtitles: @marlonrock1986 (^^V^^)\n\t`,\n\t            transcriptFormat: TranscriptFormat.JSON,\n\t            id: \"VTT, wrong format\",\n\t        },\n\t    ])(\"Convert File Error ($id)\", ({ data, transcriptFormat }) => {\n", "        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t        // @ts-ignore\n\t        expect(() => convertFile(data, transcriptFormat as TranscriptFormat)).toThrow(Error)\n\t    })\n\t})\n\tdescribe(\"Combine Single Word Segments\", () => {\n\t    // noinspection HtmlRequiredLangAttribute\n\t    test.each<{\n\t        segments: string\n\t        maxLength: number\n", "        expected: string\n\t        id: string\n\t    }>([\n\t        {\n\t            segments: TestFiles.ONE_WORD_SEGMENTS,\n\t            maxLength: 32,\n\t            expected: TestFiles.ONE_WORD_SEGMENTS_OUTPUT_32,\n\t            id: \"length 32\",\n\t        },\n\t        {\n", "            segments: TestFiles.ONE_WORD_SEGMENTS,\n\t            maxLength: 50,\n\t            expected: TestFiles.ONE_WORD_SEGMENTS_OUTPUT_50,\n\t            id: \"length 50\",\n\t        },\n\t    ])(\"Combine Single Word Segments ($id)\", ({ segments, maxLength, expected }) => {\n\t        const segmentsData = readFile(segments)\n\t        const expectedJSON = JSON.parse(readFile(expected))\n\t        Options.setOptions({\n\t            combineSegments: true,\n", "            combineSegmentsLength: maxLength,\n\t        })\n\t        const outSegments = convertFile(segmentsData, TranscriptFormat.JSON)\n\t        expect(outSegments).toStrictEqual(expectedJSON)\n\t    })\n\t})\n"]}
{"filename": "test/speaker.test.ts", "chunked_list": ["import { describe, expect, test } from \"@jest/globals\"\n\timport { parseSpeaker } from \"../src/speaker\"\n\tdescribe(\"Speaker\", () => {\n\t    test.each<{\n\t        data: string\n\t        expected: { speaker: string; message: string }\n\t    }>([\n\t        {\n\t            data: \"Adam Curry: podcasting 2.0 March\",\n\t            expected: {\n", "                speaker: \"Adam Curry\",\n\t                message: \"podcasting 2.0 March\",\n\t            },\n\t        },\n\t        {\n\t            data: \"Adam: \",\n\t            expected: {\n\t                speaker: \"Adam\",\n\t                message: \"\",\n\t            },\n", "        },\n\t        {\n\t            data: \"Adam:\",\n\t            expected: {\n\t                speaker: \"\",\n\t                message: \"Adam:\",\n\t            },\n\t        },\n\t        {\n\t            data: \"the meeting starts at 2:30\",\n", "            expected: {\n\t                speaker: \"\",\n\t                message: \"the meeting starts at 2:30\",\n\t            },\n\t        },\n\t        {\n\t            data: \"2: apples\",\n\t            expected: {\n\t                speaker: \"\",\n\t                message: \"2: apples\",\n", "            },\n\t        },\n\t    ])(\"Speaker ($data)\", ({ data, expected }) => {\n\t        expect(parseSpeaker(data)).toEqual(expected)\n\t    })\n\t})\n"]}
{"filename": "test/segments.test.ts", "chunked_list": ["import { describe, expect, test } from \"@jest/globals\"\n\timport { IOptions, Options, Segment } from \"../src\"\n\timport { addSegment } from \"../src/segments\"\n\tconst SEGMENT_FIRST: Segment = {\n\t    startTime: 0.253,\n\t    startTimeFormatted: \"00:00:00.253\",\n\t    endTime: 3.373,\n\t    endTimeFormatted: \"00:00:03.373\",\n\t    speaker: \"Jon\",\n\t    body: \"Welcome to the\",\n", "}\n\tconst SEGMENT_TIME_SPEAKER_MATCH: Segment = {\n\t    startTime: 0.253,\n\t    startTimeFormatted: \"00:00:00.253\",\n\t    endTime: 3.373,\n\t    endTimeFormatted: \"00:00:03.373\",\n\t    speaker: \"Jon\",\n\t    body: \"latest episode of Podcast.\",\n\t}\n\tconst SEGMENT_TIME_MATCH: Segment = {\n", "    startTime: 0.253,\n\t    startTimeFormatted: \"00:00:00.253\",\n\t    endTime: 3.373,\n\t    endTimeFormatted: \"00:00:03.373\",\n\t    speaker: \"Fred\",\n\t    body: \"latest episode of Podcast.\",\n\t}\n\tconst SEGMENT_SECOND: Segment = {\n\t    startTime: 3.4,\n\t    startTimeFormatted: \"00:00:03.400\",\n", "    endTime: 5.847,\n\t    endTimeFormatted: \"00:00:05.847\",\n\t    speaker: \"Jon\",\n\t    body: \"latest episode of Podcast.\",\n\t}\n\tconst SEGMENT_WORD_1: Segment = {\n\t    startTime: 0.253,\n\t    startTimeFormatted: \"00:00:00.253\",\n\t    endTime: 0.578,\n\t    endTimeFormatted: \"00:00:00.578\",\n", "    speaker: \"Jon\",\n\t    body: \"Welcome\",\n\t}\n\tconst SEGMENT_WORD_2: Segment = {\n\t    startTime: 0.579,\n\t    startTimeFormatted: \"00:00:00.579\",\n\t    endTime: 1.015,\n\t    endTimeFormatted: \"00:00:01.015\",\n\t    speaker: \"Jon\",\n\t    body: \"to\",\n", "}\n\tdescribe(\"Apply Segment Options\", () => {\n\t    test.each<{\n\t        newSegment: Segment\n\t        priorSegments: Array<Segment>\n\t        options: IOptions\n\t        expected: Array<Segment>\n\t        id: string\n\t    }>([\n\t        {\n", "            newSegment: { ...SEGMENT_FIRST },\n\t            priorSegments: undefined,\n\t            options: {},\n\t            expected: [{ ...SEGMENT_FIRST }],\n\t            id: \"first, no options\",\n\t        },\n\t        {\n\t            newSegment: { ...SEGMENT_TIME_SPEAKER_MATCH },\n\t            priorSegments: [{ ...SEGMENT_FIRST }],\n\t            options: {\n", "                combineEqualTimes: true,\n\t            },\n\t            expected: [\n\t                {\n\t                    startTime: 0.253,\n\t                    startTimeFormatted: \"00:00:00.253\",\n\t                    endTime: 3.373,\n\t                    endTimeFormatted: \"00:00:03.373\",\n\t                    speaker: \"Jon\",\n\t                    body: \"Welcome to the\\nlatest episode of Podcast.\",\n", "                },\n\t            ],\n\t            id: \"time, speaker match - default\",\n\t        },\n\t        {\n\t            newSegment: { ...SEGMENT_TIME_SPEAKER_MATCH },\n\t            priorSegments: [{ ...SEGMENT_FIRST }],\n\t            options: {\n\t                combineEqualTimes: true,\n\t                combineEqualTimesSeparator: \" \",\n", "            },\n\t            expected: [\n\t                {\n\t                    startTime: 0.253,\n\t                    startTimeFormatted: \"00:00:00.253\",\n\t                    endTime: 3.373,\n\t                    endTimeFormatted: \"00:00:03.373\",\n\t                    speaker: \"Jon\",\n\t                    body: \"Welcome to the latest episode of Podcast.\",\n\t                },\n", "            ],\n\t            id: \"time, speaker match - space\",\n\t        },\n\t        {\n\t            newSegment: { ...SEGMENT_TIME_MATCH },\n\t            priorSegments: [{ ...SEGMENT_FIRST }],\n\t            options: {\n\t                combineEqualTimes: true,\n\t            },\n\t            expected: [{ ...SEGMENT_FIRST }, { ...SEGMENT_TIME_MATCH }],\n", "            id: \"time match, speaker different\",\n\t        },\n\t        {\n\t            newSegment: {\n\t                startTime: 1.822,\n\t                startTimeFormatted: \"00:00:01.822\",\n\t                endTime: 3.373,\n\t                endTimeFormatted: \"00:00:03.373\",\n\t                body: \"latest episode of Podcast.\",\n\t            },\n", "            priorSegments: undefined,\n\t            options: {\n\t                speakerChange: true,\n\t            },\n\t            expected: [\n\t                {\n\t                    startTime: 1.822,\n\t                    startTimeFormatted: \"00:00:01.822\",\n\t                    endTime: 3.373,\n\t                    endTimeFormatted: \"00:00:03.373\",\n", "                    speaker: undefined,\n\t                    body: \"latest episode of Podcast.\",\n\t                },\n\t            ],\n\t            id: \"speaker change, no speaker, no prior\",\n\t        },\n\t        {\n\t            newSegment: {\n\t                startTime: 1.822,\n\t                startTimeFormatted: \"00:00:01.822\",\n", "                endTime: 3.373,\n\t                endTimeFormatted: \"00:00:03.373\",\n\t                speaker: \"Fred\",\n\t                body: \"latest episode of Podcast.\",\n\t            },\n\t            priorSegments: [{ ...SEGMENT_FIRST }],\n\t            options: {\n\t                speakerChange: true,\n\t            },\n\t            expected: [\n", "                { ...SEGMENT_FIRST },\n\t                {\n\t                    startTime: 1.822,\n\t                    startTimeFormatted: \"00:00:01.822\",\n\t                    endTime: 3.373,\n\t                    endTimeFormatted: \"00:00:03.373\",\n\t                    speaker: \"Fred\",\n\t                    body: \"latest episode of Podcast.\",\n\t                },\n\t            ],\n", "            id: \"speaker change, different speaker\",\n\t        },\n\t        {\n\t            newSegment: {\n\t                startTime: 1.822,\n\t                startTimeFormatted: \"00:00:01.822\",\n\t                endTime: 3.373,\n\t                endTimeFormatted: \"00:00:03.373\",\n\t                speaker: \"Jon\",\n\t                body: \"latest episode of Podcast.\",\n", "            },\n\t            priorSegments: [\n\t                {\n\t                    startTime: 0.253,\n\t                    startTimeFormatted: \"00:00:00.253\",\n\t                    endTime: 1.821,\n\t                    endTimeFormatted: \"00:00:01.821\",\n\t                    speaker: \"Jon\",\n\t                    body: \"Welcome to the\",\n\t                },\n", "            ],\n\t            options: {\n\t                speakerChange: true,\n\t            },\n\t            expected: [\n\t                {\n\t                    startTime: 0.253,\n\t                    startTimeFormatted: \"00:00:00.253\",\n\t                    endTime: 1.821,\n\t                    endTimeFormatted: \"00:00:01.821\",\n", "                    speaker: \"Jon\",\n\t                    body: \"Welcome to the\",\n\t                },\n\t                {\n\t                    startTime: 1.822,\n\t                    startTimeFormatted: \"00:00:01.822\",\n\t                    endTime: 3.373,\n\t                    endTimeFormatted: \"00:00:03.373\",\n\t                    speaker: undefined,\n\t                    body: \"latest episode of Podcast.\",\n", "                },\n\t            ],\n\t            id: \"same speaker, remove speaker\",\n\t        },\n\t        {\n\t            newSegment: {\n\t                startTime: 1.822,\n\t                startTimeFormatted: \"00:00:01.822\",\n\t                endTime: 3.373,\n\t                endTimeFormatted: \"00:00:03.373\",\n", "                body: \"latest episode of Podcast.\",\n\t            },\n\t            priorSegments: [\n\t                {\n\t                    startTime: 0.253,\n\t                    startTimeFormatted: \"00:00:00.253\",\n\t                    endTime: 1.821,\n\t                    endTimeFormatted: \"00:00:01.821\",\n\t                    body: \"Welcome to the\",\n\t                },\n", "            ],\n\t            options: {\n\t                speakerChange: true,\n\t            },\n\t            expected: [\n\t                {\n\t                    startTime: 0.253,\n\t                    startTimeFormatted: \"00:00:00.253\",\n\t                    endTime: 1.821,\n\t                    endTimeFormatted: \"00:00:01.821\",\n", "                    body: \"Welcome to the\",\n\t                },\n\t                {\n\t                    startTime: 1.822,\n\t                    startTimeFormatted: \"00:00:01.822\",\n\t                    endTime: 3.373,\n\t                    endTimeFormatted: \"00:00:03.373\",\n\t                    body: \"latest episode of Podcast.\",\n\t                },\n\t            ],\n", "            id: \"no speaker, remove speaker\",\n\t        },\n\t        {\n\t            newSegment: { ...SEGMENT_SECOND },\n\t            priorSegments: [{ ...SEGMENT_FIRST }],\n\t            options: {\n\t                combineSegments: true,\n\t            },\n\t            expected: [{ ...SEGMENT_FIRST }, { ...SEGMENT_SECOND }],\n\t            id: \"combine segments, too long, default length\",\n", "        },\n\t        {\n\t            newSegment: { ...SEGMENT_WORD_2 },\n\t            priorSegments: [{ ...SEGMENT_WORD_1 }],\n\t            options: {\n\t                combineSegments: true,\n\t            },\n\t            expected: [\n\t                {\n\t                    startTime: 0.253,\n", "                    startTimeFormatted: \"00:00:00.253\",\n\t                    endTime: 1.015,\n\t                    endTimeFormatted: \"00:00:01.015\",\n\t                    speaker: \"Jon\",\n\t                    body: \"Welcome to\",\n\t                },\n\t            ],\n\t            id: \"combine segments, default length\",\n\t        },\n\t        {\n", "            newSegment: { ...SEGMENT_SECOND },\n\t            priorSegments: [{ ...SEGMENT_FIRST }],\n\t            options: {\n\t                combineSegments: true,\n\t                combineSegmentsLength: 45,\n\t            },\n\t            expected: [\n\t                {\n\t                    startTime: 0.253,\n\t                    startTimeFormatted: \"00:00:00.253\",\n", "                    endTime: 5.847,\n\t                    endTimeFormatted: \"00:00:05.847\",\n\t                    speaker: \"Jon\",\n\t                    body: \"Welcome to the latest episode of Podcast.\",\n\t                },\n\t            ],\n\t            id: \"combine segments, length 45\",\n\t        },\n\t        {\n\t            newSegment: { ...SEGMENT_SECOND },\n", "            priorSegments: [{ ...SEGMENT_FIRST }],\n\t            options: {\n\t                combineSegments: true,\n\t                combineSegmentsLength: 32,\n\t            },\n\t            expected: [{ ...SEGMENT_FIRST }, { ...SEGMENT_SECOND }],\n\t            id: \"combine segments, too long\",\n\t        },\n\t        {\n\t            newSegment: {\n", "                startTime: 0.579,\n\t                startTimeFormatted: \"00:00:00.579\",\n\t                endTime: 1.015,\n\t                endTimeFormatted: \"00:00:01.015\",\n\t                speaker: \"Jon\",\n\t                body: \", this\",\n\t            },\n\t            priorSegments: [{ ...SEGMENT_WORD_1 }],\n\t            options: {\n\t                combineSegments: true,\n", "            },\n\t            expected: [\n\t                {\n\t                    startTime: 0.253,\n\t                    startTimeFormatted: \"00:00:00.253\",\n\t                    endTime: 1.015,\n\t                    endTimeFormatted: \"00:00:01.015\",\n\t                    speaker: \"Jon\",\n\t                    body: \"Welcome, this\",\n\t                },\n", "            ],\n\t            id: \"combine segments, no space\",\n\t        },\n\t        {\n\t            newSegment: { ...SEGMENT_SECOND },\n\t            priorSegments: [{ ...SEGMENT_FIRST }],\n\t            options: {\n\t                combineSpeaker: true,\n\t            },\n\t            expected: [\n", "                {\n\t                    startTime: 0.253,\n\t                    startTimeFormatted: \"00:00:00.253\",\n\t                    endTime: 5.847,\n\t                    endTimeFormatted: \"00:00:05.847\",\n\t                    speaker: \"Jon\",\n\t                    body: \"Welcome to the latest episode of Podcast.\",\n\t                },\n\t            ],\n\t            id: \"combine speaker\",\n", "        },\n\t        {\n\t            newSegment: { ...SEGMENT_SECOND },\n\t            priorSegments: [\n\t                {\n\t                    startTime: 0.253,\n\t                    startTimeFormatted: \"00:00:00.253\",\n\t                    endTime: 3.373,\n\t                    endTimeFormatted: \"00:00:03.373\",\n\t                    speaker: \"Jon\",\n", "                    body: \"\",\n\t                },\n\t            ],\n\t            options: {\n\t                combineSpeaker: true,\n\t            },\n\t            expected: [\n\t                {\n\t                    startTime: 0.253,\n\t                    startTimeFormatted: \"00:00:00.253\",\n", "                    endTime: 5.847,\n\t                    endTimeFormatted: \"00:00:05.847\",\n\t                    speaker: \"Jon\",\n\t                    body: \"latest episode of Podcast.\",\n\t                },\n\t            ],\n\t            id: \"no body\",\n\t        },\n\t        {\n\t            newSegment: { ...SEGMENT_SECOND },\n", "            priorSegments: [\n\t                {\n\t                    startTime: 0.253,\n\t                    startTimeFormatted: \"00:00:00.253\",\n\t                    endTime: 3.373,\n\t                    endTimeFormatted: \"00:00:03.373\",\n\t                    speaker: \"Jeff\",\n\t                    body: \"Welcome to the\",\n\t                },\n\t            ],\n", "            options: {\n\t                combineSpeaker: true,\n\t            },\n\t            expected: [\n\t                {\n\t                    startTime: 0.253,\n\t                    startTimeFormatted: \"00:00:00.253\",\n\t                    endTime: 3.373,\n\t                    endTimeFormatted: \"00:00:03.373\",\n\t                    speaker: \"Jeff\",\n", "                    body: \"Welcome to the\",\n\t                },\n\t                { ...SEGMENT_SECOND },\n\t            ],\n\t            id: \"combine speaker, different speakers\",\n\t        },\n\t    ])(\"Apply Options ($id)\", ({ newSegment, priorSegments, options, expected }) => {\n\t        Options.setOptions(options)\n\t        expect(addSegment(newSegment, priorSegments)).toStrictEqual(expected)\n\t    })\n", "})\n"]}
{"filename": "test/html.test.ts", "chunked_list": ["// noinspection HtmlRequiredLangAttribute\n\timport { describe, expect, test } from \"@jest/globals\"\n\timport { Segment } from \"../src\"\n\timport { parseHTML } from \"../src/formats/html\"\n\timport { readFile, TestFiles } from \"./test_utils\"\n\tdescribe(\"HTML formats test\", () => {\n\t    test.each<{\n\t        data: string\n\t        expected: Array<Segment>\n\t        id: string\n", "    }>([\n\t        { data: \"<html></html>\", expected: [], id: \"Empty HTML\" },\n\t        { data: \"<html><body></body></html>\", expected: [], id: \"Empty Body\" },\n\t        {\n\t            data: `\n\t<!-- a comment -->\n\t<html><body><cite>Alban:</cite>\n\t<time>0:00</time>\n\t<p>It is so stinking nice to like, show up and record this show. And Travis has already put together an outline. Kevin's got suggestions, I throw my thoughts into the mix. And then Travis goes and does all the work from there, too. It's out into the wild. And I don't see anything. That's an absolute joy for at least two thirds of the team. Yeah, I mean, exactly.</p>\n\t<cite>Kevin:</cite>\n", "<time>0:30</time>\n\t<p>You guys remember, like two months ago, when you were like, We're going all in on video Buzzcast. I was like, that's, I mean, I will agree and commit and disagree, disagree and commit, I'll do something. But I don't want to do this.</p>\n\t</body></html>`,\n\t            expected: [\n\t                {\n\t                    startTime: 0,\n\t                    startTimeFormatted: \"00:00:00.000\",\n\t                    endTime: 30,\n\t                    endTimeFormatted: \"00:00:30.000\",\n\t                    speaker: \"Alban\",\n", "                    body: \"It is so stinking nice to like, show up and record this show. And Travis has already put together an outline. Kevin's got suggestions, I throw my thoughts into the mix. And then Travis goes and does all the work from there, too. It's out into the wild. And I don't see anything. That's an absolute joy for at least two thirds of the team. Yeah, I mean, exactly.\",\n\t                },\n\t                {\n\t                    startTime: 30,\n\t                    startTimeFormatted: \"00:00:30.000\",\n\t                    endTime: 0,\n\t                    endTimeFormatted: \"00:00:00.000\",\n\t                    speaker: \"Kevin\",\n\t                    body: \"You guys remember, like two months ago, when you were like, We're going all in on video Buzzcast. I was like, that's, I mean, I will agree and commit and disagree, disagree and commit, I'll do something. But I don't want to do this.\",\n\t                },\n", "            ],\n\t            id: \"has body html\",\n\t        },\n\t        {\n\t            data: `\n\t<html><cite>Alban:</cite>\n\t  <time>0:00</time>\n\t  <p>It is so stinking nice to like, show up and record this show. And Travis has already put together an outline. Kevin's got suggestions, I throw my thoughts into the mix. And then Travis goes and does all the work from there, too. It's out into the wild. And I don't see anything. That's an absolute joy for at least two thirds of the team. Yeah, I mean, exactly.</p>\n\t</html>`,\n\t            expected: [\n", "                {\n\t                    startTime: 0,\n\t                    startTimeFormatted: \"00:00:00.000\",\n\t                    endTime: 0,\n\t                    endTimeFormatted: \"00:00:00.000\",\n\t                    speaker: \"Alban\",\n\t                    body: \"It is so stinking nice to like, show up and record this show. And Travis has already put together an outline. Kevin's got suggestions, I throw my thoughts into the mix. And then Travis goes and does all the work from there, too. It's out into the wild. And I don't see anything. That's an absolute joy for at least two thirds of the team. Yeah, I mean, exactly.\",\n\t                },\n\t            ],\n\t            id: \"no body html\",\n", "        },\n\t        {\n\t            data: `  <time>0:00</time>\n\t  <p>Hello. And just before we start, I'm gonna sound a little bit different in this episode because I discovered that I had magically recorded myself using my inbuilt microphone on my MacBook Air. Brilliant. So you can imagine how rubbish that was. However, thanks to the tools at Adobe Podcast, I no longer sound like this. It's Friday the 17th of March, 2023, but now I sound like this. It's Friday, the 17th of March, 2023. The last word in podcasting news. This is the Pod News Weekly review with James Cridlin and Sam Sethy. I'm James Cridlin, the editor of Pod News. And I'm Courtney Kosack from the podcast, besties Newsletter, and now podcast. Yes, uh, Sam is away skiing Las Vegas last week. Kits Bull in Switzerland this week. It's, uh, it's a difficult life, isn't it, for some people  in the chapters today. Apple and Spotify are both number one. It just depends what you look at. Uh, the winners of the ihearts Podcast Awards and who didn't win there or at the MBEs. And also, hello, I'm</p>\n\t  <cite>Norma-Jean Belenky:</cite>`,\n\t            expected: [\n\t                {\n\t                    startTime: 0,\n\t                    startTimeFormatted: \"00:00:00.000\",\n\t                    endTime: 0,\n", "                    endTimeFormatted: \"00:00:00.000\",\n\t                    speaker: \"Norma-Jean Belenky\",\n\t                    body: \"Hello. And just before we start, I'm gonna sound a little bit different in this episode because I discovered that I had magically recorded myself using my inbuilt microphone on my MacBook Air. Brilliant. So you can imagine how rubbish that was. However, thanks to the tools at Adobe Podcast, I no longer sound like this. It's Friday the 17th of March, 2023, but now I sound like this. It's Friday, the 17th of March, 2023. The last word in podcasting news. This is the Pod News Weekly review with James Cridlin and Sam Sethy. I'm James Cridlin, the editor of Pod News. And I'm Courtney Kosack from the podcast, besties Newsletter, and now podcast. Yes, uh, Sam is away skiing Las Vegas last week. Kits Bull in Switzerland this week. It's, uh, it's a difficult life, isn't it, for some people  in the chapters today. Apple and Spotify are both number one. It just depends what you look at. Uh, the winners of the ihearts Podcast Awards and who didn't win there or at the MBEs. And also, hello, I'm\",\n\t                },\n\t            ],\n\t            id: \"time, p, cite\",\n\t        },\n\t        {\n\t            data: `  <time>0:00</time>\n\t  <p>Hello. And just before we start, I'm gonna sound a little bit different in this episode because I discovered that I had magically recorded myself using my inbuilt microphone on my MacBook Air. Brilliant. So you can imagine how rubbish that was. However, thanks to the tools at Adobe Podcast, I no longer sound like this. It's Friday the 17th of March, 2023, but now I sound like this. It's Friday, the 17th of March, 2023. The last word in podcasting news. This is the Pod News Weekly review with James Cridlin and Sam Sethy. I'm James Cridlin, the editor of Pod News. And I'm Courtney Kosack from the podcast, besties Newsletter, and now podcast. Yes, uh, Sam is away skiing Las Vegas last week. Kits Bull in Switzerland this week. It's, uh, it's a difficult life, isn't it, for some people  in the chapters today. Apple and Spotify are both number one. It just depends what you look at. Uh, the winners of the ihearts Podcast Awards and who didn't win there or at the MBEs. And also, hello, I'm</p>`,\n", "            expected: [\n\t                {\n\t                    startTime: 0,\n\t                    startTimeFormatted: \"00:00:00.000\",\n\t                    endTime: 0,\n\t                    endTimeFormatted: \"00:00:00.000\",\n\t                    speaker: \"\",\n\t                    body: \"Hello. And just before we start, I'm gonna sound a little bit different in this episode because I discovered that I had magically recorded myself using my inbuilt microphone on my MacBook Air. Brilliant. So you can imagine how rubbish that was. However, thanks to the tools at Adobe Podcast, I no longer sound like this. It's Friday the 17th of March, 2023, but now I sound like this. It's Friday, the 17th of March, 2023. The last word in podcasting news. This is the Pod News Weekly review with James Cridlin and Sam Sethy. I'm James Cridlin, the editor of Pod News. And I'm Courtney Kosack from the podcast, besties Newsletter, and now podcast. Yes, uh, Sam is away skiing Las Vegas last week. Kits Bull in Switzerland this week. It's, uh, it's a difficult life, isn't it, for some people  in the chapters today. Apple and Spotify are both number one. It just depends what you look at. Uh, the winners of the ihearts Podcast Awards and who didn't win there or at the MBEs. And also, hello, I'm\",\n\t                },\n\t            ],\n", "            id: \"time, p\",\n\t        },\n\t    ])(\"HTML Format ($id)\", ({ data, expected }) => {\n\t        expect(parseHTML(data)).toStrictEqual(expected)\n\t    })\n\t})\n\tdescribe(\"Bad HTML data\", () => {\n\t    test.each<{\n\t        data: string\n\t        expected: Array<Segment>\n", "        id: string\n\t    }>([\n\t        {\n\t            data: `<html><body>\\n\n\t  <time>0:00</time>\\n\n\t  <p>It is so stinking nice to like, show up and record this show. And Travis has already put together an outline. Kevin's got suggestions, I throw my thoughts into the mix. And then Travis goes and does all the work from there, too. It's out into the wild. And I don't see anything. That's an absolute joy for at least two thirds of the team. Yeah, I mean, exactly.</p>\\n\n\t  <cite>Kevin:</cite>\\n\n\t  <time>0:30</time>\\n\n\t  <p>You guys remember, like two months ago, when you were like, We're going all in on video Buzzcast. I was like, that's, I mean, I will agree and commit and disagree, disagree and commit, I'll do something. But I don't want to do this.</p>\n\t</body></html>`,\n", "            expected: [\n\t                {\n\t                    startTime: 0,\n\t                    startTimeFormatted: \"00:00:00.000\",\n\t                    endTime: 30,\n\t                    endTimeFormatted: \"00:00:30.000\",\n\t                    speaker: \"Kevin\",\n\t                    body: \"It is so stinking nice to like, show up and record this show. And Travis has already put together an outline. Kevin's got suggestions, I throw my thoughts into the mix. And then Travis goes and does all the work from there, too. It's out into the wild. And I don't see anything. That's an absolute joy for at least two thirds of the team. Yeah, I mean, exactly.\",\n\t                },\n\t                {\n", "                    startTime: 30,\n\t                    startTimeFormatted: \"00:00:30.000\",\n\t                    endTime: 0,\n\t                    endTimeFormatted: \"00:00:00.000\",\n\t                    speaker: \"Kevin\",\n\t                    body: \"You guys remember, like two months ago, when you were like, We're going all in on video Buzzcast. I was like, that's, I mean, I will agree and commit and disagree, disagree and commit, I'll do something. But I don't want to do this.\",\n\t                },\n\t            ],\n\t            id: \"No cite\",\n\t        },\n", "        {\n\t            data: `<html><body><cite>Alban:</cite>\n\t  <p>It is so stinking nice to like, show up and record this show. And Travis has already put together an outline. Kevin's got suggestions, I throw my thoughts into the mix. And then Travis goes and does all the work from there, too. It's out into the wild. And I don't see anything. That's an absolute joy for at least two thirds of the team. Yeah, I mean, exactly.</p>\n\t  <cite>Kevin:</cite>\n\t  <time>0:30</time>\n\t  <p>You guys remember, like two months ago, when you were like, We're going all in on video Buzzcast. I was like, that's, I mean, I will agree and commit and disagree, disagree and commit, I'll do something. But I don't want to do this.</p>\n\t</body></html>`,\n\t            expected: [\n\t                {\n\t                    startTime: 30,\n", "                    startTimeFormatted: \"00:00:30.000\",\n\t                    endTime: 0,\n\t                    endTimeFormatted: \"00:00:00.000\",\n\t                    speaker: \"Kevin\",\n\t                    body: \"You guys remember, like two months ago, when you were like, We're going all in on video Buzzcast. I was like, that's, I mean, I will agree and commit and disagree, disagree and commit, I'll do something. But I don't want to do this.\",\n\t                },\n\t            ],\n\t            id: \"No time\",\n\t        },\n\t        {\n", "            data: `<html><body><cite>Alban:</cite>\n\t  <time>0:00</time>\n\t  <cite>Kevin:</cite>\n\t  <time>0:30</time>\n\t  <p>You guys remember, like two months ago, when you were like, We're going all in on video Buzzcast. I was like, that's, I mean, I will agree and commit and disagree, disagree and commit, I'll do something. But I don't want to do this.</p>\n\t</body></html>`,\n\t            expected: [\n\t                {\n\t                    startTime: 0,\n\t                    startTimeFormatted: \"00:00:00.000\",\n", "                    endTime: 30,\n\t                    endTimeFormatted: \"00:00:30.000\",\n\t                    speaker: \"Alban\",\n\t                    body: \"\",\n\t                },\n\t                {\n\t                    startTime: 30,\n\t                    startTimeFormatted: \"00:00:30.000\",\n\t                    endTime: 0,\n\t                    endTimeFormatted: \"00:00:00.000\",\n", "                    speaker: \"Kevin\",\n\t                    body: \"You guys remember, like two months ago, when you were like, We're going all in on video Buzzcast. I was like, that's, I mean, I will agree and commit and disagree, disagree and commit, I'll do something. But I don't want to do this.\",\n\t                },\n\t            ],\n\t            id: \"No p\",\n\t        },\n\t        {\n\t            data: `<html><cite>Alban:</cite><cite>Joe:</cite>\n\t  <time>0:00</time>\n\t  <p>It is so stinking nice to like, show up and record this show. And Travis has already put together an outline. Kevin's got suggestions, I throw my thoughts into the mix. And then Travis goes and does all the work from there, too. It's out into the wild. And I don't see anything. That's an absolute joy for at least two thirds of the team. Yeah, I mean, exactly.</p>\n", "  <cite>Kevin:</cite>\n\t  <time>0:30</time>\n\t  <p>You guys remember, like two months ago, when you were like, We're going all in on video Buzzcast. I was like, that's, I mean, I will agree and commit and disagree, disagree and commit, I'll do something. But I don't want to do this.</p>\n\t</body></html>`,\n\t            expected: [\n\t                {\n\t                    startTime: 0,\n\t                    startTimeFormatted: \"00:00:00.000\",\n\t                    endTime: 30,\n\t                    endTimeFormatted: \"00:00:30.000\",\n", "                    speaker: \"Joe\",\n\t                    body: \"It is so stinking nice to like, show up and record this show. And Travis has already put together an outline. Kevin's got suggestions, I throw my thoughts into the mix. And then Travis goes and does all the work from there, too. It's out into the wild. And I don't see anything. That's an absolute joy for at least two thirds of the team. Yeah, I mean, exactly.\",\n\t                },\n\t                {\n\t                    startTime: 30,\n\t                    startTimeFormatted: \"00:00:30.000\",\n\t                    endTime: 0,\n\t                    endTimeFormatted: \"00:00:00.000\",\n\t                    speaker: \"Kevin\",\n\t                    body: \"You guys remember, like two months ago, when you were like, We're going all in on video Buzzcast. I was like, that's, I mean, I will agree and commit and disagree, disagree and commit, I'll do something. But I don't want to do this.\",\n", "                },\n\t            ],\n\t            id: \"duplicate cite\",\n\t        },\n\t        {\n\t            data: `<html><cite>Alban:</cite>\n\t  <time>0:00</time><time>0:01</time>\n\t  <p>It is so stinking nice to like, show up and record this show. And Travis has already put together an outline. Kevin's got suggestions, I throw my thoughts into the mix. And then Travis goes and does all the work from there, too. It's out into the wild. And I don't see anything. That's an absolute joy for at least two thirds of the team. Yeah, I mean, exactly.</p>\n\t  <cite>Kevin:</cite>\n\t  <time>0:30</time>\n", "  <p>You guys remember, like two months ago, when you were like, We're going all in on video Buzzcast. I was like, that's, I mean, I will agree and commit and disagree, disagree and commit, I'll do something. But I don't want to do this.</p>\n\t</body></html>`,\n\t            expected: [\n\t                {\n\t                    startTime: 0,\n\t                    startTimeFormatted: \"00:00:00.000\",\n\t                    endTime: 1,\n\t                    endTimeFormatted: \"00:00:01.000\",\n\t                    speaker: \"Alban\",\n\t                    body: \"\",\n", "                },\n\t                {\n\t                    startTime: 1,\n\t                    startTimeFormatted: \"00:00:01.000\",\n\t                    endTime: 30,\n\t                    endTimeFormatted: \"00:00:30.000\",\n\t                    speaker: \"Kevin\",\n\t                    body: \"It is so stinking nice to like, show up and record this show. And Travis has already put together an outline. Kevin's got suggestions, I throw my thoughts into the mix. And then Travis goes and does all the work from there, too. It's out into the wild. And I don't see anything. That's an absolute joy for at least two thirds of the team. Yeah, I mean, exactly.\",\n\t                },\n\t                {\n", "                    startTime: 30,\n\t                    startTimeFormatted: \"00:00:30.000\",\n\t                    endTime: 0,\n\t                    endTimeFormatted: \"00:00:00.000\",\n\t                    speaker: \"Kevin\",\n\t                    body: \"You guys remember, like two months ago, when you were like, We're going all in on video Buzzcast. I was like, that's, I mean, I will agree and commit and disagree, disagree and commit, I'll do something. But I don't want to do this.\",\n\t                },\n\t            ],\n\t            id: \"duplicate time\",\n\t        },\n", "        {\n\t            data: `<html><cite>Alban:</cite>\n\t<time>0:00</time>\n\t<p>It is so stinking nice to like, show up and record this show. And Travis has already put together an outline. Kevin's got suggestions, I throw my thoughts into the mix. And then Travis goes and does all the work from there, too. It's out into the wild. And I don't see anything. That's an absolute joy for at least two thirds of the team. Yeah, I mean, exactly.</p>\n\t<p>Second paragraph</p>\n\t<cite>Kevin:</cite>\n\t<time>0:30</time>\n\t<p>You guys remember, like two months ago, when you were like, We're going all in on video Buzzcast. I was like, that's, I mean, I will agree and commit and disagree, disagree and commit, I'll do something. But I don't want to do this.</p>\n\t</body></html>`,\n\t            expected: [\n", "                {\n\t                    startTime: 0,\n\t                    startTimeFormatted: \"00:00:00.000\",\n\t                    endTime: 30,\n\t                    endTimeFormatted: \"00:00:30.000\",\n\t                    speaker: \"Alban\",\n\t                    body: \"It is so stinking nice to like, show up and record this show. And Travis has already put together an outline. Kevin's got suggestions, I throw my thoughts into the mix. And then Travis goes and does all the work from there, too. It's out into the wild. And I don't see anything. That's an absolute joy for at least two thirds of the team. Yeah, I mean, exactly.\",\n\t                },\n\t                {\n\t                    startTime: 30,\n", "                    startTimeFormatted: \"00:00:30.000\",\n\t                    endTime: 0,\n\t                    endTimeFormatted: \"00:00:00.000\",\n\t                    speaker: \"Kevin\",\n\t                    body: \"Second paragraph\",\n\t                },\n\t            ],\n\t            id: \"duplicate p\",\n\t        },\n\t    ])(\"Bad HTML data ($id)\", ({ data, expected }) => {\n", "        expect(parseHTML(data)).toStrictEqual(expected)\n\t    })\n\t})\n\tdescribe(\"HTML formats error test\", () => {\n\t    test.each<{\n\t        data: string\n\t        id: string\n\t    }>([{ data: \"<body></body>\", id: \"No HTML\" }])(\"HTML Error Format ($id)\", ({ data }) => {\n\t        expect(() => parseHTML(data)).toThrow(Error)\n\t    })\n", "})\n\tdescribe(\"Parse HTML file data\", () => {\n\t    test.each<{\n\t        filePath: string\n\t        expectedFilePath: string\n\t        id: string\n\t    }>([\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_HTML_BUZZCAST,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_HTML_BUZZCAST_OUTPUT,\n", "            id: \"Buzzcast\",\n\t        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_HTML_PODNEWS_WEEKLY_REVIEW_2023_03_17,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_HTML_PODNEWS_WEEKLY_REVIEW_2023_03_17_OUTPUT,\n\t            id: \"Podnews Weekly Review 2023-03-07\",\n\t        },\n\t    ])(\"Parse HTML File ($id)\", ({ filePath, expectedFilePath }) => {\n\t        const data = readFile(filePath)\n\t        const expectedHTMLData = JSON.parse(readFile(expectedFilePath))\n", "        const segments = parseHTML(data)\n\t        expect(segments).toEqual(expectedHTMLData.segments)\n\t    })\n\t})\n"]}
{"filename": "test/test_utils.ts", "chunked_list": ["import { existsSync, mkdirSync, readFileSync, writeFileSync } from \"node:fs\"\n\timport * as path from \"node:path\"\n\timport { Segment } from \"../src\"\n\texport enum TestFiles {\n\t    TRANSCRIPT_HTML_BUZZCAST = \"buzzcast.html\",\n\t    TRANSCRIPT_HTML_BUZZCAST_OUTPUT = \"buzzcast_html_parsed.json\",\n\t    TRANSCRIPT_HTML_PODNEWS_WEEKLY_REVIEW_2023_03_17 = \"podnews_weekly_review_2023-03-17.html\",\n\t    TRANSCRIPT_HTML_PODNEWS_WEEKLY_REVIEW_2023_03_17_OUTPUT = \"podnews_weekly_review_2023-03-17_html_parsed.json\",\n\t    TRANSCRIPT_JSON_PODNEWS_WEEKLY_REVIEW_2023_05_05 = \"podnews_weekly_review_2023-05-05.json\",\n\t    TRANSCRIPT_JSON_PODNEWS_WEEKLY_REVIEW_2023_05_05_OUTPUT = \"podnews_weekly_review_2023-05-05_json_parsed.json\",\n", "    TRANSCRIPT_JSON_PODNEWS_WEEKLY_REVIEW_2023_05_05_COMBINE_SPEAKER_OUTPUT = \"podnews_weekly_review_2023-05-05_combine_speaker_json_parsed.json\",\n\t    TRANSCRIPT_JSON_PODNEWS_WEEKLY_REVIEW_2023_06_02 = \"podnews_weekly_review_2023-06-02.json\",\n\t    TRANSCRIPT_JSON_PODNEWS_WEEKLY_REVIEW_2023_06_02_OUTPUT = \"podnews_weekly_review_2023-06-02_json_parsed.json\",\n\t    TRANSCRIPT_JSON_BUZZCAST = \"buzzcast.json\",\n\t    TRANSCRIPT_JSON_BUZZCAST_OUTPUT = \"buzzcast_json_parsed.json\",\n\t    TRANSCRIPT_JSON_BUZZCAST_COMBINE_EQUAL_TIME_OUTPUT = \"buzzcast_json_combine_equal_time_parsed.json\",\n\t    TRANSCRIPT_JSON_BUZZCAST_COMBINE_EQUAL_TIME_SPACE_OUTPUT = \"buzzcast_json_combine_equal_time_space_parsed.json\",\n\t    TRANSCRIPT_JSON_BUZZCAST_SPEAKER_CHANGE_COMBINE_EQUAL_TIME_SPACE_OUTPUT = \"buzzcast_json_speaker_change_combine_equal_time_space_parsed.json\",\n\t    TRANSCRIPT_JSON_HOW_TO_START_A_PODCAST = \"how_to_start_a_podcast.json\",\n\t    TRANSCRIPT_JSON_HOW_TO_START_A_PODCAST_OUTPUT = \"how_to_start_a_podcast_json_parsed.json\",\n", "    TRANSCRIPT_JSON_LALALAND = \"LaLaLand.json\",\n\t    TRANSCRIPT_JSON_HOW_TO_START_A_PODCAST_COMBINE_SEGMENTS_32_OUTPUT = \"how_to_start_a_podcast_json_combine_segments_32_parsed.json\",\n\t    TRANSCRIPT_JSON_HOW_TO_START_A_PODCAST_COMBINE_SPEAKER_OUTPUT = \"how_to_start_a_podcast_json_combine_speaker_parsed.json\",\n\t    TRANSCRIPT_JSON_HOW_TO_START_A_PODCAST_SPEAKER_CHANGE_OUTPUT = \"how_to_start_a_podcast_json_speaker_changed_parsed.json\",\n\t    TRANSCRIPT_JSON_LALALAND_OUTPUT = \"LaLaLand_json_parsed.json\",\n\t    TRANSCRIPT_SRT_BUZZCAST = \"buzzcast.srt\",\n\t    TRANSCRIPT_SRT_BUZZCAST_OUTPUT = \"buzzcast_srt_parsed.json\",\n\t    TRANSCRIPT_SRT_BUZZCAST_COMBINED_SEGMENTS_128_OUTPUT = \"buzzcast_srt_combined_segments_128_parsed.json\",\n\t    TRANSCRIPT_SRT_BUZZCAST_SPEAKER_CHANGE_COMBINED_SEGMENTS_128_OUTPUT = \"buzzcast_srt_speaker_change_combined_segments_128_parsed.json\",\n\t    TRANSCRIPT_SRT_PODCASTING_20_EPISODE_124 = \"podcasting_20_episode_124.srt\",\n", "    TRANSCRIPT_SRT_PODCASTING_20_EPISODE_124_OUTPUT = \"podcasting_20_episode_124_srt_parsed.json\",\n\t    TRANSCRIPT_VTT_LALALAND = \"LaLaLand.vtt\",\n\t    TRANSCRIPT_VTT_LALALAND_OUTPUT = \"LaLaLand_vtt_parsed.json\",\n\t    ONE_WORD_SEGMENTS = \"one_word_segments.json\",\n\t    ONE_WORD_SEGMENTS_OUTPUT_32 = \"one_word_segments_parsed_32.json\",\n\t    ONE_WORD_SEGMENTS_OUTPUT_50 = \"one_word_segments_parsed_50.json\",\n\t}\n\t/**\n\t * Directory to save files to during tests\n\t */\n", "const OUTPUT_DIR = path.join(__dirname, \"/test_output\")\n\t/**\n\t * Read file from `test_files` directory\n\t *\n\t * @param filename Name of file to read\n\t * @returns Data read from `filename`\n\t */\n\texport const readFile = (filename: string): string => {\n\t    const filePath = path.join(__dirname, `/test_files/${filename}`)\n\t    return readFileSync(filePath, \"utf8\")\n", "}\n\t/**\n\t * Save data to the filename specified in the {@link OUTPUT_DIR}\n\t *\n\t * @param filename Name of file to save data to\n\t * @param data Data to save to file\n\t */\n\tconst saveFile = (filename: string, data: string): void => {\n\t    if (!existsSync(OUTPUT_DIR)) {\n\t        mkdirSync(OUTPUT_DIR)\n", "    }\n\t    const filePath = path.join(OUTPUT_DIR, `/${filename}`)\n\t    writeFileSync(filePath, data, \"utf-8\")\n\t}\n\t/**\n\t * Save segments to JSON file specified by filename in {@link OUTPUT_DIR}\n\t *\n\t * @param segments Array of Segments\n\t * @param filename Name of file to save segments to\n\t */\n", "export const saveSegmentsToFile = (segments: Array<Segment>, filename: string): void => {\n\t    const data = JSON.stringify(\n\t        {\n\t            segments,\n\t        },\n\t        null,\n\t        4\n\t    )\n\t    saveFile(filename, data)\n\t}\n"]}
{"filename": "test/setup.ts", "chunked_list": ["import { beforeEach } from \"@jest/globals\"\n\timport { Options } from \"../src\"\n\tbeforeEach(() => {\n\t    Options.restoreDefaultSettings()\n\t})\n"]}
{"filename": "test/srt.test.ts", "chunked_list": ["import { describe, expect, jest, test } from \"@jest/globals\"\n\timport { IOptions, Options, Segment } from \"../src\"\n\timport { parseSRT, parseSRTSegment, SRTSegment } from \"../src/formats/srt\"\n\timport { readFile, TestFiles } from \"./test_utils\"\n\tdescribe(\"SRT segment data\", () => {\n\t    test.each<{\n\t        data: Array<string>\n\t        expected: SRTSegment\n\t        id: string\n\t    }>([\n", "        {\n\t            data: [\n\t                \"1\",\n\t                \"00:00:00,780 --> 00:00:06,210\",\n\t                \"Adam Curry: podcasting 2.0 March\",\n\t                \"4 2023 Episode 124 on D flat\",\n\t            ],\n\t            expected: {\n\t                index: 1,\n\t                startTime: 0.78,\n", "                endTime: 6.21,\n\t                speaker: \"Adam Curry\",\n\t                body: \"podcasting 2.0 March\\n4 2023 Episode 124 on D flat\",\n\t            },\n\t            id: \"comma, 2 line\",\n\t        },\n\t        {\n\t            data: [\"1\", \"00:00:00.780 --> 00:00:06.210\", \"Adam Curry: podcasting 2.0 March\"],\n\t            expected: {\n\t                index: 1,\n", "                startTime: 0.78,\n\t                endTime: 6.21,\n\t                speaker: \"Adam Curry\",\n\t                body: \"podcasting 2.0 March\",\n\t            },\n\t            id: \"period, 1 line\",\n\t        },\n\t        {\n\t            data: [\"1\", \"00:00:00,780 --> 00:00:06,210\", \"podcasting 2.0 March\", \"4 2023 Episode 124 on D flat\"],\n\t            expected: {\n", "                index: 1,\n\t                startTime: 0.78,\n\t                endTime: 6.21,\n\t                speaker: \"\",\n\t                body: \"podcasting 2.0 March\\n4 2023 Episode 124 on D flat\",\n\t            },\n\t            id: \"no speaker\",\n\t        },\n\t        {\n\t            data: [\n", "                \"1\",\n\t                \"00:00:00,780 --> 00:00:06,210\",\n\t                \"Adam Curry: podcasting 2.0 March\",\n\t                \"4 2023 Episode 124 on D flat\",\n\t                \"\",\n\t                \"2\",\n\t            ],\n\t            expected: {\n\t                index: 1,\n\t                startTime: 0.78,\n", "                endTime: 6.21,\n\t                speaker: \"Adam Curry\",\n\t                body: \"podcasting 2.0 March\\n4 2023 Episode 124 on D flat\",\n\t            },\n\t            id: \"includes separator line\",\n\t        },\n\t        {\n\t            data: [\n\t                \"1\",\n\t                \"00:00:00,780 --> 00:00:17,070\",\n", "                \"Adam Curry: podcasting 2.0 March\",\n\t                \"4 2023 Episode 124 on D flat\",\n\t                \"formable hello everybody welcome\",\n\t                \"to a delayed board meeting of\",\n\t                \"podcasting 2.0 preserving,\",\n\t                \"protecting and extending the\",\n\t            ],\n\t            expected: {\n\t                index: 1,\n\t                startTime: 0.78,\n", "                endTime: 17.07,\n\t                speaker: \"Adam Curry\",\n\t                body: \"podcasting 2.0 March\\n4 2023 Episode 124 on D flat\\nformable hello everybody welcome\\nto a delayed board meeting of\\npodcasting 2.0 preserving,\\nprotecting and extending the\",\n\t            },\n\t            id: \"large body\",\n\t        },\n\t    ])(\"SRT Segment ($id)\", ({ data, expected }) => {\n\t        expect(parseSRTSegment(data)).toEqual(expected)\n\t    })\n\t})\n", "describe(\"Undefined SRT segment data\", () => {\n\t    test.each<{\n\t        data: Array<string>\n\t        id: string\n\t    }>([\n\t        { data: [], id: \"Empty\" },\n\t        { data: [\"\"], id: \"Single Empty\" },\n\t        {\n\t            data: [\n\t                \"\",\n", "                \"00:00:00,780 --> 00:00:06,210\",\n\t                \"Adam Curry: podcasting 2.0 March\",\n\t                \"4 2023 Episode 124 on D flat\",\n\t            ],\n\t            id: \"missing index\",\n\t        },\n\t        {\n\t            data: [\n\t                \"1\",\n\t                \"00:00:00,780 -> 00:00:06,210\",\n", "                \"Adam Curry: podcasting 2.0 March\",\n\t                \"4 2023 Episode 124 on D flat\",\n\t            ],\n\t            id: \"wrong arrow\",\n\t        },\n\t        {\n\t            data: [\n\t                \"1\",\n\t                \"00:00:00,780 --> 00:00:06,210 --> 00:00:07,030\",\n\t                \"Adam Curry: podcasting 2.0 March\",\n", "                \"4 2023 Episode 124 on D flat\",\n\t            ],\n\t            id: \"duplicate arrow\",\n\t        },\n\t    ])(\"SRT Segment Undefined ($id)\", ({ data }) => {\n\t        expect(() => parseSRTSegment(data)).toThrow(Error)\n\t    })\n\t})\n\tdescribe(\"Parse SRT file data\", () => {\n\t    test.each<{\n", "        filePath: string\n\t        expectedFilePath: string\n\t        options: IOptions\n\t        id: string\n\t    }>([\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_SRT_BUZZCAST,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_SRT_BUZZCAST_OUTPUT,\n\t            options: undefined,\n\t            id: \"Buzzcast\",\n", "        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_SRT_PODCASTING_20_EPISODE_124,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_SRT_PODCASTING_20_EPISODE_124_OUTPUT,\n\t            options: undefined,\n\t            id: \"Podcasting 2.0\",\n\t        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_SRT_BUZZCAST,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_SRT_BUZZCAST_COMBINED_SEGMENTS_128_OUTPUT,\n", "            options: {\n\t                combineSegments: true,\n\t                combineSegmentsLength: 128,\n\t            },\n\t            id: \"Buzzcast, combined segments 128\",\n\t        },\n\t        {\n\t            filePath: TestFiles.TRANSCRIPT_SRT_BUZZCAST,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_SRT_BUZZCAST_SPEAKER_CHANGE_COMBINED_SEGMENTS_128_OUTPUT,\n\t            options: {\n", "                speakerChange: true,\n\t                combineSegments: true,\n\t                combineSegmentsLength: 128,\n\t            },\n\t            id: \"Buzzcast, speaker change, combined segments 128\",\n\t        },\n\t    ])(\"Parse SRT File ($id)\", ({ filePath, expectedFilePath, options }) => {\n\t        const data = readFile(filePath)\n\t        const expectedJSONData = JSON.parse(readFile(expectedFilePath))\n\t        Options.setOptions(options)\n", "        const segments = parseSRT(data)\n\t        expect(segments).toEqual(expectedJSONData.segments)\n\t    })\n\t})\n\tdescribe(\"Parse SRT data (strings)\", () => {\n\t    test.each<{\n\t        data: string\n\t        expected: Array<Segment>\n\t        id: string\n\t    }>([\n", "        {\n\t            data: `1\n\t00:00:00,780 --> 00:00:06,210\n\tAdam Curry: podcasting 2.0 March\n\t4 2023 Episode 124 on D flat\n\t2\n\t00:00:06,210 --> 00:00:12,990\n\tformable hello everybody welcome\n\tto a delayed board meeting of`,\n\t            expected: [\n", "                {\n\t                    startTime: 0.78,\n\t                    startTimeFormatted: \"00:00:00.780\",\n\t                    endTime: 6.21,\n\t                    endTimeFormatted: \"00:00:06.210\",\n\t                    speaker: \"Adam Curry\",\n\t                    body: \"podcasting 2.0 March\\n4 2023 Episode 124 on D flat\",\n\t                },\n\t                {\n\t                    startTime: 6.21,\n", "                    startTimeFormatted: \"00:00:06.210\",\n\t                    endTime: 12.99,\n\t                    endTimeFormatted: \"00:00:12.990\",\n\t                    speaker: \"Adam Curry\",\n\t                    body: \"formable hello everybody welcome\\nto a delayed board meeting of\",\n\t                },\n\t            ],\n\t            id: \"Missing trailing blank line\",\n\t        },\n\t    ])(\"Parse SRT File Data ($id)\", ({ data, expected }) => {\n", "        expect(parseSRT(data)).toEqual(expected)\n\t    })\n\t})\n\tdescribe(\"Parse Invalid SRT data (strings)\", () => {\n\t    test.each<{\n\t        data: string\n\t        consoleMessage: string | undefined\n\t        id: string\n\t    }>([\n\t        {\n", "            data: `1\n\t00:00:00,780 -> 00:00:06,210\n\tAdam Curry: podcasting 2.0 March\n\t4 2023 Episode 124 on D flat\n\t00:00:06,210 --> 00:00:12,990\n\tformable hello everybody welcome\n\tto a delayed board meeting of\n\t3\n\t00:00:12990 --> 00:00:17,070\n\tpodcasting 2.0 preserving,\n", "protecting and extending the\n\t4\n\t00:00:17,100 --> 00:00:20;220\n\topen independent podcasting\n\tecosystem that's what we're all\n\t`,\n\t            consoleMessage: undefined,\n\t            id: \"No valid SRT segment in first 20 lines\",\n\t        },\n\t        {\n", "            data: `1\n\t00:00:00,780 --> 00:00:06,210\n\tAdam Curry: podcasting 2.0 March\n\t4 2023 Episode 124 on D flat\n\t00:00:06,210 --> 00:00:12,990\n\tformable hello everybody welcome\n\tto a delayed board meeting of\n\t`,\n\t            consoleMessage: \"Error parsing SRT segment lines (source line 9)\",\n\t            id: \"Invalid segment logged\",\n", "        },\n\t        {\n\t            data: `1\n\t00:00:00,780 --> 00:00:06,210\n\tAdam Curry: podcasting 2.0 March\n\t4 2023 Episode 124 on D flat\n\t00:00:06,210 --> 00:00:12,990\n\tformable hello everybody welcome\n\tto a delayed board meeting of`,\n\t            consoleMessage: \"Error parsing final SRT segment lines\",\n", "            id: \"Invalid final segment logged\",\n\t        },\n\t    ])(\"Parse Invalid SRT File Data ($id)\", ({ data, consoleMessage }) => {\n\t        if (consoleMessage === undefined) {\n\t            expect(() => parseSRT(data)).toThrow(TypeError)\n\t        } else {\n\t            const logSpy = jest.spyOn(global.console, \"error\")\n\t            parseSRT(data)\n\t            expect(logSpy).toHaveBeenCalledWith(expect.stringContaining(consoleMessage))\n\t        }\n", "    })\n\t})\n"]}
{"filename": "test/vtt.test.ts", "chunked_list": ["import { describe, expect, test } from \"@jest/globals\"\n\timport { parseVTT } from \"../src/formats/vtt\"\n\timport { readFile, TestFiles } from \"./test_utils\"\n\tdescribe(\"Parse VTT file data\", () => {\n\t    test.each<{\n\t        filePath: string\n\t        expectedFilePath: string\n\t        id: string\n\t    }>([\n\t        {\n", "            filePath: TestFiles.TRANSCRIPT_VTT_LALALAND,\n\t            expectedFilePath: TestFiles.TRANSCRIPT_VTT_LALALAND_OUTPUT,\n\t            id: \"LaLaLand\",\n\t        },\n\t    ])(\"Parse VTT File ($id)\", ({ filePath, expectedFilePath }) => {\n\t        const data = readFile(filePath)\n\t        const expectedJSONData = JSON.parse(readFile(expectedFilePath))\n\t        const segments = parseVTT(data)\n\t        expect(segments).toEqual(expectedJSONData.segments)\n\t    })\n", "})\n"]}
{"filename": "test/options.test.ts", "chunked_list": ["import { describe, expect, test } from \"@jest/globals\"\n\timport { IOptions, Options, OptionsManager } from \"../src/options\"\n\ttest(\"Option Manager instances\", () => {\n\t    Options.setOptions({\n\t        combineSpeaker: true,\n\t    })\n\t    const second = new OptionsManager()\n\t    expect(Options === second).toBe(true)\n\t    Options.restoreDefaultSettings()\n\t})\n", "describe(\"setOptions values\", () => {\n\t    test.each<{\n\t        options: IOptions | unknown\n\t        expected: IOptions | unknown\n\t        id: string\n\t    }>([\n\t        {\n\t            options: undefined,\n\t            expected: {},\n\t            id: \"undefined options\",\n", "        },\n\t        {\n\t            options: {},\n\t            expected: {},\n\t            id: \"no options\",\n\t        },\n\t        {\n\t            options: {\n\t                combineEqualTimes: true,\n\t            },\n", "            expected: {\n\t                combineEqualTimes: true,\n\t            },\n\t            id: \"combineEqualTimes\",\n\t        },\n\t        {\n\t            options: {\n\t                combineEqualTimesSeparator: \"<br/>\",\n\t            },\n\t            expected: {\n", "                combineEqualTimesSeparator: \"<br/>\",\n\t            },\n\t            id: \"combineEqualTimesSeparator\",\n\t        },\n\t        {\n\t            options: {\n\t                combineSegments: true,\n\t            },\n\t            expected: {\n\t                combineSegments: true,\n", "            },\n\t            id: \"combineSegments\",\n\t        },\n\t        {\n\t            options: {\n\t                combineSegmentsLength: 20,\n\t            },\n\t            expected: {\n\t                combineSegmentsLength: 20,\n\t            },\n", "            id: \"combineSegmentsLength\",\n\t        },\n\t        {\n\t            options: {\n\t                combineSpeaker: true,\n\t            },\n\t            expected: {\n\t                combineSpeaker: true,\n\t            },\n\t            id: \"combineSpeaker\",\n", "        },\n\t        {\n\t            options: {\n\t                speakerChange: true,\n\t            },\n\t            expected: {\n\t                speakerChange: true,\n\t            },\n\t            id: \"speakerChange\",\n\t        },\n", "        {\n\t            options: {\n\t                combineTime: true,\n\t            },\n\t            expected: {\n\t                combineTime: undefined,\n\t            },\n\t            id: \"invalid, combineTime\",\n\t        },\n\t    ])(\"setOptions ($id)\", ({ options, expected }) => {\n", "        Options.setOptions(options)\n\t        ;(Object.keys(expected) as Array<keyof IOptions>).forEach((option) => {\n\t            const actual = Options.getOptionByName(option)\n\t            const expectedValue = expected[option]\n\t            expect(actual === expectedValue).toBe(true)\n\t        })\n\t    })\n\t})\n\tdescribe(\"Incorrect option type\", () => {\n\t    test.each<{\n", "        options: IOptions | unknown\n\t        id: string\n\t    }>([\n\t        {\n\t            options: {\n\t                combineEqualTimes: \"true\",\n\t            },\n\t            id: \"combineEqualTimes\",\n\t        },\n\t        {\n", "            options: {\n\t                combineEqualTimesSeparator: 1,\n\t            },\n\t            id: \"combineEqualTimesSeparator\",\n\t        },\n\t        {\n\t            options: {\n\t                combineSegments: \"false\",\n\t            },\n\t            id: \"combineSegments\",\n", "        },\n\t        {\n\t            options: {\n\t                combineSegmentsLength: \"20\",\n\t            },\n\t            id: \"combineSegmentsLength\",\n\t        },\n\t        {\n\t            options: {\n\t                combineSpeaker: undefined,\n", "            },\n\t            id: \"combineSpeaker\",\n\t        },\n\t        {\n\t            options: {\n\t                speakerChange: null,\n\t            },\n\t            id: \"speakerChange\",\n\t        },\n\t    ])(\"Incorrect type ($id)\", ({ options }) => {\n", "        expect(() => Options.setOptions(options)).toThrow(TypeError)\n\t    })\n\t})\n"]}
{"filename": "src/segments.ts", "chunked_list": ["import { Options } from \"./options\"\n\timport { TimestampFormatter } from \"./timestamp\"\n\timport { DEFAULT_COMBINE_SEGMENTS_LENGTH, Segment } from \"./types\"\n\t/**\n\t * Regular Expression for detecting punctuation that should not be prefixed with a space\n\t */\n\tconst PATTERN_PUNCTUATIONS = /^ *[.,?!}\\]>) *$]/\n\t/**\n\t * Regular Expression for detecting space characters at the end of a string\n\t */\n", "const PATTERN_TRAILING_SPACE = /^ *$/\n\t/**\n\t * Remove any trailing space characters from data\n\t *\n\t * @param data text to trim\n\t * @returns text with any trailing space character removed\n\t */\n\tconst trimEndSpace = (data: string): string => {\n\t    return data.replace(PATTERN_TRAILING_SPACE, \"\")\n\t}\n", "/**\n\t * Append `addition` to `body` with the character(s) specified.\n\t *\n\t * If `addition` matches the {@link PATTERN_PUNCTUATIONS} pattern, no character is added before the additional data.\n\t *\n\t * @param body Current body text\n\t * @param addition Additional text to add to `body`\n\t * @param separator Character(s) to use to separate data. If undefined, uses `\\n`.\n\t * @returns Combined data\n\t */\n", "const joinBody = (body: string, addition: string, separator: string = undefined): string => {\n\t    if (body) {\n\t        let separatorToUse = separator || \"\\n\"\n\t        if (PATTERN_PUNCTUATIONS.exec(addition)) {\n\t            separatorToUse = \"\"\n\t        }\n\t        return `${trimEndSpace(body)}${separatorToUse}${trimEndSpace(addition)}`\n\t    }\n\t    return trimEndSpace(addition)\n\t}\n", "/**\n\t * Combine one or more {@link Segment}\n\t *\n\t * @param segments Array of Segment objects to combine\n\t * @param bodySeparator Character(s) to use to separate body data. If undefined, uses `\\n`.\n\t * @returns Combined segment where:\n\t *\n\t *   - `startTime`: from first segment\n\t *   - `startTimeFormatted`: from first segment\n\t *   - `endTime`: from last segment\n", " *   - `endTimeFormatted`: from last segment\n\t *   - `speaker`: from first segment\n\t *   - `body`: combination of all segments\n\t */\n\tconst joinSegments = (segments: Array<Segment>, bodySeparator: string = undefined): Segment => {\n\t    const newSegment = { ...segments[0] }\n\t    segments.slice(1).forEach((segment) => {\n\t        newSegment.endTime = segment.endTime\n\t        newSegment.endTimeFormatted = TimestampFormatter.format(segment.endTime)\n\t        newSegment.body = joinBody(newSegment.body, segment.body, bodySeparator)\n", "    })\n\t    return newSegment\n\t}\n\t/**\n\t * Type returned from combine functions\n\t */\n\ttype CombineResult = {\n\t    /**\n\t     * The updated segment with any changes applied\n\t     */\n", "    segment: Segment\n\t    /**\n\t     * If true, the {@link segment} contains a {@link Segment} that should replace the prior segment instead of\n\t     * appending a new segment\n\t     */\n\t    replace: boolean\n\t    /**\n\t     * Indicates if the combine rule was applied\n\t     */\n\t    combined: boolean\n", "}\n\t/**\n\t * Checks if the new and prior segments have the same speaker.\n\t *\n\t * If so, combines segments where:\n\t *   - `startTime`: from priorSegment\n\t *   - `startTimeFormatted`: from priorSegment\n\t *   - `endTime`: from newSegment\n\t *   - `endTimeFormatted`: from newSegment\n\t *   - `speaker`: from priorSegment\n", " *   - `body`: body of priorSegment with body of newSegment separated with space\n\t *\n\t * @param newSegment segment being created\n\t * @param priorSegment prior parsed segment\n\t * @param lastSpeaker last speaker name.\n\t * Used when speaker in segment has been removed via {@link Options.speakerChange} rule\n\t * @returns result of combination.\n\t * If segments were combined, {@link CombineResult.replace} and {@link CombineResult.combined} set to true.\n\t */\n\tconst doCombineSpeaker = (newSegment: Segment, priorSegment: Segment, lastSpeaker: string): CombineResult => {\n", "    if (newSegment.speaker === priorSegment.speaker || newSegment.speaker === lastSpeaker) {\n\t        return {\n\t            segment: joinSegments([priorSegment, newSegment], \" \"),\n\t            replace: true,\n\t            combined: true,\n\t        }\n\t    }\n\t    return {\n\t        segment: newSegment,\n\t        replace: false,\n", "        combined: false,\n\t    }\n\t}\n\t/**\n\t * Checks if the new and prior segments have the same speaker and combining body results in new body shorter than\n\t * max length\n\t *\n\t * If so, combines segments where:\n\t *   - `startTime`: from priorSegment\n\t *   - `startTimeFormatted`: from priorSegment\n", " *   - `endTime`: from newSegment\n\t *   - `endTimeFormatted`: from newSegment\n\t *   - `speaker`: from priorSegment\n\t *   - `body`: body of priorSegment with body of newSegment separated with space\n\t *\n\t * @param newSegment segment being created\n\t * @param priorSegment prior parsed segment\n\t * @param maxLength maximum allowed length of combined body. If undefined, uses {@link DEFAULT_COMBINE_SEGMENTS_LENGTH}\n\t * @param lastSpeaker last speaker name.\n\t * Used when speaker in segment has been removed via {@link Options.speakerChange} rule\n", " * @returns result of combination.\n\t * If segments were combined, {@link CombineResult.replace} and {@link CombineResult.combined} set to true.\n\t */\n\tconst doCombineSegments = (\n\t    newSegment: Segment,\n\t    priorSegment: Segment,\n\t    maxLength: number,\n\t    lastSpeaker: string\n\t): CombineResult => {\n\t    if (priorSegment === undefined) {\n", "        return {\n\t            segment: newSegment,\n\t            replace: false,\n\t            combined: false,\n\t        }\n\t    }\n\t    const combineSegmentsLength = maxLength || DEFAULT_COMBINE_SEGMENTS_LENGTH\n\t    if (\n\t        (newSegment.speaker === priorSegment.speaker || newSegment.speaker === lastSpeaker) &&\n\t        joinBody(priorSegment.body, newSegment.body, \" \").length <= combineSegmentsLength\n", "    ) {\n\t        return {\n\t            segment: joinSegments([priorSegment, newSegment], \" \"),\n\t            replace: true,\n\t            combined: true,\n\t        }\n\t    }\n\t    return {\n\t        segment: newSegment,\n\t        replace: false,\n", "        combined: false,\n\t    }\n\t}\n\t/**\n\t * Checks if the new and prior segments have the same speaker, startTime and endTime.\n\t *\n\t * If so, combines segments where:\n\t *   - `startTime`: from priorSegment\n\t *   - `startTimeFormatted`: from priorSegment\n\t *   - `endTime`: from newSegment\n", " *   - `endTimeFormatted`: from newSegment\n\t *   - `speaker`: from priorSegment\n\t *   - `body`: body of priorSegment with body of newSegment separated with value of separator argument\n\t *\n\t * @param newSegment segment being created\n\t * @param priorSegment prior parsed segment\n\t * @param separator string to use to combine body values. If undefined, uses \"\\n\"\n\t * @param lastSpeaker last speaker name.\n\t * Used when speaker in segment has been removed via {@link Options.speakerChange} rule\n\t * @returns result of combination.\n", " * If segments were combined, {@link CombineResult.replace} and {@link CombineResult.combined} set to true.\n\t */\n\tconst doCombineEqualTimes = (\n\t    newSegment: Segment,\n\t    priorSegment: Segment,\n\t    separator: string,\n\t    lastSpeaker: string\n\t): CombineResult => {\n\t    const combineEqualTimesSeparator = separator || \"\\n\"\n\t    if (\n", "        newSegment.startTime === priorSegment.startTime &&\n\t        newSegment.endTime === priorSegment.endTime &&\n\t        (newSegment.speaker === priorSegment.speaker || newSegment.speaker === lastSpeaker)\n\t    ) {\n\t        return {\n\t            segment: joinSegments([priorSegment, newSegment], combineEqualTimesSeparator),\n\t            replace: true,\n\t            combined: true,\n\t        }\n\t    }\n", "    return {\n\t        segment: newSegment,\n\t        replace: false,\n\t        combined: false,\n\t    }\n\t}\n\t/**\n\t * Checks if the new and prior segments have the same speaker. If so, sets the speaker value to undefined\n\t *\n\t * If so, combines segments where:\n", " *   - `startTime`: from priorSegment\n\t *   - `startTimeFormatted`: from priorSegment\n\t *   - `endTime`: from newSegment\n\t *   - `endTimeFormatted`: from newSegment\n\t *   - `speaker`: from newSegment if different from priorSegment else undefined\n\t *   - `body`: body of priorSegment with body of newSegment separated with space\n\t *\n\t * @param newSegment segment being created\n\t * @param priorSegment prior parsed segment. For the first segment, this shall be undefined.\n\t * @param lastSpeaker last speaker name.\n", " * Used when speaker in segment has been removed via {@link Options.speakerChange} rule\n\t * @returns result of combination.\n\t * If segments were combined, {@link CombineResult.replace} set to false and {@link CombineResult.combined} set to true.\n\t */\n\tconst doSpeakerChange = (newSegment: Segment, priorSegment: Segment, lastSpeaker: string): CombineResult => {\n\t    const result: CombineResult = {\n\t        segment: newSegment,\n\t        replace: false,\n\t        combined: false,\n\t    }\n", "    if (priorSegment === undefined) {\n\t        if (newSegment.speaker === lastSpeaker) {\n\t            const segment: Segment = { ...newSegment }\n\t            segment.speaker = undefined\n\t            return {\n\t                segment,\n\t                replace: false,\n\t                combined: true,\n\t            }\n\t        }\n", "        return result\n\t    }\n\t    if (newSegment.speaker === undefined) {\n\t        return result\n\t    }\n\t    if (\n\t        newSegment.speaker === \"\" ||\n\t        newSegment.speaker === priorSegment.speaker ||\n\t        newSegment.speaker === lastSpeaker\n\t    ) {\n", "        const segment: Segment = { ...newSegment }\n\t        segment.speaker = undefined\n\t        return {\n\t            segment,\n\t            replace: false,\n\t            combined: true,\n\t        }\n\t    }\n\t    return result\n\t}\n", "/**\n\t * Determine how {@link Options.speakerChange is applied based an past options being applied}\n\t *\n\t * @param currentResult current result object from any prior options\n\t * @param priorSegment prior parsed segment\n\t * @param lastSpeaker last speaker name.\n\t * @returns result of combination.\n\t * If segments were combined, {@link CombineResult.replace} set to false and {@link CombineResult.combined} set to true.\n\t */\n\tconst applyOptionsAndDoSpeakerChange = (\n", "    currentResult: CombineResult,\n\t    priorSegment: Segment,\n\t    lastSpeaker: string\n\t): CombineResult => {\n\t    const { combineSegments, combineEqualTimes } = Options\n\t    let result = currentResult\n\t    if (combineSegments && currentResult.combined && currentResult.replace) {\n\t        result = doSpeakerChange(currentResult.segment, undefined, undefined)\n\t    } else if (combineEqualTimes) {\n\t        if (result.combined && result.replace) {\n", "            result = doSpeakerChange(currentResult.segment, undefined, undefined)\n\t        } else {\n\t            result = doSpeakerChange(currentResult.segment, priorSegment, lastSpeaker)\n\t        }\n\t    } else {\n\t        result = doSpeakerChange(currentResult.segment, priorSegment, lastSpeaker)\n\t    }\n\t    if (result) {\n\t        result = {\n\t            segment: result.segment,\n", "            replace: currentResult.replace || result.replace,\n\t            combined: currentResult.combined || result.combined,\n\t        }\n\t    }\n\t    return result\n\t}\n\t/**\n\t * Apply convert rules when no prior segment exits.\n\t *\n\t * NOTE: not all rules applicable when no prior segment\n", " *\n\t * @param newSegment segment before any rules options to it\n\t * @param lastSpeaker last speaker name.\n\t * Used when speaker in segment has been removed via {@link Options.speakerChange} rule\n\t * @returns the updated segment info\n\t */\n\tconst doCombineNoPrior = (newSegment: Segment, lastSpeaker: string): CombineResult => {\n\t    const { speakerChange } = Options\n\t    let result: CombineResult = {\n\t        segment: newSegment,\n", "        replace: false,\n\t        combined: false,\n\t    }\n\t    if (speakerChange) {\n\t        result = doSpeakerChange(result.segment, undefined, lastSpeaker)\n\t    }\n\t    return result\n\t}\n\t/**\n\t * Apply convert rules when prior segment exits.\n", " *\n\t * @param newSegment segment before any rules options to it\n\t * @param priorSegment prior parsed segment\n\t * @param lastSpeaker last speaker name.\n\t * Used when speaker in segment has been removed via {@link Options.speakerChange} rule\n\t * @returns the updated segment info\n\t */\n\tconst doCombineWithPrior = (newSegment: Segment, priorSegment: Segment, lastSpeaker: string): CombineResult => {\n\t    const {\n\t        combineEqualTimes,\n", "        combineEqualTimesSeparator,\n\t        combineSegments,\n\t        combineSegmentsLength,\n\t        combineSpeaker,\n\t        speakerChange,\n\t    } = Options\n\t    let result: CombineResult = {\n\t        segment: { ...newSegment },\n\t        replace: false,\n\t        combined: false,\n", "    }\n\t    let combinedSpeaker = false\n\t    if (combineSpeaker) {\n\t        result = doCombineSpeaker(result.segment, priorSegment, lastSpeaker)\n\t        combinedSpeaker = result.combined\n\t    }\n\t    if (!combinedSpeaker && combineEqualTimes) {\n\t        result = doCombineEqualTimes(result.segment, priorSegment, combineEqualTimesSeparator, lastSpeaker)\n\t    }\n\t    if (!combinedSpeaker && combineSegments) {\n", "        let combineResult\n\t        if (combineEqualTimes && result.combined) {\n\t            combineResult = doCombineSegments(result.segment, undefined, combineSegmentsLength, lastSpeaker)\n\t        } else {\n\t            combineResult = doCombineSegments(result.segment, priorSegment, combineSegmentsLength, lastSpeaker)\n\t        }\n\t        if (combineResult) {\n\t            result = {\n\t                segment: combineResult.segment,\n\t                replace: result.replace || combineResult.replace,\n", "                combined: result.combined || combineResult.combined,\n\t            }\n\t        }\n\t    }\n\t    if (speakerChange) {\n\t        result = applyOptionsAndDoSpeakerChange(result, priorSegment, lastSpeaker)\n\t    }\n\t    return result\n\t}\n\t/**\n", " * Apply any options to the current segment\n\t *\n\t * @param newSegment segment before any rules options to it\n\t * @param priorSegment prior parsed segment. For the first segment, this shall be undefined.\n\t * @param lastSpeaker last speaker name.\n\t * Used when speaker in segment has been removed via {@link Options.speakerChange} rule\n\t * @returns the updated segment info\n\t */\n\tconst applyOptions = (newSegment: Segment, priorSegment: Segment, lastSpeaker: string = undefined): CombineResult => {\n\t    if (!Options.optionsSet()) {\n", "        return {\n\t            segment: newSegment,\n\t            replace: false,\n\t            combined: false,\n\t        }\n\t    }\n\t    let result: CombineResult\n\t    // if no prior segment, limited additional checking\n\t    if (priorSegment === undefined) {\n\t        result = doCombineNoPrior(newSegment, lastSpeaker)\n", "    } else {\n\t        result = doCombineWithPrior(newSegment, priorSegment, lastSpeaker)\n\t    }\n\t    return result\n\t}\n\t/**\n\t * Get the last speaker name from the previously parsed segments\n\t *\n\t * @param priorSegment prior parsed segment\n\t * @param priorSegments array of all previous segments\n", " * @returns the name of the last speaker\n\t */\n\tconst getLastSpeaker = (priorSegment: Segment, priorSegments: Array<Segment>): string => {\n\t    let lastSpeaker\n\t    if (priorSegment) {\n\t        lastSpeaker = priorSegment.speaker\n\t    }\n\t    if (lastSpeaker === undefined && priorSegments.length > 0) {\n\t        lastSpeaker = priorSegments[0].speaker\n\t        for (let i = priorSegments.length - 1; i > 0; i--) {\n", "            if (priorSegments[i].speaker !== undefined) {\n\t                lastSpeaker = priorSegments[i].speaker\n\t                break\n\t            }\n\t        }\n\t    }\n\t    return lastSpeaker\n\t}\n\t/**\n\t * Helper for adding segment to or updating last segment in array of segments\n", " *\n\t * @param newSegment segment to add or replace\n\t * @param priorSegments array of all previous segments\n\t * @returns updated array of segments with new segment added or last segment updated (per options)\n\t */\n\texport const addSegment = (newSegment: Segment, priorSegments: Array<Segment>): Array<Segment> => {\n\t    const { speakerChange } = Options\n\t    const outSegments = priorSegments || []\n\t    const priorSegment = outSegments.length > 0 ? outSegments[outSegments.length - 1] : undefined\n\t    // don't worry about identifying the last speaker if speaker is not being removed by speakerChange\n", "    let lastSpeaker: string\n\t    if (speakerChange) {\n\t        lastSpeaker = getLastSpeaker(priorSegment, outSegments)\n\t    }\n\t    const newSegmentInfo = applyOptions(newSegment, priorSegment, lastSpeaker)\n\t    if (newSegmentInfo.replace && outSegments.length > 0) {\n\t        outSegments[outSegments.length - 1] = newSegmentInfo.segment\n\t    } else {\n\t        outSegments.push(newSegmentInfo.segment)\n\t    }\n", "    return outSegments\n\t}\n"]}
{"filename": "src/speaker.ts", "chunked_list": ["/**\n\t * Regular expression for detecting speaker in string\n\t */\n\tconst PATTERN_SPEAKER = /^(?<speaker>[a-z].+?): (?<body>.*)/i\n\t/**\n\t * Attempt to extract the speaker's name from the data.\n\t *\n\t * Looks for the strings in the format matching {@link PATTERN_SPEAKER}\n\t *\n\t * @param data Data to get speaker from\n", " * @returns The speaker (if found) and the remaining string\n\t */\n\texport const parseSpeaker = (data: string): { speaker: string; message: string } => {\n\t    let speaker = \"\"\n\t    let message = data\n\t    const speakerMatch = PATTERN_SPEAKER.exec(data)\n\t    if (speakerMatch !== null) {\n\t        speaker = speakerMatch.groups.speaker\n\t        message = speakerMatch.groups.body\n\t    }\n", "    return { speaker, message }\n\t}\n"]}
{"filename": "src/types.ts", "chunked_list": ["/**\n\t * Regular expression to detect both `\\r\\n` and `\\n` line endings\n\t */\n\texport const PATTERN_LINE_SEPARATOR = /\\r?\\n/\n\t/**\n\t * Enum of all supported transcript formats\n\t */\n\texport enum TranscriptFormat {\n\t    /**\n\t     * Data is HTML\n", "     */\n\t    HTML = \"html\",\n\t    /**\n\t     * Data is JSON\n\t     */\n\t    JSON = \"json\",\n\t    /**\n\t     * Data is {@link https://en.wikipedia.org/wiki/SubRip|SRT}\n\t     */\n\t    SRT = \"srt\",\n", "    /**\n\t     * Data is {@link https://en.wikipedia.org/wiki/WebVTT|WebVTT}\n\t     */\n\t    VTT = \"vtt\",\n\t}\n\t/**\n\t * Define a segment/cue\n\t */\n\texport type Segment = {\n\t    /**\n", "     * Time (in seconds) when segment starts\n\t     */\n\t    startTime: number\n\t    /**\n\t     * Time when segment starts formatted as a string in the format HH:mm:SS.fff\n\t     */\n\t    startTimeFormatted: string\n\t    /**\n\t     * Time (in seconds) when segment ends\n\t     */\n", "    endTime: number\n\t    /**\n\t     * Time when segment ends formatted as a string in the format HH:mm:SS.fff\n\t     */\n\t    endTimeFormatted: string\n\t    /**\n\t     * Name of speaker for `body`\n\t     */\n\t    speaker?: string\n\t    /**\n", "     * Text of transcript for segment\n\t     */\n\t    body: string\n\t}\n\t/**\n\t * Default length to use when combining segments with {@link Options.combineSegments}\n\t */\n\texport const DEFAULT_COMBINE_SEGMENTS_LENGTH = 32\n"]}
{"filename": "src/options.ts", "chunked_list": ["import { DEFAULT_COMBINE_SEGMENTS_LENGTH } from \"./types\"\n\t/**\n\t * Verifies the type of the value matches the expected type\n\t *\n\t * @param name name of option to check value for\n\t * @param expectedType expected type off the value for the option\n\t * @param value value to check\n\t * @throws TypeError When value is invalid type for option\n\t */\n\tconst verifyType = (name: string, expectedType: string, value: unknown): void => {\n", "    if (typeof value !== expectedType) {\n\t        throw new TypeError(`Invalid type ${typeof value} for ${name}. Expected ${expectedType}`)\n\t    }\n\t}\n\texport interface IOptions {\n\t    /**\n\t     * Combine segments if the {@link Segment.startTime}, {@link Segment.endTime}, and {@link Segment.speaker} match\n\t     * between the current and prior segments\n\t     *\n\t     * Can be used with {@link combineSegments}. The {@link combineEqualTimes} rule is applied first.\n", "     *\n\t     * Can be used with {@link speakerChange}. The {@link speakerChange} rule is applied last.\n\t     *\n\t     * Cannot be used with {@link combineSpeaker}\n\t     */\n\t    combineEqualTimes?: boolean\n\t    /**\n\t     * Character to use when {@link combineEqualTimes} is true.\n\t     *\n\t     * Default: `\\n`\n", "     */\n\t    combineEqualTimesSeparator?: string\n\t    /**\n\t     * Combine segments where speaker is the same and concatenated `body` fits in the {@link combineSegmentsLength}\n\t     *\n\t     * Can be used with {@link combineEqualTimes}. The {@link combineSegments} rule is applied first.\n\t     *\n\t     * Can be used with {@link speakerChange}. The {@link speakerChange} rule is applied last.\n\t     *\n\t     * Cannot be used with {@link combineSpeaker}\n", "     */\n\t    combineSegments?: boolean\n\t    /**\n\t     * Max length of body text to use when {@link combineSegments} is true\n\t     *\n\t     * Default: See {@link DEFAULT_COMBINE_SEGMENTS_LENGTH}\n\t     */\n\t    combineSegmentsLength?: number\n\t    /**\n\t     * Combine consecutive segments from the same speaker.\n", "     *\n\t     * Note: If this is enabled, {@link combineEqualTimes} and {@link combineSegments} will not be applied.\n\t     *\n\t     * Warning: if the transcript does not contain speaker information, resulting segment will contain entire transcript text.\n\t     */\n\t    combineSpeaker?: boolean\n\t    /**\n\t     * Only include {@link Segment.speaker} when speaker changes\n\t     *\n\t     * May be used in combination with {@link combineSpeaker}, {@link combineEqualTimes}, or {@link combineSegments}\n", "     */\n\t    speakerChange?: boolean\n\t}\n\t/**\n\t * Provides a way to convert numeric timestamp to a formatted string.\n\t *\n\t * A custom formatter may be registered.\n\t * If one isn't registered, the default formatter will be used and the data will be formatted as HH:mm:SS.fff\n\t */\n\texport class OptionsManager implements IOptions {\n", "    static _instance: OptionsManager\n\t    /**\n\t     * Combine segments if the {@link Segment.startTime}, {@link Segment.endTime}, and {@link Segment.speaker} match\n\t     * between the current and prior segments\n\t     *\n\t     * Can be used with {@link combineSegments}. The {@link combineEqualTimes} rule is applied first.\n\t     *\n\t     * Can be used with {@link speakerChange}. The {@link speakerChange} rule is applied last.\n\t     *\n\t     * Cannot be used with {@link combineSpeaker}\n", "     */\n\t    public combineEqualTimes = false\n\t    /**\n\t     * Character to use when {@link combineEqualTimes} is true.\n\t     */\n\t    public combineEqualTimesSeparator = \"\\n\"\n\t    /**\n\t     * Combine segments where speaker is the same and concatenated `body` fits in the {@link combineSegmentsLength}\n\t     *\n\t     * Can be used with {@link combineEqualTimes}. The {@link combineSegments} rule is applied first.\n", "     *\n\t     * Can be used with {@link speakerChange}. The {@link speakerChange} rule is applied last.\n\t     *\n\t     * Cannot be used with {@link combineSpeaker}\n\t     */\n\t    public combineSegments = false\n\t    /**\n\t     * Max length of body text to use when {@link combineSegments} is true\n\t     */\n\t    public combineSegmentsLength: number = DEFAULT_COMBINE_SEGMENTS_LENGTH\n", "    /**\n\t     * Combine consecutive segments from the same speaker.\n\t     *\n\t     * Note: If this is enabled, {@link combineEqualTimes} and {@link combineSegments} will not be applied.\n\t     *\n\t     * Warning: if the transcript does not contain speaker information, resulting segment will contain entire transcript text.\n\t     */\n\t    public combineSpeaker = false\n\t    /**\n\t     * Only include {@link Segment.speaker} when speaker changes\n", "     *\n\t     * May be used in combination with {@link combineSpeaker}, {@link combineEqualTimes}, or {@link combineSegments}\n\t     */\n\t    public speakerChange = false\n\t    /**\n\t     * Create the options manager\n\t     */\n\t    constructor() {\n\t        if (!OptionsManager._instance) {\n\t            OptionsManager._instance = this\n", "        }\n\t        // eslint-disable-next-line no-constructor-return\n\t        return OptionsManager._instance\n\t    }\n\t    /**\n\t     * Get option value from it's name\n\t     *\n\t     * @param name name of option to get\n\t     * @returns value of option. If unknown, returns undefined\n\t     */\n", "    public getOptionByName = (name: string): boolean | string | number => {\n\t        let actual\n\t        switch (name) {\n\t            case \"combineEqualTimes\":\n\t                actual = this.combineEqualTimes\n\t                break\n\t            case \"combineEqualTimesSeparator\":\n\t                actual = this.combineEqualTimesSeparator\n\t                break\n\t            case \"combineSegments\":\n", "                actual = this.combineSegments\n\t                break\n\t            case \"combineSegmentsLength\":\n\t                actual = this.combineSegmentsLength\n\t                break\n\t            case \"combineSpeaker\":\n\t                actual = this.combineSpeaker\n\t                break\n\t            case \"speakerChange\":\n\t                actual = this.speakerChange\n", "                break\n\t            default:\n\t                break\n\t        }\n\t        return actual\n\t    }\n\t    /**\n\t     * Set option value using it's name\n\t     *\n\t     * @param name name of option to set\n", "     * @param value value to set option to\n\t     */\n\t    public setOptionByName = (name: string, value: boolean | string | number): void => {\n\t        switch (name) {\n\t            case \"combineEqualTimes\":\n\t                verifyType(name, \"boolean\", value)\n\t                this.combineEqualTimes = <boolean>value\n\t                break\n\t            case \"combineEqualTimesSeparator\":\n\t                verifyType(name, \"string\", value)\n", "                this.combineEqualTimesSeparator = <string>value\n\t                break\n\t            case \"combineSegments\":\n\t                verifyType(name, \"boolean\", value)\n\t                this.combineSegments = <boolean>value\n\t                break\n\t            case \"combineSegmentsLength\":\n\t                verifyType(name, \"number\", value)\n\t                this.combineSegmentsLength = <number>value\n\t                break\n", "            case \"combineSpeaker\":\n\t                verifyType(name, \"boolean\", value)\n\t                this.combineSpeaker = <boolean>value\n\t                break\n\t            case \"speakerChange\":\n\t                verifyType(name, \"boolean\", value)\n\t                this.speakerChange = <boolean>value\n\t                break\n\t            default:\n\t                break\n", "        }\n\t    }\n\t    /**\n\t     * Set all options to their default value\n\t     */\n\t    public restoreDefaultSettings = (): void => {\n\t        this.setOptions(\n\t            {\n\t                combineEqualTimes: false,\n\t                combineEqualTimesSeparator: \"\\n\",\n", "                combineSegments: false,\n\t                combineSegmentsLength: DEFAULT_COMBINE_SEGMENTS_LENGTH,\n\t                combineSpeaker: false,\n\t                speakerChange: false,\n\t            },\n\t            false\n\t        )\n\t    }\n\t    /**\n\t     * Set one or more options\n", "     *\n\t     * @param options the options to set\n\t     * @param setDefault true: set all values to the default before setting values specified by `options`\n\t     */\n\t    public setOptions = (options: IOptions, setDefault = true): void => {\n\t        if (setDefault) {\n\t            this.restoreDefaultSettings()\n\t        }\n\t        if (options === undefined) {\n\t            return\n", "        }\n\t        ;(Object.keys(options) as Array<keyof IOptions>).forEach((option) => {\n\t            this.setOptionByName(option, options[option])\n\t        })\n\t    }\n\t    /**\n\t     * Helper to determine if at least one option should be applied\n\t     *\n\t     * @returns true: at least one option set\n\t     */\n", "    public optionsSet = (): boolean => {\n\t        const { combineEqualTimes, combineSegments, combineSpeaker, speakerChange } = this\n\t        return combineEqualTimes || combineSegments || combineSpeaker || speakerChange\n\t    }\n\t}\n\texport const Options = new OptionsManager()\n"]}
{"filename": "src/timestamp.ts", "chunked_list": ["/**\n\t * Regular expression for detecting all valid timestamps\n\t */\n\tconst PATTERN_TIMESTAMP = /^(?<time>((?<hour>\\d+):|)((?<minute>\\d+):|)((?<second>\\d+)|))([,.](?<ms>\\d+|)|)$/m\n\t/**\n\t * Parse timestamp from value\n\t *\n\t * Supported formats must match {@link PATTERN_TIMESTAMP}\n\t *\n\t * @param value Value to parse timestamp from. If number, assumes already a timestamp in seconds.\n", " * @returns Parsed timestamp in seconds\n\t * @throws {TypeError} When value is not a string\n\t * @throws {TypeError} When value does not match {@link PATTERN_TIMESTAMP}\n\t */\n\texport const parseTimestamp = (value: string | number): number => {\n\t    if (typeof value === \"number\") {\n\t        return value\n\t    }\n\t    if (typeof value !== \"string\") {\n\t        throw new TypeError(`Cannot parse timestamp of type ${typeof value}}`)\n", "    }\n\t    const match = PATTERN_TIMESTAMP.exec(value.trim())\n\t    if (match === null) {\n\t        throw new TypeError(`Not enough separator fields in timestamp string`)\n\t    }\n\t    const { time } = match.groups\n\t    const splits = time.split(\":\")\n\t    const splitLength = splits.length\n\t    let timestamp = 0\n\t    if (splitLength === 3) {\n", "        timestamp = parseInt(splits[0], 10) * 60 * 60 + parseInt(splits[1], 10) * 60 + parseInt(splits[2], 10)\n\t    } else if (splitLength === 2) {\n\t        timestamp = parseInt(splits[0], 10) * 60 + parseInt(splits[1], 10)\n\t    } else if (splitLength === 1) {\n\t        timestamp = parseInt(splits[0], 10)\n\t    }\n\t    let ms = parseInt(match.groups.ms, 10)\n\t    if (Number.isNaN(ms)) {\n\t        ms = 0\n\t    } else if (ms !== 0) {\n", "        ms /= 1000\n\t    }\n\t    timestamp += ms\n\t    return timestamp\n\t}\n\t/**\n\t * Timestamp formatter\n\t */\n\texport interface FormatterCallback {\n\t    (timestamp: number): string\n", "}\n\t/**\n\t * Provides a way to convert numeric timestamp to a formatted string.\n\t *\n\t * A custom formatter may be registered.\n\t * If one isn't registered, the default formatter will be used and the data will be formatted as HH:mm:SS.fff\n\t */\n\texport class TimestampFormatterManager {\n\t    static _instance: TimestampFormatterManager\n\t    private customFormatter: FormatterCallback = undefined\n", "    /**\n\t     * Create the formatter\n\t     */\n\t    constructor() {\n\t        if (!TimestampFormatterManager._instance) {\n\t            TimestampFormatterManager._instance = this\n\t        }\n\t        // eslint-disable-next-line no-constructor-return\n\t        return TimestampFormatterManager._instance\n\t    }\n", "    /**\n\t     * Default formatter where the timestamp number is formatted to a human readable string in the format HH:mm:SS.fff\n\t     *\n\t     * @param timestamp Time in seconds to format\n\t     * @returns formatted timestamp string\n\t     */\n\t    private static defaultFormatter = (timestamp: number): string => {\n\t        const hours = String(Math.floor(timestamp / 3600)).padStart(2, \"0\")\n\t        const remaining = timestamp % 3600\n\t        const minutes = String(Math.floor(remaining / 60)).padStart(2, \"0\")\n", "        const seconds = String(Math.floor(remaining % 60)).padStart(2, \"0\")\n\t        const ms = String(Math.round((timestamp - Math.floor(timestamp)) * 1000)).padStart(3, \"0\")\n\t        return `${hours}:${minutes}:${seconds}.${ms}`\n\t    }\n\t    /**\n\t     * Format the timestamp to a human readable string.\n\t     *\n\t     * If a custom formatter has been registered, it will be used.\n\t     * If not, the default formatter is used and the data will be returned in the format HH:mm:SS.fff\n\t     *\n", "     * @param timestamp Time in seconds to format\n\t     * @returns formatted timestamp string\n\t     */\n\t    public format = (timestamp: number): string => {\n\t        if (this.customFormatter === undefined) {\n\t            return TimestampFormatterManager.defaultFormatter(timestamp)\n\t        }\n\t        return this.customFormatter(timestamp)\n\t    }\n\t    /**\n", "     * Register a custom timestamp formatter\n\t     *\n\t     * @param formatter function to call to format timestamp to string\n\t     */\n\t    public registerCustomFormatter = (formatter: FormatterCallback): void => {\n\t        this.customFormatter = formatter\n\t    }\n\t    /**\n\t     * Remove the custom formatter (if one registered)\n\t     */\n", "    public unregisterCustomFormatter = (): void => {\n\t        this.customFormatter = undefined\n\t    }\n\t}\n\texport const TimestampFormatter = new TimestampFormatterManager()\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { isHTML, parseHTML } from \"./formats/html\"\n\timport { isJSON, parseJSON } from \"./formats/json\"\n\timport { isSRT, parseSRT } from \"./formats/srt\"\n\timport { isVTT, parseVTT } from \"./formats/vtt\"\n\timport { Segment, TranscriptFormat } from \"./types\"\n\texport { Segment, TranscriptFormat } from \"./types\"\n\texport { TimestampFormatter, FormatterCallback } from \"./timestamp\"\n\texport { Options, IOptions } from \"./options\"\n\t/**\n\t * Determines the format of transcript by inspecting the data\n", " *\n\t * @param data The transcript data\n\t * @returns The determined transcript format\n\t * @throws {TypeError} Cannot determine format of data or error parsing data\n\t */\n\texport const determineFormat = (data: string): TranscriptFormat => {\n\t    const normalizedData = data.trim()\n\t    if (isVTT(normalizedData)) {\n\t        return TranscriptFormat.VTT\n\t    }\n", "    if (isJSON(normalizedData)) {\n\t        return TranscriptFormat.JSON\n\t    }\n\t    if (isHTML(normalizedData)) {\n\t        return TranscriptFormat.HTML\n\t    }\n\t    if (isSRT(normalizedData)) {\n\t        return TranscriptFormat.SRT\n\t    }\n\t    throw new TypeError(`Cannot determine format for data`)\n", "}\n\t/**\n\t * Convert the data to an Array of {@link Segment}\n\t *\n\t * @param data The transcript data\n\t * @param transcriptFormat The format of the data.\n\t * @returns An Array of Segment objects from the parsed data\n\t * @throws {TypeError} When `transcriptFormat` is unknown\n\t */\n\texport const convertFile = (data: string, transcriptFormat: TranscriptFormat = undefined): Array<Segment> => {\n", "    const format = transcriptFormat ?? determineFormat(data)\n\t    const normalizedData = data.trimStart()\n\t    let outSegments: Array<Segment> = []\n\t    switch (format) {\n\t        case TranscriptFormat.HTML:\n\t            outSegments = parseHTML(normalizedData)\n\t            break\n\t        case TranscriptFormat.JSON:\n\t            outSegments = parseJSON(normalizedData)\n\t            break\n", "        case TranscriptFormat.SRT:\n\t            outSegments = parseSRT(normalizedData)\n\t            break\n\t        case TranscriptFormat.VTT:\n\t            outSegments = parseVTT(normalizedData)\n\t            break\n\t        default:\n\t            throw new TypeError(`Unknown transcript format: ${format}`)\n\t    }\n\t    return outSegments\n", "}\n"]}
{"filename": "src/formats/html.ts", "chunked_list": ["import { HTMLElement, parse } from \"node-html-parser\"\n\timport { addSegment } from \"../segments\"\n\timport { parseTimestamp, TimestampFormatter } from \"../timestamp\"\n\timport { Segment } from \"../types\"\n\t/**\n\t * Regular expression to detect `<html>` tag\n\t */\n\tconst PATTERN_HTML_TAG = /^< *html.*?>/i\n\t/**\n\t * Regular expression to detect transcript data where `<time>` is followed by `<p>`\n", " */\n\tconst PATTERN_HTML_TIME_P = /(?<time><time>\\d[\\d:.,]*?<\\/time>)[ \\t\\r\\n]*?(?<body><p>.*?<\\/p>)/i\n\t/**\n\t * Regular expression to detect transcript data where `<p>` is followed by `<time>`\n\t */\n\tconst PATTERN_HTML_P_TIME = /(?<body><p>.*?<\\/p>)[ \\t\\r\\n]*?(?<time><time>\\d[\\d:.,]*?<\\/time>)/i\n\ttype HTMLSegmentPart = {\n\t    cite: string\n\t    time: string\n\t    text: string\n", "}\n\t/**\n\t * Determines if the value of data is a valid HTML transcript format\n\t *\n\t * @param data The transcript data\n\t * @returns True: data is valid HTML transcript format\n\t */\n\texport const isHTML = (data: string): boolean => {\n\t    return (\n\t        data.startsWith(\"<!--\") ||\n", "        PATTERN_HTML_TAG.test(data) ||\n\t        PATTERN_HTML_TIME_P.test(data) ||\n\t        PATTERN_HTML_P_TIME.test(data)\n\t    )\n\t}\n\t/**\n\t * Updates HTML Segment parts if expected HTML segment\n\t *\n\t * @param element HTML segment to check\n\t * @param segmentPart Current segment parts\n", " * @returns Updated HTML Segment part and segment data for next segment (if fields encountered)\n\t */\n\tconst updateSegmentPartFromElement = (\n\t    element: HTMLElement,\n\t    segmentPart: HTMLSegmentPart\n\t): {\n\t    current: HTMLSegmentPart\n\t    next: HTMLSegmentPart\n\t} => {\n\t    const currentSegmentPart = segmentPart\n", "    const nextSegmentPart: HTMLSegmentPart = {\n\t        cite: \"\",\n\t        time: \"\",\n\t        text: \"\",\n\t    }\n\t    if (element.tagName === \"CITE\") {\n\t        if (currentSegmentPart.cite === \"\") {\n\t            currentSegmentPart.cite = element.innerHTML\n\t        } else {\n\t            nextSegmentPart.cite = element.innerHTML\n", "        }\n\t    } else if (element.tagName === \"TIME\") {\n\t        if (currentSegmentPart.time === \"\") {\n\t            currentSegmentPart.time = element.innerHTML\n\t        } else {\n\t            nextSegmentPart.time = element.innerHTML\n\t        }\n\t    } else if (element.tagName === \"P\") {\n\t        if (currentSegmentPart.text === \"\") {\n\t            currentSegmentPart.text = element.innerHTML\n", "        } else {\n\t            nextSegmentPart.text = element.innerHTML\n\t        }\n\t    }\n\t    return { current: currentSegmentPart, next: nextSegmentPart }\n\t}\n\t/**\n\t * Create Segment from HTML segment parts\n\t *\n\t * @param segmentPart HTML segment data\n", " * @param lastSpeaker Name of last speaker. Will be used if no speaker found in `segmentLines`\n\t * @returns Created segment\n\t */\n\tconst createSegmentFromSegmentPart = (segmentPart: HTMLSegmentPart, lastSpeaker: string): Segment => {\n\t    const calculatedSpeaker = segmentPart.cite ? segmentPart.cite : lastSpeaker\n\t    const startTime = parseTimestamp(segmentPart.time)\n\t    return {\n\t        startTime,\n\t        startTimeFormatted: TimestampFormatter.format(startTime),\n\t        endTime: 0,\n", "        endTimeFormatted: TimestampFormatter.format(0),\n\t        speaker: calculatedSpeaker.replace(\":\", \"\").trimEnd(),\n\t        body: segmentPart.text,\n\t    }\n\t}\n\t/**\n\t * Parse HTML data and create {@link Segment} for each segment data found in data\n\t *\n\t * @param elements HTML elements containing transcript data\n\t * @returns Segments created from HTML data\n", " */\n\tconst getSegmentsFromHTMLElements = (elements: Array<HTMLElement>): Array<Segment> => {\n\t    let outSegments: Array<Segment> = []\n\t    let lastSpeaker = \"\"\n\t    let segmentPart: HTMLSegmentPart = {\n\t        cite: \"\",\n\t        time: \"\",\n\t        text: \"\",\n\t    }\n\t    let nextSegmentPart: HTMLSegmentPart = {\n", "        cite: \"\",\n\t        time: \"\",\n\t        text: \"\",\n\t    }\n\t    elements.forEach((element, count) => {\n\t        const segmentParts = updateSegmentPartFromElement(element, segmentPart)\n\t        segmentPart = segmentParts.current\n\t        nextSegmentPart = segmentParts.next\n\t        if (\n\t            count === elements.length - 1 ||\n", "            Object.keys(nextSegmentPart).filter((x) => nextSegmentPart[x] === \"\").length !== 3\n\t        ) {\n\t            // time is required\n\t            if (segmentPart.time === \"\") {\n\t                console.warn(`Segment ${count} does not contain time information, ignoring`)\n\t            } else {\n\t                const segment = createSegmentFromSegmentPart(segmentPart, lastSpeaker)\n\t                lastSpeaker = segment.speaker\n\t                // update endTime of previous Segment\n\t                const totalSegments = outSegments.length\n", "                if (totalSegments > 0) {\n\t                    outSegments[totalSegments - 1].endTime = segment.startTime\n\t                    outSegments[totalSegments - 1].endTimeFormatted = TimestampFormatter.format(\n\t                        outSegments[totalSegments - 1].endTime\n\t                    )\n\t                }\n\t                outSegments = addSegment(segment, outSegments)\n\t            }\n\t            // clear\n\t            segmentPart = nextSegmentPart\n", "            nextSegmentPart = {\n\t                cite: \"\",\n\t                time: \"\",\n\t                text: \"\",\n\t            }\n\t        }\n\t    })\n\t    return outSegments\n\t}\n\t/**\n", " * Parse HTML data to an Array of {@link Segment}\n\t *\n\t * @param data The transcript data\n\t * @returns An array of Segments from the parsed data\n\t * @throws {TypeError} When `data` is not valid HTML format\n\t */\n\texport const parseHTML = (data: string): Array<Segment> => {\n\t    const dataTrimmed = data.trim()\n\t    if (!isHTML(dataTrimmed)) {\n\t        throw new TypeError(`Data is not valid HTML format`)\n", "    }\n\t    const html = parse(data)\n\t    let root: HTMLElement\n\t    const htmlElements = html.getElementsByTagName(\"html\")\n\t    if (htmlElements.length === 0) {\n\t        root = html\n\t    } else {\n\t        const htmlElement = htmlElements[0]\n\t        const bodyElements = htmlElement.getElementsByTagName(\"body\")\n\t        if (bodyElements.length > 0) {\n", "            // eslint-disable-next-line prefer-destructuring\n\t            root = bodyElements[0]\n\t        } else {\n\t            root = htmlElement\n\t        }\n\t    }\n\t    return getSegmentsFromHTMLElements(root.childNodes as Array<HTMLElement>)\n\t}\n"]}
{"filename": "src/formats/json.ts", "chunked_list": ["import { addSegment } from \"../segments\"\n\timport { parseSpeaker } from \"../speaker\"\n\timport { TimestampFormatter } from \"../timestamp\"\n\timport { Segment } from \"../types\"\n\t/**\n\t * Define a segment/cue used in the JSONTranscript format\n\t */\n\texport type JSONSegment = {\n\t    /**\n\t     * Time (in seconds) when segment starts\n", "     */\n\t    startTime: number\n\t    /**\n\t     * Time (in seconds) when segment ends\n\t     */\n\t    endTime: number\n\t    /**\n\t     * Name of speaker for `body`\n\t     */\n\t    speaker?: string\n", "    /**\n\t     * Text of transcript for segment\n\t     */\n\t    body: string\n\t}\n\t/**\n\t * Define the JSON transcript format\n\t */\n\texport type JSONTranscript = {\n\t    /**\n", "     * Version of file format\n\t     */\n\t    version: string\n\t    /**\n\t     * Segment data\n\t     */\n\t    segments: Array<JSONSegment>\n\t}\n\t/**\n\t * Define the JSON transcript Segment format\n", " */\n\texport type SubtitleSegment = {\n\t    /**\n\t     * Time (in milliseconds) when segment starts\n\t     */\n\t    start: number\n\t    /**\n\t     * Time (in milliseconds) when segment ends\n\t     */\n\t    end: number\n", "    /**\n\t     * Text of transcript for segment\n\t     */\n\t    text: string\n\t}\n\t/**\n\t * Determines if the value of data is a valid JSON transcript format\n\t *\n\t * @param data The transcript data\n\t * @returns True: data is valid JSON transcript format\n", " */\n\texport const isJSON = (data: string): boolean => {\n\t    return (data.startsWith(\"{\") && data.endsWith(\"}\")) || (data.startsWith(\"[\") && data.endsWith(\"]\"))\n\t}\n\t/**\n\t * Parse JSON data where segments are in the `segments` Array and in the {@link JSONSegment} format\n\t *\n\t * @param data Parsed JSON data\n\t * @returns An array of Segments from the parsed data\n\t */\n", "const parseDictSegmentsJSON = (data: JSONTranscript): Array<Segment> => {\n\t    let outSegments: Array<Segment> = []\n\t    data.segments.forEach((segment) => {\n\t        outSegments = addSegment(\n\t            {\n\t                startTime: segment.startTime,\n\t                startTimeFormatted: TimestampFormatter.format(segment.startTime),\n\t                endTime: segment.endTime,\n\t                endTimeFormatted: TimestampFormatter.format(segment.endTime),\n\t                speaker: segment.speaker,\n", "                body: segment.body,\n\t            },\n\t            outSegments\n\t        )\n\t    })\n\t    return outSegments\n\t}\n\t/**\n\t * Parse JSON data where top level item is a dict/object\n\t *\n", " * @param data The transcript data\n\t * @returns An array of Segments from the parsed data\n\t * @throws {TypeError} When JSON data does not match one of the valid formats\n\t */\n\tconst parseDictJSON = (data: object): Array<Segment> => {\n\t    let outSegments: Array<Segment> = []\n\t    if (Object.keys(data).length === 0) {\n\t        return outSegments\n\t    }\n\t    if (\"segments\" in data) {\n", "        outSegments = parseDictSegmentsJSON(data as JSONTranscript)\n\t    } else {\n\t        throw new TypeError(`Unknown JSON dict transcript format`)\n\t    }\n\t    return outSegments\n\t}\n\t/**\n\t * Convert {@link SubtitleSegment} to the {@link Segment} format used here\n\t *\n\t * @param data Segment parsed from JSON data\n", " * @returns Segment representing `data`.\n\t * Returns {@link undefined} when data does not match {@link SubtitleSegment} format.\n\t */\n\tconst getSegmentFromSubtitle = (data: SubtitleSegment): Segment => {\n\t    if (\"start\" in data && \"end\" in data && \"text\" in data) {\n\t        const { speaker, message } = parseSpeaker(data.text)\n\t        const startTime = data.start / 1000\n\t        const endTime = data.end / 1000\n\t        const segment: Segment = {\n\t            startTime,\n", "            startTimeFormatted: TimestampFormatter.format(startTime),\n\t            endTime,\n\t            endTimeFormatted: TimestampFormatter.format(endTime),\n\t            speaker,\n\t            body: message,\n\t        }\n\t        if (Number.isNaN(segment.startTime)) {\n\t            console.warn(`Computed start time is NaN: ${segment.startTime}`)\n\t            return undefined\n\t        }\n", "        if (Number.isNaN(segment.endTime)) {\n\t            console.warn(`Computed end time is NaN: ${segment.endTime}`)\n\t            return undefined\n\t        }\n\t        return segment\n\t    }\n\t    return undefined\n\t}\n\t/**\n\t * Parse JSON data where items in data are in the {@link SubtitleSegment} format\n", " *\n\t * @param data Parsed JSON data\n\t * @returns An array of Segments from the parsed data\n\t * @throws {TypeError} When item in `data` does not match the {@link SubtitleSegment} format\n\t */\n\tconst parseListJSONSubtitle = (data: Array<SubtitleSegment>): Array<Segment> => {\n\t    let outSegments: Array<Segment> = []\n\t    let lastSpeaker = \"\"\n\t    data.forEach((subtitle, count) => {\n\t        const subtitleSegment = getSegmentFromSubtitle(subtitle)\n", "        if (subtitleSegment !== undefined) {\n\t            lastSpeaker = subtitleSegment.speaker ? subtitleSegment.speaker : lastSpeaker\n\t            subtitleSegment.speaker = lastSpeaker\n\t            outSegments = addSegment(subtitleSegment, outSegments)\n\t        } else {\n\t            throw new TypeError(`Unable to parse segment for item ${count}`)\n\t        }\n\t    })\n\t    return outSegments\n\t}\n", "/**\n\t * Parse JSON data where top level item is an Array\n\t *\n\t * @param data The transcript data\n\t * @returns An array of Segments from the parsed data\n\t * @throws {TypeError} When JSON data does not match one of the valid formats\n\t */\n\tconst parseListJSON = (data: Array<unknown>): Array<Segment> => {\n\t    let outSegments: Array<Segment> = []\n\t    if (data.length === 0) {\n", "        return outSegments\n\t    }\n\t    const subtitleSegment = getSegmentFromSubtitle(data[0] as SubtitleSegment)\n\t    if (subtitleSegment !== undefined) {\n\t        outSegments = parseListJSONSubtitle(data as Array<SubtitleSegment>)\n\t    } else {\n\t        throw new TypeError(`Unknown JSON list transcript format`)\n\t    }\n\t    return outSegments\n\t}\n", "/**\n\t * Parse JSON data to an Array of {@link Segment}\n\t *\n\t * @param data The transcript data\n\t * @returns An array of Segments from the parsed data\n\t * @throws {TypeError} When `data` is not valid JSON format\n\t */\n\texport const parseJSON = (data: string): Array<Segment> => {\n\t    const dataTrimmed = data.trim()\n\t    let outSegments: Array<Segment> = []\n", "    if (!isJSON(dataTrimmed)) {\n\t        throw new TypeError(`Data is not valid JSON format`)\n\t    }\n\t    let parsed: object | Array<unknown>\n\t    try {\n\t        parsed = JSON.parse(data)\n\t    } catch (e) {\n\t        throw new TypeError(`Data is not valid JSON: ${e}`)\n\t    }\n\t    if (parsed.constructor === Object) {\n", "        outSegments = parseDictJSON(parsed)\n\t    } else if (parsed.constructor === Array) {\n\t        outSegments = parseListJSON(parsed)\n\t    }\n\t    return outSegments\n\t}\n"]}
{"filename": "src/formats/vtt.ts", "chunked_list": ["import { Segment } from \"../types\"\n\timport { parseSRT } from \"./srt\"\n\t/**\n\t * Required header for WebVTT/VTT files\n\t */\n\tconst WEBVTT_HEADER = \"WEBVTT\"\n\t/**\n\t * Determines if the value of data is a valid VTT transcript format\n\t *\n\t * @param data The transcript data\n", " * @returns True: data is valid VTT transcript format\n\t */\n\texport const isVTT = (data: string): boolean => {\n\t    return data.startsWith(\"WEBVTT\")\n\t}\n\t/**\n\t * Parse VTT data to an Array of {@link Segment}\n\t *\n\t * @param data The transcript data\n\t * @returns An array of Segments from the parsed data\n", " * @throws {TypeError} When `data` is not valid VTT format\n\t */\n\texport const parseVTT = (data: string): Array<Segment> => {\n\t    if (!isVTT(data)) {\n\t        throw new TypeError(`Data is not valid VTT format`)\n\t    }\n\t    // format is similar enough to SRT to be parsed by the same parser\n\t    // Remove WEBVTT header first\n\t    return parseSRT(data.substring(WEBVTT_HEADER.length).trimStart())\n\t}\n"]}
{"filename": "src/formats/srt.ts", "chunked_list": ["import { addSegment } from \"../segments\"\n\timport { parseSpeaker } from \"../speaker\"\n\timport { parseTimestamp, TimestampFormatter } from \"../timestamp\"\n\timport { PATTERN_LINE_SEPARATOR, Segment } from \"../types\"\n\t/**\n\t * Define a segment/cue parsed from SRT file\n\t */\n\texport type SRTSegment = {\n\t    /**\n\t     * Cue number\n", "     */\n\t    index: number\n\t    /**\n\t     * Time (in seconds) when segment starts\n\t     */\n\t    startTime: number\n\t    /**\n\t     * Time (in seconds) when segment ends\n\t     */\n\t    endTime: number\n", "    /**\n\t     * Name of speaker for `body`\n\t     */\n\t    speaker: string\n\t    /**\n\t     * Text of transcript for segment\n\t     */\n\t    body: string\n\t}\n\t/**\n", " * Parse lines looking for data to be SRT format\n\t *\n\t * @param lines Lines containing SRT data\n\t * @returns Parsed segment\n\t * @throws {Error} When no non-empty strings in `lines`\n\t * @throws {Error} When the minimum required number of lines is not received\n\t * @throws {Error} When segment lines does not start with a number\n\t * @throws {Error} When second segment line does not follow the timestamp format\n\t */\n\texport const parseSRTSegment = (lines: Array<string>): SRTSegment => {\n", "    do {\n\t        if (lines.length === 0) {\n\t            throw new Error(\"SRT segment lines empty\")\n\t        } else if (lines[0].trim() === \"\") {\n\t            lines.shift()\n\t        } else {\n\t            break\n\t        }\n\t    } while (lines.length > 0)\n\t    if (lines.length < 3) {\n", "        throw new Error(`SRT requires at least 3 lines, ${lines.length} received`)\n\t    }\n\t    const index = parseInt(lines[0], 10)\n\t    if (!index) {\n\t        throw new Error(`First line of SRT segment is not a number`)\n\t    }\n\t    const timestampLine = lines[1]\n\t    if (!timestampLine.includes(\"-->\")) {\n\t        throw new Error(`SRT timestamp line does not include --> separator`)\n\t    }\n", "    const timestampParts = timestampLine.split(\"-->\")\n\t    if (timestampParts.length !== 2) {\n\t        throw new Error(`SRT timestamp line contains more than 2 --> separators`)\n\t    }\n\t    const startTime = parseTimestamp(timestampParts[0].trim())\n\t    const endTime = parseTimestamp(timestampParts[1].trim())\n\t    let bodyLines = lines.slice(2)\n\t    const emptyLineIndex = bodyLines.findIndex((v) => v.trim() === \"\")\n\t    if (emptyLineIndex > 0) {\n\t        bodyLines = bodyLines.slice(0, emptyLineIndex)\n", "    }\n\t    const { speaker, message } = parseSpeaker(bodyLines.shift())\n\t    bodyLines = [message].concat(bodyLines)\n\t    return {\n\t        startTime,\n\t        endTime,\n\t        speaker,\n\t        body: bodyLines.join(\"\\n\"),\n\t        index,\n\t    }\n", "}\n\t/**\n\t * Create Segment from lines containing an SRT segment/cue\n\t *\n\t * @param segmentLines Lines containing SRT data\n\t * @param lastSpeaker Name of last speaker. Will be used if no speaker found in `segmentLines`\n\t * @returns Created segment\n\t */\n\tconst createSegmentFromSRTLines = (segmentLines: Array<string>, lastSpeaker: string): Segment => {\n\t    const srtSegment = parseSRTSegment(segmentLines)\n", "    const calculatedSpeaker = srtSegment.speaker ? srtSegment.speaker : lastSpeaker\n\t    return {\n\t        startTime: srtSegment.startTime,\n\t        startTimeFormatted: TimestampFormatter.format(srtSegment.startTime),\n\t        endTime: srtSegment.endTime,\n\t        endTimeFormatted: TimestampFormatter.format(srtSegment.endTime),\n\t        speaker: calculatedSpeaker,\n\t        body: srtSegment.body,\n\t    }\n\t}\n", "/**\n\t * Determines if the value of data is a valid SRT transcript format\n\t *\n\t * @param data The transcript data\n\t * @returns True: data is valid SRT transcript format\n\t */\n\texport const isSRT = (data: string): boolean => {\n\t    try {\n\t        return parseSRTSegment(data.split(PATTERN_LINE_SEPARATOR).slice(0, 20)) !== undefined\n\t    } catch (e) {\n", "        return false\n\t    }\n\t}\n\t/**\n\t * Parse SRT data to an Array of {@link Segment}\n\t *\n\t * @param data The transcript data\n\t * @returns An array of Segments from the parsed data\n\t * @throws {TypeError} When `data` is not valid SRT format\n\t */\n", "export const parseSRT = (data: string): Array<Segment> => {\n\t    if (!isSRT(data)) {\n\t        throw new TypeError(`Data is not valid SRT format`)\n\t    }\n\t    let outSegments: Array<Segment> = []\n\t    let lastSpeaker = \"\"\n\t    let segmentLines = []\n\t    data.split(PATTERN_LINE_SEPARATOR).forEach((line, count) => {\n\t        // separator line found, handle previous data\n\t        if (line.trim() === \"\") {\n", "            // handle consecutive multiple blank lines\n\t            if (segmentLines.length !== 0) {\n\t                try {\n\t                    outSegments = addSegment(createSegmentFromSRTLines(segmentLines, lastSpeaker), outSegments)\n\t                    lastSpeaker = outSegments[outSegments.length - 1].speaker\n\t                } catch (e) {\n\t                    console.error(`Error parsing SRT segment lines (source line ${count}): ${e}`)\n\t                    console.error(segmentLines)\n\t                }\n\t            }\n", "            segmentLines = [] // clear buffer\n\t        } else {\n\t            segmentLines.push(line)\n\t        }\n\t    })\n\t    // handle data when trailing line not included\n\t    if (segmentLines.length !== 0) {\n\t        try {\n\t            outSegments = addSegment(createSegmentFromSRTLines(segmentLines, lastSpeaker), outSegments)\n\t            lastSpeaker = outSegments[outSegments.length - 1].speaker\n", "        } catch (e) {\n\t            console.error(`Error parsing final SRT segment lines: ${e}`)\n\t            console.error(segmentLines)\n\t        }\n\t    }\n\t    return outSegments\n\t}\n"]}
