{"filename": "src/index.ts", "chunked_list": ["#! /usr/bin/env node\n\timport { Command } from \"commander\";\n\timport SummaryProgram from \"./programs/summary-program.js\";\n\timport figlet from \"figlet\";\n\timport ConfigureProgram from \"./programs/configure/configure-program.js\";\n\timport TranslateProgram from \"./programs/translate-program.js\";\n\timport UnderstandProgram from \"./programs/understand-program.js\";\n\timport ChatProgram from \"./programs/chat-program.js\";\n\timport PromptProgram from \"./programs/prompt-program.js\";\n\tconst version = \"0.1.5\";\n", "const description =\n\t  \"A super charged CLI for interfacing with GPT-3 and other AI services\";\n\tasync function main(): Promise<void> {\n\t  console.log(figlet.textSync(\"GPT CLI\"));\n\t  // Create a new command instance for the program and configure it with root commands\n\t  const cliApp = new Command()\n\t    .version(version)\n\t    .description(description)\n\t    .option(\"-d, --debug\", \"toggles verbose logging\", false);\n\t  // Configure the help command\n", "  cliApp.configureHelp({\n\t    sortSubcommands: true,\n\t    sortOptions: true,\n\t    showGlobalOptions: true,\n\t    subcommandDescription(cmd) {\n\t      return cmd.description();\n\t    },\n\t    subcommandTerm: (cmd: Command): string => {\n\t      let term = cmd.name();\n\t      if (cmd.aliases().length > 0) {\n", "        term += `, ${cmd.aliases().join(\", \")}`;\n\t      }\n\t      return term;\n\t    },\n\t  });\n\t  // Confifgure the programs\n\t  new SummaryProgram().configure(cliApp);\n\t  new ConfigureProgram().configure(cliApp);\n\t  new TranslateProgram().configure(cliApp);\n\t  new UnderstandProgram().configure(cliApp);\n", "  new ChatProgram().configure(cliApp);\n\t  new PromptProgram().configure(cliApp);\n\t  // Parse the args for the program\n\t  await cliApp.parseAsync(process.argv);\n\t}\n\tmain();\n"]}
{"filename": "src/langchain/open-ai-chat-helper.ts", "chunked_list": ["import { initializeAgentExecutor, Tool } from \"langchain/agents\";\n\timport { LLMChain, ChatVectorDBQAChain } from \"langchain/chains\";\n\timport { LLM } from \"langchain/llms\";\n\timport { BufferMemory } from \"langchain/memory\";\n\timport {\n\t  ChatPromptTemplate,\n\t  HumanMessagePromptTemplate,\n\t  SystemMessagePromptTemplate,\n\t} from \"langchain/prompts\";\n\timport { Calculator, SerpAPI } from \"langchain/tools\";\n", "import { VectorStore } from \"langchain/vectorstores\";\n\timport * as cliChat from \"./helpers/cli-chat-helper.js\";\n\timport CurrencyConversionTool from \"./tools/currency-conversion-tool.js\";\n\tconst { Document: LangDocument } = await import(\"langchain/document\");\n\tconst { loadSummarizationChain } = await import(\"langchain/chains\");\n\tconst { OpenAIChat } = await import(\"langchain/llms\");\n\tconst { CallbackManager } = await import(\"langchain/callbacks\");\n\tinterface OpenAiChatHelperInput {\n\t  model?: string;\n\t  temperature?: number;\n", "  verbose?: boolean;\n\t}\n\tinterface SummarizationOptions {\n\t  type: \"map_reduce\" | \"stuff\";\n\t  split: number;\n\t}\n\tinterface TranslationOptions {\n\t  source: string;\n\t  output: string;\n\t}\n", "interface AgentToolOptions {\n\t  tools?: { [name: string]: Tool };\n\t}\n\tfunction getToolsList(input?: AgentToolOptions) {\n\t  return Object.values(input?.tools ?? {});\n\t}\n\tclass OpenAiChatHelper {\n\t  public model: LLM;\n\t  constructor(input: OpenAiChatHelperInput) {\n\t    let params = {\n", "      temperature: input.temperature ?? 0.7,\n\t      modelName: input.model ?? \"gpt-3.5-turbo\",\n\t      verbose: input.verbose ?? false,\n\t      callbackManager: null as any,\n\t    };\n\t    if (params.verbose) {\n\t      params.callbackManager = OpenAiChatHelper.defaultCallBackManager;\n\t    }\n\t    this.model = new OpenAIChat(params);\n\t  }\n", "  public static get defaultCallBackManager() {\n\t    return CallbackManager.fromHandlers({\n\t      handleLLMStart: async (llm: { name: string }, prompts: string[]) => {\n\t        console.log(JSON.stringify(llm, null, 2));\n\t        console.log(JSON.stringify(prompts, null, 2));\n\t      },\n\t      handleLLMEnd: async (output: any) => {\n\t        console.log(JSON.stringify(output, null, 2));\n\t      },\n\t      handleLLMError: async (err: Error) => {\n", "        console.error(err);\n\t      },\n\t    });\n\t  }\n\t  public static get noCallBackManager() {\n\t    return CallbackManager.fromHandlers({});\n\t  }\n\t  /*\n\t     ____                                             \n\t    / ___| _   _ _ __ ___  _ __ ___   __ _ _ __ _   _ \n", "    \\___ \\| | | | '_ ` _ \\| '_ ` _ \\ / _` | '__| | | |\n\t     ___) | |_| | | | | | | | | | | | (_| | |  | |_| |\n\t    |____/ \\__,_|_| |_| |_|_| |_| |_|\\__,_|_|   \\__, |\n\t                                                |___/ \n\t*/\n\t  public async summarize(\n\t    text: string,\n\t    options: SummarizationOptions = {\n\t      type: \"map_reduce\",\n\t      split: 3000,\n", "    }\n\t  ): Promise<string> {\n\t    // Loads in the chain\n\t    const chain = loadSummarizationChain(this.model, { type: options.type });\n\t    // Create the documents\n\t    let docs = [];\n\t    if (options.type === \"map_reduce\") {\n\t      const { RecursiveCharacterTextSplitter } = await import(\n\t        \"langchain/text_splitter\"\n\t      );\n", "      const textSplitter = new RecursiveCharacterTextSplitter({\n\t        chunkSize: options.split,\n\t      });\n\t      docs = await textSplitter.createDocuments([text]);\n\t    } else {\n\t      docs = [new LangDocument({ pageContent: text })];\n\t    }\n\t    // Summarize\n\t    const res = await chain.call({\n\t      input_documents: docs,\n", "    });\n\t    // Output the result\n\t    return res.text;\n\t  }\n\t  /*\n\t     _____                    _       _       \n\t    |_   _| __ __ _ _ __  ___| | __ _| |_ ___ \n\t      | || '__/ _` | '_ \\/ __| |/ _` | __/ _ \\\n\t      | || | | (_| | | | \\__ \\ | (_| | ||  __/\n\t      |_||_|  \\__,_|_| |_|___/_|\\__,_|\\__\\___|\n", "*/\n\t  public async translate(\n\t    text: string,\n\t    options: TranslationOptions = {\n\t      source: \"auto\",\n\t      output: \"english\",\n\t    }\n\t  ): Promise<string> {\n\t    const template =\n\t      \"You are a helpful assistant that takes text in {input_language} and only responds with its translation in {output_language}.\";\n", "    const autoTemplate =\n\t      \"You are a helpful assistant that detects the language of the input and only responds with its translation in {output_language}.\";\n\t    let promptTemplate = template;\n\t    if (options.source === \"auto\") {\n\t      promptTemplate = autoTemplate;\n\t    }\n\t    const chatPrompt = ChatPromptTemplate.fromPromptMessages([\n\t      SystemMessagePromptTemplate.fromTemplate(promptTemplate),\n\t      HumanMessagePromptTemplate.fromTemplate(\"{text}\"),\n\t    ]);\n", "    const chain = new LLMChain({ llm: this.model, prompt: chatPrompt });\n\t    const response = await chain.call({\n\t      input_language: options.source,\n\t      output_language: options.output,\n\t      text: text,\n\t    });\n\t    return response.text;\n\t  }\n\t  /*\n\t     _   _           _               _                  _ \n", "    | | | |_ __   __| | ___ _ __ ___| |_ __ _ _ __   __| |\n\t    | | | | '_ \\ / _` |/ _ \\ '__/ __| __/ _` | '_ \\ / _` |\n\t    | |_| | | | | (_| |  __/ |  \\__ \\ || (_| | | | | (_| |\n\t     \\___/|_| |_|\\__,_|\\___|_|  |___/\\__\\__,_|_| |_|\\__,_|\n\t*/\n\t  // Runs a chat on the vector store\n\t  public async understand(info: VectorStore): Promise<void> {\n\t    const qaTemplate = `Use the following pieces of context to answer the question at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.\n\t    {context}\n\t    Chat History:\n", "    {chat_history}\n\t    Question: {question}\n\t    Helpful Answer:`;\n\t    // define chat vars\n\t    const chain = ChatVectorDBQAChain.fromLLM(this.model, info, {\n\t      k: 2,\n\t      qaTemplate: qaTemplate,\n\t    });\n\t    // Options for the chat\n\t    const runner = async (\n", "      input: string,\n\t      history: string[]\n\t    ): Promise<cliChat.ChatRunnerOutput> => {\n\t      const result = await chain.call({\n\t        question: input,\n\t        chat_history: history,\n\t      });\n\t      return { output: result.text };\n\t    };\n\t    // Run the chat\n", "    await cliChat.run({ runner, inputTitle: \"Question\" });\n\t  }\n\t  /*\n\t      ____ _           _   \n\t     / ___| |__   __ _| |_ \n\t    | |   | '_ \\ / _` | __|\n\t    | |___| | | | (_| | |_ \n\t     \\____|_| |_|\\__,_|\\__|\n\t*/\n\t  public async chat(input?: AgentToolOptions): Promise<void> {\n", "    // Create the chat agent\n\t    const executor = await initializeAgentExecutor(\n\t      getToolsList(input), // input any tools\n\t      this.model,\n\t      \"chat-conversational-react-description\",\n\t      this.model.verbose\n\t    );\n\t    // Add memory to the agent\n\t    executor.memory = new BufferMemory({\n\t      returnMessages: true,\n", "      memoryKey: \"chat_history\",\n\t      inputKey: \"input\",\n\t    });\n\t    // Options for the chat helper\n\t    const runner = async (\n\t      input: string,\n\t      _: string[]\n\t    ): Promise<cliChat.ChatRunnerOutput> => {\n\t      const result = await executor.call({ input });\n\t      return { output: result.output };\n", "    };\n\t    // Run the chat\n\t    await cliChat.run({ runner, historyUpdate: cliChat.noHistoryUpdate });\n\t  }\n\t  /*\n\t     _____             ____  _           _     ____                 _   \n\t    |__  /___ _ __ ___/ ___|| |__   ___ | |_  |  _ \\ ___  __ _  ___| |_ \n\t      / // _ \\ '__/ _ \\___ \\| '_ \\ / _ \\| __| | |_) / _ \\/ _` |/ __| __|\n\t     / /|  __/ | | (_) |__) | | | | (_) | |_  |  _ <  __/ (_| | (__| |_ \n\t    /____\\___|_|  \\___/____/|_| |_|\\___/ \\__| |_| \\_\\___|\\__,_|\\___|\\__|\n", "*/\n\t  public async zeroShot(input?: AgentToolOptions): Promise<void> {\n\t    // Create the chat zero shot agent\n\t    const executor = await initializeAgentExecutor(\n\t      getToolsList(input), // input any tools\n\t      this.model,\n\t      \"chat-zero-shot-react-description\",\n\t      this.model.verbose\n\t    );\n\t    this.model.callbackManager = OpenAiChatHelper.noCallBackManager; // Leave logging to the executor\n", "    // Options for the chat helper\n\t    const runner = async (\n\t      input: string,\n\t      _: string[]\n\t    ): Promise<cliChat.ChatRunnerOutput> => {\n\t      const result = await executor.call({ input });\n\t      return { output: result.output, stop: true };\n\t    };\n\t    // Run the chat\n\t    await cliChat.run({ runner, historyUpdate: cliChat.noHistoryUpdate });\n", "  }\n\t}\n\texport default OpenAiChatHelper;\n"]}
{"filename": "src/langchain/tools/finnhub-stock-price-tool.ts", "chunked_list": ["import { Quote } from \"@stoqey/finnhub\";\n\timport { SymbolData } from \"@stoqey/finnhub/dist/api/fundamentals/interface.js\";\n\timport { Tool } from \"langchain/tools\";\n\tconst { FinnhubAPI } = await import(\"@stoqey/finnhub\");\n\tinterface RawQuoteData extends SymbolData {\n\t  quote: Quote | null;\n\t}\n\tinterface QuoteData extends SymbolData {\n\t  quote: Quote;\n\t}\n", "class FinnhubStockPriceTool extends Tool {\n\t  name: string;\n\t  description: string;\n\t  apiKey: string;\n\t  constructor(apiKey: string | undefined) {\n\t    super();\n\t    if (!apiKey) {\n\t      throw new Error(\"No apiKey provided\");\n\t    }\n\t    this.apiKey = apiKey as string;\n", "    this.name = \"stockPrice\";\n\t    this.description =\n\t      \"a stock value checker. useful for when you need to find the out up to date price of a stock in USD, however, does not work for products. input only should be the stock symbol or stock name and nothing else.\";\n\t  }\n\t  protected async _call(input: string, verbose?: boolean): Promise<string> {\n\t    const api = new FinnhubAPI(this.apiKey);\n\t    try {\n\t      // search for the stock symbol\n\t      const lookup = await api.symbolLookup(input);\n\t      if ((lookup?.count ?? 0) === 0) {\n", "        return `No stocks found for ${input}`;\n\t      }\n\t      // filter the lookup to 10 results\n\t      const symbols = lookup!.result.slice(0, Math.min(10, lookup!.count));\n\t      if (verbose) console.log(symbols.map((s) => s.symbol).join(\", \"));\n\t      // map the symbols to parallel quote requests\n\t      const requests = symbols.map(\n\t        async (symbol: SymbolData): Promise<RawQuoteData> => {\n\t          const quote = await api.getQuote(symbol.symbol).catch(() => null);\n\t          return {\n", "            ...symbol,\n\t            quote: quote,\n\t          };\n\t        }\n\t      );\n\t      // wait for all the requests to complete\n\t      const quotes: QuoteData[] = (await Promise.all(requests))\n\t        .filter((q) => q.quote && q.quote.close > 0)\n\t        .map((q) => {\n\t          return q as QuoteData;\n", "        });\n\t      if (quotes.length === 0) {\n\t        return `No stocks found for ${input}`;\n\t      }\n\t      if (verbose) console.log(quotes);\n\t      // collect the stock prices into a bullet list\n\t      const stockPrices = quotes\n\t        .map((q) => {\n\t          return `- The current price of ${q.description} (${q.displaySymbol}) is $${q.quote.close} USD as of ${q.quote.date}`;\n\t        })\n", "        .join(\"\\n\");\n\t      // return the stock prices\n\t      return `Stock Prices: \\n${stockPrices}`;\n\t    } catch (e) {\n\t      throw new Error(`Got error from finnhub API: ${e}`);\n\t    }\n\t  }\n\t}\n\texport default FinnhubStockPriceTool;\n"]}
{"filename": "src/langchain/tools/value-serp-tool.ts", "chunked_list": ["import axios from \"axios\";\n\timport { Tool } from \"langchain/tools\";\n\tconst value_serp_url = \"https://api.valueserp.com/search\";\n\tclass ValueSerpAPI extends Tool {\n\t  name: string;\n\t  description: string;\n\t  apiKey: string;\n\t  constructor(apiKey: string | undefined) {\n\t    super();\n\t    if (!apiKey) {\n", "      throw new Error(\"No apiKey provided\");\n\t    }\n\t    this.apiKey = apiKey as string;\n\t    this.name = \"search\";\n\t    this.description =\n\t      \"a search engine. useful for when you need to answer questions about current events. input should be a search query.\";\n\t  }\n\t  protected async _call(input: string): Promise<string> {\n\t    const params = this.getParams(input);\n\t    try {\n", "      const response = await axios.get(value_serp_url, { params });\n\t      const data = response.data;\n\t      return this.extractData(data);\n\t    } catch (e) {\n\t      throw new Error(`Got error from valueSerpAPI: ${e}`);\n\t    }\n\t  }\n\t  private getParams(input: string): any {\n\t    return {\n\t      api_key: this.apiKey,\n", "      q: input,\n\t      hl: \"en\",\n\t      google_domain: \"google.com\",\n\t      gl: \"us\",\n\t    };\n\t  }\n\t  private extractData(data: any): string {\n\t    let response: string = \"\";\n\t    // answer box\n\t    if (data?.answer_box?.answers) {\n", "      const answers = (data.answer_box.answers as any[])\n\t        .map((e) => `- ${e.answer}`)\n\t        .join(\"\\n\");\n\t      response += \"Possible Answers: \\n\" + answers + \"\\n\\n\";\n\t    }\n\t    // knowledge graph\n\t    if (data?.knowledge_graph?.description) {\n\t      response +=\n\t        \"Additional Information: \\n- \" +\n\t        data.knowledge_graph.description +\n", "        \"\\n\\n\";\n\t    }\n\t    // QA results\n\t    if (data?.related_questions) {\n\t      const questions = data.related_questions.slice(\n\t        0,\n\t        Math.min(3, data.related_questions.length)\n\t      );\n\t      const results = questions\n\t        .map((e: any) => `[Q]: ${e.question}\\n[A]: ${e.answer}`)\n", "        .join(\"\\n---\\n\");\n\t      response += \"Related Question Responses: \\n\" + results + \"\\n\\n\";\n\t    }\n\t    // organic web results, only run if there is no response\n\t    if (data?.organic_results) {\n\t      const organgicResults = data.organic_results.slice(\n\t        0,\n\t        Math.min(3, data.organic_results.length)\n\t      );\n\t      const results = organgicResults\n", "        .map((e: any) => `- [${e.title}]: ${e.snippet}`)\n\t        .join(\"\\n\");\n\t      response += \"Top Web Results: \\n\" + results + \"\\n\\n\";\n\t    }\n\t    // defualt response\n\t    if (response.length === 0) {\n\t      return \"No good search result found\";\n\t    }\n\t    return response;\n\t  }\n", "}\n\texport default ValueSerpAPI;\n"]}
{"filename": "src/langchain/tools/currency-conversion-tool.ts", "chunked_list": ["import axios from \"axios\";\n\timport { Tool } from \"langchain/tools\";\n\tconst conversion_url =\n\t  \"https://cdn.jsdelivr.net/gh/fawazahmed0/currency-api@1/latest/currencies\";\n\tclass CurrencyConversionTool extends Tool {\n\t  name: string;\n\t  description: string;\n\t  constructor() {\n\t    super();\n\t    this.name = \"currency-convert\";\n", "    this.description =\n\t      'a currency exchange tool. useful for when you need to convert currency values. input should comma seperated text containin the 2 ISO codes for the currencies. Example Input:\"usd,cad\"';\n\t  }\n\t  protected async _call(input: string): Promise<string> {\n\t    const { from, to } = this.extractParams(input);\n\t    try {\n\t      const response = await this.getConversion(from, to);\n\t      return `1 ${from.toUpperCase()} = ${response} ${to.toUpperCase()}`;\n\t    } catch (e) {}\n\t    return \"Could not find a conversion rate for that currency pair.\";\n", "  }\n\t  private extractParams(input: string): { from: string; to: string } {\n\t    const [from, to] = input.toLowerCase().split(\",\");\n\t    return { from, to };\n\t  }\n\t  private async getConversion(from: string, to: string): Promise<number> {\n\t    const response = await axios.get(`${conversion_url}/${from}/${to}.json`);\n\t    const data = response.data;\n\t    return data[to];\n\t  }\n", "}\n\texport default CurrencyConversionTool;\n"]}
{"filename": "src/langchain/helpers/cli-chat-helper.ts", "chunked_list": ["import * as readline from \"readline\";\n\tinterface ChatRunnerOutput {\n\t  output: string;\n\t  stop?: boolean;\n\t}\n\tinterface ChatOptions {\n\t  runner: (input: string, history: string[]) => Promise<ChatRunnerOutput>;\n\t  historyUpdate?: (\n\t    input: string,\n\t    output: string,\n", "    history: string[]\n\t  ) => string[];\n\t  inputTitle?: string;\n\t}\n\tfunction noHistoryUpdate(_: string, __: string, history: string[]): string[] {\n\t  return history;\n\t}\n\tfunction defaultHistoryUpdate(\n\t  input: string,\n\t  output: string,\n", "  history: string[]\n\t): string[] {\n\t  return [...history, `User: ${input}`, `Chat: ${output}`];\n\t}\n\tasync function run(options: ChatOptions): Promise<string[]> {\n\t  const userInputString = `----------\\n${\n\t    options.inputTitle ?? \"Input\"\n\t  }:\\n----------`;\n\t  const chatInputString = `----------\\nResponse:\\n----------`;\n\t  const rl = readline.createInterface({\n", "    input: process.stdin,\n\t    output: process.stdout,\n\t  });\n\t  function closeChat(print: boolean = true): void {\n\t    if (print) {\n\t      console.log();\n\t      console.log(\"Exiting chat\");\n\t    }\n\t    rl.close();\n\t  }\n", "  // State\n\t  let chatHistory: string[] = [];\n\t  // start the chat\n\t  console.log();\n\t  console.log('Type \"..\" to exit');\n\t  console.log();\n\t  console.log(userInputString);\n\t  rl.on(\"line\", async (input) => {\n\t    // Exit the chat\n\t    if (input === \"..\") {\n", "      return closeChat();\n\t    }\n\t    // Run the query\n\t    console.log();\n\t    const { output: result, stop } = await options.runner(input, chatHistory);\n\t    // Print resopnse and next question prompt\n\t    console.log();\n\t    console.log(chatInputString);\n\t    console.log(result);\n\t    // Exit the chat\n", "    if (stop) {\n\t      return closeChat(false);\n\t    }\n\t    console.log();\n\t    console.log(userInputString);\n\t    // Update the chat history\n\t    chatHistory =\n\t      options.historyUpdate?.(input, result, chatHistory) ??\n\t      defaultHistoryUpdate(input, result, chatHistory);\n\t  });\n", "  return chatHistory;\n\t}\n\texport {\n\t  ChatOptions,\n\t  ChatRunnerOutput,\n\t  run,\n\t  defaultHistoryUpdate,\n\t  noHistoryUpdate,\n\t};\n"]}
{"filename": "src/langchain/services/embedding-service.ts", "chunked_list": ["const __filename = fileURLToPath(import.meta.url);\n\tconst __dirname = path.join(path.dirname(__filename), \"vectors\", \"hsnw\");\n\timport path from \"path\";\n\timport { fileURLToPath } from \"url\";\n\timport { HNSWLib, VectorStore } from \"langchain/vectorstores\";\n\timport { RecursiveCharacterTextSplitter } from \"langchain/text_splitter\";\n\timport { Embeddings, OpenAIEmbeddings } from \"langchain/embeddings\";\n\tinterface EmbeddingInputBase {\n\t  embedding?: Embeddings;\n\t  debug?: boolean;\n", "}\n\tinterface EmbeddingLoadInput extends EmbeddingInputBase {\n\t  path: string;\n\t}\n\tinterface EmbeddingInput extends EmbeddingInputBase {\n\t  documents: string[];\n\t  path?: string;\n\t  chunkSize?: number;\n\t}\n\t// Singleton class named EmbeddingDirectory\n", "class EmbeddingDirectory {\n\t  private static instance: EmbeddingDirectory;\n\t  private constructor() {}\n\t  public static getInstance(): EmbeddingDirectory {\n\t    if (!EmbeddingDirectory.instance) {\n\t      EmbeddingDirectory.instance = new EmbeddingDirectory();\n\t    }\n\t    return EmbeddingDirectory.instance;\n\t  }\n\t  public url(url: string): string {\n", "    // extract hostname and path from url\n\t    const urlObj = new URL(url);\n\t    const hostname = urlObj.hostname.replace(/\\./g, \"-\");\n\t    const urlPath = urlObj.pathname.substring(1);\n\t    return path.resolve(__dirname, \"urls\", hostname, urlPath);\n\t  }\n\t}\n\tclass EmbeddingService {\n\t  public static get embeddingDirectory(): EmbeddingDirectory {\n\t    return EmbeddingDirectory.getInstance();\n", "  }\n\t  public static async load(\n\t    input: EmbeddingLoadInput\n\t  ): Promise<VectorStore | null> {\n\t    const debug = input.debug ?? false;\n\t    const embeddingModel: Embeddings =\n\t      input.embedding ?? new OpenAIEmbeddings();\n\t    let vectorStore: HNSWLib;\n\t    // Attempt to load in the vector store\n\t    if (input.path) {\n", "      try {\n\t        if (debug) {\n\t          console.log(`Loading vector store from path: [${input.path}]`);\n\t        }\n\t        // Load in the vector store\n\t        vectorStore = await HNSWLib.load(input.path, embeddingModel);\n\t        // Return the vector store if it was loaded\n\t        if (vectorStore) {\n\t          return vectorStore;\n\t        }\n", "      } catch (e) {\n\t        if (debug) {\n\t          console.log(`Failed to load vector store from path: [${input.path}]`);\n\t        }\n\t      }\n\t    }\n\t    return null;\n\t  }\n\t  public static async embed(input: EmbeddingInput): Promise<VectorStore> {\n\t    const debug = input.debug ?? false;\n", "    const embeddingModel: Embeddings =\n\t      input.embedding ?? new OpenAIEmbeddings();\n\t    let vectorStore: HNSWLib;\n\t    // Create new vector store\n\t    /* Split the text into chunks */\n\t    const textSplitter = new RecursiveCharacterTextSplitter({\n\t      chunkSize: input.chunkSize ?? 1000,\n\t    });\n\t    const docs = await textSplitter.createDocuments(input.documents);\n\t    /* Create the vectorstore */\n", "    vectorStore = await HNSWLib.fromDocuments(docs, embeddingModel);\n\t    // If the path is provided, save the vector store\n\t    if (input.path) {\n\t      if (debug) {\n\t        console.log(`Saving vector store to path: [${input.path}]`);\n\t      }\n\t      await vectorStore.save(input.path);\n\t    }\n\t    return vectorStore;\n\t  }\n", "}\n\texport default EmbeddingService;\n"]}
{"filename": "src/programs/summary-program.ts", "chunked_list": ["import { ProgramInterface, ProgramInput } from \"./program-interface.js\";\n\timport EnvironmentService from \"../services/environment-service.js\";\n\timport { Argument, Option } from \"commander\";\n\timport WebExtractionService from \"../services/web-extraction-service.js\";\n\timport OpenAiChatHelper from \"../langchain/open-ai-chat-helper.js\";\n\tinterface SummarizationInput {\n\t  text: string; //url or text\n\t  mode: \"map_reduce\" | \"stuff\";\n\t  split: number;\n\t  debug: boolean;\n", "  url?: string;\n\t}\n\tclass SummaryProgram extends ProgramInterface {\n\t  protected get name(): string {\n\t    return \"summary\";\n\t  }\n\t  protected get description(): string {\n\t    return `Allows for the sumarization of text and urls. By defualt runs the map reduce mode which does not have a limit on its input.`;\n\t  }\n\t  protected get requiredEnvironmentVariables(): string[] {\n", "    return [EnvironmentService.names.OPENAI_API_KEY];\n\t  }\n\t  protected get arguments(): Argument[] {\n\t    return [new Argument(\"[input...]\", \"The text or url to summarize.\")];\n\t  }\n\t  protected get options(): Option[] {\n\t    return [\n\t      new Option(\n\t        \"-m, --mode <mode>\",\n\t        \"The summarization mode to run on:\" +\n", "          \"\\n\\tmap-reduce: Runs the map reduce mode which does not have a limit on its input.\" +\n\t          \"\\n\\tstuff: Sends the input directly to summarization, you may encounter max rate limits.\"\n\t      )\n\t        .choices([\"map_reduce\", \"stuff\"])\n\t        .default(\"map_reduce\"),\n\t      new Option(\n\t        \"--split <split>\",\n\t        \"Defines the split length for large input texts when running with map reduce mode.\"\n\t      ).default(3000),\n\t    ];\n", "  }\n\t  public async run(input: ProgramInput): Promise<void> {\n\t    if (input.args.length > 0) {\n\t      // Extract the text\n\t      const inputArg = input.args[0].join(\" \");\n\t      if (inputArg.length > 0) {\n\t        // Summarize\n\t        return SummaryProgram.runSummary({\n\t          text: inputArg,\n\t          mode: input.input.mode,\n", "          split: input.input.split,\n\t          debug: input.globals.debug,\n\t        });\n\t      }\n\t    }\n\t    // Default show help\n\t    input.command.help();\n\t  }\n\t  private static async runSummary(input: SummarizationInput): Promise<void> {\n\t    // Determine if the text is a url\n", "    const isUrl = WebExtractionService.isUrl(input.text);\n\t    if (isUrl) {\n\t      // Extract the webpage content\n\t      try {\n\t        input.url = input.text;\n\t        input.text = (\n\t          await WebExtractionService.extract(input.text)\n\t        ).toString();\n\t      } catch (e) {\n\t        console.error(`Could not extract webpage content from url: ${input}`);\n", "        return;\n\t      }\n\t    }\n\t    // Summarize the text\n\t    await SummaryProgram.summarizeText(input);\n\t  }\n\t  private static async summarizeText(input: SummarizationInput): Promise<void> {\n\t    if (input.debug) {\n\t      console.log(\"Input:\");\n\t      console.log(input);\n", "      console.log();\n\t    }\n\t    // Model\n\t    const chat = new OpenAiChatHelper({\n\t      model: \"gpt-3.5-turbo\",\n\t      temperature: 0.7,\n\t      verbose: input.debug,\n\t    });\n\t    // Run summary\n\t    const summary = await chat.summarize(input.text, {\n", "      type: input.mode,\n\t      split: input.split,\n\t    });\n\t    // Output the result\n\t    console.log();\n\t    console.log(summary);\n\t  }\n\t}\n\texport default SummaryProgram;\n"]}
{"filename": "src/programs/translate-program.ts", "chunked_list": ["import { ProgramInterface, ProgramInput } from \"./program-interface.js\";\n\timport EnvironmentService from \"../services/environment-service.js\";\n\timport { Argument, Option } from \"commander\";\n\timport OpenAiChatHelper from \"../langchain/open-ai-chat-helper.js\";\n\tinterface TranslationInput {\n\t  text: string; //text\n\t  source: string; // source language\n\t  output: string; // output language\n\t  debug: boolean;\n\t}\n", "class TranslateProgram extends ProgramInterface {\n\t  protected get name(): string {\n\t    return \"translate\";\n\t  }\n\t  protected get description(): string {\n\t    return `Allows for the translatation of text from one langauge to the other. By defualt the program detects the input language and translates to english.`;\n\t  }\n\t  protected get requiredEnvironmentVariables(): string[] {\n\t    return [EnvironmentService.names.OPENAI_API_KEY];\n\t  }\n", "  protected get arguments(): Argument[] {\n\t    return [new Argument(\"[input...]\", \"The text tranlsate.\")];\n\t  }\n\t  protected get options(): Option[] {\n\t    return [\n\t      new Option(\n\t        \"-s, --source <source>\",\n\t        \"The expected langauge for the input.\"\n\t      ).default(\"Auto\"),\n\t      new Option(\n", "        \"-o, --output <output>\",\n\t        \"The langauge to translate the input to.\"\n\t      ).default(\"English\"),\n\t    ];\n\t  }\n\t  public async run(input: ProgramInput): Promise<void> {\n\t    if (input.args.length > 0) {\n\t      // Extract the text\n\t      const inputArg = input.args[0].join(\" \");\n\t      if (inputArg.length > 0) {\n", "        // Summarize\n\t        TranslateProgram.translate({\n\t          text: inputArg,\n\t          source: (input.input.source as string).toLowerCase(),\n\t          output: (input.input.output as string).toLowerCase(),\n\t          debug: input.globals.debug,\n\t        });\n\t        return;\n\t      }\n\t    }\n", "    // Default show help\n\t    input.command.help();\n\t  }\n\t  private static async translate(input: TranslationInput): Promise<void> {\n\t    if (input.debug) {\n\t      console.log(\"Input:\");\n\t      console.log(input);\n\t      console.log();\n\t    }\n\t    // Model\n", "    const chat = new OpenAiChatHelper({\n\t      model: \"gpt-3.5-turbo\",\n\t      temperature: 0, // Enforces deterministic behavior\n\t      verbose: input.debug,\n\t    });\n\t    // Run summary\n\t    const translation = await chat.translate(input.text, {\n\t      source: input.source,\n\t      output: input.output,\n\t    });\n", "    // Output the result\n\t    console.log();\n\t    console.log(translation);\n\t  }\n\t}\n\texport default TranslateProgram;\n"]}
{"filename": "src/programs/prompt-program.ts", "chunked_list": ["import { ProgramInput, ProgramInterface } from \"./program-interface.js\";\n\timport EnvironmentService from \"../services/environment-service.js\";\n\timport OpenAiChatHelper from \"../langchain/open-ai-chat-helper.js\";\n\timport * as toolHelper from \"../helpers/agent-tool-helper.js\";\n\tclass PromptProgram extends ProgramInterface {\n\t  protected get name(): string {\n\t    return \"prompt\";\n\t  }\n\t  protected get aliases(): string[] {\n\t    return [\"p\"];\n", "  }\n\t  protected get description(): string {\n\t    return `Runs a ReAct agent to resolve the users prompt, limited to a single input.`;\n\t  }\n\t  protected get requiredEnvironmentVariables(): string[] {\n\t    return [EnvironmentService.names.OPENAI_API_KEY];\n\t  }\n\t  protected formatDescription(): string {\n\t    let description =\n\t      super.formatDescription() + toolHelper.getToolOptionDescription();\n", "    return description;\n\t  }\n\t  public async run(input: ProgramInput): Promise<void> {\n\t    // Create model\n\t    const model = new OpenAiChatHelper({\n\t      model: \"gpt-3.5-turbo\",\n\t      temperature: 0.7,\n\t      verbose: input.globals.debug,\n\t    });\n\t    // Get the tools\n", "    const tools = toolHelper.getEnabledTools();\n\t    // Log the tools\n\t    console.log(`Running with Tools: [${Object.keys(tools).join(\", \")}]`);\n\t    // Start chat with the tools\n\t    return model.zeroShot({ tools });\n\t  }\n\t}\n\texport default PromptProgram;\n"]}
{"filename": "src/programs/chat-program.ts", "chunked_list": ["import { ProgramInput, ProgramInterface } from \"./program-interface.js\";\n\timport EnvironmentService from \"../services/environment-service.js\";\n\timport OpenAiChatHelper from \"../langchain/open-ai-chat-helper.js\";\n\timport * as toolHelper from \"../helpers/agent-tool-helper.js\";\n\tclass ChatProgram extends ProgramInterface {\n\t  protected get name(): string {\n\t    return \"chat\";\n\t  }\n\t  protected get aliases(): string[] {\n\t    return [\"c\"];\n", "  }\n\t  protected get description(): string {\n\t    return `Runs a chat interface with ChatGPT. various api keys can be set in the environment variables to enable additional features.`;\n\t  }\n\t  protected get requiredEnvironmentVariables(): string[] {\n\t    return [EnvironmentService.names.OPENAI_API_KEY];\n\t  }\n\t  protected formatDescription(): string {\n\t    let description =\n\t      super.formatDescription() + toolHelper.getToolOptionDescription();\n", "    return description;\n\t  }\n\t  public async run(input: ProgramInput): Promise<void> {\n\t    // Create model\n\t    const model = new OpenAiChatHelper({\n\t      model: \"gpt-3.5-turbo\",\n\t      temperature: 0.7,\n\t      verbose: input.globals.debug,\n\t    });\n\t    // Get the tools\n", "    const tools = toolHelper.getEnabledTools();\n\t    // Log the tools\n\t    console.log(`Running with Tools: [${Object.keys(tools).join(\", \")}]`);\n\t    // Start chat with the tools\n\t    return model.chat({ tools });\n\t  }\n\t}\n\texport default ChatProgram;\n"]}
{"filename": "src/programs/understand-program.ts", "chunked_list": ["import { VectorStore } from \"langchain/vectorstores\";\n\timport { ProgramInput, ProgramInterface } from \"./program-interface.js\";\n\timport EnvironmentService from \"../services/environment-service.js\";\n\timport { Argument, Option } from \"commander\";\n\timport WebExtractionService from \"../services/web-extraction-service.js\";\n\timport OpenAiChatHelper from \"../langchain/open-ai-chat-helper.js\";\n\timport EmbeddingService from \"../langchain/services/embedding-service.js\";\n\tinterface UnderstandInput {\n\t  url: string; //text\n\t  clear: boolean;\n", "  debug: boolean;\n\t}\n\tclass UnderstandProgram extends ProgramInterface {\n\t  protected get name(): string {\n\t    return \"understand\";\n\t  }\n\t  protected get description(): string {\n\t    return `Allows for the AI Model to understand a Website. Ask it questions about the website.`;\n\t  }\n\t  protected get requiredEnvironmentVariables(): string[] {\n", "    return [EnvironmentService.names.OPENAI_API_KEY];\n\t  }\n\t  protected get arguments(): Argument[] {\n\t    return [new Argument(\"[input...]\", \"The text tranlsate.\")];\n\t  }\n\t  protected get options(): Option[] {\n\t    return [\n\t      new Option(\n\t        \"-c, --clear\",\n\t        \"Clears any cached vector stores for the input, and creates a new one.\"\n", "      ).default(false),\n\t    ];\n\t  }\n\t  public async run(input: ProgramInput): Promise<void> {\n\t    // Extract the text\n\t    const inputArg = input.args[0].join(\" \");\n\t    if (inputArg.length > 0) {\n\t      return UnderstandProgram.understandWebpage({\n\t        url: inputArg,\n\t        clear: input.input.clear,\n", "        debug: input.globals.debug,\n\t      });\n\t    }\n\t    // Default show help\n\t    input.command.help();\n\t  }\n\t  public static async understandWebpage(input: UnderstandInput): Promise<void> {\n\t    if (input.debug) {\n\t      console.log(\"Input:\");\n\t      console.log(input);\n", "      console.log();\n\t    }\n\t    // Embed the webpage\n\t    const vectorStore = await this.embedWebpage(input);\n\t    // Model\n\t    // Create Model (Randonmess level 0.7)\n\t    const chat = new OpenAiChatHelper({\n\t      model: \"gpt-3.5-turbo\",\n\t      temperature: 0.7,\n\t      verbose: input.debug,\n", "    });\n\t    await chat.understand(vectorStore);\n\t  }\n\t  // Embedds the contents of a webpage into a vector store\n\t  public static async embedWebpage(\n\t    input: UnderstandInput\n\t  ): Promise<VectorStore> {\n\t    const { url, debug, clear } = input;\n\t    // Error checking\n\t    if (WebExtractionService.isUrl(url) == false) {\n", "      throw new Error(\"Invalid URL\");\n\t    }\n\t    let vectorStore: VectorStore | null = null;\n\t    const urlDirectory = EmbeddingService.embeddingDirectory.url(url);\n\t    if (!clear) {\n\t      // Loads the vector store if it exists\n\t      vectorStore = await EmbeddingService.load({\n\t        path: urlDirectory,\n\t        debug: debug,\n\t      });\n", "    }\n\t    if (!vectorStore) {\n\t      // Vector store does not exist, create it\n\t      if (debug) {\n\t        console.log(\"Starting webpage embedding\");\n\t      }\n\t      // Extract the text\n\t      const text = await WebExtractionService.extract(url);\n\t      if (debug) {\n\t        console.log(\"Text abstraction complete\");\n", "      }\n\t      vectorStore = await EmbeddingService.embed({\n\t        documents: [text.toString()],\n\t        path: urlDirectory,\n\t        debug: debug,\n\t      });\n\t    }\n\t    if (debug) {\n\t      console.log(\"Created vector store\");\n\t    }\n", "    return vectorStore;\n\t  }\n\t}\n\texport default UnderstandProgram;\n"]}
{"filename": "src/programs/program-interface.ts", "chunked_list": ["import { Command, Option, Argument } from \"commander\";\n\timport EnvironmentService from \"../services/environment-service.js\";\n\tinterface ProgramInput {\n\t  args: any[]; // A list of the input arguments\n\t  input: { [key: string]: any }; // A dictionary of the input options\n\t  globals: { [key: string]: any }; // A dictionary of the global options\n\t  objects: { [key: string]: any }; // A dictionary of the additional objects\n\t  root: Command; // The root command\n\t  command: Command; // The current command\n\t}\n", "abstract class ProgramInterface {\n\t  public command?: Command;\n\t  protected abstract get name(): string;\n\t  protected abstract get description(): string;\n\t  // Optional\n\t  protected get aliases(): string[] {\n\t    return [];\n\t  }\n\t  protected get arguments(): Argument[] {\n\t    return [];\n", "  }\n\t  protected get options(): Option[] {\n\t    return [];\n\t  }\n\t  protected get requiredEnvironmentVariables(): string[] {\n\t    return [];\n\t  }\n\t  protected get inputObjects(): { [key: string]: any } {\n\t    return {};\n\t  }\n", "  // Configure the program with the commander instance\n\t  // Sets the command at each step\n\t  public configure(root: Command): Command {\n\t    let command: Command = root\n\t      .command(this.name)\n\t      .description(this.formatDescription() + \"\\n\\n\");\n\t    // Add the aliases if they exists\n\t    if (this.aliases) {\n\t      command = command.aliases(this.aliases);\n\t    }\n", "    // Add any arguments\n\t    this.arguments.forEach((argument) => {\n\t      command = command.addArgument(argument);\n\t    });\n\t    // Add any options\n\t    this.options.forEach((option) => {\n\t      command = command.addOption(option);\n\t    });\n\t    // Add the run function to the command\n\t    command = command.action((...args) =>\n", "      this.runWrapper(this.run, root, ...args)\n\t    );\n\t    this.command = command;\n\t    return command;\n\t  }\n\t  protected abstract run(input: ProgramInput): Promise<void>;\n\t  // Formats the description, adding the required environment variables\n\t  protected formatDescription(): string {\n\t    let description = this.description;\n\t    if (this.requiredEnvironmentVariables.length > 0) {\n", "      const envList = this.requiredEnvironmentVariables.join(\", \");\n\t      description += `\\n<Required: [${envList}]>`;\n\t    }\n\t    return description;\n\t  }\n\t  // formats the input for the runner\n\t  private async runWrapper(\n\t    run: (input: ProgramInput) => Promise<void>,\n\t    root: Command,\n\t    ...args: any[]\n", "  ): Promise<void> {\n\t    // Format the input\n\t    const finalArgs = [];\n\t    for (let i = 0; i < args.length; i++) {\n\t      if (args[i] instanceof Command) {\n\t        break;\n\t      } else if (args[i] != undefined && args[i] != null) {\n\t        finalArgs.push(args[i]);\n\t      }\n\t    }\n", "    let finalInput = {};\n\t    if (typeof finalArgs[finalArgs.length - 1] === typeof {}) {\n\t      finalInput = finalArgs.pop();\n\t    }\n\t    let input: ProgramInput = {\n\t      args: finalArgs,\n\t      input: finalInput,\n\t      globals: root.optsWithGlobals(),\n\t      objects: this.inputObjects,\n\t      root: root,\n", "      command: this.command!,\n\t    };\n\t    const isInit = EnvironmentService.isEnvironmentInitialized(\n\t      this.requiredEnvironmentVariables\n\t    );\n\t    // Run the command and validate it\n\t    try {\n\t      if (!isInit) {\n\t        throw new Error(\n\t          `All required environment variables are not set. required: ${this.requiredEnvironmentVariables.join(\n", "            \", \"\n\t          )}`\n\t        );\n\t      }\n\t      if (input.globals.debug) {\n\t        console.log(\"Running with debug mode [enabled]\");\n\t      } else {\n\t        process.removeAllListeners(\"warning\");\n\t        console.warn = () => {};\n\t      }\n", "      // Run the program\n\t      await this.run(input);\n\t    } catch (e) {\n\t      // Catch any errors and print them\n\t      if (input.globals.debug) {\n\t        // Check if the verbose flag is set and print the stack trace\n\t        console.error(e);\n\t      } else {\n\t        // Print just the message\n\t        let message = e;\n", "        if (e instanceof Error) {\n\t          message = e.message;\n\t        }\n\t        console.error(message);\n\t      }\n\t    }\n\t  }\n\t}\n\texport { ProgramInterface, ProgramInput };\n"]}
{"filename": "src/programs/configure/configure-key-program.ts", "chunked_list": ["import { Argument, Option } from \"commander\";\n\timport { ProgramInterface, ProgramInput } from \"../program-interface.js\";\n\timport EnvironmentService from \"../../services/environment-service.js\";\n\tinterface ConfigureKeyInput {\n\t  command: string;\n\t  name: string;\n\t  env: string;\n\t}\n\tclass ConfigureKeyProgram extends ProgramInterface {\n\t  protected get name(): string {\n", "    return this.config.command;\n\t  }\n\t  protected get description(): string {\n\t    return `Sets the ${this.config.name} key within the CLI environment variable. Overrides the exsisting value at the [${this.config.env}] index.`;\n\t  }\n\t  protected get arguments(): Argument[] {\n\t    return [new Argument(\"[key]\", `The key for the ${this.config.name}`)];\n\t  }\n\t  protected get options(): Option[] {\n\t    return [\n", "      new Option(\"-p, --print\", \"Prints the current key to the console\"),\n\t      new Option(\"-c, --clear\", \"Clears the current key\"),\n\t    ];\n\t  }\n\t  protected get inputObjects(): { [key: string]: any } {\n\t    return {\n\t      config: this.config,\n\t    };\n\t  }\n\t  private config: ConfigureKeyInput;\n", "  constructor(input: ConfigureKeyInput) {\n\t    super();\n\t    this.config = input;\n\t  }\n\t  public async run(input: ProgramInput): Promise<void> {\n\t    if (input.args.length === 1) {\n\t      // Write key\n\t      EnvironmentService.writeToEnvironmentFile(\n\t        input.objects.config.env,\n\t        input.args[0]\n", "      );\n\t      console.log(\n\t        `Wrote ${input.objects.config.name} key to environment file.`\n\t      );\n\t    } else if (input.input.print) {\n\t      // Print current key\n\t      const key = EnvironmentService.getEnvironmentVariable(\n\t        input.objects.config.env\n\t      );\n\t      console.log(`Current ${input.objects.config.name} key: ${key}`);\n", "    } else if (input.input.clear) {\n\t      // Clear current key\n\t      EnvironmentService.clearFromEnvironmentFile([input.objects.config.env]);\n\t      console.log(`${input.objects.config.name} key cleared.`);\n\t    } else {\n\t      // Show help\n\t      input.command.help();\n\t    }\n\t  }\n\t}\n", "export { ConfigureKeyProgram, ConfigureKeyInput };\n"]}
{"filename": "src/programs/configure/clear-configuration-program.ts", "chunked_list": ["import { ProgramInterface, ProgramInput } from \"../program-interface.js\";\n\timport EnvironmentService from \"../../services/environment-service.js\";\n\tclass ClearConfigurationProgram extends ProgramInterface {\n\t  protected get name(): string {\n\t    return \"clear\";\n\t  }\n\t  protected get description(): string {\n\t    return \"Clears all environment variables for the application\";\n\t  }\n\t  public async run(input: ProgramInput): Promise<void> {\n", "    EnvironmentService.setEnvironemntFile(\"\");\n\t    console.log(\"Cleared environment file\");\n\t  }\n\t}\n\texport default ClearConfigurationProgram;\n"]}
{"filename": "src/programs/configure/configure-program.ts", "chunked_list": ["import { Command } from \"commander\";\n\timport { ProgramInterface, ProgramInput } from \"../program-interface.js\";\n\timport EnvironmentService from \"../../services/environment-service.js\";\n\timport {\n\t  ConfigureKeyProgram,\n\t  ConfigureKeyInput,\n\t} from \"./configure-key-program.js\";\n\timport ClearConfigurationProgram from \"./clear-configuration-program.js\";\n\tclass ConfigureProgram extends ProgramInterface {\n\t  protected get name(): string {\n", "    return \"config\";\n\t  }\n\t  protected get description(): string {\n\t    return \"Configures environment variables for the application. An alternative to setting environment variables manually.\";\n\t  }\n\t  // Configure the program with the commander instance\n\t  public configure(root: Command): Command {\n\t    this.command = super.configure(root);\n\t    // clear sub command\n\t    new ClearConfigurationProgram().configure(this.command);\n", "    // key sub commands\n\t    this.configureKeyPrograms(this.keyPrograms);\n\t    return this.command!;\n\t  }\n\t  private configureKeyPrograms(inputs: ConfigureKeyInput[]): void {\n\t    for (const input of inputs) {\n\t      new ConfigureKeyProgram(input).configure(this.command!);\n\t    }\n\t  }\n\t  public async run(input: ProgramInput): Promise<void> {\n", "    // Runs the help command\n\t    input.command.help();\n\t  }\n\t  private get keyPrograms(): ConfigureKeyInput[] {\n\t    return [\n\t      // open ai key\n\t      {\n\t        command: \"openai\",\n\t        name: \"Open AI API\",\n\t        env: EnvironmentService.names.OPENAI_API_KEY,\n", "      },\n\t      // serp api key\n\t      {\n\t        command: \"serpapi\",\n\t        name: \"SERP API Key\",\n\t        env: EnvironmentService.names.SERPAPI_API_KEY,\n\t      },\n\t      // value serp api key\n\t      {\n\t        command: \"valueserp\",\n", "        name: \"Value SERP API Key\",\n\t        env: EnvironmentService.names.VALUESERP_API_KEY,\n\t      },\n\t      // finnhub api key\n\t      {\n\t        command: \"finnhub\",\n\t        name: \"Finnhub API Key\",\n\t        env: EnvironmentService.names.FINNHUB_API_KEY,\n\t      },\n\t    ];\n", "  }\n\t}\n\texport default ConfigureProgram;\n"]}
{"filename": "src/helpers/agent-tool-helper.ts", "chunked_list": ["import { Calculator, SerpAPI, Tool } from \"langchain/tools\";\n\timport EnvironmentService from \"../services/environment-service.js\";\n\timport ValueSerpAPI from \"../langchain/tools/value-serp-tool.js\";\n\timport FinnhubStockPriceTool from \"../langchain/tools/finnhub-stock-price-tool.js\";\n\timport CurrencyConversionTool from \"../langchain/tools/currency-conversion-tool.js\";\n\tfunction getToolOptionDescription(): string {\n\t  let description = \"\\n<Optional>:\";\n\t  description += `\\n[${EnvironmentService.names.SERPAPI_API_KEY}]: Enables the use of the SerpAPI to enable search functionality.`;\n\t  description += `\\n[${EnvironmentService.names.VALUESERP_API_KEY}]: Preffered over SerpAPI, enabled search functionality.`;\n\t  description += `\\n[${EnvironmentService.names.FINNHUB_API_KEY}]: Enables real-time stock price knowledge for the agent.`;\n", "  return description;\n\t}\n\tfunction getEnabledTools(): { [name: string]: Tool } {\n\t  const tools: { [name: string]: Tool } = {\n\t    // Default tools\n\t    Calulator: new Calculator(),\n\t    CurrencyConvertor: new CurrencyConversionTool(),\n\t  };\n\t  // Environment Tools\n\t  // search tools\n", "  if (process.env[EnvironmentService.names.VALUESERP_API_KEY]) {\n\t    tools[\"ValueSerp\"] = new ValueSerpAPI(\n\t      process.env[EnvironmentService.names.VALUESERP_API_KEY]\n\t    );\n\t  } else if (process.env[EnvironmentService.names.SERPAPI_API_KEY]) {\n\t    tools[\"SerpAPI\"] = new SerpAPI(\n\t      process.env[EnvironmentService.names.SERPAPI_API_KEY]\n\t    );\n\t  }\n\t  // finnhub tool\n", "  if (process.env[EnvironmentService.names.FINNHUB_API_KEY]) {\n\t    tools[\"FinnhubStockPrice\"] = new FinnhubStockPriceTool(\n\t      process.env[EnvironmentService.names.FINNHUB_API_KEY]\n\t    );\n\t  }\n\t  return tools;\n\t}\n\texport { getToolOptionDescription, getEnabledTools };\n"]}
{"filename": "src/helpers/commander-helper.ts", "chunked_list": ["import commander from \"commander\";\n\tfunction parseIntArgument(value: string, _: any): number {\n\t  const parsedValue = parseInt(value, 10);\n\t  if (isNaN(parsedValue)) {\n\t    throw new commander.InvalidArgumentError(\"Not a valid number.\");\n\t  }\n\t  return parsedValue;\n\t}\n\texport { parseIntArgument };\n"]}
{"filename": "src/services/environment-service.ts", "chunked_list": ["import dotenv from \"dotenv\";\n\timport path from \"path\";\n\timport fs from \"fs\";\n\timport { fileURLToPath } from \"url\";\n\tconst __filename = fileURLToPath(import.meta.url);\n\tconst __dirname = path.dirname(__filename);\n\tclass EnvironmentNames {\n\t  OPENAI_API_KEY: string = \"OPENAI_API_KEY\";\n\t  SERPAPI_API_KEY: string = \"SERPAPI_API_KEY\";\n\t  VALUESERP_API_KEY: string = \"VALUESERP_API_KEY\";\n", "  FINNHUB_API_KEY: string = \"FINNHUB_API_KEY\";\n\t}\n\tclass EnvironmentService {\n\t  public static readonly names: EnvironmentNames = new EnvironmentNames();\n\t  private static readonly ENV_PATH: string = path.resolve(__dirname, \".env\");\n\t  public static initializeEnvironment(): void {\n\t    dotenv.config({\n\t      path: EnvironmentService.ENV_PATH,\n\t    });\n\t  }\n", "  public static isEnvironmentInitialized(vars: string[]): boolean {\n\t    EnvironmentService.initializeEnvironment();\n\t    return vars.every((v) => !!process.env[v]);\n\t  }\n\t  public static getEnvironmentVariable(key: string): string {\n\t    EnvironmentService.initializeEnvironment();\n\t    return process.env[key] || \"\";\n\t  }\n\t  public static setEnvironemntFile(value: string): void {\n\t    fs.writeFileSync(EnvironmentService.ENV_PATH, value);\n", "  }\n\t  public static clearEnvironment(): void {\n\t    EnvironmentService.setEnvironemntFile(\"\");\n\t  }\n\t  public static clearFromEnvironmentFile(keys: string[]): void {\n\t    // Check if the environment file exists\n\t    let contentsList: string[] = [];\n\t    if (fs.existsSync(EnvironmentService.ENV_PATH)) {\n\t      // Pull the file contents and set the contents list\n\t      const fileContents = fs\n", "        .readFileSync(EnvironmentService.ENV_PATH)\n\t        .toString();\n\t      contentsList = fileContents.split(\"\\n\");\n\t    }\n\t    // Split the keys into a map\n\t    let keysMap: { [key: string]: string } = {};\n\t    contentsList.forEach((c) => {\n\t      const [envKey, value] = c.split(\"=\");\n\t      keysMap[envKey] = value;\n\t    });\n", "    // Remove the keys\n\t    keys.forEach((k) => {\n\t      delete keysMap[k];\n\t    });\n\t    // Convert the map back into a string\n\t    const newContents = Object.keys(keysMap).reduce((acc, key) => {\n\t      if (!key) return acc;\n\t      return `${acc}${key}=${keysMap[key]}\\n`;\n\t    }, \"\");\n\t    // Write the new contents to the file\n", "    EnvironmentService.setEnvironemntFile(newContents);\n\t  }\n\t  public static writeToEnvironmentFile(key: string, value: string): void {\n\t    // Check if the environment file exists\n\t    let contentsList: string[] = [];\n\t    if (fs.existsSync(EnvironmentService.ENV_PATH)) {\n\t      // Pull the file contents and set the contents list\n\t      const fileContents = fs\n\t        .readFileSync(EnvironmentService.ENV_PATH)\n\t        .toString();\n", "      contentsList = fileContents.split(\"\\n\");\n\t    }\n\t    // Split the keys into a map\n\t    let keysMap: { [key: string]: string } = {};\n\t    contentsList.forEach((c) => {\n\t      const [envKey, value] = c.split(\"=\");\n\t      keysMap[envKey] = value;\n\t    });\n\t    // Replace the value at the key\n\t    keysMap[key] = value;\n", "    // Convert the map back into a string\n\t    const newContents = Object.keys(keysMap).reduce((acc, key) => {\n\t      if (!key) return acc;\n\t      return `${acc}${key}=${keysMap[key]}\\n`;\n\t    }, \"\");\n\t    // Write the new contents to the file\n\t    EnvironmentService.setEnvironemntFile(newContents);\n\t  }\n\t}\n\texport default EnvironmentService;\n"]}
{"filename": "src/services/web-extraction-service.ts", "chunked_list": ["import axios from \"axios\";\n\timport cheerio from \"cheerio\";\n\tinterface ExtractedPageData {\n\t  type: \"text\" | \"header\" | \"list\" | \"table\";\n\t  content: string;\n\t}\n\tclass WebPageData {\n\t  public data: ExtractedPageData[];\n\t  constructor(data: ExtractedPageData[]) {\n\t    this.data = data;\n", "  }\n\t  public toString(): string {\n\t    return this.data.map((data) => data.content).join(\"\\n\");\n\t  }\n\t}\n\tclass WebExtractionService {\n\t  public static get urlPattern(): RegExp {\n\t    return /^(https?:\\/\\/)?([\\da-z.-]+)\\.([a-z.]{2,6})([/\\w .-]*)*\\/?$/i;\n\t  }\n\t  /*\n", "     ___       _             __                \n\t    |_ _|_ __ | |_ ___ _ __ / _| __ _  ___ ___ \n\t     | || '_ \\| __/ _ \\ '__| |_ / _` |/ __/ _ \\\n\t     | || | | | ||  __/ |  |  _| (_| | (_|  __/\n\t    |___|_| |_|\\__\\___|_|  |_|  \\__,_|\\___\\___|\n\t*/\n\t  public static isUrl(url: string): boolean {\n\t    return WebExtractionService.urlPattern.test(url);\n\t  }\n\t  public static async extract(url: string): Promise<WebPageData> {\n", "    if (!WebExtractionService.isUrl(url))\n\t      throw new Error(\"Invalid url provided.\");\n\t    const html = await WebExtractionService.fetchWebPage(url);\n\t    return WebExtractionService.extractHtmlData(html);\n\t  }\n\t  public static async fetchWebPage(url: string): Promise<string> {\n\t    const response = await axios.get(url);\n\t    return response.data;\n\t  }\n\t  public static extractHtmlData(html: string): WebPageData {\n", "    const $ = cheerio.load(html);\n\t    const data: ExtractedPageData[] = [];\n\t    $(\"body\")\n\t      .find(\"*\")\n\t      .each((_, e: cheerio.Element) => {\n\t        const extractedData = WebExtractionService._dataFromElement($, e);\n\t        if (extractedData) {\n\t          if (Array.isArray(extractedData)) {\n\t            data.push(...extractedData);\n\t          } else {\n", "            data.push(extractedData);\n\t          }\n\t        }\n\t      });\n\t    return new WebPageData(data);\n\t  }\n\t  /*\n\t     _   _      _                     \n\t    | | | | ___| |_ __   ___ _ __ ___ \n\t    | |_| |/ _ \\ | '_ \\ / _ \\ '__/ __|\n", "    |  _  |  __/ | |_) |  __/ |  \\__ \\\n\t    |_| |_|\\___|_| .__/ \\___|_|  |___/\n\t                 |_|                  \n\t*/\n\t  private static _extractText(\n\t    $: cheerio.Root,\n\t    element: cheerio.Cheerio\n\t  ): ExtractedPageData[] {\n\t    return element\n\t      .map((_, el) => ({\n", "        type: \"text\",\n\t        content: $(el).text().trim(),\n\t      }))\n\t      .get();\n\t  }\n\t  private static _dataFromElement(\n\t    $: cheerio.Root,\n\t    element: cheerio.Element\n\t  ): ExtractedPageData[] | ExtractedPageData | null {\n\t    if (element.type === \"text\") {\n", "      // Parse text element\n\t      return {\n\t        type: \"text\",\n\t        content: element.data ?? \"\",\n\t      };\n\t    } else if (element.type === \"tag\") {\n\t      // Parse tagged element\n\t      const tagName = element.tagName.toLowerCase();\n\t      if (\n\t        tagName.startsWith(\"h\") &&\n", "        tagName.length === 2 &&\n\t        !isNaN(Number(tagName[1]))\n\t      ) {\n\t        // H1-H6\n\t        return {\n\t          type: \"header\",\n\t          content: $(element).text().trim(),\n\t        };\n\t      } else if (tagName === \"p\") {\n\t        // Paragraph\n", "        return WebExtractionService._extractText($, $(element));\n\t      } else if (tagName === \"ul\" || tagName === \"ol\") {\n\t        // List\n\t        const isOrdered = tagName === \"ol\";\n\t        return {\n\t          type: \"list\",\n\t          content: $(element)\n\t            .find(\"li\")\n\t            .map(\n\t              (i, li) =>\n", "                `${isOrdered ? `${i + 1}. ` : \"\"}${$(li).text().trim()}`\n\t            )\n\t            .get()\n\t            .join(\", \"),\n\t        };\n\t      } else if (tagName === \"table\") {\n\t        // Table\n\t        return {\n\t          type: \"table\",\n\t          content: $(element)\n", "            .find(\"tr\")\n\t            .map((_, tr) =>\n\t              $(tr)\n\t                .find(\"td, th\")\n\t                .map((_, cell) => $(cell).text().trim())\n\t                .get()\n\t                .join(\" | \")\n\t            )\n\t            .get()\n\t            .join(\"\\n\"),\n", "        };\n\t      }\n\t    }\n\t    return null;\n\t  }\n\t}\n\texport default WebExtractionService;\n"]}
