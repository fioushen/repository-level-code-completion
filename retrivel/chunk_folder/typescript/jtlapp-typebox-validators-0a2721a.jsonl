{"filename": "src/index.ts", "chunked_list": ["export * from './abstract/abstract-validator';\n\texport * from './abstract/abstract-standard-validator';\n\texport * from './abstract/abstract-typed-union-validator';\n\texport * from './standard/index';\n\texport * from './heterogeneous/index';\n\texport * from './discriminated/index';\n\texport * from './lib/validation-exception';\n\texport { ValueError } from '@sinclair/typebox/value';\n"]}
{"filename": "src/test/discriminated-union-validators-valid.test.ts", "chunked_list": ["import { TObject, TSchema, TUnion, Type } from '@sinclair/typebox';\n\timport { AbstractTypedUnionValidator } from '../abstract/abstract-typed-union-validator';\n\timport { DiscriminatedUnionValidator } from '../discriminated/discriminated-union-validator';\n\timport { CompilingDiscriminatedUnionValidator } from '../discriminated/compiling-discriminated-union-validator';\n\timport {\n\t  ValidUnionTestSpec,\n\t  ValidatorKind,\n\t  MethodKind,\n\t  ValidatorCache,\n\t  ValidTestSpec,\n", "} from './test-utils';\n\timport { testValidSpecs } from './test-valid-specs';\n\timport { AbstractValidator } from '../abstract/abstract-validator';\n\tconst onlyRunValidator = ValidatorKind.All;\n\tconst onlyRunMethod = MethodKind.All;\n\tconst wellFormedUnion1 = Type.Union([\n\t  Type.Object({\n\t    kind: Type.Literal('s'),\n\t    str1: Type.String(),\n\t    str2: Type.Optional(Type.String()),\n", "  }),\n\t  Type.Object({\n\t    kind: Type.Literal('i'),\n\t    int1: Type.Integer(),\n\t    int2: Type.Optional(Type.Integer()),\n\t  }),\n\t]);\n\tconst wellFormedUnion2 = Type.Union(\n\t  [\n\t    Type.Object({\n", "      str1: Type.String(),\n\t      t: Type.Literal('s'),\n\t      str2: Type.Optional(Type.String()),\n\t    }),\n\t    Type.Object({\n\t      int1: Type.Integer(),\n\t      int2: Type.Optional(Type.Integer()),\n\t      t: Type.Literal('i'),\n\t    }),\n\t  ],\n", "  { discriminantKey: 't', errorMessage: 'Unknown type' }\n\t);\n\tconst wellFormedUnion3 = Type.Union(\n\t  [\n\t    Type.Object({\n\t      \"s'quote\": Type.Literal(100),\n\t      str1: Type.String(),\n\t    }),\n\t    Type.Object({\n\t      \"s'quote\": Type.Literal(200),\n", "      int1: Type.Integer(),\n\t    }),\n\t  ],\n\t  { discriminantKey: \"s'quote\" }\n\t);\n\tconst validatorCache = new ValidatorCache();\n\tdescribe('discriminated union validators - valid values', () => {\n\t  if (runThisValidator(ValidatorKind.NonCompiling)) {\n\t    describe('DiscriminatedUnionValidator', () => {\n\t      testValidator(\n", "        (schema: TSchema) =>\n\t          validatorCache.getNonCompiling(\n\t            schema,\n\t            () => new DiscriminatedUnionValidator(schema as TUnion<TObject[]>)\n\t          ) as AbstractTypedUnionValidator<TUnion<TObject[]>>\n\t      );\n\t    });\n\t  }\n\t  if (runThisValidator(ValidatorKind.Compiling)) {\n\t    describe('CompilingDiscriminatedUnionValidator', () => {\n", "      testValidator((schema: TSchema) =>\n\t        validatorCache.getCompiling(\n\t          schema,\n\t          () =>\n\t            new CompilingDiscriminatedUnionValidator(\n\t              schema as TUnion<TObject[]>\n\t            )\n\t        )\n\t      );\n\t    });\n", "  }\n\t});\n\tfunction testValidator(\n\t  createValidator: (schema: TSchema) => AbstractValidator<TSchema>\n\t) {\n\t  testValidSpecs(runThisTest, createValidator, verifyCleaning, [\n\t    {\n\t      description: 'valid discrim union 1, no unrecognized fields',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n", "      value: { kind: 's', str1: 'hello' },\n\t      selectedIndex: 0,\n\t    },\n\t    {\n\t      description: 'valid discrim union 2, no unrecognized fields',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: { kind: 'i', int1: 1 },\n\t      selectedIndex: 1,\n\t    },\n", "    {\n\t      description: 'valid discrim union 3, with unrecognized fields',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: {\n\t        kind: 's',\n\t        str1: 'hello',\n\t        int1: 1,\n\t        unrecognized1: 1,\n\t        unrecognized2: 'abc',\n", "      },\n\t      selectedIndex: 0,\n\t    },\n\t    {\n\t      description: 'valid discrim union 4, with unrecognized fields',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: {\n\t        kind: 'i',\n\t        str1: 'hello',\n", "        int1: 1,\n\t        unrecognized1: 1,\n\t        unrecognized2: 'abc',\n\t      },\n\t      selectedIndex: 1,\n\t    },\n\t    {\n\t      description: 'valid discrim union 5, different discriminant key',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion2,\n", "      value: { t: 's', str1: 'hello' },\n\t      selectedIndex: 0,\n\t    },\n\t    {\n\t      description: 'valid discrim union 6, different discriminant key',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion2,\n\t      value: { t: 'i', str1: 'hello', int1: 1 },\n\t      selectedIndex: 1,\n\t    },\n", "    {\n\t      description: 'valid discrim union 7, quoted discriminant key',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion3,\n\t      value: { \"s'quote\": 200, int1: 1 },\n\t      selectedIndex: 1,\n\t    },\n\t  ]);\n\t}\n\tfunction verifyCleaning(spec: ValidTestSpec<TSchema>, value: any): void {\n", "  const unionSpec = spec as ValidUnionTestSpec;\n\t  const validProperties = Object.keys(\n\t    unionSpec.schema.anyOf[unionSpec.selectedIndex].properties\n\t  );\n\t  for (const key in value) {\n\t    expect(validProperties.includes(key)).toBe(true);\n\t  }\n\t  expect(Object.keys(value).length).toBeLessThanOrEqual(validProperties.length);\n\t}\n\tfunction runThisValidator(validatorKind: ValidatorKind): boolean {\n", "  return [ValidatorKind.All, validatorKind].includes(onlyRunValidator);\n\t}\n\tfunction runThisTest(methodKind: MethodKind): boolean {\n\t  return [MethodKind.All, methodKind].includes(onlyRunMethod);\n\t}\n"]}
{"filename": "src/test/test-invalid-specs.ts", "chunked_list": ["import { TSchema } from '@sinclair/typebox';\n\timport { AbstractValidator } from '../abstract/abstract-validator';\n\timport {\n\t  InvalidTestSpec,\n\t  MethodKind,\n\t  ValidatorMethodOfClass,\n\t  specsToRun,\n\t} from './test-utils';\n\timport { DEFAULT_OVERALL_MESSAGE } from '../lib/error-utils';\n\timport { ValidationException } from '../lib/validation-exception';\n", "export function testInvalidSpecs<S extends InvalidTestSpec<TSchema>>(\n\t  runThisTest: (method: MethodKind) => boolean,\n\t  createValidator: (schema: TSchema) => AbstractValidator<TSchema>,\n\t  invalidSpecs: S[]\n\t) {\n\t  if (runThisTest(MethodKind.Test)) {\n\t    describe('test() rejections', () => {\n\t      specsToRun(invalidSpecs).forEach((spec) => {\n\t        it('test() should reject ' + spec.description, () => {\n\t          const validator = createValidator(spec.schema);\n", "          expect(validator.test(spec.value)).toBe(false);\n\t        });\n\t      });\n\t    });\n\t  }\n\t  if (runThisTest(MethodKind.TestReturningErrors)) {\n\t    describe('testReturningErrors()', () => {\n\t      specsToRun(invalidSpecs).forEach((spec) => {\n\t        it('testReturningErrors() for ' + spec.description, () => {\n\t          const validator = createValidator(spec.schema);\n", "          const result = validator.testReturningErrors(spec.value);\n\t          expect(result).not.toBeNull();\n\t          const errors = [...result!];\n\t          expect(errors.length).toEqual(spec.errors.length);\n\t          errors.forEach((error, i) => {\n\t            expect(error.path).toEqual(spec.errors[i].path);\n\t            expect(error.message).toContain(spec.errors[i].message);\n\t          });\n\t        });\n\t      });\n", "    });\n\t  }\n\t  if (runThisTest(MethodKind.TestReturningFirstError)) {\n\t    describe('testReturningFirstError()', () => {\n\t      specsToRun(invalidSpecs).forEach((spec) => {\n\t        it('testReturningFirstError() for ' + spec.description, () => {\n\t          const validator = createValidator(spec.schema);\n\t          const firstError = validator.firstError(spec.value);\n\t          expect(firstError).not.toBeNull();\n\t          expect(firstError?.path).toEqual(spec.errors[0].path);\n", "          expect(firstError?.message).toContain(spec.errors[0].message);\n\t        });\n\t      });\n\t    });\n\t  }\n\t  if (runThisTest(MethodKind.Assert)) {\n\t    testAssertMethodRejection('assert', invalidSpecs);\n\t  }\n\t  if (runThisTest(MethodKind.AssertAndClean)) {\n\t    testAssertMethodRejection('assertAndClean', invalidSpecs);\n", "  }\n\t  if (runThisTest(MethodKind.AssertAndCleanCopy)) {\n\t    testAssertMethodRejection('assertAndCleanCopy', invalidSpecs);\n\t  }\n\t  if (runThisTest(MethodKind.Validate)) {\n\t    testValidateMethodRejection('validate', invalidSpecs);\n\t  }\n\t  if (runThisTest(MethodKind.ValidateAndClean)) {\n\t    testValidateMethodRejection('validateAndClean', invalidSpecs);\n\t  }\n", "  if (runThisTest(MethodKind.ValidateAndCleanCopy)) {\n\t    testValidateMethodRejection('validateAndCleanCopy', invalidSpecs);\n\t  }\n\t  if (runThisTest(MethodKind.Errors)) {\n\t    describe('errors()', () => {\n\t      specsToRun(invalidSpecs).forEach((spec) => {\n\t        it('errors() for ' + spec.description, () => {\n\t          const validator = createValidator(spec.schema);\n\t          const errors = [...validator.errors(spec.value)];\n\t          expect(errors.length).toEqual(spec.errors.length);\n", "          errors.forEach((error, i) => {\n\t            expect(error.path).toEqual(spec.errors[i].path);\n\t            expect(error.message).toContain(spec.errors[i].message);\n\t          });\n\t        });\n\t      });\n\t    });\n\t  }\n\t  if (runThisTest(MethodKind.FirstError)) {\n\t    describe('firstError()', () => {\n", "      specsToRun(invalidSpecs).forEach((spec) => {\n\t        it('firstError() for ' + spec.description, () => {\n\t          const validator = createValidator(spec.schema);\n\t          const firstError = validator.firstError(spec.value);\n\t          expect(firstError?.path).toEqual(spec.errors[0].path);\n\t          expect(firstError?.message).toContain(spec.errors[0].message);\n\t        });\n\t      });\n\t    });\n\t  }\n", "  function testAssertMethodRejection<S extends TSchema>(\n\t    method: ValidatorMethodOfClass<AbstractValidator<S>>,\n\t    specs: InvalidTestSpec<TSchema>[]\n\t  ) {\n\t    describe(`${method}() rejections`, () => {\n\t      specsToRun(specs).forEach((spec) => {\n\t        it(`${method}() should reject ${spec.description}`, () => {\n\t          const validator = createValidator(spec.schema);\n\t          try {\n\t            (validator[method] as any)(spec.value, spec.overallMessage);\n", "            expect(false).toBe(true);\n\t          } catch (e: any) {\n\t            if (!(e instanceof ValidationException)) throw e;\n\t            const details = e.details;\n\t            const errors = spec.errors;\n\t            expect(details.length).toEqual(1);\n\t            expect(details[0].path).toEqual(errors[0].path);\n\t            expect(details[0].message).toContain(errors[0].message);\n\t            if (spec.assertMessage !== undefined) {\n\t              expect(e.message).toEqual(spec.assertMessage);\n", "            }\n\t            if (spec.assertString !== undefined) {\n\t              expect(e.toString()).toEqual(spec.assertString);\n\t            }\n\t          }\n\t        });\n\t      });\n\t    });\n\t  }\n\t  function testValidateMethodRejection<S extends TSchema>(\n", "    method: ValidatorMethodOfClass<AbstractValidator<S>>,\n\t    specs: InvalidTestSpec<TSchema>[]\n\t  ) {\n\t    describe(`${method}() rejections`, () => {\n\t      specsToRun(specs).forEach((spec) => {\n\t        it(`${method}() should reject ${spec.description}`, () => {\n\t          const validator = createValidator(spec.schema);\n\t          const overallMessage = spec.overallMessage\n\t            ? spec.overallMessage.replace('{error}', '').trim()\n\t            : undefined;\n", "          try {\n\t            (validator[method] as any)(spec.value, overallMessage);\n\t            expect(false).toBe(true);\n\t          } catch (e: any) {\n\t            if (!(e instanceof ValidationException)) throw e;\n\t            const details = e.details;\n\t            const errors = spec.errors;\n\t            expect(details.length).toEqual(errors.length);\n\t            errors.forEach((error, i) => {\n\t              expect(details[i]?.path).toEqual(error.path);\n", "              expect(details[i]?.message).toContain(error.message);\n\t            });\n\t            expect(e.message).toEqual(\n\t              overallMessage ?? DEFAULT_OVERALL_MESSAGE\n\t            );\n\t            if (spec.validateString !== undefined) {\n\t              expect(e.toString()).toEqual(spec.validateString);\n\t            }\n\t          }\n\t        });\n", "      });\n\t    });\n\t  }\n\t}\n"]}
{"filename": "src/test/standard-validators-invalid.test.ts", "chunked_list": ["import { TSchema, Type } from '@sinclair/typebox';\n\timport { AbstractStandardValidator } from '../abstract/abstract-standard-validator';\n\timport { StandardValidator } from '../standard/standard-validator';\n\timport { CompilingStandardValidator } from '../standard/compiling-standard-validator';\n\timport { DEFAULT_OVERALL_MESSAGE } from '../lib/error-utils';\n\timport { ValidatorKind, MethodKind, ValidatorCache } from './test-utils';\n\timport { testInvalidSpecs } from './test-invalid-specs';\n\tconst onlyRunValidator = ValidatorKind.All;\n\tconst onlyRunMethod = MethodKind.All;\n\tconst schema0 = Type.String({\n", "  minLength: 5,\n\t  maxLength: 10,\n\t  pattern: '^[a-zA-Z]+$',\n\t});\n\tconst schema1 = Type.String({\n\t  minLength: 5,\n\t  maxLength: 10,\n\t  pattern: '^[a-zA-Z]+$',\n\t  errorMessage: 'name should consist of 5-10 letters',\n\t});\n", "const schema2 = Type.Object({\n\t  delta: Type.Integer(),\n\t  count: Type.Integer({ exclusiveMinimum: 0 }),\n\t  name: schema1,\n\t});\n\tconst schema3 = Type.Object({\n\t  int1: Type.Integer({ errorMessage: 'must be an int' }),\n\t  int2: Type.Integer({ errorMessage: 'must be an int' }),\n\t  alpha: Type.String({ pattern: '^[a-zA-Z]+$', maxLength: 4 }),\n\t});\n", "const schema4 = Type.Object({\n\t  int1: Type.Integer(),\n\t  whatever: Type.Any(),\n\t});\n\tconst schema5 = Type.Object({\n\t  int1: Type.Integer(),\n\t  whatever: Type.Unknown({ errorMessage: 'Missing whatever' }),\n\t});\n\tconst validatorCache = new ValidatorCache();\n\tdescribe('standard validators - invalid values', () => {\n", "  if (runThisValidator(ValidatorKind.NonCompiling)) {\n\t    describe('StandardValidator', () => {\n\t      testValidator((schema: TSchema) =>\n\t        validatorCache.getNonCompiling(\n\t          schema,\n\t          () => new StandardValidator(schema)\n\t        )\n\t      );\n\t    });\n\t  }\n", "  if (runThisValidator(ValidatorKind.Compiling)) {\n\t    describe('CompilingStandardValidator', () => {\n\t      testValidator((schema: TSchema) =>\n\t        validatorCache.getCompiling(\n\t          schema,\n\t          () => new CompilingStandardValidator(schema)\n\t        )\n\t      );\n\t    });\n\t  }\n", "});\n\tfunction testValidator(\n\t  createValidator: (schema: TSchema) => AbstractStandardValidator<TSchema>\n\t) {\n\t  testInvalidSpecs(runThisTest, createValidator, [\n\t    {\n\t      description: 'multiple errors for string literal',\n\t      onlySpec: false,\n\t      schema: schema0,\n\t      value: '1',\n", "      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [\n\t        {\n\t          path: '',\n\t          message: 'greater or equal to 5',\n\t        },\n\t        {\n\t          path: '',\n\t          message: 'match pattern',\n\t        },\n", "      ],\n\t      assertString:\n\t        'Invalid value:\\n * Expected string length greater or equal to 5',\n\t      validateString:\n\t        'Invalid value:\\n' +\n\t        ' * Expected string length greater or equal to 5\\n' +\n\t        ' * Expected string to match pattern ^[a-zA-Z]+$',\n\t    },\n\t    {\n\t      description: 'custom overall and error messages for string literal',\n", "      onlySpec: false,\n\t      schema: schema1,\n\t      value: '1',\n\t      overallMessage: 'Oopsie',\n\t      assertMessage: 'Oopsie',\n\t      errors: [\n\t        {\n\t          path: '',\n\t          message: 'name should consist of 5-10 letters',\n\t        },\n", "      ],\n\t      assertString: 'Oopsie:\\n * name should consist of 5-10 letters',\n\t      validateString: 'Oopsie:\\n * name should consist of 5-10 letters',\n\t    },\n\t    {\n\t      description: 'single invalid field with one error',\n\t      onlySpec: false,\n\t      schema: schema2,\n\t      value: { delta: 0.5, count: 1, name: 'ABCDE' },\n\t      assertMessage: DEFAULT_OVERALL_MESSAGE,\n", "      errors: [{ path: '/delta', message: 'Expected integer' }],\n\t      assertString: 'Invalid value:\\n * delta - Expected integer',\n\t      validateString: 'Invalid value:\\n * delta - Expected integer',\n\t    },\n\t    {\n\t      description:\n\t        'single invalid field with one error, custom overall message 1',\n\t      onlySpec: false,\n\t      schema: schema2,\n\t      value: { delta: 0.5, count: 1, name: 'ABCDE' },\n", "      overallMessage: 'Custom message',\n\t      assertMessage: 'Custom message',\n\t      errors: [{ path: '/delta', message: 'Expected integer' }],\n\t      assertString: 'Custom message:\\n * delta - Expected integer',\n\t      validateString: 'Custom message:\\n * delta - Expected integer',\n\t    },\n\t    {\n\t      description:\n\t        'single invalid field with one error, custom overall message 2',\n\t      onlySpec: false,\n", "      schema: schema2,\n\t      value: { delta: 0.5, count: 1, name: 'ABCDE' },\n\t      overallMessage: 'Oopsie: {error}',\n\t      assertMessage: 'Oopsie: delta - Expected integer',\n\t      errors: [{ path: '/delta', message: 'Expected integer' }],\n\t      assertString:\n\t        'Oopsie: delta - Expected integer:\\n * delta - Expected integer',\n\t      validateString: 'Oopsie:\\n * delta - Expected integer',\n\t    },\n\t    {\n", "      description: 'custom error message makes it into custom overall message',\n\t      onlySpec: false,\n\t      schema: schema2,\n\t      value: { delta: 1, count: 1, name: '1' },\n\t      overallMessage: 'Oopsie: {error}',\n\t      assertMessage: 'Oopsie: name - name should consist of 5-10 letters',\n\t      errors: [\n\t        { path: '/name', message: 'name should consist of 5-10 letters' },\n\t      ],\n\t      assertString:\n", "        'Oopsie: name - name should consist of 5-10 letters:\\n' +\n\t        ' * name - name should consist of 5-10 letters',\n\t      validateString: 'Oopsie:\\n * name - name should consist of 5-10 letters',\n\t    },\n\t    {\n\t      description: 'single invalid field with multiple errors',\n\t      onlySpec: false,\n\t      schema: schema3,\n\t      value: { int1: 1, int2: 1, alpha: '12345' },\n\t      errors: [\n", "        {\n\t          path: '/alpha',\n\t          message: 'less or equal to 4',\n\t        },\n\t        {\n\t          path: '/alpha',\n\t          message: 'match pattern',\n\t        },\n\t      ],\n\t    },\n", "    {\n\t      description: 'multiple invalid fields with multiple errors',\n\t      onlySpec: false,\n\t      schema: schema3,\n\t      value: { int1: 1.5, int2: 1.5, alpha: '12345' },\n\t      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [\n\t        {\n\t          path: '/int1',\n\t          message: 'must be an int',\n", "        },\n\t        {\n\t          path: '/int2',\n\t          message: 'must be an int',\n\t        },\n\t        {\n\t          path: '/alpha',\n\t          message: 'less or equal to 4',\n\t        },\n\t        {\n", "          path: '/alpha',\n\t          message: 'match pattern',\n\t        },\n\t      ],\n\t    },\n\t    {\n\t      description: 'one custom error message for multiple errors',\n\t      onlySpec: false,\n\t      schema: schema2,\n\t      value: { delta: 0.5, count: 1, name: '1' },\n", "      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [\n\t        {\n\t          path: '/delta',\n\t          message: 'integer',\n\t        },\n\t        {\n\t          path: '/name',\n\t          message: 'name should consist of 5-10 letters',\n\t        },\n", "      ],\n\t      assertString: 'Invalid value:\\n * delta - Expected integer',\n\t      validateString:\n\t        'Invalid value:\\n' +\n\t        ' * delta - Expected integer\\n' +\n\t        ' * name - name should consist of 5-10 letters',\n\t    },\n\t    {\n\t      description:\n\t        'invalid overall value with one error, custom overall message 1',\n", "      onlySpec: false,\n\t      schema: schema2,\n\t      value: 'not an object',\n\t      overallMessage: 'Oopsie: {error}',\n\t      assertMessage: 'Oopsie: Expected object',\n\t      errors: [{ path: '', message: 'Expected object' }],\n\t      assertString: 'Oopsie: Expected object:\\n * Expected object',\n\t      validateString: 'Oopsie:\\n * Expected object',\n\t    },\n\t    {\n", "      description: \"reports default required message for 'any' field\",\n\t      onlySpec: false,\n\t      schema: schema4,\n\t      value: { int1: 32 },\n\t      errors: [\n\t        {\n\t          path: '/whatever',\n\t          message: 'Expected required property',\n\t        },\n\t      ],\n", "      assertString: 'Invalid value:\\n * whatever - Expected required property',\n\t      validateString:\n\t        'Invalid value:\\n * whatever - Expected required property',\n\t    },\n\t    {\n\t      description: \"reports custom required message for 'unknown' field\",\n\t      onlySpec: false,\n\t      schema: schema5,\n\t      value: { int1: 'not an integer' },\n\t      errors: [\n", "        {\n\t          path: '/int1',\n\t          message: 'Expected integer',\n\t        },\n\t        {\n\t          path: '/whatever',\n\t          message: 'Missing whatever',\n\t        },\n\t      ],\n\t      assertString: 'Invalid value:\\n * int1 - Expected integer',\n", "      validateString:\n\t        'Invalid value:\\n' +\n\t        ' * int1 - Expected integer\\n' +\n\t        ' * whatever - Missing whatever',\n\t    },\n\t  ]);\n\t}\n\tfunction runThisValidator(validatorKind: ValidatorKind): boolean {\n\t  return [ValidatorKind.All, validatorKind].includes(onlyRunValidator);\n\t}\n", "function runThisTest(methodKind: MethodKind): boolean {\n\t  return [MethodKind.All, methodKind].includes(onlyRunMethod);\n\t}\n"]}
{"filename": "src/test/maxItems-maxLength.test.ts", "chunked_list": ["/**\n\t * As of Typebox version 0.28.13,`maxLength` and `maxItems` are checked before\n\t * checking other constraints, but the TypeBox docs say nothing about this, so\n\t * this feature may not be part of the public contract. These tests confirm\n\t * that this remains the case, as this feature is important for securing APIs.\n\t */\n\timport { TSchema, Type } from '@sinclair/typebox';\n\timport { Value, ValueErrorIterator } from '@sinclair/typebox/value';\n\timport { TypeCheck, TypeCompiler } from '@sinclair/typebox/compiler';\n\t//import { performance } from 'node:perf_hooks';\n", "const MAX_SIZE = 4;\n\tconst ERROR_SUBSTRING = `less or equal to ${MAX_SIZE}`;\n\tconst PATTERN = '^[a-z]+$';\n\t// const uncompiledIterations = [400, 10000] as const;\n\t// const compiledIterations = [400, 20000] as const;\n\tdescribe('TypeBox value size checks', () => {\n\t  describe('maxLength checks', () => {\n\t    const schema = Type.Object({\n\t      lengthFirstStr: Type.String({ maxLength: 4, pattern: PATTERN }),\n\t      lengthLastStr: Type.String({ pattern: PATTERN, maxLength: MAX_SIZE }),\n", "    });\n\t    const badSizeValue = {\n\t      lengthFirstStr: '1'.repeat(MAX_SIZE + 1),\n\t      lengthLastStr: '1'.repeat(MAX_SIZE + 1),\n\t    };\n\t    // const badRegexValue = {\n\t    //   lengthFirstStr: '1',\n\t    //   lengthLastStr: '1',\n\t    // };\n\t    const compiledType = TypeCompiler.Compile(schema);\n", "    // it('should have uncompiled Check() test maxLength first', () => {\n\t    //   const check = Value.Check.bind(Value, schema);\n\t    //   testCheckViaTiming(\n\t    //     check,\n\t    //     badSizeValue,\n\t    //     badRegexValue,\n\t    //     uncompiledIterations\n\t    //   );\n\t    // });\n\t    it('should have compiled Check() test maxLength first', () => {\n", "      testCheckViaCode(compiledType);\n\t      // const check = compiledType.Check.bind(compiledType);\n\t      // testCheckViaTiming(\n\t      //   check,\n\t      //   badSizeValue,\n\t      //   badRegexValue,\n\t      //   compiledIterations\n\t      // );\n\t    });\n\t    it('should have First() return a maxLength error', () => {\n", "      let error = Value.Errors(schema, badSizeValue).First();\n\t      expect(error?.message).toContain(ERROR_SUBSTRING);\n\t      error = compiledType.Errors(badSizeValue).First();\n\t      expect(error?.message).toContain(ERROR_SUBSTRING);\n\t    });\n\t    it('should have Errors() return a maxLength error first', () => {\n\t      const verifyErrors = (errors: ValueErrorIterator) => {\n\t        let priorPath = '';\n\t        for (const error of errors) {\n\t          if (error.path !== priorPath) {\n", "            expect(error.message).toContain(ERROR_SUBSTRING);\n\t            priorPath = error.path;\n\t          }\n\t        }\n\t      };\n\t      verifyErrors(Value.Errors(schema, badSizeValue));\n\t      verifyErrors(compiledType.Errors(badSizeValue));\n\t    });\n\t  });\n\t  describe('maxItems checks', () => {\n", "    const schema = Type.Object({\n\t      array: Type.Array(Type.String({ pattern: PATTERN }), {\n\t        maxItems: MAX_SIZE,\n\t      }),\n\t    });\n\t    const badSizeValue = {\n\t      array: Array.from({ length: MAX_SIZE + 1 }).fill('1'),\n\t    };\n\t    // const badRegexValue = {\n\t    //   array: Array.from({ length: 1 }).fill('1'),\n", "    // };\n\t    const compiledType = TypeCompiler.Compile(schema);\n\t    // it('should have uncompiled Check() test maxItems first', () => {\n\t    //   const check = Value.Check.bind(Value, schema);\n\t    //   testCheckViaTiming(\n\t    //     check,\n\t    //     badSizeValue,\n\t    //     badRegexValue,\n\t    //     uncompiledIterations\n\t    //   );\n", "    // });\n\t    it('should have compiled Check() test maxItems first', () => {\n\t      testCheckViaCode(compiledType);\n\t      // const check = compiledType.Check.bind(compiledType);\n\t      // testCheckViaTiming(\n\t      //   check,\n\t      //   badSizeValue,\n\t      //   badRegexValue,\n\t      //   compiledIterations\n\t      // );\n", "    });\n\t    it('should have First() return a maxItems error', () => {\n\t      let error = Value.Errors(schema, badSizeValue).First();\n\t      expect(error?.message).toContain(ERROR_SUBSTRING);\n\t      error = compiledType.Errors(badSizeValue).First();\n\t      expect(error?.message).toContain(ERROR_SUBSTRING);\n\t    });\n\t    it('should have Errors() return a maxItems error first', () => {\n\t      for (const error of compiledType.Errors(badSizeValue)) {\n\t        expect(error.message).toContain(ERROR_SUBSTRING);\n", "        break; // only check first error\n\t      }\n\t    });\n\t  });\n\t});\n\tfunction testCheckViaCode(compiledType: TypeCheck<TSchema>) {\n\t  // Not guaranteed to work for all versions of TypeBox,\n\t  // but it's faster than doing another timing test.\n\t  const code = compiledType.Code();\n\t  const maxSizeOffset = code.indexOf(`${MAX_SIZE}`);\n", "  const patternOffset = code.indexOf('.test(');\n\t  expect(maxSizeOffset).toBeGreaterThanOrEqual(0);\n\t  expect(patternOffset).toBeGreaterThanOrEqual(0);\n\t  expect(maxSizeOffset).toBeLessThan(patternOffset);\n\t}\n\t// This function works most of the time, but produces a false negative\n\t// often enough to make it too unreliable to include in the test suite.\n\t// function testCheckViaTiming(\n\t//   check: (value: unknown) => boolean,\n\t//   badSizeValue: unknown,\n", "//   badRegexValue: unknown,\n\t//   iterations: Readonly<[number, number]>\n\t// ) {\n\t//   let badSizeTimes: number[] = [];\n\t//   let badRegexTimes: number[] = [];\n\t//   // Mix the two tests to equally apply system slowdowns across them.\n\t//   for (let i = 0; i < iterations[0]; ++i) {\n\t//     badSizeTimes.push(timeCheckFunction(check, badSizeValue, iterations[1]));\n\t//     badRegexTimes.push(timeCheckFunction(check, badRegexValue, iterations[1]));\n\t//   }\n", "//   badSizeTimes.sort();\n\t//   badRegexTimes.sort();\n\t//   const sum = (times: number[]) =>\n\t//     times.slice(0, iterations[0] / 2).reduce((a, b) => a + b, 0);\n\t//   expect(sum(badSizeTimes)).toBeLessThan(sum(badRegexTimes));\n\t// }\n\t// function timeCheckFunction(\n\t//   check: (value: unknown) => boolean,\n\t//   badValue: unknown,\n\t//   iterations: number\n", "// ): number {\n\t//   let start = performance.now();\n\t//   for (let i = 0; i < iterations; ++i) {\n\t//     check(badValue);\n\t//   }\n\t//   return performance.now() - start;\n\t// }\n"]}
{"filename": "src/test/key-iteration-performance.ts", "chunked_list": ["import { TSchema, Type } from '@sinclair/typebox';\n\tconst iterations = [1000, 10000] as const;\n\tconst schema = Type.Object({\n\t  key1: Type.String(),\n\t  key2: Type.String(),\n\t  key3: Type.String(),\n\t  key4: Type.String(),\n\t  key5: Type.String(),\n\t  key6: Type.String(),\n\t  key7: Type.String(),\n", "  key8: Type.String(),\n\t  key9: Type.String(),\n\t  key10: Type.String(),\n\t});\n\tconsole.log('key iteration performance');\n\t{\n\t  console.log('  key iteration speed\\n');\n\t  let forInTime = 0;\n\t  let objectKeysTime = 0;\n\t  let objectKeysForEachTime = 0;\n", "  let objectGetOwnPropertyNamesTime = 0;\n\t  let objectGetOwnPropertyNamesForEachTime = 0;\n\t  // Mix the two tests to equally apply system slowdowns across them.\n\t  for (let i = 0; i < iterations[0]; ++i) {\n\t    forInTime += timeFunction(() => {\n\t      let count = 0;\n\t      for (const _ in schema.properties) {\n\t        count++;\n\t      }\n\t      return count;\n", "    });\n\t    objectKeysTime += timeFunction(() => {\n\t      let count = 0;\n\t      for (const _ of Object.keys(schema.properties)) {\n\t        count++;\n\t      }\n\t      return count;\n\t    });\n\t    objectKeysForEachTime += timeFunction(() => {\n\t      let count = 0;\n", "      Object.keys(schema.properties).forEach(() => {\n\t        count++;\n\t      });\n\t      return count;\n\t    });\n\t    objectGetOwnPropertyNamesTime += timeFunction(() => {\n\t      let count = 0;\n\t      for (const _ of Object.getOwnPropertyNames(schema.properties)) {\n\t        count++;\n\t      }\n", "      return count;\n\t    });\n\t    objectGetOwnPropertyNamesForEachTime += timeFunction(() => {\n\t      let count = 0;\n\t      Object.getOwnPropertyNames(schema.properties).forEach(() => {\n\t        count++;\n\t      });\n\t      return count;\n\t    });\n\t  }\n", "  const results: [string, number][] = [];\n\t  results.push(['for in', forInTime]);\n\t  results.push(['Object.keys of', objectKeysTime]);\n\t  results.push(['Object.keys.forEach', objectKeysForEachTime]);\n\t  results.push([\n\t    'Object.getOwnPropertyNames of',\n\t    objectGetOwnPropertyNamesTime,\n\t  ]);\n\t  results.push([\n\t    'Object.getOwnPropertyNames.forEach',\n", "    objectGetOwnPropertyNamesForEachTime,\n\t  ]);\n\t  showResults(results);\n\t  function timeFunction(func: () => number): number {\n\t    let start = performance.now();\n\t    for (let i = 0; i < iterations[1]; ++i) {\n\t      func();\n\t    }\n\t    return performance.now() - start;\n\t  }\n", "}\n\t{\n\t  console.log('  key lookup speed\\n');\n\t  let inTime = 0;\n\t  let objectKeysIncludesTime = 0;\n\t  let objectGetOwnPropertyIncludesTime = 0;\n\t  // Mix the two tests to equally apply system slowdowns across them.\n\t  for (let i = 0; i < iterations[0]; ++i) {\n\t    const lookupKeys = ['key1', 'key5', 'key10'];\n\t    inTime += timeFunction((schema) => {\n", "      let count = 0;\n\t      for (const key of lookupKeys) {\n\t        if (key in schema.properties) {\n\t          count++;\n\t        }\n\t      }\n\t      return count;\n\t    });\n\t    objectKeysIncludesTime += timeFunction((schema) => {\n\t      let count = 0;\n", "      for (const key of lookupKeys) {\n\t        if (Object.keys(schema.properties).includes(key)) {\n\t          count++;\n\t        }\n\t      }\n\t      return count;\n\t    });\n\t    objectGetOwnPropertyIncludesTime += timeFunction((schema) => {\n\t      let count = 0;\n\t      for (const key of lookupKeys) {\n", "        if (Object.getOwnPropertyNames(schema.properties).includes(key)) {\n\t          count++;\n\t        }\n\t      }\n\t      return count;\n\t    });\n\t  }\n\t  const results: [string, number][] = [];\n\t  results.push(['in', inTime]);\n\t  results.push(['Object.keys.includes', objectKeysIncludesTime]);\n", "  results.push([\n\t    'Object.getOwnPropertyNames.includes',\n\t    objectGetOwnPropertyIncludesTime,\n\t  ]);\n\t  showResults(results);\n\t  function timeFunction(func: (schema: TSchema) => number): number {\n\t    let start = performance.now();\n\t    for (let i = 0; i < iterations[1]; ++i) {\n\t      func(schema);\n\t    }\n", "    return performance.now() - start;\n\t  }\n\t}\n\tfunction showResults(results: [string, number][]) {\n\t  results.sort((a, b) => b[1] - a[1]);\n\t  for (const [name, time] of results) {\n\t    console.log(\n\t      `${\n\t        Math.round((time / results[results.length - 1][1]) * 100) / 100\n\t      }x - ${name} (${time}ms)`\n", "    );\n\t  }\n\t  console.log();\n\t}\n"]}
{"filename": "src/test/test-utils.ts", "chunked_list": ["import { TObject, TSchema, TUnion } from '@sinclair/typebox';\n\timport { AbstractValidator } from '../abstract/abstract-validator';\n\texport enum ValidatorKind {\n\t  All,\n\t  Compiling,\n\t  NonCompiling,\n\t}\n\texport enum MethodKind {\n\t  All,\n\t  Test,\n", "  TestReturningErrors,\n\t  TestReturningFirstError,\n\t  Assert,\n\t  AssertAndClean,\n\t  AssertAndCleanCopy,\n\t  Validate,\n\t  ValidateAndClean,\n\t  ValidateAndCleanCopy,\n\t  Errors,\n\t  FirstError,\n", "  InvalidSchema,\n\t}\n\texport type ValidatorMethodOfClass<T> = {\n\t  [K in keyof T]: T[K] extends (value: any, errorMessage?: string) => any\n\t    ? K\n\t    : never;\n\t}[keyof T];\n\texport interface TestSpec {\n\t  onlySpec: boolean;\n\t}\n", "export interface ValidTestSpec<S extends TSchema> extends TestSpec {\n\t  description: string;\n\t  schema: S;\n\t  value: any;\n\t}\n\texport interface ValidUnionTestSpec extends ValidTestSpec<TUnion<TObject[]>> {\n\t  selectedIndex: number;\n\t}\n\texport interface InvalidTestSpec<S extends TSchema> extends TestSpec {\n\t  description: string;\n", "  schema: S;\n\t  value: any;\n\t  overallMessage?: string;\n\t  assertMessage?: string;\n\t  errors: { path: string; message: string }[];\n\t  assertString?: string;\n\t  validateString?: string;\n\t}\n\texport function specsToRun<S extends TestSpec>(specs: S[]): S[] {\n\t  for (const spec of specs) {\n", "    if (spec.onlySpec) {\n\t      return [spec];\n\t    }\n\t  }\n\t  return specs;\n\t}\n\texport class ValidatorCache {\n\t  compilingValidators = new Map<TSchema, AbstractValidator<TSchema>>();\n\t  nonCompilingValidators = new Map<TSchema, AbstractValidator<TSchema>>();\n\t  getCompiling<S extends TSchema>(\n", "    schema: S,\n\t    createValidator: (schema: S) => AbstractValidator<S>\n\t  ): AbstractValidator<TSchema> {\n\t    return this._getCachedValidator(\n\t      this.compilingValidators,\n\t      schema,\n\t      createValidator\n\t    );\n\t  }\n\t  getNonCompiling<S extends TSchema>(\n", "    schema: S,\n\t    createValidator: (schema: S) => AbstractValidator<S>\n\t  ): AbstractValidator<TSchema> {\n\t    return this._getCachedValidator(\n\t      this.nonCompilingValidators,\n\t      schema,\n\t      createValidator\n\t    );\n\t  }\n\t  private _getCachedValidator<S extends TSchema>(\n", "    cache: Map<TSchema, AbstractValidator<TSchema>>,\n\t    schema: S,\n\t    createValidator: (schema: S) => AbstractValidator<S>\n\t  ): AbstractValidator<TSchema> {\n\t    let validator = cache.get(schema);\n\t    if (validator === undefined) {\n\t      validator = createValidator(schema);\n\t      cache.set(schema, validator);\n\t    }\n\t    return validator;\n", "  }\n\t}\n"]}
{"filename": "src/test/heterogeneous-union-validators-valid.test.ts", "chunked_list": ["import { TObject, TSchema, TUnion, Type } from '@sinclair/typebox';\n\timport { AbstractValidator } from '../abstract/abstract-validator';\n\timport { AbstractTypedUnionValidator } from '../abstract/abstract-typed-union-validator';\n\timport { HeterogeneousUnionValidator } from '../heterogeneous/heterogeneous-union-validator';\n\timport { CompilingHeterogeneousUnionValidator } from '../heterogeneous/compiling-heterogeneous-union-validator';\n\timport { TypeIdentifyingKey } from '../heterogeneous/type-identifying-key';\n\timport {\n\t  ValidUnionTestSpec,\n\t  ValidatorKind,\n\t  MethodKind,\n", "  ValidatorCache,\n\t  ValidTestSpec,\n\t} from './test-utils';\n\timport { testValidSpecs } from './test-valid-specs';\n\tconst onlyRunValidator = ValidatorKind.All;\n\tconst onlyRunMethod = MethodKind.All;\n\tconst wellFormedUnion1 = Type.Union([\n\t  Type.Object({\n\t    unique1: TypeIdentifyingKey(Type.String()),\n\t    str1: Type.String(),\n", "    str2: Type.Optional(Type.String()),\n\t  }),\n\t  Type.Object({\n\t    unique2: TypeIdentifyingKey(Type.Integer()),\n\t    int1: Type.Integer(),\n\t    int2: Type.Optional(Type.Integer()),\n\t  }),\n\t  Type.Object({\n\t    \"s'quote\": TypeIdentifyingKey(Type.String()),\n\t    str1: Type.String(),\n", "  }),\n\t]);\n\tconst wellFormedUnion2 = Type.Union(\n\t  [\n\t    Type.Object({\n\t      str1: Type.String(),\n\t      str2: Type.String(),\n\t      unique3: Type.String(),\n\t      unique1: TypeIdentifyingKey(Type.String()),\n\t      opt: Type.Optional(Type.String()),\n", "    }),\n\t    Type.Object({\n\t      str1: Type.String(),\n\t      unique2: TypeIdentifyingKey(Type.String()),\n\t      str2: Type.String(),\n\t      opt: Type.Optional(Type.Integer()),\n\t    }),\n\t  ],\n\t  { errorMessage: 'Unknown type' }\n\t);\n", "const validatorCache = new ValidatorCache();\n\tdescribe('heterogenous union validators - valid values', () => {\n\t  if (runThisValidator(ValidatorKind.NonCompiling)) {\n\t    describe('HeterogeneousUnionValidator', () => {\n\t      testValidator(\n\t        (schema: TSchema) =>\n\t          validatorCache.getNonCompiling(\n\t            schema,\n\t            () => new HeterogeneousUnionValidator(schema as TUnion<TObject[]>)\n\t          ) as AbstractTypedUnionValidator<TUnion<TObject[]>>\n", "      );\n\t    });\n\t  }\n\t  if (runThisValidator(ValidatorKind.Compiling)) {\n\t    describe('CompilingHeterogeneousUnionValidator', () => {\n\t      testValidator((schema: TSchema) =>\n\t        validatorCache.getCompiling(\n\t          schema,\n\t          () =>\n\t            new CompilingHeterogeneousUnionValidator(\n", "              schema as TUnion<TObject[]>\n\t            )\n\t        )\n\t      );\n\t    });\n\t  }\n\t});\n\tfunction testValidator(\n\t  createValidator: (schema: TSchema) => AbstractValidator<TSchema>\n\t) {\n", "  testValidSpecs(runThisTest, createValidator, verifyCleaning, [\n\t    {\n\t      description: 'valid hetero union 1, no unrecognized fields',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: { unique1: 'hello', str1: 'hello' },\n\t      selectedIndex: 0,\n\t    },\n\t    {\n\t      description: 'valid hetero union 2, no unrecognized fields',\n", "      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: { unique2: 1, int1: 1 },\n\t      selectedIndex: 1,\n\t    },\n\t    {\n\t      description: 'valid hetero union 3, with unrecognized fields',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: {\n", "        unique1: 'hello',\n\t        str1: 'hello',\n\t        int1: 1,\n\t        unrecognized1: 1,\n\t        unrecognized2: 'abc',\n\t      },\n\t      selectedIndex: 0,\n\t    },\n\t    {\n\t      description: 'valid hetero union 4, with unrecognized fields',\n", "      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: {\n\t        unique2: 1,\n\t        str1: 'hello',\n\t        int1: 1,\n\t        unrecognized1: 1,\n\t        unrecognized2: 'abc',\n\t      },\n\t      selectedIndex: 1,\n", "    },\n\t    {\n\t      description: 'valid hetero union 5, selecting by member keys',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion2,\n\t      value: { str1: 'a', str2: 'b', unique1: 'c', unique3: 'd', opt: 'e' },\n\t      selectedIndex: 0,\n\t    },\n\t    {\n\t      description: 'valid hetero union 6, selecting by member keys',\n", "      onlySpec: false,\n\t      schema: wellFormedUnion2,\n\t      value: {\n\t        str1: 'a',\n\t        unique2: 'b',\n\t        str2: 'c',\n\t        opt: 32,\n\t      },\n\t      selectedIndex: 1,\n\t    },\n", "    {\n\t      description: 'valid hetero union 7, selecting quoted key',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: { \"s'quote\": 'a', str1: 'b' },\n\t      selectedIndex: 2,\n\t    },\n\t  ]);\n\t}\n\tfunction verifyCleaning(spec: ValidTestSpec<TSchema>, value: any): void {\n", "  const unionSpec = spec as ValidUnionTestSpec;\n\t  const validProperties = Object.keys(\n\t    unionSpec.schema.anyOf[unionSpec.selectedIndex].properties\n\t  );\n\t  for (const key in value) {\n\t    expect(validProperties.includes(key)).toBe(true);\n\t  }\n\t  expect(Object.keys(value).length).toBeLessThanOrEqual(validProperties.length);\n\t}\n\tfunction runThisValidator(validatorKind: ValidatorKind): boolean {\n", "  return [ValidatorKind.All, validatorKind].includes(onlyRunValidator);\n\t}\n\tfunction runThisTest(methodKind: MethodKind): boolean {\n\t  return [MethodKind.All, methodKind].includes(onlyRunMethod);\n\t}\n"]}
{"filename": "src/test/discriminated-union-validators-invalid.test.ts", "chunked_list": ["import { TSchema, TObject, Type, TUnion } from '@sinclair/typebox';\n\timport { AbstractTypedUnionValidator } from '../abstract/abstract-typed-union-validator';\n\timport { DiscriminatedUnionValidator } from '../discriminated/discriminated-union-validator';\n\timport { CompilingDiscriminatedUnionValidator } from '../discriminated/compiling-discriminated-union-validator';\n\timport {\n\t  DEFAULT_OVERALL_MESSAGE,\n\t  DEFAULT_UNKNOWN_TYPE_MESSAGE,\n\t} from '../lib/error-utils';\n\timport { ValidatorKind, MethodKind, ValidatorCache } from './test-utils';\n\timport { testInvalidSpecs } from './test-invalid-specs';\n", "const onlyRunValidator = ValidatorKind.All;\n\tconst onlyRunMethod = MethodKind.All;\n\tconst wellFormedUnion1 = Type.Union([\n\t  Type.Object({\n\t    kind: Type.Literal('s'),\n\t    str1: Type.String(),\n\t    str2: Type.Optional(Type.String()),\n\t  }),\n\t  Type.Object({\n\t    kind: Type.Literal('i'),\n", "    int1: Type.Integer(),\n\t    int2: Type.Optional(\n\t      Type.Integer({\n\t        errorMessage: 'must be an int',\n\t      })\n\t    ),\n\t  }),\n\t]);\n\tconst wellFormedUnion2 = Type.Union(\n\t  [\n", "    Type.Object({\n\t      str1: Type.String(),\n\t      t: Type.Literal('s'),\n\t      str2: Type.Optional(Type.String()),\n\t    }),\n\t    Type.Object({\n\t      int1: Type.Integer(),\n\t      int2: Type.Optional(Type.Integer()),\n\t      t: Type.Literal('i'),\n\t    }),\n", "  ],\n\t  { discriminantKey: 't', errorMessage: 'Unknown type' }\n\t);\n\tconst illFormedUnion = Type.Union(\n\t  [\n\t    Type.Object({\n\t      t: Type.Literal('s'),\n\t      str1: Type.String(),\n\t      str2: Type.Optional(Type.String()),\n\t    }),\n", "    Type.Object({\n\t      kind: Type.Literal('i'),\n\t      int1: Type.Integer(),\n\t      int2: Type.Optional(Type.Integer()),\n\t    }),\n\t  ],\n\t  { discriminantKey: 't' }\n\t);\n\tconst validatorCache = new ValidatorCache();\n\tdescribe('discriminated union validators - invalid values', () => {\n", "  if (runThisValidator(ValidatorKind.NonCompiling)) {\n\t    describe('DiscriminatedUnionValidator', () => {\n\t      testValidator(\n\t        (schema: TSchema) =>\n\t          validatorCache.getNonCompiling(\n\t            schema,\n\t            () => new DiscriminatedUnionValidator(schema as TUnion<TObject[]>)\n\t          ) as AbstractTypedUnionValidator<TUnion<TObject[]>>\n\t      );\n\t    });\n", "  }\n\t  if (runThisValidator(ValidatorKind.Compiling)) {\n\t    describe('CompilingDiscriminatedUnionValidator', () => {\n\t      testValidator(\n\t        (schema: TSchema) =>\n\t          validatorCache.getCompiling(\n\t            schema,\n\t            () =>\n\t              new CompilingDiscriminatedUnionValidator(\n\t                schema as TUnion<TObject[]>\n", "              )\n\t          ) as AbstractTypedUnionValidator<TUnion<TObject[]>>\n\t      );\n\t    });\n\t  }\n\t});\n\tfunction testValidator(\n\t  createValidator: (\n\t    schema: TSchema\n\t  ) => AbstractTypedUnionValidator<TUnion<TObject[]>>\n", ") {\n\t  const defaultString = `${DEFAULT_OVERALL_MESSAGE}:\\n * ${DEFAULT_UNKNOWN_TYPE_MESSAGE}`;\n\t  testInvalidSpecs(runThisTest, createValidator, [\n\t    {\n\t      description: 'selects 1st union member, single error',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: { kind: 's', int1: 1 },\n\t      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [{ path: '/str1', message: 'Expected string' }],\n", "      assertString: 'Invalid value:\\n * str1 - Expected string',\n\t      validateString: 'Invalid value:\\n * str1 - Expected string',\n\t    },\n\t    {\n\t      description: 'selects 2nd union member, multiple errors',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: { kind: 'i', int1: '1', int2: 'hello' },\n\t      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [\n", "        { path: '/int1', message: 'Expected integer' },\n\t        { path: '/int2', message: 'must be an int' },\n\t      ],\n\t      assertString: 'Invalid value:\\n * int1 - Expected integer',\n\t      validateString:\n\t        'Invalid value:\\n' +\n\t        ' * int1 - Expected integer\\n' +\n\t        ' * int2 - must be an int',\n\t    },\n\t    {\n", "      description: 'discriminant key value not selecting any union member',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: { kind: 'not-there', str1: 'hello' },\n\t      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n\t      assertString: defaultString,\n\t      validateString: defaultString,\n\t    },\n\t    {\n", "      description: 'value lacking discriminant key',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: { str1: 'hello', int1: 1 },\n\t      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n\t      assertString: defaultString,\n\t      validateString: defaultString,\n\t    },\n\t    {\n", "      description: 'empty object value',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: {},\n\t      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n\t      assertString: defaultString,\n\t      validateString: defaultString,\n\t    },\n\t    {\n", "      description: 'undefined value',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: undefined,\n\t      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n\t      assertString: defaultString,\n\t      validateString: defaultString,\n\t    },\n\t    {\n", "      description: 'null value',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: null,\n\t      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n\t      assertString: defaultString,\n\t      validateString: defaultString,\n\t    },\n\t    {\n", "      description: 'simple literal value',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: 'hello',\n\t      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n\t      assertString: defaultString,\n\t      validateString: defaultString,\n\t    },\n\t    {\n", "      description:\n\t        'selects 1st union member, non-1st discriminant, invalid, with overall message',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion2,\n\t      value: { t: 's', str1: 32 },\n\t      overallMessage: 'Custom message',\n\t      assertMessage: 'Custom message',\n\t      errors: [{ path: '/str1', message: 'Expected string' }],\n\t      assertString: 'Custom message:\\n * str1 - Expected string',\n\t      validateString: 'Custom message:\\n * str1 - Expected string',\n", "    },\n\t    {\n\t      description: 'not selecting any union member, with custom type error',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion2,\n\t      value: { t: 'not-there', str1: 'hello' },\n\t      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [{ path: '', message: 'Unknown type' }],\n\t      assertString: 'Invalid value:\\n * Unknown type',\n\t      validateString: 'Invalid value:\\n * Unknown type',\n", "    },\n\t    {\n\t      description:\n\t        'not selecting any union member, with custom overall and type errors',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion2,\n\t      value: { int1: 32 },\n\t      overallMessage: 'Oopsie: {error}',\n\t      assertMessage: 'Oopsie: Unknown type',\n\t      errors: [{ path: '', message: 'Unknown type' }],\n", "      assertString: 'Oopsie: Unknown type:\\n * Unknown type',\n\t      validateString: 'Oopsie:\\n * Unknown type',\n\t    },\n\t  ]);\n\t  if ([MethodKind.All, MethodKind.InvalidSchema].includes(onlyRunMethod)) {\n\t    const errorMessage = `Discriminant key 't' not present in all members of discriminated union`;\n\t    describe('errors on invalid union schemas', () => {\n\t      it('union having members lacking the discriminant key, valid value', () => {\n\t        const validator = createValidator(illFormedUnion);\n\t        const validObject = { t: 's', str1: 'hello' };\n", "        expect(() => validator.test(validObject)).toThrow(errorMessage);\n\t        expect(() => validator.assert(validObject)).toThrow(errorMessage);\n\t        expect(() => validator.assertAndClean(validObject)).toThrow(\n\t          errorMessage\n\t        );\n\t        expect(() => validator.assertAndCleanCopy(validObject)).toThrow(\n\t          errorMessage\n\t        );\n\t        expect(() => validator.validate(validObject)).toThrow(errorMessage);\n\t        expect(() => validator.validateAndClean(validObject)).toThrow(\n", "          errorMessage\n\t        );\n\t        expect(() => validator.validateAndCleanCopy(validObject)).toThrow(\n\t          errorMessage\n\t        );\n\t        expect(() => validator.errors(validObject)).toThrow(errorMessage);\n\t      });\n\t      it('union having members lacking the discriminant key, invalid value', () => {\n\t        const validator = createValidator(illFormedUnion);\n\t        const invalidObject = { s: 'hello', str1: 32 };\n", "        expect(() => validator.test(invalidObject)).toThrow(errorMessage);\n\t        expect(() => validator.assert(invalidObject)).toThrow(errorMessage);\n\t        expect(() => validator.assertAndClean(invalidObject)).toThrow(\n\t          errorMessage\n\t        );\n\t        expect(() => validator.assertAndCleanCopy(invalidObject)).toThrow(\n\t          errorMessage\n\t        );\n\t        expect(() => validator.validate(invalidObject)).toThrow(errorMessage);\n\t        expect(() => validator.validateAndClean(invalidObject)).toThrow(\n", "          errorMessage\n\t        );\n\t        expect(() => validator.validateAndCleanCopy(invalidObject)).toThrow(\n\t          errorMessage\n\t        );\n\t        expect(() => validator.errors(invalidObject)).toThrow(errorMessage);\n\t      });\n\t    });\n\t  }\n\t}\n", "function runThisValidator(validatorKind: ValidatorKind): boolean {\n\t  return [ValidatorKind.All, validatorKind].includes(onlyRunValidator);\n\t}\n\tfunction runThisTest(methodKind: MethodKind): boolean {\n\t  return [MethodKind.All, methodKind].includes(onlyRunMethod);\n\t}\n"]}
{"filename": "src/test/heterogeneous-union-validators-invalid.test.ts", "chunked_list": ["import { TSchema, TObject, Type, TUnion } from '@sinclair/typebox';\n\timport { AbstractTypedUnionValidator } from '../abstract/abstract-typed-union-validator';\n\timport { HeterogeneousUnionValidator } from '../heterogeneous/heterogeneous-union-validator';\n\timport { CompilingHeterogeneousUnionValidator } from '../heterogeneous/compiling-heterogeneous-union-validator';\n\timport { TypeIdentifyingKey } from '../heterogeneous//type-identifying-key';\n\timport {\n\t  DEFAULT_OVERALL_MESSAGE,\n\t  DEFAULT_UNKNOWN_TYPE_MESSAGE,\n\t} from '../lib/error-utils';\n\timport { ValidatorKind, MethodKind, ValidatorCache } from './test-utils';\n", "import { testInvalidSpecs } from './test-invalid-specs';\n\timport {\n\t  MESSAGE_MEMBERS_MISSING_KEY,\n\t  MESSAGE_MULTIPLE_MEMBERS_WITH_SAME_KEY,\n\t  MESSAGE_MEMBER_WITH_MULTIPLE_KEYS,\n\t  MESSAGE_OPTIONAL_TYPE_ID_KEY,\n\t} from '../heterogeneous/type-identifying-key-index';\n\tconst onlyRunValidator = ValidatorKind.NonCompiling;\n\tconst onlyRunMethod = MethodKind.InvalidSchema;\n\tconst wellFormedUnion1 = Type.Union([\n", "  Type.Object({\n\t    unique1: TypeIdentifyingKey(Type.String()),\n\t    str1: Type.String(),\n\t    str2: Type.Optional(Type.String()),\n\t  }),\n\t  Type.Object({\n\t    unique2: TypeIdentifyingKey(Type.Integer()),\n\t    int1: Type.Integer(),\n\t    int2: Type.Optional(\n\t      Type.Integer({\n", "        errorMessage: 'must be an int',\n\t      })\n\t    ),\n\t  }),\n\t]);\n\tconst wellFormedUnion2 = Type.Union(\n\t  [\n\t    Type.Object({\n\t      str1: Type.String(),\n\t      str2: Type.String(),\n", "      unique3: Type.String(),\n\t      unique1: TypeIdentifyingKey(Type.String()),\n\t      opt: Type.Optional(Type.String()),\n\t    }),\n\t    Type.Object({\n\t      str1: Type.String(),\n\t      unique2: TypeIdentifyingKey(Type.String()),\n\t      str2: Type.String(),\n\t      opt: Type.Optional(Type.Integer()),\n\t    }),\n", "  ],\n\t  { errorMessage: 'Unknown type' }\n\t);\n\tconst unionDupTypeKeysMultipleMembers = Type.Union([\n\t  Type.Object({\n\t    s: TypeIdentifyingKey(Type.String()),\n\t    str1: Type.Optional(Type.String()),\n\t  }),\n\t  Type.Object({\n\t    s: TypeIdentifyingKey(Type.Integer()),\n", "    int1: Type.Optional(Type.Integer()),\n\t  }),\n\t]);\n\tconst unionDupTypeKeysSingleMembers = Type.Union([\n\t  Type.Object({\n\t    s1: TypeIdentifyingKey(Type.String()),\n\t    s3: TypeIdentifyingKey(Type.String()),\n\t    str1: Type.Optional(Type.String()),\n\t  }),\n\t  Type.Object({\n", "    s2: TypeIdentifyingKey(Type.Integer()),\n\t    int1: Type.Optional(Type.Integer()),\n\t  }),\n\t]);\n\tconst unionMissingTypeKeys = Type.Union([\n\t  Type.Object({\n\t    s1: TypeIdentifyingKey(Type.String()),\n\t    str1: Type.Optional(Type.String()),\n\t  }),\n\t  Type.Object({\n", "    s2: Type.String(),\n\t    int1: Type.Optional(Type.Integer()),\n\t  }),\n\t]);\n\tconst unionOptionalTypeKey = Type.Union([\n\t  Type.Object({\n\t    s1: TypeIdentifyingKey(Type.String()),\n\t    str1: Type.Optional(Type.String()),\n\t  }),\n\t  Type.Object({\n", "    s2: TypeIdentifyingKey(Type.Optional(Type.Integer())),\n\t    int1: Type.Optional(Type.Integer()),\n\t  }),\n\t]);\n\tconst validatorCache = new ValidatorCache();\n\tdescribe('heterogenous union validators - invalid values', () => {\n\t  if (runThisValidator(ValidatorKind.NonCompiling)) {\n\t    describe('HeterogeneousUnionValidator', () => {\n\t      testValidator(\n\t        (schema: TSchema) =>\n", "          validatorCache.getNonCompiling(\n\t            schema,\n\t            () => new HeterogeneousUnionValidator(schema as TUnion<TObject[]>)\n\t          ) as AbstractTypedUnionValidator<TUnion<TObject[]>>\n\t      );\n\t    });\n\t  }\n\t  if (runThisValidator(ValidatorKind.Compiling)) {\n\t    describe('CompilingHeterogeneousUnionValidator', () => {\n\t      testValidator(\n", "        (schema: TSchema) =>\n\t          validatorCache.getCompiling(\n\t            schema,\n\t            () =>\n\t              new CompilingHeterogeneousUnionValidator(\n\t                schema as TUnion<TObject[]>\n\t              )\n\t          ) as AbstractTypedUnionValidator<TUnion<TObject[]>>\n\t      );\n\t    });\n", "  }\n\t});\n\tfunction testValidator(\n\t  createValidator: (\n\t    schema: TSchema\n\t  ) => AbstractTypedUnionValidator<TUnion<TObject[]>>\n\t) {\n\t  const defaultString = `${DEFAULT_OVERALL_MESSAGE}:\\n * ${DEFAULT_UNKNOWN_TYPE_MESSAGE}`;\n\t  testInvalidSpecs(runThisTest, createValidator, [\n\t    {\n", "      description: 'selects 1st union member, 1st key unique, single error',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: { unique1: 'hello', int1: 1 },\n\t      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [{ path: '/str1', message: 'Expected string' }],\n\t      assertString: 'Invalid value:\\n * str1 - Expected string',\n\t      validateString: 'Invalid value:\\n * str1 - Expected string',\n\t    },\n\t    {\n", "      description: 'selects 2nd union member, 1st key unique, multiple errors',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: { unique2: 1, str1: 'hello', int2: 'hello' },\n\t      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [\n\t        { path: '/int1', message: 'Expected integer' },\n\t        { path: '/int2', message: 'must be an int' },\n\t      ],\n\t      assertString: 'Invalid value:\\n * int1 - Expected integer',\n", "      validateString:\n\t        'Invalid value:\\n' +\n\t        ' * int1 - Expected integer\\n' +\n\t        ' * int2 - must be an int',\n\t    },\n\t    {\n\t      description: 'unique field not selecting any union member',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: { x: 'hello', str1: 'hello', int1: 1 },\n", "      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n\t      assertString: defaultString,\n\t      validateString: defaultString,\n\t    },\n\t    {\n\t      description: 'unique fields selecting multiple union members',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: { str1: 'hello', int1: 1 },\n", "      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n\t      assertString: defaultString,\n\t      validateString: defaultString,\n\t    },\n\t    {\n\t      description: 'empty object value',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: {},\n", "      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n\t      assertString: defaultString,\n\t      validateString: defaultString,\n\t    },\n\t    {\n\t      description: 'undefined value',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: undefined,\n", "      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n\t      assertString: defaultString,\n\t      validateString: defaultString,\n\t    },\n\t    {\n\t      description: 'null value',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: null,\n", "      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n\t      assertString: defaultString,\n\t      validateString: defaultString,\n\t    },\n\t    {\n\t      description: 'simple literal value',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion1,\n\t      value: 'hello',\n", "      assertMessage: DEFAULT_OVERALL_MESSAGE,\n\t      errors: [{ path: '', message: DEFAULT_UNKNOWN_TYPE_MESSAGE }],\n\t      assertString: defaultString,\n\t      validateString: defaultString,\n\t    },\n\t    {\n\t      description:\n\t        'selects 1st union member, non-1st key unique, invalid, with overall message',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion2,\n", "      value: {\n\t        str1: 'a',\n\t        str2: 'b',\n\t        unique1: 'c',\n\t        unique3: 'd',\n\t        opt: 32,\n\t      },\n\t      overallMessage: 'Custom message',\n\t      assertMessage: 'Custom message',\n\t      errors: [{ path: '/opt', message: 'Expected string' }],\n", "      assertString: 'Custom message:\\n * opt - Expected string',\n\t      validateString: 'Custom message:\\n * opt - Expected string',\n\t    },\n\t    {\n\t      description:\n\t        'selects 2nd union member, non-1st key unique, invalid key value',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion2,\n\t      value: { str1: 'a', unique2: 1, str2: 'c', opt: 32 },\n\t      assertMessage: DEFAULT_OVERALL_MESSAGE,\n", "      errors: [{ path: '/unique2', message: 'Expected string' }],\n\t      assertString: 'Invalid value:\\n * unique2 - Expected string',\n\t      validateString: 'Invalid value:\\n * unique2 - Expected string',\n\t    },\n\t    {\n\t      description: 'not selecting any union member, with custom type error',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion2,\n\t      value: { x: 'not-there' },\n\t      assertMessage: DEFAULT_OVERALL_MESSAGE,\n", "      errors: [{ path: '', message: 'Unknown type' }],\n\t      assertString: 'Invalid value:\\n * Unknown type',\n\t      validateString: 'Invalid value:\\n * Unknown type',\n\t    },\n\t    {\n\t      description:\n\t        'not selecting any union member, with custom overall and type errors',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion2,\n\t      value: { opt: 32 },\n", "      overallMessage: 'Oopsie: {error}',\n\t      assertMessage: 'Oopsie: Unknown type',\n\t      errors: [{ path: '', message: 'Unknown type' }],\n\t      assertString: 'Oopsie: Unknown type:\\n * Unknown type',\n\t      validateString: 'Oopsie:\\n * Unknown type',\n\t    },\n\t    {\n\t      description: 'not selecting any union member, but having a unique key',\n\t      onlySpec: false,\n\t      schema: wellFormedUnion2,\n", "      value: { unique3: 'hello' },\n\t      overallMessage: 'Oopsie: {error}',\n\t      assertMessage: 'Oopsie: Unknown type',\n\t      errors: [{ path: '', message: 'Unknown type' }],\n\t      assertString: 'Oopsie: Unknown type:\\n * Unknown type',\n\t      validateString: 'Oopsie:\\n * Unknown type',\n\t    },\n\t  ]);\n\t  if ([MethodKind.All, MethodKind.InvalidSchema].includes(onlyRunMethod)) {\n\t    describe('errors on invalid union schemas', () => {\n", "      it('union with members missing keys', () => {\n\t        const validator = createValidator(unionMissingTypeKeys);\n\t        expect(() => validator.test({})).toThrow(MESSAGE_MEMBERS_MISSING_KEY);\n\t      });\n\t      it('union with multiple members having same key', () => {\n\t        const validator = createValidator(unionDupTypeKeysMultipleMembers);\n\t        expect(() => validator.assert({})).toThrow(\n\t          MESSAGE_MULTIPLE_MEMBERS_WITH_SAME_KEY\n\t        );\n\t      });\n", "      it('union with single member having multiple keys', () => {\n\t        const validator = createValidator(unionDupTypeKeysSingleMembers);\n\t        expect(() => validator.validate({})).toThrow(\n\t          MESSAGE_MEMBER_WITH_MULTIPLE_KEYS\n\t        );\n\t      });\n\t      it('union with optional type identifying key', () => {\n\t        const validator = createValidator(unionOptionalTypeKey);\n\t        expect(() => validator.errors({})).toThrow(\n\t          MESSAGE_OPTIONAL_TYPE_ID_KEY\n", "        );\n\t      });\n\t    });\n\t  }\n\t}\n\tfunction runThisValidator(validatorKind: ValidatorKind): boolean {\n\t  return [ValidatorKind.All, validatorKind].includes(onlyRunValidator);\n\t}\n\tfunction runThisTest(methodKind: MethodKind): boolean {\n\t  return [MethodKind.All, methodKind].includes(onlyRunMethod);\n", "}\n"]}
{"filename": "src/test/standard-validators-valid.test.ts", "chunked_list": ["import { TSchema, Type } from '@sinclair/typebox';\n\timport { AbstractStandardValidator } from '../abstract/abstract-standard-validator';\n\timport { StandardValidator } from '../standard/standard-validator';\n\timport { CompilingStandardValidator } from '../standard/compiling-standard-validator';\n\timport {\n\t  ValidTestSpec,\n\t  ValidatorKind,\n\t  MethodKind,\n\t  ValidatorCache,\n\t} from './test-utils';\n", "import { testValidSpecs } from './test-valid-specs';\n\tconst onlyRunValidator = ValidatorKind.All;\n\tconst onlyRunMethod = MethodKind.All;\n\tconst schema0 = Type.String({\n\t  minLength: 5,\n\t  maxLength: 10,\n\t  pattern: '^[a-zA-Z]+$',\n\t});\n\tconst schema1 = Type.Object({\n\t  delta: Type.Integer(),\n", "  count: Type.Integer({ exclusiveMinimum: 0 }),\n\t  name: schema0,\n\t});\n\tconst validatorCache = new ValidatorCache();\n\tdescribe('standard validators - valid values', () => {\n\t  if (runThisValidator(ValidatorKind.NonCompiling)) {\n\t    describe('StandardValidator', () => {\n\t      testValidator((schema: TSchema) =>\n\t        validatorCache.getNonCompiling(\n\t          schema,\n", "          () => new StandardValidator(schema)\n\t        )\n\t      );\n\t    });\n\t  }\n\t  if (runThisValidator(ValidatorKind.Compiling)) {\n\t    describe('CompilingStandardValidator', () => {\n\t      testValidator((schema: TSchema) =>\n\t        validatorCache.getCompiling(\n\t          schema,\n", "          () => new CompilingStandardValidator(schema)\n\t        )\n\t      );\n\t    });\n\t  }\n\t});\n\tfunction testValidator(\n\t  createValidator: (schema: TSchema) => AbstractStandardValidator<TSchema>\n\t) {\n\t  testValidSpecs(runThisTest, createValidator, verifyCleaning, [\n", "    {\n\t      description: 'valid value 0, string literal',\n\t      onlySpec: false,\n\t      schema: schema0,\n\t      value: 'ABCDEDEFGH',\n\t    },\n\t    {\n\t      description: 'valid value 1, no unrecognized fields',\n\t      onlySpec: false,\n\t      schema: schema1,\n", "      value: { delta: 0, count: 1, name: 'ABCDE' },\n\t    },\n\t    {\n\t      description: 'valid value 2, with unrecognized fields',\n\t      onlySpec: false,\n\t      schema: schema1,\n\t      value: {\n\t        delta: -5,\n\t        count: 125,\n\t        name: 'ABCDEDEFGH',\n", "        unrecognized1: 1,\n\t        unrecognized2: 'abc',\n\t      },\n\t    },\n\t  ]);\n\t}\n\tfunction verifyCleaning(spec: ValidTestSpec<TSchema>, value: any): void {\n\t  if (spec.schema.properties !== undefined) {\n\t    for (const key in value) {\n\t      expect(key in spec.schema.properties).toBe(true);\n", "    }\n\t    expect(Object.keys(value).length).toBeLessThanOrEqual(\n\t      Object.keys(spec.schema.properties).length\n\t    );\n\t  }\n\t}\n\tfunction runThisValidator(validatorKind: ValidatorKind): boolean {\n\t  return [ValidatorKind.All, validatorKind].includes(onlyRunValidator);\n\t}\n\tfunction runThisTest(methodKind: MethodKind): boolean {\n", "  return [MethodKind.All, methodKind].includes(onlyRunMethod);\n\t}\n"]}
{"filename": "src/test/test-valid-specs.ts", "chunked_list": ["import { TSchema } from '@sinclair/typebox';\n\timport { MethodKind, ValidTestSpec, specsToRun } from './test-utils';\n\timport { AbstractValidator } from '../abstract/abstract-validator';\n\texport function testValidSpecs<S extends ValidTestSpec<TSchema>>(\n\t  runThisTest: (method: MethodKind) => boolean,\n\t  createValidator: (schema: TSchema) => AbstractValidator<TSchema>,\n\t  verifyCleaning: (spec: S, value: any) => void,\n\t  validSpecs: S[]\n\t) {\n\t  specsToRun(validSpecs).forEach((spec) => {\n", "    if (runThisTest(MethodKind.Test)) {\n\t      describe('test()', () => {\n\t        it(`test() should accept ${spec.description}`, () => {\n\t          const validator = createValidator(spec.schema);\n\t          expect(validator.test(spec.value)).toBe(true);\n\t        });\n\t      });\n\t    }\n\t    if (runThisTest(MethodKind.TestReturningErrors)) {\n\t      describe('testReturningErrors()', () => {\n", "        specsToRun(validSpecs).forEach((spec) => {\n\t          it('testReturningErrors() for ' + spec.description, () => {\n\t            const validator = createValidator(spec.schema);\n\t            const errors = validator.testReturningErrors(spec.value);\n\t            expect(errors).toBeNull();\n\t          });\n\t        });\n\t      });\n\t    }\n\t    if (runThisTest(MethodKind.TestReturningFirstError)) {\n", "      describe('testReturningFirstError()', () => {\n\t        specsToRun(validSpecs).forEach((spec) => {\n\t          it('testReturningFirstError() for ' + spec.description, () => {\n\t            const validator = createValidator(spec.schema);\n\t            const firstError = validator.testReturningFirstError(spec.value);\n\t            expect(firstError).toBeNull();\n\t          });\n\t        });\n\t      });\n\t    }\n", "    describe('no cleaning', () => {\n\t      if (runThisTest(MethodKind.Assert)) {\n\t        it(`assert() should accept ${spec.description}`, () => {\n\t          const validator = createValidator(spec.schema);\n\t          expect(() => validator.assert(spec.value)).not.toThrow();\n\t        });\n\t      }\n\t      if (runThisTest(MethodKind.Validate)) {\n\t        it(`validate() should accept ${spec.description}`, () => {\n\t          const validator = createValidator(spec.schema);\n", "          expect(() => validator.validate(spec.value)).not.toThrow();\n\t        });\n\t      }\n\t    });\n\t    describe('cleaning provided value', () => {\n\t      if (runThisTest(MethodKind.AssertAndClean)) {\n\t        it(`assertAndClean() should clean provided ${spec.description}`, () => {\n\t          const validator = createValidator(spec.schema);\n\t          const value =\n\t            typeof spec.value == 'object' ? { ...spec.value } : spec.value;\n", "          expect(() => validator.assertAndClean(value)).not.toThrow();\n\t          verifyCleaning(spec, value);\n\t        });\n\t      }\n\t      if (runThisTest(MethodKind.ValidateAndClean)) {\n\t        it(`validateAndClean() should clean provided ${spec.description}`, () => {\n\t          const validator = createValidator(spec.schema);\n\t          const value =\n\t            typeof spec.value == 'object' ? { ...spec.value } : spec.value;\n\t          expect(() => validator.validateAndClean(value)).not.toThrow();\n", "          verifyCleaning(spec, value);\n\t        });\n\t      }\n\t    });\n\t    describe('cleaning copy of value', () => {\n\t      if (runThisTest(MethodKind.AssertAndCleanCopy)) {\n\t        it(`assertAndCleanCopy() should clean copy of ${spec.description}`, () => {\n\t          const validator = createValidator(spec.schema);\n\t          const value = validator.assertAndCleanCopy(spec.value) as object;\n\t          verifyCleaning(spec, value);\n", "        });\n\t      }\n\t      if (runThisTest(MethodKind.ValidateAndCleanCopy)) {\n\t        it(`validateAndCleanCopy() should clean copy of ${spec.description}`, () => {\n\t          const validator = createValidator(spec.schema);\n\t          const value = validator.validateAndCleanCopy(spec.value) as object;\n\t          verifyCleaning(spec, value);\n\t        });\n\t      }\n\t    });\n", "    if (runThisTest(MethodKind.Errors)) {\n\t      describe('errors()', () => {\n\t        specsToRun(validSpecs).forEach((spec) => {\n\t          it('errors() for ' + spec.description, () => {\n\t            const validator = createValidator(spec.schema);\n\t            const errors = [...validator.errors(spec.value)];\n\t            expect(errors.length).toEqual(0);\n\t          });\n\t        });\n\t      });\n", "    }\n\t    if (runThisTest(MethodKind.FirstError)) {\n\t      describe('firstError()', () => {\n\t        specsToRun(validSpecs).forEach((spec) => {\n\t          it('firstError() for ' + spec.description, () => {\n\t            const validator = createValidator(spec.schema);\n\t            const firstError = validator.firstError(spec.value);\n\t            expect(firstError).toBeNull();\n\t          });\n\t        });\n", "      });\n\t    }\n\t  });\n\t}\n"]}
{"filename": "src/abstract/abstract-typed-union-validator.ts", "chunked_list": ["import { Static, TObject, TUnion } from '@sinclair/typebox';\n\timport { AbstractValidator } from './abstract-validator';\n\t/**\n\t * The key providing the object type in discriminated unions, if not\n\t * specified in the schema's `discriminantKey` option.\n\t */\n\texport const DEFAULT_DISCRIMINANT_KEY = 'kind';\n\t/**\n\t * Abstract validator for values that are typed member unions of objects.\n\t */\n", "export abstract class AbstractTypedUnionValidator<\n\t  S extends TUnion<TObject[]>\n\t> extends AbstractValidator<S> {\n\t  constructor(schema: S) {\n\t    super(schema);\n\t  }\n\t  /** @inheritdoc */\n\t  override assert(value: Readonly<unknown>, overallError?: string): void {\n\t    this.assertReturningSchema(value, overallError);\n\t  }\n", "  /** @inheritdoc */\n\t  override assertAndClean(value: unknown, overallError?: string): void {\n\t    const schema = this.assertReturningSchema(value as any, overallError);\n\t    this.cleanValue(schema, value);\n\t  }\n\t  /** @inheritdoc */\n\t  override assertAndCleanCopy(\n\t    value: Readonly<unknown>,\n\t    overallError?: string\n\t  ): Static<S> {\n", "    const schema = this.assertReturningSchema(value, overallError);\n\t    return this.cleanCopyOfValue(schema, value);\n\t  }\n\t  /** @inheritdoc */\n\t  override validate(value: Readonly<unknown>, overallError?: string): void {\n\t    this.validateReturningSchema(value, overallError);\n\t  }\n\t  /** @inheritdoc */\n\t  override validateAndClean(value: unknown, overallError?: string): void {\n\t    const schema = this.validateReturningSchema(value as any, overallError);\n", "    this.cleanValue(schema, value);\n\t  }\n\t  /** @inheritdoc */\n\t  override validateAndCleanCopy(\n\t    value: Readonly<unknown>,\n\t    overallError?: string\n\t  ): Static<S> {\n\t    const schema = this.validateReturningSchema(value, overallError);\n\t    return this.cleanCopyOfValue(schema, value);\n\t  }\n", "  protected abstract assertReturningSchema(\n\t    value: Readonly<unknown>,\n\t    overallError?: string\n\t  ): TObject;\n\t  protected abstract validateReturningSchema(\n\t    value: Readonly<unknown>,\n\t    overallError?: string\n\t  ): TObject;\n\t  protected toValueKeyDereference(key: string): string {\n\t    return /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(key)\n", "      ? `value.${key}`\n\t      : `value['${key.replace(/'/g, \"\\\\'\")}']`;\n\t  }\n\t}\n"]}
{"filename": "src/abstract/abstract-standard-validator.ts", "chunked_list": ["import type { Static, TSchema } from '@sinclair/typebox';\n\timport { AbstractValidator } from './abstract-validator';\n\t/**\n\t * Abstract validator for standard TypeBox values.\n\t */\n\texport abstract class AbstractStandardValidator<\n\t  S extends TSchema\n\t> extends AbstractValidator<S> {\n\t  /** @inheritdoc */\n\t  constructor(schema: Readonly<S>) {\n", "    super(schema);\n\t  }\n\t  /** @inheritdoc */\n\t  override assertAndClean(value: unknown, overallError?: string): void {\n\t    this.assert(value as any, overallError);\n\t    this.cleanValue(this.schema, value);\n\t  }\n\t  /** @inheritdoc */\n\t  override assertAndCleanCopy(\n\t    value: Readonly<unknown>,\n", "    overallError?: string\n\t  ): Static<S> {\n\t    this.assert(value, overallError);\n\t    return this.cleanCopyOfValue(this.schema, value);\n\t  }\n\t  /** @inheritdoc */\n\t  override validateAndClean(value: unknown, overallError?: string): void {\n\t    this.validate(value as any, overallError);\n\t    this.cleanValue(this.schema, value);\n\t  }\n", "  /** @inheritdoc */\n\t  override validateAndCleanCopy(\n\t    value: Readonly<unknown>,\n\t    overallError?: string\n\t  ): Static<S> {\n\t    this.validate(value, overallError);\n\t    return this.cleanCopyOfValue(this.schema, value);\n\t  }\n\t}\n"]}
{"filename": "src/abstract/abstract-compiling-typed-union-validator.ts", "chunked_list": ["import { TObject, TUnion } from '@sinclair/typebox';\n\timport { Value, ValueError } from '@sinclair/typebox/value';\n\timport { TypeCompiler } from '@sinclair/typebox/compiler';\n\timport { AbstractTypedUnionValidator } from './abstract-typed-union-validator';\n\timport {\n\t  createErrorsIterable,\n\t  createUnionTypeError,\n\t  createUnionTypeErrorIterable,\n\t  throwInvalidAssert,\n\t  throwInvalidValidate,\n", "} from '../lib/error-utils';\n\texport type FindSchemaMemberIndex = (value: unknown) => number | null;\n\texport type SchemaMemberTest = (value: object) => boolean;\n\t/**\n\t * Abstract validatory for typed unions, performing lazy compilation.\n\t */\n\texport abstract class AbstractCompilingTypedUnionValidator<\n\t  S extends TUnion<TObject[]>\n\t> extends AbstractTypedUnionValidator<S> {\n\t  #compiledSchemaMemberTests: (SchemaMemberTest | undefined)[];\n", "  /** @inheritdoc */\n\t  constructor(schema: Readonly<S>) {\n\t    super(schema);\n\t    this.#compiledSchemaMemberTests = new Array(schema.anyOf.length);\n\t  }\n\t  /** @inheritdoc */\n\t  override test(value: Readonly<unknown>): boolean {\n\t    const memberIndex = this.compiledFindSchemaMemberIndex(value);\n\t    return this.compiledSchemaMemberTest(memberIndex, value);\n\t  }\n", "  /** @inheritdoc */\n\t  override errors(value: Readonly<unknown>): Iterable<ValueError> {\n\t    const indexOrError = this.compiledFindSchemaMemberIndexOrError(value);\n\t    if (typeof indexOrError !== 'number') {\n\t      return createUnionTypeErrorIterable(indexOrError);\n\t    }\n\t    return createErrorsIterable(\n\t      Value.Errors(this.schema.anyOf[indexOrError], value)\n\t    );\n\t  }\n", "  protected override assertReturningSchema(\n\t    value: Readonly<unknown>,\n\t    overallError?: string\n\t  ): TObject {\n\t    const indexOrError = this.compiledFindSchemaMemberIndexOrError(value);\n\t    if (typeof indexOrError !== 'number') {\n\t      throwInvalidAssert(overallError, indexOrError);\n\t    }\n\t    const memberSchema = this.schema.anyOf[indexOrError];\n\t    if (!this.compiledSchemaMemberTest(indexOrError, value)) {\n", "      throwInvalidAssert(\n\t        overallError,\n\t        Value.Errors(memberSchema, value).First()!\n\t      );\n\t    }\n\t    return memberSchema;\n\t  }\n\t  protected override validateReturningSchema(\n\t    value: Readonly<unknown>,\n\t    overallError?: string\n", "  ): TObject {\n\t    const indexOrError = this.compiledFindSchemaMemberIndexOrError(value);\n\t    if (typeof indexOrError !== 'number') {\n\t      throwInvalidValidate(overallError, indexOrError);\n\t    }\n\t    const memberSchema = this.schema.anyOf[indexOrError];\n\t    if (!this.compiledSchemaMemberTest(indexOrError, value)) {\n\t      throwInvalidValidate(overallError, Value.Errors(memberSchema, value));\n\t    }\n\t    return memberSchema;\n", "  }\n\t  protected compiledFindSchemaMemberIndexOrError(\n\t    value: Readonly<unknown>\n\t  ): number | ValueError {\n\t    const memberIndex = this.compiledFindSchemaMemberIndex(value);\n\t    if (memberIndex === null) {\n\t      return createUnionTypeError(this.schema, value);\n\t    }\n\t    return memberIndex;\n\t  }\n", "  protected abstract compiledFindSchemaMemberIndex(\n\t    value: Readonly<unknown>\n\t  ): number | null;\n\t  private compiledSchemaMemberTest(\n\t    memberIndex: number | null,\n\t    value: Readonly<unknown>\n\t  ): boolean {\n\t    if (memberIndex === null) {\n\t      return false;\n\t    }\n", "    if (this.#compiledSchemaMemberTests[memberIndex] === undefined) {\n\t      let code = TypeCompiler.Compile(this.schema.anyOf[memberIndex]).Code();\n\t      code = code.replace(\n\t        `(typeof value === 'object' && value !== null && !Array.isArray(value)) &&`,\n\t        ''\n\t      );\n\t      // provide some resilience to change in TypeBox compiled code formatting\n\t      const startOfFunction = code.indexOf('function');\n\t      const startOfReturn = code.indexOf('return', startOfFunction);\n\t      code =\n", "        'return ' +\n\t        code.substring(code.indexOf('(', startOfReturn), code.length - 1);\n\t      this.#compiledSchemaMemberTests[memberIndex] = new Function(\n\t        'value',\n\t        code\n\t      ) as SchemaMemberTest;\n\t    }\n\t    return this.#compiledSchemaMemberTests[memberIndex]!(value);\n\t  }\n\t}\n"]}
{"filename": "src/abstract/abstract-validator.ts", "chunked_list": ["import type { TSchema, Static } from '@sinclair/typebox';\n\timport { Value, ValueError } from '@sinclair/typebox/value';\n\timport { throwInvalidAssert, throwInvalidValidate } from '../lib/error-utils';\n\t/**\n\t * Abstract base class for validators, providing validation services for a\n\t * JSON schema, offering both short-circuting and full validation, supporting\n\t * custom error messages, and optionally removing unrecognized properties.\n\t *\n\t * As of TypeBox version 0.28.13, when validating any given value, TypeBox\n\t * checks the value's `maxItems` and `maxLength` constraints before testing\n", " * any other constraints. An API endpoint can therefore protect itself from\n\t * faulty and malicious clients by short-circuting validation after the\n\t * first validation error. The `test` method does this, but it does not\n\t * return any errors. If you want to short-circuit validation and return the\n\t * first error, use one of the `assert` methods. These methods protect the\n\t * server from running regex checks on excessively long strings and from\n\t * running regex checks on all the items of excessively long arrays.\n\t *\n\t * @typeParam S Type for a JSON schema, expressed as a TypeBox type.\n\t */\n", "export abstract class AbstractValidator<S extends TSchema> {\n\t  /**\n\t   * @param schema JSON schema against which to validate values. When a schema\n\t   *  provides an `errorMessage` string option, all errors occurring for that\n\t   *  schema (but not for nested schemas) collapse into a single error having\n\t   *  this message. The `errorMessage` option allows you to provide a custom\n\t   *  error message for a schema. For example, an `errorMessage` on a schema\n\t   *  for a property of an object replaces TypeBox's built-in error messages\n\t   *  for errors that occur on that property.\n\t   */\n", "  constructor(readonly schema: Readonly<S>) {}\n\t  /**\n\t   * Tests whether a value conforms to the schema. For performance reasons, it\n\t   * is best to call this method before calling `errors()` or `firstError()`,\n\t   * should you also need to information about the errors. This method does not\n\t   * throw `ValidationException` and does not clean values of unrecognized\n\t   * properties.\n\t   *\n\t   * @param value Value to validate against the schema.\n\t   * @returns `true` when the value conforms to the schema, `false` otherwise.\n", "   */\n\t  abstract test(value: Readonly<unknown>): boolean;\n\t  /**\n\t   * Tests whether a value conforms to the schema, returning an iterable whose\n\t   * iterator yields the validation errors, or returning `null` if there are no\n\t   * validation errors. This method is equivalent to calling `test()` and then\n\t   * `errors()` and exists only for convenience. The method does not throw\n\t   * `ValidationException` and does not clean values of unrecognized properties.\n\t   *\n\t   * @param value Value to validate against the schema.\n", "   * @returns An iteratable yielding all validation errors, if any, otherwise\n\t   *  `null`. Upon detecting one or more errors for a particular schema\n\t   *  (possibly a nested schema), if the schema provides an `errorMessage`\n\t   *  property, only a single error is reported for the schema, and the\n\t   *  `message` property of this error is set to `errorMessage`'s value. Also,\n\t   *  the TypeBox error \"Expected required property\" is dropped when at least\n\t   *  one other error is reported for the property. Consequently, only the\n\t   *  `Type.Any` and `Type.Unknown` schemas can yield \"Expected required\n\t   *  property\" errors.\n\t   */\n", "  testReturningErrors(value: Readonly<unknown>): Iterable<ValueError> | null {\n\t    return this.test(value) ? null : this.errors(value);\n\t  }\n\t  /**\n\t   * Tests whether a value conforms to the schema, returning the first error,\n\t   * or returning `null` if there is no error. This method is equivalent to\n\t   * calling `test()` and then `firstError()` and exists only for convenience.\n\t   * The method does not throw `ValidationException` and does not clean values\n\t   * of unrecognized properties.\n\t   *\n", "   * @param value Value to validate against the schema.\n\t   * @returns The first validation error, if there is a validation error,\n\t   *  otherwise `null`.\n\t   */\n\t  testReturningFirstError(value: Readonly<unknown>): ValueError | null {\n\t    const iterable = this.testReturningErrors(value);\n\t    if (iterable === null) {\n\t      return null;\n\t    }\n\t    const result = iterable[Symbol.iterator]().next();\n", "    return result.done ? null : result.value;\n\t  }\n\t  /**\n\t   * Validates a value against the schema, halting validation at the first\n\t   * validation error with a `ValidationException`. Does not clean values of\n\t   * unrecognized properties.\n\t   *\n\t   * @param value Value to validate against the schema.\n\t   * @param errorMessage Overall eror message to report in the exception.\n\t   *  The substring `{error}`, if present, will be replaced with a string\n", "   *  representation of the error. Defaults to \"Invalid value\".\n\t   * @throws ValidationException when the value is invalid, reporting only\n\t   *  the first validation error in the `details` property. The `errorMessage`\n\t   *  parameter provides the exception's overall error message.\n\t   */\n\t  abstract assert(value: Readonly<unknown>, errorMessage?: string): void;\n\t  /**\n\t   * Validates a value against the schema, halting validation at the first\n\t   * validation error with a `ValidationException`. On successful validation,\n\t   * removes unrecognized properties from the provided value.\n", "   *\n\t   * @param value Value to validate against the schema.\n\t   * @param errorMessage Overall eror message to report in the exception.\n\t   *  The substring `{error}`, if present, will be replaced with a string\n\t   *  representation of the error. Defaults to \"Invalid value\".\n\t   * @throws ValidationException when the value is invalid, reporting only\n\t   *  the first validation error in the `details` property. The `errorMessage`\n\t   *  parameter provides the exception's overall error message.\n\t   */\n\t  abstract assertAndClean(value: unknown, errorMessage?: string): void;\n", "  /**\n\t   * Validates a value against the schema, halting validation at the first\n\t   * validation error with a `ValidationException`. On successful validation,\n\t   * returns a copy of the value with unrecognized properties removed, but\n\t   * returns the original value if there are no unrecognized properties.\n\t   *\n\t   * @param value Value to validate against the schema.\n\t   * @param errorMessage Overall eror message to report in the exception.\n\t   *  The substring `{error}`, if present, will be replaced with a string\n\t   *  representation of the error. Defaults to \"Invalid value\".\n", "   * @returns The provided value itself if the value is not an object or if\n\t   *  the value is an object having no unrecognized properties. If the value\n\t   *  is an object having at least one unrecognized property, returns a copy\n\t   *  of the value with unrecognized properties removed.\n\t   * @throws ValidationException when the value is invalid, reporting only\n\t   *  the first validation error in the `details` property. The `errorMessage`\n\t   *  parameter provides the exception's overall error message.\n\t   */\n\t  abstract assertAndCleanCopy(\n\t    value: Readonly<unknown>,\n", "    errorMessage?: string\n\t  ): Static<S>;\n\t  /**\n\t   * Validates a value against the schema, detecting all validation errors\n\t   * and reporting them by throwing `ValidationException`. Does not clean\n\t   * values of unrecognized properties.\n\t   *\n\t   * @param value Value to validate against the schema.\n\t   * @param errorMessage Overall error message to report in the exception.\n\t   * @throws ValidationException when the value is invalid, reporting all\n", "   *  validation errors in the `details` property. The `errorMessage`\n\t   *  parameter provides the exception's overall error message.\n\t   */\n\t  abstract validate(value: Readonly<unknown>, errorMessage?: string): void;\n\t  /**\n\t   * Validates a value against the schema, detecting all validation errors\n\t   * and reporting them by throwing `ValidationException`. On successful\n\t   * validation, removes unrecognized properties from the provided value.\n\t   *\n\t   * @param value Value to validate against the schema.\n", "   * @param errorMessage Overall error message to report in the exception.=\n\t   * @throws ValidationException when the value is invalid, reporting all\n\t   *  validation errors in the `details` property. The `errorMessage`\n\t   *  parameter provides the exception's overall error message.\n\t   */\n\t  abstract validateAndClean(value: unknown, errorMessage?: string): void;\n\t  /**\n\t   * Validates a value against the schema, detecting all validation errors\n\t   * and reporting them with a `ValidationException`. On successful validation,\n\t   * returns a copy of the value with unrecognized properties removed, but\n", "   * returns the original value if there are no unrecognized properties.\n\t   *\n\t   * @param value Value to validate against the schema.\n\t   * @param errorMessage Overall error message to report in the exception.\n\t   * @returns The provided value itself if the value is not an object or if\n\t   *  the value is an object having no unrecognized properties. If the value\n\t   *  is an object having at least one unrecognized property, returns a copy\n\t   *  of the value with unrecognized properties removed.\n\t   * @throws ValidationException when the value is invalid, reporting all\n\t   *  validation errors in the `details` property. The `errorMessage`\n", "   *  parameter provides the exception's overall error message.\n\t   */\n\t  abstract validateAndCleanCopy(\n\t    value: Readonly<unknown>,\n\t    errorMessage?: string\n\t  ): Static<S>;\n\t  /**\n\t   * Validates a value against the schema and returns an iteratable whose\n\t   * iterator yields the validation errors. The iterator tests the value for the\n\t   * next error on each call to `next()`, returning a `ValueError` for the error\n", "   * until done. It does not evaluate errors in advance of their being\n\t   * requested, allowing you to short-circuit validation by stopping iteration\n\t   * early. For performance reasons, it is best to call `test()` before calling\n\t   * this method. This method does not throw `ValidationException` and does not\n\t   * clean values of unrecognized properties.\n\t   *\n\t   * @param value Value to validate against the schema.\n\t   * @returns An iteratable yielding all validation errors. Upon detecting one\n\t   *  or more errors for a particular schema (possibly a nested schema), if the\n\t   *  schema provides an `errorMessage` property, only a single error is\n", "   *  reported for the schema, and the `message` property of this error is set\n\t   *  to `errorMessage`'s value. Also, the TypeBox error \"Expected required\n\t   *  property\" is dropped when at least one other error is reported for the\n\t   *  property. Consequently, only the `Type.Any` and `Type.Unknown` schemas can\n\t   *  yield \"Expected required property\" errors.\n\t   */\n\t  abstract errors(value: Readonly<unknown>): Iterable<ValueError>;\n\t  /**\n\t   * Validates a value against the schema and returns the first error,\n\t   * returning `null` if there is no error. No validation is performed beyond\n", "   * the first error, allowing you to protect the server from wasting time and\n\t   * memory validating excessively long strings. It is equivalent to calling\n\t   * `next()` exactly once on the iterator returned by `errors()`, serving\n\t   * only as a convenience method. For performance reasons, it is best to call\n\t   * `test()` before calling this method. This method does not throw\n\t   * `ValidationException` and does not clean values of unrecognized properties.\n\t   *\n\t   * @param value Value to validate against the schema.\n\t   * @returns The first validation error, if there is a validation error,\n\t   *  otherwise `null`.\n", "   */\n\t  firstError(value: Readonly<unknown>): ValueError | null {\n\t    const iterator = this.errors(value)[Symbol.iterator]();\n\t    const result = iterator.next();\n\t    return result.done ? null : result.value;\n\t  }\n\t  protected cleanCopyOfValue<VS extends TSchema>(\n\t    schema: Readonly<VS>,\n\t    value: Readonly<unknown>\n\t  ): Static<VS> {\n", "    if (schema.type === 'object' && typeof value === 'object') {\n\t      const cleanedValue: Record<string, any> = {};\n\t      Object.keys(schema.properties).forEach((key) => {\n\t        cleanedValue[key] = (value as Record<string, any>)[key];\n\t      });\n\t      return cleanedValue;\n\t    }\n\t    return value;\n\t  }\n\t  protected cleanValue<VS extends TSchema>(\n", "    schema: Readonly<VS>,\n\t    value: unknown\n\t  ): void {\n\t    if (schema.type === 'object' && typeof value === 'object') {\n\t      const schemaKeys = Object.keys(schema.properties);\n\t      Object.getOwnPropertyNames(value).forEach((key) => {\n\t        if (!schemaKeys.includes(key)) {\n\t          delete (value as Record<string, any>)[key];\n\t        }\n\t      });\n", "    }\n\t  }\n\t  protected uncompiledAssert(\n\t    schema: Readonly<TSchema>,\n\t    value: Readonly<unknown>,\n\t    overallError?: string\n\t  ): void {\n\t    if (!Value.Check(schema, value)) {\n\t      throwInvalidAssert(overallError, Value.Errors(schema, value).First()!);\n\t    }\n", "  }\n\t  protected uncompiledValidate(\n\t    schema: Readonly<TSchema>,\n\t    value: Readonly<unknown>,\n\t    overallError?: string\n\t  ): void {\n\t    if (!Value.Check(schema, value)) {\n\t      throwInvalidValidate(overallError, Value.Errors(schema, value));\n\t    }\n\t  }\n", "}\n"]}
{"filename": "src/heterogeneous/heterogeneous-union-validator.ts", "chunked_list": ["import { TObject, TUnion } from '@sinclair/typebox';\n\timport { Value, ValueError } from '@sinclair/typebox/value';\n\timport { AbstractTypedUnionValidator } from '../abstract/abstract-typed-union-validator';\n\timport {\n\t  createErrorsIterable,\n\t  createUnionTypeError,\n\t  createUnionTypeErrorIterable,\n\t  throwInvalidAssert,\n\t  throwInvalidValidate,\n\t} from '../lib/error-utils';\n", "import { TypeIdentifyingKeyIndex } from './type-identifying-key-index';\n\t/**\n\t * Non-compiling validator for heterogeneous unions of objects. To improve\n\t * performance, list the more frequently used types earlier in the union, and\n\t * list each object's unique key first in its properties.\n\t */\n\texport class HeterogeneousUnionValidator<\n\t  S extends TUnion<TObject[]>\n\t> extends AbstractTypedUnionValidator<S> {\n\t  #typeIdentifyingKeyIndex: TypeIdentifyingKeyIndex;\n", "  /** @inheritdoc */\n\t  constructor(schema: S) {\n\t    super(schema);\n\t    this.#typeIdentifyingKeyIndex = new TypeIdentifyingKeyIndex(schema);\n\t  }\n\t  /** @inheritdoc */\n\t  override test(value: Readonly<unknown>): boolean {\n\t    const indexOrError = this.findSchemaMemberIndex(value);\n\t    if (typeof indexOrError !== 'number') {\n\t      return false;\n", "    }\n\t    return Value.Check(this.schema.anyOf[indexOrError], value);\n\t  }\n\t  /** @inheritdoc */\n\t  override errors(value: Readonly<unknown>): Iterable<ValueError> {\n\t    const indexOrError = this.findSchemaMemberIndex(value);\n\t    if (typeof indexOrError !== 'number') {\n\t      return createUnionTypeErrorIterable(indexOrError);\n\t    }\n\t    const schema = this.schema.anyOf[indexOrError] as TObject;\n", "    return createErrorsIterable(Value.Errors(schema, value));\n\t  }\n\t  override assertReturningSchema(\n\t    value: Readonly<unknown>,\n\t    overallError?: string\n\t  ): TObject {\n\t    const indexOrError = this.findSchemaMemberIndex(value);\n\t    if (typeof indexOrError !== 'number') {\n\t      throwInvalidAssert(overallError, indexOrError);\n\t    }\n", "    const schema = this.schema.anyOf[indexOrError] as TObject;\n\t    this.uncompiledAssert(schema, value, overallError);\n\t    return schema;\n\t  }\n\t  override validateReturningSchema(\n\t    value: Readonly<unknown>,\n\t    overallError?: string\n\t  ): TObject {\n\t    const indexOrError = this.findSchemaMemberIndex(value);\n\t    if (typeof indexOrError !== 'number') {\n", "      throwInvalidValidate(overallError, indexOrError);\n\t    }\n\t    const schema = this.schema.anyOf[indexOrError] as TObject;\n\t    this.uncompiledValidate(schema, value, overallError);\n\t    return schema;\n\t  }\n\t  private findSchemaMemberIndex(value: Readonly<any>): number | ValueError {\n\t    if (this.#typeIdentifyingKeyIndex.keyByMemberIndex === undefined) {\n\t      // only incur cost if validator is actually used\n\t      this.#typeIdentifyingKeyIndex.cacheKeys();\n", "    }\n\t    if (typeof value === 'object' && value !== null) {\n\t      for (let i = 0; i < this.schema.anyOf.length; ++i) {\n\t        const uniqueKey = this.#typeIdentifyingKeyIndex.keyByMemberIndex![i];\n\t        if (value[uniqueKey] !== undefined) {\n\t          return i;\n\t        }\n\t      }\n\t    }\n\t    return createUnionTypeError(this.schema, value);\n", "  }\n\t}\n"]}
{"filename": "src/heterogeneous/type-identifying-key.ts", "chunked_list": ["import { TSchema } from '@sinclair/typebox';\n\t/**\n\t * Marks an occurrence of a schema as being the property of a key that\n\t * uniquely identifies its containing object within a heterogeneous union.\n\t */\n\texport function TypeIdentifyingKey(schema: Readonly<TSchema>): TSchema {\n\t  return {\n\t    ...schema,\n\t    typeIdentifyingKey: true,\n\t  };\n", "}\n"]}
{"filename": "src/heterogeneous/index.ts", "chunked_list": ["export * from './heterogeneous-union-validator';\n\texport * from './compiling-heterogeneous-union-validator';\n\texport * from './type-identifying-key';\n"]}
{"filename": "src/heterogeneous/compiling-heterogeneous-union-validator.ts", "chunked_list": ["import { TObject, TUnion } from '@sinclair/typebox';\n\timport {\n\t  AbstractCompilingTypedUnionValidator,\n\t  FindSchemaMemberIndex,\n\t} from '../abstract/abstract-compiling-typed-union-validator';\n\timport { TypeIdentifyingKeyIndex } from './type-identifying-key-index';\n\t/**\n\t * Lazily compiled validator for heterogeneous unions of objects. To improve\n\t * performance, list the more frequently used types earlier in the union, and\n\t * list each object's unique key first in its properties.\n", " */\n\texport class CompilingHeterogeneousUnionValidator<\n\t  S extends TUnion<TObject[]>\n\t> extends AbstractCompilingTypedUnionValidator<S> {\n\t  #typeIdentifyingKeyIndex: TypeIdentifyingKeyIndex;\n\t  #compiledFindSchemaMemberIndex?: FindSchemaMemberIndex;\n\t  /** @inheritdoc */\n\t  constructor(schema: Readonly<S>) {\n\t    super(schema);\n\t    this.#typeIdentifyingKeyIndex = new TypeIdentifyingKeyIndex(schema);\n", "  }\n\t  protected override compiledFindSchemaMemberIndex(\n\t    value: Readonly<unknown>\n\t  ): number | null {\n\t    if (this.#compiledFindSchemaMemberIndex === undefined) {\n\t      this.#typeIdentifyingKeyIndex.cacheKeys();\n\t      const codeParts: string[] = [\n\t        `return ((typeof value !== 'object' || value === null || Array.isArray(value)) ? null : `,\n\t      ];\n\t      for (let i = 0; i < this.schema.anyOf.length; ++i) {\n", "        const uniqueKey = this.#typeIdentifyingKeyIndex.keyByMemberIndex![i];\n\t        codeParts.push(\n\t          `${this.toValueKeyDereference(uniqueKey)} !== undefined ? ${i} : `\n\t        );\n\t      }\n\t      this.#compiledFindSchemaMemberIndex = new Function(\n\t        'value',\n\t        codeParts.join('') + 'null)'\n\t      ) as FindSchemaMemberIndex;\n\t    }\n", "    return this.#compiledFindSchemaMemberIndex(value);\n\t  }\n\t}\n"]}
{"filename": "src/heterogeneous/type-identifying-key-index.ts", "chunked_list": ["import { Optional, TObject, TUnion } from '@sinclair/typebox';\n\texport const MESSAGE_OPTIONAL_TYPE_ID_KEY =\n\t  'Type identifying key cannot be optional';\n\texport const MESSAGE_MEMBER_WITH_MULTIPLE_KEYS =\n\t  'Union has member with multiple identifying keys';\n\texport const MESSAGE_MULTIPLE_MEMBERS_WITH_SAME_KEY =\n\t  'Union has multiple members with same identifying key';\n\texport const MESSAGE_MEMBERS_MISSING_KEY =\n\t  'Union has members missing identifying keys';\n\t// Note: The type identifying keys of heterogeneous unions are assigned via\n", "// the typeIdentifyingKey schema option instead of being inferred, because\n\t// inferrence requires a lot of computation, especially because multiple\n\t// keys might be unique within a given member schema.\n\texport class TypeIdentifyingKeyIndex {\n\t  keyByMemberIndex?: string[];\n\t  constructor(readonly schema: Readonly<TUnion<TObject[]>>) {}\n\t  cacheKeys(): void {\n\t    const unionSize = this.schema.anyOf.length;\n\t    const takenKeys = new Set<string>();\n\t    this.keyByMemberIndex = new Array<string>(unionSize);\n", "    for (let i = 0; i < unionSize; ++i) {\n\t      const memberSchema = this.schema.anyOf[i];\n\t      for (const [key, schema] of Object.entries(memberSchema.properties)) {\n\t        if (schema.typeIdentifyingKey) {\n\t          if (schema[Optional] == 'Optional') {\n\t            throw Error(MESSAGE_OPTIONAL_TYPE_ID_KEY);\n\t          }\n\t          if (this.keyByMemberIndex[i] !== undefined) {\n\t            throw Error(MESSAGE_MEMBER_WITH_MULTIPLE_KEYS);\n\t          }\n", "          if (takenKeys.has(key)) {\n\t            throw Error(MESSAGE_MULTIPLE_MEMBERS_WITH_SAME_KEY);\n\t          }\n\t          this.keyByMemberIndex[i] = key;\n\t          takenKeys.add(key);\n\t        }\n\t      }\n\t    }\n\t    if (takenKeys.size < unionSize) {\n\t      this.keyByMemberIndex = undefined; // reset for next attempt\n", "      throw Error(MESSAGE_MEMBERS_MISSING_KEY);\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/discriminated/compiling-discriminated-union-validator.ts", "chunked_list": ["import { TObject, TUnion } from '@sinclair/typebox';\n\timport { DEFAULT_DISCRIMINANT_KEY } from '../abstract/abstract-typed-union-validator';\n\timport {\n\t  AbstractCompilingTypedUnionValidator,\n\t  FindSchemaMemberIndex,\n\t} from '../abstract/abstract-compiling-typed-union-validator';\n\t/**\n\t * Lazily compiled validator for discriminated-union unions. To improve\n\t * performance, list the more frequently used types earlier in the union,\n\t * and list each object's discriminant key first in its properties.\n", " */\n\texport class CompilingDiscriminatedUnionValidator<\n\t  S extends TUnion<TObject[]>\n\t> extends AbstractCompilingTypedUnionValidator<S> {\n\t  #discriminantKey: string;\n\t  #compiledFindSchemaMemberIndex?: FindSchemaMemberIndex;\n\t  /** @inheritdoc */\n\t  constructor(schema: Readonly<S>) {\n\t    super(schema);\n\t    this.#discriminantKey =\n", "      this.schema.discriminantKey ?? DEFAULT_DISCRIMINANT_KEY;\n\t  }\n\t  protected override compiledFindSchemaMemberIndex(\n\t    value: Readonly<unknown>\n\t  ): number | null {\n\t    if (this.#compiledFindSchemaMemberIndex === undefined) {\n\t      const codeParts: string[] = [\n\t        `if (typeof value !== 'object' || value === null || Array.isArray(value)) return null;\n\t          switch (${this.toValueKeyDereference(this.#discriminantKey)}) {\\n`,\n\t      ];\n", "      for (let i = 0; i < this.schema.anyOf.length; ++i) {\n\t        const discriminantSchema =\n\t          this.schema.anyOf[i].properties[this.#discriminantKey];\n\t        if (discriminantSchema === undefined) {\n\t          throw Error(\n\t            `Discriminant key '${\n\t              this.#discriminantKey\n\t            }' not present in all members of discriminated union`\n\t          );\n\t        }\n", "        const literal = discriminantSchema.const;\n\t        if (typeof literal === 'string') {\n\t          codeParts.push(\n\t            `case '${literal.replace(/'/g, \"\\\\'\")}': return ${i};\\n`\n\t          );\n\t        } else {\n\t          codeParts.push(`case ${literal}: return ${i};\\n`);\n\t        }\n\t      }\n\t      const code = codeParts.join('') + 'default: return null; }';\n", "      this.#compiledFindSchemaMemberIndex = new Function(\n\t        'value',\n\t        code\n\t      ) as FindSchemaMemberIndex;\n\t    }\n\t    return this.#compiledFindSchemaMemberIndex(value);\n\t  }\n\t}\n"]}
{"filename": "src/discriminated/discriminated-union-validator.ts", "chunked_list": ["import { TObject, TUnion } from '@sinclair/typebox';\n\timport { Value, ValueError } from '@sinclair/typebox/value';\n\timport {\n\t  AbstractTypedUnionValidator,\n\t  DEFAULT_DISCRIMINANT_KEY,\n\t} from '../abstract/abstract-typed-union-validator';\n\timport {\n\t  createErrorsIterable,\n\t  createUnionTypeError,\n\t  createUnionTypeErrorIterable,\n", "  throwInvalidAssert,\n\t  throwInvalidValidate,\n\t} from '../lib/error-utils';\n\t/**\n\t * Non-compiling validator for discriminated unions. To improve performance,\n\t * list the more frequently used types earlier in the union, and list each\n\t * object's discriminant key first in its properties.\n\t */\n\texport class DiscriminatedUnionValidator<\n\t  S extends TUnion<TObject[]>\n", "> extends AbstractTypedUnionValidator<S> {\n\t  discriminantKey: string;\n\t  #unionIsWellformed: boolean = false;\n\t  /** @inheritdoc */\n\t  constructor(schema: S) {\n\t    super(schema);\n\t    this.discriminantKey =\n\t      this.schema.discriminantKey ?? DEFAULT_DISCRIMINANT_KEY;\n\t  }\n\t  /** @inheritdoc */\n", "  override test(value: Readonly<unknown>): boolean {\n\t    const indexOrError = this.findSchemaMemberIndex(value);\n\t    if (typeof indexOrError !== 'number') {\n\t      return false;\n\t    }\n\t    return Value.Check(this.schema.anyOf[indexOrError], value);\n\t  }\n\t  /** @inheritdoc */\n\t  override errors(value: Readonly<unknown>): Iterable<ValueError> {\n\t    const indexOrError = this.findSchemaMemberIndex(value);\n", "    if (typeof indexOrError !== 'number') {\n\t      return createUnionTypeErrorIterable(indexOrError);\n\t    }\n\t    const schema = this.schema.anyOf[indexOrError] as TObject;\n\t    return createErrorsIterable(Value.Errors(schema, value));\n\t  }\n\t  override assertReturningSchema(\n\t    value: Readonly<unknown>,\n\t    overallError?: string\n\t  ): TObject {\n", "    const indexOrError = this.findSchemaMemberIndex(value);\n\t    if (typeof indexOrError !== 'number') {\n\t      throwInvalidAssert(overallError, indexOrError);\n\t    }\n\t    const schema = this.schema.anyOf[indexOrError] as TObject;\n\t    this.uncompiledAssert(schema, value, overallError);\n\t    return schema;\n\t  }\n\t  override validateReturningSchema(\n\t    value: Readonly<unknown>,\n", "    overallError?: string\n\t  ): TObject {\n\t    const indexOrError = this.findSchemaMemberIndex(value);\n\t    if (typeof indexOrError !== 'number') {\n\t      throwInvalidValidate(overallError, indexOrError);\n\t    }\n\t    const schema = this.schema.anyOf[indexOrError] as TObject;\n\t    this.uncompiledValidate(schema, value, overallError);\n\t    return schema;\n\t  }\n", "  private findSchemaMemberIndex(subject: Readonly<any>): number | ValueError {\n\t    if (!this.#unionIsWellformed) {\n\t      // only incur cost if validator is actually used\n\t      for (const memberSchema of this.schema.anyOf) {\n\t        if (memberSchema.properties[this.discriminantKey] === undefined) {\n\t          throw Error(\n\t            `Discriminant key '${this.discriminantKey}' not present in all members of discriminated union`\n\t          );\n\t        }\n\t      }\n", "      this.#unionIsWellformed = true;\n\t    }\n\t    if (typeof subject === 'object' && subject !== null) {\n\t      const subjectKind = subject[this.discriminantKey];\n\t      if (subjectKind !== undefined) {\n\t        for (let i = 0; i < this.schema.anyOf.length; ++i) {\n\t          const memberKind =\n\t            this.schema.anyOf[i].properties[this.discriminantKey];\n\t          if (memberKind !== undefined && memberKind.const === subjectKind) {\n\t            return i;\n", "          }\n\t        }\n\t      }\n\t    }\n\t    return createUnionTypeError(this.schema, subject);\n\t  }\n\t}\n"]}
{"filename": "src/discriminated/index.ts", "chunked_list": ["export * from './discriminated-union-validator';\n\texport * from './compiling-discriminated-union-validator';\n"]}
{"filename": "src/lib/validation-exception.ts", "chunked_list": ["/**\n\t * Classes representing the validation errors of a single value.\n\t */\n\timport { ValueError } from '@sinclair/typebox/value';\n\t/**\n\t * Exception reporting the occurrence of one or more validation errors.\n\t */\n\texport class ValidationException {\n\t  /**\n\t   * @param message Overall error message\n", "   * @param details The individual validation errors\n\t   */\n\t  constructor(\n\t    readonly message: string,\n\t    readonly details: Readonly<ValueError[]> = []\n\t  ) {}\n\t  /**\n\t   * Returns a string representation of the error. Provides the overall\n\t   * error message, followed by the specific error messages, one per line.\n\t   * @returns a string representation of the error.\n", "   */\n\t  toString(): string {\n\t    let message = this.message;\n\t    if (this.details.length > 0) {\n\t      if (!message.endsWith(':')) {\n\t        message += ':';\n\t      }\n\t      for (const detail of this.details) {\n\t        message += '\\n * ' + ValidationException.errorToString(detail);\n\t      }\n", "    }\n\t    return message;\n\t  }\n\t  /**\n\t   * Returns a string representation of a validation error, which precedes\n\t   * the error with its reference path if it occurs in an object.\n\t   */\n\t  static errorToString(error: ValueError): string {\n\t    return error.path != ''\n\t      ? `${error.path.substring(1)} - ${error.message}`\n", "      : error.message;\n\t  }\n\t}\n"]}
{"filename": "src/lib/error-utils.ts", "chunked_list": ["import { Kind, TObject, TUnion } from '@sinclair/typebox';\n\timport {\n\t  ValueError,\n\t  ValueErrorIterator,\n\t  ValueErrorType,\n\t} from '@sinclair/typebox/errors';\n\timport { ValidationException } from './validation-exception';\n\texport const DEFAULT_OVERALL_MESSAGE = 'Invalid value';\n\texport const DEFAULT_UNKNOWN_TYPE_MESSAGE = 'Object type not recognized';\n\tconst TYPEBOX_REQUIRED_ERROR_MESSAGE = 'Expected required property';\n", "export function adjustErrorMessage(error: ValueError): ValueError {\n\t  if (error.schema.errorMessage !== undefined) {\n\t    error.message = error.schema.errorMessage;\n\t  }\n\t  return error;\n\t}\n\texport function createErrorsIterable(\n\t  typeboxErrorIterator: ValueErrorIterator\n\t): Iterable<ValueError> {\n\t  return {\n", "    [Symbol.iterator]: function* () {\n\t      const errors = typeboxErrorIterator[Symbol.iterator]();\n\t      let result = errors.next();\n\t      let customErrorPath = '???'; // signals no prior path ('' can be root path)\n\t      while (result.value !== undefined) {\n\t        const error = result.value;\n\t        const standardMessage = error.message;\n\t        if (error.path !== customErrorPath) {\n\t          adjustErrorMessage(error);\n\t          if (error.message != standardMessage) {\n", "            customErrorPath = error.path;\n\t            yield error;\n\t          } else if (\n\t            // drop 'required' errors for values that have constraints\n\t            error.message != TYPEBOX_REQUIRED_ERROR_MESSAGE ||\n\t            ['Any', 'Unknown'].includes(error.schema[Kind])\n\t          ) {\n\t            yield error;\n\t          }\n\t        }\n", "        result = errors.next();\n\t      }\n\t    },\n\t  };\n\t}\n\texport function createUnionTypeError(\n\t  unionSchema: Readonly<TUnion<TObject[]>>,\n\t  value: Readonly<unknown>\n\t): ValueError {\n\t  return {\n", "    type: ValueErrorType.Union,\n\t    path: '',\n\t    schema: unionSchema,\n\t    value,\n\t    message: unionSchema.errorMessage ?? DEFAULT_UNKNOWN_TYPE_MESSAGE,\n\t  };\n\t}\n\texport function createUnionTypeErrorIterable(\n\t  typeError: ValueError\n\t): Iterable<ValueError> {\n", "  return {\n\t    [Symbol.iterator]: function* () {\n\t      yield typeError;\n\t    },\n\t  };\n\t}\n\texport function throwInvalidAssert(\n\t  overallError: string | undefined,\n\t  firstError: ValueError\n\t): never {\n", "  adjustErrorMessage(firstError);\n\t  throw new ValidationException(\n\t    overallError === undefined\n\t      ? DEFAULT_OVERALL_MESSAGE\n\t      : overallError.replace(\n\t          '{error}',\n\t          ValidationException.errorToString(firstError)\n\t        ),\n\t    [firstError]\n\t  );\n", "}\n\texport function throwInvalidValidate(\n\t  overallError: string | undefined,\n\t  errorOrErrors: ValueError | ValueErrorIterator\n\t): never {\n\t  throw new ValidationException(\n\t    overallError ?? DEFAULT_OVERALL_MESSAGE,\n\t    errorOrErrors instanceof ValueErrorIterator\n\t      ? [...createErrorsIterable(errorOrErrors)]\n\t      : [errorOrErrors]\n", "  );\n\t}\n"]}
{"filename": "src/standard/standard-validator.ts", "chunked_list": ["import type { TSchema } from '@sinclair/typebox';\n\timport { AbstractStandardValidator } from '../abstract/abstract-standard-validator';\n\timport { ValueError } from '@sinclair/typebox/errors';\n\timport { Value } from '@sinclair/typebox/value';\n\timport { createErrorsIterable } from '../lib/error-utils';\n\t/**\n\t * Non-compiling validator for standard TypeBox values.\n\t */\n\texport class StandardValidator<\n\t  S extends TSchema\n", "> extends AbstractStandardValidator<S> {\n\t  /** @inheritdoc */\n\t  constructor(schema: S) {\n\t    super(schema);\n\t  }\n\t  /** @inheritdoc */\n\t  override test(value: Readonly<unknown>): boolean {\n\t    return Value.Check(this.schema, value);\n\t  }\n\t  /** @inheritdoc */\n", "  override assert(value: Readonly<unknown>, overallError?: string): void {\n\t    this.uncompiledAssert(this.schema, value, overallError);\n\t  }\n\t  /** @inheritdoc */\n\t  override validate(value: Readonly<unknown>, overallError?: string): void {\n\t    this.uncompiledValidate(this.schema, value, overallError);\n\t  }\n\t  /** @inheritdoc */\n\t  override errors(value: Readonly<unknown>): Iterable<ValueError> {\n\t    return createErrorsIterable(Value.Errors(this.schema, value));\n", "  }\n\t}\n"]}
{"filename": "src/standard/index.ts", "chunked_list": ["export * from './standard-validator';\n\texport * from './compiling-standard-validator';\n"]}
{"filename": "src/standard/compiling-standard-validator.ts", "chunked_list": ["import type { TSchema } from '@sinclair/typebox';\n\timport {\n\t  TypeCheck,\n\t  TypeCompiler,\n\t  ValueError,\n\t} from '@sinclair/typebox/compiler';\n\timport { AbstractStandardValidator } from '../abstract/abstract-standard-validator';\n\timport {\n\t  createErrorsIterable,\n\t  throwInvalidAssert,\n", "  throwInvalidValidate,\n\t} from '../lib/error-utils';\n\t/**\n\t * Lazily compiled validator for standard TypeBox values.\n\t */\n\texport class CompilingStandardValidator<\n\t  S extends TSchema\n\t> extends AbstractStandardValidator<S> {\n\t  #compiledType?: TypeCheck<S>;\n\t  /** @inheritdoc */\n", "  constructor(schema: Readonly<S>) {\n\t    super(schema);\n\t  }\n\t  /** @inheritdoc */\n\t  override test(value: Readonly<unknown>): boolean {\n\t    const compiledType = this.getCompiledType();\n\t    return compiledType.Check(value);\n\t  }\n\t  /** @inheritdoc */\n\t  override assert(value: Readonly<unknown>, overallError?: string): void {\n", "    const compiledType = this.getCompiledType();\n\t    if (!compiledType.Check(value)) {\n\t      throwInvalidAssert(overallError, compiledType.Errors(value).First()!);\n\t    }\n\t  }\n\t  /** @inheritdoc */\n\t  override validate(value: Readonly<unknown>, overallError?: string): void {\n\t    const compiledType = this.getCompiledType();\n\t    if (!compiledType.Check(value)) {\n\t      throwInvalidValidate(overallError, compiledType.Errors(value));\n", "    }\n\t  }\n\t  /** @inheritdoc */\n\t  override errors(value: Readonly<unknown>): Iterable<ValueError> {\n\t    const compiledType = this.getCompiledType();\n\t    return createErrorsIterable(compiledType.Errors(value));\n\t  }\n\t  private getCompiledType(): TypeCheck<S> {\n\t    if (this.#compiledType === undefined) {\n\t      this.#compiledType = TypeCompiler.Compile(this.schema);\n", "    }\n\t    return this.#compiledType;\n\t  }\n\t}\n"]}
