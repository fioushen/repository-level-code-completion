{"filename": "src/main.ts", "chunked_list": ["import { CommandFactory } from 'nest-commander';\n\timport { Logger } from 'nestjs-pino';\n\timport { AppModule } from './app.module';\n\timport { AppService } from './app.service';\n\tasync function bootstrap() {\n\t  const app = await CommandFactory.createWithoutRunning(AppModule, { cliName: 'ssc', logger: false });\n\t  app.enableShutdownHooks();\n\t  const logger = app.get(Logger);\n\t  app.useLogger(logger);\n\t  const appService = app.get(AppService);\n", "  appService.subscribeToShutdown(() => app.close());\n\t  try {\n\t    await CommandFactory.runApplication(app);\n\t  } catch (error) {\n\t    logger.error(error.message);\n\t    appService.shutdown();\n\t  }\n\t}\n\tbootstrap();\n"]}
{"filename": "src/app.service.ts", "chunked_list": ["import { Subject } from 'rxjs';\n\timport { Injectable, Logger, OnModuleInit } from '@nestjs/common';\n\timport { ConfigService } from '@nestjs/config';\n\t@Injectable()\n\texport class AppService implements OnModuleInit {\n\t  private readonly logger = new Logger(AppService.name);\n\t  private readonly shutdownListener$: Subject<void> = new Subject();\n\t  private isShuttingDown = false;\n\t  constructor(private readonly configService: ConfigService) {}\n\t  public onModuleInit() {\n", "    this.initialize();\n\t  }\n\t  private initialize() {\n\t    this.catchExceptions();\n\t    this.setProcessTitle(this.configService.getOrThrow('app.title'));\n\t  }\n\t  public shutdown() {\n\t    if (this.isShuttingDown) return;\n\t    this.isShuttingDown = true;\n\t    this.shutdownListener$.next();\n", "  }\n\t  private setProcessTitle(title: string) {\n\t    if (process.title === title) return;\n\t    if (process.platform === 'win32') process.title = title;\n\t    else process.stdout.write(`\\x1b]2;${title}\\x1b\\x5c`);\n\t  }\n\t  public subscribeToShutdown(shutdownFn: () => void): void {\n\t    this.shutdownListener$.subscribe(() => shutdownFn());\n\t  }\n\t  private catchExceptions() {\n", "    process.on('uncaughtException', (error) => {\n\t      this.logger.error(new Error('Uncaught exception', { cause: error }));\n\t      this.shutdown();\n\t    });\n\t    process.on('unhandledRejection', (reason) => {\n\t      this.logger.error(new Error('Unhandled rejection', { cause: reason }));\n\t      this.shutdown();\n\t    });\n\t  }\n\t}\n"]}
{"filename": "src/app.module.ts", "chunked_list": ["import { CacheModule } from '@nestjs/cache-manager';\n\timport { Global, Module } from '@nestjs/common';\n\timport { ConfigModule } from '@nestjs/config';\n\timport { AppService } from './app.service';\n\timport { CommandsModule } from './commands/commands.module';\n\timport configuration from './config/configuration';\n\timport { LoggerModule } from './modules/logger/logger.module';\n\t@Global()\n\t@Module({\n\t  imports: [\n", "    ConfigModule.forRoot({ isGlobal: true, load: [configuration] }),\n\t    LoggerModule,\n\t    CacheModule.register(),\n\t    CommandsModule,\n\t  ],\n\t  providers: [AppService],\n\t  exports: [AppService],\n\t})\n\texport class AppModule {}\n"]}
{"filename": "src/commands/commands.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { CreateModule } from './create/create-sessions.module';\n\timport { ValidateSessionsModule } from './validate/validate-sessions.module';\n\t@Module({\n\t  imports: [CreateModule, ValidateSessionsModule],\n\t})\n\texport class CommandsModule {}\n"]}
{"filename": "src/commands/create/create-sessions.service.ts", "chunked_list": ["import pRetry from 'p-retry';\n\timport { setTimeout as delay } from 'timers/promises';\n\timport { Injectable, OnModuleInit } from '@nestjs/common';\n\timport { ConfigService } from '@nestjs/config';\n\timport { Account } from '../../interfaces/account.interface';\n\timport { Session as ISession } from '../../interfaces/session.interface';\n\timport { SteamTokensService } from '../../modules/steam-tokens/steam-tokens.service';\n\t@Injectable()\n\texport class CreateSessionsService implements OnModuleInit {\n\t  private schemaVersion: number;\n", "  constructor(private readonly steamTokensService: SteamTokensService, private readonly configService: ConfigService) {}\n\t  public onModuleInit() {\n\t    this.schemaVersion = this.configService.getOrThrow<number>('session.schemaVersion');\n\t  }\n\t  public async createSession(account: Account) {\n\t    try {\n\t      // we need to wait at least 30 seconds between each refresh token creation\n\t      // because steam has a limit of logins for one account once per 30 seconds\n\t      // probably it's fair only for accounts with 2FA enabled\n\t      const delayMs = 1000 * 31;\n", "      const desktopRefreshToken = await this.createRefreshToken(account, 'desktop');\n\t      await delay(delayMs);\n\t      const webRefreshToken = await this.createRefreshToken(account, 'web');\n\t      await delay(delayMs);\n\t      const mobileRefreshToken = await this.createRefreshToken(account, 'mobile');\n\t      await delay(delayMs);\n\t      const steamId = this.getSteamIdFromRefreshToken(webRefreshToken);\n\t      const schemaVersion = this.schemaVersion;\n\t      const session: ISession = {\n\t        username: account.username,\n", "        password: account.password,\n\t        sharedSecret: account.sharedSecret || null,\n\t        identitySecret: account.identitySecret || null,\n\t        steamId,\n\t        webRefreshToken,\n\t        mobileRefreshToken,\n\t        desktopRefreshToken,\n\t        schemaVersion,\n\t      };\n\t      return session;\n", "    } catch (error) {\n\t      throw new Error('Failed to create session', { cause: error });\n\t    }\n\t  }\n\t  private async createRefreshToken(account: Account, platform: 'web' | 'mobile' | 'desktop') {\n\t    try {\n\t      return await pRetry(() => this.steamTokensService.createRefreshToken(account, platform), {\n\t        retries: 3,\n\t        minTimeout: 31000,\n\t        maxTimeout: 31000,\n", "      });\n\t    } catch (error) {\n\t      throw new Error('Failed to create refresh token', { cause: error });\n\t    }\n\t  }\n\t  private getSteamIdFromRefreshToken(token: string) {\n\t    try {\n\t      const { sub: steamId } = this.steamTokensService.decodeRefreshToken(token);\n\t      if (!steamId) throw new Error('SteamId is missing from refresh token');\n\t      return steamId;\n", "    } catch (error) {\n\t      throw new Error('Failed to get steamId from refresh token', { cause: error });\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/commands/create/create-sessions.command.ts", "chunked_list": ["import glob from 'fast-glob';\n\timport { CliUtilityService, Command, CommandRunner, Help, Option } from 'nest-commander';\n\timport pQueue from 'p-queue';\n\timport path from 'path';\n\timport { setTimeout as delay } from 'timers/promises';\n\timport { Logger } from '@nestjs/common';\n\timport { AccountsImportService } from '../../modules/accounts-import/accounts-import.service';\n\timport { ExportSessionsService } from '../../modules/export-sessions/export-sessions.service';\n\timport { ProxiesImportService } from '../../modules/proxies-import/proxies-import.service';\n\timport { ProxiesService } from '../../modules/proxies/proxies.service';\n", "import { SecretsImportService } from '../../modules/secrets-import/secrets-import.service';\n\timport { CreateSessionsService } from './create-sessions.service';\n\tinterface CreateCommandOptions {\n\t  accounts: string | string[];\n\t  secrets: string | string[];\n\t  proxies: string | string[];\n\t  concurrency: number;\n\t  output: string;\n\t  overwrite: boolean;\n\t}\n", "@Command({\n\t  name: 'create',\n\t  description: 'Creates new sessions',\n\t})\n\texport class CreateSessionsCommand extends CommandRunner {\n\t  private readonly logger = new Logger(CreateSessionsCommand.name);\n\t  constructor(\n\t    private readonly createSessionsService: CreateSessionsService,\n\t    private readonly exportSessionsService: ExportSessionsService,\n\t    private readonly accountsImportService: AccountsImportService,\n", "    private readonly secretsImportService: SecretsImportService,\n\t    private readonly proxiesImportService: ProxiesImportService,\n\t    private readonly proxiesService: ProxiesService,\n\t  ) {\n\t    super();\n\t  }\n\t  public async run(args: string[], options: CreateCommandOptions) {\n\t    try {\n\t      const accountsOptionInput = await this.normalizeInput(options.accounts);\n\t      let accounts = await this.accountsImportService.loadAccounts(accountsOptionInput);\n", "      if (accounts.length === 0) throw new Error('No accounts found');\n\t      this.logger.log(`Accounts: ${accounts.length}`);\n\t      const secretsOptionInput = await this.normalizeInput(options.secrets);\n\t      const secrets = await this.secretsImportService.loadSecrets(secretsOptionInput);\n\t      this.logger.log(`Secrets: ${secrets.length}`);\n\t      const outputOptionInput = options.output;\n\t      if (!outputOptionInput) throw new Error('Output path is required');\n\t      const output = path.resolve(outputOptionInput);\n\t      await this.exportSessionsService.setOutputPath(output);\n\t      this.logger.log(`Output: ${output}`);\n", "      const overwriteExistingSessions = options.overwrite;\n\t      if (!overwriteExistingSessions) {\n\t        const sessionsPaths = await this.normalizeInput(`${output}/*`);\n\t        const existingSessions = await this.accountsImportService.loadAccounts(sessionsPaths);\n\t        this.logger.log(`Ignoring existing sessions: ${existingSessions.length}`);\n\t        accounts = accounts.filter((account) => !existingSessions.some((a) => a.username === account.username));\n\t      }\n\t      if (accounts.length === 0) {\n\t        this.logger.log('No accounts to create');\n\t        return;\n", "      }\n\t      const proxiesOptionInput = await this.normalizeInput(options.proxies);\n\t      const proxies = await this.proxiesImportService.loadProxies(proxiesOptionInput);\n\t      this.proxiesService.setProxies(proxies);\n\t      this.logger.log(`Proxies: ${proxies.length}`);\n\t      const concurrencyOptionInput = options.concurrency;\n\t      const concurrency = proxies.length > 0 ? concurrencyOptionInput || Math.min(proxies.length * 3, 100) : 1;\n\t      this.logger.log(`Concurrency: ${concurrency}`);\n\t      this.logger.log(`Starting to create sessions for ${accounts.length} accounts`);\n\t      this.accountsImportService.assignSecretsToAccounts(accounts, secrets);\n", "      let success = 0;\n\t      let fails = 0;\n\t      let left = accounts.length;\n\t      const queue = new pQueue({ concurrency, interval: 10, intervalCap: 1 });\n\t      for (const account of accounts) {\n\t        queue.add(async () => {\n\t          try {\n\t            const session = await this.createSessionsService.createSession(account);\n\t            await this.exportSessionsService.exportSession(session);\n\t            success++;\n", "            this.logger.log(`Success: ${account.username}, left: ${--left}`);\n\t          } catch (error) {\n\t            fails++;\n\t            this.logger.warn(`Fail: ${account.username}, left: ${--left}`);\n\t          }\n\t        });\n\t      }\n\t      await queue.onIdle();\n\t      this.logger.log(`Session creation complete`);\n\t      this.logger.log(`Success: ${success}`);\n", "      this.logger.log(`Fails: ${fails}`);\n\t      await delay(1000);\n\t    } catch (error) {\n\t      this.logger.error(error.message);\n\t    }\n\t  }\n\t  private async normalizeInput(input: string | string[]) {\n\t    if (!input) return [];\n\t    if (!Array.isArray(input)) input = [input];\n\t    const filteredInput = input.filter((el) => typeof el === 'string' && el.trim() !== '');\n", "    if (filteredInput.length === 0) return [];\n\t    const nestedData = await Promise.all(\n\t      filteredInput.map(async (el) => {\n\t        el = el.trim();\n\t        // Possible glob pattern\n\t        const files = await glob(el);\n\t        if (files.length > 0) return files;\n\t        // Possible string\n\t        return el.split(/\\s+|\\r?\\n/).map((line) => line.trim());\n\t      }),\n", "    );\n\t    return nestedData.flat();\n\t  }\n\t  @Option({\n\t    required: true,\n\t    flags: '-a, --accounts <accounts...>',\n\t    description: `Specify one or more accounts.\n\tAccount can be specified as:\n\t- A simple string.\n\t- A file path to load accounts from (one account per line).\n", "- A glob pattern to load accounts from multiple files.\n\tSupported formats:\n\t- username:password\n\t- username:password:sharedSecret\n\t- username:password:sharedSecret:identitySecret\n\t- ASF json`,\n\t  })\n\t  private parseAccountsOption(val: string, accumulator: string[] = []) {\n\t    accumulator.push(val);\n\t    return accumulator;\n", "  }\n\t  @Option({\n\t    flags: '-s, --secrets <secrets...>',\n\t    description: `Specify one or more secrets.\n\tSecret can be specified as:\n\t- A file path to load secrets from file.\n\t- A glob pattern to load secrets from multiple files.\n\tSupported formats:\n\t- maFile\n\t- ASF db`,\n", "  })\n\t  private parseSecretsOption(val: string, accumulator: string[] = []) {\n\t    accumulator.push(val);\n\t    return accumulator;\n\t  }\n\t  @Option({\n\t    flags: '-p, --proxies <proxies...>',\n\t    description: `Specify one or more proxies.\n\tProxy can be specified as:\n\t- A string in the format <protocol>://<username>:<password>@<host>:<port>.\n", "- A file path to load proxies from a text file.\n\tSupported protocols:\n\t- http\n\t- https`,\n\t  })\n\t  private parseProxiesOption(val: string, accumulator: string[] = []) {\n\t    accumulator.push(val);\n\t    return accumulator;\n\t  }\n\t  @Option({\n", "    flags: '-c, --concurrency <concurrency>',\n\t    description: `Specify the number of concurrent runs.\n\tDefault: 1, or the number of proxies.`,\n\t  })\n\t  private parseConcurrencyOption(val: string) {\n\t    const parsed = parseInt(val, 10);\n\t    if (Number.isNaN(parsed)) throw new Error('Concurrency must be a number');\n\t    if (parsed < 1) throw new Error('Concurrency must be greater than 0');\n\t    return parsed;\n\t  }\n", "  @Option({\n\t    flags: '-o, --output <output>',\n\t    description: 'Specify the output directory.',\n\t    defaultValue: './sessions',\n\t  })\n\t  private parseOutputOption(val: string) {\n\t    return val;\n\t  }\n\t  @Option({\n\t    flags: '--overwrite (-w)',\n", "    description: 'Overwrite existing sessions.',\n\t    defaultValue: false,\n\t  })\n\t  private parseOverwriteOption(val: string) {\n\t    return new CliUtilityService().parseBoolean(val);\n\t  }\n\t  @Help('afterAll')\n\t  private displayExamples() {\n\t    return `\n\tExamples:\n", "  create -a accounts.txt -s ./secrets -p proxies.txt\n\t  create -a username:password -p proxies.txt`;\n\t  }\n\t}\n"]}
{"filename": "src/commands/create/create-sessions.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { AccountsImportModule } from '../../modules/accounts-import/accounts-import.module';\n\timport { ExportSessionsModule } from '../../modules/export-sessions/export-sessions.module';\n\timport { ProxiesImportModule } from '../../modules/proxies-import/proxies-import.module';\n\timport { ProxiesModule } from '../../modules/proxies/proxies.module';\n\timport { SecretsImportModule } from '../../modules/secrets-import/secrets-import.module';\n\timport { SteamTokensModule } from '../../modules/steam-tokens/steam-tokens.module';\n\timport { CreateSessionsCommand } from './create-sessions.command';\n\timport { CreateSessionsService } from './create-sessions.service';\n\t@Module({\n", "  imports: [\n\t    AccountsImportModule,\n\t    SecretsImportModule,\n\t    ProxiesImportModule,\n\t    ExportSessionsModule,\n\t    ProxiesModule,\n\t    SteamTokensModule,\n\t  ],\n\t  providers: [CreateSessionsCommand, CreateSessionsService],\n\t})\n", "export class CreateModule {}\n"]}
{"filename": "src/commands/validate/validate-sessions.command.ts", "chunked_list": ["import glob from 'fast-glob';\n\timport { Command, CommandRunner, Help, Option } from 'nest-commander';\n\timport { Logger } from '@nestjs/common';\n\timport { SessionsImportService } from '../../modules/sessions-import/sessions-import.service';\n\timport { ValidateSessionsService } from './validate-sessions.service';\n\tinterface ValidateCommandOptions {\n\t  sessions: string | string[];\n\t}\n\t@Command({\n\t  name: 'validate',\n", "  description: 'Validates sessions',\n\t})\n\texport class ValidateSessionsCommand extends CommandRunner {\n\t  private readonly logger = new Logger(ValidateSessionsCommand.name);\n\t  constructor(\n\t    private readonly sessionsImportService: SessionsImportService,\n\t    private readonly validateSessionsService: ValidateSessionsService,\n\t  ) {\n\t    super();\n\t  }\n", "  public async run(args: string[], options: ValidateCommandOptions) {\n\t    try {\n\t      const sessionsOptionInput = await this.normalizeInput(options.sessions);\n\t      const sessions = await this.sessionsImportService.loadSessions(sessionsOptionInput);\n\t      if (sessions.length === 0) throw new Error('No sessions found');\n\t      this.logger.log(`Sessions: ${sessions.length}`);\n\t      await this.validateSessionsService.validateSessions(sessions);\n\t    } catch (error) {\n\t      this.logger.error(error.message);\n\t    }\n", "  }\n\t  private async normalizeInput(input: string | string[]) {\n\t    if (!input) return [];\n\t    if (!Array.isArray(input)) input = [input];\n\t    const filteredInput = input.filter((el) => typeof el === 'string' && el.trim() !== '');\n\t    if (filteredInput.length === 0) return [];\n\t    const nestedData = await Promise.all(\n\t      filteredInput.map(async (el) => {\n\t        el = el.trim();\n\t        // Possible glob pattern\n", "        const files = await glob(el);\n\t        if (files.length > 0) return files;\n\t        // Possible string\n\t        return el.split(/\\s+|\\r?\\n/).map((line) => line.trim());\n\t      }),\n\t    );\n\t    return nestedData.flat();\n\t  }\n\t  @Option({\n\t    flags: '-s, --sessions <sessions...>',\n", "    description: `Specify one or more sessions.\n\tSession can be specified as:\n\t- A file path to load session from.\n\t- A glob pattern to load sessions from multiple files.`,\n\t  })\n\t  private parseSessionsOption(val: string, accumulator: string[] = []) {\n\t    accumulator.push(val);\n\t    return accumulator;\n\t  }\n\t  @Help('afterAll')\n", "  private displayHelp() {\n\t    return `\n\tExamples:\n\t  validate -s example.steamsession\n\t  validate -s sessions/*.steamsession`;\n\t  }\n\t}\n"]}
{"filename": "src/commands/validate/validate-sessions.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { SessionsImportModule } from '../../modules/sessions-import/sessions-import.module';\n\timport { SteamTokensModule } from '../../modules/steam-tokens/steam-tokens.module';\n\timport { ValidateSessionsCommand } from './validate-sessions.command';\n\timport { ValidateSessionsService } from './validate-sessions.service';\n\t@Module({\n\t  imports: [SessionsImportModule, SteamTokensModule],\n\t  providers: [ValidateSessionsCommand, ValidateSessionsService],\n\t})\n\texport class ValidateSessionsModule {}\n"]}
{"filename": "src/commands/validate/validate-sessions.service.ts", "chunked_list": ["import { setTimeout as delay } from 'timers/promises';\n\timport { Injectable, Logger } from '@nestjs/common';\n\timport { ConfigService } from '@nestjs/config';\n\timport { Session } from '../../interfaces/session.interface';\n\timport { SteamTokensService } from '../../modules/steam-tokens/steam-tokens.service';\n\t@Injectable()\n\texport class ValidateSessionsService {\n\t  private readonly logger = new Logger(ValidateSessionsService.name);\n\t  constructor(private readonly steamTokensService: SteamTokensService, private readonly configService: ConfigService) {}\n\t  public async validateSessions(sessions: Session[]) {\n", "    const valid: Session[] = [];\n\t    const invalid: Session[] = [];\n\t    for (const session of sessions) {\n\t      const { valid: isValid, errors, expires } = await this.validateSession(session);\n\t      if (isValid) {\n\t        valid.push(session);\n\t        this.logger.log(\n\t          `Valid: ${session.username}, days: ${Math.floor((expires - Date.now()) / (24 * 60 * 60 * 1000))}`,\n\t        );\n\t      } else {\n", "        invalid.push(session);\n\t        this.logger.warn(`Invalid: ${session.username}, errors: ${errors.join(', ')}`);\n\t      }\n\t    }\n\t    if (invalid.length > 0) {\n\t      this.logger.warn(`Invalid sessions:\\n${invalid.map((session) => session.username).join('\\n')}`);\n\t    }\n\t    await delay(1000);\n\t  }\n\t  private async validateSession(session: Session) {\n", "    const errors: string[] = [];\n\t    let expires = Date.now();\n\t    if (!session) errors.push('Invalid session');\n\t    if (session.schemaVersion !== this.configService.getOrThrow<number>('session.schemaVersion')) {\n\t      errors.push('Outdated schema version');\n\t    }\n\t    if (!session.username) errors.push('Invalid username');\n\t    if (!session.password) errors.push('Invalid password');\n\t    if (!session.steamId) errors.push('Invalid steamId');\n\t    if (!session.hasOwnProperty('sharedSecret')) errors.push('Invalid shared Secret');\n", "    if (!session.hasOwnProperty('identitySecret')) errors.push('Invalid identity Secret');\n\t    if (session.desktopRefreshToken) {\n\t      if (!this.steamTokensService.validateRefreshToken(session.desktopRefreshToken)) {\n\t        errors.push('Invalid desktop refresh token');\n\t      }\n\t      const tokenExpiration = this.steamTokensService.getRefreshTokenExpiration(session.desktopRefreshToken);\n\t      if (tokenExpiration > expires) expires = tokenExpiration;\n\t    }\n\t    if (session.mobileRefreshToken) {\n\t      if (!this.steamTokensService.validateRefreshToken(session.mobileRefreshToken)) {\n", "        errors.push('Invalid mobile refresh token');\n\t      }\n\t      const tokenExpiration = this.steamTokensService.getRefreshTokenExpiration(session.mobileRefreshToken);\n\t      if (tokenExpiration > expires) expires = tokenExpiration;\n\t    }\n\t    if (session.webRefreshToken) {\n\t      if (!this.steamTokensService.validateRefreshToken(session.webRefreshToken)) {\n\t        errors.push('Invalid web refresh token');\n\t      }\n\t      const tokenExpiration = this.steamTokensService.getRefreshTokenExpiration(session.webRefreshToken);\n", "      if (tokenExpiration > expires) expires = tokenExpiration;\n\t    }\n\t    if (expires < Date.now()) errors.push('Expired session');\n\t    return { valid: errors.length === 0, errors, expires };\n\t  }\n\t}\n"]}
{"filename": "src/config/configuration.ts", "chunked_list": ["import fs from 'fs';\n\timport path from 'path';\n\texport interface Config {\n\t  app: {\n\t    name: string;\n\t    version: string;\n\t    title: string;\n\t    directory: string;\n\t    environment: 'development' | 'production';\n\t  };\n", "  session: {\n\t    schemaVersion: number;\n\t  };\n\t}\n\tconst getPackageJson = (): any => {\n\t  try {\n\t    let filePath = path.resolve(__dirname, '../package.json');\n\t    if (fs.existsSync(filePath)) return JSON.parse(fs.readFileSync(filePath, 'utf8'));\n\t    filePath = path.resolve(__dirname, '../../package.json');\n\t    if (fs.existsSync(filePath)) return JSON.parse(fs.readFileSync(filePath, 'utf8'));\n", "  } catch (error) {\n\t    throw new Error('Failed to read package.json');\n\t  }\n\t};\n\texport default (): Config => {\n\t  const packageJson = getPackageJson();\n\t  const appName = packageJson.name;\n\t  const appVersion = packageJson.version;\n\t  const env = process.env.NODE_ENV || (<any>process).pkg ? 'production' : 'development';\n\t  const appDirectory = env === 'production' && (<any>process).pkg ? path.dirname(process.execPath) : process.cwd();\n", "  return {\n\t    app: {\n\t      name: appName,\n\t      title: appName,\n\t      version: appVersion,\n\t      directory: appDirectory,\n\t      environment: env,\n\t    },\n\t    session: {\n\t      schemaVersion: 2,\n", "    },\n\t  };\n\t};\n"]}
{"filename": "src/interfaces/proxy.interface.ts", "chunked_list": ["export interface Proxy {\n\t  host: string;\n\t  port: number;\n\t  protocol: string;\n\t  auth?: {\n\t    username: string;\n\t    password: string;\n\t  };\n\t  toString(): string;\n\t}\n"]}
{"filename": "src/interfaces/account.interface.ts", "chunked_list": ["export interface Account {\n\t  username: string;\n\t  password: string;\n\t  sharedSecret: string | null;\n\t  identitySecret: string | null;\n\t}\n"]}
{"filename": "src/interfaces/session.interface.ts", "chunked_list": ["export interface Session {\n\t  username: string;\n\t  password: string;\n\t  steamId: string;\n\t  webRefreshToken: string;\n\t  mobileRefreshToken: string;\n\t  desktopRefreshToken: string;\n\t  sharedSecret: string | null;\n\t  identitySecret: string | null;\n\t  schemaVersion: number;\n", "}\n"]}
{"filename": "src/interfaces/secrets.interface.ts", "chunked_list": ["export interface Secrets {\n\t  username: string;\n\t  sharedSecret: string;\n\t  identitySecret: string;\n\t}\n"]}
{"filename": "src/modules/proxies-import/proxies-import.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { ProxiesImportService } from './proxies-import.service';\n\t@Module({\n\t  providers: [ProxiesImportService],\n\t  exports: [ProxiesImportService],\n\t})\n\texport class ProxiesImportModule {}\n"]}
{"filename": "src/modules/proxies-import/proxies-import.service.ts", "chunked_list": ["import fs from 'fs/promises';\n\timport inquirer from 'inquirer';\n\timport { setTimeout as delay } from 'timers/promises';\n\timport { Injectable, Logger } from '@nestjs/common';\n\timport { Proxy as IProxy } from '../../interfaces/proxy.interface';\n\tclass Proxy implements IProxy {\n\t  public readonly host: string;\n\t  public readonly port: number;\n\t  public readonly protocol: string;\n\t  public readonly auth?: { username: string; password: string };\n", "  constructor(proxy: string) {\n\t    if (!/^(https?|socks5?):\\/\\/([-\\w:@.^&]+)$/.test(proxy)) throw new Error('Invalid proxy');\n\t    const url = new URL(proxy);\n\t    this.host = url.hostname;\n\t    this.port = Number(url.port);\n\t    this.protocol = url.protocol.replace(/:$/, '');\n\t    if (url.username.length > 0 && url.password.length > 0) {\n\t      this.auth = { username: url.username, password: url.password };\n\t    }\n\t  }\n", "  public toString() {\n\t    return this.auth\n\t      ? `${this.protocol}://${this.auth.username}:${this.auth.password}@${this.host}:${this.port}`\n\t      : `${this.protocol}://${this.host}:${this.port}`;\n\t  }\n\t}\n\t@Injectable()\n\texport class ProxiesImportService {\n\t  private readonly logger = new Logger(ProxiesImportService.name);\n\t  public async loadProxies(input: string[] | string) {\n", "    if (!input) return [];\n\t    if (!Array.isArray(input)) input = [input];\n\t    if (input.length === 0) return [];\n\t    let proxies: Proxy[] = [];\n\t    const errors: string[] = [];\n\t    const readResults = await Promise.all(input.map((input) => this.readProxyFromInput(input)));\n\t    for (const result of readResults) {\n\t      proxies.push(...result.values);\n\t      errors.push(...result.errors);\n\t    }\n", "    proxies = this.removeDuplicates(proxies);\n\t    if (errors.length > 0) {\n\t      this.logger.warn(`The following proxy sources are invalid:\\n${errors.join('\\n')}`);\n\t      await delay(1000);\n\t      const { confirm } = await inquirer.prompt({\n\t        type: 'confirm',\n\t        name: 'confirm',\n\t        message: proxies.length > 0 ? `Continue with ${proxies.length} valid proxies ?` : 'Continue without proxies ?',\n\t        default: false,\n\t      });\n", "      if (!confirm) throw new Error('Aborted by user');\n\t    }\n\t    return proxies;\n\t  }\n\t  private removeDuplicates(proxies: Proxy[]) {\n\t    const map = new Map<string, Proxy>();\n\t    for (const proxy of proxies) map.set(proxy.toString(), proxy);\n\t    return [...map.values()];\n\t  }\n\t  private async readProxyFromInput(input: string) {\n", "    const inputType = await this.inferInputType(input);\n\t    if (inputType === 'file') return await this.readProxyFromFile(input);\n\t    if (inputType === 'string') return this.readProxyFromString(input);\n\t    if (inputType === 'directory') return { values: [], errors: [input] };\n\t  }\n\t  private readProxyFromString(str: string) {\n\t    const result: { values: Proxy[]; errors: string[] } = { values: [], errors: [] };\n\t    try {\n\t      const proxy = new Proxy(str);\n\t      result.values.push(proxy);\n", "    } catch (error) {\n\t      result.errors.push(str);\n\t    }\n\t    return result;\n\t  }\n\t  private async readProxyFromFile(path: string) {\n\t    const result: { values: Proxy[]; errors: string[] } = { values: [], errors: [] };\n\t    try {\n\t      const file = await fs.readFile(path, 'utf8');\n\t      const lines = file\n", "        .split(/\\s+|\\r?\\n/)\n\t        .map((line) => line.trim())\n\t        .filter((line) => line.length > 0);\n\t      if (lines.length === 0) throw new Error(`File '${path}' is empty`);\n\t      for (const line of lines) {\n\t        const { values, errors } = this.readProxyFromString(line);\n\t        result.values.push(...values);\n\t        result.errors.push(...errors);\n\t      }\n\t    } catch (error) {\n", "      result.errors.push(path);\n\t    }\n\t    return result;\n\t  }\n\t  private async inferInputType(input: string) {\n\t    if (typeof input !== 'string') throw new Error(`Invalid input type: '${typeof input}'`);\n\t    try {\n\t      const stats = await fs.stat(input);\n\t      if (stats.isFile()) return 'file';\n\t      if (stats.isDirectory()) return 'directory';\n", "    } catch (error) {\n\t      return 'string';\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/modules/export-sessions/export-sessions.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { ExportSessionsService } from './export-sessions.service';\n\t@Module({\n\t  providers: [ExportSessionsService],\n\t  exports: [ExportSessionsService],\n\t})\n\texport class ExportSessionsModule {}\n"]}
{"filename": "src/modules/export-sessions/export-sessions.service.ts", "chunked_list": ["import fs from 'fs/promises';\n\timport path from 'path';\n\timport { Injectable } from '@nestjs/common';\n\timport { Session } from '../../interfaces/session.interface';\n\t@Injectable()\n\texport class ExportSessionsService {\n\t  private readonly fileExtension = 'steamsession';\n\t  private outputPath = './output';\n\t  public async setOutputPath(directory: string) {\n\t    if (directory === this.outputPath) return;\n", "    if (!directory || typeof directory !== 'string') throw new Error('Invalid output path');\n\t    if (!path.isAbsolute(directory)) throw new Error('Output path must be absolute');\n\t    try {\n\t      await fs.mkdir(directory, { recursive: true });\n\t    } catch (error) {\n\t      throw new Error('Failed to create output directory', { cause: error });\n\t    }\n\t    this.outputPath = directory;\n\t  }\n\t  public async exportSession(session: Session) {\n", "    const serializedSession = this.serializeSession(session);\n\t    const sessionPath = path.resolve(this.outputPath, `${session.username}.${this.fileExtension}`);\n\t    try {\n\t      await fs.writeFile(sessionPath, serializedSession);\n\t    } catch (error) {\n\t      throw new Error('Failed to write session to file', { cause: error });\n\t    }\n\t  }\n\t  private serializeSession(session: Session) {\n\t    const serializedObject = Object.fromEntries(\n", "      Object.entries(session).map(([key, value]) => {\n\t        key = key[0].toUpperCase() + key.slice(1);\n\t        value = value || null;\n\t        return [key, value];\n\t      }),\n\t    );\n\t    const serializedString = JSON.stringify(serializedObject, null, 2);\n\t    return serializedString;\n\t  }\n\t}\n"]}
{"filename": "src/modules/steam-tokens/steam-tokens.service.ts", "chunked_list": ["import { Cache } from 'cache-manager';\n\timport pEvent from 'p-event';\n\timport { EAuthTokenPlatformType, EResult, LoginSession } from 'steam-session';\n\timport SteamTotp from 'steam-totp';\n\timport { CACHE_MANAGER } from '@nestjs/cache-manager';\n\timport { Inject, Injectable } from '@nestjs/common';\n\timport { Account } from '../../interfaces/account.interface';\n\timport { ProxiesService } from '../proxies/proxies.service';\n\t@Injectable()\n\texport class SteamTokensService {\n", "  private readonly connectionThrottlingTimeout = 31 * 1000;\n\t  constructor(\n\t    @Inject(CACHE_MANAGER) private throttledConnections: Cache,\n\t    private readonly proxiesService: ProxiesService,\n\t  ) {}\n\t  public async createRefreshToken(account: Account, platform: 'web' | 'mobile' | 'desktop') {\n\t    const loginSessionPlatform = this.inferLoginSessionPlatform(platform);\n\t    const proxy = await this.proxiesService.getProxy();\n\t    const connectionId = this.inferConnectionId((proxy || '').toString());\n\t    await this.waitConnectionLimitReset(connectionId);\n", "    this.throttleConnection(connectionId, this.connectionThrottlingTimeout);\n\t    const loginSessionOptions = {};\n\t    if (proxy) loginSessionOptions[proxy.protocol.includes('socks') ? 'socksProxy' : 'httpProxy'] = proxy.toString();\n\t    const loginSession = new LoginSession(loginSessionPlatform, loginSessionOptions);\n\t    loginSession.on('error', () => {}); // fallback errors handling\n\t    try {\n\t      const credentials = { accountName: account.username, password: account.password } as any;\n\t      if (account.sharedSecret) credentials.steamGuardCode = SteamTotp.getAuthCode(account.sharedSecret);\n\t      loginSession\n\t        .startWithCredentials(credentials)\n", "        .then((result) => result.actionRequired && loginSession.emit('error', new Error('Guard action required')))\n\t        .catch((error) => loginSession.emit('error', error));\n\t      await pEvent(loginSession, 'authenticated', { rejectionEvents: ['error', 'timeout'], timeout: 35000 });\n\t      const refreshToken = loginSession.refreshToken;\n\t      if (!refreshToken) throw new Error('Refresh token is empty');\n\t      return refreshToken;\n\t    } catch (error) {\n\t      if (error.eresult === EResult.RateLimitExceeded) this.throttleConnection(connectionId, 31 * 60 * 1000);\n\t      throw new Error('Failed to create refresh token', { cause: error });\n\t    } finally {\n", "      if (loginSession) loginSession.cancelLoginAttempt();\n\t    }\n\t  }\n\t  public decodeRefreshToken(token: string) {\n\t    try {\n\t      const parts = token.split('.');\n\t      if (parts.length !== 3) throw new Error('Invalid token');\n\t      const headerBase64Url = parts[1];\n\t      const headerBase64 = headerBase64Url.replace(/-/g, '+').replace(/_/g, '/');\n\t      const headerJson = Buffer.from(headerBase64, 'base64').toString('utf-8');\n", "      return JSON.parse(headerJson);\n\t    } catch (error) {\n\t      throw new Error('An error occurred while decoding refresh token', { cause: error });\n\t    }\n\t  }\n\t  public validateRefreshToken(token: string) {\n\t    try {\n\t      const { iss, sub, exp, aud } = this.decodeRefreshToken(token);\n\t      if (!iss || !sub || !exp || !aud) return false;\n\t      if (iss !== 'steam') return false;\n", "      if (exp < Math.floor(Date.now() / 1000)) return false;\n\t      if (!aud.includes('renew')) return false;\n\t      return true;\n\t    } catch (error) {\n\t      return false;\n\t    }\n\t  }\n\t  public getRefreshTokenExpiration(token: string) {\n\t    try {\n\t      const { exp } = this.decodeRefreshToken(token);\n", "      return exp * 1000;\n\t    } catch (error) {\n\t      return 0;\n\t    }\n\t  }\n\t  private inferLoginSessionPlatform(platform: 'web' | 'mobile' | 'desktop'): EAuthTokenPlatformType {\n\t    if (platform === 'web') return EAuthTokenPlatformType.WebBrowser;\n\t    else if (platform === 'mobile') return EAuthTokenPlatformType.MobileApp;\n\t    else if (platform === 'desktop') return EAuthTokenPlatformType.SteamClient;\n\t    else throw new Error('Invalid platform');\n", "  }\n\t  private inferConnectionId(id?: string) {\n\t    return `${SteamTokensService.name}:${id || 'localhost'}`;\n\t  }\n\t  private throttleConnection(connectionId: string, timeoutMs: number) {\n\t    connectionId = this.inferConnectionId(connectionId);\n\t    this.throttledConnections.set(connectionId, true, timeoutMs);\n\t    if (this.inferConnectionId() !== connectionId) this.proxiesService.throttleProxy(connectionId, timeoutMs);\n\t  }\n\t  private async waitConnectionLimitReset(connectionId: string) {\n", "    connectionId = this.inferConnectionId(connectionId);\n\t    const execute = () => {\n\t      if (this.throttledConnections.get(connectionId)) return false;\n\t      this.throttleConnection(connectionId, 1000);\n\t      return true;\n\t    };\n\t    if (execute()) return;\n\t    return new Promise<void>((resolve) => {\n\t      const interval = setInterval(() => {\n\t        if (!execute()) return;\n", "        clearInterval(interval);\n\t        resolve();\n\t      }, 1000);\n\t    });\n\t  }\n\t}\n"]}
{"filename": "src/modules/steam-tokens/steam-tokens.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { ProxiesModule } from '../proxies/proxies.module';\n\timport { SteamTokensService } from './steam-tokens.service';\n\t@Module({\n\t  imports: [ProxiesModule],\n\t  providers: [SteamTokensService],\n\t  exports: [SteamTokensService],\n\t})\n\texport class SteamTokensModule {}\n"]}
{"filename": "src/modules/proxies/proxies.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { ProxiesService } from './proxies.service';\n\t@Module({\n\t  providers: [ProxiesService],\n\t  exports: [ProxiesService],\n\t})\n\texport class ProxiesModule {}\n"]}
{"filename": "src/modules/proxies/proxies.service.ts", "chunked_list": ["import { Cache } from 'cache-manager';\n\timport pQueue from 'p-queue';\n\timport { CACHE_MANAGER } from '@nestjs/cache-manager';\n\timport { Inject, Injectable } from '@nestjs/common';\n\timport { Proxy } from '../../interfaces/proxy.interface';\n\t@Injectable()\n\texport class ProxiesService {\n\t  private readonly proxies: Map<string, Proxy> = new Map();\n\t  private readonly proxiesUsageQueue = new pQueue({ concurrency: 1 });\n\t  constructor(@Inject(CACHE_MANAGER) private throttledProxies: Cache) {}\n", "  public setProxies(proxies: Proxy[]) {\n\t    if (proxies.length === 0) return;\n\t    for (const proxy of proxies) {\n\t      this.proxies.set(proxy.toString(), proxy);\n\t    }\n\t  }\n\t  public async getProxy(): Promise<Proxy | null> {\n\t    if (this.proxies.size === 0) return null;\n\t    const proxy = await this.proxiesUsageQueue.add(() => this.fetchProxy());\n\t    this.throttleProxy(proxy);\n", "    return proxy;\n\t  }\n\t  public getProxiesCount() {\n\t    return this.proxies.size;\n\t  }\n\t  public throttleProxy(proxy: Proxy | string, timeoutMs?: number) {\n\t    const proxyId = this.getProxyId(proxy);\n\t    this.throttledProxies.set(proxyId, true, timeoutMs);\n\t  }\n\t  private async fetchProxy() {\n", "    const proxy = await new Promise<Proxy>((resolve) => {\n\t      let proxy = this.findAvailableProxy();\n\t      if (proxy) return resolve(proxy);\n\t      const interval = setInterval(() => {\n\t        proxy = this.findAvailableProxy();\n\t        if (!proxy) return;\n\t        clearInterval(interval);\n\t        resolve(proxy);\n\t      }, 1000);\n\t    });\n", "    return proxy;\n\t  }\n\t  private findAvailableProxy(): Proxy | null {\n\t    for (const proxy of this.proxies.values()) {\n\t      const proxyId = this.getProxyId(proxy);\n\t      if (this.throttledProxies.get(proxyId)) continue;\n\t      return proxy;\n\t    }\n\t    return null;\n\t  }\n", "  private getProxyId(proxy: Proxy | string) {\n\t    return `${ProxiesService.name}:${proxy.toString()}`;\n\t  }\n\t}\n"]}
{"filename": "src/modules/accounts-import/accounts-import.service.ts", "chunked_list": ["import fs from 'fs/promises';\n\timport inquirer from 'inquirer';\n\timport pQueue from 'p-queue';\n\timport { setTimeout as delay } from 'timers/promises';\n\timport { Injectable, Logger } from '@nestjs/common';\n\timport { Account as IAccount } from '../../interfaces/account.interface';\n\timport { Secrets } from '../../interfaces/secrets.interface';\n\tclass Account implements IAccount {\n\t  public readonly username: string;\n\t  public readonly password: string;\n", "  public sharedSecret: string | null = null;\n\t  public identitySecret: string | null = null;\n\t  constructor(account: string) {\n\t    account = account.trim();\n\t    if (account.length === 0) throw new Error('Invalid account');\n\t    const parts = account.split(':').map((part) => part.trim());\n\t    if (parts.length < 2) throw new Error('Invalid account');\n\t    const [username, password, sharedSecret, identitySecret] = parts;\n\t    this.username = username;\n\t    this.password = password;\n", "    if (sharedSecret) this.sharedSecret = sharedSecret;\n\t    if (identitySecret) this.identitySecret = identitySecret;\n\t  }\n\t}\n\t@Injectable()\n\texport class AccountsImportService {\n\t  private readonly logger = new Logger(AccountsImportService.name);\n\t  private readonly readFilesQueue = new pQueue({ concurrency: 100 });\n\t  public async loadAccounts(input: string[] | string) {\n\t    if (!input) return [];\n", "    if (!Array.isArray(input)) input = [input];\n\t    if (input.length === 0) return [];\n\t    let accounts: Account[] = [];\n\t    const errors: string[] = [];\n\t    const readResults = await Promise.all(input.map((input) => this.readAccountsFromInput(input)));\n\t    for (const result of readResults) {\n\t      accounts.push(...result.values);\n\t      errors.push(...result.errors);\n\t    }\n\t    accounts = this.removeDuplicates(accounts);\n", "    if (errors.length > 0 && accounts.length > 0) {\n\t      this.logger.warn(`The following account sources are invalid:\\n${errors.join('\\n')}`);\n\t      await delay(1000);\n\t      const { confirm } = await inquirer.prompt({\n\t        type: 'confirm',\n\t        name: 'confirm',\n\t        message: 'Continue with the valid accounts?',\n\t        default: false,\n\t      });\n\t      if (!confirm) throw new Error('Aborted by user');\n", "    }\n\t    return accounts;\n\t  }\n\t  public assignSecretsToAccounts(accounts: Account[], secrets: Secrets[]) {\n\t    const secretsMap = new Map<string, Secrets>();\n\t    for (const secret of secrets) {\n\t      secretsMap.set(secret.username, secret);\n\t      // some existing steam-oriented apps are case-insensitive to usernames in secrets\n\t      secretsMap.set(secret.username.toLowerCase(), secret);\n\t    }\n", "    for (const account of accounts) {\n\t      let secret = secretsMap.get(account.username);\n\t      if (!secret) secret = secretsMap.get(account.username.toLowerCase());\n\t      if (!secret) continue;\n\t      account.sharedSecret = secret.sharedSecret;\n\t      account.identitySecret = secret.identitySecret;\n\t    }\n\t  }\n\t  private removeDuplicates(accounts: Account[]) {\n\t    const map = new Map<string, Account>();\n", "    for (const account of accounts) map.set(account.username, account);\n\t    return [...map.values()];\n\t  }\n\t  private async readAccountsFromInput(input: string) {\n\t    const inputType = await this.inferInputType(input);\n\t    if (inputType === 'file') return this.readAccountsFromFile(input);\n\t    if (inputType === 'string') return this.readAccountFromString(input);\n\t    if (inputType === 'directory') return { values: [], errors: [input] };\n\t  }\n\t  private async readAccountsFromFile(filePath: string) {\n", "    const result: { values: Account[]; errors: string[] } = { values: [], errors: [] };\n\t    try {\n\t      let content = await this.readFilesQueue.add(() => fs.readFile(filePath, 'utf-8'));\n\t      content = content.trim();\n\t      if (content.length === 0) throw new Error('Empty file');\n\t      // session file\n\t      if (filePath.endsWith('.steamsession')) {\n\t        const readResults = this.readAccountFromSessionFile(content);\n\t        result.values.push(...readResults.values);\n\t        if (readResults.errors.length > 0) result.errors.push(filePath);\n", "        return result;\n\t      }\n\t      // asf json\n\t      if (filePath.endsWith('.json') && content.includes('\"SteamLogin\"')) {\n\t        const readResults = this.readAccountFromAsfJson(content);\n\t        result.values.push(...readResults.values);\n\t        if (readResults.errors.length > 0) result.errors.push(filePath);\n\t        return result;\n\t      }\n\t      // plain text\n", "      if (content.includes(':')) {\n\t        const lines = content\n\t          .split(/\\s+|\\r?\\n/)\n\t          .map((l) => l.trim())\n\t          .filter((l) => l.length > 0);\n\t        if (lines.length === 0) throw new Error('Empty file');\n\t        for (const line of lines) {\n\t          const readResults = this.readAccountFromString(line);\n\t          result.values.push(...readResults.values);\n\t          if (readResults.errors.length > 0) result.errors.push(line);\n", "        }\n\t        return result;\n\t      }\n\t      throw new Error('Unsupported file format');\n\t    } catch (error) {\n\t      result.errors.push(filePath);\n\t    }\n\t    return result;\n\t  }\n\t  private readAccountFromString(str: string) {\n", "    const result: { values: Account[]; errors: string[] } = { values: [], errors: [] };\n\t    try {\n\t      const account = new Account(str);\n\t      result.values.push(account);\n\t    } catch (error) {\n\t      result.errors.push(str);\n\t    }\n\t    return result;\n\t  }\n\t  private readAccountFromAsfJson(fileContent: string) {\n", "    const result: { values: Account[]; errors: string[] } = { values: [], errors: [] };\n\t    try {\n\t      const { SteamLogin: username, SteamPassword: password } = JSON.parse(fileContent);\n\t      if (!username) throw new Error('Invalid username');\n\t      if (!password) throw new Error('Invalid password');\n\t      const account = new Account(`${username}:${password}`);\n\t      result.values.push(account);\n\t    } catch (error) {\n\t      result.errors.push(fileContent);\n\t    }\n", "    return result;\n\t  }\n\t  private readAccountFromSessionFile(fileContent: string) {\n\t    const result: { values: Account[]; errors: string[] } = { values: [], errors: [] };\n\t    try {\n\t      const { Username, Password, SharedSecret, IdentitySecret } = JSON.parse(fileContent);\n\t      if (!Username) throw new Error('Invalid username');\n\t      if (!Password) throw new Error('Invalid password');\n\t      const account = new Account(`${Username}:${Password}:${SharedSecret || ''}:${IdentitySecret || ''}`);\n\t      result.values.push(account);\n", "    } catch (error) {\n\t      result.errors.push(fileContent);\n\t    }\n\t    return result;\n\t  }\n\t  private async inferInputType(input: string) {\n\t    if (typeof input !== 'string') throw new Error(`Invalid input type: '${typeof input}'`);\n\t    try {\n\t      const stats = await fs.stat(input);\n\t      if (stats.isFile()) return 'file';\n", "      if (stats.isDirectory()) return 'directory';\n\t    } catch (error) {\n\t      return 'string';\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/modules/accounts-import/accounts-import.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { AccountsImportService } from './accounts-import.service';\n\t@Module({\n\t  providers: [AccountsImportService],\n\t  exports: [AccountsImportService],\n\t})\n\texport class AccountsImportModule {}\n"]}
{"filename": "src/modules/sessions-import/sessions-import.service.ts", "chunked_list": ["import fs from 'fs/promises';\n\timport inquirer from 'inquirer';\n\timport pQueue from 'p-queue';\n\timport { setTimeout as delay } from 'timers/promises';\n\timport { Injectable, Logger } from '@nestjs/common';\n\timport { Session } from '../../interfaces/session.interface';\n\t@Injectable()\n\texport class SessionsImportService {\n\t  private readonly logger = new Logger(SessionsImportService.name);\n\t  private readonly readFilesQueue = new pQueue({ concurrency: 100 });\n", "  public async loadSessions(input: string[] | string) {\n\t    if (!input) return [];\n\t    if (!Array.isArray(input)) input = [input];\n\t    if (input.length === 0) return [];\n\t    let sessions: Session[] = [];\n\t    const errors: string[] = [];\n\t    const readResults = await Promise.all(input.map((input) => this.readSessionsFromInput(input)));\n\t    for (const result of readResults) {\n\t      sessions.push(...result.values);\n\t      errors.push(...result.errors);\n", "    }\n\t    sessions = this.removeDuplicates(sessions);\n\t    if (errors.length > 0 && sessions.length > 0) {\n\t      this.logger.warn(`The following session sources are invalid:\\n${errors.join('\\n')}`);\n\t      await delay(1000);\n\t      const { confirm } = await inquirer.prompt({\n\t        type: 'confirm',\n\t        name: 'confirm',\n\t        message: 'Continue with the valid sessions?',\n\t        default: false,\n", "      });\n\t      if (!confirm) throw new Error('Aborted by user');\n\t    }\n\t    return sessions;\n\t  }\n\t  private removeDuplicates(sessions: Session[]) {\n\t    const map = new Map<string, Session>();\n\t    for (const session of sessions) map.set(session.username, session);\n\t    return [...map.values()];\n\t  }\n", "  private async readSessionsFromInput(input: string) {\n\t    const inputType = await this.inferInputType(input);\n\t    if (inputType === 'file') return this.readSessionFromFile(input);\n\t    if (inputType === 'string') return { values: [], errors: [input] };\n\t    if (inputType === 'directory') return { values: [], errors: [input] };\n\t  }\n\t  private async readSessionFromFile(filePath: string) {\n\t    const result: { values: Session[]; errors: string[] } = { values: [], errors: [] };\n\t    try {\n\t      let content = await this.readFilesQueue.add(() => fs.readFile(filePath, 'utf-8'));\n", "      content = JSON.parse(content);\n\t      if (content == null || typeof content !== 'object' || Array.isArray(content)) {\n\t        throw new Error('Invalid session file');\n\t      }\n\t      const session = Object.fromEntries(\n\t        Object.entries(content).map(([key, value]) => [key[0].toLowerCase() + key.slice(1), value]),\n\t      ) as unknown as Session;\n\t      result.values.push(session);\n\t    } catch (error) {\n\t      result.errors.push(filePath);\n", "    }\n\t    return result;\n\t  }\n\t  private async inferInputType(input: string) {\n\t    if (typeof input !== 'string') throw new Error(`Invalid input type: '${typeof input}'`);\n\t    try {\n\t      const stats = await fs.stat(input);\n\t      if (stats.isFile()) return 'file';\n\t      if (stats.isDirectory()) return 'directory';\n\t    } catch (error) {\n", "      return 'string';\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/modules/sessions-import/sessions-import.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { SessionsImportService } from './sessions-import.service';\n\t@Module({\n\t  providers: [SessionsImportService],\n\t  exports: [SessionsImportService],\n\t})\n\texport class SessionsImportModule {}\n"]}
{"filename": "src/modules/logger/logger.module.ts", "chunked_list": ["import { LoggerModule as PinoLoggerModule } from 'nestjs-pino';\n\timport { Global, Module } from '@nestjs/common';\n\timport { ConfigModule, ConfigService } from '@nestjs/config';\n\timport { LoggerService } from './logger.service';\n\t@Global()\n\t@Module({\n\t  imports: [\n\t    PinoLoggerModule.forRootAsync({\n\t      imports: [ConfigModule],\n\t      useFactory: async (configService) => ({\n", "        pinoHttp: {\n\t          level: configService.getOrThrow('app.environment') === 'production' ? 'info' : 'trace',\n\t          base: null,\n\t          transport: {\n\t            targets: [{ target: 'pino-pretty', level: 'trace', options: { sync: true } }],\n\t          },\n\t        },\n\t      }),\n\t      inject: [ConfigService],\n\t    }),\n", "  ],\n\t  providers: [LoggerService],\n\t})\n\texport class LoggerModule {}\n"]}
{"filename": "src/modules/logger/logger.service.ts", "chunked_list": ["import { PinoLogger } from 'nestjs-pino';\n\timport { setTimeout as delay } from 'timers/promises';\n\timport { Injectable, OnModuleDestroy } from '@nestjs/common';\n\t@Injectable()\n\texport class LoggerService implements OnModuleDestroy {\n\t  constructor(private readonly logger: PinoLogger) {}\n\t  public async onModuleDestroy() {\n\t    this.logger.logger.flush();\n\t    await delay(1000);\n\t  }\n", "}\n"]}
{"filename": "src/modules/secrets-import/secrets-import.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { SecretsImportService } from './secrets-import.service';\n\t@Module({\n\t  providers: [SecretsImportService],\n\t  exports: [SecretsImportService],\n\t})\n\texport class SecretsImportModule {}\n"]}
{"filename": "src/modules/secrets-import/secrets-import.service.ts", "chunked_list": ["import fs from 'fs/promises';\n\timport inquirer from 'inquirer';\n\timport pQueue from 'p-queue';\n\timport path from 'path';\n\timport { setTimeout as delay } from 'timers/promises';\n\timport { Injectable, Logger } from '@nestjs/common';\n\timport { Secrets as ISecrets } from '../../interfaces/secrets.interface';\n\tclass Secrets implements ISecrets {\n\t  public readonly username: string;\n\t  public readonly sharedSecret: string;\n", "  public readonly identitySecret: string;\n\t  constructor(secrets: string) {\n\t    let parsedSecrets: any;\n\t    try {\n\t      parsedSecrets = JSON.parse(secrets);\n\t    } catch (error) {}\n\t    if (typeof parsedSecrets !== 'object' || parsedSecrets === null) throw new Error('Secrets string is invalid');\n\t    const { shared_secret, identity_secret, account_name } = parsedSecrets;\n\t    if (!shared_secret) throw new Error('Shared secret is missing');\n\t    this.sharedSecret = shared_secret;\n", "    if (!identity_secret) throw new Error('Identity secret is missing');\n\t    this.identitySecret = identity_secret;\n\t    if (!account_name) throw new Error('Account name is missing');\n\t    this.username = account_name;\n\t  }\n\t}\n\t@Injectable()\n\texport class SecretsImportService {\n\t  private readonly logger = new Logger(SecretsImportService.name);\n\t  private readonly readFilesQueue = new pQueue({ concurrency: 100 });\n", "  public async loadSecrets(input: string[] | string) {\n\t    if (!input) return [];\n\t    if (!Array.isArray(input)) input = [input];\n\t    if (input.length === 0) return [];\n\t    let secrets: Secrets[] = [];\n\t    const errors: string[] = [];\n\t    const readResults = await Promise.all(input.map((input) => this.readSecretsFromInput(input)));\n\t    for (const result of readResults) {\n\t      secrets.push(...result.values);\n\t      errors.push(...result.errors);\n", "    }\n\t    secrets = this.removeDuplicates(secrets);\n\t    if (errors.length > 0) {\n\t      this.logger.warn(`The following secret sources are invalid:\\n${errors.join('\\n')}`);\n\t      await delay(1000);\n\t      const { confirm } = await inquirer.prompt({\n\t        type: 'confirm',\n\t        name: 'confirm',\n\t        message:\n\t          secrets.length > 0 ? `Continue with ${secrets.length} valid secrets?` : 'Continue without any secrets?',\n", "        default: false,\n\t      });\n\t      if (!confirm) throw new Error('Aborted by user');\n\t    }\n\t    return secrets;\n\t  }\n\t  private removeDuplicates(secrets: Secrets[]) {\n\t    const map = new Map<string, Secrets>();\n\t    for (const secret of secrets) map.set(secret.username, secret);\n\t    return [...map.values()];\n", "  }\n\t  private async readSecretsFromInput(input: string) {\n\t    const inputType = await this.inferInputType(input);\n\t    if (inputType === 'file') return this.readSecretsFromFile(input);\n\t    if (inputType === 'string') return { values: [], errors: [input] };\n\t    if (inputType === 'directory') return { values: [], errors: [input] };\n\t  }\n\t  private async readSecretsFromFile(filePath: string) {\n\t    const result: { values: Secrets[]; errors: string[] } = { values: [], errors: [] };\n\t    try {\n", "      const fileExtension = path.extname(filePath);\n\t      // mafile\n\t      if (fileExtension.toLowerCase() === '.mafile') {\n\t        const readResult = await this.readSecretsFromMaFile(filePath);\n\t        result.values.push(...readResult.values);\n\t        if (readResult.errors.length > 0) result.errors.push(filePath);\n\t        return result;\n\t      }\n\t      // asf db\n\t      if (fileExtension === '.db') {\n", "        const readResult = await this.readSecretsFromAsfDbFile(filePath);\n\t        result.values.push(...readResult.values);\n\t        if (readResult.errors.length > 0) result.errors.push(filePath);\n\t        return result;\n\t      }\n\t      throw new Error('Unsupported file format');\n\t    } catch (error) {\n\t      result.errors.push(filePath);\n\t    }\n\t    return result;\n", "  }\n\t  private async readSecretsFromMaFile(filePath: string) {\n\t    const result: { values: Secrets[]; errors: string[] } = { values: [], errors: [] };\n\t    try {\n\t      let content = await this.readFilesQueue.add(() => fs.readFile(filePath, 'utf-8'));\n\t      content = content.trim().replace(/},\\s*}/g, '}}');\n\t      const secrets = new Secrets(content);\n\t      result.values.push(secrets);\n\t    } catch (error) {\n\t      result.errors.push(filePath);\n", "    }\n\t    return result;\n\t  }\n\t  private async readSecretsFromAsfDbFile(filePath: string) {\n\t    const result: { values: Secrets[]; errors: string[] } = { values: [], errors: [] };\n\t    try {\n\t      let content = await this.readFilesQueue.add(() => fs.readFile(filePath, 'utf-8'));\n\t      const parsedContent = JSON.parse(content)['_MobileAuthenticator'];\n\t      parsedContent['account_name'] = path.basename(filePath, path.extname(filePath));\n\t      content = JSON.stringify(parsedContent);\n", "      const secrets = new Secrets(content);\n\t      result.values.push(secrets);\n\t    } catch (error) {\n\t      result.errors.push(filePath);\n\t    }\n\t    return result;\n\t  }\n\t  private async inferInputType(input: string) {\n\t    if (typeof input !== 'string') throw new Error(`Invalid input type: '${typeof input}'`);\n\t    try {\n", "      const stats = await fs.stat(input);\n\t      if (stats.isFile()) return 'file';\n\t      if (stats.isDirectory()) return 'directory';\n\t    } catch (error) {\n\t      return 'string';\n\t    }\n\t  }\n\t}\n"]}
