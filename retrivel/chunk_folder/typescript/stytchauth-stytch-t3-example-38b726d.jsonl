{"filename": "next-env.d.ts", "chunked_list": ["/// <reference types=\"next\" />\n\t/// <reference types=\"next/image-types/global\" />\n\t// NOTE: This file should not be edited\n\t// see https://nextjs.org/docs/basic-features/typescript for more information.\n"]}
{"filename": "prisma/seed.ts", "chunked_list": ["import { PrismaClient } from '@prisma/client';\n\tconst prisma = new PrismaClient();\n\tasync function main() {\n\t  console.log(`ðŸŽ‰ðŸŽ‰ðŸŽ‰ Seeding Finished ðŸŽ‰ðŸŽ‰ðŸŽ‰`);\n\t}\n\tmain()\n\t  .catch((e) => {\n\t    console.error(e);\n\t    process.exit(1);\n\t  })\n", "  .finally(async () => {\n\t    await prisma.$disconnect();\n\t  });\n"]}
{"filename": "src/middleware.ts", "chunked_list": ["import { NextResponse, type NextRequest } from 'next/server';\n\timport { loadStytch } from '~/server/stytch';\n\texport const config = {\n\t  matcher: ['/profile', '/login'],\n\t};\n\texport const middleware = async (req: NextRequest) => {\n\t  const res = NextResponse.next();\n\t  const { pathname } = req.nextUrl;\n\t  // Pull the session JWT from the cookie.\n\t  const jwtToken = req.cookies.get('session_jwt')?.value;\n", "  // If there is a JWT, we need to verify it with Stytch to make sure it is valid and take the appropriate action.\n\t  if (jwtToken) {\n\t    // Authenticate the JWT with Stytch; this will tell us if the session is still valid.\n\t    try {\n\t      const stytch = loadStytch();\n\t      await stytch.sessions.authenticateJwt(jwtToken);\n\t      // If the session is valid and they are on the login screen, redirect them to the profile screen.\n\t      if (pathname === '/login') {\n\t        return NextResponse.redirect(new URL('/profile', req.url));\n\t      }\n", "    // If there is an error, the session is invalid, delete the cookie and redirect them to the login screen.\n\t    } catch (err) {\n\t      res.cookies.delete('session_jwt');\n\t      return NextResponse.redirect(new URL('/login', req.url), { headers: res.headers });\n\t    }\n\t  }\n\t  // If there is no token, the user does not have an active session, redirect them to the login screen.\n\t  if (!jwtToken && pathname === '/profile') {\n\t    return NextResponse.redirect(new URL('/login', req.url));\n\t  }\n", "  return res;\n\t};\n"]}
{"filename": "src/pages/api/trpc/[trpc].ts", "chunked_list": ["import * as trpcNext from '@trpc/server/adapters/next';\n\timport { createContext } from '~/server/context';\n\timport { appRouter } from '~/server/routers/_app';\n\texport default trpcNext.createNextApiHandler({\n\t  router: appRouter,\n\t  createContext,\n\t  batching: {\n\t    enabled: true,\n\t  },\n\t});\n"]}
{"filename": "src/components/index.ts", "chunked_list": ["export * from './AccountLogout';\n\texport * from './Button';\n\texport * from './Input';\n\texport * from './LoginButton';\n\texport * from './LoginEmail';\n\texport * from './LoginSms';\n\texport * from './PhoneInput';\n\texport * from './Profile';\n\texport * from './SiteHeader';\n\texport * from './VerifyOtp';\n", "export * from './Welcome';"]}
{"filename": "src/utils/trpc.ts", "chunked_list": ["import { httpBatchLink, loggerLink } from '@trpc/client';\n\timport { createTRPCNext } from '@trpc/next';\n\timport superjson from 'superjson';\n\timport { type AppRouter } from '~/server/routers/_app';\n\tfunction getBaseUrl() {\n\t  if (typeof window !== 'undefined')\n\t    // browser should use relative path\n\t    return '';\n\t  if (process.env.VERCEL_URL)\n\t    // reference for vercel.com\n", "    return `https://${process.env.VERCEL_URL}`;\n\t  // assume localhost\n\t  return `http://localhost:${process.env.PORT ?? 3000}`;\n\t}\n\texport const trpc = createTRPCNext<AppRouter>({\n\t  config() {\n\t    return {\n\t      abortOnUnmount: true,\n\t      queryClientConfig: {\n\t        defaultOptions: {\n", "          queries: {\n\t            staleTime: Infinity,\n\t            refetchOnWindowFocus: false,\n\t          },\n\t        },\n\t      },\n\t      transformer: superjson,\n\t      links: [\n\t        loggerLink({\n\t          enabled: (opts) =>\n", "            process.env.NODE_ENV === 'development' || (opts.direction === 'down' && opts.result instanceof Error),\n\t        }),\n\t        httpBatchLink({ url: `${getBaseUrl()}/api/trpc` }),\n\t      ],\n\t    };\n\t  },\n\t  ssr: false,\n\t});\n"]}
{"filename": "src/utils/phone-countries.ts", "chunked_list": ["import { Country } from 'react-phone-number-input';\n\t/**\n\t * These are the countries that Stytch supports at the time of writing\n\t * https://stytch.com/docs/passcodes#unsupported-countries.\n\t *\n\t * This list is used to populate the country dropdown on the phone number input\n\t * in the login form. Simply remove any countries that you don't want to support. You may\n\t * want to limit support due to cost, fraud, or because you do not do business in that country.\n\t **/\n\texport const STYTCH_SUPPORTED_SMS_COUNTRIES: Country[] = [\n", "  'US', // will be selected by default on phone number input\n\t  'CA',\n\t  // 'AU',\n\t  // 'BR',\n\t  // 'DE',\n\t  // 'ES',\n\t  // 'FR',\n\t  // 'GB',\n\t  // 'MX',\n\t];\n"]}
{"filename": "src/utils/regex.ts", "chunked_list": ["// This regex is used to validate that the phone number entered by the user is valid.\n\texport const VALID_PHONE_NUMBER = /^[\\+]?[(]?[0-9]{3}[)]?[-\\s\\.]?[0-9]{3}[-\\s\\.]?[0-9]{4,6}$/;\n"]}
{"filename": "src/server/trpc.ts", "chunked_list": ["import { initTRPC, TRPCError } from '@trpc/server';\n\timport superjson from 'superjson';\n\timport { Context } from './context';\n\t/**\n\t * This is your entry point to setup the root configuration for tRPC on the server.\n\t * - `initTRPC` should only be used once per app.\n\t * - We export only the functionality that we use so we can enforce which base procedures should be used\n\t *\n\t * Learn how to create protected base procedures and other things below:\n\t * @see https://trpc.io/docs/v10/router\n", " * @see https://trpc.io/docs/v10/procedures\n\t */\n\tconst t = initTRPC.context<Context>().create({\n\t  /**\n\t   * @see https://trpc.io/docs/v10/data-transformers\n\t   */\n\t  transformer: superjson,\n\t  /**\n\t   * @see https://trpc.io/docs/v10/error-formatting\n\t   */\n", "  errorFormatter({ shape }) {\n\t    return shape;\n\t  },\n\t});\n\t/**\n\t * Reusable middleware that checks if users are authenticated.\n\t **/\n\tconst isAuthed = t.middleware(async ({ next, ctx }) => {\n\t  if (!ctx.req || !ctx.res) {\n\t    throw new Error('You are missing `req` or `res` in your call.');\n", "  }\n\t  if (!ctx.session) {\n\t    throw new TRPCError({ code: 'UNAUTHORIZED' });\n\t  }\n\t  return next({\n\t    ctx: {\n\t      session: ctx.session,\n\t      req: ctx.req,\n\t      res: ctx.res,\n\t    },\n", "  });\n\t});\n\t/**\n\t * Create a router\n\t * @see https://trpc.io/docs/v10/router\n\t */\n\texport const router = t.router;\n\t/**\n\t * Create an unprotected procedure\n\t * @see https://trpc.io/docs/v10/procedures\n", " **/\n\texport const publicProcedure = t.procedure;\n\t/**\n\t * Protected procedure\n\t **/\n\texport const protectedProcedure = t.procedure.use(isAuthed);\n\t/**\n\t * @see https://trpc.io/docs/v10/middlewares\n\t */\n\texport const middleware = t.middleware;\n", "/**\n\t * @see https://trpc.io/docs/v10/merging-routers\n\t */\n\texport const mergeRouters = t.mergeRouters;\n"]}
{"filename": "src/server/stytch.ts", "chunked_list": ["import * as stytch from 'stytch';\n\tlet client: stytch.Client;\n\t// Initialize the Stytch client.\n\texport const loadStytch = () => {\n\t  if (!client) {\n\t    client = new stytch.Client({\n\t      project_id: process.env.STYTCH_PROJECT_ID!,\n\t      secret: process.env.STYTCH_SECRET!,\n\t      env: process.env.STYTCH_PROJECT_ENV === 'live' ? stytch.envs.live : stytch.envs.test,\n\t    });\n", "  }\n\t  return client;\n\t};\n"]}
{"filename": "src/server/prisma.ts", "chunked_list": ["/**\n\t * Instantiates a single instance PrismaClient and save it on the global object.\n\t * @link https://www.prisma.io/docs/support/help-articles/nextjs-prisma-client-dev-practices\n\t */\n\timport { PrismaClient } from '@prisma/client';\n\tconst prismaGlobal = global as typeof global & {\n\t  prisma?: PrismaClient;\n\t};\n\texport const prisma: PrismaClient =\n\t  prismaGlobal.prisma ||\n", "  new PrismaClient({\n\t    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\n\t  });\n\tif (process.env.NODE_ENV !== 'production') {\n\t  prismaGlobal.prisma = prisma;\n\t}\n"]}
{"filename": "src/server/context.ts", "chunked_list": ["import * as trpc from '@trpc/server';\n\timport * as trpcNext from '@trpc/server/adapters/next';\n\timport { deleteCookie, getCookie } from 'cookies-next';\n\timport { type StytchCustomClaims, type StytchSessionWithCustomClaims } from '~/types/stytch';\n\timport { prisma } from './prisma';\n\timport { loadStytch } from './stytch';\n\texport async function createContext(opts?: trpcNext.CreateNextContextOptions) {\n\t  const req = opts?.req;\n\t  const res = opts?.res;\n\t  const stytch = loadStytch();\n", "  let session: StytchSessionWithCustomClaims | undefined = undefined;\n\t  const jwtToken = getCookie('session_jwt', { req, res })?.toString();\n\t  if (jwtToken) {\n\t    try {\n\t      const authenticateJwtResponse = await stytch.sessions.authenticateJwt(jwtToken);\n\t      session = {\n\t        ...authenticateJwtResponse.session,\n\t        custom_claims: authenticateJwtResponse.session.custom_claims as StytchCustomClaims,\n\t      };\n\t    } catch (err) {\n", "      deleteCookie('session_jwt', { req, res });\n\t    }\n\t  }\n\t  return { req, res, prisma, stytch, session };\n\t}\n\texport type Context = trpc.inferAsyncReturnType<typeof createContext>;\n"]}
{"filename": "src/server/routers/auth.ts", "chunked_list": ["import { TRPCError } from '@trpc/server';\n\timport { deleteCookie, setCookie } from 'cookies-next';\n\timport { parsePhoneNumber } from 'react-phone-number-input';\n\timport { StytchError } from 'stytch';\n\timport { z } from 'zod';\n\timport { protectedProcedure, publicProcedure, router } from '~/server/trpc';\n\timport { VALID_PHONE_NUMBER } from '~/utils/regex';\n\timport { STYTCH_SUPPORTED_SMS_COUNTRIES } from '~/utils/phone-countries';\n\t// Change these values to adjust the length of a user's session. 30 day sessions, like we use here, is usually a good default,\n\t// but you may find a shorter or longer duration to work better for your app.\n", "const SESSION_DURATION_MINUTES = 43200;\n\t// SESSION_DURATION_SECONDS is used to set the age of the cookie that we set in the user's browser.\n\tconst SESSION_DURATION_SECONDS = SESSION_DURATION_MINUTES * 60;\n\texport const authRouter = router({\n\t  // This route is used to send an OTP via email to a user.\n\t  loginEmail: publicProcedure\n\t    .input(\n\t      z.object({\n\t        email: z.string().email('Invalid email address').min(1, 'Email address is required'),\n\t      }),\n", "    )\n\t    .output(\n\t      z.object({\n\t        methodId: z.string(),\n\t        userCreated: z.boolean(),\n\t      }),\n\t    )\n\t    .mutation(async ({ input, ctx }) => {\n\t      try {\n\t        // 1. Login or create the user in Stytch. If the user has been seen before, a vanilla login will be performed, if they\n", "        // haven't been seen before, a signup email will be sent and a new Stytch User will be created.\n\t        const loginOrCreateResponse = await ctx.stytch.otps.email.loginOrCreate({\n\t          email: input.email,\n\t          create_user_as_pending: true,\n\t        });\n\t        // 2. Create the user in your Prisma database.\n\t        //\n\t        // Because Stytch auth lives in your backend, you can perform all of your\n\t        // normal business logic in sync with your authentication, e.g. syncing your user DB, adding the user to a mailing list,\n\t        // or provisioning them a Stripe customer, etc.\n", "        //\n\t        // If you're coming from Auth0, you might have Rules, Hooks, or Actions that perform this logic. With Stytch, there is\n\t        // no need for this logic to live outside of your codebase separate from your backend.\n\t        if (loginOrCreateResponse.user_created) {\n\t          await ctx.prisma.user.create({ data: { stytchUserId: loginOrCreateResponse.user_id } });\n\t        }\n\t        return {\n\t          // The method_id is used during the OTP Authenticate step to ensure the OTP code belongs to the user who initiated the\n\t          // the login flow.\n\t          methodId: loginOrCreateResponse.email_id,\n", "          // The user_created flag is used to determine if the user was created during this login flow. This is useful for\n\t          // determining if you should show a welcome message, or take some other action, for new vs. existing users.\n\t          userCreated: loginOrCreateResponse.user_created,\n\t        };\n\t      } catch (err) {\n\t        if (err instanceof StytchError) {\n\t          throw new TRPCError({ code: 'BAD_REQUEST', message: err.error_message, cause: err });\n\t        }\n\t        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', cause: err });\n\t      }\n", "    }),\n\t  // This route is used to send an SMS OTP to a user.\n\t  loginSms: publicProcedure\n\t    .input(\n\t      z.object({\n\t        phone: z.string().regex(VALID_PHONE_NUMBER, 'Invalid phone number').min(1, 'Phone number is required'),\n\t      }),\n\t    )\n\t    .output(\n\t      z.object({\n", "        methodId: z.string(),\n\t        userCreated: z.boolean(),\n\t      }),\n\t    )\n\t    .mutation(async ({ input, ctx }) => {\n\t      const phoneNumber = parsePhoneNumber(input.phone);\n\t      if (!phoneNumber?.country || !STYTCH_SUPPORTED_SMS_COUNTRIES.includes(phoneNumber.country)) {\n\t        throw new TRPCError({\n\t          code: 'BAD_REQUEST',\n\t          message: `Sorry, we don't support sms login for your country yet.`,\n", "        });\n\t      }\n\t      try {\n\t        // 1. Login or create the user in Stytch. If the user has been seen before, a vanilla login will be performed, if they\n\t        // haven't been seen before, an SMS will be sent and a new Stytch User will be created.\n\t        const loginOrCreateResponse = await ctx.stytch.otps.sms.loginOrCreate({\n\t          phone_number: input.phone,\n\t          create_user_as_pending: true,\n\t        });\n\t        // 2. Create the user in your Prisma database.\n", "        //\n\t        // Because Stytch auth lives in your backend, you can perform all of your\n\t        // normal business logic in sync with your authentication, e.g. syncing your user DB, adding the user to a mailing list,\n\t        // or provisioning them a Stripe customer, etc.\n\t        //\n\t        // If you're coming from Auth0, you might have Rules, Hooks, or Actions that perform this logic. With Stytch, there is\n\t        // no need for this logic to live outside of your codebase separate from your backend.\n\t        if (loginOrCreateResponse.user_created) {\n\t          await ctx.prisma.user.create({ data: { stytchUserId: loginOrCreateResponse.user_id } });\n\t        }\n", "        return {\n\t          // The method_id is used during the OTP Authenticate step to ensure the OTP code belongs to the user who initiated the\n\t          // the login flow.\n\t          methodId: loginOrCreateResponse.phone_id,\n\t          // The user_created flag is used to determine if the user was created during this login flow. This is useful for\n\t          // determining if you should show a welcome message, or take some other action, for new vs. existing users.\n\t          userCreated: loginOrCreateResponse.user_created,\n\t        };\n\t      } catch (err) {\n\t        if (err instanceof StytchError) {\n", "          throw new TRPCError({ code: 'BAD_REQUEST', message: err.error_message, cause: err });\n\t        }\n\t        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', cause: err });\n\t      }\n\t    }),\n\t  // This route handles authenticating an OTP as input by the user and adding custom claims to their resulting session.\n\t  authenticateOtp: publicProcedure\n\t    .input(\n\t      z.object({\n\t        code: z.string().length(6, 'OTP must be 6 digits'),\n", "        methodId: z.string(),\n\t      }),\n\t    )\n\t    .output(\n\t      z.object({\n\t        id: z.string(),\n\t      }),\n\t    )\n\t    .mutation(async ({ input, ctx }) => {\n\t      try {\n", "        // 1. OTP Authenticate step; here we'll validate that the OTP + Method (phone_id or email_id) are valid and belong to\n\t        // the same user who initiated the login flow.\n\t        const authenticateResponse = await ctx.stytch.otps.authenticate({\n\t          code: input.code,\n\t          method_id: input.methodId,\n\t          session_duration_minutes: SESSION_DURATION_MINUTES,\n\t        });\n\t        // 2. Get the user from your Prisma database.\n\t        //\n\t        // Here you could also include any other business logic, e.g. firing logs in your own stack, on successful completion of the login flow.\n", "        const dbUser = await ctx.prisma.user.findUniqueOrThrow({\n\t          where: { stytchUserId: authenticateResponse.user.user_id },\n\t          select: {\n\t            id: true,\n\t          },\n\t        });\n\t        // Examples of business logic you might want to include on successful user creation:\n\t        //\n\t        // Create a Stripe customer for the user.\n\t        // await ctx.stripe.customers.create({ name: authenticateResponse.user.name.first_name });\n", "        //\n\t        // Subscribe the user to a mailing list.\n\t        // await ctx.mailchimp.lists.addListMember(\"list_id\", { email_address: authenticateResponse.user.emails[0].email, status: \"subscribed\" });\n\t        // 3. Optional: Add custom claims to the session. These claims will be available in the JWT returned by Stytch.\n\t        // \n\t        // Alternatively this can also be accomplished via a custom JWT template set in the Stytch Dashboard if there are values you want on \n\t        // all JWTs issued for your sessions.\n\t        const sessionResponse = await ctx.stytch.sessions.authenticate({\n\t          // Here we add the Prisma user ID to the session as a custom claim.\n\t          session_custom_claims: { db_user_id: dbUser.id },\n", "          session_jwt: authenticateResponse.session_jwt,\n\t          session_duration_minutes: SESSION_DURATION_MINUTES,\n\t        });\n\t        // 4. Set the session JWT as a cookie in the user's browser.\n\t        setCookie('session_jwt', sessionResponse.session_jwt, {\n\t          req: ctx.req,\n\t          res: ctx.res,\n\t          httpOnly: true,\n\t          maxAge: SESSION_DURATION_SECONDS,\n\t          secure: process.env.NODE_ENV === 'production',\n", "          sameSite: 'strict',\n\t        });\n\t        return {\n\t          id: dbUser.id,\n\t        };\n\t      } catch (err) {\n\t        if (err instanceof StytchError) {\n\t          throw new TRPCError({ code: 'BAD_REQUEST', message: err.error_message, cause: err });\n\t        }\n\t        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', cause: err });\n", "      }\n\t    }),\n\t  // This route logs a user out of their session by revoking it with Stytch. \n\t  //\n\t  // Note, because JWTs are valid for their lifetime (here we've set it to 30 days), the JWT would still\n\t  // locally parse, i.e. using an open source JWT parsing library, as valid. We always encourage you to\n\t  // authenticate a session with Stytch's API directly to ensure that it is still valid.\n\t  logout: protectedProcedure.mutation(async ({ ctx }) => {\n\t    await ctx.stytch.sessions.revoke({ session_id: ctx.session.session_id });\n\t    deleteCookie('session_jwt', { req: ctx.req, res: ctx.res });\n", "    return { success: true };\n\t  }),\n\t});\n"]}
{"filename": "src/server/routers/_app.ts", "chunked_list": ["import { type inferRouterInputs, type inferRouterOutputs } from '@trpc/server';\n\timport { router } from '~/server/trpc';\n\timport { authRouter } from './auth';\n\timport { userRouter } from './user';\n\texport const appRouter = router({\n\t  auth: authRouter,\n\t  user: userRouter,\n\t});\n\texport type AppRouter = typeof appRouter;\n\texport type RouterInput = inferRouterInputs<AppRouter>;\n", "export type RouterOutput = inferRouterOutputs<AppRouter>;\n"]}
{"filename": "src/server/routers/user.ts", "chunked_list": ["import { publicProcedure, router } from '~/server/trpc';\n\texport const userRouter = router({\n\t  // This route fetches the current, logged-in user.\n\t  current: publicProcedure.query(async ({ ctx }) => {\n\t    const session = ctx.session;\n\t    if (!session) return null;\n\t    const [stytchUser, dbUser] = await Promise.all([\n\t      ctx.stytch.users.get(session.user_id),\n\t      ctx.prisma.user.findUniqueOrThrow({\n\t        where: { id: session.custom_claims.db_user_id },\n", "        select: {\n\t          id: true,\n\t        },\n\t      }),\n\t    ]);\n\t    return {\n\t      id: dbUser.id,\n\t      stytch_user_id: stytchUser.user_id,\n\t      emails: stytchUser.emails,\n\t      phoneNumbers: stytchUser.phone_numbers,\n", "      status: stytchUser.status,\n\t    };\n\t  }),\n\t});\n"]}
{"filename": "src/types/stytch.ts", "chunked_list": ["import { type Session } from 'stytch/types/lib/b2c/shared_b2c';\n\texport type StytchAuthMethods = 'otp_email' | 'otp_sms';\n\texport type StytchCustomClaims = {\n\t  db_user_id: string;\n\t};\n\texport interface StytchSessionWithCustomClaims extends Session {\n\t  custom_claims: StytchCustomClaims;\n\t}\n"]}
