{"filename": "vite.config.ts", "chunked_list": ["import path from \"path\";\n\timport { defineConfig } from \"vite\";\n\timport packageJson from \"./package.json\";\n\tconst getPackageName = () => {\n\t  return packageJson.name;\n\t};\n\tconst getPackageNameCamelCase = () => {\n\t  try {\n\t    return getPackageName().replace(/-./g, (char) => char[1].toUpperCase());\n\t  } catch (err) {\n", "    throw new Error(\"Name property in package.json is missing.\");\n\t  }\n\t};\n\tconst fileName = {\n\t  es: `${getPackageName()}.mjs`,\n\t  cjs: `${getPackageName()}.cjs`,\n\t  iife: `${getPackageName()}.iife.js`,\n\t};\n\tconst formats = Object.keys(fileName) as Array<keyof typeof fileName>;\n\tmodule.exports = defineConfig({\n", "  base: \"./\",\n\t  build: {\n\t    lib: {\n\t      entry: path.resolve(__dirname, \"src/index.ts\"),\n\t      name: getPackageNameCamelCase(),\n\t      formats,\n\t      fileName: (format) => fileName[format],\n\t    },\n\t  },\n\t});\n"]}
{"filename": "test/string.test.ts", "chunked_list": ["import { describe, it, expect } from \"vitest\"\n\timport * as String from \"../src/string\"\n\timport { pipe } from \"../src/Composition\"\n\tdescribe(\"String\", () => {\n\t    describe(\"isEmpty\", () => {\n\t        it.each([\n\t            [true, \"\"],\n\t            [false, \"something\"],\n\t        ])(\"returns %o when given %s\", (expected, inp) => {\n\t            expect(String.isEmpty(inp)).toBe(expected)\n", "        })\n\t    })\n\t    describe(\"trim\", () => {\n\t        it(\"trims\", () => {\n\t            expect(String.trim(\"  abc \")).toBe(\"abc\")\n\t        })\n\t    })\n\t    describe(\"toLowerCase\", () => {\n\t        it(\"lower-cases\", () => {\n\t            expect(String.toLowerCase(\"AAbdF\")).toBe(\"aabdf\")\n", "        })\n\t    })\n\t    describe(\"toUpperCase\", () => {\n\t        it(\"upper-cases\", () => {\n\t            expect(String.toUpperCase(\"Dogs\")).toBe(\"DOGS\")\n\t        })\n\t    })\n\t    describe(\"isString\", () => {\n\t        it.each([\n\t            [true, \"\"],\n", "            [true, \"   \"],\n\t            [true, \"  addc \"],\n\t            [true, \"cheese\"],\n\t            [false, null],\n\t            [false, undefined],\n\t            [false, {}],\n\t            [false, 42],\n\t        ])(\"returns %o when given %o\", (expected, inp) => {\n\t            expect(String.isString(inp)).toBe(expected)\n\t        })\n", "    })\n\t    describe(\"length\", () => {\n\t        it(\"returns the length\", () => {\n\t            expect(String.length(\"cheese\")).toBe(6)\n\t        })\n\t    })\n\t    describe(\"split\", () => {\n\t        it(\"splits using a string\", () => {\n\t            expect(pipe(\"C-H-E-D-D-A-R\", String.split(\"-\"))).toStrictEqual([\n\t                \"C\",\n", "                \"H\",\n\t                \"E\",\n\t                \"D\",\n\t                \"D\",\n\t                \"A\",\n\t                \"R\",\n\t            ])\n\t        })\n\t        it(\"splits using a regex\", () => {\n\t            expect(pipe(\"org.url.com\", String.split(/\\./))).toStrictEqual([\n", "                \"org\",\n\t                \"url\",\n\t                \"com\",\n\t            ])\n\t        })\n\t    })\n\t    describe(\"capitalize\", () => {\n\t        it.each([\n\t            [\"\", \"\"],\n\t            [\"cheese\", \"Cheese\"],\n", "            [\"Cheese\", \"Cheese\"],\n\t        ])(\"capitalizes %s -> %s\", (input, expected) => {\n\t            expect(String.capitalize(input)).toBe(expected)\n\t        })\n\t    })\n\t    describe(\"uncapitalize\", () => {\n\t        it.each([\n\t            [\"\", \"\"],\n\t            [\"cheese\", \"cheese\"],\n\t            [\"Cheese\", \"cheese\"],\n", "        ])(\"uncapitalizes %s -> %s\", (input, expected) => {\n\t            expect(String.uncapitalize(input)).toBe(expected)\n\t        })\n\t    })\n\t})\n"]}
{"filename": "test/AsyncResult.test.ts", "chunked_list": ["import { describe, it, expect, vi } from \"vitest\"\n\timport * as AsyncResult from \"../src/AsyncResult\"\n\timport { Async } from \"../src/Async\"\n\timport { Result } from \"../src/Result\"\n\timport { pipe } from \"../src/Composition\"\n\tdescribe(\"AsyncResult\", () => {\n\t    describe(\"constructors\", () => {\n\t        describe(\"Ok\", () => {\n\t            it(\"produces a new Ok\", async () => {\n\t                expect(await pipe(AsyncResult.ok(30), Async.start)).toStrictEqual(\n", "                    Result.ok(30)\n\t                )\n\t            })\n\t        })\n\t        describe(\"Err\", () => {\n\t            it(\"produces a new Err\", async () => {\n\t                expect(await pipe(AsyncResult.err(\"err\"), Async.start)).toStrictEqual(\n\t                    Result.err(\"err\")\n\t                )\n\t            })\n", "        })\n\t    })\n\t    describe(\"map\", () => {\n\t        it(\"projects the inner Ok value\", async () => {\n\t            expect(\n\t                await pipe(\n\t                    AsyncResult.ok(10),\n\t                    AsyncResult.map(n => n + 1),\n\t                    Async.start\n\t                )\n", "            ).toStrictEqual(Result.ok(11))\n\t        })\n\t        it(\"does nothing to an Err\", async () => {\n\t            expect(\n\t                await pipe(\n\t                    AsyncResult.err(10),\n\t                    AsyncResult.map((n: number) => n + 1),\n\t                    Async.start\n\t                )\n\t            ).toStrictEqual(Result.err(10))\n", "        })\n\t    })\n\t    describe(\"mapErr\", () => {\n\t        it(\"projects the inner Err value\", async () => {\n\t            expect(\n\t                await pipe(\n\t                    AsyncResult.err(\"err\"),\n\t                    AsyncResult.mapErr(s => s.length),\n\t                    Async.start\n\t                )\n", "            ).toStrictEqual(Result.err(3))\n\t        })\n\t        it(\"does nothing to an Ok\", async () => {\n\t            expect(\n\t                await pipe(\n\t                    AsyncResult.ok(10),\n\t                    AsyncResult.mapErr((n: number) => n + 1),\n\t                    Async.start\n\t                )\n\t            ).toStrictEqual(Result.ok(10))\n", "        })\n\t    })\n\t    describe(\"mapBoth\", () => {\n\t        it(\"projects the inner Ok value on Ok\", async () => {\n\t            expect(\n\t                await pipe(\n\t                    AsyncResult.ok<number, string>(25),\n\t                    AsyncResult.mapBoth(\n\t                        n => n * 2,\n\t                        s => s.length\n", "                    ),\n\t                    Async.start\n\t                )\n\t            ).toStrictEqual(Result.ok(50))\n\t        })\n\t        it(\"projects the inner Err value on Err\", async () => {\n\t            expect(\n\t                await pipe(\n\t                    AsyncResult.err<string, number>(\"failure\"),\n\t                    AsyncResult.mapBoth(\n", "                        n => n * 2,\n\t                        s => s.length\n\t                    ),\n\t                    Async.start\n\t                )\n\t            ).toStrictEqual(Result.err(7))\n\t        })\n\t    })\n\t    describe(\"bind\", () => {\n\t        it(\"projects the inner Ok value and flattens the result\", async () => {\n", "            // arrange\n\t            const f1 = () => AsyncResult.ok<string, Error>(\"ok\")\n\t            const f2 = (s: string) => AsyncResult.ok<number, Error>(s.length)\n\t            // act\n\t            const actual = await pipe(f1(), AsyncResult.bind(f2), Async.start)\n\t            // assert\n\t            expect(actual).toStrictEqual(Result.ok(2))\n\t        })\n\t        it(\"does nothing to Err values\", async () => {\n\t            // arrange\n", "            const f1 = () => AsyncResult.err<Error, string>(new Error(\"err\"))\n\t            const f2 = (s: string) => AsyncResult.ok<number, Error>(s.length)\n\t            // act\n\t            const actual = await pipe(f1(), AsyncResult.bind(f2), Async.start)\n\t            // assert\n\t            expect(actual).toStrictEqual(Result.err(new Error(\"err\")))\n\t        })\n\t        it(\"returns a flattened Err if the bind projection returns an Err\", async () => {\n\t            // arrange\n\t            const f1 = () => AsyncResult.ok<string, Error>(\"ok\")\n", "            const f2 = (_: string) => AsyncResult.err<Error, number>(new Error(\"err\"))\n\t            // act\n\t            const actual = await pipe(f1(), AsyncResult.bind(f2), Async.start)\n\t            // assert\n\t            expect(actual).toStrictEqual(Result.err(new Error(\"err\")))\n\t        })\n\t    })\n\t    describe(\"bindResult\", () => {\n\t        it(\"projects the inner Ok value and flattens the result\", async () => {\n\t            // arrange\n", "            const f1 = () => AsyncResult.ok<string, Error>(\"ok\")\n\t            const f2 = (s: string) => Result.ok<number, Error>(s.length)\n\t            // act\n\t            const actual = await pipe(f1(), AsyncResult.bindResult(f2), Async.start)\n\t            // assert\n\t            expect(actual).toStrictEqual(Result.ok(2))\n\t        })\n\t        it(\"does nothing to Err values\", async () => {\n\t            // arrange\n\t            const f1 = () => AsyncResult.err<Error, string>(new Error(\"err\"))\n", "            const f2 = (s: string) => Result.ok<number, Error>(s.length)\n\t            // act\n\t            const actual = await pipe(f1(), AsyncResult.bindResult(f2), Async.start)\n\t            // assert\n\t            expect(actual).toStrictEqual(Result.err(new Error(\"err\")))\n\t        })\n\t        it(\"returns a flattened Err if the bind projection returns an Err\", async () => {\n\t            // arrange\n\t            const f1 = () => AsyncResult.ok<string, Error>(\"ok\")\n\t            const f2 = (_: string) => Result.err<Error, number>(new Error(\"err\"))\n", "            // act\n\t            const actual = await pipe(f1(), AsyncResult.bindResult(f2), Async.start)\n\t            // assert\n\t            expect(actual).toStrictEqual(Result.err(new Error(\"err\")))\n\t        })\n\t    })\n\t    describe(\"ofResult\", () => {\n\t        it(\"lifts a result into an AsyncResult\", async () => {\n\t            expect(\n\t                await pipe(Result.err(\"failure\"), AsyncResult.ofResult, Async.start)\n", "            ).toStrictEqual(Result.err(\"failure\"))\n\t        })\n\t    })\n\t    describe(\"ofAsync\", () => {\n\t        it(\"lifts an Async into an AsyncResult\", async () => {\n\t            expect(\n\t                await pipe(Async.of(25), AsyncResult.ofAsync, Async.start)\n\t            ).toStrictEqual(Result.ok(25))\n\t        })\n\t    })\n", "    describe(\"tryCatch\", () => {\n\t        it(\"returns an Ok if the computation does not throw\", async () => {\n\t            // arrange\n\t            const f = Async.of(12)\n\t            // act\n\t            const actual = await pipe(f, AsyncResult.tryCatch, Async.start)\n\t            // assert\n\t            expect(actual).toStrictEqual(Result.ok(12))\n\t        })\n\t        it(\"returns an Err if the computation throws\", async () => {\n", "            // arrange\n\t            // eslint-disable-next-line @typescript-eslint/require-await\n\t            const f = async () => {\n\t                throw new Error(\"failure\")\n\t            }\n\t            // act\n\t            const actual = await pipe(f, AsyncResult.tryCatch, Async.start)\n\t            // assert\n\t            expect(actual).toStrictEqual(Result.err(new Error(\"failure\")))\n\t        })\n", "        it(\"coerces thrown non-error objects to a stringified error by default\", async () => {\n\t            // arrange\n\t            // eslint-disable-next-line @typescript-eslint/require-await\n\t            const f = async () => {\n\t                throw \"failure\"\n\t            }\n\t            // act\n\t            const actual = await pipe(f, AsyncResult.tryCatch, Async.start)\n\t            // assert\n\t            expect(actual).toStrictEqual(Result.err(new Error(\"failure\")))\n", "        })\n\t        it(\"uses the onThrow function if given\", async () => {\n\t            // arrange\n\t            // eslint-disable-next-line @typescript-eslint/require-await\n\t            const f = async (): Promise<number> => {\n\t                throw \"failure\"\n\t            }\n\t            const onThrow = (u: unknown) => ({ err: String(u) })\n\t            // act\n\t            const actual = await pipe(AsyncResult.tryCatch(f, onThrow), Async.start)\n", "            // assert\n\t            expect(actual).toStrictEqual(Result.err({ err: \"failure\" }))\n\t        })\n\t    })\n\t    describe(\"match\", () => {\n\t        it(\"matches Ok using a lambda\", async () => {\n\t            // arrange\n\t            const matcher = {\n\t                ok: (n: number) => n + 100,\n\t                err: (s: string) => s.length,\n", "            }\n\t            // act\n\t            const actual = await pipe(\n\t                AsyncResult.ok<number, string>(10),\n\t                AsyncResult.match(matcher),\n\t                Async.start\n\t            )\n\t            // assert\n\t            expect(actual).toBe(110)\n\t        })\n", "        it(\"matches Ok using a raw value\", async () => {\n\t            // arrange\n\t            const matcher = {\n\t                ok: 99,\n\t                err: (s: string) => s.length,\n\t            }\n\t            // act\n\t            const actual = await pipe(\n\t                AsyncResult.ok<number, string>(10),\n\t                AsyncResult.match(matcher),\n", "                Async.start\n\t            )\n\t            // assert\n\t            expect(actual).toBe(99)\n\t        })\n\t        it(\"matches Err using a lambda\", async () => {\n\t            // arrange\n\t            const matcher = {\n\t                ok: (n: number) => n + 100,\n\t                err: (s: string) => s.length,\n", "            }\n\t            // act\n\t            const actual = await pipe(\n\t                AsyncResult.err<string, number>(\"fail\"),\n\t                AsyncResult.match(matcher),\n\t                Async.start\n\t            )\n\t            // assert\n\t            expect(actual).toBe(4)\n\t        })\n", "        it(\"matches Err using a raw value\", async () => {\n\t            // arrange\n\t            const matcher = {\n\t                ok: \"\",\n\t                err: \"argh!\",\n\t            }\n\t            // act\n\t            const actual = await pipe(\n\t                AsyncResult.err<string, number>(\"\"),\n\t                AsyncResult.match(matcher),\n", "                Async.start\n\t            )\n\t            // assert\n\t            expect(actual).toBe(\"argh!\")\n\t        })\n\t    })\n\t    describe(\"start\", () => {\n\t        it(\"invokes the AsyncResult\", async () => {\n\t            expect(await pipe(AsyncResult.ok(\"A\"), AsyncResult.start)).toStrictEqual(\n\t                Result.ok(\"A\")\n", "            )\n\t        })\n\t    })\n\t    describe(\"tee\", () => {\n\t        it(\"executes the side effect on an Ok value\", async () => {\n\t            const sideEffect = vi.fn<[number], void>()\n\t            const actual = await pipe(\n\t                AsyncResult.ofResult(Result.ok(42)),\n\t                AsyncResult.tee(sideEffect),\n\t                Async.start\n", "            )\n\t            expect(sideEffect).toHaveBeenCalledOnce()\n\t            expect(sideEffect).toHaveBeenCalledWith(42)\n\t            expect(actual).toStrictEqual(Result.ok(42))\n\t        })\n\t        it(\"does not execute the side effect on an Err value\", async () => {\n\t            const sideEffect = vi.fn<[number], void>()\n\t            const actual = await pipe(\n\t                AsyncResult.ofResult(Result.err<string, number>(\"42\")),\n\t                AsyncResult.tee(sideEffect),\n", "                Async.start\n\t            )\n\t            expect(sideEffect).not.toHaveBeenCalled()\n\t            expect(actual).toStrictEqual(Result.err(\"42\"))\n\t        })\n\t    })\n\t    describe(\"teeErr\", () => {\n\t        it(\"executes the side effect on an Err value\", async () => {\n\t            const sideEffect = vi.fn<[number], void>()\n\t            const actual = await pipe(\n", "                AsyncResult.ofResult(Result.err(42)),\n\t                AsyncResult.teeErr(sideEffect),\n\t                Async.start\n\t            )\n\t            expect(sideEffect).toHaveBeenCalledOnce()\n\t            expect(sideEffect).toHaveBeenCalledWith(42)\n\t            expect(actual).toStrictEqual(Result.err(42))\n\t        })\n\t        it(\"does not execute the side effect on an Ok value\", async () => {\n\t            const sideEffect = vi.fn<[number], void>()\n", "            const actual = await pipe(\n\t                AsyncResult.ofResult(Result.ok<string, number>(\"42\")),\n\t                AsyncResult.teeErr(sideEffect),\n\t                Async.start\n\t            )\n\t            expect(sideEffect).not.toHaveBeenCalled()\n\t            expect(actual).toStrictEqual(Result.ok(\"42\"))\n\t        })\n\t    })\n\t})\n"]}
{"filename": "test/Array.test.ts", "chunked_list": ["import { it, describe, expect, vi } from \"vitest\"\n\timport { pipe, flow } from \"../src/Composition\"\n\timport { Option } from \"../src/Option\"\n\timport * as Array from \"../src/Array\"\n\timport { NonEmptyArray } from \"../src/NonEmptyArray\"\n\timport { Result } from \"../src/Result\"\n\timport { String } from \"../src/string\"\n\timport { OrderingComparer } from \"../src/OrderingComparer\"\n\timport { EqualityComparer } from \"../src/EqualityComparer\"\n\tdescribe(\"Array\", () => {\n", "    describe(\"choose\", () => {\n\t        it(\"projects and keeps only the Some results\", () => {\n\t            // arrange\n\t            const arr = [32, null, 55, undefined, 89] as const\n\t            // act\n\t            const actual = pipe(\n\t                arr,\n\t                Array.choose(flow(Option.ofNullish, Option.map(globalThis.String)))\n\t            )\n\t            // assert\n", "            expect(actual).toStrictEqual([\"32\", \"55\", \"89\"])\n\t        })\n\t    })\n\t    describe(\"chooseR\", () => {\n\t        it(\"projects and keeps only the Ok results\", () => {\n\t            // arrange\n\t            const arr = [32, null, 55, undefined, 89] as const\n\t            // act\n\t            const actual = pipe(\n\t                arr,\n", "                Array.chooseR(\n\t                    flow(\n\t                        Option.ofNullish,\n\t                        Option.map(globalThis.String),\n\t                        Result.ofOption(() => \"err\")\n\t                    )\n\t                )\n\t            )\n\t            // assert\n\t            expect(actual).toStrictEqual([\"32\", \"55\", \"89\"])\n", "        })\n\t    })\n\t    describe(\"take\", () => {\n\t        it(\"keeps only the specificed number of values when the array is longer\", () => {\n\t            // arrange\n\t            const arr = [1, 2, 3, 4, 5]\n\t            // act\n\t            const actual = pipe(arr, Array.take(3))\n\t            // assert\n\t            expect(actual).toStrictEqual([1, 2, 3])\n", "        })\n\t        it(\"keeps all the itmes if the array is shorter\", () => {\n\t            // arrange\n\t            const arr = [1, 2]\n\t            // act\n\t            const actual = pipe(arr, Array.take(3))\n\t            // assert\n\t            expect(actual).toStrictEqual(arr)\n\t        })\n\t        it(\"returns empty if array is empty\", () => {\n", "            // act\n\t            const actual = pipe([], Array.take(3))\n\t            // assert\n\t            expect(actual).toStrictEqual([])\n\t        })\n\t        it.each([\n\t            [-1, []],\n\t            [3.22, [1, 2, 3]],\n\t        ])(\"normalizes count to a natural number\", (count, expected) => {\n\t            // act\n", "            const actual = pipe([1, 2, 3, 4, 5], Array.take(count))\n\t            // assert\n\t            expect(actual).toStrictEqual(expected)\n\t        })\n\t    })\n\t    describe(\"skip\", () => {\n\t        it(\"returns all items after the skipped ones if the array is longer\", () => {\n\t            // arrange\n\t            const arr = [1, 2, 3, 4, 5]\n\t            // act\n", "            const actual = pipe(arr, Array.skip(3))\n\t            // asser\n\t            expect(actual).toStrictEqual([4, 5])\n\t        })\n\t        it(\"returns empty if skip count = array length\", () => {\n\t            // arrange\n\t            const arr = [1, 2, 3]\n\t            // act\n\t            const actual = pipe(arr, Array.skip(3))\n\t            // assert\n", "            expect(actual).toStrictEqual([])\n\t        })\n\t        it(\"returns empty if skip count > array length\", () => {\n\t            // arrange\n\t            const arr = [1, 2, 3]\n\t            // act\n\t            const actual = pipe(arr, Array.skip(4))\n\t            // assert\n\t            expect(actual).toStrictEqual([])\n\t        })\n", "        it(\"returns empty if given empty\", () => {\n\t            // act\n\t            const actual = pipe([], Array.skip(3))\n\t            // assert\n\t            expect(actual).toStrictEqual([])\n\t        })\n\t        it.each([\n\t            [-1, [1, 2, 3, 4]],\n\t            [3.22, [4]],\n\t        ])(\"normalizes count to a natural number\", (count, expected) => {\n", "            // act\n\t            const actual = pipe([1, 2, 3, 4], Array.skip(count))\n\t            // assert\n\t            expect(actual).toStrictEqual(expected)\n\t        })\n\t    })\n\t    describe(\"isEmpty\", () => {\n\t        it(\"returns true when the array is empty\", () => {\n\t            expect(Array.isEmpty([])).toBe(true)\n\t        })\n", "        it(\"returns false when the array is not empty\", () => {\n\t            expect(Array.isEmpty([42])).toBe(false)\n\t        })\n\t    })\n\t    describe(\"isNonEmpty\", () => {\n\t        it.each([[[1]], [[1, 2]], [[1, 2, 3]]])(\n\t            \"returns true if the array contains at least one element (%i)\",\n\t            arr => {\n\t                expect(Array.isNonEmpty(arr)).toBe(true)\n\t            }\n", "        )\n\t        it(\"returns false if the array is empty\", () => {\n\t            expect(Array.isNonEmpty([])).toBe(false)\n\t        })\n\t    })\n\t    describe(\"bind\", () => {\n\t        it(\"flat maps\", () => {\n\t            // arrange\n\t            const dupl = <A>(a: A) => [a, a] as const\n\t            const arr = [\"a\", \"b\", \"c\"]\n", "            // act\n\t            const actual = pipe(arr, Array.bind(dupl))\n\t            // assert\n\t            expect(actual).toStrictEqual([\"a\", \"a\", \"b\", \"b\", \"c\", \"c\"])\n\t        })\n\t    })\n\t    describe(\"append\", () => {\n\t        it.each([\n\t            [[], [\"new\"]],\n\t            [[\"old\"], [\"old\", \"new\"]],\n", "        ])(\"adds an element to the end of an array (%i)\", (arr, expected) => {\n\t            expect(pipe(arr, Array.append(\"new\"))).toStrictEqual(expected)\n\t        })\n\t    })\n\t    describe(\"prepend\", () => {\n\t        it.each([\n\t            [[], [\"new\"]],\n\t            [[\"old\"], [\"new\", \"old\"]],\n\t        ])(\"adds an element at the beginning\", (arr, expected) => {\n\t            expect(pipe(arr, Array.prepend(\"new\"))).toStrictEqual(expected)\n", "        })\n\t    })\n\t    describe(\"groupBy\", () => {\n\t        it(\"returns an empty map given an empty array\", () => {\n\t            expect(Array.groupBy(globalThis.String)([])).toStrictEqual(new Map())\n\t        })\n\t        it(\"returns a map of grouped values for a non-empty array\", () => {\n\t            // arrange\n\t            const arr = [\"horse\", \"cow\", \"Cheese\", \"Hampster\", \"fox\"]\n\t            // act\n", "            const actual = pipe(\n\t                arr,\n\t                Array.groupBy(s => s.toLowerCase()[0])\n\t            )\n\t            // assert\n\t            expect(actual).toStrictEqual(\n\t                new Map([\n\t                    [\"h\", [\"horse\", \"Hampster\"]],\n\t                    [\"c\", [\"cow\", \"Cheese\"]],\n\t                    [\"f\", [\"fox\"]],\n", "                ])\n\t            )\n\t        })\n\t    })\n\t    describe(\"concat\", () => {\n\t        it(\"adds the new values at the end of the partially applied values\", () => {\n\t            expect(pipe([\"a\", \"b\"], Array.concat([\"c\", \"d\"]))).toStrictEqual([\n\t                \"a\",\n\t                \"b\",\n\t                \"c\",\n", "                \"d\",\n\t            ])\n\t        })\n\t        it(\"doesn't choke on empty arrays\", () => {\n\t            expect(pipe([], Array.concat([]))).toStrictEqual([])\n\t        })\n\t    })\n\t    describe(\"concatFirst\", () => {\n\t        it(\"adds the new values at the beginning of the partially applied values\", () => {\n\t            expect(pipe([\"a\", \"b\"], Array.concatFirst([\"c\", \"d\"]))).toStrictEqual([\n", "                \"c\",\n\t                \"d\",\n\t                \"a\",\n\t                \"b\",\n\t            ])\n\t        })\n\t        it(\"doesn't choke on empty arrays\", () => {\n\t            expect(pipe([], Array.concatFirst([]))).toStrictEqual([])\n\t        })\n\t    })\n", "    describe(\"match\", () => {\n\t        it(\"can match with lambdas\", () => {\n\t            // arrange\n\t            const matcher = {\n\t                empty: () => 42,\n\t                nonEmpty: NonEmptyArray.head,\n\t            }\n\t            // act\n\t            const actual1 = pipe([], Array.match(matcher))\n\t            const actual2 = pipe([23, 35], Array.match(matcher))\n", "            // assert\n\t            expect(actual1).toBe(42)\n\t            expect(actual2).toBe(23)\n\t        })\n\t        it(\"can match with raw values\", () => {\n\t            // arrange\n\t            const matcher = {\n\t                empty: 42,\n\t                nonEmpty: 24,\n\t            }\n", "            // act\n\t            const actual1 = pipe([], Array.match(matcher))\n\t            const actual2 = pipe([23, 35], Array.match(matcher))\n\t            // assert\n\t            expect(actual1).toBe(42)\n\t            expect(actual2).toBe(24)\n\t        })\n\t        it(\"can accepts nullish matcher values\", () => {\n\t            // arrange\n\t            const matcher = {\n", "                empty: null,\n\t                nonEmpty: undefined,\n\t            }\n\t            // act\n\t            const actual1 = pipe([], Array.match(matcher))\n\t            const actual2 = pipe([23, 35], Array.match(matcher))\n\t            // assert\n\t            expect(actual1).toBe(null)\n\t            expect(actual2).toBe(undefined)\n\t        })\n", "    })\n\t    describe(\"head\", () => {\n\t        it(\"returns Some if non-empty\", () => {\n\t            expect(Array.head([1, 2])).toStrictEqual(Option.some(1))\n\t        })\n\t        it(\"returns None if empty\", () => {\n\t            expect(Array.head([])).toStrictEqual(Option.none)\n\t        })\n\t    })\n\t    describe(\"tail\", () => {\n", "        it(\"returns `Some` with empty if array is singleton\", () => {\n\t            expect(Array.tail([1])).toStrictEqual(Option.some([]))\n\t        })\n\t        it(\"returns `Some` with the remaining elements if array.length > 1\", () => {\n\t            expect(Array.tail([1, 2, 3])).toStrictEqual(Option.some([2, 3]))\n\t        })\n\t        it(\"returns `None` if the array is empty\", () => {\n\t            expect(Array.tail([])).toStrictEqual(Option.none)\n\t        })\n\t    })\n", "    describe(\"chunk\", () => {\n\t        it(\"returns empty for an empty array\", () => {\n\t            expect(Array.chunk(1)([])).toStrictEqual([])\n\t        })\n\t        it(\"returns even chunks if the array is evenly divisible by the chunk size\", () => {\n\t            expect(pipe([1, 2, 3, 4, 5, 6, 7, 8, 9], Array.chunk(3))).toStrictEqual([\n\t                [1, 2, 3],\n\t                [4, 5, 6],\n\t                [7, 8, 9],\n\t            ])\n", "        })\n\t        it(\"returns uneven chunks if the array is not evenly divisible by the chunk size\", () => {\n\t            expect(pipe([\"a\", \"b\", \"c\", \"d\", \"e\"], Array.chunk(2))).toStrictEqual([\n\t                [\"a\", \"b\"],\n\t                [\"c\", \"d\"],\n\t                [\"e\"],\n\t            ])\n\t        })\n\t        it(\"works for very large arrays when the array is evenly divisible by the chunk size\", () => {\n\t            // act\n", "            const actual = pipe(NonEmptyArray.range(1, 10_000), Array.chunk(40))\n\t            // assert\n\t            expect(actual).toHaveLength(250)\n\t            expect(actual.every(arr => arr.length === 40)).toBe(true)\n\t        })\n\t        it(\"works for very large arrays when the array is not evenly divisible by the chunk size\", () => {\n\t            // act\n\t            const actual = pipe(NonEmptyArray.range(1, 11_111), Array.chunk(27))\n\t            // assert\n\t            expect(actual).toHaveLength(412)\n", "            expect(\n\t                actual.every(\n\t                    (arr, i) =>\n\t                        i === 411\n\t                            ? arr.length === 14 // the last chunk only has 14 elements\n\t                            : arr.length === 27 // all other chunks have exactly 27 elements\n\t                )\n\t            )\n\t        })\n\t        it.each([[-50], [0], [0.1442], [1.77]])(\n", "            \"normalizes the chunk size (%o) to a natural number\",\n\t            size => {\n\t                expect(pipe([1, 2, 3], Array.chunk(size))).toStrictEqual([[1], [2], [3]])\n\t            }\n\t        )\n\t        it.each([[1], [20], [100]])(\n\t            \"works for a singleton regardless of chunk size (%o)\",\n\t            size => {\n\t                expect(pipe([1], Array.chunk(size))).toStrictEqual([[1]])\n\t            }\n", "        )\n\t    })\n\t    describe(\"contains\", () => {\n\t        it(\"returns true if the element is in the array (using default === equality)\", () => {\n\t            expect(pipe([1, 2, 3, 4], Array.contains(2))).toBe(true)\n\t        })\n\t        it(\"returns false if the element is not in the array (using default === equality)\", () => {\n\t            expect(pipe([1, 2, 3, 4], Array.contains(5))).toBe(false)\n\t        })\n\t        it(\n", "            \"returns false if a structurally equivalent element is in the array, \" +\n\t                \"but is not reference equal (using default === equality)\",\n\t            () => {\n\t                // arrange\n\t                const as = [{ name: \"john\" }, { name: \"jingleheimer\" }, { name: \"smith\" }]\n\t                // act\n\t                const actual = Array.contains({ name: \"john\" })(as)\n\t                // assert\n\t                expect(actual).toBe(false)\n\t            }\n", "        )\n\t        it(\"returns true if the element is in the array (using EqualityComparer)\", () => {\n\t            // arrange\n\t            type Person = { name: string }\n\t            const as = [{ name: \"john\" }, { name: \"jingleheimer\" }, { name: \"smith\" }]\n\t            const equalityComparer = {\n\t                equals: ({ name: name1 }: Person, { name: name2 }: Person) =>\n\t                    name1 === name2,\n\t            }\n\t            // act\n", "            const actual = Array.contains({ name: \"smith\" }, equalityComparer)(as)\n\t            // assert\n\t            expect(actual).toBe(true)\n\t        })\n\t        it(\"returns false if the element is not in the array (using EqualityComparer)\", () => {\n\t            // arrange\n\t            type Person = { name: string }\n\t            const as = [{ name: \"john\" }, { name: \"jingleheimer\" }, { name: \"smith\" }]\n\t            const equalityComparer = {\n\t                equals: ({ name: name1 }: Person, { name: name2 }: Person) =>\n", "                    name1 === name2,\n\t            }\n\t            // act\n\t            const actual = Array.contains({ name: \"joe\" }, equalityComparer)(as)\n\t            // assert\n\t            expect(actual).toBe(false)\n\t        })\n\t    })\n\t    describe(\"length\", () => {\n\t        it.each([\n", "            [[], 0],\n\t            [[1, 2], 2],\n\t            [[\"a\", \"b\", \"c\", \"d\"], 4],\n\t        ])(\n\t            \"returns the length of the array\",\n\t            (arr: readonly (string | number)[], expected) => {\n\t                expect(Array.length(arr)).toBe(expected)\n\t            }\n\t        )\n\t    })\n", "    describe(\"uniq\", () => {\n\t        it(\"returns empty for an empty array\", () => {\n\t            expect(Array.uniq()([])).toStrictEqual([])\n\t        })\n\t        it(\"returns unique values (using default triple equals equality)\", () => {\n\t            expect(\n\t                pipe(\n\t                    [\"a\", \"b\", \"b\", \"a\", \"c\", \"d\", \"e\", \"e\", \"e\", \"a\", \"z\"],\n\t                    Array.uniq()\n\t                )\n", "            ).toStrictEqual([\"a\", \"b\", \"c\", \"d\", \"e\", \"z\"])\n\t        })\n\t        it(\"does not work for objects without an equality comparer\", () => {\n\t            expect(\n\t                pipe(\n\t                    [{ name: \"John\" }, { name: \"John\" }, { name: \"Larry\" }],\n\t                    Array.uniq()\n\t                )\n\t            ).toStrictEqual([{ name: \"John\" }, { name: \"John\" }, { name: \"Larry\" }])\n\t        })\n", "        it(\"returns uniq elements using the equality comparer if given\", () => {\n\t            // arrange\n\t            type Person = { name: string }\n\t            const people = [\n\t                { name: \"John\" },\n\t                { name: \"John\" },\n\t                { name: \"Larry\" },\n\t                { name: \"Jeff\" },\n\t                { name: \"Larry\" },\n\t            ]\n", "            const equalityComparer = {\n\t                equals: ({ name: name1 }: Person, { name: name2 }: Person) =>\n\t                    name1 === name2,\n\t            }\n\t            // act\n\t            const actual = Array.uniq(equalityComparer)(people)\n\t            // assert\n\t            expect(actual).toStrictEqual([\n\t                { name: \"John\" },\n\t                { name: \"Larry\" },\n", "                { name: \"Jeff\" },\n\t            ])\n\t        })\n\t    })\n\t    describe(\"uniqBy\", () => {\n\t        it(\"returns empty for an empty array\", () => {\n\t            expect(Array.uniqBy((n: number) => n * 1)([])).toStrictEqual([])\n\t        })\n\t        it(\"returns un-projected unique values based on the projected values (using default triple equals equality)\", () => {\n\t            expect(\n", "                pipe(\n\t                    [\"a\", \"b\", \"b\", \"a\", \"c\", \"d\", \"e\", \"e\", \"e\", \"a\", \"z\"],\n\t                    Array.uniqBy(String.toUpperCase)\n\t                )\n\t            ).toStrictEqual([\"a\", \"b\", \"c\", \"d\", \"e\", \"z\"])\n\t        })\n\t        it(\"does not work for projected objects without an equality comparer\", () => {\n\t            expect(\n\t                pipe(\n\t                    [\n", "                        { name: { first: \"John\" } },\n\t                        { name: { first: \"John\" } },\n\t                        { name: { first: \"Larry\" } },\n\t                    ],\n\t                    Array.uniqBy(p => p.name)\n\t                )\n\t            ).toStrictEqual([\n\t                { name: { first: \"John\" } },\n\t                { name: { first: \"John\" } },\n\t                { name: { first: \"Larry\" } },\n", "            ])\n\t        })\n\t        it(\"returns unique un-projected elements using the equality comparer against the projected elements if given\", () => {\n\t            // arrange\n\t            type Person = { name: { first: string } }\n\t            const people: Person[] = [\n\t                { name: { first: \"John\" } },\n\t                { name: { first: \"John\" } },\n\t                { name: { first: \"Larry\" } },\n\t                { name: { first: \"Jeff\" } },\n", "                { name: { first: \"Larry\" } },\n\t            ]\n\t            const equalityComparer = {\n\t                equals: (n1: { first: string }, n2: { first: string }) =>\n\t                    n1.first === n2.first,\n\t            }\n\t            // act\n\t            const actual = pipe(\n\t                people,\n\t                Array.uniqBy(p => p.name, equalityComparer)\n", "            )\n\t            // assert\n\t            expect(actual).toStrictEqual([\n\t                { name: { first: \"John\" } },\n\t                { name: { first: \"Larry\" } },\n\t                { name: { first: \"Jeff\" } },\n\t            ])\n\t        })\n\t    })\n\t    describe(\"find\", () => {\n", "        it(\"returns Some(first elem) if the element exists\", () => {\n\t            expect(\n\t                pipe(\n\t                    [1, 2, 3, 4, 5],\n\t                    Array.find(n => n % 2 === 0)\n\t                )\n\t            ).toStrictEqual(Option.some(2))\n\t        })\n\t        it(\"returns None if the element does not exist\", () => {\n\t            expect(\n", "                pipe(\n\t                    [1, 2, 3, 4, 5],\n\t                    Array.find(n => n < 0)\n\t                )\n\t            ).toStrictEqual(Option.none)\n\t        })\n\t    })\n\t    describe(\"findIndex\", () => {\n\t        it(\"returns Some(first index) if the element exists\", () => {\n\t            expect(\n", "                pipe(\n\t                    [1, 2, 3, 4, 5],\n\t                    Array.findIndex(n => n % 2 === 0)\n\t                )\n\t            ).toStrictEqual(Option.some(1))\n\t        })\n\t        it(\"returns None if the element does not exist\", () => {\n\t            expect(\n\t                pipe(\n\t                    [1, 2, 3, 4, 5],\n", "                    Array.find(n => n < 0)\n\t                )\n\t            ).toStrictEqual(Option.none)\n\t        })\n\t    })\n\t    describe(\"reverse\", () => {\n\t        it(\"returns a new, reversed array\", () => {\n\t            // arrange\n\t            const arr = [\"a\", \"b\", \"c\", \"d\"]\n\t            // act\n", "            const actual = Array.reverse(arr)\n\t            // assert\n\t            expect(actual).toStrictEqual([\"d\", \"c\", \"b\", \"a\"])\n\t            expect(actual).not.toBe(arr)\n\t        })\n\t    })\n\t    describe(\"exists\", () => {\n\t        it(\"returns true if an element satisfies the predicate\", () => {\n\t            expect(\n\t                pipe(\n", "                    [1, 5, 10, 15],\n\t                    Array.exists(n => n > 10)\n\t                )\n\t            ).toBe(true)\n\t        })\n\t        it(\"returns false if no element satisfies the predicate\", () => {\n\t            expect(\n\t                pipe(\n\t                    [1, 5, 10, 15],\n\t                    Array.exists(n => n < 1)\n", "                )\n\t            ).toBe(false)\n\t        })\n\t    })\n\t    describe(\"flatten\", () => {\n\t        it(\"flattens a nested array\", () => {\n\t            expect(pipe([[1, 2], [3, 4], [5], [6], []], Array.flatten)).toStrictEqual([\n\t                1, 2, 3, 4, 5, 6,\n\t            ])\n\t        })\n", "    })\n\t    describe(\"sort\", () => {\n\t        it(\"returns empty for an empty array\", () => {\n\t            expect(Array.sort()([])).toStrictEqual([])\n\t        })\n\t        it(\"sorts an array using default ASCII sort order if no comparer is given\", () => {\n\t            expect(\n\t                pipe([\"Beto\", \"Alfred\", \"Drake\", \"Jimbo\"], Array.sort())\n\t            ).toStrictEqual([\"Alfred\", \"Beto\", \"Drake\", \"Jimbo\"])\n\t        })\n", "        it(\"sorts an array using the custom comparer if one is given\", () => {\n\t            const descNumberOrd: OrderingComparer<number> = {\n\t                compare(n1: number, n2: number) {\n\t                    return n1 === n2 ? 0 : n1 < n2 ? 1 : -1\n\t                },\n\t            }\n\t            expect(pipe([33, 22, 78], Array.sort(descNumberOrd))).toStrictEqual([\n\t                78, 33, 22,\n\t            ])\n\t        })\n", "    })\n\t    describe(\"sortBy\", () => {\n\t        it(\"returns empty for empty array\", () => {\n\t            expect(Array.sortBy((n: number) => n.toString())([])).toStrictEqual([])\n\t        })\n\t        it(\"sorts an array using the projected values, using default comparison\", () => {\n\t            expect(\n\t                pipe(\n\t                    [\n\t                        { name: \"Rex\" },\n", "                        { name: \"Fido\" },\n\t                        { name: \"Gerald\" },\n\t                        { name: \"Albus\" },\n\t                    ],\n\t                    Array.sortBy(pet => pet.name)\n\t                )\n\t            ).toStrictEqual([\n\t                { name: \"Albus\" },\n\t                { name: \"Fido\" },\n\t                { name: \"Gerald\" },\n", "                { name: \"Rex\" },\n\t            ])\n\t        })\n\t        it(\"sorts an array using the projected values, using the given comparer if provided\", () => {\n\t            const descNumberOrd: OrderingComparer<number> = {\n\t                compare(n1, n2) {\n\t                    return n1 === n2 ? 0 : n1 < n2 ? 1 : -1\n\t                },\n\t            }\n\t            expect(\n", "                pipe(\n\t                    [{ age: 16 }, { age: 2 }, { age: 8 }, { age: 9 }],\n\t                    Array.sortBy(pet => pet.age, descNumberOrd)\n\t                )\n\t            ).toStrictEqual([{ age: 16 }, { age: 9 }, { age: 8 }, { age: 2 }])\n\t        })\n\t    })\n\t    describe(\"except\", () => {\n\t        it(\"returns empty if the given array is empty\", () => {\n\t            expect(pipe([], Array.except([1, 2, 3]))).toStrictEqual([])\n", "        })\n\t        it(\"returns the given array if the excludeThese array is empty\", () => {\n\t            expect(pipe([1, 2, 3], Array.except<number>([]))).toStrictEqual([1, 2, 3])\n\t        })\n\t        it(\"returns an array with excluded elements\", () => {\n\t            expect(\n\t                pipe([1, 3, 3, 5, 6, 7, 9, 11], Array.except([5, 9, 11, 9]))\n\t            ).toStrictEqual([1, 3, 3, 6, 7])\n\t        })\n\t    })\n", "    describe(\"union\", () => {\n\t        it(\"returns empty if both arrays are empty\", () => {\n\t            expect(pipe([], Array.union([]))).toStrictEqual([])\n\t        })\n\t        it(\"returns the set union of two populated arrays, using default equality\", () => {\n\t            expect(\n\t                pipe([1, 2, 7, 8, 8, 14], Array.union([3, 2, 8, 14, 5]))\n\t            ).toStrictEqual([1, 2, 7, 8, 14, 3, 5])\n\t        })\n\t        it(\"uses the equality comparer if given\", () => {\n", "            const petEq = {\n\t                equals(\n\t                    { name: name1 }: { name: string },\n\t                    { name: name2 }: { name: string }\n\t                ) {\n\t                    return name1 === name2\n\t                },\n\t            }\n\t            expect(\n\t                pipe(\n", "                    [\n\t                        { name: \"Fido\" },\n\t                        { name: \"Rufus\" },\n\t                        { name: \"Rufus\" },\n\t                        { name: \"Albus\" },\n\t                    ],\n\t                    Array.union(\n\t                        [\n\t                            { name: \"Johan\" },\n\t                            { name: \"Rufus\" },\n", "                            { name: \"Albus\" },\n\t                            { name: \"Scrappy\" },\n\t                        ],\n\t                        petEq\n\t                    )\n\t                )\n\t            ).toStrictEqual([\n\t                { name: \"Fido\" },\n\t                { name: \"Rufus\" },\n\t                { name: \"Albus\" },\n", "                { name: \"Johan\" },\n\t                { name: \"Scrappy\" },\n\t            ])\n\t        })\n\t    })\n\t    describe(\"filter\", () => {\n\t        it(\"filters\", () => {\n\t            expect(\n\t                pipe(\n\t                    [1, 2, 3, 4, 5, 6, 7, 8, 9],\n", "                    Array.filter(n => n % 2 === 0)\n\t                )\n\t            ).toStrictEqual([2, 4, 6, 8])\n\t        })\n\t    })\n\t    describe(\"filteri\", () => {\n\t        it(\"filters with index\", () => {\n\t            expect(\n\t                pipe(\n\t                    [2, 1, 3, 4, 5, 7, 6, 8, 9, 10],\n", "                    Array.filteri((n, i) => n % 2 !== 0 && i % 2 === 0)\n\t                )\n\t            ).toStrictEqual([3, 5, 9])\n\t        })\n\t    })\n\t    describe(\"map\", () => {\n\t        it(\"maps\", () => {\n\t            expect(\n\t                pipe([\"a\", \"ab\", \"abc\", \"abcd\"], Array.map(String.length))\n\t            ).toStrictEqual([1, 2, 3, 4])\n", "        })\n\t    })\n\t    describe(\"mapi\", () => {\n\t        it(\"maps with index\", () => {\n\t            expect(\n\t                pipe(\n\t                    [\"a\", \"ab\", \"abc\", \"abcd\"],\n\t                    Array.mapi((s, i) => s.length + i)\n\t                )\n\t            ).toStrictEqual([1, 3, 5, 7])\n", "        })\n\t    })\n\t    describe(\"reduce\", () => {\n\t        it(\"reduces\", () => {\n\t            expect(\n\t                pipe(\n\t                    [1, 2, 3, 4, 5],\n\t                    Array.reduce(0, (a, b) => a + b)\n\t                )\n\t            ).toBe(15)\n", "        })\n\t    })\n\t    describe(\"reduceRight\", () => {\n\t        it(\"reduces from the right\", () => {\n\t            expect(\n\t                pipe(\n\t                    [\"a\", \"b\", \"c\", \"d\"],\n\t                    Array.reduceRight(\"\", (a, b) => `${a}${b}`)\n\t                )\n\t            ).toBe(\"dcba\")\n", "        })\n\t    })\n\t    describe(\"getEqualityComparer\", () => {\n\t        it(\"always returns true if the arrays are both empty\", () => {\n\t            const { equals } = Array.getEqualityComparer(EqualityComparer.Number)\n\t            expect(equals([], [])).toBe(true)\n\t        })\n\t        it(\"always returns false if the arrays are different lengths\", () => {\n\t            const { equals } = Array.getEqualityComparer(EqualityComparer.Number)\n\t            expect(equals([1, 2, 3], [1, 2])).toBe(false)\n", "        })\n\t        it(\"returns false if the arrays are not equal element-by-element\", () => {\n\t            const { equals } = Array.getEqualityComparer(EqualityComparer.Number)\n\t            expect(equals([1, 2, 3], [1, 3, 2])).toBe(false)\n\t        })\n\t        it(\"returns true if the arrays are equal element-by-element\", () => {\n\t            const { equals } = Array.getEqualityComparer(EqualityComparer.Number)\n\t            expect(equals([1, 2, 3], [1, 2, 3])).toBe(true)\n\t        })\n\t    })\n", "    describe(\"iter\", () => {\n\t        it(\"executes a function for each element of the array\", () => {\n\t            const sideEffect = vi.fn<[], void>()\n\t            pipe(NonEmptyArray.range(1, 5), Array.iter(sideEffect))\n\t            expect(sideEffect).toHaveBeenCalledTimes(5)\n\t            NonEmptyArray.range(1, 5).forEach(n => {\n\t                expect(sideEffect).toHaveBeenCalledWith(n)\n\t            })\n\t        })\n\t    })\n", "})\n"]}
{"filename": "test/Option.test.ts", "chunked_list": ["import { describe, it, expect, vi } from \"vitest\"\n\timport * as Option from \"../src/Option\"\n\timport { pipe } from \"../src/Composition\"\n\timport { EqualityComparer } from \"../src/EqualityComparer\"\n\timport { NonNullish } from \"../src/prelude\"\n\ttype Option<A extends NonNullish> = Option.Option<A>\n\tdescribe(\"Option\", () => {\n\t    describe(\"constructors\", () => {\n\t        describe(\"Some\", () => {\n\t            it(\"creates a new Some instance\", () => {\n", "                expect(Option.some(42)).toStrictEqual({\n\t                    _tag: \"Some\",\n\t                    some: 42,\n\t                })\n\t            })\n\t        })\n\t        describe(\"None\", () => {\n\t            it(\"creates a new None instance\", () => {\n\t                expect(Option.none).toStrictEqual({\n\t                    _tag: \"None\",\n", "                })\n\t            })\n\t        })\n\t    })\n\t    describe(\"ofNullish\", () => {\n\t        it.each([[null], [undefined]])(\"converts nullish values (%o) to None\", inp => {\n\t            expect(Option.ofNullish(inp)).toStrictEqual(Option.none)\n\t        })\n\t        it.each([\n\t            [0, Option.some(0)],\n", "            [42, Option.some(42)],\n\t            [\"\", Option.some(\"\")],\n\t            [\"cheese\", Option.some(\"cheese\")],\n\t            [[], Option.some([])],\n\t            [[1], Option.some([1])],\n\t        ])(\"converts non-nullish values (%o) to Some\", (inp, expected) => {\n\t            expect(Option.ofNullish(inp)).toStrictEqual(expected)\n\t        })\n\t    })\n\t    describe(\"toNullish\", () => {\n", "        it.each([\n\t            [undefined, null],\n\t            [false, undefined],\n\t            [true, null],\n\t        ])(\"converts None to a nullish value (useNull = %o)\", (useNull, expected) => {\n\t            expect(Option.toNullish(Option.none, useNull)).toBe(expected)\n\t        })\n\t        it.each([\n\t            [0, Option.some(0)],\n\t            [42, Option.some(42)],\n", "            [\"\", Option.some(\"\")],\n\t            [\"cheese\", Option.some(\"cheese\")],\n\t            [[], Option.some([])],\n\t            [[1], Option.some([1])],\n\t        ])(\"converts Some to a raw value (%o)\", (expected, inp) => {\n\t            expect(Option.toNullish<NonNullish>(inp)).toStrictEqual(expected)\n\t        })\n\t    })\n\t    describe(\"isSome\", () => {\n\t        it(\"returns true for Some\", () => {\n", "            expect(Option.isSome(Option.some(1))).toBe(true)\n\t        })\n\t        it(\"returns false for None\", () => {\n\t            expect(Option.isSome(Option.none)).toBe(false)\n\t        })\n\t    })\n\t    describe(\"isNone\", () => {\n\t        it(\"returns true for None\", () => {\n\t            expect(Option.isNone(Option.none)).toBe(true)\n\t        })\n", "        it(\"returns false for Some\", () => {\n\t            expect(Option.isNone(Option.some(1))).toBe(false)\n\t        })\n\t    })\n\t    describe(\"map\", () => {\n\t        it(\"returns a Some with projected inner value if Some\", () => {\n\t            const incr = (n: number) => n + 1\n\t            expect(pipe(Option.some(22), Option.map(incr))).toStrictEqual(Option.some(23))\n\t        })\n\t        it(\"returns None if given None\", () => {\n", "            const incr = (n: number) => n + 1\n\t            expect(pipe(Option.none, Option.map(incr))).toStrictEqual(Option.none)\n\t        })\n\t    })\n\t    describe(\"map2\", () => {\n\t        it(\"returns the projected value if both Options are Some\", () => {\n\t            // arrange\n\t            const add = (a: number, b: number) => a + b\n\t            // act\n\t            const actual = pipe([Option.some(2), Option.some(3)], Option.map2(add))\n", "            // assert\n\t            expect(actual).toStrictEqual(Option.some(5))\n\t        })\n\t        it.each([\n\t            [[Option.none, Option.none]],\n\t            [[Option.some(2), Option.none]],\n\t            [[Option.none, Option.some(3)]],\n\t        ] as const)(\"returns None if either/both of the Options are None\", options => {\n\t            // arrange\n\t            const add = (a: number, b: number) => a + b\n", "            // act\n\t            const actual = pipe(options, Option.map2(add))\n\t            // assert\n\t            expect(actual).toStrictEqual(Option.none)\n\t        })\n\t    })\n\t    describe(\"map3\", () => {\n\t        it(\"returns the projected value if all 3 Options are Some\", () => {\n\t            // arrange\n\t            const add = (a: number, b: number, c: number) => a + b + c\n", "            // act\n\t            const actual = pipe(\n\t                [Option.some(2), Option.some(3), Option.some(4)],\n\t                Option.map3(add)\n\t            )\n\t            // assert\n\t            expect(actual).toStrictEqual(Option.some(9))\n\t        })\n\t        it.each([\n\t            [[Option.none, Option.none, Option.none]],\n", "            [[Option.some(2), Option.none, Option.none]],\n\t            [[Option.none, Option.some(3), Option.none]],\n\t            [[Option.none, Option.none, Option.some(3)]],\n\t            [[Option.none, Option.some(3), Option.some(3)]],\n\t            [[Option.some(3), Option.some(3), Option.none]],\n\t        ] as const)(\n\t            \"returns None if any one of the Options is None\",\n\t            (options: readonly [Option<number>, Option<number>, Option<number>]) => {\n\t                // arrange\n\t                const add = (a: number, b: number) => a + b\n", "                // act\n\t                const actual = pipe(options, Option.map3(add))\n\t                // assert\n\t                expect(actual).toStrictEqual(Option.none)\n\t            }\n\t        )\n\t    })\n\t    describe(\"bind\", () => {\n\t        it(\"returns Some if the given Option is Some and the projection returns Some\", () => {\n\t            // arrange\n", "            const appendS = (s: string) => Option.some(`${s}S`)\n\t            // act\n\t            const actual = pipe(Option.some(\"cheese\"), Option.bind(appendS))\n\t            // assert\n\t            expect(actual).toStrictEqual(Option.some(\"cheeseS\"))\n\t        })\n\t        it(\"returns None if the given Option is Some but the projection returns None\", () => {\n\t            // arrange\n\t            const alwaysNone = () => Option.none\n\t            // act\n", "            const actual = pipe(Option.some(\"cheese\"), Option.bind(alwaysNone))\n\t            // assert\n\t            expect(actual).toStrictEqual(Option.none)\n\t        })\n\t        it(\"returns None if the given Option is None, regardless of the projection\", () => {\n\t            // arrange\n\t            const alwaysSome = () => Option.some(\"cheese\")\n\t            // act\n\t            const actual = pipe(Option.none, Option.bind(alwaysSome))\n\t            // assert\n", "            expect(actual).toStrictEqual(Option.none)\n\t        })\n\t    })\n\t    describe(\"defaultValue\", () => {\n\t        it(\"returns the wrapped value if the Option is Some\", () => {\n\t            const actual = pipe(Option.some(33), Option.defaultValue(1))\n\t            expect(actual).toBe(33)\n\t        })\n\t        it(\"returns the default value if the Option is None\", () => {\n\t            const actual = pipe(Option.none, Option.defaultValue(1))\n", "            expect(actual).toBe(1)\n\t        })\n\t    })\n\t    describe(\"defaultWith\", () => {\n\t        it(\"returns the wrapped value if the Option is Some\", () => {\n\t            const fallbackFn = vi.fn(() => \"default\")\n\t            const actual = pipe(Option.some(\"cheese\"), Option.defaultWith(fallbackFn))\n\t            expect(actual).toBe(\"cheese\")\n\t            expect(fallbackFn).not.toHaveBeenCalled()\n\t        })\n", "        it(\"returns the default lambda result if the Option is None\", () => {\n\t            const actual = pipe(\n\t                Option.none,\n\t                Option.defaultWith(() => \"default\")\n\t            )\n\t            expect(actual).toBe(\"default\")\n\t        })\n\t    })\n\t    describe(\"match\", () => {\n\t        it.each([\n", "            [Option.some(\"cheese\"), \"cheese!\"],\n\t            [Option.none, \"!\"],\n\t        ])(\"can match with lambdas\", (inp, expected) => {\n\t            // arrange\n\t            const exclaim = (s: string) => `${s}!`\n\t            const matcher = {\n\t                some: exclaim,\n\t                none: () => \"!\",\n\t            }\n\t            // act\n", "            const actual = pipe(inp, Option.match(matcher))\n\t            // assert\n\t            expect(actual).toBe(expected)\n\t        })\n\t        it.each([\n\t            [Option.some(\"cheese\"), \"cheese!\"],\n\t            [Option.none, \"!\"],\n\t        ])(\"can match with raw values\", (inp, expected) => {\n\t            // arrange\n\t            const matcher = {\n", "                some: \"cheese!\",\n\t                none: \"!\",\n\t            }\n\t            // act\n\t            const actual = pipe(inp, Option.match(matcher))\n\t            // assert\n\t            expect(actual).toBe(expected)\n\t        })\n\t        it.each([\n\t            [Option.some(22), undefined],\n", "            [Option.none, 0],\n\t        ])(\"allows falsy values as matcher values\", (inp, expected) => {\n\t            // arrange\n\t            const matcher = {\n\t                some: undefined,\n\t                none: 0,\n\t            }\n\t            // act\n\t            const actual = pipe(inp as Option<number>, Option.match(matcher))\n\t            // assert\n", "            expect(actual).toBe(expected)\n\t        })\n\t    })\n\t    describe(\"filter\", () => {\n\t        it(\"returns Some if the predicate holds\", () => {\n\t            expect(\n\t                pipe(\n\t                    Option.some(\"cheese\"),\n\t                    Option.filter(s => s.length < 10)\n\t                )\n", "            ).toStrictEqual(Option.some(\"cheese\"))\n\t        })\n\t        it(\"returns None if the predicate does not hold\", () => {\n\t            expect(\n\t                pipe(\n\t                    Option.some(\"cheese\"),\n\t                    Option.filter(s => s.length > 10)\n\t                )\n\t            ).toStrictEqual(Option.none)\n\t        })\n", "        it(\"returns None if given None\", () => {\n\t            expect(\n\t                pipe(\n\t                    Option.none,\n\t                    Option.filter((s: string) => s.length > 10)\n\t                )\n\t            ).toStrictEqual(Option.none)\n\t        })\n\t    })\n\t    describe(\"refine\", () => {\n", "        it(\"returns Some if the type guard holds\", () => {\n\t            expect(\n\t                pipe(\n\t                    Option.some(\"cheese\"),\n\t                    Option.refine((s): s is \"cheese\" => s === \"cheese\")\n\t                )\n\t            ).toStrictEqual(Option.some(\"cheese\"))\n\t        })\n\t        it(\"returns None if the predicate does not hold\", () => {\n\t            expect(\n", "                pipe(\n\t                    Option.some(\"cheese\"),\n\t                    Option.refine((s): s is \"nope\" => s === \"nope\")\n\t                )\n\t            ).toStrictEqual(Option.none)\n\t        })\n\t        it(\"returns None if given None\", () => {\n\t            expect(\n\t                pipe(\n\t                    Option.none,\n", "                    Option.refine((s: string): s is \"cheese\" => s === \"cheese\")\n\t                )\n\t            ).toStrictEqual(Option.none)\n\t        })\n\t    })\n\t    describe(\"tryCatch\", () => {\n\t        it(\"returns Some when function succeeds\", () => {\n\t            // arrange\n\t            const f = () => 42\n\t            // act\n", "            const actual = Option.tryCatch(f)\n\t            // assert\n\t            expect(actual).toStrictEqual(Option.some(42))\n\t        })\n\t        it(\"returns None when function throws\", () => {\n\t            // arrange\n\t            const f = () => {\n\t                throw new Error(\"\")\n\t            }\n\t            // act\n", "            const actual = Option.tryCatch(f)\n\t            // assert\n\t            expect(actual).toStrictEqual(Option.none)\n\t        })\n\t    })\n\t    describe(\"getEqualityComparer\", () => {\n\t        it.each([\n\t            [true, \"both are Somes and are equal\", Option.some(1), Option.some(1)],\n\t            [false, \"both are Somes but are not equal\", Option.some(1), Option.some(2)],\n\t            [false, \"one is a Some and one is a None\", Option.some(1), Option.none],\n", "            [false, \"one is a None and one is an Some\", Option.none, Option.some(1)],\n\t            [true, \"both are Nones\", Option.none, Option.none],\n\t        ])(\n\t            \"gets an equality comparer that returns %o when %s\",\n\t            (expected, _, result1, result2) => {\n\t                const { equals } = Option.getEqualityComparer(EqualityComparer.Number)\n\t                expect(equals(result1, result2)).toBe(equals(result2, result1))\n\t                expect(equals(result1, result2)).toBe(expected)\n\t            }\n\t        )\n", "    })\n\t    describe(\"tee\", () => {\n\t        it(\"executes a side effect against Some\", () => {\n\t            const log = vi.fn<[], void>()\n\t            const actual = pipe(\n\t                Option.some(32),\n\t                Option.tee(log),\n\t                Option.map(n => n * 2)\n\t            )\n\t            expect(actual).toStrictEqual(Option.some(64))\n", "            expect(log).toHaveBeenCalledOnce()\n\t            expect(log).toHaveBeenCalledWith(32)\n\t        })\n\t        it(\"does not execute a side effect against None\", () => {\n\t            const log = vi.fn<[], void>()\n\t            const actual = pipe(\n\t                Option.none,\n\t                Option.tee(log),\n\t                Option.map((n: number) => n * 2)\n\t            )\n", "            expect(actual).toBe(Option.none)\n\t            expect(log).not.toHaveBeenCalled()\n\t        })\n\t    })\n\t})\n"]}
{"filename": "test/Enums.test.ts", "chunked_list": ["import { describe, it, expect } from \"vitest\"\n\timport { enumOf, EnumOf } from \"../src/Enums\"\n\timport { Result } from \"../src/Result\"\n\tconst Cheese = enumOf(\n\t    {\n\t        Gouda: \"Gouda\",\n\t        Muenster: \"Muenster\",\n\t        Parmesean: \"Parmesean\",\n\t    } as const,\n\t    \"Cheese\"\n", ")\n\ttype Cheese = EnumOf<typeof Cheese>\n\tconst LogLevel = enumOf(\n\t    {\n\t        TRACE: 0,\n\t        DEBUG: 1,\n\t        CRAZY_PILLS: \"over 9000\",\n\t    } as const,\n\t    \"LogLevel\"\n\t)\n", "type LogLevel = EnumOf<typeof LogLevel>\n\tdescribe(\"enumOf module\", () => {\n\t    describe(\"value accessors\", () => {\n\t        it(\"preserves simple named value access\", () => {\n\t            expect(Cheese.Gouda).toBe(\"Gouda\")\n\t            expect(Cheese.Muenster).toBe(\"Muenster\")\n\t            expect(Cheese.Parmesean).toBe(\"Parmesean\")\n\t            expect(LogLevel.TRACE).toBe(0)\n\t            expect(LogLevel.DEBUG).toBe(1)\n\t            expect(LogLevel.CRAZY_PILLS).toBe(\"over 9000\")\n", "        })\n\t    })\n\t    describe(\"values array\", () => {\n\t        it(\"automatically produces a values property with all possible enum values\", () => {\n\t            expect(Cheese.values).toStrictEqual([\"Gouda\", \"Muenster\", \"Parmesean\"])\n\t            expect(LogLevel.values).toStrictEqual([0, 1, \"over 9000\"])\n\t        })\n\t    })\n\t    describe(\"parse\", () => {\n\t        it.each([\n", "            [\"muenster \", Cheese.Muenster],\n\t            [\"GOUDA\", Cheese.Gouda],\n\t            [\"  gOuDa \", Cheese.Gouda],\n\t            [\"Muenster\", Cheese.Muenster],\n\t        ])(\n\t            \"decodes valid input %s -> %s regardless of case or surrounding whitespace\",\n\t            (input, expected) => {\n\t                expect(Cheese.parse(input)).toStrictEqual(Result.ok(expected))\n\t            }\n\t        )\n", "        it.each([[\"i am 12\"], [\"swiss\"], [\"Mue- n-ster\"]])(\n\t            \"fails invalid input: %s\",\n\t            input => {\n\t                expect(Cheese.parse(input)).toStrictEqual(\n\t                    Result.err(\n\t                        expect.stringMatching(\n\t                            /Must be an enum value in the set Cheese{.*}/\n\t                        )\n\t                    )\n\t                )\n", "            }\n\t        )\n\t        it.each([[null], [undefined]])(\"fails for nullish input %o\", input => {\n\t            expect(Cheese.parse(input)).toStrictEqual(\n\t                Result.err(\"Enum Cheese cannot be null/undefined\")\n\t            )\n\t        })\n\t        it.each([\n\t            [{ name: \"cheese\" }],\n\t            [\n", "                () => {\n\t                    return\n\t                },\n\t            ],\n\t        ])(\"fails for inputs of an incorrect type\", input => {\n\t            expect(Cheese.parse(input)).toStrictEqual(\n\t                Result.err(\"Enum Cheese must be a string or number\")\n\t            )\n\t        })\n\t    })\n", "    describe(\"match\", () => {\n\t        it.each([\n\t            [0, \"trace!\"],\n\t            [1, \"debug!\"],\n\t            [\"over 9000\", \"you're on crazy pills!\"],\n\t        ] as const)(\"it matches inputs (%o -> %s)\", (input, expected) => {\n\t            // arrange\n\t            const matcher = {\n\t                TRACE: \"trace!\",\n\t                DEBUG: () => \"debug!\",\n", "                CRAZY_PILLS() {\n\t                    return \"you're on crazy pills!\"\n\t                },\n\t            }\n\t            // act\n\t            const actual = LogLevel.match(matcher)(input)\n\t            // assert\n\t            expect(actual).toBe(expected)\n\t        })\n\t        it.each([\n", "            [LogLevel.TRACE, null],\n\t            [LogLevel.DEBUG, undefined],\n\t            [LogLevel.CRAZY_PILLS, 0],\n\t        ])(\n\t            \"allows specifying null/undefined/falsy values in the matcher branches\",\n\t            (input, expected) => {\n\t                // arrange\n\t                const matcher = {\n\t                    TRACE: null,\n\t                    DEBUG: undefined,\n", "                    CRAZY_PILLS: 0,\n\t                }\n\t                // act\n\t                const actual = LogLevel.match(matcher)(input)\n\t                // assert\n\t                expect(actual).toBe(expected)\n\t            }\n\t        )\n\t        it(\"throws a helpful error message if the matcher is missing a required case (if someone ignores compiler errors)\", () => {\n\t            // arrange\n", "            const matcher = {\n\t                DEBUG: () => \"debug!\",\n\t                CRAZY_PILLS() {\n\t                    return `you're on crazy pills!`\n\t                },\n\t            }\n\t            // act & assert\n\t            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n\t            expect(() => LogLevel.match(matcher as any)(0)).toThrow(\n\t                `Expected a matcher containing a case for 'TRACE'.`\n", "            )\n\t        })\n\t        it(\"throws a helpful error message if the matcher gets passed an invalid enum value (if someone ignores compiler errors)\", () => {\n\t            // arrange\n\t            const matcher = {\n\t                TRACE: \"trace!\",\n\t                DEBUG: () => \"debug!\",\n\t                CRAZY_PILLS() {\n\t                    return \"you're on crazy pills!\"\n\t                },\n", "            }\n\t            // act & assert\n\t            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n\t            expect(() => LogLevel.match(matcher)(2 as any)).toThrow(\n\t                `Expected to match against an enum where '2' is a valid value.`\n\t            )\n\t        })\n\t    })\n\t    describe(\"matchOrElse\", () => {\n\t        it.each([\n", "            [0, \"trace!\"],\n\t            [1, \"unmatched\"],\n\t            [\"over 9000\", \"you're on crazy pills!\"],\n\t        ] as const)(\"it matches inputs (%o -> %s)\", (input, expected) => {\n\t            // arrange\n\t            const matcher = {\n\t                TRACE: \"trace!\",\n\t                CRAZY_PILLS() {\n\t                    return \"you're on crazy pills!\"\n\t                },\n", "                orElse: \"unmatched\",\n\t            }\n\t            // act\n\t            const actual = LogLevel.matchOrElse(matcher)(input)\n\t            // assert\n\t            expect(actual).toBe(expected)\n\t        })\n\t        it.each([\n\t            [Cheese.Gouda, null],\n\t            [Cheese.Muenster, undefined],\n", "            [Cheese.Parmesean, \"\"],\n\t        ])(\n\t            \"allows specifying null/undefined/falsy values in the matcher branches\",\n\t            (input, expected) => {\n\t                // arrange\n\t                const matcher = {\n\t                    Gouda: null,\n\t                    Muenster: undefined,\n\t                    Parmesean: \"\",\n\t                    orElse: \"\",\n", "                }\n\t                // act\n\t                const actual = Cheese.matchOrElse(matcher)(input)\n\t                // assert\n\t                expect(actual).toBe(expected)\n\t            }\n\t        )\n\t        it(\"throws a helpful error message if the matcher gets passed an invalid enum value (somehow?)\", () => {\n\t            // arrange\n\t            const matcher = {\n", "                TRACE: \"trace!\",\n\t                DEBUG: () => \"debug!\",\n\t                CRAZY_PILLS() {\n\t                    return \"you're on crazy pills!\"\n\t                },\n\t                orElse: () => \"unmatched\",\n\t            }\n\t            // act & assert\n\t            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n\t            expect(() => LogLevel.matchOrElse(matcher)(2 as any)).toThrow(\n", "                `Expected to match against an enum where '2' is a valid value.`\n\t            )\n\t        })\n\t    })\n\t})\n"]}
{"filename": "test/OrderingComparer.test.ts", "chunked_list": ["import { describe, it, expect } from \"vitest\"\n\timport * as OrderingComparer from \"../src/OrderingComparer\"\n\tinterface Person {\n\t    readonly name: string\n\t}\n\tinterface Cat {\n\t    readonly name: string\n\t    readonly age: number\n\t    readonly livesRemaining: number\n\t}\n", "describe(\"OrderingComparer\", () => {\n\t    describe(\"ofCompare\", () => {\n\t        it(\"costructs a new OrderingComparer from a compare function\", () => {\n\t            const { compare } = OrderingComparer.ofCompare<number>(\n\t                (n1, n2) => (n1 === n2 ? 0 : n1 > n2 ? -1 : 1) // numbers in desc order\n\t            )\n\t            expect(compare(5, 5)).toBe(0)\n\t            expect(compare(6, 5)).toBe(-1)\n\t            expect(compare(5, 6)).toBe(1)\n\t            expect(compare(100, 0)).toBe(-1)\n", "            expect(compare(0, 100)).toBe(1)\n\t        })\n\t    })\n\t    describe(\"Number\", () => {\n\t        it(\"sorts numbers in ascending order\", () => {\n\t            const { compare } = OrderingComparer.Number\n\t            const shuffledNumbers = [-11, -13, 2, 0, 45, 1, 8, 2, 100, -1]\n\t            expect(shuffledNumbers.slice(0).sort(compare)).toStrictEqual([\n\t                -13, -11, -1, 0, 1, 2, 2, 8, 45, 100,\n\t            ])\n", "        })\n\t    })\n\t    describe(\"reverse\", () => {\n\t        it(\"reverses the sort order\", () => {\n\t            const { compare } = OrderingComparer.reverse(OrderingComparer.Number)\n\t            const shuffledNumbers = [-11, -13, 2, 0, 45, 1, 8, 2, 100, -1]\n\t            expect(shuffledNumbers.slice(0).sort(compare)).toStrictEqual([\n\t                100, 45, 8, 2, 2, 1, 0, -1, -11, -13,\n\t            ])\n\t        })\n", "    })\n\t    describe(\"deriveFrom\", () => {\n\t        it(\"can use an existing OrderingComparer to make a new one with a map function\", () => {\n\t            const { compare } = OrderingComparer.deriveFrom<string, Person>(\n\t                OrderingComparer.String,\n\t                p => p.name\n\t            )\n\t            const unsortedPeople = [\n\t                { name: \"Johnny\" },\n\t                { name: \"Larry\" },\n", "                { name: \"Amy\" },\n\t                { name: \"Kevin\" },\n\t            ]\n\t            expect(unsortedPeople.slice(0).sort(compare)).toStrictEqual([\n\t                { name: \"Amy\" },\n\t                { name: \"Johnny\" },\n\t                { name: \"Kevin\" },\n\t                { name: \"Larry\" },\n\t            ])\n\t        })\n", "    })\n\t    describe(\"getComposite\", () => {\n\t        it(\"applies multiple OrderingComparers in a 'and then by,' 'and then by,' fashion\", () => {\n\t            // arrange\n\t            const byName = OrderingComparer.deriveFrom<string, Cat>(\n\t                OrderingComparer.String,\n\t                c => c.name\n\t            )\n\t            const byAge = OrderingComparer.deriveFrom<number, Cat>(\n\t                OrderingComparer.Number,\n", "                c => c.age\n\t            )\n\t            const byLivesRemainingDesc = OrderingComparer.deriveFrom<number, Cat>(\n\t                OrderingComparer.reverse(OrderingComparer.Number),\n\t                c => c.livesRemaining\n\t            )\n\t            const { compare } = OrderingComparer.getComposite(\n\t                byName,\n\t                byAge,\n\t                byLivesRemainingDesc\n", "            )\n\t            const shuffledCats: Cat[] = [\n\t                { name: \"Gerald\", age: 5, livesRemaining: 9 },\n\t                { name: \"Rufus\", age: 10, livesRemaining: 3 },\n\t                { name: \"Gerald\", age: 5, livesRemaining: 7 },\n\t                { name: \"Arnold\", age: 1, livesRemaining: 9 },\n\t                { name: \"Rufus\", age: 10, livesRemaining: 1 },\n\t                { name: \"Gerald\", age: 7, livesRemaining: 8 },\n\t            ]\n\t            const sortedCats: Cat[] = [\n", "                { name: \"Arnold\", age: 1, livesRemaining: 9 },\n\t                { name: \"Gerald\", age: 5, livesRemaining: 9 },\n\t                { name: \"Gerald\", age: 5, livesRemaining: 7 },\n\t                { name: \"Gerald\", age: 7, livesRemaining: 8 },\n\t                { name: \"Rufus\", age: 10, livesRemaining: 3 },\n\t                { name: \"Rufus\", age: 10, livesRemaining: 1 },\n\t            ]\n\t            // act\n\t            const actual = shuffledCats.slice(0).sort(compare)\n\t            // assert\n", "            expect(actual).toStrictEqual(sortedCats)\n\t        })\n\t    })\n\t    describe(\"Date\", () => {\n\t        it(\"sorts dates in ascending order\", () => {\n\t            const { compare } = OrderingComparer.Date\n\t            expect(\n\t                [\n\t                    new Date(2023, 2, 15),\n\t                    new Date(2025, 2, 15),\n", "                    new Date(2022, 2, 15),\n\t                    new Date(2020, 2, 15),\n\t                ]\n\t                    .slice(0)\n\t                    .sort(compare)\n\t            ).toStrictEqual([\n\t                new Date(2020, 2, 15),\n\t                new Date(2022, 2, 15),\n\t                new Date(2023, 2, 15),\n\t                new Date(2025, 2, 15),\n", "            ])\n\t        })\n\t    })\n\t    describe(\"deriveEqualityComparer\", () => {\n\t        it(\"returns an instance that also includes an equality comparer\", () => {\n\t            const { equals } = OrderingComparer.deriveEqualityComparer(\n\t                OrderingComparer.Number\n\t            )\n\t            expect(equals(1, 1)).toBe(true)\n\t            expect(equals(1, 2)).toBe(false)\n", "            expect(equals(2, 1)).toBe(false)\n\t        })\n\t    })\n\t    describe(\"gt\", () => {\n\t        it.each([\n\t            [true, \"a > b\", 2, 1],\n\t            [false, \"a = b\", 1, 1],\n\t            [false, \"a < b\", 0, 1],\n\t        ])(\"returns %o when %s\", (expected, _, first, second) => {\n\t            expect(OrderingComparer.gt(OrderingComparer.Number)(first, second)).toBe(\n", "                expected\n\t            )\n\t        })\n\t    })\n\t    describe(\"geq\", () => {\n\t        it.each([\n\t            [true, \"a > b\", 2, 1],\n\t            [true, \"a = b\", 1, 1],\n\t            [false, \"a < b\", 0, 1],\n\t        ])(\"returns %o when %s\", (expected, _, first, second) => {\n", "            expect(OrderingComparer.geq(OrderingComparer.Number)(first, second)).toBe(\n\t                expected\n\t            )\n\t        })\n\t    })\n\t    describe(\"lt\", () => {\n\t        it.each([\n\t            [false, \"a > b\", 2, 1],\n\t            [false, \"a = b\", 1, 1],\n\t            [true, \"a < b\", 0, 1],\n", "        ])(\"returns %o when %s\", (expected, _, first, second) => {\n\t            expect(OrderingComparer.lt(OrderingComparer.Number)(first, second)).toBe(\n\t                expected\n\t            )\n\t        })\n\t    })\n\t    describe(\"leq\", () => {\n\t        it.each([\n\t            [false, \"a > b\", 2, 1],\n\t            [true, \"a = b\", 1, 1],\n", "            [true, \"a < b\", 0, 1],\n\t        ])(\"returns %o when %s\", (expected, _, first, second) => {\n\t            expect(OrderingComparer.leq(OrderingComparer.Number)(first, second)).toBe(\n\t                expected\n\t            )\n\t        })\n\t    })\n\t    describe(\"isBetween\", () => {\n\t        it.each([\n\t            [true, \"on upper bound\", 1, 5, 5],\n", "            [true, \"on lower bound\", 1, 5, 1],\n\t            [true, \"within upper and lower bounds\", 1, 5, 3],\n\t            [false, \"above upper bound\", 1, 5, 6],\n\t            [false, \"below lower bound\", 1, 5, 0],\n\t        ])(\n\t            \"returns %o when test value is %s\",\n\t            (expected, _, lowerBound, upperBound, test) => {\n\t                expect(\n\t                    OrderingComparer.isBetween(OrderingComparer.Number)(\n\t                        lowerBound,\n", "                        upperBound\n\t                    )(test)\n\t                ).toBe(expected)\n\t            }\n\t        )\n\t    })\n\t})\n"]}
{"filename": "test/DeferredResult.test.ts", "chunked_list": ["import { describe, it, expect } from \"vitest\"\n\timport * as DeferredResult from \"../src/DeferredResult\"\n\timport { Deferred } from \"../src/Deferred\"\n\timport { Result } from \"../src/Result\"\n\timport { pipe } from \"../src/Composition\"\n\ttype DeferredResult<A, E> = DeferredResult.DeferredResult<A, E>\n\tdescribe(\"DeferredResult\", () => {\n\t    describe(\"match\", () => {\n\t        it.each([\n\t            [\n", "                \"notStarted\",\n\t                Deferred.notStarted as DeferredResult<number, string>,\n\t                \"Not Started\",\n\t            ],\n\t            [\n\t                \"inProgress\",\n\t                Deferred.inProgress as DeferredResult<number, string>,\n\t                \"In Progress\",\n\t            ],\n\t            [\n", "                \"resolvedOk\",\n\t                Deferred.resolved(Result.ok(20)) as DeferredResult<number, string>,\n\t                \"Ok\",\n\t            ],\n\t            [\n\t                \"resolvedErr\",\n\t                Deferred.resolved(Result.err(\"fail\")) as DeferredResult<number, string>,\n\t                \"Err\",\n\t            ],\n\t        ])(\n", "            \"uses the raw value for each match case if given (%s)\",\n\t            (_, input, expected) => {\n\t                expect(\n\t                    pipe(\n\t                        input,\n\t                        DeferredResult.match({\n\t                            notStarted: \"Not Started\",\n\t                            inProgress: \"In Progress\",\n\t                            resolvedOk: \"Ok\",\n\t                            resolvedErr: \"Err\",\n", "                        })\n\t                    )\n\t                ).toBe(expected)\n\t            }\n\t        )\n\t        it.each([\n\t            [\"notStarted\", Deferred.notStarted as DeferredResult<number, string>, \"\"],\n\t            [\"inProgress\", Deferred.inProgress as DeferredResult<number, string>, 0],\n\t            [\n\t                \"resolvedOk\",\n", "                Deferred.resolved(Result.ok(20)) as DeferredResult<number, string>,\n\t                null,\n\t            ],\n\t            [\n\t                \"resolvedErr\",\n\t                Deferred.resolved(Result.err(\"fail\")) as DeferredResult<number, string>,\n\t                undefined,\n\t            ],\n\t        ])(\n\t            \"correctly returns falsy and nullish raw values for each match case if given (%s)\",\n", "            (_, input, expected) => {\n\t                expect(\n\t                    pipe(\n\t                        input,\n\t                        DeferredResult.match<\n\t                            number,\n\t                            string,\n\t                            number | string | null | undefined\n\t                        >({\n\t                            notStarted: \"\",\n", "                            inProgress: 0,\n\t                            resolvedOk: null,\n\t                            resolvedErr: undefined,\n\t                        })\n\t                    )\n\t                ).toBe(expected)\n\t            }\n\t        )\n\t        it.each([\n\t            [\n", "                \"notStarted\",\n\t                Deferred.notStarted as DeferredResult<number, string>,\n\t                \"Not Started\",\n\t            ],\n\t            [\n\t                \"inProgress\",\n\t                Deferred.inProgress as DeferredResult<number, string>,\n\t                \"In Progress\",\n\t            ],\n\t            [\n", "                \"resolvedOk\",\n\t                Deferred.resolved(Result.ok(20)) as DeferredResult<number, string>,\n\t                \"Ok(20)\",\n\t            ],\n\t            [\n\t                \"resolvedErr\",\n\t                Deferred.resolved(Result.err(\"fail\")) as DeferredResult<number, string>,\n\t                \"Err(fail)\",\n\t            ],\n\t        ])(\n", "            \"correctly uses lambda functions for each match case if given (%s)\",\n\t            (_, input, expected) => {\n\t                expect(\n\t                    pipe(\n\t                        input,\n\t                        DeferredResult.match({\n\t                            notStarted: () => \"Not Started\",\n\t                            inProgress: () => \"In Progress\",\n\t                            resolvedOk: a => `Ok(${a})`,\n\t                            resolvedErr: e => `Err(${e})`,\n", "                        })\n\t                    )\n\t                ).toBe(expected)\n\t            }\n\t        )\n\t    })\n\t    describe(\"matchOrElse\", () => {\n\t        it.each([\n\t            [\n\t                \"notStarted\",\n", "                Deferred.notStarted as DeferredResult<number, string>,\n\t                \"Default\",\n\t            ],\n\t            [\n\t                \"inProgress\",\n\t                Deferred.inProgress as DeferredResult<number, string>,\n\t                \"Default\",\n\t            ],\n\t            [\n\t                \"resolvedOk\",\n", "                Deferred.resolved(Result.ok(20)) as DeferredResult<number, string>,\n\t                \"Ok\",\n\t            ],\n\t            [\n\t                \"resolvedErr\",\n\t                Deferred.resolved(Result.err(\"fail\")) as DeferredResult<number, string>,\n\t                \"Err\",\n\t            ],\n\t        ])(\n\t            \"uses the raw value for each match case if given (%s)\",\n", "            (_, input, expected) => {\n\t                expect(\n\t                    pipe(\n\t                        input,\n\t                        DeferredResult.matchOrElse({\n\t                            resolvedOk: \"Ok\",\n\t                            resolvedErr: \"Err\",\n\t                            orElse: \"Default\",\n\t                        })\n\t                    )\n", "                ).toBe(expected)\n\t            }\n\t        )\n\t        it.each([\n\t            [\"notStarted\", Deferred.notStarted as DeferredResult<number, string>, 0],\n\t            [\"inProgress\", Deferred.inProgress as DeferredResult<number, string>, 0],\n\t            [\n\t                \"resolvedOk\",\n\t                Deferred.resolved(Result.ok(20)) as DeferredResult<number, string>,\n\t                \"\",\n", "            ],\n\t            [\n\t                \"resolvedErr\",\n\t                Deferred.resolved(Result.err(\"fail\")) as DeferredResult<number, string>,\n\t                undefined,\n\t            ],\n\t        ])(\n\t            \"correctly returns falsy and nullish raw values for each match case if given (%s)\",\n\t            (_, input, expected) => {\n\t                expect(\n", "                    pipe(\n\t                        input,\n\t                        DeferredResult.matchOrElse<\n\t                            number,\n\t                            string,\n\t                            number | string | undefined\n\t                        >({\n\t                            resolvedOk: \"\",\n\t                            resolvedErr: undefined,\n\t                            orElse: 0,\n", "                        })\n\t                    )\n\t                ).toBe(expected)\n\t            }\n\t        )\n\t        it.each([\n\t            [\n\t                \"notStarted\",\n\t                Deferred.notStarted as DeferredResult<number, string>,\n\t                \"Default\",\n", "            ],\n\t            [\n\t                \"inProgress\",\n\t                Deferred.inProgress as DeferredResult<number, string>,\n\t                \"Default\",\n\t            ],\n\t            [\n\t                \"resolvedOk\",\n\t                Deferred.resolved(Result.ok(20)) as DeferredResult<number, string>,\n\t                \"Ok(20)\",\n", "            ],\n\t            [\n\t                \"resolvedErr\",\n\t                Deferred.resolved(Result.err(\"fail\")) as DeferredResult<number, string>,\n\t                \"Err(fail)\",\n\t            ],\n\t        ])(\n\t            \"correctly uses lambda functions for each match case if given (%s)\",\n\t            (_, input, expected) => {\n\t                expect(\n", "                    pipe(\n\t                        input,\n\t                        DeferredResult.matchOrElse({\n\t                            resolvedOk: a => `Ok(${a})`,\n\t                            resolvedErr: e => `Err(${e})`,\n\t                            orElse: () => \"Default\",\n\t                        })\n\t                    )\n\t                ).toBe(expected)\n\t            }\n", "        )\n\t    })\n\t})\n"]}
{"filename": "test/Result.test.ts", "chunked_list": ["import { describe, it, expect, vi } from \"vitest\"\n\timport * as Result from \"../src/Result\"\n\timport { Option } from \"../src/Option\"\n\timport { pipe } from \"../src/Composition\"\n\timport { EqualityComparer } from \"../src/EqualityComparer\"\n\ttype Result<A, E> = Result.Result<A, E>\n\tdescribe(\"Result\", () => {\n\t    describe(\"constructors\", () => {\n\t        describe(\"Ok\", () => {\n\t            it(\"returns a new Ok object\", () => {\n", "                expect(Result.ok(\"cheese\")).toStrictEqual({\n\t                    _tag: \"Ok\",\n\t                    ok: \"cheese\",\n\t                })\n\t            })\n\t        })\n\t        describe(\"Err\", () => {\n\t            it(\"returns a new Err object\", () => {\n\t                expect(Result.err(\"melted\")).toStrictEqual({\n\t                    _tag: \"Err\",\n", "                    err: \"melted\",\n\t                })\n\t            })\n\t        })\n\t    })\n\t    describe(\"match\", () => {\n\t        it(\"can match using lambdas\", () => {\n\t            // arrange\n\t            const matcher = {\n\t                ok: (s: string) => s.length,\n", "                err: (e: number) => e,\n\t            }\n\t            // act\n\t            const actual1 = pipe(Result.of(\"stink!\"), Result.match(matcher))\n\t            const actual2 = pipe(Result.err(404), Result.match(matcher))\n\t            // assert\n\t            expect(actual1).toBe(6)\n\t            expect(actual2).toBe(404)\n\t        })\n\t        it(\"can match using raw values\", () => {\n", "            // arrange\n\t            const matcher = {\n\t                ok: \"ok?\",\n\t                err: \"err!\",\n\t            }\n\t            // act\n\t            const actual1 = pipe(Result.ok(\"stink!\"), Result.match(matcher))\n\t            const actual2 = pipe(Result.err(404), Result.match(matcher))\n\t            // assert\n\t            expect(actual1).toBe(\"ok?\")\n", "            expect(actual2).toBe(\"err!\")\n\t        })\n\t        it(\"allows nullish matcher values\", () => {\n\t            // arrange\n\t            const matcher = {\n\t                ok: null,\n\t                err: undefined,\n\t            }\n\t            // act\n\t            const actual1 = pipe(Result.ok(\"stink!\"), Result.match(matcher))\n", "            const actual2 = pipe(Result.err(404), Result.match(matcher))\n\t            // assert\n\t            expect(actual1).toBe(null)\n\t            expect(actual2).toBe(undefined)\n\t        })\n\t        it(\"allows falsy matcher values\", () => {\n\t            // arrange\n\t            const matcher = {\n\t                ok: 0,\n\t                err: \"\",\n", "            }\n\t            // act\n\t            const actual1 = pipe(\n\t                Result.ok(\"stink!\"),\n\t                Result.match<string, never, number | string>(matcher)\n\t            )\n\t            const actual2 = pipe(\n\t                Result.err(404),\n\t                Result.match<never, number, number | string>(matcher)\n\t            )\n", "            // assert\n\t            expect(actual1).toBe(0)\n\t            expect(actual2).toBe(\"\")\n\t        })\n\t    })\n\t    describe(\"map\", () => {\n\t        it(\"returns a mapped Ok if given an Ok\", () => {\n\t            expect(\n\t                pipe(\n\t                    Result.ok(55),\n", "                    Result.map(n => n * 2)\n\t                )\n\t            ).toStrictEqual(Result.ok(110))\n\t        })\n\t        it(\"ignores Err values\", () => {\n\t            expect(\n\t                pipe(\n\t                    Result.err(\"cheese melted\"),\n\t                    Result.map((n: number) => n * 2)\n\t                )\n", "            ).toStrictEqual(Result.err(\"cheese melted\"))\n\t        })\n\t    })\n\t    describe(\"mapErr\", () => {\n\t        it(\"returns a mapped Err if given an Err\", () => {\n\t            expect(\n\t                pipe(\n\t                    Result.err(55),\n\t                    Result.mapErr(n => n * 2)\n\t                )\n", "            ).toStrictEqual(Result.err(110))\n\t        })\n\t        it(\"ignores Ok values\", () => {\n\t            expect(\n\t                pipe(\n\t                    Result.ok(\"cheese\"),\n\t                    Result.mapErr((n: number) => n * 2)\n\t                )\n\t            ).toStrictEqual(Result.ok(\"cheese\"))\n\t        })\n", "    })\n\t    describe(\"map2\", () => {\n\t        it(\"returns the projected value if both results are Ok\", () => {\n\t            // arrange\n\t            const concat = (a: string, b: string) => `${a}${b}`\n\t            // act\n\t            const actual = pipe(\n\t                [Result.ok(\"a\"), Result.ok(\"b\")] as const,\n\t                Result.map2(concat)\n\t            )\n", "            // assert\n\t            expect(actual).toStrictEqual(Result.ok(\"ab\"))\n\t        })\n\t        it.each([\n\t            [[Result.err(\"err1\"), Result.err(\"err2\")], Result.err(\"err1\")],\n\t            [[Result.ok(20), Result.err(\"err\")], Result.err(\"err\")],\n\t            [[Result.err(\"err\"), Result.ok(20)], Result.err(\"err\")],\n\t        ] as const)(\n\t            \"returns the first Err if either/both result is Err\",\n\t            (\n", "                results: readonly [Result<number, string>, Result<number, string>],\n\t                expected\n\t            ) => {\n\t                // arrange\n\t                const add = (a: number, b: number) => a + b\n\t                // act\n\t                const actual = pipe(results, Result.map2(add))\n\t                // assert\n\t                expect(actual).toStrictEqual(expected)\n\t            }\n", "        )\n\t    })\n\t    describe(\"map3\", () => {\n\t        it(\"returns the projected value if all three results are Ok\", () => {\n\t            // arrange\n\t            const concat = (a: string, b: string, c: string) => `${a}${b}${c}`\n\t            // act\n\t            const actual = pipe(\n\t                [Result.ok(\"a\"), Result.ok(\"b\"), Result.ok(\"c\")] as const,\n\t                Result.map3(concat)\n", "            )\n\t            // assert\n\t            expect(actual).toStrictEqual(Result.ok(\"abc\"))\n\t        })\n\t        it.each([\n\t            [\n\t                [Result.err(\"err1\"), Result.err(\"err2\"), Result.err(\"err3\")],\n\t                Result.err(\"err1\"),\n\t            ],\n\t            [[Result.ok(20), Result.err(\"err1\"), Result.err(\"err2\")], Result.err(\"err1\")],\n", "            [[Result.err(\"err1\"), Result.ok(20), Result.err(\"err2\")], Result.err(\"err1\")],\n\t            [[Result.err(\"err1\"), Result.err(\"err2\"), Result.ok(20)], Result.err(\"err1\")],\n\t            [[Result.err(\"err\"), Result.ok(10), Result.ok(20)], Result.err(\"err\")],\n\t            [[Result.ok(10), Result.ok(20), Result.err(\"err\")], Result.err(\"err\")],\n\t        ] as const)(\n\t            \"returns the first found Err if any Result is Err\",\n\t            (\n\t                results: readonly [\n\t                    Result<number, string>,\n\t                    Result<number, string>,\n", "                    Result<number, string>\n\t                ],\n\t                expected\n\t            ) => {\n\t                // arrange\n\t                const add = (a: number, b: number, c: number) => a + b + c\n\t                // act\n\t                const actual = pipe(results, Result.map3(add))\n\t                // assert\n\t                expect(actual).toStrictEqual(expected)\n", "            }\n\t        )\n\t    })\n\t    describe(\"mapBoth\", () => {\n\t        it(\"returns a mapped Err if given an Err\", () => {\n\t            expect(\n\t                pipe(\n\t                    Result.err(55),\n\t                    Result.mapBoth(\n\t                        (n: number) => n * 2,\n", "                        n => n + 1\n\t                    )\n\t                )\n\t            ).toStrictEqual(Result.err(56))\n\t        })\n\t        it(\"returns a mapped Ok if given an Ok\", () => {\n\t            expect(\n\t                pipe(\n\t                    Result.ok(\"cheese\"),\n\t                    Result.mapBoth(\n", "                        s => s.length,\n\t                        (s: string) => s.concat(\"eek\")\n\t                    )\n\t                )\n\t            ).toStrictEqual(Result.ok(6))\n\t        })\n\t    })\n\t    describe(\"defaultValue\", () => {\n\t        it(\"returns the Ok value for Oks\", () => {\n\t            expect(pipe(Result.ok(1), Result.defaultValue(0))).toBe(1)\n", "        })\n\t        it(\"returns the fallback value for Errs\", () => {\n\t            expect(pipe(Result.err(\"cheese\"), Result.defaultValue(0))).toBe(0)\n\t        })\n\t    })\n\t    describe(\"defaultWith\", () => {\n\t        it(\"returns the Ok value for Oks\", () => {\n\t            const f = vi.fn()\n\t            expect(pipe(Result.ok(1), Result.defaultWith(f))).toBe(1)\n\t            expect(f).not.toHaveBeenCalled()\n", "        })\n\t        it(\"returns the fallback value for Errs\", () => {\n\t            const f = vi.fn(() => 0)\n\t            expect(pipe(Result.err(\"cheese\"), Result.defaultWith(f))).toBe(0)\n\t            expect(f).toHaveBeenCalledOnce()\n\t        })\n\t    })\n\t    describe(\"bind\", () => {\n\t        it(\"maps the Ok value to a new Result\", () => {\n\t            expect(\n", "                pipe(\n\t                    Result.ok(1),\n\t                    Result.bind(n =>\n\t                        n > 0 ? Result.ok(\"positive\") : Result.err(\"not positive\")\n\t                    ),\n\t                    Result.defaultValue(\"\")\n\t                )\n\t            ).toBe(\"positive\")\n\t        })\n\t        it(\"does nothing to an Err\", () => {\n", "            expect(\n\t                pipe(\n\t                    Result.err(\"error\"),\n\t                    Result.bind((n: number) =>\n\t                        n > 0 ? Result.ok(\"positive\") : Result.err(\"not positive\")\n\t                    )\n\t                )\n\t            ).toStrictEqual(Result.err(\"error\"))\n\t        })\n\t    })\n", "    describe(\"isOk\", () => {\n\t        it(\"returns true for Ok\", () => {\n\t            expect(Result.isOk(Result.ok(1))).toBe(true)\n\t        })\n\t        it(\"returns false for Err\", () => {\n\t            expect(Result.isOk(Result.err(1))).toBe(false)\n\t        })\n\t    })\n\t    describe(\"isErr\", () => {\n\t        it(\"returns true for Err\", () => {\n", "            expect(Result.isErr(Result.err(1))).toBe(true)\n\t        })\n\t        it(\"returns false for Ok\", () => {\n\t            expect(Result.isErr(Result.ok(1))).toBe(false)\n\t        })\n\t    })\n\t    describe(\"tryCatch\", () => {\n\t        it(\"yields an Ok if the function succeeds\", () => {\n\t            // arrange\n\t            const f = () => 22\n", "            // act\n\t            const actual = Result.tryCatch(f)\n\t            // assert\n\t            expect(actual).toStrictEqual(Result.ok(22))\n\t        })\n\t        it.each([\n\t            [new TypeError(\"type error\"), new TypeError(\"type error\")],\n\t            [42, new Error(\"42\")],\n\t        ])(\n\t            \"yields an Err if the function throws (using default behavior when onThrow is omitted)\",\n", "            (thrown, expected) => {\n\t                // arrange\n\t                const f = () => {\n\t                    throw thrown\n\t                }\n\t                // act\n\t                const actual = Result.tryCatch(f)\n\t                // assert\n\t                expect(actual).toStrictEqual(Result.err(expected))\n\t            }\n", "        )\n\t        it(\"yields an Err if the function throws (using onThrow when provided)\", () => {\n\t            // arrange\n\t            const f = (): number => {\n\t                throw new Error(\"cheese\")\n\t            }\n\t            // act\n\t            const actual = Result.tryCatch(f, () => \"aw, shucks\")\n\t            // assert\n\t            expect(actual).toStrictEqual(Result.err(\"aw, shucks\"))\n", "        })\n\t    })\n\t    describe(\"tee\", () => {\n\t        it(\"executes a side effect without affecting the wrapped Ok\", () => {\n\t            // arrange\n\t            const log = vi.fn()\n\t            // act\n\t            const actual = pipe(\n\t                Result.ok(20),\n\t                Result.tee(log),\n", "                Result.map(n => n * 3)\n\t            )\n\t            // assert\n\t            expect(actual).toStrictEqual(Result.ok(60))\n\t            expect(log).toHaveBeenCalledOnce()\n\t            expect(log).toHaveBeenCalledWith(20)\n\t        })\n\t        it(\"does not execute the side effect for an Err\", () => {\n\t            // arrange\n\t            const log = vi.fn()\n", "            // act\n\t            const actual = pipe(\n\t                Result.err(\"err\"),\n\t                Result.tee(log),\n\t                Result.map((n: number) => n * 3)\n\t            )\n\t            // assert\n\t            expect(actual).toStrictEqual(Result.err(\"err\"))\n\t            expect(log).not.toHaveBeenCalled()\n\t        })\n", "    })\n\t    describe(\"teeErr\", () => {\n\t        it(\"executes a side effect without affecting the wrapped Err\", () => {\n\t            // arrange\n\t            const log = vi.fn()\n\t            // act\n\t            const actual = pipe(\n\t                Result.err<string, number>(\"err\"),\n\t                Result.teeErr(e => {\n\t                    log(e)\n", "                }),\n\t                Result.mapErr((s: string) => s.length)\n\t            )\n\t            // assert\n\t            expect(actual).toStrictEqual(Result.err(3))\n\t            expect(log).toHaveBeenCalledOnce()\n\t            expect(log).toHaveBeenCalledWith(\"err\")\n\t        })\n\t        it(\"does not execute the side effect for an Ok\", () => {\n\t            // arrange\n", "            const log = vi.fn()\n\t            // act\n\t            const actual = pipe(\n\t                Result.ok(\"ok\"),\n\t                Result.teeErr(log),\n\t                Result.mapErr((n: number) => n * 3)\n\t            )\n\t            // assert\n\t            expect(actual).toStrictEqual(Result.ok(\"ok\"))\n\t            expect(log).not.toHaveBeenCalled()\n", "        })\n\t    })\n\t    describe(\"ofOption\", () => {\n\t        it(\"returns Ok if given a Some\", () => {\n\t            expect(\n\t                pipe(\n\t                    Option.some(100),\n\t                    Result.ofOption(() => \"cheese\")\n\t                )\n\t            ).toStrictEqual(Result.ok(100))\n", "        })\n\t        it(\"returns Err if given a None\", () => {\n\t            expect(\n\t                pipe(\n\t                    Option.none,\n\t                    Result.ofOption(() => \"cheese\")\n\t                )\n\t            ).toStrictEqual(Result.err(\"cheese\"))\n\t        })\n\t    })\n", "    describe(\"getEqualityComparer\", () => {\n\t        it.each([\n\t            [true, \"both are Errs and are equal\", Result.err(1), Result.err(1)],\n\t            [false, \"both are Errs but are not equal\", Result.err(1), Result.err(2)],\n\t            [false, \"one is an Ok and one is an Err\", Result.ok(1), Result.err(1)],\n\t            [false, \"one is an Err and one is an Ok\", Result.err(1), Result.ok(1)],\n\t            [true, \"both are Oks and are equal\", Result.ok(1), Result.ok(1)],\n\t            [false, \"both are Oks but are not equal\", Result.ok(1), Result.ok(2)],\n\t        ])(\n\t            \"gets an equality comparer that returns %o when %s\",\n", "            (expected, _, result1, result2) => {\n\t                const { equals } = Result.getEqualityComparer(\n\t                    EqualityComparer.Number,\n\t                    EqualityComparer.Number\n\t                )\n\t                expect(equals(result1, result2)).toBe(equals(result2, result1))\n\t                expect(equals(result1, result2)).toBe(expected)\n\t            }\n\t        )\n\t    })\n", "    describe(\"refine\", () => {\n\t        it(\"returns the refined result if Ok passes the refinement\", () => {\n\t            const isCat = (s: string): s is \"cat\" => s === \"cat\"\n\t            expect(\n\t                pipe(\n\t                    Result.ok(\"cat\"),\n\t                    Result.refine(isCat, () => \"not a cat\")\n\t                )\n\t            ).toStrictEqual(Result.ok(\"cat\"))\n\t        })\n", "        it(\"returns the onFail result if Ok does not pass the refinement\", () => {\n\t            const isCat = (s: string): s is \"cat\" => s === \"cat\"\n\t            expect(\n\t                pipe(\n\t                    Result.ok(\"dog\"),\n\t                    Result.refine(isCat, a => `${a} is not cat`)\n\t                )\n\t            ).toStrictEqual(Result.err(\"dog is not cat\"))\n\t        })\n\t        it(\"passes Errs through\", () => {\n", "            const isCat = (s: string): s is \"cat\" => s === \"cat\"\n\t            expect(\n\t                pipe(\n\t                    Result.err<number, string>(0),\n\t                    Result.refine(isCat, () => 10)\n\t                )\n\t            ).toStrictEqual(Result.err(0))\n\t        })\n\t    })\n\t})\n"]}
{"filename": "test/Nullable.test.ts", "chunked_list": ["import { describe, it, expect, vi } from \"vitest\"\n\timport * as Nullable from \"../src/Nullable\"\n\timport { pipe } from \"../src/Composition\"\n\timport { EqualityComparer } from \"../src/EqualityComparer\"\n\timport { Array } from \"../src/Array\"\n\timport { NonNullish } from \"../src/prelude\"\n\ttype Nullable<A extends NonNullish> = Nullable.Nullable<A>\n\tdescribe(\"Nullable\", () => {\n\t    describe(\"defaultValue\", () => {\n\t        it.each([[null], [undefined]])(\n", "            \"returns the default value if given a nullish\",\n\t            n => {\n\t                expect(pipe(n, Nullable.defaultValue(42))).toBe(42)\n\t            }\n\t        )\n\t        it.each([[\"\"], [[]], [0], [\"cheese\"], [42], [{}]])(\n\t            \"returns the value if given a non-nullish (including falsy, non-nullish)\",\n\t            val => {\n\t                expect(pipe(val, Nullable.defaultValue<NonNullish>(0))).toBe(val)\n\t            }\n", "        )\n\t    })\n\t    describe(\"defaultWith\", () => {\n\t        it.each([[null], [undefined]])(\n\t            \"returns the default value if given a nullish\",\n\t            n => {\n\t                expect(\n\t                    pipe(\n\t                        n,\n\t                        Nullable.defaultWith(() => 42)\n", "                    )\n\t                ).toBe(42)\n\t            }\n\t        )\n\t        it.each([[\"\"], [[]], [0], [\"cheese\"], [42], [{}]])(\n\t            \"returns the value if given a non-nullish (including falsy, non-nullish)\",\n\t            val => {\n\t                expect(\n\t                    pipe(\n\t                        val,\n", "                        Nullable.defaultWith<NonNullish>(() => 0)\n\t                    )\n\t                ).toBe(val)\n\t            }\n\t        )\n\t    })\n\t    describe(\"map\", () => {\n\t        it.each([[null], [undefined]])(\n\t            \"returns the same nullish value if given a nullish\",\n\t            n => {\n", "                expect(\n\t                    pipe(\n\t                        n,\n\t                        Nullable.map(u => typeof u)\n\t                    )\n\t                ).toBe(n)\n\t            }\n\t        )\n\t        it.each([\n\t            [\"\", \"string\"],\n", "            [[], \"object\"],\n\t            [0, \"number\"],\n\t            [\"cheese\", \"string\"],\n\t            [42, \"number\"],\n\t            [{}, \"object\"],\n\t        ])(\n\t            \"returns the result of the map function if given a non-nullish (including falsy, non-nullish)\",\n\t            (val, expected) => {\n\t                expect(\n\t                    pipe(\n", "                        val,\n\t                        Nullable.map<NonNullish, string>(u => typeof u)\n\t                    )\n\t                ).toBe(expected)\n\t            }\n\t        )\n\t    })\n\t    describe(\"bind\", () => {\n\t        it.each([[null], [undefined]])(\n\t            \"returns the same nullish value if given a nullish\",\n", "            n => {\n\t                expect(\n\t                    pipe(\n\t                        n,\n\t                        Nullable.bind(() => \"cheese\")\n\t                    )\n\t                ).toBe(n)\n\t            }\n\t        )\n\t        it.each([\n", "            [null, null],\n\t            [undefined, undefined],\n\t        ])(\n\t            \"returns the nullish value produced by the bind function if it produces a nullish\",\n\t            (bindFnResult, expected) => {\n\t                const bindFn = vi.fn(() => bindFnResult)\n\t                expect(pipe(\"\", Nullable.bind(bindFn))).toBe(expected)\n\t            }\n\t        )\n\t        it.each([\n", "            [() => 42, 42],\n\t            [() => \"\", \"\"],\n\t            [() => [], []],\n\t            [() => ({}), {}],\n\t            [() => \"A\", \"A\"],\n\t        ])(\n\t            \"returns the result of the bind function if it produces a value\",\n\t            (bindFn, expected) => {\n\t                expect(pipe(\"\", Nullable.bind(bindFn))).toStrictEqual(expected)\n\t            }\n", "        )\n\t    })\n\t    describe(\"getEqualityComparer\", () => {\n\t        it.each([\n\t            [null, undefined],\n\t            [undefined, null],\n\t            [null, null],\n\t            [undefined, undefined],\n\t        ])(\"produces an EqualityComparer that considers %o equivalent to %o\", (a, b) => {\n\t            // arrange\n", "            const { equals } = Nullable.getEqualityComparer(EqualityComparer.String)\n\t            // act & assert\n\t            expect(equals(a, b)).toBe(equals(b, a))\n\t            expect(equals(a, b)).toBe(true)\n\t        })\n\t        it.each([[null], [undefined]])(\n\t            \"produces an EqualityComparer that doesn't consider [] equivalent to %o\",\n\t            falsy => {\n\t                // arrange\n\t                const { equals } = Nullable.getEqualityComparer(\n", "                    Array.getEqualityComparer(EqualityComparer.String)\n\t                )\n\t                // act & assert\n\t                expect(equals([], falsy)).toBe(false)\n\t            }\n\t        )\n\t        it.each([[null], [undefined]])(\n\t            'produces an EqualityComparer that doesn\\'t consider \"\" equivalent to %o',\n\t            falsy => {\n\t                // arrange\n", "                const { equals } = Nullable.getEqualityComparer(EqualityComparer.String)\n\t                // act & assert\n\t                expect(equals(\"\", falsy)).toBe(false)\n\t            }\n\t        )\n\t        it.each([\n\t            [null, \"cheese\", false],\n\t            [undefined, \"cheese\", false],\n\t            [\"rawr\", \"monster\", false],\n\t            [\"\", \"\", true],\n", "            [\"hello\", \"hello\", true],\n\t        ])(\n\t            \"produces an EqualityComparer that considers equals(%o, %o) to be %o\",\n\t            (a, b, expected) => {\n\t                // arrange\n\t                const { equals } = Nullable.getEqualityComparer(EqualityComparer.String)\n\t                // act\n\t                expect(equals(a, b)).toBe(expected)\n\t            }\n\t        )\n", "    })\n\t})\n"]}
{"filename": "test/Deferred.test.ts", "chunked_list": ["import { describe, it, expect } from \"vitest\"\n\timport * as Deferred from \"../src/Deferred\"\n\timport { pipe } from \"../src/Composition\"\n\tdescribe(\"Deferred\", () => {\n\t    describe(\"match\", () => {\n\t        it.each([\n\t            [Deferred.notStarted, \"not started\"],\n\t            [Deferred.inProgress, \"in progress\"],\n\t            [Deferred.resolved(42), \"resolved: 42\"],\n\t        ])(\"matches every case for %o\", (input, expected) => {\n", "            // act\n\t            const actual = pipe(\n\t                input,\n\t                Deferred.match({\n\t                    notStarted: \"not started\",\n\t                    inProgress: () => \"in progress\",\n\t                    resolved: n => `resolved: ${n}`,\n\t                })\n\t            )\n\t            // assert\n", "            expect(actual).toBe(expected)\n\t        })\n\t    })\n\t    describe(\"matchOrElse\", () => {\n\t        it.each([\n\t            [Deferred.notStarted, \"not started\"],\n\t            [Deferred.inProgress, \"unmatched\"],\n\t            [Deferred.resolved(42), \"resolved\"],\n\t        ])(\"matches only specified cases for %o\", (input, expected) => {\n\t            // act\n", "            const actual = pipe(\n\t                input,\n\t                Deferred.matchOrElse({\n\t                    notStarted: \"not started\",\n\t                    resolved: \"resolved\",\n\t                    orElse: () => \"unmatched\",\n\t                })\n\t            )\n\t            // assert\n\t            expect(actual).toBe(expected)\n", "        })\n\t        it(\"considers falsy matcher values as valid\", () => {\n\t            // arrange\n\t            const def1 = Deferred.inProgress\n\t            const def2 = Deferred.notStarted\n\t            const def3 = Deferred.resolved(\"resolve this, bro\")\n\t            // act\n\t            const actual1 = pipe(\n\t                def1,\n\t                Deferred.matchOrElse({\n", "                    inProgress: false,\n\t                    orElse: true,\n\t                })\n\t            )\n\t            const actual2 = pipe(\n\t                def2,\n\t                Deferred.matchOrElse({\n\t                    notStarted: 0,\n\t                    orElse: 1,\n\t                })\n", "            )\n\t            const actual3 = pipe(\n\t                def3,\n\t                Deferred.matchOrElse({\n\t                    resolved: false,\n\t                    orElse: true,\n\t                })\n\t            )\n\t            // assert\n\t            expect(actual1).toBe(false)\n", "            expect(actual2).toBe(0)\n\t            expect(actual3).toBe(false)\n\t        })\n\t    })\n\t    describe(\"isUnresolved\", () => {\n\t        it.each([\n\t            [true, \"in progress\", Deferred.inProgress],\n\t            [true, \"not started\", Deferred.notStarted],\n\t            [false, \"resolved\", Deferred.resolved({})],\n\t        ])(\"returns %o when deferred is %s\", (expected, _, val) => {\n", "            // act\n\t            const actual = Deferred.isUnresolved(val)\n\t            // assert\n\t            expect(actual).toBe(expected)\n\t        })\n\t    })\n\t    describe(\"isInProgress\", () => {\n\t        it.each([\n\t            [true, \"in progress\", Deferred.inProgress],\n\t            [false, \"not started\", Deferred.notStarted],\n", "            [false, \"resolved\", Deferred.resolved({})],\n\t        ])(\"returns %o when deferred is %s\", (expected, _, val) => {\n\t            // act\n\t            const actual = Deferred.isInProgress(val)\n\t            // assert\n\t            expect(actual).toBe(expected)\n\t        })\n\t    })\n\t    describe(\"isResolvedWith\", () => {\n\t        it.each([\n", "            [\"in progress\", Deferred.inProgress],\n\t            [\"not started\", Deferred.notStarted],\n\t        ])(\"returns false if deferred is %s\", (_, val) => {\n\t            // act\n\t            const actual = Deferred.isResolvedWith({})(val)\n\t            // assert\n\t            expect(actual).toBe(false)\n\t        })\n\t        it(\"returns false if deferred is resolved, but not Eq-equivalent to expected\", () => {\n\t            // arrange\n", "            const def = Deferred.resolved(89)\n\t            // act\n\t            const actual = Deferred.isResolvedWith<number>(12)(def)\n\t            // assert\n\t            expect(actual).toBe(false)\n\t        })\n\t        it(\"returns true if deferred is resolved, and is Eq-equivalent to expected\", () => {\n\t            // arrange\n\t            const def = Deferred.resolved(89)\n\t            // act\n", "            const actual = Deferred.isResolvedWith<number>(89)(def)\n\t            // assert\n\t            expect(actual).toBe(true)\n\t        })\n\t    })\n\t    describe(\"isResolved\", () => {\n\t        it.each([\n\t            [false, \"in progress\", Deferred.inProgress],\n\t            [false, \"not started\", Deferred.notStarted],\n\t            [true, \"resolved\", Deferred.resolved({})],\n", "        ])(\"returns %o when deferred is %s\", (expected, _, val) => {\n\t            // act\n\t            const actual = Deferred.isResolved(val)\n\t            // assert\n\t            expect(actual).toBe(expected)\n\t        })\n\t    })\n\t})\n"]}
{"filename": "test/Map.test.ts", "chunked_list": ["import { describe, it, expect, vi } from \"vitest\"\n\timport * as Map from \"../src/Map\"\n\timport { Option } from \"../src/Option\"\n\timport { String } from \"../src/string\"\n\timport { pipe } from \"../src/Composition\"\n\timport { OrderingComparer } from \"../src/OrderingComparer\"\n\timport { EqualityComparer } from \"../src/EqualityComparer\"\n\tinterface Cheese {\n\t    readonly name: string\n\t    readonly age: number\n", "}\n\tconst cheeseByAgeComparer: OrderingComparer<Cheese> = {\n\t    compare: (c1, c2) => (c1.age === c2.age ? 0 : c1.age < c2.age ? -1 : 1),\n\t}\n\tconst cheeseEqualityComparer: EqualityComparer<Cheese> = {\n\t    equals: (c1, c2) => c1.name === c2.name && c1.age === c2.age,\n\t}\n\tdescribe(\"Map\", () => {\n\t    describe(\"set\", () => {\n\t        it(\"sets a new key/value on an empty map\", () => {\n", "            expect(pipe(Map.empty(), Map.set([\"Albus\", 12]))).toStrictEqual(\n\t                Map.ofArray([[\"Albus\", 12]])\n\t            )\n\t        })\n\t        it(\"sets a new key/value on a non-empty map without the same key using default equality\", () => {\n\t            expect(\n\t                pipe(Map.ofArray([[\"Fido\", 44]]), Map.set([\"Albus\", 12]))\n\t            ).toStrictEqual(\n\t                Map.ofArray([\n\t                    [\"Fido\", 44],\n", "                    [\"Albus\", 12],\n\t                ])\n\t            )\n\t        })\n\t        it(\"overrides a key/value to a non-empty map with the same key using default equality\", () => {\n\t            expect(\n\t                pipe(Map.ofArray([[\"Fido\", 44]]), Map.set([\"Fido\", 12]))\n\t            ).toStrictEqual(Map.ofArray([[\"Fido\", 12]]))\n\t        })\n\t        it(\"sets a new key/value on a non-empty map without the same key using custom equality\", () => {\n", "            expect(\n\t                pipe(\n\t                    Map.ofArray([[{ name: \"Gouda\", age: 2 }, \"AA\"]]),\n\t                    Map.set([{ name: \"Cheddar\", age: 0.5 }, \"C\"], cheeseEqualityComparer)\n\t                )\n\t            ).toStrictEqual(\n\t                Map.ofArray([\n\t                    [{ name: \"Gouda\", age: 2 }, \"AA\"],\n\t                    [{ name: \"Cheddar\", age: 0.5 }, \"C\"],\n\t                ])\n", "            )\n\t        })\n\t        it(\"overrides a new key/value on a non-empty map with the same key using custom equality\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofArray([[{ name: \"Gouda\", age: 2 }, \"AA\"]]),\n\t                    Map.set([{ name: \"Gouda\", age: 2 }, \"B\"], cheeseEqualityComparer)\n\t                )\n\t            ).toStrictEqual(Map.ofArray([[{ name: \"Gouda\", age: 2 }, \"B\"]]))\n\t        })\n", "    })\n\t    describe(\"findWithKey\", () => {\n\t        it(\"returns None if the map is empty\", () => {\n\t            expect(pipe(new globalThis.Map(), Map.findWithKey(\"Abby\"))).toStrictEqual(\n\t                Option.none\n\t            )\n\t        })\n\t        it(\"returns None if the key is not in the Map (using default equality)\", () => {\n\t            expect(\n\t                pipe(Map.ofArray([[\"Jared\", 25]]), Map.findWithKey(\"Fubo\"))\n", "            ).toStrictEqual(Option.none)\n\t        })\n\t        it(\"returns Some if the key is in the Map (using default equality)\", () => {\n\t            expect(\n\t                pipe(Map.ofArray([[\"Jared\", 25]]), Map.findWithKey(\"Jared\"))\n\t            ).toStrictEqual(Option.some([\"Jared\", 25]))\n\t        })\n\t        it(\"returns None if the key is not in the Map (using custom equality)\", () => {\n\t            expect(\n\t                pipe(\n", "                    Map.ofArray([[{ name: \"Muenster\", age: 4 }, 25]]),\n\t                    Map.findWithKey({ name: \"Muenster\", age: 3 }, cheeseEqualityComparer)\n\t                )\n\t            ).toStrictEqual(Option.none)\n\t        })\n\t        it(\"returns Some if the key is in the Map (using custom equality)\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofArray([[{ name: \"Muenster\", age: 4 }, 25]]),\n\t                    Map.findWithKey({ name: \"Muenster\", age: 4 }, cheeseEqualityComparer)\n", "                )\n\t            ).toStrictEqual(Option.some([{ name: \"Muenster\", age: 4 }, 25]))\n\t        })\n\t    })\n\t    describe(\"containsKey\", () => {\n\t        it.each([\n\t            [true, \"e\", \"in\"],\n\t            [false, \"f\", \"not in\"],\n\t        ])(\n\t            \"returns %o if the key (%s) is %s the map (default equality)\",\n", "            (expected, letter) => {\n\t                const letterCounts = Map.ofArray([\n\t                    [\"a\", 21],\n\t                    [\"e\", 17],\n\t                ])\n\t                expect(pipe(letterCounts, Map.containsKey(letter))).toBe(expected)\n\t            }\n\t        )\n\t        it.each([\n\t            [true, { name: \"Provolone\", age: 1.5 }, \"in\"],\n", "            [false, { name: \"Brie\", age: 0.5 }, \"not in\"],\n\t        ])(\n\t            \"returns %o if the key (%s) is %s the map (custom equality)\",\n\t            (expected, key) => {\n\t                const cheeseRankings = Map.ofArray([\n\t                    [{ name: \"Provolone\", age: 1.5 }, \"A+\"],\n\t                    [{ name: \"Cheddar\", age: 2 }, \"B-\"],\n\t                ])\n\t                expect(\n\t                    pipe(cheeseRankings, Map.containsKey(key, cheeseEqualityComparer))\n", "                ).toBe(expected)\n\t            }\n\t        )\n\t    })\n\t    describe(\"find\", () => {\n\t        it.each([\n\t            [Option.some(17), \"e\", \"in\"],\n\t            [Option.none, \"f\", \"not in\"],\n\t        ])(\n\t            \"returns the value (%o) if the key (%s) is %s the map (default equality)\",\n", "            (expected, letter) => {\n\t                const letterCounts = Map.ofArray([\n\t                    [\"a\", 21],\n\t                    [\"e\", 17],\n\t                ])\n\t                expect(pipe(letterCounts, Map.find(letter))).toStrictEqual(expected)\n\t            }\n\t        )\n\t        it.each([\n\t            [Option.some(\"A+\"), { name: \"Provolone\", age: 1.5 }, \"in\"],\n", "            [Option.none, { name: \"Brie\", age: 0.5 }, \"not in\"],\n\t        ])(\n\t            \"returns the value (%o) if the key (%s) is %s the map (custom equality)\",\n\t            (expected, key) => {\n\t                const cheeseRankings = Map.ofArray([\n\t                    [{ name: \"Provolone\", age: 1.5 }, \"A+\"],\n\t                    [{ name: \"Cheddar\", age: 2 }, \"B-\"],\n\t                ])\n\t                expect(\n\t                    pipe(cheeseRankings, Map.find(key, cheeseEqualityComparer))\n", "                ).toStrictEqual(expected)\n\t            }\n\t        )\n\t    })\n\t    describe(\"map\", () => {\n\t        it(\"returns an empty map if given an empty map\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.empty(),\n\t                    Map.map(() => 0)\n", "                )\n\t            ).toStrictEqual(Map.empty())\n\t        })\n\t        it(\"returns a new map containing mapped values\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofArray([\n\t                        [\"John\", 23],\n\t                        [\"George\", 8],\n\t                        [\"Jimmy\", 88],\n", "                    ]),\n\t                    Map.map((name, age) => `${name}:${age - 3}`)\n\t                )\n\t            ).toStrictEqual(\n\t                Map.ofArray([\n\t                    [\"John\", \"John:20\"],\n\t                    [\"George\", \"George:5\"],\n\t                    [\"Jimmy\", \"Jimmy:85\"],\n\t                ])\n\t            )\n", "        })\n\t    })\n\t    describe(\"findKey\", () => {\n\t        it(\"returns None for an empty map\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.empty(),\n\t                    Map.findKey((n: number) => n === 20)\n\t                )\n\t            ).toStrictEqual(Option.none)\n", "        })\n\t        it(\"returns the first key for which the predicate returns true (default sort)\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofArray([\n\t                        [\"b\", 2],\n\t                        [\"d\", 4],\n\t                        [\"a\", 1],\n\t                        [\"c\", 3],\n\t                    ]),\n", "                    Map.findKey(s => s.length === 1)\n\t                )\n\t            ).toStrictEqual(Option.some(\"a\"))\n\t        })\n\t        it(\"returns None if no key matches the predicate (default sort)\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofArray([\n\t                        [\"b\", 2],\n\t                        [\"d\", 4],\n", "                        [\"a\", 1],\n\t                        [\"c\", 3],\n\t                    ]),\n\t                    Map.findKey(s => s.length === 2)\n\t                )\n\t            ).toStrictEqual(Option.none)\n\t        })\n\t        it(\"returns the first key for which the predicate returns true (custom sort)\", () => {\n\t            expect(\n\t                pipe(\n", "                    Map.ofArray([\n\t                        [{ name: \"Mozzarella\", age: 2 }, 2],\n\t                        [{ name: \"Provolone\", age: 1 }, 4],\n\t                        [{ name: \"Provolone\", age: 0.5 }, 1],\n\t                        [{ name: \"Cheddar\", age: 3 }, 3],\n\t                    ]),\n\t                    Map.findKey(\n\t                        cheese => cheese.name === \"Provolone\",\n\t                        cheeseByAgeComparer\n\t                    )\n", "                )\n\t            ).toStrictEqual(Option.some({ name: \"Provolone\", age: 0.5 }))\n\t        })\n\t        it(\"returns None if no key matches the predicate (custom sort)\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofArray([\n\t                        [{ name: \"Mozzarella\", age: 2 }, 2],\n\t                        [{ name: \"Provolone\", age: 1 }, 4],\n\t                        [{ name: \"Provolone\", age: 0.5 }, 1],\n", "                        [{ name: \"Cheddar\", age: 3 }, 3],\n\t                    ]),\n\t                    Map.findKey(cheese => cheese.name === \"Muenster\", cheeseByAgeComparer)\n\t                )\n\t            ).toStrictEqual(Option.none)\n\t        })\n\t    })\n\t    describe(\"empty\", () => {\n\t        it(\"returns an empty map\", () => {\n\t            expect(Map.empty()).toStrictEqual(new globalThis.Map())\n", "        })\n\t    })\n\t    describe(\"exists\", () => {\n\t        it(\"returns false for an empty map\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.empty(),\n\t                    Map.exists(() => true)\n\t                )\n\t            ).toBe(false)\n", "        })\n\t        it(\"returns false if no value in the map matches the predicate\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofArray([\n\t                        [\"Cat\", 1],\n\t                        [\"Dog\", 3],\n\t                        [\"Mouse\", 0],\n\t                    ]),\n\t                    Map.exists(n => n < 0)\n", "                )\n\t            ).toBe(false)\n\t        })\n\t        it(\"returns true if at least one value in the map matches the predicate\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofArray([\n\t                        [\"Cat\", 1],\n\t                        [\"Dog\", 3],\n\t                        [\"Mouse\", 0],\n", "                    ]),\n\t                    Map.exists(n => n > 2)\n\t                )\n\t            ).toBe(true)\n\t        })\n\t    })\n\t    describe(\"change\", () => {\n\t        describe(\"default equality\", () => {\n\t            it(\"returns the map unchanged if the key doesn't exist\", () => {\n\t                expect(\n", "                    pipe(\n\t                        Map.ofArray([\n\t                            [\"Cat\", 1],\n\t                            [\"Dog\", 2],\n\t                        ]),\n\t                        Map.change(\"Mouse\", n => n + 1)\n\t                    )\n\t                ).toStrictEqual(\n\t                    Map.ofArray([\n\t                        [\"Cat\", 1],\n", "                        [\"Dog\", 2],\n\t                    ])\n\t                )\n\t            })\n\t            it(\"returns the map with changed binding if the key does exist\", () => {\n\t                expect(\n\t                    pipe(\n\t                        Map.ofArray([\n\t                            [\"Cat\", 1],\n\t                            [\"Dog\", 2],\n", "                        ]),\n\t                        Map.change(\"Dog\", n => n + 1)\n\t                    )\n\t                ).toStrictEqual(\n\t                    Map.ofArray([\n\t                        [\"Cat\", 1],\n\t                        [\"Dog\", 3],\n\t                    ])\n\t                )\n\t            })\n", "        })\n\t        describe(\"custom equality\", () => {\n\t            it(\"returns the map unchanged if the key doesn't exist\", () => {\n\t                expect(\n\t                    pipe(\n\t                        Map.ofArray([\n\t                            [{ name: \"Cheddar\", age: 1 }, 1],\n\t                            [{ name: \"Mozzarella\", age: 0.25 }, 2],\n\t                        ]),\n\t                        Map.change(\n", "                            { name: \"Provolone\", age: 0 },\n\t                            n => n + 1,\n\t                            cheeseEqualityComparer\n\t                        )\n\t                    )\n\t                ).toStrictEqual(\n\t                    Map.ofArray([\n\t                        [{ name: \"Cheddar\", age: 1 }, 1],\n\t                        [{ name: \"Mozzarella\", age: 0.25 }, 2],\n\t                    ])\n", "                )\n\t            })\n\t            it(\"returns the map with changed binding if the key does exist\", () => {\n\t                expect(\n\t                    pipe(\n\t                        Map.ofArray([\n\t                            [{ name: \"Cheddar\", age: 1 }, 1],\n\t                            [{ name: \"Mozzarella\", age: 0.25 }, 2],\n\t                        ]),\n\t                        Map.change(\n", "                            { name: \"Cheddar\", age: 1 },\n\t                            n => n + 1,\n\t                            cheeseEqualityComparer\n\t                        )\n\t                    )\n\t                ).toStrictEqual(\n\t                    Map.ofArray([\n\t                        [{ name: \"Cheddar\", age: 1 }, 2],\n\t                        [{ name: \"Mozzarella\", age: 0.25 }, 2],\n\t                    ])\n", "                )\n\t            })\n\t        })\n\t    })\n\t    describe(\"remove\", () => {\n\t        it(\"removes the key from the map (default equality)\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofRecord<string, number>({\n\t                        DinJarin: 10,\n", "                        Meredith: 20,\n\t                        Grogu: 9001,\n\t                    }),\n\t                    Map.remove(\"Meredith\")\n\t                )\n\t            ).toStrictEqual(\n\t                Map.ofArray([\n\t                    [\"DinJarin\", 10],\n\t                    [\"Grogu\", 9001],\n\t                ])\n", "            )\n\t        })\n\t        it(\"doesn't change the map if the key doesn't exist (default equality)\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofRecord<string, number>({\n\t                        DinJarin: 10,\n\t                        Grogu: 9001,\n\t                    }),\n\t                    Map.remove(\"Jimmy\")\n", "                )\n\t            ).toStrictEqual(\n\t                Map.ofArray([\n\t                    [\"DinJarin\", 10],\n\t                    [\"Grogu\", 9001],\n\t                ])\n\t            )\n\t        })\n\t        it(\"removes the key from the map (custom equality)\", () => {\n\t            expect(\n", "                pipe(\n\t                    Map.ofArray(\n\t                        [\n\t                            [{ name: \"American\", age: 0.1 }, 0],\n\t                            [{ name: \"Provolone\", age: 2 }, 23],\n\t                            [{ name: \"Sharp Cheddar\", age: 3 }, 12],\n\t                        ],\n\t                        cheeseEqualityComparer\n\t                    ),\n\t                    Map.remove({ name: \"Provolone\", age: 2 }, cheeseEqualityComparer)\n", "                )\n\t            ).toStrictEqual(\n\t                Map.ofArray(\n\t                    [\n\t                        [{ name: \"American\", age: 0.1 }, 0],\n\t                        [{ name: \"Sharp Cheddar\", age: 3 }, 12],\n\t                    ],\n\t                    cheeseEqualityComparer\n\t                )\n\t            )\n", "        })\n\t        it(\"doesn't change the map if the key doesn't exist (custom equality)\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofArray(\n\t                        [\n\t                            [{ name: \"American\", age: 0.1 }, 0],\n\t                            [{ name: \"Sharp Cheddar\", age: 3 }, 12],\n\t                        ],\n\t                        cheeseEqualityComparer\n", "                    ),\n\t                    Map.remove({ name: \"Provolone\", age: 2 }, cheeseEqualityComparer)\n\t                )\n\t            ).toStrictEqual(\n\t                Map.ofArray(\n\t                    [\n\t                        [{ name: \"American\", age: 0.1 }, 0],\n\t                        [{ name: \"Sharp Cheddar\", age: 3 }, 12],\n\t                    ],\n\t                    cheeseEqualityComparer\n", "                )\n\t            )\n\t        })\n\t    })\n\t    describe(\"iter\", () => {\n\t        it(\"never calls the given fucntion for an empty map\", () => {\n\t            const fn = vi.fn()\n\t            pipe(Map.empty(), Map.iter(fn))\n\t            expect(fn).not.toHaveBeenCalled()\n\t        })\n", "        it(\"executes the given function for every key/value pair\", () => {\n\t            // arrange\n\t            const fn = vi.fn()\n\t            // act\n\t            pipe(\n\t                Map.ofRecord({\n\t                    \"red team\": 44,\n\t                    \"blue team\": 48,\n\t                    \"green team\": 13,\n\t                }),\n", "                Map.iter(fn)\n\t            )\n\t            // assert\n\t            expect(fn).toHaveBeenCalledTimes(3)\n\t            ;(\n\t                [\n\t                    [\"red team\", 44],\n\t                    [\"blue team\", 48],\n\t                    [\"green team\", 13],\n\t                ] as const\n", "            ).forEach(([k, v]) => expect(fn).toHaveBeenCalledWith(k, v))\n\t        })\n\t    })\n\t    describe(\"isEmpty\", () => {\n\t        it.each([\n\t            [true, \"empty\", []],\n\t            [\n\t                false,\n\t                \"not empty\",\n\t                [\n", "                    [\"key1\", \"val1\"],\n\t                    [\"key2\", \"val2\"],\n\t                ],\n\t            ],\n\t        ] as const)(\"returns %o if the map is %s\", (expected, _, bindings) => {\n\t            expect(pipe(Map.ofArray(bindings), Map.isEmpty)).toBe(expected)\n\t        })\n\t    })\n\t    describe(\"size\", () => {\n\t        it.each([\n", "            [0, []],\n\t            [1, [[\"dog\", 1]]],\n\t            [\n\t                3,\n\t                [\n\t                    [\"dog\", 1],\n\t                    [\"cat\", 2],\n\t                    [\"mouse\", 3],\n\t                ],\n\t            ],\n", "        ] as const)(\"returns the size (%i) of the map\", (expected, bindings) => {\n\t            expect(pipe(Map.ofArray(bindings), Map.size)).toBe(expected)\n\t        })\n\t    })\n\t    describe(\"keys\", () => {\n\t        it.each([\n\t            [\"empty\", [], []],\n\t            [\n\t                \"non-empty\",\n\t                [\n", "                    [\"Johnny\", 1],\n\t                    [\"Amy\", 2],\n\t                    [\"Leonard\", 3],\n\t                ],\n\t                [\"Amy\", \"Johnny\", \"Leonard\"],\n\t            ],\n\t        ] as const)(\n\t            \"returns the keys in the expected order when the map is %s (default comparison)\",\n\t            (_, bindings, expected) => {\n\t                expect(pipe(Map.ofArray(bindings), Map.keys())).toStrictEqual(expected)\n", "            }\n\t        )\n\t        it.each([\n\t            [\"empty\", [], []],\n\t            [\n\t                \"non-empty\",\n\t                [\n\t                    [{ name: \"Muenster\", age: 3 }, \"A+\"],\n\t                    [{ name: \"Cheddar\", age: 2 }, \"B\"],\n\t                    [{ name: \"Kraft Single\", age: 4 }, \"F-\"],\n", "                ],\n\t                [\n\t                    { name: \"Cheddar\", age: 2 },\n\t                    { name: \"Muenster\", age: 3 },\n\t                    { name: \"Kraft Single\", age: 4 },\n\t                ],\n\t            ],\n\t        ])(\n\t            \"returns the keys in the expected order when the map is %s (custom comparison)\",\n\t            (_, bindings, expected) => {\n", "                expect(\n\t                    pipe(\n\t                        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n\t                        Map.ofArray<Cheese, string>(bindings as any),\n\t                        Map.keys(cheeseByAgeComparer)\n\t                    )\n\t                ).toStrictEqual(expected)\n\t            }\n\t        )\n\t    })\n", "    describe(\"values\", () => {\n\t        it.each([\n\t            [\"empty\", [], []],\n\t            [\n\t                \"non-empty\",\n\t                [\n\t                    [\"Johnny\", 2],\n\t                    [\"Amy\", 3],\n\t                    [\"Leonard\", 1],\n\t                ],\n", "                [1, 2, 3],\n\t            ],\n\t        ] as const)(\n\t            \"returns the values in the expected order (including duplicates) when the map is %s (default comparison)\",\n\t            (_, bindings, expected) => {\n\t                expect(pipe(Map.ofArray(bindings), Map.values())).toStrictEqual(expected)\n\t            }\n\t        )\n\t        it.each([\n\t            [\"empty\", [], []],\n", "            [\n\t                \"non-empty\",\n\t                [\n\t                    [\"1\", { name: \"Muenster\", age: 3 }],\n\t                    [\"2\", { name: \"Cheddar\", age: 2 }],\n\t                    [\"3\", { name: \"Kraft Single\", age: 4 }],\n\t                ],\n\t                [\n\t                    { name: \"Cheddar\", age: 2 },\n\t                    { name: \"Muenster\", age: 3 },\n", "                    { name: \"Kraft Single\", age: 4 },\n\t                ],\n\t            ],\n\t        ])(\n\t            \"returns the values in the expected order (including duplicates) when the map is %s (custom comparison)\",\n\t            (_, bindings, expected) => {\n\t                expect(\n\t                    pipe(\n\t                        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n\t                        Map.ofArray<string, Cheese>(bindings as any),\n", "                        Map.values(cheeseByAgeComparer)\n\t                    )\n\t                ).toStrictEqual(expected)\n\t            }\n\t        )\n\t    })\n\t    describe(\"toArray\", () => {\n\t        it(\"returns an empty array for an empty map\", () => {\n\t            expect(pipe(new globalThis.Map(), Map.toArray())).toStrictEqual([])\n\t        })\n", "        it(\"returns an array of tuples sorted by key (default comparison)\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofArray([\n\t                        [\"b\", 2],\n\t                        [\"d\", 4],\n\t                        [\"c\", 3],\n\t                        [\"a\", 1],\n\t                    ]),\n\t                    Map.toArray()\n", "                )\n\t            ).toStrictEqual([\n\t                [\"a\", 1],\n\t                [\"b\", 2],\n\t                [\"c\", 3],\n\t                [\"d\", 4],\n\t            ])\n\t        })\n\t        it(\"returns an array of tuples sorted by key (custom comparison)\", () => {\n\t            expect(\n", "                pipe(\n\t                    Map.ofArray([\n\t                        [{ name: \"Gouda\", age: 2 }, 2],\n\t                        [{ name: \"Mozzarella\", age: 4 }, 4],\n\t                        [{ name: \"Garganzola\", age: 3 }, 3],\n\t                        [{ name: \"Swiss\", age: 1 }, 1],\n\t                    ]),\n\t                    Map.toArray(cheeseByAgeComparer)\n\t                )\n\t            ).toStrictEqual([\n", "                [{ name: \"Swiss\", age: 1 }, 1],\n\t                [{ name: \"Gouda\", age: 2 }, 2],\n\t                [{ name: \"Garganzola\", age: 3 }, 3],\n\t                [{ name: \"Mozzarella\", age: 4 }, 4],\n\t            ])\n\t        })\n\t    })\n\t    describe(\"filter\", () => {\n\t        it(\"returns an empty map if given an empty map\", () => {\n\t            expect(\n", "                pipe(\n\t                    Map.empty(),\n\t                    Map.filter(() => true)\n\t                )\n\t            ).toStrictEqual(Map.empty())\n\t        })\n\t        it(\"filters out keys that fail the predicate\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofRecord({\n", "                        cheese: \"yum\",\n\t                        soup: \"yum\",\n\t                        veggies: \"bleh\",\n\t                        crackers: \"yum\",\n\t                        \"lima beans\": \"bleh\",\n\t                    }),\n\t                    Map.filter((_, v) => v === \"yum\")\n\t                )\n\t            ).toStrictEqual(\n\t                Map.ofArray([\n", "                    [\"cheese\", \"yum\"],\n\t                    [\"soup\", \"yum\"],\n\t                    [\"crackers\", \"yum\"],\n\t                ])\n\t            )\n\t        })\n\t    })\n\t    describe(\"every\", () => {\n\t        it(\"returns true for an empty map\", () => {\n\t            expect(\n", "                pipe(\n\t                    Map.empty(),\n\t                    Map.every(() => false)\n\t                )\n\t            ).toBe(true)\n\t        })\n\t        it(\"returns true if every key/value pair holds true\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofRecord({\n", "                        John: \"Hancock\",\n\t                        James: \"Monroe\",\n\t                        Alexander: \"Hamilton\",\n\t                    }),\n\t                    Map.every((first, last) => first.length > 0 && last.length > 0)\n\t                )\n\t            ).toBe(true)\n\t        })\n\t        it(\"returns false if not every key/value pair holds true\", () => {\n\t            expect(\n", "                pipe(\n\t                    Map.ofRecord({\n\t                        John: \"\",\n\t                        James: \"Monroe\",\n\t                        Alexander: \"Hamilton\",\n\t                    }),\n\t                    Map.every((first, last) => first.length > 0 && last.length > 0)\n\t                )\n\t            ).toBe(false)\n\t        })\n", "    })\n\t    describe(\"reduce\", () => {\n\t        it(\"reduces using default sort order\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofArray([\n\t                        [\"a\", \"1\"],\n\t                        [\"c\", \"3\"],\n\t                        [\"b\", \"2\"],\n\t                    ]),\n", "                    Map.reduce(\"\", (acc, k, v) => `${acc}${k}${v}`)\n\t                )\n\t            ).toBe(\"a1b2c3\")\n\t        })\n\t        it(\"reduces using custom sort order\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofArray([\n\t                        [{ name: \"Parmesean\", age: 1 }, \"Parm\"],\n\t                        [{ name: \"Gouda\", age: 3 }, \"Goodie\"],\n", "                        [{ name: \"Gruyere\", age: 2 }, \"Weird Swiss\"],\n\t                    ]),\n\t                    Map.reduce(\n\t                        \"\",\n\t                        (acc, { name }, v) => `${acc}\\n${name}-${v}`,\n\t                        cheeseByAgeComparer\n\t                    ),\n\t                    String.trim\n\t                )\n\t            ).toBe(\n", "                pipe(\n\t                    `\n\tParmesean-Parm\n\tGruyere-Weird Swiss\n\tGouda-Goodie\n\t                    `,\n\t                    String.trim\n\t                )\n\t            )\n\t        })\n", "    })\n\t    describe(\"reduceRight\", () => {\n\t        it(\"reduces in reverse order, using default sort order\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofArray([\n\t                        [\"a\", \"1\"],\n\t                        [\"c\", \"3\"],\n\t                        [\"b\", \"2\"],\n\t                    ]),\n", "                    Map.reduceRight(\"\", (acc, k, v) => `${acc}${k}${v}`)\n\t                )\n\t            ).toBe(\"c3b2a1\")\n\t        })\n\t        it(\"reduces in reverse order using custom sort order\", () => {\n\t            expect(\n\t                pipe(\n\t                    Map.ofArray([\n\t                        [{ name: \"Parmesean\", age: 1 }, \"Parm\"],\n\t                        [{ name: \"Gouda\", age: 3 }, \"Goodie\"],\n", "                        [{ name: \"Gruyere\", age: 2 }, \"Weird Swiss\"],\n\t                    ]),\n\t                    Map.reduceRight(\n\t                        \"\",\n\t                        (acc, { name }, v) => `${acc}\\n${name}-${v}`,\n\t                        cheeseByAgeComparer\n\t                    ),\n\t                    String.trim\n\t                )\n\t            ).toBe(\n", "                pipe(\n\t                    `\n\tGouda-Goodie\n\tGruyere-Weird Swiss\n\tParmesean-Parm\n\t                    `,\n\t                    String.trim\n\t                )\n\t            )\n\t        })\n", "    })\n\t})\n"]}
{"filename": "test/EqualityComparer.test.ts", "chunked_list": ["import { describe, it, expect } from \"vitest\"\n\timport * as EqualityComparer from \"../src/EqualityComparer\"\n\tinterface ParentThing {\n\t    readonly id: string\n\t    readonly child: Thing\n\t}\n\tinterface Thing {\n\t    readonly id: number\n\t}\n\tdescribe(\"EqualityComparer\", () => {\n", "    describe(\"ofEquals\", () => {\n\t        const thing = { id: 1 }\n\t        it.each([\n\t            [true, \"equal\", { id: 12 }, { id: 12 }],\n\t            [false, \"not equal\", { id: 3 }, { id: 9 }],\n\t            [true, \"same exact reference\", thing, thing],\n\t        ])(\n\t            \"constructs an equality comparer from an equals function (returns %o when %s)\",\n\t            (expected, _, t1, t2) => {\n\t                const eq = EqualityComparer.ofEquals<Thing>(\n", "                    (thing1, thing2) => thing1.id === thing2.id\n\t                )\n\t                expect(eq.equals(t1, t2)).toBe(eq.equals(t2, t1))\n\t                expect(eq.equals(t1, t2)).toBe(expected)\n\t            }\n\t        )\n\t    })\n\t    describe(\"deriveFrom\", () => {\n\t        const thing = { id: 1 }\n\t        it.each([\n", "            [true, \"equal\", { id: 12 }, { id: 12 }],\n\t            [false, \"not equal\", { id: 3 }, { id: 9 }],\n\t            [true, \"same exact reference\", thing, thing],\n\t        ])(\n\t            \"constructs an equality comparer from an existing one + a (contra)map function [returns %o when %s]\",\n\t            (expected, _, t1, t2) => {\n\t                const eq = EqualityComparer.deriveFrom<number, Thing>(\n\t                    EqualityComparer.Number,\n\t                    thing => thing.id\n\t                )\n", "                expect(eq.equals(t1, t2)).toBe(eq.equals(t2, t1))\n\t                expect(eq.equals(t1, t2)).toBe(expected)\n\t            }\n\t        )\n\t    })\n\t    describe(\"ofStruct\", () => {\n\t        const eqChild = EqualityComparer.ofStruct<Thing>({\n\t            id: EqualityComparer.Number,\n\t        })\n\t        const eqParent = EqualityComparer.ofStruct<ParentThing>({\n", "            id: EqualityComparer.String,\n\t            child: eqChild,\n\t        })\n\t        it(\"returns true if comparing the exact same reference\", () => {\n\t            const parent: ParentThing = {\n\t                id: \"101\",\n\t                child: { id: 20 },\n\t            }\n\t            expect(eqParent.equals(parent, parent)).toBe(true)\n\t        })\n", "        it(\"returns true if comparing two structurally equivalent values\", () => {\n\t            const p1: ParentThing = {\n\t                id: \"101\",\n\t                child: { id: 20 },\n\t            }\n\t            const p2: ParentThing = {\n\t                id: \"101\",\n\t                child: { id: 20 },\n\t            }\n\t            expect(eqParent.equals(p1, p2)).toBe(eqParent.equals(p2, p1))\n", "            expect(eqParent.equals(p1, p2)).toBe(true)\n\t        })\n\t        it(\"returns false if comparing two structurally inequivalent values\", () => {\n\t            const p1: ParentThing = {\n\t                id: \"101\",\n\t                child: { id: 20 },\n\t            }\n\t            const p2: ParentThing = {\n\t                id: \"10\",\n\t                child: { id: 20 },\n", "            }\n\t            expect(eqParent.equals(p1, p2)).toBe(eqParent.equals(p2, p1))\n\t            expect(eqParent.equals(p1, p2)).toBe(false)\n\t        })\n\t    })\n\t    describe(\"Date\", () => {\n\t        const piDay = new Date(2023, 2, 14)\n\t        it.each([\n\t            [true, \"equal\", new Date(2023, 2, 15), new Date(2023, 2, 15)],\n\t            [true, \"same exact reference\", piDay, piDay],\n", "            [false, \"not equal\", new Date(2023, 2, 15), new Date(2025, 1, 15)],\n\t        ])(\n\t            \"provides equality for dates (returns %o when %s)\",\n\t            (expected, _, dt1, dt2) => {\n\t                const { equals } = EqualityComparer.Date\n\t                expect(equals(dt1, dt2)).toBe(equals(dt2, dt1))\n\t                expect(equals(dt1, dt2)).toBe(expected)\n\t            }\n\t        )\n\t    })\n", "})\n"]}
{"filename": "test/function.test.ts", "chunked_list": ["import { describe, it, expect, vi } from \"vitest\"\n\timport { tee, teeAsync } from \"../src/function\"\n\timport { flow, pipe } from \"../src/Composition\"\n\tdescribe(\"function\", () => {\n\t    describe(\"tee\", () => {\n\t        it(\"executes the side effect and passes through the value\", () => {\n\t            // arrange\n\t            const log = vi.fn()\n\t            const double = (n: number) => n * 2\n\t            // act\n", "            const actual = pipe(42, tee(log), double, String)\n\t            // assert\n\t            expect(actual).toBe(\"84\")\n\t            expect(log).toHaveBeenCalledOnce()\n\t            expect(log).toHaveBeenCalledWith(42)\n\t        })\n\t    })\n\t    describe(\"teeAsync\", () => {\n\t        it(\"executes the side effect on the resolved value and passes through the promise\", async () => {\n\t            // arrange\n", "            const log: (n: number) => void = vi.fn()\n\t            const double = (n: number) => n * 2\n\t            // act\n\t            const actual = await pipe(Promise.resolve(42), teeAsync(log), p =>\n\t                p.then(flow(double, String))\n\t            )\n\t            // assert\n\t            expect(actual).toBe(\"84\")\n\t            expect(log).toHaveBeenCalledOnce()\n\t            expect(log).toHaveBeenCalledWith(42)\n", "        })\n\t    })\n\t})\n"]}
{"filename": "test/Async.test.ts", "chunked_list": ["import { describe, it, expect, vi } from \"vitest\"\n\timport { pipe } from \"../src/Composition\"\n\timport * as Async from \"../src/Async\"\n\ttype Async<A> = Async.Async<A>\n\tdescribe(\"Async\", () => {\n\t    describe(\"constructors\", () => {\n\t        describe(\"of\", () => {\n\t            it(\"wraps a value in an Async\", async () => {\n\t                expect(await Async.of(22)()).toBe(22)\n\t            })\n", "        })\n\t        describe(\"ofPromise\", () => {\n\t            it(\"wraps a promise in a lambda\", async () => {\n\t                expect(\n\t                    await pipe(\n\t                        Promise.resolve(\"zebra skin\"),\n\t                        Async.ofPromise,\n\t                        Async.map(s => s.length),\n\t                        Async.start\n\t                    )\n", "                ).toBe(10)\n\t            })\n\t        })\n\t    })\n\t    describe(\"map\", () => {\n\t        it(\"maps the inner value\", async () => {\n\t            expect(\n\t                await pipe(\n\t                    Async.of(\"cheese\"),\n\t                    Async.map(s => `${s} melted`),\n", "                    Async.start\n\t                )\n\t            ).toBe(\"cheese melted\")\n\t        })\n\t    })\n\t    describe(\"bind\", () => {\n\t        it(\"flatMaps the inner value\", async () => {\n\t            // arrange\n\t            const asyncIncr = (n: number) => Async.of(n + 1)\n\t            // act\n", "            const actual = await pipe(Async.of(2), Async.bind(asyncIncr), Async.start)\n\t            // assert\n\t            expect(actual).toBe(3)\n\t        })\n\t    })\n\t    describe(\"flatten\", () => {\n\t        it(\"flattens a nested structure\", async () => {\n\t            expect(await pipe(Async.of(Async.of(\"a\")), Async.flatten, Async.start)).toBe(\n\t                \"a\"\n\t            )\n", "        })\n\t    })\n\t    describe(\"sequential\", () => {\n\t        it(\"executes the computations in series and collects the results\", async () => {\n\t            // arrange\n\t            vi.useFakeTimers()\n\t            const comp1 = pipe(Async.of(\"1\"))\n\t            const comp2 = pipe(Async.of(\"2\"), Async.delay(500))\n\t            const comp3 = pipe(Async.of(\"3\"), Async.delay(1000))\n\t            // act\n", "            const promise = pipe([comp3, comp2, comp1], Async.sequential, Async.start)\n\t            await vi.runAllTimersAsync()\n\t            const actual = await promise\n\t            // assert\n\t            expect(actual).toStrictEqual([\"3\", \"2\", \"1\"])\n\t            // cleanup\n\t            vi.useRealTimers()\n\t        })\n\t    })\n\t    describe(\"parallel\", () => {\n", "        it(\"executes the computations in parallel and collects the results\", async () => {\n\t            // arrange\n\t            vi.useFakeTimers()\n\t            const log = vi.fn()\n\t            const comp1 = pipe(Async.of(\"1\"), Async.tee(log))\n\t            const comp2 = pipe(Async.of(\"2\"), Async.delay(500), Async.tee(log))\n\t            const comp3 = pipe(Async.of(\"3\"), Async.delay(1000), Async.tee(log))\n\t            // act\n\t            const promise = pipe([comp3, comp2, comp1], Async.parallel, Async.start)\n\t            await vi.runAllTimersAsync()\n", "            const actual = await promise\n\t            // assert\n\t            expect(log).toHaveBeenCalledTimes(3)\n\t            expect(log.mock.calls).toStrictEqual([[\"1\"], [\"2\"], [\"3\"]])\n\t            ;[\"1\", \"2\", \"3\"].forEach(i => {\n\t                expect(actual).toContain(i)\n\t            })\n\t            // cleanup\n\t            vi.useRealTimers()\n\t        })\n", "    })\n\t    describe(\"asyncify\", () => {\n\t        it(\"converts a function with a single argument\", async () => {\n\t            // arrange\n\t            const fakeIO = (fileName: string) => Promise.resolve([\".txt\", fileName])\n\t            const asyncified = Async.asyncify(fakeIO)\n\t            // act\n\t            const actual = await asyncified(\"file\")()\n\t            // assert\n\t            expect(actual).toStrictEqual([\".txt\", \"file\"])\n", "        })\n\t        it(\"converts a function with multiple arguments\", async () => {\n\t            // arrange\n\t            const fakeIO = (fileName: string, lineNumber: number) =>\n\t                Promise.resolve([\".txt\", fileName, `L${lineNumber}`])\n\t            const asyncified = Async.asyncify(fakeIO)\n\t            // act\n\t            const actual = await asyncified(\"file\", 32)()\n\t            // assert\n\t            expect(actual).toStrictEqual([\".txt\", \"file\", \"L32\"])\n", "        })\n\t        it(\"converts a function with multiple, mixed, array, object, and primitive arguments\", async () => {\n\t            // arrange\n\t            const fakeIO = (\n\t                fileName: string,\n\t                extension: \".txt\" | \".md\",\n\t                lines: number[],\n\t                options?: { skipChecks?: boolean }\n\t            ) =>\n\t                Promise.resolve([\n", "                    extension,\n\t                    fileName,\n\t                    `Lines:${lines.join(\",\")}`,\n\t                    `Options:{ skipChecks = ${options?.skipChecks} }`,\n\t                ])\n\t            const asyncified = Async.asyncify(fakeIO)\n\t            // act\n\t            const actual = await asyncified(\"file\", \".md\", [2, 8, 22], {\n\t                skipChecks: false,\n\t            })()\n", "            // assert\n\t            expect(actual).toStrictEqual([\n\t                \".md\",\n\t                \"file\",\n\t                \"Lines:2,8,22\",\n\t                \"Options:{ skipChecks = false }\",\n\t            ])\n\t        })\n\t    })\n\t    describe(\"tee\", () => {\n", "        it(\"allows executing an arbitrary side effect without affecting the inner value\", async () => {\n\t            // arrange\n\t            const log = vi.fn<number[], void>()\n\t            const logDouble = (n: number) => log(n * 2)\n\t            // act\n\t            const actual = await pipe(\n\t                Async.of(100),\n\t                Async.tee(logDouble),\n\t                Async.map(String),\n\t                Async.start\n", "            )\n\t            // assert\n\t            expect(actual).toBe(\"100\")\n\t            expect(log).toHaveBeenCalledOnce()\n\t            expect(log).toHaveBeenCalledWith(200)\n\t        })\n\t    })\n\t    describe(\"start\", () => {\n\t        it(\"is equivalent to invoking the async as a lambda\", async () => {\n\t            // arrange\n", "            const mock = vi.fn(() => Promise.resolve(\"a\"))\n\t            const f: Async<string> = () => mock()\n\t            // act\n\t            const actual1 = await Async.start(f)\n\t            const actual2 = await f()\n\t            // assert\n\t            expect(mock).toHaveBeenCalledTimes(2)\n\t            expect(actual1).toBe(\"a\")\n\t            expect(actual2).toBe(\"a\")\n\t        })\n", "    })\n\t    describe(\"never\", () => {\n\t        it(\"never resolves\", () => {\n\t            // arrange\n\t            vi.useFakeTimers()\n\t            const f = vi.fn()\n\t            // act\n\t            void pipe(Async.never, Async.tee(f), Async.start)\n\t            vi.advanceTimersByTime(10_000_000)\n\t            // assert\n", "            expect(f).not.toHaveBeenCalled()\n\t            // cleanup\n\t            vi.useRealTimers()\n\t        })\n\t    })\n\t    describe(\"delay\", () => {\n\t        it(\"normalizes the delay to a natural number\", async () => {\n\t            // act\n\t            const setTimeoutSpy = vi.spyOn(globalThis, \"setTimeout\")\n\t            const actual = await pipe(Async.unit, Async.delay(-100), Async.start)\n", "            // assert\n\t            expect(actual).toBeDefined()\n\t            expect(setTimeoutSpy).toHaveBeenCalledWith(expect.anything(), 0)\n\t            expect(setTimeoutSpy).not.toHaveBeenCalledWith(expect.anything(), -100)\n\t        })\n\t    })\n\t})\n"]}
{"filename": "test/NonEmptyArray.test.ts", "chunked_list": ["import { describe, it, expect } from \"vitest\"\n\timport * as NonEmptyArray from \"../src/NonEmptyArray\"\n\timport { pipe } from \"../src/Composition\"\n\timport { String } from \"../src/string\"\n\timport { OrderingComparer } from \"../src/OrderingComparer\"\n\timport { EqualityComparer } from \"../src/EqualityComparer\"\n\tdescribe(\"NonEmptyArray\", () => {\n\t    describe(\"head\", () => {\n\t        it(\"returns the first element\", () => {\n\t            expect(NonEmptyArray.head([12])).toBe(12)\n", "            expect(NonEmptyArray.head([\"a\", \"b\", \"c\"])).toBe(\"a\")\n\t        })\n\t    })\n\t    describe(\"destruct\", () => {\n\t        it(\"can destructure a singleton\", () => {\n\t            expect(NonEmptyArray.destruct([\"a\"])).toStrictEqual({\n\t                head: \"a\",\n\t                tail: [],\n\t            })\n\t        })\n", "        it(\"can destructure a non-singleton\", () => {\n\t            expect(NonEmptyArray.destruct([\"a\", \"b\", \"c\"])).toStrictEqual({\n\t                head: \"a\",\n\t                tail: [\"b\", \"c\"],\n\t            })\n\t        })\n\t    })\n\t    describe(\"map\", () => {\n\t        it(\"maps\", () => {\n\t            expect(\n", "                pipe(\n\t                    [1, 2, 3, 4] as const,\n\t                    NonEmptyArray.map(n => n * 3)\n\t                )\n\t            ).toStrictEqual([3, 6, 9, 12])\n\t        })\n\t    })\n\t    describe(\"bind\", () => {\n\t        it(\"flatMaps\", () => {\n\t            expect(\n", "                pipe(\n\t                    [\"a\", \"ab\", \"abc\", \"abcd\"] as const,\n\t                    NonEmptyArray.bind(String.split(\"\"))\n\t                )\n\t            ).toStrictEqual([\"a\", \"a\", \"b\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"d\"])\n\t        })\n\t    })\n\t    describe(\"of\", () => {\n\t        it(\"produces a single-element array\", () => {\n\t            expect(NonEmptyArray.of(\"abc\")).toStrictEqual([\"abc\"])\n", "        })\n\t    })\n\t    describe(\"range\", () => {\n\t        it.each([\n\t            [1, 5, [1, 2, 3, 4, 5]],\n\t            [-3, 1, [-3, -2, -1, 0, 1]],\n\t            [0, 0, [0]],\n\t            [1, -20, [1]],\n\t            [4.1142, 11.0034, [4, 5, 6, 7, 8, 9, 10, 11]],\n\t        ])(\"produces the expected result %i\", (start, end, expected) => {\n", "            expect(NonEmptyArray.range(start, end)).toStrictEqual(expected)\n\t        })\n\t    })\n\t    describe(\"make\", () => {\n\t        it(\"makes\", () => {\n\t            expect(NonEmptyArray.make(5, i => `${i + 1}`)).toStrictEqual([\n\t                \"1\",\n\t                \"2\",\n\t                \"3\",\n\t                \"4\",\n", "                \"5\",\n\t            ])\n\t        })\n\t        it(\"normalizes length to a natural number\", () => {\n\t            expect(NonEmptyArray.make(-20.11, () => \"a\")).toStrictEqual([\"a\"])\n\t        })\n\t    })\n\t    describe(\"reverse\", () => {\n\t        it(\"reverses\", () => {\n\t            expect(NonEmptyArray.reverse([1, 2, 3, 4, 5])).toStrictEqual([5, 4, 3, 2, 1])\n", "        })\n\t    })\n\t    describe(\"sort\", () => {\n\t        it(\"sorts\", () => {\n\t            expect(\n\t                pipe([4, 8, -1, -5, 0], NonEmptyArray.sort(OrderingComparer.Number))\n\t            ).toStrictEqual([-5, -1, 0, 4, 8])\n\t        })\n\t    })\n\t    describe(\"getEqualityComparer\", () => {\n", "        it(\"always returns false if the arrays are different lengths\", () => {\n\t            const { equals } = NonEmptyArray.getEqualityComparer(EqualityComparer.Number)\n\t            expect(equals([1, 2, 3], [1, 2])).toBe(false)\n\t        })\n\t        it(\"returns false if the arrays are not equal element-by-element\", () => {\n\t            const { equals } = NonEmptyArray.getEqualityComparer(EqualityComparer.Number)\n\t            expect(equals([1, 2, 3], [1, 3, 2])).toBe(false)\n\t        })\n\t        it(\"returns true if the arrays are equal element-by-element\", () => {\n\t            const { equals } = NonEmptyArray.getEqualityComparer(EqualityComparer.Number)\n", "            expect(equals([1, 2, 3], [1, 2, 3])).toBe(true)\n\t        })\n\t    })\n\t})\n"]}
{"filename": "test/Variants.test.ts", "chunked_list": ["import { describe, it, expect, test } from \"vitest\"\n\timport { variant, variantC, VariantOf } from \"../src/Variants\"\n\tconst BasicTest = variant({\n\t    emptyCase: {},\n\t    dataCase: (datum: string) => ({ datum }),\n\t    \"1234\": (field: number) => ({ field }),\n\t})\n\ttype BasicTest = VariantOf<typeof BasicTest>\n\tdescribe(\"Basic Tests\", () => {\n\t    describe(\"constructors\", () => {\n", "        it(\"generates a constructor (or constant for empty case) for every case\", () => {\n\t            expect(BasicTest.emptyCase).toStrictEqual({ _tag: \"EmptyCase\" })\n\t            expect(BasicTest.dataCase(\"ipsum\")).toStrictEqual({\n\t                _tag: \"DataCase\",\n\t                datum: \"ipsum\",\n\t            })\n\t            expect(BasicTest[1234](999)).toStrictEqual({ _tag: \"1234\", field: 999 })\n\t        })\n\t    })\n\t    describe(\"match\", () => {\n", "        const matcher = {\n\t            emptyCase: \"empty\",\n\t            dataCase: ({ datum }: { datum: string }) => `datum=${datum}`,\n\t            \"1234\": ({ field }: { field: number }) => `field=${field}`,\n\t        }\n\t        it.each([\n\t            [\"empty\", BasicTest.emptyCase],\n\t            [\"datum=ipsum\", BasicTest.dataCase(\"ipsum\")],\n\t            [\"field=999\", BasicTest[1234](999)],\n\t        ] as const)(\"produces %s for %o\", (expected, instance: BasicTest) => {\n", "            expect(BasicTest.match(matcher)(instance)).toBe(expected)\n\t        })\n\t    })\n\t    describe(\"matchOrElse\", () => {\n\t        const matcher = {\n\t            emptyCase: \"empty\",\n\t            dataCase: ({ datum }: { datum: string }) => `datum=${datum}`,\n\t            orElse: \"not matched\",\n\t        }\n\t        it.each([\n", "            [\"empty\", BasicTest.emptyCase],\n\t            [\"datum=ipsum\", BasicTest.dataCase(\"ipsum\")],\n\t            [\"not matched\", BasicTest[1234](999)],\n\t        ] as const)(\"produces %s for %o\", (expected, instance: BasicTest) => {\n\t            expect(BasicTest.matchOrElse(matcher)(instance)).toBe(expected)\n\t        })\n\t    })\n\t    describe(\"types\", () => {\n\t        it(\"contains the expected types in the types 'magic' property\", () => {\n\t            expect(BasicTest.types.emptyCase).toBe(\"EmptyCase\")\n", "            expect(BasicTest.types.dataCase).toBe(\"DataCase\")\n\t            expect(BasicTest.types[1234]).toBe(\"1234\")\n\t        })\n\t    })\n\t})\n\tconst ScopedTest = variantC(\n\t    {\n\t        dog: (name: string) => ({ name }),\n\t        cat: (livesLeft: number) => ({ livesLeft }),\n\t        fish: {},\n", "    },\n\t    \"type\",\n\t    \"Pets/\"\n\t)\n\ttype ScopedTest = VariantOf<typeof ScopedTest>\n\tconst ConflictScopedTest = variantC(\n\t    {\n\t        dog: (name: string) => ({ name }),\n\t        cat: (livesLeft: number) => ({ livesLeft }),\n\t        fish: {},\n", "    },\n\t    \"type\",\n\t    \"Animals/\"\n\t)\n\tdescribe(\"Scoped Tests\", () => {\n\t    describe(\"constructors\", () => {\n\t        it(\"generates a constructor for every entry\", () => {\n\t            expect(ScopedTest.dog(\"Fido\")).toStrictEqual({\n\t                type: \"Pets/Dog\",\n\t                name: \"Fido\",\n", "            })\n\t            expect(ScopedTest.cat(7)).toStrictEqual({\n\t                type: \"Pets/Cat\",\n\t                livesLeft: 7,\n\t            })\n\t            expect(ScopedTest.fish).toStrictEqual({ type: \"Pets/Fish\" })\n\t        })\n\t    })\n\t    describe(\"match\", () => {\n\t        const matcher = {\n", "            dog: ({ name }: { name: string }) => `Woof! My name is ${name}.`,\n\t            cat: ({ livesLeft }: { livesLeft: number }) =>\n\t                `Meow! I have ${livesLeft} lives left.`,\n\t            fish: () => \"Blub blub.\",\n\t        }\n\t        it.each([\n\t            [\"Woof! My name is Fido.\", ScopedTest.dog(\"Fido\")],\n\t            [\"Meow! I have 7 lives left.\", ScopedTest.cat(7)],\n\t            [\"Blub blub.\", ScopedTest.fish],\n\t        ] as const)(\"produces %s for %o\", (expected, instance: ScopedTest) => {\n", "            expect(ScopedTest.match(matcher)(instance)).toBe(expected)\n\t        })\n\t    })\n\t    describe(\"matchOrElse\", () => {\n\t        const matcher = {\n\t            dog: \"dog\",\n\t            cat: \"cat\",\n\t            orElse: () => \"not a mammal\",\n\t        }\n\t        it.each([\n", "            [\"dog\", ScopedTest.dog(\"Fido\")],\n\t            [\"cat\", ScopedTest.cat(7)],\n\t            [\"not a mammal\", ScopedTest.fish],\n\t        ] as const)(\"produces %s for %o\", (expected, instance: ScopedTest) => {\n\t            expect(ScopedTest.matchOrElse(matcher)(instance)).toBe(expected)\n\t        })\n\t    })\n\t    describe(\"types\", () => {\n\t        it(\"contains the expected types in the types 'magic' property\", () => {\n\t            expect(ScopedTest.types.dog).toBe(\"Pets/Dog\")\n", "            expect(ScopedTest.types.cat).toBe(\"Pets/Cat\")\n\t            expect(ScopedTest.types.fish).toBe(\"Pets/Fish\")\n\t        })\n\t    })\n\t})\n\tdescribe(\"Conflicting Scope Tests\", () => {\n\t    describe(\"matchOrElse\", () => {\n\t        test(\"a variant with the same structure will not match if their scopes are different\", () => {\n\t            // arrange\n\t            const matcher = {\n", "                dog: \"pets dog\",\n\t                cat: \"pets cat\",\n\t                fish: \"pets fish\",\n\t                orElse: \"not in scope\",\n\t            }\n\t            const differentlyScoped = ConflictScopedTest.dog(\"Fido\")\n\t            // act\n\t            // `as any` is because redux reducers don't get type-checked at runtime\n\t            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n\t            const actual = ScopedTest.matchOrElse(matcher)(differentlyScoped as any)\n", "            // assert\n\t            expect(actual).toBe(\"not in scope\")\n\t        })\n\t    })\n\t    describe(\"match\", () => {\n\t        test(\"a variant with the same structure will not match if their scopes are different\", () => {\n\t            // arrange\n\t            const matcher = {\n\t                dog: () => \"pets dog\",\n\t                cat: () => \"pets cat\",\n", "                fish: () => \"pets fish\",\n\t            }\n\t            const differentlyScoped = ConflictScopedTest.dog(\"Fido\")\n\t            // act & assert\n\t            // `as any` is because redux reducers don't get type-checked at runtime\n\t            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n\t            expect(() => ScopedTest.match(matcher)(differentlyScoped as any)).toThrow(\n\t                \"Expected to be given a variant with scope Pets/. Actual type was Animals/Dog\"\n\t            )\n\t        })\n", "    })\n\t})\n"]}
{"filename": "src/DeferredResult.ts", "chunked_list": ["/**\n\t * The `DeferredResult` type is simply a convenient alias for a {@link Deferred} with an\n\t * inner value of a result {@link Result}. The `DeferredResult` type is frequently useful\n\t * for modeling the state of an asynchronous operation in something like a Redux store or\n\t * the `State` type of a React `useReducer` hook.\n\t *\n\t * The most common use case for this module is to make a decision about what text/UI\n\t * components to display to a user based on the state of some asynchronous operation that\n\t * is potentially ongoing.\n\t *\n", " * See docs for {@link match} and {@link matchOrElse} for code examples.\n\t *\n\t * @module\n\t */\n\timport { pipe } from \"./Composition\"\n\timport { Deferred } from \"./Deferred\"\n\timport { assertExhaustive, Identity } from \"./prelude\"\n\timport { Result } from \"./Result\"\n\texport type DeferredResult<A, E> = Deferred<Result<A, E>>\n\t/** @ignore */\n", "interface DeferredResultMatcher<A, E, R> {\n\t    readonly notStarted: (() => R) | R\n\t    readonly inProgress: (() => R) | R\n\t    readonly resolvedOk: ((ok: A) => R) | R\n\t    readonly resolvedErr: ((ok: E) => R) | R\n\t}\n\t/** @ignore */\n\tinterface PartialDeferredResultMatcher<A, E, R>\n\t    extends Partial<DeferredResultMatcher<A, E, R>> {\n\t    readonly orElse: (() => R) | R\n", "}\n\tconst isRawValue = <A, E, R>(caseFn: R | ((ok: A) => R) | ((err: E) => E)): caseFn is R =>\n\t    typeof caseFn !== \"function\"\n\tconst getMatcherResult = <T, R>(match: ((t: T) => R) | R, arg: T) =>\n\t    isRawValue(match) ? match : match(arg)\n\tconst objHasOptionalProp = <T extends object, P extends keyof T>(\n\t    prop: P,\n\t    obj: T\n\t): obj is Identity<T & Required<{ [key in P]: T[P] }>> => Object.hasOwn(obj, prop)\n\t/**\n", " * Exhaustive pattern match against a `DeferredResult`. Provide a raw value or\n\t * lambda function to use in each case: `notStarted`, `inProgress`, `resolvedOk`,\n\t * and `resolvedErr`. For `resolvedOk` and `resolvedErr`, the lambda function\n\t * will be given the attached \"ok\" or \"err\" data attached to the `Result`.\n\t *\n\t * @param matcher The matcher object containing the value or function to use in each case.\n\t *\n\t * @returns The result of evaluating the matcher case appropriate to the value.\n\t *\n\t * @group Pattern Matching\n", " *\n\t * @example\n\t * ```ts\n\t * declare const apiCallResponse: DeferredResult<Fruit, ApiError>\n\t * pipe(\n\t *     apiCallResponse,\n\t *     DeferredResult.match({\n\t *         notStarted: \"Not Started\",\n\t *         inProgress: \"In Progress\",\n\t *         resolvedOk: fruit => `Fruit is: ${fruit.name}`,\n", " *         resolvedErr: apiError => `Error was: ${ApiError.toString(apiError)}`\n\t *     })\n\t * )\n\t * ```\n\t */\n\texport const match =\n\t    <A, E, R>(matcher: DeferredResultMatcher<A, E, R>) =>\n\t    (deferredResult: DeferredResult<A, E>) => {\n\t        switch (deferredResult._tag) {\n\t            case \"InProgress\":\n", "                return getMatcherResult(matcher.inProgress, undefined)\n\t            case \"NotStarted\":\n\t                return getMatcherResult(matcher.notStarted, undefined)\n\t            case \"Resolved\":\n\t                return pipe(\n\t                    deferredResult.resolved,\n\t                    Result.match({\n\t                        ok: a => getMatcherResult(matcher.resolvedOk, a),\n\t                        err: e => getMatcherResult(matcher.resolvedErr, e),\n\t                    })\n", "                )\n\t            /* c8 ignore next 2 */\n\t            default:\n\t                return assertExhaustive(deferredResult)\n\t        }\n\t    }\n\t/**\n\t * Non-exhaustive pattern match against a `DeferredResult` value. Provide a raw\n\t * value or a lambda function to use in the cases you care about. (But don't provide\n\t * all the cases; if you want an exhaustive pattern match, use {@link match} instead.)\n", " * Must provide an `orElse` matcher case to use if no other match case is hit.\n\t *\n\t * This function is especially useful for when you really only care about the \"resolved\"\n\t * cases, for instance.\n\t *\n\t * @param matcher The matcher object containing the value or function to use in each case.\n\t *\n\t * @returns The result of evaluating the matcher case appropriate to the value.\n\t *\n\t * @group Pattern Matching\n", " *\n\t * @example\n\t * ```ts\n\t *     declare const apiResponse: DeferredResult<Fruit, ApiError>\n\t *     pipe(\n\t *         apiResponse,\n\t *         DeferredResult.matchOrElse({\n\t *             resolvedOk: fruit => `Got fruit! ${fruit.name}`,\n\t *             resolvedErr: apiError => `Oh noes! ${apiError.message}`,\n\t *             orElse: \"Still loading...\"\n", " *         })\n\t *     )\n\t * ```\n\t */\n\texport const matchOrElse =\n\t    <A, E, R>(matcher: PartialDeferredResultMatcher<A, E, R>) =>\n\t    (deferredResult: DeferredResult<A, E>) => {\n\t        switch (deferredResult._tag) {\n\t            case \"InProgress\":\n\t                return objHasOptionalProp(\"inProgress\", matcher)\n", "                    ? getMatcherResult(matcher.inProgress, undefined)\n\t                    : getMatcherResult(matcher.orElse, undefined)\n\t            case \"NotStarted\":\n\t                return objHasOptionalProp(\"notStarted\", matcher)\n\t                    ? getMatcherResult(matcher.notStarted, undefined)\n\t                    : getMatcherResult(matcher.orElse, undefined)\n\t            case \"Resolved\":\n\t                return pipe(\n\t                    deferredResult.resolved,\n\t                    Result.match({\n", "                        ok: a =>\n\t                            objHasOptionalProp(\"resolvedOk\", matcher)\n\t                                ? getMatcherResult(matcher.resolvedOk, a)\n\t                                : getMatcherResult(matcher.orElse, undefined),\n\t                        err: e =>\n\t                            objHasOptionalProp(\"resolvedErr\", matcher)\n\t                                ? getMatcherResult(matcher.resolvedErr, e)\n\t                                : getMatcherResult(matcher.orElse, undefined),\n\t                    })\n\t                )\n", "            /* c8 ignore next 2 */\n\t            default:\n\t                return assertExhaustive(deferredResult)\n\t        }\n\t    }\n\t/* c8 ignore start */\n\t/** @ignore */\n\texport const DeferredResult = {\n\t    match,\n\t    matchOrElse,\n", "}\n\t/* c8 ignore start */\n"]}
{"filename": "src/Async.ts", "chunked_list": ["/**\n\t * The `Async` type represents a \"lazy\" or \"cold\" asynchronous\n\t * operation. This is in contrast to the default behavior of the\n\t * `Promise` type, which is \"hot\" by nature. That is, once you have\n\t * instantiated a `Promise`, whatever asynchronous or background\n\t * work it represents has already begun.\n\t *\n\t * The `Async` type is intended to be used to model computations that\n\t * should never fail. (Meaning, if a failure does occur, it is likely an\n\t * exceptional case and throwing an Error makes sense.) If you need\n", " * to model asynchronous computations that may fail, please use `AsyncResult`.\n\t *\n\t * The primary motivation for using a \"cold\" `Async` type is to\n\t * enable things like\n\t *\n\t * * deciding whether to use in-parallel or in-series sequencing\n\t * * avoiding unnecessary work (If an `Async` is constructed, but\n\t *   never started, no work is performed.)\n\t *\n\t * This API is curried and has been optimized for use right-to-left\n", " * function composition like `pipe` or `flow`.\n\t *\n\t * @example\n\t * ```ts\n\t * await pipe(\n\t *     [\n\t *         () => doThing1Async(),                   // `doThing1Async` returns a Promise\n\t *         () => doThing2Async(),                   // `doThing2Async` returns a Promise\n\t *     ],                                           // Async<string>[]\n\t *     Async.sequential,                            // Async<readonly string[]>\n", " *     Async.map(Array.map(s => s.toLowerCase())),  // Async<readonly string[]>\n\t *     Async.start                                  // Promise<readonly string[]>\n\t * ) // => [\"completed thing 1\", \"completed thing 2\"]\n\t * ```\n\t *\n\t * @module Async\n\t */\n\t/** Represents a \"lazy\" or \"cold\" `Promise`. (See module-level documentation for more.) */\n\texport interface Async<A> {\n\t    (): Promise<A>\n", "}\n\t/**\n\t * Constructs an Async from a raw value. Primarily useful for\n\t * writing tests, or for coercing some value into an Async for\n\t * use in a pipeline.\n\t *\n\t * @group Constructors\n\t *\n\t * @example\n\t * await Async.of(42)() // => 42\n", " */\n\texport const of =\n\t    <A>(a: A): Async<A> =>\n\t    () =>\n\t        Promise.resolve(a)\n\t/**\n\t * Maps the inner value using the given function, producing\n\t * a new `Async`.\n\t *\n\t * @group Mapping\n", " *\n\t * @example\n\t * declare const getSecretValueFromApi: () => Promise<number>\n\t *\n\t * await pipe(\n\t *     getSecretValueFromApi,   // assume always returns 1\n\t *     Async.map(n => n + 1),   // Async<number>\n\t *     Async.start              // Promise<number>\n\t * ) // => 2\n\t */\n", "export const map =\n\t    <A, B>(f: (a: A) => B) =>\n\t    (async: Async<A>): Async<B> =>\n\t    () =>\n\t        async().then(f)\n\t/**\n\t * Maps the inner value using the given function which also\n\t * returns an `Async`, and flattens the result. Also called\n\t * `flatMap`.\n\t *\n", " * @group Mapping\n\t *\n\t * @example\n\t * ```\n\t * await pipe(\n\t *     Async.of(\"a\"),\n\t *     Async.bind(s => Async.of(`${s}+b`)),\n\t *     Async.start\n\t * ) // => \"a+b\"\n\t * ```\n", " */\n\texport const bind =\n\t    <A, B>(f: (a: A) => Async<B>) =>\n\t    (async: Async<A>): Async<B> =>\n\t    () =>\n\t        async().then(a => f(a)())\n\t/**\n\t * Alias of {@link bind}.\n\t *\n\t * @group Mapping\n", " */\n\texport const flatMap = bind\n\t/**\n\t * Unwraps a nested `Async<Async<A>>` structure so that\n\t * the inner value is only wrapped in a single `Async`.\n\t * (Note: {@link bind} can be thought of as just a map +\n\t * flatten operation.)\n\t *\n\t * @group Mapping\n\t *\n", " * @example\n\t * const nested = Async.of(Async.of(30))   // => Async<Async<number>>\n\t * const flattened = Async.flatten(nested) // => Async<number>\n\t */\n\texport const flatten =\n\t    <A>(async: Async<Async<A>>): Async<A> =>\n\t    () =>\n\t        async().then(inner => inner())\n\t/**\n\t * An `Async` of an arbitrary non-nullish value. Useful for\n", " * adding delays at the beginning of a pipeline. Mostly used\n\t * in writing test code.\n\t *\n\t * @group Utils\n\t *\n\t * @example\n\t * ```\n\t * // Add a delay to the beginning of an `Async` pipeline\n\t * pipe(\n\t *     Async.unit,\n", " *     Async.delay(5_000),      // wait 5 seconds\n\t *     Async.map(console.log)\n\t * ) // logs `{}` after 5 seconds\n\t * ```\n\t */\n\texport const unit: Async<unknown> = of({})\n\t/**\n\t * Adds an arbitrary delay to an `Async` computation.\n\t *\n\t * @group Utils\n", " *\n\t * @param delayInMilliseconds Normalized to a non-negative integer.\n\t *\n\t * @example\n\t * ```ts\n\t * pipe(\n\t *     Async.unit,\n\t *     Async.delay(5000), // wait 5 seconds\n\t *     Async.map(console.log)\n\t * ) // logs `{}` after 5 seconds\n", " * ```\n\t */\n\texport const delay =\n\t    (delayInMilliseconds: number) =>\n\t    <A>(async: Async<A>): Async<A> =>\n\t    async () => {\n\t        const delay = delayInMilliseconds <= 0 ? 0 : Math.floor(delayInMilliseconds)\n\t        await new Promise(resolve => setTimeout(resolve, delay))\n\t        return await async()\n\t    }\n", "/**\n\t * Converts an array of `Async` computations into a single `Async`\n\t * computation that represents the in-series execution of each\n\t * individual `Async` computation.\n\t *\n\t * @group Sequencing\n\t *\n\t * @remarks\n\t * Order is guaranteed. The order of the given computations will be\n\t * preserved in the resultant array.\n", " */\n\texport const sequential =\n\t    <A>(asyncs: readonly Async<A>[]): Async<readonly A[]> =>\n\t    async () => {\n\t        const results: A[] = []\n\t        for (let i = 0; i < asyncs.length; i++) {\n\t            results.push(await asyncs[i]())\n\t        }\n\t        return results\n\t    }\n", "/**\n\t * Invokes the `Async`. Identical to calling the `Async` as\n\t * a function. Useful for more expressive function pipelines.\n\t *\n\t * @group Utils\n\t *\n\t * @returns A `Promise` that will resolve to the result of the `Async` computation.\n\t *\n\t * @example\n\t * // simply invoke\n", " * const a = await Async.of(1)(); // => 1\n\t * // use a named function, useful for pipelining\n\t * const b = await pipe(\n\t *     Async.of(1),\n\t *     Async.start\n\t * ) // => 1\n\t */\n\texport const start = <A>(async: Async<A>): Promise<A> => async()\n\t/**\n\t * Converts an array of `Async` computations into one `Async` computation\n", " * which represents the in-parallel execution of all the given `Async`\n\t * computations.\n\t *\n\t * @group Sequencing\n\t *\n\t * @remarks\n\t * This is effectively an alias for `Promise.all`. Order is not guaranteed.\n\t */\n\texport const parallel =\n\t    <A>(asyncs: readonly Async<A>[]): Async<readonly A[]> =>\n", "    () =>\n\t        Promise.all(asyncs.map(start))\n\t/**\n\t * Wraps a `Promise` inside an `Async`.\n\t *\n\t * @group Constructors\n\t * @group Utils\n\t *\n\t * @remarks\n\t * **Note:** this does not mean that the given promise is made \"cold.\"\n", " * By definition, the given `Promise` is already \"hot\" when it is passed\n\t * to this function.\n\t *\n\t * If you want to convert a function that returns a `Promise` into a\n\t * function that returns an `Async`, see {@link asyncify}.\n\t *\n\t * @example\n\t * declare const safeWriteToFile: (content: string) => Promise<number>;\n\t * // Promises are always \"hot\" as soon as they are instantiated\n\t * const statusPromise = safeWriteToFile(\"I love cheese\"); // => Promise<number>\n", " * const statusAsync = Async.ofPromise(statusPromise);     // => Async<number>\n\t */\n\texport const ofPromise =\n\t    <A>(promise: Promise<A>): Async<A> =>\n\t    () =>\n\t        promise\n\t/* eslint-disable @typescript-eslint/no-explicit-any */\n\t/**\n\t * Converts a function that returns a `Promise` into one that returns\n\t * an `Async` instead.\n", " *\n\t * @group Utils\n\t */\n\texport const asyncify =\n\t    <F extends (...args: any[]) => Promise<any>>(\n\t        f: F\n\t    ): ((...args: Parameters<F>) => Async<Awaited<ReturnType<F>>>) =>\n\t    (...args: Parameters<F>) =>\n\t    () =>\n\t        f(...args)\n", "/* eslint-enable @typescript-eslint/no-explicit-any */\n\t/**\n\t * Execute an arbitrary side-effect within a pipeline of\n\t * `Async` functions. Useful for logging and debugging.\n\t * Passes the inner value through unchanged. This function\n\t * is sometimes called `do` or `tap`.\n\t *\n\t * @group Utils\n\t *\n\t * @param f Should not mutate its arguments. See {@link map} if you want to map the inner value.\n", " *\n\t * @example\n\t * ```ts\n\t * await pipe(\n\t *     Async.of(20),\n\t *     Async.delay(2_000),\n\t *     Async.tee(console.log), // logs `20` after 2 seconds\n\t *     Async.map(double),      // double receives the un-altered value `20`\n\t *     Async.start\n\t * ) // => 40 (after 2 seconds)\n", " * ```\n\t */\n\texport const tee =\n\t    <A>(f: (a: A) => void) =>\n\t    (async: Async<A>): Async<A> =>\n\t    async () => {\n\t        const a = await async()\n\t        f(a)\n\t        return a\n\t    }\n", "/**\n\t * `Async` computation that never resolves. Primarily useful\n\t * for writing test code.\n\t *\n\t * @group Utils\n\t */\n\texport const never: Async<never> = () =>\n\t    // eslint-disable-next-line @typescript-eslint/no-empty-function\n\t    new Promise(() => {})\n\t/* c8 ignore start */\n", "/** @ignore */\n\texport const Async = {\n\t    of,\n\t    map,\n\t    bind,\n\t    flatMap,\n\t    flatten,\n\t    sequential,\n\t    parallel,\n\t    start,\n", "    ofPromise,\n\t    delay,\n\t    unit,\n\t    asyncify,\n\t    never,\n\t    tee,\n\t}\n\t/* c8 ignore end */\n"]}
{"filename": "src/OrderingComparer.ts", "chunked_list": ["/**\n\t * An `OrderingComparer` represents the ability to deterministcally sort a set of values.\n\t * Meaning, it should always give back the same sort order given the same set of values.\n\t *\n\t * The `compare` function returns `-1` if the first item is _less than_ the second\n\t * item. It returns `1` if the first item is _greater than_ the second item in the\n\t * sort order. It returns `0` if the first item is equivalent  to the second item\n\t * with reference to the sort order.\n\t *\n\t * **Note:** An `OrderingComparer` is not structurally compatible with an `Ord` from `fp-ts`\n", " * by default. You can get an `Ord`-compatible structure via {@link deriveEqualityComparer}.\n\t *\n\t * @example\n\t * interface Pet {\n\t *    readonly name: string\n\t *    readonly age: number\n\t * }\n\t *\n\t * class PetByAgeDescComparer implements OrderingComparer<Pet> {\n\t *    compare(p1: Pet, p2: Pet) {\n", " *        return p1.age === p2.age ? 0 : p1.age < p2.age ? 1 : -1\n\t *    }\n\t * }\n\t *\n\t * @module OrderingComparer\n\t */\n\timport { String as S } from \"./string\"\n\timport { EqualityComparer } from \"./EqualityComparer\"\n\t/**\n\t * A more strict version of the default JavaScript compare function result.\n", " * (i.e., `-1` and `1` are required specifically, not just `< 0` or `> 0`)\n\t */\n\ttype CompareResult =\n\t    | -1 // the first value is considered _less than_ the second value\n\t    | 0 // the first value is considered _the same as_ the second value\n\t    | 1 // the first value is considered _greater than_ the second value\n\texport interface OrderingComparer<A> {\n\t    compare(a1: A, a2: A): CompareResult\n\t}\n\t/**\n", " * Construct a new `OrderingComparer` based on a compare function that returns\n\t * `-1`, `0`, or `1`. See docs for {@link OrderingComparer}.\n\t *\n\t * **Note:** this function already checks for reference equality and will return\n\t * `0` in that case. (So the compare function you pass here does not necessarily\n\t * need to check for reference equality.)\n\t *\n\t * @group Constructors\n\t *\n\t * @returns A new `OrderingComparer` instance.\n", " */\n\texport const ofCompare = <A>(\n\t    compare: OrderingComparer<A>[\"compare\"]\n\t): OrderingComparer<A> => ({\n\t    compare: (a1, a2) => (a1 === a2 ? 0 : compare(a1, a2)),\n\t})\n\t/**\n\t * Reverse the sort order produced by an `OrderingComparer`. For example, you could use this\n\t * to generate an `OrderingComparer` that would sort numbers in descending order.\n\t *\n", " * @group Utils\n\t *\n\t * @returns A new `OrderingComparer` with its sort order inverted.\n\t *\n\t * @example\n\t * const numberDesc = OrderingComparer.reverse(OrderingComparer.Number)\n\t */\n\texport const reverse = <A>({ compare }: OrderingComparer<A>): OrderingComparer<A> =>\n\t    ofCompare((a1, a2) => compare(a2, a1))\n\t/**\n", " * Given you already have an `OrderingComparer` for some type `A`, and you know how to\n\t * map from some other type `B` to type `A`, you can effectively \"re-use\" your `OrderingComparer`\n\t * for type `B`. Also referred to commonly as `contramap`, because the mapping is going\n\t * from `B`&rarr;`A`, not from `A`&rarr;`B`.\n\t *\n\t * @group Utils\n\t * @group Constructors\n\t *\n\t * @param known The `OrderingComparer` that you already have.\n\t * @param map The function that can map from `B`&rarr;`A`.\n", " *\n\t * @returns A new `OrderingComparer` instance.\n\t */\n\texport const deriveFrom = <A, B>(\n\t    known: OrderingComparer<A>,\n\t    map: (b: B) => A\n\t): OrderingComparer<B> => ({\n\t    compare: (b1, b2) => (b1 === b2 ? 0 : known.compare(map(b1), map(b2))),\n\t})\n\t/**\n", " * The default `OrderingComparer`. Converts both values to strings (if they\n\t * are not already) and does the default ASCII-based alphabetical comparison.\n\t *\n\t * @group Primitives\n\t */\n\texport const Default: OrderingComparer<never> = ofCompare((a1, a2) => {\n\t    const a1String: string = S.isString(a1) ? a1 : globalThis.String(a1)\n\t    const a2String: string = S.isString(a2) ? a2 : globalThis.String(a2)\n\t    return a1String < a2String ? -1 : a1String > a2String ? 1 : 0\n\t})\n", "/**\n\t * Combine or merge multiple `OrderingComparer`s together **in a specific order**.\n\t * Conceptually, this means, \"Sort these values by this first, then this, then this\"\n\t * and so on.\n\t *\n\t * For example if you have an `OrderingComparer` that sorts strings alphabetically in\n\t * a case-insensitive manner (say, `alphabeticalCiComparer`) and an `OrderingComparer`\n\t * that sorts strings by their length (say, `lengthComparer`), you could generate a new\n\t * \"composite\" `OrderingComparer` that sorts alphabetically (case-insensitive) **and\n\t * then by** length.\n", " *\n\t * @example\n\t * const alphabeticalCiThenLengthComparer =\n\t *     OrderingComparer.getComposite(alphabeticalCiComparer, lengthComparer)\n\t *\n\t * @group Utils\n\t *\n\t * @remarks\n\t * If no comparers are passed, will default to {@link Default}\n\t *\n", " * @returns A new `OrderingComparer` instance.\n\t */\n\texport const getComposite = <A>(\n\t    ...comparers: readonly OrderingComparer<A>[]\n\t): OrderingComparer<A> => {\n\t    /* c8 ignore next 3 */\n\t    if (comparers.length < 1) {\n\t        return Default\n\t    }\n\t    return ofCompare((a1, a2) =>\n", "        comparers.reduce<CompareResult>(\n\t            (result, nextComparer) =>\n\t                result !== 0 ? result : nextComparer.compare(a1, a2),\n\t            0\n\t        )\n\t    )\n\t}\n\t/**\n\t * An `OrderingComparer` for the built-in `number` type, in ascending order.\n\t *\n", " * @group Primitives\n\t */\n\texport const Number: OrderingComparer<number> = ofCompare((n1, n2) =>\n\t    n2 - n1 > 0 ? -1 : 1\n\t)\n\t/**\n\t * An `OrderingComparer` for the built-in `string` type. Equivalent to {@link Default}.\n\t *\n\t * @group Primitives\n\t */\n", "export const String: OrderingComparer<string> = Default\n\t/**\n\t * An `OrderingComparer` for the built-in `date` type, in ascending order.\n\t *\n\t * @group Primitives\n\t */\n\texport const Date: OrderingComparer<Date> = deriveFrom(Number, date => date.valueOf())\n\t/**\n\t * Get a combined `OrderingComparer` and `EqualityComparer` by using the check,\n\t * \"Does the compare return `0`?\" as the equals function. This produces a type\n", " * that is compatible with `Ord` from `fp-ts`.\n\t *\n\t * @returns A new instance that implements both `EqualityComparer` and `OrderingComparer`\n\t *\n\t * @group Utils\n\t */\n\texport const deriveEqualityComparer = <A>(\n\t    orderingComparer: OrderingComparer<A>\n\t): OrderingComparer<A> & EqualityComparer<A> => ({\n\t    compare: orderingComparer.compare,\n", "    equals: (a1, a2) => a1 === a2 || orderingComparer.compare(a1, a2) === 0,\n\t})\n\t/**\n\t * Get whether the _first_ value is **greater than** the _second_ value.\n\t *\n\t * @param orderingComparer The `OrderingComparer` to use for the comparison.\n\t *\n\t * @group Comparisons\n\t */\n\texport const gt =\n", "    <A>({ compare }: OrderingComparer<A>) =>\n\t    (first: A, second: A): boolean =>\n\t        compare(first, second) === 1\n\t/**\n\t * Get whether the _first_ value is **greater than or equal to** the _second_ value.\n\t *\n\t * @param orderingComparer The `OrderingComparer` to use for the comparison.\n\t *\n\t * @group Comparisons\n\t */\n", "export const geq =\n\t    <A>({ compare }: OrderingComparer<A>) =>\n\t    (first: A, second: A): boolean =>\n\t        compare(first, second) >= 0\n\t/**\n\t * Get whether the _first_ value is **less than** the _second_ value.\n\t *\n\t * @param orderingComparer The `OrderingComparer` to use for the comparison.\n\t *\n\t * @group Comparisons\n", " */\n\texport const lt =\n\t    <A>({ compare }: OrderingComparer<A>) =>\n\t    (first: A, second: A): boolean =>\n\t        compare(first, second) === -1\n\t/**\n\t * Get whether the _first_ value is **less than or equal to** the _second_ value.\n\t *\n\t * @param orderingComparer The `OrderingComparer` to use for the comparison.\n\t *\n", " * @group Comparisons\n\t */\n\texport const leq =\n\t    <A>({ compare }: OrderingComparer<A>) =>\n\t    (first: A, second: A): boolean =>\n\t        compare(first, second) <= 0\n\t/**\n\t * Get whether the value is between the upper and lower bound (inclusive).\n\t *\n\t * @group Comparisons\n", " */\n\texport const isBetween =\n\t    <A>(orderingComparer: OrderingComparer<A>) =>\n\t    (lowerBound: A, upperBound: A) =>\n\t    (a: A): boolean =>\n\t        geq(orderingComparer)(a, lowerBound) && leq(orderingComparer)(a, upperBound)\n\t/* c8 ignore start */\n\t/** @ignore */\n\texport const OrderingComparer = {\n\t    ofCompare,\n", "    reverse,\n\t    deriveFrom,\n\t    Default,\n\t    Number,\n\t    String,\n\t    Date,\n\t    getComposite,\n\t    deriveEqualityComparer,\n\t    gt,\n\t    geq,\n", "    lt,\n\t    leq,\n\t    isBetween,\n\t}\n\t/* c8 ignore end */\n"]}
{"filename": "src/AsyncResult.ts", "chunked_list": ["/**\n\t * An `AsyncResult` represents an asynchronous computation that may either\n\t * succeed or fail (but should never throw). It is identical to `Async<Result<A, E>`.\n\t * This module simply provides convenience functions for working with that\n\t * type because they are so frequently used in real-world programming.\n\t *\n\t * Like `Async`, `AsyncResult` represents a \"cold\" computation that must be\n\t * explicitly invoked/started, in contrast to `Promise`s, which are \"hot.\"\n\t *\n\t * **Note:** You can use `Async.start` to start `AsyncResult`s because they are\n", " * just `Async`s with a constrained inner value type.\n\t *\n\t * @module AsyncResult\n\t */\n\timport { Result } from \"./Result\"\n\timport { Async } from \"./Async\"\n\timport { pipe } from \"./Composition\"\n\t/**\n\t * @typeParam A The type of the `Ok` branch.\n\t * @typeParam E The type of the `Err` branch.\n", " */\n\texport interface AsyncResult<A, E> {\n\t    (): Promise<Result<A, E>>\n\t}\n\t/**\n\t * Construct a new `Ok` instance.\n\t *\n\t * @group Constructors\n\t *\n\t * @returns A new `AsyncResult` containing the given ok value.\n", " */\n\texport const ok =\n\t    <A, E = never>(ok: A): AsyncResult<A, E> =>\n\t    () =>\n\t        Promise.resolve(Result.ok(ok))\n\t/**\n\t * Construct a new `Err` instance.\n\t *\n\t * @group Constructors\n\t *\n", " * @returns A new `AsyncResult` using the given err value.\n\t */\n\texport const err =\n\t    <E, A = never>(err: E): AsyncResult<A, E> =>\n\t    () =>\n\t        Promise.resolve(Result.err(err))\n\t/**\n\t * Maps the wrapped `Ok` value using the given function and\n\t * returns a new `AsyncResult`. Passes `Err` values through as-is.\n\t *\n", " * @group Mapping\n\t *\n\t * @example\n\t * await pipe(\n\t *     AsyncResult.ok(10),\n\t *     AsyncResult.map(n => n * 2),\n\t *     Async.start\n\t * ) // => Result.ok(20)\n\t */\n\texport const map =\n", "    <A, B>(f: (a: A) => B) =>\n\t    <E>(async: AsyncResult<A, E>): AsyncResult<B, E> =>\n\t    () =>\n\t        async().then(Result.map(f))\n\t/**\n\t * Maps the wrapped `Err` value using the given function and\n\t * returns a new `AsyncResult`. Passes `Ok` values through as-is.\n\t *\n\t * @group Mapping\n\t *\n", " * @example\n\t * await pipe(\n\t *     AsyncResult.err(\"err\"),\n\t *     AsyncResult.mapErr(s => s.length),\n\t *     Async.start\n\t * ) // => Result.err(3)\n\t */\n\texport const mapErr =\n\t    <Ea, Eb>(f: (a: Ea) => Eb) =>\n\t    <A>(async: AsyncResult<A, Ea>): AsyncResult<A, Eb> =>\n", "    () =>\n\t        async().then(Result.mapErr(f))\n\t/**\n\t * Takes two functions: one to map an `Ok`, one to map an `Err`.\n\t * Returns a new AsyncResult with the projected value based\n\t * on which function was used. Equivalent to calling {@link map} =\n\t * followed by {@link mapErr}.\n\t *\n\t * @group Mapping\n\t */\n", "export const mapBoth =\n\t    <A1, A2, E1, E2>(mapOk: (a: A1) => A2, mapErr: (e: E1) => E2) =>\n\t    (async: AsyncResult<A1, E1>) =>\n\t    () =>\n\t        async().then(Result.mapBoth(mapOk, mapErr))\n\t/**\n\t * Maps the wrapped `Ok` value using a given function that\n\t * also returns an AsyncResult, and flattens the result.\n\t * Also commonly known as `flatpMap`.\n\t *\n", " * @group Mapping\n\t *\n\t * @example\n\t * declare const getNumberOfLines: (fileName: string) => AsyncResult<number, Error>\n\t * declare const sendToServer: (numLines: number) => AsyncResult<{}, Error>\n\t *\n\t * await pipe(\n\t *     \"log.txt\",                       // string\n\t *     getNumberOfLines,                // AsyncResult<number, Error>\n\t *     AsyncResult.bind(sendToServer),  // AsyncResult<{}, Error>\n", " *     Async.start                      // Promise<Result<{}, Error>>\n\t * )\n\t * // returns Result.ok({}) if everything succeeds\n\t * // otherwise returns Result.err(Error) if something\n\t * // fell down along the way\n\t */\n\texport const bind =\n\t    <A, B, E>(f: (a: A) => AsyncResult<B, E>) =>\n\t    (async: AsyncResult<A, E>): AsyncResult<B, E> =>\n\t    async () => {\n", "        const result = await async()\n\t        return await pipe(\n\t            result,\n\t            Result.match({\n\t                ok: f,\n\t                err: e => err(e),\n\t            }),\n\t            Async.start\n\t        )\n\t    }\n", "/**\n\t * Alias for {@link bind}.\n\t *\n\t * @group Mapping\n\t */\n\texport const flatMap = bind\n\t/**\n\t * Projects the wrapped `Ok` value using a given _synchronous_ function\n\t * that returns a `Result` and flattens that result into a new `AsyncResult`.\n\t * Primarily useful for composing together asynchronous workflows with\n", " * synchronous functions that may also fail. (e.g., parsing a JSON string)\n\t *\n\t * @group Mapping\n\t *\n\t * @example\n\t * declare const networkRequest: (url: string) => AsyncResult<JsonValue, Error>;\n\t * declare const parseJson: (j: JsonValue) => Result<MyType, string>;\n\t *\n\t * await pipe(\n\t *     url,                                 // string\n", " *     networkRequest,                      // AsyncResult<JsonValue, Error>\n\t *     AsyncResult.bindResult(flow(\n\t *         parseJson,                       // Result<MyType, string>\n\t *         Result.mapErr(s => new Error(s)) // Result<MyType, Error>\n\t *     )),                                  // AsyncResult<MyType, Error>\n\t *     Async.start                          // Promise<Result<MyType, Error>>\n\t * )\n\t * // returns Result.ok(MyType) instance if everything succeeds,\n\t * // otherwise returns Result.err(Error)F if something fell over\n\t */\n", "export const bindResult =\n\t    <A, B, E>(f: (a: A) => Result<B, E>) =>\n\t    (async: AsyncResult<A, E>): AsyncResult<B, E> =>\n\t    () =>\n\t        async().then(Result.bind(f))\n\t/**\n\t * Alias for {@link bindResult}.\n\t *\n\t * @group Mapping\n\t */\n", "export const flatMapResult = bindResult\n\t/**\n\t * Use this function to \"lift\" a `Result` value into the `AsyncResult` type.\n\t * Essentially, this just wraps a `Result` into a lambda that returns an\n\t * immediately-resolved `Promise` containing the `Result`.\n\t *\n\t * @group Utils\n\t * @group Constructors\n\t */\n\texport const ofResult =\n", "    <A, E>(result: Result<A, E>): AsyncResult<A, E> =>\n\t    () =>\n\t        Promise.resolve(result)\n\t/**\n\t * Use this function to \"lift\" an `Async` computation into an `AsyncResult`.\n\t * Essentially, this just wraps the `Async`'s inner value into a `Result.ok`.\n\t *\n\t * @group Utils\n\t * @group Constructors\n\t */\n", "export const ofAsync =\n\t    <A, E = unknown>(async: Async<A>): AsyncResult<A, E> =>\n\t    () =>\n\t        async().then(a => Result.ok(a))\n\t/* eslint-disable func-style */\n\t/**\n\t * Converts an `Async` computation that might reject into an\n\t * Async computation that never rejects and returns a `Result`.\n\t * (Remember that an `Async` is just a lambda returning a `Promise`.)\n\t *\n", " * If the `onThrow` callback function is given, it will be used to\n\t * convert the thrown object into the Err branch. By default, the thrown\n\t * object will be `string`-ed and wrapped in an Error if it is not an Error already.\n\t *\n\t * @group Utils\n\t *\n\t * @example\n\t * ```\n\t * declare const doHttpThing: (url: string) => Promise<number>;\n\t *\n", " * await pipe(\n\t *     AsyncResult.tryCatch(() => doHttpThing(\"/cats\")),    // AsyncResult<number, Error>\n\t *     AsyncResult.mapErr(e => e.message),                  // AsyncResult<number, string>\n\t *     Async.start                                          // Promise<Result<number, string>>\n\t * )\n\t * // yields `Result.ok(number)` if the call succeeded\n\t * // otherwise yields `Result.err(string)`\n\t * ```\n\t */\n\texport function tryCatch<A>(mightThrow: Async<A>): AsyncResult<A, Error>\n", "export function tryCatch<A, E = unknown>(\n\t    mightThrow: Async<A>,\n\t    onThrow: (thrown: unknown) => E\n\t): AsyncResult<A, E>\n\texport function tryCatch<A, E = unknown>(\n\t    mightThrow: Async<A>,\n\t    onThrow?: (err: unknown) => E\n\t): AsyncResult<A, unknown> {\n\t    return async () => {\n\t        const toError = (err: unknown) =>\n", "            err instanceof Error ? err : Error(String(err))\n\t        try {\n\t            return Result.ok(await mightThrow())\n\t        } catch (err) {\n\t            if (onThrow != null) {\n\t                return Result.err(onThrow(err))\n\t            }\n\t            return Result.err(toError(err))\n\t        }\n\t    }\n", "}\n\t/* eslint-enable func-style */\n\t/**\n\t * @ignore\n\t */\n\tinterface AsyncResultMatcher<A, E, R> {\n\t    readonly ok: R | ((ok: A) => R)\n\t    readonly err: R | ((err: E) => R)\n\t}\n\t/**\n", " * Exhaustive pattern match against an `AsyncResult`. Pass a matcher\n\t * object with cases for `ok` and `err` using either raw values or\n\t * lambdas accepting the data associated with each case.\n\t *\n\t * This pattern match unwraps the inner `Result` and returns an `Async`\n\t * computation containing the result of the match. Use {@link start} to\n\t * convert the `Async` into a `Promise` which can be `await`-ed.\n\t *\n\t * @group Pattern Matching\n\t *\n", " * @example\n\t * await pipe(\n\t *     AsyncResult.ok(\"alright!\"),\n\t *     AsyncResult.match({\n\t *         ok: String.capitalize,\n\t *         err: \"bah, humbug!\",\n\t *     }),\n\t *     Async.start\n\t * ) // => \"Alright!\"\n\t */\n", "export const match =\n\t    <A, E, R>(matcher: AsyncResultMatcher<A, E, R>) =>\n\t    (async: AsyncResult<A, E>): Async<R> =>\n\t    () =>\n\t        async().then(Result.match(matcher))\n\t/**\n\t * Equivalent to both Async.start or simply invoking\n\t * the AsyncResult as a function. Aliased here for convenience.\n\t *\n\t * @group Utils\n", " */\n\texport const start = <A, E>(async: AsyncResult<A, E>) => async()\n\t/**\n\t * Execute an arbitrary side-effect on the inner `Ok` value of an `AsyncResult`\n\t * within a pipeline of functions. Useful for logging and debugging. Passes\n\t * the inner value through unchanged. Sometimes referred to as `do` or `tap`.\n\t *\n\t * The side-effect will be invoked once the underlying `Promise` has resolved.\n\t *\n\t * @param f The side-effect to execute. Should not mutate its arguments.\n", " * @returns The `AsyncResult`, unchanged.\n\t *\n\t * @group Utils\n\t */\n\texport const tee =\n\t    <A>(f: (a: A) => void) =>\n\t    <E>(async: AsyncResult<A, E>): AsyncResult<A, E> =>\n\t        Async.tee<Result<A, E>>(Result.tee(f))(async)\n\t/**\n\t * Execute an arbitrary side-effect on the inner `Err` value of an `AsyncResult`\n", " * within a pipeline of functions. Useful for logging and debugging. Passes\n\t * the inner value through unchanged. Sometimes referred to as `do` or `tap`.\n\t *\n\t * The side-effect will be invoked once the underlying `Promise` has resolved.\n\t *\n\t * @param f The side-effect to execute. Should not mutate its arguments.\n\t * @returns The `AsyncResult`, unchanged.\n\t *\n\t * @group Utils\n\t */\n", "export const teeErr =\n\t    <E>(f: (a: E) => void) =>\n\t    <A>(async: AsyncResult<A, E>): AsyncResult<A, E> =>\n\t        Async.tee<Result<A, E>>(Result.teeErr(f))(async)\n\t/* c8 ignore start */\n\t/** @ignore */\n\texport const AsyncResult = {\n\t    ok,\n\t    err,\n\t    map,\n", "    mapErr,\n\t    mapBoth,\n\t    bind,\n\t    flatMap,\n\t    bindResult,\n\t    flatMapResult,\n\t    ofResult,\n\t    ofAsync,\n\t    tryCatch,\n\t    match,\n", "    start,\n\t    tee,\n\t    teeErr,\n\t}\n\t/* c8 ignore end */\n"]}
{"filename": "src/Deferred.ts", "chunked_list": ["/**\n\t * The `Deferred` type represents the state of some asynchronous operation. The\n\t * operation can either be `NotStarted`, `InProgress`, or `Resolved`. When the\n\t * operation is resolved, it has some data attached to it that represents the\n\t * outcome of the asyncrhonous work.\n\t *\n\t * This type is frequently used with `Result` as the data of the `Resolved`\n\t * branch, because it is a common situation to model the outcome of an asynchronous\n\t * operation that can fail.\n\t *\n", " * This type is especially helpful in Redux stores (or in the React `useReducer`\n\t * state) because it allows you to determinstically model the state of an async\n\t * operation as one value. I.e., instead of using separate flags that are\n\t * _implicitly_ related to each other (e.g., `notStarted`, `loading`, `result`),\n\t * you know for a fact that the async work can only be in one of three states,\n\t * and the data present on the resolved state is _only_ present on the resolved\n\t * state.\n\t *\n\t * @example\n\t * declare const def: Deferred<ApiResponse>\n", " *\n\t * pipe(\n\t *     def,\n\t *     Deferred.match({\n\t *         notStarted: \"Not Started\",\n\t *         inProgress: \"In Progress\",\n\t *         resolved: response => response.body\n\t *     })\n\t * )\n\t *\n", " * @module Deferred\n\t */\n\t/* eslint-disable @typescript-eslint/no-explicit-any */\n\t/* eslint-disable @typescript-eslint/no-empty-interface */\n\timport { Tagged, assertExhaustive } from \"./prelude\"\n\timport { pipe } from \"./Composition\"\n\timport { EqualityComparer } from \"./EqualityComparer\"\n\t/** The `NotStarted` type. */\n\texport interface NotStarted extends Tagged<\"NotStarted\", object> {}\n\t/** The `InProgress` type. */\n", "export interface InProgress extends Tagged<\"InProgress\", object> {}\n\t/** The `Resolved` type. */\n\texport interface Resolved<A> extends Tagged<\"Resolved\", { resolved: A }> {}\n\t/** A discriminated union type representing a `Deferred` value. */\n\texport type Deferred<A> = NotStarted | InProgress | Resolved<A>\n\t/**\n\t * The static `NotStarted` instance.\n\t *\n\t * @group Constructors\n\t */\n", "export const notStarted: Deferred<never> = Object.freeze({ _tag: \"NotStarted\" })\n\t/**\n\t * The static `InProgress` instance.\n\t *\n\t * @group Constructors\n\t */\n\texport const inProgress: Deferred<never> = Object.freeze({ _tag: \"InProgress\" })\n\t/**\n\t * Construct a new `Resolved` instance with the given data attached.\n\t *\n", " * @param a The data that will be wrapped in the `Deferred`.\n\t *\n\t * @group Constructors\n\t */\n\texport const resolved = <A>(a: A): Deferred<A> => ({ _tag: \"Resolved\", resolved: a })\n\t/** @ignore */\n\tinterface DeferredMatcher<A, R> {\n\t    readonly notStarted: (() => R) | R\n\t    readonly inProgress: (() => R) | R\n\t    readonly resolved: ((a: A) => R) | R\n", "}\n\t/** @ignore */\n\tinterface PartialDeferredMatcher<A, R> extends Partial<DeferredMatcher<A, R>> {\n\t    readonly orElse: (() => R) | R\n\t}\n\ttype Func<T> = (...args: any[]) => T\n\ttype FuncOrValue<T> = Func<T> | T\n\tconst resultOrValue = <T>(f: FuncOrValue<T>, ...args: any[]) => {\n\t    const isFunc = (f: FuncOrValue<T>): f is Func<T> => typeof f === \"function\"\n\t    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n", "    return isFunc(f) ? f(...args) : f\n\t}\n\t/**\n\t * Exhaustively pattern match against a `Deferred` value. Provide either\n\t * a value or a lambda to use for each case. If you provide a lambda to the\n\t * `resolved` case, it will be given the data associated with the `Resolved`\n\t * instance.\n\t *\n\t * See docs for {@link Deferred} for example.\n\t *\n", " * @param matcher The matcher object to use.\n\t *\n\t * @group Pattern Matching\n\t *\n\t * @example\n\t * ```\n\t * declare const def: Deferred<MyApiResponse>\n\t * pipe(\n\t *     def,\n\t *     Deferred.match({\n", " *         notStarted: \"\",\n\t *         inProgress: \"Loading...\",\n\t *         resolved: resp => resp?.body ?? \"\"\n\t *     })\n\t * ) // => the string produced in each case, depending on the value of `def`\n\t * ```\n\t */\n\texport const match =\n\t    <A, R>(matcher: DeferredMatcher<A, R>) =>\n\t    (deferred: Deferred<A>) => {\n", "        switch (deferred._tag) {\n\t            case \"NotStarted\":\n\t                return resultOrValue(matcher.notStarted)\n\t            case \"InProgress\":\n\t                return resultOrValue(matcher.inProgress)\n\t            case \"Resolved\":\n\t                return resultOrValue(matcher.resolved, deferred.resolved)\n\t            /* c8 ignore next 2 */\n\t            default:\n\t                return assertExhaustive(deferred) as R\n", "        }\n\t    }\n\t/**\n\t * Non-exhaustive pattern match against a `Deferred`. Provide a lambda or raw value\n\t * to return for the various cases. (But don't specify all the cases. You should use\n\t * {@link match} if you want exhaustive case checking.) Then also provide a raw value\n\t * or lambda to use for the `orElse` case if the check falls through all other cases.\n\t *\n\t * @group Pattern Matching\n\t *\n", " * @example\n\t * ```\n\t * declare const def: Deferred<number>\n\t * pipe(\n\t *     def,\n\t *     Deferred.matchOrElse({\n\t *         resolved: statusCode => `Status: ${statusCode}`,\n\t *         orElse: 'Not Finished' // effectively captures both \"in progress\" and \"not started\" cases together\n\t *     })\n\t * )\n", " * ```\n\t */\n\texport const matchOrElse =\n\t    <A, R>(matcher: PartialDeferredMatcher<A, R>) =>\n\t    (deferred: Deferred<A>) => {\n\t        switch (deferred._tag) {\n\t            case \"NotStarted\":\n\t                return resultOrValue(\n\t                    matcher.notStarted != null ? matcher.notStarted : matcher.orElse\n\t                )\n", "            case \"InProgress\":\n\t                return resultOrValue(\n\t                    matcher.inProgress != null ? matcher.inProgress : matcher.orElse\n\t                )\n\t            case \"Resolved\":\n\t                return matcher.resolved != null\n\t                    ? resultOrValue(matcher.resolved, deferred.resolved)\n\t                    : resultOrValue(matcher.orElse)\n\t            /* c8 ignore next 2 */\n\t            default:\n", "                return resultOrValue(matcher.orElse)\n\t        }\n\t    }\n\t/**\n\t * Get whether the `Deferred` is either in progress or not started.\n\t *\n\t * @group Utils\n\t */\n\texport const isUnresolved: <A>(deferred: Deferred<A>) => boolean = matchOrElse({\n\t    resolved: false,\n", "    orElse: true,\n\t})\n\t/**\n\t * Gets whether the `Deferred` is in progress.\n\t *\n\t * @group Utils\n\t */\n\texport const isInProgress = <A>(deferred: Deferred<A>): deferred is InProgress =>\n\t    pipe(\n\t        deferred,\n", "        matchOrElse({\n\t            inProgress: true,\n\t            orElse: false,\n\t        })\n\t    )\n\t/**\n\t * Gets whether the `Deferred` is resolved.\n\t *\n\t * @group Utils\n\t */\n", "export const isResolved = <A>(deferred: Deferred<A>): deferred is Resolved<A> =>\n\t    pipe(\n\t        deferred,\n\t        matchOrElse({\n\t            resolved: true,\n\t            orElse: false,\n\t        })\n\t    )\n\t/**\n\t * Gets whether the `Deferred` is resolved with data equal to a specific value.\n", " * Uses the `EqualityComparer` if given, otherwise defaults to reference (triple\n\t * equals) equality.\n\t *\n\t * @group Pattern Matching\n\t * @group Utils\n\t *\n\t * @example\n\t * pipe(\n\t *     Deferred.resolved(101),\n\t *     Deferred.isResolvedWith(100, EqualityComparer.Number)\n", " *     // number is just a trivial example here, not required\n\t * ) // => false\n\t */\n\texport const isResolvedWith = <A>(\n\t    expected: A,\n\t    equalityComparer: EqualityComparer<A> = EqualityComparer.Default\n\t) =>\n\t    matchOrElse<A, boolean>({\n\t        resolved: actual => equalityComparer.equals(actual, expected),\n\t        orElse: false,\n", "    })\n\t/* c8 ignore start */\n\t/** @ignore */\n\texport const Deferred = {\n\t    notStarted,\n\t    inProgress,\n\t    resolved,\n\t    match,\n\t    matchOrElse,\n\t    isUnresolved,\n", "    isResolved,\n\t    isInProgress,\n\t    isResolvedWith,\n\t}\n\t/* c8 ignore end */\n"]}
{"filename": "src/Nullable.ts", "chunked_list": ["/**\n\t * The `Nullable` type is, unsurprisingly, the opposite of the built-in `NonNullable`\n\t * type. Sometimes, it is advantageous to model values as `Nullable` instead of using\n\t * the `Option` type. This module is designed to provide a set of useful functions for\n\t * seamlessly working with `Nullable` values in function composition pipelines.\n\t *\n\t * _Some_ of this behavior can be reproduced with JavaScript's nullish-coalescing `??`\n\t * operator, and the nullish-safe accessor `?.` operator. However, those operators lend\n\t * themselves primarily to OO-style programming, not function pipelining or composition.\n\t * These functions are curried and are designed to be used with right-to-left function\n", " * composition like `pipe` and `flow`.\n\t *\n\t * @example\n\t * ```\n\t * declare const str: Nullable<string>\n\t * pipe(\n\t *     str,\n\t *     Nullable.map(s => `${s}!`),\n\t *     Nullable.map(String.reverse),\n\t *     Nullable.defaultWith(() => \"\")   // could also have used Nullable.defaultValue(\"\")\n", " * ) // => \"!yoha\", if str is \"ahoy\"; \"\" if str is null or undefined\n\t * ```\n\t *\n\t * @module Nullable\n\t */\n\timport { EqualityComparer } from \"./EqualityComparer\"\n\timport { NonNullish } from \"./prelude\"\n\texport type Nullable<A extends NonNullish> = A | null | undefined\n\t/**\n\t * Get an `EqualityComparer` that considers `null` and `undefined` equivalent, and\n", " * compares non-nullish values based on the given `EqualityComparer`.\n\t *\n\t * @group Utils\n\t *\n\t * @example\n\t * ```\n\t * const { equals } = Nullable.getEqualityComparer(EqualityComparer.Number)\n\t * equals(null, undefined) // => true\n\t * equals(3, undefined) // => false\n\t * equals(null, 4) // => false\n", " * equals(4, 4) // => true\n\t * equals(4, 5) // => false\n\t * ```\n\t */\n\texport const getEqualityComparer = <A extends NonNullish>(\n\t    equalityComparer: EqualityComparer<A>\n\t) =>\n\t    EqualityComparer.ofEquals<Nullable<A>>(\n\t        (a1, a2) =>\n\t            (a1 == null && a2 == null) ||\n", "            (a1 != null && a2 != null && equalityComparer.equals(a1, a2))\n\t    )\n\t/**\n\t * Similar to `Option.defaultValue`. If the given nullable value is nullish, returns\n\t * the given fallback/default value. If the given nullable value is non-nullish,\n\t * returns the value.\n\t *\n\t * @remarks\n\t * This is more or less equivalent to the `??` nullish-coalescing operator, it just\n\t * works more nicely in function composition pipelines.\n", " *\n\t * @param a The default/fallback value to use.\n\t *\n\t * @returns A non-nullable value.\n\t *\n\t * @group Utils\n\t *\n\t * @example\n\t * pipe(\n\t *     undefined,\n", " *     Nullable.defaultValue(\"\")\n\t * ) // => \"\"\n\t */\n\texport const defaultValue =\n\t    <A extends NonNullish>(a: A) =>\n\t    (nullable: Nullable<A>): NonNullable<A> =>\n\t        nullable != null ? nullable : a\n\t/**\n\t * Similar to `Option.defaultWith`. If the given nullable value is nullish,\n\t * computes the fallback/default value using the given function. If the given\n", " * nullable value is non-nullish, returns the value.\n\t *\n\t * @param f The function to use to compute the default/fallback value.\n\t *\n\t * @returns A non-nullable value.\n\t *\n\t * @group Utils\n\t *\n\t * @example\n\t * pipe(\n", " *     null,\n\t *     Nullable.defaultWith(() => 42)\n\t * ) // => 42\n\t */\n\texport const defaultWith =\n\t    <A extends NonNullish>(f: () => A) =>\n\t    (nullable: Nullable<A>): NonNullable<A> =>\n\t        nullable != null ? nullable : f()\n\t/**\n\t * Similar to `Option.map`. Uses the given function to map the nullable value\n", " * if it is non-nullish. Passes through nullish values unchanged.\n\t *\n\t * @group Mapping\n\t *\n\t * @example\n\t * pipe(\n\t *     32,\n\t *     Nullable.map(n => n * 2)\n\t * ) // => 64\n\t *\n", " * pipe(\n\t *     undefined,\n\t *     Nullable.map((n: number) => n * 2)\n\t * ) // => undefined\n\t */\n\texport const map =\n\t    <A extends NonNullish, B extends NonNullish>(f: (a: A) => B) =>\n\t    (nullable: Nullable<A>): Nullable<B> =>\n\t        nullable != null ? f(nullable) : nullable\n\t/**\n", " * Similar to `Option.bind`. Maps the nullable value using a function that itself\n\t * returns a possibly nullish value, and flattens the result.\n\t *\n\t * @group Mapping\n\t *\n\t * @example\n\t * ```\n\t * type Person = { readonly name?: string }\n\t *\n\t * declare const person: Nullable<Person>\n", " *\n\t * pipe(\n\t *     person,\n\t *     Nullable.bind(p => p.name),\n\t *     Nullable.defaultValue(\"\")\n\t * )\n\t * // => \"Joe\" if both `person` and `person.name` are defined\n\t * // => \"\" if either `person` or `person.name` is undefined\n\t * ```\n\t */\n", "export const bind =\n\t    <A extends NonNullish, B extends NonNullish>(f: (a: A) => Nullable<B>) =>\n\t    (nullable: Nullable<A>): Nullable<B> =>\n\t        nullable != null ? f(nullable) : nullable\n\t/**\n\t * Alias for {@link bind}.\n\t *\n\t * @group Mapping\n\t */\n\texport const flatMap = bind\n", "/* c8 ignore start */\n\t/** @ignore */\n\texport const Nullable = {\n\t    getEqualityComparer,\n\t    defaultValue,\n\t    defaultWith,\n\t    map,\n\t    bind,\n\t    flatMap,\n\t}\n", "/* c8 ignore end */\n"]}
{"filename": "src/prelude.ts", "chunked_list": ["/* c8 ignore start */\n\t/** A helper function to get TypeScript to enforce exhaustive\n\t * case checking in switch blocks.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t/** @ignore */\n\texport const assertExhaustive = (_: never): never => {\n\t    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n\t    throw new Error(`assertExhaustive failed at runtime! It was called with ${_}`)\n\t}\n", "/* c8 ignore end */\n\t/**\n\t * Internal utility type to get slight improvements in\n\t * intellisense for complex TypeScript object types.\n\t *\n\t * @ignore\n\t */\n\texport type Identity<T> = T extends object\n\t    ? NonNullish & {\n\t          [P in keyof T]: T[P]\n", "      }\n\t    : T\n\t/**\n\t * Internal utility type for discriminated unions.\n\t *\n\t * @ignore\n\t */\n\texport type Tagged<Tag extends string, A extends object> = Identity<\n\t    Readonly<\n\t        {\n", "            _tag: Tag\n\t        } & A\n\t    >\n\t>\n\t/**\n\t * Describes a function that is used in filtering operations\n\t * to determine if an element passes some set of criteria.\n\t *\n\t * See `Array.filter` for an example usage.\n\t */\n", "export interface Predicate<A> {\n\t    (a: A): boolean\n\t}\n\t/**\n\t * A sub-type of a Predicate. Represents a type guard that\n\t * holds when the given element can be determined to be a more\n\t * specific type.\n\t *\n\t * See `String.isString` for an example.\n\t */\n", "export interface Refinement<A, B extends A> {\n\t    (a: A): a is B\n\t}\n\t/** @ignore */\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\texport type NonNullish = {}\n"]}
{"filename": "src/Array.ts", "chunked_list": ["/**\n\t * A suite of useful functions for working with readonly arrays. These functions\n\t * provide a curried API that works seamlessly with right-to-left function\n\t * composition and preserve the `readonly` type.\n\t *\n\t * @module Array\n\t */\n\timport { Predicate, Refinement, NonNullish } from \"./prelude\"\n\timport { Option } from \"./Option\"\n\timport { Result } from \"./Result\"\n", "import { pipe } from \"./Composition\"\n\timport { EqualityComparer } from \"./EqualityComparer\"\n\timport { OrderingComparer } from \"./OrderingComparer\"\n\timport { NonEmptyArray } from \"./NonEmptyArray\"\n\t/* eslint-disable func-style */\n\t/**\n\t * Curried and readonly version of the built-in `filter`.\n\t * Accepts a plain predicate function or a refinement\n\t * function (a.k.a. type guard).\n\t *\n", " * @group Filtering\n\t */\n\texport function filter<A, B extends A>(\n\t    refinement: Refinement<A, B>\n\t): (as: readonly A[]) => readonly B[]\n\texport function filter<A>(\n\t    predicate: Predicate<A>\n\t): <B extends A>(bs: readonly B[]) => readonly B[]\n\texport function filter<A>(predicate: Predicate<A>): (as: readonly A[]) => readonly A[]\n\texport function filter<A>(f: Predicate<A>) {\n", "    return <B extends A>(as: readonly B[]) => as.filter(f)\n\t}\n\t/* eslint-enable func-style */\n\t/**\n\t * Like {@link filter}, but the predicate function also accepts the\n\t * index of the element as an argument.\n\t *\n\t * @group Filtering\n\t */\n\texport const filteri =\n", "    <A>(f: (a: A, i: number) => boolean) =>\n\t    (as: readonly A[]): readonly A[] =>\n\t        as.filter(f)\n\t/**\n\t * Curried and readonly version of the built-in `map`.\n\t *\n\t * @group Mapping\n\t */\n\texport const map =\n\t    <A, B>(f: (a: A) => B) =>\n", "    (as: readonly A[]): readonly B[] =>\n\t        as.map(f)\n\t/**\n\t * Like {@link map} but the map function also accepts the\n\t * index of the element as an argument.\n\t *\n\t * @group Mapping\n\t */\n\texport const mapi =\n\t    <A, B>(f: (a: A, i: number) => B) =>\n", "    (as: readonly A[]): readonly B[] =>\n\t        as.map(f)\n\t/**\n\t * Maps each value of the array into an `Option`, and keeps only the inner\n\t * values of those `Option`s that are`Some`. Essentially, this is a combined map +\n\t * filter operation where each element of the array is mapped into an `Option`\n\t * and an `isSome` check is used as the filter function.\n\t *\n\t * @group Mapping\n\t *\n", " * @example\n\t * pipe(\n\t *     [32, null, 55, undefined, 89],   // (number | null | undefined)[]\n\t *     Array.choose(x => pipe(\n\t *         x,                           // number | null | undefined\n\t *         Option.ofNullish,            // Option<number>\n\t *         Option.map(String)           // Option<string>\n\t *     ))                               // string[]\n\t * ) // => [\"32\", \"55\", \"89\"]\n\t */\n", "export const choose =\n\t    <A, B extends NonNullish>(f: (a: A) => Option<B>) =>\n\t    (as: readonly A[]): readonly B[] => {\n\t        const bs: B[] = []\n\t        for (let i = 0; i < as.length; i++) {\n\t            const maybeB = f(as[i])\n\t            if (Option.isSome(maybeB)) {\n\t                bs.push(maybeB.some)\n\t            }\n\t        }\n", "        return bs\n\t    }\n\t/**\n\t * Like {@link choose}, but maps each value of the array into a `Result`,\n\t * and keeps only the values where the projection returns `Ok`. Essentially,\n\t * this is a combined map + filter operation where each element of the array\n\t * is mapped into an `Result` and an `isOk` check is used as the filter function.\n\t *\n\t * @group Mapping\n\t *\n", " * @example\n\t * pipe(\n\t *     [32, null, 55, undefined, 89],       // (number | null | undefined)[]\n\t *     Array.chooseR(x => pipe(\n\t *         x,                               // number | null | undefined\n\t *         Option.ofNullish,                // Option<number>\n\t *         Option.map(String),              // Option<string>\n\t *         Result.ofOption(() => \"err\")     // Result<string, string>\n\t *     ))                                   // string[]\n\t * ) // => [\"32\", \"55\", \"89\"]\n", " */\n\texport const chooseR =\n\t    <A, E, B>(f: (a: A) => Result<B, E>) =>\n\t    (as: readonly A[]): readonly B[] => {\n\t        const bs: B[] = []\n\t        for (let i = 0; i < as.length; i++) {\n\t            const result = f(as[i])\n\t            if (Result.isOk(result)) {\n\t                bs.push(result.ok)\n\t            }\n", "        }\n\t        return bs\n\t    }\n\t/**\n\t * Get the first element of the array (wrapped in `Some`) if\n\t * non-empty, otherwise `None`.\n\t *\n\t * @group Utils\n\t * @group Pattern Matching\n\t *\n", " * @example\n\t * ```ts\n\t * Array.head([]) // => `Option.none`\n\t * Array.head([1, 2, 3]) // => `Option.some(1)`\n\t * ```\n\t */\n\texport const head = <A extends NonNullish>(as: readonly A[]): Option<A> =>\n\t    as.length > 0 ? Option.some(as[0]) : Option.none\n\t/**\n\t * Alias of {@link head}.\n", " *\n\t * @group Utils\n\t * @group Pattern Matching\n\t */\n\texport const first = head\n\t/**\n\t * Get a new array containing all values except the first\n\t * one (wrapped in `Some`) if non-empty, otherwise `None`.\n\t *\n\t * @group Utils\n", " * @group Pattern Matching\n\t *\n\t * @example\n\t * pipe(\n\t *     [1, 2, 3, 4],\n\t *     Array.tail\n\t * ) // => Option.some([2, 3, 4])\n\t */\n\texport const tail = <A>(as: readonly A[]): Option<readonly A[]> => {\n\t    if (as.length === 0) {\n", "        return Option.none\n\t    }\n\t    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t    const [_, ...tail] = as\n\t    return Option.some(tail)\n\t}\n\t/**\n\t * Get the first `n` elements of the array. Will return the entire\n\t * array if `n` is greater than the length of the array.\n\t *\n", " * @param count is normalized to a non-negative integer\n\t *\n\t * @group Utils\n\t *\n\t * @example\n\t * pipe(\n\t *     [1, 2, 3, 4, 5, 6],\n\t *     Array.take(3)\n\t * ) // => [1, 2, 3]\n\t */\n", "export const take =\n\t    (count: number) =>\n\t    <A>(as: readonly A[]): readonly A[] => {\n\t        const c = count <= 0 ? 0 : Math.floor(count)\n\t        if (c > as.length) {\n\t            return as\n\t        }\n\t        const out: A[] = []\n\t        for (let i = 0; i < as.length && i < c; i++) {\n\t            out.push(as[i])\n", "        }\n\t        return out\n\t    }\n\t/**\n\t * Get the remaining elements of the array\n\t * after skipping `n` elements. Returns empty if the\n\t * skip count goes past the end of the array.\n\t *\n\t * @group Utils\n\t *\n", " * @param count is normalized to a non-negative integer\n\t *\n\t * @example\n\t * pipe(\n\t *     [1, 2, 3, 4, 5, 6],\n\t *     Array.skip(3)\n\t * ) // => [4, 5, 6]\n\t */\n\texport const skip =\n\t    (count: number) =>\n", "    <A>(as: readonly A[]): readonly A[] => {\n\t        const c = count <= 0 ? 0 : Math.floor(count)\n\t        if (c >= as.length) {\n\t            return []\n\t        }\n\t        const out: A[] = []\n\t        for (let i = c; i < as.length; i++) {\n\t            out.push(as[i])\n\t        }\n\t        return out\n", "    }\n\t/**\n\t * Curried and readonly version of the built-in `Array.prototype.reduce`. Takes\n\t * the initial value first instead of last.\n\t *\n\t * @group Utils\n\t * @group Folding\n\t */\n\texport const reduce =\n\t    <A, B>(initialValue: B, reducer: (acc: B, next: A) => B) =>\n", "    (as: readonly A[]): B =>\n\t        as.reduce(reducer, initialValue)\n\t/**\n\t * Curried and readonly version of the built-in `Array.prototype.reduceRight`.\n\t * Takes the initial value first instead of last.\n\t *\n\t * @group Utils\n\t * @group Folding\n\t */\n\texport const reduceRight =\n", "    <A, B>(initialValue: B, reducer: (acc: B, next: A) => B) =>\n\t    (as: readonly A[]): B =>\n\t        as.reduceRight(reducer, initialValue)\n\tconst isRawValue = <A, R>(caseFn: R | ((ok: A) => R)): caseFn is R =>\n\t    typeof caseFn !== \"function\"\n\tconst getMatcherResult = <T, R>(match: ((t: T) => R) | R, arg: T) =>\n\t    isRawValue(match) ? match : match(arg)\n\t/**\n\t * @ignore\n\t */\n", "interface ArrayMatcher<A, R> {\n\t    empty: (() => R) | R\n\t    nonEmpty: ((as: NonEmptyArray<A>) => R) | R\n\t}\n\t/**\n\t * Exhaustive pattern match against an array to \"unwrap\" its values. Provide\n\t * a matcher object to handle both the `empty` and `nonEmpty` cases.\n\t * The matcher can use lambdas or raw values. In the `nonEmpty` case,\n\t * the lambda will be given a `NonEmptyArray`.\n\t *\n", " * @group Pattern Matching\n\t *\n\t * @example\n\t * ```ts\n\t * pipe(\n\t *     [\"a\", \"b\"],\n\t *     Array.match({\n\t *         empty: () => \"default\",\n\t *         nonEmpty: Array.reduceRight(\"\", (a, b) => `${a}${b}`)\n\t *     })\n", " * ) // => \"ba\"\n\t * ```\n\t */\n\texport const match =\n\t    <A, R>(matcher: ArrayMatcher<A, R>) =>\n\t    (as: readonly A[]): R =>\n\t        as.length > 0\n\t            ? getMatcherResult(matcher.nonEmpty, as as NonEmptyArray<A>)\n\t            : getMatcherResult(matcher.empty, undefined)\n\t/**\n", " * Type guard that tests whether the given array is equivalent\n\t * to the empty tuple type.\n\t *\n\t * @group Type Guards\n\t * @group Utils\n\t */\n\texport const isEmpty = <A>(as: readonly A[]): as is readonly [] => as.length === 0\n\t/**\n\t * Type guard that tests whether the given array is a `NonEmptyArray`\n\t *\n", " * @group Type Guards\n\t * @group Utils\n\t */\n\texport const isNonEmpty = <A>(as: readonly A[]): as is NonEmptyArray<A> => as.length > 0\n\t/**\n\t * Also commonly known as `flatMap`. Maps each element of the array\n\t * given a function that itself returns an array, then flattens the result.\n\t *\n\t * @group Mapping\n\t *\n", " * @example\n\t * pipe(\n\t *     [1, 2, 3],\n\t *     Array.bind(n => [n, n])\n\t * ) // => [1, 1, 2, 2, 3, 3]\n\t */\n\texport const bind =\n\t    <A, B>(f: (a: A) => readonly B[]) =>\n\t    (as: readonly A[]): readonly B[] =>\n\t        as.flatMap(f)\n", "/**\n\t * Alias of {@link bind}.\n\t *\n\t * @group Mapping\n\t */\n\texport const flatMap = bind\n\t/**\n\t * Add an element to the _end_ of an array. Always returns\n\t * a `NonEmptyArray`.\n\t *\n", " * @group Utils\n\t */\n\texport const append =\n\t    <A>(a: A) =>\n\t    (as: readonly A[]): NonEmptyArray<A> =>\n\t        [...as, a] as unknown as NonEmptyArray<A>\n\t/**\n\t * Also known as `cons`. Insert an element at the beginning\n\t * of an array. Always returns a `NonEmptyArray`.\n\t *\n", " * @group Utils\n\t *\n\t * @example\n\t * pipe(\n\t *     [2, 3],\n\t *     Array.prepend(1)\n\t * ) // => [1, 2, 3]\n\t */\n\texport const prepend =\n\t    <A>(a: A) =>\n", "    (as: readonly A[]): NonEmptyArray<A> =>\n\t        [a, ...as]\n\t/**\n\t * Return a Map of keys to groups, where the selector function\n\t * is used to generate a string key that determines in which group\n\t * each array element is placed.\n\t *\n\t * @group Grouping\n\t * @group Utils\n\t *\n", " * @example\n\t * pipe(\n\t *     [1, 2, 1, 2, 3, 3, 5],\n\t *     Array.groupBy(String)\n\t * )\n\t * // structurally equivalent to\n\t * new Map([\n\t *     ['1', [1, 1]],\n\t *     ['2', [2, 2]],\n\t *     ['3', [3, 3]],\n", " *     ['5', [5]]\n\t * ])\n\t */\n\texport const groupBy =\n\t    <A>(selector: (a: A) => string) =>\n\t    (as: readonly A[]): ReadonlyMap<string, NonEmptyArray<A>> => {\n\t        const groups: Map<string, NonEmptyArray<A>> = new Map()\n\t        as.forEach(a => {\n\t            const key = selector(a)\n\t            return groups.has(key)\n", "                ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t                  groups.set(key, pipe(groups.get(key)!, append(a)))\n\t                : groups.set(key, [a])\n\t        })\n\t        return groups\n\t    }\n\t/**\n\t * Add an array of values to the _end_ of the subsequently\n\t * passed (partially applied) array, in a way that makes sense\n\t * when reading top-to-bottom/left-to-right using `pipe`.\n", " *\n\t * @group Utils\n\t *\n\t * @example\n\t * pipe(\n\t *     [1, 2],\n\t *     Array.concat([3, 4])\n\t * ) // => [1, 2, 3, 4]\n\t */\n\texport const concat =\n", "    <A>(addToEnd: readonly A[]) =>\n\t    (as: readonly A[]): readonly A[] =>\n\t        [...as, ...addToEnd]\n\t/**\n\t * Like {@link concat}, except this adds an array of values to the\n\t * _beginning_ of the subsequently (partially applied) array,\n\t * in a way that makes more sense when _not_ using `pipe`.\n\t *\n\t * @group Utils\n\t *\n", " * @example\n\t * ```ts\n\t * // Reads \"backwards\" when used with `pipe`\n\t * pipe(\n\t *     [\"a\", \"b\"],\n\t *     Array.concatFirst([\"c\", \"d\"])\n\t * ) // => [\"c\", \"d\", \"a\", \"b\"]\n\t * // Reads better when *not* used with `pipe`\n\t * Array.concatFirst([\"a\", \"b\"])([\"c\", \"d\"]) // => [\"a\", \"b\", \"c\", \"d\"]\n\t * ```\n", " */\n\texport const concatFirst =\n\t    <A>(addToFront: readonly A[]) =>\n\t    (as: readonly A[]): readonly A[] =>\n\t        [...addToFront, ...as]\n\t/**\n\t * Returns true if at least one element of the array\n\t * satisfies the given predicate. Curried version of\n\t * `Array.prototype.some`.\n\t *\n", " * @group Utils\n\t */\n\texport const exists =\n\t    <A>(predicate: (a: A) => boolean) =>\n\t    (as: readonly A[]): boolean =>\n\t        as.some(predicate)\n\t/**\n\t * Alias of {@link exists}.\n\t *\n\t * @group Utils\n", " */\n\texport const some = exists\n\t/**\n\t * Equivalent to calling `Array.prototype.flat()` with a depth of 1.\n\t *\n\t * @group Utils\n\t */\n\texport const flatten = <A>(as: readonly (readonly A[])[]): readonly A[] => as.flat()\n\t/**\n\t * Split an array into chunks of a specified size. The final\n", " * chunk will contain fewer elements than the specified size if\n\t * the array is not evenly divisible by the specified size.\n\t *\n\t * @remarks\n\t * **Note:** Will return `[]`, _not_ `[[]]` if given an empty array.\n\t *\n\t * @param maxChunkSize Normalized to a positive integer.\n\t *\n\t * @example\n\t * pipe(\n", " *     [\"a\", \"b\", \"c\", \"d\", \"e\"],\n\t *     Array.chunk(2)\n\t * ) // => [[\"a\", \"b\"], [\"c\", \"d\"], [\"e\"]]\n\t *\n\t * @group Utils\n\t * @group Grouping\n\t */\n\texport const chunk =\n\t    (maxChunkSize: number) =>\n\t    <A>(as: readonly A[]): readonly NonEmptyArray<A>[] => {\n", "        if (isEmpty(as)) {\n\t            return []\n\t        }\n\t        const chunkSize = maxChunkSize <= 1 ? 1 : Math.floor(maxChunkSize)\n\t        const numChunks = Math.ceil(as.length / chunkSize)\n\t        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\t        const chunks: A[][] = [...globalThis.Array(numChunks)].map(() => [])\n\t        let chunkIndex = 0\n\t        for (let i = 0; i < as.length; i++) {\n\t            if (i !== 0 && i % chunkSize === 0) {\n", "                chunkIndex++\n\t            }\n\t            chunks[chunkIndex].push(as[i])\n\t        }\n\t        return chunks as unknown as readonly NonEmptyArray<A>[]\n\t    }\n\t/**\n\t * Get the length of an array.\n\t *\n\t * @group Utils\n", " */\n\texport const length = <A>(as: readonly A[]) => as.length\n\t/**\n\t * Returns true if the given element is in the array.\n\t * Optionally, pass an `EqualityComparer` to use. Uses\n\t * reference (triple equals) equality by default.\n\t *\n\t * @group Utils\n\t */\n\texport const contains =\n", "    <A>(a: A, equalityComparer: EqualityComparer<A> = EqualityComparer.Default) =>\n\t    (as: readonly A[]): boolean => {\n\t        if (isEmpty(as)) {\n\t            return false\n\t        }\n\t        const predicate = (test: A) => equalityComparer.equals(a, test)\n\t        return as.some(predicate)\n\t    }\n\t/**\n\t * Return a new array containing only unique values. If\n", " * passed, uses the `EqualityComparer` to test uniqueness.\n\t * Defaults to using reference equality (triple equals).\n\t *\n\t * @group Utils\n\t *\n\t * @example\n\t * pipe(\n\t *     [3, 2, 1, 2, 1, 4, 9],\n\t *     Array.uniq()\n\t * ) // => [3, 2, 1, 4, 9]\n", " */\n\texport const uniq =\n\t    <A>(equalityComparer?: EqualityComparer<A>) =>\n\t    (as: readonly A[]): readonly A[] => {\n\t        if (isEmpty(as)) {\n\t            return []\n\t        }\n\t        const out: A[] = []\n\t        as.forEach(a => {\n\t            if (!contains(a, equalityComparer)(out)) {\n", "                out.push(a)\n\t            }\n\t        })\n\t        return out\n\t    }\n\t/**\n\t * Returns a new array containing only unique values as determined\n\t * by mapping each element with the given function and optionally\n\t * passing an equality comparer to use on the mapped elements.\n\t * Defaults to using reference equality (triple equals).\n", " *\n\t * @group Utils\n\t *\n\t * @example\n\t * pipe(\n\t *     [{ name: \"Rufus\" }, { name: \"Rex\" }, { name: \"Rufus\" }],\n\t *     Array.uniqBy(p => p.name)\n\t * ) // => [{ name: \"Rufus\" }, { name: \"Rex\" }]\n\t */\n\texport const uniqBy =\n", "    <A, B>(f: (a: A) => B, equalityComparer?: EqualityComparer<B>) =>\n\t    (as: readonly A[]): readonly A[] => {\n\t        if (isEmpty(as)) {\n\t            return []\n\t        }\n\t        const out: A[] = []\n\t        const projections: B[] = []\n\t        as.forEach(a => {\n\t            const projected = f(a)\n\t            if (!contains(projected, equalityComparer)(projections)) {\n", "                projections.push(projected)\n\t                out.push(a)\n\t            }\n\t        })\n\t        return out\n\t    }\n\t/**\n\t * Get a new array with elements sorted. If given, will use the\n\t * `OrderingComparer`. Otherwise, uses the default JavaScript ASCII-based sort.\n\t *\n", " * @group Utils\n\t *\n\t * @example\n\t * declare const petByNameComparer: OrderingComparer<Pet>\n\t *\n\t * const pets: readonly Pet[] = [\n\t *     { name: \"Fido\" },\n\t *     { name: \"Albus\" },\n\t *     { name: \"Rex\" },\n\t *     { name: \"Gerald\" }\n", " * ]\n\t *\n\t * pipe(\n\t *     pets,\n\t *     Array.sort(petByNameComparer),\n\t *     Array.map(p => p.name)\n\t * ) // => [ \"Albus\", \"Fido\", \"Gerald\", \"Rex\" ]\n\t */\n\texport const sort =\n\t    <A>(orderingComparer?: OrderingComparer<A>) =>\n", "    (as: readonly A[]): readonly A[] => {\n\t        if (isEmpty(as)) {\n\t            return []\n\t        }\n\t        return as.slice(0).sort(orderingComparer?.compare)\n\t    }\n\t/**\n\t * Get a new array with elements sorted based on the sort-order\n\t * of each mapped element produced by the given mapping function.\n\t * If given, will use the `OrderingComparer`. Otherwise, defaults to an\n", " * OrderingComparer that `String`s the mapped element and uses the\n\t * default ASCII-based sort.\n\t *\n\t * @group Utils\n\t */\n\texport const sortBy =\n\t    <A, B>(\n\t        f: (a: A) => B,\n\t        orderingComparer: OrderingComparer<B> = OrderingComparer.Default\n\t    ) =>\n", "    (as: readonly A[]): readonly A[] =>\n\t        isEmpty(as)\n\t            ? []\n\t            : as.slice(0).sort((o1: A, o2: A) => orderingComparer.compare(f(o1), f(o2)))\n\t/**\n\t * Get a new array with the elements in reverse order.\n\t *\n\t * @group Utils\n\t */\n\texport const reverse = <A>(as: readonly A[]): readonly A[] => as.slice(0).reverse()\n", "/**\n\t * Get the _first_ element in the array (wrapped in a `Some`) that\n\t * returns `true` for the given predicate, or `None` if no such\n\t * element exists.\n\t *\n\t * @group Utils\n\t */\n\texport const find =\n\t    <A extends NonNullish>(predicate: Predicate<A>) =>\n\t    (as: readonly A[]): Option<A> =>\n", "        Option.ofNullish(as.find(predicate))\n\t/**\n\t * Get the _first_ index of the array (wrapped in a `Some`) for\n\t * which the element at that index returns true for the given predicate,\n\t * or `None` if no such index/element exists.\n\t *\n\t * @group Utils\n\t */\n\texport const findIndex =\n\t    <A>(predicate: Predicate<A>) =>\n", "    (as: readonly A[]): Option<number> => {\n\t        const result = as.findIndex(predicate)\n\t        return result < 0 ? Option.none : Option.some(result)\n\t    }\n\t/**\n\t * Get a new array containing only those elements that are not\n\t * in the given `excludeThese` array. If given, will use the\n\t * EqualityComparer. Otherwise, defaults to reference equality\n\t * (triple equals).\n\t *\n", " * @group Utils\n\t *\n\t * @example\n\t * pipe(\n\t *     [1, 2, 3, 4, 5],\n\t *     Array.except([2, 5])\n\t * ) // => [1, 3, 4]\n\t */\n\texport const except =\n\t    <A>(excludeThese: readonly A[], equalityComparer?: EqualityComparer<A>) =>\n", "    (as: readonly A[]): readonly A[] => {\n\t        if (isEmpty(as)) {\n\t            return []\n\t        }\n\t        if (isEmpty(excludeThese)) {\n\t            return as\n\t        }\n\t        const out: A[] = []\n\t        for (let i = 0; i < as.length; i++) {\n\t            if (!pipe(excludeThese, contains(as[i], equalityComparer))) {\n", "                out.push(as[i])\n\t            }\n\t        }\n\t        return out\n\t    }\n\t/**\n\t * Get a new array containing the set union of two arrays, defined as the\n\t * set of elements contained in both arrays. **Remember:** sets only contain\n\t * unique elements. If you just need to join two arrays together, use {@link concat}.\n\t *\n", " * @group Utils\n\t */\n\texport const union =\n\t    <A>(unionWith: readonly A[], equalityComparer?: EqualityComparer<A>) =>\n\t    (as: readonly A[]): readonly A[] =>\n\t        isEmpty(unionWith) && isEmpty(as)\n\t            ? []\n\t            : pipe(as, concat(unionWith), uniq(equalityComparer))\n\t/**\n\t * Get an {@link EqualityComparer} that represents structural equality for an array\n", " * of type `A` by giving this function an `EqualityComparer` for each `A` element.\n\t *\n\t * @group Equality\n\t * @group Utils\n\t *\n\t * @param equalityComparer The `EqualityComparer` to use for element-by-element comparison.\n\t *\n\t * @returns A new `EqualityComparer` instance\n\t *\n\t * @example\n", " * const eq = Array.getEqualityComparer(EqualityComparer.Number)\n\t * eq.equals([1, 2, 3], [1, 2, 3]) // => true\n\t * eq.equals([1, 3], [3, 1]) // => false\n\t */\n\texport const getEqualityComparer = <A>({\n\t    equals,\n\t}: EqualityComparer<A>): EqualityComparer<readonly A[]> =>\n\t    EqualityComparer.ofEquals((arr1, arr2) => {\n\t        if (isEmpty(arr1) && isEmpty(arr2)) {\n\t            return true\n", "        }\n\t        if (arr1.length !== arr2.length) {\n\t            return false\n\t        }\n\t        for (let i = 0; i < arr1.length; i++) {\n\t            if (!equals(arr1[i], arr2[i])) {\n\t                return false\n\t            }\n\t        }\n\t        return true\n", "    })\n\t/**\n\t * Does not affect the passed array at runtime. (Effectively executes an identity\n\t * function) Removes the `readonly` part of the **type** only.\n\t *\n\t * @group Utils\n\t */\n\texport const asMutable = <A>(as: readonly A[]) => as as A[]\n\t/**\n\t * Execute an arbitrary side effect for each element of the array. Essentially a\n", " * curried version of the built-in `forEach` method.\n\t *\n\t * @group Utils\n\t */\n\texport const iter =\n\t    <A>(f: (a: A) => void) =>\n\t    (as: readonly A[]): void =>\n\t        as.forEach(a => f(a))\n\t/** @ignore */\n\texport const Array = {\n", "    filter,\n\t    filteri,\n\t    map,\n\t    mapi,\n\t    bind,\n\t    flatMap,\n\t    choose,\n\t    chooseR,\n\t    head,\n\t    first,\n", "    tail,\n\t    take,\n\t    skip,\n\t    reduce,\n\t    reduceRight,\n\t    match,\n\t    isEmpty,\n\t    isNonEmpty,\n\t    append,\n\t    prepend,\n", "    groupBy,\n\t    concat,\n\t    concatFirst,\n\t    exists,\n\t    some,\n\t    flatten,\n\t    chunk,\n\t    length,\n\t    contains,\n\t    uniq,\n", "    uniqBy,\n\t    sort,\n\t    sortBy,\n\t    reverse,\n\t    find,\n\t    findIndex,\n\t    except,\n\t    union,\n\t    getEqualityComparer,\n\t    asMutable,\n", "    iter,\n\t}\n\t/* c8 ignore end */\n"]}
{"filename": "src/Result.ts", "chunked_list": ["/**\n\t * The `Result` type represents the outcome of a completed operation\n\t * that either succeeded with some `Ok` value (also called a \"success\"\n\t * or \"right\" value), or failed with some `Err` value (also called a\n\t * \"failure\" or \"left\" value).\n\t *\n\t * Generally speaking, `Result` is not intended to _replace_ exception\n\t * handling, but to augment it, so that exceptions can be used to handle\n\t * truly _exceptional_ things. (i.e., Is it really exceptional that a\n\t * network request failed?)\n", " *\n\t * This API has been optimized for use with left-to-right function composition\n\t * using `pipe` and `flow`.\n\t *\n\t * @example\n\t * ```\n\t * pipe(\n\t *     Result.tryCatch(() => readFileMightThrow()),\n\t *     Result.mapErr(FileError.create),\n\t *     Result.bind(fileText => pipe(\n", " *         Result.tryCatch(() => transmitMightThrow(fileText)),\n\t *         Result.mapErr(FileError.create)\n\t *     )),\n\t *     Result.map(transmitResponse => transmitResponse?.status),\n\t *     Result.defaultValue(\"failed\")\n\t * )\n\t * // may return, e.g., \"pending\" if everything worked\n\t * // or \"failed\" if something fell down along the way\n\t * ```\n\t *\n", " * @module Result\n\t */\n\t/* eslint-disable @typescript-eslint/no-empty-interface */\n\timport { Tagged, assertExhaustive, Refinement, NonNullish } from \"./prelude\"\n\timport { Option } from \"./Option\"\n\timport { flow, pipe } from \"./Composition\"\n\timport { EqualityComparer } from \"./EqualityComparer\"\n\texport interface Ok<A> extends Tagged<\"Ok\", { ok: A }> {}\n\texport interface Err<E> extends Tagged<\"Err\", { err: E }> {}\n\texport type Result<A, E> = Ok<A> | Err<E>\n", "/**\n\t * Construct a new Ok instance.\n\t *\n\t * @group Constructors\n\t *\n\t * @returns A new Ok instance containing the given value.\n\t */\n\texport const ok = <A, E = never>(ok: A): Result<A, E> => ({\n\t    _tag: \"Ok\",\n\t    ok,\n", "})\n\t/**\n\t * Construct a new Err instance.\n\t *\n\t * @group Constructors\n\t *\n\t * @returns A new Err instance with the given value. */\n\texport const err = <E, A = never>(err: E): Result<A, E> => ({\n\t    _tag: \"Err\",\n\t    err,\n", "})\n\t/**\n\t * Alias for {@link ok}.\n\t *\n\t * @group Constructors\n\t */\n\texport const of = ok\n\t/**\n\t * @ignore\n\t */\n", "interface ResultMatcher<A, E, R> {\n\t    readonly ok: R | ((ok: A) => R)\n\t    readonly err: R | ((err: E) => R)\n\t}\n\tconst isRawValue = <A, E, R>(caseFn: R | ((ok: A) => R) | ((err: E) => E)): caseFn is R =>\n\t    typeof caseFn !== \"function\"\n\tconst getMatcherResult = <T, R>(match: ((t: T) => R) | R, arg: T) =>\n\t    isRawValue(match) ? match : match(arg)\n\t/**\n\t * Exhaustive pattern match against a `Result` to \"unwrap\" its inner\n", " * value. Pass a matcher function with cases for `ok` and `err` that\n\t * can either be lambdas or raw values.\n\t *\n\t * @group Pattern Matching\n\t *\n\t * @example\n\t * ```\n\t * pipe(\n\t *     Result.err(\"failure\"),\n\t *     Result.match({\n", " *         ok: a => `${a.length}`,\n\t *         err: s => `${s}!`\n\t *     })\n\t * ) // => \"failure!\"\n\t * ```\n\t */\n\texport const match =\n\t    <A, E, R>(matcher: ResultMatcher<A, E, R>) =>\n\t    (result: Result<A, E>) => {\n\t        switch (result._tag) {\n", "            case \"Ok\":\n\t                return getMatcherResult(matcher.ok, result.ok)\n\t            case \"Err\":\n\t                return getMatcherResult(matcher.err, result.err)\n\t            /* c8 ignore next 2 */\n\t            default:\n\t                return assertExhaustive(result)\n\t        }\n\t    }\n\t/**\n", " * Filter a `Result` using a type guard (a.k.a. `Refinement` function) that, if\n\t * it succeeds, will return an `Ok` with a narrowed type. If it fails, will use\n\t * the given `onFail` function to produce an error branch.\n\t *\n\t * @group Utils\n\t * @group Filtering\n\t *\n\t * @example\n\t * ```\n\t * const isCat = (s: string): s is \"cat\" => s === \"cat\"\n", " * pipe(\n\t *     Result.ok(\"dog\"),\n\t *     Result.refine(isCat, a => `\"${a}\" is not \"cat\"!`)\n\t * ) // => Result.err('\"dog\" is not \"cat\"!')\n\t * ```\n\t */\n\texport const refine =\n\t    <A, B extends A, E>(refinement: Refinement<A, B>, onFail: (a: A) => E) =>\n\t    (result: Result<A, E>): Result<B, E> =>\n\t        pipe(\n", "            result,\n\t            match({\n\t                ok: a => (refinement(a) ? ok(a) : err(onFail(a))),\n\t                err: e => err(e),\n\t            })\n\t        )\n\t/**\n\t * Map the inner `Ok` value using the given function and\n\t * return a new `Result`. Passes `Err` values through as-is.\n\t *\n", " * @group Mapping\n\t *\n\t * @example\n\t * pipe(\n\t *     Result.ok(2),\n\t *     Result.map(n => n + 3)\n\t * ) // => Result.ok(5)\n\t */\n\texport const map =\n\t    <A, B>(f: (a: A) => B) =>\n", "    <E>(result: Result<A, E>): Result<B, E> =>\n\t        pipe(\n\t            result,\n\t            match({\n\t                ok: a => ok(f(a)),\n\t                err: e => err(e),\n\t            })\n\t        )\n\t/**\n\t * Map the inner `Err` value using the given function and\n", " * return a new `Result`. `Ok` values are passed through as-is.\n\t *\n\t * @group Mapping\n\t *\n\t * @example\n\t * pipe(\n\t *     Result.err(\"cheese melted\"),\n\t *     Result.mapErr(s => s.length)\n\t * ) // => Result.err(13)\n\t */\n", "export const mapErr =\n\t    <E1, E2>(f: (e: E1) => E2) =>\n\t    <A>(result: Result<A, E1>) =>\n\t        pipe(\n\t            result,\n\t            match({\n\t                ok: a => ok(a),\n\t                err: e => err(f(e)),\n\t            })\n\t        )\n", "/**\n\t * Map both branches of the Result by specifying a lambda\n\t * to use in either case. Equivalent to calling {@link map} followed\n\t * by {@link mapErr}.\n\t *\n\t * @group Mapping\n\t */\n\texport const mapBoth = <A1, E1, A2, E2>(mapOk: (a: A1) => A2, mapErr: (e: E1) => E2) =>\n\t    match<A1, E1, Result<A2, E2>>({\n\t        ok: a => ok(mapOk(a)),\n", "        err: e => err(mapErr(e)),\n\t    })\n\t/**\n\t * Return the inner `Ok` value or the given default value\n\t * if the Result is an Err.\n\t *\n\t * @group Pattern Matching\n\t */\n\texport const defaultValue =\n\t    <A>(a: A) =>\n", "    <E>(result: Result<A, E>) =>\n\t        pipe(\n\t            result,\n\t            match({\n\t                ok: a => a,\n\t                err: a,\n\t            })\n\t        )\n\t/**\n\t * Return the inner `Ok` value or use the given lambda\n", " * to compute the default value if the `Result` is an `Err`.\n\t *\n\t * @group Pattern Matching\n\t */\n\texport const defaultWith =\n\t    <A>(f: () => A) =>\n\t    <E>(result: Result<A, E>) =>\n\t        pipe(\n\t            result,\n\t            match({\n", "                ok: a => a,\n\t                err: f,\n\t            })\n\t        )\n\t/**\n\t * Maps the inner `Ok` value using a function that\n\t * also returns a `Result`, and flattens the result.\n\t * `Err` values are passed through as-is. This function\n\t * is also referred to as `flatMap`.\n\t *\n", " * @group Mapping\n\t *\n\t * @example\n\t * pipe(\n\t *     Result.ok(\"a\"),\n\t *     Result.bind(s =>\n\t *         s === \"a\" ? Result.ok(\"got an a!\") : Result.err(\"not an a\")\n\t *     ),\n\t *     Result.defaultValue(\"\")\n\t * ) // => \"got an a!\"\n", " */\n\texport const bind = <A, E, B>(f: (a: A) => Result<B, E>) =>\n\t    match<A, E, Result<B, E>>({\n\t        ok: f,\n\t        err: e => err(e),\n\t    })\n\t/**\n\t * Alias for {@link bind}.\n\t *\n\t * @group Mapping\n", " */\n\texport const flatMap = bind\n\t/**\n\t * A type guard (a.k.a. `Refinement`) that holds if the result\n\t * is an `Ok`. Allows the TypeScript compiler to narrow the type\n\t * and allow type-safe access to `.ok`.\n\t *\n\t * @group Type Guards\n\t */\n\texport const isOk = <A, E = never>(result: Result<A, E>): result is Ok<A> =>\n", "    result._tag === \"Ok\"\n\t/**\n\t * A type guard (a.k.a. `Refinement`) that holds if the result is\n\t * an `Err`. Allows the TypeScript compiler to narrow the type and\n\t * allow safe access to `.err`.\n\t *\n\t * @group Type Guards\n\t */\n\texport const isErr = <E, A = never>(result: Result<A, E>): result is Err<E> =>\n\t    result._tag === \"Err\"\n", "/**\n\t * Map a tuple of `Result`s.\n\t *\n\t * If given two `Ok` values, uses the given mapper function and produces\n\t * a new `Ok` instance with the result. If either of the `Result`s are an\n\t * `Err`, returns an `Err`. If both results are an `Err`, returns the first\n\t * one and ignores the second.\n\t *\n\t * @remarks\n\t * This is effectively a shortcut to pattern matching a 2-tuple of Results.\n", " *\n\t * @group Mapping\n\t */\n\texport const map2 =\n\t    <A, B, C>(map: (a: A, b: B) => C) =>\n\t    <E>(results: readonly [Result<A, E>, Result<B, E>]): Result<C, E> => {\n\t        if (isOk(results[0]) && isOk(results[1])) {\n\t            return ok(map(results[0].ok, results[1].ok))\n\t        } else if (isErr(results[0])) {\n\t            return err(results[0].err)\n", "        } else {\n\t            return err((results[1] as Err<E>).err)\n\t        }\n\t    }\n\t/**\n\t * Map a 3-tuple of `Result`s.\n\t *\n\t * If given three `Ok` values, uses the given mapper function and returns\n\t * a new `Ok` value with the result. If any of the `Result`s are an `Err`,\n\t * returns an `Err`.\n", " *\n\t * If multiple `Result`s are an `Err`, returns the first one found and\n\t * ignores the others.\n\t *\n\t * @remarks\n\t * This is effectively a shortcut to pattern matching a 3-tuple of Results.\n\t *\n\t * @group Pattern Matching\n\t */\n\texport const map3 =\n", "    <A, B, C, D>(map: (a: A, b: B, c: C) => D) =>\n\t    <E>(results: readonly [Result<A, E>, Result<B, E>, Result<C, E>]): Result<D, E> => {\n\t        if (isOk(results[0]) && isOk(results[1]) && isOk(results[2])) {\n\t            return ok(map(results[0].ok, results[1].ok, results[2].ok))\n\t        } else if (isErr(results[0])) {\n\t            return err(results[0].err)\n\t        } else if (isErr(results[1])) {\n\t            return err(results[1].err)\n\t        } else {\n\t            return err((results[2] as Err<E>).err)\n", "        }\n\t    }\n\t/* eslint-disable func-style */\n\t/**\n\t * Attempts to invoke a function that may throw. If the function\n\t * succeeds, returns an Ok with the result. If the function throws,\n\t * returns an Err containing the thrown Error, optionally transformed.\n\t *\n\t * @group Utils\n\t *\n", " * @param onThrow\n\t * Optional. If given, accepts the thrown `unknown` object and produces\n\t * the Err branch. If omitted, the thrown object will be stringified and\n\t * wrapped in a new Error instance if it is not already an Error instance.\n\t */\n\texport function tryCatch<A>(mightThrow: () => A): Result<A, Error>\n\texport function tryCatch<A, E = unknown>(\n\t    mightThrow: () => A,\n\t    onThrow: (thrown: unknown) => E\n\t): Result<A, E>\n", "export function tryCatch<A, E = unknown>(\n\t    mightThrow: () => A,\n\t    onThrow?: (err: unknown) => E\n\t    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t): Result<A, any> {\n\t    const toError = (err: unknown) => (err instanceof Error ? err : Error(String(err)))\n\t    try {\n\t        return ok(mightThrow())\n\t    } catch (err) {\n\t        if (onThrow != null) {\n", "            return Result.err(onThrow(err))\n\t        }\n\t        return Result.err(toError(err))\n\t    }\n\t}\n\t/* eslint-enable func-style */\n\t/**\n\t * Allows some arbitrary side-effect function to be called\n\t * using the wrapped `Ok` value. Useful for debugging and logging.\n\t *\n", " * @group Utils\n\t *\n\t * @param f Should not mutate its arguments. Use {@link map} if you\n\t * want to map the inner value of the Result instead.\n\t *\n\t * @example\n\t * ```\n\t * pipe(\n\t *     Result.ok(23),\n\t *     Result.tee(console.log), // logs `23`\n", " *     Result.map(n => n + 1), // inner value is unchanged\n\t *     Result.defaultValue(0)\n\t * ) // => 24\n\t * ```\n\t */\n\texport const tee =\n\t    <A>(f: (a: A) => void) =>\n\t    <E>(result: Result<A, E>): Result<A, E> =>\n\t        pipe(\n\t            result,\n", "            match({\n\t                ok: a => {\n\t                    f(a)\n\t                    return ok(a)\n\t                },\n\t                err: e => err(e),\n\t            })\n\t        )\n\t/**\n\t * Allows some arbitrary side-effect function to be called\n", " * using the wrapped `Err` value. Useful for debugging and logging.\n\t *\n\t * @param f Should not mutate its arguments. Use {@link mapErr} if\n\t * you want to map the inner `Err` value.\n\t *\n\t * @group Utils\n\t *\n\t * @example\n\t * ```\n\t * pipe(\n", " *     Result.err(\"melted\"),\n\t *     Result.teeErr(console.log),   // logs `melted`\n\t *     Result.mapErr(s => s.length), // inner value is unchanged\n\t * ) // => Result.err(6)\n\t * ```\n\t */\n\texport const teeErr =\n\t    <E>(f: (e: E) => void) =>\n\t    <A>(result: Result<A, E>): Result<A, E> =>\n\t        pipe(\n", "            result,\n\t            match({\n\t                ok: a => ok(a),\n\t                err: e => {\n\t                    f(e)\n\t                    return err(e)\n\t                },\n\t            })\n\t        )\n\t/**\n", " * Converts an `Option` to a `Result`.\n\t *\n\t * @group Constructors\n\t * @group Utils\n\t *\n\t * @param onNone Used to convert a `None` branch into an `Err` branch.\n\t *\n\t * @returns a new `Result`.\n\t */\n\texport const ofOption = <A extends NonNullish, E>(onNone: () => E) =>\n", "    Option.match<A, Result<A, E>>({\n\t        some: ok,\n\t        none: flow(onNone, err),\n\t    })\n\t/**\n\t * Get an `EqualityComparer` for an `Result<A, E>` by giving this function an\n\t * `EqualityComparer` for type `A` and one for type `E`. Represents structural\n\t * (value-based) equality for the `Result` type.\n\t *\n\t * @group Equality\n", " * @group Utils\n\t *\n\t * @param equalityComparerA The `EqualityComparer` to use for the inner ok value.\n\t * @param equalityComparerE The `EqualityComparer` to use for the inner err value.\n\t *\n\t * @returns A new `EqualityComparer` instance\n\t */\n\texport const getEqualityComparer = <A, E>(\n\t    equalityComparerA: EqualityComparer<A>,\n\t    equalityComparerE: EqualityComparer<E>\n", "): EqualityComparer<Result<A, E>> =>\n\t    EqualityComparer.ofEquals((r1, r2) => {\n\t        if (isErr(r1) && isErr(r2) && equalityComparerE.equals(r1.err, r2.err)) {\n\t            return true\n\t        }\n\t        return pipe(\n\t            [r1, r2] as const,\n\t            map2((a1: A, a2: A) => equalityComparerA.equals(a1, a2)),\n\t            defaultValue(false)\n\t        )\n", "    })\n\t/* c8 ignore start */\n\t/** @ignore */\n\texport const Result = {\n\t    ok,\n\t    of,\n\t    err,\n\t    isOk,\n\t    isErr,\n\t    match,\n", "    map,\n\t    map2,\n\t    map3,\n\t    mapErr,\n\t    mapBoth,\n\t    bind,\n\t    flatMap,\n\t    defaultValue,\n\t    defaultWith,\n\t    tryCatch,\n", "    tee,\n\t    teeErr,\n\t    ofOption,\n\t    getEqualityComparer,\n\t    refine,\n\t}\n\t/* c8 ignore end */\n"]}
{"filename": "src/string.ts", "chunked_list": ["/**\n\t * The string module is a suite of functions that are useful for string manipulation and\n\t * properly, designed for seamless use in function composition pipelines.\n\t *\n\t * @module String\n\t */\n\timport { NonEmptyArray } from \"./NonEmptyArray\"\n\t/**\n\t * A boolean check that also serves as a type guard which narrows the\n\t * type to the string literal `\"\"`.\n", " *\n\t * @group Utils\n\t * @group Type Guards\n\t *\n\t * @returns boolean\n\t */\n\texport const isEmpty = (s: string): s is \"\" => s === \"\"\n\t/**\n\t * Curried version of the built-in trim method.\n\t *\n", " * @group Utils\n\t */\n\texport const trim = (s: string) => s.trim()\n\t/**\n\t * Curried version of the built-in toLowerCase method.\n\t *\n\t * @group Utils\n\t */\n\texport const toLowerCase = (s: string) => s.toLowerCase()\n\t/**\n", " * Curried version of the built-in toUpperCase method.\n\t *\n\t * @group Utils\n\t */\n\texport const toUpperCase = (s: string) => s.toUpperCase()\n\t/**\n\t * Type guard that holds true when `u` is a string.\n\t *\n\t * @group Type Guards\n\t *\n", " * @returns boolean\n\t */\n\texport const isString = (u: unknown): u is string => typeof u === \"string\"\n\t/**\n\t * Get the length of a string.\n\t *\n\t * @group Utils\n\t */\n\texport const length = (s: string) => s.length\n\t/**\n", " * Reverses a string.\n\t *\n\t * @group Utils\n\t */\n\texport const reverse = (s: string) => s.split(\"\").reverse().join(\"\")\n\t/**\n\t * A curried version of the built-in split method that\n\t * is guaranteed to always return at least one entry. If\n\t * the split fails to produce at least one entry, the entire\n\t * input string is returned as a single-element array.\n", " *\n\t * @group Utils\n\t */\n\texport const split =\n\t    (separator: string | RegExp) =>\n\t    (s: string): NonEmptyArray<string> => {\n\t        const result = s.split(separator)\n\t        return result.length > 0 ? (result as unknown as NonEmptyArray<string>) : [s]\n\t    }\n\t/**\n", " * Capitalize the first letter of a string.\n\t *\n\t * @group Utils\n\t */\n\texport const capitalize = (s: string) => {\n\t    if (s.length < 1) {\n\t        return \"\"\n\t    }\n\t    const [head, ...tail] = s.split(\"\")\n\t    return [head.toUpperCase(), ...tail].join(\"\")\n", "}\n\t/**\n\t * Uncapitalize the first letter of a string.\n\t *\n\t * @group Utils\n\t */\n\texport const uncapitalize = (s: string) => {\n\t    if (s.length < 1) {\n\t        return \"\"\n\t    }\n", "    const [head, ...tail] = s.split(\"\")\n\t    return [head.toLowerCase(), ...tail].join(\"\")\n\t}\n\t/* c8 ignore start */\n\t/** @ignore */\n\texport const String = {\n\t    isEmpty,\n\t    trim,\n\t    toLowerCase,\n\t    toUpperCase,\n", "    isString,\n\t    split,\n\t    length,\n\t    reverse,\n\t    capitalize,\n\t    uncapitalize,\n\t}\n\t/* c8 ignore end */\n"]}
{"filename": "src/NonEmptyArray.ts", "chunked_list": ["/**\n\t * A `NonEmptyArray` is an array that is guaranteed by the type system to have\n\t * at least one element. This type is useful for correctly modeling certain\n\t * behaviors where empty arrays are absurd. It also makes it safer to work with\n\t * functionality like destructuring the array or getting the first value.\n\t *\n\t * **Note:** A `NonEmptyArray` is just a _more specific_ type of readonly array,\n\t * so any functions from the `Array` module can also be used with `NonEmptyArray`s.\n\t *\n\t * @module NonEmptyArray\n", " */\n\timport { EqualityComparer } from \"./EqualityComparer\"\n\timport { OrderingComparer } from \"./OrderingComparer\"\n\t/** Represents a readonly array with at least one element. */\n\texport interface NonEmptyArray<A> extends ReadonlyArray<A> {\n\t    0: A\n\t}\n\t/**\n\t * Get the first element of a non-empty array.\n\t *\n", " * @group Utils\n\t * @group Pattern Matching\n\t */\n\texport const head = <A>(as: NonEmptyArray<A>) => as[0]\n\t/**\n\t * Alias of {@link head}.\n\t *\n\t * @group Pattern Matching\n\t * @group Utils\n\t */\n", "export const first = head\n\t/**\n\t * Destructure the non-empty array into an object containing\n\t * the head and the tail.\n\t *\n\t * @group Pattern Matching\n\t *\n\t * @example\n\t * NonEmptyArray.destruct([1, 2, 3]) // => { head: 1, tail: [2, 3] }\n\t */\n", "export const destruct = <A>(\n\t    as: NonEmptyArray<A>\n\t): {\n\t    readonly head: A\n\t    readonly tail: readonly A[]\n\t} => ({\n\t    head: as[0],\n\t    tail: as.slice(1),\n\t})\n\t/**\n", " * Curried version of the built-in map that maintains\n\t * strong NonEmptyArray typing.\n\t *\n\t * @group Mapping\n\t *\n\t * @returns A new non-empty array containing the mapped elements.\n\t */\n\texport const map =\n\t    <A, B>(f: (a: A) => B) =>\n\t    (as: NonEmptyArray<A>): NonEmptyArray<B> =>\n", "        as.map(f) as unknown as NonEmptyArray<B>\n\t/**\n\t * Uses the given function to map each element into a non-empty array,\n\t * then flattens the results. Commonly called flatMap` or `chain`.\n\t *\n\t * @group Mapping\n\t *\n\t * @returns A new non-empty array containing the mapped/flattened elements.\n\t */\n\texport const bind =\n", "    <A, B>(f: (a: A) => NonEmptyArray<B>) =>\n\t    (as: NonEmptyArray<A>): NonEmptyArray<B> =>\n\t        as.flatMap(f) as unknown as NonEmptyArray<B>\n\t/**\n\t * Alias for {@link bind}.\n\t *\n\t * @group Mapping\n\t */\n\texport const flatMap = bind\n\t/**\n", " * Constructs a new non-empty array containing exactly one element.\n\t *\n\t * @group Constructors\n\t */\n\texport const of = <A>(a: A): NonEmptyArray<A> => [a]\n\t/**\n\t * Create a new array by enumerating the integers between\n\t * the given start and end, inclusive of both start and end.\n\t *\n\t * Both start and end are normalized to integers, and end is\n", " * normalized to always be at least equal to start.\n\t *\n\t * @group Constructors\n\t * @group Utils\n\t *\n\t * @example\n\t * NonEmptyArray.range(1, 5)    // => [1, 2, 3, 4, 5]\n\t * NonEmptyArray.range(-10, 1)  // => [-10, -9, -8, ..., 1]\n\t * NonEmptyArray.range(2, -5)   // => [2]\n\t * NonEmptyArray.range(1, 1)    // => [1]\n", " */\n\texport const range = (\n\t    startInclusive: number,\n\t    endInclusive: number\n\t): NonEmptyArray<number> => {\n\t    const start = Math.floor(startInclusive)\n\t    const end = Math.floor(endInclusive)\n\t    if (start >= end) {\n\t        return [start]\n\t    }\n", "    const out: number[] = []\n\t    for (let i = start; i <= end; i++) {\n\t        out.push(i)\n\t    }\n\t    return out as unknown as NonEmptyArray<number>\n\t}\n\t/**\n\t * Construct a new non-empty array with the specified number\n\t * of elements, using a constructor function for each element\n\t * that takes a zero-based index of the element being constructed.\n", " *\n\t * @param length is normalized to a non-negative integer\n\t *\n\t * @group Constructors\n\t * @group Utils\n\t *\n\t * @example\n\t * ```\n\t * NonEmptyArray.make(3, i => `${i}`) // => [\"0\", \"1\", \"2\"]\n\t * ```\n", " */\n\texport const make = <A>(\n\t    length: number,\n\t    createElement: (i: number) => A\n\t): NonEmptyArray<A> => {\n\t    const n = length <= 1 ? 1 : Math.floor(length)\n\t    return [...Array(n).keys()].map(createElement) as unknown as NonEmptyArray<A>\n\t}\n\t/**\n\t * Reverses an array. Preserves correct types.\n", " *\n\t * @group Utils\n\t *\n\t * @returns A new non-empty array with elements in reverse order.\n\t *\n\t * @example\n\t * pipe(\n\t *  NonEmptyArray.range(1, 5),\n\t *  NonEmptyArray.reverse\n\t * ) // => [5, 4, 3, 2, 1]\n", " */\n\texport const reverse = <A>(as: NonEmptyArray<A>): NonEmptyArray<A> =>\n\t    as.slice(0).reverse() as unknown as NonEmptyArray<A>\n\t/**\n\t * Sort the array using the given `OrderingComaparer`, or the default\n\t * ASCII-based comparer if not given.\n\t *\n\t * @group Utils\n\t *\n\t * @returns A new non-emty array with elements sorted.\n", " */\n\texport const sort =\n\t    <A>(orderingComparer: OrderingComparer<A> = OrderingComparer.Default) =>\n\t    (as: NonEmptyArray<A>): NonEmptyArray<A> =>\n\t        as.slice(0).sort(orderingComparer.compare) as unknown as NonEmptyArray<A>\n\t/**\n\t * Get an `EqualityComparer` that represents structural equality for a non-empty array\n\t * of type `A` by giving this function an `EqualityComparer` for each `A` element.\n\t *\n\t * @group Equality\n", " * @group Utils\n\t *\n\t * @param equalityComparer The `EqualityComparer` to use for element-by-element comparison.\n\t *\n\t * @returns A new `EqualityComparer` instance\n\t */\n\texport const getEqualityComparer = <A>({\n\t    equals,\n\t}: EqualityComparer<A>): EqualityComparer<NonEmptyArray<A>> =>\n\t    EqualityComparer.ofEquals((arr1, arr2) => {\n", "        if (arr1.length !== arr2.length) {\n\t            return false\n\t        }\n\t        for (let i = 0; i < arr1.length; i++) {\n\t            if (!equals(arr1[i], arr2[i])) {\n\t                return false\n\t            }\n\t        }\n\t        return true\n\t    })\n", "/* c8 ignore start */\n\t/** @ignore */\n\texport const NonEmptyArray = {\n\t    head,\n\t    first,\n\t    destruct,\n\t    map,\n\t    bind,\n\t    flatMap,\n\t    of,\n", "    range,\n\t    make,\n\t    reverse,\n\t    sort,\n\t    getEqualityComparer,\n\t}\n\t/* c8 ignore end */\n"]}
{"filename": "src/function.ts", "chunked_list": ["/**\n\t * Execute some arbitrary side-effect function on the given value\n\t * and return the value unchanged. Sometimes this function is\n\t * referred to as `tap` or `do`.\n\t *\n\t * Used mostly for logging or tracing in function pipelines.\n\t *\n\t * @group Utils\n\t *\n\t * @example\n", " * ```\n\t * pipe(\n\t *     42,\n\t *     tee(console.log), // logs 42\n\t *     double,\n\t *     tee(console.log), // logs 84\n\t *     String,\n\t *     tee(console.log)  // logs \"84\"\n\t * ) // => \"84\"\n\t * ```\n", " */\n\texport const tee =\n\t    <A>(f: (a: A) => void) =>\n\t    (a: A) => {\n\t        f(a)\n\t        return a\n\t    }\n\t/**\n\t * Execute some arbitrary side-effect function on the value\n\t * resolved from the `Promise` and return the value unchanged.\n", " * Sometimes this function is referred to as `tap` or `do`.\n\t *\n\t * Used primarily for logging or tracing in function pipelines.\n\t *\n\t * @remarks\n\t * If you are working with `Async` computations, use {@link Async.tee} instead.\n\t *\n\t * @group Utils\n\t *\n\t * @example\n", " * ```\n\t * await pipe(\n\t *     Promise.resolve(10),\n\t *     teeAsync(console.log), // logs `10`. Using `tee` would log the Promise object\n\t *     p => p.then(n => n * 2)\n\t * ) // => 20\n\t * ```\n\t */\n\texport const teeAsync =\n\t    <A>(f: (a: A) => void) =>\n", "    (p: Promise<A>) =>\n\t        p.then(a => {\n\t            f(a)\n\t            return a\n\t        })\n"]}
{"filename": "src/Variants.ts", "chunked_list": ["/**\n\tVariants allow you to more easily create and work with discriminated unions than you can\n\tout-of-the-box with TypeScript.\n\t**This bears repeating:** the type that is exported by `VariantOf` is _just_ a plain\n\tdiscriminated union. It's like a discriminated union PLUS.\n\tIf you find yourself working with many kinds of discriminated union types in TypeScript,\n\tyou will likely be writing a ton of boilerplate code over and over for each one: record\n\ttype definitions, manually exporting a union type, then writing a constructor function\n\tfor each case, followed by writing each `match` and `matchOrElse` function by hand while\n\tmaking sure to enforce exhaustive checks manually. This also has the unfortunate side effect\n", "of increasing your unit test API surface area, since each `match` function now needs to be\n\tunit tested individually. Using variants allows us to skip both the boilerplate code and\n\tthe boilerplate test code.\n\tMoreover, using variant-flavored discriminated unions means we can sprinkle in other helpful\n\tfeatures like scoping, where you can reuse the same variant structure but scope the discriminants\n\twithout making the rest of the code more verbose. This is particularly useful for things like\n\tredux actions which conventionally are scoped like `domainArea/actionName`, but when dealing\n\twith each case, you don't want to have to manually write out things like `domainArea/` over and over.\n\t## Basic usage\n\tIn this example below, we have a `Pet` object and `Pet` type that we're exporting. It may seem\n", "surprising for the object and the type to have the exact same name, but TypeScript is able to\n\tinfer from context which you're trying to reference. (That is because one name lives in the world\n\tof _types_ and the other name lives in the world of _values_.)\n\t```ts\n\texport const Pet = variant({\n\t    dog: (name: string) => ({ name }),\n\t    cat: (livesLeft: number) => ({ livesLeft }),\n\t    fish: {},\n\t})\n\texport type Pet = VariantOf<typeof Pet>\n", "```\n\t**Aside:** if you squint hard enough, you should see that this API is designed to read concisely,\n\tlike [ML-family](<https://en.wikipedia.org/wiki/ML_(programming_language)>) languages that have more\n\tfirst-class support for discriminated unions. For example, in F#, a similar type definition might look like:\n\t```fsharp\n\ttype Pet =\n\t    | Dog of name: string\n\t    | Cat of livesLeft: int\n\t    | Fish\n\t```\n", "The `Pet` object will give you access to the [helper methods](#helper-methods) mentioned below while\n\tthe `Pet` type gives you a type in the shape of your discriminated union.\n\t```ts\n\timport { Pet } from \"@/types\"\n\t// Simple constructor\n\tconst myPet = Pet.dog(\"Rex\")\n\t// Simple matching\n\tconst sayHelloToPet = Pet.match({\n\t    dog: \"Hello dog!\",\n\t    cat: \"Hello cat!\",\n", "    fish: \"Blub blub fish!\",\n\t})\n\t// Equivalent to:\n\tconst sayHelloToPetWithSwitch = (pet: Pet) => {\n\t    switch (pet._tag) {\n\t        case \"Dog\":\n\t            return \"Hello dog!\";\n\t        case \"Cat\":\n\t            return \"Hello cat!\";\n\t        case \"Fish\":\n", "            return \"Blub blub fish!\";\n\t        default:\n\t            return \"This should not happen!\"; // Have to handle this case somehow\n\t    }\n\t}\n\t// The generated `Pet` type is:\n\ttype PetByHand =\n\t  | {\n\t      _tag: \"Dog\";\n\t      name: string;\n", "    }\n\t  | {\n\t      _tag: \"Cat\";\n\t      livesLeft: number;\n\t    }\n\t  | {\n\t      _tag: \"Fish\";\n\t    };\n\t// ^^ Note that this type is JUST a standard TS discriminated union! \n\t```\n", "## Concepts\n\t### Discriminant\n\tThe discriminant will be the property that is used to distinguish between the various types.\n\tBy default, this property is `_tag` but using {@link variantC}, you can call this property\n\tsomething else. For example, for Redux actions, you will want to use `type` as the discriminant\n\tproperty (as is virtually always used with Redux actions).\n\tAs an example, consider the `Pet` variant type.\n\t```ts\n\tconst Pet = variant({\n\t    dog: (name: string) => ({ name }),\n", "    cat: (livesLeft: number) => ({ livesLeft }),\n\t    fish: {},\n\t})\n\ttype Pet = VariantOf<typeof Pet>\n\t```\n\tOur `Pet` type will look like:\n\t```ts\n\t{\n\t    _tag: \"Dog\",\n\t    name: string;\n", "} |\n\t{\n\t    _tag: \"Cat\",\n\t    livesLeft: number\n\t} |\n\t{\n\t    _tag: \"Fish\"\n\t}\n\t```\n\tAs you can see, the property names we pass into `variant` get translated into the different possible\n", "values of the discriminant property (`_tag`).\n\t### Scope\n\tScopes can be used when you have the possibility of different variant types with the same name, such\n\tthat one can't be passed in for another. This is common with our [Redux actions](#redux-actions) where\n\tmultiple action variants might share the same name (e.g., `rowAdded`).\n\tPractically speaking, this means that instead of the `AvailabilityHours.rowAdded` and `AvailabilityDates.rowAdded`\n\tboth having a discriminant property of `rowAdded`, they have `AvailabilityHours/rowAdded` and\n\t`AvailabilityDates/rowAdded`, respectively. See the example below for an illustration of this. (Note\n\tRedux actions use `type`, instead of `_tag` as we did above.)\n\tAvailability Hours:\n", "```ts\n\t{\n\t  type: \"AvailabilityHours/RowAdded\";\n\t}\n\t```\n\tAvailability Dates:\n\t```ts\n\t{\n\t  type: \"AvailabilityDates/RowAdded\";\n\t}\n", "```\n\tAs you can see, it is now impossible to pass in the `rowAdded` action from AvailabilityHours\n\tinto a function that expects an AvailabilityDates action variant, and vice versa. The compiler\n\tsimply won't let you do it!\n\t## Helper Methods\n\tAll examples below use the following `Pet` variant type to illustrate their usages.\n\t```ts\n\tconst Pet = variant({\n\t    dog: (name: string) => ({ name }),\n\t    cat: (livesLeft: number) => ({ livesLeft }),\n", "    fish: {},\n\t})\n\ttype Pet = VariantOf<typeof Pet>\n\t```\n\t### Constructors\n\tUsed to create an instance of a particular variant type. If a function is used for the variant\n\ttype (like `dog` and `cat` above) then that function becomes the constructor function. Otherwise\n\tif there is no function and just an empty object (like `fish` above), then there is no traditional\n\tconstructor function, but just a static instance you can reference.\n\t**Note:** Because TypeScript is a structurally typed language, discriminated union constructors\n", "behave somewhat differently than in other languages where discriminated unions are more prevalent.\n\tFor instance, the `Pet.dog` constructor below doesn't return the type `Pet`, but actually returns\n\tthe literal object type `{ _tag: 'dog', name: string }`, which is _assignable to_ `Pet`. In some cases,\n\tthis is very desirable because you know the exact shape of the object without pattern matching.\n\tIn other cases, it can lead the TypeScript compiler to make more restrictive (or \"narrow\") type\n\tinferences than you may expect. This is a compiler-level behavior, so just something to watch out for!\n\t```ts\n\tconst rexTheDog = Pet.dog(\"Rex\")\n\tconst nineLivesTheCat = Pet.cat(9)\n\tconst myGoldFish = Pet.fish\n", "```\n\t### match\n\t`match` can be used similarly to a `switch` but is much more concise and\n\tforces exhaustive checking at compile time.\n\t```ts\n\tconst isFish = Pet.match({\n\t    dog: false,\n\t    cat: false,\n\t    fish: true\n\t})\n", "const pet = ???; // Assume we won't know what kind of pet until runtime.\n\tif (isFish(pet)) {\n\t    console.log(\"You got yourself a fish there!\")\n\t}\n\t```\n\tAs you can see above, hard coded literals can be given to the matcher, but lambda functions also work!\n\tIf given a lambda, you'll automatically have type-safe access to the unique properties of that variant\n\ttype. (This is essentially equivalent to the semantics of pattern matching.)\n\tLambdas are especially useful if (a) you need to access the destructured case data (e.g., the dog's\n\tname like below) to produce the result, or (b) you want to avoid doing an expensive or long-running\n", "computation unless it is actually needed.\n\t```ts\n\tconst describePet = Pet.match({\n\t    dog: ({ name }) => `This dog's name is ${name}.`,\n\t    cat: ({ livesLeft }) => `This cat has ${livesLeft} lives left!`,\n\t    fish: () => \"This is just a fish, nothing special about it.\"\n\t    // Note: the \"fish\" case wouldn't need to be a function since the fish variant\n\t    // type does not have any data on it.\n\t})\n\tconst pet = ??? // Assume we won't know what kind of pet until runtime.\n", "console.log(\"Say hello to my pet!\")\n\tconsole.log(describePet(pet))\n\t```\n\tNote you can also mix and match between hard-coded literals and functions. Since `fish` has no additional data,\n\tI would probably write the above like this.\n\t```ts\n\tconst describePet = Pet.match({\n\t  dog: ({ name }) => `This dog's name is ${name}.`,\n\t  cat: ({ livesLeft }) => `This cat has ${livesLeft} lives left!`,\n\t  fish: \"This is just a fish, nothing special about it.\",\n", "})\n\t```\n\t### matchOrElse\n\tThere are plenty of instances where you don't want your matching to be exhaustive but instead have a\n\t\"default\" (`orElse`) case. Like in the `isFish` example above, it feels a bit redundant to mark\n\teverything not a `fish` with `false`, right? With `matchOrElse`, you could simplify\n\tit to the following:\n\t```ts\n\tconst isFish = Pet.matchOrElse({\n\t    fish: true\n", "    orElse: false\n\t})\n\t```\n\t`matchOrElse` can take any number of variant types (except all of them, use `match` in that case ) so you\n\taren't restricted to just \"fish or else!\".\n\t```ts\n\tconst isInterestingPet = Pet.matchOrElse({\n\t    dog: true,\n\t    cat: true,\n\t    orElse: false,\n", "})\n\t```\n\t(This assumes we're confident that `dog` and `cat` are the only interesting pets that we will ever have,\n\twhich may not be a safe assumption )\n\tJust like `match`, `matchOrElse` can also take functions that will give you the data attached to the\n\tparticular variant instance:\n\t```ts\n\tconst describePet = Pet.match({\n\t    dog: ({ name }) => `This dog's name is ${name}.`,\n\t    cat: ({ livesLeft }) => `This cat has ${livesLeft} lives left!`,\n", "    orElse: \"Sorry, nothing interesting about this pet.\",\n\t})\n\t```\n\t### types\n\tSimply gives you an object that gives you all the variant types with their corresponding discriminant\n\tproperty value. We've found this to be mostly useful for tests (especially tests where we need to verify\n\tthat certain redux actions have been dispatched in a particular order).\n\t```ts\n\tconst dogTag = Pet.types.dog // Evaluates to \"Dog\"\n\t```\n", "If a scope is included in the variants, this will also be included here.\n\t```ts\n\tconst rowAdded = AvailabilityHours.types.rowAdded // Evaluates to \"AvailabilityHours/RowAdded\"\n\t```\n\t## VariantC\n\tIn the majority of cases, usage of `variantC` should not be necessary. The `C` stands for \"customize\",\n\tso this version of `variant` allows you to customize your variant slightly. Currently the two things\n\tthat can be customized are the [discriminant property](#discriminant) and the [scope](#scope).\n\tWe use `variantC` (but abstracted away) with our [Redux Actions](#redux-actions) to use scope names\n\t(because that is more important with redux actions where collisions are more likely) and rename our\n", "discriminant property to `type` (per redux action convention).\n\tAnother (very contrived) example of using `variantC` might be:\n\t```ts\n\tconst discriminantProperty = \"petKind\"\n\tconst scope = \"CoolPets/\"\n\tconst CustomPet = variantC(\n\t    {\n\t        dog: (name: string) => ({ name }),\n\t        cat: (livesLeft: number) => ({ livesLeft }),\n\t        fish: {},\n", "    },\n\t    discriminantProperty,\n\t    scope\n\t)\n\ttype CustomPet = VariantOf<typeof CustomPet>\n\t```\n\t@module Variants\n\t*/\n\t/* eslint-disable @typescript-eslint/no-explicit-any */\n\t/* eslint-disable @typescript-eslint/no-unsafe-return */\n", "/* eslint-disable @typescript-eslint/no-unsafe-call */\n\t/* eslint-disable @typescript-eslint/no-unsafe-argument */\n\timport { Identity } from \"./prelude\"\n\timport { String } from \"./string\"\n\t/**************\n\t * Helper Types\n\t ***************/\n\ttype DefaultDiscriminant = \"_tag\"\n\ttype DefaultScope = \"\"\n\ttype Func = (...args: any[]) => any\n", "type EmptyObjGuard<T> = T extends ObjectGuard<infer O>\n\t    ? object extends O\n\t        ? O\n\t        : never\n\t    : never\n\ttype Scoped<T extends string, Scope extends string = \"\"> = Scope extends \"\"\n\t    ? T\n\t    : `${Scope}${T}`\n\ttype ObjectGuard<T extends object> = Exclude<T, any[] | Func>\n\ttype NonEmptyStringKeys<T> = Exclude<Extract<keyof T, string>, \"\">\n", "/********************\n\t * Foundational Types\n\t *********************/\n\ttype VariantInputObject = Record<string, Func | object>\n\ttype Variant<\n\t    Case extends string,\n\t    Data extends object = object,\n\t    Discriminant extends string = DefaultDiscriminant,\n\t    Scope extends string = DefaultScope\n\t> = Identity<\n", "    {\n\t        readonly [key in Discriminant]: Scoped<Case, Scope>\n\t    } & Readonly<Data>\n\t>\n\ttype CaseReturnType<T> = T extends (...args: any[]) => infer R\n\t    ? R extends object\n\t        ? R\n\t        : never\n\t    : EmptyObjGuard<T>\n\ttype VariantConstructor<\n", "    Args extends any[],\n\t    Case extends string,\n\t    Data extends object = object,\n\t    Discriminant extends string = DefaultDiscriminant,\n\t    Scope extends string = DefaultScope\n\t> = (...args: Args) => Variant<Case, Data, Discriminant, Scope>\n\ttype VariantConstructorOrValue<\n\t    T,\n\t    Case extends string,\n\t    Discriminant extends string = DefaultDiscriminant,\n", "    Scope extends string = DefaultScope\n\t> = ObjectGuard<CaseReturnType<T>> extends never\n\t    ? [never, \"Only objects are allowed as variant data. Wrap variant data in an object.\"]\n\t    : T extends Func\n\t    ? VariantConstructor<Parameters<T>, Case, CaseReturnType<T>, Discriminant, Scope>\n\t    : Variant<Case, CaseReturnType<T>, Discriminant, Scope>\n\ttype VariantConstructors<\n\t    Input extends VariantInputObject = Record<string, never>,\n\t    Discriminant extends string = DefaultDiscriminant,\n\t    Scope extends string = DefaultScope\n", "> = {\n\t    readonly [Case in NonEmptyStringKeys<Input>]: VariantConstructorOrValue<\n\t        Input[Case],\n\t        Capitalize<Case>,\n\t        Discriminant,\n\t        Scope\n\t    >\n\t}\n\ttype _VariantOf<\n\t    Input extends VariantInputObject,\n", "    Discriminant extends string = DefaultDiscriminant,\n\t    Scope extends string = DefaultScope\n\t> = {\n\t    [Case in NonEmptyStringKeys<Input>]: Identity<\n\t        Variant<Capitalize<Case>, CaseReturnType<Input[Case]>, Discriminant, Scope>\n\t    >\n\t}[NonEmptyStringKeys<Input>]\n\t/*****************\n\t * Composite Types\n\t ******************/\n", "type VariantMatcher<A, Input extends VariantInputObject = Record<string, never>> = {\n\t    readonly [Case in keyof Input]: ((data: CaseReturnType<Input[Case]>) => A) | A\n\t}\n\ttype VariantMatch<\n\t    Input extends VariantInputObject = Record<string, never>,\n\t    Discriminant extends string = DefaultDiscriminant,\n\t    Scope extends string = DefaultScope\n\t> = <A>(\n\t    matcher: VariantMatcher<A, Input>\n\t) => (instance: _VariantOf<Input, Discriminant, Scope>) => A\n", "type PartialVariantMatcher<\n\t    A,\n\t    Input extends VariantInputObject = Record<string, never>\n\t> = Partial<VariantMatcher<A, Input>> & {\n\t    readonly orElse: (() => A) | A\n\t}\n\ttype VariantMatchOrElse<\n\t    Input extends VariantInputObject = Record<string, never>,\n\t    Discriminant extends string = DefaultDiscriminant,\n\t    Scope extends string = DefaultScope\n", "> = <A>(\n\t    partialMatcher: PartialVariantMatcher<A, Input>\n\t) => (instance: _VariantOf<Input, Discriminant, Scope>) => A\n\ttype VariantTypes<\n\t    Input extends VariantInputObject = Record<string, never>,\n\t    Scope extends string = DefaultScope\n\t> = {\n\t    readonly [Case in NonEmptyStringKeys<Input>]: Scoped<Capitalize<Case>, Scope>\n\t}\n\ttype VariantModule<\n", "    Input extends VariantInputObject = Record<string, never>,\n\t    Discriminant extends string = DefaultDiscriminant,\n\t    Scope extends string = DefaultScope\n\t> = {\n\t    readonly match: VariantMatch<Input, Discriminant, Scope>\n\t    readonly matchOrElse: VariantMatchOrElse<Input, Discriminant, Scope>\n\t    readonly types: Identity<VariantTypes<Input, Scope>>\n\t} & VariantConstructors<Input, Discriminant, Scope>\n\t/**\n\t * Extracts a \"plain old\" discriminated union type from a `VariantModule` constructed\n", " * with {@link variant} or {@link  variantC}.\n\t */\n\texport type VariantOf<V> = V extends VariantModule<\n\t    infer Input,\n\t    infer Discriminant,\n\t    infer Scope\n\t>\n\t    ? Identity<_VariantOf<Input, Discriminant, Scope>>\n\t    : [never, \"Error: V must be a variant module\"]\n\t/**********************\n", " * Generative Functions\n\t ***********************/\n\tconst isFunc = (f: Func | object): f is Func => typeof f === \"function\"\n\tconst getVariantCtors = <\n\t    T extends VariantInputObject,\n\t    Discriminant extends string = DefaultDiscriminant,\n\t    Scope extends string = DefaultScope\n\t>(\n\t    inp: T,\n\t    discriminant: Discriminant,\n", "    scope: Scope\n\t): VariantConstructors<T, Discriminant, Scope> =>\n\t    Object.entries(inp).reduce((acc, entry) => {\n\t        const [_case, ctor] = entry\n\t        const capitalizedCase = String.capitalize(_case)\n\t        const scopedCapitalizedCase =\n\t            scope.length > 0 ? `${scope}${capitalizedCase}` : `${capitalizedCase}`\n\t        return Object.assign(acc, {\n\t            [_case]: isFunc(ctor)\n\t                ? (...args: any[]) => ({\n", "                      [discriminant]: scopedCapitalizedCase,\n\t                      ...ctor(...args),\n\t                  })\n\t                : { [discriminant]: scopedCapitalizedCase },\n\t        })\n\t    }, {}) as VariantConstructors<T, Discriminant, Scope>\n\tconst getVariantTypes = <T extends VariantInputObject, Scope extends string = \"\">(\n\t    inp: T,\n\t    scope: Scope\n\t): Identity<VariantTypes<T, Scope>> =>\n", "    Object.entries(inp).reduce((acc, entry) => {\n\t        const [_case] = entry\n\t        const capitalizedCase = String.capitalize(_case)\n\t        const scopedCapitalizedCase =\n\t            scope.length > 0 ? `${scope}${capitalizedCase}` : `${capitalizedCase}`\n\t        return Object.assign(acc, { [_case]: scopedCapitalizedCase })\n\t    }, {}) as Identity<VariantTypes<T, Scope>>\n\tconst unscope = <Scope extends string>(type: string, scope: Scope) =>\n\t    scope.length > 0 ? type.replace(new RegExp(`${scope}`), \"\") : type\n\tconst getMatchFn =\n", "    <\n\t        T extends VariantInputObject,\n\t        Discriminant extends string = DefaultDiscriminant,\n\t        Scope extends string = DefaultScope\n\t    >(\n\t        discriminant: Discriminant,\n\t        scope: Scope\n\t    ): VariantMatch<T, Discriminant> =>\n\t    matcher =>\n\t    instance => {\n", "        const unscopedUncapitalizedType = String.uncapitalize(\n\t            unscope(instance[discriminant], scope)\n\t        )\n\t        if (!Object.hasOwn(matcher, unscopedUncapitalizedType)) {\n\t            throw new TypeError(\n\t                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n\t                `Expected to be given a variant with scope ${scope}. Actual type was ${instance[discriminant]}`\n\t            )\n\t        }\n\t        const branch = matcher[unscopedUncapitalizedType]\n", "        const data = { ...instance }\n\t        delete data[discriminant]\n\t        return typeof branch === \"function\" ? (branch as any)(data) : branch\n\t    }\n\tconst getMatchOrElseFn =\n\t    <\n\t        T extends VariantInputObject,\n\t        Discriminant extends string = DefaultDiscriminant,\n\t        Scope extends string = DefaultScope\n\t    >(\n", "        discriminant: Discriminant,\n\t        scope: Scope\n\t    ): VariantMatchOrElse<T, Discriminant> =>\n\t    matcher =>\n\t    instance => {\n\t        const unscopedUncapitalizedType = String.uncapitalize(\n\t            unscope(instance[discriminant], scope)\n\t        )\n\t        if (Object.hasOwn(matcher, unscopedUncapitalizedType)) {\n\t            const branch = matcher[unscopedUncapitalizedType]\n", "            const data = { ...instance }\n\t            delete data[discriminant]\n\t            return typeof branch === \"function\" ? branch(data) : branch\n\t        }\n\t        return typeof matcher.orElse === \"function\"\n\t            ? (matcher.orElse as any)()\n\t            : matcher.orElse\n\t    }\n\t/** _C_ stands for customize! Returns a module object containing case\n\t * constructors a mapping of cases to (possibly) scoped `types` (i.e., tags),\n", " * and `match`/`matchOrElse` functions. **This function allows you to pass\n\t * your own discriminant (e.g., `\"type\"`) and scope (e.g., `\"Namespace/\"`).**\n\t *\n\t * Changing the scope allows you to re-use the exact same variant structure\n\t * without risking conflicting types or matcher functions. **Use a scope\n\t * for redux actions to namespace them.**\n\t *\n\t * This does not handle generic variants, like `Option<T>`.\n\t *\n\t * @example\n", " * ```\n\t * export const Action = variantC({\n\t *     loadStuffStarted: {},\n\t *     loadStuffFinished: (response: string) => ({ response }),\n\t * }, \"type\", \"Namespace/\")\n\t * export type Action = VariantOf<typeof Action>\n\t *\n\t * // Access type names\n\t * const types = Action.types // => { loadStuffStarted: \"Namespace/LoadStuffStarted\", loadStuffFinished: \"Namespace/LoadStuffFinished\" }\n\t *\n", " * // Construct a new instance\n\t * const myAction = Action.loadStuffFinished(\"200 OK\") // => { type: \"Namespace/LoadStuffFinished\", response: \"200 OK\" }\n\t *\n\t * // Perform a match\n\t * const matchResult = pipe(\n\t *     myAction,\n\t *     Action.match({\n\t *       loadStuffStarted: \"stuff started!\",\n\t *       loadStuffFinished: ({ response }) => `Finished, response=${response}`,\n\t *     })\n", " * ) // => \"Finished, response=200 OK\"\n\t * ```\n\t */\n\texport const variantC = <\n\t    T extends VariantInputObject,\n\t    Discriminant extends string,\n\t    Scope extends string\n\t>(\n\t    inp: T,\n\t    discriminant: Discriminant,\n", "    scope: Scope\n\t): VariantModule<T, Discriminant, Scope> => ({\n\t    ...getVariantCtors(inp, discriminant, scope),\n\t    match: getMatchFn(discriminant, scope),\n\t    matchOrElse: getMatchOrElseFn(discriminant, scope),\n\t    types: getVariantTypes(inp, scope),\n\t})\n\t/**\n\t * Returns a module object containing case constructors, a mapping of cases to\n\t * (possibly) scoped `types` (i.e., tags), and `match`/`matchOrElse` functions.\n", " * **This function uses the default discriminant of `\"_tag\"` and no scope.**\n\t *\n\t * This **does not** handle generic variants, like `Option<T>`.\n\t *\n\t * @example\n\t * ```\n\t * export const Pet = variant({\n\t *   dog: (name: string) => ({ name }),\n\t *   cat: (livesLeft: number) => ({ livesLeft }),\n\t *   fish: {},\n", " * })\n\t * export type Pet = VariantOf<typeof Pet>\n\t *\n\t * // Access type names (useful in Redux scenarios)\n\t * const types = Pet.types // => { dog: \"Dog\", cat: \"Cat\", fish: \"Fish\" }\n\t *\n\t * // Construct a new instance\n\t * const myDog = Pet.dog(\"Fido\") // => { _tag: \"Dog\", name: \"Fido\" }\n\t *\n\t * // Perform a match\n", " * const matchResult = pipe(\n\t *     myDog,\n\t *     Pet.matchOrElse({\n\t *         dog: ({ name }) => `Woof! I am ${name}`,\n\t *         orElse: \"not a dog\",\n\t *     })\n\t * ) // => \"Woof! I am Fido\"\n\t * ```\n\t */\n\texport const variant = <T extends VariantInputObject>(\n", "    inp: T\n\t): VariantModule<T, DefaultDiscriminant, DefaultScope> => ({\n\t    ...getVariantCtors(inp, \"_tag\", \"\"),\n\t    match: getMatchFn(\"_tag\", \"\"),\n\t    matchOrElse: getMatchOrElseFn(\"_tag\", \"\"),\n\t    types: getVariantTypes(inp, \"\"),\n\t})\n"]}
{"filename": "src/index.ts", "chunked_list": ["export { pipe, flow } from \"./Composition\"\n\texport { tee, teeAsync } from \"./function\"\n\texport { String } from \"./string\"\n\texport { EqualityComparer } from \"./EqualityComparer\"\n\texport { OrderingComparer } from \"./OrderingComparer\"\n\texport { Nullable } from \"./Nullable\"\n\texport { Option } from \"./Option\"\n\texport { Result } from \"./Result\"\n\texport { Async } from \"./Async\"\n\texport { AsyncResult } from \"./AsyncResult\"\n", "export { Array } from \"./Array\"\n\texport { NonEmptyArray } from \"./NonEmptyArray\"\n\texport { Map } from \"./Map\"\n\texport { Deferred } from \"./Deferred\"\n\texport type { EnumOf } from \"./Enums\"\n\texport { enumOf } from \"./Enums\"\n\texport type { VariantOf } from \"./Variants\"\n\texport { variant, variantC } from \"./Variants\"\n\texport { DeferredResult } from \"./DeferredResult\"\n"]}
{"filename": "src/Enums.ts", "chunked_list": ["/**\n\tSee [Enums considered harmful](https://www.youtube.com/watch?v=jjMbPt_H3RQ) for the motivation\n\tbehind this custom type. (Also worth noting is that in TypeScript 5.0 [all Enums are considered\n\tunions](https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#all-enums-are-union-enums).)\n\tSimilar to [variants](variants.md) for disciminated unions, `enumOf` allows you to more easily\n\tand safely create and work with enums in TypeScript.\n\t## Basic Example\n\t```ts\n\texport const MyEnum = enumOf(\n\t    {\n", "        Dog = \"Dog\",\n\t        Cat = \"Cat\",\n\t        ZEBRA = 1234,\n\t    } as const, // the `as const` won't be required in TypeScript 5.0\n\t    \"MyEnum\" // friendly name is optional; used to generate helpful parser errors\n\t) \n\texport type MyEnum = EnumOf<typeof MyEnum> // => \"Dog\" | \"Cat\" | 1234\n\t```\n\t## Methods\n\t### Standard enum-style accessors\n", "```ts\n\tconst dog = MyEnum.Dog // => \"Dog\"\n\tconst zebra = MyEnum.ZEBRA // => 1234\n\t```\n\t### Values\n\tAccess array of all valid values, correctly typed (but without any ordering guarantees).\n\t```ts\n\tconst myEnumValues = MyEnum.values // => [\"Dog\", \"Cat\", 1234]\n\t```\n\t### Parser\n", "Get a safe parser function for this enum automagically!\n\t```ts\n\tconst parsed = MyEnum.parse(\"cat\") // => a `Result<MyEnum, string>`, in this case `Result.ok(\"Cat\")`\n\t```\n\t### Match\n\tSee `match` in the {@link Variants} module docs for more details on matchers.\n\t```ts\n\tconst speak: (e: MyEnum) => string = MyEnum.match({\n\t    Dog: \"woof woof\",\n\t    Cat: () => \"meow\",\n", "    ZEBRA: \"is my skin white with black stripes or black with white stripes??\",\n\t})\n\tspeak(myEnum)\n\t```\n\t### MatchOrElse\n\tSee `matchOrElse` in the {@link Variants} module docs for more details on partial matchers.\n\t```ts\n\tconst speak: (e: MyEnum) => string = MyEnum.matchOrElse({\n\t    Dog: \"woof woof\",\n\t    Cat: () => \"meow\",\n", "    orELse: \"I cannot speak.\",\n\t})\n\tspeak(myEnum)\n\t```\n\t@module Enums\n\t*/\n\t/* eslint-disable @typescript-eslint/no-explicit-any */\n\timport { Result } from \"./Result\"\n\timport { String } from \"./string\"\n\timport { Option } from \"./Option\"\n", "import { pipe, flow } from \"./Composition\"\n\timport { Array } from \"./Array\"\n\timport { Identity, NonNullish } from \"./prelude\"\n\t/** @ignore */\n\ttype StringKeys<T extends object> = Extract<keyof T, string>\n\t/**\n\t * A plain object that serves as the definition of the enum type.\n\t * Until TypeScript 5.0 is released, you need to specify `as const`\n\t * on this object definition.\n\t */\n", "type RawEnum = Record<string, string | number>\n\t/** @ignore */\n\ttype StringKeyValues<T extends RawEnum> = Identity<T[StringKeys<T>]>\n\t/** @ignore */\n\ttype EnumMatcher<A, R extends RawEnum> = {\n\t    readonly [Label in StringKeys<R>]: (() => A) | A\n\t}\n\t/** @ignore */\n\ttype PartialEnumMatcher<A, R extends RawEnum> = Partial<EnumMatcher<A, R>> & {\n\t    readonly orElse: (() => A) | A\n", "}\n\ttype EnumMatch<R extends RawEnum> = <A>(\n\t    matcher: EnumMatcher<A, R>\n\t) => (value: StringKeyValues<R>) => A\n\ttype EnumMatchOrElse<R extends RawEnum> = <A>(\n\t    matcher: PartialEnumMatcher<A, R>\n\t) => (value: StringKeyValues<R>) => A\n\t/**\n\t * The output of the {@link enumOf} function. Produces an object that serves both as\n\t * the enum as well as a namespace for helper functions related to that enum.\n", " */\n\ttype EnumModule<R extends RawEnum> = Identity<\n\t    {\n\t        readonly [Label in StringKeys<R>]: R[Label]\n\t    } & {\n\t        /**\n\t         * Returns a readonly array containing the set of all possible enum values. No\n\t         * guarantees are made regarding the order of items in the resultant array.\n\t         */\n\t        readonly values: ReadonlyArray<StringKeyValues<R>>\n", "        /**\n\t         * For string enum values, the parse function will trim and coerce values to lowercase\n\t         * before comparison. (This has no effect on numeric enum values.) Thus, if an\n\t         * enum is defined as `'Yes' | 'No'`, this decoder will parse `'yes'`, `' yES'`,\n\t         * and `' YES '` correctly into the canonical `'Yes'` enum value.\n\t         */\n\t        readonly parse: (u: unknown) => Result<StringKeyValues<R>, string>\n\t        /**\n\t         * Use this function for an exhaustive case check that doesn't require using\n\t         * a switch/case block or any kind of assertExhaustive check.\n", "         */\n\t        readonly match: EnumMatch<R>\n\t        /**\n\t         * Use this function for a partial case check that doesn't require using\n\t         * a switch/case block.\n\t         */\n\t        readonly matchOrElse: EnumMatchOrElse<R>\n\t    }\n\t>\n\t/**\n", " * Gets the union type representing all possible enum values.\n\t */\n\texport type EnumOf<T> = T extends EnumModule<infer R>\n\t    ? StringKeyValues<R>\n\t    : [never, \"Error: T must be an EnumModule\"]\n\tconst getParserErrorMessage = <T extends RawEnum>(\n\t    enumValues: EnumModule<T>[\"values\"],\n\t    enumFriendlyName: string\n\t) => `Must be an enum value in the set ${enumFriendlyName}{ ${enumValues.join(\", \")} }`\n\tconst toTrimmedLowerCase = (a: string | number) =>\n", "    pipe(\n\t        Option.some(a),\n\t        Option.refine(String.isString),\n\t        Option.map(flow(String.trim, String.toLowerCase)),\n\t        Option.defaultValue(a)\n\t    )\n\tconst isStringOrNumber = (u: NonNullish): u is string | number =>\n\t    typeof u === \"string\" || typeof u === \"number\"\n\tconst getParseFn =\n\t    <R extends RawEnum>(enumValues: EnumModule<R>[\"values\"], enumFriendlyName: string) =>\n", "    (u: unknown): Result<StringKeyValues<R>, string> =>\n\t        pipe(\n\t            Option.ofNullish(u),\n\t            Result.ofOption(\n\t                () =>\n\t                    `Enum${\n\t                        enumFriendlyName ? ` ${enumFriendlyName}` : \"\"\n\t                    } cannot be null/undefined`\n\t            ),\n\t            Result.refine(\n", "                isStringOrNumber,\n\t                () =>\n\t                    `Enum${\n\t                        enumFriendlyName ? ` ${enumFriendlyName}` : \"\"\n\t                    } must be a string or number`\n\t            ),\n\t            Result.map(toTrimmedLowerCase),\n\t            Result.bind(testVal =>\n\t                pipe(\n\t                    enumValues,\n", "                    Array.find(val => toTrimmedLowerCase(val) === testVal),\n\t                    Option.match({\n\t                        some: a => Result.ok(a),\n\t                        none: () =>\n\t                            Result.err(\n\t                                getParserErrorMessage(enumValues, enumFriendlyName)\n\t                            ),\n\t                    })\n\t                )\n\t            )\n", "        )\n\tconst isFunc = (f: unknown): f is (...args: any[]) => any => typeof f === \"function\"\n\tconst getMatchFn =\n\t    <R extends RawEnum>(raw: R): EnumMatch<R> =>\n\t    matcher =>\n\t    value => {\n\t        const enumEntry = Object.entries(raw).find(([, v]) => v === value)\n\t        if (!enumEntry) {\n\t            throw new TypeError(\n\t                `Expected to match against an enum where '${value}' is a valid value.`\n", "            )\n\t        }\n\t        const enumLabel = enumEntry[0]\n\t        if (!Object.hasOwn(matcher, enumLabel)) {\n\t            throw new TypeError(\n\t                `Expected a matcher containing a case for '${enumLabel}'.`\n\t            )\n\t        }\n\t        const matcherBranch = matcher[enumLabel]\n\t        return isFunc(matcherBranch) ? matcherBranch() : matcherBranch\n", "    }\n\tconst getMatchOrElseFn =\n\t    <R extends RawEnum>(raw: R): EnumMatchOrElse<R> =>\n\t    matcher =>\n\t    value => {\n\t        const enumEntry = Object.entries(raw).find(([, v]) => v === value)\n\t        if (!enumEntry) {\n\t            throw new TypeError(\n\t                `Expected to match against an enum where '${value}' is a valid value.`\n\t            )\n", "        }\n\t        const enumLabel = enumEntry[0]\n\t        if (Object.hasOwn(matcher, enumLabel)) {\n\t            const branch = matcher[enumLabel]\n\t            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\t            return isFunc(branch) ? branch() : branch\n\t        }\n\t        return isFunc(matcher.orElse) ? matcher.orElse() : matcher.orElse\n\t    }\n\t/**\n", " * Generates an \"enum module\" from a raw object. For motivation behind using a custom\n\t * generative function instead of the built-in `enum` types, see [this video](https://youtu.be/jjMbPt_H3RQ).\n\t *\n\t * This function augments a raw \"enum object\" with several useful capabilities: `values`, `parse`, `match`,\n\t * and `matchOrElse`.\n\t *   - `values` contains the list of valid enum values\n\t *   - `parse` is a parser funciton auto-magically created for this enum\n\t *   - `match` is a pipeable function that allows exhaustive pattern matching\n\t *   - `matchOrElse` is a pipeable function that allows inexhaustive pattern matching\n\t *\n", " * @remarks\n\t * You can use the `parse` function together with `io-ts` to easily create a decoder for this enum.\n\t *\n\t * @example\n\t * ```ts\n\t * export const MyEnum = enumOf({\n\t *   Dog = 'Dog',\n\t *   Cat = 'Cat',\n\t *   ZEBRA = 1234,\n\t * } as const, 'MyEnum') // => friendly name optional; used to generate helpful decoder errors\n", " * export type MyEnum = EnumOf<typeof MyEnum>; //=> 'Dog' | 'Cat' | 1234\n\t *\n\t * // Standard enum-style accessors\n\t * const dog = MyEnum.Dog; // => 'Dog'\n\t * const zebra = MyEnum.ZEBRA; // => 1234\n\t *\n\t * // Access array of all valid values, correctly typed\n\t * const myEnumValues = MyEnum.values; // => ['Dog', 'Cat', 1234]\n\t *\n\t * // Get a decoder instance for this enum automagically\n", " * const myDecoder = MyEnum.decoder; // => a `D.Decoder<unknown, 'Dog' | 'Cat' | 1234>`\n\t *\n\t * // Match an enum value against all its cases (compiler ensures exhaustiveness)\n\t * const value: MyEnum = 'Cat';\n\t * const matchResult = pipe(\n\t *   value,\n\t *   MyEnum.match({\n\t *     Dog: 'woof woof',\n\t *     Cat: () => 'meow',\n\t *     ZEBRA: 'is my skin white with black stripes or black with white stripes??'\n", " *   })\n\t * ) // => 'meow'\n\t * ```\n\t */\n\texport const enumOf = <T extends RawEnum>(\n\t    raw: T,\n\t    enumFriendlyName = \"\"\n\t): EnumModule<T> => {\n\t    const entriesWithStringKeys = Object.entries(raw).reduce(\n\t        (acc, [label, value]) => ({\n", "            ...acc,\n\t            [label]: value,\n\t        }),\n\t        {}\n\t    )\n\t    const values = Object.values(raw)\n\t    return {\n\t        ...entriesWithStringKeys,\n\t        values,\n\t        parse: getParseFn(values, enumFriendlyName),\n", "        match: getMatchFn(raw),\n\t        matchOrElse: getMatchOrElseFn(raw),\n\t    } as unknown as EnumModule<T>\n\t}\n"]}
{"filename": "src/Map.ts", "chunked_list": ["/**\n\t * A suite of useful functions for working with the built-in `Map` type.\n\t *\n\t * @module Map\n\t */\n\timport { NonNullish, Predicate } from \"./prelude\"\n\timport { Option } from \"./Option\"\n\timport { pipe } from \"./Composition\"\n\timport { EqualityComparer } from \"./EqualityComparer\"\n\timport { OrderingComparer } from \"./OrderingComparer\"\n", "/**\n\t * Lookup a key/value pair (wrapped in a `Some`) from a `Map` using the given key.\n\t * If the `Map` doesn't contain the key, returns `None`.\n\t *\n\t * Uses the given equality comparer if passed. Otherwise, defaults to reference\n\t * equality (triple equals) for equality comparisons.\n\t *\n\t * @group Lookups\n\t *\n\t * @returns An `Option` containing a tuple of the key and value.\n", " */\n\texport const findWithKey =\n\t    <K>(key: K, { equals }: EqualityComparer<K> = EqualityComparer.Default) =>\n\t    <V>(map: ReadonlyMap<K, V>): Option<[K, V]> => {\n\t        if (map.size < 1) {\n\t            return Option.none\n\t        }\n\t        for (const [k, v] of map) {\n\t            if (equals(k, key)) {\n\t                return Option.some([k, v])\n", "            }\n\t        }\n\t        return Option.none\n\t    }\n\t/**\n\t * Test whether a `Map` contains the given key. Uses the given `EqualityComparer`\n\t * if passed. Otherwise, defaults to reference equality (triple equals).\n\t *\n\t * @group Lookups\n\t *\n", " * @returns `true` if the key is in the `Map`, `false` otherwise.\n\t */\n\texport const containsKey =\n\t    <K>(key: K, equalityComparer: EqualityComparer<K> = EqualityComparer.Default) =>\n\t    <V>(map: ReadonlyMap<K, V>): boolean =>\n\t        pipe(map, findWithKey(key, equalityComparer), Option.isSome)\n\t/**\n\t * Get a value associated with the given key from the `Map`. Returns a `Some`\n\t * containing the value, or `None` if the key is not in the `Map`.\n\t *\n", " * Uses the given equality comparer if passed, otherwise defaults to using\n\t * reference equality (triple equals) for equality comparison.\n\t *\n\t * @group Lookups\n\t */\n\texport const find =\n\t    <K>(key: K, equalityComparer: EqualityComparer<K> = EqualityComparer.Default) =>\n\t    <V extends NonNullish>(map: ReadonlyMap<K, V>): Option<V> =>\n\t        pipe(\n\t            map,\n", "            findWithKey(key, equalityComparer),\n\t            Option.map(([, v]) => v)\n\t        )\n\t/**\n\t * Adds a key/value pair to a `Map`. If the given key already exists\n\t * the value at that key will be updated with the given value.\n\t *\n\t * Will use the equality comparer if given, otherwise defaults to using\n\t * reference equality (triple equals) for equality comparisons.\n\t *\n", " * @group Transformations\n\t *\n\t * @returns A new `Map` with the added key/value pair\n\t */\n\texport const set =\n\t    <K, V>(\n\t        [key, value]: readonly [K, V],\n\t        equalityComparer: EqualityComparer<K> = EqualityComparer.Default\n\t    ) =>\n\t    (map: ReadonlyMap<K, V>): ReadonlyMap<K, V> => {\n", "        if (map.size < 1) {\n\t            const out = empty<K, V>()\n\t            out.set(key, value)\n\t            return out\n\t        }\n\t        const copy = new globalThis.Map(map)\n\t        return pipe(\n\t            map,\n\t            findWithKey(key, equalityComparer),\n\t            Option.match({\n", "                none: () => {\n\t                    copy.set(key, value)\n\t                    return copy\n\t                },\n\t                some: ([k]) => {\n\t                    copy.set(k, value)\n\t                    return copy\n\t                },\n\t            })\n\t        )\n", "    }\n\t/**\n\t * Make a new `Map` by producing a new each value for each key using\n\t * the given function.\n\t *\n\t * @group Mapping\n\t * @group Transformations\n\t */\n\texport const map =\n\t    <K, V, R>(f: (k: K, v: V) => R) =>\n", "    (map: ReadonlyMap<K, V>): ReadonlyMap<K, R> => {\n\t        if (map.size < 1) {\n\t            return empty<K, R>()\n\t        }\n\t        const out = empty<K, R>()\n\t        for (const [k, v] of map) {\n\t            out.set(k, f(k, v))\n\t        }\n\t        return out\n\t    }\n", "/**\n\t * Get the first key for which the given predicate function returns\n\t * true, wrapped in a `Some`. If no key is found, returns `None`. Uses\n\t * the given `OrderingComparer` if passed, otherwise defaults to default\n\t * ASCII-based sort.\n\t *\n\t * @group Lookups\n\t */\n\texport const findKey =\n\t    <K extends NonNullish>(\n", "        predicate: Predicate<K>,\n\t        orderingComparer: OrderingComparer<K> = OrderingComparer.Default\n\t    ) =>\n\t    <V>(map: ReadonlyMap<K, V>): Option<K> =>\n\t        Option.ofNullish(keys(orderingComparer)(map).find(predicate))\n\t/**\n\t * Creates a new empty map. Essentially an alias for `new globalThis.Map()`.\n\t * Provided for convience to avoid having to use `globalThis`.\n\t *\n\t * @group Constructors\n", " */\n\texport const empty = <K = never, V = never>() => new globalThis.Map<K, V>()\n\t/**\n\t * Returns `true` if at least one _value_ in the `Map` returns `true`\n\t * for the given predicate function.\n\t *\n\t * @group Lookups\n\t * @group Utils\n\t */\n\texport const exists =\n", "    <V>(predicate: Predicate<V>) =>\n\t    <K>(map: ReadonlyMap<K, V>): boolean => {\n\t        if (map.size < 1) {\n\t            return false\n\t        }\n\t        for (const [, v] of map) {\n\t            if (predicate(v)) {\n\t                return true\n\t            }\n\t        }\n", "        return false\n\t    }\n\t/**\n\t * Replace the value at a given key in the map using the given\n\t * replacement function. Will use the given `EqualityComparer`\n\t * if passed. Otherwise defaults to reference equality (triple equals).\n\t *\n\t * If the key isn't in the map, returns the map unchanged.\n\t *\n\t * @group Transformations\n", " */\n\texport const change =\n\t    <K, V>(\n\t        key: K,\n\t        f: (v: V) => V,\n\t        equalityComparer: EqualityComparer<K> = EqualityComparer.Default\n\t    ) =>\n\t    (map: ReadonlyMap<K, V>): ReadonlyMap<K, V> =>\n\t        pipe(\n\t            map,\n", "            findWithKey(key, equalityComparer),\n\t            Option.match({\n\t                some: ([k, v]) => {\n\t                    const copy = new globalThis.Map(map)\n\t                    copy.set(k, f(v))\n\t                    return copy\n\t                },\n\t                none: map,\n\t            })\n\t        )\n", "/**\n\t * Get the number of key/value pairs in the map.\n\t *\n\t * @group Utils\n\t */\n\texport const size = <K, V>(map: ReadonlyMap<K, V>) => map.size\n\t/**\n\t * Returns whether the map contains any key/value pairs.\n\t *\n\t * @group Utils\n", " *\n\t * @returns `true` if the map has no bindings, `false` otherwise.\n\t */\n\texport const isEmpty = <K, V>(map: ReadonlyMap<K, V>) => map.size < 1\n\t/**\n\t * Get only the keys from the map as an array. Will use the given `OrderingComparer`\n\t * to sort the keys, otherwise will the default ASCII-based sort.\n\t *\n\t * @group Utils\n\t */\n", "export const keys =\n\t    <K>({ compare }: OrderingComparer<K> = OrderingComparer.Default) =>\n\t    <V>(map: ReadonlyMap<K, V>): readonly K[] =>\n\t        Array.from(map.keys()).sort(compare)\n\t/**\n\t * Gets all the values from the map as an array, including duplicates. Values\n\t * will be sorted using the default ASCII-based sort or the `OrderingComparer`\n\t * if it is given.\n\t * @group Utils\n\t */\n", "export const values =\n\t    <V>(orderingComparer: OrderingComparer<V> = OrderingComparer.Default) =>\n\t    <K>(map: ReadonlyMap<K, V>): readonly V[] => {\n\t        const values: V[] = []\n\t        for (const [, v] of map) {\n\t            values.push(v)\n\t        }\n\t        return values.sort(orderingComparer.compare)\n\t    }\n\t/**\n", " * Returns the map as an array of key-value tuples. The array will be sorted by\n\t * key, using the given `OrderingComparer` or falling back to the default ASCII-based\n\t * sort.\n\t *\n\t * @group Transformations\n\t * @group Utils\n\t */\n\texport const toArray =\n\t    <K>(orderingComparer: OrderingComparer<K> = OrderingComparer.Default) =>\n\t    <V>(map: ReadonlyMap<K, V>): readonly (readonly [K, V])[] =>\n", "        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t        keys(orderingComparer)(map).map(key => [key, map.get(key)!])\n\t/**\n\t * Also commonly referred to as `fold` or `aggregate`. Applies each key/value\n\t * pair in the map to a \"reducer\" (or \"folding\") function to build up a final\n\t * accumulated value.\n\t *\n\t * Key/value pairs will be given to the reducer function based on the sort-order\n\t * of the keys. That order can be specified by passing the `OrderingComparer`.\n\t * Defaults to the standard ASCII-based sort.\n", " *\n\t * @group Transformations\n\t * @group Utils\n\t *\n\t * @param f\n\t * The reducer function. Accepts the accumulator value, the key, and the value and\n\t * produces the next incremental accumulator value.\n\t */\n\texport const reduce =\n\t    <S, K, V>(\n", "        init: S,\n\t        f: (acc: S, k: K, v: V) => S,\n\t        orderingComparer: OrderingComparer<K> = OrderingComparer.Default\n\t    ) =>\n\t    (map: ReadonlyMap<K, V>): S =>\n\t        toArray(orderingComparer)(map).reduce((s, [k, v]) => f(s, k, v), init)\n\t/**\n\t * Like {@link reduce}, but the key-value pairs are passed to the reducer in\n\t * _reverse_ sort-order.\n\t */\n", "export const reduceRight =\n\t    <S, K, V>(\n\t        init: S,\n\t        f: (acc: S, k: K, v: V) => S,\n\t        orderingComparer: OrderingComparer<K> = OrderingComparer.Default\n\t    ) =>\n\t    (map: ReadonlyMap<K, V>): S =>\n\t        toArray(orderingComparer)(map).reduceRight((s, [k, v]) => f(s, k, v), init)\n\t/**\n\t * Get a new map containing only the key/value pairs for which the given\n", " * predicate function returns `true`.\n\t *\n\t * @group Transformations\n\t * @group Filtering\n\t */\n\texport const filter =\n\t    <K, V>(f: (k: K, v: V) => boolean) =>\n\t    (map: ReadonlyMap<K, V>): ReadonlyMap<K, V> => {\n\t        if (map.size < 1) {\n\t            return empty()\n", "        }\n\t        const out = empty<K, V>()\n\t        for (const [k, v] of map) {\n\t            if (f(k, v)) {\n\t                out.set(k, v)\n\t            }\n\t        }\n\t        return out\n\t    }\n\t/**\n", " * Test whether every key/value pair in a map returns `true` for the\n\t * given predicate function.\n\t *\n\t * @group Utils\n\t */\n\texport const every =\n\t    <K, V>(f: (k: K, v: V) => boolean) =>\n\t    (map: ReadonlyMap<K, V>): boolean => {\n\t        if (map.size < 1) {\n\t            return true\n", "        }\n\t        for (const [k, v] of map) {\n\t            if (!f(k, v)) {\n\t                return false\n\t            }\n\t        }\n\t        return true\n\t    }\n\t/**\n\t * Execute an arbitrary side-effect function for every key/value pair in the map.\n", " * Does not affect the values contained in the map. Can be helpful for logging\n\t * or debugging.\n\t *\n\t * @group Utils\n\t *\n\t * @param f Should not mutate its arguments. See {@link map} if you want to\n\t * transform the map into a new map.\n\t *\n\t * @returns void\n\t */\n", "export const iter =\n\t    <K, V>(f: (k: K, v: V) => void) =>\n\t    (map: ReadonlyMap<K, V>): void => {\n\t        if (map.size < 1) {\n\t            return\n\t        }\n\t        for (const [k, v] of map) {\n\t            f(k, v)\n\t        }\n\t    }\n", "/**\n\t * Convert an array of tuples into a map of key/value pairs.\n\t *\n\t * @group Constructors\n\t */\n\texport const ofArray = <K, V>(\n\t    array: readonly (readonly [K, V])[],\n\t    equalityComparer: EqualityComparer<K> = EqualityComparer.Default\n\t): ReadonlyMap<K, V> => {\n\t    if (array.length < 1) {\n", "        return new globalThis.Map()\n\t    }\n\t    return array.reduce<ReadonlyMap<K, V>>(\n\t        (map, kvp) => set(kvp, equalityComparer)(map),\n\t        empty()\n\t    )\n\t}\n\t/**\n\t * Remove the given key from the map. Will use the `EqualityComparer` if passed,\n\t * otherwise defaults to reference equality (triple equals). The map will be\n", " * returned unchanged if the key is not found in the map.\n\t *\n\t * @group Transformations\n\t */\n\texport const remove =\n\t    <K>(key: K, equalityComparer: EqualityComparer<K> = EqualityComparer.Default) =>\n\t    <V>(map: ReadonlyMap<K, V>) =>\n\t        pipe(\n\t            map,\n\t            findWithKey(key, equalityComparer),\n", "            Option.match({\n\t                some: ([k]) => {\n\t                    const copy = new globalThis.Map(map)\n\t                    copy.delete(k)\n\t                    return copy\n\t                },\n\t                none: map,\n\t            })\n\t        )\n\t/**\n", " * Convert a `Record` object into a map of key/value pairs. Uses `Object.entries`\n\t * under-the-hood, so keep in mind there are some gotchas about what comprise\n\t * an object's \"own, enumerable\" properties. Designed primarily to be used for\n\t * simple objects like those deserialized from a JSON blob, for instance.\n\t *\n\t * Will use the given `EqualityComparer` to determine key uniqueness if given.\n\t * Otherwise, defaults to reference equality (triple equals).\n\t *\n\t * @group Constructors\n\t */\n", "export const ofRecord = <K extends string, V>(\n\t    record: Record<K, V>,\n\t    equalityComparer: EqualityComparer<K> = EqualityComparer.Default\n\t) =>\n\t    Object.entries<V>(record).reduce<ReadonlyMap<K, V>>(\n\t        (map, [k, v]) => set([k as K, v], equalityComparer)(map),\n\t        empty()\n\t    )\n\t/* c8 ignore start */\n\t/** @ignore */\n", "export const Map = {\n\t    exists,\n\t    containsKey,\n\t    findWithKey,\n\t    find,\n\t    findKey,\n\t    set,\n\t    remove,\n\t    change,\n\t    map,\n", "    filter,\n\t    every,\n\t    iter,\n\t    empty,\n\t    size,\n\t    isEmpty,\n\t    reduce,\n\t    reduceRight,\n\t    toArray,\n\t    ofArray,\n", "    ofRecord,\n\t    keys,\n\t    values,\n\t}\n\t/* c8 ignore end */\n"]}
{"filename": "src/Composition.ts", "chunked_list": ["/* eslint-disable @typescript-eslint/no-non-null-assertion */\n\t/* eslint-disable prefer-rest-params */\n\t/* eslint-disable @typescript-eslint/ban-types */\n\t/* eslint-disable func-style */\n\t/* eslint-disable @typescript-eslint/no-unsafe-return */\n\t/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n\t/* eslint-disable  @typescript-eslint/no-unsafe-call */\n\t/// ATTRIBUTION: https://github.com/gcanti/fp-ts/blob/master/src/function.ts\n\t/**\n\t- [Jump to Pipe](#pipelining-with-pipe)\n", "- [Jump to Flow](#flowing-with-flow)\n\tBoth JavaScript and TypeScript have great support for the functional programming paradigm because\n\tthey support functions as first-class values. That is, functions can be assigned to variables, passed\n\taround as arguments to other functions, and can be freely constructed and typed in the same way as\n\tany other values.\n\tThe functional programming paradigm takes this a step further by making function composition the\n\tprimary (but not always exclusive!) means by which large and complex applications are built.\n\tReact itself is a prime example. Using Function Components to construct a user interface is essentially\n\tjust composing lots of small functions (read: components) together to make one larger function (the \n\troot component of your application component tree).\n", "### Math-y definition\n\tIn its most abstract and pure mathematical sense, function composition is simply taking the result\n\tfrom one function and passing it to another function. Consider the following code snippet:\n\t```ts\n\tconst f = (n: number) => n * 20\n\tconst g = (n: number) => n + 4\n\t// define a new function `h` that is the _composition_ of `f` and `g`\n\tconst h = (n: number) => f(g(n))\n\t```\n\tNotice that the composition essentially reflects passing the value first to `g`, then passing the\n", "resultant value immediately to `f`. Of course, we can keep composing functions all the way down the\n\troad like `f(g(h(z(42)))`.\n\t## Pipelining with `pipe`\n\tBecause function composition is so useful and prevalent in the functional paradigm, it helps to make\n\tit as readable and convenient as possible.\n\tThe `pipe` operator is a way to re-organize function composition so that it reads linearly, like a\n\tpipeline... hence its name! Using the `pipe` operator, the nested mess above could be written as follows:\n\t```ts\n\tconst result = pipe(\n\t    42,\n", "    z,\n\t    h,\n\t    g,\n\t    f\n\t)\n\t```\n\tIn plain english: \"Start with the value 42. Pass that value to `z`. Then pass the resultant value to `h`.\n\tThen pass the resultant value to `g`. Then pass the resultant value to `f`.\"\n\t**Note:** Pipelining requires unary functions (functions that take a single argument) to work properly. This\n\tis why generally functionally-oriented libraries like this one favor curried function signatures.\n", "### Examples\n\tFunction composition with `pipe` is the primary motivation for using currying and partially applying\n\tfunctions. Consider the following annotated code example:\n\t```ts\n\t// lets assume we have access to some basic string functions with these signatures\n\tdeclare const capitalize: (s: string) => string\n\tdeclare const exclaim: (s: string) => string\n\tdeclare const duplicate: (s: string) => [string, string]\n\t// note that the following functions are curried\n\tdeclare const split: (splitter: string) => (s: string) => string[]\n", "declare const join: (joiner: string) => (as: string[]) => string\n\tdeclare const map: <A, B>(f: (a: A) => B) => (as: A[]) => B[]\n\tdeclare const flatMap: <A, B>(f: (a: A) => B[]) => (as: A[]) => B[]\n\tconst result = pipe(\n\t    \"hello there\",\n\t    split(\" \"),                             // [\"hello\", \"there\"]\n\t    map(s => pipe(s, capitalize, exclaim)), // [\"Hello!\", \"There!\"]\n\t    flatMap(duplicate),                     // [\"Hello!\", \"Hello!\", \"There!\", \"There!\"]\n\t    join(\"<>\")                              // \"Hello!<>Hello!<>There!<>There!\"\n\t);\n", "```\n\tAs you can see, this fashion of function composition allows us to \"snap together\" (like LEGO bricks)\n\tsmall and simple functions to build up more complicated logic and data transformation pipelines that...\n\t1. are more _declarative_ than _imperative_&mdash;they describe what we would like done at a high level,\n\t   they don't tell the computer how exactly to do it\n\t2. require no intermediate throw-away values\n\tFor instance, you could rewrite the above pipeline along these lines:\n\t```ts\n\tconst splitResult = \"hello there\".split(\" \")\n\tconst mapResult = splitResult.map(s => {\n", "  const capitalized = capitalize(s);\n\t  return exclaim(capitalized);\n\t})\n\tconst flatMapResult = mapResult.flatMap(duplicate)\n\tconst joinResult = flatMapResult.join(\"<>\")\n\t```\n\tSee how you have to manually declare the result of each step and pass that explicitly to the next \"step\"\n\tin the flow?\n\tOf course, in this instance, you could _probably_ achieve a similar syntax with fluent method chaining,\n\tbecause JavaScript provides a lot of prototype methods for strings and arrays that are interoperable.\n", "But that is something of a special case for strings and arrays in particular. More importantly, method\n\tchaining requires you to [monkey patch](https://en.wikipedia.org/wiki/Monkey_patch) the global prototype\n\tto be able to fluently chain non-built-in functions together.\n\tThis example is just to demonstrate how the `pipe` allows you to get rid of the usually-required intermediate\n\tresult assignments that are threaded through to the next call using any arbitrary functions, _regardless\n\tof what is available as instance methods_.\n\t### TC39 proposal\n\tThere is a [stage 2 proposal](https://github.com/tc39/proposal-pipeline-operator) to make the pipeline operator\n\t(`|>`) built-in to JavaScript because it is a high-demand language feature. TypeScript generally implements\n\tTC39 proposals once they hit stage 3.\n", "## Flowing with `flow`\n\tLet's revisit part of the example from above:\n\t```ts\n\tconst result = pipe(\n\t    \"hello there\",\n\t    split(\" \"),\n\t    map(s => pipe(s, capitalize, exclaim)), // notice how `s` is only used as the initial value for `pipe`?\n\t    flatMap(duplicate),\n\t    join(\"<>\")\n\t)\n", "```\n\tWhenever you see a lambda where the lambda argument is only used as the initial value, you can likely\n\treplace that with `flow`.\n\tSo, the above could be re-written:\n\t```ts\n\tconst result = pipe(\n\t    \"hello there\",\n\t    split(\" \"),\n\t    map(flow(\n\t        capitalize,\n", "        exclaim\n\t    )),\n\t    flatMap(duplicate),\n\t    join(\"<>\")\n\t)\n\t```\n\tYou can think of `flow` like `pipe` where the initial value becomes the implicit first argument to the\n\tfunction. So, for example, these two function definitions are equivalent:\n\t```ts\n\tdeclare const double: (n: number) => number\n", "declare const addTwenty: (n: number) => number\n\tconst doubleThenAddTwenty1 = (n: number) => pipe(n, double, addTwenty);\n\tconst doubleThenAddTwenty2 = flow(double, addTwenty);\n\t```\n\tThe fancy term for `flow` is left-to-right function composition. But, frankly, it is generally easier\n\tto just think about `flow` as a `pipe` where the initial value of the `pipe` becomes the implicit first\n\targument to the function that `flow` produces.\n\tOr, another way to think about it is that `pipe` starts with a **value** then accepts a pipeline of\n\tfunctions, and returns a **value**. `flow`, on the other hand, starts with a **function** and accepts =\n\tother functions to compose together and returns a **function** that is \"waiting\" to be passed a value.\n", "Yet another way to conceptualize it is that immediately passing a value to a function composed with\n\t`flow` is identical to using `pipe` starting with the value, so the following two are identical:\n\t```ts\n\tconst result1 = pipe(\"help\", capitalize, exclaim);\n\tconst result2 = flow(capitalize, exclaim)(\"help\");\n\t```\n\t### A word of warning\n\tBecause of how TypeScript's compiler works, `pipe` will almost always give you better type inference\n\tthan `flow`. Especially when you start to work with generic types like `Option`s or `Array`s, you\n\twill likely find that TypeScript gets confused rather frequently if you overuse `flow`, so don't abuse it!\n", "Moreover, abusing or overusing `flow` can actually end up making your code _less_ readable than\n\tit would be with more straightforward `pipe`s.\n\t**As a rule of thumb**, you should _usually_ constrain your use of `flow` to small local functions\n\twhere you already have good type inference, like in the example above.\n\t@module Composition\n\t*/\n\t/* c8 ignore start */\n\t/** Left-to-right function composition. See module-level docs for more. */\n\texport function flow<A extends ReadonlyArray<unknown>, B>(\n\t    ab: (...a: A) => B\n", "): (...a: A) => B\n\texport function flow<A extends ReadonlyArray<unknown>, B, C>(\n\t    ab: (...a: A) => B,\n\t    bc: (b: B) => C\n\t): (...a: A) => C\n\texport function flow<A extends ReadonlyArray<unknown>, B, C, D>(\n\t    ab: (...a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D\n\t): (...a: A) => D\n", "export function flow<A extends ReadonlyArray<unknown>, B, C, D, E>(\n\t    ab: (...a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E\n\t): (...a: A) => E\n\texport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F>(\n\t    ab: (...a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n", "    de: (d: D) => E,\n\t    ef: (e: E) => F\n\t): (...a: A) => F\n\texport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G>(\n\t    ab: (...a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E,\n\t    ef: (e: E) => F,\n\t    fg: (f: F) => G\n", "): (...a: A) => G\n\texport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H>(\n\t    ab: (...a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E,\n\t    ef: (e: E) => F,\n\t    fg: (f: F) => G,\n\t    gh: (g: G) => H\n\t): (...a: A) => H\n", "export function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H, I>(\n\t    ab: (...a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E,\n\t    ef: (e: E) => F,\n\t    fg: (f: F) => G,\n\t    gh: (g: G) => H,\n\t    hi: (h: H) => I\n\t): (...a: A) => I\n", "export function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H, I, J>(\n\t    ab: (...a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E,\n\t    ef: (e: E) => F,\n\t    fg: (f: F) => G,\n\t    gh: (g: G) => H,\n\t    hi: (h: H) => I,\n\t    ij: (i: I) => J\n", "): (...a: A) => J\n\texport function flow(\n\t    ab: Function,\n\t    bc?: Function,\n\t    cd?: Function,\n\t    de?: Function,\n\t    ef?: Function,\n\t    fg?: Function,\n\t    gh?: Function,\n\t    hi?: Function,\n", "    ij?: Function\n\t): unknown {\n\t    switch (arguments.length) {\n\t        case 1:\n\t            return ab\n\t        case 2:\n\t            return function (this: unknown) {\n\t                return bc!(ab.apply(this, arguments))\n\t            }\n\t        case 3:\n", "            return function (this: unknown) {\n\t                return cd!(bc!(ab.apply(this, arguments)))\n\t            }\n\t        case 4:\n\t            return function (this: unknown) {\n\t                return de!(cd!(bc!(ab.apply(this, arguments))))\n\t            }\n\t        case 5:\n\t            return function (this: unknown) {\n\t                return ef!(de!(cd!(bc!(ab.apply(this, arguments)))))\n", "            }\n\t        case 6:\n\t            return function (this: unknown) {\n\t                return fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments))))))\n\t            }\n\t        case 7:\n\t            return function (this: unknown) {\n\t                return gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments)))))))\n\t            }\n\t        case 8:\n", "            return function (this: unknown) {\n\t                return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments))))))))\n\t            }\n\t        case 9:\n\t            return function (this: unknown) {\n\t                return ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments)))))))))\n\t            }\n\t    }\n\t    return\n\t}\n", "/* c8 ignore end */\n\t// ATTRIBUTION: https://github.com/gcanti/fp-ts/blob/master/src/function.ts\n\t/* c8 ignore start */\n\t/**\n\t * A version of left-to-right function composition that starts with a _value_.\n\t * Commonly referred to as function pipelining, for obvious reasons.\n\t *\n\t * See module-level docs for more.\n\t */\n\texport function pipe<A>(a: A): A\n", "export function pipe<A, B>(a: A, ab: (a: A) => B): B\n\texport function pipe<A, B, C>(a: A, ab: (a: A) => B, bc: (b: B) => C): C\n\texport function pipe<A, B, C, D>(\n\t    a: A,\n\t    ab: (a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D\n\t): D\n\texport function pipe<A, B, C, D, E>(\n\t    a: A,\n", "    ab: (a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E\n\t): E\n\texport function pipe<A, B, C, D, E, F>(\n\t    a: A,\n\t    ab: (a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n", "    de: (d: D) => E,\n\t    ef: (e: E) => F\n\t): F\n\texport function pipe<A, B, C, D, E, F, G>(\n\t    a: A,\n\t    ab: (a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E,\n\t    ef: (e: E) => F,\n", "    fg: (f: F) => G\n\t): G\n\texport function pipe<A, B, C, D, E, F, G, H>(\n\t    a: A,\n\t    ab: (a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E,\n\t    ef: (e: E) => F,\n\t    fg: (f: F) => G,\n", "    gh: (g: G) => H\n\t): H\n\texport function pipe<A, B, C, D, E, F, G, H, I>(\n\t    a: A,\n\t    ab: (a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E,\n\t    ef: (e: E) => F,\n\t    fg: (f: F) => G,\n", "    gh: (g: G) => H,\n\t    hi: (h: H) => I\n\t): I\n\texport function pipe<A, B, C, D, E, F, G, H, I, J>(\n\t    a: A,\n\t    ab: (a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E,\n\t    ef: (e: E) => F,\n", "    fg: (f: F) => G,\n\t    gh: (g: G) => H,\n\t    hi: (h: H) => I,\n\t    ij: (i: I) => J\n\t): J\n\texport function pipe<A, B, C, D, E, F, G, H, I, J, K>(\n\t    a: A,\n\t    ab: (a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n", "    de: (d: D) => E,\n\t    ef: (e: E) => F,\n\t    fg: (f: F) => G,\n\t    gh: (g: G) => H,\n\t    hi: (h: H) => I,\n\t    ij: (i: I) => J,\n\t    jk: (j: J) => K\n\t): K\n\texport function pipe<A, B, C, D, E, F, G, H, I, J, K, L>(\n\t    a: A,\n", "    ab: (a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E,\n\t    ef: (e: E) => F,\n\t    fg: (f: F) => G,\n\t    gh: (g: G) => H,\n\t    hi: (h: H) => I,\n\t    ij: (i: I) => J,\n\t    jk: (j: J) => K,\n", "    kl: (k: K) => L\n\t): L\n\texport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n\t    a: A,\n\t    ab: (a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E,\n\t    ef: (e: E) => F,\n\t    fg: (f: F) => G,\n", "    gh: (g: G) => H,\n\t    hi: (h: H) => I,\n\t    ij: (i: I) => J,\n\t    jk: (j: J) => K,\n\t    kl: (k: K) => L,\n\t    lm: (l: L) => M\n\t): M\n\texport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n\t    a: A,\n\t    ab: (a: A) => B,\n", "    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E,\n\t    ef: (e: E) => F,\n\t    fg: (f: F) => G,\n\t    gh: (g: G) => H,\n\t    hi: (h: H) => I,\n\t    ij: (i: I) => J,\n\t    jk: (j: J) => K,\n\t    kl: (k: K) => L,\n", "    lm: (l: L) => M,\n\t    mn: (m: M) => N\n\t): N\n\texport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n\t    a: A,\n\t    ab: (a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E,\n\t    ef: (e: E) => F,\n", "    fg: (f: F) => G,\n\t    gh: (g: G) => H,\n\t    hi: (h: H) => I,\n\t    ij: (i: I) => J,\n\t    jk: (j: J) => K,\n\t    kl: (k: K) => L,\n\t    lm: (l: L) => M,\n\t    mn: (m: M) => N,\n\t    no: (n: N) => O\n\t): O\n", "export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n\t    a: A,\n\t    ab: (a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E,\n\t    ef: (e: E) => F,\n\t    fg: (f: F) => G,\n\t    gh: (g: G) => H,\n\t    hi: (h: H) => I,\n", "    ij: (i: I) => J,\n\t    jk: (j: J) => K,\n\t    kl: (k: K) => L,\n\t    lm: (l: L) => M,\n\t    mn: (m: M) => N,\n\t    no: (n: N) => O,\n\t    op: (o: O) => P\n\t): P\n\texport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n\t    a: A,\n", "    ab: (a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E,\n\t    ef: (e: E) => F,\n\t    fg: (f: F) => G,\n\t    gh: (g: G) => H,\n\t    hi: (h: H) => I,\n\t    ij: (i: I) => J,\n\t    jk: (j: J) => K,\n", "    kl: (k: K) => L,\n\t    lm: (l: L) => M,\n\t    mn: (m: M) => N,\n\t    no: (n: N) => O,\n\t    op: (o: O) => P,\n\t    pq: (p: P) => Q\n\t): Q\n\texport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(\n\t    a: A,\n\t    ab: (a: A) => B,\n", "    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E,\n\t    ef: (e: E) => F,\n\t    fg: (f: F) => G,\n\t    gh: (g: G) => H,\n\t    hi: (h: H) => I,\n\t    ij: (i: I) => J,\n\t    jk: (j: J) => K,\n\t    kl: (k: K) => L,\n", "    lm: (l: L) => M,\n\t    mn: (m: M) => N,\n\t    no: (n: N) => O,\n\t    op: (o: O) => P,\n\t    pq: (p: P) => Q,\n\t    qr: (q: Q) => R\n\t): R\n\texport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(\n\t    a: A,\n\t    ab: (a: A) => B,\n", "    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E,\n\t    ef: (e: E) => F,\n\t    fg: (f: F) => G,\n\t    gh: (g: G) => H,\n\t    hi: (h: H) => I,\n\t    ij: (i: I) => J,\n\t    jk: (j: J) => K,\n\t    kl: (k: K) => L,\n", "    lm: (l: L) => M,\n\t    mn: (m: M) => N,\n\t    no: (n: N) => O,\n\t    op: (o: O) => P,\n\t    pq: (p: P) => Q,\n\t    qr: (q: Q) => R,\n\t    rs: (r: R) => S\n\t): S\n\texport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(\n\t    a: A,\n", "    ab: (a: A) => B,\n\t    bc: (b: B) => C,\n\t    cd: (c: C) => D,\n\t    de: (d: D) => E,\n\t    ef: (e: E) => F,\n\t    fg: (f: F) => G,\n\t    gh: (g: G) => H,\n\t    hi: (h: H) => I,\n\t    ij: (i: I) => J,\n\t    jk: (j: J) => K,\n", "    kl: (k: K) => L,\n\t    lm: (l: L) => M,\n\t    mn: (m: M) => N,\n\t    no: (n: N) => O,\n\t    op: (o: O) => P,\n\t    pq: (p: P) => Q,\n\t    qr: (q: Q) => R,\n\t    rs: (r: R) => S,\n\t    st: (s: S) => T\n\t): T\n", "export function pipe(\n\t    a: unknown,\n\t    ab?: Function,\n\t    bc?: Function,\n\t    cd?: Function,\n\t    de?: Function,\n\t    ef?: Function,\n\t    fg?: Function,\n\t    gh?: Function,\n\t    hi?: Function\n", "): unknown {\n\t    switch (arguments.length) {\n\t        case 1:\n\t            return a\n\t        case 2:\n\t            return ab!(a)\n\t        case 3:\n\t            return bc!(ab!(a))\n\t        case 4:\n\t            return cd!(bc!(ab!(a)))\n", "        case 5:\n\t            return de!(cd!(bc!(ab!(a))))\n\t        case 6:\n\t            return ef!(de!(cd!(bc!(ab!(a)))))\n\t        case 7:\n\t            return fg!(ef!(de!(cd!(bc!(ab!(a))))))\n\t        case 8:\n\t            return gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))\n\t        case 9:\n\t            return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))\n", "        default: {\n\t            let ret = arguments[0]\n\t            for (let i = 1; i < arguments.length; i++) {\n\t                ret = arguments[i](ret)\n\t            }\n\t            return ret\n\t        }\n\t    }\n\t}\n\t/* c8 ignore end */\n"]}
{"filename": "src/EqualityComparer.ts", "chunked_list": ["/**\n\t * An `EqualityComparer` is intended to model deterministic or \"decideable\" equality\n\t * between two values. Meaning, it should always give back the same result for the\n\t * same inputs.\n\t *\n\t * Generally you won't need to worry about these things, but in case you come up against\n\t * some weird edge cases, `EqualityComparer`s should always satisfy these rules:\n\t *   1. always return `true` if given two values that are the same object reference\n\t *       - `myEqComparer.equals(a, a) === true`\n\t *   1. always return `true` for equivalent variables, regardless of the order in which they are passed\n", " *       - `myEqComparer.equals(a, b) === myEqComparer.equals(b, a)`\n\t *   1. should be transitive such that if `a` = `b` and `b` = `c`, then `a` = `c`\n\t *\n\t * **Note:** An `EqualityComparer` is structurally compatible with the `Eq` type from `fp-ts`.\n\t *\n\t * @example\n\t * interface Pet {\n\t *    readonly name: string\n\t *    readonly age: number\n\t * }\n", " *\n\t * class PetByNameComparer implements EqualityComparer<Pet> {\n\t *    equals(p1: Pet, p2: Pet): boolean {\n\t *        return p1.name === p2.name\n\t *    }\n\t * }\n\t *\n\t * @module EqualityComparer\n\t */\n\texport interface EqualityComparer<A> {\n", "    equals(a1: A, a2: A): boolean\n\t}\n\t/**\n\t * Construct a new `EqualityComparer` instance by providing an `equals` function\n\t * that can decide equality between two values.\n\t *\n\t * @group Constructors\n\t *\n\t * @returns A new `EqualityComparer` instance.\n\t */\n", "export const ofEquals = <A>(\n\t    equals: EqualityComparer<A>[\"equals\"]\n\t): EqualityComparer<A> => ({\n\t    equals: (a1, a2) => a1 === a2 || equals(a1, a2),\n\t})\n\t/**\n\t * Given you already have an `EqualityComparer` for some type `A`, and you know how to\n\t * map from some other type `B` to `A`, you can effectively \"re-use\" your `EqualityComparer`\n\t * for type `B`. Also referred to commonly as `contramap`, because the mapping is going\n\t * from `B`&rarr;`A`, not from `A`&rarr;`B`.\n", " *\n\t * @group Utils\n\t * @group Constructors\n\t *\n\t * @param known The `EqualityComparer` that you already have.\n\t * @param map The function that can map from `B`&rarr;`A`.\n\t *\n\t * @returns A new `EqualityComparer` instance.\n\t */\n\texport const deriveFrom = <A, B>(\n", "    known: EqualityComparer<A>,\n\t    map: (b: B) => A\n\t): EqualityComparer<B> => ({\n\t    equals: (b1, b2) => b1 === b2 || known.equals(map(b1), map(b2)),\n\t})\n\ttype EqualityComparerRecord<A extends object> = {\n\t    readonly [Key in keyof A]: EqualityComparer<A[Key]>\n\t}\n\t/**\n\t * Get an `EqualityComparer` that represents _structural_ equality for a type that\n", " * conforms to the given shape of type `A`. It is generally required to use `ofStruct`\n\t * for any complex object type for which you would like property-by-property comparison,\n\t * because JavaScript has no concept of structural or value-based equality.\n\t *\n\t * Will perform property-by-property equality comparsion for each property of the object,\n\t * using the given `EqualityComparer` instance for each property.\n\t *\n\t * @group Utils\n\t * @group Constructors\n\t *\n", " * @returns A new `EqualityComparer` instance.\n\t */\n\texport const ofStruct = <A extends object>(\n\t    struct: EqualityComparerRecord<A>\n\t): EqualityComparer<Readonly<A>> =>\n\t    ofEquals((a1, a2) => {\n\t        for (const key in struct) {\n\t            if (!struct[key].equals(a1[key], a2[key])) {\n\t                return false\n\t            }\n", "        }\n\t        return true\n\t    })\n\t/**\n\t * The default `EqualityComparer`, which uses reference (triple equals) equality.\n\t *\n\t * @group Primitives\n\t */\n\texport const Default: EqualityComparer<never> = Object.freeze(\n\t    ofEquals((a1, a2) => a1 === a2)\n", ")\n\t/**\n\t * An `EqualityComparer` for the built-in `Date` type.\n\t *\n\t * @group Primitives\n\t */\n\texport const Date: EqualityComparer<Date> = ofEquals(\n\t    (dt1, dt2) => dt1.valueOf() === dt2.valueOf()\n\t)\n\t/**\n", " * An `EqualityComparer` for the built-in `string` type.\n\t *\n\t * @group Primitives\n\t */\n\texport const String: EqualityComparer<string> = Default\n\t/**\n\t * An `EqualityComparer` for the built-in `number` type.\n\t *\n\t * @group Primitives\n\t */\n", "export const Number: EqualityComparer<number> = Default\n\t/* c8 ignore start */\n\t/** @ignore */\n\texport const EqualityComparer = {\n\t    ofEquals,\n\t    ofStruct,\n\t    deriveFrom,\n\t    Default,\n\t    Date,\n\t    String,\n", "    Number,\n\t}\n\t/* c8 ignore end */\n"]}
{"filename": "src/Option.ts", "chunked_list": ["/**\n\t * An `Option` represents a value that is, well, optional\n\t * it can either be present or absent. This is particularly\n\t * useful for modeling nullable values while avoiding the\n\t * possibility of null reference errors.\n\t *\n\t * @group Types\n\t *\n\t * @remarks\n\t * The functions in this module are curried and are optimized\n", " * for use with left-to-right function composition like `pipe`\n\t * and `flow`.\n\t *\n\t * **Note:** There is a generic type constraint on option that\n\t * excludes `null`, `undefined`, and `void` types. This is\n\t * intentional, because `Option<undefined>` or `Option<null>` make\n\t * little to no sense conceptually.\n\t *\n\t *\n\t * @example\n", " * ```\n\t * pipe(\n\t *     56,\n\t *     Option.ofNullish,\n\t *     Option.filter(n => n > 50),\n\t *     Option.map(String),\n\t *     Option.match({\n\t *         some: a => `${a}!`,\n\t *         none: \"!\"\n\t *     }),\n", " *     console.info\n\t * ) // logs \"56!\"\n\t * ```\n\t *\n\t * @module Option\n\t */\n\t/* eslint-disable @typescript-eslint/no-empty-interface */\n\timport { Tagged, assertExhaustive, Refinement, NonNullish } from \"./prelude\"\n\timport { pipe } from \"./Composition\"\n\timport { EqualityComparer } from \"./EqualityComparer\"\n", "export interface Some<A extends NonNullish> extends Tagged<\"Some\", { some: A }> {}\n\texport interface None extends Tagged<\"None\", object> {}\n\texport type Option<A extends NonNullish> = Some<A> | None\n\t/**\n\t * Creates a new `Some` instance.\n\t *\n\t * @group Constructors\n\t *\n\t * @returns a new `Some` instance containing the given value\n\t */\n", "export const some = <A extends NonNullish>(some: A): Option<A> => ({\n\t    _tag: \"Some\",\n\t    some,\n\t})\n\t/**\n\t * Alias for the Some constructor. See {@link some}.\n\t *\n\t * @group Constructors\n\t */\n\texport const of = some\n", "/**\n\t * The static None instance.\n\t *\n\t * @group Constructors\n\t */\n\texport const none: Option<never> = Object.freeze({ _tag: \"None\" })\n\t/**\n\t * @ignore\n\t */\n\ttype OptionMatcher<A, R> = {\n", "    readonly some: R | ((some: A) => R)\n\t    readonly none: R | (() => R)\n\t}\n\tconst isRawValue = <A, R>(caseFn: R | ((ok: A) => R)): caseFn is R =>\n\t    typeof caseFn !== \"function\"\n\tconst getMatcherResult = <T, R>(match: ((t: T) => R) | R, arg: T) =>\n\t    isRawValue(match) ? match : match(arg)\n\t/**\n\t * Exhaustively pattern match against an `Option` in order\n\t * to \"unwrap\" the inner value. Provide either a raw value\n", " * or lambda to use for each case (`Some` or `None`). This\n\t * function is curried.\n\t *\n\t * @group Pattern Matching\n\t *\n\t * @example\n\t * pipe(\n\t *     Option.some(42),\n\t *     Option.match({\n\t *         some: n => n * 2,\n", " *         none: 0,\n\t *     })\n\t * ) // => 84\n\t */\n\texport const match =\n\t    <A extends NonNullish, R>(matcher: OptionMatcher<A, R>) =>\n\t    (option: Option<A>) => {\n\t        switch (option._tag) {\n\t            case \"Some\":\n\t                return getMatcherResult(matcher.some, option.some)\n", "            case \"None\":\n\t                return getMatcherResult(matcher.none, void 0)\n\t            /* c8 ignore next 2 */\n\t            default:\n\t                return assertExhaustive(option)\n\t        }\n\t    }\n\t/**\n\t * Maps the wrapped `Some` value using the given function.\n\t * Passes through `None` as-is.\n", " *\n\t * @group Mapping\n\t *\n\t * @example\n\t * pipe(\n\t *     Option.some(\"cheese\"),\n\t *     Option.map(s => s.length),\n\t *     Option.defaultValue(0)\n\t * ) // => 6\n\t */\n", "export const map = <A extends NonNullish, B extends NonNullish>(f: (a: A) => B) =>\n\t    match<A, Option<B>>({\n\t        some: a => some(f(a)),\n\t        none: none,\n\t    })\n\t/**\n\t * Tests the wrapped `Some` value using the given predicate.\n\t * If the wrapped value fails the check, returns `None`.\n\t * `None` is passed through as-is.\n\t *\n", " * @group Filtering\n\t *\n\t * @example\n\t * pipe(\n\t *     Option.some(70),\n\t *     Option.filter(n => n <= 25),\n\t *     Option.defaultValue(0)\n\t * ) // => 0\n\t */\n\texport const filter = <A extends NonNullish>(f: (a: A) => boolean) =>\n", "    match<A, Option<A>>({\n\t        some: a => (f(a) ? some(a) : none),\n\t        none: none,\n\t    })\n\t/**\n\t * Use a type guard (a.k.a. `Refinement`) to filter the wrapped value.\n\t * If the type guard holds for the wrapped value, returns `Some` with\n\t * the narrowed type. `None` is passed through as-is.\n\t *\n\t * @group Filtering\n", " *\n\t * @example\n\t * ```\n\t * const isString = (u: unknown): u is string => typeof u === \"string\"\n\t *\n\t * pipe(\n\t *     Option.some(\"cheese\" as any),    // Option<any>\n\t *     Option.refine(isString),         // Option<string> (type is narrowed by the guard)\n\t *     Option.map(s => s.length)        // Option<number> (TS infers the type of `s`)\n\t * ) // => Option.some(6)\n", " * ```\n\t */\n\texport const refine = <A extends NonNullish, B extends A>(f: Refinement<A, B>) =>\n\t    match<A, Option<B>>({\n\t        some: a => (f(a) ? some(a) : none),\n\t        none: none,\n\t    })\n\t/**\n\t * Returns the wrapped value if the `Option` is `Some`,\n\t * otherwise uses the given value as a default value.\n", " *\n\t * @group Pattern Matching\n\t *\n\t * @example\n\t * pipe(\n\t *     Option.none,\n\t *     Option.defaultValue(\"ABC\")\n\t * ) // => \"ABC\"\n\t */\n\texport const defaultValue = <A extends NonNullish>(a: A) =>\n", "    match<A, A>({\n\t        some: a => a,\n\t        none: a,\n\t    })\n\t/**\n\t * Returns the wrapped value if `Some`. Otherwise, uses the\n\t * given lambda to compute and return a default value.\n\t *\n\t * @group Pattern Matching\n\t *\n", " * @example\n\t * pipe(\n\t *     Option.some(\"123\"),\n\t *     Option.defaultWith(() => \"\")\n\t * ) // => \"123\"\n\t *\n\t * @example\n\t * pipe(\n\t *     Option.none,\n\t *     Option.defaultWith(() => \"\")\n", " * ) // => \"\"\n\t */\n\texport const defaultWith = <A extends NonNullish>(f: () => A) =>\n\t    match<A, A>({\n\t        some: a => a,\n\t        none: f,\n\t    })\n\t/**\n\t * Maps an `Option` using a function that returns another\n\t * `Option` and flattens the result. Sometimes called `flatMap`.\n", " *\n\t * @group Mapping\n\t *\n\t * @example\n\t * ```ts\n\t * declare mightFailA: () => Option<string>\n\t * declare mightFailB: (s: string) => Option<number>\n\t *\n\t * pipe(\n\t *     mightFailA(),                // Option<string>\n", " *     Option.bind(mightFailB),     // Option<number>\n\t *     Option.defaultWith(() => 0)  // number\n\t * )\n\t * // => 200 if both mightFail functions return `Some`\n\t * // => 0 if either function returns `None`\n\t * ```\n\t */\n\texport const bind = <A extends NonNullish, B extends NonNullish>(\n\t    f: (a: A) => Option<B>\n\t) =>\n", "    match<A, Option<B>>({\n\t        some: f,\n\t        none: none,\n\t    })\n\t/**\n\t * Alias of {@link bind}\n\t *\n\t * @group Mapping\n\t */\n\texport const flatMap = bind\n", "/**\n\t * A type guard determining whether an `Option` instance is a `Some`.\n\t *\n\t * @group Type Guards\n\t *\n\t * @example\n\t * Option.isSome(Option.some(1)) // => true\n\t * Option.isSome(Option.none) // => false\n\t */\n\texport const isSome = <A extends NonNullish>(o: Option<A>): o is Some<A> =>\n", "    o._tag === \"Some\"\n\t/**\n\t * A type guard determining whether an `Option` instance is a `None`.\n\t *\n\t * @group Type Guards\n\t * @example\n\t * Option.isNone(Option.none) // => true\n\t * Option.isNone(Option.some(1)) // => false\n\t */\n\texport const isNone = <A extends NonNullish>(o: Option<A>): o is None => o._tag === \"None\"\n", "/**\n\t * Returns a `Some` containing the value returned from the map function\n\t * if both `Option`s  are `Some`s. Otherwise, returns `None`.\n\t *\n\t * This is a kind of shortcut for pattern matching a tuple of `Option`s.\n\t *\n\t * @group Mapping\n\t * @group Pattern Matching\n\t *\n\t * @example\n", " * pipe(\n\t *     [Option.some(10), Option.some(20)],\n\t *     Option.map2((a, b) => a + b),\n\t *     Option.defaultValue(0)\n\t * ) // => 30\n\t */\n\texport const map2 =\n\t    <A extends NonNullish, B extends NonNullish, C extends NonNullish>(\n\t        map: (a: A, b: B) => C\n\t    ) =>\n", "    (options: readonly [Option<A>, Option<B>]): Option<C> => {\n\t        if (isSome(options[0]) && isSome(options[1])) {\n\t            return some(map(options[0].some, options[1].some))\n\t        }\n\t        return none\n\t    }\n\t/**\n\t * Returns a Some containing the value returned from the map function\n\t * if all three `Option`s are `Some`s. Otherwise, returns `None`.\n\t *\n", " * This is a kind of shortcut for pattern matching a 3-tuple of `Option`s.\n\t *\n\t * @group Mapping\n\t * @group Pattern Matching\n\t *\n\t * @example\n\t * pipe(\n\t *     [Option.some(10), Option.some(20), Option.some(30)],\n\t *     Option.map3((a, b, c) => a + b + c),\n\t *     Option.defaultValue(0)\n", " * ) // => 60\n\t *\n\t * @example\n\t * pipe(\n\t *     [Option.none, Option.some(20), Option.some(30)],\n\t *     Option.map3((a, b, c) => a + b + c),\n\t *     Option.defaultValue(0)\n\t * ) // => 0\n\t */\n\texport const map3 =\n", "    <\n\t        A extends NonNullish,\n\t        B extends NonNullish,\n\t        C extends NonNullish,\n\t        D extends NonNullish\n\t    >(\n\t        map: (a: A, b: B, c: C) => D\n\t    ) =>\n\t    (options: readonly [Option<A>, Option<B>, Option<C>]): Option<D> => {\n\t        if (isSome(options[0]) && isSome(options[1]) && isSome(options[2])) {\n", "            return some(map(options[0].some, options[1].some, options[2].some))\n\t        }\n\t        return none\n\t    }\n\t/**\n\t * Constructs an `Option` from a potentially nullish value.\n\t * Nullish values will result in a `None` instance. Other\n\t * values will result in a `Some` instance containing the\n\t * value now constrained to be `NonNullable`.\n\t *\n", " * @group Constructors\n\t *\n\t * @example\n\t * Option.ofNullish(null) // => Option.none\n\t * Option.ofNullish(undefined) // => Option.none\n\t * Option.ofNullish(1) // => Option.some(1)\n\t */\n\texport const ofNullish = <A>(a: A): Option<NonNullable<A>> => (a != null ? some(a) : none)\n\t/**\n\t * Converts an `Option` to a nullish value. (`null | undefined`)\n", " *\n\t * @group Pattern Matching\n\t *\n\t * @param useNull Defaults to `true`. Specify `false` to use `undefined` instead of `null` for `None`s\n\t */\n\texport const toNullish = <A extends NonNullish>(\n\t    o: Option<A>,\n\t    useNull = true\n\t): A | null | undefined =>\n\t    pipe(\n", "        o,\n\t        match({\n\t            some: a => a,\n\t            none: useNull ? null : undefined,\n\t        })\n\t    )\n\t/**\n\t * Attempt to perform a function that may throw. If the\n\t * function throws, returns `None` and swallows the Error.\n\t *\n", " * @group Error Handling\n\t */\n\texport const tryCatch = <A extends NonNullish>(mightThrow: () => A): Option<A> => {\n\t    try {\n\t        return some(mightThrow())\n\t    } catch (_) {\n\t        return none\n\t    }\n\t}\n\t/**\n", " * Get an `EqualityComparer` for an `Option<A>` by giving this function an\n\t * `EqualityComparer` for type `A`. Represents structural (value-based) equality\n\t * for the `Option` type.\n\t *\n\t * @group Equality\n\t * @group Utils\n\t *\n\t * @param equalityComparer The `EqualityComparer` to use for the inner value.\n\t * @returns A new `EqualityComparer` instance\n\t */\n", "export const getEqualityComparer = <A extends NonNullish>({\n\t    equals,\n\t}: EqualityComparer<A>): EqualityComparer<Option<A>> =>\n\t    // `ofEquals` has a built-in reference equality check, which captures the None/None case\n\t    EqualityComparer.ofEquals((opt1, opt2) =>\n\t        pipe(\n\t            [opt1, opt2] as const,\n\t            map2((a1: A, a2: A) => equals(a1, a2)),\n\t            defaultValue(false)\n\t        )\n", "    )\n\t/**\n\t * Execute an arbitrary side effect using the inner value of the `Option`. Useful\n\t * for debugging and logging purposes. Will not have any effect for `None`s.\n\t *\n\t * @param f The side effect to execute.\n\t *\n\t * @returns The `Option`, unchanged.\n\t *\n\t * @group Utils\n", " */\n\texport const tee =\n\t    <A extends NonNullish>(f: (a: A) => void) =>\n\t    (option: Option<A>) =>\n\t        pipe(\n\t            option,\n\t            map(a => {\n\t                f(a)\n\t                return a\n\t            })\n", "        )\n\t/* c8 ignore start */\n\t/** @ignore */\n\texport const Option = {\n\t    some,\n\t    of,\n\t    none,\n\t    ofNullish,\n\t    toNullish,\n\t    match,\n", "    map,\n\t    map2,\n\t    map3,\n\t    bind,\n\t    flatMap,\n\t    defaultValue,\n\t    defaultWith,\n\t    isSome,\n\t    isNone,\n\t    filter,\n", "    refine,\n\t    tryCatch,\n\t    getEqualityComparer,\n\t    tee,\n\t}\n\t/* c8 ignore end */\n"]}
