{"filename": "comparison/mapperless-UserRepo-embedded-transforms.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\timport { User, UserID } from '@fieldzoo/model';\n\timport { Database } from '../tables/table-interfaces';\n\texport class UserRepo {\n\t  constructor(readonly db: Kysely<Database>) {}\n\t  async add(user: User): Promise<User> {\n\t    const returns = await this.db\n\t      .insertInto('users')\n\t      .values(this.upsertTransform(user))\n\t      .returning(['id', 'createdAt', 'modifiedAt'])\n", "      .executeTakeFirst();\n\t    return User.castFrom({ ...user, ...returns });\n\t  }\n\t  async deleteByID(id: UserID): Promise<boolean> {\n\t    const result = await this.db\n\t      .deleteFrom('users')\n\t      .where('id', '=', id)\n\t      .executeTakeFirst();\n\t    return result.numDeletedRows > 0;\n\t  }\n", "  async getByID(id: UserID): Promise<User | null> {\n\t    const row = await this.db\n\t      .selectFrom('users')\n\t      .selectAll()\n\t      .where('id', '=', id)\n\t      .executeTakeFirst();\n\t    return row ? User.castFrom(row) : null;\n\t  }\n\t  async update(user: User): Promise<boolean> {\n\t    const returns = await this.db\n", "      .updateTable('users')\n\t      .set(this.upsertTransform(user))\n\t      .where('id', '=', user.id)\n\t      .returning(['modifiedAt'])\n\t      .executeTakeFirst();\n\t    if (returns === undefined) {\n\t      return false;\n\t    }\n\t    Object.assign(user, returns) as User;\n\t    return true;\n", "  }\n\t  private upsertTransform(user: User) {\n\t    const values = { ...user } as any;\n\t    delete values['id'];\n\t    delete values['createdAt'];\n\t    delete values['modifiedAt'];\n\t    return values;\n\t  }\n\t}\n"]}
{"filename": "comparison/mapperless-UserRepo-calling-transforms.ts", "chunked_list": ["import { Kysely, Selectable, Selection } from 'kysely';\n\timport { User, UserID } from '@fieldzoo/model';\n\timport { Database, Users } from '../tables/table-interfaces';\n\texport class UserRepo {\n\t  constructor(readonly db: Kysely<Database>) {}\n\t  async add(user: User): Promise<User> {\n\t    const returns = await this.db\n\t      .insertInto('users')\n\t      .values(this.upsertTransform(user))\n\t      .returning(['id', 'createdAt', 'modifiedAt'])\n", "      .executeTakeFirst();\n\t    return this.insertReturnTransform(user, returns!);\n\t  }\n\t  async deleteByID(id: UserID): Promise<boolean> {\n\t    const result = await this.db\n\t      .deleteFrom('users')\n\t      .where('id', '=', id)\n\t      .executeTakeFirst();\n\t    return result.numDeletedRows > 0;\n\t  }\n", "  async getByID(id: UserID): Promise<User | null> {\n\t    const row = await this.db\n\t      .selectFrom('users')\n\t      .selectAll()\n\t      .where('id', '=', id)\n\t      .executeTakeFirst();\n\t    return row ? this.selectTransform(row) : null;\n\t  }\n\t  async update(user: User): Promise<boolean> {\n\t    const returns = await this.db\n", "      .updateTable('users')\n\t      .set(this.upsertTransform(user))\n\t      .where('id', '=', user.id)\n\t      .returning(['modifiedAt'])\n\t      .executeTakeFirst();\n\t    if (returns === undefined) {\n\t      return false;\n\t    }\n\t    this.updateReturnTransform(user, returns!);\n\t    return true;\n", "  }\n\t  private upsertTransform(user: User) {\n\t    const values = { ...user } as any;\n\t    delete values['id'];\n\t    delete values['createdAt'];\n\t    delete values['modifiedAt'];\n\t    return values;\n\t  }\n\t  private insertReturnTransform(\n\t    user: User,\n", "    returns: Selection<Database, 'users', 'id' | 'createdAt' | 'modifiedAt'>\n\t  ) {\n\t    return User.castFrom({ ...user, ...returns });\n\t  }\n\t  private updateReturnTransform(\n\t    user: User,\n\t    returns: Selection<Database, 'users', 'modifiedAt'>\n\t  ) {\n\t    return Object.assign(user, returns) as User;\n\t  }\n", "  private selectTransform(row: Selectable<Users>) {\n\t    return User.castFrom(row);\n\t  }\n\t}\n"]}
{"filename": "comparison/UserRepo-using-mapper.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\timport { TableMapper } from 'kysely-mapper';\n\timport { User, UserID } from '@fieldzoo/model';\n\timport { Database } from '../tables/table-interfaces';\n\texport class UserRepo {\n\t  readonly #table: ReturnType<UserRepo['getMapper']>;\n\t  constructor(readonly db: Kysely<Database>) {\n\t    this.#table = this.getMapper(db);\n\t  }\n\t  async add(user: User): Promise<User> {\n", "    return this.#table.insert().returnOne(user);\n\t  }\n\t  async deleteByID(id: UserID): Promise<boolean> {\n\t    return this.#table.delete(id).run();\n\t  }\n\t  async getByID(id: UserID): Promise<User | null> {\n\t    return this.#table.select(id).returnOne();\n\t  }\n\t  async update(user: User): Promise<boolean> {\n\t    return (await this.#table.update(user.id).returnOne(user)) !== null;\n", "  }\n\t  private getMapper(db: Kysely<Database>) {\n\t    const upsertTransform = (user: User) => {\n\t      const values = { ...user } as any;\n\t      delete values['id'];\n\t      delete values['createdAt'];\n\t      delete values['modifiedAt'];\n\t      return values;\n\t    };\n\t    return new TableMapper(db, 'users', {\n", "      keyColumns: ['id'],\n\t      insertReturnColumns: ['id', 'createdAt', 'modifiedAt'],\n\t      updateReturnColumns: ['modifiedAt'],\n\t    }).withTransforms({\n\t      insertTransform: upsertTransform,\n\t      insertReturnTransform: (user: User, returns) =>\n\t        User.castFrom({ ...user, ...returns }),\n\t      updateTransform: upsertTransform,\n\t      updateReturnTransform: (user: User, returns) =>\n\t        Object.assign(user, returns) as User,\n", "      selectTransform: (row) => User.castFrom(row),\n\t    });\n\t  }\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["export * from './mappers/abstract-table-mapper';\n\texport * from './mappers/table-mapper';\n\texport * from './mappers/table-mapper-settings';\n\texport * from './mappers/table-mapper-transforms';\n\texport * from './mappers/entire-row-transforms';\n\texport * from './lib/query-filter';\n"]}
{"filename": "src/queries/compiling-update-query.ts", "chunked_list": ["import { Kysely, UpdateQueryBuilder, UpdateResult, Updateable } from 'kysely';\n\timport { SelectionColumn } from '../lib/type-utils';\n\timport { CompilingValuesQuery } from './compiling-values-query';\n\timport { ParametersObject } from 'kysely-params';\n\timport {\n\t  CountTransform,\n\t  UpdateTransforms,\n\t} from '../mappers/table-mapper-transforms';\n\t/**\n\t * Compiling mapping query for updating rows in a database table.\n", " */\n\texport class CompilingMappingUpdateQuery<\n\t  DB,\n\t  TB extends keyof DB & string,\n\t  QB extends UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n\t  UpdatingObject,\n\t  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n\t  ReturnCount,\n\t  UpdateReturn,\n\t  Parameters extends ParametersObject<Parameters>\n", "> extends CompilingValuesQuery<\n\t  DB,\n\t  TB,\n\t  QB,\n\t  UpdateReturnColumns,\n\t  Parameters,\n\t  Updateable<DB[TB]>\n\t> {\n\t  constructor(\n\t    db: Kysely<DB>,\n", "    qb: QB,\n\t    protected readonly columnsToUpdate: Readonly<\n\t      (keyof Updateable<DB[TB]> & string)[]\n\t    >,\n\t    protected readonly transforms: Readonly<\n\t      CountTransform<ReturnCount> &\n\t        UpdateTransforms<\n\t          DB,\n\t          TB,\n\t          UpdatingObject,\n", "          UpdateReturnColumns,\n\t          UpdateReturn\n\t        >\n\t    >,\n\t    returnColumns: Readonly<UpdateReturnColumns>\n\t  ) {\n\t    super(db, returnColumns);\n\t    const parameterizedValues = this.getParameterizedObject(columnsToUpdate);\n\t    this.qb = qb.set(parameterizedValues) as QB;\n\t  }\n", "  /**\n\t   * Runs the query, returning the number of rows updated, in the required\n\t   * client representation. Accepts values for any parameters embedded in\n\t   * the query.\n\t   *\n\t   * On the first execution, compiles and discards the underlying Kysely\n\t   * query builder. Subsequent executions reuse the compiled query.\n\t   * @param obj The object which which to update the rows.\n\t   * @returns Number of rows updated, in client-requested representation.\n\t   */\n", "  async returnCount(\n\t    params: Parameters,\n\t    obj: UpdatingObject\n\t  ): Promise<ReturnCount> {\n\t    const transformedObj = this.applyUpdateTransform(obj);\n\t    const compiledQuery = this.instantiateNoReturns(params, transformedObj);\n\t    const result = await this.db.executeQuery(compiledQuery);\n\t    return this.transforms.countTransform === undefined\n\t      ? (result.numAffectedRows as ReturnCount)\n\t      : this.transforms.countTransform(result.numAffectedRows!);\n", "  }\n\t  /**\n\t   * Updates rows with the values that result from transforming the object via\n\t   * `insertTransform` (if defined). For each row updated, retrieves the\n\t   * columns specified in `returnColumns` (if defined), returning them to the\n\t   * caller as an `UpdateReturn`, after transformation by any provided\n\t   * `updateReturnTransform`. If `returnColumns` is empty, returns `undefined`.\n\t   * Accepts values for any parameters embedded in the query.\n\t   *\n\t   * On the first execution, compiles and discards the underlying Kysely\n", "   * query builder. Subsequent executions reuse the compiled query.\n\t   * @returns If `returnColumns` is not empty, returns an array containing one\n\t   *  object for each row updated; otherwise returns `undefined`.\n\t   */\n\t  returnAll(\n\t    params: Parameters,\n\t    obj: UpdatingObject\n\t  ): Promise<UpdateReturnColumns extends [] ? void : UpdateReturn[]>;\n\t  async returnAll(\n\t    params: Parameters,\n", "    obj: UpdatingObject\n\t  ): Promise<UpdateReturn[] | void> {\n\t    if (this.returnColumns.length === 0) {\n\t      await this.run(params, obj as UpdatingObject);\n\t      return;\n\t    }\n\t    const transformedObj = this.applyUpdateTransform(obj as UpdatingObject);\n\t    const compiledQuery = this.instantiateWithReturns(params, transformedObj);\n\t    const result = await this.db.executeQuery(compiledQuery);\n\t    return this.transforms.updateReturnTransform === undefined\n", "      ? (result.rows as any)\n\t      : result.rows.map((row) =>\n\t          this.applyUpdateReturnTransform(obj as UpdatingObject, row as any)\n\t        );\n\t  }\n\t  /**\n\t   * Updates rows with the values that result from transforming the object via\n\t   * `updateTransform` (if defined). For the first row updated, retrieves the\n\t   * columns specified in `returnColumns` (if defined), returning them to the\n\t   * caller as an `UpdateReturn`, after transformation by any provided\n", "   * `updateReturnTransform`. If `returnColumns` is empty, returns `undefined`.\n\t   * Accepts values for any parameters embedded in the query.\n\t   *\n\t   * On the first execution, compiles and discards the underlying Kysely\n\t   * query builder. Subsequent executions reuse the compiled query.\n\t   * @returns If `returnColumns` is empty, returns `undefined`. Otherwise,\n\t   *  returns the first object if at least one row was updated, or `null` if\n\t   *  no rows were updated.\n\t   */\n\t  returnOne(\n", "    params: Parameters,\n\t    obj: UpdatingObject\n\t  ): Promise<UpdateReturnColumns extends [] ? void : UpdateReturn | null>;\n\t  async returnOne(\n\t    params: Parameters,\n\t    obj: UpdatingObject\n\t  ): Promise<UpdateReturn | null | void> {\n\t    if (this.returnColumns.length === 0) {\n\t      await this.run(params, obj as UpdatingObject);\n\t      return;\n", "    }\n\t    const transformedObj = this.applyUpdateTransform(obj as UpdatingObject);\n\t    const compiledQuery = this.instantiateWithReturns(params, transformedObj);\n\t    const result = await this.db.executeQuery(compiledQuery);\n\t    if (result.rows.length === 0) {\n\t      return null;\n\t    }\n\t    return this.applyUpdateReturnTransform(\n\t      obj as UpdatingObject,\n\t      result.rows[0] as any\n", "    );\n\t  }\n\t  /**\n\t   * Runs the query, updating rows, without returning any columns. Accepts\n\t   * values for any parameters embedded in the query.\n\t   *\n\t   * On the first execution, compiles and discards the underlying Kysely\n\t   * query builder. Subsequent executions reuse the compiled query.\n\t   * @param obj The object which which to update the rows.\n\t   * @returns `true` if any rows were updated, `false` otherwise.\n", "   */\n\t  async run(params: Parameters, obj: UpdatingObject): Promise<boolean> {\n\t    return (await this.returnCount(params, obj)) !== 0;\n\t  }\n\t  protected applyUpdateTransform(obj: UpdatingObject): Updateable<DB[TB]> {\n\t    return this.transforms.updateTransform === undefined\n\t      ? (obj as Updateable<DB[TB]>)\n\t      : this.transforms.updateTransform(obj, this.columnsToUpdate);\n\t  }\n\t  protected applyUpdateReturnTransform(source: UpdatingObject, returns: any) {\n", "    return this.transforms.updateReturnTransform === undefined\n\t      ? (returns as any)\n\t      : this.transforms.updateReturnTransform(source, returns);\n\t  }\n\t}\n"]}
{"filename": "src/queries/delete-query.ts", "chunked_list": ["import { DeleteQueryBuilder, DeleteResult, Kysely } from 'kysely';\n\timport { ParameterizableMappingQuery } from './parameterizable-query';\n\timport { ParametersObject } from 'kysely-params';\n\timport { CompilingMappingDeleteQuery } from './compiling-delete-query';\n\timport { CountTransform } from '../mappers/table-mapper-transforms';\n\t/**\n\t * Mapping query for deleting rows from a database table.\n\t */\n\texport class MappingDeleteQuery<\n\t  DB,\n", "  TB extends keyof DB & string,\n\t  QB extends DeleteQueryBuilder<DB, TB, DeleteResult>,\n\t  ReturnCount\n\t> implements ParameterizableMappingQuery\n\t{\n\t  constructor(\n\t    protected readonly db: Kysely<DB>,\n\t    protected readonly qb: QB,\n\t    protected readonly transforms: Readonly<CountTransform<ReturnCount>>\n\t  ) {}\n", "  /**\n\t   * Returns a compiling query that can be executed multiple times with\n\t   * different parameters (if any parameters were provided), but which only\n\t   * compiles the underlying Kysely query builder on the first execution.\n\t   * Frees the query builder on the first execution to reduce memory usage.\n\t   * @typeParam Parameters Record characterizing the parameter names and\n\t   *  types that were previously embedded in the query, if any.\n\t   * @returns A compiling delete query.\n\t   */\n\t  compile<\n", "    Parameters extends ParametersObject<Parameters> = {}\n\t  >(): CompilingMappingDeleteQuery<DB, TB, QB, ReturnCount, Parameters> {\n\t    return new CompilingMappingDeleteQuery(this.db, this.qb, this.transforms);\n\t  }\n\t  /**\n\t   * Runs the query, returning the number of rows deleted, converted to\n\t   * the required client representation.\n\t   * @returns Number of rows deleted, in client-requested representation.\n\t   */\n\t  async returnCount(): Promise<ReturnCount> {\n", "    const result = await this.qb.executeTakeFirst();\n\t    return this.transforms.countTransform === undefined\n\t      ? (result.numDeletedRows as ReturnCount)\n\t      : this.transforms.countTransform(result.numDeletedRows);\n\t  }\n\t  /**\n\t   * Modifies the underlying Kysely query builder.\n\t   * @param factory A function that takes the current query builder and\n\t   *  returns a new query builder.\n\t   */\n", "  modify<NextQB extends DeleteQueryBuilder<DB, any, DeleteResult>>(\n\t    factory: (qb: QB) => NextQB\n\t  ): MappingDeleteQuery<DB, TB, NextQB, ReturnCount> {\n\t    return new MappingDeleteQuery(this.db, factory(this.qb), this.transforms);\n\t  }\n\t  /**\n\t   * Runs the query, deleting the indicated rows, returning nothing.\n\t   * @returns `true` if any rows were deleted, `false` otherwise.\n\t   */\n\t  async run(): Promise<boolean> {\n", "    const results = await this.qb.executeTakeFirst();\n\t    return results.numDeletedRows !== BigInt(0);\n\t  }\n\t}\n"]}
{"filename": "src/queries/compiling-delete-query.ts", "chunked_list": ["import { DeleteQueryBuilder, Kysely, QueryResult } from 'kysely';\n\timport { ParameterizedQuery, ParametersObject } from 'kysely-params';\n\timport { CountTransform } from '../mappers/table-mapper-transforms';\n\timport { ParameterizableMappingQuery } from './parameterizable-query';\n\t/**\n\t * Compiling mapping query for deleting rows from a database table.\n\t */\n\texport class CompilingMappingDeleteQuery<\n\t  DB,\n\t  TB extends keyof DB & string,\n", "  QB extends DeleteQueryBuilder<DB, TB, any>,\n\t  ReturnCount,\n\t  Parameters extends ParametersObject<Parameters>\n\t> implements ParameterizableMappingQuery\n\t{\n\t  #parameterizedQuery: ParameterizedQuery<Parameters, QueryResult<any>>;\n\t  constructor(\n\t    protected readonly db: Kysely<DB>,\n\t    protected readonly qb: QB,\n\t    protected readonly transforms: Readonly<CountTransform<ReturnCount>>\n", "  ) {\n\t    this.#parameterizedQuery = new ParameterizedQuery(qb);\n\t  }\n\t  /**\n\t   * Runs the query, returning the number of rows deleted, converted to\n\t   * the required client representation. Accepts values for any parameters\n\t   * embedded in the query.\n\t   *\n\t   * On the first execution, compiles and discards the underlying Kysely\n\t   * query builder. Subsequent executions reuse the compiled query.\n", "   * @param params Record characterizing the parameter names and types.\n\t   *  Pass in `{}` if the query has no parameters.\n\t   * @returns Number of rows deleted, in client-requested representation.\n\t   */\n\t  async returnCount(params: Parameters): Promise<ReturnCount> {\n\t    const result = await this.#parameterizedQuery.execute(this.db, params);\n\t    return this.transforms.countTransform === undefined\n\t      ? (result.numAffectedRows! as ReturnCount)\n\t      : this.transforms.countTransform(result.numAffectedRows!);\n\t  }\n", "  /**\n\t   * Runs the query, deleting the indicated rows, returning nothing.\n\t   * Accepts values for any parameters embedded in the query.\n\t   *\n\t   * On the first execution, compiles and discards the underlying Kysely\n\t   * query builder. Subsequent executions reuse the compiled query.\n\t   * @param params Record characterizing the parameter names and types.\n\t   *  Pass in `{}` if the query has no parameters.\n\t   * @returns `true` if any rows were deleted, `false` otherwise.\n\t   */\n", "  async run(params: Parameters): Promise<boolean> {\n\t    const results = await this.#parameterizedQuery.execute(this.db, params);\n\t    return results.numAffectedRows !== BigInt(0);\n\t  }\n\t}\n"]}
{"filename": "src/queries/parameterizable-query.ts", "chunked_list": ["/**\n\t * Interface tagging a query as parameterizable. When parameterizing a query,\n\t * the caller provides a function that must return a query having this tag.\n\t */\n\texport interface ParameterizableMappingQuery {}\n"]}
{"filename": "src/queries/subsetting-update-query.ts", "chunked_list": ["import { Kysely, UpdateQueryBuilder, UpdateResult, Updateable } from 'kysely';\n\timport { SelectionColumn } from '../lib/type-utils';\n\timport { MappingUpdateQuery } from './update-query';\n\timport { ParameterizableMappingQuery } from './parameterizable-query';\n\timport { ParametersObject } from 'kysely-params';\n\timport { CompilingMappingUpdateQuery } from './compiling-update-query';\n\timport {\n\t  CountTransform,\n\t  UpdateTransforms,\n\t} from '../mappers/table-mapper-transforms';\n", "import { restrictValues } from '../lib/restrict-values';\n\t/**\n\t * Mapping query for updating rows into a database table,\n\t * updating a specified subset of the updateable columns.\n\t */\n\texport class SubsettingMappingUpdateQuery<\n\t    DB,\n\t    TB extends keyof DB & string,\n\t    QB extends UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n\t    UpdatingObject,\n", "    UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n\t    ReturnCount,\n\t    UpdateReturn\n\t  >\n\t  extends MappingUpdateQuery<\n\t    DB,\n\t    TB,\n\t    QB,\n\t    UpdatingObject,\n\t    UpdateReturnColumns,\n", "    ReturnCount,\n\t    UpdateReturn\n\t  >\n\t  implements ParameterizableMappingQuery\n\t{\n\t  constructor(\n\t    db: Kysely<DB>,\n\t    qb: QB,\n\t    protected readonly columnsToUpdate: Readonly<\n\t      (keyof Updateable<DB[TB]> & string)[]\n", "    >,\n\t    transforms: Readonly<\n\t      CountTransform<ReturnCount> &\n\t        UpdateTransforms<\n\t          DB,\n\t          TB,\n\t          UpdatingObject,\n\t          UpdateReturnColumns,\n\t          UpdateReturn\n\t        >\n", "    >,\n\t    returnColumns: Readonly<UpdateReturnColumns>\n\t  ) {\n\t    super(db, qb, transforms, returnColumns);\n\t  }\n\t  /**\n\t   * Returns a compiling query that can be executed multiple times with\n\t   * different parameters (if any parameters were provided), but which only\n\t   * compiles the underlying Kysely query builder on the first execution.\n\t   * Frees the query builder on the first execution to reduce memory usage.\n", "   * @typeParam Parameters Record characterizing the parameter names and\n\t   *  types that were previously embedded in the query, if any.\n\t   * @returns A compiling update query.\n\t   */\n\t  compile<\n\t    Parameters extends ParametersObject<Parameters> = {}\n\t  >(): CompilingMappingUpdateQuery<\n\t    DB,\n\t    TB,\n\t    QB,\n", "    UpdatingObject,\n\t    UpdateReturnColumns,\n\t    ReturnCount,\n\t    UpdateReturn,\n\t    Parameters\n\t  > {\n\t    return new CompilingMappingUpdateQuery(\n\t      this.db,\n\t      this.qb,\n\t      this.columnsToUpdate,\n", "      this.transforms,\n\t      this.returnColumns\n\t    );\n\t  }\n\t  protected override getUpdateColumns():\n\t    | Readonly<(keyof Updateable<DB[TB]> & string)[]>\n\t    | ['*'] {\n\t    return this.columnsToUpdate;\n\t  }\n\t  protected override setColumnValues(\n", "    qb: UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n\t    obj: Updateable<DB[TB]>\n\t  ): UpdateQueryBuilder<DB, TB, TB, UpdateResult> {\n\t    return qb.set(restrictValues(obj, this.columnsToUpdate));\n\t  }\n\t}\n"]}
{"filename": "src/queries/any-update-query.ts", "chunked_list": ["import { Kysely, UpdateQueryBuilder, UpdateResult, Updateable } from 'kysely';\n\timport { SelectionColumn } from '../lib/type-utils';\n\timport { MappingUpdateQuery } from './update-query';\n\timport { SubsettingMappingUpdateQuery } from './subsetting-update-query';\n\timport {\n\t  CountTransform,\n\t  UpdateTransforms,\n\t} from '../mappers/table-mapper-transforms';\n\t/**\n\t * Mapping query for updating rows from a database table, where the\n", " * columns to be updated have not been restricted.\n\t */\n\texport class AnyColumnsMappingUpdateQuery<\n\t  DB,\n\t  TB extends keyof DB & string,\n\t  QB extends UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n\t  UpdatingObject,\n\t  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n\t  ReturnCount,\n\t  UpdateReturn\n", "> extends MappingUpdateQuery<\n\t  DB,\n\t  TB,\n\t  QB,\n\t  UpdatingObject,\n\t  UpdateReturnColumns,\n\t  ReturnCount,\n\t  UpdateReturn\n\t> {\n\t  constructor(\n", "    db: Kysely<DB>,\n\t    qb: QB,\n\t    transforms: Readonly<\n\t      CountTransform<ReturnCount> &\n\t        UpdateTransforms<\n\t          DB,\n\t          TB,\n\t          UpdatingObject,\n\t          UpdateReturnColumns,\n\t          UpdateReturn\n", "        >\n\t    >,\n\t    returnColumns: Readonly<UpdateReturnColumns>\n\t  ) {\n\t    super(db, qb, transforms, returnColumns);\n\t  }\n\t  /**\n\t   * Returns a mapping query that only updates a specified subset of columns.\n\t   * @param columns The columns to update. All are required, but this\n\t   *  constraint is only enforced at runtime, not by the type system.\n", "   * @returns A mapping query that only updates the specified columns.\n\t   */\n\t  columns(\n\t    columnsToUpdate: Readonly<(keyof Updateable<DB[TB]> & string)[]>\n\t  ): SubsettingMappingUpdateQuery<\n\t    DB,\n\t    TB,\n\t    QB,\n\t    UpdatingObject,\n\t    UpdateReturnColumns,\n", "    ReturnCount,\n\t    UpdateReturn\n\t  > {\n\t    return new SubsettingMappingUpdateQuery(\n\t      this.db,\n\t      this.qb,\n\t      columnsToUpdate,\n\t      this.transforms,\n\t      this.returnColumns\n\t    );\n", "  }\n\t}\n"]}
{"filename": "src/queries/update-query.ts", "chunked_list": ["import {\n\t  Kysely,\n\t  Selectable,\n\t  UpdateQueryBuilder,\n\t  UpdateResult,\n\t  Updateable,\n\t} from 'kysely';\n\timport { SelectionColumn } from '../lib/type-utils';\n\timport {\n\t  CountTransform,\n", "  UpdateTransforms,\n\t} from '../mappers/table-mapper-transforms';\n\t/**\n\t * Mapping query for updating rows from a database table.\n\t */\n\texport class MappingUpdateQuery<\n\t  DB,\n\t  TB extends keyof DB & string,\n\t  QB extends UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n\t  UpdatingObject,\n", "  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n\t  ReturnCount,\n\t  UpdateReturn\n\t> {\n\t  #returningQB: UpdateQueryBuilder<DB, TB, TB, any> | null = null;\n\t  constructor(\n\t    readonly db: Kysely<DB>,\n\t    readonly qb: QB,\n\t    protected readonly transforms: Readonly<\n\t      CountTransform<ReturnCount> &\n", "        UpdateTransforms<\n\t          DB,\n\t          TB,\n\t          UpdatingObject,\n\t          UpdateReturnColumns,\n\t          UpdateReturn\n\t        >\n\t    >,\n\t    protected readonly returnColumns: Readonly<UpdateReturnColumns>\n\t  ) {}\n", "  /**\n\t   * Modifies the underlying Kysely query builder.\n\t   * @param factory A function that takes the current query builder and\n\t   *  returns a new query builder.\n\t   */\n\t  modify<NextQB extends UpdateQueryBuilder<DB, TB, TB, any>>(\n\t    factory: (qb: QB) => NextQB\n\t  ): MappingUpdateQuery<\n\t    DB,\n\t    TB,\n", "    NextQB,\n\t    UpdatingObject,\n\t    UpdateReturnColumns,\n\t    ReturnCount,\n\t    UpdateReturn\n\t  > {\n\t    return new MappingUpdateQuery(\n\t      this.db,\n\t      factory(this.qb),\n\t      this.transforms,\n", "      this.returnColumns\n\t    );\n\t  }\n\t  /**\n\t   * Runs the query, returning the number of rows updated, in\n\t   * the required client representation.\n\t   * @param obj The object which which to update the rows.\n\t   * @returns Number of rows updated, in client-requested representation.\n\t   */\n\t  async returnCount(obj: UpdatingObject): Promise<ReturnCount> {\n", "    const result = await this.loadUpdatingObject(\n\t      this.qb,\n\t      obj\n\t    ).executeTakeFirst();\n\t    return this.transforms.countTransform === undefined\n\t      ? (result.numUpdatedRows as ReturnCount)\n\t      : this.transforms.countTransform(result.numUpdatedRows);\n\t  }\n\t  /**\n\t   * Updates rows with the values that result from transforming the object via\n", "   * `updateTransform` (if defined). For each row updated, retrieves the\n\t   * columns specified in `returnColumns` (if defined), returning them to the\n\t   * caller as an `UpdateReturn`, after transformation by any provided\n\t   * `updateReturnTransform`. If `returnColumns` is empty, returns `undefined`.\n\t   * @returns If `returnColumns` is not empty, returns an array containing one\n\t   *  object for each row updated; otherwise returns `undefined`.\n\t   */\n\t  returnAll(\n\t    obj: UpdatingObject\n\t  ): Promise<UpdateReturnColumns extends [] ? void : UpdateReturn[]>;\n", "  async returnAll(obj: UpdatingObject): Promise<UpdateReturn[] | void> {\n\t    if (this.returnColumns.length === 0) {\n\t      await this.loadUpdatingObject(this.qb, obj as UpdatingObject).execute();\n\t      return;\n\t    }\n\t    const returns = await this.loadUpdatingObject(\n\t      this.getReturningQB(),\n\t      obj as UpdatingObject\n\t    ).execute();\n\t    return this.transforms.updateReturnTransform === undefined\n", "      ? (returns as any)\n\t      : returns.map((row) =>\n\t          this.transforms.updateReturnTransform!(\n\t            obj as UpdatingObject,\n\t            row as any\n\t          )\n\t        );\n\t  }\n\t  /**\n\t   * Updates rows with the values that result from transforming the object via\n", "   * `updateTransform` (if defined). For the first row updated, retrieves the\n\t   * columns specified in `returnColumns` (if defined), returning them to the\n\t   * caller as an `UpdateReturn`, after transformation by any provided\n\t   * `updateReturnTransform`. If `returnColumns` is empty, returns `undefined`.\n\t   * @returns If `returnColumns` is empty, returns `undefined`. Otherwise,\n\t   *  returns the first object if at least one row was updated, or `null` if\n\t   *  no rows were updated.\n\t   */\n\t  returnOne(\n\t    obj: UpdatingObject\n", "  ): Promise<UpdateReturnColumns extends [] ? void : UpdateReturn | null>;\n\t  async returnOne(obj: UpdatingObject): Promise<UpdateReturn | null | void> {\n\t    if (this.returnColumns.length === 0) {\n\t      await this.loadUpdatingObject(this.qb, obj as UpdatingObject).execute();\n\t      return;\n\t    }\n\t    const returns = await this.loadUpdatingObject(\n\t      this.getReturningQB(),\n\t      obj as UpdatingObject\n\t    ).execute();\n", "    if (returns.length === 0) {\n\t      return null;\n\t    }\n\t    return this.transforms.updateReturnTransform === undefined\n\t      ? (returns[0] as any)\n\t      : this.transforms.updateReturnTransform!(\n\t          obj as UpdatingObject,\n\t          returns[0] as any\n\t        );\n\t  }\n", "  /**\n\t   * Runs the query, updating rows, without returning any columns.\n\t   * @param obj The object which which to update the rows.\n\t   * @returns `true` if any rows were updated, `false` otherwise.\n\t   */\n\t  async run(obj: UpdatingObject): Promise<boolean> {\n\t    const results = await this.loadUpdatingObject(\n\t      this.qb,\n\t      obj\n\t    ).executeTakeFirst();\n", "    return results.numUpdatedRows !== BigInt(0);\n\t  }\n\t  /**\n\t   * Returns an array of the columns to be updated, with\n\t   * `['*']` indicating that all columns will be updated.\n\t   * @returns An array of the columns to be updated.\n\t   */\n\t  protected getUpdateColumns():\n\t    | Readonly<(keyof Updateable<DB[TB]> & string)[]>\n\t    | ['*'] {\n", "    return ['*'];\n\t  }\n\t  /**\n\t   * Returns a query builder for updating rows in the table and\n\t   * returning values, caching the query builder for future use.\n\t   * @returns A query builder for updating rows in the table and\n\t   *  returning values.\n\t   */\n\t  protected getReturningQB(): UpdateQueryBuilder<DB, TB, TB, any> {\n\t    if (this.#returningQB === null) {\n", "      this.#returningQB =\n\t        this.returnColumns[0 as number] == '*'\n\t          ? this.qb.returningAll()\n\t          : this.qb.returning(\n\t              this.returnColumns as Readonly<\n\t                (keyof Selectable<DB[TB]> & string)[]\n\t              >\n\t            );\n\t    }\n\t    return this.#returningQB;\n", "  }\n\t  /**\n\t   * Loads the object with which to update rows.\n\t   * @param qb The query builder to load the objects into.\n\t   * @param obj The object with which to update rows.\n\t   * @returns The query builder with the object loaded.\n\t   */\n\t  protected loadUpdatingObject(\n\t    qb: UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n\t    obj: UpdatingObject\n", "  ): UpdateQueryBuilder<DB, TB, TB, UpdateResult> {\n\t    const updateColumns = this.getUpdateColumns();\n\t    const transformedObj =\n\t      this.transforms.updateTransform === undefined\n\t        ? (obj as Updateable<DB[TB]>)\n\t        : this.transforms.updateTransform(obj, updateColumns);\n\t    return this.setColumnValues(qb, transformedObj);\n\t  }\n\t  /**\n\t   * Sets the values of the updated columns.\n", "   * @param qb The query builder to set the values into.\n\t   * @param obj The object of column-value pairs to be updated.\n\t   */\n\t  protected setColumnValues(\n\t    qb: UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n\t    obj: Updateable<DB[TB]>\n\t  ): UpdateQueryBuilder<DB, TB, TB, UpdateResult> {\n\t    return qb.set(obj);\n\t  }\n\t}\n"]}
{"filename": "src/queries/insert-query.ts", "chunked_list": ["import {\n\t  Kysely,\n\t  InsertQueryBuilder,\n\t  InsertResult,\n\t  Selectable,\n\t  Insertable,\n\t} from 'kysely';\n\timport { SelectionColumn } from '../lib/type-utils';\n\timport { InsertTransforms } from '../mappers/table-mapper-transforms';\n\t/**\n", " * Mapping query for inserting rows into a database table.\n\t */\n\texport class MappingInsertQuery<\n\t  DB,\n\t  TB extends keyof DB & string,\n\t  QB extends InsertQueryBuilder<DB, TB, InsertResult>,\n\t  InsertedObject,\n\t  InsertReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n\t  InsertReturn\n\t> {\n", "  #returningQB: InsertQueryBuilder<DB, TB, any> | null = null;\n\t  constructor(\n\t    protected readonly db: Kysely<DB>,\n\t    protected readonly qb: QB,\n\t    protected readonly transforms: Readonly<\n\t      InsertTransforms<\n\t        DB,\n\t        TB,\n\t        InsertedObject,\n\t        InsertReturnColumns,\n", "        InsertReturn\n\t      >\n\t    >,\n\t    protected readonly returnColumns: Readonly<InsertReturnColumns>\n\t  ) {}\n\t  /**\n\t   * Modifies the underlying Kysely query builder.\n\t   * @param factory A function that takes the current query builder and\n\t   *  returns a new query builder.\n\t   */\n", "  modify<NextQB extends InsertQueryBuilder<DB, TB, any>>(\n\t    factory: (qb: QB) => NextQB\n\t  ): MappingInsertQuery<\n\t    DB,\n\t    TB,\n\t    NextQB,\n\t    InsertedObject,\n\t    InsertReturnColumns,\n\t    InsertReturn\n\t  > {\n", "    return new MappingInsertQuery(\n\t      this.db,\n\t      factory(this.qb),\n\t      this.transforms,\n\t      this.returnColumns\n\t    );\n\t  }\n\t  /**\n\t   * Inserts the provided objects into the table as rows, first transforming\n\t   * them into rows via `insertTransform` (if defined). For each row inserted,\n", "   * retrieves the columns specified in `returnColumns`, returning them to\n\t   * the caller as `InsertReturn`, after transformation by\n\t   * `insertReturnTransform`. If `returnColumns` is empty, returns `undefined`.\n\t   * @returns If `returnColumns` is not empty, returns an array containing one\n\t   *  object for each inserted object; otherwise returns `undefined`.\n\t   */\n\t  returnAll(\n\t    objs: InsertedObject[]\n\t  ): Promise<InsertReturnColumns extends [] ? void : InsertReturn[]>;\n\t  async returnAll(objs: InsertedObject[]): Promise<InsertReturn[] | void> {\n", "    if (this.returnColumns.length === 0) {\n\t      await this.loadInsertedObjects(this.qb, objs).execute();\n\t      return;\n\t    }\n\t    const returns = await this.loadInsertedObjects(\n\t      this.getReturningQB(),\n\t      objs\n\t    ).execute();\n\t    return this.transforms.insertReturnTransform === undefined\n\t      ? (returns as any)\n", "      : returns.map((row, i) =>\n\t          this.transforms.insertReturnTransform!(objs[i], row as any)\n\t        );\n\t  }\n\t  /**\n\t   * Inserts the provided object into the table as a row, first transforming\n\t   * it into a row via `insertTransform` (if defined). Also retrieves the\n\t   * columns specified in `returnColumns`, returning them to the caller as\n\t   * `InsertReturn`, after transformation by `insertReturnTransform`.\n\t   * If `returnColumns` is empty, returns `undefined`.\n", "   * @returns If `returnColumns` is not empty, returns an object;\n\t   *  otherwise returns `undefined`.\n\t   */\n\t  returnOne(\n\t    obj: InsertedObject\n\t  ): Promise<InsertReturnColumns extends [] ? void : InsertReturn>;\n\t  async returnOne(obj: InsertedObject): Promise<InsertReturn | void> {\n\t    if (this.returnColumns.length === 0) {\n\t      await this.loadInsertedObjects(this.qb, obj).execute();\n\t      return;\n", "    }\n\t    const result = await this.loadInsertedObjects(\n\t      this.getReturningQB(),\n\t      obj\n\t    ).executeTakeFirst();\n\t    return this.transforms.insertReturnTransform === undefined\n\t      ? (result as any)\n\t      : this.transforms.insertReturnTransform(obj, result as any);\n\t  }\n\t  /**\n", "   * Runs the query, inserting rows into the table without returning any columns.\n\t   * @param objOrObjs The object or objects to be inserted.\n\t   * @returns Returns `true`; throws an exception on error.\n\t   */\n\t  async run(objOrObjs: InsertedObject | InsertedObject[]): Promise<boolean> {\n\t    await this.loadInsertedObjects(this.qb, objOrObjs).execute();\n\t    return true;\n\t  }\n\t  /**\n\t   * Returns an array of the columns to be inserted, with\n", "   * `['*']` indicating that all columns will be inserted.\n\t   * @returns An array of the columns to be inserted.\n\t   */\n\t  protected getInsertColumns():\n\t    | Readonly<(keyof Insertable<DB[TB]> & string)[]>\n\t    | ['*'] {\n\t    return ['*'];\n\t  }\n\t  /**\n\t   * Returns a query builder for inserting rows into the table and\n", "   * returning values, caching the query builder for future use.\n\t   * @returns A query builder for inserting rows into the table and\n\t   *  returning values.\n\t   */\n\t  protected getReturningQB(): InsertQueryBuilder<DB, TB, any> {\n\t    if (this.#returningQB === null) {\n\t      this.#returningQB =\n\t        this.returnColumns[0 as number] == '*'\n\t          ? this.qb.returningAll()\n\t          : this.qb.returning(\n", "              this.returnColumns as Readonly<\n\t                (keyof Selectable<DB[TB]> & string)[]\n\t              >\n\t            );\n\t    }\n\t    return this.#returningQB;\n\t  }\n\t  /**\n\t   * Loads the objects to be inserted into the query builder.\n\t   * @param qb The query builder to load the objects into.\n", "   * @param objOrObjs The object or objects to be inserted.\n\t   * @returns The query builder with the objects loaded.\n\t   */\n\t  protected loadInsertedObjects(\n\t    qb: InsertQueryBuilder<DB, TB, InsertResult>,\n\t    objOrObjs: InsertedObject | InsertedObject[]\n\t  ): InsertQueryBuilder<DB, TB, InsertResult> {\n\t    const insertColumns = this.getInsertColumns();\n\t    if (Array.isArray(objOrObjs)) {\n\t      const transformedObjs =\n", "        this.transforms.insertTransform === undefined\n\t          ? (objOrObjs as Insertable<DB[TB]>[])\n\t          : objOrObjs.map((obj) =>\n\t              this.transforms.insertTransform!(obj, insertColumns)\n\t            );\n\t      // TS requires separate calls to values() for different arg types.\n\t      return this.setColumnValues(qb, transformedObjs);\n\t    }\n\t    const transformedObj =\n\t      this.transforms.insertTransform === undefined\n", "        ? (objOrObjs as Insertable<DB[TB]>)\n\t        : this.transforms.insertTransform(objOrObjs, insertColumns);\n\t    // TS requires separate calls to values() for different arg types.\n\t    return this.setColumnValues(qb, transformedObj);\n\t  }\n\t  /**\n\t   * Sets the values of the inserted columns.\n\t   * @param qb The query builder to set the values into.\n\t   * @param objOrObjs The object or objects of column-value pairs\n\t   *  to be inserted.\n", "   */\n\t  protected setColumnValues(\n\t    qb: InsertQueryBuilder<DB, TB, InsertResult>,\n\t    objOrObjs: Insertable<DB[TB]> | Insertable<DB[TB]>[]\n\t  ): InsertQueryBuilder<DB, TB, InsertResult> {\n\t    return qb.values(objOrObjs);\n\t  }\n\t}\n"]}
{"filename": "src/queries/subsetting-insert-query.ts", "chunked_list": ["import { Kysely, InsertQueryBuilder, InsertResult, Insertable } from 'kysely';\n\timport { SelectionColumn } from '../lib/type-utils';\n\timport { MappingInsertQuery } from './insert-query';\n\timport { CompilingMappingInsertQuery } from './compiling-insert-query';\n\timport { InsertTransforms } from '../mappers/table-mapper-transforms';\n\timport { restrictValues } from '../lib/restrict-values';\n\t/**\n\t * Mapping query for inserting rows into a database table,\n\t * inserting a specified subset of the insertable columns.\n\t */\n", "export class SubsettingMappingInsertQuery<\n\t  DB,\n\t  TB extends keyof DB & string,\n\t  QB extends InsertQueryBuilder<DB, TB, InsertResult>,\n\t  InsertedObject,\n\t  InsertReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n\t  InsertReturn\n\t> extends MappingInsertQuery<\n\t  DB,\n\t  TB,\n", "  QB,\n\t  InsertedObject,\n\t  InsertReturnColumns,\n\t  InsertReturn\n\t> {\n\t  constructor(\n\t    db: Kysely<DB>,\n\t    qb: QB,\n\t    protected readonly columnsToInsert: Readonly<\n\t      (keyof Insertable<DB[TB]> & string)[]\n", "    >,\n\t    transforms: Readonly<\n\t      InsertTransforms<\n\t        DB,\n\t        TB,\n\t        InsertedObject,\n\t        InsertReturnColumns,\n\t        InsertReturn\n\t      >\n\t    >,\n", "    returnColumns: Readonly<InsertReturnColumns>\n\t  ) {\n\t    super(db, qb, transforms, returnColumns);\n\t  }\n\t  /**\n\t   * Returns a compiling query that can be executed multiple times with\n\t   * different parameters (if any parameters were provided), but which only\n\t   * compiles the underlying Kysely query builder on the first execution.\n\t   * Frees the query builder on the first execution to reduce memory usage.\n\t   * @typeParam Parameters Record characterizing the parameter names and\n", "   *  types that were previously embedded in the query, if any.\n\t   * @returns A compiling insert query.\n\t   */\n\t  compile(): CompilingMappingInsertQuery<\n\t    DB,\n\t    TB,\n\t    QB,\n\t    InsertedObject,\n\t    InsertReturnColumns,\n\t    InsertReturn\n", "  > {\n\t    return new CompilingMappingInsertQuery(\n\t      this.db,\n\t      this.qb,\n\t      this.columnsToInsert,\n\t      this.transforms,\n\t      this.returnColumns\n\t    );\n\t  }\n\t  protected override getInsertColumns():\n", "    | Readonly<(keyof Insertable<DB[TB]> & string)[]>\n\t    | ['*'] {\n\t    return this.columnsToInsert;\n\t  }\n\t  protected override setColumnValues(\n\t    qb: InsertQueryBuilder<DB, TB, InsertResult>,\n\t    objOrObjs: Insertable<DB[TB]> | Insertable<DB[TB]>[]\n\t  ): InsertQueryBuilder<DB, TB, InsertResult> {\n\t    if (Array.isArray(objOrObjs)) {\n\t      return qb.values(\n", "        objOrObjs.map((obj) => restrictValues(obj, this.columnsToInsert))\n\t      );\n\t    }\n\t    return qb.values(restrictValues(objOrObjs, this.columnsToInsert));\n\t  }\n\t}\n"]}
{"filename": "src/queries/compiling-insert-query.ts", "chunked_list": ["import { Kysely, InsertQueryBuilder, Insertable } from 'kysely';\n\timport { SelectionColumn } from '../lib/type-utils';\n\timport { CompilingValuesQuery } from './compiling-values-query';\n\timport { InsertTransforms } from '../mappers/table-mapper-transforms';\n\t/**\n\t * Compiling mapping query for inserting rows into a database table.\n\t */\n\texport class CompilingMappingInsertQuery<\n\t  DB,\n\t  TB extends keyof DB & string,\n", "  QB extends InsertQueryBuilder<DB, TB, any>,\n\t  InsertedObject,\n\t  InsertReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n\t  InsertReturn\n\t> extends CompilingValuesQuery<\n\t  DB,\n\t  TB,\n\t  QB,\n\t  InsertReturnColumns,\n\t  {},\n", "  Insertable<DB[TB]>\n\t> {\n\t  constructor(\n\t    db: Kysely<DB>,\n\t    qb: QB,\n\t    protected readonly columnsToInsert: Readonly<\n\t      (keyof Insertable<DB[TB]> & string)[]\n\t    >,\n\t    protected readonly transforms: Readonly<\n\t      InsertTransforms<\n", "        DB,\n\t        TB,\n\t        InsertedObject,\n\t        InsertReturnColumns,\n\t        InsertReturn\n\t      >\n\t    >,\n\t    returnColumns: Readonly<InsertReturnColumns>\n\t  ) {\n\t    super(db, returnColumns);\n", "    const parameterizedValues = this.getParameterizedObject(columnsToInsert);\n\t    this.qb = qb.values(parameterizedValues) as QB;\n\t  }\n\t  /**\n\t   * Inserts the provided object into the table as a row, first transforming\n\t   * it into a row via `insertTransform` (if defined). Also retrieves the\n\t   * columns specified in `returnColumns`, returning them to the caller as\n\t   * `InsertReturn`, after transformation by `insertReturnTransform`.\n\t   * If `returnColumns` is empty, returns `undefined`.\n\t   *\n", "   * On the first execution, compiles and discards the underlying Kysely\n\t   * query builder. Subsequent executions reuse the compiled query.\n\t   * @returns If `returnColumns` is not empty, returns an object;\n\t   *  otherwise returns `undefined`.\n\t   */\n\t  returnOne(\n\t    obj: InsertedObject\n\t  ): Promise<InsertReturnColumns extends [] ? void : InsertReturn>;\n\t  async returnOne(obj: InsertedObject): Promise<InsertReturn | void> {\n\t    if (this.returnColumns.length === 0) {\n", "      await this.run(obj);\n\t      return;\n\t    }\n\t    const transformedObj = this.applyInsertTransform(obj);\n\t    const compiledQuery = this.instantiateWithReturns({}, transformedObj);\n\t    const result = await this.db.executeQuery(compiledQuery);\n\t    if (result.rows.length === 0) {\n\t      throw Error(\n\t        'No row returned from compiled insert expecting returned columns'\n\t      );\n", "    }\n\t    return this.transforms.insertReturnTransform === undefined\n\t      ? (result.rows[0] as any)\n\t      : this.transforms.insertReturnTransform(obj, result.rows[0] as any);\n\t  }\n\t  /**\n\t   * Runs the query, inserting rows into the table without returning any\n\t   * columns.\n\t   *\n\t   * On the first execution, compiles and discards the underlying Kysely\n", "   * query builder. Subsequent executions reuse the compiled query.\n\t   * @param objOrObjs The object or objects to be inserted.\n\t   * @returns Returns `true`; throws an exception on error.\n\t   */\n\t  async run(obj: InsertedObject): Promise<boolean> {\n\t    const transformedObj = this.applyInsertTransform(obj);\n\t    const compiledQuery = this.instantiateNoReturns({}, transformedObj);\n\t    await this.db.executeQuery(compiledQuery);\n\t    return true;\n\t  }\n", "  protected applyInsertTransform(obj: InsertedObject): Insertable<DB[TB]> {\n\t    return this.transforms.insertTransform === undefined\n\t      ? (obj as Insertable<DB[TB]>)\n\t      : this.transforms.insertTransform(obj, this.columnsToInsert);\n\t  }\n\t}\n"]}
{"filename": "src/queries/any-insert-query.ts", "chunked_list": ["import { Kysely, InsertQueryBuilder, InsertResult, Insertable } from 'kysely';\n\timport { SelectionColumn } from '../lib/type-utils';\n\timport { SubsettingMappingInsertQuery } from './subsetting-insert-query';\n\timport { MappingInsertQuery } from './insert-query';\n\timport { InsertTransforms } from '../mappers/table-mapper-transforms';\n\t/**\n\t * Mapping query for inserting rows into a database table, where the\n\t * columns to be inserted have not been restricted.\n\t */\n\texport class AnyColumnsMappingInsertQuery<\n", "  DB,\n\t  TB extends keyof DB & string,\n\t  QB extends InsertQueryBuilder<DB, TB, InsertResult>,\n\t  InsertedObject,\n\t  InsertReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n\t  InsertReturn\n\t> extends MappingInsertQuery<\n\t  DB,\n\t  TB,\n\t  QB,\n", "  InsertedObject,\n\t  InsertReturnColumns,\n\t  InsertReturn\n\t> {\n\t  constructor(\n\t    db: Kysely<DB>,\n\t    qb: QB,\n\t    transforms: Readonly<\n\t      InsertTransforms<\n\t        DB,\n", "        TB,\n\t        InsertedObject,\n\t        InsertReturnColumns,\n\t        InsertReturn\n\t      >\n\t    >,\n\t    returnColumns: Readonly<InsertReturnColumns>\n\t  ) {\n\t    super(db, qb, transforms, returnColumns);\n\t  }\n", "  /**\n\t   * Returns a mapping query that only inserts a specified subset of columns.\n\t   * @param columns The columns to insert. All are required, but this\n\t   *  constraint is only enforced at runtime, not by the type system.\n\t   * @returns A mapping query that only inserts the specified columns.\n\t   */\n\t  columns(\n\t    columnsToInsert: Readonly<(keyof Insertable<DB[TB]> & string)[]>\n\t  ): SubsettingMappingInsertQuery<\n\t    DB,\n", "    TB,\n\t    QB,\n\t    InsertedObject,\n\t    InsertReturnColumns,\n\t    InsertReturn\n\t  > {\n\t    return new SubsettingMappingInsertQuery(\n\t      this.db,\n\t      this.qb,\n\t      columnsToInsert,\n", "      this.transforms,\n\t      this.returnColumns\n\t    );\n\t  }\n\t}\n"]}
{"filename": "src/queries/compiling-select-query.ts", "chunked_list": ["import { Kysely, SelectQueryBuilder } from 'kysely';\n\timport { SelectionColumn } from '../lib/type-utils';\n\timport { ParameterizableMappingQuery } from './parameterizable-query';\n\timport { ParameterizedQuery, ParametersObject } from 'kysely-params';\n\timport { SelectTransform } from '../mappers/table-mapper-transforms';\n\t/**\n\t * Compiling mapping query for selecting rows from a database table.\n\t */\n\texport class CompilingMappingSelectQuery<\n\t  DB,\n", "  TB extends keyof DB & string,\n\t  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n\t  SelectedObject,\n\t  QB extends SelectQueryBuilder<DB, TB, any>,\n\t  Parameters extends ParametersObject<Parameters>\n\t> implements ParameterizableMappingQuery\n\t{\n\t  #parameterizedQuery: ParameterizedQuery<Parameters, SelectedObject>;\n\t  constructor(\n\t    readonly db: Kysely<DB>,\n", "    qb: QB,\n\t    protected readonly transforms: Readonly<\n\t      SelectTransform<DB, TB, SelectedColumns, SelectedObject>\n\t    >\n\t  ) {\n\t    this.#parameterizedQuery = new ParameterizedQuery(qb);\n\t  }\n\t  /**\n\t   * Retrieves zero or more rows from the table, using `selectTransform`\n\t   * (if provided) to map the rows to objects of type `SelectedObject`.\n", "   * Accepts values for any parameters embedded in the query.\n\t   *\n\t   * On the first execution, compiles and discards the underlying Kysely\n\t   * query builder. Subsequent executions reuse the compiled query.\n\t   * @param params Record characterizing the parameter names and types.\n\t   *  Pass in `{}` if the query has no parameters.\n\t   * @returns An array of objects for the selected rows, possibly empty.\n\t   */\n\t  async returnAll(params: Parameters): Promise<SelectedObject[]> {\n\t    const results = await this.#parameterizedQuery.execute(this.db, params);\n", "    return this.transforms.selectTransform === undefined\n\t      ? (results.rows as SelectedObject[])\n\t      : (results.rows as any[]).map(this.transforms.selectTransform);\n\t  }\n\t  /**\n\t   * Retrieves a single row from the table, using `selectTransform` (if\n\t   * provided) to map the row to an object of type `SelectedObject`.\n\t   * Accepts values for any parameters embedded in the query.\n\t   *\n\t   * On the first execution, compiles and discards the underlying Kysely\n", "   * query builder. Subsequent executions reuse the compiled query.\n\t   * @param params Record characterizing the parameter names and types.\n\t   *  Pass in `{}` if the query has no parameters.\n\t   * @returns An object for the selected rows, or null if not found.\n\t   */\n\t  async returnOne(params: Parameters): Promise<SelectedObject | null> {\n\t    const result = await this.#parameterizedQuery.executeTakeFirst(\n\t      this.db,\n\t      params\n\t    );\n", "    if (!result) return null;\n\t    return result === undefined\n\t      ? null\n\t      : this.transforms.selectTransform === undefined\n\t      ? (result as SelectedObject)\n\t      : this.transforms.selectTransform(result as any);\n\t  }\n\t}\n"]}
{"filename": "src/queries/select-query.ts", "chunked_list": ["import { Kysely, SelectQueryBuilder } from 'kysely';\n\timport { SelectionColumn } from '../lib/type-utils';\n\timport { ParameterizableMappingQuery } from './parameterizable-query';\n\timport { ParametersObject } from 'kysely-params';\n\timport { CompilingMappingSelectQuery } from './compiling-select-query';\n\timport { SelectTransform } from '../mappers/table-mapper-transforms';\n\t/**\n\t * Mapping query for selecting rows from a database table.\n\t */\n\texport class MappingSelectQuery<\n", "  DB,\n\t  TB extends keyof DB & string,\n\t  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n\t  SelectedObject,\n\t  QB extends SelectQueryBuilder<DB, TB, any>\n\t> implements ParameterizableMappingQuery\n\t{\n\t  constructor(\n\t    readonly db: Kysely<DB>,\n\t    readonly qb: QB,\n", "    protected readonly transforms: Readonly<\n\t      SelectTransform<DB, TB, SelectedColumns, SelectedObject>\n\t    >\n\t  ) {}\n\t  /**\n\t   * Returns a compiling query that can be executed multiple times with\n\t   * different parameters (if any parameters were provided), but which only\n\t   * compiles the underlying Kysely query builder on the first execution.\n\t   * Frees the query builder on the first execution to reduce memory usage.\n\t   * @typeParam Parameters Record characterizing the parameter names and\n", "   *  types that were previously embedded in the query, if any.\n\t   * @returns A compiling select query.\n\t   */\n\t  compile<\n\t    Parameters extends ParametersObject<Parameters> = {}\n\t  >(): CompilingMappingSelectQuery<\n\t    DB,\n\t    TB,\n\t    SelectedColumns,\n\t    SelectedObject,\n", "    SelectQueryBuilder<DB, TB, Parameters>,\n\t    Parameters\n\t  > {\n\t    return new CompilingMappingSelectQuery(this.db, this.qb, this.transforms);\n\t  }\n\t  /**\n\t   * Modifies the underlying Kysely query builder. All columns given in\n\t   * `SelectedColumns` are already selected, but you can select additional\n\t   * columns or add column aliases.\n\t   * @param factory A function that takes the current query builder and\n", "   *  returns a new query builder.\n\t   */\n\t  modify<NextQB extends SelectQueryBuilder<DB, TB, any>>(\n\t    factory: (qb: QB) => NextQB\n\t  ): MappingSelectQuery<DB, TB, SelectedColumns, SelectedObject, NextQB> {\n\t    return new MappingSelectQuery(this.db, factory(this.qb), this.transforms);\n\t  }\n\t  /**\n\t   * Retrieves zero or more rows from the table, using `selectTransform`\n\t   * (if provided) to map the rows to objects of type `SelectedObject`.\n", "   * @returns An array of objects for the selected rows, possibly empty.\n\t   */\n\t  async returnAll(): Promise<SelectedObject[]> {\n\t    const results = await this.qb.execute();\n\t    return this.transforms.selectTransform === undefined\n\t      ? results\n\t      : (results as any[]).map(this.transforms.selectTransform);\n\t  }\n\t  /**\n\t   * Retrieves a single row from the table, using `selectTransform`\n", "   * (if provided) to map the row to an object of type `SelectedObject`.\n\t   * @returns An object for the selected rows, or null if not found.\n\t   */\n\t  async returnOne(): Promise<SelectedObject | null> {\n\t    const result = await this.qb.executeTakeFirst();\n\t    if (!result) return null;\n\t    return this.transforms.selectTransform === undefined\n\t      ? result\n\t      : this.transforms.selectTransform(result);\n\t  }\n", "}\n"]}
{"filename": "src/queries/compiling-values-query.ts", "chunked_list": ["import {\n\t  Kysely,\n\t  Selectable,\n\t  CompiledQuery,\n\t  Compilable,\n\t  ReturningInterface,\n\t} from 'kysely';\n\timport { SelectionColumn } from '../lib/type-utils';\n\timport { ParametersObject, ParameterizedValue } from 'kysely-params';\n\t/**\n", " * Parameterized value placeholder for inserted or added column values.\n\t */\n\tclass ColumnParameter<Values> {\n\t  constructor(public readonly columnName: keyof Values & string) {}\n\t}\n\t/**\n\t * Base class for compilable inserting and updating mapping queriees.\n\t */\n\texport class CompilingValuesQuery<\n\t  DB,\n", "  TB extends keyof DB & string,\n\t  QB extends ReturningInterface<DB, TB, any> & Compilable<any>,\n\t  ReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n\t  Parameters extends ParametersObject<Parameters>,\n\t  Values extends Record<string, any>\n\t> {\n\t  protected qb: QB | null = null;\n\t  #compiledQueryNoReturns?: CompiledQuery<any>;\n\t  #compiledQueryWithReturns?: CompiledQuery<any>;\n\t  constructor(\n", "    protected readonly db: Kysely<DB>,\n\t    protected readonly returnColumns: Readonly<ReturnColumns>\n\t  ) {}\n\t  protected getParameterizedObject(\n\t    columnsToAllow: Readonly<(keyof Values & string)[]>\n\t  ) {\n\t    return Object.fromEntries(\n\t      columnsToAllow.map((col) => [col, new ColumnParameter<Values>(col)])\n\t    ) as Values;\n\t  }\n", "  protected instantiateNoReturns(\n\t    params: Parameters,\n\t    obj: Values\n\t  ): CompiledQuery<any> {\n\t    this.compileQueries();\n\t    return this.instantiate(this.#compiledQueryNoReturns!, params, obj);\n\t  }\n\t  protected instantiateWithReturns(\n\t    params: Parameters,\n\t    obj: Values\n", "  ): CompiledQuery<any> {\n\t    this.compileQueries();\n\t    return this.instantiate(this.#compiledQueryWithReturns!, params, obj);\n\t  }\n\t  private compileQueries(): void {\n\t    if (this.qb !== null) {\n\t      this.#compiledQueryNoReturns = this.qb!.compile();\n\t      this.#compiledQueryWithReturns = this.getReturningQB().compile();\n\t      this.qb = null;\n\t    }\n", "  }\n\t  private getReturningQB(): QB {\n\t    return this.returnColumns[0 as number] == '*'\n\t      ? (this.qb!.returningAll() as QB)\n\t      : (this.qb!.returning(\n\t          this.returnColumns as Readonly<(keyof Selectable<DB[TB]> & string)[]>\n\t        ) as QB);\n\t  }\n\t  private instantiate(\n\t    compiledQuery: CompiledQuery<any>,\n", "    params: Parameters,\n\t    obj: Values\n\t  ): CompiledQuery<any> {\n\t    return {\n\t      query: compiledQuery.query,\n\t      sql: compiledQuery.sql,\n\t      parameters: compiledQuery.parameters.map((value) =>\n\t        value instanceof ColumnParameter\n\t          ? this.verifiedValue(obj, value.columnName)\n\t          : value instanceof ParameterizedValue\n", "          ? params[value.parameterName as keyof Parameters]\n\t          : value\n\t      ),\n\t    };\n\t  }\n\t  private verifiedValue(obj: any, column: string): any {\n\t    const value = obj[column];\n\t    // ensure the output of the applied transform works for the present query\n\t    if (value === undefined) {\n\t      throw new Error(\n", "        `Specified column '${column}' missing from values object (compiled)`\n\t      );\n\t    }\n\t    return value;\n\t  }\n\t}\n"]}
{"filename": "src/tests/update-general.test.ts", "chunked_list": ["import { Kysely, sql } from 'kysely';\n\timport { createDB, resetDB, destroyDB } from './utils/test-setup';\n\timport { Database } from './utils/test-tables';\n\timport {\n\t  createUserMapperReturningDefault,\n\t  createUserMapperReturningID,\n\t  createUserMapperReturningIDAndHandleAsH,\n\t  createUserMapperReturningAll,\n\t  createUserMapperReturningNothing,\n\t} from './utils/test-mappers';\n", "import { USERS } from './utils/test-objects';\n\timport { ignore } from './utils/test-utils';\n\tlet db: Kysely<Database>;\n\tlet userMapperReturningDefault: ReturnType<\n\t  typeof createUserMapperReturningDefault\n\t>;\n\tlet userMapperReturningNothing: ReturnType<\n\t  typeof createUserMapperReturningNothing\n\t>;\n\tlet userMapperReturningID: ReturnType<typeof createUserMapperReturningID>;\n", "let userMapperReturningIDAndHandleAsH: ReturnType<\n\t  typeof createUserMapperReturningIDAndHandleAsH\n\t>;\n\tlet userMapperReturningAll: ReturnType<typeof createUserMapperReturningAll>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n\t  userMapperReturningDefault = createUserMapperReturningDefault(db);\n\t  userMapperReturningNothing = createUserMapperReturningNothing(db);\n\t  userMapperReturningID = createUserMapperReturningID(db);\n\t  userMapperReturningIDAndHandleAsH =\n", "    createUserMapperReturningIDAndHandleAsH(db);\n\t  userMapperReturningAll = createUserMapperReturningAll(db);\n\t});\n\tbeforeEach(() => resetDB(db));\n\tafterAll(() => destroyDB(db));\n\tdescribe('general update', () => {\n\t  it('updates nothing returning zero update count', async () => {\n\t    const updateValues = { email: 'new.email@xyz.pdq' };\n\t    const success = await userMapperReturningAll\n\t      .update({ id: 1 })\n", "      .run(updateValues);\n\t    expect(success).toBe(false);\n\t    const updateCount = await userMapperReturningAll\n\t      .update({ id: 1 })\n\t      .returnCount(updateValues);\n\t    expect(updateCount).toEqual(0);\n\t    const updates = await userMapperReturningID\n\t      .update({ id: 1 })\n\t      .returnAll(updateValues);\n\t    expect(updates.length).toEqual(0);\n", "    const update = await userMapperReturningID\n\t      .update({ id: 1 })\n\t      .returnOne(updateValues);\n\t    expect(update).toBeNull();\n\t  });\n\t  it('updates something returning non-zero update count', async () => {\n\t    const updateValues = { email: 'new.email@xyz.pdq' };\n\t    const insertReturn0 = await userMapperReturningID\n\t      .insert()\n\t      .returnOne(USERS[0]);\n", "    await userMapperReturningID.insert().run(USERS[1]);\n\t    await userMapperReturningID.insert().run(USERS[2]);\n\t    const updateCount1 = await userMapperReturningAll\n\t      .update({ id: insertReturn0.id })\n\t      .returnCount(updateValues);\n\t    expect(updateCount1).toEqual(1);\n\t    const readUser1 = await userMapperReturningID\n\t      .select('id', '=', insertReturn0.id)\n\t      .returnOne();\n\t    expect(readUser1?.email).toEqual(updateValues.email);\n", "    const updateCount2 = await userMapperReturningAll\n\t      .update({ name: 'Sue' })\n\t      .returnCount(updateValues);\n\t    expect(updateCount2).toEqual(2);\n\t    const readUsers = await userMapperReturningID\n\t      .select('name', '=', 'Sue')\n\t      .returnAll();\n\t    expect(readUsers.length).toEqual(2);\n\t    expect(readUsers[0].email).toEqual(updateValues.email);\n\t    expect(readUsers[1].email).toEqual(updateValues.email);\n", "    const updates = await userMapperReturningID.update().returnAll({\n\t      name: 'Every User 1',\n\t    });\n\t    expect(updates).toEqual([{ id: 1 }, { id: 2 }, { id: 3 }]);\n\t    const update = await userMapperReturningID\n\t      .update({ id: readUsers[0].id })\n\t      .returnOne({\n\t        name: 'Every User 2',\n\t      });\n\t    expect(update).toEqual({ id: 1 });\n", "    const readUser2 = await userMapperReturningID\n\t      .select('id', '=', 1)\n\t      .returnOne();\n\t    expect(readUser2?.name).toEqual('Every User 2');\n\t    const updateCount = await userMapperReturningID.update().returnCount({\n\t      name: 'Every User 3',\n\t    });\n\t    expect(updateCount).toEqual(3);\n\t    const success = await userMapperReturningID.update().run({\n\t      name: 'Every User 4',\n", "    });\n\t    expect(success).toBe(true);\n\t  });\n\t  it('updates returning configured return columns', async () => {\n\t    await userMapperReturningID.insert().run(USERS[0]);\n\t    const insertReturn = await userMapperReturningID\n\t      .insert()\n\t      .returnOne(USERS[1]);\n\t    await userMapperReturningID.insert().run(USERS[2]);\n\t    // Verify that update performs the correct change on the correct row.\n", "    const updateValues1 = { email: 'new.email@xyz.pdq' };\n\t    const updateReturns1 = await userMapperReturningID\n\t      .update({ id: insertReturn.id })\n\t      .returnAll(updateValues1);\n\t    expect(updateReturns1).toEqual([{ id: insertReturn.id }]);\n\t    let readUser = await userMapperReturningID\n\t      .select('id', '=', insertReturn.id)\n\t      .returnOne();\n\t    expect(readUser?.email).toEqual(updateValues1.email);\n\t    // Verify a different change on the same row, returning multiple columns.\n", "    const updateValues2 = { name: 'Sue' };\n\t    const updateReturns2 = await userMapperReturningIDAndHandleAsH\n\t      .update({ email: updateValues1.email })\n\t      .returnAll(updateValues2);\n\t    updateReturns2[0].id; // ensure key is accessible\n\t    updateReturns2[0].h; // ensure key is accessible\n\t    expect(updateReturns2).toEqual([\n\t      {\n\t        id: insertReturn.id,\n\t        h: USERS[1].handle,\n", "      },\n\t    ]);\n\t    readUser = await userMapperReturningID\n\t      .select('id', '=', insertReturn.id)\n\t      .returnOne();\n\t    expect(readUser?.name).toEqual(updateValues2.name);\n\t    // Verify that update changes all required rows.\n\t    const updateValues3 = { name: 'Replacement Sue' };\n\t    const updateReturns3 = await userMapperReturningIDAndHandleAsH\n\t      .update({ name: 'Sue' })\n", "      .returnAll(updateValues3);\n\t    expect(updateReturns3.length).toEqual(3);\n\t    expect(updateReturns3[0].h).toEqual(USERS[0].handle);\n\t    expect(updateReturns3[1].h).toEqual(USERS[1].handle);\n\t    expect(updateReturns3[2].h).toEqual(USERS[2].handle);\n\t    const readUsers = await userMapperReturningID\n\t      .select('name', '=', updateValues3.name)\n\t      .returnAll();\n\t    expect(readUsers.length).toEqual(3);\n\t    ignore('check return types', () => {\n", "      // @ts-expect-error - check return types\n\t      updateReturns2[0].title;\n\t      // @ts-expect-error - check return types\n\t      updateReturns2[0].userId;\n\t    });\n\t  });\n\t  it('update returns void when defaulting to no return columns', async () => {\n\t    await userMapperReturningID.insert().run(USERS);\n\t    const updates = await userMapperReturningDefault\n\t      .update({ name: 'Sue' })\n", "      .returnAll({ email: 'new.email@xyz.pdq' });\n\t    expect(updates).toBeUndefined();\n\t    const readUsers = await userMapperReturningID\n\t      .select({\n\t        email: 'new.email@xyz.pdq',\n\t      })\n\t      .returnAll();\n\t    expect(readUsers.length).toEqual(2);\n\t  });\n\t  it('update returns void when explicitly no return columns', async () => {\n", "    await userMapperReturningID.insert().run(USERS);\n\t    const updates = await userMapperReturningNothing\n\t      .update({ name: 'Sue' })\n\t      .returnAll({ email: 'new.email@xyz.pdq' });\n\t    expect(updates).toBeUndefined();\n\t    const readUsers = await userMapperReturningID\n\t      .select({\n\t        email: 'new.email@xyz.pdq',\n\t      })\n\t      .returnAll();\n", "    expect(readUsers.length).toEqual(2);\n\t    const update = await userMapperReturningNothing\n\t      .update({ name: 'Sue' })\n\t      .returnOne({ email: 'new2.email@xyz.pdq' });\n\t    expect(update).toBeUndefined();\n\t    const readUser = await userMapperReturningID\n\t      .select({\n\t        email: 'new2.email@xyz.pdq',\n\t      })\n\t      .returnOne();\n", "    expect(readUser!.id).toEqual(1);\n\t    ignore('type errors', () => {\n\t      // @ts-expect-error - check return types\n\t      updates[0].id;\n\t      // @ts-expect-error - check return types\n\t      update!.id;\n\t    });\n\t  });\n\t  it('updates configured to return all columns', async () => {\n\t    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n", "    const updateValues1 = { email: 'new.email@xyz.pdq' };\n\t    const updateReturns = await userMapperReturningAll\n\t      .update({ name: 'Sue' })\n\t      .returnAll(updateValues1);\n\t    const expectedUsers = [\n\t      Object.assign({}, USERS[0], updateValues1, { id: insertReturns[0].id }),\n\t      Object.assign({}, USERS[2], updateValues1, { id: insertReturns[2].id }),\n\t    ];\n\t    expect(updateReturns).toEqual(expectedUsers);\n\t    // Ensure that the returned value can be accessed as a row.\n", "    ((_: string) => {})(updateReturns[0].name);\n\t    ((_: string | null) => {})(updateReturns[0].email);\n\t    const updateValues2 = { email: 'another.email@xyz.pdq' };\n\t    const updateReturn = await userMapperReturningAll\n\t      .update({ name: 'Sue' })\n\t      .returnOne(updateValues2);\n\t    const expectedUser = Object.assign({}, USERS[0], updateValues2, {\n\t      id: insertReturns[0].id,\n\t    });\n\t    expect(updateReturn).toEqual(expectedUser);\n", "    // Ensure that the returned value can be accessed as a row.\n\t    ((_: string) => {})(updateReturn!.name);\n\t    ((_: string | null) => {})(updateReturn!.email);\n\t  });\n\t  it('updates all rows when no filter is given', async () => {\n\t    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\t    const updateValues = { email: 'new.email@xyz.pdq' };\n\t    const updateReturns = await userMapperReturningIDAndHandleAsH\n\t      .update()\n\t      .returnAll(updateValues);\n", "    const expectedUsers = USERS.map((user, i) => ({\n\t      id: insertReturns[i].id,\n\t      h: user.handle,\n\t    }));\n\t    expect(updateReturns).toEqual(expectedUsers);\n\t    const readUsers = await userMapperReturningID.select().returnAll();\n\t    expect(readUsers.length).toEqual(3);\n\t    for (const user of readUsers) {\n\t      expect(user.email).toEqual(updateValues.email);\n\t    }\n", "  });\n\t  it('updates rows indicated by a binary operator', async () => {\n\t    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\t    const updateValues = { email: 'new.email@xyz.pdq' };\n\t    const updateCount = await userMapperReturningAll\n\t      .update('id', '>', insertReturns[0].id)\n\t      .returnCount(updateValues);\n\t    expect(updateCount).toEqual(2);\n\t    const readUsers = await userMapperReturningID\n\t      .select('id', '>', insertReturns[0].id)\n", "      .returnAll();\n\t    expect(readUsers.length).toEqual(2);\n\t    for (const user of readUsers) {\n\t      expect(user.email).toEqual(updateValues.email);\n\t    }\n\t  });\n\t  it('updates rows indicated by a kysely expression', async () => {\n\t    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\t    const updateValues = { email: 'new.email@xyz.pdq' };\n\t    const updateCount = await userMapperReturningDefault\n", "      .update(sql`id > ${insertReturns[0].id}`)\n\t      .returnCount(updateValues);\n\t    expect(updateCount).toEqual(BigInt(2));\n\t    const readUsers = await userMapperReturningID\n\t      .select('id', '>', insertReturns[0].id)\n\t      .returnAll();\n\t    expect(readUsers.length).toEqual(2);\n\t    for (const user of readUsers) {\n\t      expect(user.email).toEqual(updateValues.email);\n\t    }\n", "  });\n\t  it('updates rows indicated by a where expression filter', async () => {\n\t    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\t    const updateValues1 = { email: 'foo@xyz.pdq' };\n\t    const updateCount = await userMapperReturningAll\n\t      .update(({ or, cmpr }) =>\n\t        or([\n\t          cmpr('id', '=', insertReturns[0].id),\n\t          cmpr('id', '=', insertReturns[2].id),\n\t        ])\n", "      )\n\t      .returnCount(updateValues1);\n\t    expect(updateCount).toEqual(2);\n\t    const updateValues2 = { email: 'bar@xyz.pdq' };\n\t    const updateReturns = await userMapperReturningID\n\t      .update(({ or, cmpr }) =>\n\t        or([\n\t          cmpr('id', '=', insertReturns[0].id),\n\t          cmpr('id', '=', insertReturns[2].id),\n\t        ])\n", "      )\n\t      .returnAll(updateValues2);\n\t    expect(updateReturns).toEqual([\n\t      { id: insertReturns[0].id },\n\t      { id: insertReturns[2].id },\n\t    ]);\n\t  });\n\t  ignore('detects update type errors', async () => {\n\t    userMapperReturningID.update(\n\t      // @ts-expect-error - table must have all filter fields\n", "      { notThere: 'xyz' }\n\t    );\n\t    // @ts-expect-error - table must have all filter fields\n\t    userMapperReturningID.update('notThere', '=', 'foo');\n\t    userMapperReturningID.update(({ or, cmpr }) =>\n\t      // @ts-expect-error - only table columns are accessible via anyOf()\n\t      or([cmpr('notThere', '=', 'xyz'), cmpr('alsoNotThere', '=', 'Sue')])\n\t    );\n\t    // @ts-expect-error - ID filter must have correct type\n\t    userMapperReturningID.update('str');\n", "    // @ts-expect-error - ID filter must have correct type\n\t    userMapperReturningID.update(['str']);\n\t    // @ts-expect-error - ID filter not allowed when when no ID column\n\t    userMapperReturningNothing.update(1);\n\t    // @ts-expect-error - ID filter not allowed when when no ID column\n\t    userMapperReturningNothing.update([1]);\n\t    userMapperReturningID.update({ id: 32 }).returnAll(\n\t      // @ts-expect-error - update must only have table columns\n\t      { notThere: 'xyz@pdq.xyz' }\n\t    );\n", "    // @ts-expect-error - only requested columns are accessible\n\t    // prettier-ignore\n\t    (await userMapperReturningID.update({ id: 32 }).returnAll(USERS[0]))[0].name;\n\t    userMapperReturningID.update({ id: 32 }).returnOne(\n\t      // @ts-expect-error - update must only have table columns\n\t      { notThere: 'xyz@pdq.xyz' }\n\t    );\n\t    // @ts-expect-error - only requested columns are accessible\n\t    // prettier-ignore\n\t    (await userMapperReturningID.update({ id: 32 }).returnOne(USERS[0]))[0].name;\n", "    userMapperReturningID.update({ id: 32 }).returnCount(\n\t      // @ts-expect-error - update must only have table columns\n\t      { notThere: 'xyz@pdq.xyz' }\n\t    );\n\t    // @ts-expect-error - only requested columns are accessible\n\t    // prettier-ignore\n\t    (await userMapperReturningID.update({ id: 32 }).returnCount(USERS[0]))[0].name;\n\t    userMapperReturningID.update({ id: 32 }).run(\n\t      // @ts-expect-error - update must only have table columns\n\t      { notThere: 'xyz@pdq.xyz' }\n", "    );\n\t    // @ts-expect-error - only requested columns are accessible\n\t    // prettier-ignore\n\t    (await userMapperReturningID.update({ id: 32 }).run(USERS[0]))[0].name;\n\t  });\n\t});\n"]}
{"filename": "src/tests/insert-array.test.ts", "chunked_list": ["import { Insertable, Kysely, Selectable, Updateable } from 'kysely';\n\timport { TableMapper } from '../mappers/table-mapper';\n\timport { createDB, resetDB, destroyDB } from './utils/test-setup';\n\timport { Database, Posts } from './utils/test-tables';\n\timport {\n\t  createUserMapperReturningDefault,\n\t  createUserMapperReturningID,\n\t  createUserMapperReturningAll,\n\t  createUserMapperReturningNothing,\n\t  createUserMapperReturningDifferently,\n", "} from './utils/test-mappers';\n\timport { USERS, POSTS } from './utils/test-objects';\n\timport { ignore } from './utils/test-utils';\n\tlet db: Kysely<Database>;\n\tlet userMapperReturningDefault: ReturnType<\n\t  typeof createUserMapperReturningDefault\n\t>;\n\tlet userMapperReturningNothing: ReturnType<\n\t  typeof createUserMapperReturningNothing\n\t>;\n", "let userMapperReturningID: ReturnType<typeof createUserMapperReturningID>;\n\tlet userMapperReturningAll: ReturnType<typeof createUserMapperReturningAll>;\n\tlet postTableMapperReturningIDAndTitleAsT: TableMapper<\n\t  Database,\n\t  'posts',\n\t  [],\n\t  ['*'],\n\t  Selectable<Posts>,\n\t  Insertable<Posts>,\n\t  Updateable<Posts>,\n", "  number,\n\t  ['id', 'title as t']\n\t>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n\t  userMapperReturningDefault = createUserMapperReturningDefault(db);\n\t  userMapperReturningNothing = createUserMapperReturningNothing(db);\n\t  userMapperReturningID = createUserMapperReturningID(db);\n\t  userMapperReturningAll = createUserMapperReturningAll(db);\n\t  postTableMapperReturningIDAndTitleAsT = new TableMapper(db, 'posts', {\n", "    insertReturnColumns: ['id', 'title as t'],\n\t  }).withTransforms({\n\t    countTransform: (count) => Number(count),\n\t  });\n\t});\n\tbeforeEach(() => resetDB(db));\n\tafterAll(() => destroyDB(db));\n\tdescribe('inserting an array of objects without transformation', () => {\n\t  it('inserts readonly objects', async () => {\n\t    const obj = {\n", "      name: 'John Doe' as const,\n\t      handle: 'johndoe' as const,\n\t      email: 'abc@def.ghi' as const,\n\t    } as const;\n\t    await userMapperReturningAll.insert().run(obj);\n\t    await userMapperReturningAll.insert().returnAll([obj]);\n\t    await userMapperReturningAll.insert().returnOne(obj);\n\t  });\n\t  it('inserts multiple via run() without returning columns', async () => {\n\t    const success = await userMapperReturningDefault.insert().run(USERS);\n", "    expect(success).toBe(true);\n\t    const readUsers = await userMapperReturningAll.select().returnAll();\n\t    expect(readUsers.length).toEqual(3);\n\t    for (let i = 0; i < USERS.length; i++) {\n\t      expect(readUsers[i].handle).toEqual(USERS[i].handle);\n\t    }\n\t    ignore(\"can't access columns when returning nothing\", () => {\n\t      // @ts-expect-error - can't access columns when returning nothing\n\t      result.id;\n\t      // @ts-expect-error - can't access columns when returning nothing\n", "      result[0].id;\n\t    });\n\t  });\n\t  it('inserts multiple via returnAll() without returning columns', async () => {\n\t    const results = await userMapperReturningDefault.insert().returnAll(USERS);\n\t    expect(results).toBeUndefined();\n\t    const readUsers = await userMapperReturningAll.select().returnAll();\n\t    expect(readUsers.length).toEqual(3);\n\t    for (let i = 0; i < USERS.length; i++) {\n\t      expect(readUsers[i].handle).toEqual(USERS[i].handle);\n", "    }\n\t    ignore(\"can't access columns when returning nothing\", () => {\n\t      // @ts-expect-error - can't access columns when returning nothing\n\t      results.id;\n\t      // @ts-expect-error - can't access columns when returning nothing\n\t      results[0].id;\n\t    });\n\t  });\n\t  it('inserts multiple via returnOne() without returning columns', async () => {\n\t    const results = await userMapperReturningDefault\n", "      .insert()\n\t      .returnOne(USERS[0]);\n\t    expect(results).toBeUndefined();\n\t    const readUsers = await userMapperReturningAll.select().returnAll();\n\t    expect(readUsers.length).toEqual(1);\n\t    expect(readUsers[0].handle).toEqual(USERS[0].handle);\n\t    ignore(\"can't access columns when returning nothing\", () => {\n\t      // @ts-expect-error - can't access columns when returning nothing\n\t      results.id;\n\t      // @ts-expect-error - can't access columns when returning nothing\n", "      results[0].id;\n\t    });\n\t  });\n\t  it('inserts multiple returning configured return columns', async () => {\n\t    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\t    expect(insertReturns.length).toEqual(3);\n\t    for (let i = 0; i < USERS.length; i++) {\n\t      expect(insertReturns[i].id).toBeGreaterThan(0);\n\t      expect(Object.keys(insertReturns[i]).length).toEqual(1);\n\t    }\n", "    const readUsers = await userMapperReturningAll.select().returnAll();\n\t    expect(readUsers.length).toEqual(3);\n\t    for (let i = 0; i < USERS.length; i++) {\n\t      expect(readUsers[i].handle).toEqual(USERS[i].handle);\n\t    }\n\t    const post0 = Object.assign({}, POSTS[0], { userId: insertReturns[0].id });\n\t    const post1 = Object.assign({}, POSTS[1], { userId: insertReturns[1].id });\n\t    const post2 = Object.assign({}, POSTS[2], { userId: insertReturns[2].id });\n\t    const updateReturns = await postTableMapperReturningIDAndTitleAsT\n\t      .insert()\n", "      .returnAll([post0, post1, post2]);\n\t    expect(updateReturns.length).toEqual(3);\n\t    for (let i = 0; i < updateReturns.length; i++) {\n\t      expect(updateReturns[i].id).toBeGreaterThan(0);\n\t      expect(updateReturns[i].t).toEqual(POSTS[i].title);\n\t      expect(Object.keys(updateReturns[i]).length).toEqual(2);\n\t    }\n\t    ignore('check return types', () => {\n\t      // @ts-expect-error - check return types\n\t      updateReturns[0].title;\n", "      // @ts-expect-error - check return types\n\t      updateReturns[0].userId;\n\t    });\n\t  });\n\t  it('inserts multiple returning no columns by default', async () => {\n\t    const insertReturns = await userMapperReturningDefault\n\t      .insert()\n\t      .returnAll(USERS);\n\t    expect(insertReturns).toBeUndefined();\n\t    const readUsers = await userMapperReturningAll.select().returnAll();\n", "    expect(readUsers.length).toEqual(3);\n\t    for (let i = 0; i < USERS.length; i++) {\n\t      expect(readUsers[i].handle).toEqual(USERS[i].handle);\n\t    }\n\t  });\n\t  it('inserts multiple explicitly returning no columns', async () => {\n\t    const insertReturns = await userMapperReturningNothing\n\t      .insert()\n\t      .returnAll(USERS);\n\t    expect(insertReturns).toBeUndefined();\n", "    const readUsers = await userMapperReturningAll.select().returnAll();\n\t    expect(readUsers.length).toEqual(3);\n\t    for (let i = 0; i < USERS.length; i++) {\n\t      expect(readUsers[i].handle).toEqual(USERS[i].handle);\n\t    }\n\t    ignore(\"can't access columns when returning nothing\", () => {\n\t      // @ts-expect-error - can't access columns when returning nothing\n\t      insertReturns[0].id;\n\t    });\n\t  });\n", "  it('inserts multiple returning differently for inserts and updates', async () => {\n\t    const mapper = createUserMapperReturningDifferently(db);\n\t    const insertReturns = await mapper.insert().returnAll(USERS);\n\t    expect(insertReturns.length).toEqual(3);\n\t    expect(insertReturns[0]).toEqual({\n\t      id: insertReturns[0].id,\n\t      handle: USERS[0].handle,\n\t    });\n\t    // Ensure that returned objects can be accessed as expected.\n\t    ((_: number) => {})(insertReturns[0].id);\n", "    ((_: string) => {})(insertReturns[0].handle);\n\t    const newHandle = 'newHandle';\n\t    const updateReturns = await mapper\n\t      .update(1)\n\t      .returnAll({ handle: newHandle });\n\t    expect(updateReturns.length).toEqual(1);\n\t    expect(updateReturns[0]).toEqual({\n\t      name: USERS[0].name,\n\t    });\n\t    // Ensure that returned objects can be accessed as expected.\n", "    ((_: string) => {})(updateReturns[0].name);\n\t    ignore('type errors', () => {\n\t      // @ts-expect-error - check return types\n\t      insertReturns[0].name;\n\t      // @ts-expect-error - check return types\n\t      updateReturns[0].id;\n\t    });\n\t  });\n\t  it('inserts multiple configured to return all columns', async () => {\n\t    const insertReturns = await userMapperReturningAll\n", "      .insert()\n\t      .returnAll(USERS);\n\t    for (let i = 0; i < USERS.length; i++) {\n\t      expect(insertReturns[i].id).toBeGreaterThan(0);\n\t    }\n\t    expect(insertReturns).toEqual(\n\t      USERS.map((user, i) =>\n\t        Object.assign({}, user, { id: insertReturns[i].id })\n\t      )\n\t    );\n", "    // Ensure that returned objects can be accessed as expected.\n\t    ((_: string) => {})(insertReturns[0].name);\n\t  });\n\t  ignore('detects inserting an array of objects type errors', async () => {\n\t    // @ts-expect-error - inserted object must have all required columns\n\t    userMapperReturningAll.insert().returnAll([{}]);\n\t    // @ts-expect-error - inserted object must have all required columns\n\t    userMapperReturningAll.insert().run([{}]);\n\t    // @ts-expect-error - inserted object must have all required columns\n\t    userMapperReturningAll.insert().returnAll([{ email: 'xyz@pdq.xyz' }]);\n", "    // @ts-expect-error - inserted object must have all required columns\n\t    userMapperReturningAll.insert().run([{ email: 'xyz@pdq.xyz' }]);\n\t    // @ts-expect-error - only configured columns are returned\n\t    (await userMapperReturningID.insert().returnAll([USERS[0]]))[0].handle;\n\t    // @ts-expect-error - only configured columns are returned\n\t    (await userMapperReturningID.insert().run([USERS[0]]))[0].handle;\n\t  });\n\t});\n"]}
{"filename": "src/tests/select-all.test.ts", "chunked_list": ["/**\n\t * Tests TableMapper.selectMany(), TableMapper.selectOne(), and query filters.\n\t */\n\timport { Kysely, sql } from 'kysely';\n\timport { TableMapper } from '../mappers/table-mapper';\n\timport { createDB, resetDB, destroyDB } from './utils/test-setup';\n\timport { Database } from './utils/test-tables';\n\timport { createUserMapperReturningID } from './utils/test-mappers';\n\timport { USERS } from './utils/test-objects';\n\timport { ignore } from './utils/test-utils';\n", "let db: Kysely<Database>;\n\tlet userMapper: ReturnType<typeof createUserMapperReturningID>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n\t  userMapper = createUserMapperReturningID(db);\n\t});\n\tbeforeEach(() => resetDB(db));\n\tafterAll(() => destroyDB(db));\n\tdescribe('selecting all returns', () => {\n\t  it('accepts readonly filters', async () => {\n", "    const filter1 = { name: 'Not There' as const } as const;\n\t    await userMapper.select(filter1).returnAll();\n\t    await userMapper.select(filter1).returnOne();\n\t    const filter2 = { name: ['name1', 'name2'] as const } as const;\n\t    await userMapper.select(filter2).returnAll();\n\t    await userMapper.select(filter2).returnOne();\n\t  });\n\t  it('selects nothing when nothing matches filter', async () => {\n\t    await userMapper.insert().run(USERS);\n\t    const users = await userMapper.select({ name: 'Not There' }).returnAll();\n", "    expect(users.length).toEqual(0);\n\t  });\n\t  it('selects all rows with no filter', async () => {\n\t    await userMapper.insert().run(USERS);\n\t    // Test selecting all\n\t    const users = await userMapper.select().returnAll();\n\t    expect(users.length).toEqual(USERS.length);\n\t    for (let i = 0; i < USERS.length; i++) {\n\t      expect(users[i].handle).toEqual(USERS[i].handle);\n\t    }\n", "  });\n\t  it('selects via key column values', async () => {\n\t    await userMapper.insert().run(USERS);\n\t    // Test selecting via key value\n\t    const users1 = await userMapper.select(2).returnAll();\n\t    expect(users1.length).toEqual(1);\n\t    expect(users1[0].handle).toEqual(USERS[1].handle);\n\t    // Test selecting via key tuple\n\t    const users2 = await userMapper.select([2]).returnAll();\n\t    expect(users2.length).toEqual(1);\n", "    expect(users2[0].handle).toEqual(USERS[1].handle);\n\t  });\n\t  it('selects with a matching field filter', async () => {\n\t    await userMapper.insert().run(USERS);\n\t    let users = await userMapper\n\t      .select({\n\t        name: USERS[0].name,\n\t      })\n\t      .returnAll();\n\t    expect(users.length).toEqual(2);\n", "    expect(users[0].handle).toEqual(USERS[0].handle);\n\t    expect(users[1].handle).toEqual(USERS[2].handle);\n\t    users = await userMapper\n\t      .select({\n\t        name: USERS[0].name,\n\t        handle: USERS[2].handle,\n\t      })\n\t      .returnAll();\n\t    expect(users.length).toEqual(1);\n\t    expect(users[0].handle).toEqual(USERS[2].handle);\n", "    users = await userMapper\n\t      .select({\n\t        handle: [USERS[1].handle, USERS[2].handle],\n\t      })\n\t      .returnAll();\n\t    expect(users.length).toEqual(2);\n\t    expect(users[0].handle).toEqual(USERS[1].handle);\n\t    expect(users[1].handle).toEqual(USERS[2].handle);\n\t  });\n\t  it('selects with a binary operation filter', async () => {\n", "    await userMapper.insert().run(USERS);\n\t    // Test selecting by condition (with results)\n\t    let users = await userMapper.select('name', '=', USERS[0].name).returnAll();\n\t    expect(users.length).toEqual(2);\n\t    expect(users[0].handle).toEqual(USERS[0].handle);\n\t    expect(users[1].handle).toEqual(USERS[2].handle);\n\t    // Test selecting by condition (no results)\n\t    users = await userMapper.select('name', '=', 'nonexistent').returnAll();\n\t    expect(users.length).toEqual(0);\n\t  });\n", "  it('selects with a binary operation filter using .ref()', async () => {\n\t    await userMapper.insert().run(USERS);\n\t    // Test selecting by condition (with results)\n\t    let users = await userMapper\n\t      .select(userMapper.ref('name'), '=', USERS[0].name)\n\t      .returnAll();\n\t    expect(users.length).toEqual(2);\n\t    expect(users[0].handle).toEqual(USERS[0].handle);\n\t    expect(users[1].handle).toEqual(USERS[2].handle);\n\t    // Test selecting by condition (no results)\n", "    users = await userMapper\n\t      .select(userMapper.ref('email'), '=', 'nonexistent')\n\t      .returnAll();\n\t    expect(users.length).toEqual(0);\n\t  });\n\t  it('selects with a query expression filter', async () => {\n\t    await userMapper.insert().run(USERS);\n\t    const users = await userMapper\n\t      .select(sql`name != ${USERS[0].name}`)\n\t      .returnAll();\n", "    expect(users.length).toEqual(1);\n\t    expect(users[0].handle).toEqual(USERS[1].handle);\n\t  });\n\t  it('selects many returning selected columns and aliases', async () => {\n\t    const ids = await userMapper.insert().returnAll(USERS);\n\t    const mapper = new TableMapper(db, 'users', {\n\t      selectedColumns: ['id', 'handle as h'],\n\t    });\n\t    // Should allow access to aliased columns\n\t    (await mapper.select().returnAll())[0].h;\n", "    const users = await mapper.select({ name: USERS[0].name }).returnAll();\n\t    expect(users).toEqual([\n\t      {\n\t        id: ids[0].id,\n\t        h: USERS[0].handle,\n\t      },\n\t      {\n\t        id: ids[2].id,\n\t        h: USERS[2].handle,\n\t      },\n", "    ]);\n\t    ignore('inaccessible types are not allowed', async () => {\n\t      // @ts-expect-error - aliases are not allowed in filter expressions\n\t      mapper.select({ h: USERS[0].handle });\n\t      // @ts-expect-error - unselected columns are not allowed\n\t      (await mapper.select().returnAll())[0].name;\n\t    });\n\t  });\n\t  ignore(\n\t    'detects selecting returnAll() simple filter type errors',\n", "    async () => {\n\t      // @ts-expect-error - only table columns are accessible unfiltered\n\t      (await userMapper.select().returnAll())[0].notThere;\n\t      // @ts-expect-error - only table columns are accessible unfiltered\n\t      (await userMapper.select({}).returnAll())[0].notThere;\n\t      // @ts-expect-error - only table columns are accessible w/ object filter\n\t      // prettier-ignore\n\t      (await userMapper.select({ name: \"Sue\" }).returnAll())[0].notThere;\n\t      // @ts-expect-error - only table columns are accessible w/ op filter\n\t      // prettier-ignore\n", "      (await userMapper.select(\"name\", \"=\", \"Sue\").returnAll())[0].notThere;\n\t      // prettier-ignore\n\t      (\n\t        await userMapper\n\t          .select((qb) => qb)\n\t          .returnAll()\n\t        // @ts-expect-error - only table columns are accessible w/ QB filter\n\t      )[0].notThere;\n\t      // prettier-ignore\n\t      (\n", "        await userMapper\n\t          .select(sql`name = 'Sue'`)\n\t          .returnAll()\n\t        // @ts-expect-error - only table columns are accessible w/ expr filter\n\t      )[0].notThere;\n\t    }\n\t  );\n\t});\n"]}
{"filename": "src/tests/insert-compile.test.ts", "chunked_list": ["import { Insertable, Kysely } from 'kysely';\n\timport { TableMapper } from '../mappers/table-mapper';\n\timport { createDB, resetDB, destroyDB } from './utils/test-setup';\n\timport { Database, Users } from './utils/test-tables';\n\timport { USERS } from './utils/test-objects';\n\timport { ignore } from './utils/test-utils';\n\timport { User } from './utils/test-types';\n\timport {\n\t  createUserMapperReturningAll,\n\t  createUserMapperReturningNothing,\n", "} from './utils/test-mappers';\n\tlet db: Kysely<Database>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n\t  userMapperReturningNothing = createUserMapperReturningNothing(db);\n\t  userMapperReturningAll = createUserMapperReturningAll(db);\n\t});\n\tbeforeEach(() => resetDB(db));\n\tafterAll(() => destroyDB(db));\n\tlet userMapperReturningNothing: ReturnType<\n", "  typeof createUserMapperReturningNothing\n\t>;\n\tlet userMapperReturningAll: ReturnType<typeof createUserMapperReturningAll>;\n\tdescribe('compiled insertions', () => {\n\t  it('compiles a non-returning insert query without transformation', async () => {\n\t    const compilation = userMapperReturningNothing\n\t      .insert()\n\t      .columns(['name', 'handle'])\n\t      .compile();\n\t    // test run()\n", "    const success1 = await compilation.run(USERS[1]);\n\t    expect(success1).toBe(true);\n\t    // test returnOne()\n\t    const success2 = await compilation.returnOne(USERS[2]);\n\t    expect(success2).toBeUndefined();\n\t    const readUsers = await userMapperReturningAll.select().returnAll();\n\t    expect(readUsers.length).toEqual(2);\n\t    expect(readUsers[0].handle).toEqual(USERS[1].handle);\n\t    expect(readUsers[0].email).toEqual(null);\n\t    expect(readUsers[1].handle).toEqual(USERS[2].handle);\n", "    expect(readUsers[1].email).toEqual(null);\n\t  });\n\t  it('compiles a returning insert query without transformation', async () => {\n\t    const compilation = userMapperReturningAll\n\t      .insert()\n\t      .columns(['name', 'handle', 'email'])\n\t      .compile();\n\t    // test returnOne()\n\t    const insertReturn = await compilation.returnOne(USERS[0]);\n\t    expect(insertReturn).toEqual({ ...USERS[0], id: 1 });\n", "    // Ensure that the provided columns are accessible\n\t    ((_: string) => {})(insertReturn!.name);\n\t    // test run()\n\t    const success1 = await compilation.run(USERS[1]);\n\t    expect(success1).toBe(true);\n\t    // test that non-specified columns are not inserted\n\t    const success2 = await compilation.run({ ...USERS[2], id: 100 });\n\t    expect(success2).toBe(true);\n\t    const readUsers = await userMapperReturningAll.select().returnAll();\n\t    expect(readUsers.length).toEqual(3);\n", "    expect(readUsers[0].handle).toEqual(USERS[0].handle);\n\t    expect(readUsers[1].handle).toEqual(USERS[1].handle);\n\t    expect(readUsers[2].handle).toEqual(USERS[2].handle);\n\t    expect(readUsers[2].id).toEqual(3);\n\t    ignore('check compile-time types', () => {\n\t      compilation.returnOne({\n\t        name: 'xyz',\n\t        handle: 'pdq',\n\t        email: 'abc@def.hij',\n\t        // @ts-expect-error - only insertable columns are allowed\n", "        notThere: 32,\n\t      });\n\t      // @ts-expect-error - only expected columns are returned\n\t      insertReturn!.notThere;\n\t    });\n\t  });\n\t  it('compiles an insert query with transformation', async () => {\n\t    expect.assertions(7);\n\t    const columnSubset: (keyof Insertable<Users>)[] = [\n\t      'name',\n", "      'handle',\n\t      'email',\n\t    ];\n\t    const transformMapper = new TableMapper(db, 'users', {\n\t      insertReturnColumns: ['id'],\n\t    }).withTransforms({\n\t      selectTransform: (row) => {\n\t        const names = row.name.split(' ');\n\t        return new User(row.id, names[0], names[1], row.handle, row.email);\n\t      },\n", "      insertTransform: (source: User, columns) => {\n\t        expect(columns).toEqual(columnSubset);\n\t        return {\n\t          name: `${source.firstName} ${source.lastName}`,\n\t          handle: source.handle,\n\t          email: source.email,\n\t        };\n\t      },\n\t      insertReturnTransform: (source: User, returns) =>\n\t        new User(\n", "          returns.id,\n\t          source.firstName,\n\t          source.lastName,\n\t          source.handle,\n\t          source.email\n\t        ),\n\t      countTransform: (count) => Number(count),\n\t    });\n\t    const user1: Readonly<User> = new User(\n\t      0,\n", "      'John',\n\t      'Doe',\n\t      'johndoe',\n\t      'jdoe@abc.def'\n\t    );\n\t    const user2: Readonly<User> = new User(\n\t      0,\n\t      'Sam',\n\t      'Gamgee',\n\t      'sg',\n", "      'sg@abc.def'\n\t    );\n\t    const user3 = new User(100, 'Sue', 'Rex', 'srex', 'srex@abc.def');\n\t    const compilation = transformMapper\n\t      .insert()\n\t      .columns(columnSubset)\n\t      .compile();\n\t    // test returnOne()\n\t    const insertReturn = await compilation.returnOne(user1);\n\t    expect(insertReturn).toEqual(User.create(1, user1));\n", "    // Ensure that the provided columns are accessible\n\t    ((_: string) => {})(insertReturn!.firstName);\n\t    // test run()\n\t    const success1 = await compilation.run(user2);\n\t    expect(success1).toBe(true);\n\t    // test that non-specified columns are not inserted\n\t    const success2 = await compilation.run(user3);\n\t    expect(success2).toBe(true);\n\t    const readUsers = await transformMapper.select().returnAll();\n\t    expect(readUsers).toEqual([\n", "      User.create(1, user1),\n\t      User.create(2, user2),\n\t      User.create(3, user3),\n\t    ]);\n\t    ignore('check compile-time types', () => {\n\t      // @ts-expect-error - only insertable objecs are allowed\n\t      compilation.returnOne(USERS[0]);\n\t      // @ts-expect-error - only insertable objecs are allowed\n\t      compilation.run(USERS[0]);\n\t    });\n", "  });\n\t  it('requires all indicated columns to be inserted', async () => {\n\t    const compilation = userMapperReturningAll\n\t      .insert()\n\t      .columns(['name', 'handle', 'email'])\n\t      .compile();\n\t    const insertValues = { name: 'John Doe', handle: 'johndoe' };\n\t    expect(() => compilation.returnOne(insertValues)).rejects.toThrow(\n\t      `column 'email' missing`\n\t    );\n", "    const success = await compilation.run({ ...insertValues, email: null });\n\t    expect(success).toBe(true);\n\t  });\n\t});\n"]}
{"filename": "src/tests/update-transform.test.ts", "chunked_list": ["import { Kysely, Updateable } from 'kysely';\n\timport { TableMapper } from '../mappers/table-mapper';\n\timport { createDB, resetDB, destroyDB } from './utils/test-setup';\n\timport { Database, Users } from './utils/test-tables';\n\timport {\n\t  userObject1,\n\t  userRow1,\n\t  userRow2,\n\t  userRow3,\n\t} from './utils/test-objects';\n", "import { ReturnedUser, UpdatingUser } from './utils/test-types';\n\tlet db: Kysely<Database>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n\t});\n\tbeforeEach(() => resetDB(db));\n\tafterAll(() => destroyDB(db));\n\tdescribe('updating with transformation', () => {\n\t  it('transforms users for update without transforming return', async () => {\n\t    const mapper = new TableMapper(db, 'users', {\n", "      insertReturnColumns: ['id'],\n\t      updateReturnColumns: ['id'],\n\t    }).withTransforms({\n\t      updateTransform: (source: UpdatingUser) => ({\n\t        name: `${source.firstName} ${source.lastName}`,\n\t        handle: source.handle,\n\t        email: source.email,\n\t      }),\n\t    });\n\t    const insertReturns = await mapper\n", "      .insert()\n\t      .returnAll([userRow1, userRow2, userRow3]);\n\t    const updatingUser1 = UpdatingUser.create(\n\t      0,\n\t      Object.assign({}, userObject1, { firstName: 'Suzanne' })\n\t    );\n\t    const updateReturns = await mapper\n\t      .update(({ or, cmpr }) =>\n\t        or([\n\t          cmpr('id', '=', insertReturns[0].id),\n", "          cmpr('id', '=', insertReturns[2].id),\n\t        ])\n\t      )\n\t      .returnAll(updatingUser1);\n\t    expect(updateReturns).toEqual([\n\t      { id: insertReturns[0].id },\n\t      { id: insertReturns[2].id },\n\t    ]);\n\t    const readUsers = await mapper\n\t      .select()\n", "      .modify((qb) => qb.orderBy('id'))\n\t      .returnAll();\n\t    expect(readUsers).toEqual([\n\t      Object.assign({}, userRow1, {\n\t        id: insertReturns[0].id,\n\t        name: 'Suzanne Smith',\n\t      }),\n\t      Object.assign({}, userRow2, { id: insertReturns[1].id }),\n\t      Object.assign({}, userRow1, {\n\t        id: insertReturns[2].id,\n", "        name: 'Suzanne Smith',\n\t      }),\n\t    ]);\n\t  });\n\t  it('transforms update return into object without transforming update', async () => {\n\t    const updateReturnTransformMapper = new TableMapper(db, 'users', {\n\t      insertReturnColumns: ['id'],\n\t      updateReturnColumns: ['id'],\n\t    }).withTransforms({\n\t      updateReturnTransform: (source, returns) =>\n", "        new ReturnedUser(\n\t          returns.id,\n\t          source.name ? source.name.split(' ')[0] : '(first)',\n\t          source.name ? source.name.split(' ')[1] : '(last)',\n\t          source.handle ? source.handle : '(handle)',\n\t          source.email ? source.email : '(email)'\n\t        ),\n\t    });\n\t    const insertReturn = await updateReturnTransformMapper\n\t      .insert()\n", "      .returnOne(userRow1);\n\t    const updateReturn1 = await updateReturnTransformMapper\n\t      .update({ id: insertReturn.id })\n\t      .returnAll({ name: 'Suzanne Smith' });\n\t    expect(updateReturn1).toEqual([\n\t      new ReturnedUser(\n\t        insertReturn.id,\n\t        'Suzanne',\n\t        'Smith',\n\t        '(handle)',\n", "        '(email)'\n\t      ),\n\t    ]);\n\t    // Ensure the returned value is accessible as a ReturnedUser\n\t    ((_: string) => {})(updateReturn1[0].firstName);\n\t    const updateReturn2 = await updateReturnTransformMapper\n\t      .update({ id: insertReturn.id })\n\t      .returnOne({ name: 'Suzanne Smithy' });\n\t    expect(updateReturn2).toEqual(\n\t      new ReturnedUser(\n", "        insertReturn.id,\n\t        'Suzanne',\n\t        'Smithy',\n\t        '(handle)',\n\t        '(email)'\n\t      )\n\t    );\n\t    // Ensure the returned value is accessible as a ReturnedUser\n\t    ((_: string) => {})(updateReturn2!.firstName);\n\t  });\n", "  it('transforms update return into primitive without transforming update', async () => {\n\t    const updateReturnTransformMapper = new TableMapper(db, 'users', {\n\t      insertReturnColumns: ['id'],\n\t      updateReturnColumns: ['id'],\n\t    }).withTransforms({\n\t      insertReturnTransform: (_source, returns) => returns.id,\n\t      updateReturnTransform: (_source, returns) => returns.id,\n\t    });\n\t    const insertReturn = await updateReturnTransformMapper\n\t      .insert()\n", "      .returnOne(userRow1);\n\t    const updateReturn1 = await updateReturnTransformMapper\n\t      .update({ id: insertReturn })\n\t      .returnAll({ name: 'Suzanne Smith' });\n\t    expect(updateReturn1).toEqual([1]);\n\t    // Ensure the returned value is accessible as a number\n\t    ((_: number) => {})(updateReturn1[0]);\n\t    const updateReturn2 = await updateReturnTransformMapper\n\t      .update({ id: insertReturn })\n\t      .returnOne({ name: 'Suzanne Smithy' });\n", "    expect(updateReturn2).toEqual(1);\n\t    // Ensure the returned value is accessible as a number\n\t    ((_: number) => {})(updateReturn2!);\n\t  });\n\t  it(\"transforms update and update return, columns is ['*']\", async () => {\n\t    expect.assertions(2);\n\t    const updateAndReturnTransformMapper = new TableMapper(db, 'users', {\n\t      insertReturnColumns: ['id'],\n\t      updateReturnColumns: ['id'],\n\t    }).withTransforms({\n", "      updateTransform: (source: UpdatingUser, columns) => {\n\t        expect(columns).toEqual(['*']);\n\t        return {\n\t          name: `${source.firstName} ${source.lastName}`,\n\t          handle: source.handle,\n\t          email: source.email,\n\t        };\n\t      },\n\t      updateReturnTransform: (source: UpdatingUser, returns) =>\n\t        new ReturnedUser(\n", "          returns.id,\n\t          source.firstName,\n\t          source.lastName,\n\t          source.handle,\n\t          source.email\n\t        ),\n\t    });\n\t    const insertReturn = await updateAndReturnTransformMapper\n\t      .insert()\n\t      .returnOne(userRow1);\n", "    const updateReturn = await updateAndReturnTransformMapper\n\t      .update({ id: insertReturn.id })\n\t      .returnAll(UpdatingUser.create(0, userObject1));\n\t    expect(updateReturn).toEqual([\n\t      new ReturnedUser(\n\t        insertReturn.id,\n\t        userObject1.firstName,\n\t        userObject1.lastName,\n\t        userObject1.handle,\n\t        userObject1.email\n", "      ),\n\t    ]);\n\t    // Ensure the returned value is accessible as a ReturnedUser\n\t    ((_: string) => {})(updateReturn[0].firstName);\n\t  });\n\t  it('transforms a union of updating object types', async () => {\n\t    const mapper = new TableMapper(db, 'users', {\n\t      keyColumns: ['id'],\n\t    }).withTransforms({\n\t      updateTransform: (source: UpdatingUser | Updateable<Users>) =>\n", "        source instanceof UpdatingUser\n\t          ? {\n\t              name: `${source.firstName} ${source.lastName}`,\n\t              handle: source.handle,\n\t              email: source.email,\n\t            }\n\t          : source,\n\t    });\n\t    const insertReturn = await mapper.insert().returnOne(userRow1);\n\t    // test with UpdatingUser\n", "    await mapper\n\t      .update({ id: insertReturn.id })\n\t      .columns(['name'])\n\t      .run(UpdatingUser.create(0, userObject1));\n\t    const readUser1 = await mapper.select(insertReturn.id).returnOne();\n\t    expect(readUser1).toEqual({\n\t      id: insertReturn.id,\n\t      name: `${userObject1.firstName} ${userObject1.lastName}`,\n\t      email: userRow1.email,\n\t      handle: userRow1.handle,\n", "    });\n\t    // test with Updateable<Users>\n\t    const newName = 'Suzanne Smith Something';\n\t    await mapper.update({ id: insertReturn.id }).run({ name: newName });\n\t    const readUser2 = await mapper.select(insertReturn.id).returnOne();\n\t    expect(readUser2).toEqual({\n\t      id: insertReturn.id,\n\t      name: newName,\n\t      email: userRow1.email,\n\t      handle: userRow1.handle,\n", "    });\n\t  });\n\t});\n"]}
{"filename": "src/tests/update-columns.test.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\timport { createDB, resetDB, destroyDB } from './utils/test-setup';\n\timport { Database } from './utils/test-tables';\n\timport { createUserMapperReturningID } from './utils/test-mappers';\n\timport { USERS } from './utils/test-objects';\n\timport { TableMapper } from '../mappers/table-mapper';\n\tlet db: Kysely<Database>;\n\tlet userMapperReturningID: ReturnType<typeof createUserMapperReturningID>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n", "  userMapperReturningID = createUserMapperReturningID(db);\n\t});\n\tbeforeEach(() => resetDB(db));\n\tafterAll(() => destroyDB(db));\n\tdescribe('updating specific columns', () => {\n\t  it('subsets updating columns, excluding ID', async () => {\n\t    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\t    const updateValues = { id: 100, name: 'Sue Rex', email: 'rex@abc.def' };\n\t    const subsetQuery = userMapperReturningID\n\t      .update('id', '=', insertReturns[0].id)\n", "      .columns(['name'] as const); // allows readonly array\n\t    const updateReturns = await subsetQuery.returnAll(updateValues);\n\t    expect(updateReturns).toEqual([{ id: insertReturns[0].id }]);\n\t    const readUsers = await userMapperReturningID\n\t      .select('id', '=', insertReturns[0].id)\n\t      .returnOne();\n\t    expect(readUsers).toEqual({\n\t      id: insertReturns[0].id,\n\t      name: 'Sue Rex',\n\t      email: USERS[0].email,\n", "      handle: USERS[0].handle,\n\t    });\n\t  });\n\t  it('subsets updating columns, including ID', async () => {\n\t    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\t    const updateValues = { id: 100, name: 'Sue Rex', email: 'rex@abc.def' };\n\t    const subsetQuery = userMapperReturningID\n\t      .update('id', '=', insertReturns[0].id)\n\t      .columns(['id', 'name', 'email']);\n\t    const updateReturns = await subsetQuery.returnAll(updateValues);\n", "    expect(updateReturns).toEqual([{ id: 100 }]);\n\t    const readUsers = await userMapperReturningID\n\t      .select('id', '=', 100)\n\t      .returnOne();\n\t    expect(readUsers).toEqual({\n\t      id: 100,\n\t      name: 'Sue Rex',\n\t      email: 'rex@abc.def',\n\t      handle: USERS[0].handle,\n\t    });\n", "  });\n\t  it('requires all subsetted columns to be updated', async () => {\n\t    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\t    const updateValues = { name: 'Sue Rex' };\n\t    const subsetQuery = userMapperReturningID\n\t      .update('id', '=', insertReturns[0].id)\n\t      .columns(['name', 'email']);\n\t    expect(() => subsetQuery.returnAll(updateValues)).rejects.toThrow(\n\t      `column 'email' missing`\n\t    );\n", "    const success = await subsetQuery.run({ ...updateValues, email: null });\n\t    expect(success).toBe(true);\n\t  });\n\t  it('provides updateTransform with column subset', async () => {\n\t    expect.assertions(1);\n\t    const mapper = new TableMapper(db, 'users').withTransforms({\n\t      updateTransform: (source, columns) => {\n\t        expect(columns).toEqual(['name', 'handle']);\n\t        return source;\n\t      },\n", "    });\n\t    await mapper.update().columns(['name', 'handle']).run({\n\t      name: 'John Doe',\n\t      handle: 'johndoe',\n\t      email: 'jdoe@abc.def',\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/tests/insert-single.test.ts", "chunked_list": ["import { Insertable, Kysely, Selectable, Updateable } from 'kysely';\n\timport { TableMapper } from '../mappers/table-mapper';\n\timport { createDB, resetDB, destroyDB } from './utils/test-setup';\n\timport { Database, Posts } from './utils/test-tables';\n\timport {\n\t  createUserMapperReturningDefault,\n\t  createUserMapperReturningID,\n\t  createUserMapperReturningAll,\n\t  createUserMapperReturningNothing,\n\t  createUserMapperReturningDifferently,\n", "} from './utils/test-mappers';\n\timport { USERS, POSTS } from './utils/test-objects';\n\timport { ignore } from './utils/test-utils';\n\tlet db: Kysely<Database>;\n\tlet userMapperReturningDefault: ReturnType<\n\t  typeof createUserMapperReturningDefault\n\t>;\n\tlet userMapperReturningNothing: ReturnType<\n\t  typeof createUserMapperReturningNothing\n\t>;\n", "let userMapperReturningID: ReturnType<typeof createUserMapperReturningID>;\n\tlet userMapperReturningAll: ReturnType<typeof createUserMapperReturningAll>;\n\tlet postTableMapper: TableMapper<\n\t  Database,\n\t  'posts',\n\t  [],\n\t  ['*'],\n\t  Selectable<Posts>,\n\t  Insertable<Posts>,\n\t  Updateable<Posts>,\n", "  number,\n\t  ['*']\n\t>;\n\tlet postTableMapperReturningIDAndTitleAsT: TableMapper<\n\t  Database,\n\t  'posts',\n\t  [],\n\t  ['*'],\n\t  Selectable<Posts>,\n\t  Insertable<Posts>,\n", "  Updateable<Posts>,\n\t  number,\n\t  ['id', 'title as t']\n\t>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n\t  userMapperReturningDefault = createUserMapperReturningDefault(db);\n\t  userMapperReturningNothing = createUserMapperReturningNothing(db);\n\t  userMapperReturningID = createUserMapperReturningID(db);\n\t  userMapperReturningAll = createUserMapperReturningAll(db);\n", "  postTableMapper = new TableMapper(db, 'posts', {\n\t    insertReturnColumns: ['*'],\n\t  }).withTransforms({\n\t    countTransform: (count) => Number(count),\n\t  });\n\t  postTableMapperReturningIDAndTitleAsT = new TableMapper(db, 'posts', {\n\t    insertReturnColumns: ['id', 'title as t'],\n\t  }).withTransforms({\n\t    countTransform: (count) => Number(count),\n\t  });\n", "});\n\tbeforeEach(() => resetDB(db));\n\tafterAll(() => destroyDB(db));\n\tdescribe('inserting a single object without transformation', () => {\n\t  it('inserts one returning no columns by default', async () => {\n\t    const success = await userMapperReturningDefault.insert().run(USERS[0]);\n\t    expect(success).toBe(true);\n\t    const readUser0 = await userMapperReturningAll\n\t      .select('email', '=', USERS[0].email!)\n\t      .returnOne();\n", "    expect(readUser0?.email).toEqual(USERS[0].email);\n\t  });\n\t  it('inserts one explicitly returning no columns', async () => {\n\t    const insertReturn = await userMapperReturningNothing\n\t      .insert()\n\t      .returnOne(USERS[0]);\n\t    expect(insertReturn).toBe(undefined);\n\t    const readUser0 = await userMapperReturningAll\n\t      .select('email', '=', USERS[0].email!)\n\t      .returnOne();\n", "    expect(readUser0?.email).toEqual(USERS[0].email);\n\t    ignore('type errors', () => {\n\t      // @ts-expect-error - check return type\n\t      insertReturn.id;\n\t    });\n\t  });\n\t  it('inserts one returning configured return columns', async () => {\n\t    const insertReturn1 = await userMapperReturningID\n\t      .insert()\n\t      .returnOne(USERS[0]);\n", "    expect(insertReturn1.id).toBeGreaterThan(0);\n\t    expect(Object.keys(insertReturn1).length).toEqual(1);\n\t    const readUser0 = await userMapperReturningAll\n\t      .select('id', '=', insertReturn1.id)\n\t      .returnOne();\n\t    expect(readUser0?.email).toEqual(USERS[0].email);\n\t    const post0 = Object.assign({}, POSTS[0], { userId: insertReturn1.id });\n\t    const insertReturn2 = await postTableMapperReturningIDAndTitleAsT\n\t      .insert()\n\t      .returnOne(post0);\n", "    expect(insertReturn2.id).toBeGreaterThan(0);\n\t    expect(insertReturn2.t).toEqual(POSTS[0].title);\n\t    expect(Object.keys(insertReturn2).length).toEqual(2);\n\t    const readPost0 = await postTableMapper\n\t      .select(({ and, cmpr }) =>\n\t        and([\n\t          cmpr('id', '=', insertReturn2.id),\n\t          cmpr('title', '=', insertReturn2.t),\n\t        ])\n\t      )\n", "      .returnOne();\n\t    expect(readPost0?.likeCount).toEqual(post0.likeCount);\n\t    ignore('check return types', () => {\n\t      // @ts-expect-error - check return types\n\t      insertReturn1.title;\n\t      // @ts-expect-error - check return types\n\t      insertReturn1.userId;\n\t      // @ts-expect-error - check return types\n\t      insertReturn2.title;\n\t      // @ts-expect-error - check return types\n", "      insertReturn2.userId;\n\t    });\n\t  });\n\t  it('inserts multiple returning differently for inserts and updates', async () => {\n\t    const mapper = createUserMapperReturningDifferently(db);\n\t    const insertReturn = await mapper.insert().returnOne(USERS[0]);\n\t    expect(insertReturn).toEqual({\n\t      id: 1,\n\t      handle: USERS[0].handle,\n\t    });\n", "    // Ensure that returned objects can be accessed as expected.\n\t    ((_: number) => {})(insertReturn.id);\n\t    ((_: string) => {})(insertReturn.handle);\n\t    const newHandle = 'newHandle';\n\t    const updateReturn = await mapper\n\t      .update(1)\n\t      .returnOne({ handle: newHandle });\n\t    expect(updateReturn).toEqual({\n\t      name: USERS[0].name,\n\t    });\n", "    // Ensure that returned objects can be accessed as expected.\n\t    ((_: string) => {})(updateReturn!.name);\n\t    ignore('type errors', () => {\n\t      // @ts-expect-error - check return types\n\t      insertReturn.name;\n\t      // @ts-expect-error - check return types\n\t      updateReturn!.id;\n\t    });\n\t  });\n\t  it('inserts one configured to return all columns', async () => {\n", "    const insertReturn = await userMapperReturningAll\n\t      .insert()\n\t      .returnOne(USERS[0]);\n\t    expect(insertReturn.id).toBeGreaterThan(0);\n\t    expect(insertReturn.email).toEqual(USERS[0].email);\n\t    const expectedUser = Object.assign({}, USERS[0], { id: insertReturn.id });\n\t    expect(insertReturn).toEqual(expectedUser);\n\t  });\n\t  ignore('detects type errors inserting a single object', async () => {\n\t    // @ts-expect-error - inserted object must have all required columns\n", "    userMapperReturningAll.insert().returnOne({});\n\t    // @ts-expect-error - inserted object must have all required columns\n\t    userMapperReturningAll.insert().run({});\n\t    // @ts-expect-error - inserted object must have all required columns\n\t    userMapperReturningAll.insert().returnOne({ email: 'xyz@pdq.xyz' });\n\t    // @ts-expect-error - inserted object must have all required columns\n\t    userMapperReturningAll.insert().run({ email: 'xyz@pdq.xyz' });\n\t    // @ts-expect-error - only requested columns are returned\n\t    (await userMapperReturningID.insert().returnOne(USERS[0])).name;\n\t    // @ts-expect-error - only requested columns are returned\n", "    (await userMapperReturningDefault.insert().run(USERS[0])).name;\n\t  });\n\t});\n"]}
{"filename": "src/tests/update-compile.test.ts", "chunked_list": ["import { Kysely, Updateable } from 'kysely';\n\timport { TableMapper } from '../mappers/table-mapper';\n\timport { createDB, resetDB, destroyDB } from './utils/test-setup';\n\timport { Database, Users } from './utils/test-tables';\n\timport {\n\t  createUserMapperReturningID,\n\t  createUserMapperReturningIDAndHandleAsH,\n\t  createUserMapperReturningNothing,\n\t} from './utils/test-mappers';\n\timport { USERS } from './utils/test-objects';\n", "import { ignore } from './utils/test-utils';\n\timport { User } from './utils/test-types';\n\tlet db: Kysely<Database>;\n\tlet userMapperReturningNothing: ReturnType<\n\t  typeof createUserMapperReturningNothing\n\t>;\n\tlet userMapperReturningID: ReturnType<typeof createUserMapperReturningID>;\n\tlet userMapperReturningIDAndHandleAsH: ReturnType<\n\t  typeof createUserMapperReturningIDAndHandleAsH\n\t>;\n", "beforeAll(async () => {\n\t  db = await createDB();\n\t  userMapperReturningNothing = createUserMapperReturningNothing(db);\n\t  userMapperReturningID = createUserMapperReturningID(db);\n\t  userMapperReturningIDAndHandleAsH =\n\t    createUserMapperReturningIDAndHandleAsH(db);\n\t});\n\tbeforeEach(() => resetDB(db));\n\tafterAll(() => destroyDB(db));\n\tdescribe('compiled updates', () => {\n", "  it('updates nothing returning zero update count', async () => {\n\t    const updateValues = { email: 'new.email@xyz.pdq' };\n\t    const compilation = userMapperReturningID\n\t      .update({ id: 1 })\n\t      .columns(['email'])\n\t      .compile();\n\t    const success2 = await compilation.run({}, updateValues);\n\t    expect(success2).toBe(false);\n\t    const updateCount2 = await compilation.returnCount({}, updateValues);\n\t    expect(updateCount2).toEqual(0);\n", "    const updates2 = await compilation.returnAll({}, updateValues);\n\t    expect(updates2.length).toEqual(0);\n\t    const update2 = await compilation.returnOne({}, updateValues);\n\t    expect(update2).toBeNull();\n\t  });\n\t  it('compilations accept readonly updating objects', async () => {\n\t    const compilation = userMapperReturningNothing\n\t      .update('id', '=', 1)\n\t      .columns(['name', 'email'])\n\t      .compile();\n", "    const updateValues1 = {\n\t      name: 'Sue Rex' as const,\n\t      email: 'srex@abc.def' as const,\n\t    } as const;\n\t    await compilation.run({}, updateValues1);\n\t  });\n\t  it('compiles a non-returning update query without transformation', async () => {\n\t    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\t    const compilation = userMapperReturningNothing\n\t      .update('id', '=', insertReturns[0].id)\n", "      .columns(['name', 'email'])\n\t      .compile();\n\t    // test run()\n\t    const updateValues1 = {\n\t      name: 'Sue Rex' as const,\n\t      email: 'srex@abc.def' as const,\n\t    } as const;\n\t    const updateReturns1 = await compilation.run({}, updateValues1);\n\t    expect(updateReturns1).toBe(true);\n\t    const readUser1 = await userMapperReturningID\n", "      .select({ id: insertReturns[0].id })\n\t      .returnOne();\n\t    expect(readUser1?.name).toEqual(updateValues1.name);\n\t    expect(readUser1?.email).toEqual(updateValues1.email);\n\t    // test returnOne()\n\t    const updateValues2 = {\n\t      name: 'Johnny Rex' as const,\n\t      email: 'jrex@abc.def' as const,\n\t    } as const;\n\t    const updateReturns2 = await compilation.returnOne({}, updateValues2);\n", "    expect(updateReturns2).toBeUndefined();\n\t    const readUser2 = await userMapperReturningID\n\t      .select({ id: insertReturns[0].id })\n\t      .returnOne();\n\t    expect(readUser2?.name).toEqual(updateValues2.name);\n\t    expect(readUser2?.email).toEqual(updateValues2.email);\n\t    // test returnAll()\n\t    const updateReturns3 = await compilation.returnAll({}, updateValues1);\n\t    expect(updateReturns3).toBeUndefined();\n\t    // test returnCount()\n", "    const updateReturns4 = await compilation.returnCount({}, updateValues2);\n\t    expect(updateReturns4).toEqual(1);\n\t  });\n\t  it('compiles a returning update query without transformation', async () => {\n\t    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n\t    const compilation = userMapperReturningIDAndHandleAsH\n\t      .update('id', '=', insertReturns[0].id)\n\t      .columns(['name', 'email'])\n\t      .compile();\n\t    // test run()\n", "    const updateValues1 = { name: 'Sue Rex', email: 'srex@abc.def' };\n\t    const updateReturns1 = await compilation.run({}, updateValues1);\n\t    expect(updateReturns1).toBe(true);\n\t    const readUser1 = await userMapperReturningID\n\t      .select({ id: insertReturns[0].id })\n\t      .returnOne();\n\t    expect(readUser1?.name).toEqual(updateValues1.name);\n\t    expect(readUser1?.email).toEqual(updateValues1.email);\n\t    // test returnOne()\n\t    const updateValues2 = { name: 'Johnny Rex', email: 'jrex@abc.def' };\n", "    const updateReturns2 = await compilation.returnOne({}, updateValues2);\n\t    expect(updateReturns2?.id).toEqual(insertReturns[0].id);\n\t    expect(updateReturns2?.h).toEqual(USERS[0].handle);\n\t    const readUser2 = await userMapperReturningID\n\t      .select({ id: insertReturns[0].id })\n\t      .returnOne();\n\t    expect(readUser2?.name).toEqual(updateValues2.name);\n\t    expect(readUser2?.email).toEqual(updateValues2.email);\n\t    // test returnAll()\n\t    const updateReturns3 = await compilation.returnAll({}, updateValues1);\n", "    expect(updateReturns3[0].id).toEqual(insertReturns[0].id);\n\t    expect(updateReturns3[0].h).toEqual(USERS[0].handle);\n\t    // test returnCount()\n\t    const updateReturns4 = await compilation.returnCount({}, updateValues2);\n\t    expect(updateReturns4).toEqual(1);\n\t    ignore('check compile-time types', () => {\n\t      compilation.returnOne(\n\t        {},\n\t        {\n\t          name: 'xyz',\n", "          handle: 'pdq',\n\t          email: 'abc@def.hij',\n\t          // @ts-expect-error - only insertable columns are allowed\n\t          notThere: 32,\n\t        }\n\t      );\n\t      // @ts-expect-error - only expected columns are returned\n\t      updateReturns2!.handle;\n\t      // @ts-expect-error - only expected columns are returned\n\t      updateReturns3[0].handle;\n", "    });\n\t  });\n\t  it('accepts readonly parameters and updating objects', async () => {\n\t    const parameterization = userMapperReturningIDAndHandleAsH.parameterize<{\n\t      id: number;\n\t    }>(({ mapper, param }) =>\n\t      mapper.update({ id: param('id') }).columns(['name'])\n\t    );\n\t    const params = { id: 1 as const } as const;\n\t    const updateValues = {\n", "      name: 'Sue Rex' as const,\n\t      email: 'srex@abc.def' as const,\n\t    } as const;\n\t    await parameterization.run(params, updateValues);\n\t    await parameterization.returnAll(params, updateValues);\n\t    await parameterization.returnOne(params, updateValues);\n\t    await parameterization.returnCount(params, updateValues);\n\t  });\n\t  it('parameterizes a returning update query without transformation', async () => {\n\t    const insertReturns = await userMapperReturningID.insert().returnAll(USERS);\n", "    const parameterization = userMapperReturningIDAndHandleAsH.parameterize<{\n\t      id: number;\n\t    }>(({ mapper, param }) =>\n\t      mapper.update({ id: param('id') }).columns(['name'])\n\t    );\n\t    // test run()\n\t    const updateValues1 = { name: 'Sue Rex' };\n\t    const updateReturns1 = await parameterization.run(\n\t      { id: insertReturns[0].id },\n\t      updateValues1\n", "    );\n\t    expect(updateReturns1).toBe(true);\n\t    // test returnOne()\n\t    const updateValues2 = { name: 'Johnny Rex' };\n\t    const updateReturns2 = await parameterization.returnOne(\n\t      { id: insertReturns[1].id },\n\t      updateValues2\n\t    );\n\t    expect(updateReturns2?.id).toEqual(insertReturns[1].id);\n\t    expect(updateReturns2?.h).toEqual(USERS[1].handle);\n", "    // test returnAll()\n\t    const updateReturns3 = await parameterization.returnAll(\n\t      { id: insertReturns[2].id },\n\t      updateValues1\n\t    );\n\t    expect(updateReturns3[0].id).toEqual(insertReturns[2].id);\n\t    expect(updateReturns3[0].h).toEqual(USERS[2].handle);\n\t    // verify updates\n\t    const readUsers = await userMapperReturningID.select().returnAll();\n\t    expect(readUsers[0].name).toEqual(updateValues1.name);\n", "    expect(readUsers[1].name).toEqual(updateValues2.name);\n\t    expect(readUsers[2].name).toEqual(updateValues1.name);\n\t    // test returnCount()\n\t    const updateReturns4 = await parameterization.returnCount(\n\t      { id: insertReturns[0].id },\n\t      updateValues2\n\t    );\n\t    expect(updateReturns4).toEqual(1);\n\t    const readUser = await userMapperReturningID\n\t      .select({ id: insertReturns[0].id })\n", "      .returnOne();\n\t    expect(readUser?.name).toEqual(updateValues2.name);\n\t    ignore('parameterization type errors', () => {\n\t      // @ts-expect-error - errors on invalid parameter names\n\t      parameterization.returnAll({ handle: 'foo' }, updateValues1);\n\t      // @ts-expect-error - errors on invalid column names\n\t      updateReturns2!.handle;\n\t      // @ts-expect-error - errors on invalid column names\n\t      updateReturns3[0].handle;\n\t      userMapperReturningIDAndHandleAsH.parameterize<{ id: number }>(\n", "        ({ mapper, param }) =>\n\t          // @ts-expect-error - errors on invalid parameter name\n\t          mapper.update({ id: param('handle') }).columns(['name'])\n\t      );\n\t      userMapperReturningIDAndHandleAsH.parameterize<{ id: string }>(\n\t        ({ mapper, param }) =>\n\t          // @ts-expect-error - errors on invalid parameter type\n\t          mapper.update({ id: param('id') }).columns(['name'])\n\t      );\n\t      // @ts-expect-error - errors on invalid parameter value name\n", "      parameterization.returnOne({ handle: 'foo' }, updateValues1);\n\t      // @ts-expect-error - errors on invalid parameter value type\n\t      parameterization.returnOne({ id: 'foo' }, updateValues1);\n\t      parameterization.returnOne(\n\t        { id: 1 },\n\t        {\n\t          name: 'xyz',\n\t          handle: 'pdq',\n\t          email: 'abc@def.hij',\n\t          // @ts-expect-error - only updateable columns are allowed\n", "          notThere: 32,\n\t        }\n\t      );\n\t    });\n\t  });\n\t  it('compiles an update query with transformation', async () => {\n\t    expect.assertions(12);\n\t    const columnSubset: (keyof Updateable<Users>)[] = ['name'];\n\t    const transformMapper = new TableMapper(db, 'users', {\n\t      insertReturnColumns: ['*'],\n", "      updateReturnColumns: ['*'],\n\t    }).withTransforms({\n\t      selectTransform: (row) => {\n\t        const names = row.name.split(' ');\n\t        return new User(row.id, names[0], names[1], row.handle, row.email);\n\t      },\n\t      insertTransform: (source: User) => ({\n\t        name: `${source.firstName} ${source.lastName}`,\n\t        handle: source.handle,\n\t        email: source.email,\n", "      }),\n\t      insertReturnTransform: (_source, returns) => {\n\t        const names = returns.name.split(' ');\n\t        return new User(\n\t          returns.id,\n\t          names[0],\n\t          names[1],\n\t          returns.handle,\n\t          returns.email\n\t        );\n", "      },\n\t      updateTransform: (source: User, columns) => {\n\t        expect(columns).toEqual(columnSubset);\n\t        return {\n\t          name: `${source.firstName} ${source.lastName}`,\n\t          handle: source.handle,\n\t          email: source.email,\n\t        };\n\t      },\n\t      updateReturnTransform: (_source, returns) => {\n", "        const names = returns.name.split(' ');\n\t        return new User(\n\t          returns.id,\n\t          names[0],\n\t          names[1],\n\t          returns.handle,\n\t          returns.email\n\t        );\n\t      },\n\t      countTransform: (count) => Number(count),\n", "    });\n\t    const user1 = new User(0, 'John', 'Doe', 'johndoe', 'jdoe@abc.def');\n\t    const user2 = new User(0, 'Sam', 'Gamgee', 'sg', 'sg@abc.def');\n\t    const user3 = new User(0, 'Sue', 'Rex', 'srex', 'srex@abc.def');\n\t    const insertReturns = await transformMapper\n\t      .insert()\n\t      .returnAll([user1, user2, user3]);\n\t    const compilation = transformMapper\n\t      .update({ id: insertReturns[2].id })\n\t      .columns(columnSubset)\n", "      .compile();\n\t    // test returnOne()\n\t    const updateReturn1 = await compilation.returnOne({}, user1);\n\t    const expectedUser1 = User.create(insertReturns[2].id, {\n\t      firstName: user1.firstName,\n\t      lastName: user1.lastName,\n\t      handle: user3.handle,\n\t      email: user3.email,\n\t    });\n\t    expect(updateReturn1).toEqual(expectedUser1);\n", "    // Ensure that the provided columns are accessible\n\t    ((_: string) => {})(updateReturn1!.firstName);\n\t    const readUser1 = await transformMapper\n\t      .select({ id: insertReturns[2].id })\n\t      .returnOne();\n\t    expect(readUser1).toEqual(expectedUser1);\n\t    // test returnAll()\n\t    const updateReturn2 = await compilation.returnAll({}, user2);\n\t    const expectedUser2 = User.create(insertReturns[2].id, {\n\t      firstName: user2.firstName,\n", "      lastName: user2.lastName,\n\t      handle: user3.handle,\n\t      email: user3.email,\n\t    });\n\t    expect(updateReturn2[0]).toEqual(expectedUser2);\n\t    // Ensure that the provided columns are accessible\n\t    ((_: string) => {})(updateReturn2[0]!.firstName);\n\t    const readUser2 = await transformMapper\n\t      .select({ id: insertReturns[2].id })\n\t      .returnOne();\n", "    expect(readUser2).toEqual(expectedUser2);\n\t    // test run()\n\t    const success1 = await compilation.run({}, user1);\n\t    expect(success1).toBe(true);\n\t    const readUser3 = await transformMapper\n\t      .select({ id: insertReturns[2].id })\n\t      .returnOne();\n\t    expect(readUser3).toEqual(expectedUser1);\n\t    // test returnCount()\n\t    const count = await compilation.returnCount({}, user2);\n", "    expect(count).toEqual(1);\n\t    const readUser4 = await transformMapper\n\t      .select({ id: insertReturns[2].id })\n\t      .returnOne();\n\t    expect(readUser4).toEqual(expectedUser2);\n\t    ignore('check compile-time types', async () => {\n\t      // @ts-expect-error - only update objects are allowed\n\t      compilation.returnOne({}, USERS[0]);\n\t      // @ts-expect-error - only update objects are allowed\n\t      compilation.returnAll({}, USERS[0]);\n", "      // @ts-expect-error - only update objects are allowed\n\t      compilation.returnCount({}, USERS[0]);\n\t      // @ts-expect-error - only update objects are allowed\n\t      compilation.run({}, USERS[0]);\n\t      // @ts-expect-error - correct return is expected\n\t      (await compilation.returnOne({}, user1))!.name;\n\t      // @ts-expect-error - correct return is expected\n\t      (await compilation.returnAll({}, user2))[0].name;\n\t    });\n\t  });\n", "  it('parameterizes an update query with transformation', async () => {\n\t    const transformMapper = new TableMapper(db, 'users', {\n\t      insertReturnColumns: ['id'],\n\t      updateReturnColumns: ['id'],\n\t    }).withTransforms({\n\t      selectTransform: (row) => {\n\t        const names = row.name.split(' ');\n\t        return new User(row.id, names[0], names[1], row.handle, row.email);\n\t      },\n\t      insertTransform: (source: User) => ({\n", "        name: `${source.firstName} ${source.lastName}`,\n\t        handle: source.handle,\n\t        email: source.email,\n\t      }),\n\t      insertReturnTransform: (source: User, returns) => ({\n\t        id: returns.id,\n\t        firstName: source.firstName,\n\t        lastName: source.lastName,\n\t      }),\n\t      updateTransform: (source: User) => ({\n", "        name: `${source.firstName} ${source.lastName}`,\n\t        handle: source.handle,\n\t        email: source.email,\n\t      }),\n\t      updateReturnTransform: (source: User, returns) => ({\n\t        id: returns.id,\n\t        firstName: source.firstName,\n\t        lastName: source.lastName,\n\t      }),\n\t      countTransform: (count) => Number(count),\n", "    });\n\t    const user1 = new User(0, 'John', 'Doe', 'johndoe', 'jdoe@abc.def');\n\t    const user2 = new User(0, 'Sam', 'Gamgee', 'sg', 'sg@abc.def');\n\t    const user3 = new User(0, 'Sue', 'Rex', 'srex', 'srex@abc.def');\n\t    const insertReturns = await transformMapper\n\t      .insert()\n\t      .returnAll([user1, user2, user3]);\n\t    const parameterization = transformMapper.parameterize<{ id: number }>(\n\t      ({ mapper, param }) =>\n\t        mapper.update({ id: param('id') }).columns(['name'])\n", "    );\n\t    // test returnOne()\n\t    const updateReturn1 = await parameterization.returnOne(\n\t      { id: insertReturns[0].id },\n\t      user2\n\t    );\n\t    const expectedReturn1 = {\n\t      id: insertReturns[0].id,\n\t      firstName: user2.firstName,\n\t      lastName: user2.lastName,\n", "    };\n\t    expect(updateReturn1).toEqual(expectedReturn1);\n\t    // Ensure that the provided columns are accessible\n\t    ((_: string) => {})(updateReturn1!.firstName);\n\t    // test returnAll()\n\t    const updateReturn2 = await parameterization.returnAll(\n\t      { id: insertReturns[1].id },\n\t      user3\n\t    );\n\t    const expectedReturn2 = {\n", "      id: insertReturns[1].id,\n\t      firstName: user3.firstName,\n\t      lastName: user3.lastName,\n\t    };\n\t    expect(updateReturn2[0]).toEqual(expectedReturn2);\n\t    // Ensure that the provided columns are accessible\n\t    ((_: string) => {})(updateReturn2[0]!.firstName);\n\t    // test run()\n\t    const success1 = await parameterization.run(\n\t      { id: insertReturns[2].id },\n", "      user1\n\t    );\n\t    const expectedReturn3 = {\n\t      id: insertReturns[2].id,\n\t      firstName: user1.firstName,\n\t      lastName: user1.lastName,\n\t    };\n\t    expect(success1).toBe(true);\n\t    // verify updates\n\t    const readUsers = await transformMapper.select().returnAll();\n", "    expect(readUsers).toEqual([\n\t      User.create(expectedReturn1.id, {\n\t        ...expectedReturn1,\n\t        handle: user1.handle,\n\t        email: user1.email!,\n\t      }),\n\t      User.create(expectedReturn2.id, {\n\t        ...expectedReturn2,\n\t        handle: user2.handle,\n\t        email: user2.email!,\n", "      }),\n\t      User.create(expectedReturn3.id, {\n\t        ...expectedReturn3,\n\t        handle: user3.handle,\n\t        email: user3.email!,\n\t      }),\n\t    ]);\n\t    // test returnCount()\n\t    const count = await parameterization.returnCount(\n\t      { id: insertReturns[2].id },\n", "      user2\n\t    );\n\t    expect(count).toEqual(1);\n\t    const readUser = await transformMapper\n\t      .select({ id: insertReturns[2].id })\n\t      .returnOne();\n\t    expect(readUser).toEqual(\n\t      User.create(insertReturns[2].id, {\n\t        ...expectedReturn1,\n\t        handle: user3.handle,\n", "        email: user3.email!,\n\t      })\n\t    );\n\t    ignore('parameterization type errors', () => {\n\t      // @ts-expect-error - errors on invalid parameter names\n\t      parameterization.returnAll({ handle: 'foo' }, user1);\n\t      // @ts-expect-error - errors on invalid column names\n\t      updateReturn1!.handle;\n\t      // @ts-expect-error - errors on invalid column names\n\t      updateReturn2[0].handle;\n", "      transformMapper.parameterize<{ id: number }>(({ mapper, param }) =>\n\t        // @ts-expect-error - errors on invalid parameter name\n\t        mapper.update({ id: param('handle') }).columns(['name'])\n\t      );\n\t      transformMapper.parameterize<{ id: string }>(({ mapper, param }) =>\n\t        // @ts-expect-error - errors on invalid parameter type\n\t        mapper.update({ id: param('id') }).columns(['name'])\n\t      );\n\t      // @ts-expect-error - errors on invalid parameter value name\n\t      parameterization.returnOne({ handle: 'foo' }, user1);\n", "      // @ts-expect-error - errors on invalid parameter value type\n\t      parameterization.returnOne({ id: 'foo' }, user1);\n\t      parameterization.returnOne(\n\t        { id: 1 },\n\t        {\n\t          // @ts-expect-error - only updateable columns are allowed\n\t          name: 'xyz',\n\t          handle: 'pdq',\n\t          email: 'abc@def.hij',\n\t        }\n", "      );\n\t    });\n\t  });\n\t  it('requires all indicated columns to be updated', async () => {\n\t    await userMapperReturningID.insert().run(USERS);\n\t    const compilation = userMapperReturningID\n\t      .update()\n\t      .columns(['name', 'handle', 'email'])\n\t      .compile();\n\t    const updateValues = { name: 'John Doe', handle: 'johndoe' };\n", "    expect(() => compilation.returnOne({}, updateValues)).rejects.toThrow(\n\t      `column 'email' missing`\n\t    );\n\t    const success = await compilation.run({}, { ...updateValues, email: null });\n\t    expect(success).toBe(true);\n\t  });\n\t});\n"]}
{"filename": "src/tests/insert-transforms.test.ts", "chunked_list": ["import { Kysely, Updateable } from 'kysely';\n\timport { TableMapper } from '../mappers/table-mapper';\n\timport { createDB, resetDB, destroyDB } from './utils/test-setup';\n\timport { Database } from './utils/test-tables';\n\timport { createInsertTransformMapper } from './utils/test-mappers';\n\timport {\n\t  userRow1,\n\t  userRow2,\n\t  userRow3,\n\t  insertedUser1,\n", "  insertedUser2,\n\t  insertedUser3,\n\t  insertReturnedUser1,\n\t  insertReturnedUser2,\n\t  insertReturnedUser3,\n\t} from './utils/test-objects';\n\timport { InsertedUser, ReturnedUser, SelectedUser } from './utils/test-types';\n\tlet db: Kysely<Database>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n", "});\n\tbeforeEach(() => resetDB(db));\n\tafterAll(() => destroyDB(db));\n\tdescribe('inserting with transformation', () => {\n\t  it('transforms users for insertion without transforming return', async () => {\n\t    const insertTransformMapper = createInsertTransformMapper(db);\n\t    const insertReturn = await insertTransformMapper\n\t      .insert()\n\t      .returnOne(insertedUser1);\n\t    const readUser1 = await insertTransformMapper\n", "      .select({\n\t        id: insertReturn.id,\n\t      })\n\t      .returnOne();\n\t    expect(readUser1?.name).toEqual(\n\t      `${insertedUser1.firstName} ${insertedUser1.lastName}`\n\t    );\n\t    await insertTransformMapper\n\t      .insert()\n\t      .returnAll([insertedUser2, insertedUser3]);\n", "    const readUsers = await insertTransformMapper\n\t      .select('id', '>', insertReturn.id)\n\t      .returnAll();\n\t    expect(readUsers.length).toEqual(2);\n\t    expect(readUsers[0].name).toEqual(\n\t      `${insertedUser2.firstName} ${insertedUser2.lastName}`\n\t    );\n\t    expect(readUsers[1].name).toEqual(\n\t      `${insertedUser3.firstName} ${insertedUser3.lastName}`\n\t    );\n", "  });\n\t  it('transforms insertion return into object without transforming insertion', async () => {\n\t    const insertReturnTransformMapper = new TableMapper(db, 'users', {\n\t      insertReturnColumns: ['id', 'name'],\n\t      updateReturnColumns: ['id', 'name'],\n\t    }).withTransforms({\n\t      insertReturnTransform: (source, returns) => {\n\t        const names = returns.name.split(' ');\n\t        return new ReturnedUser(\n\t          returns.id,\n", "          names[0],\n\t          names[1],\n\t          source.handle,\n\t          source.email || null\n\t        );\n\t      },\n\t      countTransform: (count) => Number(count),\n\t    });\n\t    const insertReturn = await insertReturnTransformMapper\n\t      .insert()\n", "      .returnOne(userRow1);\n\t    expect(insertReturn).toEqual(insertReturnedUser1);\n\t    const insertReturns = await insertReturnTransformMapper\n\t      .insert()\n\t      .returnAll([userRow2, userRow3]);\n\t    expect(insertReturns).toEqual([insertReturnedUser2, insertReturnedUser3]);\n\t    // test that updates return table rows\n\t    const updatedUser = await insertReturnTransformMapper\n\t      .update({ id: insertReturn.id })\n\t      .returnOne({ name: 'Updated Name' });\n", "    expect(updatedUser).toEqual({ id: insertReturn.id, name: 'Updated Name' });\n\t    // ensure return type can be accessed as a row\n\t    ((_: string) => {})(updatedUser!.name);\n\t  });\n\t  it('transforms insertion return into primitive without transforming insertion', async () => {\n\t    const insertReturnTransformMapper = new TableMapper(db, 'users', {\n\t      insertReturnColumns: ['id'],\n\t    }).withTransforms({\n\t      insertReturnTransform: (_source, returns) => returns.id,\n\t      countTransform: (count) => Number(count),\n", "    });\n\t    const insertReturn = await insertReturnTransformMapper\n\t      .insert()\n\t      .returnOne(userRow1);\n\t    expect(insertReturn).toEqual(1);\n\t    // ensure return type can be accessed as a number\n\t    ((_: number) => {})(insertReturn);\n\t    const insertReturns = await insertReturnTransformMapper\n\t      .insert()\n\t      .returnAll([userRow2, userRow3]);\n", "    expect(insertReturns).toEqual([2, 3]);\n\t    // ensure return type can be accessed as a number\n\t    ((_: number) => {})(insertReturns[0]);\n\t  });\n\t  it(\"transforms insertion and insertion return, columns is ['*']\", async () => {\n\t    expect.assertions(5);\n\t    const insertAndReturnTransformMapper = new TableMapper(db, 'users', {\n\t      insertReturnColumns: ['id'],\n\t    }).withTransforms({\n\t      insertTransform: (source: InsertedUser, columns) => {\n", "        expect(columns).toEqual(['*']);\n\t        return {\n\t          name: `${source.firstName} ${source.lastName}`,\n\t          handle: source.handle,\n\t          email: source.email,\n\t        };\n\t      },\n\t      insertReturnTransform: (source: InsertedUser, returns) =>\n\t        new ReturnedUser(\n\t          returns.id,\n", "          source.firstName,\n\t          source.lastName,\n\t          source.handle,\n\t          source.email\n\t        ),\n\t      countTransform: (count) => Number(count),\n\t    });\n\t    const insertReturn = await insertAndReturnTransformMapper\n\t      .insert()\n\t      .returnOne(insertedUser1);\n", "    expect(insertReturn).toEqual(insertReturnedUser1);\n\t    // ensure return type can be accessed as a ReturnedUser\n\t    ((_: string) => {})(insertReturn.firstName);\n\t    const insertReturns = await insertAndReturnTransformMapper\n\t      .insert()\n\t      .returnAll([insertedUser2, insertedUser3]);\n\t    expect(insertReturns).toEqual([insertReturnedUser2, insertReturnedUser3]);\n\t    // ensure return type can be accessed as a ReturnedUser\n\t    ((_: string) => {})(insertReturns[0].firstName);\n\t  });\n", "  it('returns SelectedObject with updates returning rows', async () => {\n\t    const transformMapper = new TableMapper(db, 'users', {\n\t      insertReturnColumns: ['id', 'name'],\n\t      updateReturnColumns: ['id', 'name'],\n\t    }).withTransforms({\n\t      insertReturnTransform: (source, results) => {\n\t        const names = results.name.split(' ');\n\t        return SelectedUser.create(results.id, {\n\t          firstName: names[0],\n\t          lastName: names[1],\n", "          handle: source.handle,\n\t          email: source.email || null,\n\t        });\n\t      },\n\t      updateTransform: (\n\t        source: SelectedUser | Updateable<Database['users']>\n\t      ) => {\n\t        if (source instanceof SelectedUser) {\n\t          return {\n\t            name: `${source.firstName} ${source.lastName}`,\n", "            handle: source.handle,\n\t            email: source.email,\n\t          };\n\t        }\n\t        return source;\n\t      },\n\t      selectTransform: (row) => {\n\t        const names = row.name.split(' ');\n\t        return SelectedUser.create(row.id, {\n\t          firstName: names[0],\n", "          lastName: names[1],\n\t          handle: row.handle,\n\t          email: row.email,\n\t        });\n\t      },\n\t    });\n\t    // test returnOne()\n\t    const names1 = userRow1.name.split(' ');\n\t    const expectedUser1 = SelectedUser.create(1, {\n\t      firstName: names1[0],\n", "      lastName: names1[1],\n\t      handle: userRow1.handle,\n\t      email: userRow1.email,\n\t    });\n\t    const insertReturn = await transformMapper.insert().returnOne(userRow1);\n\t    expect(insertReturn).toEqual(expectedUser1);\n\t    // ensure return type can be accessed as a SelectedUser\n\t    ((_: string) => {})(insertReturn.firstName);\n\t    const readUser = await transformMapper\n\t      .select({\n", "        id: insertReturn.id,\n\t      })\n\t      .returnOne();\n\t    expect(readUser).toEqual(expectedUser1);\n\t    // test returnAll()\n\t    const names2 = userRow2.name.split(' ');\n\t    const expectedUser2 = SelectedUser.create(2, {\n\t      firstName: names2[0],\n\t      lastName: names2[1],\n\t      handle: userRow2.handle,\n", "      email: userRow2.email,\n\t    });\n\t    const names3 = userRow3.name.split(' ');\n\t    const expectedUser3 = SelectedUser.create(3, {\n\t      firstName: names3[0],\n\t      lastName: names3[1],\n\t      handle: userRow3.handle,\n\t      email: userRow3.email,\n\t    });\n\t    const insertReturns = await transformMapper\n", "      .insert()\n\t      .returnAll([userRow2, userRow3]);\n\t    expect(insertReturns).toEqual([expectedUser2, expectedUser3]);\n\t    // ensure return type can be accessed as a SelectedUser\n\t    ((_: string) => {})(insertReturns[0].firstName);\n\t    ((_: string) => {})(insertReturns[1].firstName);\n\t    const readUsers = await transformMapper\n\t      .select('id', '>', insertReturn.id)\n\t      .returnAll();\n\t    expect(readUsers).toEqual([expectedUser2, expectedUser3]);\n", "    // test that updates return rows\n\t    const updateReturn = await transformMapper\n\t      .update({ id: 1 })\n\t      .returnOne(expectedUser2);\n\t    expect(updateReturn).toEqual({\n\t      id: 1,\n\t      name: `${expectedUser2.firstName} ${expectedUser2.lastName}`,\n\t    });\n\t    // ensure return type can be accessed as a row\n\t    ((_: string) => {})(updateReturn!.name);\n", "  });\n\t});\n"]}
{"filename": "src/tests/delete.test.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\timport { createDB, resetDB, destroyDB } from './utils/test-setup';\n\timport { Database } from './utils/test-tables';\n\timport {\n\t  createUserMapperReturningAll,\n\t  createUserMapperReturningDefault,\n\t  createUserMapperReturningNothing,\n\t} from './utils/test-mappers';\n\timport { USERS } from './utils/test-objects';\n\timport { ignore } from './utils/test-utils';\n", "import { TableMapper } from '../mappers/table-mapper';\n\tlet db: Kysely<Database>;\n\tlet userMapper: ReturnType<typeof createUserMapperReturningAll>;\n\tlet userMapperReturningNothing: ReturnType<\n\t  typeof createUserMapperReturningNothing\n\t>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n\t  userMapper = createUserMapperReturningAll(db);\n\t  userMapperReturningNothing = createUserMapperReturningNothing(db);\n", "});\n\tbeforeEach(() => resetDB(db));\n\tafterAll(() => destroyDB(db));\n\tdescribe('deleting rows via TableMapper', () => {\n\t  it('accepts readonly filters', async () => {\n\t    const filter = { name: 'Not There' as const } as const;\n\t    await userMapper.delete(filter).run();\n\t    await userMapper.delete(filter).returnCount();\n\t  });\n\t  it(\"doesn't delete anything if no rows match\", async () => {\n", "    const count = await userMapper\n\t      .delete({ name: USERS[0].name })\n\t      .returnCount();\n\t    expect(count).toEqual(0);\n\t    const success = await userMapper.delete({ name: USERS[0].name }).run();\n\t    expect(success).toEqual(false);\n\t  });\n\t  it('deletes rows without returning a count', async () => {\n\t    const testMapper = new TableMapper(db, 'users').withTransforms({\n\t      countTransform: (count) => Number(count),\n", "    });\n\t    await testMapper.insert().run(USERS);\n\t    const success = await testMapper.delete({ name: USERS[0].name }).run();\n\t    expect(success).toBe(true);\n\t    const users = await testMapper.select().returnAll();\n\t    expect(users.length).toEqual(1);\n\t    expect(users[0].handle).toEqual(USERS[1].handle);\n\t  });\n\t  it('deletes rows returning the deletion count as bigint default', async () => {\n\t    const defaultMapper = createUserMapperReturningDefault(db);\n", "    const count1 = await defaultMapper\n\t      .delete({ name: USERS[0].name })\n\t      .returnCount();\n\t    expect(count1).toEqual(BigInt(0));\n\t    await defaultMapper.insert().run(USERS);\n\t    const count2 = await defaultMapper\n\t      .delete({ name: USERS[0].name })\n\t      .returnCount();\n\t    expect(count2).toEqual(BigInt(2));\n\t    const users = await defaultMapper.select().returnAll();\n", "    expect(users.length).toEqual(1);\n\t    expect(users[0].handle).toEqual(USERS[1].handle);\n\t  });\n\t  it('deletes rows returning the deletion count inferred as a number', async () => {\n\t    const testMapper = new TableMapper(db, 'users').withTransforms({\n\t      countTransform: (count) => Number(count),\n\t    });\n\t    await testMapper.insert().run(USERS);\n\t    const count = await testMapper\n\t      .delete({ name: USERS[0].name })\n", "      .returnCount();\n\t    expect(count).toEqual(2);\n\t  });\n\t  it('deletes rows returning the deletion count as number', async () => {\n\t    const count1 = await userMapper\n\t      .delete({ name: USERS[0].name })\n\t      .returnCount();\n\t    expect(count1).toEqual(0);\n\t    await userMapper.insert().run(USERS);\n\t    const count2 = await userMapper\n", "      .delete({ name: USERS[0].name })\n\t      .returnCount();\n\t    expect(count2).toEqual(2);\n\t    const users = await userMapper.select().returnAll();\n\t    expect(users.length).toEqual(1);\n\t    expect(users[0].handle).toEqual(USERS[1].handle);\n\t  });\n\t  it('deletes all rows without a filter', async () => {\n\t    await userMapper.insert().run(USERS);\n\t    const count1 = await userMapper.delete().returnCount();\n", "    expect(count1).toEqual(3);\n\t    const users1 = await userMapper.select().returnAll();\n\t    expect(users1.length).toEqual(0);\n\t    await userMapper.insert().run(USERS);\n\t    const success = await userMapper.delete().run();\n\t    expect(success).toBe(true);\n\t    const users2 = await userMapper.select().returnAll();\n\t    expect(users2.length).toEqual(0);\n\t  });\n\t  it('deletes rows specified via compound filter', async () => {\n", "    await userMapper.insert().run(USERS);\n\t    const count1 = await userMapper\n\t      .delete(({ and, cmpr }) =>\n\t        and([\n\t          cmpr('name', '=', USERS[0].name),\n\t          cmpr('handle', '=', USERS[0].handle),\n\t        ])\n\t      )\n\t      .returnCount();\n\t    expect(count1).toEqual(1);\n", "    const count2 = await userMapper\n\t      .delete(({ or, cmpr }) =>\n\t        or([\n\t          cmpr('name', '=', USERS[0].name),\n\t          cmpr('handle', '=', USERS[0].handle),\n\t        ])\n\t      )\n\t      .returnCount();\n\t    expect(count2).toEqual(1);\n\t  });\n", "  it('deletes rows specified via binary operation', async () => {\n\t    await userMapper.insert().run(USERS);\n\t    const count1 = await userMapper\n\t      .delete('name', '=', USERS[0].name)\n\t      .returnCount();\n\t    expect(count1).toEqual(2);\n\t    const users = await userMapper.select().returnAll();\n\t    expect(users.length).toEqual(1);\n\t    expect(users[0].handle).toEqual(USERS[1].handle);\n\t  });\n", "  it('modifies a delete query builder', async () => {\n\t    await userMapper.insert().run(USERS);\n\t    await userMapper.insert().run({ ...USERS[1], handle: 'user4' });\n\t    const count1 = await userMapper\n\t      .delete()\n\t      .modify((qb) => qb.where('name', '=', USERS[0].name))\n\t      .returnCount();\n\t    expect(count1).toEqual(2);\n\t    const count2 = await userMapper\n\t      .delete({ name: USERS[1].name })\n", "      .modify((qb) => qb.where('handle', '=', 'user4'))\n\t      .returnCount();\n\t    expect(count2).toEqual(1);\n\t    const users = await userMapper.select().returnAll();\n\t    expect(users.length).toEqual(1);\n\t  });\n\t  it('compiles an unparameterized delete query', async () => {\n\t    await userMapper.insert().run(USERS);\n\t    const compilation = userMapper.delete({ name: USERS[0].name }).compile();\n\t    const count1 = await compilation.returnCount({});\n", "    expect(count1).toEqual(2);\n\t    const users = await userMapper.select().returnAll();\n\t    expect(users.length).toEqual(1);\n\t    expect(users[0].handle).toEqual(USERS[1].handle);\n\t    await userMapper.insert().run(USERS[2]);\n\t    const success = await compilation.run({});\n\t    expect(success).toBe(true);\n\t    const users2 = await userMapper.select().returnAll();\n\t    expect(users2.length).toEqual(1);\n\t    expect(users2[0].handle).toEqual(USERS[1].handle);\n", "  });\n\t  it('parameterizes and compiles a delete query', async () => {\n\t    const parameterization = userMapper.parameterize<{ targetName: string }>(\n\t      ({ mapper, param }) => mapper.delete({ name: param('targetName') })\n\t    );\n\t    const count1 = await parameterization.returnCount({\n\t      targetName: USERS[0].name,\n\t    });\n\t    expect(count1).toEqual(0);\n\t    await userMapper.insert().run(USERS);\n", "    const count2 = await parameterization.returnCount({\n\t      targetName: USERS[0].name,\n\t    });\n\t    expect(count2).toEqual(2);\n\t    const users = await userMapper.select().returnAll();\n\t    expect(users.length).toEqual(1);\n\t    expect(users[0].handle).toEqual(USERS[1].handle);\n\t    const count3 = await parameterization.returnCount({\n\t      targetName: USERS[1].name,\n\t    });\n", "    expect(count3).toEqual(1);\n\t    const users2 = await userMapper.select().returnAll();\n\t    expect(users2.length).toEqual(0);\n\t    ignore('parameterization type errors', () => {\n\t      // @ts-expect-error - errors on invalid parameter names\n\t      parameterization.run({ notThere: 'foo' });\n\t      userMapper.parameterize<{ name: string }>(\n\t        // @ts-expect-error - errors on invalid parameter name\n\t        ({ mapper, param }) => mapper.select({ name: param('notThere') })\n\t      );\n", "      userMapper.parameterize<{ name: number }>(\n\t        // @ts-expect-error - errors on invalid parameter type\n\t        ({ mapper, param }) => mapper.select({ name: param('name') })\n\t      );\n\t      // @ts-expect-error - errors on invalid parameter value name\n\t      parameterization.run({ notThere: 'foo' });\n\t      // @ts-expect-error - errors on invalid parameter value type\n\t      parameterization.run({ targetName: 123 });\n\t    });\n\t  });\n", "  ignore('detects deletion type errors', async () => {\n\t    // @ts-expect-error - table must have all filter fields\n\t    userMapper.delete({ notThere: 'xyz' });\n\t    // @ts-expect-error - table must have all filter fields\n\t    userMapper.delete('notThere', '=', 'foo');\n\t    userMapper.delete(({ or, cmpr }) =>\n\t      // @ts-expect-error - only table columns are accessible via anyOf()\n\t      or([cmpr('notThere', '=', 'xyz'), cmpr('alsoNotThere', '=', 'Sue')])\n\t    );\n\t    userMapper.delete(({ or, cmpr }) =>\n", "      // @ts-expect-error - only table columns are accessible via allOf()\n\t      or([cmpr('notThere', '=', 'xyz'), cmpr('alsoNotThere', '=', 'Sue')])\n\t    );\n\t    // @ts-expect-error - ID filter must have correct type\n\t    userMapper.delete('str');\n\t    // @ts-expect-error - ID filter must have correct type\n\t    userMapper.delete(['str']);\n\t    // @ts-expect-error - ID filter not allowed when when no ID column\n\t    userMapperReturningNothing.delete(1);\n\t    // @ts-expect-error - ID filter not allowed when when no ID column\n", "    userMapperReturningNothing.delete([1]);\n\t  });\n\t});\n"]}
{"filename": "src/tests/select-general.test.ts", "chunked_list": ["/**\n\t * Tests TableMapper.selectMany(), TableMapper.selectOne(), and query filters.\n\t */\n\timport { Kysely } from 'kysely';\n\timport { TableMapper } from '../mappers/table-mapper';\n\timport { createDB, resetDB, destroyDB } from './utils/test-setup';\n\timport { Database } from './utils/test-tables';\n\timport {\n\t  createUserMapperReturningID,\n\t  createUserMapperReturningNothing,\n", "} from './utils/test-mappers';\n\timport { USERS } from './utils/test-objects';\n\timport { ignore } from './utils/test-utils';\n\tlet db: Kysely<Database>;\n\tlet userMapper: ReturnType<typeof createUserMapperReturningID>;\n\tlet userMapperReturningNothing: ReturnType<\n\t  typeof createUserMapperReturningNothing\n\t>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n", "  userMapper = createUserMapperReturningID(db);\n\t  userMapperReturningNothing = createUserMapperReturningNothing(db);\n\t});\n\tbeforeEach(() => resetDB(db));\n\tafterAll(() => destroyDB(db));\n\tdescribe('general selection', () => {\n\t  it('compiles an unparameterized select query', async () => {\n\t    await userMapper.insert().run(USERS);\n\t    const compilation = userMapper.select({ name: USERS[0].name }).compile();\n\t    const users = await compilation.returnAll({});\n", "    expect(users.length).toEqual(2);\n\t    expect(users[0].handle).toEqual(USERS[0].handle);\n\t    expect(users[1].handle).toEqual(USERS[2].handle);\n\t    // Ensure that the provided columns are not optional\n\t    ((_: string) => {})(users[0].handle);\n\t    const user = await compilation.returnOne({});\n\t    expect(user?.handle).toEqual(USERS[0].handle);\n\t    // Ensure that the provided columns are not optional\n\t    ((_: string) => {})(user!.name);\n\t    ignore('compilation type errors', () => {\n", "      // @ts-expect-error - errors on invalid column names\n\t      users[0].notThere;\n\t      // @ts-expect-error - errors on invalid column names\n\t      user!.notThere;\n\t    });\n\t  });\n\t  it('parameterizes and compiles a select query', async () => {\n\t    await userMapper.insert().run(USERS);\n\t    const parameterization = userMapper.parameterize<{ name: string }>(\n\t      ({ mapper, param }) => mapper.select({ name: param('name') })\n", "    );\n\t    // test returnAll() returning multiple\n\t    const users = await parameterization.returnAll({ name: USERS[0].name });\n\t    expect(users.length).toEqual(2);\n\t    expect(users[0].handle).toEqual(USERS[0].handle);\n\t    expect(users[1].handle).toEqual(USERS[2].handle);\n\t    // Ensure that the provided columns are not optional\n\t    ((_: string) => {})(users[0].handle);\n\t    // test returnAll() returning none\n\t    const users2 = await parameterization.returnAll({ name: 'not there' });\n", "    expect(users2.length).toEqual(0);\n\t    // test returnOne() returning one\n\t    const user = await parameterization.returnOne({ name: USERS[1].name });\n\t    expect(user?.handle).toEqual(USERS[1].handle);\n\t    // Ensure that the provided columns are not optional\n\t    ((_: string) => {})(user!.name);\n\t    // test returnOne() returning none\n\t    const user2 = await parameterization.returnOne({ name: 'not there' });\n\t    expect(user2).toBeNull();\n\t    ignore('parameterization type errors', () => {\n", "      // @ts-expect-error - errors on invalid parameter names\n\t      parameterization.returnAll({ notThere: 'foo' });\n\t      // @ts-expect-error - errors on invalid column names\n\t      users[0].notThere;\n\t      // @ts-expect-error - errors on invalid column names\n\t      user!.notThere;\n\t      userMapper.parameterize<{ name: string }>(\n\t        // @ts-expect-error - errors on invalid parameter name\n\t        ({ mapper, param }) => mapper.select({ name: param('notThere') })\n\t      );\n", "      userMapper.parameterize<{ name: number }>(\n\t        // @ts-expect-error - errors on invalid parameter type\n\t        ({ mapper, param }) => mapper.select({ name: param('name') })\n\t      );\n\t      // @ts-expect-error - errors on invalid parameter value name\n\t      parameterization.returnOne({ notThere: 'foo' });\n\t      // @ts-expect-error - errors on invalid parameter value type\n\t      parameterization.returnOne({ name: 123 });\n\t    });\n\t  });\n", "  it('modifies the underlying query builder', async () => {\n\t    await userMapper.insert().run(USERS);\n\t    const users = await userMapper\n\t      .select()\n\t      .modify((qb) =>\n\t        qb.where('name', '=', USERS[0].name).orderBy('handle', 'desc')\n\t      )\n\t      .returnAll();\n\t    expect(users.length).toEqual(2);\n\t    expect(users[0].handle).toEqual(USERS[2].handle);\n", "    expect(users[1].handle).toEqual(USERS[0].handle);\n\t    const user = await userMapper\n\t      .select()\n\t      .modify((qb) =>\n\t        qb.where('name', '=', USERS[0].name).orderBy('handle', 'desc')\n\t      )\n\t      .returnOne();\n\t    expect(user?.handle).toEqual(USERS[2].handle);\n\t  });\n\t  it('does not modify the underlying selected columns', async () => {\n", "    await userMapper.insert().run(USERS);\n\t    const users = await userMapper\n\t      .select()\n\t      .modify((qb) => qb.select('name').orderBy('handle', 'desc'))\n\t      .returnAll();\n\t    expect(users).toEqual([\n\t      { ...USERS[2], id: 3 },\n\t      { ...USERS[1], id: 2 },\n\t      { ...USERS[0], id: 1 },\n\t    ]);\n", "    // Ensure that columns can be addressed by name.\n\t    ((_: number) => {})(users[0].id);\n\t    ((_: string) => {})(users[0].handle);\n\t    ((_: string) => {})(users[0].name);\n\t    ((_: string) => {})(users[0].email!);\n\t    const user = await userMapper\n\t      .select()\n\t      .modify((qb) => qb.select('name').orderBy('handle', 'desc'))\n\t      .returnOne();\n\t    expect(user).toEqual({ ...USERS[2], id: 3 });\n", "    // Ensure that columns can be addressed by name.\n\t    ((_: number) => {})(user!.id);\n\t    ((_: string) => {})(user!.handle);\n\t    ((_: string) => {})(user!.name);\n\t    ((_: string) => {})(user!.email!);\n\t    ignore('detects modify() type errors', async () => {\n\t      // @ts-expect-error - cannot access invalid columns\n\t      users[0].notThere;\n\t      // @ts-expect-error - cannot access invalid columns\n\t      user!.notThere;\n", "    });\n\t  });\n\t  it('selects via a multi-column key tuple (definition order)', async () => {\n\t    const mapper = new TableMapper(db, 'users', {\n\t      keyColumns: ['id', 'name'],\n\t    });\n\t    await mapper.insert().run(USERS);\n\t    const users = await mapper.select([3, 'Sue']).returnAll();\n\t    expect(users.length).toEqual(1);\n\t    expect(users[0].name).toEqual(USERS[2].name);\n", "    ignore('detects key colum tuple type errors', () => {\n\t      // @ts-expect-error - key tuple must have correct length\n\t      mapper.select(['Sue']);\n\t      // @ts-expect-error - key tuple must have correct length\n\t      mapper.select(['Sue', 3, 'foo']);\n\t      // @ts-expect-error - key tuple must have correct types\n\t      mapper.select(['Sue', 'foo']);\n\t      // @ts-expect-error - primitive key values are not allowed\n\t      mapper.select('Sue');\n\t      // @ts-expect-error - primitive key values are not allowed\n", "      mapper.select(1);\n\t    });\n\t  });\n\t  it('selects via a multi-column key tuple (different order)', async () => {\n\t    const mapper = new TableMapper(db, 'users', {\n\t      keyColumns: ['name', 'id'],\n\t    });\n\t    await mapper.insert().run(USERS);\n\t    const users = await mapper.select(['Sue', 3]).returnAll();\n\t    expect(users.length).toEqual(1);\n", "    expect(users[0].name).toEqual(USERS[2].name);\n\t    ignore('detects key colum tuple type errors', () => {\n\t      // @ts-expect-error - key tuple must have correct length\n\t      mapper.select(['Sue']);\n\t      // @ts-expect-error - key tuple must have correct length\n\t      mapper.select(['Sue', 3, 'foo']);\n\t      // @ts-expect-error - key tuple must have correct types\n\t      mapper.select(['Sue', 'foo']);\n\t      // @ts-expect-error - primitive key values are not allowed\n\t      mapper.select('Sue');\n", "      // @ts-expect-error - primitive key values are not allowed\n\t      mapper.select(1);\n\t    });\n\t  });\n\t  ignore('detects select(filter) type errors', async () => {\n\t    // @ts-expect-error - doesn't allow only two arguments\n\t    userMapper.select('name', '=');\n\t    // @ts-expect-error - object filter fields must be valid\n\t    userMapper.select({ notThere: 'xyz' });\n\t    userMapper.select(({ or, cmpr }) =>\n", "      // @ts-expect-error - where expression columns must be valid\n\t      or([cmpr('notThere', '=', 'Sue')])\n\t    );\n\t    // @ts-expect-error - binary op filter fields must be valid\n\t    userMapper.select('notThere', '=', 'foo');\n\t    // @ts-expect-error - binary op filter fields must be valid\n\t    userMapper.select('users.notThere', '=', 'foo');\n\t    // @ts-expect-error - ID filter must have correct type\n\t    userMapper.select('str');\n\t    // @ts-expect-error - ID filter must have correct type\n", "    userMapper.select(['str']);\n\t    // @ts-expect-error - ID filter not allowed when when no ID column\n\t    userMapperReturningNothing.select(1);\n\t    // @ts-expect-error - ID filter not allowed when when no ID column\n\t    userMapperReturningNothing.select([1]);\n\t  });\n\t});\n"]}
{"filename": "src/tests/transform-types.test.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\timport { TableMapper } from '../mappers/table-mapper';\n\timport { createDB, resetDB, destroyDB } from './utils/test-setup';\n\timport { Database } from './utils/test-tables';\n\timport { User } from './utils/test-types';\n\timport { ignore } from './utils/test-utils';\n\timport { createInsertTransformMapper } from './utils/test-mappers';\n\tlet db: Kysely<Database>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n", "});\n\tbeforeEach(() => resetDB(db));\n\tafterAll(() => destroyDB(db));\n\tdescribe('table mapper transform type checks', () => {\n\t  ignore('detects invalid select transform configuration', () => {\n\t    new TableMapper(db, 'users').withTransforms({\n\t      // @ts-expect-error - invalid select transform\n\t      selectTransform: (user: User) => user,\n\t    });\n\t  });\n", "  ignore('detects invalid insert transform configuration', () => {\n\t    new TableMapper(db, 'users').withTransforms({\n\t      // @ts-expect-error - invalid insert transform\n\t      insertTransform: (user: User) => user,\n\t    });\n\t  });\n\t  ignore('detects invalid update transform configuration', () => {\n\t    new TableMapper(db, 'users').withTransforms({\n\t      // @ts-expect-error - invalid update transform\n\t      updateTransform: (_user) => ({ noId: 1 }),\n", "    });\n\t  });\n\t  ignore('detects invalid update return transform return', async () => {\n\t    const mapper = new TableMapper(db, 'users', { keyColumns: ['id'] });\n\t    mapper.withTransforms({\n\t      selectTransform: (_user) => new User(1, 'John', 'Doe', 'jdoe', 'x@y.z'),\n\t      updateTransform: (user: User) => ({\n\t        id: user.id,\n\t        name: `${user.firstName} ${user.lastName}`,\n\t        handle: user.handle,\n", "        email: user.email,\n\t      }),\n\t      updateReturnTransform: (_user, returns) => returns,\n\t    });\n\t    (await mapper\n\t      .update({ id: 1 })\n\t      // @ts-expect-error - ensure that return type is User\n\t      .returnOne(new User(1, 'John', 'Doe', 'jdoe', 'jdoe@abc.def')))!.name;\n\t  });\n\t  ignore('detects insertion transformation type errors', async () => {\n", "    const insertTransformMapper = createInsertTransformMapper(db);\n\t    // @ts-expect-error - requires InsertedObject as input\n\t    await insertTransformMapper.insert().returnOne(USERS[0]);\n\t    // @ts-expect-error - requires InsertedObject as input\n\t    await insertTransformMapper.insert().run(USERS[0]);\n\t    // @ts-expect-error - requires InsertedObject as input\n\t    await insertTransformMapper.insert().returnOne(selectedUser1);\n\t    // @ts-expect-error - requires InsertedObject as input\n\t    await insertTransformMapper.insert().run(selectedUser1);\n\t  });\n", "  it('accepts readonly transforms', () => {\n\t    const transforms = {\n\t      countTransform: (count: bigint) => count,\n\t    } as const;\n\t    new TableMapper(db, 'users', {}).withTransforms(transforms);\n\t  });\n\t});\n"]}
{"filename": "src/tests/select-one.test.ts", "chunked_list": ["/**\n\t * Tests TableMapper.selectMany(), TableMapper.selectOne(), and query filters.\n\t */\n\timport { Kysely, sql } from 'kysely';\n\timport { TableMapper } from '../mappers/table-mapper';\n\timport { createDB, resetDB, destroyDB } from './utils/test-setup';\n\timport { Database } from './utils/test-tables';\n\timport { createUserMapperReturningID } from './utils/test-mappers';\n\timport { USERS } from './utils/test-objects';\n\timport { ignore } from './utils/test-utils';\n", "let db: Kysely<Database>;\n\tlet userMapper: ReturnType<typeof createUserMapperReturningID>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n\t  userMapper = createUserMapperReturningID(db);\n\t});\n\tbeforeEach(() => resetDB(db));\n\tafterAll(() => destroyDB(db));\n\tdescribe('selecting one return', () => {\n\t  it('selects the first row with no filter', async () => {\n", "    await userMapper.insert().run(USERS);\n\t    let user = await userMapper.select().returnOne();\n\t    expect(user?.handle).toEqual(USERS[0].handle);\n\t    user = await userMapper.select({}).returnOne();\n\t    expect(user?.handle).toEqual(USERS[0].handle);\n\t  });\n\t  it('selects the first row with a matching field filter', async () => {\n\t    await userMapper.insert().run(USERS);\n\t    let user = await userMapper.select({ name: USERS[0].name }).returnOne();\n\t    expect(user?.handle).toEqual(USERS[0].handle);\n", "    user = await userMapper\n\t      .select({\n\t        name: USERS[0].name,\n\t        handle: USERS[2].handle,\n\t      })\n\t      .returnOne();\n\t    expect(user?.handle).toEqual(USERS[2].handle);\n\t    user = await userMapper\n\t      .select({\n\t        id: [1, 2],\n", "        handle: [USERS[1].handle, USERS[2].handle],\n\t      })\n\t      .returnOne();\n\t    expect(user?.handle).toEqual(USERS[1].handle);\n\t  });\n\t  it('selects the first row with a binary operation filter', async () => {\n\t    await userMapper.insert().run(USERS);\n\t    // Test selecting by condition (with result)\n\t    let user = await userMapper.select('name', '=', USERS[0].name).returnOne();\n\t    expect(user?.handle).toEqual(USERS[0].handle);\n", "    // Test selecting by condition (no result)\n\t    user = await userMapper.select('name', '=', 'nonexistent').returnOne();\n\t    expect(user).toBeNull();\n\t  });\n\t  it('selects the first row with a query expression filter', async () => {\n\t    await userMapper.insert().run(USERS);\n\t    const user = await userMapper\n\t      .select(sql`name != ${USERS[0].name}`)\n\t      .returnOne();\n\t    expect(user?.handle).toEqual(USERS[1].handle);\n", "  });\n\t  it('selects the first row with a compound filter', async () => {\n\t    const userIDs = await userMapper.insert().returnAll(USERS);\n\t    const user = await userMapper\n\t      .select(({ and, cmpr }) =>\n\t        and([cmpr('name', '=', USERS[0].name), cmpr('id', '>', userIDs[0].id)])\n\t      )\n\t      .returnOne();\n\t    expect(user?.handle).toEqual(USERS[2].handle);\n\t  });\n", "  it('selects one returning selected columns and aliases', async () => {\n\t    const ids = await userMapper.insert().returnAll(USERS);\n\t    const mapper = new TableMapper(db, 'users', {\n\t      selectedColumns: ['id', 'handle as h'],\n\t    });\n\t    // Should allow access to aliased columns\n\t    (await mapper.select().returnOne())!.h;\n\t    const user = await mapper.select({ handle: USERS[0].handle }).returnOne();\n\t    expect(user).toEqual({ id: ids[0].id, h: USERS[0].handle });\n\t    ignore('inaccessible types are not allowed', async () => {\n", "      // @ts-expect-error - unselected columns are not allowed\n\t      (await mapper.select().returnAll())[0].name;\n\t    });\n\t  });\n\t  ignore('detects selecting returnOne() type errors', async () => {\n\t    // @ts-expect-error - only table columns are accessible unfiltered\n\t    (await userMapper.select({}).returnOne()).notThere;\n\t    // @ts-expect-error - only table columns are accessible w/ object filter\n\t    (await userMapper.select({ name: 'Sue' }).returnOne()).notThere;\n\t    // @ts-expect-error - only table columns are accessible w/ op filter\n", "    // prettier-ignore\n\t    (await userMapper.select(\"name\", \"=\", \"Sue\").returnOne()).notThere;\n\t    // prettier-ignore\n\t    (\n\t      await userMapper\n\t        .select((qb) => qb)\n\t        .returnOne()\n\t      // @ts-expect-error - only table columns are accessible w/ QB filter\n\t    )!.notThere;\n\t    // prettier-ignore\n", "    (\n\t      await userMapper\n\t        .select(sql`name = 'Sue'`)\n\t        .returnOne()\n\t      // @ts-expect-error - only table columns are accessible w/ expr filter\n\t    )!.notThere;\n\t  });\n\t});\n"]}
{"filename": "src/tests/sample-mappers.test.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\timport { createDB, resetDB, destroyDB } from './utils/test-setup';\n\timport { Database } from './utils/test-tables';\n\timport { USERS, insertedUser1 } from './utils/test-objects';\n\timport { TableMapper } from '../mappers/table-mapper';\n\timport { EntireRowTransforms } from '../mappers/entire-row-transforms';\n\tlet db: Kysely<Database>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n\t});\n", "beforeEach(() => resetDB(db));\n\tafterAll(() => destroyDB(db));\n\tdescribe('mappers that input and output the same type of object', () => {\n\t  it('inserts/updates/deletes with default transforms', async () => {\n\t    class MappedUser {\n\t      constructor(\n\t        public id: number,\n\t        public name: string,\n\t        public handle: string,\n\t        public email: string | null\n", "      ) {}\n\t    }\n\t    const keyColumns = ['id'] as const;\n\t    const userMapper = new TableMapper(db, 'users', {\n\t      keyColumns,\n\t      updateReturnColumns: ['id', 'name'],\n\t    }).withTransforms(new EntireRowTransforms(keyColumns));\n\t    // test updating a non-existent user\n\t    const userWithID = new MappedUser(\n\t      1,\n", "      USERS[0].name,\n\t      USERS[0].handle,\n\t      USERS[0].email!\n\t    );\n\t    const updateReturn1 = await userMapper\n\t      .update({ id: 1 })\n\t      .returnOne(userWithID);\n\t    expect(updateReturn1).toEqual(null);\n\t    // test inserting a user with falsy id\n\t    const insertedUser1 = new MappedUser(\n", "      0,\n\t      USERS[0].name,\n\t      USERS[0].handle,\n\t      USERS[0].email!\n\t    );\n\t    const insertReturn1 = (await userMapper.insert().returnOne(insertedUser1))!;\n\t    expect(insertReturn1).not.toBeNull();\n\t    expect(insertReturn1.id).toBeGreaterThan(0);\n\t    insertReturn1.name; // ensure 'name' is accessible\n\t    // test getting a user by ID\n", "    const selectedUser1 = await userMapper\n\t      .select({ id: insertReturn1.id })\n\t      .returnOne();\n\t    expect(selectedUser1).toEqual({ ...insertedUser1, id: insertReturn1.id });\n\t    // ensure 'id' is accessible\n\t    expect(selectedUser1?.id).toEqual(insertReturn1.id);\n\t    selectedUser1?.name; // ensure 'name' is accessible\n\t    // test inserting a user with truthy id\n\t    const insertedUser2 = new MappedUser(\n\t      10,\n", "      USERS[1].name,\n\t      USERS[1].handle,\n\t      USERS[1].email!\n\t    );\n\t    const insertReturn2 = (await userMapper.insert().returnOne(insertedUser2))!;\n\t    expect(insertReturn2).toEqual(insertedUser2);\n\t    insertReturn2?.name; // ensure 'name' is accessible\n\t    const selectedUser2 = await userMapper\n\t      .select({ id: insertReturn2.id })\n\t      .returnOne();\n", "    expect(selectedUser2).toEqual(insertedUser2);\n\t    // test updating a user, with returned row\n\t    const updatingUser = new MappedUser(\n\t      selectedUser1!.id,\n\t      'Xana',\n\t      selectedUser1!.handle,\n\t      selectedUser1!.email\n\t    );\n\t    const updateReturn = await userMapper\n\t      .update({ id: updatingUser.id })\n", "      .returnOne(updatingUser);\n\t    updateReturn?.id; // ensure 'id' is accessible\n\t    updateReturn?.name; // ensure 'name' is accessible\n\t    expect(updateReturn).toEqual(updatingUser);\n\t    const selectedUser3 = await userMapper\n\t      .select({ id: insertReturn1.id })\n\t      .returnOne();\n\t    expect(selectedUser3).toEqual(updatingUser);\n\t    // test updating a user, without returned row\n\t    const updatingUser2 = new MappedUser(\n", "      selectedUser3!.id,\n\t      'Freddy',\n\t      selectedUser3!.handle,\n\t      selectedUser3!.email\n\t    );\n\t    const updateReturn2 = await userMapper\n\t      .update({ id: updatingUser2.id })\n\t      .run(updatingUser2);\n\t    expect(updateReturn2).toBe(true);\n\t    const selectedUser4 = await userMapper\n", "      .select({ id: insertReturn1.id })\n\t      .returnOne();\n\t    expect(selectedUser4).toEqual(updatingUser2);\n\t    // test updating multiple users returning rows\n\t    const updatingUser3 = new MappedUser(\n\t      selectedUser1!.id,\n\t      'Everyone',\n\t      selectedUser1!.handle,\n\t      selectedUser1!.email\n\t    );\n", "    const updateReturn3 = await userMapper\n\t      .update()\n\t      .columns(['name', 'handle', 'email'])\n\t      .returnAll(updatingUser3);\n\t    expect(updateReturn3).toEqual([\n\t      { ...updatingUser3, id: 1 },\n\t      { ...updatingUser3, id: 10 },\n\t    ]);\n\t    updateReturn3[0].id; // ensure 'id' is accessible\n\t    updateReturn3[0].name; // ensure 'name' is accessible\n", "    // test deleting a user\n\t    const deleted = await userMapper.delete({ id: insertReturn1.id }).run();\n\t    expect(deleted).toEqual(true);\n\t    const selectedUser5 = await userMapper\n\t      .select({ id: insertReturn1.id })\n\t      .returnOne();\n\t    expect(selectedUser5).toBeNull();\n\t  });\n\t  it('inserts/updates/deletes with all custom transforms', async () => {\n\t    class MappedUser {\n", "      constructor(\n\t        public serialNo: number,\n\t        public firstName: string,\n\t        public lastName: string,\n\t        public handle: string,\n\t        public email: string | null\n\t      ) {}\n\t    }\n\t    const userMapper = new TableMapper(db, 'users', {\n\t      keyColumns: ['id'],\n", "      updateReturnColumns: ['id'],\n\t    }).withTransforms({\n\t      insertTransform: (user: MappedUser) => ({\n\t        name: `${user.firstName} ${user.lastName}`,\n\t        handle: user.handle,\n\t        email: user.email,\n\t      }),\n\t      insertReturnTransform: (user, returns) =>\n\t        new MappedUser(\n\t          returns.id,\n", "          user.firstName,\n\t          user.lastName,\n\t          user.handle,\n\t          user.email\n\t        ),\n\t      updateTransform: (user: MappedUser) => {\n\t        if (!(user instanceof MappedUser)) {\n\t          return user;\n\t        }\n\t        return {\n", "          name: `${user.firstName} ${user.lastName}`,\n\t          handle: user.handle + '2',\n\t          email: user.email,\n\t        };\n\t      },\n\t      updateReturnTransform: (user, returns) => {\n\t        return new MappedUser(\n\t          returns.id,\n\t          user.firstName,\n\t          user.lastName,\n", "          user.handle,\n\t          user.email\n\t        );\n\t      },\n\t      selectTransform: (row) => {\n\t        const names = row.name.split(' ');\n\t        return new MappedUser(\n\t          row.id,\n\t          names[0],\n\t          names[1],\n", "          row.handle,\n\t          row.email\n\t        );\n\t      },\n\t    });\n\t    // test updating a non-existent user\n\t    const updateReturn1 = await userMapper\n\t      .update({ id: 1 })\n\t      .returnOne(\n\t        new MappedUser(\n", "          1,\n\t          insertedUser1.firstName,\n\t          insertedUser1.lastName,\n\t          insertedUser1.handle,\n\t          insertedUser1.email\n\t        )\n\t      );\n\t    expect(updateReturn1).toEqual(null);\n\t    // test inserting a user\n\t    const insertedUser = new MappedUser(\n", "      0,\n\t      insertedUser1.firstName,\n\t      insertedUser1.lastName,\n\t      insertedUser1.handle,\n\t      insertedUser1.email\n\t    );\n\t    const insertReturn = (await userMapper.insert().returnOne(insertedUser))!;\n\t    insertReturn?.firstName; // ensure 'firstName' is accessible\n\t    expect(insertReturn).not.toBeNull();\n\t    expect(insertReturn.serialNo).toBeGreaterThan(0);\n", "    // test getting a user by ID\n\t    const selectedUser1 = await userMapper\n\t      .select({ id: insertReturn.serialNo })\n\t      .returnOne();\n\t    selectedUser1?.firstName; // ensure 'firstName' is accessible\n\t    expect(selectedUser1).toEqual(insertReturn);\n\t    expect(selectedUser1?.serialNo).toEqual(insertReturn.serialNo);\n\t    // test updating a user\n\t    const updatingUser = new MappedUser(\n\t      selectedUser1!.serialNo,\n", "      selectedUser1!.firstName,\n\t      'Xana',\n\t      selectedUser1!.handle,\n\t      selectedUser1!.email\n\t    );\n\t    const updateReturn2 = await userMapper\n\t      .update({ id: updatingUser.serialNo })\n\t      .returnOne(updatingUser);\n\t    updateReturn2?.firstName; // ensure 'firstName' is accessible\n\t    expect(updateReturn2).toEqual(updatingUser);\n", "    const selectedUser2 = await userMapper\n\t      .select({ id: insertReturn.serialNo })\n\t      .returnOne();\n\t    selectedUser2?.firstName; // ensure 'firstName' is accessible\n\t    expect(selectedUser2?.serialNo).toEqual(selectedUser1!.serialNo);\n\t    expect(selectedUser2?.handle).toEqual(selectedUser1!.handle + '2');\n\t    // test updating multiple users\n\t    const updatingUser3 = new MappedUser(\n\t      selectedUser1!.serialNo,\n\t      'Every',\n", "      'One',\n\t      selectedUser1!.handle,\n\t      selectedUser1!.email\n\t    );\n\t    const updateReturn3 = await userMapper.update().returnAll(updatingUser3);\n\t    expect(updateReturn3).toEqual([updatingUser3]);\n\t    updateReturn3[0].serialNo; // ensure 'serialNo' is accessible\n\t    const updateReturn4 = await userMapper.update().returnOne(updatingUser3);\n\t    expect(updateReturn4).toEqual(updatingUser3);\n\t    updateReturn4?.serialNo; // ensure 'serialNo' is accessible\n", "    // test deleting a user\n\t    const deleted = await userMapper\n\t      .delete({ id: insertReturn.serialNo })\n\t      .run();\n\t    expect(deleted).toEqual(true);\n\t    const selectedUser3 = await userMapper\n\t      .select({ id: insertReturn.serialNo })\n\t      .returnOne();\n\t    expect(selectedUser3).toBeNull();\n\t  });\n", "});\n"]}
{"filename": "src/tests/insert-columns.test.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\timport { createDB, resetDB, destroyDB } from './utils/test-setup';\n\timport { Database } from './utils/test-tables';\n\timport {\n\t  createUserMapperReturningID,\n\t  createUserMapperReturningNothing,\n\t} from './utils/test-mappers';\n\tlet db: Kysely<Database>;\n\tlet userMapperReturningID: ReturnType<typeof createUserMapperReturningID>;\n\tlet userMapperReturningNothing: ReturnType<\n", "  typeof createUserMapperReturningNothing\n\t>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n\t  userMapperReturningNothing = createUserMapperReturningNothing(db);\n\t  userMapperReturningID = createUserMapperReturningID(db);\n\t});\n\tbeforeEach(() => resetDB(db));\n\tafterAll(() => destroyDB(db));\n\tdescribe('inserting specific columns', () => {\n", "  it('subsets inserted columns, excluding ID', async () => {\n\t    const subsetQuery = userMapperReturningID\n\t      .insert()\n\t      .columns(['name', 'handle'] as const); // allows readonly array\n\t    const insertReturn = await subsetQuery.returnOne({\n\t      id: 10,\n\t      name: 'John Doe',\n\t      handle: 'johndoe',\n\t      email: 'jdoe@abc.def',\n\t    });\n", "    expect(insertReturn).toEqual({ id: expect.any(Number) });\n\t    const readUser = await userMapperReturningID.select().returnAll();\n\t    expect(readUser).toEqual([\n\t      { id: 1, name: 'John Doe', handle: 'johndoe', email: null },\n\t    ]);\n\t  });\n\t  it('subsets inserted columns, including ID', async () => {\n\t    const subsetQuery = userMapperReturningNothing\n\t      .insert()\n\t      .columns(['id', 'name', 'handle']);\n", "    await subsetQuery.run({\n\t      id: 10,\n\t      name: 'John Doe',\n\t      handle: 'johndoe',\n\t      email: 'jdoe@abc.def',\n\t    });\n\t    const readUser = await userMapperReturningID.select().returnAll();\n\t    expect(readUser).toEqual([\n\t      { id: 10, name: 'John Doe', handle: 'johndoe', email: null },\n\t    ]);\n", "  });\n\t  it('requires all subsetted columns to be inserted', async () => {\n\t    const subsetQuery = userMapperReturningID\n\t      .insert()\n\t      .columns(['name', 'handle', 'email']);\n\t    const insertValues = { name: 'John Doe', handle: 'johndoe' };\n\t    expect(() => subsetQuery.returnOne(insertValues)).rejects.toThrow(\n\t      `column 'email' missing`\n\t    );\n\t    const success = await subsetQuery.run({ ...insertValues, email: null });\n", "    expect(success).toBe(true);\n\t  });\n\t  it('provides insertTransform with column subset', async () => {\n\t    expect.assertions(1);\n\t    const mapper = userMapperReturningID.withTransforms({\n\t      insertTransform: (source, columns) => {\n\t        expect(columns).toEqual(['name', 'handle']);\n\t        return source;\n\t      },\n\t    });\n", "    await mapper.insert().columns(['name', 'handle']).run({\n\t      name: 'John Doe',\n\t      handle: 'johndoe',\n\t      email: 'jdoe@abc.def',\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/tests/setting-types.test.ts", "chunked_list": ["import { Insertable, Kysely, Selectable, Updateable } from 'kysely';\n\timport { TableMapper } from '../mappers/table-mapper';\n\timport { createDB, resetDB, destroyDB } from './utils/test-setup';\n\timport { Database, Users } from './utils/test-tables';\n\timport { ignore } from './utils/test-utils';\n\timport { SelectionColumn } from '../lib/type-utils';\n\tlet db: Kysely<Database>;\n\tbeforeAll(async () => {\n\t  db = await createDB();\n\t});\n", "beforeEach(() => resetDB(db));\n\tafterAll(() => destroyDB(db));\n\tdescribe('table mapper setting type checks', () => {\n\t  ignore('detects invalid return columns configurations', () => {\n\t    new TableMapper<Database, 'users', ['id']>(db, 'users', {\n\t      // @ts-expect-error - invalid return column configuration\n\t      insertReturnColumns: ['notThere'],\n\t      // @ts-expect-error - invalid return column configuration\n\t      updateReturnColumns: ['notThere'],\n\t    });\n", "    new TableMapper<Database, 'users', ['id']>(db, 'users', {\n\t      // @ts-expect-error - actual and declared return types must match\n\t      insertReturnColumns: ['id', 'name'],\n\t      // @ts-expect-error - actual and declared return types must match\n\t      updateReturnColumns: ['id', 'name'],\n\t    });\n\t    new TableMapper<\n\t      Database,\n\t      'users',\n\t      [],\n", "      ['*'],\n\t      Selectable<Users>,\n\t      Insertable<Users>,\n\t      Updateable<Users>,\n\t      bigint,\n\t      // @ts-expect-error - invalid return column configuration\n\t      ['notThere']\n\t    >(db, 'users', {});\n\t    new TableMapper<\n\t      Database,\n", "      'users',\n\t      [],\n\t      ['*'],\n\t      Selectable<Users>,\n\t      Insertable<Users>,\n\t      Updateable<Users>,\n\t      bigint,\n\t      ['name'],\n\t      // @ts-expect-error - invalid return column configuration\n\t      ['name', 'notThere']\n", "    >(db, 'users', {});\n\t    new TableMapper<Database, 'users', ['id']>(db, 'users', {\n\t      // @ts-expect-error - invalid return column configuration\n\t      insertReturnColumns: [''],\n\t      // @ts-expect-error - invalid return column configuration\n\t      updateReturnColumns: [''],\n\t    });\n\t    new TableMapper<Database, 'users', ['id']>(db, 'users', {\n\t      // @ts-expect-error - invalid return column configuration\n\t      insertReturnColumns: ['notThere'],\n", "      // @ts-expect-error - invalid return column configuration\n\t      updateReturnColumns: ['notThere'],\n\t    });\n\t    class TestMapper6<\n\t      InsertReturnColumns extends\n\t        | SelectionColumn<Database, 'users'>[]\n\t        | ['*'] = [],\n\t      UpdateReturnColumns extends\n\t        | SelectionColumn<Database, 'users'>[]\n\t        | ['*'] = []\n", "    > extends TableMapper<\n\t      Database,\n\t      'users',\n\t      [],\n\t      ['*'],\n\t      Selectable<Users>,\n\t      Insertable<Users>,\n\t      Updateable<Users>,\n\t      number,\n\t      InsertReturnColumns,\n", "      UpdateReturnColumns\n\t    > {}\n\t    new TestMapper6(db, 'users', {\n\t      // @ts-expect-error - invalid return column configuration\n\t      insertReturnColumns: ['notThere'],\n\t      // @ts-expect-error - invalid return column configuration\n\t      updateReturnColumns: ['notThere'],\n\t    });\n\t    new TableMapper<\n\t      Database,\n", "      'users',\n\t      [],\n\t      any,\n\t      any,\n\t      any,\n\t      any,\n\t      number,\n\t      ['id', 'name']\n\t    >(db, 'users', {\n\t      // @ts-expect-error - actual and declared return types must match\n", "      insertReturnColumns: ['id'],\n\t      // @ts-expect-error - actual and declared return types must match\n\t      updateReturnColumns: ['id'],\n\t    });\n\t    new TableMapper<\n\t      Database,\n\t      'users',\n\t      [],\n\t      any,\n\t      any,\n", "      any,\n\t      any,\n\t      number,\n\t      ['*'],\n\t      ['*']\n\t    >(db, 'users', {\n\t      // @ts-expect-error - actual and declared return types must match\n\t      insertReturnColumns: ['id'],\n\t      // @ts-expect-error - actual and declared return types must match\n\t      updateReturnColumns: ['id'],\n", "    });\n\t    new TableMapper<Database, 'users', [], any, any, any, any, number, [], []>(\n\t      db,\n\t      'users',\n\t      {\n\t        // @ts-expect-error - actual and declared return types must match\n\t        insertReturnColumns: ['id'],\n\t        // @ts-expect-error - actual and declared return types must match\n\t        updateReturnColumns: ['id'],\n\t      }\n", "    );\n\t  });\n\t  ignore('detects invalid return count configuration', () => {\n\t    class TestMapper extends TableMapper<\n\t      Database,\n\t      'users',\n\t      ['id'],\n\t      ['*'],\n\t      Selectable<Users>,\n\t      Insertable<Users>,\n", "      Updateable<Users>,\n\t      number\n\t    > {}\n\t    new TestMapper(db, 'users', {\n\t      // @ts-expect-error - invalid return count\n\t      countTransform: (count: bigint) => BigInt(count),\n\t    });\n\t  });\n\t  it('accepts readonly KeyColumns', () => {\n\t    new TableMapper<\n", "      Database,\n\t      'users',\n\t      Readonly<['id']> // should not error\n\t    >(db, 'users', {});\n\t  });\n\t  it('accepts readonly SelectedColumns', () => {\n\t    new TableMapper<\n\t      Database,\n\t      'users',\n\t      ['id'],\n", "      Readonly<['id', 'name']> // should not error\n\t    >(db, 'users', {});\n\t  });\n\t  it('accepts readonly return columns', () => {\n\t    new TableMapper<\n\t      Database,\n\t      'users',\n\t      ['id'],\n\t      ['*'],\n\t      Selectable<Users>,\n", "      Insertable<Users>,\n\t      Updateable<Users>,\n\t      bigint,\n\t      Readonly<['id']>, // should not error\n\t      Readonly<['name']> // should not error\n\t    >(db, 'users', {});\n\t  });\n\t  it('accepts readonly settings', () => {\n\t    const settings = {\n\t      insertReturnColumns: ['id'] as const,\n", "      updateReturnColumns: ['name'] as const,\n\t    } as const;\n\t    new TableMapper(db, 'users', settings);\n\t  });\n\t});\n"]}
{"filename": "src/tests/utils/test-types.ts", "chunked_list": ["/**\n\t * Types and classes used in tests.\n\t */\n\ttype VariableFieldsOf<T> = Omit<T, 'id' | '__type'>;\n\texport class User {\n\t  constructor(\n\t    public id: number,\n\t    public firstName: string,\n\t    public lastName: string,\n\t    public handle: string,\n", "    public email: string | null\n\t  ) {}\n\t  static create(id: number, obj: VariableFieldsOf<User>): User {\n\t    return new User(id, obj.firstName, obj.lastName, obj.handle, obj.email);\n\t  }\n\t}\n\texport class InsertedUser extends User {\n\t  readonly __type = 'InsertedUser';\n\t  static override create(\n\t    id: number,\n", "    obj: VariableFieldsOf<InsertedUser>\n\t  ): InsertedUser {\n\t    return new InsertedUser(\n\t      id,\n\t      obj.firstName,\n\t      obj.lastName,\n\t      obj.handle,\n\t      obj.email\n\t    );\n\t  }\n", "}\n\texport class SelectedUser extends User {\n\t  readonly __type = 'SelectedUser';\n\t  static override create(\n\t    id: number,\n\t    obj: VariableFieldsOf<SelectedUser>\n\t  ): SelectedUser {\n\t    return new SelectedUser(\n\t      id,\n\t      obj.firstName,\n", "      obj.lastName,\n\t      obj.handle,\n\t      obj.email\n\t    );\n\t  }\n\t}\n\texport class UpdatingUser extends User {\n\t  readonly __type = 'UpdatingUser';\n\t  static override create(\n\t    id: number,\n", "    obj: VariableFieldsOf<UpdatingUser>\n\t  ): UpdatingUser {\n\t    return new UpdatingUser(\n\t      id,\n\t      obj.firstName,\n\t      obj.lastName,\n\t      obj.handle,\n\t      obj.email\n\t    );\n\t  }\n", "}\n\texport class ReturnedUser extends User {\n\t  readonly __type = 'ReturnedUser';\n\t  static override create(\n\t    id: number,\n\t    obj: VariableFieldsOf<ReturnedUser>\n\t  ): ReturnedUser {\n\t    return new ReturnedUser(\n\t      id,\n\t      obj.firstName,\n", "      obj.lastName,\n\t      obj.handle,\n\t      obj.email\n\t    );\n\t  }\n\t}\n"]}
{"filename": "src/tests/utils/test-setup.ts", "chunked_list": ["import Sqlite3 from 'better-sqlite3';\n\timport { Kysely, SqliteDialect } from 'kysely';\n\timport { Database, createTables, dropTables } from './test-tables';\n\texport async function createDB() {\n\t  return new Kysely<Database>({\n\t    dialect: new SqliteDialect({\n\t      database: new Sqlite3(':memory:'),\n\t    }),\n\t  });\n\t}\n", "export async function resetDB(db: Kysely<Database>) {\n\t  await dropTables(db);\n\t  await createTables(db);\n\t}\n\texport async function destroyDB<DB>(db: Kysely<DB>) {\n\t  return db.destroy();\n\t}\n"]}
{"filename": "src/tests/utils/test-mappers.ts", "chunked_list": ["import { Kysely } from 'kysely';\n\timport { TableMapper } from '../../mappers/table-mapper';\n\timport { Database } from './test-tables';\n\timport { InsertedUser } from './test-types';\n\tconst countTransform = (count: bigint) => Number(count);\n\texport function createUserMapperReturningDefault(db: Kysely<Database>) {\n\t  return new TableMapper(db, 'users');\n\t}\n\tconst noColumns = [] as const;\n\texport function createUserMapperReturningNothing(db: Kysely<Database>) {\n", "  return new TableMapper(db, 'users', {\n\t    keyColumns: noColumns,\n\t    updateReturnColumns: noColumns,\n\t  }).withTransforms({\n\t    countTransform,\n\t  });\n\t}\n\texport function createUserMapperReturningID(db: Kysely<Database>) {\n\t  return new TableMapper(db, 'users', {\n\t    keyColumns: ['id'],\n", "    updateReturnColumns: ['id'],\n\t  }).withTransforms({\n\t    countTransform,\n\t  });\n\t}\n\texport function createUserMapperReturningIDAndHandleAsH(db: Kysely<Database>) {\n\t  return new TableMapper(db, 'users', {\n\t    keyColumns: ['id'],\n\t    insertReturnColumns: ['id', 'handle as h'],\n\t    updateReturnColumns: ['id', 'handle as h'],\n", "  }).withTransforms({ countTransform });\n\t}\n\texport function createUserMapperReturningDifferently(db: Kysely<Database>) {\n\t  return new TableMapper(db, 'users', {\n\t    keyColumns: ['id'],\n\t    insertReturnColumns: ['id', 'handle'],\n\t    updateReturnColumns: ['name'],\n\t  }).withTransforms({ countTransform });\n\t}\n\texport function createUserMapperReturningAll(db: Kysely<Database>) {\n", "  return new TableMapper(db, 'users', {\n\t    insertReturnColumns: ['*'],\n\t    updateReturnColumns: ['*'],\n\t  }).withTransforms({\n\t    countTransform,\n\t  });\n\t}\n\texport function createInsertTransformMapper(db: Kysely<Database>) {\n\t  return new TableMapper(db, 'users', {\n\t    insertReturnColumns: ['id'],\n", "    updateReturnColumns: ['id'],\n\t  }).withTransforms({\n\t    insertTransform: (source: InsertedUser) => ({\n\t      name: `${source.firstName} ${source.lastName}`,\n\t      handle: source.handle,\n\t      email: source.email,\n\t    }),\n\t    countTransform: (count) => Number(count),\n\t  });\n\t}\n"]}
{"filename": "src/tests/utils/test-utils.ts", "chunked_list": ["/**\n\t * Generic testing utilities\n\t */\n\t/**\n\t * Retrieve an error for examination. Modified from\n\t * https://stackoverflow.com/a/49512933/650894\n\t *\n\t * @param call Function that may throw an error; can be async\n\t * @returns The thrown error if one was thrown, otherwise returns\n\t *   the error NoErrorThrownError\n", " */\n\texport async function getError<E>(call: () => unknown): Promise<E | null> {\n\t  try {\n\t    await call(); // need not be async\n\t    return null;\n\t  } catch (err: unknown) {\n\t    return err as E;\n\t  }\n\t}\n\t/**\n", " * Embeds code that will never run within a callback. Useful for\n\t * testing expected type errors.\n\t * @param description Description of the code that will never run\n\t * @param callback Callback that will never run\n\t */\n\texport function ignore(_description: string, _: () => void) {}\n"]}
{"filename": "src/tests/utils/test-tables.ts", "chunked_list": ["import { Kysely, Generated, sql } from 'kysely';\n\t// list tables after those they depend on\n\tconst TABLE_NAMES = ['posts', 'users'];\n\texport interface Users {\n\t  id: Generated<number>;\n\t  handle: string;\n\t  name: string;\n\t  email: string | null;\n\t}\n\texport interface Posts {\n", "  id: Generated<number>;\n\t  userId: number;\n\t  title: string;\n\t  likeCount: number;\n\t  createdAt: Generated<Date>;\n\t}\n\texport interface Database {\n\t  users: Users;\n\t  posts: Posts;\n\t}\n", "export async function createTables(db: Kysely<Database>) {\n\t  await _createTableWithId(db, 'users')\n\t    .addColumn('handle', 'varchar(255)', (col) => col.notNull())\n\t    .addColumn('name', 'varchar(255)', (col) => col.notNull())\n\t    .addColumn('email', 'varchar(255)')\n\t    .execute();\n\t  await _createTableWithId(db, 'posts')\n\t    .addColumn('userId', 'integer', (col) =>\n\t      col.references('users.id').onDelete('cascade').notNull()\n\t    )\n", "    .addColumn('title', 'varchar(255)', (col) => col.unique().notNull())\n\t    .addColumn('likeCount', 'integer', (col) => col.notNull())\n\t    .addColumn('createdAt', 'timestamp', (col) =>\n\t      col.defaultTo(sql`current_timestamp`).notNull()\n\t    )\n\t    .execute();\n\t  return db;\n\t}\n\texport async function dropTables(db: Kysely<Database>): Promise<void> {\n\t  for (const table of TABLE_NAMES) {\n", "    await db.schema.dropTable(table).ifExists().execute();\n\t  }\n\t}\n\tfunction _createTableWithId(db: Kysely<Database>, tableName: string) {\n\t  return db.schema\n\t    .createTable(tableName)\n\t    .addColumn('id', 'integer', (col) => col.autoIncrement().primaryKey());\n\t}\n"]}
{"filename": "src/tests/utils/test-objects.ts", "chunked_list": ["import { Insertable } from 'kysely';\n\timport { Users, Posts } from './test-tables';\n\timport { InsertedUser, ReturnedUser, SelectedUser } from './test-types';\n\texport const USERS: Insertable<Users>[] = [\n\t  {\n\t    handle: 'handle1',\n\t    name: 'Sue',\n\t    email: 'foo1@bar.com',\n\t  },\n\t  {\n", "    handle: 'handle2',\n\t    name: 'Fred',\n\t    email: 'foo2@bar.com',\n\t  },\n\t  {\n\t    handle: 'handle3',\n\t    name: 'Sue',\n\t    email: 'foo3@bar.com',\n\t  },\n\t];\n", "export const POSTS: Insertable<Posts>[] = [\n\t  {\n\t    userId: 0,\n\t    title: 'About Something',\n\t    likeCount: 0,\n\t  },\n\t  {\n\t    userId: 0,\n\t    title: 'And Another Thing',\n\t    likeCount: 10,\n", "  },\n\t  {\n\t    userId: 0,\n\t    title: 'Still One More Thing',\n\t    likeCount: 1000,\n\t  },\n\t];\n\texport const userRow1 = {\n\t  name: 'John Smith',\n\t  handle: 'jsmith',\n", "  email: 'jsmith@xyz.pdq',\n\t};\n\texport const userRow2 = {\n\t  name: 'Jane Doe',\n\t  handle: 'jdoe',\n\t  email: 'jdoe@xyz.pdq',\n\t};\n\texport const userRow3 = {\n\t  name: 'Mary Sue',\n\t  handle: 'msue',\n", "  email: 'msue@xyz.pdq',\n\t};\n\texport const userObject1 = {\n\t  firstName: 'John',\n\t  lastName: 'Smith',\n\t  handle: userRow1.handle,\n\t  email: userRow1.email,\n\t};\n\texport const userObject2 = {\n\t  firstName: 'Jane',\n", "  lastName: 'Doe',\n\t  handle: userRow2.handle,\n\t  email: userRow2.email,\n\t};\n\texport const userObject3 = {\n\t  firstName: 'Mary',\n\t  lastName: 'Sue',\n\t  handle: userRow3.handle,\n\t  email: userRow3.email,\n\t};\n", "export const selectedUser1 = SelectedUser.create(1, userObject1);\n\texport const selectedUser2 = SelectedUser.create(2, userObject2);\n\texport const selectedUser3 = SelectedUser.create(3, userObject3);\n\texport const insertedUser1 = InsertedUser.create(0, userObject1);\n\texport const insertedUser2 = InsertedUser.create(0, userObject2);\n\texport const insertedUser3 = InsertedUser.create(0, userObject3);\n\texport const insertReturnedUser1 = ReturnedUser.create(1, userObject1);\n\texport const insertReturnedUser2 = ReturnedUser.create(2, userObject2);\n\texport const insertReturnedUser3 = ReturnedUser.create(3, userObject3);\n"]}
{"filename": "src/lib/parameterizable-query-factory.ts", "chunked_list": ["import { ParametersObject, QueryParameterMaker } from 'kysely-params';\n\timport { AbstractTableMapper } from '../mappers/abstract-table-mapper';\n\timport { SelectableColumnTuple, SelectionColumn } from './type-utils';\n\timport { ParameterizableMappingQuery } from '../queries/parameterizable-query';\n\t/**\n\t * Definition of the function that a caller provides to parameterize a\n\t * compilable query.\n\t */\n\texport interface ParameterizableMappingQueryFactory<\n\t  DB,\n", "  TB extends keyof DB & string,\n\t  KeyColumns extends Readonly<SelectableColumnTuple<DB[TB]>> | Readonly<[]>,\n\t  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n\t  SelectedObject,\n\t  InsertedObject,\n\t  UpdatingObject,\n\t  ReturnCount,\n\t  InsertReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n\t  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n\t  InsertReturn,\n", "  UpdateReturn,\n\t  M extends AbstractTableMapper<\n\t    DB,\n\t    TB,\n\t    KeyColumns,\n\t    SelectedColumns,\n\t    SelectedObject,\n\t    InsertedObject,\n\t    UpdatingObject,\n\t    ReturnCount,\n", "    InsertReturnColumns,\n\t    UpdateReturnColumns,\n\t    InsertReturn,\n\t    UpdateReturn\n\t  >,\n\t  Parameters extends ParametersObject<Parameters>,\n\t  Q extends ParameterizableMappingQuery\n\t> {\n\t  (factory: { mapper: M; param: QueryParameterMaker<Parameters>['param'] }): Q;\n\t}\n"]}
{"filename": "src/lib/restrict-values.ts", "chunked_list": ["/**\n\t * Restrict the values of an object to the specified columns, requiring that\n\t * all of the specified columns be present in the object.\n\t * @param obj The object to restrict.\n\t * @param toColumns The columns to restrict the object to.\n\t * @returns A new object with only the specified columns.\n\t */\n\texport function restrictValues(obj: any, toColumns: Readonly<string[]>) {\n\t  const values = {} as any;\n\t  for (const column of toColumns) {\n", "    const value = obj[column];\n\t    // ensure the output of the applied transform works for the present query\n\t    if (value === undefined) {\n\t      throw Error(`Specified column '${column}' missing from values object`);\n\t    }\n\t    values[column] = value;\n\t  }\n\t  return values;\n\t}\n"]}
{"filename": "src/lib/query-filter.ts", "chunked_list": ["/**\n\t * The type and implementation of the query filter object, which can\n\t * be passed as an argument to query functions to constrain results.\n\t */\n\timport {\n\t  Expression,\n\t  ExtractTypeFromStringReference,\n\t  ReferenceExpression,\n\t  SelectType,\n\t  Selectable,\n", "  WhereExpressionFactory,\n\t} from 'kysely';\n\timport { KeyTuple, SelectableColumnTuple } from './type-utils';\n\t/**\n\t * Type of the query filter object, which can be passed as an argument\n\t * to query functions to constrain results. A filter can be any of the\n\t * following:\n\t *\n\t * - A key column value, which matches a single key column, if\n\t *   `KeyColumns` is a tuple with a single element.\n", " * - A key tuple, which matches multiple key columns, if `KeyColumns`\n\t *   is a tuple with multiple elements.\n\t * - An object, which matches columns against the object's fields. A\n\t *   field value may be an array, in which case the associated column ]\n\t *   matches any of the elements of the array.\n\t * - A raw SQL expression using Kysely's `sql` template literal tag.\n\t * - An arbitrary Kysely query expression.\n\t *\n\t * A filter is represented as a single value, but the methods that use\n\t * filters also accept three-argument binary operations.\n", " */\n\texport type QueryFilter<\n\t  DB,\n\t  TB extends keyof DB & string,\n\t  KeyColumns extends Readonly<SelectableColumnTuple<DB[TB]>> | Readonly<[]>,\n\t  RE extends ReferenceExpression<DB, TB>\n\t> =\n\t  | (KeyColumns extends [string]\n\t      ? KeyColumnFilter<DB, TB, KeyColumns[0]>\n\t      : never)\n", "  | (KeyColumns extends [] ? never : Readonly<KeyTuple<DB[TB], KeyColumns>>)\n\t  | FieldMatchingFilter<DB, TB, RE>\n\t  | WhereExpressionFactory<DB, TB>\n\t  | Expression<any>;\n\t/**\n\t * A filter that matches columns against the fields of an object.\n\t */\n\texport type FieldMatchingFilter<\n\t  DB,\n\t  TB extends keyof DB & string,\n", "  RE extends ReferenceExpression<DB, TB>\n\t> = {\n\t  [K in RE & string]?:\n\t    | SelectType<ExtractTypeFromStringReference<DB, TB, K>>\n\t    | Readonly<SelectType<ExtractTypeFromStringReference<DB, TB, K>>[]>;\n\t};\n\t/**\n\t * A filter that matches a single key column.\n\t */\n\ttype KeyColumnFilter<\n", "  DB,\n\t  TB extends keyof DB,\n\t  K extends keyof Selectable<DB[TB]> & string\n\t> = NonNullable<Selectable<DB[TB]>[K]>;\n"]}
{"filename": "src/lib/type-utils.ts", "chunked_list": ["/**\n\t * Type utilities.\n\t */\n\timport { Selectable, SelectArg, SelectExpression, Selection } from 'kysely';\n\t/**\n\t * Type of the key tuple whose column names are given by `KA` and are\n\t * found in the table interface `T`. Supports up to 4 columns.\n\t * @typeParam T Table interface.\n\t * @typeParam KA Array of the key column names.\n\t */\n", "export type KeyTuple<\n\t  T,\n\t  KA extends Readonly<(keyof Selectable<T> & string)[]>\n\t> = KA[3] extends string\n\t  ? [\n\t      Selectable<T>[KA[0]],\n\t      Selectable<T>[KA[1]],\n\t      Selectable<T>[KA[2]],\n\t      Selectable<T>[KA[3]]\n\t    ]\n", "  : KA[2] extends string\n\t  ? [Selectable<T>[KA[0]], Selectable<T>[KA[1]], Selectable<T>[KA[2]]]\n\t  : KA[1] extends string\n\t  ? [Selectable<T>[KA[0]], Selectable<T>[KA[1]]]\n\t  : KA[0] extends string\n\t  ? [Selectable<T>[KA[0]]]\n\t  : never;\n\t/**\n\t * Require specified properties of a type, leaving the rest optional.\n\t * @typeParam T Type to require properties from.\n", " * @typeParam K Keys of the properties to require.\n\t */\n\texport type RequireSome<T, K extends keyof T> = Omit<T, K> &\n\t  Required<Pick<T, K>>;\n\t/**\n\t * Shorthand type for a selectable column, restricted to a column name.\n\t */\n\texport type SelectableColumn<T> = keyof Selectable<T> & string;\n\t/**\n\t * Selectable column name or column alias.\n", " */\n\texport type SelectionColumn<DB, TB extends keyof DB & string> =\n\t  | SelectableColumn<DB[TB]>\n\t  | (SelectExpression<DB, TB> & `${SelectableColumn<DB[TB]>} as ${string}`);\n\t/**\n\t * Type of a selected row, evaluating to all columns if `S` is `['*']`.\n\t */\n\texport type SelectedRow<\n\t  DB,\n\t  TB extends keyof DB & string,\n", "  SE extends SelectExpression<DB, TB>,\n\t  S extends SelectArg<DB, TB, any> | ['*']\n\t> = S extends ['*'] ? Selectable<DB[TB]> : Selection<DB, TB, SE>;\n\t/**\n\t * Tuple of up to four selectable columns.\n\t */\n\texport type SelectableColumnTuple<T> =\n\t  | [SelectableColumn<T>]\n\t  | [SelectableColumn<T>, SelectableColumn<T>]\n\t  | [SelectableColumn<T>, SelectableColumn<T>, SelectableColumn<T>]\n", "  | [\n\t      SelectableColumn<T>,\n\t      SelectableColumn<T>,\n\t      SelectableColumn<T>,\n\t      SelectableColumn<T>\n\t    ];\n"]}
{"filename": "src/lib/apply-query-filter.ts", "chunked_list": ["import {\n\t  ComparisonOperatorExpression,\n\t  Kysely,\n\t  OperandValueExpressionOrList,\n\t  ReferenceExpression,\n\t  WhereInterface,\n\t} from 'kysely';\n\timport { SelectableColumnTuple } from './type-utils';\n\timport { QueryFilter } from './query-filter';\n\ttype AnyWhereInterface = WhereInterface<any, any>;\n", "/**\n\t * Returns a query builder that constrains the provided query builder\n\t * according to the provided query filter or binary operation.\n\t * @param base The Kysely mapper that is used to create references.\n\t * @param qb The query builder to constrain.\n\t * @param filterOrLHS The query filter or left-hand side of a binary operation.\n\t * @param op The operator of a binary operation.\n\t * @param rhs The right-hand side of a binary operation.\n\t * @returns A query builder constrained for the provided query filter\n\t *  or binary operation.\n", " */\n\texport function applyQueryFilter<\n\t  DB,\n\t  TB extends keyof DB & string,\n\t  KeyColumns extends Readonly<SelectableColumnTuple<DB[TB]>> | Readonly<[]>,\n\t  QB extends AnyWhereInterface,\n\t  RE extends ReferenceExpression<DB, TB>\n\t>(\n\t  db: Kysely<DB>,\n\t  qb: QB,\n", "  keyColumns: KeyColumns,\n\t  filterOrLHS: QueryFilter<DB, TB, KeyColumns, RE> | RE,\n\t  op?: ComparisonOperatorExpression,\n\t  rhs?: OperandValueExpressionOrList<DB, TB, RE>\n\t): QB {\n\t  // Process a binary operation.\n\t  if (op !== undefined) {\n\t    return qb.where(filterOrLHS as RE, op, rhs!) as QB;\n\t  }\n\t  const filter = filterOrLHS as QueryFilter<DB, TB, KeyColumns, RE>;\n", "  if (typeof filter === 'object') {\n\t    // Process a key tuple filter.\n\t    if (Array.isArray(filter)) {\n\t      keyColumns.forEach((column, i) => {\n\t        qb = qb.where(db.dynamic.ref(column), '=', filter[i]) as QB;\n\t      });\n\t      return qb;\n\t    }\n\t    // Process a query expression filter. Check for expressions\n\t    // first because they could potentially be plain objects.\n", "    if ('expressionType' in filter) {\n\t      return qb.where(filter) as QB;\n\t    }\n\t    // Process a field matching filter. `{}` matches all rows.\n\t    if (filter.constructor === Object) {\n\t      for (const [column, value] of Object.entries(filter)) {\n\t        if (Array.isArray(value)) {\n\t          qb = qb.where(db.dynamic.ref(column), 'in', value) as QB;\n\t        } else {\n\t          qb = qb.where(db.dynamic.ref(column), '=', value) as QB;\n", "        }\n\t      }\n\t      return qb as unknown as QB;\n\t    }\n\t  }\n\t  // Process a where expression factory.\n\t  if (typeof filter === 'function') {\n\t    return qb.where(filter as any) as QB;\n\t  }\n\t  // Process a single key filter, expressed as a primitive value.\n", "  if (keyColumns.length === 1) {\n\t    return qb.where(db.dynamic.ref(keyColumns[0]), '=', filter) as QB;\n\t  }\n\t  throw Error('Unrecognized query filter');\n\t}\n"]}
{"filename": "src/mappers/table-mapper.ts", "chunked_list": ["import { Insertable, Selectable, Selection, Updateable } from 'kysely';\n\timport {\n\t  SelectableColumnTuple,\n\t  SelectedRow,\n\t  SelectionColumn,\n\t} from '../lib/type-utils';\n\timport { TableMapperTransforms } from './table-mapper-transforms';\n\timport { AbstractTableMapper } from './abstract-table-mapper';\n\t/**\n\t * Table mapper that defaults to passing through all query inputs and output\n", " * unchanged, allowing the selective overloading of transforms.\n\t * @typeParam DB Interface whose fields are table names defining tables.\n\t * @typeParam TB Name of the table.\n\t * @typeParam KeyColumns Tuple of the names of the table's key columns.\n\t *  Defaults to `[]`, indicating no key columns. Supports up to 4 columns.\n\t * @typeParam SelectedColumns Columns to return from selection queries.\n\t *  Defaults to `['*']`, returning all columns. May specify aliases.\n\t * @typeParam SelectedObject Type of objects returned by select queries.\n\t * @typeParam InsertedObject Type of objects inserted into the table.\n\t * @typeParam UpdatingObject Type of objects used to update rows of the table.\n", " * @typeParam Type of the count of the number of affected rows.\n\t * @typeParam InsertReturnColumns Columns to return from the table on insert\n\t *  queries that return columns. `['*']` returns all columns; `[]` returns\n\t *  none. May specify aliases. Defaults to `KeyColumns`.\n\t * @typeParam UpdateReturnColumns Columns to return from the table on update\n\t *  queries that return columns. `['*']` returns all columns; `[]` returns\n\t *  none and is the default. May specify aliases.\n\t * @typeParam InsertReturn Type returned from inserts. Defaults to an object\n\t *  whose properties are the columns of `InsertReturnColumns`.\n\t * @typeParam UpdateReturn Type returned from updates. Defaults to an object\n", " *  whose properties are the columns of `UpdateReturnColumns`.\n\t */\n\texport class TableMapper<\n\t  DB,\n\t  TB extends keyof DB & string,\n\t  KeyColumns extends\n\t    | Readonly<SelectableColumnTuple<DB[TB]>>\n\t    | Readonly<[]> = [],\n\t  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = ['*'],\n\t  SelectedObject = SelectedRow<\n", "    DB,\n\t    TB,\n\t    SelectedColumns extends ['*'] ? never : SelectedColumns[number],\n\t    SelectedColumns\n\t  >,\n\t  InsertedObject = Insertable<DB[TB]>,\n\t  UpdatingObject = Updateable<DB[TB]>,\n\t  ReturnCount = bigint,\n\t  InsertReturnColumns extends\n\t    | Readonly<SelectionColumn<DB, TB>[]>\n", "    | ['*'] = Readonly<KeyColumns>,\n\t  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = [],\n\t  InsertReturn = InsertReturnColumns extends ['*']\n\t    ? Selectable<DB[TB]>\n\t    : Selection<DB, TB, InsertReturnColumns[number]>,\n\t  UpdateReturn = UpdateReturnColumns extends ['*']\n\t    ? Selectable<DB[TB]>\n\t    : Selection<DB, TB, UpdateReturnColumns[number]>\n\t> extends AbstractTableMapper<\n\t  DB,\n", "  TB,\n\t  KeyColumns,\n\t  SelectedColumns,\n\t  SelectedObject,\n\t  InsertedObject,\n\t  UpdatingObject,\n\t  ReturnCount,\n\t  InsertReturnColumns,\n\t  UpdateReturnColumns,\n\t  InsertReturn,\n", "  UpdateReturn\n\t> {\n\t  /**\n\t   * Returns a new table mapper that uses the provided transformations, along\n\t   * with the settings of the current table mapper.\n\t   * @param transforms The transforms to use.\n\t   * @returns A new table mapper that uses the provided transforms.\n\t   */\n\t  withTransforms<\n\t    SelectedObject = SelectedRow<\n", "      DB,\n\t      TB,\n\t      SelectedColumns extends ['*'] ? never : SelectedColumns[number],\n\t      SelectedColumns\n\t    >,\n\t    InsertedObject = Insertable<DB[TB]>,\n\t    UpdatingObject = Updateable<DB[TB]>,\n\t    ReturnCount = bigint,\n\t    InsertReturn = InsertReturnColumns extends ['*']\n\t      ? Selectable<DB[TB]>\n", "      : Selection<DB, TB, InsertReturnColumns[number]>,\n\t    UpdateReturn = UpdateReturnColumns extends ['*']\n\t      ? Selectable<DB[TB]>\n\t      : Selection<DB, TB, UpdateReturnColumns[number]>\n\t  >(\n\t    transforms: Readonly<\n\t      TableMapperTransforms<\n\t        DB,\n\t        TB,\n\t        KeyColumns,\n", "        SelectedColumns,\n\t        SelectedObject,\n\t        InsertedObject,\n\t        UpdatingObject,\n\t        ReturnCount,\n\t        InsertReturnColumns,\n\t        UpdateReturnColumns,\n\t        InsertReturn,\n\t        UpdateReturn\n\t      >\n", "    >\n\t  ) {\n\t    const transformingTableMapper = new TableMapper<\n\t      DB,\n\t      TB,\n\t      KeyColumns,\n\t      SelectedColumns,\n\t      SelectedObject,\n\t      InsertedObject,\n\t      UpdatingObject,\n", "      ReturnCount,\n\t      InsertReturnColumns,\n\t      UpdateReturnColumns,\n\t      InsertReturn,\n\t      UpdateReturn\n\t    >(this.db, this.tableName, this.settings);\n\t    transformingTableMapper.transforms = transforms;\n\t    return transformingTableMapper;\n\t  }\n\t}\n"]}
{"filename": "src/mappers/entire-row-transforms.ts", "chunked_list": ["import { Insertable, Selectable, Updateable } from 'kysely';\n\timport {\n\t  SelectableColumnTuple,\n\t  SelectedRow,\n\t  SelectionColumn,\n\t} from '../lib/type-utils';\n\timport { TableMapperTransforms } from './table-mapper-transforms';\n\t/**\n\t * Transforms for a table mapper that only receives and returns\n\t * entire table rows, given by type `Selectable<DB[TB]>`.\n", " * @typeParam DB Interface whose fields are table names defining tables.\n\t * @typeParam TB Name of the table.\n\t * @typeParam KeyColumns Tuple of the names of the table's key columns.\n\t *  Defaults to `[]`, indicating no key columns. Supports up to 4 columns.\n\t * @typeParam InsertReturnColumns Columns to return from the table on insert\n\t *  queries that return columns. `['*']` returns all columns; `[]` returns\n\t *  none. May specify aliases. Defaults to `KeyColumns`.\n\t * @typeParam UpdateReturnColumns Columns to return from the table on update\n\t *  queries that return columns. `['*']` returns all columns; `[]` returns\n\t *  none and is the default. May specify aliases.\n", " */\n\texport class EntireRowTransforms<\n\t  DB,\n\t  TB extends keyof DB & string,\n\t  KeyColumns extends Readonly<SelectableColumnTuple<DB[TB]>> | Readonly<[]>,\n\t  InsertReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n\t  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*']\n\t> implements\n\t    Required<\n\t      TableMapperTransforms<\n", "        DB,\n\t        TB,\n\t        KeyColumns,\n\t        ['*'],\n\t        Selectable<DB[TB]>,\n\t        Selectable<DB[TB]>,\n\t        Selectable<DB[TB]>,\n\t        number,\n\t        InsertReturnColumns,\n\t        UpdateReturnColumns,\n", "        Selectable<DB[TB]>,\n\t        Selectable<DB[TB]>\n\t      >\n\t    >\n\t{\n\t  /**\n\t   * Constructs an object providing transforms for entire table rows.\n\t   */\n\t  constructor(readonly keyColumns: KeyColumns) {}\n\t  /**\n", "   * Transform a count of the number of rows affected into a number.\n\t   */\n\t  countTransform(count: bigint) {\n\t    return Number(count);\n\t  }\n\t  /**\n\t   * Transforms inserted objects into inserted rows, removing the columns\n\t   * that are keys having falsy values.\n\t   */\n\t  insertTransform(\n", "    obj: Selectable<DB[TB]>,\n\t    _columns: Readonly<(keyof Insertable<DB[TB]>)[]> | ['*']\n\t  ) {\n\t    const insertedValues = { ...obj };\n\t    this.keyColumns.forEach((column) => {\n\t      if (!obj[column as unknown as keyof Selectable<DB[TB]>]) {\n\t        delete insertedValues[column as unknown as keyof Selectable<DB[TB]>];\n\t      }\n\t    });\n\t    return insertedValues as unknown as Insertable<DB[TB]>;\n", "  }\n\t  /**\n\t   * Transforms the returns of an insert query into the the object returned\n\t   * to the caller, merging the returned values into the inserted object.\n\t   */\n\t  insertReturnTransform(\n\t    source: Selectable<DB[TB]>,\n\t    returns: InsertReturnColumns extends []\n\t      ? never\n\t      : SelectedRow<\n", "          DB,\n\t          TB,\n\t          InsertReturnColumns extends ['*']\n\t            ? never\n\t            : InsertReturnColumns[number],\n\t          InsertReturnColumns\n\t        >\n\t  ) {\n\t    if (returns === undefined) return source;\n\t    return { ...source, ...returns };\n", "  }\n\t  /**\n\t   * Returns selected rows to the caller as selected objects, unchanged.\n\t   */\n\t  selectTransform(row: Selectable<DB[TB]>) {\n\t    return row;\n\t  }\n\t  /**\n\t   * Provides updating objects as the update values for an update query.\n\t   */\n", "  updateTransform(\n\t    source: Selectable<DB[TB]>,\n\t    _columns: Readonly<(keyof Updateable<DB[TB]>)[]> | ['*']\n\t  ) {\n\t    return source as Updateable<DB[TB]>;\n\t  }\n\t  /**\n\t   * Transforms the returns of an update query into the the object returned\n\t   * to the caller, merging the returned values into the updating object.\n\t   */\n", "  updateReturnTransform(\n\t    source: Selectable<DB[TB]>,\n\t    returns: UpdateReturnColumns extends []\n\t      ? never\n\t      : SelectedRow<\n\t          DB,\n\t          TB,\n\t          UpdateReturnColumns extends ['*']\n\t            ? never\n\t            : UpdateReturnColumns[number],\n", "          UpdateReturnColumns\n\t        >\n\t  ) {\n\t    if (returns === undefined) return source;\n\t    return { ...source, ...returns };\n\t  }\n\t}\n"]}
{"filename": "src/mappers/table-mapper-settings.ts", "chunked_list": ["import { SelectableColumnTuple, SelectionColumn } from '../lib/type-utils';\n\t/**\n\t * Settings governing table mapper behavior, excluding transformations.\n\t * @typeParam DB Interface whose fields are table names defining tables.\n\t * @typeParam TB Name of the table.\n\t * @typeParam KeyColumns Tuple of the names of the table's key columns.\n\t *  Defaults to `[]`, indicating no key columns. Supports up to 4 columns.\n\t * @typeParam SelectedColumns Columns to return from selection queries.\n\t *  Defaults to `['*']`, returning all columns. May specify aliases.\n\t * @typeParam InsertReturnColumns Columns to return from the table on insert\n", " *  queries that return columns. `['*']` returns all columns; `[]` returns\n\t *  none. May specify aliases. Defaults to `KeyColumns`.\n\t * @typeParam UpdateReturnColumns Columns to return from the table on update\n\t *  queries that return columns. `['*']` returns all columns; `[]` returns\n\t *  none and is the default. May specify aliases.\n\t */\n\texport interface TableMapperSettings<\n\t  DB,\n\t  TB extends keyof DB & string,\n\t  KeyColumns extends\n", "    | Readonly<SelectableColumnTuple<DB[TB]>>\n\t    | Readonly<[]> = [],\n\t  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = ['*'],\n\t  InsertReturnColumns extends\n\t    | Readonly<SelectionColumn<DB, TB>[]>\n\t    | ['*'] = Readonly<KeyColumns>,\n\t  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = []\n\t> {\n\t  /**\n\t   * Tuple of the columns that make up the table's key. Defaults to `[]`,\n", "   * indicating that no columns are keys.\n\t   */\n\t  keyColumns?: KeyColumns;\n\t  /**\n\t   * Columns to return from selection queries. Defaults to `[*]`, selecting\n\t   * all columns. May contain aliases.\n\t   */\n\t  selectedColumns?: SelectedColumns;\n\t  /**\n\t   * Columns to return from insert queries that return columns. `['*']`\n", "   * returns all columns; `[]` returns none. May specify aliases. Defaults\n\t   * to `KeyColumns`.\n\t   */\n\t  insertReturnColumns?: InsertReturnColumns;\n\t  /**\n\t   * Columns to return from update queries that return columns. `['*']` returns\n\t   * all columns; `[]` returns none and is the default. May specify aliases.\n\t   */\n\t  updateReturnColumns?: UpdateReturnColumns;\n\t}\n"]}
{"filename": "src/mappers/table-mapper-transforms.ts", "chunked_list": ["import { Insertable, Selectable, Selection, Updateable } from 'kysely';\n\timport {\n\t  SelectableColumnTuple,\n\t  SelectedRow,\n\t  SelectionColumn,\n\t} from '../lib/type-utils';\n\t/**\n\t * Transformations to apply to values provided to and received from queries.\n\t * All transformations are optional. When no transformation is provided, the\n\t * value is passed through unchanged.\n", " * @typeParam DB Interface whose fields are table names defining tables.\n\t * @typeParam TB Name of the table.\n\t * @typeParam KeyColumns Tuple of the names of the table's key columns.\n\t *  Defaults to `[]`, indicating no key columns. Supports up to 4 columns.\n\t * @typeParam SelectedColumns Columns to return from selection queries.\n\t *  Defaults to `['*']`, returning all columns. May specify aliases.\n\t * @typeParam SelectedObject Type of objects returned by select queries.\n\t * @typeParam InsertedObject Type of objects inserted into the table.\n\t * @typeParam UpdatingObject Type of objects used to update rows of the table.\n\t * @typeParam Type of the count of the number of affected rows.\n", " * @typeParam InsertReturnColumns Columns to return from the table on insert\n\t *  queries that return columns. `['*']` returns all columns; `[]` returns\n\t *  none. May specify aliases. Defaults to `KeyColumns`.\n\t * @typeParam UpdateReturnColumns Columns to return from the table on update\n\t *  queries that return columns. `['*']` returns all columns; `[]` returns\n\t *  none and is the default. May specify aliases.\n\t * @typeParam InsertReturn Type returned from inserts. Defaults to an object\n\t *  whose properties are the columns of `InsertReturnColumns`.\n\t * @typeParam UpdateReturn Type returned from updates. Defaults to an object\n\t *  whose properties are the columns of `UpdateReturnColumns`.\n", " */\n\texport interface TableMapperTransforms<\n\t  DB,\n\t  TB extends keyof DB & string,\n\t  KeyColumns extends\n\t    | Readonly<SelectableColumnTuple<DB[TB]>>\n\t    | Readonly<[]> = [],\n\t  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = ['*'],\n\t  SelectedObject = SelectedRow<\n\t    DB,\n", "    TB,\n\t    SelectedColumns extends ['*'] ? never : SelectedColumns[number],\n\t    SelectedColumns\n\t  >,\n\t  InsertedObject = Insertable<DB[TB]>,\n\t  UpdatingObject = Updateable<DB[TB]>,\n\t  ReturnCount = bigint,\n\t  InsertReturnColumns extends\n\t    | Readonly<SelectionColumn<DB, TB>[]>\n\t    | ['*'] = Readonly<KeyColumns>,\n", "  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = [],\n\t  InsertReturn = InsertReturnColumns extends ['*']\n\t    ? Selectable<DB[TB]>\n\t    : Selection<DB, TB, InsertReturnColumns[number]>,\n\t  UpdateReturn = UpdateReturnColumns extends ['*']\n\t    ? Selectable<DB[TB]>\n\t    : Selection<DB, TB, UpdateReturnColumns[number]>\n\t> extends CountTransform<ReturnCount>,\n\t    InsertTransforms<DB, TB, InsertedObject, InsertReturnColumns, InsertReturn>,\n\t    SelectTransform<DB, TB, SelectedColumns, SelectedObject>,\n", "    UpdateTransforms<\n\t      DB,\n\t      TB,\n\t      UpdatingObject,\n\t      UpdateReturnColumns,\n\t      UpdateReturn\n\t    > {}\n\texport interface CountTransform<ReturnCount> {\n\t  /**\n\t   * Transformation to apply to bigint count results indicating the number of\n", "   * rows affected, before returning the count to the client. `count` is the\n\t   * count returned by the query.\n\t   */\n\t  countTransform?: (count: bigint) => ReturnCount;\n\t}\n\texport interface InsertTransforms<\n\t  DB,\n\t  TB extends keyof DB & string,\n\t  InsertedObject,\n\t  InsertReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n", "  InsertReturn\n\t> {\n\t  /**\n\t   * Transformation to apply to inserted objects before insertion. `source`\n\t   * is the object provided for insertion. Only the columns in `columns` will\n\t   * actually be inserted, with `[*]` indicating all columns.\n\t   */\n\t  insertTransform?: (\n\t    source: InsertedObject,\n\t    columns: Readonly<(keyof Insertable<DB[TB]>)[]> | ['*']\n", "  ) => Insertable<DB[TB]>;\n\t  /**\n\t   * Transformation to apply to column values returned from inserts before\n\t   * returning values to the client. When inferring type parameters, specify\n\t   * a type for the `source` parameter. `source` is the object that was provided\n\t   * for insertion, and `returns` are the values returned from the insert.\n\t   */\n\t  insertReturnTransform?: (\n\t    source: InsertedObject,\n\t    returns: InsertReturnColumns extends []\n", "      ? never\n\t      : SelectedRow<\n\t          DB,\n\t          TB,\n\t          InsertReturnColumns extends ['*']\n\t            ? never\n\t            : InsertReturnColumns[number],\n\t          InsertReturnColumns\n\t        >\n\t  ) => InsertReturn;\n", "}\n\texport interface SelectTransform<\n\t  DB,\n\t  TB extends keyof DB & string,\n\t  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n\t  SelectedObject\n\t> {\n\t  /**\n\t   * Transformation to apply to selected objects after retrieval from the\n\t   * database and before returning to the client. `row` is the selected\n", "   * row, as returned by the Kysely query.\n\t   */\n\t  selectTransform?: (\n\t    row: SelectedRow<\n\t      DB,\n\t      TB,\n\t      SelectedColumns extends ['*'] ? never : SelectedColumns[number],\n\t      SelectedColumns\n\t    >\n\t  ) => SelectedObject;\n", "}\n\texport interface UpdateTransforms<\n\t  DB,\n\t  TB extends keyof DB & string,\n\t  UpdatingObject,\n\t  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'],\n\t  UpdateReturn\n\t> {\n\t  /**\n\t   * Transformation to apply to objects provided for updating rows. `source`\n", "   * is the object containing the values which which to update the table row.\n\t   * Only the columns in `columns` will actually be updated, with `[*]`\n\t   * indicating all columns.\n\t   */\n\t  updateTransform?: (\n\t    source: UpdatingObject,\n\t    columns: Readonly<(keyof Updateable<DB[TB]>)[]> | ['*']\n\t  ) => Updateable<DB[TB]>;\n\t  /**\n\t   * Transformation to apply to column values returned from updates before\n", "   * returning values to the client. When inferring type parameters, specify\n\t   * a type for the `source` parameter. `source` is the object that contained\n\t   * the valiues with which the table row was updated, and `returns` are the\n\t   * values returned from the update.\n\t   */\n\t  updateReturnTransform?: (\n\t    source: UpdatingObject,\n\t    returns: UpdateReturnColumns extends []\n\t      ? never\n\t      : SelectedRow<\n", "          DB,\n\t          TB,\n\t          UpdateReturnColumns extends ['*']\n\t            ? never\n\t            : UpdateReturnColumns[number],\n\t          UpdateReturnColumns\n\t        >\n\t  ) => UpdateReturn;\n\t}\n"]}
{"filename": "src/mappers/abstract-table-mapper.ts", "chunked_list": ["import {\n\t  Kysely,\n\t  Insertable,\n\t  ReferenceExpression,\n\t  Selectable,\n\t  InsertQueryBuilder,\n\t  InsertResult,\n\t  SelectQueryBuilder,\n\t  Selection,\n\t  DeleteQueryBuilder,\n", "  DeleteResult,\n\t  UpdateResult,\n\t  UpdateQueryBuilder,\n\t  ComparisonOperatorExpression,\n\t  OperandValueExpressionOrList,\n\t  Updateable,\n\t} from 'kysely';\n\timport { QueryFilter } from '../lib/query-filter';\n\timport { applyQueryFilter } from '../lib/apply-query-filter';\n\timport {\n", "  SelectableColumnTuple,\n\t  SelectedRow,\n\t  SelectionColumn,\n\t} from '../lib/type-utils';\n\timport { MappingDeleteQuery } from '../queries/delete-query';\n\timport { MappingSelectQuery } from '../queries/select-query';\n\timport { MappingUpdateQuery } from '../queries/update-query';\n\timport { AnyColumnsMappingInsertQuery } from '../queries/any-insert-query';\n\timport { AnyColumnsMappingUpdateQuery } from '../queries/any-update-query';\n\timport { ParametersObject, QueryParameterMaker } from 'kysely-params';\n", "import { ParameterizableMappingQueryFactory } from '../lib/parameterizable-query-factory';\n\timport { CompilingMappingSelectQuery } from '../queries/compiling-select-query';\n\timport { CompilingMappingDeleteQuery } from '../queries/compiling-delete-query';\n\timport { SubsettingMappingUpdateQuery } from '../queries/subsetting-update-query';\n\timport { CompilingMappingUpdateQuery } from '../queries/compiling-update-query';\n\timport { TableMapperSettings } from './table-mapper-settings';\n\timport { TableMapperTransforms } from './table-mapper-transforms';\n\t/**\n\t * Abstract base class for table mappers. It is abstract because it does not\n\t * provide a way to specify query input and output transforms. Custom table\n", " * mappers should extend this class with means for providing transforms.\n\t * @typeParam DB Interface whose fields are table names defining tables.\n\t * @typeParam TB Name of the table.\n\t * @typeParam KeyColumns Tuple of the names of the table's key columns.\n\t *  Defaults to `[]`, indicating no key columns. Supports up to 4 columns.\n\t * @typeParam SelectedColumns Columns to return from selection queries.\n\t *  Defaults to `['*']`, returning all columns. May specify aliases.\n\t * @typeParam SelectedObject Type of objects returned by select queries.\n\t * @typeParam InsertedObject Type of objects inserted into the table.\n\t * @typeParam UpdatingObject Type of objects used to update rows of the table.\n", " * @typeParam ReturnCount Type of the count of the number of affected rows.\n\t * @typeParam InsertReturnColumns Columns to return from the table on insert\n\t *  queries that return columns. `['*']` returns all columns; `[]` returns\n\t *  none. May specify aliases. Defaults to `KeyColumns`.\n\t * @typeParam UpdateReturnColumns Columns to return from the table on update\n\t *  queries that return columns. `['*']` returns all columns; `[]` returns\n\t *  none and is the default. May specify aliases.\n\t * @typeParam InsertReturn Type returned from inserts. Defaults to an object\n\t *  whose properties are the columns of `InsertReturnColumns`.\n\t * @typeParam UpdateReturn Type returned from updates. Defaults to an object\n", " *  whose properties are the columns of `UpdateReturnColumns`.\n\t */\n\texport abstract class AbstractTableMapper<\n\t  DB,\n\t  TB extends keyof DB & string,\n\t  KeyColumns extends\n\t    | Readonly<SelectableColumnTuple<DB[TB]>>\n\t    | Readonly<[]> = [],\n\t  SelectedColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = ['*'],\n\t  SelectedObject = SelectedRow<\n", "    DB,\n\t    TB,\n\t    SelectedColumns extends ['*'] ? never : SelectedColumns[number],\n\t    SelectedColumns\n\t  >,\n\t  InsertedObject = Insertable<DB[TB]>,\n\t  UpdatingObject = Updateable<DB[TB]>,\n\t  ReturnCount = bigint,\n\t  InsertReturnColumns extends\n\t    | Readonly<SelectionColumn<DB, TB>[]>\n", "    | ['*'] = Readonly<KeyColumns>,\n\t  UpdateReturnColumns extends Readonly<SelectionColumn<DB, TB>[]> | ['*'] = [],\n\t  InsertReturn = InsertReturnColumns extends ['*']\n\t    ? Selectable<DB[TB]>\n\t    : Selection<DB, TB, InsertReturnColumns[number]>,\n\t  UpdateReturn = UpdateReturnColumns extends ['*']\n\t    ? Selectable<DB[TB]>\n\t    : Selection<DB, TB, UpdateReturnColumns[number]>\n\t> {\n\t  #baseDeleteQB: DeleteQueryBuilder<DB, TB, DeleteResult> | null = null;\n", "  #baseInsertQB: InsertQueryBuilder<DB, TB, InsertResult> | null = null;\n\t  #baseSelectQB: SelectQueryBuilder<DB, TB, object> | null = null;\n\t  #baseUpdateQB: UpdateQueryBuilder<DB, TB, TB, UpdateResult> | null = null;\n\t  /** Columns that compose the table's primary key. */\n\t  protected readonly keyColumns: KeyColumns;\n\t  /** Columns to return from selection queries. `[]` => all columns. */\n\t  protected readonly selectedColumns: SelectionColumn<DB, TB>[];\n\t  /** Columns to return from the table on insert. */\n\t  protected readonly insertReturnColumns:\n\t    | Readonly<SelectionColumn<DB, TB>[]>\n", "    | ['*'];\n\t  /** Columns to return from the table on update. */\n\t  protected readonly updateReturnColumns:\n\t    | Readonly<SelectionColumn<DB, TB>[]>\n\t    | ['*'];\n\t  /** Query input and output value transforms. */\n\t  protected transforms: TableMapperTransforms<\n\t    DB,\n\t    TB,\n\t    KeyColumns,\n", "    SelectedColumns,\n\t    SelectedObject,\n\t    InsertedObject,\n\t    UpdatingObject,\n\t    ReturnCount,\n\t    InsertReturnColumns,\n\t    UpdateReturnColumns,\n\t    InsertReturn,\n\t    UpdateReturn\n\t  > = {};\n", "  /**\n\t   * Constructs a new abstract table mapper.\n\t   * @param db The Kysely database.\n\t   * @param tableName The name of the table.\n\t   * @param options Options governing mapper behavior. Default to selecting\n\t   *  all columns and to returning no columns on insert or update.\n\t   */\n\t  constructor(\n\t    readonly db: Kysely<DB>,\n\t    readonly tableName: TB,\n", "    readonly settings: Readonly<\n\t      TableMapperSettings<\n\t        DB,\n\t        TB,\n\t        KeyColumns,\n\t        SelectedColumns,\n\t        InsertReturnColumns,\n\t        UpdateReturnColumns\n\t      >\n\t    > = {}\n", "  ) {\n\t    this.keyColumns = settings.keyColumns ?? ([] as any);\n\t    this.selectedColumns =\n\t      settings.selectedColumns === undefined\n\t        ? ([] as any)\n\t        : settings.selectedColumns[0] === '*'\n\t        ? ([] as any)\n\t        : settings.selectedColumns;\n\t    this.insertReturnColumns =\n\t      settings.insertReturnColumns ?? this.keyColumns ?? ([] as any);\n", "    this.updateReturnColumns = settings.updateReturnColumns ?? ([] as any);\n\t  }\n\t  /**\n\t   * Returns a mapping query for deleting the rows of the table that match\n\t   * the provided filter or Kysely binary operation.\n\t   * @param filter Optional filter to apply to the query or the left-hand-side\n\t   *  of a Kysely binary operation.\n\t   * @returns A mapping query for deleting rows.\n\t   */\n\t  delete<RE extends ReferenceExpression<DB, TB>>(\n", "    lhs: RE,\n\t    op: ComparisonOperatorExpression,\n\t    rhs: OperandValueExpressionOrList<DB, TB, RE>\n\t  ): MappingDeleteQuery<\n\t    DB,\n\t    TB,\n\t    DeleteQueryBuilder<DB, TB, DeleteResult>,\n\t    ReturnCount\n\t  >;\n\t  delete<RE extends ReferenceExpression<DB, TB>>(\n", "    filter?: QueryFilter<DB, TB, KeyColumns, RE>\n\t  ): MappingDeleteQuery<\n\t    DB,\n\t    TB,\n\t    DeleteQueryBuilder<DB, TB, DeleteResult>,\n\t    ReturnCount\n\t  >;\n\t  delete<RE extends ReferenceExpression<DB, TB>>(\n\t    filterOrLHS?: QueryFilter<DB, TB, KeyColumns, RE> | RE,\n\t    op?: ComparisonOperatorExpression,\n", "    rhs?: OperandValueExpressionOrList<DB, TB, RE>\n\t  ): MappingDeleteQuery<\n\t    DB,\n\t    TB,\n\t    DeleteQueryBuilder<DB, TB, DeleteResult>,\n\t    ReturnCount\n\t  > {\n\t    return new MappingDeleteQuery(\n\t      this.db,\n\t      filterOrLHS === undefined\n", "        ? this.getDeleteQB()\n\t        : applyQueryFilter(\n\t            this.db,\n\t            this.getDeleteQB(),\n\t            this.keyColumns,\n\t            filterOrLHS,\n\t            op,\n\t            rhs\n\t          ),\n\t      this.transforms\n", "    );\n\t  }\n\t  /**\n\t   * Returns a query for inserting rows into the table.\n\t   * @returns A mapping query for inserting rows.\n\t   */\n\t  insert(): AnyColumnsMappingInsertQuery<\n\t    DB,\n\t    TB,\n\t    InsertQueryBuilder<DB, TB, InsertResult>,\n", "    InsertedObject,\n\t    InsertReturnColumns,\n\t    InsertReturn\n\t  > {\n\t    return new AnyColumnsMappingInsertQuery(\n\t      this.db,\n\t      this.getInsertQB(),\n\t      this.transforms,\n\t      this.insertReturnColumns as InsertReturnColumns\n\t    );\n", "  }\n\t  /**\n\t   * Creates and returns a parameterized mapping query, which can be repeatedly\n\t   * executed with different parameter values, but which only ever compiles\n\t   * the underlying Kysely query once (on the first execution).\n\t   * @paramtype Parameters Record characterizing the available parameter names\n\t   *  and types.\n\t   * @param factory Function that receives an object of the form `{ mapper,\n\t   *  param }`, where `mapper` is the present table mapper and `param` is a\n\t   *  function for creating parameters. The argument to `param` is the name of\n", "   *  the parameter, which must occur as a property of `Parameters`. You may\n\t   *  parameterize inserted values, updated values, and right-hand-side values\n\t   *  of filters. Parameters may not be arrays, but you can parameterize the\n\t   *  individual elements of an array. Returns a parameterized mapping query.\n\t   * @returns A parameterized mapping query\n\t   */\n\t  parameterize<Parameters extends ParametersObject<Parameters>>(\n\t    factory: ParameterizableMappingQueryFactory<\n\t      DB,\n\t      TB,\n", "      KeyColumns,\n\t      SelectedColumns,\n\t      SelectedObject,\n\t      InsertedObject,\n\t      UpdatingObject,\n\t      ReturnCount,\n\t      InsertReturnColumns,\n\t      UpdateReturnColumns,\n\t      InsertReturn,\n\t      UpdateReturn,\n", "      this,\n\t      Parameters,\n\t      MappingDeleteQuery<\n\t        DB,\n\t        TB,\n\t        DeleteQueryBuilder<DB, TB, DeleteResult>,\n\t        ReturnCount\n\t      >\n\t    >\n\t  ): CompilingMappingDeleteQuery<\n", "    DB,\n\t    TB,\n\t    DeleteQueryBuilder<DB, TB, DeleteResult>,\n\t    ReturnCount,\n\t    Parameters\n\t  >;\n\t  parameterize<Parameters extends ParametersObject<Parameters>>(\n\t    factory: ParameterizableMappingQueryFactory<\n\t      DB,\n\t      TB,\n", "      KeyColumns,\n\t      SelectedColumns,\n\t      SelectedObject,\n\t      InsertedObject,\n\t      UpdatingObject,\n\t      ReturnCount,\n\t      InsertReturnColumns,\n\t      UpdateReturnColumns,\n\t      InsertReturn,\n\t      UpdateReturn,\n", "      this,\n\t      Parameters,\n\t      MappingSelectQuery<\n\t        DB,\n\t        TB,\n\t        SelectedColumns,\n\t        SelectedObject,\n\t        SelectQueryBuilder<DB, TB, object>\n\t      >\n\t    >\n", "  ): CompilingMappingSelectQuery<\n\t    DB,\n\t    TB,\n\t    SelectedColumns,\n\t    SelectedObject,\n\t    SelectQueryBuilder<DB, TB, object>,\n\t    Parameters\n\t  >;\n\t  parameterize<Parameters extends ParametersObject<Parameters>>(\n\t    factory: ParameterizableMappingQueryFactory<\n", "      DB,\n\t      TB,\n\t      KeyColumns,\n\t      SelectedColumns,\n\t      SelectedObject,\n\t      InsertedObject,\n\t      UpdatingObject,\n\t      ReturnCount,\n\t      InsertReturnColumns,\n\t      UpdateReturnColumns,\n", "      InsertReturn,\n\t      UpdateReturn,\n\t      this,\n\t      Parameters,\n\t      SubsettingMappingUpdateQuery<\n\t        DB,\n\t        TB,\n\t        UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n\t        UpdatingObject,\n\t        UpdateReturnColumns,\n", "        ReturnCount,\n\t        UpdateReturn\n\t      >\n\t    >\n\t  ): CompilingMappingUpdateQuery<\n\t    DB,\n\t    TB,\n\t    UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n\t    UpdatingObject,\n\t    UpdateReturnColumns,\n", "    ReturnCount,\n\t    UpdateReturn,\n\t    Parameters\n\t  >;\n\t  parameterize<Parameters extends ParametersObject<Parameters>>(\n\t    factory: ParameterizableMappingQueryFactory<\n\t      DB,\n\t      TB,\n\t      KeyColumns,\n\t      SelectedColumns,\n", "      SelectedObject,\n\t      InsertedObject,\n\t      UpdatingObject,\n\t      ReturnCount,\n\t      InsertReturnColumns,\n\t      UpdateReturnColumns,\n\t      InsertReturn,\n\t      UpdateReturn,\n\t      this,\n\t      Parameters,\n", "      any\n\t    >\n\t  ): any {\n\t    const parameterMaker = new QueryParameterMaker<Parameters>();\n\t    return factory({\n\t      mapper: this,\n\t      param: parameterMaker.param.bind(parameterMaker),\n\t    }).compile();\n\t  }\n\t  /**\n", "   * Returns a reference to a column, which can be a generated string.\n\t   * (Shorthand for `db.dynamic.ref(column)`.)\n\t   * @param column The column name being referenced.\n\t   * @returns A reference to the given column.\n\t   */\n\t  ref(column: string) {\n\t    return this.db.dynamic.ref(column);\n\t  }\n\t  /**\n\t   * Returns a mapping query for selecting rows of the table that match\n", "   *  the provided filter or Kysely binary operation.\n\t   * @param filter Optional filter to apply to the query or the left-hand-side\n\t   *  of a Kysely binary operation.\n\t   * @returns A mapping query for retrieving rows as objects.\n\t   */\n\t  select<RE extends ReferenceExpression<DB, TB>>(\n\t    lhs: RE,\n\t    op: ComparisonOperatorExpression,\n\t    rhs: OperandValueExpressionOrList<DB, TB, RE>\n\t  ): MappingSelectQuery<\n", "    DB,\n\t    TB,\n\t    SelectedColumns,\n\t    SelectedObject,\n\t    SelectQueryBuilder<DB, TB, object>\n\t  >;\n\t  select<RE extends ReferenceExpression<DB, TB>>(\n\t    filter?: QueryFilter<DB, TB, KeyColumns, RE>\n\t  ): MappingSelectQuery<\n\t    DB,\n", "    TB,\n\t    SelectedColumns,\n\t    SelectedObject,\n\t    SelectQueryBuilder<DB, TB, object>\n\t  >;\n\t  select<RE extends ReferenceExpression<DB, TB>>(\n\t    filterOrLHS?: QueryFilter<DB, TB, KeyColumns, RE> | RE,\n\t    op?: ComparisonOperatorExpression,\n\t    rhs?: OperandValueExpressionOrList<DB, TB, RE>\n\t  ): MappingSelectQuery<\n", "    DB,\n\t    TB,\n\t    SelectedColumns,\n\t    SelectedObject,\n\t    SelectQueryBuilder<DB, TB, object>\n\t  > {\n\t    return new MappingSelectQuery(\n\t      this.db,\n\t      filterOrLHS === undefined\n\t        ? this.getSelectQB()\n", "        : applyQueryFilter(\n\t            this.db,\n\t            this.getSelectQB(),\n\t            this.keyColumns,\n\t            filterOrLHS,\n\t            op,\n\t            rhs\n\t          ),\n\t      this.transforms\n\t    );\n", "  }\n\t  /**\n\t   * Returns a mapping query for updating rows of the table that match\n\t   *  the provided filter or Kysely binary operation.\n\t   * @param filter Optional filter to apply to the query or the left-hand-side\n\t   *  of a Kysely binary operation.\n\t   * @returns A mapping query for updating table rows.\n\t   */\n\t  update<RE extends ReferenceExpression<DB, TB>>(\n\t    lhs: RE,\n", "    op: ComparisonOperatorExpression,\n\t    rhs: OperandValueExpressionOrList<DB, TB, RE>\n\t  ): AnyColumnsMappingUpdateQuery<\n\t    DB,\n\t    TB,\n\t    UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n\t    UpdatingObject,\n\t    UpdateReturnColumns,\n\t    ReturnCount,\n\t    UpdateReturn\n", "  >;\n\t  update<RE extends ReferenceExpression<DB, TB>>(\n\t    filter?: QueryFilter<DB, TB, KeyColumns, RE>\n\t  ): AnyColumnsMappingUpdateQuery<\n\t    DB,\n\t    TB,\n\t    UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n\t    UpdatingObject,\n\t    UpdateReturnColumns,\n\t    ReturnCount,\n", "    UpdateReturn\n\t  >;\n\t  update<RE extends ReferenceExpression<DB, TB>>(\n\t    filterOrLHS?: QueryFilter<DB, TB, KeyColumns, RE> | RE,\n\t    op?: ComparisonOperatorExpression,\n\t    rhs?: OperandValueExpressionOrList<DB, TB, RE>\n\t  ): MappingUpdateQuery<\n\t    DB,\n\t    TB,\n\t    UpdateQueryBuilder<DB, TB, TB, UpdateResult>,\n", "    UpdatingObject,\n\t    UpdateReturnColumns,\n\t    ReturnCount,\n\t    UpdateReturn\n\t  > {\n\t    return new AnyColumnsMappingUpdateQuery(\n\t      this.db,\n\t      filterOrLHS === undefined\n\t        ? this.getUpdateQB()\n\t        : applyQueryFilter(\n", "            this.db,\n\t            this.getUpdateQB(),\n\t            this.keyColumns,\n\t            filterOrLHS,\n\t            op,\n\t            rhs\n\t          ),\n\t      this.transforms,\n\t      this.updateReturnColumns as UpdateReturnColumns\n\t    );\n", "  }\n\t  /**\n\t   * Returns a query builder for deleting rows from the table, caching the\n\t   * query builder for use with future deletions.\n\t   * @returns A query builder for deleting rows from the table.\n\t   */\n\t  protected getDeleteQB(): DeleteQueryBuilder<DB, TB, DeleteResult> {\n\t    if (this.#baseDeleteQB === null) {\n\t      this.#baseDeleteQB = this.db.deleteFrom(\n\t        this.tableName\n", "      ) as DeleteQueryBuilder<DB, TB, DeleteResult>;\n\t    }\n\t    return this.#baseDeleteQB;\n\t  }\n\t  /**\n\t   * Returns a query builder for inserting rows into the table, caching the\n\t   * query builder for use with future insertions.\n\t   * @returns A query builder for inserting rows into the table.\n\t   */\n\t  protected getInsertQB(): InsertQueryBuilder<DB, TB, InsertResult> {\n", "    if (this.#baseInsertQB === null) {\n\t      this.#baseInsertQB = this.db.insertInto(\n\t        this.tableName\n\t      ) as InsertQueryBuilder<DB, TB, InsertResult>;\n\t    }\n\t    return this.#baseInsertQB;\n\t  }\n\t  /**\n\t   * Returns a query builder for selecting rows from the table, caching the\n\t   * query builder for use with future selection. The query builder returns\n", "   * the columns and aliases specified in `SelectedColumns`.\n\t   * @returns A query builder for selecting rows from the table.\n\t   */\n\t  protected getSelectQB(): SelectedColumns extends ['*']\n\t    ? never\n\t    : SelectQueryBuilder<\n\t        DB,\n\t        TB,\n\t        object & Selection<DB, TB, SelectedColumns[number]>\n\t      >;\n", "  protected getSelectQB(): SelectQueryBuilder<DB, TB, object> {\n\t    if (this.#baseSelectQB === null) {\n\t      const selectQB = this.db.selectFrom(this.tableName) as SelectQueryBuilder<\n\t        DB,\n\t        TB,\n\t        object\n\t      >;\n\t      this.#baseSelectQB =\n\t        this.selectedColumns.length == 0\n\t          ? selectQB.selectAll()\n", "          : selectQB.select(this.selectedColumns);\n\t    }\n\t    return this.#baseSelectQB;\n\t  }\n\t  /**\n\t   * Returns a query builder for updating rows from the table, caching the\n\t   * query builder for use with future updates.\n\t   * @returns A query builder for updating rows from the table.\n\t   */\n\t  protected getUpdateQB(): UpdateQueryBuilder<DB, TB, TB, UpdateResult> {\n", "    if (this.#baseUpdateQB === null) {\n\t      this.#baseUpdateQB = this.db.updateTable(this.tableName) as any;\n\t    }\n\t    return this.#baseUpdateQB!;\n\t  }\n\t}\n"]}
