{"filename": "src/types.ts", "chunked_list": ["import { narrow } from \"abitype\";\n\timport IZeroEx from \"./abi/IZeroEx.json\";\n\timport type {\n\t  Contract,\n\t  BaseContractMethod,\n\t  TransactionReceipt,\n\t  TransactionDescription,\n\t} from \"ethers\";\n\texport type PermitAndCallChainIds = 1 | 137 | 8453;\n\texport type SupportedChainId = 1 | 5 | 10 | 56 | 137 | 250 | 8453 | 42220 | 43114 | 42161;\n", "export interface CallResult {\n\t  success: boolean;\n\t  returnData: string;\n\t}\n\tinterface Call {\n\t  target: string;\n\t  callData: string;\n\t}\n\ttype BlockHash = string;\n\texport type AggregateResponse = [bigint, BlockHash, CallResult[]];\n", "export const exchangeProxyAbi = narrow(IZeroEx.compilerOutput.abi);\n\texport type Mtx = [\n\t  signer: string,\n\t  sender: string,\n\t  expirationTimeSeconds: bigint,\n\t  salt: bigint,\n\t  calldata: string,\n\t  feeToken: string,\n\t  fees: [[recipient: string]]\n\t];\n", "export interface ProcessedLog {\n\t  to: string;\n\t  from: string;\n\t  symbol: string;\n\t  amount: string;\n\t  address: string;\n\t  decimals: number;\n\t}\n\texport interface EnrichedTxReceipt {\n\t  logs: ProcessedLog[];\n", "  from: string;\n\t}\n\texport type TryBlockAndAggregate = BaseContractMethod<\n\t  [boolean, Call[]],\n\t  AggregateResponse\n\t>;\n\texport interface EnrichedTxReceiptArgs {\n\t  transactionReceipt: TransactionReceipt;\n\t  tryBlockAndAggregate: TryBlockAndAggregate;\n\t}\n", "export interface ProcessReceiptArgs {\n\t  signer: string;\n\t  recipient: string;\n\t  parser: ParserFunction;\n\t  transactionReceipt: TransactionReceipt;\n\t  tryBlockAndAggregate: TryBlockAndAggregate;\n\t  transactionDescription: TransactionDescription;\n\t}\n\texport enum TransactionStatus {\n\t  REVERTED = 0,\n", "  SUCCESSFUL = 1,\n\t}\n\texport interface Log {\n\t  transactionIndex: number;\n\t  blockNumber: number;\n\t  transactionHash: string;\n\t  address: string;\n\t  data: string;\n\t  logIndex?: number;\n\t  blockHash: string;\n", "  topics: readonly string[];\n\t}\n\texport interface EnrichedLogWithoutAmount extends Log {\n\t  symbol: string;\n\t  decimals: number;\n\t  from?: string;\n\t}\n\texport interface ParseSwapArgs {\n\t  transactionHash: string;\n\t  exchangeProxyAbi?: typeof exchangeProxyAbi;\n", "  rpcUrl: string;\n\t}\n\texport type Token = {\n\t  symbol: string;\n\t  amount: string;\n\t  address: string;\n\t};\n\texport type TokenTransaction =\n\t  | {\n\t      tokenIn: Token;\n", "      tokenOut: Token;\n\t    }\n\t  | undefined;\n\ttype TxParams = {\n\t  txReceipt: EnrichedTxReceipt;\n\t  txDescription: TransactionDescription;\n\t};\n\texport type ParserFunction = (params: TxParams) => TokenTransaction;\n\texport interface LogParsers {\n\t  [key: string]: ParserFunction;\n", "}\n\texport type TransformERC20EventData = [string, string, string, bigint, bigint];\n\texport interface ParseGaslessTxArgs {\n\t  logParsers: LogParsers;\n\t  chainId: SupportedChainId;\n\t  exchangeProxyContract: Contract;\n\t  tryBlockAndAggregate: TryBlockAndAggregate;\n\t  transactionReceipt: TransactionReceipt;\n\t  transactionDescription: TransactionDescription;\n\t}\n", "export type ParseSwap = (\n\t  args: ParseSwapArgs\n\t) => Promise<TokenTransaction | null>;\n"]}
{"filename": "src/constants.ts", "chunked_list": ["import { SupportedChainId } from \"./types\";\n\texport const EVENT_SIGNATURES = {\n\t  LimitOrderFilled:\n\t    \"0xab614d2b738543c0ea21f56347cf696a3a0c42a7cbec3212a5ca22a4dcff2124\",\n\t  LiquidityProviderSwap:\n\t    \"0x40a6ba9513d09e3488135e0e0d10e2d4382b792720155b144cbea89ac9db6d34\",\n\t  OtcOrderFilled:\n\t    \"0xac75f773e3a92f1a02b12134d65e1f47f8a14eabe4eaf1e24624918e6a8b269f\",\n\t  MetaTransactionExecuted:\n\t    \"0x7f4fe3ff8ae440e1570c558da08440b26f89fb1c1f2910cd91ca6452955f121a\",\n", "  Transfer:\n\t    \"0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\",\n\t  TransformedERC20:\n\t    \"0x0f6672f78a59ba8e5e5b5d38df3ebc67f3c792e2c9259b8d97d7f00dd78ba1b3\",\n\t} as const;\n\texport const ERC20_FUNCTION_HASHES = {\n\t  symbol: \"0x95d89b41\",\n\t  decimals: \"0x313ce567\",\n\t} as const;\n\texport const EXCHANGE_PROXY_ABI_URL =\n", "  \"https://raw.githubusercontent.com/0xProject/protocol/development/packages/contract-artifacts/artifacts/IZeroEx.json\";\n\tconst CONONICAL_EXCHANGE_PROXY = \"0xdef1c0ded9bec7f1a1670819833240f027b25eff\";\n\texport const MULTICALL3 = \"0xcA11bde05977b3631167028862bE2a173976CA11\";\n\texport const PERMIT_AND_CALL_BY_CHAIN_ID = {\n\t  1: \"0x1291C02D288de3De7dC25353459489073D11E1Ae\",\n\t  137: \"0x2ddd30fe5c12fc4cd497526f14bf3d1fcd3d5db4\",\n\t  8453: \"0x3CA53031Ad0B86a304845e83644983Be3340895f\"\n\t} as const\n\texport const EXCHANGE_PROXY_BY_CHAIN_ID = {\n\t  1: CONONICAL_EXCHANGE_PROXY,\n", "  5: \"0xf91bb752490473b8342a3e964e855b9f9a2a668e\",\n\t  10: \"0xdef1abe32c034e558cdd535791643c58a13acc10\",\n\t  56: CONONICAL_EXCHANGE_PROXY,\n\t  137: CONONICAL_EXCHANGE_PROXY,\n\t  250: \"0xdef189deaef76e379df891899eb5a00a94cbc250\",\n\t  8453: CONONICAL_EXCHANGE_PROXY,\n\t  42161: CONONICAL_EXCHANGE_PROXY,\n\t  42220: CONONICAL_EXCHANGE_PROXY,\n\t  43114: CONONICAL_EXCHANGE_PROXY,\n\t} as const\n", "export const CONTRACTS = {\n\t  weth: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n\t} as const;\n\texport const NATIVE_ASSET = \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\";\n\texport const NATIVE_SYMBOL_BY_CHAIN_ID: Record<SupportedChainId, string> = {\n\t  1: \"ETH\", // Ethereum\n\t  5: \"ETH\", // Goerli\n\t  10: \"ETH\", // Optimism\n\t  56: \"BNB\", // BNB Chain\n\t  137: \"MATIC\", // Polygon\n", "  250: \"FTM\", // Fantom\n\t  8453: \"ETH\", // Base\n\t  42161: \"ETH\", // Arbitrum One\n\t  42220: \"CELO\", // Celo\n\t  43114: \"AVAX\", // Avalanche\n\t} as const;\n"]}
{"filename": "src/index.ts", "chunked_list": ["import { Contract, JsonRpcProvider } from \"ethers\";\n\timport { abi as permitAndCallAbi } from \"./abi/PermitAndCall.json\";\n\timport multicall3Abi from \"./abi/Multicall3.json\";\n\timport {\n\t  MULTICALL3,\n\t  EXCHANGE_PROXY_ABI_URL,\n\t  EXCHANGE_PROXY_BY_CHAIN_ID,\n\t  PERMIT_AND_CALL_BY_CHAIN_ID,\n\t} from \"./constants\";\n\timport {\n", "  fillLimitOrder,\n\t  fillOtcOrder,\n\t  fillOtcOrderForEth,\n\t  fillOtcOrderWithEth,\n\t  fillTakerSignedOtcOrder,\n\t  fillTakerSignedOtcOrderForEth,\n\t  executeMetaTransaction,\n\t  multiplexBatchSellTokenForToken,\n\t  multiplexBatchSellTokenForEth,\n\t  multiplexBatchSellEthForToken,\n", "  multiplexMultiHopSellTokenForToken,\n\t  multiplexMultiHopSellEthForToken,\n\t  multiplexMultiHopSellTokenForEth,\n\t  sellToUniswap,\n\t  sellTokenForEthToUniswapV3,\n\t  sellEthForTokenToUniswapV3,\n\t  sellTokenForTokenToUniswapV3,\n\t  sellToLiquidityProvider,\n\t  sellToPancakeSwap,\n\t  transformERC20,\n", "} from \"./parsers\";\n\timport {\n\t  enrichTxReceipt,\n\t  isChainIdSupported,\n\t  isPermitAndCallChainId,\n\t} from \"./utils\";\n\timport { TransactionStatus } from \"./types\";\n\timport type {\n\t  Mtx,\n\t  LogParsers,\n", "  ParseSwapArgs,\n\t  ParseGaslessTxArgs,\n\t  ProcessReceiptArgs,\n\t} from \"./types\";\n\texport * from \"./types\";\n\texport async function parseSwap({\n\t  transactionHash,\n\t  exchangeProxyAbi,\n\t  rpcUrl,\n\t}: ParseSwapArgs) {\n", "  if (!rpcUrl) throw new Error(\"Missing rpcUrl\");\n\t  if (!transactionHash) throw new Error(\"Missing transaction hash\");\n\t  if (!exchangeProxyAbi)\n\t    throw new Error(`Missing 0x Exchange Proxy ABI: ${EXCHANGE_PROXY_ABI_URL}`);\n\t  const provider = new JsonRpcProvider(rpcUrl);\n\t  const [tx, transactionReceipt] = await Promise.all([\n\t    provider.getTransaction(transactionHash),\n\t    provider.getTransactionReceipt(transactionHash),\n\t  ]);\n\t  if (tx && transactionReceipt) {\n", "    if (transactionReceipt.status === TransactionStatus.REVERTED) return null;\n\t    const chainId = Number(tx.chainId);\n\t    if (!isChainIdSupported(chainId)) {\n\t      throw new Error(`chainId ${chainId} is unsupported.`);\n\t    }\n\t    const exchangeProxyContract = new Contract(\n\t      EXCHANGE_PROXY_BY_CHAIN_ID[chainId],\n\t      exchangeProxyAbi\n\t    );\n\t    const permitAndCallAddress = isPermitAndCallChainId(chainId)\n", "      ? PERMIT_AND_CALL_BY_CHAIN_ID[chainId]\n\t      : undefined;\n\t    const permitAndCallContract = permitAndCallAddress\n\t      ? new Contract(permitAndCallAddress, permitAndCallAbi)\n\t      : undefined;\n\t    const transactionDescription =\n\t      transactionReceipt.to === permitAndCallAddress\n\t        ? permitAndCallContract?.interface.parseTransaction(tx)\n\t        : exchangeProxyContract.interface.parseTransaction(tx);\n\t    if (!transactionDescription) return null;\n", "    const multicall = new Contract(MULTICALL3, multicall3Abi, provider);\n\t    const tryBlockAndAggregate =\n\t      multicall[\n\t        \"tryBlockAndAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls)\"\n\t      ];\n\t    const logParsers: LogParsers = {\n\t      fillLimitOrder,\n\t      fillOtcOrder,\n\t      fillOtcOrderForEth,\n\t      fillOtcOrderWithEth,\n", "      fillTakerSignedOtcOrder,\n\t      fillTakerSignedOtcOrderForEth,\n\t      executeMetaTransaction,\n\t      multiplexBatchSellTokenForToken,\n\t      multiplexBatchSellTokenForEth,\n\t      multiplexBatchSellEthForToken,\n\t      multiplexMultiHopSellTokenForToken,\n\t      multiplexMultiHopSellEthForToken,\n\t      multiplexMultiHopSellTokenForEth,\n\t      sellToUniswap,\n", "      sellTokenForEthToUniswapV3,\n\t      sellEthForTokenToUniswapV3,\n\t      sellTokenForTokenToUniswapV3,\n\t      sellToLiquidityProvider,\n\t      sellToPancakeSwap,\n\t    };\n\t    const parser = logParsers[transactionDescription.name];\n\t    if (transactionDescription.name === \"permitAndCall\") {\n\t      const calldataFromPermitAndCall = transactionDescription.args[7];\n\t      const permitAndCallDescription =\n", "        exchangeProxyContract.interface.parseTransaction({\n\t          data: calldataFromPermitAndCall,\n\t        });\n\t      if (permitAndCallDescription) {\n\t        return parseGaslessTx({\n\t          chainId,\n\t          logParsers,\n\t          tryBlockAndAggregate,\n\t          exchangeProxyContract,\n\t          transactionReceipt,\n", "          transactionDescription: permitAndCallDescription,\n\t        });\n\t      }\n\t    }\n\t    if (transactionDescription.name === \"executeMetaTransactionV2\") {\n\t      return parseGaslessTx({\n\t        chainId,\n\t        logParsers,\n\t        exchangeProxyContract,\n\t        tryBlockAndAggregate,\n", "        transactionReceipt,\n\t        transactionDescription,\n\t      });\n\t    }\n\t    if (transactionDescription.name === \"transformERC20\") {\n\t      return transformERC20({\n\t        chainId,\n\t        transactionReceipt,\n\t        tryBlockAndAggregate,\n\t        contract: exchangeProxyContract,\n", "      });\n\t    }\n\t    const txReceiptEnriched = await enrichTxReceipt({\n\t      transactionReceipt,\n\t      tryBlockAndAggregate,\n\t    });\n\t    return parser({\n\t      txDescription: transactionDescription,\n\t      txReceipt: txReceiptEnriched,\n\t    });\n", "  }\n\t}\n\tasync function parseGaslessTx({\n\t  chainId,\n\t  logParsers,\n\t  exchangeProxyContract,\n\t  tryBlockAndAggregate,\n\t  transactionReceipt,\n\t  transactionDescription,\n\t}: ParseGaslessTxArgs) {\n", "  const [mtx] = transactionDescription.args;\n\t  const { 0: signer, 4: data, 6: fees } = mtx as Mtx;\n\t  const [recipient] = fees[0];\n\t  const mtxV2Description = exchangeProxyContract.interface.parseTransaction({\n\t    data,\n\t  });\n\t  if (mtxV2Description) {\n\t    if (mtxV2Description.name === \"transformERC20\") {\n\t      return transformERC20({\n\t        chainId,\n", "        transactionReceipt,\n\t        tryBlockAndAggregate,\n\t        contract: exchangeProxyContract,\n\t      });\n\t    } else {\n\t      const parser = logParsers[mtxV2Description.name];\n\t      return processReceipt({\n\t        signer,\n\t        parser,\n\t        recipient,\n", "        tryBlockAndAggregate,\n\t        transactionReceipt,\n\t        transactionDescription: mtxV2Description,\n\t      });\n\t    }\n\t  }\n\t  const parser = logParsers[transactionDescription.name];\n\t  return processReceipt({\n\t    signer,\n\t    parser,\n", "    recipient,\n\t    tryBlockAndAggregate,\n\t    transactionReceipt,\n\t    transactionDescription,\n\t  });\n\t}\n\tasync function processReceipt({\n\t  signer,\n\t  parser,\n\t  recipient,\n", "  tryBlockAndAggregate,\n\t  transactionReceipt,\n\t  transactionDescription,\n\t}: ProcessReceiptArgs) {\n\t  const enrichedTxReceipt = await enrichTxReceipt({\n\t    transactionReceipt,\n\t    tryBlockAndAggregate,\n\t  });\n\t  const { logs } = enrichedTxReceipt;\n\t  const filteredLogs = logs.filter((log) => log.to !== recipient.toLowerCase());\n", "  return parser({\n\t    txDescription: transactionDescription,\n\t    txReceipt: { from: signer, logs: filteredLogs },\n\t  });\n\t}\n"]}
{"filename": "src/utils/index.test.ts", "chunked_list": ["import { describe, expect, it } from \"vitest\";\n\timport { parseHexDataToString } from \"./index\";\n\tdescribe(\"parseHexDataToString\", () => {\n\t  it(\"should return empty string when input data does not contain any hexadecimal number\", () => {\n\t    const hexData =\n\t      \"0x00000000000000000000000000000000000000000000000000000000000000002\"; // This does not have any hexadecimal number after the length field\n\t    const result = parseHexDataToString(hexData);\n\t    expect(result).toEqual(\"\");\n\t  });\n\t});\n"]}
{"filename": "src/utils/index.ts", "chunked_list": ["import { EVENT_SIGNATURES, ERC20_FUNCTION_HASHES } from \"../constants\";\n\timport type {\n\t  ProcessedLog,\n\t  SupportedChainId,\n\t  PermitAndCallChainIds,\n\t  EnrichedTxReceipt,\n\t  EnrichedTxReceiptArgs,\n\t  EnrichedLogWithoutAmount,\n\t  TryBlockAndAggregate,\n\t} from \"../types\";\n", "export function convertHexToAddress(hexString: string): string {\n\t  return `0x${hexString.slice(-40)}`;\n\t}\n\texport function isChainIdSupported(\n\t  chainId: number\n\t): chainId is SupportedChainId {\n\t  return [1, 5, 10, 56, 137, 250, 8453, 42220, 43114, 42161].includes(chainId);\n\t}\n\texport function isPermitAndCallChainId(\n\t  chainId: number\n", "): chainId is PermitAndCallChainIds {\n\t  return [1, 137, 8453].includes(chainId);\n\t}\n\texport function parseHexDataToString(hexData: string) {\n\t  const dataLength = parseInt(hexData.slice(66, 130), 16);\n\t  const data = hexData.slice(130, 130 + dataLength * 2);\n\t  const bytes = new Uint8Array(\n\t    data.match(/.{1,2}/g)?.map((byte: string) => parseInt(byte, 16)) ?? []\n\t  );\n\t  const textDecoder = new TextDecoder();\n", "  const utf8String = textDecoder.decode(bytes);\n\t  return utf8String;\n\t}\n\texport function formatUnits(data: string, decimals: number) {\n\t  const bigIntData = BigInt(data);\n\t  const bigIntDecimals = BigInt(10 ** decimals);\n\t  const wholePart = bigIntData / bigIntDecimals;\n\t  const fractionalPart = bigIntData % bigIntDecimals;\n\t  const paddedFractionalPart = String(fractionalPart).padStart(decimals, \"0\");\n\t  const formattedFractionalPart = paddedFractionalPart.replace(/0+$/, \"\");\n", "  return formattedFractionalPart.length > 0\n\t    ? `${wholePart}.${formattedFractionalPart}`\n\t    : wholePart.toString();\n\t}\n\texport async function fetchSymbolAndDecimal(\n\t  address: string,\n\t  tryBlockAndAggregate: TryBlockAndAggregate\n\t): Promise<[string, number]> {\n\t  const calls = [\n\t    { target: address, callData: ERC20_FUNCTION_HASHES.symbol },\n", "    { target: address, callData: ERC20_FUNCTION_HASHES.decimals },\n\t  ];\n\t  const { 2: results } = await tryBlockAndAggregate.staticCall(false, calls);\n\t  const [symbolResult, decimalsResult] = results;\n\t  const symbol = parseHexDataToString(symbolResult.returnData);\n\t  const decimals = Number(BigInt(decimalsResult.returnData));\n\t  return [symbol, decimals];\n\t}\n\tfunction processLog(log: EnrichedLogWithoutAmount): ProcessedLog {\n\t  const { topics, data, decimals, symbol, address } = log;\n", "  const { 1: fromHex, 2: toHex } = topics;\n\t  const from = convertHexToAddress(fromHex);\n\t  const to = convertHexToAddress(toHex);\n\t  const amount = formatUnits(data, decimals);\n\t  return { to, from, symbol, amount, address, decimals };\n\t}\n\texport async function enrichTxReceipt({\n\t  transactionReceipt,\n\t  tryBlockAndAggregate,\n\t}: EnrichedTxReceiptArgs): Promise<EnrichedTxReceipt> {\n", "  const { from, logs } = transactionReceipt;\n\t  const filteredLogs = logs.filter(\n\t    (log) => log.topics[0] === EVENT_SIGNATURES.Transfer\n\t  );\n\t  const calls = filteredLogs.flatMap((log) => [\n\t    { target: log.address, callData: ERC20_FUNCTION_HASHES.symbol },\n\t    { target: log.address, callData: ERC20_FUNCTION_HASHES.decimals },\n\t  ]);\n\t  const { 2: results } = await tryBlockAndAggregate.staticCall(false, calls);\n\t  const enrichedLogs = filteredLogs.map((log, i) => {\n", "    const symbolResult = results[i * 2];\n\t    const decimalsResult = results[i * 2 + 1];\n\t    const enrichedLog = {\n\t      ...log,\n\t      symbol: parseHexDataToString(symbolResult.returnData),\n\t      decimals: Number(BigInt(decimalsResult.returnData)),\n\t    };\n\t    return processLog(enrichedLog);\n\t  });\n\t  return { from, logs: enrichedLogs };\n", "}\n\texport function extractTokenInfo(\n\t  inputLog: ProcessedLog,\n\t  outputLog: ProcessedLog\n\t) {\n\t  return {\n\t    tokenIn: {\n\t      symbol: inputLog.symbol,\n\t      amount: inputLog.amount,\n\t      address: inputLog.address,\n", "    },\n\t    tokenOut: {\n\t      symbol: outputLog.symbol,\n\t      amount: outputLog.amount,\n\t      address: outputLog.address,\n\t    },\n\t  };\n\t}\n"]}
{"filename": "src/tests/fillLimitOrder.test.ts", "chunked_list": ["import { it, expect } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0xbe734b761ccd45cc60a5b4828eb83da96405d663567a46041b049627dddf347d\n\tit(\"parses swap from fillLimitOrder\", async () => {\n", "  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0xbe734b761ccd45cc60a5b4828eb83da96405d663567a46041b049627dddf347d\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      symbol: \"USDT\",\n\t      amount: \"1.6\",\n", "      address: \"0xdAC17F958D2ee523a2206206994597C13D831ec7\",\n\t    },\n\t    tokenOut: {\n\t      symbol: \"WETH\",\n\t      amount: \"0.001\",\n\t      address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n\t    },\n\t  });\n\t});\n"]}
{"filename": "src/tests/multiplexMultiHopSellTokenForToken.test.ts", "chunked_list": ["import { it, expect } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0xf705df9127065ae8a8da3c1939d7096011ea13c81e4a2ed8c59ea1b039f7565d\n\tit(\"parses swap from multiplexMultiHopSellTokenForToken\", async () => {\n", "  const data = await parseSwap({\n\t    transactionHash: \"0xf705df9127065ae8a8da3c1939d7096011ea13c81e4a2ed8c59ea1b039f7565d\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      symbol: \"LINK\",\n\t      amount: \"503.8124966\",\n\t      address: \"0x514910771AF9Ca656af840dff83E8264EcF986CA\",\n", "    },\n\t    tokenOut: {\n\t      symbol: \"DAO\",\n\t      amount: \"2014.179756573835415392\",\n\t      address: \"0x0f51bb10119727a7e5eA3538074fb341F56B09Ad\",\n\t    },\n\t  });\n\t});\n"]}
{"filename": "src/tests/multiplexBatchSellEthForToken.test.ts", "chunked_list": ["import { it, expect } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0xe59ff84284d7e2ad87f1a6de55d5d6600b0b721242110687847e57b52a045b7d\n\tit(\"parses swap from multiplexBatchSellEthForToken\", async () => {\n", "  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0xe59ff84284d7e2ad87f1a6de55d5d6600b0b721242110687847e57b52a045b7d\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      symbol: \"WETH\",\n\t      amount: \"10\",\n", "      address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n\t    },\n\t    tokenOut: {\n\t      symbol: \"X2Y2\",\n\t      amount: \"90095.36724488341\",\n\t      address: \"0x1E4EDE388cbc9F4b5c79681B7f94d36a11ABEBC9\",\n\t    },\n\t  });\n\t});\n"]}
{"filename": "src/tests/sellTokenForEthToUniswapV3.test.ts", "chunked_list": ["import { describe, expect, it } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0x822d38c0746b19544cedddd9a1ebaacadd3e5da55dc293738ae135fc595e269b\n\tdescribe(\"parseSwap\", () => {\n", "  it(\"parses swap from sellTokenForEthToUniswapV3\", async () => {\n\t    const data = await parseSwap({\n\t      transactionHash: '0x822d38c0746b19544cedddd9a1ebaacadd3e5da55dc293738ae135fc595e269b',\n\t      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t      rpcUrl: ETH_MAINNET_RPC,\n\t    });\n\t    expect(data).toEqual({\n\t      tokenIn: {\n\t        symbol: \"✺RUG\",\n\t        amount: \"56322.215316673764925169\",\n", "        address: '0xD2d8D78087D0E43BC4804B6F946674b2Ee406b80',\n\t      },\n\t      tokenOut: {\n\t        symbol: \"WETH\",\n\t        amount: \"0.218304893918707078\",\n\t        address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',\n\t      },\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/tests/sellToUniswap.test.ts", "chunked_list": ["import { it, expect } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0xd6a7aeda4a2978c80b03700e3136c6895b48d08cd9c8d4c88dfd19dee0a12795\n\tit(\"parses swap from sellToUniswap\", async () => {\n", "  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0xd6a7aeda4a2978c80b03700e3136c6895b48d08cd9c8d4c88dfd19dee0a12795\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      symbol: \"WETH\",\n\t      amount: \"0.016858343555927415\",\n", "      address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n\t    },\n\t    tokenOut: {\n\t      symbol: \"USDT\",\n\t      amount: \"30.149999\",\n\t      address: \"0xdAC17F958D2ee523a2206206994597C13D831ec7\",\n\t    },\n\t  });\n\t});\n"]}
{"filename": "src/tests/fillTakerSignedOtcOrderForEth.test.ts", "chunked_list": ["import { it, expect } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0x5f0ed4396f68e0321e48d50611cc6663af68bf7cbee6bc8e74ff5c63d90f3b68\n\tit(\"parses swap from fillTakerSignedOtcOrderForEth\", async () => {\n", "  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0x5f0ed4396f68e0321e48d50611cc6663af68bf7cbee6bc8e74ff5c63d90f3b68\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      symbol: \"USDC\",\n\t      amount: \"25000\",\n", "      address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n\t    },\n\t    tokenOut: {\n\t      symbol: \"WETH\",\n\t      amount: \"13.848320444784979968\",\n\t      address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n\t    },\n\t  });\n\t});\n"]}
{"filename": "src/tests/multiplexMultiHopSellTokenForEth.test.ts", "chunked_list": ["import { it, expect } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0xba3a89b2164e5f169bc81e90a13f8946d110dffe2b53393953ea2a4fede8e81e\n\tit(\"parses swap from multiplexMultiHopSellTokenForEth\", async () => {\n", "  const data = await parseSwap({\n\t    transactionHash: \"0xba3a89b2164e5f169bc81e90a13f8946d110dffe2b53393953ea2a4fede8e81e\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      symbol: \"LSS\",\n\t      amount: \"20065.979484072366300492\",\n\t      address: \"0x3B9BE07d622aCcAEd78f479BC0EDabFd6397E320\",\n", "    },\n\t    tokenOut: {\n\t      symbol: \"WETH\",\n\t      amount: \"3.305750792360646949\",\n\t      address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n\t    },\n\t  });\n\t});\n"]}
{"filename": "src/tests/permitAndCall.test.ts", "chunked_list": ["import { describe, expect, it } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\tdescribe(\"permitAndCall\", () => {\n\t  // https://etherscan.io/tx/0x5eac379185f24ddeba7fcd4414779df77ecfd1102da6ebf6dacf25b01a14b241\n", "  it(\"parses swap\", async () => {\n\t    const data = await parseSwap({\n\t      transactionHash:\n\t        \"0x5eac379185f24ddeba7fcd4414779df77ecfd1102da6ebf6dacf25b01a14b241\",\n\t      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t      rpcUrl: ETH_MAINNET_RPC,\n\t    });\n\t    expect(data).toEqual({\n\t      tokenIn: {\n\t        symbol: \"USDC\",\n", "        amount: \"20\",\n\t        address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n\t      },\n\t      tokenOut: {\n\t        symbol: \"USDT\",\n\t        amount: \"8.735176\",\n\t        address: \"0xdAC17F958D2ee523a2206206994597C13D831ec7\",\n\t      },\n\t    });\n\t  });\n", "  // https://etherscan.io/tx/0x96f00ee10fb5bc7a71865d0efef87e1105946b5a7a87d44ccc8a60fa852ba467\n\t  it(\"parses swap with a meta transaction that wraps multiplexBatchSellTokenForEth\", async () => {\n\t    const data = await parseSwap({\n\t      transactionHash:\n\t        \"0x96f00ee10fb5bc7a71865d0efef87e1105946b5a7a87d44ccc8a60fa852ba467\",\n\t      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t      rpcUrl: ETH_MAINNET_RPC,\n\t    });\n\t    expect(data).toEqual({\n\t      tokenIn: {\n", "        symbol: \"cbETH\",\n\t        amount: \"0.1485446807974644\",\n\t        address: \"0xBe9895146f7AF43049ca1c1AE358B0541Ea49704\",\n\t      },\n\t      tokenOut: {\n\t        symbol: \"ETH\",\n\t        amount: \"0.1540473741459534\",\n\t        address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n\t      },\n\t    });\n", "  });\n\t  // https://etherscan.io/tx/0x142909f33e8b9882c73da6dc85193a81cd2bfa3bd39d485dd901d3b70e985ee4\n\t  it(\"parses swap with a meta transaction that wraps transformERC20\", async () => {\n\t    const data = await parseSwap({\n\t      transactionHash:\n\t        \"0x142909f33e8b9882c73da6dc85193a81cd2bfa3bd39d485dd901d3b70e985ee4\",\n\t      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t      rpcUrl: ETH_MAINNET_RPC,\n\t    });\n\t    expect(data).toEqual({\n", "      tokenIn: {\n\t        symbol: \"BAL\",\n\t        amount: \"50.883400023914484682\",\n\t        address: \"0xba100000625a3754423978a60c9317c58a424e3D\",\n\t      },\n\t      tokenOut: {\n\t        symbol: \"ETH\",\n\t        amount: \"0.144785082557763087\",\n\t        address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n\t      },\n", "    });\n\t  });\n\t  // https://etherscan.io/tx/0x911354147775d4460259809bf7606b6a0f06c70a788856bd7f9371411abf3a5e\n\t  it(\"parses swap with a meta transaction that wraps multiplexBatchSellTokenForToken\", async () => {\n\t    const data = await parseSwap({\n\t      transactionHash:\n\t        \"0x911354147775d4460259809bf7606b6a0f06c70a788856bd7f9371411abf3a5e\",\n\t      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t      rpcUrl: ETH_MAINNET_RPC,\n\t    });\n", "    expect(data).toEqual({\n\t      tokenIn: {\n\t        symbol: \"USDC\",\n\t        amount: \"7938.859514\",\n\t        address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n\t      },\n\t      tokenOut: {\n\t        symbol: \"HEX\",\n\t        amount: \"545031.76796769\",\n\t        address: \"0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39\",\n", "      },\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/tests/transformERC20.test.ts", "chunked_list": ["import { Contract } from \"ethers\";\n\timport { it, expect, describe } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport { EXCHANGE_PROXY_BY_CHAIN_ID } from \"../constants\";\n\timport { transformERC20 } from \"../parsers\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n", "}\n\tdescribe(\"transformERC20\", () => {\n\t  it(\"returns undefined when TransformedERC20 topic is not found in logs\", async () => {\n\t    const contract = new Contract(\n\t      EXCHANGE_PROXY_BY_CHAIN_ID[1],\n\t      EXCHANGE_PROXY_ABI.compilerOutput.abi\n\t    );\n\t    const transactionReceipt = {\n\t      from: \"0x8C410057a8933d579926dEcCD043921A974A24ee\",\n\t      hash: \"0xee3ffb65f6c8e07b46471cc610cf721affeefed87098c7db30a8147d50eb2a65\",\n", "      logs: [],\n\t      to: \"0xDef1C0ded9bec7F1a1670819833240f027b25EfF\",\n\t    };\n\t    const result = await transformERC20({\n\t      transactionReceipt,\n\t      contract,\n\t      rpcUrl: ETH_MAINNET_RPC,\n\t    } as any);\n\t    expect(result).toBe(undefined);\n\t  });\n", "});\n\tdescribe(\"transformERC20 on various networks\", () => {\n\t  // https://etherscan.io/tx/0x30d015e87dd5481609eec1c54433b8d4679fe641034971baf648d4528a9b0a35\n\t  it(\"Ethereum mainnet: parse a swap with native input asset\", async () => {\n\t    const data = await parseSwap({\n\t      transactionHash:\n\t        \"0x30d015e87dd5481609eec1c54433b8d4679fe641034971baf648d4528a9b0a35\",\n\t      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t      rpcUrl: ETH_MAINNET_RPC,\n\t    });\n", "    expect(data).toEqual({\n\t      tokenIn: {\n\t        address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n\t        symbol: \"ETH\",\n\t        amount: \"332.666067836453233036\",\n\t      },\n\t      tokenOut: {\n\t        address: \"0xdAC17F958D2ee523a2206206994597C13D831ec7\",\n\t        symbol: \"USDT\",\n\t        amount: \"500000.317382\",\n", "      },\n\t    });\n\t  });\n\t  // https://etherscan.io/tx/0x4db5b7168686cdfb1469b47a67f03fb6199aa81f3d2a26c4a05835b8752d152d\n\t  it(\"Ethereum mainnet: parse a swap with ERC-20 input asset\", async () => {\n\t    const data = await parseSwap({\n\t      transactionHash:\n\t        \"0x4db5b7168686cdfb1469b47a67f03fb6199aa81f3d2a26c4a05835b8752d152d\",\n\t      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t      rpcUrl: ETH_MAINNET_RPC,\n", "    });\n\t    expect(data).toEqual({\n\t      tokenIn: {\n\t        symbol: \"USDT\",\n\t        amount: \"275.0\",\n\t        address: \"0xdAC17F958D2ee523a2206206994597C13D831ec7\",\n\t      },\n\t      tokenOut: {\n\t        symbol: \"MUTE\",\n\t        amount: \"183.067612917791449241\",\n", "        address: \"0xA49d7499271aE71cd8aB9Ac515e6694C755d400c\",\n\t      },\n\t    });\n\t  });\n\t  // https://arbiscan.io/tx/0x3e48c1d1d3596ecfc1f9feb9e9613f5f5fc002b76743251c31eca8bc0aa30e21\n\t  it(\"parse a swap on Arbitrum\", async () => {\n\t    const data = await parseSwap({\n\t      transactionHash:\n\t        \"0x3e48c1d1d3596ecfc1f9feb9e9613f5f5fc002b76743251c31eca8bc0aa30e21\",\n\t      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n", "      rpcUrl: \"https://arb1.arbitrum.io/rpc\",\n\t    });\n\t    expect(data).toEqual({\n\t      tokenIn: {\n\t        address: \"0xfc5A1A6EB076a2C7aD06eD22C90d7E710E35ad0a\",\n\t        amount: \"36834.421293958495524657\",\n\t        symbol: \"GMX\",\n\t      },\n\t      tokenOut: {\n\t        address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n", "        amount: \"1189.251717722346544033\",\n\t        symbol: \"ETH\",\n\t      },\n\t    });\n\t  });\n\t  // https://optimistic.etherscan.io/tx/0x0d8125a0d77af877c5efd475e0b2a8aa7451c2b5b95e2918387f8a038aacd718\n\t  it(\"parse a swap on Optimism\", async () => {\n\t    const data = await parseSwap({\n\t      transactionHash:\n\t        \"0x0d8125a0d77af877c5efd475e0b2a8aa7451c2b5b95e2918387f8a038aacd718\",\n", "      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t      rpcUrl: \"https://endpoints.omniatech.io/v1/op/mainnet/public\",\n\t    });\n\t    expect(data).toEqual({\n\t      tokenIn: {\n\t        address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n\t        amount: \"51.0\",\n\t        symbol: \"ETH\",\n\t      },\n\t      tokenOut: {\n", "        address: \"0x9A601C5bb360811d96A23689066af316a30c3027\",\n\t        amount: \"217794.381575767372449449\",\n\t        symbol: \"PIKA\",\n\t      },\n\t    });\n\t  });\n\t  // https://snowtrace.io/tx/0x989436aff2791d355a08b87c9a97288699ed5a44a75897a963925b1922e12dbb\n\t  it(\"parse a swap on Avalanche\", async () => {\n\t    const data = await parseSwap({\n\t      transactionHash:\n", "        \"0x989436aff2791d355a08b87c9a97288699ed5a44a75897a963925b1922e12dbb\",\n\t      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t      rpcUrl: \"https://api.avax.network/ext/bc/C/rpc\",\n\t    });\n\t    expect(data).toEqual({\n\t      tokenIn: {\n\t        address: \"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E\",\n\t        amount: \"25650.0\",\n\t        symbol: \"USDC\",\n\t      },\n", "      tokenOut: {\n\t        address: \"0x152b9d0FdC40C096757F570A51E494bd4b943E50\",\n\t        amount: \"0.99966847\",\n\t        symbol: \"BTC.b\",\n\t      },\n\t    });\n\t  });\n\t  // https://ftmscan.com/tx/0xc48de1d0482475d76a13107b4d438605abe0d2223e75167fc46d6d6a54d954c2\n\t  it(\"parse a swap on Fantom\", async () => {\n\t    const data = await parseSwap({\n", "      transactionHash:\n\t        \"0xc48de1d0482475d76a13107b4d438605abe0d2223e75167fc46d6d6a54d954c2\",\n\t      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t      rpcUrl: \"https://rpc.ftm.tools\",\n\t    });\n\t    expect(data).toEqual({\n\t      tokenIn: {\n\t        address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n\t        amount: \"375000.0\",\n\t        symbol: \"FTM\",\n", "      },\n\t      tokenOut: {\n\t        address: \"0x04068DA6C83AFCFA0e13ba15A6696662335D5B75\",\n\t        amount: \"126441.837374\",\n\t        symbol: \"USDC\",\n\t      },\n\t    });\n\t  });\n\t  // https://bscscan.com/tx/0x789d6d51ceb6d32407c97757e4be90c12f789927453413318178bed0ebc53bc0\n\t  it(\"parse a swap on BNB Chain\", async () => {\n", "    const data = await parseSwap({\n\t      transactionHash:\n\t        \"0x789d6d51ceb6d32407c97757e4be90c12f789927453413318178bed0ebc53bc0\",\n\t      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t      rpcUrl: \"https://bscrpc.com\",\n\t    });\n\t    expect(data).toEqual({\n\t      tokenIn: {\n\t        address: \"0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\",\n\t        amount: \"400142.7162326532\",\n", "        symbol: \"BUSD\",\n\t      },\n\t      tokenOut: {\n\t        address: \"0x55d398326f99059fF775485246999027B3197955\",\n\t        amount: \"399966.973708709289660215\",\n\t        symbol: \"USDT\",\n\t      },\n\t    });\n\t  });\n\t});\n", "// https://explorer.celo.org/tx/0x615c5089f772a8f2074750e8c6070013d288af7681435aba1771f6bfc63d1286\n\tit(\"parse a swap on Celo\", async () => {\n\t  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0x615c5089f772a8f2074750e8c6070013d288af7681435aba1771f6bfc63d1286\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: \"https://rpc.ankr.com/celo\",\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n", "      address: \"0x765DE816845861e75A25fCA122bb6898B8B1282a\",\n\t      amount: \"500.0\",\n\t      symbol: \"cUSD\",\n\t    },\n\t    tokenOut: {\n\t      address: \"0x74c0C58B99b68cF16A717279AC2d056A34ba2bFe\",\n\t      amount: \"23390.112524333224016754\",\n\t      symbol: \"SOURCE\",\n\t    },\n\t  });\n", "});\n\t// https://basescan.org/tx/0x26ca796e654a3667957c25e7714c5d6d5de1fc845ebf98d8ee217f9f5e2c5f34\n\tit(\"parse a swap on Base\", async () => {\n\t  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0x26ca796e654a3667957c25e7714c5d6d5de1fc845ebf98d8ee217f9f5e2c5f34\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: \"https://mainnet.base.org\",\n\t  });\n\t  expect(data).toEqual({\n", "    tokenIn: {\n\t      address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n\t      amount: \"0.005446885313391051\",\n\t      symbol: \"ETH\",\n\t    },\n\t    tokenOut: {\n\t      address: \"0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA\",\n\t      amount: \"10.049999\",\n\t      symbol: \"USDbC\",\n\t    },\n", "  });\n\t});\n"]}
{"filename": "src/tests/multiplexBatchSellTokenForEth.test.ts", "chunked_list": ["import { it, expect } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0x0caebae93af96f83c4d2434816d079d1b43e9061dcaca8627bd9e2c0917a3b63\n\tit(\"parses swap from multiplexBatchSellTokenForEth\", async () => {\n", "  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0x0caebae93af96f83c4d2434816d079d1b43e9061dcaca8627bd9e2c0917a3b63\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      symbol: \"BORING\",\n\t      amount: \"181533.55587344\",\n", "      address: \"0xBC19712FEB3a26080eBf6f2F7849b417FdD792CA\",\n\t    },\n\t    tokenOut: {\n\t      symbol: \"ETH\",\n\t      amount: \"0.48027902546177326\",\n\t      address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n\t    },\n\t  });\n\t});\n"]}
{"filename": "src/tests/index.test.ts", "chunked_list": ["import { it, expect } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\timport { EXCHANGE_PROXY_ABI_URL } from \"../constants\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0xe393e03e31ba2b938326ef0527aba08b4e7f2d144ac2a2172c57615990698ee6\n", "it(\"returns null when the smart contract function name is not supported\", async () => {\n\t  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0xe393e03e31ba2b938326ef0527aba08b4e7f2d144ac2a2172c57615990698ee6\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toBe(null);\n\t});\n\t// https://etherscan.io/tx/0x335b2a3faf4a15cd6f67f1ec7ed26ee04ea7cc248f5cd052967e6ae672af8d35\n", "it(\"returns null when the transaction reverted\", async () => {\n\t  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0x335b2a3faf4a15cd6f67f1ec7ed26ee04ea7cc248f5cd052967e6ae672af8d35\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toBe(null);\n\t});\n\tit(\"throws an error when required arguments are not passed\", () => {\n", "  expect(async () => {\n\t    await parseSwap({\n\t      transactionHash: \"0x…\",\n\t      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    } as any);\n\t  }).rejects.toThrowError(\"Missing rpcUrl\");\n\t  expect(async () => {\n\t    await parseSwap({\n\t      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t      rpcUrl: ETH_MAINNET_RPC,\n", "    } as any);\n\t  }).rejects.toThrowError(\"Missing transaction hash\");\n\t  expect(async () => {\n\t    await parseSwap({\n\t      transactionHash: \"0x…\",\n\t      rpcUrl: ETH_MAINNET_RPC,\n\t    });\n\t  }).rejects.toThrowError(\n\t    `Missing 0x Exchange Proxy ABI: ${EXCHANGE_PROXY_ABI_URL}`\n\t  );\n", "});\n\tit(\"throws an error if the chainId is not supported\", () => {\n\t  expect(async () => {\n\t    await parseSwap({\n\t      transactionHash:\n\t        \"0x689eaa9ad3db373b241330be646e450d5b8bb3faad7f0c3260c63b9ef6765fcb\",\n\t      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t      rpcUrl: \"https://rpc.gnosis.gateway.fm\",\n\t    });\n\t  }).rejects.toThrowError(\"chainId 100 is unsupported.\");\n", "});\n"]}
{"filename": "src/tests/sellTokenForTokenToUniswapV3.test.ts", "chunked_list": ["import { it, expect } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0x90dbdd630287a0412f88cbc98b0d751bc81c613bb285898dac461b523cd07a5a\n\tit(\"parses swap from sellTokenForTokenToUniswapV3\", async () => {\n", "  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0x90dbdd630287a0412f88cbc98b0d751bc81c613bb285898dac461b523cd07a5a\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      symbol: \"USDC\",\n\t      amount: \"3500\",\n", "      address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n\t    },\n\t    tokenOut: {\n\t      symbol: \"CRV\",\n\t      amount: \"3490.286498060619473095\",\n\t      address: \"0xD533a949740bb3306d119CC777fa900bA034cd52\",\n\t    },\n\t  });\n\t});\n"]}
{"filename": "src/tests/executeMetaTransaction.test.ts", "chunked_list": ["import { it, expect } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\tconst POLYGON_MAINNET_RPC = \"https://rpc.ankr.com/polygon\";\n\t// https://polygonscan.com/tx/0xaa61b2058fafae1532565b6acadf47a8fe604518185f535e2780dd28d626e0ef\n\tit(\"parses swap from executeMetaTransaction\", async () => {\n\t  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0xaa61b2058fafae1532565b6acadf47a8fe604518185f535e2780dd28d626e0ef\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n", "    rpcUrl: POLYGON_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      symbol: \"WMATIC\",\n\t      amount: \"8.54621988\",\n\t      address: \"0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270\",\n\t    },\n\t    tokenOut: {\n\t      symbol: \"PAXG\",\n", "      amount: \"0.00488474242697242\",\n\t      address: \"0x553d3D295e0f695B9228246232eDF400ed3560B5\",\n\t    },\n\t  });\n\t});\n"]}
{"filename": "src/tests/multiplexMultiHopSellEthForToken.test.ts", "chunked_list": ["import { it, expect } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0x00b191d47269265cfbbc94c77a114281ee939463b7a922e8bfbf7de8bc150c5c\n\tit(\"parses swap from multiplexMultiHopSellEthForToken\", async () => {\n", "  const data = await parseSwap({\n\t    transactionHash: \"0x00b191d47269265cfbbc94c77a114281ee939463b7a922e8bfbf7de8bc150c5c\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      symbol: \"WETH\",\n\t      amount: \"3\",\n\t      address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n", "    },\n\t    tokenOut: {\n\t      symbol: \"XCAD\",\n\t      amount: \"2705.968001258040126473\",\n\t      address: \"0x7659CE147D0e714454073a5dd7003544234b6Aa0\",\n\t    },\n\t  });\n\t});\n"]}
{"filename": "src/tests/executeMetaTransactionV2.test.ts", "chunked_list": ["import { it, expect } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0x3e22063b0a1be3e8a7a902b6a2ecd86d7753279ef368e21b99d23e431d759f71\n\tit(\"parses swap from executeMetaTransactionV2 which wraps transformERC20\", async () => {\n", "  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0x3e22063b0a1be3e8a7a902b6a2ecd86d7753279ef368e21b99d23e431d759f71\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      symbol: \"USDC\",\n\t      amount: \"9960.981086\",\n", "      address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n\t    },\n\t    tokenOut: {\n\t      symbol: \"WBTC\",\n\t      amount: \"0.35487978\",\n\t      address: \"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\",\n\t    },\n\t  });\n\t});\n\t// https://etherscan.io/tx/0xc772258418e5d73bcf891ef341a42c0d74d8f84beda7f9e8580eacc0d62ba3c7\n", "it(\"parses swap from executeMetaTransactionV2 which wraps multiplexBatchSellTokenForEth\", async () => {\n\t  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0xc772258418e5d73bcf891ef341a42c0d74d8f84beda7f9e8580eacc0d62ba3c7\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      amount: \"4972.542335\",\n", "      symbol: \"USDT\",\n\t      address: \"0xdAC17F958D2ee523a2206206994597C13D831ec7\",\n\t    },\n\t    tokenOut: {\n\t      amount: \"2.6043201133029994\",\n\t      symbol: \"ETH\",\n\t      address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n\t    },\n\t  });\n\t});\n", "// https://etherscan.io/tx/0xa4fa7313361c1be65bcec51217ad795028c8fd0ce9eacaff7aab546c29017921\n\tit(\"parses swap from executeMetaTransactionV2 which wraps multiplexBatchSellTokenForToken\", async () => {\n\t  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0xa4fa7313361c1be65bcec51217ad795028c8fd0ce9eacaff7aab546c29017921\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n", "      amount: \"2.886827\",\n\t      symbol: \"WETH\",\n\t      address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n\t    },\n\t    tokenOut: {\n\t      amount: \"384833.18203482\",\n\t      symbol: \"HEX\",\n\t      address: \"0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39\",\n\t    },\n\t  });\n", "});\n\t// https://etherscan.io/tx/0xee3ffb65f6c8e07b46471cc610cf721affeefed87098c7db30a8147d50eb2a65\n\tit(\"parses swap from executeMetaTransactionV2 which wraps transformERC20\", async () => {\n\t  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0xee3ffb65f6c8e07b46471cc610cf721affeefed87098c7db30a8147d50eb2a65\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n", "    tokenIn: {\n\t      amount: \"399.98912868386398826\",\n\t      symbol: \"cbETH\",\n\t      address: \"0xBe9895146f7AF43049ca1c1AE358B0541Ea49704\",\n\t    },\n\t    tokenOut: {\n\t      amount: \"410.723904828710787856\",\n\t      symbol: \"ETH\",\n\t      address: \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n\t    },\n", "  });\n\t});\n"]}
{"filename": "src/tests/sellToLiquidityProvider.test.ts", "chunked_list": ["import { it, expect } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0x2a4379d531695dd4f142730edb7720bb9d06dfb405322e0e16acbfd8ba4fcb98\n\tit(\"parses swap from sellToLiquidityProvider\", async () => {\n", "  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0x2a4379d531695dd4f142730edb7720bb9d06dfb405322e0e16acbfd8ba4fcb98\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      symbol: \"STG\",\n\t      amount: \"918.996239437320809884\",\n", "      address: \"0xAf5191B0De278C7286d6C7CC6ab6BB8A73bA2Cd6\",\n\t    },\n\t    tokenOut: {\n\t      symbol: \"USDC\",\n\t      amount: \"692.783026\",\n\t      address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n\t    },\n\t  });\n\t});\n"]}
{"filename": "src/tests/fillOtcOrderWithEth.test.ts", "chunked_list": ["import { it, expect } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0x68608bec5c30750a6a358b14eb937a07f10f72c84428bdf6eae80f52c27faf53\n\tit(\"parses swap from fillOtcOrderWithEth\", async () => {\n", "  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0x68608bec5c30750a6a358b14eb937a07f10f72c84428bdf6eae80f52c27faf53\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      symbol: \"WETH\",\n\t      amount: \"0.9\",\n", "      address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n\t    },\n\t    tokenOut: {\n\t      symbol: \"USDC\",\n\t      amount: \"1384.074396\",\n\t      address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n\t    },\n\t  });\n\t});\n"]}
{"filename": "src/tests/fillTakerSignedOtcOrder.test.ts", "chunked_list": ["import { it, expect } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0x7f31ba7cacfda809ea24d4b9f87c44fb4114608666c7dd1c6553986ce88dc92b\n\tit(\"parses swap from fillTakerSignedOtcOrder\", async () => {\n", "  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0x7f31ba7cacfda809ea24d4b9f87c44fb4114608666c7dd1c6553986ce88dc92b\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      symbol: \"WETH\",\n\t      amount: \"3.919122810830431232\",\n", "      address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n\t    },\n\t    tokenOut: {\n\t      symbol: \"WBTC\",\n\t      amount: \"0.25\",\n\t      address: \"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\",\n\t    },\n\t  });\n\t});\n"]}
{"filename": "src/tests/multiplexBatchSellTokenForToken.test.ts", "chunked_list": ["import { it, expect } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0xb2c5a697a3126af96d2aa20ba6dcd0daaf9ec6baa49de2a76682dfe4258d2e56\n\tit(\"parses swap from multiplexBatchSellTokenForToken\", async () => {\n", "  const data = await parseSwap({\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    transactionHash:\n\t      \"0xb2c5a697a3126af96d2aa20ba6dcd0daaf9ec6baa49de2a76682dfe4258d2e56\",\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      amount: \"329656.871822\",\n\t      symbol: \"USDC\",\n", "      address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n\t    },\n\t    tokenOut: {\n\t      amount: \"11.5568887\",\n\t      symbol: \"WBTC\",\n\t      address: \"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\",\n\t    },\n\t  });\n\t});\n"]}
{"filename": "src/tests/sellEthForTokenToUniswapV3.test.ts", "chunked_list": ["import { expect, it } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0xc552e83ef96c5d523f69494ae61b7235a6304ab439e127eb0121d33bbcdaa1ff\n\tit(\"parses swap from sellEthForTokenToUniswapV3\", async () => {\n", "  const data = await parseSwap({\n\t    transactionHash: '0xc552e83ef96c5d523f69494ae61b7235a6304ab439e127eb0121d33bbcdaa1ff',\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      symbol: \"WETH\",\n\t      amount: \"2.749441612813630418\",\n\t      address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',\n", "    },\n\t    tokenOut: {\n\t      symbol: \"HEX\",\n\t      amount: \"50249.93952297\",\n\t      address: '0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39',\n\t    },\n\t  });\n\t});\n"]}
{"filename": "src/tests/sellToPancakeSwap.test.ts", "chunked_list": ["import { describe, expect, it } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\tconst BSC_RPC = \"https://bsc-dataseed.binance.org\";\n\t// https://bscscan.com/tx/0x2076af859a54f5f0c7d4e1cd13b3906169a5e3697d8762b59062052d53466e94\n\tdescribe(\"sellToPancakeSwap tx: 0x2076af859a54f5f0c7d4e1cd13b3906169a5e3697d8762b59062052d53466e94\", () => {\n\t  it(\"parses swap from sellToPancakeSwap\", async () => {\n\t    const data = await parseSwap({\n\t      transactionHash:\n\t        \"0x2076af859a54f5f0c7d4e1cd13b3906169a5e3697d8762b59062052d53466e94\",\n", "      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t      rpcUrl: BSC_RPC,\n\t    });\n\t    expect(data).toEqual({\n\t      tokenIn: {\n\t        symbol: \"BUSD\",\n\t        amount: \"1155.41\",\n\t        address: \"0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\",\n\t      },\n\t      tokenOut: {\n", "        symbol: \"WBNB\",\n\t        amount: \"1.82210243305633351\",\n\t        address: \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\",\n\t      },\n\t    });\n\t  });\n\t});\n\t// https://bscscan.com/tx/0x595b1684b8accec5fdd536dbdd9acb4ddcae9cfc21afcd65245d0a51a0e3582b\n\tdescribe(\"sellToPancakeSwap tx: 0x595b1684b8accec5fdd536dbdd9acb4ddcae9cfc21afcd65245d0a51a0e3582b\", () => {\n\t  it(\"parses swap from sellToPancakeSwap\", async () => {\n", "    const data = await parseSwap({\n\t      transactionHash:\n\t        \"0x595b1684b8accec5fdd536dbdd9acb4ddcae9cfc21afcd65245d0a51a0e3582b\",\n\t      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t      rpcUrl: BSC_RPC,\n\t    });\n\t    expect(data).toEqual({\n\t      tokenIn: {\n\t        symbol: \"WBNB\",\n\t        amount: \"1.2\",\n", "        address: \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\",\n\t      },\n\t      tokenOut: {\n\t        symbol: \"BUSD\",\n\t        amount: \"319.903586514927545022\",\n\t        address: \"0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\",\n\t      },\n\t    });\n\t  });\n\t});\n"]}
{"filename": "src/tests/fillOtcOrderForEth.test.ts", "chunked_list": ["import { it, expect } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\t// https://etherscan.io/tx/0x2c4cee137659650ef486fb46b657ec37c1b4fe18489956a5e058cf5585328fa7\n\tit(\"parses swap from fillOtcOrderForEth\", async () => {\n", "  const data = await parseSwap({\n\t    transactionHash:\n\t      \"0x2c4cee137659650ef486fb46b657ec37c1b4fe18489956a5e058cf5585328fa7\",\n\t    exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t    rpcUrl: ETH_MAINNET_RPC,\n\t  });\n\t  expect(data).toEqual({\n\t    tokenIn: {\n\t      symbol: \"USDT\",\n\t      amount: \"218.441376\",\n", "      address: \"0xdAC17F958D2ee523a2206206994597C13D831ec7\",\n\t    },\n\t    tokenOut: {\n\t      symbol: \"WETH\",\n\t      amount: \"0.1254399221596278\",\n\t      address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n\t    },\n\t  });\n\t});\n"]}
{"filename": "src/tests/fillOtcOrder.test.ts", "chunked_list": ["import { it, expect, describe } from \"vitest\";\n\timport { parseSwap } from \"../index\";\n\timport EXCHANGE_PROXY_ABI from \"../abi/IZeroEx.json\";\n\trequire(\"dotenv\").config();\n\tconst ETH_MAINNET_RPC = process.env.ETH_MAINNET_RPC;\n\tif (!ETH_MAINNET_RPC) {\n\t  throw new Error(\"Missing environment variable `ETH_MAINNET_RPC`\");\n\t}\n\tdescribe(\"fillOtcOrder\", () => {\n\t  // https://etherscan.io/tx/0xc9579b9e3cddebd3d48ccb0a719456d7c46869b2c3a536509ea88685c7a5efbb\n", "  it(\"parse a swap on Ethereum\", async () => {\n\t    const data = await parseSwap({\n\t      transactionHash:\n\t        \"0xc9579b9e3cddebd3d48ccb0a719456d7c46869b2c3a536509ea88685c7a5efbb\",\n\t      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t      rpcUrl: ETH_MAINNET_RPC,\n\t    });\n\t    expect(data).toEqual({\n\t      tokenIn: {\n\t        symbol: \"USDT\",\n", "        amount: \"50000\",\n\t        address: \"0xdAC17F958D2ee523a2206206994597C13D831ec7\",\n\t      },\n\t      tokenOut: {\n\t        symbol: \"LDO\",\n\t        amount: \"21120.508370504671821824\",\n\t        address: \"0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32\",\n\t      },\n\t    });\n\t  });\n", "  // https://arbiscan.io/tx/0x3e48c1d1d3596ecfc1f9feb9e9613f5f5fc002b76743251c31eca8bc0aa30e21\n\t  it(\"parse a swap on Arbitrum\", async () => {\n\t    const data = await parseSwap({\n\t      transactionHash:\n\t        \"0xae78f94319844585bd9e8d4ecfefa2eb70e0cd0d49f76695ee7e4783bad4c1fc\",\n\t      exchangeProxyAbi: EXCHANGE_PROXY_ABI.compilerOutput.abi,\n\t      rpcUrl: \"https://arb1.arbitrum.io/rpc\",\n\t    });\n\t    expect(data).toEqual({\n\t      tokenIn: {\n", "        symbol: \"ARB\",\n\t        amount: \"2050\",\n\t        address: \"0x912CE59144191C1204E64559FE8253a0e49E6548\",\n\t      },\n\t      tokenOut: {\n\t        symbol: \"USDC\",\n\t        amount: \"1918.218706\",\n\t        address: \"0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8\",\n\t      },\n\t    });\n", "  });\n\t});\n"]}
{"filename": "src/parsers/index.ts", "chunked_list": ["import { formatUnits } from \"ethers\";\n\timport { extractTokenInfo, fetchSymbolAndDecimal } from \"../utils\";\n\timport {\n\t  CONTRACTS,\n\t  NATIVE_ASSET,\n\t  EVENT_SIGNATURES,\n\t  NATIVE_SYMBOL_BY_CHAIN_ID,\n\t  EXCHANGE_PROXY_BY_CHAIN_ID,\n\t} from \"../constants\";\n\timport type {\n", "  Contract,\n\t  TransactionReceipt,\n\t  TransactionDescription,\n\t} from \"ethers\";\n\timport type {\n\t  SupportedChainId,\n\t  EnrichedTxReceipt,\n\t  TryBlockAndAggregate,\n\t  TransformERC20EventData,\n\t} from \"../types\";\n", "export function sellToLiquidityProvider({\n\t  txReceipt,\n\t}: {\n\t  txReceipt: EnrichedTxReceipt;\n\t}) {\n\t  const { logs, from } = txReceipt;\n\t  const inputLog = logs.find((log) => from.toLowerCase() === log.from);\n\t  const outputLog = logs.find((log) => from.toLowerCase() === log.to);\n\t  if (inputLog && outputLog) {\n\t    return extractTokenInfo(inputLog, outputLog);\n", "  }\n\t}\n\texport function multiplexMultiHopSellTokenForEth({\n\t  txReceipt,\n\t}: {\n\t  txReceipt: EnrichedTxReceipt;\n\t}) {\n\t  const { logs, from } = txReceipt;\n\t  const inputLog = logs.find((log) => from.toLowerCase() === log.from);\n\t  const outputLog = logs.find((log) => log.address === CONTRACTS.weth);\n", "  if (inputLog && outputLog) {\n\t    return extractTokenInfo(inputLog, outputLog);\n\t  }\n\t}\n\texport function multiplexMultiHopSellEthForToken({\n\t  txReceipt,\n\t}: {\n\t  txReceipt: EnrichedTxReceipt;\n\t}) {\n\t  const { logs, from } = txReceipt;\n", "  const inputLog = logs.find((log) => log.address === CONTRACTS.weth);\n\t  const outputLog = logs.find((log) => log.to === from.toLowerCase());\n\t  if (inputLog && outputLog) {\n\t    return extractTokenInfo(inputLog, outputLog);\n\t  }\n\t}\n\texport function fillTakerSignedOtcOrder({\n\t  txReceipt,\n\t  txDescription,\n\t}: {\n", "  txReceipt: EnrichedTxReceipt;\n\t  txDescription: TransactionDescription;\n\t}) {\n\t  const [order] = txDescription.args;\n\t  const { logs } = txReceipt;\n\t  const { 4: maker, 5: taker } = order as string[];\n\t  if (typeof maker === \"string\" && typeof taker === \"string\") {\n\t    const inputLog = logs.find((log) => log.from === taker.toLowerCase());\n\t    const outputLog = logs.find((log) => log.from === maker.toLowerCase());\n\t    if (inputLog && outputLog) {\n", "      return extractTokenInfo(inputLog, outputLog);\n\t    }\n\t  }\n\t}\n\texport function fillOtcOrder({ txReceipt }: { txReceipt: EnrichedTxReceipt }) {\n\t  const { logs, from } = txReceipt;\n\t  const fromAddress = from.toLowerCase();\n\t  const inputLog = logs.find((log) => log.from === fromAddress);\n\t  const outputLog = logs.find((log) => log.to === fromAddress);\n\t  if (inputLog && outputLog) {\n", "    return extractTokenInfo(inputLog, outputLog);\n\t  }\n\t}\n\texport function fillTakerSignedOtcOrderForEth({\n\t  txReceipt,\n\t}: {\n\t  txReceipt: EnrichedTxReceipt;\n\t}) {\n\t  const { logs } = txReceipt;\n\t  const inputLog = logs.find((log) => log.address !== CONTRACTS.weth);\n", "  const outputLog = logs.find((log) => log.address === CONTRACTS.weth);\n\t  if (inputLog && outputLog) {\n\t    return extractTokenInfo(inputLog, outputLog);\n\t  }\n\t}\n\texport function sellTokenForEthToUniswapV3({\n\t  txReceipt,\n\t}: {\n\t  txReceipt: EnrichedTxReceipt;\n\t}) {\n", "  const { logs, from } = txReceipt;\n\t  const inputLog = logs.find((log) => log.from === from.toLowerCase());\n\t  const outputLog = logs.find((log) => log.from !== from.toLowerCase());\n\t  if (inputLog && outputLog) {\n\t    return extractTokenInfo(inputLog, outputLog);\n\t  }\n\t}\n\texport function sellTokenForTokenToUniswapV3({\n\t  txReceipt,\n\t}: {\n", "  txReceipt: EnrichedTxReceipt;\n\t}) {\n\t  const { logs, from } = txReceipt;\n\t  const inputLog = logs.find((log) => from.toLowerCase() === log.from);\n\t  const outputLog = logs.find((log) => from.toLowerCase() === log.to);\n\t  if (inputLog && outputLog) {\n\t    return extractTokenInfo(inputLog, outputLog);\n\t  }\n\t}\n\texport function sellEthForTokenToUniswapV3({\n", "  txReceipt,\n\t}: {\n\t  txReceipt: EnrichedTxReceipt;\n\t}) {\n\t  const { logs, from } = txReceipt;\n\t  const inputLog = logs.find((log) => from.toLowerCase() !== log.to);\n\t  const outputLog = logs.find((log) => from.toLowerCase() === log.to);\n\t  if (inputLog && outputLog) {\n\t    return extractTokenInfo(inputLog, outputLog);\n\t  }\n", "}\n\texport function sellToUniswap({ txReceipt }: { txReceipt: EnrichedTxReceipt }) {\n\t  const [inputLog, outputLog] = txReceipt.logs;\n\t  return extractTokenInfo(inputLog, outputLog);\n\t}\n\texport async function transformERC20({\n\t  chainId,\n\t  contract,\n\t  transactionReceipt,\n\t  tryBlockAndAggregate,\n", "}: {\n\t  contract: Contract;\n\t  chainId: SupportedChainId;\n\t  transactionReceipt: TransactionReceipt;\n\t  tryBlockAndAggregate: TryBlockAndAggregate;\n\t}) {\n\t  const nativeSymbol = NATIVE_SYMBOL_BY_CHAIN_ID[chainId];\n\t  for (const log of transactionReceipt.logs) {\n\t    const { topics, data } = log;\n\t    const [eventHash] = topics;\n", "    if (eventHash === EVENT_SIGNATURES.TransformedERC20) {\n\t      const logDescription = contract.interface.parseLog({\n\t        data,\n\t        topics: [...topics],\n\t      });\n\t      const {\n\t        1: inputToken,\n\t        2: outputToken,\n\t        3: inputTokenAmount,\n\t        4: outputTokenAmount,\n", "      } = logDescription!.args as unknown as TransformERC20EventData;\n\t      let inputSymbol: string;\n\t      let inputDecimal: number;\n\t      let outputSymbol: string;\n\t      let outputDecimal: number;\n\t      if (inputToken === NATIVE_ASSET) {\n\t        inputSymbol = nativeSymbol;\n\t        inputDecimal = 18;\n\t      } else {\n\t        [inputSymbol, inputDecimal] = await fetchSymbolAndDecimal(\n", "          inputToken,\n\t          tryBlockAndAggregate\n\t        );\n\t      }\n\t      if (outputToken === NATIVE_ASSET) {\n\t        outputSymbol = nativeSymbol;\n\t        outputDecimal = 18;\n\t      } else {\n\t        [outputSymbol, outputDecimal] = await fetchSymbolAndDecimal(\n\t          outputToken,\n", "          tryBlockAndAggregate\n\t        );\n\t      }\n\t      const inputAmount = formatUnits(inputTokenAmount, inputDecimal);\n\t      const outputAmount = formatUnits(outputTokenAmount, outputDecimal);\n\t      return {\n\t        tokenIn: {\n\t          address: inputToken,\n\t          amount: inputAmount,\n\t          symbol: inputSymbol,\n", "        },\n\t        tokenOut: {\n\t          address: outputToken,\n\t          amount: outputAmount,\n\t          symbol: outputSymbol,\n\t        },\n\t      };\n\t    }\n\t  }\n\t}\n", "export function multiplexMultiHopSellTokenForToken({\n\t  txReceipt,\n\t}: {\n\t  txReceipt: EnrichedTxReceipt;\n\t}) {\n\t  const { logs, from } = txReceipt;\n\t  const inputLog = logs.find((log) => from.toLowerCase() === log.from);\n\t  const outputLog = logs.find((log) => from.toLowerCase() === log.to);\n\t  if (inputLog && outputLog) {\n\t    return extractTokenInfo(inputLog, outputLog);\n", "  }\n\t}\n\texport function multiplexBatchSellTokenForEth({\n\t  txReceipt,\n\t}: {\n\t  txReceipt: EnrichedTxReceipt;\n\t}) {\n\t  const { from, logs } = txReceipt;\n\t  const tokenData = {\n\t    [from.toLowerCase()]: { amount: \"0\", symbol: \"\", address: \"\" },\n", "    [CONTRACTS.weth.toLowerCase()]: {\n\t      amount: \"0\",\n\t      symbol: \"ETH\",\n\t      address: NATIVE_ASSET,\n\t    },\n\t  };\n\t  logs.forEach(({ address, symbol, amount, from }) => {\n\t    const erc20Address = address.toLowerCase();\n\t    if (tokenData[erc20Address]) {\n\t      tokenData[erc20Address].amount = String(\n", "        Number(tokenData[erc20Address].amount) + Number(amount)\n\t      );\n\t    }\n\t    if (tokenData[from]) {\n\t      tokenData[from].amount = String(\n\t        Number(tokenData[from].amount) + Number(amount)\n\t      );\n\t      tokenData[from].symbol = symbol;\n\t      tokenData[from].address = address;\n\t    }\n", "  });\n\t  return {\n\t    tokenIn: tokenData[from.toLowerCase()],\n\t    tokenOut: tokenData[CONTRACTS.weth.toLowerCase()],\n\t  };\n\t}\n\texport function multiplexBatchSellEthForToken({\n\t  txReceipt,\n\t  txDescription,\n\t}: {\n", "  txReceipt: EnrichedTxReceipt;\n\t  txDescription: TransactionDescription;\n\t}) {\n\t  const { logs } = txReceipt;\n\t  const { args, value } = txDescription;\n\t  const { 0: outputToken } = args;\n\t  const divisor = 1000000000000000000n; // 1e18, for conversion from wei to ether\n\t  const etherBigInt = value / divisor;\n\t  const remainderBigInt = value % divisor;\n\t  const ether = Number(etherBigInt) + Number(remainderBigInt) / Number(divisor);\n", "  const tokenOutAmount = logs.reduce((total, log) => {\n\t    return log.address === outputToken ? total + Number(log.amount) : total;\n\t  }, 0);\n\t  const inputLog = logs.find((log) => log.address === CONTRACTS.weth);\n\t  const outputLog = logs.find((log) => log.address === outputToken);\n\t  if (inputLog && outputLog) {\n\t    return {\n\t      tokenIn: {\n\t        symbol: inputLog.symbol,\n\t        amount: ether.toString(),\n", "        address: inputLog.address,\n\t      },\n\t      tokenOut: {\n\t        symbol: outputLog.symbol,\n\t        amount: tokenOutAmount.toString(),\n\t        address: outputLog.address,\n\t      },\n\t    };\n\t  }\n\t}\n", "export function multiplexBatchSellTokenForToken({\n\t  txDescription,\n\t  txReceipt,\n\t}: {\n\t  txReceipt: EnrichedTxReceipt;\n\t  txDescription: TransactionDescription;\n\t}) {\n\t  const [inputContractAddress, outputContractAddress] = txDescription.args;\n\t  if (\n\t    typeof inputContractAddress === \"string\" &&\n", "    typeof outputContractAddress === \"string\"\n\t  ) {\n\t    const tokenData = {\n\t      [inputContractAddress]: { amount: \"0\", symbol: \"\", address: \"\" },\n\t      [outputContractAddress]: { amount: \"0\", symbol: \"\", address: \"\" },\n\t    };\n\t    txReceipt.logs.forEach(({ address, symbol, amount }) => {\n\t      if (address in tokenData) {\n\t        tokenData[address].address = address;\n\t        tokenData[address].symbol = symbol;\n", "        tokenData[address].amount = (\n\t          Number(tokenData[address].amount) + Number(amount)\n\t        ).toString();\n\t      }\n\t    });\n\t    return {\n\t      tokenIn: tokenData[inputContractAddress],\n\t      tokenOut: tokenData[outputContractAddress],\n\t    };\n\t  }\n", "}\n\texport function sellToPancakeSwap({\n\t  txReceipt,\n\t}: {\n\t  txReceipt: EnrichedTxReceipt;\n\t}) {\n\t  const from = txReceipt.from.toLowerCase();\n\t  const { logs } = txReceipt;\n\t  const exchangeProxy = EXCHANGE_PROXY_BY_CHAIN_ID[56].toLowerCase();\n\t  let inputLog = logs.find((log) => log.from === from);\n", "  let outputLog = logs.find((log) => log.from !== from);\n\t  if (inputLog === undefined) {\n\t    inputLog = logs.find((log) => log.from === exchangeProxy);\n\t    outputLog = logs.find((log) => log.from !== exchangeProxy);\n\t  }\n\t  if (inputLog && outputLog) {\n\t    return extractTokenInfo(inputLog, outputLog);\n\t  }\n\t}\n\texport function executeMetaTransaction({\n", "  txReceipt,\n\t  txDescription,\n\t}: {\n\t  txReceipt: EnrichedTxReceipt;\n\t  txDescription: TransactionDescription;\n\t}) {\n\t  const [metaTransaction] = txDescription.args;\n\t  const [from] = metaTransaction as string[];\n\t  const { logs } = txReceipt;\n\t  if (typeof from === \"string\") {\n", "    const inputLog = logs.find((log) => log.from === from.toLowerCase());\n\t    const outputLog = logs.find((log) => log.to === from.toLowerCase());\n\t    if (inputLog && outputLog) {\n\t      return extractTokenInfo(inputLog, outputLog);\n\t    }\n\t  }\n\t}\n\texport function fillOtcOrderForEth({\n\t  txReceipt,\n\t  txDescription,\n", "}: {\n\t  txReceipt: EnrichedTxReceipt;\n\t  txDescription: TransactionDescription;\n\t}) {\n\t  const { logs } = txReceipt;\n\t  const [order] = txDescription.args;\n\t  const [makerToken, takerToken] = order as string[];\n\t  const inputLog = logs.find((log) => log.address === takerToken);\n\t  const outputLog = logs.find((log) => log.address === makerToken);\n\t  if (inputLog && outputLog) {\n", "    return extractTokenInfo(inputLog, outputLog);\n\t  }\n\t}\n\texport function fillOtcOrderWithEth({\n\t  txReceipt,\n\t  txDescription,\n\t}: {\n\t  txReceipt: EnrichedTxReceipt;\n\t  txDescription: TransactionDescription;\n\t}) {\n", "  return fillOtcOrderForEth({ txReceipt, txDescription });\n\t}\n\texport function fillLimitOrder({\n\t  txReceipt,\n\t  txDescription,\n\t}: {\n\t  txReceipt: EnrichedTxReceipt;\n\t  txDescription: TransactionDescription;\n\t}) {\n\t  const [order] = txDescription.args;\n", "  const { 5: maker, 6: taker } = order as string[];\n\t  const { logs } = txReceipt;\n\t  if (typeof maker === \"string\" && typeof taker === \"string\") {\n\t    const inputLog = logs.find((log) => log.from === taker.toLowerCase());\n\t    const outputLog = logs.find((log) => log.from === maker.toLowerCase());\n\t    if (inputLog && outputLog) {\n\t      return extractTokenInfo(inputLog, outputLog);\n\t    }\n\t  }\n\t}\n"]}
