{"filename": "src/extension.ts", "chunked_list": ["import * as vscode from 'vscode';\n\timport * as path from 'path';\n\timport {\n\t    LanguageClient, LanguageClientOptions, ServerOptions, TransportKind\n\t} from 'vscode-languageclient/node';\n\timport { HintsService } from './hints-service/hints-service';\n\tlet client: LanguageClient;\n\t// This function is called when the extension is activated.\n\texport function activate(context: vscode.ExtensionContext): void {\n\t    client = startLanguageClient(context);\n", "    context.subscriptions.push(\n\t        vscode.languages.registerHoverProvider(\n\t            'rails', {\n\t                provideHover(document, position, token) {\n\t                    let hints = new HintsService();\n\t                    let content = hints.populateHints(document, position);\n\t                    if (content != undefined) return new vscode.Hover(content);\n\t                    return null;\n\t            }\n\t      }));\n", "}\n\t// This function is called when the extension is deactivated.\n\texport function deactivate(): Thenable<void> | undefined {\n\t    if (client) {\n\t        return client.stop();\n\t    }\n\t    return undefined;\n\t}\n\tfunction startLanguageClient(context: vscode.ExtensionContext): LanguageClient {\n\t    const serverModule = context.asAbsolutePath(path.join('out', 'language-server', 'main'));\n", "    // The debug options for the server\n\t    // --inspect=6009: runs the server in Node's Inspector mode so VS Code can attach to the server for debugging.\n\t    // By setting `process.env.DEBUG_BREAK` to a truthy value, the language server will wait until a debugger is attached.\n\t    const debugOptions = { execArgv: ['--nolazy', `--inspect${process.env.DEBUG_BREAK ? '-brk' : ''}=${process.env.DEBUG_SOCKET || '6009'}`] };\n\t    // If the extension is launched in debug mode then the debug server options are used\n\t    // Otherwise the run options are used\n\t    const serverOptions: ServerOptions = {\n\t        run: { module: serverModule, transport: TransportKind.ipc },\n\t        debug: { module: serverModule, transport: TransportKind.ipc, options: debugOptions }\n\t    };\n", "    const fileSystemWatcher = vscode.workspace.createFileSystemWatcher('**/*.rails');\n\t    context.subscriptions.push(fileSystemWatcher);\n\t    // Options to control the language client\n\t    const clientOptions: LanguageClientOptions = {\n\t        documentSelector: [{ scheme: 'file', language: 'rails' }],\n\t        synchronize: {\n\t            // Notify the server about file changes to files contained in the workspace\n\t            fileEvents: fileSystemWatcher\n\t        }\n\t    };\n", "    // Create the language client and start the client.\n\t    const client = new LanguageClient(\n\t        'rails',\n\t        'rails',\n\t        serverOptions,\n\t        clientOptions\n\t    );\n\t    // Start the client. This will also launch the server\n\t    client.start();\n\t    return client;\n", "}\n"]}
{"filename": "src/cli/generator.ts", "chunked_list": ["import fs from 'fs';\n\timport { CompositeGeneratorNode, NL, toString } from 'langium';\n\timport path from 'path';\n\timport { Model } from '../language-server/generated/ast';\n\timport { extractDestinationAndName } from './cli-util';\n\texport function generateJavaScript(model: Model, filePath: string, destination: string | undefined): string {\n\t    const data = extractDestinationAndName(filePath, destination);\n\t    const generatedFilePath = `${path.join(data.destination, data.name)}.js`;\n\t    const fileNode = new CompositeGeneratorNode();\n\t    fileNode.append('\"use strict\";', NL, NL);\n", "    //model.greetings.forEach(greeting => fileNode.append(`console.log('Hello, ${greeting.person.ref?.name}!');`, NL));\n\t    if (!fs.existsSync(data.destination)) {\n\t        fs.mkdirSync(data.destination, { recursive: true });\n\t    }\n\t    fs.writeFileSync(generatedFilePath, toString(fileNode));\n\t    return generatedFilePath;\n\t}\n"]}
{"filename": "src/cli/cli-util.ts", "chunked_list": ["import chalk from 'chalk';\n\timport path from 'path';\n\timport fs from 'fs';\n\timport { AstNode, LangiumDocument, LangiumServices } from 'langium';\n\timport { URI } from 'vscode-uri';\n\texport async function extractDocument(fileName: string, services: LangiumServices): Promise<LangiumDocument> {\n\t    const extensions = services.LanguageMetaData.fileExtensions;\n\t    if (!extensions.includes(path.extname(fileName))) {\n\t        console.error(chalk.yellow(`Please choose a file with one of these extensions: ${extensions}.`));\n\t        process.exit(1);\n", "    }\n\t    if (!fs.existsSync(fileName)) {\n\t        console.error(chalk.red(`File ${fileName} does not exist.`));\n\t        process.exit(1);\n\t    }\n\t    const document = services.shared.workspace.LangiumDocuments.getOrCreateDocument(URI.file(path.resolve(fileName)));\n\t    await services.shared.workspace.DocumentBuilder.build([document], { validationChecks: 'all' });\n\t    const validationErrors = (document.diagnostics ?? []).filter(e => e.severity === 1);\n\t    if (validationErrors.length > 0) {\n\t        console.error(chalk.red('There are validation errors:'));\n", "        for (const validationError of validationErrors) {\n\t            console.error(chalk.red(\n\t                `line ${validationError.range.start.line + 1}: ${validationError.message} [${document.textDocument.getText(validationError.range)}]`\n\t            ));\n\t        }\n\t        process.exit(1);\n\t    }\n\t    return document;\n\t}\n\texport async function extractAstNode<T extends AstNode>(fileName: string, services: LangiumServices): Promise<T> {\n", "    return (await extractDocument(fileName, services)).parseResult?.value as T;\n\t}\n\tinterface FilePathData {\n\t    destination: string,\n\t    name: string\n\t}\n\texport function extractDestinationAndName(filePath: string, destination: string | undefined): FilePathData {\n\t    filePath = path.basename(filePath, path.extname(filePath)).replace(/[.-]/g, '');\n\t    return {\n\t        destination: destination ?? path.join(path.dirname(filePath), 'generated'),\n", "        name: path.basename(filePath)\n\t    };\n\t}\n"]}
{"filename": "src/cli/index.ts", "chunked_list": ["import chalk from 'chalk';\n\timport { Command } from 'commander';\n\timport { Model } from '../language-server/generated/ast';\n\timport { RailsLanguageMetaData } from '../language-server/generated/module';\n\timport { createRailsServices } from '../language-server/rails-module';\n\timport { extractAstNode } from './cli-util';\n\timport { generateJavaScript } from './generator';\n\timport { NodeFileSystem } from 'langium/node';\n\texport const generateAction = async (fileName: string, opts: GenerateOptions): Promise<void> => {\n\t    const services = createRailsServices(NodeFileSystem).Rails;\n", "    const model = await extractAstNode<Model>(fileName, services);\n\t    const generatedFilePath = generateJavaScript(model, fileName, opts.destination);\n\t    console.log(chalk.green(`JavaScript code generated successfully: ${generatedFilePath}`));\n\t};\n\texport type GenerateOptions = {\n\t    destination?: string;\n\t}\n\texport default function(): void {\n\t    const program = new Command();\n\t    program\n", "        // eslint-disable-next-line @typescript-eslint/no-var-requires\n\t        .version(require('../../package.json').version);\n\t    const fileExtensions = RailsLanguageMetaData.fileExtensions.join(', ');\n\t    program\n\t        .command('generate')\n\t        .argument('<file>', `source file (possible file extensions: ${fileExtensions})`)\n\t        .option('-d, --destination <dir>', 'destination directory of generating')\n\t        .description('generates JavaScript code that prints \"Hello, {name}!\" for each greeting in a source file')\n\t        .action(generateAction);\n\t    program.parse(process.argv);\n", "}\n"]}
{"filename": "src/hints-service/hints-service.ts", "chunked_list": ["/******************************************************************************\n\t * Copyright 2022 SOM Research\n\t * This program and the accompanying materials are made available under the\n\t * terms of the MIT License, which is available in the project root.\n\t ******************************************************************************/\n\t import { TextDocument, MarkdownString} from 'vscode';\n\t export interface Hints {\n\t     // Load the Abstract Syntax Tree of the .descML active file\n\t     populateHints(Declaration : string | TextDocument, position: any) : MarkdownString | undefined;\n\t }\n", " /**\n\t  */\n\t export class HintsService implements Hints {\n\t     constructor() {\n\t    }\n\t     populateHints(document : TextDocument, position: any) : MarkdownString | undefined {\n\t        const wordRange = document.getWordRangeAtPosition(position);\n\t        const word = document.getText(wordRange);\n\t        switch (word) {\n\t            case \"output\":\n", "                const markdown = new MarkdownString();\n\t                markdown.appendMarkdown(`## Output \\n The output element contains the structure of the expected output of the LLM. It contains the spec for the overall structure of the LLM output, type info for each field, and the quality criteria for each field and the corrective action to be taken in case quality criteria is not met. \\n`)\n\t                markdown.appendCodeblock(`\n\t<rail version=\"0.1\">\n\t    <output>\n\t        <string name=\"text\" description=\"The generated text\" \n\t            format=\"two-words\" on-fail-two-words=\"reask\"/>\n\t        <float name=\"score\" description=\"The score of th.e..\"\n\t            format=\"min-val: 0\" on-fail-min-val=\"fix\"/>\n\t        <object name=\"metadata\" description=\"The metadata...\">\n", "            <string name=\"key_1\" description=\"description of key_1\" />\n\t            ...\n\t        </object>\n\t    </output>\n\t</rail>`,\"rails\")\n\t                return  markdown\n\t  //          case \"prompt\":\n\t             //   return \"## Prompt \\n The prompt `declare = x` element contains the high level instructions that are sent to the LLM. Check out the RAIL Prompt page for more details.\";\n\t  //          case \"rails\":\n\t  //              return `<rail version=\"0.1\">\n", "  //              <output>\n\t  //                  <string name=\"text\" description=\"The generated text\" format=\"two-words\" on-fail-two-words=\"reask\"/>\n\t  //                  <float name=\"score\" description=\"The score of the generated text\" format=\"min-val: 0\" on-fail-min-val=\"fix\"/>\n\t  //                  <object name=\"metadata\" description=\"The metadata associated with the generated text\">\n\t  //                      <string name=\"key_1\" description=\"description of key_1\" />\n\t  //                      ...\n\t   //                 </object>\n\t   //             </output>\n\t   //         </rail>`;\n\t           default:\n", "            return undefined\n\t        }\n\t     }\n\t }"]}
{"filename": "src/language-server/rails-module.ts", "chunked_list": ["import {\n\t    createDefaultModule, createDefaultSharedModule, DefaultSharedModuleContext, inject,\n\t    LangiumServices, LangiumSharedServices, Module, PartialLangiumServices\n\t} from 'langium';\n\timport { RailsGeneratedModule, RailsGeneratedSharedModule } from './generated/module';\n\timport { RailsValidator, registerValidationChecks } from './rails-validator';\n\t/**\n\t * Declaration of custom services - add your own service classes here.\n\t */\n\texport type RailsAddedServices = {\n", "    validation: {\n\t        RailsValidator: RailsValidator\n\t    }\n\t}\n\t/**\n\t * Union of Langium default services and your custom services - use this as constructor parameter\n\t * of custom service classes.\n\t */\n\texport type RailsServices = LangiumServices & RailsAddedServices\n\t/**\n", " * Dependency injection module that overrides Langium default services and contributes the\n\t * declared custom services. The Langium defaults can be partially specified to override only\n\t * selected services, while the custom services must be fully specified.\n\t */\n\texport const RailsModule: Module<RailsServices, PartialLangiumServices & RailsAddedServices> = {\n\t    validation: {\n\t        RailsValidator: () => new RailsValidator()\n\t    }\n\t};\n\t/**\n", " * Create the full set of services required by Langium.\n\t *\n\t * First inject the shared services by merging two modules:\n\t *  - Langium default shared services\n\t *  - Services generated by langium-cli\n\t *\n\t * Then inject the language-specific services by merging three modules:\n\t *  - Langium default language-specific services\n\t *  - Services generated by langium-cli\n\t *  - Services specified in this file\n", " *\n\t * @param context Optional module context with the LSP connection\n\t * @returns An object wrapping the shared services and the language-specific services\n\t */\n\texport function createRailsServices(context: DefaultSharedModuleContext): {\n\t    shared: LangiumSharedServices,\n\t    Rails: RailsServices\n\t} {\n\t    const shared = inject(\n\t        createDefaultSharedModule(context),\n", "        RailsGeneratedSharedModule\n\t    );\n\t    const Rails = inject(\n\t        createDefaultModule({ shared }),\n\t        RailsGeneratedModule,\n\t        RailsModule\n\t    );\n\t    shared.ServiceRegistry.register(Rails);\n\t    registerValidationChecks(Rails);\n\t    return { shared, Rails };\n", "}\n"]}
{"filename": "src/language-server/main.ts", "chunked_list": ["import { startLanguageServer } from 'langium';\n\timport { NodeFileSystem } from 'langium/node';\n\timport { createConnection, ProposedFeatures } from 'vscode-languageserver/node';\n\timport { createRailsServices } from './rails-module';\n\t// Create a connection to the client\n\tconst connection = createConnection(ProposedFeatures.all);\n\t// Inject the shared services and language-specific services\n\tconst { shared } = createRailsServices({ connection, ...NodeFileSystem });\n\t// Start the language server with the shared services\n\tstartLanguageServer(shared);\n"]}
{"filename": "src/language-server/rails-validator.ts", "chunked_list": ["import { ValidationAcceptor, ValidationChecks } from 'langium';\n\timport { RailsAstType, Output } from './generated/ast';\n\timport type { RailsServices } from './rails-module';\n\t/**\n\t * Register custom validation checks.\n\t */\n\texport function registerValidationChecks(services: RailsServices) {\n\t    const registry = services.validation.ValidationRegistry;\n\t    const validator = services.validation.RailsValidator;\n\t    const checks: ValidationChecks<RailsAstType> = {\n", "    };\n\t    registry.register(checks, validator);\n\t}\n\t/**\n\t * Implementation of custom validations.\n\t */\n\texport class RailsValidator {\n\t    checkPersonStartsWithCapital(person: Output, accept: ValidationAcceptor): void {\n\t    //    if (person.name) {\n\t    //        const firstChar = person.name.substring(0, 1);\n", "    //        if (firstChar.toUpperCase() !== firstChar) {\n\t    //            accept('warning', 'Person name should start with a capital.', { node: person, property: 'name' });\n\t    //        }\n\t    //    }\n\t    }\n\t}\n"]}
{"filename": "src/language-server/generated/module.ts", "chunked_list": ["/******************************************************************************\n\t * This file was generated by langium-cli 1.1.0.\n\t * DO NOT EDIT MANUALLY!\n\t ******************************************************************************/\n\timport { LangiumGeneratedServices, LangiumGeneratedSharedServices, LangiumSharedServices, LangiumServices, LanguageMetaData, Module } from 'langium';\n\timport { RailsAstReflection } from './ast';\n\timport { RailsGrammar } from './grammar';\n\texport const RailsLanguageMetaData: LanguageMetaData = {\n\t    languageId: 'rails',\n\t    fileExtensions: ['.rails'],\n", "    caseInsensitive: false\n\t};\n\texport const RailsGeneratedSharedModule: Module<LangiumSharedServices, LangiumGeneratedSharedServices> = {\n\t    AstReflection: () => new RailsAstReflection()\n\t};\n\texport const RailsGeneratedModule: Module<LangiumServices, LangiumGeneratedServices> = {\n\t    Grammar: () => RailsGrammar(),\n\t    LanguageMetaData: () => RailsLanguageMetaData,\n\t    parser: {}\n\t};\n"]}
{"filename": "src/language-server/generated/grammar.ts", "chunked_list": ["/******************************************************************************\n\t * This file was generated by langium-cli 1.1.0.\n\t * DO NOT EDIT MANUALLY!\n\t ******************************************************************************/\n\timport { loadGrammarFromJson, Grammar } from 'langium';\n\tlet loadedRailsGrammar: Grammar | undefined;\n\texport const RailsGrammar = (): Grammar => loadedRailsGrammar ?? (loadedRailsGrammar = loadGrammarFromJson(`{\n\t  \"$type\": \"Grammar\",\n\t  \"isDeclared\": true,\n\t  \"name\": \"Rails\",\n", "  \"rules\": [\n\t    {\n\t      \"$type\": \"ParserRule\",\n\t      \"name\": \"Model\",\n\t      \"entry\": true,\n\t      \"definition\": {\n\t        \"$type\": \"Group\",\n\t        \"elements\": [\n\t          {\n\t            \"$type\": \"Keyword\",\n", "            \"value\": \"<\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"rails\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"version=\"\n\t          },\n", "          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"version\",\n\t            \"operator\": \"=\",\n\t            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@16\"\n\t              },\n\t              \"arguments\": []\n", "            }\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \">\"\n\t          },\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"rails\",\n\t            \"operator\": \"=\",\n", "            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@1\"\n\t              },\n\t              \"arguments\": []\n\t            }\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n", "            \"value\": \"</\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"rails\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \">\"\n\t          }\n", "        ]\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n\t    },\n\t    {\n\t      \"$type\": \"ParserRule\",\n", "      \"name\": \"Rails\",\n\t      \"definition\": {\n\t        \"$type\": \"Group\",\n\t        \"elements\": [\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"output\",\n\t            \"operator\": \"=\",\n\t            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n", "              \"rule\": {\n\t                \"$ref\": \"#/rules@2\"\n\t              },\n\t              \"arguments\": []\n\t            }\n\t          },\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"prompt\",\n\t            \"operator\": \"=\",\n", "            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@13\"\n\t              },\n\t              \"arguments\": []\n\t            }\n\t          },\n\t          {\n\t            \"$type\": \"Assignment\",\n", "            \"feature\": \"script\",\n\t            \"operator\": \"=\",\n\t            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@14\"\n\t              },\n\t              \"arguments\": []\n\t            }\n\t          }\n", "        ]\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n\t      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n\t    },\n\t    {\n", "      \"$type\": \"ParserRule\",\n\t      \"name\": \"Output\",\n\t      \"definition\": {\n\t        \"$type\": \"Group\",\n\t        \"elements\": [\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"name\",\n\t            \"operator\": \"=\",\n\t            \"terminal\": {\n", "              \"$type\": \"Keyword\",\n\t              \"value\": \"<output>\"\n\t            }\n\t          },\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"element\",\n\t            \"operator\": \"+=\",\n\t            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n", "              \"rule\": {\n\t                \"$ref\": \"#/rules@3\"\n\t              },\n\t              \"arguments\": []\n\t            },\n\t            \"cardinality\": \"*\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"</output>\"\n", "          }\n\t        ]\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n\t      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n\t    },\n", "    {\n\t      \"$type\": \"ParserRule\",\n\t      \"name\": \"NonScalarType\",\n\t      \"definition\": {\n\t        \"$type\": \"Alternatives\",\n\t        \"elements\": [\n\t          {\n\t            \"$type\": \"RuleCall\",\n\t            \"rule\": {\n\t              \"$ref\": \"#/rules@4\"\n", "            },\n\t            \"arguments\": []\n\t          },\n\t          {\n\t            \"$type\": \"RuleCall\",\n\t            \"rule\": {\n\t              \"$ref\": \"#/rules@5\"\n\t            },\n\t            \"arguments\": []\n\t          }\n", "        ]\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n\t      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n\t    },\n\t    {\n", "      \"$type\": \"ParserRule\",\n\t      \"name\": \"ObjectType\",\n\t      \"definition\": {\n\t        \"$type\": \"Group\",\n\t        \"elements\": [\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"<object\"\n\t          },\n\t          {\n", "            \"$type\": \"Keyword\",\n\t            \"value\": \"name=\"\n\t          },\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"name\",\n\t            \"operator\": \"=\",\n\t            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n", "                \"$ref\": \"#/rules@20\"\n\t              },\n\t              \"arguments\": []\n\t            }\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"format=\"\n\t          },\n\t          {\n", "            \"$type\": \"Assignment\",\n\t            \"feature\": \"format\",\n\t            \"operator\": \"=\",\n\t            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@7\"\n\t              },\n\t              \"arguments\": []\n\t            }\n", "          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \">\"\n\t          },\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"elements\",\n\t            \"operator\": \"+=\",\n\t            \"terminal\": {\n", "              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@8\"\n\t              },\n\t              \"arguments\": []\n\t            },\n\t            \"cardinality\": \"*\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n", "            \"value\": \"</object>\"\n\t          }\n\t        ]\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n\t      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n", "    },\n\t    {\n\t      \"$type\": \"ParserRule\",\n\t      \"name\": \"ListType\",\n\t      \"definition\": {\n\t        \"$type\": \"Group\",\n\t        \"elements\": [\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"<list\"\n", "          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"name=\"\n\t          },\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"name\",\n\t            \"operator\": \"=\",\n\t            \"terminal\": {\n", "              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@20\"\n\t              },\n\t              \"arguments\": []\n\t            }\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"format=\"\n", "          },\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"format\",\n\t            \"operator\": \"=\",\n\t            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@7\"\n\t              },\n", "              \"arguments\": []\n\t            }\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \">\"\n\t          },\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"elements\",\n", "            \"operator\": \"+=\",\n\t            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@8\"\n\t              },\n\t              \"arguments\": []\n\t            },\n\t            \"cardinality\": \"*\"\n\t          },\n", "          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"</list>\"\n\t          }\n\t        ]\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n\t      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n", "      \"parameters\": [],\n\t      \"wildcard\": false\n\t    },\n\t    {\n\t      \"$type\": \"ParserRule\",\n\t      \"name\": \"Format\",\n\t      \"definition\": {\n\t        \"$type\": \"Assignment\",\n\t        \"feature\": \"name\",\n\t        \"operator\": \"=\",\n", "        \"terminal\": {\n\t          \"$type\": \"RuleCall\",\n\t          \"rule\": {\n\t            \"$ref\": \"#/rules@15\"\n\t          },\n\t          \"arguments\": []\n\t        }\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n", "      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n\t    },\n\t    {\n\t      \"$type\": \"ParserRule\",\n\t      \"name\": \"Formats\",\n\t      \"definition\": {\n\t        \"$type\": \"Group\",\n", "        \"elements\": [\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"format\",\n\t            \"operator\": \"+=\",\n\t            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@6\"\n\t              },\n", "              \"arguments\": []\n\t            }\n\t          },\n\t          {\n\t            \"$type\": \"Group\",\n\t            \"elements\": [\n\t              {\n\t                \"$type\": \"Keyword\",\n\t                \"value\": \";\"\n\t              },\n", "              {\n\t                \"$type\": \"Assignment\",\n\t                \"feature\": \"format\",\n\t                \"operator\": \"+=\",\n\t                \"terminal\": {\n\t                  \"$type\": \"RuleCall\",\n\t                  \"rule\": {\n\t                    \"$ref\": \"#/rules@6\"\n\t                  },\n\t                  \"arguments\": []\n", "                }\n\t              }\n\t            ],\n\t            \"cardinality\": \"?\"\n\t          }\n\t        ]\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n\t      \"fragment\": false,\n", "      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n\t    },\n\t    {\n\t      \"$type\": \"ParserRule\",\n\t      \"name\": \"ScalarType\",\n\t      \"definition\": {\n\t        \"$type\": \"Assignment\",\n\t        \"feature\": \"element\",\n", "        \"operator\": \"+=\",\n\t        \"terminal\": {\n\t          \"$type\": \"Alternatives\",\n\t          \"elements\": [\n\t            {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@9\"\n\t              },\n\t              \"arguments\": []\n", "            },\n\t            {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@11\"\n\t              },\n\t              \"arguments\": []\n\t            }\n\t          ]\n\t        },\n", "        \"cardinality\": \"*\"\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n\t      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n\t    },\n\t    {\n", "      \"$type\": \"ParserRule\",\n\t      \"name\": \"StringType\",\n\t      \"definition\": {\n\t        \"$type\": \"Group\",\n\t        \"elements\": [\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"<string\"\n\t          },\n\t          {\n", "            \"$type\": \"Keyword\",\n\t            \"value\": \"name=\"\n\t          },\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"name\",\n\t            \"operator\": \"=\",\n\t            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n", "                \"$ref\": \"#/rules@20\"\n\t              },\n\t              \"arguments\": []\n\t            }\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"description=\"\n\t          },\n\t          {\n", "            \"$type\": \"Assignment\",\n\t            \"feature\": \"desc\",\n\t            \"operator\": \"=\",\n\t            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@22\"\n\t              },\n\t              \"arguments\": []\n\t            }\n", "          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"format=\"\n\t          },\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"format\",\n\t            \"operator\": \"=\",\n\t            \"terminal\": {\n", "              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@7\"\n\t              },\n\t              \"arguments\": []\n\t            }\n\t          },\n\t          {\n\t            \"$type\": \"Group\",\n\t            \"elements\": [\n", "              {\n\t                \"$type\": \"Keyword\",\n\t                \"value\": \"on-fail-\"\n\t              },\n\t              {\n\t                \"$type\": \"Assignment\",\n\t                \"feature\": \"fail\",\n\t                \"operator\": \"=\",\n\t                \"terminal\": {\n\t                  \"$type\": \"RuleCall\",\n", "                  \"rule\": {\n\t                    \"$ref\": \"#/rules@10\"\n\t                  },\n\t                  \"arguments\": []\n\t                }\n\t              },\n\t              {\n\t                \"$type\": \"Keyword\",\n\t                \"value\": \"=\"\n\t              },\n", "              {\n\t                \"$type\": \"Assignment\",\n\t                \"feature\": \"corrective\",\n\t                \"operator\": \"=\",\n\t                \"terminal\": {\n\t                  \"$type\": \"RuleCall\",\n\t                  \"rule\": {\n\t                    \"$ref\": \"#/rules@18\"\n\t                  },\n\t                  \"arguments\": []\n", "                }\n\t              }\n\t            ],\n\t            \"cardinality\": \"?\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \">\"\n\t          }\n\t        ]\n", "      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n\t      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n\t    },\n\t    {\n\t      \"$type\": \"ParserRule\",\n", "      \"name\": \"OnFail\",\n\t      \"definition\": {\n\t        \"$type\": \"Assignment\",\n\t        \"feature\": \"fail\",\n\t        \"operator\": \"=\",\n\t        \"terminal\": {\n\t          \"$type\": \"RuleCall\",\n\t          \"rule\": {\n\t            \"$ref\": \"#/rules@15\"\n\t          },\n", "          \"arguments\": []\n\t        }\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n\t      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n\t    },\n", "    {\n\t      \"$type\": \"ParserRule\",\n\t      \"name\": \"IntegerType\",\n\t      \"definition\": {\n\t        \"$type\": \"Group\",\n\t        \"elements\": [\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"<integer\"\n\t          },\n", "          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"name=\"\n\t          },\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"name\",\n\t            \"operator\": \"=\",\n\t            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n", "              \"rule\": {\n\t                \"$ref\": \"#/rules@20\"\n\t              },\n\t              \"arguments\": []\n\t            }\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"description=\"\n\t          },\n", "          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"desc\",\n\t            \"operator\": \"=\",\n\t            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@22\"\n\t              },\n\t              \"arguments\": []\n", "            }\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"format=\"\n\t          },\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"format\",\n\t            \"operator\": \"=\",\n", "            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@7\"\n\t              },\n\t              \"arguments\": []\n\t            }\n\t          },\n\t          {\n\t            \"$type\": \"Group\",\n", "            \"elements\": [\n\t              {\n\t                \"$type\": \"Keyword\",\n\t                \"value\": \"on-fail-\"\n\t              },\n\t              {\n\t                \"$type\": \"Assignment\",\n\t                \"feature\": \"fail\",\n\t                \"operator\": \"=\",\n\t                \"terminal\": {\n", "                  \"$type\": \"RuleCall\",\n\t                  \"rule\": {\n\t                    \"$ref\": \"#/rules@10\"\n\t                  },\n\t                  \"arguments\": []\n\t                }\n\t              },\n\t              {\n\t                \"$type\": \"Keyword\",\n\t                \"value\": \"=\"\n", "              },\n\t              {\n\t                \"$type\": \"Assignment\",\n\t                \"feature\": \"corrective\",\n\t                \"operator\": \"=\",\n\t                \"terminal\": {\n\t                  \"$type\": \"RuleCall\",\n\t                  \"rule\": {\n\t                    \"$ref\": \"#/rules@12\"\n\t                  },\n", "                  \"arguments\": []\n\t                }\n\t              }\n\t            ],\n\t            \"cardinality\": \"?\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \">\"\n\t          }\n", "        ]\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n\t      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n\t    },\n\t    {\n", "      \"$type\": \"ParserRule\",\n\t      \"name\": \"Corrective\",\n\t      \"definition\": {\n\t        \"$type\": \"Assignment\",\n\t        \"feature\": \"name\",\n\t        \"operator\": \"=\",\n\t        \"terminal\": {\n\t          \"$type\": \"RuleCall\",\n\t          \"rule\": {\n\t            \"$ref\": \"#/rules@18\"\n", "          },\n\t          \"arguments\": []\n\t        }\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n\t      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n", "    },\n\t    {\n\t      \"$type\": \"ParserRule\",\n\t      \"name\": \"Prompt\",\n\t      \"definition\": {\n\t        \"$type\": \"Group\",\n\t        \"elements\": [\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"name\",\n", "            \"operator\": \"=\",\n\t            \"terminal\": {\n\t              \"$type\": \"Keyword\",\n\t              \"value\": \"<prompt>\"\n\t            }\n\t          },\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"prompt\",\n\t            \"operator\": \"=\",\n", "            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@22\"\n\t              },\n\t              \"arguments\": []\n\t            }\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n", "            \"value\": \"</prompt>\"\n\t          }\n\t        ]\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n\t      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n", "    },\n\t    {\n\t      \"$type\": \"ParserRule\",\n\t      \"name\": \"Script\",\n\t      \"definition\": {\n\t        \"$type\": \"Group\",\n\t        \"elements\": [\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"name\",\n", "            \"operator\": \"=\",\n\t            \"terminal\": {\n\t              \"$type\": \"Keyword\",\n\t              \"value\": \"<script\"\n\t            }\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"language=\"\n\t          },\n", "          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"language\",\n\t            \"operator\": \"=\",\n\t            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@17\"\n\t              },\n\t              \"arguments\": []\n", "            }\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \">\"\n\t          },\n\t          {\n\t            \"$type\": \"Assignment\",\n\t            \"feature\": \"script\",\n\t            \"operator\": \"=\",\n", "            \"terminal\": {\n\t              \"$type\": \"RuleCall\",\n\t              \"rule\": {\n\t                \"$ref\": \"#/rules@22\"\n\t              },\n\t              \"arguments\": []\n\t            }\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n", "            \"value\": \"</script>\"\n\t          }\n\t        ]\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n\t      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n", "    },\n\t    {\n\t      \"$type\": \"ParserRule\",\n\t      \"name\": \"QualityCriteria\",\n\t      \"dataType\": \"string\",\n\t      \"definition\": {\n\t        \"$type\": \"Alternatives\",\n\t        \"elements\": [\n\t          {\n\t            \"$type\": \"Keyword\",\n", "            \"value\": \"bug-free-python\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"bug-free-sql\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"choice\"\n\t          },\n", "          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"ends-with\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"exclude-sql-predicates\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n", "            \"value\": \"is-high-quality-translation\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"alt-profinity-check\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"lowe-case\"\n\t          },\n", "          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"one-line\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"similar-to-document\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n", "            \"value\": \"sql-column-presence\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"two-words\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"upper-case\"\n\t          },\n", "          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"valid-choices\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"lenght\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n", "            \"value\": \"valid-range\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"valid-url\"\n\t          }\n\t        ]\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n", "      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n\t    },\n\t    {\n\t      \"$type\": \"ParserRule\",\n\t      \"name\": \"Version\",\n\t      \"dataType\": \"string\",\n\t      \"definition\": {\n", "        \"$type\": \"Alternatives\",\n\t        \"elements\": [\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"1.0\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"1.1\"\n\t          }\n", "        ]\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n\t      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n\t    },\n\t    {\n", "      \"$type\": \"ParserRule\",\n\t      \"name\": \"Languages\",\n\t      \"dataType\": \"string\",\n\t      \"definition\": {\n\t        \"$type\": \"Alternatives\",\n\t        \"elements\": [\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"python\"\n\t          },\n", "          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"typescript\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"c++\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n", "            \"value\": \"go\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"others\"\n\t          }\n\t        ]\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n", "      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n\t    },\n\t    {\n\t      \"$type\": \"ParserRule\",\n\t      \"name\": \"CorrectiveAction\",\n\t      \"dataType\": \"string\",\n\t      \"definition\": {\n", "        \"$type\": \"Alternatives\",\n\t        \"elements\": [\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"reask\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"fix\"\n\t          },\n", "          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"filter\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"refrain\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n", "            \"value\": \"noop\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"exception\"\n\t          },\n\t          {\n\t            \"$type\": \"Keyword\",\n\t            \"value\": \"fix_reask\"\n\t          }\n", "        ]\n\t      },\n\t      \"definesHiddenTokens\": false,\n\t      \"entry\": false,\n\t      \"fragment\": false,\n\t      \"hiddenTokens\": [],\n\t      \"parameters\": [],\n\t      \"wildcard\": false\n\t    },\n\t    {\n", "      \"$type\": \"TerminalRule\",\n\t      \"hidden\": true,\n\t      \"name\": \"WS\",\n\t      \"definition\": {\n\t        \"$type\": \"RegexToken\",\n\t        \"regex\": \"\\\\\\\\s+\"\n\t      },\n\t      \"fragment\": false\n\t    },\n\t    {\n", "      \"$type\": \"TerminalRule\",\n\t      \"name\": \"ID\",\n\t      \"definition\": {\n\t        \"$type\": \"RegexToken\",\n\t        \"regex\": \"[_a-zA-Z][\\\\\\\\w_]*\"\n\t      },\n\t      \"fragment\": false,\n\t      \"hidden\": false\n\t    },\n\t    {\n", "      \"$type\": \"TerminalRule\",\n\t      \"name\": \"INT\",\n\t      \"type\": {\n\t        \"$type\": \"ReturnType\",\n\t        \"name\": \"number\"\n\t      },\n\t      \"definition\": {\n\t        \"$type\": \"RegexToken\",\n\t        \"regex\": \"[0-9]+\"\n\t      },\n", "      \"fragment\": false,\n\t      \"hidden\": false\n\t    },\n\t    {\n\t      \"$type\": \"TerminalRule\",\n\t      \"name\": \"STRING\",\n\t      \"definition\": {\n\t        \"$type\": \"RegexToken\",\n\t        \"regex\": \"\\\\\"(\\\\\\\\\\\\\\\\.|[^\\\\\"\\\\\\\\\\\\\\\\])*\\\\\"|'(\\\\\\\\\\\\\\\\.|[^'\\\\\\\\\\\\\\\\])*'\"\n\t      },\n", "      \"fragment\": false,\n\t      \"hidden\": false\n\t    },\n\t    {\n\t      \"$type\": \"TerminalRule\",\n\t      \"hidden\": true,\n\t      \"name\": \"ML_COMMENT\",\n\t      \"definition\": {\n\t        \"$type\": \"RegexToken\",\n\t        \"regex\": \"\\\\\\\\/\\\\\\\\*[\\\\\\\\s\\\\\\\\S]*?\\\\\\\\*\\\\\\\\/\"\n", "      },\n\t      \"fragment\": false\n\t    },\n\t    {\n\t      \"$type\": \"TerminalRule\",\n\t      \"hidden\": true,\n\t      \"name\": \"SL_COMMENT\",\n\t      \"definition\": {\n\t        \"$type\": \"RegexToken\",\n\t        \"regex\": \"\\\\\\\\/\\\\\\\\/[^\\\\\\\\n\\\\\\\\r]*\"\n", "      },\n\t      \"fragment\": false\n\t    }\n\t  ],\n\t  \"definesHiddenTokens\": false,\n\t  \"hiddenTokens\": [],\n\t  \"imports\": [],\n\t  \"interfaces\": [],\n\t  \"types\": [],\n\t  \"usedGrammars\": []\n", "}`));\n"]}
{"filename": "src/language-server/generated/ast.ts", "chunked_list": ["/******************************************************************************\n\t * This file was generated by langium-cli 1.1.0.\n\t * DO NOT EDIT MANUALLY!\n\t ******************************************************************************/\n\t/* eslint-disable */\n\timport { AstNode, AbstractAstReflection, ReferenceInfo, TypeMetaData } from 'langium';\n\texport type CorrectiveAction = 'exception' | 'filter' | 'fix' | 'fix_reask' | 'noop' | 'reask' | 'refrain';\n\texport type Languages = 'c++' | 'go' | 'others' | 'python' | 'typescript';\n\texport type NonScalarType = ListType | ObjectType;\n\texport const NonScalarType = 'NonScalarType';\n", "export function isNonScalarType(item: unknown): item is NonScalarType {\n\t    return reflection.isInstance(item, NonScalarType);\n\t}\n\texport type QualityCriteria = 'alt-profinity-check' | 'bug-free-python' | 'bug-free-sql' | 'choice' | 'ends-with' | 'exclude-sql-predicates' | 'is-high-quality-translation' | 'lenght' | 'lowe-case' | 'one-line' | 'similar-to-document' | 'sql-column-presence' | 'two-words' | 'upper-case' | 'valid-choices' | 'valid-range' | 'valid-url';\n\texport type Version = '1.0' | '1.1';\n\texport interface Corrective extends AstNode {\n\t    readonly $container: IntegerType;\n\t    readonly $type: 'Corrective';\n\t    name: CorrectiveAction\n\t}\n", "export const Corrective = 'Corrective';\n\texport function isCorrective(item: unknown): item is Corrective {\n\t    return reflection.isInstance(item, Corrective);\n\t}\n\texport interface Format extends AstNode {\n\t    readonly $container: Formats;\n\t    readonly $type: 'Format';\n\t    name: QualityCriteria\n\t}\n\texport const Format = 'Format';\n", "export function isFormat(item: unknown): item is Format {\n\t    return reflection.isInstance(item, Format);\n\t}\n\texport interface Formats extends AstNode {\n\t    readonly $container: IntegerType | ListType | ObjectType | StringType;\n\t    readonly $type: 'Formats';\n\t    format: Array<Format>\n\t}\n\texport const Formats = 'Formats';\n\texport function isFormats(item: unknown): item is Formats {\n", "    return reflection.isInstance(item, Formats);\n\t}\n\texport interface IntegerType extends AstNode {\n\t    readonly $container: ScalarType;\n\t    readonly $type: 'IntegerType';\n\t    corrective?: Corrective\n\t    desc: string\n\t    fail?: OnFail\n\t    format: Formats\n\t    name: string\n", "}\n\texport const IntegerType = 'IntegerType';\n\texport function isIntegerType(item: unknown): item is IntegerType {\n\t    return reflection.isInstance(item, IntegerType);\n\t}\n\texport interface ListType extends AstNode {\n\t    readonly $container: Output;\n\t    readonly $type: 'ListType';\n\t    elements: Array<ScalarType>\n\t    format: Formats\n", "    name: string\n\t}\n\texport const ListType = 'ListType';\n\texport function isListType(item: unknown): item is ListType {\n\t    return reflection.isInstance(item, ListType);\n\t}\n\texport interface Model extends AstNode {\n\t    readonly $type: 'Model';\n\t    rails: Rails\n\t    version: Version\n", "}\n\texport const Model = 'Model';\n\texport function isModel(item: unknown): item is Model {\n\t    return reflection.isInstance(item, Model);\n\t}\n\texport interface ObjectType extends AstNode {\n\t    readonly $container: Output;\n\t    readonly $type: 'ObjectType';\n\t    elements: Array<ScalarType>\n\t    format: Formats\n", "    name: string\n\t}\n\texport const ObjectType = 'ObjectType';\n\texport function isObjectType(item: unknown): item is ObjectType {\n\t    return reflection.isInstance(item, ObjectType);\n\t}\n\texport interface OnFail extends AstNode {\n\t    readonly $container: IntegerType | StringType;\n\t    readonly $type: 'OnFail';\n\t    fail: QualityCriteria\n", "}\n\texport const OnFail = 'OnFail';\n\texport function isOnFail(item: unknown): item is OnFail {\n\t    return reflection.isInstance(item, OnFail);\n\t}\n\texport interface Output extends AstNode {\n\t    readonly $container: Rails;\n\t    readonly $type: 'Output';\n\t    element: Array<NonScalarType>\n\t    name: '<output>'\n", "}\n\texport const Output = 'Output';\n\texport function isOutput(item: unknown): item is Output {\n\t    return reflection.isInstance(item, Output);\n\t}\n\texport interface Prompt extends AstNode {\n\t    readonly $container: Rails;\n\t    readonly $type: 'Prompt';\n\t    name: '<prompt>'\n\t    prompt: string\n", "}\n\texport const Prompt = 'Prompt';\n\texport function isPrompt(item: unknown): item is Prompt {\n\t    return reflection.isInstance(item, Prompt);\n\t}\n\texport interface Rails extends AstNode {\n\t    readonly $container: Model;\n\t    readonly $type: 'Rails';\n\t    output: Output\n\t    prompt: Prompt\n", "    script: Script\n\t}\n\texport const Rails = 'Rails';\n\texport function isRails(item: unknown): item is Rails {\n\t    return reflection.isInstance(item, Rails);\n\t}\n\texport interface ScalarType extends AstNode {\n\t    readonly $container: ListType | ObjectType;\n\t    readonly $type: 'ScalarType';\n\t    element: Array<IntegerType | StringType>\n", "}\n\texport const ScalarType = 'ScalarType';\n\texport function isScalarType(item: unknown): item is ScalarType {\n\t    return reflection.isInstance(item, ScalarType);\n\t}\n\texport interface Script extends AstNode {\n\t    readonly $container: Rails;\n\t    readonly $type: 'Script';\n\t    language: Languages\n\t    name: '<script'\n", "    script: string\n\t}\n\texport const Script = 'Script';\n\texport function isScript(item: unknown): item is Script {\n\t    return reflection.isInstance(item, Script);\n\t}\n\texport interface StringType extends AstNode {\n\t    readonly $container: ScalarType;\n\t    readonly $type: 'StringType';\n\t    corrective?: CorrectiveAction\n", "    desc: string\n\t    fail?: OnFail\n\t    format: Formats\n\t    name: string\n\t}\n\texport const StringType = 'StringType';\n\texport function isStringType(item: unknown): item is StringType {\n\t    return reflection.isInstance(item, StringType);\n\t}\n\texport interface RailsAstType {\n", "    Corrective: Corrective\n\t    Format: Format\n\t    Formats: Formats\n\t    IntegerType: IntegerType\n\t    ListType: ListType\n\t    Model: Model\n\t    NonScalarType: NonScalarType\n\t    ObjectType: ObjectType\n\t    OnFail: OnFail\n\t    Output: Output\n", "    Prompt: Prompt\n\t    Rails: Rails\n\t    ScalarType: ScalarType\n\t    Script: Script\n\t    StringType: StringType\n\t}\n\texport class RailsAstReflection extends AbstractAstReflection {\n\t    getAllTypes(): string[] {\n\t        return ['Corrective', 'Format', 'Formats', 'IntegerType', 'ListType', 'Model', 'NonScalarType', 'ObjectType', 'OnFail', 'Output', 'Prompt', 'Rails', 'ScalarType', 'Script', 'StringType'];\n\t    }\n", "    protected override computeIsSubtype(subtype: string, supertype: string): boolean {\n\t        switch (subtype) {\n\t            case ListType:\n\t            case ObjectType: {\n\t                return this.isSubtype(NonScalarType, supertype);\n\t            }\n\t            default: {\n\t                return false;\n\t            }\n\t        }\n", "    }\n\t    getReferenceType(refInfo: ReferenceInfo): string {\n\t        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n\t        switch (referenceId) {\n\t            default: {\n\t                throw new Error(`${referenceId} is not a valid reference id.`);\n\t            }\n\t        }\n\t    }\n\t    getTypeMetaData(type: string): TypeMetaData {\n", "        switch (type) {\n\t            case 'Formats': {\n\t                return {\n\t                    name: 'Formats',\n\t                    mandatory: [\n\t                        { name: 'format', type: 'array' }\n\t                    ]\n\t                };\n\t            }\n\t            case 'ListType': {\n", "                return {\n\t                    name: 'ListType',\n\t                    mandatory: [\n\t                        { name: 'elements', type: 'array' }\n\t                    ]\n\t                };\n\t            }\n\t            case 'ObjectType': {\n\t                return {\n\t                    name: 'ObjectType',\n", "                    mandatory: [\n\t                        { name: 'elements', type: 'array' }\n\t                    ]\n\t                };\n\t            }\n\t            case 'Output': {\n\t                return {\n\t                    name: 'Output',\n\t                    mandatory: [\n\t                        { name: 'element', type: 'array' }\n", "                    ]\n\t                };\n\t            }\n\t            case 'ScalarType': {\n\t                return {\n\t                    name: 'ScalarType',\n\t                    mandatory: [\n\t                        { name: 'element', type: 'array' }\n\t                    ]\n\t                };\n", "            }\n\t            default: {\n\t                return {\n\t                    name: type,\n\t                    mandatory: []\n\t                };\n\t            }\n\t        }\n\t    }\n\t}\n", "export const reflection = new RailsAstReflection();\n"]}
