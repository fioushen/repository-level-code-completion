{"filename": "src/main.ts", "chunked_list": ["import * as fs from \"node:fs\"\n\timport { deployServer } from \"./server/deployer.js\"\n\timport { startTests } from \"./server/controller.js\"\n\timport type { Args } from \"./utils.js\"\n\timport { getArguments } from \"./utils.js\"\n\timport {info, setFailed} from \"@actions/core\";\n\timport {context, getOctokit} from \"@actions/github\";\n\timport type {PullRequestInfo} from \"./outputs/pull-request/appender\";\n\timport {initPullRequest} from \"./server/client\";\n\tconst main = async (): Promise<void> => {\n", "    const args: Args = getArguments()\n\t    const { mcVersion,\n\t        javaVersion,\n\t        scenamaticaVersion,\n\t        serverDir,\n\t        pluginFile,\n\t        githubToken\n\t    } = args\n\t    const pullRequest = context.payload.pull_request\n\t    if (pullRequest) {\n", "        initPRMode(pullRequest, githubToken)\n\t    }\n\t    if (!fs.existsSync(pluginFile)) {\n\t        setFailed(`Plugin file ${pluginFile} does not exist`)\n\t        return\n\t    }\n\t    const paper = await deployServer(serverDir, javaVersion, mcVersion, scenamaticaVersion)\n\t    info(\"Starting tests...\")\n\t    await startTests(serverDir, paper, pluginFile)\n\t}\n", "const initPRMode = (pullRequest: {number: number}, token: string) => {\n\t    info(`Running in Pull Request mode for PR #${pullRequest.number}`)\n\t    const prInfo: PullRequestInfo = {\n\t        number: pullRequest.number,\n\t        octokit: getOctokit(token),\n\t        owner: context.repo.owner,\n\t        repository: context.repo.repo\n\t    }\n\t    initPullRequest(prInfo)\n\t}\n", "main().catch((error) => {\n\t    if (error instanceof Error)\n\t        setFailed(error)\n\t    else {\n\t        const message = error as string\n\t        setFailed(message)\n\t    }\n\t})\n"]}
{"filename": "src/logging.ts", "chunked_list": ["import type {PacketSessionEnd, Scenario, TestState} from \"./packets\";\n\timport { TestResultCause} from \"./packets\";\n\timport {endGroup, info, startGroup, warning} from \"@actions/core\";\n\texport const logTestStart = (scenario: Scenario): void => {\n\t    startGroup(`Test: ${scenario.name}`)\n\t    info(`Starting test: ${scenario.name} (${scenario.description ?? \"(No description provided)\"})`)\n\t}\n\texport const logTestEnd = (\n\t    name: string,\n\t    state: TestState,\n", "    cause: TestResultCause,\n\t    startedAt: number,\n\t    finishedAt: number,\n\t): void => {\n\t    const elapsed = `${finishedAt - startedAt} ms`\n\t    const emoji = getEmojiForCause(cause)\n\t    switch (cause) {\n\t        case TestResultCause.CANCELLED: {\n\t            info(`${emoji} The test ${name} is cancelled with state ${state} in ${elapsed}.`)\n\t            break\n", "        }\n\t        case TestResultCause.PASSED: {\n\t            info(`${emoji} The test ${name} is passed with state ${state} in ${elapsed}.`)\n\t            break\n\t        }\n\t        case TestResultCause.SKIPPED: {\n\t            info(`${emoji} The test ${name} is skipped with state ${state} in ${elapsed}.`)\n\t            break\n\t        }\n\t        default: {\n", "            warning(`${emoji} The test ${name} is failed with state ${state} in ${elapsed}.`)\n\t            break\n\t        }\n\t    }\n\t    endGroup()\n\t}\n\texport const getEmojiForCause = (cause: TestResultCause): string => {\n\t    switch (cause) {\n\t        case TestResultCause.PASSED: {\n\t            return \"✔\"\n", "        }\n\t        case TestResultCause.SKIPPED: {\n\t            return \"➔\"\n\t        }\n\t        case TestResultCause.CANCELLED: {\n\t            return \":no_entry:\"\n\t        }\n\t        default: {\n\t            return \"❌\"\n\t        }\n", "    }\n\t}\n\texport const logSessionStart = (startedAt: number, tests: number): void => {\n\t    info(\"--------------------------------------\")\n\t    info(\" T E S T S\")\n\t    info(\"--------------------------------------\")\n\t    info(`The session is started at ${startedAt}, ${tests} tests are marked to be run.`)\n\t}\n\texport const logSessionEnd = (sessionEnd: PacketSessionEnd): void => {\n\t    const elapsed = `${Math.ceil((sessionEnd.finishedAt - sessionEnd.startedAt) / 1000)} sec`\n", "    const {results} = sessionEnd\n\t    const total = results.length\n\t    const failures = results.filter(\n\t        (t) =>\n\t            !(\n\t                t.cause === TestResultCause.PASSED ||\n\t                t.cause === TestResultCause.SKIPPED ||\n\t                t.cause === TestResultCause.CANCELLED\n\t            ),\n\t    ).length\n", "    const skipped = results.filter((t) => t.cause === TestResultCause.SKIPPED).length\n\t    info(`\\nResults:\\n`)\n\t    info(`Tests run: ${total}, Failures: ${failures}, Skipped: ${skipped}, Time elapsed: ${elapsed}\\n`)\n\t}\n"]}
{"filename": "src/packets.ts", "chunked_list": ["// @ts-nocheck\n\texport class Packet<T extends Packet<T>> {\n\t    public constructor(public genre: string, public type: string, public date: number) {}\n\t}\n\texport interface Scenario {\n\t    name: string\n\t    description?: string\n\t}\n\texport class PacketTestStart implements Packet<PacketTestStart> {\n\t    public genre = \"test\"\n", "    public type = \"start\"\n\t    public constructor(public date: number, public scenario: Scenario) {}\n\t}\n\texport enum TestState {\n\t    STAND_BY = \"STAND_BY\",\n\t    CONTEXT_PREPARING = \"CONTEXT_PREPARING\",\n\t    STARTING = \"STARTING\",\n\t    RUNNING_BEFORE = \"RUNNING_BEFORE\",\n\t    RUNNING_MAIN = \"RUNNING_MAIN\",\n\t    RUNNING_AFTER = \"RUNNING_AFTER\",\n", "    FINISHED = \"FINISHED\",\n\t}\n\texport enum TestResultCause {\n\t    PASSED = \"PASSED\",\n\t    CONTEXT_PREPARATION_FAILED = \"CONTEXT_PREPARATION_FAILED\",\n\t    ACTION_EXECUTION_FAILED = \"ACTION_EXECUTION_FAILED\",\n\t    ACTION_EXPECTATION_JUMPED = \"ACTION_EXPECTATION_JUMPED\",\n\t    SCENARIO_TIMED_OUT = \"SCENARIO_TIMED_OUT\",\n\t    ILLEGAL_CONDITION = \"ILLEGAL_CONDITION\",\n\t    INTERNAL_ERROR = \"INTERNAL_ERROR\",\n", "    CANCELLED = \"CANCELLED\",\n\t    SKIPPED = \"SKIPPED\",\n\t}\n\texport class PacketTestEnd implements Packet<PacketTestEnd> {\n\t    public genre = \"test\"\n\t    public type = \"end\"\n\t    public constructor(\n\t        public date: number,\n\t        public scenario: Scenario,\n\t        public state: TestState,\n", "        public cause: TestResultCause,\n\t        public startedAt: number,\n\t        public finishedAt: number,\n\t    ) {}\n\t}\n\texport class PacketSessionStart implements Packet<PacketSessionStart> {\n\t    public genre = \"session\"\n\t    public type = \"start\"\n\t    public constructor(\n\t        public date: number,\n", "        public tests: PacketTestStart[],\n\t        public isAutoStart: boolean,\n\t        public startedAt: number,\n\t    ) {}\n\t}\n\texport class PacketSessionEnd implements Packet<PacketSessionEnd> {\n\t    public genre = \"session\"\n\t    public type = \"end\"\n\t    public constructor(\n\t        public date: number,\n", "        public results: PacketTestEnd[],\n\t        public startedAt: number,\n\t        public finishedAt: number,\n\t    ) {}\n\t}\n\texport class PacketScenamaticaError implements Packet<PacketScenamaticaError> {\n\t    public genre = \"general\"\n\t    public type = \"error\"\n\t    public constructor(public date: number, public exception: string, public message: string, public stackTrace: string[]) {}\n\t}\n", "export const parsePacket = (\n\t    packet: string,\n\t): Packet<PacketSessionEnd | PacketSessionStart | PacketTestEnd | PacketTestStart> | null => {\n\t    const json: unknown = JSON.parse(packet)\n\t    switch (json.genre) {\n\t        case \"session\": {\n\t            switch (json.type) {\n\t                case \"start\": {\n\t                    return new PacketSessionStart(json.date, json.tests, json.isAutoStart, json.startedAt)\n\t                }\n", "                case \"end\": {\n\t                    return new PacketSessionEnd(json.date, json.results, json.startedAt, json.date)\n\t                }\n\t            }\n\t            break\n\t        }\n\t        case \"test\": {\n\t            switch (json.type) {\n\t                case \"start\": {\n\t                    return new PacketTestStart(json.date, json.scenario)\n", "                }\n\t                case \"end\": {\n\t                    return new PacketTestEnd(\n\t                        json.date,\n\t                        json.scenario,\n\t                        json.state,\n\t                        json.cause,\n\t                        json.startedAt,\n\t                        json.finishedAt,\n\t                    )\n", "                }\n\t            }\n\t            break\n\t        }\n\t        case \"general\": {\n\t            switch (json.type) {\n\t                case \"error\": {\n\t                    return new PacketScenamaticaError(json.date, json.exception, json.message, json.stackTrace)\n\t                }\n\t            }\n", "            break\n\t        }\n\t    }\n\t    return null\n\t}\n\texport * from \"./packets\"\n"]}
{"filename": "src/utils.ts", "chunked_list": ["import * as core from \"@actions/core\"\n\timport type {PacketTestEnd} from \"./packets\";\n\timport {TestResultCause} from \"./packets\";\n\tconst DEFAULT_SCENAMATICA_VERSION = \"0.7.0\"\n\tconst ENV_NO_SCENAMATICA = \"NO_SCENAMATICA\"\n\tconst extractTestResults = (results: PacketTestEnd[]) => {\n\t    const total = results.length\n\t    const passed = results.filter((t) => t.cause === TestResultCause.PASSED).length\n\t    const skipped = results.filter((t) => t.cause === TestResultCause.SKIPPED).length\n\t    const cancelled = results.filter((t) => t.cause === TestResultCause.CANCELLED).length\n", "    const failures = results.filter(\n\t        (t) =>\n\t            !(\n\t                t.cause === TestResultCause.PASSED ||\n\t                t.cause === TestResultCause.SKIPPED ||\n\t                t.cause === TestResultCause.CANCELLED\n\t            ),\n\t    ).length\n\t    return {\n\t        total,\n", "        passed,\n\t        failures,\n\t        skipped,\n\t        cancelled,\n\t    }\n\t}\n\texport const isTestSucceed = (results: PacketTestEnd[]) => {\n\t    const {failures} = extractTestResults(results)\n\t    const threshold = getArguments().failThreshold\n\t    return failures <= threshold\n", "}\n\tinterface Args {\n\t    mcVersion: string\n\t    scenamaticaVersion: string\n\t    serverDir: string\n\t    pluginFile: string\n\t    javaVersion: string\n\t    githubToken: string\n\t    failThreshold: number\n\t}\n", "const getArguments = (): Args => {\n\t    return {\n\t        mcVersion: core.getInput(\"minecraft\") || \"1.16.5\",\n\t        scenamaticaVersion: core.getInput(\"scenamatica\", ) || DEFAULT_SCENAMATICA_VERSION,\n\t        serverDir: core.getInput(\"server-dir\") || \"server\",\n\t        pluginFile: core.getInput(\"plugin\", { required: true }),\n\t        javaVersion: core.getInput(\"java\") || \"17\",\n\t        githubToken: core.getInput(\"github-token\") || process.env.GITHUB_TOKEN!,\n\t        failThreshold: Number.parseInt(core.getInput(\"fail-threshold\"), 10) || 0,\n\t    }\n", "}\n\tconst isNoScenamatica = (): boolean => {\n\t    return process.env[ENV_NO_SCENAMATICA] === \"true\"\n\t}\n\texport { extractTestResults, getArguments, Args, isNoScenamatica }\n"]}
{"filename": "src/outputs/messages.ts", "chunked_list": ["import {extractTestResults, getArguments} from \"../utils\";\n\timport type {PacketTestEnd} from \"../packets\";\n\timport {getEmojiForCause} from \"../logging\";\n\tconst MESSAGES_PASSED = [\n\t    \":tada: Congrats! All tests passed! :star2:\",\n\t    \":raised_hands: High-five! You nailed all the tests! :tada::tada:\",\n\t    \":confetti_ball: Hooray! Everything's working perfectly! :tada::confetti_ball:\",\n\t    \":100: Perfect score! All tests passed with flying colors! :rainbow::clap:\",\n\t    \":thumbsup: Great job! All tests passed without a hitch! :rocket::star2:\",\n\t    \":metal: Rock on! All tests passed flawlessly! :guitar::metal:\",\n", "    \":partying_face: Celebrate good times! All tests passed with flying colors! :tada::confetti_ball::balloon:\",\n\t    \":muscle: You crushed it! All tests passed with ease! :fire::muscle:\",\n\t    \":1st_place_medal: Gold medal performance! All tests passed with flying colors! :1st_place_medal::star2:\",\n\t    \":champagne: Pop the champagne! All tests passed, time to celebrate! :champagne::tada:\"\n\t];\n\tconst MESSAGES_NO_TESTS = [\n\t    \"Alright, who forgot to write tests? :face_with_raised_eyebrow:\",\n\t    \"No tests? Time to break out the crystal ball. :crystal_ball:\",\n\t    \"Tests? Who writes tests? :person_shrugging:\",\n\t    \"No tests found. Did they run away? :man_running: :woman_running:\",\n", "    \"No tests, no glory. :trophy:\",\n\t    \"Tests? We don't need no stinkin' tests! :shushing_face:\",\n\t    \"No tests? I guess we'll just have to wing it. :eagle:\",\n\t    \"You get a test, and you get a test! Everybody gets a test! :gift: :tada:\",\n\t    \"No tests? That's impossible! :dizzy_face:\",\n\t    \"Tests make the code go round. :carousel_horse:\"\n\t];\n\tconst MESSAGES_FAILED = [\n\t    \"Oops! Something went wrong! :scream_cat:\",\n\t    \"Oh no! The tests have betrayed us! :scream:\",\n", "    \"Houston, we have a problem. :rocket:\",\n\t    \"Looks like we have some debugging to do. :beetle:\",\n\t    \"Failures? More like opportunities to improve! :muscle:\",\n\t    \"This is not the result we were looking for. :confused:\",\n\t    \"Looks like we need to rethink our strategy. :thinking:\",\n\t    \"Don't worry, we'll get 'em next time! :sunglasses:\",\n\t    \"Keep calm and debug on. :female_detective:\",\n\t    \"The only way is up from here! :rocket:\"\n\t];\n\tconst MESSAGES_PASSED_WITH_THRESHOLD = [\n", "    \"Tests passed, but some are being rebellious. Debug mode: ON! :microscope:\",\n\t    \"Almost there! Some tests failed, but hey, progress is progress! :turtle:\",\n\t    \"Good news: most tests passed. Bad news: a few had different plans. Let's fix 'em! :hammer:\",\n\t    \"We're on the right track, but some tests are playing hard to get. Challenge accepted! :muscle:\",\n\t    \"Tests went well overall, but we have a few stubborn failures. Time for some gentle persuasion! :wrench:\",\n\t    \"Success with a side of failures. It's like a bittersweet symphony. Let's sweeten it up! :musical_note:\",\n\t    \"We're soaring high, but some tests got left behind. Time to reel them back in! :fishing_pole_and_fish:\",\n\t    \"Great progress, but we've got some test gremlins causing trouble. Let's send them packing! :imp:\",\n\t    \"Victory is ours, with a sprinkle of defeat. Let's conquer those pesky failures! :crossed_swords:\",\n\t    \"We're almost there, but a few tests are being rebellious. Let's bring them back to the flock! :sheep:\"\n", "];\n\tconst REPORT_URL = \"https://github.com/TeamKun/Scenamatica/issues/new?assignees=PeyaPeyaPeyang&labels=Type%3A+Bug&projects=&template=bug_report.yml&title=%E3%80%90%E3%83%90%E3%82%B0%E3%80%91\"\n\texport const getHeader = (isError: boolean) => {\n\t    const result = [ wrap(\"h1\", \"Scenamatica\"), wrap(\"h2\", \"Summary\"), \"<hr />\"]\n\t    if (isError) {\n\t        result.push(\n\t            wrap(\"h4\", \":no_entry: ERROR!!\"),\n\t            wrap(\"p\", \"An unexpected error occurred while running the server and Scenamatica daemon.\"),\n\t            wrap(\"h2\", \"Error details\")\n\t        )\n", "    }\n\t    return joinLine(...result)\n\t}\n\texport const getRunningMessage = () => {\n\t    const messages = [\n\t        wrap(\"h4\", \":hourglass_flowing_sand: Hey there! :wave: We're currently testing your plugin.\"),\n\t        wrap(\"p\", \"The testing process may take some time, but we'll update this message once it's complete.\")\n\t    ]\n\t    return joinLine(...messages)\n\t}\n", "export const getTestSummary = (results: PacketTestEnd[], startedAt: number, finishedAt: number) => {\n\t    const elapsed = (finishedAt - startedAt) / 1000\n\t    const {\n\t        total,\n\t        passed,\n\t        failures,\n\t        skipped,\n\t        cancelled\n\t    } = extractTestResults(results)\n\t    return joinLine(\n", "        getSummaryHeader(total, elapsed, passed, failures, skipped, cancelled),\n\t        \"<hr />\",\n\t        wrap(\"h2\", \"Details\")\n\t    )\n\t}\n\texport const getTestResultTable = (results: PacketTestEnd[], minimize = false) => {\n\t    const header = wrap(\"thead\", joinLine(\n\t            wrap(\"tr\", joinLine(\n\t                wrap(\"th\", \" \"),\n\t                wrap(\"th\", \"Test\"),\n", "                wrap(\"th\", \"Cause\"),\n\t                wrap(\"th\", \"State\"),\n\t                wrap(\"th\", \"Started at\"),\n\t                wrap(\"th\", \"Finished at\"),\n\t                wrap(\"th\", \"Elapsed\"),\n\t                wrap(\"th\", \"Test description\")\n\t            ))\n\t        )\n\t    )\n\t    const body = wrap(\"tbody\", joinLine(...results.map((result) => {\n", "            const {\n\t                cause,\n\t                state,\n\t                scenario,\n\t                startedAt,\n\t                finishedAt\n\t            } = result\n\t            const emoji = getEmojiForCause(cause)\n\t            const { name } = scenario\n\t            const startedAtStr = new Date(startedAt).toLocaleString()\n", "            const finishedAtStr = new Date(finishedAt).toLocaleString()\n\t            const testElapsed = `${Math.ceil((finishedAt - startedAt) / 1000)} sec`\n\t            const description = scenario.description || \"No description\"\n\t            return wrap(\"tr\", joinLine(\n\t                wrap(\"td\", emoji),\n\t                wrap(\"td\", name),\n\t                wrap(\"td\", cause),\n\t                wrap(\"td\", state),\n\t                wrap(\"td\", startedAtStr),\n\t                wrap(\"td\", finishedAtStr),\n", "                wrap(\"td\", testElapsed),\n\t                wrap(\"td\", description)\n\t            ))\n\t        }))\n\t    )\n\t    const table = wrap(\"table\", joinLine(header, body))\n\t    if (minimize)\n\t        return wrap(\"details\", joinLine(\n\t            wrap(\"summary\", \"Full test results\"),\n\t            table\n", "        ))\n\t    return table\n\t}\n\tconst getSummaryHeader = (total: number, elapsed: number, passed: number, failures: number, skipped: number, cancelled: number) => {\n\t    const threshold = getArguments().failThreshold\n\t    let messageSource: string[]\n\t    if (total === passed + skipped) messageSource = MESSAGES_PASSED\n\t    else if (failures === 0) messageSource = MESSAGES_NO_TESTS\n\t    else if (failures <= threshold) messageSource = MESSAGES_PASSED_WITH_THRESHOLD\n\t    else messageSource = MESSAGES_FAILED\n", "    const summaryText = messageSource[Math.floor(Math.random() * messageSource.length)]\n\t    return joinLine(\n\t        wrap(\"h4\", summaryText),\n\t        \"<br />\",\n\t        wrap(\"p\", join(\", \",\n\t            `Tests run: ${total}`,\n\t            `Failures: ${failures}`,\n\t            `Skipped: ${skipped}`,\n\t            `Cancelled: ${cancelled}`,\n\t            `Time elapsed: ${elapsed} sec`\n", "        ))\n\t    )\n\t}\n\texport const getExceptionString = (errorType: string, errorMessage: string, errorStackTrace: string[]) => {\n\t    return wrap(\"pre\", wrap(\"code\", joinLine(\n\t                \"An unexpected error has occurred while running Scenamatica daemon:\",\n\t                `${errorType}: ${errorMessage}`,\n\t                ...errorStackTrace.map((s) => `    at ${s}`)\n\t            )\n\t    ))\n", "}\n\texport const getReportingMessage = () => {\n\t    return joinLine(\n\t        wrap(\"h2\", \"Reporting bugs\"),\n\t        wrap(\"p\", combine(\n\t            \"If you believe this is a bug, please report it to \",\n\t            wrap(\"a\", \"Scenamatica\", { href: REPORT_URL }),\n\t            \" along with the contents of this error message, the above stack trace, and the environment information listed below.\"\n\t        )),\n\t        getEnvInfoMessage()\n", "    )\n\t}\n\texport const getFooter = () => {\n\t    return joinLine(\n\t        \"<hr />\",\n\t        getLicenseMessage()\n\t    )\n\t}\n\tconst getEnvInfoMessage = () => {\n\t    const runArgs = getArguments()\n", "    const envInfo = [\n\t        \"+ Versions:\",\n\t        `  - Scenamatica: ${runArgs.scenamaticaVersion}`,\n\t        `  - Minecraft: ${runArgs.mcVersion}`,\n\t        `  - Java: ${runArgs.javaVersion}`,\n\t        `  - Node.js: ${process.version}`,\n\t        \"+ Runner:\",\n\t        `  - OS: ${process.platform}`,\n\t        `  - Arch: ${process.arch}`,\n\t    ]\n", "    return wrap(\"details\", joinLine(\n\t        wrap(\"summary\", \"Environment Information\"),\n\t        wrap(\"pre\", wrap(\"code\", envInfo.join(\"\\n\")))\n\t    ))\n\t}\n\tconst getLicenseMessage = () => {\n\t    return joinLine(\n\t        wrap(\"h2\" , \"License\"),\n\t        wrap(\"small\", `This test report has been generated by ${\n\t            wrap(\"a\", \"Scenamatica\", { href: \"https://github.com/TeamKUN/Scenamatica\" })\n", "        } and licensed under ${\n\t            wrap(\"a\", \"MIT License\", { href: \"https://github.com/TeamKUN/Scenamatica/blob/main/LICENSE\" })\n\t        }.`),\n\t        \"<br />\",\n\t        wrap(\"small\", \"You can redistribute it and/or modify it under the terms of the MIT License.\")\n\t    )\n\t}\n\tconst wrap = (tag: string, text: string, props: { [key: string]: string } = {}) => {\n\t    const attributes = Object.entries(props).map(([key, value]) => `${key}=\"${value}\"`).join(\" \")\n\t    return `<${tag} ${attributes}>${text}</${tag}>`\n", "}\n\tconst joinLine = (...texts: string[]) => {\n\t    return texts.join(\"\\n\")\n\t}\n\tconst join = (delimiter: string, ...texts: string[]) => {\n\t    return texts.join(delimiter)\n\t}\n\tconst combine = (...texts: string[]) => {\n\t    return texts.join(\"\")\n\t}\n"]}
{"filename": "src/outputs/publisher.ts", "chunked_list": ["import type { PacketSessionEnd,PacketScenamaticaError} from \"../packets\";\n\timport {printErrorSummary, printSummary} from \"./summary\";\n\timport {publishOutput} from \"./action-output\";\n\timport type { PullRequestInfo} from \"./pull-request/appender\";\n\timport {publishPRComment, reportRunning, reportError, reportSessionEnd} from \"./pull-request/appender\";\n\texport const publishSessionEnd = async (packet: PacketSessionEnd) => {\n\t    await printSummary(packet)\n\t    publishOutput(packet)\n\t    reportSessionEnd(packet)\n\t}\n", "export const publishScenamaticaError = async (packet: PacketScenamaticaError) => {\n\t    const {exception, message, stackTrace} = packet\n\t    await printErrorSummary(exception, message, stackTrace)\n\t    publishOutput(packet)\n\t    reportError(packet)\n\t}\n\texport const publishRunning = (info: PullRequestInfo) => {\n\t    reportRunning()\n\t    publishPRComment(info)  // 即反映\n\t        .catch(console.error)\n", "}\n"]}
{"filename": "src/outputs/summary.ts", "chunked_list": ["import type {PacketSessionEnd} from \"../packets\"\n\timport {summary} from \"@actions/core\";\n\timport {\n\t    getExceptionString,\n\t    getFooter,\n\t    getHeader,\n\t    getReportingMessage,\n\t    getTestResultTable,\n\t    getTestSummary\n\t} from \"./messages\";\n", "const printSummary = async (sessionEnd: PacketSessionEnd) => {\n\t    const {results, finishedAt, startedAt} = sessionEnd\n\t    summary.addRaw(getHeader(false))\n\t    summary.addRaw(getTestSummary(results, startedAt, finishedAt))\n\t    summary.addRaw(getTestResultTable(results))\n\t    await summary.write()\n\t}\n\tlet errorHeaderPrinted = false\n\tlet errorReportingMessagePrinted = false\n\tconst printErrorSummary = async (errorType: string, errorMessage: string, errorStackTrace: string[]) => {\n", "    if (!errorHeaderPrinted) {\n\t        summary.addRaw(getHeader(true))\n\t        errorHeaderPrinted = true\n\t    }\n\t    summary.addRaw(getExceptionString(errorType, errorMessage, errorStackTrace))\n\t    if (!errorReportingMessagePrinted) {\n\t        summary.addRaw(getReportingMessage())\n\t        errorReportingMessagePrinted = true\n\t    }\n\t    await summary.write()\n", "}\n\tconst printFooter = async () => {\n\t    summary.addRaw(getFooter())\n\t    await summary.write()\n\t}\n\texport { printSummary, printErrorSummary, printFooter }\n"]}
{"filename": "src/outputs/action-output.ts", "chunked_list": ["import type { PacketSessionEnd} from \"../packets\";\n\timport {PacketScenamaticaError, TestResultCause} from \"../packets\";\n\timport {setOutput} from \"@actions/core\";\n\timport {isTestSucceed} from \"../utils\";\n\texport const publishOutput = (packet: PacketScenamaticaError | PacketSessionEnd) => {\n\t    if (packet instanceof PacketScenamaticaError) {\n\t        publishError(packet)\n\t    } else {\n\t        publishSessionEnd(packet);\n\t    }\n", "}\n\tconst publishError = (packet: PacketScenamaticaError) => {\n\t    const {exception, message} = packet\n\t    setOutput(\"success\", false)\n\t    setOutput(\"runner-error-type\", exception)\n\t    setOutput(\"runner-error-message\", message)\n\t}\n\tconst publishSessionEnd = (packet: PacketSessionEnd) => {\n\t    const {results} = packet\n\t    const all = results.length\n", "    const passed = results.filter((t) => t.cause === TestResultCause.PASSED).length\n\t    const skipped = results.filter((t) => t.cause === TestResultCause.SKIPPED).length\n\t    const cancelled = results.filter((t) => t.cause === TestResultCause.CANCELLED).length\n\t    const failed = all - passed - skipped - cancelled\n\t    setOutput(\"success\", isTestSucceed(results))\n\t    setOutput(\"tests\", all)\n\t    setOutput(\"tests-passes\", passed)\n\t    setOutput(\"tests-failures\", failed)\n\t    setOutput(\"tests-skips\", skipped)\n\t    setOutput(\"tests-cancels\", cancelled)\n", "}\n"]}
{"filename": "src/outputs/pull-request/appender.ts", "chunked_list": ["import type {PacketSessionEnd} from \"../../packets\";\n\timport {\n\t    getExceptionString,\n\t    getFooter,\n\t    getHeader, getReportingMessage,\n\t    getRunningMessage,\n\t    getTestResultTable,\n\t    getTestSummary\n\t} from \"../messages\";\n\timport { upsertReport} from \"./writer\";\n", "import type {PacketScenamaticaError} from \"../../packets\";\n\timport type {GitHub} from \"@actions/github/lib/utils\";\n\tlet headerPrinted = false\n\tlet containsError = false\n\tlet outMessage = \"\"\n\texport interface PullRequestInfo {\n\t    octokit: InstanceType<typeof GitHub>;\n\t    owner: string;\n\t    repository: string;\n\t    number: number;\n", "}\n\texport const reportError = (packet: PacketScenamaticaError) => {\n\t    const {exception, message, stackTrace} = packet\n\t    appendHeaderIfNotPrinted()\n\t    outMessage += getExceptionString(exception, message, stackTrace)\n\t    containsError = true\n\t}\n\texport const reportRunning = () => {\n\t    appendHeaderIfNotPrinted()\n\t    outMessage += getRunningMessage()\n", "}\n\texport const reportSessionEnd = (packet: PacketSessionEnd) => {\n\t    const {results, finishedAt, startedAt} = packet\n\t    appendHeaderIfNotPrinted()\n\t    outMessage += `${getTestSummary(results, startedAt, finishedAt)}\n\t        ${getTestResultTable(results, true)}\n\t    `\n\t}\n\tconst appendHeaderIfNotPrinted = () => {\n\t    if (!headerPrinted) {\n", "        outMessage += `${getHeader(false)}`\n\t        headerPrinted = true\n\t    }\n\t}\n\texport const publishPRComment = async (runData: PullRequestInfo) => {\n\t    if (containsError)\n\t        outMessage += getReportingMessage()\n\t    outMessage += getFooter()\n\t    await upsertReport(\n\t        runData.octokit,\n", "        runData.owner,\n\t        runData.repository,\n\t        runData.number,\n\t        outMessage\n\t    )\n\t    outMessage = \"\"\n\t    containsError = false\n\t    headerPrinted = false\n\t}\n"]}
{"filename": "src/outputs/pull-request/writer.ts", "chunked_list": ["import type {IssueComment, Maybe, Repository} from \"@octokit/graphql-schema\";\n\timport type {GitHub} from \"@actions/github/lib/utils\";\n\tconst COMMENT_IDENTIFIER = \"<!-- ### Scenamatica plugin analysis report ### -->\";\n\tconst COMMENT_AUTHOR_LOGIN = \"github-actions\"\n\texport const findFirstReportComment = async (\n\t    octokit: InstanceType<typeof GitHub>,\n\t    owner: string,\n\t    repo: string,\n\t    number: number\n\t): Promise<IssueComment | undefined> => {\n", "    const query = `\n\t        query ($repo: String!, $owner: String!, $number: Int!) {\n\t            repository(name: $repo, owner: $owner) {\n\t                pullRequest(number: $number) {\n\t                    comments(first: 25) {\n\t                        nodes {\n\t                            id\n\t                            author {\n\t                                login\n\t                            }\n", "                            body\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    `\n\t    const response = await octokit.graphql<{repository: Repository}>(\n\t        query,\n\t        {\n", "            repo,\n\t            owner,\n\t            number\n\t        }\n\t    )\n\t    if (!response.repository.pullRequest) {\n\t        return undefined\n\t    }\n\t    const comment = response.repository.pullRequest.comments.nodes?.find(isScenamaticaReport)\n\t    return comment ?? undefined\n", "}\n\texport const upsertReport = async (\n\t    octokit: InstanceType<typeof GitHub>,\n\t    owner: string,\n\t    repo: string,\n\t    number: number,\n\t    report: string\n\t) => {\n\t    const comment = await findFirstReportComment(octokit, owner, repo, number)\n\t    await (comment ? updateOldComment(octokit, owner, repo, comment.id, report) : postNewComment(octokit, owner, repo, number, report));\n", "}\n\tconst postNewComment = async (octokit: InstanceType<typeof GitHub>,\n\t                              owner: string,\n\t                              repo: string,\n\t                              number: number,\n\t                              body: string\n\t) => {\n\t    const fullBody = `${COMMENT_IDENTIFIER} \\n${body}`\n\t    await octokit.issues.createComment({\n\t        owner,\n", "        repo,\n\t        issue_number: number,\n\t        body: fullBody\n\t    })\n\t}\n\tconst updateOldComment = async (octokit: InstanceType<typeof GitHub>,\n\t                                owner: string,\n\t                                repo: string,\n\t                                commentId: string,\n\t                                body: string\n", ") => {\n\t    const fullBody = `${COMMENT_IDENTIFIER} \\n${body}`\n\t    const query = `\n\t        mutation ($input: UpdateIssueCommentInput!) {\n\t            updateIssueComment(input: $input) {\n\t                issueComment {\n\t                    id\n\t                    body\n\t                }\n\t            }\n", "        }\n\t    `\n\t    await octokit.graphql(\n\t        query,\n\t        {\n\t            input: {\n\t                id: commentId,\n\t                body: fullBody\n\t            }\n\t        })\n", "}\n\tconst isScenamaticaReport = (comment: Maybe<IssueComment>) => {\n\t    if (!comment) {\n\t        return false;\n\t    }\n\t    return comment.author?.login === COMMENT_AUTHOR_LOGIN\n\t        && comment.body.includes(COMMENT_IDENTIFIER);\n\t}\n"]}
{"filename": "src/server/deployer.ts", "chunked_list": ["import * as tc from \"@actions/tool-cache\"\n\timport * as cache from \"@actions/cache\"\n\timport * as io from \"@actions/io\"\n\timport * as core from \"@actions/core\"\n\timport path from \"node:path\"\n\timport * as fs from \"node:fs\"\n\timport * as yaml from \"js-yaml\"\n\timport { exec } from \"@actions/exec\"\n\timport fetch from \"node-fetch\"\n\timport {startServerOnly} from \"./controller\";\n", "import {info} from \"@actions/core\";\n\timport {compare} from \"compare-versions\";\n\tconst PAPER_NAME = \"paper.jar\"\n\tconst PAPER_VERSION_URL = \"https://papermc.io/api/v2/projects/paper/versions/{version}/\"\n\tconst PAPER_DOWNLOAD_URL = `${PAPER_VERSION_URL}/builds/{build}/downloads/paper-{version}-{build}.jar`\n\tconst SCENAMATICA_URL = \"https://github.com/TeamKun/Scenamatica/releases/download/v{version}/Scenamatica-{version}.jar\"\n\tconst JAVA_FETCH_URL =\n\t    \"https://api.azul.com/zulu/download/community/v1.0/bundles/?os={os}&arch={arch}&ext={ext}&java_version={version}&type=jdk\"\n\tconst genCacheKey = (javaVersion: string, mcVersion: string, scenamaticaVersion: string) => {\n\t    return `server-${mcVersion}-scenamatica-v${scenamaticaVersion}@java-${javaVersion}`\n", "}\n\tconst restoreCache = async (\n\t    dir: string,\n\t    javaVersion: string,\n\t    mcVersion: string,\n\t    scenamaticaVersion: string,\n\t) => {\n\t    const cacheKey = genCacheKey(javaVersion, mcVersion, scenamaticaVersion)\n\t    info(`Checking cache for ${cacheKey}`)\n\t    const cachedKey = await cache.restoreCache([dir], cacheKey)\n", "    return cachedKey === cacheKey\n\t}\n\tconst retrieveLatestPaperBuildFor = async (mcVersion: string): Promise<string> => {\n\t    const url = PAPER_VERSION_URL.replace(/\\{version}/g, mcVersion)\n\t    const response = await fetch(url)\n\t    const json = (await response.json()) as { builds: string[] }\n\t    return json.builds[json.builds.length - 1] // 最新のビルドを返す\n\t}\n\tconst downloadLatestPaper = async (destDir: string, mcVersion: string) => {\n\t    info(`Retrieving latest Paper build for ${mcVersion}`)\n", "    const build = await retrieveLatestPaperBuildFor(mcVersion)\n\t    info(`Retrieved latest Paper build for ${mcVersion}: The latest build is ${build}`)\n\t    const url = PAPER_DOWNLOAD_URL\n\t        .replace(/\\{version}/g, mcVersion)\n\t        .replace(/\\{build}/g, build)\n\t    info(`Downloading Paper ${mcVersion} build ${build} from ${url}`)\n\t    await io.mkdirP(destDir)\n\t    const dest = await tc.downloadTool(url, path.join(destDir, \"paper.jar\"))\n\t    // permission がないと起動できないので、chmod で付与する\n\t    const os = process.platform === \"win32\" ? \"windows\" : \"unix\"\n", "    await (os === \"unix\" ? exec(\"chmod\", [\"+x\", dest]) : exec(\"icacls\", [dest, \"/grant\", \"Everyone:(F)\"]));\n\t    info(`Downloaded Paper ${mcVersion} build ${build} to ${dest}`)\n\t    return build\n\t}\n\tconst writeEula = async (dir: string) => {\n\t    const eulaPath = path.join(dir, \"eula.txt\")\n\t    const eulaContent = \"eula=true\\n\"\n\t    await fs.promises.writeFile(eulaPath, eulaContent)\n\t    info(`Wrote eula.txt to ${eulaPath}`)\n\t}\n", "const downloadScenamatica = async (destDir: string, version: string) => {\n\t    const url = SCENAMATICA_URL.replace(/\\{version}/g, version)\n\t    info(`Downloading Scenamatica ${version} from ${url}`)\n\t    const destPath = await tc.downloadTool(url, path.join(destDir, `Scenamatica-${version}.jar`))\n\t    info(`Downloaded Scenamatica ${version} to ${destPath}`)\n\t    return destPath\n\t}\n\tconst fetchLatestJavaLinkFor = async (version: string) => {\n\t    const processPlatform = process.platform\n\t    const platform = processPlatform === \"win32\" ? \"windows\" : processPlatform === \"darwin\" ? \"macos\" : \"linux\"\n", "    const arch = process.arch === \"x64\" ? \"x86_64\" : \"x86\"\n\t    const ext = platform === \"windows\" ? \"zip\" : \"tar.gz\"\n\t    const url = JAVA_FETCH_URL.replace(/\\{os}/g, platform)\n\t        .replace(/\\{arch}/g, arch)\n\t        .replace(/\\{ext}/g, ext)\n\t        .replace(/\\{version}/g, version)\n\t    const response = await fetch(url)\n\t    const json = (await response.json()) as Array<{ url: string }>\n\t    return {\n\t        url: json[0].url,\n", "        isTar: ext === \"tar.gz\",\n\t    }\n\t}\n\tconst downloadJava = async (destBaseDir: string, version: string) => {\n\t    info(`Retrieving latest Java build for ${version}`)\n\t    const { url, isTar } = await fetchLatestJavaLinkFor(version) // 最新の Java ビルドの URL を取得\n\t    info(`Retrieved latest Java build for ${version}: ${url}`)\n\t    const dest = await tc.downloadTool(url, path.join(destBaseDir, \"java-package\"))\n\t    info(`Downloaded Java ${version} to ${dest}`)\n\t    const destDir = path.join(destBaseDir, \"java\")\n", "    info(\"Extracting...\")\n\t    await (isTar ? tc.extractTar(dest, destDir) : tc.extractZip(dest, destDir))\n\t    core.addPath(path.join(destDir, \"bin\"))\n\t    info(`Installed Java ${version}`)\n\t}\n\tconst isJavaInstalled = async () => {\n\t    try {\n\t        await exec(\"java\", [\"-version\"])\n\t        return true\n\t    } catch {\n", "        return false\n\t    }\n\t}\n\texport const deployServer = async (\n\t    dir: string,\n\t    javaVersion: string,\n\t    mcVersion: string,\n\t    scenamaticaVersion: string,\n\t): Promise<string> => {\n\t    const pluginDir = path.join(dir, \"plugins\")\n", "    // キャッシュの復元\n\t    const cached = await restoreCache(dir, javaVersion, mcVersion, scenamaticaVersion)\n\t    if (cached)\n\t        return new Promise<string>((resolve) => {\n\t            resolve(PAPER_NAME)\n\t        })\n\t    // キャッシュがないので Paper をビルドする。\n\t    info(\"Building server...\")\n\t    // Java のダウンロード\n\t    if (!(await isJavaInstalled())) await downloadJava(dir, javaVersion)\n", "    // Paper のダウンロード\n\t    await io.mkdirP(pluginDir)\n\t    await downloadLatestPaper(dir, mcVersion)\n\t    await downloadScenamatica(pluginDir, scenamaticaVersion)\n\t    await writeEula(dir) // eula.txt を書き込まないと Paper が起動Vしない\n\t    await startServerOnly(dir, PAPER_NAME)\n\t    await initScenamaticaConfig(path.join(pluginDir, \"Scenamatica\"), scenamaticaVersion)\n\t    await cache.saveCache([dir], genCacheKey(javaVersion, mcVersion, scenamaticaVersion))\n\t    return PAPER_NAME\n\t}\n", "export const deployPlugin = async (serverDir: string, pluginFile: string) => {\n\t    const pluginDir = path.join(serverDir, \"plugins\")\n\t    await io.mkdirP(pluginDir)\n\t    await io.cp(pluginFile, pluginDir)\n\t}\n\tconst initScenamaticaConfig = async (configDir: string, scenamaticaVersion: string) => {\n\t    const configPath = path.join(configDir, \"config.yml\")\n\t    const configData = yaml.load(await fs.promises.readFile(configPath, \"utf8\")) as {\n\t        interfaces?: {\n\t            raw: boolean\n", "        },\n\t        reporting?: {  // v0.6.1 から。\n\t            raw: boolean\n\t        }\n\t    }\n\t    if (compare(scenamaticaVersion, \"0.7.0\", \">=\")) {\n\t        configData[\"reporting\"]![\"raw\"] = true\n\t    } else {\n\t        configData[\"interfaces\"]![\"raw\"] = true\n\t    }\n", "    await fs.promises.writeFile(configPath, yaml.dump(configData))\n\t}\n"]}
{"filename": "src/server/controller.ts", "chunked_list": ["import {isNoScenamatica} from \"../utils.js\"\n\timport {deployPlugin} from \"./deployer.js\"\n\timport {kill, onDataReceived} from \"./client\";\n\timport type {ChildProcess} from \"node:child_process\";\n\timport {spawn} from \"node:child_process\";\n\timport type {Writable} from \"node:stream\";\n\timport * as fs from \"node:fs\";\n\timport path from \"node:path\";\n\timport {info, setFailed, warning} from \"@actions/core\";\n\timport {printFooter} from \"../outputs/summary\";\n", "let serverProcess: ChildProcess | undefined\n\tlet serverStdin: Writable | undefined\n\tconst genArgs = (executable: string, args: string[]) => {\n\t    return [\n\t        ...args,\n\t        \"-jar\",\n\t        executable,\n\t        \"nogui\"\n\t    ]\n\t}\n", "const createServerProcess = (workDir: string, executable: string, args: string[] = []) => {\n\t    const cp = spawn(\n\t        \"java\",\n\t        genArgs(executable, args),\n\t        {\n\t            cwd: workDir\n\t        }\n\t    )\n\t    serverStdin = cp.stdin\n\t    serverProcess = cp\n", "    return cp\n\t}\n\texport const startServerOnly = async (workDir: string, executable: string, args: string[] = []) => {\n\t    info(`Starting server with executable ${executable} and args ${args.join(\" \")}`)\n\t    const cp = createServerProcess(workDir, executable, args)\n\t    cp.stdout.on(\"data\", (data: Buffer) => {\n\t        const line = data.toString(\"utf8\")\n\t        if (line.includes(\"Done\") && line.includes(\"For help, type \\\"help\\\"\"))\n\t            serverStdin?.write(\"stop\\n\")\n\t        if (line.endsWith(\"\\n\"))\n", "            info(line.slice(0, - 1))\n\t        else\n\t            info(line)\n\t    })\n\t    return new Promise<number>((resolve, reject) => {\n\t        cp.on(\"exit\", (code) => {\n\t            if (code === 0)\n\t                resolve(code)\n\t            else\n\t                reject(code)\n", "        })\n\t    })\n\t}\n\texport const stopServer = () => {\n\t    if (!serverStdin || !serverProcess)\n\t        return\n\t    info(\"Stopping server...\")\n\t    serverStdin.write(\"stop\\n\")\n\t    setTimeout(() => {\n\t        if (serverProcess!.killed)\n", "            return\n\t        warning(\"Server didn't stop in time, killing it...\")\n\t        serverProcess?.kill(\"SIGKILL\")\n\t    }, 1000 * 20)\n\t}\n\texport const startTests = async (serverDir: string, executable: string, pluginFile: string) => {\n\t    info(`Starting tests of plugin ${pluginFile}.`)\n\t    if (isNoScenamatica())\n\t        await removeScenamatica(serverDir)\n\t    await deployPlugin(serverDir, pluginFile)\n", "    const cp = createServerProcess(serverDir, executable)\n\t    cp.stdout.on(\"data\", async (data: Buffer) => {\n\t        await onDataReceived(data.toString(\"utf8\"))\n\t    })\n\t}\n\tconst removeScenamatica = async (serverDir: string) => {\n\t    info(\"Removing Scenamatica from server...\")\n\t    const pluginDir = path.join(serverDir, \"plugins\")\n\t    const files = await fs.promises.readdir(pluginDir)\n\t    for (const file of files) {\n", "        if (file.includes(\"Scenamatica\") && file.endsWith(\".jar\")) {\n\t            info(`Removing ${file}...`)\n\t            await fs.promises.rm(path.join(pluginDir, file))\n\t        }\n\t    }\n\t}\n\texport const endTests = async (succeed: boolean) => {\n\t    info(\"Ending tests, shutting down server...\")\n\t    kill()\n\t    stopServer()\n", "    await printFooter()\n\t    let code: number\n\t    if (succeed) {\n\t        info(\"Tests succeeded\")\n\t        code = 0\n\t    } else {\n\t        setFailed(\"Tests failed\")\n\t        code = 1\n\t    }\n\t    process.exit(code)\n", "}\n"]}
{"filename": "src/server/client.ts", "chunked_list": ["import type {\n\t    PacketScenamaticaError,\n\t    PacketSessionEnd,\n\t    PacketSessionStart,\n\t    PacketTestEnd,\n\t    PacketTestStart\n\t} from \"../packets.js\"\n\timport {parsePacket} from \"../packets.js\"\n\timport {error, info} from \"@actions/core\";\n\timport {\n", "    publishRunning,\n\t    publishScenamaticaError,\n\t    publishSessionEnd\n\t} from \"../outputs/publisher\";\n\timport {logSessionEnd, logSessionStart, logTestEnd, logTestStart} from \"../logging\";\n\timport type {PullRequestInfo} from \"../outputs/pull-request/appender\";\n\timport {endTests} from \"./controller\";\n\timport {isTestSucceed} from \"../utils\";\n\timport {publishPRComment} from \"../outputs/pull-request/appender\";\n\tlet incomingBuffer: string | undefined\n", "let alive = true\n\tlet prInfo: PullRequestInfo | undefined\n\texport const initPullRequest = (pi: PullRequestInfo) => {\n\t    prInfo = pi\n\t    publishRunning(pi)\n\t}\n\texport const onDataReceived = async (chunkMessage: string) => {\n\t    incomingBuffer = incomingBuffer ? incomingBuffer + chunkMessage : chunkMessage\n\t    while (incomingBuffer && incomingBuffer.includes(\"\\n\")) {\n\t        const messages: string[] = incomingBuffer.split(\"\\n\")\n", "        incomingBuffer = messages.slice(1).join(\"\\n\") || undefined\n\t        if (!await processPacket(messages[0]))\n\t            info(messages[0])\n\t    }\n\t}\n\texport const kill = () => {\n\t    alive = false\n\t}\n\tconst processPacket = async (msg: string) => {\n\t    if (!alive) {\n", "        return false\n\t    }\n\t    let packet\n\t    try {\n\t        packet = parsePacket(msg)\n\t    } catch {\n\t        return false\n\t    }\n\t    if (!packet) {\n\t        return false\n", "    }\n\t    switch (packet.genre) {\n\t        case \"session\": {\n\t            await processSessionPackets(packet as PacketSessionEnd | PacketSessionStart)\n\t            break\n\t        }\n\t        case \"test\": {\n\t            processTestsPacket(packet as PacketTestEnd | PacketTestStart)\n\t            break\n\t        }\n", "        case \"general\": {\n\t            if (packet.type !== \"error\") {\n\t                return false // general ジャンルは、エラーのみしかない\n\t            }\n\t            const errorPacket = packet as PacketScenamaticaError\n\t            error(`An error occurred in Scenamatica: ${errorPacket.exception}: ${errorPacket.message}`)\n\t            await publishScenamaticaError(errorPacket)\n\t            if (prInfo)\n\t                await publishPRComment(prInfo)\n\t            await endTests(false)\n", "            break\n\t        }\n\t    }\n\t    return true\n\t}\n\tconst processTestsPacket = (packet: PacketTestEnd | PacketTestStart) => {\n\t    switch (packet.type) {\n\t        case \"start\": {\n\t            logTestStart(packet.scenario)\n\t            break\n", "        }\n\t        case \"end\": {\n\t            const endPacket = packet as PacketTestEnd\n\t            logTestEnd(\n\t                packet.scenario.name,\n\t                endPacket.state,\n\t                endPacket.cause,\n\t                endPacket.startedAt,\n\t                endPacket.finishedAt\n\t            )\n", "            break\n\t        }\n\t    }\n\t}\n\tconst processSessionPackets = async (packet: PacketSessionEnd | PacketSessionStart) => {\n\t    switch (packet.type) {\n\t        case \"start\": {\n\t            const sessionStart = packet as PacketSessionStart\n\t            logSessionStart(packet.startedAt, sessionStart.tests.length)\n\t            break\n", "        }\n\t        case \"end\": {\n\t            const sessionEnd = packet as PacketSessionEnd\n\t            logSessionEnd(sessionEnd)\n\t            await publishSessionEnd(sessionEnd)\n\t            if (prInfo)\n\t                await publishPRComment(prInfo)\n\t            await endTests(isTestSucceed(sessionEnd.results))\n\t            break\n\t        }\n", "    }\n\t}\n"]}
