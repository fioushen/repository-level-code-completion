{"filename": "src/index.ts", "chunked_list": ["export * from './decorators/active-user.decorator';\n\texport * from './decorators/auth.decorator';\n\texport * from './decorators/roles.decorator';\n\texport * from './enums/auth-type.enum';\n\texport * from './enums/token-type.enum';\n\texport * from './events/logged-in.event';\n\texport * from './events/logged-out.event';\n\texport * from './hashers/bcrypt.hasher';\n\texport * from './iam.module';\n\texport * from './interfaces/active-user.interface';\n", "export * from './interfaces/auth-service.interface';\n\texport * from './interfaces/login.interface';\n\texport * from './interfaces/module-options.interface';\n\texport * from './interfaces/token.interface';\n\texport * from './interfaces/user.interface';\n\texport * from './processors/login.processor';\n"]}
{"filename": "src/iam.module.ts", "chunked_list": ["import { Module } from '@nestjs/common';\n\timport { ConfigModule, ConfigService } from '@nestjs/config';\n\timport { APP_GUARD } from '@nestjs/core';\n\timport { CqrsModule } from '@nestjs/cqrs';\n\timport { JwtModule } from '@nestjs/jwt';\n\timport iamConfig from './configs/iam.config';\n\timport { AuthController } from './controllers/auth.controller';\n\timport { AccessTokenGenerator } from './generators/access-token.generator';\n\timport { PasswordlessLoginTokenGenerator } from './generators/passwordless-login-token.generator';\n\timport { RefreshTokenGenerator } from './generators/refresh-token.generator';\n", "import { AccessTokenGuard } from './guards/access-token.guard';\n\timport { AuthGuard } from './guards/auth.guard';\n\timport { NoneGuard } from './guards/none.guard';\n\timport { RolesGuard } from './guards/roles.guard';\n\timport { BcryptHasher } from './hashers/bcrypt.hasher';\n\timport { ConfigurableModuleClass } from './iam.module-definition';\n\timport { LoginProcessor } from './processors/login.processor';\n\timport { LogoutProcessor } from './processors/logout.processor';\n\timport { PasswordlessLoginRequestProcessor } from './processors/passwordless-login-request.processor';\n\t@Module({\n", "  imports: [\n\t    ConfigModule.forFeature(iamConfig),\n\t    CqrsModule,\n\t    JwtModule.registerAsync({\n\t      imports: [ConfigModule],\n\t      useFactory: async (config: ConfigService) => ({\n\t        secret: config.get('iam.jwt.secret'),\n\t        signOptions: {\n\t          audience: config.get('iam.jwt.audience'),\n\t          issuer: config.get('iam.jwt.issuer'),\n", "        },\n\t      }),\n\t      inject: [ConfigService],\n\t    }),\n\t  ],\n\t  providers: [\n\t    AccessTokenGenerator,\n\t    AccessTokenGuard,\n\t    AuthGuard,\n\t    BcryptHasher,\n", "    LoginProcessor,\n\t    LogoutProcessor,\n\t    NoneGuard,\n\t    PasswordlessLoginRequestProcessor,\n\t    PasswordlessLoginTokenGenerator,\n\t    RefreshTokenGenerator,\n\t    RolesGuard,\n\t    {\n\t      provide: APP_GUARD,\n\t      useClass: AuthGuard,\n", "    },\n\t    {\n\t      provide: APP_GUARD,\n\t      useClass: RolesGuard,\n\t    },\n\t  ],\n\t  exports: [BcryptHasher, LoginProcessor],\n\t  controllers: [AuthController],\n\t})\n\texport class IamModule extends ConfigurableModuleClass {}\n"]}
{"filename": "src/iam.module-definition.ts", "chunked_list": ["import { ConfigurableModuleBuilder } from '@nestjs/common';\n\timport { IModuleOptions } from './interfaces/module-options.interface';\n\texport const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =\n\t  new ConfigurableModuleBuilder<IModuleOptions>()\n\t    .setClassMethodName('register')\n\t    .build();\n"]}
{"filename": "src/processors/login.processor.ts", "chunked_list": ["import { Inject, Injectable } from '@nestjs/common';\n\timport { ConfigType } from '@nestjs/config';\n\timport { Response } from 'express';\n\timport iamConfig from '../configs/iam.config';\n\timport { TokenType } from '../enums/token-type.enum';\n\timport { AccessTokenGenerator } from '../generators/access-token.generator';\n\timport { RefreshTokenGenerator } from '../generators/refresh-token.generator';\n\timport { MODULE_OPTIONS_TOKEN } from '../iam.module-definition';\n\timport { ILogin } from '../interfaces/login.interface';\n\timport { IModuleOptions } from '../interfaces/module-options.interface';\n", "import { IUser } from '../interfaces/user.interface';\n\timport { TokenModel } from '../models/token.model';\n\t@Injectable()\n\texport class LoginProcessor {\n\t  public constructor(\n\t    private readonly accessTokenGenerator: AccessTokenGenerator,\n\t    private readonly refreshTokenGenerator: RefreshTokenGenerator,\n\t    @Inject(MODULE_OPTIONS_TOKEN)\n\t    private readonly moduleOptions: IModuleOptions,\n\t    @Inject(iamConfig.KEY)\n", "    private readonly config: ConfigType<typeof iamConfig>,\n\t  ) {}\n\t  public async process(user: IUser, response: Response): Promise<ILogin> {\n\t    const accessToken = await this.accessTokenGenerator.generate(user);\n\t    const refreshToken = await this.refreshTokenGenerator.generate(user);\n\t    const login = {\n\t      accessToken: accessToken.jwt,\n\t      refreshToken: refreshToken.jwt,\n\t    };\n\t    await this.moduleOptions.authService.saveToken(\n", "      new TokenModel(\n\t        refreshToken.id,\n\t        TokenType.RefreshToken,\n\t        user.getId(),\n\t        refreshToken.expiresAt,\n\t      ),\n\t    );\n\t    response.cookie(TokenType.AccessToken, accessToken.jwt, {\n\t      secure: this.config.cookie.secure,\n\t      httpOnly: this.config.cookie.httpOnly,\n", "      sameSite: this.config.cookie.sameSite,\n\t      expires: accessToken.expiresAt,\n\t    });\n\t    response.cookie(TokenType.RefreshToken, refreshToken.jwt, {\n\t      secure: this.config.cookie.secure,\n\t      httpOnly: this.config.cookie.httpOnly,\n\t      sameSite: this.config.cookie.sameSite,\n\t      expires: refreshToken.expiresAt,\n\t      path: `${this.config.routePathPrefix}/auth`,\n\t    });\n", "    return login;\n\t  }\n\t}\n"]}
{"filename": "src/processors/passwordless-login-request.processor.ts", "chunked_list": ["import { Inject, Injectable } from '@nestjs/common';\n\timport { ConfigType } from '@nestjs/config';\n\timport { randomUUID } from 'crypto';\n\timport { Response } from 'express';\n\timport iamConfig from '../configs/iam.config';\n\timport { TokenType } from '../enums/token-type.enum';\n\timport { PasswordlessLoginTokenGenerator } from '../generators/passwordless-login-token.generator';\n\timport { MODULE_OPTIONS_TOKEN } from '../iam.module-definition';\n\timport { IModuleOptions } from '../interfaces/module-options.interface';\n\timport { IUser } from '../interfaces/user.interface';\n", "@Injectable()\n\texport class PasswordlessLoginRequestProcessor {\n\t  public constructor(\n\t    private readonly passwordlessLoginTokenGenerator: PasswordlessLoginTokenGenerator,\n\t    @Inject(MODULE_OPTIONS_TOKEN)\n\t    private readonly moduleOptions: IModuleOptions,\n\t    @Inject(iamConfig.KEY)\n\t    private readonly config: ConfigType<typeof iamConfig>,\n\t  ) {}\n\t  public async process(user: IUser, response: Response): Promise<void> {\n", "    const requestId = randomUUID();\n\t    const passwordlessLoginToken =\n\t      await this.passwordlessLoginTokenGenerator.generate(user, requestId);\n\t    await this.moduleOptions.authService.saveToken(passwordlessLoginToken);\n\t    response.cookie(TokenType.PasswordlessLoginToken, requestId, {\n\t      secure: this.config.cookie.secure,\n\t      httpOnly: this.config.cookie.httpOnly,\n\t      sameSite: this.config.cookie.sameSite,\n\t      expires: passwordlessLoginToken.getExpiresAt(),\n\t      path: `${this.config.routePathPrefix}/auth`,\n", "    });\n\t  }\n\t}\n"]}
{"filename": "src/processors/logout.processor.ts", "chunked_list": ["import { Inject, Injectable } from '@nestjs/common';\n\timport { ConfigType } from '@nestjs/config';\n\timport { JwtService } from '@nestjs/jwt';\n\timport { Request, Response } from 'express';\n\timport { IRefreshTokenJwtPayload } from 'src/interfaces/refresh-token-jwt-payload.interface';\n\timport iamConfig from '../configs/iam.config';\n\timport { TokenType } from '../enums/token-type.enum';\n\timport { MODULE_OPTIONS_TOKEN } from '../iam.module-definition';\n\timport { IModuleOptions } from '../interfaces/module-options.interface';\n\t@Injectable()\n", "export class LogoutProcessor {\n\t  public constructor(\n\t    private readonly jwtService: JwtService,\n\t    @Inject(MODULE_OPTIONS_TOKEN)\n\t    private readonly moduleOptions: IModuleOptions,\n\t    @Inject(iamConfig.KEY)\n\t    private readonly config: ConfigType<typeof iamConfig>,\n\t  ) {}\n\t  public async process(request: Request, response: Response): Promise<void> {\n\t    try {\n", "      const refreshTokenJwtPayload: IRefreshTokenJwtPayload =\n\t        await this.jwtService.verifyAsync(\n\t          request.cookies[TokenType.RefreshToken],\n\t        );\n\t      await this.moduleOptions.authService.removeToken(\n\t        refreshTokenJwtPayload.id,\n\t      );\n\t    } catch {}\n\t    response.clearCookie(TokenType.AccessToken);\n\t    response.clearCookie(TokenType.RefreshToken, {\n", "      path: `${this.config.routePathPrefix}/auth`,\n\t    });\n\t  }\n\t}\n"]}
{"filename": "src/dtos/login-request.dto.ts", "chunked_list": ["import { ApiProperty } from '@nestjs/swagger';\n\timport { IsString } from 'class-validator';\n\texport class LoginRequestDto {\n\t  @IsString()\n\t  @ApiProperty()\n\t  username: string;\n\t  @IsString()\n\t  @ApiProperty()\n\t  password: string;\n\t}\n"]}
{"filename": "src/dtos/login-response.dto.ts", "chunked_list": ["import { ApiProperty } from '@nestjs/swagger';\n\texport class LoginResponseDto {\n\t  @ApiProperty()\n\t  public readonly accessToken: string;\n\t  @ApiProperty()\n\t  public readonly refreshToken: string;\n\t}\n"]}
{"filename": "src/dtos/passwordless-login-request-request.dto.ts", "chunked_list": ["import { ApiProperty } from '@nestjs/swagger';\n\timport { IsString } from 'class-validator';\n\texport class PasswordlessLoginRequestRequestDto {\n\t  @IsString()\n\t  @ApiProperty()\n\t  username: string;\n\t}\n"]}
{"filename": "src/configs/iam.config.ts", "chunked_list": ["import { registerAs } from '@nestjs/config';\n\timport * as Joi from 'joi';\n\texport default registerAs('iam', () => {\n\t  const config = {\n\t    routePathPrefix: process.env.IAM_ROUTE_PATH_PREFIX || '',\n\t    auth: {\n\t      methods: (process.env.IAM_AUTH_METHODS || '').split(','),\n\t      passwordless: {\n\t        tokenTtl: process.env.IAM_AUTH_PASSWORDLESS_TOKEN_TTL,\n\t      },\n", "    },\n\t    cookie: {\n\t      httpOnly: process.env.IAM_COOKIE_HTTP_ONLY,\n\t      sameSite: process.env.IAM_COOKIE_SAME_SITE,\n\t      secure: process.env.IAM_COOKIE_SECURE,\n\t    },\n\t    jwt: {\n\t      accessTokenTtl: process.env.IAM_JWT_ACCESS_TOKEN_TTL,\n\t      audience: process.env.IAM_JWT_TOKEN_AUDIENCE,\n\t      issuer: process.env.IAM_JWT_TOKEN_ISSUER,\n", "      refreshTokenTtl: process.env.IAM_JWT_REFRESH_TOKEN_TTL,\n\t      secret: process.env.IAM_JWT_SECRET,\n\t    },\n\t  };\n\t  const validationResult = Joi.object({\n\t    auth: Joi.object({\n\t      methods: Joi.array()\n\t        .items(Joi.string().valid('basic', 'passwordless'))\n\t        .min(1)\n\t        .required()\n", "        .messages({\n\t          '*': 'Environment variable IAM_AUTH_METHODS is required (e.g. basic,passwordless (comma separated))',\n\t        }),\n\t      passwordless: Joi.any().when('methods', {\n\t        is: Joi.array().items().has('passwordless'),\n\t        then: Joi.object({\n\t          tokenTtl: Joi.number().positive().required().messages({\n\t            '*': 'Environment variable IAM_AUTH_PASSWORDLESS_TOKEN_TTL is required (e.g. 300 for 5 minutes)',\n\t          }),\n\t        }),\n", "      }),\n\t    }),\n\t    cookie: Joi.object({\n\t      httpOnly: Joi.valid('1', '0').required().messages({\n\t        '*': 'Environment variable IAM_COOKIE_HTTP_ONLY is required (1 or 0)',\n\t      }),\n\t      sameSite: Joi.valid('lax', 'strict', 'none').required().messages({\n\t        '*': 'Environment variable IAM_COOKIE_SAME_SITE is required (lax, strict or none)',\n\t      }),\n\t      secure: Joi.valid('1', '0').required().messages({\n", "        '*': 'Environment variable IAM_COOKIE_SECURE is required (1 or 0)',\n\t      }),\n\t    }),\n\t    jwt: Joi.object({\n\t      accessTokenTtl: Joi.number().positive().required().messages({\n\t        '*': 'Environment variable IAM_JWT_ACCESS_TOKEN_TTL is required (e.g. 3600 for 1 hour)',\n\t      }),\n\t      audience: Joi.string().required().messages({\n\t        '*': 'Environment variable IAM_JWT_TOKEN_AUDIENCE is required (e.g. localhost)',\n\t      }),\n", "      issuer: Joi.string().required().messages({\n\t        '*': 'Environment variable IAM_JWT_TOKEN_ISSUER is required (e.g. localhost)',\n\t      }),\n\t      refreshTokenTtl: Joi.number().positive().required().messages({\n\t        '*': 'Environment variable IAM_JWT_REFRESH_TOKEN_TTL is required (e.g. 86400 for 1 day)',\n\t      }),\n\t      secret: Joi.string().required().messages({\n\t        '*': 'Environment variable IAM_JWT_SECRET is required (e.g. superSecretString)',\n\t      }),\n\t    }),\n", "    routePathPrefix: Joi.string().allow('').optional().messages({\n\t      '*': 'Environment variable IAM_ROUTE_PATH_PREFIX must be a string (e.g. /api)',\n\t    }),\n\t  }).validate(config, { abortEarly: false });\n\t  if (validationResult.error) {\n\t    throw validationResult.error;\n\t  }\n\t  return {\n\t    ...config,\n\t    auth: {\n", "      ...config.auth,\n\t      passwordless: {\n\t        ...config.auth.passwordless,\n\t        tokenTtl: config.auth.passwordless.tokenTtl\n\t          ? parseInt(config.auth.passwordless.tokenTtl, 10)\n\t          : undefined,\n\t      },\n\t    },\n\t    jwt: {\n\t      ...config.jwt,\n", "      accessTokenTtl: parseInt(config.jwt.accessTokenTtl, 10),\n\t      refreshTokenTtl: parseInt(config.jwt.refreshTokenTtl, 10),\n\t    },\n\t    cookie: {\n\t      httpOnly: config.cookie.httpOnly === '1',\n\t      sameSite: config.cookie.sameSite as 'lax' | 'strict' | 'none',\n\t      secure: config.cookie.secure === '1',\n\t    },\n\t  };\n\t});\n"]}
{"filename": "src/events/logged-in.event.ts", "chunked_list": ["export class LoggedInEvent {\n\t  constructor(public readonly userId: string) {}\n\t}\n"]}
{"filename": "src/events/logged-out.event.ts", "chunked_list": ["export class LoggedOutEvent {\n\t  constructor(public readonly userId: string) {}\n\t}\n"]}
{"filename": "src/constants/iam.constants.ts", "chunked_list": ["export const IAM_AUTH_TYPE_KEY = 'iamAuthType';\n\texport const IAM_REQUEST_USER_KEY = 'iamUser';\n\texport const IAM_ROLES_KEY = 'iamRoles';\n"]}
{"filename": "src/prompts/hash-password.prompt.ts", "chunked_list": ["#!/usr/bin/env node\n\timport { PromptObject, prompt } from 'prompts';\n\timport { BcryptHasher } from '../hashers/bcrypt.hasher';\n\t(async () => {\n\t  const questions: PromptObject[] = [\n\t    {\n\t      type: 'password',\n\t      name: 'username',\n\t      message: 'Type in the password you would like to hash:',\n\t    },\n", "  ];\n\t  await prompt(questions, {\n\t    onSubmit: async (_: string, answer: string) =>\n\t      console.log(await new BcryptHasher().hash(answer)),\n\t  });\n\t})();\n"]}
{"filename": "src/interfaces/user.interface.ts", "chunked_list": ["export interface IUser {\n\t  getId(): string;\n\t  getUsername(): string;\n\t  getPassword(): string;\n\t  getRoles(): string[];\n\t}\n"]}
{"filename": "src/interfaces/module-options.interface.ts", "chunked_list": ["import { IAuthService } from './auth-service.interface';\n\texport interface IModuleOptions {\n\t  authService: IAuthService;\n\t}\n"]}
{"filename": "src/interfaces/cookie.interface.ts", "chunked_list": ["export interface ICookie {\n\t  name: string;\n\t  value: string;\n\t  ttl: number;\n\t}\n"]}
{"filename": "src/interfaces/auth-service.interface.ts", "chunked_list": ["import { IToken } from './token.interface';\n\timport { IUser } from './user.interface';\n\texport interface IAuthService {\n\t  checkToken(id: string, type: string, requestId?: string): Promise<IToken>;\n\t  checkUser(username: string): Promise<IUser>;\n\t  getUser(id: string): Promise<IUser>;\n\t  removeToken(id: string): Promise<void>;\n\t  saveToken(token: IToken): Promise<void>;\n\t}\n"]}
{"filename": "src/interfaces/login.interface.ts", "chunked_list": ["export interface ILogin {\n\t  accessToken: string;\n\t  refreshToken: string;\n\t}\n"]}
{"filename": "src/interfaces/access-token.interface.ts", "chunked_list": ["export interface IAccessToken {\n\t  jwt: string;\n\t  expiresAt: Date;\n\t}\n"]}
{"filename": "src/interfaces/active-user.interface.ts", "chunked_list": ["export interface IActiveUser {\n\t  userId: string;\n\t  roles: string[];\n\t}\n"]}
{"filename": "src/interfaces/token.interface.ts", "chunked_list": ["export interface IToken {\n\t  getId(): string;\n\t  getRequestId(): string | undefined;\n\t  getUserId(): string;\n\t  getType(): string;\n\t  getExpiresAt(): Date;\n\t}\n"]}
{"filename": "src/interfaces/refresh-token-jwt-payload.interface.ts", "chunked_list": ["export interface IRefreshTokenJwtPayload {\n\t  id: string;\n\t  sub: string;\n\t  username: string;\n\t  roles: string[];\n\t}\n"]}
{"filename": "src/interfaces/hasher.interface.ts", "chunked_list": ["export interface IHasher {\n\t  hash(data: string | Buffer): Promise<string>;\n\t  compare(data: string | Buffer, encrypted: string): Promise<boolean>;\n\t}\n"]}
{"filename": "src/interfaces/refresh-token.interface.ts", "chunked_list": ["export interface IRefreshToken {\n\t  id: string;\n\t  jwt: string;\n\t  expiresAt: Date;\n\t}\n"]}
{"filename": "src/interfaces/access-token-jwt-payload.interface.ts", "chunked_list": ["export interface IAccessTokenJwtPayload {\n\t  sub: string;\n\t  username: string;\n\t  roles: string[];\n\t}\n"]}
{"filename": "src/generators/access-token.generator.ts", "chunked_list": ["import { Inject, Injectable } from '@nestjs/common';\n\timport { ConfigType } from '@nestjs/config';\n\timport { JwtService } from '@nestjs/jwt';\n\timport iamConfig from '../configs/iam.config';\n\timport { IAccessTokenJwtPayload } from '../interfaces/access-token-jwt-payload.interface';\n\timport { IAccessToken } from '../interfaces/access-token.interface';\n\timport { IUser } from '../interfaces/user.interface';\n\t@Injectable()\n\texport class AccessTokenGenerator {\n\t  constructor(\n", "    private readonly jwtService: JwtService,\n\t    @Inject(iamConfig.KEY)\n\t    private readonly config: ConfigType<typeof iamConfig>,\n\t  ) {}\n\t  async generate(user: IUser): Promise<IAccessToken> {\n\t    const ttl = this.config.jwt.accessTokenTtl;\n\t    const expiresAt = new Date();\n\t    expiresAt.setSeconds(expiresAt.getSeconds() + ttl);\n\t    return {\n\t      jwt: await this.jwtService.signAsync(\n", "        {\n\t          sub: user.getId(),\n\t          username: user.getUsername(),\n\t          roles: user.getRoles(),\n\t        } as IAccessTokenJwtPayload,\n\t        {\n\t          expiresIn: this.config.jwt.accessTokenTtl,\n\t        },\n\t      ),\n\t      expiresAt,\n", "    };\n\t  }\n\t}\n"]}
{"filename": "src/generators/refresh-token.generator.ts", "chunked_list": ["import { Inject, Injectable } from '@nestjs/common';\n\timport { ConfigType } from '@nestjs/config';\n\timport { JwtService } from '@nestjs/jwt';\n\timport { randomUUID } from 'crypto';\n\timport iamConfig from '../configs/iam.config';\n\timport { IRefreshTokenJwtPayload } from '../interfaces/refresh-token-jwt-payload.interface';\n\timport { IRefreshToken } from '../interfaces/refresh-token.interface';\n\timport { IUser } from '../interfaces/user.interface';\n\t@Injectable()\n\texport class RefreshTokenGenerator {\n", "  constructor(\n\t    private readonly jwtService: JwtService,\n\t    @Inject(iamConfig.KEY)\n\t    private readonly config: ConfigType<typeof iamConfig>,\n\t  ) {}\n\t  async generate(user: IUser): Promise<IRefreshToken> {\n\t    const id = randomUUID();\n\t    const ttl = this.config.jwt.refreshTokenTtl;\n\t    const expiresAt = new Date();\n\t    expiresAt.setSeconds(expiresAt.getSeconds() + ttl);\n", "    return {\n\t      id,\n\t      jwt: await this.jwtService.signAsync(\n\t        {\n\t          id,\n\t          sub: user.getId(),\n\t          username: user.getUsername(),\n\t          roles: user.getRoles(),\n\t        } as IRefreshTokenJwtPayload,\n\t        {\n", "          expiresIn: this.config.jwt.refreshTokenTtl,\n\t        },\n\t      ),\n\t      expiresAt,\n\t    };\n\t  }\n\t}\n"]}
{"filename": "src/generators/passwordless-login-token.generator.ts", "chunked_list": ["import { Inject, Injectable } from '@nestjs/common';\n\timport { ConfigType } from '@nestjs/config';\n\timport { randomUUID } from 'crypto';\n\timport iamConfig from '../configs/iam.config';\n\timport { TokenType } from '../enums/token-type.enum';\n\timport { IToken } from '../interfaces/token.interface';\n\timport { IUser } from '../interfaces/user.interface';\n\timport { TokenModel } from '../models/token.model';\n\t@Injectable()\n\texport class PasswordlessLoginTokenGenerator {\n", "  constructor(\n\t    @Inject(iamConfig.KEY)\n\t    private readonly config: ConfigType<typeof iamConfig>,\n\t  ) {}\n\t  async generate(user: IUser, requestId: string): Promise<IToken> {\n\t    const id = randomUUID();\n\t    const ttl = this.config.auth.passwordless.tokenTtl;\n\t    const expiresAt = new Date();\n\t    expiresAt.setSeconds(expiresAt.getSeconds() + ttl);\n\t    return new TokenModel(\n", "      id,\n\t      TokenType.PasswordlessLoginToken,\n\t      user.getId(),\n\t      expiresAt,\n\t      requestId,\n\t    );\n\t  }\n\t}\n"]}
{"filename": "src/models/token.model.ts", "chunked_list": ["import { IToken } from '../interfaces/token.interface';\n\texport class TokenModel implements IToken {\n\t  constructor(\n\t    public readonly id: string,\n\t    public readonly type: string,\n\t    public readonly userId: string,\n\t    public readonly expiresAt: Date,\n\t    public readonly requestId?: string,\n\t  ) {}\n\t  public getId(): string {\n", "    return this.id;\n\t  }\n\t  public getRequestId(): string | undefined {\n\t    return this.requestId;\n\t  }\n\t  public getUserId(): string {\n\t    return this.userId;\n\t  }\n\t  public getType(): string {\n\t    return this.type;\n", "  }\n\t  public getExpiresAt(): Date {\n\t    return this.expiresAt;\n\t  }\n\t}\n"]}
{"filename": "src/enums/auth-type.enum.ts", "chunked_list": ["export enum AuthType {\n\t  AccessToken,\n\t  None,\n\t}\n"]}
{"filename": "src/enums/token-type.enum.ts", "chunked_list": ["export enum TokenType {\n\t  AccessToken = 'accessToken',\n\t  PasswordlessLoginToken = 'passwordlessLoginToken',\n\t  RefreshToken = 'refreshToken',\n\t}\n"]}
{"filename": "src/controllers/auth.controller.ts", "chunked_list": ["import {\n\t  Body,\n\t  Controller,\n\t  Get,\n\t  HttpCode,\n\t  HttpStatus,\n\t  Inject,\n\t  NotFoundException,\n\t  Param,\n\t  Post,\n", "  Req,\n\t  Res,\n\t  UnauthorizedException,\n\t} from '@nestjs/common';\n\timport { ConfigType } from '@nestjs/config';\n\timport { EventBus } from '@nestjs/cqrs';\n\timport { JwtService } from '@nestjs/jwt';\n\timport {\n\t  ApiNoContentResponse,\n\t  ApiOkResponse,\n", "  ApiOperation,\n\t  ApiTags,\n\t} from '@nestjs/swagger';\n\timport { Request, Response } from 'express';\n\timport iamConfig from '../configs/iam.config';\n\timport { ActiveUser } from '../decorators/active-user.decorator';\n\timport { Auth } from '../decorators/auth.decorator';\n\timport { LoginRequestDto } from '../dtos/login-request.dto';\n\timport { LoginResponseDto } from '../dtos/login-response.dto';\n\timport { PasswordlessLoginRequestRequestDto } from '../dtos/passwordless-login-request-request.dto';\n", "import { AuthType } from '../enums/auth-type.enum';\n\timport { TokenType } from '../enums/token-type.enum';\n\timport { LoggedInEvent } from '../events/logged-in.event';\n\timport { LoggedOutEvent } from '../events/logged-out.event';\n\timport { BcryptHasher } from '../hashers/bcrypt.hasher';\n\timport { MODULE_OPTIONS_TOKEN } from '../iam.module-definition';\n\timport { IActiveUser } from '../interfaces/active-user.interface';\n\timport { IModuleOptions } from '../interfaces/module-options.interface';\n\timport { IRefreshTokenJwtPayload } from '../interfaces/refresh-token-jwt-payload.interface';\n\timport { LoginProcessor } from '../processors/login.processor';\n", "import { LogoutProcessor } from '../processors/logout.processor';\n\timport { PasswordlessLoginRequestProcessor } from '../processors/passwordless-login-request.processor';\n\t@Controller()\n\t@ApiTags('Auth')\n\texport class AuthController {\n\t  constructor(\n\t    private readonly eventBus: EventBus,\n\t    private readonly hasher: BcryptHasher,\n\t    private readonly loginProcessor: LoginProcessor,\n\t    private readonly logoutProcessor: LogoutProcessor,\n", "    private readonly passwordlessLoginRequestProcessor: PasswordlessLoginRequestProcessor,\n\t    private readonly jwtService: JwtService,\n\t    @Inject(MODULE_OPTIONS_TOKEN)\n\t    private readonly moduleOptions: IModuleOptions,\n\t    @Inject(iamConfig.KEY)\n\t    private readonly config: ConfigType<typeof iamConfig>,\n\t  ) {}\n\t  @HttpCode(HttpStatus.OK)\n\t  @ApiOperation({ operationId: 'authLogin' })\n\t  @ApiOkResponse({ type: LoginResponseDto })\n", "  @Auth(AuthType.None)\n\t  @Post('/auth/login')\n\t  async login(\n\t    @Body() request: LoginRequestDto,\n\t    @Res({ passthrough: true }) response: Response,\n\t  ): Promise<LoginResponseDto> {\n\t    if (!this.config.auth.methods.includes('basic')) {\n\t      throw new NotFoundException();\n\t    }\n\t    try {\n", "      const user = await this.moduleOptions.authService.checkUser(\n\t        request.username,\n\t      );\n\t      if (!(await this.hasher.compare(request.password, user.getPassword()))) {\n\t        throw new UnauthorizedException();\n\t      }\n\t      const login = await this.loginProcessor.process(user, response);\n\t      this.eventBus.publish(new LoggedInEvent(user.getId()));\n\t      return {\n\t        accessToken: login.accessToken,\n", "        refreshToken: login.refreshToken,\n\t      };\n\t    } catch {\n\t      throw new UnauthorizedException();\n\t    }\n\t  }\n\t  @HttpCode(HttpStatus.OK)\n\t  @ApiOperation({ operationId: 'authPasswordlessLogin' })\n\t  @ApiOkResponse({ type: LoginResponseDto })\n\t  @Auth(AuthType.None)\n", "  @Get('/auth/passwordless_login/:id')\n\t  async passwordlessLogin(\n\t    @Param('id') tokenId: string,\n\t    @Req() request: Request,\n\t    @Res({ passthrough: true }) response: Response,\n\t  ): Promise<LoginResponseDto> {\n\t    if (!this.config.auth.methods.includes('passwordless')) {\n\t      throw new NotFoundException();\n\t    }\n\t    const requestId = request.cookies[TokenType.PasswordlessLoginToken];\n", "    if (!requestId) {\n\t      throw new UnauthorizedException();\n\t    }\n\t    try {\n\t      const token = await this.moduleOptions.authService.checkToken(\n\t        tokenId,\n\t        TokenType.PasswordlessLoginToken,\n\t        requestId,\n\t      );\n\t      const user = await this.moduleOptions.authService.getUser(\n", "        token.getUserId(),\n\t      );\n\t      await this.moduleOptions.authService.checkUser(user.getUsername());\n\t      await this.moduleOptions.authService.removeToken(tokenId);\n\t      const login = await this.loginProcessor.process(user, response);\n\t      return {\n\t        accessToken: login.accessToken,\n\t        refreshToken: login.refreshToken,\n\t      };\n\t    } catch {\n", "      throw new UnauthorizedException();\n\t    }\n\t  }\n\t  @HttpCode(HttpStatus.NO_CONTENT)\n\t  @ApiOperation({ operationId: 'authPasswordlessLoginRequest' })\n\t  @ApiNoContentResponse()\n\t  @Auth(AuthType.None)\n\t  @Post('/auth/passwordless_login')\n\t  async passwordlessLoginRequest(\n\t    @Body() request: PasswordlessLoginRequestRequestDto,\n", "    @Res({ passthrough: true }) response: Response,\n\t  ): Promise<void> {\n\t    if (!this.config.auth.methods.includes('passwordless')) {\n\t      throw new NotFoundException();\n\t    }\n\t    try {\n\t      const user = await this.moduleOptions.authService.checkUser(\n\t        request.username,\n\t      );\n\t      await this.passwordlessLoginRequestProcessor.process(user, response);\n", "    } catch {}\n\t  }\n\t  @HttpCode(HttpStatus.OK)\n\t  @ApiOperation({ operationId: 'authRefreshTokens' })\n\t  @ApiOkResponse({ type: LoginResponseDto })\n\t  @Auth(AuthType.None)\n\t  @Get('/auth/refresh_tokens')\n\t  async refreshTokens(\n\t    @Req() request: Request,\n\t    @Res({ passthrough: true }) response: Response,\n", "  ): Promise<LoginResponseDto> {\n\t    try {\n\t      const refreshTokenJwtPayload: IRefreshTokenJwtPayload =\n\t        await this.jwtService.verifyAsync(\n\t          request.cookies[TokenType.RefreshToken],\n\t        );\n\t      await this.moduleOptions.authService.checkToken(\n\t        refreshTokenJwtPayload.id,\n\t        TokenType.RefreshToken,\n\t      );\n", "      const user = await this.moduleOptions.authService.getUser(\n\t        refreshTokenJwtPayload.sub,\n\t      );\n\t      await this.moduleOptions.authService.checkUser(user.getUsername());\n\t      await this.moduleOptions.authService.removeToken(\n\t        refreshTokenJwtPayload.id,\n\t      );\n\t      const login = await this.loginProcessor.process(user, response);\n\t      return {\n\t        accessToken: login.accessToken,\n", "        refreshToken: login.refreshToken,\n\t      };\n\t    } catch {\n\t      throw new UnauthorizedException();\n\t    }\n\t  }\n\t  @HttpCode(HttpStatus.NO_CONTENT)\n\t  @ApiOperation({ operationId: 'authLogout' })\n\t  @ApiNoContentResponse()\n\t  @Auth(AuthType.None)\n", "  @Get('/auth/logout')\n\t  async logout(\n\t    @Req() request: Request,\n\t    @Res({ passthrough: true }) response: Response,\n\t    @ActiveUser() activeUser: IActiveUser,\n\t  ) {\n\t    await this.logoutProcessor.process(request, response);\n\t    if (!activeUser) {\n\t      return;\n\t    }\n", "    this.eventBus.publish(new LoggedOutEvent(activeUser.userId));\n\t  }\n\t}\n"]}
{"filename": "src/decorators/roles.decorator.ts", "chunked_list": ["import { SetMetadata } from '@nestjs/common';\n\timport { IAM_ROLES_KEY } from '../constants/iam.constants';\n\texport const Roles = (...roles: string[]) => SetMetadata(IAM_ROLES_KEY, roles);\n"]}
{"filename": "src/decorators/auth.decorator.ts", "chunked_list": ["import { SetMetadata } from '@nestjs/common';\n\timport { IAM_AUTH_TYPE_KEY } from '../constants/iam.constants';\n\timport { AuthType } from '../enums/auth-type.enum';\n\texport const Auth = (...authTypes: AuthType[]) =>\n\t  SetMetadata(IAM_AUTH_TYPE_KEY, authTypes);\n"]}
{"filename": "src/decorators/active-user.decorator.ts", "chunked_list": ["import { createParamDecorator, ExecutionContext } from '@nestjs/common';\n\timport { IAM_REQUEST_USER_KEY } from '../constants/iam.constants';\n\timport { IActiveUser } from '../interfaces/active-user.interface';\n\texport const ActiveUser = createParamDecorator(\n\t  (field: keyof IActiveUser | undefined, ctx: ExecutionContext) => {\n\t    const request = ctx.switchToHttp().getRequest();\n\t    const user: IActiveUser | undefined = request[IAM_REQUEST_USER_KEY];\n\t    return field ? user?.[field] : user;\n\t  },\n\t);\n"]}
{"filename": "src/guards/access-token.guard.ts", "chunked_list": ["import {\n\t  CanActivate,\n\t  ExecutionContext,\n\t  Injectable,\n\t  UnauthorizedException,\n\t} from '@nestjs/common';\n\timport { JwtService } from '@nestjs/jwt';\n\timport { IAM_REQUEST_USER_KEY } from '../constants/iam.constants';\n\timport { TokenType } from '../enums/token-type.enum';\n\timport { IAccessTokenJwtPayload } from '../interfaces/access-token-jwt-payload.interface';\n", "import { IActiveUser } from '../interfaces/active-user.interface';\n\t@Injectable()\n\texport class AccessTokenGuard implements CanActivate {\n\t  constructor(private readonly jwtService: JwtService) {}\n\t  async canActivate(context: ExecutionContext): Promise<boolean> {\n\t    const request = context.switchToHttp().getRequest();\n\t    try {\n\t      const accessTokenJwtPayload: IAccessTokenJwtPayload =\n\t        await this.jwtService.verifyAsync(\n\t          request.cookies[TokenType.AccessToken] ?? '',\n", "        );\n\t      const activeUser: IActiveUser = {\n\t        userId: accessTokenJwtPayload.sub,\n\t        roles: accessTokenJwtPayload.roles,\n\t      };\n\t      request[IAM_REQUEST_USER_KEY] = activeUser;\n\t    } catch {\n\t      throw new UnauthorizedException();\n\t    }\n\t    return true;\n", "  }\n\t}\n"]}
{"filename": "src/guards/roles.guard.ts", "chunked_list": ["import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';\n\timport { Reflector } from '@nestjs/core';\n\timport { Observable } from 'rxjs';\n\timport {\n\t  IAM_REQUEST_USER_KEY,\n\t  IAM_ROLES_KEY,\n\t} from '../constants/iam.constants';\n\timport { IActiveUser } from '../interfaces/active-user.interface';\n\t@Injectable()\n\texport class RolesGuard implements CanActivate {\n", "  constructor(private readonly reflector: Reflector) {}\n\t  canActivate(\n\t    context: ExecutionContext,\n\t  ): boolean | Promise<boolean> | Observable<boolean> {\n\t    const roles = this.reflector.getAllAndOverride<string[]>(IAM_ROLES_KEY, [\n\t      context.getHandler(),\n\t      context.getClass(),\n\t    ]);\n\t    if (!roles) {\n\t      return true;\n", "    }\n\t    const user: IActiveUser | null = context.switchToHttp().getRequest()[\n\t      IAM_REQUEST_USER_KEY\n\t    ];\n\t    return roles.some((role) => user && user.roles.includes(role));\n\t  }\n\t}\n"]}
{"filename": "src/guards/none.guard.ts", "chunked_list": ["import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';\n\timport { JwtService } from '@nestjs/jwt';\n\timport { IAM_REQUEST_USER_KEY } from '../constants/iam.constants';\n\timport { TokenType } from '../enums/token-type.enum';\n\timport { IAccessTokenJwtPayload } from '../interfaces/access-token-jwt-payload.interface';\n\timport { IActiveUser } from '../interfaces/active-user.interface';\n\t@Injectable()\n\texport class NoneGuard implements CanActivate {\n\t  constructor(private readonly jwtService: JwtService) {}\n\t  async canActivate(context: ExecutionContext): Promise<boolean> {\n", "    const request = context.switchToHttp().getRequest();\n\t    const accessToken: string | undefined =\n\t      request.cookies[TokenType.AccessToken];\n\t    try {\n\t      const accessTokenJwtPayload: IAccessTokenJwtPayload =\n\t        await this.jwtService.verifyAsync(accessToken);\n\t      const activeUser: IActiveUser = {\n\t        userId: accessTokenJwtPayload.sub,\n\t        roles: accessTokenJwtPayload.roles,\n\t      };\n", "      request[IAM_REQUEST_USER_KEY] = activeUser;\n\t    } catch {\n\t      return true;\n\t    }\n\t    return true;\n\t  }\n\t}\n"]}
{"filename": "src/guards/auth.guard.ts", "chunked_list": ["import {\n\t  CanActivate,\n\t  ExecutionContext,\n\t  Injectable,\n\t  UnauthorizedException,\n\t} from '@nestjs/common';\n\timport { Reflector } from '@nestjs/core';\n\timport { IAM_AUTH_TYPE_KEY } from '../constants/iam.constants';\n\timport { AuthType } from '../enums/auth-type.enum';\n\timport { AccessTokenGuard } from './access-token.guard';\n", "import { NoneGuard } from './none.guard';\n\t@Injectable()\n\texport class AuthGuard implements CanActivate {\n\t  private readonly authTypeGuardMap: Record<\n\t    AuthType,\n\t    CanActivate | CanActivate[]\n\t  > = {\n\t    [AuthType.AccessToken]: this.accessTokenGuard,\n\t    [AuthType.None]: this.noneGuard,\n\t  };\n", "  constructor(\n\t    private readonly reflector: Reflector,\n\t    private readonly accessTokenGuard: AccessTokenGuard,\n\t    private readonly noneGuard: NoneGuard,\n\t  ) {}\n\t  async canActivate(context: ExecutionContext): Promise<boolean> {\n\t    const authTypes = this.reflector.getAllAndOverride<AuthType[]>(\n\t      IAM_AUTH_TYPE_KEY,\n\t      [context.getHandler(), context.getClass()],\n\t    ) ?? [AuthType.AccessToken];\n", "    const guards = authTypes.map((type) => this.authTypeGuardMap[type]).flat();\n\t    for (const guard of guards) {\n\t      if (await Promise.resolve(guard.canActivate(context))) {\n\t        return true;\n\t      }\n\t    }\n\t    throw new UnauthorizedException();\n\t  }\n\t}\n"]}
{"filename": "src/hashers/bcrypt.hasher.ts", "chunked_list": ["import { Injectable } from '@nestjs/common';\n\timport { compare, genSalt, hash } from 'bcrypt';\n\timport { IHasher } from '../interfaces/hasher.interface';\n\t@Injectable()\n\texport class BcryptHasher implements IHasher {\n\t  async hash(data: string | Buffer): Promise<string> {\n\t    const salt = await genSalt();\n\t    return hash(data, salt);\n\t  }\n\t  async compare(data: string | Buffer, encrypted: string): Promise<boolean> {\n", "    return compare(data, encrypted);\n\t  }\n\t}\n"]}
