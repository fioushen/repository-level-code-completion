{"filename": "manifest.ts", "chunked_list": ["import { defineManifest } from '@crxjs/vite-plugin'\n\timport packageJson from './package.json'\n\tconst { description, version } = packageJson\n\texport default defineManifest({\n\t  name: 'GitHub Account Switcher',\n\t  description,\n\t  version,\n\t  manifest_version: 3,\n\t  icons: {\n\t    '16': 'img/logo-16.png',\n", "    '32': 'img/logo-32.png',\n\t    '48': 'img/logo-48.png',\n\t    '128': 'img/logo-128.png',\n\t  },\n\t  action: {\n\t    default_popup: 'popup.html',\n\t    default_icon: 'img/logo-48.png',\n\t  },\n\t  background: {\n\t    service_worker: 'src/background/index.ts',\n", "    type: 'module',\n\t  },\n\t  content_scripts: [\n\t    {\n\t      matches: ['https://*.github.com/*'],\n\t      run_at: 'document_start',\n\t      js: ['src/content/index.ts'],\n\t    },\n\t  ],\n\t  web_accessible_resources: [],\n", "  host_permissions: ['https://*.github.com/'],\n\t  permissions: ['cookies', 'storage', 'webRequest', 'declarativeNetRequest'],\n\t})\n"]}
{"filename": "vite.config.ts", "chunked_list": ["import { crx } from '@crxjs/vite-plugin'\n\timport react from '@vitejs/plugin-react'\n\timport { defineConfig } from 'vite'\n\timport manifest from './manifest'\n\texport default defineConfig({\n\t  plugins: [react(), crx({ manifest })],\n\t})\n"]}
{"filename": "scripts/build.ts", "chunked_list": ["import cpy from 'cpy'\n\timport { deleteAsync } from 'del'\n\timport fs from 'fs/promises'\n\timport { join } from 'path'\n\timport AdmZip from 'adm-zip'\n\tconst __dirname = new URL('.', import.meta.url).pathname\n\t// Convert Chrome manifest V3 to Firefox manifest V2\n\tasync function buildFirefox() {\n\t  const distFolder = join(__dirname, '../dist')\n\t  const distFirefoxFolder = join(__dirname, '../dist_firefox')\n", "  // copy dist folder to dist_firefox\n\t  await deleteAsync(distFirefoxFolder)\n\t  await cpy(`${distFolder}/**`, distFirefoxFolder)\n\t  const manifest = JSON.parse(await fs.readFile(join(distFirefoxFolder, 'manifest.json'), 'utf-8'))\n\t  const {\n\t    action,\n\t    background: { service_worker },\n\t    web_accessible_resources,\n\t    host_permissions,\n\t    permissions,\n", "    ...rest\n\t  } = manifest\n\t  const combinedPermissions = permissions\n\t    .filter(\n\t      (permission: string) =>\n\t        permission !== 'declarativeNetRequest' && permission !== 'declarativeNetRequestFeedback',\n\t    )\n\t    .concat(['webRequestBlocking', ...host_permissions])\n\t  const webAccessibleResources = web_accessible_resources.reduce((acc: string[], item: any) => {\n\t    return acc.concat(item.resources)\n", "  }, [])\n\t  const firefoxManifest = {\n\t    ...rest,\n\t    manifest_version: 2,\n\t    browser_action: action,\n\t    background: {\n\t      page: 'background.html',\n\t    },\n\t    web_accessible_resources: webAccessibleResources,\n\t    permissions: combinedPermissions,\n", "  }\n\t  const backgroundHtml = `<!DOCTYPE html>\n\t<html>\n\t  <head>\n\t    <meta charset=\"utf-8\">\n\t    <title>${manifest.name} Background Page</title>\n\t  </head>\n\t  <body>\n\t    <script src=\"${service_worker}\" type=\"module\"></script>\n\t  </body>\n", "</html>\n\t`\n\t  await fs.writeFile(join(distFirefoxFolder, 'background.html'), backgroundHtml)\n\t  await fs.writeFile(\n\t    join(distFirefoxFolder, 'manifest.json'),\n\t    JSON.stringify(firefoxManifest, null, 2),\n\t  )\n\t  console.log('Firefox manifest built')\n\t}\n\tasync function createZip(folder: string, target: string) {\n", "  const source = join(__dirname, `../${folder}`)\n\t  const destination = join(__dirname, `../release/${target}`)\n\t  await deleteAsync(destination)\n\t  const zip = new AdmZip()\n\t  zip.addLocalFolder(source)\n\t  zip.writeZip(destination)\n\t}\n\tasync function main() {\n\t  await buildFirefox()\n\t  await createZip('dist', 'chrome.zip')\n", "  await createZip('dist_firefox', 'firefox.zip')\n\t}\n\tawait main()\n"]}
{"filename": "src/types.ts", "chunked_list": ["import { Rule } from './services/rule'\n\ttype Message<T extends string, P = {}> = { type: T } & P\n\ttype ErrorResponse = { success: false; error: Error }\n\texport type Response<T = void> = { success: true; data: T } | ErrorResponse\n\texport type GetAccountsMessage = Message<'getAccounts'>\n\texport type GetAccountsResponse = Response<string[]>\n\texport type SwitchAccountMessage = Message<'switchAccount', { account: string }>\n\texport type SwitchAccountResponse = Response\n\texport type ClearCookiesMessage = Message<'clearCookies'>\n\texport type ClearCookiesResponse = Response\n", "export type RemoveAccountMessage = Message<'removeAccount', { account: string }>\n\texport type RemoveAccountResponse = Response\n\texport type GetAutoSwitchRulesMessage = Message<'getAutoSwitchRules'>\n\texport type GetAutoSwitchRulesResponse = Response<Rule[]>\n\texport type RequestMessage =\n\t  | GetAccountsMessage\n\t  | ClearCookiesMessage\n\t  | SwitchAccountMessage\n\t  | RemoveAccountMessage\n\t  | GetAutoSwitchRulesMessage\n"]}
{"filename": "src/global.d.ts", "chunked_list": ["/// <reference types=\"vite/client\" />\n\tdeclare const __APP_VERSION__: string\n\tdeclare module '*?script&module' {\n\t  const src: string\n\t  export default src\n\t}\n"]}
{"filename": "src/shared.ts", "chunked_list": ["import browser from 'webextension-polyfill'\n\timport { Rule } from './services/rule'\n\tfunction urlMatchesRule(url: string, rule: Rule) {\n\t  const pattern = new RegExp(rule.urlPattern)\n\t  return pattern.test(url)\n\t}\n\tfunction urlMatchesAnyRule(url: string, rules: Rule[]) {\n\t  return rules.some((rule) => urlMatchesRule(url, rule))\n\t}\n\texport function isGitHubUrl(url: string | undefined) {\n", "  if (!url) {\n\t    return false\n\t  }\n\t  return /^https:\\/\\/(.+?\\.)?github\\.com/.test(url)\n\t}\n\texport function isNormalGitHubUrl(url: string | undefined, rules: Rule[]) {\n\t  if (!url) {\n\t    return false\n\t  }\n\t  if (!isGitHubUrl(url)) {\n", "    return false\n\t  }\n\t  if (urlMatchesAnyRule(url, rules)) {\n\t    return false\n\t  }\n\t  return true\n\t}\n\texport async function removeAccount(account: string) {\n\t  await browser.runtime.sendMessage({ type: 'removeAccount', account })\n\t}\n"]}
{"filename": "src/background/index.ts", "chunked_list": ["import browser, { DeclarativeNetRequest } from 'webextension-polyfill'\n\timport accountService from '../services/account'\n\timport { setBadgeText } from '../services/badge'\n\timport cookie from '../services/cookie'\n\timport ruleService from '../services/rule'\n\timport { RequestMessage, Response } from '../types'\n\tconst RESOURCE_TYPES: DeclarativeNetRequest.ResourceType[] = [\n\t  'main_frame',\n\t  'sub_frame',\n\t  'csp_report',\n", "  'websocket',\n\t  'xmlhttprequest',\n\t]\n\tasync function syncAccounts() {\n\t  const usernameCookie = await cookie.get('dotcom_user')\n\t  const sessionCookie = await cookie.get('user_session')\n\t  if (!usernameCookie || !sessionCookie) {\n\t    return\n\t  }\n\t  const { value: account } = usernameCookie\n", "  if (!account) {\n\t    return\n\t  }\n\t  await accountService.upsert(account, await cookie.getAll())\n\t  const accounts = await accountService.getAll()\n\t  console.info('synced accounts', accounts)\n\t  await updateDynamicRequestRules()\n\t  const res = await fetch(`https://github.com/${account}.png?size=100`)\n\t  if (res.status === 200) {\n\t    accountService.saveAvatar(account, res.url)\n", "  }\n\t  await setBadgeText(account.slice(0, 2))\n\t}\n\tasync function removeAccount(accountName: string) {\n\t  await accountService.remove(accountName)\n\t  await updateDynamicRequestRules()\n\t}\n\tasync function buildCookieValue(accountName: string): Promise<string | null> {\n\t  const account = await accountService.find(accountName)\n\t  const cookies = account?.cookies || []\n", "  if (!cookies.length) {\n\t    return null\n\t  }\n\t  return cookies\n\t    .map((cookie) => `${cookie.name}=${cookie.value}`)\n\t    .concat(`__account__=${accountName}`)\n\t    .join('; ')\n\t}\n\tasync function buildAddRules(): Promise<DeclarativeNetRequest.Rule[]> {\n\t  const requestRules: DeclarativeNetRequest.Rule[] = []\n", "  const autoSwitchRules = await ruleService.getAll()\n\t  for (const [index, rule] of autoSwitchRules.entries()) {\n\t    const cookieValue = await buildCookieValue(rule.account)\n\t    if (!cookieValue) {\n\t      continue\n\t    }\n\t    requestRules.push({\n\t      id: index + 1,\n\t      priority: 1,\n\t      action: {\n", "        type: 'modifyHeaders',\n\t        requestHeaders: [\n\t          {\n\t            header: 'Cookie',\n\t            operation: 'set',\n\t            value: cookieValue,\n\t          },\n\t        ],\n\t      },\n\t      condition: {\n", "        regexFilter: `${rule.urlPattern}|__account__=${rule.account}`,\n\t        resourceTypes: RESOURCE_TYPES,\n\t      },\n\t    })\n\t  }\n\t  return requestRules\n\t}\n\tasync function updateDynamicRequestRules() {\n\t  if (!browser.declarativeNetRequest) {\n\t    return\n", "  }\n\t  const existingRules = await browser.declarativeNetRequest.getDynamicRules()\n\t  const removeRuleIds = existingRules.map((rule) => rule.id)\n\t  const addRules = await buildAddRules()\n\t  await browser.declarativeNetRequest.updateDynamicRules({\n\t    removeRuleIds,\n\t    addRules,\n\t  })\n\t  const rules = await browser.declarativeNetRequest.getDynamicRules()\n\t  console.info('Current dynamic rules:', rules)\n", "}\n\t// Watch the requests, if the main_frame url matches any of the auto switch rules, switch to the account\n\tfunction watchAutoSwitchRequests() {\n\t  browser.webRequest.onBeforeRequest.addListener(\n\t    (details) => {\n\t      ruleService.getAll().then((autoSwitchRules) => {\n\t        for (const rule of autoSwitchRules) {\n\t          if (new RegExp(rule.urlPattern).test(details.url)) {\n\t            console.info('onBeforeRequest: found an auto switch rule for url', details.url, rule)\n\t            return accountService.switchTo(rule.account)\n", "          }\n\t        }\n\t      })\n\t    },\n\t    {\n\t      urls: ['https://github.com/*'],\n\t      types: ['main_frame'],\n\t    },\n\t  )\n\t}\n", "function watchCookies() {\n\t  browser.cookies.onChanged.addListener(async (changeInfo) => {\n\t    const { cookie, removed } = changeInfo\n\t    // Ignore other cookies\n\t    if (cookie.name !== 'dotcom_user') {\n\t      return\n\t    }\n\t    if (removed) {\n\t      if (cookie.name === 'dotcom_user') {\n\t        console.info('dotcom_user cookie removed')\n", "        await setBadgeText('...')\n\t      }\n\t      return\n\t    }\n\t    console.info('New dotcom_user cookie', cookie.value)\n\t    await syncAccounts()\n\t  })\n\t}\n\tfunction handleMessage(message: RequestMessage) {\n\t  const { type } = message\n", "  switch (type) {\n\t    case 'getAccounts':\n\t      return accountService.getAllNames()\n\t    case 'switchAccount':\n\t      return accountService.switchTo(message.account)\n\t    case 'removeAccount':\n\t      return removeAccount(message.account)\n\t    case 'clearCookies':\n\t      return cookie.clear()\n\t    case 'getAutoSwitchRules':\n", "      return ruleService.getAll()\n\t  }\n\t}\n\tfunction listenMessage() {\n\t  browser.runtime.onMessage.addListener(\n\t    async (request: RequestMessage, _sender): Promise<Response<unknown>> => {\n\t      try {\n\t        const data = await handleMessage(request)\n\t        return { success: true, data }\n\t      } catch (error: unknown) {\n", "        return { success: false, error: error as Error }\n\t      }\n\t    },\n\t  )\n\t}\n\tfunction interceptRequests() {\n\t  browser.webRequest.onBeforeSendHeaders.addListener(\n\t    async (details) => {\n\t      if (!details.requestHeaders) {\n\t        return { requestHeaders: details.requestHeaders }\n", "      }\n\t      const autoSwitchRules = await ruleService.getAll()\n\t      for (const rule of autoSwitchRules) {\n\t        const urlPattern = `${rule.urlPattern}|__account__=${rule.account}`\n\t        if (new RegExp(urlPattern).test(details.url)) {\n\t          const cookieValue = await buildCookieValue(rule.account)\n\t          if (cookieValue) {\n\t            for (const header of details.requestHeaders) {\n\t              if (header.name.toLowerCase() === 'cookie') {\n\t                header.value = cookieValue\n", "              }\n\t            }\n\t          }\n\t          console.info('interceptRequests: found an auto switch rule for url', details.url, rule)\n\t          return { requestHeaders: details.requestHeaders }\n\t        }\n\t      }\n\t      return { requestHeaders: details.requestHeaders }\n\t    },\n\t    {\n", "      urls: ['https://github.com/*'],\n\t      types: RESOURCE_TYPES,\n\t    },\n\t    ['blocking', 'requestHeaders'],\n\t  )\n\t}\n\tasync function init() {\n\t  await syncAccounts()\n\t  watchAutoSwitchRequests()\n\t  watchCookies()\n", "  listenMessage()\n\t  if (!browser.declarativeNetRequest) {\n\t    interceptRequests()\n\t  }\n\t  /*\n\t  chrome.declarativeNetRequest.onRuleMatchedDebug.addListener((info) => {\n\t    console.info('onRuleMatchedDebug', info)\n\t  })*/\n\t}\n\tinit()\n"]}
{"filename": "src/services/account.ts", "chunked_list": ["import browser, { Cookies } from 'webextension-polyfill'\n\timport { setBadgeText } from './badge'\n\timport cookie from './cookie'\n\timport storage from './storage'\n\ttype Cookie = Cookies.Cookie\n\texport type Account = {\n\t  name: string\n\t  cookies: Cookie[]\n\t  active: boolean\n\t  avatarUrl?: string\n", "  expiresAt?: Date\n\t}\n\ttype Accounts = Record<string, Cookie[]>\n\tasync function getAll(): Promise<Account[]> {\n\t  const accounts = await storage.get<Accounts>('accounts')\n\t  if (!accounts) {\n\t    return []\n\t  }\n\t  const currentAccount = await browser.cookies.get({\n\t    url: 'https://github.com',\n", "    name: 'dotcom_user',\n\t  })\n\t  const avatarUrls = await storage.get<Record<string, string>>('avatars')\n\t  return Object.entries(accounts).map(([name, cookies]) => {\n\t    const userSessionCookie = cookies.find(({ name }) => name === 'user_session')\n\t    return {\n\t      name,\n\t      cookies,\n\t      active: currentAccount?.value === name,\n\t      avatarUrl: avatarUrls?.[name],\n", "      expiresAt: userSessionCookie?.expirationDate\n\t        ? new Date(userSessionCookie.expirationDate * 1000)\n\t        : undefined,\n\t    }\n\t  })\n\t}\n\tasync function getAllNames(): Promise<string[]> {\n\t  const accounts = await getAll()\n\t  return accounts.map(({ name }) => name)\n\t}\n", "async function find(accountName: string): Promise<Account | undefined> {\n\t  const accounts = await getAll()\n\t  return accounts.find((account) => account.name === accountName)\n\t}\n\tasync function upsert(accountName: string, cookies: Cookie[]) {\n\t  await storage.update<Accounts>('accounts', (accounts = {}) => {\n\t    accounts[accountName] = cookies\n\t    return accounts\n\t  })\n\t}\n", "async function switchTo(accountName: string) {\n\t  await cookie.clear()\n\t  const account = await find(accountName)\n\t  const cookies = account?.cookies || []\n\t  for (const cookie of cookies) {\n\t    const { hostOnly, domain, session, ...rest } = cookie\n\t    await browser.cookies.set({\n\t      url: 'https://github.com',\n\t      domain: hostOnly ? undefined : domain,\n\t      ...rest,\n", "    })\n\t  }\n\t  if (cookies.length) {\n\t    setBadgeText(accountName.slice(0, 2))\n\t  } else {\n\t    setBadgeText('...')\n\t  }\n\t}\n\tasync function remove(accountName: string) {\n\t  await storage.update<Accounts>('accounts', (accounts) => {\n", "    if (!accounts) {\n\t      return\n\t    }\n\t    delete accounts[accountName]\n\t    return accounts\n\t  })\n\t}\n\tasync function saveAvatar(accountName: string, avatarUrl: string) {\n\t  await storage.update<Record<string, string>>('avatars', (avatars = {}) => {\n\t    avatars[accountName] = avatarUrl\n", "    return avatars\n\t  })\n\t}\n\texport default {\n\t  getAll,\n\t  getAllNames,\n\t  find,\n\t  upsert,\n\t  switchTo,\n\t  remove,\n", "  saveAvatar,\n\t}\n"]}
{"filename": "src/services/rule.ts", "chunked_list": ["import storage from './storage'\n\texport type Rule = {\n\t  id: number\n\t  urlPattern: string\n\t  account: string\n\t}\n\tasync function getAll(): Promise<Rule[]> {\n\t  const rules = await storage.get<Rule[]>('rules')\n\t  return rules || []\n\t}\n", "async function add(rule: Rule) {\n\t  await storage.update<Rule[]>('rules', (rules = []) => {\n\t    return [...rules, rule]\n\t  })\n\t}\n\tasync function update(rule: Rule) {\n\t  await storage.update<Rule[]>('rules', (rules = []) => {\n\t    return rules.map((r) => (r.id === rule.id ? rule : r))\n\t  })\n\t}\n", "async function remove(id: number) {\n\t  await storage.update<Rule[]>('rules', (rules = []) => {\n\t    return rules.filter((rule) => rule.id !== id)\n\t  })\n\t}\n\texport default {\n\t  getAll,\n\t  add,\n\t  update,\n\t  remove,\n", "}\n"]}
{"filename": "src/services/badge.ts", "chunked_list": ["import browser from 'webextension-polyfill'\n\texport async function setBadgeText(text: string) {\n\t  const action = browser.action || browser.browserAction\n\t  await action.setBadgeText({\n\t    text\n\t  })\n\t  await action.setBadgeBackgroundColor({\n\t    color: '#44b700',\n\t  })\n\t  action.setBadgeTextColor({\n", "    color: '#fff',\n\t  })\n\t}\n"]}
{"filename": "src/services/storage.ts", "chunked_list": ["import browser from 'webextension-polyfill'\n\tasync function set<T>(key: string, value: T) {\n\t  await browser.storage.local.set({ [key]: value })\n\t}\n\tasync function get<T>(key: string): Promise<T | undefined> {\n\t  const { [key]: value } = await browser.storage.local.get(key)\n\t  return value as T\n\t}\n\tasync function update<T>(key: string, updater: (value?: T) => T | undefined) {\n\t  const value = await get<T>(key)\n", "  await set(key, updater(value))\n\t}\n\tasync function clear() {\n\t  await browser.storage.local.clear()\n\t}\n\texport default {\n\t  get,\n\t  set,\n\t  update,\n\t  clear,\n", "}\n"]}
{"filename": "src/services/cookie.ts", "chunked_list": ["import browser from 'webextension-polyfill'\n\tconst COOKIE_URL = 'https://github.com'\n\tasync function get(name: string) {\n\t  return browser.cookies.get({ url: COOKIE_URL, name })\n\t}\n\tasync function getAll() {\n\t  return browser.cookies.getAll({ url: COOKIE_URL })\n\t}\n\tasync function clear() {\n\t  const cookies = await getAll()\n", "  for (const cookie of cookies) {\n\t    await browser.cookies.remove({ url: COOKIE_URL, name: cookie.name })\n\t  }\n\t}\n\texport default {\n\t  get,\n\t  getAll,\n\t  clear,\n\t}\n"]}
{"filename": "src/content/injected.ts", "chunked_list": ["type FetchFn = typeof fetch\n\ttype FetchInput = Parameters<FetchFn>[0]\n\tconst ACCOUNT_PARAM = '__account__'\n\tclass PatchedResponse extends Response {\n\t  constructor(private readonly response: Response) {\n\t    super(response.body, response)\n\t  }\n\t  get url() {\n\t    const url = new URL(this.response.url, window.location.origin)\n\t    url.searchParams.delete(ACCOUNT_PARAM)\n", "    return url.href\n\t  }\n\t}\n\tfunction patchUrl(oldUrl: string | URL) {\n\t  const account = document.querySelector<HTMLMetaElement>('meta[name=\"user-login\"]')?.content\n\t  if (!account) {\n\t    return oldUrl\n\t  }\n\t  const newUrl = new URL(oldUrl, window.location.origin)\n\t  newUrl.searchParams.append(ACCOUNT_PARAM, account)\n", "  return newUrl\n\t}\n\tfunction patchRequestInfo(input: RequestInfo | URL) {\n\t  if (input instanceof Request) {\n\t    return input\n\t  }\n\t  return patchUrl(input)\n\t}\n\tfunction patchRequest() {\n\t  const OriginalRequest = window.Request\n", "  class PatchedRequest extends OriginalRequest {\n\t    constructor(input: RequestInfo | URL, init?: RequestInit) {\n\t      super(patchRequestInfo(input), init)\n\t    }\n\t  }\n\t  window.Request = PatchedRequest\n\t}\n\tfunction patchFetch() {\n\t  const originalFetch = window.fetch\n\t  const patchedFetch: FetchFn = async (input, options) => {\n", "    try {\n\t      const res = await originalFetch(patchRequestInfo(input), options)\n\t      return new PatchedResponse(res)\n\t    } catch (err) {\n\t      console.warn('Failed to fetch:', err)\n\t      throw err\n\t    }\n\t  }\n\t  window.fetch = patchedFetch\n\t}\n", "function init() {\n\t  patchRequest()\n\t  patchFetch()\n\t}\n\tinit()\n"]}
{"filename": "src/content/createElement.ts", "chunked_list": ["type Child = Node | string | undefined\n\texport function createElement(\n\t  tagName: string,\n\t  attributes: Record<string, string> | { ns?: string; children?: Child | Child[] },\n\t) {\n\t  if (tagName === 'fragment') {\n\t    const fragment = document.createDocumentFragment()\n\t    appendChildren(fragment, attributes.children)\n\t    return fragment\n\t  }\n", "  const { children, ns, ...rest } = attributes\n\t  const el = ns ? document.createElementNS(ns, tagName) : document.createElement(tagName)\n\t  for (const [key, value] of Object.entries(rest)) {\n\t    el.setAttribute(key, value)\n\t  }\n\t  appendChildren(el, children)\n\t  return el\n\t}\n\tfunction appendChildren(parent: Node, children: Child | Child[] = []) {\n\t  const childrenArray = Array.isArray(children) ? children : [children]\n", "  for (const child of childrenArray) {\n\t    if (typeof child === 'undefined') {\n\t      continue\n\t    }\n\t    if (typeof child === 'string') {\n\t      parent.appendChild(document.createTextNode(child))\n\t    } else {\n\t      parent.appendChild(child)\n\t    }\n\t  }\n", "}\n\texport function createRemoveIcon() {\n\t  return createElement('svg', {\n\t    ns: 'http://www.w3.org/2000/svg',\n\t    'aria-hidden': 'true',\n\t    viewBox: '0 0 16 16',\n\t    height: '16',\n\t    width: '16',\n\t    version: '1.1',\n\t    'data-view-component': 'true',\n", "    class: 'octicon octicon-trash',\n\t    children: createElement('path', {\n\t      ns: 'http://www.w3.org/2000/svg',\n\t      d: 'M11 1.75V3h2.25a.75.75 0 0 1 0 1.5H2.75a.75.75 0 0 1 0-1.5H5V1.75C5 .784 5.784 0 6.75 0h2.5C10.216 0 11 .784 11 1.75ZM4.496 6.675l.66 6.6a.25.25 0 0 0 .249.225h5.19a.25.25 0 0 0 .249-.225l.66-6.6a.75.75 0 0 1 1.492.149l-.66 6.6A1.748 1.748 0 0 1 10.595 15h-5.19a1.75 1.75 0 0 1-1.741-1.575l-.66-6.6a.75.75 0 1 1 1.492-.15ZM6.5 1.75V3h3V1.75a.25.25 0 0 0-.25-.25h-2.5a.25.25 0 0 0-.25.25Z',\n\t    }),\n\t  })\n\t}\n"]}
{"filename": "src/content/index.ts", "chunked_list": ["import browser from 'webextension-polyfill'\n\timport { isNormalGitHubUrl, removeAccount } from '../shared'\n\timport {\n\t  ClearCookiesMessage,\n\t  GetAccountsMessage,\n\t  GetAccountsResponse,\n\t  GetAutoSwitchRulesMessage,\n\t  GetAutoSwitchRulesResponse,\n\t} from '../types'\n\timport './index.css'\n", "// Script that will be injected in the main page\n\timport { createElement } from './createElement'\n\timport injectedScript from './injected?script&module'\n\timport { ACCOUNT_ITEM_CLASS, ACCOUNT_REMOVE_CLASS, ADD_ACCOUNT_BUTTON_ID, createAccountItem, createAddAccountLink, createDivider } from './ui'\n\tasync function addSwitchUserMenu(logoutForm: HTMLFormElement) {\n\t  const currentAccount = document.querySelector<HTMLMetaElement>('meta[name=\"user-login\"]')?.content\n\t  if (!currentAccount) {\n\t    console.info('no current account found')\n\t    return\n\t  }\n", "  if (!document.getElementById(ADD_ACCOUNT_BUTTON_ID)) {\n\t    // Add the \"Add another account\" menu item and a divider\n\t    const fragment = createElement('fragment', {\n\t      children: [\n\t        createAddAccountLink(),\n\t        createDivider(),\n\t      ],\n\t    })\n\t    // Insert the elements before the logoutForm\n\t    logoutForm.parentElement?.insertBefore(fragment, logoutForm)\n", "  }\n\t  const res: GetAccountsResponse = await browser.runtime.sendMessage({\n\t    type: 'getAccounts',\n\t  } as GetAccountsMessage)\n\t  if (!res?.success) {\n\t    return\n\t  }\n\t  const { data: accounts } = res\n\t  const addAccountButton = document.getElementById(ADD_ACCOUNT_BUTTON_ID)!\n\t  for (const account of accounts) {\n", "    if (account === currentAccount) {\n\t      continue\n\t    }\n\t    const accountId = `${ACCOUNT_ITEM_CLASS}-${account}`\n\t    if (!document.getElementById(accountId) && addAccountButton) {\n\t      const accountWrapper = createAccountItem(account)\n\t      addAccountButton.parentElement?.insertBefore(accountWrapper, addAccountButton)\n\t    }\n\t  }\n\t}\n", "async function getAutoSwitchRules() {\n\t  const res: GetAutoSwitchRulesResponse = await browser.runtime.sendMessage({\n\t    type: 'getAutoSwitchRules',\n\t  } as GetAutoSwitchRulesMessage)\n\t  return res?.success ? res.data : []\n\t}\n\tasync function addAccount() {\n\t  await browser.runtime.sendMessage({ type: 'clearCookies' } as ClearCookiesMessage)\n\t  const autoSwitchRules = await getAutoSwitchRules()\n\t  window.location.href = isNormalGitHubUrl(window.location.href, autoSwitchRules)\n", "    ? `/login?return_to=${encodeURIComponent(window.location.href)}`\n\t    : '/login'\n\t}\n\tasync function switchAccount(account: string) {\n\t  await browser.runtime.sendMessage({ type: 'switchAccount', account })\n\t  const autoSwitchRules = await getAutoSwitchRules()\n\t  if (isNormalGitHubUrl(window.location.href, autoSwitchRules)) {\n\t    window.location.reload()\n\t  } else {\n\t    window.location.href = '/'\n", "  }\n\t}\n\tfunction injectScript() {\n\t  const script = document.createElement('script')\n\t  script.src = browser.runtime.getURL(injectedScript)\n\t  script.type = 'module'\n\t  document.head.prepend(script)\n\t}\n\tfunction ready(fn: () => void) {\n\t  if (document.readyState !== 'loading') {\n", "    fn()\n\t    return\n\t  }\n\t  document.addEventListener('DOMContentLoaded', fn)\n\t}\n\tfunction watchDom() {\n\t  new MutationObserver((mutations) => {\n\t    for (const mutation of mutations) {\n\t      const isOpen =\n\t        mutation.type === 'attributes' &&\n", "        mutation.attributeName === 'open' &&\n\t        mutation.target instanceof HTMLElement &&\n\t        mutation.target.hasAttribute('open')\n\t      if (isOpen || (mutation.type === 'childList' && mutation.target instanceof HTMLElement)) {\n\t        // Find the logout form on GitHub page or Gist page\n\t        const logoutForm = mutation.target.querySelector<HTMLFormElement>(\n\t          '.js-loggout-form, #user-links .logout-form, user-drawer-side-panel nav-list .ActionListItem:last-child',\n\t        )\n\t        if (logoutForm) {\n\t          addSwitchUserMenu(logoutForm)\n", "        }\n\t      }\n\t    }\n\t  }).observe(document.documentElement, {\n\t    childList: true,\n\t    subtree: true,\n\t    attributes: true,\n\t  })\n\t}\n\tasync function init() {\n", "  injectScript()\n\t  ready(watchDom)\n\t  document.addEventListener('click', (event) => {\n\t    const target = event.target as HTMLElement\n\t    if (target.closest(`.${ADD_ACCOUNT_BUTTON_ID}`)) {\n\t      // add another account\n\t      event.preventDefault()\n\t      addAccount()\n\t    } else if (target.closest(`.${ACCOUNT_ITEM_CLASS}`)) {\n\t      // switch to account\n", "      const closestTarget = target.closest(`.${ACCOUNT_ITEM_CLASS}`) as HTMLElement\n\t      const { account } = closestTarget.dataset\n\t      switchAccount(account!)\n\t    } else if (target.closest(`.${ACCOUNT_REMOVE_CLASS}`)) {\n\t      // remove account\n\t      const btn = target.closest(`.${ACCOUNT_REMOVE_CLASS}`) as HTMLElement\n\t      const { account } = btn.dataset\n\t      removeAccount(account!).then(() => {\n\t        btn.parentElement?.remove()\n\t      })\n", "    }\n\t  })\n\t}\n\tinit()\n"]}
{"filename": "src/content/ui.ts", "chunked_list": ["import { createElement, createRemoveIcon } from './createElement'\n\texport const ADD_ACCOUNT_BUTTON_ID = 'gh-account-switcher__add-account'\n\texport const ACCOUNT_ITEM_CLASS = 'gh-account-switcher__account'\n\texport const ACCOUNT_REMOVE_CLASS = 'gh-account-switcher__account-remove'\n\tfunction isNewLook() {\n\t  return document.querySelector('.AppHeader-user') !== null\n\t}\n\tfunction uiLook() {\n\t  return isNewLook() ? newLook : classicLook\n\t}\n", "const classicLook = {\n\t  createDivider() {\n\t    return createElement('div', {\n\t      class: 'dropdown-divider'\n\t    })\n\t  },\n\t  createAddAccountLink() {\n\t    return createElement('a', {\n\t      id: ADD_ACCOUNT_BUTTON_ID,\n\t      href: '/login',\n", "      class: `dropdown-item ${ADD_ACCOUNT_BUTTON_ID}`,\n\t      children: 'Add another account'\n\t    })\n\t  },\n\t  createAccountItem(account: string) {\n\t    const accountId = `${ACCOUNT_ITEM_CLASS}-${account}`\n\t    return createElement('div', {\n\t      id: accountId,\n\t      class: 'gh-account-switcher__account-wrapper',\n\t      children: [\n", "        createElement('button', {\n\t          'data-account': account,\n\t          class: `dropdown-item btn-link ${ACCOUNT_ITEM_CLASS}`,\n\t          role: 'menuitem',\n\t          children: [\n\t            'Switch to ',\n\t            createElement('b', { children: account }),\n\t          ],\n\t        }),\n\t        createElement('button', {\n", "          title: 'Remove account',\n\t          class: `btn-link ${ACCOUNT_REMOVE_CLASS}`,\n\t          'data-account': account,\n\t          children: createRemoveIcon(),\n\t        }),\n\t      ]\n\t    })\n\t  }\n\t}\n\tconst newLook = {\n", "  createDivider() {\n\t    return createElement('li', {\n\t      class: 'ActionList-sectionDivider'\n\t    })\n\t  },\n\t  createAddAccountLink() {\n\t    return createElement('li', {\n\t      id: ADD_ACCOUNT_BUTTON_ID,\n\t      class: 'ActionListItem',\n\t      children: [\n", "        createElement('a', {\n\t          class: `ActionListContent ${ADD_ACCOUNT_BUTTON_ID}`,\n\t          href: '/login',\n\t          children: [\n\t            createElement('span', {\n\t              class: 'ActionListItem-label',\n\t              children: 'Add another account'\n\t            })\n\t          ]\n\t        })\n", "      ]\n\t    })\n\t  },\n\t  createAccountItem(account: string) {\n\t    const accountId = `${ACCOUNT_ITEM_CLASS}-${account}`\n\t    return createElement('li', {\n\t      id: accountId,\n\t      class: 'ActionListItem',\n\t      children: [\n\t        createElement('button', {\n", "          'data-account': account,\n\t          class: `ActionListContent ${ACCOUNT_ITEM_CLASS}`,\n\t          children: [\n\t            createElement('span', {\n\t              class: 'ActionListItem-label',\n\t              children: [\n\t                'Switch to ',\n\t                createElement('b', { children: account }),\n\t              ]\n\t            })\n", "          ]\n\t        }),\n\t        createElement('button', {\n\t          title: 'Remove account',\n\t          'data-account': account,\n\t          class: `btn-link color-fg-danger ${ACCOUNT_REMOVE_CLASS}`,\n\t          children: createRemoveIcon(),\n\t        })\n\t      ]\n\t    })\n", "  }\n\t}\n\texport function createDivider() {\n\t  const look = uiLook()\n\t  return look.createDivider();\n\t}\n\texport function createAddAccountLink() {\n\t  const look = uiLook()\n\t  return look.createAddAccountLink();\n\t}\n", "export function createAccountItem(account: string) {\n\t  const look = uiLook()\n\t  return look.createAccountItem(account);\n\t}\n"]}
