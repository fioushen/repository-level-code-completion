{"filename": "dist/esm/klient.d.ts", "chunked_list": ["import Bag from './services/bag/bag';\n\timport Dispatcher from './services/dispatcher/dispatcher';\n\timport RequestFactory from './services/request/factory';\n\timport type Event from './events/event';\n\timport type Request from './services/request/request';\n\timport type { KlientRequestConfig } from './services/request/request';\n\timport type { Callback } from './services/dispatcher/dispatcher';\n\timport type { Parameters } from './parameters';\n\texport default class Klient<P extends Parameters = Parameters> {\n\t    readonly extensions: string[];\n", "    readonly parameters: Bag;\n\t    readonly services: Bag;\n\t    constructor(urlOrParams?: P | string);\n\t    get url(): string | undefined;\n\t    get debug(): boolean;\n\t    get factory(): RequestFactory;\n\t    get dispatcher(): Dispatcher;\n\t    extends(property: string, value: unknown, writable?: boolean): this;\n\t    load(names?: string[]): this;\n\t    on<T extends Event>(event: string, callback: Callback<T>, priority?: number, once?: boolean): this;\n", "    once<T extends Event>(event: string, callback: Callback<T>, priority?: number): this;\n\t    off<T extends Event>(event: string, callback: Callback<T>): this;\n\t    request<T = unknown>(urlOrConfig: KlientRequestConfig | string): Request<T>;\n\t    get<T = unknown>(url: string, config?: KlientRequestConfig): Request<T>;\n\t    post<T = unknown>(url: string, data: unknown, config?: KlientRequestConfig): Request<T>;\n\t    put<T = unknown>(url: string, data: unknown, config?: KlientRequestConfig): Request<T>;\n\t    patch<T = unknown>(url: string, data: unknown, config?: KlientRequestConfig): Request<T>;\n\t    delete<T = unknown>(url: string, config?: KlientRequestConfig): Request<T>;\n\t    head<T = unknown>(url: string, config?: KlientRequestConfig): Request<T>;\n\t    options<T = unknown>(url: string, config?: KlientRequestConfig): Request<T>;\n", "    file(urlOrConfig: KlientRequestConfig | string): Promise<Blob>;\n\t    cancelPendingRequests(): this;\n\t    isCancel(e: Error): boolean;\n\t}\n"]}
{"filename": "dist/esm/extensions.d.ts", "chunked_list": ["import type Klient from '.';\n\texport declare type Extension = {\n\t    name: string;\n\t    initialize: (klient: Klient) => void;\n\t};\n\tdeclare class Extensions extends Array<Extension> {\n\t    load(klient: Klient, extensions?: string[]): void;\n\t}\n\tdeclare const _default: Extensions;\n\texport default _default;\n"]}
{"filename": "dist/esm/index.d.ts", "chunked_list": ["import Klient from './klient';\n\texport { AxiosError } from 'axios';\n\texport { default as Extensions } from './extensions';\n\texport { default as Bag } from './services/bag/bag';\n\texport { default as Dispatcher } from './services/dispatcher/dispatcher';\n\texport { default as RequestFactory } from './services/request/factory';\n\texport { default as Request } from './services/request/request';\n\texport { default as Event } from './events/event';\n\texport { default as DebugEvent } from './events/debug';\n\texport { default as RequestEvent } from './events/request/request';\n", "export { default as RequestSuccessEvent } from './events/request/success';\n\texport { default as RequestErrorEvent } from './events/request/error';\n\texport { default as RequestCancelEvent } from './events/request/cancel';\n\texport { default as RequestDoneEvent } from './events/request/done';\n\texport type { Parameters } from './parameters';\n\texport type { KlientRequestConfig } from './services/request/request';\n\texport default Klient;\n"]}
{"filename": "dist/esm/parameters.d.ts", "chunked_list": ["import type { AxiosRequestConfig } from 'axios';\n\texport interface ExtendableParameters {\n\t    [_prop: string]: unknown;\n\t}\n\texport interface Parameters extends ExtendableParameters {\n\t    url?: string;\n\t    extensions?: string[];\n\t    request?: AxiosRequestConfig;\n\t    debug?: boolean;\n\t}\n", "export declare const defaultParameters: Parameters;\n"]}
{"filename": "dist/esm/toolbox/object.d.ts", "chunked_list": ["export declare type AnyObject = Record<string, unknown>;\n\texport declare function isPlainObject(value: unknown): boolean;\n\texport declare function isPlainArray(value: unknown): boolean;\n\texport declare function softClone(obj: AnyObject): AnyObject;\n"]}
{"filename": "dist/esm/events/debug.d.ts", "chunked_list": ["import Event from './event';\n\timport type Listener from '../services/dispatcher/listener';\n\texport default class DebugEvent extends Event {\n\t    action: string;\n\t    relatedEvent: Event;\n\t    handler: Listener<never> | Listener<never>[];\n\t    error: Error | null;\n\t    static NAME: string;\n\t    constructor(action: string, relatedEvent: Event, handler: Listener<never> | Listener<never>[], error: Error | null);\n\t}\n"]}
{"filename": "dist/esm/events/event.d.ts", "chunked_list": ["export default class Event {\n\t    static NAME: string;\n\t    readonly dispatch: {\n\t        propagation: boolean;\n\t        skipNextListeners: number;\n\t        skipUntilListener?: number;\n\t    };\n\t    stopPropagation(): void;\n\t    skipNextListeners(total: number): void;\n\t    skipUntilListener(id: number): void;\n", "}\n"]}
{"filename": "dist/esm/events/request/success.d.ts", "chunked_list": ["import type { AxiosResponse } from 'axios';\n\timport RequestEvent from './request';\n\texport default class RequestSuccessEvent<T = unknown> extends RequestEvent {\n\t    relatedEvent: RequestEvent<T>;\n\t    static NAME: string;\n\t    constructor(relatedEvent: RequestEvent<T>);\n\t    get response(): AxiosResponse<T>;\n\t    get data(): T;\n\t}\n"]}
{"filename": "dist/esm/events/request/error.d.ts", "chunked_list": ["import type { AxiosError } from 'axios';\n\timport RequestEvent from './request';\n\texport default class RequestErrorEvent<T = unknown> extends RequestEvent<T> {\n\t    relatedEvent: RequestEvent<T>;\n\t    static NAME: string;\n\t    constructor(relatedEvent: RequestEvent<T>);\n\t    get error(): AxiosError;\n\t    get response(): import(\"axios\").AxiosResponse<unknown, any> | undefined;\n\t    get data(): unknown;\n\t}\n"]}
{"filename": "dist/esm/events/request/done.d.ts", "chunked_list": ["import RequestEvent from './request';\n\timport RequestSuccessEvent from './success';\n\timport type RequestErrorEvent from './error';\n\texport default class RequestDoneEvent<T = unknown> extends RequestEvent {\n\t    relatedEvent: RequestSuccessEvent<T> | RequestErrorEvent<T>;\n\t    static NAME: string;\n\t    constructor(relatedEvent: RequestSuccessEvent<T> | RequestErrorEvent<T>);\n\t    get success(): boolean;\n\t    get result(): import(\"axios\").AxiosResponse<any, any> | import(\"axios\").AxiosError<unknown, any> | undefined;\n\t    get data(): unknown;\n", "}\n"]}
{"filename": "dist/esm/events/request/request.d.ts", "chunked_list": ["import Event from '../event';\n\timport type Request from '../../services/request/request';\n\timport type { KlientRequestConfig } from '../../services/request/request';\n\texport default class RequestEvent<T = unknown> extends Event {\n\t    request: Request<T>;\n\t    static NAME: string;\n\t    constructor(request: Request<T>);\n\t    get config(): KlientRequestConfig;\n\t    get context(): {\n\t        [x: string]: any;\n", "    };\n\t}\n"]}
{"filename": "dist/esm/events/request/cancel.d.ts", "chunked_list": ["import RequestEvent from './request';\n\texport default class RequestCancelEvent<T = unknown> extends RequestEvent {\n\t    relatedEvent: RequestEvent<T>;\n\t    static NAME: string;\n\t    constructor(relatedEvent: RequestEvent<T>);\n\t}\n"]}
{"filename": "dist/esm/services/bag/bag.d.ts", "chunked_list": ["import { Watchable, WatchCallback } from './watch';\n\tdeclare type BagItems = Record<string, unknown>;\n\texport default class Bag implements BagItems, Watchable {\n\t    [x: string]: unknown;\n\t    constructor(items?: BagItems);\n\t    get watchers(): Record<string, {\n\t        callback: WatchCallback<unknown, unknown>;\n\t        deep: boolean;\n\t    }[]>;\n\t    has(path: string): boolean;\n", "    get(path: string): any;\n\t    all(): import(\"../../toolbox/object\").AnyObject;\n\t    set(path: string, value: unknown): this;\n\t    merge(...items: BagItems[]): this;\n\t    watch(path: string, onChange: WatchCallback, deep?: boolean): this;\n\t    unwatch(path: string, onChange: WatchCallback): this;\n\t}\n\texport {};\n"]}
{"filename": "dist/esm/services/bag/watch.d.ts", "chunked_list": ["export declare type Watchable = object;\n\texport declare type WatchCallback<T = unknown, Z = T> = (next: T, prev: Z) => void;\n\tdeclare type WatcherItem = {\n\t    callback: WatchCallback;\n\t    deep: boolean;\n\t};\n\texport declare function getWatchers(watchable: Watchable): Record<string, WatcherItem[]>;\n\texport declare function watch<T extends Watchable>(watchable: T, path: string, onChange: WatchCallback, deep: boolean): T;\n\texport declare function unwatch<T extends Watchable>(watchable: T, path: string, onChange: WatchCallback): T;\n\texport declare function invokeWatchers<T extends Watchable>(watchable: T, next: object, prev: object): T;\n", "export {};\n"]}
{"filename": "dist/esm/services/dispatcher/listener.d.ts", "chunked_list": ["import type Event from '../../events/event';\n\timport type { Callback } from './dispatcher';\n\texport default class Listener<T extends Event> {\n\t    readonly callback: Callback<T>;\n\t    readonly priority: number;\n\t    readonly once: boolean;\n\t    readonly id: number;\n\t    constructor(callback: Callback<T>, priority: number, once: boolean, id: number);\n\t    invoke(event: T): Promise<void>;\n\t}\n"]}
{"filename": "dist/esm/services/dispatcher/dispatcher.d.ts", "chunked_list": ["import Event from '../../events/event';\n\timport Listener from './listener';\n\timport type Klient from '../../klient';\n\texport declare type Callback<T extends Event> = (e: T) => Promise<void> | void;\n\texport declare type Listeners = {\n\t    [event: string]: Listener<never>[];\n\t};\n\texport default class Dispatcher {\n\t    protected readonly klient: Klient;\n\t    readonly listeners: Listeners;\n", "    constructor(klient: Klient);\n\t    on<T extends Event>(event: string, callback: Callback<T>, priority?: number, once?: boolean): this;\n\t    once<T extends Event>(event: string, callback: Callback<T>, priority?: number): this;\n\t    off<T extends Event>(event: string, callback: Callback<T>): this;\n\t    dispatch(e: Event, abortOnFailure?: boolean): Promise<void>;\n\t    protected findListenerIndex<T extends Event>(event: string, callback: Callback<T>): number | undefined;\n\t    protected static handleListenerSkipping(event: Event, listener: Listener<never>): boolean | void;\n\t    protected debug(action: string, relatedEvent: Event, handler: Listener<never> | Listener<never>[], error?: Error | null): void;\n\t}\n"]}
{"filename": "dist/esm/services/request/factory.d.ts", "chunked_list": ["import type Klient from '../../klient';\n\timport Request from './request';\n\timport type { KlientRequestConfig } from './request';\n\texport default class RequestFactory {\n\t    protected readonly klient: Klient;\n\t    model: typeof Request;\n\t    readonly requests: Request[];\n\t    constructor(klient: Klient);\n\t    request<T = unknown>(urlOrConfig: KlientRequestConfig | string): Request<T>;\n\t    file(urlOrConfig: KlientRequestConfig | string): Promise<Blob>;\n", "    cancelPendingRequests(): this;\n\t    createRequest<T = unknown>(urlOrConfig: KlientRequestConfig | string): Request<T>;\n\t    isCancel(e: Error): boolean;\n\t    protected prepare(config: KlientRequestConfig): KlientRequestConfig;\n\t    protected removePendingRequest(request: Request): void;\n\t}\n"]}
{"filename": "dist/esm/services/request/request.d.ts", "chunked_list": ["import type { AxiosResponse, AxiosError, AxiosRequestConfig, AxiosPromise } from 'axios';\n\timport RequestEvent from '../../events/request/request';\n\timport RequestSuccessEvent from '../../events/request/success';\n\timport RequestErrorEvent from '../../events/request/error';\n\timport RequestCancelEvent from '../../events/request/cancel';\n\timport type Klient from '../..';\n\texport declare type ResolveRequest = (response: AxiosResponse) => void;\n\texport declare type RejectRequest = (error: AxiosError) => void;\n\texport declare type RequestCallback = (resolve: ResolveRequest, reject: RejectRequest) => void;\n\tdeclare type PromiseCallbacks = {\n", "    resolve: ResolveRequest;\n\t    reject: RejectRequest;\n\t};\n\tdeclare type RequestEventTypes = typeof RequestSuccessEvent | typeof RequestErrorEvent | typeof RequestCancelEvent;\n\tdeclare type RequestContext = Record<string, any>;\n\texport interface KlientRequestConfig extends AxiosRequestConfig {\n\t    context?: RequestContext;\n\t}\n\texport default class Request<T = unknown> extends Promise<AxiosResponse<T>> {\n\t    context: RequestContext;\n", "    config: KlientRequestConfig;\n\t    result?: AxiosError | AxiosResponse;\n\t    handler: (config: AxiosRequestConfig) => AxiosPromise<T>;\n\t    protected klient: Klient;\n\t    protected callbacks: PromiseCallbacks;\n\t    protected readonly primaryEvent: RequestEvent<T>;\n\t    protected readonly abortController: AbortController;\n\t    protected constructor(callback: RequestCallback);\n\t    static new<T>({ context, ...axiosConfig }: KlientRequestConfig, klient: Klient): Request<T>;\n\t    static isCancel(e: Error): boolean;\n", "    cancel(): this;\n\t    execute(): this;\n\t    protected doRequest(): this;\n\t    protected resolve(response: AxiosResponse<T>): Promise<void>;\n\t    protected reject(error: AxiosError): Promise<void>;\n\t    protected dispatchResultEvent(EventClass: RequestEventTypes): Promise<void>;\n\t    protected get dispatcher(): import(\"../..\").Dispatcher;\n\t}\n\texport {};\n"]}
{"filename": "dist/cjs/klient.d.ts", "chunked_list": ["import Bag from './services/bag/bag';\n\timport Dispatcher from './services/dispatcher/dispatcher';\n\timport RequestFactory from './services/request/factory';\n\timport type Event from './events/event';\n\timport type Request from './services/request/request';\n\timport type { KlientRequestConfig } from './services/request/request';\n\timport type { Callback } from './services/dispatcher/dispatcher';\n\timport type { Parameters } from './parameters';\n\texport default class Klient<P extends Parameters = Parameters> {\n\t    readonly extensions: string[];\n", "    readonly parameters: Bag;\n\t    readonly services: Bag;\n\t    constructor(urlOrParams?: P | string);\n\t    get url(): string | undefined;\n\t    get debug(): boolean;\n\t    get factory(): RequestFactory;\n\t    get dispatcher(): Dispatcher;\n\t    extends(property: string, value: unknown, writable?: boolean): this;\n\t    load(names?: string[]): this;\n\t    on<T extends Event>(event: string, callback: Callback<T>, priority?: number, once?: boolean): this;\n", "    once<T extends Event>(event: string, callback: Callback<T>, priority?: number): this;\n\t    off<T extends Event>(event: string, callback: Callback<T>): this;\n\t    request<T = unknown>(urlOrConfig: KlientRequestConfig | string): Request<T>;\n\t    get<T = unknown>(url: string, config?: KlientRequestConfig): Request<T>;\n\t    post<T = unknown>(url: string, data: unknown, config?: KlientRequestConfig): Request<T>;\n\t    put<T = unknown>(url: string, data: unknown, config?: KlientRequestConfig): Request<T>;\n\t    patch<T = unknown>(url: string, data: unknown, config?: KlientRequestConfig): Request<T>;\n\t    delete<T = unknown>(url: string, config?: KlientRequestConfig): Request<T>;\n\t    head<T = unknown>(url: string, config?: KlientRequestConfig): Request<T>;\n\t    options<T = unknown>(url: string, config?: KlientRequestConfig): Request<T>;\n", "    file(urlOrConfig: KlientRequestConfig | string): Promise<Blob>;\n\t    cancelPendingRequests(): this;\n\t    isCancel(e: Error): boolean;\n\t}\n"]}
{"filename": "dist/cjs/extensions.d.ts", "chunked_list": ["import type Klient from '.';\n\texport declare type Extension = {\n\t    name: string;\n\t    initialize: (klient: Klient) => void;\n\t};\n\tdeclare class Extensions extends Array<Extension> {\n\t    load(klient: Klient, extensions?: string[]): void;\n\t}\n\tdeclare const _default: Extensions;\n\texport default _default;\n"]}
{"filename": "dist/cjs/index.d.ts", "chunked_list": ["import Klient from './klient';\n\texport { AxiosError } from 'axios';\n\texport { default as Extensions } from './extensions';\n\texport { default as Bag } from './services/bag/bag';\n\texport { default as Dispatcher } from './services/dispatcher/dispatcher';\n\texport { default as RequestFactory } from './services/request/factory';\n\texport { default as Request } from './services/request/request';\n\texport { default as Event } from './events/event';\n\texport { default as DebugEvent } from './events/debug';\n\texport { default as RequestEvent } from './events/request/request';\n", "export { default as RequestSuccessEvent } from './events/request/success';\n\texport { default as RequestErrorEvent } from './events/request/error';\n\texport { default as RequestCancelEvent } from './events/request/cancel';\n\texport { default as RequestDoneEvent } from './events/request/done';\n\texport type { Parameters } from './parameters';\n\texport type { KlientRequestConfig } from './services/request/request';\n\texport default Klient;\n"]}
{"filename": "dist/cjs/parameters.d.ts", "chunked_list": ["import type { AxiosRequestConfig } from 'axios';\n\texport interface ExtendableParameters {\n\t    [_prop: string]: unknown;\n\t}\n\texport interface Parameters extends ExtendableParameters {\n\t    url?: string;\n\t    extensions?: string[];\n\t    request?: AxiosRequestConfig;\n\t    debug?: boolean;\n\t}\n", "export declare const defaultParameters: Parameters;\n"]}
{"filename": "dist/cjs/toolbox/object.d.ts", "chunked_list": ["export declare type AnyObject = Record<string, unknown>;\n\texport declare function isPlainObject(value: unknown): boolean;\n\texport declare function isPlainArray(value: unknown): boolean;\n\texport declare function softClone(obj: AnyObject): AnyObject;\n"]}
{"filename": "dist/cjs/events/debug.d.ts", "chunked_list": ["import Event from './event';\n\timport type Listener from '../services/dispatcher/listener';\n\texport default class DebugEvent extends Event {\n\t    action: string;\n\t    relatedEvent: Event;\n\t    handler: Listener<never> | Listener<never>[];\n\t    error: Error | null;\n\t    static NAME: string;\n\t    constructor(action: string, relatedEvent: Event, handler: Listener<never> | Listener<never>[], error: Error | null);\n\t}\n"]}
{"filename": "dist/cjs/events/event.d.ts", "chunked_list": ["export default class Event {\n\t    static NAME: string;\n\t    readonly dispatch: {\n\t        propagation: boolean;\n\t        skipNextListeners: number;\n\t        skipUntilListener?: number;\n\t    };\n\t    stopPropagation(): void;\n\t    skipNextListeners(total: number): void;\n\t    skipUntilListener(id: number): void;\n", "}\n"]}
{"filename": "dist/cjs/events/request/success.d.ts", "chunked_list": ["import type { AxiosResponse } from 'axios';\n\timport RequestEvent from './request';\n\texport default class RequestSuccessEvent<T = unknown> extends RequestEvent {\n\t    relatedEvent: RequestEvent<T>;\n\t    static NAME: string;\n\t    constructor(relatedEvent: RequestEvent<T>);\n\t    get response(): AxiosResponse<T>;\n\t    get data(): T;\n\t}\n"]}
{"filename": "dist/cjs/events/request/error.d.ts", "chunked_list": ["import type { AxiosError } from 'axios';\n\timport RequestEvent from './request';\n\texport default class RequestErrorEvent<T = unknown> extends RequestEvent<T> {\n\t    relatedEvent: RequestEvent<T>;\n\t    static NAME: string;\n\t    constructor(relatedEvent: RequestEvent<T>);\n\t    get error(): AxiosError;\n\t    get response(): import(\"axios\").AxiosResponse<unknown, any> | undefined;\n\t    get data(): unknown;\n\t}\n"]}
{"filename": "dist/cjs/events/request/done.d.ts", "chunked_list": ["import RequestEvent from './request';\n\timport RequestSuccessEvent from './success';\n\timport type RequestErrorEvent from './error';\n\texport default class RequestDoneEvent<T = unknown> extends RequestEvent {\n\t    relatedEvent: RequestSuccessEvent<T> | RequestErrorEvent<T>;\n\t    static NAME: string;\n\t    constructor(relatedEvent: RequestSuccessEvent<T> | RequestErrorEvent<T>);\n\t    get success(): boolean;\n\t    get result(): import(\"axios\").AxiosResponse<any, any> | import(\"axios\").AxiosError<unknown, any> | undefined;\n\t    get data(): unknown;\n", "}\n"]}
{"filename": "dist/cjs/events/request/request.d.ts", "chunked_list": ["import Event from '../event';\n\timport type Request from '../../services/request/request';\n\timport type { KlientRequestConfig } from '../../services/request/request';\n\texport default class RequestEvent<T = unknown> extends Event {\n\t    request: Request<T>;\n\t    static NAME: string;\n\t    constructor(request: Request<T>);\n\t    get config(): KlientRequestConfig;\n\t    get context(): {\n\t        [x: string]: any;\n", "    };\n\t}\n"]}
{"filename": "dist/cjs/events/request/cancel.d.ts", "chunked_list": ["import RequestEvent from './request';\n\texport default class RequestCancelEvent<T = unknown> extends RequestEvent {\n\t    relatedEvent: RequestEvent<T>;\n\t    static NAME: string;\n\t    constructor(relatedEvent: RequestEvent<T>);\n\t}\n"]}
{"filename": "dist/cjs/services/bag/bag.d.ts", "chunked_list": ["import { Watchable, WatchCallback } from './watch';\n\tdeclare type BagItems = Record<string, unknown>;\n\texport default class Bag implements BagItems, Watchable {\n\t    [x: string]: unknown;\n\t    constructor(items?: BagItems);\n\t    get watchers(): Record<string, {\n\t        callback: WatchCallback<unknown, unknown>;\n\t        deep: boolean;\n\t    }[]>;\n\t    has(path: string): boolean;\n", "    get(path: string): any;\n\t    all(): import(\"../../toolbox/object\").AnyObject;\n\t    set(path: string, value: unknown): this;\n\t    merge(...items: BagItems[]): this;\n\t    watch(path: string, onChange: WatchCallback, deep?: boolean): this;\n\t    unwatch(path: string, onChange: WatchCallback): this;\n\t}\n\texport {};\n"]}
{"filename": "dist/cjs/services/bag/watch.d.ts", "chunked_list": ["export declare type Watchable = object;\n\texport declare type WatchCallback<T = unknown, Z = T> = (next: T, prev: Z) => void;\n\tdeclare type WatcherItem = {\n\t    callback: WatchCallback;\n\t    deep: boolean;\n\t};\n\texport declare function getWatchers(watchable: Watchable): Record<string, WatcherItem[]>;\n\texport declare function watch<T extends Watchable>(watchable: T, path: string, onChange: WatchCallback, deep: boolean): T;\n\texport declare function unwatch<T extends Watchable>(watchable: T, path: string, onChange: WatchCallback): T;\n\texport declare function invokeWatchers<T extends Watchable>(watchable: T, next: object, prev: object): T;\n", "export {};\n"]}
{"filename": "dist/cjs/services/dispatcher/listener.d.ts", "chunked_list": ["import type Event from '../../events/event';\n\timport type { Callback } from './dispatcher';\n\texport default class Listener<T extends Event> {\n\t    readonly callback: Callback<T>;\n\t    readonly priority: number;\n\t    readonly once: boolean;\n\t    readonly id: number;\n\t    constructor(callback: Callback<T>, priority: number, once: boolean, id: number);\n\t    invoke(event: T): Promise<void>;\n\t}\n"]}
{"filename": "dist/cjs/services/dispatcher/dispatcher.d.ts", "chunked_list": ["import Event from '../../events/event';\n\timport Listener from './listener';\n\timport type Klient from '../../klient';\n\texport declare type Callback<T extends Event> = (e: T) => Promise<void> | void;\n\texport declare type Listeners = {\n\t    [event: string]: Listener<never>[];\n\t};\n\texport default class Dispatcher {\n\t    protected readonly klient: Klient;\n\t    readonly listeners: Listeners;\n", "    constructor(klient: Klient);\n\t    on<T extends Event>(event: string, callback: Callback<T>, priority?: number, once?: boolean): this;\n\t    once<T extends Event>(event: string, callback: Callback<T>, priority?: number): this;\n\t    off<T extends Event>(event: string, callback: Callback<T>): this;\n\t    dispatch(e: Event, abortOnFailure?: boolean): Promise<void>;\n\t    protected findListenerIndex<T extends Event>(event: string, callback: Callback<T>): number | undefined;\n\t    protected static handleListenerSkipping(event: Event, listener: Listener<never>): boolean | void;\n\t    protected debug(action: string, relatedEvent: Event, handler: Listener<never> | Listener<never>[], error?: Error | null): void;\n\t}\n"]}
{"filename": "dist/cjs/services/request/factory.d.ts", "chunked_list": ["import type Klient from '../../klient';\n\timport Request from './request';\n\timport type { KlientRequestConfig } from './request';\n\texport default class RequestFactory {\n\t    protected readonly klient: Klient;\n\t    model: typeof Request;\n\t    readonly requests: Request[];\n\t    constructor(klient: Klient);\n\t    request<T = unknown>(urlOrConfig: KlientRequestConfig | string): Request<T>;\n\t    file(urlOrConfig: KlientRequestConfig | string): Promise<Blob>;\n", "    cancelPendingRequests(): this;\n\t    createRequest<T = unknown>(urlOrConfig: KlientRequestConfig | string): Request<T>;\n\t    isCancel(e: Error): boolean;\n\t    protected prepare(config: KlientRequestConfig): KlientRequestConfig;\n\t    protected removePendingRequest(request: Request): void;\n\t}\n"]}
{"filename": "dist/cjs/services/request/request.d.ts", "chunked_list": ["import type { AxiosResponse, AxiosError, AxiosRequestConfig, AxiosPromise } from 'axios';\n\timport RequestEvent from '../../events/request/request';\n\timport RequestSuccessEvent from '../../events/request/success';\n\timport RequestErrorEvent from '../../events/request/error';\n\timport RequestCancelEvent from '../../events/request/cancel';\n\timport type Klient from '../..';\n\texport declare type ResolveRequest = (response: AxiosResponse) => void;\n\texport declare type RejectRequest = (error: AxiosError) => void;\n\texport declare type RequestCallback = (resolve: ResolveRequest, reject: RejectRequest) => void;\n\tdeclare type PromiseCallbacks = {\n", "    resolve: ResolveRequest;\n\t    reject: RejectRequest;\n\t};\n\tdeclare type RequestEventTypes = typeof RequestSuccessEvent | typeof RequestErrorEvent | typeof RequestCancelEvent;\n\tdeclare type RequestContext = Record<string, any>;\n\texport interface KlientRequestConfig extends AxiosRequestConfig {\n\t    context?: RequestContext;\n\t}\n\texport default class Request<T = unknown> extends Promise<AxiosResponse<T>> {\n\t    context: RequestContext;\n", "    config: KlientRequestConfig;\n\t    result?: AxiosError | AxiosResponse;\n\t    handler: (config: AxiosRequestConfig) => AxiosPromise<T>;\n\t    protected klient: Klient;\n\t    protected callbacks: PromiseCallbacks;\n\t    protected readonly primaryEvent: RequestEvent<T>;\n\t    protected readonly abortController: AbortController;\n\t    protected constructor(callback: RequestCallback);\n\t    static new<T>({ context, ...axiosConfig }: KlientRequestConfig, klient: Klient): Request<T>;\n\t    static isCancel(e: Error): boolean;\n", "    cancel(): this;\n\t    execute(): this;\n\t    protected doRequest(): this;\n\t    protected resolve(response: AxiosResponse<T>): Promise<void>;\n\t    protected reject(error: AxiosError): Promise<void>;\n\t    protected dispatchResultEvent(EventClass: RequestEventTypes): Promise<void>;\n\t    protected get dispatcher(): import(\"../..\").Dispatcher;\n\t}\n\texport {};\n"]}
{"filename": "src/parameters.ts", "chunked_list": ["import type { AxiosRequestConfig } from 'axios';\n\texport interface ExtendableParameters {\n\t  [_prop: string]: unknown;\n\t}\n\texport interface Parameters extends ExtendableParameters {\n\t  url?: string;\n\t  extensions?: string[];\n\t  request?: AxiosRequestConfig;\n\t  debug?: boolean;\n\t}\n", "export const defaultParameters: Parameters = {\n\t  url: undefined,\n\t  extensions: undefined,\n\t  request: undefined,\n\t  debug: false\n\t};\n"]}
{"filename": "src/klient.ts", "chunked_list": ["import Bag from './services/bag/bag';\n\timport Dispatcher from './services/dispatcher/dispatcher';\n\timport RequestFactory from './services/request/factory';\n\timport Extensions from './extensions';\n\timport { defaultParameters } from './parameters';\n\timport type Event from './events/event';\n\timport type Request from './services/request/request';\n\timport type { KlientRequestConfig } from './services/request/request';\n\timport type { Callback } from './services/dispatcher/dispatcher';\n\timport type { Parameters } from './parameters';\n", "export default class Klient<P extends Parameters = Parameters> {\n\t  readonly extensions: string[] = [];\n\t  readonly parameters = new Bag(defaultParameters);\n\t  readonly services = new Bag();\n\t  constructor(urlOrParams?: P | string) {\n\t    let parameters: Parameters = {};\n\t    if (typeof urlOrParams === 'string') {\n\t      parameters.url = urlOrParams;\n\t    } else if (urlOrParams && typeof urlOrParams === 'object') {\n\t      parameters = urlOrParams;\n", "    }\n\t    this.parameters.merge(parameters);\n\t    // prettier-ignore\n\t    this.services\n\t      .set('klient', this)\n\t      .set('dispatcher', new Dispatcher(this))\n\t      .set('factory', new RequestFactory(this));\n\t    this.load(this.parameters.get('extensions') as string[] | undefined);\n\t  }\n\t  /** === Common parameters === */\n", "  get url(): string | undefined {\n\t    return this.parameters.get('url');\n\t  }\n\t  get debug(): boolean {\n\t    return Boolean(this.parameters.get('debug'));\n\t  }\n\t  /** === Common services === */\n\t  get factory(): RequestFactory {\n\t    return this.services.get('factory') as RequestFactory;\n\t  }\n", "  get dispatcher(): Dispatcher {\n\t    return this.services.get('dispatcher') as Dispatcher;\n\t  }\n\t  /** === Extensions === */\n\t  extends(property: string, value: unknown, writable = false): this {\n\t    return Object.defineProperty(this, property, { writable, value });\n\t  }\n\t  load(names?: string[]): this {\n\t    Extensions.load(this, names);\n\t    return this;\n", "  }\n\t  /** === Dispatcher/Events === */\n\t  on<T extends Event>(event: string, callback: Callback<T>, priority = 0, once = false): this {\n\t    this.dispatcher.on(event, callback, priority, once);\n\t    return this;\n\t  }\n\t  once<T extends Event>(event: string, callback: Callback<T>, priority = 0): this {\n\t    this.dispatcher.once(event, callback, priority);\n\t    return this;\n\t  }\n", "  off<T extends Event>(event: string, callback: Callback<T>): this {\n\t    this.dispatcher.off(event, callback);\n\t    return this;\n\t  }\n\t  /** === Request === */\n\t  request<T = unknown>(urlOrConfig: KlientRequestConfig | string): Request<T> {\n\t    return this.factory.request(urlOrConfig);\n\t  }\n\t  get<T = unknown>(url: string, config?: KlientRequestConfig): Request<T> {\n\t    return this.request<T>({ ...config, method: 'GET', url });\n", "  }\n\t  post<T = unknown>(url: string, data: unknown, config?: KlientRequestConfig): Request<T> {\n\t    return this.request<T>({ ...config, method: 'POST', url, data });\n\t  }\n\t  put<T = unknown>(url: string, data: unknown, config?: KlientRequestConfig): Request<T> {\n\t    return this.request<T>({ ...config, method: 'PUT', url, data });\n\t  }\n\t  patch<T = unknown>(url: string, data: unknown, config?: KlientRequestConfig): Request<T> {\n\t    return this.request<T>({ ...config, method: 'PATCH', url, data });\n\t  }\n", "  delete<T = unknown>(url: string, config?: KlientRequestConfig): Request<T> {\n\t    return this.request<T>({ ...config, method: 'DELETE', url });\n\t  }\n\t  head<T = unknown>(url: string, config?: KlientRequestConfig): Request<T> {\n\t    return this.request<T>({ ...config, method: 'HEAD', url });\n\t  }\n\t  options<T = unknown>(url: string, config?: KlientRequestConfig): Request<T> {\n\t    return this.request<T>({ ...config, method: 'OPTIONS', url });\n\t  }\n\t  file(urlOrConfig: KlientRequestConfig | string): Promise<Blob> {\n", "    return this.factory.file(urlOrConfig);\n\t  }\n\t  cancelPendingRequests(): this {\n\t    this.factory.cancelPendingRequests();\n\t    return this;\n\t  }\n\t  isCancel(e: Error) {\n\t    return this.factory.isCancel(e);\n\t  }\n\t}\n"]}
{"filename": "src/index.ts", "chunked_list": ["import Klient from './klient';\n\texport { AxiosError } from 'axios';\n\texport { default as Extensions } from './extensions';\n\texport { default as Bag } from './services/bag/bag';\n\texport { default as Dispatcher } from './services/dispatcher/dispatcher';\n\texport { default as RequestFactory } from './services/request/factory';\n\texport { default as Request } from './services/request/request';\n\texport { default as Event } from './events/event';\n\texport { default as DebugEvent } from './events/debug';\n\texport { default as RequestEvent } from './events/request/request';\n", "export { default as RequestSuccessEvent } from './events/request/success';\n\texport { default as RequestErrorEvent } from './events/request/error';\n\texport { default as RequestCancelEvent } from './events/request/cancel';\n\texport { default as RequestDoneEvent } from './events/request/done';\n\texport type { Parameters } from './parameters';\n\texport type { KlientRequestConfig } from './services/request/request';\n\texport default Klient;\n"]}
{"filename": "src/extensions.ts", "chunked_list": ["import type Klient from '.';\n\texport type Extension = {\n\t  name: string;\n\t  initialize: (klient: Klient) => void;\n\t};\n\tclass Extensions extends Array<Extension> {\n\t  load(klient: Klient, extensions?: string[]): void {\n\t    for (let i = 0, len = this.length; i < len; i += 1) {\n\t      const { name, initialize } = this[i];\n\t      if (!klient.extensions.includes(name) && (!extensions || extensions.includes(name))) {\n", "        initialize(klient);\n\t        klient.extensions.push(name);\n\t      }\n\t    }\n\t  }\n\t}\n\texport default new Extensions();\n"]}
{"filename": "src/toolbox/object.ts", "chunked_list": ["export type AnyObject = Record<string, unknown>;\n\t/**\n\t * Check if a value is a native JS object\n\t */\n\texport function isPlainObject(value: unknown) {\n\t  return value !== null && typeof value === 'object' && value.constructor.name === 'Object';\n\t}\n\t/**\n\t * Check if a value is a native JS array\n\t */\n", "export function isPlainArray(value: unknown) {\n\t  return Array.isArray(value) && value.constructor.name === 'Array';\n\t}\n\t/**\n\t * Deep clone object properties (traverse only native plain objects)\n\t */\n\texport function softClone(obj: AnyObject) {\n\t  const values: AnyObject = {};\n\t  Object.keys(obj).forEach((prop) => {\n\t    const value = obj[prop];\n", "    if (isPlainObject(value)) {\n\t      values[prop] = softClone(value as AnyObject);\n\t    } else if (isPlainArray(value)) {\n\t      values[prop] = (value as []).map((b) => (isPlainObject(b) ? softClone(b) : b));\n\t    } else {\n\t      values[prop] = value;\n\t    }\n\t  });\n\t  return values;\n\t}\n"]}
{"filename": "src/events/debug.ts", "chunked_list": ["import Event from './event';\n\timport type Listener from '../services/dispatcher/listener';\n\texport default class DebugEvent extends Event {\n\t  static NAME = 'debug';\n\t  constructor(\n\t    public action: string,\n\t    public relatedEvent: Event,\n\t    public handler: Listener<never> | Listener<never>[],\n\t    public error: Error | null\n\t  ) {\n", "    super();\n\t  }\n\t}\n"]}
{"filename": "src/events/event.ts", "chunked_list": ["export default class Event {\n\t  static NAME = 'event';\n\t  readonly dispatch: {\n\t    propagation: boolean;\n\t    skipNextListeners: number;\n\t    skipUntilListener?: number;\n\t  } = {\n\t    propagation: true,\n\t    skipNextListeners: 0,\n\t    skipUntilListener: undefined\n", "  };\n\t  stopPropagation() {\n\t    this.dispatch.propagation = false;\n\t  }\n\t  skipNextListeners(total: number) {\n\t    this.dispatch.skipNextListeners = total;\n\t  }\n\t  skipUntilListener(id: number) {\n\t    this.dispatch.skipUntilListener = id;\n\t  }\n", "}\n"]}
{"filename": "src/events/request/cancel.ts", "chunked_list": ["import RequestEvent from './request';\n\texport default class RequestCancelEvent<T = unknown> extends RequestEvent {\n\t  static NAME = 'request:cancel';\n\t  constructor(public relatedEvent: RequestEvent<T>) {\n\t    super(relatedEvent.request);\n\t  }\n\t}\n"]}
{"filename": "src/events/request/done.ts", "chunked_list": ["import RequestEvent from './request';\n\timport RequestSuccessEvent from './success';\n\timport type RequestErrorEvent from './error';\n\texport default class RequestDoneEvent<T = unknown> extends RequestEvent {\n\t  static NAME = 'request:done';\n\t  constructor(public relatedEvent: RequestSuccessEvent<T> | RequestErrorEvent<T>) {\n\t    super(relatedEvent.request);\n\t  }\n\t  get success() {\n\t    return this.relatedEvent instanceof RequestSuccessEvent;\n", "  }\n\t  get result() {\n\t    return this.request.result;\n\t  }\n\t  get data() {\n\t    return this.relatedEvent.data;\n\t  }\n\t}\n"]}
{"filename": "src/events/request/success.ts", "chunked_list": ["import type { AxiosResponse } from 'axios';\n\timport RequestEvent from './request';\n\texport default class RequestSuccessEvent<T = unknown> extends RequestEvent {\n\t  static NAME = 'request:success';\n\t  constructor(public relatedEvent: RequestEvent<T>) {\n\t    super(relatedEvent.request);\n\t  }\n\t  get response(): AxiosResponse<T> {\n\t    return this.request.result as AxiosResponse<T>;\n\t  }\n", "  get data() {\n\t    return this.response.data;\n\t  }\n\t}\n"]}
{"filename": "src/events/request/error.ts", "chunked_list": ["import type { AxiosError } from 'axios';\n\timport RequestEvent from './request';\n\texport default class RequestErrorEvent<T = unknown> extends RequestEvent<T> {\n\t  static NAME = 'request:error';\n\t  constructor(public relatedEvent: RequestEvent<T>) {\n\t    super(relatedEvent.request);\n\t  }\n\t  get error(): AxiosError {\n\t    return this.request.result as AxiosError;\n\t  }\n", "  get response() {\n\t    return this.error.response;\n\t  }\n\t  get data() {\n\t    return this.response?.data;\n\t  }\n\t}\n"]}
{"filename": "src/events/request/request.ts", "chunked_list": ["import Event from '../event';\n\timport type Request from '../../services/request/request';\n\timport type { KlientRequestConfig } from '../../services/request/request';\n\texport default class RequestEvent<T = unknown> extends Event {\n\t  static NAME = 'request';\n\t  constructor(public request: Request<T>) {\n\t    super();\n\t  }\n\t  get config(): KlientRequestConfig {\n\t    return this.request.config;\n", "  }\n\t  get context() {\n\t    return this.request.context;\n\t  }\n\t}\n"]}
{"filename": "src/services/bag/watch.ts", "chunked_list": ["import * as objectPath from 'object-path';\n\timport * as deepDiff from 'deep-diff';\n\texport type Watchable = object;\n\texport type WatchCallback<T = unknown, Z = T> = (next: T, prev: Z) => void;\n\ttype WatcherItem = { callback: WatchCallback; deep: boolean };\n\t/**\n\t * Each watchable object is stored with a generated ID\n\t */\n\tconst instances: Record<string, Watchable> = {};\n\t/**\n", " * All watchers attached to watchable objects are stored as described below :\n\t *\n\t * watchers = {\n\t *   'watchableObjectID: {          // Storage is accessible with Instance ID\n\t *     'path.to.property': [        // Watchers are grouped by target path\n\t *         { callback, deep },\n\t *     ]\n\t *   }\n\t * }\n\t */\n", "const watchers: Record<string, Record<string, WatcherItem[]>> = {};\n\t/**\n\t * Determine the instance ID for given watchable object.\n\t */\n\tfunction getInstanceId(watchable: Watchable) {\n\t  const ids = Object.keys(instances);\n\t  let id = null;\n\t  for (let i = 0, len = ids.length; i < len; i += 1) {\n\t    if (instances[ids[i]] === watchable) {\n\t      id = ids[i];\n", "      break;\n\t    }\n\t  }\n\t  if (id === null) {\n\t    id = Math.random().toString(36).substring(2);\n\t    instances[id] = watchable;\n\t  }\n\t  return id;\n\t}\n\t/**\n", " * Extract watchers collection, grouped by path, for given watchable object\n\t */\n\texport function getWatchers(watchable: Watchable) {\n\t  const id = getInstanceId(watchable);\n\t  if (!watchers[id]) {\n\t    watchers[id] = {};\n\t  }\n\t  return watchers[id];\n\t}\n\t/**\n", " * Register callback to listen changes made on specific path of given watchable object\n\t */\n\texport function watch<T extends Watchable>(watchable: T, path: string, onChange: WatchCallback, deep: boolean): T {\n\t  const id = getInstanceId(watchable);\n\t  watchers[id] = getWatchers(watchable);\n\t  const collection = watchers[id][path] || [];\n\t  for (let i = 0, len = collection.length; i < len; i += 1) {\n\t    if (collection[i].callback === onChange) {\n\t      return watchable;\n\t    }\n", "  }\n\t  collection.push({ callback: onChange, deep });\n\t  watchers[id][path] = collection;\n\t  return watchable;\n\t}\n\t/**\n\t * Unregister watcher callback for given path\n\t */\n\texport function unwatch<T extends Watchable>(watchable: T, path: string, onChange: WatchCallback): T {\n\t  const id = getInstanceId(watchable);\n", "  watchers[id] = getWatchers(watchable);\n\t  const collection = watchers[id][path] || [];\n\t  let index: number | null = null;\n\t  for (let i = 0, len = collection.length; i < len; i += 1) {\n\t    if (collection[i].callback === onChange) {\n\t      index = i;\n\t      break;\n\t    }\n\t  }\n\t  if (index === null) {\n", "    return watchable;\n\t  }\n\t  collection.splice(index, 1);\n\t  watchers[id][path] = collection;\n\t  return watchable;\n\t}\n\t/**\n\t * Invoke all watchers attached to given watchable object with prev and next state\n\t */\n\texport function invokeWatchers<T extends Watchable>(watchable: T, next: object, prev: object): T {\n", "  const watched = getWatchers(watchable);\n\t  const watchedPaths = Object.keys(watched);\n\t  if (watchedPaths.length === 0) {\n\t    return watchable;\n\t  }\n\t  const changedPaths = deepDiff(prev, next)?.map((diff) => (diff.path as string[]).join('.'));\n\t  const invoked: WatcherItem[] = [];\n\t  changedPaths?.forEach((path) => {\n\t    watchedPaths.forEach((targetPath) => {\n\t      if (!path.startsWith(targetPath)) return;\n", "      watched[targetPath].forEach((watcher) => {\n\t        if ((path === targetPath || watcher.deep) && !invoked.includes(watcher)) {\n\t          watcher.callback(objectPath.get(next, targetPath), objectPath.get(prev, targetPath));\n\t          invoked.push(watcher);\n\t        }\n\t      });\n\t    });\n\t  });\n\t  return watchable;\n\t}\n"]}
{"filename": "src/services/bag/bag.ts", "chunked_list": ["import * as deepmerge from 'deepmerge';\n\timport * as objectPath from 'object-path';\n\timport { isPlainObject, isPlainArray, softClone } from '../../toolbox/object';\n\timport { watch, unwatch, invokeWatchers, getWatchers, Watchable, WatchCallback } from './watch';\n\ttype BagItems = Record<string, unknown>;\n\texport default class Bag implements BagItems, Watchable {\n\t  [x: string]: unknown;\n\t  constructor(items: BagItems = {}) {\n\t    Object.keys(items).forEach((key) => {\n\t      this[key] = items[key];\n", "    });\n\t  }\n\t  get watchers() {\n\t    return getWatchers(this);\n\t  }\n\t  has(path: string) {\n\t    return objectPath.get(this, path) !== undefined;\n\t  }\n\t  get(path: string) {\n\t    return objectPath.get(this.all(), path);\n", "  }\n\t  all() {\n\t    return softClone(this);\n\t  }\n\t  set(path: string, value: unknown): this {\n\t    const prevState = this.all();\n\t    objectPath.set(this, path, value);\n\t    return invokeWatchers(this, this.all(), prevState);\n\t  }\n\t  merge(...items: BagItems[]): this {\n", "    const prevState = this.all();\n\t    const nextState = deepmerge.all<BagItems>([this.all(), ...items], {\n\t      arrayMerge: (_destinationArray: unknown[], sourceArray: unknown[]) => sourceArray,\n\t      isMergeableObject: (o: object) => isPlainArray(o) || isPlainObject(o)\n\t    });\n\t    Object.keys(nextState).forEach((key) => {\n\t      this[key] = nextState[key];\n\t    });\n\t    return invokeWatchers(this, nextState, prevState);\n\t  }\n", "  watch(path: string, onChange: WatchCallback, deep = false): this {\n\t    return watch(this, path, onChange, deep);\n\t  }\n\t  unwatch(path: string, onChange: WatchCallback): this {\n\t    return unwatch(this, path, onChange);\n\t  }\n\t}\n"]}
{"filename": "src/services/dispatcher/dispatcher.ts", "chunked_list": ["import Event from '../../events/event';\n\timport DebugEvent from '../../events/debug';\n\timport Listener from './listener';\n\timport type Klient from '../../klient';\n\texport type Callback<T extends Event> = (e: T) => Promise<void> | void;\n\texport type Listeners = { [event: string]: Listener<never>[] };\n\texport default class Dispatcher {\n\t  readonly listeners: Listeners = {};\n\t  constructor(protected readonly klient: Klient) {}\n\t  on<T extends Event>(event: string, callback: Callback<T>, priority = 0, once = false): this {\n", "    // Avoid duplication\n\t    if (this.findListenerIndex(event, callback) !== undefined) {\n\t      return this;\n\t    }\n\t    // Initialize listeners collection if not exists\n\t    this.listeners[event] = this.listeners[event] || [];\n\t    // Get reference to array containing listeners\n\t    const listeners = this.listeners[event];\n\t    // Build listener id (incremental)\n\t    const id = listeners.length ? Math.max(...listeners.map((l) => l.id)) + 1 : 0;\n", "    // Register the listener\n\t    listeners.push(new Listener(callback, priority, once, id));\n\t    // Listener are sorted in order they are defined\n\t    listeners.sort((a, b) => b.id - a.id);\n\t    // Sort by priority listeners binded to same event\n\t    // Lower priorities are first because we loop on collection from the end (see dispatch method)\n\t    listeners.sort((a, b) => a.priority - b.priority);\n\t    return this;\n\t  }\n\t  once<T extends Event>(event: string, callback: Callback<T>, priority = 0): this {\n", "    return this.on(event, callback, priority, true);\n\t  }\n\t  off<T extends Event>(event: string, callback: Callback<T>): this {\n\t    const index = this.findListenerIndex(event, callback);\n\t    if (index !== undefined) {\n\t      this.listeners[event].splice(index, 1);\n\t    }\n\t    return this;\n\t  }\n\t  /**\n", "   * Invoke all listeners attached to given event.\n\t   *\n\t   * @param abortOnFailure - Specify if listener failures must abort dispatch process.\n\t   */\n\t  async dispatch(e: Event, abortOnFailure = true): Promise<void> {\n\t    const event = (e.constructor as typeof Event).NAME;\n\t    const listeners = this.listeners[event] || [];\n\t    this.debug('start', e, listeners);\n\t    // Use inverse loop because we need to remove listeners callable once\n\t    for (let i = listeners.length - 1, listener = null; i >= 0; i -= 1) {\n", "      listener = listeners[i];\n\t      if (Dispatcher.handleListenerSkipping(e, listener)) {\n\t        this.debug('skipped', e, listener);\n\t        continue;\n\t      }\n\t      if (listener.once) {\n\t        this.listeners[event].splice(i, 1);\n\t      }\n\t      try {\n\t        this.debug('invoking', e, listener);\n", "        // Wait for listener whose return a promise\n\t        await listener.invoke(e as never); // eslint-disable-line no-await-in-loop\n\t        this.debug('invoked', e, listener);\n\t      } catch (err) {\n\t        this.debug('failed', e, listener, err as Error);\n\t        if (abortOnFailure) {\n\t          // Reject promise on \"abort on listener failure\" strategy\n\t          return Promise.reject(err);\n\t        }\n\t      }\n", "      if (!e.dispatch.propagation) {\n\t        this.debug('stopped', e, listener);\n\t        // Stop listeners invokation\n\t        break;\n\t      }\n\t    }\n\t    this.debug('end', e, listeners);\n\t    return Promise.resolve();\n\t  }\n\t  protected findListenerIndex<T extends Event>(event: string, callback: Callback<T>): number | undefined {\n", "    const listeners = this.listeners[event] || [];\n\t    for (let i = 0, len = listeners.length; i < len; i += 1) {\n\t      if (listeners[i].callback === callback) {\n\t        return i;\n\t      }\n\t    }\n\t    return undefined;\n\t  }\n\t  protected static handleListenerSkipping(event: Event, listener: Listener<never>): boolean | void {\n\t    const { skipNextListeners, skipUntilListener } = event.dispatch;\n", "    if (skipNextListeners > 0) {\n\t      event.dispatch.skipNextListeners -= 1;\n\t      return true;\n\t    }\n\t    if (skipUntilListener) {\n\t      if (listener.id === skipUntilListener) {\n\t        event.dispatch.skipUntilListener = undefined;\n\t        return;\n\t      }\n\t      return true;\n", "    }\n\t  }\n\t  protected debug(\n\t    action: string,\n\t    relatedEvent: Event,\n\t    handler: Listener<never> | Listener<never>[],\n\t    error: Error | null = null\n\t  ): void {\n\t    if (relatedEvent instanceof DebugEvent || !this.klient.debug) {\n\t      return;\n", "    }\n\t    this.dispatch(new DebugEvent(action, relatedEvent, handler, error), false);\n\t  }\n\t}\n"]}
{"filename": "src/services/dispatcher/listener.ts", "chunked_list": ["import type Event from '../../events/event';\n\timport type { Callback } from './dispatcher';\n\texport default class Listener<T extends Event> {\n\t  constructor(readonly callback: Callback<T>, readonly priority: number, readonly once: boolean, readonly id: number) {}\n\t  invoke(event: T): Promise<void> {\n\t    let result;\n\t    try {\n\t      result = this.callback(event);\n\t      if (!(result instanceof Promise)) {\n\t        result = Promise.resolve();\n", "      }\n\t    } catch (error) {\n\t      result = Promise.reject(error);\n\t    }\n\t    return result;\n\t  }\n\t}\n"]}
{"filename": "src/services/request/factory.ts", "chunked_list": ["import * as deepmerge from 'deepmerge';\n\timport type { AxiosRequestConfig } from 'axios';\n\timport type Klient from '../../klient';\n\timport Request from './request';\n\timport type { KlientRequestConfig } from './request';\n\texport default class RequestFactory {\n\t  model = Request;\n\t  // Requests are stocked during their execution only.\n\t  readonly requests: Request[] = [];\n\t  constructor(protected readonly klient: Klient) {}\n", "  request<T = unknown>(urlOrConfig: KlientRequestConfig | string): Request<T> {\n\t    return this.createRequest<T>(urlOrConfig).execute();\n\t  }\n\t  file(urlOrConfig: KlientRequestConfig | string): Promise<Blob> {\n\t    const config = deepmerge(\n\t      { responseType: 'blob', context: { action: 'file' } },\n\t      typeof urlOrConfig === 'string' ? { url: urlOrConfig } : urlOrConfig\n\t    );\n\t    return this.request<Blob>(config).then(({ data }) => data);\n\t  }\n", "  cancelPendingRequests(): this {\n\t    for (let i = 0, len = this.requests.length; i < len; i += 1) {\n\t      this.requests[i].cancel();\n\t    }\n\t    return this;\n\t  }\n\t  createRequest<T = unknown>(urlOrConfig: KlientRequestConfig | string): Request<T> {\n\t    const config = typeof urlOrConfig === 'string' ? { url: urlOrConfig } : urlOrConfig;\n\t    const request = this.model.new<T>(this.prepare(config), this.klient);\n\t    // Store request during pending state only\n", "    this.requests.push(request);\n\t    // Remove request when promise has been fulfilled\n\t    request\n\t      .then((r) => {\n\t        this.removePendingRequest(request);\n\t        return r;\n\t      })\n\t      .catch((e) => {\n\t        this.removePendingRequest(request);\n\t        return e;\n", "      });\n\t    return request;\n\t  }\n\t  isCancel(e: Error) {\n\t    return this.model.isCancel(e);\n\t  }\n\t  protected prepare(config: KlientRequestConfig): KlientRequestConfig {\n\t    return deepmerge.all([\n\t      { baseURL: this.klient.url },\n\t      (this.klient.parameters.get('request') as AxiosRequestConfig) || {},\n", "      config\n\t    ]);\n\t  }\n\t  protected removePendingRequest(request: Request) {\n\t    const i = this.requests.indexOf(request);\n\t    if (this.requests[i] instanceof Request) {\n\t      this.requests.splice(i, 1);\n\t    }\n\t  }\n\t}\n"]}
{"filename": "src/services/request/request.ts", "chunked_list": ["import axios from 'axios';\n\timport type { AxiosResponse, AxiosError, AxiosRequestConfig, AxiosPromise } from 'axios';\n\timport RequestEvent from '../../events/request/request';\n\timport RequestSuccessEvent from '../../events/request/success';\n\timport RequestErrorEvent from '../../events/request/error';\n\timport RequestDoneEvent from '../../events/request/done';\n\timport RequestCancelEvent from '../../events/request/cancel';\n\timport type Klient from '../..';\n\texport type ResolveRequest = (response: AxiosResponse) => void;\n\texport type RejectRequest = (error: AxiosError) => void;\n", "export type RequestCallback = (resolve: ResolveRequest, reject: RejectRequest) => void;\n\ttype PromiseCallbacks = { resolve: ResolveRequest; reject: RejectRequest };\n\ttype RequestEventTypes = typeof RequestSuccessEvent | typeof RequestErrorEvent | typeof RequestCancelEvent;\n\ttype RequestContext = Record<string, any>; // eslint-disable-line @typescript-eslint/no-explicit-any\n\texport interface KlientRequestConfig extends AxiosRequestConfig {\n\t  context?: RequestContext;\n\t}\n\t/**\n\t * Request is a Promise object able to dispatch events before/after axios execution.\n\t * Theses events allow to access and make action on request config/result at any step of execution.\n", " * The Request will be resolved/rejected only after all events be dispatched.\n\t *\n\t * The events workflow is describe below :\n\t *\n\t * 1) RequestEvent (dispatched with abortOnFailure strategy)\n\t * 2) Axios execution\n\t *    2.1) Optional : RequestCancelEvent - only if request is cancelled (will reject promise and skip next events)\n\t * 3) RequestSuccessEvent OR RequestErrorEvent\n\t * 4) RequestDoneEvent\n\t */\n", "export default class Request<T = unknown> extends Promise<AxiosResponse<T>> {\n\t  context: RequestContext = { action: 'request' };\n\t  config: KlientRequestConfig = {};\n\t  result?: AxiosError | AxiosResponse;\n\t  // Allow override axios execution\n\t  handler: (config: AxiosRequestConfig) => AxiosPromise<T> = axios;\n\t  protected klient!: Klient;\n\t  protected callbacks!: PromiseCallbacks;\n\t  protected readonly primaryEvent = new RequestEvent<T>(this);\n\t  protected readonly abortController = new AbortController();\n", "  protected constructor(callback: RequestCallback) {\n\t    super(callback);\n\t  }\n\t  static new<T>({ context, ...axiosConfig }: KlientRequestConfig, klient: Klient): Request<T> {\n\t    const callbacks = {} as PromiseCallbacks;\n\t    const request = new this<T>((resolve: ResolveRequest, reject: RejectRequest) => {\n\t      callbacks.resolve = resolve;\n\t      callbacks.reject = reject;\n\t    });\n\t    request.klient = klient;\n", "    request.config = axiosConfig;\n\t    request.callbacks = callbacks;\n\t    request.config.signal = request.abortController.signal;\n\t    request.context = { ...request.context, ...context };\n\t    return request;\n\t  }\n\t  static isCancel(e: Error) {\n\t    return axios.isCancel(e);\n\t  }\n\t  cancel(): this {\n", "    this.abortController.abort();\n\t    return this;\n\t  }\n\t  execute(): this {\n\t    this.dispatcher\n\t      .dispatch(this.primaryEvent)\n\t      .then(() => {\n\t        this.doRequest();\n\t      })\n\t      .catch((e) => {\n", "        this.reject(e);\n\t      });\n\t    return this;\n\t  }\n\t  protected doRequest(): this {\n\t    if (!this.result) {\n\t      this.handler(this.config)\n\t        .then((r) => {\n\t          this.resolve(r);\n\t        })\n", "        .catch((e) => {\n\t          this.reject(e);\n\t        });\n\t    }\n\t    return this;\n\t  }\n\t  protected resolve(response: AxiosResponse<T>): Promise<void> {\n\t    this.result = response;\n\t    return this.dispatchResultEvent(RequestSuccessEvent).then(() => {\n\t      this.callbacks.resolve(this.result as AxiosResponse<T>);\n", "    });\n\t  }\n\t  protected reject(error: AxiosError): Promise<void> {\n\t    this.result = error;\n\t    return this.dispatchResultEvent(Request.isCancel(error) ? RequestCancelEvent : RequestErrorEvent).then(() => {\n\t      this.callbacks.reject(this.result as AxiosError);\n\t    });\n\t  }\n\t  protected dispatchResultEvent(EventClass: RequestEventTypes): Promise<void> {\n\t    const event = new EventClass(this.primaryEvent);\n", "    return new Promise((resolve) => {\n\t      this.dispatcher.dispatch(event, false).then(() => {\n\t        if (event instanceof RequestCancelEvent) {\n\t          return resolve();\n\t        }\n\t        this.dispatcher.dispatch(new RequestDoneEvent(event), false).then(resolve);\n\t      });\n\t    });\n\t  }\n\t  protected get dispatcher() {\n", "    return this.klient.dispatcher;\n\t  }\n\t}\n"]}
{"filename": "src/__tests__/exports.test.ts", "chunked_list": ["import SourceExtensions from '../extensions';\n\timport SourceBag from '../services/bag/bag';\n\timport SourceDispatcher from '../services/dispatcher/dispatcher';\n\timport SourceRequestFactory from '../services/request/factory';\n\timport SourceRequest from '../services/request/request';\n\timport SourceEvent from '../events/event';\n\timport SourceDebugEvent from '../events/debug';\n\timport SourceRequestEvent from '../events/request/request';\n\timport SourceRequestSuccessEvent from '../events/request/success';\n\timport SourceRequestErrorEvent from '../events/request/error';\n", "import SourceRequestCancelEvent from '../events/request/cancel';\n\timport SourceRequestDoneEvent from '../events/request/done';\n\timport {\n\t  Extensions,\n\t  Bag,\n\t  Dispatcher,\n\t  RequestFactory,\n\t  Request,\n\t  Event,\n\t  DebugEvent,\n", "  RequestEvent,\n\t  RequestSuccessEvent,\n\t  RequestErrorEvent,\n\t  RequestCancelEvent,\n\t  RequestDoneEvent\n\t} from '..';\n\ttest('export', () => {\n\t  expect(Extensions).toBe(SourceExtensions);\n\t  expect(Bag).toBe(SourceBag);\n\t  expect(Dispatcher).toBe(SourceDispatcher);\n", "  expect(RequestFactory).toBe(SourceRequestFactory);\n\t  expect(Request).toBe(SourceRequest);\n\t  expect(Event).toBe(SourceEvent);\n\t  expect(DebugEvent).toBe(SourceDebugEvent);\n\t  expect(RequestEvent).toBe(SourceRequestEvent);\n\t  expect(RequestSuccessEvent).toBe(SourceRequestSuccessEvent);\n\t  expect(RequestErrorEvent).toBe(SourceRequestErrorEvent);\n\t  expect(RequestCancelEvent).toBe(SourceRequestCancelEvent);\n\t  expect(RequestDoneEvent).toBe(SourceRequestDoneEvent);\n\t});\n"]}
{"filename": "src/__tests__/parameters.test.ts", "chunked_list": ["import Klient, { Bag } from '..';\n\tclass Test {}\n\ttest('constructor', () => {\n\t  let klient = new Klient();\n\t  expect(klient.url).toBe(undefined);\n\t  expect(klient.debug).toBe(false);\n\t  klient = new Klient('http://localhost');\n\t  expect(klient.url).toBe('http://localhost');\n\t  klient = new Klient({\n\t    url: 'http://localhost',\n", "    debug: true,\n\t    request: {\n\t      headers: {\n\t        'Content-Type': 'application/json'\n\t      }\n\t    },\n\t    customParam: [new Test()]\n\t  });\n\t  const { parameters } = klient;\n\t  parameters.merge({\n", "    name: 'KlientTest',\n\t    customParam: [new Test(), new Test()]\n\t  });\n\t  expect(parameters.has('request')).toBe(true);\n\t  expect(parameters.has('request.headers')).toBe(true);\n\t  expect(parameters.has('request.headers.Content-Type')).toBe(true);\n\t  expect(parameters.has('request.headers.Content-type')).toBe(false);\n\t  expect(parameters.has('request.unknown')).toBe(false);\n\t  expect(klient.url).toBe('http://localhost');\n\t  expect(klient.debug).toBe(true);\n", "  expect(parameters.get('request.headers.Content-Type')).toBe('application/json');\n\t  expect(parameters).toBeInstanceOf(Bag);\n\t  const customParam = parameters.get('customParam');\n\t  expect(customParam).toBeInstanceOf(Array);\n\t  expect(customParam.length).toBe(2);\n\t  expect(customParam[0]).toBeInstanceOf(Test);\n\t  expect(customParam[1]).toBeInstanceOf(Test);\n\t  expect(parameters.all()).toBeInstanceOf(Object);\n\t  expect(parameters.all()).not.toBeInstanceOf(Bag);\n\t  expect(parameters.all().name).toBe('KlientTest');\n", "});\n"]}
{"filename": "src/__tests__/bag.test.ts", "chunked_list": ["import Klient from '..';\n\ttest('watch', () => {\n\t  const unclonable = new Klient();\n\t  const { parameters } = new Klient({\n\t    request: {\n\t      headers: {\n\t        'Content-Type': 'application/json'\n\t      }\n\t    },\n\t    arr: [{ prop: true }, unclonable]\n", "  });\n\t  const innerParams = parameters as any;\n\t  const clonedParams = parameters.all() as any;\n\t  expect(JSON.stringify(Object.keys(clonedParams))).toBe(\n\t    JSON.stringify(['url', 'extensions', 'request', 'debug', 'arr'])\n\t  );\n\t  expect(clonedParams.arr === innerParams).toBeFalsy();\n\t  expect(clonedParams.arr[0] === innerParams.arr[0]).toBeFalsy();\n\t  expect(clonedParams.arr[1] === innerParams.arr[1]).toBeTruthy();\n\t  const urlWatchSpy = jest.fn();\n", "  const requestWatchSpy = jest.fn();\n\t  parameters.watch('url', urlWatchSpy);\n\t  // Check duplication\n\t  parameters.watch('url', urlWatchSpy);\n\t  parameters.watch('request.headers.Content-Type', requestWatchSpy);\n\t  parameters.set('url', undefined);\n\t  parameters.set('url', 'http://localhost');\n\t  expect(urlWatchSpy).toBeCalledTimes(1);\n\t  expect(urlWatchSpy).toBeCalledWith('http://localhost', undefined);\n\t  parameters.set('request.headers', {});\n", "  expect(requestWatchSpy).toBeCalledWith(undefined, 'application/json');\n\t  parameters.merge({\n\t    request: {\n\t      headers: {\n\t        'Content-Type': 'application/xml'\n\t      }\n\t    }\n\t  });\n\t  expect(requestWatchSpy).toBeCalledWith('application/xml', undefined);\n\t});\n", "test('unwatch', () => {\n\t  const { parameters } = new Klient();\n\t  const testWatchSpy = jest.fn();\n\t  parameters.unwatch('test', () => undefined);\n\t  parameters.watch('test', testWatchSpy);\n\t  parameters.unwatch('test', testWatchSpy);\n\t  parameters.set('test', true);\n\t  expect(testWatchSpy).not.toBeCalled();\n\t});\n\ttest('watch:deep', () => {\n", "  const { parameters } = new Klient({\n\t    example: {\n\t      nested: {\n\t        test: true\n\t      }\n\t    }\n\t  });\n\t  const exampleDeepSpy = jest.fn();\n\t  const exampleSpy = jest.fn();\n\t  const exampleNestedSpy = jest.fn();\n", "  const exampleNestedDeepSpy = jest.fn();\n\t  const exampleNestedTestSpy = jest.fn();\n\t  parameters.watch('example', exampleSpy);\n\t  parameters.watch('example', exampleDeepSpy, true);\n\t  parameters.watch('example.nested', exampleNestedSpy);\n\t  parameters.watch('example.nested', exampleNestedDeepSpy, true);\n\t  parameters.watch('example.nested.test', exampleNestedTestSpy);\n\t  expect(parameters.watchers['example'].length).toBe(2);\n\t  expect(parameters.watchers['example.nested'].length).toBe(2);\n\t  expect(parameters.watchers['example.nested.test'].length).toBe(1);\n", "  parameters.set('example.nested.test', false);\n\t  expect(exampleSpy).not.toBeCalled();\n\t  expect(exampleNestedSpy).not.toBeCalled();\n\t  expect(exampleDeepSpy).toBeCalledWith(\n\t    {\n\t      nested: {\n\t        test: false\n\t      }\n\t    },\n\t    {\n", "      nested: {\n\t        test: true\n\t      }\n\t    }\n\t  );\n\t  expect(exampleNestedDeepSpy).toBeCalledWith({ test: false }, { test: true });\n\t  expect(exampleNestedTestSpy).toBeCalledWith(false, true);\n\t});\n"]}
{"filename": "src/__tests__/extension.test.ts", "chunked_list": ["import 'jest-extended';\n\timport { mockAxiosWithRestApi } from '@klient/testing';\n\timport Klient, { Extensions } from '..';\n\tjest.mock('axios');\n\tmockAxiosWithRestApi();\n\tinterface KlientExtended extends Klient {\n\t  writable: string;\n\t  readonly unwritable: boolean;\n\t}\n\ttest('extension:load', () => {\n", "  Extensions.push({\n\t    name: '@klient/test',\n\t    initialize: (klient) => {\n\t      klient.services.set('test', {\n\t        run() {\n\t          return true;\n\t        }\n\t      });\n\t      klient.parameters.set('test', true);\n\t      klient.extends('writable', 'something', true);\n", "      klient.extends('unwritable', true);\n\t    }\n\t  });\n\t  const klient = new Klient() as KlientExtended;\n\t  expect(klient.extensions.includes('@klient/test')).toBe(true);\n\t  expect(klient.services.get('test')).toBeDefined();\n\t  expect(klient.services.test).toBeDefined();\n\t  expect(klient.parameters.get('test')).toBe(true);\n\t  expect(klient.writable).toBe('something');\n\t  klient.writable = 'else';\n", "  expect(klient.writable).toBe('else');\n\t  try {\n\t    // eslint-disable-next-line\n\t    (klient as any).unwritable = false;\n\t    // Force to go in catch block\n\t    throw new Error('Property is writable');\n\t  } catch (e) {\n\t    expect((e as Error).message).toBe(\"Cannot assign to read only property 'unwritable' of object '#<Klient>'\");\n\t  }\n\t  const emptyKlient = new Klient({ extensions: [] });\n", "  expect(emptyKlient.extensions.includes('@klient/test')).toBe(false);\n\t  expect(emptyKlient.services.get('test')).toBeUndefined();\n\t  emptyKlient.load(['@klient/test']);\n\t  expect(emptyKlient.extensions.includes('@klient/test')).toBe(true);\n\t  expect(emptyKlient.services.get('test')).toBeDefined();\n\t});\n"]}
{"filename": "src/__tests__/listener.test.ts", "chunked_list": ["import 'jest-extended';\n\timport { mockAxiosWithRestApi } from '@klient/testing';\n\timport Klient from '..';\n\tjest.mock('axios');\n\tmockAxiosWithRestApi();\n\ttest('listener:on', async () => {\n\t  const klient = new Klient();\n\t  const spyRequestEvent = jest.fn();\n\t  klient.on('request', spyRequestEvent);\n\t  // Check duplication\n", "  klient.dispatcher.on('request', spyRequestEvent);\n\t  await klient.request('/posts');\n\t  expect(spyRequestEvent).toBeCalledTimes(1);\n\t  await klient.request('/posts');\n\t  expect(spyRequestEvent).toBeCalledTimes(2);\n\t});\n\ttest('listener:once', async () => {\n\t  const klient = new Klient();\n\t  const spyRequestEvent = jest.fn();\n\t  const spyRequestEvent2 = jest.fn();\n", "  const spyRequestEvent3 = jest.fn();\n\t  const spyRequestEventHigherPriority = jest.fn();\n\t  klient.on('request', spyRequestEvent2, 0, true);\n\t  klient.once('request', spyRequestEvent);\n\t  klient.once('request', spyRequestEventHigherPriority, 2);\n\t  klient.dispatcher.once('request', spyRequestEvent3);\n\t  await klient.request('/posts');\n\t  expect(spyRequestEvent).toBeCalledTimes(1);\n\t  expect(spyRequestEvent2).toBeCalledTimes(1);\n\t  expect(spyRequestEvent3).toBeCalledTimes(1);\n", "  expect(spyRequestEventHigherPriority).toBeCalledTimes(1);\n\t  expect(spyRequestEventHigherPriority).toHaveBeenCalledBefore(spyRequestEvent, false);\n\t  expect(spyRequestEvent2).toHaveBeenCalledBefore(spyRequestEvent, false);\n\t  await klient.request('/posts');\n\t  expect(spyRequestEvent).toBeCalledTimes(1);\n\t  expect(spyRequestEvent2).toBeCalledTimes(1);\n\t  expect(spyRequestEvent3).toBeCalledTimes(1);\n\t  expect(spyRequestEventHigherPriority).toBeCalledTimes(1);\n\t});\n\ttest('listener:off', async () => {\n", "  const klient = new Klient();\n\t  const spyRequestEvent = jest.fn();\n\t  klient.on('request', spyRequestEvent);\n\t  klient.off('request', spyRequestEvent);\n\t  klient.off('undefined', jest.fn());\n\t  await klient.request('/posts');\n\t  expect(spyRequestEvent).toBeCalledTimes(0);\n\t});\n\ttest('listener:priority', async () => {\n\t  const klient = new Klient();\n", "  const spyRequestEvent = jest.fn();\n\t  const spyRequestEventAfterFirst = jest.fn();\n\t  const spyRequestEventHigherPriority = jest.fn();\n\t  klient.on('request', spyRequestEvent);\n\t  klient.on('request', spyRequestEventAfterFirst);\n\t  klient.on('request', spyRequestEventHigherPriority, 2);\n\t  await klient.request('/posts');\n\t  expect(spyRequestEvent).toBeCalledTimes(1);\n\t  expect(spyRequestEventAfterFirst).toBeCalledTimes(1);\n\t  expect(spyRequestEventHigherPriority).toBeCalledTimes(1);\n", "  expect(spyRequestEvent).toHaveBeenCalledBefore(spyRequestEventAfterFirst, false);\n\t  expect(spyRequestEventHigherPriority).toHaveBeenCalledBefore(spyRequestEvent, false);\n\t});\n\ttest('listener:skip:stop-propagation', async () => {\n\t  const klient = new Klient();\n\t  const spyRequestEvent = jest.fn();\n\t  const spyRequestEventSkipped = jest.fn();\n\t  const spyAfterRequestEventSkipped = jest.fn();\n\t  const spyLastRequestEvent = jest.fn();\n\t  klient.on('request', (e) => {\n", "    spyRequestEvent();\n\t    e.stopPropagation();\n\t  });\n\t  klient.on('request', spyRequestEventSkipped);\n\t  klient.on('request', spyAfterRequestEventSkipped);\n\t  klient.on('request', spyLastRequestEvent);\n\t  await klient.request('/posts');\n\t  expect(spyRequestEvent).toBeCalledTimes(1);\n\t  expect(spyRequestEventSkipped).toBeCalledTimes(0);\n\t  expect(spyAfterRequestEventSkipped).toBeCalledTimes(0);\n", "  expect(spyLastRequestEvent).toBeCalledTimes(0);\n\t});\n\ttest('listener:skip:goto', async () => {\n\t  const klient = new Klient();\n\t  const spyRequestEvent = jest.fn();\n\t  const spyRequestEventSkipped = jest.fn();\n\t  const spyOtherRequestEventSkipped = jest.fn();\n\t  const spyLastRequestEvent = jest.fn();\n\t  klient.on('request', (e) => {\n\t    spyRequestEvent();\n", "    e.skipUntilListener(3);\n\t  });\n\t  klient.on('request', spyRequestEventSkipped);\n\t  klient.on('request', spyOtherRequestEventSkipped);\n\t  klient.on('request', spyLastRequestEvent);\n\t  await klient.request('/posts');\n\t  expect(spyRequestEvent).toBeCalledTimes(1);\n\t  expect(spyRequestEventSkipped).toBeCalledTimes(0);\n\t  expect(spyOtherRequestEventSkipped).toBeCalledTimes(0);\n\t  expect(spyLastRequestEvent).toBeCalledTimes(1);\n", "});\n\ttest('listener:skip:next-listeners', async () => {\n\t  const klient = new Klient();\n\t  const spyRequestEvent = jest.fn();\n\t  const spyRequestEventSkipped = jest.fn();\n\t  const spyOtherRequestEventSkipped = jest.fn();\n\t  const spyLastRequestEvent = jest.fn();\n\t  klient.on('request', (e) => {\n\t    spyRequestEvent();\n\t    e.skipNextListeners(2);\n", "  });\n\t  klient.on('request', spyRequestEventSkipped);\n\t  klient.on('request', spyOtherRequestEventSkipped);\n\t  klient.on('request', spyLastRequestEvent);\n\t  await klient.request('/posts');\n\t  expect(spyRequestEvent).toBeCalledTimes(1);\n\t  expect(spyRequestEventSkipped).toBeCalledTimes(0);\n\t  expect(spyOtherRequestEventSkipped).toBeCalledTimes(0);\n\t  expect(spyLastRequestEvent).toBeCalledTimes(1);\n\t});\n"]}
{"filename": "src/__tests__/event.test.ts", "chunked_list": ["import { mockAxiosWithRestApi } from '@klient/testing';\n\timport Klient, {\n\t  Request,\n\t  RequestEvent,\n\t  RequestSuccessEvent,\n\t  RequestCancelEvent,\n\t  RequestErrorEvent,\n\t  RequestDoneEvent,\n\t  AxiosError\n\t} from '..';\n", "jest.mock('axios');\n\tmockAxiosWithRestApi();\n\ttest('event:request', () => {\n\t  const klient = new Klient();\n\t  const config = {\n\t    url: '/posts',\n\t    context: { test: true }\n\t  };\n\t  const spyRequestEvent = jest.fn();\n\t  klient.on('request', (e: RequestEvent) => {\n", "    spyRequestEvent(e.context.action, e.config.url, e.context.test, e.request);\n\t  });\n\t  return klient\n\t    .request(config)\n\t    .then(() => {\n\t      expect(spyRequestEvent).toBeCalledWith('request', config.url, true, expect.any(Request));\n\t    })\n\t    .catch((e) => {\n\t      console.log(e);\n\t      throw e;\n", "    });\n\t});\n\ttest('event:request:success', () => {\n\t  const klient = new Klient();\n\t  const spyRequestSuccessEvent = jest.fn();\n\t  klient.on('request:success', (e: RequestSuccessEvent) => {\n\t    spyRequestSuccessEvent(e.relatedEvent, e.response, e.data);\n\t  });\n\t  return klient\n\t    .request('/posts')\n", "    .then(() => {\n\t      expect(spyRequestSuccessEvent).toBeCalledWith(\n\t        expect.any(RequestEvent),\n\t        expect.objectContaining({ status: 200, data: expect.any(Array) }),\n\t        expect.any(Array)\n\t      );\n\t    })\n\t    .catch((e) => {\n\t      console.log(e);\n\t      throw e;\n", "    });\n\t});\n\ttest('event:request:error', () => {\n\t  const klient = new Klient();\n\t  const spyRequestErrorEvent = jest.fn();\n\t  klient.on('request:error', (e: RequestErrorEvent) => {\n\t    spyRequestErrorEvent(e.relatedEvent, e.error, e.response, e.data);\n\t  });\n\t  return klient\n\t    .request('/notfound')\n", "    .then(() => {\n\t      throw new Error('This request must failed');\n\t    })\n\t    .catch(() => {\n\t      expect(spyRequestErrorEvent).toBeCalledWith(\n\t        expect.any(RequestEvent),\n\t        expect.any(AxiosError),\n\t        expect.objectContaining({\n\t          status: 404,\n\t          data: expect.any(Object)\n", "        }),\n\t        expect.objectContaining({\n\t          error: expect.any(String)\n\t        })\n\t      );\n\t    });\n\t});\n\ttest('event:request:done', async () => {\n\t  const klient = new Klient();\n\t  const spyRequestDoneEvent = jest.fn();\n", "  klient.on('request:done', (e: RequestDoneEvent) => {\n\t    spyRequestDoneEvent(e.relatedEvent, e.success, e.result, e.data);\n\t  });\n\t  await klient\n\t    .request('/notfound')\n\t    .then(() => {\n\t      throw new Error('This request must failed');\n\t    })\n\t    .catch(() => {\n\t      expect(spyRequestDoneEvent).toBeCalledWith(\n", "        expect.any(RequestErrorEvent),\n\t        false,\n\t        expect.any(AxiosError),\n\t        expect.objectContaining({\n\t          error: expect.any(String)\n\t        })\n\t      );\n\t    });\n\t  await klient\n\t    .request('/posts')\n", "    .then(() => {\n\t      expect(spyRequestDoneEvent).toHaveBeenLastCalledWith(\n\t        expect.any(RequestSuccessEvent),\n\t        true,\n\t        expect.objectContaining({ status: 200, data: expect.any(Array) }),\n\t        expect.any(Array)\n\t      );\n\t    })\n\t    .catch((e) => {\n\t      console.log(e);\n", "      throw e;\n\t    });\n\t});\n\ttest('event:request:cancel', async () => {\n\t  const klient = new Klient();\n\t  const spyRequestCancelEvent = jest.fn();\n\t  klient.on('request', (e: RequestEvent) => {\n\t    e.request.cancel();\n\t  });\n\t  klient.on('request:cancel', (e: RequestCancelEvent) => {\n", "    spyRequestCancelEvent(e.relatedEvent);\n\t  });\n\t  await klient\n\t    .request('/posts')\n\t    .then(() => {\n\t      throw new Error('This request must failed');\n\t    })\n\t    .catch(() => {\n\t      expect(spyRequestCancelEvent).toHaveBeenCalledWith(expect.any(RequestEvent));\n\t    });\n", "});\n"]}
{"filename": "src/__tests__/request.test.ts", "chunked_list": ["/**\n\t * @jest-environment jsdom\n\t */\n\timport { mockAxiosWithRestApi } from '@klient/testing';\n\timport Klient, { RequestEvent, RequestErrorEvent } from '..';\n\tjest.mock('axios');\n\tmockAxiosWithRestApi();\n\ttest('factory', () => {\n\t  const { factory } = new Klient();\n\t  const request = factory.createRequest('/posts');\n", "  factory.createRequest('/example');\n\t  factory.createRequest('/other');\n\t  expect(factory.requests.length).toBe(3);\n\t  return request.execute().then(() => {\n\t    expect(factory.requests.length).toBe(2);\n\t  });\n\t});\n\ttest('request:success', async () => {\n\t  const klient = new Klient();\n\t  const spyRequestEvent = jest.fn();\n", "  const spyRequestSuccessEvent = jest.fn();\n\t  const spyRequestErrorEvent = jest.fn();\n\t  const spyRequestDoneEvent = jest.fn();\n\t  klient.on('request', spyRequestEvent);\n\t  klient.on('request:success', spyRequestSuccessEvent);\n\t  klient.on('request:error', spyRequestErrorEvent);\n\t  klient.on('request:done', spyRequestDoneEvent);\n\t  await klient.request('/posts');\n\t  expect(spyRequestEvent).toBeCalledTimes(1);\n\t  expect(spyRequestSuccessEvent).toBeCalledTimes(1);\n", "  expect(spyRequestErrorEvent).toBeCalledTimes(0);\n\t  expect(spyRequestDoneEvent).toBeCalledTimes(1);\n\t});\n\ttest('request:error', () => {\n\t  const klient = new Klient();\n\t  const spyRequestEvent = jest.fn();\n\t  const spyRequestSuccessEvent = jest.fn();\n\t  const spyRequestErrorEvent = jest.fn();\n\t  const spyRequestDoneEvent = jest.fn();\n\t  klient.on('request', spyRequestEvent);\n", "  klient.on('request:success', spyRequestSuccessEvent);\n\t  klient.on('request:error', spyRequestErrorEvent);\n\t  klient.on('request:done', spyRequestDoneEvent);\n\t  return klient\n\t    .request('/notfound')\n\t    .then(() => {\n\t      throw new Error('This request must failed');\n\t    })\n\t    .catch(() => {\n\t      expect(spyRequestEvent).toBeCalledTimes(1);\n", "      expect(spyRequestSuccessEvent).toBeCalledTimes(0);\n\t      expect(spyRequestErrorEvent).toBeCalledTimes(1);\n\t      expect(spyRequestDoneEvent).toBeCalledTimes(1);\n\t    });\n\t});\n\ttest('request:failure', async () => {\n\t  let klient = new Klient();\n\t  klient.on('request', () => {\n\t    throw new Error('Aborted');\n\t  });\n", "  await klient\n\t    .request('/posts')\n\t    .then(() => {\n\t      throw new Error('This request must failed');\n\t    })\n\t    .catch((e) => {\n\t      expect(e.message).toBe('Aborted');\n\t    });\n\t  klient = new Klient();\n\t  klient.on('request:success', () => {\n", "    throw new Error('Not aborted');\n\t  });\n\t  await klient\n\t    .request('/posts')\n\t    .then(({ status }) => {\n\t      expect(status).toBe(200);\n\t    })\n\t    .catch((e) => {\n\t      console.log(e);\n\t      throw e;\n", "    });\n\t});\n\ttest('request:cancelled', async () => {\n\t  let klient = new Klient();\n\t  const spyRequestSuccessEvent = jest.fn();\n\t  const spyRequestCancelEvent = jest.fn();\n\t  const spyRequestErrorEvent = jest.fn();\n\t  const spyRequestDoneEvent = jest.fn();\n\t  klient.on('request', (e: RequestEvent) => {\n\t    e.request.cancel();\n", "  });\n\t  klient.on('request:success', spyRequestSuccessEvent);\n\t  klient.on('request:error', spyRequestErrorEvent);\n\t  klient.on('request:cancel', spyRequestCancelEvent);\n\t  klient.on('request:done', spyRequestDoneEvent);\n\t  await klient\n\t    .request('/posts')\n\t    .then(() => {\n\t      throw new Error('This request must failed');\n\t    })\n", "    .catch((e) => {\n\t      expect(klient.isCancel(e)).toBe(true);\n\t      expect(spyRequestSuccessEvent).toBeCalledTimes(0);\n\t      expect(spyRequestErrorEvent).toBeCalledTimes(0);\n\t      expect(spyRequestDoneEvent).toBeCalledTimes(0);\n\t      expect(spyRequestCancelEvent).toBeCalledTimes(1);\n\t    });\n\t  klient = new Klient();\n\t  klient.on('request', () => {\n\t    klient.cancelPendingRequests();\n", "  });\n\t  await klient\n\t    .request('/posts')\n\t    .then(() => {\n\t      throw new Error('This request must failed');\n\t    })\n\t    .catch((e) => {\n\t      expect(klient.isCancel(e)).toBe(true);\n\t    });\n\t});\n", "test('request:file', async () => {\n\t  const klient = new Klient();\n\t  const spyRequestEvent = jest.fn();\n\t  klient.on('request', (e: RequestEvent) => {\n\t    spyRequestEvent(e.context.action, e.config.responseType);\n\t  });\n\t  await klient\n\t    .file('/file')\n\t    .then((file) => {\n\t      expect(file).toBeInstanceOf(Blob);\n", "      expect(spyRequestEvent).toBeCalledWith('file', 'blob');\n\t    })\n\t    .catch((e) => {\n\t      console.log(e);\n\t      throw e;\n\t    });\n\t  await klient\n\t    .file({\n\t      baseURL: 'http://localhost',\n\t      url: '/file'\n", "    })\n\t    .then((file) => {\n\t      expect(file).toBeInstanceOf(Blob);\n\t      expect(spyRequestEvent).toBeCalledWith('file', 'blob');\n\t    })\n\t    .catch((e) => {\n\t      console.log(e);\n\t      throw e;\n\t    });\n\t});\n", "test('request:handler', async () => {\n\t  const klient = new Klient();\n\t  const spyRequestSuccessEvent = jest.fn();\n\t  const spyRequestErrorEvent = jest.fn();\n\t  const spyRequestHandler = jest.fn();\n\t  klient.once('request', (e: RequestEvent) => {\n\t    e.request.handler = () => {\n\t      spyRequestHandler();\n\t      return Promise.resolve({ status: 200, statusText: 'OK', data: [], headers: {}, config: {} });\n\t    };\n", "  });\n\t  klient.on('request:success', (e: RequestErrorEvent) => {\n\t    spyRequestSuccessEvent(e.request.result);\n\t  });\n\t  klient.on('request:error', (e: RequestErrorEvent) => {\n\t    spyRequestErrorEvent(e.data);\n\t  });\n\t  await klient\n\t    .request('/')\n\t    .then((response) => {\n", "      expect(spyRequestSuccessEvent).toBeCalledWith(response);\n\t      expect(spyRequestSuccessEvent).toBeCalledTimes(1);\n\t      expect(spyRequestHandler).toBeCalledTimes(1);\n\t      expect(spyRequestErrorEvent).toBeCalledTimes(0);\n\t    })\n\t    .catch((e) => {\n\t      console.log(e);\n\t      throw e;\n\t    });\n\t  klient.once('request', (e: RequestEvent) => {\n", "    e.request.handler = () => {\n\t      spyRequestHandler();\n\t      return Promise.reject(new Error());\n\t    };\n\t  });\n\t  await klient\n\t    .request('/')\n\t    .then(() => {\n\t      throw new Error('This request must failed');\n\t    })\n", "    .catch(() => {\n\t      expect(spyRequestErrorEvent).toBeCalledTimes(1);\n\t      expect(spyRequestErrorEvent).toBeCalledWith(undefined);\n\t      expect(spyRequestHandler).toBeCalledTimes(2);\n\t      expect(spyRequestSuccessEvent).toBeCalledTimes(1);\n\t    });\n\t});\n\ttest('request:get', () => {\n\t  const klient = new Klient();\n\t  const spyRequestEvent = jest.fn();\n", "  klient.on('request', (e: RequestEvent) => {\n\t    spyRequestEvent(e.config.method);\n\t  });\n\t  return klient\n\t    .get('/posts')\n\t    .then(() => {\n\t      expect(spyRequestEvent).toBeCalledWith('GET');\n\t    })\n\t    .catch((e) => {\n\t      console.log(e);\n", "      throw e;\n\t    });\n\t});\n\ttest('request:post', () => {\n\t  const klient = new Klient();\n\t  const spyRequestEvent = jest.fn();\n\t  klient.on('request', (e: RequestEvent) => {\n\t    spyRequestEvent(e.config.method);\n\t  });\n\t  return klient\n", "    .post('/posts', {})\n\t    .then(() => {\n\t      throw new Error('This request must failed');\n\t    })\n\t    .catch(() => {\n\t      expect(spyRequestEvent).toBeCalledWith('POST');\n\t    });\n\t});\n\ttest('request:put', () => {\n\t  const klient = new Klient();\n", "  const spyRequestEvent = jest.fn();\n\t  klient.on('request', (e: RequestEvent) => {\n\t    spyRequestEvent(e.config.method);\n\t  });\n\t  return klient\n\t    .put('/posts/1', {})\n\t    .then(() => {\n\t      throw new Error('This request must failed');\n\t    })\n\t    .catch(() => {\n", "      expect(spyRequestEvent).toBeCalledWith('PUT');\n\t    });\n\t});\n\ttest('request:patch', () => {\n\t  const klient = new Klient();\n\t  const spyRequestEvent = jest.fn();\n\t  klient.on('request', (e: RequestEvent) => {\n\t    spyRequestEvent(e.config.method);\n\t  });\n\t  return klient\n", "    .patch('/posts/1', {})\n\t    .then(() => {\n\t      throw new Error('This request must failed');\n\t    })\n\t    .catch(() => {\n\t      expect(spyRequestEvent).toBeCalledWith('PATCH');\n\t    });\n\t});\n\ttest('request:head', () => {\n\t  const klient = new Klient();\n", "  const spyRequestEvent = jest.fn();\n\t  klient.on('request', (e: RequestEvent) => {\n\t    spyRequestEvent(e.config.method);\n\t  });\n\t  return klient\n\t    .head('/posts/1')\n\t    .then(() => {\n\t      throw new Error('This request must failed');\n\t    })\n\t    .catch(() => {\n", "      expect(spyRequestEvent).toBeCalledWith('HEAD');\n\t    });\n\t});\n\ttest('request:options', () => {\n\t  const klient = new Klient();\n\t  const spyRequestEvent = jest.fn();\n\t  klient.on('request', (e: RequestEvent) => {\n\t    spyRequestEvent(e.config.method);\n\t  });\n\t  return klient\n", "    .options('/posts/1')\n\t    .then(() => {\n\t      throw new Error('This request must failed');\n\t    })\n\t    .catch(() => {\n\t      expect(spyRequestEvent).toBeCalledWith('OPTIONS');\n\t    });\n\t});\n\ttest('request:delete', () => {\n\t  const klient = new Klient();\n", "  const spyRequestEvent = jest.fn();\n\t  klient.on('request', (e: RequestEvent) => {\n\t    spyRequestEvent(e.config.method);\n\t  });\n\t  return klient\n\t    .delete('/posts/1')\n\t    .then(() => {\n\t      throw new Error('This request must failed');\n\t    })\n\t    .catch(() => {\n", "      expect(spyRequestEvent).toBeCalledWith('DELETE');\n\t    });\n\t});\n"]}
{"filename": "src/__tests__/debug.test.ts", "chunked_list": ["import { mockAxiosWithRestApi } from '@klient/testing';\n\timport Klient, { DebugEvent } from '..';\n\tjest.mock('axios');\n\tmockAxiosWithRestApi();\n\ttest('debug', async () => {\n\t  const klient = new Klient({ debug: true });\n\t  const spyRequestEvent = jest.fn();\n\t  const spyRequest2Event = jest.fn();\n\t  const spyStartDispatchEvent = jest.fn();\n\t  const spySkippedEvent = jest.fn();\n", "  const spyInvokingEvent = jest.fn();\n\t  const spyInvokedEvent = jest.fn();\n\t  const spyDispatchStoppedEvent = jest.fn();\n\t  const spyDispatchFailedEvent = jest.fn();\n\t  const spyDispatchEndEvent = jest.fn();\n\t  klient.on('debug', (e: DebugEvent) => {\n\t    switch (e.action) {\n\t      case 'start':\n\t        spyStartDispatchEvent();\n\t        break;\n", "      case 'invoking':\n\t        spyInvokingEvent();\n\t        break;\n\t      case 'invoked':\n\t        spyInvokedEvent();\n\t        break;\n\t      case 'stopped':\n\t        spyDispatchStoppedEvent();\n\t        break;\n\t      case 'skipped':\n", "        spySkippedEvent();\n\t        break;\n\t      case 'failed':\n\t        spyDispatchFailedEvent();\n\t        break;\n\t      case 'end':\n\t        spyDispatchEndEvent();\n\t        break;\n\t    }\n\t  });\n", "  klient.on('request', (e) => {\n\t    spyRequestEvent();\n\t    e.skipNextListeners(1);\n\t  });\n\t  klient.on('request', () => {\n\t    return;\n\t  });\n\t  klient.on('request', spyRequest2Event);\n\t  await klient\n\t    .request('/posts')\n", "    .then(() => {\n\t      expect(spyRequestEvent).toBeCalledTimes(1);\n\t      expect(spyStartDispatchEvent).toBeCalledTimes(3);\n\t      expect(spyInvokingEvent).toBeCalledTimes(2);\n\t      expect(spyInvokedEvent).toBeCalledTimes(2);\n\t      expect(spyDispatchEndEvent).toBeCalledTimes(3);\n\t      expect(spyDispatchFailedEvent).toBeCalledTimes(0);\n\t      expect(spyDispatchStoppedEvent).toBeCalledTimes(0);\n\t    })\n\t    .catch((e) => {\n", "      console.log(e);\n\t      throw e;\n\t    });\n\t  klient.on('request', (e) => {\n\t    e.stopPropagation();\n\t  });\n\t  await klient\n\t    .request('/posts')\n\t    .then(() => {\n\t      expect(spyDispatchStoppedEvent).toBeCalledTimes(1);\n", "    })\n\t    .catch((e) => {\n\t      console.log(e);\n\t      throw e;\n\t    });\n\t  klient.on(\n\t    'request',\n\t    () => {\n\t      throw new Error();\n\t    },\n", "    1\n\t  );\n\t  await klient\n\t    .request('/posts')\n\t    .then(() => {\n\t      throw new Error('This request must failed');\n\t    })\n\t    .catch(() => {\n\t      expect(spyDispatchFailedEvent).toBeCalledTimes(1);\n\t    });\n", "});\n"]}
