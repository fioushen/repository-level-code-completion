{"filename": "tools/generateXmltvFile.ts", "chunked_list": ["#!/usr/bin/env -S ts-node --esm\n\timport { writeXmltv } from \"../src/main.js\";\n\timport { ArgumentParser } from \"argparse\";\n\timport type { Xmltv } from \"../src/types.js\";\n\t/**\n\t * Generate a xmltv file with the given number of channels and programmes\n\t *\n\t * Usage:\n\t *   ./generateXml.ts -c 100 -p 250000 > tests/fixtures/c100-p250_000.xml\n\t *   ./generateXml.ts --channels 100 --programmes 250000 > tests/fixtures/c100-p250_000.xml\n", " */\n\tconst parser = new ArgumentParser({\n\t  description: \"Generate xmltv xml file\",\n\t});\n\tparser.add_argument(\"-c\", \"--channels\", {\n\t  help: \"Number of channels to generate\",\n\t  required: true,\n\t});\n\tparser.add_argument(\"-p\", \"--programmes\", {\n\t  help: \"Number of programmes to generate\",\n", "  required: true,\n\t});\n\tconst { channels: numberOfChannels, programmes: numberOfProgrammes } =\n\t  parser.parse_args();\n\tconst channelFactory = (count: number) => {\n\t  const channels: any = [];\n\t  for (let i = 0; i < count; i++) {\n\t    channels.push({\n\t      id: `${i + 1}`,\n\t      displayName: [{ _value: `Channel ${i + 1}` }],\n", "    });\n\t  }\n\t  return channels;\n\t};\n\tconst programmeFactory = (count: number) => {\n\t  const programmes: any = [];\n\t  let currentStartTime = new Date(Date.now() - 4 * 60 * 60 * 1000);\n\t  for (let i = 0; i < count; i++) {\n\t    const duration = Math.floor(Math.random() * 180) + 30;\n\t    const end = new Date(currentStartTime.getTime() + duration * 60 * 1000);\n", "    programmes.push({\n\t      title: `Programme ${i + 1}`,\n\t      desc: \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed euismod, nisl nec ultricies lacinia, nisl nisl aliquam nisl\",\n\t      start: currentStartTime,\n\t      stop: end,\n\t      channel: `${Math.floor(Math.random() * numberOfChannels) + 1}`,\n\t    });\n\t    currentStartTime = end;\n\t  }\n\t  return programmes;\n", "};\n\tconst channels = channelFactory(numberOfChannels);\n\tconst programmes = programmeFactory(numberOfProgrammes);\n\tconst xmltv: Xmltv = {\n\t  channels,\n\t  programmes: programmes,\n\t};\n\tconst xml = writeXmltv(xmltv);\n\tprocess.stdout.write(xml + \"\\n\");\n"]}
{"filename": "tests/main.bench.ts", "chunked_list": ["import fs from \"node:fs\";\n\timport { describe, bench } from \"vitest\";\n\timport { parser, writeXmltv, parseXmltv } from \"../src/main.js\";\n\timport { XMLBuilder, XMLParser } from \"fast-xml-parser\";\n\timport epgParser from \"epg-parser\";\n\timport {\n\t  xmltvTagTranslations,\n\t  xmltvAttributeTranslations,\n\t} from \"../src/xmltvTranslations.js\";\n\timport type { XmltvTags, XmltvAttributes } from \"../src/xmltvTagsAttributes.js\";\n", "import xmltv from \"xmltv\";\n\timport path from \"node:path\";\n\tconst files = [\"example.xml\"];\n\tconst file = files[0];\n\tconst xmltvString = fs.readFileSync(`./tests/fixtures/${file}`, {\n\t  encoding: \"utf-8\",\n\t});\n\tconst preParsed = parser(xmltvString);\n\t// these options bring it to feature parity with @iptv/xmltv\n\tconst fxpParser = new XMLParser({\n", "  ignoreAttributes: false,\n\t  alwaysCreateTextNode: true,\n\t  parseTagValue: true,\n\t  preserveOrder: true,\n\t  trimValues: true,\n\t  transformTagName: (tag) => xmltvTagTranslations.get(tag as XmltvTags) || tag,\n\t  transformAttributeName: (tag) =>\n\t    xmltvAttributeTranslations.get(tag as XmltvAttributes) || tag,\n\t});\n\t// unable to transform tags and attributes with XMLBuilder\n", "const fxpBuilder = new XMLBuilder({\n\t  ignoreAttributes: false,\n\t  preserveOrder: true,\n\t});\n\tconst fxpParsed = fxpParser.parse(xmltvString);\n\tdescribe(\"Writing XML Files\", () => {\n\t  bench(\"@iptv/xmltv\", () => {\n\t    writeXmltv(preParsed, { fromDom: true });\n\t  });\n\t  bench(\"fast-xml-parser\", () => {\n", "    fxpBuilder.build(fxpParsed);\n\t  });\n\t});\n\tdescribe(\"Parsing XML Files\", () => {\n\t  bench(\"@iptv/xmltv parseXmltv\", () => {\n\t    parseXmltv(xmltvString);\n\t  });\n\t  bench(\"@iptv/xmltv parser\", () => {\n\t    parser(xmltvString);\n\t  });\n", "  bench(\"fast-xml-parser\", () => {\n\t    fxpParser.parse(xmltvString);\n\t  });\n\t  bench(\"epg-parser\", () => {\n\t    epgParser.parse(xmltvString);\n\t  });\n\t  bench(\"xmltv\", async () => {\n\t    await new Promise<void>((resolve) => {\n\t      const xmltvparser = new xmltv.Parser() as any;\n\t      const readable = fs.createReadStream(\n", "        path.resolve(path.resolve(`./tests/fixtures/${file}`))\n\t      );\n\t      readable.pipe(xmltvparser);\n\t      const obj: { programmes: any[] } = {\n\t        programmes: [],\n\t      };\n\t      xmltvparser.on(\"programme\", function (programme: any) {\n\t        obj.programmes.push(programme);\n\t      });\n\t      xmltvparser.on(\"end\", () => {\n", "        resolve();\n\t      });\n\t    });\n\t  });\n\t});\n"]}
{"filename": "tests/main.test.ts", "chunked_list": ["import { describe, expect, test } from \"vitest\";\n\timport { objectToDom, parseXmltv, writeXmltv } from \"../src/main\";\n\timport fs from \"node:fs\";\n\tconst fileAsString = fs.readFileSync(`./tests/fixtures/example.xml`, {\n\t  encoding: \"utf-8\",\n\t});\n\tconst fileWithOnlyChannelData = fs.readFileSync(\n\t  `./tests/fixtures/channel-only.xml`,\n\t  {\n\t    encoding: \"utf-8\",\n", "  }\n\t);\n\tdescribe(\"Parses a XMLTV file\", () => {\n\t  test(\"Fully parses to a JS object\", async () => {\n\t    const parsed = parseXmltv(fileAsString);\n\t    expect(parsed).toMatchSnapshot();\n\t  });\n\t  test(\"it can convert back to xml\", () => {\n\t    const parsed = parseXmltv(fileAsString);\n\t    const xml = writeXmltv(parsed);\n", "    expect(xml).toMatchSnapshot();\n\t  });\n\t  test(\"it can convert an object into the dom structure\", () => {\n\t    const obj = parseXmltv(fileAsString);\n\t    const dom = objectToDom(obj);\n\t    expect(dom).toMatchSnapshot();\n\t  });\n\t  test(\"convertToDom produces the same DOM as an xml file parse\", () => {\n\t    const [, , exampleOutput] = parseXmltv(fileAsString, { asDom: true });\n\t    const xml = parseXmltv(fileAsString);\n", "    const [dom] = objectToDom(xml);\n\t    expect(exampleOutput).toEqual(dom);\n\t  });\n\t  test(\"Handles empty input string gracefully\", () => {\n\t    const parsed = parseXmltv(\"\");\n\t    expect(parsed).toEqual({});\n\t  });\n\t  test(\"Throws error on malformed XML input string\", () => {\n\t    const malformedXml = \"<tv><channel></tv>\";\n\t    expect(() => parseXmltv(malformedXml)).toThrowError(`Unexpected close tag\n", "Line: 0\n\tColumn: 18\n\tChar: >`);\n\t  });\n\t  test(\"Parses a XMLTV file with only channel data\", () => {\n\t    const parsed = parseXmltv(fileWithOnlyChannelData);\n\t    expect(parsed).toEqual({\n\t      channels: [{ displayName: [{ _value: \"Channel 1\" }], id: \"1\" }],\n\t    });\n\t  });\n", "});\n"]}
{"filename": "tests/utils.test.ts", "chunked_list": ["import { describe, expect, test } from 'vitest';\n\timport { dateToXmltvUtcTimestamp, xmltvTimestampToUtcDate } from '../src/utils';\n\tdescribe('dateToXmltvUtcTimestamp', () => {\n\t  test('should return a valid xmltv UTC timestamp', () => {\n\t    const date = new Date('2022-01-01T00:00:00Z');\n\t    const expected = '20220101000000 +0000';\n\t    const result = dateToXmltvUtcTimestamp(date);\n\t    expect(result).toEqual(expected);\n\t  });\n\t});\n", "describe('xmltvTimestampToUtcDate', () => {\n\t  test('should return a valid UTC date', () => {\n\t    const timestamp = '20220101000000 +0000';\n\t    const expected = new Date('2022-01-01T00:00:00Z');\n\t    const result = xmltvTimestampToUtcDate(timestamp);\n\t    expect(result).toEqual(expected);\n\t  });\n\t  test('should handle positive timezones', () => {\n\t    const timestamp = '20220101000000 +0100';\n\t    const expected = new Date('2021-12-31T23:00:00Z');\n", "    const result = xmltvTimestampToUtcDate(timestamp);\n\t    expect(result).toEqual(expected);\n\t  });\n\t  test('should handle negative timezones ', () => {\n\t    const timestamp = '20220101000000 -0400';\n\t    const expected = new Date('2022-01-01T04:00:00Z');\n\t    const result = xmltvTimestampToUtcDate(timestamp);\n\t    expect(result).toEqual(expected);\n\t  });\n\t  test('should handle misformatted timestamps ', () => {\n", "    const timestamp = '2022 01 01 000000    -0400';\n\t    const expected = new Date('2022-01-01T04:00:00Z');\n\t    const result = xmltvTimestampToUtcDate(timestamp);\n\t    expect(result).toEqual(expected);\n\t  });\n\t  test('should handle iso formatted timestamps without spaces ', () => {\n\t    const timestamp = '2022-01-01T00:00:00.000-0400';\n\t    const expected = new Date('2022-01-01T04:00:00Z');\n\t    const result = xmltvTimestampToUtcDate(timestamp);\n\t    expect(result).toEqual(expected);\n", "  });\n\t  test('should handle iso formatted timestamps with Z timezone', () => {\n\t    const timestamp = '2022-01-01T00:00:00.000Z';\n\t    const expected = new Date('2022-01-01T00:00:00Z');\n\t    const result = xmltvTimestampToUtcDate(timestamp);\n\t    expect(result).toEqual(expected);\n\t  });\n\t});\n"]}
{"filename": "tests/fixtures/files.ts", "chunked_list": ["const files = [\"c0-p0.xml\",\"c0-p1.xml\",\"c1-p0.xml\",\"c1-p1.xml\",\"c100-p100.xml\",\"c100-p1000.xml\",\"c100-p10000.xml\",\"c100-p100000.xml\",\"c100-p250000.xml\",\"c100-p500000.xml\",\"c100-p1000000.xml\",]; export { files }\n"]}
{"filename": "benchmark/nanobench.ts", "chunked_list": ["import bench from \"nanobench\";\n\timport fs from \"node:fs\";\n\timport { parseXmltv } from \"../src/main.js\";\n\timport epgParser from \"epg-parser\";\n\timport { files } from \"../tests/fixtures/files.js\";\n\t// import xmltv from \"xmltv\";\n\t// const xmltvParser = new xmltv.Parser() as any;\n\tfiles.forEach((file) => {\n\t  bench(`@iptv/xmltv parsing: ${file}`, function (b: any) {\n\t    let xmltvString: string | null = fs.readFileSync(\n", "      `./tests/fixtures/${file}`,\n\t      {\n\t        encoding: \"utf-8\",\n\t      }\n\t    );\n\t    b.start();\n\t    parseXmltv(xmltvString);\n\t    b.end();\n\t    xmltvString = null;\n\t  });\n", "  bench(`epg-parser parsing: ${file}`, function (b: any) {\n\t    let xmltvString: string | null = fs.readFileSync(\n\t      `./tests/fixtures/${file}`,\n\t      {\n\t        encoding: \"utf-8\",\n\t      }\n\t    );\n\t    b.start();\n\t    epgParser.parse(xmltvString);\n\t    b.end();\n", "    xmltvString = null;\n\t  });\n\t  // bench(`xmltv parsing: ${file}`, function (b: any) {\n\t  //   const readable = fs.createReadStream(\n\t  //     path.resolve(path.resolve(`./tests/fixtures/${file}`))\n\t  //   );\n\t  //   b.start();\n\t  //   console.log(\"started parsing\");\n\t  //   readable.pipe(xmltvParser);\n\t  //   const obj: { programmes: any[] } = {\n", "  //     programmes: [],\n\t  //   };\n\t  //   xmltvParser.on(\"programme\", function (programme: any) {\n\t  //     console.log(\"programme\");\n\t  //     obj.programmes.push(programme);\n\t  //   });\n\t  //   console.log(\"setting end\");\n\t  //   xmltvParser.on(\"end\", () => {\n\t  //     console.log(\"ended parsing\");\n\t  //     b.end();\n", "  //   });\n\t  // });\n\t});\n"]}
{"filename": "benchmark/self-bench.ts", "chunked_list": ["#!/usr/bin/env -S ts-node --esm\n\timport fs from \"node:fs\";\n\timport { suite, add, cycle, complete } from \"benny\";\n\timport { parseXmltv } from \"../src/main.js\";\n\timport { files } from \"../tests/fixtures/files.js\";\n\tfiles.unshift(\"example.xml\");\n\tconst file = files[0];\n\tconst xmltvString = fs.readFileSync(`./tests/fixtures/${file}`, {\n\t  encoding: \"utf-8\",\n\t});\n", "suite(\n\t  \"XMLTV Parsing\",\n\t  add(\"@iptv/xmltv DOM parse\", () => {\n\t    parseXmltv(xmltvString, { asDom: true });\n\t  }),\n\t  add(\"@iptv/xmltv DOM parse\", () => {\n\t    parseXmltv(xmltvString, { asDom: true });\n\t  }),\n\t  add(\"@iptv/xmltv DOM parse\", () => {\n\t    parseXmltv(xmltvString, { asDom: true });\n", "  }),\n\t  add(\"@iptv/xmltv DOM parse\", () => {\n\t    parseXmltv(xmltvString, { asDom: true });\n\t  }),\n\t  add(\"@iptv/xmltv DOM parse\", () => {\n\t    parseXmltv(xmltvString, { asDom: true });\n\t  }),\n\t  cycle(),\n\t  complete()\n\t);\n"]}
{"filename": "benchmark/benchmark.ts", "chunked_list": ["#!/usr/bin/env -S ts-node --esm\n\timport fs from \"node:fs\";\n\timport path from \"node:path\";\n\timport { suite, add, cycle, complete, save } from \"benny\";\n\timport { parseXmltv, writeXmltv } from \"../src/main.js\";\n\timport xmltv from \"xmltv\";\n\timport epgParser from \"epg-parser\";\n\timport { XMLBuilder, XMLParser } from \"fast-xml-parser\";\n\timport {\n\t  xmltvTagTranslations,\n", "  xmltvAttributeTranslations,\n\t} from \"../src/xmltvTranslations.js\";\n\timport type { XmltvTags, XmltvAttributes } from \"../src/xmltvTagsAttributes.js\";\n\timport { files } from \"../tests/fixtures/files.js\";\n\t// These options bring fast-xml-parser to feature parity with @iptv/xmltv\n\tconst fxpParser = new XMLParser({\n\t  ignoreAttributes: false,\n\t  alwaysCreateTextNode: true,\n\t  parseTagValue: true,\n\t  preserveOrder: true,\n", "  trimValues: true,\n\t  transformTagName: (tag) => {\n\t    return xmltvTagTranslations.get(tag as XmltvTags) || tag;\n\t  },\n\t  transformAttributeName: (tag) => {\n\t    return xmltvAttributeTranslations.get(tag as XmltvAttributes) || tag;\n\t  },\n\t});\n\tfiles.unshift(\"example.xml\");\n\tconst file = files[0];\n", "const xmltvString = fs.readFileSync(`./tests/fixtures/${file}`, {\n\t  encoding: \"utf-8\",\n\t});\n\tconst parsed = parseXmltv(xmltvString, { asDom: true });\n\tconst fxpParsed = fxpParser.parse(xmltvString);\n\tsuite(\n\t  \"XMLTV Parsing\",\n\t  add(\"@iptv/xmltv full parse\", () => {\n\t    parseXmltv(xmltvString);\n\t  }),\n", "  add(\"@iptv/xmltv DOM parse\", () => {\n\t    parseXmltv(xmltvString, { asDom: true });\n\t  }),\n\t  // add(\"txml\", () => {\n\t  //   txml.parse(xmltvString);\n\t  // }),\n\t  add(\"epg-parser\", () => {\n\t    epgParser.parse(xmltvString);\n\t  }),\n\t  add(\"fast-xml-parser\", () => {\n", "    fxpParser.parse(xmltvString);\n\t  }),\n\t  add(\"xmltv\", async () => {\n\t    await new Promise<void>((resolve) => {\n\t      const xmltvparser = new xmltv.Parser() as any;\n\t      const readable = fs.createReadStream(\n\t        path.resolve(path.resolve(`./tests/fixtures/${file}`))\n\t      );\n\t      readable.pipe(xmltvparser);\n\t      const obj: { programmes: any[] } = {\n", "        programmes: [],\n\t      };\n\t      xmltvparser.on(\"programme\", function (programme: any) {\n\t        obj.programmes.push(programme);\n\t      });\n\t      xmltvparser.on(\"end\", () => {\n\t        resolve();\n\t      });\n\t    });\n\t  }),\n", "  cycle(),\n\t  complete(),\n\t  save({ file: \"xmltv-parse-benchmark\", version: \"1.0.0\" }),\n\t  save({ file: \"xmltv-parse-benchmark\", format: \"chart.html\" })\n\t);\n\tsuite(\n\t  \"Creating XML\",\n\t  add(\"@iptv/xmltv creating xml\", () => {\n\t    writeXmltv(parsed, { fromDom: true });\n\t  }),\n", "  add(\"fast-xml-parser XMLBuilder\", () => {\n\t    const builder = new XMLBuilder({\n\t      ignoreAttributes: false,\n\t      preserveOrder: true,\n\t    });\n\t    builder.build(fxpParsed);\n\t  }),\n\t  cycle(),\n\t  complete(),\n\t  save({ file: \"xmltv-creation-benchmark\", version: \"1.0.0\" }),\n", "  save({ file: \"xmltv-creation-benchmark\", format: \"chart.html\" })\n\t);\n"]}
{"filename": "benchmark/index.d.ts", "chunked_list": ["declare module \"epg-parser\";\n\tdeclare module \"xmltv\";\n\tdeclare module \"nanobench\";\n"]}
{"filename": "src/toObject.ts", "chunked_list": ["import type { Xmltv, XmltvDomNode } from \"./types\";\n\timport { xmltvTimestampToUtcDate } from \"./utils.js\";\n\timport {\n\t  xmltvAttributeTranslations,\n\t  xmltvTagTranslations,\n\t} from \"./xmltvTranslations.js\";\n\timport type { XmltvTags, XmltvAttributes } from \"./xmltvTagsAttributes.js\";\n\tconst questionMarkCC = \"?\".charCodeAt(0);\n\t/**\n\t * Elements that can only be used once wherever they appear.\n", " * eg <credits> can only be used once in a <programme> element\n\t * but <actor> can be used multiple times in a <credits> element\n\t */\n\tconst singleUseElements: XmltvTags[] = [\n\t  \"credits\",\n\t  \"date\",\n\t  \"language\",\n\t  \"orig-language\",\n\t  \"length\",\n\t  \"country\",\n", "  \"previously-shown\",\n\t  \"premiere\",\n\t  \"last-chance\",\n\t  \"new\",\n\t  \"video\",\n\t  \"audio\",\n\t  // Sub-elements of 'video'\n\t  \"present\",\n\t  \"colour\",\n\t  \"aspect\",\n", "  \"quality\",\n\t  // Sub-elements of 'audio'\n\t  \"present\",\n\t  \"stereo\",\n\t  //sub-elements of rating and star rating\n\t  \"value\",\n\t];\n\t/**\n\t * Elements that do not have children or attributes so can be rendered as a scalar\n\t *\n", " * eg <date>2020-01-01</date> should render as\n\t * { date: \"2020-01-01\" }\n\t *    instead of\n\t * { date: { _value: \"2020-01-01\" } }\n\t */\n\tconst elementsAsScalar: XmltvTags[] = [\n\t  \"date\",\n\t  \"value\",\n\t  \"aspect\",\n\t  \"present\",\n", "  \"colour\",\n\t  \"quality\",\n\t  \"stereo\",\n\t];\n\t/**\n\t * Convert an XmltvDom tree to a plain object\n\t *\n\t * @param children The XmltvDom tree to convert\n\t */\n\ttype Out = Record<string, any>;\n", "export function toObject(\n\t  children: any[],\n\t  parent: XmltvDomNode = { tagName: \"tv\", attributes: {}, children: [] }\n\t): Out | boolean | string | Xmltv {\n\t  let out: Out = {};\n\t  if (!children.length) {\n\t    return out;\n\t  }\n\t  if (\n\t    children.length === 1 &&\n", "    typeof children[0] === \"string\" &&\n\t    (children[0] === \"yes\" || children[0] === \"no\")\n\t  ) {\n\t    return children[0] === \"yes\";\n\t  }\n\t  if (\n\t    children.length === 1 &&\n\t    typeof children[0] === \"string\" &&\n\t    typeof parent !== \"string\"\n\t  ) {\n", "    if (Object.keys(parent.attributes).length) {\n\t      return {\n\t        _value: children[0],\n\t      };\n\t    }\n\t    return children[0];\n\t  }\n\t  // map each object\n\t  for (let i = 0, n = children.length; i < n; i++) {\n\t    let child = children[i];\n", "    if (\n\t      typeof parent !== \"string\" &&\n\t      parent.tagName === \"actor\" &&\n\t      typeof child === \"string\"\n\t    ) {\n\t      out._value = child;\n\t    }\n\t    if (typeof child !== \"object\") {\n\t      continue;\n\t    }\n", "    if (child.tagName.charCodeAt(0) === questionMarkCC) continue;\n\t    if (child.tagName === \"new\") {\n\t      out[child.tagName] = true;\n\t      continue;\n\t    }\n\t    if (child.tagName === \"tv\") {\n\t      out = {};\n\t    }\n\t    const translatedName =\n\t      xmltvTagTranslations.get(child.tagName) || child.tagName;\n", "    if (\n\t      !out[translatedName] &&\n\t      singleUseElements.indexOf(child.tagName) === -1\n\t    ) {\n\t      out[translatedName] = [];\n\t    }\n\t    let kids: any = toObject(child.children || [], child);\n\t    if (Object.keys(child.attributes).length) {\n\t      if (!Array.isArray(kids)) {\n\t        if (child.attributes.size) {\n", "          child.attributes.size = Number(child.attributes.size);\n\t        }\n\t        if (translatedName === \"programmes\") {\n\t          if (child.attributes.stop) {\n\t            child.attributes.stop = xmltvTimestampToUtcDate(\n\t              child.attributes.stop\n\t            );\n\t          }\n\t          if (child.attributes[\"pdc-start\"]) {\n\t            child.attributes[\"pdc-start\"] = xmltvTimestampToUtcDate(\n", "              child.attributes[\"pdc-start\"]\n\t            );\n\t          }\n\t          if (child.attributes[\"vps-start\"]) {\n\t            child.attributes[\"vps-start\"] = xmltvTimestampToUtcDate(\n\t              child.attributes[\"vps-start\"]\n\t            );\n\t          }\n\t        } else if (translatedName === \"icon\") {\n\t          if (child.attributes.width) {\n", "            child.attributes.width = Number(child.attributes.width);\n\t          }\n\t          if (child.attributes.height) {\n\t            child.attributes.height = Number(child.attributes.height);\n\t          }\n\t        } else if (child.attributes.units) {\n\t          kids._value = Number(kids._value);\n\t        } else if (child.attributes.guest) {\n\t          child.attributes.guest = child.attributes.guest === \"yes\";\n\t        }\n", "        if (child.attributes.date) {\n\t          child.attributes.date = xmltvTimestampToUtcDate(\n\t            child.attributes.date\n\t          );\n\t        }\n\t        if (child.attributes.start) {\n\t          child.attributes.start = xmltvTimestampToUtcDate(\n\t            child.attributes.start\n\t          );\n\t        }\n", "        const translatedAttributes = Object.keys(child.attributes).reduce(\n\t          (acc: Record<string, string>, key: string) => {\n\t            acc[xmltvAttributeTranslations.get(key as XmltvAttributes) || key] =\n\t              child.attributes[key];\n\t            return acc;\n\t          },\n\t          {}\n\t        );\n\t        Object.assign(kids, translatedAttributes);\n\t      }\n", "    }\n\t    if (translatedName === \"subtitles\") {\n\t      if (typeof kids.language === \"string\") {\n\t        kids.language = { _value: kids.language };\n\t      }\n\t      out[translatedName].push(kids);\n\t      continue;\n\t    }\n\t    if (translatedName === \"tv\") {\n\t      out = kids;\n", "      continue;\n\t    }\n\t    if (translatedName === \"date\") {\n\t      out[translatedName] = xmltvTimestampToUtcDate(kids);\n\t      continue;\n\t    }\n\t    if (\n\t      typeof kids === \"string\" &&\n\t      elementsAsScalar.indexOf(child.tagName) === -1\n\t    ) {\n", "      kids = {\n\t        _value: kids,\n\t      };\n\t    }\n\t    if (Array.isArray(out[translatedName])) {\n\t      out[translatedName].push(kids);\n\t      continue;\n\t    }\n\t    out[translatedName] = kids;\n\t  }\n", "  return out as Xmltv;\n\t}\n"]}
{"filename": "src/parser.ts", "chunked_list": ["import { XmltvDom } from \"./types\";\n\t/**\n\t * The MIT License (MIT)\n\t *\n\t * Copyright (c) 2015 Tobias Nickel\n\t *\n\t * Copyright (c) 2023 Liam Potter\n\t *\n\t * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n\t * and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n", " * including without limitation the rights to use, copy, modify, merge, publish, distribute,\n\t * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\n\t * furnished to do so, subject to the following conditions:\n\t *\n\t * The above copyright notice and this permission notice shall be included in all copies or\n\t * substantial portions of the Software.\n\t *\n\t * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\n\t * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n\t * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n", " * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n\t * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t */\n\t/**\n\t * @author: Tobias Nickel\n\t * @created: 06.04.2015\n\t * I needed a small xml parser that can be used in a worker.\n\t *\n\t * @author: Liam Potter\n\t * @created: 03.04.2023\n", " * Based on the original work of Tobias Nickel (txml)\n\t * I removed the more generic parts of the parser to focus on working with the XMLTV format\n\t * Outputs a more fluent object structure matching the Xmltv types\n\t */\n\texport function parser(xmltvString: string): XmltvDom {\n\t  let pos = 0;\n\t  const openBracket = \"<\";\n\t  const closeBracket = \">\";\n\t  const openBracketCC = openBracket.charCodeAt(0);\n\t  const closeBracketCC = closeBracket.charCodeAt(0);\n", "  const minusCC = \"-\".charCodeAt(0);\n\t  const slashCC = \"/\".charCodeAt(0);\n\t  const exclamationCC = \"!\".charCodeAt(0);\n\t  const singleQuoteCC = \"'\".charCodeAt(0);\n\t  const doubleQuoteCC = '\"'.charCodeAt(0);\n\t  const openCornerBracketCC = \"[\".charCodeAt(0);\n\t  const closeCornerBracketCC = \"]\".charCodeAt(0);\n\t  const questionMarkCC = \"?\".charCodeAt(0);\n\t  const nameSpacer = \"\\r\\n\\t>/= \";\n\t  const noChildNodes = [\"new\", \"icon\", \"previously-shown\"];\n", "  /**\n\t   * parsing a list of entries\n\t   */\n\t  function parseChildren(tagName: string): XmltvDom {\n\t    const children: XmltvDom = [];\n\t    while (xmltvString[pos]) {\n\t      if (xmltvString.charCodeAt(pos) == openBracketCC) {\n\t        if (xmltvString.charCodeAt(pos + 1) === slashCC) {\n\t          const closeStart = pos + 2;\n\t          pos = xmltvString.indexOf(closeBracket, pos);\n", "          const closeTag = xmltvString.substring(closeStart, pos);\n\t          if (closeTag.indexOf(tagName) == -1) {\n\t            const parsedText = xmltvString.substring(0, pos).split(\"\\n\");\n\t            throw new Error(\n\t              \"Unexpected close tag\\nLine: \" +\n\t                (parsedText.length - 1) +\n\t                \"\\nColumn: \" +\n\t                (parsedText[parsedText.length - 1].length + 1) +\n\t                \"\\nChar: \" +\n\t                xmltvString[pos]\n", "            );\n\t          }\n\t          if (pos + 1) pos += 1;\n\t          return children;\n\t        } else if (xmltvString.charCodeAt(pos + 1) === exclamationCC) {\n\t          if (xmltvString.charCodeAt(pos + 2) == minusCC) {\n\t            //comment support\n\t            while (\n\t              pos !== -1 &&\n\t              !(\n", "                xmltvString.charCodeAt(pos) === closeBracketCC &&\n\t                xmltvString.charCodeAt(pos - 1) == minusCC &&\n\t                xmltvString.charCodeAt(pos - 2) == minusCC &&\n\t                pos != -1\n\t              )\n\t            ) {\n\t              pos = xmltvString.indexOf(closeBracket, pos + 1);\n\t            }\n\t            if (pos === -1) {\n\t              pos = xmltvString.length;\n", "            }\n\t          } else {\n\t            // doctype support\n\t            const startDoctype = pos + 1;\n\t            pos += 2;\n\t            let encapsulated = false;\n\t            while (\n\t              (xmltvString.charCodeAt(pos) !== closeBracketCC ||\n\t                encapsulated === true) &&\n\t              xmltvString[pos]\n", "            ) {\n\t              if (xmltvString.charCodeAt(pos) === openCornerBracketCC) {\n\t                encapsulated = true;\n\t              } else if (\n\t                encapsulated === true &&\n\t                xmltvString.charCodeAt(pos) === closeCornerBracketCC\n\t              ) {\n\t                encapsulated = false;\n\t              }\n\t              pos++;\n", "            }\n\t            children.push(xmltvString.substring(startDoctype, pos));\n\t          }\n\t          pos++;\n\t          continue;\n\t        }\n\t        const node = parseNode();\n\t        children.push(node);\n\t        if (node.tagName.charCodeAt(0) === questionMarkCC) {\n\t          for (let i = 0, x = node.children.length; i < x; i++) {\n", "            children.push(node.children[i]);\n\t          }\n\t          node.children = [];\n\t        }\n\t      } else {\n\t        const text = parseText().trim();\n\t        if (text.length > 0) {\n\t          children.push(text);\n\t        }\n\t        pos++;\n", "      }\n\t    }\n\t    return children;\n\t  }\n\t  /**\n\t   *    returns the text outside of texts until the first '<'\n\t   */\n\t  function parseText() {\n\t    const start = pos;\n\t    pos = xmltvString.indexOf(openBracket, pos) - 1;\n", "    if (pos === -2) pos = xmltvString.length;\n\t    return xmltvString.slice(start, pos + 1);\n\t  }\n\t  /**\n\t   *    returns text until the first nonAlphabetic letter\n\t   */\n\t  function parseName() {\n\t    const start = pos;\n\t    while (nameSpacer.indexOf(xmltvString[pos]) === -1 && xmltvString[pos]) {\n\t      pos++;\n", "    }\n\t    return xmltvString.slice(start, pos);\n\t  }\n\t  function parseNode() {\n\t    pos++;\n\t    const tagName = parseName();\n\t    const attributes: Record<string, any> = {};\n\t    let children: XmltvDom = [];\n\t    // parsing attributes\n\t    while (xmltvString.charCodeAt(pos) !== closeBracketCC && xmltvString[pos]) {\n", "      const c = xmltvString.charCodeAt(pos);\n\t      if ((c > 64 && c < 91) || (c > 96 && c < 123)) {\n\t        const name = parseName();\n\t        // search beginning of the string\n\t        let code = xmltvString.charCodeAt(pos);\n\t        let value;\n\t        while (\n\t          code &&\n\t          code !== singleQuoteCC &&\n\t          code !== doubleQuoteCC &&\n", "          !((code > 64 && code < 91) || (code > 96 && code < 123)) &&\n\t          code !== closeBracketCC\n\t        ) {\n\t          pos++;\n\t          code = xmltvString.charCodeAt(pos);\n\t        }\n\t        if (code === singleQuoteCC || code === doubleQuoteCC) {\n\t          value = parseString();\n\t          if (pos === -1) {\n\t            return {\n", "              tagName,\n\t              attributes,\n\t              children,\n\t            };\n\t          }\n\t        } else {\n\t          value = null;\n\t          pos--;\n\t        }\n\t        attributes[name] = value;\n", "      }\n\t      pos++;\n\t    }\n\t    // optional parsing of children\n\t    if (xmltvString.charCodeAt(pos - 1) !== slashCC) {\n\t      if (noChildNodes.indexOf(tagName) === -1) {\n\t        pos++;\n\t        children = parseChildren(tagName);\n\t      } else {\n\t        pos++;\n", "      }\n\t    } else {\n\t      pos++;\n\t    }\n\t    return {\n\t      tagName,\n\t      attributes,\n\t      children,\n\t    };\n\t  }\n", "  function parseString(): string {\n\t    const startChar = xmltvString[pos];\n\t    const start = pos + 1;\n\t    pos = xmltvString.indexOf(startChar, start);\n\t    return xmltvString.slice(start, pos);\n\t  }\n\t  return parseChildren(\"\");\n\t}\n"]}
{"filename": "src/main.ts", "chunked_list": ["import { parser } from \"./parser.js\";\n\timport { writer } from \"./writer.js\";\n\timport { objectToDom } from \"./objectToDom.js\";\n\timport { toObject } from \"./toObject.js\";\n\timport type {\n\t  Xmltv,\n\t  XmltvAudio,\n\t  XmltvChannel,\n\t  XmltvCreditImage,\n\t  XmltvCredits,\n", "  XmltvDom,\n\t  XmltvDisplayName,\n\t  XmltvEpisodeNumber,\n\t  XmltvIcon,\n\t  XmltvImage,\n\t  XmltvLength,\n\t  XmltvPerson,\n\t  XmltvPreviouslyShown,\n\t  XmltvProgramme,\n\t  XmltvRating,\n", "  XmltvReview,\n\t  XmltvStarRating,\n\t  XmltvSubtitle,\n\t  XmltvUrl,\n\t  XmltvVideo,\n\t} from \"./types\";\n\timport {\n\t  addAttributeTranslation,\n\t  addTagTranslation,\n\t} from \"./xmltvTranslations.js\";\n", "type ParseXmltvOptions = {\n\t  asDom: boolean;\n\t};\n\ttype WriteXmltvOptions = {\n\t  fromDom: boolean;\n\t};\n\t/**\n\t * parseXmltv\n\t *\n\t * Parses an xmltv file and returns an `Xmltv` object or a DOM tree\n", " *\n\t * @param xmltvString The xmltv file content as a string\n\t * @param options Options to parse the xmltv file\n\t * @param options.asDom If true, the xmltv file will be returned as a DOM tree\n\t */\n\tfunction parseXmltv(\n\t  xmltvString: string,\n\t  options: ParseXmltvOptions & { asDom: true }\n\t): XmltvDom;\n\tfunction parseXmltv(\n", "  xmltvString: string,\n\t  options: ParseXmltvOptions & { asDom: false }\n\t): XmltvDom;\n\tfunction parseXmltv(xmltvString: string): Xmltv;\n\tfunction parseXmltv(\n\t  xmltvString: string,\n\t  options: ParseXmltvOptions = { asDom: false }\n\t): Xmltv | XmltvDom {\n\t  const parsed = parser(xmltvString);\n\t  if (options.asDom) {\n", "    return parsed;\n\t  }\n\t  return <Xmltv>toObject(parsed);\n\t}\n\t/**\n\t * writeXmltv\n\t *\n\t * Writes an `Xmltv` object or a DOM tree to an xmltv string\n\t *\n\t * @param xmltv The `Xmltv` object or a DOM tree\n", " * @param options Options to write the xmltv file\n\t * @param options.fromDom If true, the xmltv file will be written from a DOM tree\n\t * @returns The xmltv file content as a string\n\t * @throws If `options.fromDom` is true and `xmltv` is an `Xmltv` object\n\t */\n\tfunction writeXmltv(\n\t  xmltv: XmltvDom,\n\t  options: WriteXmltvOptions & { fromDom: true }\n\t): string;\n\tfunction writeXmltv(\n", "  xmltv: Xmltv,\n\t  options: WriteXmltvOptions & { fromDom: false }\n\t): string;\n\tfunction writeXmltv(xmltv: Xmltv): string;\n\tfunction writeXmltv(\n\t  xmltv: Xmltv | XmltvDom,\n\t  options: WriteXmltvOptions = { fromDom: false }\n\t): string {\n\t  if (options.fromDom) {\n\t    if (typeof xmltv === \"object\" && !Array.isArray(xmltv)) {\n", "      throw new Error(\n\t        \"Cannot write XMLTV from a DOM object that has been converted to an object\"\n\t      );\n\t    }\n\t    return writer(xmltv);\n\t  }\n\t  const dom = objectToDom(xmltv);\n\t  return writer(dom);\n\t}\n\texport {\n", "  parseXmltv,\n\t  writeXmltv,\n\t  writer,\n\t  parser,\n\t  objectToDom,\n\t  addTagTranslation,\n\t  addAttributeTranslation,\n\t};\n\texport type {\n\t  Xmltv,\n", "  XmltvChannel,\n\t  XmltvDisplayName,\n\t  XmltvProgramme,\n\t  XmltvAudio,\n\t  XmltvCreditImage,\n\t  XmltvCredits,\n\t  XmltvEpisodeNumber,\n\t  XmltvIcon,\n\t  XmltvImage,\n\t  XmltvLength,\n", "  XmltvPerson,\n\t  XmltvPreviouslyShown,\n\t  XmltvRating,\n\t  XmltvReview,\n\t  XmltvStarRating,\n\t  XmltvSubtitle,\n\t  XmltvUrl,\n\t  XmltvVideo,\n\t};\n"]}
{"filename": "src/types.ts", "chunked_list": ["/**\n\t * A representation of XMLTV data in TypeScript.\n\t *\n\t * @see http://wiki.xmltv.org/index.php/XmltvFormat\n\t */\n\t/**\n\t * A URL to an image about the programme.\n\t *\n\t * The type of the image may be identified by the 'type' attribute. For programmes\n\t * this could be 'poster' or 'backdrop' (marketing promo photos)  or 'still' (screenshot from the\n", " * programme itself).\n\t *\n\t * If multiple image elements of a particular type are given, the most authoritative or official\n\t * images should be listed first.\n\t *\n\t * The `system` attribute may be used to identify the source of the image, or some useful feature\n\t * of the target (e.g. 'imdb','tmdb',etc.).\n\t *\n\t * The `orient` attribute defines the orientation of the image \"P\" portrait or \"L\" landscape\n\t *\n", " * The `size` attribute may be used to indicate the relative size of the image.\n\t * Possible values are:\n\t * \"1\" is < 200px in its largest dimension\n\t * \"2\" is 200-400px in its largest dimension\n\t * \"3\" is > 400px in its largest dimension\n\t * Multiple images of different sizes is permitted (e.g. small poster and large poster).\n\t */\n\texport type XmltvImage = {\n\t  /**\n\t   * Type of image\n", "   */\n\t  type?: \"poster\" | \"backdrop\" | \"still\";\n\t  /**\n\t   * URL of the image\n\t   */\n\t  _value: string;\n\t  /**\n\t   * Size of the image\n\t   *\n\t   * Possible values are:\n", "   * \"1\" is < 200px in its largest dimension\n\t   * \"2\" is 200-400px in its largest dimension\n\t   * \"3\" is > 400px in its largest dimension\n\t   */\n\t  size?: 1 | 2 | 3;\n\t  /**\n\t   * Orientation of the image\n\t   *\n\t   * Possible values are:\n\t   * - \"L\" = landscape\n", "   * - \"P\" = portrait\n\t   */\n\t  orient?: \"L\" | \"P\" | \"l\" | \"p\";\n\t  /**\n\t   * A string to describe where the image came from, eg IMDB\n\t   */\n\t  system?: string;\n\t};\n\t/**\n\t * Similar to XmltvImage but with a types for the credit images.\n", " *\n\t * It could be 'person' (general portfolio picture of the person) or 'character'\n\t * (photo taken from the programme showing the actor in character).\n\t */\n\texport type XmltvCreditImage = XmltvImage & {\n\t  /**\n\t   * Type of image\n\t   */\n\t  type?: \"person\" | \"character\";\n\t};\n", "/**\n\t * A representation of a person in an XMLTV programme object.\n\t */\n\texport type XmltvPerson = {\n\t  /**\n\t   * The name of the person.\n\t   */\n\t  _value: string;\n\t  /**\n\t   * The role of the actor in the programme eg Bryan Cranston's role in Breaking Bad is \"Walter White\".\n", "   */\n\t  role?: string;\n\t  /**\n\t   * Whether the person is a guest star or a regular cast member.\n\t   */\n\t  guest?: boolean;\n\t  /**\n\t   * An image of the person.\n\t   */\n\t  image?: XmltvCreditImage[];\n", "  /**\n\t   * The URL of the person.\n\t   */\n\t  url?: XmltvUrl[];\n\t};\n\t/**\n\t * A representation of the credits for an XMLTV programme object.\n\t *\n\t * People are listed in decreasing order of importance; so for example the starring actors appear\n\t * first followed by the smaller parts.  As with other parts of this file format, not mentioning\n", " * a particular actor (for example) does not imply that he _didn't_ star in the film - so normally\n\t * you'd list only the few most important people.\n\t *\n\t * Adapter can be either somebody who adapted a work for television, or somebody who did the translation\n\t * from another lang. The distinction is not always clear.\n\t *\n\t * URL can be, for example, a link to a webpage with more information about the actor, director, etc..\n\t */\n\texport type XmltvCredits = {\n\t  /**\n", "   * The director(s) of the programme.\n\t   */\n\t  director?: XmltvPerson[];\n\t  /**\n\t   * The actor(s) in the programme.\n\t   */\n\t  actor?: XmltvPerson[];\n\t  /**\n\t   * The writer(s) of the programme.\n\t   */\n", "  writer?: XmltvPerson[];\n\t  /**\n\t   * The adapter(s) of the programme.\n\t   */\n\t  adapter?: XmltvPerson[];\n\t  /**\n\t   * The producer(s) of the programme.\n\t   */\n\t  producer?: XmltvPerson[];\n\t  /**\n", "   * The composer(s) of the programme.\n\t   */\n\t  composer?: XmltvPerson[];\n\t  /**\n\t   * The editor(s) of the programme.\n\t   */\n\t  editor?: XmltvPerson[];\n\t  /**\n\t   * The presenter(s) of the programme.\n\t   */\n", "  presenter?: XmltvPerson[];\n\t  /**\n\t   * The commentator(s) of the programme.\n\t   */\n\t  commentator?: XmltvPerson[];\n\t  /**\n\t   * The guest(s) of the programme.\n\t   */\n\t  guest?: XmltvPerson[];\n\t};\n", "/**\n\t * A way to define multiple strings with different langs for the same value.\n\t */\n\ttype XmltvStringWithLang = {\n\t  /**\n\t   * The value of the string\n\t   */\n\t  _value: string;\n\t  /**\n\t   * The lang code of the string eg. \"en\" for English, \"es\" for Spanish, etc.\n", "   */\n\t  lang?: string;\n\t};\n\t/**\n\t * The channel display name with an optional language attribute.\n\t */\n\texport type XmltvDisplayName = XmltvStringWithLang;\n\t/**\n\t * The title of a programme with an optional language attribute.\n\t */\n", "export type XmltvTitle = XmltvStringWithLang;\n\t/**\n\t * The subtitle of a programme with an optional language attribute.\n\t */\n\texport type XmltvSubTitle = XmltvStringWithLang;\n\t/**\n\t * The description of a programme with an optional language attribute.\n\t */\n\texport type XmltvDesc = XmltvStringWithLang;\n\t/**\n", " * The category of a programme with an optional language attribute.\n\t */\n\texport type XmltvCategory = XmltvStringWithLang;\n\t/**\n\t * The keyword related to a programme with an optional language attribute.\n\t */\n\texport type XmltvKeyword = XmltvStringWithLang;\n\t/**\n\t * The language of a programme with an optional language attribute.\n\t */\n", "export type XmltvLanguage = XmltvStringWithLang;\n\t/**\n\t * The original language of a programme with an optional language attribute.\n\t */\n\texport type XmltvOrigLanguage = XmltvStringWithLang;\n\t/**\n\t * The country where a programme was produced with an optional language attribute.\n\t */\n\texport type XmltvCountry = XmltvStringWithLang;\n\t/**\n", " * The premiere information for a programme with an optional language attribute.\n\t */\n\texport type XmltvPremiere = XmltvStringWithLang;\n\t/**\n\t * The last chance information for a programme with an optional language attribute.\n\t */\n\texport type XmltvLastChance = XmltvStringWithLang;\n\t/**\n\t * Object describing an icon\n\t *\n", " * The icon element is used to specify an image that represents the programme or channel,\n\t * typically a logo or thumbnail image. The src attribute of the icon element is required\n\t * and specifies the URL of the image file. The width and height attributes are optional\n\t * and specify the dimensions of the image in pixels. The icon element is optional and\n\t * can be used within the channel and programme elements to provide visual information\n\t * about the channel or programme being described.\n\t */\n\texport type XmltvIcon = {\n\t  /**\n\t   * URL of the icon\n", "   */\n\t  src: string;\n\t  /**\n\t   * Width of the icon\n\t   */\n\t  width?: number;\n\t  /**\n\t   * Height of the icon\n\t   */\n\t  height?: number;\n", "};\n\t/**\n\t * Object describing a URL, used in the programme and channel objects.\n\t */\n\texport type XmltvUrl = {\n\t  /**\n\t   * Value of the URL\n\t   */\n\t  _value: string;\n\t  /**\n", "   * System of the URL, eg \"imdb\", \"thetvdb\", etc.\n\t   */\n\t  system?: string;\n\t};\n\t/**\n\t * Episode number\n\t */\n\texport type XmltvEpisodeNumber = {\n\t  /**\n\t   * The episode number as a standard SxxExx string.\n", "   * This is the preferred way to specify the episode number.\n\t   */\n\t  system?: \"onscreen\" | \"xmltv_ns\";\n\t  /**\n\t   * The episode number as a XMLTV episode number string eg. \"2.3.2\".\n\t   */\n\t  _value?: string;\n\t};\n\t/**\n\t * Object describing details of the programme's video\n", " */\n\texport type XmltvVideo = {\n\t  /**\n\t   * Whether this programme has a picture (no, in the case of radio stations broadcast\n\t   * on TV or 'Blue'). If this attribute is missing, it is assumed to be `true`.\n\t   */\n\t  present?: boolean;\n\t  /**\n\t   * `true` for colour, `false` for black-and-white.\n\t   */\n", "  colour?: boolean;\n\t  /**\n\t   * The horizontal:vertical aspect ratio, eg `4:3` or `16:9`.\n\t   */\n\t  aspect?: string;\n\t  /**\n\t   * Information on the quality, eg `HDTV`, `800x600`.\n\t   */\n\t  quality?: string;\n\t};\n", "/**\n\t * The programme rating eg TV-MA, PG, etc.\n\t */\n\texport type XmltvRating = {\n\t  /**\n\t   * Value of the rating\n\t   */\n\t  value: string;\n\t  /**\n\t   * System of the rating eg. MPAA, VCHIP, etc.\n", "   */\n\t  system?: string;\n\t  /**\n\t   * Icon of the rating\n\t   */\n\t  icon?: XmltvIcon[];\n\t};\n\t/**\n\t * Audio details, similar to video details.\n\t *\n", " * `present`: Whether this programme has any sound at all.\n\t * `stereo`: Description of the stereo-ness of the sound.  Legal values\n\t * are currently `mono`,`stereo`,`dolby`,`dolby digital`,`bilingual` and `surround`.\n\t */\n\texport type XmltvAudio = {\n\t  /**\n\t   * Whether this programme has any sound at all.\n\t   */\n\t  present?: boolean;\n\t  /**\n", "   * Description of the stereo-ness of the sound.\n\t   *\n\t   * `bilingual` in this case refers to a single audio stream where the left and right\n\t   * channels contain monophonic audio  in different langs.  Other values may be added later.\n\t   */\n\t  stereo?:\n\t    | \"mono\"\n\t    | \"stereo\"\n\t    | \"dolby\"\n\t    | \"dolby digital\"\n", "    | \"bilingual\"\n\t    | \"surround\";\n\t};\n\t/**\n\t * The true length of the programme, not counting advertisements or trailers.\n\t * But this does take account of any bits which were cut out of the broadcast version\n\t * - eg if a two hour film is cut to 110 minutes and then padded with 20 minutes of advertising,\n\t * length will be 110 minutes even though end time minus start time is 130 minutes.\n\t */\n\texport type XmltvLength = {\n", "  /**\n\t   * The length of the programme\n\t   */\n\t  _value: number;\n\t  /**\n\t   * The units of the length\n\t   *\n\t   */\n\t  units: \"seconds\" | \"minutes\" | \"hours\";\n\t};\n", "/**\n\t * These can be either `teletext` (sent digitally, and displayed at the viewer's request),\n\t * `onscreen` (superimposed on the picture and impossible to get rid of),\n\t * or 'deaf-signed' (in-vision signing for users of sign lang).\n\t *\n\t * You can have multiple subtitle streams to handle different langs.\n\t * lang for subtitles is specified in the same way as for programmes.\n\t */\n\texport type XmltvSubtitle = {\n\t  type?: \"teletext\" | \"onscreen\" | \"deaf-signed\";\n", "  language?: XmltvStringWithLang;\n\t};\n\t/**\n\t * When and where the programme was last shown, if known.  Normally in TV listings 'repeat'\n\t * means 'previously shown on this channel', but if you don't know what channel the old\n\t * screening was on (but do know that it happened) then you can omit the 'channel' attribute.\n\t * Similarly you can omit the 'start' attribute if you don't know when the previous transmission\n\t * was (though you can of course give just the year, etc.).\n\t */\n\texport type XmltvPreviouslyShown = {\n", "  start?: Date;\n\t  channel?: string;\n\t};\n\t/**\n\t * A review of the programme.\n\t * Either the text of the review, or a URL that links to it.\n\t */\n\texport type XmltvReview = {\n\t  /**\n\t   * The value of this element must be either the text of the review, or a URL that links to it.\n", "   */\n\t  _value: string;\n\t  /**\n\t   * The type of review\n\t   */\n\t  type: \"text\" | \"url\";\n\t  /**\n\t   * The source of the review\n\t   */\n\t  source?: string;\n", "  /**\n\t   * The author of the review\n\t   */\n\t  reviewer?: string;\n\t  /**\n\t   * The lang of the review\n\t   */\n\t  lang?: string;\n\t};\n\texport type XmltvStarRating = {\n", "  /**\n\t   * The value of this element should be 'N / M', for example one star out of a possible five stars would be '1 / 5'.\n\t   */\n\t  value: string;\n\t  /**\n\t   * The system used to provide the star rating\n\t   */\n\t  system?: string;\n\t  /**\n\t   * Icon for the star rating\n", "   */\n\t  icon?: XmltvIcon[];\n\t};\n\t/**\n\t * Object describing a programme\n\t */\n\texport type XmltvProgramme = {\n\t  /**\n\t   * The channel id for the program (see `XmltvChannel`)\n\t   * This is a string that uniquely identifies the channel on which the programme is broadcast.\n", "   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   channel: 'bbc1.uk'\n\t   * }\n\t   * ```\n\t   */\n\t  channel: string;\n\t  /**\n", "   * Title of the program in different langs\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   title: [\n\t   *     { _value: 'The Simpsons', lang: 'en' },\n\t   *     { _value: 'Los Simpson', lang: 'es' },\n\t   *     { _value: 'Les Simpson', lang: 'fr' },\n\t   *   ]\n", "   * }\n\t   * ```\n\t   */\n\t  title: XmltvTitle[];\n\t  /**\n\t   * Start time of the program\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n", "   *   start: new Date('2019-01-01T00:00:00Z');\n\t   * }\n\t   * ```\n\t   */\n\t  start: Date;\n\t  /**\n\t   * Stop time of the program\n\t   *\n\t   * @example\n\t   * ```typescript\n", "   * {\n\t   *   stop: new Date('2019-01-01T00:00:00Z');\n\t   * }\n\t   * ```\n\t   */\n\t  stop?: Date;\n\t  /**\n\t   * The PDC (Program Delivery Control) start time of the programme.\n\t   * This is used to mark the actual start time of a broadcast in a tape-based recording system.\n\t   *\n", "   * PDC stands for Programme Delivery Control. PDC start time is a signal that is transmitted\n\t   * along with the television signal to synchronize the VCR's timer with the beginning of a program.\n\t   * The PDC start time is the precise start time of a television program, accurate to the second,\n\t   * and is useful for programming VCRs to record a particular program.\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   pdcStart: new Date('2019-01-01T00:00:00Z');\n\t   * }\n", "   * ```\n\t   */\n\t  pdcStart?: Date;\n\t  /**\n\t   * VPS start time of the program\n\t   *\n\t   * VPS stands for Video Programming System, a system used in some countries to synchronize the\n\t   * start and end times of television programs. The VPS start time is an optional field in the\n\t   * XMLTV DTD that specifies the start time of the programme according to the VPS system.\n\t   *\n", "   * @example\n\t   * ```typescript\n\t   * {\n\t   *   vpsStart: new Date('2019-01-01T00:00:00Z');\n\t   * }\n\t   * ```\n\t   */\n\t  vpsStart?: Date;\n\t  /**\n\t   * Showview code for the program\n", "   *\n\t   * Showview is a system used in some countries to identify TV programs. It is a six-digit code\n\t   * assigned to each program that provides a unique identifier, which can be used to look up\n\t   * program information in a database. In the XMLTV DTD, the showView attribute is an optional\n\t   * field that specifies the Showview code for the programme.\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   showView: '123456'\n", "   * }\n\t   * ```\n\t   */\n\t  showview?: string;\n\t  /**\n\t   * Video Plus+ code for the program\n\t   *\n\t   * Video Plus+ (VPS+) is a system used in some countries to set the timer of a VCR (Video Cassette Recorder)\n\t   * to record a specific TV program. It works by assigning a code to each program in the TV listings that\n\t   * can be entered into the VCR timer. The VCR then starts recording at the specified time, without the\n", "   * need for the user to set the timer manually. In the XMLTV DTD, the videoplus attribute is an optional\n\t   * field that specifies the Video Plus+ code for the programme.\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   videoPlus: 'V123456'\n\t   * }\n\t   * ```\n\t   */\n", "  videoplus?: string;\n\t  /**\n\t   * Clump index for the program\n\t   *\n\t   * TV listings sometimes have the problem of listing two or more programmes in the same timeslot,\n\t   * such as 'News; Weather'. We call this a 'clump' of programmes, and the `clumpIndex` attribute\n\t   * differentiates between two programmes sharing the same timeslot and channel.\n\t   * In this case News would have clumpIndex=\"0/2\" and Weather would have clumpidx: \"1/2\".\n\t   *\n\t   * If you don't have this problem, be thankful!\n", "   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   clumpidx: '0/2'\n\t   * }\n\t   * ```\n\t   *\n\t   */\n\t  clumpidx?: string;\n", "  /**\n\t   * Subtitle of the program in different langs\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   subTitle: [\n\t   *     { _value: 'Treehouse of Horror XXVII', lang: 'en' },\n\t   *     { _value: 'El árbol de los horrores XXVII', lang: 'es' },\n\t   *     { _value: \"Le manoir de l'horreur XXVII\", lang: 'fr' },\n", "   *   ]\n\t   * }\n\t   * ```\n\t   */\n\t  subTitle?: XmltvSubTitle[];\n\t  /**\n\t   * Description of the program in different langs\n\t   *\n\t   * @example\n\t   * ```typescript\n", "   * {\n\t   *   desc: [\n\t   *     { _value: 'The Simpsons go to a haunted house.', lang: 'en' },\n\t   *     { _value: 'Los Simpson van a una casa embrujada.', lang: 'es' },\n\t   *     { _value: 'Les Simpson vont dans une maison hantée.', lang: 'fr' },\n\t   *   ]\n\t   * }\n\t   * ```\n\t   */\n\t  desc?: XmltvDesc[];\n", "  /**\n\t   * Credits for the program, including director, actors, writers, etc.\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   credits: {\n\t   *     directors: [{ _value: 'David Silverman' }],\n\t   *     actors: [\n\t   *       { _value: 'Dan Castellaneta', role: 'Homer Simpson' },\n", "   *       { _value: 'Julie Kavner', role: 'Marge Simpson' },\n\t   *       { _value: 'Nancy Cartwright', role: 'Bart Simpson' },\n\t   *       { _value: 'Yeardley Smith', role: 'Lisa Simpson' },\n\t   *     ],\n\t   *   }\n\t   * }\n\t   */\n\t  credits?: XmltvCredits;\n\t  /**\n\t   * Date of the program in YYYYMMDD format\n", "   *\n\t   * The date the programme or film was finished.  This will probably be the same as the copyright date.\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *  date: '20190101'\n\t   * }\n\t   * ```\n\t   */\n", "  date?: Date;\n\t  /**\n\t   * Category of the program in different langs\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   categories: [\n\t   *     { : 'Comedy', lang: 'en' },\n\t   *     { : 'Comedia', lang: 'es' },\n", "   *     { : 'Comédie', lang: 'fr' },\n\t   *   ]\n\t   * }\n\t   * ```\n\t   */\n\t  category?: XmltvCategory[];\n\t  /**\n\t   * Keyword for the program in different langs\n\t   *\n\t   * @example\n", "   * ```typescript\n\t   * {\n\t   *   keywords: [\n\t   *     { _value: 'Halloween', lang: 'en' },\n\t   *     { _value: 'Halloween', lang: 'es' },\n\t   *     { _value: 'Halloween', lang: 'fr' },\n\t   *   ]\n\t   * }\n\t   * ```\n\t   */\n", "  keyword?: XmltvKeyword[];\n\t  /**\n\t   * language used in the program\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *  language: 'en'\n\t   * }\n\t   * ```\n", "   */\n\t  language?: XmltvLanguage;\n\t  /**\n\t   * Original lang of the program\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   origLanguage: 'en'\n\t   * }\n", "   * ```\n\t   */\n\t  origLanguage?: XmltvOrigLanguage;\n\t  /**\n\t   * Length of the program\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   length: {\n", "   *     units: 'minutes',\n\t   *     _value: 30\n\t   *   }\n\t   * }\n\t   * ```\n\t   */\n\t  length?: XmltvLength;\n\t  /**\n\t   * Icon for the program\n\t   *\n", "   * @example\n\t   * ```typescript\n\t   * {\n\t   *   icon: {\n\t   *     src: 'https://example.com/icon.png',\n\t   *     width: 32,\n\t   *     height: 32\n\t   *   }\n\t   * }\n\t   * ```\n", "   */\n\t  icon?: XmltvIcon[];\n\t  /**\n\t   * URL for the program\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   url: {\n\t   *    _value: 'https://example.com/program',\n", "   *    system: 'imdb'\n\t   *   }\n\t   * }\n\t   * ```\n\t   */\n\t  url?: XmltvUrl[];\n\t  /**\n\t   * Country of the program\n\t   *\n\t   * @example\n", "   * ```typescript\n\t   * {\n\t   *   country: 'US'\n\t   * }\n\t   * ```\n\t   */\n\t  country?: XmltvCountry;\n\t  /**\n\t   * Episode number for the program in either \"onscreen\" or \"xmltv_ns\" format\n\t   *\n", "   * @example\n\t   * ```typescript\n\t   * {\n\t   *   episodeNum: [{\n\t   *     _value: 'S27E07',\n\t   *     type: '27.7'\n\t   *   }]\n\t   * }\n\t   * ```\n\t   */\n", "  episodeNum?: XmltvEpisodeNumber[];\n\t  /**\n\t   * Video details, including aspect ratio, whether it is in colour or black and white, etc.\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   video: {\n\t   *     present: true,\n\t   *     colour: true,\n", "   *     aspect: '16:9',\n\t   *     quality: 'HDTV'\n\t   *   }\n\t   * }\n\t   * ```\n\t   */\n\t  video?: XmltvVideo;\n\t  /**\n\t   * Audio details, similar to video details.\n\t   *\n", "   * @example\n\t   * ```typescript\n\t   * {\n\t   *   audio: {\n\t   *     present: true,\n\t   *     stereo: 'stereo'\n\t   *   }\n\t   * }\n\t   * ```\n\t   */\n", "  audio?: XmltvAudio;\n\t  /**\n\t   * When and where the programme was last shown, if known.  Normally in TV listings 'repeat'\n\t   * means 'previously shown on this channel', but if you don't know what channel the old\n\t   * screening was on (but do know that it happened) then you can omit the 'channel' attribute.\n\t   *\n\t   * Similarly you can omit the 'start' attribute if you don't know when the previous transmission\n\t   * was (though you can of course give just the year, etc.).\n\t   *\n\t   * The absence of this element does not say for certain that the programme is brand new and\n", "   * has never been screened anywhere before.\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   previouslyShown: {\n\t   *     start: '2019-01-01T00:00:00Z',\n\t   *     channel: 'example.com'\n\t   *   }\n\t   * }\n", "   * ```\n\t   *\n\t   */\n\t  previouslyShown?: XmltvPreviouslyShown;\n\t  /**\n\t   * Premiere details for the program in different langs\n\t   *\n\t   * Different channels have different meanings for this word - sometimes it means a film\n\t   * has never before been seen on TV in that country, but other channels use it to mean\n\t   * 'the first showing of this film on our channel in the current run'.  It might have been\n", "   * shown before, but now they have paid for another set of showings, which makes the first\n\t   * in that set count as a premiere!\n\t   *\n\t   * So this element doesn't have a clear meaning, just use it to represent where 'premiere'\n\t   * would appear in a printed TV listing. You can use the content of the element to explain\n\t   * exactly what is meant.\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n", "   *   premiere:'First showing on this channel'\n\t   * }\n\t   * ```\n\t   *\n\t   * If you don't want to give an explanation, just set it to true:\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   premiere: true\n", "   * }\n\t   * ```\n\t   */\n\t  premiere?: XmltvStringWithLang | boolean;\n\t  /**\n\t   * Last chance details for the program in different langs\n\t   *\n\t   * In a way this is the opposite of premiere.  Some channels buy the rights to show a\n\t   * movie a certain number of times, and the first may be flagged 'premiere',\n\t   * the last as 'last showing'.\n", "   *\n\t   * For symmetry with premiere, you may use the element content to give a 'paragraph'\n\t   * describing exactly what is meant - it's unlikely to be the last showing ever!\n\t   * Otherwise, explicitly put empty content.\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   lastChance: 'Last showing on this channel'\n\t   * }\n", "   * ```\n\t   */\n\t  lastChance?: XmltvStringWithLang | boolean;\n\t  /**\n\t   * This is the first screened programme from a new show that has never been shown on television\n\t   * before (if not worldwide then at least never before in this country).\n\t   *\n\t   * After the first episode or programme has been shown, subsequent ones are no longer 'new'.\n\t   * Similarly the second series of an established programme is not 'new'.\n\t   *\n", "   * Note that this does not mean 'new season' or 'new episode' of an existing show.\n\t   * You can express part of that using the episode-num stuff.\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   new: true\n\t   * }\n\t   * ```\n\t   */\n", "  new?: boolean;\n\t  /**\n\t   * Subtitles details for the program\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   subtitles: [\n\t   *     { type: 'teletext', language: {_value: 'English'} },\n\t   *     { type: 'onscreen', language: {_value: 'French', lang: 'fr'} }\n", "   *   ]\n\t   * }\n\t   * ```\n\t   */\n\t  subtitles?: XmltvSubtitle[];\n\t  /**\n\t   * Various bodies decide on classifications for films - usually a minimum age you must be to see it.\n\t   * In principle the same could be done for ordinary TV programmes. Because there are many systems for\n\t   * doing this, you can also specify the rating system used eg MPAA, VCHIP, etc.\n\t   *\n", "   * @example\n\t   * ```typescript\n\t   * {\n\t   *   system: 'MPAA',\n\t   *   _value: 'PG',\n\t   *   icon: [{\n\t   *     src: 'https://www.themoviedb.org/assets/1/v4/logos/32x32-blue-1f8b5c2fda197d0ee7d4f5b9fdca72a67ac3c9f7f8f8f8f8f8f8f8f8f8f8f8f8f.png',\n\t   *     width: 32,\n\t   *     height: 32\n\t   *   }]\n", "   * }\n\t   * ```\n\t   *\n\t   */\n\t  rating?: XmltvRating[];\n\t  /**\n\t   * Star rating for the program, including value and system\n\t   *\n\t   * Star rating' - many listings guides award a programme a score as a quick guide to how good it is.\n\t   * The value of this element should be 'N / M', for example one star out of a possible five stars would be '1 / 5'.\n", "   *\n\t   * Zero stars is also a possible score (and not the same as 'unrated').  You should try to map whatever wacky system\n\t   * your listings source uses to a number of stars: so for example if they have thumbs up, thumbs sideways and thumbs down,\n\t   * you could map that to two, one or zero stars out of two.\n\t   *\n\t   * If a programme is marked as recommended in a listings guide you could map this to '1 / 1'.\n\t   *\n\t   * Because there could be many ways to provide star-ratings or recommendations for a programme, you can specify\n\t   * multiple star-ratings. You can specify the star-rating system used, or the provider of the recommendation,\n\t   * with the system attribute. Whitespace between the numbers and slash is ignored.\n", "   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   starRating: [{\n\t   *     value: '1 / 5',\n\t   *     system: 'IMDB',\n\t   *     icon: {\n\t   *       src: 'https://www.themoviedb.org/assets/1/v4/logos/32x32-blue-1f8b5c2fda197d0ee7d4f5b9fdca72a67ac3c9f7f8f8f8f8f8f8f8f8f8f8f8f8f.png',\n\t   *       width: 32,\n", "   *       height: 32\n\t   *     }\n\t   *   }]\n\t   * }\n\t   * ```\n\t   */\n\t  starRating?: XmltvStarRating[];\n\t  /**\n\t   * Review details for the program\n\t   *\n", "   * Listings guides may provide reviews of programmes in addition to, or in place of, standard\n\t   * programme descriptions. They are usually written by in-house reviewers, but reviews can also\n\t   * be made available by third-party organisations/individuals. The value of this element must\n\t   * be either the text of the review, or a URL that links to it. Optional attributes giving the\n\t   * review source and the individual reviewer can also be specified.\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *  review: {\n", "   *   _value: 'https://www.imdb.com/title/tt0111161/reviews',\n\t   *  type: 'url',\n\t   * source: 'IMDB',\n\t   * reviewer: 'John Doe',\n\t   * lang: 'en'\n\t   * }\n\t   * ```\n\t   *\n\t   * @example\n\t   * ```typescript\n", "   * {\n\t   *   review: [{\n\t   *     _value: 'A great movie',\n\t   *     type: 'text',\n\t   *     source: 'IMDB',\n\t   *     reviewer: 'John Doe',\n\t   *     lang: 'en'\n\t   *   }]\n\t   * }\n\t   * ```\n", "   */\n\t  review?: XmltvReview[];\n\t  /**\n\t   * Images associated with the program\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   images: [{\n\t   *     src: 'https://www.themoviedb.org/assets/1/v4/logos/32x32-blue-1f8b5c2fda197d0ee7d4f5b9fdca72a67ac3c9f7f8f8f8f8f8f8f8f8f8f8f8f8f.png',\n", "   *     type: 'poster\n\t   *     orient: 'L',\n\t   *     size: 3\n\t   *   }]\n\t   * }\n\t   * ```\n\t   */\n\t  image?: XmltvImage[];\n\t};\n\t/**\n", " * The channel details\n\t */\n\texport type XmltvChannel = {\n\t  /**\n\t   * The channel id\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   id: 'channel-1'\n", "   * }\n\t   * ```\n\t   */\n\t  id: string;\n\t  /**\n\t   * The channel display name\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n", "   *   displayName: [{\n\t   *     _value: 'Channel 1',\n\t   *     lang: 'en'\n\t   *   },{\n\t   *     _value: 'Kanal 1',\n\t   *     lang: 'de'\n\t   *   }]\n\t   * }\n\t   * ```\n\t   */\n", "  displayName: XmltvDisplayName[];\n\t  /**\n\t   * The channel icon\n\t   *\n\t   * @example\n\t   * ```typescript\n\t   * {\n\t   *   icon: [{\n\t   *     src: 'https://www.themoviedb.org/assets/1/v4/logos/32x32-blue-1f8b5c2fda197d0ee7d4f5b9fdca72a67ac3c9f7f8f8f8f8f8f8f8f8f8f8f8f8f.png',\n\t   *     width: 32,\n", "   *     height: 32\n\t   *   }]\n\t   * }\n\t   * ```\n\t   */\n\t  icon?: XmltvIcon[];\n\t  /**\n\t   * The channel url\n\t   *\n\t   * @example\n", "   * ```typescript\n\t   * {\n\t   *   url: [{_value: 'https://www.channel1.com'}]\n\t   * ]\n\t   * ```\n\t   */\n\t  url?: XmltvUrl[];\n\t};\n\texport type Xmltv = {\n\t  channels?: XmltvChannel[];\n", "  programmes?: XmltvProgramme[];\n\t  date?: Date;\n\t  sourceInfoName?: string;\n\t  generatorInfoName?: string;\n\t  sourceInfoUrl?: string;\n\t  sourceDataUrl?: string;\n\t  generatorInfoUrl?: string;\n\t};\n\t/**\n\t * A single XMLTV DOM node\n", " *\n\t * @example\n\t * ```typescript\n\t * {\n\t *   tagName: 'programme',\n\t *   attributes: {\n\t *     start: '20210101000000 +0100',\n\t *     stop: '20210101010000 +0100',\n\t *     channel: 'channel-1'\n\t *   },\n", " *   children: [{\n\t *     tagName: 'title',\n\t *     attributes: {\n\t *       lang: 'en'\n\t *     },\n\t *     children: ['Programme title']\n\t *   }]\n\t * }\n\t * ```\n\t */\n", "export type XmltvDomNode =\n\t  | {\n\t      tagName: string;\n\t      attributes: Record<string, any>;\n\t      children: Array<XmltvDomNode | string>;\n\t    }\n\t  | string;\n\t/**\n\t * A collection of XMLTV DOM nodes to form a valid XMLTV document\n\t *\n", " */\n\texport type XmltvDom = XmltvDomNode[];\n"]}
{"filename": "src/vite-env.d.ts", "chunked_list": ["/// <reference types=\"vite/client\" />\n\t/// <reference types=\"vitest\" />\n"]}
{"filename": "src/objectToDom.ts", "chunked_list": ["import type { XmltvDomNode } from \"./types\";\n\timport { dateToXmltvUtcTimestamp } from \"./utils.js\";\n\timport {\n\t  xmltvAttributeTranslationsReversed,\n\t  xmltvTagTranslationsReversed,\n\t} from \"./xmltvTranslations.js\";\n\timport { XmltvAttributes, xmltvAttributes } from \"./xmltvTagsAttributes.js\";\n\t/**\n\t * Converts an XMLTV object to a DOM tree\n\t *\n", " * @param obj The XMLTV object to convert to a DOM tree\n\t * @param key The current key to loop over\n\t * @param isArrayChild Controls if the return is an array or not\n\t * @returns The DOM tree\n\t */\n\texport function objectToDom(obj: any, key = \"tv\", isArrayChild = false): any {\n\t  if (Array.isArray(obj)) {\n\t    return obj.map((item) => objectToDom(item, key, true));\n\t  }\n\t  if (typeof obj === \"number\") {\n", "    return obj.toString();\n\t  }\n\t  if (typeof obj === \"string\") {\n\t    return obj;\n\t  }\n\t  if (obj instanceof Date && key !== \"date\") {\n\t    return dateToXmltvUtcTimestamp(obj);\n\t  }\n\t  if (typeof obj === \"boolean\" && key !== \"new\") {\n\t    return obj ? \"yes\" : \"no\";\n", "  }\n\t  const translatedTagName = xmltvTagTranslationsReversed.get(key) || key;\n\t  const DomNode: XmltvDomNode = {\n\t    tagName: translatedTagName,\n\t    attributes: {},\n\t    children: [],\n\t  };\n\t  for (let childKey in obj) {\n\t    const translatedAttributeName =\n\t      xmltvAttributeTranslationsReversed.get(childKey) || childKey;\n", "    if (obj[childKey].tagName === \"new\") {\n\t      obj[translatedTagName].children = [];\n\t      continue;\n\t    }\n\t    if (\n\t      (xmltvAttributes.indexOf(translatedAttributeName as XmltvAttributes) >=\n\t        0 &&\n\t        typeof obj[childKey] !== \"object\") ||\n\t      obj[childKey] instanceof Date\n\t    ) {\n", "      if (DomNode.tagName === \"credits\" && childKey === \"guest\") {\n\t        continue;\n\t      }\n\t      if (DomNode.tagName === \"programme\" && childKey === \"channel\") {\n\t        DomNode.attributes[translatedAttributeName] = obj[childKey];\n\t        continue;\n\t      }\n\t      if (DomNode.tagName === \"tv\" && childKey === \"date\") {\n\t        DomNode.attributes[translatedAttributeName] = dateToXmltvUtcTimestamp(\n\t          obj[childKey]\n", "        );\n\t        continue;\n\t      }\n\t      if (DomNode.tagName === \"programme\" && childKey === \"date\") {\n\t        DomNode.children.push({\n\t          tagName: translatedAttributeName,\n\t          attributes: {},\n\t          children: [dateToXmltvUtcTimestamp(obj[childKey])],\n\t        });\n\t        continue;\n", "      }\n\t      const childJsType = typeof obj[childKey];\n\t      if (childJsType === \"number\") {\n\t        DomNode.attributes[translatedAttributeName] = obj[childKey].toString();\n\t        continue;\n\t      }\n\t      if (childJsType === \"boolean\") {\n\t        DomNode.attributes[translatedAttributeName] = obj[childKey]\n\t          ? \"yes\"\n\t          : \"no\";\n", "        continue;\n\t      }\n\t      if (childJsType === \"object\" && !Array.isArray(obj[childKey])) {\n\t        if (obj[childKey] instanceof Date) {\n\t          obj[childKey] = dateToXmltvUtcTimestamp(obj[childKey]);\n\t          DomNode.attributes[translatedAttributeName] = obj[childKey];\n\t          continue;\n\t        }\n\t        const normalizedAttrs = Object.keys(obj[childKey]).map((key) => {\n\t          obj[childKey][key] = obj[childKey][key].toString();\n", "        });\n\t        DomNode.attributes[translatedAttributeName] = normalizedAttrs;\n\t        continue;\n\t      }\n\t      DomNode.attributes[translatedAttributeName] = obj[childKey];\n\t    } else {\n\t      const childNode = objectToDom(obj[childKey], childKey);\n\t      if (Array.isArray(childNode)) {\n\t        for (let i = 0, x = childNode.length; i < x; i++) {\n\t          DomNode.children.push(childNode[i]);\n", "        }\n\t      } else {\n\t        if (childKey !== \"_value\") {\n\t          DomNode.children.push({\n\t            tagName: translatedAttributeName,\n\t            attributes: {},\n\t            children: [childNode],\n\t          });\n\t          continue;\n\t        }\n", "        DomNode.children.push(childNode);\n\t      }\n\t    }\n\t  }\n\t  return isArrayChild ? DomNode : [DomNode];\n\t}\n"]}
{"filename": "src/xmltvTranslations.ts", "chunked_list": ["import { reverseMap } from \"./utils.js\";\n\timport { xmltvAttributes, xmltvTags } from \"./xmltvTagsAttributes.js\";\n\timport type { XmltvTags, XmltvAttributes } from \"./xmltvTagsAttributes.js\";\n\t/**\n\t * The map of XMLTV strings to preferred JS strings\n\t *\n\t * Why use a map?\n\t *\n\t * Instead of using a function to convert to camelCase, we use a map.\n\t * This is because performance is important in this library, and picking\n", " * from a map is faster than running a function. It also allows us to\n\t * translate by any rule we want, pluralisation, internationalisation, etc.\n\t *\n\t * Here are the results of running a benchmark comparing picking from a\n\t * map vs running a transform function:\n\t *       map: 6 470 122 ops/s, ±0.21%   | fastest\n\t *   convert: 232 614 ops/s, ±0.27%     | slowest, 96.4% slower\n\t *\n\t */\n\ttype XmltvTagTranslations = Map<XmltvTags, string>;\n", "type XmltvAttributeTranslations = Map<XmltvAttributes, string>;\n\ttype XmltvTagTranslationsReversed = Map<string, XmltvTags>;\n\ttype XmltvAttributeTranslationsReversed = Map<string, XmltvAttributes>;\n\tconst xmltvTagTranslations: XmltvTagTranslations = new Map([\n\t  ...xmltvTags.map((x) => [x, x] as [XmltvTags, string]),\n\t]);\n\tconst xmltvAttributeTranslations: XmltvAttributeTranslations = new Map([\n\t  ...xmltvAttributes.map((x) => [x, x] as [XmltvAttributes, string]),\n\t]);\n\tconst xmltvTagTranslationsReversed =\n", "  reverseMap<XmltvTagTranslationsReversed>(xmltvTagTranslations);\n\tconst xmltvAttributeTranslationsReversed =\n\t  reverseMap<XmltvAttributeTranslationsReversed>(xmltvAttributeTranslations);\n\t/**\n\t * Adds or modifies a translation for a XMLTV tag\n\t *\n\t * @param key A valid Xmltv tag string\n\t * @param value Your translation\n\t */\n\tfunction addTagTranslation(key: XmltvTags, value: string) {\n", "  if (!xmltvTags.includes(key)) {\n\t    throw new Error(`Invalid tag: ${key}`);\n\t  }\n\t  const map: XmltvTagTranslations = xmltvTagTranslations;\n\t  const reverse: XmltvTagTranslationsReversed = xmltvTagTranslationsReversed;\n\t  if (map && reverse) {\n\t    map.set(key, value);\n\t    reverse.set(value, key);\n\t  }\n\t}\n", "/**\n\t * Adds or modifies a translation for a XMLTV attribute\n\t *\n\t * @param key A valid Xmltv attribute string\n\t * @param value Your translation\n\t */\n\tfunction addAttributeTranslation(key: XmltvAttributes, value: string) {\n\t  if (!xmltvAttributes.includes(key)) {\n\t    throw new Error(`Invalid attribute: ${key}`);\n\t  }\n", "  const map: XmltvAttributeTranslations = xmltvAttributeTranslations;\n\t  const reverse: XmltvAttributeTranslationsReversed =\n\t    xmltvAttributeTranslationsReversed;\n\t  if (map && reverse) {\n\t    map.set(key, value);\n\t    reverse.set(value, key);\n\t  }\n\t}\n\taddTagTranslation(\"display-name\", \"displayName\");\n\taddTagTranslation(\"episode-num\", \"episodeNum\");\n", "addTagTranslation(\"last-chance\", \"lastChance\");\n\taddTagTranslation(\"orig-language\", \"origLanguage\");\n\taddTagTranslation(\"previously-shown\", \"previouslyShown\");\n\taddTagTranslation(\"star-rating\", \"starRating\");\n\taddTagTranslation(\"sub-title\", \"subTitle\");\n\taddTagTranslation(\"channel\", \"channels\");\n\taddTagTranslation(\"programme\", \"programmes\");\n\taddAttributeTranslation(\"generator-info-name\", \"generatorInfoName\");\n\taddAttributeTranslation(\"generator-info-url\", \"generatorInfoUrl\");\n\taddAttributeTranslation(\"pdc-start\", \"pdcStart\");\n", "addAttributeTranslation(\"vps-start\", \"vpsStart\");\n\taddAttributeTranslation(\"source-data-url\", \"sourceDataUrl\");\n\taddAttributeTranslation(\"source-info-name\", \"sourceInfoName\");\n\taddAttributeTranslation(\"source-info-url\", \"sourceInfoUrl\");\n\texport {\n\t  xmltvTagTranslations,\n\t  xmltvTagTranslationsReversed,\n\t  xmltvAttributeTranslations,\n\t  xmltvAttributeTranslationsReversed,\n\t  addTagTranslation,\n", "  addAttributeTranslation,\n\t};\n\texport type { XmltvTagTranslations, XmltvAttributeTranslations };\n"]}
{"filename": "src/utils.ts", "chunked_list": ["export function xmltvTimestampToUtcDate(timestamp: string) {\n\t  timestamp = timestamp.trim().replace(/[\\s]/g, '');\n\t  let mainPart, timeZone;\n\t  if (timestamp.endsWith('Z')) {\n\t    mainPart = timestamp.slice(0, -1);\n\t    timeZone = null; // No adjustment needed for UTC\n\t  } else {\n\t    mainPart = timestamp.slice(0, -5);\n\t    timeZone = timestamp.slice(-5);\n\t  }\n", "  const cleanTimestamp = mainPart.replace(/[-:Zz]/g, '');\n\t  const year = parseInt(cleanTimestamp.slice(0, 4), 10);\n\t  const month = parseInt(cleanTimestamp.slice(4, 6), 10) - 1 || 0;\n\t  const day = parseInt(cleanTimestamp.slice(6, 8), 10) || 1;\n\t  const hours = parseInt(cleanTimestamp.slice(8, 10), 10) || 0;\n\t  const minutes = parseInt(cleanTimestamp.slice(10, 12), 10) || 0;\n\t  const seconds = parseInt(cleanTimestamp.slice(12, 14), 10) || 0;\n\t  const date = new Date(Date.UTC(year, month, day, hours, minutes, seconds));\n\t  if (timeZone) {\n\t    const offsetSign = timeZone.slice(0, 1);\n", "    const offsetHours = parseInt(timeZone.slice(1, 3), 10);\n\t    const offsetMinutes = parseInt(timeZone.slice(3, 5), 10);\n\t    const totalOffsetMinutes = offsetHours * 60 + offsetMinutes;\n\t    if (offsetSign === '+') {\n\t      date.setUTCMinutes(date.getUTCMinutes() - totalOffsetMinutes);\n\t    } else if (offsetSign === '-') {\n\t      date.setUTCMinutes(date.getUTCMinutes() + totalOffsetMinutes);\n\t    }\n\t  }\n\t  return date;\n", "}\n\texport function dateToXmltvUtcTimestamp(date: Date) {\n\t  const padZeroes = (num: number) => (num < 10 ? `0${num}` : num.toString());\n\t  const year = padZeroes(date.getUTCFullYear());\n\t  const month = padZeroes(date.getUTCMonth() + 1);\n\t  const day = padZeroes(date.getUTCDate());\n\t  const hours = padZeroes(date.getUTCHours());\n\t  const minutes = padZeroes(date.getUTCMinutes());\n\t  const seconds = padZeroes(date.getUTCSeconds());\n\t  return `${year}${month}${day}${hours}${minutes}${seconds} +0000`;\n", "}\n\t/**\n\t * Reverses the xmltvTranslations . So that we can convert from\n\t * camelCase to the xmltv format.\n\t */\n\texport function reverseMap<T extends Map<any, any>>(map: Map<any, any>) {\n\t  const reversedMap = new Map<any, any>();\n\t  for (const [key, value] of map.entries()) {\n\t    reversedMap.set(value, key);\n\t  }\n", "  return reversedMap as T;\n\t}\n"]}
{"filename": "src/writer.ts", "chunked_list": ["import type { XmltvDom, XmltvDomNode } from \"./types\";\n\texport function writer(xmltvDom: XmltvDom): string {\n\t  let out = \"\";\n\t  function writeChildren(node: XmltvDom) {\n\t    if (node)\n\t      for (var i = 0; i < node.length; i++) {\n\t        if (typeof node[i] === \"string\") {\n\t          if ((node[i] as string).includes(\"!DOCTYPE\")) {\n\t            out += \"<\" + (node[i] as string).trim() + \">\";\n\t            continue;\n", "          }\n\t          out += (node[i] as string).trim();\n\t        } else {\n\t          writeNode(node[i]);\n\t        }\n\t      }\n\t  }\n\t  function writeNode(node: XmltvDomNode) {\n\t    if (typeof node === \"string\") return;\n\t    out += \"<\" + node.tagName;\n", "    for (const attr in node.attributes) {\n\t      if (\n\t        typeof node.attributes[attr] === \"string\" &&\n\t        node.attributes[attr].indexOf('\"') === -1\n\t      ) {\n\t        out += \" \" + attr + '=\"' + node.attributes[attr].trim() + '\"';\n\t      } else if (typeof node.attributes[attr] === \"boolean\") {\n\t        out += \" \" + attr + '=\"' + (node.attributes[attr] ? \"yes\" : \"no\") + '\"';\n\t      } else {\n\t        out += \" \" + attr + \"='\" + node.attributes[attr] + \"'\";\n", "      }\n\t    }\n\t    if ([\"new\", \"icon\", \"previously-shown\"].indexOf(node.tagName) >= 0) {\n\t      out += \"/>\";\n\t      return;\n\t    }\n\t    if (node.tagName === \"?xml\") {\n\t      out += \"?>\";\n\t      return;\n\t    }\n", "    out += \">\";\n\t    if (typeof node.children === \"boolean\") {\n\t      out += node.children ? \"yes\" : \"no\";\n\t      return;\n\t    }\n\t    writeChildren(node.children);\n\t    out += \"</\" + node.tagName + \">\";\n\t  }\n\t  writeChildren(xmltvDom);\n\t  let header = \"\";\n", "  if (out.indexOf(\"?xml\") === -1) {\n\t    header += '<?xml version=\"1.0\" encoding=\"UTF-8\"?>';\n\t  }\n\t  if (out.indexOf(\"!DOCTYPE\") === -1) {\n\t    header += '<!DOCTYPE tv SYSTEM \"xmltv.dtd\">';\n\t  }\n\t  return header + out;\n\t}\n"]}
{"filename": "src/xmltvTagsAttributes.ts", "chunked_list": ["const xmltvTags = [\n\t  \"actor\",\n\t  \"adapter\",\n\t  \"aspect\",\n\t  \"audio\",\n\t  \"category\",\n\t  \"channel\",\n\t  \"colour\",\n\t  \"commentator\",\n\t  \"composer\",\n", "  \"country\",\n\t  \"credits\",\n\t  \"date\",\n\t  \"desc\",\n\t  \"director\",\n\t  \"display-name\",\n\t  \"editor\",\n\t  \"episode-num\",\n\t  \"guest\",\n\t  \"icon\",\n", "  \"image\",\n\t  \"keyword\",\n\t  \"language\",\n\t  \"last-chance\",\n\t  \"length\",\n\t  \"new\",\n\t  \"orig-language\",\n\t  \"premiere\",\n\t  \"present\",\n\t  \"presenter\",\n", "  \"previously-shown\",\n\t  \"producer\",\n\t  \"programme\",\n\t  \"quality\",\n\t  \"rating\",\n\t  \"review\",\n\t  \"star-rating\",\n\t  \"stereo\",\n\t  \"sub-title\",\n\t  \"subtitles\",\n", "  \"title\",\n\t  \"tv\",\n\t  \"url\",\n\t  \"value\",\n\t  \"video\",\n\t  \"writer\",\n\t] as const;\n\tconst xmltvAttributes = [\n\t  \"channel\",\n\t  \"clumpidx\",\n", "  \"date\",\n\t  \"generator-info-name\",\n\t  \"generator-info-url\",\n\t  \"guest\",\n\t  \"height\",\n\t  \"id\",\n\t  \"lang\",\n\t  \"orient\",\n\t  \"pdc-start\",\n\t  \"reviewer\",\n", "  \"role\",\n\t  \"showview\",\n\t  \"size\",\n\t  \"source-data-url\",\n\t  \"source-info-name\",\n\t  \"source-info-url\",\n\t  \"source\",\n\t  \"src\",\n\t  \"start\",\n\t  \"stop\",\n", "  \"system\",\n\t  \"type\",\n\t  \"units\",\n\t  \"videoplus\",\n\t  \"vps-start\",\n\t  \"width\",\n\t] as const;\n\ttype XmltvTags = (typeof xmltvTags)[number];\n\ttype XmltvAttributes = (typeof xmltvAttributes)[number];\n\texport { xmltvTags, xmltvAttributes, XmltvTags, XmltvAttributes };\n"]}
